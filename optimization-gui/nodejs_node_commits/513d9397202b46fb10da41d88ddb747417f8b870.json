{
    "author": "targos",
    "message": "fs: move fs.promises API to fs/promises\n\nPR-URL: https://github.com/nodejs/node/pull/18777\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "513d9397202b46fb10da41d88ddb747417f8b870",
    "files": [
        {
            "sha": "b0317455728b46e8076f01d52f8af9f445f8af9a",
            "filename": "benchmark/fs/bench-stat-promise.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/513d9397202b46fb10da41d88ddb747417f8b870/benchmark%2Ffs%2Fbench-stat-promise.js",
            "raw_url": "https://github.com/nodejs/node/raw/513d9397202b46fb10da41d88ddb747417f8b870/benchmark%2Ffs%2Fbench-stat-promise.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Ffs%2Fbench-stat-promise.js?ref=513d9397202b46fb10da41d88ddb747417f8b870",
            "patch": "@@ -1,7 +1,7 @@\n 'use strict';\n \n const common = require('../common');\n-const fs = require('fs');\n+const fsPromises = require('fs/promises');\n \n const bench = common.createBenchmark(main, {\n   n: [20e4],\n@@ -10,11 +10,11 @@ const bench = common.createBenchmark(main, {\n \n async function run(n, statType) {\n   const arg = statType === 'fstat' ?\n-    await fs.promises.open(__filename, 'r') : __filename;\n+    await fsPromises.open(__filename, 'r') : __filename;\n   let remaining = n;\n   bench.start();\n   while (remaining-- > 0)\n-    await fs.promises[statType](arg);\n+    await fsPromises[statType](arg);\n   bench.end(n);\n \n   if (typeof arg.close === 'function')"
        },
        {
            "sha": "a4a9e5fd3f2096312faed43b657864b47aaa4cf5",
            "filename": "doc/api/fs.md",
            "status": "modified",
            "additions": 62,
            "deletions": 62,
            "changes": 124,
            "blob_url": "https://github.com/nodejs/node/blob/513d9397202b46fb10da41d88ddb747417f8b870/doc%2Fapi%2Ffs.md",
            "raw_url": "https://github.com/nodejs/node/raw/513d9397202b46fb10da41d88ddb747417f8b870/doc%2Fapi%2Ffs.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ffs.md?ref=513d9397202b46fb10da41d88ddb747417f8b870",
            "patch": "@@ -3231,9 +3231,9 @@ Synchronous versions of [`fs.write()`][]. Returns the number of bytes written.\n \n > Stability: 1 - Experimental\n \n-The `fs.promises` API provides an alternative set of asynchronous file system\n+The `fs/promises` API provides an alternative set of asynchronous file system\n methods that return `Promise` objects rather than using callbacks. The\n-API is accessible via `fs.promises`.\n+API is accessible via `require('fs/promises)`.\n \n ### class: FileHandle\n <!-- YAML\n@@ -3247,11 +3247,11 @@ in that, if the `FileHandle` is not explicitly closed using the\n and will emit a process warning, thereby helping to prevent memory leaks.\n \n Instances of the `FileHandle` object are created internally by the\n-`fs.promises.open()` method.\n+`fsPromises.open()` method.\n \n Unlike callback-based such as `fs.fstat()`, `fs.fchown()`, `fs.fchmod()`,\n `fs.ftruncate()`, `fs.read()`, and `fs.write()`, operations -- all of which\n-use a simple numeric file descriptor, all `fs.promises.*` variations use the\n+use a simple numeric file descriptor, all `fsPromises.*` variations use the\n `FileHandle` class in order to help protect against accidental leaking of\n unclosed file descriptors after a `Promise` is resolved or rejected.\n \n@@ -3317,7 +3317,7 @@ Closes the file descriptor.\n async function openAndClose() {\n   let filehandle;\n   try {\n-    filehandle = await fs.promises.open('thefile.txt', 'r');\n+    filehandle = await fsPromises.open('thefile.txt', 'r');\n   } finally {\n     if (filehandle !== undefined)\n       await filehandle.close();\n@@ -3378,7 +3378,7 @@ object. Otherwise, the data will be a string.\n \n If `options` is a string, then it specifies the encoding.\n \n-When the `path` is a directory, the behavior of `fs.promises.readFile()` is\n+When the `path` is a directory, the behavior of `fsPromises.readFile()` is\n platform-specific. On macOS, Linux, and Windows, the promise will be rejected\n with an error. On FreeBSD, a representation of the directory's contents will be\n returned.\n@@ -3422,8 +3422,8 @@ console.log(fs.readFileSync('temp.txt', 'utf8'));\n // Prints: Node.js\n \n async function doTruncate() {\n-  const fd = await fs.promises.open('temp.txt', 'r+');\n-  await fs.promises.ftruncate(fd, 4);\n+  const fd = await fsPromises.open('temp.txt', 'r+');\n+  await fsPromises.ftruncate(fd, 4);\n   console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints: Node\n }\n \n@@ -3438,8 +3438,8 @@ console.log(fs.readFileSync('temp.txt', 'utf8'));\n // Prints: Node.js\n \n async function doTruncate() {\n-  const fd = await fs.promises.open('temp.txt', 'r+');\n-  await fs.promises.ftruncate(fd, 10);\n+  const fd = await fsPromises.open('temp.txt', 'r+');\n+  await fsPromises.ftruncate(fd, 10);\n   console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints Node.js\\0\\0\\0\n }\n \n@@ -3518,7 +3518,7 @@ The `FileHandle` has to support writing.\n It is unsafe to use `filehandle.writeFile()` multiple times on the same file\n without waiting for the `Promise` to be resolved (or rejected).\n \n-### fs.promises.access(path[, mode])\n+### fsPromises.access(path[, mode])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3547,18 +3547,18 @@ with an `Error` object. The following example checks if the file\n `/etc/passwd` can be read and written by the current process.\n \n ```js\n-fs.promises.access('/etc/passwd', fs.constants.R_OK | fs.constants.W_OK)\n+fsPromises.access('/etc/passwd', fs.constants.R_OK | fs.constants.W_OK)\n   .then(() => console.log('can access'))\n   .catch(() => console.error('cannot access'));\n ```\n \n-Using `fs.promises.access()` to check for the accessibility of a file before\n-calling `fs.promises.open()` is not recommended. Doing so introduces a race\n+Using `fsPromises.access()` to check for the accessibility of a file before\n+calling `fsPromises.open()` is not recommended. Doing so introduces a race\n condition, since other processes may change the file's state between the two\n calls. Instead, user code should open/read/write the file directly and handle\n the error raised if the file is not accessible.\n \n-### fs.promises.appendFile(file, data[, options])\n+### fsPromises.appendFile(file, data[, options])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3578,9 +3578,9 @@ resolved with no arguments upon success.\n If `options` is a string, then it specifies the encoding.\n \n The `file` may be specified as a `FileHandle` that has been opened\n-for appending (using `fs.promises.open()`).\n+for appending (using `fsPromises.open()`).\n \n-### fs.promises.chmod(path, mode)\n+### fsPromises.chmod(path, mode)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3592,7 +3592,7 @@ added: REPLACEME\n Changes the permissions of a file then resolves the `Promise` with no\n arguments upon succces.\n \n-### fs.promises.chown(path, uid, gid)\n+### fsPromises.chown(path, uid, gid)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3605,7 +3605,7 @@ added: REPLACEME\n Changes the ownership of a file then resolves the `Promise` with no arguments\n upon success.\n \n-### fs.promises.copyFile(src, dest[, flags])\n+### fsPromises.copyFile(src, dest[, flags])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3632,7 +3632,7 @@ Example:\n const fs = require('fs');\n \n // destination.txt will be created or overwritten by default.\n-fs.promises.copyFile('source.txt', 'destination.txt')\n+fsPromises.copyFile('source.txt', 'destination.txt')\n   .then(() => console.log('source.txt was copied to destination.txt'))\n   .catch(() => console.log('The file could not be copied'));\n ```\n@@ -3645,12 +3645,12 @@ const fs = require('fs');\n const { COPYFILE_EXCL } = fs.constants;\n \n // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.\n-fs.promises.copyFile('source.txt', 'destination.txt', COPYFILE_EXCL)\n+fsPromises.copyFile('source.txt', 'destination.txt', COPYFILE_EXCL)\n   .then(() => console.log('source.txt was copied to destination.txt'))\n   .catch(() => console.log('The file could not be copied'));\n ```\n \n-### fs.promises.fchmod(filehandle, mode)\n+### fsPromises.fchmod(filehandle, mode)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3662,7 +3662,7 @@ added: REPLACEME\n Asynchronous fchmod(2). The `Promise` is resolved with no arguments upon\n success.\n \n-### fs.promises.fchown(filehandle, uid, gid)\n+### fsPromises.fchown(filehandle, uid, gid)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3675,7 +3675,7 @@ added: REPLACEME\n Changes the ownership of the file represented by `filehandle` then resolves\n the `Promise` with no arguments upon success.\n \n-### fs.promises.fdatasync(filehandle)\n+### fsPromises.fdatasync(filehandle)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3686,7 +3686,7 @@ added: REPLACEME\n Asynchronous fdatasync(2). The `Promise` is resolved with no arguments upon\n success.\n \n-### fs.promises.fstat(filehandle)\n+### fsPromises.fstat(filehandle)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3696,7 +3696,7 @@ added: REPLACEME\n \n Retrieves the [`fs.Stats`][] for the given `filehandle`.\n \n-### fs.promises.fsync(filehandle)\n+### fsPromises.fsync(filehandle)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3707,7 +3707,7 @@ added: REPLACEME\n Asynchronous fsync(2). The `Promise` is resolved with no arguments upon\n success.\n \n-### fs.promises.ftruncate(filehandle[, len])\n+### fsPromises.ftruncate(filehandle[, len])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3730,8 +3730,8 @@ console.log(fs.readFileSync('temp.txt', 'utf8'));\n // Prints: Node.js\n \n async function doTruncate() {\n-  const fd = await fs.promises.open('temp.txt', 'r+');\n-  await fs.promises.ftruncate(fd, 4);\n+  const fd = await fsPromises.open('temp.txt', 'r+');\n+  await fsPromises.ftruncate(fd, 4);\n   console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints: Node\n }\n \n@@ -3746,8 +3746,8 @@ console.log(fs.readFileSync('temp.txt', 'utf8'));\n // Prints: Node.js\n \n async function doTruncate() {\n-  const fd = await fs.promises.open('temp.txt', 'r+');\n-  await fs.promises.ftruncate(fd, 10);\n+  const fd = await fsPromises.open('temp.txt', 'r+');\n+  await fsPromises.ftruncate(fd, 10);\n   console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints Node.js\\0\\0\\0\n }\n \n@@ -3756,7 +3756,7 @@ doTruncate().catch(console.error);\n \n The last three bytes are null bytes ('\\0'), to compensate the over-truncation.\n \n-### fs.promises.futimes(filehandle, atime, mtime)\n+### fsPromises.futimes(filehandle, atime, mtime)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3772,7 +3772,7 @@ Change the file system timestamps of the object referenced by the supplied\n This function does not work on AIX versions before 7.1, it will resolve the\n `Promise` with an error using code `UV_ENOSYS`.\n \n-### fs.promises.lchmod(path, mode)\n+### fsPromises.lchmod(path, mode)\n <!-- YAML\n deprecated: REPLACEME\n -->\n@@ -3784,7 +3784,7 @@ deprecated: REPLACEME\n Changes the permissions on a symbolic link then resolves the `Promise` with\n no arguments upon success. This method is only implemented on macOS.\n \n-### fs.promises.lchown(path, uid, gid)\n+### fsPromises.lchown(path, uid, gid)\n <!-- YAML\n deprecated: REPLACEME\n -->\n@@ -3797,7 +3797,7 @@ deprecated: REPLACEME\n Changes the ownership on a symbolic link then resolves the `Promise` with\n no arguments upon success. This method is only implemented on macOS.\n \n-### fs.promises.link(existingPath, newPath)\n+### fsPromises.link(existingPath, newPath)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3808,7 +3808,7 @@ added: REPLACEME\n \n Asynchronous link(2). The `Promise` is resolved with no arguments upon success.\n \n-### fs.promises.lstat(path)\n+### fsPromises.lstat(path)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3819,7 +3819,7 @@ added: REPLACEME\n Asynchronous lstat(2). The `Promise` is resolved with the [`fs.Stats`][] object\n for the given symbolic link `path`.\n \n-### fs.promises.mkdir(path[, mode])\n+### fsPromises.mkdir(path[, mode])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3831,7 +3831,7 @@ added: REPLACEME\n Asynchronously creates a directory then resolves the `Promise` with no\n arguments upon success.\n \n-### fs.promises.mkdtemp(prefix[, options])\n+### fsPromises.mkdtemp(prefix[, options])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3851,7 +3851,7 @@ object with an `encoding` property specifying the character encoding to use.\n Example:\n \n ```js\n-fs.promises.mkdtemp(path.join(os.tmpdir(), 'foo-'))\n+fsPromises.mkdtemp(path.join(os.tmpdir(), 'foo-'))\n   .catch(console.error);\n ```\n \n@@ -3861,7 +3861,7 @@ intention is to create a temporary directory *within* `/tmp`, the `prefix`\n *must* end with a trailing platform-specific path separator\n (`require('path').sep`).\n \n-### fs.promises.open(path, flags[, mode])\n+### fsPromises.open(path, flags[, mode])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3889,7 +3889,7 @@ An exception occurs if the file does not exist.\n   the potentially stale local cache. It has a very real impact on I/O\n   performance so using this flag is not recommended unless it is needed.\n \n-  Note that this does not turn `fs.promises.open()` into a synchronous blocking\n+  Note that this does not turn `fsPromises.open()` into a synchronous blocking\n   call.\n \n * `'w'` - Open file for writing.\n@@ -3929,7 +3929,7 @@ On Linux, positional writes don't work when the file is opened in append mode.\n The kernel ignores the position argument and always appends the data to\n the end of the file.\n \n-The behavior of `fs.promises.open()` is platform-specific for some\n+The behavior of `fsPromises.open()` is platform-specific for some\n flags. As such, opening a directory on macOS and Linux with the `'a+'` flag will\n return an error. In contrast, on Windows and FreeBSD, a `FileHandle` will be\n returned.\n@@ -3940,11 +3940,11 @@ a colon, Node.js will open a file system stream, as described by\n [this MSDN page][MSDN-Using-Streams].\n \n *Note:* On Windows, opening an existing hidden file using the `w` flag (e.g.\n-using `fs.promises.open()`) will fail with `EPERM`. Existing hidden\n+using `fsPromises.open()`) will fail with `EPERM`. Existing hidden\n files can be opened for writing with the `r+` flag. A call to\n-`fs.promises.ftruncate()` can be used to reset the file contents.\n+`fsPromises.ftruncate()` can be used to reset the file contents.\n \n-### fs.promises.read(filehandle, buffer, offset, length, position)\n+### fsPromises.read(filehandle, buffer, offset, length, position)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3973,7 +3973,7 @@ Following successful read, the `Promise` is resolved with an object with a\n `bytesRead` property specifying the number of bytes read, and a `buffer` property\n that is a reference to the passed in `buffer` argument.\n \n-### fs.promises.readdir(path[, options])\n+### fsPromises.readdir(path[, options])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -3991,7 +3991,7 @@ object with an `encoding` property specifying the character encoding to use for\n the filenames. If the `encoding` is set to `'buffer'`, the filenames returned\n will be passed as `Buffer` objects.\n \n-### fs.promises.readFile(path[, options])\n+### fsPromises.readFile(path[, options])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4010,14 +4010,14 @@ object. Otherwise, the data will be a string.\n \n If `options` is a string, then it specifies the encoding.\n \n-When the `path` is a directory, the behavior of `fs.promises.readFile()` is\n+When the `path` is a directory, the behavior of `fsPromises.readFile()` is\n platform-specific. On macOS, Linux, and Windows, the promise will be rejected\n with an error. On FreeBSD, a representation of the directory's contents will be\n returned.\n \n Any specified `FileHandle` has to support reading.\n \n-### fs.promises.readlink(path[, options])\n+### fsPromises.readlink(path[, options])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4035,7 +4035,7 @@ object with an `encoding` property specifying the character encoding to use for\n the link path returned. If the `encoding` is set to `'buffer'`, the link path\n returned will be passed as a `Buffer` object.\n \n-### fs.promises.realpath(path[, options])\n+### fsPromises.realpath(path[, options])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4060,7 +4060,7 @@ On Linux, when Node.js is linked against musl libc, the procfs file system must\n be mounted on `/proc` in order for this function to work.  Glibc does not have\n this restriction.\n \n-### fs.promises.rename(oldPath, newPath)\n+### fsPromises.rename(oldPath, newPath)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4072,7 +4072,7 @@ added: REPLACEME\n Renames `oldPath` to `newPath` and resolves the `Promise` with no arguments\n upon success.\n \n-### fs.promises.rmdir(path)\n+### fsPromises.rmdir(path)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4083,11 +4083,11 @@ added: REPLACEME\n Removes the directory identified by `path` then resolves the `Promise` with\n no arguments upon success.\n \n-Using `fs.promises.rmdir()` on a file (not a directory) results in the\n+Using `fsPromises.rmdir()` on a file (not a directory) results in the\n `Promise` being rejected with an `ENOENT` error on Windows and an `ENOTDIR`\n error on POSIX.\n \n-### fs.promises.stat(path)\n+### fsPromises.stat(path)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4097,7 +4097,7 @@ added: REPLACEME\n \n The `Promise` is resolved with the [`fs.Stats`][] object for the given `path`.\n \n-### fs.promises.symlink(target, path[, type])\n+### fsPromises.symlink(target, path[, type])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4115,7 +4115,7 @@ The `type` argument is only used on Windows platforms and can be one of `'dir'`,\n points require the destination path to be absolute. When using `'junction'`,\n the `target` argument will automatically be normalized to absolute path.\n \n-### fs.promises.truncate(path[, len])\n+### fsPromises.truncate(path[, len])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4127,7 +4127,7 @@ added: REPLACEME\n Truncates the `path` then resolves the `Promise` with no arguments upon\n success. The `path` *must* be a string or `Buffer`.\n \n-### fs.promises.unlink(path)\n+### fsPromises.unlink(path)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4138,7 +4138,7 @@ added: REPLACEME\n Asynchronous unlink(2). The `Promise` is resolved with no arguments upon\n success.\n \n-### fs.promises.utimes(path, atime, mtime)\n+### fsPromises.utimes(path, atime, mtime)\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4157,7 +4157,7 @@ The `atime` and `mtime` arguments follow these rules:\n - If the value can not be converted to a number, or is `NaN`, `Infinity` or\n   `-Infinity`, an `Error` will be thrown.\n \n-### fs.promises.write(filehandle, buffer[, offset[, length[, position]]])\n+### fsPromises.write(filehandle, buffer[, offset[, length[, position]]])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4182,15 +4182,15 @@ an integer specifying the number of bytes to write.\n should be written. If `typeof position !== 'number'`, the data will be written\n at the current position. See pwrite(2).\n \n-It is unsafe to use `fs.promises.write()` multiple times on the same file\n+It is unsafe to use `fsPromises.write()` multiple times on the same file\n without waiting for the `Promise` to be resolved (or rejected). For this\n scenario, `fs.createWriteStream` is strongly recommended.\n \n On Linux, positional writes do not work when the file is opened in append mode.\n The kernel ignores the position argument and always appends the data to\n the end of the file.\n \n-### fs.promises.writeFile(file, data[, options])\n+### fsPromises.writeFile(file, data[, options])\n <!-- YAML\n added: REPLACEME\n -->\n@@ -4214,7 +4214,7 @@ If `options` is a string, then it specifies the encoding.\n \n Any specified `FileHandle` has to support writing.\n \n-It is unsafe to use `fs.promises.writeFile()` multiple times on the same file\n+It is unsafe to use `fsPromises.writeFile()` multiple times on the same file\n without waiting for the `Promise` to be resolved (or rejected).\n \n "
        },
        {
            "sha": "92e8d4fe3e2d43a12aee49905d4b8f5536197e6a",
            "filename": "lib/fs.js",
            "status": "modified",
            "additions": 0,
            "deletions": 459,
            "changes": 459,
            "blob_url": "https://github.com/nodejs/node/blob/513d9397202b46fb10da41d88ddb747417f8b870/lib%2Ffs.js",
            "raw_url": "https://github.com/nodejs/node/raw/513d9397202b46fb10da41d88ddb747417f8b870/lib%2Ffs.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ffs.js?ref=513d9397202b46fb10da41d88ddb747417f8b870",
            "patch": "@@ -72,9 +72,6 @@ Object.defineProperty(exports, 'constants', {\n   value: constants\n });\n \n-const kHandle = Symbol('handle');\n-const { kUsePromises } = binding;\n-\n const kMinPoolSpace = 128;\n const { kMaxLength } = require('buffer');\n \n@@ -2284,459 +2281,3 @@ Object.defineProperty(fs, 'SyncWriteStream', {\n   set: internalUtil.deprecate((val) => { SyncWriteStream = val; },\n                               'fs.SyncWriteStream is deprecated.', 'DEP0061')\n });\n-\n-// Promises API\n-\n-class FileHandle {\n-  constructor(filehandle) {\n-    this[kHandle] = filehandle;\n-  }\n-\n-  getAsyncId() {\n-    return this[kHandle].getAsyncId();\n-  }\n-\n-  get fd() {\n-    return this[kHandle].fd;\n-  }\n-\n-  appendFile(data, options) {\n-    return promises.appendFile(this, data, options);\n-  }\n-\n-  chmod(mode) {\n-    return promises.fchmod(this, mode);\n-  }\n-\n-  chown(uid, gid) {\n-    return promises.fchown(this, uid, gid);\n-  }\n-\n-  datasync() {\n-    return promises.fdatasync(this);\n-  }\n-\n-  sync() {\n-    return promises.fsync(this);\n-  }\n-\n-\n-  read(buffer, offset, length, position) {\n-    return promises.read(this, buffer, offset, length, position);\n-  }\n-\n-  readFile(options) {\n-    return promises.readFile(this, options);\n-  }\n-\n-  stat() {\n-    return promises.fstat(this);\n-  }\n-\n-  truncate(len = 0) {\n-    return promises.ftruncate(this, len);\n-  }\n-\n-  utimes(atime, mtime) {\n-    return promises.futimes(this, atime, mtime);\n-  }\n-\n-  write(buffer, offset, length, position) {\n-    return promises.write(this, buffer, offset, length, position);\n-  }\n-\n-  writeFile(data, options) {\n-    return promises.writeFile(this, data, options);\n-  }\n-\n-  close() {\n-    return this[kHandle].close();\n-  }\n-}\n-\n-\n-function validateFileHandle(handle) {\n-  if (!(handle instanceof FileHandle))\n-    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n-                               'filehandle', 'FileHandle');\n-}\n-\n-async function writeFileHandle(filehandle, data, options) {\n-  let buffer = isUint8Array(data) ?\n-    data : Buffer.from('' + data, options.encoding || 'utf8');\n-  let remaining = buffer.length;\n-  if (remaining === 0) return;\n-  do {\n-    const { bytesWritten } =\n-      await promises.write(filehandle, buffer, 0,\n-                           Math.min(16384, buffer.length));\n-    remaining -= bytesWritten;\n-    buffer = buffer.slice(bytesWritten);\n-  } while (remaining > 0);\n-}\n-\n-async function readFileHandle(filehandle, options) {\n-  const statFields = await binding.fstat(filehandle.fd, kUsePromises);\n-\n-  let size;\n-  if ((statFields[1/*mode*/] & S_IFMT) === S_IFREG) {\n-    size = statFields[8/*size*/];\n-  } else {\n-    size = 0;\n-  }\n-\n-  if (size === 0)\n-    return Buffer.alloc(0);\n-\n-  if (size > kMaxLength)\n-    throw new errors.RangeError('ERR_BUFFER_TOO_LARGE');\n-\n-  const chunks = [];\n-  const chunkSize = Math.min(size, 16384);\n-  const buf = Buffer.alloc(chunkSize);\n-  let read = 0;\n-  do {\n-    const { bytesRead, buffer } =\n-      await promises.read(filehandle, buf, 0, buf.length);\n-    read = bytesRead;\n-    if (read > 0)\n-      chunks.push(buffer.slice(0, read));\n-  } while (read === chunkSize);\n-\n-  return Buffer.concat(chunks);\n-}\n-\n-// All of the functions in fs.promises are defined as async in order to\n-// ensure that errors thrown cause promise rejections rather than being\n-// thrown synchronously\n-const promises = {\n-  async access(path, mode = fs.F_OK) {\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-\n-    mode = mode | 0;\n-    return binding.access(pathModule.toNamespacedPath(path), mode,\n-                          kUsePromises);\n-  },\n-\n-  async copyFile(src, dest, flags) {\n-    src = getPathFromURL(src);\n-    dest = getPathFromURL(dest);\n-    validatePath(src, 'src');\n-    validatePath(dest, 'dest');\n-    flags = flags | 0;\n-    return binding.copyFile(pathModule.toNamespacedPath(src),\n-                            pathModule.toNamespacedPath(dest),\n-                            flags, kUsePromises);\n-  },\n-\n-  // Note that unlike fs.open() which uses numeric file descriptors,\n-  // promises.open() uses the fs.FileHandle class.\n-  async open(path, flags, mode) {\n-    mode = modeNum(mode, 0o666);\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    validateUint32(mode, 'mode');\n-    return new FileHandle(\n-      await binding.openFileHandle(pathModule.toNamespacedPath(path),\n-                                   stringToFlags(flags),\n-                                   mode, kUsePromises));\n-  },\n-\n-  async read(handle, buffer, offset, length, position) {\n-    validateFileHandle(handle);\n-    validateBuffer(buffer);\n-\n-    offset |= 0;\n-    length |= 0;\n-\n-    if (length === 0)\n-      return { bytesRead: length, buffer };\n-\n-    validateOffsetLengthRead(offset, length, buffer.length);\n-\n-    if (!isUint32(position))\n-      position = -1;\n-\n-    const bytesRead = (await binding.read(handle.fd, buffer, offset, length,\n-                                          position, kUsePromises)) || 0;\n-\n-    return { bytesRead, buffer };\n-  },\n-\n-  async write(handle, buffer, offset, length, position) {\n-    validateFileHandle(handle);\n-\n-    if (buffer.length === 0)\n-      return { bytesWritten: 0, buffer };\n-\n-    if (isUint8Array(buffer)) {\n-      if (typeof offset !== 'number')\n-        offset = 0;\n-      if (typeof length !== 'number')\n-        length = buffer.length - offset;\n-      if (typeof position !== 'number')\n-        position = null;\n-      validateOffsetLengthWrite(offset, length, buffer.byteLength);\n-      const bytesWritten =\n-        (await binding.writeBuffer(handle.fd, buffer, offset,\n-                                   length, position, kUsePromises)) || 0;\n-      return { bytesWritten, buffer };\n-    }\n-\n-    if (typeof buffer !== 'string')\n-      buffer += '';\n-    if (typeof position !== 'function') {\n-      if (typeof offset === 'function') {\n-        position = offset;\n-        offset = null;\n-      } else {\n-        position = length;\n-      }\n-      length = 'utf8';\n-    }\n-    const bytesWritten = (await binding.writeString(handle.fd, buffer, offset,\n-                                                    length, kUsePromises)) || 0;\n-    return { bytesWritten, buffer };\n-  },\n-\n-  async rename(oldPath, newPath) {\n-    oldPath = getPathFromURL(oldPath);\n-    newPath = getPathFromURL(newPath);\n-    validatePath(oldPath, 'oldPath');\n-    validatePath(newPath, 'newPath');\n-    return binding.rename(pathModule.toNamespacedPath(oldPath),\n-                          pathModule.toNamespacedPath(newPath),\n-                          kUsePromises);\n-  },\n-\n-  async truncate(path, len = 0) {\n-    return promises.ftruncate(await promises.open(path, 'r+'), len);\n-  },\n-\n-  async ftruncate(handle, len = 0) {\n-    validateFileHandle(handle);\n-    validateLen(len);\n-    len = Math.max(0, len);\n-    return binding.ftruncate(handle.fd, len, kUsePromises);\n-  },\n-\n-  async rmdir(path) {\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    return binding.rmdir(pathModule.toNamespacedPath(path), kUsePromises);\n-  },\n-\n-  async fdatasync(handle) {\n-    validateFileHandle(handle);\n-    return binding.fdatasync(handle.fd, kUsePromises);\n-  },\n-\n-  async fsync(handle) {\n-    validateFileHandle(handle);\n-    return binding.fsync(handle.fd, kUsePromises);\n-  },\n-\n-  async mkdir(path, mode) {\n-    mode = modeNum(mode, 0o777);\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    validateUint32(mode, 'mode');\n-    return binding.mkdir(pathModule.toNamespacedPath(path), mode, kUsePromises);\n-  },\n-\n-  async readdir(path, options) {\n-    options = getOptions(options, {});\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    return binding.readdir(pathModule.toNamespacedPath(path),\n-                           options.encoding, kUsePromises);\n-  },\n-\n-  async readlink(path, options) {\n-    options = getOptions(options, {});\n-    path = getPathFromURL(path);\n-    validatePath(path, 'oldPath');\n-    return binding.readlink(pathModule.toNamespacedPath(path),\n-                            options.encoding, kUsePromises);\n-  },\n-\n-  async symlink(target, path, type_) {\n-    const type = (typeof type_ === 'string' ? type_ : null);\n-    target = getPathFromURL(target);\n-    path = getPathFromURL(path);\n-    validatePath(target, 'target');\n-    validatePath(path);\n-    return binding.symlink(preprocessSymlinkDestination(target, type, path),\n-                           pathModule.toNamespacedPath(path),\n-                           stringToSymlinkType(type),\n-                           kUsePromises);\n-  },\n-\n-  async fstat(handle) {\n-    validateFileHandle(handle);\n-    return statsFromValues(await binding.fstat(handle.fd, kUsePromises));\n-  },\n-\n-  async lstat(path) {\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    return statsFromValues(\n-      await binding.lstat(pathModule.toNamespacedPath(path), kUsePromises));\n-  },\n-\n-  async stat(path) {\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    return statsFromValues(\n-      await binding.stat(pathModule.toNamespacedPath(path), kUsePromises));\n-  },\n-\n-  async link(existingPath, newPath) {\n-    existingPath = getPathFromURL(existingPath);\n-    newPath = getPathFromURL(newPath);\n-    validatePath(existingPath, 'existingPath');\n-    validatePath(newPath, 'newPath');\n-    return binding.link(pathModule.toNamespacedPath(existingPath),\n-                        pathModule.toNamespacedPath(newPath),\n-                        kUsePromises);\n-  },\n-\n-  async unlink(path) {\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    return binding.unlink(pathModule.toNamespacedPath(path), kUsePromises);\n-  },\n-\n-  async fchmod(handle, mode) {\n-    mode = modeNum(mode);\n-    validateFileHandle(handle);\n-    validateUint32(mode, 'mode');\n-    if (mode < 0 || mode > 0o777)\n-      throw new errors.RangeError('ERR_OUT_OF_RANGE', 'mode');\n-    return binding.fchmod(handle.fd, mode, kUsePromises);\n-  },\n-\n-  async chmod(path, mode) {\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    mode = modeNum(mode);\n-    validateUint32(mode, 'mode');\n-    return binding.chmod(pathModule.toNamespacedPath(path), mode, kUsePromises);\n-  },\n-\n-  async lchmod(path, mode) {\n-    if (constants.O_SYMLINK !== undefined) {\n-      const fd = await promises.open(path,\n-                                     constants.O_WRONLY | constants.O_SYMLINK);\n-      return promises.fchmod(fd, mode).finally(fd.close.bind(fd));\n-    }\n-    throw new errors.Error('ERR_METHOD_NOT_IMPLEMENTED');\n-  },\n-\n-  async lchown(path, uid, gid) {\n-    if (constants.O_SYMLINK !== undefined) {\n-      const fd = await promises.open(path,\n-                                     constants.O_WRONLY | constants.O_SYMLINK);\n-      return promises.fchown(fd, uid, gid).finally(fd.close.bind(fd));\n-    }\n-    throw new errors.Error('ERR_METHOD_NOT_IMPLEMENTED');\n-  },\n-\n-  async fchown(handle, uid, gid) {\n-    validateFileHandle(handle);\n-    validateUint32(uid, 'uid');\n-    validateUint32(gid, 'gid');\n-    return binding.fchown(handle.fd, uid, gid, kUsePromises);\n-  },\n-\n-  async chown(path, uid, gid) {\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    validateUint32(uid, 'uid');\n-    validateUint32(gid, 'gid');\n-    return binding.chown(pathModule.toNamespacedPath(path),\n-                         uid, gid, kUsePromises);\n-  },\n-\n-  async utimes(path, atime, mtime) {\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    return binding.utimes(pathModule.toNamespacedPath(path),\n-                          toUnixTimestamp(atime),\n-                          toUnixTimestamp(mtime),\n-                          kUsePromises);\n-  },\n-\n-  async futimes(handle, atime, mtime) {\n-    validateFileHandle(handle);\n-    atime = toUnixTimestamp(atime, 'atime');\n-    mtime = toUnixTimestamp(mtime, 'mtime');\n-    return binding.futimes(handle.fd, atime, mtime, kUsePromises);\n-  },\n-\n-  async realpath(path, options) {\n-    options = getOptions(options, {});\n-    path = getPathFromURL(path);\n-    validatePath(path);\n-    return binding.realpath(path, options.encoding, kUsePromises);\n-  },\n-\n-  async mkdtemp(prefix, options) {\n-    options = getOptions(options, {});\n-    if (!prefix || typeof prefix !== 'string') {\n-      throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n-                                 'prefix',\n-                                 'string',\n-                                 prefix);\n-    }\n-    nullCheck(prefix);\n-    return binding.mkdtemp(`${prefix}XXXXXX`, options.encoding, kUsePromises);\n-  },\n-\n-  async writeFile(path, data, options) {\n-    options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n-    const flag = options.flag || 'w';\n-\n-    if (path instanceof FileHandle)\n-      return writeFileHandle(path, data, options);\n-\n-    const fd = await promises.open(path, flag, options.mode);\n-    return writeFileHandle(fd, data, options).finally(fd.close.bind(fd));\n-  },\n-\n-  async appendFile(path, data, options) {\n-    options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n-    options = copyObject(options);\n-    options.flag = options.flag || 'a';\n-    return promises.writeFile(path, data, options);\n-  },\n-\n-  async readFile(path, options) {\n-    options = getOptions(options, { flag: 'r' });\n-\n-    if (path instanceof FileHandle)\n-      return readFileHandle(path, options);\n-\n-    const fd = await promises.open(path, options.flag, 0o666);\n-    return readFileHandle(fd, options).finally(fd.close.bind(fd));\n-  }\n-};\n-\n-let warn = true;\n-\n-// TODO(jasnell): Exposing this as a property with a getter works fine with\n-// commonjs but is going to be problematic for named imports support under\n-// ESM. A different approach will have to be followed there.\n-Object.defineProperty(fs, 'promises', {\n-  configurable: true,\n-  enumerable: true,\n-  get() {\n-    if (warn) {\n-      warn = false;\n-      process.emitWarning('The fs.promises API is experimental',\n-                          'ExperimentalWarning');\n-    }\n-    return promises;\n-  }\n-});"
        },
        {
            "sha": "8cbcd963c772c80c06eabe00c94014c42fd38642",
            "filename": "lib/fs/promises.js",
            "status": "added",
            "additions": 507,
            "deletions": 0,
            "changes": 507,
            "blob_url": "https://github.com/nodejs/node/blob/513d9397202b46fb10da41d88ddb747417f8b870/lib%2Ffs%2Fpromises.js",
            "raw_url": "https://github.com/nodejs/node/raw/513d9397202b46fb10da41d88ddb747417f8b870/lib%2Ffs%2Fpromises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ffs%2Fpromises.js?ref=513d9397202b46fb10da41d88ddb747417f8b870",
            "patch": "@@ -0,0 +1,507 @@\n+'use strict';\n+\n+process.emitWarning('The fs/promises API is experimental',\n+                    'ExperimentalWarning');\n+\n+const {\n+  F_OK,\n+  O_SYMLINK,\n+  O_WRONLY,\n+  S_IFMT,\n+  S_IFREG\n+} = process.binding('constants').fs;\n+const binding = process.binding('fs');\n+const { Buffer, kMaxLength } = require('buffer');\n+const errors = require('internal/errors');\n+const { getPathFromURL } = require('internal/url');\n+const { isUint8Array } = require('internal/util/types');\n+const {\n+  copyObject,\n+  getOptions,\n+  isUint32,\n+  modeNum,\n+  nullCheck,\n+  preprocessSymlinkDestination,\n+  statsFromValues,\n+  stringToFlags,\n+  stringToSymlinkType,\n+  toUnixTimestamp,\n+  validateBuffer,\n+  validateLen,\n+  validateOffsetLengthRead,\n+  validateOffsetLengthWrite,\n+  validatePath,\n+  validateUint32\n+} = require('internal/fs');\n+const pathModule = require('path');\n+\n+const kHandle = Symbol('handle');\n+const { kUsePromises } = binding;\n+\n+class FileHandle {\n+  constructor(filehandle) {\n+    this[kHandle] = filehandle;\n+  }\n+\n+  getAsyncId() {\n+    return this[kHandle].getAsyncId();\n+  }\n+\n+  get fd() {\n+    return this[kHandle].fd;\n+  }\n+\n+  appendFile(data, options) {\n+    return appendFile(this, data, options);\n+  }\n+\n+  chmod(mode) {\n+    return fchmod(this, mode);\n+  }\n+\n+  chown(uid, gid) {\n+    return fchown(this, uid, gid);\n+  }\n+\n+  datasync() {\n+    return fdatasync(this);\n+  }\n+\n+  sync() {\n+    return fsync(this);\n+  }\n+\n+  read(buffer, offset, length, position) {\n+    return read(this, buffer, offset, length, position);\n+  }\n+\n+  readFile(options) {\n+    return readFile(this, options);\n+  }\n+\n+  stat() {\n+    return fstat(this);\n+  }\n+\n+  truncate(len = 0) {\n+    return ftruncate(this, len);\n+  }\n+\n+  utimes(atime, mtime) {\n+    return futimes(this, atime, mtime);\n+  }\n+\n+  write(buffer, offset, length, position) {\n+    return write(this, buffer, offset, length, position);\n+  }\n+\n+  writeFile(data, options) {\n+    return writeFile(this, data, options);\n+  }\n+\n+  close() {\n+    return this[kHandle].close();\n+  }\n+}\n+\n+\n+function validateFileHandle(handle) {\n+  if (!(handle instanceof FileHandle))\n+    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n+                               'filehandle', 'FileHandle');\n+}\n+\n+async function writeFileHandle(filehandle, data, options) {\n+  let buffer = isUint8Array(data) ?\n+    data : Buffer.from('' + data, options.encoding || 'utf8');\n+  let remaining = buffer.length;\n+  if (remaining === 0) return;\n+  do {\n+    const { bytesWritten } =\n+      await write(filehandle, buffer, 0,\n+                  Math.min(16384, buffer.length));\n+    remaining -= bytesWritten;\n+    buffer = buffer.slice(bytesWritten);\n+  } while (remaining > 0);\n+}\n+\n+async function readFileHandle(filehandle, options) {\n+  const statFields = await binding.fstat(filehandle.fd, kUsePromises);\n+\n+  let size;\n+  if ((statFields[1/*mode*/] & S_IFMT) === S_IFREG) {\n+    size = statFields[8/*size*/];\n+  } else {\n+    size = 0;\n+  }\n+\n+  if (size === 0)\n+    return Buffer.alloc(0);\n+\n+  if (size > kMaxLength)\n+    throw new errors.RangeError('ERR_BUFFER_TOO_LARGE');\n+\n+  const chunks = [];\n+  const chunkSize = Math.min(size, 16384);\n+  const buf = Buffer.alloc(chunkSize);\n+  let totalRead = 0;\n+  do {\n+    const { bytesRead, buffer } =\n+      await read(filehandle, buf, 0, buf.length);\n+    totalRead = bytesRead;\n+    if (totalRead > 0)\n+      chunks.push(buffer.slice(0, totalRead));\n+  } while (totalRead === chunkSize);\n+\n+  return Buffer.concat(chunks);\n+}\n+\n+// All of the functions are defined as async in order to ensure that errors\n+// thrown cause promise rejections rather than being thrown synchronously.\n+async function access(path, mode = F_OK) {\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+\n+  mode = mode | 0;\n+  return binding.access(pathModule.toNamespacedPath(path), mode,\n+                        kUsePromises);\n+}\n+\n+async function copyFile(src, dest, flags) {\n+  src = getPathFromURL(src);\n+  dest = getPathFromURL(dest);\n+  validatePath(src, 'src');\n+  validatePath(dest, 'dest');\n+  flags = flags | 0;\n+  return binding.copyFile(pathModule.toNamespacedPath(src),\n+                          pathModule.toNamespacedPath(dest),\n+                          flags, kUsePromises);\n+}\n+\n+// Note that unlike fs.open() which uses numeric file descriptors,\n+// fsPromises.open() uses the fs.FileHandle class.\n+async function open(path, flags, mode) {\n+  mode = modeNum(mode, 0o666);\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  validateUint32(mode, 'mode');\n+  return new FileHandle(\n+    await binding.openFileHandle(pathModule.toNamespacedPath(path),\n+                                 stringToFlags(flags),\n+                                 mode, kUsePromises));\n+}\n+\n+async function read(handle, buffer, offset, length, position) {\n+  validateFileHandle(handle);\n+  validateBuffer(buffer);\n+\n+  offset |= 0;\n+  length |= 0;\n+\n+  if (length === 0)\n+    return { bytesRead: length, buffer };\n+\n+  validateOffsetLengthRead(offset, length, buffer.length);\n+\n+  if (!isUint32(position))\n+    position = -1;\n+\n+  const bytesRead = (await binding.read(handle.fd, buffer, offset, length,\n+                                        position, kUsePromises)) || 0;\n+\n+  return { bytesRead, buffer };\n+}\n+\n+async function write(handle, buffer, offset, length, position) {\n+  validateFileHandle(handle);\n+\n+  if (buffer.length === 0)\n+    return { bytesWritten: 0, buffer };\n+\n+  if (isUint8Array(buffer)) {\n+    if (typeof offset !== 'number')\n+      offset = 0;\n+    if (typeof length !== 'number')\n+      length = buffer.length - offset;\n+    if (typeof position !== 'number')\n+      position = null;\n+    validateOffsetLengthWrite(offset, length, buffer.byteLength);\n+    const bytesWritten =\n+      (await binding.writeBuffer(handle.fd, buffer, offset,\n+                                 length, position, kUsePromises)) || 0;\n+    return { bytesWritten, buffer };\n+  }\n+\n+  if (typeof buffer !== 'string')\n+    buffer += '';\n+  if (typeof position !== 'function') {\n+    if (typeof offset === 'function') {\n+      position = offset;\n+      offset = null;\n+    } else {\n+      position = length;\n+    }\n+    length = 'utf8';\n+  }\n+  const bytesWritten = (await binding.writeString(handle.fd, buffer, offset,\n+                                                  length, kUsePromises)) || 0;\n+  return { bytesWritten, buffer };\n+}\n+\n+async function rename(oldPath, newPath) {\n+  oldPath = getPathFromURL(oldPath);\n+  newPath = getPathFromURL(newPath);\n+  validatePath(oldPath, 'oldPath');\n+  validatePath(newPath, 'newPath');\n+  return binding.rename(pathModule.toNamespacedPath(oldPath),\n+                        pathModule.toNamespacedPath(newPath),\n+                        kUsePromises);\n+}\n+\n+async function truncate(path, len = 0) {\n+  return ftruncate(await open(path, 'r+'), len);\n+}\n+\n+async function ftruncate(handle, len = 0) {\n+  validateFileHandle(handle);\n+  validateLen(len);\n+  len = Math.max(0, len);\n+  return binding.ftruncate(handle.fd, len, kUsePromises);\n+}\n+\n+async function rmdir(path) {\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  return binding.rmdir(pathModule.toNamespacedPath(path), kUsePromises);\n+}\n+\n+async function fdatasync(handle) {\n+  validateFileHandle(handle);\n+  return binding.fdatasync(handle.fd, kUsePromises);\n+}\n+\n+async function fsync(handle) {\n+  validateFileHandle(handle);\n+  return binding.fsync(handle.fd, kUsePromises);\n+}\n+\n+async function mkdir(path, mode) {\n+  mode = modeNum(mode, 0o777);\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  validateUint32(mode, 'mode');\n+  return binding.mkdir(pathModule.toNamespacedPath(path), mode, kUsePromises);\n+}\n+\n+async function readdir(path, options) {\n+  options = getOptions(options, {});\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  return binding.readdir(pathModule.toNamespacedPath(path),\n+                         options.encoding, kUsePromises);\n+}\n+\n+async function readlink(path, options) {\n+  options = getOptions(options, {});\n+  path = getPathFromURL(path);\n+  validatePath(path, 'oldPath');\n+  return binding.readlink(pathModule.toNamespacedPath(path),\n+                          options.encoding, kUsePromises);\n+}\n+\n+async function symlink(target, path, type_) {\n+  const type = (typeof type_ === 'string' ? type_ : null);\n+  target = getPathFromURL(target);\n+  path = getPathFromURL(path);\n+  validatePath(target, 'target');\n+  validatePath(path);\n+  return binding.symlink(preprocessSymlinkDestination(target, type, path),\n+                         pathModule.toNamespacedPath(path),\n+                         stringToSymlinkType(type),\n+                         kUsePromises);\n+}\n+\n+async function fstat(handle) {\n+  validateFileHandle(handle);\n+  return statsFromValues(await binding.fstat(handle.fd, kUsePromises));\n+}\n+\n+async function lstat(path) {\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  return statsFromValues(\n+    await binding.lstat(pathModule.toNamespacedPath(path), kUsePromises));\n+}\n+\n+async function stat(path) {\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  return statsFromValues(\n+    await binding.stat(pathModule.toNamespacedPath(path), kUsePromises));\n+}\n+\n+async function link(existingPath, newPath) {\n+  existingPath = getPathFromURL(existingPath);\n+  newPath = getPathFromURL(newPath);\n+  validatePath(existingPath, 'existingPath');\n+  validatePath(newPath, 'newPath');\n+  return binding.link(pathModule.toNamespacedPath(existingPath),\n+                      pathModule.toNamespacedPath(newPath),\n+                      kUsePromises);\n+}\n+\n+async function unlink(path) {\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  return binding.unlink(pathModule.toNamespacedPath(path), kUsePromises);\n+}\n+\n+async function fchmod(handle, mode) {\n+  mode = modeNum(mode);\n+  validateFileHandle(handle);\n+  validateUint32(mode, 'mode');\n+  if (mode < 0 || mode > 0o777)\n+    throw new errors.RangeError('ERR_OUT_OF_RANGE', 'mode');\n+  return binding.fchmod(handle.fd, mode, kUsePromises);\n+}\n+\n+async function chmod(path, mode) {\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  mode = modeNum(mode);\n+  validateUint32(mode, 'mode');\n+  return binding.chmod(pathModule.toNamespacedPath(path), mode, kUsePromises);\n+}\n+\n+async function lchmod(path, mode) {\n+  if (O_SYMLINK !== undefined) {\n+    const fd = await open(path,\n+                          O_WRONLY | O_SYMLINK);\n+    return fchmod(fd, mode).finally(fd.close.bind(fd));\n+  }\n+  throw new errors.Error('ERR_METHOD_NOT_IMPLEMENTED');\n+}\n+\n+async function lchown(path, uid, gid) {\n+  if (O_SYMLINK !== undefined) {\n+    const fd = await open(path,\n+                          O_WRONLY | O_SYMLINK);\n+    return fchmod(fd, uid, gid).finally(fd.close.bind(fd));\n+  }\n+  throw new errors.Error('ERR_METHOD_NOT_IMPLEMENTED');\n+}\n+\n+async function fchown(handle, uid, gid) {\n+  validateFileHandle(handle);\n+  validateUint32(uid, 'uid');\n+  validateUint32(gid, 'gid');\n+  return binding.fchown(handle.fd, uid, gid, kUsePromises);\n+}\n+\n+async function chown(path, uid, gid) {\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  validateUint32(uid, 'uid');\n+  validateUint32(gid, 'gid');\n+  return binding.chown(pathModule.toNamespacedPath(path),\n+                       uid, gid, kUsePromises);\n+}\n+\n+async function utimes(path, atime, mtime) {\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  return binding.utimes(pathModule.toNamespacedPath(path),\n+                        toUnixTimestamp(atime),\n+                        toUnixTimestamp(mtime),\n+                        kUsePromises);\n+}\n+\n+async function futimes(handle, atime, mtime) {\n+  validateFileHandle(handle);\n+  atime = toUnixTimestamp(atime, 'atime');\n+  mtime = toUnixTimestamp(mtime, 'mtime');\n+  return binding.futimes(handle.fd, atime, mtime, kUsePromises);\n+}\n+\n+async function realpath(path, options) {\n+  options = getOptions(options, {});\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  return binding.realpath(path, options.encoding, kUsePromises);\n+}\n+\n+async function mkdtemp(prefix, options) {\n+  options = getOptions(options, {});\n+  if (!prefix || typeof prefix !== 'string') {\n+    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n+                               'prefix',\n+                               'string',\n+                               prefix);\n+  }\n+  nullCheck(prefix);\n+  return binding.mkdtemp(`${prefix}XXXXXX`, options.encoding, kUsePromises);\n+}\n+\n+async function writeFile(path, data, options) {\n+  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n+  const flag = options.flag || 'w';\n+\n+  if (path instanceof FileHandle)\n+    return writeFileHandle(path, data, options);\n+\n+  const fd = await open(path, flag, options.mode);\n+  return writeFileHandle(fd, data, options).finally(fd.close.bind(fd));\n+}\n+\n+async function appendFile(path, data, options) {\n+  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n+  options = copyObject(options);\n+  options.flag = options.flag || 'a';\n+  return writeFile(path, data, options);\n+}\n+\n+async function readFile(path, options) {\n+  options = getOptions(options, { flag: 'r' });\n+\n+  if (path instanceof FileHandle)\n+    return readFileHandle(path, options);\n+\n+  const fd = await open(path, options.flag, 0o666);\n+  return readFileHandle(fd, options).finally(fd.close.bind(fd));\n+}\n+\n+module.exports = {\n+  access,\n+  copyFile,\n+  open,\n+  read,\n+  write,\n+  rename,\n+  truncate,\n+  ftruncate,\n+  rmdir,\n+  fdatasync,\n+  fsync,\n+  mkdir,\n+  readdir,\n+  readlink,\n+  symlink,\n+  fstat,\n+  lstat,\n+  stat,\n+  link,\n+  unlink,\n+  fchmod,\n+  chmod,\n+  lchmod,\n+  lchown,\n+  fchown,\n+  chown,\n+  utimes,\n+  futimes,\n+  realpath,\n+  mkdtemp,\n+  writeFile,\n+  appendFile,\n+  readFile\n+};"
        },
        {
            "sha": "08eee42856077082bcd1c99c96eb4e4675c8f837",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/513d9397202b46fb10da41d88ddb747417f8b870/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/513d9397202b46fb10da41d88ddb747417f8b870/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=513d9397202b46fb10da41d88ddb747417f8b870",
            "patch": "@@ -39,6 +39,7 @@\n       'lib/domain.js',\n       'lib/events.js',\n       'lib/fs.js',\n+      'lib/fs/promises.js',\n       'lib/http.js',\n       'lib/http2.js',\n       'lib/_http_agent.js',"
        },
        {
            "sha": "e2ae289b180bc226a326ad4cf38e70fb21bf42a7",
            "filename": "test/parallel/test-fs-promises-writefile.js",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/513d9397202b46fb10da41d88ddb747417f8b870/test%2Fparallel%2Ftest-fs-promises-writefile.js",
            "raw_url": "https://github.com/nodejs/node/raw/513d9397202b46fb10da41d88ddb747417f8b870/test%2Fparallel%2Ftest-fs-promises-writefile.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-promises-writefile.js?ref=513d9397202b46fb10da41d88ddb747417f8b870",
            "patch": "@@ -2,6 +2,7 @@\n \n const common = require('../common');\n const fs = require('fs');\n+const fsPromises = require('fs/promises');\n const path = require('path');\n const tmpdir = require('../common/tmpdir');\n const assert = require('assert');\n@@ -16,20 +17,20 @@ const buffer = Buffer.from('abc'.repeat(1000));\n const buffer2 = Buffer.from('xyz'.repeat(1000));\n \n async function doWrite() {\n-  await fs.promises.writeFile(dest, buffer);\n+  await fsPromises.writeFile(dest, buffer);\n   const data = fs.readFileSync(dest);\n   assert.deepStrictEqual(data, buffer);\n }\n \n async function doAppend() {\n-  await fs.promises.appendFile(dest, buffer2);\n+  await fsPromises.appendFile(dest, buffer2);\n   const data = fs.readFileSync(dest);\n   const buf = Buffer.concat([buffer, buffer2]);\n   assert.deepStrictEqual(buf, data);\n }\n \n async function doRead() {\n-  const data = await fs.promises.readFile(dest);\n+  const data = await fsPromises.readFile(dest);\n   const buf = fs.readFileSync(dest);\n   assert.deepStrictEqual(buf, data);\n }"
        },
        {
            "sha": "e24374602bfc3f1dbb34565f2f89b495890f1d28",
            "filename": "test/parallel/test-fs-promises.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/513d9397202b46fb10da41d88ddb747417f8b870/test%2Fparallel%2Ftest-fs-promises.js",
            "raw_url": "https://github.com/nodejs/node/raw/513d9397202b46fb10da41d88ddb747417f8b870/test%2Fparallel%2Ftest-fs-promises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-promises.js?ref=513d9397202b46fb10da41d88ddb747417f8b870",
            "patch": "@@ -5,7 +5,7 @@ const assert = require('assert');\n const tmpdir = require('../common/tmpdir');\n const fixtures = require('../common/fixtures');\n const path = require('path');\n-const fs = require('fs');\n+const fsPromises = require('fs/promises');\n const {\n   access,\n   chmod,\n@@ -32,7 +32,7 @@ const {\n   write,\n   unlink,\n   utimes\n-} = fs.promises;\n+} = fsPromises;\n \n const tmpDir = tmpdir.path;\n "
        },
        {
            "sha": "1877d53dbfd3ae81703717f99454a0d8adef4470",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/513d9397202b46fb10da41d88ddb747417f8b870/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/513d9397202b46fb10da41d88ddb747417f8b870/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=513d9397202b46fb10da41d88ddb747417f8b870",
            "patch": "@@ -3,6 +3,7 @@\n const common = require('../common');\n const assert = require('assert');\n const fs = require('fs');\n+const fsPromises = require('fs/promises');\n const net = require('net');\n const providers = Object.assign({}, process.binding('async_wrap').Providers);\n const fixtures = require('../common/fixtures');\n@@ -171,7 +172,7 @@ if (common.hasCrypto) { // eslint-disable-line crypto-check\n \n {\n   async function openTest() {\n-    const fd = await fs.promises.open(__filename, 'r');\n+    const fd = await fsPromises.open(__filename, 'r');\n     testInitialized(fd, 'FileHandle');\n     await fd.close();\n   }"
        }
    ],
    "stats": {
        "total": 1111,
        "additions": 581,
        "deletions": 530
    }
}