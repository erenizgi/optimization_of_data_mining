{
    "author": "jasnell",
    "message": "src: move CallbackScope to separate cc/h\n\nPR-URL: https://github.com/nodejs/node/pull/20789\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>",
    "sha": "fbd1c4977ed963e2aaebee871d3be4b0a090cc18",
    "files": [
        {
            "sha": "8351a45686db203443400a571871bd6873058f0e",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=fbd1c4977ed963e2aaebee871d3be4b0a090cc18",
            "patch": "@@ -304,6 +304,7 @@\n \n       'sources': [\n         'src/async_wrap.cc',\n+        'src/callback_scope.cc',\n         'src/cares_wrap.cc',\n         'src/connection_wrap.cc',\n         'src/connect_wrap.cc',\n@@ -365,6 +366,7 @@\n         'src/async_wrap-inl.h',\n         'src/base_object.h',\n         'src/base_object-inl.h',\n+        'src/callback_scope.h',\n         'src/connection_wrap.h',\n         'src/connect_wrap.h',\n         'src/env.h',"
        },
        {
            "sha": "5539d77c70cb4ea386f783ec9f0a97bb88078be4",
            "filename": "src/callback_scope.cc",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/nodejs/node/blob/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/src%2Fcallback_scope.cc",
            "raw_url": "https://github.com/nodejs/node/raw/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/src%2Fcallback_scope.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fcallback_scope.cc?ref=fbd1c4977ed963e2aaebee871d3be4b0a090cc18",
            "patch": "@@ -0,0 +1,126 @@\n+#include \"node.h\"\n+#include \"callback_scope.h\"\n+#include \"async_wrap.h\"\n+#include \"async_wrap-inl.h\"\n+#include \"env.h\"\n+#include \"env-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node {\n+\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+\n+using AsyncHooks = Environment::AsyncHooks;\n+\n+CallbackScope::CallbackScope(Isolate* isolate,\n+                             Local<Object> object,\n+                             async_context asyncContext)\n+  : private_(new InternalCallbackScope(Environment::GetCurrent(isolate),\n+                                       object,\n+                                       asyncContext)),\n+    try_catch_(isolate) {\n+  try_catch_.SetVerbose(true);\n+}\n+\n+CallbackScope::~CallbackScope() {\n+  if (try_catch_.HasCaught())\n+    private_->MarkAsFailed();\n+  delete private_;\n+}\n+\n+InternalCallbackScope::InternalCallbackScope(AsyncWrap* async_wrap)\n+    : InternalCallbackScope(async_wrap->env(),\n+                            async_wrap->object(),\n+                            { async_wrap->get_async_id(),\n+                              async_wrap->get_trigger_async_id() }) {}\n+\n+InternalCallbackScope::InternalCallbackScope(Environment* env,\n+                                             Local<Object> object,\n+                                             const async_context& asyncContext,\n+                                             ResourceExpectation expect)\n+  : env_(env),\n+    async_context_(asyncContext),\n+    object_(object),\n+    callback_scope_(env) {\n+  if (expect == kRequireResource) {\n+    CHECK(!object.IsEmpty());\n+  }\n+\n+  if (!env->can_call_into_js()) {\n+    failed_ = true;\n+    return;\n+  }\n+\n+  HandleScope handle_scope(env->isolate());\n+  // If you hit this assertion, you forgot to enter the v8::Context first.\n+  CHECK_EQ(Environment::GetCurrent(env->isolate()), env);\n+\n+  if (asyncContext.async_id != 0) {\n+    // No need to check a return value because the application will exit if\n+    // an exception occurs.\n+    AsyncWrap::EmitBefore(env, asyncContext.async_id);\n+  }\n+\n+  if (!IsInnerMakeCallback()) {\n+    env->tick_info()->set_has_thrown(false);\n+  }\n+\n+  env->async_hooks()->push_async_ids(async_context_.async_id,\n+                               async_context_.trigger_async_id);\n+  pushed_ids_ = true;\n+}\n+\n+InternalCallbackScope::~InternalCallbackScope() {\n+  Close();\n+}\n+\n+void InternalCallbackScope::Close() {\n+  if (closed_) return;\n+  closed_ = true;\n+  HandleScope handle_scope(env_->isolate());\n+\n+  if (pushed_ids_)\n+    env_->async_hooks()->pop_async_id(async_context_.async_id);\n+\n+  if (failed_) return;\n+\n+  if (async_context_.async_id != 0) {\n+    AsyncWrap::EmitAfter(env_, async_context_.async_id);\n+  }\n+\n+  if (IsInnerMakeCallback()) {\n+    return;\n+  }\n+\n+  Environment::TickInfo* tick_info = env_->tick_info();\n+\n+  if (!env_->can_call_into_js()) return;\n+  if (!tick_info->has_scheduled()) {\n+    env_->isolate()->RunMicrotasks();\n+  }\n+\n+  // Make sure the stack unwound properly. If there are nested MakeCallback's\n+  // then it should return early and not reach this code.\n+  if (env_->async_hooks()->fields()[AsyncHooks::kTotals]) {\n+    CHECK_EQ(env_->execution_async_id(), 0);\n+    CHECK_EQ(env_->trigger_async_id(), 0);\n+  }\n+\n+  if (!tick_info->has_scheduled() && !tick_info->has_promise_rejections()) {\n+    return;\n+  }\n+\n+  Local<Object> process = env_->process_object();\n+\n+  if (!env_->can_call_into_js()) return;\n+\n+  if (env_->tick_callback_function()->Call(process, 0, nullptr).IsEmpty()) {\n+    env_->tick_info()->set_has_thrown(true);\n+    failed_ = true;\n+  }\n+}\n+\n+}  // namespace node"
        },
        {
            "sha": "11fee0dd57ac813b00b666e3cd6b8822c3a3fbe3",
            "filename": "src/callback_scope.h",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/nodejs/node/blob/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/src%2Fcallback_scope.h",
            "raw_url": "https://github.com/nodejs/node/raw/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/src%2Fcallback_scope.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fcallback_scope.h?ref=fbd1c4977ed963e2aaebee871d3be4b0a090cc18",
            "patch": "@@ -0,0 +1,56 @@\n+#ifndef SRC_CALLBACK_SCOPE_H_\n+#define SRC_CALLBACK_SCOPE_H_\n+\n+#ifdef _WIN32\n+# ifndef BUILDING_NODE_EXTENSION\n+#   define NODE_EXTERN __declspec(dllexport)\n+# else\n+#   define NODE_EXTERN __declspec(dllimport)\n+# endif\n+#else\n+# define NODE_EXTERN /* nothing */\n+#endif\n+\n+#include \"v8.h\"\n+\n+namespace node {\n+\n+typedef double async_id;\n+struct async_context {\n+  ::node::async_id async_id;\n+  ::node::async_id trigger_async_id;\n+};\n+\n+class InternalCallbackScope;\n+\n+/* This class works like `MakeCallback()` in that it sets up a specific\n+ * asyncContext as the current one and informs the async_hooks and domains\n+ * modules that this context is currently active.\n+ *\n+ * `MakeCallback()` is a wrapper around this class as well as\n+ * `Function::Call()`. Either one of these mechanisms needs to be used for\n+ * top-level calls into JavaScript (i.e. without any existing JS stack).\n+ *\n+ * This object should be stack-allocated to ensure that it is contained in a\n+ * valid HandleScope.\n+ */\n+class NODE_EXTERN CallbackScope {\n+ public:\n+  CallbackScope(v8::Isolate* isolate,\n+                v8::Local<v8::Object> resource,\n+                async_context asyncContext);\n+  ~CallbackScope();\n+\n+ private:\n+  InternalCallbackScope* private_;\n+  v8::TryCatch try_catch_;\n+\n+  void operator=(const CallbackScope&) = delete;\n+  void operator=(CallbackScope&&) = delete;\n+  CallbackScope(const CallbackScope&) = delete;\n+  CallbackScope(CallbackScope&&) = delete;\n+};\n+\n+}  // namespace node\n+\n+#endif  // SRC_CALLBACK_SCOPE_H_"
        },
        {
            "sha": "cef4127e2c3239d0dac849b6f8ce0fd86d9fb921",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 111,
            "changes": 111,
            "blob_url": "https://github.com/nodejs/node/blob/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=fbd1c4977ed963e2aaebee871d3be4b0a090cc18",
            "patch": "@@ -170,8 +170,6 @@ using v8::Undefined;\n using v8::V8;\n using v8::Value;\n \n-using AsyncHooks = Environment::AsyncHooks;\n-\n static Mutex process_mutex;\n static Mutex environ_mutex;\n \n@@ -924,115 +922,6 @@ void RemoveEnvironmentCleanupHook(v8::Isolate* isolate,\n   env->RemoveCleanupHook(fun, arg);\n }\n \n-\n-CallbackScope::CallbackScope(Isolate* isolate,\n-                             Local<Object> object,\n-                             async_context asyncContext)\n-  : private_(new InternalCallbackScope(Environment::GetCurrent(isolate),\n-                                       object,\n-                                       asyncContext)),\n-    try_catch_(isolate) {\n-  try_catch_.SetVerbose(true);\n-}\n-\n-CallbackScope::~CallbackScope() {\n-  if (try_catch_.HasCaught())\n-    private_->MarkAsFailed();\n-  delete private_;\n-}\n-\n-InternalCallbackScope::InternalCallbackScope(AsyncWrap* async_wrap)\n-    : InternalCallbackScope(async_wrap->env(),\n-                            async_wrap->object(),\n-                            { async_wrap->get_async_id(),\n-                              async_wrap->get_trigger_async_id() }) {}\n-\n-InternalCallbackScope::InternalCallbackScope(Environment* env,\n-                                             Local<Object> object,\n-                                             const async_context& asyncContext,\n-                                             ResourceExpectation expect)\n-  : env_(env),\n-    async_context_(asyncContext),\n-    object_(object),\n-    callback_scope_(env) {\n-  if (expect == kRequireResource) {\n-    CHECK(!object.IsEmpty());\n-  }\n-\n-  if (!env->can_call_into_js()) {\n-    failed_ = true;\n-    return;\n-  }\n-\n-  HandleScope handle_scope(env->isolate());\n-  // If you hit this assertion, you forgot to enter the v8::Context first.\n-  CHECK_EQ(Environment::GetCurrent(env->isolate()), env);\n-\n-  if (asyncContext.async_id != 0) {\n-    // No need to check a return value because the application will exit if\n-    // an exception occurs.\n-    AsyncWrap::EmitBefore(env, asyncContext.async_id);\n-  }\n-\n-  if (!IsInnerMakeCallback()) {\n-    env->tick_info()->set_has_thrown(false);\n-  }\n-\n-  env->async_hooks()->push_async_ids(async_context_.async_id,\n-                               async_context_.trigger_async_id);\n-  pushed_ids_ = true;\n-}\n-\n-InternalCallbackScope::~InternalCallbackScope() {\n-  Close();\n-}\n-\n-void InternalCallbackScope::Close() {\n-  if (closed_) return;\n-  closed_ = true;\n-  HandleScope handle_scope(env_->isolate());\n-\n-  if (pushed_ids_)\n-    env_->async_hooks()->pop_async_id(async_context_.async_id);\n-\n-  if (failed_) return;\n-\n-  if (async_context_.async_id != 0) {\n-    AsyncWrap::EmitAfter(env_, async_context_.async_id);\n-  }\n-\n-  if (IsInnerMakeCallback()) {\n-    return;\n-  }\n-\n-  Environment::TickInfo* tick_info = env_->tick_info();\n-\n-  if (!env_->can_call_into_js()) return;\n-  if (!tick_info->has_scheduled()) {\n-    env_->isolate()->RunMicrotasks();\n-  }\n-\n-  // Make sure the stack unwound properly. If there are nested MakeCallback's\n-  // then it should return early and not reach this code.\n-  if (env_->async_hooks()->fields()[AsyncHooks::kTotals]) {\n-    CHECK_EQ(env_->execution_async_id(), 0);\n-    CHECK_EQ(env_->trigger_async_id(), 0);\n-  }\n-\n-  if (!tick_info->has_scheduled() && !tick_info->has_promise_rejections()) {\n-    return;\n-  }\n-\n-  Local<Object> process = env_->process_object();\n-\n-  if (!env_->can_call_into_js()) return;\n-\n-  if (env_->tick_callback_function()->Call(process, 0, nullptr).IsEmpty()) {\n-    env_->tick_info()->set_has_thrown(true);\n-    failed_ = true;\n-  }\n-}\n-\n MaybeLocal<Value> InternalMakeCallback(Environment* env,\n                                        Local<Object> recv,\n                                        const Local<Function> callback,"
        },
        {
            "sha": "e10e393cd64d4bcca3d7e6892db21e6c9d25b6fc",
            "filename": "src/node.h",
            "status": "modified",
            "additions": 1,
            "deletions": 36,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/src%2Fnode.h",
            "raw_url": "https://github.com/nodejs/node/raw/fbd1c4977ed963e2aaebee871d3be4b0a090cc18/src%2Fnode.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.h?ref=fbd1c4977ed963e2aaebee871d3be4b0a090cc18",
            "patch": "@@ -63,6 +63,7 @@\n #include \"v8.h\"  // NOLINT(build/include_order)\n #include \"v8-platform.h\"  // NOLINT(build/include_order)\n #include \"node_version.h\"  // NODE_MODULE_VERSION\n+#include \"callback_scope.h\"\n \n #define NODE_MAKE_VERSION(major, minor, patch)                                \\\n   ((major) * 0x1000 + (minor) * 0x100 + (patch))\n@@ -593,12 +594,6 @@ typedef void (*promise_hook_func) (v8::PromiseHookType type,\n                                    v8::Local<v8::Value> parent,\n                                    void* arg);\n \n-typedef double async_id;\n-struct async_context {\n-  ::node::async_id async_id;\n-  ::node::async_id trigger_async_id;\n-};\n-\n /* Registers an additional v8::PromiseHook wrapper. This API exists because V8\n  * itself supports only a single PromiseHook. */\n NODE_EXTERN void AddPromiseHook(v8::Isolate* isolate,\n@@ -647,36 +642,6 @@ NODE_EXTERN async_context EmitAsyncInit(v8::Isolate* isolate,\n NODE_EXTERN void EmitAsyncDestroy(v8::Isolate* isolate,\n                                   async_context asyncContext);\n \n-class InternalCallbackScope;\n-\n-/* This class works like `MakeCallback()` in that it sets up a specific\n- * asyncContext as the current one and informs the async_hooks and domains\n- * modules that this context is currently active.\n- *\n- * `MakeCallback()` is a wrapper around this class as well as\n- * `Function::Call()`. Either one of these mechanisms needs to be used for\n- * top-level calls into JavaScript (i.e. without any existing JS stack).\n- *\n- * This object should be stack-allocated to ensure that it is contained in a\n- * valid HandleScope.\n- */\n-class NODE_EXTERN CallbackScope {\n- public:\n-  CallbackScope(v8::Isolate* isolate,\n-                v8::Local<v8::Object> resource,\n-                async_context asyncContext);\n-  ~CallbackScope();\n-\n- private:\n-  InternalCallbackScope* private_;\n-  v8::TryCatch try_catch_;\n-\n-  void operator=(const CallbackScope&) = delete;\n-  void operator=(CallbackScope&&) = delete;\n-  CallbackScope(const CallbackScope&) = delete;\n-  CallbackScope(CallbackScope&&) = delete;\n-};\n-\n /* An API specific to emit before/after callbacks is unnecessary because\n  * MakeCallback will automatically call them for you.\n  *"
        }
    ],
    "stats": {
        "total": 332,
        "additions": 185,
        "deletions": 147
    }
}