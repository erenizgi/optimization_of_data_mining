{
    "author": "cjihrig",
    "message": "deps: upgrade libuv to 1.19.2\n\nPR-URL: https://github.com/nodejs/node/pull/18918\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "3a191229418dcc0e21956847993b1702c88a923b",
    "files": [
        {
            "sha": "fcb0aac3e83b10d816f79d1cd155603a3e656587",
            "filename": "deps/uv/AUTHORS",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FAUTHORS?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -325,3 +325,8 @@ Anna Henningsen <anna@addaleax.net>\n Jérémy Lal <kapouer@melix.org>\n Ben Wijen <ben@wijen.net>\n elephantp <elephantp@elephantp.blog>\n+Felix Yan <felixonmars@archlinux.org>\n+Mason X <me@masonx.ca>\n+Jesse Gorzinski <jgorzinski@gmail.com>\n+Ryuichi KAWAMATA <ryuichi.kawamata@dena.jp>\n+Joyee Cheung <joyeec9h3@gmail.com>"
        },
        {
            "sha": "509a1d1571d4982f9ce5036cb67c9d198f3544dc",
            "filename": "deps/uv/ChangeLog",
            "status": "modified",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2FChangeLog",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2FChangeLog",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FChangeLog?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -1,3 +1,48 @@\n+2018.02.22, Version 1.19.2 (Stable), c5afc37e2a8a70d8ab0da8dac10b77ba78c0488c\n+\n+Changes since version 1.19.1:\n+\n+* test: fix incorrect asserts (cjihrig)\n+\n+* test: fix a typo in test-fork.c (Felix Yan)\n+\n+* build: remove long-obsolete gyp workarounds (Ben Noordhuis)\n+\n+* build: split off tests into separate gyp file (Ben Noordhuis)\n+\n+* test: check uv_cond_timedwait more carefully (Jamie Davis)\n+\n+* include,src: introduce UV__ERR() macro (Mason X)\n+\n+* build: add url field to libuv.pc (Ben Noordhuis)\n+\n+* doc: mark IBM i as Tier 3 support (Jesse Gorzinski)\n+\n+* win,build: correct C2059 errors (Michael Fero)\n+\n+* zos: fix timeout for condition variable (jBarz)\n+\n+* win: CREATE_NO_WINDOW when stdio is not inherited (Nick Logan)\n+\n+* build: fix commmon.gypi comment (Ryuichi KAWAMATA)\n+\n+* doc: document uv_timer_start() on an active timer (Vladimír Čunát)\n+\n+* doc: add note about handle movability (Bartosz Sosnowski)\n+\n+* doc: fix syntax error in loop documentation (Bartosz Sosnowski)\n+\n+* osx,stream: retry sending handle on EMSGSIZE error (Santiago Gimeno)\n+\n+* unix: delay fs req register until after validation (cjihrig)\n+\n+* test: add tests for bad inputs (Joyee Cheung)\n+\n+* unix,win: ensure req->bufs is freed (cjihrig)\n+\n+* test: add additional fs memory management checks (cjihrig)\n+\n+\n 2018.01.20, Version 1.19.1 (Stable), 8202d1751196c2374ad370f7f3779daef89befae\n \n Changes since version 1.19.0:"
        },
        {
            "sha": "077191086ce524754fbc5e1d912ebc72e753925e",
            "filename": "deps/uv/SUPPORTED_PLATFORMS.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2FSUPPORTED_PLATFORMS.md",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2FSUPPORTED_PLATFORMS.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FSUPPORTED_PLATFORMS.md?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -11,6 +11,7 @@\n | Linux with musl | Tier 2 | musl >= 1.0 | |\n | SmartOS | Tier 2 | >= 14.4 | Maintainers: @libuv/smartos |\n | Android | Tier 3 | NDK >= r15b | |\n+| IBM i | Tier 3 | >= IBM i 7.2 | Maintainers: @libuv/ibmi |\n | MinGW | Tier 3 | MinGW32 and MinGW-w64 | |\n | SunOS | Tier 3 | Solaris 121 and later | |\n | Other | Tier 3 | N/A | |"
        },
        {
            "sha": "572a1633b0b5552ef4fa73ba6ef219c517a6232e",
            "filename": "deps/uv/common.gypi",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fcommon.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fcommon.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fcommon.gypi?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -16,9 +16,9 @@\n           'VCCLCompilerTool': {\n             'target_conditions': [\n               ['uv_library==\"static_library\"', {\n-                'RuntimeLibrary': 1, # static debug\n+                'RuntimeLibrary': 1, # /MTd static debug\n               }, {\n-                'RuntimeLibrary': 3, # DLL debug\n+                'RuntimeLibrary': 3, # /MDd DLL debug\n               }],\n             ],\n             'Optimization': 0, # /Od, no optimization\n@@ -52,9 +52,9 @@\n           'VCCLCompilerTool': {\n             'target_conditions': [\n               ['uv_library==\"static_library\"', {\n-                'RuntimeLibrary': 0, # static release\n+                'RuntimeLibrary': 0, # /MT static release\n               }, {\n-                'RuntimeLibrary': 2, # debug release\n+                'RuntimeLibrary': 2, # /MD DLL release\n               }],\n             ],\n             'Optimization': 3, # /Ox, full optimization"
        },
        {
            "sha": "4074e77841d48945ba7ed0c718fa83d17208bc0f",
            "filename": "deps/uv/configure.ac",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fconfigure.ac",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fconfigure.ac",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fconfigure.ac?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -13,7 +13,7 @@\n # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n \n AC_PREREQ(2.57)\n-AC_INIT([libuv], [1.19.1], [https://github.com/libuv/libuv/issues])\n+AC_INIT([libuv], [1.19.2], [https://github.com/libuv/libuv/issues])\n AC_CONFIG_MACRO_DIR([m4])\n m4_include([m4/libuv-extra-automake-flags.m4])\n m4_include([m4/as_case.m4])"
        },
        {
            "sha": "cdfb76bf8c89284bda9dc2393fd049d2bcbb8ba6",
            "filename": "deps/uv/docs/src/handle.rst",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fdocs%2Fsrc%2Fhandle.rst",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fdocs%2Fsrc%2Fhandle.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Fhandle.rst?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -9,6 +9,9 @@\n Structures are aligned so that any libuv handle can be cast to `uv_handle_t`.\n All API functions defined here work with any handle type.\n \n+Libuv handles are not movable. Pointers to handle structures passed to\n+functions must remain valid for the duration of the requested operation. Take\n+care when using stack allocated handles.\n \n Data types\n ----------"
        },
        {
            "sha": "86a99adf5d669c5b46168be5edde6bc8103110c6",
            "filename": "deps/uv/docs/src/loop.rst",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fdocs%2Fsrc%2Floop.rst",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fdocs%2Fsrc%2Floop.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Floop.rst?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -219,7 +219,7 @@ API\n \n     .. caution::\n \n-       Any previous value returned from :c:func`uv_backend_fd` is now\n+       Any previous value returned from :c:func:`uv_backend_fd` is now\n        invalid. That function must be called again to determine the\n        correct backend file descriptor.\n "
        },
        {
            "sha": "89bb4a6f3ae14e0c5f6fad2641c672797baddb1a",
            "filename": "deps/uv/docs/src/threading.rst",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fdocs%2Fsrc%2Fthreading.rst",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fdocs%2Fsrc%2Fthreading.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Fthreading.rst?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -131,8 +131,15 @@ Functions return 0 on success or an error code < 0 (unless the\n return type is void, of course).\n \n .. note::\n-    Callers should be prepared to deal with spurious wakeups on :c:func:`uv_cond_wait` and\n-    :c:func:`uv_cond_timedwait`.\n+    1. Callers should be prepared to deal with spurious wakeups on :c:func:`uv_cond_wait`\n+       and :c:func:`uv_cond_timedwait`.\n+    2. The timeout parameter for :c:func:`uv_cond_timedwait` is relative to the time\n+       at which function is called.\n+    3. On z/OS, the timeout parameter for :c:func:`uv_cond_timedwait` is converted to an\n+       absolute system time at which the wait expires. If the current system clock time\n+       passes the absolute time calculated before the condition is signaled, an ETIMEDOUT\n+       error results. After the wait begins, the wait time is not affected by changes\n+       to the system clock.\n \n .. c:function:: int uv_cond_init(uv_cond_t* cond)\n .. c:function:: void uv_cond_destroy(uv_cond_t* cond)"
        },
        {
            "sha": "e163e288fdb275153c8c2a98108d4f5ea7e65f34",
            "filename": "deps/uv/docs/src/timer.rst",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fdocs%2Fsrc%2Ftimer.rst",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fdocs%2Fsrc%2Ftimer.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Ftimer.rst?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -45,6 +45,8 @@ API\n     .. note::\n         Does not update the event loop's concept of \"now\". See :c:func:`uv_update_time` for more information.\n \n+        If the timer is already active, it is simply updated.\n+\n .. c:function:: int uv_timer_stop(uv_timer_t* handle)\n \n     Stop the timer, the callback will not be called anymore."
        },
        {
            "sha": "c2add5caecc7d387edf67928a153ace279ef9edf",
            "filename": "deps/uv/gyp_uv.py",
            "status": "modified",
            "additions": 1,
            "deletions": 22,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fgyp_uv.py",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fgyp_uv.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fgyp_uv.py?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -43,28 +43,7 @@ def run_gyp(args):\n \n if __name__ == '__main__':\n   args = sys.argv[1:]\n-\n-  # GYP bug.\n-  # On msvs it will crash if it gets an absolute path.\n-  # On Mac/make it will crash if it doesn't get an absolute path.\n-  if sys.platform == 'win32':\n-    args.append(os.path.join(uv_root, 'uv.gyp'))\n-    common_fn  = os.path.join(uv_root, 'common.gypi')\n-    options_fn = os.path.join(uv_root, 'options.gypi')\n-    # we force vs 2010 over 2008 which would otherwise be the default for gyp\n-    if not os.environ.get('GYP_MSVS_VERSION'):\n-      os.environ['GYP_MSVS_VERSION'] = '2010'\n-  else:\n-    args.append(os.path.join(os.path.abspath(uv_root), 'uv.gyp'))\n-    common_fn  = os.path.join(os.path.abspath(uv_root), 'common.gypi')\n-    options_fn = os.path.join(os.path.abspath(uv_root), 'options.gypi')\n-\n-  if os.path.exists(common_fn):\n-    args.extend(['-I', common_fn])\n-\n-  if os.path.exists(options_fn):\n-    args.extend(['-I', options_fn])\n-\n+  args.extend('-I common.gypi test/test.gyp'.split(' '))\n   args.append('--depth=' + uv_root)\n \n   # There's a bug with windows which doesn't allow this feature."
        },
        {
            "sha": "aa4d4509f60dd1a0eb16f8a2d809106db0594a74",
            "filename": "deps/uv/include/uv-errno.h",
            "status": "modified",
            "additions": 69,
            "deletions": 63,
            "changes": 132,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Finclude%2Fuv-errno.h",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Finclude%2Fuv-errno.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv-errno.h?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -23,6 +23,11 @@\n #define UV_ERRNO_H_\n \n #include <errno.h>\n+#if EDOM > 0\n+# define UV__ERR(x) (-(x))\n+#else\n+# define UV__ERR(x) (x)\n+#endif\n \n #define UV__EOF     (-4095)\n #define UV__UNKNOWN (-4094)\n@@ -46,355 +51,355 @@\n  * a fairly common practice for Windows programmers to redefine errno codes.\n  */\n #if defined(E2BIG) && !defined(_WIN32)\n-# define UV__E2BIG (-E2BIG)\n+# define UV__E2BIG UV__ERR(E2BIG)\n #else\n # define UV__E2BIG (-4093)\n #endif\n \n #if defined(EACCES) && !defined(_WIN32)\n-# define UV__EACCES (-EACCES)\n+# define UV__EACCES UV__ERR(EACCES)\n #else\n # define UV__EACCES (-4092)\n #endif\n \n #if defined(EADDRINUSE) && !defined(_WIN32)\n-# define UV__EADDRINUSE (-EADDRINUSE)\n+# define UV__EADDRINUSE UV__ERR(EADDRINUSE)\n #else\n # define UV__EADDRINUSE (-4091)\n #endif\n \n #if defined(EADDRNOTAVAIL) && !defined(_WIN32)\n-# define UV__EADDRNOTAVAIL (-EADDRNOTAVAIL)\n+# define UV__EADDRNOTAVAIL UV__ERR(EADDRNOTAVAIL)\n #else\n # define UV__EADDRNOTAVAIL (-4090)\n #endif\n \n #if defined(EAFNOSUPPORT) && !defined(_WIN32)\n-# define UV__EAFNOSUPPORT (-EAFNOSUPPORT)\n+# define UV__EAFNOSUPPORT UV__ERR(EAFNOSUPPORT)\n #else\n # define UV__EAFNOSUPPORT (-4089)\n #endif\n \n #if defined(EAGAIN) && !defined(_WIN32)\n-# define UV__EAGAIN (-EAGAIN)\n+# define UV__EAGAIN UV__ERR(EAGAIN)\n #else\n # define UV__EAGAIN (-4088)\n #endif\n \n #if defined(EALREADY) && !defined(_WIN32)\n-# define UV__EALREADY (-EALREADY)\n+# define UV__EALREADY UV__ERR(EALREADY)\n #else\n # define UV__EALREADY (-4084)\n #endif\n \n #if defined(EBADF) && !defined(_WIN32)\n-# define UV__EBADF (-EBADF)\n+# define UV__EBADF UV__ERR(EBADF)\n #else\n # define UV__EBADF (-4083)\n #endif\n \n #if defined(EBUSY) && !defined(_WIN32)\n-# define UV__EBUSY (-EBUSY)\n+# define UV__EBUSY UV__ERR(EBUSY)\n #else\n # define UV__EBUSY (-4082)\n #endif\n \n #if defined(ECANCELED) && !defined(_WIN32)\n-# define UV__ECANCELED (-ECANCELED)\n+# define UV__ECANCELED UV__ERR(ECANCELED)\n #else\n # define UV__ECANCELED (-4081)\n #endif\n \n #if defined(ECHARSET) && !defined(_WIN32)\n-# define UV__ECHARSET (-ECHARSET)\n+# define UV__ECHARSET UV__ERR(ECHARSET)\n #else\n # define UV__ECHARSET (-4080)\n #endif\n \n #if defined(ECONNABORTED) && !defined(_WIN32)\n-# define UV__ECONNABORTED (-ECONNABORTED)\n+# define UV__ECONNABORTED UV__ERR(ECONNABORTED)\n #else\n # define UV__ECONNABORTED (-4079)\n #endif\n \n #if defined(ECONNREFUSED) && !defined(_WIN32)\n-# define UV__ECONNREFUSED (-ECONNREFUSED)\n+# define UV__ECONNREFUSED UV__ERR(ECONNREFUSED)\n #else\n # define UV__ECONNREFUSED (-4078)\n #endif\n \n #if defined(ECONNRESET) && !defined(_WIN32)\n-# define UV__ECONNRESET (-ECONNRESET)\n+# define UV__ECONNRESET UV__ERR(ECONNRESET)\n #else\n # define UV__ECONNRESET (-4077)\n #endif\n \n #if defined(EDESTADDRREQ) && !defined(_WIN32)\n-# define UV__EDESTADDRREQ (-EDESTADDRREQ)\n+# define UV__EDESTADDRREQ UV__ERR(EDESTADDRREQ)\n #else\n # define UV__EDESTADDRREQ (-4076)\n #endif\n \n #if defined(EEXIST) && !defined(_WIN32)\n-# define UV__EEXIST (-EEXIST)\n+# define UV__EEXIST UV__ERR(EEXIST)\n #else\n # define UV__EEXIST (-4075)\n #endif\n \n #if defined(EFAULT) && !defined(_WIN32)\n-# define UV__EFAULT (-EFAULT)\n+# define UV__EFAULT UV__ERR(EFAULT)\n #else\n # define UV__EFAULT (-4074)\n #endif\n \n #if defined(EHOSTUNREACH) && !defined(_WIN32)\n-# define UV__EHOSTUNREACH (-EHOSTUNREACH)\n+# define UV__EHOSTUNREACH UV__ERR(EHOSTUNREACH)\n #else\n # define UV__EHOSTUNREACH (-4073)\n #endif\n \n #if defined(EINTR) && !defined(_WIN32)\n-# define UV__EINTR (-EINTR)\n+# define UV__EINTR UV__ERR(EINTR)\n #else\n # define UV__EINTR (-4072)\n #endif\n \n #if defined(EINVAL) && !defined(_WIN32)\n-# define UV__EINVAL (-EINVAL)\n+# define UV__EINVAL UV__ERR(EINVAL)\n #else\n # define UV__EINVAL (-4071)\n #endif\n \n #if defined(EIO) && !defined(_WIN32)\n-# define UV__EIO (-EIO)\n+# define UV__EIO UV__ERR(EIO)\n #else\n # define UV__EIO (-4070)\n #endif\n \n #if defined(EISCONN) && !defined(_WIN32)\n-# define UV__EISCONN (-EISCONN)\n+# define UV__EISCONN UV__ERR(EISCONN)\n #else\n # define UV__EISCONN (-4069)\n #endif\n \n #if defined(EISDIR) && !defined(_WIN32)\n-# define UV__EISDIR (-EISDIR)\n+# define UV__EISDIR UV__ERR(EISDIR)\n #else\n # define UV__EISDIR (-4068)\n #endif\n \n #if defined(ELOOP) && !defined(_WIN32)\n-# define UV__ELOOP (-ELOOP)\n+# define UV__ELOOP UV__ERR(ELOOP)\n #else\n # define UV__ELOOP (-4067)\n #endif\n \n #if defined(EMFILE) && !defined(_WIN32)\n-# define UV__EMFILE (-EMFILE)\n+# define UV__EMFILE UV__ERR(EMFILE)\n #else\n # define UV__EMFILE (-4066)\n #endif\n \n #if defined(EMSGSIZE) && !defined(_WIN32)\n-# define UV__EMSGSIZE (-EMSGSIZE)\n+# define UV__EMSGSIZE UV__ERR(EMSGSIZE)\n #else\n # define UV__EMSGSIZE (-4065)\n #endif\n \n #if defined(ENAMETOOLONG) && !defined(_WIN32)\n-# define UV__ENAMETOOLONG (-ENAMETOOLONG)\n+# define UV__ENAMETOOLONG UV__ERR(ENAMETOOLONG)\n #else\n # define UV__ENAMETOOLONG (-4064)\n #endif\n \n #if defined(ENETDOWN) && !defined(_WIN32)\n-# define UV__ENETDOWN (-ENETDOWN)\n+# define UV__ENETDOWN UV__ERR(ENETDOWN)\n #else\n # define UV__ENETDOWN (-4063)\n #endif\n \n #if defined(ENETUNREACH) && !defined(_WIN32)\n-# define UV__ENETUNREACH (-ENETUNREACH)\n+# define UV__ENETUNREACH UV__ERR(ENETUNREACH)\n #else\n # define UV__ENETUNREACH (-4062)\n #endif\n \n #if defined(ENFILE) && !defined(_WIN32)\n-# define UV__ENFILE (-ENFILE)\n+# define UV__ENFILE UV__ERR(ENFILE)\n #else\n # define UV__ENFILE (-4061)\n #endif\n \n #if defined(ENOBUFS) && !defined(_WIN32)\n-# define UV__ENOBUFS (-ENOBUFS)\n+# define UV__ENOBUFS UV__ERR(ENOBUFS)\n #else\n # define UV__ENOBUFS (-4060)\n #endif\n \n #if defined(ENODEV) && !defined(_WIN32)\n-# define UV__ENODEV (-ENODEV)\n+# define UV__ENODEV UV__ERR(ENODEV)\n #else\n # define UV__ENODEV (-4059)\n #endif\n \n #if defined(ENOENT) && !defined(_WIN32)\n-# define UV__ENOENT (-ENOENT)\n+# define UV__ENOENT UV__ERR(ENOENT)\n #else\n # define UV__ENOENT (-4058)\n #endif\n \n #if defined(ENOMEM) && !defined(_WIN32)\n-# define UV__ENOMEM (-ENOMEM)\n+# define UV__ENOMEM UV__ERR(ENOMEM)\n #else\n # define UV__ENOMEM (-4057)\n #endif\n \n #if defined(ENONET) && !defined(_WIN32)\n-# define UV__ENONET (-ENONET)\n+# define UV__ENONET UV__ERR(ENONET)\n #else\n # define UV__ENONET (-4056)\n #endif\n \n #if defined(ENOSPC) && !defined(_WIN32)\n-# define UV__ENOSPC (-ENOSPC)\n+# define UV__ENOSPC UV__ERR(ENOSPC)\n #else\n # define UV__ENOSPC (-4055)\n #endif\n \n #if defined(ENOSYS) && !defined(_WIN32)\n-# define UV__ENOSYS (-ENOSYS)\n+# define UV__ENOSYS UV__ERR(ENOSYS)\n #else\n # define UV__ENOSYS (-4054)\n #endif\n \n #if defined(ENOTCONN) && !defined(_WIN32)\n-# define UV__ENOTCONN (-ENOTCONN)\n+# define UV__ENOTCONN UV__ERR(ENOTCONN)\n #else\n # define UV__ENOTCONN (-4053)\n #endif\n \n #if defined(ENOTDIR) && !defined(_WIN32)\n-# define UV__ENOTDIR (-ENOTDIR)\n+# define UV__ENOTDIR UV__ERR(ENOTDIR)\n #else\n # define UV__ENOTDIR (-4052)\n #endif\n \n #if defined(ENOTEMPTY) && !defined(_WIN32)\n-# define UV__ENOTEMPTY (-ENOTEMPTY)\n+# define UV__ENOTEMPTY UV__ERR(ENOTEMPTY)\n #else\n # define UV__ENOTEMPTY (-4051)\n #endif\n \n #if defined(ENOTSOCK) && !defined(_WIN32)\n-# define UV__ENOTSOCK (-ENOTSOCK)\n+# define UV__ENOTSOCK UV__ERR(ENOTSOCK)\n #else\n # define UV__ENOTSOCK (-4050)\n #endif\n \n #if defined(ENOTSUP) && !defined(_WIN32)\n-# define UV__ENOTSUP (-ENOTSUP)\n+# define UV__ENOTSUP UV__ERR(ENOTSUP)\n #else\n # define UV__ENOTSUP (-4049)\n #endif\n \n #if defined(EPERM) && !defined(_WIN32)\n-# define UV__EPERM (-EPERM)\n+# define UV__EPERM UV__ERR(EPERM)\n #else\n # define UV__EPERM (-4048)\n #endif\n \n #if defined(EPIPE) && !defined(_WIN32)\n-# define UV__EPIPE (-EPIPE)\n+# define UV__EPIPE UV__ERR(EPIPE)\n #else\n # define UV__EPIPE (-4047)\n #endif\n \n #if defined(EPROTO) && !defined(_WIN32)\n-# define UV__EPROTO (-EPROTO)\n+# define UV__EPROTO UV__ERR(EPROTO)\n #else\n-# define UV__EPROTO (-4046)\n+# define UV__EPROTO UV__ERR(4046)\n #endif\n \n #if defined(EPROTONOSUPPORT) && !defined(_WIN32)\n-# define UV__EPROTONOSUPPORT (-EPROTONOSUPPORT)\n+# define UV__EPROTONOSUPPORT UV__ERR(EPROTONOSUPPORT)\n #else\n # define UV__EPROTONOSUPPORT (-4045)\n #endif\n \n #if defined(EPROTOTYPE) && !defined(_WIN32)\n-# define UV__EPROTOTYPE (-EPROTOTYPE)\n+# define UV__EPROTOTYPE UV__ERR(EPROTOTYPE)\n #else\n # define UV__EPROTOTYPE (-4044)\n #endif\n \n #if defined(EROFS) && !defined(_WIN32)\n-# define UV__EROFS (-EROFS)\n+# define UV__EROFS UV__ERR(EROFS)\n #else\n # define UV__EROFS (-4043)\n #endif\n \n #if defined(ESHUTDOWN) && !defined(_WIN32)\n-# define UV__ESHUTDOWN (-ESHUTDOWN)\n+# define UV__ESHUTDOWN UV__ERR(ESHUTDOWN)\n #else\n # define UV__ESHUTDOWN (-4042)\n #endif\n \n #if defined(ESPIPE) && !defined(_WIN32)\n-# define UV__ESPIPE (-ESPIPE)\n+# define UV__ESPIPE UV__ERR(ESPIPE)\n #else\n # define UV__ESPIPE (-4041)\n #endif\n \n #if defined(ESRCH) && !defined(_WIN32)\n-# define UV__ESRCH (-ESRCH)\n+# define UV__ESRCH UV__ERR(ESRCH)\n #else\n # define UV__ESRCH (-4040)\n #endif\n \n #if defined(ETIMEDOUT) && !defined(_WIN32)\n-# define UV__ETIMEDOUT (-ETIMEDOUT)\n+# define UV__ETIMEDOUT UV__ERR(ETIMEDOUT)\n #else\n # define UV__ETIMEDOUT (-4039)\n #endif\n \n #if defined(ETXTBSY) && !defined(_WIN32)\n-# define UV__ETXTBSY (-ETXTBSY)\n+# define UV__ETXTBSY UV__ERR(ETXTBSY)\n #else\n # define UV__ETXTBSY (-4038)\n #endif\n \n #if defined(EXDEV) && !defined(_WIN32)\n-# define UV__EXDEV (-EXDEV)\n+# define UV__EXDEV UV__ERR(EXDEV)\n #else\n # define UV__EXDEV (-4037)\n #endif\n \n #if defined(EFBIG) && !defined(_WIN32)\n-# define UV__EFBIG (-EFBIG)\n+# define UV__EFBIG UV__ERR(EFBIG)\n #else\n # define UV__EFBIG (-4036)\n #endif\n \n #if defined(ENOPROTOOPT) && !defined(_WIN32)\n-# define UV__ENOPROTOOPT (-ENOPROTOOPT)\n+# define UV__ENOPROTOOPT UV__ERR(ENOPROTOOPT)\n #else\n # define UV__ENOPROTOOPT (-4035)\n #endif\n \n #if defined(ERANGE) && !defined(_WIN32)\n-# define UV__ERANGE (-ERANGE)\n+# define UV__ERANGE UV__ERR(ERANGE)\n #else\n # define UV__ERANGE (-4034)\n #endif\n \n #if defined(ENXIO) && !defined(_WIN32)\n-# define UV__ENXIO (-ENXIO)\n+# define UV__ENXIO UV__ERR(ENXIO)\n #else\n # define UV__ENXIO (-4033)\n #endif\n \n #if defined(EMLINK) && !defined(_WIN32)\n-# define UV__EMLINK (-EMLINK)\n+# define UV__EMLINK UV__ERR(EMLINK)\n #else\n # define UV__EMLINK (-4032)\n #endif\n@@ -404,7 +409,7 @@\n  * icky to hard-code it.\n  */\n #if defined(EHOSTDOWN) && !defined(_WIN32)\n-# define UV__EHOSTDOWN (-EHOSTDOWN)\n+# define UV__EHOSTDOWN UV__ERR(EHOSTDOWN)\n #elif defined(__APPLE__) || \\\n       defined(__DragonFly__) || \\\n       defined(__FreeBSD__) || \\\n@@ -417,15 +422,16 @@\n #endif\n \n #if defined(EREMOTEIO) && !defined(_WIN32)\n-# define UV__EREMOTEIO (-EREMOTEIO)\n+# define UV__EREMOTEIO UV__ERR(EREMOTEIO)\n #else\n # define UV__EREMOTEIO (-4030)\n #endif\n \n #if defined(ENOTTY) && !defined(_WIN32)\n-# define UV__ENOTTY (-ENOTTY)\n+# define UV__ENOTTY UV__ERR(ENOTTY)\n #else\n # define UV__ENOTTY (-4029)\n #endif\n \n+\n #endif /* UV_ERRNO_H_ */"
        },
        {
            "sha": "c2753d51c7c36e070bae5138429f3fda3aaa9bce",
            "filename": "deps/uv/include/uv-version.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Finclude%2Fuv-version.h",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Finclude%2Fuv-version.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv-version.h?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -32,7 +32,7 @@\n \n #define UV_VERSION_MAJOR 1\n #define UV_VERSION_MINOR 19\n-#define UV_VERSION_PATCH 1\n+#define UV_VERSION_PATCH 2\n #define UV_VERSION_IS_RELEASE 1\n #define UV_VERSION_SUFFIX \"\"\n "
        },
        {
            "sha": "9794d9969b620ec9db4c7972e35d3258fc119a28",
            "filename": "deps/uv/include/uv.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Finclude%2Fuv.h",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Finclude%2Fuv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv.h?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -1559,6 +1559,7 @@ UV_EXTERN void uv_loop_set_data(uv_loop_t*, void* data);\n #undef UV_SIGNAL_PRIVATE_FIELDS\n #undef UV_LOOP_PRIVATE_FIELDS\n #undef UV_LOOP_PRIVATE_PLATFORM_FIELDS\n+#undef UV__ERR\n \n #ifdef __cplusplus\n }"
        },
        {
            "sha": "55c4b65d5dc5cfef89aba35bd25e7e6b80e69c08",
            "filename": "deps/uv/libuv.pc.in",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Flibuv.pc.in",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Flibuv.pc.in",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Flibuv.pc.in?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -6,6 +6,7 @@ includedir=@includedir@\n Name: @PACKAGE_NAME@\n Version: @PACKAGE_VERSION@\n Description: multi-platform support library with a focus on asynchronous I/O.\n+URL: http://libuv.org/\n \n Libs: -L${libdir} -luv @LIBS@\n Cflags: -I${includedir}"
        },
        {
            "sha": "e17e449481836ad52ec3f808b6e41b57a4946e2d",
            "filename": "deps/uv/src/unix/aix-common.c",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Faix-common.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Faix-common.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Faix-common.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -83,12 +83,12 @@ int uv_exepath(char* buffer, size_t* size) {\n   struct procsinfo pi;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   pi.pi_pid = getpid();\n   res = getargs(&pi, sizeof(pi), args, sizeof(args));\n   if (res < 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   /*\n    * Possibilities for args:\n@@ -101,7 +101,7 @@ int uv_exepath(char* buffer, size_t* size) {\n   /* Case i) and ii) absolute or relative paths */\n   if (strchr(args, '/') != NULL) {\n     if (realpath(args, abspath) != abspath)\n-      return -errno;\n+      return UV__ERR(errno);\n \n     abspath_size = strlen(abspath);\n \n@@ -121,11 +121,11 @@ int uv_exepath(char* buffer, size_t* size) {\n     char *path = getenv(\"PATH\");\n \n     if (path == NULL)\n-      return -EINVAL;\n+      return UV_EINVAL;\n \n     clonedpath = uv__strdup(path);\n     if (clonedpath == NULL)\n-      return -ENOMEM;\n+      return UV_ENOMEM;\n \n     token = strtok(clonedpath, \":\");\n     while (token != NULL) {\n@@ -151,7 +151,7 @@ int uv_exepath(char* buffer, size_t* size) {\n     uv__free(clonedpath);\n \n     /* Out of tokens (path entries), and no match found */\n-    return -EINVAL;\n+    return UV_EINVAL;\n   }\n }\n \n@@ -177,19 +177,19 @@ int uv_interface_addresses(uv_interface_address_t** addresses,\n   *count = 0;\n \n   if (0 > (sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP))) {\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   if (ioctl(sockfd, SIOCGSIZIFCONF, &size) == -1) {\n     uv__close(sockfd);\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   ifc.ifc_req = (struct ifreq*)uv__malloc(size);\n   ifc.ifc_len = size;\n   if (ioctl(sockfd, SIOCGIFCONF, &ifc) == -1) {\n     uv__close(sockfd);\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n #define ADDR_SIZE(p) MAX((p).sa_len, sizeof(p))\n@@ -208,7 +208,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses,\n     memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));\n     if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {\n       uv__close(sockfd);\n-      return -errno;\n+      return UV__ERR(errno);\n     }\n \n     if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))\n@@ -221,7 +221,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses,\n   *addresses = uv__malloc(*count * sizeof(uv_interface_address_t));\n   if (!(*addresses)) {\n     uv__close(sockfd);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n   address = *addresses;\n \n@@ -240,7 +240,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses,\n     memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));\n     if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {\n       uv__close(sockfd);\n-      return -ENOSYS;\n+      return UV_ENOSYS;\n     }\n \n     if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))\n@@ -260,7 +260,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses,\n \n     if (ioctl(sockfd, SIOCGIFNETMASK, p) == -1) {\n       uv__close(sockfd);\n-      return -ENOSYS;\n+      return UV_ENOSYS;\n     }\n \n     if (inet6)"
        },
        {
            "sha": "92de8148341e1005c221489f8b07da22b2097e5c",
            "filename": "deps/uv/src/unix/aix.c",
            "status": "modified",
            "additions": 23,
            "deletions": 23,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Faix.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Faix.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Faix.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -119,7 +119,7 @@ int uv__io_check_fd(uv_loop_t* loop, int fd) {\n   pc.fd = fd;\n \n   if (pollset_ctl(loop->backend_fd, &pc, 1))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   pc.cmd = PS_DELETE;\n   if (pollset_ctl(loop->backend_fd, &pc, 1))\n@@ -409,22 +409,22 @@ static int uv__is_ahafs_mounted(void){\n \n   p = uv__malloc(siz);\n   if (p == NULL)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   /* Retrieve all mounted filesystems */\n   rv = mntctl(MCTL_QUERY, siz, (char*)p);\n   if (rv < 0)\n-    return -errno;\n+    return UV__ERR(errno);\n   if (rv == 0) {\n     /* buffer was not large enough, reallocate to correct size */\n     siz = *(int*)p;\n     uv__free(p);\n     p = uv__malloc(siz);\n     if (p == NULL)\n-      return -errno;\n+      return UV__ERR(errno);\n     rv = mntctl(MCTL_QUERY, siz, (char*)p);\n     if (rv < 0)\n-      return -errno;\n+      return UV__ERR(errno);\n   }\n \n   /* Look for dev in filesystems mount info */\n@@ -495,7 +495,7 @@ static int uv__make_subdirs_p(const char *filename) {\n   rc = uv__makedir_p(cmd);\n \n   if (rc == -1 && errno != EEXIST){\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   return rc;\n@@ -522,7 +522,7 @@ static int uv__setup_ahafs(const char* filename, int *fd) {\n     sprintf(mon_file, \"/aha/fs/modFile.monFactory\");\n \n   if ((strlen(mon_file) + strlen(filename) + 5) > PATH_MAX)\n-    return -ENAMETOOLONG;\n+    return UV_ENAMETOOLONG;\n \n   /* Make the necessary subdirectories for the monitor file */\n   rc = uv__make_subdirs_p(filename);\n@@ -537,7 +537,7 @@ static int uv__setup_ahafs(const char* filename, int *fd) {\n   /* Open the monitor file, creating it if necessary */\n   *fd = open(mon_file, O_CREAT|O_RDWR);\n   if (*fd < 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   /* Write out the monitoring specifications.\n    * In this case, we are monitoring for a state change event type\n@@ -558,7 +558,7 @@ static int uv__setup_ahafs(const char* filename, int *fd) {\n \n   rc = write(*fd, mon_file_write_string, strlen(mon_file_write_string)+1);\n   if (rc < 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -716,7 +716,7 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle) {\n   uv__handle_init(loop, (uv_handle_t*)handle, UV_FS_EVENT);\n   return 0;\n #else\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n #endif\n }\n \n@@ -771,7 +771,7 @@ int uv_fs_event_start(uv_fs_event_t* handle,\n \n   return 0;\n #else\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n #endif\n }\n \n@@ -796,7 +796,7 @@ int uv_fs_event_stop(uv_fs_event_t* handle) {\n \n   return 0;\n #else\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n #endif\n }\n \n@@ -861,7 +861,7 @@ int uv_set_process_title(const char* title) {\n    */\n   new_title = uv__strdup(title);\n   if (new_title == NULL)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   uv_once(&process_title_mutex_once, init_process_title_mutex_once);\n   uv_mutex_lock(&process_title_mutex);\n@@ -888,9 +888,9 @@ int uv_get_process_title(char* buffer, size_t size) {\n   size_t len;\n   len = strlen(process_argv[0]);\n   if (buffer == NULL || size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n   else if (size <= len)\n-    return -ENOBUFS;\n+    return UV_ENOBUFS;\n \n   uv_once(&process_title_mutex_once, init_process_title_mutex_once);\n   uv_mutex_lock(&process_title_mutex);\n@@ -919,10 +919,10 @@ int uv_resident_set_memory(size_t* rss) {\n \n   fd = open(pp, O_RDONLY);\n   if (fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   /* FIXME(bnoordhuis) Handle EINTR. */\n-  err = -EINVAL;\n+  err = UV_EINVAL;\n   if (read(fd, &psinfo, sizeof(psinfo)) == sizeof(psinfo)) {\n     *rss = (size_t)psinfo.pr_rssize * 1024;\n     err = 0;\n@@ -953,7 +953,7 @@ int uv_uptime(double* uptime) {\n   endutent();\n \n   if (boot_time == 0)\n-    return -ENOSYS;\n+    return UV_ENOSYS;\n \n   *uptime = time(NULL) - boot_time;\n   return 0;\n@@ -969,30 +969,30 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n \n   result = perfstat_cpu_total(NULL, &ps_total, sizeof(ps_total), 1);\n   if (result == -1) {\n-    return -ENOSYS;\n+    return UV_ENOSYS;\n   }\n \n   ncpus = result = perfstat_cpu(NULL, NULL, sizeof(perfstat_cpu_t), 0);\n   if (result == -1) {\n-    return -ENOSYS;\n+    return UV_ENOSYS;\n   }\n \n   ps_cpus = (perfstat_cpu_t*) uv__malloc(ncpus * sizeof(perfstat_cpu_t));\n   if (!ps_cpus) {\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   strcpy(cpu_id.name, FIRST_CPU);\n   result = perfstat_cpu(&cpu_id, ps_cpus, sizeof(perfstat_cpu_t), ncpus);\n   if (result == -1) {\n     uv__free(ps_cpus);\n-    return -ENOSYS;\n+    return UV_ENOSYS;\n   }\n \n   *cpu_infos = (uv_cpu_info_t*) uv__malloc(ncpus * sizeof(uv_cpu_info_t));\n   if (!*cpu_infos) {\n     uv__free(ps_cpus);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   *count = ncpus;"
        },
        {
            "sha": "0b450ae0da7f372b7d9fd9fbd90969a4670763ff",
            "filename": "deps/uv/src/unix/async.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fasync.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fasync.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fasync.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -166,7 +166,7 @@ static int uv__async_start(uv_loop_t* loop) {\n     pipefd[0] = err;\n     pipefd[1] = -1;\n   }\n-  else if (err == -ENOSYS) {\n+  else if (err == UV_ENOSYS) {\n     err = uv__make_pipe(pipefd, UV__F_NONBLOCK);\n #if defined(__linux__)\n     /* Save a file descriptor by opening one of the pipe descriptors as\n@@ -240,7 +240,7 @@ static int uv__async_eventfd(void) {\n     return fd;\n \n   if (errno != ENOSYS)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   no_eventfd2 = 1;\n \n@@ -257,13 +257,13 @@ static int uv__async_eventfd(void) {\n   }\n \n   if (errno != ENOSYS)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   no_eventfd = 1;\n \n skip_eventfd:\n \n #endif\n \n-  return -ENOSYS;\n+  return UV_ENOSYS;\n }"
        },
        {
            "sha": "0d0215448640a4d149f7d729c596c23a748b8b99",
            "filename": "deps/uv/src/unix/bsd-ifaddrs.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fbsd-ifaddrs.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fbsd-ifaddrs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fbsd-ifaddrs.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -70,7 +70,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n   int i;\n \n   if (getifaddrs(&addrs) != 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *count = 0;\n \n@@ -85,7 +85,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n \n   if (*addresses == NULL) {\n     freeifaddrs(addrs);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   address = *addresses;"
        },
        {
            "sha": "3741c1d06b2d79bf4b8c47230e551ab5d1d1008e",
            "filename": "deps/uv/src/unix/core.c",
            "status": "modified",
            "additions": 51,
            "deletions": 51,
            "changes": 102,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fcore.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -191,14 +191,14 @@ int uv__socket_sockopt(uv_handle_t* handle, int optname, int* value) {\n   socklen_t len;\n \n   if (handle == NULL || value == NULL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (handle->type == UV_TCP || handle->type == UV_NAMED_PIPE)\n     fd = uv__stream_fd((uv_stream_t*) handle);\n   else if (handle->type == UV_UDP)\n     fd = ((uv_udp_t *) handle)->io_watcher.fd;\n   else\n-    return -ENOTSUP;\n+    return UV_ENOTSUP;\n \n   len = sizeof(*value);\n \n@@ -208,7 +208,7 @@ int uv__socket_sockopt(uv_handle_t* handle, int optname, int* value) {\n     r = setsockopt(fd, SOL_SOCKET, optname, (const void*) value, len);\n \n   if (r < 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -418,12 +418,12 @@ int uv__socket(int domain, int type, int protocol) {\n     return sockfd;\n \n   if (errno != EINVAL)\n-    return -errno;\n+    return UV__ERR(errno);\n #endif\n \n   sockfd = socket(domain, type, protocol);\n   if (sockfd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   err = uv__nonblock(sockfd, 1);\n   if (err == 0)\n@@ -487,7 +487,7 @@ int uv__accept(int sockfd) {\n       continue;\n \n     if (errno != ENOSYS)\n-      return -errno;\n+      return UV__ERR(errno);\n \n     no_accept4 = 1;\n skip:\n@@ -497,7 +497,7 @@ int uv__accept(int sockfd) {\n     if (peerfd == -1) {\n       if (errno == EINTR)\n         continue;\n-      return -errno;\n+      return UV__ERR(errno);\n     }\n \n     err = uv__cloexec(peerfd, 1);\n@@ -523,8 +523,8 @@ int uv__close_nocheckstdio(int fd) {\n   saved_errno = errno;\n   rc = close(fd);\n   if (rc == -1) {\n-    rc = -errno;\n-    if (rc == -EINTR || rc == -EINPROGRESS)\n+    rc = UV__ERR(errno);\n+    if (rc == UV_EINTR || rc == UV__ERR(EINPROGRESS))\n       rc = 0;    /* The close is in progress, not an error. */\n     errno = saved_errno;\n   }\n@@ -550,7 +550,7 @@ int uv__nonblock_ioctl(int fd, int set) {\n   while (r == -1 && errno == EINTR);\n \n   if (r)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -565,7 +565,7 @@ int uv__cloexec_ioctl(int fd, int set) {\n   while (r == -1 && errno == EINTR);\n \n   if (r)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -581,7 +581,7 @@ int uv__nonblock_fcntl(int fd, int set) {\n   while (r == -1 && errno == EINTR);\n \n   if (r == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   /* Bail out now if already set/clear. */\n   if (!!(r & O_NONBLOCK) == !!set)\n@@ -597,7 +597,7 @@ int uv__nonblock_fcntl(int fd, int set) {\n   while (r == -1 && errno == EINTR);\n \n   if (r)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -612,7 +612,7 @@ int uv__cloexec_fcntl(int fd, int set) {\n   while (r == -1 && errno == EINTR);\n \n   if (r == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   /* Bail out now if already set/clear. */\n   if (!!(r & FD_CLOEXEC) == !!set)\n@@ -628,7 +628,7 @@ int uv__cloexec_fcntl(int fd, int set) {\n   while (r == -1 && errno == EINTR);\n \n   if (r)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -643,7 +643,7 @@ int uv__dup(int fd) {\n   fd = dup(fd);\n \n   if (fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   err = uv__cloexec(fd, 1);\n   if (err) {\n@@ -667,10 +667,10 @@ ssize_t uv__recvmsg(int fd, struct msghdr* msg, int flags) {\n     if (rc != -1)\n       return rc;\n     if (errno != EINVAL)\n-      return -errno;\n+      return UV__ERR(errno);\n     rc = recvmsg(fd, msg, flags);\n     if (rc == -1)\n-      return -errno;\n+      return UV__ERR(errno);\n     no_msg_cmsg_cloexec = 1;\n   } else {\n     rc = recvmsg(fd, msg, flags);\n@@ -679,7 +679,7 @@ ssize_t uv__recvmsg(int fd, struct msghdr* msg, int flags) {\n   rc = recvmsg(fd, msg, flags);\n #endif\n   if (rc == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n   if (msg->msg_controllen == 0)\n     return rc;\n   for (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg))\n@@ -695,10 +695,10 @@ ssize_t uv__recvmsg(int fd, struct msghdr* msg, int flags) {\n \n int uv_cwd(char* buffer, size_t* size) {\n   if (buffer == NULL || size == NULL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (getcwd(buffer, *size) == NULL)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *size = strlen(buffer);\n   if (*size > 1 && buffer[*size - 1] == '/') {\n@@ -712,7 +712,7 @@ int uv_cwd(char* buffer, size_t* size) {\n \n int uv_chdir(const char* dir) {\n   if (chdir(dir))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -749,11 +749,11 @@ int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd) {\n     break;\n \n   default:\n-    return -EINVAL;\n+    return UV_EINVAL;\n   }\n \n   if (uv__is_closing(handle) || fd_out == -1)\n-    return -EBADF;\n+    return UV_EBADF;\n \n   *fd = fd_out;\n   return 0;\n@@ -931,7 +931,7 @@ int uv_getrusage(uv_rusage_t* rusage) {\n   struct rusage usage;\n \n   if (getrusage(RUSAGE_SELF, &usage))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   rusage->ru_utime.tv_sec = usage.ru_utime.tv_sec;\n   rusage->ru_utime.tv_usec = usage.ru_utime.tv_usec;\n@@ -973,7 +973,7 @@ int uv__open_cloexec(const char* path, int flags) {\n       return fd;\n \n     if (errno != EINVAL)\n-      return -errno;\n+      return UV__ERR(errno);\n \n     /* O_CLOEXEC not supported. */\n     no_cloexec = 1;\n@@ -982,7 +982,7 @@ int uv__open_cloexec(const char* path, int flags) {\n \n   fd = open(path, flags);\n   if (fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   err = uv__cloexec(fd, 1);\n   if (err) {\n@@ -999,14 +999,14 @@ int uv__dup2_cloexec(int oldfd, int newfd) {\n #if (defined(__FreeBSD__) && __FreeBSD__ >= 10) || defined(__NetBSD__)\n   r = dup3(oldfd, newfd, O_CLOEXEC);\n   if (r == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n   return r;\n #elif defined(__FreeBSD__) && defined(F_DUP2FD_CLOEXEC)\n   r = fcntl(oldfd, F_DUP2FD_CLOEXEC, newfd);\n   if (r != -1)\n     return r;\n   if (errno != EINVAL)\n-    return -errno;\n+    return UV__ERR(errno);\n   /* Fall through. */\n #elif defined(__linux__)\n   static int no_dup3;\n@@ -1017,7 +1017,7 @@ int uv__dup2_cloexec(int oldfd, int newfd) {\n     if (r != -1)\n       return r;\n     if (errno != ENOSYS)\n-      return -errno;\n+      return UV__ERR(errno);\n     /* Fall through. */\n     no_dup3 = 1;\n   }\n@@ -1033,7 +1033,7 @@ int uv__dup2_cloexec(int oldfd, int newfd) {\n #endif\n \n     if (r == -1)\n-      return -errno;\n+      return UV__ERR(errno);\n \n     err = uv__cloexec(newfd, 1);\n     if (err) {\n@@ -1053,7 +1053,7 @@ int uv_os_homedir(char* buffer, size_t* size) {\n   int r;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   /* Check if the HOME environment variable is set first */\n   buf = getenv(\"HOME\");\n@@ -1063,7 +1063,7 @@ int uv_os_homedir(char* buffer, size_t* size) {\n \n     if (len >= *size) {\n       *size = len + 1;\n-      return -ENOBUFS;\n+      return UV_ENOBUFS;\n     }\n \n     memcpy(buffer, buf, len + 1);\n@@ -1084,7 +1084,7 @@ int uv_os_homedir(char* buffer, size_t* size) {\n   if (len >= *size) {\n     *size = len + 1;\n     uv_os_free_passwd(&pwd);\n-    return -ENOBUFS;\n+    return UV_ENOBUFS;\n   }\n \n   memcpy(buffer, pwd.homedir, len + 1);\n@@ -1100,7 +1100,7 @@ int uv_os_tmpdir(char* buffer, size_t* size) {\n   size_t len;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n #define CHECK_ENV_VAR(name)                                                   \\\n   do {                                                                        \\\n@@ -1130,7 +1130,7 @@ int uv_os_tmpdir(char* buffer, size_t* size) {\n \n   if (len >= *size) {\n     *size = len + 1;\n-    return -ENOBUFS;\n+    return UV_ENOBUFS;\n   }\n \n   /* The returned directory should not have a trailing slash. */\n@@ -1162,11 +1162,11 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {\n \n   getpwuid_r = dlsym(RTLD_DEFAULT, \"getpwuid_r\");\n   if (getpwuid_r == NULL)\n-    return -ENOSYS;\n+    return UV_ENOSYS;\n #endif\n \n   if (pwd == NULL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   initsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n \n@@ -1183,7 +1183,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {\n     buf = uv__malloc(bufsize);\n \n     if (buf == NULL)\n-      return -ENOMEM;\n+      return UV_ENOMEM;\n \n     r = getpwuid_r(uid, &pw, buf, bufsize, &result);\n \n@@ -1200,7 +1200,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {\n \n   if (result == NULL) {\n     uv__free(buf);\n-    return -ENOENT;\n+    return UV_ENOENT;\n   }\n \n   /* Allocate memory for the username, shell, and home directory */\n@@ -1211,7 +1211,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {\n \n   if (pwd->username == NULL) {\n     uv__free(buf);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   /* Copy the username */\n@@ -1267,18 +1267,18 @@ int uv_os_getenv(const char* name, char* buffer, size_t* size) {\n   size_t len;\n \n   if (name == NULL || buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   var = getenv(name);\n \n   if (var == NULL)\n-    return -ENOENT;\n+    return UV_ENOENT;\n \n   len = strlen(var);\n \n   if (len >= *size) {\n     *size = len + 1;\n-    return -ENOBUFS;\n+    return UV_ENOBUFS;\n   }\n \n   memcpy(buffer, var, len + 1);\n@@ -1290,21 +1290,21 @@ int uv_os_getenv(const char* name, char* buffer, size_t* size) {\n \n int uv_os_setenv(const char* name, const char* value) {\n   if (name == NULL || value == NULL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (setenv(name, value, 1) != 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n \n \n int uv_os_unsetenv(const char* name) {\n   if (name == NULL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (unsetenv(name) != 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -1321,17 +1321,17 @@ int uv_os_gethostname(char* buffer, size_t* size) {\n   size_t len;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (gethostname(buf, sizeof(buf)) != 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   buf[sizeof(buf) - 1] = '\\0'; /* Null terminate, just to be safe. */\n   len = strlen(buf);\n \n   if (len >= *size) {\n     *size = len + 1;\n-    return -ENOBUFS;\n+    return UV_ENOBUFS;\n   }\n \n   memcpy(buffer, buf, len + 1);"
        },
        {
            "sha": "9fe4093ef46fb01275d173a9a463714a7ad4e67c",
            "filename": "deps/uv/src/unix/cygwin.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fcygwin.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fcygwin.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fcygwin.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -29,7 +29,7 @@ int uv_uptime(double* uptime) {\n   struct sysinfo info;\n \n   if (sysinfo(&info) < 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *uptime = info.uptime;\n   return 0;"
        },
        {
            "sha": "dabde2239ccab33439da6a42aa8cacfb4cb1f19a",
            "filename": "deps/uv/src/unix/darwin-proctitle.c",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fdarwin-proctitle.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fdarwin-proctitle.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fdarwin-proctitle.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -18,6 +18,9 @@\n  * IN THE SOFTWARE.\n  */\n \n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n #include <dlfcn.h>\n #include <errno.h>\n #include <stdlib.h>\n@@ -41,14 +44,14 @@ static int uv__pthread_setname_np(const char* name) {\n       dlsym(RTLD_DEFAULT, \"pthread_setname_np\");\n \n   if (dynamic_pthread_setname_np == NULL)\n-    return -ENOSYS;\n+    return UV_ENOSYS;\n \n   strncpy(namebuf, name, sizeof(namebuf) - 1);\n   namebuf[sizeof(namebuf) - 1] = '\\0';\n \n   err = dynamic_pthread_setname_np(namebuf);\n   if (err)\n-    return -err;\n+    return UV__ERR(err);\n \n   return 0;\n }\n@@ -84,7 +87,7 @@ int uv__set_process_title(const char* title) {\n   CFTypeRef asn;\n   int err;\n \n-  err = -ENOENT;\n+  err = UV_ENOENT;\n   application_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                        \"ApplicationServices.framework/\"\n                                        \"Versions/A/ApplicationServices\",\n@@ -151,7 +154,7 @@ int uv__set_process_title(const char* title) {\n   /* Black 10.9 magic, to remove (Not responding) mark in Activity Monitor */\n   hi_services_bundle =\n       pCFBundleGetBundleWithIdentifier(S(\"com.apple.HIServices\"));\n-  err = -ENOENT;\n+  err = UV_ENOENT;\n   if (hi_services_bundle == NULL)\n     goto out;\n \n@@ -182,7 +185,7 @@ int uv__set_process_title(const char* title) {\n \n   asn = pLSGetCurrentApplicationASN();\n \n-  err = -EINVAL;\n+  err = UV_EINVAL;\n   if (pLSSetApplicationInformationItem(-2,  /* Magic value. */\n                                        asn,\n                                        *display_name_key,"
        },
        {
            "sha": "31ad8a9e48a077cc35b083f3b7068c4f2e19bbde",
            "filename": "deps/uv/src/unix/darwin.c",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fdarwin.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fdarwin.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fdarwin.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -37,7 +37,7 @@ int uv__platform_loop_init(uv_loop_t* loop) {\n   loop->cf_state = NULL;\n \n   if (uv__kqueue_init(loop))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -68,18 +68,18 @@ int uv_exepath(char* buffer, size_t* size) {\n   size_t abspath_size;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   exepath_size = sizeof(exepath);\n   if (_NSGetExecutablePath(exepath, &exepath_size))\n-    return -EIO;\n+    return UV_EIO;\n \n   if (realpath(exepath, abspath) != abspath)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   abspath_size = strlen(abspath);\n   if (abspath_size == 0)\n-    return -EIO;\n+    return UV_EIO;\n \n   *size -= 1;\n   if (*size > abspath_size)\n@@ -98,7 +98,7 @@ uint64_t uv_get_free_memory(void) {\n \n   if (host_statistics(mach_host_self(), HOST_VM_INFO,\n                       (host_info_t)&info, &count) != KERN_SUCCESS) {\n-    return -EINVAL;  /* FIXME(bnoordhuis) Translate error. */\n+    return UV_EINVAL;  /* FIXME(bnoordhuis) Translate error. */\n   }\n \n   return (uint64_t) info.free_count * sysconf(_SC_PAGESIZE);\n@@ -111,7 +111,7 @@ uint64_t uv_get_total_memory(void) {\n   size_t size = sizeof(info);\n \n   if (sysctl(which, 2, &info, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return (uint64_t) info;\n }\n@@ -158,7 +158,7 @@ int uv_uptime(double* uptime) {\n   static int which[] = {CTL_KERN, KERN_BOOTTIME};\n \n   if (sysctl(which, 2, &info, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   now = time(NULL);\n   *uptime = now - info.tv_sec;\n@@ -181,23 +181,23 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n   size = sizeof(model);\n   if (sysctlbyname(\"machdep.cpu.brand_string\", &model, &size, NULL, 0) &&\n       sysctlbyname(\"hw.model\", &model, &size, NULL, 0)) {\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   size = sizeof(cpuspeed);\n   if (sysctlbyname(\"hw.cpufrequency\", &cpuspeed, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   if (host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &numcpus,\n                           (processor_info_array_t*)&info,\n                           &msg_type) != KERN_SUCCESS) {\n-    return -EINVAL;  /* FIXME(bnoordhuis) Translate error. */\n+    return UV_EINVAL;  /* FIXME(bnoordhuis) Translate error. */\n   }\n \n   *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));\n   if (!(*cpu_infos)) {\n     vm_deallocate(mach_task_self(), (vm_address_t)info, msg_type);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   *count = numcpus;"
        },
        {
            "sha": "70ccb13042fddb9e79c6791b2d6c6a67b097bd09",
            "filename": "deps/uv/src/unix/freebsd.c",
            "status": "modified",
            "additions": 17,
            "deletions": 17,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ffreebsd.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ffreebsd.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ffreebsd.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -72,11 +72,11 @@ int uv_exepath(char* buffer, size_t* size) {\n   ssize_t abspath_size;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   abspath_size = readlink(\"/proc/curproc/file\", abspath, sizeof(abspath));\n   if (abspath_size < 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   assert(abspath_size > 0);\n   *size -= 1;\n@@ -96,7 +96,7 @@ int uv_exepath(char* buffer, size_t* size) {\n   size_t abspath_size;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   mib[0] = CTL_KERN;\n   mib[1] = KERN_PROC;\n@@ -105,7 +105,7 @@ int uv_exepath(char* buffer, size_t* size) {\n \n   abspath_size = sizeof abspath;\n   if (sysctl(mib, 4, abspath, &abspath_size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   assert(abspath_size > 0);\n   abspath_size -= 1;\n@@ -126,7 +126,7 @@ uint64_t uv_get_free_memory(void) {\n   size_t size = sizeof(freecount);\n \n   if (sysctlbyname(\"vm.stats.vm.v_free_count\", &freecount, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return (uint64_t) freecount * sysconf(_SC_PAGESIZE);\n \n@@ -140,7 +140,7 @@ uint64_t uv_get_total_memory(void) {\n   size_t size = sizeof(info);\n \n   if (sysctl(which, 2, &info, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return (uint64_t) info;\n }\n@@ -176,7 +176,7 @@ int uv_set_process_title(const char* title) {\n \n   if (process_title == NULL) {\n     uv_mutex_unlock(&process_title_mutex);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   uv__free(process_title);\n@@ -204,7 +204,7 @@ int uv_get_process_title(char* buffer, size_t size) {\n   size_t len;\n \n   if (buffer == NULL || size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   uv_once(&process_title_mutex_once, init_process_title_mutex_once);\n   uv_mutex_lock(&process_title_mutex);\n@@ -214,7 +214,7 @@ int uv_get_process_title(char* buffer, size_t size) {\n \n     if (size < len) {\n       uv_mutex_unlock(&process_title_mutex);\n-      return -ENOBUFS;\n+      return UV_ENOBUFS;\n     }\n \n     memcpy(buffer, process_title, len);\n@@ -243,7 +243,7 @@ int uv_resident_set_memory(size_t* rss) {\n   kinfo_size = sizeof(kinfo);\n \n   if (sysctl(mib, 4, &kinfo, &kinfo_size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   page_size = getpagesize();\n \n@@ -262,7 +262,7 @@ int uv_uptime(double* uptime) {\n   struct timespec sp;\n   r = clock_gettime(CLOCK_MONOTONIC, &sp);\n   if (r)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *uptime = sp.tv_sec;\n   return 0;\n@@ -309,15 +309,15 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n \n   size = sizeof(model);\n   if (sysctlbyname(model_key, &model, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   size = sizeof(numcpus);\n   if (sysctlbyname(\"hw.ncpu\", &numcpus, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));\n   if (!(*cpu_infos))\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   *count = numcpus;\n \n@@ -327,21 +327,21 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n   size = sizeof(maxcpus);\n   if (sysctlbyname(maxcpus_key, &maxcpus, &size, NULL, 0)) {\n     uv__free(*cpu_infos);\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   size = maxcpus * CPUSTATES * sizeof(long);\n \n   cp_times = uv__malloc(size);\n   if (cp_times == NULL) {\n     uv__free(*cpu_infos);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   if (sysctlbyname(cptimes_key, cp_times, &size, NULL, 0)) {\n     uv__free(cp_times);\n     uv__free(*cpu_infos);\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   for (i = 0; i < numcpus; i++) {"
        },
        {
            "sha": "92e2d255702fd777823905ad88ee85f7269d7077",
            "filename": "deps/uv/src/unix/fs.c",
            "status": "modified",
            "additions": 26,
            "deletions": 35,
            "changes": 61,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ffs.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ffs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ffs.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -67,16 +67,15 @@\n #define INIT(subtype)                                                         \\\n   do {                                                                        \\\n     if (req == NULL)                                                          \\\n-      return -EINVAL;                                                         \\\n-    req->type = UV_FS;                                                        \\\n-    if (cb != NULL)                                                           \\\n-      uv__req_init(loop, req, UV_FS);                                         \\\n+      return UV_EINVAL;                                                       \\\n+    UV_REQ_INIT(req, UV_FS);                                                  \\\n     req->fs_type = UV_FS_ ## subtype;                                         \\\n     req->result = 0;                                                          \\\n     req->ptr = NULL;                                                          \\\n     req->loop = loop;                                                         \\\n     req->path = NULL;                                                         \\\n     req->new_path = NULL;                                                     \\\n+    req->bufs = NULL;                                                         \\\n     req->cb = cb;                                                             \\\n   }                                                                           \\\n   while (0)\n@@ -88,10 +87,8 @@\n       req->path = path;                                                       \\\n     } else {                                                                  \\\n       req->path = uv__strdup(path);                                           \\\n-      if (req->path == NULL) {                                                \\\n-        uv__req_unregister(loop, req);                                        \\\n-        return -ENOMEM;                                                       \\\n-      }                                                                       \\\n+      if (req->path == NULL)                                                  \\\n+        return UV_ENOMEM;                                                     \\\n     }                                                                         \\\n   }                                                                           \\\n   while (0)\n@@ -107,10 +104,8 @@\n       path_len = strlen(path) + 1;                                            \\\n       new_path_len = strlen(new_path) + 1;                                    \\\n       req->path = uv__malloc(path_len + new_path_len);                        \\\n-      if (req->path == NULL) {                                                \\\n-        uv__req_unregister(loop, req);                                        \\\n-        return -ENOMEM;                                                       \\\n-      }                                                                       \\\n+      if (req->path == NULL)                                                  \\\n+        return UV_ENOMEM;                                                     \\\n       req->new_path = req->path + path_len;                                   \\\n       memcpy((void*) req->path, path, path_len);                              \\\n       memcpy((void*) req->new_path, new_path, new_path_len);                  \\\n@@ -121,6 +116,7 @@\n #define POST                                                                  \\\n   do {                                                                        \\\n     if (cb != NULL) {                                                         \\\n+      uv__req_register(loop, req);                                            \\\n       uv__work_submit(loop, &req->work_req, uv__fs_work, uv__fs_done);        \\\n       return 0;                                                               \\\n     }                                                                         \\\n@@ -818,7 +814,7 @@ static ssize_t uv__fs_copyfile(uv_fs_t* req) {\n \n   /* Get the source file's mode. */\n   if (fstat(srcfd, &statsbuf)) {\n-    err = -errno;\n+    err = UV__ERR(errno);\n     goto out;\n   }\n \n@@ -842,7 +838,7 @@ static ssize_t uv__fs_copyfile(uv_fs_t* req) {\n   }\n \n   if (fchmod(dstfd, statsbuf.st_mode) == -1) {\n-    err = -errno;\n+    err = UV__ERR(errno);\n     goto out;\n   }\n \n@@ -1107,7 +1103,7 @@ static void uv__fs_work(struct uv__work* w) {\n   } while (r == -1 && errno == EINTR && retry_on_eintr);\n \n   if (r == -1)\n-    req->result = -errno;\n+    req->result = UV__ERR(errno);\n   else\n     req->result = r;\n \n@@ -1125,9 +1121,9 @@ static void uv__fs_done(struct uv__work* w, int status) {\n   req = container_of(w, uv_fs_t, work_req);\n   uv__req_unregister(req->loop, req);\n \n-  if (status == -ECANCELED) {\n+  if (status == UV_ECANCELED) {\n     assert(req->result == 0);\n-    req->result = -ECANCELED;\n+    req->result = UV_ECANCELED;\n   }\n \n   req->cb(req);\n@@ -1288,11 +1284,8 @@ int uv_fs_mkdtemp(uv_loop_t* loop,\n                   uv_fs_cb cb) {\n   INIT(MKDTEMP);\n   req->path = uv__strdup(tpl);\n-  if (req->path == NULL) {\n-    if (cb != NULL)\n-      uv__req_unregister(loop, req);\n-    return -ENOMEM;\n-  }\n+  if (req->path == NULL)\n+    return UV_ENOMEM;\n   POST;\n }\n \n@@ -1320,7 +1313,7 @@ int uv_fs_read(uv_loop_t* loop, uv_fs_t* req,\n   INIT(READ);\n \n   if (bufs == NULL || nbufs == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   req->file = file;\n \n@@ -1329,11 +1322,8 @@ int uv_fs_read(uv_loop_t* loop, uv_fs_t* req,\n   if (nbufs > ARRAY_SIZE(req->bufsml))\n     req->bufs = uv__malloc(nbufs * sizeof(*bufs));\n \n-  if (req->bufs == NULL) {\n-    if (cb != NULL)\n-      uv__req_unregister(loop, req);\n-    return -ENOMEM;\n-  }\n+  if (req->bufs == NULL)\n+    return UV_ENOMEM;\n \n   memcpy(req->bufs, bufs, nbufs * sizeof(*bufs));\n \n@@ -1459,7 +1449,7 @@ int uv_fs_write(uv_loop_t* loop,\n   INIT(WRITE);\n \n   if (bufs == NULL || nbufs == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   req->file = file;\n \n@@ -1468,11 +1458,8 @@ int uv_fs_write(uv_loop_t* loop,\n   if (nbufs > ARRAY_SIZE(req->bufsml))\n     req->bufs = uv__malloc(nbufs * sizeof(*bufs));\n \n-  if (req->bufs == NULL) {\n-    if (cb != NULL)\n-      uv__req_unregister(loop, req);\n-    return -ENOMEM;\n-  }\n+  if (req->bufs == NULL)\n+    return UV_ENOMEM;\n \n   memcpy(req->bufs, bufs, nbufs * sizeof(*bufs));\n \n@@ -1499,6 +1486,10 @@ void uv_fs_req_cleanup(uv_fs_t* req) {\n   if (req->fs_type == UV_FS_SCANDIR && req->ptr != NULL)\n     uv__fs_scandir_cleanup(req);\n \n+  if (req->bufs != req->bufsml)\n+    uv__free(req->bufs);\n+  req->bufs = NULL;\n+\n   if (req->ptr != &req->statbuf)\n     uv__free(req->ptr);\n   req->ptr = NULL;\n@@ -1514,7 +1505,7 @@ int uv_fs_copyfile(uv_loop_t* loop,\n   INIT(COPYFILE);\n \n   if (flags & ~UV_FS_COPYFILE_EXCL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   PATH2;\n   req->flags = flags;"
        },
        {
            "sha": "47d8024b6d51ba4a7a81ad2c1b37ad85c76e4e7b",
            "filename": "deps/uv/src/unix/fsevents.c",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ffsevents.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ffsevents.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ffsevents.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -379,7 +379,7 @@ static int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {\n   if (!pFSEventStreamStart(ref)) {\n     pFSEventStreamInvalidate(ref);\n     pFSEventStreamRelease(ref);\n-    return -EMFILE;\n+    return UV_EMFILE;\n   }\n \n   state->fsevent_stream = ref;\n@@ -440,7 +440,7 @@ static void uv__fsevents_reschedule(uv_fs_event_t* handle,\n   uv__fsevents_destroy_stream(handle->loop);\n \n   /* Any failure below will be a memory failure */\n-  err = -ENOMEM;\n+  err = UV_ENOMEM;\n \n   /* Create list of all watched paths */\n   uv_mutex_lock(&state->fsevent_mutex);\n@@ -474,7 +474,7 @@ static void uv__fsevents_reschedule(uv_fs_event_t* handle,\n     /* Create new FSEventStream */\n     cf_paths = pCFArrayCreate(NULL, (const void**) paths, path_count, NULL);\n     if (cf_paths == NULL) {\n-      err = -ENOMEM;\n+      err = UV_ENOMEM;\n       goto final;\n     }\n     err = uv__fsevents_create_stream(handle->loop, cf_paths);\n@@ -528,7 +528,7 @@ static int uv__fsevents_global_init(void) {\n    * but if it ever becomes one, we can turn the dynamic library handles into\n    * per-event loop properties and have the dynamic linker keep track for us.\n    */\n-  err = -ENOSYS;\n+  err = UV_ENOSYS;\n   core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                   \"CoreFoundation.framework/\"\n                                   \"Versions/A/CoreFoundation\",\n@@ -543,7 +543,7 @@ static int uv__fsevents_global_init(void) {\n   if (core_services_handle == NULL)\n     goto out;\n \n-  err = -ENOENT;\n+  err = UV_ENOENT;\n #define V(handle, symbol)                                                     \\\n   do {                                                                        \\\n     *(void **)(&p ## symbol) = dlsym((handle), #symbol);                      \\\n@@ -607,7 +607,7 @@ static int uv__fsevents_loop_init(uv_loop_t* loop) {\n \n   state = uv__calloc(1, sizeof(*state));\n   if (state == NULL)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   err = uv_mutex_init(&loop->cf_mutex);\n   if (err)\n@@ -636,7 +636,7 @@ static int uv__fsevents_loop_init(uv_loop_t* loop) {\n   ctx.perform = uv__cf_loop_cb;\n   state->signal_source = pCFRunLoopSourceCreate(NULL, 0, &ctx);\n   if (state->signal_source == NULL) {\n-    err = -ENOMEM;\n+    err = UV_ENOMEM;\n     goto fail_signal_source_create;\n   }\n \n@@ -655,7 +655,7 @@ static int uv__fsevents_loop_init(uv_loop_t* loop) {\n   loop->cf_state = state;\n \n   /* uv_thread_t is an alias for pthread_t. */\n-  err = -pthread_create(&loop->cf_thread, attr, uv__cf_loop_runner, loop);\n+  err = UV__ERR(pthread_create(&loop->cf_thread, attr, uv__cf_loop_runner, loop));\n \n   if (attr != NULL)\n     pthread_attr_destroy(attr);\n@@ -787,7 +787,7 @@ int uv__cf_loop_signal(uv_loop_t* loop,\n \n   item = uv__malloc(sizeof(*item));\n   if (item == NULL)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   item->handle = handle;\n   item->type = type;\n@@ -817,7 +817,7 @@ int uv__fsevents_init(uv_fs_event_t* handle) {\n   /* Get absolute path to file */\n   handle->realpath = realpath(handle->path, NULL);\n   if (handle->realpath == NULL)\n-    return -errno;\n+    return UV__ERR(errno);\n   handle->realpath_len = strlen(handle->realpath);\n \n   /* Initialize event queue */\n@@ -830,7 +830,7 @@ int uv__fsevents_init(uv_fs_event_t* handle) {\n    */\n   handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb));\n   if (handle->cf_cb == NULL) {\n-    err = -ENOMEM;\n+    err = UV_ENOMEM;\n     goto fail_cf_cb_malloc;\n   }\n \n@@ -881,7 +881,7 @@ int uv__fsevents_close(uv_fs_event_t* handle) {\n   uv__cf_loop_state_t* state;\n \n   if (handle->cf_cb == NULL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   /* Remove handle from  the list */\n   state = handle->loop->cf_state;\n@@ -895,7 +895,7 @@ int uv__fsevents_close(uv_fs_event_t* handle) {\n   assert(handle != NULL);\n   err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalClosing);\n   if (err)\n-    return -err;\n+    return UV__ERR(err);\n \n   /* Wait for deinitialization */\n   uv_sem_wait(&state->fsevent_sem);"
        },
        {
            "sha": "10e8afd75e831b93c0868d3ba8051aa23955374c",
            "filename": "deps/uv/src/unix/getaddrinfo.c",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fgetaddrinfo.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fgetaddrinfo.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fgetaddrinfo.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -86,7 +86,7 @@ int uv__getaddrinfo_translate_error(int sys_err) {\n   case EAI_SOCKTYPE: return UV_EAI_SOCKTYPE;\n #endif\n #if defined(EAI_SYSTEM)\n-  case EAI_SYSTEM: return -errno;\n+  case EAI_SYSTEM: return UV__ERR(errno);\n #endif\n   }\n   assert(!\"unknown EAI_* error code\");\n@@ -125,7 +125,7 @@ static void uv__getaddrinfo_done(struct uv__work* w, int status) {\n   req->service = NULL;\n   req->hostname = NULL;\n \n-  if (status == -ECANCELED) {\n+  if (status == UV_ECANCELED) {\n     assert(req->retcode == 0);\n     req->retcode = UV_EAI_CANCELED;\n   }\n@@ -148,15 +148,15 @@ int uv_getaddrinfo(uv_loop_t* loop,\n   char* buf;\n \n   if (req == NULL || (hostname == NULL && service == NULL))\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   hostname_len = hostname ? strlen(hostname) + 1 : 0;\n   service_len = service ? strlen(service) + 1 : 0;\n   hints_len = hints ? sizeof(*hints) : 0;\n   buf = uv__malloc(hostname_len + service_len + hints_len);\n \n   if (buf == NULL)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   uv__req_init(loop, req, UV_GETADDRINFO);\n   req->loop = loop;\n@@ -211,7 +211,7 @@ int uv_if_indextoname(unsigned int ifindex, char* buffer, size_t* size) {\n     return UV_EINVAL;\n \n   if (if_indextoname(ifindex, ifname_buf) == NULL)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   len = strnlen(ifname_buf, sizeof(ifname_buf));\n "
        },
        {
            "sha": "9a4367224c7fa6e71b0184e1b1516f10a6b332b2",
            "filename": "deps/uv/src/unix/getnameinfo.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fgetnameinfo.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fgetnameinfo.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fgetnameinfo.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -61,7 +61,7 @@ static void uv__getnameinfo_done(struct uv__work* w, int status) {\n   uv__req_unregister(req->loop, req);\n   host = service = NULL;\n \n-  if (status == -ECANCELED) {\n+  if (status == UV_ECANCELED) {\n     assert(req->retcode == 0);\n     req->retcode = UV_EAI_CANCELED;\n   } else if (req->retcode == 0) {"
        },
        {
            "sha": "c50a4e76f841191a2a792720c6cc8c796aa8a4be",
            "filename": "deps/uv/src/unix/ibmi.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fibmi.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fibmi.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fibmi.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -92,7 +92,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n \n   *cpu_infos = uv__malloc(numcpus * sizeof(uv_cpu_info_t));\n   if (!*cpu_infos) {\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   cpu_info = *cpu_infos;"
        },
        {
            "sha": "2bb3773c068d8e34a5ddb22e03a1fe03228ff330",
            "filename": "deps/uv/src/unix/internal.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Finternal.h",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Finternal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Finternal.h?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -29,6 +29,7 @@\n #include <string.h> /* strrchr */\n #include <fcntl.h>  /* O_CLOEXEC, may be */\n #include <stdio.h>\n+#include <errno.h>\n \n #if defined(__STRICT_ANSI__)\n # define inline __inline"
        },
        {
            "sha": "a30fd730ff872e21e0ddadcd88b841683f38529d",
            "filename": "deps/uv/src/unix/kqueue.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fkqueue.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fkqueue.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fkqueue.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -51,7 +51,7 @@ static void uv__fs_event(uv_loop_t* loop, uv__io_t* w, unsigned int fflags);\n int uv__kqueue_init(uv_loop_t* loop) {\n   loop->backend_fd = kqueue();\n   if (loop->backend_fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   uv__cloexec(loop->backend_fd, 1);\n \n@@ -98,7 +98,7 @@ int uv__io_check_fd(uv_loop_t* loop, int fd) {\n   rc = 0;\n   EV_SET(&ev, fd, EVFILT_READ, EV_ADD, 0, 0, 0);\n   if (kevent(loop->backend_fd, &ev, 1, NULL, 0, NULL))\n-    rc = -errno;\n+    rc = UV__ERR(errno);\n \n   EV_SET(&ev, fd, EVFILT_READ, EV_DELETE, 0, 0, 0);\n   if (rc == 0)\n@@ -458,12 +458,12 @@ int uv_fs_event_start(uv_fs_event_t* handle,\n   int fd;\n \n   if (uv__is_active(handle))\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   /* TODO open asynchronously - but how do we report back errors? */\n   fd = open(path, O_RDONLY);\n   if (fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   uv__handle_start(handle);\n   uv__io_init(&handle->event_watcher, uv__fs_event, fd);"
        },
        {
            "sha": "b63c25f3c2258f450a8f59be790920682ba123de",
            "filename": "deps/uv/src/unix/linux-core.c",
            "status": "modified",
            "additions": 17,
            "deletions": 17,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Flinux-core.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Flinux-core.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Flinux-core.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -101,7 +101,7 @@ int uv__platform_loop_init(uv_loop_t* loop) {\n   loop->inotify_watchers = NULL;\n \n   if (fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -175,7 +175,7 @@ int uv__io_check_fd(uv_loop_t* loop, int fd) {\n   rc = 0;\n   if (uv__epoll_ctl(loop->backend_fd, UV__EPOLL_CTL_ADD, fd, &e))\n     if (errno != EEXIST)\n-      rc = -errno;\n+      rc = UV__ERR(errno);\n \n   if (rc == 0)\n     if (uv__epoll_ctl(loop->backend_fd, UV__EPOLL_CTL_DEL, fd, &e))\n@@ -485,15 +485,15 @@ int uv_resident_set_memory(size_t* rss) {\n   while (fd == -1 && errno == EINTR);\n \n   if (fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   do\n     n = read(fd, buf, sizeof(buf) - 1);\n   while (n == -1 && errno == EINTR);\n \n   uv__close(fd);\n   if (n == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n   buf[n] = '\\0';\n \n   s = strchr(buf, ' ');\n@@ -525,7 +525,7 @@ int uv_resident_set_memory(size_t* rss) {\n   return 0;\n \n err:\n-  return -EINVAL;\n+  return UV_EINVAL;\n }\n \n \n@@ -547,7 +547,7 @@ int uv_uptime(double* uptime) {\n   }\n \n   if (r)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *uptime = now.tv_sec;\n   return 0;\n@@ -559,7 +559,7 @@ static int uv__cpu_num(FILE* statfile_fp, unsigned int* numcpus) {\n   char buf[1024];\n \n   if (!fgets(buf, sizeof(buf), statfile_fp))\n-    return -EIO;\n+    return UV_EIO;\n \n   num = 0;\n   while (fgets(buf, sizeof(buf), statfile_fp)) {\n@@ -569,7 +569,7 @@ static int uv__cpu_num(FILE* statfile_fp, unsigned int* numcpus) {\n   }\n \n   if (num == 0)\n-    return -EIO;\n+    return UV_EIO;\n \n   *numcpus = num;\n   return 0;\n@@ -587,13 +587,13 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n \n   statfile_fp = uv__open_file(\"/proc/stat\");\n   if (statfile_fp == NULL)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   err = uv__cpu_num(statfile_fp, &numcpus);\n   if (err < 0)\n     goto out;\n \n-  err = -ENOMEM;\n+  err = UV_ENOMEM;\n   ci = uv__calloc(numcpus, sizeof(*ci));\n   if (ci == NULL)\n     goto out;\n@@ -667,7 +667,7 @@ static int read_models(unsigned int numcpus, uv_cpu_info_t* ci) {\n     defined(__x86_64__)\n   fp = uv__open_file(\"/proc/cpuinfo\");\n   if (fp == NULL)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   while (fgets(buf, sizeof(buf), fp)) {\n     if (model_idx < numcpus) {\n@@ -676,7 +676,7 @@ static int read_models(unsigned int numcpus, uv_cpu_info_t* ci) {\n         model = uv__strndup(model, strlen(model) - 1);  /* Strip newline. */\n         if (model == NULL) {\n           fclose(fp);\n-          return -ENOMEM;\n+          return UV_ENOMEM;\n         }\n         ci[model_idx++].model = model;\n         continue;\n@@ -695,7 +695,7 @@ static int read_models(unsigned int numcpus, uv_cpu_info_t* ci) {\n         model = uv__strndup(model, strlen(model) - 1);  /* Strip newline. */\n         if (model == NULL) {\n           fclose(fp);\n-          return -ENOMEM;\n+          return UV_ENOMEM;\n         }\n         ci[model_idx++].model = model;\n         continue;\n@@ -725,7 +725,7 @@ static int read_models(unsigned int numcpus, uv_cpu_info_t* ci) {\n   while (model_idx < numcpus) {\n     model = uv__strndup(inferred_model, strlen(inferred_model));\n     if (model == NULL)\n-      return -ENOMEM;\n+      return UV_ENOMEM;\n     ci[model_idx++].model = model;\n   }\n \n@@ -854,15 +854,15 @@ static int uv__ifaddr_exclude(struct ifaddrs *ent, int exclude_type) {\n int uv_interface_addresses(uv_interface_address_t** addresses,\n   int* count) {\n #ifndef HAVE_IFADDRS_H\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n #else\n   struct ifaddrs *addrs, *ent;\n   uv_interface_address_t* address;\n   int i;\n   struct sockaddr_ll *sll;\n \n   if (getifaddrs(&addrs))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *count = 0;\n   *addresses = NULL;\n@@ -881,7 +881,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses,\n   *addresses = uv__malloc(*count * sizeof(**addresses));\n   if (!(*addresses)) {\n     freeifaddrs(addrs);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   address = *addresses;"
        },
        {
            "sha": "bcad630fabf112c317a4628861259f2809026854",
            "filename": "deps/uv/src/unix/linux-inotify.c",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Flinux-inotify.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Flinux-inotify.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Flinux-inotify.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -73,11 +73,11 @@ static int new_inotify_fd(void) {\n     return fd;\n \n   if (errno != ENOSYS)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   fd = uv__inotify_init();\n   if (fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   err = uv__cloexec(fd, 1);\n   if (err == 0)\n@@ -283,7 +283,7 @@ int uv_fs_event_start(uv_fs_event_t* handle,\n   int wd;\n \n   if (uv__is_active(handle))\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   err = init_inotify(handle->loop);\n   if (err)\n@@ -300,15 +300,15 @@ int uv_fs_event_start(uv_fs_event_t* handle,\n \n   wd = uv__inotify_add_watch(handle->loop->inotify_fd, path, events);\n   if (wd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   w = find_watcher(handle->loop, wd);\n   if (w)\n     goto no_insert;\n \n   w = uv__malloc(sizeof(*w) + strlen(path) + 1);\n   if (w == NULL)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   w->wd = wd;\n   w->path = strcpy((char*)(w + 1), path);"
        },
        {
            "sha": "b8c1c2a7102ac3e4376f882e1205ed5e4a92d5a6",
            "filename": "deps/uv/src/unix/loop-watcher.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Floop-watcher.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Floop-watcher.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Floop-watcher.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -31,7 +31,7 @@\n                                                                               \\\n   int uv_##name##_start(uv_##name##_t* handle, uv_##name##_cb cb) {           \\\n     if (uv__is_active(handle)) return 0;                                      \\\n-    if (cb == NULL) return -EINVAL;                                           \\\n+    if (cb == NULL) return UV_EINVAL;                                         \\\n     QUEUE_INSERT_HEAD(&handle->loop->name##_handles, &handle->queue);         \\\n     handle->name##_cb = cb;                                                   \\\n     uv__handle_start(handle);                                                 \\"
        },
        {
            "sha": "2605c114bca72dc20590d5721f8dbfaf698b6bf2",
            "filename": "deps/uv/src/unix/netbsd.c",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fnetbsd.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fnetbsd.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fnetbsd.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -82,7 +82,7 @@ int uv_exepath(char* buffer, size_t* size) {\n   int mib[4];\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   mib[0] = CTL_KERN;\n   mib[1] = KERN_PROC_ARGS;\n@@ -91,7 +91,7 @@ int uv_exepath(char* buffer, size_t* size) {\n   int_size = ARRAY_SIZE(int_buf);\n \n   if (sysctl(mib, 4, int_buf, &int_size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   /* Copy string from the intermediate buffer to outer one with appropriate\n    * length.\n@@ -111,7 +111,7 @@ uint64_t uv_get_free_memory(void) {\n   int which[] = {CTL_VM, VM_UVMEXP};\n \n   if (sysctl(which, 2, &info, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return (uint64_t) info.free * sysconf(_SC_PAGESIZE);\n }\n@@ -128,7 +128,7 @@ uint64_t uv_get_total_memory(void) {\n   size_t size = sizeof(info);\n \n   if (sysctl(which, 2, &info, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return (uint64_t) info;\n }\n@@ -150,7 +150,7 @@ int uv_set_process_title(const char* title) {\n \n   if (process_title == NULL) {\n     uv_mutex_unlock(&process_title_mutex);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   uv__free(process_title);\n@@ -167,7 +167,7 @@ int uv_get_process_title(char* buffer, size_t size) {\n   size_t len;\n \n   if (buffer == NULL || size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   uv_once(&process_title_mutex_once, init_process_title_mutex_once);\n   uv_mutex_lock(&process_title_mutex);\n@@ -177,7 +177,7 @@ int uv_get_process_title(char* buffer, size_t size) {\n \n     if (size < len) {\n       uv_mutex_unlock(&process_title_mutex);\n-      return -ENOBUFS;\n+      return UV_ENOBUFS;\n     }\n \n     memcpy(buffer, process_title, len);\n@@ -219,7 +219,7 @@ int uv_resident_set_memory(size_t* rss) {\n \n error:\n   if (kd) kvm_close(kd);\n-  return -EPERM;\n+  return UV_EPERM;\n }\n \n \n@@ -230,7 +230,7 @@ int uv_uptime(double* uptime) {\n   static int which[] = {CTL_KERN, KERN_BOOTTIME};\n \n   if (sysctl(which, 2, &info, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   now = time(NULL);\n \n@@ -254,12 +254,12 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n   size = sizeof(model);\n   if (sysctlbyname(\"machdep.cpu_brand\", &model, &size, NULL, 0) &&\n       sysctlbyname(\"hw.model\", &model, &size, NULL, 0)) {\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   size = sizeof(numcpus);\n   if (sysctlbyname(\"hw.ncpu\", &numcpus, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n   *count = numcpus;\n \n   /* Only i386 and amd64 have machdep.tsc_freq */\n@@ -270,16 +270,16 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n   size = numcpus * CPUSTATES * sizeof(*cp_times);\n   cp_times = uv__malloc(size);\n   if (cp_times == NULL)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   if (sysctlbyname(\"kern.cp_time\", cp_times, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));\n   if (!(*cpu_infos)) {\n     uv__free(cp_times);\n     uv__free(*cpu_infos);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   for (i = 0; i < numcpus; i++) {"
        },
        {
            "sha": "158643af1ef52849e418940cfb78e1adf1eec416",
            "filename": "deps/uv/src/unix/no-fsevents.c",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fno-fsevents.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fno-fsevents.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fno-fsevents.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -25,16 +25,16 @@\n #include <errno.h>\n \n int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle) {\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n }\n \n int uv_fs_event_start(uv_fs_event_t* handle, uv_fs_event_cb cb,\n                       const char* filename, unsigned int flags) {\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n }\n \n int uv_fs_event_stop(uv_fs_event_t* handle) {\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n }\n \n void uv__fs_event_close(uv_fs_event_t* handle) {"
        },
        {
            "sha": "165740ca3ff9d5536498968bf02cccc431a569ac",
            "filename": "deps/uv/src/unix/no-proctitle.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fno-proctitle.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fno-proctitle.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fno-proctitle.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -35,7 +35,7 @@ int uv_set_process_title(const char* title) {\n \n int uv_get_process_title(char* buffer, size_t size) {\n   if (buffer == NULL || size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   buffer[0] = '\\0';\n   return 0;"
        },
        {
            "sha": "ce937cd3efec25eef35ed397e01fed416b0ce608",
            "filename": "deps/uv/src/unix/openbsd.c",
            "status": "modified",
            "additions": 16,
            "deletions": 16,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fopenbsd.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fopenbsd.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fopenbsd.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -78,11 +78,11 @@ int uv_exepath(char* buffer, size_t* size) {\n   int err;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   mypid = getpid();\n   for (;;) {\n-    err = -ENOMEM;\n+    err = UV_ENOMEM;\n     argsbuf_tmp = uv__realloc(argsbuf, argsbuf_size);\n     if (argsbuf_tmp == NULL)\n       goto out;\n@@ -95,14 +95,14 @@ int uv_exepath(char* buffer, size_t* size) {\n       break;\n     }\n     if (errno != ENOMEM) {\n-      err = -errno;\n+      err = UV__ERR(errno);\n       goto out;\n     }\n     argsbuf_size *= 2U;\n   }\n \n   if (argsbuf[0] == NULL) {\n-    err = -EINVAL;  /* FIXME(bnoordhuis) More appropriate error. */\n+    err = UV_EINVAL;  /* FIXME(bnoordhuis) More appropriate error. */\n     goto out;\n   }\n \n@@ -128,7 +128,7 @@ uint64_t uv_get_free_memory(void) {\n   int which[] = {CTL_VM, VM_UVMEXP};\n \n   if (sysctl(which, 2, &info, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return (uint64_t) info.free * sysconf(_SC_PAGESIZE);\n }\n@@ -140,7 +140,7 @@ uint64_t uv_get_total_memory(void) {\n   size_t size = sizeof(info);\n \n   if (sysctl(which, 2, &info, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return (uint64_t) info;\n }\n@@ -162,7 +162,7 @@ int uv_set_process_title(const char* title) {\n \n   if (process_title == NULL) {\n     uv_mutex_unlock(&process_title_mutex);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   uv__free(process_title);\n@@ -179,7 +179,7 @@ int uv_get_process_title(char* buffer, size_t size) {\n   size_t len;\n \n   if (buffer == NULL || size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   uv_once(&process_title_mutex_once, init_process_title_mutex_once);\n   uv_mutex_lock(&process_title_mutex);\n@@ -189,7 +189,7 @@ int uv_get_process_title(char* buffer, size_t size) {\n \n     if (size < len) {\n       uv_mutex_unlock(&process_title_mutex);\n-      return -ENOBUFS;\n+      return UV_ENOBUFS;\n     }\n \n     memcpy(buffer, process_title, len);\n@@ -219,7 +219,7 @@ int uv_resident_set_memory(size_t* rss) {\n   mib[5] = 1;\n \n   if (sysctl(mib, 6, &kinfo, &size, NULL, 0) < 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *rss = kinfo.p_vm_rssize * page_size;\n   return 0;\n@@ -233,7 +233,7 @@ int uv_uptime(double* uptime) {\n   static int which[] = {CTL_KERN, KERN_BOOTTIME};\n \n   if (sysctl(which, 2, &info, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   now = time(NULL);\n \n@@ -255,24 +255,24 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n \n   size = sizeof(model);\n   if (sysctl(which, 2, &model, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   which[1] = HW_NCPU;\n   size = sizeof(numcpus);\n   if (sysctl(which, 2, &numcpus, &size, NULL, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));\n   if (!(*cpu_infos))\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   *count = numcpus;\n \n   which[1] = HW_CPUSPEED;\n   size = sizeof(cpuspeed);\n   if (sysctl(which, 2, &cpuspeed, &size, NULL, 0)) {\n     uv__free(*cpu_infos);\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   size = sizeof(info);\n@@ -283,7 +283,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n     size = sizeof(info);\n     if (sysctl(which, 3, &info, &size, NULL, 0)) {\n       uv__free(*cpu_infos);\n-      return -errno;\n+      return UV__ERR(errno);\n     }\n \n     cpu_info = &(*cpu_infos)[i];"
        },
        {
            "sha": "f766b393395ee7119fbc54fada562d297645569a",
            "filename": "deps/uv/src/unix/os390.c",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fos390.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fos390.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fos390.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -122,7 +122,7 @@ int uv__platform_loop_init(uv_loop_t* loop) {\n   ep = epoll_create1(0);\n   loop->ep = ep;\n   if (ep == NULL)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -259,12 +259,12 @@ int uv_exepath(char* buffer, size_t* size) {\n   int pid;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   pid = getpid();\n   res = getexe(pid, args, sizeof(args));\n   if (res < 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   /*\n    * Possibilities for args:\n@@ -277,7 +277,7 @@ int uv_exepath(char* buffer, size_t* size) {\n   /* Case i) and ii) absolute or relative paths */\n   if (strchr(args, '/') != NULL) {\n     if (realpath(args, abspath) != abspath)\n-      return -errno;\n+      return UV__ERR(errno);\n \n     abspath_size = strlen(abspath);\n \n@@ -297,11 +297,11 @@ int uv_exepath(char* buffer, size_t* size) {\n     char* path = getenv(\"PATH\");\n \n     if (path == NULL)\n-      return -EINVAL;\n+      return UV_EINVAL;\n \n     clonedpath = uv__strdup(path);\n     if (clonedpath == NULL)\n-      return -ENOMEM;\n+      return UV_ENOMEM;\n \n     token = strtok(clonedpath, \":\");\n     while (token != NULL) {\n@@ -327,7 +327,7 @@ int uv_exepath(char* buffer, size_t* size) {\n     uv__free(clonedpath);\n \n     /* Out of tokens (path entries), and no match found */\n-    return -EINVAL;\n+    return UV_EINVAL;\n   }\n }\n \n@@ -407,7 +407,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n \n   *cpu_infos = uv__malloc(*count * sizeof(uv_cpu_info_t));\n   if (!*cpu_infos)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   cpu_info = *cpu_infos;\n   idx = 0;\n@@ -452,15 +452,15 @@ static int uv__interface_addresses_v6(uv_interface_address_t** addresses,\n   maxsize = 16384;\n \n   if (0 > (sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   ifc.__nif6h_version = 1;\n   ifc.__nif6h_buflen = maxsize;\n   ifc.__nif6h_buffer = uv__calloc(1, maxsize);;\n \n   if (ioctl(sockfd, SIOCGIFCONF6, &ifc) == -1) {\n     uv__close(sockfd);\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n \n@@ -484,7 +484,7 @@ static int uv__interface_addresses_v6(uv_interface_address_t** addresses,\n   *addresses = uv__malloc(*count * sizeof(uv_interface_address_t));\n   if (!(*addresses)) {\n     uv__close(sockfd);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n   address = *addresses;\n \n@@ -543,13 +543,13 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n \n   sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);\n   if (0 > sockfd)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   ifc.ifc_req = uv__calloc(1, maxsize);\n   ifc.ifc_len = maxsize;\n   if (ioctl(sockfd, SIOCGIFCONF, &ifc) == -1) {\n     uv__close(sockfd);\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n #define MAX(a,b) (((a)>(b))?(a):(b))\n@@ -569,7 +569,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n     memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));\n     if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {\n       uv__close(sockfd);\n-      return -errno;\n+      return UV__ERR(errno);\n     }\n \n     if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))\n@@ -584,7 +584,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n \n   if (!(*addresses)) {\n     uv__close(sockfd);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n   address = *addresses;\n \n@@ -607,7 +607,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n     memcpy(flg.ifr_name, p->ifr_name, sizeof(flg.ifr_name));\n     if (ioctl(sockfd, SIOCGIFFLAGS, &flg) == -1) {\n       uv__close(sockfd);\n-      return -ENOSYS;\n+      return UV_ENOSYS;\n     }\n \n     if (!(flg.ifr_flags & IFF_UP && flg.ifr_flags & IFF_RUNNING))\n@@ -706,7 +706,7 @@ int uv_fs_event_start(uv_fs_event_t* handle, uv_fs_event_cb cb,\n   int rc;\n \n   if (uv__is_active(handle))\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   ep = handle->loop->ep;\n   assert(ep->msg_queue != -1);\n@@ -718,11 +718,11 @@ int uv_fs_event_start(uv_fs_event_t* handle, uv_fs_event_cb cb,\n \n   path = uv__strdup(filename);\n   if (path == NULL)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   rc = __w_pioctl(path, _IOCC_REGFILEINT, sizeof(reg_struct), &reg_struct);\n   if (rc != 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   uv__handle_start(handle);\n   handle->path = path;"
        },
        {
            "sha": "e640bf29fc1754fe4e0738dc5cd92f54883ef0ff",
            "filename": "deps/uv/src/unix/pipe.c",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fpipe.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fpipe.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fpipe.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -50,12 +50,12 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n \n   /* Already bound? */\n   if (uv__stream_fd(handle) >= 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   /* Make a copy of the file name, it outlives this function's scope. */\n   pipe_fname = uv__strdup(name);\n   if (pipe_fname == NULL)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   /* We've got a copy, don't touch the original any more. */\n   name = NULL;\n@@ -71,10 +71,10 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n   saddr.sun_family = AF_UNIX;\n \n   if (bind(sockfd, (struct sockaddr*)&saddr, sizeof saddr)) {\n-    err = -errno;\n+    err = UV__ERR(errno);\n     /* Convert ENOENT to EACCES for compatibility with Windows. */\n-    if (err == -ENOENT)\n-      err = -EACCES;\n+    if (err == UV_ENOENT)\n+      err = UV_EACCES;\n \n     uv__close(sockfd);\n     goto err_socket;\n@@ -94,7 +94,7 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n \n int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {\n   if (uv__stream_fd(handle) == -1)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n #if defined(__MVS__)\n   /* On zOS, backlog=0 has undefined behaviour */\n@@ -105,7 +105,7 @@ int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {\n #endif\n \n   if (listen(uv__stream_fd(handle), backlog))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   handle->connection_cb = cb;\n   handle->io_watcher.cb = uv__server_io;\n@@ -180,14 +180,14 @@ void uv_pipe_connect(uv_connect_t* req,\n   while (r == -1 && errno == EINTR);\n \n   if (r == -1 && errno != EINPROGRESS) {\n-    err = -errno;\n+    err = UV__ERR(errno);\n #if defined(__CYGWIN__) || defined(__MSYS__)\n     /* EBADF is supposed to mean that the socket fd is bad, but\n        Cygwin reports EBADF instead of ENOTSOCK when the file is\n        not a socket.  We do not expect to see a bad fd here\n        (e.g. due to new_sock), so translate the error.  */\n-    if (err == -EBADF)\n-      err = -ENOTSOCK;\n+    if (err == UV_EBADF)\n+      err = UV_ENOTSOCK;\n #endif\n     goto out;\n   }\n@@ -234,7 +234,7 @@ static int uv__pipe_getsockpeername(const uv_pipe_t* handle,\n   err = func(uv__stream_fd(handle), (struct sockaddr*) &sa, &addrlen);\n   if (err < 0) {\n     *size = 0;\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n #if defined(__linux__)\n@@ -312,15 +312,15 @@ int uv_pipe_chmod(uv_pipe_t* handle, int mode) {\n   int r;\n \n   if (handle == NULL || uv__stream_fd(handle) == -1)\n-    return -EBADF;\n+    return UV_EBADF;\n \n   if (mode != UV_READABLE &&\n       mode != UV_WRITABLE &&\n       mode != (UV_WRITABLE | UV_READABLE))\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (fstat(uv__stream_fd(handle), &pipe_stat) == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   desired_mode = 0;\n   if (mode & UV_READABLE)\n@@ -353,5 +353,5 @@ int uv_pipe_chmod(uv_pipe_t* handle, int mode) {\n   r = chmod(name_buffer, pipe_stat.st_mode);\n   uv__free(name_buffer);\n \n-  return r != -1 ? 0 : -errno;\n+  return r != -1 ? 0 : UV__ERR(errno);\n }"
        },
        {
            "sha": "f3b0bf4e433942113c64ee1b76217b4f08e34b2b",
            "filename": "deps/uv/src/unix/poll.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fpoll.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fpoll.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fpoll.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -47,7 +47,7 @@ static void uv__poll_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n   if ((events & POLLERR) && !(events & UV__POLLPRI)) {\n     uv__io_stop(loop, w, POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI);\n     uv__handle_stop(handle);\n-    handle->poll_cb(handle, -EBADF, 0);\n+    handle->poll_cb(handle, UV_EBADF, 0);\n     return;\n   }\n \n@@ -76,7 +76,7 @@ int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd) {\n    * Workaround for e.g. kqueue fds not supporting ioctls.\n    */\n   err = uv__nonblock(fd, 1);\n-  if (err == -ENOTTY)\n+  if (err == UV_ENOTTY)\n     if (uv__nonblock == uv__nonblock_ioctl)\n       err = uv__nonblock_fcntl(fd, 1);\n "
        },
        {
            "sha": "f356e76c79daec7ac94de5aae754d5228caa6d4a",
            "filename": "deps/uv/src/unix/posix-poll.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fposix-poll.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fposix-poll.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fposix-poll.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -315,10 +315,10 @@ int uv__io_check_fd(uv_loop_t* loop, int fd) {\n   while (rv == -1 && (errno == EINTR || errno == EAGAIN));\n \n   if (rv == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   if (p[0].revents & POLLNVAL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   return 0;\n }"
        },
        {
            "sha": "74113e3a696cc29ce67e164add3f19b927024b44",
            "filename": "deps/uv/src/unix/process.c",
            "status": "modified",
            "additions": 20,
            "deletions": 20,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fprocess.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fprocess.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fprocess.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -126,15 +126,15 @@ int uv__make_socketpair(int fds[2], int flags) {\n    * Anything else is a genuine error.\n    */\n   if (errno != EINVAL)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   no_cloexec = 1;\n \n skip:\n #endif\n \n   if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   uv__cloexec(fds[0], 1);\n   uv__cloexec(fds[1], 1);\n@@ -159,15 +159,15 @@ int uv__make_pipe(int fds[2], int flags) {\n     return 0;\n \n   if (errno != ENOSYS)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   no_pipe2 = 1;\n \n skip:\n #endif\n \n   if (pipe(fds))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   uv__cloexec(fds[0], 1);\n   uv__cloexec(fds[1], 1);\n@@ -198,7 +198,7 @@ static int uv__process_init_stdio(uv_stdio_container_t* container, int fds[2]) {\n   case UV_CREATE_PIPE:\n     assert(container->data.stream != NULL);\n     if (container->data.stream->type != UV_NAMED_PIPE)\n-      return -EINVAL;\n+      return UV_EINVAL;\n     else\n       return uv__make_socketpair(fds, 0);\n \n@@ -210,14 +210,14 @@ static int uv__process_init_stdio(uv_stdio_container_t* container, int fds[2]) {\n       fd = uv__stream_fd(container->data.stream);\n \n     if (fd == -1)\n-      return -EINVAL;\n+      return UV_EINVAL;\n \n     fds[1] = fd;\n     return 0;\n \n   default:\n     assert(0 && \"Unexpected flags\");\n-    return -EINVAL;\n+    return UV_EINVAL;\n   }\n }\n \n@@ -299,7 +299,7 @@ static void uv__process_child_init(const uv_process_options_t* options,\n       continue;\n     pipes[fd][1] = fcntl(use_fd, F_DUPFD, stdio_count);\n     if (pipes[fd][1] == -1) {\n-      uv__write_int(error_fd, -errno);\n+      uv__write_int(error_fd, UV__ERR(errno));\n       _exit(127);\n     }\n   }\n@@ -319,7 +319,7 @@ static void uv__process_child_init(const uv_process_options_t* options,\n         close_fd = use_fd;\n \n         if (use_fd == -1) {\n-          uv__write_int(error_fd, -errno);\n+          uv__write_int(error_fd, UV__ERR(errno));\n           _exit(127);\n         }\n       }\n@@ -331,7 +331,7 @@ static void uv__process_child_init(const uv_process_options_t* options,\n       fd = dup2(use_fd, fd);\n \n     if (fd == -1) {\n-      uv__write_int(error_fd, -errno);\n+      uv__write_int(error_fd, UV__ERR(errno));\n       _exit(127);\n     }\n \n@@ -350,7 +350,7 @@ static void uv__process_child_init(const uv_process_options_t* options,\n   }\n \n   if (options->cwd != NULL && chdir(options->cwd)) {\n-    uv__write_int(error_fd, -errno);\n+    uv__write_int(error_fd, UV__ERR(errno));\n     _exit(127);\n   }\n \n@@ -366,12 +366,12 @@ static void uv__process_child_init(const uv_process_options_t* options,\n   }\n \n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n-    uv__write_int(error_fd, -errno);\n+    uv__write_int(error_fd, UV__ERR(errno));\n     _exit(127);\n   }\n \n   if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n-    uv__write_int(error_fd, -errno);\n+    uv__write_int(error_fd, UV__ERR(errno));\n     _exit(127);\n   }\n \n@@ -391,7 +391,7 @@ static void uv__process_child_init(const uv_process_options_t* options,\n     if (SIG_ERR != signal(n, SIG_DFL))\n       continue;\n \n-    uv__write_int(error_fd, -errno);\n+    uv__write_int(error_fd, UV__ERR(errno));\n     _exit(127);\n   }\n \n@@ -400,12 +400,12 @@ static void uv__process_child_init(const uv_process_options_t* options,\n   err = pthread_sigmask(SIG_SETMASK, &set, NULL);\n \n   if (err != 0) {\n-    uv__write_int(error_fd, -err);\n+    uv__write_int(error_fd, UV__ERR(err));\n     _exit(127);\n   }\n \n   execvp(options->file, options->args);\n-  uv__write_int(error_fd, -errno);\n+  uv__write_int(error_fd, UV__ERR(errno));\n   _exit(127);\n }\n #endif\n@@ -416,7 +416,7 @@ int uv_spawn(uv_loop_t* loop,\n              const uv_process_options_t* options) {\n #if defined(__APPLE__) && (TARGET_OS_TV || TARGET_OS_WATCH)\n   /* fork is marked __WATCHOS_PROHIBITED __TVOS_PROHIBITED. */\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n #else\n   int signal_pipe[2] = { -1, -1 };\n   int pipes_storage[8][2];\n@@ -443,7 +443,7 @@ int uv_spawn(uv_loop_t* loop,\n   if (stdio_count < 3)\n     stdio_count = 3;\n \n-  err = -ENOMEM;\n+  err = UV_ENOMEM;\n   pipes = pipes_storage;\n   if (stdio_count > (int) ARRAY_SIZE(pipes_storage))\n     pipes = uv__malloc(stdio_count * sizeof(*pipes));\n@@ -493,7 +493,7 @@ int uv_spawn(uv_loop_t* loop,\n   pid = fork();\n \n   if (pid == -1) {\n-    err = -errno;\n+    err = UV__ERR(errno);\n     uv_rwlock_wrunlock(&loop->cloexec_lock);\n     uv__close(signal_pipe[0]);\n     uv__close(signal_pipe[1]);\n@@ -585,7 +585,7 @@ int uv_process_kill(uv_process_t* process, int signum) {\n \n int uv_kill(int pid, int signum) {\n   if (kill(pid, signum))\n-    return -errno;\n+    return UV__ERR(errno);\n   else\n     return 0;\n }"
        },
        {
            "sha": "00dc021f21e71fb343ab7a1a4e144e067bf987a6",
            "filename": "deps/uv/src/unix/procfs-exepath.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fprocfs-exepath.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fprocfs-exepath.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fprocfs-exepath.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -29,14 +29,14 @@ int uv_exepath(char* buffer, size_t* size) {\n   ssize_t n;\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   n = *size - 1;\n   if (n > 0)\n     n = readlink(\"/proc/self/exe\", buffer, n);\n \n   if (n == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   buffer[n] = '\\0';\n   *size = n;"
        },
        {
            "sha": "1a8c7a7090e8a6bf460da019a35a24609b0bc61e",
            "filename": "deps/uv/src/unix/proctitle.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fproctitle.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fproctitle.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fproctitle.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -105,14 +105,14 @@ int uv_set_process_title(const char* title) {\n \n int uv_get_process_title(char* buffer, size_t size) {\n   if (buffer == NULL || size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   uv_once(&process_title_mutex_once, init_process_title_mutex_once);\n   uv_mutex_lock(&process_title_mutex);\n \n   if (size <= process_title.len) {\n     uv_mutex_unlock(&process_title_mutex);\n-    return -ENOBUFS;\n+    return UV_ENOBUFS;\n   }\n \n   if (process_title.len != 0)"
        },
        {
            "sha": "b9d0a56084c6b35ff7a4f7c2da5ab4ea70ff3f49",
            "filename": "deps/uv/src/unix/signal.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fsignal.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fsignal.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fsignal.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -225,7 +225,7 @@ static int uv__signal_register_handler(int signum, int oneshot) {\n \n   /* XXX save old action so we can restore it later on? */\n   if (sigaction(signum, &sa, NULL))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -362,7 +362,7 @@ static int uv__signal_start(uv_signal_t* handle,\n    * eventually.\n    */\n   if (signum == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   /* Short circuit: if the signal watcher is already watching {signum} don't\n    * go through the process of deregistering and registering the handler."
        },
        {
            "sha": "3e786abee015c44052af15bb1ba526aebfa7ff16",
            "filename": "deps/uv/src/unix/stream.c",
            "status": "modified",
            "additions": 45,
            "deletions": 39,
            "changes": 84,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fstream.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -58,6 +58,12 @@ struct uv__stream_select_s {\n   fd_set* swrite;\n   size_t swrite_sz;\n };\n+# define WRITE_RETRY_ON_ERROR(send_handle) \\\n+    (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS || \\\n+     (errno == EMSGSIZE && send_handle))\n+#else\n+# define WRITE_RETRY_ON_ERROR(send_handle) \\\n+    (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)\n #endif /* defined(__APPLE__) */\n \n static void uv__stream_connect(uv_stream_t*);\n@@ -282,7 +288,7 @@ int uv__stream_try_select(uv_stream_t* stream, int* fd) {\n   kq = kqueue();\n   if (kq == -1) {\n     perror(\"(libuv) kqueue()\");\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   EV_SET(&filter[0], *fd, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, 0);\n@@ -298,7 +304,7 @@ int uv__stream_try_select(uv_stream_t* stream, int* fd) {\n   uv__close(kq);\n \n   if (ret == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   if (ret == 0 || (events[0].flags & EV_ERROR) == 0 || events[0].data != EINVAL)\n     return 0;\n@@ -310,7 +316,7 @@ int uv__stream_try_select(uv_stream_t* stream, int* fd) {\n    * NOTE: do it ahead of malloc below to allocate enough space for fd_sets\n    */\n   if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   max_fd = *fd;\n   if (fds[1] > max_fd)\n@@ -321,7 +327,7 @@ int uv__stream_try_select(uv_stream_t* stream, int* fd) {\n \n   s = uv__malloc(sizeof(*s) + sread_sz + swrite_sz);\n   if (s == NULL) {\n-    err = -ENOMEM;\n+    err = UV_ENOMEM;\n     goto failed_malloc;\n   }\n \n@@ -395,26 +401,26 @@ int uv__stream_open(uv_stream_t* stream, int fd, int flags) {\n #endif\n \n   if (!(stream->io_watcher.fd == -1 || stream->io_watcher.fd == fd))\n-    return -EBUSY;\n+    return UV_EBUSY;\n \n   assert(fd >= 0);\n   stream->flags |= flags;\n \n   if (stream->type == UV_TCP) {\n     if ((stream->flags & UV_TCP_NODELAY) && uv__tcp_nodelay(fd, 1))\n-      return -errno;\n+      return UV__ERR(errno);\n \n     /* TODO Use delay the user passed in. */\n     if ((stream->flags & UV_TCP_KEEPALIVE) && uv__tcp_keepalive(fd, 1, 60))\n-      return -errno;\n+      return UV__ERR(errno);\n   }\n \n #if defined(__APPLE__)\n   enable = 1;\n   if (setsockopt(fd, SOL_SOCKET, SO_OOBINLINE, &enable, sizeof(enable)) &&\n       errno != ENOTSOCK &&\n       errno != EINVAL) {\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n #endif\n \n@@ -445,11 +451,11 @@ void uv__stream_destroy(uv_stream_t* stream) {\n \n   if (stream->connect_req) {\n     uv__req_unregister(stream->loop, stream->connect_req);\n-    stream->connect_req->cb(stream->connect_req, -ECANCELED);\n+    stream->connect_req->cb(stream->connect_req, UV_ECANCELED);\n     stream->connect_req = NULL;\n   }\n \n-  uv__stream_flush_write_queue(stream, -ECANCELED);\n+  uv__stream_flush_write_queue(stream, UV_ECANCELED);\n   uv__write_callbacks(stream);\n \n   if (stream->shutdown_req) {\n@@ -459,7 +465,7 @@ void uv__stream_destroy(uv_stream_t* stream) {\n      * callee that the handle has been destroyed.\n      */\n     uv__req_unregister(stream->loop, stream->shutdown_req);\n-    stream->shutdown_req->cb(stream->shutdown_req, -ECANCELED);\n+    stream->shutdown_req->cb(stream->shutdown_req, UV_ECANCELED);\n     stream->shutdown_req = NULL;\n   }\n \n@@ -483,7 +489,7 @@ static int uv__emfile_trick(uv_loop_t* loop, int accept_fd) {\n   int emfile_fd;\n \n   if (loop->emfile_fd == -1)\n-    return -EMFILE;\n+    return UV_EMFILE;\n \n   uv__close(loop->emfile_fd);\n   loop->emfile_fd = -1;\n@@ -492,7 +498,7 @@ static int uv__emfile_trick(uv_loop_t* loop, int accept_fd) {\n     err = uv__accept(accept_fd);\n     if (err >= 0)\n       uv__close(err);\n-  } while (err >= 0 || err == -EINTR);\n+  } while (err >= 0 || err == UV_EINTR);\n \n   emfile_fd = uv__open_cloexec(\"/\", O_RDONLY);\n   if (emfile_fd >= 0)\n@@ -533,15 +539,15 @@ void uv__server_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n \n     err = uv__accept(uv__stream_fd(stream));\n     if (err < 0) {\n-      if (err == -EAGAIN || err == -EWOULDBLOCK)\n+      if (err == UV_EAGAIN || err == UV__ERR(EWOULDBLOCK))\n         return;  /* Not an error. */\n \n-      if (err == -ECONNABORTED)\n+      if (err == UV_ECONNABORTED)\n         continue;  /* Ignore. Nothing we can do about that. */\n \n-      if (err == -EMFILE || err == -ENFILE) {\n+      if (err == UV_EMFILE || err == UV_ENFILE) {\n         err = uv__emfile_trick(loop, uv__stream_fd(stream));\n-        if (err == -EAGAIN || err == -EWOULDBLOCK)\n+        if (err == UV_EAGAIN || err == UV__ERR(EWOULDBLOCK))\n           break;\n       }\n \n@@ -577,7 +583,7 @@ int uv_accept(uv_stream_t* server, uv_stream_t* client) {\n   assert(server->loop == client->loop);\n \n   if (server->accepted_fd == -1)\n-    return -EAGAIN;\n+    return UV_EAGAIN;\n \n   switch (client->type) {\n     case UV_NAMED_PIPE:\n@@ -601,7 +607,7 @@ int uv_accept(uv_stream_t* server, uv_stream_t* client) {\n       break;\n \n     default:\n-      return -EINVAL;\n+      return UV_EINVAL;\n   }\n \n   client->flags |= UV_HANDLE_BOUND;\n@@ -649,7 +655,7 @@ int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb) {\n     break;\n \n   default:\n-    err = -EINVAL;\n+    err = UV_EINVAL;\n   }\n \n   if (err == 0)\n@@ -680,7 +686,7 @@ static void uv__drain(uv_stream_t* stream) {\n \n     err = 0;\n     if (shutdown(uv__stream_fd(stream), SHUT_WR))\n-      err = -errno;\n+      err = UV__ERR(errno);\n \n     if (err == 0)\n       stream->flags |= UV_STREAM_SHUT;\n@@ -792,7 +798,7 @@ static void uv__write(uv_stream_t* stream) {\n     } scratch;\n \n     if (uv__is_closing(req->send_handle)) {\n-      err = -EBADF;\n+      err = UV_EBADF;\n       goto error;\n     }\n \n@@ -859,8 +865,8 @@ static void uv__write(uv_stream_t* stream) {\n   }\n \n   if (n < 0) {\n-    if (errno != EAGAIN && errno != EWOULDBLOCK && errno != ENOBUFS) {\n-      err = -errno;\n+    if (!WRITE_RETRY_ON_ERROR(req->send_handle)) {\n+      err = UV__ERR(errno);\n       goto error;\n     } else if (stream->flags & UV_STREAM_BLOCKING) {\n       /* If this is a blocking stream, try again. */\n@@ -1029,7 +1035,7 @@ static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {\n     queued_fds = uv__malloc((queue_size - 1) * sizeof(*queued_fds->fds) +\n                             sizeof(*queued_fds));\n     if (queued_fds == NULL)\n-      return -ENOMEM;\n+      return UV_ENOMEM;\n     queued_fds->size = queue_size;\n     queued_fds->offset = 0;\n     stream->queued_fds = queued_fds;\n@@ -1046,7 +1052,7 @@ static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {\n      * NOTE: if it is fatal - sockets will be closed in uv__stream_close\n      */\n     if (queued_fds == NULL)\n-      return -ENOMEM;\n+      return UV_ENOMEM;\n     queued_fds->size = queue_size;\n     stream->queued_fds = queued_fds;\n   }\n@@ -1192,7 +1198,7 @@ static void uv__read(uv_stream_t* stream) {\n #endif\n       } else {\n         /* Error. User should call uv_close(). */\n-        stream->read_cb(stream, -errno, &buf);\n+        stream->read_cb(stream, UV__ERR(errno), &buf);\n         if (stream->flags & UV_STREAM_READING) {\n           stream->flags &= ~UV_STREAM_READING;\n           uv__io_stop(stream->loop, &stream->io_watcher, POLLIN);\n@@ -1269,7 +1275,7 @@ int uv_shutdown(uv_shutdown_t* req, uv_stream_t* stream, uv_shutdown_cb cb) {\n       stream->flags & UV_STREAM_SHUT ||\n       stream->flags & UV_STREAM_SHUTTING ||\n       uv__is_closing(stream)) {\n-    return -ENOTCONN;\n+    return UV_ENOTCONN;\n   }\n \n   assert(uv__stream_fd(stream) >= 0);\n@@ -1368,10 +1374,10 @@ static void uv__stream_connect(uv_stream_t* stream) {\n                SO_ERROR,\n                &error,\n                &errorsize);\n-    error = -error;\n+    error = UV__ERR(error);\n   }\n \n-  if (error == -EINPROGRESS)\n+  if (error == UV__ERR(EINPROGRESS))\n     return;\n \n   stream->connect_req = NULL;\n@@ -1388,7 +1394,7 @@ static void uv__stream_connect(uv_stream_t* stream) {\n     return;\n \n   if (error < 0) {\n-    uv__stream_flush_write_queue(stream, -ECANCELED);\n+    uv__stream_flush_write_queue(stream, UV_ECANCELED);\n     uv__write_callbacks(stream);\n   }\n }\n@@ -1409,11 +1415,11 @@ int uv_write2(uv_write_t* req,\n          \"uv_write (unix) does not yet support other types of streams\");\n \n   if (uv__stream_fd(stream) < 0)\n-    return -EBADF;\n+    return UV_EBADF;\n \n   if (send_handle) {\n     if (stream->type != UV_NAMED_PIPE || !((uv_pipe_t*)stream)->ipc)\n-      return -EINVAL;\n+      return UV_EINVAL;\n \n     /* XXX We abuse uv_write2() to send over UDP handles to child processes.\n      * Don't call uv__stream_fd() on those handles, it's a macro that on OS X\n@@ -1422,12 +1428,12 @@ int uv_write2(uv_write_t* req,\n      * which works but only by accident.\n      */\n     if (uv__handle_fd((uv_handle_t*) send_handle) < 0)\n-      return -EBADF;\n+      return UV_EBADF;\n \n #if defined(__CYGWIN__) || defined(__MSYS__)\n     /* Cygwin recvmsg always sets msg_controllen to zero, so we cannot send it.\n        See https://github.com/mirror/newlib-cygwin/blob/86fc4bf0/winsup/cygwin/fhandler_socket.cc#L1736-L1743 */\n-    return -ENOSYS;\n+    return UV_ENOSYS;\n #endif\n   }\n \n@@ -1452,7 +1458,7 @@ int uv_write2(uv_write_t* req,\n     req->bufs = uv__malloc(nbufs * sizeof(bufs[0]));\n \n   if (req->bufs == NULL)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   memcpy(req->bufs, bufs, nbufs * sizeof(bufs[0]));\n   req->nbufs = nbufs;\n@@ -1516,7 +1522,7 @@ int uv_try_write(uv_stream_t* stream,\n \n   /* Connecting or already writing some data */\n   if (stream->connect_req != NULL || stream->write_queue_size != 0)\n-    return -EAGAIN;\n+    return UV_EAGAIN;\n \n   has_pollout = uv__io_active(&stream->io_watcher, POLLOUT);\n \n@@ -1547,7 +1553,7 @@ int uv_try_write(uv_stream_t* stream,\n   }\n \n   if (written == 0 && req_size != 0)\n-    return -EAGAIN;\n+    return UV_EAGAIN;\n   else\n     return written;\n }\n@@ -1560,7 +1566,7 @@ int uv_read_start(uv_stream_t* stream,\n       stream->type == UV_TTY);\n \n   if (stream->flags & UV_CLOSING)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   /* The UV_STREAM_READING flag is irrelevant of the state of the tcp - it just\n    * expresses the desired state of the user."
        },
        {
            "sha": "b6b3dfea77a8d72d9dc51be624500813e0b704f7",
            "filename": "deps/uv/src/unix/sunos.c",
            "status": "modified",
            "additions": 21,
            "deletions": 21,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fsunos.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fsunos.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fsunos.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -73,7 +73,7 @@ int uv__platform_loop_init(uv_loop_t* loop) {\n \n   fd = port_create();\n   if (fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   err = uv__cloexec(fd, 1);\n   if (err) {\n@@ -132,7 +132,7 @@ void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {\n \n int uv__io_check_fd(uv_loop_t* loop, int fd) {\n   if (port_associate(loop->backend_fd, PORT_SOURCE_FD, fd, POLLIN, 0))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   if (port_dissociate(loop->backend_fd, PORT_SOURCE_FD, fd))\n     abort();\n@@ -342,7 +342,7 @@ int uv_exepath(char* buffer, size_t* size) {\n   char buf[128];\n \n   if (buffer == NULL || size == NULL || *size == 0)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   snprintf(buf, sizeof(buf), \"/proc/%lu/path/a.out\", (unsigned long) getpid());\n \n@@ -351,7 +351,7 @@ int uv_exepath(char* buffer, size_t* size) {\n     res = readlink(buf, buffer, res);\n \n   if (res == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   buffer[res] = '\\0';\n   *size = res;\n@@ -378,14 +378,14 @@ void uv_loadavg(double avg[3]) {\n \n static int uv__fs_event_rearm(uv_fs_event_t *handle) {\n   if (handle->fd == -1)\n-    return -EBADF;\n+    return UV_EBADF;\n \n   if (port_associate(handle->loop->fs_fd,\n                      PORT_SOURCE_FILE,\n                      (uintptr_t) &handle->fo,\n                      FILE_ATTRIB | FILE_MODIFIED,\n                      handle) == -1) {\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n   handle->fd = PORT_LOADED;\n \n@@ -462,13 +462,13 @@ int uv_fs_event_start(uv_fs_event_t* handle,\n   int err;\n \n   if (uv__is_active(handle))\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   first_run = 0;\n   if (handle->loop->fs_fd == -1) {\n     portfd = port_create();\n     if (portfd == -1)\n-      return -errno;\n+      return UV__ERR(errno);\n     handle->loop->fs_fd = portfd;\n     first_run = 1;\n   }\n@@ -521,20 +521,20 @@ void uv__fs_event_close(uv_fs_event_t* handle) {\n #else /* !defined(PORT_SOURCE_FILE) */\n \n int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle) {\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n }\n \n \n int uv_fs_event_start(uv_fs_event_t* handle,\n                       uv_fs_event_cb cb,\n                       const char* filename,\n                       unsigned int flags) {\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n }\n \n \n int uv_fs_event_stop(uv_fs_event_t* handle) {\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n }\n \n \n@@ -552,10 +552,10 @@ int uv_resident_set_memory(size_t* rss) {\n \n   fd = open(\"/proc/self/psinfo\", O_RDONLY);\n   if (fd == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   /* FIXME(bnoordhuis) Handle EINTR. */\n-  err = -EINVAL;\n+  err = UV_EINVAL;\n   if (read(fd, &psinfo, sizeof(psinfo)) == sizeof(psinfo)) {\n     *rss = (size_t)psinfo.pr_rssize * 1024;\n     err = 0;\n@@ -575,7 +575,7 @@ int uv_uptime(double* uptime) {\n \n   kc = kstat_open();\n   if (kc == NULL)\n-    return -EPERM;\n+    return UV_EPERM;\n \n   ksp = kstat_lookup(kc, (char*) \"unix\", 0, (char*) \"system_misc\");\n   if (kstat_read(kc, ksp, NULL) == -1) {\n@@ -599,7 +599,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n \n   kc = kstat_open();\n   if (kc == NULL)\n-    return -EPERM;\n+    return UV_EPERM;\n \n   /* Get count of cpus */\n   lookup_instance = 0;\n@@ -610,7 +610,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n   *cpu_infos = uv__malloc(lookup_instance * sizeof(**cpu_infos));\n   if (!(*cpu_infos)) {\n     kstat_close(kc);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   *count = lookup_instance;\n@@ -692,7 +692,7 @@ void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count) {\n \n #ifdef SUNOS_NO_IFADDRS\n int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n-  return -ENOSYS;\n+  return UV_ENOSYS;\n }\n #else  /* SUNOS_NO_IFADDRS */\n /*\n@@ -730,11 +730,11 @@ static int uv__set_phys_addr(uv_interface_address_t* address,\n \n   sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n   if (sockfd < 0)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   if (ioctl(sockfd, SIOCGARP, (char*)&arpreq) == -1) {\n     uv__close(sockfd);\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n   memcpy(address->phys_addr, arpreq.arp_ha.sa_data, sizeof(address->phys_addr));\n   uv__close(sockfd);\n@@ -759,7 +759,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n   struct ifaddrs* ent;\n \n   if (getifaddrs(&addrs))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *count = 0;\n \n@@ -773,7 +773,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n   *addresses = uv__malloc(*count * sizeof(**addresses));\n   if (!(*addresses)) {\n     freeifaddrs(addrs);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   address = *addresses;"
        },
        {
            "sha": "96f89312def0eb496895f45db294c0572aa689f8",
            "filename": "deps/uv/src/unix/tcp.c",
            "status": "modified",
            "additions": 23,
            "deletions": 23,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ftcp.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ftcp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ftcp.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -89,7 +89,7 @@ static int maybe_new_socket(uv_tcp_t* handle, int domain, unsigned long flags) {\n       slen = sizeof(saddr);\n       memset(&saddr, 0, sizeof(saddr));\n       if (getsockname(uv__stream_fd(handle), (struct sockaddr*) &saddr, &slen))\n-        return -errno;\n+        return UV__ERR(errno);\n \n       if ((saddr.ss_family == AF_INET6 &&\n           ((struct sockaddr_in6*) &saddr)->sin6_port != 0) ||\n@@ -102,7 +102,7 @@ static int maybe_new_socket(uv_tcp_t* handle, int domain, unsigned long flags) {\n \n       /* Bind to arbitrary port */\n       if (bind(uv__stream_fd(handle), (struct sockaddr*) &saddr, slen))\n-        return -errno;\n+        return UV__ERR(errno);\n     }\n \n     handle->flags |= flags;\n@@ -119,10 +119,10 @@ int uv_tcp_init_ex(uv_loop_t* loop, uv_tcp_t* tcp, unsigned int flags) {\n   /* Use the lower 8 bits for the domain */\n   domain = flags & 0xFF;\n   if (domain != AF_INET && domain != AF_INET6 && domain != AF_UNSPEC)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (flags & ~0xFF)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   uv__stream_init(loop, (uv_stream_t*)tcp, UV_TCP);\n \n@@ -156,7 +156,7 @@ int uv__tcp_bind(uv_tcp_t* tcp,\n \n   /* Cannot set IPv6-only mode on non-IPv6 socket. */\n   if ((flags & UV_TCP_IPV6ONLY) && addr->sa_family != AF_INET6)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   err = maybe_new_socket(tcp,\n                          addr->sa_family,\n@@ -166,7 +166,7 @@ int uv__tcp_bind(uv_tcp_t* tcp,\n \n   on = 1;\n   if (setsockopt(tcp->io_watcher.fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)))\n-    return -errno;\n+    return UV__ERR(errno);\n \n #ifdef IPV6_V6ONLY\n   if (addr->sa_family == AF_INET6) {\n@@ -178,9 +178,9 @@ int uv__tcp_bind(uv_tcp_t* tcp,\n                    sizeof on) == -1) {\n #if defined(__MVS__)\n       if (errno == EOPNOTSUPP)\n-        return -EINVAL;\n+        return UV_EINVAL;\n #endif\n-      return -errno;\n+      return UV__ERR(errno);\n     }\n   }\n #endif\n@@ -190,10 +190,10 @@ int uv__tcp_bind(uv_tcp_t* tcp,\n     if (errno == EAFNOSUPPORT)\n       /* OSX, other BSDs and SunoS fail with EAFNOSUPPORT when binding a\n        * socket created with AF_INET to an AF_INET6 address or vice versa. */\n-      return -EINVAL;\n-    return -errno;\n+      return UV_EINVAL;\n+    return UV__ERR(errno);\n   }\n-  tcp->delayed_error = -errno;\n+  tcp->delayed_error = UV__ERR(errno);\n \n   tcp->flags |= UV_HANDLE_BOUND;\n   if (addr->sa_family == AF_INET6)\n@@ -214,7 +214,7 @@ int uv__tcp_connect(uv_connect_t* req,\n   assert(handle->type == UV_TCP);\n \n   if (handle->connect_req != NULL)\n-    return -EALREADY;  /* FIXME(bnoordhuis) -EINVAL or maybe -EBUSY. */\n+    return UV_EALREADY;  /* FIXME(bnoordhuis) UV_EINVAL or maybe UV_EBUSY. */\n \n   err = maybe_new_socket(handle,\n                          addr->sa_family,\n@@ -242,9 +242,9 @@ int uv__tcp_connect(uv_connect_t* req,\n      * error. Solaris wants to report immediately--other unixes want to\n      * wait.\n      */\n-      handle->delayed_error = -errno;\n+      handle->delayed_error = UV__ERR(errno);\n     else\n-      return -errno;\n+      return UV__ERR(errno);\n   }\n \n   uv__req_init(handle->loop, req, UV_CONNECT);\n@@ -284,13 +284,13 @@ int uv_tcp_getsockname(const uv_tcp_t* handle,\n     return handle->delayed_error;\n \n   if (uv__stream_fd(handle) < 0)\n-    return -EINVAL;  /* FIXME(bnoordhuis) -EBADF */\n+    return UV_EINVAL;  /* FIXME(bnoordhuis) UV_EBADF */\n \n   /* sizeof(socklen_t) != sizeof(int) on some systems. */\n   socklen = (socklen_t) *namelen;\n \n   if (getsockname(uv__stream_fd(handle), name, &socklen))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *namelen = (int) socklen;\n   return 0;\n@@ -306,13 +306,13 @@ int uv_tcp_getpeername(const uv_tcp_t* handle,\n     return handle->delayed_error;\n \n   if (uv__stream_fd(handle) < 0)\n-    return -EINVAL;  /* FIXME(bnoordhuis) -EBADF */\n+    return UV_EINVAL;  /* FIXME(bnoordhuis) UV_EBADF */\n \n   /* sizeof(socklen_t) != sizeof(int) on some systems. */\n   socklen = (socklen_t) *namelen;\n \n   if (getpeername(uv__stream_fd(handle), name, &socklen))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *namelen = (int) socklen;\n   return 0;\n@@ -348,7 +348,7 @@ int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n     return err;\n \n   if (listen(tcp->io_watcher.fd, backlog))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   tcp->connection_cb = cb;\n   tcp->flags |= UV_HANDLE_BOUND;\n@@ -363,18 +363,18 @@ int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n \n int uv__tcp_nodelay(int fd, int on) {\n   if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)))\n-    return -errno;\n+    return UV__ERR(errno);\n   return 0;\n }\n \n \n int uv__tcp_keepalive(int fd, int on, unsigned int delay) {\n   if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)))\n-    return -errno;\n+    return UV__ERR(errno);\n \n #ifdef TCP_KEEPIDLE\n   if (on && setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &delay, sizeof(delay)))\n-    return -errno;\n+    return UV__ERR(errno);\n #endif\n \n   /* Solaris/SmartOS, if you don't support keep-alive,\n@@ -383,7 +383,7 @@ int uv__tcp_keepalive(int fd, int on, unsigned int delay) {\n   /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */\n #if defined(TCP_KEEPALIVE) && !defined(__sun)\n   if (on && setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &delay, sizeof(delay)))\n-    return -errno;\n+    return UV__ERR(errno);\n #endif\n \n   return 0;"
        },
        {
            "sha": "3def29457aafb698e8568fae63d0effffcdffa29",
            "filename": "deps/uv/src/unix/thread.c",
            "status": "modified",
            "additions": 35,
            "deletions": 26,
            "changes": 61,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fthread.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fthread.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fthread.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -200,7 +200,7 @@ int uv_thread_create(uv_thread_t *tid, void (*entry)(void *arg), void *arg) {\n   if (attr != NULL)\n     pthread_attr_destroy(attr);\n \n-  return -err;\n+  return UV__ERR(err);\n }\n \n \n@@ -209,7 +209,7 @@ uv_thread_t uv_thread_self(void) {\n }\n \n int uv_thread_join(uv_thread_t *tid) {\n-  return -pthread_join(*tid, NULL);\n+  return UV__ERR(pthread_join(*tid, NULL));\n }\n \n \n@@ -220,7 +220,7 @@ int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2) {\n \n int uv_mutex_init(uv_mutex_t* mutex) {\n #if defined(NDEBUG) || !defined(PTHREAD_MUTEX_ERRORCHECK)\n-  return -pthread_mutex_init(mutex, NULL);\n+  return UV__ERR(pthread_mutex_init(mutex, NULL));\n #else\n   pthread_mutexattr_t attr;\n   int err;\n@@ -236,7 +236,7 @@ int uv_mutex_init(uv_mutex_t* mutex) {\n   if (pthread_mutexattr_destroy(&attr))\n     abort();\n \n-  return -err;\n+  return UV__ERR(err);\n #endif\n }\n \n@@ -256,7 +256,7 @@ int uv_mutex_init_recursive(uv_mutex_t* mutex) {\n   if (pthread_mutexattr_destroy(&attr))\n     abort();\n \n-  return -err;\n+  return UV__ERR(err);\n }\n \n \n@@ -279,7 +279,7 @@ int uv_mutex_trylock(uv_mutex_t* mutex) {\n   if (err) {\n     if (err != EBUSY && err != EAGAIN)\n       abort();\n-    return -EBUSY;\n+    return UV_EBUSY;\n   }\n \n   return 0;\n@@ -293,7 +293,7 @@ void uv_mutex_unlock(uv_mutex_t* mutex) {\n \n \n int uv_rwlock_init(uv_rwlock_t* rwlock) {\n-  return -pthread_rwlock_init(rwlock, NULL);\n+  return UV__ERR(pthread_rwlock_init(rwlock, NULL));\n }\n \n \n@@ -316,7 +316,7 @@ int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {\n   if (err) {\n     if (err != EBUSY && err != EAGAIN)\n       abort();\n-    return -EBUSY;\n+    return UV_EBUSY;\n   }\n \n   return 0;\n@@ -342,7 +342,7 @@ int uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {\n   if (err) {\n     if (err != EBUSY && err != EAGAIN)\n       abort();\n-    return -EBUSY;\n+    return UV_EBUSY;\n   }\n \n   return 0;\n@@ -369,12 +369,12 @@ int uv_sem_init(uv_sem_t* sem, unsigned int value) {\n   if (err == KERN_SUCCESS)\n     return 0;\n   if (err == KERN_INVALID_ARGUMENT)\n-    return -EINVAL;\n+    return UV_EINVAL;\n   if (err == KERN_RESOURCE_SHORTAGE)\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n \n   abort();\n-  return -EINVAL;  /* Satisfy the compiler. */\n+  return UV_EINVAL;  /* Satisfy the compiler. */\n }\n \n \n@@ -413,10 +413,10 @@ int uv_sem_trywait(uv_sem_t* sem) {\n   if (err == KERN_SUCCESS)\n     return 0;\n   if (err == KERN_OPERATION_TIMED_OUT)\n-    return -EAGAIN;\n+    return UV_EAGAIN;\n \n   abort();\n-  return -EINVAL;  /* Satisfy the compiler. */\n+  return UV_EINVAL;  /* Satisfy the compiler. */\n }\n \n #elif defined(__MVS__)\n@@ -433,14 +433,14 @@ int uv_sem_init(uv_sem_t* sem, unsigned int value) {\n \n   semid = semget(IPC_PRIVATE, 1, S_IRUSR | S_IWUSR);\n   if (semid == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   arg.val = value;\n   if (-1 == semctl(semid, 0, SETVAL, arg)) {\n     err = errno;\n     if (-1 == semctl(*sem, 0, IPC_RMID))\n       abort();\n-    return -err;\n+    return UV__ERR(err);\n   }\n \n   *sem = semid;\n@@ -493,7 +493,7 @@ int uv_sem_trywait(uv_sem_t* sem) {\n \n   if (op_status) {\n     if (errno == EAGAIN)\n-      return -EAGAIN;\n+      return UV_EAGAIN;\n     abort();\n   }\n \n@@ -504,7 +504,7 @@ int uv_sem_trywait(uv_sem_t* sem) {\n \n int uv_sem_init(uv_sem_t* sem, unsigned int value) {\n   if (sem_init(sem, 0, value))\n-    return -errno;\n+    return UV__ERR(errno);\n   return 0;\n }\n \n@@ -542,7 +542,7 @@ int uv_sem_trywait(uv_sem_t* sem) {\n \n   if (r) {\n     if (errno == EAGAIN)\n-      return -EAGAIN;\n+      return UV_EAGAIN;\n     abort();\n   }\n \n@@ -555,7 +555,7 @@ int uv_sem_trywait(uv_sem_t* sem) {\n #if defined(__APPLE__) && defined(__MACH__) || defined(__MVS__)\n \n int uv_cond_init(uv_cond_t* cond) {\n-  return -pthread_cond_init(cond, NULL);\n+  return UV__ERR(pthread_cond_init(cond, NULL));\n }\n \n #else /* !(defined(__APPLE__) && defined(__MACH__)) */\n@@ -566,7 +566,7 @@ int uv_cond_init(uv_cond_t* cond) {\n \n   err = pthread_condattr_init(&attr);\n   if (err)\n-    return -err;\n+    return UV__ERR(err);\n \n #if !(defined(__ANDROID_API__) && __ANDROID_API__ < 21)\n   err = pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);\n@@ -588,7 +588,7 @@ int uv_cond_init(uv_cond_t* cond) {\n   pthread_cond_destroy(cond);\n error2:\n   pthread_condattr_destroy(&attr);\n-  return -err;\n+  return UV__ERR(err);\n }\n \n #endif /* defined(__APPLE__) && defined(__MACH__) */\n@@ -646,13 +646,22 @@ void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex) {\n int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex, uint64_t timeout) {\n   int r;\n   struct timespec ts;\n+#if defined(__MVS__)\n+  struct timeval tv;\n+#endif\n \n #if defined(__APPLE__) && defined(__MACH__)\n   ts.tv_sec = timeout / NANOSEC;\n   ts.tv_nsec = timeout % NANOSEC;\n   r = pthread_cond_timedwait_relative_np(cond, mutex, &ts);\n+#else\n+#if defined(__MVS__)\n+  if (gettimeofday(&tv, NULL))\n+    abort();\n+  timeout += tv.tv_sec * NANOSEC + tv.tv_usec * 1e3;\n #else\n   timeout += uv__hrtime(UV_CLOCK_PRECISE);\n+#endif\n   ts.tv_sec = timeout / NANOSEC;\n   ts.tv_nsec = timeout % NANOSEC;\n #if defined(__ANDROID_API__) && __ANDROID_API__ < 21\n@@ -672,15 +681,15 @@ int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex, uint64_t timeout) {\n     return 0;\n \n   if (r == ETIMEDOUT)\n-    return -ETIMEDOUT;\n+    return UV_ETIMEDOUT;\n \n   abort();\n-  return -EINVAL;  /* Satisfy the compiler. */\n+  return UV_EINVAL;  /* Satisfy the compiler. */\n }\n \n \n int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {\n-  return -pthread_barrier_init(barrier, NULL, count);\n+  return UV__ERR(pthread_barrier_init(barrier, NULL, count));\n }\n \n \n@@ -699,7 +708,7 @@ int uv_barrier_wait(uv_barrier_t* barrier) {\n \n \n int uv_key_create(uv_key_t* key) {\n-  return -pthread_key_create(key, NULL);\n+  return UV__ERR(pthread_key_create(key, NULL));\n }\n \n "
        },
        {
            "sha": "54dabfe7df9e27bf08e3c05c55c0c61b0a9a3c05",
            "filename": "deps/uv/src/unix/timer.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ftimer.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ftimer.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ftimer.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -66,7 +66,7 @@ int uv_timer_start(uv_timer_t* handle,\n   uint64_t clamped_timeout;\n \n   if (cb == NULL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (uv__is_active(handle))\n     uv_timer_stop(handle);\n@@ -105,7 +105,7 @@ int uv_timer_stop(uv_timer_t* handle) {\n \n int uv_timer_again(uv_timer_t* handle) {\n   if (handle->timer_cb == NULL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (handle->repeat) {\n     uv_timer_stop(handle);"
        },
        {
            "sha": "f22b3b80de061f34f4cba41e1d42fbefcf12e431",
            "filename": "deps/uv/src/unix/tty.c",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ftty.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Ftty.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ftty.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -106,7 +106,7 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n    */\n   type = uv_guess_handle(fd);\n   if (type == UV_FILE || type == UV_UNKNOWN_HANDLE)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   flags = 0;\n   newfd = -1;\n@@ -142,7 +142,7 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n     newfd = r;\n \n     r = uv__dup2_cloexec(newfd, fd);\n-    if (r < 0 && r != -EINVAL) {\n+    if (r < 0 && r != UV_EINVAL) {\n       /* EINVAL means newfd == fd which could conceivably happen if another\n        * thread called close(fd) between our calls to isatty() and open().\n        * That's a rather unlikely event but let's handle it anyway.\n@@ -163,7 +163,7 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n   if (saved_flags == -1) {\n     if (newfd != -1)\n       uv__close(newfd);\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n #endif\n \n@@ -234,7 +234,7 @@ int uv_tty_set_mode(uv_tty_t* tty, uv_tty_mode_t mode) {\n   fd = uv__stream_fd(tty);\n   if (tty->mode == UV_TTY_MODE_NORMAL && mode != UV_TTY_MODE_NORMAL) {\n     if (tcgetattr(fd, &tty->orig_termios))\n-      return -errno;\n+      return UV__ERR(errno);\n \n     /* This is used for uv_tty_reset_mode() */\n     uv_spinlock_lock(&termios_spinlock);\n@@ -264,7 +264,7 @@ int uv_tty_set_mode(uv_tty_t* tty, uv_tty_mode_t mode) {\n \n   /* Apply changes after draining */\n   if (tcsetattr(fd, TCSADRAIN, &tmp))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   tty->mode = mode;\n   return 0;\n@@ -280,7 +280,7 @@ int uv_tty_get_winsize(uv_tty_t* tty, int* width, int* height) {\n   while (err == -1 && errno == EINTR);\n \n   if (err == -1)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *width = ws.ws_col;\n   *height = ws.ws_row;\n@@ -358,12 +358,12 @@ int uv_tty_reset_mode(void) {\n \n   saved_errno = errno;\n   if (!uv_spinlock_trylock(&termios_spinlock))\n-    return -EBUSY;  /* In uv_tty_set_mode(). */\n+    return UV_EBUSY;  /* In uv_tty_set_mode(). */\n \n   err = 0;\n   if (orig_termios_fd != -1)\n     if (tcsetattr(orig_termios_fd, TCSANOW, &orig_termios))\n-      err = -errno;\n+      err = UV__ERR(errno);\n \n   uv_spinlock_unlock(&termios_spinlock);\n   errno = saved_errno;"
        },
        {
            "sha": "74d613b6843b7de9671fe1f6900e5505291b7566",
            "filename": "deps/uv/src/unix/udp.c",
            "status": "modified",
            "additions": 38,
            "deletions": 38,
            "changes": 76,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fudp.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Funix%2Fudp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fudp.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -72,7 +72,7 @@ void uv__udp_finish_close(uv_udp_t* handle) {\n     QUEUE_REMOVE(q);\n \n     req = QUEUE_DATA(q, uv_udp_send_t, queue);\n-    req->status = -ECANCELED;\n+    req->status = UV_ECANCELED;\n     QUEUE_INSERT_TAIL(&handle->write_completed_queue, &req->queue);\n   }\n \n@@ -189,7 +189,7 @@ static void uv__udp_recvmsg(uv_udp_t* handle) {\n       if (errno == EAGAIN || errno == EWOULDBLOCK)\n         handle->recv_cb(handle, 0, &buf, NULL, 0);\n       else\n-        handle->recv_cb(handle, -errno, &buf, NULL, 0);\n+        handle->recv_cb(handle, UV__ERR(errno), &buf, NULL, 0);\n     }\n     else {\n       const struct sockaddr *addr;\n@@ -242,7 +242,7 @@ static void uv__udp_sendmsg(uv_udp_t* handle) {\n         break;\n     }\n \n-    req->status = (size == -1 ? -errno : size);\n+    req->status = (size == -1 ? UV__ERR(errno) : size);\n \n     /* Sending a datagram is an atomic operation: either all data\n      * is written or nothing is (and EMSGSIZE is raised). That is\n@@ -270,11 +270,11 @@ static int uv__set_reuse(int fd) {\n #if defined(SO_REUSEPORT) && !defined(__linux__)\n   yes = 1;\n   if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes)))\n-    return -errno;\n+    return UV__ERR(errno);\n #else\n   yes = 1;\n   if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)))\n-    return -errno;\n+    return UV__ERR(errno);\n #endif\n \n   return 0;\n@@ -291,11 +291,11 @@ int uv__udp_bind(uv_udp_t* handle,\n \n   /* Check for bad flags. */\n   if (flags & ~(UV_UDP_IPV6ONLY | UV_UDP_REUSEADDR))\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   /* Cannot set IPv6-only mode on non-IPv6 socket. */\n   if ((flags & UV_UDP_IPV6ONLY) && addr->sa_family != AF_INET6)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   fd = handle->io_watcher.fd;\n   if (fd == -1) {\n@@ -316,21 +316,21 @@ int uv__udp_bind(uv_udp_t* handle,\n #ifdef IPV6_V6ONLY\n     yes = 1;\n     if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &yes, sizeof yes) == -1) {\n-      err = -errno;\n+      err = UV__ERR(errno);\n       return err;\n     }\n #else\n-    err = -ENOTSUP;\n+    err = UV_ENOTSUP;\n     return err;\n #endif\n   }\n \n   if (bind(fd, addr, addrlen)) {\n-    err = -errno;\n+    err = UV__ERR(errno);\n     if (errno == EAFNOSUPPORT)\n       /* OSX, other BSDs and SunoS fail with EAFNOSUPPORT when binding a\n        * socket created with AF_INET to an AF_INET6 address or vice versa. */\n-      err = -EINVAL;\n+      err = UV_EINVAL;\n     return err;\n   }\n \n@@ -418,7 +418,7 @@ int uv__udp_send(uv_udp_send_t* req,\n \n   if (req->bufs == NULL) {\n     uv__req_unregister(handle->loop, req);\n-    return -ENOMEM;\n+    return UV_ENOMEM;\n   }\n \n   memcpy(req->bufs, bufs, nbufs * sizeof(bufs[0]));\n@@ -457,7 +457,7 @@ int uv__udp_try_send(uv_udp_t* handle,\n \n   /* already sending a message */\n   if (handle->send_queue_count != 0)\n-    return -EAGAIN;\n+    return UV_EAGAIN;\n \n   err = uv__udp_maybe_deferred_bind(handle, addr->sa_family, 0);\n   if (err)\n@@ -475,9 +475,9 @@ int uv__udp_try_send(uv_udp_t* handle,\n \n   if (size == -1) {\n     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)\n-      return -EAGAIN;\n+      return UV_EAGAIN;\n     else\n-      return -errno;\n+      return UV__ERR(errno);\n   }\n \n   return size;\n@@ -512,7 +512,7 @@ static int uv__udp_set_membership4(uv_udp_t* handle,\n     optname = IP_DROP_MEMBERSHIP;\n     break;\n   default:\n-    return -EINVAL;\n+    return UV_EINVAL;\n   }\n \n   if (setsockopt(handle->io_watcher.fd,\n@@ -522,9 +522,9 @@ static int uv__udp_set_membership4(uv_udp_t* handle,\n                  sizeof(mreq))) {\n #if defined(__MVS__)\n   if (errno == ENXIO)\n-    return -ENODEV;\n+    return UV_ENODEV;\n #endif\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   return 0;\n@@ -543,7 +543,7 @@ static int uv__udp_set_membership6(uv_udp_t* handle,\n \n   if (interface_addr) {\n     if (uv_ip6_addr(interface_addr, 0, &addr6))\n-      return -EINVAL;\n+      return UV_EINVAL;\n     mreq.ipv6mr_interface = addr6.sin6_scope_id;\n   } else {\n     mreq.ipv6mr_interface = 0;\n@@ -559,7 +559,7 @@ static int uv__udp_set_membership6(uv_udp_t* handle,\n     optname = IPV6_DROP_MEMBERSHIP;\n     break;\n   default:\n-    return -EINVAL;\n+    return UV_EINVAL;\n   }\n \n   if (setsockopt(handle->io_watcher.fd,\n@@ -569,9 +569,9 @@ static int uv__udp_set_membership6(uv_udp_t* handle,\n                  sizeof(mreq))) {\n #if defined(__MVS__)\n   if (errno == ENXIO)\n-    return -ENODEV;\n+    return UV_ENODEV;\n #endif\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   return 0;\n@@ -586,10 +586,10 @@ int uv_udp_init_ex(uv_loop_t* loop, uv_udp_t* handle, unsigned int flags) {\n   /* Use the lower 8 bits for the domain */\n   domain = flags & 0xFF;\n   if (domain != AF_INET && domain != AF_INET6 && domain != AF_UNSPEC)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (flags & ~0xFF)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (domain != AF_UNSPEC) {\n     err = uv__socket(domain, SOCK_DGRAM, 0);\n@@ -622,7 +622,7 @@ int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {\n \n   /* Check for already active socket. */\n   if (handle->io_watcher.fd != -1)\n-    return -EBUSY;\n+    return UV_EBUSY;\n \n   err = uv__nonblock(sock, 1);\n   if (err)\n@@ -656,7 +656,7 @@ int uv_udp_set_membership(uv_udp_t* handle,\n       return err;\n     return uv__udp_set_membership6(handle, &addr6, interface_addr, membership);\n   } else {\n-    return -EINVAL;\n+    return UV_EINVAL;\n   }\n }\n \n@@ -680,7 +680,7 @@ static int uv__setsockopt(uv_udp_t* handle,\n                    val,\n                    size);\n   if (r)\n-    return -errno;\n+    return UV__ERR(errno);\n \n   return 0;\n }\n@@ -698,7 +698,7 @@ static int uv__setsockopt_maybe_char(uv_udp_t* handle,\n #endif\n \n   if (val < 0 || val > 255)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   return uv__setsockopt(handle, option4, option6, &arg, sizeof(arg));\n }\n@@ -710,7 +710,7 @@ int uv_udp_set_broadcast(uv_udp_t* handle, int on) {\n                  SO_BROADCAST,\n                  &on,\n                  sizeof(on))) {\n-    return -errno;\n+    return UV__ERR(errno);\n   }\n \n   return 0;\n@@ -719,11 +719,11 @@ int uv_udp_set_broadcast(uv_udp_t* handle, int on) {\n \n int uv_udp_set_ttl(uv_udp_t* handle, int ttl) {\n   if (ttl < 1 || ttl > 255)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n #if defined(__MVS__)\n   if (!(handle->flags & UV_HANDLE_IPV6))\n-    return -ENOTSUP;  /* zOS does not support setting ttl for IPv4 */\n+    return UV_ENOTSUP;  /* zOS does not support setting ttl for IPv4 */\n #endif\n \n /*\n@@ -817,7 +817,7 @@ int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr)\n   } else if (uv_ip6_addr(interface_addr, 0, addr6) == 0) {\n     /* nothing, address was parsed */\n   } else {\n-    return -EINVAL;\n+    return UV_EINVAL;\n   }\n \n   if (addr_st.ss_family == AF_INET) {\n@@ -826,15 +826,15 @@ int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr)\n                    IP_MULTICAST_IF,\n                    (void*) &addr4->sin_addr,\n                    sizeof(addr4->sin_addr)) == -1) {\n-      return -errno;\n+      return UV__ERR(errno);\n     }\n   } else if (addr_st.ss_family == AF_INET6) {\n     if (setsockopt(handle->io_watcher.fd,\n                    IPPROTO_IPV6,\n                    IPV6_MULTICAST_IF,\n                    &addr6->sin6_scope_id,\n                    sizeof(addr6->sin6_scope_id)) == -1) {\n-      return -errno;\n+      return UV__ERR(errno);\n     }\n   } else {\n     assert(0 && \"unexpected address family\");\n@@ -851,13 +851,13 @@ int uv_udp_getsockname(const uv_udp_t* handle,\n   socklen_t socklen;\n \n   if (handle->io_watcher.fd == -1)\n-    return -EINVAL;  /* FIXME(bnoordhuis) -EBADF */\n+    return UV_EINVAL;  /* FIXME(bnoordhuis) UV_EBADF */\n \n   /* sizeof(socklen_t) != sizeof(int) on some systems. */\n   socklen = (socklen_t) *namelen;\n \n   if (getsockname(handle->io_watcher.fd, name, &socklen))\n-    return -errno;\n+    return UV__ERR(errno);\n \n   *namelen = (int) socklen;\n   return 0;\n@@ -870,10 +870,10 @@ int uv__udp_recv_start(uv_udp_t* handle,\n   int err;\n \n   if (alloc_cb == NULL || recv_cb == NULL)\n-    return -EINVAL;\n+    return UV_EINVAL;\n \n   if (uv__io_active(&handle->io_watcher, POLLIN))\n-    return -EALREADY;  /* FIXME(bnoordhuis) Should be -EBUSY. */\n+    return UV_EALREADY;  /* FIXME(bnoordhuis) Should be UV_EBUSY. */\n \n   err = uv__udp_maybe_deferred_bind(handle, AF_INET, 0);\n   if (err)"
        },
        {
            "sha": "d4fa22aaef6add33faa184171649405e9bb9eab4",
            "filename": "deps/uv/src/uv-common.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Fuv-common.h",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Fuv-common.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fuv-common.h?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -41,6 +41,12 @@\n #include \"tree.h\"\n #include \"queue.h\"\n \n+#if EDOM > 0\n+# define UV__ERR(x) (-(x))\n+#else\n+# define UV__ERR(x) (x)\n+#endif\n+\n #if !defined(snprintf) && defined(_MSC_VER) && _MSC_VER < 1900\n extern int snprintf(char*, size_t, const char*, ...);\n #endif"
        },
        {
            "sha": "6e0bdc7bb20e66ac3338bcea8ff133766127c847",
            "filename": "deps/uv/src/win/fs.c",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -245,6 +245,7 @@ INLINE static void uv_fs_req_init(uv_loop_t* loop, uv_fs_t* req,\n   req->ptr = NULL;\n   req->path = NULL;\n   req->cb = cb;\n+  req->fs.info.bufs = NULL;\n   memset(&req->fs, 0, sizeof(req->fs));\n }\n "
        },
        {
            "sha": "7523522217392e9664a06b90faaecb33cc64d3f2",
            "filename": "deps/uv/src/win/process.c",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Fwin%2Fprocess.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Fwin%2Fprocess.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fprocess.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -1061,11 +1061,16 @@ int uv_spawn(uv_loop_t* loop,\n   process_flags = CREATE_UNICODE_ENVIRONMENT;\n \n   if (options->flags & UV_PROCESS_WINDOWS_HIDE) {\n+    /* Avoid creating console window if stdio is not inherited. */\n+    for (i = 0; i < options->stdio_count; i++) {\n+      if (options->stdio[i].flags & UV_INHERIT_FD)\n+        break;\n+      if (i == options->stdio_count - 1)\n+        process_flags |= CREATE_NO_WINDOW;\n+    }\n+\n     /* Use SW_HIDE to avoid any potential process window. */\n     startup.wShowWindow = SW_HIDE;\n-\n-    /* Hide console windows. */\n-    process_flags |= CREATE_NO_WINDOW;\n   } else {\n     startup.wShowWindow = SW_SHOWDEFAULT;\n   }"
        },
        {
            "sha": "84188954d815f161617d5c3cb0ef5610a0ab639e",
            "filename": "deps/uv/src/win/winsock.c",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Fwin%2Fwinsock.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fsrc%2Fwin%2Fwinsock.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fwinsock.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -580,8 +580,10 @@ int uv__convert_to_localhost_if_unspecified(const struct sockaddr* addr,\n     memcpy(dest6, addr, sizeof(*dest6));\n     if (memcmp(&dest6->sin6_addr,\n                &uv_addr_ip6_any_.sin6_addr,\n-               sizeof(uv_addr_ip6_any_.sin6_addr)) == 0)\n-      dest6->sin6_addr = (struct in6_addr) IN6ADDR_LOOPBACK_INIT;\n+               sizeof(uv_addr_ip6_any_.sin6_addr)) == 0) {\n+      struct in6_addr init_sin6_addr = IN6ADDR_LOOPBACK_INIT;\n+      dest6->sin6_addr = init_sin6_addr;\n+    }\n     return 0;\n   default:\n     return UV_EINVAL;"
        },
        {
            "sha": "d956efef3c5a0031384576500a57c81841a7c5d3",
            "filename": "deps/uv/test/test-condvar.c",
            "status": "modified",
            "additions": 46,
            "deletions": 8,
            "changes": 54,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-condvar.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-condvar.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-condvar.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -34,7 +34,7 @@ typedef struct worker_config {\n   volatile int posted_1;\n   volatile int posted_2;\n   void (*signal_cond)(struct worker_config* c, volatile int* flag);\n-  void (*wait_cond)(struct worker_config* c, const volatile int* flag);\n+  int (*wait_cond)(struct worker_config* c, const volatile int* flag);\n } worker_config;\n \n \n@@ -44,6 +44,9 @@ static void worker(void* arg) {\n   c->wait_cond(c, &c->posted_2);\n }\n \n+static void noop_worker(void* arg) {\n+  return;\n+}\n \n static void condvar_signal(worker_config* c, volatile int* flag) {\n   if (c->signal_delay)\n@@ -60,7 +63,7 @@ static void condvar_signal(worker_config* c, volatile int* flag) {\n }\n \n \n-static void condvar_wait(worker_config* c, const volatile int* flag) {\n+static int condvar_wait(worker_config* c, const volatile int* flag) {\n   uv_mutex_lock(&c->mutex);\n   if (c->wait_delay)\n     uv_sleep(c->wait_delay);\n@@ -69,6 +72,8 @@ static void condvar_wait(worker_config* c, const volatile int* flag) {\n   }\n   ASSERT(*flag == 1);\n   uv_mutex_unlock(&c->mutex);\n+\n+  return 0;\n }\n \n \n@@ -85,7 +90,7 @@ TEST_IMPL(condvar_1) {\n   ASSERT(0 == uv_mutex_init(&wc.mutex));\n   ASSERT(0 == uv_thread_create(&thread, worker, &wc));\n \n-  wc.wait_cond(&wc, &wc.posted_1);\n+  ASSERT(0 == wc.wait_cond(&wc, &wc.posted_1));\n   wc.signal_cond(&wc, &wc.posted_2);\n \n   ASSERT(0 == uv_thread_join(&thread));\n@@ -109,7 +114,7 @@ TEST_IMPL(condvar_2) {\n   ASSERT(0 == uv_mutex_init(&wc.mutex));\n   ASSERT(0 == uv_thread_create(&thread, worker, &wc));\n \n-  wc.wait_cond(&wc, &wc.posted_1);\n+  ASSERT(0 == wc.wait_cond(&wc, &wc.posted_1));\n   wc.signal_cond(&wc, &wc.posted_2);\n \n   ASSERT(0 == uv_thread_join(&thread));\n@@ -120,20 +125,26 @@ TEST_IMPL(condvar_2) {\n }\n \n \n-static void condvar_timedwait(worker_config* c, const volatile int* flag) {\n+static int condvar_timedwait(worker_config* c, const volatile int* flag) {\n   int r;\n \n+  r = 0;\n+\n   uv_mutex_lock(&c->mutex);\n   if (c->wait_delay)\n     uv_sleep(c->wait_delay);\n   while (*flag == 0) {\n     r = uv_cond_timedwait(&c->cond, &c->mutex, (uint64_t)(150 * 1e6));\n-    ASSERT(r == 0);\n+    ASSERT(r == 0 || r == UV_ETIMEDOUT);\n+    if (r == UV_ETIMEDOUT)\n+      break;\n   }\n   uv_mutex_unlock(&c->mutex);\n-}\n \n+  return r;\n+}\n \n+/* Test that uv_cond_timedwait will return early when cond is signaled. */\n TEST_IMPL(condvar_3) {\n   uv_thread_t thread;\n   worker_config wc;\n@@ -147,7 +158,7 @@ TEST_IMPL(condvar_3) {\n   ASSERT(0 == uv_mutex_init(&wc.mutex));\n   ASSERT(0 == uv_thread_create(&thread, worker, &wc));\n \n-  wc.wait_cond(&wc, &wc.posted_1);\n+  ASSERT(0 == wc.wait_cond(&wc, &wc.posted_1));\n   wc.signal_cond(&wc, &wc.posted_2);\n \n   ASSERT(0 == uv_thread_join(&thread));\n@@ -205,3 +216,30 @@ TEST_IMPL(condvar_5) {\n \n   return 0;\n }\n+\n+/* Test that uv_cond_timedwait will time out when cond is not signaled. */\n+TEST_IMPL(condvar_6) {\n+  uv_thread_t thread;\n+  worker_config wc;\n+  int r;\n+\n+  memset(&wc, 0, sizeof(wc));\n+  wc.signal_delay = 100;\n+  wc.signal_cond = condvar_signal;\n+  wc.wait_cond = condvar_timedwait;\n+\n+  ASSERT(0 == uv_cond_init(&wc.cond));\n+  ASSERT(0 == uv_mutex_init(&wc.mutex));\n+  ASSERT(0 == uv_thread_create(&thread, noop_worker, &wc));\n+\n+  /* This can only return having timed out, because otherwise we\n+   * loop forever in condvar_timedwait. */\n+  r = wc.wait_cond(&wc, &wc.posted_1);\n+  ASSERT(r == UV_ETIMEDOUT);\n+\n+  ASSERT(0 == uv_thread_join(&thread));\n+  uv_mutex_destroy(&wc.mutex);\n+  uv_cond_destroy(&wc.cond);\n+\n+  return 0;\n+}"
        },
        {
            "sha": "39b59c8f20ebb49ba68294368620df48f4f4c646",
            "filename": "deps/uv/test/test-fork.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-fork.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-fork.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fork.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -335,7 +335,7 @@ TEST_IMPL(fork_signal_to_child_closed) {\n     /* Note that we're deliberately not running the loop\n      * in the child, and also not closing the loop's handles,\n      * so the child default loop can't be cleanly closed.\n-     * We need te explicitly exit to avoid an automatic failure\n+     * We need to explicitly exit to avoid an automatic failure\n      * in that case.\n      */\n     exit(0);"
        },
        {
            "sha": "4b1fdc5e7982800b86277c1ca2f641f3d591b929",
            "filename": "deps/uv/test/test-fs-copyfile.c",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-fs-copyfile.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-fs-copyfile.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fs-copyfile.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -36,6 +36,10 @@ static const char dst[] = \"test_file_dst\";\n static int result_check_count;\n \n \n+static void fail_cb(uv_fs_t* req) {\n+  FATAL(\"fail_cb should not have been called\");\n+}\n+\n static void handle_result(uv_fs_t* req) {\n   uv_fs_t stat_req;\n   uint64_t size;\n@@ -158,7 +162,12 @@ TEST_IMPL(fs_copyfile) {\n   ASSERT(result_check_count == 5);\n   uv_run(loop, UV_RUN_DEFAULT);\n   ASSERT(result_check_count == 6);\n-  unlink(dst); /* Cleanup */\n \n+  /* If the flags are invalid, the loop should not be kept open */\n+  unlink(dst);\n+  r = uv_fs_copyfile(loop, &req, fixture, dst, -1, fail_cb);\n+  ASSERT(r == UV_EINVAL);\n+  uv_run(loop, UV_RUN_DEFAULT);\n+  unlink(dst); /* Cleanup */\n   return 0;\n }"
        },
        {
            "sha": "39d73300dc2b61d34b44f5a3bf758a50a5f0ed2a",
            "filename": "deps/uv/test/test-fs-event.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-fs-event.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-fs-event.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fs-event.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -199,7 +199,7 @@ static void fs_event_cb_dir_multi_file(uv_fs_event_t* handle,\n   fs_event_cb_called++;\n   ASSERT(handle == &fs_event);\n   ASSERT(status == 0);\n-  ASSERT(events == UV_CHANGE || UV_RENAME);\n+  ASSERT(events == UV_CHANGE || events == UV_RENAME);\n   #if defined(__APPLE__) || defined(_WIN32) || defined(__linux__)\n   ASSERT(strncmp(filename, file_prefix, sizeof(file_prefix) - 1) == 0);\n   #else\n@@ -283,7 +283,7 @@ static void fs_event_cb_dir_multi_file_in_subdir(uv_fs_event_t* handle,\n   fs_event_cb_called++;\n   ASSERT(handle == &fs_event);\n   ASSERT(status == 0);\n-  ASSERT(events == UV_CHANGE || UV_RENAME);\n+  ASSERT(events == UV_CHANGE || events == UV_RENAME);\n   #if defined(__APPLE__) || defined(_WIN32) || defined(__linux__)\n   ASSERT(strncmp(filename,\n                  file_prefix_in_subdir,"
        },
        {
            "sha": "3318b86649de50dbe153344cec469f72bf8ef31c",
            "filename": "deps/uv/test/test-fs.c",
            "status": "modified",
            "additions": 41,
            "deletions": 1,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-fs.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-fs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fs.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -319,6 +319,9 @@ static void ftruncate_cb(uv_fs_t* req) {\n   ASSERT(r == 0);\n }\n \n+static void fail_cb(uv_fs_t* req) {\n+  FATAL(\"fail_cb should not have been called\");\n+}\n \n static void read_cb(uv_fs_t* req) {\n   int r;\n@@ -2884,7 +2887,19 @@ TEST_IMPL(fs_read_write_null_arguments) {\n   uv_fs_req_cleanup(&read_req);\n \n   r = uv_fs_write(NULL, &write_req, 0, NULL, 0, -1, NULL);\n+  /* Validate some memory management on failed input validation before sending\n+     fs work to the thread pool. */\n   ASSERT(r == UV_EINVAL);\n+  ASSERT(write_req.path == NULL);\n+  ASSERT(write_req.ptr == NULL);\n+#ifdef _WIN32\n+  ASSERT(write_req.file.pathw == NULL);\n+  ASSERT(write_req.fs.info.new_pathw == NULL);\n+  ASSERT(write_req.fs.info.bufs == NULL);\n+#else\n+  ASSERT(write_req.new_path == NULL);\n+  ASSERT(write_req.bufs == NULL);\n+#endif\n   uv_fs_req_cleanup(&write_req);\n \n   iov = uv_buf_init(NULL, 0);\n@@ -2897,6 +2912,31 @@ TEST_IMPL(fs_read_write_null_arguments) {\n   ASSERT(r == UV_EINVAL);\n   uv_fs_req_cleanup(&write_req);\n \n+  /* If the arguments are invalid, the loop should not be kept open */\n+  loop = uv_default_loop();\n+\n+  r = uv_fs_read(loop, &read_req, 0, NULL, 0, -1, fail_cb);\n+  ASSERT(r == UV_EINVAL);\n+  uv_run(loop, UV_RUN_DEFAULT);\n+  uv_fs_req_cleanup(&read_req);\n+\n+  r = uv_fs_write(loop, &write_req, 0, NULL, 0, -1, fail_cb);\n+  ASSERT(r == UV_EINVAL);\n+  uv_run(loop, UV_RUN_DEFAULT);\n+  uv_fs_req_cleanup(&write_req);\n+\n+  iov = uv_buf_init(NULL, 0);\n+  r = uv_fs_read(loop, &read_req, 0, &iov, 0, -1, fail_cb);\n+  ASSERT(r == UV_EINVAL);\n+  uv_run(loop, UV_RUN_DEFAULT);\n+  uv_fs_req_cleanup(&read_req);\n+\n+  iov = uv_buf_init(NULL, 0);\n+  r = uv_fs_write(loop, &write_req, 0, &iov, 0, -1, fail_cb);\n+  ASSERT(r == UV_EINVAL);\n+  uv_run(loop, UV_RUN_DEFAULT);\n+  uv_fs_req_cleanup(&write_req);\n+\n   return 0;\n }\n \n@@ -3084,7 +3124,7 @@ TEST_IMPL(fs_exclusive_sharing_mode) {\n   unlink(\"test_file\");\n \n   ASSERT(UV_FS_O_EXLOCK > 0);\n-  \n+\n   r = uv_fs_open(NULL,\n                  &open_req1,\n                  \"test_file\","
        },
        {
            "sha": "917744cbaed9788a3e21d354fd461e03f56d5f57",
            "filename": "deps/uv/test/test-ipc-send-recv.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-ipc-send-recv.c",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-ipc-send-recv.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-ipc-send-recv.c?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -304,7 +304,7 @@ static void read_cb(uv_stream_t* handle,\n   union handles* recv;\n   uv_write_t* write_req;\n \n-  if (nread == UV__EOF || nread == UV__ECONNABORTED) {\n+  if (nread == UV_EOF || nread == UV_ECONNABORTED) {\n     return;\n   }\n "
        },
        {
            "sha": "ff0a31d16bb940e8cdad672dfeb18c0eef0656fd",
            "filename": "deps/uv/test/test-list.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-list.h",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest-list.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-list.h?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -42,6 +42,7 @@ TEST_DECLARE   (condvar_2)\n TEST_DECLARE   (condvar_3)\n TEST_DECLARE   (condvar_4)\n TEST_DECLARE   (condvar_5)\n+TEST_DECLARE   (condvar_6)\n TEST_DECLARE   (semaphore_1)\n TEST_DECLARE   (semaphore_2)\n TEST_DECLARE   (semaphore_3)\n@@ -445,6 +446,7 @@ TASK_LIST_START\n   TEST_ENTRY  (condvar_3)\n   TEST_ENTRY  (condvar_4)\n   TEST_ENTRY  (condvar_5)\n+  TEST_ENTRY  (condvar_6)\n   TEST_ENTRY  (semaphore_1)\n   TEST_ENTRY  (semaphore_2)\n   TEST_ENTRY  (semaphore_3)"
        },
        {
            "sha": "480e5a26c4176dc3724c6e9bda206a94bfbaea46",
            "filename": "deps/uv/test/test.gyp",
            "status": "added",
            "additions": 279,
            "deletions": 0,
            "changes": 279,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Ftest%2Ftest.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest.gyp?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -0,0 +1,279 @@\n+{\n+  'targets': [\n+    {\n+      'target_name': 'run-tests',\n+      'type': 'executable',\n+      'dependencies': [ '../uv.gyp:libuv' ],\n+      'sources': [\n+        'blackhole-server.c',\n+        'echo-server.c',\n+        'run-tests.c',\n+        'runner.c',\n+        'runner.h',\n+        'test-get-loadavg.c',\n+        'task.h',\n+        'test-active.c',\n+        'test-async.c',\n+        'test-async-null-cb.c',\n+        'test-callback-stack.c',\n+        'test-callback-order.c',\n+        'test-close-fd.c',\n+        'test-close-order.c',\n+        'test-connect-unspecified.c',\n+        'test-connection-fail.c',\n+        'test-cwd-and-chdir.c',\n+        'test-default-loop-close.c',\n+        'test-delayed-accept.c',\n+        'test-eintr-handling.c',\n+        'test-error.c',\n+        'test-embed.c',\n+        'test-emfile.c',\n+        'test-env-vars.c',\n+        'test-fail-always.c',\n+        'test-fork.c',\n+        'test-fs.c',\n+        'test-fs-copyfile.c',\n+        'test-fs-event.c',\n+        'test-getters-setters.c',\n+        'test-get-currentexe.c',\n+        'test-get-memory.c',\n+        'test-get-passwd.c',\n+        'test-getaddrinfo.c',\n+        'test-gethostname.c',\n+        'test-getnameinfo.c',\n+        'test-getsockname.c',\n+        'test-handle-fileno.c',\n+        'test-homedir.c',\n+        'test-hrtime.c',\n+        'test-idle.c',\n+        'test-ip6-addr.c',\n+        'test-ipc.c',\n+        'test-ipc-send-recv.c',\n+        'test-list.h',\n+        'test-loop-handles.c',\n+        'test-loop-alive.c',\n+        'test-loop-close.c',\n+        'test-loop-stop.c',\n+        'test-loop-time.c',\n+        'test-loop-configure.c',\n+        'test-walk-handles.c',\n+        'test-watcher-cross-stop.c',\n+        'test-multiple-listen.c',\n+        'test-osx-select.c',\n+        'test-pass-always.c',\n+        'test-ping-pong.c',\n+        'test-pipe-bind-error.c',\n+        'test-pipe-connect-error.c',\n+        'test-pipe-connect-multiple.c',\n+        'test-pipe-connect-prepare.c',\n+        'test-pipe-getsockname.c',\n+        'test-pipe-pending-instances.c',\n+        'test-pipe-sendmsg.c',\n+        'test-pipe-server-close.c',\n+        'test-pipe-close-stdout-read-stdin.c',\n+        'test-pipe-set-non-blocking.c',\n+        'test-pipe-set-fchmod.c',\n+        'test-platform-output.c',\n+        'test-poll.c',\n+        'test-poll-close.c',\n+        'test-poll-close-doesnt-corrupt-stack.c',\n+        'test-poll-closesocket.c',\n+        'test-poll-oob.c',\n+        'test-process-title.c',\n+        'test-process-title-threadsafe.c',\n+        'test-queue-foreach-delete.c',\n+        'test-ref.c',\n+        'test-run-nowait.c',\n+        'test-run-once.c',\n+        'test-semaphore.c',\n+        'test-shutdown-close.c',\n+        'test-shutdown-eof.c',\n+        'test-shutdown-twice.c',\n+        'test-signal.c',\n+        'test-signal-multiple-loops.c',\n+        'test-socket-buffer-size.c',\n+        'test-spawn.c',\n+        'test-fs-poll.c',\n+        'test-stdio-over-pipes.c',\n+        'test-tcp-alloc-cb-fail.c',\n+        'test-tcp-bind-error.c',\n+        'test-tcp-bind6-error.c',\n+        'test-tcp-close.c',\n+        'test-tcp-close-accept.c',\n+        'test-tcp-close-while-connecting.c',\n+        'test-tcp-create-socket-early.c',\n+        'test-tcp-connect-error-after-write.c',\n+        'test-tcp-shutdown-after-write.c',\n+        'test-tcp-flags.c',\n+        'test-tcp-connect-error.c',\n+        'test-tcp-connect-timeout.c',\n+        'test-tcp-connect6-error.c',\n+        'test-tcp-open.c',\n+        'test-tcp-write-to-half-open-connection.c',\n+        'test-tcp-write-after-connect.c',\n+        'test-tcp-writealot.c',\n+        'test-tcp-write-fail.c',\n+        'test-tcp-try-write.c',\n+        'test-tcp-unexpected-read.c',\n+        'test-tcp-oob.c',\n+        'test-tcp-read-stop.c',\n+        'test-tcp-write-queue-order.c',\n+        'test-threadpool.c',\n+        'test-threadpool-cancel.c',\n+        'test-thread-equal.c',\n+        'test-tmpdir.c',\n+        'test-mutexes.c',\n+        'test-thread.c',\n+        'test-barrier.c',\n+        'test-condvar.c',\n+        'test-timer-again.c',\n+        'test-timer-from-check.c',\n+        'test-timer.c',\n+        'test-tty.c',\n+        'test-udp-alloc-cb-fail.c',\n+        'test-udp-bind.c',\n+        'test-udp-create-socket-early.c',\n+        'test-udp-dgram-too-big.c',\n+        'test-udp-ipv6.c',\n+        'test-udp-open.c',\n+        'test-udp-options.c',\n+        'test-udp-send-and-recv.c',\n+        'test-udp-send-hang-loop.c',\n+        'test-udp-send-immediate.c',\n+        'test-udp-send-unreachable.c',\n+        'test-udp-multicast-join.c',\n+        'test-udp-multicast-join6.c',\n+        'test-dlerror.c',\n+        'test-udp-multicast-ttl.c',\n+        'test-ip4-addr.c',\n+        'test-ip6-addr.c',\n+        'test-udp-multicast-interface.c',\n+        'test-udp-multicast-interface6.c',\n+        'test-udp-try-send.c',\n+      ],\n+      'conditions': [\n+        [ 'OS==\"win\"', {\n+          'sources': [\n+            'runner-win.c',\n+            'runner-win.h',\n+            '../src/win/snprintf.c',\n+          ],\n+          'libraries': [ '-lws2_32' ]\n+        }, { # POSIX\n+          'sources': [\n+            'runner-unix.c',\n+            'runner-unix.h',\n+          ],\n+          'conditions': [\n+            [ 'OS != \"zos\"', {\n+              'defines': [ '_GNU_SOURCE' ],\n+              'cflags': [ '-Wno-long-long' ],\n+              'xcode_settings': {\n+                'WARNING_CFLAGS': [ '-Wno-long-long' ]\n+              }\n+            }],\n+          ]},\n+        ],\n+        [ 'OS in \"mac dragonflybsd freebsd linux netbsd openbsd\".split()', {\n+          'link_settings': {\n+            'libraries': [ '-lutil' ],\n+          },\n+        }],\n+        [ 'OS==\"solaris\"', { # make test-fs.c compile, needs _POSIX_C_SOURCE\n+          'defines': [\n+            '__EXTENSIONS__',\n+            '_XOPEN_SOURCE=500',\n+          ],\n+        }],\n+        [ 'OS==\"aix\"', {     # make test-fs.c compile, needs _POSIX_C_SOURCE\n+          'defines': [\n+            '_ALL_SOURCE',\n+            '_XOPEN_SOURCE=500',\n+          ],\n+        }],\n+        [ 'OS == \"zos\"', {\n+          'cflags': [ '-qxplink' ],\n+          'ldflags': [ '-qxplink' ],\n+        }],\n+        ['uv_library==\"shared_library\"', {\n+          'defines': [ 'USING_UV_SHARED=1' ],\n+          'conditions': [\n+            [ 'OS == \"zos\"', {\n+              'cflags': [ '-Wc,DLL' ],\n+            }],\n+          ],\n+        }],\n+      ],\n+      'msvs-settings': {\n+        'VCLinkerTool': {\n+          'SubSystem': 1, # /subsystem:console\n+        },\n+      },\n+    },\n+\n+    {\n+      'target_name': 'run-benchmarks',\n+      'type': 'executable',\n+      'dependencies': [ '../uv.gyp:libuv' ],\n+      'sources': [\n+        'benchmark-async.c',\n+        'benchmark-async-pummel.c',\n+        'benchmark-fs-stat.c',\n+        'benchmark-getaddrinfo.c',\n+        'benchmark-list.h',\n+        'benchmark-loop-count.c',\n+        'benchmark-million-async.c',\n+        'benchmark-million-timers.c',\n+        'benchmark-multi-accept.c',\n+        'benchmark-ping-pongs.c',\n+        'benchmark-pound.c',\n+        'benchmark-pump.c',\n+        'benchmark-sizes.c',\n+        'benchmark-spawn.c',\n+        'benchmark-thread.c',\n+        'benchmark-tcp-write-batch.c',\n+        'benchmark-udp-pummel.c',\n+        'dns-server.c',\n+        'echo-server.c',\n+        'blackhole-server.c',\n+        'run-benchmarks.c',\n+        'runner.c',\n+        'runner.h',\n+        'task.h',\n+      ],\n+      'conditions': [\n+        [ 'OS==\"win\"', {\n+          'sources': [\n+            'runner-win.c',\n+            'runner-win.h',\n+            '../src/win/snprintf.c',\n+          ],\n+          'libraries': [ '-lws2_32' ]\n+        }, { # POSIX\n+          'defines': [ '_GNU_SOURCE' ],\n+          'sources': [\n+            'runner-unix.c',\n+            'runner-unix.h',\n+          ]\n+        }],\n+        [ 'OS == \"zos\"', {\n+          'cflags': [ '-qxplink' ],\n+          'ldflags': [ '-qxplink' ],\n+        }],\n+        ['uv_library==\"shared_library\"', {\n+          'defines': [ 'USING_UV_SHARED=1' ],\n+          'conditions': [\n+            [ 'OS == \"zos\"', {\n+              'cflags': [ '-Wc,DLL' ],\n+            }],\n+          ],\n+        }],\n+      ],\n+      'msvs-settings': {\n+        'VCLinkerTool': {\n+          'SubSystem': 1, # /subsystem:console\n+        },\n+      },\n+    },\n+  ],\n+}"
        },
        {
            "sha": "a5046b87ea5b3c6746d787a507aabcb96c4085c3",
            "filename": "deps/uv/uv.gyp",
            "status": "modified",
            "additions": 47,
            "deletions": 310,
            "changes": 357,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fuv.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fuv.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fuv.gyp?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -1,44 +1,38 @@\n {\n-  'target_defaults': {\n+  'variables': {\n     'conditions': [\n-      ['OS != \"win\"', {\n-        'defines': [\n+      ['OS==\"win\"', {\n+        'shared_unix_defines': [\n           '_LARGEFILE_SOURCE',\n           '_FILE_OFFSET_BITS=64',\n         ],\n-        'conditions': [\n-          ['OS==\"solaris\"', {\n-            'cflags': [ '-pthreads' ],\n-          }],\n-          ['OS not in \"solaris android zos\"', {\n-            'cflags': [ '-pthread' ],\n-          }],\n-          ['OS in \"zos\"', {\n-            'defines': [\n-              '_UNIX03_THREADS',\n-              '_UNIX03_SOURCE',\n-              '_UNIX03_WITHDRAWN',\n-              '_OPEN_SYS_IF_EXT',\n-              '_OPEN_SYS_SOCK_IPV6',\n-              '_OPEN_MSGQ_EXT',\n-              '_XOPEN_SOURCE_EXTENDED',\n-              '_ALL_SOURCE',\n-              '_LARGE_TIME_API',\n-              '_OPEN_SYS_FILE_EXT',\n-              '_AE_BIMODAL',\n-              'PATH_MAX=255'\n-            ],\n-            'cflags': [ '-qxplink' ],\n-            'ldflags': [ '-qxplink' ],\n-          }]\n+      }, {\n+        'shared_unix_defines': [ ],\n+      }],\n+      ['OS in \"mac ios\"', {\n+        'shared_mac_defines': [ '_DARWIN_USE_64_BIT_INODE=1' ],\n+      }, {\n+        'shared_mac_defines': [ ],\n+      }],\n+      ['OS==\"zos\"', {\n+        'shared_zos_defines': [\n+          '_UNIX03_THREADS',\n+          '_UNIX03_SOURCE',\n+          '_UNIX03_WITHDRAWN',\n+          '_OPEN_SYS_IF_EXT',\n+          '_OPEN_SYS_SOCK_IPV6',\n+          '_OPEN_MSGQ_EXT',\n+          '_XOPEN_SOURCE_EXTENDED',\n+          '_ALL_SOURCE',\n+          '_LARGE_TIME_API',\n+          '_OPEN_SYS_FILE_EXT',\n+          '_AE_BIMODAL',\n+          'PATH_MAX=255'\n         ],\n+      }, {\n+        'shared_zos_defines': [ ],\n       }],\n     ],\n-    'xcode_settings': {\n-      'GCC_SYMBOLS_PRIVATE_EXTERN': 'YES',  # -fvisibility=hidden\n-      'WARNING_CFLAGS': [ '-Wall', '-Wextra', '-Wno-unused-parameter', '-Wstrict-prototypes' ],\n-      'OTHER_CFLAGS': [ '-g', '--std=gnu89', '-pedantic' ],\n-    }\n   },\n \n   'targets': [\n@@ -49,18 +43,19 @@\n         'include',\n         'src/',\n       ],\n+      'defines': [\n+        '<@(shared_mac_defines)',\n+        '<@(shared_unix_defines)',\n+        '<@(shared_zos_defines)',\n+      ],\n       'direct_dependent_settings': {\n+        'defines': [\n+          '<@(shared_mac_defines)',\n+          '<@(shared_unix_defines)',\n+          '<@(shared_zos_defines)',\n+        ],\n         'include_dirs': [ 'include' ],\n         'conditions': [\n-          ['OS != \"win\"', {\n-            'defines': [\n-              '_LARGEFILE_SOURCE',\n-              '_FILE_OFFSET_BITS=64',\n-            ],\n-          }],\n-          ['OS in \"mac ios\"', {\n-            'defines': [ '_DARWIN_USE_64_BIT_INODE=1' ],\n-          }],\n           ['OS == \"linux\"', {\n             'defines': [ '_POSIX_C_SOURCE=200112' ],\n           }],\n@@ -83,6 +78,16 @@\n         'src/uv-common.h',\n         'src/version.c'\n       ],\n+      'xcode_settings': {\n+        'GCC_SYMBOLS_PRIVATE_EXTERN': 'YES',  # -fvisibility=hidden\n+        'WARNING_CFLAGS': [\n+          '-Wall',\n+          '-Wextra',\n+          '-Wno-unused-parameter',\n+          '-Wstrict-prototypes',\n+        ],\n+        'OTHER_CFLAGS': [ '-g', '--std=gnu89', '-pedantic' ],\n+      },\n       'conditions': [\n         [ 'OS==\"win\"', {\n           'defines': [\n@@ -346,273 +351,5 @@\n         }],\n       ]\n     },\n-\n-    {\n-      'target_name': 'run-tests',\n-      'type': 'executable',\n-      'dependencies': [ 'libuv' ],\n-      'sources': [\n-        'test/blackhole-server.c',\n-        'test/echo-server.c',\n-        'test/run-tests.c',\n-        'test/runner.c',\n-        'test/runner.h',\n-        'test/test-get-loadavg.c',\n-        'test/task.h',\n-        'test/test-active.c',\n-        'test/test-async.c',\n-        'test/test-async-null-cb.c',\n-        'test/test-callback-stack.c',\n-        'test/test-callback-order.c',\n-        'test/test-close-fd.c',\n-        'test/test-close-order.c',\n-        'test/test-connect-unspecified.c',\n-        'test/test-connection-fail.c',\n-        'test/test-cwd-and-chdir.c',\n-        'test/test-default-loop-close.c',\n-        'test/test-delayed-accept.c',\n-        'test/test-eintr-handling.c',\n-        'test/test-error.c',\n-        'test/test-embed.c',\n-        'test/test-emfile.c',\n-        'test/test-env-vars.c',\n-        'test/test-fail-always.c',\n-        'test/test-fork.c',\n-        'test/test-fs.c',\n-        'test/test-fs-copyfile.c',\n-        'test/test-fs-event.c',\n-        'test/test-getters-setters.c',\n-        'test/test-get-currentexe.c',\n-        'test/test-get-memory.c',\n-        'test/test-get-passwd.c',\n-        'test/test-getaddrinfo.c',\n-        'test/test-gethostname.c',\n-        'test/test-getnameinfo.c',\n-        'test/test-getsockname.c',\n-        'test/test-handle-fileno.c',\n-        'test/test-homedir.c',\n-        'test/test-hrtime.c',\n-        'test/test-idle.c',\n-        'test/test-ip6-addr.c',\n-        'test/test-ipc.c',\n-        'test/test-ipc-send-recv.c',\n-        'test/test-list.h',\n-        'test/test-loop-handles.c',\n-        'test/test-loop-alive.c',\n-        'test/test-loop-close.c',\n-        'test/test-loop-stop.c',\n-        'test/test-loop-time.c',\n-        'test/test-loop-configure.c',\n-        'test/test-walk-handles.c',\n-        'test/test-watcher-cross-stop.c',\n-        'test/test-multiple-listen.c',\n-        'test/test-osx-select.c',\n-        'test/test-pass-always.c',\n-        'test/test-ping-pong.c',\n-        'test/test-pipe-bind-error.c',\n-        'test/test-pipe-connect-error.c',\n-        'test/test-pipe-connect-multiple.c',\n-        'test/test-pipe-connect-prepare.c',\n-        'test/test-pipe-getsockname.c',\n-        'test/test-pipe-pending-instances.c',\n-        'test/test-pipe-sendmsg.c',\n-        'test/test-pipe-server-close.c',\n-        'test/test-pipe-close-stdout-read-stdin.c',\n-        'test/test-pipe-set-non-blocking.c',\n-        'test/test-pipe-set-fchmod.c',\n-        'test/test-platform-output.c',\n-        'test/test-poll.c',\n-        'test/test-poll-close.c',\n-        'test/test-poll-close-doesnt-corrupt-stack.c',\n-        'test/test-poll-closesocket.c',\n-        'test/test-poll-oob.c',\n-        'test/test-process-title.c',\n-        'test/test-process-title-threadsafe.c',\n-        'test/test-queue-foreach-delete.c',\n-        'test/test-ref.c',\n-        'test/test-run-nowait.c',\n-        'test/test-run-once.c',\n-        'test/test-semaphore.c',\n-        'test/test-shutdown-close.c',\n-        'test/test-shutdown-eof.c',\n-        'test/test-shutdown-twice.c',\n-        'test/test-signal.c',\n-        'test/test-signal-multiple-loops.c',\n-        'test/test-socket-buffer-size.c',\n-        'test/test-spawn.c',\n-        'test/test-fs-poll.c',\n-        'test/test-stdio-over-pipes.c',\n-        'test/test-tcp-alloc-cb-fail.c',\n-        'test/test-tcp-bind-error.c',\n-        'test/test-tcp-bind6-error.c',\n-        'test/test-tcp-close.c',\n-        'test/test-tcp-close-accept.c',\n-        'test/test-tcp-close-while-connecting.c',\n-        'test/test-tcp-create-socket-early.c',\n-        'test/test-tcp-connect-error-after-write.c',\n-        'test/test-tcp-shutdown-after-write.c',\n-        'test/test-tcp-flags.c',\n-        'test/test-tcp-connect-error.c',\n-        'test/test-tcp-connect-timeout.c',\n-        'test/test-tcp-connect6-error.c',\n-        'test/test-tcp-open.c',\n-        'test/test-tcp-write-to-half-open-connection.c',\n-        'test/test-tcp-write-after-connect.c',\n-        'test/test-tcp-writealot.c',\n-        'test/test-tcp-write-fail.c',\n-        'test/test-tcp-try-write.c',\n-        'test/test-tcp-unexpected-read.c',\n-        'test/test-tcp-oob.c',\n-        'test/test-tcp-read-stop.c',\n-        'test/test-tcp-write-queue-order.c',\n-        'test/test-threadpool.c',\n-        'test/test-threadpool-cancel.c',\n-        'test/test-thread-equal.c',\n-        'test/test-tmpdir.c',\n-        'test/test-mutexes.c',\n-        'test/test-thread.c',\n-        'test/test-barrier.c',\n-        'test/test-condvar.c',\n-        'test/test-timer-again.c',\n-        'test/test-timer-from-check.c',\n-        'test/test-timer.c',\n-        'test/test-tty.c',\n-        'test/test-udp-alloc-cb-fail.c',\n-        'test/test-udp-bind.c',\n-        'test/test-udp-create-socket-early.c',\n-        'test/test-udp-dgram-too-big.c',\n-        'test/test-udp-ipv6.c',\n-        'test/test-udp-open.c',\n-        'test/test-udp-options.c',\n-        'test/test-udp-send-and-recv.c',\n-        'test/test-udp-send-hang-loop.c',\n-        'test/test-udp-send-immediate.c',\n-        'test/test-udp-send-unreachable.c',\n-        'test/test-udp-multicast-join.c',\n-        'test/test-udp-multicast-join6.c',\n-        'test/test-dlerror.c',\n-        'test/test-udp-multicast-ttl.c',\n-        'test/test-ip4-addr.c',\n-        'test/test-ip6-addr.c',\n-        'test/test-udp-multicast-interface.c',\n-        'test/test-udp-multicast-interface6.c',\n-        'test/test-udp-try-send.c',\n-      ],\n-      'conditions': [\n-        [ 'OS==\"win\"', {\n-          'sources': [\n-            'test/runner-win.c',\n-            'test/runner-win.h',\n-            'src/win/snprintf.c',\n-          ],\n-          'libraries': [ '-lws2_32' ]\n-        }, { # POSIX\n-          'sources': [\n-            'test/runner-unix.c',\n-            'test/runner-unix.h',\n-          ],\n-          'conditions': [\n-            [ 'OS != \"zos\"', {\n-              'defines': [ '_GNU_SOURCE' ],\n-              'cflags': [ '-Wno-long-long' ],\n-              'xcode_settings': {\n-                'WARNING_CFLAGS': [ '-Wno-long-long' ]\n-              }\n-            }],\n-          ]},\n-        ],\n-        [ 'OS in \"mac dragonflybsd freebsd linux netbsd openbsd\".split()', {\n-          'link_settings': {\n-            'libraries': [ '-lutil' ],\n-          },\n-        }],\n-        [ 'OS==\"solaris\"', { # make test-fs.c compile, needs _POSIX_C_SOURCE\n-          'defines': [\n-            '__EXTENSIONS__',\n-            '_XOPEN_SOURCE=500',\n-          ],\n-        }],\n-        [ 'OS==\"aix\"', {     # make test-fs.c compile, needs _POSIX_C_SOURCE\n-          'defines': [\n-            '_ALL_SOURCE',\n-            '_XOPEN_SOURCE=500',\n-          ],\n-        }],\n-        ['uv_library==\"shared_library\"', {\n-          'defines': [ 'USING_UV_SHARED=1' ],\n-          'conditions': [\n-            [ 'OS == \"zos\"', {\n-              'cflags': [ '-Wc,DLL' ],\n-            }],\n-          ],\n-        }],\n-      ],\n-      'msvs-settings': {\n-        'VCLinkerTool': {\n-          'SubSystem': 1, # /subsystem:console\n-        },\n-      },\n-    },\n-\n-    {\n-      'target_name': 'run-benchmarks',\n-      'type': 'executable',\n-      'dependencies': [ 'libuv' ],\n-      'sources': [\n-        'test/benchmark-async.c',\n-        'test/benchmark-async-pummel.c',\n-        'test/benchmark-fs-stat.c',\n-        'test/benchmark-getaddrinfo.c',\n-        'test/benchmark-list.h',\n-        'test/benchmark-loop-count.c',\n-        'test/benchmark-million-async.c',\n-        'test/benchmark-million-timers.c',\n-        'test/benchmark-multi-accept.c',\n-        'test/benchmark-ping-pongs.c',\n-        'test/benchmark-pound.c',\n-        'test/benchmark-pump.c',\n-        'test/benchmark-sizes.c',\n-        'test/benchmark-spawn.c',\n-        'test/benchmark-thread.c',\n-        'test/benchmark-tcp-write-batch.c',\n-        'test/benchmark-udp-pummel.c',\n-        'test/dns-server.c',\n-        'test/echo-server.c',\n-        'test/blackhole-server.c',\n-        'test/run-benchmarks.c',\n-        'test/runner.c',\n-        'test/runner.h',\n-        'test/task.h',\n-      ],\n-      'conditions': [\n-        [ 'OS==\"win\"', {\n-          'sources': [\n-            'test/runner-win.c',\n-            'test/runner-win.h',\n-            'src/win/snprintf.c',\n-          ],\n-          'libraries': [ '-lws2_32' ]\n-        }, { # POSIX\n-          'defines': [ '_GNU_SOURCE' ],\n-          'sources': [\n-            'test/runner-unix.c',\n-            'test/runner-unix.h',\n-          ]\n-        }],\n-        ['uv_library==\"shared_library\"', {\n-          'defines': [ 'USING_UV_SHARED=1' ],\n-          'conditions': [\n-            [ 'OS == \"zos\"', {\n-              'cflags': [ '-Wc,DLL' ],\n-            }],\n-          ],\n-        }],\n-      ],\n-      'msvs-settings': {\n-        'VCLinkerTool': {\n-          'SubSystem': 1, # /subsystem:console\n-        },\n-      },\n-    },\n   ]\n }"
        },
        {
            "sha": "c195394f37ea0bfa5d23e9ffcfce724013d6e7a3",
            "filename": "deps/uv/vcbuild.bat",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fvcbuild.bat",
            "raw_url": "https://github.com/nodejs/node/raw/3a191229418dcc0e21956847993b1702c88a923b/deps%2Fuv%2Fvcbuild.bat",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fvcbuild.bat?ref=3a191229418dcc0e21956847993b1702c88a923b",
            "patch": "@@ -159,13 +159,14 @@ goto run\n :msbuild-found\n msbuild uv.sln /t:%target% /p:Configuration=%config% /p:Platform=\"%msbuild_platform%\" /clp:NoSummary;NoItemAndPropertyList;Verbosity=minimal /nologo\n if errorlevel 1 exit /b 1\n+msbuild test\\test.sln /t:%target% /p:Configuration=%config% /p:Platform=\"%msbuild_platform%\" /clp:NoSummary;NoItemAndPropertyList;Verbosity=minimal /nologo\n+if errorlevel 1 exit /b 1\n \n :run\n @rem Run tests if requested.\n if \"%run%\"==\"\" goto exit\n-if not exist %config%\\%run% goto exit\n-echo running '%config%\\%run%'\n-%config%\\%run%\n+echo running 'test\\%config%\\%run%'\n+test\\%config%\\%run%\n goto exit\n \n :create-msvs-files-failed"
        }
    ],
    "stats": {
        "total": 1962,
        "additions": 1071,
        "deletions": 891
    }
}