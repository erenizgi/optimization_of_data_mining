{
    "author": "addaleax",
    "message": "src: clean up `node::Init()` wrt embedder scenarios\n\nThis makes the STL variant of `node::Init()` a bit more\nsuitable for inclusion in a proper embedder API, as errors\nor other output are reported to the caller rather than\ndirectly being printed, and the process is not exited\ndirectly either.\n\nPR-URL: https://github.com/nodejs/node/pull/25370\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "eb664c3b6df2ec618fa1c9339dbd418e858bfcfa",
    "files": [
        {
            "sha": "e55fbef57a1d114295630c48d81702282a8e3a6b",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 64,
            "deletions": 51,
            "changes": 115,
            "blob_url": "https://github.com/nodejs/node/blob/eb664c3b6df2ec618fa1c9339dbd418e858bfcfa/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/eb664c3b6df2ec618fa1c9339dbd418e858bfcfa/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=eb664c3b6df2ec618fa1c9339dbd418e858bfcfa",
            "patch": "@@ -1147,42 +1147,23 @@ inline void PlatformInit() {\n #endif  // _WIN32\n }\n \n-void ProcessArgv(std::vector<std::string>* args,\n-                 std::vector<std::string>* exec_args,\n-                 bool is_env) {\n+int ProcessGlobalArgs(std::vector<std::string>* args,\n+                      std::vector<std::string>* exec_args,\n+                      std::vector<std::string>* errors,\n+                      bool is_env) {\n   // Parse a few arguments which are specific to Node.\n   std::vector<std::string> v8_args;\n-  std::vector<std::string> errors{};\n \n-  {\n-    // TODO(addaleax): The mutex here should ideally be held during the\n-    // entire function, but that doesn't play well with the exit() calls below.\n-    Mutex::ScopedLock lock(per_process::cli_options_mutex);\n-    options_parser::PerProcessOptionsParser::instance.Parse(\n-        args,\n-        exec_args,\n-        &v8_args,\n-        per_process::cli_options.get(),\n-        is_env ? kAllowedInEnvironment : kDisallowedInEnvironment,\n-        &errors);\n-  }\n-\n-  if (!errors.empty()) {\n-    for (auto const& error : errors) {\n-      fprintf(stderr, \"%s: %s\\n\", args->at(0).c_str(), error.c_str());\n-    }\n-    exit(9);\n-  }\n+  Mutex::ScopedLock lock(per_process::cli_options_mutex);\n+  options_parser::PerProcessOptionsParser::instance.Parse(\n+      args,\n+      exec_args,\n+      &v8_args,\n+      per_process::cli_options.get(),\n+      is_env ? kAllowedInEnvironment : kDisallowedInEnvironment,\n+      errors);\n \n-  if (per_process::cli_options->print_version) {\n-    printf(\"%s\\n\", NODE_VERSION);\n-    exit(0);\n-  }\n-\n-  if (per_process::cli_options->print_v8_help) {\n-    V8::SetFlagsFromString(\"--help\", 6);\n-    exit(0);\n-  }\n+  if (!errors->empty()) return 9;\n \n   for (const std::string& cve : per_process::cli_options->security_reverts)\n     Revert(cve.c_str());\n@@ -1222,19 +1203,17 @@ void ProcessArgv(std::vector<std::string>* args,\n   }\n \n   // Anything that's still in v8_argv is not a V8 or a node option.\n-  for (size_t i = 1; i < v8_args_as_char_ptr.size(); i++) {\n-    fprintf(stderr, \"%s: bad option: %s\\n\",\n-            args->at(0).c_str(), v8_args_as_char_ptr[i]);\n-  }\n+  for (size_t i = 1; i < v8_args_as_char_ptr.size(); i++)\n+    errors->push_back(\"bad option: \" + std::string(v8_args_as_char_ptr[i]));\n \n-  if (v8_args_as_char_ptr.size() > 1) {\n-    exit(9);\n-  }\n-}\n+  if (v8_args_as_char_ptr.size() > 1) return 9;\n \n+  return 0;\n+}\n \n-void Init(std::vector<std::string>* argv,\n-          std::vector<std::string>* exec_argv) {\n+int Init(std::vector<std::string>* argv,\n+         std::vector<std::string>* exec_argv,\n+         std::vector<std::string>* errors) {\n   // Initialize prog_start_time to get relative uptime.\n   per_process::prog_start_time = static_cast<double>(uv_now(uv_default_loop()));\n \n@@ -1295,11 +1274,13 @@ void Init(std::vector<std::string>* argv,\n     std::vector<std::string> env_argv = SplitString(\"x \" + node_options, ' ');\n     env_argv[0] = argv->at(0);\n \n-    ProcessArgv(&env_argv, nullptr, true);\n+    const int exit_code = ProcessGlobalArgs(&env_argv, nullptr, errors, true);\n+    if (exit_code != 0) return exit_code;\n   }\n #endif\n \n-  ProcessArgv(argv, exec_argv, false);\n+  const int exit_code = ProcessGlobalArgs(argv, exec_argv, errors, false);\n+  if (exit_code != 0) return exit_code;\n \n   // Set the process.title immediately after processing argv if --title is set.\n   if (!per_process::cli_options->title.empty())\n@@ -1313,11 +1294,9 @@ void Init(std::vector<std::string>* argv,\n   // Initialize ICU.\n   // If icu_data_dir is empty here, it will load the 'minimal' data.\n   if (!i18n::InitializeICUDirectory(per_process::cli_options->icu_data_dir)) {\n-    fprintf(stderr,\n-            \"%s: could not initialize ICU \"\n-            \"(check NODE_ICU_DATA or --icu-data-dir parameters)\\n\",\n-            argv->at(0).c_str());\n-    exit(9);\n+    errors->push_back(\"could not initialize ICU \"\n+                      \"(check NODE_ICU_DATA or --icu-data-dir parameters)\\n\");\n+    return 9;\n   }\n   per_process::metadata.versions.InitializeIntlVersions();\n #endif\n@@ -1326,6 +1305,7 @@ void Init(std::vector<std::string>* argv,\n   // otherwise embedders using node::Init to initialize everything will not be\n   // able to set it and native modules will not load for them.\n   node_is_initialized = true;\n+  return 0;\n }\n \n // TODO(addaleax): Deprecate and eventually remove this.\n@@ -1335,8 +1315,25 @@ void Init(int* argc,\n           const char*** exec_argv) {\n   std::vector<std::string> argv_(argv, argv + *argc);  // NOLINT\n   std::vector<std::string> exec_argv_;\n+  std::vector<std::string> errors;\n+\n+  // This (approximately) duplicates some logic that has been moved to\n+  // node::Start(), with the difference that here we explicitly call `exit()`.\n+  int exit_code = Init(&argv_, &exec_argv_, &errors);\n \n-  Init(&argv_, &exec_argv_);\n+  for (const std::string& error : errors)\n+    fprintf(stderr, \"%s: %s\\n\", argv_.at(0).c_str(), error.c_str());\n+  if (exit_code != 0) exit(exit_code);\n+\n+  if (per_process::cli_options->print_version) {\n+    printf(\"%s\\n\", NODE_VERSION);\n+    exit(0);\n+  }\n+\n+  if (per_process::cli_options->print_v8_help) {\n+    V8::SetFlagsFromString(\"--help\", 6);  // Doesn't return.\n+    UNREACHABLE();\n+  }\n \n   *argc = argv_.size();\n   *exec_argc = exec_argv_.size();\n@@ -1653,6 +1650,16 @@ inline int Start(uv_loop_t* event_loop,\n   if (isolate == nullptr)\n     return 12;  // Signal internal error.\n \n+  if (per_process::cli_options->print_version) {\n+    printf(\"%s\\n\", NODE_VERSION);\n+    return 0;\n+  }\n+\n+  if (per_process::cli_options->print_v8_help) {\n+    V8::SetFlagsFromString(\"--help\", 6);  // Doesn't return.\n+    UNREACHABLE();\n+  }\n+\n   {\n     Mutex::ScopedLock scoped_lock(per_process::main_isolate_mutex);\n     CHECK_NULL(per_process::main_isolate);\n@@ -1712,8 +1719,14 @@ int Start(int argc, char** argv) {\n \n   std::vector<std::string> args(argv, argv + argc);\n   std::vector<std::string> exec_args;\n+  std::vector<std::string> errors;\n   // This needs to run *before* V8::Initialize().\n-  Init(&args, &exec_args);\n+  {\n+    const int exit_code = Init(&args, &exec_args, &errors);\n+    for (const std::string& error : errors)\n+      fprintf(stderr, \"%s: %s\\n\", args.at(0).c_str(), error.c_str());\n+    if (exit_code != 0) return exit_code;\n+  }\n \n #if HAVE_OPENSSL\n   {"
        }
    ],
    "stats": {
        "total": 115,
        "additions": 64,
        "deletions": 51
    }
}