{
    "author": "tniessen",
    "message": "crypto: throw in setAuthTag on invalid length\n\nThe current implementation performs limited checks only and silently\nignores superfluous bytes of the authentication tag. This change makes\nsetAuthTag throw when\n- the user-specified authTagLength does not match the actual tag length,\n  especially when the authentication tag is longer than 16 bytes, and\n  when\n- the mode is GCM, no authTagLength option has been specified and the\n  tag length is not a valid GCM tag length.\n\nThis change makes the conditional assignment in SetAuthTag unnecessary,\nwhich is replaced with a CHECK.\n\nRefs: https://github.com/nodejs/node/pull/17825\n\nPR-URL: https://github.com/nodejs/node/pull/20040\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Yihong Wang <yh.wang@ibm.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "faf449ca0490f5371dc6cbbc94a87eb697b00fcc",
    "files": [
        {
            "sha": "d81853331ba86bda0401f162e3815577962e6163",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 15,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/faf449ca0490f5371dc6cbbc94a87eb697b00fcc/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/faf449ca0490f5371dc6cbbc94a87eb697b00fcc/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=faf449ca0490f5371dc6cbbc94a87eb697b00fcc",
            "patch": "@@ -2806,9 +2806,7 @@ bool CipherBase::InitAuthenticated(const char* cipher_type, int iv_len,\n       return false;\n     }\n \n-    // When decrypting in CCM mode, this field will be set in setAuthTag().\n-    if (kind_ == kCipher)\n-      auth_tag_len_ = auth_tag_len;\n+    auth_tag_len_ = auth_tag_len;\n \n     // The message length is restricted to 2 ^ (8 * (15 - iv_len)) - 1 bytes.\n     CHECK(iv_len >= 7 && iv_len <= 13);\n@@ -2824,7 +2822,7 @@ bool CipherBase::InitAuthenticated(const char* cipher_type, int iv_len,\n       if (!IsValidGCMTagLength(auth_tag_len)) {\n         char msg[50];\n         snprintf(msg, sizeof(msg),\n-            \"Invalid GCM authentication tag length: %u\", auth_tag_len);\n+            \"Invalid authentication tag length: %u\", auth_tag_len);\n         env()->ThrowError(msg);\n         return false;\n       }\n@@ -2891,21 +2889,26 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n   // Restrict GCM tag lengths according to NIST 800-38d, page 9.\n   unsigned int tag_len = Buffer::Length(args[0]);\n   const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());\n+  bool is_valid;\n   if (mode == EVP_CIPH_GCM_MODE) {\n-    if ((cipher->auth_tag_len_ != kNoAuthTagLength &&\n-        cipher->auth_tag_len_ != tag_len) ||\n-        !IsValidGCMTagLength(tag_len)) {\n-      char msg[50];\n-      snprintf(msg, sizeof(msg),\n-          \"Invalid GCM authentication tag length: %u\", tag_len);\n-      return cipher->env()->ThrowError(msg);\n-    }\n+    is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||\n+                cipher->auth_tag_len_ == tag_len) &&\n+               IsValidGCMTagLength(tag_len);\n+  } else {\n+    CHECK_EQ(mode, EVP_CIPH_CCM_MODE);\n+    CHECK_NE(cipher->auth_tag_len_, kNoAuthTagLength);\n+    is_valid = cipher->auth_tag_len_ == tag_len;\n+  }\n+\n+  if (!is_valid) {\n+    char msg[50];\n+    snprintf(msg, sizeof(msg),\n+        \"Invalid authentication tag length: %u\", tag_len);\n+    return cipher->env()->ThrowError(msg);\n   }\n \n-  // Note: we don't use std::min() here to work around a header conflict.\n   cipher->auth_tag_len_ = tag_len;\n-  if (cipher->auth_tag_len_ > sizeof(cipher->auth_tag_))\n-    cipher->auth_tag_len_ = sizeof(cipher->auth_tag_);\n+  CHECK_LE(cipher->auth_tag_len_, sizeof(cipher->auth_tag_));\n \n   memset(cipher->auth_tag_, 0, sizeof(cipher->auth_tag_));\n   memcpy(cipher->auth_tag_, Buffer::Data(args[0]), cipher->auth_tag_len_);"
        },
        {
            "sha": "ee91e31e9c63b900061de766c53bd3995c0c512b",
            "filename": "test/parallel/test-crypto-authenticated.js",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/faf449ca0490f5371dc6cbbc94a87eb697b00fcc/test%2Fparallel%2Ftest-crypto-authenticated.js",
            "raw_url": "https://github.com/nodejs/node/raw/faf449ca0490f5371dc6cbbc94a87eb697b00fcc/test%2Fparallel%2Ftest-crypto-authenticated.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-authenticated.js?ref=faf449ca0490f5371dc6cbbc94a87eb697b00fcc",
            "patch": "@@ -724,7 +724,7 @@ for (const test of TEST_CASES) {\n       decrypt.setAuthTag(Buffer.from('1'.repeat(length)));\n     }, {\n       type: Error,\n-      message: `Invalid GCM authentication tag length: ${length}`\n+      message: `Invalid authentication tag length: ${length}`\n     });\n \n     common.expectsError(() => {\n@@ -736,7 +736,7 @@ for (const test of TEST_CASES) {\n                             });\n     }, {\n       type: Error,\n-      message: `Invalid GCM authentication tag length: ${length}`\n+      message: `Invalid authentication tag length: ${length}`\n     });\n \n     common.expectsError(() => {\n@@ -748,7 +748,7 @@ for (const test of TEST_CASES) {\n                               });\n     }, {\n       type: Error,\n-      message: `Invalid GCM authentication tag length: ${length}`\n+      message: `Invalid authentication tag length: ${length}`\n     });\n   }\n }\n@@ -783,7 +783,7 @@ for (const test of TEST_CASES) {\n     decipher.setAuthTag(Buffer.from('1'.repeat(12)));\n   }, {\n     type: Error,\n-    message: 'Invalid GCM authentication tag length: 12'\n+    message: 'Invalid authentication tag length: 12'\n   });\n \n   // The Decipher object should be left intact.\n@@ -985,7 +985,7 @@ for (const test of TEST_CASES) {\n   }\n }\n \n-// Test that setAAD throws in CCM mode when no authentication tag is provided.\n+// Test that final() throws in CCM mode when no authentication tag is provided.\n {\n   if (!common.hasFipsCrypto) {\n     const key = Buffer.from('1ed2233fa2223ef5d7df08546049406c', 'hex');\n@@ -1000,6 +1000,8 @@ for (const test of TEST_CASES) {\n       decrypt.setAAD(Buffer.from('63616c76696e', 'hex'), {\n         plaintextLength: ct.length\n       });\n+      decrypt.update(ct);\n+      decrypt.final();\n     }, errMessages.state);\n   }\n }"
        }
    ],
    "stats": {
        "total": 45,
        "additions": 25,
        "deletions": 20
    }
}