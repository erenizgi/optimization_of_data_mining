{
    "author": "cjihrig",
    "message": "deps: upgrade to libuv 1.23.2\n\nPR-URL: https://github.com/nodejs/node/pull/23336\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\nFixes: https://github.com/nodejs/node/issues/23043\nFixes: https://github.com/nodejs/node/issues/21773\nFixes: https://github.com/nodejs/node/issues/16601\nFixes: https://github.com/nodejs/node/issues/22999\nFixes: https://github.com/nodejs/node/issues/23219\nFixes: https://github.com/nodejs/node/issues/23066\nFixes: https://github.com/nodejs/node/issues/23067\nFixes: https://github.com/nodejs/node/issues/23089",
    "sha": "c65a523597ccdf2b3544244679dae581040cf52f",
    "files": [
        {
            "sha": "2fdfbcd5322e5e77799b21c18f32e84e819ffd3f",
            "filename": "deps/uv/AUTHORS",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FAUTHORS?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -351,3 +351,4 @@ Jeremiah Senkpiel <fishrock123@rocketmail.com>\n Andy Zhang <zhangyong232@gmail.com>\n dmabupt <dmabupt@gmail.com>\n Ryan Liptak <squeek502@hotmail.com>\n+Ali Ijaz Sheikh <ofrobots@google.com>"
        },
        {
            "sha": "6a631a87c1cb393e0126033f786d50ed76c97836",
            "filename": "deps/uv/CMakeLists.txt",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2FCMakeLists.txt",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2FCMakeLists.txt",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FCMakeLists.txt?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -193,7 +193,6 @@ if(WIN32)\n        src/win/poll.c\n        src/win/process.c\n        src/win/process-stdio.c\n-       src/win/req.c\n        src/win/signal.c\n        src/win/snprintf.c\n        src/win/stream.c"
        },
        {
            "sha": "7cb675238d3e0871b7094a15b2118f5647dd9213",
            "filename": "deps/uv/ChangeLog",
            "status": "modified",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2FChangeLog",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2FChangeLog",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FChangeLog?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -1,3 +1,41 @@\n+2018.10.09, Version 1.23.2 (Stable), 34c12788d2e7308f3ac506c0abcbf74c0d6abd20\n+\n+Changes since version 1.23.1:\n+\n+* unix: return 0 retrieving rss on cygwin (cjihrig)\n+\n+* unix: initialize uv_interface_address_t.phys_addr (cjihrig)\n+\n+* test: handle uv_os_setpriority() windows edge case (cjihrig)\n+\n+* tty, win: fix read stop for raw mode (Bartosz Sosnowski)\n+\n+* Revert \"Revert \"unix,fs: fix for potential partial reads/writes\"\" (Jameson\n+  Nash)\n+\n+* unix,readv: always permit partial reads to return (Jameson Nash)\n+\n+* win,tty: fix uv_tty_close() (Bartosz Sosnowski)\n+\n+* doc: remove extraneous \"on\" (Ben Noordhuis)\n+\n+* unix,win: fix threadpool race condition (Anna Henningsen)\n+\n+* unix: rework thread barrier implementation (Ben Noordhuis)\n+\n+* aix: switch to libuv's own thread barrier impl (Ben Noordhuis)\n+\n+* unix: signal done to last thread barrier waiter (Ben Noordhuis)\n+\n+* test: add uv_barrier_wait serial thread test (Ali Ijaz Sheikh)\n+\n+* unix: optimize uv_fs_readlink() memory allocation (Ben Noordhuis)\n+\n+* win: remove req.c and other cleanup (Carlo Marcelo Arenas Bel√≥n)\n+\n+* aix: don't EISDIR on read from directory fd (Ben Noordhuis)\n+\n+\n 2018.09.22, Version 1.23.1 (Stable), d2282b3d67821dc53c907c2155fa8c5c6ce25180\n \n Changes since version 1.23.0:"
        },
        {
            "sha": "2381425403c376efdfafbf48ffd41233fa6a279d",
            "filename": "deps/uv/Makefile.am",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2FMakefile.am",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2FMakefile.am",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FMakefile.am?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -68,7 +68,6 @@ libuv_la_SOURCES += src/win/async.c \\\n                     src/win/poll.c \\\n                     src/win/process-stdio.c \\\n                     src/win/process.c \\\n-                    src/win/req.c \\\n                     src/win/req-inl.h \\\n                     src/win/signal.c \\\n                     src/win/stream.c \\\n@@ -340,8 +339,7 @@ libuv_la_SOURCES += src/unix/aix.c src/unix/aix-common.c\n endif\n \n if ANDROID\n-uvinclude_HEADERS += include/uv/android-ifaddrs.h \\\n-                   include/uv/pthread-barrier.h\n+uvinclude_HEADERS += include/uv/android-ifaddrs.h\n libuv_la_SOURCES += src/unix/android-ifaddrs.c \\\n                     src/unix/pthread-fixes.c\n endif\n@@ -361,8 +359,7 @@ libuv_la_SOURCES += src/unix/cygwin.c \\\n endif\n \n if DARWIN\n-uvinclude_HEADERS += include/uv/darwin.h \\\n-                   include/uv/pthread-barrier.h\n+uvinclude_HEADERS += include/uv/darwin.h\n libuv_la_CFLAGS += -D_DARWIN_USE_64_BIT_INODE=1\n libuv_la_CFLAGS += -D_DARWIN_UNLIMITED_SELECT=1\n libuv_la_SOURCES += src/unix/bsd-ifaddrs.c \\\n@@ -445,7 +442,6 @@ libuv_la_SOURCES += src/unix/no-proctitle.c \\\n endif\n \n if OS390\n-uvinclude_HEADERS += include/uv/pthread-barrier.h\n libuv_la_CFLAGS += -D_UNIX03_THREADS \\\n                    -D_UNIX03_SOURCE \\\n                    -D_OPEN_SYS_IF_EXT=1 \\"
        },
        {
            "sha": "0d9066bb0225a5fd06744d9ddb5b247cf989ca9e",
            "filename": "deps/uv/configure.ac",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fconfigure.ac",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fconfigure.ac",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fconfigure.ac?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -13,7 +13,7 @@\n # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n \n AC_PREREQ(2.57)\n-AC_INIT([libuv], [1.23.1], [https://github.com/libuv/libuv/issues])\n+AC_INIT([libuv], [1.23.2], [https://github.com/libuv/libuv/issues])\n AC_CONFIG_MACRO_DIR([m4])\n m4_include([m4/libuv-extra-automake-flags.m4])\n m4_include([m4/as_case.m4])"
        },
        {
            "sha": "001b12334d2354ab36a447d2b395950a4ae5cbfe",
            "filename": "deps/uv/docs/src/design.rst",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fdocs%2Fsrc%2Fdesign.rst",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fdocs%2Fsrc%2Fdesign.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Fdesign.rst?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -126,7 +126,7 @@ so the current approach is to run blocking file I/O operations in a thread pool.\n For a thorough explanation of the cross-platform file I/O landscape, checkout\n `this post <http://blog.libtorrent.org/2012/10/asynchronous-disk-io/>`_.\n \n-libuv currently uses a global thread pool on which all loops can queue work on. 3 types of\n+libuv currently uses a global thread pool on which all loops can queue work. 3 types of\n operations are currently run on this pool:\n \n     * File system operations"
        },
        {
            "sha": "07db9b8a6a27e0a6fb88522fdb9eb5eec7522e62",
            "filename": "deps/uv/include/uv/pthread-barrier.h",
            "status": "removed",
            "additions": 0,
            "deletions": 69,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/13340d47fcdbc9fa0eaaeee52d2c09338590a797/deps%2Fuv%2Finclude%2Fuv%2Fpthread-barrier.h",
            "raw_url": "https://github.com/nodejs/node/raw/13340d47fcdbc9fa0eaaeee52d2c09338590a797/deps%2Fuv%2Finclude%2Fuv%2Fpthread-barrier.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fpthread-barrier.h?ref=13340d47fcdbc9fa0eaaeee52d2c09338590a797",
            "patch": "@@ -1,69 +0,0 @@\n-/*\n-Copyright (c) 2016, Kari Tristan Helgason <kthelgason@gmail.com>\n-\n-Permission to use, copy, modify, and/or distribute this software for any\n-purpose with or without fee is hereby granted, provided that the above\n-copyright notice and this permission notice appear in all copies.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n-WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n-MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n-ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n-ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n-OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n-*/\n-\n-#ifndef _UV_PTHREAD_BARRIER_\n-#define _UV_PTHREAD_BARRIER_\n-#include <errno.h>\n-#include <pthread.h>\n-#if !defined(__MVS__)\n-#include <semaphore.h> /* sem_t */\n-#endif\n-\n-#define PTHREAD_BARRIER_SERIAL_THREAD  0x12345\n-#define UV__PTHREAD_BARRIER_FALLBACK   1\n-\n-/*\n- * To maintain ABI compatibility with\n- * libuv v1.x struct is padded according\n- * to target platform\n- */\n-#if defined(__ANDROID__)\n-# define UV_BARRIER_STRUCT_PADDING \\\n-  sizeof(pthread_mutex_t) + \\\n-  sizeof(pthread_cond_t) + \\\n-  sizeof(unsigned int) - \\\n-  sizeof(void *)\n-#elif defined(__APPLE__)\n-# define UV_BARRIER_STRUCT_PADDING \\\n-  sizeof(pthread_mutex_t) + \\\n-  2 * sizeof(sem_t) + \\\n-  2 * sizeof(unsigned int) - \\\n-  sizeof(void *)\n-#else\n-# define UV_BARRIER_STRUCT_PADDING 0\n-#endif\n-\n-typedef struct {\n-  pthread_mutex_t  mutex;\n-  pthread_cond_t   cond;\n-  unsigned         threshold;\n-  unsigned         in;\n-  unsigned         out;\n-} _uv_barrier;\n-\n-typedef struct {\n-  _uv_barrier* b;\n-  char _pad[UV_BARRIER_STRUCT_PADDING];\n-} pthread_barrier_t;\n-\n-int pthread_barrier_init(pthread_barrier_t* barrier,\n-                         const void* barrier_attr,\n-                         unsigned count);\n-\n-int pthread_barrier_wait(pthread_barrier_t* barrier);\n-int pthread_barrier_destroy(pthread_barrier_t *barrier);\n-\n-#endif /* _UV_PTHREAD_BARRIER_ */"
        },
        {
            "sha": "7208557b560ce864ff179f2430c75bf3faf9f84b",
            "filename": "deps/uv/include/uv/unix.h",
            "status": "modified",
            "additions": 21,
            "deletions": 5,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Finclude%2Fuv%2Funix.h",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Finclude%2Fuv%2Funix.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Funix.h?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -66,10 +66,6 @@\n # include \"uv/posix.h\"\n #endif\n \n-#ifndef PTHREAD_BARRIER_SERIAL_THREAD\n-# include \"uv/pthread-barrier.h\"\n-#endif\n-\n #ifndef NI_MAXHOST\n # define NI_MAXHOST 1025\n #endif\n@@ -136,8 +132,28 @@ typedef pthread_rwlock_t uv_rwlock_t;\n typedef UV_PLATFORM_SEM_T uv_sem_t;\n typedef pthread_cond_t uv_cond_t;\n typedef pthread_key_t uv_key_t;\n-typedef pthread_barrier_t uv_barrier_t;\n \n+/* Note: guard clauses should match uv_barrier_init's in src/unix/thread.c. */\n+#if defined(_AIX) || !defined(PTHREAD_BARRIER_SERIAL_THREAD)\n+/* TODO(bnoordhuis) Merge into uv_barrier_t in v2. */\n+struct _uv_barrier {\n+  uv_mutex_t mutex;\n+  uv_cond_t cond;\n+  unsigned threshold;\n+  unsigned in;\n+  unsigned out;\n+};\n+\n+typedef struct {\n+  struct _uv_barrier* b;\n+# if defined(PTHREAD_BARRIER_SERIAL_THREAD)\n+  /* TODO(bnoordhuis) Remove padding in v2. */\n+  char pad[sizeof(pthread_barrier_t) - sizeof(struct _uv_barrier*)];\n+# endif\n+} uv_barrier_t;\n+#else\n+typedef pthread_barrier_t uv_barrier_t;\n+#endif\n \n /* Platform-specific definitions for uv_spawn support. */\n typedef gid_t uv_gid_t;"
        },
        {
            "sha": "cc064e2fd87ce8cbddcf0f1a0cc705728821bb36",
            "filename": "deps/uv/include/uv/version.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fversion.h?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -32,7 +32,7 @@\n \n #define UV_VERSION_MAJOR 1\n #define UV_VERSION_MINOR 23\n-#define UV_VERSION_PATCH 1\n+#define UV_VERSION_PATCH 2\n #define UV_VERSION_IS_RELEASE 1\n #define UV_VERSION_SUFFIX \"\"\n "
        },
        {
            "sha": "4258933c724782cbf6eb0c3d7978f5224da0bf29",
            "filename": "deps/uv/src/threadpool.c",
            "status": "modified",
            "additions": 12,
            "deletions": 6,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fthreadpool.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fthreadpool.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fthreadpool.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -62,10 +62,10 @@ static void worker(void* arg) {\n   uv_sem_post((uv_sem_t*) arg);\n   arg = NULL;\n \n+  uv_mutex_lock(&mutex);\n   for (;;) {\n-    uv_mutex_lock(&mutex);\n+    /* `mutex` should always be locked at this point. */\n \n-  wait_for_work:\n     /* Keep waiting while either no work is present or only slow I/O\n        and we're at the threshold for that. */\n     while (QUEUE_EMPTY(&wq) ||\n@@ -93,13 +93,13 @@ static void worker(void* arg) {\n          other work in the queue is done. */\n       if (slow_io_work_running >= slow_work_thread_threshold()) {\n         QUEUE_INSERT_TAIL(&wq, q);\n-        goto wait_for_work;\n+        continue;\n       }\n \n       /* If we encountered a request to run slow I/O work but there is none\n          to run, that means it's cancelled => Start over. */\n       if (QUEUE_EMPTY(&slow_io_pending_wq))\n-        goto wait_for_work;\n+        continue;\n \n       is_slow_work = 1;\n       slow_io_work_running++;\n@@ -122,13 +122,19 @@ static void worker(void* arg) {\n     w->work(w);\n \n     uv_mutex_lock(&w->loop->wq_mutex);\n-    if (is_slow_work)\n-      slow_io_work_running--;\n     w->work = NULL;  /* Signal uv_cancel() that the work req is done\n                         executing. */\n     QUEUE_INSERT_TAIL(&w->loop->wq, &w->wq);\n     uv_async_send(&w->loop->wq_async);\n     uv_mutex_unlock(&w->loop->wq_mutex);\n+\n+    /* Lock `mutex` since that is expected at the start of the next\n+     * iteration. */\n+    uv_mutex_lock(&mutex);\n+    if (is_slow_work) {\n+      /* `slow_io_work_running` is protected by `mutex`. */\n+      slow_io_work_running--;\n+    }\n   }\n }\n "
        },
        {
            "sha": "9825b1c4db486522bc89f98a46f62ad974095247",
            "filename": "deps/uv/src/unix/bsd-ifaddrs.c",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Fbsd-ifaddrs.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Fbsd-ifaddrs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fbsd-ifaddrs.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -119,16 +119,13 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n       continue;\n \n     address = *addresses;\n+    memset(address->phys_addr, 0, sizeof(address->phys_addr));\n \n     for (i = 0; i < *count; i++) {\n       if (strcmp(address->name, ent->ifa_name) == 0) {\n-#if defined(__CYGWIN__) || defined(__MSYS__)\n-        memset(address->phys_addr, 0, sizeof(address->phys_addr));\n-#else\n         struct sockaddr_dl* sa_addr;\n         sa_addr = (struct sockaddr_dl*)(ent->ifa_addr);\n         memcpy(address->phys_addr, LLADDR(sa_addr), sizeof(address->phys_addr));\n-#endif\n       }\n       address++;\n     }"
        },
        {
            "sha": "9da20e203aa238ab50d27362590c87057f27d16f",
            "filename": "deps/uv/src/unix/cygwin.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Fcygwin.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Fcygwin.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fcygwin.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -38,7 +38,7 @@ int uv_uptime(double* uptime) {\n int uv_resident_set_memory(size_t* rss) {\n   /* FIXME: read /proc/meminfo? */\n   *rss = 0;\n-  return UV_ENOSYS;\n+  return 0;\n }\n \n int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {"
        },
        {
            "sha": "3db5f89c9503d2e0295a38c9de16023ab2b60bf0",
            "filename": "deps/uv/src/unix/fs.c",
            "status": "modified",
            "additions": 55,
            "deletions": 61,
            "changes": 116,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Ffs.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Ffs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ffs.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -262,17 +262,13 @@ static ssize_t uv__fs_read(uv_fs_t* req) {\n #if defined(__linux__)\n   static int no_preadv;\n #endif\n+  unsigned int iovmax;\n   ssize_t result;\n \n-#if defined(_AIX)\n-  struct stat buf;\n-  if(fstat(req->file, &buf))\n-    return -1;\n-  if(S_ISDIR(buf.st_mode)) {\n-    errno = EISDIR;\n-    return -1;\n-  }\n-#endif /* defined(_AIX) */\n+  iovmax = uv__getiovmax();\n+  if (req->nbufs > iovmax)\n+    req->nbufs = iovmax;\n+\n   if (req->off < 0) {\n     if (req->nbufs == 1)\n       result = read(req->file, req->bufs[0].base, req->bufs[0].len);\n@@ -291,25 +287,7 @@ static ssize_t uv__fs_read(uv_fs_t* req) {\n     if (no_preadv) retry:\n # endif\n     {\n-      off_t nread;\n-      size_t index;\n-\n-      nread = 0;\n-      index = 0;\n-      result = 1;\n-      do {\n-        if (req->bufs[index].len > 0) {\n-          result = pread(req->file,\n-                         req->bufs[index].base,\n-                         req->bufs[index].len,\n-                         req->off + nread);\n-          if (result > 0)\n-            nread += result;\n-        }\n-        index++;\n-      } while (index < req->nbufs && result > 0);\n-      if (nread > 0)\n-        result = nread;\n+      result = pread(req->file, req->bufs[0].base, req->bufs[0].len, req->off);\n     }\n # if defined(__linux__)\n     else {\n@@ -327,6 +305,13 @@ static ssize_t uv__fs_read(uv_fs_t* req) {\n   }\n \n done:\n+  /* Early cleanup of bufs allocation, since we're done with it. */\n+  if (req->bufs != req->bufsml)\n+    uv__free(req->bufs);\n+\n+  req->bufs = NULL;\n+  req->nbufs = 0;\n+\n   return result;\n }\n \n@@ -391,29 +376,42 @@ static ssize_t uv__fs_pathmax_size(const char* path) {\n }\n \n static ssize_t uv__fs_readlink(uv_fs_t* req) {\n+  ssize_t maxlen;\n   ssize_t len;\n   char* buf;\n+  char* newbuf;\n \n-  len = uv__fs_pathmax_size(req->path);\n-  buf = uv__malloc(len + 1);\n+  maxlen = uv__fs_pathmax_size(req->path);\n+  buf = uv__malloc(maxlen);\n \n   if (buf == NULL) {\n     errno = ENOMEM;\n     return -1;\n   }\n \n #if defined(__MVS__)\n-  len = os390_readlink(req->path, buf, len);\n+  len = os390_readlink(req->path, buf, maxlen);\n #else\n-  len = readlink(req->path, buf, len);\n+  len = readlink(req->path, buf, maxlen);\n #endif\n \n-\n   if (len == -1) {\n     uv__free(buf);\n     return -1;\n   }\n \n+  /* Uncommon case: resize to make room for the trailing nul byte. */\n+  if (len == maxlen) {\n+    newbuf = uv__realloc(buf, len + 1);\n+\n+    if (newbuf == NULL) {\n+      uv__free(buf);\n+      return -1;\n+    }\n+\n+    buf = newbuf;\n+  }\n+\n   buf[len] = '\\0';\n   req->ptr = buf;\n \n@@ -735,25 +733,7 @@ static ssize_t uv__fs_write(uv_fs_t* req) {\n     if (no_pwritev) retry:\n # endif\n     {\n-      off_t written;\n-      size_t index;\n-\n-      written = 0;\n-      index = 0;\n-      r = 0;\n-      do {\n-        if (req->bufs[index].len > 0) {\n-          r = pwrite(req->file,\n-                     req->bufs[index].base,\n-                     req->bufs[index].len,\n-                     req->off + written);\n-          if (r > 0)\n-            written += r;\n-        }\n-        index++;\n-      } while (index < req->nbufs && r >= 0);\n-      if (written > 0)\n-        r = written;\n+      r = pwrite(req->file, req->bufs[0].base, req->bufs[0].len, req->off);\n     }\n # if defined(__linux__)\n     else {\n@@ -1045,9 +1025,21 @@ static int uv__fs_fstat(int fd, uv_stat_t *buf) {\n   return ret;\n }\n \n+static size_t uv__fs_buf_offset(uv_buf_t* bufs, size_t size) {\n+  size_t offset;\n+  /* Figure out which bufs are done */\n+  for (offset = 0; size > 0 && bufs[offset].len <= size; ++offset)\n+    size -= bufs[offset].len;\n+\n+  /* Fix a partial read/write */\n+  if (size > 0) {\n+    bufs[offset].base += size;\n+    bufs[offset].len -= size;\n+  }\n+  return offset;\n+}\n \n-typedef ssize_t (*uv__fs_buf_iter_processor)(uv_fs_t* req);\n-static ssize_t uv__fs_buf_iter(uv_fs_t* req, uv__fs_buf_iter_processor process) {\n+static ssize_t uv__fs_write_all(uv_fs_t* req) {\n   unsigned int iovmax;\n   unsigned int nbufs;\n   uv_buf_t* bufs;\n@@ -1064,7 +1056,10 @@ static ssize_t uv__fs_buf_iter(uv_fs_t* req, uv__fs_buf_iter_processor process)\n     if (req->nbufs > iovmax)\n       req->nbufs = iovmax;\n \n-    result = process(req);\n+    do\n+      result = uv__fs_write(req);\n+    while (result < 0 && errno == EINTR);\n+\n     if (result <= 0) {\n       if (total == 0)\n         total = result;\n@@ -1074,14 +1069,12 @@ static ssize_t uv__fs_buf_iter(uv_fs_t* req, uv__fs_buf_iter_processor process)\n     if (req->off >= 0)\n       req->off += result;\n \n+    req->nbufs = uv__fs_buf_offset(req->bufs, result);\n     req->bufs += req->nbufs;\n     nbufs -= req->nbufs;\n     total += result;\n   }\n \n-  if (errno == EINTR && total == -1)\n-    return total;\n-\n   if (bufs != req->bufsml)\n     uv__free(bufs);\n \n@@ -1098,7 +1091,8 @@ static void uv__fs_work(struct uv__work* w) {\n   ssize_t r;\n \n   req = container_of(w, uv_fs_t, work_req);\n-  retry_on_eintr = !(req->fs_type == UV_FS_CLOSE);\n+  retry_on_eintr = !(req->fs_type == UV_FS_CLOSE ||\n+                     req->fs_type == UV_FS_READ);\n \n   do {\n     errno = 0;\n@@ -1127,7 +1121,7 @@ static void uv__fs_work(struct uv__work* w) {\n     X(MKDIR, mkdir(req->path, req->mode));\n     X(MKDTEMP, uv__fs_mkdtemp(req));\n     X(OPEN, uv__fs_open(req));\n-    X(READ, uv__fs_buf_iter(req, uv__fs_read));\n+    X(READ, uv__fs_read(req));\n     X(SCANDIR, uv__fs_scandir(req));\n     X(READLINK, uv__fs_readlink(req));\n     X(REALPATH, uv__fs_realpath(req));\n@@ -1138,7 +1132,7 @@ static void uv__fs_work(struct uv__work* w) {\n     X(SYMLINK, symlink(req->path, req->new_path));\n     X(UNLINK, unlink(req->path));\n     X(UTIME, uv__fs_utime(req));\n-    X(WRITE, uv__fs_buf_iter(req, uv__fs_write));\n+    X(WRITE, uv__fs_write_all(req));\n     default: abort();\n     }\n #undef X"
        },
        {
            "sha": "75362eb76d7f5d528a33b70ac72ecb4f2f466aac",
            "filename": "deps/uv/src/unix/linux-core.c",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Flinux-core.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Flinux-core.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Flinux-core.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -890,6 +890,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses,\n       continue;\n \n     address = *addresses;\n+    memset(address->phys_addr, 0, sizeof(address->phys_addr));\n \n     for (i = 0; i < (*count); i++) {\n       if (strcmp(address->name, ent->ifa_name) == 0) {"
        },
        {
            "sha": "65e9b7083036687cd3b0a7f1c35495f68508c7b4",
            "filename": "deps/uv/src/unix/os390.c",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Fos390.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Fos390.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fos390.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -512,7 +512,7 @@ static int uv__interface_addresses_v6(uv_interface_address_t** addresses,\n     /* TODO: Retrieve netmask using SIOCGIFNETMASK ioctl */\n \n     address->is_internal = flg.__nif6e_flags & _NIF6E_FLAGS_LOOPBACK ? 1 : 0;\n-\n+    memset(address->phys_addr, 0, sizeof(address->phys_addr));\n     address++;\n   }\n \n@@ -624,6 +624,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {\n     }\n \n     address->is_internal = flg.ifr_flags & IFF_LOOPBACK ? 1 : 0;\n+    memset(address->phys_addr, 0, sizeof(address->phys_addr));\n     address++;\n   }\n "
        },
        {
            "sha": "29004707a41947b17ca3714ab113a543aba7fa3e",
            "filename": "deps/uv/src/unix/thread.c",
            "status": "modified",
            "additions": 69,
            "deletions": 77,
            "changes": 146,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Fthread.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Funix%2Fthread.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fthread.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -44,108 +44,119 @@\n #undef NANOSEC\n #define NANOSEC ((uint64_t) 1e9)\n \n+#if defined(PTHREAD_BARRIER_SERIAL_THREAD)\n+STATIC_ASSERT(sizeof(uv_barrier_t) == sizeof(pthread_barrier_t));\n+#endif\n \n-#if defined(UV__PTHREAD_BARRIER_FALLBACK)\n-/* TODO: support barrier_attr */\n-int pthread_barrier_init(pthread_barrier_t* barrier,\n-                         const void* barrier_attr,\n-                         unsigned count) {\n+/* Note: guard clauses should match uv_barrier_t's in include/uv/uv-unix.h. */\n+#if defined(_AIX) || !defined(PTHREAD_BARRIER_SERIAL_THREAD)\n+int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {\n+  struct _uv_barrier* b;\n   int rc;\n-  _uv_barrier* b;\n \n   if (barrier == NULL || count == 0)\n-    return EINVAL;\n-\n-  if (barrier_attr != NULL)\n-    return ENOTSUP;\n+    return UV_EINVAL;\n \n   b = uv__malloc(sizeof(*b));\n   if (b == NULL)\n-    return ENOMEM;\n+    return UV_ENOMEM;\n \n   b->in = 0;\n   b->out = 0;\n   b->threshold = count;\n \n-  if ((rc = pthread_mutex_init(&b->mutex, NULL)) != 0)\n+  rc = uv_mutex_init(&b->mutex);\n+  if (rc != 0)\n     goto error2;\n-  if ((rc = pthread_cond_init(&b->cond, NULL)) != 0)\n+\n+  rc = uv_cond_init(&b->cond);\n+  if (rc != 0)\n     goto error;\n \n   barrier->b = b;\n   return 0;\n \n error:\n-  pthread_mutex_destroy(&b->mutex);\n+  uv_mutex_destroy(&b->mutex);\n error2:\n   uv__free(b);\n   return rc;\n }\n \n-int pthread_barrier_wait(pthread_barrier_t* barrier) {\n-  int rc;\n-  _uv_barrier* b;\n+\n+int uv_barrier_wait(uv_barrier_t* barrier) {\n+  struct _uv_barrier* b;\n+  int last;\n \n   if (barrier == NULL || barrier->b == NULL)\n-    return EINVAL;\n+    return UV_EINVAL;\n \n   b = barrier->b;\n-  /* Lock the mutex*/\n-  if ((rc = pthread_mutex_lock(&b->mutex)) != 0)\n-    return rc;\n+  uv_mutex_lock(&b->mutex);\n \n-  /* Increment the count. If this is the first thread to reach the threshold,\n-     wake up waiters, unlock the mutex, then return\n-     PTHREAD_BARRIER_SERIAL_THREAD. */\n   if (++b->in == b->threshold) {\n     b->in = 0;\n-    b->out = b->threshold - 1;\n-    rc = pthread_cond_signal(&b->cond);\n-    assert(rc == 0);\n-\n-    pthread_mutex_unlock(&b->mutex);\n-    return PTHREAD_BARRIER_SERIAL_THREAD;\n+    b->out = b->threshold;\n+    uv_cond_signal(&b->cond);\n+  } else {\n+    do\n+      uv_cond_wait(&b->cond, &b->mutex);\n+    while (b->in != 0);\n   }\n-  /* Otherwise, wait for other threads until in is set to 0,\n-     then return 0 to indicate this is not the first thread. */\n-  do {\n-    if ((rc = pthread_cond_wait(&b->cond, &b->mutex)) != 0)\n-      break;\n-  } while (b->in != 0);\n-\n-  /* mark thread exit */\n-  b->out--;\n-  pthread_cond_signal(&b->cond);\n-  pthread_mutex_unlock(&b->mutex);\n-  return rc;\n+\n+  last = (--b->out == 0);\n+  if (!last)\n+    uv_cond_signal(&b->cond);  /* Not needed for last thread. */\n+\n+  uv_mutex_unlock(&b->mutex);\n+  return last;\n }\n \n-int pthread_barrier_destroy(pthread_barrier_t* barrier) {\n-  int rc;\n-  _uv_barrier* b;\n \n-  if (barrier == NULL || barrier->b == NULL)\n-    return EINVAL;\n+void uv_barrier_destroy(uv_barrier_t* barrier) {\n+  struct _uv_barrier* b;\n \n   b = barrier->b;\n+  uv_mutex_lock(&b->mutex);\n \n-  if ((rc = pthread_mutex_lock(&b->mutex)) != 0)\n-    return rc;\n+  assert(b->in == 0);\n+  assert(b->out == 0);\n \n-  if (b->in > 0 || b->out > 0)\n-    rc = EBUSY;\n-\n-  pthread_mutex_unlock(&b->mutex);\n+  if (b->in != 0 || b->out != 0)\n+    abort();\n \n-  if (rc)\n-    return rc;\n+  uv_mutex_unlock(&b->mutex);\n+  uv_mutex_destroy(&b->mutex);\n+  uv_cond_destroy(&b->cond);\n \n-  pthread_cond_destroy(&b->cond);\n-  pthread_mutex_destroy(&b->mutex);\n   uv__free(barrier->b);\n   barrier->b = NULL;\n-  return 0;\n }\n+\n+#else\n+\n+int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {\n+  return UV__ERR(pthread_barrier_init(barrier, NULL, count));\n+}\n+\n+\n+int uv_barrier_wait(uv_barrier_t* barrier) {\n+  int rc;\n+\n+  rc = pthread_barrier_wait(barrier);\n+  if (rc != 0)\n+    if (rc != PTHREAD_BARRIER_SERIAL_THREAD)\n+      abort();\n+\n+  return rc == PTHREAD_BARRIER_SERIAL_THREAD;\n+}\n+\n+\n+void uv_barrier_destroy(uv_barrier_t* barrier) {\n+  if (pthread_barrier_destroy(barrier))\n+    abort();\n+}\n+\n #endif\n \n \n@@ -771,25 +782,6 @@ int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex, uint64_t timeout) {\n }\n \n \n-int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {\n-  return UV__ERR(pthread_barrier_init(barrier, NULL, count));\n-}\n-\n-\n-void uv_barrier_destroy(uv_barrier_t* barrier) {\n-  if (pthread_barrier_destroy(barrier))\n-    abort();\n-}\n-\n-\n-int uv_barrier_wait(uv_barrier_t* barrier) {\n-  int r = pthread_barrier_wait(barrier);\n-  if (r && r != PTHREAD_BARRIER_SERIAL_THREAD)\n-    abort();\n-  return r == PTHREAD_BARRIER_SERIAL_THREAD;\n-}\n-\n-\n int uv_key_create(uv_key_t* key) {\n   return UV__ERR(pthread_key_create(key, NULL));\n }"
        },
        {
            "sha": "25809ea4f2f605af7424b65328cbae24fa74a5aa",
            "filename": "deps/uv/src/win/fs-event.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Ffs-event.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Ffs-event.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ffs-event.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -83,7 +83,7 @@ static void uv_relative_path(const WCHAR* filename,\n static int uv_split_path(const WCHAR* filename, WCHAR** dir,\n     WCHAR** file) {\n   size_t len, i;\n- \n+\n   if (filename == NULL) {\n     if (dir != NULL)\n       *dir = NULL;"
        },
        {
            "sha": "812c1a6de583d26d42d5a992f4c1c7b04f8c69df",
            "filename": "deps/uv/src/win/fs.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -1517,10 +1517,10 @@ static void fs__fchmod(uv_fs_t* req) {\n     SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(nt_status));\n     goto fchmod_cleanup;\n   }\n- \n+\n   /* Test if the Archive attribute is cleared */\n   if ((file_info.FileAttributes & FILE_ATTRIBUTE_ARCHIVE) == 0) {\n-      /* Set Archive flag, otherwise setting or clearing the read-only \n+      /* Set Archive flag, otherwise setting or clearing the read-only\n          flag will not work */\n       file_info.FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;\n       nt_status = pNtSetInformationFile(handle,"
        },
        {
            "sha": "9a3cbc8a1e26e1dfcbf568216a6b77815f15a21c",
            "filename": "deps/uv/src/win/pipe.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -2347,7 +2347,7 @@ int uv_pipe_chmod(uv_pipe_t* handle, int mode) {\n     error = GetLastError();\n     goto clean_sid;\n   }\n- \n+\n   memset(&ea, 0, sizeof(EXPLICIT_ACCESS));\n   if (mode & UV_READABLE)\n     ea.grfAccessPermissions |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;"
        },
        {
            "sha": "111cc5e28936fc2d8a3511c5b1e3d356c4fcbdca",
            "filename": "deps/uv/src/win/req.c",
            "status": "removed",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/13340d47fcdbc9fa0eaaeee52d2c09338590a797/deps%2Fuv%2Fsrc%2Fwin%2Freq.c",
            "raw_url": "https://github.com/nodejs/node/raw/13340d47fcdbc9fa0eaaeee52d2c09338590a797/deps%2Fuv%2Fsrc%2Fwin%2Freq.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Freq.c?ref=13340d47fcdbc9fa0eaaeee52d2c09338590a797",
            "patch": "@@ -1,25 +0,0 @@\n-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to\n- * deal in the Software without restriction, including without limitation the\n- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n- * sell copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n- * IN THE SOFTWARE.\n- */\n-\n-#include <assert.h>\n-\n-#include \"uv.h\"\n-#include \"internal.h\""
        },
        {
            "sha": "56ca41aab0b759560a269abe478979489dbb5edb",
            "filename": "deps/uv/src/win/thread.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -118,7 +118,7 @@ int uv_thread_create(uv_thread_t *tid, void (*entry)(void *arg), void *arg) {\n   ctx->arg = arg;\n \n   /* Create the thread in suspended state so we have a chance to pass\n-   * its own creation handle to it */   \n+   * its own creation handle to it */\n   thread = (HANDLE) _beginthreadex(NULL,\n                                    0,\n                                    uv__thread_start,"
        },
        {
            "sha": "32ccf74ca8cb6aeb6adbc381b7c3e0c353320328",
            "filename": "deps/uv/src/win/tty.c",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -1033,6 +1033,7 @@ int uv_tty_read_stop(uv_tty_t* handle) {\n     /* Cancel raw read. Write some bullshit event to force the console wait to\n      * return. */\n     memset(&record, 0, sizeof record);\n+    record.EventType = FOCUS_EVENT;\n     if (!WriteConsoleInputW(handle->handle, &record, 1, &written)) {\n       return GetLastError();\n     }\n@@ -2179,14 +2180,14 @@ void uv_process_tty_write_req(uv_loop_t* loop, uv_tty_t* handle,\n \n void uv_tty_close(uv_tty_t* handle) {\n   assert(handle->u.fd == -1 || handle->u.fd > 2);\n+  if (handle->flags & UV_HANDLE_READING)\n+    uv_tty_read_stop(handle);\n+\n   if (handle->u.fd == -1)\n     CloseHandle(handle->handle);\n   else\n     close(handle->u.fd);\n \n-  if (handle->flags & UV_HANDLE_READING)\n-    uv_tty_read_stop(handle);\n-\n   handle->u.fd = -1;\n   handle->handle = INVALID_HANDLE_VALUE;\n   handle->flags &= ~(UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);"
        },
        {
            "sha": "aa52d7cc5aa9a696c3bd3d930b31d10b574a1903",
            "filename": "deps/uv/test/runner-win.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Frunner-win.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Frunner-win.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Frunner-win.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -228,7 +228,7 @@ int process_copy_output(process_info_t* p, FILE* stream) {\n \n   while (fgets(buf, sizeof(buf), f) != NULL)\n     print_lines(buf, strlen(buf), stream);\n-  \n+\n   if (ferror(f))\n     return -1;\n "
        },
        {
            "sha": "89858db5711482e4a20d2fb1dd7b1c3dd0e7a9e8",
            "filename": "deps/uv/test/test-barrier.c",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-barrier.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-barrier.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-barrier.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -104,3 +104,45 @@ TEST_IMPL(barrier_3) {\n \n   return 0;\n }\n+\n+static void serial_worker(void* data) {\n+  uv_barrier_t* barrier;\n+\n+  barrier = data;\n+  if (uv_barrier_wait(barrier) > 0)\n+    uv_barrier_destroy(barrier);\n+\n+  uv_sleep(100);  /* Wait a bit before terminating. */\n+}\n+\n+/* Ensure that uv_barrier_wait returns positive only after all threads have\n+ * exited the barrier. If this value is returned too early and the barrier is\n+ * destroyed prematurely, then this test may see a crash. */\n+TEST_IMPL(barrier_serial_thread) {\n+  uv_thread_t threads[4];\n+  uv_barrier_t barrier;\n+  unsigned i;\n+\n+  ASSERT(0 == uv_barrier_init(&barrier, ARRAY_SIZE(threads) + 1));\n+\n+  for (i = 0; i < ARRAY_SIZE(threads); ++i)\n+    ASSERT(0 == uv_thread_create(&threads[i], serial_worker, &barrier));\n+\n+  if (uv_barrier_wait(&barrier) > 0)\n+    uv_barrier_destroy(&barrier);\n+\n+  for (i = 0; i < ARRAY_SIZE(threads); ++i)\n+    ASSERT(0 == uv_thread_join(&threads[i]));\n+\n+  return 0;\n+}\n+\n+/* Single thread uv_barrier_wait should return correct return value. */\n+TEST_IMPL(barrier_serial_thread_single) {\n+  uv_barrier_t barrier;\n+\n+  ASSERT(0 == uv_barrier_init(&barrier, 1));\n+  ASSERT(0 < uv_barrier_wait(&barrier));\n+  uv_barrier_destroy(&barrier);\n+  return 0;\n+}"
        },
        {
            "sha": "01f5a7b023651490c113dc205cf20fac2a5af5e4",
            "filename": "deps/uv/test/test-fs.c",
            "status": "modified",
            "additions": 252,
            "deletions": 14,
            "changes": 266,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-fs.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-fs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fs.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -26,6 +26,7 @@\n #include <string.h> /* memset */\n #include <fcntl.h>\n #include <sys/stat.h>\n+#include <limits.h> /* INT_MAX, PATH_MAX, IOV_MAX */\n \n /* FIXME we shouldn't need to branch in this file */\n #if defined(__unix__) || defined(__POSIX__) || \\\n@@ -120,6 +121,31 @@ static char test_buf[] = \"test-buffer\\n\";\n static char test_buf2[] = \"second-buffer\\n\";\n static uv_buf_t iov;\n \n+#ifdef _WIN32\n+int uv_test_getiovmax(void) {\n+  return INT32_MAX; /* Emulated by libuv, so no real limit. */\n+}\n+#else\n+int uv_test_getiovmax(void) {\n+#if defined(IOV_MAX)\n+  return IOV_MAX;\n+#elif defined(_SC_IOV_MAX)\n+  static int iovmax = -1;\n+  if (iovmax == -1) {\n+    iovmax = sysconf(_SC_IOV_MAX);\n+    /* On some embedded devices (arm-linux-uclibc based ip camera),\n+     * sysconf(_SC_IOV_MAX) can not get the correct value. The return\n+     * value is -1 and the errno is EINPROGRESS. Degrade the value to 1.\n+     */\n+    if (iovmax == -1) iovmax = 1;\n+  }\n+  return iovmax;\n+#else\n+  return 1024;\n+#endif\n+}\n+#endif\n+\n #ifdef _WIN32\n /*\n  * This tag and guid have no special meaning, and don't conflict with\n@@ -2752,19 +2778,44 @@ TEST_IMPL(fs_write_multiple_bufs) {\n \n   memset(buf, 0, sizeof(buf));\n   memset(buf2, 0, sizeof(buf2));\n+  /* Read the strings back to separate buffers. */\n+  iovs[0] = uv_buf_init(buf, sizeof(test_buf));\n+  iovs[1] = uv_buf_init(buf2, sizeof(test_buf2));\n+  ASSERT(lseek(open_req1.result, 0, SEEK_CUR) == 0);\n+  r = uv_fs_read(NULL, &read_req, open_req1.result, iovs, 2, -1, NULL);\n+  ASSERT(r >= 0);\n+  ASSERT(read_req.result == sizeof(test_buf) + sizeof(test_buf2));\n+  ASSERT(strcmp(buf, test_buf) == 0);\n+  ASSERT(strcmp(buf2, test_buf2) == 0);\n+  uv_fs_req_cleanup(&read_req);\n+\n+  iov = uv_buf_init(buf, sizeof(buf));\n+  r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1, -1, NULL);\n+  ASSERT(r == 0);\n+  ASSERT(read_req.result == 0);\n+  uv_fs_req_cleanup(&read_req);\n+\n   /* Read the strings back to separate buffers. */\n   iovs[0] = uv_buf_init(buf, sizeof(test_buf));\n   iovs[1] = uv_buf_init(buf2, sizeof(test_buf2));\n   r = uv_fs_read(NULL, &read_req, open_req1.result, iovs, 2, 0, NULL);\n   ASSERT(r >= 0);\n-  ASSERT(read_req.result >= 0);\n+  if (read_req.result == sizeof(test_buf)) {\n+    /* Infer that preadv is not available. */\n+    uv_fs_req_cleanup(&read_req);\n+    r = uv_fs_read(NULL, &read_req, open_req1.result, &iovs[1], 1, read_req.result, NULL);\n+    ASSERT(r >= 0);\n+    ASSERT(read_req.result == sizeof(test_buf2));\n+  } else {\n+    ASSERT(read_req.result == sizeof(test_buf) + sizeof(test_buf2));\n+  }\n   ASSERT(strcmp(buf, test_buf) == 0);\n   ASSERT(strcmp(buf2, test_buf2) == 0);\n   uv_fs_req_cleanup(&read_req);\n \n   iov = uv_buf_init(buf, sizeof(buf));\n   r = uv_fs_read(NULL, &read_req, open_req1.result, &iov, 1,\n-                 read_req.result, NULL);\n+                 sizeof(test_buf) + sizeof(test_buf2), NULL);\n   ASSERT(r == 0);\n   ASSERT(read_req.result == 0);\n   uv_fs_req_cleanup(&read_req);\n@@ -2783,19 +2834,23 @@ TEST_IMPL(fs_write_multiple_bufs) {\n \n \n TEST_IMPL(fs_write_alotof_bufs) {\n-  const size_t iovcount = 54321;\n+  size_t iovcount;\n+  size_t iovmax;\n   uv_buf_t* iovs;\n   char* buffer;\n   size_t index;\n   int r;\n \n+  iovcount = 54321;\n+\n   /* Setup. */\n   unlink(\"test_file\");\n \n   loop = uv_default_loop();\n \n   iovs = malloc(sizeof(*iovs) * iovcount);\n   ASSERT(iovs != NULL);\n+  iovmax = uv_test_getiovmax();\n \n   r = uv_fs_open(NULL,\n                  &open_req1,\n@@ -2829,7 +2884,10 @@ TEST_IMPL(fs_write_alotof_bufs) {\n     iovs[index] = uv_buf_init(buffer + index * sizeof(test_buf),\n                               sizeof(test_buf));\n \n-  r = uv_fs_read(NULL, &read_req, open_req1.result, iovs, iovcount, 0, NULL);\n+  ASSERT(lseek(open_req1.result, 0, SEEK_SET) == 0);\n+  r = uv_fs_read(NULL, &read_req, open_req1.result, iovs, iovcount, -1, NULL);\n+  if (iovcount > iovmax)\n+    iovcount = iovmax;\n   ASSERT(r >= 0);\n   ASSERT((size_t)read_req.result == sizeof(test_buf) * iovcount);\n \n@@ -2841,13 +2899,14 @@ TEST_IMPL(fs_write_alotof_bufs) {\n   uv_fs_req_cleanup(&read_req);\n   free(buffer);\n \n+  ASSERT(lseek(open_req1.result, write_req.result, SEEK_SET) == write_req.result);\n   iov = uv_buf_init(buf, sizeof(buf));\n   r = uv_fs_read(NULL,\n                  &read_req,\n                  open_req1.result,\n                  &iov,\n                  1,\n-                 read_req.result,\n+                 -1,\n                  NULL);\n   ASSERT(r == 0);\n   ASSERT(read_req.result == 0);\n@@ -2868,14 +2927,19 @@ TEST_IMPL(fs_write_alotof_bufs) {\n \n \n TEST_IMPL(fs_write_alotof_bufs_with_offset) {\n-  const size_t iovcount = 54321;\n+  size_t iovcount;\n+  size_t iovmax;\n   uv_buf_t* iovs;\n   char* buffer;\n   size_t index;\n   int r;\n   int64_t offset;\n-  char* filler = \"0123456789\";\n-  int filler_len = strlen(filler);\n+  char* filler;\n+  int filler_len;\n+\n+  filler = \"0123456789\";\n+  filler_len = strlen(filler);\n+  iovcount = 54321;\n \n   /* Setup. */\n   unlink(\"test_file\");\n@@ -2884,6 +2948,7 @@ TEST_IMPL(fs_write_alotof_bufs_with_offset) {\n \n   iovs = malloc(sizeof(*iovs) * iovcount);\n   ASSERT(iovs != NULL);\n+  iovmax = uv_test_getiovmax();\n \n   r = uv_fs_open(NULL,\n                  &open_req1,\n@@ -2927,6 +2992,10 @@ TEST_IMPL(fs_write_alotof_bufs_with_offset) {\n   r = uv_fs_read(NULL, &read_req, open_req1.result,\n                  iovs, iovcount, offset, NULL);\n   ASSERT(r >= 0);\n+  if (r == sizeof(test_buf))\n+    iovcount = 1; /* Infer that preadv is not available. */\n+  else if (iovcount > iovmax)\n+    iovcount = iovmax;\n   ASSERT((size_t)read_req.result == sizeof(test_buf) * iovcount);\n \n   for (index = 0; index < iovcount; ++index)\n@@ -2940,7 +3009,7 @@ TEST_IMPL(fs_write_alotof_bufs_with_offset) {\n   r = uv_fs_stat(NULL, &stat_req, \"test_file\", NULL);\n   ASSERT(r == 0);\n   ASSERT((int64_t)((uv_stat_t*)stat_req.ptr)->st_size ==\n-         offset + (int64_t)(iovcount * sizeof(test_buf)));\n+         offset + (int64_t)write_req.result);\n   uv_fs_req_cleanup(&stat_req);\n \n   iov = uv_buf_init(buf, sizeof(buf));\n@@ -2949,7 +3018,7 @@ TEST_IMPL(fs_write_alotof_bufs_with_offset) {\n                  open_req1.result,\n                  &iov,\n                  1,\n-                 read_req.result + offset,\n+                 offset + write_req.result,\n                  NULL);\n   ASSERT(r == 0);\n   ASSERT(read_req.result == 0);\n@@ -2969,6 +3038,175 @@ TEST_IMPL(fs_write_alotof_bufs_with_offset) {\n }\n \n \n+#ifdef _WIN32\n+\n+TEST_IMPL(fs_partial_read) {\n+  RETURN_SKIP(\"Test not implemented on Windows.\");\n+}\n+\n+TEST_IMPL(fs_partial_write) {\n+  RETURN_SKIP(\"Test not implemented on Windows.\");\n+}\n+\n+#else  /* !_WIN32 */\n+\n+struct thread_ctx {\n+  pthread_t pid;\n+  int fd;\n+  char* data;\n+  int size;\n+  int interval;\n+  int doread;\n+};\n+\n+static void thread_main(void* arg) {\n+  const struct thread_ctx* ctx;\n+  int size;\n+  char* data;\n+\n+  ctx = (struct thread_ctx*)arg;\n+  size = ctx->size;\n+  data = ctx->data;\n+\n+  while (size > 0) {\n+    ssize_t result;\n+    int nbytes;\n+    nbytes = size < ctx->interval ? size : ctx->interval;\n+    if (ctx->doread) {\n+      result = write(ctx->fd, data, nbytes);\n+      /* Should not see EINTR (or other errors) */\n+      ASSERT(result == nbytes);\n+    } else {\n+      result = read(ctx->fd, data, nbytes);\n+      /* Should not see EINTR (or other errors),\n+       * but might get a partial read if we are faster than the writer\n+       */\n+      ASSERT(result > 0 && result <= nbytes);\n+    }\n+\n+    pthread_kill(ctx->pid, SIGUSR1);\n+    size -= result;\n+    data += result;\n+  }\n+}\n+\n+static void sig_func(uv_signal_t* handle, int signum) {\n+  uv_signal_stop(handle);\n+}\n+\n+static size_t uv_test_fs_buf_offset(uv_buf_t* bufs, size_t size) {\n+  size_t offset;\n+  /* Figure out which bufs are done */\n+  for (offset = 0; size > 0 && bufs[offset].len <= size; ++offset)\n+    size -= bufs[offset].len;\n+\n+  /* Fix a partial read/write */\n+  if (size > 0) {\n+    bufs[offset].base += size;\n+    bufs[offset].len -= size;\n+  }\n+  return offset;\n+}\n+\n+static void test_fs_partial(int doread) {\n+  struct thread_ctx ctx;\n+  uv_thread_t thread;\n+  uv_signal_t signal;\n+  int pipe_fds[2];\n+  size_t iovcount;\n+  uv_buf_t* iovs;\n+  char* buffer;\n+  size_t index;\n+\n+  iovcount = 54321;\n+\n+  iovs = malloc(sizeof(*iovs) * iovcount);\n+  ASSERT(iovs != NULL);\n+\n+  ctx.pid = pthread_self();\n+  ctx.doread = doread;\n+  ctx.interval = 1000;\n+  ctx.size = sizeof(test_buf) * iovcount;\n+  ctx.data = malloc(ctx.size);\n+  ASSERT(ctx.data != NULL);\n+  buffer = malloc(ctx.size);\n+  ASSERT(buffer != NULL);\n+\n+  for (index = 0; index < iovcount; ++index)\n+    iovs[index] = uv_buf_init(buffer + index * sizeof(test_buf), sizeof(test_buf));\n+\n+  loop = uv_default_loop();\n+\n+  ASSERT(0 == uv_signal_init(loop, &signal));\n+  ASSERT(0 == uv_signal_start(&signal, sig_func, SIGUSR1));\n+\n+  ASSERT(0 == pipe(pipe_fds));\n+\n+  ctx.fd = pipe_fds[doread];\n+  ASSERT(0 == uv_thread_create(&thread, thread_main, &ctx));\n+\n+  if (doread) {\n+    uv_buf_t* read_iovs;\n+    int nread;\n+    read_iovs = iovs;\n+    nread = 0;\n+    while (nread < ctx.size) {\n+      int result;\n+      result = uv_fs_read(loop, &read_req, pipe_fds[0], read_iovs, iovcount, -1, NULL);\n+      if (result > 0) {\n+        size_t read_iovcount;\n+        read_iovcount = uv_test_fs_buf_offset(read_iovs, result);\n+        read_iovs += read_iovcount;\n+        iovcount -= read_iovcount;\n+        nread += result;\n+      } else {\n+        ASSERT(result == UV_EINTR);\n+      }\n+      uv_fs_req_cleanup(&read_req);\n+    }\n+  } else {\n+    int result;\n+    result = uv_fs_write(loop, &write_req, pipe_fds[1], iovs, iovcount, -1, NULL);\n+    ASSERT(write_req.result == result);\n+    ASSERT(result == ctx.size);\n+    uv_fs_req_cleanup(&write_req);\n+  }\n+\n+  ASSERT(0 == memcmp(buffer, ctx.data, ctx.size));\n+\n+  ASSERT(0 == uv_thread_join(&thread));\n+  ASSERT(0 == uv_run(loop, UV_RUN_DEFAULT));\n+\n+  ASSERT(0 == close(pipe_fds[1]));\n+  uv_close((uv_handle_t*) &signal, NULL);\n+\n+  { /* Make sure we read everything that we wrote. */\n+      int result;\n+      result = uv_fs_read(loop, &read_req, pipe_fds[0], iovs, 1, -1, NULL);\n+      ASSERT(result == 0);\n+      uv_fs_req_cleanup(&read_req);\n+  }\n+  ASSERT(0 == close(pipe_fds[0]));\n+\n+  free(iovs);\n+  free(buffer);\n+  free(ctx.data);\n+\n+  MAKE_VALGRIND_HAPPY();\n+}\n+\n+TEST_IMPL(fs_partial_read) {\n+  test_fs_partial(1);\n+  return 0;\n+}\n+\n+TEST_IMPL(fs_partial_write) {\n+  test_fs_partial(0);\n+  return 0;\n+}\n+\n+#endif/* _WIN32 */\n+\n TEST_IMPL(fs_read_write_null_arguments) {\n   int r;\n \n@@ -3313,7 +3551,7 @@ TEST_IMPL(fs_exclusive_sharing_mode) {\n int call_icacls(const char* command, ...) {\n     char icacls_command[1024];\n     va_list args;\n-    \n+\n     va_start(args, command);\n     vsnprintf(icacls_command, ARRAYSIZE(icacls_command), command, args);\n     va_end(args);\n@@ -3335,7 +3573,7 @@ TEST_IMPL(fs_open_readonly_acl) {\n             attrib -r test_file_icacls\n             del test_file_icacls\n     */\n-    \n+\n     /* Setup - clear the ACL and remove the file */\n     loop = uv_default_loop();\n     r = uv_os_get_passwd(&pwd);\n@@ -3345,7 +3583,7 @@ TEST_IMPL(fs_open_readonly_acl) {\n     uv_fs_chmod(loop, &req, \"test_file_icacls\", S_IWUSR, NULL);\n     unlink(\"test_file_icacls\");\n \n-    /* Create the file */    \n+    /* Create the file */\n     r = uv_fs_open(loop,\n                    &open_req1,\n                    \"test_file_icacls\",\n@@ -3370,7 +3608,7 @@ TEST_IMPL(fs_open_readonly_acl) {\n     if (r != 0) {\n         goto acl_cleanup;\n     }\n-    \n+\n     /* Try opening the file */\n     r = uv_fs_open(NULL, &open_req1, \"test_file_icacls\", O_RDONLY, 0, NULL);\n     if (r < 0) {"
        },
        {
            "sha": "1bd062da3d2e4b9d03091cac033b5c291bf3e5e0",
            "filename": "deps/uv/test/test-list.h",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-list.h",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-list.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-list.h?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -37,6 +37,8 @@ TEST_DECLARE   (default_loop_close)\n TEST_DECLARE   (barrier_1)\n TEST_DECLARE   (barrier_2)\n TEST_DECLARE   (barrier_3)\n+TEST_DECLARE   (barrier_serial_thread)\n+TEST_DECLARE   (barrier_serial_thread_single)\n TEST_DECLARE   (condvar_1)\n TEST_DECLARE   (condvar_2)\n TEST_DECLARE   (condvar_3)\n@@ -50,6 +52,7 @@ TEST_DECLARE   (tty)\n TEST_DECLARE   (tty_raw)\n TEST_DECLARE   (tty_empty_write)\n TEST_DECLARE   (tty_large_write)\n+TEST_DECLARE   (tty_raw_cancel)\n #endif\n TEST_DECLARE   (tty_file)\n TEST_DECLARE   (tty_pty)\n@@ -339,6 +342,8 @@ TEST_DECLARE   (get_osfhandle_valid_handle)\n TEST_DECLARE   (open_osfhandle_valid_handle)\n TEST_DECLARE   (fs_write_alotof_bufs)\n TEST_DECLARE   (fs_write_alotof_bufs_with_offset)\n+TEST_DECLARE   (fs_partial_read)\n+TEST_DECLARE   (fs_partial_write)\n TEST_DECLARE   (fs_file_pos_after_op_with_offset)\n TEST_DECLARE   (fs_null_req)\n #ifdef _WIN32\n@@ -456,6 +461,8 @@ TASK_LIST_START\n   TEST_ENTRY  (barrier_1)\n   TEST_ENTRY  (barrier_2)\n   TEST_ENTRY  (barrier_3)\n+  TEST_ENTRY  (barrier_serial_thread)\n+  TEST_ENTRY  (barrier_serial_thread_single)\n   TEST_ENTRY  (condvar_1)\n   TEST_ENTRY  (condvar_2)\n   TEST_ENTRY  (condvar_3)\n@@ -480,6 +487,7 @@ TASK_LIST_START\n   TEST_ENTRY  (tty_raw)\n   TEST_ENTRY  (tty_empty_write)\n   TEST_ENTRY  (tty_large_write)\n+  TEST_ENTRY  (tty_raw_cancel)\n #endif\n   TEST_ENTRY  (tty_file)\n   TEST_ENTRY  (tty_pty)\n@@ -884,6 +892,8 @@ TASK_LIST_START\n   TEST_ENTRY  (fs_write_multiple_bufs)\n   TEST_ENTRY  (fs_write_alotof_bufs)\n   TEST_ENTRY  (fs_write_alotof_bufs_with_offset)\n+  TEST_ENTRY  (fs_partial_read)\n+  TEST_ENTRY  (fs_partial_write)\n   TEST_ENTRY  (fs_read_write_null_arguments)\n   TEST_ENTRY  (fs_file_pos_after_op_with_offset)\n   TEST_ENTRY  (fs_null_req)"
        },
        {
            "sha": "b3d0a85bdd70ec851c07815508404397c01ecb54",
            "filename": "deps/uv/test/test-process-priority.c",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-process-priority.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-process-priority.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-process-priority.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -54,8 +54,10 @@ TEST_IMPL(process_priority) {\n #ifndef _WIN32\n     ASSERT(priority == i);\n #else\n+    /* On Windows, only elevated users can set UV_PRIORITY_HIGHEST. Other\n+       users will silently be set to UV_PRIORITY_HIGH. */\n     if (i < UV_PRIORITY_HIGH)\n-      ASSERT(priority == UV_PRIORITY_HIGHEST);\n+      ASSERT(priority == UV_PRIORITY_HIGHEST || priority == UV_PRIORITY_HIGH);\n     else if (i < UV_PRIORITY_ABOVE_NORMAL)\n       ASSERT(priority == UV_PRIORITY_HIGH);\n     else if (i < UV_PRIORITY_NORMAL)"
        },
        {
            "sha": "979a6ec38d7fcd807070f3bc0d8771a8fe825576",
            "filename": "deps/uv/test/test-tty.c",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-tty.c",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Ftest%2Ftest-tty.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-tty.c?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -310,6 +310,41 @@ TEST_IMPL(tty_large_write) {\n   MAKE_VALGRIND_HAPPY();\n   return 0;\n }\n+\n+TEST_IMPL(tty_raw_cancel) {\n+  int r;\n+  int ttyin_fd;\n+  uv_tty_t tty_in;\n+  uv_loop_t* loop;\n+  HANDLE handle;\n+\n+  loop = uv_default_loop();\n+  /* Make sure we have an FD that refers to a tty */\n+  handle = CreateFileA(\"conin$\",\n+                       GENERIC_READ | GENERIC_WRITE,\n+                       FILE_SHARE_READ | FILE_SHARE_WRITE,\n+                       NULL,\n+                       OPEN_EXISTING,\n+                       FILE_ATTRIBUTE_NORMAL,\n+                       NULL);\n+  ASSERT(handle != INVALID_HANDLE_VALUE);\n+  ttyin_fd = _open_osfhandle((intptr_t) handle, 0);\n+  ASSERT(ttyin_fd >= 0);\n+  ASSERT(UV_TTY == uv_guess_handle(ttyin_fd));\n+\n+  r = uv_tty_init(uv_default_loop(), &tty_in, ttyin_fd, 1);  /* Readable. */\n+  ASSERT(r == 0);\n+  r = uv_tty_set_mode(&tty_in, UV_TTY_MODE_RAW);\n+  ASSERT(r == 0);\n+  r = uv_read_start((uv_stream_t*)&tty_in, tty_raw_alloc, tty_raw_read);\n+  ASSERT(r == 0);\n+\n+  r = uv_read_stop((uv_stream_t*) &tty_in);\n+  ASSERT(r == 0);\n+\n+  MAKE_VALGRIND_HAPPY();\n+  return 0;\n+}\n #endif\n \n "
        },
        {
            "sha": "5148a850ab4c155a3d32de67134588699aeb9736",
            "filename": "deps/uv/uv.gyp",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fuv.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/c65a523597ccdf2b3544244679dae581040cf52f/deps%2Fuv%2Fuv.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fuv.gyp?ref=c65a523597ccdf2b3544244679dae581040cf52f",
            "patch": "@@ -116,7 +116,6 @@\n             'src/win/poll.c',\n             'src/win/process.c',\n             'src/win/process-stdio.c',\n-            'src/win/req.c',\n             'src/win/req-inl.h',\n             'src/win/signal.c',\n             'src/win/snprintf.c',"
        }
    ],
    "stats": {
        "total": 842,
        "additions": 558,
        "deletions": 284
    }
}