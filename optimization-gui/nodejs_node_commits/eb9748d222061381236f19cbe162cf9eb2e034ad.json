{
    "author": "basti1302",
    "message": "async_hooks: add missing async_hooks destroys in AsyncReset\n\nThis adds missing async_hooks destroy calls for sockets (in\n_http_agent.js) and HTTP parsers. We need to emit a destroy in\nAsyncWrap#AsyncReset before assigning a new async_id when the instance\nhas already been in use and is being recycled, because in that case, we\nhave already emitted an init for the \"old\" async_id.\n\nThis also removes a duplicated init call for HTTP parser: Each time a\nnew parser was created, AsyncReset was being called via the C++ Parser\nclass constructor (super constructor AsyncWrap) and also via\nParser::Reinitialize.\n\nPR-URL: https://github.com/nodejs/node/pull/23272\nFixes: https://github.com/nodejs/node/issues/19859\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "eb9748d222061381236f19cbe162cf9eb2e034ad",
    "files": [
        {
            "sha": "8208df11223b9038c7f45f338bde59132ac7acf1",
            "filename": "benchmark/http/bench-parser.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/benchmark%2Fhttp%2Fbench-parser.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/benchmark%2Fhttp%2Fbench-parser.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fhttp%2Fbench-parser.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -25,7 +25,7 @@ function main({ len, n }) {\n     bench.start();\n     for (var i = 0; i < n; i++) {\n       parser.execute(header, 0, header.length);\n-      parser.reinitialize(REQUEST);\n+      parser.reinitialize(REQUEST, i > 0);\n     }\n     bench.end(n);\n   }"
        },
        {
            "sha": "7fa9af4f3ddb7f71925360c5edcc5850901828a2",
            "filename": "benchmark/misc/freelist.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/benchmark%2Fmisc%2Ffreelist.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/benchmark%2Fmisc%2Ffreelist.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Fmisc%2Ffreelist.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -9,7 +9,7 @@ const bench = common.createBenchmark(main, {\n });\n \n function main({ n }) {\n-  const FreeList = require('internal/freelist');\n+  const { FreeList } = require('internal/freelist');\n   const poolSize = 1000;\n   const list = new FreeList('test', poolSize, Object);\n   var j;"
        },
        {
            "sha": "97c5ab604ff821cd8870c581bf716c2e11fb1f33",
            "filename": "lib/_http_agent.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2F_http_agent.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2F_http_agent.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_http_agent.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -167,7 +167,7 @@ Agent.prototype.addRequest = function addRequest(req, options, port/* legacy */,\n     var socket = this.freeSockets[name].shift();\n     // Guard against an uninitialized or user supplied Socket.\n     if (socket._handle && typeof socket._handle.asyncReset === 'function') {\n-      // Assign the handle a new asyncId and run any init() hooks.\n+      // Assign the handle a new asyncId and run any destroy()/init() hooks.\n       socket._handle.asyncReset();\n       socket[async_id_symbol] = socket._handle.getAsyncId();\n     }"
        },
        {
            "sha": "d91b43516fa4ee2c51e4dc7036486faf8f95a606",
            "filename": "lib/_http_client.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2F_http_client.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2F_http_client.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_http_client.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -47,6 +47,7 @@ const {\n   ERR_UNESCAPED_CHARACTERS\n } = require('internal/errors').codes;\n const { validateTimerDuration } = require('internal/timers');\n+const is_reused_symbol = require('internal/freelist').symbols.is_reused_symbol;\n \n const INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\n \n@@ -631,7 +632,7 @@ function tickOnSocket(req, socket) {\n   var parser = parsers.alloc();\n   req.socket = socket;\n   req.connection = socket;\n-  parser.reinitialize(HTTPParser.RESPONSE);\n+  parser.reinitialize(HTTPParser.RESPONSE, parser[is_reused_symbol]);\n   parser.socket = socket;\n   parser.outgoing = req;\n   req.parser = parser;"
        },
        {
            "sha": "b37814f7832242d940cf7e7fe72f737b3f10f8e7",
            "filename": "lib/_http_common.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2F_http_common.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2F_http_common.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_http_common.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -23,7 +23,7 @@\n \n const { methods, HTTPParser } = internalBinding('http_parser');\n \n-const FreeList = require('internal/freelist');\n+const { FreeList } = require('internal/freelist');\n const { ondrain } = require('internal/http');\n const incoming = require('_http_incoming');\n const {"
        },
        {
            "sha": "3b2d7f5041912707d1bef929ba7387e525b0e930",
            "filename": "lib/_http_server.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2F_http_server.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2F_http_server.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_http_server.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -42,6 +42,7 @@ const {\n   defaultTriggerAsyncIdScope,\n   getOrSetAsyncId\n } = require('internal/async_hooks');\n+const is_reused_symbol = require('internal/freelist').symbols.is_reused_symbol;\n const { IncomingMessage } = require('_http_incoming');\n const {\n   ERR_HTTP_HEADERS_SENT,\n@@ -338,7 +339,7 @@ function connectionListenerInternal(server, socket) {\n   socket.on('timeout', socketOnTimeout);\n \n   var parser = parsers.alloc();\n-  parser.reinitialize(HTTPParser.REQUEST);\n+  parser.reinitialize(HTTPParser.REQUEST, parser[is_reused_symbol]);\n   parser.socket = socket;\n   socket.parser = parser;\n "
        },
        {
            "sha": "04d684e8334ff58a6c18fb176119bf770a89afb2",
            "filename": "lib/internal/freelist.js",
            "status": "modified",
            "additions": 17,
            "deletions": 4,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2Finternal%2Ffreelist.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/lib%2Finternal%2Ffreelist.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffreelist.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -1,5 +1,7 @@\n 'use strict';\n \n+const is_reused_symbol = Symbol('isReused');\n+\n class FreeList {\n   constructor(name, max, ctor) {\n     this.name = name;\n@@ -9,9 +11,15 @@ class FreeList {\n   }\n \n   alloc() {\n-    return this.list.length ?\n-      this.list.pop() :\n-      this.ctor.apply(this, arguments);\n+    let item;\n+    if (this.list.length > 0) {\n+      item = this.list.pop();\n+      item[is_reused_symbol] = true;\n+    } else {\n+      item = this.ctor.apply(this, arguments);\n+      item[is_reused_symbol] = false;\n+    }\n+    return item;\n   }\n \n   free(obj) {\n@@ -23,4 +31,9 @@ class FreeList {\n   }\n }\n \n-module.exports = FreeList;\n+module.exports = {\n+  FreeList,\n+  symbols: {\n+    is_reused_symbol\n+  }\n+};"
        },
        {
            "sha": "596fcc8356d5005ddafe36ca4d14c881c00f98bf",
            "filename": "src/async_wrap.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/src%2Fasync_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/src%2Fasync_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.cc?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -563,6 +563,7 @@ AsyncWrap::AsyncWrap(Environment* env,\n   CHECK_NE(provider, PROVIDER_NONE);\n   CHECK_GE(object->InternalFieldCount(), 1);\n \n+  async_id_ = -1;\n   // Use AsyncReset() call to execute the init() callbacks.\n   AsyncReset(execution_async_id, silent);\n }\n@@ -606,6 +607,14 @@ void AsyncWrap::EmitDestroy(Environment* env, double async_id) {\n // and reused over their lifetime. This way a new uid can be assigned when\n // the resource is pulled out of the pool and put back into use.\n void AsyncWrap::AsyncReset(double execution_async_id, bool silent) {\n+  if (async_id_ != -1) {\n+    // This instance was in use before, we have already emitted an init with\n+    // its previous async_id and need to emit a matching destroy for that\n+    // before generating a new async_id.\n+    EmitDestroy(env(), async_id_);\n+  }\n+\n+  // Now we can assign a new async_id_ to this instance.\n   async_id_ =\n     execution_async_id == -1 ? env()->new_async_id() : execution_async_id;\n   trigger_async_id_ = env()->get_default_trigger_async_id();"
        },
        {
            "sha": "9850b4f698205b6a89c43b7fec1ef77a43bc1b51",
            "filename": "src/node_http_parser.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/src%2Fnode_http_parser.cc",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/src%2Fnode_http_parser.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http_parser.cc?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -465,6 +465,8 @@ class Parser : public AsyncWrap, public StreamListener {\n     Environment* env = Environment::GetCurrent(args);\n \n     CHECK(args[0]->IsInt32());\n+    CHECK(args[1]->IsBoolean());\n+    bool isReused = args[1]->IsTrue();\n     http_parser_type type =\n         static_cast<http_parser_type>(args[0].As<Int32>()->Value());\n \n@@ -473,8 +475,12 @@ class Parser : public AsyncWrap, public StreamListener {\n     ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());\n     // Should always be called from the same context.\n     CHECK_EQ(env, parser->env());\n-    // The parser is being reused. Reset the async id and call init() callbacks.\n-    parser->AsyncReset();\n+    // This parser has either just been created or it is being reused.\n+    // We must only call AsyncReset for the latter case, because AsyncReset has\n+    // already been called via the constructor for the former case.\n+    if (isReused) {\n+      parser->AsyncReset();\n+    }\n     parser->Init(type);\n   }\n "
        },
        {
            "sha": "414ebabeeeaea48dae1b61ed9c735165fc8c405c",
            "filename": "test/async-hooks/test-graph.http.js",
            "status": "modified",
            "additions": 2,
            "deletions": 8,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fasync-hooks%2Ftest-graph.http.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fasync-hooks%2Ftest-graph.http.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fasync-hooks%2Ftest-graph.http.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -38,20 +38,14 @@ process.on('exit', function() {\n       { type: 'HTTPPARSER',\n         id: 'httpparser:1',\n         triggerAsyncId: 'tcpserver:1' },\n-      { type: 'HTTPPARSER',\n-        id: 'httpparser:2',\n-        triggerAsyncId: 'tcpserver:1' },\n       { type: 'TCPWRAP', id: 'tcp:2', triggerAsyncId: 'tcpserver:1' },\n       { type: 'Timeout', id: 'timeout:1', triggerAsyncId: 'tcp:2' },\n       { type: 'HTTPPARSER',\n-        id: 'httpparser:3',\n-        triggerAsyncId: 'tcp:2' },\n-      { type: 'HTTPPARSER',\n-        id: 'httpparser:4',\n+        id: 'httpparser:2',\n         triggerAsyncId: 'tcp:2' },\n       { type: 'Timeout',\n         id: 'timeout:2',\n-        triggerAsyncId: 'httpparser:4' },\n+        triggerAsyncId: 'httpparser:2' },\n       { type: 'SHUTDOWNWRAP',\n         id: 'shutdown:1',\n         triggerAsyncId: 'tcp:2' } ]"
        },
        {
            "sha": "637f2c511410e73bb8d667c4b4f2ba130e2813af",
            "filename": "test/parallel/test-async-hooks-http-agent-destroy.js",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-async-hooks-http-agent-destroy.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-async-hooks-http-agent-destroy.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-async-hooks-http-agent-destroy.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -0,0 +1,84 @@\n+'use strict';\n+// Flags: --expose-internals\n+const common = require('../common');\n+const assert = require('assert');\n+const { async_id_symbol } = require('internal/async_hooks').symbols;\n+const async_hooks = require('async_hooks');\n+const http = require('http');\n+\n+// Regression test for https://github.com/nodejs/node/issues/19859\n+// Checks that an http.Agent emits a destroy for the old asyncId before calling\n+// asyncReset()s when reusing a socket handle. The setup is nearly identical to\n+// parallel/test-async-hooks-http-agent (which focuses on the assertion that\n+// a fresh asyncId is assigned to the net.Socket instance).\n+\n+const destroyedIds = new Set();\n+async_hooks.createHook({\n+  destroy: common.mustCallAtLeast((asyncId) => {\n+    destroyedIds.add(asyncId);\n+  }, 1)\n+}).enable();\n+\n+// Make sure a single socket is transparently reused for 2 requests.\n+const agent = new http.Agent({\n+  keepAlive: true,\n+  keepAliveMsecs: Infinity,\n+  maxSockets: 1\n+});\n+\n+const server = http.createServer(common.mustCall((req, res) => {\n+  req.once('data', common.mustCallAtLeast(() => {\n+    res.writeHead(200, { 'Content-Type': 'text/plain' });\n+    res.write('foo');\n+  }));\n+  req.on('end', common.mustCall(() => {\n+    res.end('bar');\n+  }));\n+}, 2)).listen(0, common.mustCall(() => {\n+  const port = server.address().port;\n+  const payload = 'hello world';\n+\n+  // First request. This is useless except for adding a socket to the\n+  // agent’s pool for reuse.\n+  const r1 = http.request({\n+    agent, port, method: 'POST'\n+  }, common.mustCall((res) => {\n+    // Remember which socket we used.\n+    const socket = res.socket;\n+    const asyncIdAtFirstRequest = socket[async_id_symbol];\n+    assert.ok(asyncIdAtFirstRequest > 0, `${asyncIdAtFirstRequest} > 0`);\n+    // Check that request and response share their socket.\n+    assert.strictEqual(r1.socket, socket);\n+\n+    res.on('data', common.mustCallAtLeast(() => {}));\n+    res.on('end', common.mustCall(() => {\n+      // setImmediate() to give the agent time to register the freed socket.\n+      setImmediate(common.mustCall(() => {\n+        // The socket is free for reuse now.\n+        assert.strictEqual(socket[async_id_symbol], -1);\n+\n+        // second request:\n+        const r2 = http.request({\n+          agent, port, method: 'POST'\n+        }, common.mustCall((res) => {\n+          assert.ok(destroyedIds.has(asyncIdAtFirstRequest));\n+\n+          // Empty payload, to hit the “right” code path.\n+          r2.end('');\n+\n+          res.on('data', common.mustCallAtLeast(() => {}));\n+          res.on('end', common.mustCall(() => {\n+            // Clean up to let the event loop stop.\n+            server.close();\n+            agent.destroy();\n+          }));\n+        }));\n+\n+        // Schedule a payload to be written immediately, but do not end the\n+        // request just yet.\n+        r2.write(payload);\n+      }));\n+    }));\n+  }));\n+  r1.end(payload);\n+}));"
        },
        {
            "sha": "aeb805702d89e9d8a13af3eed314f49e0436ed0f",
            "filename": "test/parallel/test-async-hooks-http-parser-destroy.js",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-async-hooks-http-parser-destroy.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-async-hooks-http-parser-destroy.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-async-hooks-http-parser-destroy.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -0,0 +1,61 @@\n+'use strict';\n+const common = require('../common');\n+const Countdown = require('../common/countdown');\n+const assert = require('assert');\n+const async_hooks = require('async_hooks');\n+const http = require('http');\n+\n+// Regression test for https://github.com/nodejs/node/issues/19859.\n+// Checks that matching destroys are emitted when creating new/reusing old http\n+// parser instances.\n+\n+const N = 50;\n+const KEEP_ALIVE = 100;\n+\n+const createdIds = [];\n+const destroyedIds = [];\n+async_hooks.createHook({\n+  init: common.mustCallAtLeast((asyncId, type) => {\n+    if (type === 'HTTPPARSER') {\n+      createdIds.push(asyncId);\n+    }\n+  }, N),\n+  destroy: (asyncId) => {\n+    destroyedIds.push(asyncId);\n+  }\n+}).enable();\n+\n+const server = http.createServer(function(req, res) {\n+  res.end('Hello');\n+});\n+\n+const keepAliveAgent = new http.Agent({\n+  keepAlive: true,\n+  keepAliveMsecs: KEEP_ALIVE,\n+});\n+\n+const countdown = new Countdown(N, () => {\n+  server.close(() => {\n+    // give the server sockets time to close (which will also free their\n+    // associated parser objects) after the server has been closed.\n+    setTimeout(() => {\n+      createdIds.forEach((createdAsyncId) => {\n+        assert.ok(destroyedIds.indexOf(createdAsyncId) >= 0);\n+      });\n+    }, KEEP_ALIVE * 2);\n+  });\n+});\n+\n+server.listen(0, function() {\n+  for (let i = 0; i < N; ++i) {\n+    (function makeRequest() {\n+      http.get({\n+        port: server.address().port,\n+        agent: keepAliveAgent\n+      }, function(res) {\n+        countdown.dec();\n+        res.resume();\n+      });\n+    })();\n+  }\n+});"
        },
        {
            "sha": "03946dfda257c210f04b8b7a91af1bb2061c1977",
            "filename": "test/parallel/test-freelist.js",
            "status": "modified",
            "additions": 12,
            "deletions": 13,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-freelist.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-freelist.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-freelist.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -4,28 +4,27 @@\n \n require('../common');\n const assert = require('assert');\n-const FreeList = require('internal/freelist');\n+const { FreeList } = require('internal/freelist');\n \n assert.strictEqual(typeof FreeList, 'function');\n \n-const flist1 = new FreeList('flist1', 3, String);\n+const flist1 = new FreeList('flist1', 3, Object);\n \n // Allocating when empty, should not change the list size\n-const result = flist1.alloc('test');\n-assert.strictEqual(typeof result, 'string');\n-assert.strictEqual(result, 'test');\n+const result = flist1.alloc();\n+assert.strictEqual(typeof result, 'object');\n assert.strictEqual(flist1.list.length, 0);\n \n // Exhaust the free list\n-assert(flist1.free('test1'));\n-assert(flist1.free('test2'));\n-assert(flist1.free('test3'));\n+assert(flist1.free({ id: 'test1' }));\n+assert(flist1.free({ id: 'test2' }));\n+assert(flist1.free({ id: 'test3' }));\n \n // Now it should not return 'true', as max length is exceeded\n-assert.strictEqual(flist1.free('test4'), false);\n-assert.strictEqual(flist1.free('test5'), false);\n+assert.strictEqual(flist1.free({ id: 'test4' }), false);\n+assert.strictEqual(flist1.free({ id: 'test5' }), false);\n \n // At this point 'alloc' should just return the stored values\n-assert.strictEqual(flist1.alloc(), 'test3');\n-assert.strictEqual(flist1.alloc(), 'test2');\n-assert.strictEqual(flist1.alloc(), 'test1');\n+assert.strictEqual(flist1.alloc().id, 'test3');\n+assert.strictEqual(flist1.alloc().id, 'test2');\n+assert.strictEqual(flist1.alloc().id, 'test1');"
        },
        {
            "sha": "36f41f79e59dcfabe45eb093a97e0d7dbd20837d",
            "filename": "test/parallel/test-http-parser.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-http-parser.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-http-parser.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-parser.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -98,7 +98,7 @@ function expectBody(expected) {\n     throw new Error('hello world');\n   };\n \n-  parser.reinitialize(HTTPParser.REQUEST);\n+  parser.reinitialize(HTTPParser.REQUEST, false);\n \n   assert.throws(\n     () => { parser.execute(request, 0, request.length); },\n@@ -558,7 +558,7 @@ function expectBody(expected) {\n   parser[kOnBody] = expectBody('ping');\n   parser.execute(req1, 0, req1.length);\n \n-  parser.reinitialize(REQUEST);\n+  parser.reinitialize(REQUEST, false);\n   parser[kOnBody] = expectBody('pong');\n   parser[kOnHeadersComplete] = onHeadersComplete2;\n   parser.execute(req2, 0, req2.length);"
        },
        {
            "sha": "ab48e36881268c2ec8a830f1bfcf2f20e2ec6b2e",
            "filename": "test/parallel/test-internal-modules-expose.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-internal-modules-expose.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fparallel%2Ftest-internal-modules-expose.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-internal-modules-expose.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -7,5 +7,5 @@ const config = process.binding('config');\n \n console.log(config, process.argv);\n \n-assert.strictEqual(typeof require('internal/freelist'), 'function');\n+assert.strictEqual(typeof require('internal/freelist').FreeList, 'function');\n assert.strictEqual(config.exposeInternals, true);"
        },
        {
            "sha": "3794eddaa093695ef2e72b3270c08b74613bf802",
            "filename": "test/sequential/test-http-regr-gh-2928.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fsequential%2Ftest-http-regr-gh-2928.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb9748d222061381236f19cbe162cf9eb2e034ad/test%2Fsequential%2Ftest-http-regr-gh-2928.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-http-regr-gh-2928.js?ref=eb9748d222061381236f19cbe162cf9eb2e034ad",
            "patch": "@@ -7,6 +7,7 @@ const common = require('../common');\n const assert = require('assert');\n const httpCommon = require('_http_common');\n const { internalBinding } = require('internal/test/binding');\n+const is_reused_symbol = require('internal/freelist').symbols.is_reused_symbol;\n const { HTTPParser } = internalBinding('http_parser');\n const net = require('net');\n \n@@ -25,7 +26,7 @@ function execAndClose() {\n   process.stdout.write('.');\n \n   const parser = parsers.pop();\n-  parser.reinitialize(HTTPParser.RESPONSE);\n+  parser.reinitialize(HTTPParser.RESPONSE, parser[is_reused_symbol]);\n \n   const socket = net.connect(common.PORT);\n   socket.on('error', (e) => {"
        }
    ],
    "stats": {
        "total": 243,
        "additions": 206,
        "deletions": 37
    }
}