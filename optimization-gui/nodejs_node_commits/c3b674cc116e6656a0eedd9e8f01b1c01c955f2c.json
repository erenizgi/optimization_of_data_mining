{
    "author": "joyeecheung",
    "message": "lib: move module exports proxy into a separate method\n\nAlso added the comment in f074612b7 to make\nNativeModule.prototype.compile() more readable.\n\nPR-URL: https://github.com/nodejs/node/pull/24057\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "c3b674cc116e6656a0eedd9e8f01b1c01c955f2c",
    "files": [
        {
            "sha": "cd7a566fb1f9a3d2b150e7d9dfd424b38b6063ca",
            "filename": "lib/internal/bootstrap/loaders.js",
            "status": "modified",
            "additions": 59,
            "deletions": 51,
            "changes": 110,
            "blob_url": "https://github.com/nodejs/node/blob/c3b674cc116e6656a0eedd9e8f01b1c01c955f2c/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "raw_url": "https://github.com/nodejs/node/raw/c3b674cc116e6656a0eedd9e8f01b1c01c955f2c/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Floaders.js?ref=c3b674cc116e6656a0eedd9e8f01b1c01c955f2c",
            "patch": "@@ -235,6 +235,64 @@\n       undefined;\n   };\n \n+  // Provide named exports for all builtin libraries so that the libraries\n+  // may be imported in a nicer way for esm users. The default export is left\n+  // as the entire namespace (module.exports) and wrapped in a proxy such\n+  // that APMs and other behavior are still left intact.\n+  NativeModule.prototype.proxifyExports = function() {\n+    this.exportKeys = ObjectKeys(this.exports);\n+\n+    const update = (property, value) => {\n+      if (this.reflect !== undefined &&\n+          ReflectApply(ObjectHasOwnProperty,\n+                       this.reflect.exports, [property]))\n+        this.reflect.exports[property].set(value);\n+    };\n+\n+    const handler = {\n+      __proto__: null,\n+      defineProperty: (target, prop, descriptor) => {\n+        // Use `Object.defineProperty` instead of `Reflect.defineProperty`\n+        // to throw the appropriate error if something goes wrong.\n+        ObjectDefineProperty(target, prop, descriptor);\n+        if (typeof descriptor.get === 'function' &&\n+            !ReflectHas(handler, 'get')) {\n+          handler.get = (target, prop, receiver) => {\n+            const value = ReflectGet(target, prop, receiver);\n+            if (ReflectApply(ObjectHasOwnProperty, target, [prop]))\n+              update(prop, value);\n+            return value;\n+          };\n+        }\n+        update(prop, getOwn(target, prop));\n+        return true;\n+      },\n+      deleteProperty: (target, prop) => {\n+        if (ReflectDeleteProperty(target, prop)) {\n+          update(prop, undefined);\n+          return true;\n+        }\n+        return false;\n+      },\n+      set: (target, prop, value, receiver) => {\n+        const descriptor = ReflectGetOwnPropertyDescriptor(target, prop);\n+        if (ReflectSet(target, prop, value, receiver)) {\n+          if (descriptor && typeof descriptor.set === 'function') {\n+            for (const key of this.exportKeys) {\n+              update(key, getOwn(target, key, receiver));\n+            }\n+          } else {\n+            update(prop, getOwn(target, prop, receiver));\n+          }\n+          return true;\n+        }\n+        return false;\n+      }\n+    };\n+\n+    this.exports = new Proxy(this.exports, handler);\n+  };\n+\n   NativeModule.prototype.compile = function() {\n     const id = this.id;\n     let source = NativeModule.getSource(id);\n@@ -299,57 +357,7 @@\n       fn(this.exports, requireFn, this, process, internalBinding);\n \n       if (config.experimentalModules && !NativeModule.isInternal(this.id)) {\n-        this.exportKeys = ObjectKeys(this.exports);\n-\n-        const update = (property, value) => {\n-          if (this.reflect !== undefined &&\n-              ReflectApply(ObjectHasOwnProperty,\n-                           this.reflect.exports, [property]))\n-            this.reflect.exports[property].set(value);\n-        };\n-\n-        const handler = {\n-          __proto__: null,\n-          defineProperty: (target, prop, descriptor) => {\n-            // Use `Object.defineProperty` instead of `Reflect.defineProperty`\n-            // to throw the appropriate error if something goes wrong.\n-            ObjectDefineProperty(target, prop, descriptor);\n-            if (typeof descriptor.get === 'function' &&\n-                !ReflectHas(handler, 'get')) {\n-              handler.get = (target, prop, receiver) => {\n-                const value = ReflectGet(target, prop, receiver);\n-                if (ReflectApply(ObjectHasOwnProperty, target, [prop]))\n-                  update(prop, value);\n-                return value;\n-              };\n-            }\n-            update(prop, getOwn(target, prop));\n-            return true;\n-          },\n-          deleteProperty: (target, prop) => {\n-            if (ReflectDeleteProperty(target, prop)) {\n-              update(prop, undefined);\n-              return true;\n-            }\n-            return false;\n-          },\n-          set: (target, prop, value, receiver) => {\n-            const descriptor = ReflectGetOwnPropertyDescriptor(target, prop);\n-            if (ReflectSet(target, prop, value, receiver)) {\n-              if (descriptor && typeof descriptor.set === 'function') {\n-                for (const key of this.exportKeys) {\n-                  update(key, getOwn(target, key, receiver));\n-                }\n-              } else {\n-                update(prop, getOwn(target, prop, receiver));\n-              }\n-              return true;\n-            }\n-            return false;\n-          }\n-        };\n-\n-        this.exports = new Proxy(this.exports, handler);\n+        this.proxifyExports();\n       }\n \n       this.loaded = true;"
        }
    ],
    "stats": {
        "total": 110,
        "additions": 59,
        "deletions": 51
    }
}