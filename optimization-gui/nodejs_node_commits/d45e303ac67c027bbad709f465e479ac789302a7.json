{
    "author": "mhdawson",
    "message": "n-api: handle reference delete before finalize\n\nCrashes were reported during finalization due to\nthe memory for a reference being deleted and the\nfinalizer running after the deletion.\n\nThis change ensures the deletion of the memory for\nthe reference only occurs after the finalizer has run.\n\nFixes: https://github.com/nodejs/node-addon-api/issues/393\n\nPR-URL: https://github.com/nodejs/node/pull/24494\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Franziska Hinkelmann <franziska.hinkelmann@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "d45e303ac67c027bbad709f465e479ac789302a7",
    "files": [
        {
            "sha": "6b8d3f91056823305fa60d7ddd8fbd6bb9601f0a",
            "filename": "src/js_native_api_v8.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 5,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/d45e303ac67c027bbad709f465e479ac789302a7/src%2Fjs_native_api_v8.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d45e303ac67c027bbad709f465e479ac789302a7/src%2Fjs_native_api_v8.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_native_api_v8.cc?ref=d45e303ac67c027bbad709f465e479ac789302a7",
            "patch": "@@ -227,8 +227,29 @@ class Reference : private Finalizer {\n       finalize_hint);\n   }\n \n+  // Delete is called in 2 ways. Either from the finalizer or\n+  // from one of Unwrap or napi_delete_reference.\n+  //\n+  // When it is called from Unwrap or napi_delete_reference we only\n+  // want to do the delete if the finalizer has already run,\n+  // otherwise we may crash when the finalizer does run.\n+  // If the finalizer has not already run delay the delete until\n+  // the finalizer runs by not doing the delete\n+  // and setting _delete_self to true so that the finalizer will\n+  // delete it when it runs.\n+  //\n+  // The second way this is called is from\n+  // the finalizer and _delete_self is set. In this case we\n+  // know we need to do the deletion so just do it.\n   static void Delete(Reference* reference) {\n-    delete reference;\n+    if ((reference->_delete_self) || (reference->_finalize_ran)) {\n+      delete reference;\n+    } else {\n+      // reduce the reference count to 0 and defer until\n+      // finalizer runs\n+      reference->_delete_self = true;\n+      while (reference->Unref() != 0) {}\n+    }\n   }\n \n   uint32_t Ref() {\n@@ -268,9 +289,6 @@ class Reference : private Finalizer {\n     Reference* reference = data.GetParameter();\n     reference->_persistent.Reset();\n \n-    // Check before calling the finalize callback, because the callback might\n-    // delete it.\n-    bool delete_self = reference->_delete_self;\n     napi_env env = reference->_env;\n \n     if (reference->_finalize_callback != nullptr) {\n@@ -281,8 +299,13 @@ class Reference : private Finalizer {\n             reference->_finalize_hint));\n     }\n \n-    if (delete_self) {\n+    // this is safe because if a request to delete the reference\n+    // is made in the finalize_callback it will defer deletion\n+    // to this block and set _delete_self to true\n+    if (reference->_delete_self) {\n       Delete(reference);\n+    } else {\n+      reference->_finalize_ran = true;\n     }\n   }\n "
        },
        {
            "sha": "81b00f2aa59b8f3a3d5e0b2326b4a1727d0ac53d",
            "filename": "src/js_native_api_v8.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/d45e303ac67c027bbad709f465e479ac789302a7/src%2Fjs_native_api_v8.h",
            "raw_url": "https://github.com/nodejs/node/raw/d45e303ac67c027bbad709f465e479ac789302a7/src%2Fjs_native_api_v8.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_native_api_v8.h?ref=d45e303ac67c027bbad709f465e479ac789302a7",
            "patch": "@@ -180,6 +180,7 @@ class Finalizer {\n   napi_finalize _finalize_callback;\n   void* _finalize_data;\n   void* _finalize_hint;\n+  bool _finalize_ran = false;\n };\n \n class TryCatch : public v8::TryCatch {"
        },
        {
            "sha": "389ee11d7e5f5bc3be6e62b7e8f0bbf0c3428cbe",
            "filename": "test/addons-napi/test_reference/test.js",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/d45e303ac67c027bbad709f465e479ac789302a7/test%2Faddons-napi%2Ftest_reference%2Ftest.js",
            "raw_url": "https://github.com/nodejs/node/raw/d45e303ac67c027bbad709f465e479ac789302a7/test%2Faddons-napi%2Ftest_reference%2Ftest.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2Ftest_reference%2Ftest.js?ref=d45e303ac67c027bbad709f465e479ac789302a7",
            "patch": "@@ -118,3 +118,29 @@ runTests(0, undefined, [\n     assert.strictEqual(test_reference.finalizeCount, 1);\n   },\n ]);\n+\n+// This test creates a napi_ref on an object that has\n+// been wrapped by napi_wrap and for which the finalizer\n+// for the wrap calls napi_delete_ref on that napi_ref.\n+//\n+// Since both the wrap and the reference use the same\n+// object the finalizer for the wrap and reference\n+// may run in the same gc and in any order.\n+//\n+// It does that to validate that napi_delete_ref can be\n+// called before the finalizer has been run for the\n+// reference (there is a finalizer behind the scenes even\n+// though it cannot be passed to napi_create_reference).\n+//\n+// Since the order is not guarranteed, run the\n+// test a number of times maximize the chance that we\n+// get a run with the desired order for the test.\n+//\n+// 1000 reliably recreated the problem without the fix\n+// required to ensure delete could be called before\n+// the finalizer in manual testing.\n+for (let i = 0; i < 1000; i++) {\n+  const wrapObject = new Object();\n+  test_reference.validateDeleteBeforeFinalize(wrapObject);\n+  global.gc();\n+}"
        },
        {
            "sha": "f3dc3644770ab0f87aca19adaa3c4667c3e99578",
            "filename": "test/addons-napi/test_reference/test_reference.c",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/d45e303ac67c027bbad709f465e479ac789302a7/test%2Faddons-napi%2Ftest_reference%2Ftest_reference.c",
            "raw_url": "https://github.com/nodejs/node/raw/d45e303ac67c027bbad709f465e479ac789302a7/test%2Faddons-napi%2Ftest_reference%2Ftest_reference.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2Ftest_reference%2Ftest_reference.c?ref=d45e303ac67c027bbad709f465e479ac789302a7",
            "patch": "@@ -1,3 +1,4 @@\n+#include <stdlib.h>\n #include <node_api.h>\n #include \"../common.h\"\n \n@@ -131,6 +132,39 @@ static napi_value GetReferenceValue(napi_env env, napi_callback_info info) {\n   return result;\n }\n \n+static void DeleteBeforeFinalizeFinalizer(\n+    napi_env env, void* finalize_data, void* finalize_hint) {\n+  napi_ref* ref = (napi_ref*)finalize_data;\n+  napi_delete_reference(env, *ref);\n+  free(ref);\n+}\n+\n+static napi_value ValidateDeleteBeforeFinalize(napi_env env, napi_callback_info info) {\n+  napi_value wrapObject;\n+  size_t argc = 1;\n+  NAPI_CALL(env, napi_get_cb_info(env, info, &argc, &wrapObject, NULL, NULL));\n+\n+  napi_ref* ref_t = malloc(sizeof(napi_ref));\n+  NAPI_CALL(env, napi_wrap(env,\n+\t\t\t   wrapObject,\n+\t\t\t   ref_t,\n+\t\t\t   DeleteBeforeFinalizeFinalizer,\n+\t\t\t   NULL,\n+\t\t\t   NULL));\n+\n+  // Create a reference that will be eligible for collection at the same\n+  // time as the wrapped object by passing in the same wrapObject.\n+  // This means that the FinalizeOrderValidation callback may be run\n+  // before the finalizer for the newly created reference (there is a finalizer\n+  // behind the scenes even though it cannot be passed to napi_create_reference)\n+  // The Finalizer for the wrap (which is different than the finalizer\n+  // for the reference) calls napi_delete_reference validating that\n+  // napi_delete_reference can be called before the finalizer for the\n+  // reference runs.\n+  NAPI_CALL(env, napi_create_reference(env, wrapObject, 0, ref_t));\n+  return wrapObject;\n+}\n+\n static napi_value Init(napi_env env, napi_value exports) {\n   napi_property_descriptor descriptors[] = {\n     DECLARE_NAPI_GETTER(\"finalizeCount\", GetFinalizeCount),\n@@ -143,6 +177,8 @@ static napi_value Init(napi_env env, napi_value exports) {\n     DECLARE_NAPI_PROPERTY(\"incrementRefcount\", IncrementRefcount),\n     DECLARE_NAPI_PROPERTY(\"decrementRefcount\", DecrementRefcount),\n     DECLARE_NAPI_GETTER(\"referenceValue\", GetReferenceValue),\n+    DECLARE_NAPI_PROPERTY(\"validateDeleteBeforeFinalize\",\n+\t\t          ValidateDeleteBeforeFinalize),\n   };\n \n   NAPI_CALL(env, napi_define_properties("
        }
    ],
    "stats": {
        "total": 96,
        "additions": 91,
        "deletions": 5
    }
}