{
    "author": "shigeki",
    "message": "deps: copy all openssl header files to include dir\n\nAll symlink files in `deps/openssl/openssl/include/openssl/`\nare removed and replaced with real header files to avoid\nissues on Windows. Two files of opensslconf.h in crypto and\ninclude dir are replaced to refer config/opensslconf.h.\n\nPR-URL: https://github.com/nodejs/node/pull/19638\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>\nReviewed-By: Rod Vagg <rod@vagg.org>",
    "sha": "a5bd474573d411eb5346eabdeba40c729dc21279",
    "files": [
        {
            "sha": "76c99d433ab886d1dc1990213b8765e25415da00",
            "filename": "deps/openssl/openssl/crypto/opensslconf.h",
            "status": "modified",
            "additions": 1,
            "deletions": 265,
            "changes": 266,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Fcrypto%2Fopensslconf.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Fcrypto%2Fopensslconf.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Fcrypto%2Fopensslconf.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -1,265 +1 @@\n-/* opensslconf.h */\n-/* WARNING: Generated automatically from opensslconf.h.in by Configure. */\n-\n-#ifdef  __cplusplus\n-extern \"C\" {\n-#endif\n-/* OpenSSL was configured with the following options: */\n-#ifndef OPENSSL_DOING_MAKEDEPEND\n-\n-\n-#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n-# define OPENSSL_NO_EC_NISTP_64_GCC_128\n-#endif\n-#ifndef OPENSSL_NO_GMP\n-# define OPENSSL_NO_GMP\n-#endif\n-#ifndef OPENSSL_NO_JPAKE\n-# define OPENSSL_NO_JPAKE\n-#endif\n-#ifndef OPENSSL_NO_KRB5\n-# define OPENSSL_NO_KRB5\n-#endif\n-#ifndef OPENSSL_NO_LIBUNBOUND\n-# define OPENSSL_NO_LIBUNBOUND\n-#endif\n-#ifndef OPENSSL_NO_MD2\n-# define OPENSSL_NO_MD2\n-#endif\n-#ifndef OPENSSL_NO_RC5\n-# define OPENSSL_NO_RC5\n-#endif\n-#ifndef OPENSSL_NO_RFC3779\n-# define OPENSSL_NO_RFC3779\n-#endif\n-#ifndef OPENSSL_NO_SCTP\n-# define OPENSSL_NO_SCTP\n-#endif\n-#ifndef OPENSSL_NO_SSL_TRACE\n-# define OPENSSL_NO_SSL_TRACE\n-#endif\n-#ifndef OPENSSL_NO_SSL2\n-# define OPENSSL_NO_SSL2\n-#endif\n-#ifndef OPENSSL_NO_STORE\n-# define OPENSSL_NO_STORE\n-#endif\n-#ifndef OPENSSL_NO_UNIT_TEST\n-# define OPENSSL_NO_UNIT_TEST\n-#endif\n-#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS\n-# define OPENSSL_NO_WEAK_SSL_CIPHERS\n-#endif\n-\n-#endif /* OPENSSL_DOING_MAKEDEPEND */\n-\n-#ifndef OPENSSL_NO_DYNAMIC_ENGINE\n-# define OPENSSL_NO_DYNAMIC_ENGINE\n-#endif\n-\n-/* The OPENSSL_NO_* macros are also defined as NO_* if the application\n-   asks for it.  This is a transient feature that is provided for those\n-   who haven't had the time to do the appropriate changes in their\n-   applications.  */\n-#ifdef OPENSSL_ALGORITHM_DEFINES\n-# if defined(OPENSSL_NO_EC_NISTP_64_GCC_128) && !defined(NO_EC_NISTP_64_GCC_128)\n-#  define NO_EC_NISTP_64_GCC_128\n-# endif\n-# if defined(OPENSSL_NO_GMP) && !defined(NO_GMP)\n-#  define NO_GMP\n-# endif\n-# if defined(OPENSSL_NO_JPAKE) && !defined(NO_JPAKE)\n-#  define NO_JPAKE\n-# endif\n-# if defined(OPENSSL_NO_KRB5) && !defined(NO_KRB5)\n-#  define NO_KRB5\n-# endif\n-# if defined(OPENSSL_NO_LIBUNBOUND) && !defined(NO_LIBUNBOUND)\n-#  define NO_LIBUNBOUND\n-# endif\n-# if defined(OPENSSL_NO_MD2) && !defined(NO_MD2)\n-#  define NO_MD2\n-# endif\n-# if defined(OPENSSL_NO_RC5) && !defined(NO_RC5)\n-#  define NO_RC5\n-# endif\n-# if defined(OPENSSL_NO_RFC3779) && !defined(NO_RFC3779)\n-#  define NO_RFC3779\n-# endif\n-# if defined(OPENSSL_NO_SCTP) && !defined(NO_SCTP)\n-#  define NO_SCTP\n-# endif\n-# if defined(OPENSSL_NO_SSL_TRACE) && !defined(NO_SSL_TRACE)\n-#  define NO_SSL_TRACE\n-# endif\n-# if defined(OPENSSL_NO_SSL2) && !defined(NO_SSL2)\n-#  define NO_SSL2\n-# endif\n-# if defined(OPENSSL_NO_STORE) && !defined(NO_STORE)\n-#  define NO_STORE\n-# endif\n-# if defined(OPENSSL_NO_UNIT_TEST) && !defined(NO_UNIT_TEST)\n-#  define NO_UNIT_TEST\n-# endif\n-# if defined(OPENSSL_NO_WEAK_SSL_CIPHERS) && !defined(NO_WEAK_SSL_CIPHERS)\n-#  define NO_WEAK_SSL_CIPHERS\n-# endif\n-#endif\n-\n-/* crypto/opensslconf.h.in */\n-\n-/* Generate 80386 code? */\n-#undef I386_ONLY\n-\n-#if !(defined(VMS) || defined(__VMS)) /* VMS uses logical names instead */\n-#if defined(HEADER_CRYPTLIB_H) && !defined(OPENSSLDIR)\n-#define ENGINESDIR \"/usr/local/ssl/lib/engines\"\n-#define OPENSSLDIR \"/usr/local/ssl\"\n-#endif\n-#endif\n-\n-#undef OPENSSL_UNISTD\n-#define OPENSSL_UNISTD <unistd.h>\n-\n-#undef OPENSSL_EXPORT_VAR_AS_FUNCTION\n-\n-#if defined(HEADER_IDEA_H) && !defined(IDEA_INT)\n-#define IDEA_INT unsigned int\n-#endif\n-\n-#if defined(HEADER_MD2_H) && !defined(MD2_INT)\n-#define MD2_INT unsigned int\n-#endif\n-\n-#if defined(HEADER_RC2_H) && !defined(RC2_INT)\n-/* I need to put in a mod for the alpha - eay */\n-#define RC2_INT unsigned int\n-#endif\n-\n-#if defined(HEADER_RC4_H)\n-#if !defined(RC4_INT)\n-/* using int types make the structure larger but make the code faster\n- * on most boxes I have tested - up to %20 faster. */\n-/*\n- * I don't know what does \"most\" mean, but declaring \"int\" is a must on:\n- * - Intel P6 because partial register stalls are very expensive;\n- * - elder Alpha because it lacks byte load/store instructions;\n- */\n-#define RC4_INT unsigned int\n-#endif\n-#if !defined(RC4_CHUNK)\n-/*\n- * This enables code handling data aligned at natural CPU word\n- * boundary. See crypto/rc4/rc4_enc.c for further details.\n- */\n-#undef RC4_CHUNK\n-#endif\n-#endif\n-\n-#if (defined(HEADER_NEW_DES_H) || defined(HEADER_DES_H)) && !defined(DES_LONG)\n-/* If this is set to 'unsigned int' on a DEC Alpha, this gives about a\n- * %20 speed up (longs are 8 bytes, int's are 4). */\n-#ifndef DES_LONG\n-#define DES_LONG unsigned long\n-#endif\n-#endif\n-\n-#if defined(HEADER_BN_H) && !defined(CONFIG_HEADER_BN_H)\n-#define CONFIG_HEADER_BN_H\n-#undef BN_LLONG\n-\n-/* Should we define BN_DIV2W here? */\n-\n-/* Only one for the following should be defined */\n-#undef SIXTY_FOUR_BIT_LONG\n-#undef SIXTY_FOUR_BIT\n-#define THIRTY_TWO_BIT\n-#endif\n-\n-#if defined(HEADER_RC4_LOCL_H) && !defined(CONFIG_HEADER_RC4_LOCL_H)\n-#define CONFIG_HEADER_RC4_LOCL_H\n-/* if this is defined data[i] is used instead of *data, this is a %20\n- * speedup on x86 */\n-#undef RC4_INDEX\n-#endif\n-\n-#if defined(HEADER_BF_LOCL_H) && !defined(CONFIG_HEADER_BF_LOCL_H)\n-#define CONFIG_HEADER_BF_LOCL_H\n-#undef BF_PTR\n-#endif /* HEADER_BF_LOCL_H */\n-\n-#if defined(HEADER_DES_LOCL_H) && !defined(CONFIG_HEADER_DES_LOCL_H)\n-#define CONFIG_HEADER_DES_LOCL_H\n-#ifndef DES_DEFAULT_OPTIONS\n-/* the following is tweaked from a config script, that is why it is a\n- * protected undef/define */\n-#ifndef DES_PTR\n-#undef DES_PTR\n-#endif\n-\n-/* This helps C compiler generate the correct code for multiple functional\n- * units.  It reduces register dependancies at the expense of 2 more\n- * registers */\n-#ifndef DES_RISC1\n-#undef DES_RISC1\n-#endif\n-\n-#ifndef DES_RISC2\n-#undef DES_RISC2\n-#endif\n-\n-#if defined(DES_RISC1) && defined(DES_RISC2)\n-#error YOU SHOULD NOT HAVE BOTH DES_RISC1 AND DES_RISC2 DEFINED!!!!!\n-#endif\n-\n-/* Unroll the inner loop, this sometimes helps, sometimes hinders.\n- * Very mucy CPU dependant */\n-#ifndef DES_UNROLL\n-#undef DES_UNROLL\n-#endif\n-\n-/* These default values were supplied by\n- * Peter Gutman <pgut001@cs.auckland.ac.nz>\n- * They are only used if nothing else has been defined */\n-#if !defined(DES_PTR) && !defined(DES_RISC1) && !defined(DES_RISC2) && !defined(DES_UNROLL)\n-/* Special defines which change the way the code is built depending on the\n-   CPU and OS.  For SGI machines you can use _MIPS_SZLONG (32 or 64) to find\n-   even newer MIPS CPU's, but at the moment one size fits all for\n-   optimization options.  Older Sparc's work better with only UNROLL, but\n-   there's no way to tell at compile time what it is you're running on */\n- \n-#if defined( __sun ) || defined ( sun )\t\t/* Newer Sparc's */\n-#  define DES_PTR\n-#  define DES_RISC1\n-#  define DES_UNROLL\n-#elif defined( __ultrix )\t/* Older MIPS */\n-#  define DES_PTR\n-#  define DES_RISC2\n-#  define DES_UNROLL\n-#elif defined( __osf1__ )\t/* Alpha */\n-#  define DES_PTR\n-#  define DES_RISC2\n-#elif defined ( _AIX )\t\t/* RS6000 */\n-  /* Unknown */\n-#elif defined( __hpux )\t\t/* HP-PA */\n-  /* Unknown */\n-#elif defined( __aux )\t\t/* 68K */\n-  /* Unknown */\n-#elif defined( __dgux )\t\t/* 88K (but P6 in latest boxes) */\n-#  define DES_UNROLL\n-#elif defined( __sgi )\t\t/* Newer MIPS */\n-#  define DES_PTR\n-#  define DES_RISC2\n-#  define DES_UNROLL\n-#elif defined(i386) || defined(__i386__)\t/* x86 boxes, should be gcc */\n-#  define DES_PTR\n-#  define DES_RISC1\n-#  define DES_UNROLL\n-#endif /* Systems-specific speed defines */\n-#endif\n-\n-#endif /* DES_DEFAULT_OPTIONS */\n-#endif /* HEADER_DES_LOCL_H */\n-#ifdef  __cplusplus\n-}\n-#endif\n+#include \"../../config/opensslconf.h\""
        },
        {
            "sha": "faa66c49148f50f7854464091ded0f05136c3f59",
            "filename": "deps/openssl/openssl/include/openssl/aes.h",
            "status": "added",
            "additions": 149,
            "deletions": 0,
            "changes": 149,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Faes.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Faes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Faes.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,149 @@\n+/* crypto/aes/aes.h */\n+/* ====================================================================\n+ * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ */\n+\n+#ifndef HEADER_AES_H\n+# define HEADER_AES_H\n+\n+# include <openssl/opensslconf.h>\n+\n+# ifdef OPENSSL_NO_AES\n+#  error AES is disabled.\n+# endif\n+\n+# include <stddef.h>\n+\n+# define AES_ENCRYPT     1\n+# define AES_DECRYPT     0\n+\n+/*\n+ * Because array size can't be a const in C, the following two are macros.\n+ * Both sizes are in bytes.\n+ */\n+# define AES_MAXNR 14\n+# define AES_BLOCK_SIZE 16\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This should be a hidden type, but EVP requires that the size be known */\n+struct aes_key_st {\n+# ifdef AES_LONG\n+    unsigned long rd_key[4 * (AES_MAXNR + 1)];\n+# else\n+    unsigned int rd_key[4 * (AES_MAXNR + 1)];\n+# endif\n+    int rounds;\n+};\n+typedef struct aes_key_st AES_KEY;\n+\n+const char *AES_options(void);\n+\n+int AES_set_encrypt_key(const unsigned char *userKey, const int bits,\n+                        AES_KEY *key);\n+int AES_set_decrypt_key(const unsigned char *userKey, const int bits,\n+                        AES_KEY *key);\n+\n+int private_AES_set_encrypt_key(const unsigned char *userKey, const int bits,\n+                                AES_KEY *key);\n+int private_AES_set_decrypt_key(const unsigned char *userKey, const int bits,\n+                                AES_KEY *key);\n+\n+void AES_encrypt(const unsigned char *in, unsigned char *out,\n+                 const AES_KEY *key);\n+void AES_decrypt(const unsigned char *in, unsigned char *out,\n+                 const AES_KEY *key);\n+\n+void AES_ecb_encrypt(const unsigned char *in, unsigned char *out,\n+                     const AES_KEY *key, const int enc);\n+void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,\n+                     size_t length, const AES_KEY *key,\n+                     unsigned char *ivec, const int enc);\n+void AES_cfb128_encrypt(const unsigned char *in, unsigned char *out,\n+                        size_t length, const AES_KEY *key,\n+                        unsigned char *ivec, int *num, const int enc);\n+void AES_cfb1_encrypt(const unsigned char *in, unsigned char *out,\n+                      size_t length, const AES_KEY *key,\n+                      unsigned char *ivec, int *num, const int enc);\n+void AES_cfb8_encrypt(const unsigned char *in, unsigned char *out,\n+                      size_t length, const AES_KEY *key,\n+                      unsigned char *ivec, int *num, const int enc);\n+void AES_ofb128_encrypt(const unsigned char *in, unsigned char *out,\n+                        size_t length, const AES_KEY *key,\n+                        unsigned char *ivec, int *num);\n+void AES_ctr128_encrypt(const unsigned char *in, unsigned char *out,\n+                        size_t length, const AES_KEY *key,\n+                        unsigned char ivec[AES_BLOCK_SIZE],\n+                        unsigned char ecount_buf[AES_BLOCK_SIZE],\n+                        unsigned int *num);\n+/* NB: the IV is _two_ blocks long */\n+void AES_ige_encrypt(const unsigned char *in, unsigned char *out,\n+                     size_t length, const AES_KEY *key,\n+                     unsigned char *ivec, const int enc);\n+/* NB: the IV is _four_ blocks long */\n+void AES_bi_ige_encrypt(const unsigned char *in, unsigned char *out,\n+                        size_t length, const AES_KEY *key,\n+                        const AES_KEY *key2, const unsigned char *ivec,\n+                        const int enc);\n+\n+int AES_wrap_key(AES_KEY *key, const unsigned char *iv,\n+                 unsigned char *out,\n+                 const unsigned char *in, unsigned int inlen);\n+int AES_unwrap_key(AES_KEY *key, const unsigned char *iv,\n+                   unsigned char *out,\n+                   const unsigned char *in, unsigned int inlen);\n+\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif                          /* !HEADER_AES_H */"
        },
        {
            "sha": "35a2b2aa02381145d7827557ab4473c7db009c95",
            "filename": "deps/openssl/openssl/include/openssl/asn1.h",
            "status": "added",
            "additions": 1420,
            "deletions": 0,
            "changes": 1420,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fasn1.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fasn1.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fasn1.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,1420 @@\n+/* crypto/asn1/asn1.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_ASN1_H\n+# define HEADER_ASN1_H\n+\n+# include <time.h>\n+# include <openssl/e_os2.h>\n+# ifndef OPENSSL_NO_BIO\n+#  include <openssl/bio.h>\n+# endif\n+# include <openssl/stack.h>\n+# include <openssl/safestack.h>\n+\n+# include <openssl/symhacks.h>\n+\n+# include <openssl/ossl_typ.h>\n+# ifndef OPENSSL_NO_DEPRECATED\n+#  include <openssl/bn.h>\n+# endif\n+\n+# ifdef OPENSSL_BUILD_SHLIBCRYPTO\n+#  undef OPENSSL_EXTERN\n+#  define OPENSSL_EXTERN OPENSSL_EXPORT\n+# endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# define V_ASN1_UNIVERSAL                0x00\n+# define V_ASN1_APPLICATION              0x40\n+# define V_ASN1_CONTEXT_SPECIFIC         0x80\n+# define V_ASN1_PRIVATE                  0xc0\n+\n+# define V_ASN1_CONSTRUCTED              0x20\n+# define V_ASN1_PRIMITIVE_TAG            0x1f\n+# define V_ASN1_PRIMATIVE_TAG            0x1f\n+\n+# define V_ASN1_APP_CHOOSE               -2/* let the recipient choose */\n+# define V_ASN1_OTHER                    -3/* used in ASN1_TYPE */\n+# define V_ASN1_ANY                      -4/* used in ASN1 template code */\n+\n+# define V_ASN1_NEG                      0x100/* negative flag */\n+\n+# define V_ASN1_UNDEF                    -1\n+# define V_ASN1_EOC                      0\n+# define V_ASN1_BOOLEAN                  1 /**/\n+# define V_ASN1_INTEGER                  2\n+# define V_ASN1_NEG_INTEGER              (2 | V_ASN1_NEG)\n+# define V_ASN1_BIT_STRING               3\n+# define V_ASN1_OCTET_STRING             4\n+# define V_ASN1_NULL                     5\n+# define V_ASN1_OBJECT                   6\n+# define V_ASN1_OBJECT_DESCRIPTOR        7\n+# define V_ASN1_EXTERNAL                 8\n+# define V_ASN1_REAL                     9\n+# define V_ASN1_ENUMERATED               10\n+# define V_ASN1_NEG_ENUMERATED           (10 | V_ASN1_NEG)\n+# define V_ASN1_UTF8STRING               12\n+# define V_ASN1_SEQUENCE                 16\n+# define V_ASN1_SET                      17\n+# define V_ASN1_NUMERICSTRING            18 /**/\n+# define V_ASN1_PRINTABLESTRING          19\n+# define V_ASN1_T61STRING                20\n+# define V_ASN1_TELETEXSTRING            20/* alias */\n+# define V_ASN1_VIDEOTEXSTRING           21 /**/\n+# define V_ASN1_IA5STRING                22\n+# define V_ASN1_UTCTIME                  23\n+# define V_ASN1_GENERALIZEDTIME          24 /**/\n+# define V_ASN1_GRAPHICSTRING            25 /**/\n+# define V_ASN1_ISO64STRING              26 /**/\n+# define V_ASN1_VISIBLESTRING            26/* alias */\n+# define V_ASN1_GENERALSTRING            27 /**/\n+# define V_ASN1_UNIVERSALSTRING          28 /**/\n+# define V_ASN1_BMPSTRING                30\n+/* For use with d2i_ASN1_type_bytes() */\n+# define B_ASN1_NUMERICSTRING    0x0001\n+# define B_ASN1_PRINTABLESTRING  0x0002\n+# define B_ASN1_T61STRING        0x0004\n+# define B_ASN1_TELETEXSTRING    0x0004\n+# define B_ASN1_VIDEOTEXSTRING   0x0008\n+# define B_ASN1_IA5STRING        0x0010\n+# define B_ASN1_GRAPHICSTRING    0x0020\n+# define B_ASN1_ISO64STRING      0x0040\n+# define B_ASN1_VISIBLESTRING    0x0040\n+# define B_ASN1_GENERALSTRING    0x0080\n+# define B_ASN1_UNIVERSALSTRING  0x0100\n+# define B_ASN1_OCTET_STRING     0x0200\n+# define B_ASN1_BIT_STRING       0x0400\n+# define B_ASN1_BMPSTRING        0x0800\n+# define B_ASN1_UNKNOWN          0x1000\n+# define B_ASN1_UTF8STRING       0x2000\n+# define B_ASN1_UTCTIME          0x4000\n+# define B_ASN1_GENERALIZEDTIME  0x8000\n+# define B_ASN1_SEQUENCE         0x10000\n+/* For use with ASN1_mbstring_copy() */\n+# define MBSTRING_FLAG           0x1000\n+# define MBSTRING_UTF8           (MBSTRING_FLAG)\n+# define MBSTRING_ASC            (MBSTRING_FLAG|1)\n+# define MBSTRING_BMP            (MBSTRING_FLAG|2)\n+# define MBSTRING_UNIV           (MBSTRING_FLAG|4)\n+# define SMIME_OLDMIME           0x400\n+# define SMIME_CRLFEOL           0x800\n+# define SMIME_STREAM            0x1000\n+    struct X509_algor_st;\n+DECLARE_STACK_OF(X509_ALGOR)\n+\n+# define DECLARE_ASN1_SET_OF(type)/* filled in by mkstack.pl */\n+# define IMPLEMENT_ASN1_SET_OF(type)/* nothing, no longer needed */\n+\n+/*\n+ * We MUST make sure that, except for constness, asn1_ctx_st and\n+ * asn1_const_ctx are exactly the same.  Fortunately, as soon as the old ASN1\n+ * parsing macros are gone, we can throw this away as well...\n+ */\n+typedef struct asn1_ctx_st {\n+    unsigned char *p;           /* work char pointer */\n+    int eos;                    /* end of sequence read for indefinite\n+                                 * encoding */\n+    int error;                  /* error code to use when returning an error */\n+    int inf;                    /* constructed if 0x20, indefinite is 0x21 */\n+    int tag;                    /* tag from last 'get object' */\n+    int xclass;                 /* class from last 'get object' */\n+    long slen;                  /* length of last 'get object' */\n+    unsigned char *max;         /* largest value of p allowed */\n+    unsigned char *q;           /* temporary variable */\n+    unsigned char **pp;         /* variable */\n+    int line;                   /* used in error processing */\n+} ASN1_CTX;\n+\n+typedef struct asn1_const_ctx_st {\n+    const unsigned char *p;     /* work char pointer */\n+    int eos;                    /* end of sequence read for indefinite\n+                                 * encoding */\n+    int error;                  /* error code to use when returning an error */\n+    int inf;                    /* constructed if 0x20, indefinite is 0x21 */\n+    int tag;                    /* tag from last 'get object' */\n+    int xclass;                 /* class from last 'get object' */\n+    long slen;                  /* length of last 'get object' */\n+    const unsigned char *max;   /* largest value of p allowed */\n+    const unsigned char *q;     /* temporary variable */\n+    const unsigned char **pp;   /* variable */\n+    int line;                   /* used in error processing */\n+} ASN1_const_CTX;\n+\n+/*\n+ * These are used internally in the ASN1_OBJECT to keep track of whether the\n+ * names and data need to be free()ed\n+ */\n+# define ASN1_OBJECT_FLAG_DYNAMIC         0x01/* internal use */\n+# define ASN1_OBJECT_FLAG_CRITICAL        0x02/* critical x509v3 object id */\n+# define ASN1_OBJECT_FLAG_DYNAMIC_STRINGS 0x04/* internal use */\n+# define ASN1_OBJECT_FLAG_DYNAMIC_DATA    0x08/* internal use */\n+struct asn1_object_st {\n+    const char *sn, *ln;\n+    int nid;\n+    int length;\n+    const unsigned char *data;  /* data remains const after init */\n+    int flags;                  /* Should we free this one */\n+};\n+\n+# define ASN1_STRING_FLAG_BITS_LEFT 0x08/* Set if 0x07 has bits left value */\n+/*\n+ * This indicates that the ASN1_STRING is not a real value but just a place\n+ * holder for the location where indefinite length constructed data should be\n+ * inserted in the memory buffer\n+ */\n+# define ASN1_STRING_FLAG_NDEF 0x010\n+\n+/*\n+ * This flag is used by the CMS code to indicate that a string is not\n+ * complete and is a place holder for content when it had all been accessed.\n+ * The flag will be reset when content has been written to it.\n+ */\n+\n+# define ASN1_STRING_FLAG_CONT 0x020\n+/*\n+ * This flag is used by ASN1 code to indicate an ASN1_STRING is an MSTRING\n+ * type.\n+ */\n+# define ASN1_STRING_FLAG_MSTRING 0x040\n+/* This is the base type that holds just about everything :-) */\n+struct asn1_string_st {\n+    int length;\n+    int type;\n+    unsigned char *data;\n+    /*\n+     * The value of the following field depends on the type being held.  It\n+     * is mostly being used for BIT_STRING so if the input data has a\n+     * non-zero 'unused bits' value, it will be handled correctly\n+     */\n+    long flags;\n+};\n+\n+/*\n+ * ASN1_ENCODING structure: this is used to save the received encoding of an\n+ * ASN1 type. This is useful to get round problems with invalid encodings\n+ * which can break signatures.\n+ */\n+\n+typedef struct ASN1_ENCODING_st {\n+    unsigned char *enc;         /* DER encoding */\n+    long len;                   /* Length of encoding */\n+    int modified;               /* set to 1 if 'enc' is invalid */\n+} ASN1_ENCODING;\n+\n+/* Used with ASN1 LONG type: if a long is set to this it is omitted */\n+# define ASN1_LONG_UNDEF 0x7fffffffL\n+\n+# define STABLE_FLAGS_MALLOC     0x01\n+# define STABLE_NO_MASK          0x02\n+# define DIRSTRING_TYPE  \\\n+ (B_ASN1_PRINTABLESTRING|B_ASN1_T61STRING|B_ASN1_BMPSTRING|B_ASN1_UTF8STRING)\n+# define PKCS9STRING_TYPE (DIRSTRING_TYPE|B_ASN1_IA5STRING)\n+\n+typedef struct asn1_string_table_st {\n+    int nid;\n+    long minsize;\n+    long maxsize;\n+    unsigned long mask;\n+    unsigned long flags;\n+} ASN1_STRING_TABLE;\n+\n+DECLARE_STACK_OF(ASN1_STRING_TABLE)\n+\n+/* size limits: this stuff is taken straight from RFC2459 */\n+\n+# define ub_name                         32768\n+# define ub_common_name                  64\n+# define ub_locality_name                128\n+# define ub_state_name                   128\n+# define ub_organization_name            64\n+# define ub_organization_unit_name       64\n+# define ub_title                        64\n+# define ub_email_address                128\n+\n+/*\n+ * Declarations for template structures: for full definitions see asn1t.h\n+ */\n+typedef struct ASN1_TEMPLATE_st ASN1_TEMPLATE;\n+typedef struct ASN1_TLC_st ASN1_TLC;\n+/* This is just an opaque pointer */\n+typedef struct ASN1_VALUE_st ASN1_VALUE;\n+\n+/* Declare ASN1 functions: the implement macro in in asn1t.h */\n+\n+# define DECLARE_ASN1_FUNCTIONS(type) DECLARE_ASN1_FUNCTIONS_name(type, type)\n+\n+# define DECLARE_ASN1_ALLOC_FUNCTIONS(type) \\\n+        DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, type)\n+\n+# define DECLARE_ASN1_FUNCTIONS_name(type, name) \\\n+        DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, name) \\\n+        DECLARE_ASN1_ENCODE_FUNCTIONS(type, name, name)\n+\n+# define DECLARE_ASN1_FUNCTIONS_fname(type, itname, name) \\\n+        DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, name) \\\n+        DECLARE_ASN1_ENCODE_FUNCTIONS(type, itname, name)\n+\n+# define DECLARE_ASN1_ENCODE_FUNCTIONS(type, itname, name) \\\n+        type *d2i_##name(type **a, const unsigned char **in, long len); \\\n+        int i2d_##name(type *a, unsigned char **out); \\\n+        DECLARE_ASN1_ITEM(itname)\n+\n+# define DECLARE_ASN1_ENCODE_FUNCTIONS_const(type, name) \\\n+        type *d2i_##name(type **a, const unsigned char **in, long len); \\\n+        int i2d_##name(const type *a, unsigned char **out); \\\n+        DECLARE_ASN1_ITEM(name)\n+\n+# define DECLARE_ASN1_NDEF_FUNCTION(name) \\\n+        int i2d_##name##_NDEF(name *a, unsigned char **out);\n+\n+# define DECLARE_ASN1_FUNCTIONS_const(name) \\\n+        DECLARE_ASN1_ALLOC_FUNCTIONS(name) \\\n+        DECLARE_ASN1_ENCODE_FUNCTIONS_const(name, name)\n+\n+# define DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, name) \\\n+        type *name##_new(void); \\\n+        void name##_free(type *a);\n+\n+# define DECLARE_ASN1_PRINT_FUNCTION(stname) \\\n+        DECLARE_ASN1_PRINT_FUNCTION_fname(stname, stname)\n+\n+# define DECLARE_ASN1_PRINT_FUNCTION_fname(stname, fname) \\\n+        int fname##_print_ctx(BIO *out, stname *x, int indent, \\\n+                                         const ASN1_PCTX *pctx);\n+\n+# define D2I_OF(type) type *(*)(type **,const unsigned char **,long)\n+# define I2D_OF(type) int (*)(type *,unsigned char **)\n+# define I2D_OF_const(type) int (*)(const type *,unsigned char **)\n+\n+# define CHECKED_D2I_OF(type, d2i) \\\n+    ((d2i_of_void*) (1 ? d2i : ((D2I_OF(type))0)))\n+# define CHECKED_I2D_OF(type, i2d) \\\n+    ((i2d_of_void*) (1 ? i2d : ((I2D_OF(type))0)))\n+# define CHECKED_NEW_OF(type, xnew) \\\n+    ((void *(*)(void)) (1 ? xnew : ((type *(*)(void))0)))\n+# define CHECKED_PTR_OF(type, p) \\\n+    ((void*) (1 ? p : (type*)0))\n+# define CHECKED_PPTR_OF(type, p) \\\n+    ((void**) (1 ? p : (type**)0))\n+\n+# define TYPEDEF_D2I_OF(type) typedef type *d2i_of_##type(type **,const unsigned char **,long)\n+# define TYPEDEF_I2D_OF(type) typedef int i2d_of_##type(type *,unsigned char **)\n+# define TYPEDEF_D2I2D_OF(type) TYPEDEF_D2I_OF(type); TYPEDEF_I2D_OF(type)\n+\n+TYPEDEF_D2I2D_OF(void);\n+\n+/*-\n+ * The following macros and typedefs allow an ASN1_ITEM\n+ * to be embedded in a structure and referenced. Since\n+ * the ASN1_ITEM pointers need to be globally accessible\n+ * (possibly from shared libraries) they may exist in\n+ * different forms. On platforms that support it the\n+ * ASN1_ITEM structure itself will be globally exported.\n+ * Other platforms will export a function that returns\n+ * an ASN1_ITEM pointer.\n+ *\n+ * To handle both cases transparently the macros below\n+ * should be used instead of hard coding an ASN1_ITEM\n+ * pointer in a structure.\n+ *\n+ * The structure will look like this:\n+ *\n+ * typedef struct SOMETHING_st {\n+ *      ...\n+ *      ASN1_ITEM_EXP *iptr;\n+ *      ...\n+ * } SOMETHING;\n+ *\n+ * It would be initialised as e.g.:\n+ *\n+ * SOMETHING somevar = {...,ASN1_ITEM_ref(X509),...};\n+ *\n+ * and the actual pointer extracted with:\n+ *\n+ * const ASN1_ITEM *it = ASN1_ITEM_ptr(somevar.iptr);\n+ *\n+ * Finally an ASN1_ITEM pointer can be extracted from an\n+ * appropriate reference with: ASN1_ITEM_rptr(X509). This\n+ * would be used when a function takes an ASN1_ITEM * argument.\n+ *\n+ */\n+\n+# ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION\n+\n+/* ASN1_ITEM pointer exported type */\n+typedef const ASN1_ITEM ASN1_ITEM_EXP;\n+\n+/* Macro to obtain ASN1_ITEM pointer from exported type */\n+#  define ASN1_ITEM_ptr(iptr) (iptr)\n+\n+/* Macro to include ASN1_ITEM pointer from base type */\n+#  define ASN1_ITEM_ref(iptr) (&(iptr##_it))\n+\n+#  define ASN1_ITEM_rptr(ref) (&(ref##_it))\n+\n+#  define DECLARE_ASN1_ITEM(name) \\\n+        OPENSSL_EXTERN const ASN1_ITEM name##_it;\n+\n+# else\n+\n+/*\n+ * Platforms that can't easily handle shared global variables are declared as\n+ * functions returning ASN1_ITEM pointers.\n+ */\n+\n+/* ASN1_ITEM pointer exported type */\n+typedef const ASN1_ITEM *ASN1_ITEM_EXP (void);\n+\n+/* Macro to obtain ASN1_ITEM pointer from exported type */\n+#  define ASN1_ITEM_ptr(iptr) (iptr())\n+\n+/* Macro to include ASN1_ITEM pointer from base type */\n+#  define ASN1_ITEM_ref(iptr) (iptr##_it)\n+\n+#  define ASN1_ITEM_rptr(ref) (ref##_it())\n+\n+#  define DECLARE_ASN1_ITEM(name) \\\n+        const ASN1_ITEM * name##_it(void);\n+\n+# endif\n+\n+/* Parameters used by ASN1_STRING_print_ex() */\n+\n+/*\n+ * These determine which characters to escape: RFC2253 special characters,\n+ * control characters and MSB set characters\n+ */\n+\n+# define ASN1_STRFLGS_ESC_2253           1\n+# define ASN1_STRFLGS_ESC_CTRL           2\n+# define ASN1_STRFLGS_ESC_MSB            4\n+\n+/*\n+ * This flag determines how we do escaping: normally RC2253 backslash only,\n+ * set this to use backslash and quote.\n+ */\n+\n+# define ASN1_STRFLGS_ESC_QUOTE          8\n+\n+/* These three flags are internal use only. */\n+\n+/* Character is a valid PrintableString character */\n+# define CHARTYPE_PRINTABLESTRING        0x10\n+/* Character needs escaping if it is the first character */\n+# define CHARTYPE_FIRST_ESC_2253         0x20\n+/* Character needs escaping if it is the last character */\n+# define CHARTYPE_LAST_ESC_2253          0x40\n+\n+/*\n+ * NB the internal flags are safely reused below by flags handled at the top\n+ * level.\n+ */\n+\n+/*\n+ * If this is set we convert all character strings to UTF8 first\n+ */\n+\n+# define ASN1_STRFLGS_UTF8_CONVERT       0x10\n+\n+/*\n+ * If this is set we don't attempt to interpret content: just assume all\n+ * strings are 1 byte per character. This will produce some pretty odd\n+ * looking output!\n+ */\n+\n+# define ASN1_STRFLGS_IGNORE_TYPE        0x20\n+\n+/* If this is set we include the string type in the output */\n+# define ASN1_STRFLGS_SHOW_TYPE          0x40\n+\n+/*\n+ * This determines which strings to display and which to 'dump' (hex dump of\n+ * content octets or DER encoding). We can only dump non character strings or\n+ * everything. If we don't dump 'unknown' they are interpreted as character\n+ * strings with 1 octet per character and are subject to the usual escaping\n+ * options.\n+ */\n+\n+# define ASN1_STRFLGS_DUMP_ALL           0x80\n+# define ASN1_STRFLGS_DUMP_UNKNOWN       0x100\n+\n+/*\n+ * These determine what 'dumping' does, we can dump the content octets or the\n+ * DER encoding: both use the RFC2253 #XXXXX notation.\n+ */\n+\n+# define ASN1_STRFLGS_DUMP_DER           0x200\n+\n+/*\n+ * All the string flags consistent with RFC2253, escaping control characters\n+ * isn't essential in RFC2253 but it is advisable anyway.\n+ */\n+\n+# define ASN1_STRFLGS_RFC2253    (ASN1_STRFLGS_ESC_2253 | \\\n+                                ASN1_STRFLGS_ESC_CTRL | \\\n+                                ASN1_STRFLGS_ESC_MSB | \\\n+                                ASN1_STRFLGS_UTF8_CONVERT | \\\n+                                ASN1_STRFLGS_DUMP_UNKNOWN | \\\n+                                ASN1_STRFLGS_DUMP_DER)\n+\n+DECLARE_STACK_OF(ASN1_INTEGER)\n+DECLARE_ASN1_SET_OF(ASN1_INTEGER)\n+\n+DECLARE_STACK_OF(ASN1_GENERALSTRING)\n+\n+typedef struct asn1_type_st {\n+    int type;\n+    union {\n+        char *ptr;\n+        ASN1_BOOLEAN boolean;\n+        ASN1_STRING *asn1_string;\n+        ASN1_OBJECT *object;\n+        ASN1_INTEGER *integer;\n+        ASN1_ENUMERATED *enumerated;\n+        ASN1_BIT_STRING *bit_string;\n+        ASN1_OCTET_STRING *octet_string;\n+        ASN1_PRINTABLESTRING *printablestring;\n+        ASN1_T61STRING *t61string;\n+        ASN1_IA5STRING *ia5string;\n+        ASN1_GENERALSTRING *generalstring;\n+        ASN1_BMPSTRING *bmpstring;\n+        ASN1_UNIVERSALSTRING *universalstring;\n+        ASN1_UTCTIME *utctime;\n+        ASN1_GENERALIZEDTIME *generalizedtime;\n+        ASN1_VISIBLESTRING *visiblestring;\n+        ASN1_UTF8STRING *utf8string;\n+        /*\n+         * set and sequence are left complete and still contain the set or\n+         * sequence bytes\n+         */\n+        ASN1_STRING *set;\n+        ASN1_STRING *sequence;\n+        ASN1_VALUE *asn1_value;\n+    } value;\n+} ASN1_TYPE;\n+\n+DECLARE_STACK_OF(ASN1_TYPE)\n+DECLARE_ASN1_SET_OF(ASN1_TYPE)\n+\n+typedef STACK_OF(ASN1_TYPE) ASN1_SEQUENCE_ANY;\n+\n+DECLARE_ASN1_ENCODE_FUNCTIONS_const(ASN1_SEQUENCE_ANY, ASN1_SEQUENCE_ANY)\n+DECLARE_ASN1_ENCODE_FUNCTIONS_const(ASN1_SEQUENCE_ANY, ASN1_SET_ANY)\n+\n+typedef struct NETSCAPE_X509_st {\n+    ASN1_OCTET_STRING *header;\n+    X509 *cert;\n+} NETSCAPE_X509;\n+\n+/* This is used to contain a list of bit names */\n+typedef struct BIT_STRING_BITNAME_st {\n+    int bitnum;\n+    const char *lname;\n+    const char *sname;\n+} BIT_STRING_BITNAME;\n+\n+# define M_ASN1_STRING_length(x) ((x)->length)\n+# define M_ASN1_STRING_length_set(x, n)  ((x)->length = (n))\n+# define M_ASN1_STRING_type(x)   ((x)->type)\n+# define M_ASN1_STRING_data(x)   ((x)->data)\n+\n+/* Macros for string operations */\n+# define M_ASN1_BIT_STRING_new() (ASN1_BIT_STRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_BIT_STRING)\n+# define M_ASN1_BIT_STRING_free(a)       ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_ASN1_BIT_STRING_dup(a) (ASN1_BIT_STRING *)\\\n+                ASN1_STRING_dup((const ASN1_STRING *)a)\n+# define M_ASN1_BIT_STRING_cmp(a,b) ASN1_STRING_cmp(\\\n+                (const ASN1_STRING *)a,(const ASN1_STRING *)b)\n+# define M_ASN1_BIT_STRING_set(a,b,c) ASN1_STRING_set((ASN1_STRING *)a,b,c)\n+\n+# define M_ASN1_INTEGER_new()    (ASN1_INTEGER *)\\\n+                ASN1_STRING_type_new(V_ASN1_INTEGER)\n+# define M_ASN1_INTEGER_free(a)          ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_ASN1_INTEGER_dup(a) (ASN1_INTEGER *)\\\n+                ASN1_STRING_dup((const ASN1_STRING *)a)\n+# define M_ASN1_INTEGER_cmp(a,b) ASN1_STRING_cmp(\\\n+                (const ASN1_STRING *)a,(const ASN1_STRING *)b)\n+\n+# define M_ASN1_ENUMERATED_new() (ASN1_ENUMERATED *)\\\n+                ASN1_STRING_type_new(V_ASN1_ENUMERATED)\n+# define M_ASN1_ENUMERATED_free(a)       ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_ASN1_ENUMERATED_dup(a) (ASN1_ENUMERATED *)\\\n+                ASN1_STRING_dup((const ASN1_STRING *)a)\n+# define M_ASN1_ENUMERATED_cmp(a,b)      ASN1_STRING_cmp(\\\n+                (const ASN1_STRING *)a,(const ASN1_STRING *)b)\n+\n+# define M_ASN1_OCTET_STRING_new()       (ASN1_OCTET_STRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_OCTET_STRING)\n+# define M_ASN1_OCTET_STRING_free(a)     ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_ASN1_OCTET_STRING_dup(a) (ASN1_OCTET_STRING *)\\\n+                ASN1_STRING_dup((const ASN1_STRING *)a)\n+# define M_ASN1_OCTET_STRING_cmp(a,b) ASN1_STRING_cmp(\\\n+                (const ASN1_STRING *)a,(const ASN1_STRING *)b)\n+# define M_ASN1_OCTET_STRING_set(a,b,c)  ASN1_STRING_set((ASN1_STRING *)a,b,c)\n+# define M_ASN1_OCTET_STRING_print(a,b)  ASN1_STRING_print(a,(ASN1_STRING *)b)\n+# define M_i2d_ASN1_OCTET_STRING(a,pp) \\\n+                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_OCTET_STRING,\\\n+                V_ASN1_UNIVERSAL)\n+\n+# define B_ASN1_TIME \\\n+                        B_ASN1_UTCTIME | \\\n+                        B_ASN1_GENERALIZEDTIME\n+\n+# define B_ASN1_PRINTABLE \\\n+                        B_ASN1_NUMERICSTRING| \\\n+                        B_ASN1_PRINTABLESTRING| \\\n+                        B_ASN1_T61STRING| \\\n+                        B_ASN1_IA5STRING| \\\n+                        B_ASN1_BIT_STRING| \\\n+                        B_ASN1_UNIVERSALSTRING|\\\n+                        B_ASN1_BMPSTRING|\\\n+                        B_ASN1_UTF8STRING|\\\n+                        B_ASN1_SEQUENCE|\\\n+                        B_ASN1_UNKNOWN\n+\n+# define B_ASN1_DIRECTORYSTRING \\\n+                        B_ASN1_PRINTABLESTRING| \\\n+                        B_ASN1_TELETEXSTRING|\\\n+                        B_ASN1_BMPSTRING|\\\n+                        B_ASN1_UNIVERSALSTRING|\\\n+                        B_ASN1_UTF8STRING\n+\n+# define B_ASN1_DISPLAYTEXT \\\n+                        B_ASN1_IA5STRING| \\\n+                        B_ASN1_VISIBLESTRING| \\\n+                        B_ASN1_BMPSTRING|\\\n+                        B_ASN1_UTF8STRING\n+\n+# define M_ASN1_PRINTABLE_new()  ASN1_STRING_type_new(V_ASN1_T61STRING)\n+# define M_ASN1_PRINTABLE_free(a)        ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_ASN1_PRINTABLE(a,pp) i2d_ASN1_bytes((ASN1_STRING *)a,\\\n+                pp,a->type,V_ASN1_UNIVERSAL)\n+# define M_d2i_ASN1_PRINTABLE(a,pp,l) \\\n+                d2i_ASN1_type_bytes((ASN1_STRING **)a,pp,l, \\\n+                        B_ASN1_PRINTABLE)\n+\n+# define M_DIRECTORYSTRING_new() ASN1_STRING_type_new(V_ASN1_PRINTABLESTRING)\n+# define M_DIRECTORYSTRING_free(a)       ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_DIRECTORYSTRING(a,pp) i2d_ASN1_bytes((ASN1_STRING *)a,\\\n+                                                pp,a->type,V_ASN1_UNIVERSAL)\n+# define M_d2i_DIRECTORYSTRING(a,pp,l) \\\n+                d2i_ASN1_type_bytes((ASN1_STRING **)a,pp,l, \\\n+                        B_ASN1_DIRECTORYSTRING)\n+\n+# define M_DISPLAYTEXT_new() ASN1_STRING_type_new(V_ASN1_VISIBLESTRING)\n+# define M_DISPLAYTEXT_free(a) ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_DISPLAYTEXT(a,pp) i2d_ASN1_bytes((ASN1_STRING *)a,\\\n+                                                pp,a->type,V_ASN1_UNIVERSAL)\n+# define M_d2i_DISPLAYTEXT(a,pp,l) \\\n+                d2i_ASN1_type_bytes((ASN1_STRING **)a,pp,l, \\\n+                        B_ASN1_DISPLAYTEXT)\n+\n+# define M_ASN1_PRINTABLESTRING_new() (ASN1_PRINTABLESTRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_PRINTABLESTRING)\n+# define M_ASN1_PRINTABLESTRING_free(a)  ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_ASN1_PRINTABLESTRING(a,pp) \\\n+                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_PRINTABLESTRING,\\\n+                V_ASN1_UNIVERSAL)\n+# define M_d2i_ASN1_PRINTABLESTRING(a,pp,l) \\\n+                (ASN1_PRINTABLESTRING *)d2i_ASN1_type_bytes\\\n+                ((ASN1_STRING **)a,pp,l,B_ASN1_PRINTABLESTRING)\n+\n+# define M_ASN1_T61STRING_new()  (ASN1_T61STRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_T61STRING)\n+# define M_ASN1_T61STRING_free(a)        ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_ASN1_T61STRING(a,pp) \\\n+                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_T61STRING,\\\n+                V_ASN1_UNIVERSAL)\n+# define M_d2i_ASN1_T61STRING(a,pp,l) \\\n+                (ASN1_T61STRING *)d2i_ASN1_type_bytes\\\n+                ((ASN1_STRING **)a,pp,l,B_ASN1_T61STRING)\n+\n+# define M_ASN1_IA5STRING_new()  (ASN1_IA5STRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_IA5STRING)\n+# define M_ASN1_IA5STRING_free(a)        ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_ASN1_IA5STRING_dup(a) \\\n+                (ASN1_IA5STRING *)ASN1_STRING_dup((const ASN1_STRING *)a)\n+# define M_i2d_ASN1_IA5STRING(a,pp) \\\n+                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_IA5STRING,\\\n+                        V_ASN1_UNIVERSAL)\n+# define M_d2i_ASN1_IA5STRING(a,pp,l) \\\n+                (ASN1_IA5STRING *)d2i_ASN1_type_bytes((ASN1_STRING **)a,pp,l,\\\n+                        B_ASN1_IA5STRING)\n+\n+# define M_ASN1_UTCTIME_new()    (ASN1_UTCTIME *)\\\n+                ASN1_STRING_type_new(V_ASN1_UTCTIME)\n+# define M_ASN1_UTCTIME_free(a)  ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_ASN1_UTCTIME_dup(a) (ASN1_UTCTIME *)\\\n+                ASN1_STRING_dup((const ASN1_STRING *)a)\n+\n+# define M_ASN1_GENERALIZEDTIME_new()    (ASN1_GENERALIZEDTIME *)\\\n+                ASN1_STRING_type_new(V_ASN1_GENERALIZEDTIME)\n+# define M_ASN1_GENERALIZEDTIME_free(a)  ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_ASN1_GENERALIZEDTIME_dup(a) (ASN1_GENERALIZEDTIME *)ASN1_STRING_dup(\\\n+        (const ASN1_STRING *)a)\n+\n+# define M_ASN1_TIME_new()       (ASN1_TIME *)\\\n+                ASN1_STRING_type_new(V_ASN1_UTCTIME)\n+# define M_ASN1_TIME_free(a)     ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_ASN1_TIME_dup(a) (ASN1_TIME *)\\\n+        ASN1_STRING_dup((const ASN1_STRING *)a)\n+\n+# define M_ASN1_GENERALSTRING_new()      (ASN1_GENERALSTRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_GENERALSTRING)\n+# define M_ASN1_GENERALSTRING_free(a)    ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_ASN1_GENERALSTRING(a,pp) \\\n+                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_GENERALSTRING,\\\n+                        V_ASN1_UNIVERSAL)\n+# define M_d2i_ASN1_GENERALSTRING(a,pp,l) \\\n+                (ASN1_GENERALSTRING *)d2i_ASN1_type_bytes\\\n+                ((ASN1_STRING **)a,pp,l,B_ASN1_GENERALSTRING)\n+\n+# define M_ASN1_UNIVERSALSTRING_new()    (ASN1_UNIVERSALSTRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_UNIVERSALSTRING)\n+# define M_ASN1_UNIVERSALSTRING_free(a)  ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_ASN1_UNIVERSALSTRING(a,pp) \\\n+                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_UNIVERSALSTRING,\\\n+                        V_ASN1_UNIVERSAL)\n+# define M_d2i_ASN1_UNIVERSALSTRING(a,pp,l) \\\n+                (ASN1_UNIVERSALSTRING *)d2i_ASN1_type_bytes\\\n+                ((ASN1_STRING **)a,pp,l,B_ASN1_UNIVERSALSTRING)\n+\n+# define M_ASN1_BMPSTRING_new()  (ASN1_BMPSTRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_BMPSTRING)\n+# define M_ASN1_BMPSTRING_free(a)        ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_ASN1_BMPSTRING(a,pp) \\\n+                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_BMPSTRING,\\\n+                        V_ASN1_UNIVERSAL)\n+# define M_d2i_ASN1_BMPSTRING(a,pp,l) \\\n+                (ASN1_BMPSTRING *)d2i_ASN1_type_bytes\\\n+                ((ASN1_STRING **)a,pp,l,B_ASN1_BMPSTRING)\n+\n+# define M_ASN1_VISIBLESTRING_new()      (ASN1_VISIBLESTRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_VISIBLESTRING)\n+# define M_ASN1_VISIBLESTRING_free(a)    ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_ASN1_VISIBLESTRING(a,pp) \\\n+                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_VISIBLESTRING,\\\n+                        V_ASN1_UNIVERSAL)\n+# define M_d2i_ASN1_VISIBLESTRING(a,pp,l) \\\n+                (ASN1_VISIBLESTRING *)d2i_ASN1_type_bytes\\\n+                ((ASN1_STRING **)a,pp,l,B_ASN1_VISIBLESTRING)\n+\n+# define M_ASN1_UTF8STRING_new() (ASN1_UTF8STRING *)\\\n+                ASN1_STRING_type_new(V_ASN1_UTF8STRING)\n+# define M_ASN1_UTF8STRING_free(a)       ASN1_STRING_free((ASN1_STRING *)a)\n+# define M_i2d_ASN1_UTF8STRING(a,pp) \\\n+                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_UTF8STRING,\\\n+                        V_ASN1_UNIVERSAL)\n+# define M_d2i_ASN1_UTF8STRING(a,pp,l) \\\n+                (ASN1_UTF8STRING *)d2i_ASN1_type_bytes\\\n+                ((ASN1_STRING **)a,pp,l,B_ASN1_UTF8STRING)\n+\n+  /* for the is_set parameter to i2d_ASN1_SET */\n+# define IS_SEQUENCE     0\n+# define IS_SET          1\n+\n+DECLARE_ASN1_FUNCTIONS_fname(ASN1_TYPE, ASN1_ANY, ASN1_TYPE)\n+\n+int ASN1_TYPE_get(ASN1_TYPE *a);\n+void ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value);\n+int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value);\n+int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b);\n+\n+ASN1_OBJECT *ASN1_OBJECT_new(void);\n+void ASN1_OBJECT_free(ASN1_OBJECT *a);\n+int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp);\n+ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\n+                             long length);\n+ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\n+                             long length);\n+\n+DECLARE_ASN1_ITEM(ASN1_OBJECT)\n+\n+DECLARE_STACK_OF(ASN1_OBJECT)\n+DECLARE_ASN1_SET_OF(ASN1_OBJECT)\n+\n+ASN1_STRING *ASN1_STRING_new(void);\n+void ASN1_STRING_free(ASN1_STRING *a);\n+void ASN1_STRING_clear_free(ASN1_STRING *a);\n+int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str);\n+ASN1_STRING *ASN1_STRING_dup(const ASN1_STRING *a);\n+ASN1_STRING *ASN1_STRING_type_new(int type);\n+int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b);\n+  /*\n+   * Since this is used to store all sorts of things, via macros, for now,\n+   * make its data void *\n+   */\n+int ASN1_STRING_set(ASN1_STRING *str, const void *data, int len);\n+void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len);\n+int ASN1_STRING_length(const ASN1_STRING *x);\n+void ASN1_STRING_length_set(ASN1_STRING *x, int n);\n+int ASN1_STRING_type(ASN1_STRING *x);\n+unsigned char *ASN1_STRING_data(ASN1_STRING *x);\n+\n+DECLARE_ASN1_FUNCTIONS(ASN1_BIT_STRING)\n+int i2c_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned char **pp);\n+ASN1_BIT_STRING *c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a,\n+                                     const unsigned char **pp, long length);\n+int ASN1_BIT_STRING_set(ASN1_BIT_STRING *a, unsigned char *d, int length);\n+int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value);\n+int ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *a, int n);\n+int ASN1_BIT_STRING_check(ASN1_BIT_STRING *a,\n+                          unsigned char *flags, int flags_len);\n+\n+# ifndef OPENSSL_NO_BIO\n+int ASN1_BIT_STRING_name_print(BIO *out, ASN1_BIT_STRING *bs,\n+                               BIT_STRING_BITNAME *tbl, int indent);\n+# endif\n+int ASN1_BIT_STRING_num_asc(char *name, BIT_STRING_BITNAME *tbl);\n+int ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, char *name, int value,\n+                            BIT_STRING_BITNAME *tbl);\n+\n+int i2d_ASN1_BOOLEAN(int a, unsigned char **pp);\n+int d2i_ASN1_BOOLEAN(int *a, const unsigned char **pp, long length);\n+\n+DECLARE_ASN1_FUNCTIONS(ASN1_INTEGER)\n+int i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp);\n+ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,\n+                               long length);\n+ASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned char **pp,\n+                                long length);\n+ASN1_INTEGER *ASN1_INTEGER_dup(const ASN1_INTEGER *x);\n+int ASN1_INTEGER_cmp(const ASN1_INTEGER *x, const ASN1_INTEGER *y);\n+\n+DECLARE_ASN1_FUNCTIONS(ASN1_ENUMERATED)\n+\n+int ASN1_UTCTIME_check(const ASN1_UTCTIME *a);\n+ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t);\n+ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,\n+                               int offset_day, long offset_sec);\n+int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str);\n+int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t);\n+# if 0\n+time_t ASN1_UTCTIME_get(const ASN1_UTCTIME *s);\n+# endif\n+\n+int ASN1_GENERALIZEDTIME_check(const ASN1_GENERALIZEDTIME *a);\n+ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s,\n+                                               time_t t);\n+ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,\n+                                               time_t t, int offset_day,\n+                                               long offset_sec);\n+int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str);\n+int ASN1_TIME_diff(int *pday, int *psec,\n+                   const ASN1_TIME *from, const ASN1_TIME *to);\n+\n+DECLARE_ASN1_FUNCTIONS(ASN1_OCTET_STRING)\n+ASN1_OCTET_STRING *ASN1_OCTET_STRING_dup(const ASN1_OCTET_STRING *a);\n+int ASN1_OCTET_STRING_cmp(const ASN1_OCTET_STRING *a,\n+                          const ASN1_OCTET_STRING *b);\n+int ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *str, const unsigned char *data,\n+                          int len);\n+\n+DECLARE_ASN1_FUNCTIONS(ASN1_VISIBLESTRING)\n+DECLARE_ASN1_FUNCTIONS(ASN1_UNIVERSALSTRING)\n+DECLARE_ASN1_FUNCTIONS(ASN1_UTF8STRING)\n+DECLARE_ASN1_FUNCTIONS(ASN1_NULL)\n+DECLARE_ASN1_FUNCTIONS(ASN1_BMPSTRING)\n+\n+int UTF8_getc(const unsigned char *str, int len, unsigned long *val);\n+int UTF8_putc(unsigned char *str, int len, unsigned long value);\n+\n+DECLARE_ASN1_FUNCTIONS_name(ASN1_STRING, ASN1_PRINTABLE)\n+\n+DECLARE_ASN1_FUNCTIONS_name(ASN1_STRING, DIRECTORYSTRING)\n+DECLARE_ASN1_FUNCTIONS_name(ASN1_STRING, DISPLAYTEXT)\n+DECLARE_ASN1_FUNCTIONS(ASN1_PRINTABLESTRING)\n+DECLARE_ASN1_FUNCTIONS(ASN1_T61STRING)\n+DECLARE_ASN1_FUNCTIONS(ASN1_IA5STRING)\n+DECLARE_ASN1_FUNCTIONS(ASN1_GENERALSTRING)\n+DECLARE_ASN1_FUNCTIONS(ASN1_UTCTIME)\n+DECLARE_ASN1_FUNCTIONS(ASN1_GENERALIZEDTIME)\n+DECLARE_ASN1_FUNCTIONS(ASN1_TIME)\n+\n+DECLARE_ASN1_ITEM(ASN1_OCTET_STRING_NDEF)\n+\n+ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t);\n+ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t,\n+                         int offset_day, long offset_sec);\n+int ASN1_TIME_check(ASN1_TIME *t);\n+ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t, ASN1_GENERALIZEDTIME\n+                                                   **out);\n+int ASN1_TIME_set_string(ASN1_TIME *s, const char *str);\n+\n+int i2d_ASN1_SET(STACK_OF(OPENSSL_BLOCK) *a, unsigned char **pp,\n+                 i2d_of_void *i2d, int ex_tag, int ex_class, int is_set);\n+STACK_OF(OPENSSL_BLOCK) *d2i_ASN1_SET(STACK_OF(OPENSSL_BLOCK) **a,\n+                                      const unsigned char **pp,\n+                                      long length, d2i_of_void *d2i,\n+                                      void (*free_func) (OPENSSL_BLOCK),\n+                                      int ex_tag, int ex_class);\n+\n+# ifndef OPENSSL_NO_BIO\n+int i2a_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *a);\n+int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size);\n+int i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a);\n+int a2i_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *bs, char *buf, int size);\n+int i2a_ASN1_OBJECT(BIO *bp, ASN1_OBJECT *a);\n+int a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size);\n+int i2a_ASN1_STRING(BIO *bp, ASN1_STRING *a, int type);\n+# endif\n+int i2t_ASN1_OBJECT(char *buf, int buf_len, ASN1_OBJECT *a);\n+\n+int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num);\n+ASN1_OBJECT *ASN1_OBJECT_create(int nid, unsigned char *data, int len,\n+                                const char *sn, const char *ln);\n+\n+int ASN1_INTEGER_set(ASN1_INTEGER *a, long v);\n+long ASN1_INTEGER_get(const ASN1_INTEGER *a);\n+ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai);\n+BIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn);\n+\n+int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v);\n+long ASN1_ENUMERATED_get(ASN1_ENUMERATED *a);\n+ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai);\n+BIGNUM *ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai, BIGNUM *bn);\n+\n+/* General */\n+/* given a string, return the correct type, max is the maximum length */\n+int ASN1_PRINTABLE_type(const unsigned char *s, int max);\n+\n+int i2d_ASN1_bytes(ASN1_STRING *a, unsigned char **pp, int tag, int xclass);\n+ASN1_STRING *d2i_ASN1_bytes(ASN1_STRING **a, const unsigned char **pp,\n+                            long length, int Ptag, int Pclass);\n+unsigned long ASN1_tag2bit(int tag);\n+/* type is one or more of the B_ASN1_ values. */\n+ASN1_STRING *d2i_ASN1_type_bytes(ASN1_STRING **a, const unsigned char **pp,\n+                                 long length, int type);\n+\n+/* PARSING */\n+int asn1_Finish(ASN1_CTX *c);\n+int asn1_const_Finish(ASN1_const_CTX *c);\n+\n+/* SPECIALS */\n+int ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,\n+                    int *pclass, long omax);\n+int ASN1_check_infinite_end(unsigned char **p, long len);\n+int ASN1_const_check_infinite_end(const unsigned char **p, long len);\n+void ASN1_put_object(unsigned char **pp, int constructed, int length,\n+                     int tag, int xclass);\n+int ASN1_put_eoc(unsigned char **pp);\n+int ASN1_object_size(int constructed, int length, int tag);\n+\n+/* Used to implement other functions */\n+void *ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, void *x);\n+\n+# define ASN1_dup_of(type,i2d,d2i,x) \\\n+    ((type*)ASN1_dup(CHECKED_I2D_OF(type, i2d), \\\n+                     CHECKED_D2I_OF(type, d2i), \\\n+                     CHECKED_PTR_OF(type, x)))\n+\n+# define ASN1_dup_of_const(type,i2d,d2i,x) \\\n+    ((type*)ASN1_dup(CHECKED_I2D_OF(const type, i2d), \\\n+                     CHECKED_D2I_OF(type, d2i), \\\n+                     CHECKED_PTR_OF(const type, x)))\n+\n+void *ASN1_item_dup(const ASN1_ITEM *it, void *x);\n+\n+/* ASN1 alloc/free macros for when a type is only used internally */\n+\n+# define M_ASN1_new_of(type) (type *)ASN1_item_new(ASN1_ITEM_rptr(type))\n+# define M_ASN1_free_of(x, type) \\\n+                ASN1_item_free(CHECKED_PTR_OF(type, x), ASN1_ITEM_rptr(type))\n+\n+# ifndef OPENSSL_NO_FP_API\n+void *ASN1_d2i_fp(void *(*xnew) (void), d2i_of_void *d2i, FILE *in, void **x);\n+\n+#  define ASN1_d2i_fp_of(type,xnew,d2i,in,x) \\\n+    ((type*)ASN1_d2i_fp(CHECKED_NEW_OF(type, xnew), \\\n+                        CHECKED_D2I_OF(type, d2i), \\\n+                        in, \\\n+                        CHECKED_PPTR_OF(type, x)))\n+\n+void *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x);\n+int ASN1_i2d_fp(i2d_of_void *i2d, FILE *out, void *x);\n+\n+#  define ASN1_i2d_fp_of(type,i2d,out,x) \\\n+    (ASN1_i2d_fp(CHECKED_I2D_OF(type, i2d), \\\n+                 out, \\\n+                 CHECKED_PTR_OF(type, x)))\n+\n+#  define ASN1_i2d_fp_of_const(type,i2d,out,x) \\\n+    (ASN1_i2d_fp(CHECKED_I2D_OF(const type, i2d), \\\n+                 out, \\\n+                 CHECKED_PTR_OF(const type, x)))\n+\n+int ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, void *x);\n+int ASN1_STRING_print_ex_fp(FILE *fp, ASN1_STRING *str, unsigned long flags);\n+# endif\n+\n+int ASN1_STRING_to_UTF8(unsigned char **out, ASN1_STRING *in);\n+\n+# ifndef OPENSSL_NO_BIO\n+void *ASN1_d2i_bio(void *(*xnew) (void), d2i_of_void *d2i, BIO *in, void **x);\n+\n+#  define ASN1_d2i_bio_of(type,xnew,d2i,in,x) \\\n+    ((type*)ASN1_d2i_bio( CHECKED_NEW_OF(type, xnew), \\\n+                          CHECKED_D2I_OF(type, d2i), \\\n+                          in, \\\n+                          CHECKED_PPTR_OF(type, x)))\n+\n+void *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x);\n+int ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, unsigned char *x);\n+\n+#  define ASN1_i2d_bio_of(type,i2d,out,x) \\\n+    (ASN1_i2d_bio(CHECKED_I2D_OF(type, i2d), \\\n+                  out, \\\n+                  CHECKED_PTR_OF(type, x)))\n+\n+#  define ASN1_i2d_bio_of_const(type,i2d,out,x) \\\n+    (ASN1_i2d_bio(CHECKED_I2D_OF(const type, i2d), \\\n+                  out, \\\n+                  CHECKED_PTR_OF(const type, x)))\n+\n+int ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, void *x);\n+int ASN1_UTCTIME_print(BIO *fp, const ASN1_UTCTIME *a);\n+int ASN1_GENERALIZEDTIME_print(BIO *fp, const ASN1_GENERALIZEDTIME *a);\n+int ASN1_TIME_print(BIO *fp, const ASN1_TIME *a);\n+int ASN1_STRING_print(BIO *bp, const ASN1_STRING *v);\n+int ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unsigned long flags);\n+int ASN1_bn_print(BIO *bp, const char *number, const BIGNUM *num,\n+                  unsigned char *buf, int off);\n+int ASN1_parse(BIO *bp, const unsigned char *pp, long len, int indent);\n+int ASN1_parse_dump(BIO *bp, const unsigned char *pp, long len, int indent,\n+                    int dump);\n+# endif\n+const char *ASN1_tag2str(int tag);\n+\n+/* Used to load and write netscape format cert */\n+\n+DECLARE_ASN1_FUNCTIONS(NETSCAPE_X509)\n+\n+int ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s);\n+\n+int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len);\n+int ASN1_TYPE_get_octetstring(ASN1_TYPE *a, unsigned char *data, int max_len);\n+int ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num,\n+                                  unsigned char *data, int len);\n+int ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a, long *num,\n+                                  unsigned char *data, int max_len);\n+\n+STACK_OF(OPENSSL_BLOCK) *ASN1_seq_unpack(const unsigned char *buf, int len,\n+                                         d2i_of_void *d2i,\n+                                         void (*free_func) (OPENSSL_BLOCK));\n+unsigned char *ASN1_seq_pack(STACK_OF(OPENSSL_BLOCK) *safes, i2d_of_void *i2d,\n+                             unsigned char **buf, int *len);\n+void *ASN1_unpack_string(ASN1_STRING *oct, d2i_of_void *d2i);\n+void *ASN1_item_unpack(ASN1_STRING *oct, const ASN1_ITEM *it);\n+ASN1_STRING *ASN1_pack_string(void *obj, i2d_of_void *i2d,\n+                              ASN1_OCTET_STRING **oct);\n+\n+# define ASN1_pack_string_of(type,obj,i2d,oct) \\\n+    (ASN1_pack_string(CHECKED_PTR_OF(type, obj), \\\n+                      CHECKED_I2D_OF(type, i2d), \\\n+                      oct))\n+\n+ASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it,\n+                            ASN1_OCTET_STRING **oct);\n+\n+void ASN1_STRING_set_default_mask(unsigned long mask);\n+int ASN1_STRING_set_default_mask_asc(const char *p);\n+unsigned long ASN1_STRING_get_default_mask(void);\n+int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in, int len,\n+                       int inform, unsigned long mask);\n+int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,\n+                        int inform, unsigned long mask,\n+                        long minsize, long maxsize);\n+\n+ASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out,\n+                                    const unsigned char *in, int inlen,\n+                                    int inform, int nid);\n+ASN1_STRING_TABLE *ASN1_STRING_TABLE_get(int nid);\n+int ASN1_STRING_TABLE_add(int, long, long, unsigned long, unsigned long);\n+void ASN1_STRING_TABLE_cleanup(void);\n+\n+/* ASN1 template functions */\n+\n+/* Old API compatible functions */\n+ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it);\n+void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it);\n+ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **val, const unsigned char **in,\n+                          long len, const ASN1_ITEM *it);\n+int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it);\n+int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out,\n+                       const ASN1_ITEM *it);\n+\n+void ASN1_add_oid_module(void);\n+\n+ASN1_TYPE *ASN1_generate_nconf(char *str, CONF *nconf);\n+ASN1_TYPE *ASN1_generate_v3(char *str, X509V3_CTX *cnf);\n+\n+/* ASN1 Print flags */\n+\n+/* Indicate missing OPTIONAL fields */\n+# define ASN1_PCTX_FLAGS_SHOW_ABSENT             0x001\n+/* Mark start and end of SEQUENCE */\n+# define ASN1_PCTX_FLAGS_SHOW_SEQUENCE           0x002\n+/* Mark start and end of SEQUENCE/SET OF */\n+# define ASN1_PCTX_FLAGS_SHOW_SSOF               0x004\n+/* Show the ASN1 type of primitives */\n+# define ASN1_PCTX_FLAGS_SHOW_TYPE               0x008\n+/* Don't show ASN1 type of ANY */\n+# define ASN1_PCTX_FLAGS_NO_ANY_TYPE             0x010\n+/* Don't show ASN1 type of MSTRINGs */\n+# define ASN1_PCTX_FLAGS_NO_MSTRING_TYPE         0x020\n+/* Don't show field names in SEQUENCE */\n+# define ASN1_PCTX_FLAGS_NO_FIELD_NAME           0x040\n+/* Show structure names of each SEQUENCE field */\n+# define ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME  0x080\n+/* Don't show structure name even at top level */\n+# define ASN1_PCTX_FLAGS_NO_STRUCT_NAME          0x100\n+\n+int ASN1_item_print(BIO *out, ASN1_VALUE *ifld, int indent,\n+                    const ASN1_ITEM *it, const ASN1_PCTX *pctx);\n+ASN1_PCTX *ASN1_PCTX_new(void);\n+void ASN1_PCTX_free(ASN1_PCTX *p);\n+unsigned long ASN1_PCTX_get_flags(ASN1_PCTX *p);\n+void ASN1_PCTX_set_flags(ASN1_PCTX *p, unsigned long flags);\n+unsigned long ASN1_PCTX_get_nm_flags(ASN1_PCTX *p);\n+void ASN1_PCTX_set_nm_flags(ASN1_PCTX *p, unsigned long flags);\n+unsigned long ASN1_PCTX_get_cert_flags(ASN1_PCTX *p);\n+void ASN1_PCTX_set_cert_flags(ASN1_PCTX *p, unsigned long flags);\n+unsigned long ASN1_PCTX_get_oid_flags(ASN1_PCTX *p);\n+void ASN1_PCTX_set_oid_flags(ASN1_PCTX *p, unsigned long flags);\n+unsigned long ASN1_PCTX_get_str_flags(ASN1_PCTX *p);\n+void ASN1_PCTX_set_str_flags(ASN1_PCTX *p, unsigned long flags);\n+\n+BIO_METHOD *BIO_f_asn1(void);\n+\n+BIO *BIO_new_NDEF(BIO *out, ASN1_VALUE *val, const ASN1_ITEM *it);\n+\n+int i2d_ASN1_bio_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,\n+                        const ASN1_ITEM *it);\n+int PEM_write_bio_ASN1_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,\n+                              const char *hdr, const ASN1_ITEM *it);\n+int SMIME_write_ASN1(BIO *bio, ASN1_VALUE *val, BIO *data, int flags,\n+                     int ctype_nid, int econt_nid,\n+                     STACK_OF(X509_ALGOR) *mdalgs, const ASN1_ITEM *it);\n+ASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it);\n+int SMIME_crlf_copy(BIO *in, BIO *out, int flags);\n+int SMIME_text(BIO *in, BIO *out);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_ASN1_strings(void);\n+\n+/* Error codes for the ASN1 functions. */\n+\n+/* Function codes. */\n+# define ASN1_F_A2D_ASN1_OBJECT                           100\n+# define ASN1_F_A2I_ASN1_ENUMERATED                       101\n+# define ASN1_F_A2I_ASN1_INTEGER                          102\n+# define ASN1_F_A2I_ASN1_STRING                           103\n+# define ASN1_F_APPEND_EXP                                176\n+# define ASN1_F_ASN1_BIT_STRING_SET_BIT                   183\n+# define ASN1_F_ASN1_CB                                   177\n+# define ASN1_F_ASN1_CHECK_TLEN                           104\n+# define ASN1_F_ASN1_COLLATE_PRIMITIVE                    105\n+# define ASN1_F_ASN1_COLLECT                              106\n+# define ASN1_F_ASN1_D2I_EX_PRIMITIVE                     108\n+# define ASN1_F_ASN1_D2I_FP                               109\n+# define ASN1_F_ASN1_D2I_READ_BIO                         107\n+# define ASN1_F_ASN1_DIGEST                               184\n+# define ASN1_F_ASN1_DO_ADB                               110\n+# define ASN1_F_ASN1_DUP                                  111\n+# define ASN1_F_ASN1_ENUMERATED_SET                       112\n+# define ASN1_F_ASN1_ENUMERATED_TO_BN                     113\n+# define ASN1_F_ASN1_EX_C2I                               204\n+# define ASN1_F_ASN1_FIND_END                             190\n+# define ASN1_F_ASN1_GENERALIZEDTIME_ADJ                  216\n+# define ASN1_F_ASN1_GENERALIZEDTIME_SET                  185\n+# define ASN1_F_ASN1_GENERATE_V3                          178\n+# define ASN1_F_ASN1_GET_OBJECT                           114\n+# define ASN1_F_ASN1_HEADER_NEW                           115\n+# define ASN1_F_ASN1_I2D_BIO                              116\n+# define ASN1_F_ASN1_I2D_FP                               117\n+# define ASN1_F_ASN1_INTEGER_SET                          118\n+# define ASN1_F_ASN1_INTEGER_TO_BN                        119\n+# define ASN1_F_ASN1_ITEM_D2I_FP                          206\n+# define ASN1_F_ASN1_ITEM_DUP                             191\n+# define ASN1_F_ASN1_ITEM_EX_COMBINE_NEW                  121\n+# define ASN1_F_ASN1_ITEM_EX_D2I                          120\n+# define ASN1_F_ASN1_ITEM_I2D_BIO                         192\n+# define ASN1_F_ASN1_ITEM_I2D_FP                          193\n+# define ASN1_F_ASN1_ITEM_PACK                            198\n+# define ASN1_F_ASN1_ITEM_SIGN                            195\n+# define ASN1_F_ASN1_ITEM_SIGN_CTX                        220\n+# define ASN1_F_ASN1_ITEM_UNPACK                          199\n+# define ASN1_F_ASN1_ITEM_VERIFY                          197\n+# define ASN1_F_ASN1_MBSTRING_NCOPY                       122\n+# define ASN1_F_ASN1_OBJECT_NEW                           123\n+# define ASN1_F_ASN1_OUTPUT_DATA                          214\n+# define ASN1_F_ASN1_PACK_STRING                          124\n+# define ASN1_F_ASN1_PCTX_NEW                             205\n+# define ASN1_F_ASN1_PKCS5_PBE_SET                        125\n+# define ASN1_F_ASN1_SEQ_PACK                             126\n+# define ASN1_F_ASN1_SEQ_UNPACK                           127\n+# define ASN1_F_ASN1_SIGN                                 128\n+# define ASN1_F_ASN1_STR2TYPE                             179\n+# define ASN1_F_ASN1_STRING_SET                           186\n+# define ASN1_F_ASN1_STRING_TABLE_ADD                     129\n+# define ASN1_F_ASN1_STRING_TYPE_NEW                      130\n+# define ASN1_F_ASN1_TEMPLATE_EX_D2I                      132\n+# define ASN1_F_ASN1_TEMPLATE_NEW                         133\n+# define ASN1_F_ASN1_TEMPLATE_NOEXP_D2I                   131\n+# define ASN1_F_ASN1_TIME_ADJ                             217\n+# define ASN1_F_ASN1_TIME_SET                             175\n+# define ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING             134\n+# define ASN1_F_ASN1_TYPE_GET_OCTETSTRING                 135\n+# define ASN1_F_ASN1_UNPACK_STRING                        136\n+# define ASN1_F_ASN1_UTCTIME_ADJ                          218\n+# define ASN1_F_ASN1_UTCTIME_SET                          187\n+# define ASN1_F_ASN1_VERIFY                               137\n+# define ASN1_F_B64_READ_ASN1                             209\n+# define ASN1_F_B64_WRITE_ASN1                            210\n+# define ASN1_F_BIO_NEW_NDEF                              208\n+# define ASN1_F_BITSTR_CB                                 180\n+# define ASN1_F_BN_TO_ASN1_ENUMERATED                     138\n+# define ASN1_F_BN_TO_ASN1_INTEGER                        139\n+# define ASN1_F_C2I_ASN1_BIT_STRING                       189\n+# define ASN1_F_C2I_ASN1_INTEGER                          194\n+# define ASN1_F_C2I_ASN1_OBJECT                           196\n+# define ASN1_F_COLLECT_DATA                              140\n+# define ASN1_F_D2I_ASN1_BIT_STRING                       141\n+# define ASN1_F_D2I_ASN1_BOOLEAN                          142\n+# define ASN1_F_D2I_ASN1_BYTES                            143\n+# define ASN1_F_D2I_ASN1_GENERALIZEDTIME                  144\n+# define ASN1_F_D2I_ASN1_HEADER                           145\n+# define ASN1_F_D2I_ASN1_INTEGER                          146\n+# define ASN1_F_D2I_ASN1_OBJECT                           147\n+# define ASN1_F_D2I_ASN1_SET                              148\n+# define ASN1_F_D2I_ASN1_TYPE_BYTES                       149\n+# define ASN1_F_D2I_ASN1_UINTEGER                         150\n+# define ASN1_F_D2I_ASN1_UTCTIME                          151\n+# define ASN1_F_D2I_AUTOPRIVATEKEY                        207\n+# define ASN1_F_D2I_NETSCAPE_RSA                          152\n+# define ASN1_F_D2I_NETSCAPE_RSA_2                        153\n+# define ASN1_F_D2I_PRIVATEKEY                            154\n+# define ASN1_F_D2I_PUBLICKEY                             155\n+# define ASN1_F_D2I_RSA_NET                               200\n+# define ASN1_F_D2I_RSA_NET_2                             201\n+# define ASN1_F_D2I_X509                                  156\n+# define ASN1_F_D2I_X509_CINF                             157\n+# define ASN1_F_D2I_X509_PKEY                             159\n+# define ASN1_F_I2D_ASN1_BIO_STREAM                       211\n+# define ASN1_F_I2D_ASN1_SET                              188\n+# define ASN1_F_I2D_ASN1_TIME                             160\n+# define ASN1_F_I2D_DSA_PUBKEY                            161\n+# define ASN1_F_I2D_EC_PUBKEY                             181\n+# define ASN1_F_I2D_PRIVATEKEY                            163\n+# define ASN1_F_I2D_PUBLICKEY                             164\n+# define ASN1_F_I2D_RSA_NET                               162\n+# define ASN1_F_I2D_RSA_PUBKEY                            165\n+# define ASN1_F_LONG_C2I                                  166\n+# define ASN1_F_OID_MODULE_INIT                           174\n+# define ASN1_F_PARSE_TAGGING                             182\n+# define ASN1_F_PKCS5_PBE2_SET_IV                         167\n+# define ASN1_F_PKCS5_PBE_SET                             202\n+# define ASN1_F_PKCS5_PBE_SET0_ALGOR                      215\n+# define ASN1_F_PKCS5_PBKDF2_SET                          219\n+# define ASN1_F_SMIME_READ_ASN1                           212\n+# define ASN1_F_SMIME_TEXT                                213\n+# define ASN1_F_X509_CINF_NEW                             168\n+# define ASN1_F_X509_CRL_ADD0_REVOKED                     169\n+# define ASN1_F_X509_INFO_NEW                             170\n+# define ASN1_F_X509_NAME_ENCODE                          203\n+# define ASN1_F_X509_NAME_EX_D2I                          158\n+# define ASN1_F_X509_NAME_EX_NEW                          171\n+# define ASN1_F_X509_NEW                                  172\n+# define ASN1_F_X509_PKEY_NEW                             173\n+\n+/* Reason codes. */\n+# define ASN1_R_ADDING_OBJECT                             171\n+# define ASN1_R_ASN1_PARSE_ERROR                          203\n+# define ASN1_R_ASN1_SIG_PARSE_ERROR                      204\n+# define ASN1_R_AUX_ERROR                                 100\n+# define ASN1_R_BAD_CLASS                                 101\n+# define ASN1_R_BAD_OBJECT_HEADER                         102\n+# define ASN1_R_BAD_PASSWORD_READ                         103\n+# define ASN1_R_BAD_TAG                                   104\n+# define ASN1_R_BMPSTRING_IS_WRONG_LENGTH                 214\n+# define ASN1_R_BN_LIB                                    105\n+# define ASN1_R_BOOLEAN_IS_WRONG_LENGTH                   106\n+# define ASN1_R_BUFFER_TOO_SMALL                          107\n+# define ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER           108\n+# define ASN1_R_CONTEXT_NOT_INITIALISED                   217\n+# define ASN1_R_DATA_IS_WRONG                             109\n+# define ASN1_R_DECODE_ERROR                              110\n+# define ASN1_R_DECODING_ERROR                            111\n+# define ASN1_R_DEPTH_EXCEEDED                            174\n+# define ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED         198\n+# define ASN1_R_ENCODE_ERROR                              112\n+# define ASN1_R_ERROR_GETTING_TIME                        173\n+# define ASN1_R_ERROR_LOADING_SECTION                     172\n+# define ASN1_R_ERROR_PARSING_SET_ELEMENT                 113\n+# define ASN1_R_ERROR_SETTING_CIPHER_PARAMS               114\n+# define ASN1_R_EXPECTING_AN_INTEGER                      115\n+# define ASN1_R_EXPECTING_AN_OBJECT                       116\n+# define ASN1_R_EXPECTING_A_BOOLEAN                       117\n+# define ASN1_R_EXPECTING_A_TIME                          118\n+# define ASN1_R_EXPLICIT_LENGTH_MISMATCH                  119\n+# define ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED              120\n+# define ASN1_R_FIELD_MISSING                             121\n+# define ASN1_R_FIRST_NUM_TOO_LARGE                       122\n+# define ASN1_R_HEADER_TOO_LONG                           123\n+# define ASN1_R_ILLEGAL_BITSTRING_FORMAT                  175\n+# define ASN1_R_ILLEGAL_BOOLEAN                           176\n+# define ASN1_R_ILLEGAL_CHARACTERS                        124\n+# define ASN1_R_ILLEGAL_FORMAT                            177\n+# define ASN1_R_ILLEGAL_HEX                               178\n+# define ASN1_R_ILLEGAL_IMPLICIT_TAG                      179\n+# define ASN1_R_ILLEGAL_INTEGER                           180\n+# define ASN1_R_ILLEGAL_NESTED_TAGGING                    181\n+# define ASN1_R_ILLEGAL_NULL                              125\n+# define ASN1_R_ILLEGAL_NULL_VALUE                        182\n+# define ASN1_R_ILLEGAL_OBJECT                            183\n+# define ASN1_R_ILLEGAL_OPTIONAL_ANY                      126\n+# define ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE          170\n+# define ASN1_R_ILLEGAL_TAGGED_ANY                        127\n+# define ASN1_R_ILLEGAL_TIME_VALUE                        184\n+# define ASN1_R_INTEGER_NOT_ASCII_FORMAT                  185\n+# define ASN1_R_INTEGER_TOO_LARGE_FOR_LONG                128\n+# define ASN1_R_INVALID_BIT_STRING_BITS_LEFT              220\n+# define ASN1_R_INVALID_BMPSTRING_LENGTH                  129\n+# define ASN1_R_INVALID_DIGIT                             130\n+# define ASN1_R_INVALID_MIME_TYPE                         205\n+# define ASN1_R_INVALID_MODIFIER                          186\n+# define ASN1_R_INVALID_NUMBER                            187\n+# define ASN1_R_INVALID_OBJECT_ENCODING                   216\n+# define ASN1_R_INVALID_SEPARATOR                         131\n+# define ASN1_R_INVALID_TIME_FORMAT                       132\n+# define ASN1_R_INVALID_UNIVERSALSTRING_LENGTH            133\n+# define ASN1_R_INVALID_UTF8STRING                        134\n+# define ASN1_R_IV_TOO_LARGE                              135\n+# define ASN1_R_LENGTH_ERROR                              136\n+# define ASN1_R_LIST_ERROR                                188\n+# define ASN1_R_MIME_NO_CONTENT_TYPE                      206\n+# define ASN1_R_MIME_PARSE_ERROR                          207\n+# define ASN1_R_MIME_SIG_PARSE_ERROR                      208\n+# define ASN1_R_MISSING_EOC                               137\n+# define ASN1_R_MISSING_SECOND_NUMBER                     138\n+# define ASN1_R_MISSING_VALUE                             189\n+# define ASN1_R_MSTRING_NOT_UNIVERSAL                     139\n+# define ASN1_R_MSTRING_WRONG_TAG                         140\n+# define ASN1_R_NESTED_ASN1_STRING                        197\n+# define ASN1_R_NESTED_TOO_DEEP                           219\n+# define ASN1_R_NON_HEX_CHARACTERS                        141\n+# define ASN1_R_NOT_ASCII_FORMAT                          190\n+# define ASN1_R_NOT_ENOUGH_DATA                           142\n+# define ASN1_R_NO_CONTENT_TYPE                           209\n+# define ASN1_R_NO_DEFAULT_DIGEST                         201\n+# define ASN1_R_NO_MATCHING_CHOICE_TYPE                   143\n+# define ASN1_R_NO_MULTIPART_BODY_FAILURE                 210\n+# define ASN1_R_NO_MULTIPART_BOUNDARY                     211\n+# define ASN1_R_NO_SIG_CONTENT_TYPE                       212\n+# define ASN1_R_NULL_IS_WRONG_LENGTH                      144\n+# define ASN1_R_OBJECT_NOT_ASCII_FORMAT                   191\n+# define ASN1_R_ODD_NUMBER_OF_CHARS                       145\n+# define ASN1_R_PRIVATE_KEY_HEADER_MISSING                146\n+# define ASN1_R_SECOND_NUMBER_TOO_LARGE                   147\n+# define ASN1_R_SEQUENCE_LENGTH_MISMATCH                  148\n+# define ASN1_R_SEQUENCE_NOT_CONSTRUCTED                  149\n+# define ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG              192\n+# define ASN1_R_SHORT_LINE                                150\n+# define ASN1_R_SIG_INVALID_MIME_TYPE                     213\n+# define ASN1_R_STREAMING_NOT_SUPPORTED                   202\n+# define ASN1_R_STRING_TOO_LONG                           151\n+# define ASN1_R_STRING_TOO_SHORT                          152\n+# define ASN1_R_TAG_VALUE_TOO_HIGH                        153\n+# define ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD 154\n+# define ASN1_R_TIME_NOT_ASCII_FORMAT                     193\n+# define ASN1_R_TOO_LONG                                  155\n+# define ASN1_R_TYPE_NOT_CONSTRUCTED                      156\n+# define ASN1_R_TYPE_NOT_PRIMITIVE                        218\n+# define ASN1_R_UNABLE_TO_DECODE_RSA_KEY                  157\n+# define ASN1_R_UNABLE_TO_DECODE_RSA_PRIVATE_KEY          158\n+# define ASN1_R_UNEXPECTED_EOC                            159\n+# define ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH           215\n+# define ASN1_R_UNKNOWN_FORMAT                            160\n+# define ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM          161\n+# define ASN1_R_UNKNOWN_OBJECT_TYPE                       162\n+# define ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE                   163\n+# define ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM               199\n+# define ASN1_R_UNKNOWN_TAG                               194\n+# define ASN1_R_UNKOWN_FORMAT                             195\n+# define ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE           164\n+# define ASN1_R_UNSUPPORTED_CIPHER                        165\n+# define ASN1_R_UNSUPPORTED_ENCRYPTION_ALGORITHM          166\n+# define ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE               167\n+# define ASN1_R_UNSUPPORTED_TYPE                          196\n+# define ASN1_R_WRONG_PUBLIC_KEY_TYPE                     200\n+# define ASN1_R_WRONG_TAG                                 168\n+# define ASN1_R_WRONG_TYPE                                169\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "abc6dc35ca41a661d53e86e24f3f3d2cd0c66915",
            "filename": "deps/openssl/openssl/include/openssl/asn1_mac.h",
            "status": "added",
            "additions": 579,
            "deletions": 0,
            "changes": 579,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fasn1_mac.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fasn1_mac.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fasn1_mac.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,579 @@\n+/* crypto/asn1/asn1_mac.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_ASN1_MAC_H\n+# define HEADER_ASN1_MAC_H\n+\n+# include <openssl/asn1.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# ifndef ASN1_MAC_ERR_LIB\n+#  define ASN1_MAC_ERR_LIB        ERR_LIB_ASN1\n+# endif\n+\n+# define ASN1_MAC_H_err(f,r,line) \\\n+        ERR_PUT_error(ASN1_MAC_ERR_LIB,(f),(r),__FILE__,(line))\n+\n+# define M_ASN1_D2I_vars(a,type,func) \\\n+        ASN1_const_CTX c; \\\n+        type ret=NULL; \\\n+        \\\n+        c.pp=(const unsigned char **)pp; \\\n+        c.q= *(const unsigned char **)pp; \\\n+        c.error=ERR_R_NESTED_ASN1_ERROR; \\\n+        if ((a == NULL) || ((*a) == NULL)) \\\n+                { if ((ret=(type)func()) == NULL) \\\n+                        { c.line=__LINE__; goto err; } } \\\n+        else    ret=(*a);\n+\n+# define M_ASN1_D2I_Init() \\\n+        c.p= *(const unsigned char **)pp; \\\n+        c.max=(length == 0)?0:(c.p+length);\n+\n+# define M_ASN1_D2I_Finish_2(a) \\\n+        if (!asn1_const_Finish(&c)) \\\n+                { c.line=__LINE__; goto err; } \\\n+        *(const unsigned char **)pp=c.p; \\\n+        if (a != NULL) (*a)=ret; \\\n+        return(ret);\n+\n+# define M_ASN1_D2I_Finish(a,func,e) \\\n+        M_ASN1_D2I_Finish_2(a); \\\n+err:\\\n+        ASN1_MAC_H_err((e),c.error,c.line); \\\n+        asn1_add_error(*(const unsigned char **)pp,(int)(c.q- *pp)); \\\n+        if ((ret != NULL) && ((a == NULL) || (*a != ret))) func(ret); \\\n+        return(NULL)\n+\n+# define M_ASN1_D2I_start_sequence() \\\n+        if (!asn1_GetSequence(&c,&length)) \\\n+                { c.line=__LINE__; goto err; }\n+/* Begin reading ASN1 without a surrounding sequence */\n+# define M_ASN1_D2I_begin() \\\n+        c.slen = length;\n+\n+/* End reading ASN1 with no check on length */\n+# define M_ASN1_D2I_Finish_nolen(a, func, e) \\\n+        *pp=c.p; \\\n+        if (a != NULL) (*a)=ret; \\\n+        return(ret); \\\n+err:\\\n+        ASN1_MAC_H_err((e),c.error,c.line); \\\n+        asn1_add_error(*pp,(int)(c.q- *pp)); \\\n+        if ((ret != NULL) && ((a == NULL) || (*a != ret))) func(ret); \\\n+        return(NULL)\n+\n+# define M_ASN1_D2I_end_sequence() \\\n+        (((c.inf&1) == 0)?(c.slen <= 0): \\\n+                (c.eos=ASN1_const_check_infinite_end(&c.p,c.slen)))\n+\n+/* Don't use this with d2i_ASN1_BOOLEAN() */\n+# define M_ASN1_D2I_get(b, func) \\\n+        c.q=c.p; \\\n+        if (func(&(b),&c.p,c.slen) == NULL) \\\n+                {c.line=__LINE__; goto err; } \\\n+        c.slen-=(c.p-c.q);\n+\n+/* Don't use this with d2i_ASN1_BOOLEAN() */\n+# define M_ASN1_D2I_get_x(type,b,func) \\\n+        c.q=c.p; \\\n+        if (((D2I_OF(type))func)(&(b),&c.p,c.slen) == NULL) \\\n+                {c.line=__LINE__; goto err; } \\\n+        c.slen-=(c.p-c.q);\n+\n+/* use this instead () */\n+# define M_ASN1_D2I_get_int(b,func) \\\n+        c.q=c.p; \\\n+        if (func(&(b),&c.p,c.slen) < 0) \\\n+                {c.line=__LINE__; goto err; } \\\n+        c.slen-=(c.p-c.q);\n+\n+# define M_ASN1_D2I_get_opt(b,func,type) \\\n+        if ((c.slen != 0) && ((M_ASN1_next & (~V_ASN1_CONSTRUCTED)) \\\n+                == (V_ASN1_UNIVERSAL|(type)))) \\\n+                { \\\n+                M_ASN1_D2I_get(b,func); \\\n+                }\n+\n+# define M_ASN1_D2I_get_int_opt(b,func,type) \\\n+        if ((c.slen != 0) && ((M_ASN1_next & (~V_ASN1_CONSTRUCTED)) \\\n+                == (V_ASN1_UNIVERSAL|(type)))) \\\n+                { \\\n+                M_ASN1_D2I_get_int(b,func); \\\n+                }\n+\n+# define M_ASN1_D2I_get_imp(b,func, type) \\\n+        M_ASN1_next=(_tmp& V_ASN1_CONSTRUCTED)|type; \\\n+        c.q=c.p; \\\n+        if (func(&(b),&c.p,c.slen) == NULL) \\\n+                {c.line=__LINE__; M_ASN1_next_prev = _tmp; goto err; } \\\n+        c.slen-=(c.p-c.q);\\\n+        M_ASN1_next_prev=_tmp;\n+\n+# define M_ASN1_D2I_get_IMP_opt(b,func,tag,type) \\\n+        if ((c.slen != 0) && ((M_ASN1_next & (~V_ASN1_CONSTRUCTED)) == \\\n+                (V_ASN1_CONTEXT_SPECIFIC|(tag)))) \\\n+                { \\\n+                unsigned char _tmp = M_ASN1_next; \\\n+                M_ASN1_D2I_get_imp(b,func, type);\\\n+                }\n+\n+# define M_ASN1_D2I_get_set(r,func,free_func) \\\n+                M_ASN1_D2I_get_imp_set(r,func,free_func, \\\n+                        V_ASN1_SET,V_ASN1_UNIVERSAL);\n+\n+# define M_ASN1_D2I_get_set_type(type,r,func,free_func) \\\n+                M_ASN1_D2I_get_imp_set_type(type,r,func,free_func, \\\n+                        V_ASN1_SET,V_ASN1_UNIVERSAL);\n+\n+# define M_ASN1_D2I_get_set_opt(r,func,free_func) \\\n+        if ((c.slen != 0) && (M_ASN1_next == (V_ASN1_UNIVERSAL| \\\n+                V_ASN1_CONSTRUCTED|V_ASN1_SET)))\\\n+                { M_ASN1_D2I_get_set(r,func,free_func); }\n+\n+# define M_ASN1_D2I_get_set_opt_type(type,r,func,free_func) \\\n+        if ((c.slen != 0) && (M_ASN1_next == (V_ASN1_UNIVERSAL| \\\n+                V_ASN1_CONSTRUCTED|V_ASN1_SET)))\\\n+                { M_ASN1_D2I_get_set_type(type,r,func,free_func); }\n+\n+# define M_ASN1_I2D_len_SET_opt(a,f) \\\n+        if ((a != NULL) && (sk_num(a) != 0)) \\\n+                M_ASN1_I2D_len_SET(a,f);\n+\n+# define M_ASN1_I2D_put_SET_opt(a,f) \\\n+        if ((a != NULL) && (sk_num(a) != 0)) \\\n+                M_ASN1_I2D_put_SET(a,f);\n+\n+# define M_ASN1_I2D_put_SEQUENCE_opt(a,f) \\\n+        if ((a != NULL) && (sk_num(a) != 0)) \\\n+                M_ASN1_I2D_put_SEQUENCE(a,f);\n+\n+# define M_ASN1_I2D_put_SEQUENCE_opt_type(type,a,f) \\\n+        if ((a != NULL) && (sk_##type##_num(a) != 0)) \\\n+                M_ASN1_I2D_put_SEQUENCE_type(type,a,f);\n+\n+# define M_ASN1_D2I_get_IMP_set_opt(b,func,free_func,tag) \\\n+        if ((c.slen != 0) && \\\n+                (M_ASN1_next == \\\n+                (V_ASN1_CONTEXT_SPECIFIC|V_ASN1_CONSTRUCTED|(tag))))\\\n+                { \\\n+                M_ASN1_D2I_get_imp_set(b,func,free_func,\\\n+                        tag,V_ASN1_CONTEXT_SPECIFIC); \\\n+                }\n+\n+# define M_ASN1_D2I_get_IMP_set_opt_type(type,b,func,free_func,tag) \\\n+        if ((c.slen != 0) && \\\n+                (M_ASN1_next == \\\n+                (V_ASN1_CONTEXT_SPECIFIC|V_ASN1_CONSTRUCTED|(tag))))\\\n+                { \\\n+                M_ASN1_D2I_get_imp_set_type(type,b,func,free_func,\\\n+                        tag,V_ASN1_CONTEXT_SPECIFIC); \\\n+                }\n+\n+# define M_ASN1_D2I_get_seq(r,func,free_func) \\\n+                M_ASN1_D2I_get_imp_set(r,func,free_func,\\\n+                        V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\n+\n+# define M_ASN1_D2I_get_seq_type(type,r,func,free_func) \\\n+                M_ASN1_D2I_get_imp_set_type(type,r,func,free_func,\\\n+                                            V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL)\n+\n+# define M_ASN1_D2I_get_seq_opt(r,func,free_func) \\\n+        if ((c.slen != 0) && (M_ASN1_next == (V_ASN1_UNIVERSAL| \\\n+                V_ASN1_CONSTRUCTED|V_ASN1_SEQUENCE)))\\\n+                { M_ASN1_D2I_get_seq(r,func,free_func); }\n+\n+# define M_ASN1_D2I_get_seq_opt_type(type,r,func,free_func) \\\n+        if ((c.slen != 0) && (M_ASN1_next == (V_ASN1_UNIVERSAL| \\\n+                V_ASN1_CONSTRUCTED|V_ASN1_SEQUENCE)))\\\n+                { M_ASN1_D2I_get_seq_type(type,r,func,free_func); }\n+\n+# define M_ASN1_D2I_get_IMP_set(r,func,free_func,x) \\\n+                M_ASN1_D2I_get_imp_set(r,func,free_func,\\\n+                        x,V_ASN1_CONTEXT_SPECIFIC);\n+\n+# define M_ASN1_D2I_get_IMP_set_type(type,r,func,free_func,x) \\\n+                M_ASN1_D2I_get_imp_set_type(type,r,func,free_func,\\\n+                        x,V_ASN1_CONTEXT_SPECIFIC);\n+\n+# define M_ASN1_D2I_get_imp_set(r,func,free_func,a,b) \\\n+        c.q=c.p; \\\n+        if (d2i_ASN1_SET(&(r),&c.p,c.slen,(char *(*)())func,\\\n+                (void (*)())free_func,a,b) == NULL) \\\n+                { c.line=__LINE__; goto err; } \\\n+        c.slen-=(c.p-c.q);\n+\n+# define M_ASN1_D2I_get_imp_set_type(type,r,func,free_func,a,b) \\\n+        c.q=c.p; \\\n+        if (d2i_ASN1_SET_OF_##type(&(r),&c.p,c.slen,func,\\\n+                                   free_func,a,b) == NULL) \\\n+                { c.line=__LINE__; goto err; } \\\n+        c.slen-=(c.p-c.q);\n+\n+# define M_ASN1_D2I_get_set_strings(r,func,a,b) \\\n+        c.q=c.p; \\\n+        if (d2i_ASN1_STRING_SET(&(r),&c.p,c.slen,a,b) == NULL) \\\n+                { c.line=__LINE__; goto err; } \\\n+        c.slen-=(c.p-c.q);\n+\n+# define M_ASN1_D2I_get_EXP_opt(r,func,tag) \\\n+        if ((c.slen != 0L) && (M_ASN1_next == \\\n+                (V_ASN1_CONSTRUCTED|V_ASN1_CONTEXT_SPECIFIC|tag))) \\\n+                { \\\n+                int Tinf,Ttag,Tclass; \\\n+                long Tlen; \\\n+                \\\n+                c.q=c.p; \\\n+                Tinf=ASN1_get_object(&c.p,&Tlen,&Ttag,&Tclass,c.slen); \\\n+                if (Tinf & 0x80) \\\n+                        { c.error=ERR_R_BAD_ASN1_OBJECT_HEADER; \\\n+                        c.line=__LINE__; goto err; } \\\n+                if (Tinf == (V_ASN1_CONSTRUCTED+1)) \\\n+                                        Tlen = c.slen - (c.p - c.q) - 2; \\\n+                if (func(&(r),&c.p,Tlen) == NULL) \\\n+                        { c.line=__LINE__; goto err; } \\\n+                if (Tinf == (V_ASN1_CONSTRUCTED+1)) { \\\n+                        Tlen = c.slen - (c.p - c.q); \\\n+                        if(!ASN1_const_check_infinite_end(&c.p, Tlen)) \\\n+                                { c.error=ERR_R_MISSING_ASN1_EOS; \\\n+                                c.line=__LINE__; goto err; } \\\n+                }\\\n+                c.slen-=(c.p-c.q); \\\n+                }\n+\n+# define M_ASN1_D2I_get_EXP_set_opt(r,func,free_func,tag,b) \\\n+        if ((c.slen != 0) && (M_ASN1_next == \\\n+                (V_ASN1_CONSTRUCTED|V_ASN1_CONTEXT_SPECIFIC|tag))) \\\n+                { \\\n+                int Tinf,Ttag,Tclass; \\\n+                long Tlen; \\\n+                \\\n+                c.q=c.p; \\\n+                Tinf=ASN1_get_object(&c.p,&Tlen,&Ttag,&Tclass,c.slen); \\\n+                if (Tinf & 0x80) \\\n+                        { c.error=ERR_R_BAD_ASN1_OBJECT_HEADER; \\\n+                        c.line=__LINE__; goto err; } \\\n+                if (Tinf == (V_ASN1_CONSTRUCTED+1)) \\\n+                                        Tlen = c.slen - (c.p - c.q) - 2; \\\n+                if (d2i_ASN1_SET(&(r),&c.p,Tlen,(char *(*)())func, \\\n+                        (void (*)())free_func, \\\n+                        b,V_ASN1_UNIVERSAL) == NULL) \\\n+                        { c.line=__LINE__; goto err; } \\\n+                if (Tinf == (V_ASN1_CONSTRUCTED+1)) { \\\n+                        Tlen = c.slen - (c.p - c.q); \\\n+                        if(!ASN1_check_infinite_end(&c.p, Tlen)) \\\n+                                { c.error=ERR_R_MISSING_ASN1_EOS; \\\n+                                c.line=__LINE__; goto err; } \\\n+                }\\\n+                c.slen-=(c.p-c.q); \\\n+                }\n+\n+# define M_ASN1_D2I_get_EXP_set_opt_type(type,r,func,free_func,tag,b) \\\n+        if ((c.slen != 0) && (M_ASN1_next == \\\n+                (V_ASN1_CONSTRUCTED|V_ASN1_CONTEXT_SPECIFIC|tag))) \\\n+                { \\\n+                int Tinf,Ttag,Tclass; \\\n+                long Tlen; \\\n+                \\\n+                c.q=c.p; \\\n+                Tinf=ASN1_get_object(&c.p,&Tlen,&Ttag,&Tclass,c.slen); \\\n+                if (Tinf & 0x80) \\\n+                        { c.error=ERR_R_BAD_ASN1_OBJECT_HEADER; \\\n+                        c.line=__LINE__; goto err; } \\\n+                if (Tinf == (V_ASN1_CONSTRUCTED+1)) \\\n+                                        Tlen = c.slen - (c.p - c.q) - 2; \\\n+                if (d2i_ASN1_SET_OF_##type(&(r),&c.p,Tlen,func, \\\n+                        free_func,b,V_ASN1_UNIVERSAL) == NULL) \\\n+                        { c.line=__LINE__; goto err; } \\\n+                if (Tinf == (V_ASN1_CONSTRUCTED+1)) { \\\n+                        Tlen = c.slen - (c.p - c.q); \\\n+                        if(!ASN1_check_infinite_end(&c.p, Tlen)) \\\n+                                { c.error=ERR_R_MISSING_ASN1_EOS; \\\n+                                c.line=__LINE__; goto err; } \\\n+                }\\\n+                c.slen-=(c.p-c.q); \\\n+                }\n+\n+/* New macros */\n+# define M_ASN1_New_Malloc(ret,type) \\\n+        if ((ret=(type *)OPENSSL_malloc(sizeof(type))) == NULL) \\\n+                { c.line=__LINE__; goto err2; }\n+\n+# define M_ASN1_New(arg,func) \\\n+        if (((arg)=func()) == NULL) return(NULL)\n+\n+# define M_ASN1_New_Error(a) \\\n+/*-     err:    ASN1_MAC_H_err((a),ERR_R_NESTED_ASN1_ERROR,c.line); \\\n+                return(NULL);*/ \\\n+        err2:   ASN1_MAC_H_err((a),ERR_R_MALLOC_FAILURE,c.line); \\\n+                return(NULL)\n+\n+/*\n+ * BIG UGLY WARNING! This is so damn ugly I wanna puke.  Unfortunately, some\n+ * macros that use ASN1_const_CTX still insist on writing in the input\n+ * stream.  ARGH! ARGH! ARGH! Let's get rid of this macro package. Please? --\n+ * Richard Levitte\n+ */\n+# define M_ASN1_next             (*((unsigned char *)(c.p)))\n+# define M_ASN1_next_prev        (*((unsigned char *)(c.q)))\n+\n+/*************************************************/\n+\n+# define M_ASN1_I2D_vars(a)      int r=0,ret=0; \\\n+                                unsigned char *p; \\\n+                                if (a == NULL) return(0)\n+\n+/* Length Macros */\n+# define M_ASN1_I2D_len(a,f)     ret+=f(a,NULL)\n+# define M_ASN1_I2D_len_IMP_opt(a,f)     if (a != NULL) M_ASN1_I2D_len(a,f)\n+\n+# define M_ASN1_I2D_len_SET(a,f) \\\n+                ret+=i2d_ASN1_SET(a,NULL,f,V_ASN1_SET,V_ASN1_UNIVERSAL,IS_SET);\n+\n+# define M_ASN1_I2D_len_SET_type(type,a,f) \\\n+                ret+=i2d_ASN1_SET_OF_##type(a,NULL,f,V_ASN1_SET, \\\n+                                            V_ASN1_UNIVERSAL,IS_SET);\n+\n+# define M_ASN1_I2D_len_SEQUENCE(a,f) \\\n+                ret+=i2d_ASN1_SET(a,NULL,f,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL, \\\n+                                  IS_SEQUENCE);\n+\n+# define M_ASN1_I2D_len_SEQUENCE_type(type,a,f) \\\n+                ret+=i2d_ASN1_SET_OF_##type(a,NULL,f,V_ASN1_SEQUENCE, \\\n+                                            V_ASN1_UNIVERSAL,IS_SEQUENCE)\n+\n+# define M_ASN1_I2D_len_SEQUENCE_opt(a,f) \\\n+                if ((a != NULL) && (sk_num(a) != 0)) \\\n+                        M_ASN1_I2D_len_SEQUENCE(a,f);\n+\n+# define M_ASN1_I2D_len_SEQUENCE_opt_type(type,a,f) \\\n+                if ((a != NULL) && (sk_##type##_num(a) != 0)) \\\n+                        M_ASN1_I2D_len_SEQUENCE_type(type,a,f);\n+\n+# define M_ASN1_I2D_len_IMP_SET(a,f,x) \\\n+                ret+=i2d_ASN1_SET(a,NULL,f,x,V_ASN1_CONTEXT_SPECIFIC,IS_SET);\n+\n+# define M_ASN1_I2D_len_IMP_SET_type(type,a,f,x) \\\n+                ret+=i2d_ASN1_SET_OF_##type(a,NULL,f,x, \\\n+                                            V_ASN1_CONTEXT_SPECIFIC,IS_SET);\n+\n+# define M_ASN1_I2D_len_IMP_SET_opt(a,f,x) \\\n+                if ((a != NULL) && (sk_num(a) != 0)) \\\n+                        ret+=i2d_ASN1_SET(a,NULL,f,x,V_ASN1_CONTEXT_SPECIFIC, \\\n+                                          IS_SET);\n+\n+# define M_ASN1_I2D_len_IMP_SET_opt_type(type,a,f,x) \\\n+                if ((a != NULL) && (sk_##type##_num(a) != 0)) \\\n+                        ret+=i2d_ASN1_SET_OF_##type(a,NULL,f,x, \\\n+                                               V_ASN1_CONTEXT_SPECIFIC,IS_SET);\n+\n+# define M_ASN1_I2D_len_IMP_SEQUENCE(a,f,x) \\\n+                ret+=i2d_ASN1_SET(a,NULL,f,x,V_ASN1_CONTEXT_SPECIFIC, \\\n+                                  IS_SEQUENCE);\n+\n+# define M_ASN1_I2D_len_IMP_SEQUENCE_opt(a,f,x) \\\n+                if ((a != NULL) && (sk_num(a) != 0)) \\\n+                        ret+=i2d_ASN1_SET(a,NULL,f,x,V_ASN1_CONTEXT_SPECIFIC, \\\n+                                          IS_SEQUENCE);\n+\n+# define M_ASN1_I2D_len_IMP_SEQUENCE_opt_type(type,a,f,x) \\\n+                if ((a != NULL) && (sk_##type##_num(a) != 0)) \\\n+                        ret+=i2d_ASN1_SET_OF_##type(a,NULL,f,x, \\\n+                                                    V_ASN1_CONTEXT_SPECIFIC, \\\n+                                                    IS_SEQUENCE);\n+\n+# define M_ASN1_I2D_len_EXP_opt(a,f,mtag,v) \\\n+                if (a != NULL)\\\n+                        { \\\n+                        v=f(a,NULL); \\\n+                        ret+=ASN1_object_size(1,v,mtag); \\\n+                        }\n+\n+# define M_ASN1_I2D_len_EXP_SET_opt(a,f,mtag,tag,v) \\\n+                if ((a != NULL) && (sk_num(a) != 0))\\\n+                        { \\\n+                        v=i2d_ASN1_SET(a,NULL,f,tag,V_ASN1_UNIVERSAL,IS_SET); \\\n+                        ret+=ASN1_object_size(1,v,mtag); \\\n+                        }\n+\n+# define M_ASN1_I2D_len_EXP_SEQUENCE_opt(a,f,mtag,tag,v) \\\n+                if ((a != NULL) && (sk_num(a) != 0))\\\n+                        { \\\n+                        v=i2d_ASN1_SET(a,NULL,f,tag,V_ASN1_UNIVERSAL, \\\n+                                       IS_SEQUENCE); \\\n+                        ret+=ASN1_object_size(1,v,mtag); \\\n+                        }\n+\n+# define M_ASN1_I2D_len_EXP_SEQUENCE_opt_type(type,a,f,mtag,tag,v) \\\n+                if ((a != NULL) && (sk_##type##_num(a) != 0))\\\n+                        { \\\n+                        v=i2d_ASN1_SET_OF_##type(a,NULL,f,tag, \\\n+                                                 V_ASN1_UNIVERSAL, \\\n+                                                 IS_SEQUENCE); \\\n+                        ret+=ASN1_object_size(1,v,mtag); \\\n+                        }\n+\n+/* Put Macros */\n+# define M_ASN1_I2D_put(a,f)     f(a,&p)\n+\n+# define M_ASN1_I2D_put_IMP_opt(a,f,t)   \\\n+                if (a != NULL) \\\n+                        { \\\n+                        unsigned char *q=p; \\\n+                        f(a,&p); \\\n+                        *q=(V_ASN1_CONTEXT_SPECIFIC|t|(*q&V_ASN1_CONSTRUCTED));\\\n+                        }\n+\n+# define M_ASN1_I2D_put_SET(a,f) i2d_ASN1_SET(a,&p,f,V_ASN1_SET,\\\n+                        V_ASN1_UNIVERSAL,IS_SET)\n+# define M_ASN1_I2D_put_SET_type(type,a,f) \\\n+     i2d_ASN1_SET_OF_##type(a,&p,f,V_ASN1_SET,V_ASN1_UNIVERSAL,IS_SET)\n+# define M_ASN1_I2D_put_IMP_SET(a,f,x) i2d_ASN1_SET(a,&p,f,x,\\\n+                        V_ASN1_CONTEXT_SPECIFIC,IS_SET)\n+# define M_ASN1_I2D_put_IMP_SET_type(type,a,f,x) \\\n+     i2d_ASN1_SET_OF_##type(a,&p,f,x,V_ASN1_CONTEXT_SPECIFIC,IS_SET)\n+# define M_ASN1_I2D_put_IMP_SEQUENCE(a,f,x) i2d_ASN1_SET(a,&p,f,x,\\\n+                        V_ASN1_CONTEXT_SPECIFIC,IS_SEQUENCE)\n+\n+# define M_ASN1_I2D_put_SEQUENCE(a,f) i2d_ASN1_SET(a,&p,f,V_ASN1_SEQUENCE,\\\n+                                             V_ASN1_UNIVERSAL,IS_SEQUENCE)\n+\n+# define M_ASN1_I2D_put_SEQUENCE_type(type,a,f) \\\n+     i2d_ASN1_SET_OF_##type(a,&p,f,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL, \\\n+                            IS_SEQUENCE)\n+\n+# define M_ASN1_I2D_put_SEQUENCE_opt(a,f) \\\n+                if ((a != NULL) && (sk_num(a) != 0)) \\\n+                        M_ASN1_I2D_put_SEQUENCE(a,f);\n+\n+# define M_ASN1_I2D_put_IMP_SET_opt(a,f,x) \\\n+                if ((a != NULL) && (sk_num(a) != 0)) \\\n+                        { i2d_ASN1_SET(a,&p,f,x,V_ASN1_CONTEXT_SPECIFIC, \\\n+                                       IS_SET); }\n+\n+# define M_ASN1_I2D_put_IMP_SET_opt_type(type,a,f,x) \\\n+                if ((a != NULL) && (sk_##type##_num(a) != 0)) \\\n+                        { i2d_ASN1_SET_OF_##type(a,&p,f,x, \\\n+                                                 V_ASN1_CONTEXT_SPECIFIC, \\\n+                                                 IS_SET); }\n+\n+# define M_ASN1_I2D_put_IMP_SEQUENCE_opt(a,f,x) \\\n+                if ((a != NULL) && (sk_num(a) != 0)) \\\n+                        { i2d_ASN1_SET(a,&p,f,x,V_ASN1_CONTEXT_SPECIFIC, \\\n+                                       IS_SEQUENCE); }\n+\n+# define M_ASN1_I2D_put_IMP_SEQUENCE_opt_type(type,a,f,x) \\\n+                if ((a != NULL) && (sk_##type##_num(a) != 0)) \\\n+                        { i2d_ASN1_SET_OF_##type(a,&p,f,x, \\\n+                                                 V_ASN1_CONTEXT_SPECIFIC, \\\n+                                                 IS_SEQUENCE); }\n+\n+# define M_ASN1_I2D_put_EXP_opt(a,f,tag,v) \\\n+                if (a != NULL) \\\n+                        { \\\n+                        ASN1_put_object(&p,1,v,tag,V_ASN1_CONTEXT_SPECIFIC); \\\n+                        f(a,&p); \\\n+                        }\n+\n+# define M_ASN1_I2D_put_EXP_SET_opt(a,f,mtag,tag,v) \\\n+                if ((a != NULL) && (sk_num(a) != 0)) \\\n+                        { \\\n+                        ASN1_put_object(&p,1,v,mtag,V_ASN1_CONTEXT_SPECIFIC); \\\n+                        i2d_ASN1_SET(a,&p,f,tag,V_ASN1_UNIVERSAL,IS_SET); \\\n+                        }\n+\n+# define M_ASN1_I2D_put_EXP_SEQUENCE_opt(a,f,mtag,tag,v) \\\n+                if ((a != NULL) && (sk_num(a) != 0)) \\\n+                        { \\\n+                        ASN1_put_object(&p,1,v,mtag,V_ASN1_CONTEXT_SPECIFIC); \\\n+                        i2d_ASN1_SET(a,&p,f,tag,V_ASN1_UNIVERSAL,IS_SEQUENCE); \\\n+                        }\n+\n+# define M_ASN1_I2D_put_EXP_SEQUENCE_opt_type(type,a,f,mtag,tag,v) \\\n+                if ((a != NULL) && (sk_##type##_num(a) != 0)) \\\n+                        { \\\n+                        ASN1_put_object(&p,1,v,mtag,V_ASN1_CONTEXT_SPECIFIC); \\\n+                        i2d_ASN1_SET_OF_##type(a,&p,f,tag,V_ASN1_UNIVERSAL, \\\n+                                               IS_SEQUENCE); \\\n+                        }\n+\n+# define M_ASN1_I2D_seq_total() \\\n+                r=ASN1_object_size(1,ret,V_ASN1_SEQUENCE); \\\n+                if (pp == NULL) return(r); \\\n+                p= *pp; \\\n+                ASN1_put_object(&p,1,ret,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL)\n+\n+# define M_ASN1_I2D_INF_seq_start(tag,ctx) \\\n+                *(p++)=(V_ASN1_CONSTRUCTED|(tag)|(ctx)); \\\n+                *(p++)=0x80\n+\n+# define M_ASN1_I2D_INF_seq_end() *(p++)=0x00; *(p++)=0x00\n+\n+# define M_ASN1_I2D_finish()     *pp=p; \\\n+                                return(r);\n+\n+int asn1_GetSequence(ASN1_const_CTX *c, long *length);\n+void asn1_add_error(const unsigned char *address, int offset);\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "99bc0eecf323cb1c7513cbb5595bf1a0178123f3",
            "filename": "deps/openssl/openssl/include/openssl/asn1t.h",
            "status": "added",
            "additions": 973,
            "deletions": 0,
            "changes": 973,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fasn1t.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fasn1t.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fasn1t.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,973 @@\n+/* asn1t.h */\n+/*\n+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project\n+ * 2000.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+#ifndef HEADER_ASN1T_H\n+# define HEADER_ASN1T_H\n+\n+# include <stddef.h>\n+# include <openssl/e_os2.h>\n+# include <openssl/asn1.h>\n+\n+# ifdef OPENSSL_BUILD_SHLIBCRYPTO\n+#  undef OPENSSL_EXTERN\n+#  define OPENSSL_EXTERN OPENSSL_EXPORT\n+# endif\n+\n+/* ASN1 template defines, structures and functions */\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION\n+\n+/* Macro to obtain ASN1_ADB pointer from a type (only used internally) */\n+#  define ASN1_ADB_ptr(iptr) ((const ASN1_ADB *)(iptr))\n+\n+/* Macros for start and end of ASN1_ITEM definition */\n+\n+#  define ASN1_ITEM_start(itname) \\\n+        OPENSSL_GLOBAL const ASN1_ITEM itname##_it = {\n+\n+#  define ASN1_ITEM_end(itname) \\\n+                };\n+\n+# else\n+\n+/* Macro to obtain ASN1_ADB pointer from a type (only used internally) */\n+#  define ASN1_ADB_ptr(iptr) ((const ASN1_ADB *)(iptr()))\n+\n+/* Macros for start and end of ASN1_ITEM definition */\n+\n+#  define ASN1_ITEM_start(itname) \\\n+        const ASN1_ITEM * itname##_it(void) \\\n+        { \\\n+                static const ASN1_ITEM local_it = {\n+\n+#  define ASN1_ITEM_end(itname) \\\n+                }; \\\n+        return &local_it; \\\n+        }\n+\n+# endif\n+\n+/* Macros to aid ASN1 template writing */\n+\n+# define ASN1_ITEM_TEMPLATE(tname) \\\n+        static const ASN1_TEMPLATE tname##_item_tt\n+\n+# define ASN1_ITEM_TEMPLATE_END(tname) \\\n+        ;\\\n+        ASN1_ITEM_start(tname) \\\n+                ASN1_ITYPE_PRIMITIVE,\\\n+                -1,\\\n+                &tname##_item_tt,\\\n+                0,\\\n+                NULL,\\\n+                0,\\\n+                #tname \\\n+        ASN1_ITEM_end(tname)\n+\n+/* This is a ASN1 type which just embeds a template */\n+\n+/*-\n+ * This pair helps declare a SEQUENCE. We can do:\n+ *\n+ *      ASN1_SEQUENCE(stname) = {\n+ *              ... SEQUENCE components ...\n+ *      } ASN1_SEQUENCE_END(stname)\n+ *\n+ *      This will produce an ASN1_ITEM called stname_it\n+ *      for a structure called stname.\n+ *\n+ *      If you want the same structure but a different\n+ *      name then use:\n+ *\n+ *      ASN1_SEQUENCE(itname) = {\n+ *              ... SEQUENCE components ...\n+ *      } ASN1_SEQUENCE_END_name(stname, itname)\n+ *\n+ *      This will create an item called itname_it using\n+ *      a structure called stname.\n+ */\n+\n+# define ASN1_SEQUENCE(tname) \\\n+        static const ASN1_TEMPLATE tname##_seq_tt[]\n+\n+# define ASN1_SEQUENCE_END(stname) ASN1_SEQUENCE_END_name(stname, stname)\n+\n+# define ASN1_SEQUENCE_END_name(stname, tname) \\\n+        ;\\\n+        ASN1_ITEM_start(tname) \\\n+                ASN1_ITYPE_SEQUENCE,\\\n+                V_ASN1_SEQUENCE,\\\n+                tname##_seq_tt,\\\n+                sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\\\n+                NULL,\\\n+                sizeof(stname),\\\n+                #stname \\\n+        ASN1_ITEM_end(tname)\n+\n+# define ASN1_NDEF_SEQUENCE(tname) \\\n+        ASN1_SEQUENCE(tname)\n+\n+# define ASN1_NDEF_SEQUENCE_cb(tname, cb) \\\n+        ASN1_SEQUENCE_cb(tname, cb)\n+\n+# define ASN1_SEQUENCE_cb(tname, cb) \\\n+        static const ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \\\n+        ASN1_SEQUENCE(tname)\n+\n+# define ASN1_BROKEN_SEQUENCE(tname) \\\n+        static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_BROKEN, 0, 0, 0, 0}; \\\n+        ASN1_SEQUENCE(tname)\n+\n+# define ASN1_SEQUENCE_ref(tname, cb, lck) \\\n+        static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_REFCOUNT, offsetof(tname, references), lck, cb, 0}; \\\n+        ASN1_SEQUENCE(tname)\n+\n+# define ASN1_SEQUENCE_enc(tname, enc, cb) \\\n+        static const ASN1_AUX tname##_aux = {NULL, ASN1_AFLG_ENCODING, 0, 0, cb, offsetof(tname, enc)}; \\\n+        ASN1_SEQUENCE(tname)\n+\n+# define ASN1_NDEF_SEQUENCE_END(tname) \\\n+        ;\\\n+        ASN1_ITEM_start(tname) \\\n+                ASN1_ITYPE_NDEF_SEQUENCE,\\\n+                V_ASN1_SEQUENCE,\\\n+                tname##_seq_tt,\\\n+                sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\\\n+                NULL,\\\n+                sizeof(tname),\\\n+                #tname \\\n+        ASN1_ITEM_end(tname)\n+\n+# define ASN1_BROKEN_SEQUENCE_END(stname) ASN1_SEQUENCE_END_ref(stname, stname)\n+\n+# define ASN1_SEQUENCE_END_enc(stname, tname) ASN1_SEQUENCE_END_ref(stname, tname)\n+\n+# define ASN1_SEQUENCE_END_cb(stname, tname) ASN1_SEQUENCE_END_ref(stname, tname)\n+\n+# define ASN1_SEQUENCE_END_ref(stname, tname) \\\n+        ;\\\n+        ASN1_ITEM_start(tname) \\\n+                ASN1_ITYPE_SEQUENCE,\\\n+                V_ASN1_SEQUENCE,\\\n+                tname##_seq_tt,\\\n+                sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\\\n+                &tname##_aux,\\\n+                sizeof(stname),\\\n+                #stname \\\n+        ASN1_ITEM_end(tname)\n+\n+# define ASN1_NDEF_SEQUENCE_END_cb(stname, tname) \\\n+        ;\\\n+        ASN1_ITEM_start(tname) \\\n+                ASN1_ITYPE_NDEF_SEQUENCE,\\\n+                V_ASN1_SEQUENCE,\\\n+                tname##_seq_tt,\\\n+                sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\\\n+                &tname##_aux,\\\n+                sizeof(stname),\\\n+                #stname \\\n+        ASN1_ITEM_end(tname)\n+\n+/*-\n+ * This pair helps declare a CHOICE type. We can do:\n+ *\n+ *      ASN1_CHOICE(chname) = {\n+ *              ... CHOICE options ...\n+ *      ASN1_CHOICE_END(chname)\n+ *\n+ *      This will produce an ASN1_ITEM called chname_it\n+ *      for a structure called chname. The structure\n+ *      definition must look like this:\n+ *      typedef struct {\n+ *              int type;\n+ *              union {\n+ *                      ASN1_SOMETHING *opt1;\n+ *                      ASN1_SOMEOTHER *opt2;\n+ *              } value;\n+ *      } chname;\n+ *\n+ *      the name of the selector must be 'type'.\n+ *      to use an alternative selector name use the\n+ *      ASN1_CHOICE_END_selector() version.\n+ */\n+\n+# define ASN1_CHOICE(tname) \\\n+        static const ASN1_TEMPLATE tname##_ch_tt[]\n+\n+# define ASN1_CHOICE_cb(tname, cb) \\\n+        static const ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \\\n+        ASN1_CHOICE(tname)\n+\n+# define ASN1_CHOICE_END(stname) ASN1_CHOICE_END_name(stname, stname)\n+\n+# define ASN1_CHOICE_END_name(stname, tname) ASN1_CHOICE_END_selector(stname, tname, type)\n+\n+# define ASN1_CHOICE_END_selector(stname, tname, selname) \\\n+        ;\\\n+        ASN1_ITEM_start(tname) \\\n+                ASN1_ITYPE_CHOICE,\\\n+                offsetof(stname,selname) ,\\\n+                tname##_ch_tt,\\\n+                sizeof(tname##_ch_tt) / sizeof(ASN1_TEMPLATE),\\\n+                NULL,\\\n+                sizeof(stname),\\\n+                #stname \\\n+        ASN1_ITEM_end(tname)\n+\n+# define ASN1_CHOICE_END_cb(stname, tname, selname) \\\n+        ;\\\n+        ASN1_ITEM_start(tname) \\\n+                ASN1_ITYPE_CHOICE,\\\n+                offsetof(stname,selname) ,\\\n+                tname##_ch_tt,\\\n+                sizeof(tname##_ch_tt) / sizeof(ASN1_TEMPLATE),\\\n+                &tname##_aux,\\\n+                sizeof(stname),\\\n+                #stname \\\n+        ASN1_ITEM_end(tname)\n+\n+/* This helps with the template wrapper form of ASN1_ITEM */\n+\n+# define ASN1_EX_TEMPLATE_TYPE(flags, tag, name, type) { \\\n+        (flags), (tag), 0,\\\n+        #name, ASN1_ITEM_ref(type) }\n+\n+/* These help with SEQUENCE or CHOICE components */\n+\n+/* used to declare other types */\n+\n+# define ASN1_EX_TYPE(flags, tag, stname, field, type) { \\\n+        (flags), (tag), offsetof(stname, field),\\\n+        #field, ASN1_ITEM_ref(type) }\n+\n+/* used when the structure is combined with the parent */\n+\n+# define ASN1_EX_COMBINE(flags, tag, type) { \\\n+        (flags)|ASN1_TFLG_COMBINE, (tag), 0, NULL, ASN1_ITEM_ref(type) }\n+\n+/* implicit and explicit helper macros */\n+\n+# define ASN1_IMP_EX(stname, field, type, tag, ex) \\\n+                ASN1_EX_TYPE(ASN1_TFLG_IMPLICIT | ex, tag, stname, field, type)\n+\n+# define ASN1_EXP_EX(stname, field, type, tag, ex) \\\n+                ASN1_EX_TYPE(ASN1_TFLG_EXPLICIT | ex, tag, stname, field, type)\n+\n+/* Any defined by macros: the field used is in the table itself */\n+\n+# ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION\n+#  define ASN1_ADB_OBJECT(tblname) { ASN1_TFLG_ADB_OID, -1, 0, #tblname, (const ASN1_ITEM *)&(tblname##_adb) }\n+#  define ASN1_ADB_INTEGER(tblname) { ASN1_TFLG_ADB_INT, -1, 0, #tblname, (const ASN1_ITEM *)&(tblname##_adb) }\n+# else\n+#  define ASN1_ADB_OBJECT(tblname) { ASN1_TFLG_ADB_OID, -1, 0, #tblname, tblname##_adb }\n+#  define ASN1_ADB_INTEGER(tblname) { ASN1_TFLG_ADB_INT, -1, 0, #tblname, tblname##_adb }\n+# endif\n+/* Plain simple type */\n+# define ASN1_SIMPLE(stname, field, type) ASN1_EX_TYPE(0,0, stname, field, type)\n+\n+/* OPTIONAL simple type */\n+# define ASN1_OPT(stname, field, type) ASN1_EX_TYPE(ASN1_TFLG_OPTIONAL, 0, stname, field, type)\n+\n+/* IMPLICIT tagged simple type */\n+# define ASN1_IMP(stname, field, type, tag) ASN1_IMP_EX(stname, field, type, tag, 0)\n+\n+/* IMPLICIT tagged OPTIONAL simple type */\n+# define ASN1_IMP_OPT(stname, field, type, tag) ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL)\n+\n+/* Same as above but EXPLICIT */\n+\n+# define ASN1_EXP(stname, field, type, tag) ASN1_EXP_EX(stname, field, type, tag, 0)\n+# define ASN1_EXP_OPT(stname, field, type, tag) ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL)\n+\n+/* SEQUENCE OF type */\n+# define ASN1_SEQUENCE_OF(stname, field, type) \\\n+                ASN1_EX_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, stname, field, type)\n+\n+/* OPTIONAL SEQUENCE OF */\n+# define ASN1_SEQUENCE_OF_OPT(stname, field, type) \\\n+                ASN1_EX_TYPE(ASN1_TFLG_SEQUENCE_OF|ASN1_TFLG_OPTIONAL, 0, stname, field, type)\n+\n+/* Same as above but for SET OF */\n+\n+# define ASN1_SET_OF(stname, field, type) \\\n+                ASN1_EX_TYPE(ASN1_TFLG_SET_OF, 0, stname, field, type)\n+\n+# define ASN1_SET_OF_OPT(stname, field, type) \\\n+                ASN1_EX_TYPE(ASN1_TFLG_SET_OF|ASN1_TFLG_OPTIONAL, 0, stname, field, type)\n+\n+/* Finally compound types of SEQUENCE, SET, IMPLICIT, EXPLICIT and OPTIONAL */\n+\n+# define ASN1_IMP_SET_OF(stname, field, type, tag) \\\n+                        ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF)\n+\n+# define ASN1_EXP_SET_OF(stname, field, type, tag) \\\n+                        ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF)\n+\n+# define ASN1_IMP_SET_OF_OPT(stname, field, type, tag) \\\n+                        ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF|ASN1_TFLG_OPTIONAL)\n+\n+# define ASN1_EXP_SET_OF_OPT(stname, field, type, tag) \\\n+                        ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SET_OF|ASN1_TFLG_OPTIONAL)\n+\n+# define ASN1_IMP_SEQUENCE_OF(stname, field, type, tag) \\\n+                        ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF)\n+\n+# define ASN1_IMP_SEQUENCE_OF_OPT(stname, field, type, tag) \\\n+                        ASN1_IMP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF|ASN1_TFLG_OPTIONAL)\n+\n+# define ASN1_EXP_SEQUENCE_OF(stname, field, type, tag) \\\n+                        ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF)\n+\n+# define ASN1_EXP_SEQUENCE_OF_OPT(stname, field, type, tag) \\\n+                        ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_SEQUENCE_OF|ASN1_TFLG_OPTIONAL)\n+\n+/* EXPLICIT using indefinite length constructed form */\n+# define ASN1_NDEF_EXP(stname, field, type, tag) \\\n+                        ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_NDEF)\n+\n+/* EXPLICIT OPTIONAL using indefinite length constructed form */\n+# define ASN1_NDEF_EXP_OPT(stname, field, type, tag) \\\n+                        ASN1_EXP_EX(stname, field, type, tag, ASN1_TFLG_OPTIONAL|ASN1_TFLG_NDEF)\n+\n+/* Macros for the ASN1_ADB structure */\n+\n+# define ASN1_ADB(name) \\\n+        static const ASN1_ADB_TABLE name##_adbtbl[]\n+\n+# ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION\n+\n+#  define ASN1_ADB_END(name, flags, field, app_table, def, none) \\\n+        ;\\\n+        static const ASN1_ADB name##_adb = {\\\n+                flags,\\\n+                offsetof(name, field),\\\n+                app_table,\\\n+                name##_adbtbl,\\\n+                sizeof(name##_adbtbl) / sizeof(ASN1_ADB_TABLE),\\\n+                def,\\\n+                none\\\n+        }\n+\n+# else\n+\n+#  define ASN1_ADB_END(name, flags, field, app_table, def, none) \\\n+        ;\\\n+        static const ASN1_ITEM *name##_adb(void) \\\n+        { \\\n+        static const ASN1_ADB internal_adb = \\\n+                {\\\n+                flags,\\\n+                offsetof(name, field),\\\n+                app_table,\\\n+                name##_adbtbl,\\\n+                sizeof(name##_adbtbl) / sizeof(ASN1_ADB_TABLE),\\\n+                def,\\\n+                none\\\n+                }; \\\n+                return (const ASN1_ITEM *) &internal_adb; \\\n+        } \\\n+        void dummy_function(void)\n+\n+# endif\n+\n+# define ADB_ENTRY(val, template) {val, template}\n+\n+# define ASN1_ADB_TEMPLATE(name) \\\n+        static const ASN1_TEMPLATE name##_tt\n+\n+/*\n+ * This is the ASN1 template structure that defines a wrapper round the\n+ * actual type. It determines the actual position of the field in the value\n+ * structure, various flags such as OPTIONAL and the field name.\n+ */\n+\n+struct ASN1_TEMPLATE_st {\n+    unsigned long flags;        /* Various flags */\n+    long tag;                   /* tag, not used if no tagging */\n+    unsigned long offset;       /* Offset of this field in structure */\n+# ifndef NO_ASN1_FIELD_NAMES\n+    const char *field_name;     /* Field name */\n+# endif\n+    ASN1_ITEM_EXP *item;        /* Relevant ASN1_ITEM or ASN1_ADB */\n+};\n+\n+/* Macro to extract ASN1_ITEM and ASN1_ADB pointer from ASN1_TEMPLATE */\n+\n+# define ASN1_TEMPLATE_item(t) (t->item_ptr)\n+# define ASN1_TEMPLATE_adb(t) (t->item_ptr)\n+\n+typedef struct ASN1_ADB_TABLE_st ASN1_ADB_TABLE;\n+typedef struct ASN1_ADB_st ASN1_ADB;\n+\n+struct ASN1_ADB_st {\n+    unsigned long flags;        /* Various flags */\n+    unsigned long offset;       /* Offset of selector field */\n+    STACK_OF(ASN1_ADB_TABLE) **app_items; /* Application defined items */\n+    const ASN1_ADB_TABLE *tbl;  /* Table of possible types */\n+    long tblcount;              /* Number of entries in tbl */\n+    const ASN1_TEMPLATE *default_tt; /* Type to use if no match */\n+    const ASN1_TEMPLATE *null_tt; /* Type to use if selector is NULL */\n+};\n+\n+struct ASN1_ADB_TABLE_st {\n+    long value;                 /* NID for an object or value for an int */\n+    const ASN1_TEMPLATE tt;     /* item for this value */\n+};\n+\n+/* template flags */\n+\n+/* Field is optional */\n+# define ASN1_TFLG_OPTIONAL      (0x1)\n+\n+/* Field is a SET OF */\n+# define ASN1_TFLG_SET_OF        (0x1 << 1)\n+\n+/* Field is a SEQUENCE OF */\n+# define ASN1_TFLG_SEQUENCE_OF   (0x2 << 1)\n+\n+/*\n+ * Special case: this refers to a SET OF that will be sorted into DER order\n+ * when encoded *and* the corresponding STACK will be modified to match the\n+ * new order.\n+ */\n+# define ASN1_TFLG_SET_ORDER     (0x3 << 1)\n+\n+/* Mask for SET OF or SEQUENCE OF */\n+# define ASN1_TFLG_SK_MASK       (0x3 << 1)\n+\n+/*\n+ * These flags mean the tag should be taken from the tag field. If EXPLICIT\n+ * then the underlying type is used for the inner tag.\n+ */\n+\n+/* IMPLICIT tagging */\n+# define ASN1_TFLG_IMPTAG        (0x1 << 3)\n+\n+/* EXPLICIT tagging, inner tag from underlying type */\n+# define ASN1_TFLG_EXPTAG        (0x2 << 3)\n+\n+# define ASN1_TFLG_TAG_MASK      (0x3 << 3)\n+\n+/* context specific IMPLICIT */\n+# define ASN1_TFLG_IMPLICIT      ASN1_TFLG_IMPTAG|ASN1_TFLG_CONTEXT\n+\n+/* context specific EXPLICIT */\n+# define ASN1_TFLG_EXPLICIT      ASN1_TFLG_EXPTAG|ASN1_TFLG_CONTEXT\n+\n+/*\n+ * If tagging is in force these determine the type of tag to use. Otherwise\n+ * the tag is determined by the underlying type. These values reflect the\n+ * actual octet format.\n+ */\n+\n+/* Universal tag */\n+# define ASN1_TFLG_UNIVERSAL     (0x0<<6)\n+/* Application tag */\n+# define ASN1_TFLG_APPLICATION   (0x1<<6)\n+/* Context specific tag */\n+# define ASN1_TFLG_CONTEXT       (0x2<<6)\n+/* Private tag */\n+# define ASN1_TFLG_PRIVATE       (0x3<<6)\n+\n+# define ASN1_TFLG_TAG_CLASS     (0x3<<6)\n+\n+/*\n+ * These are for ANY DEFINED BY type. In this case the 'item' field points to\n+ * an ASN1_ADB structure which contains a table of values to decode the\n+ * relevant type\n+ */\n+\n+# define ASN1_TFLG_ADB_MASK      (0x3<<8)\n+\n+# define ASN1_TFLG_ADB_OID       (0x1<<8)\n+\n+# define ASN1_TFLG_ADB_INT       (0x1<<9)\n+\n+/*\n+ * This flag means a parent structure is passed instead of the field: this is\n+ * useful is a SEQUENCE is being combined with a CHOICE for example. Since\n+ * this means the structure and item name will differ we need to use the\n+ * ASN1_CHOICE_END_name() macro for example.\n+ */\n+\n+# define ASN1_TFLG_COMBINE       (0x1<<10)\n+\n+/*\n+ * This flag when present in a SEQUENCE OF, SET OF or EXPLICIT causes\n+ * indefinite length constructed encoding to be used if required.\n+ */\n+\n+# define ASN1_TFLG_NDEF          (0x1<<11)\n+\n+/* This is the actual ASN1 item itself */\n+\n+struct ASN1_ITEM_st {\n+    char itype;                 /* The item type, primitive, SEQUENCE, CHOICE\n+                                 * or extern */\n+    long utype;                 /* underlying type */\n+    const ASN1_TEMPLATE *templates; /* If SEQUENCE or CHOICE this contains\n+                                     * the contents */\n+    long tcount;                /* Number of templates if SEQUENCE or CHOICE */\n+    const void *funcs;          /* functions that handle this type */\n+    long size;                  /* Structure size (usually) */\n+# ifndef NO_ASN1_FIELD_NAMES\n+    const char *sname;          /* Structure name */\n+# endif\n+};\n+\n+/*-\n+ * These are values for the itype field and\n+ * determine how the type is interpreted.\n+ *\n+ * For PRIMITIVE types the underlying type\n+ * determines the behaviour if items is NULL.\n+ *\n+ * Otherwise templates must contain a single\n+ * template and the type is treated in the\n+ * same way as the type specified in the template.\n+ *\n+ * For SEQUENCE types the templates field points\n+ * to the members, the size field is the\n+ * structure size.\n+ *\n+ * For CHOICE types the templates field points\n+ * to each possible member (typically a union)\n+ * and the 'size' field is the offset of the\n+ * selector.\n+ *\n+ * The 'funcs' field is used for application\n+ * specific functions.\n+ *\n+ * For COMPAT types the funcs field gives a\n+ * set of functions that handle this type, this\n+ * supports the old d2i, i2d convention.\n+ *\n+ * The EXTERN type uses a new style d2i/i2d.\n+ * The new style should be used where possible\n+ * because it avoids things like the d2i IMPLICIT\n+ * hack.\n+ *\n+ * MSTRING is a multiple string type, it is used\n+ * for a CHOICE of character strings where the\n+ * actual strings all occupy an ASN1_STRING\n+ * structure. In this case the 'utype' field\n+ * has a special meaning, it is used as a mask\n+ * of acceptable types using the B_ASN1 constants.\n+ *\n+ * NDEF_SEQUENCE is the same as SEQUENCE except\n+ * that it will use indefinite length constructed\n+ * encoding if requested.\n+ *\n+ */\n+\n+# define ASN1_ITYPE_PRIMITIVE            0x0\n+\n+# define ASN1_ITYPE_SEQUENCE             0x1\n+\n+# define ASN1_ITYPE_CHOICE               0x2\n+\n+# define ASN1_ITYPE_COMPAT               0x3\n+\n+# define ASN1_ITYPE_EXTERN               0x4\n+\n+# define ASN1_ITYPE_MSTRING              0x5\n+\n+# define ASN1_ITYPE_NDEF_SEQUENCE        0x6\n+\n+/*\n+ * Cache for ASN1 tag and length, so we don't keep re-reading it for things\n+ * like CHOICE\n+ */\n+\n+struct ASN1_TLC_st {\n+    char valid;                 /* Values below are valid */\n+    int ret;                    /* return value */\n+    long plen;                  /* length */\n+    int ptag;                   /* class value */\n+    int pclass;                 /* class value */\n+    int hdrlen;                 /* header length */\n+};\n+\n+/* Typedefs for ASN1 function pointers */\n+\n+typedef ASN1_VALUE *ASN1_new_func(void);\n+typedef void ASN1_free_func(ASN1_VALUE *a);\n+typedef ASN1_VALUE *ASN1_d2i_func(ASN1_VALUE **a, const unsigned char **in,\n+                                  long length);\n+typedef int ASN1_i2d_func(ASN1_VALUE *a, unsigned char **in);\n+\n+typedef int ASN1_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\n+                        const ASN1_ITEM *it, int tag, int aclass, char opt,\n+                        ASN1_TLC *ctx);\n+\n+typedef int ASN1_ex_i2d(ASN1_VALUE **pval, unsigned char **out,\n+                        const ASN1_ITEM *it, int tag, int aclass);\n+typedef int ASN1_ex_new_func(ASN1_VALUE **pval, const ASN1_ITEM *it);\n+typedef void ASN1_ex_free_func(ASN1_VALUE **pval, const ASN1_ITEM *it);\n+\n+typedef int ASN1_ex_print_func(BIO *out, ASN1_VALUE **pval,\n+                               int indent, const char *fname,\n+                               const ASN1_PCTX *pctx);\n+\n+typedef int ASN1_primitive_i2c(ASN1_VALUE **pval, unsigned char *cont,\n+                               int *putype, const ASN1_ITEM *it);\n+typedef int ASN1_primitive_c2i(ASN1_VALUE **pval, const unsigned char *cont,\n+                               int len, int utype, char *free_cont,\n+                               const ASN1_ITEM *it);\n+typedef int ASN1_primitive_print(BIO *out, ASN1_VALUE **pval,\n+                                 const ASN1_ITEM *it, int indent,\n+                                 const ASN1_PCTX *pctx);\n+\n+typedef struct ASN1_COMPAT_FUNCS_st {\n+    ASN1_new_func *asn1_new;\n+    ASN1_free_func *asn1_free;\n+    ASN1_d2i_func *asn1_d2i;\n+    ASN1_i2d_func *asn1_i2d;\n+} ASN1_COMPAT_FUNCS;\n+\n+typedef struct ASN1_EXTERN_FUNCS_st {\n+    void *app_data;\n+    ASN1_ex_new_func *asn1_ex_new;\n+    ASN1_ex_free_func *asn1_ex_free;\n+    ASN1_ex_free_func *asn1_ex_clear;\n+    ASN1_ex_d2i *asn1_ex_d2i;\n+    ASN1_ex_i2d *asn1_ex_i2d;\n+    ASN1_ex_print_func *asn1_ex_print;\n+} ASN1_EXTERN_FUNCS;\n+\n+typedef struct ASN1_PRIMITIVE_FUNCS_st {\n+    void *app_data;\n+    unsigned long flags;\n+    ASN1_ex_new_func *prim_new;\n+    ASN1_ex_free_func *prim_free;\n+    ASN1_ex_free_func *prim_clear;\n+    ASN1_primitive_c2i *prim_c2i;\n+    ASN1_primitive_i2c *prim_i2c;\n+    ASN1_primitive_print *prim_print;\n+} ASN1_PRIMITIVE_FUNCS;\n+\n+/*\n+ * This is the ASN1_AUX structure: it handles various miscellaneous\n+ * requirements. For example the use of reference counts and an informational\n+ * callback. The \"informational callback\" is called at various points during\n+ * the ASN1 encoding and decoding. It can be used to provide minor\n+ * customisation of the structures used. This is most useful where the\n+ * supplied routines *almost* do the right thing but need some extra help at\n+ * a few points. If the callback returns zero then it is assumed a fatal\n+ * error has occurred and the main operation should be abandoned. If major\n+ * changes in the default behaviour are required then an external type is\n+ * more appropriate.\n+ */\n+\n+typedef int ASN1_aux_cb(int operation, ASN1_VALUE **in, const ASN1_ITEM *it,\n+                        void *exarg);\n+\n+typedef struct ASN1_AUX_st {\n+    void *app_data;\n+    int flags;\n+    int ref_offset;             /* Offset of reference value */\n+    int ref_lock;               /* Lock type to use */\n+    ASN1_aux_cb *asn1_cb;\n+    int enc_offset;             /* Offset of ASN1_ENCODING structure */\n+} ASN1_AUX;\n+\n+/* For print related callbacks exarg points to this structure */\n+typedef struct ASN1_PRINT_ARG_st {\n+    BIO *out;\n+    int indent;\n+    const ASN1_PCTX *pctx;\n+} ASN1_PRINT_ARG;\n+\n+/* For streaming related callbacks exarg points to this structure */\n+typedef struct ASN1_STREAM_ARG_st {\n+    /* BIO to stream through */\n+    BIO *out;\n+    /* BIO with filters appended */\n+    BIO *ndef_bio;\n+    /* Streaming I/O boundary */\n+    unsigned char **boundary;\n+} ASN1_STREAM_ARG;\n+\n+/* Flags in ASN1_AUX */\n+\n+/* Use a reference count */\n+# define ASN1_AFLG_REFCOUNT      1\n+/* Save the encoding of structure (useful for signatures) */\n+# define ASN1_AFLG_ENCODING      2\n+/* The Sequence length is invalid */\n+# define ASN1_AFLG_BROKEN        4\n+\n+/* operation values for asn1_cb */\n+\n+# define ASN1_OP_NEW_PRE         0\n+# define ASN1_OP_NEW_POST        1\n+# define ASN1_OP_FREE_PRE        2\n+# define ASN1_OP_FREE_POST       3\n+# define ASN1_OP_D2I_PRE         4\n+# define ASN1_OP_D2I_POST        5\n+# define ASN1_OP_I2D_PRE         6\n+# define ASN1_OP_I2D_POST        7\n+# define ASN1_OP_PRINT_PRE       8\n+# define ASN1_OP_PRINT_POST      9\n+# define ASN1_OP_STREAM_PRE      10\n+# define ASN1_OP_STREAM_POST     11\n+# define ASN1_OP_DETACHED_PRE    12\n+# define ASN1_OP_DETACHED_POST   13\n+\n+/* Macro to implement a primitive type */\n+# define IMPLEMENT_ASN1_TYPE(stname) IMPLEMENT_ASN1_TYPE_ex(stname, stname, 0)\n+# define IMPLEMENT_ASN1_TYPE_ex(itname, vname, ex) \\\n+                                ASN1_ITEM_start(itname) \\\n+                                        ASN1_ITYPE_PRIMITIVE, V_##vname, NULL, 0, NULL, ex, #itname \\\n+                                ASN1_ITEM_end(itname)\n+\n+/* Macro to implement a multi string type */\n+# define IMPLEMENT_ASN1_MSTRING(itname, mask) \\\n+                                ASN1_ITEM_start(itname) \\\n+                                        ASN1_ITYPE_MSTRING, mask, NULL, 0, NULL, sizeof(ASN1_STRING), #itname \\\n+                                ASN1_ITEM_end(itname)\n+\n+/* Macro to implement an ASN1_ITEM in terms of old style funcs */\n+\n+# define IMPLEMENT_COMPAT_ASN1(sname) IMPLEMENT_COMPAT_ASN1_type(sname, V_ASN1_SEQUENCE)\n+\n+# define IMPLEMENT_COMPAT_ASN1_type(sname, tag) \\\n+        static const ASN1_COMPAT_FUNCS sname##_ff = { \\\n+                (ASN1_new_func *)sname##_new, \\\n+                (ASN1_free_func *)sname##_free, \\\n+                (ASN1_d2i_func *)d2i_##sname, \\\n+                (ASN1_i2d_func *)i2d_##sname, \\\n+        }; \\\n+        ASN1_ITEM_start(sname) \\\n+                ASN1_ITYPE_COMPAT, \\\n+                tag, \\\n+                NULL, \\\n+                0, \\\n+                &sname##_ff, \\\n+                0, \\\n+                #sname \\\n+        ASN1_ITEM_end(sname)\n+\n+# define IMPLEMENT_EXTERN_ASN1(sname, tag, fptrs) \\\n+        ASN1_ITEM_start(sname) \\\n+                ASN1_ITYPE_EXTERN, \\\n+                tag, \\\n+                NULL, \\\n+                0, \\\n+                &fptrs, \\\n+                0, \\\n+                #sname \\\n+        ASN1_ITEM_end(sname)\n+\n+/* Macro to implement standard functions in terms of ASN1_ITEM structures */\n+\n+# define IMPLEMENT_ASN1_FUNCTIONS(stname) IMPLEMENT_ASN1_FUNCTIONS_fname(stname, stname, stname)\n+\n+# define IMPLEMENT_ASN1_FUNCTIONS_name(stname, itname) IMPLEMENT_ASN1_FUNCTIONS_fname(stname, itname, itname)\n+\n+# define IMPLEMENT_ASN1_FUNCTIONS_ENCODE_name(stname, itname) \\\n+                        IMPLEMENT_ASN1_FUNCTIONS_ENCODE_fname(stname, itname, itname)\n+\n+# define IMPLEMENT_STATIC_ASN1_ALLOC_FUNCTIONS(stname) \\\n+                IMPLEMENT_ASN1_ALLOC_FUNCTIONS_pfname(static, stname, stname, stname)\n+\n+# define IMPLEMENT_ASN1_ALLOC_FUNCTIONS(stname) \\\n+                IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, stname, stname)\n+\n+# define IMPLEMENT_ASN1_ALLOC_FUNCTIONS_pfname(pre, stname, itname, fname) \\\n+        pre stname *fname##_new(void) \\\n+        { \\\n+                return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \\\n+        } \\\n+        pre void fname##_free(stname *a) \\\n+        { \\\n+                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \\\n+        }\n+\n+# define IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname) \\\n+        stname *fname##_new(void) \\\n+        { \\\n+                return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \\\n+        } \\\n+        void fname##_free(stname *a) \\\n+        { \\\n+                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \\\n+        }\n+\n+# define IMPLEMENT_ASN1_FUNCTIONS_fname(stname, itname, fname) \\\n+        IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \\\n+        IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname)\n+\n+# define IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \\\n+        stname *d2i_##fname(stname **a, const unsigned char **in, long len) \\\n+        { \\\n+                return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\\\n+        } \\\n+        int i2d_##fname(stname *a, unsigned char **out) \\\n+        { \\\n+                return ASN1_item_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(itname));\\\n+        }\n+\n+# define IMPLEMENT_ASN1_NDEF_FUNCTION(stname) \\\n+        int i2d_##stname##_NDEF(stname *a, unsigned char **out) \\\n+        { \\\n+                return ASN1_item_ndef_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(stname));\\\n+        }\n+\n+/*\n+ * This includes evil casts to remove const: they will go away when full ASN1\n+ * constification is done.\n+ */\n+# define IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(stname, itname, fname) \\\n+        stname *d2i_##fname(stname **a, const unsigned char **in, long len) \\\n+        { \\\n+                return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\\\n+        } \\\n+        int i2d_##fname(const stname *a, unsigned char **out) \\\n+        { \\\n+                return ASN1_item_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(itname));\\\n+        }\n+\n+# define IMPLEMENT_ASN1_DUP_FUNCTION(stname) \\\n+        stname * stname##_dup(stname *x) \\\n+        { \\\n+        return ASN1_item_dup(ASN1_ITEM_rptr(stname), x); \\\n+        }\n+\n+# define IMPLEMENT_ASN1_PRINT_FUNCTION(stname) \\\n+        IMPLEMENT_ASN1_PRINT_FUNCTION_fname(stname, stname, stname)\n+\n+# define IMPLEMENT_ASN1_PRINT_FUNCTION_fname(stname, itname, fname) \\\n+        int fname##_print_ctx(BIO *out, stname *x, int indent, \\\n+                                                const ASN1_PCTX *pctx) \\\n+        { \\\n+                return ASN1_item_print(out, (ASN1_VALUE *)x, indent, \\\n+                        ASN1_ITEM_rptr(itname), pctx); \\\n+        }\n+\n+# define IMPLEMENT_ASN1_FUNCTIONS_const(name) \\\n+                IMPLEMENT_ASN1_FUNCTIONS_const_fname(name, name, name)\n+\n+# define IMPLEMENT_ASN1_FUNCTIONS_const_fname(stname, itname, fname) \\\n+        IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(stname, itname, fname) \\\n+        IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname)\n+\n+/* external definitions for primitive types */\n+\n+DECLARE_ASN1_ITEM(ASN1_BOOLEAN)\n+DECLARE_ASN1_ITEM(ASN1_TBOOLEAN)\n+DECLARE_ASN1_ITEM(ASN1_FBOOLEAN)\n+DECLARE_ASN1_ITEM(ASN1_SEQUENCE)\n+DECLARE_ASN1_ITEM(CBIGNUM)\n+DECLARE_ASN1_ITEM(BIGNUM)\n+DECLARE_ASN1_ITEM(LONG)\n+DECLARE_ASN1_ITEM(ZLONG)\n+\n+DECLARE_STACK_OF(ASN1_VALUE)\n+\n+/* Functions used internally by the ASN1 code */\n+\n+int ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it);\n+void ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it);\n+int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);\n+int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it);\n+\n+void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);\n+int ASN1_template_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\n+                      const ASN1_TEMPLATE *tt);\n+int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\n+                     const ASN1_ITEM *it, int tag, int aclass, char opt,\n+                     ASN1_TLC *ctx);\n+\n+int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,\n+                     const ASN1_ITEM *it, int tag, int aclass);\n+int ASN1_template_i2d(ASN1_VALUE **pval, unsigned char **out,\n+                      const ASN1_TEMPLATE *tt);\n+void ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it);\n+\n+int asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cont, int *putype,\n+                const ASN1_ITEM *it);\n+int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,\n+                int utype, char *free_cont, const ASN1_ITEM *it);\n+\n+int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it);\n+int asn1_set_choice_selector(ASN1_VALUE **pval, int value,\n+                             const ASN1_ITEM *it);\n+\n+ASN1_VALUE **asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt);\n+\n+const ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,\n+                                 int nullerr);\n+\n+int asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it);\n+\n+void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it);\n+void asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it);\n+int asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,\n+                     const ASN1_ITEM *it);\n+int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,\n+                  const ASN1_ITEM *it);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "8f2438cdad70184bd1ea71c181ee16b2734d7ec3",
            "filename": "deps/openssl/openssl/include/openssl/bio.h",
            "status": "added",
            "additions": 883,
            "deletions": 0,
            "changes": 883,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fbio.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fbio.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fbio.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,883 @@\n+/* crypto/bio/bio.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_BIO_H\n+# define HEADER_BIO_H\n+\n+# include <openssl/e_os2.h>\n+\n+# ifndef OPENSSL_NO_FP_API\n+#  include <stdio.h>\n+# endif\n+# include <stdarg.h>\n+\n+# include <openssl/crypto.h>\n+\n+# ifndef OPENSSL_NO_SCTP\n+#  ifndef OPENSSL_SYS_VMS\n+#   include <stdint.h>\n+#  else\n+#   include <inttypes.h>\n+#  endif\n+# endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* These are the 'types' of BIOs */\n+# define BIO_TYPE_NONE           0\n+# define BIO_TYPE_MEM            (1|0x0400)\n+# define BIO_TYPE_FILE           (2|0x0400)\n+\n+# define BIO_TYPE_FD             (4|0x0400|0x0100)\n+# define BIO_TYPE_SOCKET         (5|0x0400|0x0100)\n+# define BIO_TYPE_NULL           (6|0x0400)\n+# define BIO_TYPE_SSL            (7|0x0200)\n+# define BIO_TYPE_MD             (8|0x0200)/* passive filter */\n+# define BIO_TYPE_BUFFER         (9|0x0200)/* filter */\n+# define BIO_TYPE_CIPHER         (10|0x0200)/* filter */\n+# define BIO_TYPE_BASE64         (11|0x0200)/* filter */\n+# define BIO_TYPE_CONNECT        (12|0x0400|0x0100)/* socket - connect */\n+# define BIO_TYPE_ACCEPT         (13|0x0400|0x0100)/* socket for accept */\n+# define BIO_TYPE_PROXY_CLIENT   (14|0x0200)/* client proxy BIO */\n+# define BIO_TYPE_PROXY_SERVER   (15|0x0200)/* server proxy BIO */\n+# define BIO_TYPE_NBIO_TEST      (16|0x0200)/* server proxy BIO */\n+# define BIO_TYPE_NULL_FILTER    (17|0x0200)\n+# define BIO_TYPE_BER            (18|0x0200)/* BER -> bin filter */\n+# define BIO_TYPE_BIO            (19|0x0400)/* (half a) BIO pair */\n+# define BIO_TYPE_LINEBUFFER     (20|0x0200)/* filter */\n+# define BIO_TYPE_DGRAM          (21|0x0400|0x0100)\n+# ifndef OPENSSL_NO_SCTP\n+#  define BIO_TYPE_DGRAM_SCTP     (24|0x0400|0x0100)\n+# endif\n+# define BIO_TYPE_ASN1           (22|0x0200)/* filter */\n+# define BIO_TYPE_COMP           (23|0x0200)/* filter */\n+\n+# define BIO_TYPE_DESCRIPTOR     0x0100/* socket, fd, connect or accept */\n+# define BIO_TYPE_FILTER         0x0200\n+# define BIO_TYPE_SOURCE_SINK    0x0400\n+\n+/*\n+ * BIO_FILENAME_READ|BIO_CLOSE to open or close on free.\n+ * BIO_set_fp(in,stdin,BIO_NOCLOSE);\n+ */\n+# define BIO_NOCLOSE             0x00\n+# define BIO_CLOSE               0x01\n+\n+/*\n+ * These are used in the following macros and are passed to BIO_ctrl()\n+ */\n+# define BIO_CTRL_RESET          1/* opt - rewind/zero etc */\n+# define BIO_CTRL_EOF            2/* opt - are we at the eof */\n+# define BIO_CTRL_INFO           3/* opt - extra tit-bits */\n+# define BIO_CTRL_SET            4/* man - set the 'IO' type */\n+# define BIO_CTRL_GET            5/* man - get the 'IO' type */\n+# define BIO_CTRL_PUSH           6/* opt - internal, used to signify change */\n+# define BIO_CTRL_POP            7/* opt - internal, used to signify change */\n+# define BIO_CTRL_GET_CLOSE      8/* man - set the 'close' on free */\n+# define BIO_CTRL_SET_CLOSE      9/* man - set the 'close' on free */\n+# define BIO_CTRL_PENDING        10/* opt - is their more data buffered */\n+# define BIO_CTRL_FLUSH          11/* opt - 'flush' buffered output */\n+# define BIO_CTRL_DUP            12/* man - extra stuff for 'duped' BIO */\n+# define BIO_CTRL_WPENDING       13/* opt - number of bytes still to write */\n+/* callback is int cb(BIO *bio,state,ret); */\n+# define BIO_CTRL_SET_CALLBACK   14/* opt - set callback function */\n+# define BIO_CTRL_GET_CALLBACK   15/* opt - set callback function */\n+\n+# define BIO_CTRL_SET_FILENAME   30/* BIO_s_file special */\n+\n+/* dgram BIO stuff */\n+# define BIO_CTRL_DGRAM_CONNECT       31/* BIO dgram special */\n+# define BIO_CTRL_DGRAM_SET_CONNECTED 32/* allow for an externally connected\n+                                         * socket to be passed in */\n+# define BIO_CTRL_DGRAM_SET_RECV_TIMEOUT 33/* setsockopt, essentially */\n+# define BIO_CTRL_DGRAM_GET_RECV_TIMEOUT 34/* getsockopt, essentially */\n+# define BIO_CTRL_DGRAM_SET_SEND_TIMEOUT 35/* setsockopt, essentially */\n+# define BIO_CTRL_DGRAM_GET_SEND_TIMEOUT 36/* getsockopt, essentially */\n+\n+# define BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP 37/* flag whether the last */\n+# define BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP 38/* I/O operation tiemd out */\n+\n+/* #ifdef IP_MTU_DISCOVER */\n+# define BIO_CTRL_DGRAM_MTU_DISCOVER       39/* set DF bit on egress packets */\n+/* #endif */\n+\n+# define BIO_CTRL_DGRAM_QUERY_MTU          40/* as kernel for current MTU */\n+# define BIO_CTRL_DGRAM_GET_FALLBACK_MTU   47\n+# define BIO_CTRL_DGRAM_GET_MTU            41/* get cached value for MTU */\n+# define BIO_CTRL_DGRAM_SET_MTU            42/* set cached value for MTU.\n+                                              * want to use this if asking\n+                                              * the kernel fails */\n+\n+# define BIO_CTRL_DGRAM_MTU_EXCEEDED       43/* check whether the MTU was\n+                                              * exceed in the previous write\n+                                              * operation */\n+\n+# define BIO_CTRL_DGRAM_GET_PEER           46\n+# define BIO_CTRL_DGRAM_SET_PEER           44/* Destination for the data */\n+\n+# define BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT   45/* Next DTLS handshake timeout\n+                                              * to adjust socket timeouts */\n+# define BIO_CTRL_DGRAM_SET_DONT_FRAG      48\n+\n+# define BIO_CTRL_DGRAM_GET_MTU_OVERHEAD   49\n+\n+# ifndef OPENSSL_NO_SCTP\n+/* SCTP stuff */\n+#  define BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE    50\n+#  define BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY                51\n+#  define BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY               52\n+#  define BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD               53\n+#  define BIO_CTRL_DGRAM_SCTP_GET_SNDINFO         60\n+#  define BIO_CTRL_DGRAM_SCTP_SET_SNDINFO         61\n+#  define BIO_CTRL_DGRAM_SCTP_GET_RCVINFO         62\n+#  define BIO_CTRL_DGRAM_SCTP_SET_RCVINFO         63\n+#  define BIO_CTRL_DGRAM_SCTP_GET_PRINFO                  64\n+#  define BIO_CTRL_DGRAM_SCTP_SET_PRINFO                  65\n+#  define BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN               70\n+# endif\n+\n+/* modifiers */\n+# define BIO_FP_READ             0x02\n+# define BIO_FP_WRITE            0x04\n+# define BIO_FP_APPEND           0x08\n+# define BIO_FP_TEXT             0x10\n+\n+# define BIO_FLAGS_READ          0x01\n+# define BIO_FLAGS_WRITE         0x02\n+# define BIO_FLAGS_IO_SPECIAL    0x04\n+# define BIO_FLAGS_RWS (BIO_FLAGS_READ|BIO_FLAGS_WRITE|BIO_FLAGS_IO_SPECIAL)\n+# define BIO_FLAGS_SHOULD_RETRY  0x08\n+# ifndef BIO_FLAGS_UPLINK\n+/*\n+ * \"UPLINK\" flag denotes file descriptors provided by application. It\n+ * defaults to 0, as most platforms don't require UPLINK interface.\n+ */\n+#  define BIO_FLAGS_UPLINK        0\n+# endif\n+\n+/* Used in BIO_gethostbyname() */\n+# define BIO_GHBN_CTRL_HITS              1\n+# define BIO_GHBN_CTRL_MISSES            2\n+# define BIO_GHBN_CTRL_CACHE_SIZE        3\n+# define BIO_GHBN_CTRL_GET_ENTRY         4\n+# define BIO_GHBN_CTRL_FLUSH             5\n+\n+/* Mostly used in the SSL BIO */\n+/*-\n+ * Not used anymore\n+ * #define BIO_FLAGS_PROTOCOL_DELAYED_READ 0x10\n+ * #define BIO_FLAGS_PROTOCOL_DELAYED_WRITE 0x20\n+ * #define BIO_FLAGS_PROTOCOL_STARTUP   0x40\n+ */\n+\n+# define BIO_FLAGS_BASE64_NO_NL  0x100\n+\n+/*\n+ * This is used with memory BIOs: it means we shouldn't free up or change the\n+ * data in any way.\n+ */\n+# define BIO_FLAGS_MEM_RDONLY    0x200\n+\n+typedef struct bio_st BIO;\n+\n+void BIO_set_flags(BIO *b, int flags);\n+int BIO_test_flags(const BIO *b, int flags);\n+void BIO_clear_flags(BIO *b, int flags);\n+\n+# define BIO_get_flags(b) BIO_test_flags(b, ~(0x0))\n+# define BIO_set_retry_special(b) \\\n+                BIO_set_flags(b, (BIO_FLAGS_IO_SPECIAL|BIO_FLAGS_SHOULD_RETRY))\n+# define BIO_set_retry_read(b) \\\n+                BIO_set_flags(b, (BIO_FLAGS_READ|BIO_FLAGS_SHOULD_RETRY))\n+# define BIO_set_retry_write(b) \\\n+                BIO_set_flags(b, (BIO_FLAGS_WRITE|BIO_FLAGS_SHOULD_RETRY))\n+\n+/* These are normally used internally in BIOs */\n+# define BIO_clear_retry_flags(b) \\\n+                BIO_clear_flags(b, (BIO_FLAGS_RWS|BIO_FLAGS_SHOULD_RETRY))\n+# define BIO_get_retry_flags(b) \\\n+                BIO_test_flags(b, (BIO_FLAGS_RWS|BIO_FLAGS_SHOULD_RETRY))\n+\n+/* These should be used by the application to tell why we should retry */\n+# define BIO_should_read(a)              BIO_test_flags(a, BIO_FLAGS_READ)\n+# define BIO_should_write(a)             BIO_test_flags(a, BIO_FLAGS_WRITE)\n+# define BIO_should_io_special(a)        BIO_test_flags(a, BIO_FLAGS_IO_SPECIAL)\n+# define BIO_retry_type(a)               BIO_test_flags(a, BIO_FLAGS_RWS)\n+# define BIO_should_retry(a)             BIO_test_flags(a, BIO_FLAGS_SHOULD_RETRY)\n+\n+/*\n+ * The next three are used in conjunction with the BIO_should_io_special()\n+ * condition.  After this returns true, BIO *BIO_get_retry_BIO(BIO *bio, int\n+ * *reason); will walk the BIO stack and return the 'reason' for the special\n+ * and the offending BIO. Given a BIO, BIO_get_retry_reason(bio) will return\n+ * the code.\n+ */\n+/*\n+ * Returned from the SSL bio when the certificate retrieval code had an error\n+ */\n+# define BIO_RR_SSL_X509_LOOKUP          0x01\n+/* Returned from the connect BIO when a connect would have blocked */\n+# define BIO_RR_CONNECT                  0x02\n+/* Returned from the accept BIO when an accept would have blocked */\n+# define BIO_RR_ACCEPT                   0x03\n+\n+/* These are passed by the BIO callback */\n+# define BIO_CB_FREE     0x01\n+# define BIO_CB_READ     0x02\n+# define BIO_CB_WRITE    0x03\n+# define BIO_CB_PUTS     0x04\n+# define BIO_CB_GETS     0x05\n+# define BIO_CB_CTRL     0x06\n+\n+/*\n+ * The callback is called before and after the underling operation, The\n+ * BIO_CB_RETURN flag indicates if it is after the call\n+ */\n+# define BIO_CB_RETURN   0x80\n+# define BIO_CB_return(a) ((a)|BIO_CB_RETURN)\n+# define BIO_cb_pre(a)   (!((a)&BIO_CB_RETURN))\n+# define BIO_cb_post(a)  ((a)&BIO_CB_RETURN)\n+\n+long (*BIO_get_callback(const BIO *b)) (struct bio_st *, int, const char *,\n+                                        int, long, long);\n+void BIO_set_callback(BIO *b,\n+                      long (*callback) (struct bio_st *, int, const char *,\n+                                        int, long, long));\n+char *BIO_get_callback_arg(const BIO *b);\n+void BIO_set_callback_arg(BIO *b, char *arg);\n+\n+const char *BIO_method_name(const BIO *b);\n+int BIO_method_type(const BIO *b);\n+\n+typedef void bio_info_cb (struct bio_st *, int, const char *, int, long,\n+                          long);\n+\n+typedef struct bio_method_st {\n+    int type;\n+    const char *name;\n+    int (*bwrite) (BIO *, const char *, int);\n+    int (*bread) (BIO *, char *, int);\n+    int (*bputs) (BIO *, const char *);\n+    int (*bgets) (BIO *, char *, int);\n+    long (*ctrl) (BIO *, int, long, void *);\n+    int (*create) (BIO *);\n+    int (*destroy) (BIO *);\n+    long (*callback_ctrl) (BIO *, int, bio_info_cb *);\n+} BIO_METHOD;\n+\n+struct bio_st {\n+    BIO_METHOD *method;\n+    /* bio, mode, argp, argi, argl, ret */\n+    long (*callback) (struct bio_st *, int, const char *, int, long, long);\n+    char *cb_arg;               /* first argument for the callback */\n+    int init;\n+    int shutdown;\n+    int flags;                  /* extra storage */\n+    int retry_reason;\n+    int num;\n+    void *ptr;\n+    struct bio_st *next_bio;    /* used by filter BIOs */\n+    struct bio_st *prev_bio;    /* used by filter BIOs */\n+    int references;\n+    unsigned long num_read;\n+    unsigned long num_write;\n+    CRYPTO_EX_DATA ex_data;\n+};\n+\n+DECLARE_STACK_OF(BIO)\n+\n+typedef struct bio_f_buffer_ctx_struct {\n+    /*-\n+     * Buffers are setup like this:\n+     *\n+     * <---------------------- size ----------------------->\n+     * +---------------------------------------------------+\n+     * | consumed | remaining          | free space        |\n+     * +---------------------------------------------------+\n+     * <-- off --><------- len ------->\n+     */\n+    /*- BIO *bio; *//*\n+     * this is now in the BIO struct\n+     */\n+    int ibuf_size;              /* how big is the input buffer */\n+    int obuf_size;              /* how big is the output buffer */\n+    char *ibuf;                 /* the char array */\n+    int ibuf_len;               /* how many bytes are in it */\n+    int ibuf_off;               /* write/read offset */\n+    char *obuf;                 /* the char array */\n+    int obuf_len;               /* how many bytes are in it */\n+    int obuf_off;               /* write/read offset */\n+} BIO_F_BUFFER_CTX;\n+\n+/* Prefix and suffix callback in ASN1 BIO */\n+typedef int asn1_ps_func (BIO *b, unsigned char **pbuf, int *plen,\n+                          void *parg);\n+\n+# ifndef OPENSSL_NO_SCTP\n+/* SCTP parameter structs */\n+struct bio_dgram_sctp_sndinfo {\n+    uint16_t snd_sid;\n+    uint16_t snd_flags;\n+    uint32_t snd_ppid;\n+    uint32_t snd_context;\n+};\n+\n+struct bio_dgram_sctp_rcvinfo {\n+    uint16_t rcv_sid;\n+    uint16_t rcv_ssn;\n+    uint16_t rcv_flags;\n+    uint32_t rcv_ppid;\n+    uint32_t rcv_tsn;\n+    uint32_t rcv_cumtsn;\n+    uint32_t rcv_context;\n+};\n+\n+struct bio_dgram_sctp_prinfo {\n+    uint16_t pr_policy;\n+    uint32_t pr_value;\n+};\n+# endif\n+\n+/* connect BIO stuff */\n+# define BIO_CONN_S_BEFORE               1\n+# define BIO_CONN_S_GET_IP               2\n+# define BIO_CONN_S_GET_PORT             3\n+# define BIO_CONN_S_CREATE_SOCKET        4\n+# define BIO_CONN_S_CONNECT              5\n+# define BIO_CONN_S_OK                   6\n+# define BIO_CONN_S_BLOCKED_CONNECT      7\n+# define BIO_CONN_S_NBIO                 8\n+/*\n+ * #define BIO_CONN_get_param_hostname BIO_ctrl\n+ */\n+\n+# define BIO_C_SET_CONNECT                       100\n+# define BIO_C_DO_STATE_MACHINE                  101\n+# define BIO_C_SET_NBIO                          102\n+# define BIO_C_SET_PROXY_PARAM                   103\n+# define BIO_C_SET_FD                            104\n+# define BIO_C_GET_FD                            105\n+# define BIO_C_SET_FILE_PTR                      106\n+# define BIO_C_GET_FILE_PTR                      107\n+# define BIO_C_SET_FILENAME                      108\n+# define BIO_C_SET_SSL                           109\n+# define BIO_C_GET_SSL                           110\n+# define BIO_C_SET_MD                            111\n+# define BIO_C_GET_MD                            112\n+# define BIO_C_GET_CIPHER_STATUS                 113\n+# define BIO_C_SET_BUF_MEM                       114\n+# define BIO_C_GET_BUF_MEM_PTR                   115\n+# define BIO_C_GET_BUFF_NUM_LINES                116\n+# define BIO_C_SET_BUFF_SIZE                     117\n+# define BIO_C_SET_ACCEPT                        118\n+# define BIO_C_SSL_MODE                          119\n+# define BIO_C_GET_MD_CTX                        120\n+# define BIO_C_GET_PROXY_PARAM                   121\n+# define BIO_C_SET_BUFF_READ_DATA                122/* data to read first */\n+# define BIO_C_GET_CONNECT                       123\n+# define BIO_C_GET_ACCEPT                        124\n+# define BIO_C_SET_SSL_RENEGOTIATE_BYTES         125\n+# define BIO_C_GET_SSL_NUM_RENEGOTIATES          126\n+# define BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT       127\n+# define BIO_C_FILE_SEEK                         128\n+# define BIO_C_GET_CIPHER_CTX                    129\n+# define BIO_C_SET_BUF_MEM_EOF_RETURN            130/* return end of input\n+                                                     * value */\n+# define BIO_C_SET_BIND_MODE                     131\n+# define BIO_C_GET_BIND_MODE                     132\n+# define BIO_C_FILE_TELL                         133\n+# define BIO_C_GET_SOCKS                         134\n+# define BIO_C_SET_SOCKS                         135\n+\n+# define BIO_C_SET_WRITE_BUF_SIZE                136/* for BIO_s_bio */\n+# define BIO_C_GET_WRITE_BUF_SIZE                137\n+# define BIO_C_MAKE_BIO_PAIR                     138\n+# define BIO_C_DESTROY_BIO_PAIR                  139\n+# define BIO_C_GET_WRITE_GUARANTEE               140\n+# define BIO_C_GET_READ_REQUEST                  141\n+# define BIO_C_SHUTDOWN_WR                       142\n+# define BIO_C_NREAD0                            143\n+# define BIO_C_NREAD                             144\n+# define BIO_C_NWRITE0                           145\n+# define BIO_C_NWRITE                            146\n+# define BIO_C_RESET_READ_REQUEST                147\n+# define BIO_C_SET_MD_CTX                        148\n+\n+# define BIO_C_SET_PREFIX                        149\n+# define BIO_C_GET_PREFIX                        150\n+# define BIO_C_SET_SUFFIX                        151\n+# define BIO_C_GET_SUFFIX                        152\n+\n+# define BIO_C_SET_EX_ARG                        153\n+# define BIO_C_GET_EX_ARG                        154\n+\n+# define BIO_set_app_data(s,arg)         BIO_set_ex_data(s,0,arg)\n+# define BIO_get_app_data(s)             BIO_get_ex_data(s,0)\n+\n+/* BIO_s_connect() and BIO_s_socks4a_connect() */\n+# define BIO_set_conn_hostname(b,name) BIO_ctrl(b,BIO_C_SET_CONNECT,0,(char *)name)\n+# define BIO_set_conn_port(b,port) BIO_ctrl(b,BIO_C_SET_CONNECT,1,(char *)port)\n+# define BIO_set_conn_ip(b,ip)     BIO_ctrl(b,BIO_C_SET_CONNECT,2,(char *)ip)\n+# define BIO_set_conn_int_port(b,port) BIO_ctrl(b,BIO_C_SET_CONNECT,3,(char *)port)\n+# define BIO_get_conn_hostname(b)  BIO_ptr_ctrl(b,BIO_C_GET_CONNECT,0)\n+# define BIO_get_conn_port(b)      BIO_ptr_ctrl(b,BIO_C_GET_CONNECT,1)\n+# define BIO_get_conn_ip(b)               BIO_ptr_ctrl(b,BIO_C_GET_CONNECT,2)\n+# define BIO_get_conn_int_port(b) BIO_ctrl(b,BIO_C_GET_CONNECT,3,NULL)\n+\n+# define BIO_set_nbio(b,n)       BIO_ctrl(b,BIO_C_SET_NBIO,(n),NULL)\n+\n+/* BIO_s_accept() */\n+# define BIO_set_accept_port(b,name) BIO_ctrl(b,BIO_C_SET_ACCEPT,0,(char *)name)\n+# define BIO_get_accept_port(b)  BIO_ptr_ctrl(b,BIO_C_GET_ACCEPT,0)\n+/* #define BIO_set_nbio(b,n)    BIO_ctrl(b,BIO_C_SET_NBIO,(n),NULL) */\n+# define BIO_set_nbio_accept(b,n) BIO_ctrl(b,BIO_C_SET_ACCEPT,1,(n)?(void *)\"a\":NULL)\n+# define BIO_set_accept_bios(b,bio) BIO_ctrl(b,BIO_C_SET_ACCEPT,2,(char *)bio)\n+\n+# define BIO_BIND_NORMAL                 0\n+# define BIO_BIND_REUSEADDR_IF_UNUSED    1\n+# define BIO_BIND_REUSEADDR              2\n+# define BIO_set_bind_mode(b,mode) BIO_ctrl(b,BIO_C_SET_BIND_MODE,mode,NULL)\n+# define BIO_get_bind_mode(b,mode) BIO_ctrl(b,BIO_C_GET_BIND_MODE,0,NULL)\n+\n+/* BIO_s_accept() and BIO_s_connect() */\n+# define BIO_do_connect(b)       BIO_do_handshake(b)\n+# define BIO_do_accept(b)        BIO_do_handshake(b)\n+# define BIO_do_handshake(b)     BIO_ctrl(b,BIO_C_DO_STATE_MACHINE,0,NULL)\n+\n+/* BIO_s_proxy_client() */\n+# define BIO_set_url(b,url)      BIO_ctrl(b,BIO_C_SET_PROXY_PARAM,0,(char *)(url))\n+# define BIO_set_proxies(b,p)    BIO_ctrl(b,BIO_C_SET_PROXY_PARAM,1,(char *)(p))\n+/* BIO_set_nbio(b,n) */\n+# define BIO_set_filter_bio(b,s) BIO_ctrl(b,BIO_C_SET_PROXY_PARAM,2,(char *)(s))\n+/* BIO *BIO_get_filter_bio(BIO *bio); */\n+# define BIO_set_proxy_cb(b,cb) BIO_callback_ctrl(b,BIO_C_SET_PROXY_PARAM,3,(void *(*cb)()))\n+# define BIO_set_proxy_header(b,sk) BIO_ctrl(b,BIO_C_SET_PROXY_PARAM,4,(char *)sk)\n+# define BIO_set_no_connect_return(b,bool) BIO_int_ctrl(b,BIO_C_SET_PROXY_PARAM,5,bool)\n+\n+# define BIO_get_proxy_header(b,skp) BIO_ctrl(b,BIO_C_GET_PROXY_PARAM,0,(char *)skp)\n+# define BIO_get_proxies(b,pxy_p) BIO_ctrl(b,BIO_C_GET_PROXY_PARAM,1,(char *)(pxy_p))\n+# define BIO_get_url(b,url)      BIO_ctrl(b,BIO_C_GET_PROXY_PARAM,2,(char *)(url))\n+# define BIO_get_no_connect_return(b)    BIO_ctrl(b,BIO_C_GET_PROXY_PARAM,5,NULL)\n+\n+/* BIO_s_datagram(), BIO_s_fd(), BIO_s_socket(), BIO_s_accept() and BIO_s_connect() */\n+# define BIO_set_fd(b,fd,c)      BIO_int_ctrl(b,BIO_C_SET_FD,c,fd)\n+# define BIO_get_fd(b,c)         BIO_ctrl(b,BIO_C_GET_FD,0,(char *)c)\n+\n+/* BIO_s_file() */\n+# define BIO_set_fp(b,fp,c)      BIO_ctrl(b,BIO_C_SET_FILE_PTR,c,(char *)fp)\n+# define BIO_get_fp(b,fpp)       BIO_ctrl(b,BIO_C_GET_FILE_PTR,0,(char *)fpp)\n+\n+/* BIO_s_fd() and BIO_s_file() */\n+# define BIO_seek(b,ofs) (int)BIO_ctrl(b,BIO_C_FILE_SEEK,ofs,NULL)\n+# define BIO_tell(b)     (int)BIO_ctrl(b,BIO_C_FILE_TELL,0,NULL)\n+\n+/*\n+ * name is cast to lose const, but might be better to route through a\n+ * function so we can do it safely\n+ */\n+# ifdef CONST_STRICT\n+/*\n+ * If you are wondering why this isn't defined, its because CONST_STRICT is\n+ * purely a compile-time kludge to allow const to be checked.\n+ */\n+int BIO_read_filename(BIO *b, const char *name);\n+# else\n+#  define BIO_read_filename(b,name) BIO_ctrl(b,BIO_C_SET_FILENAME, \\\n+                BIO_CLOSE|BIO_FP_READ,(char *)name)\n+# endif\n+# define BIO_write_filename(b,name) BIO_ctrl(b,BIO_C_SET_FILENAME, \\\n+                BIO_CLOSE|BIO_FP_WRITE,name)\n+# define BIO_append_filename(b,name) BIO_ctrl(b,BIO_C_SET_FILENAME, \\\n+                BIO_CLOSE|BIO_FP_APPEND,name)\n+# define BIO_rw_filename(b,name) BIO_ctrl(b,BIO_C_SET_FILENAME, \\\n+                BIO_CLOSE|BIO_FP_READ|BIO_FP_WRITE,name)\n+\n+/*\n+ * WARNING WARNING, this ups the reference count on the read bio of the SSL\n+ * structure.  This is because the ssl read BIO is now pointed to by the\n+ * next_bio field in the bio.  So when you free the BIO, make sure you are\n+ * doing a BIO_free_all() to catch the underlying BIO.\n+ */\n+# define BIO_set_ssl(b,ssl,c)    BIO_ctrl(b,BIO_C_SET_SSL,c,(char *)ssl)\n+# define BIO_get_ssl(b,sslp)     BIO_ctrl(b,BIO_C_GET_SSL,0,(char *)sslp)\n+# define BIO_set_ssl_mode(b,client)      BIO_ctrl(b,BIO_C_SSL_MODE,client,NULL)\n+# define BIO_set_ssl_renegotiate_bytes(b,num) \\\n+        BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_BYTES,num,NULL)\n+# define BIO_get_num_renegotiates(b) \\\n+        BIO_ctrl(b,BIO_C_GET_SSL_NUM_RENEGOTIATES,0,NULL)\n+# define BIO_set_ssl_renegotiate_timeout(b,seconds) \\\n+        BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT,seconds,NULL)\n+\n+/* defined in evp.h */\n+/* #define BIO_set_md(b,md)     BIO_ctrl(b,BIO_C_SET_MD,1,(char *)md) */\n+\n+# define BIO_get_mem_data(b,pp)  BIO_ctrl(b,BIO_CTRL_INFO,0,(char *)pp)\n+# define BIO_set_mem_buf(b,bm,c) BIO_ctrl(b,BIO_C_SET_BUF_MEM,c,(char *)bm)\n+# define BIO_get_mem_ptr(b,pp)   BIO_ctrl(b,BIO_C_GET_BUF_MEM_PTR,0,(char *)pp)\n+# define BIO_set_mem_eof_return(b,v) \\\n+                                BIO_ctrl(b,BIO_C_SET_BUF_MEM_EOF_RETURN,v,NULL)\n+\n+/* For the BIO_f_buffer() type */\n+# define BIO_get_buffer_num_lines(b)     BIO_ctrl(b,BIO_C_GET_BUFF_NUM_LINES,0,NULL)\n+# define BIO_set_buffer_size(b,size)     BIO_ctrl(b,BIO_C_SET_BUFF_SIZE,size,NULL)\n+# define BIO_set_read_buffer_size(b,size) BIO_int_ctrl(b,BIO_C_SET_BUFF_SIZE,size,0)\n+# define BIO_set_write_buffer_size(b,size) BIO_int_ctrl(b,BIO_C_SET_BUFF_SIZE,size,1)\n+# define BIO_set_buffer_read_data(b,buf,num) BIO_ctrl(b,BIO_C_SET_BUFF_READ_DATA,num,buf)\n+\n+/* Don't use the next one unless you know what you are doing :-) */\n+# define BIO_dup_state(b,ret)    BIO_ctrl(b,BIO_CTRL_DUP,0,(char *)(ret))\n+\n+# define BIO_reset(b)            (int)BIO_ctrl(b,BIO_CTRL_RESET,0,NULL)\n+# define BIO_eof(b)              (int)BIO_ctrl(b,BIO_CTRL_EOF,0,NULL)\n+# define BIO_set_close(b,c)      (int)BIO_ctrl(b,BIO_CTRL_SET_CLOSE,(c),NULL)\n+# define BIO_get_close(b)        (int)BIO_ctrl(b,BIO_CTRL_GET_CLOSE,0,NULL)\n+# define BIO_pending(b)          (int)BIO_ctrl(b,BIO_CTRL_PENDING,0,NULL)\n+# define BIO_wpending(b)         (int)BIO_ctrl(b,BIO_CTRL_WPENDING,0,NULL)\n+/* ...pending macros have inappropriate return type */\n+size_t BIO_ctrl_pending(BIO *b);\n+size_t BIO_ctrl_wpending(BIO *b);\n+# define BIO_flush(b)            (int)BIO_ctrl(b,BIO_CTRL_FLUSH,0,NULL)\n+# define BIO_get_info_callback(b,cbp) (int)BIO_ctrl(b,BIO_CTRL_GET_CALLBACK,0, \\\n+                                                   cbp)\n+# define BIO_set_info_callback(b,cb) (int)BIO_callback_ctrl(b,BIO_CTRL_SET_CALLBACK,cb)\n+\n+/* For the BIO_f_buffer() type */\n+# define BIO_buffer_get_num_lines(b) BIO_ctrl(b,BIO_CTRL_GET,0,NULL)\n+\n+/* For BIO_s_bio() */\n+# define BIO_set_write_buf_size(b,size) (int)BIO_ctrl(b,BIO_C_SET_WRITE_BUF_SIZE,size,NULL)\n+# define BIO_get_write_buf_size(b,size) (size_t)BIO_ctrl(b,BIO_C_GET_WRITE_BUF_SIZE,size,NULL)\n+# define BIO_make_bio_pair(b1,b2)   (int)BIO_ctrl(b1,BIO_C_MAKE_BIO_PAIR,0,b2)\n+# define BIO_destroy_bio_pair(b)    (int)BIO_ctrl(b,BIO_C_DESTROY_BIO_PAIR,0,NULL)\n+# define BIO_shutdown_wr(b) (int)BIO_ctrl(b, BIO_C_SHUTDOWN_WR, 0, NULL)\n+/* macros with inappropriate type -- but ...pending macros use int too: */\n+# define BIO_get_write_guarantee(b) (int)BIO_ctrl(b,BIO_C_GET_WRITE_GUARANTEE,0,NULL)\n+# define BIO_get_read_request(b)    (int)BIO_ctrl(b,BIO_C_GET_READ_REQUEST,0,NULL)\n+size_t BIO_ctrl_get_write_guarantee(BIO *b);\n+size_t BIO_ctrl_get_read_request(BIO *b);\n+int BIO_ctrl_reset_read_request(BIO *b);\n+\n+/* ctrl macros for dgram */\n+# define BIO_ctrl_dgram_connect(b,peer)  \\\n+                     (int)BIO_ctrl(b,BIO_CTRL_DGRAM_CONNECT,0, (char *)peer)\n+# define BIO_ctrl_set_connected(b, state, peer) \\\n+         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_SET_CONNECTED, state, (char *)peer)\n+# define BIO_dgram_recv_timedout(b) \\\n+         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP, 0, NULL)\n+# define BIO_dgram_send_timedout(b) \\\n+         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP, 0, NULL)\n+# define BIO_dgram_get_peer(b,peer) \\\n+         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_GET_PEER, 0, (char *)peer)\n+# define BIO_dgram_set_peer(b,peer) \\\n+         (int)BIO_ctrl(b, BIO_CTRL_DGRAM_SET_PEER, 0, (char *)peer)\n+# define BIO_dgram_get_mtu_overhead(b) \\\n+         (unsigned int)BIO_ctrl((b), BIO_CTRL_DGRAM_GET_MTU_OVERHEAD, 0, NULL)\n+\n+/* These two aren't currently implemented */\n+/* int BIO_get_ex_num(BIO *bio); */\n+/* void BIO_set_ex_free_func(BIO *bio,int idx,void (*cb)()); */\n+int BIO_set_ex_data(BIO *bio, int idx, void *data);\n+void *BIO_get_ex_data(BIO *bio, int idx);\n+int BIO_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\n+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);\n+unsigned long BIO_number_read(BIO *bio);\n+unsigned long BIO_number_written(BIO *bio);\n+\n+/* For BIO_f_asn1() */\n+int BIO_asn1_set_prefix(BIO *b, asn1_ps_func *prefix,\n+                        asn1_ps_func *prefix_free);\n+int BIO_asn1_get_prefix(BIO *b, asn1_ps_func **pprefix,\n+                        asn1_ps_func **pprefix_free);\n+int BIO_asn1_set_suffix(BIO *b, asn1_ps_func *suffix,\n+                        asn1_ps_func *suffix_free);\n+int BIO_asn1_get_suffix(BIO *b, asn1_ps_func **psuffix,\n+                        asn1_ps_func **psuffix_free);\n+\n+# ifndef OPENSSL_NO_FP_API\n+BIO_METHOD *BIO_s_file(void);\n+BIO *BIO_new_file(const char *filename, const char *mode);\n+BIO *BIO_new_fp(FILE *stream, int close_flag);\n+#  define BIO_s_file_internal    BIO_s_file\n+# endif\n+BIO *BIO_new(BIO_METHOD *type);\n+int BIO_set(BIO *a, BIO_METHOD *type);\n+int BIO_free(BIO *a);\n+void BIO_vfree(BIO *a);\n+int BIO_read(BIO *b, void *data, int len);\n+int BIO_gets(BIO *bp, char *buf, int size);\n+int BIO_write(BIO *b, const void *data, int len);\n+int BIO_puts(BIO *bp, const char *buf);\n+int BIO_indent(BIO *b, int indent, int max);\n+long BIO_ctrl(BIO *bp, int cmd, long larg, void *parg);\n+long BIO_callback_ctrl(BIO *b, int cmd,\n+                       void (*fp) (struct bio_st *, int, const char *, int,\n+                                   long, long));\n+char *BIO_ptr_ctrl(BIO *bp, int cmd, long larg);\n+long BIO_int_ctrl(BIO *bp, int cmd, long larg, int iarg);\n+BIO *BIO_push(BIO *b, BIO *append);\n+BIO *BIO_pop(BIO *b);\n+void BIO_free_all(BIO *a);\n+BIO *BIO_find_type(BIO *b, int bio_type);\n+BIO *BIO_next(BIO *b);\n+BIO *BIO_get_retry_BIO(BIO *bio, int *reason);\n+int BIO_get_retry_reason(BIO *bio);\n+BIO *BIO_dup_chain(BIO *in);\n+\n+int BIO_nread0(BIO *bio, char **buf);\n+int BIO_nread(BIO *bio, char **buf, int num);\n+int BIO_nwrite0(BIO *bio, char **buf);\n+int BIO_nwrite(BIO *bio, char **buf, int num);\n+\n+long BIO_debug_callback(BIO *bio, int cmd, const char *argp, int argi,\n+                        long argl, long ret);\n+\n+BIO_METHOD *BIO_s_mem(void);\n+BIO *BIO_new_mem_buf(const void *buf, int len);\n+BIO_METHOD *BIO_s_socket(void);\n+BIO_METHOD *BIO_s_connect(void);\n+BIO_METHOD *BIO_s_accept(void);\n+BIO_METHOD *BIO_s_fd(void);\n+# ifndef OPENSSL_SYS_OS2\n+BIO_METHOD *BIO_s_log(void);\n+# endif\n+BIO_METHOD *BIO_s_bio(void);\n+BIO_METHOD *BIO_s_null(void);\n+BIO_METHOD *BIO_f_null(void);\n+BIO_METHOD *BIO_f_buffer(void);\n+# ifdef OPENSSL_SYS_VMS\n+BIO_METHOD *BIO_f_linebuffer(void);\n+# endif\n+BIO_METHOD *BIO_f_nbio_test(void);\n+# ifndef OPENSSL_NO_DGRAM\n+BIO_METHOD *BIO_s_datagram(void);\n+#  ifndef OPENSSL_NO_SCTP\n+BIO_METHOD *BIO_s_datagram_sctp(void);\n+#  endif\n+# endif\n+\n+/* BIO_METHOD *BIO_f_ber(void); */\n+\n+int BIO_sock_should_retry(int i);\n+int BIO_sock_non_fatal_error(int error);\n+int BIO_dgram_non_fatal_error(int error);\n+\n+int BIO_fd_should_retry(int i);\n+int BIO_fd_non_fatal_error(int error);\n+int BIO_dump_cb(int (*cb) (const void *data, size_t len, void *u),\n+                void *u, const char *s, int len);\n+int BIO_dump_indent_cb(int (*cb) (const void *data, size_t len, void *u),\n+                       void *u, const char *s, int len, int indent);\n+int BIO_dump(BIO *b, const char *bytes, int len);\n+int BIO_dump_indent(BIO *b, const char *bytes, int len, int indent);\n+# ifndef OPENSSL_NO_FP_API\n+int BIO_dump_fp(FILE *fp, const char *s, int len);\n+int BIO_dump_indent_fp(FILE *fp, const char *s, int len, int indent);\n+# endif\n+int BIO_hex_string(BIO *out, int indent, int width, unsigned char *data,\n+                   int datalen);\n+\n+struct hostent *BIO_gethostbyname(const char *name);\n+/*-\n+ * We might want a thread-safe interface too:\n+ * struct hostent *BIO_gethostbyname_r(const char *name,\n+ *     struct hostent *result, void *buffer, size_t buflen);\n+ * or something similar (caller allocates a struct hostent,\n+ * pointed to by \"result\", and additional buffer space for the various\n+ * substructures; if the buffer does not suffice, NULL is returned\n+ * and an appropriate error code is set).\n+ */\n+int BIO_sock_error(int sock);\n+int BIO_socket_ioctl(int fd, long type, void *arg);\n+int BIO_socket_nbio(int fd, int mode);\n+int BIO_get_port(const char *str, unsigned short *port_ptr);\n+int BIO_get_host_ip(const char *str, unsigned char *ip);\n+int BIO_get_accept_socket(char *host_port, int mode);\n+int BIO_accept(int sock, char **ip_port);\n+int BIO_sock_init(void);\n+void BIO_sock_cleanup(void);\n+int BIO_set_tcp_ndelay(int sock, int turn_on);\n+\n+BIO *BIO_new_socket(int sock, int close_flag);\n+BIO *BIO_new_dgram(int fd, int close_flag);\n+# ifndef OPENSSL_NO_SCTP\n+BIO *BIO_new_dgram_sctp(int fd, int close_flag);\n+int BIO_dgram_is_sctp(BIO *bio);\n+int BIO_dgram_sctp_notification_cb(BIO *b,\n+                                   void (*handle_notifications) (BIO *bio,\n+                                                                 void\n+                                                                 *context,\n+                                                                 void *buf),\n+                                   void *context);\n+int BIO_dgram_sctp_wait_for_dry(BIO *b);\n+int BIO_dgram_sctp_msg_waiting(BIO *b);\n+# endif\n+BIO *BIO_new_fd(int fd, int close_flag);\n+BIO *BIO_new_connect(const char *host_port);\n+BIO *BIO_new_accept(const char *host_port);\n+\n+int BIO_new_bio_pair(BIO **bio1, size_t writebuf1,\n+                     BIO **bio2, size_t writebuf2);\n+/*\n+ * If successful, returns 1 and in *bio1, *bio2 two BIO pair endpoints.\n+ * Otherwise returns 0 and sets *bio1 and *bio2 to NULL. Size 0 uses default\n+ * value.\n+ */\n+\n+void BIO_copy_next_retry(BIO *b);\n+\n+/*\n+ * long BIO_ghbn_ctrl(int cmd,int iarg,char *parg);\n+ */\n+\n+# ifdef __GNUC__\n+#  define __bio_h__attr__ __attribute__\n+# else\n+#  define __bio_h__attr__(x)\n+# endif\n+int BIO_printf(BIO *bio, const char *format, ...)\n+__bio_h__attr__((__format__(__printf__, 2, 3)));\n+int BIO_vprintf(BIO *bio, const char *format, va_list args)\n+__bio_h__attr__((__format__(__printf__, 2, 0)));\n+int BIO_snprintf(char *buf, size_t n, const char *format, ...)\n+__bio_h__attr__((__format__(__printf__, 3, 4)));\n+int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)\n+__bio_h__attr__((__format__(__printf__, 3, 0)));\n+# undef __bio_h__attr__\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_BIO_strings(void);\n+\n+/* Error codes for the BIO functions. */\n+\n+/* Function codes. */\n+# define BIO_F_ACPT_STATE                                 100\n+# define BIO_F_BIO_ACCEPT                                 101\n+# define BIO_F_BIO_BER_GET_HEADER                         102\n+# define BIO_F_BIO_CALLBACK_CTRL                          131\n+# define BIO_F_BIO_CTRL                                   103\n+# define BIO_F_BIO_GETHOSTBYNAME                          120\n+# define BIO_F_BIO_GETS                                   104\n+# define BIO_F_BIO_GET_ACCEPT_SOCKET                      105\n+# define BIO_F_BIO_GET_HOST_IP                            106\n+# define BIO_F_BIO_GET_PORT                               107\n+# define BIO_F_BIO_MAKE_PAIR                              121\n+# define BIO_F_BIO_NEW                                    108\n+# define BIO_F_BIO_NEW_FILE                               109\n+# define BIO_F_BIO_NEW_MEM_BUF                            126\n+# define BIO_F_BIO_NREAD                                  123\n+# define BIO_F_BIO_NREAD0                                 124\n+# define BIO_F_BIO_NWRITE                                 125\n+# define BIO_F_BIO_NWRITE0                                122\n+# define BIO_F_BIO_PUTS                                   110\n+# define BIO_F_BIO_READ                                   111\n+# define BIO_F_BIO_SOCK_INIT                              112\n+# define BIO_F_BIO_WRITE                                  113\n+# define BIO_F_BUFFER_CTRL                                114\n+# define BIO_F_CONN_CTRL                                  127\n+# define BIO_F_CONN_STATE                                 115\n+# define BIO_F_DGRAM_SCTP_READ                            132\n+# define BIO_F_DGRAM_SCTP_WRITE                           133\n+# define BIO_F_FILE_CTRL                                  116\n+# define BIO_F_FILE_READ                                  130\n+# define BIO_F_LINEBUFFER_CTRL                            129\n+# define BIO_F_MEM_READ                                   128\n+# define BIO_F_MEM_WRITE                                  117\n+# define BIO_F_SSL_NEW                                    118\n+# define BIO_F_WSASTARTUP                                 119\n+\n+/* Reason codes. */\n+# define BIO_R_ACCEPT_ERROR                               100\n+# define BIO_R_BAD_FOPEN_MODE                             101\n+# define BIO_R_BAD_HOSTNAME_LOOKUP                        102\n+# define BIO_R_BROKEN_PIPE                                124\n+# define BIO_R_CONNECT_ERROR                              103\n+# define BIO_R_EOF_ON_MEMORY_BIO                          127\n+# define BIO_R_ERROR_SETTING_NBIO                         104\n+# define BIO_R_ERROR_SETTING_NBIO_ON_ACCEPTED_SOCKET      105\n+# define BIO_R_ERROR_SETTING_NBIO_ON_ACCEPT_SOCKET        106\n+# define BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET          107\n+# define BIO_R_INVALID_ARGUMENT                           125\n+# define BIO_R_INVALID_IP_ADDRESS                         108\n+# define BIO_R_IN_USE                                     123\n+# define BIO_R_KEEPALIVE                                  109\n+# define BIO_R_NBIO_CONNECT_ERROR                         110\n+# define BIO_R_NO_ACCEPT_PORT_SPECIFIED                   111\n+# define BIO_R_NO_HOSTNAME_SPECIFIED                      112\n+# define BIO_R_NO_PORT_DEFINED                            113\n+# define BIO_R_NO_PORT_SPECIFIED                          114\n+# define BIO_R_NO_SUCH_FILE                               128\n+# define BIO_R_NULL_PARAMETER                             115\n+# define BIO_R_TAG_MISMATCH                               116\n+# define BIO_R_UNABLE_TO_BIND_SOCKET                      117\n+# define BIO_R_UNABLE_TO_CREATE_SOCKET                    118\n+# define BIO_R_UNABLE_TO_LISTEN_SOCKET                    119\n+# define BIO_R_UNINITIALIZED                              120\n+# define BIO_R_UNSUPPORTED_METHOD                         121\n+# define BIO_R_WRITE_TO_READ_ONLY_BIO                     126\n+# define BIO_R_WSASTARTUP                                 122\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "832930272cf08070c2a8d6a7582b4fcecbab410f",
            "filename": "deps/openssl/openssl/include/openssl/blowfish.h",
            "status": "added",
            "additions": 130,
            "deletions": 0,
            "changes": 130,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fblowfish.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fblowfish.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fblowfish.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,130 @@\n+/* crypto/bf/blowfish.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_BLOWFISH_H\n+# define HEADER_BLOWFISH_H\n+\n+# include <openssl/e_os2.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# ifdef OPENSSL_NO_BF\n+#  error BF is disabled.\n+# endif\n+\n+# define BF_ENCRYPT      1\n+# define BF_DECRYPT      0\n+\n+/*-\n+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n+ * ! BF_LONG has to be at least 32 bits wide. If it's wider, then !\n+ * ! BF_LONG_LOG2 has to be defined along.                        !\n+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n+ */\n+\n+# if defined(__LP32__)\n+#  define BF_LONG unsigned long\n+# elif defined(OPENSSL_SYS_CRAY) || defined(__ILP64__)\n+#  define BF_LONG unsigned long\n+#  define BF_LONG_LOG2 3\n+/*\n+ * _CRAY note. I could declare short, but I have no idea what impact\n+ * does it have on performance on none-T3E machines. I could declare\n+ * int, but at least on C90 sizeof(int) can be chosen at compile time.\n+ * So I've chosen long...\n+ *                                      <appro@fy.chalmers.se>\n+ */\n+# else\n+#  define BF_LONG unsigned int\n+# endif\n+\n+# define BF_ROUNDS       16\n+# define BF_BLOCK        8\n+\n+typedef struct bf_key_st {\n+    BF_LONG P[BF_ROUNDS + 2];\n+    BF_LONG S[4 * 256];\n+} BF_KEY;\n+\n+# ifdef OPENSSL_FIPS\n+void private_BF_set_key(BF_KEY *key, int len, const unsigned char *data);\n+# endif\n+void BF_set_key(BF_KEY *key, int len, const unsigned char *data);\n+\n+void BF_encrypt(BF_LONG *data, const BF_KEY *key);\n+void BF_decrypt(BF_LONG *data, const BF_KEY *key);\n+\n+void BF_ecb_encrypt(const unsigned char *in, unsigned char *out,\n+                    const BF_KEY *key, int enc);\n+void BF_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\n+                    const BF_KEY *schedule, unsigned char *ivec, int enc);\n+void BF_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n+                      long length, const BF_KEY *schedule,\n+                      unsigned char *ivec, int *num, int enc);\n+void BF_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n+                      long length, const BF_KEY *schedule,\n+                      unsigned char *ivec, int *num);\n+const char *BF_options(void);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "633d1b1f60136e73a04d41dc701dc4548f7a010e",
            "filename": "deps/openssl/openssl/include/openssl/bn.h",
            "status": "added",
            "additions": 951,
            "deletions": 0,
            "changes": 951,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fbn.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fbn.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fbn.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,951 @@\n+/* crypto/bn/bn.h */\n+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+/* ====================================================================\n+ * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+/* ====================================================================\n+ * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\n+ *\n+ * Portions of the attached software (\"Contribution\") are developed by\n+ * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.\n+ *\n+ * The Contribution is licensed pursuant to the Eric Young open source\n+ * license provided above.\n+ *\n+ * The binary polynomial arithmetic software is originally written by\n+ * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.\n+ *\n+ */\n+\n+#ifndef HEADER_BN_H\n+# define HEADER_BN_H\n+\n+# include <limits.h>\n+# include <openssl/e_os2.h>\n+# ifndef OPENSSL_NO_FP_API\n+#  include <stdio.h>            /* FILE */\n+# endif\n+# include <openssl/ossl_typ.h>\n+# include <openssl/crypto.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+ * These preprocessor symbols control various aspects of the bignum headers\n+ * and library code. They're not defined by any \"normal\" configuration, as\n+ * they are intended for development and testing purposes. NB: defining all\n+ * three can be useful for debugging application code as well as openssl\n+ * itself. BN_DEBUG - turn on various debugging alterations to the bignum\n+ * code BN_DEBUG_RAND - uses random poisoning of unused words to trip up\n+ * mismanagement of bignum internals. You must also define BN_DEBUG.\n+ */\n+/* #define BN_DEBUG */\n+/* #define BN_DEBUG_RAND */\n+\n+# ifndef OPENSSL_SMALL_FOOTPRINT\n+#  define BN_MUL_COMBA\n+#  define BN_SQR_COMBA\n+#  define BN_RECURSION\n+# endif\n+\n+/*\n+ * This next option uses the C libraries (2 word)/(1 word) function. If it is\n+ * not defined, I use my C version (which is slower). The reason for this\n+ * flag is that when the particular C compiler library routine is used, and\n+ * the library is linked with a different compiler, the library is missing.\n+ * This mostly happens when the library is built with gcc and then linked\n+ * using normal cc.  This would be a common occurrence because gcc normally\n+ * produces code that is 2 times faster than system compilers for the big\n+ * number stuff. For machines with only one compiler (or shared libraries),\n+ * this should be on.  Again this in only really a problem on machines using\n+ * \"long long's\", are 32bit, and are not using my assembler code.\n+ */\n+# if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || \\\n+    defined(OPENSSL_SYS_WIN32) || defined(linux)\n+#  ifndef BN_DIV2W\n+#   define BN_DIV2W\n+#  endif\n+# endif\n+\n+/*\n+ * assuming long is 64bit - this is the DEC Alpha unsigned long long is only\n+ * 64 bits :-(, don't define BN_LLONG for the DEC Alpha\n+ */\n+# ifdef SIXTY_FOUR_BIT_LONG\n+#  define BN_ULLONG       unsigned long long\n+#  define BN_ULONG        unsigned long\n+#  define BN_LONG         long\n+#  define BN_BITS         128\n+#  define BN_BYTES        8\n+#  define BN_BITS2        64\n+#  define BN_BITS4        32\n+#  define BN_MASK         (0xffffffffffffffffffffffffffffffffLL)\n+#  define BN_MASK2        (0xffffffffffffffffL)\n+#  define BN_MASK2l       (0xffffffffL)\n+#  define BN_MASK2h       (0xffffffff00000000L)\n+#  define BN_MASK2h1      (0xffffffff80000000L)\n+#  define BN_TBIT         (0x8000000000000000L)\n+#  define BN_DEC_CONV     (10000000000000000000UL)\n+#  define BN_DEC_FMT1     \"%lu\"\n+#  define BN_DEC_FMT2     \"%019lu\"\n+#  define BN_DEC_NUM      19\n+#  define BN_HEX_FMT1     \"%lX\"\n+#  define BN_HEX_FMT2     \"%016lX\"\n+# endif\n+\n+/*\n+ * This is where the long long data type is 64 bits, but long is 32. For\n+ * machines where there are 64bit registers, this is the mode to use. IRIX,\n+ * on R4000 and above should use this mode, along with the relevant assembler\n+ * code :-).  Do NOT define BN_LLONG.\n+ */\n+# ifdef SIXTY_FOUR_BIT\n+#  undef BN_LLONG\n+#  undef BN_ULLONG\n+#  define BN_ULONG        unsigned long long\n+#  define BN_LONG         long long\n+#  define BN_BITS         128\n+#  define BN_BYTES        8\n+#  define BN_BITS2        64\n+#  define BN_BITS4        32\n+#  define BN_MASK2        (0xffffffffffffffffLL)\n+#  define BN_MASK2l       (0xffffffffL)\n+#  define BN_MASK2h       (0xffffffff00000000LL)\n+#  define BN_MASK2h1      (0xffffffff80000000LL)\n+#  define BN_TBIT         (0x8000000000000000LL)\n+#  define BN_DEC_CONV     (10000000000000000000ULL)\n+#  define BN_DEC_FMT1     \"%llu\"\n+#  define BN_DEC_FMT2     \"%019llu\"\n+#  define BN_DEC_NUM      19\n+#  define BN_HEX_FMT1     \"%llX\"\n+#  define BN_HEX_FMT2     \"%016llX\"\n+# endif\n+\n+# ifdef THIRTY_TWO_BIT\n+#  ifdef BN_LLONG\n+#   if defined(_WIN32) && !defined(__GNUC__)\n+#    define BN_ULLONG     unsigned __int64\n+#    define BN_MASK       (0xffffffffffffffffI64)\n+#   else\n+#    define BN_ULLONG     unsigned long long\n+#    define BN_MASK       (0xffffffffffffffffLL)\n+#   endif\n+#  endif\n+#  define BN_ULONG        unsigned int\n+#  define BN_LONG         int\n+#  define BN_BITS         64\n+#  define BN_BYTES        4\n+#  define BN_BITS2        32\n+#  define BN_BITS4        16\n+#  define BN_MASK2        (0xffffffffL)\n+#  define BN_MASK2l       (0xffff)\n+#  define BN_MASK2h1      (0xffff8000L)\n+#  define BN_MASK2h       (0xffff0000L)\n+#  define BN_TBIT         (0x80000000L)\n+#  define BN_DEC_CONV     (1000000000L)\n+#  define BN_DEC_FMT1     \"%u\"\n+#  define BN_DEC_FMT2     \"%09u\"\n+#  define BN_DEC_NUM      9\n+#  define BN_HEX_FMT1     \"%X\"\n+#  define BN_HEX_FMT2     \"%08X\"\n+# endif\n+\n+# define BN_DEFAULT_BITS 1280\n+\n+# define BN_FLG_MALLOCED         0x01\n+# define BN_FLG_STATIC_DATA      0x02\n+\n+/*\n+ * avoid leaking exponent information through timing,\n+ * BN_mod_exp_mont() will call BN_mod_exp_mont_consttime,\n+ * BN_div() will call BN_div_no_branch,\n+ * BN_mod_inverse() will call BN_mod_inverse_no_branch.\n+ */\n+# define BN_FLG_CONSTTIME        0x04\n+\n+# ifdef OPENSSL_NO_DEPRECATED\n+/* deprecated name for the flag */\n+#  define BN_FLG_EXP_CONSTTIME BN_FLG_CONSTTIME\n+/*\n+ * avoid leaking exponent information through timings\n+ * (BN_mod_exp_mont() will call BN_mod_exp_mont_consttime)\n+ */\n+# endif\n+\n+# ifndef OPENSSL_NO_DEPRECATED\n+#  define BN_FLG_FREE             0x8000\n+                                       /* used for debuging */\n+# endif\n+# define BN_set_flags(b,n)       ((b)->flags|=(n))\n+# define BN_get_flags(b,n)       ((b)->flags&(n))\n+\n+/*\n+ * get a clone of a BIGNUM with changed flags, for *temporary* use only (the\n+ * two BIGNUMs cannot not be used in parallel!)\n+ */\n+# define BN_with_flags(dest,b,n)  ((dest)->d=(b)->d, \\\n+                                  (dest)->top=(b)->top, \\\n+                                  (dest)->dmax=(b)->dmax, \\\n+                                  (dest)->neg=(b)->neg, \\\n+                                  (dest)->flags=(((dest)->flags & BN_FLG_MALLOCED) \\\n+                                                 |  ((b)->flags & ~BN_FLG_MALLOCED) \\\n+                                                 |  BN_FLG_STATIC_DATA \\\n+                                                 |  (n)))\n+\n+/* Already declared in ossl_typ.h */\n+# if 0\n+typedef struct bignum_st BIGNUM;\n+/* Used for temp variables (declaration hidden in bn_lcl.h) */\n+typedef struct bignum_ctx BN_CTX;\n+typedef struct bn_blinding_st BN_BLINDING;\n+typedef struct bn_mont_ctx_st BN_MONT_CTX;\n+typedef struct bn_recp_ctx_st BN_RECP_CTX;\n+typedef struct bn_gencb_st BN_GENCB;\n+# endif\n+\n+struct bignum_st {\n+    BN_ULONG *d;                /* Pointer to an array of 'BN_BITS2' bit\n+                                 * chunks. */\n+    int top;                    /* Index of last used d +1. */\n+    /* The next are internal book keeping for bn_expand. */\n+    int dmax;                   /* Size of the d array. */\n+    int neg;                    /* one if the number is negative */\n+    int flags;\n+};\n+\n+/* Used for montgomery multiplication */\n+struct bn_mont_ctx_st {\n+    int ri;                     /* number of bits in R */\n+    BIGNUM RR;                  /* used to convert to montgomery form */\n+    BIGNUM N;                   /* The modulus */\n+    BIGNUM Ni;                  /* R*(1/R mod N) - N*Ni = 1 (Ni is only\n+                                 * stored for bignum algorithm) */\n+    BN_ULONG n0[2];             /* least significant word(s) of Ni; (type\n+                                 * changed with 0.9.9, was \"BN_ULONG n0;\"\n+                                 * before) */\n+    int flags;\n+};\n+\n+/*\n+ * Used for reciprocal division/mod functions It cannot be shared between\n+ * threads\n+ */\n+struct bn_recp_ctx_st {\n+    BIGNUM N;                   /* the divisor */\n+    BIGNUM Nr;                  /* the reciprocal */\n+    int num_bits;\n+    int shift;\n+    int flags;\n+};\n+\n+/* Used for slow \"generation\" functions. */\n+struct bn_gencb_st {\n+    unsigned int ver;           /* To handle binary (in)compatibility */\n+    void *arg;                  /* callback-specific data */\n+    union {\n+        /* if(ver==1) - handles old style callbacks */\n+        void (*cb_1) (int, int, void *);\n+        /* if(ver==2) - new callback style */\n+        int (*cb_2) (int, int, BN_GENCB *);\n+    } cb;\n+};\n+/* Wrapper function to make using BN_GENCB easier,  */\n+int BN_GENCB_call(BN_GENCB *cb, int a, int b);\n+/* Macro to populate a BN_GENCB structure with an \"old\"-style callback */\n+# define BN_GENCB_set_old(gencb, callback, cb_arg) { \\\n+                BN_GENCB *tmp_gencb = (gencb); \\\n+                tmp_gencb->ver = 1; \\\n+                tmp_gencb->arg = (cb_arg); \\\n+                tmp_gencb->cb.cb_1 = (callback); }\n+/* Macro to populate a BN_GENCB structure with a \"new\"-style callback */\n+# define BN_GENCB_set(gencb, callback, cb_arg) { \\\n+                BN_GENCB *tmp_gencb = (gencb); \\\n+                tmp_gencb->ver = 2; \\\n+                tmp_gencb->arg = (cb_arg); \\\n+                tmp_gencb->cb.cb_2 = (callback); }\n+\n+# define BN_prime_checks 0      /* default: select number of iterations based\n+                                 * on the size of the number */\n+\n+/*\n+ * number of Miller-Rabin iterations for an error rate of less than 2^-80 for\n+ * random 'b'-bit input, b >= 100 (taken from table 4.4 in the Handbook of\n+ * Applied Cryptography [Menezes, van Oorschot, Vanstone; CRC Press 1996];\n+ * original paper: Damgaard, Landrock, Pomerance: Average case error\n+ * estimates for the strong probable prime test. -- Math. Comp. 61 (1993)\n+ * 177-194)\n+ */\n+# define BN_prime_checks_for_size(b) ((b) >= 1300 ?  2 : \\\n+                                (b) >=  850 ?  3 : \\\n+                                (b) >=  650 ?  4 : \\\n+                                (b) >=  550 ?  5 : \\\n+                                (b) >=  450 ?  6 : \\\n+                                (b) >=  400 ?  7 : \\\n+                                (b) >=  350 ?  8 : \\\n+                                (b) >=  300 ?  9 : \\\n+                                (b) >=  250 ? 12 : \\\n+                                (b) >=  200 ? 15 : \\\n+                                (b) >=  150 ? 18 : \\\n+                                /* b >= 100 */ 27)\n+\n+# define BN_num_bytes(a) ((BN_num_bits(a)+7)/8)\n+\n+/* Note that BN_abs_is_word didn't work reliably for w == 0 until 0.9.8 */\n+# define BN_abs_is_word(a,w) ((((a)->top == 1) && ((a)->d[0] == (BN_ULONG)(w))) || \\\n+                                (((w) == 0) && ((a)->top == 0)))\n+# define BN_is_zero(a)       ((a)->top == 0)\n+# define BN_is_one(a)        (BN_abs_is_word((a),1) && !(a)->neg)\n+# define BN_is_word(a,w)     (BN_abs_is_word((a),(w)) && (!(w) || !(a)->neg))\n+# define BN_is_odd(a)        (((a)->top > 0) && ((a)->d[0] & 1))\n+\n+# define BN_one(a)       (BN_set_word((a),1))\n+# define BN_zero_ex(a) \\\n+        do { \\\n+                BIGNUM *_tmp_bn = (a); \\\n+                _tmp_bn->top = 0; \\\n+                _tmp_bn->neg = 0; \\\n+        } while(0)\n+# ifdef OPENSSL_NO_DEPRECATED\n+#  define BN_zero(a)      BN_zero_ex(a)\n+# else\n+#  define BN_zero(a)      (BN_set_word((a),0))\n+# endif\n+\n+const BIGNUM *BN_value_one(void);\n+char *BN_options(void);\n+BN_CTX *BN_CTX_new(void);\n+# ifndef OPENSSL_NO_DEPRECATED\n+void BN_CTX_init(BN_CTX *c);\n+# endif\n+void BN_CTX_free(BN_CTX *c);\n+void BN_CTX_start(BN_CTX *ctx);\n+BIGNUM *BN_CTX_get(BN_CTX *ctx);\n+void BN_CTX_end(BN_CTX *ctx);\n+int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);\n+int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);\n+int BN_rand_range(BIGNUM *rnd, const BIGNUM *range);\n+int BN_pseudo_rand_range(BIGNUM *rnd, const BIGNUM *range);\n+int BN_num_bits(const BIGNUM *a);\n+int BN_num_bits_word(BN_ULONG);\n+BIGNUM *BN_new(void);\n+void BN_init(BIGNUM *);\n+void BN_clear_free(BIGNUM *a);\n+BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);\n+void BN_swap(BIGNUM *a, BIGNUM *b);\n+BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);\n+int BN_bn2bin(const BIGNUM *a, unsigned char *to);\n+BIGNUM *BN_mpi2bn(const unsigned char *s, int len, BIGNUM *ret);\n+int BN_bn2mpi(const BIGNUM *a, unsigned char *to);\n+int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n+int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n+int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n+int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n+int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\n+int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx);\n+/** BN_set_negative sets sign of a BIGNUM\n+ * \\param  b  pointer to the BIGNUM object\n+ * \\param  n  0 if the BIGNUM b should be positive and a value != 0 otherwise\n+ */\n+void BN_set_negative(BIGNUM *b, int n);\n+/** BN_is_negative returns 1 if the BIGNUM is negative\n+ * \\param  a  pointer to the BIGNUM object\n+ * \\return 1 if a < 0 and 0 otherwise\n+ */\n+# define BN_is_negative(a) ((a)->neg != 0)\n+\n+int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,\n+           BN_CTX *ctx);\n+# define BN_mod(rem,m,d,ctx) BN_div(NULL,(rem),(m),(d),(ctx))\n+int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);\n+int BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,\n+               BN_CTX *ctx);\n+int BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n+                     const BIGNUM *m);\n+int BN_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,\n+               BN_CTX *ctx);\n+int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n+                     const BIGNUM *m);\n+int BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,\n+               BN_CTX *ctx);\n+int BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n+int BN_mod_lshift1(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);\n+int BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m);\n+int BN_mod_lshift(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m,\n+                  BN_CTX *ctx);\n+int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m);\n+\n+BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);\n+BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);\n+int BN_mul_word(BIGNUM *a, BN_ULONG w);\n+int BN_add_word(BIGNUM *a, BN_ULONG w);\n+int BN_sub_word(BIGNUM *a, BN_ULONG w);\n+int BN_set_word(BIGNUM *a, BN_ULONG w);\n+BN_ULONG BN_get_word(const BIGNUM *a);\n+\n+int BN_cmp(const BIGNUM *a, const BIGNUM *b);\n+void BN_free(BIGNUM *a);\n+int BN_is_bit_set(const BIGNUM *a, int n);\n+int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);\n+int BN_lshift1(BIGNUM *r, const BIGNUM *a);\n+int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);\n+\n+int BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n+               const BIGNUM *m, BN_CTX *ctx);\n+int BN_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n+                    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);\n+int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\n+                              const BIGNUM *m, BN_CTX *ctx,\n+                              BN_MONT_CTX *in_mont);\n+int BN_mod_exp_mont_word(BIGNUM *r, BN_ULONG a, const BIGNUM *p,\n+                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);\n+int BN_mod_exp2_mont(BIGNUM *r, const BIGNUM *a1, const BIGNUM *p1,\n+                     const BIGNUM *a2, const BIGNUM *p2, const BIGNUM *m,\n+                     BN_CTX *ctx, BN_MONT_CTX *m_ctx);\n+int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n+                      const BIGNUM *m, BN_CTX *ctx);\n+\n+int BN_mask_bits(BIGNUM *a, int n);\n+# ifndef OPENSSL_NO_FP_API\n+int BN_print_fp(FILE *fp, const BIGNUM *a);\n+# endif\n+# ifdef HEADER_BIO_H\n+int BN_print(BIO *fp, const BIGNUM *a);\n+# else\n+int BN_print(void *fp, const BIGNUM *a);\n+# endif\n+int BN_reciprocal(BIGNUM *r, const BIGNUM *m, int len, BN_CTX *ctx);\n+int BN_rshift(BIGNUM *r, const BIGNUM *a, int n);\n+int BN_rshift1(BIGNUM *r, const BIGNUM *a);\n+void BN_clear(BIGNUM *a);\n+BIGNUM *BN_dup(const BIGNUM *a);\n+int BN_ucmp(const BIGNUM *a, const BIGNUM *b);\n+int BN_set_bit(BIGNUM *a, int n);\n+int BN_clear_bit(BIGNUM *a, int n);\n+char *BN_bn2hex(const BIGNUM *a);\n+char *BN_bn2dec(const BIGNUM *a);\n+int BN_hex2bn(BIGNUM **a, const char *str);\n+int BN_dec2bn(BIGNUM **a, const char *str);\n+int BN_asc2bn(BIGNUM **a, const char *str);\n+int BN_gcd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);\n+int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx); /* returns\n+                                                                  * -2 for\n+                                                                  * error */\n+BIGNUM *BN_mod_inverse(BIGNUM *ret,\n+                       const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx);\n+BIGNUM *BN_mod_sqrt(BIGNUM *ret,\n+                    const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx);\n+\n+void BN_consttime_swap(BN_ULONG swap, BIGNUM *a, BIGNUM *b, int nwords);\n+\n+/* Deprecated versions */\n+# ifndef OPENSSL_NO_DEPRECATED\n+BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int safe,\n+                          const BIGNUM *add, const BIGNUM *rem,\n+                          void (*callback) (int, int, void *), void *cb_arg);\n+int BN_is_prime(const BIGNUM *p, int nchecks,\n+                void (*callback) (int, int, void *),\n+                BN_CTX *ctx, void *cb_arg);\n+int BN_is_prime_fasttest(const BIGNUM *p, int nchecks,\n+                         void (*callback) (int, int, void *), BN_CTX *ctx,\n+                         void *cb_arg, int do_trial_division);\n+# endif                         /* !defined(OPENSSL_NO_DEPRECATED) */\n+\n+/* Newer versions */\n+int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe, const BIGNUM *add,\n+                         const BIGNUM *rem, BN_GENCB *cb);\n+int BN_is_prime_ex(const BIGNUM *p, int nchecks, BN_CTX *ctx, BN_GENCB *cb);\n+int BN_is_prime_fasttest_ex(const BIGNUM *p, int nchecks, BN_CTX *ctx,\n+                            int do_trial_division, BN_GENCB *cb);\n+\n+int BN_X931_generate_Xpq(BIGNUM *Xp, BIGNUM *Xq, int nbits, BN_CTX *ctx);\n+\n+int BN_X931_derive_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2,\n+                            const BIGNUM *Xp, const BIGNUM *Xp1,\n+                            const BIGNUM *Xp2, const BIGNUM *e, BN_CTX *ctx,\n+                            BN_GENCB *cb);\n+int BN_X931_generate_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2, BIGNUM *Xp1,\n+                              BIGNUM *Xp2, const BIGNUM *Xp, const BIGNUM *e,\n+                              BN_CTX *ctx, BN_GENCB *cb);\n+\n+BN_MONT_CTX *BN_MONT_CTX_new(void);\n+void BN_MONT_CTX_init(BN_MONT_CTX *ctx);\n+int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n+                          BN_MONT_CTX *mont, BN_CTX *ctx);\n+# define BN_to_montgomery(r,a,mont,ctx)  BN_mod_mul_montgomery(\\\n+        (r),(a),&((mont)->RR),(mont),(ctx))\n+int BN_from_montgomery(BIGNUM *r, const BIGNUM *a,\n+                       BN_MONT_CTX *mont, BN_CTX *ctx);\n+void BN_MONT_CTX_free(BN_MONT_CTX *mont);\n+int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx);\n+BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);\n+BN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock,\n+                                    const BIGNUM *mod, BN_CTX *ctx);\n+\n+/* BN_BLINDING flags */\n+# define BN_BLINDING_NO_UPDATE   0x00000001\n+# define BN_BLINDING_NO_RECREATE 0x00000002\n+\n+BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod);\n+void BN_BLINDING_free(BN_BLINDING *b);\n+int BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx);\n+int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n+int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);\n+int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *);\n+int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,\n+                          BN_CTX *);\n+# ifndef OPENSSL_NO_DEPRECATED\n+unsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);\n+void BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);\n+# endif\n+CRYPTO_THREADID *BN_BLINDING_thread_id(BN_BLINDING *);\n+unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);\n+void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);\n+BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\n+                                      const BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\n+                                      int (*bn_mod_exp) (BIGNUM *r,\n+                                                         const BIGNUM *a,\n+                                                         const BIGNUM *p,\n+                                                         const BIGNUM *m,\n+                                                         BN_CTX *ctx,\n+                                                         BN_MONT_CTX *m_ctx),\n+                                      BN_MONT_CTX *m_ctx);\n+\n+# ifndef OPENSSL_NO_DEPRECATED\n+void BN_set_params(int mul, int high, int low, int mont);\n+int BN_get_params(int which);   /* 0, mul, 1 high, 2 low, 3 mont */\n+# endif\n+\n+void BN_RECP_CTX_init(BN_RECP_CTX *recp);\n+BN_RECP_CTX *BN_RECP_CTX_new(void);\n+void BN_RECP_CTX_free(BN_RECP_CTX *recp);\n+int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *rdiv, BN_CTX *ctx);\n+int BN_mod_mul_reciprocal(BIGNUM *r, const BIGNUM *x, const BIGNUM *y,\n+                          BN_RECP_CTX *recp, BN_CTX *ctx);\n+int BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n+                    const BIGNUM *m, BN_CTX *ctx);\n+int BN_div_recp(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m,\n+                BN_RECP_CTX *recp, BN_CTX *ctx);\n+\n+# ifndef OPENSSL_NO_EC2M\n+\n+/*\n+ * Functions for arithmetic over binary polynomials represented by BIGNUMs.\n+ * The BIGNUM::neg property of BIGNUMs representing binary polynomials is\n+ * ignored. Note that input arguments are not const so that their bit arrays\n+ * can be expanded to the appropriate size if needed.\n+ */\n+\n+/*\n+ * r = a + b\n+ */\n+int BN_GF2m_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);\n+#  define BN_GF2m_sub(r, a, b) BN_GF2m_add(r, a, b)\n+/*\n+ * r=a mod p\n+ */\n+int BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p);\n+/* r = (a * b) mod p */\n+int BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n+                    const BIGNUM *p, BN_CTX *ctx);\n+/* r = (a * a) mod p */\n+int BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);\n+/* r = (1 / b) mod p */\n+int BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *b, const BIGNUM *p, BN_CTX *ctx);\n+/* r = (a / b) mod p */\n+int BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n+                    const BIGNUM *p, BN_CTX *ctx);\n+/* r = (a ^ b) mod p */\n+int BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n+                    const BIGNUM *p, BN_CTX *ctx);\n+/* r = sqrt(a) mod p */\n+int BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n+                     BN_CTX *ctx);\n+/* r^2 + r = a mod p */\n+int BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n+                           BN_CTX *ctx);\n+#  define BN_GF2m_cmp(a, b) BN_ucmp((a), (b))\n+/*-\n+ * Some functions allow for representation of the irreducible polynomials\n+ * as an unsigned int[], say p.  The irreducible f(t) is then of the form:\n+ *     t^p[0] + t^p[1] + ... + t^p[k]\n+ * where m = p[0] > p[1] > ... > p[k] = 0.\n+ */\n+/* r = a mod p */\n+int BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[]);\n+/* r = (a * b) mod p */\n+int BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n+                        const int p[], BN_CTX *ctx);\n+/* r = (a * a) mod p */\n+int BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const int p[],\n+                        BN_CTX *ctx);\n+/* r = (1 / b) mod p */\n+int BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *b, const int p[],\n+                        BN_CTX *ctx);\n+/* r = (a / b) mod p */\n+int BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n+                        const int p[], BN_CTX *ctx);\n+/* r = (a ^ b) mod p */\n+int BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\n+                        const int p[], BN_CTX *ctx);\n+/* r = sqrt(a) mod p */\n+int BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a,\n+                         const int p[], BN_CTX *ctx);\n+/* r^2 + r = a mod p */\n+int BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a,\n+                               const int p[], BN_CTX *ctx);\n+int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max);\n+int BN_GF2m_arr2poly(const int p[], BIGNUM *a);\n+\n+# endif\n+\n+/*\n+ * faster mod functions for the 'NIST primes' 0 <= a < p^2\n+ */\n+int BN_nist_mod_192(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);\n+int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);\n+int BN_nist_mod_256(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);\n+int BN_nist_mod_384(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);\n+int BN_nist_mod_521(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);\n+\n+const BIGNUM *BN_get0_nist_prime_192(void);\n+const BIGNUM *BN_get0_nist_prime_224(void);\n+const BIGNUM *BN_get0_nist_prime_256(void);\n+const BIGNUM *BN_get0_nist_prime_384(void);\n+const BIGNUM *BN_get0_nist_prime_521(void);\n+\n+/* library internal functions */\n+\n+# define bn_expand(a,bits) \\\n+    ( \\\n+        bits > (INT_MAX - BN_BITS2 + 1) ? \\\n+            NULL \\\n+        : \\\n+            (((bits+BN_BITS2-1)/BN_BITS2) <= (a)->dmax) ? \\\n+                (a) \\\n+            : \\\n+                bn_expand2((a),(bits+BN_BITS2-1)/BN_BITS2) \\\n+    )\n+\n+# define bn_wexpand(a,words) (((words) <= (a)->dmax)?(a):bn_expand2((a),(words)))\n+BIGNUM *bn_expand2(BIGNUM *a, int words);\n+# ifndef OPENSSL_NO_DEPRECATED\n+BIGNUM *bn_dup_expand(const BIGNUM *a, int words); /* unused */\n+# endif\n+\n+/*-\n+ * Bignum consistency macros\n+ * There is one \"API\" macro, bn_fix_top(), for stripping leading zeroes from\n+ * bignum data after direct manipulations on the data. There is also an\n+ * \"internal\" macro, bn_check_top(), for verifying that there are no leading\n+ * zeroes. Unfortunately, some auditing is required due to the fact that\n+ * bn_fix_top() has become an overabused duct-tape because bignum data is\n+ * occasionally passed around in an inconsistent state. So the following\n+ * changes have been made to sort this out;\n+ * - bn_fix_top()s implementation has been moved to bn_correct_top()\n+ * - if BN_DEBUG isn't defined, bn_fix_top() maps to bn_correct_top(), and\n+ *   bn_check_top() is as before.\n+ * - if BN_DEBUG *is* defined;\n+ *   - bn_check_top() tries to pollute unused words even if the bignum 'top' is\n+ *     consistent. (ed: only if BN_DEBUG_RAND is defined)\n+ *   - bn_fix_top() maps to bn_check_top() rather than \"fixing\" anything.\n+ * The idea is to have debug builds flag up inconsistent bignums when they\n+ * occur. If that occurs in a bn_fix_top(), we examine the code in question; if\n+ * the use of bn_fix_top() was appropriate (ie. it follows directly after code\n+ * that manipulates the bignum) it is converted to bn_correct_top(), and if it\n+ * was not appropriate, we convert it permanently to bn_check_top() and track\n+ * down the cause of the bug. Eventually, no internal code should be using the\n+ * bn_fix_top() macro. External applications and libraries should try this with\n+ * their own code too, both in terms of building against the openssl headers\n+ * with BN_DEBUG defined *and* linking with a version of OpenSSL built with it\n+ * defined. This not only improves external code, it provides more test\n+ * coverage for openssl's own code.\n+ */\n+\n+# ifdef BN_DEBUG\n+\n+/* We only need assert() when debugging */\n+#  include <assert.h>\n+\n+#  ifdef BN_DEBUG_RAND\n+/* To avoid \"make update\" cvs wars due to BN_DEBUG, use some tricks */\n+#   ifndef RAND_pseudo_bytes\n+int RAND_pseudo_bytes(unsigned char *buf, int num);\n+#    define BN_DEBUG_TRIX\n+#   endif\n+#   define bn_pollute(a) \\\n+        do { \\\n+                const BIGNUM *_bnum1 = (a); \\\n+                if(_bnum1->top < _bnum1->dmax) { \\\n+                        unsigned char _tmp_char; \\\n+                        /* We cast away const without the compiler knowing, any \\\n+                         * *genuinely* constant variables that aren't mutable \\\n+                         * wouldn't be constructed with top!=dmax. */ \\\n+                        BN_ULONG *_not_const; \\\n+                        memcpy(&_not_const, &_bnum1->d, sizeof(BN_ULONG*)); \\\n+                        /* Debug only - safe to ignore error return */ \\\n+                        RAND_pseudo_bytes(&_tmp_char, 1); \\\n+                        memset((unsigned char *)(_not_const + _bnum1->top), _tmp_char, \\\n+                                (_bnum1->dmax - _bnum1->top) * sizeof(BN_ULONG)); \\\n+                } \\\n+        } while(0)\n+#   ifdef BN_DEBUG_TRIX\n+#    undef RAND_pseudo_bytes\n+#   endif\n+#  else\n+#   define bn_pollute(a)\n+#  endif\n+#  define bn_check_top(a) \\\n+        do { \\\n+                const BIGNUM *_bnum2 = (a); \\\n+                if (_bnum2 != NULL) { \\\n+                        assert((_bnum2->top == 0) || \\\n+                                (_bnum2->d[_bnum2->top - 1] != 0)); \\\n+                        bn_pollute(_bnum2); \\\n+                } \\\n+        } while(0)\n+\n+#  define bn_fix_top(a)           bn_check_top(a)\n+\n+#  define bn_check_size(bn, bits) bn_wcheck_size(bn, ((bits+BN_BITS2-1))/BN_BITS2)\n+#  define bn_wcheck_size(bn, words) \\\n+        do { \\\n+                const BIGNUM *_bnum2 = (bn); \\\n+                assert((words) <= (_bnum2)->dmax && (words) >= (_bnum2)->top); \\\n+                /* avoid unused variable warning with NDEBUG */ \\\n+                (void)(_bnum2); \\\n+        } while(0)\n+\n+# else                          /* !BN_DEBUG */\n+\n+#  define bn_pollute(a)\n+#  define bn_check_top(a)\n+#  define bn_fix_top(a)           bn_correct_top(a)\n+#  define bn_check_size(bn, bits)\n+#  define bn_wcheck_size(bn, words)\n+\n+# endif\n+\n+# define bn_correct_top(a) \\\n+        { \\\n+        BN_ULONG *ftl; \\\n+        int tmp_top = (a)->top; \\\n+        if (tmp_top > 0) \\\n+                { \\\n+                for (ftl= &((a)->d[tmp_top-1]); tmp_top > 0; tmp_top--) \\\n+                        if (*(ftl--)) break; \\\n+                (a)->top = tmp_top; \\\n+                } \\\n+        if ((a)->top == 0) \\\n+            (a)->neg = 0; \\\n+        bn_pollute(a); \\\n+        }\n+\n+BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num,\n+                          BN_ULONG w);\n+BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w);\n+void bn_sqr_words(BN_ULONG *rp, const BN_ULONG *ap, int num);\n+BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);\n+BN_ULONG bn_add_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n+                      int num);\n+BN_ULONG bn_sub_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\n+                      int num);\n+\n+/* Primes from RFC 2409 */\n+BIGNUM *get_rfc2409_prime_768(BIGNUM *bn);\n+BIGNUM *get_rfc2409_prime_1024(BIGNUM *bn);\n+\n+/* Primes from RFC 3526 */\n+BIGNUM *get_rfc3526_prime_1536(BIGNUM *bn);\n+BIGNUM *get_rfc3526_prime_2048(BIGNUM *bn);\n+BIGNUM *get_rfc3526_prime_3072(BIGNUM *bn);\n+BIGNUM *get_rfc3526_prime_4096(BIGNUM *bn);\n+BIGNUM *get_rfc3526_prime_6144(BIGNUM *bn);\n+BIGNUM *get_rfc3526_prime_8192(BIGNUM *bn);\n+\n+int BN_bntest_rand(BIGNUM *rnd, int bits, int top, int bottom);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_BN_strings(void);\n+\n+/* Error codes for the BN functions. */\n+\n+/* Function codes. */\n+# define BN_F_BNRAND                                      127\n+# define BN_F_BN_BLINDING_CONVERT_EX                      100\n+# define BN_F_BN_BLINDING_CREATE_PARAM                    128\n+# define BN_F_BN_BLINDING_INVERT_EX                       101\n+# define BN_F_BN_BLINDING_NEW                             102\n+# define BN_F_BN_BLINDING_UPDATE                          103\n+# define BN_F_BN_BN2DEC                                   104\n+# define BN_F_BN_BN2HEX                                   105\n+# define BN_F_BN_CTX_GET                                  116\n+# define BN_F_BN_CTX_NEW                                  106\n+# define BN_F_BN_CTX_START                                129\n+# define BN_F_BN_DIV                                      107\n+# define BN_F_BN_DIV_NO_BRANCH                            138\n+# define BN_F_BN_DIV_RECP                                 130\n+# define BN_F_BN_EXP                                      123\n+# define BN_F_BN_EXPAND2                                  108\n+# define BN_F_BN_EXPAND_INTERNAL                          120\n+# define BN_F_BN_GF2M_MOD                                 131\n+# define BN_F_BN_GF2M_MOD_EXP                             132\n+# define BN_F_BN_GF2M_MOD_MUL                             133\n+# define BN_F_BN_GF2M_MOD_SOLVE_QUAD                      134\n+# define BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR                  135\n+# define BN_F_BN_GF2M_MOD_SQR                             136\n+# define BN_F_BN_GF2M_MOD_SQRT                            137\n+# define BN_F_BN_LSHIFT                                   145\n+# define BN_F_BN_MOD_EXP2_MONT                            118\n+# define BN_F_BN_MOD_EXP_MONT                             109\n+# define BN_F_BN_MOD_EXP_MONT_CONSTTIME                   124\n+# define BN_F_BN_MOD_EXP_MONT_WORD                        117\n+# define BN_F_BN_MOD_EXP_RECP                             125\n+# define BN_F_BN_MOD_EXP_SIMPLE                           126\n+# define BN_F_BN_MOD_INVERSE                              110\n+# define BN_F_BN_MOD_INVERSE_NO_BRANCH                    139\n+# define BN_F_BN_MOD_LSHIFT_QUICK                         119\n+# define BN_F_BN_MOD_MUL_RECIPROCAL                       111\n+# define BN_F_BN_MOD_SQRT                                 121\n+# define BN_F_BN_MPI2BN                                   112\n+# define BN_F_BN_NEW                                      113\n+# define BN_F_BN_RAND                                     114\n+# define BN_F_BN_RAND_RANGE                               122\n+# define BN_F_BN_RSHIFT                                   146\n+# define BN_F_BN_USUB                                     115\n+\n+/* Reason codes. */\n+# define BN_R_ARG2_LT_ARG3                                100\n+# define BN_R_BAD_RECIPROCAL                              101\n+# define BN_R_BIGNUM_TOO_LONG                             114\n+# define BN_R_BITS_TOO_SMALL                              118\n+# define BN_R_CALLED_WITH_EVEN_MODULUS                    102\n+# define BN_R_DIV_BY_ZERO                                 103\n+# define BN_R_ENCODING_ERROR                              104\n+# define BN_R_EXPAND_ON_STATIC_BIGNUM_DATA                105\n+# define BN_R_INPUT_NOT_REDUCED                           110\n+# define BN_R_INVALID_LENGTH                              106\n+# define BN_R_INVALID_RANGE                               115\n+# define BN_R_INVALID_SHIFT                               119\n+# define BN_R_NOT_A_SQUARE                                111\n+# define BN_R_NOT_INITIALIZED                             107\n+# define BN_R_NO_INVERSE                                  108\n+# define BN_R_NO_SOLUTION                                 116\n+# define BN_R_P_IS_NOT_PRIME                              112\n+# define BN_R_TOO_MANY_ITERATIONS                         113\n+# define BN_R_TOO_MANY_TEMPORARY_VARIABLES                109\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "efd240a5f91e25360aab3d83b5aa01509bb29f00",
            "filename": "deps/openssl/openssl/include/openssl/buffer.h",
            "status": "added",
            "additions": 125,
            "deletions": 0,
            "changes": 125,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fbuffer.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fbuffer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fbuffer.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,125 @@\n+/* crypto/buffer/buffer.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_BUFFER_H\n+# define HEADER_BUFFER_H\n+\n+# include <openssl/ossl_typ.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# include <stddef.h>\n+\n+# if !defined(NO_SYS_TYPES_H)\n+#  include <sys/types.h>\n+# endif\n+\n+/* Already declared in ossl_typ.h */\n+/* typedef struct buf_mem_st BUF_MEM; */\n+\n+struct buf_mem_st {\n+    size_t length;              /* current number of bytes */\n+    char *data;\n+    size_t max;                 /* size of buffer */\n+};\n+\n+BUF_MEM *BUF_MEM_new(void);\n+void BUF_MEM_free(BUF_MEM *a);\n+int BUF_MEM_grow(BUF_MEM *str, size_t len);\n+int BUF_MEM_grow_clean(BUF_MEM *str, size_t len);\n+size_t BUF_strnlen(const char *str, size_t maxlen);\n+char *BUF_strdup(const char *str);\n+\n+/*\n+ * Like strndup, but in addition, explicitly guarantees to never read past the\n+ * first |siz| bytes of |str|.\n+ */\n+char *BUF_strndup(const char *str, size_t siz);\n+\n+void *BUF_memdup(const void *data, size_t siz);\n+void BUF_reverse(unsigned char *out, const unsigned char *in, size_t siz);\n+\n+/* safe string functions */\n+size_t BUF_strlcpy(char *dst, const char *src, size_t siz);\n+size_t BUF_strlcat(char *dst, const char *src, size_t siz);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_BUF_strings(void);\n+\n+/* Error codes for the BUF functions. */\n+\n+/* Function codes. */\n+# define BUF_F_BUF_MEMDUP                                 103\n+# define BUF_F_BUF_MEM_GROW                               100\n+# define BUF_F_BUF_MEM_GROW_CLEAN                         105\n+# define BUF_F_BUF_MEM_NEW                                101\n+# define BUF_F_BUF_STRDUP                                 102\n+# define BUF_F_BUF_STRNDUP                                104\n+\n+/* Reason codes. */\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "45e8d25b1dd5b5148d48b2be9fa4f37886e91ebe",
            "filename": "deps/openssl/openssl/include/openssl/camellia.h",
            "status": "added",
            "additions": 132,
            "deletions": 0,
            "changes": 132,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcamellia.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcamellia.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcamellia.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,132 @@\n+/* crypto/camellia/camellia.h */\n+/* ====================================================================\n+ * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ */\n+\n+#ifndef HEADER_CAMELLIA_H\n+# define HEADER_CAMELLIA_H\n+\n+# include <openssl/opensslconf.h>\n+\n+# ifdef OPENSSL_NO_CAMELLIA\n+#  error CAMELLIA is disabled.\n+# endif\n+\n+# include <stddef.h>\n+\n+# define CAMELLIA_ENCRYPT        1\n+# define CAMELLIA_DECRYPT        0\n+\n+/*\n+ * Because array size can't be a const in C, the following two are macros.\n+ * Both sizes are in bytes.\n+ */\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This should be a hidden type, but EVP requires that the size be known */\n+\n+# define CAMELLIA_BLOCK_SIZE 16\n+# define CAMELLIA_TABLE_BYTE_LEN 272\n+# define CAMELLIA_TABLE_WORD_LEN (CAMELLIA_TABLE_BYTE_LEN / 4)\n+\n+typedef unsigned int KEY_TABLE_TYPE[CAMELLIA_TABLE_WORD_LEN]; /* to match\n+                                                               * with WORD */\n+\n+struct camellia_key_st {\n+    union {\n+        double d;               /* ensures 64-bit align */\n+        KEY_TABLE_TYPE rd_key;\n+    } u;\n+    int grand_rounds;\n+};\n+typedef struct camellia_key_st CAMELLIA_KEY;\n+\n+# ifdef OPENSSL_FIPS\n+int private_Camellia_set_key(const unsigned char *userKey, const int bits,\n+                             CAMELLIA_KEY *key);\n+# endif\n+int Camellia_set_key(const unsigned char *userKey, const int bits,\n+                     CAMELLIA_KEY *key);\n+\n+void Camellia_encrypt(const unsigned char *in, unsigned char *out,\n+                      const CAMELLIA_KEY *key);\n+void Camellia_decrypt(const unsigned char *in, unsigned char *out,\n+                      const CAMELLIA_KEY *key);\n+\n+void Camellia_ecb_encrypt(const unsigned char *in, unsigned char *out,\n+                          const CAMELLIA_KEY *key, const int enc);\n+void Camellia_cbc_encrypt(const unsigned char *in, unsigned char *out,\n+                          size_t length, const CAMELLIA_KEY *key,\n+                          unsigned char *ivec, const int enc);\n+void Camellia_cfb128_encrypt(const unsigned char *in, unsigned char *out,\n+                             size_t length, const CAMELLIA_KEY *key,\n+                             unsigned char *ivec, int *num, const int enc);\n+void Camellia_cfb1_encrypt(const unsigned char *in, unsigned char *out,\n+                           size_t length, const CAMELLIA_KEY *key,\n+                           unsigned char *ivec, int *num, const int enc);\n+void Camellia_cfb8_encrypt(const unsigned char *in, unsigned char *out,\n+                           size_t length, const CAMELLIA_KEY *key,\n+                           unsigned char *ivec, int *num, const int enc);\n+void Camellia_ofb128_encrypt(const unsigned char *in, unsigned char *out,\n+                             size_t length, const CAMELLIA_KEY *key,\n+                             unsigned char *ivec, int *num);\n+void Camellia_ctr128_encrypt(const unsigned char *in, unsigned char *out,\n+                             size_t length, const CAMELLIA_KEY *key,\n+                             unsigned char ivec[CAMELLIA_BLOCK_SIZE],\n+                             unsigned char ecount_buf[CAMELLIA_BLOCK_SIZE],\n+                             unsigned int *num);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif                          /* !HEADER_Camellia_H */"
        },
        {
            "sha": "0003ec9c7c02a788fede84787a841c3d8c0fa79d",
            "filename": "deps/openssl/openssl/include/openssl/cast.h",
            "status": "added",
            "additions": 107,
            "deletions": 0,
            "changes": 107,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcast.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcast.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcast.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,107 @@\n+/* crypto/cast/cast.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_CAST_H\n+# define HEADER_CAST_H\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# include <openssl/opensslconf.h>\n+\n+# ifdef OPENSSL_NO_CAST\n+#  error CAST is disabled.\n+# endif\n+\n+# define CAST_ENCRYPT    1\n+# define CAST_DECRYPT    0\n+\n+# define CAST_LONG unsigned int\n+\n+# define CAST_BLOCK      8\n+# define CAST_KEY_LENGTH 16\n+\n+typedef struct cast_key_st {\n+    CAST_LONG data[32];\n+    int short_key;              /* Use reduced rounds for short key */\n+} CAST_KEY;\n+\n+# ifdef OPENSSL_FIPS\n+void private_CAST_set_key(CAST_KEY *key, int len, const unsigned char *data);\n+# endif\n+void CAST_set_key(CAST_KEY *key, int len, const unsigned char *data);\n+void CAST_ecb_encrypt(const unsigned char *in, unsigned char *out,\n+                      const CAST_KEY *key, int enc);\n+void CAST_encrypt(CAST_LONG *data, const CAST_KEY *key);\n+void CAST_decrypt(CAST_LONG *data, const CAST_KEY *key);\n+void CAST_cbc_encrypt(const unsigned char *in, unsigned char *out,\n+                      long length, const CAST_KEY *ks, unsigned char *iv,\n+                      int enc);\n+void CAST_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n+                        long length, const CAST_KEY *schedule,\n+                        unsigned char *ivec, int *num, int enc);\n+void CAST_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n+                        long length, const CAST_KEY *schedule,\n+                        unsigned char *ivec, int *num);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "175be8348abb40ff317de2945d05444dc6eb0cbc",
            "filename": "deps/openssl/openssl/include/openssl/cmac.h",
            "status": "added",
            "additions": 82,
            "deletions": 0,
            "changes": 82,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcmac.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcmac.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcmac.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,82 @@\n+/* crypto/cmac/cmac.h */\n+/*\n+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL\n+ * project.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 2010 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ */\n+\n+#ifndef HEADER_CMAC_H\n+# define HEADER_CMAC_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# include <openssl/evp.h>\n+\n+/* Opaque */\n+typedef struct CMAC_CTX_st CMAC_CTX;\n+\n+CMAC_CTX *CMAC_CTX_new(void);\n+void CMAC_CTX_cleanup(CMAC_CTX *ctx);\n+void CMAC_CTX_free(CMAC_CTX *ctx);\n+EVP_CIPHER_CTX *CMAC_CTX_get0_cipher_ctx(CMAC_CTX *ctx);\n+int CMAC_CTX_copy(CMAC_CTX *out, const CMAC_CTX *in);\n+\n+int CMAC_Init(CMAC_CTX *ctx, const void *key, size_t keylen,\n+              const EVP_CIPHER *cipher, ENGINE *impl);\n+int CMAC_Update(CMAC_CTX *ctx, const void *data, size_t dlen);\n+int CMAC_Final(CMAC_CTX *ctx, unsigned char *out, size_t *poutlen);\n+int CMAC_resume(CMAC_CTX *ctx);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "e6c7f964bf48c0806c5ca32728130206feb6ac2a",
            "filename": "deps/openssl/openssl/include/openssl/cms.h",
            "status": "added",
            "additions": 555,
            "deletions": 0,
            "changes": 555,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcms.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcms.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcms.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,555 @@\n+/* crypto/cms/cms.h */\n+/*\n+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL\n+ * project.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ */\n+\n+#ifndef HEADER_CMS_H\n+# define HEADER_CMS_H\n+\n+# include <openssl/x509.h>\n+\n+# ifdef OPENSSL_NO_CMS\n+#  error CMS is disabled.\n+# endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct CMS_ContentInfo_st CMS_ContentInfo;\n+typedef struct CMS_SignerInfo_st CMS_SignerInfo;\n+typedef struct CMS_CertificateChoices CMS_CertificateChoices;\n+typedef struct CMS_RevocationInfoChoice_st CMS_RevocationInfoChoice;\n+typedef struct CMS_RecipientInfo_st CMS_RecipientInfo;\n+typedef struct CMS_ReceiptRequest_st CMS_ReceiptRequest;\n+typedef struct CMS_Receipt_st CMS_Receipt;\n+typedef struct CMS_RecipientEncryptedKey_st CMS_RecipientEncryptedKey;\n+typedef struct CMS_OtherKeyAttribute_st CMS_OtherKeyAttribute;\n+\n+DECLARE_STACK_OF(CMS_SignerInfo)\n+DECLARE_STACK_OF(GENERAL_NAMES)\n+DECLARE_STACK_OF(CMS_RecipientEncryptedKey)\n+DECLARE_ASN1_FUNCTIONS(CMS_ContentInfo)\n+DECLARE_ASN1_FUNCTIONS(CMS_ReceiptRequest)\n+DECLARE_ASN1_PRINT_FUNCTION(CMS_ContentInfo)\n+\n+# define CMS_SIGNERINFO_ISSUER_SERIAL    0\n+# define CMS_SIGNERINFO_KEYIDENTIFIER    1\n+\n+# define CMS_RECIPINFO_NONE              -1\n+# define CMS_RECIPINFO_TRANS             0\n+# define CMS_RECIPINFO_AGREE             1\n+# define CMS_RECIPINFO_KEK               2\n+# define CMS_RECIPINFO_PASS              3\n+# define CMS_RECIPINFO_OTHER             4\n+\n+/* S/MIME related flags */\n+\n+# define CMS_TEXT                        0x1\n+# define CMS_NOCERTS                     0x2\n+# define CMS_NO_CONTENT_VERIFY           0x4\n+# define CMS_NO_ATTR_VERIFY              0x8\n+# define CMS_NOSIGS                      \\\n+                        (CMS_NO_CONTENT_VERIFY|CMS_NO_ATTR_VERIFY)\n+# define CMS_NOINTERN                    0x10\n+# define CMS_NO_SIGNER_CERT_VERIFY       0x20\n+# define CMS_NOVERIFY                    0x20\n+# define CMS_DETACHED                    0x40\n+# define CMS_BINARY                      0x80\n+# define CMS_NOATTR                      0x100\n+# define CMS_NOSMIMECAP                  0x200\n+# define CMS_NOOLDMIMETYPE               0x400\n+# define CMS_CRLFEOL                     0x800\n+# define CMS_STREAM                      0x1000\n+# define CMS_NOCRL                       0x2000\n+# define CMS_PARTIAL                     0x4000\n+# define CMS_REUSE_DIGEST                0x8000\n+# define CMS_USE_KEYID                   0x10000\n+# define CMS_DEBUG_DECRYPT               0x20000\n+# define CMS_KEY_PARAM                   0x40000\n+\n+const ASN1_OBJECT *CMS_get0_type(CMS_ContentInfo *cms);\n+\n+BIO *CMS_dataInit(CMS_ContentInfo *cms, BIO *icont);\n+int CMS_dataFinal(CMS_ContentInfo *cms, BIO *bio);\n+\n+ASN1_OCTET_STRING **CMS_get0_content(CMS_ContentInfo *cms);\n+int CMS_is_detached(CMS_ContentInfo *cms);\n+int CMS_set_detached(CMS_ContentInfo *cms, int detached);\n+\n+# ifdef HEADER_PEM_H\n+DECLARE_PEM_rw_const(CMS, CMS_ContentInfo)\n+# endif\n+int CMS_stream(unsigned char ***boundary, CMS_ContentInfo *cms);\n+CMS_ContentInfo *d2i_CMS_bio(BIO *bp, CMS_ContentInfo **cms);\n+int i2d_CMS_bio(BIO *bp, CMS_ContentInfo *cms);\n+\n+BIO *BIO_new_CMS(BIO *out, CMS_ContentInfo *cms);\n+int i2d_CMS_bio_stream(BIO *out, CMS_ContentInfo *cms, BIO *in, int flags);\n+int PEM_write_bio_CMS_stream(BIO *out, CMS_ContentInfo *cms, BIO *in,\n+                             int flags);\n+CMS_ContentInfo *SMIME_read_CMS(BIO *bio, BIO **bcont);\n+int SMIME_write_CMS(BIO *bio, CMS_ContentInfo *cms, BIO *data, int flags);\n+\n+int CMS_final(CMS_ContentInfo *cms, BIO *data, BIO *dcont,\n+              unsigned int flags);\n+\n+CMS_ContentInfo *CMS_sign(X509 *signcert, EVP_PKEY *pkey,\n+                          STACK_OF(X509) *certs, BIO *data,\n+                          unsigned int flags);\n+\n+CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,\n+                                  X509 *signcert, EVP_PKEY *pkey,\n+                                  STACK_OF(X509) *certs, unsigned int flags);\n+\n+int CMS_data(CMS_ContentInfo *cms, BIO *out, unsigned int flags);\n+CMS_ContentInfo *CMS_data_create(BIO *in, unsigned int flags);\n+\n+int CMS_digest_verify(CMS_ContentInfo *cms, BIO *dcont, BIO *out,\n+                      unsigned int flags);\n+CMS_ContentInfo *CMS_digest_create(BIO *in, const EVP_MD *md,\n+                                   unsigned int flags);\n+\n+int CMS_EncryptedData_decrypt(CMS_ContentInfo *cms,\n+                              const unsigned char *key, size_t keylen,\n+                              BIO *dcont, BIO *out, unsigned int flags);\n+\n+CMS_ContentInfo *CMS_EncryptedData_encrypt(BIO *in, const EVP_CIPHER *cipher,\n+                                           const unsigned char *key,\n+                                           size_t keylen, unsigned int flags);\n+\n+int CMS_EncryptedData_set1_key(CMS_ContentInfo *cms, const EVP_CIPHER *ciph,\n+                               const unsigned char *key, size_t keylen);\n+\n+int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,\n+               X509_STORE *store, BIO *dcont, BIO *out, unsigned int flags);\n+\n+int CMS_verify_receipt(CMS_ContentInfo *rcms, CMS_ContentInfo *ocms,\n+                       STACK_OF(X509) *certs,\n+                       X509_STORE *store, unsigned int flags);\n+\n+STACK_OF(X509) *CMS_get0_signers(CMS_ContentInfo *cms);\n+\n+CMS_ContentInfo *CMS_encrypt(STACK_OF(X509) *certs, BIO *in,\n+                             const EVP_CIPHER *cipher, unsigned int flags);\n+\n+int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pkey, X509 *cert,\n+                BIO *dcont, BIO *out, unsigned int flags);\n+\n+int CMS_decrypt_set1_pkey(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert);\n+int CMS_decrypt_set1_key(CMS_ContentInfo *cms,\n+                         unsigned char *key, size_t keylen,\n+                         unsigned char *id, size_t idlen);\n+int CMS_decrypt_set1_password(CMS_ContentInfo *cms,\n+                              unsigned char *pass, ossl_ssize_t passlen);\n+\n+STACK_OF(CMS_RecipientInfo) *CMS_get0_RecipientInfos(CMS_ContentInfo *cms);\n+int CMS_RecipientInfo_type(CMS_RecipientInfo *ri);\n+EVP_PKEY_CTX *CMS_RecipientInfo_get0_pkey_ctx(CMS_RecipientInfo *ri);\n+CMS_ContentInfo *CMS_EnvelopedData_create(const EVP_CIPHER *cipher);\n+CMS_RecipientInfo *CMS_add1_recipient_cert(CMS_ContentInfo *cms,\n+                                           X509 *recip, unsigned int flags);\n+int CMS_RecipientInfo_set0_pkey(CMS_RecipientInfo *ri, EVP_PKEY *pkey);\n+int CMS_RecipientInfo_ktri_cert_cmp(CMS_RecipientInfo *ri, X509 *cert);\n+int CMS_RecipientInfo_ktri_get0_algs(CMS_RecipientInfo *ri,\n+                                     EVP_PKEY **pk, X509 **recip,\n+                                     X509_ALGOR **palg);\n+int CMS_RecipientInfo_ktri_get0_signer_id(CMS_RecipientInfo *ri,\n+                                          ASN1_OCTET_STRING **keyid,\n+                                          X509_NAME **issuer,\n+                                          ASN1_INTEGER **sno);\n+\n+CMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid,\n+                                          unsigned char *key, size_t keylen,\n+                                          unsigned char *id, size_t idlen,\n+                                          ASN1_GENERALIZEDTIME *date,\n+                                          ASN1_OBJECT *otherTypeId,\n+                                          ASN1_TYPE *otherType);\n+\n+int CMS_RecipientInfo_kekri_get0_id(CMS_RecipientInfo *ri,\n+                                    X509_ALGOR **palg,\n+                                    ASN1_OCTET_STRING **pid,\n+                                    ASN1_GENERALIZEDTIME **pdate,\n+                                    ASN1_OBJECT **potherid,\n+                                    ASN1_TYPE **pothertype);\n+\n+int CMS_RecipientInfo_set0_key(CMS_RecipientInfo *ri,\n+                               unsigned char *key, size_t keylen);\n+\n+int CMS_RecipientInfo_kekri_id_cmp(CMS_RecipientInfo *ri,\n+                                   const unsigned char *id, size_t idlen);\n+\n+int CMS_RecipientInfo_set0_password(CMS_RecipientInfo *ri,\n+                                    unsigned char *pass,\n+                                    ossl_ssize_t passlen);\n+\n+CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,\n+                                               int iter, int wrap_nid,\n+                                               int pbe_nid,\n+                                               unsigned char *pass,\n+                                               ossl_ssize_t passlen,\n+                                               const EVP_CIPHER *kekciph);\n+\n+int CMS_RecipientInfo_decrypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri);\n+int CMS_RecipientInfo_encrypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri);\n+\n+int CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out,\n+                   unsigned int flags);\n+CMS_ContentInfo *CMS_compress(BIO *in, int comp_nid, unsigned int flags);\n+\n+int CMS_set1_eContentType(CMS_ContentInfo *cms, const ASN1_OBJECT *oid);\n+const ASN1_OBJECT *CMS_get0_eContentType(CMS_ContentInfo *cms);\n+\n+CMS_CertificateChoices *CMS_add0_CertificateChoices(CMS_ContentInfo *cms);\n+int CMS_add0_cert(CMS_ContentInfo *cms, X509 *cert);\n+int CMS_add1_cert(CMS_ContentInfo *cms, X509 *cert);\n+STACK_OF(X509) *CMS_get1_certs(CMS_ContentInfo *cms);\n+\n+CMS_RevocationInfoChoice *CMS_add0_RevocationInfoChoice(CMS_ContentInfo *cms);\n+int CMS_add0_crl(CMS_ContentInfo *cms, X509_CRL *crl);\n+int CMS_add1_crl(CMS_ContentInfo *cms, X509_CRL *crl);\n+STACK_OF(X509_CRL) *CMS_get1_crls(CMS_ContentInfo *cms);\n+\n+int CMS_SignedData_init(CMS_ContentInfo *cms);\n+CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,\n+                                X509 *signer, EVP_PKEY *pk, const EVP_MD *md,\n+                                unsigned int flags);\n+EVP_PKEY_CTX *CMS_SignerInfo_get0_pkey_ctx(CMS_SignerInfo *si);\n+EVP_MD_CTX *CMS_SignerInfo_get0_md_ctx(CMS_SignerInfo *si);\n+STACK_OF(CMS_SignerInfo) *CMS_get0_SignerInfos(CMS_ContentInfo *cms);\n+\n+void CMS_SignerInfo_set1_signer_cert(CMS_SignerInfo *si, X509 *signer);\n+int CMS_SignerInfo_get0_signer_id(CMS_SignerInfo *si,\n+                                  ASN1_OCTET_STRING **keyid,\n+                                  X509_NAME **issuer, ASN1_INTEGER **sno);\n+int CMS_SignerInfo_cert_cmp(CMS_SignerInfo *si, X509 *cert);\n+int CMS_set1_signers_certs(CMS_ContentInfo *cms, STACK_OF(X509) *certs,\n+                           unsigned int flags);\n+void CMS_SignerInfo_get0_algs(CMS_SignerInfo *si, EVP_PKEY **pk,\n+                              X509 **signer, X509_ALGOR **pdig,\n+                              X509_ALGOR **psig);\n+ASN1_OCTET_STRING *CMS_SignerInfo_get0_signature(CMS_SignerInfo *si);\n+int CMS_SignerInfo_sign(CMS_SignerInfo *si);\n+int CMS_SignerInfo_verify(CMS_SignerInfo *si);\n+int CMS_SignerInfo_verify_content(CMS_SignerInfo *si, BIO *chain);\n+\n+int CMS_add_smimecap(CMS_SignerInfo *si, STACK_OF(X509_ALGOR) *algs);\n+int CMS_add_simple_smimecap(STACK_OF(X509_ALGOR) **algs,\n+                            int algnid, int keysize);\n+int CMS_add_standard_smimecap(STACK_OF(X509_ALGOR) **smcap);\n+\n+int CMS_signed_get_attr_count(const CMS_SignerInfo *si);\n+int CMS_signed_get_attr_by_NID(const CMS_SignerInfo *si, int nid,\n+                               int lastpos);\n+int CMS_signed_get_attr_by_OBJ(const CMS_SignerInfo *si, ASN1_OBJECT *obj,\n+                               int lastpos);\n+X509_ATTRIBUTE *CMS_signed_get_attr(const CMS_SignerInfo *si, int loc);\n+X509_ATTRIBUTE *CMS_signed_delete_attr(CMS_SignerInfo *si, int loc);\n+int CMS_signed_add1_attr(CMS_SignerInfo *si, X509_ATTRIBUTE *attr);\n+int CMS_signed_add1_attr_by_OBJ(CMS_SignerInfo *si,\n+                                const ASN1_OBJECT *obj, int type,\n+                                const void *bytes, int len);\n+int CMS_signed_add1_attr_by_NID(CMS_SignerInfo *si,\n+                                int nid, int type,\n+                                const void *bytes, int len);\n+int CMS_signed_add1_attr_by_txt(CMS_SignerInfo *si,\n+                                const char *attrname, int type,\n+                                const void *bytes, int len);\n+void *CMS_signed_get0_data_by_OBJ(CMS_SignerInfo *si, ASN1_OBJECT *oid,\n+                                  int lastpos, int type);\n+\n+int CMS_unsigned_get_attr_count(const CMS_SignerInfo *si);\n+int CMS_unsigned_get_attr_by_NID(const CMS_SignerInfo *si, int nid,\n+                                 int lastpos);\n+int CMS_unsigned_get_attr_by_OBJ(const CMS_SignerInfo *si, ASN1_OBJECT *obj,\n+                                 int lastpos);\n+X509_ATTRIBUTE *CMS_unsigned_get_attr(const CMS_SignerInfo *si, int loc);\n+X509_ATTRIBUTE *CMS_unsigned_delete_attr(CMS_SignerInfo *si, int loc);\n+int CMS_unsigned_add1_attr(CMS_SignerInfo *si, X509_ATTRIBUTE *attr);\n+int CMS_unsigned_add1_attr_by_OBJ(CMS_SignerInfo *si,\n+                                  const ASN1_OBJECT *obj, int type,\n+                                  const void *bytes, int len);\n+int CMS_unsigned_add1_attr_by_NID(CMS_SignerInfo *si,\n+                                  int nid, int type,\n+                                  const void *bytes, int len);\n+int CMS_unsigned_add1_attr_by_txt(CMS_SignerInfo *si,\n+                                  const char *attrname, int type,\n+                                  const void *bytes, int len);\n+void *CMS_unsigned_get0_data_by_OBJ(CMS_SignerInfo *si, ASN1_OBJECT *oid,\n+                                    int lastpos, int type);\n+\n+# ifdef HEADER_X509V3_H\n+\n+int CMS_get1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest **prr);\n+CMS_ReceiptRequest *CMS_ReceiptRequest_create0(unsigned char *id, int idlen,\n+                                               int allorfirst,\n+                                               STACK_OF(GENERAL_NAMES)\n+                                               *receiptList, STACK_OF(GENERAL_NAMES)\n+                                               *receiptsTo);\n+int CMS_add1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest *rr);\n+void CMS_ReceiptRequest_get0_values(CMS_ReceiptRequest *rr,\n+                                    ASN1_STRING **pcid,\n+                                    int *pallorfirst,\n+                                    STACK_OF(GENERAL_NAMES) **plist,\n+                                    STACK_OF(GENERAL_NAMES) **prto);\n+# endif\n+int CMS_RecipientInfo_kari_get0_alg(CMS_RecipientInfo *ri,\n+                                    X509_ALGOR **palg,\n+                                    ASN1_OCTET_STRING **pukm);\n+STACK_OF(CMS_RecipientEncryptedKey)\n+*CMS_RecipientInfo_kari_get0_reks(CMS_RecipientInfo *ri);\n+\n+int CMS_RecipientInfo_kari_get0_orig_id(CMS_RecipientInfo *ri,\n+                                        X509_ALGOR **pubalg,\n+                                        ASN1_BIT_STRING **pubkey,\n+                                        ASN1_OCTET_STRING **keyid,\n+                                        X509_NAME **issuer,\n+                                        ASN1_INTEGER **sno);\n+\n+int CMS_RecipientInfo_kari_orig_id_cmp(CMS_RecipientInfo *ri, X509 *cert);\n+\n+int CMS_RecipientEncryptedKey_get0_id(CMS_RecipientEncryptedKey *rek,\n+                                      ASN1_OCTET_STRING **keyid,\n+                                      ASN1_GENERALIZEDTIME **tm,\n+                                      CMS_OtherKeyAttribute **other,\n+                                      X509_NAME **issuer, ASN1_INTEGER **sno);\n+int CMS_RecipientEncryptedKey_cert_cmp(CMS_RecipientEncryptedKey *rek,\n+                                       X509 *cert);\n+int CMS_RecipientInfo_kari_set0_pkey(CMS_RecipientInfo *ri, EVP_PKEY *pk);\n+EVP_CIPHER_CTX *CMS_RecipientInfo_kari_get0_ctx(CMS_RecipientInfo *ri);\n+int CMS_RecipientInfo_kari_decrypt(CMS_ContentInfo *cms,\n+                                   CMS_RecipientInfo *ri,\n+                                   CMS_RecipientEncryptedKey *rek);\n+\n+int CMS_SharedInfo_encode(unsigned char **pder, X509_ALGOR *kekalg,\n+                          ASN1_OCTET_STRING *ukm, int keylen);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_CMS_strings(void);\n+\n+/* Error codes for the CMS functions. */\n+\n+/* Function codes. */\n+# define CMS_F_CHECK_CONTENT                              99\n+# define CMS_F_CMS_ADD0_CERT                              164\n+# define CMS_F_CMS_ADD0_RECIPIENT_KEY                     100\n+# define CMS_F_CMS_ADD0_RECIPIENT_PASSWORD                165\n+# define CMS_F_CMS_ADD1_RECEIPTREQUEST                    158\n+# define CMS_F_CMS_ADD1_RECIPIENT_CERT                    101\n+# define CMS_F_CMS_ADD1_SIGNER                            102\n+# define CMS_F_CMS_ADD1_SIGNINGTIME                       103\n+# define CMS_F_CMS_COMPRESS                               104\n+# define CMS_F_CMS_COMPRESSEDDATA_CREATE                  105\n+# define CMS_F_CMS_COMPRESSEDDATA_INIT_BIO                106\n+# define CMS_F_CMS_COPY_CONTENT                           107\n+# define CMS_F_CMS_COPY_MESSAGEDIGEST                     108\n+# define CMS_F_CMS_DATA                                   109\n+# define CMS_F_CMS_DATAFINAL                              110\n+# define CMS_F_CMS_DATAINIT                               111\n+# define CMS_F_CMS_DECRYPT                                112\n+# define CMS_F_CMS_DECRYPT_SET1_KEY                       113\n+# define CMS_F_CMS_DECRYPT_SET1_PASSWORD                  166\n+# define CMS_F_CMS_DECRYPT_SET1_PKEY                      114\n+# define CMS_F_CMS_DIGESTALGORITHM_FIND_CTX               115\n+# define CMS_F_CMS_DIGESTALGORITHM_INIT_BIO               116\n+# define CMS_F_CMS_DIGESTEDDATA_DO_FINAL                  117\n+# define CMS_F_CMS_DIGEST_VERIFY                          118\n+# define CMS_F_CMS_ENCODE_RECEIPT                         161\n+# define CMS_F_CMS_ENCRYPT                                119\n+# define CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO              120\n+# define CMS_F_CMS_ENCRYPTEDDATA_DECRYPT                  121\n+# define CMS_F_CMS_ENCRYPTEDDATA_ENCRYPT                  122\n+# define CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY                 123\n+# define CMS_F_CMS_ENVELOPEDDATA_CREATE                   124\n+# define CMS_F_CMS_ENVELOPEDDATA_INIT_BIO                 125\n+# define CMS_F_CMS_ENVELOPED_DATA_INIT                    126\n+# define CMS_F_CMS_ENV_ASN1_CTRL                          171\n+# define CMS_F_CMS_FINAL                                  127\n+# define CMS_F_CMS_GET0_CERTIFICATE_CHOICES               128\n+# define CMS_F_CMS_GET0_CONTENT                           129\n+# define CMS_F_CMS_GET0_ECONTENT_TYPE                     130\n+# define CMS_F_CMS_GET0_ENVELOPED                         131\n+# define CMS_F_CMS_GET0_REVOCATION_CHOICES                132\n+# define CMS_F_CMS_GET0_SIGNED                            133\n+# define CMS_F_CMS_MSGSIGDIGEST_ADD1                      162\n+# define CMS_F_CMS_RECEIPTREQUEST_CREATE0                 159\n+# define CMS_F_CMS_RECEIPT_VERIFY                         160\n+# define CMS_F_CMS_RECIPIENTINFO_DECRYPT                  134\n+# define CMS_F_CMS_RECIPIENTINFO_ENCRYPT                  169\n+# define CMS_F_CMS_RECIPIENTINFO_KARI_ENCRYPT             178\n+# define CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ALG            175\n+# define CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ORIG_ID        173\n+# define CMS_F_CMS_RECIPIENTINFO_KARI_GET0_REKS           172\n+# define CMS_F_CMS_RECIPIENTINFO_KARI_ORIG_ID_CMP         174\n+# define CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT            135\n+# define CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT            136\n+# define CMS_F_CMS_RECIPIENTINFO_KEKRI_GET0_ID            137\n+# define CMS_F_CMS_RECIPIENTINFO_KEKRI_ID_CMP             138\n+# define CMS_F_CMS_RECIPIENTINFO_KTRI_CERT_CMP            139\n+# define CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT             140\n+# define CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT             141\n+# define CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_ALGS           142\n+# define CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_SIGNER_ID      143\n+# define CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT               167\n+# define CMS_F_CMS_RECIPIENTINFO_SET0_KEY                 144\n+# define CMS_F_CMS_RECIPIENTINFO_SET0_PASSWORD            168\n+# define CMS_F_CMS_RECIPIENTINFO_SET0_PKEY                145\n+# define CMS_F_CMS_SD_ASN1_CTRL                           170\n+# define CMS_F_CMS_SET1_IAS                               176\n+# define CMS_F_CMS_SET1_KEYID                             177\n+# define CMS_F_CMS_SET1_SIGNERIDENTIFIER                  146\n+# define CMS_F_CMS_SET_DETACHED                           147\n+# define CMS_F_CMS_SIGN                                   148\n+# define CMS_F_CMS_SIGNED_DATA_INIT                       149\n+# define CMS_F_CMS_SIGNERINFO_CONTENT_SIGN                150\n+# define CMS_F_CMS_SIGNERINFO_SIGN                        151\n+# define CMS_F_CMS_SIGNERINFO_VERIFY                      152\n+# define CMS_F_CMS_SIGNERINFO_VERIFY_CERT                 153\n+# define CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT              154\n+# define CMS_F_CMS_SIGN_RECEIPT                           163\n+# define CMS_F_CMS_STREAM                                 155\n+# define CMS_F_CMS_UNCOMPRESS                             156\n+# define CMS_F_CMS_VERIFY                                 157\n+\n+/* Reason codes. */\n+# define CMS_R_ADD_SIGNER_ERROR                           99\n+# define CMS_R_CERTIFICATE_ALREADY_PRESENT                175\n+# define CMS_R_CERTIFICATE_HAS_NO_KEYID                   160\n+# define CMS_R_CERTIFICATE_VERIFY_ERROR                   100\n+# define CMS_R_CIPHER_INITIALISATION_ERROR                101\n+# define CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR      102\n+# define CMS_R_CMS_DATAFINAL_ERROR                        103\n+# define CMS_R_CMS_LIB                                    104\n+# define CMS_R_CONTENTIDENTIFIER_MISMATCH                 170\n+# define CMS_R_CONTENT_NOT_FOUND                          105\n+# define CMS_R_CONTENT_TYPE_MISMATCH                      171\n+# define CMS_R_CONTENT_TYPE_NOT_COMPRESSED_DATA           106\n+# define CMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA            107\n+# define CMS_R_CONTENT_TYPE_NOT_SIGNED_DATA               108\n+# define CMS_R_CONTENT_VERIFY_ERROR                       109\n+# define CMS_R_CTRL_ERROR                                 110\n+# define CMS_R_CTRL_FAILURE                               111\n+# define CMS_R_DECRYPT_ERROR                              112\n+# define CMS_R_DIGEST_ERROR                               161\n+# define CMS_R_ERROR_GETTING_PUBLIC_KEY                   113\n+# define CMS_R_ERROR_READING_MESSAGEDIGEST_ATTRIBUTE      114\n+# define CMS_R_ERROR_SETTING_KEY                          115\n+# define CMS_R_ERROR_SETTING_RECIPIENTINFO                116\n+# define CMS_R_INVALID_ENCRYPTED_KEY_LENGTH               117\n+# define CMS_R_INVALID_KEY_ENCRYPTION_PARAMETER           176\n+# define CMS_R_INVALID_KEY_LENGTH                         118\n+# define CMS_R_MD_BIO_INIT_ERROR                          119\n+# define CMS_R_MESSAGEDIGEST_ATTRIBUTE_WRONG_LENGTH       120\n+# define CMS_R_MESSAGEDIGEST_WRONG_LENGTH                 121\n+# define CMS_R_MSGSIGDIGEST_ERROR                         172\n+# define CMS_R_MSGSIGDIGEST_VERIFICATION_FAILURE          162\n+# define CMS_R_MSGSIGDIGEST_WRONG_LENGTH                  163\n+# define CMS_R_NEED_ONE_SIGNER                            164\n+# define CMS_R_NOT_A_SIGNED_RECEIPT                       165\n+# define CMS_R_NOT_ENCRYPTED_DATA                         122\n+# define CMS_R_NOT_KEK                                    123\n+# define CMS_R_NOT_KEY_AGREEMENT                          181\n+# define CMS_R_NOT_KEY_TRANSPORT                          124\n+# define CMS_R_NOT_PWRI                                   177\n+# define CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE            125\n+# define CMS_R_NO_CIPHER                                  126\n+# define CMS_R_NO_CONTENT                                 127\n+# define CMS_R_NO_CONTENT_TYPE                            173\n+# define CMS_R_NO_DEFAULT_DIGEST                          128\n+# define CMS_R_NO_DIGEST_SET                              129\n+# define CMS_R_NO_KEY                                     130\n+# define CMS_R_NO_KEY_OR_CERT                             174\n+# define CMS_R_NO_MATCHING_DIGEST                         131\n+# define CMS_R_NO_MATCHING_RECIPIENT                      132\n+# define CMS_R_NO_MATCHING_SIGNATURE                      166\n+# define CMS_R_NO_MSGSIGDIGEST                            167\n+# define CMS_R_NO_PASSWORD                                178\n+# define CMS_R_NO_PRIVATE_KEY                             133\n+# define CMS_R_NO_PUBLIC_KEY                              134\n+# define CMS_R_NO_RECEIPT_REQUEST                         168\n+# define CMS_R_NO_SIGNERS                                 135\n+# define CMS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE     136\n+# define CMS_R_RECEIPT_DECODE_ERROR                       169\n+# define CMS_R_RECIPIENT_ERROR                            137\n+# define CMS_R_SIGNER_CERTIFICATE_NOT_FOUND               138\n+# define CMS_R_SIGNFINAL_ERROR                            139\n+# define CMS_R_SMIME_TEXT_ERROR                           140\n+# define CMS_R_STORE_INIT_ERROR                           141\n+# define CMS_R_TYPE_NOT_COMPRESSED_DATA                   142\n+# define CMS_R_TYPE_NOT_DATA                              143\n+# define CMS_R_TYPE_NOT_DIGESTED_DATA                     144\n+# define CMS_R_TYPE_NOT_ENCRYPTED_DATA                    145\n+# define CMS_R_TYPE_NOT_ENVELOPED_DATA                    146\n+# define CMS_R_UNABLE_TO_FINALIZE_CONTEXT                 147\n+# define CMS_R_UNKNOWN_CIPHER                             148\n+# define CMS_R_UNKNOWN_DIGEST_ALGORIHM                    149\n+# define CMS_R_UNKNOWN_ID                                 150\n+# define CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM          151\n+# define CMS_R_UNSUPPORTED_CONTENT_TYPE                   152\n+# define CMS_R_UNSUPPORTED_KEK_ALGORITHM                  153\n+# define CMS_R_UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM       179\n+# define CMS_R_UNSUPPORTED_RECIPIENT_TYPE                 154\n+# define CMS_R_UNSUPPORTED_RECPIENTINFO_TYPE              155\n+# define CMS_R_UNSUPPORTED_TYPE                           156\n+# define CMS_R_UNWRAP_ERROR                               157\n+# define CMS_R_UNWRAP_FAILURE                             180\n+# define CMS_R_VERIFICATION_FAILURE                       158\n+# define CMS_R_WRAP_ERROR                                 159\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "df599ba3314bfb3d07401596f9b6e630f53e6b9b",
            "filename": "deps/openssl/openssl/include/openssl/comp.h",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcomp.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcomp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcomp.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,83 @@\n+\n+#ifndef HEADER_COMP_H\n+# define HEADER_COMP_H\n+\n+# include <openssl/crypto.h>\n+\n+# ifdef OPENSSL_NO_COMP\n+#  error COMP is disabled.\n+# endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct comp_ctx_st COMP_CTX;\n+\n+struct comp_method_st {\n+    int type;                   /* NID for compression library */\n+    const char *name;           /* A text string to identify the library */\n+    int (*init) (COMP_CTX *ctx);\n+    void (*finish) (COMP_CTX *ctx);\n+    int (*compress) (COMP_CTX *ctx,\n+                     unsigned char *out, unsigned int olen,\n+                     unsigned char *in, unsigned int ilen);\n+    int (*expand) (COMP_CTX *ctx,\n+                   unsigned char *out, unsigned int olen,\n+                   unsigned char *in, unsigned int ilen);\n+    /*\n+     * The following two do NOTHING, but are kept for backward compatibility\n+     */\n+    long (*ctrl) (void);\n+    long (*callback_ctrl) (void);\n+};\n+\n+struct comp_ctx_st {\n+    COMP_METHOD *meth;\n+    unsigned long compress_in;\n+    unsigned long compress_out;\n+    unsigned long expand_in;\n+    unsigned long expand_out;\n+    CRYPTO_EX_DATA ex_data;\n+};\n+\n+COMP_CTX *COMP_CTX_new(COMP_METHOD *meth);\n+void COMP_CTX_free(COMP_CTX *ctx);\n+int COMP_compress_block(COMP_CTX *ctx, unsigned char *out, int olen,\n+                        unsigned char *in, int ilen);\n+int COMP_expand_block(COMP_CTX *ctx, unsigned char *out, int olen,\n+                      unsigned char *in, int ilen);\n+COMP_METHOD *COMP_rle(void);\n+COMP_METHOD *COMP_zlib(void);\n+void COMP_zlib_cleanup(void);\n+\n+# ifdef HEADER_BIO_H\n+#  ifdef ZLIB\n+BIO_METHOD *BIO_f_zlib(void);\n+#  endif\n+# endif\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_COMP_strings(void);\n+\n+/* Error codes for the COMP functions. */\n+\n+/* Function codes. */\n+# define COMP_F_BIO_ZLIB_FLUSH                            99\n+# define COMP_F_BIO_ZLIB_NEW                              100\n+# define COMP_F_BIO_ZLIB_READ                             101\n+# define COMP_F_BIO_ZLIB_WRITE                            102\n+\n+/* Reason codes. */\n+# define COMP_R_ZLIB_DEFLATE_ERROR                        99\n+# define COMP_R_ZLIB_INFLATE_ERROR                        100\n+# define COMP_R_ZLIB_NOT_SUPPORTED                        101\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "fe49113080b700b21f2e79e7942a7d26e4b9b1b9",
            "filename": "deps/openssl/openssl/include/openssl/conf.h",
            "status": "added",
            "additions": 268,
            "deletions": 0,
            "changes": 268,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fconf.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fconf.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fconf.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,268 @@\n+/* crypto/conf/conf.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef  HEADER_CONF_H\n+# define HEADER_CONF_H\n+\n+# include <openssl/bio.h>\n+# include <openssl/lhash.h>\n+# include <openssl/stack.h>\n+# include <openssl/safestack.h>\n+# include <openssl/e_os2.h>\n+\n+# include <openssl/ossl_typ.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct {\n+    char *section;\n+    char *name;\n+    char *value;\n+} CONF_VALUE;\n+\n+DECLARE_STACK_OF(CONF_VALUE)\n+DECLARE_LHASH_OF(CONF_VALUE);\n+\n+struct conf_st;\n+struct conf_method_st;\n+typedef struct conf_method_st CONF_METHOD;\n+\n+struct conf_method_st {\n+    const char *name;\n+    CONF *(*create) (CONF_METHOD *meth);\n+    int (*init) (CONF *conf);\n+    int (*destroy) (CONF *conf);\n+    int (*destroy_data) (CONF *conf);\n+    int (*load_bio) (CONF *conf, BIO *bp, long *eline);\n+    int (*dump) (const CONF *conf, BIO *bp);\n+    int (*is_number) (const CONF *conf, char c);\n+    int (*to_int) (const CONF *conf, char c);\n+    int (*load) (CONF *conf, const char *name, long *eline);\n+};\n+\n+/* Module definitions */\n+\n+typedef struct conf_imodule_st CONF_IMODULE;\n+typedef struct conf_module_st CONF_MODULE;\n+\n+DECLARE_STACK_OF(CONF_MODULE)\n+DECLARE_STACK_OF(CONF_IMODULE)\n+\n+/* DSO module function typedefs */\n+typedef int conf_init_func (CONF_IMODULE *md, const CONF *cnf);\n+typedef void conf_finish_func (CONF_IMODULE *md);\n+\n+# define CONF_MFLAGS_IGNORE_ERRORS       0x1\n+# define CONF_MFLAGS_IGNORE_RETURN_CODES 0x2\n+# define CONF_MFLAGS_SILENT              0x4\n+# define CONF_MFLAGS_NO_DSO              0x8\n+# define CONF_MFLAGS_IGNORE_MISSING_FILE 0x10\n+# define CONF_MFLAGS_DEFAULT_SECTION     0x20\n+\n+int CONF_set_default_method(CONF_METHOD *meth);\n+void CONF_set_nconf(CONF *conf, LHASH_OF(CONF_VALUE) *hash);\n+LHASH_OF(CONF_VALUE) *CONF_load(LHASH_OF(CONF_VALUE) *conf, const char *file,\n+                                long *eline);\n+# ifndef OPENSSL_NO_FP_API\n+LHASH_OF(CONF_VALUE) *CONF_load_fp(LHASH_OF(CONF_VALUE) *conf, FILE *fp,\n+                                   long *eline);\n+# endif\n+LHASH_OF(CONF_VALUE) *CONF_load_bio(LHASH_OF(CONF_VALUE) *conf, BIO *bp,\n+                                    long *eline);\n+STACK_OF(CONF_VALUE) *CONF_get_section(LHASH_OF(CONF_VALUE) *conf,\n+                                       const char *section);\n+char *CONF_get_string(LHASH_OF(CONF_VALUE) *conf, const char *group,\n+                      const char *name);\n+long CONF_get_number(LHASH_OF(CONF_VALUE) *conf, const char *group,\n+                     const char *name);\n+void CONF_free(LHASH_OF(CONF_VALUE) *conf);\n+int CONF_dump_fp(LHASH_OF(CONF_VALUE) *conf, FILE *out);\n+int CONF_dump_bio(LHASH_OF(CONF_VALUE) *conf, BIO *out);\n+\n+void OPENSSL_config(const char *config_name);\n+void OPENSSL_no_config(void);\n+\n+/*\n+ * New conf code.  The semantics are different from the functions above. If\n+ * that wasn't the case, the above functions would have been replaced\n+ */\n+\n+struct conf_st {\n+    CONF_METHOD *meth;\n+    void *meth_data;\n+    LHASH_OF(CONF_VALUE) *data;\n+};\n+\n+CONF *NCONF_new(CONF_METHOD *meth);\n+CONF_METHOD *NCONF_default(void);\n+CONF_METHOD *NCONF_WIN32(void);\n+# if 0                          /* Just to give you an idea of what I have in\n+                                 * mind */\n+CONF_METHOD *NCONF_XML(void);\n+# endif\n+void NCONF_free(CONF *conf);\n+void NCONF_free_data(CONF *conf);\n+\n+int NCONF_load(CONF *conf, const char *file, long *eline);\n+# ifndef OPENSSL_NO_FP_API\n+int NCONF_load_fp(CONF *conf, FILE *fp, long *eline);\n+# endif\n+int NCONF_load_bio(CONF *conf, BIO *bp, long *eline);\n+STACK_OF(CONF_VALUE) *NCONF_get_section(const CONF *conf,\n+                                        const char *section);\n+char *NCONF_get_string(const CONF *conf, const char *group, const char *name);\n+int NCONF_get_number_e(const CONF *conf, const char *group, const char *name,\n+                       long *result);\n+int NCONF_dump_fp(const CONF *conf, FILE *out);\n+int NCONF_dump_bio(const CONF *conf, BIO *out);\n+\n+# if 0                          /* The following function has no error\n+                                 * checking, and should therefore be avoided */\n+long NCONF_get_number(CONF *conf, char *group, char *name);\n+# else\n+#  define NCONF_get_number(c,g,n,r) NCONF_get_number_e(c,g,n,r)\n+# endif\n+\n+/* Module functions */\n+\n+int CONF_modules_load(const CONF *cnf, const char *appname,\n+                      unsigned long flags);\n+int CONF_modules_load_file(const char *filename, const char *appname,\n+                           unsigned long flags);\n+void CONF_modules_unload(int all);\n+void CONF_modules_finish(void);\n+void CONF_modules_free(void);\n+int CONF_module_add(const char *name, conf_init_func *ifunc,\n+                    conf_finish_func *ffunc);\n+\n+const char *CONF_imodule_get_name(const CONF_IMODULE *md);\n+const char *CONF_imodule_get_value(const CONF_IMODULE *md);\n+void *CONF_imodule_get_usr_data(const CONF_IMODULE *md);\n+void CONF_imodule_set_usr_data(CONF_IMODULE *md, void *usr_data);\n+CONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md);\n+unsigned long CONF_imodule_get_flags(const CONF_IMODULE *md);\n+void CONF_imodule_set_flags(CONF_IMODULE *md, unsigned long flags);\n+void *CONF_module_get_usr_data(CONF_MODULE *pmod);\n+void CONF_module_set_usr_data(CONF_MODULE *pmod, void *usr_data);\n+\n+char *CONF_get1_default_config_file(void);\n+\n+int CONF_parse_list(const char *list, int sep, int nospc,\n+                    int (*list_cb) (const char *elem, int len, void *usr),\n+                    void *arg);\n+\n+void OPENSSL_load_builtin_modules(void);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_CONF_strings(void);\n+\n+/* Error codes for the CONF functions. */\n+\n+/* Function codes. */\n+# define CONF_F_CONF_DUMP_FP                              104\n+# define CONF_F_CONF_LOAD                                 100\n+# define CONF_F_CONF_LOAD_BIO                             102\n+# define CONF_F_CONF_LOAD_FP                              103\n+# define CONF_F_CONF_MODULES_LOAD                         116\n+# define CONF_F_CONF_PARSE_LIST                           119\n+# define CONF_F_DEF_LOAD                                  120\n+# define CONF_F_DEF_LOAD_BIO                              121\n+# define CONF_F_MODULE_INIT                               115\n+# define CONF_F_MODULE_LOAD_DSO                           117\n+# define CONF_F_MODULE_RUN                                118\n+# define CONF_F_NCONF_DUMP_BIO                            105\n+# define CONF_F_NCONF_DUMP_FP                             106\n+# define CONF_F_NCONF_GET_NUMBER                          107\n+# define CONF_F_NCONF_GET_NUMBER_E                        112\n+# define CONF_F_NCONF_GET_SECTION                         108\n+# define CONF_F_NCONF_GET_STRING                          109\n+# define CONF_F_NCONF_LOAD                                113\n+# define CONF_F_NCONF_LOAD_BIO                            110\n+# define CONF_F_NCONF_LOAD_FP                             114\n+# define CONF_F_NCONF_NEW                                 111\n+# define CONF_F_STR_COPY                                  101\n+\n+/* Reason codes. */\n+# define CONF_R_ERROR_LOADING_DSO                         110\n+# define CONF_R_LIST_CANNOT_BE_NULL                       115\n+# define CONF_R_MISSING_CLOSE_SQUARE_BRACKET              100\n+# define CONF_R_MISSING_EQUAL_SIGN                        101\n+# define CONF_R_MISSING_FINISH_FUNCTION                   111\n+# define CONF_R_MISSING_INIT_FUNCTION                     112\n+# define CONF_R_MODULE_INITIALIZATION_ERROR               109\n+# define CONF_R_NO_CLOSE_BRACE                            102\n+# define CONF_R_NO_CONF                                   105\n+# define CONF_R_NO_CONF_OR_ENVIRONMENT_VARIABLE           106\n+# define CONF_R_NO_SECTION                                107\n+# define CONF_R_NO_SUCH_FILE                              114\n+# define CONF_R_NO_VALUE                                  108\n+# define CONF_R_UNABLE_TO_CREATE_NEW_SECTION              103\n+# define CONF_R_UNKNOWN_MODULE_NAME                       113\n+# define CONF_R_VARIABLE_EXPANSION_TOO_LONG               116\n+# define CONF_R_VARIABLE_HAS_NO_VALUE                     104\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "e478f7df4b1163e55a06f869ae51fe3ff35910b3",
            "filename": "deps/openssl/openssl/include/openssl/conf_api.h",
            "status": "added",
            "additions": 89,
            "deletions": 0,
            "changes": 89,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fconf_api.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fconf_api.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fconf_api.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,89 @@\n+/* conf_api.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef  HEADER_CONF_API_H\n+# define HEADER_CONF_API_H\n+\n+# include <openssl/lhash.h>\n+# include <openssl/conf.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Up until OpenSSL 0.9.5a, this was new_section */\n+CONF_VALUE *_CONF_new_section(CONF *conf, const char *section);\n+/* Up until OpenSSL 0.9.5a, this was get_section */\n+CONF_VALUE *_CONF_get_section(const CONF *conf, const char *section);\n+/* Up until OpenSSL 0.9.5a, this was CONF_get_section */\n+STACK_OF(CONF_VALUE) *_CONF_get_section_values(const CONF *conf,\n+                                               const char *section);\n+\n+int _CONF_add_string(CONF *conf, CONF_VALUE *section, CONF_VALUE *value);\n+char *_CONF_get_string(const CONF *conf, const char *section,\n+                       const char *name);\n+long _CONF_get_number(const CONF *conf, const char *section,\n+                      const char *name);\n+\n+int _CONF_new_data(CONF *conf);\n+void _CONF_free_data(CONF *conf);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "6c644ce12a82507532be3f2edee3605f06d15b79",
            "filename": "deps/openssl/openssl/include/openssl/crypto.h",
            "status": "added",
            "additions": 661,
            "deletions": 0,
            "changes": 661,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcrypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcrypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fcrypto.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,661 @@\n+/* crypto/crypto.h */\n+/* ====================================================================\n+ * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+/* ====================================================================\n+ * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\n+ * ECDH support in OpenSSL originally developed by\n+ * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.\n+ */\n+\n+#ifndef HEADER_CRYPTO_H\n+# define HEADER_CRYPTO_H\n+\n+# include <stdlib.h>\n+\n+# include <openssl/e_os2.h>\n+\n+# ifndef OPENSSL_NO_FP_API\n+#  include <stdio.h>\n+# endif\n+\n+# include <openssl/stack.h>\n+# include <openssl/safestack.h>\n+# include <openssl/opensslv.h>\n+# include <openssl/ossl_typ.h>\n+\n+# ifdef CHARSET_EBCDIC\n+#  include <openssl/ebcdic.h>\n+# endif\n+\n+/*\n+ * Resolve problems on some operating systems with symbol names that clash\n+ * one way or another\n+ */\n+# include <openssl/symhacks.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Backward compatibility to SSLeay */\n+/*\n+ * This is more to be used to check the correct DLL is being used in the MS\n+ * world.\n+ */\n+# define SSLEAY_VERSION_NUMBER   OPENSSL_VERSION_NUMBER\n+# define SSLEAY_VERSION          0\n+/* #define SSLEAY_OPTIONS       1 no longer supported */\n+# define SSLEAY_CFLAGS           2\n+# define SSLEAY_BUILT_ON         3\n+# define SSLEAY_PLATFORM         4\n+# define SSLEAY_DIR              5\n+\n+/* Already declared in ossl_typ.h */\n+# if 0\n+typedef struct crypto_ex_data_st CRYPTO_EX_DATA;\n+/* Called when a new object is created */\n+typedef int CRYPTO_EX_new (void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n+                           int idx, long argl, void *argp);\n+/* Called when an object is free()ed */\n+typedef void CRYPTO_EX_free (void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n+                             int idx, long argl, void *argp);\n+/* Called when we need to dup an object */\n+typedef int CRYPTO_EX_dup (CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from,\n+                           void *from_d, int idx, long argl, void *argp);\n+# endif\n+\n+/* A generic structure to pass assorted data in a expandable way */\n+typedef struct openssl_item_st {\n+    int code;\n+    void *value;                /* Not used for flag attributes */\n+    size_t value_size;          /* Max size of value for output, length for\n+                                 * input */\n+    size_t *value_length;       /* Returned length of value for output */\n+} OPENSSL_ITEM;\n+\n+/*\n+ * When changing the CRYPTO_LOCK_* list, be sure to maintin the text lock\n+ * names in cryptlib.c\n+ */\n+\n+# define CRYPTO_LOCK_ERR                 1\n+# define CRYPTO_LOCK_EX_DATA             2\n+# define CRYPTO_LOCK_X509                3\n+# define CRYPTO_LOCK_X509_INFO           4\n+# define CRYPTO_LOCK_X509_PKEY           5\n+# define CRYPTO_LOCK_X509_CRL            6\n+# define CRYPTO_LOCK_X509_REQ            7\n+# define CRYPTO_LOCK_DSA                 8\n+# define CRYPTO_LOCK_RSA                 9\n+# define CRYPTO_LOCK_EVP_PKEY            10\n+# define CRYPTO_LOCK_X509_STORE          11\n+# define CRYPTO_LOCK_SSL_CTX             12\n+# define CRYPTO_LOCK_SSL_CERT            13\n+# define CRYPTO_LOCK_SSL_SESSION         14\n+# define CRYPTO_LOCK_SSL_SESS_CERT       15\n+# define CRYPTO_LOCK_SSL                 16\n+# define CRYPTO_LOCK_SSL_METHOD          17\n+# define CRYPTO_LOCK_RAND                18\n+# define CRYPTO_LOCK_RAND2               19\n+# define CRYPTO_LOCK_MALLOC              20\n+# define CRYPTO_LOCK_BIO                 21\n+# define CRYPTO_LOCK_GETHOSTBYNAME       22\n+# define CRYPTO_LOCK_GETSERVBYNAME       23\n+# define CRYPTO_LOCK_READDIR             24\n+# define CRYPTO_LOCK_RSA_BLINDING        25\n+# define CRYPTO_LOCK_DH                  26\n+# define CRYPTO_LOCK_MALLOC2             27\n+# define CRYPTO_LOCK_DSO                 28\n+# define CRYPTO_LOCK_DYNLOCK             29\n+# define CRYPTO_LOCK_ENGINE              30\n+# define CRYPTO_LOCK_UI                  31\n+# define CRYPTO_LOCK_ECDSA               32\n+# define CRYPTO_LOCK_EC                  33\n+# define CRYPTO_LOCK_ECDH                34\n+# define CRYPTO_LOCK_BN                  35\n+# define CRYPTO_LOCK_EC_PRE_COMP         36\n+# define CRYPTO_LOCK_STORE               37\n+# define CRYPTO_LOCK_COMP                38\n+# define CRYPTO_LOCK_FIPS                39\n+# define CRYPTO_LOCK_FIPS2               40\n+# define CRYPTO_NUM_LOCKS                41\n+\n+# define CRYPTO_LOCK             1\n+# define CRYPTO_UNLOCK           2\n+# define CRYPTO_READ             4\n+# define CRYPTO_WRITE            8\n+\n+# ifndef OPENSSL_NO_LOCKING\n+#  ifndef CRYPTO_w_lock\n+#   define CRYPTO_w_lock(type)     \\\n+        CRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n+#   define CRYPTO_w_unlock(type)   \\\n+        CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)\n+#   define CRYPTO_r_lock(type)     \\\n+        CRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n+#   define CRYPTO_r_unlock(type)   \\\n+        CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ,type,__FILE__,__LINE__)\n+#   define CRYPTO_add(addr,amount,type)    \\\n+        CRYPTO_add_lock(addr,amount,type,__FILE__,__LINE__)\n+#  endif\n+# else\n+#  define CRYPTO_w_lock(a)\n+#  define CRYPTO_w_unlock(a)\n+#  define CRYPTO_r_lock(a)\n+#  define CRYPTO_r_unlock(a)\n+#  define CRYPTO_add(a,b,c)       ((*(a))+=(b))\n+# endif\n+\n+/*\n+ * Some applications as well as some parts of OpenSSL need to allocate and\n+ * deallocate locks in a dynamic fashion.  The following typedef makes this\n+ * possible in a type-safe manner.\n+ */\n+/* struct CRYPTO_dynlock_value has to be defined by the application. */\n+typedef struct {\n+    int references;\n+    struct CRYPTO_dynlock_value *data;\n+} CRYPTO_dynlock;\n+\n+/*\n+ * The following can be used to detect memory leaks in the SSLeay library. It\n+ * used, it turns on malloc checking\n+ */\n+\n+# define CRYPTO_MEM_CHECK_OFF    0x0/* an enume */\n+# define CRYPTO_MEM_CHECK_ON     0x1/* a bit */\n+# define CRYPTO_MEM_CHECK_ENABLE 0x2/* a bit */\n+# define CRYPTO_MEM_CHECK_DISABLE 0x3/* an enume */\n+\n+/*\n+ * The following are bit values to turn on or off options connected to the\n+ * malloc checking functionality\n+ */\n+\n+/* Adds time to the memory checking information */\n+# define V_CRYPTO_MDEBUG_TIME    0x1/* a bit */\n+/* Adds thread number to the memory checking information */\n+# define V_CRYPTO_MDEBUG_THREAD  0x2/* a bit */\n+\n+# define V_CRYPTO_MDEBUG_ALL (V_CRYPTO_MDEBUG_TIME | V_CRYPTO_MDEBUG_THREAD)\n+\n+/* predec of the BIO type */\n+typedef struct bio_st BIO_dummy;\n+\n+struct crypto_ex_data_st {\n+    STACK_OF(void) *sk;\n+    /* gcc is screwing up this data structure :-( */\n+    int dummy;\n+};\n+DECLARE_STACK_OF(void)\n+\n+/*\n+ * This stuff is basically class callback functions The current classes are\n+ * SSL_CTX, SSL, SSL_SESSION, and a few more\n+ */\n+\n+typedef struct crypto_ex_data_func_st {\n+    long argl;                  /* Arbitary long */\n+    void *argp;                 /* Arbitary void * */\n+    CRYPTO_EX_new *new_func;\n+    CRYPTO_EX_free *free_func;\n+    CRYPTO_EX_dup *dup_func;\n+} CRYPTO_EX_DATA_FUNCS;\n+\n+DECLARE_STACK_OF(CRYPTO_EX_DATA_FUNCS)\n+\n+/*\n+ * Per class, we have a STACK of CRYPTO_EX_DATA_FUNCS for each CRYPTO_EX_DATA\n+ * entry.\n+ */\n+\n+# define CRYPTO_EX_INDEX_BIO             0\n+# define CRYPTO_EX_INDEX_SSL             1\n+# define CRYPTO_EX_INDEX_SSL_CTX         2\n+# define CRYPTO_EX_INDEX_SSL_SESSION     3\n+# define CRYPTO_EX_INDEX_X509_STORE      4\n+# define CRYPTO_EX_INDEX_X509_STORE_CTX  5\n+# define CRYPTO_EX_INDEX_RSA             6\n+# define CRYPTO_EX_INDEX_DSA             7\n+# define CRYPTO_EX_INDEX_DH              8\n+# define CRYPTO_EX_INDEX_ENGINE          9\n+# define CRYPTO_EX_INDEX_X509            10\n+# define CRYPTO_EX_INDEX_UI              11\n+# define CRYPTO_EX_INDEX_ECDSA           12\n+# define CRYPTO_EX_INDEX_ECDH            13\n+# define CRYPTO_EX_INDEX_COMP            14\n+# define CRYPTO_EX_INDEX_STORE           15\n+\n+/*\n+ * Dynamically assigned indexes start from this value (don't use directly,\n+ * use via CRYPTO_ex_data_new_class).\n+ */\n+# define CRYPTO_EX_INDEX_USER            100\n+\n+/*\n+ * This is the default callbacks, but we can have others as well: this is\n+ * needed in Win32 where the application malloc and the library malloc may\n+ * not be the same.\n+ */\n+# define CRYPTO_malloc_init()    CRYPTO_set_mem_functions(\\\n+        malloc, realloc, free)\n+\n+# if defined CRYPTO_MDEBUG_ALL || defined CRYPTO_MDEBUG_TIME || defined CRYPTO_MDEBUG_THREAD\n+#  ifndef CRYPTO_MDEBUG         /* avoid duplicate #define */\n+#   define CRYPTO_MDEBUG\n+#  endif\n+# endif\n+\n+/*\n+ * Set standard debugging functions (not done by default unless CRYPTO_MDEBUG\n+ * is defined)\n+ */\n+# define CRYPTO_malloc_debug_init()      do {\\\n+        CRYPTO_set_mem_debug_functions(\\\n+                CRYPTO_dbg_malloc,\\\n+                CRYPTO_dbg_realloc,\\\n+                CRYPTO_dbg_free,\\\n+                CRYPTO_dbg_set_options,\\\n+                CRYPTO_dbg_get_options);\\\n+        } while(0)\n+\n+int CRYPTO_mem_ctrl(int mode);\n+int CRYPTO_is_mem_check_on(void);\n+\n+/* for applications */\n+# define MemCheck_start() CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON)\n+# define MemCheck_stop() CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_OFF)\n+\n+/* for library-internal use */\n+# define MemCheck_on()   CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ENABLE)\n+# define MemCheck_off()  CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_DISABLE)\n+# define is_MemCheck_on() CRYPTO_is_mem_check_on()\n+\n+# define OPENSSL_malloc(num)     CRYPTO_malloc((int)num,__FILE__,__LINE__)\n+# define OPENSSL_strdup(str)     CRYPTO_strdup((str),__FILE__,__LINE__)\n+# define OPENSSL_realloc(addr,num) \\\n+        CRYPTO_realloc((char *)addr,(int)num,__FILE__,__LINE__)\n+# define OPENSSL_realloc_clean(addr,old_num,num) \\\n+        CRYPTO_realloc_clean(addr,old_num,num,__FILE__,__LINE__)\n+# define OPENSSL_remalloc(addr,num) \\\n+        CRYPTO_remalloc((char **)addr,(int)num,__FILE__,__LINE__)\n+# define OPENSSL_freeFunc        CRYPTO_free\n+# define OPENSSL_free(addr)      CRYPTO_free(addr)\n+\n+# define OPENSSL_malloc_locked(num) \\\n+        CRYPTO_malloc_locked((int)num,__FILE__,__LINE__)\n+# define OPENSSL_free_locked(addr) CRYPTO_free_locked(addr)\n+\n+const char *SSLeay_version(int type);\n+unsigned long SSLeay(void);\n+\n+int OPENSSL_issetugid(void);\n+\n+/* An opaque type representing an implementation of \"ex_data\" support */\n+typedef struct st_CRYPTO_EX_DATA_IMPL CRYPTO_EX_DATA_IMPL;\n+/* Return an opaque pointer to the current \"ex_data\" implementation */\n+const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void);\n+/* Sets the \"ex_data\" implementation to be used (if it's not too late) */\n+int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i);\n+/* Get a new \"ex_data\" class, and return the corresponding \"class_index\" */\n+int CRYPTO_ex_data_new_class(void);\n+/* Within a given class, get/register a new index */\n+int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,\n+                            CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\n+                            CRYPTO_EX_free *free_func);\n+/*\n+ * Initialise/duplicate/free CRYPTO_EX_DATA variables corresponding to a\n+ * given class (invokes whatever per-class callbacks are applicable)\n+ */\n+int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);\n+int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,\n+                       CRYPTO_EX_DATA *from);\n+void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);\n+/*\n+ * Get/set data in a CRYPTO_EX_DATA variable corresponding to a particular\n+ * index (relative to the class type involved)\n+ */\n+int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val);\n+void *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx);\n+/*\n+ * This function cleans up all \"ex_data\" state. It mustn't be called under\n+ * potential race-conditions.\n+ */\n+void CRYPTO_cleanup_all_ex_data(void);\n+\n+int CRYPTO_get_new_lockid(char *name);\n+\n+int CRYPTO_num_locks(void);     /* return CRYPTO_NUM_LOCKS (shared libs!) */\n+void CRYPTO_lock(int mode, int type, const char *file, int line);\n+void CRYPTO_set_locking_callback(void (*func) (int mode, int type,\n+                                               const char *file, int line));\n+void (*CRYPTO_get_locking_callback(void)) (int mode, int type,\n+                                           const char *file, int line);\n+void CRYPTO_set_add_lock_callback(int (*func)\n+                                   (int *num, int mount, int type,\n+                                    const char *file, int line));\n+int (*CRYPTO_get_add_lock_callback(void)) (int *num, int mount, int type,\n+                                           const char *file, int line);\n+\n+/* Don't use this structure directly. */\n+typedef struct crypto_threadid_st {\n+    void *ptr;\n+    unsigned long val;\n+} CRYPTO_THREADID;\n+/* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */\n+void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);\n+void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);\n+int CRYPTO_THREADID_set_callback(void (*threadid_func) (CRYPTO_THREADID *));\n+void (*CRYPTO_THREADID_get_callback(void)) (CRYPTO_THREADID *);\n+void CRYPTO_THREADID_current(CRYPTO_THREADID *id);\n+int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a, const CRYPTO_THREADID *b);\n+void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest, const CRYPTO_THREADID *src);\n+unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);\n+# ifndef OPENSSL_NO_DEPRECATED\n+void CRYPTO_set_id_callback(unsigned long (*func) (void));\n+unsigned long (*CRYPTO_get_id_callback(void)) (void);\n+unsigned long CRYPTO_thread_id(void);\n+# endif\n+\n+const char *CRYPTO_get_lock_name(int type);\n+int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,\n+                    int line);\n+\n+int CRYPTO_get_new_dynlockid(void);\n+void CRYPTO_destroy_dynlockid(int i);\n+struct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i);\n+void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value\n+                                        *(*dyn_create_function) (const char\n+                                                                 *file,\n+                                                                 int line));\n+void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)\n+                                       (int mode,\n+                                        struct CRYPTO_dynlock_value *l,\n+                                        const char *file, int line));\n+void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)\n+                                          (struct CRYPTO_dynlock_value *l,\n+                                           const char *file, int line));\n+struct CRYPTO_dynlock_value\n+*(*CRYPTO_get_dynlock_create_callback(void)) (const char *file, int line);\n+void (*CRYPTO_get_dynlock_lock_callback(void)) (int mode,\n+                                                struct CRYPTO_dynlock_value\n+                                                *l, const char *file,\n+                                                int line);\n+void (*CRYPTO_get_dynlock_destroy_callback(void)) (struct CRYPTO_dynlock_value\n+                                                   *l, const char *file,\n+                                                   int line);\n+\n+/*\n+ * CRYPTO_set_mem_functions includes CRYPTO_set_locked_mem_functions -- call\n+ * the latter last if you need different functions\n+ */\n+int CRYPTO_set_mem_functions(void *(*m) (size_t), void *(*r) (void *, size_t),\n+                             void (*f) (void *));\n+int CRYPTO_set_locked_mem_functions(void *(*m) (size_t),\n+                                    void (*free_func) (void *));\n+int CRYPTO_set_mem_ex_functions(void *(*m) (size_t, const char *, int),\n+                                void *(*r) (void *, size_t, const char *,\n+                                            int), void (*f) (void *));\n+int CRYPTO_set_locked_mem_ex_functions(void *(*m) (size_t, const char *, int),\n+                                       void (*free_func) (void *));\n+int CRYPTO_set_mem_debug_functions(void (*m)\n+                                    (void *, int, const char *, int, int),\n+                                   void (*r) (void *, void *, int,\n+                                              const char *, int, int),\n+                                   void (*f) (void *, int), void (*so) (long),\n+                                   long (*go) (void));\n+void CRYPTO_get_mem_functions(void *(**m) (size_t),\n+                              void *(**r) (void *, size_t),\n+                              void (**f) (void *));\n+void CRYPTO_get_locked_mem_functions(void *(**m) (size_t),\n+                                     void (**f) (void *));\n+void CRYPTO_get_mem_ex_functions(void *(**m) (size_t, const char *, int),\n+                                 void *(**r) (void *, size_t, const char *,\n+                                              int), void (**f) (void *));\n+void CRYPTO_get_locked_mem_ex_functions(void\n+                                        *(**m) (size_t, const char *, int),\n+                                        void (**f) (void *));\n+void CRYPTO_get_mem_debug_functions(void (**m)\n+                                     (void *, int, const char *, int, int),\n+                                    void (**r) (void *, void *, int,\n+                                                const char *, int, int),\n+                                    void (**f) (void *, int),\n+                                    void (**so) (long), long (**go) (void));\n+\n+void *CRYPTO_malloc_locked(int num, const char *file, int line);\n+void CRYPTO_free_locked(void *ptr);\n+void *CRYPTO_malloc(int num, const char *file, int line);\n+char *CRYPTO_strdup(const char *str, const char *file, int line);\n+void CRYPTO_free(void *ptr);\n+void *CRYPTO_realloc(void *addr, int num, const char *file, int line);\n+void *CRYPTO_realloc_clean(void *addr, int old_num, int num, const char *file,\n+                           int line);\n+void *CRYPTO_remalloc(void *addr, int num, const char *file, int line);\n+\n+void OPENSSL_cleanse(void *ptr, size_t len);\n+\n+void CRYPTO_set_mem_debug_options(long bits);\n+long CRYPTO_get_mem_debug_options(void);\n+\n+# define CRYPTO_push_info(info) \\\n+        CRYPTO_push_info_(info, __FILE__, __LINE__);\n+int CRYPTO_push_info_(const char *info, const char *file, int line);\n+int CRYPTO_pop_info(void);\n+int CRYPTO_remove_all_info(void);\n+\n+/*\n+ * Default debugging functions (enabled by CRYPTO_malloc_debug_init() macro;\n+ * used as default in CRYPTO_MDEBUG compilations):\n+ */\n+/*-\n+ * The last argument has the following significance:\n+ *\n+ * 0:   called before the actual memory allocation has taken place\n+ * 1:   called after the actual memory allocation has taken place\n+ */\n+void CRYPTO_dbg_malloc(void *addr, int num, const char *file, int line,\n+                       int before_p);\n+void CRYPTO_dbg_realloc(void *addr1, void *addr2, int num, const char *file,\n+                        int line, int before_p);\n+void CRYPTO_dbg_free(void *addr, int before_p);\n+/*-\n+ * Tell the debugging code about options.  By default, the following values\n+ * apply:\n+ *\n+ * 0:                           Clear all options.\n+ * V_CRYPTO_MDEBUG_TIME (1):    Set the \"Show Time\" option.\n+ * V_CRYPTO_MDEBUG_THREAD (2):  Set the \"Show Thread Number\" option.\n+ * V_CRYPTO_MDEBUG_ALL (3):     1 + 2\n+ */\n+void CRYPTO_dbg_set_options(long bits);\n+long CRYPTO_dbg_get_options(void);\n+\n+# ifndef OPENSSL_NO_FP_API\n+void CRYPTO_mem_leaks_fp(FILE *);\n+# endif\n+void CRYPTO_mem_leaks(struct bio_st *bio);\n+/* unsigned long order, char *file, int line, int num_bytes, char *addr */\n+typedef void *CRYPTO_MEM_LEAK_CB (unsigned long, const char *, int, int,\n+                                  void *);\n+void CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb);\n+\n+/* die if we have to */\n+void OpenSSLDie(const char *file, int line, const char *assertion);\n+# define OPENSSL_assert(e)       (void)((e) ? 0 : (OpenSSLDie(__FILE__, __LINE__, #e),1))\n+\n+unsigned long *OPENSSL_ia32cap_loc(void);\n+# define OPENSSL_ia32cap (*(OPENSSL_ia32cap_loc()))\n+int OPENSSL_isservice(void);\n+\n+int FIPS_mode(void);\n+int FIPS_mode_set(int r);\n+\n+void OPENSSL_init(void);\n+\n+# define fips_md_init(alg) fips_md_init_ctx(alg, alg)\n+\n+# ifdef OPENSSL_FIPS\n+#  define fips_md_init_ctx(alg, cx) \\\n+        int alg##_Init(cx##_CTX *c) \\\n+        { \\\n+        if (FIPS_mode()) OpenSSLDie(__FILE__, __LINE__, \\\n+                \"Low level API call to digest \" #alg \" forbidden in FIPS mode!\"); \\\n+        return private_##alg##_Init(c); \\\n+        } \\\n+        int private_##alg##_Init(cx##_CTX *c)\n+\n+#  define fips_cipher_abort(alg) \\\n+        if (FIPS_mode()) OpenSSLDie(__FILE__, __LINE__, \\\n+                \"Low level API call to cipher \" #alg \" forbidden in FIPS mode!\")\n+\n+# else\n+#  define fips_md_init_ctx(alg, cx) \\\n+        int alg##_Init(cx##_CTX *c)\n+#  define fips_cipher_abort(alg) while(0)\n+# endif\n+\n+/*\n+ * CRYPTO_memcmp returns zero iff the |len| bytes at |a| and |b| are equal.\n+ * It takes an amount of time dependent on |len|, but independent of the\n+ * contents of |a| and |b|. Unlike memcmp, it cannot be used to put elements\n+ * into a defined order as the return value when a != b is undefined, other\n+ * than to be non-zero.\n+ */\n+int CRYPTO_memcmp(const volatile void *a, const volatile void *b, size_t len);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_CRYPTO_strings(void);\n+\n+/* Error codes for the CRYPTO functions. */\n+\n+/* Function codes. */\n+# define CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX                 100\n+# define CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID                103\n+# define CRYPTO_F_CRYPTO_GET_NEW_LOCKID                   101\n+# define CRYPTO_F_CRYPTO_SET_EX_DATA                      102\n+# define CRYPTO_F_DEF_ADD_INDEX                           104\n+# define CRYPTO_F_DEF_GET_CLASS                           105\n+# define CRYPTO_F_FIPS_MODE_SET                           109\n+# define CRYPTO_F_INT_DUP_EX_DATA                         106\n+# define CRYPTO_F_INT_FREE_EX_DATA                        107\n+# define CRYPTO_F_INT_NEW_EX_DATA                         108\n+\n+/* Reason codes. */\n+# define CRYPTO_R_FIPS_MODE_NOT_SUPPORTED                 101\n+# define CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK              100\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "1b40144e1b3641c6cd817e6fd2905674e3494dda",
            "filename": "deps/openssl/openssl/include/openssl/des.h",
            "status": "added",
            "additions": 257,
            "deletions": 0,
            "changes": 257,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdes.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdes.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,257 @@\n+/* crypto/des/des.h */\n+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_NEW_DES_H\n+# define HEADER_NEW_DES_H\n+\n+# include <openssl/e_os2.h>     /* OPENSSL_EXTERN, OPENSSL_NO_DES, DES_LONG\n+                                 * (via openssl/opensslconf.h */\n+\n+# ifdef OPENSSL_NO_DES\n+#  error DES is disabled.\n+# endif\n+\n+# ifdef OPENSSL_BUILD_SHLIBCRYPTO\n+#  undef OPENSSL_EXTERN\n+#  define OPENSSL_EXTERN OPENSSL_EXPORT\n+# endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef unsigned char DES_cblock[8];\n+typedef /* const */ unsigned char const_DES_cblock[8];\n+/*\n+ * With \"const\", gcc 2.8.1 on Solaris thinks that DES_cblock * and\n+ * const_DES_cblock * are incompatible pointer types.\n+ */\n+\n+typedef struct DES_ks {\n+    union {\n+        DES_cblock cblock;\n+        /*\n+         * make sure things are correct size on machines with 8 byte longs\n+         */\n+        DES_LONG deslong[2];\n+    } ks[16];\n+} DES_key_schedule;\n+\n+# ifndef OPENSSL_DISABLE_OLD_DES_SUPPORT\n+#  ifndef OPENSSL_ENABLE_OLD_DES_SUPPORT\n+#   define OPENSSL_ENABLE_OLD_DES_SUPPORT\n+#  endif\n+# endif\n+\n+# ifdef OPENSSL_ENABLE_OLD_DES_SUPPORT\n+#  include <openssl/des_old.h>\n+# endif\n+\n+# define DES_KEY_SZ      (sizeof(DES_cblock))\n+# define DES_SCHEDULE_SZ (sizeof(DES_key_schedule))\n+\n+# define DES_ENCRYPT     1\n+# define DES_DECRYPT     0\n+\n+# define DES_CBC_MODE    0\n+# define DES_PCBC_MODE   1\n+\n+# define DES_ecb2_encrypt(i,o,k1,k2,e) \\\n+        DES_ecb3_encrypt((i),(o),(k1),(k2),(k1),(e))\n+\n+# define DES_ede2_cbc_encrypt(i,o,l,k1,k2,iv,e) \\\n+        DES_ede3_cbc_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(e))\n+\n+# define DES_ede2_cfb64_encrypt(i,o,l,k1,k2,iv,n,e) \\\n+        DES_ede3_cfb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n),(e))\n+\n+# define DES_ede2_ofb64_encrypt(i,o,l,k1,k2,iv,n) \\\n+        DES_ede3_ofb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n))\n+\n+OPENSSL_DECLARE_GLOBAL(int, DES_check_key); /* defaults to false */\n+# define DES_check_key OPENSSL_GLOBAL_REF(DES_check_key)\n+OPENSSL_DECLARE_GLOBAL(int, DES_rw_mode); /* defaults to DES_PCBC_MODE */\n+# define DES_rw_mode OPENSSL_GLOBAL_REF(DES_rw_mode)\n+\n+const char *DES_options(void);\n+void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,\n+                      DES_key_schedule *ks1, DES_key_schedule *ks2,\n+                      DES_key_schedule *ks3, int enc);\n+DES_LONG DES_cbc_cksum(const unsigned char *input, DES_cblock *output,\n+                       long length, DES_key_schedule *schedule,\n+                       const_DES_cblock *ivec);\n+/* DES_cbc_encrypt does not update the IV!  Use DES_ncbc_encrypt instead. */\n+void DES_cbc_encrypt(const unsigned char *input, unsigned char *output,\n+                     long length, DES_key_schedule *schedule,\n+                     DES_cblock *ivec, int enc);\n+void DES_ncbc_encrypt(const unsigned char *input, unsigned char *output,\n+                      long length, DES_key_schedule *schedule,\n+                      DES_cblock *ivec, int enc);\n+void DES_xcbc_encrypt(const unsigned char *input, unsigned char *output,\n+                      long length, DES_key_schedule *schedule,\n+                      DES_cblock *ivec, const_DES_cblock *inw,\n+                      const_DES_cblock *outw, int enc);\n+void DES_cfb_encrypt(const unsigned char *in, unsigned char *out, int numbits,\n+                     long length, DES_key_schedule *schedule,\n+                     DES_cblock *ivec, int enc);\n+void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output,\n+                     DES_key_schedule *ks, int enc);\n+\n+/*\n+ * This is the DES encryption function that gets called by just about every\n+ * other DES routine in the library.  You should not use this function except\n+ * to implement 'modes' of DES.  I say this because the functions that call\n+ * this routine do the conversion from 'char *' to long, and this needs to be\n+ * done to make sure 'non-aligned' memory access do not occur.  The\n+ * characters are loaded 'little endian'. Data is a pointer to 2 unsigned\n+ * long's and ks is the DES_key_schedule to use.  enc, is non zero specifies\n+ * encryption, zero if decryption.\n+ */\n+void DES_encrypt1(DES_LONG *data, DES_key_schedule *ks, int enc);\n+\n+/*\n+ * This functions is the same as DES_encrypt1() except that the DES initial\n+ * permutation (IP) and final permutation (FP) have been left out.  As for\n+ * DES_encrypt1(), you should not use this function. It is used by the\n+ * routines in the library that implement triple DES. IP() DES_encrypt2()\n+ * DES_encrypt2() DES_encrypt2() FP() is the same as DES_encrypt1()\n+ * DES_encrypt1() DES_encrypt1() except faster :-).\n+ */\n+void DES_encrypt2(DES_LONG *data, DES_key_schedule *ks, int enc);\n+\n+void DES_encrypt3(DES_LONG *data, DES_key_schedule *ks1,\n+                  DES_key_schedule *ks2, DES_key_schedule *ks3);\n+void DES_decrypt3(DES_LONG *data, DES_key_schedule *ks1,\n+                  DES_key_schedule *ks2, DES_key_schedule *ks3);\n+void DES_ede3_cbc_encrypt(const unsigned char *input, unsigned char *output,\n+                          long length,\n+                          DES_key_schedule *ks1, DES_key_schedule *ks2,\n+                          DES_key_schedule *ks3, DES_cblock *ivec, int enc);\n+void DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out,\n+                           long length,\n+                           DES_key_schedule *ks1, DES_key_schedule *ks2,\n+                           DES_key_schedule *ks3,\n+                           DES_cblock *ivec1, DES_cblock *ivec2, int enc);\n+void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n+                            long length, DES_key_schedule *ks1,\n+                            DES_key_schedule *ks2, DES_key_schedule *ks3,\n+                            DES_cblock *ivec, int *num, int enc);\n+void DES_ede3_cfb_encrypt(const unsigned char *in, unsigned char *out,\n+                          int numbits, long length, DES_key_schedule *ks1,\n+                          DES_key_schedule *ks2, DES_key_schedule *ks3,\n+                          DES_cblock *ivec, int enc);\n+void DES_ede3_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n+                            long length, DES_key_schedule *ks1,\n+                            DES_key_schedule *ks2, DES_key_schedule *ks3,\n+                            DES_cblock *ivec, int *num);\n+# if 0\n+void DES_xwhite_in2out(const_DES_cblock *DES_key, const_DES_cblock *in_white,\n+                       DES_cblock *out_white);\n+# endif\n+\n+int DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,\n+                 DES_cblock *iv);\n+int DES_enc_write(int fd, const void *buf, int len, DES_key_schedule *sched,\n+                  DES_cblock *iv);\n+char *DES_fcrypt(const char *buf, const char *salt, char *ret);\n+char *DES_crypt(const char *buf, const char *salt);\n+void DES_ofb_encrypt(const unsigned char *in, unsigned char *out, int numbits,\n+                     long length, DES_key_schedule *schedule,\n+                     DES_cblock *ivec);\n+void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output,\n+                      long length, DES_key_schedule *schedule,\n+                      DES_cblock *ivec, int enc);\n+DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[],\n+                        long length, int out_count, DES_cblock *seed);\n+int DES_random_key(DES_cblock *ret);\n+void DES_set_odd_parity(DES_cblock *key);\n+int DES_check_key_parity(const_DES_cblock *key);\n+int DES_is_weak_key(const_DES_cblock *key);\n+/*\n+ * DES_set_key (= set_key = DES_key_sched = key_sched) calls\n+ * DES_set_key_checked if global variable DES_check_key is set,\n+ * DES_set_key_unchecked otherwise.\n+ */\n+int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule);\n+int DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule);\n+int DES_set_key_checked(const_DES_cblock *key, DES_key_schedule *schedule);\n+void DES_set_key_unchecked(const_DES_cblock *key, DES_key_schedule *schedule);\n+# ifdef OPENSSL_FIPS\n+void private_DES_set_key_unchecked(const_DES_cblock *key,\n+                                   DES_key_schedule *schedule);\n+# endif\n+void DES_string_to_key(const char *str, DES_cblock *key);\n+void DES_string_to_2keys(const char *str, DES_cblock *key1, DES_cblock *key2);\n+void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n+                       long length, DES_key_schedule *schedule,\n+                       DES_cblock *ivec, int *num, int enc);\n+void DES_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n+                       long length, DES_key_schedule *schedule,\n+                       DES_cblock *ivec, int *num);\n+\n+int DES_read_password(DES_cblock *key, const char *prompt, int verify);\n+int DES_read_2passwords(DES_cblock *key1, DES_cblock *key2,\n+                        const char *prompt, int verify);\n+\n+# define DES_fixup_key_parity DES_set_odd_parity\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "ee7607a2415f83fd9d52a6708ad53669835ddb48",
            "filename": "deps/openssl/openssl/include/openssl/des_old.h",
            "status": "added",
            "additions": 497,
            "deletions": 0,
            "changes": 497,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdes_old.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdes_old.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdes_old.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,497 @@\n+/* crypto/des/des_old.h */\n+\n+/*-\n+ * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING\n+ *\n+ * The function names in here are deprecated and are only present to\n+ * provide an interface compatible with openssl 0.9.6 and older as\n+ * well as libdes.  OpenSSL now provides functions where \"des_\" has\n+ * been replaced with \"DES_\" in the names, to make it possible to\n+ * make incompatible changes that are needed for C type security and\n+ * other stuff.\n+ *\n+ * This include files has two compatibility modes:\n+ *\n+ *   - If OPENSSL_DES_LIBDES_COMPATIBILITY is defined, you get an API\n+ *     that is compatible with libdes and SSLeay.\n+ *   - If OPENSSL_DES_LIBDES_COMPATIBILITY isn't defined, you get an\n+ *     API that is compatible with OpenSSL 0.9.5x to 0.9.6x.\n+ *\n+ * Note that these modes break earlier snapshots of OpenSSL, where\n+ * libdes compatibility was the only available mode or (later on) the\n+ * prefered compatibility mode.  However, after much consideration\n+ * (and more or less violent discussions with external parties), it\n+ * was concluded that OpenSSL should be compatible with earlier versions\n+ * of itself before anything else.  Also, in all honesty, libdes is\n+ * an old beast that shouldn't really be used any more.\n+ *\n+ * Please consider starting to use the DES_ functions rather than the\n+ * des_ ones.  The des_ functions will disappear completely before\n+ * OpenSSL 1.0!\n+ *\n+ * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING\n+ */\n+\n+/*\n+ * Written by Richard Levitte (richard@levitte.org) for the OpenSSL project\n+ * 2001.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#ifndef HEADER_DES_H\n+# define HEADER_DES_H\n+\n+# include <openssl/e_os2.h>     /* OPENSSL_EXTERN, OPENSSL_NO_DES, DES_LONG */\n+\n+# ifdef OPENSSL_NO_DES\n+#  error DES is disabled.\n+# endif\n+\n+# ifndef HEADER_NEW_DES_H\n+#  error You must include des.h, not des_old.h directly.\n+# endif\n+\n+# ifdef _KERBEROS_DES_H\n+#  error <openssl/des_old.h> replaces <kerberos/des.h>.\n+# endif\n+\n+# include <openssl/symhacks.h>\n+\n+# ifdef OPENSSL_BUILD_SHLIBCRYPTO\n+#  undef OPENSSL_EXTERN\n+#  define OPENSSL_EXTERN OPENSSL_EXPORT\n+# endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# ifdef _\n+#  undef _\n+# endif\n+\n+typedef unsigned char _ossl_old_des_cblock[8];\n+typedef struct _ossl_old_des_ks_struct {\n+    union {\n+        _ossl_old_des_cblock _;\n+        /*\n+         * make sure things are correct size on machines with 8 byte longs\n+         */\n+        DES_LONG pad[2];\n+    } ks;\n+} _ossl_old_des_key_schedule[16];\n+\n+# ifndef OPENSSL_DES_LIBDES_COMPATIBILITY\n+#  define des_cblock DES_cblock\n+#  define const_des_cblock const_DES_cblock\n+#  define des_key_schedule DES_key_schedule\n+#  define des_ecb3_encrypt(i,o,k1,k2,k3,e)\\\n+        DES_ecb3_encrypt((i),(o),&(k1),&(k2),&(k3),(e))\n+#  define des_ede3_cbc_encrypt(i,o,l,k1,k2,k3,iv,e)\\\n+        DES_ede3_cbc_encrypt((i),(o),(l),&(k1),&(k2),&(k3),(iv),(e))\n+#  define des_ede3_cbcm_encrypt(i,o,l,k1,k2,k3,iv1,iv2,e)\\\n+        DES_ede3_cbcm_encrypt((i),(o),(l),&(k1),&(k2),&(k3),(iv1),(iv2),(e))\n+#  define des_ede3_cfb64_encrypt(i,o,l,k1,k2,k3,iv,n,e)\\\n+        DES_ede3_cfb64_encrypt((i),(o),(l),&(k1),&(k2),&(k3),(iv),(n),(e))\n+#  define des_ede3_ofb64_encrypt(i,o,l,k1,k2,k3,iv,n)\\\n+        DES_ede3_ofb64_encrypt((i),(o),(l),&(k1),&(k2),&(k3),(iv),(n))\n+#  define des_options()\\\n+        DES_options()\n+#  define des_cbc_cksum(i,o,l,k,iv)\\\n+        DES_cbc_cksum((i),(o),(l),&(k),(iv))\n+#  define des_cbc_encrypt(i,o,l,k,iv,e)\\\n+        DES_cbc_encrypt((i),(o),(l),&(k),(iv),(e))\n+#  define des_ncbc_encrypt(i,o,l,k,iv,e)\\\n+        DES_ncbc_encrypt((i),(o),(l),&(k),(iv),(e))\n+#  define des_xcbc_encrypt(i,o,l,k,iv,inw,outw,e)\\\n+        DES_xcbc_encrypt((i),(o),(l),&(k),(iv),(inw),(outw),(e))\n+#  define des_cfb_encrypt(i,o,n,l,k,iv,e)\\\n+        DES_cfb_encrypt((i),(o),(n),(l),&(k),(iv),(e))\n+#  define des_ecb_encrypt(i,o,k,e)\\\n+        DES_ecb_encrypt((i),(o),&(k),(e))\n+#  define des_encrypt1(d,k,e)\\\n+        DES_encrypt1((d),&(k),(e))\n+#  define des_encrypt2(d,k,e)\\\n+        DES_encrypt2((d),&(k),(e))\n+#  define des_encrypt3(d,k1,k2,k3)\\\n+        DES_encrypt3((d),&(k1),&(k2),&(k3))\n+#  define des_decrypt3(d,k1,k2,k3)\\\n+        DES_decrypt3((d),&(k1),&(k2),&(k3))\n+#  define des_xwhite_in2out(k,i,o)\\\n+        DES_xwhite_in2out((k),(i),(o))\n+#  define des_enc_read(f,b,l,k,iv)\\\n+        DES_enc_read((f),(b),(l),&(k),(iv))\n+#  define des_enc_write(f,b,l,k,iv)\\\n+        DES_enc_write((f),(b),(l),&(k),(iv))\n+#  define des_fcrypt(b,s,r)\\\n+        DES_fcrypt((b),(s),(r))\n+#  if 0\n+#   define des_crypt(b,s)\\\n+        DES_crypt((b),(s))\n+#   if !defined(PERL5) && !defined(__FreeBSD__) && !defined(NeXT) && !defined(__OpenBSD__)\n+#    define crypt(b,s)\\\n+        DES_crypt((b),(s))\n+#   endif\n+#  endif\n+#  define des_ofb_encrypt(i,o,n,l,k,iv)\\\n+        DES_ofb_encrypt((i),(o),(n),(l),&(k),(iv))\n+#  define des_pcbc_encrypt(i,o,l,k,iv,e)\\\n+        DES_pcbc_encrypt((i),(o),(l),&(k),(iv),(e))\n+#  define des_quad_cksum(i,o,l,c,s)\\\n+        DES_quad_cksum((i),(o),(l),(c),(s))\n+#  define des_random_seed(k)\\\n+        _ossl_096_des_random_seed((k))\n+#  define des_random_key(r)\\\n+        DES_random_key((r))\n+#  define des_read_password(k,p,v) \\\n+        DES_read_password((k),(p),(v))\n+#  define des_read_2passwords(k1,k2,p,v) \\\n+        DES_read_2passwords((k1),(k2),(p),(v))\n+#  define des_set_odd_parity(k)\\\n+        DES_set_odd_parity((k))\n+#  define des_check_key_parity(k)\\\n+        DES_check_key_parity((k))\n+#  define des_is_weak_key(k)\\\n+        DES_is_weak_key((k))\n+#  define des_set_key(k,ks)\\\n+        DES_set_key((k),&(ks))\n+#  define des_key_sched(k,ks)\\\n+        DES_key_sched((k),&(ks))\n+#  define des_set_key_checked(k,ks)\\\n+        DES_set_key_checked((k),&(ks))\n+#  define des_set_key_unchecked(k,ks)\\\n+        DES_set_key_unchecked((k),&(ks))\n+#  define des_string_to_key(s,k)\\\n+        DES_string_to_key((s),(k))\n+#  define des_string_to_2keys(s,k1,k2)\\\n+        DES_string_to_2keys((s),(k1),(k2))\n+#  define des_cfb64_encrypt(i,o,l,ks,iv,n,e)\\\n+        DES_cfb64_encrypt((i),(o),(l),&(ks),(iv),(n),(e))\n+#  define des_ofb64_encrypt(i,o,l,ks,iv,n)\\\n+        DES_ofb64_encrypt((i),(o),(l),&(ks),(iv),(n))\n+\n+#  define des_ecb2_encrypt(i,o,k1,k2,e) \\\n+        des_ecb3_encrypt((i),(o),(k1),(k2),(k1),(e))\n+\n+#  define des_ede2_cbc_encrypt(i,o,l,k1,k2,iv,e) \\\n+        des_ede3_cbc_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(e))\n+\n+#  define des_ede2_cfb64_encrypt(i,o,l,k1,k2,iv,n,e) \\\n+        des_ede3_cfb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n),(e))\n+\n+#  define des_ede2_ofb64_encrypt(i,o,l,k1,k2,iv,n) \\\n+        des_ede3_ofb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n))\n+\n+#  define des_check_key DES_check_key\n+#  define des_rw_mode DES_rw_mode\n+# else                          /* libdes compatibility */\n+/*\n+ * Map all symbol names to _ossl_old_des_* form, so we avoid all clashes with\n+ * libdes\n+ */\n+#  define des_cblock _ossl_old_des_cblock\n+#  define des_key_schedule _ossl_old_des_key_schedule\n+#  define des_ecb3_encrypt(i,o,k1,k2,k3,e)\\\n+        _ossl_old_des_ecb3_encrypt((i),(o),(k1),(k2),(k3),(e))\n+#  define des_ede3_cbc_encrypt(i,o,l,k1,k2,k3,iv,e)\\\n+        _ossl_old_des_ede3_cbc_encrypt((i),(o),(l),(k1),(k2),(k3),(iv),(e))\n+#  define des_ede3_cfb64_encrypt(i,o,l,k1,k2,k3,iv,n,e)\\\n+        _ossl_old_des_ede3_cfb64_encrypt((i),(o),(l),(k1),(k2),(k3),(iv),(n),(e))\n+#  define des_ede3_ofb64_encrypt(i,o,l,k1,k2,k3,iv,n)\\\n+        _ossl_old_des_ede3_ofb64_encrypt((i),(o),(l),(k1),(k2),(k3),(iv),(n))\n+#  define des_options()\\\n+        _ossl_old_des_options()\n+#  define des_cbc_cksum(i,o,l,k,iv)\\\n+        _ossl_old_des_cbc_cksum((i),(o),(l),(k),(iv))\n+#  define des_cbc_encrypt(i,o,l,k,iv,e)\\\n+        _ossl_old_des_cbc_encrypt((i),(o),(l),(k),(iv),(e))\n+#  define des_ncbc_encrypt(i,o,l,k,iv,e)\\\n+        _ossl_old_des_ncbc_encrypt((i),(o),(l),(k),(iv),(e))\n+#  define des_xcbc_encrypt(i,o,l,k,iv,inw,outw,e)\\\n+        _ossl_old_des_xcbc_encrypt((i),(o),(l),(k),(iv),(inw),(outw),(e))\n+#  define des_cfb_encrypt(i,o,n,l,k,iv,e)\\\n+        _ossl_old_des_cfb_encrypt((i),(o),(n),(l),(k),(iv),(e))\n+#  define des_ecb_encrypt(i,o,k,e)\\\n+        _ossl_old_des_ecb_encrypt((i),(o),(k),(e))\n+#  define des_encrypt(d,k,e)\\\n+        _ossl_old_des_encrypt((d),(k),(e))\n+#  define des_encrypt2(d,k,e)\\\n+        _ossl_old_des_encrypt2((d),(k),(e))\n+#  define des_encrypt3(d,k1,k2,k3)\\\n+        _ossl_old_des_encrypt3((d),(k1),(k2),(k3))\n+#  define des_decrypt3(d,k1,k2,k3)\\\n+        _ossl_old_des_decrypt3((d),(k1),(k2),(k3))\n+#  define des_xwhite_in2out(k,i,o)\\\n+        _ossl_old_des_xwhite_in2out((k),(i),(o))\n+#  define des_enc_read(f,b,l,k,iv)\\\n+        _ossl_old_des_enc_read((f),(b),(l),(k),(iv))\n+#  define des_enc_write(f,b,l,k,iv)\\\n+        _ossl_old_des_enc_write((f),(b),(l),(k),(iv))\n+#  define des_fcrypt(b,s,r)\\\n+        _ossl_old_des_fcrypt((b),(s),(r))\n+#  define des_crypt(b,s)\\\n+        _ossl_old_des_crypt((b),(s))\n+#  if 0\n+#   define crypt(b,s)\\\n+        _ossl_old_crypt((b),(s))\n+#  endif\n+#  define des_ofb_encrypt(i,o,n,l,k,iv)\\\n+        _ossl_old_des_ofb_encrypt((i),(o),(n),(l),(k),(iv))\n+#  define des_pcbc_encrypt(i,o,l,k,iv,e)\\\n+        _ossl_old_des_pcbc_encrypt((i),(o),(l),(k),(iv),(e))\n+#  define des_quad_cksum(i,o,l,c,s)\\\n+        _ossl_old_des_quad_cksum((i),(o),(l),(c),(s))\n+#  define des_random_seed(k)\\\n+        _ossl_old_des_random_seed((k))\n+#  define des_random_key(r)\\\n+        _ossl_old_des_random_key((r))\n+#  define des_read_password(k,p,v) \\\n+        _ossl_old_des_read_password((k),(p),(v))\n+#  define des_read_2passwords(k1,k2,p,v) \\\n+        _ossl_old_des_read_2passwords((k1),(k2),(p),(v))\n+#  define des_set_odd_parity(k)\\\n+        _ossl_old_des_set_odd_parity((k))\n+#  define des_is_weak_key(k)\\\n+        _ossl_old_des_is_weak_key((k))\n+#  define des_set_key(k,ks)\\\n+        _ossl_old_des_set_key((k),(ks))\n+#  define des_key_sched(k,ks)\\\n+        _ossl_old_des_key_sched((k),(ks))\n+#  define des_string_to_key(s,k)\\\n+        _ossl_old_des_string_to_key((s),(k))\n+#  define des_string_to_2keys(s,k1,k2)\\\n+        _ossl_old_des_string_to_2keys((s),(k1),(k2))\n+#  define des_cfb64_encrypt(i,o,l,ks,iv,n,e)\\\n+        _ossl_old_des_cfb64_encrypt((i),(o),(l),(ks),(iv),(n),(e))\n+#  define des_ofb64_encrypt(i,o,l,ks,iv,n)\\\n+        _ossl_old_des_ofb64_encrypt((i),(o),(l),(ks),(iv),(n))\n+\n+#  define des_ecb2_encrypt(i,o,k1,k2,e) \\\n+        des_ecb3_encrypt((i),(o),(k1),(k2),(k1),(e))\n+\n+#  define des_ede2_cbc_encrypt(i,o,l,k1,k2,iv,e) \\\n+        des_ede3_cbc_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(e))\n+\n+#  define des_ede2_cfb64_encrypt(i,o,l,k1,k2,iv,n,e) \\\n+        des_ede3_cfb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n),(e))\n+\n+#  define des_ede2_ofb64_encrypt(i,o,l,k1,k2,iv,n) \\\n+        des_ede3_ofb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n))\n+\n+#  define des_check_key DES_check_key\n+#  define des_rw_mode DES_rw_mode\n+# endif\n+\n+const char *_ossl_old_des_options(void);\n+void _ossl_old_des_ecb3_encrypt(_ossl_old_des_cblock *input,\n+                                _ossl_old_des_cblock *output,\n+                                _ossl_old_des_key_schedule ks1,\n+                                _ossl_old_des_key_schedule ks2,\n+                                _ossl_old_des_key_schedule ks3, int enc);\n+DES_LONG _ossl_old_des_cbc_cksum(_ossl_old_des_cblock *input,\n+                                 _ossl_old_des_cblock *output, long length,\n+                                 _ossl_old_des_key_schedule schedule,\n+                                 _ossl_old_des_cblock *ivec);\n+void _ossl_old_des_cbc_encrypt(_ossl_old_des_cblock *input,\n+                               _ossl_old_des_cblock *output, long length,\n+                               _ossl_old_des_key_schedule schedule,\n+                               _ossl_old_des_cblock *ivec, int enc);\n+void _ossl_old_des_ncbc_encrypt(_ossl_old_des_cblock *input,\n+                                _ossl_old_des_cblock *output, long length,\n+                                _ossl_old_des_key_schedule schedule,\n+                                _ossl_old_des_cblock *ivec, int enc);\n+void _ossl_old_des_xcbc_encrypt(_ossl_old_des_cblock *input,\n+                                _ossl_old_des_cblock *output, long length,\n+                                _ossl_old_des_key_schedule schedule,\n+                                _ossl_old_des_cblock *ivec,\n+                                _ossl_old_des_cblock *inw,\n+                                _ossl_old_des_cblock *outw, int enc);\n+void _ossl_old_des_cfb_encrypt(unsigned char *in, unsigned char *out,\n+                               int numbits, long length,\n+                               _ossl_old_des_key_schedule schedule,\n+                               _ossl_old_des_cblock *ivec, int enc);\n+void _ossl_old_des_ecb_encrypt(_ossl_old_des_cblock *input,\n+                               _ossl_old_des_cblock *output,\n+                               _ossl_old_des_key_schedule ks, int enc);\n+void _ossl_old_des_encrypt(DES_LONG *data, _ossl_old_des_key_schedule ks,\n+                           int enc);\n+void _ossl_old_des_encrypt2(DES_LONG *data, _ossl_old_des_key_schedule ks,\n+                            int enc);\n+void _ossl_old_des_encrypt3(DES_LONG *data, _ossl_old_des_key_schedule ks1,\n+                            _ossl_old_des_key_schedule ks2,\n+                            _ossl_old_des_key_schedule ks3);\n+void _ossl_old_des_decrypt3(DES_LONG *data, _ossl_old_des_key_schedule ks1,\n+                            _ossl_old_des_key_schedule ks2,\n+                            _ossl_old_des_key_schedule ks3);\n+void _ossl_old_des_ede3_cbc_encrypt(_ossl_old_des_cblock *input,\n+                                    _ossl_old_des_cblock *output, long length,\n+                                    _ossl_old_des_key_schedule ks1,\n+                                    _ossl_old_des_key_schedule ks2,\n+                                    _ossl_old_des_key_schedule ks3,\n+                                    _ossl_old_des_cblock *ivec, int enc);\n+void _ossl_old_des_ede3_cfb64_encrypt(unsigned char *in, unsigned char *out,\n+                                      long length,\n+                                      _ossl_old_des_key_schedule ks1,\n+                                      _ossl_old_des_key_schedule ks2,\n+                                      _ossl_old_des_key_schedule ks3,\n+                                      _ossl_old_des_cblock *ivec, int *num,\n+                                      int enc);\n+void _ossl_old_des_ede3_ofb64_encrypt(unsigned char *in, unsigned char *out,\n+                                      long length,\n+                                      _ossl_old_des_key_schedule ks1,\n+                                      _ossl_old_des_key_schedule ks2,\n+                                      _ossl_old_des_key_schedule ks3,\n+                                      _ossl_old_des_cblock *ivec, int *num);\n+# if 0\n+void _ossl_old_des_xwhite_in2out(_ossl_old_des_cblock (*des_key),\n+                                 _ossl_old_des_cblock (*in_white),\n+                                 _ossl_old_des_cblock (*out_white));\n+# endif\n+\n+int _ossl_old_des_enc_read(int fd, char *buf, int len,\n+                           _ossl_old_des_key_schedule sched,\n+                           _ossl_old_des_cblock *iv);\n+int _ossl_old_des_enc_write(int fd, char *buf, int len,\n+                            _ossl_old_des_key_schedule sched,\n+                            _ossl_old_des_cblock *iv);\n+char *_ossl_old_des_fcrypt(const char *buf, const char *salt, char *ret);\n+char *_ossl_old_des_crypt(const char *buf, const char *salt);\n+# if !defined(PERL5) && !defined(NeXT)\n+char *_ossl_old_crypt(const char *buf, const char *salt);\n+# endif\n+void _ossl_old_des_ofb_encrypt(unsigned char *in, unsigned char *out,\n+                               int numbits, long length,\n+                               _ossl_old_des_key_schedule schedule,\n+                               _ossl_old_des_cblock *ivec);\n+void _ossl_old_des_pcbc_encrypt(_ossl_old_des_cblock *input,\n+                                _ossl_old_des_cblock *output, long length,\n+                                _ossl_old_des_key_schedule schedule,\n+                                _ossl_old_des_cblock *ivec, int enc);\n+DES_LONG _ossl_old_des_quad_cksum(_ossl_old_des_cblock *input,\n+                                  _ossl_old_des_cblock *output, long length,\n+                                  int out_count, _ossl_old_des_cblock *seed);\n+void _ossl_old_des_random_seed(_ossl_old_des_cblock key);\n+void _ossl_old_des_random_key(_ossl_old_des_cblock ret);\n+int _ossl_old_des_read_password(_ossl_old_des_cblock *key, const char *prompt,\n+                                int verify);\n+int _ossl_old_des_read_2passwords(_ossl_old_des_cblock *key1,\n+                                  _ossl_old_des_cblock *key2,\n+                                  const char *prompt, int verify);\n+void _ossl_old_des_set_odd_parity(_ossl_old_des_cblock *key);\n+int _ossl_old_des_is_weak_key(_ossl_old_des_cblock *key);\n+int _ossl_old_des_set_key(_ossl_old_des_cblock *key,\n+                          _ossl_old_des_key_schedule schedule);\n+int _ossl_old_des_key_sched(_ossl_old_des_cblock *key,\n+                            _ossl_old_des_key_schedule schedule);\n+void _ossl_old_des_string_to_key(char *str, _ossl_old_des_cblock *key);\n+void _ossl_old_des_string_to_2keys(char *str, _ossl_old_des_cblock *key1,\n+                                   _ossl_old_des_cblock *key2);\n+void _ossl_old_des_cfb64_encrypt(unsigned char *in, unsigned char *out,\n+                                 long length,\n+                                 _ossl_old_des_key_schedule schedule,\n+                                 _ossl_old_des_cblock *ivec, int *num,\n+                                 int enc);\n+void _ossl_old_des_ofb64_encrypt(unsigned char *in, unsigned char *out,\n+                                 long length,\n+                                 _ossl_old_des_key_schedule schedule,\n+                                 _ossl_old_des_cblock *ivec, int *num);\n+\n+void _ossl_096_des_random_seed(des_cblock *key);\n+\n+/*\n+ * The following definitions provide compatibility with the MIT Kerberos\n+ * library. The _ossl_old_des_key_schedule structure is not binary\n+ * compatible.\n+ */\n+\n+# define _KERBEROS_DES_H\n+\n+# define KRBDES_ENCRYPT DES_ENCRYPT\n+# define KRBDES_DECRYPT DES_DECRYPT\n+\n+# ifdef KERBEROS\n+#  define ENCRYPT DES_ENCRYPT\n+#  define DECRYPT DES_DECRYPT\n+# endif\n+\n+# ifndef NCOMPAT\n+#  define C_Block des_cblock\n+#  define Key_schedule des_key_schedule\n+#  define KEY_SZ DES_KEY_SZ\n+#  define string_to_key des_string_to_key\n+#  define read_pw_string des_read_pw_string\n+#  define random_key des_random_key\n+#  define pcbc_encrypt des_pcbc_encrypt\n+#  define set_key des_set_key\n+#  define key_sched des_key_sched\n+#  define ecb_encrypt des_ecb_encrypt\n+#  define cbc_encrypt des_cbc_encrypt\n+#  define ncbc_encrypt des_ncbc_encrypt\n+#  define xcbc_encrypt des_xcbc_encrypt\n+#  define cbc_cksum des_cbc_cksum\n+#  define quad_cksum des_quad_cksum\n+#  define check_parity des_check_key_parity\n+# endif\n+\n+# define des_fixup_key_parity DES_fixup_key_parity\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+/* for DES_read_pw_string et al */\n+# include <openssl/ui_compat.h>\n+\n+#endif"
        },
        {
            "sha": "80b28fb39dc82d4bfdb7806491a99e6d649845bf",
            "filename": "deps/openssl/openssl/include/openssl/dh.h",
            "status": "added",
            "additions": 412,
            "deletions": 0,
            "changes": 412,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdh.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdh.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdh.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,412 @@\n+/* crypto/dh/dh.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_DH_H\n+# define HEADER_DH_H\n+\n+# include <openssl/e_os2.h>\n+\n+# ifdef OPENSSL_NO_DH\n+#  error DH is disabled.\n+# endif\n+\n+# ifndef OPENSSL_NO_BIO\n+#  include <openssl/bio.h>\n+# endif\n+# include <openssl/ossl_typ.h>\n+# ifndef OPENSSL_NO_DEPRECATED\n+#  include <openssl/bn.h>\n+# endif\n+\n+# ifndef OPENSSL_DH_MAX_MODULUS_BITS\n+#  define OPENSSL_DH_MAX_MODULUS_BITS    10000\n+# endif\n+\n+# define DH_FLAG_CACHE_MONT_P     0x01\n+\n+/*\n+ * new with 0.9.7h; the built-in DH\n+ * implementation now uses constant time\n+ * modular exponentiation for secret exponents\n+ * by default. This flag causes the\n+ * faster variable sliding window method to\n+ * be used for all exponents.\n+ */\n+# define DH_FLAG_NO_EXP_CONSTTIME 0x02\n+\n+/*\n+ * If this flag is set the DH method is FIPS compliant and can be used in\n+ * FIPS mode. This is set in the validated module method. If an application\n+ * sets this flag in its own methods it is its reposibility to ensure the\n+ * result is compliant.\n+ */\n+\n+# define DH_FLAG_FIPS_METHOD                     0x0400\n+\n+/*\n+ * If this flag is set the operations normally disabled in FIPS mode are\n+ * permitted it is then the applications responsibility to ensure that the\n+ * usage is compliant.\n+ */\n+\n+# define DH_FLAG_NON_FIPS_ALLOW                  0x0400\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Already defined in ossl_typ.h */\n+/* typedef struct dh_st DH; */\n+/* typedef struct dh_method DH_METHOD; */\n+\n+struct dh_method {\n+    const char *name;\n+    /* Methods here */\n+    int (*generate_key) (DH *dh);\n+    int (*compute_key) (unsigned char *key, const BIGNUM *pub_key, DH *dh);\n+    /* Can be null */\n+    int (*bn_mod_exp) (const DH *dh, BIGNUM *r, const BIGNUM *a,\n+                       const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\n+                       BN_MONT_CTX *m_ctx);\n+    int (*init) (DH *dh);\n+    int (*finish) (DH *dh);\n+    int flags;\n+    char *app_data;\n+    /* If this is non-NULL, it will be used to generate parameters */\n+    int (*generate_params) (DH *dh, int prime_len, int generator,\n+                            BN_GENCB *cb);\n+};\n+\n+struct dh_st {\n+    /*\n+     * This first argument is used to pick up errors when a DH is passed\n+     * instead of a EVP_PKEY\n+     */\n+    int pad;\n+    int version;\n+    BIGNUM *p;\n+    BIGNUM *g;\n+    long length;                /* optional */\n+    BIGNUM *pub_key;            /* g^x % p */\n+    BIGNUM *priv_key;           /* x */\n+    int flags;\n+    BN_MONT_CTX *method_mont_p;\n+    /* Place holders if we want to do X9.42 DH */\n+    BIGNUM *q;\n+    BIGNUM *j;\n+    unsigned char *seed;\n+    int seedlen;\n+    BIGNUM *counter;\n+    int references;\n+    CRYPTO_EX_DATA ex_data;\n+    const DH_METHOD *meth;\n+    ENGINE *engine;\n+};\n+\n+# define DH_GENERATOR_2          2\n+/* #define DH_GENERATOR_3       3 */\n+# define DH_GENERATOR_5          5\n+\n+/* DH_check error codes */\n+# define DH_CHECK_P_NOT_PRIME            0x01\n+# define DH_CHECK_P_NOT_SAFE_PRIME       0x02\n+# define DH_UNABLE_TO_CHECK_GENERATOR    0x04\n+# define DH_NOT_SUITABLE_GENERATOR       0x08\n+# define DH_CHECK_Q_NOT_PRIME            0x10\n+# define DH_CHECK_INVALID_Q_VALUE        0x20\n+# define DH_CHECK_INVALID_J_VALUE        0x40\n+\n+/* DH_check_pub_key error codes */\n+# define DH_CHECK_PUBKEY_TOO_SMALL       0x01\n+# define DH_CHECK_PUBKEY_TOO_LARGE       0x02\n+# define DH_CHECK_PUBKEY_INVALID         0x04\n+\n+/*\n+ * primes p where (p-1)/2 is prime too are called \"safe\"; we define this for\n+ * backward compatibility:\n+ */\n+# define DH_CHECK_P_NOT_STRONG_PRIME     DH_CHECK_P_NOT_SAFE_PRIME\n+\n+# define d2i_DHparams_fp(fp,x) \\\n+    (DH *)ASN1_d2i_fp((char *(*)())DH_new, \\\n+                      (char *(*)())d2i_DHparams, \\\n+                      (fp), \\\n+                      (unsigned char **)(x))\n+# define i2d_DHparams_fp(fp,x) \\\n+    ASN1_i2d_fp(i2d_DHparams,(fp), (unsigned char *)(x))\n+# define d2i_DHparams_bio(bp,x) \\\n+    ASN1_d2i_bio_of(DH, DH_new, d2i_DHparams, bp, x)\n+# define i2d_DHparams_bio(bp,x) \\\n+    ASN1_i2d_bio_of_const(DH,i2d_DHparams,bp,x)\n+\n+# define d2i_DHxparams_fp(fp,x) \\\n+    (DH *)ASN1_d2i_fp((char *(*)())DH_new, \\\n+                      (char *(*)())d2i_DHxparams, \\\n+                      (fp), \\\n+                      (unsigned char **)(x))\n+# define i2d_DHxparams_fp(fp,x) \\\n+    ASN1_i2d_fp(i2d_DHxparams,(fp), (unsigned char *)(x))\n+# define d2i_DHxparams_bio(bp,x) \\\n+    ASN1_d2i_bio_of(DH, DH_new, d2i_DHxparams, bp, x)\n+# define i2d_DHxparams_bio(bp,x) \\\n+    ASN1_i2d_bio_of_const(DH, i2d_DHxparams, bp, x)\n+\n+DH *DHparams_dup(DH *);\n+\n+const DH_METHOD *DH_OpenSSL(void);\n+\n+void DH_set_default_method(const DH_METHOD *meth);\n+const DH_METHOD *DH_get_default_method(void);\n+int DH_set_method(DH *dh, const DH_METHOD *meth);\n+DH *DH_new_method(ENGINE *engine);\n+\n+DH *DH_new(void);\n+void DH_free(DH *dh);\n+int DH_up_ref(DH *dh);\n+int DH_size(const DH *dh);\n+int DH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\n+                        CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);\n+int DH_set_ex_data(DH *d, int idx, void *arg);\n+void *DH_get_ex_data(DH *d, int idx);\n+\n+/* Deprecated version */\n+# ifndef OPENSSL_NO_DEPRECATED\n+DH *DH_generate_parameters(int prime_len, int generator,\n+                           void (*callback) (int, int, void *), void *cb_arg);\n+# endif                         /* !defined(OPENSSL_NO_DEPRECATED) */\n+\n+/* New version */\n+int DH_generate_parameters_ex(DH *dh, int prime_len, int generator,\n+                              BN_GENCB *cb);\n+\n+int DH_check(const DH *dh, int *codes);\n+int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *codes);\n+int DH_generate_key(DH *dh);\n+int DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh);\n+int DH_compute_key_padded(unsigned char *key, const BIGNUM *pub_key, DH *dh);\n+DH *d2i_DHparams(DH **a, const unsigned char **pp, long length);\n+int i2d_DHparams(const DH *a, unsigned char **pp);\n+DH *d2i_DHxparams(DH **a, const unsigned char **pp, long length);\n+int i2d_DHxparams(const DH *a, unsigned char **pp);\n+# ifndef OPENSSL_NO_FP_API\n+int DHparams_print_fp(FILE *fp, const DH *x);\n+# endif\n+# ifndef OPENSSL_NO_BIO\n+int DHparams_print(BIO *bp, const DH *x);\n+# else\n+int DHparams_print(char *bp, const DH *x);\n+# endif\n+\n+/* RFC 5114 parameters */\n+DH *DH_get_1024_160(void);\n+DH *DH_get_2048_224(void);\n+DH *DH_get_2048_256(void);\n+\n+# ifndef OPENSSL_NO_CMS\n+/* RFC2631 KDF */\n+int DH_KDF_X9_42(unsigned char *out, size_t outlen,\n+                 const unsigned char *Z, size_t Zlen,\n+                 ASN1_OBJECT *key_oid,\n+                 const unsigned char *ukm, size_t ukmlen, const EVP_MD *md);\n+# endif\n+\n+# define EVP_PKEY_CTX_set_dh_paramgen_prime_len(ctx, len) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DH, EVP_PKEY_OP_PARAMGEN, \\\n+                        EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN, len, NULL)\n+\n+# define EVP_PKEY_CTX_set_dh_paramgen_subprime_len(ctx, len) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DH, EVP_PKEY_OP_PARAMGEN, \\\n+                        EVP_PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN, len, NULL)\n+\n+# define EVP_PKEY_CTX_set_dh_paramgen_type(ctx, typ) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DH, EVP_PKEY_OP_PARAMGEN, \\\n+                        EVP_PKEY_CTRL_DH_PARAMGEN_TYPE, typ, NULL)\n+\n+# define EVP_PKEY_CTX_set_dh_paramgen_generator(ctx, gen) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DH, EVP_PKEY_OP_PARAMGEN, \\\n+                        EVP_PKEY_CTRL_DH_PARAMGEN_GENERATOR, gen, NULL)\n+\n+# define EVP_PKEY_CTX_set_dh_rfc5114(ctx, gen) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, EVP_PKEY_OP_PARAMGEN, \\\n+                        EVP_PKEY_CTRL_DH_RFC5114, gen, NULL)\n+\n+# define EVP_PKEY_CTX_set_dhx_rfc5114(ctx, gen) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, EVP_PKEY_OP_PARAMGEN, \\\n+                        EVP_PKEY_CTRL_DH_RFC5114, gen, NULL)\n+\n+# define EVP_PKEY_CTX_set_dh_kdf_type(ctx, kdf) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_DH_KDF_TYPE, kdf, NULL)\n+\n+# define EVP_PKEY_CTX_get_dh_kdf_type(ctx) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_DH_KDF_TYPE, -2, NULL)\n+\n+# define EVP_PKEY_CTX_set0_dh_kdf_oid(ctx, oid) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_DH_KDF_OID, 0, (void *)oid)\n+\n+# define EVP_PKEY_CTX_get0_dh_kdf_oid(ctx, poid) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_GET_DH_KDF_OID, 0, (void *)poid)\n+\n+# define EVP_PKEY_CTX_set_dh_kdf_md(ctx, md) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_DH_KDF_MD, 0, (void *)md)\n+\n+# define EVP_PKEY_CTX_get_dh_kdf_md(ctx, pmd) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_GET_DH_KDF_MD, 0, (void *)pmd)\n+\n+# define EVP_PKEY_CTX_set_dh_kdf_outlen(ctx, len) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_DH_KDF_OUTLEN, len, NULL)\n+\n+# define EVP_PKEY_CTX_get_dh_kdf_outlen(ctx, plen) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                        EVP_PKEY_CTRL_GET_DH_KDF_OUTLEN, 0, (void *)plen)\n+\n+# define EVP_PKEY_CTX_set0_dh_kdf_ukm(ctx, p, plen) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_DH_KDF_UKM, plen, (void *)p)\n+\n+# define EVP_PKEY_CTX_get0_dh_kdf_ukm(ctx, p) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DHX, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_GET_DH_KDF_UKM, 0, (void *)p)\n+\n+# define EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN     (EVP_PKEY_ALG_CTRL + 1)\n+# define EVP_PKEY_CTRL_DH_PARAMGEN_GENERATOR     (EVP_PKEY_ALG_CTRL + 2)\n+# define EVP_PKEY_CTRL_DH_RFC5114                (EVP_PKEY_ALG_CTRL + 3)\n+# define EVP_PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN  (EVP_PKEY_ALG_CTRL + 4)\n+# define EVP_PKEY_CTRL_DH_PARAMGEN_TYPE          (EVP_PKEY_ALG_CTRL + 5)\n+# define EVP_PKEY_CTRL_DH_KDF_TYPE               (EVP_PKEY_ALG_CTRL + 6)\n+# define EVP_PKEY_CTRL_DH_KDF_MD                 (EVP_PKEY_ALG_CTRL + 7)\n+# define EVP_PKEY_CTRL_GET_DH_KDF_MD             (EVP_PKEY_ALG_CTRL + 8)\n+# define EVP_PKEY_CTRL_DH_KDF_OUTLEN             (EVP_PKEY_ALG_CTRL + 9)\n+# define EVP_PKEY_CTRL_GET_DH_KDF_OUTLEN         (EVP_PKEY_ALG_CTRL + 10)\n+# define EVP_PKEY_CTRL_DH_KDF_UKM                (EVP_PKEY_ALG_CTRL + 11)\n+# define EVP_PKEY_CTRL_GET_DH_KDF_UKM            (EVP_PKEY_ALG_CTRL + 12)\n+# define EVP_PKEY_CTRL_DH_KDF_OID                (EVP_PKEY_ALG_CTRL + 13)\n+# define EVP_PKEY_CTRL_GET_DH_KDF_OID            (EVP_PKEY_ALG_CTRL + 14)\n+\n+/* KDF types */\n+# define EVP_PKEY_DH_KDF_NONE                            1\n+# define EVP_PKEY_DH_KDF_X9_42                           2\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_DH_strings(void);\n+\n+/* Error codes for the DH functions. */\n+\n+/* Function codes. */\n+# define DH_F_COMPUTE_KEY                                 102\n+# define DH_F_DHPARAMS_PRINT_FP                           101\n+# define DH_F_DH_BUILTIN_GENPARAMS                        106\n+# define DH_F_DH_CMS_DECRYPT                              117\n+# define DH_F_DH_CMS_SET_PEERKEY                          118\n+# define DH_F_DH_CMS_SET_SHARED_INFO                      119\n+# define DH_F_DH_COMPUTE_KEY                              114\n+# define DH_F_DH_GENERATE_KEY                             115\n+# define DH_F_DH_GENERATE_PARAMETERS_EX                   116\n+# define DH_F_DH_NEW_METHOD                               105\n+# define DH_F_DH_PARAM_DECODE                             107\n+# define DH_F_DH_PRIV_DECODE                              110\n+# define DH_F_DH_PRIV_ENCODE                              111\n+# define DH_F_DH_PUB_DECODE                               108\n+# define DH_F_DH_PUB_ENCODE                               109\n+# define DH_F_DO_DH_PRINT                                 100\n+# define DH_F_GENERATE_KEY                                103\n+# define DH_F_GENERATE_PARAMETERS                         104\n+# define DH_F_PKEY_DH_DERIVE                              112\n+# define DH_F_PKEY_DH_KEYGEN                              113\n+\n+/* Reason codes. */\n+# define DH_R_BAD_GENERATOR                               101\n+# define DH_R_BN_DECODE_ERROR                             109\n+# define DH_R_BN_ERROR                                    106\n+# define DH_R_DECODE_ERROR                                104\n+# define DH_R_INVALID_PUBKEY                              102\n+# define DH_R_KDF_PARAMETER_ERROR                         112\n+# define DH_R_KEYS_NOT_SET                                108\n+# define DH_R_KEY_SIZE_TOO_SMALL                          110\n+# define DH_R_MODULUS_TOO_LARGE                           103\n+# define DH_R_NON_FIPS_METHOD                             111\n+# define DH_R_NO_PARAMETERS_SET                           107\n+# define DH_R_NO_PRIVATE_VALUE                            100\n+# define DH_R_PARAMETER_ENCODING_ERROR                    105\n+# define DH_R_PEER_KEY_ERROR                              113\n+# define DH_R_SHARED_INFO_ERROR                           114\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "545358fd02b2addd3b418d065917157ed3a5783d",
            "filename": "deps/openssl/openssl/include/openssl/dsa.h",
            "status": "added",
            "additions": 332,
            "deletions": 0,
            "changes": 332,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdsa.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdsa.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdsa.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,332 @@\n+/* crypto/dsa/dsa.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+/*\n+ * The DSS routines are based on patches supplied by\n+ * Steven Schoch <schoch@sheba.arc.nasa.gov>.  He basically did the\n+ * work and I have just tweaked them a little to fit into my\n+ * stylistic vision for SSLeay :-) */\n+\n+#ifndef HEADER_DSA_H\n+# define HEADER_DSA_H\n+\n+# include <openssl/e_os2.h>\n+\n+# ifdef OPENSSL_NO_DSA\n+#  error DSA is disabled.\n+# endif\n+\n+# ifndef OPENSSL_NO_BIO\n+#  include <openssl/bio.h>\n+# endif\n+# include <openssl/crypto.h>\n+# include <openssl/ossl_typ.h>\n+\n+# ifndef OPENSSL_NO_DEPRECATED\n+#  include <openssl/bn.h>\n+#  ifndef OPENSSL_NO_DH\n+#   include <openssl/dh.h>\n+#  endif\n+# endif\n+\n+# ifndef OPENSSL_DSA_MAX_MODULUS_BITS\n+#  define OPENSSL_DSA_MAX_MODULUS_BITS   10000\n+# endif\n+\n+# define DSA_FLAG_CACHE_MONT_P   0x01\n+/*\n+ * new with 0.9.7h; the built-in DSA implementation now uses constant time\n+ * modular exponentiation for secret exponents by default. This flag causes\n+ * the faster variable sliding window method to be used for all exponents.\n+ */\n+# define DSA_FLAG_NO_EXP_CONSTTIME       0x02\n+\n+/*\n+ * If this flag is set the DSA method is FIPS compliant and can be used in\n+ * FIPS mode. This is set in the validated module method. If an application\n+ * sets this flag in its own methods it is its reposibility to ensure the\n+ * result is compliant.\n+ */\n+\n+# define DSA_FLAG_FIPS_METHOD                    0x0400\n+\n+/*\n+ * If this flag is set the operations normally disabled in FIPS mode are\n+ * permitted it is then the applications responsibility to ensure that the\n+ * usage is compliant.\n+ */\n+\n+# define DSA_FLAG_NON_FIPS_ALLOW                 0x0400\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Already defined in ossl_typ.h */\n+/* typedef struct dsa_st DSA; */\n+/* typedef struct dsa_method DSA_METHOD; */\n+\n+typedef struct DSA_SIG_st {\n+    BIGNUM *r;\n+    BIGNUM *s;\n+} DSA_SIG;\n+\n+struct dsa_method {\n+    const char *name;\n+    DSA_SIG *(*dsa_do_sign) (const unsigned char *dgst, int dlen, DSA *dsa);\n+    int (*dsa_sign_setup) (DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,\n+                           BIGNUM **rp);\n+    int (*dsa_do_verify) (const unsigned char *dgst, int dgst_len,\n+                          DSA_SIG *sig, DSA *dsa);\n+    int (*dsa_mod_exp) (DSA *dsa, BIGNUM *rr, BIGNUM *a1, BIGNUM *p1,\n+                        BIGNUM *a2, BIGNUM *p2, BIGNUM *m, BN_CTX *ctx,\n+                        BN_MONT_CTX *in_mont);\n+    /* Can be null */\n+    int (*bn_mod_exp) (DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,\n+                       const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);\n+    int (*init) (DSA *dsa);\n+    int (*finish) (DSA *dsa);\n+    int flags;\n+    char *app_data;\n+    /* If this is non-NULL, it is used to generate DSA parameters */\n+    int (*dsa_paramgen) (DSA *dsa, int bits,\n+                         const unsigned char *seed, int seed_len,\n+                         int *counter_ret, unsigned long *h_ret,\n+                         BN_GENCB *cb);\n+    /* If this is non-NULL, it is used to generate DSA keys */\n+    int (*dsa_keygen) (DSA *dsa);\n+};\n+\n+struct dsa_st {\n+    /*\n+     * This first variable is used to pick up errors where a DSA is passed\n+     * instead of of a EVP_PKEY\n+     */\n+    int pad;\n+    long version;\n+    int write_params;\n+    BIGNUM *p;\n+    BIGNUM *q;                  /* == 20 */\n+    BIGNUM *g;\n+    BIGNUM *pub_key;            /* y public key */\n+    BIGNUM *priv_key;           /* x private key */\n+    BIGNUM *kinv;               /* Signing pre-calc */\n+    BIGNUM *r;                  /* Signing pre-calc */\n+    int flags;\n+    /* Normally used to cache montgomery values */\n+    BN_MONT_CTX *method_mont_p;\n+    int references;\n+    CRYPTO_EX_DATA ex_data;\n+    const DSA_METHOD *meth;\n+    /* functional reference if 'meth' is ENGINE-provided */\n+    ENGINE *engine;\n+};\n+\n+# define d2i_DSAparams_fp(fp,x) (DSA *)ASN1_d2i_fp((char *(*)())DSA_new, \\\n+                (char *(*)())d2i_DSAparams,(fp),(unsigned char **)(x))\n+# define i2d_DSAparams_fp(fp,x) ASN1_i2d_fp(i2d_DSAparams,(fp), \\\n+                (unsigned char *)(x))\n+# define d2i_DSAparams_bio(bp,x) ASN1_d2i_bio_of(DSA,DSA_new,d2i_DSAparams,bp,x)\n+# define i2d_DSAparams_bio(bp,x) ASN1_i2d_bio_of_const(DSA,i2d_DSAparams,bp,x)\n+\n+DSA *DSAparams_dup(DSA *x);\n+DSA_SIG *DSA_SIG_new(void);\n+void DSA_SIG_free(DSA_SIG *a);\n+int i2d_DSA_SIG(const DSA_SIG *a, unsigned char **pp);\n+DSA_SIG *d2i_DSA_SIG(DSA_SIG **v, const unsigned char **pp, long length);\n+\n+DSA_SIG *DSA_do_sign(const unsigned char *dgst, int dlen, DSA *dsa);\n+int DSA_do_verify(const unsigned char *dgst, int dgst_len,\n+                  DSA_SIG *sig, DSA *dsa);\n+\n+const DSA_METHOD *DSA_OpenSSL(void);\n+\n+void DSA_set_default_method(const DSA_METHOD *);\n+const DSA_METHOD *DSA_get_default_method(void);\n+int DSA_set_method(DSA *dsa, const DSA_METHOD *);\n+\n+DSA *DSA_new(void);\n+DSA *DSA_new_method(ENGINE *engine);\n+void DSA_free(DSA *r);\n+/* \"up\" the DSA object's reference count */\n+int DSA_up_ref(DSA *r);\n+int DSA_size(const DSA *);\n+        /* next 4 return -1 on error */\n+int DSA_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp);\n+int DSA_sign(int type, const unsigned char *dgst, int dlen,\n+             unsigned char *sig, unsigned int *siglen, DSA *dsa);\n+int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n+               const unsigned char *sigbuf, int siglen, DSA *dsa);\n+int DSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\n+                         CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);\n+int DSA_set_ex_data(DSA *d, int idx, void *arg);\n+void *DSA_get_ex_data(DSA *d, int idx);\n+\n+DSA *d2i_DSAPublicKey(DSA **a, const unsigned char **pp, long length);\n+DSA *d2i_DSAPrivateKey(DSA **a, const unsigned char **pp, long length);\n+DSA *d2i_DSAparams(DSA **a, const unsigned char **pp, long length);\n+\n+/* Deprecated version */\n+# ifndef OPENSSL_NO_DEPRECATED\n+DSA *DSA_generate_parameters(int bits,\n+                             unsigned char *seed, int seed_len,\n+                             int *counter_ret, unsigned long *h_ret, void\n+                              (*callback) (int, int, void *), void *cb_arg);\n+# endif                         /* !defined(OPENSSL_NO_DEPRECATED) */\n+\n+/* New version */\n+int DSA_generate_parameters_ex(DSA *dsa, int bits,\n+                               const unsigned char *seed, int seed_len,\n+                               int *counter_ret, unsigned long *h_ret,\n+                               BN_GENCB *cb);\n+\n+int DSA_generate_key(DSA *a);\n+int i2d_DSAPublicKey(const DSA *a, unsigned char **pp);\n+int i2d_DSAPrivateKey(const DSA *a, unsigned char **pp);\n+int i2d_DSAparams(const DSA *a, unsigned char **pp);\n+\n+# ifndef OPENSSL_NO_BIO\n+int DSAparams_print(BIO *bp, const DSA *x);\n+int DSA_print(BIO *bp, const DSA *x, int off);\n+# endif\n+# ifndef OPENSSL_NO_FP_API\n+int DSAparams_print_fp(FILE *fp, const DSA *x);\n+int DSA_print_fp(FILE *bp, const DSA *x, int off);\n+# endif\n+\n+# define DSS_prime_checks 50\n+/*\n+ * Primality test according to FIPS PUB 186[-1], Appendix 2.1: 50 rounds of\n+ * Rabin-Miller\n+ */\n+# define DSA_is_prime(n, callback, cb_arg) \\\n+        BN_is_prime(n, DSS_prime_checks, callback, NULL, cb_arg)\n+\n+# ifndef OPENSSL_NO_DH\n+/*\n+ * Convert DSA structure (key or just parameters) into DH structure (be\n+ * careful to avoid small subgroup attacks when using this!)\n+ */\n+DH *DSA_dup_DH(const DSA *r);\n+# endif\n+\n+# define EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx, nbits) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DSA, EVP_PKEY_OP_PARAMGEN, \\\n+                                EVP_PKEY_CTRL_DSA_PARAMGEN_BITS, nbits, NULL)\n+\n+# define EVP_PKEY_CTRL_DSA_PARAMGEN_BITS         (EVP_PKEY_ALG_CTRL + 1)\n+# define EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS       (EVP_PKEY_ALG_CTRL + 2)\n+# define EVP_PKEY_CTRL_DSA_PARAMGEN_MD           (EVP_PKEY_ALG_CTRL + 3)\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_DSA_strings(void);\n+\n+/* Error codes for the DSA functions. */\n+\n+/* Function codes. */\n+# define DSA_F_D2I_DSA_SIG                                110\n+# define DSA_F_DO_DSA_PRINT                               104\n+# define DSA_F_DSAPARAMS_PRINT                            100\n+# define DSA_F_DSAPARAMS_PRINT_FP                         101\n+# define DSA_F_DSA_BUILTIN_PARAMGEN2                      126\n+# define DSA_F_DSA_DO_SIGN                                112\n+# define DSA_F_DSA_DO_VERIFY                              113\n+# define DSA_F_DSA_GENERATE_KEY                           124\n+# define DSA_F_DSA_GENERATE_PARAMETERS_EX                 123\n+# define DSA_F_DSA_NEW_METHOD                             103\n+# define DSA_F_DSA_PARAM_DECODE                           119\n+# define DSA_F_DSA_PRINT_FP                               105\n+# define DSA_F_DSA_PRIV_DECODE                            115\n+# define DSA_F_DSA_PRIV_ENCODE                            116\n+# define DSA_F_DSA_PUB_DECODE                             117\n+# define DSA_F_DSA_PUB_ENCODE                             118\n+# define DSA_F_DSA_SIGN                                   106\n+# define DSA_F_DSA_SIGN_SETUP                             107\n+# define DSA_F_DSA_SIG_NEW                                109\n+# define DSA_F_DSA_SIG_PRINT                              125\n+# define DSA_F_DSA_VERIFY                                 108\n+# define DSA_F_I2D_DSA_SIG                                111\n+# define DSA_F_OLD_DSA_PRIV_DECODE                        122\n+# define DSA_F_PKEY_DSA_CTRL                              120\n+# define DSA_F_PKEY_DSA_KEYGEN                            121\n+# define DSA_F_SIG_CB                                     114\n+\n+/* Reason codes. */\n+# define DSA_R_BAD_Q_VALUE                                102\n+# define DSA_R_BN_DECODE_ERROR                            108\n+# define DSA_R_BN_ERROR                                   109\n+# define DSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE                100\n+# define DSA_R_DECODE_ERROR                               104\n+# define DSA_R_INVALID_DIGEST_TYPE                        106\n+# define DSA_R_INVALID_PARAMETERS                         112\n+# define DSA_R_MISSING_PARAMETERS                         101\n+# define DSA_R_MODULUS_TOO_LARGE                          103\n+# define DSA_R_NEED_NEW_SETUP_VALUES                      110\n+# define DSA_R_NON_FIPS_DSA_METHOD                        111\n+# define DSA_R_NO_PARAMETERS_SET                          107\n+# define DSA_R_PARAMETER_ENCODING_ERROR                   105\n+# define DSA_R_Q_NOT_PRIME                                113\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "c9013f5cea8b252a87a47079bccfa39399c42c98",
            "filename": "deps/openssl/openssl/include/openssl/dso.h",
            "status": "added",
            "additions": 451,
            "deletions": 0,
            "changes": 451,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdso.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdso.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdso.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,451 @@\n+/* dso.h */\n+/*\n+ * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project\n+ * 2000.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#ifndef HEADER_DSO_H\n+# define HEADER_DSO_H\n+\n+# include <openssl/crypto.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* These values are used as commands to DSO_ctrl() */\n+# define DSO_CTRL_GET_FLAGS      1\n+# define DSO_CTRL_SET_FLAGS      2\n+# define DSO_CTRL_OR_FLAGS       3\n+\n+/*\n+ * By default, DSO_load() will translate the provided filename into a form\n+ * typical for the platform (more specifically the DSO_METHOD) using the\n+ * dso_name_converter function of the method. Eg. win32 will transform \"blah\"\n+ * into \"blah.dll\", and dlfcn will transform it into \"libblah.so\". The\n+ * behaviour can be overriden by setting the name_converter callback in the\n+ * DSO object (using DSO_set_name_converter()). This callback could even\n+ * utilise the DSO_METHOD's converter too if it only wants to override\n+ * behaviour for one or two possible DSO methods. However, the following flag\n+ * can be set in a DSO to prevent *any* native name-translation at all - eg.\n+ * if the caller has prompted the user for a path to a driver library so the\n+ * filename should be interpreted as-is.\n+ */\n+# define DSO_FLAG_NO_NAME_TRANSLATION            0x01\n+/*\n+ * An extra flag to give if only the extension should be added as\n+ * translation.  This is obviously only of importance on Unix and other\n+ * operating systems where the translation also may prefix the name with\n+ * something, like 'lib', and ignored everywhere else. This flag is also\n+ * ignored if DSO_FLAG_NO_NAME_TRANSLATION is used at the same time.\n+ */\n+# define DSO_FLAG_NAME_TRANSLATION_EXT_ONLY      0x02\n+\n+/*\n+ * The following flag controls the translation of symbol names to upper case.\n+ * This is currently only being implemented for OpenVMS.\n+ */\n+# define DSO_FLAG_UPCASE_SYMBOL                  0x10\n+\n+/*\n+ * This flag loads the library with public symbols. Meaning: The exported\n+ * symbols of this library are public to all libraries loaded after this\n+ * library. At the moment only implemented in unix.\n+ */\n+# define DSO_FLAG_GLOBAL_SYMBOLS                 0x20\n+\n+typedef void (*DSO_FUNC_TYPE) (void);\n+\n+typedef struct dso_st DSO;\n+\n+/*\n+ * The function prototype used for method functions (or caller-provided\n+ * callbacks) that transform filenames. They are passed a DSO structure\n+ * pointer (or NULL if they are to be used independantly of a DSO object) and\n+ * a filename to transform. They should either return NULL (if there is an\n+ * error condition) or a newly allocated string containing the transformed\n+ * form that the caller will need to free with OPENSSL_free() when done.\n+ */\n+typedef char *(*DSO_NAME_CONVERTER_FUNC)(DSO *, const char *);\n+/*\n+ * The function prototype used for method functions (or caller-provided\n+ * callbacks) that merge two file specifications. They are passed a DSO\n+ * structure pointer (or NULL if they are to be used independantly of a DSO\n+ * object) and two file specifications to merge. They should either return\n+ * NULL (if there is an error condition) or a newly allocated string\n+ * containing the result of merging that the caller will need to free with\n+ * OPENSSL_free() when done. Here, merging means that bits and pieces are\n+ * taken from each of the file specifications and added together in whatever\n+ * fashion that is sensible for the DSO method in question.  The only rule\n+ * that really applies is that if the two specification contain pieces of the\n+ * same type, the copy from the first string takes priority.  One could see\n+ * it as the first specification is the one given by the user and the second\n+ * being a bunch of defaults to add on if they're missing in the first.\n+ */\n+typedef char *(*DSO_MERGER_FUNC)(DSO *, const char *, const char *);\n+\n+typedef struct dso_meth_st {\n+    const char *name;\n+    /*\n+     * Loads a shared library, NB: new DSO_METHODs must ensure that a\n+     * successful load populates the loaded_filename field, and likewise a\n+     * successful unload OPENSSL_frees and NULLs it out.\n+     */\n+    int (*dso_load) (DSO *dso);\n+    /* Unloads a shared library */\n+    int (*dso_unload) (DSO *dso);\n+    /* Binds a variable */\n+    void *(*dso_bind_var) (DSO *dso, const char *symname);\n+    /*\n+     * Binds a function - assumes a return type of DSO_FUNC_TYPE. This should\n+     * be cast to the real function prototype by the caller. Platforms that\n+     * don't have compatible representations for different prototypes (this\n+     * is possible within ANSI C) are highly unlikely to have shared\n+     * libraries at all, let alone a DSO_METHOD implemented for them.\n+     */\n+    DSO_FUNC_TYPE (*dso_bind_func) (DSO *dso, const char *symname);\n+/* I don't think this would actually be used in any circumstances. */\n+# if 0\n+    /* Unbinds a variable */\n+    int (*dso_unbind_var) (DSO *dso, char *symname, void *symptr);\n+    /* Unbinds a function */\n+    int (*dso_unbind_func) (DSO *dso, char *symname, DSO_FUNC_TYPE symptr);\n+# endif\n+    /*\n+     * The generic (yuck) \"ctrl()\" function. NB: Negative return values\n+     * (rather than zero) indicate errors.\n+     */\n+    long (*dso_ctrl) (DSO *dso, int cmd, long larg, void *parg);\n+    /*\n+     * The default DSO_METHOD-specific function for converting filenames to a\n+     * canonical native form.\n+     */\n+    DSO_NAME_CONVERTER_FUNC dso_name_converter;\n+    /*\n+     * The default DSO_METHOD-specific function for converting filenames to a\n+     * canonical native form.\n+     */\n+    DSO_MERGER_FUNC dso_merger;\n+    /* [De]Initialisation handlers. */\n+    int (*init) (DSO *dso);\n+    int (*finish) (DSO *dso);\n+    /* Return pathname of the module containing location */\n+    int (*pathbyaddr) (void *addr, char *path, int sz);\n+    /* Perform global symbol lookup, i.e. among *all* modules */\n+    void *(*globallookup) (const char *symname);\n+} DSO_METHOD;\n+\n+/**********************************************************************/\n+/* The low-level handle type used to refer to a loaded shared library */\n+\n+struct dso_st {\n+    DSO_METHOD *meth;\n+    /*\n+     * Standard dlopen uses a (void *). Win32 uses a HANDLE. VMS doesn't use\n+     * anything but will need to cache the filename for use in the dso_bind\n+     * handler. All in all, let each method control its own destiny.\n+     * \"Handles\" and such go in a STACK.\n+     */\n+    STACK_OF(void) *meth_data;\n+    int references;\n+    int flags;\n+    /*\n+     * For use by applications etc ... use this for your bits'n'pieces, don't\n+     * touch meth_data!\n+     */\n+    CRYPTO_EX_DATA ex_data;\n+    /*\n+     * If this callback function pointer is set to non-NULL, then it will be\n+     * used in DSO_load() in place of meth->dso_name_converter. NB: This\n+     * should normally set using DSO_set_name_converter().\n+     */\n+    DSO_NAME_CONVERTER_FUNC name_converter;\n+    /*\n+     * If this callback function pointer is set to non-NULL, then it will be\n+     * used in DSO_load() in place of meth->dso_merger. NB: This should\n+     * normally set using DSO_set_merger().\n+     */\n+    DSO_MERGER_FUNC merger;\n+    /*\n+     * This is populated with (a copy of) the platform-independant filename\n+     * used for this DSO.\n+     */\n+    char *filename;\n+    /*\n+     * This is populated with (a copy of) the translated filename by which\n+     * the DSO was actually loaded. It is NULL iff the DSO is not currently\n+     * loaded. NB: This is here because the filename translation process may\n+     * involve a callback being invoked more than once not only to convert to\n+     * a platform-specific form, but also to try different filenames in the\n+     * process of trying to perform a load. As such, this variable can be\n+     * used to indicate (a) whether this DSO structure corresponds to a\n+     * loaded library or not, and (b) the filename with which it was actually\n+     * loaded.\n+     */\n+    char *loaded_filename;\n+};\n+\n+DSO *DSO_new(void);\n+DSO *DSO_new_method(DSO_METHOD *method);\n+int DSO_free(DSO *dso);\n+int DSO_flags(DSO *dso);\n+int DSO_up_ref(DSO *dso);\n+long DSO_ctrl(DSO *dso, int cmd, long larg, void *parg);\n+\n+/*\n+ * This function sets the DSO's name_converter callback. If it is non-NULL,\n+ * then it will be used instead of the associated DSO_METHOD's function. If\n+ * oldcb is non-NULL then it is set to the function pointer value being\n+ * replaced. Return value is non-zero for success.\n+ */\n+int DSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb,\n+                           DSO_NAME_CONVERTER_FUNC *oldcb);\n+/*\n+ * These functions can be used to get/set the platform-independant filename\n+ * used for a DSO. NB: set will fail if the DSO is already loaded.\n+ */\n+const char *DSO_get_filename(DSO *dso);\n+int DSO_set_filename(DSO *dso, const char *filename);\n+/*\n+ * This function will invoke the DSO's name_converter callback to translate a\n+ * filename, or if the callback isn't set it will instead use the DSO_METHOD's\n+ * converter. If \"filename\" is NULL, the \"filename\" in the DSO itself will be\n+ * used. If the DSO_FLAG_NO_NAME_TRANSLATION flag is set, then the filename is\n+ * simply duplicated. NB: This function is usually called from within a\n+ * DSO_METHOD during the processing of a DSO_load() call, and is exposed so\n+ * that caller-created DSO_METHODs can do the same thing. A non-NULL return\n+ * value will need to be OPENSSL_free()'d.\n+ */\n+char *DSO_convert_filename(DSO *dso, const char *filename);\n+/*\n+ * This function will invoke the DSO's merger callback to merge two file\n+ * specifications, or if the callback isn't set it will instead use the\n+ * DSO_METHOD's merger.  A non-NULL return value will need to be\n+ * OPENSSL_free()'d.\n+ */\n+char *DSO_merge(DSO *dso, const char *filespec1, const char *filespec2);\n+/*\n+ * If the DSO is currently loaded, this returns the filename that it was\n+ * loaded under, otherwise it returns NULL. So it is also useful as a test as\n+ * to whether the DSO is currently loaded. NB: This will not necessarily\n+ * return the same value as DSO_convert_filename(dso, dso->filename), because\n+ * the DSO_METHOD's load function may have tried a variety of filenames (with\n+ * and/or without the aid of the converters) before settling on the one it\n+ * actually loaded.\n+ */\n+const char *DSO_get_loaded_filename(DSO *dso);\n+\n+void DSO_set_default_method(DSO_METHOD *meth);\n+DSO_METHOD *DSO_get_default_method(void);\n+DSO_METHOD *DSO_get_method(DSO *dso);\n+DSO_METHOD *DSO_set_method(DSO *dso, DSO_METHOD *meth);\n+\n+/*\n+ * The all-singing all-dancing load function, you normally pass NULL for the\n+ * first and third parameters. Use DSO_up and DSO_free for subsequent\n+ * reference count handling. Any flags passed in will be set in the\n+ * constructed DSO after its init() function but before the load operation.\n+ * If 'dso' is non-NULL, 'flags' is ignored.\n+ */\n+DSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags);\n+\n+/* This function binds to a variable inside a shared library. */\n+void *DSO_bind_var(DSO *dso, const char *symname);\n+\n+/* This function binds to a function inside a shared library. */\n+DSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname);\n+\n+/*\n+ * This method is the default, but will beg, borrow, or steal whatever method\n+ * should be the default on any particular platform (including\n+ * DSO_METH_null() if necessary).\n+ */\n+DSO_METHOD *DSO_METHOD_openssl(void);\n+\n+/*\n+ * This method is defined for all platforms - if a platform has no DSO\n+ * support then this will be the only method!\n+ */\n+DSO_METHOD *DSO_METHOD_null(void);\n+\n+/*\n+ * If DSO_DLFCN is defined, the standard dlfcn.h-style functions (dlopen,\n+ * dlclose, dlsym, etc) will be used and incorporated into this method. If\n+ * not, this method will return NULL.\n+ */\n+DSO_METHOD *DSO_METHOD_dlfcn(void);\n+\n+/*\n+ * If DSO_DL is defined, the standard dl.h-style functions (shl_load,\n+ * shl_unload, shl_findsym, etc) will be used and incorporated into this\n+ * method. If not, this method will return NULL.\n+ */\n+DSO_METHOD *DSO_METHOD_dl(void);\n+\n+/* If WIN32 is defined, use DLLs. If not, return NULL. */\n+DSO_METHOD *DSO_METHOD_win32(void);\n+\n+/* If VMS is defined, use shared images. If not, return NULL. */\n+DSO_METHOD *DSO_METHOD_vms(void);\n+\n+/*\n+ * This function writes null-terminated pathname of DSO module containing\n+ * 'addr' into 'sz' large caller-provided 'path' and returns the number of\n+ * characters [including trailing zero] written to it. If 'sz' is 0 or\n+ * negative, 'path' is ignored and required amount of charachers [including\n+ * trailing zero] to accomodate pathname is returned. If 'addr' is NULL, then\n+ * pathname of cryptolib itself is returned. Negative or zero return value\n+ * denotes error.\n+ */\n+int DSO_pathbyaddr(void *addr, char *path, int sz);\n+\n+/*\n+ * This function should be used with caution! It looks up symbols in *all*\n+ * loaded modules and if module gets unloaded by somebody else attempt to\n+ * dereference the pointer is doomed to have fatal consequences. Primary\n+ * usage for this function is to probe *core* system functionality, e.g.\n+ * check if getnameinfo(3) is available at run-time without bothering about\n+ * OS-specific details such as libc.so.versioning or where does it actually\n+ * reside: in libc itself or libsocket.\n+ */\n+void *DSO_global_lookup(const char *name);\n+\n+/* If BeOS is defined, use shared images. If not, return NULL. */\n+DSO_METHOD *DSO_METHOD_beos(void);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_DSO_strings(void);\n+\n+/* Error codes for the DSO functions. */\n+\n+/* Function codes. */\n+# define DSO_F_BEOS_BIND_FUNC                             144\n+# define DSO_F_BEOS_BIND_VAR                              145\n+# define DSO_F_BEOS_LOAD                                  146\n+# define DSO_F_BEOS_NAME_CONVERTER                        147\n+# define DSO_F_BEOS_UNLOAD                                148\n+# define DSO_F_DLFCN_BIND_FUNC                            100\n+# define DSO_F_DLFCN_BIND_VAR                             101\n+# define DSO_F_DLFCN_LOAD                                 102\n+# define DSO_F_DLFCN_MERGER                               130\n+# define DSO_F_DLFCN_NAME_CONVERTER                       123\n+# define DSO_F_DLFCN_UNLOAD                               103\n+# define DSO_F_DL_BIND_FUNC                               104\n+# define DSO_F_DL_BIND_VAR                                105\n+# define DSO_F_DL_LOAD                                    106\n+# define DSO_F_DL_MERGER                                  131\n+# define DSO_F_DL_NAME_CONVERTER                          124\n+# define DSO_F_DL_UNLOAD                                  107\n+# define DSO_F_DSO_BIND_FUNC                              108\n+# define DSO_F_DSO_BIND_VAR                               109\n+# define DSO_F_DSO_CONVERT_FILENAME                       126\n+# define DSO_F_DSO_CTRL                                   110\n+# define DSO_F_DSO_FREE                                   111\n+# define DSO_F_DSO_GET_FILENAME                           127\n+# define DSO_F_DSO_GET_LOADED_FILENAME                    128\n+# define DSO_F_DSO_GLOBAL_LOOKUP                          139\n+# define DSO_F_DSO_LOAD                                   112\n+# define DSO_F_DSO_MERGE                                  132\n+# define DSO_F_DSO_NEW_METHOD                             113\n+# define DSO_F_DSO_PATHBYADDR                             140\n+# define DSO_F_DSO_SET_FILENAME                           129\n+# define DSO_F_DSO_SET_NAME_CONVERTER                     122\n+# define DSO_F_DSO_UP_REF                                 114\n+# define DSO_F_GLOBAL_LOOKUP_FUNC                         138\n+# define DSO_F_PATHBYADDR                                 137\n+# define DSO_F_VMS_BIND_SYM                               115\n+# define DSO_F_VMS_LOAD                                   116\n+# define DSO_F_VMS_MERGER                                 133\n+# define DSO_F_VMS_UNLOAD                                 117\n+# define DSO_F_WIN32_BIND_FUNC                            118\n+# define DSO_F_WIN32_BIND_VAR                             119\n+# define DSO_F_WIN32_GLOBALLOOKUP                         142\n+# define DSO_F_WIN32_GLOBALLOOKUP_FUNC                    143\n+# define DSO_F_WIN32_JOINER                               135\n+# define DSO_F_WIN32_LOAD                                 120\n+# define DSO_F_WIN32_MERGER                               134\n+# define DSO_F_WIN32_NAME_CONVERTER                       125\n+# define DSO_F_WIN32_PATHBYADDR                           141\n+# define DSO_F_WIN32_SPLITTER                             136\n+# define DSO_F_WIN32_UNLOAD                               121\n+\n+/* Reason codes. */\n+# define DSO_R_CTRL_FAILED                                100\n+# define DSO_R_DSO_ALREADY_LOADED                         110\n+# define DSO_R_EMPTY_FILE_STRUCTURE                       113\n+# define DSO_R_FAILURE                                    114\n+# define DSO_R_FILENAME_TOO_BIG                           101\n+# define DSO_R_FINISH_FAILED                              102\n+# define DSO_R_INCORRECT_FILE_SYNTAX                      115\n+# define DSO_R_LOAD_FAILED                                103\n+# define DSO_R_NAME_TRANSLATION_FAILED                    109\n+# define DSO_R_NO_FILENAME                                111\n+# define DSO_R_NO_FILE_SPECIFICATION                      116\n+# define DSO_R_NULL_HANDLE                                104\n+# define DSO_R_SET_FILENAME_FAILED                        112\n+# define DSO_R_STACK_ERROR                                105\n+# define DSO_R_SYM_FAILURE                                106\n+# define DSO_R_UNLOAD_FAILED                              107\n+# define DSO_R_UNSUPPORTED                                108\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "30bbcf278a4361a76ddf1c25119d10f5697a401b",
            "filename": "deps/openssl/openssl/include/openssl/dtls1.h",
            "status": "added",
            "additions": 272,
            "deletions": 0,
            "changes": 272,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdtls1.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdtls1.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fdtls1.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,272 @@\n+/* ssl/dtls1.h */\n+/*\n+ * DTLS implementation written by Nagendra Modadugu\n+ * (nagendra@cs.stanford.edu) for the OpenSSL project 2005.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#ifndef HEADER_DTLS1_H\n+# define HEADER_DTLS1_H\n+\n+# include <openssl/buffer.h>\n+# include <openssl/pqueue.h>\n+# ifdef OPENSSL_SYS_VMS\n+#  include <resource.h>\n+#  include <sys/timeb.h>\n+# endif\n+# ifdef OPENSSL_SYS_WIN32\n+/* Needed for struct timeval */\n+#  include <winsock.h>\n+# elif defined(OPENSSL_SYS_NETWARE) && !defined(_WINSOCK2API_)\n+#  include <sys/timeval.h>\n+# else\n+#  if defined(OPENSSL_SYS_VXWORKS)\n+#   include <sys/times.h>\n+#  else\n+#   include <sys/time.h>\n+#  endif\n+# endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# define DTLS1_VERSION                   0xFEFF\n+# define DTLS1_2_VERSION                 0xFEFD\n+# define DTLS_MAX_VERSION                DTLS1_2_VERSION\n+# define DTLS1_VERSION_MAJOR             0xFE\n+\n+# define DTLS1_BAD_VER                   0x0100\n+\n+/* Special value for method supporting multiple versions */\n+# define DTLS_ANY_VERSION                0x1FFFF\n+\n+# if 0\n+/* this alert description is not specified anywhere... */\n+#  define DTLS1_AD_MISSING_HANDSHAKE_MESSAGE    110\n+# endif\n+\n+/* lengths of messages */\n+# define DTLS1_COOKIE_LENGTH                     256\n+\n+# define DTLS1_RT_HEADER_LENGTH                  13\n+\n+# define DTLS1_HM_HEADER_LENGTH                  12\n+\n+# define DTLS1_HM_BAD_FRAGMENT                   -2\n+# define DTLS1_HM_FRAGMENT_RETRY                 -3\n+\n+# define DTLS1_CCS_HEADER_LENGTH                  1\n+\n+# ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE\n+#  define DTLS1_AL_HEADER_LENGTH                   7\n+# else\n+#  define DTLS1_AL_HEADER_LENGTH                   2\n+# endif\n+\n+# ifndef OPENSSL_NO_SSL_INTERN\n+\n+#  ifndef OPENSSL_NO_SCTP\n+#   define DTLS1_SCTP_AUTH_LABEL   \"EXPORTER_DTLS_OVER_SCTP\"\n+#  endif\n+\n+/* Max MTU overhead we know about so far is 40 for IPv6 + 8 for UDP */\n+#  define DTLS1_MAX_MTU_OVERHEAD                   48\n+\n+typedef struct dtls1_bitmap_st {\n+    unsigned long map;          /* track 32 packets on 32-bit systems and 64\n+                                 * - on 64-bit systems */\n+    unsigned char max_seq_num[8]; /* max record number seen so far, 64-bit\n+                                   * value in big-endian encoding */\n+} DTLS1_BITMAP;\n+\n+struct dtls1_retransmit_state {\n+    EVP_CIPHER_CTX *enc_write_ctx; /* cryptographic state */\n+    EVP_MD_CTX *write_hash;     /* used for mac generation */\n+#  ifndef OPENSSL_NO_COMP\n+    COMP_CTX *compress;         /* compression */\n+#  else\n+    char *compress;\n+#  endif\n+    SSL_SESSION *session;\n+    unsigned short epoch;\n+};\n+\n+struct hm_header_st {\n+    unsigned char type;\n+    unsigned long msg_len;\n+    unsigned short seq;\n+    unsigned long frag_off;\n+    unsigned long frag_len;\n+    unsigned int is_ccs;\n+    struct dtls1_retransmit_state saved_retransmit_state;\n+};\n+\n+struct ccs_header_st {\n+    unsigned char type;\n+    unsigned short seq;\n+};\n+\n+struct dtls1_timeout_st {\n+    /* Number of read timeouts so far */\n+    unsigned int read_timeouts;\n+    /* Number of write timeouts so far */\n+    unsigned int write_timeouts;\n+    /* Number of alerts received so far */\n+    unsigned int num_alerts;\n+};\n+\n+typedef struct record_pqueue_st {\n+    unsigned short epoch;\n+    pqueue q;\n+} record_pqueue;\n+\n+typedef struct hm_fragment_st {\n+    struct hm_header_st msg_header;\n+    unsigned char *fragment;\n+    unsigned char *reassembly;\n+} hm_fragment;\n+\n+typedef struct dtls1_state_st {\n+    unsigned int send_cookie;\n+    unsigned char cookie[DTLS1_COOKIE_LENGTH];\n+    unsigned char rcvd_cookie[DTLS1_COOKIE_LENGTH];\n+    unsigned int cookie_len;\n+    /*\n+     * The current data and handshake epoch.  This is initially\n+     * undefined, and starts at zero once the initial handshake is\n+     * completed\n+     */\n+    unsigned short r_epoch;\n+    unsigned short w_epoch;\n+    /* records being received in the current epoch */\n+    DTLS1_BITMAP bitmap;\n+    /* renegotiation starts a new set of sequence numbers */\n+    DTLS1_BITMAP next_bitmap;\n+    /* handshake message numbers */\n+    unsigned short handshake_write_seq;\n+    unsigned short next_handshake_write_seq;\n+    unsigned short handshake_read_seq;\n+    /* save last sequence number for retransmissions */\n+    unsigned char last_write_sequence[8];\n+    /* Received handshake records (processed and unprocessed) */\n+    record_pqueue unprocessed_rcds;\n+    record_pqueue processed_rcds;\n+    /* Buffered handshake messages */\n+    pqueue buffered_messages;\n+    /* Buffered (sent) handshake records */\n+    pqueue sent_messages;\n+    /*\n+     * Buffered application records. Only for records between CCS and\n+     * Finished to prevent either protocol violation or unnecessary message\n+     * loss.\n+     */\n+    record_pqueue buffered_app_data;\n+    /* Is set when listening for new connections with dtls1_listen() */\n+    unsigned int listen;\n+    unsigned int link_mtu;      /* max on-the-wire DTLS packet size */\n+    unsigned int mtu;           /* max DTLS packet size */\n+    struct hm_header_st w_msg_hdr;\n+    struct hm_header_st r_msg_hdr;\n+    struct dtls1_timeout_st timeout;\n+    /*\n+     * Indicates when the last handshake msg or heartbeat sent will timeout\n+     */\n+    struct timeval next_timeout;\n+    /* Timeout duration */\n+    unsigned short timeout_duration;\n+    /*\n+     * storage for Alert/Handshake protocol data received but not yet\n+     * processed by ssl3_read_bytes:\n+     */\n+    unsigned char alert_fragment[DTLS1_AL_HEADER_LENGTH];\n+    unsigned int alert_fragment_len;\n+    unsigned char handshake_fragment[DTLS1_HM_HEADER_LENGTH];\n+    unsigned int handshake_fragment_len;\n+    unsigned int retransmitting;\n+    /*\n+     * Set when the handshake is ready to process peer's ChangeCipherSpec message.\n+     * Cleared after the message has been processed.\n+     */\n+    unsigned int change_cipher_spec_ok;\n+#  ifndef OPENSSL_NO_SCTP\n+    /* used when SSL_ST_XX_FLUSH is entered */\n+    int next_state;\n+    int shutdown_received;\n+#  endif\n+} DTLS1_STATE;\n+\n+typedef struct dtls1_record_data_st {\n+    unsigned char *packet;\n+    unsigned int packet_length;\n+    SSL3_BUFFER rbuf;\n+    SSL3_RECORD rrec;\n+#  ifndef OPENSSL_NO_SCTP\n+    struct bio_dgram_sctp_rcvinfo recordinfo;\n+#  endif\n+} DTLS1_RECORD_DATA;\n+\n+# endif\n+\n+/* Timeout multipliers (timeout slice is defined in apps/timeouts.h */\n+# define DTLS1_TMO_READ_COUNT                      2\n+# define DTLS1_TMO_WRITE_COUNT                     2\n+\n+# define DTLS1_TMO_ALERT_COUNT                     12\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "7be9989ac3a101016d51ba9ba66d908e3a3770ac",
            "filename": "deps/openssl/openssl/include/openssl/e_os2.h",
            "status": "added",
            "additions": 328,
            "deletions": 0,
            "changes": 328,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fe_os2.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fe_os2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fe_os2.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,328 @@\n+/* e_os2.h */\n+/* ====================================================================\n+ * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#include <openssl/opensslconf.h>\n+\n+#ifndef HEADER_E_OS2_H\n+# define HEADER_E_OS2_H\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/******************************************************************************\n+ * Detect operating systems.  This probably needs completing.\n+ * The result is that at least one OPENSSL_SYS_os macro should be defined.\n+ * However, if none is defined, Unix is assumed.\n+ **/\n+\n+# define OPENSSL_SYS_UNIX\n+\n+/* ---------------------- Macintosh, before MacOS X ----------------------- */\n+# if defined(__MWERKS__) && defined(macintosh) || defined(OPENSSL_SYSNAME_MAC)\n+#  undef OPENSSL_SYS_UNIX\n+#  define OPENSSL_SYS_MACINTOSH_CLASSIC\n+# endif\n+\n+/* ---------------------- NetWare ----------------------------------------- */\n+# if defined(NETWARE) || defined(OPENSSL_SYSNAME_NETWARE)\n+#  undef OPENSSL_SYS_UNIX\n+#  define OPENSSL_SYS_NETWARE\n+# endif\n+\n+/* --------------------- Microsoft operating systems ---------------------- */\n+\n+/*\n+ * Note that MSDOS actually denotes 32-bit environments running on top of\n+ * MS-DOS, such as DJGPP one.\n+ */\n+# if defined(OPENSSL_SYSNAME_MSDOS)\n+#  undef OPENSSL_SYS_UNIX\n+#  define OPENSSL_SYS_MSDOS\n+# endif\n+\n+/*\n+ * For 32 bit environment, there seems to be the CygWin environment and then\n+ * all the others that try to do the same thing Microsoft does...\n+ */\n+# if defined(OPENSSL_SYSNAME_UWIN)\n+#  undef OPENSSL_SYS_UNIX\n+#  define OPENSSL_SYS_WIN32_UWIN\n+# else\n+#  if defined(__CYGWIN__) || defined(OPENSSL_SYSNAME_CYGWIN)\n+#   undef OPENSSL_SYS_UNIX\n+#   define OPENSSL_SYS_WIN32_CYGWIN\n+#  else\n+#   if defined(_WIN32) || defined(OPENSSL_SYSNAME_WIN32)\n+#    undef OPENSSL_SYS_UNIX\n+#    define OPENSSL_SYS_WIN32\n+#   endif\n+#   if defined(_WIN64) || defined(OPENSSL_SYSNAME_WIN64)\n+#    undef OPENSSL_SYS_UNIX\n+#    if !defined(OPENSSL_SYS_WIN64)\n+#     define OPENSSL_SYS_WIN64\n+#    endif\n+#   endif\n+#   if defined(OPENSSL_SYSNAME_WINNT)\n+#    undef OPENSSL_SYS_UNIX\n+#    define OPENSSL_SYS_WINNT\n+#   endif\n+#   if defined(OPENSSL_SYSNAME_WINCE)\n+#    undef OPENSSL_SYS_UNIX\n+#    define OPENSSL_SYS_WINCE\n+#   endif\n+#  endif\n+# endif\n+\n+/* Anything that tries to look like Microsoft is \"Windows\" */\n+# if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN64) || defined(OPENSSL_SYS_WINNT) || defined(OPENSSL_SYS_WINCE)\n+#  undef OPENSSL_SYS_UNIX\n+#  define OPENSSL_SYS_WINDOWS\n+#  ifndef OPENSSL_SYS_MSDOS\n+#   define OPENSSL_SYS_MSDOS\n+#  endif\n+# endif\n+\n+/*\n+ * DLL settings.  This part is a bit tough, because it's up to the\n+ * application implementor how he or she will link the application, so it\n+ * requires some macro to be used.\n+ */\n+# ifdef OPENSSL_SYS_WINDOWS\n+#  ifndef OPENSSL_OPT_WINDLL\n+#   if defined(_WINDLL)         /* This is used when building OpenSSL to\n+                                 * indicate that DLL linkage should be used */\n+#    define OPENSSL_OPT_WINDLL\n+#   endif\n+#  endif\n+# endif\n+\n+/* ------------------------------- OpenVMS -------------------------------- */\n+# if defined(__VMS) || defined(VMS) || defined(OPENSSL_SYSNAME_VMS)\n+#  undef OPENSSL_SYS_UNIX\n+#  define OPENSSL_SYS_VMS\n+#  if defined(__DECC)\n+#   define OPENSSL_SYS_VMS_DECC\n+#  elif defined(__DECCXX)\n+#   define OPENSSL_SYS_VMS_DECC\n+#   define OPENSSL_SYS_VMS_DECCXX\n+#  else\n+#   define OPENSSL_SYS_VMS_NODECC\n+#  endif\n+# endif\n+\n+/* -------------------------------- OS/2 ---------------------------------- */\n+# if defined(__EMX__) || defined(__OS2__)\n+#  undef OPENSSL_SYS_UNIX\n+#  define OPENSSL_SYS_OS2\n+# endif\n+\n+/* -------------------------------- Unix ---------------------------------- */\n+# ifdef OPENSSL_SYS_UNIX\n+#  if defined(linux) || defined(__linux__) || defined(OPENSSL_SYSNAME_LINUX)\n+#   define OPENSSL_SYS_LINUX\n+#  endif\n+#  ifdef OPENSSL_SYSNAME_MPE\n+#   define OPENSSL_SYS_MPE\n+#  endif\n+#  ifdef OPENSSL_SYSNAME_SNI\n+#   define OPENSSL_SYS_SNI\n+#  endif\n+#  ifdef OPENSSL_SYSNAME_ULTRASPARC\n+#   define OPENSSL_SYS_ULTRASPARC\n+#  endif\n+#  ifdef OPENSSL_SYSNAME_NEWS4\n+#   define OPENSSL_SYS_NEWS4\n+#  endif\n+#  ifdef OPENSSL_SYSNAME_MACOSX\n+#   define OPENSSL_SYS_MACOSX\n+#  endif\n+#  ifdef OPENSSL_SYSNAME_MACOSX_RHAPSODY\n+#   define OPENSSL_SYS_MACOSX_RHAPSODY\n+#   define OPENSSL_SYS_MACOSX\n+#  endif\n+#  ifdef OPENSSL_SYSNAME_SUNOS\n+#   define OPENSSL_SYS_SUNOS\n+#  endif\n+#  if defined(_CRAY) || defined(OPENSSL_SYSNAME_CRAY)\n+#   define OPENSSL_SYS_CRAY\n+#  endif\n+#  if defined(_AIX) || defined(OPENSSL_SYSNAME_AIX)\n+#   define OPENSSL_SYS_AIX\n+#  endif\n+# endif\n+\n+/* -------------------------------- VOS ----------------------------------- */\n+# if defined(__VOS__) || defined(OPENSSL_SYSNAME_VOS)\n+#  define OPENSSL_SYS_VOS\n+#  ifdef __HPPA__\n+#   define OPENSSL_SYS_VOS_HPPA\n+#  endif\n+#  ifdef __IA32__\n+#   define OPENSSL_SYS_VOS_IA32\n+#  endif\n+# endif\n+\n+/* ------------------------------ VxWorks --------------------------------- */\n+# ifdef OPENSSL_SYSNAME_VXWORKS\n+#  define OPENSSL_SYS_VXWORKS\n+# endif\n+\n+/* -------------------------------- BeOS ---------------------------------- */\n+# if defined(__BEOS__)\n+#  define OPENSSL_SYS_BEOS\n+#  include <sys/socket.h>\n+#  if defined(BONE_VERSION)\n+#   define OPENSSL_SYS_BEOS_BONE\n+#  else\n+#   define OPENSSL_SYS_BEOS_R5\n+#  endif\n+# endif\n+\n+/**\n+ * That's it for OS-specific stuff\n+ *****************************************************************************/\n+\n+/* Specials for I/O an exit */\n+# ifdef OPENSSL_SYS_MSDOS\n+#  define OPENSSL_UNISTD_IO <io.h>\n+#  define OPENSSL_DECLARE_EXIT extern void exit(int);\n+# else\n+#  define OPENSSL_UNISTD_IO OPENSSL_UNISTD\n+#  define OPENSSL_DECLARE_EXIT  /* declared in unistd.h */\n+# endif\n+\n+/*-\n+ * Definitions of OPENSSL_GLOBAL and OPENSSL_EXTERN, to define and declare\n+ * certain global symbols that, with some compilers under VMS, have to be\n+ * defined and declared explicitely with globaldef and globalref.\n+ * Definitions of OPENSSL_EXPORT and OPENSSL_IMPORT, to define and declare\n+ * DLL exports and imports for compilers under Win32.  These are a little\n+ * more complicated to use.  Basically, for any library that exports some\n+ * global variables, the following code must be present in the header file\n+ * that declares them, before OPENSSL_EXTERN is used:\n+ *\n+ * #ifdef SOME_BUILD_FLAG_MACRO\n+ * # undef OPENSSL_EXTERN\n+ * # define OPENSSL_EXTERN OPENSSL_EXPORT\n+ * #endif\n+ *\n+ * The default is to have OPENSSL_EXPORT, OPENSSL_IMPORT and OPENSSL_GLOBAL\n+ * have some generally sensible values, and for OPENSSL_EXTERN to have the\n+ * value OPENSSL_IMPORT.\n+ */\n+\n+# if defined(OPENSSL_SYS_VMS_NODECC)\n+#  define OPENSSL_EXPORT globalref\n+#  define OPENSSL_IMPORT globalref\n+#  define OPENSSL_GLOBAL globaldef\n+# elif defined(OPENSSL_SYS_WINDOWS) && defined(OPENSSL_OPT_WINDLL)\n+#  define OPENSSL_EXPORT extern __declspec(dllexport)\n+#  define OPENSSL_IMPORT extern __declspec(dllimport)\n+#  define OPENSSL_GLOBAL\n+# else\n+#  define OPENSSL_EXPORT extern\n+#  define OPENSSL_IMPORT extern\n+#  define OPENSSL_GLOBAL\n+# endif\n+# define OPENSSL_EXTERN OPENSSL_IMPORT\n+\n+/*-\n+ * Macros to allow global variables to be reached through function calls when\n+ * required (if a shared library version requires it, for example.\n+ * The way it's done allows definitions like this:\n+ *\n+ *      // in foobar.c\n+ *      OPENSSL_IMPLEMENT_GLOBAL(int,foobar,0)\n+ *      // in foobar.h\n+ *      OPENSSL_DECLARE_GLOBAL(int,foobar);\n+ *      #define foobar OPENSSL_GLOBAL_REF(foobar)\n+ */\n+# ifdef OPENSSL_EXPORT_VAR_AS_FUNCTION\n+#  define OPENSSL_IMPLEMENT_GLOBAL(type,name,value)                      \\\n+        type *_shadow_##name(void)                                      \\\n+        { static type _hide_##name=value; return &_hide_##name; }\n+#  define OPENSSL_DECLARE_GLOBAL(type,name) type *_shadow_##name(void)\n+#  define OPENSSL_GLOBAL_REF(name) (*(_shadow_##name()))\n+# else\n+#  define OPENSSL_IMPLEMENT_GLOBAL(type,name,value) OPENSSL_GLOBAL type _shadow_##name=value;\n+#  define OPENSSL_DECLARE_GLOBAL(type,name) OPENSSL_EXPORT type _shadow_##name\n+#  define OPENSSL_GLOBAL_REF(name) _shadow_##name\n+# endif\n+\n+# if defined(OPENSSL_SYS_MACINTOSH_CLASSIC) && macintosh==1 && !defined(MAC_OS_GUSI_SOURCE)\n+#  define ossl_ssize_t long\n+# endif\n+\n+# ifdef OPENSSL_SYS_MSDOS\n+#  define ossl_ssize_t long\n+# endif\n+\n+# if defined(NeXT) || defined(OPENSSL_SYS_NEWS4) || defined(OPENSSL_SYS_SUNOS)\n+#  define ssize_t int\n+# endif\n+\n+# if defined(__ultrix) && !defined(ssize_t)\n+#  define ossl_ssize_t int\n+# endif\n+\n+# ifndef ossl_ssize_t\n+#  define ossl_ssize_t ssize_t\n+# endif\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "4cbdfeb7aed087bb25120a01de626e3b7ffc554d",
            "filename": "deps/openssl/openssl/include/openssl/ebcdic.h",
            "status": "added",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Febcdic.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Febcdic.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Febcdic.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,26 @@\n+/* crypto/ebcdic.h */\n+\n+#ifndef HEADER_EBCDIC_H\n+# define HEADER_EBCDIC_H\n+\n+# include <sys/types.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Avoid name clashes with other applications */\n+# define os_toascii   _openssl_os_toascii\n+# define os_toebcdic  _openssl_os_toebcdic\n+# define ebcdic2ascii _openssl_ebcdic2ascii\n+# define ascii2ebcdic _openssl_ascii2ebcdic\n+\n+extern const unsigned char os_toascii[256];\n+extern const unsigned char os_toebcdic[256];\n+void *ebcdic2ascii(void *dest, const void *srce, size_t count);\n+void *ascii2ebcdic(void *dest, const void *srce, size_t count);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "81e6faf6c5c5025f1c8ac916ac7ffbd1bd9739bc",
            "filename": "deps/openssl/openssl/include/openssl/ec.h",
            "status": "added",
            "additions": 1282,
            "deletions": 0,
            "changes": 1282,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fec.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fec.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fec.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,1282 @@\n+/* crypto/ec/ec.h */\n+/*\n+ * Originally written by Bodo Moeller for the OpenSSL project.\n+ */\n+/**\n+ * \\file crypto/ec/ec.h Include file for the OpenSSL EC functions\n+ * \\author Originally written by Bodo Moeller for the OpenSSL project\n+ */\n+/* ====================================================================\n+ * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+/* ====================================================================\n+ * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\n+ *\n+ * Portions of the attached software (\"Contribution\") are developed by\n+ * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.\n+ *\n+ * The Contribution is licensed pursuant to the OpenSSL open source\n+ * license provided above.\n+ *\n+ * The elliptic curve binary polynomial software is originally written by\n+ * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.\n+ *\n+ */\n+\n+#ifndef HEADER_EC_H\n+# define HEADER_EC_H\n+\n+# include <openssl/opensslconf.h>\n+\n+# ifdef OPENSSL_NO_EC\n+#  error EC is disabled.\n+# endif\n+\n+# include <openssl/asn1.h>\n+# include <openssl/symhacks.h>\n+# ifndef OPENSSL_NO_DEPRECATED\n+#  include <openssl/bn.h>\n+# endif\n+\n+# ifdef  __cplusplus\n+extern \"C\" {\n+# elif defined(__SUNPRO_C)\n+#  if __SUNPRO_C >= 0x520\n+#   pragma error_messages (off,E_ARRAY_OF_INCOMPLETE_NONAME,E_ARRAY_OF_INCOMPLETE)\n+#  endif\n+# endif\n+\n+# ifndef OPENSSL_ECC_MAX_FIELD_BITS\n+#  define OPENSSL_ECC_MAX_FIELD_BITS 661\n+# endif\n+\n+/** Enum for the point conversion form as defined in X9.62 (ECDSA)\n+ *  for the encoding of a elliptic curve point (x,y) */\n+typedef enum {\n+        /** the point is encoded as z||x, where the octet z specifies\n+         *  which solution of the quadratic equation y is  */\n+    POINT_CONVERSION_COMPRESSED = 2,\n+        /** the point is encoded as z||x||y, where z is the octet 0x04  */\n+    POINT_CONVERSION_UNCOMPRESSED = 4,\n+        /** the point is encoded as z||x||y, where the octet z specifies\n+         *  which solution of the quadratic equation y is  */\n+    POINT_CONVERSION_HYBRID = 6\n+} point_conversion_form_t;\n+\n+typedef struct ec_method_st EC_METHOD;\n+\n+typedef struct ec_group_st\n+    /*-\n+     EC_METHOD *meth;\n+     -- field definition\n+     -- curve coefficients\n+     -- optional generator with associated information (order, cofactor)\n+     -- optional extra data (precomputed table for fast computation of multiples of generator)\n+     -- ASN1 stuff\n+    */\n+    EC_GROUP;\n+\n+typedef struct ec_point_st EC_POINT;\n+\n+/********************************************************************/\n+/*               EC_METHODs for curves over GF(p)                   */\n+/********************************************************************/\n+\n+/** Returns the basic GFp ec methods which provides the basis for the\n+ *  optimized methods.\n+ *  \\return  EC_METHOD object\n+ */\n+const EC_METHOD *EC_GFp_simple_method(void);\n+\n+/** Returns GFp methods using montgomery multiplication.\n+ *  \\return  EC_METHOD object\n+ */\n+const EC_METHOD *EC_GFp_mont_method(void);\n+\n+/** Returns GFp methods using optimized methods for NIST recommended curves\n+ *  \\return  EC_METHOD object\n+ */\n+const EC_METHOD *EC_GFp_nist_method(void);\n+\n+# ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n+/** Returns 64-bit optimized methods for nistp224\n+ *  \\return  EC_METHOD object\n+ */\n+const EC_METHOD *EC_GFp_nistp224_method(void);\n+\n+/** Returns 64-bit optimized methods for nistp256\n+ *  \\return  EC_METHOD object\n+ */\n+const EC_METHOD *EC_GFp_nistp256_method(void);\n+\n+/** Returns 64-bit optimized methods for nistp521\n+ *  \\return  EC_METHOD object\n+ */\n+const EC_METHOD *EC_GFp_nistp521_method(void);\n+# endif\n+\n+# ifndef OPENSSL_NO_EC2M\n+/********************************************************************/\n+/*           EC_METHOD for curves over GF(2^m)                      */\n+/********************************************************************/\n+\n+/** Returns the basic GF2m ec method\n+ *  \\return  EC_METHOD object\n+ */\n+const EC_METHOD *EC_GF2m_simple_method(void);\n+\n+# endif\n+\n+/********************************************************************/\n+/*                   EC_GROUP functions                             */\n+/********************************************************************/\n+\n+/** Creates a new EC_GROUP object\n+ *  \\param   meth  EC_METHOD to use\n+ *  \\return  newly created EC_GROUP object or NULL in case of an error.\n+ */\n+EC_GROUP *EC_GROUP_new(const EC_METHOD *meth);\n+\n+/** Frees a EC_GROUP object\n+ *  \\param  group  EC_GROUP object to be freed.\n+ */\n+void EC_GROUP_free(EC_GROUP *group);\n+\n+/** Clears and frees a EC_GROUP object\n+ *  \\param  group  EC_GROUP object to be cleared and freed.\n+ */\n+void EC_GROUP_clear_free(EC_GROUP *group);\n+\n+/** Copies EC_GROUP objects. Note: both EC_GROUPs must use the same EC_METHOD.\n+ *  \\param  dst  destination EC_GROUP object\n+ *  \\param  src  source EC_GROUP object\n+ *  \\return 1 on success and 0 if an error occurred.\n+ */\n+int EC_GROUP_copy(EC_GROUP *dst, const EC_GROUP *src);\n+\n+/** Creates a new EC_GROUP object and copies the copies the content\n+ *  form src to the newly created EC_KEY object\n+ *  \\param  src  source EC_GROUP object\n+ *  \\return newly created EC_GROUP object or NULL in case of an error.\n+ */\n+EC_GROUP *EC_GROUP_dup(const EC_GROUP *src);\n+\n+/** Returns the EC_METHOD of the EC_GROUP object.\n+ *  \\param  group  EC_GROUP object\n+ *  \\return EC_METHOD used in this EC_GROUP object.\n+ */\n+const EC_METHOD *EC_GROUP_method_of(const EC_GROUP *group);\n+\n+/** Returns the field type of the EC_METHOD.\n+ *  \\param  meth  EC_METHOD object\n+ *  \\return NID of the underlying field type OID.\n+ */\n+int EC_METHOD_get_field_type(const EC_METHOD *meth);\n+\n+/** Sets the generator and it's order/cofactor of a EC_GROUP object.\n+ *  \\param  group      EC_GROUP object\n+ *  \\param  generator  EC_POINT object with the generator.\n+ *  \\param  order      the order of the group generated by the generator.\n+ *  \\param  cofactor   the index of the sub-group generated by the generator\n+ *                     in the group of all points on the elliptic curve.\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,\n+                           const BIGNUM *order, const BIGNUM *cofactor);\n+\n+/** Returns the generator of a EC_GROUP object.\n+ *  \\param  group  EC_GROUP object\n+ *  \\return the currently used generator (possibly NULL).\n+ */\n+const EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group);\n+\n+/** Returns the montgomery data for order(Generator)\n+ *  \\param  group  EC_GROUP object\n+ *  \\return the currently used generator (possibly NULL).\n+*/\n+BN_MONT_CTX *EC_GROUP_get_mont_data(const EC_GROUP *group);\n+\n+/** Gets the order of a EC_GROUP\n+ *  \\param  group  EC_GROUP object\n+ *  \\param  order  BIGNUM to which the order is copied\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx);\n+\n+/** Gets the cofactor of a EC_GROUP\n+ *  \\param  group     EC_GROUP object\n+ *  \\param  cofactor  BIGNUM to which the cofactor is copied\n+ *  \\param  ctx       BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor,\n+                          BN_CTX *ctx);\n+\n+/** Sets the name of a EC_GROUP object\n+ *  \\param  group  EC_GROUP object\n+ *  \\param  nid    NID of the curve name OID\n+ */\n+void EC_GROUP_set_curve_name(EC_GROUP *group, int nid);\n+\n+/** Returns the curve name of a EC_GROUP object\n+ *  \\param  group  EC_GROUP object\n+ *  \\return NID of the curve name OID or 0 if not set.\n+ */\n+int EC_GROUP_get_curve_name(const EC_GROUP *group);\n+\n+void EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag);\n+int EC_GROUP_get_asn1_flag(const EC_GROUP *group);\n+\n+void EC_GROUP_set_point_conversion_form(EC_GROUP *group,\n+                                        point_conversion_form_t form);\n+point_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *);\n+\n+unsigned char *EC_GROUP_get0_seed(const EC_GROUP *x);\n+size_t EC_GROUP_get_seed_len(const EC_GROUP *);\n+size_t EC_GROUP_set_seed(EC_GROUP *, const unsigned char *, size_t len);\n+\n+/** Sets the parameter of a ec over GFp defined by y^2 = x^3 + a*x + b\n+ *  \\param  group  EC_GROUP object\n+ *  \\param  p      BIGNUM with the prime number\n+ *  \\param  a      BIGNUM with parameter a of the equation\n+ *  \\param  b      BIGNUM with parameter b of the equation\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_GROUP_set_curve_GFp(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a,\n+                           const BIGNUM *b, BN_CTX *ctx);\n+\n+/** Gets the parameter of the ec over GFp defined by y^2 = x^3 + a*x + b\n+ *  \\param  group  EC_GROUP object\n+ *  \\param  p      BIGNUM for the prime number\n+ *  \\param  a      BIGNUM for parameter a of the equation\n+ *  \\param  b      BIGNUM for parameter b of the equation\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_GROUP_get_curve_GFp(const EC_GROUP *group, BIGNUM *p, BIGNUM *a,\n+                           BIGNUM *b, BN_CTX *ctx);\n+\n+# ifndef OPENSSL_NO_EC2M\n+/** Sets the parameter of a ec over GF2m defined by y^2 + x*y = x^3 + a*x^2 + b\n+ *  \\param  group  EC_GROUP object\n+ *  \\param  p      BIGNUM with the polynomial defining the underlying field\n+ *  \\param  a      BIGNUM with parameter a of the equation\n+ *  \\param  b      BIGNUM with parameter b of the equation\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a,\n+                            const BIGNUM *b, BN_CTX *ctx);\n+\n+/** Gets the parameter of the ec over GF2m defined by y^2 + x*y = x^3 + a*x^2 + b\n+ *  \\param  group  EC_GROUP object\n+ *  \\param  p      BIGNUM for the polynomial defining the underlying field\n+ *  \\param  a      BIGNUM for parameter a of the equation\n+ *  \\param  b      BIGNUM for parameter b of the equation\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a,\n+                            BIGNUM *b, BN_CTX *ctx);\n+# endif\n+/** Returns the number of bits needed to represent a field element\n+ *  \\param  group  EC_GROUP object\n+ *  \\return number of bits needed to represent a field element\n+ */\n+int EC_GROUP_get_degree(const EC_GROUP *group);\n+\n+/** Checks whether the parameter in the EC_GROUP define a valid ec group\n+ *  \\param  group  EC_GROUP object\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 if group is a valid ec group and 0 otherwise\n+ */\n+int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx);\n+\n+/** Checks whether the discriminant of the elliptic curve is zero or not\n+ *  \\param  group  EC_GROUP object\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 if the discriminant is not zero and 0 otherwise\n+ */\n+int EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx);\n+\n+/** Compares two EC_GROUP objects\n+ *  \\param  a    first EC_GROUP object\n+ *  \\param  b    second EC_GROUP object\n+ *  \\param  ctx  BN_CTX object (optional)\n+ *  \\return 0 if both groups are equal and 1 otherwise\n+ */\n+int EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx);\n+\n+/*\n+ * EC_GROUP_new_GF*() calls EC_GROUP_new() and EC_GROUP_set_GF*() after\n+ * choosing an appropriate EC_METHOD\n+ */\n+\n+/** Creates a new EC_GROUP object with the specified parameters defined\n+ *  over GFp (defined by the equation y^2 = x^3 + a*x + b)\n+ *  \\param  p    BIGNUM with the prime number\n+ *  \\param  a    BIGNUM with the parameter a of the equation\n+ *  \\param  b    BIGNUM with the parameter b of the equation\n+ *  \\param  ctx  BN_CTX object (optional)\n+ *  \\return newly created EC_GROUP object with the specified parameters\n+ */\n+EC_GROUP *EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a,\n+                                 const BIGNUM *b, BN_CTX *ctx);\n+# ifndef OPENSSL_NO_EC2M\n+/** Creates a new EC_GROUP object with the specified parameters defined\n+ *  over GF2m (defined by the equation y^2 + x*y = x^3 + a*x^2 + b)\n+ *  \\param  p    BIGNUM with the polynomial defining the underlying field\n+ *  \\param  a    BIGNUM with the parameter a of the equation\n+ *  \\param  b    BIGNUM with the parameter b of the equation\n+ *  \\param  ctx  BN_CTX object (optional)\n+ *  \\return newly created EC_GROUP object with the specified parameters\n+ */\n+EC_GROUP *EC_GROUP_new_curve_GF2m(const BIGNUM *p, const BIGNUM *a,\n+                                  const BIGNUM *b, BN_CTX *ctx);\n+# endif\n+/** Creates a EC_GROUP object with a curve specified by a NID\n+ *  \\param  nid  NID of the OID of the curve name\n+ *  \\return newly created EC_GROUP object with specified curve or NULL\n+ *          if an error occurred\n+ */\n+EC_GROUP *EC_GROUP_new_by_curve_name(int nid);\n+\n+/********************************************************************/\n+/*               handling of internal curves                        */\n+/********************************************************************/\n+\n+typedef struct {\n+    int nid;\n+    const char *comment;\n+} EC_builtin_curve;\n+\n+/*\n+ * EC_builtin_curves(EC_builtin_curve *r, size_t size) returns number of all\n+ * available curves or zero if a error occurred. In case r ist not zero\n+ * nitems EC_builtin_curve structures are filled with the data of the first\n+ * nitems internal groups\n+ */\n+size_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems);\n+\n+const char *EC_curve_nid2nist(int nid);\n+int EC_curve_nist2nid(const char *name);\n+\n+/********************************************************************/\n+/*                    EC_POINT functions                            */\n+/********************************************************************/\n+\n+/** Creates a new EC_POINT object for the specified EC_GROUP\n+ *  \\param  group  EC_GROUP the underlying EC_GROUP object\n+ *  \\return newly created EC_POINT object or NULL if an error occurred\n+ */\n+EC_POINT *EC_POINT_new(const EC_GROUP *group);\n+\n+/** Frees a EC_POINT object\n+ *  \\param  point  EC_POINT object to be freed\n+ */\n+void EC_POINT_free(EC_POINT *point);\n+\n+/** Clears and frees a EC_POINT object\n+ *  \\param  point  EC_POINT object to be cleared and freed\n+ */\n+void EC_POINT_clear_free(EC_POINT *point);\n+\n+/** Copies EC_POINT object\n+ *  \\param  dst  destination EC_POINT object\n+ *  \\param  src  source EC_POINT object\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_copy(EC_POINT *dst, const EC_POINT *src);\n+\n+/** Creates a new EC_POINT object and copies the content of the supplied\n+ *  EC_POINT\n+ *  \\param  src    source EC_POINT object\n+ *  \\param  group  underlying the EC_GROUP object\n+ *  \\return newly created EC_POINT object or NULL if an error occurred\n+ */\n+EC_POINT *EC_POINT_dup(const EC_POINT *src, const EC_GROUP *group);\n+\n+/** Returns the EC_METHOD used in EC_POINT object\n+ *  \\param  point  EC_POINT object\n+ *  \\return the EC_METHOD used\n+ */\n+const EC_METHOD *EC_POINT_method_of(const EC_POINT *point);\n+\n+/** Sets a point to infinity (neutral element)\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  point  EC_POINT to set to infinity\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point);\n+\n+/** Sets the jacobian projective coordinates of a EC_POINT over GFp\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  x      BIGNUM with the x-coordinate\n+ *  \\param  y      BIGNUM with the y-coordinate\n+ *  \\param  z      BIGNUM with the z-coordinate\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,\n+                                             EC_POINT *p, const BIGNUM *x,\n+                                             const BIGNUM *y, const BIGNUM *z,\n+                                             BN_CTX *ctx);\n+\n+/** Gets the jacobian projective coordinates of a EC_POINT over GFp\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  x      BIGNUM for the x-coordinate\n+ *  \\param  y      BIGNUM for the y-coordinate\n+ *  \\param  z      BIGNUM for the z-coordinate\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,\n+                                             const EC_POINT *p, BIGNUM *x,\n+                                             BIGNUM *y, BIGNUM *z,\n+                                             BN_CTX *ctx);\n+\n+/** Sets the affine coordinates of a EC_POINT over GFp\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  x      BIGNUM with the x-coordinate\n+ *  \\param  y      BIGNUM with the y-coordinate\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,\n+                                        const BIGNUM *x, const BIGNUM *y,\n+                                        BN_CTX *ctx);\n+\n+/** Gets the affine coordinates of a EC_POINT over GFp\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  x      BIGNUM for the x-coordinate\n+ *  \\param  y      BIGNUM for the y-coordinate\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group,\n+                                        const EC_POINT *p, BIGNUM *x,\n+                                        BIGNUM *y, BN_CTX *ctx);\n+\n+/** Sets the x9.62 compressed coordinates of a EC_POINT over GFp\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  x      BIGNUM with x-coordinate\n+ *  \\param  y_bit  integer with the y-Bit (either 0 or 1)\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group,\n+                                            EC_POINT *p, const BIGNUM *x,\n+                                            int y_bit, BN_CTX *ctx);\n+# ifndef OPENSSL_NO_EC2M\n+/** Sets the affine coordinates of a EC_POINT over GF2m\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  x      BIGNUM with the x-coordinate\n+ *  \\param  y      BIGNUM with the y-coordinate\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p,\n+                                         const BIGNUM *x, const BIGNUM *y,\n+                                         BN_CTX *ctx);\n+\n+/** Gets the affine coordinates of a EC_POINT over GF2m\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  x      BIGNUM for the x-coordinate\n+ *  \\param  y      BIGNUM for the y-coordinate\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group,\n+                                         const EC_POINT *p, BIGNUM *x,\n+                                         BIGNUM *y, BN_CTX *ctx);\n+\n+/** Sets the x9.62 compressed coordinates of a EC_POINT over GF2m\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  x      BIGNUM with x-coordinate\n+ *  \\param  y_bit  integer with the y-Bit (either 0 or 1)\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group,\n+                                             EC_POINT *p, const BIGNUM *x,\n+                                             int y_bit, BN_CTX *ctx);\n+# endif\n+/** Encodes a EC_POINT object to a octet string\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  form   point conversion form\n+ *  \\param  buf    memory buffer for the result. If NULL the function returns\n+ *                 required buffer size.\n+ *  \\param  len    length of the memory buffer\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return the length of the encoded octet string or 0 if an error occurred\n+ */\n+size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *p,\n+                          point_conversion_form_t form,\n+                          unsigned char *buf, size_t len, BN_CTX *ctx);\n+\n+/** Decodes a EC_POINT from a octet string\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\param  buf    memory buffer with the encoded ec point\n+ *  \\param  len    length of the encoded ec point\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *p,\n+                       const unsigned char *buf, size_t len, BN_CTX *ctx);\n+\n+/* other interfaces to point2oct/oct2point: */\n+BIGNUM *EC_POINT_point2bn(const EC_GROUP *, const EC_POINT *,\n+                          point_conversion_form_t form, BIGNUM *, BN_CTX *);\n+EC_POINT *EC_POINT_bn2point(const EC_GROUP *, const BIGNUM *,\n+                            EC_POINT *, BN_CTX *);\n+char *EC_POINT_point2hex(const EC_GROUP *, const EC_POINT *,\n+                         point_conversion_form_t form, BN_CTX *);\n+EC_POINT *EC_POINT_hex2point(const EC_GROUP *, const char *,\n+                             EC_POINT *, BN_CTX *);\n+\n+/********************************************************************/\n+/*         functions for doing EC_POINT arithmetic                  */\n+/********************************************************************/\n+\n+/** Computes the sum of two EC_POINT\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  r      EC_POINT object for the result (r = a + b)\n+ *  \\param  a      EC_POINT object with the first summand\n+ *  \\param  b      EC_POINT object with the second summand\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\n+                 const EC_POINT *b, BN_CTX *ctx);\n+\n+/** Computes the double of a EC_POINT\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  r      EC_POINT object for the result (r = 2 * a)\n+ *  \\param  a      EC_POINT object\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\n+                 BN_CTX *ctx);\n+\n+/** Computes the inverse of a EC_POINT\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  a      EC_POINT object to be inverted (it's used for the result as well)\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx);\n+\n+/** Checks whether the point is the neutral element of the group\n+ *  \\param  group  the underlying EC_GROUP object\n+ *  \\param  p      EC_POINT object\n+ *  \\return 1 if the point is the neutral element and 0 otherwise\n+ */\n+int EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *p);\n+\n+/** Checks whether the point is on the curve\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  point  EC_POINT object to check\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 if point if on the curve and 0 otherwise\n+ */\n+int EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point,\n+                         BN_CTX *ctx);\n+\n+/** Compares two EC_POINTs\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  a      first EC_POINT object\n+ *  \\param  b      second EC_POINT object\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 0 if both points are equal and a value != 0 otherwise\n+ */\n+int EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b,\n+                 BN_CTX *ctx);\n+\n+int EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx);\n+int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,\n+                          EC_POINT *points[], BN_CTX *ctx);\n+\n+/** Computes r = generator * n sum_{i=0}^{num-1} p[i] * m[i]\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  r      EC_POINT object for the result\n+ *  \\param  n      BIGNUM with the multiplier for the group generator (optional)\n+ *  \\param  num    number futher summands\n+ *  \\param  p      array of size num of EC_POINT objects\n+ *  \\param  m      array of size num of BIGNUM objects\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,\n+                  size_t num, const EC_POINT *p[], const BIGNUM *m[],\n+                  BN_CTX *ctx);\n+\n+/** Computes r = generator * n + q * m\n+ *  \\param  group  underlying EC_GROUP object\n+ *  \\param  r      EC_POINT object for the result\n+ *  \\param  n      BIGNUM with the multiplier for the group generator (optional)\n+ *  \\param  q      EC_POINT object with the first factor of the second summand\n+ *  \\param  m      BIGNUM with the second factor of the second summand\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,\n+                 const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);\n+\n+/** Stores multiples of generator for faster point multiplication\n+ *  \\param  group  EC_GROUP object\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occured\n+ */\n+int EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx);\n+\n+/** Reports whether a precomputation has been done\n+ *  \\param  group  EC_GROUP object\n+ *  \\return 1 if a pre-computation has been done and 0 otherwise\n+ */\n+int EC_GROUP_have_precompute_mult(const EC_GROUP *group);\n+\n+/********************************************************************/\n+/*                       ASN1 stuff                                 */\n+/********************************************************************/\n+\n+/*\n+ * EC_GROUP_get_basis_type() returns the NID of the basis type used to\n+ * represent the field elements\n+ */\n+int EC_GROUP_get_basis_type(const EC_GROUP *);\n+# ifndef OPENSSL_NO_EC2M\n+int EC_GROUP_get_trinomial_basis(const EC_GROUP *, unsigned int *k);\n+int EC_GROUP_get_pentanomial_basis(const EC_GROUP *, unsigned int *k1,\n+                                   unsigned int *k2, unsigned int *k3);\n+# endif\n+\n+# define OPENSSL_EC_NAMED_CURVE  0x001\n+\n+typedef struct ecpk_parameters_st ECPKPARAMETERS;\n+\n+EC_GROUP *d2i_ECPKParameters(EC_GROUP **, const unsigned char **in, long len);\n+int i2d_ECPKParameters(const EC_GROUP *, unsigned char **out);\n+\n+# define d2i_ECPKParameters_bio(bp,x) ASN1_d2i_bio_of(EC_GROUP,NULL,d2i_ECPKParameters,bp,x)\n+# define i2d_ECPKParameters_bio(bp,x) ASN1_i2d_bio_of_const(EC_GROUP,i2d_ECPKParameters,bp,x)\n+# define d2i_ECPKParameters_fp(fp,x) (EC_GROUP *)ASN1_d2i_fp(NULL, \\\n+                (char *(*)())d2i_ECPKParameters,(fp),(unsigned char **)(x))\n+# define i2d_ECPKParameters_fp(fp,x) ASN1_i2d_fp(i2d_ECPKParameters,(fp), \\\n+                (unsigned char *)(x))\n+\n+# ifndef OPENSSL_NO_BIO\n+int ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off);\n+# endif\n+# ifndef OPENSSL_NO_FP_API\n+int ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off);\n+# endif\n+\n+/********************************************************************/\n+/*                      EC_KEY functions                            */\n+/********************************************************************/\n+\n+typedef struct ec_key_st EC_KEY;\n+\n+/* some values for the encoding_flag */\n+# define EC_PKEY_NO_PARAMETERS   0x001\n+# define EC_PKEY_NO_PUBKEY       0x002\n+\n+/* some values for the flags field */\n+# define EC_FLAG_NON_FIPS_ALLOW  0x1\n+# define EC_FLAG_FIPS_CHECKED    0x2\n+\n+/** Creates a new EC_KEY object.\n+ *  \\return EC_KEY object or NULL if an error occurred.\n+ */\n+EC_KEY *EC_KEY_new(void);\n+\n+int EC_KEY_get_flags(const EC_KEY *key);\n+\n+void EC_KEY_set_flags(EC_KEY *key, int flags);\n+\n+void EC_KEY_clear_flags(EC_KEY *key, int flags);\n+\n+/** Creates a new EC_KEY object using a named curve as underlying\n+ *  EC_GROUP object.\n+ *  \\param  nid  NID of the named curve.\n+ *  \\return EC_KEY object or NULL if an error occurred.\n+ */\n+EC_KEY *EC_KEY_new_by_curve_name(int nid);\n+\n+/** Frees a EC_KEY object.\n+ *  \\param  key  EC_KEY object to be freed.\n+ */\n+void EC_KEY_free(EC_KEY *key);\n+\n+/** Copies a EC_KEY object.\n+ *  \\param  dst  destination EC_KEY object\n+ *  \\param  src  src EC_KEY object\n+ *  \\return dst or NULL if an error occurred.\n+ */\n+EC_KEY *EC_KEY_copy(EC_KEY *dst, const EC_KEY *src);\n+\n+/** Creates a new EC_KEY object and copies the content from src to it.\n+ *  \\param  src  the source EC_KEY object\n+ *  \\return newly created EC_KEY object or NULL if an error occurred.\n+ */\n+EC_KEY *EC_KEY_dup(const EC_KEY *src);\n+\n+/** Increases the internal reference count of a EC_KEY object.\n+ *  \\param  key  EC_KEY object\n+ *  \\return 1 on success and 0 if an error occurred.\n+ */\n+int EC_KEY_up_ref(EC_KEY *key);\n+\n+/** Returns the EC_GROUP object of a EC_KEY object\n+ *  \\param  key  EC_KEY object\n+ *  \\return the EC_GROUP object (possibly NULL).\n+ */\n+const EC_GROUP *EC_KEY_get0_group(const EC_KEY *key);\n+\n+/** Sets the EC_GROUP of a EC_KEY object.\n+ *  \\param  key    EC_KEY object\n+ *  \\param  group  EC_GROUP to use in the EC_KEY object (note: the EC_KEY\n+ *                 object will use an own copy of the EC_GROUP).\n+ *  \\return 1 on success and 0 if an error occurred.\n+ */\n+int EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group);\n+\n+/** Returns the private key of a EC_KEY object.\n+ *  \\param  key  EC_KEY object\n+ *  \\return a BIGNUM with the private key (possibly NULL).\n+ */\n+const BIGNUM *EC_KEY_get0_private_key(const EC_KEY *key);\n+\n+/** Sets the private key of a EC_KEY object.\n+ *  \\param  key  EC_KEY object\n+ *  \\param  prv  BIGNUM with the private key (note: the EC_KEY object\n+ *               will use an own copy of the BIGNUM).\n+ *  \\return 1 on success and 0 if an error occurred.\n+ */\n+int EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *prv);\n+\n+/** Returns the public key of a EC_KEY object.\n+ *  \\param  key  the EC_KEY object\n+ *  \\return a EC_POINT object with the public key (possibly NULL)\n+ */\n+const EC_POINT *EC_KEY_get0_public_key(const EC_KEY *key);\n+\n+/** Sets the public key of a EC_KEY object.\n+ *  \\param  key  EC_KEY object\n+ *  \\param  pub  EC_POINT object with the public key (note: the EC_KEY object\n+ *               will use an own copy of the EC_POINT object).\n+ *  \\return 1 on success and 0 if an error occurred.\n+ */\n+int EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub);\n+\n+unsigned EC_KEY_get_enc_flags(const EC_KEY *key);\n+void EC_KEY_set_enc_flags(EC_KEY *eckey, unsigned int flags);\n+point_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *key);\n+void EC_KEY_set_conv_form(EC_KEY *eckey, point_conversion_form_t cform);\n+/* functions to set/get method specific data  */\n+void *EC_KEY_get_key_method_data(EC_KEY *key,\n+                                 void *(*dup_func) (void *),\n+                                 void (*free_func) (void *),\n+                                 void (*clear_free_func) (void *));\n+/** Sets the key method data of an EC_KEY object, if none has yet been set.\n+ *  \\param  key              EC_KEY object\n+ *  \\param  data             opaque data to install.\n+ *  \\param  dup_func         a function that duplicates |data|.\n+ *  \\param  free_func        a function that frees |data|.\n+ *  \\param  clear_free_func  a function that wipes and frees |data|.\n+ *  \\return the previously set data pointer, or NULL if |data| was inserted.\n+ */\n+void *EC_KEY_insert_key_method_data(EC_KEY *key, void *data,\n+                                    void *(*dup_func) (void *),\n+                                    void (*free_func) (void *),\n+                                    void (*clear_free_func) (void *));\n+/* wrapper functions for the underlying EC_GROUP object */\n+void EC_KEY_set_asn1_flag(EC_KEY *eckey, int asn1_flag);\n+\n+/** Creates a table of pre-computed multiples of the generator to\n+ *  accelerate further EC_KEY operations.\n+ *  \\param  key  EC_KEY object\n+ *  \\param  ctx  BN_CTX object (optional)\n+ *  \\return 1 on success and 0 if an error occurred.\n+ */\n+int EC_KEY_precompute_mult(EC_KEY *key, BN_CTX *ctx);\n+\n+/** Creates a new ec private (and optional a new public) key.\n+ *  \\param  key  EC_KEY object\n+ *  \\return 1 on success and 0 if an error occurred.\n+ */\n+int EC_KEY_generate_key(EC_KEY *key);\n+\n+/** Verifies that a private and/or public key is valid.\n+ *  \\param  key  the EC_KEY object\n+ *  \\return 1 on success and 0 otherwise.\n+ */\n+int EC_KEY_check_key(const EC_KEY *key);\n+\n+/** Sets a public key from affine coordindates performing\n+ *  neccessary NIST PKV tests.\n+ *  \\param  key  the EC_KEY object\n+ *  \\param  x    public key x coordinate\n+ *  \\param  y    public key y coordinate\n+ *  \\return 1 on success and 0 otherwise.\n+ */\n+int EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,\n+                                             BIGNUM *y);\n+\n+/********************************************************************/\n+/*        de- and encoding functions for SEC1 ECPrivateKey          */\n+/********************************************************************/\n+\n+/** Decodes a private key from a memory buffer.\n+ *  \\param  key  a pointer to a EC_KEY object which should be used (or NULL)\n+ *  \\param  in   pointer to memory with the DER encoded private key\n+ *  \\param  len  length of the DER encoded private key\n+ *  \\return the decoded private key or NULL if an error occurred.\n+ */\n+EC_KEY *d2i_ECPrivateKey(EC_KEY **key, const unsigned char **in, long len);\n+\n+/** Encodes a private key object and stores the result in a buffer.\n+ *  \\param  key  the EC_KEY object to encode\n+ *  \\param  out  the buffer for the result (if NULL the function returns number\n+ *               of bytes needed).\n+ *  \\return 1 on success and 0 if an error occurred.\n+ */\n+int i2d_ECPrivateKey(EC_KEY *key, unsigned char **out);\n+\n+/********************************************************************/\n+/*        de- and encoding functions for EC parameters              */\n+/********************************************************************/\n+\n+/** Decodes ec parameter from a memory buffer.\n+ *  \\param  key  a pointer to a EC_KEY object which should be used (or NULL)\n+ *  \\param  in   pointer to memory with the DER encoded ec parameters\n+ *  \\param  len  length of the DER encoded ec parameters\n+ *  \\return a EC_KEY object with the decoded parameters or NULL if an error\n+ *          occurred.\n+ */\n+EC_KEY *d2i_ECParameters(EC_KEY **key, const unsigned char **in, long len);\n+\n+/** Encodes ec parameter and stores the result in a buffer.\n+ *  \\param  key  the EC_KEY object with ec paramters to encode\n+ *  \\param  out  the buffer for the result (if NULL the function returns number\n+ *               of bytes needed).\n+ *  \\return 1 on success and 0 if an error occurred.\n+ */\n+int i2d_ECParameters(EC_KEY *key, unsigned char **out);\n+\n+/********************************************************************/\n+/*         de- and encoding functions for EC public key             */\n+/*         (octet string, not DER -- hence 'o2i' and 'i2o')         */\n+/********************************************************************/\n+\n+/** Decodes a ec public key from a octet string.\n+ *  \\param  key  a pointer to a EC_KEY object which should be used\n+ *  \\param  in   memory buffer with the encoded public key\n+ *  \\param  len  length of the encoded public key\n+ *  \\return EC_KEY object with decoded public key or NULL if an error\n+ *          occurred.\n+ */\n+EC_KEY *o2i_ECPublicKey(EC_KEY **key, const unsigned char **in, long len);\n+\n+/** Encodes a ec public key in an octet string.\n+ *  \\param  key  the EC_KEY object with the public key\n+ *  \\param  out  the buffer for the result (if NULL the function returns number\n+ *               of bytes needed).\n+ *  \\return 1 on success and 0 if an error occurred\n+ */\n+int i2o_ECPublicKey(EC_KEY *key, unsigned char **out);\n+\n+# ifndef OPENSSL_NO_BIO\n+/** Prints out the ec parameters on human readable form.\n+ *  \\param  bp   BIO object to which the information is printed\n+ *  \\param  key  EC_KEY object\n+ *  \\return 1 on success and 0 if an error occurred\n+ */\n+int ECParameters_print(BIO *bp, const EC_KEY *key);\n+\n+/** Prints out the contents of a EC_KEY object\n+ *  \\param  bp   BIO object to which the information is printed\n+ *  \\param  key  EC_KEY object\n+ *  \\param  off  line offset\n+ *  \\return 1 on success and 0 if an error occurred\n+ */\n+int EC_KEY_print(BIO *bp, const EC_KEY *key, int off);\n+\n+# endif\n+# ifndef OPENSSL_NO_FP_API\n+/** Prints out the ec parameters on human readable form.\n+ *  \\param  fp   file descriptor to which the information is printed\n+ *  \\param  key  EC_KEY object\n+ *  \\return 1 on success and 0 if an error occurred\n+ */\n+int ECParameters_print_fp(FILE *fp, const EC_KEY *key);\n+\n+/** Prints out the contents of a EC_KEY object\n+ *  \\param  fp   file descriptor to which the information is printed\n+ *  \\param  key  EC_KEY object\n+ *  \\param  off  line offset\n+ *  \\return 1 on success and 0 if an error occurred\n+ */\n+int EC_KEY_print_fp(FILE *fp, const EC_KEY *key, int off);\n+\n+# endif\n+\n+# define ECParameters_dup(x) ASN1_dup_of(EC_KEY,i2d_ECParameters,d2i_ECParameters,x)\n+\n+# ifndef __cplusplus\n+#  if defined(__SUNPRO_C)\n+#   if __SUNPRO_C >= 0x520\n+#    pragma error_messages (default,E_ARRAY_OF_INCOMPLETE_NONAME,E_ARRAY_OF_INCOMPLETE)\n+#   endif\n+#  endif\n+# endif\n+\n+# define EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_PARAMGEN|EVP_PKEY_OP_KEYGEN, \\\n+                                EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID, nid, NULL)\n+\n+# define EVP_PKEY_CTX_set_ec_param_enc(ctx, flag) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_PARAMGEN|EVP_PKEY_OP_KEYGEN, \\\n+                                EVP_PKEY_CTRL_EC_PARAM_ENC, flag, NULL)\n+\n+# define EVP_PKEY_CTX_set_ecdh_cofactor_mode(ctx, flag) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_EC_ECDH_COFACTOR, flag, NULL)\n+\n+# define EVP_PKEY_CTX_get_ecdh_cofactor_mode(ctx) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_EC_ECDH_COFACTOR, -2, NULL)\n+\n+# define EVP_PKEY_CTX_set_ecdh_kdf_type(ctx, kdf) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_EC_KDF_TYPE, kdf, NULL)\n+\n+# define EVP_PKEY_CTX_get_ecdh_kdf_type(ctx) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_EC_KDF_TYPE, -2, NULL)\n+\n+# define EVP_PKEY_CTX_set_ecdh_kdf_md(ctx, md) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_EC_KDF_MD, 0, (void *)md)\n+\n+# define EVP_PKEY_CTX_get_ecdh_kdf_md(ctx, pmd) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_GET_EC_KDF_MD, 0, (void *)pmd)\n+\n+# define EVP_PKEY_CTX_set_ecdh_kdf_outlen(ctx, len) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_EC_KDF_OUTLEN, len, NULL)\n+\n+# define EVP_PKEY_CTX_get_ecdh_kdf_outlen(ctx, plen) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                        EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN, 0, (void *)plen)\n+\n+# define EVP_PKEY_CTX_set0_ecdh_kdf_ukm(ctx, p, plen) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_EC_KDF_UKM, plen, (void *)p)\n+\n+# define EVP_PKEY_CTX_get0_ecdh_kdf_ukm(ctx, p) \\\n+        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \\\n+                                EVP_PKEY_OP_DERIVE, \\\n+                                EVP_PKEY_CTRL_GET_EC_KDF_UKM, 0, (void *)p)\n+\n+# define EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID             (EVP_PKEY_ALG_CTRL + 1)\n+# define EVP_PKEY_CTRL_EC_PARAM_ENC                      (EVP_PKEY_ALG_CTRL + 2)\n+# define EVP_PKEY_CTRL_EC_ECDH_COFACTOR                  (EVP_PKEY_ALG_CTRL + 3)\n+# define EVP_PKEY_CTRL_EC_KDF_TYPE                       (EVP_PKEY_ALG_CTRL + 4)\n+# define EVP_PKEY_CTRL_EC_KDF_MD                         (EVP_PKEY_ALG_CTRL + 5)\n+# define EVP_PKEY_CTRL_GET_EC_KDF_MD                     (EVP_PKEY_ALG_CTRL + 6)\n+# define EVP_PKEY_CTRL_EC_KDF_OUTLEN                     (EVP_PKEY_ALG_CTRL + 7)\n+# define EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN                 (EVP_PKEY_ALG_CTRL + 8)\n+# define EVP_PKEY_CTRL_EC_KDF_UKM                        (EVP_PKEY_ALG_CTRL + 9)\n+# define EVP_PKEY_CTRL_GET_EC_KDF_UKM                    (EVP_PKEY_ALG_CTRL + 10)\n+/* KDF types */\n+# define EVP_PKEY_ECDH_KDF_NONE                          1\n+# define EVP_PKEY_ECDH_KDF_X9_62                         2\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_EC_strings(void);\n+\n+/* Error codes for the EC functions. */\n+\n+/* Function codes. */\n+# define EC_F_BN_TO_FELEM                                 224\n+# define EC_F_COMPUTE_WNAF                                143\n+# define EC_F_D2I_ECPARAMETERS                            144\n+# define EC_F_D2I_ECPKPARAMETERS                          145\n+# define EC_F_D2I_ECPRIVATEKEY                            146\n+# define EC_F_DO_EC_KEY_PRINT                             221\n+# define EC_F_ECDH_CMS_DECRYPT                            238\n+# define EC_F_ECDH_CMS_SET_SHARED_INFO                    239\n+# define EC_F_ECKEY_PARAM2TYPE                            223\n+# define EC_F_ECKEY_PARAM_DECODE                          212\n+# define EC_F_ECKEY_PRIV_DECODE                           213\n+# define EC_F_ECKEY_PRIV_ENCODE                           214\n+# define EC_F_ECKEY_PUB_DECODE                            215\n+# define EC_F_ECKEY_PUB_ENCODE                            216\n+# define EC_F_ECKEY_TYPE2PARAM                            220\n+# define EC_F_ECPARAMETERS_PRINT                          147\n+# define EC_F_ECPARAMETERS_PRINT_FP                       148\n+# define EC_F_ECPKPARAMETERS_PRINT                        149\n+# define EC_F_ECPKPARAMETERS_PRINT_FP                     150\n+# define EC_F_ECP_NISTZ256_GET_AFFINE                     240\n+# define EC_F_ECP_NISTZ256_MULT_PRECOMPUTE                243\n+# define EC_F_ECP_NISTZ256_POINTS_MUL                     241\n+# define EC_F_ECP_NISTZ256_PRE_COMP_NEW                   244\n+# define EC_F_ECP_NISTZ256_SET_WORDS                      245\n+# define EC_F_ECP_NISTZ256_WINDOWED_MUL                   242\n+# define EC_F_ECP_NIST_MOD_192                            203\n+# define EC_F_ECP_NIST_MOD_224                            204\n+# define EC_F_ECP_NIST_MOD_256                            205\n+# define EC_F_ECP_NIST_MOD_521                            206\n+# define EC_F_EC_ASN1_GROUP2CURVE                         153\n+# define EC_F_EC_ASN1_GROUP2FIELDID                       154\n+# define EC_F_EC_ASN1_GROUP2PARAMETERS                    155\n+# define EC_F_EC_ASN1_GROUP2PKPARAMETERS                  156\n+# define EC_F_EC_ASN1_PARAMETERS2GROUP                    157\n+# define EC_F_EC_ASN1_PKPARAMETERS2GROUP                  158\n+# define EC_F_EC_EX_DATA_SET_DATA                         211\n+# define EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY           208\n+# define EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT     159\n+# define EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE              195\n+# define EC_F_EC_GF2M_SIMPLE_OCT2POINT                    160\n+# define EC_F_EC_GF2M_SIMPLE_POINT2OCT                    161\n+# define EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES 162\n+# define EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES 163\n+# define EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES   164\n+# define EC_F_EC_GFP_MONT_FIELD_DECODE                    133\n+# define EC_F_EC_GFP_MONT_FIELD_ENCODE                    134\n+# define EC_F_EC_GFP_MONT_FIELD_MUL                       131\n+# define EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE                209\n+# define EC_F_EC_GFP_MONT_FIELD_SQR                       132\n+# define EC_F_EC_GFP_MONT_GROUP_SET_CURVE                 189\n+# define EC_F_EC_GFP_MONT_GROUP_SET_CURVE_GFP             135\n+# define EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE             225\n+# define EC_F_EC_GFP_NISTP224_POINTS_MUL                  228\n+# define EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES 226\n+# define EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE             230\n+# define EC_F_EC_GFP_NISTP256_POINTS_MUL                  231\n+# define EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES 232\n+# define EC_F_EC_GFP_NISTP521_GROUP_SET_CURVE             233\n+# define EC_F_EC_GFP_NISTP521_POINTS_MUL                  234\n+# define EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES 235\n+# define EC_F_EC_GFP_NIST_FIELD_MUL                       200\n+# define EC_F_EC_GFP_NIST_FIELD_SQR                       201\n+# define EC_F_EC_GFP_NIST_GROUP_SET_CURVE                 202\n+# define EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT      165\n+# define EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE               166\n+# define EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE_GFP           100\n+# define EC_F_EC_GFP_SIMPLE_GROUP_SET_GENERATOR           101\n+# define EC_F_EC_GFP_SIMPLE_MAKE_AFFINE                   102\n+# define EC_F_EC_GFP_SIMPLE_OCT2POINT                     103\n+# define EC_F_EC_GFP_SIMPLE_POINT2OCT                     104\n+# define EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE            137\n+# define EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES  167\n+# define EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES_GFP 105\n+# define EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES  168\n+# define EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES_GFP 128\n+# define EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES    169\n+# define EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES_GFP 129\n+# define EC_F_EC_GROUP_CHECK                              170\n+# define EC_F_EC_GROUP_CHECK_DISCRIMINANT                 171\n+# define EC_F_EC_GROUP_COPY                               106\n+# define EC_F_EC_GROUP_GET0_GENERATOR                     139\n+# define EC_F_EC_GROUP_GET_COFACTOR                       140\n+# define EC_F_EC_GROUP_GET_CURVE_GF2M                     172\n+# define EC_F_EC_GROUP_GET_CURVE_GFP                      130\n+# define EC_F_EC_GROUP_GET_DEGREE                         173\n+# define EC_F_EC_GROUP_GET_ORDER                          141\n+# define EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS              193\n+# define EC_F_EC_GROUP_GET_TRINOMIAL_BASIS                194\n+# define EC_F_EC_GROUP_NEW                                108\n+# define EC_F_EC_GROUP_NEW_BY_CURVE_NAME                  174\n+# define EC_F_EC_GROUP_NEW_FROM_DATA                      175\n+# define EC_F_EC_GROUP_PRECOMPUTE_MULT                    142\n+# define EC_F_EC_GROUP_SET_CURVE_GF2M                     176\n+# define EC_F_EC_GROUP_SET_CURVE_GFP                      109\n+# define EC_F_EC_GROUP_SET_EXTRA_DATA                     110\n+# define EC_F_EC_GROUP_SET_GENERATOR                      111\n+# define EC_F_EC_KEY_CHECK_KEY                            177\n+# define EC_F_EC_KEY_COPY                                 178\n+# define EC_F_EC_KEY_GENERATE_KEY                         179\n+# define EC_F_EC_KEY_NEW                                  182\n+# define EC_F_EC_KEY_PRINT                                180\n+# define EC_F_EC_KEY_PRINT_FP                             181\n+# define EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES    229\n+# define EC_F_EC_POINTS_MAKE_AFFINE                       136\n+# define EC_F_EC_POINT_ADD                                112\n+# define EC_F_EC_POINT_CMP                                113\n+# define EC_F_EC_POINT_COPY                               114\n+# define EC_F_EC_POINT_DBL                                115\n+# define EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M        183\n+# define EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP         116\n+# define EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP    117\n+# define EC_F_EC_POINT_INVERT                             210\n+# define EC_F_EC_POINT_IS_AT_INFINITY                     118\n+# define EC_F_EC_POINT_IS_ON_CURVE                        119\n+# define EC_F_EC_POINT_MAKE_AFFINE                        120\n+# define EC_F_EC_POINT_MUL                                184\n+# define EC_F_EC_POINT_NEW                                121\n+# define EC_F_EC_POINT_OCT2POINT                          122\n+# define EC_F_EC_POINT_POINT2OCT                          123\n+# define EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M        185\n+# define EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP         124\n+# define EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M    186\n+# define EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP     125\n+# define EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP    126\n+# define EC_F_EC_POINT_SET_TO_INFINITY                    127\n+# define EC_F_EC_PRE_COMP_DUP                             207\n+# define EC_F_EC_PRE_COMP_NEW                             196\n+# define EC_F_EC_WNAF_MUL                                 187\n+# define EC_F_EC_WNAF_PRECOMPUTE_MULT                     188\n+# define EC_F_I2D_ECPARAMETERS                            190\n+# define EC_F_I2D_ECPKPARAMETERS                          191\n+# define EC_F_I2D_ECPRIVATEKEY                            192\n+# define EC_F_I2O_ECPUBLICKEY                             151\n+# define EC_F_NISTP224_PRE_COMP_NEW                       227\n+# define EC_F_NISTP256_PRE_COMP_NEW                       236\n+# define EC_F_NISTP521_PRE_COMP_NEW                       237\n+# define EC_F_O2I_ECPUBLICKEY                             152\n+# define EC_F_OLD_EC_PRIV_DECODE                          222\n+# define EC_F_PKEY_EC_CTRL                                197\n+# define EC_F_PKEY_EC_CTRL_STR                            198\n+# define EC_F_PKEY_EC_DERIVE                              217\n+# define EC_F_PKEY_EC_KEYGEN                              199\n+# define EC_F_PKEY_EC_PARAMGEN                            219\n+# define EC_F_PKEY_EC_SIGN                                218\n+\n+/* Reason codes. */\n+# define EC_R_ASN1_ERROR                                  115\n+# define EC_R_ASN1_UNKNOWN_FIELD                          116\n+# define EC_R_BIGNUM_OUT_OF_RANGE                         144\n+# define EC_R_BUFFER_TOO_SMALL                            100\n+# define EC_R_COORDINATES_OUT_OF_RANGE                    146\n+# define EC_R_D2I_ECPKPARAMETERS_FAILURE                  117\n+# define EC_R_DECODE_ERROR                                142\n+# define EC_R_DISCRIMINANT_IS_ZERO                        118\n+# define EC_R_EC_GROUP_NEW_BY_NAME_FAILURE                119\n+# define EC_R_FIELD_TOO_LARGE                             143\n+# define EC_R_GF2M_NOT_SUPPORTED                          147\n+# define EC_R_GROUP2PKPARAMETERS_FAILURE                  120\n+# define EC_R_I2D_ECPKPARAMETERS_FAILURE                  121\n+# define EC_R_INCOMPATIBLE_OBJECTS                        101\n+# define EC_R_INVALID_ARGUMENT                            112\n+# define EC_R_INVALID_COMPRESSED_POINT                    110\n+# define EC_R_INVALID_COMPRESSION_BIT                     109\n+# define EC_R_INVALID_CURVE                               141\n+# define EC_R_INVALID_DIGEST                              151\n+# define EC_R_INVALID_DIGEST_TYPE                         138\n+# define EC_R_INVALID_ENCODING                            102\n+# define EC_R_INVALID_FIELD                               103\n+# define EC_R_INVALID_FORM                                104\n+# define EC_R_INVALID_GROUP_ORDER                         122\n+# define EC_R_INVALID_PENTANOMIAL_BASIS                   132\n+# define EC_R_INVALID_PRIVATE_KEY                         123\n+# define EC_R_INVALID_TRINOMIAL_BASIS                     137\n+# define EC_R_KDF_PARAMETER_ERROR                         148\n+# define EC_R_KEYS_NOT_SET                                140\n+# define EC_R_MISSING_PARAMETERS                          124\n+# define EC_R_MISSING_PRIVATE_KEY                         125\n+# define EC_R_NOT_A_NIST_PRIME                            135\n+# define EC_R_NOT_A_SUPPORTED_NIST_PRIME                  136\n+# define EC_R_NOT_IMPLEMENTED                             126\n+# define EC_R_NOT_INITIALIZED                             111\n+# define EC_R_NO_FIELD_MOD                                133\n+# define EC_R_NO_PARAMETERS_SET                           139\n+# define EC_R_PASSED_NULL_PARAMETER                       134\n+# define EC_R_PEER_KEY_ERROR                              149\n+# define EC_R_PKPARAMETERS2GROUP_FAILURE                  127\n+# define EC_R_POINT_AT_INFINITY                           106\n+# define EC_R_POINT_IS_NOT_ON_CURVE                       107\n+# define EC_R_SHARED_INFO_ERROR                           150\n+# define EC_R_SLOT_FULL                                   108\n+# define EC_R_UNDEFINED_GENERATOR                         113\n+# define EC_R_UNDEFINED_ORDER                             128\n+# define EC_R_UNKNOWN_GROUP                               129\n+# define EC_R_UNKNOWN_ORDER                               114\n+# define EC_R_UNSUPPORTED_FIELD                           131\n+# define EC_R_WRONG_CURVE_PARAMETERS                      145\n+# define EC_R_WRONG_ORDER                                 130\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "25348b30fe7cf48f9e5a4f1849f5ec960fff18b9",
            "filename": "deps/openssl/openssl/include/openssl/ecdh.h",
            "status": "added",
            "additions": 134,
            "deletions": 0,
            "changes": 134,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fecdh.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fecdh.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fecdh.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,134 @@\n+/* crypto/ecdh/ecdh.h */\n+/* ====================================================================\n+ * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\n+ *\n+ * The Elliptic Curve Public-Key Crypto Library (ECC Code) included\n+ * herein is developed by SUN MICROSYSTEMS, INC., and is contributed\n+ * to the OpenSSL project.\n+ *\n+ * The ECC Code is licensed pursuant to the OpenSSL open source\n+ * license provided below.\n+ *\n+ * The ECDH software is originally written by Douglas Stebila of\n+ * Sun Microsystems Laboratories.\n+ *\n+ */\n+/* ====================================================================\n+ * Copyright (c) 2000-2002 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+#ifndef HEADER_ECDH_H\n+# define HEADER_ECDH_H\n+\n+# include <openssl/opensslconf.h>\n+\n+# ifdef OPENSSL_NO_ECDH\n+#  error ECDH is disabled.\n+# endif\n+\n+# include <openssl/ec.h>\n+# include <openssl/ossl_typ.h>\n+# ifndef OPENSSL_NO_DEPRECATED\n+#  include <openssl/bn.h>\n+# endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# define EC_FLAG_COFACTOR_ECDH   0x1000\n+\n+const ECDH_METHOD *ECDH_OpenSSL(void);\n+\n+void ECDH_set_default_method(const ECDH_METHOD *);\n+const ECDH_METHOD *ECDH_get_default_method(void);\n+int ECDH_set_method(EC_KEY *, const ECDH_METHOD *);\n+\n+int ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key,\n+                     EC_KEY *ecdh, void *(*KDF) (const void *in, size_t inlen,\n+                                                 void *out, size_t *outlen));\n+\n+int ECDH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new\n+                          *new_func, CRYPTO_EX_dup *dup_func,\n+                          CRYPTO_EX_free *free_func);\n+int ECDH_set_ex_data(EC_KEY *d, int idx, void *arg);\n+void *ECDH_get_ex_data(EC_KEY *d, int idx);\n+\n+int ECDH_KDF_X9_62(unsigned char *out, size_t outlen,\n+                   const unsigned char *Z, size_t Zlen,\n+                   const unsigned char *sinfo, size_t sinfolen,\n+                   const EVP_MD *md);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_ECDH_strings(void);\n+\n+/* Error codes for the ECDH functions. */\n+\n+/* Function codes. */\n+# define ECDH_F_ECDH_CHECK                                102\n+# define ECDH_F_ECDH_COMPUTE_KEY                          100\n+# define ECDH_F_ECDH_DATA_NEW_METHOD                      101\n+\n+/* Reason codes. */\n+# define ECDH_R_KDF_FAILED                                102\n+# define ECDH_R_NON_FIPS_METHOD                           103\n+# define ECDH_R_NO_PRIVATE_VALUE                          100\n+# define ECDH_R_POINT_ARITHMETIC_FAILURE                  101\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "a6f0930f829ccc0530af159fab3134c943954517",
            "filename": "deps/openssl/openssl/include/openssl/ecdsa.h",
            "status": "added",
            "additions": 335,
            "deletions": 0,
            "changes": 335,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fecdsa.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fecdsa.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fecdsa.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,335 @@\n+/* crypto/ecdsa/ecdsa.h */\n+/**\n+ * \\file   crypto/ecdsa/ecdsa.h Include file for the OpenSSL ECDSA functions\n+ * \\author Written by Nils Larsch for the OpenSSL project\n+ */\n+/* ====================================================================\n+ * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+#ifndef HEADER_ECDSA_H\n+# define HEADER_ECDSA_H\n+\n+# include <openssl/opensslconf.h>\n+\n+# ifdef OPENSSL_NO_ECDSA\n+#  error ECDSA is disabled.\n+# endif\n+\n+# include <openssl/ec.h>\n+# include <openssl/ossl_typ.h>\n+# ifndef OPENSSL_NO_DEPRECATED\n+#  include <openssl/bn.h>\n+# endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct ECDSA_SIG_st {\n+    BIGNUM *r;\n+    BIGNUM *s;\n+} ECDSA_SIG;\n+\n+/** Allocates and initialize a ECDSA_SIG structure\n+ *  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred\n+ */\n+ECDSA_SIG *ECDSA_SIG_new(void);\n+\n+/** frees a ECDSA_SIG structure\n+ *  \\param  sig  pointer to the ECDSA_SIG structure\n+ */\n+void ECDSA_SIG_free(ECDSA_SIG *sig);\n+\n+/** DER encode content of ECDSA_SIG object (note: this function modifies *pp\n+ *  (*pp += length of the DER encoded signature)).\n+ *  \\param  sig  pointer to the ECDSA_SIG object\n+ *  \\param  pp   pointer to a unsigned char pointer for the output or NULL\n+ *  \\return the length of the DER encoded ECDSA_SIG object or 0\n+ */\n+int i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);\n+\n+/** Decodes a DER encoded ECDSA signature (note: this function changes *pp\n+ *  (*pp += len)).\n+ *  \\param  sig  pointer to ECDSA_SIG pointer (may be NULL)\n+ *  \\param  pp   memory buffer with the DER encoded signature\n+ *  \\param  len  length of the buffer\n+ *  \\return pointer to the decoded ECDSA_SIG structure (or NULL)\n+ */\n+ECDSA_SIG *d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, long len);\n+\n+/** Computes the ECDSA signature of the given hash value using\n+ *  the supplied private key and returns the created signature.\n+ *  \\param  dgst      pointer to the hash value\n+ *  \\param  dgst_len  length of the hash value\n+ *  \\param  eckey     EC_KEY object containing a private EC key\n+ *  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred\n+ */\n+ECDSA_SIG *ECDSA_do_sign(const unsigned char *dgst, int dgst_len,\n+                         EC_KEY *eckey);\n+\n+/** Computes ECDSA signature of a given hash value using the supplied\n+ *  private key (note: sig must point to ECDSA_size(eckey) bytes of memory).\n+ *  \\param  dgst     pointer to the hash value to sign\n+ *  \\param  dgstlen  length of the hash value\n+ *  \\param  kinv     BIGNUM with a pre-computed inverse k (optional)\n+ *  \\param  rp       BIGNUM with a pre-computed rp value (optioanl),\n+ *                   see ECDSA_sign_setup\n+ *  \\param  eckey    EC_KEY object containing a private EC key\n+ *  \\return pointer to a ECDSA_SIG structure or NULL if an error occurred\n+ */\n+ECDSA_SIG *ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen,\n+                            const BIGNUM *kinv, const BIGNUM *rp,\n+                            EC_KEY *eckey);\n+\n+/** Verifies that the supplied signature is a valid ECDSA\n+ *  signature of the supplied hash value using the supplied public key.\n+ *  \\param  dgst      pointer to the hash value\n+ *  \\param  dgst_len  length of the hash value\n+ *  \\param  sig       ECDSA_SIG structure\n+ *  \\param  eckey     EC_KEY object containing a public EC key\n+ *  \\return 1 if the signature is valid, 0 if the signature is invalid\n+ *          and -1 on error\n+ */\n+int ECDSA_do_verify(const unsigned char *dgst, int dgst_len,\n+                    const ECDSA_SIG *sig, EC_KEY *eckey);\n+\n+const ECDSA_METHOD *ECDSA_OpenSSL(void);\n+\n+/** Sets the default ECDSA method\n+ *  \\param  meth  new default ECDSA_METHOD\n+ */\n+void ECDSA_set_default_method(const ECDSA_METHOD *meth);\n+\n+/** Returns the default ECDSA method\n+ *  \\return pointer to ECDSA_METHOD structure containing the default method\n+ */\n+const ECDSA_METHOD *ECDSA_get_default_method(void);\n+\n+/** Sets method to be used for the ECDSA operations\n+ *  \\param  eckey  EC_KEY object\n+ *  \\param  meth   new method\n+ *  \\return 1 on success and 0 otherwise\n+ */\n+int ECDSA_set_method(EC_KEY *eckey, const ECDSA_METHOD *meth);\n+\n+/** Returns the maximum length of the DER encoded signature\n+ *  \\param  eckey  EC_KEY object\n+ *  \\return numbers of bytes required for the DER encoded signature\n+ */\n+int ECDSA_size(const EC_KEY *eckey);\n+\n+/** Precompute parts of the signing operation\n+ *  \\param  eckey  EC_KEY object containing a private EC key\n+ *  \\param  ctx    BN_CTX object (optional)\n+ *  \\param  kinv   BIGNUM pointer for the inverse of k\n+ *  \\param  rp     BIGNUM pointer for x coordinate of k * generator\n+ *  \\return 1 on success and 0 otherwise\n+ */\n+int ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, BIGNUM **rp);\n+\n+/** Computes ECDSA signature of a given hash value using the supplied\n+ *  private key (note: sig must point to ECDSA_size(eckey) bytes of memory).\n+ *  \\param  type     this parameter is ignored\n+ *  \\param  dgst     pointer to the hash value to sign\n+ *  \\param  dgstlen  length of the hash value\n+ *  \\param  sig      memory for the DER encoded created signature\n+ *  \\param  siglen   pointer to the length of the returned signature\n+ *  \\param  eckey    EC_KEY object containing a private EC key\n+ *  \\return 1 on success and 0 otherwise\n+ */\n+int ECDSA_sign(int type, const unsigned char *dgst, int dgstlen,\n+               unsigned char *sig, unsigned int *siglen, EC_KEY *eckey);\n+\n+/** Computes ECDSA signature of a given hash value using the supplied\n+ *  private key (note: sig must point to ECDSA_size(eckey) bytes of memory).\n+ *  \\param  type     this parameter is ignored\n+ *  \\param  dgst     pointer to the hash value to sign\n+ *  \\param  dgstlen  length of the hash value\n+ *  \\param  sig      buffer to hold the DER encoded signature\n+ *  \\param  siglen   pointer to the length of the returned signature\n+ *  \\param  kinv     BIGNUM with a pre-computed inverse k (optional)\n+ *  \\param  rp       BIGNUM with a pre-computed rp value (optioanl),\n+ *                   see ECDSA_sign_setup\n+ *  \\param  eckey    EC_KEY object containing a private EC key\n+ *  \\return 1 on success and 0 otherwise\n+ */\n+int ECDSA_sign_ex(int type, const unsigned char *dgst, int dgstlen,\n+                  unsigned char *sig, unsigned int *siglen,\n+                  const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *eckey);\n+\n+/** Verifies that the given signature is valid ECDSA signature\n+ *  of the supplied hash value using the specified public key.\n+ *  \\param  type     this parameter is ignored\n+ *  \\param  dgst     pointer to the hash value\n+ *  \\param  dgstlen  length of the hash value\n+ *  \\param  sig      pointer to the DER encoded signature\n+ *  \\param  siglen   length of the DER encoded signature\n+ *  \\param  eckey    EC_KEY object containing a public EC key\n+ *  \\return 1 if the signature is valid, 0 if the signature is invalid\n+ *          and -1 on error\n+ */\n+int ECDSA_verify(int type, const unsigned char *dgst, int dgstlen,\n+                 const unsigned char *sig, int siglen, EC_KEY *eckey);\n+\n+/* the standard ex_data functions */\n+int ECDSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new\n+                           *new_func, CRYPTO_EX_dup *dup_func,\n+                           CRYPTO_EX_free *free_func);\n+int ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg);\n+void *ECDSA_get_ex_data(EC_KEY *d, int idx);\n+\n+/** Allocates and initialize a ECDSA_METHOD structure\n+ *  \\param ecdsa_method pointer to ECDSA_METHOD to copy.  (May be NULL)\n+ *  \\return pointer to a ECDSA_METHOD structure or NULL if an error occurred\n+ */\n+\n+ECDSA_METHOD *ECDSA_METHOD_new(const ECDSA_METHOD *ecdsa_method);\n+\n+/** frees a ECDSA_METHOD structure\n+ *  \\param  ecdsa_method  pointer to the ECDSA_METHOD structure\n+ */\n+void ECDSA_METHOD_free(ECDSA_METHOD *ecdsa_method);\n+\n+/**  Sets application specific data in the ECDSA_METHOD\n+ *   \\param  ecdsa_method pointer to existing ECDSA_METHOD\n+ *   \\param  app application specific data to set\n+ */\n+\n+void ECDSA_METHOD_set_app_data(ECDSA_METHOD *ecdsa_method, void *app);\n+\n+/** Returns application specific data from a ECDSA_METHOD structure\n+ *  \\param ecdsa_method pointer to ECDSA_METHOD structure\n+ *  \\return pointer to application specific data.\n+ */\n+\n+void *ECDSA_METHOD_get_app_data(ECDSA_METHOD *ecdsa_method);\n+\n+/**  Set the ECDSA_do_sign function in the ECDSA_METHOD\n+ *   \\param  ecdsa_method  pointer to existing ECDSA_METHOD\n+ *   \\param  ecdsa_do_sign a funtion of type ECDSA_do_sign\n+ */\n+\n+void ECDSA_METHOD_set_sign(ECDSA_METHOD *ecdsa_method,\n+                           ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char\n+                                                        *dgst, int dgst_len,\n+                                                        const BIGNUM *inv,\n+                                                        const BIGNUM *rp,\n+                                                        EC_KEY *eckey));\n+\n+/**  Set the  ECDSA_sign_setup function in the ECDSA_METHOD\n+ *   \\param  ecdsa_method  pointer to existing ECDSA_METHOD\n+ *   \\param  ecdsa_sign_setup a funtion of type ECDSA_sign_setup\n+ */\n+\n+void ECDSA_METHOD_set_sign_setup(ECDSA_METHOD *ecdsa_method,\n+                                 int (*ecdsa_sign_setup) (EC_KEY *eckey,\n+                                                          BN_CTX *ctx,\n+                                                          BIGNUM **kinv,\n+                                                          BIGNUM **r));\n+\n+/**  Set the ECDSA_do_verify function in the ECDSA_METHOD\n+ *   \\param  ecdsa_method  pointer to existing ECDSA_METHOD\n+ *   \\param  ecdsa_do_verify a funtion of type ECDSA_do_verify\n+ */\n+\n+void ECDSA_METHOD_set_verify(ECDSA_METHOD *ecdsa_method,\n+                             int (*ecdsa_do_verify) (const unsigned char\n+                                                     *dgst, int dgst_len,\n+                                                     const ECDSA_SIG *sig,\n+                                                     EC_KEY *eckey));\n+\n+void ECDSA_METHOD_set_flags(ECDSA_METHOD *ecdsa_method, int flags);\n+\n+/**  Set the flags field in the ECDSA_METHOD\n+ *   \\param  ecdsa_method  pointer to existing ECDSA_METHOD\n+ *   \\param  flags flags value to set\n+ */\n+\n+void ECDSA_METHOD_set_name(ECDSA_METHOD *ecdsa_method, char *name);\n+\n+/**  Set the name field in the ECDSA_METHOD\n+ *   \\param  ecdsa_method  pointer to existing ECDSA_METHOD\n+ *   \\param  name name to set\n+ */\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_ECDSA_strings(void);\n+\n+/* Error codes for the ECDSA functions. */\n+\n+/* Function codes. */\n+# define ECDSA_F_ECDSA_CHECK                              104\n+# define ECDSA_F_ECDSA_DATA_NEW_METHOD                    100\n+# define ECDSA_F_ECDSA_DO_SIGN                            101\n+# define ECDSA_F_ECDSA_DO_VERIFY                          102\n+# define ECDSA_F_ECDSA_METHOD_NEW                         105\n+# define ECDSA_F_ECDSA_SIGN_SETUP                         103\n+\n+/* Reason codes. */\n+# define ECDSA_R_BAD_SIGNATURE                            100\n+# define ECDSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE              101\n+# define ECDSA_R_ERR_EC_LIB                               102\n+# define ECDSA_R_MISSING_PARAMETERS                       103\n+# define ECDSA_R_NEED_NEW_SETUP_VALUES                    106\n+# define ECDSA_R_NON_FIPS_METHOD                          107\n+# define ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED          104\n+# define ECDSA_R_SIGNATURE_MALLOC_FAILED                  105\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "bd7b591447dd427131e2783ab8350cd0225a1cb4",
            "filename": "deps/openssl/openssl/include/openssl/engine.h",
            "status": "added",
            "additions": 960,
            "deletions": 0,
            "changes": 960,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fengine.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fengine.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fengine.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,960 @@\n+/* openssl/engine.h */\n+/*\n+ * Written by Geoff Thorpe (geoff@geoffthorpe.net) for the OpenSSL project\n+ * 2000.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+/* ====================================================================\n+ * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.\n+ * ECDH support in OpenSSL originally developed by\n+ * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.\n+ */\n+\n+#ifndef HEADER_ENGINE_H\n+# define HEADER_ENGINE_H\n+\n+# include <openssl/opensslconf.h>\n+\n+# ifdef OPENSSL_NO_ENGINE\n+#  error ENGINE is disabled.\n+# endif\n+\n+# ifndef OPENSSL_NO_DEPRECATED\n+#  include <openssl/bn.h>\n+#  ifndef OPENSSL_NO_RSA\n+#   include <openssl/rsa.h>\n+#  endif\n+#  ifndef OPENSSL_NO_DSA\n+#   include <openssl/dsa.h>\n+#  endif\n+#  ifndef OPENSSL_NO_DH\n+#   include <openssl/dh.h>\n+#  endif\n+#  ifndef OPENSSL_NO_ECDH\n+#   include <openssl/ecdh.h>\n+#  endif\n+#  ifndef OPENSSL_NO_ECDSA\n+#   include <openssl/ecdsa.h>\n+#  endif\n+#  include <openssl/rand.h>\n+#  include <openssl/ui.h>\n+#  include <openssl/err.h>\n+# endif\n+\n+# include <openssl/ossl_typ.h>\n+# include <openssl/symhacks.h>\n+\n+# include <openssl/x509.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+ * These flags are used to control combinations of algorithm (methods) by\n+ * bitwise \"OR\"ing.\n+ */\n+# define ENGINE_METHOD_RSA               (unsigned int)0x0001\n+# define ENGINE_METHOD_DSA               (unsigned int)0x0002\n+# define ENGINE_METHOD_DH                (unsigned int)0x0004\n+# define ENGINE_METHOD_RAND              (unsigned int)0x0008\n+# define ENGINE_METHOD_ECDH              (unsigned int)0x0010\n+# define ENGINE_METHOD_ECDSA             (unsigned int)0x0020\n+# define ENGINE_METHOD_CIPHERS           (unsigned int)0x0040\n+# define ENGINE_METHOD_DIGESTS           (unsigned int)0x0080\n+# define ENGINE_METHOD_STORE             (unsigned int)0x0100\n+# define ENGINE_METHOD_PKEY_METHS        (unsigned int)0x0200\n+# define ENGINE_METHOD_PKEY_ASN1_METHS   (unsigned int)0x0400\n+/* Obvious all-or-nothing cases. */\n+# define ENGINE_METHOD_ALL               (unsigned int)0xFFFF\n+# define ENGINE_METHOD_NONE              (unsigned int)0x0000\n+\n+/*\n+ * This(ese) flag(s) controls behaviour of the ENGINE_TABLE mechanism used\n+ * internally to control registration of ENGINE implementations, and can be\n+ * set by ENGINE_set_table_flags(). The \"NOINIT\" flag prevents attempts to\n+ * initialise registered ENGINEs if they are not already initialised.\n+ */\n+# define ENGINE_TABLE_FLAG_NOINIT        (unsigned int)0x0001\n+\n+/* ENGINE flags that can be set by ENGINE_set_flags(). */\n+/* Not used */\n+/* #define ENGINE_FLAGS_MALLOCED        0x0001 */\n+\n+/*\n+ * This flag is for ENGINEs that wish to handle the various 'CMD'-related\n+ * control commands on their own. Without this flag, ENGINE_ctrl() handles\n+ * these control commands on behalf of the ENGINE using their \"cmd_defns\"\n+ * data.\n+ */\n+# define ENGINE_FLAGS_MANUAL_CMD_CTRL    (int)0x0002\n+\n+/*\n+ * This flag is for ENGINEs who return new duplicate structures when found\n+ * via \"ENGINE_by_id()\". When an ENGINE must store state (eg. if\n+ * ENGINE_ctrl() commands are called in sequence as part of some stateful\n+ * process like key-generation setup and execution), it can set this flag -\n+ * then each attempt to obtain the ENGINE will result in it being copied into\n+ * a new structure. Normally, ENGINEs don't declare this flag so\n+ * ENGINE_by_id() just increments the existing ENGINE's structural reference\n+ * count.\n+ */\n+# define ENGINE_FLAGS_BY_ID_COPY         (int)0x0004\n+\n+/*\n+ * This flag if for an ENGINE that does not want its methods registered as\n+ * part of ENGINE_register_all_complete() for example if the methods are not\n+ * usable as default methods.\n+ */\n+\n+# define ENGINE_FLAGS_NO_REGISTER_ALL    (int)0x0008\n+\n+/*\n+ * ENGINEs can support their own command types, and these flags are used in\n+ * ENGINE_CTRL_GET_CMD_FLAGS to indicate to the caller what kind of input\n+ * each command expects. Currently only numeric and string input is\n+ * supported. If a control command supports none of the _NUMERIC, _STRING, or\n+ * _NO_INPUT options, then it is regarded as an \"internal\" control command -\n+ * and not for use in config setting situations. As such, they're not\n+ * available to the ENGINE_ctrl_cmd_string() function, only raw ENGINE_ctrl()\n+ * access. Changes to this list of 'command types' should be reflected\n+ * carefully in ENGINE_cmd_is_executable() and ENGINE_ctrl_cmd_string().\n+ */\n+\n+/* accepts a 'long' input value (3rd parameter to ENGINE_ctrl) */\n+# define ENGINE_CMD_FLAG_NUMERIC         (unsigned int)0x0001\n+/*\n+ * accepts string input (cast from 'void*' to 'const char *', 4th parameter\n+ * to ENGINE_ctrl)\n+ */\n+# define ENGINE_CMD_FLAG_STRING          (unsigned int)0x0002\n+/*\n+ * Indicates that the control command takes *no* input. Ie. the control\n+ * command is unparameterised.\n+ */\n+# define ENGINE_CMD_FLAG_NO_INPUT        (unsigned int)0x0004\n+/*\n+ * Indicates that the control command is internal. This control command won't\n+ * be shown in any output, and is only usable through the ENGINE_ctrl_cmd()\n+ * function.\n+ */\n+# define ENGINE_CMD_FLAG_INTERNAL        (unsigned int)0x0008\n+\n+/*\n+ * NB: These 3 control commands are deprecated and should not be used.\n+ * ENGINEs relying on these commands should compile conditional support for\n+ * compatibility (eg. if these symbols are defined) but should also migrate\n+ * the same functionality to their own ENGINE-specific control functions that\n+ * can be \"discovered\" by calling applications. The fact these control\n+ * commands wouldn't be \"executable\" (ie. usable by text-based config)\n+ * doesn't change the fact that application code can find and use them\n+ * without requiring per-ENGINE hacking.\n+ */\n+\n+/*\n+ * These flags are used to tell the ctrl function what should be done. All\n+ * command numbers are shared between all engines, even if some don't make\n+ * sense to some engines.  In such a case, they do nothing but return the\n+ * error ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED.\n+ */\n+# define ENGINE_CTRL_SET_LOGSTREAM               1\n+# define ENGINE_CTRL_SET_PASSWORD_CALLBACK       2\n+# define ENGINE_CTRL_HUP                         3/* Close and reinitialise\n+                                                   * any handles/connections\n+                                                   * etc. */\n+# define ENGINE_CTRL_SET_USER_INTERFACE          4/* Alternative to callback */\n+# define ENGINE_CTRL_SET_CALLBACK_DATA           5/* User-specific data, used\n+                                                   * when calling the password\n+                                                   * callback and the user\n+                                                   * interface */\n+# define ENGINE_CTRL_LOAD_CONFIGURATION          6/* Load a configuration,\n+                                                   * given a string that\n+                                                   * represents a file name\n+                                                   * or so */\n+# define ENGINE_CTRL_LOAD_SECTION                7/* Load data from a given\n+                                                   * section in the already\n+                                                   * loaded configuration */\n+\n+/*\n+ * These control commands allow an application to deal with an arbitrary\n+ * engine in a dynamic way. Warn: Negative return values indicate errors FOR\n+ * THESE COMMANDS because zero is used to indicate 'end-of-list'. Other\n+ * commands, including ENGINE-specific command types, return zero for an\n+ * error. An ENGINE can choose to implement these ctrl functions, and can\n+ * internally manage things however it chooses - it does so by setting the\n+ * ENGINE_FLAGS_MANUAL_CMD_CTRL flag (using ENGINE_set_flags()). Otherwise\n+ * the ENGINE_ctrl() code handles this on the ENGINE's behalf using the\n+ * cmd_defns data (set using ENGINE_set_cmd_defns()). This means an ENGINE's\n+ * ctrl() handler need only implement its own commands - the above \"meta\"\n+ * commands will be taken care of.\n+ */\n+\n+/*\n+ * Returns non-zero if the supplied ENGINE has a ctrl() handler. If \"not\",\n+ * then all the remaining control commands will return failure, so it is\n+ * worth checking this first if the caller is trying to \"discover\" the\n+ * engine's capabilities and doesn't want errors generated unnecessarily.\n+ */\n+# define ENGINE_CTRL_HAS_CTRL_FUNCTION           10\n+/*\n+ * Returns a positive command number for the first command supported by the\n+ * engine. Returns zero if no ctrl commands are supported.\n+ */\n+# define ENGINE_CTRL_GET_FIRST_CMD_TYPE          11\n+/*\n+ * The 'long' argument specifies a command implemented by the engine, and the\n+ * return value is the next command supported, or zero if there are no more.\n+ */\n+# define ENGINE_CTRL_GET_NEXT_CMD_TYPE           12\n+/*\n+ * The 'void*' argument is a command name (cast from 'const char *'), and the\n+ * return value is the command that corresponds to it.\n+ */\n+# define ENGINE_CTRL_GET_CMD_FROM_NAME           13\n+/*\n+ * The next two allow a command to be converted into its corresponding string\n+ * form. In each case, the 'long' argument supplies the command. In the\n+ * NAME_LEN case, the return value is the length of the command name (not\n+ * counting a trailing EOL). In the NAME case, the 'void*' argument must be a\n+ * string buffer large enough, and it will be populated with the name of the\n+ * command (WITH a trailing EOL).\n+ */\n+# define ENGINE_CTRL_GET_NAME_LEN_FROM_CMD       14\n+# define ENGINE_CTRL_GET_NAME_FROM_CMD           15\n+/* The next two are similar but give a \"short description\" of a command. */\n+# define ENGINE_CTRL_GET_DESC_LEN_FROM_CMD       16\n+# define ENGINE_CTRL_GET_DESC_FROM_CMD           17\n+/*\n+ * With this command, the return value is the OR'd combination of\n+ * ENGINE_CMD_FLAG_*** values that indicate what kind of input a given\n+ * engine-specific ctrl command expects.\n+ */\n+# define ENGINE_CTRL_GET_CMD_FLAGS               18\n+\n+/*\n+ * ENGINE implementations should start the numbering of their own control\n+ * commands from this value. (ie. ENGINE_CMD_BASE, ENGINE_CMD_BASE + 1, etc).\n+ */\n+# define ENGINE_CMD_BASE                         200\n+\n+/*\n+ * NB: These 2 nCipher \"chil\" control commands are deprecated, and their\n+ * functionality is now available through ENGINE-specific control commands\n+ * (exposed through the above-mentioned 'CMD'-handling). Code using these 2\n+ * commands should be migrated to the more general command handling before\n+ * these are removed.\n+ */\n+\n+/* Flags specific to the nCipher \"chil\" engine */\n+# define ENGINE_CTRL_CHIL_SET_FORKCHECK          100\n+        /*\n+         * Depending on the value of the (long)i argument, this sets or\n+         * unsets the SimpleForkCheck flag in the CHIL API to enable or\n+         * disable checking and workarounds for applications that fork().\n+         */\n+# define ENGINE_CTRL_CHIL_NO_LOCKING             101\n+        /*\n+         * This prevents the initialisation function from providing mutex\n+         * callbacks to the nCipher library.\n+         */\n+\n+/*\n+ * If an ENGINE supports its own specific control commands and wishes the\n+ * framework to handle the above 'ENGINE_CMD_***'-manipulation commands on\n+ * its behalf, it should supply a null-terminated array of ENGINE_CMD_DEFN\n+ * entries to ENGINE_set_cmd_defns(). It should also implement a ctrl()\n+ * handler that supports the stated commands (ie. the \"cmd_num\" entries as\n+ * described by the array). NB: The array must be ordered in increasing order\n+ * of cmd_num. \"null-terminated\" means that the last ENGINE_CMD_DEFN element\n+ * has cmd_num set to zero and/or cmd_name set to NULL.\n+ */\n+typedef struct ENGINE_CMD_DEFN_st {\n+    unsigned int cmd_num;       /* The command number */\n+    const char *cmd_name;       /* The command name itself */\n+    const char *cmd_desc;       /* A short description of the command */\n+    unsigned int cmd_flags;     /* The input the command expects */\n+} ENGINE_CMD_DEFN;\n+\n+/* Generic function pointer */\n+typedef int (*ENGINE_GEN_FUNC_PTR) (void);\n+/* Generic function pointer taking no arguments */\n+typedef int (*ENGINE_GEN_INT_FUNC_PTR) (ENGINE *);\n+/* Specific control function pointer */\n+typedef int (*ENGINE_CTRL_FUNC_PTR) (ENGINE *, int, long, void *,\n+                                     void (*f) (void));\n+/* Generic load_key function pointer */\n+typedef EVP_PKEY *(*ENGINE_LOAD_KEY_PTR)(ENGINE *, const char *,\n+                                         UI_METHOD *ui_method,\n+                                         void *callback_data);\n+typedef int (*ENGINE_SSL_CLIENT_CERT_PTR) (ENGINE *, SSL *ssl,\n+                                           STACK_OF(X509_NAME) *ca_dn,\n+                                           X509 **pcert, EVP_PKEY **pkey,\n+                                           STACK_OF(X509) **pother,\n+                                           UI_METHOD *ui_method,\n+                                           void *callback_data);\n+/*-\n+ * These callback types are for an ENGINE's handler for cipher and digest logic.\n+ * These handlers have these prototypes;\n+ *   int foo(ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid);\n+ *   int foo(ENGINE *e, const EVP_MD **digest, const int **nids, int nid);\n+ * Looking at how to implement these handlers in the case of cipher support, if\n+ * the framework wants the EVP_CIPHER for 'nid', it will call;\n+ *   foo(e, &p_evp_cipher, NULL, nid);    (return zero for failure)\n+ * If the framework wants a list of supported 'nid's, it will call;\n+ *   foo(e, NULL, &p_nids, 0); (returns number of 'nids' or -1 for error)\n+ */\n+/*\n+ * Returns to a pointer to the array of supported cipher 'nid's. If the\n+ * second parameter is non-NULL it is set to the size of the returned array.\n+ */\n+typedef int (*ENGINE_CIPHERS_PTR) (ENGINE *, const EVP_CIPHER **,\n+                                   const int **, int);\n+typedef int (*ENGINE_DIGESTS_PTR) (ENGINE *, const EVP_MD **, const int **,\n+                                   int);\n+typedef int (*ENGINE_PKEY_METHS_PTR) (ENGINE *, EVP_PKEY_METHOD **,\n+                                      const int **, int);\n+typedef int (*ENGINE_PKEY_ASN1_METHS_PTR) (ENGINE *, EVP_PKEY_ASN1_METHOD **,\n+                                           const int **, int);\n+/*\n+ * STRUCTURE functions ... all of these functions deal with pointers to\n+ * ENGINE structures where the pointers have a \"structural reference\". This\n+ * means that their reference is to allowed access to the structure but it\n+ * does not imply that the structure is functional. To simply increment or\n+ * decrement the structural reference count, use ENGINE_by_id and\n+ * ENGINE_free. NB: This is not required when iterating using ENGINE_get_next\n+ * as it will automatically decrement the structural reference count of the\n+ * \"current\" ENGINE and increment the structural reference count of the\n+ * ENGINE it returns (unless it is NULL).\n+ */\n+\n+/* Get the first/last \"ENGINE\" type available. */\n+ENGINE *ENGINE_get_first(void);\n+ENGINE *ENGINE_get_last(void);\n+/* Iterate to the next/previous \"ENGINE\" type (NULL = end of the list). */\n+ENGINE *ENGINE_get_next(ENGINE *e);\n+ENGINE *ENGINE_get_prev(ENGINE *e);\n+/* Add another \"ENGINE\" type into the array. */\n+int ENGINE_add(ENGINE *e);\n+/* Remove an existing \"ENGINE\" type from the array. */\n+int ENGINE_remove(ENGINE *e);\n+/* Retrieve an engine from the list by its unique \"id\" value. */\n+ENGINE *ENGINE_by_id(const char *id);\n+/* Add all the built-in engines. */\n+void ENGINE_load_openssl(void);\n+void ENGINE_load_dynamic(void);\n+# ifndef OPENSSL_NO_STATIC_ENGINE\n+void ENGINE_load_4758cca(void);\n+void ENGINE_load_aep(void);\n+void ENGINE_load_atalla(void);\n+void ENGINE_load_chil(void);\n+void ENGINE_load_cswift(void);\n+void ENGINE_load_nuron(void);\n+void ENGINE_load_sureware(void);\n+void ENGINE_load_ubsec(void);\n+void ENGINE_load_padlock(void);\n+void ENGINE_load_capi(void);\n+#  ifndef OPENSSL_NO_GMP\n+void ENGINE_load_gmp(void);\n+#  endif\n+#  ifndef OPENSSL_NO_GOST\n+void ENGINE_load_gost(void);\n+#  endif\n+# endif\n+void ENGINE_load_cryptodev(void);\n+void ENGINE_load_rdrand(void);\n+void ENGINE_load_builtin_engines(void);\n+\n+/*\n+ * Get and set global flags (ENGINE_TABLE_FLAG_***) for the implementation\n+ * \"registry\" handling.\n+ */\n+unsigned int ENGINE_get_table_flags(void);\n+void ENGINE_set_table_flags(unsigned int flags);\n+\n+/*- Manage registration of ENGINEs per \"table\". For each type, there are 3\n+ * functions;\n+ *   ENGINE_register_***(e) - registers the implementation from 'e' (if it has one)\n+ *   ENGINE_unregister_***(e) - unregister the implementation from 'e'\n+ *   ENGINE_register_all_***() - call ENGINE_register_***() for each 'e' in the list\n+ * Cleanup is automatically registered from each table when required, so\n+ * ENGINE_cleanup() will reverse any \"register\" operations.\n+ */\n+\n+int ENGINE_register_RSA(ENGINE *e);\n+void ENGINE_unregister_RSA(ENGINE *e);\n+void ENGINE_register_all_RSA(void);\n+\n+int ENGINE_register_DSA(ENGINE *e);\n+void ENGINE_unregister_DSA(ENGINE *e);\n+void ENGINE_register_all_DSA(void);\n+\n+int ENGINE_register_ECDH(ENGINE *e);\n+void ENGINE_unregister_ECDH(ENGINE *e);\n+void ENGINE_register_all_ECDH(void);\n+\n+int ENGINE_register_ECDSA(ENGINE *e);\n+void ENGINE_unregister_ECDSA(ENGINE *e);\n+void ENGINE_register_all_ECDSA(void);\n+\n+int ENGINE_register_DH(ENGINE *e);\n+void ENGINE_unregister_DH(ENGINE *e);\n+void ENGINE_register_all_DH(void);\n+\n+int ENGINE_register_RAND(ENGINE *e);\n+void ENGINE_unregister_RAND(ENGINE *e);\n+void ENGINE_register_all_RAND(void);\n+\n+int ENGINE_register_STORE(ENGINE *e);\n+void ENGINE_unregister_STORE(ENGINE *e);\n+void ENGINE_register_all_STORE(void);\n+\n+int ENGINE_register_ciphers(ENGINE *e);\n+void ENGINE_unregister_ciphers(ENGINE *e);\n+void ENGINE_register_all_ciphers(void);\n+\n+int ENGINE_register_digests(ENGINE *e);\n+void ENGINE_unregister_digests(ENGINE *e);\n+void ENGINE_register_all_digests(void);\n+\n+int ENGINE_register_pkey_meths(ENGINE *e);\n+void ENGINE_unregister_pkey_meths(ENGINE *e);\n+void ENGINE_register_all_pkey_meths(void);\n+\n+int ENGINE_register_pkey_asn1_meths(ENGINE *e);\n+void ENGINE_unregister_pkey_asn1_meths(ENGINE *e);\n+void ENGINE_register_all_pkey_asn1_meths(void);\n+\n+/*\n+ * These functions register all support from the above categories. Note, use\n+ * of these functions can result in static linkage of code your application\n+ * may not need. If you only need a subset of functionality, consider using\n+ * more selective initialisation.\n+ */\n+int ENGINE_register_complete(ENGINE *e);\n+int ENGINE_register_all_complete(void);\n+\n+/*\n+ * Send parametrised control commands to the engine. The possibilities to\n+ * send down an integer, a pointer to data or a function pointer are\n+ * provided. Any of the parameters may or may not be NULL, depending on the\n+ * command number. In actuality, this function only requires a structural\n+ * (rather than functional) reference to an engine, but many control commands\n+ * may require the engine be functional. The caller should be aware of trying\n+ * commands that require an operational ENGINE, and only use functional\n+ * references in such situations.\n+ */\n+int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void));\n+\n+/*\n+ * This function tests if an ENGINE-specific command is usable as a\n+ * \"setting\". Eg. in an application's config file that gets processed through\n+ * ENGINE_ctrl_cmd_string(). If this returns zero, it is not available to\n+ * ENGINE_ctrl_cmd_string(), only ENGINE_ctrl().\n+ */\n+int ENGINE_cmd_is_executable(ENGINE *e, int cmd);\n+\n+/*\n+ * This function works like ENGINE_ctrl() with the exception of taking a\n+ * command name instead of a command number, and can handle optional\n+ * commands. See the comment on ENGINE_ctrl_cmd_string() for an explanation\n+ * on how to use the cmd_name and cmd_optional.\n+ */\n+int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,\n+                    long i, void *p, void (*f) (void), int cmd_optional);\n+\n+/*\n+ * This function passes a command-name and argument to an ENGINE. The\n+ * cmd_name is converted to a command number and the control command is\n+ * called using 'arg' as an argument (unless the ENGINE doesn't support such\n+ * a command, in which case no control command is called). The command is\n+ * checked for input flags, and if necessary the argument will be converted\n+ * to a numeric value. If cmd_optional is non-zero, then if the ENGINE\n+ * doesn't support the given cmd_name the return value will be success\n+ * anyway. This function is intended for applications to use so that users\n+ * (or config files) can supply engine-specific config data to the ENGINE at\n+ * run-time to control behaviour of specific engines. As such, it shouldn't\n+ * be used for calling ENGINE_ctrl() functions that return data, deal with\n+ * binary data, or that are otherwise supposed to be used directly through\n+ * ENGINE_ctrl() in application code. Any \"return\" data from an ENGINE_ctrl()\n+ * operation in this function will be lost - the return value is interpreted\n+ * as failure if the return value is zero, success otherwise, and this\n+ * function returns a boolean value as a result. In other words, vendors of\n+ * 'ENGINE'-enabled devices should write ENGINE implementations with\n+ * parameterisations that work in this scheme, so that compliant ENGINE-based\n+ * applications can work consistently with the same configuration for the\n+ * same ENGINE-enabled devices, across applications.\n+ */\n+int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,\n+                           int cmd_optional);\n+\n+/*\n+ * These functions are useful for manufacturing new ENGINE structures. They\n+ * don't address reference counting at all - one uses them to populate an\n+ * ENGINE structure with personalised implementations of things prior to\n+ * using it directly or adding it to the builtin ENGINE list in OpenSSL.\n+ * These are also here so that the ENGINE structure doesn't have to be\n+ * exposed and break binary compatibility!\n+ */\n+ENGINE *ENGINE_new(void);\n+int ENGINE_free(ENGINE *e);\n+int ENGINE_up_ref(ENGINE *e);\n+int ENGINE_set_id(ENGINE *e, const char *id);\n+int ENGINE_set_name(ENGINE *e, const char *name);\n+int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);\n+int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);\n+int ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *ecdh_meth);\n+int ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *ecdsa_meth);\n+int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);\n+int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);\n+int ENGINE_set_STORE(ENGINE *e, const STORE_METHOD *store_meth);\n+int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f);\n+int ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f);\n+int ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f);\n+int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f);\n+int ENGINE_set_load_privkey_function(ENGINE *e,\n+                                     ENGINE_LOAD_KEY_PTR loadpriv_f);\n+int ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f);\n+int ENGINE_set_load_ssl_client_cert_function(ENGINE *e,\n+                                             ENGINE_SSL_CLIENT_CERT_PTR\n+                                             loadssl_f);\n+int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);\n+int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);\n+int ENGINE_set_pkey_meths(ENGINE *e, ENGINE_PKEY_METHS_PTR f);\n+int ENGINE_set_pkey_asn1_meths(ENGINE *e, ENGINE_PKEY_ASN1_METHS_PTR f);\n+int ENGINE_set_flags(ENGINE *e, int flags);\n+int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns);\n+/* These functions allow control over any per-structure ENGINE data. */\n+int ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\n+                            CRYPTO_EX_dup *dup_func,\n+                            CRYPTO_EX_free *free_func);\n+int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg);\n+void *ENGINE_get_ex_data(const ENGINE *e, int idx);\n+\n+/*\n+ * This function cleans up anything that needs it. Eg. the ENGINE_add()\n+ * function automatically ensures the list cleanup function is registered to\n+ * be called from ENGINE_cleanup(). Similarly, all ENGINE_register_***\n+ * functions ensure ENGINE_cleanup() will clean up after them.\n+ */\n+void ENGINE_cleanup(void);\n+\n+/*\n+ * These return values from within the ENGINE structure. These can be useful\n+ * with functional references as well as structural references - it depends\n+ * which you obtained. Using the result for functional purposes if you only\n+ * obtained a structural reference may be problematic!\n+ */\n+const char *ENGINE_get_id(const ENGINE *e);\n+const char *ENGINE_get_name(const ENGINE *e);\n+const RSA_METHOD *ENGINE_get_RSA(const ENGINE *e);\n+const DSA_METHOD *ENGINE_get_DSA(const ENGINE *e);\n+const ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *e);\n+const ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *e);\n+const DH_METHOD *ENGINE_get_DH(const ENGINE *e);\n+const RAND_METHOD *ENGINE_get_RAND(const ENGINE *e);\n+const STORE_METHOD *ENGINE_get_STORE(const ENGINE *e);\n+ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e);\n+ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e);\n+ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e);\n+ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e);\n+ENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e);\n+ENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e);\n+ENGINE_SSL_CLIENT_CERT_PTR ENGINE_get_ssl_client_cert_function(const ENGINE\n+                                                               *e);\n+ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e);\n+ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e);\n+ENGINE_PKEY_METHS_PTR ENGINE_get_pkey_meths(const ENGINE *e);\n+ENGINE_PKEY_ASN1_METHS_PTR ENGINE_get_pkey_asn1_meths(const ENGINE *e);\n+const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);\n+const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid);\n+const EVP_PKEY_METHOD *ENGINE_get_pkey_meth(ENGINE *e, int nid);\n+const EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth(ENGINE *e, int nid);\n+const EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth_str(ENGINE *e,\n+                                                          const char *str,\n+                                                          int len);\n+const EVP_PKEY_ASN1_METHOD *ENGINE_pkey_asn1_find_str(ENGINE **pe,\n+                                                      const char *str,\n+                                                      int len);\n+const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e);\n+int ENGINE_get_flags(const ENGINE *e);\n+\n+/*\n+ * FUNCTIONAL functions. These functions deal with ENGINE structures that\n+ * have (or will) be initialised for use. Broadly speaking, the structural\n+ * functions are useful for iterating the list of available engine types,\n+ * creating new engine types, and other \"list\" operations. These functions\n+ * actually deal with ENGINEs that are to be used. As such these functions\n+ * can fail (if applicable) when particular engines are unavailable - eg. if\n+ * a hardware accelerator is not attached or not functioning correctly. Each\n+ * ENGINE has 2 reference counts; structural and functional. Every time a\n+ * functional reference is obtained or released, a corresponding structural\n+ * reference is automatically obtained or released too.\n+ */\n+\n+/*\n+ * Initialise a engine type for use (or up its reference count if it's\n+ * already in use). This will fail if the engine is not currently operational\n+ * and cannot initialise.\n+ */\n+int ENGINE_init(ENGINE *e);\n+/*\n+ * Free a functional reference to a engine type. This does not require a\n+ * corresponding call to ENGINE_free as it also releases a structural\n+ * reference.\n+ */\n+int ENGINE_finish(ENGINE *e);\n+\n+/*\n+ * The following functions handle keys that are stored in some secondary\n+ * location, handled by the engine.  The storage may be on a card or\n+ * whatever.\n+ */\n+EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,\n+                                  UI_METHOD *ui_method, void *callback_data);\n+EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,\n+                                 UI_METHOD *ui_method, void *callback_data);\n+int ENGINE_load_ssl_client_cert(ENGINE *e, SSL *s,\n+                                STACK_OF(X509_NAME) *ca_dn, X509 **pcert,\n+                                EVP_PKEY **ppkey, STACK_OF(X509) **pother,\n+                                UI_METHOD *ui_method, void *callback_data);\n+\n+/*\n+ * This returns a pointer for the current ENGINE structure that is (by\n+ * default) performing any RSA operations. The value returned is an\n+ * incremented reference, so it should be free'd (ENGINE_finish) before it is\n+ * discarded.\n+ */\n+ENGINE *ENGINE_get_default_RSA(void);\n+/* Same for the other \"methods\" */\n+ENGINE *ENGINE_get_default_DSA(void);\n+ENGINE *ENGINE_get_default_ECDH(void);\n+ENGINE *ENGINE_get_default_ECDSA(void);\n+ENGINE *ENGINE_get_default_DH(void);\n+ENGINE *ENGINE_get_default_RAND(void);\n+/*\n+ * These functions can be used to get a functional reference to perform\n+ * ciphering or digesting corresponding to \"nid\".\n+ */\n+ENGINE *ENGINE_get_cipher_engine(int nid);\n+ENGINE *ENGINE_get_digest_engine(int nid);\n+ENGINE *ENGINE_get_pkey_meth_engine(int nid);\n+ENGINE *ENGINE_get_pkey_asn1_meth_engine(int nid);\n+\n+/*\n+ * This sets a new default ENGINE structure for performing RSA operations. If\n+ * the result is non-zero (success) then the ENGINE structure will have had\n+ * its reference count up'd so the caller should still free their own\n+ * reference 'e'.\n+ */\n+int ENGINE_set_default_RSA(ENGINE *e);\n+int ENGINE_set_default_string(ENGINE *e, const char *def_list);\n+/* Same for the other \"methods\" */\n+int ENGINE_set_default_DSA(ENGINE *e);\n+int ENGINE_set_default_ECDH(ENGINE *e);\n+int ENGINE_set_default_ECDSA(ENGINE *e);\n+int ENGINE_set_default_DH(ENGINE *e);\n+int ENGINE_set_default_RAND(ENGINE *e);\n+int ENGINE_set_default_ciphers(ENGINE *e);\n+int ENGINE_set_default_digests(ENGINE *e);\n+int ENGINE_set_default_pkey_meths(ENGINE *e);\n+int ENGINE_set_default_pkey_asn1_meths(ENGINE *e);\n+\n+/*\n+ * The combination \"set\" - the flags are bitwise \"OR\"d from the\n+ * ENGINE_METHOD_*** defines above. As with the \"ENGINE_register_complete()\"\n+ * function, this function can result in unnecessary static linkage. If your\n+ * application requires only specific functionality, consider using more\n+ * selective functions.\n+ */\n+int ENGINE_set_default(ENGINE *e, unsigned int flags);\n+\n+void ENGINE_add_conf_module(void);\n+\n+/* Deprecated functions ... */\n+/* int ENGINE_clear_defaults(void); */\n+\n+/**************************/\n+/* DYNAMIC ENGINE SUPPORT */\n+/**************************/\n+\n+/* Binary/behaviour compatibility levels */\n+# define OSSL_DYNAMIC_VERSION            (unsigned long)0x00020000\n+/*\n+ * Binary versions older than this are too old for us (whether we're a loader\n+ * or a loadee)\n+ */\n+# define OSSL_DYNAMIC_OLDEST             (unsigned long)0x00020000\n+\n+/*\n+ * When compiling an ENGINE entirely as an external shared library, loadable\n+ * by the \"dynamic\" ENGINE, these types are needed. The 'dynamic_fns'\n+ * structure type provides the calling application's (or library's) error\n+ * functionality and memory management function pointers to the loaded\n+ * library. These should be used/set in the loaded library code so that the\n+ * loading application's 'state' will be used/changed in all operations. The\n+ * 'static_state' pointer allows the loaded library to know if it shares the\n+ * same static data as the calling application (or library), and thus whether\n+ * these callbacks need to be set or not.\n+ */\n+typedef void *(*dyn_MEM_malloc_cb) (size_t);\n+typedef void *(*dyn_MEM_realloc_cb) (void *, size_t);\n+typedef void (*dyn_MEM_free_cb) (void *);\n+typedef struct st_dynamic_MEM_fns {\n+    dyn_MEM_malloc_cb malloc_cb;\n+    dyn_MEM_realloc_cb realloc_cb;\n+    dyn_MEM_free_cb free_cb;\n+} dynamic_MEM_fns;\n+/*\n+ * FIXME: Perhaps the memory and locking code (crypto.h) should declare and\n+ * use these types so we (and any other dependant code) can simplify a bit??\n+ */\n+typedef void (*dyn_lock_locking_cb) (int, int, const char *, int);\n+typedef int (*dyn_lock_add_lock_cb) (int *, int, int, const char *, int);\n+typedef struct CRYPTO_dynlock_value *(*dyn_dynlock_create_cb) (const char *,\n+                                                               int);\n+typedef void (*dyn_dynlock_lock_cb) (int, struct CRYPTO_dynlock_value *,\n+                                     const char *, int);\n+typedef void (*dyn_dynlock_destroy_cb) (struct CRYPTO_dynlock_value *,\n+                                        const char *, int);\n+typedef struct st_dynamic_LOCK_fns {\n+    dyn_lock_locking_cb lock_locking_cb;\n+    dyn_lock_add_lock_cb lock_add_lock_cb;\n+    dyn_dynlock_create_cb dynlock_create_cb;\n+    dyn_dynlock_lock_cb dynlock_lock_cb;\n+    dyn_dynlock_destroy_cb dynlock_destroy_cb;\n+} dynamic_LOCK_fns;\n+/* The top-level structure */\n+typedef struct st_dynamic_fns {\n+    void *static_state;\n+    const ERR_FNS *err_fns;\n+    const CRYPTO_EX_DATA_IMPL *ex_data_fns;\n+    dynamic_MEM_fns mem_fns;\n+    dynamic_LOCK_fns lock_fns;\n+} dynamic_fns;\n+\n+/*\n+ * The version checking function should be of this prototype. NB: The\n+ * ossl_version value passed in is the OSSL_DYNAMIC_VERSION of the loading\n+ * code. If this function returns zero, it indicates a (potential) version\n+ * incompatibility and the loaded library doesn't believe it can proceed.\n+ * Otherwise, the returned value is the (latest) version supported by the\n+ * loading library. The loader may still decide that the loaded code's\n+ * version is unsatisfactory and could veto the load. The function is\n+ * expected to be implemented with the symbol name \"v_check\", and a default\n+ * implementation can be fully instantiated with\n+ * IMPLEMENT_DYNAMIC_CHECK_FN().\n+ */\n+typedef unsigned long (*dynamic_v_check_fn) (unsigned long ossl_version);\n+# define IMPLEMENT_DYNAMIC_CHECK_FN() \\\n+        OPENSSL_EXPORT unsigned long v_check(unsigned long v); \\\n+        OPENSSL_EXPORT unsigned long v_check(unsigned long v) { \\\n+                if(v >= OSSL_DYNAMIC_OLDEST) return OSSL_DYNAMIC_VERSION; \\\n+                return 0; }\n+\n+/*\n+ * This function is passed the ENGINE structure to initialise with its own\n+ * function and command settings. It should not adjust the structural or\n+ * functional reference counts. If this function returns zero, (a) the load\n+ * will be aborted, (b) the previous ENGINE state will be memcpy'd back onto\n+ * the structure, and (c) the shared library will be unloaded. So\n+ * implementations should do their own internal cleanup in failure\n+ * circumstances otherwise they could leak. The 'id' parameter, if non-NULL,\n+ * represents the ENGINE id that the loader is looking for. If this is NULL,\n+ * the shared library can choose to return failure or to initialise a\n+ * 'default' ENGINE. If non-NULL, the shared library must initialise only an\n+ * ENGINE matching the passed 'id'. The function is expected to be\n+ * implemented with the symbol name \"bind_engine\". A standard implementation\n+ * can be instantiated with IMPLEMENT_DYNAMIC_BIND_FN(fn) where the parameter\n+ * 'fn' is a callback function that populates the ENGINE structure and\n+ * returns an int value (zero for failure). 'fn' should have prototype;\n+ * [static] int fn(ENGINE *e, const char *id);\n+ */\n+typedef int (*dynamic_bind_engine) (ENGINE *e, const char *id,\n+                                    const dynamic_fns *fns);\n+# define IMPLEMENT_DYNAMIC_BIND_FN(fn) \\\n+        OPENSSL_EXPORT \\\n+        int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns); \\\n+        OPENSSL_EXPORT \\\n+        int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \\\n+                if(ENGINE_get_static_state() == fns->static_state) goto skip_cbs; \\\n+                if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, \\\n+                        fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) \\\n+                        return 0; \\\n+                CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); \\\n+                CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); \\\n+                CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \\\n+                CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \\\n+                CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \\\n+                if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \\\n+                        return 0; \\\n+                if(!ERR_set_implementation(fns->err_fns)) return 0; \\\n+        skip_cbs: \\\n+                if(!fn(e,id)) return 0; \\\n+                return 1; }\n+\n+/*\n+ * If the loading application (or library) and the loaded ENGINE library\n+ * share the same static data (eg. they're both dynamically linked to the\n+ * same libcrypto.so) we need a way to avoid trying to set system callbacks -\n+ * this would fail, and for the same reason that it's unnecessary to try. If\n+ * the loaded ENGINE has (or gets from through the loader) its own copy of\n+ * the libcrypto static data, we will need to set the callbacks. The easiest\n+ * way to detect this is to have a function that returns a pointer to some\n+ * static data and let the loading application and loaded ENGINE compare\n+ * their respective values.\n+ */\n+void *ENGINE_get_static_state(void);\n+\n+# if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(HAVE_CRYPTODEV)\n+void ENGINE_setup_bsd_cryptodev(void);\n+# endif\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_ENGINE_strings(void);\n+\n+/* Error codes for the ENGINE functions. */\n+\n+/* Function codes. */\n+# define ENGINE_F_DYNAMIC_CTRL                            180\n+# define ENGINE_F_DYNAMIC_GET_DATA_CTX                    181\n+# define ENGINE_F_DYNAMIC_LOAD                            182\n+# define ENGINE_F_DYNAMIC_SET_DATA_CTX                    183\n+# define ENGINE_F_ENGINE_ADD                              105\n+# define ENGINE_F_ENGINE_BY_ID                            106\n+# define ENGINE_F_ENGINE_CMD_IS_EXECUTABLE                170\n+# define ENGINE_F_ENGINE_CTRL                             142\n+# define ENGINE_F_ENGINE_CTRL_CMD                         178\n+# define ENGINE_F_ENGINE_CTRL_CMD_STRING                  171\n+# define ENGINE_F_ENGINE_FINISH                           107\n+# define ENGINE_F_ENGINE_FREE_UTIL                        108\n+# define ENGINE_F_ENGINE_GET_CIPHER                       185\n+# define ENGINE_F_ENGINE_GET_DEFAULT_TYPE                 177\n+# define ENGINE_F_ENGINE_GET_DIGEST                       186\n+# define ENGINE_F_ENGINE_GET_NEXT                         115\n+# define ENGINE_F_ENGINE_GET_PKEY_ASN1_METH               193\n+# define ENGINE_F_ENGINE_GET_PKEY_METH                    192\n+# define ENGINE_F_ENGINE_GET_PREV                         116\n+# define ENGINE_F_ENGINE_INIT                             119\n+# define ENGINE_F_ENGINE_LIST_ADD                         120\n+# define ENGINE_F_ENGINE_LIST_REMOVE                      121\n+# define ENGINE_F_ENGINE_LOAD_PRIVATE_KEY                 150\n+# define ENGINE_F_ENGINE_LOAD_PUBLIC_KEY                  151\n+# define ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT             194\n+# define ENGINE_F_ENGINE_NEW                              122\n+# define ENGINE_F_ENGINE_REMOVE                           123\n+# define ENGINE_F_ENGINE_SET_DEFAULT_STRING               189\n+# define ENGINE_F_ENGINE_SET_DEFAULT_TYPE                 126\n+# define ENGINE_F_ENGINE_SET_ID                           129\n+# define ENGINE_F_ENGINE_SET_NAME                         130\n+# define ENGINE_F_ENGINE_TABLE_REGISTER                   184\n+# define ENGINE_F_ENGINE_UNLOAD_KEY                       152\n+# define ENGINE_F_ENGINE_UNLOCKED_FINISH                  191\n+# define ENGINE_F_ENGINE_UP_REF                           190\n+# define ENGINE_F_INT_CTRL_HELPER                         172\n+# define ENGINE_F_INT_ENGINE_CONFIGURE                    188\n+# define ENGINE_F_INT_ENGINE_MODULE_INIT                  187\n+# define ENGINE_F_LOG_MESSAGE                             141\n+\n+/* Reason codes. */\n+# define ENGINE_R_ALREADY_LOADED                          100\n+# define ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER                133\n+# define ENGINE_R_CMD_NOT_EXECUTABLE                      134\n+# define ENGINE_R_COMMAND_TAKES_INPUT                     135\n+# define ENGINE_R_COMMAND_TAKES_NO_INPUT                  136\n+# define ENGINE_R_CONFLICTING_ENGINE_ID                   103\n+# define ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED            119\n+# define ENGINE_R_DH_NOT_IMPLEMENTED                      139\n+# define ENGINE_R_DSA_NOT_IMPLEMENTED                     140\n+# define ENGINE_R_DSO_FAILURE                             104\n+# define ENGINE_R_DSO_NOT_FOUND                           132\n+# define ENGINE_R_ENGINES_SECTION_ERROR                   148\n+# define ENGINE_R_ENGINE_CONFIGURATION_ERROR              102\n+# define ENGINE_R_ENGINE_IS_NOT_IN_LIST                   105\n+# define ENGINE_R_ENGINE_SECTION_ERROR                    149\n+# define ENGINE_R_FAILED_LOADING_PRIVATE_KEY              128\n+# define ENGINE_R_FAILED_LOADING_PUBLIC_KEY               129\n+# define ENGINE_R_FINISH_FAILED                           106\n+# define ENGINE_R_GET_HANDLE_FAILED                       107\n+# define ENGINE_R_ID_OR_NAME_MISSING                      108\n+# define ENGINE_R_INIT_FAILED                             109\n+# define ENGINE_R_INTERNAL_LIST_ERROR                     110\n+# define ENGINE_R_INVALID_ARGUMENT                        143\n+# define ENGINE_R_INVALID_CMD_NAME                        137\n+# define ENGINE_R_INVALID_CMD_NUMBER                      138\n+# define ENGINE_R_INVALID_INIT_VALUE                      151\n+# define ENGINE_R_INVALID_STRING                          150\n+# define ENGINE_R_NOT_INITIALISED                         117\n+# define ENGINE_R_NOT_LOADED                              112\n+# define ENGINE_R_NO_CONTROL_FUNCTION                     120\n+# define ENGINE_R_NO_INDEX                                144\n+# define ENGINE_R_NO_LOAD_FUNCTION                        125\n+# define ENGINE_R_NO_REFERENCE                            130\n+# define ENGINE_R_NO_SUCH_ENGINE                          116\n+# define ENGINE_R_NO_UNLOAD_FUNCTION                      126\n+# define ENGINE_R_PROVIDE_PARAMETERS                      113\n+# define ENGINE_R_RSA_NOT_IMPLEMENTED                     141\n+# define ENGINE_R_UNIMPLEMENTED_CIPHER                    146\n+# define ENGINE_R_UNIMPLEMENTED_DIGEST                    147\n+# define ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD         101\n+# define ENGINE_R_VERSION_INCOMPATIBILITY                 145\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "f42365620db0c022d2f55c31a47bfb47564a8842",
            "filename": "deps/openssl/openssl/include/openssl/err.h",
            "status": "added",
            "additions": 390,
            "deletions": 0,
            "changes": 390,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Ferr.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Ferr.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Ferr.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,390 @@\n+/* crypto/err/err.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+/* ====================================================================\n+ * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#ifndef HEADER_ERR_H\n+# define HEADER_ERR_H\n+\n+# include <openssl/e_os2.h>\n+\n+# ifndef OPENSSL_NO_FP_API\n+#  include <stdio.h>\n+#  include <stdlib.h>\n+# endif\n+\n+# include <openssl/ossl_typ.h>\n+# ifndef OPENSSL_NO_BIO\n+#  include <openssl/bio.h>\n+# endif\n+# ifndef OPENSSL_NO_LHASH\n+#  include <openssl/lhash.h>\n+# endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# ifndef OPENSSL_NO_ERR\n+#  define ERR_PUT_error(a,b,c,d,e)        ERR_put_error(a,b,c,d,e)\n+# else\n+#  define ERR_PUT_error(a,b,c,d,e)        ERR_put_error(a,b,c,NULL,0)\n+# endif\n+\n+# include <errno.h>\n+\n+# define ERR_TXT_MALLOCED        0x01\n+# define ERR_TXT_STRING          0x02\n+\n+# define ERR_FLAG_MARK           0x01\n+\n+# define ERR_NUM_ERRORS  16\n+typedef struct err_state_st {\n+    CRYPTO_THREADID tid;\n+    int err_flags[ERR_NUM_ERRORS];\n+    unsigned long err_buffer[ERR_NUM_ERRORS];\n+    char *err_data[ERR_NUM_ERRORS];\n+    int err_data_flags[ERR_NUM_ERRORS];\n+    const char *err_file[ERR_NUM_ERRORS];\n+    int err_line[ERR_NUM_ERRORS];\n+    int top, bottom;\n+} ERR_STATE;\n+\n+/* library */\n+# define ERR_LIB_NONE            1\n+# define ERR_LIB_SYS             2\n+# define ERR_LIB_BN              3\n+# define ERR_LIB_RSA             4\n+# define ERR_LIB_DH              5\n+# define ERR_LIB_EVP             6\n+# define ERR_LIB_BUF             7\n+# define ERR_LIB_OBJ             8\n+# define ERR_LIB_PEM             9\n+# define ERR_LIB_DSA             10\n+# define ERR_LIB_X509            11\n+/* #define ERR_LIB_METH         12 */\n+# define ERR_LIB_ASN1            13\n+# define ERR_LIB_CONF            14\n+# define ERR_LIB_CRYPTO          15\n+# define ERR_LIB_EC              16\n+# define ERR_LIB_SSL             20\n+/* #define ERR_LIB_SSL23        21 */\n+/* #define ERR_LIB_SSL2         22 */\n+/* #define ERR_LIB_SSL3         23 */\n+/* #define ERR_LIB_RSAREF       30 */\n+/* #define ERR_LIB_PROXY        31 */\n+# define ERR_LIB_BIO             32\n+# define ERR_LIB_PKCS7           33\n+# define ERR_LIB_X509V3          34\n+# define ERR_LIB_PKCS12          35\n+# define ERR_LIB_RAND            36\n+# define ERR_LIB_DSO             37\n+# define ERR_LIB_ENGINE          38\n+# define ERR_LIB_OCSP            39\n+# define ERR_LIB_UI              40\n+# define ERR_LIB_COMP            41\n+# define ERR_LIB_ECDSA           42\n+# define ERR_LIB_ECDH            43\n+# define ERR_LIB_STORE           44\n+# define ERR_LIB_FIPS            45\n+# define ERR_LIB_CMS             46\n+# define ERR_LIB_TS              47\n+# define ERR_LIB_HMAC            48\n+# define ERR_LIB_JPAKE           49\n+\n+# define ERR_LIB_USER            128\n+\n+# define SYSerr(f,r)  ERR_PUT_error(ERR_LIB_SYS,(f),(r),__FILE__,__LINE__)\n+# define BNerr(f,r)   ERR_PUT_error(ERR_LIB_BN,(f),(r),__FILE__,__LINE__)\n+# define RSAerr(f,r)  ERR_PUT_error(ERR_LIB_RSA,(f),(r),__FILE__,__LINE__)\n+# define DHerr(f,r)   ERR_PUT_error(ERR_LIB_DH,(f),(r),__FILE__,__LINE__)\n+# define EVPerr(f,r)  ERR_PUT_error(ERR_LIB_EVP,(f),(r),__FILE__,__LINE__)\n+# define BUFerr(f,r)  ERR_PUT_error(ERR_LIB_BUF,(f),(r),__FILE__,__LINE__)\n+# define OBJerr(f,r)  ERR_PUT_error(ERR_LIB_OBJ,(f),(r),__FILE__,__LINE__)\n+# define PEMerr(f,r)  ERR_PUT_error(ERR_LIB_PEM,(f),(r),__FILE__,__LINE__)\n+# define DSAerr(f,r)  ERR_PUT_error(ERR_LIB_DSA,(f),(r),__FILE__,__LINE__)\n+# define X509err(f,r) ERR_PUT_error(ERR_LIB_X509,(f),(r),__FILE__,__LINE__)\n+# define ASN1err(f,r) ERR_PUT_error(ERR_LIB_ASN1,(f),(r),__FILE__,__LINE__)\n+# define CONFerr(f,r) ERR_PUT_error(ERR_LIB_CONF,(f),(r),__FILE__,__LINE__)\n+# define CRYPTOerr(f,r) ERR_PUT_error(ERR_LIB_CRYPTO,(f),(r),__FILE__,__LINE__)\n+# define ECerr(f,r)   ERR_PUT_error(ERR_LIB_EC,(f),(r),__FILE__,__LINE__)\n+# define SSLerr(f,r)  ERR_PUT_error(ERR_LIB_SSL,(f),(r),__FILE__,__LINE__)\n+# define BIOerr(f,r)  ERR_PUT_error(ERR_LIB_BIO,(f),(r),__FILE__,__LINE__)\n+# define PKCS7err(f,r) ERR_PUT_error(ERR_LIB_PKCS7,(f),(r),__FILE__,__LINE__)\n+# define X509V3err(f,r) ERR_PUT_error(ERR_LIB_X509V3,(f),(r),__FILE__,__LINE__)\n+# define PKCS12err(f,r) ERR_PUT_error(ERR_LIB_PKCS12,(f),(r),__FILE__,__LINE__)\n+# define RANDerr(f,r) ERR_PUT_error(ERR_LIB_RAND,(f),(r),__FILE__,__LINE__)\n+# define DSOerr(f,r) ERR_PUT_error(ERR_LIB_DSO,(f),(r),__FILE__,__LINE__)\n+# define ENGINEerr(f,r) ERR_PUT_error(ERR_LIB_ENGINE,(f),(r),__FILE__,__LINE__)\n+# define OCSPerr(f,r) ERR_PUT_error(ERR_LIB_OCSP,(f),(r),__FILE__,__LINE__)\n+# define UIerr(f,r) ERR_PUT_error(ERR_LIB_UI,(f),(r),__FILE__,__LINE__)\n+# define COMPerr(f,r) ERR_PUT_error(ERR_LIB_COMP,(f),(r),__FILE__,__LINE__)\n+# define ECDSAerr(f,r)  ERR_PUT_error(ERR_LIB_ECDSA,(f),(r),__FILE__,__LINE__)\n+# define ECDHerr(f,r)  ERR_PUT_error(ERR_LIB_ECDH,(f),(r),__FILE__,__LINE__)\n+# define STOREerr(f,r) ERR_PUT_error(ERR_LIB_STORE,(f),(r),__FILE__,__LINE__)\n+# define FIPSerr(f,r) ERR_PUT_error(ERR_LIB_FIPS,(f),(r),__FILE__,__LINE__)\n+# define CMSerr(f,r) ERR_PUT_error(ERR_LIB_CMS,(f),(r),__FILE__,__LINE__)\n+# define TSerr(f,r) ERR_PUT_error(ERR_LIB_TS,(f),(r),__FILE__,__LINE__)\n+# define HMACerr(f,r) ERR_PUT_error(ERR_LIB_HMAC,(f),(r),__FILE__,__LINE__)\n+# define JPAKEerr(f,r) ERR_PUT_error(ERR_LIB_JPAKE,(f),(r),__FILE__,__LINE__)\n+\n+/*\n+ * Borland C seems too stupid to be able to shift and do longs in the\n+ * pre-processor :-(\n+ */\n+# define ERR_PACK(l,f,r)         (((((unsigned long)l)&0xffL)*0x1000000)| \\\n+                                ((((unsigned long)f)&0xfffL)*0x1000)| \\\n+                                ((((unsigned long)r)&0xfffL)))\n+# define ERR_GET_LIB(l)          (int)((((unsigned long)l)>>24L)&0xffL)\n+# define ERR_GET_FUNC(l)         (int)((((unsigned long)l)>>12L)&0xfffL)\n+# define ERR_GET_REASON(l)       (int)((l)&0xfffL)\n+# define ERR_FATAL_ERROR(l)      (int)((l)&ERR_R_FATAL)\n+\n+/* OS functions */\n+# define SYS_F_FOPEN             1\n+# define SYS_F_CONNECT           2\n+# define SYS_F_GETSERVBYNAME     3\n+# define SYS_F_SOCKET            4\n+# define SYS_F_IOCTLSOCKET       5\n+# define SYS_F_BIND              6\n+# define SYS_F_LISTEN            7\n+# define SYS_F_ACCEPT            8\n+# define SYS_F_WSASTARTUP        9/* Winsock stuff */\n+# define SYS_F_OPENDIR           10\n+# define SYS_F_FREAD             11\n+# define SYS_F_FFLUSH            18\n+\n+/* reasons */\n+# define ERR_R_SYS_LIB   ERR_LIB_SYS/* 2 */\n+# define ERR_R_BN_LIB    ERR_LIB_BN/* 3 */\n+# define ERR_R_RSA_LIB   ERR_LIB_RSA/* 4 */\n+# define ERR_R_DH_LIB    ERR_LIB_DH/* 5 */\n+# define ERR_R_EVP_LIB   ERR_LIB_EVP/* 6 */\n+# define ERR_R_BUF_LIB   ERR_LIB_BUF/* 7 */\n+# define ERR_R_OBJ_LIB   ERR_LIB_OBJ/* 8 */\n+# define ERR_R_PEM_LIB   ERR_LIB_PEM/* 9 */\n+# define ERR_R_DSA_LIB   ERR_LIB_DSA/* 10 */\n+# define ERR_R_X509_LIB  ERR_LIB_X509/* 11 */\n+# define ERR_R_ASN1_LIB  ERR_LIB_ASN1/* 13 */\n+# define ERR_R_CONF_LIB  ERR_LIB_CONF/* 14 */\n+# define ERR_R_CRYPTO_LIB ERR_LIB_CRYPTO/* 15 */\n+# define ERR_R_EC_LIB    ERR_LIB_EC/* 16 */\n+# define ERR_R_SSL_LIB   ERR_LIB_SSL/* 20 */\n+# define ERR_R_BIO_LIB   ERR_LIB_BIO/* 32 */\n+# define ERR_R_PKCS7_LIB ERR_LIB_PKCS7/* 33 */\n+# define ERR_R_X509V3_LIB ERR_LIB_X509V3/* 34 */\n+# define ERR_R_PKCS12_LIB ERR_LIB_PKCS12/* 35 */\n+# define ERR_R_RAND_LIB  ERR_LIB_RAND/* 36 */\n+# define ERR_R_DSO_LIB   ERR_LIB_DSO/* 37 */\n+# define ERR_R_ENGINE_LIB ERR_LIB_ENGINE/* 38 */\n+# define ERR_R_OCSP_LIB  ERR_LIB_OCSP/* 39 */\n+# define ERR_R_UI_LIB    ERR_LIB_UI/* 40 */\n+# define ERR_R_COMP_LIB  ERR_LIB_COMP/* 41 */\n+# define ERR_R_ECDSA_LIB ERR_LIB_ECDSA/* 42 */\n+# define ERR_R_ECDH_LIB  ERR_LIB_ECDH/* 43 */\n+# define ERR_R_STORE_LIB ERR_LIB_STORE/* 44 */\n+# define ERR_R_TS_LIB    ERR_LIB_TS/* 45 */\n+\n+# define ERR_R_NESTED_ASN1_ERROR                 58\n+# define ERR_R_BAD_ASN1_OBJECT_HEADER            59\n+# define ERR_R_BAD_GET_ASN1_OBJECT_CALL          60\n+# define ERR_R_EXPECTING_AN_ASN1_SEQUENCE        61\n+# define ERR_R_ASN1_LENGTH_MISMATCH              62\n+# define ERR_R_MISSING_ASN1_EOS                  63\n+\n+/* fatal error */\n+# define ERR_R_FATAL                             64\n+# define ERR_R_MALLOC_FAILURE                    (1|ERR_R_FATAL)\n+# define ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED       (2|ERR_R_FATAL)\n+# define ERR_R_PASSED_NULL_PARAMETER             (3|ERR_R_FATAL)\n+# define ERR_R_INTERNAL_ERROR                    (4|ERR_R_FATAL)\n+# define ERR_R_DISABLED                          (5|ERR_R_FATAL)\n+\n+/*\n+ * 99 is the maximum possible ERR_R_... code, higher values are reserved for\n+ * the individual libraries\n+ */\n+\n+typedef struct ERR_string_data_st {\n+    unsigned long error;\n+    const char *string;\n+} ERR_STRING_DATA;\n+\n+void ERR_put_error(int lib, int func, int reason, const char *file, int line);\n+void ERR_set_error_data(char *data, int flags);\n+\n+unsigned long ERR_get_error(void);\n+unsigned long ERR_get_error_line(const char **file, int *line);\n+unsigned long ERR_get_error_line_data(const char **file, int *line,\n+                                      const char **data, int *flags);\n+unsigned long ERR_peek_error(void);\n+unsigned long ERR_peek_error_line(const char **file, int *line);\n+unsigned long ERR_peek_error_line_data(const char **file, int *line,\n+                                       const char **data, int *flags);\n+unsigned long ERR_peek_last_error(void);\n+unsigned long ERR_peek_last_error_line(const char **file, int *line);\n+unsigned long ERR_peek_last_error_line_data(const char **file, int *line,\n+                                            const char **data, int *flags);\n+void ERR_clear_error(void);\n+char *ERR_error_string(unsigned long e, char *buf);\n+void ERR_error_string_n(unsigned long e, char *buf, size_t len);\n+const char *ERR_lib_error_string(unsigned long e);\n+const char *ERR_func_error_string(unsigned long e);\n+const char *ERR_reason_error_string(unsigned long e);\n+void ERR_print_errors_cb(int (*cb) (const char *str, size_t len, void *u),\n+                         void *u);\n+# ifndef OPENSSL_NO_FP_API\n+void ERR_print_errors_fp(FILE *fp);\n+# endif\n+# ifndef OPENSSL_NO_BIO\n+void ERR_print_errors(BIO *bp);\n+# endif\n+void ERR_add_error_data(int num, ...);\n+void ERR_add_error_vdata(int num, va_list args);\n+void ERR_load_strings(int lib, ERR_STRING_DATA str[]);\n+void ERR_unload_strings(int lib, ERR_STRING_DATA str[]);\n+void ERR_load_ERR_strings(void);\n+void ERR_load_crypto_strings(void);\n+void ERR_free_strings(void);\n+\n+void ERR_remove_thread_state(const CRYPTO_THREADID *tid);\n+# ifndef OPENSSL_NO_DEPRECATED\n+void ERR_remove_state(unsigned long pid); /* if zero we look it up */\n+# endif\n+ERR_STATE *ERR_get_state(void);\n+\n+# ifndef OPENSSL_NO_LHASH\n+LHASH_OF(ERR_STRING_DATA) *ERR_get_string_table(void);\n+LHASH_OF(ERR_STATE) *ERR_get_err_state_table(void);\n+void ERR_release_err_state_table(LHASH_OF(ERR_STATE) **hash);\n+# endif\n+\n+int ERR_get_next_error_library(void);\n+\n+int ERR_set_mark(void);\n+int ERR_pop_to_mark(void);\n+\n+/* Already defined in ossl_typ.h */\n+/* typedef struct st_ERR_FNS ERR_FNS; */\n+/*\n+ * An application can use this function and provide the return value to\n+ * loaded modules that should use the application's ERR state/functionality\n+ */\n+const ERR_FNS *ERR_get_implementation(void);\n+/*\n+ * A loaded module should call this function prior to any ERR operations\n+ * using the application's \"ERR_FNS\".\n+ */\n+int ERR_set_implementation(const ERR_FNS *fns);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "cf1de15e6d03cecf7961b3219b27d1cee6b4df71",
            "filename": "deps/openssl/openssl/include/openssl/evp.h",
            "status": "added",
            "additions": 1628,
            "deletions": 0,
            "changes": 1628,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fevp.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fevp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fevp.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,1628 @@\n+/* crypto/evp/evp.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_ENVELOPE_H\n+# define HEADER_ENVELOPE_H\n+\n+# ifdef OPENSSL_ALGORITHM_DEFINES\n+#  include <openssl/opensslconf.h>\n+# else\n+#  define OPENSSL_ALGORITHM_DEFINES\n+#  include <openssl/opensslconf.h>\n+#  undef OPENSSL_ALGORITHM_DEFINES\n+# endif\n+\n+# include <openssl/ossl_typ.h>\n+\n+# include <openssl/symhacks.h>\n+\n+# ifndef OPENSSL_NO_BIO\n+#  include <openssl/bio.h>\n+# endif\n+\n+/*-\n+#define EVP_RC2_KEY_SIZE                16\n+#define EVP_RC4_KEY_SIZE                16\n+#define EVP_BLOWFISH_KEY_SIZE           16\n+#define EVP_CAST5_KEY_SIZE              16\n+#define EVP_RC5_32_12_16_KEY_SIZE       16\n+*/\n+# define EVP_MAX_MD_SIZE                 64/* longest known is SHA512 */\n+# define EVP_MAX_KEY_LENGTH              64\n+# define EVP_MAX_IV_LENGTH               16\n+# define EVP_MAX_BLOCK_LENGTH            32\n+\n+# define PKCS5_SALT_LEN                  8\n+/* Default PKCS#5 iteration count */\n+# define PKCS5_DEFAULT_ITER              2048\n+\n+# include <openssl/objects.h>\n+\n+# define EVP_PK_RSA      0x0001\n+# define EVP_PK_DSA      0x0002\n+# define EVP_PK_DH       0x0004\n+# define EVP_PK_EC       0x0008\n+# define EVP_PKT_SIGN    0x0010\n+# define EVP_PKT_ENC     0x0020\n+# define EVP_PKT_EXCH    0x0040\n+# define EVP_PKS_RSA     0x0100\n+# define EVP_PKS_DSA     0x0200\n+# define EVP_PKS_EC      0x0400\n+\n+# define EVP_PKEY_NONE   NID_undef\n+# define EVP_PKEY_RSA    NID_rsaEncryption\n+# define EVP_PKEY_RSA2   NID_rsa\n+# define EVP_PKEY_DSA    NID_dsa\n+# define EVP_PKEY_DSA1   NID_dsa_2\n+# define EVP_PKEY_DSA2   NID_dsaWithSHA\n+# define EVP_PKEY_DSA3   NID_dsaWithSHA1\n+# define EVP_PKEY_DSA4   NID_dsaWithSHA1_2\n+# define EVP_PKEY_DH     NID_dhKeyAgreement\n+# define EVP_PKEY_DHX    NID_dhpublicnumber\n+# define EVP_PKEY_EC     NID_X9_62_id_ecPublicKey\n+# define EVP_PKEY_HMAC   NID_hmac\n+# define EVP_PKEY_CMAC   NID_cmac\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+ * Type needs to be a bit field Sub-type needs to be for variations on the\n+ * method, as in, can it do arbitrary encryption....\n+ */\n+struct evp_pkey_st {\n+    int type;\n+    int save_type;\n+    int references;\n+    const EVP_PKEY_ASN1_METHOD *ameth;\n+    ENGINE *engine;\n+    union {\n+        char *ptr;\n+# ifndef OPENSSL_NO_RSA\n+        struct rsa_st *rsa;     /* RSA */\n+# endif\n+# ifndef OPENSSL_NO_DSA\n+        struct dsa_st *dsa;     /* DSA */\n+# endif\n+# ifndef OPENSSL_NO_DH\n+        struct dh_st *dh;       /* DH */\n+# endif\n+# ifndef OPENSSL_NO_EC\n+        struct ec_key_st *ec;   /* ECC */\n+# endif\n+    } pkey;\n+    int save_parameters;\n+    STACK_OF(X509_ATTRIBUTE) *attributes; /* [ 0 ] */\n+} /* EVP_PKEY */ ;\n+\n+# define EVP_PKEY_MO_SIGN        0x0001\n+# define EVP_PKEY_MO_VERIFY      0x0002\n+# define EVP_PKEY_MO_ENCRYPT     0x0004\n+# define EVP_PKEY_MO_DECRYPT     0x0008\n+\n+# ifndef EVP_MD\n+struct env_md_st {\n+    int type;\n+    int pkey_type;\n+    int md_size;\n+    unsigned long flags;\n+    int (*init) (EVP_MD_CTX *ctx);\n+    int (*update) (EVP_MD_CTX *ctx, const void *data, size_t count);\n+    int (*final) (EVP_MD_CTX *ctx, unsigned char *md);\n+    int (*copy) (EVP_MD_CTX *to, const EVP_MD_CTX *from);\n+    int (*cleanup) (EVP_MD_CTX *ctx);\n+    /* FIXME: prototype these some day */\n+    int (*sign) (int type, const unsigned char *m, unsigned int m_length,\n+                 unsigned char *sigret, unsigned int *siglen, void *key);\n+    int (*verify) (int type, const unsigned char *m, unsigned int m_length,\n+                   const unsigned char *sigbuf, unsigned int siglen,\n+                   void *key);\n+    int required_pkey_type[5];  /* EVP_PKEY_xxx */\n+    int block_size;\n+    int ctx_size;               /* how big does the ctx->md_data need to be */\n+    /* control function */\n+    int (*md_ctrl) (EVP_MD_CTX *ctx, int cmd, int p1, void *p2);\n+} /* EVP_MD */ ;\n+\n+typedef int evp_sign_method(int type, const unsigned char *m,\n+                            unsigned int m_length, unsigned char *sigret,\n+                            unsigned int *siglen, void *key);\n+typedef int evp_verify_method(int type, const unsigned char *m,\n+                              unsigned int m_length,\n+                              const unsigned char *sigbuf,\n+                              unsigned int siglen, void *key);\n+\n+/* digest can only handle a single block */\n+#  define EVP_MD_FLAG_ONESHOT     0x0001\n+\n+/*\n+ * digest is a \"clone\" digest used\n+ * which is a copy of an existing\n+ * one for a specific public key type.\n+ * EVP_dss1() etc\n+ */\n+#  define EVP_MD_FLAG_PKEY_DIGEST 0x0002\n+\n+/* Digest uses EVP_PKEY_METHOD for signing instead of MD specific signing */\n+\n+#  define EVP_MD_FLAG_PKEY_METHOD_SIGNATURE       0x0004\n+\n+/* DigestAlgorithmIdentifier flags... */\n+\n+#  define EVP_MD_FLAG_DIGALGID_MASK               0x0018\n+\n+/* NULL or absent parameter accepted. Use NULL */\n+\n+#  define EVP_MD_FLAG_DIGALGID_NULL               0x0000\n+\n+/* NULL or absent parameter accepted. Use NULL for PKCS#1 otherwise absent */\n+\n+#  define EVP_MD_FLAG_DIGALGID_ABSENT             0x0008\n+\n+/* Custom handling via ctrl */\n+\n+#  define EVP_MD_FLAG_DIGALGID_CUSTOM             0x0018\n+\n+/* Note if suitable for use in FIPS mode */\n+#  define EVP_MD_FLAG_FIPS        0x0400\n+\n+/* Digest ctrls */\n+\n+#  define EVP_MD_CTRL_DIGALGID                    0x1\n+#  define EVP_MD_CTRL_MICALG                      0x2\n+\n+/* Minimum Algorithm specific ctrl value */\n+\n+#  define EVP_MD_CTRL_ALG_CTRL                    0x1000\n+\n+#  define EVP_PKEY_NULL_method    NULL,NULL,{0,0,0,0}\n+\n+#  ifndef OPENSSL_NO_DSA\n+#   define EVP_PKEY_DSA_method     (evp_sign_method *)DSA_sign, \\\n+                                (evp_verify_method *)DSA_verify, \\\n+                                {EVP_PKEY_DSA,EVP_PKEY_DSA2,EVP_PKEY_DSA3, \\\n+                                        EVP_PKEY_DSA4,0}\n+#  else\n+#   define EVP_PKEY_DSA_method     EVP_PKEY_NULL_method\n+#  endif\n+\n+#  ifndef OPENSSL_NO_ECDSA\n+#   define EVP_PKEY_ECDSA_method   (evp_sign_method *)ECDSA_sign, \\\n+                                (evp_verify_method *)ECDSA_verify, \\\n+                                 {EVP_PKEY_EC,0,0,0}\n+#  else\n+#   define EVP_PKEY_ECDSA_method   EVP_PKEY_NULL_method\n+#  endif\n+\n+#  ifndef OPENSSL_NO_RSA\n+#   define EVP_PKEY_RSA_method     (evp_sign_method *)RSA_sign, \\\n+                                (evp_verify_method *)RSA_verify, \\\n+                                {EVP_PKEY_RSA,EVP_PKEY_RSA2,0,0}\n+#   define EVP_PKEY_RSA_ASN1_OCTET_STRING_method \\\n+                                (evp_sign_method *)RSA_sign_ASN1_OCTET_STRING, \\\n+                                (evp_verify_method *)RSA_verify_ASN1_OCTET_STRING, \\\n+                                {EVP_PKEY_RSA,EVP_PKEY_RSA2,0,0}\n+#  else\n+#   define EVP_PKEY_RSA_method     EVP_PKEY_NULL_method\n+#   define EVP_PKEY_RSA_ASN1_OCTET_STRING_method EVP_PKEY_NULL_method\n+#  endif\n+\n+# endif                         /* !EVP_MD */\n+\n+struct env_md_ctx_st {\n+    const EVP_MD *digest;\n+    ENGINE *engine;             /* functional reference if 'digest' is\n+                                 * ENGINE-provided */\n+    unsigned long flags;\n+    void *md_data;\n+    /* Public key context for sign/verify */\n+    EVP_PKEY_CTX *pctx;\n+    /* Update function: usually copied from EVP_MD */\n+    int (*update) (EVP_MD_CTX *ctx, const void *data, size_t count);\n+} /* EVP_MD_CTX */ ;\n+\n+/* values for EVP_MD_CTX flags */\n+\n+# define EVP_MD_CTX_FLAG_ONESHOT         0x0001/* digest update will be\n+                                                * called once only */\n+# define EVP_MD_CTX_FLAG_CLEANED         0x0002/* context has already been\n+                                                * cleaned */\n+# define EVP_MD_CTX_FLAG_REUSE           0x0004/* Don't free up ctx->md_data\n+                                                * in EVP_MD_CTX_cleanup */\n+/*\n+ * FIPS and pad options are ignored in 1.0.0, definitions are here so we\n+ * don't accidentally reuse the values for other purposes.\n+ */\n+\n+# define EVP_MD_CTX_FLAG_NON_FIPS_ALLOW  0x0008/* Allow use of non FIPS\n+                                                * digest in FIPS mode */\n+\n+/*\n+ * The following PAD options are also currently ignored in 1.0.0, digest\n+ * parameters are handled through EVP_DigestSign*() and EVP_DigestVerify*()\n+ * instead.\n+ */\n+# define EVP_MD_CTX_FLAG_PAD_MASK        0xF0/* RSA mode to use */\n+# define EVP_MD_CTX_FLAG_PAD_PKCS1       0x00/* PKCS#1 v1.5 mode */\n+# define EVP_MD_CTX_FLAG_PAD_X931        0x10/* X9.31 mode */\n+# define EVP_MD_CTX_FLAG_PAD_PSS         0x20/* PSS mode */\n+\n+# define EVP_MD_CTX_FLAG_NO_INIT         0x0100/* Don't initialize md_data */\n+\n+struct evp_cipher_st {\n+    int nid;\n+    int block_size;\n+    /* Default value for variable length ciphers */\n+    int key_len;\n+    int iv_len;\n+    /* Various flags */\n+    unsigned long flags;\n+    /* init key */\n+    int (*init) (EVP_CIPHER_CTX *ctx, const unsigned char *key,\n+                 const unsigned char *iv, int enc);\n+    /* encrypt/decrypt data */\n+    int (*do_cipher) (EVP_CIPHER_CTX *ctx, unsigned char *out,\n+                      const unsigned char *in, size_t inl);\n+    /* cleanup ctx */\n+    int (*cleanup) (EVP_CIPHER_CTX *);\n+    /* how big ctx->cipher_data needs to be */\n+    int ctx_size;\n+    /* Populate a ASN1_TYPE with parameters */\n+    int (*set_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *);\n+    /* Get parameters from a ASN1_TYPE */\n+    int (*get_asn1_parameters) (EVP_CIPHER_CTX *, ASN1_TYPE *);\n+    /* Miscellaneous operations */\n+    int (*ctrl) (EVP_CIPHER_CTX *, int type, int arg, void *ptr);\n+    /* Application data */\n+    void *app_data;\n+} /* EVP_CIPHER */ ;\n+\n+/* Values for cipher flags */\n+\n+/* Modes for ciphers */\n+\n+# define         EVP_CIPH_STREAM_CIPHER          0x0\n+# define         EVP_CIPH_ECB_MODE               0x1\n+# define         EVP_CIPH_CBC_MODE               0x2\n+# define         EVP_CIPH_CFB_MODE               0x3\n+# define         EVP_CIPH_OFB_MODE               0x4\n+# define         EVP_CIPH_CTR_MODE               0x5\n+# define         EVP_CIPH_GCM_MODE               0x6\n+# define         EVP_CIPH_CCM_MODE               0x7\n+# define         EVP_CIPH_XTS_MODE               0x10001\n+# define         EVP_CIPH_WRAP_MODE              0x10002\n+# define         EVP_CIPH_MODE                   0xF0007\n+/* Set if variable length cipher */\n+# define         EVP_CIPH_VARIABLE_LENGTH        0x8\n+/* Set if the iv handling should be done by the cipher itself */\n+# define         EVP_CIPH_CUSTOM_IV              0x10\n+/* Set if the cipher's init() function should be called if key is NULL */\n+# define         EVP_CIPH_ALWAYS_CALL_INIT       0x20\n+/* Call ctrl() to init cipher parameters */\n+# define         EVP_CIPH_CTRL_INIT              0x40\n+/* Don't use standard key length function */\n+# define         EVP_CIPH_CUSTOM_KEY_LENGTH      0x80\n+/* Don't use standard block padding */\n+# define         EVP_CIPH_NO_PADDING             0x100\n+/* cipher handles random key generation */\n+# define         EVP_CIPH_RAND_KEY               0x200\n+/* cipher has its own additional copying logic */\n+# define         EVP_CIPH_CUSTOM_COPY            0x400\n+/* Allow use default ASN1 get/set iv */\n+# define         EVP_CIPH_FLAG_DEFAULT_ASN1      0x1000\n+/* Buffer length in bits not bytes: CFB1 mode only */\n+# define         EVP_CIPH_FLAG_LENGTH_BITS       0x2000\n+/* Note if suitable for use in FIPS mode */\n+# define         EVP_CIPH_FLAG_FIPS              0x4000\n+/* Allow non FIPS cipher in FIPS mode */\n+# define         EVP_CIPH_FLAG_NON_FIPS_ALLOW    0x8000\n+/*\n+ * Cipher handles any and all padding logic as well as finalisation.\n+ */\n+# define         EVP_CIPH_FLAG_CUSTOM_CIPHER     0x100000\n+# define         EVP_CIPH_FLAG_AEAD_CIPHER       0x200000\n+# define         EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK 0x400000\n+\n+/*\n+ * Cipher context flag to indicate we can handle wrap mode: if allowed in\n+ * older applications it could overflow buffers.\n+ */\n+\n+# define         EVP_CIPHER_CTX_FLAG_WRAP_ALLOW  0x1\n+\n+/* ctrl() values */\n+\n+# define         EVP_CTRL_INIT                   0x0\n+# define         EVP_CTRL_SET_KEY_LENGTH         0x1\n+# define         EVP_CTRL_GET_RC2_KEY_BITS       0x2\n+# define         EVP_CTRL_SET_RC2_KEY_BITS       0x3\n+# define         EVP_CTRL_GET_RC5_ROUNDS         0x4\n+# define         EVP_CTRL_SET_RC5_ROUNDS         0x5\n+# define         EVP_CTRL_RAND_KEY               0x6\n+# define         EVP_CTRL_PBE_PRF_NID            0x7\n+# define         EVP_CTRL_COPY                   0x8\n+# define         EVP_CTRL_GCM_SET_IVLEN          0x9\n+# define         EVP_CTRL_GCM_GET_TAG            0x10\n+# define         EVP_CTRL_GCM_SET_TAG            0x11\n+# define         EVP_CTRL_GCM_SET_IV_FIXED       0x12\n+# define         EVP_CTRL_GCM_IV_GEN             0x13\n+# define         EVP_CTRL_CCM_SET_IVLEN          EVP_CTRL_GCM_SET_IVLEN\n+# define         EVP_CTRL_CCM_GET_TAG            EVP_CTRL_GCM_GET_TAG\n+# define         EVP_CTRL_CCM_SET_TAG            EVP_CTRL_GCM_SET_TAG\n+# define         EVP_CTRL_CCM_SET_L              0x14\n+# define         EVP_CTRL_CCM_SET_MSGLEN         0x15\n+/*\n+ * AEAD cipher deduces payload length and returns number of bytes required to\n+ * store MAC and eventual padding. Subsequent call to EVP_Cipher even\n+ * appends/verifies MAC.\n+ */\n+# define         EVP_CTRL_AEAD_TLS1_AAD          0x16\n+/* Used by composite AEAD ciphers, no-op in GCM, CCM... */\n+# define         EVP_CTRL_AEAD_SET_MAC_KEY       0x17\n+/* Set the GCM invocation field, decrypt only */\n+# define         EVP_CTRL_GCM_SET_IV_INV         0x18\n+\n+# define         EVP_CTRL_TLS1_1_MULTIBLOCK_AAD  0x19\n+# define         EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT      0x1a\n+# define         EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT      0x1b\n+# define         EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE  0x1c\n+\n+/* RFC 5246 defines additional data to be 13 bytes in length */\n+# define         EVP_AEAD_TLS1_AAD_LEN           13\n+\n+typedef struct {\n+    unsigned char *out;\n+    const unsigned char *inp;\n+    size_t len;\n+    unsigned int interleave;\n+} EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM;\n+\n+/* GCM TLS constants */\n+/* Length of fixed part of IV derived from PRF */\n+# define EVP_GCM_TLS_FIXED_IV_LEN                        4\n+/* Length of explicit part of IV part of TLS records */\n+# define EVP_GCM_TLS_EXPLICIT_IV_LEN                     8\n+/* Length of tag for TLS */\n+# define EVP_GCM_TLS_TAG_LEN                             16\n+\n+typedef struct evp_cipher_info_st {\n+    const EVP_CIPHER *cipher;\n+    unsigned char iv[EVP_MAX_IV_LENGTH];\n+} EVP_CIPHER_INFO;\n+\n+struct evp_cipher_ctx_st {\n+    const EVP_CIPHER *cipher;\n+    ENGINE *engine;             /* functional reference if 'cipher' is\n+                                 * ENGINE-provided */\n+    int encrypt;                /* encrypt or decrypt */\n+    int buf_len;                /* number we have left */\n+    unsigned char oiv[EVP_MAX_IV_LENGTH]; /* original iv */\n+    unsigned char iv[EVP_MAX_IV_LENGTH]; /* working iv */\n+    unsigned char buf[EVP_MAX_BLOCK_LENGTH]; /* saved partial block */\n+    int num;                    /* used by cfb/ofb/ctr mode */\n+    void *app_data;             /* application stuff */\n+    int key_len;                /* May change for variable length cipher */\n+    unsigned long flags;        /* Various flags */\n+    void *cipher_data;          /* per EVP data */\n+    int final_used;\n+    int block_mask;\n+    unsigned char final[EVP_MAX_BLOCK_LENGTH]; /* possible final block */\n+} /* EVP_CIPHER_CTX */ ;\n+\n+typedef struct evp_Encode_Ctx_st {\n+    /* number saved in a partial encode/decode */\n+    int num;\n+    /*\n+     * The length is either the output line length (in input bytes) or the\n+     * shortest input line length that is ok.  Once decoding begins, the\n+     * length is adjusted up each time a longer line is decoded\n+     */\n+    int length;\n+    /* data to encode */\n+    unsigned char enc_data[80];\n+    /* number read on current line */\n+    int line_num;\n+    int expect_nl;\n+} EVP_ENCODE_CTX;\n+\n+/* Password based encryption function */\n+typedef int (EVP_PBE_KEYGEN) (EVP_CIPHER_CTX *ctx, const char *pass,\n+                              int passlen, ASN1_TYPE *param,\n+                              const EVP_CIPHER *cipher, const EVP_MD *md,\n+                              int en_de);\n+\n+# ifndef OPENSSL_NO_RSA\n+#  define EVP_PKEY_assign_RSA(pkey,rsa) EVP_PKEY_assign((pkey),EVP_PKEY_RSA,\\\n+                                        (char *)(rsa))\n+# endif\n+\n+# ifndef OPENSSL_NO_DSA\n+#  define EVP_PKEY_assign_DSA(pkey,dsa) EVP_PKEY_assign((pkey),EVP_PKEY_DSA,\\\n+                                        (char *)(dsa))\n+# endif\n+\n+# ifndef OPENSSL_NO_DH\n+#  define EVP_PKEY_assign_DH(pkey,dh) EVP_PKEY_assign((pkey),EVP_PKEY_DH,\\\n+                                        (char *)(dh))\n+# endif\n+\n+# ifndef OPENSSL_NO_EC\n+#  define EVP_PKEY_assign_EC_KEY(pkey,eckey) EVP_PKEY_assign((pkey),EVP_PKEY_EC,\\\n+                                        (char *)(eckey))\n+# endif\n+\n+/* Add some extra combinations */\n+# define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))\n+# define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))\n+# define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))\n+# define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))\n+\n+int EVP_MD_type(const EVP_MD *md);\n+# define EVP_MD_nid(e)                   EVP_MD_type(e)\n+# define EVP_MD_name(e)                  OBJ_nid2sn(EVP_MD_nid(e))\n+int EVP_MD_pkey_type(const EVP_MD *md);\n+int EVP_MD_size(const EVP_MD *md);\n+int EVP_MD_block_size(const EVP_MD *md);\n+unsigned long EVP_MD_flags(const EVP_MD *md);\n+\n+const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);\n+# define EVP_MD_CTX_size(e)              EVP_MD_size(EVP_MD_CTX_md(e))\n+# define EVP_MD_CTX_block_size(e)        EVP_MD_block_size(EVP_MD_CTX_md(e))\n+# define EVP_MD_CTX_type(e)              EVP_MD_type(EVP_MD_CTX_md(e))\n+\n+int EVP_CIPHER_nid(const EVP_CIPHER *cipher);\n+# define EVP_CIPHER_name(e)              OBJ_nid2sn(EVP_CIPHER_nid(e))\n+int EVP_CIPHER_block_size(const EVP_CIPHER *cipher);\n+int EVP_CIPHER_key_length(const EVP_CIPHER *cipher);\n+int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);\n+unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher);\n+# define EVP_CIPHER_mode(e)              (EVP_CIPHER_flags(e) & EVP_CIPH_MODE)\n+\n+const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);\n+int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);\n+int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);\n+int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);\n+int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);\n+int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in);\n+void *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);\n+void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data);\n+# define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))\n+unsigned long EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx);\n+# define EVP_CIPHER_CTX_mode(e)          (EVP_CIPHER_CTX_flags(e) & EVP_CIPH_MODE)\n+\n+# define EVP_ENCODE_LENGTH(l)    (((l+2)/3*4)+(l/48+1)*2+80)\n+# define EVP_DECODE_LENGTH(l)    ((l+3)/4*3+80)\n+\n+# define EVP_SignInit_ex(a,b,c)          EVP_DigestInit_ex(a,b,c)\n+# define EVP_SignInit(a,b)               EVP_DigestInit(a,b)\n+# define EVP_SignUpdate(a,b,c)           EVP_DigestUpdate(a,b,c)\n+# define EVP_VerifyInit_ex(a,b,c)        EVP_DigestInit_ex(a,b,c)\n+# define EVP_VerifyInit(a,b)             EVP_DigestInit(a,b)\n+# define EVP_VerifyUpdate(a,b,c)         EVP_DigestUpdate(a,b,c)\n+# define EVP_OpenUpdate(a,b,c,d,e)       EVP_DecryptUpdate(a,b,c,d,e)\n+# define EVP_SealUpdate(a,b,c,d,e)       EVP_EncryptUpdate(a,b,c,d,e)\n+# define EVP_DigestSignUpdate(a,b,c)     EVP_DigestUpdate(a,b,c)\n+# define EVP_DigestVerifyUpdate(a,b,c)   EVP_DigestUpdate(a,b,c)\n+\n+# ifdef CONST_STRICT\n+void BIO_set_md(BIO *, const EVP_MD *md);\n+# else\n+#  define BIO_set_md(b,md)               BIO_ctrl(b,BIO_C_SET_MD,0,(char *)md)\n+# endif\n+# define BIO_get_md(b,mdp)               BIO_ctrl(b,BIO_C_GET_MD,0,(char *)mdp)\n+# define BIO_get_md_ctx(b,mdcp)     BIO_ctrl(b,BIO_C_GET_MD_CTX,0,(char *)mdcp)\n+# define BIO_set_md_ctx(b,mdcp)     BIO_ctrl(b,BIO_C_SET_MD_CTX,0,(char *)mdcp)\n+# define BIO_get_cipher_status(b)        BIO_ctrl(b,BIO_C_GET_CIPHER_STATUS,0,NULL)\n+# define BIO_get_cipher_ctx(b,c_pp)      BIO_ctrl(b,BIO_C_GET_CIPHER_CTX,0,(char *)c_pp)\n+\n+int EVP_Cipher(EVP_CIPHER_CTX *c,\n+               unsigned char *out, const unsigned char *in, unsigned int inl);\n+\n+# define EVP_add_cipher_alias(n,alias) \\\n+        OBJ_NAME_add((alias),OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS,(n))\n+# define EVP_add_digest_alias(n,alias) \\\n+        OBJ_NAME_add((alias),OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS,(n))\n+# define EVP_delete_cipher_alias(alias) \\\n+        OBJ_NAME_remove(alias,OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS);\n+# define EVP_delete_digest_alias(alias) \\\n+        OBJ_NAME_remove(alias,OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS);\n+\n+void EVP_MD_CTX_init(EVP_MD_CTX *ctx);\n+int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);\n+EVP_MD_CTX *EVP_MD_CTX_create(void);\n+void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);\n+int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in);\n+void EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags);\n+void EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags);\n+int EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx, int flags);\n+int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);\n+int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);\n+int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);\n+int EVP_Digest(const void *data, size_t count,\n+               unsigned char *md, unsigned int *size, const EVP_MD *type,\n+               ENGINE *impl);\n+\n+int EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in);\n+int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);\n+int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);\n+\n+int EVP_read_pw_string(char *buf, int length, const char *prompt, int verify);\n+int EVP_read_pw_string_min(char *buf, int minlen, int maxlen,\n+                           const char *prompt, int verify);\n+void EVP_set_pw_prompt(const char *prompt);\n+char *EVP_get_pw_prompt(void);\n+\n+int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,\n+                   const unsigned char *salt, const unsigned char *data,\n+                   int datal, int count, unsigned char *key,\n+                   unsigned char *iv);\n+\n+void EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags);\n+void EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags);\n+int EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx, int flags);\n+\n+int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\n+                    const unsigned char *key, const unsigned char *iv);\n+int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\n+                       ENGINE *impl, const unsigned char *key,\n+                       const unsigned char *iv);\n+int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n+                      const unsigned char *in, int inl);\n+int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);\n+int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);\n+\n+int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\n+                    const unsigned char *key, const unsigned char *iv);\n+int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\n+                       ENGINE *impl, const unsigned char *key,\n+                       const unsigned char *iv);\n+int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n+                      const unsigned char *in, int inl);\n+int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);\n+int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);\n+\n+int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\n+                   const unsigned char *key, const unsigned char *iv,\n+                   int enc);\n+int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\n+                      ENGINE *impl, const unsigned char *key,\n+                      const unsigned char *iv, int enc);\n+int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n+                     const unsigned char *in, int inl);\n+int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);\n+int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);\n+\n+int EVP_SignFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s,\n+                  EVP_PKEY *pkey);\n+\n+int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf,\n+                    unsigned int siglen, EVP_PKEY *pkey);\n+\n+int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n+                       const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\n+int EVP_DigestSignFinal(EVP_MD_CTX *ctx,\n+                        unsigned char *sigret, size_t *siglen);\n+\n+int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\n+                         const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);\n+int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx,\n+                          const unsigned char *sig, size_t siglen);\n+\n+int EVP_OpenInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n+                 const unsigned char *ek, int ekl, const unsigned char *iv,\n+                 EVP_PKEY *priv);\n+int EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);\n+\n+int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\n+                 unsigned char **ek, int *ekl, unsigned char *iv,\n+                 EVP_PKEY **pubk, int npubk);\n+int EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);\n+\n+void EVP_EncodeInit(EVP_ENCODE_CTX *ctx);\n+void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n+                      const unsigned char *in, int inl);\n+void EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl);\n+int EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);\n+\n+void EVP_DecodeInit(EVP_ENCODE_CTX *ctx);\n+int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n+                     const unsigned char *in, int inl);\n+int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned\n+                    char *out, int *outl);\n+int EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);\n+\n+void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);\n+int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);\n+EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);\n+void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a);\n+int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);\n+int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad);\n+int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);\n+int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);\n+\n+# ifndef OPENSSL_NO_BIO\n+BIO_METHOD *BIO_f_md(void);\n+BIO_METHOD *BIO_f_base64(void);\n+BIO_METHOD *BIO_f_cipher(void);\n+BIO_METHOD *BIO_f_reliable(void);\n+void BIO_set_cipher(BIO *b, const EVP_CIPHER *c, const unsigned char *k,\n+                    const unsigned char *i, int enc);\n+# endif\n+\n+const EVP_MD *EVP_md_null(void);\n+# ifndef OPENSSL_NO_MD2\n+const EVP_MD *EVP_md2(void);\n+# endif\n+# ifndef OPENSSL_NO_MD4\n+const EVP_MD *EVP_md4(void);\n+# endif\n+# ifndef OPENSSL_NO_MD5\n+const EVP_MD *EVP_md5(void);\n+# endif\n+# ifndef OPENSSL_NO_SHA\n+const EVP_MD *EVP_sha(void);\n+const EVP_MD *EVP_sha1(void);\n+const EVP_MD *EVP_dss(void);\n+const EVP_MD *EVP_dss1(void);\n+const EVP_MD *EVP_ecdsa(void);\n+# endif\n+# ifndef OPENSSL_NO_SHA256\n+const EVP_MD *EVP_sha224(void);\n+const EVP_MD *EVP_sha256(void);\n+# endif\n+# ifndef OPENSSL_NO_SHA512\n+const EVP_MD *EVP_sha384(void);\n+const EVP_MD *EVP_sha512(void);\n+# endif\n+# ifndef OPENSSL_NO_MDC2\n+const EVP_MD *EVP_mdc2(void);\n+# endif\n+# ifndef OPENSSL_NO_RIPEMD\n+const EVP_MD *EVP_ripemd160(void);\n+# endif\n+# ifndef OPENSSL_NO_WHIRLPOOL\n+const EVP_MD *EVP_whirlpool(void);\n+# endif\n+const EVP_CIPHER *EVP_enc_null(void); /* does nothing :-) */\n+# ifndef OPENSSL_NO_DES\n+const EVP_CIPHER *EVP_des_ecb(void);\n+const EVP_CIPHER *EVP_des_ede(void);\n+const EVP_CIPHER *EVP_des_ede3(void);\n+const EVP_CIPHER *EVP_des_ede_ecb(void);\n+const EVP_CIPHER *EVP_des_ede3_ecb(void);\n+const EVP_CIPHER *EVP_des_cfb64(void);\n+#  define EVP_des_cfb EVP_des_cfb64\n+const EVP_CIPHER *EVP_des_cfb1(void);\n+const EVP_CIPHER *EVP_des_cfb8(void);\n+const EVP_CIPHER *EVP_des_ede_cfb64(void);\n+#  define EVP_des_ede_cfb EVP_des_ede_cfb64\n+#  if 0\n+const EVP_CIPHER *EVP_des_ede_cfb1(void);\n+const EVP_CIPHER *EVP_des_ede_cfb8(void);\n+#  endif\n+const EVP_CIPHER *EVP_des_ede3_cfb64(void);\n+#  define EVP_des_ede3_cfb EVP_des_ede3_cfb64\n+const EVP_CIPHER *EVP_des_ede3_cfb1(void);\n+const EVP_CIPHER *EVP_des_ede3_cfb8(void);\n+const EVP_CIPHER *EVP_des_ofb(void);\n+const EVP_CIPHER *EVP_des_ede_ofb(void);\n+const EVP_CIPHER *EVP_des_ede3_ofb(void);\n+const EVP_CIPHER *EVP_des_cbc(void);\n+const EVP_CIPHER *EVP_des_ede_cbc(void);\n+const EVP_CIPHER *EVP_des_ede3_cbc(void);\n+const EVP_CIPHER *EVP_desx_cbc(void);\n+const EVP_CIPHER *EVP_des_ede3_wrap(void);\n+/*\n+ * This should now be supported through the dev_crypto ENGINE. But also, why\n+ * are rc4 and md5 declarations made here inside a \"NO_DES\" precompiler\n+ * branch?\n+ */\n+#  if 0\n+#   ifdef OPENSSL_OPENBSD_DEV_CRYPTO\n+const EVP_CIPHER *EVP_dev_crypto_des_ede3_cbc(void);\n+const EVP_CIPHER *EVP_dev_crypto_rc4(void);\n+const EVP_MD *EVP_dev_crypto_md5(void);\n+#   endif\n+#  endif\n+# endif\n+# ifndef OPENSSL_NO_RC4\n+const EVP_CIPHER *EVP_rc4(void);\n+const EVP_CIPHER *EVP_rc4_40(void);\n+#  ifndef OPENSSL_NO_MD5\n+const EVP_CIPHER *EVP_rc4_hmac_md5(void);\n+#  endif\n+# endif\n+# ifndef OPENSSL_NO_IDEA\n+const EVP_CIPHER *EVP_idea_ecb(void);\n+const EVP_CIPHER *EVP_idea_cfb64(void);\n+#  define EVP_idea_cfb EVP_idea_cfb64\n+const EVP_CIPHER *EVP_idea_ofb(void);\n+const EVP_CIPHER *EVP_idea_cbc(void);\n+# endif\n+# ifndef OPENSSL_NO_RC2\n+const EVP_CIPHER *EVP_rc2_ecb(void);\n+const EVP_CIPHER *EVP_rc2_cbc(void);\n+const EVP_CIPHER *EVP_rc2_40_cbc(void);\n+const EVP_CIPHER *EVP_rc2_64_cbc(void);\n+const EVP_CIPHER *EVP_rc2_cfb64(void);\n+#  define EVP_rc2_cfb EVP_rc2_cfb64\n+const EVP_CIPHER *EVP_rc2_ofb(void);\n+# endif\n+# ifndef OPENSSL_NO_BF\n+const EVP_CIPHER *EVP_bf_ecb(void);\n+const EVP_CIPHER *EVP_bf_cbc(void);\n+const EVP_CIPHER *EVP_bf_cfb64(void);\n+#  define EVP_bf_cfb EVP_bf_cfb64\n+const EVP_CIPHER *EVP_bf_ofb(void);\n+# endif\n+# ifndef OPENSSL_NO_CAST\n+const EVP_CIPHER *EVP_cast5_ecb(void);\n+const EVP_CIPHER *EVP_cast5_cbc(void);\n+const EVP_CIPHER *EVP_cast5_cfb64(void);\n+#  define EVP_cast5_cfb EVP_cast5_cfb64\n+const EVP_CIPHER *EVP_cast5_ofb(void);\n+# endif\n+# ifndef OPENSSL_NO_RC5\n+const EVP_CIPHER *EVP_rc5_32_12_16_cbc(void);\n+const EVP_CIPHER *EVP_rc5_32_12_16_ecb(void);\n+const EVP_CIPHER *EVP_rc5_32_12_16_cfb64(void);\n+#  define EVP_rc5_32_12_16_cfb EVP_rc5_32_12_16_cfb64\n+const EVP_CIPHER *EVP_rc5_32_12_16_ofb(void);\n+# endif\n+# ifndef OPENSSL_NO_AES\n+const EVP_CIPHER *EVP_aes_128_ecb(void);\n+const EVP_CIPHER *EVP_aes_128_cbc(void);\n+const EVP_CIPHER *EVP_aes_128_cfb1(void);\n+const EVP_CIPHER *EVP_aes_128_cfb8(void);\n+const EVP_CIPHER *EVP_aes_128_cfb128(void);\n+#  define EVP_aes_128_cfb EVP_aes_128_cfb128\n+const EVP_CIPHER *EVP_aes_128_ofb(void);\n+const EVP_CIPHER *EVP_aes_128_ctr(void);\n+const EVP_CIPHER *EVP_aes_128_ccm(void);\n+const EVP_CIPHER *EVP_aes_128_gcm(void);\n+const EVP_CIPHER *EVP_aes_128_xts(void);\n+const EVP_CIPHER *EVP_aes_128_wrap(void);\n+const EVP_CIPHER *EVP_aes_192_ecb(void);\n+const EVP_CIPHER *EVP_aes_192_cbc(void);\n+const EVP_CIPHER *EVP_aes_192_cfb1(void);\n+const EVP_CIPHER *EVP_aes_192_cfb8(void);\n+const EVP_CIPHER *EVP_aes_192_cfb128(void);\n+#  define EVP_aes_192_cfb EVP_aes_192_cfb128\n+const EVP_CIPHER *EVP_aes_192_ofb(void);\n+const EVP_CIPHER *EVP_aes_192_ctr(void);\n+const EVP_CIPHER *EVP_aes_192_ccm(void);\n+const EVP_CIPHER *EVP_aes_192_gcm(void);\n+const EVP_CIPHER *EVP_aes_192_wrap(void);\n+const EVP_CIPHER *EVP_aes_256_ecb(void);\n+const EVP_CIPHER *EVP_aes_256_cbc(void);\n+const EVP_CIPHER *EVP_aes_256_cfb1(void);\n+const EVP_CIPHER *EVP_aes_256_cfb8(void);\n+const EVP_CIPHER *EVP_aes_256_cfb128(void);\n+#  define EVP_aes_256_cfb EVP_aes_256_cfb128\n+const EVP_CIPHER *EVP_aes_256_ofb(void);\n+const EVP_CIPHER *EVP_aes_256_ctr(void);\n+const EVP_CIPHER *EVP_aes_256_ccm(void);\n+const EVP_CIPHER *EVP_aes_256_gcm(void);\n+const EVP_CIPHER *EVP_aes_256_xts(void);\n+const EVP_CIPHER *EVP_aes_256_wrap(void);\n+#  if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)\n+const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void);\n+const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void);\n+#  endif\n+#  ifndef OPENSSL_NO_SHA256\n+const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha256(void);\n+const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void);\n+#  endif\n+# endif\n+# ifndef OPENSSL_NO_CAMELLIA\n+const EVP_CIPHER *EVP_camellia_128_ecb(void);\n+const EVP_CIPHER *EVP_camellia_128_cbc(void);\n+const EVP_CIPHER *EVP_camellia_128_cfb1(void);\n+const EVP_CIPHER *EVP_camellia_128_cfb8(void);\n+const EVP_CIPHER *EVP_camellia_128_cfb128(void);\n+#  define EVP_camellia_128_cfb EVP_camellia_128_cfb128\n+const EVP_CIPHER *EVP_camellia_128_ofb(void);\n+const EVP_CIPHER *EVP_camellia_192_ecb(void);\n+const EVP_CIPHER *EVP_camellia_192_cbc(void);\n+const EVP_CIPHER *EVP_camellia_192_cfb1(void);\n+const EVP_CIPHER *EVP_camellia_192_cfb8(void);\n+const EVP_CIPHER *EVP_camellia_192_cfb128(void);\n+#  define EVP_camellia_192_cfb EVP_camellia_192_cfb128\n+const EVP_CIPHER *EVP_camellia_192_ofb(void);\n+const EVP_CIPHER *EVP_camellia_256_ecb(void);\n+const EVP_CIPHER *EVP_camellia_256_cbc(void);\n+const EVP_CIPHER *EVP_camellia_256_cfb1(void);\n+const EVP_CIPHER *EVP_camellia_256_cfb8(void);\n+const EVP_CIPHER *EVP_camellia_256_cfb128(void);\n+#  define EVP_camellia_256_cfb EVP_camellia_256_cfb128\n+const EVP_CIPHER *EVP_camellia_256_ofb(void);\n+# endif\n+\n+# ifndef OPENSSL_NO_SEED\n+const EVP_CIPHER *EVP_seed_ecb(void);\n+const EVP_CIPHER *EVP_seed_cbc(void);\n+const EVP_CIPHER *EVP_seed_cfb128(void);\n+#  define EVP_seed_cfb EVP_seed_cfb128\n+const EVP_CIPHER *EVP_seed_ofb(void);\n+# endif\n+\n+void OPENSSL_add_all_algorithms_noconf(void);\n+void OPENSSL_add_all_algorithms_conf(void);\n+\n+# ifdef OPENSSL_LOAD_CONF\n+#  define OpenSSL_add_all_algorithms() \\\n+                OPENSSL_add_all_algorithms_conf()\n+# else\n+#  define OpenSSL_add_all_algorithms() \\\n+                OPENSSL_add_all_algorithms_noconf()\n+# endif\n+\n+void OpenSSL_add_all_ciphers(void);\n+void OpenSSL_add_all_digests(void);\n+# define SSLeay_add_all_algorithms() OpenSSL_add_all_algorithms()\n+# define SSLeay_add_all_ciphers() OpenSSL_add_all_ciphers()\n+# define SSLeay_add_all_digests() OpenSSL_add_all_digests()\n+\n+int EVP_add_cipher(const EVP_CIPHER *cipher);\n+int EVP_add_digest(const EVP_MD *digest);\n+\n+const EVP_CIPHER *EVP_get_cipherbyname(const char *name);\n+const EVP_MD *EVP_get_digestbyname(const char *name);\n+void EVP_cleanup(void);\n+\n+void EVP_CIPHER_do_all(void (*fn) (const EVP_CIPHER *ciph,\n+                                   const char *from, const char *to, void *x),\n+                       void *arg);\n+void EVP_CIPHER_do_all_sorted(void (*fn)\n+                               (const EVP_CIPHER *ciph, const char *from,\n+                                const char *to, void *x), void *arg);\n+\n+void EVP_MD_do_all(void (*fn) (const EVP_MD *ciph,\n+                               const char *from, const char *to, void *x),\n+                   void *arg);\n+void EVP_MD_do_all_sorted(void (*fn)\n+                           (const EVP_MD *ciph, const char *from,\n+                            const char *to, void *x), void *arg);\n+\n+int EVP_PKEY_decrypt_old(unsigned char *dec_key,\n+                         const unsigned char *enc_key, int enc_key_len,\n+                         EVP_PKEY *private_key);\n+int EVP_PKEY_encrypt_old(unsigned char *enc_key,\n+                         const unsigned char *key, int key_len,\n+                         EVP_PKEY *pub_key);\n+int EVP_PKEY_type(int type);\n+int EVP_PKEY_id(const EVP_PKEY *pkey);\n+int EVP_PKEY_base_id(const EVP_PKEY *pkey);\n+int EVP_PKEY_bits(EVP_PKEY *pkey);\n+int EVP_PKEY_size(EVP_PKEY *pkey);\n+int EVP_PKEY_set_type(EVP_PKEY *pkey, int type);\n+int EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len);\n+int EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key);\n+void *EVP_PKEY_get0(EVP_PKEY *pkey);\n+\n+# ifndef OPENSSL_NO_RSA\n+struct rsa_st;\n+int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, struct rsa_st *key);\n+struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);\n+# endif\n+# ifndef OPENSSL_NO_DSA\n+struct dsa_st;\n+int EVP_PKEY_set1_DSA(EVP_PKEY *pkey, struct dsa_st *key);\n+struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);\n+# endif\n+# ifndef OPENSSL_NO_DH\n+struct dh_st;\n+int EVP_PKEY_set1_DH(EVP_PKEY *pkey, struct dh_st *key);\n+struct dh_st *EVP_PKEY_get1_DH(EVP_PKEY *pkey);\n+# endif\n+# ifndef OPENSSL_NO_EC\n+struct ec_key_st;\n+int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, struct ec_key_st *key);\n+struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);\n+# endif\n+\n+EVP_PKEY *EVP_PKEY_new(void);\n+void EVP_PKEY_free(EVP_PKEY *pkey);\n+\n+EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,\n+                        long length);\n+int i2d_PublicKey(EVP_PKEY *a, unsigned char **pp);\n+\n+EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,\n+                         long length);\n+EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,\n+                             long length);\n+int i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp);\n+\n+int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);\n+int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);\n+int EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode);\n+int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);\n+\n+int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);\n+\n+int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,\n+                          int indent, ASN1_PCTX *pctx);\n+int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,\n+                           int indent, ASN1_PCTX *pctx);\n+int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,\n+                          int indent, ASN1_PCTX *pctx);\n+\n+int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);\n+\n+int EVP_CIPHER_type(const EVP_CIPHER *ctx);\n+\n+/* calls methods */\n+int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n+int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n+\n+/* These are used by EVP_CIPHER methods */\n+int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n+int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type);\n+\n+/* PKCS5 password based encryption */\n+int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\n+                       ASN1_TYPE *param, const EVP_CIPHER *cipher,\n+                       const EVP_MD *md, int en_de);\n+int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,\n+                           const unsigned char *salt, int saltlen, int iter,\n+                           int keylen, unsigned char *out);\n+int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,\n+                      const unsigned char *salt, int saltlen, int iter,\n+                      const EVP_MD *digest, int keylen, unsigned char *out);\n+int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\n+                          ASN1_TYPE *param, const EVP_CIPHER *cipher,\n+                          const EVP_MD *md, int en_de);\n+\n+void PKCS5_PBE_add(void);\n+\n+int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\n+                       ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de);\n+\n+/* PBE type */\n+\n+/* Can appear as the outermost AlgorithmIdentifier */\n+# define EVP_PBE_TYPE_OUTER      0x0\n+/* Is an PRF type OID */\n+# define EVP_PBE_TYPE_PRF        0x1\n+\n+int EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid,\n+                         int md_nid, EVP_PBE_KEYGEN *keygen);\n+int EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,\n+                    EVP_PBE_KEYGEN *keygen);\n+int EVP_PBE_find(int type, int pbe_nid, int *pcnid, int *pmnid,\n+                 EVP_PBE_KEYGEN **pkeygen);\n+void EVP_PBE_cleanup(void);\n+\n+# define ASN1_PKEY_ALIAS         0x1\n+# define ASN1_PKEY_DYNAMIC       0x2\n+# define ASN1_PKEY_SIGPARAM_NULL 0x4\n+\n+# define ASN1_PKEY_CTRL_PKCS7_SIGN       0x1\n+# define ASN1_PKEY_CTRL_PKCS7_ENCRYPT    0x2\n+# define ASN1_PKEY_CTRL_DEFAULT_MD_NID   0x3\n+# define ASN1_PKEY_CTRL_CMS_SIGN         0x5\n+# define ASN1_PKEY_CTRL_CMS_ENVELOPE     0x7\n+# define ASN1_PKEY_CTRL_CMS_RI_TYPE      0x8\n+\n+int EVP_PKEY_asn1_get_count(void);\n+const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx);\n+const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type);\n+const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe,\n+                                                   const char *str, int len);\n+int EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth);\n+int EVP_PKEY_asn1_add_alias(int to, int from);\n+int EVP_PKEY_asn1_get0_info(int *ppkey_id, int *pkey_base_id,\n+                            int *ppkey_flags, const char **pinfo,\n+                            const char **ppem_str,\n+                            const EVP_PKEY_ASN1_METHOD *ameth);\n+\n+const EVP_PKEY_ASN1_METHOD *EVP_PKEY_get0_asn1(EVP_PKEY *pkey);\n+EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_new(int id, int flags,\n+                                        const char *pem_str,\n+                                        const char *info);\n+void EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst,\n+                        const EVP_PKEY_ASN1_METHOD *src);\n+void EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth);\n+void EVP_PKEY_asn1_set_public(EVP_PKEY_ASN1_METHOD *ameth,\n+                              int (*pub_decode) (EVP_PKEY *pk,\n+                                                 X509_PUBKEY *pub),\n+                              int (*pub_encode) (X509_PUBKEY *pub,\n+                                                 const EVP_PKEY *pk),\n+                              int (*pub_cmp) (const EVP_PKEY *a,\n+                                              const EVP_PKEY *b),\n+                              int (*pub_print) (BIO *out,\n+                                                const EVP_PKEY *pkey,\n+                                                int indent, ASN1_PCTX *pctx),\n+                              int (*pkey_size) (const EVP_PKEY *pk),\n+                              int (*pkey_bits) (const EVP_PKEY *pk));\n+void EVP_PKEY_asn1_set_private(EVP_PKEY_ASN1_METHOD *ameth,\n+                               int (*priv_decode) (EVP_PKEY *pk,\n+                                                   PKCS8_PRIV_KEY_INFO\n+                                                   *p8inf),\n+                               int (*priv_encode) (PKCS8_PRIV_KEY_INFO *p8,\n+                                                   const EVP_PKEY *pk),\n+                               int (*priv_print) (BIO *out,\n+                                                  const EVP_PKEY *pkey,\n+                                                  int indent,\n+                                                  ASN1_PCTX *pctx));\n+void EVP_PKEY_asn1_set_param(EVP_PKEY_ASN1_METHOD *ameth,\n+                             int (*param_decode) (EVP_PKEY *pkey,\n+                                                  const unsigned char **pder,\n+                                                  int derlen),\n+                             int (*param_encode) (const EVP_PKEY *pkey,\n+                                                  unsigned char **pder),\n+                             int (*param_missing) (const EVP_PKEY *pk),\n+                             int (*param_copy) (EVP_PKEY *to,\n+                                                const EVP_PKEY *from),\n+                             int (*param_cmp) (const EVP_PKEY *a,\n+                                               const EVP_PKEY *b),\n+                             int (*param_print) (BIO *out,\n+                                                 const EVP_PKEY *pkey,\n+                                                 int indent,\n+                                                 ASN1_PCTX *pctx));\n+\n+void EVP_PKEY_asn1_set_free(EVP_PKEY_ASN1_METHOD *ameth,\n+                            void (*pkey_free) (EVP_PKEY *pkey));\n+void EVP_PKEY_asn1_set_ctrl(EVP_PKEY_ASN1_METHOD *ameth,\n+                            int (*pkey_ctrl) (EVP_PKEY *pkey, int op,\n+                                              long arg1, void *arg2));\n+void EVP_PKEY_asn1_set_item(EVP_PKEY_ASN1_METHOD *ameth,\n+                            int (*item_verify) (EVP_MD_CTX *ctx,\n+                                                const ASN1_ITEM *it,\n+                                                void *asn,\n+                                                X509_ALGOR *a,\n+                                                ASN1_BIT_STRING *sig,\n+                                                EVP_PKEY *pkey),\n+                            int (*item_sign) (EVP_MD_CTX *ctx,\n+                                              const ASN1_ITEM *it,\n+                                              void *asn,\n+                                              X509_ALGOR *alg1,\n+                                              X509_ALGOR *alg2,\n+                                              ASN1_BIT_STRING *sig));\n+\n+# define EVP_PKEY_OP_UNDEFINED           0\n+# define EVP_PKEY_OP_PARAMGEN            (1<<1)\n+# define EVP_PKEY_OP_KEYGEN              (1<<2)\n+# define EVP_PKEY_OP_SIGN                (1<<3)\n+# define EVP_PKEY_OP_VERIFY              (1<<4)\n+# define EVP_PKEY_OP_VERIFYRECOVER       (1<<5)\n+# define EVP_PKEY_OP_SIGNCTX             (1<<6)\n+# define EVP_PKEY_OP_VERIFYCTX           (1<<7)\n+# define EVP_PKEY_OP_ENCRYPT             (1<<8)\n+# define EVP_PKEY_OP_DECRYPT             (1<<9)\n+# define EVP_PKEY_OP_DERIVE              (1<<10)\n+\n+# define EVP_PKEY_OP_TYPE_SIG    \\\n+        (EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY | EVP_PKEY_OP_VERIFYRECOVER \\\n+                | EVP_PKEY_OP_SIGNCTX | EVP_PKEY_OP_VERIFYCTX)\n+\n+# define EVP_PKEY_OP_TYPE_CRYPT \\\n+        (EVP_PKEY_OP_ENCRYPT | EVP_PKEY_OP_DECRYPT)\n+\n+# define EVP_PKEY_OP_TYPE_NOGEN \\\n+        (EVP_PKEY_OP_SIG | EVP_PKEY_OP_CRYPT | EVP_PKEY_OP_DERIVE)\n+\n+# define EVP_PKEY_OP_TYPE_GEN \\\n+                (EVP_PKEY_OP_PARAMGEN | EVP_PKEY_OP_KEYGEN)\n+\n+# define  EVP_PKEY_CTX_set_signature_md(ctx, md) \\\n+                EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_TYPE_SIG,  \\\n+                                        EVP_PKEY_CTRL_MD, 0, (void *)md)\n+\n+# define  EVP_PKEY_CTX_get_signature_md(ctx, pmd)        \\\n+                EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_TYPE_SIG,  \\\n+                                        EVP_PKEY_CTRL_GET_MD, 0, (void *)pmd)\n+\n+# define EVP_PKEY_CTRL_MD                1\n+# define EVP_PKEY_CTRL_PEER_KEY          2\n+\n+# define EVP_PKEY_CTRL_PKCS7_ENCRYPT     3\n+# define EVP_PKEY_CTRL_PKCS7_DECRYPT     4\n+\n+# define EVP_PKEY_CTRL_PKCS7_SIGN        5\n+\n+# define EVP_PKEY_CTRL_SET_MAC_KEY       6\n+\n+# define EVP_PKEY_CTRL_DIGESTINIT        7\n+\n+/* Used by GOST key encryption in TLS */\n+# define EVP_PKEY_CTRL_SET_IV            8\n+\n+# define EVP_PKEY_CTRL_CMS_ENCRYPT       9\n+# define EVP_PKEY_CTRL_CMS_DECRYPT       10\n+# define EVP_PKEY_CTRL_CMS_SIGN          11\n+\n+# define EVP_PKEY_CTRL_CIPHER            12\n+\n+# define EVP_PKEY_CTRL_GET_MD            13\n+\n+# define EVP_PKEY_ALG_CTRL               0x1000\n+\n+# define EVP_PKEY_FLAG_AUTOARGLEN        2\n+/*\n+ * Method handles all operations: don't assume any digest related defaults.\n+ */\n+# define EVP_PKEY_FLAG_SIGCTX_CUSTOM     4\n+\n+const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type);\n+EVP_PKEY_METHOD *EVP_PKEY_meth_new(int id, int flags);\n+void EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,\n+                             const EVP_PKEY_METHOD *meth);\n+void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src);\n+void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth);\n+int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth);\n+\n+EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);\n+EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);\n+EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);\n+void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);\n+\n+int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,\n+                      int cmd, int p1, void *p2);\n+int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,\n+                          const char *value);\n+\n+int EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx);\n+void EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen);\n+\n+EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,\n+                               const unsigned char *key, int keylen);\n+\n+void EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data);\n+void *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx);\n+EVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx);\n+\n+EVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx);\n+\n+void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);\n+void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);\n+\n+int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);\n+int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\n+                  unsigned char *sig, size_t *siglen,\n+                  const unsigned char *tbs, size_t tbslen);\n+int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);\n+int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\n+                    const unsigned char *sig, size_t siglen,\n+                    const unsigned char *tbs, size_t tbslen);\n+int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);\n+int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,\n+                            unsigned char *rout, size_t *routlen,\n+                            const unsigned char *sig, size_t siglen);\n+int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);\n+int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\n+                     unsigned char *out, size_t *outlen,\n+                     const unsigned char *in, size_t inlen);\n+int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);\n+int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\n+                     unsigned char *out, size_t *outlen,\n+                     const unsigned char *in, size_t inlen);\n+\n+int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);\n+int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);\n+int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);\n+\n+typedef int EVP_PKEY_gen_cb (EVP_PKEY_CTX *ctx);\n+\n+int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);\n+int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n+int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);\n+int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);\n+\n+void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);\n+EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);\n+\n+int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);\n+\n+void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,\n+                            int (*init) (EVP_PKEY_CTX *ctx));\n+\n+void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,\n+                            int (*copy) (EVP_PKEY_CTX *dst,\n+                                         EVP_PKEY_CTX *src));\n+\n+void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,\n+                               void (*cleanup) (EVP_PKEY_CTX *ctx));\n+\n+void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,\n+                                int (*paramgen_init) (EVP_PKEY_CTX *ctx),\n+                                int (*paramgen) (EVP_PKEY_CTX *ctx,\n+                                                 EVP_PKEY *pkey));\n+\n+void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,\n+                              int (*keygen_init) (EVP_PKEY_CTX *ctx),\n+                              int (*keygen) (EVP_PKEY_CTX *ctx,\n+                                             EVP_PKEY *pkey));\n+\n+void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,\n+                            int (*sign_init) (EVP_PKEY_CTX *ctx),\n+                            int (*sign) (EVP_PKEY_CTX *ctx,\n+                                         unsigned char *sig, size_t *siglen,\n+                                         const unsigned char *tbs,\n+                                         size_t tbslen));\n+\n+void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,\n+                              int (*verify_init) (EVP_PKEY_CTX *ctx),\n+                              int (*verify) (EVP_PKEY_CTX *ctx,\n+                                             const unsigned char *sig,\n+                                             size_t siglen,\n+                                             const unsigned char *tbs,\n+                                             size_t tbslen));\n+\n+void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,\n+                                      int (*verify_recover_init) (EVP_PKEY_CTX\n+                                                                  *ctx),\n+                                      int (*verify_recover) (EVP_PKEY_CTX\n+                                                             *ctx,\n+                                                             unsigned char\n+                                                             *sig,\n+                                                             size_t *siglen,\n+                                                             const unsigned\n+                                                             char *tbs,\n+                                                             size_t tbslen));\n+\n+void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,\n+                               int (*signctx_init) (EVP_PKEY_CTX *ctx,\n+                                                    EVP_MD_CTX *mctx),\n+                               int (*signctx) (EVP_PKEY_CTX *ctx,\n+                                               unsigned char *sig,\n+                                               size_t *siglen,\n+                                               EVP_MD_CTX *mctx));\n+\n+void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,\n+                                 int (*verifyctx_init) (EVP_PKEY_CTX *ctx,\n+                                                        EVP_MD_CTX *mctx),\n+                                 int (*verifyctx) (EVP_PKEY_CTX *ctx,\n+                                                   const unsigned char *sig,\n+                                                   int siglen,\n+                                                   EVP_MD_CTX *mctx));\n+\n+void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,\n+                               int (*encrypt_init) (EVP_PKEY_CTX *ctx),\n+                               int (*encryptfn) (EVP_PKEY_CTX *ctx,\n+                                                 unsigned char *out,\n+                                                 size_t *outlen,\n+                                                 const unsigned char *in,\n+                                                 size_t inlen));\n+\n+void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,\n+                               int (*decrypt_init) (EVP_PKEY_CTX *ctx),\n+                               int (*decrypt) (EVP_PKEY_CTX *ctx,\n+                                               unsigned char *out,\n+                                               size_t *outlen,\n+                                               const unsigned char *in,\n+                                               size_t inlen));\n+\n+void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,\n+                              int (*derive_init) (EVP_PKEY_CTX *ctx),\n+                              int (*derive) (EVP_PKEY_CTX *ctx,\n+                                             unsigned char *key,\n+                                             size_t *keylen));\n+\n+void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,\n+                            int (*ctrl) (EVP_PKEY_CTX *ctx, int type, int p1,\n+                                         void *p2),\n+                            int (*ctrl_str) (EVP_PKEY_CTX *ctx,\n+                                             const char *type,\n+                                             const char *value));\n+\n+void EVP_PKEY_meth_get_init(EVP_PKEY_METHOD *pmeth,\n+                            int (**pinit) (EVP_PKEY_CTX *ctx));\n+\n+void EVP_PKEY_meth_get_copy(EVP_PKEY_METHOD *pmeth,\n+                            int (**pcopy) (EVP_PKEY_CTX *dst,\n+                                           EVP_PKEY_CTX *src));\n+\n+void EVP_PKEY_meth_get_cleanup(EVP_PKEY_METHOD *pmeth,\n+                               void (**pcleanup) (EVP_PKEY_CTX *ctx));\n+\n+void EVP_PKEY_meth_get_paramgen(EVP_PKEY_METHOD *pmeth,\n+                                int (**pparamgen_init) (EVP_PKEY_CTX *ctx),\n+                                int (**pparamgen) (EVP_PKEY_CTX *ctx,\n+                                                   EVP_PKEY *pkey));\n+\n+void EVP_PKEY_meth_get_keygen(EVP_PKEY_METHOD *pmeth,\n+                              int (**pkeygen_init) (EVP_PKEY_CTX *ctx),\n+                              int (**pkeygen) (EVP_PKEY_CTX *ctx,\n+                                               EVP_PKEY *pkey));\n+\n+void EVP_PKEY_meth_get_sign(EVP_PKEY_METHOD *pmeth,\n+                            int (**psign_init) (EVP_PKEY_CTX *ctx),\n+                            int (**psign) (EVP_PKEY_CTX *ctx,\n+                                           unsigned char *sig, size_t *siglen,\n+                                           const unsigned char *tbs,\n+                                           size_t tbslen));\n+\n+void EVP_PKEY_meth_get_verify(EVP_PKEY_METHOD *pmeth,\n+                              int (**pverify_init) (EVP_PKEY_CTX *ctx),\n+                              int (**pverify) (EVP_PKEY_CTX *ctx,\n+                                               const unsigned char *sig,\n+                                               size_t siglen,\n+                                               const unsigned char *tbs,\n+                                               size_t tbslen));\n+\n+void EVP_PKEY_meth_get_verify_recover(EVP_PKEY_METHOD *pmeth,\n+                                      int (**pverify_recover_init) (EVP_PKEY_CTX\n+                                                                    *ctx),\n+                                      int (**pverify_recover) (EVP_PKEY_CTX\n+                                                               *ctx,\n+                                                               unsigned char\n+                                                               *sig,\n+                                                               size_t *siglen,\n+                                                               const unsigned\n+                                                               char *tbs,\n+                                                               size_t tbslen));\n+\n+void EVP_PKEY_meth_get_signctx(EVP_PKEY_METHOD *pmeth,\n+                               int (**psignctx_init) (EVP_PKEY_CTX *ctx,\n+                                                      EVP_MD_CTX *mctx),\n+                               int (**psignctx) (EVP_PKEY_CTX *ctx,\n+                                                 unsigned char *sig,\n+                                                 size_t *siglen,\n+                                                 EVP_MD_CTX *mctx));\n+\n+void EVP_PKEY_meth_get_verifyctx(EVP_PKEY_METHOD *pmeth,\n+                                 int (**pverifyctx_init) (EVP_PKEY_CTX *ctx,\n+                                                          EVP_MD_CTX *mctx),\n+                                 int (**pverifyctx) (EVP_PKEY_CTX *ctx,\n+                                                     const unsigned char *sig,\n+                                                     int siglen,\n+                                                     EVP_MD_CTX *mctx));\n+\n+void EVP_PKEY_meth_get_encrypt(EVP_PKEY_METHOD *pmeth,\n+                               int (**pencrypt_init) (EVP_PKEY_CTX *ctx),\n+                               int (**pencryptfn) (EVP_PKEY_CTX *ctx,\n+                                                   unsigned char *out,\n+                                                   size_t *outlen,\n+                                                   const unsigned char *in,\n+                                                   size_t inlen));\n+\n+void EVP_PKEY_meth_get_decrypt(EVP_PKEY_METHOD *pmeth,\n+                               int (**pdecrypt_init) (EVP_PKEY_CTX *ctx),\n+                               int (**pdecrypt) (EVP_PKEY_CTX *ctx,\n+                                                 unsigned char *out,\n+                                                 size_t *outlen,\n+                                                 const unsigned char *in,\n+                                                 size_t inlen));\n+\n+void EVP_PKEY_meth_get_derive(EVP_PKEY_METHOD *pmeth,\n+                              int (**pderive_init) (EVP_PKEY_CTX *ctx),\n+                              int (**pderive) (EVP_PKEY_CTX *ctx,\n+                                               unsigned char *key,\n+                                               size_t *keylen));\n+\n+void EVP_PKEY_meth_get_ctrl(EVP_PKEY_METHOD *pmeth,\n+                            int (**pctrl) (EVP_PKEY_CTX *ctx, int type, int p1,\n+                                           void *p2),\n+                            int (**pctrl_str) (EVP_PKEY_CTX *ctx,\n+                                               const char *type,\n+                                               const char *value));\n+\n+void EVP_add_alg_module(void);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+\n+void ERR_load_EVP_strings(void);\n+\n+/* Error codes for the EVP functions. */\n+\n+/* Function codes. */\n+# define EVP_F_AESNI_INIT_KEY                             165\n+# define EVP_F_AESNI_XTS_CIPHER                           176\n+# define EVP_F_AES_INIT_KEY                               133\n+# define EVP_F_AES_T4_INIT_KEY                            178\n+# define EVP_F_AES_XTS                                    172\n+# define EVP_F_AES_XTS_CIPHER                             175\n+# define EVP_F_ALG_MODULE_INIT                            177\n+# define EVP_F_CAMELLIA_INIT_KEY                          159\n+# define EVP_F_CMAC_INIT                                  173\n+# define EVP_F_CMLL_T4_INIT_KEY                           179\n+# define EVP_F_D2I_PKEY                                   100\n+# define EVP_F_DO_SIGVER_INIT                             161\n+# define EVP_F_DSAPKEY2PKCS8                              134\n+# define EVP_F_DSA_PKEY2PKCS8                             135\n+# define EVP_F_ECDSA_PKEY2PKCS8                           129\n+# define EVP_F_ECKEY_PKEY2PKCS8                           132\n+# define EVP_F_EVP_CIPHERINIT_EX                          123\n+# define EVP_F_EVP_CIPHER_CTX_COPY                        163\n+# define EVP_F_EVP_CIPHER_CTX_CTRL                        124\n+# define EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH              122\n+# define EVP_F_EVP_DECRYPTFINAL_EX                        101\n+# define EVP_F_EVP_DIGESTINIT_EX                          128\n+# define EVP_F_EVP_ENCRYPTFINAL_EX                        127\n+# define EVP_F_EVP_MD_CTX_COPY_EX                         110\n+# define EVP_F_EVP_MD_SIZE                                162\n+# define EVP_F_EVP_OPENINIT                               102\n+# define EVP_F_EVP_PBE_ALG_ADD                            115\n+# define EVP_F_EVP_PBE_ALG_ADD_TYPE                       160\n+# define EVP_F_EVP_PBE_CIPHERINIT                         116\n+# define EVP_F_EVP_PKCS82PKEY                             111\n+# define EVP_F_EVP_PKCS82PKEY_BROKEN                      136\n+# define EVP_F_EVP_PKEY2PKCS8_BROKEN                      113\n+# define EVP_F_EVP_PKEY_COPY_PARAMETERS                   103\n+# define EVP_F_EVP_PKEY_CTX_CTRL                          137\n+# define EVP_F_EVP_PKEY_CTX_CTRL_STR                      150\n+# define EVP_F_EVP_PKEY_CTX_DUP                           156\n+# define EVP_F_EVP_PKEY_DECRYPT                           104\n+# define EVP_F_EVP_PKEY_DECRYPT_INIT                      138\n+# define EVP_F_EVP_PKEY_DECRYPT_OLD                       151\n+# define EVP_F_EVP_PKEY_DERIVE                            153\n+# define EVP_F_EVP_PKEY_DERIVE_INIT                       154\n+# define EVP_F_EVP_PKEY_DERIVE_SET_PEER                   155\n+# define EVP_F_EVP_PKEY_ENCRYPT                           105\n+# define EVP_F_EVP_PKEY_ENCRYPT_INIT                      139\n+# define EVP_F_EVP_PKEY_ENCRYPT_OLD                       152\n+# define EVP_F_EVP_PKEY_GET1_DH                           119\n+# define EVP_F_EVP_PKEY_GET1_DSA                          120\n+# define EVP_F_EVP_PKEY_GET1_ECDSA                        130\n+# define EVP_F_EVP_PKEY_GET1_EC_KEY                       131\n+# define EVP_F_EVP_PKEY_GET1_RSA                          121\n+# define EVP_F_EVP_PKEY_KEYGEN                            146\n+# define EVP_F_EVP_PKEY_KEYGEN_INIT                       147\n+# define EVP_F_EVP_PKEY_NEW                               106\n+# define EVP_F_EVP_PKEY_PARAMGEN                          148\n+# define EVP_F_EVP_PKEY_PARAMGEN_INIT                     149\n+# define EVP_F_EVP_PKEY_SIGN                              140\n+# define EVP_F_EVP_PKEY_SIGN_INIT                         141\n+# define EVP_F_EVP_PKEY_VERIFY                            142\n+# define EVP_F_EVP_PKEY_VERIFY_INIT                       143\n+# define EVP_F_EVP_PKEY_VERIFY_RECOVER                    144\n+# define EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT               145\n+# define EVP_F_EVP_RIJNDAEL                               126\n+# define EVP_F_EVP_SIGNFINAL                              107\n+# define EVP_F_EVP_VERIFYFINAL                            108\n+# define EVP_F_FIPS_CIPHERINIT                            166\n+# define EVP_F_FIPS_CIPHER_CTX_COPY                       170\n+# define EVP_F_FIPS_CIPHER_CTX_CTRL                       167\n+# define EVP_F_FIPS_CIPHER_CTX_SET_KEY_LENGTH             171\n+# define EVP_F_FIPS_DIGESTINIT                            168\n+# define EVP_F_FIPS_MD_CTX_COPY                           169\n+# define EVP_F_HMAC_INIT_EX                               174\n+# define EVP_F_INT_CTX_NEW                                157\n+# define EVP_F_PKCS5_PBE_KEYIVGEN                         117\n+# define EVP_F_PKCS5_V2_PBE_KEYIVGEN                      118\n+# define EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN                   164\n+# define EVP_F_PKCS8_SET_BROKEN                           112\n+# define EVP_F_PKEY_SET_TYPE                              158\n+# define EVP_F_RC2_MAGIC_TO_METH                          109\n+# define EVP_F_RC5_CTRL                                   125\n+\n+/* Reason codes. */\n+# define EVP_R_AES_IV_SETUP_FAILED                        162\n+# define EVP_R_AES_KEY_SETUP_FAILED                       143\n+# define EVP_R_ASN1_LIB                                   140\n+# define EVP_R_BAD_BLOCK_LENGTH                           136\n+# define EVP_R_BAD_DECRYPT                                100\n+# define EVP_R_BAD_KEY_LENGTH                             137\n+# define EVP_R_BN_DECODE_ERROR                            112\n+# define EVP_R_BN_PUBKEY_ERROR                            113\n+# define EVP_R_BUFFER_TOO_SMALL                           155\n+# define EVP_R_CAMELLIA_KEY_SETUP_FAILED                  157\n+# define EVP_R_CIPHER_PARAMETER_ERROR                     122\n+# define EVP_R_COMMAND_NOT_SUPPORTED                      147\n+# define EVP_R_CTRL_NOT_IMPLEMENTED                       132\n+# define EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED             133\n+# define EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH          138\n+# define EVP_R_DECODE_ERROR                               114\n+# define EVP_R_DIFFERENT_KEY_TYPES                        101\n+# define EVP_R_DIFFERENT_PARAMETERS                       153\n+# define EVP_R_DISABLED_FOR_FIPS                          163\n+# define EVP_R_ENCODE_ERROR                               115\n+# define EVP_R_ERROR_LOADING_SECTION                      165\n+# define EVP_R_ERROR_SETTING_FIPS_MODE                    166\n+# define EVP_R_EVP_PBE_CIPHERINIT_ERROR                   119\n+# define EVP_R_EXPECTING_AN_RSA_KEY                       127\n+# define EVP_R_EXPECTING_A_DH_KEY                         128\n+# define EVP_R_EXPECTING_A_DSA_KEY                        129\n+# define EVP_R_EXPECTING_A_ECDSA_KEY                      141\n+# define EVP_R_EXPECTING_A_EC_KEY                         142\n+# define EVP_R_FIPS_MODE_NOT_SUPPORTED                    167\n+# define EVP_R_INITIALIZATION_ERROR                       134\n+# define EVP_R_INPUT_NOT_INITIALIZED                      111\n+# define EVP_R_INVALID_DIGEST                             152\n+# define EVP_R_INVALID_FIPS_MODE                          168\n+# define EVP_R_INVALID_KEY                                171\n+# define EVP_R_INVALID_KEY_LENGTH                         130\n+# define EVP_R_INVALID_OPERATION                          148\n+# define EVP_R_IV_TOO_LARGE                               102\n+# define EVP_R_KEYGEN_FAILURE                             120\n+# define EVP_R_MESSAGE_DIGEST_IS_NULL                     159\n+# define EVP_R_METHOD_NOT_SUPPORTED                       144\n+# define EVP_R_MISSING_PARAMETERS                         103\n+# define EVP_R_NO_CIPHER_SET                              131\n+# define EVP_R_NO_DEFAULT_DIGEST                          158\n+# define EVP_R_NO_DIGEST_SET                              139\n+# define EVP_R_NO_DSA_PARAMETERS                          116\n+# define EVP_R_NO_KEY_SET                                 154\n+# define EVP_R_NO_OPERATION_SET                           149\n+# define EVP_R_NO_SIGN_FUNCTION_CONFIGURED                104\n+# define EVP_R_NO_VERIFY_FUNCTION_CONFIGURED              105\n+# define EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE   150\n+# define EVP_R_OPERATON_NOT_INITIALIZED                   151\n+# define EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE                  117\n+# define EVP_R_PRIVATE_KEY_DECODE_ERROR                   145\n+# define EVP_R_PRIVATE_KEY_ENCODE_ERROR                   146\n+# define EVP_R_PUBLIC_KEY_NOT_RSA                         106\n+# define EVP_R_TOO_LARGE                                  164\n+# define EVP_R_UNKNOWN_CIPHER                             160\n+# define EVP_R_UNKNOWN_DIGEST                             161\n+# define EVP_R_UNKNOWN_OPTION                             169\n+# define EVP_R_UNKNOWN_PBE_ALGORITHM                      121\n+# define EVP_R_UNSUPORTED_NUMBER_OF_ROUNDS                135\n+# define EVP_R_UNSUPPORTED_ALGORITHM                      156\n+# define EVP_R_UNSUPPORTED_CIPHER                         107\n+# define EVP_R_UNSUPPORTED_KEYLENGTH                      123\n+# define EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION        124\n+# define EVP_R_UNSUPPORTED_KEY_SIZE                       108\n+# define EVP_R_UNSUPPORTED_PRF                            125\n+# define EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM          118\n+# define EVP_R_UNSUPPORTED_SALT_TYPE                      126\n+# define EVP_R_WRAP_MODE_NOT_ALLOWED                      170\n+# define EVP_R_WRONG_FINAL_BLOCK_LENGTH                   109\n+# define EVP_R_WRONG_PUBLIC_KEY_TYPE                      110\n+\n+# ifdef  __cplusplus\n+}\n+# endif\n+#endif"
        },
        {
            "sha": "b8b55cda7d73d9e79b4aafee6c203bbb36aba5f8",
            "filename": "deps/openssl/openssl/include/openssl/hmac.h",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fhmac.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fhmac.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fhmac.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,109 @@\n+/* crypto/hmac/hmac.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+#ifndef HEADER_HMAC_H\n+# define HEADER_HMAC_H\n+\n+# include <openssl/opensslconf.h>\n+\n+# ifdef OPENSSL_NO_HMAC\n+#  error HMAC is disabled.\n+# endif\n+\n+# include <openssl/evp.h>\n+\n+# define HMAC_MAX_MD_CBLOCK      128/* largest known is SHA512 */\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct hmac_ctx_st {\n+    const EVP_MD *md;\n+    EVP_MD_CTX md_ctx;\n+    EVP_MD_CTX i_ctx;\n+    EVP_MD_CTX o_ctx;\n+    unsigned int key_length;\n+    unsigned char key[HMAC_MAX_MD_CBLOCK];\n+} HMAC_CTX;\n+\n+# define HMAC_size(e)    (EVP_MD_size((e)->md))\n+\n+void HMAC_CTX_init(HMAC_CTX *ctx);\n+void HMAC_CTX_cleanup(HMAC_CTX *ctx);\n+\n+/* deprecated */\n+# define HMAC_cleanup(ctx) HMAC_CTX_cleanup(ctx)\n+\n+/* deprecated */\n+int HMAC_Init(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md);\n+int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\n+                 const EVP_MD *md, ENGINE *impl);\n+int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, size_t len);\n+int HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len);\n+unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,\n+                    const unsigned char *d, size_t n, unsigned char *md,\n+                    unsigned int *md_len);\n+int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx);\n+\n+void HMAC_CTX_set_flags(HMAC_CTX *ctx, unsigned long flags);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "60759840397e6b551ab7f9ac5409f26a3b64b4de",
            "filename": "deps/openssl/openssl/include/openssl/idea.h",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fidea.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fidea.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fidea.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,105 @@\n+/* crypto/idea/idea.h */\n+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_IDEA_H\n+# define HEADER_IDEA_H\n+\n+# include <openssl/opensslconf.h>/* IDEA_INT, OPENSSL_NO_IDEA */\n+\n+# ifdef OPENSSL_NO_IDEA\n+#  error IDEA is disabled.\n+# endif\n+\n+# define IDEA_ENCRYPT    1\n+# define IDEA_DECRYPT    0\n+\n+# define IDEA_BLOCK      8\n+# define IDEA_KEY_LENGTH 16\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct idea_key_st {\n+    IDEA_INT data[9][6];\n+} IDEA_KEY_SCHEDULE;\n+\n+const char *idea_options(void);\n+void idea_ecb_encrypt(const unsigned char *in, unsigned char *out,\n+                      IDEA_KEY_SCHEDULE *ks);\n+# ifdef OPENSSL_FIPS\n+void private_idea_set_encrypt_key(const unsigned char *key,\n+                                  IDEA_KEY_SCHEDULE *ks);\n+# endif\n+void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks);\n+void idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk);\n+void idea_cbc_encrypt(const unsigned char *in, unsigned char *out,\n+                      long length, IDEA_KEY_SCHEDULE *ks, unsigned char *iv,\n+                      int enc);\n+void idea_cfb64_encrypt(const unsigned char *in, unsigned char *out,\n+                        long length, IDEA_KEY_SCHEDULE *ks, unsigned char *iv,\n+                        int *num, int enc);\n+void idea_ofb64_encrypt(const unsigned char *in, unsigned char *out,\n+                        long length, IDEA_KEY_SCHEDULE *ks, unsigned char *iv,\n+                        int *num);\n+void idea_encrypt(unsigned long *in, IDEA_KEY_SCHEDULE *ks);\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "9cf5a26dd81a2264f6590bc675ae1d9ce1e906d7",
            "filename": "deps/openssl/openssl/include/openssl/krb5_asn.h",
            "status": "added",
            "additions": 240,
            "deletions": 0,
            "changes": 240,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fkrb5_asn.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fkrb5_asn.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fkrb5_asn.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,240 @@\n+/* krb5_asn.h */\n+/*\n+ * Written by Vern Staats <staatsvr@asc.hpc.mil> for the OpenSSL project, **\n+ * using ocsp/{*.h,*asn*.c} as a starting point\n+ */\n+\n+/* ====================================================================\n+ * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#ifndef HEADER_KRB5_ASN_H\n+# define HEADER_KRB5_ASN_H\n+\n+/*\n+ * #include <krb5.h>\n+ */\n+# include <openssl/safestack.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+ * ASN.1 from Kerberos RFC 1510\n+ */\n+\n+/*-     EncryptedData ::=   SEQUENCE {\n+ *              etype[0]                      INTEGER, -- EncryptionType\n+ *              kvno[1]                       INTEGER OPTIONAL,\n+ *              cipher[2]                     OCTET STRING -- ciphertext\n+ *      }\n+ */\n+typedef struct krb5_encdata_st {\n+    ASN1_INTEGER *etype;\n+    ASN1_INTEGER *kvno;\n+    ASN1_OCTET_STRING *cipher;\n+} KRB5_ENCDATA;\n+\n+DECLARE_STACK_OF(KRB5_ENCDATA)\n+\n+/*-     PrincipalName ::=   SEQUENCE {\n+ *              name-type[0]                  INTEGER,\n+ *              name-string[1]                SEQUENCE OF GeneralString\n+ *      }\n+ */\n+typedef struct krb5_princname_st {\n+    ASN1_INTEGER *nametype;\n+    STACK_OF(ASN1_GENERALSTRING) *namestring;\n+} KRB5_PRINCNAME;\n+\n+DECLARE_STACK_OF(KRB5_PRINCNAME)\n+\n+/*-     Ticket ::=      [APPLICATION 1] SEQUENCE {\n+ *              tkt-vno[0]                    INTEGER,\n+ *              realm[1]                      Realm,\n+ *              sname[2]                      PrincipalName,\n+ *              enc-part[3]                   EncryptedData\n+ *      }\n+ */\n+typedef struct krb5_tktbody_st {\n+    ASN1_INTEGER *tktvno;\n+    ASN1_GENERALSTRING *realm;\n+    KRB5_PRINCNAME *sname;\n+    KRB5_ENCDATA *encdata;\n+} KRB5_TKTBODY;\n+\n+typedef STACK_OF(KRB5_TKTBODY) KRB5_TICKET;\n+DECLARE_STACK_OF(KRB5_TKTBODY)\n+\n+/*-     AP-REQ ::=      [APPLICATION 14] SEQUENCE {\n+ *              pvno[0]                       INTEGER,\n+ *              msg-type[1]                   INTEGER,\n+ *              ap-options[2]                 APOptions,\n+ *              ticket[3]                     Ticket,\n+ *              authenticator[4]              EncryptedData\n+ *      }\n+ *\n+ *      APOptions ::=   BIT STRING {\n+ *              reserved(0), use-session-key(1), mutual-required(2) }\n+ */\n+typedef struct krb5_ap_req_st {\n+    ASN1_INTEGER *pvno;\n+    ASN1_INTEGER *msgtype;\n+    ASN1_BIT_STRING *apoptions;\n+    KRB5_TICKET *ticket;\n+    KRB5_ENCDATA *authenticator;\n+} KRB5_APREQBODY;\n+\n+typedef STACK_OF(KRB5_APREQBODY) KRB5_APREQ;\n+DECLARE_STACK_OF(KRB5_APREQBODY)\n+\n+/*      Authenticator Stuff     */\n+\n+/*-     Checksum ::=   SEQUENCE {\n+ *              cksumtype[0]                  INTEGER,\n+ *              checksum[1]                   OCTET STRING\n+ *      }\n+ */\n+typedef struct krb5_checksum_st {\n+    ASN1_INTEGER *ctype;\n+    ASN1_OCTET_STRING *checksum;\n+} KRB5_CHECKSUM;\n+\n+DECLARE_STACK_OF(KRB5_CHECKSUM)\n+\n+/*-     EncryptionKey ::=   SEQUENCE {\n+ *              keytype[0]                    INTEGER,\n+ *              keyvalue[1]                   OCTET STRING\n+ *      }\n+ */\n+typedef struct krb5_encryptionkey_st {\n+    ASN1_INTEGER *ktype;\n+    ASN1_OCTET_STRING *keyvalue;\n+} KRB5_ENCKEY;\n+\n+DECLARE_STACK_OF(KRB5_ENCKEY)\n+\n+/*-     AuthorizationData ::=   SEQUENCE OF SEQUENCE {\n+ *              ad-type[0]                    INTEGER,\n+ *              ad-data[1]                    OCTET STRING\n+ *      }\n+ */\n+typedef struct krb5_authorization_st {\n+    ASN1_INTEGER *adtype;\n+    ASN1_OCTET_STRING *addata;\n+} KRB5_AUTHDATA;\n+\n+DECLARE_STACK_OF(KRB5_AUTHDATA)\n+\n+/*-     -- Unencrypted authenticator\n+ *      Authenticator ::=    [APPLICATION 2] SEQUENCE    {\n+ *              authenticator-vno[0]          INTEGER,\n+ *              crealm[1]                     Realm,\n+ *              cname[2]                      PrincipalName,\n+ *              cksum[3]                      Checksum OPTIONAL,\n+ *              cusec[4]                      INTEGER,\n+ *              ctime[5]                      KerberosTime,\n+ *              subkey[6]                     EncryptionKey OPTIONAL,\n+ *              seq-number[7]                 INTEGER OPTIONAL,\n+ *              authorization-data[8]         AuthorizationData OPTIONAL\n+ *      }\n+ */\n+typedef struct krb5_authenticator_st {\n+    ASN1_INTEGER *avno;\n+    ASN1_GENERALSTRING *crealm;\n+    KRB5_PRINCNAME *cname;\n+    KRB5_CHECKSUM *cksum;\n+    ASN1_INTEGER *cusec;\n+    ASN1_GENERALIZEDTIME *ctime;\n+    KRB5_ENCKEY *subkey;\n+    ASN1_INTEGER *seqnum;\n+    KRB5_AUTHDATA *authorization;\n+} KRB5_AUTHENTBODY;\n+\n+typedef STACK_OF(KRB5_AUTHENTBODY) KRB5_AUTHENT;\n+DECLARE_STACK_OF(KRB5_AUTHENTBODY)\n+\n+/*-  DECLARE_ASN1_FUNCTIONS(type) = DECLARE_ASN1_FUNCTIONS_name(type, type) =\n+ *      type *name##_new(void);\n+ *      void name##_free(type *a);\n+ *      DECLARE_ASN1_ENCODE_FUNCTIONS(type, name, name) =\n+ *       DECLARE_ASN1_ENCODE_FUNCTIONS(type, itname, name) =\n+ *        type *d2i_##name(type **a, const unsigned char **in, long len);\n+ *        int i2d_##name(type *a, unsigned char **out);\n+ *        DECLARE_ASN1_ITEM(itname) = OPENSSL_EXTERN const ASN1_ITEM itname##_it\n+ */\n+\n+DECLARE_ASN1_FUNCTIONS(KRB5_ENCDATA)\n+DECLARE_ASN1_FUNCTIONS(KRB5_PRINCNAME)\n+DECLARE_ASN1_FUNCTIONS(KRB5_TKTBODY)\n+DECLARE_ASN1_FUNCTIONS(KRB5_APREQBODY)\n+DECLARE_ASN1_FUNCTIONS(KRB5_TICKET)\n+DECLARE_ASN1_FUNCTIONS(KRB5_APREQ)\n+\n+DECLARE_ASN1_FUNCTIONS(KRB5_CHECKSUM)\n+DECLARE_ASN1_FUNCTIONS(KRB5_ENCKEY)\n+DECLARE_ASN1_FUNCTIONS(KRB5_AUTHDATA)\n+DECLARE_ASN1_FUNCTIONS(KRB5_AUTHENTBODY)\n+DECLARE_ASN1_FUNCTIONS(KRB5_AUTHENT)\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "ae8a51f472daf26261031d73e37b9b51d4cd5afd",
            "filename": "deps/openssl/openssl/include/openssl/kssl.h",
            "status": "added",
            "additions": 197,
            "deletions": 0,
            "changes": 197,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fkssl.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fkssl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fkssl.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,197 @@\n+/* ssl/kssl.h */\n+/*\n+ * Written by Vern Staats <staatsvr@asc.hpc.mil> for the OpenSSL project\n+ * 2000. project 2000.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+/*\n+ **      19990701        VRS     Started.\n+ */\n+\n+#ifndef KSSL_H\n+# define KSSL_H\n+\n+# include <openssl/opensslconf.h>\n+\n+# ifndef OPENSSL_NO_KRB5\n+\n+#  include <stdio.h>\n+#  include <ctype.h>\n+#  include <krb5.h>\n+#  ifdef OPENSSL_SYS_WIN32\n+/*\n+ * These can sometimes get redefined indirectly by krb5 header files after\n+ * they get undefed in ossl_typ.h\n+ */\n+#   undef X509_NAME\n+#   undef X509_EXTENSIONS\n+#   undef OCSP_REQUEST\n+#   undef OCSP_RESPONSE\n+#  endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+ *      Depending on which KRB5 implementation used, some types from\n+ *      the other may be missing.  Resolve that here and now\n+ */\n+#  ifdef KRB5_HEIMDAL\n+typedef unsigned char krb5_octet;\n+#   define FAR\n+#  else\n+\n+#   ifndef FAR\n+#    define FAR\n+#   endif\n+\n+#  endif\n+\n+/*-\n+ *      Uncomment this to debug kssl problems or\n+ *      to trace usage of the Kerberos session key\n+ *\n+ *      #define         KSSL_DEBUG\n+ */\n+\n+#  ifndef KRB5SVC\n+#   define KRB5SVC \"host\"\n+#  endif\n+\n+#  ifndef KRB5KEYTAB\n+#   define KRB5KEYTAB      \"/etc/krb5.keytab\"\n+#  endif\n+\n+#  ifndef KRB5SENDAUTH\n+#   define KRB5SENDAUTH    1\n+#  endif\n+\n+#  ifndef KRB5CHECKAUTH\n+#   define KRB5CHECKAUTH   1\n+#  endif\n+\n+#  ifndef KSSL_CLOCKSKEW\n+#   define KSSL_CLOCKSKEW  300;\n+#  endif\n+\n+#  define KSSL_ERR_MAX    255\n+typedef struct kssl_err_st {\n+    int reason;\n+    char text[KSSL_ERR_MAX + 1];\n+} KSSL_ERR;\n+\n+/*-     Context for passing\n+ *              (1) Kerberos session key to SSL, and\n+ *              (2)     Config data between application and SSL lib\n+ */\n+typedef struct kssl_ctx_st {\n+    /*      used by:    disposition:            */\n+    char *service_name;         /* C,S default ok (kssl) */\n+    char *service_host;         /* C input, REQUIRED */\n+    char *client_princ;         /* S output from krb5 ticket */\n+    char *keytab_file;          /* S NULL (/etc/krb5.keytab) */\n+    char *cred_cache;           /* C NULL (default) */\n+    krb5_enctype enctype;\n+    int length;\n+    krb5_octet FAR *key;\n+} KSSL_CTX;\n+\n+#  define KSSL_CLIENT     1\n+#  define KSSL_SERVER     2\n+#  define KSSL_SERVICE    3\n+#  define KSSL_KEYTAB     4\n+\n+#  define KSSL_CTX_OK     0\n+#  define KSSL_CTX_ERR    1\n+#  define KSSL_NOMEM      2\n+\n+/* Public (for use by applications that use OpenSSL with Kerberos 5 support */\n+krb5_error_code kssl_ctx_setstring(KSSL_CTX *kssl_ctx, int which, char *text);\n+KSSL_CTX *kssl_ctx_new(void);\n+KSSL_CTX *kssl_ctx_free(KSSL_CTX *kssl_ctx);\n+void kssl_ctx_show(KSSL_CTX *kssl_ctx);\n+krb5_error_code kssl_ctx_setprinc(KSSL_CTX *kssl_ctx, int which,\n+                                  krb5_data *realm, krb5_data *entity,\n+                                  int nentities);\n+krb5_error_code kssl_cget_tkt(KSSL_CTX *kssl_ctx, krb5_data **enc_tktp,\n+                              krb5_data *authenp, KSSL_ERR *kssl_err);\n+krb5_error_code kssl_sget_tkt(KSSL_CTX *kssl_ctx, krb5_data *indata,\n+                              krb5_ticket_times *ttimes, KSSL_ERR *kssl_err);\n+krb5_error_code kssl_ctx_setkey(KSSL_CTX *kssl_ctx, krb5_keyblock *session);\n+void kssl_err_set(KSSL_ERR *kssl_err, int reason, char *text);\n+void kssl_krb5_free_data_contents(krb5_context context, krb5_data *data);\n+krb5_error_code kssl_build_principal_2(krb5_context context,\n+                                       krb5_principal *princ, int rlen,\n+                                       const char *realm, int slen,\n+                                       const char *svc, int hlen,\n+                                       const char *host);\n+krb5_error_code kssl_validate_times(krb5_timestamp atime,\n+                                    krb5_ticket_times *ttimes);\n+krb5_error_code kssl_check_authent(KSSL_CTX *kssl_ctx, krb5_data *authentp,\n+                                   krb5_timestamp *atimep,\n+                                   KSSL_ERR *kssl_err);\n+unsigned char *kssl_skip_confound(krb5_enctype enctype, unsigned char *authn);\n+\n+void SSL_set0_kssl_ctx(SSL *s, KSSL_CTX *kctx);\n+KSSL_CTX *SSL_get0_kssl_ctx(SSL *s);\n+char *kssl_ctx_get0_client_princ(KSSL_CTX *kctx);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+# endif                         /* OPENSSL_NO_KRB5 */\n+#endif                          /* KSSL_H */"
        },
        {
            "sha": "b6c328bffbb0e915f8d1cc5f389f6b432161d074",
            "filename": "deps/openssl/openssl/include/openssl/lhash.h",
            "status": "added",
            "additions": 240,
            "deletions": 0,
            "changes": 240,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Flhash.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Flhash.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Flhash.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,240 @@\n+/* crypto/lhash/lhash.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+/*\n+ * Header for dynamic hash table routines Author - Eric Young\n+ */\n+\n+#ifndef HEADER_LHASH_H\n+# define HEADER_LHASH_H\n+\n+# include <openssl/e_os2.h>\n+# ifndef OPENSSL_NO_FP_API\n+#  include <stdio.h>\n+# endif\n+\n+# ifndef OPENSSL_NO_BIO\n+#  include <openssl/bio.h>\n+# endif\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct lhash_node_st {\n+    void *data;\n+    struct lhash_node_st *next;\n+# ifndef OPENSSL_NO_HASH_COMP\n+    unsigned long hash;\n+# endif\n+} LHASH_NODE;\n+\n+typedef int (*LHASH_COMP_FN_TYPE) (const void *, const void *);\n+typedef unsigned long (*LHASH_HASH_FN_TYPE) (const void *);\n+typedef void (*LHASH_DOALL_FN_TYPE) (void *);\n+typedef void (*LHASH_DOALL_ARG_FN_TYPE) (void *, void *);\n+\n+/*\n+ * Macros for declaring and implementing type-safe wrappers for LHASH\n+ * callbacks. This way, callbacks can be provided to LHASH structures without\n+ * function pointer casting and the macro-defined callbacks provide\n+ * per-variable casting before deferring to the underlying type-specific\n+ * callbacks. NB: It is possible to place a \"static\" in front of both the\n+ * DECLARE and IMPLEMENT macros if the functions are strictly internal.\n+ */\n+\n+/* First: \"hash\" functions */\n+# define DECLARE_LHASH_HASH_FN(name, o_type) \\\n+        unsigned long name##_LHASH_HASH(const void *);\n+# define IMPLEMENT_LHASH_HASH_FN(name, o_type) \\\n+        unsigned long name##_LHASH_HASH(const void *arg) { \\\n+                const o_type *a = arg; \\\n+                return name##_hash(a); }\n+# define LHASH_HASH_FN(name) name##_LHASH_HASH\n+\n+/* Second: \"compare\" functions */\n+# define DECLARE_LHASH_COMP_FN(name, o_type) \\\n+        int name##_LHASH_COMP(const void *, const void *);\n+# define IMPLEMENT_LHASH_COMP_FN(name, o_type) \\\n+        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \\\n+                const o_type *a = arg1;             \\\n+                const o_type *b = arg2; \\\n+                return name##_cmp(a,b); }\n+# define LHASH_COMP_FN(name) name##_LHASH_COMP\n+\n+/* Third: \"doall\" functions */\n+# define DECLARE_LHASH_DOALL_FN(name, o_type) \\\n+        void name##_LHASH_DOALL(void *);\n+# define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \\\n+        void name##_LHASH_DOALL(void *arg) { \\\n+                o_type *a = arg; \\\n+                name##_doall(a); }\n+# define LHASH_DOALL_FN(name) name##_LHASH_DOALL\n+\n+/* Fourth: \"doall_arg\" functions */\n+# define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n+        void name##_LHASH_DOALL_ARG(void *, void *);\n+# define IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \\\n+        void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \\\n+                o_type *a = arg1; \\\n+                a_type *b = arg2; \\\n+                name##_doall_arg(a, b); }\n+# define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG\n+\n+typedef struct lhash_st {\n+    LHASH_NODE **b;\n+    LHASH_COMP_FN_TYPE comp;\n+    LHASH_HASH_FN_TYPE hash;\n+    unsigned int num_nodes;\n+    unsigned int num_alloc_nodes;\n+    unsigned int p;\n+    unsigned int pmax;\n+    unsigned long up_load;      /* load times 256 */\n+    unsigned long down_load;    /* load times 256 */\n+    unsigned long num_items;\n+    unsigned long num_expands;\n+    unsigned long num_expand_reallocs;\n+    unsigned long num_contracts;\n+    unsigned long num_contract_reallocs;\n+    unsigned long num_hash_calls;\n+    unsigned long num_comp_calls;\n+    unsigned long num_insert;\n+    unsigned long num_replace;\n+    unsigned long num_delete;\n+    unsigned long num_no_delete;\n+    unsigned long num_retrieve;\n+    unsigned long num_retrieve_miss;\n+    unsigned long num_hash_comps;\n+    int error;\n+} _LHASH;                       /* Do not use _LHASH directly, use LHASH_OF\n+                                 * and friends */\n+\n+# define LH_LOAD_MULT    256\n+\n+/*\n+ * Indicates a malloc() error in the last call, this is only bad in\n+ * lh_insert().\n+ */\n+# define lh_error(lh)    ((lh)->error)\n+\n+_LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c);\n+void lh_free(_LHASH *lh);\n+void *lh_insert(_LHASH *lh, void *data);\n+void *lh_delete(_LHASH *lh, const void *data);\n+void *lh_retrieve(_LHASH *lh, const void *data);\n+void lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func);\n+void lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg);\n+unsigned long lh_strhash(const char *c);\n+unsigned long lh_num_items(const _LHASH *lh);\n+\n+# ifndef OPENSSL_NO_FP_API\n+void lh_stats(const _LHASH *lh, FILE *out);\n+void lh_node_stats(const _LHASH *lh, FILE *out);\n+void lh_node_usage_stats(const _LHASH *lh, FILE *out);\n+# endif\n+\n+# ifndef OPENSSL_NO_BIO\n+void lh_stats_bio(const _LHASH *lh, BIO *out);\n+void lh_node_stats_bio(const _LHASH *lh, BIO *out);\n+void lh_node_usage_stats_bio(const _LHASH *lh, BIO *out);\n+# endif\n+\n+/* Type checking... */\n+\n+# define LHASH_OF(type) struct lhash_st_##type\n+\n+# define DECLARE_LHASH_OF(type) LHASH_OF(type) { int dummy; }\n+\n+# define CHECKED_LHASH_OF(type,lh) \\\n+  ((_LHASH *)CHECKED_PTR_OF(LHASH_OF(type),lh))\n+\n+/* Define wrapper functions. */\n+# define LHM_lh_new(type, name) \\\n+  ((LHASH_OF(type) *)lh_new(LHASH_HASH_FN(name), LHASH_COMP_FN(name)))\n+# define LHM_lh_error(type, lh) \\\n+  lh_error(CHECKED_LHASH_OF(type,lh))\n+# define LHM_lh_insert(type, lh, inst) \\\n+  ((type *)lh_insert(CHECKED_LHASH_OF(type, lh), \\\n+                     CHECKED_PTR_OF(type, inst)))\n+# define LHM_lh_retrieve(type, lh, inst) \\\n+  ((type *)lh_retrieve(CHECKED_LHASH_OF(type, lh), \\\n+                       CHECKED_PTR_OF(type, inst)))\n+# define LHM_lh_delete(type, lh, inst) \\\n+  ((type *)lh_delete(CHECKED_LHASH_OF(type, lh),                        \\\n+                     CHECKED_PTR_OF(type, inst)))\n+# define LHM_lh_doall(type, lh,fn) lh_doall(CHECKED_LHASH_OF(type, lh), fn)\n+# define LHM_lh_doall_arg(type, lh, fn, arg_type, arg) \\\n+  lh_doall_arg(CHECKED_LHASH_OF(type, lh), fn, CHECKED_PTR_OF(arg_type, arg))\n+# define LHM_lh_num_items(type, lh) lh_num_items(CHECKED_LHASH_OF(type, lh))\n+# define LHM_lh_down_load(type, lh) (CHECKED_LHASH_OF(type, lh)->down_load)\n+# define LHM_lh_node_stats_bio(type, lh, out) \\\n+  lh_node_stats_bio(CHECKED_LHASH_OF(type, lh), out)\n+# define LHM_lh_node_usage_stats_bio(type, lh, out) \\\n+  lh_node_usage_stats_bio(CHECKED_LHASH_OF(type, lh), out)\n+# define LHM_lh_stats_bio(type, lh, out) \\\n+  lh_stats_bio(CHECKED_LHASH_OF(type, lh), out)\n+# define LHM_lh_free(type, lh) lh_free(CHECKED_LHASH_OF(type, lh))\n+\n+DECLARE_LHASH_OF(OPENSSL_STRING);\n+DECLARE_LHASH_OF(OPENSSL_CSTRING);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "11fd71295b5a6dcf4b184ed3f778c0b362460249",
            "filename": "deps/openssl/openssl/include/openssl/md4.h",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmd4.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmd4.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmd4.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,119 @@\n+/* crypto/md4/md4.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_MD4_H\n+# define HEADER_MD4_H\n+\n+# include <openssl/e_os2.h>\n+# include <stddef.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# ifdef OPENSSL_NO_MD4\n+#  error MD4 is disabled.\n+# endif\n+\n+/*-\n+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n+ * ! MD4_LONG has to be at least 32 bits wide. If it's wider, then !\n+ * ! MD4_LONG_LOG2 has to be defined along.                        !\n+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n+ */\n+\n+# if defined(__LP32__)\n+#  define MD4_LONG unsigned long\n+# elif defined(OPENSSL_SYS_CRAY) || defined(__ILP64__)\n+#  define MD4_LONG unsigned long\n+#  define MD4_LONG_LOG2 3\n+/*\n+ * _CRAY note. I could declare short, but I have no idea what impact\n+ * does it have on performance on none-T3E machines. I could declare\n+ * int, but at least on C90 sizeof(int) can be chosen at compile time.\n+ * So I've chosen long...\n+ *                                      <appro@fy.chalmers.se>\n+ */\n+# else\n+#  define MD4_LONG unsigned int\n+# endif\n+\n+# define MD4_CBLOCK      64\n+# define MD4_LBLOCK      (MD4_CBLOCK/4)\n+# define MD4_DIGEST_LENGTH 16\n+\n+typedef struct MD4state_st {\n+    MD4_LONG A, B, C, D;\n+    MD4_LONG Nl, Nh;\n+    MD4_LONG data[MD4_LBLOCK];\n+    unsigned int num;\n+} MD4_CTX;\n+\n+# ifdef OPENSSL_FIPS\n+int private_MD4_Init(MD4_CTX *c);\n+# endif\n+int MD4_Init(MD4_CTX *c);\n+int MD4_Update(MD4_CTX *c, const void *data, size_t len);\n+int MD4_Final(unsigned char *md, MD4_CTX *c);\n+unsigned char *MD4(const unsigned char *d, size_t n, unsigned char *md);\n+void MD4_Transform(MD4_CTX *c, const unsigned char *b);\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "2659038abd2530a1d14cf7666bb1c468fcabca5c",
            "filename": "deps/openssl/openssl/include/openssl/md5.h",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmd5.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmd5.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmd5.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,119 @@\n+/* crypto/md5/md5.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_MD5_H\n+# define HEADER_MD5_H\n+\n+# include <openssl/e_os2.h>\n+# include <stddef.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# ifdef OPENSSL_NO_MD5\n+#  error MD5 is disabled.\n+# endif\n+\n+/*\n+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n+ * ! MD5_LONG has to be at least 32 bits wide. If it's wider, then !\n+ * ! MD5_LONG_LOG2 has to be defined along.                        !\n+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n+ */\n+\n+# if defined(__LP32__)\n+#  define MD5_LONG unsigned long\n+# elif defined(OPENSSL_SYS_CRAY) || defined(__ILP64__)\n+#  define MD5_LONG unsigned long\n+#  define MD5_LONG_LOG2 3\n+/*\n+ * _CRAY note. I could declare short, but I have no idea what impact\n+ * does it have on performance on none-T3E machines. I could declare\n+ * int, but at least on C90 sizeof(int) can be chosen at compile time.\n+ * So I've chosen long...\n+ *                                      <appro@fy.chalmers.se>\n+ */\n+# else\n+#  define MD5_LONG unsigned int\n+# endif\n+\n+# define MD5_CBLOCK      64\n+# define MD5_LBLOCK      (MD5_CBLOCK/4)\n+# define MD5_DIGEST_LENGTH 16\n+\n+typedef struct MD5state_st {\n+    MD5_LONG A, B, C, D;\n+    MD5_LONG Nl, Nh;\n+    MD5_LONG data[MD5_LBLOCK];\n+    unsigned int num;\n+} MD5_CTX;\n+\n+# ifdef OPENSSL_FIPS\n+int private_MD5_Init(MD5_CTX *c);\n+# endif\n+int MD5_Init(MD5_CTX *c);\n+int MD5_Update(MD5_CTX *c, const void *data, size_t len);\n+int MD5_Final(unsigned char *md, MD5_CTX *c);\n+unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md);\n+void MD5_Transform(MD5_CTX *c, const unsigned char *b);\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "7efe53bc2941bddb2cc508d7101e5d01ec781c0b",
            "filename": "deps/openssl/openssl/include/openssl/mdc2.h",
            "status": "added",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmdc2.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmdc2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmdc2.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,94 @@\n+/* crypto/mdc2/mdc2.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_MDC2_H\n+# define HEADER_MDC2_H\n+\n+# include <openssl/des.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# ifdef OPENSSL_NO_MDC2\n+#  error MDC2 is disabled.\n+# endif\n+\n+# define MDC2_BLOCK              8\n+# define MDC2_DIGEST_LENGTH      16\n+\n+typedef struct mdc2_ctx_st {\n+    unsigned int num;\n+    unsigned char data[MDC2_BLOCK];\n+    DES_cblock h, hh;\n+    int pad_type;               /* either 1 or 2, default 1 */\n+} MDC2_CTX;\n+\n+# ifdef OPENSSL_FIPS\n+int private_MDC2_Init(MDC2_CTX *c);\n+# endif\n+int MDC2_Init(MDC2_CTX *c);\n+int MDC2_Update(MDC2_CTX *c, const unsigned char *data, size_t len);\n+int MDC2_Final(unsigned char *md, MDC2_CTX *c);\n+unsigned char *MDC2(const unsigned char *d, size_t n, unsigned char *md);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "fd488499a0b49f2438374ef026ba223ce9dbec90",
            "filename": "deps/openssl/openssl/include/openssl/modes.h",
            "status": "added",
            "additions": 163,
            "deletions": 0,
            "changes": 163,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmodes.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmodes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fmodes.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,163 @@\n+/* ====================================================================\n+ * Copyright (c) 2008 The OpenSSL Project. All rights reserved.\n+ *\n+ * Rights for redistribution and usage in source and binary\n+ * forms are granted according to the OpenSSL license.\n+ */\n+\n+#include <stddef.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+typedef void (*block128_f) (const unsigned char in[16],\n+                            unsigned char out[16], const void *key);\n+\n+typedef void (*cbc128_f) (const unsigned char *in, unsigned char *out,\n+                          size_t len, const void *key,\n+                          unsigned char ivec[16], int enc);\n+\n+typedef void (*ctr128_f) (const unsigned char *in, unsigned char *out,\n+                          size_t blocks, const void *key,\n+                          const unsigned char ivec[16]);\n+\n+typedef void (*ccm128_f) (const unsigned char *in, unsigned char *out,\n+                          size_t blocks, const void *key,\n+                          const unsigned char ivec[16],\n+                          unsigned char cmac[16]);\n+\n+void CRYPTO_cbc128_encrypt(const unsigned char *in, unsigned char *out,\n+                           size_t len, const void *key,\n+                           unsigned char ivec[16], block128_f block);\n+void CRYPTO_cbc128_decrypt(const unsigned char *in, unsigned char *out,\n+                           size_t len, const void *key,\n+                           unsigned char ivec[16], block128_f block);\n+\n+void CRYPTO_ctr128_encrypt(const unsigned char *in, unsigned char *out,\n+                           size_t len, const void *key,\n+                           unsigned char ivec[16],\n+                           unsigned char ecount_buf[16], unsigned int *num,\n+                           block128_f block);\n+\n+void CRYPTO_ctr128_encrypt_ctr32(const unsigned char *in, unsigned char *out,\n+                                 size_t len, const void *key,\n+                                 unsigned char ivec[16],\n+                                 unsigned char ecount_buf[16],\n+                                 unsigned int *num, ctr128_f ctr);\n+\n+void CRYPTO_ofb128_encrypt(const unsigned char *in, unsigned char *out,\n+                           size_t len, const void *key,\n+                           unsigned char ivec[16], int *num,\n+                           block128_f block);\n+\n+void CRYPTO_cfb128_encrypt(const unsigned char *in, unsigned char *out,\n+                           size_t len, const void *key,\n+                           unsigned char ivec[16], int *num,\n+                           int enc, block128_f block);\n+void CRYPTO_cfb128_8_encrypt(const unsigned char *in, unsigned char *out,\n+                             size_t length, const void *key,\n+                             unsigned char ivec[16], int *num,\n+                             int enc, block128_f block);\n+void CRYPTO_cfb128_1_encrypt(const unsigned char *in, unsigned char *out,\n+                             size_t bits, const void *key,\n+                             unsigned char ivec[16], int *num,\n+                             int enc, block128_f block);\n+\n+size_t CRYPTO_cts128_encrypt_block(const unsigned char *in,\n+                                   unsigned char *out, size_t len,\n+                                   const void *key, unsigned char ivec[16],\n+                                   block128_f block);\n+size_t CRYPTO_cts128_encrypt(const unsigned char *in, unsigned char *out,\n+                             size_t len, const void *key,\n+                             unsigned char ivec[16], cbc128_f cbc);\n+size_t CRYPTO_cts128_decrypt_block(const unsigned char *in,\n+                                   unsigned char *out, size_t len,\n+                                   const void *key, unsigned char ivec[16],\n+                                   block128_f block);\n+size_t CRYPTO_cts128_decrypt(const unsigned char *in, unsigned char *out,\n+                             size_t len, const void *key,\n+                             unsigned char ivec[16], cbc128_f cbc);\n+\n+size_t CRYPTO_nistcts128_encrypt_block(const unsigned char *in,\n+                                       unsigned char *out, size_t len,\n+                                       const void *key,\n+                                       unsigned char ivec[16],\n+                                       block128_f block);\n+size_t CRYPTO_nistcts128_encrypt(const unsigned char *in, unsigned char *out,\n+                                 size_t len, const void *key,\n+                                 unsigned char ivec[16], cbc128_f cbc);\n+size_t CRYPTO_nistcts128_decrypt_block(const unsigned char *in,\n+                                       unsigned char *out, size_t len,\n+                                       const void *key,\n+                                       unsigned char ivec[16],\n+                                       block128_f block);\n+size_t CRYPTO_nistcts128_decrypt(const unsigned char *in, unsigned char *out,\n+                                 size_t len, const void *key,\n+                                 unsigned char ivec[16], cbc128_f cbc);\n+\n+typedef struct gcm128_context GCM128_CONTEXT;\n+\n+GCM128_CONTEXT *CRYPTO_gcm128_new(void *key, block128_f block);\n+void CRYPTO_gcm128_init(GCM128_CONTEXT *ctx, void *key, block128_f block);\n+void CRYPTO_gcm128_setiv(GCM128_CONTEXT *ctx, const unsigned char *iv,\n+                         size_t len);\n+int CRYPTO_gcm128_aad(GCM128_CONTEXT *ctx, const unsigned char *aad,\n+                      size_t len);\n+int CRYPTO_gcm128_encrypt(GCM128_CONTEXT *ctx,\n+                          const unsigned char *in, unsigned char *out,\n+                          size_t len);\n+int CRYPTO_gcm128_decrypt(GCM128_CONTEXT *ctx,\n+                          const unsigned char *in, unsigned char *out,\n+                          size_t len);\n+int CRYPTO_gcm128_encrypt_ctr32(GCM128_CONTEXT *ctx,\n+                                const unsigned char *in, unsigned char *out,\n+                                size_t len, ctr128_f stream);\n+int CRYPTO_gcm128_decrypt_ctr32(GCM128_CONTEXT *ctx,\n+                                const unsigned char *in, unsigned char *out,\n+                                size_t len, ctr128_f stream);\n+int CRYPTO_gcm128_finish(GCM128_CONTEXT *ctx, const unsigned char *tag,\n+                         size_t len);\n+void CRYPTO_gcm128_tag(GCM128_CONTEXT *ctx, unsigned char *tag, size_t len);\n+void CRYPTO_gcm128_release(GCM128_CONTEXT *ctx);\n+\n+typedef struct ccm128_context CCM128_CONTEXT;\n+\n+void CRYPTO_ccm128_init(CCM128_CONTEXT *ctx,\n+                        unsigned int M, unsigned int L, void *key,\n+                        block128_f block);\n+int CRYPTO_ccm128_setiv(CCM128_CONTEXT *ctx, const unsigned char *nonce,\n+                        size_t nlen, size_t mlen);\n+void CRYPTO_ccm128_aad(CCM128_CONTEXT *ctx, const unsigned char *aad,\n+                       size_t alen);\n+int CRYPTO_ccm128_encrypt(CCM128_CONTEXT *ctx, const unsigned char *inp,\n+                          unsigned char *out, size_t len);\n+int CRYPTO_ccm128_decrypt(CCM128_CONTEXT *ctx, const unsigned char *inp,\n+                          unsigned char *out, size_t len);\n+int CRYPTO_ccm128_encrypt_ccm64(CCM128_CONTEXT *ctx, const unsigned char *inp,\n+                                unsigned char *out, size_t len,\n+                                ccm128_f stream);\n+int CRYPTO_ccm128_decrypt_ccm64(CCM128_CONTEXT *ctx, const unsigned char *inp,\n+                                unsigned char *out, size_t len,\n+                                ccm128_f stream);\n+size_t CRYPTO_ccm128_tag(CCM128_CONTEXT *ctx, unsigned char *tag, size_t len);\n+\n+typedef struct xts128_context XTS128_CONTEXT;\n+\n+int CRYPTO_xts128_encrypt(const XTS128_CONTEXT *ctx,\n+                          const unsigned char iv[16],\n+                          const unsigned char *inp, unsigned char *out,\n+                          size_t len, int enc);\n+\n+size_t CRYPTO_128_wrap(void *key, const unsigned char *iv,\n+                       unsigned char *out,\n+                       const unsigned char *in, size_t inlen,\n+                       block128_f block);\n+\n+size_t CRYPTO_128_unwrap(void *key, const unsigned char *iv,\n+                         unsigned char *out,\n+                         const unsigned char *in, size_t inlen,\n+                         block128_f block);\n+\n+#ifdef  __cplusplus\n+}\n+#endif"
        },
        {
            "sha": "779c309b869b65c34536cec64ecec93929a89390",
            "filename": "deps/openssl/openssl/include/openssl/obj_mac.h",
            "status": "added",
            "additions": 4194,
            "deletions": 0,
            "changes": 4194,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fobj_mac.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fobj_mac.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fobj_mac.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "b8dafa89ce3c98a2022609d29e42e67cb94bec53",
            "filename": "deps/openssl/openssl/include/openssl/objects.h",
            "status": "added",
            "additions": 1143,
            "deletions": 0,
            "changes": 1143,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fobjects.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fobjects.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fobjects.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,1143 @@\n+/* crypto/objects/objects.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_OBJECTS_H\n+# define HEADER_OBJECTS_H\n+\n+# define USE_OBJ_MAC\n+\n+# ifdef USE_OBJ_MAC\n+#  include <openssl/obj_mac.h>\n+# else\n+#  define SN_undef                        \"UNDEF\"\n+#  define LN_undef                        \"undefined\"\n+#  define NID_undef                       0\n+#  define OBJ_undef                       0L\n+\n+#  define SN_Algorithm                    \"Algorithm\"\n+#  define LN_algorithm                    \"algorithm\"\n+#  define NID_algorithm                   38\n+#  define OBJ_algorithm                   1L,3L,14L,3L,2L\n+\n+#  define LN_rsadsi                       \"rsadsi\"\n+#  define NID_rsadsi                      1\n+#  define OBJ_rsadsi                      1L,2L,840L,113549L\n+\n+#  define LN_pkcs                         \"pkcs\"\n+#  define NID_pkcs                        2\n+#  define OBJ_pkcs                        OBJ_rsadsi,1L\n+\n+#  define SN_md2                          \"MD2\"\n+#  define LN_md2                          \"md2\"\n+#  define NID_md2                         3\n+#  define OBJ_md2                         OBJ_rsadsi,2L,2L\n+\n+#  define SN_md5                          \"MD5\"\n+#  define LN_md5                          \"md5\"\n+#  define NID_md5                         4\n+#  define OBJ_md5                         OBJ_rsadsi,2L,5L\n+\n+#  define SN_rc4                          \"RC4\"\n+#  define LN_rc4                          \"rc4\"\n+#  define NID_rc4                         5\n+#  define OBJ_rc4                         OBJ_rsadsi,3L,4L\n+\n+#  define LN_rsaEncryption                \"rsaEncryption\"\n+#  define NID_rsaEncryption               6\n+#  define OBJ_rsaEncryption               OBJ_pkcs,1L,1L\n+\n+#  define SN_md2WithRSAEncryption         \"RSA-MD2\"\n+#  define LN_md2WithRSAEncryption         \"md2WithRSAEncryption\"\n+#  define NID_md2WithRSAEncryption        7\n+#  define OBJ_md2WithRSAEncryption        OBJ_pkcs,1L,2L\n+\n+#  define SN_md5WithRSAEncryption         \"RSA-MD5\"\n+#  define LN_md5WithRSAEncryption         \"md5WithRSAEncryption\"\n+#  define NID_md5WithRSAEncryption        8\n+#  define OBJ_md5WithRSAEncryption        OBJ_pkcs,1L,4L\n+\n+#  define SN_pbeWithMD2AndDES_CBC         \"PBE-MD2-DES\"\n+#  define LN_pbeWithMD2AndDES_CBC         \"pbeWithMD2AndDES-CBC\"\n+#  define NID_pbeWithMD2AndDES_CBC        9\n+#  define OBJ_pbeWithMD2AndDES_CBC        OBJ_pkcs,5L,1L\n+\n+#  define SN_pbeWithMD5AndDES_CBC         \"PBE-MD5-DES\"\n+#  define LN_pbeWithMD5AndDES_CBC         \"pbeWithMD5AndDES-CBC\"\n+#  define NID_pbeWithMD5AndDES_CBC        10\n+#  define OBJ_pbeWithMD5AndDES_CBC        OBJ_pkcs,5L,3L\n+\n+#  define LN_X500                         \"X500\"\n+#  define NID_X500                        11\n+#  define OBJ_X500                        2L,5L\n+\n+#  define LN_X509                         \"X509\"\n+#  define NID_X509                        12\n+#  define OBJ_X509                        OBJ_X500,4L\n+\n+#  define SN_commonName                   \"CN\"\n+#  define LN_commonName                   \"commonName\"\n+#  define NID_commonName                  13\n+#  define OBJ_commonName                  OBJ_X509,3L\n+\n+#  define SN_countryName                  \"C\"\n+#  define LN_countryName                  \"countryName\"\n+#  define NID_countryName                 14\n+#  define OBJ_countryName                 OBJ_X509,6L\n+\n+#  define SN_localityName                 \"L\"\n+#  define LN_localityName                 \"localityName\"\n+#  define NID_localityName                15\n+#  define OBJ_localityName                OBJ_X509,7L\n+\n+/* Postal Address? PA */\n+\n+/* should be \"ST\" (rfc1327) but MS uses 'S' */\n+#  define SN_stateOrProvinceName          \"ST\"\n+#  define LN_stateOrProvinceName          \"stateOrProvinceName\"\n+#  define NID_stateOrProvinceName         16\n+#  define OBJ_stateOrProvinceName         OBJ_X509,8L\n+\n+#  define SN_organizationName             \"O\"\n+#  define LN_organizationName             \"organizationName\"\n+#  define NID_organizationName            17\n+#  define OBJ_organizationName            OBJ_X509,10L\n+\n+#  define SN_organizationalUnitName       \"OU\"\n+#  define LN_organizationalUnitName       \"organizationalUnitName\"\n+#  define NID_organizationalUnitName      18\n+#  define OBJ_organizationalUnitName      OBJ_X509,11L\n+\n+#  define SN_rsa                          \"RSA\"\n+#  define LN_rsa                          \"rsa\"\n+#  define NID_rsa                         19\n+#  define OBJ_rsa                         OBJ_X500,8L,1L,1L\n+\n+#  define LN_pkcs7                        \"pkcs7\"\n+#  define NID_pkcs7                       20\n+#  define OBJ_pkcs7                       OBJ_pkcs,7L\n+\n+#  define LN_pkcs7_data                   \"pkcs7-data\"\n+#  define NID_pkcs7_data                  21\n+#  define OBJ_pkcs7_data                  OBJ_pkcs7,1L\n+\n+#  define LN_pkcs7_signed                 \"pkcs7-signedData\"\n+#  define NID_pkcs7_signed                22\n+#  define OBJ_pkcs7_signed                OBJ_pkcs7,2L\n+\n+#  define LN_pkcs7_enveloped              \"pkcs7-envelopedData\"\n+#  define NID_pkcs7_enveloped             23\n+#  define OBJ_pkcs7_enveloped             OBJ_pkcs7,3L\n+\n+#  define LN_pkcs7_signedAndEnveloped     \"pkcs7-signedAndEnvelopedData\"\n+#  define NID_pkcs7_signedAndEnveloped    24\n+#  define OBJ_pkcs7_signedAndEnveloped    OBJ_pkcs7,4L\n+\n+#  define LN_pkcs7_digest                 \"pkcs7-digestData\"\n+#  define NID_pkcs7_digest                25\n+#  define OBJ_pkcs7_digest                OBJ_pkcs7,5L\n+\n+#  define LN_pkcs7_encrypted              \"pkcs7-encryptedData\"\n+#  define NID_pkcs7_encrypted             26\n+#  define OBJ_pkcs7_encrypted             OBJ_pkcs7,6L\n+\n+#  define LN_pkcs3                        \"pkcs3\"\n+#  define NID_pkcs3                       27\n+#  define OBJ_pkcs3                       OBJ_pkcs,3L\n+\n+#  define LN_dhKeyAgreement               \"dhKeyAgreement\"\n+#  define NID_dhKeyAgreement              28\n+#  define OBJ_dhKeyAgreement              OBJ_pkcs3,1L\n+\n+#  define SN_des_ecb                      \"DES-ECB\"\n+#  define LN_des_ecb                      \"des-ecb\"\n+#  define NID_des_ecb                     29\n+#  define OBJ_des_ecb                     OBJ_algorithm,6L\n+\n+#  define SN_des_cfb64                    \"DES-CFB\"\n+#  define LN_des_cfb64                    \"des-cfb\"\n+#  define NID_des_cfb64                   30\n+/* IV + num */\n+#  define OBJ_des_cfb64                   OBJ_algorithm,9L\n+\n+#  define SN_des_cbc                      \"DES-CBC\"\n+#  define LN_des_cbc                      \"des-cbc\"\n+#  define NID_des_cbc                     31\n+/* IV */\n+#  define OBJ_des_cbc                     OBJ_algorithm,7L\n+\n+#  define SN_des_ede                      \"DES-EDE\"\n+#  define LN_des_ede                      \"des-ede\"\n+#  define NID_des_ede                     32\n+/* ?? */\n+#  define OBJ_des_ede                     OBJ_algorithm,17L\n+\n+#  define SN_des_ede3                     \"DES-EDE3\"\n+#  define LN_des_ede3                     \"des-ede3\"\n+#  define NID_des_ede3                    33\n+\n+#  define SN_idea_cbc                     \"IDEA-CBC\"\n+#  define LN_idea_cbc                     \"idea-cbc\"\n+#  define NID_idea_cbc                    34\n+#  define OBJ_idea_cbc                    1L,3L,6L,1L,4L,1L,188L,7L,1L,1L,2L\n+\n+#  define SN_idea_cfb64                   \"IDEA-CFB\"\n+#  define LN_idea_cfb64                   \"idea-cfb\"\n+#  define NID_idea_cfb64                  35\n+\n+#  define SN_idea_ecb                     \"IDEA-ECB\"\n+#  define LN_idea_ecb                     \"idea-ecb\"\n+#  define NID_idea_ecb                    36\n+\n+#  define SN_rc2_cbc                      \"RC2-CBC\"\n+#  define LN_rc2_cbc                      \"rc2-cbc\"\n+#  define NID_rc2_cbc                     37\n+#  define OBJ_rc2_cbc                     OBJ_rsadsi,3L,2L\n+\n+#  define SN_rc2_ecb                      \"RC2-ECB\"\n+#  define LN_rc2_ecb                      \"rc2-ecb\"\n+#  define NID_rc2_ecb                     38\n+\n+#  define SN_rc2_cfb64                    \"RC2-CFB\"\n+#  define LN_rc2_cfb64                    \"rc2-cfb\"\n+#  define NID_rc2_cfb64                   39\n+\n+#  define SN_rc2_ofb64                    \"RC2-OFB\"\n+#  define LN_rc2_ofb64                    \"rc2-ofb\"\n+#  define NID_rc2_ofb64                   40\n+\n+#  define SN_sha                          \"SHA\"\n+#  define LN_sha                          \"sha\"\n+#  define NID_sha                         41\n+#  define OBJ_sha                         OBJ_algorithm,18L\n+\n+#  define SN_shaWithRSAEncryption         \"RSA-SHA\"\n+#  define LN_shaWithRSAEncryption         \"shaWithRSAEncryption\"\n+#  define NID_shaWithRSAEncryption        42\n+#  define OBJ_shaWithRSAEncryption        OBJ_algorithm,15L\n+\n+#  define SN_des_ede_cbc                  \"DES-EDE-CBC\"\n+#  define LN_des_ede_cbc                  \"des-ede-cbc\"\n+#  define NID_des_ede_cbc                 43\n+\n+#  define SN_des_ede3_cbc                 \"DES-EDE3-CBC\"\n+#  define LN_des_ede3_cbc                 \"des-ede3-cbc\"\n+#  define NID_des_ede3_cbc                44\n+#  define OBJ_des_ede3_cbc                OBJ_rsadsi,3L,7L\n+\n+#  define SN_des_ofb64                    \"DES-OFB\"\n+#  define LN_des_ofb64                    \"des-ofb\"\n+#  define NID_des_ofb64                   45\n+#  define OBJ_des_ofb64                   OBJ_algorithm,8L\n+\n+#  define SN_idea_ofb64                   \"IDEA-OFB\"\n+#  define LN_idea_ofb64                   \"idea-ofb\"\n+#  define NID_idea_ofb64                  46\n+\n+#  define LN_pkcs9                        \"pkcs9\"\n+#  define NID_pkcs9                       47\n+#  define OBJ_pkcs9                       OBJ_pkcs,9L\n+\n+#  define SN_pkcs9_emailAddress           \"Email\"\n+#  define LN_pkcs9_emailAddress           \"emailAddress\"\n+#  define NID_pkcs9_emailAddress          48\n+#  define OBJ_pkcs9_emailAddress          OBJ_pkcs9,1L\n+\n+#  define LN_pkcs9_unstructuredName       \"unstructuredName\"\n+#  define NID_pkcs9_unstructuredName      49\n+#  define OBJ_pkcs9_unstructuredName      OBJ_pkcs9,2L\n+\n+#  define LN_pkcs9_contentType            \"contentType\"\n+#  define NID_pkcs9_contentType           50\n+#  define OBJ_pkcs9_contentType           OBJ_pkcs9,3L\n+\n+#  define LN_pkcs9_messageDigest          \"messageDigest\"\n+#  define NID_pkcs9_messageDigest         51\n+#  define OBJ_pkcs9_messageDigest         OBJ_pkcs9,4L\n+\n+#  define LN_pkcs9_signingTime            \"signingTime\"\n+#  define NID_pkcs9_signingTime           52\n+#  define OBJ_pkcs9_signingTime           OBJ_pkcs9,5L\n+\n+#  define LN_pkcs9_countersignature       \"countersignature\"\n+#  define NID_pkcs9_countersignature      53\n+#  define OBJ_pkcs9_countersignature      OBJ_pkcs9,6L\n+\n+#  define LN_pkcs9_challengePassword      \"challengePassword\"\n+#  define NID_pkcs9_challengePassword     54\n+#  define OBJ_pkcs9_challengePassword     OBJ_pkcs9,7L\n+\n+#  define LN_pkcs9_unstructuredAddress    \"unstructuredAddress\"\n+#  define NID_pkcs9_unstructuredAddress   55\n+#  define OBJ_pkcs9_unstructuredAddress   OBJ_pkcs9,8L\n+\n+#  define LN_pkcs9_extCertAttributes      \"extendedCertificateAttributes\"\n+#  define NID_pkcs9_extCertAttributes     56\n+#  define OBJ_pkcs9_extCertAttributes     OBJ_pkcs9,9L\n+\n+#  define SN_netscape                     \"Netscape\"\n+#  define LN_netscape                     \"Netscape Communications Corp.\"\n+#  define NID_netscape                    57\n+#  define OBJ_netscape                    2L,16L,840L,1L,113730L\n+\n+#  define SN_netscape_cert_extension      \"nsCertExt\"\n+#  define LN_netscape_cert_extension      \"Netscape Certificate Extension\"\n+#  define NID_netscape_cert_extension     58\n+#  define OBJ_netscape_cert_extension     OBJ_netscape,1L\n+\n+#  define SN_netscape_data_type           \"nsDataType\"\n+#  define LN_netscape_data_type           \"Netscape Data Type\"\n+#  define NID_netscape_data_type          59\n+#  define OBJ_netscape_data_type          OBJ_netscape,2L\n+\n+#  define SN_des_ede_cfb64                \"DES-EDE-CFB\"\n+#  define LN_des_ede_cfb64                \"des-ede-cfb\"\n+#  define NID_des_ede_cfb64               60\n+\n+#  define SN_des_ede3_cfb64               \"DES-EDE3-CFB\"\n+#  define LN_des_ede3_cfb64               \"des-ede3-cfb\"\n+#  define NID_des_ede3_cfb64              61\n+\n+#  define SN_des_ede_ofb64                \"DES-EDE-OFB\"\n+#  define LN_des_ede_ofb64                \"des-ede-ofb\"\n+#  define NID_des_ede_ofb64               62\n+\n+#  define SN_des_ede3_ofb64               \"DES-EDE3-OFB\"\n+#  define LN_des_ede3_ofb64               \"des-ede3-ofb\"\n+#  define NID_des_ede3_ofb64              63\n+\n+/* I'm not sure about the object ID */\n+#  define SN_sha1                         \"SHA1\"\n+#  define LN_sha1                         \"sha1\"\n+#  define NID_sha1                        64\n+#  define OBJ_sha1                        OBJ_algorithm,26L\n+/* 28 Jun 1996 - eay */\n+/* #define OBJ_sha1                     1L,3L,14L,2L,26L,05L <- wrong */\n+\n+#  define SN_sha1WithRSAEncryption        \"RSA-SHA1\"\n+#  define LN_sha1WithRSAEncryption        \"sha1WithRSAEncryption\"\n+#  define NID_sha1WithRSAEncryption       65\n+#  define OBJ_sha1WithRSAEncryption       OBJ_pkcs,1L,5L\n+\n+#  define SN_dsaWithSHA                   \"DSA-SHA\"\n+#  define LN_dsaWithSHA                   \"dsaWithSHA\"\n+#  define NID_dsaWithSHA                  66\n+#  define OBJ_dsaWithSHA                  OBJ_algorithm,13L\n+\n+#  define SN_dsa_2                        \"DSA-old\"\n+#  define LN_dsa_2                        \"dsaEncryption-old\"\n+#  define NID_dsa_2                       67\n+#  define OBJ_dsa_2                       OBJ_algorithm,12L\n+\n+/* proposed by microsoft to RSA */\n+#  define SN_pbeWithSHA1AndRC2_CBC        \"PBE-SHA1-RC2-64\"\n+#  define LN_pbeWithSHA1AndRC2_CBC        \"pbeWithSHA1AndRC2-CBC\"\n+#  define NID_pbeWithSHA1AndRC2_CBC       68\n+#  define OBJ_pbeWithSHA1AndRC2_CBC       OBJ_pkcs,5L,11L\n+\n+/*\n+ * proposed by microsoft to RSA as pbeWithSHA1AndRC4: it is now defined\n+ * explicitly in PKCS#5 v2.0 as id-PBKDF2 which is something completely\n+ * different.\n+ */\n+#  define LN_id_pbkdf2                    \"PBKDF2\"\n+#  define NID_id_pbkdf2                   69\n+#  define OBJ_id_pbkdf2                   OBJ_pkcs,5L,12L\n+\n+#  define SN_dsaWithSHA1_2                \"DSA-SHA1-old\"\n+#  define LN_dsaWithSHA1_2                \"dsaWithSHA1-old\"\n+#  define NID_dsaWithSHA1_2               70\n+/* Got this one from 'sdn706r20.pdf' which is actually an NSA document :-) */\n+#  define OBJ_dsaWithSHA1_2               OBJ_algorithm,27L\n+\n+#  define SN_netscape_cert_type           \"nsCertType\"\n+#  define LN_netscape_cert_type           \"Netscape Cert Type\"\n+#  define NID_netscape_cert_type          71\n+#  define OBJ_netscape_cert_type          OBJ_netscape_cert_extension,1L\n+\n+#  define SN_netscape_base_url            \"nsBaseUrl\"\n+#  define LN_netscape_base_url            \"Netscape Base Url\"\n+#  define NID_netscape_base_url           72\n+#  define OBJ_netscape_base_url           OBJ_netscape_cert_extension,2L\n+\n+#  define SN_netscape_revocation_url      \"nsRevocationUrl\"\n+#  define LN_netscape_revocation_url      \"Netscape Revocation Url\"\n+#  define NID_netscape_revocation_url     73\n+#  define OBJ_netscape_revocation_url     OBJ_netscape_cert_extension,3L\n+\n+#  define SN_netscape_ca_revocation_url   \"nsCaRevocationUrl\"\n+#  define LN_netscape_ca_revocation_url   \"Netscape CA Revocation Url\"\n+#  define NID_netscape_ca_revocation_url  74\n+#  define OBJ_netscape_ca_revocation_url  OBJ_netscape_cert_extension,4L\n+\n+#  define SN_netscape_renewal_url         \"nsRenewalUrl\"\n+#  define LN_netscape_renewal_url         \"Netscape Renewal Url\"\n+#  define NID_netscape_renewal_url        75\n+#  define OBJ_netscape_renewal_url        OBJ_netscape_cert_extension,7L\n+\n+#  define SN_netscape_ca_policy_url       \"nsCaPolicyUrl\"\n+#  define LN_netscape_ca_policy_url       \"Netscape CA Policy Url\"\n+#  define NID_netscape_ca_policy_url      76\n+#  define OBJ_netscape_ca_policy_url      OBJ_netscape_cert_extension,8L\n+\n+#  define SN_netscape_ssl_server_name     \"nsSslServerName\"\n+#  define LN_netscape_ssl_server_name     \"Netscape SSL Server Name\"\n+#  define NID_netscape_ssl_server_name    77\n+#  define OBJ_netscape_ssl_server_name    OBJ_netscape_cert_extension,12L\n+\n+#  define SN_netscape_comment             \"nsComment\"\n+#  define LN_netscape_comment             \"Netscape Comment\"\n+#  define NID_netscape_comment            78\n+#  define OBJ_netscape_comment            OBJ_netscape_cert_extension,13L\n+\n+#  define SN_netscape_cert_sequence       \"nsCertSequence\"\n+#  define LN_netscape_cert_sequence       \"Netscape Certificate Sequence\"\n+#  define NID_netscape_cert_sequence      79\n+#  define OBJ_netscape_cert_sequence      OBJ_netscape_data_type,5L\n+\n+#  define SN_desx_cbc                     \"DESX-CBC\"\n+#  define LN_desx_cbc                     \"desx-cbc\"\n+#  define NID_desx_cbc                    80\n+\n+#  define SN_id_ce                        \"id-ce\"\n+#  define NID_id_ce                       81\n+#  define OBJ_id_ce                       2L,5L,29L\n+\n+#  define SN_subject_key_identifier       \"subjectKeyIdentifier\"\n+#  define LN_subject_key_identifier       \"X509v3 Subject Key Identifier\"\n+#  define NID_subject_key_identifier      82\n+#  define OBJ_subject_key_identifier      OBJ_id_ce,14L\n+\n+#  define SN_key_usage                    \"keyUsage\"\n+#  define LN_key_usage                    \"X509v3 Key Usage\"\n+#  define NID_key_usage                   83\n+#  define OBJ_key_usage                   OBJ_id_ce,15L\n+\n+#  define SN_private_key_usage_period     \"privateKeyUsagePeriod\"\n+#  define LN_private_key_usage_period     \"X509v3 Private Key Usage Period\"\n+#  define NID_private_key_usage_period    84\n+#  define OBJ_private_key_usage_period    OBJ_id_ce,16L\n+\n+#  define SN_subject_alt_name             \"subjectAltName\"\n+#  define LN_subject_alt_name             \"X509v3 Subject Alternative Name\"\n+#  define NID_subject_alt_name            85\n+#  define OBJ_subject_alt_name            OBJ_id_ce,17L\n+\n+#  define SN_issuer_alt_name              \"issuerAltName\"\n+#  define LN_issuer_alt_name              \"X509v3 Issuer Alternative Name\"\n+#  define NID_issuer_alt_name             86\n+#  define OBJ_issuer_alt_name             OBJ_id_ce,18L\n+\n+#  define SN_basic_constraints            \"basicConstraints\"\n+#  define LN_basic_constraints            \"X509v3 Basic Constraints\"\n+#  define NID_basic_constraints           87\n+#  define OBJ_basic_constraints           OBJ_id_ce,19L\n+\n+#  define SN_crl_number                   \"crlNumber\"\n+#  define LN_crl_number                   \"X509v3 CRL Number\"\n+#  define NID_crl_number                  88\n+#  define OBJ_crl_number                  OBJ_id_ce,20L\n+\n+#  define SN_certificate_policies         \"certificatePolicies\"\n+#  define LN_certificate_policies         \"X509v3 Certificate Policies\"\n+#  define NID_certificate_policies        89\n+#  define OBJ_certificate_policies        OBJ_id_ce,32L\n+\n+#  define SN_authority_key_identifier     \"authorityKeyIdentifier\"\n+#  define LN_authority_key_identifier     \"X509v3 Authority Key Identifier\"\n+#  define NID_authority_key_identifier    90\n+#  define OBJ_authority_key_identifier    OBJ_id_ce,35L\n+\n+#  define SN_bf_cbc                       \"BF-CBC\"\n+#  define LN_bf_cbc                       \"bf-cbc\"\n+#  define NID_bf_cbc                      91\n+#  define OBJ_bf_cbc                      1L,3L,6L,1L,4L,1L,3029L,1L,2L\n+\n+#  define SN_bf_ecb                       \"BF-ECB\"\n+#  define LN_bf_ecb                       \"bf-ecb\"\n+#  define NID_bf_ecb                      92\n+\n+#  define SN_bf_cfb64                     \"BF-CFB\"\n+#  define LN_bf_cfb64                     \"bf-cfb\"\n+#  define NID_bf_cfb64                    93\n+\n+#  define SN_bf_ofb64                     \"BF-OFB\"\n+#  define LN_bf_ofb64                     \"bf-ofb\"\n+#  define NID_bf_ofb64                    94\n+\n+#  define SN_mdc2                         \"MDC2\"\n+#  define LN_mdc2                         \"mdc2\"\n+#  define NID_mdc2                        95\n+#  define OBJ_mdc2                        2L,5L,8L,3L,101L\n+/* An alternative?                      1L,3L,14L,3L,2L,19L */\n+\n+#  define SN_mdc2WithRSA                  \"RSA-MDC2\"\n+#  define LN_mdc2WithRSA                  \"mdc2withRSA\"\n+#  define NID_mdc2WithRSA                 96\n+#  define OBJ_mdc2WithRSA                 2L,5L,8L,3L,100L\n+\n+#  define SN_rc4_40                       \"RC4-40\"\n+#  define LN_rc4_40                       \"rc4-40\"\n+#  define NID_rc4_40                      97\n+\n+#  define SN_rc2_40_cbc                   \"RC2-40-CBC\"\n+#  define LN_rc2_40_cbc                   \"rc2-40-cbc\"\n+#  define NID_rc2_40_cbc                  98\n+\n+#  define SN_givenName                    \"G\"\n+#  define LN_givenName                    \"givenName\"\n+#  define NID_givenName                   99\n+#  define OBJ_givenName                   OBJ_X509,42L\n+\n+#  define SN_surname                      \"S\"\n+#  define LN_surname                      \"surname\"\n+#  define NID_surname                     100\n+#  define OBJ_surname                     OBJ_X509,4L\n+\n+#  define SN_initials                     \"I\"\n+#  define LN_initials                     \"initials\"\n+#  define NID_initials                    101\n+#  define OBJ_initials                    OBJ_X509,43L\n+\n+#  define SN_uniqueIdentifier             \"UID\"\n+#  define LN_uniqueIdentifier             \"uniqueIdentifier\"\n+#  define NID_uniqueIdentifier            102\n+#  define OBJ_uniqueIdentifier            OBJ_X509,45L\n+\n+#  define SN_crl_distribution_points      \"crlDistributionPoints\"\n+#  define LN_crl_distribution_points      \"X509v3 CRL Distribution Points\"\n+#  define NID_crl_distribution_points     103\n+#  define OBJ_crl_distribution_points     OBJ_id_ce,31L\n+\n+#  define SN_md5WithRSA                   \"RSA-NP-MD5\"\n+#  define LN_md5WithRSA                   \"md5WithRSA\"\n+#  define NID_md5WithRSA                  104\n+#  define OBJ_md5WithRSA                  OBJ_algorithm,3L\n+\n+#  define SN_serialNumber                 \"SN\"\n+#  define LN_serialNumber                 \"serialNumber\"\n+#  define NID_serialNumber                105\n+#  define OBJ_serialNumber                OBJ_X509,5L\n+\n+#  define SN_title                        \"T\"\n+#  define LN_title                        \"title\"\n+#  define NID_title                       106\n+#  define OBJ_title                       OBJ_X509,12L\n+\n+#  define SN_description                  \"D\"\n+#  define LN_description                  \"description\"\n+#  define NID_description                 107\n+#  define OBJ_description                 OBJ_X509,13L\n+\n+/* CAST5 is CAST-128, I'm just sticking with the documentation */\n+#  define SN_cast5_cbc                    \"CAST5-CBC\"\n+#  define LN_cast5_cbc                    \"cast5-cbc\"\n+#  define NID_cast5_cbc                   108\n+#  define OBJ_cast5_cbc                   1L,2L,840L,113533L,7L,66L,10L\n+\n+#  define SN_cast5_ecb                    \"CAST5-ECB\"\n+#  define LN_cast5_ecb                    \"cast5-ecb\"\n+#  define NID_cast5_ecb                   109\n+\n+#  define SN_cast5_cfb64                  \"CAST5-CFB\"\n+#  define LN_cast5_cfb64                  \"cast5-cfb\"\n+#  define NID_cast5_cfb64                 110\n+\n+#  define SN_cast5_ofb64                  \"CAST5-OFB\"\n+#  define LN_cast5_ofb64                  \"cast5-ofb\"\n+#  define NID_cast5_ofb64                 111\n+\n+#  define LN_pbeWithMD5AndCast5_CBC       \"pbeWithMD5AndCast5CBC\"\n+#  define NID_pbeWithMD5AndCast5_CBC      112\n+#  define OBJ_pbeWithMD5AndCast5_CBC      1L,2L,840L,113533L,7L,66L,12L\n+\n+/*-\n+ * This is one sun will soon be using :-(\n+ * id-dsa-with-sha1 ID  ::= {\n+ *   iso(1) member-body(2) us(840) x9-57 (10040) x9cm(4) 3 }\n+ */\n+#  define SN_dsaWithSHA1                  \"DSA-SHA1\"\n+#  define LN_dsaWithSHA1                  \"dsaWithSHA1\"\n+#  define NID_dsaWithSHA1                 113\n+#  define OBJ_dsaWithSHA1                 1L,2L,840L,10040L,4L,3L\n+\n+#  define NID_md5_sha1                    114\n+#  define SN_md5_sha1                     \"MD5-SHA1\"\n+#  define LN_md5_sha1                     \"md5-sha1\"\n+\n+#  define SN_sha1WithRSA                  \"RSA-SHA1-2\"\n+#  define LN_sha1WithRSA                  \"sha1WithRSA\"\n+#  define NID_sha1WithRSA                 115\n+#  define OBJ_sha1WithRSA                 OBJ_algorithm,29L\n+\n+#  define SN_dsa                          \"DSA\"\n+#  define LN_dsa                          \"dsaEncryption\"\n+#  define NID_dsa                         116\n+#  define OBJ_dsa                         1L,2L,840L,10040L,4L,1L\n+\n+#  define SN_ripemd160                    \"RIPEMD160\"\n+#  define LN_ripemd160                    \"ripemd160\"\n+#  define NID_ripemd160                   117\n+#  define OBJ_ripemd160                   1L,3L,36L,3L,2L,1L\n+\n+/*\n+ * The name should actually be rsaSignatureWithripemd160, but I'm going to\n+ * continue using the convention I'm using with the other ciphers\n+ */\n+#  define SN_ripemd160WithRSA             \"RSA-RIPEMD160\"\n+#  define LN_ripemd160WithRSA             \"ripemd160WithRSA\"\n+#  define NID_ripemd160WithRSA            119\n+#  define OBJ_ripemd160WithRSA            1L,3L,36L,3L,3L,1L,2L\n+\n+/*-\n+ * Taken from rfc2040\n+ *  RC5_CBC_Parameters ::= SEQUENCE {\n+ *      version           INTEGER (v1_0(16)),\n+ *      rounds            INTEGER (8..127),\n+ *      blockSizeInBits   INTEGER (64, 128),\n+ *      iv                OCTET STRING OPTIONAL\n+ *      }\n+ */\n+#  define SN_rc5_cbc                      \"RC5-CBC\"\n+#  define LN_rc5_cbc                      \"rc5-cbc\"\n+#  define NID_rc5_cbc                     120\n+#  define OBJ_rc5_cbc                     OBJ_rsadsi,3L,8L\n+\n+#  define SN_rc5_ecb                      \"RC5-ECB\"\n+#  define LN_rc5_ecb                      \"rc5-ecb\"\n+#  define NID_rc5_ecb                     121\n+\n+#  define SN_rc5_cfb64                    \"RC5-CFB\"\n+#  define LN_rc5_cfb64                    \"rc5-cfb\"\n+#  define NID_rc5_cfb64                   122\n+\n+#  define SN_rc5_ofb64                    \"RC5-OFB\"\n+#  define LN_rc5_ofb64                    \"rc5-ofb\"\n+#  define NID_rc5_ofb64                   123\n+\n+#  define SN_rle_compression              \"RLE\"\n+#  define LN_rle_compression              \"run length compression\"\n+#  define NID_rle_compression             124\n+#  define OBJ_rle_compression             1L,1L,1L,1L,666L,1L\n+\n+#  define SN_zlib_compression             \"ZLIB\"\n+#  define LN_zlib_compression             \"zlib compression\"\n+#  define NID_zlib_compression            125\n+#  define OBJ_zlib_compression            1L,1L,1L,1L,666L,2L\n+\n+#  define SN_ext_key_usage                \"extendedKeyUsage\"\n+#  define LN_ext_key_usage                \"X509v3 Extended Key Usage\"\n+#  define NID_ext_key_usage               126\n+#  define OBJ_ext_key_usage               OBJ_id_ce,37\n+\n+#  define SN_id_pkix                      \"PKIX\"\n+#  define NID_id_pkix                     127\n+#  define OBJ_id_pkix                     1L,3L,6L,1L,5L,5L,7L\n+\n+#  define SN_id_kp                        \"id-kp\"\n+#  define NID_id_kp                       128\n+#  define OBJ_id_kp                       OBJ_id_pkix,3L\n+\n+/* PKIX extended key usage OIDs */\n+\n+#  define SN_server_auth                  \"serverAuth\"\n+#  define LN_server_auth                  \"TLS Web Server Authentication\"\n+#  define NID_server_auth                 129\n+#  define OBJ_server_auth                 OBJ_id_kp,1L\n+\n+#  define SN_client_auth                  \"clientAuth\"\n+#  define LN_client_auth                  \"TLS Web Client Authentication\"\n+#  define NID_client_auth                 130\n+#  define OBJ_client_auth                 OBJ_id_kp,2L\n+\n+#  define SN_code_sign                    \"codeSigning\"\n+#  define LN_code_sign                    \"Code Signing\"\n+#  define NID_code_sign                   131\n+#  define OBJ_code_sign                   OBJ_id_kp,3L\n+\n+#  define SN_email_protect                \"emailProtection\"\n+#  define LN_email_protect                \"E-mail Protection\"\n+#  define NID_email_protect               132\n+#  define OBJ_email_protect               OBJ_id_kp,4L\n+\n+#  define SN_time_stamp                   \"timeStamping\"\n+#  define LN_time_stamp                   \"Time Stamping\"\n+#  define NID_time_stamp                  133\n+#  define OBJ_time_stamp                  OBJ_id_kp,8L\n+\n+/* Additional extended key usage OIDs: Microsoft */\n+\n+#  define SN_ms_code_ind                  \"msCodeInd\"\n+#  define LN_ms_code_ind                  \"Microsoft Individual Code Signing\"\n+#  define NID_ms_code_ind                 134\n+#  define OBJ_ms_code_ind                 1L,3L,6L,1L,4L,1L,311L,2L,1L,21L\n+\n+#  define SN_ms_code_com                  \"msCodeCom\"\n+#  define LN_ms_code_com                  \"Microsoft Commercial Code Signing\"\n+#  define NID_ms_code_com                 135\n+#  define OBJ_ms_code_com                 1L,3L,6L,1L,4L,1L,311L,2L,1L,22L\n+\n+#  define SN_ms_ctl_sign                  \"msCTLSign\"\n+#  define LN_ms_ctl_sign                  \"Microsoft Trust List Signing\"\n+#  define NID_ms_ctl_sign                 136\n+#  define OBJ_ms_ctl_sign                 1L,3L,6L,1L,4L,1L,311L,10L,3L,1L\n+\n+#  define SN_ms_sgc                       \"msSGC\"\n+#  define LN_ms_sgc                       \"Microsoft Server Gated Crypto\"\n+#  define NID_ms_sgc                      137\n+#  define OBJ_ms_sgc                      1L,3L,6L,1L,4L,1L,311L,10L,3L,3L\n+\n+#  define SN_ms_efs                       \"msEFS\"\n+#  define LN_ms_efs                       \"Microsoft Encrypted File System\"\n+#  define NID_ms_efs                      138\n+#  define OBJ_ms_efs                      1L,3L,6L,1L,4L,1L,311L,10L,3L,4L\n+\n+/* Additional usage: Netscape */\n+\n+#  define SN_ns_sgc                       \"nsSGC\"\n+#  define LN_ns_sgc                       \"Netscape Server Gated Crypto\"\n+#  define NID_ns_sgc                      139\n+#  define OBJ_ns_sgc                      OBJ_netscape,4L,1L\n+\n+#  define SN_delta_crl                    \"deltaCRL\"\n+#  define LN_delta_crl                    \"X509v3 Delta CRL Indicator\"\n+#  define NID_delta_crl                   140\n+#  define OBJ_delta_crl                   OBJ_id_ce,27L\n+\n+#  define SN_crl_reason                   \"CRLReason\"\n+#  define LN_crl_reason                   \"CRL Reason Code\"\n+#  define NID_crl_reason                  141\n+#  define OBJ_crl_reason                  OBJ_id_ce,21L\n+\n+#  define SN_invalidity_date              \"invalidityDate\"\n+#  define LN_invalidity_date              \"Invalidity Date\"\n+#  define NID_invalidity_date             142\n+#  define OBJ_invalidity_date             OBJ_id_ce,24L\n+\n+#  define SN_sxnet                        \"SXNetID\"\n+#  define LN_sxnet                        \"Strong Extranet ID\"\n+#  define NID_sxnet                       143\n+#  define OBJ_sxnet                       1L,3L,101L,1L,4L,1L\n+\n+/* PKCS12 and related OBJECT IDENTIFIERS */\n+\n+#  define OBJ_pkcs12                      OBJ_pkcs,12L\n+#  define OBJ_pkcs12_pbeids               OBJ_pkcs12, 1\n+\n+#  define SN_pbe_WithSHA1And128BitRC4     \"PBE-SHA1-RC4-128\"\n+#  define LN_pbe_WithSHA1And128BitRC4     \"pbeWithSHA1And128BitRC4\"\n+#  define NID_pbe_WithSHA1And128BitRC4    144\n+#  define OBJ_pbe_WithSHA1And128BitRC4    OBJ_pkcs12_pbeids, 1L\n+\n+#  define SN_pbe_WithSHA1And40BitRC4      \"PBE-SHA1-RC4-40\"\n+#  define LN_pbe_WithSHA1And40BitRC4      \"pbeWithSHA1And40BitRC4\"\n+#  define NID_pbe_WithSHA1And40BitRC4     145\n+#  define OBJ_pbe_WithSHA1And40BitRC4     OBJ_pkcs12_pbeids, 2L\n+\n+#  define SN_pbe_WithSHA1And3_Key_TripleDES_CBC   \"PBE-SHA1-3DES\"\n+#  define LN_pbe_WithSHA1And3_Key_TripleDES_CBC   \"pbeWithSHA1And3-KeyTripleDES-CBC\"\n+#  define NID_pbe_WithSHA1And3_Key_TripleDES_CBC  146\n+#  define OBJ_pbe_WithSHA1And3_Key_TripleDES_CBC  OBJ_pkcs12_pbeids, 3L\n+\n+#  define SN_pbe_WithSHA1And2_Key_TripleDES_CBC   \"PBE-SHA1-2DES\"\n+#  define LN_pbe_WithSHA1And2_Key_TripleDES_CBC   \"pbeWithSHA1And2-KeyTripleDES-CBC\"\n+#  define NID_pbe_WithSHA1And2_Key_TripleDES_CBC  147\n+#  define OBJ_pbe_WithSHA1And2_Key_TripleDES_CBC  OBJ_pkcs12_pbeids, 4L\n+\n+#  define SN_pbe_WithSHA1And128BitRC2_CBC         \"PBE-SHA1-RC2-128\"\n+#  define LN_pbe_WithSHA1And128BitRC2_CBC         \"pbeWithSHA1And128BitRC2-CBC\"\n+#  define NID_pbe_WithSHA1And128BitRC2_CBC        148\n+#  define OBJ_pbe_WithSHA1And128BitRC2_CBC        OBJ_pkcs12_pbeids, 5L\n+\n+#  define SN_pbe_WithSHA1And40BitRC2_CBC  \"PBE-SHA1-RC2-40\"\n+#  define LN_pbe_WithSHA1And40BitRC2_CBC  \"pbeWithSHA1And40BitRC2-CBC\"\n+#  define NID_pbe_WithSHA1And40BitRC2_CBC 149\n+#  define OBJ_pbe_WithSHA1And40BitRC2_CBC OBJ_pkcs12_pbeids, 6L\n+\n+#  define OBJ_pkcs12_Version1     OBJ_pkcs12, 10L\n+\n+#  define OBJ_pkcs12_BagIds       OBJ_pkcs12_Version1, 1L\n+\n+#  define LN_keyBag               \"keyBag\"\n+#  define NID_keyBag              150\n+#  define OBJ_keyBag              OBJ_pkcs12_BagIds, 1L\n+\n+#  define LN_pkcs8ShroudedKeyBag  \"pkcs8ShroudedKeyBag\"\n+#  define NID_pkcs8ShroudedKeyBag 151\n+#  define OBJ_pkcs8ShroudedKeyBag OBJ_pkcs12_BagIds, 2L\n+\n+#  define LN_certBag              \"certBag\"\n+#  define NID_certBag             152\n+#  define OBJ_certBag             OBJ_pkcs12_BagIds, 3L\n+\n+#  define LN_crlBag               \"crlBag\"\n+#  define NID_crlBag              153\n+#  define OBJ_crlBag              OBJ_pkcs12_BagIds, 4L\n+\n+#  define LN_secretBag            \"secretBag\"\n+#  define NID_secretBag           154\n+#  define OBJ_secretBag           OBJ_pkcs12_BagIds, 5L\n+\n+#  define LN_safeContentsBag      \"safeContentsBag\"\n+#  define NID_safeContentsBag     155\n+#  define OBJ_safeContentsBag     OBJ_pkcs12_BagIds, 6L\n+\n+#  define LN_friendlyName         \"friendlyName\"\n+#  define NID_friendlyName        156\n+#  define OBJ_friendlyName        OBJ_pkcs9, 20L\n+\n+#  define LN_localKeyID           \"localKeyID\"\n+#  define NID_localKeyID          157\n+#  define OBJ_localKeyID          OBJ_pkcs9, 21L\n+\n+#  define OBJ_certTypes           OBJ_pkcs9, 22L\n+\n+#  define LN_x509Certificate      \"x509Certificate\"\n+#  define NID_x509Certificate     158\n+#  define OBJ_x509Certificate     OBJ_certTypes, 1L\n+\n+#  define LN_sdsiCertificate      \"sdsiCertificate\"\n+#  define NID_sdsiCertificate     159\n+#  define OBJ_sdsiCertificate     OBJ_certTypes, 2L\n+\n+#  define OBJ_crlTypes            OBJ_pkcs9, 23L\n+\n+#  define LN_x509Crl              \"x509Crl\"\n+#  define NID_x509Crl             160\n+#  define OBJ_x509Crl             OBJ_crlTypes, 1L\n+\n+/* PKCS#5 v2 OIDs */\n+\n+#  define LN_pbes2                \"PBES2\"\n+#  define NID_pbes2               161\n+#  define OBJ_pbes2               OBJ_pkcs,5L,13L\n+\n+#  define LN_pbmac1               \"PBMAC1\"\n+#  define NID_pbmac1              162\n+#  define OBJ_pbmac1              OBJ_pkcs,5L,14L\n+\n+#  define LN_hmacWithSHA1         \"hmacWithSHA1\"\n+#  define NID_hmacWithSHA1        163\n+#  define OBJ_hmacWithSHA1        OBJ_rsadsi,2L,7L\n+\n+/* Policy Qualifier Ids */\n+\n+#  define LN_id_qt_cps            \"Policy Qualifier CPS\"\n+#  define SN_id_qt_cps            \"id-qt-cps\"\n+#  define NID_id_qt_cps           164\n+#  define OBJ_id_qt_cps           OBJ_id_pkix,2L,1L\n+\n+#  define LN_id_qt_unotice        \"Policy Qualifier User Notice\"\n+#  define SN_id_qt_unotice        \"id-qt-unotice\"\n+#  define NID_id_qt_unotice       165\n+#  define OBJ_id_qt_unotice       OBJ_id_pkix,2L,2L\n+\n+#  define SN_rc2_64_cbc                   \"RC2-64-CBC\"\n+#  define LN_rc2_64_cbc                   \"rc2-64-cbc\"\n+#  define NID_rc2_64_cbc                  166\n+\n+#  define SN_SMIMECapabilities            \"SMIME-CAPS\"\n+#  define LN_SMIMECapabilities            \"S/MIME Capabilities\"\n+#  define NID_SMIMECapabilities           167\n+#  define OBJ_SMIMECapabilities           OBJ_pkcs9,15L\n+\n+#  define SN_pbeWithMD2AndRC2_CBC         \"PBE-MD2-RC2-64\"\n+#  define LN_pbeWithMD2AndRC2_CBC         \"pbeWithMD2AndRC2-CBC\"\n+#  define NID_pbeWithMD2AndRC2_CBC        168\n+#  define OBJ_pbeWithMD2AndRC2_CBC        OBJ_pkcs,5L,4L\n+\n+#  define SN_pbeWithMD5AndRC2_CBC         \"PBE-MD5-RC2-64\"\n+#  define LN_pbeWithMD5AndRC2_CBC         \"pbeWithMD5AndRC2-CBC\"\n+#  define NID_pbeWithMD5AndRC2_CBC        169\n+#  define OBJ_pbeWithMD5AndRC2_CBC        OBJ_pkcs,5L,6L\n+\n+#  define SN_pbeWithSHA1AndDES_CBC        \"PBE-SHA1-DES\"\n+#  define LN_pbeWithSHA1AndDES_CBC        \"pbeWithSHA1AndDES-CBC\"\n+#  define NID_pbeWithSHA1AndDES_CBC       170\n+#  define OBJ_pbeWithSHA1AndDES_CBC       OBJ_pkcs,5L,10L\n+\n+/* Extension request OIDs */\n+\n+#  define LN_ms_ext_req                   \"Microsoft Extension Request\"\n+#  define SN_ms_ext_req                   \"msExtReq\"\n+#  define NID_ms_ext_req                  171\n+#  define OBJ_ms_ext_req                  1L,3L,6L,1L,4L,1L,311L,2L,1L,14L\n+\n+#  define LN_ext_req                      \"Extension Request\"\n+#  define SN_ext_req                      \"extReq\"\n+#  define NID_ext_req                     172\n+#  define OBJ_ext_req                     OBJ_pkcs9,14L\n+\n+#  define SN_name                         \"name\"\n+#  define LN_name                         \"name\"\n+#  define NID_name                        173\n+#  define OBJ_name                        OBJ_X509,41L\n+\n+#  define SN_dnQualifier                  \"dnQualifier\"\n+#  define LN_dnQualifier                  \"dnQualifier\"\n+#  define NID_dnQualifier                 174\n+#  define OBJ_dnQualifier                 OBJ_X509,46L\n+\n+#  define SN_id_pe                        \"id-pe\"\n+#  define NID_id_pe                       175\n+#  define OBJ_id_pe                       OBJ_id_pkix,1L\n+\n+#  define SN_id_ad                        \"id-ad\"\n+#  define NID_id_ad                       176\n+#  define OBJ_id_ad                       OBJ_id_pkix,48L\n+\n+#  define SN_info_access                  \"authorityInfoAccess\"\n+#  define LN_info_access                  \"Authority Information Access\"\n+#  define NID_info_access                 177\n+#  define OBJ_info_access                 OBJ_id_pe,1L\n+\n+#  define SN_ad_OCSP                      \"OCSP\"\n+#  define LN_ad_OCSP                      \"OCSP\"\n+#  define NID_ad_OCSP                     178\n+#  define OBJ_ad_OCSP                     OBJ_id_ad,1L\n+\n+#  define SN_ad_ca_issuers                \"caIssuers\"\n+#  define LN_ad_ca_issuers                \"CA Issuers\"\n+#  define NID_ad_ca_issuers               179\n+#  define OBJ_ad_ca_issuers               OBJ_id_ad,2L\n+\n+#  define SN_OCSP_sign                    \"OCSPSigning\"\n+#  define LN_OCSP_sign                    \"OCSP Signing\"\n+#  define NID_OCSP_sign                   180\n+#  define OBJ_OCSP_sign                   OBJ_id_kp,9L\n+# endif                         /* USE_OBJ_MAC */\n+\n+# include <openssl/bio.h>\n+# include <openssl/asn1.h>\n+\n+# define OBJ_NAME_TYPE_UNDEF             0x00\n+# define OBJ_NAME_TYPE_MD_METH           0x01\n+# define OBJ_NAME_TYPE_CIPHER_METH       0x02\n+# define OBJ_NAME_TYPE_PKEY_METH         0x03\n+# define OBJ_NAME_TYPE_COMP_METH         0x04\n+# define OBJ_NAME_TYPE_NUM               0x05\n+\n+# define OBJ_NAME_ALIAS                  0x8000\n+\n+# define OBJ_BSEARCH_VALUE_ON_NOMATCH            0x01\n+# define OBJ_BSEARCH_FIRST_VALUE_ON_MATCH        0x02\n+\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct obj_name_st {\n+    int type;\n+    int alias;\n+    const char *name;\n+    const char *data;\n+} OBJ_NAME;\n+\n+# define         OBJ_create_and_add_object(a,b,c) OBJ_create(a,b,c)\n+\n+int OBJ_NAME_init(void);\n+int OBJ_NAME_new_index(unsigned long (*hash_func) (const char *),\n+                       int (*cmp_func) (const char *, const char *),\n+                       void (*free_func) (const char *, int, const char *));\n+const char *OBJ_NAME_get(const char *name, int type);\n+int OBJ_NAME_add(const char *name, int type, const char *data);\n+int OBJ_NAME_remove(const char *name, int type);\n+void OBJ_NAME_cleanup(int type); /* -1 for everything */\n+void OBJ_NAME_do_all(int type, void (*fn) (const OBJ_NAME *, void *arg),\n+                     void *arg);\n+void OBJ_NAME_do_all_sorted(int type,\n+                            void (*fn) (const OBJ_NAME *, void *arg),\n+                            void *arg);\n+\n+ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o);\n+ASN1_OBJECT *OBJ_nid2obj(int n);\n+const char *OBJ_nid2ln(int n);\n+const char *OBJ_nid2sn(int n);\n+int OBJ_obj2nid(const ASN1_OBJECT *o);\n+ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name);\n+int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);\n+int OBJ_txt2nid(const char *s);\n+int OBJ_ln2nid(const char *s);\n+int OBJ_sn2nid(const char *s);\n+int OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b);\n+const void *OBJ_bsearch_(const void *key, const void *base, int num, int size,\n+                         int (*cmp) (const void *, const void *));\n+const void *OBJ_bsearch_ex_(const void *key, const void *base, int num,\n+                            int size,\n+                            int (*cmp) (const void *, const void *),\n+                            int flags);\n+\n+# define _DECLARE_OBJ_BSEARCH_CMP_FN(scope, type1, type2, nm)    \\\n+  static int nm##_cmp_BSEARCH_CMP_FN(const void *, const void *); \\\n+  static int nm##_cmp(type1 const *, type2 const *); \\\n+  scope type2 * OBJ_bsearch_##nm(type1 *key, type2 const *base, int num)\n+\n+# define DECLARE_OBJ_BSEARCH_CMP_FN(type1, type2, cmp)   \\\n+  _DECLARE_OBJ_BSEARCH_CMP_FN(static, type1, type2, cmp)\n+# define DECLARE_OBJ_BSEARCH_GLOBAL_CMP_FN(type1, type2, nm)     \\\n+  type2 * OBJ_bsearch_##nm(type1 *key, type2 const *base, int num)\n+\n+/*-\n+ * Unsolved problem: if a type is actually a pointer type, like\n+ * nid_triple is, then its impossible to get a const where you need\n+ * it. Consider:\n+ *\n+ * typedef int nid_triple[3];\n+ * const void *a_;\n+ * const nid_triple const *a = a_;\n+ *\n+ * The assignement discards a const because what you really want is:\n+ *\n+ * const int const * const *a = a_;\n+ *\n+ * But if you do that, you lose the fact that a is an array of 3 ints,\n+ * which breaks comparison functions.\n+ *\n+ * Thus we end up having to cast, sadly, or unpack the\n+ * declarations. Or, as I finally did in this case, delcare nid_triple\n+ * to be a struct, which it should have been in the first place.\n+ *\n+ * Ben, August 2008.\n+ *\n+ * Also, strictly speaking not all types need be const, but handling\n+ * the non-constness means a lot of complication, and in practice\n+ * comparison routines do always not touch their arguments.\n+ */\n+\n+# define IMPLEMENT_OBJ_BSEARCH_CMP_FN(type1, type2, nm)  \\\n+  static int nm##_cmp_BSEARCH_CMP_FN(const void *a_, const void *b_)    \\\n+      { \\\n+      type1 const *a = a_; \\\n+      type2 const *b = b_; \\\n+      return nm##_cmp(a,b); \\\n+      } \\\n+  static type2 *OBJ_bsearch_##nm(type1 *key, type2 const *base, int num) \\\n+      { \\\n+      return (type2 *)OBJ_bsearch_(key, base, num, sizeof(type2), \\\n+                                        nm##_cmp_BSEARCH_CMP_FN); \\\n+      } \\\n+      extern void dummy_prototype(void)\n+\n+# define IMPLEMENT_OBJ_BSEARCH_GLOBAL_CMP_FN(type1, type2, nm)   \\\n+  static int nm##_cmp_BSEARCH_CMP_FN(const void *a_, const void *b_)    \\\n+      { \\\n+      type1 const *a = a_; \\\n+      type2 const *b = b_; \\\n+      return nm##_cmp(a,b); \\\n+      } \\\n+  type2 *OBJ_bsearch_##nm(type1 *key, type2 const *base, int num) \\\n+      { \\\n+      return (type2 *)OBJ_bsearch_(key, base, num, sizeof(type2), \\\n+                                        nm##_cmp_BSEARCH_CMP_FN); \\\n+      } \\\n+      extern void dummy_prototype(void)\n+\n+# define OBJ_bsearch(type1,key,type2,base,num,cmp)                              \\\n+  ((type2 *)OBJ_bsearch_(CHECKED_PTR_OF(type1,key),CHECKED_PTR_OF(type2,base), \\\n+                         num,sizeof(type2),                             \\\n+                         ((void)CHECKED_PTR_OF(type1,cmp##_type_1),     \\\n+                          (void)CHECKED_PTR_OF(type2,cmp##_type_2),     \\\n+                          cmp##_BSEARCH_CMP_FN)))\n+\n+# define OBJ_bsearch_ex(type1,key,type2,base,num,cmp,flags)                      \\\n+  ((type2 *)OBJ_bsearch_ex_(CHECKED_PTR_OF(type1,key),CHECKED_PTR_OF(type2,base), \\\n+                         num,sizeof(type2),                             \\\n+                         ((void)CHECKED_PTR_OF(type1,cmp##_type_1),     \\\n+                          (void)type_2=CHECKED_PTR_OF(type2,cmp##_type_2), \\\n+                          cmp##_BSEARCH_CMP_FN)),flags)\n+\n+int OBJ_new_nid(int num);\n+int OBJ_add_object(const ASN1_OBJECT *obj);\n+int OBJ_create(const char *oid, const char *sn, const char *ln);\n+void OBJ_cleanup(void);\n+int OBJ_create_objects(BIO *in);\n+\n+int OBJ_find_sigid_algs(int signid, int *pdig_nid, int *ppkey_nid);\n+int OBJ_find_sigid_by_algs(int *psignid, int dig_nid, int pkey_nid);\n+int OBJ_add_sigid(int signid, int dig_id, int pkey_id);\n+void OBJ_sigid_free(void);\n+\n+extern int obj_cleanup_defer;\n+void check_defer(int nid);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_OBJ_strings(void);\n+\n+/* Error codes for the OBJ functions. */\n+\n+/* Function codes. */\n+# define OBJ_F_OBJ_ADD_OBJECT                             105\n+# define OBJ_F_OBJ_CREATE                                 100\n+# define OBJ_F_OBJ_DUP                                    101\n+# define OBJ_F_OBJ_NAME_NEW_INDEX                         106\n+# define OBJ_F_OBJ_NID2LN                                 102\n+# define OBJ_F_OBJ_NID2OBJ                                103\n+# define OBJ_F_OBJ_NID2SN                                 104\n+\n+/* Reason codes. */\n+# define OBJ_R_MALLOC_FAILURE                             100\n+# define OBJ_R_UNKNOWN_NID                                101\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "ca2ee76dce472fbb0978e596bc7699fe05596746",
            "filename": "deps/openssl/openssl/include/openssl/ocsp.h",
            "status": "added",
            "additions": 637,
            "deletions": 0,
            "changes": 637,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Focsp.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Focsp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Focsp.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,637 @@\n+/* ocsp.h */\n+/*\n+ * Written by Tom Titchener <Tom_Titchener@groove.net> for the OpenSSL\n+ * project.\n+ */\n+\n+/*\n+ * History: This file was transfered to Richard Levitte from CertCo by Kathy\n+ * Weinhold in mid-spring 2000 to be included in OpenSSL or released as a\n+ * patch kit.\n+ */\n+\n+/* ====================================================================\n+ * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#ifndef HEADER_OCSP_H\n+# define HEADER_OCSP_H\n+\n+# include <openssl/ossl_typ.h>\n+# include <openssl/x509.h>\n+# include <openssl/x509v3.h>\n+# include <openssl/safestack.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Various flags and values */\n+\n+# define OCSP_DEFAULT_NONCE_LENGTH       16\n+\n+# define OCSP_NOCERTS                    0x1\n+# define OCSP_NOINTERN                   0x2\n+# define OCSP_NOSIGS                     0x4\n+# define OCSP_NOCHAIN                    0x8\n+# define OCSP_NOVERIFY                   0x10\n+# define OCSP_NOEXPLICIT                 0x20\n+# define OCSP_NOCASIGN                   0x40\n+# define OCSP_NODELEGATED                0x80\n+# define OCSP_NOCHECKS                   0x100\n+# define OCSP_TRUSTOTHER                 0x200\n+# define OCSP_RESPID_KEY                 0x400\n+# define OCSP_NOTIME                     0x800\n+\n+/*-  CertID ::= SEQUENCE {\n+ *       hashAlgorithm            AlgorithmIdentifier,\n+ *       issuerNameHash     OCTET STRING, -- Hash of Issuer's DN\n+ *       issuerKeyHash      OCTET STRING, -- Hash of Issuers public key (excluding the tag & length fields)\n+ *       serialNumber       CertificateSerialNumber }\n+ */\n+typedef struct ocsp_cert_id_st {\n+    X509_ALGOR *hashAlgorithm;\n+    ASN1_OCTET_STRING *issuerNameHash;\n+    ASN1_OCTET_STRING *issuerKeyHash;\n+    ASN1_INTEGER *serialNumber;\n+} OCSP_CERTID;\n+\n+DECLARE_STACK_OF(OCSP_CERTID)\n+\n+/*-  Request ::=     SEQUENCE {\n+ *       reqCert                    CertID,\n+ *       singleRequestExtensions    [0] EXPLICIT Extensions OPTIONAL }\n+ */\n+typedef struct ocsp_one_request_st {\n+    OCSP_CERTID *reqCert;\n+    STACK_OF(X509_EXTENSION) *singleRequestExtensions;\n+} OCSP_ONEREQ;\n+\n+DECLARE_STACK_OF(OCSP_ONEREQ)\n+DECLARE_ASN1_SET_OF(OCSP_ONEREQ)\n+\n+/*-  TBSRequest      ::=     SEQUENCE {\n+ *       version             [0] EXPLICIT Version DEFAULT v1,\n+ *       requestorName       [1] EXPLICIT GeneralName OPTIONAL,\n+ *       requestList             SEQUENCE OF Request,\n+ *       requestExtensions   [2] EXPLICIT Extensions OPTIONAL }\n+ */\n+typedef struct ocsp_req_info_st {\n+    ASN1_INTEGER *version;\n+    GENERAL_NAME *requestorName;\n+    STACK_OF(OCSP_ONEREQ) *requestList;\n+    STACK_OF(X509_EXTENSION) *requestExtensions;\n+} OCSP_REQINFO;\n+\n+/*-  Signature       ::=     SEQUENCE {\n+ *       signatureAlgorithm   AlgorithmIdentifier,\n+ *       signature            BIT STRING,\n+ *       certs                [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }\n+ */\n+typedef struct ocsp_signature_st {\n+    X509_ALGOR *signatureAlgorithm;\n+    ASN1_BIT_STRING *signature;\n+    STACK_OF(X509) *certs;\n+} OCSP_SIGNATURE;\n+\n+/*-  OCSPRequest     ::=     SEQUENCE {\n+ *       tbsRequest                  TBSRequest,\n+ *       optionalSignature   [0]     EXPLICIT Signature OPTIONAL }\n+ */\n+typedef struct ocsp_request_st {\n+    OCSP_REQINFO *tbsRequest;\n+    OCSP_SIGNATURE *optionalSignature; /* OPTIONAL */\n+} OCSP_REQUEST;\n+\n+/*-  OCSPResponseStatus ::= ENUMERATED {\n+ *       successful            (0),      --Response has valid confirmations\n+ *       malformedRequest      (1),      --Illegal confirmation request\n+ *       internalError         (2),      --Internal error in issuer\n+ *       tryLater              (3),      --Try again later\n+ *                                       --(4) is not used\n+ *       sigRequired           (5),      --Must sign the request\n+ *       unauthorized          (6)       --Request unauthorized\n+ *   }\n+ */\n+# define OCSP_RESPONSE_STATUS_SUCCESSFUL          0\n+# define OCSP_RESPONSE_STATUS_MALFORMEDREQUEST     1\n+# define OCSP_RESPONSE_STATUS_INTERNALERROR        2\n+# define OCSP_RESPONSE_STATUS_TRYLATER             3\n+# define OCSP_RESPONSE_STATUS_SIGREQUIRED          5\n+# define OCSP_RESPONSE_STATUS_UNAUTHORIZED         6\n+\n+/*-  ResponseBytes ::=       SEQUENCE {\n+ *       responseType   OBJECT IDENTIFIER,\n+ *       response       OCTET STRING }\n+ */\n+typedef struct ocsp_resp_bytes_st {\n+    ASN1_OBJECT *responseType;\n+    ASN1_OCTET_STRING *response;\n+} OCSP_RESPBYTES;\n+\n+/*-  OCSPResponse ::= SEQUENCE {\n+ *      responseStatus         OCSPResponseStatus,\n+ *      responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL }\n+ */\n+struct ocsp_response_st {\n+    ASN1_ENUMERATED *responseStatus;\n+    OCSP_RESPBYTES *responseBytes;\n+};\n+\n+/*-  ResponderID ::= CHOICE {\n+ *      byName   [1] Name,\n+ *      byKey    [2] KeyHash }\n+ */\n+# define V_OCSP_RESPID_NAME 0\n+# define V_OCSP_RESPID_KEY  1\n+struct ocsp_responder_id_st {\n+    int type;\n+    union {\n+        X509_NAME *byName;\n+        ASN1_OCTET_STRING *byKey;\n+    } value;\n+};\n+\n+DECLARE_STACK_OF(OCSP_RESPID)\n+DECLARE_ASN1_FUNCTIONS(OCSP_RESPID)\n+\n+/*-  KeyHash ::= OCTET STRING --SHA-1 hash of responder's public key\n+ *                            --(excluding the tag and length fields)\n+ */\n+\n+/*-  RevokedInfo ::= SEQUENCE {\n+ *       revocationTime              GeneralizedTime,\n+ *       revocationReason    [0]     EXPLICIT CRLReason OPTIONAL }\n+ */\n+typedef struct ocsp_revoked_info_st {\n+    ASN1_GENERALIZEDTIME *revocationTime;\n+    ASN1_ENUMERATED *revocationReason;\n+} OCSP_REVOKEDINFO;\n+\n+/*-  CertStatus ::= CHOICE {\n+ *       good                [0]     IMPLICIT NULL,\n+ *       revoked             [1]     IMPLICIT RevokedInfo,\n+ *       unknown             [2]     IMPLICIT UnknownInfo }\n+ */\n+# define V_OCSP_CERTSTATUS_GOOD    0\n+# define V_OCSP_CERTSTATUS_REVOKED 1\n+# define V_OCSP_CERTSTATUS_UNKNOWN 2\n+typedef struct ocsp_cert_status_st {\n+    int type;\n+    union {\n+        ASN1_NULL *good;\n+        OCSP_REVOKEDINFO *revoked;\n+        ASN1_NULL *unknown;\n+    } value;\n+} OCSP_CERTSTATUS;\n+\n+/*-  SingleResponse ::= SEQUENCE {\n+ *      certID                       CertID,\n+ *      certStatus                   CertStatus,\n+ *      thisUpdate                   GeneralizedTime,\n+ *      nextUpdate           [0]     EXPLICIT GeneralizedTime OPTIONAL,\n+ *      singleExtensions     [1]     EXPLICIT Extensions OPTIONAL }\n+ */\n+typedef struct ocsp_single_response_st {\n+    OCSP_CERTID *certId;\n+    OCSP_CERTSTATUS *certStatus;\n+    ASN1_GENERALIZEDTIME *thisUpdate;\n+    ASN1_GENERALIZEDTIME *nextUpdate;\n+    STACK_OF(X509_EXTENSION) *singleExtensions;\n+} OCSP_SINGLERESP;\n+\n+DECLARE_STACK_OF(OCSP_SINGLERESP)\n+DECLARE_ASN1_SET_OF(OCSP_SINGLERESP)\n+\n+/*-  ResponseData ::= SEQUENCE {\n+ *      version              [0] EXPLICIT Version DEFAULT v1,\n+ *      responderID              ResponderID,\n+ *      producedAt               GeneralizedTime,\n+ *      responses                SEQUENCE OF SingleResponse,\n+ *      responseExtensions   [1] EXPLICIT Extensions OPTIONAL }\n+ */\n+typedef struct ocsp_response_data_st {\n+    ASN1_INTEGER *version;\n+    OCSP_RESPID *responderId;\n+    ASN1_GENERALIZEDTIME *producedAt;\n+    STACK_OF(OCSP_SINGLERESP) *responses;\n+    STACK_OF(X509_EXTENSION) *responseExtensions;\n+} OCSP_RESPDATA;\n+\n+/*-  BasicOCSPResponse       ::= SEQUENCE {\n+ *      tbsResponseData      ResponseData,\n+ *      signatureAlgorithm   AlgorithmIdentifier,\n+ *      signature            BIT STRING,\n+ *      certs                [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }\n+ */\n+  /*\n+   * Note 1: The value for \"signature\" is specified in the OCSP rfc2560 as\n+   * follows: \"The value for the signature SHALL be computed on the hash of\n+   * the DER encoding ResponseData.\" This means that you must hash the\n+   * DER-encoded tbsResponseData, and then run it through a crypto-signing\n+   * function, which will (at least w/RSA) do a hash-'n'-private-encrypt\n+   * operation.  This seems a bit odd, but that's the spec.  Also note that\n+   * the data structures do not leave anywhere to independently specify the\n+   * algorithm used for the initial hash. So, we look at the\n+   * signature-specification algorithm, and try to do something intelligent.\n+   * -- Kathy Weinhold, CertCo\n+   */\n+  /*\n+   * Note 2: It seems that the mentioned passage from RFC 2560 (section\n+   * 4.2.1) is open for interpretation.  I've done tests against another\n+   * responder, and found that it doesn't do the double hashing that the RFC\n+   * seems to say one should.  Therefore, all relevant functions take a flag\n+   * saying which variant should be used.  -- Richard Levitte, OpenSSL team\n+   * and CeloCom\n+   */\n+typedef struct ocsp_basic_response_st {\n+    OCSP_RESPDATA *tbsResponseData;\n+    X509_ALGOR *signatureAlgorithm;\n+    ASN1_BIT_STRING *signature;\n+    STACK_OF(X509) *certs;\n+} OCSP_BASICRESP;\n+\n+/*-\n+ *   CRLReason ::= ENUMERATED {\n+ *        unspecified             (0),\n+ *        keyCompromise           (1),\n+ *        cACompromise            (2),\n+ *        affiliationChanged      (3),\n+ *        superseded              (4),\n+ *        cessationOfOperation    (5),\n+ *        certificateHold         (6),\n+ *        removeFromCRL           (8) }\n+ */\n+# define OCSP_REVOKED_STATUS_NOSTATUS               -1\n+# define OCSP_REVOKED_STATUS_UNSPECIFIED             0\n+# define OCSP_REVOKED_STATUS_KEYCOMPROMISE           1\n+# define OCSP_REVOKED_STATUS_CACOMPROMISE            2\n+# define OCSP_REVOKED_STATUS_AFFILIATIONCHANGED      3\n+# define OCSP_REVOKED_STATUS_SUPERSEDED              4\n+# define OCSP_REVOKED_STATUS_CESSATIONOFOPERATION    5\n+# define OCSP_REVOKED_STATUS_CERTIFICATEHOLD         6\n+# define OCSP_REVOKED_STATUS_REMOVEFROMCRL           8\n+\n+/*-\n+ * CrlID ::= SEQUENCE {\n+ *     crlUrl               [0]     EXPLICIT IA5String OPTIONAL,\n+ *     crlNum               [1]     EXPLICIT INTEGER OPTIONAL,\n+ *     crlTime              [2]     EXPLICIT GeneralizedTime OPTIONAL }\n+ */\n+typedef struct ocsp_crl_id_st {\n+    ASN1_IA5STRING *crlUrl;\n+    ASN1_INTEGER *crlNum;\n+    ASN1_GENERALIZEDTIME *crlTime;\n+} OCSP_CRLID;\n+\n+/*-\n+ * ServiceLocator ::= SEQUENCE {\n+ *      issuer    Name,\n+ *      locator   AuthorityInfoAccessSyntax OPTIONAL }\n+ */\n+typedef struct ocsp_service_locator_st {\n+    X509_NAME *issuer;\n+    STACK_OF(ACCESS_DESCRIPTION) *locator;\n+} OCSP_SERVICELOC;\n+\n+# define PEM_STRING_OCSP_REQUEST \"OCSP REQUEST\"\n+# define PEM_STRING_OCSP_RESPONSE \"OCSP RESPONSE\"\n+\n+# define d2i_OCSP_REQUEST_bio(bp,p) ASN1_d2i_bio_of(OCSP_REQUEST,OCSP_REQUEST_new,d2i_OCSP_REQUEST,bp,p)\n+\n+# define d2i_OCSP_RESPONSE_bio(bp,p) ASN1_d2i_bio_of(OCSP_RESPONSE,OCSP_RESPONSE_new,d2i_OCSP_RESPONSE,bp,p)\n+\n+# define PEM_read_bio_OCSP_REQUEST(bp,x,cb) (OCSP_REQUEST *)PEM_ASN1_read_bio( \\\n+     (char *(*)())d2i_OCSP_REQUEST,PEM_STRING_OCSP_REQUEST,bp,(char **)x,cb,NULL)\n+\n+# define PEM_read_bio_OCSP_RESPONSE(bp,x,cb)(OCSP_RESPONSE *)PEM_ASN1_read_bio(\\\n+     (char *(*)())d2i_OCSP_RESPONSE,PEM_STRING_OCSP_RESPONSE,bp,(char **)x,cb,NULL)\n+\n+# define PEM_write_bio_OCSP_REQUEST(bp,o) \\\n+    PEM_ASN1_write_bio((int (*)())i2d_OCSP_REQUEST,PEM_STRING_OCSP_REQUEST,\\\n+                        bp,(char *)o, NULL,NULL,0,NULL,NULL)\n+\n+# define PEM_write_bio_OCSP_RESPONSE(bp,o) \\\n+    PEM_ASN1_write_bio((int (*)())i2d_OCSP_RESPONSE,PEM_STRING_OCSP_RESPONSE,\\\n+                        bp,(char *)o, NULL,NULL,0,NULL,NULL)\n+\n+# define i2d_OCSP_RESPONSE_bio(bp,o) ASN1_i2d_bio_of(OCSP_RESPONSE,i2d_OCSP_RESPONSE,bp,o)\n+\n+# define i2d_OCSP_REQUEST_bio(bp,o) ASN1_i2d_bio_of(OCSP_REQUEST,i2d_OCSP_REQUEST,bp,o)\n+\n+# define OCSP_REQUEST_sign(o,pkey,md) \\\n+        ASN1_item_sign(ASN1_ITEM_rptr(OCSP_REQINFO),\\\n+                o->optionalSignature->signatureAlgorithm,NULL,\\\n+                o->optionalSignature->signature,o->tbsRequest,pkey,md)\n+\n+# define OCSP_BASICRESP_sign(o,pkey,md,d) \\\n+        ASN1_item_sign(ASN1_ITEM_rptr(OCSP_RESPDATA),o->signatureAlgorithm,NULL,\\\n+                o->signature,o->tbsResponseData,pkey,md)\n+\n+# define OCSP_REQUEST_verify(a,r) ASN1_item_verify(ASN1_ITEM_rptr(OCSP_REQINFO),\\\n+        a->optionalSignature->signatureAlgorithm,\\\n+        a->optionalSignature->signature,a->tbsRequest,r)\n+\n+# define OCSP_BASICRESP_verify(a,r,d) ASN1_item_verify(ASN1_ITEM_rptr(OCSP_RESPDATA),\\\n+        a->signatureAlgorithm,a->signature,a->tbsResponseData,r)\n+\n+# define ASN1_BIT_STRING_digest(data,type,md,len) \\\n+        ASN1_item_digest(ASN1_ITEM_rptr(ASN1_BIT_STRING),type,data,md,len)\n+\n+# define OCSP_CERTSTATUS_dup(cs)\\\n+                (OCSP_CERTSTATUS*)ASN1_dup((int(*)())i2d_OCSP_CERTSTATUS,\\\n+                (char *(*)())d2i_OCSP_CERTSTATUS,(char *)(cs))\n+\n+OCSP_CERTID *OCSP_CERTID_dup(OCSP_CERTID *id);\n+\n+OCSP_RESPONSE *OCSP_sendreq_bio(BIO *b, const char *path, OCSP_REQUEST *req);\n+OCSP_REQ_CTX *OCSP_sendreq_new(BIO *io, const char *path, OCSP_REQUEST *req,\n+                               int maxline);\n+int OCSP_REQ_CTX_nbio(OCSP_REQ_CTX *rctx);\n+int OCSP_sendreq_nbio(OCSP_RESPONSE **presp, OCSP_REQ_CTX *rctx);\n+OCSP_REQ_CTX *OCSP_REQ_CTX_new(BIO *io, int maxline);\n+void OCSP_REQ_CTX_free(OCSP_REQ_CTX *rctx);\n+void OCSP_set_max_response_length(OCSP_REQ_CTX *rctx, unsigned long len);\n+int OCSP_REQ_CTX_i2d(OCSP_REQ_CTX *rctx, const ASN1_ITEM *it,\n+                     ASN1_VALUE *val);\n+int OCSP_REQ_CTX_nbio_d2i(OCSP_REQ_CTX *rctx, ASN1_VALUE **pval,\n+                          const ASN1_ITEM *it);\n+BIO *OCSP_REQ_CTX_get0_mem_bio(OCSP_REQ_CTX *rctx);\n+int OCSP_REQ_CTX_i2d(OCSP_REQ_CTX *rctx, const ASN1_ITEM *it,\n+                     ASN1_VALUE *val);\n+int OCSP_REQ_CTX_http(OCSP_REQ_CTX *rctx, const char *op, const char *path);\n+int OCSP_REQ_CTX_set1_req(OCSP_REQ_CTX *rctx, OCSP_REQUEST *req);\n+int OCSP_REQ_CTX_add1_header(OCSP_REQ_CTX *rctx,\n+                             const char *name, const char *value);\n+\n+OCSP_CERTID *OCSP_cert_to_id(const EVP_MD *dgst, X509 *subject, X509 *issuer);\n+\n+OCSP_CERTID *OCSP_cert_id_new(const EVP_MD *dgst,\n+                              X509_NAME *issuerName,\n+                              ASN1_BIT_STRING *issuerKey,\n+                              ASN1_INTEGER *serialNumber);\n+\n+OCSP_ONEREQ *OCSP_request_add0_id(OCSP_REQUEST *req, OCSP_CERTID *cid);\n+\n+int OCSP_request_add1_nonce(OCSP_REQUEST *req, unsigned char *val, int len);\n+int OCSP_basic_add1_nonce(OCSP_BASICRESP *resp, unsigned char *val, int len);\n+int OCSP_check_nonce(OCSP_REQUEST *req, OCSP_BASICRESP *bs);\n+int OCSP_copy_nonce(OCSP_BASICRESP *resp, OCSP_REQUEST *req);\n+\n+int OCSP_request_set1_name(OCSP_REQUEST *req, X509_NAME *nm);\n+int OCSP_request_add1_cert(OCSP_REQUEST *req, X509 *cert);\n+\n+int OCSP_request_sign(OCSP_REQUEST *req,\n+                      X509 *signer,\n+                      EVP_PKEY *key,\n+                      const EVP_MD *dgst,\n+                      STACK_OF(X509) *certs, unsigned long flags);\n+\n+int OCSP_response_status(OCSP_RESPONSE *resp);\n+OCSP_BASICRESP *OCSP_response_get1_basic(OCSP_RESPONSE *resp);\n+\n+int OCSP_resp_count(OCSP_BASICRESP *bs);\n+OCSP_SINGLERESP *OCSP_resp_get0(OCSP_BASICRESP *bs, int idx);\n+int OCSP_resp_find(OCSP_BASICRESP *bs, OCSP_CERTID *id, int last);\n+int OCSP_single_get0_status(OCSP_SINGLERESP *single, int *reason,\n+                            ASN1_GENERALIZEDTIME **revtime,\n+                            ASN1_GENERALIZEDTIME **thisupd,\n+                            ASN1_GENERALIZEDTIME **nextupd);\n+int OCSP_resp_find_status(OCSP_BASICRESP *bs, OCSP_CERTID *id, int *status,\n+                          int *reason,\n+                          ASN1_GENERALIZEDTIME **revtime,\n+                          ASN1_GENERALIZEDTIME **thisupd,\n+                          ASN1_GENERALIZEDTIME **nextupd);\n+int OCSP_check_validity(ASN1_GENERALIZEDTIME *thisupd,\n+                        ASN1_GENERALIZEDTIME *nextupd, long sec, long maxsec);\n+\n+int OCSP_request_verify(OCSP_REQUEST *req, STACK_OF(X509) *certs,\n+                        X509_STORE *store, unsigned long flags);\n+\n+int OCSP_parse_url(const char *url, char **phost, char **pport, char **ppath,\n+                   int *pssl);\n+\n+int OCSP_id_issuer_cmp(OCSP_CERTID *a, OCSP_CERTID *b);\n+int OCSP_id_cmp(OCSP_CERTID *a, OCSP_CERTID *b);\n+\n+int OCSP_request_onereq_count(OCSP_REQUEST *req);\n+OCSP_ONEREQ *OCSP_request_onereq_get0(OCSP_REQUEST *req, int i);\n+OCSP_CERTID *OCSP_onereq_get0_id(OCSP_ONEREQ *one);\n+int OCSP_id_get0_info(ASN1_OCTET_STRING **piNameHash, ASN1_OBJECT **pmd,\n+                      ASN1_OCTET_STRING **pikeyHash,\n+                      ASN1_INTEGER **pserial, OCSP_CERTID *cid);\n+int OCSP_request_is_signed(OCSP_REQUEST *req);\n+OCSP_RESPONSE *OCSP_response_create(int status, OCSP_BASICRESP *bs);\n+OCSP_SINGLERESP *OCSP_basic_add1_status(OCSP_BASICRESP *rsp,\n+                                        OCSP_CERTID *cid,\n+                                        int status, int reason,\n+                                        ASN1_TIME *revtime,\n+                                        ASN1_TIME *thisupd,\n+                                        ASN1_TIME *nextupd);\n+int OCSP_basic_add1_cert(OCSP_BASICRESP *resp, X509 *cert);\n+int OCSP_basic_sign(OCSP_BASICRESP *brsp,\n+                    X509 *signer, EVP_PKEY *key, const EVP_MD *dgst,\n+                    STACK_OF(X509) *certs, unsigned long flags);\n+\n+X509_EXTENSION *OCSP_crlID_new(char *url, long *n, char *tim);\n+\n+X509_EXTENSION *OCSP_accept_responses_new(char **oids);\n+\n+X509_EXTENSION *OCSP_archive_cutoff_new(char *tim);\n+\n+X509_EXTENSION *OCSP_url_svcloc_new(X509_NAME *issuer, char **urls);\n+\n+int OCSP_REQUEST_get_ext_count(OCSP_REQUEST *x);\n+int OCSP_REQUEST_get_ext_by_NID(OCSP_REQUEST *x, int nid, int lastpos);\n+int OCSP_REQUEST_get_ext_by_OBJ(OCSP_REQUEST *x, ASN1_OBJECT *obj,\n+                                int lastpos);\n+int OCSP_REQUEST_get_ext_by_critical(OCSP_REQUEST *x, int crit, int lastpos);\n+X509_EXTENSION *OCSP_REQUEST_get_ext(OCSP_REQUEST *x, int loc);\n+X509_EXTENSION *OCSP_REQUEST_delete_ext(OCSP_REQUEST *x, int loc);\n+void *OCSP_REQUEST_get1_ext_d2i(OCSP_REQUEST *x, int nid, int *crit,\n+                                int *idx);\n+int OCSP_REQUEST_add1_ext_i2d(OCSP_REQUEST *x, int nid, void *value, int crit,\n+                              unsigned long flags);\n+int OCSP_REQUEST_add_ext(OCSP_REQUEST *x, X509_EXTENSION *ex, int loc);\n+\n+int OCSP_ONEREQ_get_ext_count(OCSP_ONEREQ *x);\n+int OCSP_ONEREQ_get_ext_by_NID(OCSP_ONEREQ *x, int nid, int lastpos);\n+int OCSP_ONEREQ_get_ext_by_OBJ(OCSP_ONEREQ *x, ASN1_OBJECT *obj, int lastpos);\n+int OCSP_ONEREQ_get_ext_by_critical(OCSP_ONEREQ *x, int crit, int lastpos);\n+X509_EXTENSION *OCSP_ONEREQ_get_ext(OCSP_ONEREQ *x, int loc);\n+X509_EXTENSION *OCSP_ONEREQ_delete_ext(OCSP_ONEREQ *x, int loc);\n+void *OCSP_ONEREQ_get1_ext_d2i(OCSP_ONEREQ *x, int nid, int *crit, int *idx);\n+int OCSP_ONEREQ_add1_ext_i2d(OCSP_ONEREQ *x, int nid, void *value, int crit,\n+                             unsigned long flags);\n+int OCSP_ONEREQ_add_ext(OCSP_ONEREQ *x, X509_EXTENSION *ex, int loc);\n+\n+int OCSP_BASICRESP_get_ext_count(OCSP_BASICRESP *x);\n+int OCSP_BASICRESP_get_ext_by_NID(OCSP_BASICRESP *x, int nid, int lastpos);\n+int OCSP_BASICRESP_get_ext_by_OBJ(OCSP_BASICRESP *x, ASN1_OBJECT *obj,\n+                                  int lastpos);\n+int OCSP_BASICRESP_get_ext_by_critical(OCSP_BASICRESP *x, int crit,\n+                                       int lastpos);\n+X509_EXTENSION *OCSP_BASICRESP_get_ext(OCSP_BASICRESP *x, int loc);\n+X509_EXTENSION *OCSP_BASICRESP_delete_ext(OCSP_BASICRESP *x, int loc);\n+void *OCSP_BASICRESP_get1_ext_d2i(OCSP_BASICRESP *x, int nid, int *crit,\n+                                  int *idx);\n+int OCSP_BASICRESP_add1_ext_i2d(OCSP_BASICRESP *x, int nid, void *value,\n+                                int crit, unsigned long flags);\n+int OCSP_BASICRESP_add_ext(OCSP_BASICRESP *x, X509_EXTENSION *ex, int loc);\n+\n+int OCSP_SINGLERESP_get_ext_count(OCSP_SINGLERESP *x);\n+int OCSP_SINGLERESP_get_ext_by_NID(OCSP_SINGLERESP *x, int nid, int lastpos);\n+int OCSP_SINGLERESP_get_ext_by_OBJ(OCSP_SINGLERESP *x, ASN1_OBJECT *obj,\n+                                   int lastpos);\n+int OCSP_SINGLERESP_get_ext_by_critical(OCSP_SINGLERESP *x, int crit,\n+                                        int lastpos);\n+X509_EXTENSION *OCSP_SINGLERESP_get_ext(OCSP_SINGLERESP *x, int loc);\n+X509_EXTENSION *OCSP_SINGLERESP_delete_ext(OCSP_SINGLERESP *x, int loc);\n+void *OCSP_SINGLERESP_get1_ext_d2i(OCSP_SINGLERESP *x, int nid, int *crit,\n+                                   int *idx);\n+int OCSP_SINGLERESP_add1_ext_i2d(OCSP_SINGLERESP *x, int nid, void *value,\n+                                 int crit, unsigned long flags);\n+int OCSP_SINGLERESP_add_ext(OCSP_SINGLERESP *x, X509_EXTENSION *ex, int loc);\n+\n+DECLARE_ASN1_FUNCTIONS(OCSP_SINGLERESP)\n+DECLARE_ASN1_FUNCTIONS(OCSP_CERTSTATUS)\n+DECLARE_ASN1_FUNCTIONS(OCSP_REVOKEDINFO)\n+DECLARE_ASN1_FUNCTIONS(OCSP_BASICRESP)\n+DECLARE_ASN1_FUNCTIONS(OCSP_RESPDATA)\n+DECLARE_ASN1_FUNCTIONS(OCSP_RESPID)\n+DECLARE_ASN1_FUNCTIONS(OCSP_RESPONSE)\n+DECLARE_ASN1_FUNCTIONS(OCSP_RESPBYTES)\n+DECLARE_ASN1_FUNCTIONS(OCSP_ONEREQ)\n+DECLARE_ASN1_FUNCTIONS(OCSP_CERTID)\n+DECLARE_ASN1_FUNCTIONS(OCSP_REQUEST)\n+DECLARE_ASN1_FUNCTIONS(OCSP_SIGNATURE)\n+DECLARE_ASN1_FUNCTIONS(OCSP_REQINFO)\n+DECLARE_ASN1_FUNCTIONS(OCSP_CRLID)\n+DECLARE_ASN1_FUNCTIONS(OCSP_SERVICELOC)\n+\n+const char *OCSP_response_status_str(long s);\n+const char *OCSP_cert_status_str(long s);\n+const char *OCSP_crl_reason_str(long s);\n+\n+int OCSP_REQUEST_print(BIO *bp, OCSP_REQUEST *a, unsigned long flags);\n+int OCSP_RESPONSE_print(BIO *bp, OCSP_RESPONSE *o, unsigned long flags);\n+\n+int OCSP_basic_verify(OCSP_BASICRESP *bs, STACK_OF(X509) *certs,\n+                      X509_STORE *st, unsigned long flags);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_OCSP_strings(void);\n+\n+/* Error codes for the OCSP functions. */\n+\n+/* Function codes. */\n+# define OCSP_F_ASN1_STRING_ENCODE                        100\n+# define OCSP_F_D2I_OCSP_NONCE                            102\n+# define OCSP_F_OCSP_BASIC_ADD1_STATUS                    103\n+# define OCSP_F_OCSP_BASIC_SIGN                           104\n+# define OCSP_F_OCSP_BASIC_VERIFY                         105\n+# define OCSP_F_OCSP_CERT_ID_NEW                          101\n+# define OCSP_F_OCSP_CHECK_DELEGATED                      106\n+# define OCSP_F_OCSP_CHECK_IDS                            107\n+# define OCSP_F_OCSP_CHECK_ISSUER                         108\n+# define OCSP_F_OCSP_CHECK_VALIDITY                       115\n+# define OCSP_F_OCSP_MATCH_ISSUERID                       109\n+# define OCSP_F_OCSP_PARSE_URL                            114\n+# define OCSP_F_OCSP_REQUEST_SIGN                         110\n+# define OCSP_F_OCSP_REQUEST_VERIFY                       116\n+# define OCSP_F_OCSP_RESPONSE_GET1_BASIC                  111\n+# define OCSP_F_OCSP_SENDREQ_BIO                          112\n+# define OCSP_F_OCSP_SENDREQ_NBIO                         117\n+# define OCSP_F_PARSE_HTTP_LINE1                          118\n+# define OCSP_F_REQUEST_VERIFY                            113\n+\n+/* Reason codes. */\n+# define OCSP_R_BAD_DATA                                  100\n+# define OCSP_R_CERTIFICATE_VERIFY_ERROR                  101\n+# define OCSP_R_DIGEST_ERR                                102\n+# define OCSP_R_ERROR_IN_NEXTUPDATE_FIELD                 122\n+# define OCSP_R_ERROR_IN_THISUPDATE_FIELD                 123\n+# define OCSP_R_ERROR_PARSING_URL                         121\n+# define OCSP_R_MISSING_OCSPSIGNING_USAGE                 103\n+# define OCSP_R_NEXTUPDATE_BEFORE_THISUPDATE              124\n+# define OCSP_R_NOT_BASIC_RESPONSE                        104\n+# define OCSP_R_NO_CERTIFICATES_IN_CHAIN                  105\n+# define OCSP_R_NO_CONTENT                                106\n+# define OCSP_R_NO_PUBLIC_KEY                             107\n+# define OCSP_R_NO_RESPONSE_DATA                          108\n+# define OCSP_R_NO_REVOKED_TIME                           109\n+# define OCSP_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE    110\n+# define OCSP_R_REQUEST_NOT_SIGNED                        128\n+# define OCSP_R_RESPONSE_CONTAINS_NO_REVOCATION_DATA      111\n+# define OCSP_R_ROOT_CA_NOT_TRUSTED                       112\n+# define OCSP_R_SERVER_READ_ERROR                         113\n+# define OCSP_R_SERVER_RESPONSE_ERROR                     114\n+# define OCSP_R_SERVER_RESPONSE_PARSE_ERROR               115\n+# define OCSP_R_SERVER_WRITE_ERROR                        116\n+# define OCSP_R_SIGNATURE_FAILURE                         117\n+# define OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND              118\n+# define OCSP_R_STATUS_EXPIRED                            125\n+# define OCSP_R_STATUS_NOT_YET_VALID                      126\n+# define OCSP_R_STATUS_TOO_OLD                            127\n+# define OCSP_R_UNKNOWN_MESSAGE_DIGEST                    119\n+# define OCSP_R_UNKNOWN_NID                               120\n+# define OCSP_R_UNSUPPORTED_REQUESTORNAME_TYPE            129\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "221be629b722480f9c647bb88d56c4bfb2e3c374",
            "filename": "deps/openssl/openssl/include/openssl/opensslconf.h",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fopensslconf.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fopensslconf.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fopensslconf.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1 @@\n+#include \"../../crypto/opensslconf.h\""
        },
        {
            "sha": "77f124e2cb3c4b6d1627a4d8ba16f91da331b0f3",
            "filename": "deps/openssl/openssl/include/openssl/opensslv.h",
            "status": "added",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fopensslv.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fopensslv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fopensslv.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,97 @@\n+#ifndef HEADER_OPENSSLV_H\n+# define HEADER_OPENSSLV_H\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*-\n+ * Numeric release version identifier:\n+ * MNNFFPPS: major minor fix patch status\n+ * The status nibble has one of the values 0 for development, 1 to e for betas\n+ * 1 to 14, and f for release.  The patch level is exactly that.\n+ * For example:\n+ * 0.9.3-dev      0x00903000\n+ * 0.9.3-beta1    0x00903001\n+ * 0.9.3-beta2-dev 0x00903002\n+ * 0.9.3-beta2    0x00903002 (same as ...beta2-dev)\n+ * 0.9.3          0x0090300f\n+ * 0.9.3a         0x0090301f\n+ * 0.9.4          0x0090400f\n+ * 1.2.3z         0x102031af\n+ *\n+ * For continuity reasons (because 0.9.5 is already out, and is coded\n+ * 0x00905100), between 0.9.5 and 0.9.6 the coding of the patch level\n+ * part is slightly different, by setting the highest bit.  This means\n+ * that 0.9.5a looks like this: 0x0090581f.  At 0.9.6, we can start\n+ * with 0x0090600S...\n+ *\n+ * (Prior to 0.9.3-dev a different scheme was used: 0.9.2b is 0x0922.)\n+ * (Prior to 0.9.5a beta1, a different scheme was used: MMNNFFRBB for\n+ *  major minor fix final patch/beta)\n+ */\n+# define OPENSSL_VERSION_NUMBER  0x100020ffL\n+# ifdef OPENSSL_FIPS\n+#  define OPENSSL_VERSION_TEXT    \"OpenSSL 1.0.2o-fips  27 Mar 2018\"\n+# else\n+#  define OPENSSL_VERSION_TEXT    \"OpenSSL 1.0.2o  27 Mar 2018\"\n+# endif\n+# define OPENSSL_VERSION_PTEXT   \" part of \" OPENSSL_VERSION_TEXT\n+\n+/*-\n+ * The macros below are to be used for shared library (.so, .dll, ...)\n+ * versioning.  That kind of versioning works a bit differently between\n+ * operating systems.  The most usual scheme is to set a major and a minor\n+ * number, and have the runtime loader check that the major number is equal\n+ * to what it was at application link time, while the minor number has to\n+ * be greater or equal to what it was at application link time.  With this\n+ * scheme, the version number is usually part of the file name, like this:\n+ *\n+ *      libcrypto.so.0.9\n+ *\n+ * Some unixen also make a softlink with the major verson number only:\n+ *\n+ *      libcrypto.so.0\n+ *\n+ * On Tru64 and IRIX 6.x it works a little bit differently.  There, the\n+ * shared library version is stored in the file, and is actually a series\n+ * of versions, separated by colons.  The rightmost version present in the\n+ * library when linking an application is stored in the application to be\n+ * matched at run time.  When the application is run, a check is done to\n+ * see if the library version stored in the application matches any of the\n+ * versions in the version string of the library itself.\n+ * This version string can be constructed in any way, depending on what\n+ * kind of matching is desired.  However, to implement the same scheme as\n+ * the one used in the other unixen, all compatible versions, from lowest\n+ * to highest, should be part of the string.  Consecutive builds would\n+ * give the following versions strings:\n+ *\n+ *      3.0\n+ *      3.0:3.1\n+ *      3.0:3.1:3.2\n+ *      4.0\n+ *      4.0:4.1\n+ *\n+ * Notice how version 4 is completely incompatible with version, and\n+ * therefore give the breach you can see.\n+ *\n+ * There may be other schemes as well that I haven't yet discovered.\n+ *\n+ * So, here's the way it works here: first of all, the library version\n+ * number doesn't need at all to match the overall OpenSSL version.\n+ * However, it's nice and more understandable if it actually does.\n+ * The current library version is stored in the macro SHLIB_VERSION_NUMBER,\n+ * which is just a piece of text in the format \"M.m.e\" (Major, minor, edit).\n+ * For the sake of Tru64, IRIX, and any other OS that behaves in similar ways,\n+ * we need to keep a history of version numbers, which is done in the\n+ * macro SHLIB_VERSION_HISTORY.  The numbers are separated by colons and\n+ * should only keep the versions that are binary compatible with the current.\n+ */\n+# define SHLIB_VERSION_HISTORY \"\"\n+# define SHLIB_VERSION_NUMBER \"1.0.0\"\n+\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif                          /* HEADER_OPENSSLV_H */"
        },
        {
            "sha": "364d26238e8c4def0a98cf82d0ccdb7c2e59d7ed",
            "filename": "deps/openssl/openssl/include/openssl/ossl_typ.h",
            "status": "added",
            "additions": 213,
            "deletions": 0,
            "changes": 213,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fossl_typ.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fossl_typ.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fossl_typ.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,213 @@\n+/* ====================================================================\n+ * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@openssl.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#ifndef HEADER_OPENSSL_TYPES_H\n+# define HEADER_OPENSSL_TYPES_H\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# include <openssl/e_os2.h>\n+\n+# ifdef NO_ASN1_TYPEDEFS\n+#  define ASN1_INTEGER            ASN1_STRING\n+#  define ASN1_ENUMERATED         ASN1_STRING\n+#  define ASN1_BIT_STRING         ASN1_STRING\n+#  define ASN1_OCTET_STRING       ASN1_STRING\n+#  define ASN1_PRINTABLESTRING    ASN1_STRING\n+#  define ASN1_T61STRING          ASN1_STRING\n+#  define ASN1_IA5STRING          ASN1_STRING\n+#  define ASN1_UTCTIME            ASN1_STRING\n+#  define ASN1_GENERALIZEDTIME    ASN1_STRING\n+#  define ASN1_TIME               ASN1_STRING\n+#  define ASN1_GENERALSTRING      ASN1_STRING\n+#  define ASN1_UNIVERSALSTRING    ASN1_STRING\n+#  define ASN1_BMPSTRING          ASN1_STRING\n+#  define ASN1_VISIBLESTRING      ASN1_STRING\n+#  define ASN1_UTF8STRING         ASN1_STRING\n+#  define ASN1_BOOLEAN            int\n+#  define ASN1_NULL               int\n+# else\n+typedef struct asn1_string_st ASN1_INTEGER;\n+typedef struct asn1_string_st ASN1_ENUMERATED;\n+typedef struct asn1_string_st ASN1_BIT_STRING;\n+typedef struct asn1_string_st ASN1_OCTET_STRING;\n+typedef struct asn1_string_st ASN1_PRINTABLESTRING;\n+typedef struct asn1_string_st ASN1_T61STRING;\n+typedef struct asn1_string_st ASN1_IA5STRING;\n+typedef struct asn1_string_st ASN1_GENERALSTRING;\n+typedef struct asn1_string_st ASN1_UNIVERSALSTRING;\n+typedef struct asn1_string_st ASN1_BMPSTRING;\n+typedef struct asn1_string_st ASN1_UTCTIME;\n+typedef struct asn1_string_st ASN1_TIME;\n+typedef struct asn1_string_st ASN1_GENERALIZEDTIME;\n+typedef struct asn1_string_st ASN1_VISIBLESTRING;\n+typedef struct asn1_string_st ASN1_UTF8STRING;\n+typedef struct asn1_string_st ASN1_STRING;\n+typedef int ASN1_BOOLEAN;\n+typedef int ASN1_NULL;\n+# endif\n+\n+typedef struct asn1_object_st ASN1_OBJECT;\n+\n+typedef struct ASN1_ITEM_st ASN1_ITEM;\n+typedef struct asn1_pctx_st ASN1_PCTX;\n+\n+# ifdef OPENSSL_SYS_WIN32\n+#  undef X509_NAME\n+#  undef X509_EXTENSIONS\n+#  undef X509_CERT_PAIR\n+#  undef PKCS7_ISSUER_AND_SERIAL\n+#  undef OCSP_REQUEST\n+#  undef OCSP_RESPONSE\n+# endif\n+\n+# ifdef BIGNUM\n+#  undef BIGNUM\n+# endif\n+typedef struct bignum_st BIGNUM;\n+typedef struct bignum_ctx BN_CTX;\n+typedef struct bn_blinding_st BN_BLINDING;\n+typedef struct bn_mont_ctx_st BN_MONT_CTX;\n+typedef struct bn_recp_ctx_st BN_RECP_CTX;\n+typedef struct bn_gencb_st BN_GENCB;\n+\n+typedef struct buf_mem_st BUF_MEM;\n+\n+typedef struct evp_cipher_st EVP_CIPHER;\n+typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;\n+typedef struct env_md_st EVP_MD;\n+typedef struct env_md_ctx_st EVP_MD_CTX;\n+typedef struct evp_pkey_st EVP_PKEY;\n+\n+typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;\n+\n+typedef struct evp_pkey_method_st EVP_PKEY_METHOD;\n+typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;\n+\n+typedef struct dh_st DH;\n+typedef struct dh_method DH_METHOD;\n+\n+typedef struct dsa_st DSA;\n+typedef struct dsa_method DSA_METHOD;\n+\n+typedef struct rsa_st RSA;\n+typedef struct rsa_meth_st RSA_METHOD;\n+\n+typedef struct rand_meth_st RAND_METHOD;\n+\n+typedef struct ecdh_method ECDH_METHOD;\n+typedef struct ecdsa_method ECDSA_METHOD;\n+\n+typedef struct x509_st X509;\n+typedef struct X509_algor_st X509_ALGOR;\n+typedef struct X509_crl_st X509_CRL;\n+typedef struct x509_crl_method_st X509_CRL_METHOD;\n+typedef struct x509_revoked_st X509_REVOKED;\n+typedef struct X509_name_st X509_NAME;\n+typedef struct X509_pubkey_st X509_PUBKEY;\n+typedef struct x509_store_st X509_STORE;\n+typedef struct x509_store_ctx_st X509_STORE_CTX;\n+\n+typedef struct pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;\n+\n+typedef struct v3_ext_ctx X509V3_CTX;\n+typedef struct conf_st CONF;\n+\n+typedef struct store_st STORE;\n+typedef struct store_method_st STORE_METHOD;\n+\n+typedef struct ui_st UI;\n+typedef struct ui_method_st UI_METHOD;\n+\n+typedef struct st_ERR_FNS ERR_FNS;\n+\n+typedef struct engine_st ENGINE;\n+typedef struct ssl_st SSL;\n+typedef struct ssl_ctx_st SSL_CTX;\n+\n+typedef struct comp_method_st COMP_METHOD;\n+\n+typedef struct X509_POLICY_NODE_st X509_POLICY_NODE;\n+typedef struct X509_POLICY_LEVEL_st X509_POLICY_LEVEL;\n+typedef struct X509_POLICY_TREE_st X509_POLICY_TREE;\n+typedef struct X509_POLICY_CACHE_st X509_POLICY_CACHE;\n+\n+typedef struct AUTHORITY_KEYID_st AUTHORITY_KEYID;\n+typedef struct DIST_POINT_st DIST_POINT;\n+typedef struct ISSUING_DIST_POINT_st ISSUING_DIST_POINT;\n+typedef struct NAME_CONSTRAINTS_st NAME_CONSTRAINTS;\n+\n+  /* If placed in pkcs12.h, we end up with a circular depency with pkcs7.h */\n+# define DECLARE_PKCS12_STACK_OF(type)/* Nothing */\n+# define IMPLEMENT_PKCS12_STACK_OF(type)/* Nothing */\n+\n+typedef struct crypto_ex_data_st CRYPTO_EX_DATA;\n+/* Callback types for crypto.h */\n+typedef int CRYPTO_EX_new (void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n+                           int idx, long argl, void *argp);\n+typedef void CRYPTO_EX_free (void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n+                             int idx, long argl, void *argp);\n+typedef int CRYPTO_EX_dup (CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from,\n+                           void *from_d, int idx, long argl, void *argp);\n+\n+typedef struct ocsp_req_ctx_st OCSP_REQ_CTX;\n+typedef struct ocsp_response_st OCSP_RESPONSE;\n+typedef struct ocsp_responder_id_st OCSP_RESPID;\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif                          /* def HEADER_OPENSSL_TYPES_H */"
        },
        {
            "sha": "aac72fb21eda3974fd40c4d5a583e72c2e02d7dd",
            "filename": "deps/openssl/openssl/include/openssl/pem.h",
            "status": "added",
            "additions": 617,
            "deletions": 0,
            "changes": 617,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpem.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpem.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpem.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,617 @@\n+/* crypto/pem/pem.h */\n+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_PEM_H\n+# define HEADER_PEM_H\n+\n+# include <openssl/e_os2.h>\n+# ifndef OPENSSL_NO_BIO\n+#  include <openssl/bio.h>\n+# endif\n+# ifndef OPENSSL_NO_STACK\n+#  include <openssl/stack.h>\n+# endif\n+# include <openssl/evp.h>\n+# include <openssl/x509.h>\n+# include <openssl/pem2.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# define PEM_BUFSIZE             1024\n+\n+# define PEM_OBJ_UNDEF           0\n+# define PEM_OBJ_X509            1\n+# define PEM_OBJ_X509_REQ        2\n+# define PEM_OBJ_CRL             3\n+# define PEM_OBJ_SSL_SESSION     4\n+# define PEM_OBJ_PRIV_KEY        10\n+# define PEM_OBJ_PRIV_RSA        11\n+# define PEM_OBJ_PRIV_DSA        12\n+# define PEM_OBJ_PRIV_DH         13\n+# define PEM_OBJ_PUB_RSA         14\n+# define PEM_OBJ_PUB_DSA         15\n+# define PEM_OBJ_PUB_DH          16\n+# define PEM_OBJ_DHPARAMS        17\n+# define PEM_OBJ_DSAPARAMS       18\n+# define PEM_OBJ_PRIV_RSA_PUBLIC 19\n+# define PEM_OBJ_PRIV_ECDSA      20\n+# define PEM_OBJ_PUB_ECDSA       21\n+# define PEM_OBJ_ECPARAMETERS    22\n+\n+# define PEM_ERROR               30\n+# define PEM_DEK_DES_CBC         40\n+# define PEM_DEK_IDEA_CBC        45\n+# define PEM_DEK_DES_EDE         50\n+# define PEM_DEK_DES_ECB         60\n+# define PEM_DEK_RSA             70\n+# define PEM_DEK_RSA_MD2         80\n+# define PEM_DEK_RSA_MD5         90\n+\n+# define PEM_MD_MD2              NID_md2\n+# define PEM_MD_MD5              NID_md5\n+# define PEM_MD_SHA              NID_sha\n+# define PEM_MD_MD2_RSA          NID_md2WithRSAEncryption\n+# define PEM_MD_MD5_RSA          NID_md5WithRSAEncryption\n+# define PEM_MD_SHA_RSA          NID_sha1WithRSAEncryption\n+\n+# define PEM_STRING_X509_OLD     \"X509 CERTIFICATE\"\n+# define PEM_STRING_X509         \"CERTIFICATE\"\n+# define PEM_STRING_X509_PAIR    \"CERTIFICATE PAIR\"\n+# define PEM_STRING_X509_TRUSTED \"TRUSTED CERTIFICATE\"\n+# define PEM_STRING_X509_REQ_OLD \"NEW CERTIFICATE REQUEST\"\n+# define PEM_STRING_X509_REQ     \"CERTIFICATE REQUEST\"\n+# define PEM_STRING_X509_CRL     \"X509 CRL\"\n+# define PEM_STRING_EVP_PKEY     \"ANY PRIVATE KEY\"\n+# define PEM_STRING_PUBLIC       \"PUBLIC KEY\"\n+# define PEM_STRING_RSA          \"RSA PRIVATE KEY\"\n+# define PEM_STRING_RSA_PUBLIC   \"RSA PUBLIC KEY\"\n+# define PEM_STRING_DSA          \"DSA PRIVATE KEY\"\n+# define PEM_STRING_DSA_PUBLIC   \"DSA PUBLIC KEY\"\n+# define PEM_STRING_PKCS7        \"PKCS7\"\n+# define PEM_STRING_PKCS7_SIGNED \"PKCS #7 SIGNED DATA\"\n+# define PEM_STRING_PKCS8        \"ENCRYPTED PRIVATE KEY\"\n+# define PEM_STRING_PKCS8INF     \"PRIVATE KEY\"\n+# define PEM_STRING_DHPARAMS     \"DH PARAMETERS\"\n+# define PEM_STRING_DHXPARAMS    \"X9.42 DH PARAMETERS\"\n+# define PEM_STRING_SSL_SESSION  \"SSL SESSION PARAMETERS\"\n+# define PEM_STRING_DSAPARAMS    \"DSA PARAMETERS\"\n+# define PEM_STRING_ECDSA_PUBLIC \"ECDSA PUBLIC KEY\"\n+# define PEM_STRING_ECPARAMETERS \"EC PARAMETERS\"\n+# define PEM_STRING_ECPRIVATEKEY \"EC PRIVATE KEY\"\n+# define PEM_STRING_PARAMETERS   \"PARAMETERS\"\n+# define PEM_STRING_CMS          \"CMS\"\n+\n+  /*\n+   * Note that this structure is initialised by PEM_SealInit and cleaned up\n+   * by PEM_SealFinal (at least for now)\n+   */\n+typedef struct PEM_Encode_Seal_st {\n+    EVP_ENCODE_CTX encode;\n+    EVP_MD_CTX md;\n+    EVP_CIPHER_CTX cipher;\n+} PEM_ENCODE_SEAL_CTX;\n+\n+/* enc_type is one off */\n+# define PEM_TYPE_ENCRYPTED      10\n+# define PEM_TYPE_MIC_ONLY       20\n+# define PEM_TYPE_MIC_CLEAR      30\n+# define PEM_TYPE_CLEAR          40\n+\n+typedef struct pem_recip_st {\n+    char *name;\n+    X509_NAME *dn;\n+    int cipher;\n+    int key_enc;\n+    /*      char iv[8]; unused and wrong size */\n+} PEM_USER;\n+\n+typedef struct pem_ctx_st {\n+    int type;                   /* what type of object */\n+    struct {\n+        int version;\n+        int mode;\n+    } proc_type;\n+\n+    char *domain;\n+\n+    struct {\n+        int cipher;\n+        /*-\n+        unused, and wrong size\n+        unsigned char iv[8]; */\n+    } DEK_info;\n+\n+    PEM_USER *originator;\n+\n+    int num_recipient;\n+    PEM_USER **recipient;\n+/*-\n+    XXX(ben): don#t think this is used!\n+        STACK *x509_chain;      / * certificate chain */\n+    EVP_MD *md;                 /* signature type */\n+\n+    int md_enc;                 /* is the md encrypted or not? */\n+    int md_len;                 /* length of md_data */\n+    char *md_data;              /* message digest, could be pkey encrypted */\n+\n+    EVP_CIPHER *dec;            /* date encryption cipher */\n+    int key_len;                /* key length */\n+    unsigned char *key;         /* key */\n+  /*-\n+    unused, and wrong size\n+    unsigned char iv[8]; */\n+\n+    int data_enc;               /* is the data encrypted */\n+    int data_len;\n+    unsigned char *data;\n+} PEM_CTX;\n+\n+/*\n+ * These macros make the PEM_read/PEM_write functions easier to maintain and\n+ * write. Now they are all implemented with either: IMPLEMENT_PEM_rw(...) or\n+ * IMPLEMENT_PEM_rw_cb(...)\n+ */\n+\n+# ifdef OPENSSL_NO_FP_API\n+\n+#  define IMPLEMENT_PEM_read_fp(name, type, str, asn1) /**/\n+#  define IMPLEMENT_PEM_write_fp(name, type, str, asn1) /**/\n+#  define IMPLEMENT_PEM_write_fp_const(name, type, str, asn1) /**/\n+#  define IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1) /**/\n+#  define IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1) /**/\n+# else\n+\n+#  define IMPLEMENT_PEM_read_fp(name, type, str, asn1) \\\n+type *PEM_read_##name(FILE *fp, type **x, pem_password_cb *cb, void *u)\\\n+{ \\\n+return PEM_ASN1_read((d2i_of_void *)d2i_##asn1, str,fp,(void **)x,cb,u); \\\n+}\n+\n+#  define IMPLEMENT_PEM_write_fp(name, type, str, asn1) \\\n+int PEM_write_##name(FILE *fp, type *x) \\\n+{ \\\n+return PEM_ASN1_write((i2d_of_void *)i2d_##asn1,str,fp,x,NULL,NULL,0,NULL,NULL); \\\n+}\n+\n+#  define IMPLEMENT_PEM_write_fp_const(name, type, str, asn1) \\\n+int PEM_write_##name(FILE *fp, const type *x) \\\n+{ \\\n+return PEM_ASN1_write((i2d_of_void *)i2d_##asn1,str,fp,(void *)x,NULL,NULL,0,NULL,NULL); \\\n+}\n+\n+#  define IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1) \\\n+int PEM_write_##name(FILE *fp, type *x, const EVP_CIPHER *enc, \\\n+             unsigned char *kstr, int klen, pem_password_cb *cb, \\\n+                  void *u) \\\n+        { \\\n+        return PEM_ASN1_write((i2d_of_void *)i2d_##asn1,str,fp,x,enc,kstr,klen,cb,u); \\\n+        }\n+\n+#  define IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1) \\\n+int PEM_write_##name(FILE *fp, type *x, const EVP_CIPHER *enc, \\\n+             unsigned char *kstr, int klen, pem_password_cb *cb, \\\n+                  void *u) \\\n+        { \\\n+        return PEM_ASN1_write((i2d_of_void *)i2d_##asn1,str,fp,x,enc,kstr,klen,cb,u); \\\n+        }\n+\n+# endif\n+\n+# define IMPLEMENT_PEM_read_bio(name, type, str, asn1) \\\n+type *PEM_read_bio_##name(BIO *bp, type **x, pem_password_cb *cb, void *u)\\\n+{ \\\n+return PEM_ASN1_read_bio((d2i_of_void *)d2i_##asn1, str,bp,(void **)x,cb,u); \\\n+}\n+\n+# define IMPLEMENT_PEM_write_bio(name, type, str, asn1) \\\n+int PEM_write_bio_##name(BIO *bp, type *x) \\\n+{ \\\n+return PEM_ASN1_write_bio((i2d_of_void *)i2d_##asn1,str,bp,x,NULL,NULL,0,NULL,NULL); \\\n+}\n+\n+# define IMPLEMENT_PEM_write_bio_const(name, type, str, asn1) \\\n+int PEM_write_bio_##name(BIO *bp, const type *x) \\\n+{ \\\n+return PEM_ASN1_write_bio((i2d_of_void *)i2d_##asn1,str,bp,(void *)x,NULL,NULL,0,NULL,NULL); \\\n+}\n+\n+# define IMPLEMENT_PEM_write_cb_bio(name, type, str, asn1) \\\n+int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \\\n+             unsigned char *kstr, int klen, pem_password_cb *cb, void *u) \\\n+        { \\\n+        return PEM_ASN1_write_bio((i2d_of_void *)i2d_##asn1,str,bp,x,enc,kstr,klen,cb,u); \\\n+        }\n+\n+# define IMPLEMENT_PEM_write_cb_bio_const(name, type, str, asn1) \\\n+int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \\\n+             unsigned char *kstr, int klen, pem_password_cb *cb, void *u) \\\n+        { \\\n+        return PEM_ASN1_write_bio((i2d_of_void *)i2d_##asn1,str,bp,(void *)x,enc,kstr,klen,cb,u); \\\n+        }\n+\n+# define IMPLEMENT_PEM_write(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_bio(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_fp(name, type, str, asn1)\n+\n+# define IMPLEMENT_PEM_write_const(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_bio_const(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_fp_const(name, type, str, asn1)\n+\n+# define IMPLEMENT_PEM_write_cb(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_cb_bio(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1)\n+\n+# define IMPLEMENT_PEM_write_cb_const(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_cb_bio_const(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1)\n+\n+# define IMPLEMENT_PEM_read(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_read_bio(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_read_fp(name, type, str, asn1)\n+\n+# define IMPLEMENT_PEM_rw(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_read(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write(name, type, str, asn1)\n+\n+# define IMPLEMENT_PEM_rw_const(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_read(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_const(name, type, str, asn1)\n+\n+# define IMPLEMENT_PEM_rw_cb(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_read(name, type, str, asn1) \\\n+        IMPLEMENT_PEM_write_cb(name, type, str, asn1)\n+\n+/* These are the same except they are for the declarations */\n+\n+# if defined(OPENSSL_NO_FP_API)\n+\n+#  define DECLARE_PEM_read_fp(name, type) /**/\n+#  define DECLARE_PEM_write_fp(name, type) /**/\n+#  define DECLARE_PEM_write_cb_fp(name, type) /**/\n+# else\n+\n+#  define DECLARE_PEM_read_fp(name, type) \\\n+        type *PEM_read_##name(FILE *fp, type **x, pem_password_cb *cb, void *u);\n+\n+#  define DECLARE_PEM_write_fp(name, type) \\\n+        int PEM_write_##name(FILE *fp, type *x);\n+\n+#  define DECLARE_PEM_write_fp_const(name, type) \\\n+        int PEM_write_##name(FILE *fp, const type *x);\n+\n+#  define DECLARE_PEM_write_cb_fp(name, type) \\\n+        int PEM_write_##name(FILE *fp, type *x, const EVP_CIPHER *enc, \\\n+             unsigned char *kstr, int klen, pem_password_cb *cb, void *u);\n+\n+# endif\n+\n+# ifndef OPENSSL_NO_BIO\n+#  define DECLARE_PEM_read_bio(name, type) \\\n+        type *PEM_read_bio_##name(BIO *bp, type **x, pem_password_cb *cb, void *u);\n+\n+#  define DECLARE_PEM_write_bio(name, type) \\\n+        int PEM_write_bio_##name(BIO *bp, type *x);\n+\n+#  define DECLARE_PEM_write_bio_const(name, type) \\\n+        int PEM_write_bio_##name(BIO *bp, const type *x);\n+\n+#  define DECLARE_PEM_write_cb_bio(name, type) \\\n+        int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \\\n+             unsigned char *kstr, int klen, pem_password_cb *cb, void *u);\n+\n+# else\n+\n+#  define DECLARE_PEM_read_bio(name, type) /**/\n+#  define DECLARE_PEM_write_bio(name, type) /**/\n+#  define DECLARE_PEM_write_bio_const(name, type) /**/\n+#  define DECLARE_PEM_write_cb_bio(name, type) /**/\n+# endif\n+# define DECLARE_PEM_write(name, type) \\\n+        DECLARE_PEM_write_bio(name, type) \\\n+        DECLARE_PEM_write_fp(name, type)\n+# define DECLARE_PEM_write_const(name, type) \\\n+        DECLARE_PEM_write_bio_const(name, type) \\\n+        DECLARE_PEM_write_fp_const(name, type)\n+# define DECLARE_PEM_write_cb(name, type) \\\n+        DECLARE_PEM_write_cb_bio(name, type) \\\n+        DECLARE_PEM_write_cb_fp(name, type)\n+# define DECLARE_PEM_read(name, type) \\\n+        DECLARE_PEM_read_bio(name, type) \\\n+        DECLARE_PEM_read_fp(name, type)\n+# define DECLARE_PEM_rw(name, type) \\\n+        DECLARE_PEM_read(name, type) \\\n+        DECLARE_PEM_write(name, type)\n+# define DECLARE_PEM_rw_const(name, type) \\\n+        DECLARE_PEM_read(name, type) \\\n+        DECLARE_PEM_write_const(name, type)\n+# define DECLARE_PEM_rw_cb(name, type) \\\n+        DECLARE_PEM_read(name, type) \\\n+        DECLARE_PEM_write_cb(name, type)\n+# if 1\n+/* \"userdata\": new with OpenSSL 0.9.4 */\n+typedef int pem_password_cb (char *buf, int size, int rwflag, void *userdata);\n+# else\n+/* OpenSSL 0.9.3, 0.9.3a */\n+typedef int pem_password_cb (char *buf, int size, int rwflag);\n+# endif\n+\n+int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher);\n+int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *len,\n+                  pem_password_cb *callback, void *u);\n+\n+# ifndef OPENSSL_NO_BIO\n+int PEM_read_bio(BIO *bp, char **name, char **header,\n+                 unsigned char **data, long *len);\n+int PEM_write_bio(BIO *bp, const char *name, const char *hdr,\n+                  const unsigned char *data, long len);\n+int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,\n+                       const char *name, BIO *bp, pem_password_cb *cb,\n+                       void *u);\n+void *PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,\n+                        pem_password_cb *cb, void *u);\n+int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, void *x,\n+                       const EVP_CIPHER *enc, unsigned char *kstr, int klen,\n+                       pem_password_cb *cb, void *u);\n+\n+STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk,\n+                                            pem_password_cb *cb, void *u);\n+int PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,\n+                            unsigned char *kstr, int klen,\n+                            pem_password_cb *cd, void *u);\n+# endif\n+\n+int PEM_read(FILE *fp, char **name, char **header,\n+             unsigned char **data, long *len);\n+int PEM_write(FILE *fp, const char *name, const char *hdr,\n+              const unsigned char *data, long len);\n+void *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,\n+                    pem_password_cb *cb, void *u);\n+int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,\n+                   void *x, const EVP_CIPHER *enc, unsigned char *kstr,\n+                   int klen, pem_password_cb *callback, void *u);\n+STACK_OF(X509_INFO) *PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk,\n+                                        pem_password_cb *cb, void *u);\n+\n+int PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type,\n+                 EVP_MD *md_type, unsigned char **ek, int *ekl,\n+                 unsigned char *iv, EVP_PKEY **pubk, int npubk);\n+void PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,\n+                    unsigned char *in, int inl);\n+int PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig, int *sigl,\n+                  unsigned char *out, int *outl, EVP_PKEY *priv);\n+\n+void PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type);\n+void PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *d, unsigned int cnt);\n+int PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,\n+                  unsigned int *siglen, EVP_PKEY *pkey);\n+\n+int PEM_def_callback(char *buf, int num, int w, void *key);\n+void PEM_proc_type(char *buf, int type);\n+void PEM_dek_info(char *buf, const char *type, int len, char *str);\n+\n+# include <openssl/symhacks.h>\n+\n+DECLARE_PEM_rw(X509, X509)\n+DECLARE_PEM_rw(X509_AUX, X509)\n+DECLARE_PEM_rw(X509_CERT_PAIR, X509_CERT_PAIR)\n+DECLARE_PEM_rw(X509_REQ, X509_REQ)\n+DECLARE_PEM_write(X509_REQ_NEW, X509_REQ)\n+DECLARE_PEM_rw(X509_CRL, X509_CRL)\n+DECLARE_PEM_rw(PKCS7, PKCS7)\n+DECLARE_PEM_rw(NETSCAPE_CERT_SEQUENCE, NETSCAPE_CERT_SEQUENCE)\n+DECLARE_PEM_rw(PKCS8, X509_SIG)\n+DECLARE_PEM_rw(PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO)\n+# ifndef OPENSSL_NO_RSA\n+DECLARE_PEM_rw_cb(RSAPrivateKey, RSA)\n+DECLARE_PEM_rw_const(RSAPublicKey, RSA)\n+DECLARE_PEM_rw(RSA_PUBKEY, RSA)\n+# endif\n+# ifndef OPENSSL_NO_DSA\n+DECLARE_PEM_rw_cb(DSAPrivateKey, DSA)\n+DECLARE_PEM_rw(DSA_PUBKEY, DSA)\n+DECLARE_PEM_rw_const(DSAparams, DSA)\n+# endif\n+# ifndef OPENSSL_NO_EC\n+DECLARE_PEM_rw_const(ECPKParameters, EC_GROUP)\n+DECLARE_PEM_rw_cb(ECPrivateKey, EC_KEY)\n+DECLARE_PEM_rw(EC_PUBKEY, EC_KEY)\n+# endif\n+# ifndef OPENSSL_NO_DH\n+DECLARE_PEM_rw_const(DHparams, DH)\n+DECLARE_PEM_write_const(DHxparams, DH)\n+# endif\n+DECLARE_PEM_rw_cb(PrivateKey, EVP_PKEY)\n+DECLARE_PEM_rw(PUBKEY, EVP_PKEY)\n+\n+int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,\n+                                      char *kstr, int klen,\n+                                      pem_password_cb *cb, void *u);\n+int PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,\n+                                  char *, int, pem_password_cb *, void *);\n+int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\n+                            char *kstr, int klen,\n+                            pem_password_cb *cb, void *u);\n+int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,\n+                                char *kstr, int klen,\n+                                pem_password_cb *cb, void *u);\n+EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,\n+                                  void *u);\n+\n+int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n+                           char *kstr, int klen,\n+                           pem_password_cb *cb, void *u);\n+int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,\n+                               char *kstr, int klen,\n+                               pem_password_cb *cb, void *u);\n+int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,\n+                                  char *kstr, int klen,\n+                                  pem_password_cb *cb, void *u);\n+\n+EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,\n+                                 void *u);\n+\n+int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\n+                              char *kstr, int klen, pem_password_cb *cd,\n+                              void *u);\n+\n+EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x);\n+int PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x);\n+\n+EVP_PKEY *b2i_PrivateKey(const unsigned char **in, long length);\n+EVP_PKEY *b2i_PublicKey(const unsigned char **in, long length);\n+EVP_PKEY *b2i_PrivateKey_bio(BIO *in);\n+EVP_PKEY *b2i_PublicKey_bio(BIO *in);\n+int i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk);\n+int i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk);\n+# ifndef OPENSSL_NO_RC4\n+EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u);\n+int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,\n+                pem_password_cb *cb, void *u);\n+# endif\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+\n+void ERR_load_PEM_strings(void);\n+\n+/* Error codes for the PEM functions. */\n+\n+/* Function codes. */\n+# define PEM_F_B2I_DSS                                    127\n+# define PEM_F_B2I_PVK_BIO                                128\n+# define PEM_F_B2I_RSA                                    129\n+# define PEM_F_CHECK_BITLEN_DSA                           130\n+# define PEM_F_CHECK_BITLEN_RSA                           131\n+# define PEM_F_D2I_PKCS8PRIVATEKEY_BIO                    120\n+# define PEM_F_D2I_PKCS8PRIVATEKEY_FP                     121\n+# define PEM_F_DO_B2I                                     132\n+# define PEM_F_DO_B2I_BIO                                 133\n+# define PEM_F_DO_BLOB_HEADER                             134\n+# define PEM_F_DO_PK8PKEY                                 126\n+# define PEM_F_DO_PK8PKEY_FP                              125\n+# define PEM_F_DO_PVK_BODY                                135\n+# define PEM_F_DO_PVK_HEADER                              136\n+# define PEM_F_I2B_PVK                                    137\n+# define PEM_F_I2B_PVK_BIO                                138\n+# define PEM_F_LOAD_IV                                    101\n+# define PEM_F_PEM_ASN1_READ                              102\n+# define PEM_F_PEM_ASN1_READ_BIO                          103\n+# define PEM_F_PEM_ASN1_WRITE                             104\n+# define PEM_F_PEM_ASN1_WRITE_BIO                         105\n+# define PEM_F_PEM_DEF_CALLBACK                           100\n+# define PEM_F_PEM_DO_HEADER                              106\n+# define PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY            118\n+# define PEM_F_PEM_GET_EVP_CIPHER_INFO                    107\n+# define PEM_F_PEM_PK8PKEY                                119\n+# define PEM_F_PEM_READ                                   108\n+# define PEM_F_PEM_READ_BIO                               109\n+# define PEM_F_PEM_READ_BIO_DHPARAMS                      141\n+# define PEM_F_PEM_READ_BIO_PARAMETERS                    140\n+# define PEM_F_PEM_READ_BIO_PRIVATEKEY                    123\n+# define PEM_F_PEM_READ_DHPARAMS                          142\n+# define PEM_F_PEM_READ_PRIVATEKEY                        124\n+# define PEM_F_PEM_SEALFINAL                              110\n+# define PEM_F_PEM_SEALINIT                               111\n+# define PEM_F_PEM_SIGNFINAL                              112\n+# define PEM_F_PEM_WRITE                                  113\n+# define PEM_F_PEM_WRITE_BIO                              114\n+# define PEM_F_PEM_WRITE_PRIVATEKEY                       139\n+# define PEM_F_PEM_X509_INFO_READ                         115\n+# define PEM_F_PEM_X509_INFO_READ_BIO                     116\n+# define PEM_F_PEM_X509_INFO_WRITE_BIO                    117\n+\n+/* Reason codes. */\n+# define PEM_R_BAD_BASE64_DECODE                          100\n+# define PEM_R_BAD_DECRYPT                                101\n+# define PEM_R_BAD_END_LINE                               102\n+# define PEM_R_BAD_IV_CHARS                               103\n+# define PEM_R_BAD_MAGIC_NUMBER                           116\n+# define PEM_R_BAD_PASSWORD_READ                          104\n+# define PEM_R_BAD_VERSION_NUMBER                         117\n+# define PEM_R_BIO_WRITE_FAILURE                          118\n+# define PEM_R_CIPHER_IS_NULL                             127\n+# define PEM_R_ERROR_CONVERTING_PRIVATE_KEY               115\n+# define PEM_R_EXPECTING_PRIVATE_KEY_BLOB                 119\n+# define PEM_R_EXPECTING_PUBLIC_KEY_BLOB                  120\n+# define PEM_R_HEADER_TOO_LONG                            128\n+# define PEM_R_INCONSISTENT_HEADER                        121\n+# define PEM_R_KEYBLOB_HEADER_PARSE_ERROR                 122\n+# define PEM_R_KEYBLOB_TOO_SHORT                          123\n+# define PEM_R_NOT_DEK_INFO                               105\n+# define PEM_R_NOT_ENCRYPTED                              106\n+# define PEM_R_NOT_PROC_TYPE                              107\n+# define PEM_R_NO_START_LINE                              108\n+# define PEM_R_PROBLEMS_GETTING_PASSWORD                  109\n+# define PEM_R_PUBLIC_KEY_NO_RSA                          110\n+# define PEM_R_PVK_DATA_TOO_SHORT                         124\n+# define PEM_R_PVK_TOO_SHORT                              125\n+# define PEM_R_READ_KEY                                   111\n+# define PEM_R_SHORT_HEADER                               112\n+# define PEM_R_UNSUPPORTED_CIPHER                         113\n+# define PEM_R_UNSUPPORTED_ENCRYPTION                     114\n+# define PEM_R_UNSUPPORTED_KEY_COMPONENTS                 126\n+\n+# ifdef  __cplusplus\n+}\n+# endif\n+#endif"
        },
        {
            "sha": "84897d5ec35b6a53ce9e5d0f4d1faab3666cbb41",
            "filename": "deps/openssl/openssl/include/openssl/pem2.h",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpem2.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpem2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpem2.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,70 @@\n+/* ====================================================================\n+ * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+/*\n+ * This header only exists to break a circular dependency between pem and err\n+ * Ben 30 Jan 1999.\n+ */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#ifndef HEADER_PEM_H\n+void ERR_load_PEM_strings(void);\n+#endif\n+\n+#ifdef __cplusplus\n+}\n+#endif"
        },
        {
            "sha": "21f1f62b36c66fc655087e4f75807a91b8d99e5b",
            "filename": "deps/openssl/openssl/include/openssl/pkcs12.h",
            "status": "added",
            "additions": 342,
            "deletions": 0,
            "changes": 342,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpkcs12.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpkcs12.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpkcs12.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,342 @@\n+/* pkcs12.h */\n+/*\n+ * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL project\n+ * 1999.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    licensing@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#ifndef HEADER_PKCS12_H\n+# define HEADER_PKCS12_H\n+\n+# include <openssl/bio.h>\n+# include <openssl/x509.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# define PKCS12_KEY_ID   1\n+# define PKCS12_IV_ID    2\n+# define PKCS12_MAC_ID   3\n+\n+/* Default iteration count */\n+# ifndef PKCS12_DEFAULT_ITER\n+#  define PKCS12_DEFAULT_ITER     PKCS5_DEFAULT_ITER\n+# endif\n+\n+# define PKCS12_MAC_KEY_LENGTH 20\n+\n+# define PKCS12_SALT_LEN 8\n+\n+/* Uncomment out next line for unicode password and names, otherwise ASCII */\n+\n+/*\n+ * #define PBE_UNICODE\n+ */\n+\n+# ifdef PBE_UNICODE\n+#  define PKCS12_key_gen PKCS12_key_gen_uni\n+#  define PKCS12_add_friendlyname PKCS12_add_friendlyname_uni\n+# else\n+#  define PKCS12_key_gen PKCS12_key_gen_asc\n+#  define PKCS12_add_friendlyname PKCS12_add_friendlyname_asc\n+# endif\n+\n+/* MS key usage constants */\n+\n+# define KEY_EX  0x10\n+# define KEY_SIG 0x80\n+\n+typedef struct {\n+    X509_SIG *dinfo;\n+    ASN1_OCTET_STRING *salt;\n+    ASN1_INTEGER *iter;         /* defaults to 1 */\n+} PKCS12_MAC_DATA;\n+\n+typedef struct {\n+    ASN1_INTEGER *version;\n+    PKCS12_MAC_DATA *mac;\n+    PKCS7 *authsafes;\n+} PKCS12;\n+\n+typedef struct {\n+    ASN1_OBJECT *type;\n+    union {\n+        struct pkcs12_bag_st *bag; /* secret, crl and certbag */\n+        struct pkcs8_priv_key_info_st *keybag; /* keybag */\n+        X509_SIG *shkeybag;     /* shrouded key bag */\n+        STACK_OF(PKCS12_SAFEBAG) *safes;\n+        ASN1_TYPE *other;\n+    } value;\n+    STACK_OF(X509_ATTRIBUTE) *attrib;\n+} PKCS12_SAFEBAG;\n+\n+DECLARE_STACK_OF(PKCS12_SAFEBAG)\n+DECLARE_ASN1_SET_OF(PKCS12_SAFEBAG)\n+DECLARE_PKCS12_STACK_OF(PKCS12_SAFEBAG)\n+\n+typedef struct pkcs12_bag_st {\n+    ASN1_OBJECT *type;\n+    union {\n+        ASN1_OCTET_STRING *x509cert;\n+        ASN1_OCTET_STRING *x509crl;\n+        ASN1_OCTET_STRING *octet;\n+        ASN1_IA5STRING *sdsicert;\n+        ASN1_TYPE *other;       /* Secret or other bag */\n+    } value;\n+} PKCS12_BAGS;\n+\n+# define PKCS12_ERROR    0\n+# define PKCS12_OK       1\n+\n+/* Compatibility macros */\n+\n+# define M_PKCS12_x5092certbag PKCS12_x5092certbag\n+# define M_PKCS12_x509crl2certbag PKCS12_x509crl2certbag\n+\n+# define M_PKCS12_certbag2x509 PKCS12_certbag2x509\n+# define M_PKCS12_certbag2x509crl PKCS12_certbag2x509crl\n+\n+# define M_PKCS12_unpack_p7data PKCS12_unpack_p7data\n+# define M_PKCS12_pack_authsafes PKCS12_pack_authsafes\n+# define M_PKCS12_unpack_authsafes PKCS12_unpack_authsafes\n+# define M_PKCS12_unpack_p7encdata PKCS12_unpack_p7encdata\n+\n+# define M_PKCS12_decrypt_skey PKCS12_decrypt_skey\n+# define M_PKCS8_decrypt PKCS8_decrypt\n+\n+# define M_PKCS12_bag_type(bg) OBJ_obj2nid((bg)->type)\n+# define M_PKCS12_cert_bag_type(bg) OBJ_obj2nid((bg)->value.bag->type)\n+# define M_PKCS12_crl_bag_type M_PKCS12_cert_bag_type\n+\n+# define PKCS12_get_attr(bag, attr_nid) \\\n+                         PKCS12_get_attr_gen(bag->attrib, attr_nid)\n+\n+# define PKCS8_get_attr(p8, attr_nid) \\\n+                PKCS12_get_attr_gen(p8->attributes, attr_nid)\n+\n+# define PKCS12_mac_present(p12) ((p12)->mac ? 1 : 0)\n+\n+PKCS12_SAFEBAG *PKCS12_x5092certbag(X509 *x509);\n+PKCS12_SAFEBAG *PKCS12_x509crl2certbag(X509_CRL *crl);\n+X509 *PKCS12_certbag2x509(PKCS12_SAFEBAG *bag);\n+X509_CRL *PKCS12_certbag2x509crl(PKCS12_SAFEBAG *bag);\n+\n+PKCS12_SAFEBAG *PKCS12_item_pack_safebag(void *obj, const ASN1_ITEM *it,\n+                                         int nid1, int nid2);\n+PKCS12_SAFEBAG *PKCS12_MAKE_KEYBAG(PKCS8_PRIV_KEY_INFO *p8);\n+PKCS8_PRIV_KEY_INFO *PKCS8_decrypt(X509_SIG *p8, const char *pass,\n+                                   int passlen);\n+PKCS8_PRIV_KEY_INFO *PKCS12_decrypt_skey(PKCS12_SAFEBAG *bag,\n+                                         const char *pass, int passlen);\n+X509_SIG *PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher,\n+                        const char *pass, int passlen, unsigned char *salt,\n+                        int saltlen, int iter, PKCS8_PRIV_KEY_INFO *p8);\n+PKCS12_SAFEBAG *PKCS12_MAKE_SHKEYBAG(int pbe_nid, const char *pass,\n+                                     int passlen, unsigned char *salt,\n+                                     int saltlen, int iter,\n+                                     PKCS8_PRIV_KEY_INFO *p8);\n+PKCS7 *PKCS12_pack_p7data(STACK_OF(PKCS12_SAFEBAG) *sk);\n+STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7);\n+PKCS7 *PKCS12_pack_p7encdata(int pbe_nid, const char *pass, int passlen,\n+                             unsigned char *salt, int saltlen, int iter,\n+                             STACK_OF(PKCS12_SAFEBAG) *bags);\n+STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7encdata(PKCS7 *p7, const char *pass,\n+                                                  int passlen);\n+\n+int PKCS12_pack_authsafes(PKCS12 *p12, STACK_OF(PKCS7) *safes);\n+STACK_OF(PKCS7) *PKCS12_unpack_authsafes(PKCS12 *p12);\n+\n+int PKCS12_add_localkeyid(PKCS12_SAFEBAG *bag, unsigned char *name,\n+                          int namelen);\n+int PKCS12_add_friendlyname_asc(PKCS12_SAFEBAG *bag, const char *name,\n+                                int namelen);\n+int PKCS12_add_CSPName_asc(PKCS12_SAFEBAG *bag, const char *name,\n+                           int namelen);\n+int PKCS12_add_friendlyname_uni(PKCS12_SAFEBAG *bag,\n+                                const unsigned char *name, int namelen);\n+int PKCS8_add_keyusage(PKCS8_PRIV_KEY_INFO *p8, int usage);\n+ASN1_TYPE *PKCS12_get_attr_gen(STACK_OF(X509_ATTRIBUTE) *attrs, int attr_nid);\n+char *PKCS12_get_friendlyname(PKCS12_SAFEBAG *bag);\n+unsigned char *PKCS12_pbe_crypt(X509_ALGOR *algor, const char *pass,\n+                                int passlen, unsigned char *in, int inlen,\n+                                unsigned char **data, int *datalen,\n+                                int en_de);\n+void *PKCS12_item_decrypt_d2i(X509_ALGOR *algor, const ASN1_ITEM *it,\n+                              const char *pass, int passlen,\n+                              ASN1_OCTET_STRING *oct, int zbuf);\n+ASN1_OCTET_STRING *PKCS12_item_i2d_encrypt(X509_ALGOR *algor,\n+                                           const ASN1_ITEM *it,\n+                                           const char *pass, int passlen,\n+                                           void *obj, int zbuf);\n+PKCS12 *PKCS12_init(int mode);\n+int PKCS12_key_gen_asc(const char *pass, int passlen, unsigned char *salt,\n+                       int saltlen, int id, int iter, int n,\n+                       unsigned char *out, const EVP_MD *md_type);\n+int PKCS12_key_gen_uni(unsigned char *pass, int passlen, unsigned char *salt,\n+                       int saltlen, int id, int iter, int n,\n+                       unsigned char *out, const EVP_MD *md_type);\n+int PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\n+                        ASN1_TYPE *param, const EVP_CIPHER *cipher,\n+                        const EVP_MD *md_type, int en_de);\n+int PKCS12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\n+                   unsigned char *mac, unsigned int *maclen);\n+int PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen);\n+int PKCS12_set_mac(PKCS12 *p12, const char *pass, int passlen,\n+                   unsigned char *salt, int saltlen, int iter,\n+                   const EVP_MD *md_type);\n+int PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt,\n+                     int saltlen, const EVP_MD *md_type);\n+unsigned char *OPENSSL_asc2uni(const char *asc, int asclen,\n+                               unsigned char **uni, int *unilen);\n+char *OPENSSL_uni2asc(unsigned char *uni, int unilen);\n+\n+DECLARE_ASN1_FUNCTIONS(PKCS12)\n+DECLARE_ASN1_FUNCTIONS(PKCS12_MAC_DATA)\n+DECLARE_ASN1_FUNCTIONS(PKCS12_SAFEBAG)\n+DECLARE_ASN1_FUNCTIONS(PKCS12_BAGS)\n+\n+DECLARE_ASN1_ITEM(PKCS12_SAFEBAGS)\n+DECLARE_ASN1_ITEM(PKCS12_AUTHSAFES)\n+\n+void PKCS12_PBE_add(void);\n+int PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,\n+                 STACK_OF(X509) **ca);\n+PKCS12 *PKCS12_create(char *pass, char *name, EVP_PKEY *pkey, X509 *cert,\n+                      STACK_OF(X509) *ca, int nid_key, int nid_cert, int iter,\n+                      int mac_iter, int keytype);\n+\n+PKCS12_SAFEBAG *PKCS12_add_cert(STACK_OF(PKCS12_SAFEBAG) **pbags, X509 *cert);\n+PKCS12_SAFEBAG *PKCS12_add_key(STACK_OF(PKCS12_SAFEBAG) **pbags,\n+                               EVP_PKEY *key, int key_usage, int iter,\n+                               int key_nid, char *pass);\n+int PKCS12_add_safe(STACK_OF(PKCS7) **psafes, STACK_OF(PKCS12_SAFEBAG) *bags,\n+                    int safe_nid, int iter, char *pass);\n+PKCS12 *PKCS12_add_safes(STACK_OF(PKCS7) *safes, int p7_nid);\n+\n+int i2d_PKCS12_bio(BIO *bp, PKCS12 *p12);\n+int i2d_PKCS12_fp(FILE *fp, PKCS12 *p12);\n+PKCS12 *d2i_PKCS12_bio(BIO *bp, PKCS12 **p12);\n+PKCS12 *d2i_PKCS12_fp(FILE *fp, PKCS12 **p12);\n+int PKCS12_newpass(PKCS12 *p12, const char *oldpass, const char *newpass);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_PKCS12_strings(void);\n+\n+/* Error codes for the PKCS12 functions. */\n+\n+/* Function codes. */\n+# define PKCS12_F_PARSE_BAG                               129\n+# define PKCS12_F_PARSE_BAGS                              103\n+# define PKCS12_F_PKCS12_ADD_FRIENDLYNAME                 100\n+# define PKCS12_F_PKCS12_ADD_FRIENDLYNAME_ASC             127\n+# define PKCS12_F_PKCS12_ADD_FRIENDLYNAME_UNI             102\n+# define PKCS12_F_PKCS12_ADD_LOCALKEYID                   104\n+# define PKCS12_F_PKCS12_CREATE                           105\n+# define PKCS12_F_PKCS12_GEN_MAC                          107\n+# define PKCS12_F_PKCS12_INIT                             109\n+# define PKCS12_F_PKCS12_ITEM_DECRYPT_D2I                 106\n+# define PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT                 108\n+# define PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG                117\n+# define PKCS12_F_PKCS12_KEY_GEN_ASC                      110\n+# define PKCS12_F_PKCS12_KEY_GEN_UNI                      111\n+# define PKCS12_F_PKCS12_MAKE_KEYBAG                      112\n+# define PKCS12_F_PKCS12_MAKE_SHKEYBAG                    113\n+# define PKCS12_F_PKCS12_NEWPASS                          128\n+# define PKCS12_F_PKCS12_PACK_P7DATA                      114\n+# define PKCS12_F_PKCS12_PACK_P7ENCDATA                   115\n+# define PKCS12_F_PKCS12_PARSE                            118\n+# define PKCS12_F_PKCS12_PBE_CRYPT                        119\n+# define PKCS12_F_PKCS12_PBE_KEYIVGEN                     120\n+# define PKCS12_F_PKCS12_SETUP_MAC                        122\n+# define PKCS12_F_PKCS12_SET_MAC                          123\n+# define PKCS12_F_PKCS12_UNPACK_AUTHSAFES                 130\n+# define PKCS12_F_PKCS12_UNPACK_P7DATA                    131\n+# define PKCS12_F_PKCS12_VERIFY_MAC                       126\n+# define PKCS12_F_PKCS8_ADD_KEYUSAGE                      124\n+# define PKCS12_F_PKCS8_ENCRYPT                           125\n+\n+/* Reason codes. */\n+# define PKCS12_R_CANT_PACK_STRUCTURE                     100\n+# define PKCS12_R_CONTENT_TYPE_NOT_DATA                   121\n+# define PKCS12_R_DECODE_ERROR                            101\n+# define PKCS12_R_ENCODE_ERROR                            102\n+# define PKCS12_R_ENCRYPT_ERROR                           103\n+# define PKCS12_R_ERROR_SETTING_ENCRYPTED_DATA_TYPE       120\n+# define PKCS12_R_INVALID_NULL_ARGUMENT                   104\n+# define PKCS12_R_INVALID_NULL_PKCS12_POINTER             105\n+# define PKCS12_R_IV_GEN_ERROR                            106\n+# define PKCS12_R_KEY_GEN_ERROR                           107\n+# define PKCS12_R_MAC_ABSENT                              108\n+# define PKCS12_R_MAC_GENERATION_ERROR                    109\n+# define PKCS12_R_MAC_SETUP_ERROR                         110\n+# define PKCS12_R_MAC_STRING_SET_ERROR                    111\n+# define PKCS12_R_MAC_VERIFY_ERROR                        112\n+# define PKCS12_R_MAC_VERIFY_FAILURE                      113\n+# define PKCS12_R_PARSE_ERROR                             114\n+# define PKCS12_R_PKCS12_ALGOR_CIPHERINIT_ERROR           115\n+# define PKCS12_R_PKCS12_CIPHERFINAL_ERROR                116\n+# define PKCS12_R_PKCS12_PBE_CRYPT_ERROR                  117\n+# define PKCS12_R_UNKNOWN_DIGEST_ALGORITHM                118\n+# define PKCS12_R_UNSUPPORTED_PKCS12_MODE                 119\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "b51b3863eb3c38532e74f91d0a70a48a3d779a82",
            "filename": "deps/openssl/openssl/include/openssl/pkcs7.h",
            "status": "added",
            "additions": 481,
            "deletions": 0,
            "changes": 481,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpkcs7.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpkcs7.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpkcs7.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,481 @@\n+/* crypto/pkcs7/pkcs7.h */\n+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)\n+ * All rights reserved.\n+ *\n+ * This package is an SSL implementation written\n+ * by Eric Young (eay@cryptsoft.com).\n+ * The implementation was written so as to conform with Netscapes SSL.\n+ *\n+ * This library is free for commercial and non-commercial use as long as\n+ * the following conditions are aheared to.  The following conditions\n+ * apply to all code found in this distribution, be it the RC4, RSA,\n+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation\n+ * included with this distribution is covered by the same copyright terms\n+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).\n+ *\n+ * Copyright remains Eric Young's, and as such any Copyright notices in\n+ * the code are not to be removed.\n+ * If this package is used in a product, Eric Young should be given attribution\n+ * as the author of the parts of the library used.\n+ * This can be in the form of a textual message at program startup or\n+ * in documentation (online or textual) provided with the package.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *    \"This product includes cryptographic software written by\n+ *     Eric Young (eay@cryptsoft.com)\"\n+ *    The word 'cryptographic' can be left out if the rouines from the library\n+ *    being used are not cryptographic related :-).\n+ * 4. If you include any Windows specific code (or a derivative thereof) from\n+ *    the apps directory (application code) you must include an acknowledgement:\n+ *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ * The licence and distribution terms for any publically available version or\n+ * derivative of this code cannot be changed.  i.e. this code cannot simply be\n+ * copied and put under another distribution licence\n+ * [including the GNU Public Licence.]\n+ */\n+\n+#ifndef HEADER_PKCS7_H\n+# define HEADER_PKCS7_H\n+\n+# include <openssl/asn1.h>\n+# include <openssl/bio.h>\n+# include <openssl/e_os2.h>\n+\n+# include <openssl/symhacks.h>\n+# include <openssl/ossl_typ.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+\n+# ifdef OPENSSL_SYS_WIN32\n+/* Under Win32 thes are defined in wincrypt.h */\n+#  undef PKCS7_ISSUER_AND_SERIAL\n+#  undef PKCS7_SIGNER_INFO\n+# endif\n+\n+/*-\n+Encryption_ID           DES-CBC\n+Digest_ID               MD5\n+Digest_Encryption_ID    rsaEncryption\n+Key_Encryption_ID       rsaEncryption\n+*/\n+\n+typedef struct pkcs7_issuer_and_serial_st {\n+    X509_NAME *issuer;\n+    ASN1_INTEGER *serial;\n+} PKCS7_ISSUER_AND_SERIAL;\n+\n+typedef struct pkcs7_signer_info_st {\n+    ASN1_INTEGER *version;      /* version 1 */\n+    PKCS7_ISSUER_AND_SERIAL *issuer_and_serial;\n+    X509_ALGOR *digest_alg;\n+    STACK_OF(X509_ATTRIBUTE) *auth_attr; /* [ 0 ] */\n+    X509_ALGOR *digest_enc_alg;\n+    ASN1_OCTET_STRING *enc_digest;\n+    STACK_OF(X509_ATTRIBUTE) *unauth_attr; /* [ 1 ] */\n+    /* The private key to sign with */\n+    EVP_PKEY *pkey;\n+} PKCS7_SIGNER_INFO;\n+\n+DECLARE_STACK_OF(PKCS7_SIGNER_INFO)\n+DECLARE_ASN1_SET_OF(PKCS7_SIGNER_INFO)\n+\n+typedef struct pkcs7_recip_info_st {\n+    ASN1_INTEGER *version;      /* version 0 */\n+    PKCS7_ISSUER_AND_SERIAL *issuer_and_serial;\n+    X509_ALGOR *key_enc_algor;\n+    ASN1_OCTET_STRING *enc_key;\n+    X509 *cert;                 /* get the pub-key from this */\n+} PKCS7_RECIP_INFO;\n+\n+DECLARE_STACK_OF(PKCS7_RECIP_INFO)\n+DECLARE_ASN1_SET_OF(PKCS7_RECIP_INFO)\n+\n+typedef struct pkcs7_signed_st {\n+    ASN1_INTEGER *version;      /* version 1 */\n+    STACK_OF(X509_ALGOR) *md_algs; /* md used */\n+    STACK_OF(X509) *cert;       /* [ 0 ] */\n+    STACK_OF(X509_CRL) *crl;    /* [ 1 ] */\n+    STACK_OF(PKCS7_SIGNER_INFO) *signer_info;\n+    struct pkcs7_st *contents;\n+} PKCS7_SIGNED;\n+/*\n+ * The above structure is very very similar to PKCS7_SIGN_ENVELOPE. How about\n+ * merging the two\n+ */\n+\n+typedef struct pkcs7_enc_content_st {\n+    ASN1_OBJECT *content_type;\n+    X509_ALGOR *algorithm;\n+    ASN1_OCTET_STRING *enc_data; /* [ 0 ] */\n+    const EVP_CIPHER *cipher;\n+} PKCS7_ENC_CONTENT;\n+\n+typedef struct pkcs7_enveloped_st {\n+    ASN1_INTEGER *version;      /* version 0 */\n+    STACK_OF(PKCS7_RECIP_INFO) *recipientinfo;\n+    PKCS7_ENC_CONTENT *enc_data;\n+} PKCS7_ENVELOPE;\n+\n+typedef struct pkcs7_signedandenveloped_st {\n+    ASN1_INTEGER *version;      /* version 1 */\n+    STACK_OF(X509_ALGOR) *md_algs; /* md used */\n+    STACK_OF(X509) *cert;       /* [ 0 ] */\n+    STACK_OF(X509_CRL) *crl;    /* [ 1 ] */\n+    STACK_OF(PKCS7_SIGNER_INFO) *signer_info;\n+    PKCS7_ENC_CONTENT *enc_data;\n+    STACK_OF(PKCS7_RECIP_INFO) *recipientinfo;\n+} PKCS7_SIGN_ENVELOPE;\n+\n+typedef struct pkcs7_digest_st {\n+    ASN1_INTEGER *version;      /* version 0 */\n+    X509_ALGOR *md;             /* md used */\n+    struct pkcs7_st *contents;\n+    ASN1_OCTET_STRING *digest;\n+} PKCS7_DIGEST;\n+\n+typedef struct pkcs7_encrypted_st {\n+    ASN1_INTEGER *version;      /* version 0 */\n+    PKCS7_ENC_CONTENT *enc_data;\n+} PKCS7_ENCRYPT;\n+\n+typedef struct pkcs7_st {\n+    /*\n+     * The following is non NULL if it contains ASN1 encoding of this\n+     * structure\n+     */\n+    unsigned char *asn1;\n+    long length;\n+# define PKCS7_S_HEADER  0\n+# define PKCS7_S_BODY    1\n+# define PKCS7_S_TAIL    2\n+    int state;                  /* used during processing */\n+    int detached;\n+    ASN1_OBJECT *type;\n+    /* content as defined by the type */\n+    /*\n+     * all encryption/message digests are applied to the 'contents', leaving\n+     * out the 'type' field.\n+     */\n+    union {\n+        char *ptr;\n+        /* NID_pkcs7_data */\n+        ASN1_OCTET_STRING *data;\n+        /* NID_pkcs7_signed */\n+        PKCS7_SIGNED *sign;\n+        /* NID_pkcs7_enveloped */\n+        PKCS7_ENVELOPE *enveloped;\n+        /* NID_pkcs7_signedAndEnveloped */\n+        PKCS7_SIGN_ENVELOPE *signed_and_enveloped;\n+        /* NID_pkcs7_digest */\n+        PKCS7_DIGEST *digest;\n+        /* NID_pkcs7_encrypted */\n+        PKCS7_ENCRYPT *encrypted;\n+        /* Anything else */\n+        ASN1_TYPE *other;\n+    } d;\n+} PKCS7;\n+\n+DECLARE_STACK_OF(PKCS7)\n+DECLARE_ASN1_SET_OF(PKCS7)\n+DECLARE_PKCS12_STACK_OF(PKCS7)\n+\n+# define PKCS7_OP_SET_DETACHED_SIGNATURE 1\n+# define PKCS7_OP_GET_DETACHED_SIGNATURE 2\n+\n+# define PKCS7_get_signed_attributes(si) ((si)->auth_attr)\n+# define PKCS7_get_attributes(si)        ((si)->unauth_attr)\n+\n+# define PKCS7_type_is_signed(a) (OBJ_obj2nid((a)->type) == NID_pkcs7_signed)\n+# define PKCS7_type_is_encrypted(a) (OBJ_obj2nid((a)->type) == NID_pkcs7_encrypted)\n+# define PKCS7_type_is_enveloped(a) (OBJ_obj2nid((a)->type) == NID_pkcs7_enveloped)\n+# define PKCS7_type_is_signedAndEnveloped(a) \\\n+                (OBJ_obj2nid((a)->type) == NID_pkcs7_signedAndEnveloped)\n+# define PKCS7_type_is_data(a)   (OBJ_obj2nid((a)->type) == NID_pkcs7_data)\n+# define PKCS7_type_is_digest(a)   (OBJ_obj2nid((a)->type) == NID_pkcs7_digest)\n+\n+# define PKCS7_set_detached(p,v) \\\n+                PKCS7_ctrl(p,PKCS7_OP_SET_DETACHED_SIGNATURE,v,NULL)\n+# define PKCS7_get_detached(p) \\\n+                PKCS7_ctrl(p,PKCS7_OP_GET_DETACHED_SIGNATURE,0,NULL)\n+\n+# define PKCS7_is_detached(p7) (PKCS7_type_is_signed(p7) && PKCS7_get_detached(p7))\n+\n+/* S/MIME related flags */\n+\n+# define PKCS7_TEXT              0x1\n+# define PKCS7_NOCERTS           0x2\n+# define PKCS7_NOSIGS            0x4\n+# define PKCS7_NOCHAIN           0x8\n+# define PKCS7_NOINTERN          0x10\n+# define PKCS7_NOVERIFY          0x20\n+# define PKCS7_DETACHED          0x40\n+# define PKCS7_BINARY            0x80\n+# define PKCS7_NOATTR            0x100\n+# define PKCS7_NOSMIMECAP        0x200\n+# define PKCS7_NOOLDMIMETYPE     0x400\n+# define PKCS7_CRLFEOL           0x800\n+# define PKCS7_STREAM            0x1000\n+# define PKCS7_NOCRL             0x2000\n+# define PKCS7_PARTIAL           0x4000\n+# define PKCS7_REUSE_DIGEST      0x8000\n+\n+/* Flags: for compatibility with older code */\n+\n+# define SMIME_TEXT      PKCS7_TEXT\n+# define SMIME_NOCERTS   PKCS7_NOCERTS\n+# define SMIME_NOSIGS    PKCS7_NOSIGS\n+# define SMIME_NOCHAIN   PKCS7_NOCHAIN\n+# define SMIME_NOINTERN  PKCS7_NOINTERN\n+# define SMIME_NOVERIFY  PKCS7_NOVERIFY\n+# define SMIME_DETACHED  PKCS7_DETACHED\n+# define SMIME_BINARY    PKCS7_BINARY\n+# define SMIME_NOATTR    PKCS7_NOATTR\n+\n+DECLARE_ASN1_FUNCTIONS(PKCS7_ISSUER_AND_SERIAL)\n+\n+int PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data,\n+                                   const EVP_MD *type, unsigned char *md,\n+                                   unsigned int *len);\n+# ifndef OPENSSL_NO_FP_API\n+PKCS7 *d2i_PKCS7_fp(FILE *fp, PKCS7 **p7);\n+int i2d_PKCS7_fp(FILE *fp, PKCS7 *p7);\n+# endif\n+PKCS7 *PKCS7_dup(PKCS7 *p7);\n+PKCS7 *d2i_PKCS7_bio(BIO *bp, PKCS7 **p7);\n+int i2d_PKCS7_bio(BIO *bp, PKCS7 *p7);\n+int i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags);\n+int PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags);\n+\n+DECLARE_ASN1_FUNCTIONS(PKCS7_SIGNER_INFO)\n+DECLARE_ASN1_FUNCTIONS(PKCS7_RECIP_INFO)\n+DECLARE_ASN1_FUNCTIONS(PKCS7_SIGNED)\n+DECLARE_ASN1_FUNCTIONS(PKCS7_ENC_CONTENT)\n+DECLARE_ASN1_FUNCTIONS(PKCS7_ENVELOPE)\n+DECLARE_ASN1_FUNCTIONS(PKCS7_SIGN_ENVELOPE)\n+DECLARE_ASN1_FUNCTIONS(PKCS7_DIGEST)\n+DECLARE_ASN1_FUNCTIONS(PKCS7_ENCRYPT)\n+DECLARE_ASN1_FUNCTIONS(PKCS7)\n+\n+DECLARE_ASN1_ITEM(PKCS7_ATTR_SIGN)\n+DECLARE_ASN1_ITEM(PKCS7_ATTR_VERIFY)\n+\n+DECLARE_ASN1_NDEF_FUNCTION(PKCS7)\n+DECLARE_ASN1_PRINT_FUNCTION(PKCS7)\n+\n+long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg);\n+\n+int PKCS7_set_type(PKCS7 *p7, int type);\n+int PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other);\n+int PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data);\n+int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,\n+                          const EVP_MD *dgst);\n+int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si);\n+int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *p7i);\n+int PKCS7_add_certificate(PKCS7 *p7, X509 *x509);\n+int PKCS7_add_crl(PKCS7 *p7, X509_CRL *x509);\n+int PKCS7_content_new(PKCS7 *p7, int nid);\n+int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx,\n+                     BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si);\n+int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,\n+                          X509 *x509);\n+\n+BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio);\n+int PKCS7_dataFinal(PKCS7 *p7, BIO *bio);\n+BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert);\n+\n+PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509,\n+                                       EVP_PKEY *pkey, const EVP_MD *dgst);\n+X509 *PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si);\n+int PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md);\n+STACK_OF(PKCS7_SIGNER_INFO) *PKCS7_get_signer_info(PKCS7 *p7);\n+\n+PKCS7_RECIP_INFO *PKCS7_add_recipient(PKCS7 *p7, X509 *x509);\n+void PKCS7_SIGNER_INFO_get0_algs(PKCS7_SIGNER_INFO *si, EVP_PKEY **pk,\n+                                 X509_ALGOR **pdig, X509_ALGOR **psig);\n+void PKCS7_RECIP_INFO_get0_alg(PKCS7_RECIP_INFO *ri, X509_ALGOR **penc);\n+int PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri);\n+int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509);\n+int PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher);\n+int PKCS7_stream(unsigned char ***boundary, PKCS7 *p7);\n+\n+PKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx);\n+ASN1_OCTET_STRING *PKCS7_digest_from_attributes(STACK_OF(X509_ATTRIBUTE) *sk);\n+int PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int type,\n+                               void *data);\n+int PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,\n+                        void *value);\n+ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid);\n+ASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid);\n+int PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si,\n+                                STACK_OF(X509_ATTRIBUTE) *sk);\n+int PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si,\n+                         STACK_OF(X509_ATTRIBUTE) *sk);\n+\n+PKCS7 *PKCS7_sign(X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs,\n+                  BIO *data, int flags);\n+\n+PKCS7_SIGNER_INFO *PKCS7_sign_add_signer(PKCS7 *p7,\n+                                         X509 *signcert, EVP_PKEY *pkey,\n+                                         const EVP_MD *md, int flags);\n+\n+int PKCS7_final(PKCS7 *p7, BIO *data, int flags);\n+int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,\n+                 BIO *indata, BIO *out, int flags);\n+STACK_OF(X509) *PKCS7_get0_signers(PKCS7 *p7, STACK_OF(X509) *certs,\n+                                   int flags);\n+PKCS7 *PKCS7_encrypt(STACK_OF(X509) *certs, BIO *in, const EVP_CIPHER *cipher,\n+                     int flags);\n+int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data,\n+                  int flags);\n+\n+int PKCS7_add_attrib_smimecap(PKCS7_SIGNER_INFO *si,\n+                              STACK_OF(X509_ALGOR) *cap);\n+STACK_OF(X509_ALGOR) *PKCS7_get_smimecap(PKCS7_SIGNER_INFO *si);\n+int PKCS7_simple_smimecap(STACK_OF(X509_ALGOR) *sk, int nid, int arg);\n+\n+int PKCS7_add_attrib_content_type(PKCS7_SIGNER_INFO *si, ASN1_OBJECT *coid);\n+int PKCS7_add0_attrib_signing_time(PKCS7_SIGNER_INFO *si, ASN1_TIME *t);\n+int PKCS7_add1_attrib_digest(PKCS7_SIGNER_INFO *si,\n+                             const unsigned char *md, int mdlen);\n+\n+int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags);\n+PKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont);\n+\n+BIO *BIO_new_PKCS7(BIO *out, PKCS7 *p7);\n+\n+/* BEGIN ERROR CODES */\n+/*\n+ * The following lines are auto generated by the script mkerr.pl. Any changes\n+ * made after this point may be overwritten when the script is next run.\n+ */\n+void ERR_load_PKCS7_strings(void);\n+\n+/* Error codes for the PKCS7 functions. */\n+\n+/* Function codes. */\n+# define PKCS7_F_B64_READ_PKCS7                           120\n+# define PKCS7_F_B64_WRITE_PKCS7                          121\n+# define PKCS7_F_DO_PKCS7_SIGNED_ATTRIB                   136\n+# define PKCS7_F_I2D_PKCS7_BIO_STREAM                     140\n+# define PKCS7_F_PKCS7_ADD0_ATTRIB_SIGNING_TIME           135\n+# define PKCS7_F_PKCS7_ADD_ATTRIB_SMIMECAP                118\n+# define PKCS7_F_PKCS7_ADD_CERTIFICATE                    100\n+# define PKCS7_F_PKCS7_ADD_CRL                            101\n+# define PKCS7_F_PKCS7_ADD_RECIPIENT_INFO                 102\n+# define PKCS7_F_PKCS7_ADD_SIGNATURE                      131\n+# define PKCS7_F_PKCS7_ADD_SIGNER                         103\n+# define PKCS7_F_PKCS7_BIO_ADD_DIGEST                     125\n+# define PKCS7_F_PKCS7_COPY_EXISTING_DIGEST               138\n+# define PKCS7_F_PKCS7_CTRL                               104\n+# define PKCS7_F_PKCS7_DATADECODE                         112\n+# define PKCS7_F_PKCS7_DATAFINAL                          128\n+# define PKCS7_F_PKCS7_DATAINIT                           105\n+# define PKCS7_F_PKCS7_DATASIGN                           106\n+# define PKCS7_F_PKCS7_DATAVERIFY                         107\n+# define PKCS7_F_PKCS7_DECRYPT                            114\n+# define PKCS7_F_PKCS7_DECRYPT_RINFO                      133\n+# define PKCS7_F_PKCS7_ENCODE_RINFO                       132\n+# define PKCS7_F_PKCS7_ENCRYPT                            115\n+# define PKCS7_F_PKCS7_FINAL                              134\n+# define PKCS7_F_PKCS7_FIND_DIGEST                        127\n+# define PKCS7_F_PKCS7_GET0_SIGNERS                       124\n+# define PKCS7_F_PKCS7_RECIP_INFO_SET                     130\n+# define PKCS7_F_PKCS7_SET_CIPHER                         108\n+# define PKCS7_F_PKCS7_SET_CONTENT                        109\n+# define PKCS7_F_PKCS7_SET_DIGEST                         126\n+# define PKCS7_F_PKCS7_SET_TYPE                           110\n+# define PKCS7_F_PKCS7_SIGN                               116\n+# define PKCS7_F_PKCS7_SIGNATUREVERIFY                    113\n+# define PKCS7_F_PKCS7_SIGNER_INFO_SET                    129\n+# define PKCS7_F_PKCS7_SIGNER_INFO_SIGN                   139\n+# define PKCS7_F_PKCS7_SIGN_ADD_SIGNER                    137\n+# define PKCS7_F_PKCS7_SIMPLE_SMIMECAP                    119\n+# define PKCS7_F_PKCS7_VERIFY                             117\n+# define PKCS7_F_SMIME_READ_PKCS7                         122\n+# define PKCS7_F_SMIME_TEXT                               123\n+\n+/* Reason codes. */\n+# define PKCS7_R_CERTIFICATE_VERIFY_ERROR                 117\n+# define PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER          144\n+# define PKCS7_R_CIPHER_NOT_INITIALIZED                   116\n+# define PKCS7_R_CONTENT_AND_DATA_PRESENT                 118\n+# define PKCS7_R_CTRL_ERROR                               152\n+# define PKCS7_R_DECODE_ERROR                             130\n+# define PKCS7_R_DECRYPTED_KEY_IS_WRONG_LENGTH            100\n+# define PKCS7_R_DECRYPT_ERROR                            119\n+# define PKCS7_R_DIGEST_FAILURE                           101\n+# define PKCS7_R_ENCRYPTION_CTRL_FAILURE                  149\n+# define PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE 150\n+# define PKCS7_R_ERROR_ADDING_RECIPIENT                   120\n+# define PKCS7_R_ERROR_SETTING_CIPHER                     121\n+# define PKCS7_R_INVALID_MIME_TYPE                        131\n+# define PKCS7_R_INVALID_NULL_POINTER                     143\n+# define PKCS7_R_INVALID_SIGNED_DATA_TYPE                 155\n+# define PKCS7_R_MIME_NO_CONTENT_TYPE                     132\n+# define PKCS7_R_MIME_PARSE_ERROR                         133\n+# define PKCS7_R_MIME_SIG_PARSE_ERROR                     134\n+# define PKCS7_R_MISSING_CERIPEND_INFO                    103\n+# define PKCS7_R_NO_CONTENT                               122\n+# define PKCS7_R_NO_CONTENT_TYPE                          135\n+# define PKCS7_R_NO_DEFAULT_DIGEST                        151\n+# define PKCS7_R_NO_MATCHING_DIGEST_TYPE_FOUND            154\n+# define PKCS7_R_NO_MULTIPART_BODY_FAILURE                136\n+# define PKCS7_R_NO_MULTIPART_BOUNDARY                    137\n+# define PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE         115\n+# define PKCS7_R_NO_RECIPIENT_MATCHES_KEY                 146\n+# define PKCS7_R_NO_SIGNATURES_ON_DATA                    123\n+# define PKCS7_R_NO_SIGNERS                               142\n+# define PKCS7_R_NO_SIG_CONTENT_TYPE                      138\n+# define PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE     104\n+# define PKCS7_R_PKCS7_ADD_SIGNATURE_ERROR                124\n+# define PKCS7_R_PKCS7_ADD_SIGNER_ERROR                   153\n+# define PKCS7_R_PKCS7_DATAFINAL                          126\n+# define PKCS7_R_PKCS7_DATAFINAL_ERROR                    125\n+# define PKCS7_R_PKCS7_DATASIGN                           145\n+# define PKCS7_R_PKCS7_PARSE_ERROR                        139\n+# define PKCS7_R_PKCS7_SIG_PARSE_ERROR                    140\n+# define PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE   127\n+# define PKCS7_R_SIGNATURE_FAILURE                        105\n+# define PKCS7_R_SIGNER_CERTIFICATE_NOT_FOUND             128\n+# define PKCS7_R_SIGNING_CTRL_FAILURE                     147\n+# define PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE  148\n+# define PKCS7_R_SIG_INVALID_MIME_TYPE                    141\n+# define PKCS7_R_SMIME_TEXT_ERROR                         129\n+# define PKCS7_R_UNABLE_TO_FIND_CERTIFICATE               106\n+# define PKCS7_R_UNABLE_TO_FIND_MEM_BIO                   107\n+# define PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST            108\n+# define PKCS7_R_UNKNOWN_DIGEST_TYPE                      109\n+# define PKCS7_R_UNKNOWN_OPERATION                        110\n+# define PKCS7_R_UNSUPPORTED_CIPHER_TYPE                  111\n+# define PKCS7_R_UNSUPPORTED_CONTENT_TYPE                 112\n+# define PKCS7_R_WRONG_CONTENT_TYPE                       113\n+# define PKCS7_R_WRONG_PKCS7_TYPE                         114\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif"
        },
        {
            "sha": "d40d9c7d852d640d722691e3cb162f50c64bb96b",
            "filename": "deps/openssl/openssl/include/openssl/pqueue.h",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpqueue.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpqueue.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fpqueue.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279",
            "patch": "@@ -0,0 +1,99 @@\n+/* crypto/pqueue/pqueue.h */\n+/*\n+ * DTLS implementation written by Nagendra Modadugu\n+ * (nagendra@cs.stanford.edu) for the OpenSSL project 2005.\n+ */\n+/* ====================================================================\n+ * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n+ *\n+ * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n+ *    endorse or promote products derived from this software without\n+ *    prior written permission. For written permission, please contact\n+ *    openssl-core@OpenSSL.org.\n+ *\n+ * 5. Products derived from this software may not be called \"OpenSSL\"\n+ *    nor may \"OpenSSL\" appear in their names without prior written\n+ *    permission of the OpenSSL Project.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the OpenSSL Project\n+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This product includes cryptographic software written by Eric Young\n+ * (eay@cryptsoft.com).  This product includes software written by Tim\n+ * Hudson (tjh@cryptsoft.com).\n+ *\n+ */\n+\n+#ifndef HEADER_PQUEUE_H\n+# define HEADER_PQUEUE_H\n+\n+# include <stdio.h>\n+# include <stdlib.h>\n+# include <string.h>\n+\n+#ifdef  __cplusplus\n+extern \"C\" {\n+#endif\n+typedef struct _pqueue *pqueue;\n+\n+typedef struct _pitem {\n+    unsigned char priority[8];  /* 64-bit value in big-endian encoding */\n+    void *data;\n+    struct _pitem *next;\n+} pitem;\n+\n+typedef struct _pitem *piterator;\n+\n+pitem *pitem_new(unsigned char *prio64be, void *data);\n+void pitem_free(pitem *item);\n+\n+pqueue pqueue_new(void);\n+void pqueue_free(pqueue pq);\n+\n+pitem *pqueue_insert(pqueue pq, pitem *item);\n+pitem *pqueue_peek(pqueue pq);\n+pitem *pqueue_pop(pqueue pq);\n+pitem *pqueue_find(pqueue pq, unsigned char *prio64be);\n+pitem *pqueue_iterator(pqueue pq);\n+pitem *pqueue_next(piterator *iter);\n+\n+void pqueue_print(pqueue pq);\n+int pqueue_size(pqueue pq);\n+\n+#ifdef  __cplusplus\n+}\n+#endif\n+#endif                          /* ! HEADER_PQUEUE_H */"
        },
        {
            "sha": "2553afda200176bb3a0eedc02a1a89f8a48adf04",
            "filename": "deps/openssl/openssl/include/openssl/rand.h",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frand.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frand.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frand.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "29d02d7322e7ef4654e2ec998ed988a69f057abd",
            "filename": "deps/openssl/openssl/include/openssl/rc2.h",
            "status": "added",
            "additions": 103,
            "deletions": 0,
            "changes": 103,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frc2.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frc2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frc2.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "39162b1648d864890fb74706ecf1d23174eaa21b",
            "filename": "deps/openssl/openssl/include/openssl/rc4.h",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frc4.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frc4.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frc4.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "b88ef25e724bcf41414622d632d13e3f6b2439df",
            "filename": "deps/openssl/openssl/include/openssl/ripemd.h",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fripemd.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fripemd.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fripemd.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "d2ee37406e3cc33fc10353e293a4b40849ed8f43",
            "filename": "deps/openssl/openssl/include/openssl/rsa.h",
            "status": "added",
            "additions": 664,
            "deletions": 0,
            "changes": 664,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frsa.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frsa.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Frsa.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "1d4f87eab34dcbdb9163ec28c9bba9b7b06c442c",
            "filename": "deps/openssl/openssl/include/openssl/safestack.h",
            "status": "added",
            "additions": 2672,
            "deletions": 0,
            "changes": 2672,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsafestack.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsafestack.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsafestack.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "8cbf0d9281b0b6b315b59c13d3c160a2bf3c9df8",
            "filename": "deps/openssl/openssl/include/openssl/seed.h",
            "status": "added",
            "additions": 149,
            "deletions": 0,
            "changes": 149,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fseed.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fseed.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fseed.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "e5169e4fee047745985b245cbf52642282648bbf",
            "filename": "deps/openssl/openssl/include/openssl/sha.h",
            "status": "added",
            "additions": 214,
            "deletions": 0,
            "changes": 214,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsha.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsha.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsha.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "028892a1ff5e04ff19e0b0e3406b332390b25c2a",
            "filename": "deps/openssl/openssl/include/openssl/srp.h",
            "status": "added",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsrp.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsrp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsrp.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "2279c32b895ac23085e8f130abf27a3a01bced82",
            "filename": "deps/openssl/openssl/include/openssl/srtp.h",
            "status": "added",
            "additions": 147,
            "deletions": 0,
            "changes": 147,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsrtp.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsrtp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsrtp.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "3cf96a239bab448cb58d838f1d699604ec5010a3",
            "filename": "deps/openssl/openssl/include/openssl/ssl.h",
            "status": "added",
            "additions": 3163,
            "deletions": 0,
            "changes": 3163,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "03c7dd8cac1881ecff15bde4dcd378e5cb49109a",
            "filename": "deps/openssl/openssl/include/openssl/ssl2.h",
            "status": "added",
            "additions": 265,
            "deletions": 0,
            "changes": 265,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl2.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl2.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "9de4685af9e09e97575d8c561ab0524cbe43d982",
            "filename": "deps/openssl/openssl/include/openssl/ssl23.h",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl23.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl23.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl23.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "e681d50a9e8643f13ba16d31c6907664bf804af8",
            "filename": "deps/openssl/openssl/include/openssl/ssl3.h",
            "status": "added",
            "additions": 774,
            "deletions": 0,
            "changes": 774,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl3.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl3.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fssl3.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "eb07216659d0f3f92b7c0f73734e903351d77408",
            "filename": "deps/openssl/openssl/include/openssl/stack.h",
            "status": "added",
            "additions": 107,
            "deletions": 0,
            "changes": 107,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fstack.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fstack.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fstack.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "3001957988f7d5ad7b3ab193c43656f50b225702",
            "filename": "deps/openssl/openssl/include/openssl/symhacks.h",
            "status": "added",
            "additions": 518,
            "deletions": 0,
            "changes": 518,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsymhacks.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsymhacks.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fsymhacks.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "dd1d8c109ee54d2592ab2246783bad9169a00d12",
            "filename": "deps/openssl/openssl/include/openssl/tls1.h",
            "status": "added",
            "additions": 810,
            "deletions": 0,
            "changes": 810,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Ftls1.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Ftls1.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Ftls1.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "2daa1b2fb5940e4d2806b5b3cd9bf0fb3170790d",
            "filename": "deps/openssl/openssl/include/openssl/ts.h",
            "status": "added",
            "additions": 865,
            "deletions": 0,
            "changes": 865,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fts.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fts.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fts.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "98e23a2003c9800dc5b82c7dad3b0d416a9b4514",
            "filename": "deps/openssl/openssl/include/openssl/txt_db.h",
            "status": "added",
            "additions": 112,
            "deletions": 0,
            "changes": 112,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Ftxt_db.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Ftxt_db.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Ftxt_db.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "0dc16330b8708a7977e763b8d8562792562b615b",
            "filename": "deps/openssl/openssl/include/openssl/ui.h",
            "status": "added",
            "additions": 415,
            "deletions": 0,
            "changes": 415,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fui.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fui.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fui.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "bf541542c0411250db9d658e3257685866ee3d54",
            "filename": "deps/openssl/openssl/include/openssl/ui_compat.h",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fui_compat.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fui_compat.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fui_compat.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "73c749da8151faf0dee98e57080a7161fd704c3e",
            "filename": "deps/openssl/openssl/include/openssl/whrlpool.h",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fwhrlpool.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fwhrlpool.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fwhrlpool.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "6fa28ebada465b295a2945e244dc7496e861dea9",
            "filename": "deps/openssl/openssl/include/openssl/x509.h",
            "status": "added",
            "additions": 1330,
            "deletions": 0,
            "changes": 1330,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fx509.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fx509.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fx509.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "50626826e0b9e0b65146d127a81c8725f916304e",
            "filename": "deps/openssl/openssl/include/openssl/x509_vfy.h",
            "status": "added",
            "additions": 652,
            "deletions": 0,
            "changes": 652,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fx509_vfy.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fx509_vfy.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fx509_vfy.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        },
        {
            "sha": "f5c61560aa10bad9bfe9dddaab3c88786346938f",
            "filename": "deps/openssl/openssl/include/openssl/x509v3.h",
            "status": "added",
            "additions": 1055,
            "deletions": 0,
            "changes": 1055,
            "blob_url": "https://github.com/nodejs/node/blob/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fx509v3.h",
            "raw_url": "https://github.com/nodejs/node/raw/a5bd474573d411eb5346eabdeba40c729dc21279/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fx509v3.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Finclude%2Fopenssl%2Fx509v3.h?ref=a5bd474573d411eb5346eabdeba40c729dc21279"
        }
    ],
    "stats": {
        "total": 38787,
        "additions": 38522,
        "deletions": 265
    }
}