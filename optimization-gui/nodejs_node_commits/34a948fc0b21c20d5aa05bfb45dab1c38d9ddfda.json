{
    "author": "addaleax",
    "message": "lib: document nextTick queue internals\n\nMake this code (a bit more) comprehensible by adding some\ninternals docs.\n\nWith diagrams and everything! ðŸŽ‰\n\nPR-URL: https://github.com/nodejs/node/pull/19469\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Weijia Wang <starkwang@126.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Tobias NieÃŸen <tniessen@tnie.de>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "34a948fc0b21c20d5aa05bfb45dab1c38d9ddfda",
    "files": [
        {
            "sha": "7a5d2f88a6d17e1e828be9418d7c670fe281a8a4",
            "filename": "lib/internal/process/next_tick.js",
            "status": "modified",
            "additions": 73,
            "deletions": 9,
            "changes": 82,
            "blob_url": "https://github.com/nodejs/node/blob/34a948fc0b21c20d5aa05bfb45dab1c38d9ddfda/lib%2Finternal%2Fprocess%2Fnext_tick.js",
            "raw_url": "https://github.com/nodejs/node/raw/34a948fc0b21c20d5aa05bfb45dab1c38d9ddfda/lib%2Finternal%2Fprocess%2Fnext_tick.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fnext_tick.js?ref=34a948fc0b21c20d5aa05bfb45dab1c38d9ddfda",
            "patch": "@@ -31,10 +31,60 @@ function setupNextTick() {\n   const kHasScheduled = 0;\n   const kHasPromiseRejections = 1;\n \n-  // Queue size for each tick array. Must be a factor of two.\n+  // Queue size for each tick array. Must be a power of two.\n   const kQueueSize = 2048;\n   const kQueueMask = kQueueSize - 1;\n \n+  // The next tick queue is implemented as a singly-linked list of fixed-size\n+  // circular buffers. It looks something like this:\n+  //\n+  //  head                                                       tail\n+  //    |                                                          |\n+  //    v                                                          v\n+  // +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n+  // |  [null]   |        \\----- |   next    |         \\------- |   next    |\n+  // +-----------+               +-----------+                  +-----------+\n+  // |   tick    | <-- bottom    |   tick    | <-- bottom       |  [empty]  |\n+  // |   tick    |               |   tick    |                  |  [empty]  |\n+  // |   tick    |               |   tick    |                  |  [empty]  |\n+  // |   tick    |               |   tick    |                  |  [empty]  |\n+  // |   tick    |               |   tick    |       bottom --> |   tick    |\n+  // |   tick    |               |   tick    |                  |   tick    |\n+  // |    ...    |               |    ...    |                  |    ...    |\n+  // |   tick    |               |   tick    |                  |   tick    |\n+  // |   tick    |               |   tick    |                  |   tick    |\n+  // |  [empty]  | <-- top       |   tick    |                  |   tick    |\n+  // |  [empty]  |               |   tick    |                  |   tick    |\n+  // |  [empty]  |               |   tick    |                  |   tick    |\n+  // +-----------+               +-----------+ <-- top  top --> +-----------+\n+  //\n+  // Or, if there is only one fixed-size queue, it looks something\n+  // like either of these:\n+  //\n+  //  head   tail                                 head   tail\n+  //    |     |                                     |     |\n+  //    v     v                                     v     v\n+  // +-----------+                               +-----------+\n+  // |  [null]   |                               |  [null]   |\n+  // +-----------+                               +-----------+\n+  // |  [empty]  |                               |   tick    |\n+  // |  [empty]  |                               |   tick    |\n+  // |   tick    | <-- bottom            top --> |  [empty]  |\n+  // |   tick    |                               |  [empty]  |\n+  // |  [empty]  | <-- top            bottom --> |   tick    |\n+  // |  [empty]  |                               |   tick    |\n+  // +-----------+                               +-----------+\n+  //\n+  // Adding a value means moving `top` forward by one, removing means\n+  // moving `bottom` forward by one.\n+  //\n+  // We let `bottom` and `top` wrap around, so when `top` is conceptually\n+  // pointing to the end of the list, that means that the actual value is `0`.\n+  //\n+  // In particular, when `top === bottom`, this can mean *either* that the\n+  // current queue is empty or that it is full. We can differentiate by\n+  // checking whether an entry in the queue is empty (a.k.a. `=== undefined`).\n+\n   class FixedQueue {\n     constructor() {\n       this.bottom = 0;\n@@ -49,11 +99,12 @@ function setupNextTick() {\n     }\n \n     shift() {\n-      const next = this.list[this.bottom];\n-      if (next === undefined) return null;\n+      const nextItem = this.list[this.bottom];\n+      if (nextItem === undefined)\n+        return null;\n       this.list[this.bottom] = undefined;\n       this.bottom = (this.bottom + 1) & kQueueMask;\n-      return next;\n+      return nextItem;\n     }\n   }\n \n@@ -62,21 +113,34 @@ function setupNextTick() {\n \n   function push(data) {\n     if (head.bottom === head.top) {\n-      if (head.list[head.top] !== undefined)\n+      // Either empty or full:\n+      if (head.list[head.top] !== undefined) {\n+        // It's full: Creates a new queue, sets the old queue's `.next` to it,\n+        // and sets it as the new main queue.\n         head = head.next = new FixedQueue();\n-      else\n+      } else {\n+        // If the head is empty, that means that it was the only fixed-sized\n+        // queue in existence.\n+        DCHECK_EQ(head.next, null);\n+        // This is the first tick object in existence, so we need to inform\n+        // the C++ side that we do want to run `_tickCallback()`.\n         tickInfo[kHasScheduled] = 1;\n+      }\n     }\n     head.push(data);\n   }\n \n   function shift() {\n     const next = tail.shift();\n-    if (tail.top === tail.bottom) {\n-      if (tail.next)\n+    if (tail.top === tail.bottom) { // -> .shift() emptied the current queue.\n+      if (tail.next !== null) {\n+        // If there is another queue, it forms the new tail.\n         tail = tail.next;\n-      else\n+      } else {\n+        // We've just run out of items. Let the native side know that it\n+        // doesn't need to bother calling into JS to run the queue.\n         tickInfo[kHasScheduled] = 0;\n+      }\n     }\n     return next;\n   }"
        }
    ],
    "stats": {
        "total": 82,
        "additions": 73,
        "deletions": 9
    }
}