{
    "author": "ryzokuken",
    "message": "src: rework (mostly internal) functions to use Maybes\n\nRework all affected functions to use Maybes, thus improving error\nhandling substantially in internal functions, API functions as well as\nutilities.\n\nCo-authored-by: MichaÃ«l Zasso <targos@protonmail.com>\nPR-URL: https://github.com/nodejs/node/pull/21935\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
    "files": [
        {
            "sha": "d2cb79d4145e7cef20a900fec5f920aa0fc51b1d",
            "filename": "src/node_buffer.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fnode_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fnode_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.cc?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -236,7 +236,9 @@ MaybeLocal<Object> New(Isolate* isolate,\n                        enum encoding enc) {\n   EscapableHandleScope scope(isolate);\n \n-  const size_t length = StringBytes::Size(isolate, string, enc);\n+  size_t length;\n+  if (!StringBytes::Size(isolate, string, enc).To(&length))\n+    return Local<Object>();\n   size_t actual = 0;\n   char* data = nullptr;\n \n@@ -828,7 +830,8 @@ void IndexOfString(const FunctionCallbackInfo<Value>& args) {\n   const size_t haystack_length = (enc == UCS2) ?\n       ts_obj_length &~ 1 : ts_obj_length;  // NOLINT(whitespace/operators)\n \n-  const size_t needle_length = StringBytes::Size(isolate, needle, enc);\n+  size_t needle_length;\n+  if (!StringBytes::Size(isolate, needle, enc).To(&needle_length)) return;\n \n   int64_t opt_offset = IndexOfOffset(haystack_length,\n                                      offset_i64,\n@@ -868,7 +871,7 @@ void IndexOfString(const FunctionCallbackInfo<Value>& args) {\n \n     if (IsBigEndian()) {\n       StringBytes::InlineDecoder decoder;\n-      decoder.Decode(env, needle, args[3], UCS2);\n+      if (decoder.Decode(env, needle, args[3], UCS2).IsNothing()) return;\n       const uint16_t* decoded_string =\n           reinterpret_cast<const uint16_t*>(decoder.out());\n "
        },
        {
            "sha": "8f774405306be66c8c704f5bd00aefa44c0bb0b0",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -3059,7 +3059,8 @@ void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {\n   // Only copy the data if we have to, because it's a string\n   if (args[0]->IsString()) {\n     StringBytes::InlineDecoder decoder;\n-    if (!decoder.Decode(env, args[0].As<String>(), args[1], UTF8))\n+    if (!decoder.Decode(env, args[0].As<String>(), args[1], UTF8)\n+             .FromMaybe(false))\n       return;\n     r = cipher->Update(decoder.out(), decoder.size(), &out, &out_len);\n   } else {\n@@ -3249,7 +3250,8 @@ void Hmac::HmacUpdate(const FunctionCallbackInfo<Value>& args) {\n   bool r = false;\n   if (args[0]->IsString()) {\n     StringBytes::InlineDecoder decoder;\n-    if (decoder.Decode(env, args[0].As<String>(), args[1], UTF8)) {\n+    if (decoder.Decode(env, args[0].As<String>(), args[1], UTF8)\n+            .FromMaybe(false)) {\n       r = hmac->HmacUpdate(decoder.out(), decoder.size());\n     }\n   } else {\n@@ -3356,7 +3358,8 @@ void Hash::HashUpdate(const FunctionCallbackInfo<Value>& args) {\n   bool r = true;\n   if (args[0]->IsString()) {\n     StringBytes::InlineDecoder decoder;\n-    if (!decoder.Decode(env, args[0].As<String>(), args[1], UTF8)) {\n+    if (!decoder.Decode(env, args[0].As<String>(), args[1], UTF8)\n+             .FromMaybe(false)) {\n       args.GetReturnValue().Set(false);\n       return;\n     }"
        },
        {
            "sha": "21d327509727a235610c147bd0f64fa923023533",
            "filename": "src/node_encoding.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fnode_encoding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fnode_encoding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_encoding.cc?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -121,7 +121,7 @@ ssize_t DecodeBytes(Isolate* isolate,\n                     enum encoding encoding) {\n   HandleScope scope(isolate);\n \n-  return StringBytes::Size(isolate, val, encoding);\n+  return StringBytes::Size(isolate, val, encoding).FromMaybe(-1);\n }\n \n // Returns number of bytes written."
        },
        {
            "sha": "4299945bbb8e986359a4ad77b8d6b645929e5239",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -1819,7 +1819,7 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n \n   if (is_async) {  // write(fd, string, pos, enc, req)\n     CHECK_NOT_NULL(req_wrap_async);\n-    len = StringBytes::StorageSize(env->isolate(), value, enc);\n+    if (!StringBytes::StorageSize(env->isolate(), value, enc).To(&len)) return;\n     FSReqBase::FSReqBuffer& stack_buffer =\n         req_wrap_async->Init(\"write\", len, enc);\n     // StorageSize may return too large a char, so correct the actual length\n@@ -1847,7 +1847,8 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n     FSReqWrapSync req_wrap_sync;\n     FSReqBase::FSReqBuffer stack_buffer;\n     if (buf == nullptr) {\n-      len = StringBytes::StorageSize(env->isolate(), value, enc);\n+      if (!StringBytes::StorageSize(env->isolate(), value, enc).To(&len))\n+        return;\n       stack_buffer.AllocateSufficientStorage(len + 1);\n       // StorageSize may return too large a char, so correct the actual length\n       // by the write size"
        },
        {
            "sha": "77449b9569d9cd77a95828120f82c238dfd18b45",
            "filename": "src/spawn_sync.cc",
            "status": "modified",
            "additions": 71,
            "deletions": 54,
            "changes": 125,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fspawn_sync.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fspawn_sync.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fspawn_sync.cc?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -37,7 +37,11 @@ using v8::FunctionCallbackInfo;\n using v8::HandleScope;\n using v8::Integer;\n using v8::Isolate;\n+using v8::Just;\n using v8::Local;\n+using v8::Maybe;\n+using v8::MaybeLocal;\n+using v8::Nothing;\n using v8::Null;\n using v8::Number;\n using v8::Object;\n@@ -372,7 +376,8 @@ void SyncProcessRunner::Spawn(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   env->PrintSyncTrace();\n   SyncProcessRunner p(env);\n-  Local<Value> result = p.Run(args[0]);\n+  Local<Value> result;\n+  if (!p.Run(args[0]).ToLocal(&result)) return;\n   args.GetReturnValue().Set(result);\n }\n \n@@ -430,22 +435,21 @@ Environment* SyncProcessRunner::env() const {\n   return env_;\n }\n \n-\n-Local<Object> SyncProcessRunner::Run(Local<Value> options) {\n+MaybeLocal<Object> SyncProcessRunner::Run(Local<Value> options) {\n   EscapableHandleScope scope(env()->isolate());\n \n   CHECK_EQ(lifecycle_, kUninitialized);\n \n-  TryInitializeAndRunLoop(options);\n+  Maybe<bool> r = TryInitializeAndRunLoop(options);\n   CloseHandlesAndDeleteLoop();\n+  if (r.IsNothing()) return MaybeLocal<Object>();\n \n   Local<Object> result = BuildResultObject();\n \n   return scope.Escape(result);\n }\n \n-\n-void SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) {\n+Maybe<bool> SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) {\n   int r;\n \n   // There is no recovery from failure inside TryInitializeAndRunLoop - the\n@@ -454,18 +458,24 @@ void SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) {\n   lifecycle_ = kInitialized;\n \n   uv_loop_ = new uv_loop_t;\n-  if (uv_loop_ == nullptr)\n-    return SetError(UV_ENOMEM);\n+  if (uv_loop_ == nullptr) {\n+    SetError(UV_ENOMEM);\n+    return Just(false);\n+  }\n   CHECK_EQ(uv_loop_init(uv_loop_), 0);\n \n-  r = ParseOptions(options);\n-  if (r < 0)\n-    return SetError(r);\n+  if (!ParseOptions(options).To(&r)) return Nothing<bool>();\n+  if (r < 0) {\n+    SetError(r);\n+    return Just(false);\n+  }\n \n   if (timeout_ > 0) {\n     r = uv_timer_init(uv_loop_, &uv_timer_);\n-    if (r < 0)\n-      return SetError(r);\n+    if (r < 0) {\n+      SetError(r);\n+      return Just(false);\n+    }\n \n     uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));\n \n@@ -477,22 +487,28 @@ void SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) {\n     // which implicitly stops it, so there is no risk that the timeout callback\n     // runs when the process didn't start.\n     r = uv_timer_start(&uv_timer_, KillTimerCallback, timeout_, 0);\n-    if (r < 0)\n-      return SetError(r);\n+    if (r < 0) {\n+      SetError(r);\n+      return Just(false);\n+    }\n   }\n \n   uv_process_options_.exit_cb = ExitCallback;\n   r = uv_spawn(uv_loop_, &uv_process_, &uv_process_options_);\n-  if (r < 0)\n-    return SetError(r);\n+  if (r < 0) {\n+    SetError(r);\n+    return Just(false);\n+  }\n   uv_process_.data = this;\n \n   for (uint32_t i = 0; i < stdio_count_; i++) {\n     SyncProcessStdioPipe* h = stdio_pipes_[i].get();\n     if (h != nullptr) {\n       r = h->Start();\n-      if (r < 0)\n-        return SetPipeError(r);\n+      if (r < 0) {\n+        SetPipeError(r);\n+        return Just(false);\n+      }\n     }\n   }\n \n@@ -503,6 +519,7 @@ void SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) {\n \n   // If we get here the process should have exited.\n   CHECK_GE(exit_status_, 0);\n+  return Just(true);\n }\n \n \n@@ -724,46 +741,41 @@ Local<Array> SyncProcessRunner::BuildOutputArray() {\n   return scope.Escape(js_output);\n }\n \n-\n-int SyncProcessRunner::ParseOptions(Local<Value> js_value) {\n+Maybe<int> SyncProcessRunner::ParseOptions(Local<Value> js_value) {\n   HandleScope scope(env()->isolate());\n   int r;\n \n-  if (!js_value->IsObject())\n-    return UV_EINVAL;\n+  if (!js_value->IsObject()) return Just<int>(UV_EINVAL);\n \n   Local<Context> context = env()->context();\n   Local<Object> js_options = js_value.As<Object>();\n \n   Local<Value> js_file =\n       js_options->Get(context, env()->file_string()).ToLocalChecked();\n-  r = CopyJsString(js_file, &file_buffer_);\n-  if (r < 0)\n-    return r;\n+  if (!CopyJsString(js_file, &file_buffer_).To(&r)) return Nothing<int>();\n+  if (r < 0) return Just(r);\n   uv_process_options_.file = file_buffer_;\n \n   Local<Value> js_args =\n       js_options->Get(context, env()->args_string()).ToLocalChecked();\n-  r = CopyJsStringArray(js_args, &args_buffer_);\n-  if (r < 0)\n-    return r;\n+  if (!CopyJsStringArray(js_args, &args_buffer_).To(&r)) return Nothing<int>();\n+  if (r < 0) return Just(r);\n   uv_process_options_.args = reinterpret_cast<char**>(args_buffer_);\n \n   Local<Value> js_cwd =\n       js_options->Get(context, env()->cwd_string()).ToLocalChecked();\n   if (IsSet(js_cwd)) {\n-    r = CopyJsString(js_cwd, &cwd_buffer_);\n-    if (r < 0)\n-      return r;\n+    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) return Nothing<int>();\n+    if (r < 0) return Just(r);\n     uv_process_options_.cwd = cwd_buffer_;\n   }\n \n   Local<Value> js_env_pairs =\n       js_options->Get(context, env()->env_pairs_string()).ToLocalChecked();\n   if (IsSet(js_env_pairs)) {\n-    r = CopyJsStringArray(js_env_pairs, &env_buffer_);\n-    if (r < 0)\n-      return r;\n+    if (!CopyJsStringArray(js_env_pairs, &env_buffer_).To(&r))\n+      return Nothing<int>();\n+    if (r < 0) return Just(r);\n \n     uv_process_options_.env = reinterpret_cast<char**>(env_buffer_);\n   }\n@@ -827,10 +839,9 @@ int SyncProcessRunner::ParseOptions(Local<Value> js_value) {\n   Local<Value> js_stdio =\n       js_options->Get(context, env()->stdio_string()).ToLocalChecked();\n   r = ParseStdioOptions(js_stdio);\n-  if (r < 0)\n-    return r;\n+  if (r < 0) return Just(r);\n \n-  return 0;\n+  return Just(0);\n }\n \n \n@@ -970,44 +981,43 @@ bool SyncProcessRunner::IsSet(Local<Value> value) {\n   return !value->IsUndefined() && !value->IsNull();\n }\n \n-\n-int SyncProcessRunner::CopyJsString(Local<Value> js_value,\n-                                    const char** target) {\n+Maybe<int> SyncProcessRunner::CopyJsString(Local<Value> js_value,\n+                                           const char** target) {\n   Isolate* isolate = env()->isolate();\n   Local<String> js_string;\n   size_t size, written;\n   char* buffer;\n \n   if (js_value->IsString())\n     js_string = js_value.As<String>();\n-  else\n-    js_string = js_value->ToString(env()->isolate()->GetCurrentContext())\n-                    .ToLocalChecked();\n+  else if (!js_value->ToString(env()->isolate()->GetCurrentContext())\n+                .ToLocal(&js_string))\n+    return Nothing<int>();\n \n   // Include space for null terminator byte.\n-  size = StringBytes::StorageSize(isolate, js_string, UTF8) + 1;\n+  if (!StringBytes::StorageSize(isolate, js_string, UTF8).To(&size))\n+    return Nothing<int>();\n+  size += 1;\n \n   buffer = new char[size];\n \n   written = StringBytes::Write(isolate, buffer, -1, js_string, UTF8);\n   buffer[written] = '\\0';\n \n   *target = buffer;\n-  return 0;\n+  return Just(0);\n }\n \n-\n-int SyncProcessRunner::CopyJsStringArray(Local<Value> js_value,\n-                                         char** target) {\n+Maybe<int> SyncProcessRunner::CopyJsStringArray(Local<Value> js_value,\n+                                                char** target) {\n   Isolate* isolate = env()->isolate();\n   Local<Array> js_array;\n   uint32_t length;\n   size_t list_size, data_size, data_offset;\n   char** list;\n   char* buffer;\n \n-  if (!js_value->IsArray())\n-    return UV_EINVAL;\n+  if (!js_value->IsArray()) return Just<int>(UV_EINVAL);\n \n   Local<Context> context = env()->context();\n   js_array = js_value.As<Array>()->Clone().As<Array>();\n@@ -1025,15 +1035,22 @@ int SyncProcessRunner::CopyJsStringArray(Local<Value> js_value,\n   for (uint32_t i = 0; i < length; i++) {\n     auto value = js_array->Get(context, i).ToLocalChecked();\n \n-    if (!value->IsString())\n+    if (!value->IsString()) {\n+      Local<String> string;\n+      if (!value->ToString(env()->isolate()->GetCurrentContext())\n+               .ToLocal(&string))\n+        return Nothing<int>();\n       js_array\n           ->Set(context,\n                 i,\n                 value->ToString(env()->isolate()->GetCurrentContext())\n                     .ToLocalChecked())\n           .FromJust();\n+    }\n \n-    data_size += StringBytes::StorageSize(isolate, value, UTF8) + 1;\n+    Maybe<size_t> maybe_size = StringBytes::StorageSize(isolate, value, UTF8);\n+    if (maybe_size.IsNothing()) return Nothing<int>();\n+    data_size += maybe_size.FromJust() + 1;\n     data_size = ROUND_UP(data_size, sizeof(void*));\n   }\n \n@@ -1057,7 +1074,7 @@ int SyncProcessRunner::CopyJsStringArray(Local<Value> js_value,\n   list[length] = nullptr;\n \n   *target = buffer;\n-  return 0;\n+  return Just(0);\n }\n \n "
        },
        {
            "sha": "adb2618cc5f404f39abdb1d4f181795563a4e9c7",
            "filename": "src/spawn_sync.h",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fspawn_sync.h",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fspawn_sync.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fspawn_sync.h?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -152,8 +152,8 @@ class SyncProcessRunner {\n \n   inline Environment* env() const;\n \n-  v8::Local<v8::Object> Run(v8::Local<v8::Value> options);\n-  void TryInitializeAndRunLoop(v8::Local<v8::Value> options);\n+  v8::MaybeLocal<v8::Object> Run(v8::Local<v8::Value> options);\n+  v8::Maybe<bool> TryInitializeAndRunLoop(v8::Local<v8::Value> options);\n   void CloseHandlesAndDeleteLoop();\n \n   void CloseStdioPipes();\n@@ -172,7 +172,7 @@ class SyncProcessRunner {\n   v8::Local<v8::Object> BuildResultObject();\n   v8::Local<v8::Array> BuildOutputArray();\n \n-  int ParseOptions(v8::Local<v8::Value> js_value);\n+  v8::Maybe<int> ParseOptions(v8::Local<v8::Value> js_value);\n   int ParseStdioOptions(v8::Local<v8::Value> js_value);\n   int ParseStdioOption(int child_fd, v8::Local<v8::Object> js_stdio_option);\n \n@@ -184,8 +184,10 @@ class SyncProcessRunner {\n   inline int AddStdioInheritFD(uint32_t child_fd, int inherit_fd);\n \n   static bool IsSet(v8::Local<v8::Value> value);\n-  int CopyJsString(v8::Local<v8::Value> js_value, const char** target);\n-  int CopyJsStringArray(v8::Local<v8::Value> js_value, char** target);\n+  v8::Maybe<int> CopyJsString(v8::Local<v8::Value> js_value,\n+                              const char** target);\n+  v8::Maybe<int> CopyJsStringArray(v8::Local<v8::Value> js_value,\n+                                   char** target);\n \n   static void ExitCallback(uv_process_t* handle,\n                            int64_t exit_status,"
        },
        {
            "sha": "f429f3593fd5f4272377f673db78efd53386c4e2",
            "filename": "src/stream_base.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 9,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fstream_base.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fstream_base.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.cc?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -108,11 +108,12 @@ int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {\n       enum encoding encoding = ParseEncoding(env->isolate(),\n                                              chunks->Get(i * 2 + 1));\n       size_t chunk_size;\n-      if (encoding == UTF8 && string->Length() > 65535)\n-        chunk_size = StringBytes::Size(env->isolate(), string, encoding);\n-      else\n-        chunk_size = StringBytes::StorageSize(env->isolate(), string, encoding);\n-\n+      if (encoding == UTF8 && string->Length() > 65535 &&\n+          !StringBytes::Size(env->isolate(), string, encoding).To(&chunk_size))\n+        return 0;\n+      else if (!StringBytes::StorageSize(env->isolate(), string, encoding)\n+                    .To(&chunk_size))\n+        return 0;\n       storage_size += chunk_size;\n     }\n \n@@ -214,10 +215,12 @@ int StreamBase::WriteString(const FunctionCallbackInfo<Value>& args) {\n   // For UTF8 strings that are very long, go ahead and take the hit for\n   // computing their actual size, rather than tripling the storage.\n   size_t storage_size;\n-  if (enc == UTF8 && string->Length() > 65535)\n-    storage_size = StringBytes::Size(env->isolate(), string, enc);\n-  else\n-    storage_size = StringBytes::StorageSize(env->isolate(), string, enc);\n+  if (enc == UTF8 && string->Length() > 65535 &&\n+      !StringBytes::Size(env->isolate(), string, enc).To(&storage_size))\n+    return 0;\n+  else if (!StringBytes::StorageSize(env->isolate(), string, enc)\n+                .To(&storage_size))\n+    return 0;\n \n   if (storage_size > INT_MAX)\n     return UV_ENOBUFS;"
        },
        {
            "sha": "c38f368d41878ed103f591db16c8e03e2253d7c2",
            "filename": "src/string_bytes.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 19,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fstring_bytes.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fstring_bytes.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_bytes.cc?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -41,8 +41,11 @@ namespace node {\n \n using v8::HandleScope;\n using v8::Isolate;\n+using v8::Just;\n using v8::Local;\n+using v8::Maybe;\n using v8::MaybeLocal;\n+using v8::Nothing;\n using v8::String;\n using v8::Value;\n \n@@ -399,19 +402,20 @@ bool StringBytes::IsValidString(Local<String> string,\n // Quick and dirty size calculation\n // Will always be at least big enough, but may have some extra\n // UTF8 can be as much as 3x the size, Base64 can have 1-2 extra bytes\n-size_t StringBytes::StorageSize(Isolate* isolate,\n-                                Local<Value> val,\n-                                enum encoding encoding) {\n+Maybe<size_t> StringBytes::StorageSize(Isolate* isolate,\n+                                       Local<Value> val,\n+                                       enum encoding encoding) {\n   HandleScope scope(isolate);\n   size_t data_size = 0;\n   bool is_buffer = Buffer::HasInstance(val);\n \n   if (is_buffer && (encoding == BUFFER || encoding == LATIN1)) {\n-    return Buffer::Length(val);\n+    return Just(Buffer::Length(val));\n   }\n \n-  Local<String> str =\n-      val->ToString(isolate->GetCurrentContext()).ToLocalChecked();\n+  Local<String> str;\n+  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))\n+    return Nothing<size_t>();\n \n   switch (encoding) {\n     case ASCII:\n@@ -445,40 +449,40 @@ size_t StringBytes::StorageSize(Isolate* isolate,\n       break;\n   }\n \n-  return data_size;\n+  return Just(data_size);\n }\n \n-\n-size_t StringBytes::Size(Isolate* isolate,\n-                         Local<Value> val,\n-                         enum encoding encoding) {\n+Maybe<size_t> StringBytes::Size(Isolate* isolate,\n+                                Local<Value> val,\n+                                enum encoding encoding) {\n   HandleScope scope(isolate);\n \n   if (Buffer::HasInstance(val) && (encoding == BUFFER || encoding == LATIN1))\n-    return Buffer::Length(val);\n+    return Just(Buffer::Length(val));\n \n-  Local<String> str =\n-      val->ToString(isolate->GetCurrentContext()).ToLocalChecked();\n+  Local<String> str;\n+  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))\n+    return Nothing<size_t>();\n \n   switch (encoding) {\n     case ASCII:\n     case LATIN1:\n-      return str->Length();\n+      return Just<size_t>(str->Length());\n \n     case BUFFER:\n     case UTF8:\n-      return str->Utf8Length(isolate);\n+      return Just<size_t>(str->Utf8Length(isolate));\n \n     case UCS2:\n-      return str->Length() * sizeof(uint16_t);\n+      return Just(str->Length() * sizeof(uint16_t));\n \n     case BASE64: {\n       String::Value value(isolate, str);\n-      return base64_decoded_size(*value, value.length());\n+      return Just(base64_decoded_size(*value, value.length()));\n     }\n \n     case HEX:\n-      return str->Length() / 2;\n+      return Just<size_t>(str->Length() / 2);\n   }\n \n   UNREACHABLE();"
        },
        {
            "sha": "8280e37987755c87dec8d72246daec8d1d7a7b4c",
            "filename": "src/string_bytes.h",
            "status": "modified",
            "additions": 17,
            "deletions": 20,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fstring_bytes.h",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Fstring_bytes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_bytes.h?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -35,29 +35,26 @@ class StringBytes {\n  public:\n   class InlineDecoder : public MaybeStackBuffer<char> {\n    public:\n-    inline bool Decode(Environment* env,\n-                       v8::Local<v8::String> string,\n-                       v8::Local<v8::Value> encoding,\n-                       enum encoding _default) {\n+    inline v8::Maybe<bool> Decode(Environment* env,\n+                                  v8::Local<v8::String> string,\n+                                  v8::Local<v8::Value> encoding,\n+                                  enum encoding _default) {\n       enum encoding enc = ParseEncoding(env->isolate(), encoding, _default);\n       if (!StringBytes::IsValidString(string, enc)) {\n         env->ThrowTypeError(\"Bad input string\");\n-        return false;\n+        return v8::Just(false);\n       }\n \n-      const size_t storage = StringBytes::StorageSize(env->isolate(),\n-                                                      string,\n-                                                      enc);\n+      size_t storage;\n+      if (!StringBytes::StorageSize(env->isolate(), string, enc).To(&storage))\n+        return v8::Nothing<bool>();\n       AllocateSufficientStorage(storage);\n-      const size_t length = StringBytes::Write(env->isolate(),\n-                                               out(),\n-                                               storage,\n-                                               string,\n-                                               enc);\n+      const size_t length =\n+          StringBytes::Write(env->isolate(), out(), storage, string, enc);\n \n       // No zero terminator is included when using this method.\n       SetLength(length);\n-      return true;\n+      return v8::Just(true);\n     }\n \n     inline size_t size() const { return length(); }\n@@ -71,15 +68,15 @@ class StringBytes {\n \n   // Fast, but can be 2 bytes oversized for Base64, and\n   // as much as triple UTF-8 strings <= 65536 chars in length\n-  static size_t StorageSize(v8::Isolate* isolate,\n-                            v8::Local<v8::Value> val,\n-                            enum encoding enc);\n+  static v8::Maybe<size_t> StorageSize(v8::Isolate* isolate,\n+                                       v8::Local<v8::Value> val,\n+                                       enum encoding enc);\n \n   // Precise byte count, but slightly slower for Base64 and\n   // very much slower for UTF-8\n-  static size_t Size(v8::Isolate* isolate,\n-                     v8::Local<v8::Value> val,\n-                     enum encoding enc);\n+  static v8::Maybe<size_t> Size(v8::Isolate* isolate,\n+                                v8::Local<v8::Value> val,\n+                                enum encoding enc);\n \n   // Write the bytes from the string or buffer into the char*\n   // returns the number of bytes written, which will always be"
        },
        {
            "sha": "a0f0b0bf89657df0db9563aab1e60d8bc881f145",
            "filename": "src/util.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Futil.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a55c57b8c48d4d09d3fb74ffddab6e87d10f2030/src%2Futil.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.cc?ref=a55c57b8c48d4d09d3fb74ffddab6e87d10f2030",
            "patch": "@@ -41,7 +41,9 @@ static void MakeUtf8String(Isolate* isolate,\n   Local<String> string;\n   if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;\n \n-  const size_t storage = StringBytes::StorageSize(isolate, string, UTF8) + 1;\n+  size_t storage;\n+  if (!StringBytes::StorageSize(isolate, string, UTF8).To(&storage)) return;\n+  storage += 1;\n   target->AllocateSufficientStorage(storage);\n   const int flags =\n       String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8;"
        }
    ],
    "stats": {
        "total": 266,
        "additions": 149,
        "deletions": 117
    }
}