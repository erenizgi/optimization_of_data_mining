{
    "author": "jasnell",
    "message": "src: move more to node_process.cc from node.cc\n\nPR-URL: https://github.com/nodejs/node/pull/22422\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>",
    "sha": "264c99f6c68aa8ddcbf030b227dd7e6ea812f02a",
    "files": [
        {
            "sha": "a2a28f22fd3a93eadb6f8d212639e7749da3d468",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 225,
            "changes": 225,
            "blob_url": "https://github.com/nodejs/node/blob/264c99f6c68aa8ddcbf030b227dd7e6ea812f02a/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/264c99f6c68aa8ddcbf030b227dd7e6ea812f02a/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=264c99f6c68aa8ddcbf030b227dd7e6ea812f02a",
            "patch": "@@ -114,13 +114,6 @@ typedef int mode_t;\n #include <dlfcn.h>\n #endif\n \n-#ifdef __APPLE__\n-#include <crt_externs.h>\n-#define environ (*_NSGetEnviron())\n-#elif !defined(_MSC_VER)\n-extern char **environ;\n-#endif\n-\n // This is used to load built-in modules. Instead of using\n // __attribute__((constructor)), we call the _register_<modname>\n // function for each built-in modules explicitly in\n@@ -168,9 +161,6 @@ using v8::Undefined;\n using v8::V8;\n using v8::Value;\n \n-static Mutex process_mutex;\n-static Mutex environ_mutex;\n-\n static bool v8_is_profiling = false;\n static bool node_is_initialized = false;\n static uv_once_t init_modpending_once = UV_ONCE_INIT;\n@@ -1695,221 +1685,6 @@ static void GetLinkedBinding(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(effective_exports);\n }\n \n-static void ProcessTitleGetter(Local<Name> property,\n-                               const PropertyCallbackInfo<Value>& info) {\n-  char buffer[512];\n-  uv_get_process_title(buffer, sizeof(buffer));\n-  info.GetReturnValue().Set(String::NewFromUtf8(info.GetIsolate(), buffer,\n-      v8::NewStringType::kNormal).ToLocalChecked());\n-}\n-\n-\n-static void ProcessTitleSetter(Local<Name> property,\n-                               Local<Value> value,\n-                               const PropertyCallbackInfo<void>& info) {\n-  node::Utf8Value title(info.GetIsolate(), value);\n-  TRACE_EVENT_METADATA1(\"__metadata\", \"process_name\", \"name\",\n-                        TRACE_STR_COPY(*title));\n-  uv_set_process_title(*title);\n-}\n-\n-\n-static void EnvGetter(Local<Name> property,\n-                      const PropertyCallbackInfo<Value>& info) {\n-  Isolate* isolate = info.GetIsolate();\n-  if (property->IsSymbol()) {\n-    return info.GetReturnValue().SetUndefined();\n-  }\n-  Mutex::ScopedLock lock(environ_mutex);\n-#ifdef __POSIX__\n-  node::Utf8Value key(isolate, property);\n-  const char* val = getenv(*key);\n-  if (val) {\n-    return info.GetReturnValue().Set(String::NewFromUtf8(isolate, val,\n-        v8::NewStringType::kNormal).ToLocalChecked());\n-  }\n-#else  // _WIN32\n-  node::TwoByteValue key(isolate, property);\n-  WCHAR buffer[32767];  // The maximum size allowed for environment variables.\n-  SetLastError(ERROR_SUCCESS);\n-  DWORD result = GetEnvironmentVariableW(reinterpret_cast<WCHAR*>(*key),\n-                                         buffer,\n-                                         arraysize(buffer));\n-  // If result >= sizeof buffer the buffer was too small. That should never\n-  // happen. If result == 0 and result != ERROR_SUCCESS the variable was not\n-  // found.\n-  if ((result > 0 || GetLastError() == ERROR_SUCCESS) &&\n-      result < arraysize(buffer)) {\n-    const uint16_t* two_byte_buffer = reinterpret_cast<const uint16_t*>(buffer);\n-    Local<String> rc = String::NewFromTwoByte(isolate, two_byte_buffer);\n-    return info.GetReturnValue().Set(rc);\n-  }\n-#endif\n-}\n-\n-\n-static void EnvSetter(Local<Name> property,\n-                      Local<Value> value,\n-                      const PropertyCallbackInfo<Value>& info) {\n-  Environment* env = Environment::GetCurrent(info);\n-  if (env->options()->pending_deprecation && env->EmitProcessEnvWarning() &&\n-      !value->IsString() && !value->IsNumber() && !value->IsBoolean()) {\n-    if (ProcessEmitDeprecationWarning(\n-          env,\n-          \"Assigning any value other than a string, number, or boolean to a \"\n-          \"process.env property is deprecated. Please make sure to convert the \"\n-          \"value to a string before setting process.env with it.\",\n-          \"DEP0104\").IsNothing())\n-      return;\n-  }\n-\n-  Mutex::ScopedLock lock(environ_mutex);\n-#ifdef __POSIX__\n-  node::Utf8Value key(info.GetIsolate(), property);\n-  node::Utf8Value val(info.GetIsolate(), value);\n-  setenv(*key, *val, 1);\n-#else  // _WIN32\n-  node::TwoByteValue key(info.GetIsolate(), property);\n-  node::TwoByteValue val(info.GetIsolate(), value);\n-  WCHAR* key_ptr = reinterpret_cast<WCHAR*>(*key);\n-  // Environment variables that start with '=' are read-only.\n-  if (key_ptr[0] != L'=') {\n-    SetEnvironmentVariableW(key_ptr, reinterpret_cast<WCHAR*>(*val));\n-  }\n-#endif\n-  // Whether it worked or not, always return value.\n-  info.GetReturnValue().Set(value);\n-}\n-\n-\n-static void EnvQuery(Local<Name> property,\n-                     const PropertyCallbackInfo<Integer>& info) {\n-  Mutex::ScopedLock lock(environ_mutex);\n-  int32_t rc = -1;  // Not found unless proven otherwise.\n-  if (property->IsString()) {\n-#ifdef __POSIX__\n-    node::Utf8Value key(info.GetIsolate(), property);\n-    if (getenv(*key))\n-      rc = 0;\n-#else  // _WIN32\n-    node::TwoByteValue key(info.GetIsolate(), property);\n-    WCHAR* key_ptr = reinterpret_cast<WCHAR*>(*key);\n-    SetLastError(ERROR_SUCCESS);\n-    if (GetEnvironmentVariableW(key_ptr, nullptr, 0) > 0 ||\n-        GetLastError() == ERROR_SUCCESS) {\n-      rc = 0;\n-      if (key_ptr[0] == L'=') {\n-        // Environment variables that start with '=' are hidden and read-only.\n-        rc = static_cast<int32_t>(v8::ReadOnly) |\n-             static_cast<int32_t>(v8::DontDelete) |\n-             static_cast<int32_t>(v8::DontEnum);\n-      }\n-    }\n-#endif\n-  }\n-  if (rc != -1)\n-    info.GetReturnValue().Set(rc);\n-}\n-\n-\n-static void EnvDeleter(Local<Name> property,\n-                       const PropertyCallbackInfo<Boolean>& info) {\n-  Mutex::ScopedLock lock(environ_mutex);\n-  if (property->IsString()) {\n-#ifdef __POSIX__\n-    node::Utf8Value key(info.GetIsolate(), property);\n-    unsetenv(*key);\n-#else\n-    node::TwoByteValue key(info.GetIsolate(), property);\n-    WCHAR* key_ptr = reinterpret_cast<WCHAR*>(*key);\n-    SetEnvironmentVariableW(key_ptr, nullptr);\n-#endif\n-  }\n-\n-  // process.env never has non-configurable properties, so always\n-  // return true like the tc39 delete operator.\n-  info.GetReturnValue().Set(true);\n-}\n-\n-\n-static void EnvEnumerator(const PropertyCallbackInfo<Array>& info) {\n-  Environment* env = Environment::GetCurrent(info);\n-  Isolate* isolate = env->isolate();\n-  Local<Context> ctx = env->context();\n-  Local<Function> fn = env->push_values_to_array_function();\n-  Local<Value> argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n-  size_t idx = 0;\n-\n-  Mutex::ScopedLock lock(environ_mutex);\n-#ifdef __POSIX__\n-  int size = 0;\n-  while (environ[size])\n-    size++;\n-\n-  Local<Array> envarr = Array::New(isolate);\n-\n-  for (int i = 0; i < size; ++i) {\n-    const char* var = environ[i];\n-    const char* s = strchr(var, '=');\n-    const int length = s ? s - var : strlen(var);\n-    argv[idx] = String::NewFromUtf8(isolate,\n-                                    var,\n-                                    v8::NewStringType::kNormal,\n-                                    length).ToLocalChecked();\n-    if (++idx >= arraysize(argv)) {\n-      fn->Call(ctx, envarr, idx, argv).ToLocalChecked();\n-      idx = 0;\n-    }\n-  }\n-  if (idx > 0) {\n-    fn->Call(ctx, envarr, idx, argv).ToLocalChecked();\n-  }\n-#else  // _WIN32\n-  WCHAR* environment = GetEnvironmentStringsW();\n-  if (environment == nullptr)\n-    return;  // This should not happen.\n-  Local<Array> envarr = Array::New(isolate);\n-  WCHAR* p = environment;\n-  while (*p) {\n-    WCHAR* s;\n-    if (*p == L'=') {\n-      // If the key starts with '=' it is a hidden environment variable.\n-      p += wcslen(p) + 1;\n-      continue;\n-    } else {\n-      s = wcschr(p, L'=');\n-    }\n-    if (!s) {\n-      s = p + wcslen(p);\n-    }\n-    const uint16_t* two_byte_buffer = reinterpret_cast<const uint16_t*>(p);\n-    const size_t two_byte_buffer_len = s - p;\n-    argv[idx] = String::NewFromTwoByte(isolate,\n-                                       two_byte_buffer,\n-                                       String::kNormalString,\n-                                       two_byte_buffer_len);\n-    if (++idx >= arraysize(argv)) {\n-      fn->Call(ctx, envarr, idx, argv).ToLocalChecked();\n-      idx = 0;\n-    }\n-    p = s + wcslen(s) + 1;\n-  }\n-  if (idx > 0) {\n-    fn->Call(ctx, envarr, idx, argv).ToLocalChecked();\n-  }\n-  FreeEnvironmentStringsW(environment);\n-#endif\n-\n-  info.GetReturnValue().Set(envarr);\n-}\n-\n-\n-static void GetParentProcessId(Local<Name> property,\n-                               const PropertyCallbackInfo<Value>& info) {\n-  info.GetReturnValue().Set(Integer::New(info.GetIsolate(), uv_os_getppid()));\n-}\n-\n-\n static Local<Object> GetFeatures(Environment* env) {\n   EscapableHandleScope scope(env->isolate());\n "
        },
        {
            "sha": "d09bee0cb5ef0cdc63506505ec8ba76ec18f6fb8",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/264c99f6c68aa8ddcbf030b227dd7e6ea812f02a/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/264c99f6c68aa8ddcbf030b227dd7e6ea812f02a/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=264c99f6c68aa8ddcbf030b227dd7e6ea812f02a",
            "patch": "@@ -170,6 +170,9 @@ struct sockaddr;\n \n namespace node {\n \n+extern Mutex process_mutex;\n+extern Mutex environ_mutex;\n+\n // Tells whether it is safe to call v8::Isolate::GetCurrent().\n extern bool v8_initialized;\n \n@@ -888,6 +891,26 @@ void StopProfilerIdleNotifier(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Umask(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Uptime(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n+void EnvDeleter(v8::Local<v8::Name> property,\n+                const v8::PropertyCallbackInfo<v8::Boolean>& info);\n+void EnvGetter(v8::Local<v8::Name> property,\n+               const v8::PropertyCallbackInfo<v8::Value>& info);\n+void EnvSetter(v8::Local<v8::Name> property,\n+               v8::Local<v8::Value> value,\n+               const v8::PropertyCallbackInfo<v8::Value>& info);\n+void EnvQuery(v8::Local<v8::Name> property,\n+              const v8::PropertyCallbackInfo<v8::Integer>& info);\n+void EnvEnumerator(const v8::PropertyCallbackInfo<v8::Array>& info);\n+\n+void GetParentProcessId(v8::Local<v8::Name> property,\n+                        const v8::PropertyCallbackInfo<v8::Value>& info);\n+\n+void ProcessTitleGetter(v8::Local<v8::Name> property,\n+                        const v8::PropertyCallbackInfo<v8::Value>& info);\n+void ProcessTitleSetter(v8::Local<v8::Name> property,\n+                        v8::Local<v8::Value> value,\n+                        const v8::PropertyCallbackInfo<void>& info);\n+\n #if defined(__POSIX__) && !defined(__ANDROID__) && !defined(__CloudABI__)\n void SetGid(const v8::FunctionCallbackInfo<v8::Value>& args);\n void SetEGid(const v8::FunctionCallbackInfo<v8::Value>& args);"
        },
        {
            "sha": "8db1ab5ec0121c9c85c6dc409123e77a88f9af61",
            "filename": "src/node_process.cc",
            "status": "modified",
            "additions": 227,
            "deletions": 0,
            "changes": 227,
            "blob_url": "https://github.com/nodejs/node/blob/264c99f6c68aa8ddcbf030b227dd7e6ea812f02a/src%2Fnode_process.cc",
            "raw_url": "https://github.com/nodejs/node/raw/264c99f6c68aa8ddcbf030b227dd7e6ea812f02a/src%2Fnode_process.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_process.cc?ref=264c99f6c68aa8ddcbf030b227dd7e6ea812f02a",
            "patch": "@@ -25,23 +25,38 @@ typedef int mode_t;\n #include <grp.h>  // getgrnam()\n #endif\n \n+#ifdef __APPLE__\n+#include <crt_externs.h>\n+#define environ (*_NSGetEnviron())\n+#elif !defined(_MSC_VER)\n+extern char **environ;\n+#endif\n+\n namespace node {\n \n using v8::Array;\n using v8::ArrayBuffer;\n using v8::BigUint64Array;\n+using v8::Boolean;\n+using v8::Context;\n using v8::Float64Array;\n+using v8::Function;\n using v8::FunctionCallbackInfo;\n using v8::HeapStatistics;\n using v8::Integer;\n using v8::Isolate;\n using v8::Local;\n+using v8::Name;\n using v8::Number;\n+using v8::PropertyCallbackInfo;\n using v8::String;\n using v8::Uint32;\n using v8::Uint32Array;\n using v8::Value;\n \n+Mutex process_mutex;\n+Mutex environ_mutex;\n+\n // Microseconds in a second, as a float, used in CPUUsage() below\n #define MICROS_PER_SEC 1e6\n // used in Hrtime() below\n@@ -557,4 +572,216 @@ void InitGroups(const FunctionCallbackInfo<Value>& args) {\n \n #endif  // __POSIX__ && !defined(__ANDROID__) && !defined(__CloudABI__)\n \n+void ProcessTitleGetter(Local<Name> property,\n+                        const PropertyCallbackInfo<Value>& info) {\n+  char buffer[512];\n+  uv_get_process_title(buffer, sizeof(buffer));\n+  info.GetReturnValue().Set(String::NewFromUtf8(info.GetIsolate(), buffer,\n+      v8::NewStringType::kNormal).ToLocalChecked());\n+}\n+\n+\n+void ProcessTitleSetter(Local<Name> property,\n+                        Local<Value> value,\n+                        const PropertyCallbackInfo<void>& info) {\n+  node::Utf8Value title(info.GetIsolate(), value);\n+  TRACE_EVENT_METADATA1(\"__metadata\", \"process_name\", \"name\",\n+                        TRACE_STR_COPY(*title));\n+  uv_set_process_title(*title);\n+}\n+\n+void EnvGetter(Local<Name> property,\n+               const PropertyCallbackInfo<Value>& info) {\n+  Isolate* isolate = info.GetIsolate();\n+  if (property->IsSymbol()) {\n+    return info.GetReturnValue().SetUndefined();\n+  }\n+  Mutex::ScopedLock lock(environ_mutex);\n+#ifdef __POSIX__\n+  node::Utf8Value key(isolate, property);\n+  const char* val = getenv(*key);\n+  if (val) {\n+    return info.GetReturnValue().Set(String::NewFromUtf8(isolate, val,\n+        v8::NewStringType::kNormal).ToLocalChecked());\n+  }\n+#else  // _WIN32\n+  node::TwoByteValue key(isolate, property);\n+  WCHAR buffer[32767];  // The maximum size allowed for environment variables.\n+  SetLastError(ERROR_SUCCESS);\n+  DWORD result = GetEnvironmentVariableW(reinterpret_cast<WCHAR*>(*key),\n+                                         buffer,\n+                                         arraysize(buffer));\n+  // If result >= sizeof buffer the buffer was too small. That should never\n+  // happen. If result == 0 and result != ERROR_SUCCESS the variable was not\n+  // found.\n+  if ((result > 0 || GetLastError() == ERROR_SUCCESS) &&\n+      result < arraysize(buffer)) {\n+    const uint16_t* two_byte_buffer = reinterpret_cast<const uint16_t*>(buffer);\n+    Local<String> rc = String::NewFromTwoByte(isolate, two_byte_buffer);\n+    return info.GetReturnValue().Set(rc);\n+  }\n+#endif\n+}\n+\n+\n+void EnvSetter(Local<Name> property,\n+               Local<Value> value,\n+               const PropertyCallbackInfo<Value>& info) {\n+  Environment* env = Environment::GetCurrent(info);\n+  if (env->options()->pending_deprecation && env->EmitProcessEnvWarning() &&\n+      !value->IsString() && !value->IsNumber() && !value->IsBoolean()) {\n+    if (ProcessEmitDeprecationWarning(\n+          env,\n+          \"Assigning any value other than a string, number, or boolean to a \"\n+          \"process.env property is deprecated. Please make sure to convert the \"\n+          \"value to a string before setting process.env with it.\",\n+          \"DEP0104\").IsNothing())\n+      return;\n+  }\n+\n+  Mutex::ScopedLock lock(environ_mutex);\n+#ifdef __POSIX__\n+  node::Utf8Value key(info.GetIsolate(), property);\n+  node::Utf8Value val(info.GetIsolate(), value);\n+  setenv(*key, *val, 1);\n+#else  // _WIN32\n+  node::TwoByteValue key(info.GetIsolate(), property);\n+  node::TwoByteValue val(info.GetIsolate(), value);\n+  WCHAR* key_ptr = reinterpret_cast<WCHAR*>(*key);\n+  // Environment variables that start with '=' are read-only.\n+  if (key_ptr[0] != L'=') {\n+    SetEnvironmentVariableW(key_ptr, reinterpret_cast<WCHAR*>(*val));\n+  }\n+#endif\n+  // Whether it worked or not, always return value.\n+  info.GetReturnValue().Set(value);\n+}\n+\n+\n+void EnvQuery(Local<Name> property, const PropertyCallbackInfo<Integer>& info) {\n+  Mutex::ScopedLock lock(environ_mutex);\n+  int32_t rc = -1;  // Not found unless proven otherwise.\n+  if (property->IsString()) {\n+#ifdef __POSIX__\n+    node::Utf8Value key(info.GetIsolate(), property);\n+    if (getenv(*key))\n+      rc = 0;\n+#else  // _WIN32\n+    node::TwoByteValue key(info.GetIsolate(), property);\n+    WCHAR* key_ptr = reinterpret_cast<WCHAR*>(*key);\n+    SetLastError(ERROR_SUCCESS);\n+    if (GetEnvironmentVariableW(key_ptr, nullptr, 0) > 0 ||\n+        GetLastError() == ERROR_SUCCESS) {\n+      rc = 0;\n+      if (key_ptr[0] == L'=') {\n+        // Environment variables that start with '=' are hidden and read-only.\n+        rc = static_cast<int32_t>(v8::ReadOnly) |\n+             static_cast<int32_t>(v8::DontDelete) |\n+             static_cast<int32_t>(v8::DontEnum);\n+      }\n+    }\n+#endif\n+  }\n+  if (rc != -1)\n+    info.GetReturnValue().Set(rc);\n+}\n+\n+\n+void EnvDeleter(Local<Name> property,\n+                const PropertyCallbackInfo<Boolean>& info) {\n+  Mutex::ScopedLock lock(environ_mutex);\n+  if (property->IsString()) {\n+#ifdef __POSIX__\n+    node::Utf8Value key(info.GetIsolate(), property);\n+    unsetenv(*key);\n+#else\n+    node::TwoByteValue key(info.GetIsolate(), property);\n+    WCHAR* key_ptr = reinterpret_cast<WCHAR*>(*key);\n+    SetEnvironmentVariableW(key_ptr, nullptr);\n+#endif\n+  }\n+\n+  // process.env never has non-configurable properties, so always\n+  // return true like the tc39 delete operator.\n+  info.GetReturnValue().Set(true);\n+}\n+\n+\n+void EnvEnumerator(const PropertyCallbackInfo<Array>& info) {\n+  Environment* env = Environment::GetCurrent(info);\n+  Isolate* isolate = env->isolate();\n+  Local<Context> ctx = env->context();\n+  Local<Function> fn = env->push_values_to_array_function();\n+  Local<Value> argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n+  size_t idx = 0;\n+\n+  Mutex::ScopedLock lock(environ_mutex);\n+#ifdef __POSIX__\n+  int size = 0;\n+  while (environ[size])\n+    size++;\n+\n+  Local<Array> envarr = Array::New(isolate);\n+\n+  for (int i = 0; i < size; ++i) {\n+    const char* var = environ[i];\n+    const char* s = strchr(var, '=');\n+    const int length = s ? s - var : strlen(var);\n+    argv[idx] = String::NewFromUtf8(isolate,\n+                                    var,\n+                                    v8::NewStringType::kNormal,\n+                                    length).ToLocalChecked();\n+    if (++idx >= arraysize(argv)) {\n+      fn->Call(ctx, envarr, idx, argv).ToLocalChecked();\n+      idx = 0;\n+    }\n+  }\n+  if (idx > 0) {\n+    fn->Call(ctx, envarr, idx, argv).ToLocalChecked();\n+  }\n+#else  // _WIN32\n+  WCHAR* environment = GetEnvironmentStringsW();\n+  if (environment == nullptr)\n+    return;  // This should not happen.\n+  Local<Array> envarr = Array::New(isolate);\n+  WCHAR* p = environment;\n+  while (*p) {\n+    WCHAR* s;\n+    if (*p == L'=') {\n+      // If the key starts with '=' it is a hidden environment variable.\n+      p += wcslen(p) + 1;\n+      continue;\n+    } else {\n+      s = wcschr(p, L'=');\n+    }\n+    if (!s) {\n+      s = p + wcslen(p);\n+    }\n+    const uint16_t* two_byte_buffer = reinterpret_cast<const uint16_t*>(p);\n+    const size_t two_byte_buffer_len = s - p;\n+    argv[idx] = String::NewFromTwoByte(isolate,\n+                                       two_byte_buffer,\n+                                       String::kNormalString,\n+                                       two_byte_buffer_len);\n+    if (++idx >= arraysize(argv)) {\n+      fn->Call(ctx, envarr, idx, argv).ToLocalChecked();\n+      idx = 0;\n+    }\n+    p = s + wcslen(s) + 1;\n+  }\n+  if (idx > 0) {\n+    fn->Call(ctx, envarr, idx, argv).ToLocalChecked();\n+  }\n+  FreeEnvironmentStringsW(environment);\n+#endif\n+\n+  info.GetReturnValue().Set(envarr);\n+}\n+\n+void GetParentProcessId(Local<Name> property,\n+                        const PropertyCallbackInfo<Value>& info) {\n+  info.GetReturnValue().Set(Integer::New(info.GetIsolate(), uv_os_getppid()));\n+}\n+\n+\n }  // namespace node"
        }
    ],
    "stats": {
        "total": 475,
        "additions": 250,
        "deletions": 225
    }
}