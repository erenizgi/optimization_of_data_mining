{
    "author": "srl295",
    "message": "deps: ICU 61.1 bump\n\n- Update to released ICU 61.1, including:\n  - CLDR 33 (many new languages and data improvements)\n  - Many small API additions, improvements, and bug fixes\n  - note: 'icu::' namespace is no longer used by default\n   (Necessated https://github.com/nodejs/node/pull/18667 )\n\nPR-URL: https://github.com/nodejs/node/pull/19621\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "64211405dab824a570e52d000891c49415cc42b8",
    "files": [
        {
            "sha": "e425dff429a35b5f42789582bd6999496f9d4acb",
            "filename": "LICENSE",
            "status": "modified",
            "additions": 31,
            "deletions": 2,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/LICENSE",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/LICENSE",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/LICENSE?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -122,8 +122,8 @@ The externally maintained libraries used by Node.js are:\n   \"\"\"\n     COPYRIGHT AND PERMISSION NOTICE (ICU 58 and later)\n \n-    Copyright © 1991-2017 Unicode, Inc. All rights reserved.\n-    Distributed under the Terms of Use in http://www.unicode.org/copyright.html\n+    Copyright © 1991-2018 Unicode, Inc. All rights reserved.\n+    Distributed under the Terms of Use in http://www.unicode.org/copyright.html.\n \n     Permission is hereby granted, free of charge, to any person obtaining\n     a copy of the Unicode data files and any associated documentation\n@@ -505,6 +505,35 @@ The externally maintained libraries used by Node.js are:\n      #    by ICANN or the IETF Trust on the database or the code.  Any person\n      #    making a contribution to the database or code waives all rights to\n      #    future claims in that contribution or in the TZ Database.\n+\n+    6. Google double-conversion\n+\n+    Copyright 2006-2011, the V8 project authors. All rights reserved.\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions are\n+    met:\n+\n+        * Redistributions of source code must retain the above copyright\n+          notice, this list of conditions and the following disclaimer.\n+        * Redistributions in binary form must reproduce the above\n+          copyright notice, this list of conditions and the following\n+          disclaimer in the documentation and/or other materials provided\n+          with the distribution.\n+        * Neither the name of Google Inc. nor the names of its\n+          contributors may be used to endorse or promote products derived\n+          from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   \"\"\"\n \n - libuv, located at deps/uv, is licensed as follows:"
        },
        {
            "sha": "84273f939501586759bad80ca585a8e21fb479fa",
            "filename": "configure",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/configure",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/configure",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/configure?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -1125,8 +1125,8 @@ def glob_to_var(dir_base, dir_sub, patch_dir):\n def configure_intl(o):\n   icus = [\n     {\n-      'url': 'https://ssl.icu-project.org/files/icu4c/60.2/icu4c-60_2-src.zip',\n-      'md5': '115908818fd0324530b2acb1b029738d',\n+      'url': 'https://ssl.icu-project.org/files/icu4c/61.1/icu4c-61_1-src.zip',\n+      'md5': '780d8524c8a860ed8d8f6fe75cb7ce3f',\n     },\n   ]\n   def icu_download(path):"
        },
        {
            "sha": "25b6eb9d3415e62e99af6a349362349c091bc6c7",
            "filename": "deps/icu-small/LICENSE",
            "status": "modified",
            "additions": 31,
            "deletions": 2,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2FLICENSE",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2FLICENSE",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2FLICENSE?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -1,7 +1,7 @@\n COPYRIGHT AND PERMISSION NOTICE (ICU 58 and later)\n \n-Copyright © 1991-2017 Unicode, Inc. All rights reserved.\n-Distributed under the Terms of Use in http://www.unicode.org/copyright.html\n+Copyright © 1991-2018 Unicode, Inc. All rights reserved.\n+Distributed under the Terms of Use in http://www.unicode.org/copyright.html.\n \n Permission is hereby granted, free of charge, to any person obtaining\n a copy of the Unicode data files and any associated documentation\n@@ -383,3 +383,32 @@ Database section 7.\n  #    by ICANN or the IETF Trust on the database or the code.  Any person\n  #    making a contribution to the database or code waives all rights to\n  #    future claims in that contribution or in the TZ Database.\n+\n+6. Google double-conversion\n+\n+Copyright 2006-2011, the V8 project authors. All rights reserved.\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    * Redistributions of source code must retain the above copyright\n+      notice, this list of conditions and the following disclaimer.\n+    * Redistributions in binary form must reproduce the above\n+      copyright notice, this list of conditions and the following\n+      disclaimer in the documentation and/or other materials provided\n+      with the distribution.\n+    * Neither the name of Google Inc. nor the names of its\n+      contributors may be used to endorse or promote products derived\n+      from this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
            "sha": "b3919ec52b21aecbb733a809bc2804ac15e11ce3",
            "filename": "deps/icu-small/README-SMALL-ICU.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2FREADME-SMALL-ICU.txt",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2FREADME-SMALL-ICU.txt",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2FREADME-SMALL-ICU.txt?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -1,8 +1,8 @@\n Small ICU sources - auto generated by shrink-icu-src.py\n \n This directory contains the ICU subset used by --with-intl=small-icu (the default)\n-It is a strict subset of ICU 60 source files with the following exception(s):\n-* deps/icu-small/source/data/in/icudt60l.dat : Reduced-size data file\n+It is a strict subset of ICU 61 source files with the following exception(s):\n+* deps/icu-small/source/data/in/icudt61l.dat : Reduced-size data file\n \n \n To rebuild this directory, see ../../tools/icu/README.md"
        },
        {
            "sha": "35bc80dce359eb90ffcdd968c209b3361c5e5f7f",
            "filename": "deps/icu-small/source/common/bmpset.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbmpset.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbmpset.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbmpset.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -100,9 +100,9 @@ static void set32x64Bits(uint32_t table[64], int32_t start, int32_t limit) {\n             ++lead;\n         }\n         if(lead<limitLead) {\n-            bits=~((1<<lead)-1);\n+            bits=~(((unsigned)1<<lead)-1);\n             if(limitLead<0x20) {\n-                bits&=(1<<limitLead)-1;\n+                bits&=((unsigned)1<<limitLead)-1;\n             }\n             for(trail=0; trail<64; ++trail) {\n                 table[trail]|=bits;"
        },
        {
            "sha": "a513bafb160c853dc6e23978801cf9a067445c98",
            "filename": "deps/icu-small/source/common/brkeng.cpp",
            "status": "modified",
            "additions": 27,
            "deletions": 38,
            "changes": 65,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbrkeng.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbrkeng.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbrkeng.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -59,58 +59,47 @@ LanguageBreakFactory::~LanguageBreakFactory() {\n  ******************************************************************\n  */\n \n-UnhandledEngine::UnhandledEngine(UErrorCode &/*status*/) {\n-    for (int32_t i = 0; i < UPRV_LENGTHOF(fHandled); ++i) {\n-        fHandled[i] = 0;\n-    }\n+UnhandledEngine::UnhandledEngine(UErrorCode &status) : fHandled(nullptr) {\n+    (void)status;\n }\n \n UnhandledEngine::~UnhandledEngine() {\n-    for (int32_t i = 0; i < UPRV_LENGTHOF(fHandled); ++i) {\n-        if (fHandled[i] != 0) {\n-            delete fHandled[i];\n-        }\n-    }\n+    delete fHandled;\n+    fHandled = nullptr;\n }\n \n UBool\n-UnhandledEngine::handles(UChar32 c, int32_t breakType) const {\n-    return (breakType >= 0 && breakType < UPRV_LENGTHOF(fHandled)\n-        && fHandled[breakType] != 0 && fHandled[breakType]->contains(c));\n+UnhandledEngine::handles(UChar32 c) const {\n+    return fHandled && fHandled->contains(c);\n }\n \n int32_t\n UnhandledEngine::findBreaks( UText *text,\n                              int32_t /* startPos */,\n                              int32_t endPos,\n-                             int32_t breakType,\n                              UVector32 &/*foundBreaks*/ ) const {\n-    if (breakType >= 0 && breakType < UPRV_LENGTHOF(fHandled)) {\n-        UChar32 c = utext_current32(text);\n-        while((int32_t)utext_getNativeIndex(text) < endPos && fHandled[breakType]->contains(c)) {\n-            utext_next32(text);            // TODO:  recast loop to work with post-increment operations.\n-            c = utext_current32(text);\n-        }\n+    UChar32 c = utext_current32(text);\n+    while((int32_t)utext_getNativeIndex(text) < endPos && fHandled->contains(c)) {\n+        utext_next32(text);            // TODO:  recast loop to work with post-increment operations.\n+        c = utext_current32(text);\n     }\n     return 0;\n }\n \n void\n-UnhandledEngine::handleCharacter(UChar32 c, int32_t breakType) {\n-    if (breakType >= 0 && breakType < UPRV_LENGTHOF(fHandled)) {\n-        if (fHandled[breakType] == 0) {\n-            fHandled[breakType] = new UnicodeSet();\n-            if (fHandled[breakType] == 0) {\n-                return;\n-            }\n-        }\n-        if (!fHandled[breakType]->contains(c)) {\n-            UErrorCode status = U_ZERO_ERROR;\n-            // Apply the entire script of the character.\n-            int32_t script = u_getIntPropertyValue(c, UCHAR_SCRIPT);\n-            fHandled[breakType]->applyIntPropertyValue(UCHAR_SCRIPT, script, status);\n+UnhandledEngine::handleCharacter(UChar32 c) {\n+    if (fHandled == nullptr) {\n+        fHandled = new UnicodeSet();\n+        if (fHandled == nullptr) {\n+            return;\n         }\n     }\n+    if (!fHandled->contains(c)) {\n+        UErrorCode status = U_ZERO_ERROR;\n+        // Apply the entire script of the character.\n+        int32_t script = u_getIntPropertyValue(c, UCHAR_SCRIPT);\n+        fHandled->applyIntPropertyValue(UCHAR_SCRIPT, script, status);\n+    }\n }\n \n /*\n@@ -138,7 +127,7 @@ U_NAMESPACE_BEGIN\n static UMutex gBreakEngineMutex = U_MUTEX_INITIALIZER;\n \n const LanguageBreakEngine *\n-ICULanguageBreakFactory::getEngineFor(UChar32 c, int32_t breakType) {\n+ICULanguageBreakFactory::getEngineFor(UChar32 c) {\n     const LanguageBreakEngine *lbe = NULL;\n     UErrorCode  status = U_ZERO_ERROR;\n \n@@ -156,26 +145,26 @@ ICULanguageBreakFactory::getEngineFor(UChar32 c, int32_t breakType) {\n         int32_t i = fEngines->size();\n         while (--i >= 0) {\n             lbe = (const LanguageBreakEngine *)(fEngines->elementAt(i));\n-            if (lbe != NULL && lbe->handles(c, breakType)) {\n+            if (lbe != NULL && lbe->handles(c)) {\n                 return lbe;\n             }\n         }\n     }\n \n     // We didn't find an engine. Create one.\n-    lbe = loadEngineFor(c, breakType);\n+    lbe = loadEngineFor(c);\n     if (lbe != NULL) {\n         fEngines->push((void *)lbe, status);\n     }\n     return lbe;\n }\n \n const LanguageBreakEngine *\n-ICULanguageBreakFactory::loadEngineFor(UChar32 c, int32_t breakType) {\n+ICULanguageBreakFactory::loadEngineFor(UChar32 c) {\n     UErrorCode status = U_ZERO_ERROR;\n     UScriptCode code = uscript_getScript(c, &status);\n     if (U_SUCCESS(status)) {\n-        DictionaryMatcher *m = loadDictionaryMatcherFor(code, breakType);\n+        DictionaryMatcher *m = loadDictionaryMatcherFor(code);\n         if (m != NULL) {\n             const LanguageBreakEngine *engine = NULL;\n             switch(code) {\n@@ -236,7 +225,7 @@ ICULanguageBreakFactory::loadEngineFor(UChar32 c, int32_t breakType) {\n }\n \n DictionaryMatcher *\n-ICULanguageBreakFactory::loadDictionaryMatcherFor(UScriptCode script, int32_t /* brkType */) {\n+ICULanguageBreakFactory::loadDictionaryMatcherFor(UScriptCode script) {\n     UErrorCode status = U_ZERO_ERROR;\n     // open root from brkitr tree.\n     UResourceBundle *b = ures_open(U_ICUDATA_BRKITR, \"\", &status);"
        },
        {
            "sha": "e40fce13f64b8aa24f6ceacecfae4bc3fc438308",
            "filename": "deps/icu-small/source/common/brkeng.h",
            "status": "modified",
            "additions": 9,
            "deletions": 24,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbrkeng.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbrkeng.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbrkeng.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -54,11 +54,10 @@ class LanguageBreakEngine : public UMemory {\n   * a particular kind of break.</p>\n   *\n   * @param c A character which begins a run that the engine might handle\n-  * @param breakType The type of text break which the caller wants to determine\n   * @return TRUE if this engine handles the particular character and break\n   * type.\n   */\n-  virtual UBool handles(UChar32 c, int32_t breakType) const = 0;\n+  virtual UBool handles(UChar32 c) const = 0;\n \n  /**\n   * <p>Find any breaks within a run in the supplied text.</p>\n@@ -68,14 +67,12 @@ class LanguageBreakEngine : public UMemory {\n   * is capable of handling.\n   * @param startPos The start of the run within the supplied text.\n   * @param endPos The end of the run within the supplied text.\n-  * @param breakType The type of break desired, or -1.\n   * @param foundBreaks A Vector of int32_t to receive the breaks.\n   * @return The number of breaks found.\n   */\n   virtual int32_t findBreaks( UText *text,\n                               int32_t startPos,\n                               int32_t endPos,\n-                              int32_t breakType,\n                               UVector32 &foundBreaks ) const = 0;\n \n };\n@@ -125,11 +122,9 @@ class LanguageBreakFactory : public UMemory {\n   *\n   * @param c A character that begins a run for which a LanguageBreakEngine is\n   * sought.\n-  * @param breakType The kind of text break for which a LanguageBreakEngine is\n-  * sought.\n   * @return A LanguageBreakEngine with the desired characteristics, or 0.\n   */\n-  virtual const LanguageBreakEngine *getEngineFor(UChar32 c, int32_t breakType) = 0;\n+  virtual const LanguageBreakEngine *getEngineFor(UChar32 c) = 0;\n \n };\n \n@@ -152,11 +147,11 @@ class UnhandledEngine : public LanguageBreakEngine {\n  private:\n \n     /**\n-     * The sets of characters handled, for each break type\n+     * The sets of characters handled.\n      * @internal\n      */\n \n-  UnicodeSet    *fHandled[4];\n+  UnicodeSet    *fHandled;\n \n  public:\n \n@@ -176,11 +171,10 @@ class UnhandledEngine : public LanguageBreakEngine {\n   * a particular kind of break.</p>\n   *\n   * @param c A character which begins a run that the engine might handle\n-  * @param breakType The type of text break which the caller wants to determine\n   * @return TRUE if this engine handles the particular character and break\n   * type.\n   */\n-  virtual UBool handles(UChar32 c, int32_t breakType) const;\n+  virtual UBool handles(UChar32 c) const;\n \n  /**\n   * <p>Find any breaks within a run in the supplied text.</p>\n@@ -190,23 +184,20 @@ class UnhandledEngine : public LanguageBreakEngine {\n   * is capable of handling.\n   * @param startPos The start of the run within the supplied text.\n   * @param endPos The end of the run within the supplied text.\n-  * @param breakType The type of break desired, or -1.\n   * @param foundBreaks An allocated C array of the breaks found, if any\n   * @return The number of breaks found.\n   */\n   virtual int32_t findBreaks( UText *text,\n                               int32_t startPos,\n                               int32_t endPos,\n-                              int32_t breakType,\n                               UVector32 &foundBreaks ) const;\n \n  /**\n   * <p>Tell the engine to handle a particular character and break type.</p>\n   *\n   * @param c A character which the engine should handle\n-  * @param breakType The type of text break for which the engine should handle c\n   */\n-  virtual void handleCharacter(UChar32 c, int32_t breakType);\n+  virtual void handleCharacter(UChar32 c);\n \n };\n \n@@ -250,11 +241,9 @@ class ICULanguageBreakFactory : public LanguageBreakFactory {\n   *\n   * @param c A character that begins a run for which a LanguageBreakEngine is\n   * sought.\n-  * @param breakType The kind of text break for which a LanguageBreakEngine is\n-  * sought.\n   * @return A LanguageBreakEngine with the desired characteristics, or 0.\n   */\n-  virtual const LanguageBreakEngine *getEngineFor(UChar32 c, int32_t breakType);\n+  virtual const LanguageBreakEngine *getEngineFor(UChar32 c);\n \n protected:\n  /**\n@@ -263,21 +252,17 @@ class ICULanguageBreakFactory : public LanguageBreakFactory {\n   *\n   * @param c A character that begins a run for which a LanguageBreakEngine is\n   * sought.\n-  * @param breakType The kind of text break for which a LanguageBreakEngine is\n-  * sought.\n   * @return A LanguageBreakEngine with the desired characteristics, or 0.\n   */\n-  virtual const LanguageBreakEngine *loadEngineFor(UChar32 c, int32_t breakType);\n+  virtual const LanguageBreakEngine *loadEngineFor(UChar32 c);\n \n   /**\n    * <p>Create a DictionaryMatcher for the specified script and break type.</p>\n    * @param script An ISO 15924 script code that identifies the dictionary to be\n    * created.\n-   * @param breakType The kind of text break for which a dictionary is\n-   * sought.\n    * @return A DictionaryMatcher with the desired characteristics, or NULL.\n    */\n-  virtual DictionaryMatcher *loadDictionaryMatcherFor(UScriptCode script, int32_t breakType);\n+  virtual DictionaryMatcher *loadDictionaryMatcherFor(UScriptCode script);\n };\n \n U_NAMESPACE_END"
        },
        {
            "sha": "23e0cc3c153392c4ab52668cfe98a85466fbb70e",
            "filename": "deps/icu-small/source/common/brkiter.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbrkiter.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbrkiter.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbrkiter.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -52,7 +52,7 @@ U_NAMESPACE_BEGIN\n // -------------------------------------\n \n BreakIterator*\n-BreakIterator::buildInstance(const Locale& loc, const char *type, int32_t kind, UErrorCode &status)\n+BreakIterator::buildInstance(const Locale& loc, const char *type, UErrorCode &status)\n {\n     char fnbuff[256];\n     char ext[4]={'\\0'};\n@@ -121,7 +121,6 @@ BreakIterator::buildInstance(const Locale& loc, const char *type, int32_t kind,\n         U_LOCALE_BASED(locBased, *(BreakIterator*)result);\n         locBased.setLocaleIDs(ures_getLocaleByType(b, ULOC_VALID_LOCALE, &status),\n                               actualLocale.data());\n-        result->setBreakType(kind);\n     }\n \n     ures_close(b);\n@@ -413,10 +412,10 @@ BreakIterator::makeInstance(const Locale& loc, int32_t kind, UErrorCode& status)\n     BreakIterator *result = NULL;\n     switch (kind) {\n     case UBRK_CHARACTER:\n-        result = BreakIterator::buildInstance(loc, \"grapheme\", kind, status);\n+        result = BreakIterator::buildInstance(loc, \"grapheme\", status);\n         break;\n     case UBRK_WORD:\n-        result = BreakIterator::buildInstance(loc, \"word\", kind, status);\n+        result = BreakIterator::buildInstance(loc, \"word\", status);\n         break;\n     case UBRK_LINE:\n         uprv_strcpy(lbType, \"line\");\n@@ -429,10 +428,10 @@ BreakIterator::makeInstance(const Locale& loc, int32_t kind, UErrorCode& status)\n                 uprv_strcat(lbType, lbKeyValue);\n             }\n         }\n-        result = BreakIterator::buildInstance(loc, lbType, kind, status);\n+        result = BreakIterator::buildInstance(loc, lbType, status);\n         break;\n     case UBRK_SENTENCE:\n-        result = BreakIterator::buildInstance(loc, \"sentence\", kind, status);\n+        result = BreakIterator::buildInstance(loc, \"sentence\", status);\n #if !UCONFIG_NO_FILTERED_BREAK_ITERATION\n         {\n             char ssKeyValue[kKeyValueLenMax] = {0};\n@@ -449,7 +448,7 @@ BreakIterator::makeInstance(const Locale& loc, int32_t kind, UErrorCode& status)\n #endif\n         break;\n     case UBRK_TITLE:\n-        result = BreakIterator::buildInstance(loc, \"title\", kind, status);\n+        result = BreakIterator::buildInstance(loc, \"title\", status);\n         break;\n     default:\n         status = U_ILLEGAL_ARGUMENT_ERROR;"
        },
        {
            "sha": "6af7ddfd5976382bec00ea23c64fb94107121dfa",
            "filename": "deps/icu-small/source/common/bytesinkutil.cpp",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -92,20 +92,16 @@ ByteSinkUtil::appendTwoBytes(UChar32 c, ByteSink &sink) {\n     sink.Append(s8, 2);\n }\n \n-UBool\n-ByteSinkUtil::appendUnchanged(const uint8_t *s, int32_t length,\n-                              ByteSink &sink, uint32_t options, Edits *edits,\n-                              UErrorCode &errorCode) {\n-    if (U_FAILURE(errorCode)) { return FALSE; }\n-    if (length > 0) {\n-        if (edits != nullptr) {\n-            edits->addUnchanged(length);\n-        }\n-        if ((options & U_OMIT_UNCHANGED_TEXT) == 0) {\n-            sink.Append(reinterpret_cast<const char *>(s), length);\n-        }\n+void\n+ByteSinkUtil::appendNonEmptyUnchanged(const uint8_t *s, int32_t length,\n+                                      ByteSink &sink, uint32_t options, Edits *edits) {\n+    U_ASSERT(length > 0);\n+    if (edits != nullptr) {\n+        edits->addUnchanged(length);\n+    }\n+    if ((options & U_OMIT_UNCHANGED_TEXT) == 0) {\n+        sink.Append(reinterpret_cast<const char *>(s), length);\n     }\n-    return TRUE;\n }\n \n UBool\n@@ -117,7 +113,11 @@ ByteSinkUtil::appendUnchanged(const uint8_t *s, const uint8_t *limit,\n         errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n         return FALSE;\n     }\n-    return appendUnchanged(s, (int32_t)(limit - s), sink, options, edits, errorCode);\n+    int32_t length = (int32_t)(limit - s);\n+    if (length > 0) {\n+        appendNonEmptyUnchanged(s, length, sink, options, edits);\n+    }\n+    return TRUE;\n }\n \n U_NAMESPACE_END"
        },
        {
            "sha": "8287ffea4ca713dfdc489c63cac84bbc18332f89",
            "filename": "deps/icu-small/source/common/bytesinkutil.h",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -43,11 +43,19 @@ class U_COMMON_API ByteSinkUtil {\n \n     static UBool appendUnchanged(const uint8_t *s, int32_t length,\n                                  ByteSink &sink, uint32_t options, Edits *edits,\n-                                 UErrorCode &errorCode);\n+                                 UErrorCode &errorCode) {\n+        if (U_FAILURE(errorCode)) { return FALSE; }\n+        if (length > 0) { appendNonEmptyUnchanged(s, length, sink, options, edits); }\n+        return TRUE;\n+    }\n \n     static UBool appendUnchanged(const uint8_t *s, const uint8_t *limit,\n                                  ByteSink &sink, uint32_t options, Edits *edits,\n                                  UErrorCode &errorCode);\n+\n+private:\n+    static void appendNonEmptyUnchanged(const uint8_t *s, int32_t length,\n+                                        ByteSink &sink, uint32_t options, Edits *edits);\n };\n \n U_NAMESPACE_END"
        },
        {
            "sha": "0b7e432c4dee4688ffd54a03a0528725c4507da6",
            "filename": "deps/icu-small/source/common/cmemory.cpp",
            "status": "modified",
            "additions": 0,
            "deletions": 24,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fcmemory.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fcmemory.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fcmemory.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -41,30 +41,6 @@ static int n=0;\n static long b=0;\n #endif\n \n-#if U_DEBUG\n-\n-static char gValidMemorySink = 0;\n-\n-U_CAPI void uprv_checkValidMemory(const void *p, size_t n) {\n-    /*\n-     * Access the memory to ensure that it's all valid.\n-     * Load and save a computed value to try to ensure that the compiler\n-     * does not throw away the whole loop.\n-     * A thread analyzer might complain about un-mutexed access to gValidMemorySink\n-     * which is true but harmless because no one ever uses the value in gValidMemorySink.\n-     */\n-    const char *s = (const char *)p;\n-    char c = gValidMemorySink;\n-    size_t i;\n-    U_ASSERT(p != NULL);\n-    for(i = 0; i < n; ++i) {\n-        c ^= s[i];\n-    }\n-    gValidMemorySink = c;\n-}\n-\n-#endif  /* U_DEBUG */\n-\n U_CAPI void * U_EXPORT2\n uprv_malloc(size_t s) {\n #if U_DEBUG && defined(UPRV_MALLOC_COUNT)"
        },
        {
            "sha": "a44f9a190293bd5d62a599d8c4cf0d1571c0acad",
            "filename": "deps/icu-small/source/common/cmemory.h",
            "status": "modified",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fcmemory.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fcmemory.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fcmemory.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -36,31 +36,10 @@\n #include <stdio.h>\n #endif\n \n-#if U_DEBUG\n-\n-/*\n- * The C++ standard requires that the source pointer for memcpy() & memmove()\n- * is valid, not NULL, and not at the end of an allocated memory block.\n- * In debug mode, we read one byte from the source point to verify that it's\n- * a valid, readable pointer.\n- */\n-\n-U_CAPI void uprv_checkValidMemory(const void *p, size_t n);\n-\n-#define uprv_memcpy(dst, src, size) ( \\\n-    uprv_checkValidMemory(src, 1), \\\n-    U_STANDARD_CPP_NAMESPACE memcpy(dst, src, size))\n-#define uprv_memmove(dst, src, size) ( \\\n-    uprv_checkValidMemory(src, 1), \\\n-    U_STANDARD_CPP_NAMESPACE memmove(dst, src, size))\n-\n-#else\n \n #define uprv_memcpy(dst, src, size) U_STANDARD_CPP_NAMESPACE memcpy(dst, src, size)\n #define uprv_memmove(dst, src, size) U_STANDARD_CPP_NAMESPACE memmove(dst, src, size)\n \n-#endif  /* U_DEBUG */\n-\n /**\n  * \\def UPRV_LENGTHOF\n  * Convenience macro to determine the length of a fixed array at compile-time."
        },
        {
            "sha": "ed0b1a7c8b0be863e7dd297b4e47a978ebb15a4d",
            "filename": "deps/icu-small/source/common/cstring.h",
            "status": "modified",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fcstring.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fcstring.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fcstring.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -40,28 +40,10 @@\n #define uprv_strchr(s, c) U_STANDARD_CPP_NAMESPACE strchr(s, c)\n #define uprv_strstr(s, c) U_STANDARD_CPP_NAMESPACE strstr(s, c)\n #define uprv_strrchr(s, c) U_STANDARD_CPP_NAMESPACE strrchr(s, c)\n-\n-#if U_DEBUG\n-\n-#define uprv_strncpy(dst, src, size) ( \\\n-    uprv_checkValidMemory(src, 1), \\\n-    U_STANDARD_CPP_NAMESPACE strncpy(dst, src, size))\n-#define uprv_strncmp(s1, s2, n) ( \\\n-    uprv_checkValidMemory(s1, 1), \\\n-    uprv_checkValidMemory(s2, 1), \\\n-    U_STANDARD_CPP_NAMESPACE strncmp(s1, s2, n))\n-#define uprv_strncat(dst, src, n) ( \\\n-    uprv_checkValidMemory(src, 1), \\\n-    U_STANDARD_CPP_NAMESPACE strncat(dst, src, n))\n-\n-#else\n-\n #define uprv_strncpy(dst, src, size) U_STANDARD_CPP_NAMESPACE strncpy(dst, src, size)\n #define uprv_strncmp(s1, s2, n) U_STANDARD_CPP_NAMESPACE strncmp(s1, s2, n)\n #define uprv_strncat(dst, src, n) U_STANDARD_CPP_NAMESPACE strncat(dst, src, n)\n \n-#endif  /* U_DEBUG */\n-\n /**\n  * Is c an ASCII-repertoire letter a-z or A-Z?\n  * Note: The implementation is specific to whether ICU is compiled for"
        },
        {
            "sha": "419d062ef25d44b2d8e55ede634ea69ece0987c3",
            "filename": "deps/icu-small/source/common/dictbe.cpp",
            "status": "modified",
            "additions": 12,
            "deletions": 17,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fdictbe.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fdictbe.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fdictbe.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -29,24 +29,21 @@ U_NAMESPACE_BEGIN\n  ******************************************************************\n  */\n \n-DictionaryBreakEngine::DictionaryBreakEngine(uint32_t breakTypes) {\n-    fTypes = breakTypes;\n+DictionaryBreakEngine::DictionaryBreakEngine() {\n }\n \n DictionaryBreakEngine::~DictionaryBreakEngine() {\n }\n \n UBool\n-DictionaryBreakEngine::handles(UChar32 c, int32_t breakType) const {\n-    return (breakType >= 0 && breakType < 32 && (((uint32_t)1 << breakType) & fTypes)\n-            && fSet.contains(c));\n+DictionaryBreakEngine::handles(UChar32 c) const {\n+    return fSet.contains(c);\n }\n \n int32_t\n DictionaryBreakEngine::findBreaks( UText *text,\n                                  int32_t startPos,\n                                  int32_t endPos,\n-                                 int32_t breakType,\n                                  UVector32 &foundBreaks ) const {\n     (void)startPos;            // TODO: remove this param?\n     int32_t result = 0;\n@@ -66,10 +63,8 @@ DictionaryBreakEngine::findBreaks( UText *text,\n     }\n     rangeStart = start;\n     rangeEnd = current;\n-    if (breakType >= 0 && breakType < 32 && (((uint32_t)1 << breakType) & fTypes)) {\n-        result = divideUpDictionaryRange(text, rangeStart, rangeEnd, foundBreaks);\n-        utext_setNativeIndex(text, current);\n-    }\n+    result = divideUpDictionaryRange(text, rangeStart, rangeEnd, foundBreaks);\n+    utext_setNativeIndex(text, current);\n \n     return result;\n }\n@@ -194,7 +189,7 @@ static const int32_t THAI_MIN_WORD = 2;\n static const int32_t THAI_MIN_WORD_SPAN = THAI_MIN_WORD * 2;\n \n ThaiBreakEngine::ThaiBreakEngine(DictionaryMatcher *adoptDictionary, UErrorCode &status)\n-    : DictionaryBreakEngine((1<<UBRK_WORD) | (1<<UBRK_LINE)),\n+    : DictionaryBreakEngine(),\n       fDictionary(adoptDictionary)\n {\n     fThaiWordSet.applyPattern(UNICODE_STRING_SIMPLE(\"[[:Thai:]&[:LineBreak=SA:]]\"), status);\n@@ -436,7 +431,7 @@ static const int32_t LAO_MIN_WORD = 2;\n static const int32_t LAO_MIN_WORD_SPAN = LAO_MIN_WORD * 2;\n \n LaoBreakEngine::LaoBreakEngine(DictionaryMatcher *adoptDictionary, UErrorCode &status)\n-    : DictionaryBreakEngine((1<<UBRK_WORD) | (1<<UBRK_LINE)),\n+    : DictionaryBreakEngine(),\n       fDictionary(adoptDictionary)\n {\n     fLaoWordSet.applyPattern(UNICODE_STRING_SIMPLE(\"[[:Laoo:]&[:LineBreak=SA:]]\"), status);\n@@ -632,7 +627,7 @@ static const int32_t BURMESE_MIN_WORD = 2;\n static const int32_t BURMESE_MIN_WORD_SPAN = BURMESE_MIN_WORD * 2;\n \n BurmeseBreakEngine::BurmeseBreakEngine(DictionaryMatcher *adoptDictionary, UErrorCode &status)\n-    : DictionaryBreakEngine((1<<UBRK_WORD) | (1<<UBRK_LINE)),\n+    : DictionaryBreakEngine(),\n       fDictionary(adoptDictionary)\n {\n     fBurmeseWordSet.applyPattern(UNICODE_STRING_SIMPLE(\"[[:Mymr:]&[:LineBreak=SA:]]\"), status);\n@@ -825,7 +820,7 @@ static const int32_t KHMER_MIN_WORD = 2;\n static const int32_t KHMER_MIN_WORD_SPAN = KHMER_MIN_WORD * 2;\n \n KhmerBreakEngine::KhmerBreakEngine(DictionaryMatcher *adoptDictionary, UErrorCode &status)\n-    : DictionaryBreakEngine((1 << UBRK_WORD) | (1 << UBRK_LINE)),\n+    : DictionaryBreakEngine(),\n       fDictionary(adoptDictionary)\n {\n     fKhmerWordSet.applyPattern(UNICODE_STRING_SIMPLE(\"[[:Khmr:]&[:LineBreak=SA:]]\"), status);\n@@ -1047,7 +1042,7 @@ KhmerBreakEngine::divideUpDictionaryRange( UText *text,\n  */\n static const uint32_t kuint32max = 0xFFFFFFFF;\n CjkBreakEngine::CjkBreakEngine(DictionaryMatcher *adoptDictionary, LanguageType type, UErrorCode &status)\n-: DictionaryBreakEngine(1 << UBRK_WORD), fDictionary(adoptDictionary) {\n+: DictionaryBreakEngine(), fDictionary(adoptDictionary) {\n     // Korean dictionary only includes Hangul syllables\n     fHangulWordSet.applyPattern(UNICODE_STRING_SIMPLE(\"[\\\\uac00-\\\\ud7a3]\"), status);\n     fHanWordSet.applyPattern(UNICODE_STRING_SIMPLE(\"[:Han:]\"), status);\n@@ -1324,8 +1319,8 @@ CjkBreakEngine::divideUpDictionaryRange( UText *inText,\n             }\n             if (katakanaRunLength < kMaxKatakanaGroupLength) {\n                 uint32_t newSnlp = bestSnlp.elementAti(i) + getKatakanaCost(katakanaRunLength);\n-                if (newSnlp < (uint32_t)bestSnlp.elementAti(j)) {\n-                    bestSnlp.setElementAt(newSnlp, j);\n+                if (newSnlp < (uint32_t)bestSnlp.elementAti(i+katakanaRunLength)) {\n+                    bestSnlp.setElementAt(newSnlp, i+katakanaRunLength);\n                     prev.setElementAt(i, i+katakanaRunLength);  // prev[j] = i;\n                 }\n             }"
        },
        {
            "sha": "99d176cc2e7bcf33185ec1726b0af8d8ed0c32b3",
            "filename": "deps/icu-small/source/common/dictbe.h",
            "status": "modified",
            "additions": 3,
            "deletions": 28,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fdictbe.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fdictbe.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fdictbe.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -42,27 +42,12 @@ class DictionaryBreakEngine : public LanguageBreakEngine {\n \n   UnicodeSet    fSet;\n \n-    /**\n-     * The set of break types handled by this engine\n-     * @internal\n-     */\n-\n-  uint32_t      fTypes;\n-\n-  /**\n-   * <p>Default constructor.</p>\n-   *\n-   */\n-  DictionaryBreakEngine();\n-\n  public:\n \n   /**\n-   * <p>Constructor setting the break types handled.</p>\n-   *\n-   * @param breakTypes A bitmap of types handled by the engine.\n+   * <p>Constructor </p>\n    */\n-  DictionaryBreakEngine( uint32_t breakTypes );\n+  DictionaryBreakEngine();\n \n   /**\n    * <p>Virtual destructor.</p>\n@@ -74,11 +59,10 @@ class DictionaryBreakEngine : public LanguageBreakEngine {\n    * a particular kind of break.</p>\n    *\n    * @param c A character which begins a run that the engine might handle\n-   * @param breakType The type of text break which the caller wants to determine\n    * @return TRUE if this engine handles the particular character and break\n    * type.\n    */\n-  virtual UBool handles( UChar32 c, int32_t breakType ) const;\n+  virtual UBool handles(UChar32 c) const;\n \n   /**\n    * <p>Find any breaks within a run in the supplied text.</p>\n@@ -88,14 +72,12 @@ class DictionaryBreakEngine : public LanguageBreakEngine {\n    * that starts from the first character in the range.\n    * @param startPos The start of the run within the supplied text.\n    * @param endPos The end of the run within the supplied text.\n-   * @param breakType The type of break desired, or -1.\n    * @param foundBreaks vector of int32_t to receive the break positions\n    * @return The number of breaks found.\n    */\n   virtual int32_t findBreaks( UText *text,\n                               int32_t startPos,\n                               int32_t endPos,\n-                              int32_t breakType,\n                               UVector32 &foundBreaks ) const;\n \n  protected:\n@@ -107,13 +89,6 @@ class DictionaryBreakEngine : public LanguageBreakEngine {\n   */\n   virtual void setCharacters( const UnicodeSet &set );\n \n- /**\n-  * <p>Set the break types handled by this engine.</p>\n-  *\n-  * @param breakTypes A bitmap of types handled by the engine.\n-  */\n-//  virtual void setBreakTypes( uint32_t breakTypes );\n-\n  /**\n   * <p>Divide up a range of known dictionary characters handled by this break engine.</p>\n   *"
        },
        {
            "sha": "162b38de5d6fa276e07edfdef21be5c040444af6",
            "filename": "deps/icu-small/source/common/filteredbrk.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Ffilteredbrk.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Ffilteredbrk.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Ffilteredbrk.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -693,6 +693,11 @@ FilteredBreakIteratorBuilder::createInstance(const Locale& where, UErrorCode& st\n   return (U_SUCCESS(status))? ret.orphan(): NULL;\n }\n \n+FilteredBreakIteratorBuilder *\n+FilteredBreakIteratorBuilder::createInstance(UErrorCode &status) {\n+  return createEmptyInstance(status);\n+}\n+\n FilteredBreakIteratorBuilder *\n FilteredBreakIteratorBuilder::createEmptyInstance(UErrorCode& status) {\n   if(U_FAILURE(status)) return NULL;"
        },
        {
            "sha": "69f92d94c602c33cc65cb7d873956a3efca08aed",
            "filename": "deps/icu-small/source/common/rbbi.cpp",
            "status": "modified",
            "additions": 90,
            "deletions": 105,
            "changes": 195,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -64,7 +64,9 @@ UOBJECT_DEFINE_RTTI_IMPLEMENTATION(RuleBasedBreakIterator)\n  * Constructs a RuleBasedBreakIterator that uses the already-created\n  * tables object that is passed in as a parameter.\n  */\n-RuleBasedBreakIterator::RuleBasedBreakIterator(RBBIDataHeader* data, UErrorCode &status) {\n+RuleBasedBreakIterator::RuleBasedBreakIterator(RBBIDataHeader* data, UErrorCode &status)\n+ : fSCharIter(UnicodeString())\n+{\n     init(status);\n     fData = new RBBIDataWrapper(data, status); // status checked in constructor\n     if (U_FAILURE(status)) {return;}\n@@ -80,7 +82,9 @@ RuleBasedBreakIterator::RuleBasedBreakIterator(RBBIDataHeader* data, UErrorCode\n //\n RuleBasedBreakIterator::RuleBasedBreakIterator(const uint8_t *compiledRules,\n                        uint32_t       ruleLength,\n-                       UErrorCode     &status) {\n+                       UErrorCode     &status)\n+ : fSCharIter(UnicodeString())\n+{\n     init(status);\n     if (U_FAILURE(status)) {\n         return;\n@@ -110,6 +114,7 @@ RuleBasedBreakIterator::RuleBasedBreakIterator(const uint8_t *compiledRules,\n //\n //-------------------------------------------------------------------------------\n RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory* udm, UErrorCode &status)\n+ : fSCharIter(UnicodeString())\n {\n     init(status);\n     fData = new RBBIDataWrapper(udm, status); // status checked in constructor\n@@ -130,6 +135,7 @@ RuleBasedBreakIterator::RuleBasedBreakIterator(UDataMemory* udm, UErrorCode &sta\n RuleBasedBreakIterator::RuleBasedBreakIterator( const UnicodeString  &rules,\n                                                 UParseError          &parseError,\n                                                 UErrorCode           &status)\n+ : fSCharIter(UnicodeString())\n {\n     init(status);\n     if (U_FAILURE(status)) {return;}\n@@ -152,7 +158,9 @@ RuleBasedBreakIterator::RuleBasedBreakIterator( const UnicodeString  &rules,\n //                           Used when creating a RuleBasedBreakIterator from a set\n //                           of rules.\n //-------------------------------------------------------------------------------\n-RuleBasedBreakIterator::RuleBasedBreakIterator() {\n+RuleBasedBreakIterator::RuleBasedBreakIterator()\n+ : fSCharIter(UnicodeString())\n+{\n     UErrorCode status = U_ZERO_ERROR;\n     init(status);\n }\n@@ -165,7 +173,8 @@ RuleBasedBreakIterator::RuleBasedBreakIterator() {\n //\n //-------------------------------------------------------------------------------\n RuleBasedBreakIterator::RuleBasedBreakIterator(const RuleBasedBreakIterator& other)\n-: BreakIterator(other)\n+: BreakIterator(other),\n+  fSCharIter(UnicodeString())\n {\n     UErrorCode status = U_ZERO_ERROR;\n     this->init(status);\n@@ -177,17 +186,13 @@ RuleBasedBreakIterator::RuleBasedBreakIterator(const RuleBasedBreakIterator& oth\n  * Destructor\n  */\n RuleBasedBreakIterator::~RuleBasedBreakIterator() {\n-    if (fCharIter!=fSCharIter && fCharIter!=fDCharIter) {\n+    if (fCharIter != &fSCharIter) {\n         // fCharIter was adopted from the outside.\n         delete fCharIter;\n     }\n     fCharIter = NULL;\n-    delete fSCharIter;\n-    fSCharIter = NULL;\n-    delete fDCharIter;\n-    fDCharIter = NULL;\n \n-    utext_close(fText);\n+    utext_close(&fText);\n \n     if (fData != NULL) {\n         fData->removeReference();\n@@ -217,26 +222,29 @@ RuleBasedBreakIterator::operator=(const RuleBasedBreakIterator& that) {\n     }\n     BreakIterator::operator=(that);\n \n-    fBreakType = that.fBreakType;\n     if (fLanguageBreakEngines != NULL) {\n         delete fLanguageBreakEngines;\n         fLanguageBreakEngines = NULL;   // Just rebuild for now\n     }\n     // TODO: clone fLanguageBreakEngines from \"that\"\n     UErrorCode status = U_ZERO_ERROR;\n-    fText = utext_clone(fText, that.fText, FALSE, TRUE, &status);\n+    utext_clone(&fText, &that.fText, FALSE, TRUE, &status);\n \n-    if (fCharIter!=fSCharIter && fCharIter!=fDCharIter) {\n+    if (fCharIter != &fSCharIter) {\n         delete fCharIter;\n     }\n-    fCharIter = NULL;\n+    fCharIter = &fSCharIter;\n \n-    if (that.fCharIter != NULL ) {\n+    if (that.fCharIter != NULL && that.fCharIter != &that.fSCharIter) {\n         // This is a little bit tricky - it will intially appear that\n         //  this->fCharIter is adopted, even if that->fCharIter was\n         //  not adopted.  That's ok.\n         fCharIter = that.fCharIter->clone();\n     }\n+    fSCharIter = that.fSCharIter;\n+    if (fCharIter == NULL) {\n+        fCharIter = &fSCharIter;\n+    }\n \n     if (fData != NULL) {\n         fData->removeReference();\n@@ -269,33 +277,30 @@ RuleBasedBreakIterator::operator=(const RuleBasedBreakIterator& that) {\n //\n //-----------------------------------------------------------------------------\n void RuleBasedBreakIterator::init(UErrorCode &status) {\n-    fText                 = NULL;\n     fCharIter             = NULL;\n-    fSCharIter            = NULL;\n-    fDCharIter            = NULL;\n     fData                 = NULL;\n     fPosition             = 0;\n     fRuleStatusIndex      = 0;\n     fDone                 = false;\n     fDictionaryCharCount  = 0;\n-    fBreakType            = UBRK_WORD;  // Defaulting BreakType to word gives reasonable\n-                                        //   dictionary behavior for Break Iterators that are\n-                                        //   built from rules.  Even better would be the ability to\n-                                        //   declare the type in the rules.\n-\n     fLanguageBreakEngines = NULL;\n     fUnhandledBreakEngine = NULL;\n     fBreakCache           = NULL;\n     fDictionaryCache      = NULL;\n \n-    if (U_FAILURE(status)) {\n+    // Note: IBM xlC is unable to assign or initialize member fText from UTEXT_INITIALIZER.\n+    // fText                 = UTEXT_INITIALIZER;\n+    static const UText initializedUText = UTEXT_INITIALIZER;\n+    uprv_memcpy(&fText, &initializedUText, sizeof(UText));\n+\n+   if (U_FAILURE(status)) {\n         return;\n     }\n \n-    fText            = utext_openUChars(NULL, NULL, 0, &status);\n+    utext_openUChars(&fText, NULL, 0, &status);\n     fDictionaryCache = new DictionaryCache(this, status);\n     fBreakCache      = new BreakCache(this, status);\n-    if (U_SUCCESS(status) && (fText == NULL || fDictionaryCache == NULL || fBreakCache == NULL)) {\n+    if (U_SUCCESS(status) && (fDictionaryCache == NULL || fBreakCache == NULL)) {\n         status = U_MEMORY_ALLOCATION_ERROR;\n     }\n \n@@ -344,7 +349,7 @@ RuleBasedBreakIterator::operator==(const BreakIterator& that) const {\n \n     const RuleBasedBreakIterator& that2 = (const RuleBasedBreakIterator&) that;\n \n-    if (!utext_equals(fText, that2.fText)) {\n+    if (!utext_equals(&fText, &that2.fText)) {\n         // The two break iterators are operating on different text,\n         //   or have a different iteration position.\n         //   Note that fText's position is always the same as the break iterator's position.\n@@ -385,35 +390,28 @@ void RuleBasedBreakIterator::setText(UText *ut, UErrorCode &status) {\n     }\n     fBreakCache->reset();\n     fDictionaryCache->reset();\n-    fText = utext_clone(fText, ut, FALSE, TRUE, &status);\n+    utext_clone(&fText, ut, FALSE, TRUE, &status);\n \n     // Set up a dummy CharacterIterator to be returned if anyone\n     //   calls getText().  With input from UText, there is no reasonable\n     //   way to return a characterIterator over the actual input text.\n     //   Return one over an empty string instead - this is the closest\n     //   we can come to signaling a failure.\n     //   (GetText() is obsolete, this failure is sort of OK)\n-    if (fDCharIter == NULL) {\n-        static const UChar c = 0;\n-        fDCharIter = new UCharCharacterIterator(&c, 0);\n-        if (fDCharIter == NULL) {\n-            status = U_MEMORY_ALLOCATION_ERROR;\n-            return;\n-        }\n-    }\n+    fSCharIter.setText(UnicodeString());\n \n-    if (fCharIter!=fSCharIter && fCharIter!=fDCharIter) {\n+    if (fCharIter != &fSCharIter) {\n         // existing fCharIter was adopted from the outside.  Delete it now.\n         delete fCharIter;\n     }\n-    fCharIter = fDCharIter;\n+    fCharIter = &fSCharIter;\n \n     this->first();\n }\n \n \n UText *RuleBasedBreakIterator::getUText(UText *fillIn, UErrorCode &status) const {\n-    UText *result = utext_clone(fillIn, fText, FALSE, TRUE, &status);\n+    UText *result = utext_clone(fillIn, &fText, FALSE, TRUE, &status);\n     return result;\n }\n \n@@ -439,7 +437,7 @@ void\n RuleBasedBreakIterator::adoptText(CharacterIterator* newText) {\n     // If we are holding a CharacterIterator adopted from a\n     //   previous call to this function, delete it now.\n-    if (fCharIter!=fSCharIter && fCharIter!=fDCharIter) {\n+    if (fCharIter != &fSCharIter) {\n         delete fCharIter;\n     }\n \n@@ -450,9 +448,9 @@ RuleBasedBreakIterator::adoptText(CharacterIterator* newText) {\n     if (newText==NULL || newText->startIndex() != 0) {\n         // startIndex !=0 wants to be an error, but there's no way to report it.\n         // Make the iterator text be an empty string.\n-        fText = utext_openUChars(fText, NULL, 0, &status);\n+        utext_openUChars(&fText, NULL, 0, &status);\n     } else {\n-        fText = utext_openCharacterIterator(fText, newText, &status);\n+        utext_openCharacterIterator(&fText, newText, &status);\n     }\n     this->first();\n }\n@@ -467,23 +465,19 @@ RuleBasedBreakIterator::setText(const UnicodeString& newText) {\n     UErrorCode status = U_ZERO_ERROR;\n     fBreakCache->reset();\n     fDictionaryCache->reset();\n-    fText = utext_openConstUnicodeString(fText, &newText, &status);\n+    utext_openConstUnicodeString(&fText, &newText, &status);\n \n     // Set up a character iterator on the string.\n     //   Needed in case someone calls getText().\n     //  Can not, unfortunately, do this lazily on the (probably never)\n     //  call to getText(), because getText is const.\n-    if (fSCharIter == NULL) {\n-        fSCharIter = new StringCharacterIterator(newText);\n-    } else {\n-        fSCharIter->setText(newText);\n-    }\n+    fSCharIter.setText(newText);\n \n-    if (fCharIter!=fSCharIter && fCharIter!=fDCharIter) {\n+    if (fCharIter != &fSCharIter) {\n         // old fCharIter was adopted from the outside.  Delete it.\n         delete fCharIter;\n     }\n-    fCharIter = fSCharIter;\n+    fCharIter = &fSCharIter;\n \n     this->first();\n }\n@@ -503,14 +497,14 @@ RuleBasedBreakIterator &RuleBasedBreakIterator::refreshInputText(UText *input, U\n         status = U_ILLEGAL_ARGUMENT_ERROR;\n         return *this;\n     }\n-    int64_t pos = utext_getNativeIndex(fText);\n+    int64_t pos = utext_getNativeIndex(&fText);\n     //  Shallow read-only clone of the new UText into the existing input UText\n-    fText = utext_clone(fText, input, FALSE, TRUE, &status);\n+    utext_clone(&fText, input, FALSE, TRUE, &status);\n     if (U_FAILURE(status)) {\n         return *this;\n     }\n-    utext_setNativeIndex(fText, pos);\n-    if (utext_getNativeIndex(fText) != pos) {\n+    utext_setNativeIndex(&fText, pos);\n+    if (utext_getNativeIndex(&fText) != pos) {\n         // Sanity check.  The new input utext is supposed to have the exact same\n         // contents as the old.  If we can't set to the same position, it doesn't.\n         // The contents underlying the old utext might be invalid at this point,\n@@ -540,7 +534,7 @@ int32_t RuleBasedBreakIterator::first(void) {\n  * @return The text's past-the-end offset.\n  */\n int32_t RuleBasedBreakIterator::last(void) {\n-    int32_t endPos = (int32_t)utext_nativeLength(fText);\n+    int32_t endPos = (int32_t)utext_nativeLength(&fText);\n     UBool endShouldBeBoundary = isBoundary(endPos);      // Has side effect of setting iterator position.\n     (void)endShouldBeBoundary;\n     U_ASSERT(endShouldBeBoundary);\n@@ -611,8 +605,8 @@ int32_t RuleBasedBreakIterator::following(int32_t startPos) {\n \n     // Move requested offset to a code point start. It might be on a trail surrogate,\n     // or on a trail byte if the input is UTF-8. Or it may be beyond the end of the text.\n-    utext_setNativeIndex(fText, startPos);\n-    startPos = (int32_t)utext_getNativeIndex(fText);\n+    utext_setNativeIndex(&fText, startPos);\n+    startPos = (int32_t)utext_getNativeIndex(&fText);\n \n     UErrorCode status = U_ZERO_ERROR;\n     fBreakCache->following(startPos, status);\n@@ -626,15 +620,15 @@ int32_t RuleBasedBreakIterator::following(int32_t startPos) {\n  * @return The position of the last boundary before the starting position.\n  */\n int32_t RuleBasedBreakIterator::preceding(int32_t offset) {\n-    if (fText == NULL || offset > utext_nativeLength(fText)) {\n+    if (offset > utext_nativeLength(&fText)) {\n         return last();\n     }\n \n     // Move requested offset to a code point start. It might be on a trail surrogate,\n     // or on a trail byte if the input is UTF-8.\n \n-    utext_setNativeIndex(fText, offset);\n-    int32_t adjustedOffset = utext_getNativeIndex(fText);\n+    utext_setNativeIndex(&fText, offset);\n+    int32_t adjustedOffset = utext_getNativeIndex(&fText);\n \n     UErrorCode status = U_ZERO_ERROR;\n     fBreakCache->preceding(adjustedOffset, status);\n@@ -660,16 +654,16 @@ UBool RuleBasedBreakIterator::isBoundary(int32_t offset) {\n     // Note that isBoundary() is always be false for offsets that are not on code point boundaries.\n     // But we still need the side effect of leaving iteration at the following boundary.\n \n-    utext_setNativeIndex(fText, offset);\n-    int32_t adjustedOffset = utext_getNativeIndex(fText);\n+    utext_setNativeIndex(&fText, offset);\n+    int32_t adjustedOffset = utext_getNativeIndex(&fText);\n \n     bool result = false;\n     UErrorCode status = U_ZERO_ERROR;\n     if (fBreakCache->seek(adjustedOffset) || fBreakCache->populateNear(adjustedOffset, status)) {\n         result = (fBreakCache->current() == offset);\n     }\n \n-    if (result && adjustedOffset < offset && utext_char32At(fText, offset) == U_SENTINEL) {\n+    if (result && adjustedOffset < offset && utext_char32At(&fText, offset) == U_SENTINEL) {\n         // Original offset is beyond the end of the text. Return FALSE, it's not a boundary,\n         // but the iteration position remains set to the end of the text, which is a boundary.\n         return FALSE;\n@@ -789,9 +783,9 @@ int32_t RuleBasedBreakIterator::handleNext() {\n \n     // if we're already at the end of the text, return DONE.\n     initialPosition = fPosition;\n-    UTEXT_SETNATIVEINDEX(fText, initialPosition);\n+    UTEXT_SETNATIVEINDEX(&fText, initialPosition);\n     result          = initialPosition;\n-    c               = UTEXT_NEXT32(fText);\n+    c               = UTEXT_NEXT32(&fText);\n     if (c==U_SENTINEL) {\n         fDone = TRUE;\n         return UBRK_DONE;\n@@ -854,7 +848,7 @@ int32_t RuleBasedBreakIterator::handleNext() {\n \n        #ifdef RBBI_DEBUG\n             if (gTrace) {\n-                RBBIDebugPrintf(\"             %4ld   \", utext_getNativeIndex(fText));\n+                RBBIDebugPrintf(\"             %4ld   \", utext_getNativeIndex(&fText));\n                 if (0x20<=c && c<0x7f) {\n                     RBBIDebugPrintf(\"\\\"%c\\\"  \", c);\n                 } else {\n@@ -867,9 +861,7 @@ int32_t RuleBasedBreakIterator::handleNext() {\n         // State Transition - move machine to its next state\n         //\n \n-        // Note: fNextState is defined as uint16_t[2], but we are casting\n-        // a generated RBBI table to RBBIStateTableRow and some tables\n-        // actually have more than 2 categories.\n+        // fNextState is a variable-length array.\n         U_ASSERT(category<fData->fHeader->fCatCount);\n         state = row->fNextState[category];  /*Not accessing beyond memory*/\n         row = (RBBIStateTableRow *)\n@@ -880,7 +872,7 @@ int32_t RuleBasedBreakIterator::handleNext() {\n         if (row->fAccepting == -1) {\n             // Match found, common case.\n             if (mode != RBBI_START) {\n-                result = (int32_t)UTEXT_GETNATIVEINDEX(fText);\n+                result = (int32_t)UTEXT_GETNATIVEINDEX(&fText);\n             }\n             fRuleStatusIndex = row->fTagIdx;   // Remember the break status (tag) values.\n         }\n@@ -898,7 +890,7 @@ int32_t RuleBasedBreakIterator::handleNext() {\n         int16_t rule = row->fLookAhead;\n         if (rule != 0) {\n             // At the position of a '/' in a look-ahead match. Record it.\n-            int32_t  pos = (int32_t)UTEXT_GETNATIVEINDEX(fText);\n+            int32_t  pos = (int32_t)UTEXT_GETNATIVEINDEX(&fText);\n             lookAheadMatches.setPosition(rule, pos);\n         }\n \n@@ -914,7 +906,7 @@ int32_t RuleBasedBreakIterator::handleNext() {\n         //    the input position.  The next iteration will be processing the\n         //    first real input character.\n         if (mode == RBBI_RUN) {\n-            c = UTEXT_NEXT32(fText);\n+            c = UTEXT_NEXT32(&fText);\n         } else {\n             if (mode == RBBI_START) {\n                 mode = RBBI_RUN;\n@@ -928,9 +920,9 @@ int32_t RuleBasedBreakIterator::handleNext() {\n     //   (This really indicates a defect in the break rules.  They should always match\n     //    at least one character.)\n     if (result == initialPosition) {\n-        utext_setNativeIndex(fText, initialPosition);\n-        utext_next32(fText);\n-        result = (int32_t)utext_getNativeIndex(fText);\n+        utext_setNativeIndex(&fText, initialPosition);\n+        utext_next32(&fText);\n+        result = (int32_t)utext_getNativeIndex(&fText);\n         fRuleStatusIndex = 0;\n     }\n \n@@ -965,22 +957,22 @@ int32_t RuleBasedBreakIterator::handlePrevious(int32_t fromPosition) {\n     int32_t             initialPosition = 0;\n \n     const RBBIStateTable *stateTable = fData->fSafeRevTable;\n-    UTEXT_SETNATIVEINDEX(fText, fromPosition);\n+    UTEXT_SETNATIVEINDEX(&fText, fromPosition);\n     #ifdef RBBI_DEBUG\n         if (gTrace) {\n             RBBIDebugPuts(\"Handle Previous   pos   char  state category\");\n         }\n     #endif\n \n     // if we're already at the start of the text, return DONE.\n-    if (fText == NULL || fData == NULL || UTEXT_GETNATIVEINDEX(fText)==0) {\n+    if (fData == NULL || UTEXT_GETNATIVEINDEX(&fText)==0) {\n         return BreakIterator::DONE;\n     }\n \n     //  Set up the starting char.\n-    initialPosition = (int32_t)UTEXT_GETNATIVEINDEX(fText);\n+    initialPosition = (int32_t)UTEXT_GETNATIVEINDEX(&fText);\n     result          = initialPosition;\n-    c               = UTEXT_PREVIOUS32(fText);\n+    c               = UTEXT_PREVIOUS32(&fText);\n \n     //  Set the initial state for the state machine\n     state = START_STATE;\n@@ -1028,7 +1020,7 @@ int32_t RuleBasedBreakIterator::handlePrevious(int32_t fromPosition) {\n \n         #ifdef RBBI_DEBUG\n             if (gTrace) {\n-                RBBIDebugPrintf(\"             %4d   \", (int32_t)utext_getNativeIndex(fText));\n+                RBBIDebugPrintf(\"             %4d   \", (int32_t)utext_getNativeIndex(&fText));\n                 if (0x20<=c && c<0x7f) {\n                     RBBIDebugPrintf(\"\\\"%c\\\"  \", c);\n                 } else {\n@@ -1041,32 +1033,30 @@ int32_t RuleBasedBreakIterator::handlePrevious(int32_t fromPosition) {\n         // State Transition - move machine to its next state\n         //\n \n-        // Note: fNextState is defined as uint16_t[2], but we are casting\n-        // a generated RBBI table to RBBIStateTableRow and some tables\n-        // actually have more than 2 categories.\n+        // fNextState is a variable-length array.\n         U_ASSERT(category<fData->fHeader->fCatCount);\n         state = row->fNextState[category];  /*Not accessing beyond memory*/\n         row = (RBBIStateTableRow *)\n             (stateTable->fTableData + (stateTable->fRowLen * state));\n \n         if (row->fAccepting == -1) {\n             // Match found, common case.\n-            result = (int32_t)UTEXT_GETNATIVEINDEX(fText);\n+            result = (int32_t)UTEXT_GETNATIVEINDEX(&fText);\n         }\n \n         int16_t completedRule = row->fAccepting;\n         if (completedRule > 0) {\n             // Lookahead match is completed.\n             int32_t lookaheadResult = lookAheadMatches.getPosition(completedRule);\n             if (lookaheadResult >= 0) {\n-                UTEXT_SETNATIVEINDEX(fText, lookaheadResult);\n+                UTEXT_SETNATIVEINDEX(&fText, lookaheadResult);\n                 return lookaheadResult;\n             }\n         }\n         int16_t rule = row->fLookAhead;\n         if (rule != 0) {\n             // At the position of a '/' in a look-ahead match. Record it.\n-            int32_t  pos = (int32_t)UTEXT_GETNATIVEINDEX(fText);\n+            int32_t  pos = (int32_t)UTEXT_GETNATIVEINDEX(&fText);\n             lookAheadMatches.setPosition(rule, pos);\n         }\n \n@@ -1082,7 +1072,7 @@ int32_t RuleBasedBreakIterator::handlePrevious(int32_t fromPosition) {\n         //    the input position.  The next iteration will be processing the\n         //    first real input character.\n         if (mode == RBBI_RUN) {\n-            c = UTEXT_PREVIOUS32(fText);\n+            c = UTEXT_PREVIOUS32(&fText);\n         } else {\n             if (mode == RBBI_START) {\n                 mode = RBBI_RUN;\n@@ -1096,9 +1086,9 @@ int32_t RuleBasedBreakIterator::handlePrevious(int32_t fromPosition) {\n     //   (This really indicates a defect in the break rules.  They should always match\n     //    at least one character.)\n     if (result == initialPosition) {\n-        UTEXT_SETNATIVEINDEX(fText, initialPosition);\n-        UTEXT_PREVIOUS32(fText);\n-        result = (int32_t)UTEXT_GETNATIVEINDEX(fText);\n+        UTEXT_SETNATIVEINDEX(&fText, initialPosition);\n+        UTEXT_PREVIOUS32(&fText);\n+        result = (int32_t)UTEXT_GETNATIVEINDEX(&fText);\n     }\n \n     #ifdef RBBI_DEBUG\n@@ -1247,7 +1237,7 @@ static void U_CALLCONV initLanguageFactories() {\n \n \n static const LanguageBreakEngine*\n-getLanguageBreakEngineFromFactory(UChar32 c, int32_t breakType)\n+getLanguageBreakEngineFromFactory(UChar32 c)\n {\n     umtx_initOnce(gLanguageBreakFactoriesInitOnce, &initLanguageFactories);\n     if (gLanguageBreakFactories == NULL) {\n@@ -1258,7 +1248,7 @@ getLanguageBreakEngineFromFactory(UChar32 c, int32_t breakType)\n     const LanguageBreakEngine *lbe = NULL;\n     while (--i >= 0) {\n         LanguageBreakFactory *factory = (LanguageBreakFactory *)(gLanguageBreakFactories->elementAt(i));\n-        lbe = factory->getEngineFor(c, breakType);\n+        lbe = factory->getEngineFor(c);\n         if (lbe != NULL) {\n             break;\n         }\n@@ -1290,14 +1280,14 @@ RuleBasedBreakIterator::getLanguageBreakEngine(UChar32 c) {\n     int32_t i = fLanguageBreakEngines->size();\n     while (--i >= 0) {\n         lbe = (const LanguageBreakEngine *)(fLanguageBreakEngines->elementAt(i));\n-        if (lbe->handles(c, fBreakType)) {\n+        if (lbe->handles(c)) {\n             return lbe;\n         }\n     }\n \n     // No existing dictionary took the character. See if a factory wants to\n     // give us a new LanguageBreakEngine for this character.\n-    lbe = getLanguageBreakEngineFromFactory(c, fBreakType);\n+    lbe = getLanguageBreakEngineFromFactory(c);\n \n     // If we got one, use it and push it on our stack.\n     if (lbe != NULL) {\n@@ -1313,6 +1303,7 @@ RuleBasedBreakIterator::getLanguageBreakEngine(UChar32 c) {\n         fUnhandledBreakEngine = new UnhandledEngine(status);\n         if (U_SUCCESS(status) && fUnhandledBreakEngine == NULL) {\n             status = U_MEMORY_ALLOCATION_ERROR;\n+            return nullptr;\n         }\n         // Put it last so that scripts for which we have an engine get tried\n         // first.\n@@ -1327,25 +1318,19 @@ RuleBasedBreakIterator::getLanguageBreakEngine(UChar32 c) {\n \n     // Tell the reject engine about the character; at its discretion, it may\n     // add more than just the one character.\n-    fUnhandledBreakEngine->handleCharacter(c, fBreakType);\n+    fUnhandledBreakEngine->handleCharacter(c);\n \n     return fUnhandledBreakEngine;\n }\n \n-\n-\n-/*int32_t RuleBasedBreakIterator::getBreakType() const {\n-    return fBreakType;\n-}*/\n-\n-void RuleBasedBreakIterator::setBreakType(int32_t type) {\n-    fBreakType = type;\n-}\n-\n void RuleBasedBreakIterator::dumpCache() {\n     fBreakCache->dumpCache();\n }\n \n+void RuleBasedBreakIterator::dumpTables() {\n+    fData->printData();\n+}\n+\n /**\n  * Returns the description used to create this iterator\n  */"
        },
        {
            "sha": "ba9329d4771321b2181d80b55c4d5e741a8e209c",
            "filename": "deps/icu-small/source/common/rbbi_cache.cpp",
            "status": "modified",
            "additions": 22,
            "deletions": 25,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi_cache.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi_cache.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi_cache.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -26,14 +26,11 @@ U_NAMESPACE_BEGIN\n  */\n \n RuleBasedBreakIterator::DictionaryCache::DictionaryCache(RuleBasedBreakIterator *bi, UErrorCode &status) :\n-        fBI(bi), fBreaks(NULL), fPositionInCache(-1),\n+        fBI(bi), fBreaks(status), fPositionInCache(-1),\n         fStart(0), fLimit(0), fFirstRuleStatusIndex(0), fOtherRuleStatusIndex(0) {\n-    fBreaks = new UVector32(status);\n }\n \n RuleBasedBreakIterator::DictionaryCache::~DictionaryCache() {\n-    delete fBreaks;\n-    fBreaks = NULL;\n }\n \n void RuleBasedBreakIterator::DictionaryCache::reset() {\n@@ -42,7 +39,7 @@ void RuleBasedBreakIterator::DictionaryCache::reset() {\n     fLimit = 0;\n     fFirstRuleStatusIndex = 0;\n     fOtherRuleStatusIndex = 0;\n-    fBreaks->removeAllElements();\n+    fBreaks.removeAllElements();\n }\n \n UBool RuleBasedBreakIterator::DictionaryCache::following(int32_t fromPos, int32_t *result, int32_t *statusIndex) {\n@@ -54,13 +51,13 @@ UBool RuleBasedBreakIterator::DictionaryCache::following(int32_t fromPos, int32_\n     // Sequential iteration, move from previous boundary to the following\n \n     int32_t r = 0;\n-    if (fPositionInCache >= 0 && fPositionInCache < fBreaks->size() && fBreaks->elementAti(fPositionInCache) == fromPos) {\n+    if (fPositionInCache >= 0 && fPositionInCache < fBreaks.size() && fBreaks.elementAti(fPositionInCache) == fromPos) {\n         ++fPositionInCache;\n-        if (fPositionInCache >= fBreaks->size()) {\n+        if (fPositionInCache >= fBreaks.size()) {\n             fPositionInCache = -1;\n             return FALSE;\n         }\n-        r = fBreaks->elementAti(fPositionInCache);\n+        r = fBreaks.elementAti(fPositionInCache);\n         U_ASSERT(r > fromPos);\n         *result = r;\n         *statusIndex = fOtherRuleStatusIndex;\n@@ -69,8 +66,8 @@ UBool RuleBasedBreakIterator::DictionaryCache::following(int32_t fromPos, int32_\n \n     // Random indexing. Linear search for the boundary following the given position.\n \n-    for (fPositionInCache = 0; fPositionInCache < fBreaks->size(); ++fPositionInCache) {\n-        r= fBreaks->elementAti(fPositionInCache);\n+    for (fPositionInCache = 0; fPositionInCache < fBreaks.size(); ++fPositionInCache) {\n+        r= fBreaks.elementAti(fPositionInCache);\n         if (r > fromPos) {\n             *result = r;\n             *statusIndex = fOtherRuleStatusIndex;\n@@ -90,16 +87,16 @@ UBool RuleBasedBreakIterator::DictionaryCache::preceding(int32_t fromPos, int32_\n     }\n \n     if (fromPos == fLimit) {\n-        fPositionInCache = fBreaks->size() - 1;\n+        fPositionInCache = fBreaks.size() - 1;\n         if (fPositionInCache >= 0) {\n-            U_ASSERT(fBreaks->elementAti(fPositionInCache) == fromPos);\n+            U_ASSERT(fBreaks.elementAti(fPositionInCache) == fromPos);\n         }\n     }\n \n     int32_t r;\n-    if (fPositionInCache > 0 && fPositionInCache < fBreaks->size() && fBreaks->elementAti(fPositionInCache) == fromPos) {\n+    if (fPositionInCache > 0 && fPositionInCache < fBreaks.size() && fBreaks.elementAti(fPositionInCache) == fromPos) {\n         --fPositionInCache;\n-        r = fBreaks->elementAti(fPositionInCache);\n+        r = fBreaks.elementAti(fPositionInCache);\n         U_ASSERT(r < fromPos);\n         *result = r;\n         *statusIndex = ( r== fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;\n@@ -111,8 +108,8 @@ UBool RuleBasedBreakIterator::DictionaryCache::preceding(int32_t fromPos, int32_\n         return FALSE;\n     }\n \n-    for (fPositionInCache = fBreaks->size()-1; fPositionInCache >= 0; --fPositionInCache) {\n-        r = fBreaks->elementAti(fPositionInCache);\n+    for (fPositionInCache = fBreaks.size()-1; fPositionInCache >= 0; --fPositionInCache) {\n+        r = fBreaks.elementAti(fPositionInCache);\n         if (r < fromPos) {\n             *result = r;\n             *statusIndex = ( r == fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;\n@@ -141,7 +138,7 @@ void RuleBasedBreakIterator::DictionaryCache::populateDictionary(int32_t startPo\n     int32_t     current;\n     UErrorCode  status = U_ZERO_ERROR;\n     int32_t     foundBreakCount = 0;\n-    UText      *text = fBI->fText;\n+    UText      *text = &fBI->fText;\n \n     // Loop through the text, looking for ranges of dictionary characters.\n     // For each span, find the appropriate break engine, and ask it to find\n@@ -168,7 +165,7 @@ void RuleBasedBreakIterator::DictionaryCache::populateDictionary(int32_t startPo\n         // Ask the language object if there are any breaks. It will add them to the cache and\n         // leave the text pointer on the other side of its range, ready to search for the next one.\n         if (lbe != NULL) {\n-            foundBreakCount += lbe->findBreaks(text, rangeStart, rangeEnd, fBI->fBreakType, *fBreaks);\n+            foundBreakCount += lbe->findBreaks(text, rangeStart, rangeEnd, fBreaks);\n         }\n \n         // Reload the loop variables for the next go-round\n@@ -182,21 +179,21 @@ void RuleBasedBreakIterator::DictionaryCache::populateDictionary(int32_t startPo\n \n     // printf(\"foundBreakCount = %d\\n\", foundBreakCount);\n     if (foundBreakCount > 0) {\n-        U_ASSERT(foundBreakCount == fBreaks->size());\n-        if (startPos < fBreaks->elementAti(0)) {\n+        U_ASSERT(foundBreakCount == fBreaks.size());\n+        if (startPos < fBreaks.elementAti(0)) {\n             // The dictionary did not place a boundary at the start of the segment of text.\n             // Add one now. This should not commonly happen, but it would be easy for interactions\n             // of the rules for dictionary segments and the break engine implementations to\n             // inadvertently cause it. Cover it here, just in case.\n-            fBreaks->insertElementAt(startPos, 0, status);\n+            fBreaks.insertElementAt(startPos, 0, status);\n         }\n-        if (endPos > fBreaks->peeki()) {\n-            fBreaks->push(endPos, status);\n+        if (endPos > fBreaks.peeki()) {\n+            fBreaks.push(endPos, status);\n         }\n         fPositionInCache = 0;\n         // Note: Dictionary matching may extend beyond the original limit.\n-        fStart = fBreaks->elementAti(0);\n-        fLimit = fBreaks->peeki();\n+        fStart = fBreaks.elementAti(0);\n+        fLimit = fBreaks.peeki();\n     } else {\n         // there were no language-based breaks, even though the segment contained\n         // dictionary characters. Subsequent attempts to fetch boundaries from the dictionary cache"
        },
        {
            "sha": "fd6deb4333a97eda86e2ea9c4dbfc2fd4708493d",
            "filename": "deps/icu-small/source/common/rbbi_cache.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi_cache.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi_cache.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi_cache.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -56,7 +56,7 @@ class RuleBasedBreakIterator::DictionaryCache: public UMemory {\n \n     RuleBasedBreakIterator *fBI;\n \n-    UVector32          *fBreaks;                // A vector containing the boundaries.\n+    UVector32           fBreaks;                // A vector containing the boundaries.\n     int32_t             fPositionInCache;       // Index in fBreaks of last boundary returned by following()\n                                                 //    or preceding(). Optimizes sequential access.\n     int32_t             fStart;                 // Text position of first boundary in cache."
        },
        {
            "sha": "18912a6a7b3dcfb7e8b2af17d1f90aade75c7f4e",
            "filename": "deps/icu-small/source/common/rbbidata.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbidata.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbidata.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbidata.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -267,8 +267,8 @@ void  RBBIDataWrapper::printTable(const char *heading, const RBBIStateTable *tab\n #endif\n \n \n-#ifdef RBBI_DEBUG\n void  RBBIDataWrapper::printData() {\n+#ifdef RBBI_DEBUG\n     RBBIDebugPrintf(\"RBBI Data at %p\\n\", (void *)fHeader);\n     RBBIDebugPrintf(\"   Version = {%d %d %d %d}\\n\", fHeader->fFormatVersion[0], fHeader->fFormatVersion[1],\n                                                     fHeader->fFormatVersion[2], fHeader->fFormatVersion[3]);\n@@ -285,8 +285,8 @@ void  RBBIDataWrapper::printData() {\n         RBBIDebugPrintf(\"%c\", fRuleSource[c]);\n     }\n     RBBIDebugPrintf(\"\\n\\n\");\n-}\n #endif\n+}\n \n \n U_NAMESPACE_END"
        },
        {
            "sha": "8b21acca304d5fe0c32c7fd9926de1079449f1fd",
            "filename": "deps/icu-small/source/common/rbbidata.h",
            "status": "modified",
            "additions": 7,
            "deletions": 9,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbidata.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbidata.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbidata.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -116,9 +116,10 @@ struct  RBBIStateTableRow {\n                                     /*     StatusTable of the set of matching             */\n                                     /*     tags (rule status values)                      */\n     int16_t          fReserved;\n-    uint16_t         fNextState[2]; /*  Next State, indexed by char category.             */\n-                                    /*  This array does not have two elements             */\n-                                    /*    Array Size is actually fData->fHeader->fCatCount         */\n+    uint16_t         fNextState[1]; /*  Next State, indexed by char category.             */\n+                                    /*    Variable-length array declared with length 1    */\n+                                    /*    to disable bounds checkers.                     */\n+                                    /*    Array Size is actually fData->fHeader->fCatCount*/\n                                     /*    CAUTION:  see RBBITableBuilder::getTableSize()  */\n                                     /*              before changing anything here.        */\n };\n@@ -129,7 +130,9 @@ struct RBBIStateTable {\n     uint32_t         fRowLen;       /*  Length of a state table row, in bytes.            */\n     uint32_t         fFlags;        /*  Option Flags for this state table                 */\n     uint32_t         fReserved;     /*  reserved                                          */\n-    char             fTableData[4]; /*  First RBBIStateTableRow begins here.              */\n+    char             fTableData[1]; /*  First RBBIStateTableRow begins here.              */\n+                                    /*    Variable-length array declared with length 1    */\n+                                    /*    to disable bounds checkers.                     */\n                                     /*    (making it char[] simplifies ugly address       */\n                                     /*     arithmetic for indexing variable length rows.) */\n };\n@@ -162,13 +165,8 @@ class RBBIDataWrapper : public UMemory {\n     UBool                 operator ==(const RBBIDataWrapper &other) const;\n     int32_t               hashCode();\n     const UnicodeString  &getRuleSourceString() const;\n-#ifdef RBBI_DEBUG\n     void                  printData();\n     void                  printTable(const char *heading, const RBBIStateTable *table);\n-#else\n-    #define printData()\n-    #define printTable(heading, table)\n-#endif\n \n     /*                                     */\n     /*   Pointers to items within the data */"
        },
        {
            "sha": "9fc8f8e814200a8b355d16801d3f994bc9642977",
            "filename": "deps/icu-small/source/common/rbbirb.cpp",
            "status": "modified",
            "additions": 37,
            "deletions": 8,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbirb.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbirb.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbirb.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -47,7 +47,7 @@ U_NAMESPACE_BEGIN\n RBBIRuleBuilder::RBBIRuleBuilder(const UnicodeString   &rules,\n                                        UParseError     *parseErr,\n                                        UErrorCode      &status)\n- : fRules(rules)\n+ : fRules(rules), fStrippedRules(rules)\n {\n     fStatus = &status; // status is checked below\n     fParseError = parseErr;\n@@ -147,8 +147,9 @@ RBBIDataHeader *RBBIRuleBuilder::flattenData() {\n         return NULL;\n     }\n \n-    // Remove comments and whitespace from the rules to make it smaller.\n-    UnicodeString strippedRules((const UnicodeString&)RBBIRuleScanner::stripRules(fRules));\n+    // Remove whitespace from the rules to make it smaller.\n+    // The rule parser has already removed comments.\n+    fStrippedRules = fScanner->stripRules(fStrippedRules);\n \n     // Calculate the size of each section in the data.\n     //   Sizes here are padded up to a multiple of 8 for better memory alignment.\n@@ -162,7 +163,7 @@ RBBIDataHeader *RBBIRuleBuilder::flattenData() {\n     int32_t safeRevTableSize  = align8(fSafeRevTables->getTableSize());\n     int32_t trieSize          = align8(fSetBuilder->getTrieSize());\n     int32_t statusTableSize   = align8(fRuleStatusVals->size() * sizeof(int32_t));\n-    int32_t rulesSize         = align8((strippedRules.length()+1) * sizeof(UChar));\n+    int32_t rulesSize         = align8((fStrippedRules.length()+1) * sizeof(UChar));\n \n     (void)safeFwdTableSize;\n \n@@ -225,7 +226,7 @@ RBBIDataHeader *RBBIRuleBuilder::flattenData() {\n     data->fStatusTable   = data->fTrie    + trieSize;\n     data->fStatusTableLen= statusTableSize;\n     data->fRuleSource    = data->fStatusTable + statusTableSize;\n-    data->fRuleSourceLen = strippedRules.length() * sizeof(UChar);\n+    data->fRuleSourceLen = fStrippedRules.length() * sizeof(UChar);\n \n     uprv_memset(data->fReserved, 0, sizeof(data->fReserved));\n \n@@ -245,7 +246,7 @@ RBBIDataHeader *RBBIRuleBuilder::flattenData() {\n         ruleStatusTable[i] = fRuleStatusVals->elementAti(i);\n     }\n \n-    strippedRules.extract((UChar *)((uint8_t *)data+data->fRuleSource), rulesSize/2+1, *fStatus);\n+    fStrippedRules.extract((UChar *)((uint8_t *)data+data->fRuleSource), rulesSize/2+1, *fStatus);\n \n     return data;\n }\n@@ -281,10 +282,10 @@ RBBIRuleBuilder::createRuleBasedBreakIterator( const UnicodeString    &rules,\n     //\n     // UnicodeSet processing.\n     //    Munge the Unicode Sets to create a set of character categories.\n-    //    Generate the mapping tables (TRIE) from input 32-bit characters to\n+    //    Generate the mapping tables (TRIE) from input code points to\n     //    the character categories.\n     //\n-    builder.fSetBuilder->build();\n+    builder.fSetBuilder->buildRanges();\n \n \n     //\n@@ -316,6 +317,11 @@ RBBIRuleBuilder::createRuleBasedBreakIterator( const UnicodeString    &rules,\n     }\n #endif\n \n+    builder.optimizeTables();\n+    builder.fSetBuilder->buildTrie();\n+\n+\n+\n     //\n     //   Package up the compiled data into a memory image\n     //      in the run-time format.\n@@ -347,6 +353,29 @@ RBBIRuleBuilder::createRuleBasedBreakIterator( const UnicodeString    &rules,\n     return This;\n }\n \n+void RBBIRuleBuilder::optimizeTables() {\n+    int32_t leftClass;\n+    int32_t rightClass;\n+\n+    leftClass = 3;\n+    rightClass = 0;\n+    while (fForwardTables->findDuplCharClassFrom(leftClass, rightClass)) {\n+        fSetBuilder->mergeCategories(leftClass, rightClass);\n+        fForwardTables->removeColumn(rightClass);\n+        fReverseTables->removeColumn(rightClass);\n+        fSafeFwdTables->removeColumn(rightClass);\n+        fSafeRevTables->removeColumn(rightClass);\n+    }\n+\n+    fForwardTables->removeDuplicateStates();\n+    fReverseTables->removeDuplicateStates();\n+    fSafeFwdTables->removeDuplicateStates();\n+    fSafeRevTables->removeDuplicateStates();\n+\n+\n+\n+}\n+\n U_NAMESPACE_END\n \n #endif /* #if !UCONFIG_NO_BREAK_ITERATION */"
        },
        {
            "sha": "511f394b458e93fb83847da94209f13eccbb741c",
            "filename": "deps/icu-small/source/common/rbbirb.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbirb.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbirb.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbirb.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -126,10 +126,19 @@ class RBBIRuleBuilder : public UMemory {\n         );\n \n     virtual    ~RBBIRuleBuilder();\n+\n+    /**\n+     * Fold together redundant character classes (table columns) and\n+     * redundant states (table rows). Done after initial table generation,\n+     * before serializing the result.\n+     */\n+    void optimizeTables();\n+\n     char                          *fDebugEnv;        // controls debug trace output\n     UErrorCode                    *fStatus;          // Error reporting.  Keeping status\n     UParseError                   *fParseError;      //   here avoids passing it everywhere.\n     const UnicodeString           &fRules;           // The rule string that we are compiling\n+    UnicodeString                 fStrippedRules;    // The rule string, with comments stripped.\n \n     RBBIRuleScanner               *fScanner;         // The scanner.\n     RBBINode                      *fForwardTree;     // The parse trees, generated by the scanner,"
        },
        {
            "sha": "e3472ed599e15e6f22ddddbdee3fdaae05d7b825",
            "filename": "deps/icu-small/source/common/rbbiscan.cpp",
            "status": "modified",
            "additions": 16,
            "deletions": 15,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbiscan.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbiscan.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbiscan.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -822,27 +822,24 @@ static const UChar      chRParen    = 0x29;\n \n //------------------------------------------------------------------------------\n //\n-//  stripRules    Return a rules string without unnecessary\n-//                characters.\n+//  stripRules    Return a rules string without extra spaces.\n+//                (Comments are removed separately, during rule parsing.)\n //\n //------------------------------------------------------------------------------\n UnicodeString RBBIRuleScanner::stripRules(const UnicodeString &rules) {\n     UnicodeString strippedRules;\n-    int rulesLength = rules.length();\n-    for (int idx = 0; idx < rulesLength; ) {\n-        UChar ch = rules[idx++];\n-        if (ch == chPound) {\n-            while (idx < rulesLength\n-                && ch != chCR && ch != chLF && ch != chNEL)\n-            {\n-                ch = rules[idx++];\n-            }\n-        }\n-        if (!u_isISOControl(ch)) {\n-            strippedRules.append(ch);\n+    int32_t rulesLength = rules.length();\n+    bool skippingSpaces = false;\n+\n+    for (int32_t idx=0; idx<rulesLength; idx = rules.moveIndex32(idx, 1)) {\n+        UChar32 cp = rules.char32At(idx);\n+        bool whiteSpace = u_hasBinaryProperty(cp, UCHAR_PATTERN_WHITE_SPACE);\n+        if (skippingSpaces && whiteSpace) {\n+            continue;\n         }\n+        strippedRules.append(cp);\n+        skippingSpaces = whiteSpace;\n     }\n-    // strippedRules = strippedRules.unescape();\n     return strippedRules;\n }\n \n@@ -942,6 +939,7 @@ void RBBIRuleScanner::nextChar(RBBIRuleChar &c) {\n             //  It will be treated as white-space, and serves to break up anything\n             //    that might otherwise incorrectly clump together with a comment in\n             //    the middle (a variable name, for example.)\n+            int32_t commentStart = fScanIndex;\n             for (;;) {\n                 c.fChar = nextCharLL();\n                 if (c.fChar == (UChar32)-1 ||  // EOF\n@@ -950,6 +948,9 @@ void RBBIRuleScanner::nextChar(RBBIRuleChar &c) {\n                     c.fChar == chNEL    ||\n                     c.fChar == chLS)       {break;}\n             }\n+            for (int32_t i=commentStart; i<fNextIndex-1; ++i) {\n+                fRB->fStrippedRules.setCharAt(i, u' ');\n+            }\n         }\n         if (c.fChar == (UChar32)-1) {\n             return;"
        },
        {
            "sha": "4e7389b4af039b3d831c7f634177581bff86d60e",
            "filename": "deps/icu-small/source/common/rbbisetb.cpp",
            "status": "modified",
            "additions": 38,
            "deletions": 17,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbisetb.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbisetb.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbisetb.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -91,7 +91,7 @@ RBBISetBuilder::~RBBISetBuilder()\n //                  from the Unicode Sets.\n //\n //------------------------------------------------------------------------\n-void RBBISetBuilder::build() {\n+void RBBISetBuilder::buildRanges() {\n     RBBINode        *usetNode;\n     RangeDescriptor *rlRange;\n \n@@ -245,11 +245,16 @@ void RBBISetBuilder::build() {\n \n     if (fRB->fDebugEnv && uprv_strstr(fRB->fDebugEnv, \"rgroup\")) {printRangeGroups();}\n     if (fRB->fDebugEnv && uprv_strstr(fRB->fDebugEnv, \"esets\")) {printSets();}\n+}\n+\n+\n+//\n+// Build the Trie table for mapping UChar32 values to the corresponding\n+// range group number.\n+//\n+void RBBISetBuilder::buildTrie() {\n+    RangeDescriptor *rlRange;\n \n-    //\n-    // Build the Trie table for mapping UChar32 values to the corresponding\n-    //   range group number\n-    //\n     fTrie = utrie2_open(0,       //  Initial value for all code points.\n                         0,       //  Error value for out-of-range input.\n                         fStatus);\n@@ -265,6 +270,22 @@ void RBBISetBuilder::build() {\n }\n \n \n+void RBBISetBuilder::mergeCategories(int32_t left, int32_t right) {\n+    U_ASSERT(left >= 1);\n+    U_ASSERT(right > left);\n+    for (RangeDescriptor *rd = fRangeList; rd != nullptr; rd = rd->fNext) {\n+        int32_t rangeNum = rd->fNum & ~DICT_BIT;\n+        int32_t rangeDict = rd->fNum & DICT_BIT;\n+        if (rangeNum == right) {\n+            rd->fNum = left | rangeDict;\n+        } else if (rangeNum > right) {\n+            rd->fNum--;\n+        }\n+    }\n+    --fGroupCount;\n+}\n+\n+\n //-----------------------------------------------------------------------------------\n //\n //  getTrieSize()    Return the size that will be required to serialize the Trie.\n@@ -446,7 +467,7 @@ void RBBISetBuilder::printRangeGroups() {\n             lastPrintedGroupNum = groupNum;\n             RBBIDebugPrintf(\"%2i  \", groupNum);\n \n-            if (rlRange->fNum & 0x4000) { RBBIDebugPrintf(\" <DICT> \");}\n+            if (rlRange->fNum & DICT_BIT) { RBBIDebugPrintf(\" <DICT> \");}\n \n             for (i=0; i<rlRange->fIncludesSets->size(); i++) {\n                 RBBINode       *usetNode    = (RBBINode *)rlRange->fIncludesSets->elementAt(i);\n@@ -639,20 +660,20 @@ void RangeDescriptor::split(UChar32 where, UErrorCode &status) {\n void RangeDescriptor::setDictionaryFlag() {\n     int i;\n \n-    for (i=0; i<this->fIncludesSets->size(); i++) {\n-        RBBINode       *usetNode    = (RBBINode *)fIncludesSets->elementAt(i);\n-        UnicodeString   setName;\n-        RBBINode       *setRef = usetNode->fParent;\n-        if (setRef != NULL) {\n+    static const char16_t *dictionary = u\"dictionary\";\n+    for (i=0; i<fIncludesSets->size(); i++) {\n+        RBBINode *usetNode  = (RBBINode *)fIncludesSets->elementAt(i);\n+        RBBINode *setRef = usetNode->fParent;\n+        if (setRef != nullptr) {\n             RBBINode *varRef = setRef->fParent;\n-            if (varRef != NULL  &&  varRef->fType == RBBINode::varRef) {\n-                setName = varRef->fText;\n+            if (varRef && varRef->fType == RBBINode::varRef) {\n+                const UnicodeString *setName = &varRef->fText;\n+                if (setName->compare(dictionary, -1) == 0) {\n+                    fNum |= RBBISetBuilder::DICT_BIT;\n+                    break;\n+                }\n             }\n         }\n-        if (setName.compare(UNICODE_STRING(\"dictionary\", 10)) == 0) {   // TODO:  no string literals.\n-            this->fNum |= 0x4000;\n-            break;\n-        }\n     }\n }\n "
        },
        {
            "sha": "a7a91b3b375b75aa625b33c5a58c26c19801d2c5",
            "filename": "deps/icu-small/source/common/rbbisetb.h",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbisetb.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbisetb.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbisetb.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -82,7 +82,8 @@ class RBBISetBuilder : public UMemory {\n     RBBISetBuilder(RBBIRuleBuilder *rb);\n     ~RBBISetBuilder();\n \n-    void     build();\n+    void     buildRanges();\n+    void     buildTrie();\n     void     addValToSets(UVector *sets,      uint32_t val);\n     void     addValToSet (RBBINode *usetNode, uint32_t val);\n     int32_t  getNumCharCategories() const;   // CharCategories are the same as input symbol set to the\n@@ -93,6 +94,13 @@ class RBBISetBuilder : public UMemory {\n     UChar32  getFirstChar(int32_t  val) const;\n     UBool    sawBOF() const;                 // Indicate whether any references to the {bof} pseudo\n                                              //   character were encountered.\n+    /** merge two character categories that have been identified as having equivalent behavior.\n+     *  The ranges belonging to the right category (table column) will be added to the left.\n+     */\n+    void     mergeCategories(int32_t left, int32_t right);\n+\n+    static constexpr int32_t DICT_BIT = 0x4000;\n+\n #ifdef RBBI_DEBUG\n     void     printSets();\n     void     printRanges();"
        },
        {
            "sha": "61661a544249e2e056c63884af627046475b5c2e",
            "filename": "deps/icu-small/source/common/rbbitblb.cpp",
            "status": "modified",
            "additions": 131,
            "deletions": 13,
            "changes": 144,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -22,6 +22,7 @@\n #include \"rbbidata.h\"\n #include \"cstring.h\"\n #include \"uassert.h\"\n+#include \"uvectr32.h\"\n #include \"cmemory.h\"\n \n U_NAMESPACE_BEGIN\n@@ -761,7 +762,7 @@ void     RBBITableBuilder::flagAcceptingStates() {\n                 // if sd->fAccepting already had a value other than 0 or -1, leave it be.\n \n                 // If the end marker node is from a look-ahead rule, set\n-                //   the fLookAhead field or this state also.\n+                //   the fLookAhead field for this state also.\n                 if (endMarker->fLookAheadEnd) {\n                     // TODO:  don't change value if already set?\n                     // TODO:  allow for more than one active look-ahead rule in engine.\n@@ -1077,7 +1078,128 @@ void RBBITableBuilder::printPosSets(RBBINode *n) {\n }\n #endif\n \n+//\n+//    findDuplCharClassFrom()\n+//\n+bool RBBITableBuilder::findDuplCharClassFrom(int32_t &baseCategory, int32_t &duplCategory) {\n+    int32_t numStates = fDStates->size();\n+    int32_t numCols = fRB->fSetBuilder->getNumCharCategories();\n+\n+    uint16_t table_base;\n+    uint16_t table_dupl;\n+    for (; baseCategory < numCols-1; ++baseCategory) {\n+        for (duplCategory=baseCategory+1; duplCategory < numCols; ++duplCategory) {\n+             for (int32_t state=0; state<numStates; state++) {\n+                 RBBIStateDescriptor *sd = (RBBIStateDescriptor *)fDStates->elementAt(state);\n+                 table_base = (uint16_t)sd->fDtran->elementAti(baseCategory);\n+                 table_dupl = (uint16_t)sd->fDtran->elementAti(duplCategory);\n+                 if (table_base != table_dupl) {\n+                     break;\n+                 }\n+             }\n+             if (table_base == table_dupl) {\n+                 return true;\n+             }\n+        }\n+    }\n+    return false;\n+}\n+\n+\n+//\n+//    removeColumn()\n+//\n+void RBBITableBuilder::removeColumn(int32_t column) {\n+    int32_t numStates = fDStates->size();\n+    for (int32_t state=0; state<numStates; state++) {\n+        RBBIStateDescriptor *sd = (RBBIStateDescriptor *)fDStates->elementAt(state);\n+        U_ASSERT(column < sd->fDtran->size());\n+        sd->fDtran->removeElementAt(column);\n+    }\n+}\n+\n+/*\n+ * findDuplicateState\n+ */\n+bool RBBITableBuilder::findDuplicateState(int32_t &firstState, int32_t &duplState) {\n+    int32_t numStates = fDStates->size();\n+    int32_t numCols = fRB->fSetBuilder->getNumCharCategories();\n+\n+    for (; firstState<numStates-1; ++firstState) {\n+        RBBIStateDescriptor *firstSD = (RBBIStateDescriptor *)fDStates->elementAt(firstState);\n+        for (duplState=firstState+1; duplState<numStates; ++duplState) {\n+            RBBIStateDescriptor *duplSD = (RBBIStateDescriptor *)fDStates->elementAt(duplState);\n+            if (firstSD->fAccepting != duplSD->fAccepting ||\n+                firstSD->fLookAhead != duplSD->fLookAhead ||\n+                firstSD->fTagsIdx   != duplSD->fTagsIdx) {\n+                continue;\n+            }\n+            bool rowsMatch = true;\n+            for (int32_t col=0; col < numCols; ++col) {\n+                int32_t firstVal = firstSD->fDtran->elementAti(col);\n+                int32_t duplVal = duplSD->fDtran->elementAti(col);\n+                if (!((firstVal == duplVal) ||\n+                        ((firstVal == firstState || firstVal == duplState) &&\n+                        (duplVal  == firstState || duplVal  == duplState)))) {\n+                    rowsMatch = false;\n+                    break;\n+                }\n+            }\n+            if (rowsMatch) {\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+void RBBITableBuilder::removeState(int32_t keepState, int32_t duplState) {\n+    U_ASSERT(keepState < duplState);\n+    U_ASSERT(duplState < fDStates->size());\n \n+    RBBIStateDescriptor *duplSD = (RBBIStateDescriptor *)fDStates->elementAt(duplState);\n+    fDStates->removeElementAt(duplState);\n+    delete duplSD;\n+\n+    int32_t numStates = fDStates->size();\n+    int32_t numCols = fRB->fSetBuilder->getNumCharCategories();\n+    for (int32_t state=0; state<numStates; ++state) {\n+        RBBIStateDescriptor *sd = (RBBIStateDescriptor *)fDStates->elementAt(state);\n+        for (int32_t col=0; col<numCols; col++) {\n+            int32_t existingVal = sd->fDtran->elementAti(col);\n+            int32_t newVal = existingVal;\n+            if (existingVal == duplState) {\n+                newVal = keepState;\n+            } else if (existingVal > duplState) {\n+                newVal = existingVal - 1;\n+            }\n+            sd->fDtran->setElementAt(newVal, col);\n+        }\n+        if (sd->fAccepting == duplState) {\n+            sd->fAccepting = keepState;\n+        } else if (sd->fAccepting > duplState) {\n+            sd->fAccepting--;\n+        }\n+        if (sd->fLookAhead == duplState) {\n+            sd->fLookAhead = keepState;\n+        } else if (sd->fLookAhead > duplState) {\n+            sd->fLookAhead--;\n+        }\n+    }\n+}\n+\n+\n+/*\n+ * RemoveDuplicateStates\n+ */\n+void RBBITableBuilder::removeDuplicateStates() {\n+    int32_t firstState = 3;\n+    int32_t duplicateState = 0;\n+    while (findDuplicateState(firstState, duplicateState)) {\n+        // printf(\"Removing duplicate states (%d, %d)\\n\", firstState, duplicateState);\n+        removeState(firstState, duplicateState);\n+    }\n+}\n \n //-----------------------------------------------------------------------------\n //\n@@ -1095,21 +1217,17 @@ int32_t  RBBITableBuilder::getTableSize() const {\n         return 0;\n     }\n \n-    size    = sizeof(RBBIStateTable) - 4;    // The header, with no rows to the table.\n+    size    = offsetof(RBBIStateTable, fTableData);    // The header, with no rows to the table.\n \n     numRows = fDStates->size();\n     numCols = fRB->fSetBuilder->getNumCharCategories();\n \n-    //  Note  The declaration of RBBIStateTableRow is for a table of two columns.\n-    //        Therefore we subtract two from numCols when determining\n-    //        how much storage to add to a row for the total columns.\n-    rowSize = sizeof(RBBIStateTableRow) + sizeof(uint16_t)*(numCols-2);\n+    rowSize = offsetof(RBBIStateTableRow, fNextState) + sizeof(uint16_t)*numCols;\n     size   += numRows * rowSize;\n     return size;\n }\n \n \n-\n //-----------------------------------------------------------------------------\n //\n //   exportTable()    export the state transition table in the format required\n@@ -1126,14 +1244,14 @@ void RBBITableBuilder::exportTable(void *where) {\n         return;\n     }\n \n-    if (fRB->fSetBuilder->getNumCharCategories() > 0x7fff ||\n+    int32_t catCount = fRB->fSetBuilder->getNumCharCategories();\n+    if (catCount > 0x7fff ||\n         fDStates->size() > 0x7fff) {\n         *fStatus = U_BRK_INTERNAL_ERROR;\n         return;\n     }\n \n-    table->fRowLen    = sizeof(RBBIStateTableRow) +\n-                            sizeof(uint16_t) * (fRB->fSetBuilder->getNumCharCategories() - 2);\n+    table->fRowLen    = offsetof(RBBIStateTableRow, fNextState) + sizeof(uint16_t) * catCount;\n     table->fNumStates = fDStates->size();\n     table->fFlags     = 0;\n     if (fRB->fLookAheadHardBreak) {\n@@ -1152,7 +1270,7 @@ void RBBITableBuilder::exportTable(void *where) {\n         row->fAccepting = (int16_t)sd->fAccepting;\n         row->fLookAhead = (int16_t)sd->fLookAhead;\n         row->fTagIdx    = (int16_t)sd->fTagsIdx;\n-        for (col=0; col<fRB->fSetBuilder->getNumCharCategories(); col++) {\n+        for (col=0; col<catCount; col++) {\n             row->fNextState[col] = (uint16_t)sd->fDtran->elementAti(col);\n         }\n     }\n@@ -1259,15 +1377,15 @@ RBBIStateDescriptor::RBBIStateDescriptor(int lastInputSymbol, UErrorCode *fStatu\n     fPositions = NULL;\n     fDtran     = NULL;\n \n-    fDtran     = new UVector(lastInputSymbol+1, *fStatus);\n+    fDtran     = new UVector32(lastInputSymbol+1, *fStatus);\n     if (U_FAILURE(*fStatus)) {\n         return;\n     }\n     if (fDtran == NULL) {\n         *fStatus = U_MEMORY_ALLOCATION_ERROR;\n         return;\n     }\n-    fDtran->setSize(lastInputSymbol+1, *fStatus);    // fDtran needs to be pre-sized.\n+    fDtran->setSize(lastInputSymbol+1);    // fDtran needs to be pre-sized.\n                                            //   It is indexed by input symbols, and will\n                                            //   hold  the next state number for each\n                                            //   symbol."
        },
        {
            "sha": "09b57b5cf0f4c3f44463c0ed0a26ec148b223aa5",
            "filename": "deps/icu-small/source/common/rbbitblb.h",
            "status": "modified",
            "additions": 41,
            "deletions": 4,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -24,6 +24,7 @@ U_NAMESPACE_BEGIN\n \n class RBBIRuleScanner;\n class RBBIRuleBuilder;\n+class UVector32;\n \n //\n //  class RBBITableBuilder is part of the RBBI rule compiler.\n@@ -42,9 +43,24 @@ class RBBITableBuilder : public UMemory {\n     void     build();\n     int32_t  getTableSize() const;      // Return the runtime size in bytes of\n                                         //     the built state table\n-    void     exportTable(void *where);  // fill in the runtime state table.\n-                                        //     Sufficient memory must exist at\n-                                        //     the specified location.\n+\n+    /** Fill in the runtime state table. Sufficient memory must exist at the specified location.\n+     */\n+    void     exportTable(void *where);\n+\n+    /** Find duplicate (redundant) character classes, beginning after the specifed\n+     *  pair, within this state table. This is an iterator-like function, used to\n+     *  identify char classes (state table columns) that can be eliminated.\n+     */\n+    bool     findDuplCharClassFrom(int &baseClass, int &duplClass);\n+\n+    /** Remove a column from the state table. Used when two character categories\n+     *  have been found equivalent, and merged together, to eliminate the uneeded table column.\n+     */\n+    void     removeColumn(int32_t column);\n+\n+    /** Check for, and remove dupicate states (table rows). */\n+    void     removeDuplicateStates();\n \n \n private:\n@@ -60,8 +76,29 @@ class RBBITableBuilder : public UMemory {\n     void     flagTaggedStates();\n     void     mergeRuleStatusVals();\n \n+    /**\n+     * Merge redundant state table columns, eliminating character classes with identical behavior.\n+     * Done after the state tables are generated, just before converting to their run-time format.\n+     */\n+    int32_t  mergeColumns();\n+\n     void     addRuleRootNodes(UVector *dest, RBBINode *node);\n \n+    /** Find the next duplicate state. An iterator function.\n+     * @param firstState (in/out) begin looking at this state, return the first of the\n+     *                   pair of duplicates.\n+     * @param duplicateState returns the duplicate state of fistState\n+     * @return true if a duplicate pair of states was found.\n+     */\n+    bool findDuplicateState(int32_t &firstState, int32_t &duplicateState);\n+\n+    /** Remove a duplicate state/\n+     * @param keepState First of the duplicate pair. Keep it.\n+     * @param duplState Duplicate state. Remove it. Redirect all references to the duplicate state\n+     *                  to refer to keepState instead.\n+     */\n+    void removeState(int32_t keepState, int32_t duplState);\n+\n     // Set functions for UVector.\n     //   TODO:  make a USet subclass of UVector\n \n@@ -112,7 +149,7 @@ class RBBIStateDescriptor : public UMemory {\n                                            //   with this state.  Unordered (it's a set).\n                                            //   UVector contents are RBBINode *\n \n-    UVector          *fDtran;              // Transitions out of this state.\n+    UVector32        *fDtran;              // Transitions out of this state.\n                                            //   indexed by input character\n                                            //   contents is int index of dest state\n                                            //   in RBBITableBuilder.fDStates"
        },
        {
            "sha": "6eeca8605f00021e358fc8f01e68f1c4590557d5",
            "filename": "deps/icu-small/source/common/sharedobject.cpp",
            "status": "modified",
            "additions": 22,
            "deletions": 47,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fsharedobject.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fsharedobject.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fsharedobject.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -8,7 +8,10 @@\n * sharedobject.cpp\n */\n #include \"sharedobject.h\"\n+#include \"mutex.h\"\n #include \"uassert.h\"\n+#include \"umutex.h\"\n+#include \"unifiedcache.h\"\n \n U_NAMESPACE_BEGIN\n \n@@ -17,69 +20,41 @@ SharedObject::~SharedObject() {}\n UnifiedCacheBase::~UnifiedCacheBase() {}\n \n void\n-SharedObject::addRef(UBool fromWithinCache) const {\n-    umtx_atomic_inc(&totalRefCount);\n-\n-    // Although items in use may not be correct immediately, it\n-    // will be correct eventually.\n-    if (umtx_atomic_inc(&hardRefCount) == 1 && cachePtr != NULL) {\n-        // If this object is cached, and the hardRefCount goes from 0 to 1,\n-        // then the increment must happen from within the cache while the\n-        // cache global mutex is locked. In this way, we can be rest assured\n-        // that data races can't happen if the cache performs some task if\n-        // the hardRefCount is zero while the global cache mutex is locked.\n-        (void)fromWithinCache;   // Suppress unused variable warning in non-debug builds.\n-        U_ASSERT(fromWithinCache);\n-        cachePtr->incrementItemsInUse();\n-    }\n+SharedObject::addRef() const {\n+    umtx_atomic_inc(&hardRefCount);\n }\n \n+// removeRef Decrement the reference count and delete if it is zero.\n+//           Note that SharedObjects with a non-null cachePtr are owned by the\n+//           unified cache, and the cache will be responsible for the actual deletion.\n+//           The deletion could be as soon as immediately following the\n+//           update to the reference count, if another thread is running\n+//           a cache eviction cycle concurrently.\n+//           NO ACCESS TO *this PERMITTED AFTER REFERENCE COUNT == 0 for cached objects.\n+//           THE OBJECT MAY ALREADY BE GONE.\n void\n-SharedObject::removeRef(UBool fromWithinCache) const {\n-    UBool decrementItemsInUse = (umtx_atomic_dec(&hardRefCount) == 0);\n-    UBool allReferencesGone = (umtx_atomic_dec(&totalRefCount) == 0);\n-\n-    // Although items in use may not be correct immediately, it\n-    // will be correct eventually.\n-    if (decrementItemsInUse && cachePtr != NULL) {\n-        if (fromWithinCache) {\n-            cachePtr->decrementItemsInUse();\n+SharedObject::removeRef() const {\n+    const UnifiedCacheBase *cache = this->cachePtr;\n+    int32_t updatedRefCount = umtx_atomic_dec(&hardRefCount);\n+    U_ASSERT(updatedRefCount >= 0);\n+    if (updatedRefCount == 0) {\n+        if (cache) {\n+            cache->handleUnreferencedObject();\n         } else {\n-            cachePtr->decrementItemsInUseWithLockingAndEviction();\n+            delete this;\n         }\n     }\n-    if (allReferencesGone) {\n-        delete this;\n-    }\n }\n \n-void\n-SharedObject::addSoftRef() const {\n-    umtx_atomic_inc(&totalRefCount);\n-    ++softRefCount;\n-}\n-\n-void\n-SharedObject::removeSoftRef() const {\n-    --softRefCount;\n-    if (umtx_atomic_dec(&totalRefCount) == 0) {\n-        delete this;\n-    }\n-}\n \n int32_t\n SharedObject::getRefCount() const {\n-    return umtx_loadAcquire(totalRefCount);\n-}\n-\n-int32_t\n-SharedObject::getHardRefCount() const {\n     return umtx_loadAcquire(hardRefCount);\n }\n \n void\n SharedObject::deleteIfZeroRefCount() const {\n-    if(getRefCount() == 0) {\n+    if (this->cachePtr == nullptr && getRefCount() == 0) {\n         delete this;\n     }\n }"
        },
        {
            "sha": "54655d0d716720edb5ea7291956344383a916d18",
            "filename": "deps/icu-small/source/common/sharedobject.h",
            "status": "modified",
            "additions": 32,
            "deletions": 84,
            "changes": 116,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fsharedobject.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fsharedobject.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fsharedobject.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -17,6 +17,8 @@\n \n U_NAMESPACE_BEGIN\n \n+class SharedObject;\n+\n /**\n  * Base class for unified cache exposing enough methods to SharedObject\n  * instances to allow their addRef() and removeRef() methods to\n@@ -28,22 +30,12 @@ class U_COMMON_API UnifiedCacheBase : public UObject {\n     UnifiedCacheBase() { }\n \n     /**\n-     * Called by addRefWhileHoldingCacheLock() when the hard reference count\n-     * of its instance goes from 0 to 1.\n+     * Notify the cache implementation that an object was seen transitioning to\n+     * zero hard references. The cache may use this to keep track the number of\n+     * unreferenced SharedObjects, and to trigger evictions.\n      */\n-    virtual void incrementItemsInUse() const = 0;\n+    virtual void handleUnreferencedObject() const = 0;\n \n-    /**\n-     * Called by removeRef() when the hard reference count of its instance\n-     * drops from 1 to 0.\n-     */\n-    virtual void decrementItemsInUseWithLockingAndEviction() const = 0;\n-\n-    /**\n-     * Called by removeRefWhileHoldingCacheLock() when the hard reference\n-     * count of its instance drops from 1 to 0.\n-     */\n-    virtual void decrementItemsInUse() const = 0;\n     virtual ~UnifiedCacheBase();\n private:\n     UnifiedCacheBase(const UnifiedCacheBase &);\n@@ -63,109 +55,59 @@ class U_COMMON_API SharedObject : public UObject {\n public:\n     /** Initializes totalRefCount, softRefCount to 0. */\n     SharedObject() :\n-            totalRefCount(0),\n             softRefCount(0),\n             hardRefCount(0),\n             cachePtr(NULL) {}\n \n     /** Initializes totalRefCount, softRefCount to 0. */\n     SharedObject(const SharedObject &other) :\n             UObject(other),\n-            totalRefCount(0),\n             softRefCount(0),\n             hardRefCount(0),\n             cachePtr(NULL) {}\n \n     virtual ~SharedObject();\n \n     /**\n-     * Increments the number of references to this object. Thread-safe.\n+     * Increments the number of hard references to this object. Thread-safe.\n+     * Not for use from within the Unified Cache implementation.\n      */\n-    void addRef() const { addRef(FALSE); }\n+    void addRef() const;\n \n     /**\n-     * Increments the number of references to this object.\n-     * Must be called only from within the internals of UnifiedCache and\n-     * only while the cache global mutex is held.\n-     */\n-    void addRefWhileHoldingCacheLock() const { addRef(TRUE); }\n-\n-    /**\n-     * Increments the number of soft references to this object.\n-     * Must be called only from within the internals of UnifiedCache and\n-     * only while the cache global mutex is held.\n-     */\n-    void addSoftRef() const;\n-\n-    /**\n-     * Decrements the number of references to this object. Thread-safe.\n-     */\n-    void removeRef() const { removeRef(FALSE); }\n-\n-    /**\n-     * Decrements the number of references to this object.\n-     * Must be called only from within the internals of UnifiedCache and\n-     * only while the cache global mutex is held.\n-     */\n-    void removeRefWhileHoldingCacheLock() const { removeRef(TRUE); }\n-\n-    /**\n-     * Decrements the number of soft references to this object.\n-     * Must be called only from within the internals of UnifiedCache and\n-     * only while the cache global mutex is held.\n+     * Decrements the number of hard references to this object, and\n+     * arrange for possible cache-eviction and/or deletion if ref\n+     * count goes to zero. Thread-safe.\n+     *\n+     * Not for use from within the UnifiedCache implementation.\n      */\n-    void removeSoftRef() const;\n+    void removeRef() const;\n \n     /**\n-     * Returns the reference counter including soft references.\n+     * Returns the number of hard references for this object.\n      * Uses a memory barrier.\n      */\n     int32_t getRefCount() const;\n \n-    /**\n-     * Returns the count of soft references only.\n-     * Must be called only from within the internals of UnifiedCache and\n-     * only while the cache global mutex is held.\n-     */\n-    int32_t getSoftRefCount() const { return softRefCount; }\n-\n-    /**\n-     * Returns the count of hard references only. Uses a memory barrier.\n-     * Used for testing the cache. Regular clients won't need this.\n-     */\n-    int32_t getHardRefCount() const;\n-\n     /**\n      * If noHardReferences() == TRUE then this object has no hard references.\n      * Must be called only from within the internals of UnifiedCache.\n      */\n-    inline UBool noHardReferences() const { return getHardRefCount() == 0; }\n+    inline UBool noHardReferences() const { return getRefCount() == 0; }\n \n     /**\n      * If hasHardReferences() == TRUE then this object has hard references.\n      * Must be called only from within the internals of UnifiedCache.\n      */\n-    inline UBool hasHardReferences() const { return getHardRefCount() != 0; }\n-\n-    /**\n-     * If noSoftReferences() == TRUE then this object has no soft references.\n-     * Must be called only from within the internals of UnifiedCache and\n-     * only while the cache global mutex is held.\n-     */\n-    UBool noSoftReferences() const { return (softRefCount == 0); }\n+    inline UBool hasHardReferences() const { return getRefCount() != 0; }\n \n     /**\n-     * Deletes this object if it has no references or soft references.\n+     * Deletes this object if it has no references.\n+     * Available for non-cached SharedObjects only. Ownership of cached objects\n+     * is with the UnifiedCache, which is soley responsible for eviction and deletion.\n      */\n     void deleteIfZeroRefCount() const;\n \n-    /**\n-     * @internal For UnifedCache use only to register this object with itself.\n-     *   Must be called before this object is exposed to multiple threads.\n-     */\n-    void registerWithCache(const UnifiedCacheBase *ptr) const {\n-        cachePtr = ptr;\n-    }\n \n     /**\n      * Returns a writable version of ptr.\n@@ -219,15 +161,21 @@ class U_COMMON_API SharedObject : public UObject {\n     }\n \n private:\n-    mutable u_atomic_int32_t totalRefCount;\n-\n-    // Any thread modifying softRefCount must hold the global cache mutex\n+    /**\n+     * The number of references from the UnifiedCache, which is\n+     * the number of times that the sharedObject is stored as a hash table value.\n+     * For use by UnifiedCache implementation code only.\n+     * All access is synchronized by UnifiedCache's gCacheMutex\n+     */\n     mutable int32_t softRefCount;\n+    friend class UnifiedCache;\n \n+    /**\n+     * Reference count, excluding references from within the UnifiedCache implementation.\n+     */\n     mutable u_atomic_int32_t hardRefCount;\n+\n     mutable const UnifiedCacheBase *cachePtr;\n-    void addRef(UBool withCacheLock) const;\n-    void removeRef(UBool withCacheLock) const;\n \n };\n "
        },
        {
            "sha": "26de904b1fde5a7a5648f1eeddb66af912d320cd",
            "filename": "deps/icu-small/source/common/sprpimpl.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fsprpimpl.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fsprpimpl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fsprpimpl.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -90,7 +90,6 @@ struct UStringPrepProfile{\n     UTrie sprepTrie;\n     const uint16_t* mappingData;\n     UDataMemory* sprepData;\n-    const UBiDiProps *bdp; /* used only if checkBiDi is set */\n     int32_t refCount;\n     UBool isDataLoaded;\n     UBool doNFKC;"
        },
        {
            "sha": "531ed64cff6ec8a635fbd6a6f05a0e03cf0850d2",
            "filename": "deps/icu-small/source/common/ubidi.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 5,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -152,9 +152,6 @@ ubidi_openSized(int32_t maxLength, int32_t maxRunCount, UErrorCode *pErrorCode)\n     /* reset the object, all pointers NULL, all flags FALSE, all sizes 0 */\n     uprv_memset(pBiDi, 0, sizeof(UBiDi));\n \n-    /* get BiDi properties */\n-    pBiDi->bdp=ubidi_getSingleton();\n-\n     /* allocate memory for arrays as requested */\n     if(maxLength>0) {\n         if( !getInitialDirPropsMemory(pBiDi, maxLength) ||\n@@ -925,7 +922,7 @@ bracketProcessChar(BracketData *bd, int32_t position) {\n         else\n             match=0;\n         if(match!=c &&                  /* has a matching char */\n-           ubidi_getPairedBracketType(bd->pBiDi->bdp, c)==U_BPT_OPEN) { /* opening bracket */\n+           ubidi_getPairedBracketType(c)==U_BPT_OPEN) { /* opening bracket */\n             /* special case: process synonyms\n                create an opening entry for each synonym */\n             if(match==0x232A) {     /* RIGHT-POINTING ANGLE BRACKET */\n@@ -3033,7 +3030,7 @@ ubidi_getCustomizedClass(UBiDi *pBiDi, UChar32 c)\n     if( pBiDi->fnClassCallback == NULL ||\n         (dir = (*pBiDi->fnClassCallback)(pBiDi->coClassCallback, c)) == U_BIDI_CLASS_DEFAULT )\n     {\n-        dir = ubidi_getClass(pBiDi->bdp, c);\n+        dir = ubidi_getClass(c);\n     }\n     if(dir >= U_CHAR_DIRECTION_COUNT) {\n         dir = (UCharDirection)ON;"
        },
        {
            "sha": "4141c21938a740d8851305d307b0e5ee02a4c233",
            "filename": "deps/icu-small/source/common/ubidi_props.cpp",
            "status": "modified",
            "additions": 45,
            "deletions": 58,
            "changes": 103,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi_props.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi_props.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi_props.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -44,13 +44,6 @@ struct UBiDiProps {\n #define INCLUDED_FROM_UBIDI_PROPS_C\n #include \"ubidi_props_data.h\"\n \n-/* UBiDiProps singleton ----------------------------------------------------- */\n-\n-U_CFUNC const UBiDiProps *\n-ubidi_getSingleton() {\n-    return &ubidi_props_singleton;\n-}\n-\n /* set of property starts for UnicodeSet ------------------------------------ */\n \n static UBool U_CALLCONV\n@@ -64,7 +57,7 @@ _enumPropertyStartsRange(const void *context, UChar32 start, UChar32 end, uint32\n }\n \n U_CFUNC void\n-ubidi_addPropertyStarts(const UBiDiProps *bdp, const USetAdder *sa, UErrorCode *pErrorCode) {\n+ubidi_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode) {\n     int32_t i, length;\n     UChar32 c, start, limit;\n \n@@ -76,19 +69,19 @@ ubidi_addPropertyStarts(const UBiDiProps *bdp, const USetAdder *sa, UErrorCode *\n     }\n \n     /* add the start code point of each same-value range of the trie */\n-    utrie2_enum(&bdp->trie, NULL, _enumPropertyStartsRange, sa);\n+    utrie2_enum(&ubidi_props_singleton.trie, NULL, _enumPropertyStartsRange, sa);\n \n     /* add the code points from the bidi mirroring table */\n-    length=bdp->indexes[UBIDI_IX_MIRROR_LENGTH];\n+    length=ubidi_props_singleton.indexes[UBIDI_IX_MIRROR_LENGTH];\n     for(i=0; i<length; ++i) {\n-        c=UBIDI_GET_MIRROR_CODE_POINT(bdp->mirrors[i]);\n+        c=UBIDI_GET_MIRROR_CODE_POINT(ubidi_props_singleton.mirrors[i]);\n         sa->addRange(sa->set, c, c+1);\n     }\n \n     /* add the code points from the Joining_Group array where the value changes */\n-    start=bdp->indexes[UBIDI_IX_JG_START];\n-    limit=bdp->indexes[UBIDI_IX_JG_LIMIT];\n-    jgArray=bdp->jgArray;\n+    start=ubidi_props_singleton.indexes[UBIDI_IX_JG_START];\n+    limit=ubidi_props_singleton.indexes[UBIDI_IX_JG_LIMIT];\n+    jgArray=ubidi_props_singleton.jgArray;\n     for(;;) {\n         prev=0;\n         while(start<limit) {\n@@ -103,11 +96,11 @@ ubidi_addPropertyStarts(const UBiDiProps *bdp, const USetAdder *sa, UErrorCode *\n             /* add the limit code point if the last value was not 0 (it is now start==limit) */\n             sa->add(sa->set, limit);\n         }\n-        if(limit==bdp->indexes[UBIDI_IX_JG_LIMIT]) {\n+        if(limit==ubidi_props_singleton.indexes[UBIDI_IX_JG_LIMIT]) {\n             /* switch to the second Joining_Group range */\n-            start=bdp->indexes[UBIDI_IX_JG_START2];\n-            limit=bdp->indexes[UBIDI_IX_JG_LIMIT2];\n-            jgArray=bdp->jgArray2;\n+            start=ubidi_props_singleton.indexes[UBIDI_IX_JG_START2];\n+            limit=ubidi_props_singleton.indexes[UBIDI_IX_JG_LIMIT2];\n+            jgArray=ubidi_props_singleton.jgArray2;\n         } else {\n             break;\n         }\n@@ -121,14 +114,8 @@ ubidi_addPropertyStarts(const UBiDiProps *bdp, const USetAdder *sa, UErrorCode *\n /* property access functions ------------------------------------------------ */\n \n U_CFUNC int32_t\n-ubidi_getMaxValue(const UBiDiProps *bdp, UProperty which) {\n-    int32_t max;\n-\n-    if(bdp==NULL) {\n-        return -1;\n-    }\n-\n-    max=bdp->indexes[UBIDI_MAX_VALUES_INDEX];\n+ubidi_getMaxValue(UProperty which) {\n+    int32_t max=ubidi_props_singleton.indexes[UBIDI_MAX_VALUES_INDEX];\n     switch(which) {\n     case UCHAR_BIDI_CLASS:\n         return (max&UBIDI_CLASS_MASK);\n@@ -144,19 +131,19 @@ ubidi_getMaxValue(const UBiDiProps *bdp, UProperty which) {\n }\n \n U_CAPI UCharDirection\n-ubidi_getClass(const UBiDiProps *bdp, UChar32 c) {\n-    uint16_t props=UTRIE2_GET16(&bdp->trie, c);\n+ubidi_getClass(UChar32 c) {\n+    uint16_t props=UTRIE2_GET16(&ubidi_props_singleton.trie, c);\n     return (UCharDirection)UBIDI_GET_CLASS(props);\n }\n \n U_CFUNC UBool\n-ubidi_isMirrored(const UBiDiProps *bdp, UChar32 c) {\n-    uint16_t props=UTRIE2_GET16(&bdp->trie, c);\n+ubidi_isMirrored(UChar32 c) {\n+    uint16_t props=UTRIE2_GET16(&ubidi_props_singleton.trie, c);\n     return (UBool)UBIDI_GET_FLAG(props, UBIDI_IS_MIRRORED_SHIFT);\n }\n \n static UChar32\n-getMirror(const UBiDiProps *bdp, UChar32 c, uint16_t props) {\n+getMirror(UChar32 c, uint16_t props) {\n     int32_t delta=UBIDI_GET_MIRROR_DELTA(props);\n     if(delta!=UBIDI_ESC_MIRROR_DELTA) {\n         return c+delta;\n@@ -167,8 +154,8 @@ getMirror(const UBiDiProps *bdp, UChar32 c, uint16_t props) {\n         int32_t i, length;\n         UChar32 c2;\n \n-        mirrors=bdp->mirrors;\n-        length=bdp->indexes[UBIDI_IX_MIRROR_LENGTH];\n+        mirrors=ubidi_props_singleton.mirrors;\n+        length=ubidi_props_singleton.indexes[UBIDI_IX_MIRROR_LENGTH];\n \n         /* linear search */\n         for(i=0; i<length; ++i) {\n@@ -188,80 +175,80 @@ getMirror(const UBiDiProps *bdp, UChar32 c, uint16_t props) {\n }\n \n U_CFUNC UChar32\n-ubidi_getMirror(const UBiDiProps *bdp, UChar32 c) {\n-    uint16_t props=UTRIE2_GET16(&bdp->trie, c);\n-    return getMirror(bdp, c, props);\n+ubidi_getMirror(UChar32 c) {\n+    uint16_t props=UTRIE2_GET16(&ubidi_props_singleton.trie, c);\n+    return getMirror(c, props);\n }\n \n U_CFUNC UBool\n-ubidi_isBidiControl(const UBiDiProps *bdp, UChar32 c) {\n-    uint16_t props=UTRIE2_GET16(&bdp->trie, c);\n+ubidi_isBidiControl(UChar32 c) {\n+    uint16_t props=UTRIE2_GET16(&ubidi_props_singleton.trie, c);\n     return (UBool)UBIDI_GET_FLAG(props, UBIDI_BIDI_CONTROL_SHIFT);\n }\n \n U_CFUNC UBool\n-ubidi_isJoinControl(const UBiDiProps *bdp, UChar32 c) {\n-    uint16_t props=UTRIE2_GET16(&bdp->trie, c);\n+ubidi_isJoinControl(UChar32 c) {\n+    uint16_t props=UTRIE2_GET16(&ubidi_props_singleton.trie, c);\n     return (UBool)UBIDI_GET_FLAG(props, UBIDI_JOIN_CONTROL_SHIFT);\n }\n \n U_CFUNC UJoiningType\n-ubidi_getJoiningType(const UBiDiProps *bdp, UChar32 c) {\n-    uint16_t props=UTRIE2_GET16(&bdp->trie, c);\n+ubidi_getJoiningType(UChar32 c) {\n+    uint16_t props=UTRIE2_GET16(&ubidi_props_singleton.trie, c);\n     return (UJoiningType)((props&UBIDI_JT_MASK)>>UBIDI_JT_SHIFT);\n }\n \n U_CFUNC UJoiningGroup\n-ubidi_getJoiningGroup(const UBiDiProps *bdp, UChar32 c) {\n+ubidi_getJoiningGroup(UChar32 c) {\n     UChar32 start, limit;\n \n-    start=bdp->indexes[UBIDI_IX_JG_START];\n-    limit=bdp->indexes[UBIDI_IX_JG_LIMIT];\n+    start=ubidi_props_singleton.indexes[UBIDI_IX_JG_START];\n+    limit=ubidi_props_singleton.indexes[UBIDI_IX_JG_LIMIT];\n     if(start<=c && c<limit) {\n-        return (UJoiningGroup)bdp->jgArray[c-start];\n+        return (UJoiningGroup)ubidi_props_singleton.jgArray[c-start];\n     }\n-    start=bdp->indexes[UBIDI_IX_JG_START2];\n-    limit=bdp->indexes[UBIDI_IX_JG_LIMIT2];\n+    start=ubidi_props_singleton.indexes[UBIDI_IX_JG_START2];\n+    limit=ubidi_props_singleton.indexes[UBIDI_IX_JG_LIMIT2];\n     if(start<=c && c<limit) {\n-        return (UJoiningGroup)bdp->jgArray2[c-start];\n+        return (UJoiningGroup)ubidi_props_singleton.jgArray2[c-start];\n     }\n     return U_JG_NO_JOINING_GROUP;\n }\n \n U_CFUNC UBidiPairedBracketType\n-ubidi_getPairedBracketType(const UBiDiProps *bdp, UChar32 c) {\n-    uint16_t props=UTRIE2_GET16(&bdp->trie, c);\n+ubidi_getPairedBracketType(UChar32 c) {\n+    uint16_t props=UTRIE2_GET16(&ubidi_props_singleton.trie, c);\n     return (UBidiPairedBracketType)((props&UBIDI_BPT_MASK)>>UBIDI_BPT_SHIFT);\n }\n \n U_CFUNC UChar32\n-ubidi_getPairedBracket(const UBiDiProps *bdp, UChar32 c) {\n-    uint16_t props=UTRIE2_GET16(&bdp->trie, c);\n+ubidi_getPairedBracket(UChar32 c) {\n+    uint16_t props=UTRIE2_GET16(&ubidi_props_singleton.trie, c);\n     if((props&UBIDI_BPT_MASK)==0) {\n         return c;\n     } else {\n-        return getMirror(bdp, c, props);\n+        return getMirror(c, props);\n     }\n }\n \n /* public API (see uchar.h) ------------------------------------------------- */\n \n U_CFUNC UCharDirection\n u_charDirection(UChar32 c) {\n-    return ubidi_getClass(&ubidi_props_singleton, c);\n+    return ubidi_getClass(c);\n }\n \n U_CFUNC UBool\n u_isMirrored(UChar32 c) {\n-    return ubidi_isMirrored(&ubidi_props_singleton, c);\n+    return ubidi_isMirrored(c);\n }\n \n U_CFUNC UChar32\n u_charMirror(UChar32 c) {\n-    return ubidi_getMirror(&ubidi_props_singleton, c);\n+    return ubidi_getMirror(c);\n }\n \n U_STABLE UChar32 U_EXPORT2\n u_getBidiPairedBracket(UChar32 c) {\n-    return ubidi_getPairedBracket(&ubidi_props_singleton, c);\n+    return ubidi_getPairedBracket(c);\n }"
        },
        {
            "sha": "698ee9c52bd6cbab9f7790d0daae6f5bc2a6a95f",
            "filename": "deps/icu-small/source/common/ubidi_props.h",
            "status": "modified",
            "additions": 11,
            "deletions": 17,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi_props.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi_props.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi_props.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -31,46 +31,40 @@ U_CDECL_BEGIN\n \n /* library API -------------------------------------------------------------- */\n \n-struct UBiDiProps;\n-typedef struct UBiDiProps UBiDiProps;\n-\n-U_CFUNC const UBiDiProps *\n-ubidi_getSingleton(void);\n-\n U_CFUNC void\n-ubidi_addPropertyStarts(const UBiDiProps *bdp, const USetAdder *sa, UErrorCode *pErrorCode);\n+ubidi_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode);\n \n /* property access functions */\n \n U_CFUNC int32_t\n-ubidi_getMaxValue(const UBiDiProps *bdp, UProperty which);\n+ubidi_getMaxValue(UProperty which);\n \n U_CAPI UCharDirection\n-ubidi_getClass(const UBiDiProps *bdp, UChar32 c);\n+ubidi_getClass(UChar32 c);\n \n U_CFUNC UBool\n-ubidi_isMirrored(const UBiDiProps *bdp, UChar32 c);\n+ubidi_isMirrored(UChar32 c);\n \n U_CFUNC UChar32\n-ubidi_getMirror(const UBiDiProps *bdp, UChar32 c);\n+ubidi_getMirror(UChar32 c);\n \n U_CFUNC UBool\n-ubidi_isBidiControl(const UBiDiProps *bdp, UChar32 c);\n+ubidi_isBidiControl(UChar32 c);\n \n U_CFUNC UBool\n-ubidi_isJoinControl(const UBiDiProps *bdp, UChar32 c);\n+ubidi_isJoinControl(UChar32 c);\n \n U_CFUNC UJoiningType\n-ubidi_getJoiningType(const UBiDiProps *bdp, UChar32 c);\n+ubidi_getJoiningType(UChar32 c);\n \n U_CFUNC UJoiningGroup\n-ubidi_getJoiningGroup(const UBiDiProps *bdp, UChar32 c);\n+ubidi_getJoiningGroup(UChar32 c);\n \n U_CFUNC UBidiPairedBracketType\n-ubidi_getPairedBracketType(const UBiDiProps *bdp, UChar32 c);\n+ubidi_getPairedBracketType(UChar32 c);\n \n U_CFUNC UChar32\n-ubidi_getPairedBracket(const UBiDiProps *bdp, UChar32 c);\n+ubidi_getPairedBracket(UChar32 c);\n \n /* file definitions --------------------------------------------------------- */\n "
        },
        {
            "sha": "a5d0727495d76765e83984fe64c8b1b7f3ce27c9",
            "filename": "deps/icu-small/source/common/ubidiimp.h",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidiimp.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidiimp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidiimp.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -254,8 +254,6 @@ struct UBiDi {\n      */\n     const UBiDi * pParaBiDi;\n \n-    const UBiDiProps *bdp;\n-\n     /* alias pointer to the current text */\n     const UChar *text;\n "
        },
        {
            "sha": "28d5a4cac62ba61f572eee9a1a18e9632d80b01c",
            "filename": "deps/icu-small/source/common/ucase.cpp",
            "status": "modified",
            "additions": 150,
            "deletions": 15,
            "changes": 165,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucase.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucase.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucase.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -77,9 +77,12 @@ ucase_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode) {\n \n /* data access primitives --------------------------------------------------- */\n \n-#define GET_EXCEPTIONS(csp, props) ((csp)->exceptions+((props)>>UCASE_EXC_SHIFT))\n+U_CFUNC const UTrie2 * U_EXPORT2\n+ucase_getTrie() {\n+    return &ucase_props_singleton.trie;\n+}\n \n-#define PROPS_HAS_EXCEPTION(props) ((props)&UCASE_EXCEPTION)\n+#define GET_EXCEPTIONS(csp, props) ((csp)->exceptions+((props)>>UCASE_EXC_SHIFT))\n \n /* number of bits in an 8-bit integer value */\n static const uint8_t flagsOffset[256]={\n@@ -128,8 +131,8 @@ static const uint8_t flagsOffset[256]={\n U_CAPI UChar32 U_EXPORT2\n ucase_tolower(UChar32 c) {\n     uint16_t props=UTRIE2_GET16(&ucase_props_singleton.trie, c);\n-    if(!PROPS_HAS_EXCEPTION(props)) {\n-        if(UCASE_GET_TYPE(props)>=UCASE_UPPER) {\n+    if(!UCASE_HAS_EXCEPTION(props)) {\n+        if(UCASE_IS_UPPER_OR_TITLE(props)) {\n             c+=UCASE_GET_DELTA(props);\n         }\n     } else {\n@@ -145,7 +148,7 @@ ucase_tolower(UChar32 c) {\n U_CAPI UChar32 U_EXPORT2\n ucase_toupper(UChar32 c) {\n     uint16_t props=UTRIE2_GET16(&ucase_props_singleton.trie, c);\n-    if(!PROPS_HAS_EXCEPTION(props)) {\n+    if(!UCASE_HAS_EXCEPTION(props)) {\n         if(UCASE_GET_TYPE(props)==UCASE_LOWER) {\n             c+=UCASE_GET_DELTA(props);\n         }\n@@ -162,7 +165,7 @@ ucase_toupper(UChar32 c) {\n U_CAPI UChar32 U_EXPORT2\n ucase_totitle(UChar32 c) {\n     uint16_t props=UTRIE2_GET16(&ucase_props_singleton.trie, c);\n-    if(!PROPS_HAS_EXCEPTION(props)) {\n+    if(!UCASE_HAS_EXCEPTION(props)) {\n         if(UCASE_GET_TYPE(props)==UCASE_LOWER) {\n             c+=UCASE_GET_DELTA(props);\n         }\n@@ -223,7 +226,7 @@ ucase_addCaseClosure(UChar32 c, const USetAdder *sa) {\n     }\n \n     props=UTRIE2_GET16(&ucase_props_singleton.trie, c);\n-    if(!PROPS_HAS_EXCEPTION(props)) {\n+    if(!UCASE_HAS_EXCEPTION(props)) {\n         if(UCASE_GET_TYPE(props)!=UCASE_NONE) {\n             /* add the one simple case mapping, no matter what type it is */\n             int32_t delta=UCASE_GET_DELTA(props);\n@@ -419,6 +422,138 @@ FullCaseFoldingIterator::next(UnicodeString &full) {\n     return c;\n }\n \n+namespace LatinCase {\n+\n+const int8_t TO_LOWER_NORMAL[LIMIT] = {\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, EXC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+    32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, EXC,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+    EXC, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1,\n+\n+    0, 1, 0, 1, 0, 1, 0, 1, 0, EXC, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, -121, 1, 0, 1, 0, 1, 0, EXC\n+};\n+\n+const int8_t TO_LOWER_TR_LT[LIMIT] = {\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0, 32, 32, 32, 32, 32, 32, 32, 32, EXC, EXC, 32, 32, 32, 32, 32,\n+    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, EXC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, EXC, EXC, 32, 32,\n+    32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, EXC,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, EXC, 0, 1, 0, 1, 0, EXC, 0,\n+    EXC, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1,\n+\n+    0, 1, 0, 1, 0, 1, 0, 1, 0, EXC, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n+    1, 0, 1, 0, 1, 0, 1, 0, -121, 1, 0, 1, 0, 1, 0, EXC\n+};\n+\n+const int8_t TO_UPPER_NORMAL[LIMIT] = {\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32,\n+    -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, 0, 0, 0, 0, 0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, EXC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, EXC,\n+    -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32,\n+    -32, -32, -32, -32, -32, -32, -32, 0, -32, -32, -32, -32, -32, -32, -32, 121,\n+\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, EXC, 0, -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, 0,\n+\n+    -1, 0, -1, 0, -1, 0, -1, 0, -1, EXC, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, EXC\n+};\n+\n+const int8_t TO_UPPER_TR[LIMIT] = {\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, -32, -32, -32, -32, -32, -32, -32, -32, EXC, -32, -32, -32, -32, -32, -32,\n+    -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, 0, 0, 0, 0, 0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, EXC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, EXC,\n+    -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32, -32,\n+    -32, -32, -32, -32, -32, -32, -32, 0, -32, -32, -32, -32, -32, -32, -32, 121,\n+\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, EXC, 0, -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, 0,\n+\n+    -1, 0, -1, 0, -1, 0, -1, 0, -1, EXC, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1, 0, -1,\n+    0, -1, 0, -1, 0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, EXC\n+};\n+\n+}  // namespace LatinCase\n+\n U_NAMESPACE_END\n \n /** @return UCASE_NONE, UCASE_LOWER, UCASE_UPPER, UCASE_TITLE */\n@@ -439,7 +574,7 @@ ucase_getTypeOrIgnorable(UChar32 c) {\n static inline int32_t\n getDotType(UChar32 c) {\n     uint16_t props=UTRIE2_GET16(&ucase_props_singleton.trie, c);\n-    if(!PROPS_HAS_EXCEPTION(props)) {\n+    if(!UCASE_HAS_EXCEPTION(props)) {\n         return props&UCASE_DOT_MASK;\n     } else {\n         const uint16_t *pe=GET_EXCEPTIONS(&ucase_props_singleton, props);\n@@ -878,8 +1013,8 @@ ucase_toFullLower(UChar32 c,\n     U_ASSERT(c >= 0);\n     UChar32 result=c;\n     uint16_t props=UTRIE2_GET16(&ucase_props_singleton.trie, c);\n-    if(!PROPS_HAS_EXCEPTION(props)) {\n-        if(UCASE_GET_TYPE(props)>=UCASE_UPPER) {\n+    if(!UCASE_HAS_EXCEPTION(props)) {\n+        if(UCASE_IS_UPPER_OR_TITLE(props)) {\n             result=c+UCASE_GET_DELTA(props);\n         }\n     } else {\n@@ -1024,7 +1159,7 @@ toUpperOrTitle(UChar32 c,\n     U_ASSERT(c >= 0);\n     UChar32 result=c;\n     uint16_t props=UTRIE2_GET16(&ucase_props_singleton.trie, c);\n-    if(!PROPS_HAS_EXCEPTION(props)) {\n+    if(!UCASE_HAS_EXCEPTION(props)) {\n         if(UCASE_GET_TYPE(props)==UCASE_LOWER) {\n             result=c+UCASE_GET_DELTA(props);\n         }\n@@ -1169,8 +1304,8 @@ ucase_toFullTitle(UChar32 c,\n U_CAPI UChar32 U_EXPORT2\n ucase_fold(UChar32 c, uint32_t options) {\n     uint16_t props=UTRIE2_GET16(&ucase_props_singleton.trie, c);\n-    if(!PROPS_HAS_EXCEPTION(props)) {\n-        if(UCASE_GET_TYPE(props)>=UCASE_UPPER) {\n+    if(!UCASE_HAS_EXCEPTION(props)) {\n+        if(UCASE_IS_UPPER_OR_TITLE(props)) {\n             c+=UCASE_GET_DELTA(props);\n         }\n     } else {\n@@ -1234,8 +1369,8 @@ ucase_toFullFolding(UChar32 c,\n     U_ASSERT(c >= 0);\n     UChar32 result=c;\n     uint16_t props=UTRIE2_GET16(&ucase_props_singleton.trie, c);\n-    if(!PROPS_HAS_EXCEPTION(props)) {\n-        if(UCASE_GET_TYPE(props)>=UCASE_UPPER) {\n+    if(!UCASE_HAS_EXCEPTION(props)) {\n+        if(UCASE_IS_UPPER_OR_TITLE(props)) {\n             result=c+UCASE_GET_DELTA(props);\n         }\n     } else {"
        },
        {
            "sha": "a7a8c9f00d1e9351cea31a7c0387abdc6cd736d6",
            "filename": "deps/icu-small/source/common/ucase.h",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucase.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucase.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucase.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -26,6 +26,7 @@\n #include \"putilimp.h\"\n #include \"uset_imp.h\"\n #include \"udataswp.h\"\n+#include \"utrie2.h\"\n \n #ifdef __cplusplus\n U_NAMESPACE_BEGIN\n@@ -148,6 +149,33 @@ class U_COMMON_API FullCaseFoldingIterator {\n     int32_t rowCpIndex;\n };\n \n+/**\n+ * Fast case mapping data for ASCII/Latin.\n+ * Linear arrays of delta bytes: 0=no mapping; EXC=exception.\n+ * Deltas must not cross the ASCII boundary, or else they cannot be easily used\n+ * in simple UTF-8 code.\n+ */\n+namespace LatinCase {\n+\n+/** Case mapping/folding data for code points up to U+017F. */\n+constexpr UChar LIMIT = 0x180;\n+/** U+017F case-folds and uppercases crossing the ASCII boundary. */\n+constexpr UChar LONG_S = 0x17f;\n+/** Exception: Complex mapping, or too-large delta. */\n+constexpr int8_t EXC = -0x80;\n+\n+/** Deltas for lowercasing for most locales, and default case folding. */\n+extern const int8_t TO_LOWER_NORMAL[LIMIT];\n+/** Deltas for lowercasing for tr/az/lt, and Turkic case folding. */\n+extern const int8_t TO_LOWER_TR_LT[LIMIT];\n+\n+/** Deltas for uppercasing for most locales. */\n+extern const int8_t TO_UPPER_NORMAL[LIMIT];\n+/** Deltas for uppercasing for tr/az. */\n+extern const int8_t TO_UPPER_TR[LIMIT];\n+\n+}  // namespace LatinCase\n+\n U_NAMESPACE_END\n #endif\n \n@@ -308,6 +336,9 @@ enum {\n \n /* definitions for 16-bit case properties word ------------------------------ */\n \n+U_CFUNC const UTrie2 * U_EXPORT2\n+ucase_getTrie();\n+\n /* 2-bit constants for types of cased characters */\n #define UCASE_TYPE_MASK     3\n enum {\n@@ -320,10 +351,14 @@ enum {\n #define UCASE_GET_TYPE(props) ((props)&UCASE_TYPE_MASK)\n #define UCASE_GET_TYPE_AND_IGNORABLE(props) ((props)&7)\n \n+#define UCASE_IS_UPPER_OR_TITLE(props) ((props)&2)\n+\n #define UCASE_IGNORABLE         4\n #define UCASE_SENSITIVE         8\n #define UCASE_EXCEPTION         0x10\n \n+#define UCASE_HAS_EXCEPTION(props) ((props)&UCASE_EXCEPTION)\n+\n #define UCASE_DOT_MASK      0x60\n enum {\n     UCASE_NO_DOT=0,         /* normal characters with cc=0 */"
        },
        {
            "sha": "99e30c9fc6987e27bf52a0c4e6bf0ba9bf702814",
            "filename": "deps/icu-small/source/common/ucasemap.cpp",
            "status": "modified",
            "additions": 224,
            "deletions": 48,
            "changes": 272,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucasemap.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucasemap.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucasemap.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -165,9 +165,7 @@ appendResult(int32_t cpLength, int32_t result, const UChar *s,\n inline uint8_t getTwoByteLead(UChar32 c) { return (uint8_t)((c >> 6) | 0xc0); }\n inline uint8_t getTwoByteTrail(UChar32 c) { return (uint8_t)((c & 0x3f) | 0x80); }\n \n-}  // namespace\n-\n-static UChar32 U_CALLCONV\n+UChar32 U_CALLCONV\n utf8_caseContextIterator(void *context, int8_t dir) {\n     UCaseContext *csc=(UCaseContext *)context;\n     UChar32 c;\n@@ -199,36 +197,227 @@ utf8_caseContextIterator(void *context, int8_t dir) {\n     return U_SENTINEL;\n }\n \n-/*\n- * Case-maps [srcStart..srcLimit[ but takes\n- * context [0..srcLength[ into account.\n+/**\n+ * caseLocale >= 0: Lowercases [srcStart..srcLimit[ but takes context [0..srcLength[ into account.\n+ * caseLocale < 0: Case-folds [srcStart..srcLimit[.\n  */\n-static void\n-_caseMap(int32_t caseLocale, uint32_t options, UCaseMapFull *map,\n-         const uint8_t *src, UCaseContext *csc,\n-         int32_t srcStart, int32_t srcLimit,\n-         icu::ByteSink &sink, icu::Edits *edits,\n-         UErrorCode &errorCode) {\n-    /* case mapping loop */\n-    int32_t srcIndex=srcStart;\n-    while (U_SUCCESS(errorCode) && srcIndex<srcLimit) {\n+void toLower(int32_t caseLocale, uint32_t options,\n+             const uint8_t *src, UCaseContext *csc, int32_t srcStart, int32_t srcLimit,\n+             icu::ByteSink &sink, icu::Edits *edits, UErrorCode &errorCode) {\n+    const int8_t *latinToLower;\n+    if (caseLocale == UCASE_LOC_ROOT ||\n+            (caseLocale >= 0 ?\n+                !(caseLocale == UCASE_LOC_TURKISH || caseLocale == UCASE_LOC_LITHUANIAN) :\n+                (options & _FOLD_CASE_OPTIONS_MASK) == U_FOLD_CASE_DEFAULT)) {\n+        latinToLower = LatinCase::TO_LOWER_NORMAL;\n+    } else {\n+        latinToLower = LatinCase::TO_LOWER_TR_LT;\n+    }\n+    const UTrie2 *trie = ucase_getTrie();\n+    int32_t prev = srcStart;\n+    int32_t srcIndex = srcStart;\n+    for (;;) {\n+        // fast path for simple cases\n         int32_t cpStart;\n-        csc->cpStart=cpStart=srcIndex;\n         UChar32 c;\n-        U8_NEXT(src, srcIndex, srcLimit, c);\n-        csc->cpLimit=srcIndex;\n-        if(c<0) {\n-            // Malformed UTF-8.\n-            ByteSinkUtil::appendUnchanged(src+cpStart, srcIndex-cpStart,\n+        for (;;) {\n+            if (U_FAILURE(errorCode) || srcIndex >= srcLimit) {\n+                c = U_SENTINEL;\n+                break;\n+            }\n+            uint8_t lead = src[srcIndex++];\n+            if (lead <= 0x7f) {\n+                int8_t d = latinToLower[lead];\n+                if (d == LatinCase::EXC) {\n+                    cpStart = srcIndex - 1;\n+                    c = lead;\n+                    break;\n+                }\n+                if (d == 0) { continue; }\n+                ByteSinkUtil::appendUnchanged(src + prev, srcIndex - 1 - prev,\n+                                              sink, options, edits, errorCode);\n+                char ascii = (char)(lead + d);\n+                sink.Append(&ascii, 1);\n+                if (edits != nullptr) {\n+                    edits->addReplace(1, 1);\n+                }\n+                prev = srcIndex;\n+                continue;\n+            } else if (lead < 0xe3) {\n+                uint8_t t;\n+                if (0xc2 <= lead && lead <= 0xc5 && srcIndex < srcLimit &&\n+                        (t = src[srcIndex] - 0x80) <= 0x3f) {\n+                    // U+0080..U+017F\n+                    ++srcIndex;\n+                    c = ((lead - 0xc0) << 6) | t;\n+                    int8_t d = latinToLower[c];\n+                    if (d == LatinCase::EXC) {\n+                        cpStart = srcIndex - 2;\n+                        break;\n+                    }\n+                    if (d == 0) { continue; }\n+                    ByteSinkUtil::appendUnchanged(src + prev, srcIndex - 2 - prev,\n+                                                  sink, options, edits, errorCode);\n+                    ByteSinkUtil::appendTwoBytes(c + d, sink);\n+                    if (edits != nullptr) {\n+                        edits->addReplace(2, 2);\n+                    }\n+                    prev = srcIndex;\n+                    continue;\n+                }\n+            } else if ((lead <= 0xe9 || lead == 0xeb || lead == 0xec) &&\n+                    (srcIndex + 2) <= srcLimit &&\n+                    U8_IS_TRAIL(src[srcIndex]) && U8_IS_TRAIL(src[srcIndex + 1])) {\n+                // most of CJK: no case mappings\n+                srcIndex += 2;\n+                continue;\n+            }\n+            cpStart = --srcIndex;\n+            U8_NEXT(src, srcIndex, srcLimit, c);\n+            if (c < 0) {\n+                // ill-formed UTF-8\n+                continue;\n+            }\n+            uint16_t props = UTRIE2_GET16(trie, c);\n+            if (UCASE_HAS_EXCEPTION(props)) { break; }\n+            int32_t delta;\n+            if (!UCASE_IS_UPPER_OR_TITLE(props) || (delta = UCASE_GET_DELTA(props)) == 0) {\n+                continue;\n+            }\n+            ByteSinkUtil::appendUnchanged(src + prev, cpStart - prev,\n                                           sink, options, edits, errorCode);\n+            ByteSinkUtil::appendCodePoint(srcIndex - cpStart, c + delta, sink, edits);\n+            prev = srcIndex;\n+        }\n+        if (c < 0) {\n+            break;\n+        }\n+        // slow path\n+        const UChar *s;\n+        if (caseLocale >= 0) {\n+            csc->cpStart = cpStart;\n+            csc->cpLimit = srcIndex;\n+            c = ucase_toFullLower(c, utf8_caseContextIterator, csc, &s, caseLocale);\n         } else {\n-            const UChar *s;\n-            c=map(c, utf8_caseContextIterator, csc, &s, caseLocale);\n+            c = ucase_toFullFolding(c, &s, options);\n+        }\n+        if (c >= 0) {\n+            ByteSinkUtil::appendUnchanged(src + prev, cpStart - prev,\n+                                          sink, options, edits, errorCode);\n             appendResult(srcIndex - cpStart, c, s, sink, options, edits, errorCode);\n+            prev = srcIndex;\n         }\n     }\n+    ByteSinkUtil::appendUnchanged(src + prev, srcIndex - prev,\n+                                  sink, options, edits, errorCode);\n }\n \n+void toUpper(int32_t caseLocale, uint32_t options,\n+             const uint8_t *src, UCaseContext *csc, int32_t srcLength,\n+             icu::ByteSink &sink, icu::Edits *edits, UErrorCode &errorCode) {\n+    const int8_t *latinToUpper;\n+    if (caseLocale == UCASE_LOC_TURKISH) {\n+        latinToUpper = LatinCase::TO_UPPER_TR;\n+    } else {\n+        latinToUpper = LatinCase::TO_UPPER_NORMAL;\n+    }\n+    const UTrie2 *trie = ucase_getTrie();\n+    int32_t prev = 0;\n+    int32_t srcIndex = 0;\n+    for (;;) {\n+        // fast path for simple cases\n+        int32_t cpStart;\n+        UChar32 c;\n+        for (;;) {\n+            if (U_FAILURE(errorCode) || srcIndex >= srcLength) {\n+                c = U_SENTINEL;\n+                break;\n+            }\n+            uint8_t lead = src[srcIndex++];\n+            if (lead <= 0x7f) {\n+                int8_t d = latinToUpper[lead];\n+                if (d == LatinCase::EXC) {\n+                    cpStart = srcIndex - 1;\n+                    c = lead;\n+                    break;\n+                }\n+                if (d == 0) { continue; }\n+                ByteSinkUtil::appendUnchanged(src + prev, srcIndex - 1 - prev,\n+                                              sink, options, edits, errorCode);\n+                char ascii = (char)(lead + d);\n+                sink.Append(&ascii, 1);\n+                if (edits != nullptr) {\n+                    edits->addReplace(1, 1);\n+                }\n+                prev = srcIndex;\n+                continue;\n+            } else if (lead < 0xe3) {\n+                uint8_t t;\n+                if (0xc2 <= lead && lead <= 0xc5 && srcIndex < srcLength &&\n+                        (t = src[srcIndex] - 0x80) <= 0x3f) {\n+                    // U+0080..U+017F\n+                    ++srcIndex;\n+                    c = ((lead - 0xc0) << 6) | t;\n+                    int8_t d = latinToUpper[c];\n+                    if (d == LatinCase::EXC) {\n+                        cpStart = srcIndex - 2;\n+                        break;\n+                    }\n+                    if (d == 0) { continue; }\n+                    ByteSinkUtil::appendUnchanged(src + prev, srcIndex - 2 - prev,\n+                                                  sink, options, edits, errorCode);\n+                    ByteSinkUtil::appendTwoBytes(c + d, sink);\n+                    if (edits != nullptr) {\n+                        edits->addReplace(2, 2);\n+                    }\n+                    prev = srcIndex;\n+                    continue;\n+                }\n+            } else if ((lead <= 0xe9 || lead == 0xeb || lead == 0xec) &&\n+                    (srcIndex + 2) <= srcLength &&\n+                    U8_IS_TRAIL(src[srcIndex]) && U8_IS_TRAIL(src[srcIndex + 1])) {\n+                // most of CJK: no case mappings\n+                srcIndex += 2;\n+                continue;\n+            }\n+            cpStart = --srcIndex;\n+            U8_NEXT(src, srcIndex, srcLength, c);\n+            if (c < 0) {\n+                // ill-formed UTF-8\n+                continue;\n+            }\n+            uint16_t props = UTRIE2_GET16(trie, c);\n+            if (UCASE_HAS_EXCEPTION(props)) { break; }\n+            int32_t delta;\n+            if (UCASE_GET_TYPE(props) != UCASE_LOWER || (delta = UCASE_GET_DELTA(props)) == 0) {\n+                continue;\n+            }\n+            ByteSinkUtil::appendUnchanged(src + prev, cpStart - prev,\n+                                          sink, options, edits, errorCode);\n+            ByteSinkUtil::appendCodePoint(srcIndex - cpStart, c + delta, sink, edits);\n+            prev = srcIndex;\n+        }\n+        if (c < 0) {\n+            break;\n+        }\n+        // slow path\n+        csc->cpStart = cpStart;\n+        csc->cpLimit = srcIndex;\n+        const UChar *s;\n+        c = ucase_toFullUpper(c, utf8_caseContextIterator, csc, &s, caseLocale);\n+        if (c >= 0) {\n+            ByteSinkUtil::appendUnchanged(src + prev, cpStart - prev,\n+                                          sink, options, edits, errorCode);\n+            appendResult(srcIndex - cpStart, c, s, sink, options, edits, errorCode);\n+            prev = srcIndex;\n+        }\n+    }\n+    ByteSinkUtil::appendUnchanged(src + prev, srcIndex - prev,\n+                                  sink, options, edits, errorCode);\n+}\n+\n+}  // namespace\n+\n #if !UCONFIG_NO_BREAK_ITERATION\n \n U_CFUNC void U_CALLCONV\n@@ -335,10 +524,9 @@ ucasemap_internalUTF8ToTitle(\n                 if(titleLimit<index) {\n                     if((options&U_TITLECASE_NO_LOWERCASE)==0) {\n                         /* Normal operation: Lowercase the rest of the word. */\n-                        _caseMap(caseLocale, options, ucase_toFullLower,\n-                                 src, &csc,\n-                                 titleLimit, index,\n-                                 sink, edits, errorCode);\n+                        toLower(caseLocale, options,\n+                                src, &csc, titleLimit, index,\n+                                sink, edits, errorCode);\n                         if(U_FAILURE(errorCode)) {\n                             return;\n                         }\n@@ -538,8 +726,8 @@ ucasemap_internalUTF8ToLower(int32_t caseLocale, uint32_t options, UCASEMAP_BREA\n     UCaseContext csc=UCASECONTEXT_INITIALIZER;\n     csc.p=(void *)src;\n     csc.limit=srcLength;\n-    _caseMap(\n-        caseLocale, options, ucase_toFullLower,\n+    toLower(\n+        caseLocale, options,\n         src, &csc, 0, srcLength,\n         sink, edits, errorCode);\n }\n@@ -555,9 +743,9 @@ ucasemap_internalUTF8ToUpper(int32_t caseLocale, uint32_t options, UCASEMAP_BREA\n         UCaseContext csc=UCASECONTEXT_INITIALIZER;\n         csc.p=(void *)src;\n         csc.limit=srcLength;\n-        _caseMap(\n-            caseLocale, options, ucase_toFullUpper,\n-            src, &csc, 0, srcLength,\n+        toUpper(\n+            caseLocale, options,\n+            src, &csc, srcLength,\n             sink, edits, errorCode);\n     }\n }\n@@ -567,22 +755,10 @@ ucasemap_internalUTF8Fold(int32_t /* caseLocale */, uint32_t options, UCASEMAP_B\n                           const uint8_t *src, int32_t srcLength,\n                           icu::ByteSink &sink, icu::Edits *edits,\n                           UErrorCode &errorCode) {\n-    /* case mapping loop */\n-    int32_t srcIndex = 0;\n-    while (U_SUCCESS(errorCode) && srcIndex < srcLength) {\n-        int32_t cpStart = srcIndex;\n-        UChar32 c;\n-        U8_NEXT(src, srcIndex, srcLength, c);\n-        if(c<0) {\n-            // Malformed UTF-8.\n-            ByteSinkUtil::appendUnchanged(src+cpStart, srcIndex-cpStart,\n-                                          sink, options, edits, errorCode);\n-        } else {\n-            const UChar *s;\n-            c = ucase_toFullFolding(c, &s, options);\n-            appendResult(srcIndex - cpStart, c, s, sink, options, edits, errorCode);\n-        }\n-    }\n+    toLower(\n+        -1, options,\n+        src, nullptr, 0, srcLength,\n+        sink, edits, errorCode);\n }\n \n void"
        },
        {
            "sha": "7788fd93710305e08e9a8a6bd96b61fd4afb1267",
            "filename": "deps/icu-small/source/common/ucasemap_imp.h",
            "status": "modified",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucasemap_imp.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucasemap_imp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucasemap_imp.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -60,15 +60,6 @@ u_caseInsensitivePrefixMatch(const UChar *s1, int32_t length1,\n                              int32_t *matchLen1, int32_t *matchLen2,\n                              UErrorCode *pErrorCode);\n \n-/**\n- * Are the Unicode properties loaded?\n- * This must be used before internal functions are called that do\n- * not perform this check.\n- * Generate a debug assertion failure if data is not loaded.\n- */\n-U_CFUNC UBool\n-uprv_haveProperties(UErrorCode *pErrorCode);\n-\n #ifdef __cplusplus\n \n U_NAMESPACE_BEGIN"
        },
        {
            "sha": "996c3fdc40227b81e9aacf5bfb2de89f98b3dd3d",
            "filename": "deps/icu-small/source/common/uchar.cpp",
            "status": "modified",
            "additions": 0,
            "deletions": 8,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fuchar.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fuchar.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fuchar.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -42,14 +42,6 @@\n /* getting a uint32_t properties word from the data */\n #define GET_PROPS(c, result) ((result)=UTRIE2_GET16(&propsTrie, c));\n \n-U_CFUNC UBool\n-uprv_haveProperties(UErrorCode *pErrorCode) {\n-    if(U_FAILURE(*pErrorCode)) {\n-        return FALSE;\n-    }\n-    return TRUE;\n-}\n-\n /* API functions ------------------------------------------------------------ */\n \n /* Gets the Unicode character's general category.*/"
        },
        {
            "sha": "ba2310bb7ab8a5c5e470373b6df0d35f86418ab8",
            "filename": "deps/icu-small/source/common/ucmndata.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucmndata.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucmndata.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucmndata.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -77,7 +77,11 @@ typedef struct {\n typedef struct  {\n     uint32_t          count;\n     uint32_t          reserved;\n-    PointerTOCEntry   entry[2];   /* Actual size is from count. */\n+    /**\n+     * Variable-length array declared with length 1 to disable bounds checkers.\n+     * The actual array length is in the count field.\n+     */\n+    PointerTOCEntry   entry[1];\n }  PointerTOC;\n \n "
        },
        {
            "sha": "16844414327259a0c2dacaff7b26c46b60dc562f",
            "filename": "deps/icu-small/source/common/ucmndata.h",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucmndata.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucmndata.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucmndata.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -52,7 +52,11 @@ typedef struct {\n \n typedef struct {\n     uint32_t count;\n-    UDataOffsetTOCEntry entry[2];    /* Actual size of array is from count. */\n+    /**\n+     * Variable-length array declared with length 1 to disable bounds checkers.\n+     * The actual array length is in the count field.\n+     */\n+    UDataOffsetTOCEntry entry[1];\n } UDataOffsetTOC;\n \n /**"
        },
        {
            "sha": "854ca60cc313205d15d95af32ae30ed13c3d3288",
            "filename": "deps/icu-small/source/common/ucnv2022.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv2022.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv2022.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv2022.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -3512,14 +3512,14 @@ _ISO_2022_WriteSub(UConverterFromUnicodeArgs *args, int32_t offsetIndex, UErrorC\n     case 'k':\n         if(myConverterData->version == 0) {\n             if(length == 1) {\n-                if((UBool)args->converter->fromUnicodeStatus) {\n+                if(args->converter->fromUnicodeStatus) {\n                     /* in DBCS mode: switch to SBCS */\n                     args->converter->fromUnicodeStatus = 0;\n                     *p++ = UCNV_SI;\n                 }\n                 *p++ = subchar[0];\n             } else /* length == 2*/ {\n-                if(!(UBool)args->converter->fromUnicodeStatus) {\n+                if(!args->converter->fromUnicodeStatus) {\n                     /* in SBCS mode: switch to DBCS */\n                     args->converter->fromUnicodeStatus = 1;\n                     *p++ = UCNV_SO;"
        },
        {
            "sha": "63794d2334f62b786c2a2370b188747bcac7c600",
            "filename": "deps/icu-small/source/common/ucnv_err.cpp",
            "status": "modified",
            "additions": 11,
            "deletions": 21,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_err.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_err.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_err.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -60,11 +60,12 @@\n  * To avoid dependency on other code, this list is hard coded here.\n  * When an ignorable code point is found and is unmappable, the default callbacks\n  * will ignore them.\n- * For a list of the default ignorable code points, use this link: http://unicode.org/cldr/utility/list-unicodeset.jsp?a=[%3ADI%3A]&g=\n+ * For a list of the default ignorable code points, use this link:\n+ * https://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3ADI%3A%5D&abb=on&g=&i=\n  *\n  * This list should be sync with the one in CharsetCallback.java\n  */\n-#define IS_DEFAULT_IGNORABLE_CODE_POINT(c) (\\\n+#define IS_DEFAULT_IGNORABLE_CODE_POINT(c) ( \\\n     (c == 0x00AD) || \\\n     (c == 0x034F) || \\\n     (c == 0x061C) || \\\n@@ -74,26 +75,15 @@\n     (0x180B <= c && c <= 0x180E) || \\\n     (0x200B <= c && c <= 0x200F) || \\\n     (0x202A <= c && c <= 0x202E) || \\\n-    (c == 0x2060) || \\\n-    (0x2066 <= c && c <= 0x2069) || \\\n-    (0x2061 <= c && c <= 0x2064) || \\\n-    (0x206A <= c && c <= 0x206F) || \\\n+    (0x2060 <= c && c <= 0x206F) || \\\n     (c == 0x3164) || \\\n-    (0x0FE00 <= c && c <= 0x0FE0F) || \\\n-    (c == 0x0FEFF) || \\\n-    (c == 0x0FFA0) || \\\n-    (0x01BCA0  <= c && c <= 0x01BCA3) || \\\n-    (0x01D173 <= c && c <= 0x01D17A) || \\\n-    (c == 0x0E0001) || \\\n-    (0x0E0020 <= c && c <= 0x0E007F) || \\\n-    (0x0E0100 <= c && c <= 0x0E01EF) || \\\n-    (c == 0x2065) || \\\n-    (0x0FFF0 <= c && c <= 0x0FFF8) || \\\n-    (c == 0x0E0000) || \\\n-    (0x0E0002 <= c && c <= 0x0E001F) || \\\n-    (0x0E0080 <= c && c <= 0x0E00FF) || \\\n-    (0x0E01F0 <= c && c <= 0x0E0FFF) \\\n-    )\n+    (0xFE00 <= c && c <= 0xFE0F) || \\\n+    (c == 0xFEFF) || \\\n+    (c == 0xFFA0) || \\\n+    (0xFFF0 <= c && c <= 0xFFF8) || \\\n+    (0x1BCA0 <= c && c <= 0x1BCA3) || \\\n+    (0x1D173 <= c && c <= 0x1D17A) || \\\n+    (0xE0000 <= c && c <= 0xE0FFF))\n \n \n /*Function Pointer STOPS at the ILLEGAL_SEQUENCE */"
        },
        {
            "sha": "ca8c6788d3dd973833117dbb9c7a93ee5f82e4f0",
            "filename": "deps/icu-small/source/common/ucnv_u32.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u32.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u32.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u32.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -55,7 +55,7 @@ T_UConverter_toUnicode_UTF32_BE(UConverterToUnicodeArgs * args,\n     uint32_t ch, i;\n \n     /* Restore state of current sequence */\n-    if (args->converter->toUnicodeStatus && myTarget < targetLimit) {\n+    if (args->converter->toULength > 0 && myTarget < targetLimit) {\n         i = args->converter->toULength;       /* restore # of bytes consumed */\n         args->converter->toULength = 0;\n \n@@ -136,7 +136,7 @@ T_UConverter_toUnicode_UTF32_BE_OFFSET_LOGIC(UConverterToUnicodeArgs * args,\n     int32_t offsetNum = 0;\n \n     /* Restore state of current sequence */\n-    if (args->converter->toUnicodeStatus && myTarget < targetLimit) {\n+    if (args->converter->toULength > 0 && myTarget < targetLimit) {\n         i = args->converter->toULength;       /* restore # of bytes consumed */\n         args->converter->toULength = 0;\n \n@@ -517,7 +517,7 @@ T_UConverter_toUnicode_UTF32_LE(UConverterToUnicodeArgs * args,\n     uint32_t ch, i;\n \n     /* Restore state of current sequence */\n-    if (args->converter->toUnicodeStatus && myTarget < targetLimit)\n+    if (args->converter->toULength > 0 && myTarget < targetLimit)\n     {\n         i = args->converter->toULength;       /* restore # of bytes consumed */\n         args->converter->toULength = 0;\n@@ -604,7 +604,7 @@ T_UConverter_toUnicode_UTF32_LE_OFFSET_LOGIC(UConverterToUnicodeArgs * args,\n     int32_t offsetNum = 0;\n \n     /* Restore state of current sequence */\n-    if (args->converter->toUnicodeStatus && myTarget < targetLimit)\n+    if (args->converter->toULength > 0 && myTarget < targetLimit)\n     {\n         i = args->converter->toULength;       /* restore # of bytes consumed */\n         args->converter->toULength = 0;"
        },
        {
            "sha": "5a07244b02bf9c4fabec0ddc29bffe42e5450d29",
            "filename": "deps/icu-small/source/common/ucnv_u8.cpp",
            "status": "modified",
            "additions": 15,
            "deletions": 39,
            "changes": 54,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u8.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u8.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u8.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -76,7 +76,7 @@ static void  U_CALLCONV ucnv_toUnicode_UTF8 (UConverterToUnicodeArgs * args,\n     int32_t i, inBytes;\n \n     /* Restore size of current sequence */\n-    if (cnv->toUnicodeStatus && myTarget < targetLimit)\n+    if (cnv->toULength > 0 && myTarget < targetLimit)\n     {\n         inBytes = cnv->mode;            /* restore # of bytes to consume */\n         i = cnv->toULength;             /* restore # of bytes consumed */\n@@ -194,7 +194,7 @@ static void  U_CALLCONV ucnv_toUnicode_UTF8_OFFSETS_LOGIC (UConverterToUnicodeAr\n     int32_t i, inBytes;\n \n     /* Restore size of current sequence */\n-    if (cnv->toUnicodeStatus && myTarget < targetLimit)\n+    if (cnv->toULength > 0 && myTarget < targetLimit)\n     {\n         inBytes = cnv->mode;            /* restore # of bytes to consume */\n         i = cnv->toULength;             /* restore # of bytes consumed */\n@@ -670,12 +670,13 @@ ucnv_UTF8FromUTF8(UConverterFromUnicodeArgs *pFromUArgs,\n     targetCapacity=(int32_t)(pFromUArgs->targetLimit-pFromUArgs->target);\n \n     /* get the converter state from the UTF-8 UConverter */\n-    c=(UChar32)utf8->toUnicodeStatus;\n-    if(c!=0) {\n+    if(utf8->toULength > 0) {\n         toULength=oldToULength=utf8->toULength;\n         toULimit=(int8_t)utf8->mode;\n+        c=(UChar32)utf8->toUnicodeStatus;\n     } else {\n         toULength=oldToULength=toULimit=0;\n+        c = 0;\n     }\n \n     count=(int32_t)(sourceLimit-source)+oldToULength;\n@@ -695,36 +696,20 @@ ucnv_UTF8FromUTF8(UConverterFromUnicodeArgs *pFromUArgs,\n         // Use a single counter for source and target, counting the minimum of\n         // the source length and the target capacity.\n         // Let the standard converter handle edge cases.\n-        const uint8_t *limit=sourceLimit;\n         if(count>targetCapacity) {\n-            limit-=(count-targetCapacity);\n             count=targetCapacity;\n         }\n \n-        // The conversion loop checks count>0 only once per 1/2/3-byte character.\n-        // If the buffer ends with a truncated 2- or 3-byte sequence,\n+        // The conversion loop checks count>0 only once per character.\n+        // If the buffer ends with a truncated sequence,\n         // then we reduce the count to stop before that,\n         // and collect the remaining bytes after the conversion loop.\n-        {\n-            // Do not go back into the bytes that will be read for finishing a partial\n-            // sequence from the previous buffer.\n-            int32_t length=count-toULimit;\n-            if(length>0) {\n-                uint8_t b1=*(limit-1);\n-                if(U8_IS_SINGLE(b1)) {\n-                    // common ASCII character\n-                } else if(U8_IS_TRAIL(b1) && length>=2) {\n-                    uint8_t b2=*(limit-2);\n-                    if(0xe0<=b2 && b2<0xf0 && U8_IS_VALID_LEAD3_AND_T1(b2, b1)) {\n-                        // truncated 3-byte sequence\n-                        count-=2;\n-                    }\n-                } else if(0xc2<=b1 && b1<0xf0) {\n-                    // truncated 2- or 3-byte sequence\n-                    --count;\n-                }\n-            }\n-        }\n+\n+        // Do not go back into the bytes that will be read for finishing a partial\n+        // sequence from the previous buffer.\n+        int32_t length=count-toULimit;\n+        U8_TRUNCATE_IF_INCOMPLETE(source, 0, length);\n+        count=toULimit+length;\n     }\n \n     if(c!=0) {\n@@ -814,7 +799,7 @@ ucnv_UTF8FromUTF8(UConverterFromUnicodeArgs *pFromUArgs,\n             }\n \n             /* copy the legal byte sequence to the target */\n-            if(count>=toULength) {\n+            {\n                 int8_t i;\n \n                 for(i=0; i<oldToULength; ++i) {\n@@ -825,14 +810,6 @@ ucnv_UTF8FromUTF8(UConverterFromUnicodeArgs *pFromUArgs,\n                     *target++=*source++;\n                 }\n                 count-=toULength;\n-            } else {\n-                // A supplementary character that does not fit into the target.\n-                // Let the standard converter handle this.\n-                source-=(toULength-oldToULength);\n-                pToUArgs->source=(char *)source;\n-                pFromUArgs->target=(char *)target;\n-                *pErrorCode=U_USING_DEFAULT_WARNING;\n-                return;\n             }\n         }\n     }\n@@ -856,8 +833,7 @@ ucnv_UTF8FromUTF8(UConverterFromUnicodeArgs *pFromUArgs,\n                         utf8->toULength=toULength;\n                         utf8->mode=toULimit;\n                         break;\n-                    } else if(!U8_IS_TRAIL(b=*source)) {\n-                        /* lead byte in trail byte position */\n+                    } else if(!icu::UTF8::isValidTrail(c, b=*source, toULength, toULimit)) {\n                         utf8->toULength=toULength;\n                         *pErrorCode=U_ILLEGAL_CHAR_FOUND;\n                         break;"
        },
        {
            "sha": "15eeb5c51f5fb3f47d8ef2a958f489a188201672",
            "filename": "deps/icu-small/source/common/ucnvlat1.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvlat1.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvlat1.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvlat1.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -340,7 +340,11 @@ ucnv_Latin1FromUTF8(UConverterFromUnicodeArgs *pFromUArgs,\n     targetCapacity=(int32_t)(pFromUArgs->targetLimit-pFromUArgs->target);\n \n     /* get the converter state from the UTF-8 UConverter */\n-    c=(UChar32)utf8->toUnicodeStatus;\n+    if (utf8->toULength > 0) {\n+        c=(UChar32)utf8->toUnicodeStatus;\n+    } else {\n+        c = 0;\n+    }\n     if(c!=0 && source<sourceLimit) {\n         if(targetCapacity==0) {\n             *pErrorCode=U_BUFFER_OVERFLOW_ERROR;\n@@ -620,7 +624,7 @@ ucnv_ASCIIFromUTF8(UConverterFromUnicodeArgs *pFromUArgs,\n \n     uint8_t c;\n \n-    if(pToUArgs->converter->toUnicodeStatus!=0) {\n+    if(pToUArgs->converter->toULength > 0) {\n         /* no handling of partial UTF-8 characters here, fall back to pivoting */\n         *pErrorCode=U_USING_DEFAULT_WARNING;\n         return;"
        },
        {
            "sha": "9052394b4ff8d1adcebd12a62121f1077ba408d6",
            "filename": "deps/icu-small/source/common/ucnvmbcs.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvmbcs.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvmbcs.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvmbcs.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -5064,12 +5064,13 @@ ucnv_SBCSFromUTF8(UConverterFromUnicodeArgs *pFromUArgs,\n     hasSupplementary=(UBool)(cnv->sharedData->mbcs.unicodeMask&UCNV_HAS_SUPPLEMENTARY);\n \n     /* get the converter state from the UTF-8 UConverter */\n-    c=(UChar32)utf8->toUnicodeStatus;\n-    if(c!=0) {\n+    if(utf8->toULength > 0) {\n         toULength=oldToULength=utf8->toULength;\n         toULimit=(int8_t)utf8->mode;\n+        c=(UChar32)utf8->toUnicodeStatus;\n     } else {\n         toULength=oldToULength=toULimit=0;\n+        c = 0;\n     }\n \n     // The conversion loop checks source<sourceLimit only once per 1/2/3-byte character.\n@@ -5359,12 +5360,13 @@ ucnv_DBCSFromUTF8(UConverterFromUnicodeArgs *pFromUArgs,\n     hasSupplementary=(UBool)(cnv->sharedData->mbcs.unicodeMask&UCNV_HAS_SUPPLEMENTARY);\n \n     /* get the converter state from the UTF-8 UConverter */\n-    c=(UChar32)utf8->toUnicodeStatus;\n-    if(c!=0) {\n+    if(utf8->toULength > 0) {\n         toULength=oldToULength=utf8->toULength;\n         toULimit=(int8_t)utf8->mode;\n+        c=(UChar32)utf8->toUnicodeStatus;\n     } else {\n         toULength=oldToULength=toULimit=0;\n+        c = 0;\n     }\n \n     // The conversion loop checks source<sourceLimit only once per 1/2/3-byte character."
        },
        {
            "sha": "d1e5f62a9a76bb69e85d307130984ce8e85bcc78",
            "filename": "deps/icu-small/source/common/ucurr.cpp",
            "status": "modified",
            "additions": 19,
            "deletions": 10,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucurr.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fucurr.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucurr.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -17,6 +17,7 @@\n #include \"unicode/ustring.h\"\n #include \"unicode/parsepos.h\"\n #include \"ustr_imp.h\"\n+#include \"charstr.h\"\n #include \"cmemory.h\"\n #include \"cstring.h\"\n #include \"uassert.h\"\n@@ -28,9 +29,12 @@\n #include \"uinvchar.h\"\n #include \"uresimp.h\"\n #include \"ulist.h\"\n+#include \"uresimp.h\"\n #include \"ureslocs.h\"\n #include \"ulocimp.h\"\n \n+using namespace icu;\n+\n //#define UCURR_DEBUG_EQUIV 1\n #ifdef UCURR_DEBUG_EQUIV\n #include \"stdio.h\"\n@@ -104,6 +108,7 @@ static const char VAR_DELIM_STR[] = \"_\";\n \n // Tag for localized display names (symbols) of currencies\n static const char CURRENCIES[] = \"Currencies\";\n+static const char CURRENCIES_NARROW[] = \"Currencies%narrow\";\n static const char CURRENCYPLURALS[] = \"CurrencyPlurals\";\n \n static const UChar EUR_STR[] = {0x0045,0x0055,0x0052,0};\n@@ -698,7 +703,7 @@ ucurr_getName(const UChar* currency,\n     }\n \n     int32_t choice = (int32_t) nameStyle;\n-    if (choice < 0 || choice > 1) {\n+    if (choice < 0 || choice > 2) {\n         *ec = U_ILLEGAL_ARGUMENT_ERROR;\n         return 0;\n     }\n@@ -731,15 +736,19 @@ ucurr_getName(const UChar* currency,\n \n     const UChar* s = NULL;\n     ec2 = U_ZERO_ERROR;\n-    UResourceBundle* rb = ures_open(U_ICUDATA_CURR, loc, &ec2);\n-\n-    rb = ures_getByKey(rb, CURRENCIES, rb, &ec2);\n-\n-    // Fetch resource with multi-level resource inheritance fallback\n-    rb = ures_getByKeyWithFallback(rb, buf, rb, &ec2);\n-\n-    s = ures_getStringByIndex(rb, choice, len, &ec2);\n-    ures_close(rb);\n+    LocalUResourceBundlePointer rb(ures_open(U_ICUDATA_CURR, loc, &ec2));\n+\n+    if (nameStyle == UCURR_NARROW_SYMBOL_NAME) {\n+        CharString key;\n+        key.append(CURRENCIES_NARROW, ec2);\n+        key.append(\"/\", ec2);\n+        key.append(buf, ec2);\n+        s = ures_getStringByKeyWithFallback(rb.getAlias(), key.data(), len, &ec2);\n+    } else {\n+        ures_getByKey(rb.getAlias(), CURRENCIES, rb.getAlias(), &ec2);\n+        ures_getByKeyWithFallback(rb.getAlias(), buf, rb.getAlias(), &ec2);\n+        s = ures_getStringByIndex(rb.getAlias(), choice, len, &ec2);\n+    }\n \n     // If we've succeeded we're done.  Otherwise, try to fallback.\n     // If that fails (because we are already at root) then exit."
        },
        {
            "sha": "607f3ec625ab1ffbf7819a47255fd17ecd1180b3",
            "filename": "deps/icu-small/source/common/unicode/brkiter.h",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fbrkiter.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fbrkiter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fbrkiter.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -298,15 +298,14 @@ class U_COMMON_API BreakIterator : public UObject {\n     virtual int32_t next(int32_t n) = 0;\n \n    /**\n-     * For RuleBasedBreakIterators, return the status tag from the\n-     * break rule that determined the most recently\n-     * returned break position.\n+     * For RuleBasedBreakIterators, return the status tag from the break rule\n+     * that determined the boundary at the current iteration position.\n      * <p>\n      * For break iterator types that do not support a rule status,\n      * a default value of 0 is returned.\n      * <p>\n-     * @return the status from the break rule that determined the most recently\n-     *         returned break position.\n+     * @return the status from the break rule that determined the boundary at\n+     *         the current iteration position.\n      * @see RuleBaseBreakIterator::getRuleStatus()\n      * @see UWordBreak\n      * @stable ICU 52\n@@ -315,7 +314,7 @@ class U_COMMON_API BreakIterator : public UObject {\n \n    /**\n     * For RuleBasedBreakIterators, get the status (tag) values from the break rule(s)\n-    * that determined the most recently returned break position.\n+    * that determined the boundary at the current iteration position.\n     * <p>\n     * For break iterator types that do not support rule status,\n     * no values are returned.\n@@ -334,7 +333,7 @@ class U_COMMON_API BreakIterator : public UObject {\n     *                  normal way, without attempting to store any values.\n     * @param status    receives error codes.\n     * @return          The number of rule status values from rules that determined\n-    *                  the most recent boundary returned by the break iterator.\n+    *                  the boundary at the current iteration position.\n     *                  In the event of a U_BUFFER_OVERFLOW_ERROR, the return value\n     *                  is the total number of status values that were available,\n     *                  not the reduced number that were actually returned.\n@@ -616,7 +615,7 @@ class U_COMMON_API BreakIterator : public UObject {\n     virtual BreakIterator &refreshInputText(UText *input, UErrorCode &status) = 0;\n \n  private:\n-    static BreakIterator* buildInstance(const Locale& loc, const char *type, int32_t kind, UErrorCode& status);\n+    static BreakIterator* buildInstance(const Locale& loc, const char *type, UErrorCode& status);\n     static BreakIterator* createInstance(const Locale& loc, int32_t kind, UErrorCode& status);\n     static BreakIterator* makeInstance(const Locale& loc, int32_t kind, UErrorCode& status);\n "
        },
        {
            "sha": "7a806bb7f02096c63fb50d1b7c2ae09fbaeab0ea",
            "filename": "deps/icu-small/source/common/unicode/bytestriebuilder.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fbytestriebuilder.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fbytestriebuilder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fbytestriebuilder.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -154,7 +154,6 @@ class U_COMMON_API BytesTrieBuilder : public StringTrieBuilder {\n         const char *s;\n     };\n \n-    // don't use #ifndef U_HIDE_INTERNAL_API with private class members or virtual methods.\n     virtual Node *createLinearMatchNode(int32_t i, int32_t byteIndex, int32_t length,\n                                         Node *nextNode) const;\n "
        },
        {
            "sha": "4b77256d742784d3c609a5ddad64aadec5e9b814",
            "filename": "deps/icu-small/source/common/unicode/casemap.h",
            "status": "modified",
            "additions": 11,
            "deletions": 13,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fcasemap.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fcasemap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fcasemap.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -18,16 +18,14 @@\n \n U_NAMESPACE_BEGIN\n \n-#ifndef U_HIDE_DRAFT_API\n-\n class BreakIterator;\n class ByteSink;\n class Edits;\n \n /**\n  * Low-level C++ case mapping functions.\n  *\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n class U_COMMON_API CaseMap U_FINAL : public UMemory {\n public:\n@@ -59,7 +57,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *         the full length is returned and a U_BUFFER_OVERFLOW_ERROR is set.\n      *\n      * @see u_strToLower\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n      static int32_t toLower(\n             const char *locale, uint32_t options,\n@@ -95,7 +93,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *         the full length is returned and a U_BUFFER_OVERFLOW_ERROR is set.\n      *\n      * @see u_strToUpper\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     static int32_t toUpper(\n             const char *locale, uint32_t options,\n@@ -146,7 +144,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *\n      * @see u_strToTitle\n      * @see ucasemap_toTitle\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     static int32_t toTitle(\n             const char *locale, uint32_t options, BreakIterator *iter,\n@@ -188,14 +186,15 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *         the full length is returned and a U_BUFFER_OVERFLOW_ERROR is set.\n      *\n      * @see u_strFoldCase\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     static int32_t fold(\n             uint32_t options,\n             const char16_t *src, int32_t srcLength,\n             char16_t *dest, int32_t destCapacity, Edits *edits,\n             UErrorCode &errorCode);\n \n+#ifndef U_HIDE_DRAFT_API\n     /**\n      * Lowercases a UTF-8 string and optionally records edits.\n      * Casing is locale-dependent and context-sensitive.\n@@ -318,6 +317,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n             uint32_t options,\n             StringPiece src, ByteSink &sink, Edits *edits,\n             UErrorCode &errorCode);\n+#endif  // U_HIDE_DRAFT_API\n \n     /**\n      * Lowercases a UTF-8 string and optionally records edits.\n@@ -347,7 +347,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *         the full length is returned and a U_BUFFER_OVERFLOW_ERROR is set.\n      *\n      * @see ucasemap_utf8ToLower\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     static int32_t utf8ToLower(\n             const char *locale, uint32_t options,\n@@ -383,7 +383,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *         the full length is returned and a U_BUFFER_OVERFLOW_ERROR is set.\n      *\n      * @see ucasemap_utf8ToUpper\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     static int32_t utf8ToUpper(\n             const char *locale, uint32_t options,\n@@ -433,7 +433,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *         the full length is returned and a U_BUFFER_OVERFLOW_ERROR is set.\n      *\n      * @see ucasemap_utf8ToTitle\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     static int32_t utf8ToTitle(\n             const char *locale, uint32_t options, BreakIterator *iter,\n@@ -475,7 +475,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *         the full length is returned and a U_BUFFER_OVERFLOW_ERROR is set.\n      *\n      * @see ucasemap_utf8FoldCase\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     static int32_t utf8Fold(\n             uint32_t options,\n@@ -489,8 +489,6 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n     CaseMap &operator=(const CaseMap &other) = delete;\n };\n \n-#endif  // U_HIDE_DRAFT_API\n-\n U_NAMESPACE_END\n \n #endif  // __CASEMAP_H__"
        },
        {
            "sha": "49d0e029a93b6e592e81297ce87abbb916a78717",
            "filename": "deps/icu-small/source/common/unicode/char16ptr.h",
            "status": "modified",
            "additions": 20,
            "deletions": 24,
            "changes": 44,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fchar16ptr.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fchar16ptr.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fchar16ptr.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -30,25 +30,23 @@ U_NAMESPACE_BEGIN\n #   define U_ALIASING_BARRIER(ptr) asm volatile(\"\" : : \"rm\"(ptr) : \"memory\")\n #endif\n \n-// Do not use #ifndef U_HIDE_DRAFT_API for the following class, it\n-// is now used in place of UChar* in several stable C++ methods\n /**\n  * char16_t * wrapper with implicit conversion from distinct but bit-compatible pointer types.\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n class U_COMMON_API Char16Ptr U_FINAL {\n public:\n     /**\n      * Copies the pointer.\n      * @param p pointer\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline Char16Ptr(char16_t *p);\n #if !U_CHAR16_IS_TYPEDEF\n     /**\n      * Converts the pointer to char16_t *.\n      * @param p pointer to be converted\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline Char16Ptr(uint16_t *p);\n #endif\n@@ -57,32 +55,32 @@ class U_COMMON_API Char16Ptr U_FINAL {\n      * Converts the pointer to char16_t *.\n      * (Only defined if U_SIZEOF_WCHAR_T==2.)\n      * @param p pointer to be converted\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline Char16Ptr(wchar_t *p);\n #endif\n     /**\n      * nullptr constructor.\n      * @param p nullptr\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline Char16Ptr(std::nullptr_t p);\n     /**\n      * Destructor.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline ~Char16Ptr();\n \n     /**\n      * Pointer access.\n      * @return the wrapped pointer\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline char16_t *get() const;\n     /**\n      * char16_t pointer access via type conversion (e.g., static_cast).\n      * @return the wrapped pointer\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline operator char16_t *() const { return get(); }\n \n@@ -137,25 +135,23 @@ char16_t *Char16Ptr::get() const { return u_.cp; }\n \n #endif\n \n-// Do not use #ifndef U_HIDE_DRAFT_API for the following class, it is\n-// now used in place of const UChar* in several stable C++ methods\n /**\n  * const char16_t * wrapper with implicit conversion from distinct but bit-compatible pointer types.\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n class U_COMMON_API ConstChar16Ptr U_FINAL {\n public:\n     /**\n      * Copies the pointer.\n      * @param p pointer\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline ConstChar16Ptr(const char16_t *p);\n #if !U_CHAR16_IS_TYPEDEF\n     /**\n      * Converts the pointer to char16_t *.\n      * @param p pointer to be converted\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline ConstChar16Ptr(const uint16_t *p);\n #endif\n@@ -164,33 +160,33 @@ class U_COMMON_API ConstChar16Ptr U_FINAL {\n      * Converts the pointer to char16_t *.\n      * (Only defined if U_SIZEOF_WCHAR_T==2.)\n      * @param p pointer to be converted\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline ConstChar16Ptr(const wchar_t *p);\n #endif\n     /**\n      * nullptr constructor.\n      * @param p nullptr\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline ConstChar16Ptr(const std::nullptr_t p);\n \n     /**\n      * Destructor.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline ~ConstChar16Ptr();\n \n     /**\n      * Pointer access.\n      * @return the wrapped pointer\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline const char16_t *get() const;\n     /**\n      * char16_t pointer access via type conversion (e.g., static_cast).\n      * @return the wrapped pointer\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     inline operator const char16_t *() const { return get(); }\n \n@@ -250,7 +246,7 @@ const char16_t *ConstChar16Ptr::get() const { return u_.cp; }\n  * Includes an aliasing barrier if available.\n  * @param p pointer\n  * @return p as const UChar *\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n inline const UChar *toUCharPtr(const char16_t *p) {\n #ifdef U_ALIASING_BARRIER\n@@ -264,7 +260,7 @@ inline const UChar *toUCharPtr(const char16_t *p) {\n  * Includes an aliasing barrier if available.\n  * @param p pointer\n  * @return p as UChar *\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n inline UChar *toUCharPtr(char16_t *p) {\n #ifdef U_ALIASING_BARRIER\n@@ -278,7 +274,7 @@ inline UChar *toUCharPtr(char16_t *p) {\n  * Includes an aliasing barrier if available.\n  * @param p pointer\n  * @return p as const OldUChar *\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n inline const OldUChar *toOldUCharPtr(const char16_t *p) {\n #ifdef U_ALIASING_BARRIER\n@@ -292,7 +288,7 @@ inline const OldUChar *toOldUCharPtr(const char16_t *p) {\n  * Includes an aliasing barrier if available.\n  * @param p pointer\n  * @return p as OldUChar *\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n inline OldUChar *toOldUCharPtr(char16_t *p) {\n #ifdef U_ALIASING_BARRIER"
        },
        {
            "sha": "292794f6d65832440cdb46f6bbe5d642744e026b",
            "filename": "deps/icu-small/source/common/unicode/chariter.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fchariter.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fchariter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fchariter.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -569,7 +569,7 @@ class U_COMMON_API CharacterIterator : public ForwardCharacterIterator {\n      * Returns the numeric index in the underlying text-storage\n      * object of the character the iterator currently refers to\n      * (i.e., the character returned by current()).\n-     * @return the numberic index in the text-storage object of\n+     * @return the numeric index in the text-storage object of\n      * the character the iterator currently refers to\n      * @stable ICU 2.0\n      */"
        },
        {
            "sha": "c99011e26c81dd762557d766347560cd4e5adbcc",
            "filename": "deps/icu-small/source/common/unicode/dtintrv.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fdtintrv.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fdtintrv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fdtintrv.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -69,7 +69,7 @@ class U_COMMON_API DateInterval : public UObject {\n      * <pre>\n      * .   Base* polymorphic_pointer = createPolymorphicObject();\n      * .   if (polymorphic_pointer->getDynamicClassID() ==\n-     * .       erived::getStaticClassID()) ...\n+     * .       derived::getStaticClassID()) ...\n      * </pre>\n      * @return          The class ID for all objects of this class.\n      * @stable ICU 4.0"
        },
        {
            "sha": "5a72574c140db644664fd7a0baa96576a76e8fec",
            "filename": "deps/icu-small/source/common/unicode/edits.h",
            "status": "modified",
            "additions": 30,
            "deletions": 28,
            "changes": 58,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fedits.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fedits.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fedits.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -17,8 +17,6 @@\n \n U_NAMESPACE_BEGIN\n \n-#ifndef U_HIDE_DRAFT_API\n-\n /**\n  * Records lengths of string edits but not replacement text.\n  * Supports replacements, insertions, deletions in linear progression.\n@@ -27,13 +25,13 @@ U_NAMESPACE_BEGIN\n  * An Edits object tracks a separate UErrorCode, but ICU string transformation functions\n  * (e.g., case mapping functions) merge any such errors into their API's UErrorCode.\n  *\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n class U_COMMON_API Edits U_FINAL : public UMemory {\n public:\n     /**\n      * Constructs an empty object.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     Edits() :\n             array(stackArray), capacity(STACK_CAPACITY), length(0), delta(0), numChanges(0),\n@@ -64,7 +62,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n \n     /**\n      * Destructor.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     ~Edits();\n \n@@ -88,20 +86,20 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n \n     /**\n      * Resets the data but may not release memory.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     void reset() U_NOEXCEPT;\n \n     /**\n      * Adds a record for an unchanged segment of text.\n      * Normally called from inside ICU string transformation functions, not user code.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     void addUnchanged(int32_t unchangedLength);\n     /**\n      * Adds a record for a text replacement/insertion/deletion.\n      * Normally called from inside ICU string transformation functions, not user code.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     void addReplace(int32_t oldLength, int32_t newLength);\n     /**\n@@ -112,33 +110,35 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      *                  and an error occurred while recording edits.\n      *                  Otherwise unchanged.\n      * @return TRUE if U_FAILURE(outErrorCode)\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     UBool copyErrorTo(UErrorCode &outErrorCode);\n \n     /**\n      * How much longer is the new text compared with the old text?\n      * @return new length minus old length\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     int32_t lengthDelta() const { return delta; }\n     /**\n      * @return TRUE if there are any change edits\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     UBool hasChanges() const { return numChanges != 0; }\n \n+#ifndef U_HIDE_DRAFT_API\n     /**\n      * @return the number of change edits\n      * @draft ICU 60\n      */\n     int32_t numberOfChanges() const { return numChanges; }\n+#endif  // U_HIDE_DRAFT_API\n \n     /**\n      * Access to the list of edits.\n      * @see getCoarseIterator\n      * @see getFineIterator\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     struct U_COMMON_API Iterator U_FINAL : public UMemory {\n         /**\n@@ -152,12 +152,12 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n                 srcIndex(0), replIndex(0), destIndex(0) {}\n         /**\n          * Copy constructor.\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         Iterator(const Iterator &other) = default;\n         /**\n          * Assignment operator.\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         Iterator &operator=(const Iterator &other) = default;\n \n@@ -167,7 +167,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n          *                  or else the function returns immediately. Check for U_FAILURE()\n          *                  on output or use with function chaining. (See User Guide for details.)\n          * @return TRUE if there is another edit\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         UBool next(UErrorCode &errorCode) { return next(onlyChanges_, errorCode); }\n \n@@ -188,12 +188,13 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n          *                  or else the function returns immediately. Check for U_FAILURE()\n          *                  on output or use with function chaining. (See User Guide for details.)\n          * @return TRUE if the edit for the source index was found\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         UBool findSourceIndex(int32_t i, UErrorCode &errorCode) {\n             return findIndex(i, TRUE, errorCode) == 0;\n         }\n \n+#ifndef U_HIDE_DRAFT_API\n         /**\n          * Finds the edit that contains the destination index.\n          * The destination index may be found in a non-change\n@@ -264,39 +265,40 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n          * @draft ICU 60\n          */\n         int32_t sourceIndexFromDestinationIndex(int32_t i, UErrorCode &errorCode);\n+#endif  // U_HIDE_DRAFT_API\n \n         /**\n          * @return TRUE if this edit replaces oldLength() units with newLength() different ones.\n          *         FALSE if oldLength units remain unchanged.\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         UBool hasChange() const { return changed; }\n         /**\n          * @return the number of units in the original string which are replaced or remain unchanged.\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         int32_t oldLength() const { return oldLength_; }\n         /**\n          * @return the number of units in the modified string, if hasChange() is TRUE.\n          *         Same as oldLength if hasChange() is FALSE.\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         int32_t newLength() const { return newLength_; }\n \n         /**\n          * @return the current index into the source string\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         int32_t sourceIndex() const { return srcIndex; }\n         /**\n          * @return the current index into the replacement-characters-only string,\n          *         not counting unchanged spans\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         int32_t replacementIndex() const { return replIndex; }\n         /**\n          * @return the current index into the full destination string\n-         * @draft ICU 59\n+         * @stable ICU 59\n          */\n         int32_t destinationIndex() const { return destIndex; }\n \n@@ -331,7 +333,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      * Returns an Iterator for coarse-grained changes for simple string updates.\n      * Skips non-changes.\n      * @return an Iterator that merges adjacent changes.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     Iterator getCoarseChangesIterator() const {\n         return Iterator(array, length, TRUE, TRUE);\n@@ -340,7 +342,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n     /**\n      * Returns an Iterator for coarse-grained changes and non-changes for simple string updates.\n      * @return an Iterator that merges adjacent changes.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     Iterator getCoarseIterator() const {\n         return Iterator(array, length, FALSE, TRUE);\n@@ -350,7 +352,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      * Returns an Iterator for fine-grained changes for modifying styled text.\n      * Skips non-changes.\n      * @return an Iterator that separates adjacent changes.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     Iterator getFineChangesIterator() const {\n         return Iterator(array, length, TRUE, FALSE);\n@@ -359,12 +361,13 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n     /**\n      * Returns an Iterator for fine-grained changes and non-changes for modifying styled text.\n      * @return an Iterator that separates adjacent changes.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     Iterator getFineIterator() const {\n         return Iterator(array, length, FALSE, FALSE);\n     }\n \n+#ifndef U_HIDE_DRAFT_API\n     /**\n      * Merges the two input Edits and appends the result to this object.\n      *\n@@ -393,6 +396,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      * @draft ICU 60\n      */\n     Edits &mergeAndAppend(const Edits &ab, const Edits &bc, UErrorCode &errorCode);\n+#endif  // U_HIDE_DRAFT_API\n \n private:\n     void releaseArray() U_NOEXCEPT;\n@@ -415,8 +419,6 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n     uint16_t stackArray[STACK_CAPACITY];\n };\n \n-#endif  // U_HIDE_DRAFT_API\n-\n U_NAMESPACE_END\n \n #endif  // __EDITS_H__"
        },
        {
            "sha": "751d1faf40454fa3475bcff9748f561f39ad7205",
            "filename": "deps/icu-small/source/common/unicode/filteredbrk.h",
            "status": "modified",
            "additions": 1,
            "deletions": 5,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Ffilteredbrk.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Ffilteredbrk.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Ffilteredbrk.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -64,9 +64,7 @@ class U_COMMON_API FilteredBreakIteratorBuilder : public UObject {\n    * @deprecated ICU 60 use createEmptyInstance instead\n    * @see createEmptyInstance()\n    */\n-  static inline FilteredBreakIteratorBuilder *createInstance(UErrorCode &status) {\n-    return createEmptyInstance(status);\n-  }\n+  static FilteredBreakIteratorBuilder *createInstance(UErrorCode &status);\n #endif  /* U_HIDE_DEPRECATED_API */\n \n #ifndef U_HIDE_DRAFT_API\n@@ -105,7 +103,6 @@ class U_COMMON_API FilteredBreakIteratorBuilder : public UObject {\n    */\n   virtual UBool unsuppressBreakAfter(const UnicodeString& string, UErrorCode& status) = 0;\n \n-#ifndef U_HIDE_DEPRECATED_API\n   /**\n    * This function has been deprecated in favor of wrapIteratorWithFilter()\n    * The behavior is identical.\n@@ -116,7 +113,6 @@ class U_COMMON_API FilteredBreakIteratorBuilder : public UObject {\n    * @see wrapBreakIteratorWithFilter()\n    */\n   virtual BreakIterator *build(BreakIterator* adoptBreakIterator, UErrorCode& status) = 0;\n-#endif  /* U_HIDE_DEPRECATED_API */\n \n #ifndef U_HIDE_DRAFT_API\n   /**"
        },
        {
            "sha": "c84774e07fd3950678126474550f8ee826c6e1d5",
            "filename": "deps/icu-small/source/common/unicode/locid.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Flocid.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Flocid.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Flocid.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -353,7 +353,7 @@ class U_COMMON_API Locale : public UObject {\n      * the default locale ID of the runtime environment.\n      *\n      * @param newLocale Locale to set to.  If NULL, set to the value obtained\n-     *                  from the runtime environement.\n+     *                  from the runtime environment.\n      * @param success The error code.\n      * @system\n      * @stable ICU 2.0\n@@ -629,7 +629,7 @@ class U_COMMON_API Locale : public UObject {\n \n     /**\n      * Fills in \"name\" with the name of this locale in a format suitable for user display\n-     * in the locale specfied by \"displayLocale\".  This function uses getDisplayLanguage(),\n+     * in the locale specified by \"displayLocale\".  This function uses getDisplayLanguage(),\n      * getDisplayCountry(), and getDisplayVariant() to do its work, and outputs the display\n      * name in the format \"language (country[,variant])\".  For example, if displayLocale is\n      * fr_FR, then en_US's display name would be \"Anglais (&Eacute;tats-Unis)\", and no_NO_NY's"
        },
        {
            "sha": "c05487601cb0d16967725c88084437e5d05b1889",
            "filename": "deps/icu-small/source/common/unicode/parseerr.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fparseerr.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fparseerr.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fparseerr.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -58,9 +58,9 @@ enum { U_PARSE_CONTEXT_LEN = 16 };\n typedef struct UParseError {\n \n     /**\n-     * The line on which the error occured.  If the parser uses this\n+     * The line on which the error occurred.  If the parser uses this\n      * field, it sets it to the line number of the source text line on\n-     * which the error appears, which will be be a value >= 1.  If the\n+     * which the error appears, which will be a value >= 1.  If the\n      * parse does not support line numbers, the value will be <= 0.\n      * @stable ICU 2.0\n      */"
        },
        {
            "sha": "a3f8d32f89d2cddc2404b93b3c2412a3ac836bd4",
            "filename": "deps/icu-small/source/common/unicode/platform.h",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fplatform.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fplatform.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fplatform.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -482,9 +482,9 @@\n     /* Otherwise use the predefined value. */\n #elif !defined(__cplusplus)\n #   define U_CPLUSPLUS_VERSION 0\n-#elif __cplusplus >= 201402L\n+#elif __cplusplus >= 201402L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)\n #   define U_CPLUSPLUS_VERSION 14\n-#elif __cplusplus >= 201103L\n+#elif __cplusplus >= 201103L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201103L)\n #   define U_CPLUSPLUS_VERSION 11\n #else\n     // C++98 or C++03\n@@ -631,7 +631,7 @@ namespace std {\n  */\n #ifdef U_CHARSET_IS_UTF8\n     /* Use the predefined value. */\n-#elif U_PLATFORM == U_PF_ANDROID || U_PLATFORM_IS_DARWIN_BASED\n+#elif U_PLATFORM_IS_LINUX_BASED || U_PLATFORM_IS_DARWIN_BASED\n #   define U_CHARSET_IS_UTF8 1\n #else\n #   define U_CHARSET_IS_UTF8 0\n@@ -749,8 +749,10 @@ namespace std {\n #else\n     /*\n      * Notes:\n-     * Visual Studio 10 (_MSC_VER>=1600) defines char16_t but\n-     * does not support u\"abc\" string literals.\n+     * Visual Studio 2010 (_MSC_VER==1600) defines char16_t as a typedef\n+     * and does not support u\"abc\" string literals.\n+     * Visual Studio 2015 (_MSC_VER>=1900) and above adds support for\n+     * both char16_t and u\"abc\" string literals.\n      * gcc 4.4 defines the __CHAR16_TYPE__ macro to a usable type but\n      * does not support u\"abc\" string literals.\n      * C++11 and C11 require support for UTF-16 literals"
        },
        {
            "sha": "14bb99ccc545b24821aa9a4250a9c25126efd0ed",
            "filename": "deps/icu-small/source/common/unicode/putil.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fputil.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fputil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fputil.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -38,7 +38,7 @@\n \n /**\n  * Platform utilities isolates the platform dependencies of the\n- * libarary.  For each platform which this code is ported to, these\n+ * library.  For each platform which this code is ported to, these\n  * functions may have to be re-implemented.\n  */\n \n@@ -53,7 +53,7 @@\n  * The data directory is determined as follows:\n  *    If u_setDataDirectory() has been called, that is it, otherwise\n  *    if the ICU_DATA environment variable is set, use that, otherwise\n- *    If a data directory was specifed at ICU build time\n+ *    If a data directory was specified at ICU build time\n  *      <code>\n  * \\code\n  *        #define ICU_DATA_DIR \"path\"\n@@ -93,7 +93,7 @@ U_STABLE void U_EXPORT2 u_setDataDirectory(const char *directory);\n #ifndef U_HIDE_INTERNAL_API\n /**\n   * Return the time zone files override directory, or an empty string if\n-  * no directory was specified. Certain time zone resources will be preferrentially\n+  * no directory was specified. Certain time zone resources will be preferentially\n   * loaded from individual files in this directory.\n   *\n   * @return the time zone data override directory."
        },
        {
            "sha": "0c41d69d235ccb216cd44c909b16e2d85c0fd355",
            "filename": "deps/icu-small/source/common/unicode/rbbi.h",
            "status": "modified",
            "additions": 56,
            "deletions": 68,
            "changes": 124,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Frbbi.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Frbbi.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Frbbi.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -29,7 +29,6 @@\n #include \"unicode/udata.h\"\n #include \"unicode/parseerr.h\"\n #include \"unicode/schriter.h\"\n-#include \"unicode/uchriter.h\"\n \n U_NAMESPACE_BEGIN\n \n@@ -58,34 +57,18 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      * The UText through which this BreakIterator accesses the text\n      * @internal\n      */\n-    UText  *fText;\n-\n-    /**\n-     *   A character iterator that refers to the same text as the UText, above.\n-     *   Only included for compatibility with old API, which was based on CharacterIterators.\n-     *   Value may be adopted from outside, or one of fSCharIter or fDCharIter, below.\n-     */\n-    CharacterIterator  *fCharIter;\n-\n-    /**\n-     *   When the input text is provided by a UnicodeString, this will point to\n-     *    a characterIterator that wraps that data.  Needed only for the\n-     *    implementation of getText(), a backwards compatibility issue.\n-     */\n-    StringCharacterIterator *fSCharIter;\n-\n-    /**\n-     *  When the input text is provided by a UText, this\n-     *    dummy CharacterIterator over an empty string will\n-     *    be returned from getText()\n-     */\n-    UCharCharacterIterator *fDCharIter;\n+    UText  fText;\n \n+#ifndef U_HIDE_INTERNAL_API\n+public:\n+#endif /* U_HIDE_INTERNAL_API */\n     /**\n-     * The rule data for this BreakIterator instance\n+     * The rule data for this BreakIterator instance.\n+     * Not for general use; Public only for testing purposes.\n      * @internal\n      */\n     RBBIDataWrapper    *fData;\n+private:\n \n     /**\n      *  The iteration state - current position, rule status for the current position,\n@@ -105,24 +88,11 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n       */\n     int32_t         fRuleStatusIndex;\n \n-    /**\n-      * True when iteration has run off the end, and iterator functions should return UBRK_DONE.\n-      */\n-    UBool           fDone;\n-\n     /**\n      *   Cache of previously determined boundary positions.\n      */\n-  public:    // TODO: debug, return to private.\n     class BreakCache;\n     BreakCache         *fBreakCache;\n-  private:\n-    /**\n-     * Counter for the number of characters encountered with the \"dictionary\"\n-     *   flag set.\n-     * @internal\n-     */\n-    uint32_t            fDictionaryCharCount;\n \n     /**\n      *  Cache of boundary positions within a region of text that has been\n@@ -150,11 +120,30 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n     UnhandledEngine     *fUnhandledBreakEngine;\n \n     /**\n-     *\n-     * The type of the break iterator, or -1 if it has not been set.\n+     * Counter for the number of characters encountered with the \"dictionary\"\n+     *   flag set.\n      * @internal\n      */\n-    int32_t             fBreakType;\n+    uint32_t            fDictionaryCharCount;\n+\n+    /**\n+     *   A character iterator that refers to the same text as the UText, above.\n+     *   Only included for compatibility with old API, which was based on CharacterIterators.\n+     *   Value may be adopted from outside, or one of fSCharIter or fDCharIter, below.\n+     */\n+    CharacterIterator  *fCharIter;\n+\n+    /**\n+     *   When the input text is provided by a UnicodeString, this will point to\n+     *    a characterIterator that wraps that data.  Needed only for the\n+     *    implementation of getText(), a backwards compatibility issue.\n+     */\n+    StringCharacterIterator fSCharIter;\n+\n+    /**\n+      * True when iteration has run off the end, and iterator functions should return UBRK_DONE.\n+      */\n+    UBool           fDone;\n \n     //=======================================================================\n     // constructors\n@@ -206,17 +195,17 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n                              UErrorCode            &status);\n \n     /**\n-     * Contruct a RuleBasedBreakIterator from a set of precompiled binary rules.\n+     * Construct a RuleBasedBreakIterator from a set of precompiled binary rules.\n      * Binary rules are obtained from RulesBasedBreakIterator::getBinaryRules().\n      * Construction of a break iterator in this way is substantially faster than\n-     * constuction from source rules.\n+     * construction from source rules.\n      *\n      * Ownership of the storage containing the compiled rules remains with the\n      * caller of this function.  The compiled rules must not be  modified or\n      * deleted during the life of the break iterator.\n      *\n      * The compiled rules are not compatible across different major versions of ICU.\n-     * The compiled rules are comaptible only between machines with the same\n+     * The compiled rules are compatible only between machines with the same\n      * byte ordering (little or big endian) and the same base character set family\n      * (ASCII or EBCDIC).\n      *\n@@ -285,7 +274,7 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      * behavior, and iterating over the same text, as this one.\n      * Differs from the copy constructor in that it is polymorphic, and\n      * will correctly clone (copy) a derived class.\n-     * clone() is thread safe.  Multiple threads may simultaeneously\n+     * clone() is thread safe.  Multiple threads may simultaneously\n      * clone the same source break iterator.\n      * @return a newly-constructed RuleBasedBreakIterator\n      * @stable ICU 2.0\n@@ -450,7 +439,7 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n     virtual int32_t preceding(int32_t offset);\n \n     /**\n-     * Returns true if the specfied position is a boundary position.  As a side\n+     * Returns true if the specified position is a boundary position.  As a side\n      * effect, leaves the iterator pointing to the first boundary position at\n      * or after \"offset\".\n      * @param offset the offset to check.\n@@ -471,8 +460,8 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n \n \n     /**\n-     * Return the status tag from the break rule that determined the most recently\n-     * returned break position.  For break rules that do not specify a\n+     * Return the status tag from the break rule that determined the boundary at\n+     * the current iteration position.  For break rules that do not specify a\n      * status, a default value of 0 is returned.  If more than one break rule\n      * would cause a boundary to be located at some position in the text,\n      * the numerically largest of the applicable status values is returned.\n@@ -489,25 +478,23 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      * position from <code>next()</code>, <code>previous()</code>, or\n      * any other break iterator functions that returns a boundary position.\n      * <p>\n+     * Note that <code>getRuleStatus()</code> returns the value corresponding to\n+     * <code>current()</code> index even after <code>next()</code> has returned DONE.\n+     * <p>\n      * When creating custom break rules, one is free to define whatever\n      * status values may be convenient for the application.\n      * <p>\n-     * Note: this function is not thread safe.  It should not have been\n-     *       declared const, and the const remains only for compatibility\n-     *       reasons.  (The function is logically const, but not bit-wise const).\n-     *   TODO: check this. Probably thread safe now.\n-     * <p>\n-     * @return the status from the break rule that determined the most recently\n-     * returned break position.\n+     * @return the status from the break rule that determined the boundary\n+     * at the current iteration position.\n      *\n      * @see UWordBreak\n      * @stable ICU 2.2\n      */\n     virtual int32_t getRuleStatus() const;\n \n    /**\n-    * Get the status (tag) values from the break rule(s) that determined the most\n-    * recently returned break position.\n+    * Get the status (tag) values from the break rule(s) that determined the boundary\n+    * at the current iteration position.\n     * <p>\n     * The returned status value(s) are stored into an array provided by the caller.\n     * The values are stored in sorted (ascending) order.\n@@ -518,10 +505,10 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n     * @param fillInVec an array to be filled in with the status values.\n     * @param capacity  the length of the supplied vector.  A length of zero causes\n     *                  the function to return the number of status values, in the\n-    *                  normal way, without attemtping to store any values.\n+    *                  normal way, without attempting to store any values.\n     * @param status    receives error codes.\n-    * @return          The number of rule status values from rules that determined\n-    *                  the most recent boundary returned by the break iterator.\n+    * @return          The number of rule status values from the rules that determined\n+    *                  the boundary at the current iteration position.\n     *                  In the event of a U_BUFFER_OVERFLOW_ERROR, the return value\n     *                  is the total number of status values that were available,\n     *                  not the reduced number that were actually returned.\n@@ -561,7 +548,7 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      *\n      * Create a clone (copy) of this break iterator in memory provided\n      *  by the caller.  The idea is to increase performance by avoiding\n-     *  a storage allocation.  Use of this functoin is NOT RECOMMENDED.\n+     *  a storage allocation.  Use of this function is NOT RECOMMENDED.\n      *  Performance gains are minimal, and correct buffer management is\n      *  tricky.  Use clone() instead.\n      *\n@@ -574,7 +561,7 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      *                     storage for the cloned object.\n      *\n      * @param status       Error status.  U_SAFECLONE_ALLOCATED_WARNING will be\n-     *                     returned if the the provided buffer was too small, and\n+     *                     returned if the provided buffer was too small, and\n      *                     the clone was therefore put on the heap.\n      *\n      * @return  Pointer to the clone object.  This may differ from the stackBuffer\n@@ -597,7 +584,7 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      * The binary data can only be used with the same version of ICU\n      *  and on the same platform type (processor endian-ness)\n      *\n-     * @param length Returns the length of the binary data.  (Out paramter.)\n+     * @param length Returns the length of the binary data.  (Out parameter.)\n      *\n      * @return   A pointer to the binary (compiled) rule data.  The storage\n      *           belongs to the RulesBasedBreakIterator object, not the\n@@ -645,12 +632,6 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      */\n     void reset(void);\n \n-    /**\n-      * Set the type of the break iterator.\n-      * @internal\n-      */\n-    void setBreakType(int32_t type);\n-\n     /**\n       * Common initialization function, used by constructors and bufferClone.\n       * @internal\n@@ -697,6 +678,13 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      *   @internal\n      */\n      void dumpCache();\n+\n+    /**\n+     * Debugging function only.\n+     * @internal\n+     */\n+    void dumpTables();\n+\n #endif  /* U_HIDE_INTERNAL_API */\n };\n "
        },
        {
            "sha": "ab0b60bbb28fcc84e3142c5a64035ea2c777fecf",
            "filename": "deps/icu-small/source/common/unicode/resbund.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fresbund.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fresbund.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fresbund.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -132,7 +132,7 @@ class U_COMMON_API ResourceBundle : public UObject {\n     ResourceBundle(UErrorCode &err);\n \n     /**\n-     * Standard constructor, onstructs a resource bundle for the locale-specific\n+     * Standard constructor, constructs a resource bundle for the locale-specific\n      * bundle in the specified package.\n      *\n      * @param packageName   The packageName and locale together point to an ICU udata object,"
        },
        {
            "sha": "1a12769e8df106618e3161d61b4a15573a7551d2",
            "filename": "deps/icu-small/source/common/unicode/schriter.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fschriter.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fschriter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fschriter.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -69,7 +69,7 @@ class U_COMMON_API StringCharacterIterator : public UCharCharacterIterator {\n    * Create an iterator over the UnicodeString referred to by \"textStr\".\n    * The UnicodeString object is copied.\n    * The iteration range begins with the code unit specified by\n-   * \"textBegin\" and ends with the code unit BEFORE the code unit specfied\n+   * \"textBegin\" and ends with the code unit BEFORE the code unit specified\n    * by \"textEnd\".  The starting position is specified by \"textPos\".  If\n    * \"textBegin\" and \"textEnd\" don't form a valid range on \"text\" (i.e.,\n    * textBegin >= textEnd or either is negative or greater than text.size()),"
        },
        {
            "sha": "254a5bf9ef469f161dd2c18e6ac0a51dc0eee407",
            "filename": "deps/icu-small/source/common/unicode/ubidi.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubidi.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubidi.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubidi.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -692,7 +692,7 @@ typedef enum UBiDiReorderingMode {\n       * @stable ICU 3.6 */\n     UBIDI_REORDER_DEFAULT = 0,\n     /** Logical to Visual algorithm which handles numbers in a way which\n-      * mimicks the behavior of Windows XP.\n+      * mimics the behavior of Windows XP.\n       * @stable ICU 3.6 */\n     UBIDI_REORDER_NUMBERS_SPECIAL,\n     /** Logical to Visual algorithm grouping numbers with adjacent R characters\n@@ -1142,7 +1142,7 @@ ubidi_setContext(UBiDi *pBiDi,\n \n /**\n  * Perform the Unicode Bidi algorithm. It is defined in the\n- * <a href=\"http://www.unicode.org/unicode/reports/tr9/\">Unicode Standard Anned #9</a>,\n+ * <a href=\"http://www.unicode.org/unicode/reports/tr9/\">Unicode Standard Annex #9</a>,\n  * version 13,\n  * also described in The Unicode Standard, Version 4.0 .<p>\n  *"
        },
        {
            "sha": "73c1553b24395784a0249eb13fd867b6eaba88e5",
            "filename": "deps/icu-small/source/common/unicode/ubrk.h",
            "status": "modified",
            "additions": 6,
            "deletions": 12,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubrk.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubrk.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubrk.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -268,7 +268,6 @@ ubrk_openRules(const UChar     *rules,\n                UParseError     *parseErr,\n                UErrorCode      *status);\n \n-#ifndef U_HIDE_DRAFT_API\n /**\n  * Open a new UBreakIterator for locating text boundaries using precompiled binary rules.\n  * Opening a UBreakIterator this way is substantially faster than using ubrk_openRules.\n@@ -287,15 +286,13 @@ ubrk_openRules(const UChar     *rules,\n  * @param status      Pointer to UErrorCode to receive any errors.\n  * @return            UBreakIterator for the specified rules.\n  * @see ubrk_getBinaryRules\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n-U_DRAFT UBreakIterator* U_EXPORT2\n+U_STABLE UBreakIterator* U_EXPORT2\n ubrk_openBinaryRules(const uint8_t *binaryRules, int32_t rulesLength,\n                      const UChar *  text, int32_t textLength,\n                      UErrorCode *   status);\n \n-#endif  /* U_HIDE_DRAFT_API */\n-\n /**\n  * Thread safe cloning operation\n  * @param bi iterator to be cloned\n@@ -510,7 +507,7 @@ ubrk_countAvailable(void);\n \n \n /**\n-* Returns true if the specfied position is a boundary position.  As a side\n+* Returns true if the specified position is a boundary position.  As a side\n * effect, leaves the iterator pointing to the first boundary position at\n * or after \"offset\".\n * @param bi The break iterator to use.\n@@ -544,7 +541,7 @@ ubrk_getRuleStatus(UBreakIterator *bi);\n  * @param fillInVec an array to be filled in with the status values.\n  * @param capacity  the length of the supplied vector.  A length of zero causes\n  *                  the function to return the number of status values, in the\n- *                  normal way, without attemtping to store any values.\n+ *                  normal way, without attempting to store any values.\n  * @param status    receives error codes.\n  * @return          The number of rule status values from rules that determined\n  *                  the most recent boundary returned by the break iterator.\n@@ -596,7 +593,6 @@ ubrk_refreshUText(UBreakIterator *bi,\n                        UErrorCode     *status);\n \n \n-#ifndef U_HIDE_DRAFT_API\n /**\n  * Get a compiled binary version of the rules specifying the behavior of a UBreakIterator.\n  * The binary rules may be used with ubrk_openBinaryRules to open a new UBreakIterator\n@@ -620,15 +616,13 @@ ubrk_refreshUText(UBreakIterator *bi,\n  *                      otherwise 0. If not preflighting and this is larger than\n  *                      rulesCapacity, *status will be set to an error.\n  * @see ubrk_openBinaryRules\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n-U_DRAFT int32_t U_EXPORT2\n+U_STABLE int32_t U_EXPORT2\n ubrk_getBinaryRules(UBreakIterator *bi,\n                     uint8_t *       binaryRules, int32_t rulesCapacity,\n                     UErrorCode *    status);\n \n-#endif  /* U_HIDE_DRAFT_API */\n-\n #endif /* #if !UCONFIG_NO_BREAK_ITERATION */\n \n #endif"
        },
        {
            "sha": "4b72ecfc26bf9af0453f15e1f4d77d949591b142",
            "filename": "deps/icu-small/source/common/unicode/uchar.h",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuchar.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuchar.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuchar.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -112,11 +112,11 @@ U_CDECL_BEGIN\n  * Comparison:\n  * - u_isUWhiteSpace=UCHAR_WHITE_SPACE: Unicode White_Space property;\n  *       most of general categories \"Z\" (separators) + most whitespace ISO controls\n- *       (including no-break spaces, but excluding IS1..IS4 and ZWSP)\n+ *       (including no-break spaces, but excluding IS1..IS4)\n  * - u_isWhitespace: Java isWhitespace; Z + whitespace ISO controls but excluding no-break spaces\n  * - u_isJavaSpaceChar: Java isSpaceChar; just Z (including no-break spaces)\n  * - u_isspace: Z + whitespace ISO controls (including no-break spaces)\n- * - u_isblank: \"horizontal spaces\" = TAB + Zs - ZWSP\n+ * - u_isblank: \"horizontal spaces\" = TAB + Zs\n  */\n \n /**\n@@ -2702,8 +2702,7 @@ u_isgraph(UChar32 c);\n  *\n  * same as\n  *\n- * TRUE for U+0009 (TAB) and characters with general category \"Zs\" (space separators)\n- * except Zero Width Space (ZWSP, U+200B).\n+ * TRUE for U+0009 (TAB) and characters with general category \"Zs\" (space separators).\n  *\n  * Note: There are several ICU whitespace functions; please see the uchar.h\n  * file documentation for a detailed comparison."
        },
        {
            "sha": "ab0cd6da6ba7801cc9b248aed34fd4d537c13d72",
            "filename": "deps/icu-small/source/common/unicode/uclean.h",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuclean.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuclean.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuclean.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -70,7 +70,7 @@ u_init(UErrorCode *status);\n  * This has the effect of restoring ICU to its initial condition, before\n  * any of these override functions were installed.  Refer to\n  * u_setMemoryFunctions(), u_setMutexFunctions and\n- * utrace_setFunctions().  If ICU is to be reinitialized after after\n+ * utrace_setFunctions().  If ICU is to be reinitialized after\n  * calling u_cleanup(), these runtime override functions will need to\n  * be set up again if they are still required.\n  * <p>\n@@ -104,7 +104,7 @@ u_cleanup(void);\n U_CDECL_BEGIN\n /**\n   *  Pointer type for a user supplied memory allocation function.\n-  *  @param context user supplied value, obtained from from u_setMemoryFunctions().\n+  *  @param context user supplied value, obtained from u_setMemoryFunctions().\n   *  @param size    The number of bytes to be allocated\n   *  @return        Pointer to the newly allocated memory, or NULL if the allocation failed.\n   *  @stable ICU 2.8\n@@ -113,7 +113,7 @@ U_CDECL_BEGIN\n typedef void *U_CALLCONV UMemAllocFn(const void *context, size_t size);\n /**\n   *  Pointer type for a user supplied memory re-allocation function.\n-  *  @param context user supplied value, obtained from from u_setMemoryFunctions().\n+  *  @param context user supplied value, obtained from u_setMemoryFunctions().\n   *  @param size    The number of bytes to be allocated\n   *  @return        Pointer to the newly allocated memory, or NULL if the allocation failed.\n   *  @stable ICU 2.8\n@@ -123,7 +123,7 @@ typedef void *U_CALLCONV UMemReallocFn(const void *context, void *mem, size_t si\n /**\n   *  Pointer type for a user supplied memory free  function.  Behavior should be\n   *  similar the standard C library free().\n-  *  @param context user supplied value, obtained from from u_setMemoryFunctions().\n+  *  @param context user supplied value, obtained from u_setMemoryFunctions().\n   *  @param mem     Pointer to the memory block to be resized\n   *  @param size    The new size for the block\n   *  @return        Pointer to the resized memory block, or NULL if the resizing failed.\n@@ -179,8 +179,8 @@ U_CDECL_BEGIN\n   *  The user-supplied function will be called by ICU whenever ICU needs to create a\n   *  new mutex.  The function implementation should create a mutex, and store a pointer\n   *  to something that uniquely identifies the mutex into the UMTX that is supplied\n-  *  as a paramter.\n-  *  @param context user supplied value, obtained from from u_setMutexFunctions().\n+  *  as a parameter.\n+  *  @param context user supplied value, obtained from u_setMutexFunctions().\n   *  @param mutex   Receives a pointer that identifies the new mutex.\n   *                 The mutex init function must set the UMTX to a non-null value.\n   *                 Subsequent calls by ICU to lock, unlock, or destroy a mutex will\n@@ -197,7 +197,7 @@ typedef void U_CALLCONV UMtxInitFn (const void *context, UMTX  *mutex, UErrorCod\n   *  Function Pointer type for a user supplied mutex functions.\n   *  One of the  user-supplied functions with this signature will be called by ICU\n   *  whenever ICU needs to lock, unlock, or destroy a mutex.\n-  *  @param context user supplied value, obtained from from u_setMutexFunctions().\n+  *  @param context user supplied value, obtained from u_setMutexFunctions().\n   *  @param mutex   specify the mutex on which to operate.\n   *  @deprecated ICU 52. This function is no longer supported.\n   *  @system\n@@ -229,7 +229,7 @@ u_setMutexFunctions(const void *context, UMtxInitFn *init, UMtxFn *destroy, UMtx\n \n /**\n   *  Pointer type for a user supplied atomic increment or decrement function.\n-  *  @param context user supplied value, obtained from from u_setAtomicIncDecFunctions().\n+  *  @param context user supplied value, obtained from u_setAtomicIncDecFunctions().\n   *  @param p   Pointer to a 32 bit int to be incremented or decremented\n   *  @return    The value of the variable after the inc or dec operation.\n   *  @deprecated ICU 52. This function is no longer supported."
        },
        {
            "sha": "53b4c6f0733aca65f5c6e121d01a8021c63b9038",
            "filename": "deps/icu-small/source/common/unicode/ucnv.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucnv.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucnv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucnv.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -207,7 +207,7 @@ typedef void (U_EXPORT2 *UConverterToUCallback) (\n \n /**\n  * Function pointer for error callback in the unicode to codepage direction.\n- * Called when an error has occured in conversion from unicode, or on open/close of the callback (see reason).\n+ * Called when an error has occurred in conversion from unicode, or on open/close of the callback (see reason).\n  * @param context Pointer to the callback's private data\n  * @param args Information about the conversion in progress\n  * @param codeUnits Points to 'length' UChars of the concerned Unicode sequence\n@@ -353,7 +353,7 @@ ucnv_compareNames(const char *name1, const char *name2);\n  *          ucnv_getAlias for a complete list that is available.\n  *          If this parameter is NULL, the default converter will be used.\n  * @param err outgoing error status <TT>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</TT>\n- * @return the created Unicode converter object, or <TT>NULL</TT> if an error occured\n+ * @return the created Unicode converter object, or <TT>NULL</TT> if an error occurred\n  * @see ucnv_openU\n  * @see ucnv_openCCSID\n  * @see ucnv_getAvailableName\n@@ -386,7 +386,7 @@ ucnv_open(const char *converterName, UErrorCode *err);\n  * @param err outgoing error status <TT>U_MEMORY_ALLOCATION_ERROR,\n  *        U_FILE_ACCESS_ERROR</TT>\n  * @return the created Unicode converter object, or <TT>NULL</TT> if an\n- *        error occured\n+ *        error occurred\n  * @see ucnv_open\n  * @see ucnv_openCCSID\n  * @see ucnv_close\n@@ -489,7 +489,7 @@ ucnv_openCCSID(int32_t codepage,\n  * @param packageName name of the package (equivalent to 'path' in udata_open() call)\n  * @param converterName name of the data item to be used, without suffix.\n  * @param err outgoing error status <TT>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</TT>\n- * @return the created Unicode converter object, or <TT>NULL</TT> if an error occured\n+ * @return the created Unicode converter object, or <TT>NULL</TT> if an error occurred\n  * @see udata_open\n  * @see ucnv_open\n  * @see ucnv_safeClone"
        },
        {
            "sha": "08c96c14407c222050dc8dc25c512bf7eb873f39",
            "filename": "deps/icu-small/source/common/unicode/ucnv_err.h",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucnv_err.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucnv_err.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucnv_err.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -119,19 +119,19 @@ typedef struct UConverter UConverter;\n #define UCNV_ESCAPE_JAVA      \"J\"\n /**\n  * FROM_U_CALLBACK_ESCAPE context option to escape the code unit according to C (\\\\uXXXX \\\\UXXXXXXXX)\n- * TO_U_CALLBACK_ESCAPE option to escape the character value accoding to C (\\\\xXXXX)\n+ * TO_U_CALLBACK_ESCAPE option to escape the character value according to C (\\\\xXXXX)\n  * @stable ICU 2.0\n  */\n #define UCNV_ESCAPE_C         \"C\"\n /**\n  * FROM_U_CALLBACK_ESCAPE context option to escape the code unit according to XML Decimal escape \\htmlonly(&amp;#DDDD;)\\endhtmlonly\n- * TO_U_CALLBACK_ESCAPE context option to escape the character value accoding to XML Decimal escape \\htmlonly(&amp;#DDDD;)\\endhtmlonly\n+ * TO_U_CALLBACK_ESCAPE context option to escape the character value according to XML Decimal escape \\htmlonly(&amp;#DDDD;)\\endhtmlonly\n  * @stable ICU 2.0\n  */\n #define UCNV_ESCAPE_XML_DEC   \"D\"\n /**\n  * FROM_U_CALLBACK_ESCAPE context option to escape the code unit according to XML Hex escape \\htmlonly(&amp;#xXXXX;)\\endhtmlonly\n- * TO_U_CALLBACK_ESCAPE context option to escape the character value accoding to XML Hex escape \\htmlonly(&amp;#xXXXX;)\\endhtmlonly\n+ * TO_U_CALLBACK_ESCAPE context option to escape the character value according to XML Hex escape \\htmlonly(&amp;#xXXXX;)\\endhtmlonly\n  * @stable ICU 2.0\n  */\n #define UCNV_ESCAPE_XML_HEX   \"X\"\n@@ -171,7 +171,7 @@ typedef enum {\n                              code points.\n                              The error code U_INVALID_CHAR_FOUND will be set. */\n     UCNV_RESET = 3,       /**< The callback is called with this reason when a\n-                             'reset' has occured. Callback should reset all\n+                             'reset' has occurred. Callback should reset all\n                              state. */\n     UCNV_CLOSE = 4,        /**< Called when the converter is closed. The\n                              callback should release any allocated memory.*/\n@@ -199,7 +199,7 @@ typedef struct {\n     const UChar *sourceLimit;   /**< Pointer to the limit (end + 1) of source buffer. @stable ICU 2.0    */\n     char *target;               /**< Pointer to the target buffer. @stable ICU 2.0    */\n     const char *targetLimit;    /**< Pointer to the limit (end + 1) of target buffer. @stable ICU 2.0     */\n-    int32_t *offsets;           /**< Pointer to the buffer that recieves the offsets. *offset = blah ; offset++;. @stable ICU 2.0  */\n+    int32_t *offsets;           /**< Pointer to the buffer that receives the offsets. *offset = blah ; offset++;. @stable ICU 2.0  */\n } UConverterFromUnicodeArgs;\n \n \n@@ -215,7 +215,7 @@ typedef struct {\n     const char *sourceLimit;    /**< Pointer to the limit (end + 1) of source buffer. @stable ICU 2.0    */\n     UChar *target;              /**< Pointer to the target buffer. @stable ICU 2.0    */\n     const UChar *targetLimit;   /**< Pointer to the limit (end + 1) of target buffer. @stable ICU 2.0     */\n-    int32_t *offsets;           /**< Pointer to the buffer that recieves the offsets. *offset = blah ; offset++;. @stable ICU 2.0  */\n+    int32_t *offsets;           /**< Pointer to the buffer that receives the offsets. *offset = blah ; offset++;. @stable ICU 2.0  */\n } UConverterToUnicodeArgs;\n \n "
        },
        {
            "sha": "adfaf0023bb7cf7fcd6b2f1c65cf7b6055d1be86",
            "filename": "deps/icu-small/source/common/unicode/ucurr.h",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucurr.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucurr.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucurr.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -103,6 +103,19 @@ typedef enum UCurrNameStyle {\n      * @stable ICU 2.6\n      */\n     UCURR_LONG_NAME\n+\n+#ifndef U_HIDE_DRAFT_API\n+    ,\n+    /**\n+     * Selector for getName() indicating the narrow currency symbol.\n+     * The narrow currency symbol is similar to the regular currency\n+     * symbol, but it always takes the shortest form: for example,\n+     * \"$\" instead of \"US$\" for USD in en-CA.\n+     *\n+     * @draft ICU 61\n+     */\n+    UCURR_NARROW_SYMBOL_NAME\n+#endif  // U_HIDE_DRAFT_API\n } UCurrNameStyle;\n \n #if !UCONFIG_NO_SERVICE"
        },
        {
            "sha": "a9dc1631b00e708c706004d7511ce24c4b5d0237",
            "filename": "deps/icu-small/source/common/unicode/umachine.h",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fumachine.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fumachine.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fumachine.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -299,6 +299,10 @@ typedef int8_t UBool;\n // for AIX, uchar.h needs to be included\n # include <uchar.h>\n # define U_CHAR16_IS_TYPEDEF 1\n+#elif defined(_MSC_VER) && (_MSC_VER < 1900)\n+// Versions of Visual Studio/MSVC below 2015 do not support char16_t as a real type,\n+// and instead use a typedef.  https://msdn.microsoft.com/library/bb531344.aspx\n+# define U_CHAR16_IS_TYPEDEF 1\n #else\n # define U_CHAR16_IS_TYPEDEF 0\n #endif\n@@ -366,7 +370,7 @@ typedef int8_t UBool;\n  * Exception: ICU 58 UChar was defined to UCHAR_TYPE if that macro was defined.\n  * The current UChar responds to UCHAR_TYPE but OldUChar does not.\n  *\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n #if U_SIZEOF_WCHAR_T==2\n     typedef wchar_t OldUChar;"
        },
        {
            "sha": "c2e0ad48bd7b2cbdc42e014f880a55fcbc28990e",
            "filename": "deps/icu-small/source/common/unicode/uniset.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funiset.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funiset.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funiset.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -1521,6 +1521,7 @@ class U_COMMON_API UnicodeSet U_FINAL : public UnicodeFilter {\n                       UnicodeString& rebuiltPat,\n                       uint32_t options,\n                       UnicodeSet& (UnicodeSet::*caseClosure)(int32_t attribute),\n+                      int32_t depth,\n                       UErrorCode& ec);\n \n     //----------------------------------------------------------------"
        },
        {
            "sha": "d0b271754b660e9bc45578ad4871d96e6f6a07fc",
            "filename": "deps/icu-small/source/common/unicode/unistr.h",
            "status": "modified",
            "additions": 9,
            "deletions": 45,
            "changes": 54,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funistr.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funistr.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funistr.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -2995,10 +2995,6 @@ class U_COMMON_API UnicodeString : public Replaceable\n    */\n   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const char16_t *text);\n \n-  /*\n-   * Do not use #ifndef U_HIDE_DRAFT_API for the following constructor,\n-   * it should always be available regardless of U_HIDE_DRAFT_API status\n-   */\n #if !U_CHAR16_IS_TYPEDEF\n   /**\n    * uint16_t * constructor.\n@@ -3008,16 +3004,12 @@ class U_COMMON_API UnicodeString : public Replaceable\n    * <code>-DUNISTR_FROM_STRING_EXPLICIT=explicit</code>\n    * on the compiler command line or similar.\n    * @param text NUL-terminated UTF-16 string\n-   * @draft ICU 59\n+   * @stable ICU 59\n    */\n   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const uint16_t *text) :\n       UnicodeString(ConstChar16Ptr(text)) {}\n #endif\n \n-  /*\n-   * Do not use #ifndef U_HIDE_DRAFT_API for the following constructor,\n-   * it should always be available regardless of U_HIDE_DRAFT_API status\n-   */\n #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)\n   /**\n    * wchar_t * constructor.\n@@ -3028,16 +3020,12 @@ class U_COMMON_API UnicodeString : public Replaceable\n    * <code>-DUNISTR_FROM_STRING_EXPLICIT=explicit</code>\n    * on the compiler command line or similar.\n    * @param text NUL-terminated UTF-16 string\n-   * @draft ICU 59\n+   * @stable ICU 59\n    */\n   UNISTR_FROM_STRING_EXPLICIT UnicodeString(const wchar_t *text) :\n       UnicodeString(ConstChar16Ptr(text)) {}\n #endif\n \n-  /*\n-   * Do not use #ifndef U_HIDE_DRAFT_API for the following constructor,\n-   * it should always be available regardless of U_HIDE_DRAFT_API status\n-   */\n   /**\n    * nullptr_t constructor.\n    * Effectively the same as the default constructor, makes an empty string object.\n@@ -3046,7 +3034,7 @@ class U_COMMON_API UnicodeString : public Replaceable\n    * <code>-DUNISTR_FROM_STRING_EXPLICIT=explicit</code>\n    * on the compiler command line or similar.\n    * @param text nullptr\n-   * @draft ICU 59\n+   * @stable ICU 59\n    */\n   UNISTR_FROM_STRING_EXPLICIT inline UnicodeString(const std::nullptr_t text);\n \n@@ -3060,49 +3048,37 @@ class U_COMMON_API UnicodeString : public Replaceable\n   UnicodeString(const char16_t *text,\n         int32_t textLength);\n \n-  /*\n-   * Do not use #ifndef U_HIDE_DRAFT_API for the following constructor,\n-   * it should always be available regardless of U_HIDE_DRAFT_API status\n-   */\n #if !U_CHAR16_IS_TYPEDEF\n   /**\n    * uint16_t * constructor.\n    * Delegates to UnicodeString(const char16_t *, int32_t).\n    * @param text UTF-16 string\n    * @param length string length\n-   * @draft ICU 59\n+   * @stable ICU 59\n    */\n   UnicodeString(const uint16_t *text, int32_t length) :\n       UnicodeString(ConstChar16Ptr(text), length) {}\n #endif\n \n-  /*\n-   * Do not use #ifndef U_HIDE_DRAFT_API for the following constructor,\n-   * it should always be available regardless of U_HIDE_DRAFT_API status\n-   */\n #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)\n   /**\n    * wchar_t * constructor.\n    * (Only defined if U_SIZEOF_WCHAR_T==2.)\n    * Delegates to UnicodeString(const char16_t *, int32_t).\n    * @param text NUL-terminated UTF-16 string\n    * @param length string length\n-   * @draft ICU 59\n+   * @stable ICU 59\n    */\n   UnicodeString(const wchar_t *text, int32_t length) :\n       UnicodeString(ConstChar16Ptr(text), length) {}\n #endif\n \n-  /*\n-   * Do not use #ifndef U_HIDE_DRAFT_API for the following constructor,\n-   * it should always be available regardless of U_HIDE_DRAFT_API status\n-   */\n   /**\n    * nullptr_t constructor.\n    * Effectively the same as the default constructor, makes an empty string object.\n    * @param text nullptr\n    * @param length ignored\n-   * @draft ICU 59\n+   * @stable ICU 59\n    */\n   inline UnicodeString(const std::nullptr_t text, int32_t length);\n \n@@ -3152,27 +3128,19 @@ class U_COMMON_API UnicodeString : public Replaceable\n    */\n   UnicodeString(char16_t *buffer, int32_t buffLength, int32_t buffCapacity);\n \n-  /*\n-   * Do not use #ifndef U_HIDE_DRAFT_API for the following constructor,\n-   * it should always be available regardless of U_HIDE_DRAFT_API status\n-   */\n #if !U_CHAR16_IS_TYPEDEF\n   /**\n    * Writable-aliasing uint16_t * constructor.\n    * Delegates to UnicodeString(const char16_t *, int32_t, int32_t).\n    * @param buffer writable buffer of/for UTF-16 text\n    * @param buffLength length of the current buffer contents\n    * @param buffCapacity buffer capacity\n-   * @draft ICU 59\n+   * @stable ICU 59\n    */\n   UnicodeString(uint16_t *buffer, int32_t buffLength, int32_t buffCapacity) :\n       UnicodeString(Char16Ptr(buffer), buffLength, buffCapacity) {}\n #endif\n \n-  /*\n-   * Do not use #ifndef U_HIDE_DRAFT_API for the following constructor,\n-   * it should always be available regardless of U_HIDE_DRAFT_API status\n-   */\n #if U_SIZEOF_WCHAR_T==2 || defined(U_IN_DOXYGEN)\n   /**\n    * Writable-aliasing wchar_t * constructor.\n@@ -3181,23 +3149,19 @@ class U_COMMON_API UnicodeString : public Replaceable\n    * @param buffer writable buffer of/for UTF-16 text\n    * @param buffLength length of the current buffer contents\n    * @param buffCapacity buffer capacity\n-   * @draft ICU 59\n+   * @stable ICU 59\n    */\n   UnicodeString(wchar_t *buffer, int32_t buffLength, int32_t buffCapacity) :\n       UnicodeString(Char16Ptr(buffer), buffLength, buffCapacity) {}\n #endif\n \n-  /*\n-   * Do not use #ifndef U_HIDE_DRAFT_API for the following constructor,\n-   * it should always be available regardless of U_HIDE_DRAFT_API status\n-   */\n   /**\n    * Writable-aliasing nullptr_t constructor.\n    * Effectively the same as the default constructor, makes an empty string object.\n    * @param buffer nullptr\n    * @param buffLength ignored\n    * @param buffCapacity ignored\n-   * @draft ICU 59\n+   * @stable ICU 59\n    */\n   inline UnicodeString(std::nullptr_t buffer, int32_t buffLength, int32_t buffCapacity);\n "
        },
        {
            "sha": "d8ab85091f57213c5979e67348da5443ec16156b",
            "filename": "deps/icu-small/source/common/unicode/urename.h",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Furename.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Furename.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Furename.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -107,7 +107,6 @@\n #define _UTF7Data U_ICU_ENTRY_POINT_RENAME(_UTF7Data)\n #define _UTF8Data U_ICU_ENTRY_POINT_RENAME(_UTF8Data)\n #define allowedHourFormatsCleanup U_ICU_ENTRY_POINT_RENAME(allowedHourFormatsCleanup)\n-#define checkImpl U_ICU_ENTRY_POINT_RENAME(checkImpl)\n #define cmemory_cleanup U_ICU_ENTRY_POINT_RENAME(cmemory_cleanup)\n #define dayPeriodRulesCleanup U_ICU_ENTRY_POINT_RENAME(dayPeriodRulesCleanup)\n #define deleteAllowedHourFormats U_ICU_ENTRY_POINT_RENAME(deleteAllowedHourFormats)\n@@ -446,7 +445,6 @@\n #define ubidi_getReorderingOptions U_ICU_ENTRY_POINT_RENAME(ubidi_getReorderingOptions)\n #define ubidi_getResultLength U_ICU_ENTRY_POINT_RENAME(ubidi_getResultLength)\n #define ubidi_getRuns U_ICU_ENTRY_POINT_RENAME(ubidi_getRuns)\n-#define ubidi_getSingleton U_ICU_ENTRY_POINT_RENAME(ubidi_getSingleton)\n #define ubidi_getText U_ICU_ENTRY_POINT_RENAME(ubidi_getText)\n #define ubidi_getVisualIndex U_ICU_ENTRY_POINT_RENAME(ubidi_getVisualIndex)\n #define ubidi_getVisualMap U_ICU_ENTRY_POINT_RENAME(ubidi_getVisualMap)\n@@ -551,6 +549,7 @@\n #define ucase_addStringCaseClosure U_ICU_ENTRY_POINT_RENAME(ucase_addStringCaseClosure)\n #define ucase_fold U_ICU_ENTRY_POINT_RENAME(ucase_fold)\n #define ucase_getCaseLocale U_ICU_ENTRY_POINT_RENAME(ucase_getCaseLocale)\n+#define ucase_getTrie U_ICU_ENTRY_POINT_RENAME(ucase_getTrie)\n #define ucase_getType U_ICU_ENTRY_POINT_RENAME(ucase_getType)\n #define ucase_getTypeOrIgnorable U_ICU_ENTRY_POINT_RENAME(ucase_getTypeOrIgnorable)\n #define ucase_hasBinaryProperty U_ICU_ENTRY_POINT_RENAME(ucase_hasBinaryProperty)\n@@ -862,6 +861,7 @@\n #define udatpg_getBestPatternWithOptions U_ICU_ENTRY_POINT_RENAME(udatpg_getBestPatternWithOptions)\n #define udatpg_getDateTimeFormat U_ICU_ENTRY_POINT_RENAME(udatpg_getDateTimeFormat)\n #define udatpg_getDecimal U_ICU_ENTRY_POINT_RENAME(udatpg_getDecimal)\n+#define udatpg_getFieldDisplayName U_ICU_ENTRY_POINT_RENAME(udatpg_getFieldDisplayName)\n #define udatpg_getPatternForSkeleton U_ICU_ENTRY_POINT_RENAME(udatpg_getPatternForSkeleton)\n #define udatpg_getSkeleton U_ICU_ENTRY_POINT_RENAME(udatpg_getSkeleton)\n #define udatpg_open U_ICU_ENTRY_POINT_RENAME(udatpg_open)\n@@ -1326,7 +1326,6 @@\n #define uprv_getRawUTCtime U_ICU_ENTRY_POINT_RENAME(uprv_getRawUTCtime)\n #define uprv_getStaticCurrencyName U_ICU_ENTRY_POINT_RENAME(uprv_getStaticCurrencyName)\n #define uprv_getUTCtime U_ICU_ENTRY_POINT_RENAME(uprv_getUTCtime)\n-#define uprv_haveProperties U_ICU_ENTRY_POINT_RENAME(uprv_haveProperties)\n #define uprv_int32Comparator U_ICU_ENTRY_POINT_RENAME(uprv_int32Comparator)\n #define uprv_isASCIILetter U_ICU_ENTRY_POINT_RENAME(uprv_isASCIILetter)\n #define uprv_isInfinite U_ICU_ENTRY_POINT_RENAME(uprv_isInfinite)"
        },
        {
            "sha": "af0ce76f25b1a2ff404aa32654227c733c59cdd4",
            "filename": "deps/icu-small/source/common/unicode/ures.h",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fures.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fures.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fures.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -16,7 +16,7 @@\n *   04/04/99    helena      Fixed internal header inclusion.\n *   04/15/99    Madhu       Updated Javadoc\n *   06/14/99    stephen     Removed functions taking a filename suffix.\n-*   07/20/99    stephen     Language-independent ypedef to void*\n+*   07/20/99    stephen     Language-independent typedef to void*\n *   11/09/99    weiv        Added ures_getLocale()\n *   06/24/02    weiv        Added support for resource sharing\n ******************************************************************************\n@@ -138,7 +138,7 @@ typedef enum {\n /**\n  * Opens a UResourceBundle, from which users can extract strings by using\n  * their corresponding keys.\n- * Note that the caller is responsible of calling <TT>ures_close</TT> on each succesfully\n+ * Note that the caller is responsible of calling <TT>ures_close</TT> on each successfully\n  * opened resource bundle.\n  * @param packageName   The packageName and locale together point to an ICU udata object,\n  *                      as defined by <code> udata_open( packageName, \"res\", locale, err) </code>\n@@ -301,7 +301,7 @@ ures_getVersion(const UResourceBundle* resB,\n  * you to query for the real locale of the resource. For example, if you requested\n  * \"en_US_CALIFORNIA\" and only \"en_US\" bundle exists, \"en_US\" will be returned.\n  * For subresources, the locale where this resource comes from will be returned.\n- * If fallback has occured, getLocale will reflect this.\n+ * If fallback has occurred, getLocale will reflect this.\n  *\n  * @param resourceBundle resource bundle in question\n  * @param status just for catching illegal arguments\n@@ -580,7 +580,7 @@ ures_hasNext(const UResourceBundle *resourceBundle);\n  * @param fillIn            if NULL a new UResourceBundle struct is allocated and must be closed by the caller.\n  *                          Alternatively, you can supply a struct to be filled by this function.\n  * @param status            fills in the outgoing error code. You may still get a non NULL result even if an\n- *                          error occured. Check status instead.\n+ *                          error occurred. Check status instead.\n  * @return                  a pointer to a UResourceBundle struct. If fill in param was NULL, caller must close it\n  * @stable ICU 2.0\n  */\n@@ -596,7 +596,7 @@ ures_getNextResource(UResourceBundle *resourceBundle,\n  * @param resourceBundle    a resource\n  * @param len               fill in length of the string\n  * @param key               fill in for key associated with this string. NULL if no key\n- * @param status            fills in the outgoing error code. If an error occured, we may return NULL, but don't\n+ * @param status            fills in the outgoing error code. If an error occurred, we may return NULL, but don't\n  *                          count on it. Check status instead!\n  * @return a pointer to a zero-terminated UChar array which lives in a memory mapped/DLL file.\n  * @stable ICU 2.0\n@@ -615,7 +615,7 @@ ures_getNextString(UResourceBundle *resourceBundle,\n  * @param fillIn            if NULL a new UResourceBundle struct is allocated and must be closed by the caller.\n  *                          Alternatively, you can supply a struct to be filled by this function.\n  * @param status            fills in the outgoing error code. Don't count on NULL being returned if an error has\n- *                          occured. Check status instead.\n+ *                          occurred. Check status instead.\n  * @return                  a pointer to a UResourceBundle struct. If fill in param was NULL, caller must close it\n  * @stable ICU 2.0\n  */\n@@ -631,7 +631,7 @@ ures_getByIndex(const UResourceBundle *resourceBundle,\n  * @param resourceBundle    a resource\n  * @param indexS            an index to the wanted string.\n  * @param len               fill in length of the string\n- * @param status            fills in the outgoing error code. If an error occured, we may return NULL, but don't\n+ * @param status            fills in the outgoing error code. If an error occurred, we may return NULL, but don't\n  *                          count on it. Check status instead!\n  * @return                  a pointer to a zero-terminated UChar array which lives in a memory mapped/DLL file.\n  * @stable ICU 2.0\n@@ -722,7 +722,7 @@ ures_getByKey(const UResourceBundle *resourceBundle,\n  * @param resB              a resource\n  * @param key               a key associated with the wanted string\n  * @param len               fill in length of the string\n- * @param status            fills in the outgoing error code. If an error occured, we may return NULL, but don't\n+ * @param status            fills in the outgoing error code. If an error occurred, we may return NULL, but don't\n  *                          count on it. Check status instead!\n  * @return                  a pointer to a zero-terminated UChar array which lives in a memory mapped/DLL file.\n  * @stable ICU 2.0"
        },
        {
            "sha": "0befa1cd422c20970bc94b26e0cf916cf965a15d",
            "filename": "deps/icu-small/source/common/unicode/uscript.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuscript.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuscript.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuscript.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -476,7 +476,7 @@ typedef enum UScriptCode {\n  * @param nameOrAbbrOrLocale name of the script, as given in\n  * PropertyValueAliases.txt, or ISO 15924 code or locale\n  * @param fillIn the UScriptCode buffer to fill in the script code\n- * @param capacity the capacity (size) fo UScriptCode buffer passed in.\n+ * @param capacity the capacity (size) of UScriptCode buffer passed in.\n  * @param err the error status code.\n  * @return The number of script codes filled in the buffer passed in\n  * @stable ICU 2.4"
        },
        {
            "sha": "3064e0857281c5f71fc46f833cf9e3fcbd06b881",
            "filename": "deps/icu-small/source/common/unicode/ushape.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fushape.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fushape.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fushape.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -93,7 +93,7 @@\n  *        which must not indicate a failure before the function call.\n  *\n  * @return The number of UChars written to the destination buffer.\n- *         If an error occured, then no output was written, or it may be\n+ *         If an error occurred, then no output was written, or it may be\n  *         incomplete. If <code>U_BUFFER_OVERFLOW_ERROR</code> is set, then\n  *         the return value indicates the necessary destination buffer size.\n  * @stable ICU 2.0"
        },
        {
            "sha": "7cdc6cdd18ea6b9d5a54b3e4dec184cf5919f43b",
            "filename": "deps/icu-small/source/common/unicode/usprep.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fusprep.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fusprep.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fusprep.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -33,14 +33,14 @@\n  * StringPrep prepares Unicode strings for use in network protocols.\n  * Profiles of StingPrep are set of rules and data according to with the\n  * Unicode Strings are prepared. Each profiles contains tables which describe\n- * how a code point should be treated. The tables are broadly classied into\n+ * how a code point should be treated. The tables are broadly classified into\n  * <ul>\n- *     <li> Unassinged Table: Contains code points that are unassigned\n+ *     <li> Unassigned Table: Contains code points that are unassigned\n  *          in the Unicode Version supported by StringPrep. Currently\n  *          RFC 3454 supports Unicode 3.2. </li>\n- *     <li> Prohibited Table: Contains code points that are prohibted from\n+ *     <li> Prohibited Table: Contains code points that are prohibited from\n  *          the output of the StringPrep processing function. </li>\n- *     <li> Mapping Table: Contains code ponts that are deleted from the output or case mapped. </li>\n+ *     <li> Mapping Table: Contains code points that are deleted from the output or case mapped. </li>\n  * </ul>\n  *\n  * The procedure for preparing Unicode strings:\n@@ -230,7 +230,7 @@ U_NAMESPACE_END\n \n /**\n  * Prepare the input buffer for use in applications with the given profile. This operation maps, normalizes(NFKC),\n- * checks for prohited and BiDi characters in the order defined by RFC 3454\n+ * checks for prohibited and BiDi characters in the order defined by RFC 3454\n  * depending on the options specified in the profile.\n  *\n  * @param prep          The profile to use"
        },
        {
            "sha": "cf6ec0b6b4c9d25ad491cdfde255922d002a23f4",
            "filename": "deps/icu-small/source/common/unicode/ustring.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fustring.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fustring.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fustring.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -403,7 +403,7 @@ u_strspn(const UChar *string, const UChar *matchSet);\n  * @param saveState The current pointer within the original string,\n  *              which is set by this function. The saveState\n  *              parameter should the address of a local variable of type\n- *              UChar *. (i.e. defined \"Uhar *myLocalSaveState\" and use\n+ *              UChar *. (i.e. defined \"UChar *myLocalSaveState\" and use\n  *              &myLocalSaveState for this parameter).\n  * @return A pointer to the next token found in src, or NULL\n  *         when there are no more tokens.\n@@ -884,7 +884,7 @@ u_memrchr32(const UChar *s, UChar32 c, int32_t count);\n  * Unicode String literals in C.\n  * We need one macro to declare a variable for the string\n  * and to statically preinitialize it if possible,\n- * and a second macro to dynamically intialize such a string variable if necessary.\n+ * and a second macro to dynamically initialize such a string variable if necessary.\n  *\n  * The macros are defined for maximum performance.\n  * They work only for strings that contain \"invariant characters\", i.e.,"
        },
        {
            "sha": "51d11a2e00efb45a3d9f0f0eb7ab4edbe0e06e46",
            "filename": "deps/icu-small/source/common/unicode/utext.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futext.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futext.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futext.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -655,10 +655,10 @@ utext_getPreviousNativeIndex(UText *ut);\n  * @param  ut    the UText from which to extract data.\n  * @param  nativeStart the native index of the first character to extract.\\\n  *               If the specified index is out of range,\n- *               it will be pinned to to be within 0 <= index <= textLength\n+ *               it will be pinned to be within 0 <= index <= textLength\n  * @param  nativeLimit the native string index of the position following the last\n  *               character to extract.  If the specified index is out of range,\n- *               it will be pinned to to be within 0 <= index <= textLength.\n+ *               it will be pinned to be within 0 <= index <= textLength.\n  *               nativeLimit must be >= nativeStart.\n  * @param  dest  the UChar (UTF-16) buffer into which the extracted text is placed\n  * @param  destCapacity  The size, in UChars, of the destination buffer.  May be zero\n@@ -906,7 +906,7 @@ utext_copy(UText *ut,\n   *  Caution:  freezing a UText will disable changes made via the specific\n   *   frozen UText wrapper only; it will not have any effect on the ability to\n   *   directly modify the text by bypassing the UText.  Any such backdoor modifications\n-  *   are always an error while UText access is occuring because the underlying\n+  *   are always an error while UText access is occurring because the underlying\n   *   text can get out of sync with UText's buffering.\n   *  </p>\n   *\n@@ -1452,7 +1452,7 @@ struct UText {\n     void          *pExtra;\n \n     /**\n-     * (protected) Pointer to string or text-containin object or similar.\n+     * (protected) Pointer to string or text-containing object or similar.\n      * This is the source of the text that this UText is wrapping, in a format\n      *  that is known to the text provider functions.\n      * @stable ICU 3.4"
        },
        {
            "sha": "1f076343590240e089b5b8ca0bbfe4c61120b7ef",
            "filename": "deps/icu-small/source/common/unicode/utf8.h",
            "status": "modified",
            "additions": 106,
            "deletions": 60,
            "changes": 166,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futf8.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futf8.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futf8.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -348,29 +348,7 @@ utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i);\n  * @see U8_NEXT_UNSAFE\n  * @stable ICU 2.4\n  */\n-#define U8_NEXT(s, i, length, c) { \\\n-    (c)=(uint8_t)(s)[(i)++]; \\\n-    if(!U8_IS_SINGLE(c)) { \\\n-        uint8_t __t1, __t2; \\\n-        if( /* handle U+0800..U+FFFF inline */ \\\n-                (0xe0<=(c) && (c)<0xf0) && \\\n-                (((i)+1)<(length) || (length)<0) && \\\n-                U8_IS_VALID_LEAD3_AND_T1((c), __t1=(s)[i]) && \\\n-                (__t2=(s)[(i)+1]-0x80)<=0x3f) { \\\n-            (c)=(((c)&0xf)<<12)|((__t1&0x3f)<<6)|__t2; \\\n-            (i)+=2; \\\n-        } else if( /* handle U+0080..U+07FF inline */ \\\n-                ((c)<0xe0 && (c)>=0xc2) && \\\n-                ((i)!=(length)) && \\\n-                (__t1=(s)[i]-0x80)<=0x3f) { \\\n-            (c)=(((c)&0x1f)<<6)|__t1; \\\n-            ++(i); \\\n-        } else { \\\n-            /* function call for \"complicated\" and error cases */ \\\n-            (c)=utf8_nextCharSafeBody((const uint8_t *)s, &(i), (length), c, -1); \\\n-        } \\\n-    } \\\n-}\n+#define U8_NEXT(s, i, length, c) U8_INTERNAL_NEXT_OR_SUB(s, i, length, c, U_SENTINEL)\n \n /**\n  * Get a code point from a string at a code point boundary offset,\n@@ -396,26 +374,33 @@ utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i);\n  * @see U8_NEXT\n  * @stable ICU 51\n  */\n-#define U8_NEXT_OR_FFFD(s, i, length, c) { \\\n+#define U8_NEXT_OR_FFFD(s, i, length, c) U8_INTERNAL_NEXT_OR_SUB(s, i, length, c, 0xfffd)\n+\n+/** @internal */\n+#define U8_INTERNAL_NEXT_OR_SUB(s, i, length, c, sub) { \\\n     (c)=(uint8_t)(s)[(i)++]; \\\n     if(!U8_IS_SINGLE(c)) { \\\n-        uint8_t __t1, __t2; \\\n-        if( /* handle U+0800..U+FFFF inline */ \\\n-                (0xe0<=(c) && (c)<0xf0) && \\\n-                (((i)+1)<(length) || (length)<0) && \\\n-                U8_IS_VALID_LEAD3_AND_T1((c), __t1=(s)[i]) && \\\n-                (__t2=(s)[(i)+1]-0x80)<=0x3f) { \\\n-            (c)=(((c)&0xf)<<12)|((__t1&0x3f)<<6)|__t2; \\\n-            (i)+=2; \\\n-        } else if( /* handle U+0080..U+07FF inline */ \\\n-                ((c)<0xe0 && (c)>=0xc2) && \\\n-                ((i)!=(length)) && \\\n-                (__t1=(s)[i]-0x80)<=0x3f) { \\\n-            (c)=(((c)&0x1f)<<6)|__t1; \\\n-            ++(i); \\\n+        uint8_t __t = 0; \\\n+        if((i)!=(length) && \\\n+            /* fetch/validate/assemble all but last trail byte */ \\\n+            ((c)>=0xe0 ? \\\n+                ((c)<0xf0 ?  /* U+0800..U+FFFF except surrogates */ \\\n+                    U8_LEAD3_T1_BITS[(c)&=0xf]&(1<<((__t=(s)[i])>>5)) && \\\n+                    (__t&=0x3f, 1) \\\n+                :  /* U+10000..U+10FFFF */ \\\n+                    ((c)-=0xf0)<=4 && \\\n+                    U8_LEAD4_T1_BITS[(__t=(s)[i])>>4]&(1<<(c)) && \\\n+                    ((c)=((c)<<6)|(__t&0x3f), ++(i)!=(length)) && \\\n+                    (__t=(s)[i]-0x80)<=0x3f) && \\\n+                /* valid second-to-last trail byte */ \\\n+                ((c)=((c)<<6)|__t, ++(i)!=(length)) \\\n+            :  /* U+0080..U+07FF */ \\\n+                (c)>=0xc2 && ((c)&=0x1f, 1)) && \\\n+            /* last trail byte */ \\\n+            (__t=(s)[i]-0x80)<=0x3f && \\\n+            ((c)=((c)<<6)|__t, ++(i), 1)) { \\\n         } else { \\\n-            /* function call for \"complicated\" and error cases */ \\\n-            (c)=utf8_nextCharSafeBody((const uint8_t *)s, &(i), (length), c, -3); \\\n+            (c)=(sub);  /* ill-formed*/ \\\n         } \\\n     } \\\n }\n@@ -434,21 +419,22 @@ utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i);\n  * @stable ICU 2.4\n  */\n #define U8_APPEND_UNSAFE(s, i, c) { \\\n-    if((uint32_t)(c)<=0x7f) { \\\n-        (s)[(i)++]=(uint8_t)(c); \\\n+    uint32_t __uc=(c); \\\n+    if(__uc<=0x7f) { \\\n+        (s)[(i)++]=(uint8_t)__uc; \\\n     } else { \\\n-        if((uint32_t)(c)<=0x7ff) { \\\n-            (s)[(i)++]=(uint8_t)(((c)>>6)|0xc0); \\\n+        if(__uc<=0x7ff) { \\\n+            (s)[(i)++]=(uint8_t)((__uc>>6)|0xc0); \\\n         } else { \\\n-            if((uint32_t)(c)<=0xffff) { \\\n-                (s)[(i)++]=(uint8_t)(((c)>>12)|0xe0); \\\n+            if(__uc<=0xffff) { \\\n+                (s)[(i)++]=(uint8_t)((__uc>>12)|0xe0); \\\n             } else { \\\n-                (s)[(i)++]=(uint8_t)(((c)>>18)|0xf0); \\\n-                (s)[(i)++]=(uint8_t)((((c)>>12)&0x3f)|0x80); \\\n+                (s)[(i)++]=(uint8_t)((__uc>>18)|0xf0); \\\n+                (s)[(i)++]=(uint8_t)(((__uc>>12)&0x3f)|0x80); \\\n             } \\\n-            (s)[(i)++]=(uint8_t)((((c)>>6)&0x3f)|0x80); \\\n+            (s)[(i)++]=(uint8_t)(((__uc>>6)&0x3f)|0x80); \\\n         } \\\n-        (s)[(i)++]=(uint8_t)(((c)&0x3f)|0x80); \\\n+        (s)[(i)++]=(uint8_t)((__uc&0x3f)|0x80); \\\n     } \\\n }\n \n@@ -470,17 +456,23 @@ utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i);\n  * @stable ICU 2.4\n  */\n #define U8_APPEND(s, i, capacity, c, isError) { \\\n-    if((uint32_t)(c)<=0x7f) { \\\n-        (s)[(i)++]=(uint8_t)(c); \\\n-    } else if((uint32_t)(c)<=0x7ff && (i)+1<(capacity)) { \\\n-        (s)[(i)++]=(uint8_t)(((c)>>6)|0xc0); \\\n-        (s)[(i)++]=(uint8_t)(((c)&0x3f)|0x80); \\\n-    } else if((uint32_t)(c)<=0xd7ff && (i)+2<(capacity)) { \\\n-        (s)[(i)++]=(uint8_t)(((c)>>12)|0xe0); \\\n-        (s)[(i)++]=(uint8_t)((((c)>>6)&0x3f)|0x80); \\\n-        (s)[(i)++]=(uint8_t)(((c)&0x3f)|0x80); \\\n+    uint32_t __uc=(c); \\\n+    if(__uc<=0x7f) { \\\n+        (s)[(i)++]=(uint8_t)__uc; \\\n+    } else if(__uc<=0x7ff && (i)+1<(capacity)) { \\\n+        (s)[(i)++]=(uint8_t)((__uc>>6)|0xc0); \\\n+        (s)[(i)++]=(uint8_t)((__uc&0x3f)|0x80); \\\n+    } else if((__uc<=0xd7ff || (0xe000<=__uc && __uc<=0xffff)) && (i)+2<(capacity)) { \\\n+        (s)[(i)++]=(uint8_t)((__uc>>12)|0xe0); \\\n+        (s)[(i)++]=(uint8_t)(((__uc>>6)&0x3f)|0x80); \\\n+        (s)[(i)++]=(uint8_t)((__uc&0x3f)|0x80); \\\n+    } else if(0xffff<__uc && __uc<=0x10ffff && (i)+3<(capacity)) { \\\n+        (s)[(i)++]=(uint8_t)((__uc>>18)|0xf0); \\\n+        (s)[(i)++]=(uint8_t)(((__uc>>12)&0x3f)|0x80); \\\n+        (s)[(i)++]=(uint8_t)(((__uc>>6)&0x3f)|0x80); \\\n+        (s)[(i)++]=(uint8_t)((__uc&0x3f)|0x80); \\\n     } else { \\\n-        (i)=utf8_appendCharSafeBody(s, (i), (capacity), c, &(isError)); \\\n+        (isError)=TRUE; \\\n     } \\\n }\n \n@@ -600,12 +592,15 @@ utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i);\n  * If the offset points to a UTF-8 trail byte,\n  * then the offset is moved backward to the corresponding lead byte.\n  * Otherwise, it is not modified.\n+ *\n  * \"Safe\" macro, checks for illegal sequences and for string boundaries.\n+ * Unlike U8_TRUNCATE_IF_INCOMPLETE(), this macro always reads s[i].\n  *\n  * @param s const uint8_t * string\n  * @param start int32_t starting string offset (usually 0)\n  * @param i int32_t string offset, must be start<=i\n  * @see U8_SET_CP_START_UNSAFE\n+ * @see U8_TRUNCATE_IF_INCOMPLETE\n  * @stable ICU 2.4\n  */\n #define U8_SET_CP_START(s, start, i) { \\\n@@ -614,6 +609,57 @@ utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i);\n     } \\\n }\n \n+#ifndef U_HIDE_DRAFT_API\n+/**\n+ * If the string ends with a UTF-8 byte sequence that is valid so far\n+ * but incomplete, then reduce the length of the string to end before\n+ * the lead byte of that incomplete sequence.\n+ * For example, if the string ends with E1 80, the length is reduced by 2.\n+ *\n+ * In all other cases (the string ends with a complete sequence, or it is not\n+ * possible for any further trail byte to extend the trailing sequence)\n+ * the length remains unchanged.\n+ *\n+ * Useful for processing text split across multiple buffers\n+ * (save the incomplete sequence for later)\n+ * and for optimizing iteration\n+ * (check for string length only once per character).\n+ *\n+ * \"Safe\" macro, checks for illegal sequences and for string boundaries.\n+ * Unlike U8_SET_CP_START(), this macro never reads s[length].\n+ *\n+ * (In UTF-16, simply check for U16_IS_LEAD(last code unit).)\n+ *\n+ * @param s const uint8_t * string\n+ * @param start int32_t starting string offset (usually 0)\n+ * @param length int32_t string length (usually start<=length)\n+ * @see U8_SET_CP_START\n+ * @draft ICU 61\n+ */\n+#define U8_TRUNCATE_IF_INCOMPLETE(s, start, length) \\\n+    if((length)>(start)) { \\\n+        uint8_t __b1=s[(length)-1]; \\\n+        if(U8_IS_SINGLE(__b1)) { \\\n+            /* common ASCII character */ \\\n+        } else if(U8_IS_LEAD(__b1)) { \\\n+            --(length); \\\n+        } else if(U8_IS_TRAIL(__b1) && ((length)-2)>=(start)) { \\\n+            uint8_t __b2=s[(length)-2]; \\\n+            if(0xe0<=__b2 && __b2<=0xf4) { \\\n+                if(__b2<0xf0 ? U8_IS_VALID_LEAD3_AND_T1(__b2, __b1) : \\\n+                        U8_IS_VALID_LEAD4_AND_T1(__b2, __b1)) { \\\n+                    (length)-=2; \\\n+                } \\\n+            } else if(U8_IS_TRAIL(__b2) && ((length)-3)>=(start)) { \\\n+                uint8_t __b3=s[(length)-3]; \\\n+                if(0xf0<=__b3 && __b3<=0xf4 && U8_IS_VALID_LEAD4_AND_T1(__b3, __b2)) { \\\n+                    (length)-=3; \\\n+                } \\\n+            } \\\n+        } \\\n+    }\n+#endif  // U_HIDE_DRAFT_API\n+\n /* definitions with backward iteration -------------------------------------- */\n \n /**"
        },
        {
            "sha": "bf6fd036f06c418e7ca715af47db89e739957c13",
            "filename": "deps/icu-small/source/common/unicode/utrace.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futrace.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futrace.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futrace.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -183,7 +183,7 @@ UTraceData(const void *context, int32_t fnNumber, int32_t level,\n   *  tracing functions must themselves filter by checking that the\n   *  current thread is the desired thread.\n   *\n-  *  @param context an uninterpretted pointer.  Whatever is passed in\n+  *  @param context an uninterpreted pointer.  Whatever is passed in\n   *                 here will in turn be passed to each of the tracing\n   *                 functions UTraceEntry, UTraceExit and UTraceData.\n   *                 ICU does not use or alter this pointer.\n@@ -320,7 +320,7 @@ utrace_getFunctions(const void **context,\n   *                 human readable form.  Note that a UTraceData function may choose\n   *                 to not format the data;  it could, for example, save it in\n   *                 in the raw form it was received (more compact), leaving\n-  *                 formatting for a later trace analyis tool.\n+  *                 formatting for a later trace analysis tool.\n   *  @param outBuf  pointer to a buffer to receive the formatted output.  Output\n   *                 will be nul terminated if there is space in the buffer -\n   *                 if the length of the requested output < the output buffer size."
        },
        {
            "sha": "b6cf4965112a1689aaf9edc4c68bffd2ebe65f11",
            "filename": "deps/icu-small/source/common/unicode/utypes.h",
            "status": "modified",
            "additions": 10,
            "deletions": 7,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futypes.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futypes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futypes.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -145,7 +145,7 @@\n /**\n  *  U_ICU_ENTRY_POINT is the name of the DLL entry point to the ICU data library.\n  *    Defined as a literal, not a string.\n- *    Tricky Preprocessor use - ## operator replaces macro paramters with the literal string\n+ *    Tricky Preprocessor use - ## operator replaces macro parameters with the literal string\n  *                              from the corresponding macro invocation, _before_ other macro substitutions.\n  *                              Need a nested \\#defines to get the actual version numbers rather than\n  *                              the literal text U_ICU_VERSION_MAJOR_NUM into the name.\n@@ -446,14 +446,14 @@ typedef enum UErrorCode {\n     U_BUFFER_OVERFLOW_ERROR   = 15,     /**< A result would not fit in the supplied buffer */\n     U_UNSUPPORTED_ERROR       = 16,     /**< Requested operation not supported in current context */\n     U_RESOURCE_TYPE_MISMATCH  = 17,     /**< an operation is requested over a resource that does not support it */\n-    U_ILLEGAL_ESCAPE_SEQUENCE = 18,     /**< ISO-2022 illlegal escape sequence */\n+    U_ILLEGAL_ESCAPE_SEQUENCE = 18,     /**< ISO-2022 illegal escape sequence */\n     U_UNSUPPORTED_ESCAPE_SEQUENCE = 19, /**< ISO-2022 unsupported escape sequence */\n     U_NO_SPACE_AVAILABLE      = 20,     /**< No space available for in-buffer expansion for Arabic shaping */\n     U_CE_NOT_FOUND_ERROR      = 21,     /**< Currently used only while setting variable top, but can be used generally */\n     U_PRIMARY_TOO_LONG_ERROR  = 22,     /**< User tried to set variable top to a primary that is longer than two bytes */\n     U_STATE_TOO_OLD_ERROR     = 23,     /**< ICU cannot construct a service from this state, as it is no longer supported */\n     U_TOO_MANY_ALIASES_ERROR  = 24,     /**< There are too many aliases in the path to the requested resource.\n-                                             It is very possible that a circular alias definition has occured */\n+                                             It is very possible that a circular alias definition has occurred */\n     U_ENUM_OUT_OF_SYNC_ERROR  = 25,     /**< UEnumeration out of sync with underlying collection */\n     U_INVARIANT_CONVERSION_ERROR = 26,  /**< Unable to convert a UChar* string to char* with the invariant converter. */\n     U_INVALID_STATE_ERROR     = 27,     /**< Requested operation can not be completed with ICU in its current state */\n@@ -499,7 +499,7 @@ typedef enum UErrorCode {\n     U_MULTIPLE_COMPOUND_FILTERS,      /**< More than one compound filter */\n     U_INVALID_RBT_SYNTAX,             /**< A \"::id\" rule was passed to the RuleBasedTransliterator parser */\n     U_INVALID_PROPERTY_PATTERN,       /**< UNUSED as of ICU 2.4 */\n-    U_MALFORMED_PRAGMA,               /**< A 'use' pragma is invlalid */\n+    U_MALFORMED_PRAGMA,               /**< A 'use' pragma is invalid */\n     U_UNCLOSED_SEGMENT,               /**< A closing ')' is missing */\n     U_ILLEGAL_CHAR_IN_SEGMENT,        /**< UNUSED as of ICU 2.4 */\n     U_VARIABLE_RANGE_EXHAUSTED,       /**< Too many stand-ins generated for the given variable range */\n@@ -539,12 +539,15 @@ typedef enum UErrorCode {\n     U_DEFAULT_KEYWORD_MISSING,        /**< Missing DEFAULT rule in plural rules */\n     U_DECIMAL_NUMBER_SYNTAX_ERROR,    /**< Decimal number syntax error */\n     U_FORMAT_INEXACT_ERROR,           /**< Cannot format a number exactly and rounding mode is ROUND_UNNECESSARY @stable ICU 4.8 */\n+#ifndef U_HIDE_DRAFT_API\n+    U_NUMBER_ARG_OUTOFBOUNDS_ERROR,   /**< The argument to a NumberFormatter helper method was out of bounds; the bounds are usually 0 to 999. @draft ICU 61 */\n+#endif  // U_HIDE_DRAFT_API\n #ifndef U_HIDE_DEPRECATED_API\n     /**\n      * One more than the highest normal formatting API error code.\n      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.\n      */\n-    U_FMT_PARSE_ERROR_LIMIT,\n+    U_FMT_PARSE_ERROR_LIMIT = 0x10113,\n #endif  // U_HIDE_DEPRECATED_API\n \n     /*\n@@ -555,7 +558,7 @@ typedef enum UErrorCode {\n     U_BRK_HEX_DIGITS_EXPECTED,             /**< Hex digits expected as part of a escaped char in a rule. */\n     U_BRK_SEMICOLON_EXPECTED,              /**< Missing ';' at the end of a RBBI rule.            */\n     U_BRK_RULE_SYNTAX,                     /**< Syntax error in RBBI rule.                        */\n-    U_BRK_UNCLOSED_SET,                    /**< UnicodeSet witing an RBBI rule missing a closing ']'.  */\n+    U_BRK_UNCLOSED_SET,                    /**< UnicodeSet writing an RBBI rule missing a closing ']'. */\n     U_BRK_ASSIGN_ERROR,                    /**< Syntax error in RBBI rule assignment statement.   */\n     U_BRK_VARIABLE_REDFINITION,            /**< RBBI rule $Variable redefined.                    */\n     U_BRK_MISMATCHED_PAREN,                /**< Mis-matched parentheses in an RBBI rule.          */\n@@ -564,7 +567,7 @@ typedef enum UErrorCode {\n     U_BRK_INIT_ERROR,                      /**< Initialization failure.  Probable missing ICU Data. */\n     U_BRK_RULE_EMPTY_SET,                  /**< Rule contains an empty Unicode Set.               */\n     U_BRK_UNRECOGNIZED_OPTION,             /**< !!option in RBBI rules not recognized.            */\n-    U_BRK_MALFORMED_RULE_TAG,              /**< The {nnn} tag on a rule is mal formed             */\n+    U_BRK_MALFORMED_RULE_TAG,              /**< The {nnn} tag on a rule is malformed              */\n #ifndef U_HIDE_DEPRECATED_API\n     /**\n      * One more than the highest normal BreakIterator error code."
        },
        {
            "sha": "0427bcb03db4e34c85a4f707ea6ef4b5d9d83d2e",
            "filename": "deps/icu-small/source/common/unicode/uvernum.h",
            "status": "modified",
            "additions": 16,
            "deletions": 9,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuvernum.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuvernum.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuvernum.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -58,13 +58,13 @@\n  *  This value will change in the subsequent releases of ICU\n  *  @stable ICU 2.4\n  */\n-#define U_ICU_VERSION_MAJOR_NUM 60\n+#define U_ICU_VERSION_MAJOR_NUM 61\n \n /** The current ICU minor version as an integer.\n  *  This value will change in the subsequent releases of ICU\n  *  @stable ICU 2.6\n  */\n-#define U_ICU_VERSION_MINOR_NUM 2\n+#define U_ICU_VERSION_MINOR_NUM 1\n \n /** The current ICU patchlevel version as an integer.\n  *  This value will change in the subsequent releases of ICU\n@@ -84,7 +84,7 @@\n  *  This value will change in the subsequent releases of ICU\n  *  @stable ICU 2.6\n  */\n-#define U_ICU_VERSION_SUFFIX _60\n+#define U_ICU_VERSION_SUFFIX _61\n \n /**\n  * \\def U_DEF2_ICU_ENTRY_POINT_RENAME\n@@ -119,19 +119,26 @@\n  *  This value will change in the subsequent releases of ICU\n  *  @stable ICU 2.4\n  */\n-#define U_ICU_VERSION \"60.2\"\n+#define U_ICU_VERSION \"61.1\"\n \n-/** The current ICU library major/minor version as a string without dots, for library name suffixes.\n- *  This value will change in the subsequent releases of ICU\n- *  @stable ICU 2.6\n+/**\n+ * The current ICU library major version number as a string, for library name suffixes.\n+ * This value will change in subsequent releases of ICU.\n+ *\n+ * Until ICU 4.8, this was the combination of the single-digit major and minor ICU version numbers\n+ * into one string without dots (\"48\").\n+ * Since ICU 49, it is the double-digit major ICU version number.\n+ * See http://userguide.icu-project.org/design#TOC-Version-Numbers-in-ICU\n+ *\n+ * @stable ICU 2.6\n  */\n-#define U_ICU_VERSION_SHORT \"60\"\n+#define U_ICU_VERSION_SHORT \"61\"\n \n #ifndef U_HIDE_INTERNAL_API\n /** Data version in ICU4C.\n  * @internal ICU 4.4 Internal Use Only\n  **/\n-#define U_ICU_DATA_VERSION \"60.2\"\n+#define U_ICU_DATA_VERSION \"61.1\"\n #endif  /* U_HIDE_INTERNAL_API */\n \n /*==========================================================================="
        },
        {
            "sha": "3f0251d3994bcb99f44e9d9017e95fc39726c5a9",
            "filename": "deps/icu-small/source/common/unicode/uversion.h",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuversion.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuversion.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuversion.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -105,7 +105,7 @@ typedef uint8_t UVersionInfo[U_MAX_VERSION_LENGTH];\n  * @stable ICU 2.4\n  */\n \n-/* Define namespace symbols if the compiler supports it. */\n+/* Define C++ namespace symbols. */\n #ifdef __cplusplus\n #   if U_DISABLE_RENAMING\n #       define U_ICU_NAMESPACE icu\n@@ -122,7 +122,13 @@ typedef uint8_t UVersionInfo[U_MAX_VERSION_LENGTH];\n #   define U_NAMESPACE_QUALIFIER U_ICU_NAMESPACE::\n \n #   ifndef U_USING_ICU_NAMESPACE\n-#       define U_USING_ICU_NAMESPACE 1\n+#       if defined(U_COMBINED_IMPLEMENTATION) || defined(U_COMMON_IMPLEMENTATION) || \\\n+                defined(U_I18N_IMPLEMENTATION) || defined(U_IO_IMPLEMENTATION) || \\\n+                defined(U_LAYOUTEX_IMPLEMENTATION) || defined(U_TOOLUTIL_IMPLEMENTATION)\n+#           define U_USING_ICU_NAMESPACE 0\n+#       else\n+#           define U_USING_ICU_NAMESPACE 0\n+#       endif\n #   endif\n #   if U_USING_ICU_NAMESPACE\n         U_NAMESPACE_USE"
        },
        {
            "sha": "f0f660ed06bb1939a4b57fa4d4cc753b1c0ff2c9",
            "filename": "deps/icu-small/source/common/unifiedcache.cpp",
            "status": "modified",
            "additions": 134,
            "deletions": 170,
            "changes": 304,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funifiedcache.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funifiedcache.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funifiedcache.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -6,24 +6,26 @@\n * others. All Rights Reserved.\n ******************************************************************************\n *\n-* File UNIFIEDCACHE.CPP\n+* File unifiedcache.cpp\n ******************************************************************************\n */\n \n-#include \"uhash.h\"\n #include \"unifiedcache.h\"\n-#include \"umutex.h\"\n+\n+#include <algorithm>      // For std::max()\n+\n #include \"mutex.h\"\n #include \"uassert.h\"\n+#include \"uhash.h\"\n #include \"ucln_cmn.h\"\n+#include \"umutex.h\"\n \n static icu::UnifiedCache *gCache = NULL;\n-static icu::SharedObject *gNoValue = NULL;\n static UMutex gCacheMutex = U_MUTEX_INITIALIZER;\n static UConditionVar gInProgressValueAddedCond = U_CONDITION_INITIALIZER;\n static icu::UInitOnce gCacheInitOnce = U_INITONCE_INITIALIZER;\n-static const int32_t MAX_EVICT_ITERATIONS = 10;\n \n+static const int32_t MAX_EVICT_ITERATIONS = 10;\n static const int32_t DEFAULT_MAX_UNUSED = 1000;\n static const int32_t DEFAULT_PERCENTAGE_OF_IN_USE = 100;\n \n@@ -35,10 +37,6 @@ static UBool U_CALLCONV unifiedcache_cleanup() {\n         delete gCache;\n         gCache = NULL;\n     }\n-    if (gNoValue) {\n-        delete gNoValue;\n-        gNoValue = NULL;\n-    }\n     return TRUE;\n }\n U_CDECL_END\n@@ -73,23 +71,15 @@ static void U_CALLCONV cacheInit(UErrorCode &status) {\n     ucln_common_registerCleanup(\n             UCLN_COMMON_UNIFIED_CACHE, unifiedcache_cleanup);\n \n-    // gNoValue must be created first to avoid assertion error in\n-    // cache constructor.\n-    gNoValue = new SharedObject();\n     gCache = new UnifiedCache(status);\n     if (gCache == NULL) {\n         status = U_MEMORY_ALLOCATION_ERROR;\n     }\n     if (U_FAILURE(status)) {\n         delete gCache;\n-        delete gNoValue;\n         gCache = NULL;\n-        gNoValue = NULL;\n         return;\n     }\n-    // We add a softref because we want hash elements with gNoValue to be\n-    // elligible for purging but we don't ever want gNoValue to be deleted.\n-    gNoValue->addSoftRef();\n }\n \n UnifiedCache *UnifiedCache::getInstance(UErrorCode &status) {\n@@ -104,14 +94,24 @@ UnifiedCache *UnifiedCache::getInstance(UErrorCode &status) {\n UnifiedCache::UnifiedCache(UErrorCode &status) :\n         fHashtable(NULL),\n         fEvictPos(UHASH_FIRST),\n-        fItemsInUseCount(0),\n+        fNumValuesTotal(0),\n+        fNumValuesInUse(0),\n         fMaxUnused(DEFAULT_MAX_UNUSED),\n         fMaxPercentageOfInUse(DEFAULT_PERCENTAGE_OF_IN_USE),\n-        fAutoEvictedCount(0) {\n+        fAutoEvictedCount(0),\n+        fNoValue(nullptr) {\n     if (U_FAILURE(status)) {\n         return;\n     }\n-    U_ASSERT(gNoValue != NULL);\n+    fNoValue = new SharedObject();\n+    if (fNoValue == nullptr) {\n+        status = U_MEMORY_ALLOCATION_ERROR;\n+        return;\n+    }\n+    fNoValue->softRefCount = 1;  // Add fake references to prevent fNoValue from being deleted\n+    fNoValue->hardRefCount = 1;  // when other references to it are removed.\n+    fNoValue->cachePtr = this;\n+\n     fHashtable = uhash_open(\n             &ucache_hashKeys,\n             &ucache_compareKeys,\n@@ -139,7 +139,7 @@ void UnifiedCache::setEvictionPolicy(\n \n int32_t UnifiedCache::unusedCount() const {\n     Mutex lock(&gCacheMutex);\n-    return uhash_count(fHashtable) - fItemsInUseCount;\n+    return uhash_count(fHashtable) - fNumValuesInUse;\n }\n \n int64_t UnifiedCache::autoEvictedCount() const {\n@@ -161,6 +161,12 @@ void UnifiedCache::flush() const {\n     while (_flush(FALSE));\n }\n \n+void UnifiedCache::handleUnreferencedObject() const {\n+    Mutex lock(&gCacheMutex);\n+    --fNumValuesInUse;\n+    _runEvictionSlice();\n+}\n+\n #ifdef UNIFIED_CACHE_DEBUG\n #include <stdio.h>\n \n@@ -199,7 +205,7 @@ void UnifiedCache::_dumpContents() const {\n                     \"Unified Cache: Key '%s', error %d, value %p, total refcount %d, soft refcount %d\\n\",\n                     key->writeDescription(buffer, 256),\n                     key->creationStatus,\n-                    sharedObject == gNoValue ? NULL :sharedObject,\n+                    sharedObject == fNoValue ? NULL :sharedObject,\n                     sharedObject->getRefCount(),\n                     sharedObject->getSoftRefCount());\n         }\n@@ -219,10 +225,11 @@ UnifiedCache::~UnifiedCache() {\n         _flush(TRUE);\n     }\n     uhash_close(fHashtable);\n+    fHashtable = nullptr;\n+    delete fNoValue;\n+    fNoValue = nullptr;\n }\n \n-// Returns the next element in the cache round robin style.\n-// On entry, gCacheMutex must be held.\n const UHashElement *\n UnifiedCache::_nextElement() const {\n     const UHashElement *element = uhash_nextElement(fHashtable, &fEvictPos);\n@@ -233,58 +240,51 @@ UnifiedCache::_nextElement() const {\n     return element;\n }\n \n-// Flushes the contents of the cache. If cache values hold references to other\n-// cache values then _flush should be called in a loop until it returns FALSE.\n-// On entry, gCacheMutex must be held.\n-// On exit, those values with are evictable are flushed. If all is true\n-// then every value is flushed even if it is not evictable.\n-// Returns TRUE if any value in cache was flushed or FALSE otherwise.\n UBool UnifiedCache::_flush(UBool all) const {\n     UBool result = FALSE;\n     int32_t origSize = uhash_count(fHashtable);\n     for (int32_t i = 0; i < origSize; ++i) {\n         const UHashElement *element = _nextElement();\n+        if (element == nullptr) {\n+            break;\n+        }\n         if (all || _isEvictable(element)) {\n             const SharedObject *sharedObject =\n                     (const SharedObject *) element->value.pointer;\n+            U_ASSERT(sharedObject->cachePtr = this);\n             uhash_removeElement(fHashtable, element);\n-            sharedObject->removeSoftRef();\n+            removeSoftRef(sharedObject);    // Deletes the sharedObject when softRefCount goes to zero.\n             result = TRUE;\n         }\n     }\n     return result;\n }\n \n-// Computes how many items should be evicted.\n-// On entry, gCacheMutex must be held.\n-// Returns number of items that should be evicted or a value <= 0 if no\n-// items need to be evicted.\n int32_t UnifiedCache::_computeCountOfItemsToEvict() const {\n-    int32_t maxPercentageOfInUseCount =\n-            fItemsInUseCount * fMaxPercentageOfInUse / 100;\n-    int32_t maxUnusedCount = fMaxUnused;\n-    if (maxUnusedCount < maxPercentageOfInUseCount) {\n-        maxUnusedCount = maxPercentageOfInUseCount;\n-    }\n-    return uhash_count(fHashtable) - fItemsInUseCount - maxUnusedCount;\n+    int32_t totalItems = uhash_count(fHashtable);\n+    int32_t evictableItems = totalItems - fNumValuesInUse;\n+\n+    int32_t unusedLimitByPercentage = fNumValuesInUse * fMaxPercentageOfInUse / 100;\n+    int32_t unusedLimit = std::max(unusedLimitByPercentage, fMaxUnused);\n+    int32_t countOfItemsToEvict = std::max(0, evictableItems - unusedLimit);\n+    return countOfItemsToEvict;\n }\n \n-// Run an eviction slice.\n-// On entry, gCacheMutex must be held.\n-// _runEvictionSlice runs a slice of the evict pipeline by examining the next\n-// 10 entries in the cache round robin style evicting them if they are eligible.\n void UnifiedCache::_runEvictionSlice() const {\n     int32_t maxItemsToEvict = _computeCountOfItemsToEvict();\n     if (maxItemsToEvict <= 0) {\n         return;\n     }\n     for (int32_t i = 0; i < MAX_EVICT_ITERATIONS; ++i) {\n         const UHashElement *element = _nextElement();\n+        if (element == nullptr) {\n+            break;\n+        }\n         if (_isEvictable(element)) {\n             const SharedObject *sharedObject =\n                     (const SharedObject *) element->value.pointer;\n             uhash_removeElement(fHashtable, element);\n-            sharedObject->removeSoftRef();\n+            removeSoftRef(sharedObject);   // Deletes sharedObject when SoftRefCount goes to zero.\n             ++fAutoEvictedCount;\n             if (--maxItemsToEvict == 0) {\n                 break;\n@@ -293,11 +293,6 @@ void UnifiedCache::_runEvictionSlice() const {\n     }\n }\n \n-\n-// Places a new value and creationStatus in the cache for the given key.\n-// On entry, gCacheMutex must be held. key must not exist in the cache.\n-// On exit, value and creation status placed under key. Soft reference added\n-// to value on successful add. On error sets status.\n void UnifiedCache::_putNew(\n         const CacheKeyBase &key,\n         const SharedObject *value,\n@@ -312,24 +307,17 @@ void UnifiedCache::_putNew(\n         return;\n     }\n     keyToAdopt->fCreationStatus = creationStatus;\n-    if (value->noSoftReferences()) {\n+    if (value->softRefCount == 0) {\n         _registerMaster(keyToAdopt, value);\n     }\n-    uhash_put(fHashtable, keyToAdopt, (void *) value, &status);\n+    void *oldValue = uhash_put(fHashtable, keyToAdopt, (void *) value, &status);\n+    U_ASSERT(oldValue == nullptr);\n+    (void)oldValue;\n     if (U_SUCCESS(status)) {\n-        value->addSoftRef();\n+        value->softRefCount++;\n     }\n }\n \n-// Places value and status at key if there is no value at key or if cache\n-// entry for key is in progress. Otherwise, it leaves the current value and\n-// status there.\n-// On entry. gCacheMutex must not be held. value must be\n-// included in the reference count of the object to which it points.\n-// On exit, value and status are changed to what was already in the cache if\n-// something was there and not in progress. Otherwise, value and status are left\n-// unchanged in which case they are placed in the cache on a best-effort basis.\n-// Caller must call removeRef() on value.\n void UnifiedCache::_putIfAbsentAndGet(\n         const CacheKeyBase &key,\n         const SharedObject *&value,\n@@ -352,15 +340,7 @@ void UnifiedCache::_putIfAbsentAndGet(\n     _runEvictionSlice();\n }\n \n-// Attempts to fetch value and status for key from cache.\n-// On entry, gCacheMutex must not be held value must be NULL and status must\n-// be U_ZERO_ERROR.\n-// On exit, either returns FALSE (In this\n-// case caller should try to create the object) or returns TRUE with value\n-// pointing to the fetched value and status set to fetched status. When\n-// FALSE is returned status may be set to failure if an in progress hash\n-// entry could not be made but value will remain unchanged. When TRUE is\n-// returned, caler must call removeRef() on value.\n+\n UBool UnifiedCache::_poll(\n         const CacheKeyBase &key,\n         const SharedObject *&value,\n@@ -369,27 +349,29 @@ UBool UnifiedCache::_poll(\n     U_ASSERT(status == U_ZERO_ERROR);\n     Mutex lock(&gCacheMutex);\n     const UHashElement *element = uhash_find(fHashtable, &key);\n-    while (element != NULL && _inProgress(element)) {\n+\n+    // If the hash table contains an inProgress placeholder entry for this key,\n+    // this means that another thread is currently constructing the value object.\n+    // Loop, waiting for that construction to complete.\n+     while (element != NULL && _inProgress(element)) {\n         umtx_condWait(&gInProgressValueAddedCond, &gCacheMutex);\n         element = uhash_find(fHashtable, &key);\n     }\n+\n+    // If the hash table contains an entry for the key,\n+    // fetch out the contents and return them.\n     if (element != NULL) {\n-        _fetch(element, value, status);\n+         _fetch(element, value, status);\n         return TRUE;\n     }\n-    _putNew(key, gNoValue, U_ZERO_ERROR, status);\n+\n+    // The hash table contained nothing for this key.\n+    // Insert an inProgress place holder value.\n+    // Our caller will create the final value and update the hash table.\n+    _putNew(key, fNoValue, U_ZERO_ERROR, status);\n     return FALSE;\n }\n \n-// Gets value out of cache.\n-// On entry. gCacheMutex must not be held. value must be NULL. status\n-// must be U_ZERO_ERROR.\n-// On exit. value and status set to what is in cache at key or on cache\n-// miss the key's createObject() is called and value and status are set to\n-// the result of that. In this latter case, best effort is made to add the\n-// value and status to the cache. If createObject() fails to create a value,\n-// gNoValue is stored in cache, and value is set to NULL. Caller must call\n-// removeRef on value if non NULL.\n void UnifiedCache::_get(\n         const CacheKeyBase &key,\n         const SharedObject *&value,\n@@ -398,7 +380,7 @@ void UnifiedCache::_get(\n     U_ASSERT(value == NULL);\n     U_ASSERT(status == U_ZERO_ERROR);\n     if (_poll(key, value, status)) {\n-        if (value == gNoValue) {\n+        if (value == fNoValue) {\n             SharedObject::clearPtr(value);\n         }\n         return;\n@@ -410,46 +392,22 @@ void UnifiedCache::_get(\n     U_ASSERT(value == NULL || value->hasHardReferences());\n     U_ASSERT(value != NULL || status != U_ZERO_ERROR);\n     if (value == NULL) {\n-        SharedObject::copyPtr(gNoValue, value);\n+        SharedObject::copyPtr(fNoValue, value);\n     }\n     _putIfAbsentAndGet(key, value, status);\n-    if (value == gNoValue) {\n+    if (value == fNoValue) {\n         SharedObject::clearPtr(value);\n     }\n }\n \n-void UnifiedCache::decrementItemsInUseWithLockingAndEviction() const {\n-    Mutex mutex(&gCacheMutex);\n-    decrementItemsInUse();\n-    _runEvictionSlice();\n-}\n-\n-void UnifiedCache::incrementItemsInUse() const {\n-    ++fItemsInUseCount;\n-}\n-\n-void UnifiedCache::decrementItemsInUse() const {\n-    --fItemsInUseCount;\n+void UnifiedCache::_registerMaster(\n+            const CacheKeyBase *theKey, const SharedObject *value) const {\n+    theKey->fIsMaster = true;\n+    value->cachePtr = this;\n+    ++fNumValuesTotal;\n+    ++fNumValuesInUse;\n }\n \n-// Register a master cache entry.\n-// On entry, gCacheMutex must be held.\n-// On exit, items in use count incremented, entry is marked as a master\n-// entry, and value registered with cache so that subsequent calls to\n-// addRef() and removeRef() on it correctly updates items in use count\n-void UnifiedCache::_registerMaster(\n-        const CacheKeyBase *theKey, const SharedObject *value) const {\n-    theKey->fIsMaster = TRUE;\n-    ++fItemsInUseCount;\n-    value->registerWithCache(this);\n-}\n-\n-// Store a value and error in given hash entry.\n-// On entry, gCacheMutex must be held. Hash entry element must be in progress.\n-// value must be non NULL.\n-// On Exit, soft reference added to value. value and status stored in hash\n-// entry. Soft reference removed from previous stored value. Waiting\n-// threads notified.\n void UnifiedCache::_put(\n         const UHashElement *element,\n         const SharedObject *value,\n@@ -458,86 +416,52 @@ void UnifiedCache::_put(\n     const CacheKeyBase *theKey = (const CacheKeyBase *) element->key.pointer;\n     const SharedObject *oldValue = (const SharedObject *) element->value.pointer;\n     theKey->fCreationStatus = status;\n-    if (value->noSoftReferences()) {\n+    if (value->softRefCount == 0) {\n         _registerMaster(theKey, value);\n     }\n-    value->addSoftRef();\n+    value->softRefCount++;\n     UHashElement *ptr = const_cast<UHashElement *>(element);\n     ptr->value.pointer = (void *) value;\n-    oldValue->removeSoftRef();\n+    U_ASSERT(oldValue == fNoValue);\n+    removeSoftRef(oldValue);\n \n     // Tell waiting threads that we replace in-progress status with\n     // an error.\n     umtx_condBroadcast(&gInProgressValueAddedCond);\n }\n \n-void\n-UnifiedCache::copyPtr(const SharedObject *src, const SharedObject *&dest) {\n-    if(src != dest) {\n-        if(dest != NULL) {\n-            dest->removeRefWhileHoldingCacheLock();\n-        }\n-        dest = src;\n-        if(src != NULL) {\n-            src->addRefWhileHoldingCacheLock();\n-        }\n-    }\n-}\n-\n-void\n-UnifiedCache::clearPtr(const SharedObject *&ptr) {\n-    if (ptr != NULL) {\n-        ptr->removeRefWhileHoldingCacheLock();\n-        ptr = NULL;\n-    }\n-}\n-\n-\n-// Fetch value and error code from a particular hash entry.\n-// On entry, gCacheMutex must be held. value must be either NULL or must be\n-// included in the ref count of the object to which it points.\n-// On exit, value and status set to what is in the hash entry. Caller must\n-// eventually call removeRef on value.\n-// If hash entry is in progress, value will be set to gNoValue and status will\n-// be set to U_ZERO_ERROR.\n void UnifiedCache::_fetch(\n         const UHashElement *element,\n         const SharedObject *&value,\n-        UErrorCode &status) {\n+        UErrorCode &status) const {\n     const CacheKeyBase *theKey = (const CacheKeyBase *) element->key.pointer;\n     status = theKey->fCreationStatus;\n \n-    // Since we have the cache lock, calling regular SharedObject methods\n+    // Since we have the cache lock, calling regular SharedObject add/removeRef\n     // could cause us to deadlock on ourselves since they may need to lock\n     // the cache mutex.\n-    UnifiedCache::copyPtr((const SharedObject *) element->value.pointer, value);\n+    removeHardRef(value);\n+    value = static_cast<const SharedObject *>(element->value.pointer);\n+    addHardRef(value);\n }\n \n-// Determine if given hash entry is in progress.\n-// On entry, gCacheMutex must be held.\n-UBool UnifiedCache::_inProgress(const UHashElement *element) {\n-    const SharedObject *value = NULL;\n+\n+UBool UnifiedCache::_inProgress(const UHashElement* element) const {\n     UErrorCode status = U_ZERO_ERROR;\n+    const SharedObject * value = NULL;\n     _fetch(element, value, status);\n     UBool result = _inProgress(value, status);\n-\n-    // Since we have the cache lock, calling regular SharedObject methods\n-    // could cause us to deadlock on ourselves since they may need to lock\n-    // the cache mutex.\n-    UnifiedCache::clearPtr(value);\n+    removeHardRef(value);\n     return result;\n }\n \n-// Determine if given hash entry is in progress.\n-// On entry, gCacheMutex must be held.\n UBool UnifiedCache::_inProgress(\n-        const SharedObject *theValue, UErrorCode creationStatus) {\n-    return (theValue == gNoValue && creationStatus == U_ZERO_ERROR);\n+        const SharedObject* theValue, UErrorCode creationStatus) const {\n+    return (theValue == fNoValue && creationStatus == U_ZERO_ERROR);\n }\n \n-// Determine if given hash entry is eligible for eviction.\n-// On entry, gCacheMutex must be held.\n-UBool UnifiedCache::_isEvictable(const UHashElement *element) {\n+UBool UnifiedCache::_isEvictable(const UHashElement *element) const\n+{\n     const CacheKeyBase *theKey = (const CacheKeyBase *) element->key.pointer;\n     const SharedObject *theValue =\n             (const SharedObject *) element->value.pointer;\n@@ -549,7 +473,47 @@ UBool UnifiedCache::_isEvictable(const UHashElement *element) {\n \n     // We can evict entries that are either not a master or have just\n     // one reference (The one reference being from the cache itself).\n-    return (!theKey->fIsMaster || (theValue->getSoftRefCount() == 1 && theValue->noHardReferences()));\n+    return (!theKey->fIsMaster || (theValue->softRefCount == 1 && theValue->noHardReferences()));\n+}\n+\n+void UnifiedCache::removeSoftRef(const SharedObject *value) const {\n+    U_ASSERT(value->cachePtr == this);\n+    U_ASSERT(value->softRefCount > 0);\n+    if (--value->softRefCount == 0) {\n+        --fNumValuesTotal;\n+        if (value->noHardReferences()) {\n+            delete value;\n+        } else {\n+            // This path only happens from flush(all). Which only happens from the\n+            // UnifiedCache destructor.  Nulling out value.cacheptr changes the behavior\n+            // of value.removeRef(), causing the deletion to be done there.\n+            value->cachePtr = nullptr;\n+        }\n+    }\n+}\n+\n+int32_t UnifiedCache::removeHardRef(const SharedObject *value) const {\n+    int refCount = 0;\n+    if (value) {\n+        refCount = umtx_atomic_dec(&value->hardRefCount);\n+        U_ASSERT(refCount >= 0);\n+        if (refCount == 0) {\n+            --fNumValuesInUse;\n+        }\n+    }\n+    return refCount;\n+}\n+\n+int32_t UnifiedCache::addHardRef(const SharedObject *value) const {\n+    int refCount = 0;\n+    if (value) {\n+        refCount = umtx_atomic_inc(&value->hardRefCount);\n+        U_ASSERT(refCount >= 1);\n+        if (refCount == 1) {\n+            fNumValuesInUse++;\n+        }\n+    }\n+    return refCount;\n }\n \n U_NAMESPACE_END"
        },
        {
            "sha": "b3ccd60d177ea17436d8075ca21331ae84725cce",
            "filename": "deps/icu-small/source/common/unifiedcache.h",
            "status": "modified",
            "additions": 182,
            "deletions": 28,
            "changes": 210,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funifiedcache.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funifiedcache.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funifiedcache.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -190,7 +190,7 @@ class U_COMMON_API UnifiedCache : public UnifiedCacheBase {\n    UnifiedCache(UErrorCode &status);\n \n    /**\n-    * Returns the cache instance.\n+    * Return a pointer to the global cache instance.\n     */\n    static UnifiedCache *getInstance(UErrorCode &status);\n \n@@ -294,7 +294,7 @@ class U_COMMON_API UnifiedCache : public UnifiedCacheBase {\n \n    /**\n     * Configures at what point evcition of unused entries will begin.\n-    * Eviction is triggered whenever the number of unused entries exeeds\n+    * Eviction is triggered whenever the number of evictable keys exeeds\n     * BOTH count AND (number of in-use items) * (percentageOfInUseItems / 100).\n     * Once the number of unused entries drops below one of these,\n     * eviction ceases. Because eviction happens incrementally,\n@@ -341,60 +341,214 @@ class U_COMMON_API UnifiedCache : public UnifiedCacheBase {\n     */\n    int32_t unusedCount() const;\n \n-   virtual void incrementItemsInUse() const;\n-   virtual void decrementItemsInUseWithLockingAndEviction() const;\n-   virtual void decrementItemsInUse() const;\n+   virtual void handleUnreferencedObject() const;\n    virtual ~UnifiedCache();\n+\n  private:\n    UHashtable *fHashtable;\n    mutable int32_t fEvictPos;\n-   mutable int32_t fItemsInUseCount;\n+   mutable int32_t fNumValuesTotal;\n+   mutable int32_t fNumValuesInUse;\n    int32_t fMaxUnused;\n    int32_t fMaxPercentageOfInUse;\n    mutable int64_t fAutoEvictedCount;\n+   SharedObject *fNoValue;\n+\n    UnifiedCache(const UnifiedCache &other);\n    UnifiedCache &operator=(const UnifiedCache &other);\n+\n+   /**\n+    * Flushes the contents of the cache. If cache values hold references to other\n+    * cache values then _flush should be called in a loop until it returns FALSE.\n+    *\n+    * On entry, gCacheMutex must be held.\n+    * On exit, those values with are evictable are flushed.\n+    *\n+    *  @param all if false flush evictable items only, which are those with no external\n+    *                    references, plus those that can be safely recreated.<br>\n+    *            if true, flush all elements. Any values (sharedObjects) with remaining\n+    *                     hard (external) references are not deleted, but are detached from\n+    *                     the cache, so that a subsequent removeRefs can delete them.\n+    *                     _flush is not thread safe when all is true.\n+    *   @return TRUE if any value in cache was flushed or FALSE otherwise.\n+    */\n    UBool _flush(UBool all) const;\n+\n+   /**\n+    * Gets value out of cache.\n+    * On entry. gCacheMutex must not be held. value must be NULL. status\n+    * must be U_ZERO_ERROR.\n+    * On exit. value and status set to what is in cache at key or on cache\n+    * miss the key's createObject() is called and value and status are set to\n+    * the result of that. In this latter case, best effort is made to add the\n+    * value and status to the cache. If createObject() fails to create a value,\n+    * fNoValue is stored in cache, and value is set to NULL. Caller must call\n+    * removeRef on value if non NULL.\n+    */\n    void _get(\n            const CacheKeyBase &key,\n            const SharedObject *&value,\n            const void *creationContext,\n            UErrorCode &status) const;\n-   UBool _poll(\n-           const CacheKeyBase &key,\n-           const SharedObject *&value,\n-           UErrorCode &status) const;\n-   void _putNew(\n-           const CacheKeyBase &key,\n-           const SharedObject *value,\n-           const UErrorCode creationStatus,\n-           UErrorCode &status) const;\n+\n+    /**\n+     * Attempts to fetch value and status for key from cache.\n+     * On entry, gCacheMutex must not be held value must be NULL and status must\n+     * be U_ZERO_ERROR.\n+     * On exit, either returns FALSE (In this\n+     * case caller should try to create the object) or returns TRUE with value\n+     * pointing to the fetched value and status set to fetched status. When\n+     * FALSE is returned status may be set to failure if an in progress hash\n+     * entry could not be made but value will remain unchanged. When TRUE is\n+     * returned, caller must call removeRef() on value.\n+     */\n+    UBool _poll(\n+            const CacheKeyBase &key,\n+            const SharedObject *&value,\n+            UErrorCode &status) const;\n+\n+    /**\n+     * Places a new value and creationStatus in the cache for the given key.\n+     * On entry, gCacheMutex must be held. key must not exist in the cache.\n+     * On exit, value and creation status placed under key. Soft reference added\n+     * to value on successful add. On error sets status.\n+     */\n+    void _putNew(\n+        const CacheKeyBase &key,\n+        const SharedObject *value,\n+        const UErrorCode creationStatus,\n+        UErrorCode &status) const;\n+\n+    /**\n+     * Places value and status at key if there is no value at key or if cache\n+     * entry for key is in progress. Otherwise, it leaves the current value and\n+     * status there.\n+     *\n+     * On entry. gCacheMutex must not be held. Value must be\n+     * included in the reference count of the object to which it points.\n+     *\n+     * On exit, value and status are changed to what was already in the cache if\n+     * something was there and not in progress. Otherwise, value and status are left\n+     * unchanged in which case they are placed in the cache on a best-effort basis.\n+     * Caller must call removeRef() on value.\n+     */\n    void _putIfAbsentAndGet(\n            const CacheKeyBase &key,\n            const SharedObject *&value,\n            UErrorCode &status) const;\n-   const UHashElement *_nextElement() const;\n+\n+    /**\n+     * Returns the next element in the cache round robin style.\n+     * Returns nullptr if the cache is empty.\n+     * On entry, gCacheMutex must be held.\n+     */\n+    const UHashElement *_nextElement() const;\n+\n+   /**\n+    * Return the number of cache items that would need to be evicted\n+    * to bring usage into conformance with eviction policy.\n+    *\n+    * An item corresponds to an entry in the hash table, a hash table element.\n+    *\n+    * On entry, gCacheMutex must be held.\n+    */\n    int32_t _computeCountOfItemsToEvict() const;\n+\n+   /**\n+    * Run an eviction slice.\n+    * On entry, gCacheMutex must be held.\n+    * _runEvictionSlice runs a slice of the evict pipeline by examining the next\n+    * 10 entries in the cache round robin style evicting them if they are eligible.\n+    */\n    void _runEvictionSlice() const;\n-   void _registerMaster(\n-        const CacheKeyBase *theKey, const SharedObject *value) const;\n+\n+   /**\n+    * Register a master cache entry. A master key is the first key to create\n+    * a given  SharedObject value. Subsequent keys whose create function\n+    * produce referneces to an already existing SharedObject are not masters -\n+    * they can be evicted and subsequently recreated.\n+    *\n+    * On entry, gCacheMutex must be held.\n+    * On exit, items in use count incremented, entry is marked as a master\n+    * entry, and value registered with cache so that subsequent calls to\n+    * addRef() and removeRef() on it correctly interact with the cache.\n+    */\n+   void _registerMaster(const CacheKeyBase *theKey, const SharedObject *value) const;\n+\n+   /**\n+    * Store a value and creation error status in given hash entry.\n+    * On entry, gCacheMutex must be held. Hash entry element must be in progress.\n+    * value must be non NULL.\n+    * On Exit, soft reference added to value. value and status stored in hash\n+    * entry. Soft reference removed from previous stored value. Waiting\n+    * threads notified.\n+    */\n    void _put(\n            const UHashElement *element,\n            const SharedObject *value,\n            const UErrorCode status) const;\n+    /**\n+     * Remove a soft reference, and delete the SharedObject if no references remain.\n+     * To be used from within the UnifiedCache implementation only.\n+     * gCacheMutex must be held by caller.\n+     * @param value the SharedObject to be acted on.\n+     */\n+   void removeSoftRef(const SharedObject *value) const;\n+\n+   /**\n+    * Increment the hard reference count of the given SharedObject.\n+    * gCacheMutex must be held by the caller.\n+    * Update numValuesEvictable on transitions between zero and one reference.\n+    *\n+    * @param value The SharedObject to be referenced.\n+    * @return the hard reference count after the addition.\n+    */\n+   int32_t addHardRef(const SharedObject *value) const;\n+\n+  /**\n+    * Decrement the hard reference count of the given SharedObject.\n+    * gCacheMutex must be held by the caller.\n+    * Update numValuesEvictable on transitions between one and zero reference.\n+    *\n+    * @param value The SharedObject to be referenced.\n+    * @return the hard reference count after the removal.\n+    */\n+   int32_t removeHardRef(const SharedObject *value) const;\n+\n+\n #ifdef UNIFIED_CACHE_DEBUG\n    void _dumpContents() const;\n #endif\n-   static void copyPtr(const SharedObject *src, const SharedObject *&dest);\n-   static void clearPtr(const SharedObject *&ptr);\n-   static void _fetch(\n-           const UHashElement *element,\n-           const SharedObject *&value,\n-           UErrorCode &status);\n-   static UBool _inProgress(const UHashElement *element);\n-   static UBool _inProgress(\n-           const SharedObject *theValue, UErrorCode creationStatus);\n-   static UBool _isEvictable(const UHashElement *element);\n+\n+   /**\n+    *  Fetch value and error code from a particular hash entry.\n+    *  On entry, gCacheMutex must be held. value must be either NULL or must be\n+    *  included in the ref count of the object to which it points.\n+    *  On exit, value and status set to what is in the hash entry. Caller must\n+    *  eventually call removeRef on value.\n+    *  If hash entry is in progress, value will be set to gNoValue and status will\n+    *  be set to U_ZERO_ERROR.\n+    */\n+   void _fetch(const UHashElement *element, const SharedObject *&value,\n+                       UErrorCode &status) const;\n+\n+    /**\n+     * Determine if given hash entry is in progress.\n+     * On entry, gCacheMutex must be held.\n+     */\n+   UBool _inProgress(const UHashElement *element) const;\n+\n+   /**\n+    * Determine if given hash entry is in progress.\n+    * On entry, gCacheMutex must be held.\n+    */\n+   UBool _inProgress(const SharedObject *theValue, UErrorCode creationStatus) const;\n+\n+   /**\n+    * Determine if given hash entry is eligible for eviction.\n+    * On entry, gCacheMutex must be held.\n+    */\n+   UBool _isEvictable(const UHashElement *element) const;\n };\n \n U_NAMESPACE_END"
        },
        {
            "sha": "97c7bc9d352ab95a9959b1ad986fd4ce3c488b9c",
            "filename": "deps/icu-small/source/common/uniset_closure.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset_closure.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset_closure.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset_closure.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -129,7 +129,7 @@ UnicodeSet& UnicodeSet::applyPattern(const UnicodeString& pattern,\n     // _applyPattern calls add() etc., which set pat to empty.\n     UnicodeString rebuiltPat;\n     RuleCharacterIterator chars(pattern, symbols, pos);\n-    applyPattern(chars, symbols, rebuiltPat, options, &UnicodeSet::closeOver, status);\n+    applyPattern(chars, symbols, rebuiltPat, options, &UnicodeSet::closeOver, 0, status);\n     if (U_FAILURE(status)) return *this;\n     if (chars.inVariable()) {\n         // syntaxError(chars, \"Extra chars in variable value\");"
        },
        {
            "sha": "ef5d6a32b2d10b8c19c8acbb58dcc5a2296a5429",
            "filename": "deps/icu-small/source/common/uniset_props.cpp",
            "status": "modified",
            "additions": 25,
            "deletions": 3,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset_props.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset_props.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset_props.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -231,7 +231,7 @@ void U_CALLCONV UnicodeSet_initInclusion(int32_t src, UErrorCode &status) {\n         ucase_addPropertyStarts(&sa, &status);\n         break;\n     case UPROPS_SRC_BIDI:\n-        ubidi_addPropertyStarts(ubidi_getSingleton(), &sa, &status);\n+        ubidi_addPropertyStarts(&sa, &status);\n         break;\n     default:\n         status = U_INTERNAL_PROGRAM_ERROR;\n@@ -257,6 +257,7 @@ const UnicodeSet* UnicodeSet::getInclusions(int32_t src, UErrorCode &status) {\n     return i.fSet;\n }\n \n+namespace {\n \n // Cache some sets for other services -------------------------------------- ***\n void U_CALLCONV createUni32Set(UErrorCode &errorCode) {\n@@ -315,6 +316,8 @@ isPOSIXClose(const UnicodeString &pattern, int32_t pos) {\n // memory leak checker tools\n #define _dbgct(me)\n \n+}  // namespace\n+\n //----------------------------------------------------------------\n // Constructors &c\n //----------------------------------------------------------------\n@@ -382,7 +385,7 @@ UnicodeSet::applyPatternIgnoreSpace(const UnicodeString& pattern,\n     // _applyPattern calls add() etc., which set pat to empty.\n     UnicodeString rebuiltPat;\n     RuleCharacterIterator chars(pattern, symbols, pos);\n-    applyPattern(chars, symbols, rebuiltPat, USET_IGNORE_SPACE, NULL, status);\n+    applyPattern(chars, symbols, rebuiltPat, USET_IGNORE_SPACE, NULL, 0, status);\n     if (U_FAILURE(status)) return;\n     if (chars.inVariable()) {\n         // syntaxError(chars, \"Extra chars in variable value\");\n@@ -406,6 +409,8 @@ UBool UnicodeSet::resemblesPattern(const UnicodeString& pattern, int32_t pos) {\n // Implementation: Pattern parsing\n //----------------------------------------------------------------\n \n+namespace {\n+\n /**\n  * A small all-inline class to manage a UnicodeSet pointer.  Add\n  * operator->() etc. as needed.\n@@ -424,6 +429,10 @@ class UnicodeSetPointer {\n     }\n };\n \n+constexpr int32_t MAX_DEPTH = 100;\n+\n+}  // namespace\n+\n /**\n  * Parse the pattern from the given RuleCharacterIterator.  The\n  * iterator is advanced over the parsed pattern.\n@@ -443,8 +452,13 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,\n                               UnicodeString& rebuiltPat,\n                               uint32_t options,\n                               UnicodeSet& (UnicodeSet::*caseClosure)(int32_t attribute),\n+                              int32_t depth,\n                               UErrorCode& ec) {\n     if (U_FAILURE(ec)) return;\n+    if (depth > MAX_DEPTH) {\n+        ec = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n \n     // Syntax characters: [ ] ^ - & { }\n \n@@ -579,7 +593,7 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,\n             }\n             switch (setMode) {\n             case 1:\n-                nested->applyPattern(chars, symbols, patLocal, options, caseClosure, ec);\n+                nested->applyPattern(chars, symbols, patLocal, options, caseClosure, depth + 1, ec);\n                 break;\n             case 2:\n                 chars.skipIgnored(opts);\n@@ -837,6 +851,8 @@ void UnicodeSet::applyPattern(RuleCharacterIterator& chars,\n // Property set implementation\n //----------------------------------------------------------------\n \n+namespace {\n+\n static UBool numericValueFilter(UChar32 ch, void* context) {\n     return u_getNumericValue(ch) == *(double*)context;\n }\n@@ -868,6 +884,8 @@ static UBool scriptExtensionsFilter(UChar32 ch, void* context) {\n     return uscript_hasScript(ch, *(UScriptCode*)context);\n }\n \n+}  // namespace\n+\n /**\n  * Generic filter-based scanning code for UCD property UnicodeSets.\n  */\n@@ -924,6 +942,8 @@ void UnicodeSet::applyFilter(UnicodeSet::Filter filter,\n     }\n }\n \n+namespace {\n+\n static UBool mungeCharName(char* dst, const char* src, int32_t dstCapacity) {\n     /* Note: we use ' ' in compiler code page */\n     int32_t j = 0;\n@@ -941,6 +961,8 @@ static UBool mungeCharName(char* dst, const char* src, int32_t dstCapacity) {\n     return TRUE;\n }\n \n+}  // namespace\n+\n //----------------------------------------------------------------\n // Property set API\n //----------------------------------------------------------------"
        },
        {
            "sha": "b76896db1b704f098a058f8ec23b0ae1e6fa1583",
            "filename": "deps/icu-small/source/common/uprops.cpp",
            "status": "modified",
            "additions": 7,
            "deletions": 9,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fuprops.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fuprops.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fuprops.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -38,8 +38,6 @@\n \n U_NAMESPACE_USE\n \n-#define GET_BIDI_PROPS() ubidi_getSingleton()\n-\n /* general properties API functions ----------------------------------------- */\n \n struct BinaryProperty;\n@@ -62,15 +60,15 @@ static UBool caseBinaryPropertyContains(const BinaryProperty &/*prop*/, UChar32\n }\n \n static UBool isBidiControl(const BinaryProperty &/*prop*/, UChar32 c, UProperty /*which*/) {\n-    return ubidi_isBidiControl(GET_BIDI_PROPS(), c);\n+    return ubidi_isBidiControl(c);\n }\n \n static UBool isMirrored(const BinaryProperty &/*prop*/, UChar32 c, UProperty /*which*/) {\n-    return ubidi_isMirrored(GET_BIDI_PROPS(), c);\n+    return ubidi_isMirrored(c);\n }\n \n static UBool isJoinControl(const BinaryProperty &/*prop*/, UChar32 c, UProperty /*which*/) {\n-    return ubidi_isJoinControl(GET_BIDI_PROPS(), c);\n+    return ubidi_isJoinControl(c);\n }\n \n #if UCONFIG_NO_NORMALIZATION\n@@ -329,11 +327,11 @@ static int32_t getBiDiClass(const IntProperty &/*prop*/, UChar32 c, UProperty /*\n }\n \n static int32_t getBiDiPairedBracketType(const IntProperty &/*prop*/, UChar32 c, UProperty /*which*/) {\n-    return (int32_t)ubidi_getPairedBracketType(GET_BIDI_PROPS(), c);\n+    return (int32_t)ubidi_getPairedBracketType(c);\n }\n \n static int32_t biDiGetMaxValue(const IntProperty &/*prop*/, UProperty which) {\n-    return ubidi_getMaxValue(GET_BIDI_PROPS(), which);\n+    return ubidi_getMaxValue(which);\n }\n \n #if UCONFIG_NO_NORMALIZATION\n@@ -351,11 +349,11 @@ static int32_t getGeneralCategory(const IntProperty &/*prop*/, UChar32 c, UPrope\n }\n \n static int32_t getJoiningGroup(const IntProperty &/*prop*/, UChar32 c, UProperty /*which*/) {\n-    return ubidi_getJoiningGroup(GET_BIDI_PROPS(), c);\n+    return ubidi_getJoiningGroup(c);\n }\n \n static int32_t getJoiningType(const IntProperty &/*prop*/, UChar32 c, UProperty /*which*/) {\n-    return ubidi_getJoiningType(GET_BIDI_PROPS(), c);\n+    return ubidi_getJoiningType(c);\n }\n \n static int32_t getNumericType(const IntProperty &/*prop*/, UChar32 c, UProperty /*which*/) {"
        },
        {
            "sha": "c3f3ef9e2078f0b535e01b73ab950d25114ff7b9",
            "filename": "deps/icu-small/source/common/ushape.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fushape.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fushape.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fushape.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -342,18 +342,16 @@ static void\n _shapeToArabicDigitsWithContext(UChar *s, int32_t length,\n                                 UChar digitBase,\n                                 UBool isLogical, UBool lastStrongWasAL) {\n-    const UBiDiProps *bdp;\n     int32_t i;\n     UChar c;\n \n-    bdp=ubidi_getSingleton();\n     digitBase-=0x30;\n \n     /* the iteration direction depends on the type of input */\n     if(isLogical) {\n         for(i=0; i<length; ++i) {\n             c=s[i];\n-            switch(ubidi_getClass(bdp, c)) {\n+            switch(ubidi_getClass(c)) {\n             case U_LEFT_TO_RIGHT: /* L */\n             case U_RIGHT_TO_LEFT: /* R */\n                 lastStrongWasAL=FALSE;\n@@ -373,7 +371,7 @@ _shapeToArabicDigitsWithContext(UChar *s, int32_t length,\n     } else {\n         for(i=length; i>0; /* pre-decrement in the body */) {\n             c=s[--i];\n-            switch(ubidi_getClass(bdp, c)) {\n+            switch(ubidi_getClass(c)) {\n             case U_LEFT_TO_RIGHT: /* L */\n             case U_RIGHT_TO_LEFT: /* R */\n                 lastStrongWasAL=FALSE;"
        },
        {
            "sha": "54a77172fe1b098b780f1421dfec643d74992410",
            "filename": "deps/icu-small/source/common/usprep.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 5,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fusprep.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fusprep.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fusprep.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -347,10 +347,6 @@ usprep_getProfile(const char* path,\n         newProfile->doNFKC = (UBool)((newProfile->indexes[_SPREP_OPTIONS] & _SPREP_NORMALIZATION_ON) > 0);\n         newProfile->checkBiDi = (UBool)((newProfile->indexes[_SPREP_OPTIONS] & _SPREP_CHECK_BIDI_ON) > 0);\n \n-        if(newProfile->checkBiDi) {\n-            newProfile->bdp = ubidi_getSingleton();\n-        }\n-\n         LocalMemory<UStringPrepKey> key;\n         LocalMemory<char> keyName;\n         LocalMemory<char> keyPath;\n@@ -735,7 +731,7 @@ usprep_prepare(   const UStringPrepProfile* profile,\n         }\n \n         if(profile->checkBiDi) {\n-            direction = ubidi_getClass(profile->bdp, ch);\n+            direction = ubidi_getClass(ch);\n             if(firstCharDir == U_CHAR_DIRECTION_COUNT){\n                 firstCharDir = direction;\n             }"
        },
        {
            "sha": "0372824f21f61596ec743acc5ced1c1fae3be651",
            "filename": "deps/icu-small/source/common/ustr_wcs.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fustr_wcs.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fustr_wcs.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fustr_wcs.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -342,7 +342,7 @@ _strFromWCS( UChar   *dest,\n         pSrcLimit = src + srcLength;\n \n         for(;;){\n-            register int32_t nulLen = 0;\n+            int32_t nulLen = 0;\n \n             /* find nulls in the string */\n             while(nulLen<srcLength && pSrc[nulLen++]!=0){"
        },
        {
            "sha": "978bd3b7b8618e1f8030b3fadef01cfd62568d17",
            "filename": "deps/icu-small/source/common/ustrcase.cpp",
            "status": "modified",
            "additions": 228,
            "deletions": 77,
            "changes": 305,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fustrcase.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Fustrcase.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fustrcase.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -52,16 +52,8 @@ int32_t checkOverflowAndEditsError(int32_t destIndex, int32_t destCapacity,\n     return destIndex;\n }\n \n-}  // namespace\n-\n-U_NAMESPACE_END\n-\n-U_NAMESPACE_USE\n-\n-/* string casing ------------------------------------------------------------ */\n-\n /* Appends a full case mapping result, see UCASE_MAX_STRING_LENGTH. */\n-static inline int32_t\n+inline int32_t\n appendResult(UChar *dest, int32_t destIndex, int32_t destCapacity,\n              int32_t result, const UChar *s,\n              int32_t cpLength, uint32_t options, icu::Edits *edits) {\n@@ -134,7 +126,7 @@ appendResult(UChar *dest, int32_t destIndex, int32_t destCapacity,\n     return destIndex;\n }\n \n-static inline int32_t\n+inline int32_t\n appendUChar(UChar *dest, int32_t destIndex, int32_t destCapacity, UChar c) {\n     if(destIndex<destCapacity) {\n         dest[destIndex]=c;\n@@ -144,28 +136,34 @@ appendUChar(UChar *dest, int32_t destIndex, int32_t destCapacity, UChar c) {\n     return destIndex+1;\n }\n \n-static inline int32_t\n+int32_t\n+appendNonEmptyUnchanged(UChar *dest, int32_t destIndex, int32_t destCapacity,\n+                        const UChar *s, int32_t length, uint32_t options, icu::Edits *edits) {\n+    if(edits!=NULL) {\n+        edits->addUnchanged(length);\n+    }\n+    if(options & U_OMIT_UNCHANGED_TEXT) {\n+        return destIndex;\n+    }\n+    if(length>(INT32_MAX-destIndex)) {\n+        return -1;  // integer overflow\n+    }\n+    if((destIndex+length)<=destCapacity) {\n+        u_memcpy(dest+destIndex, s, length);\n+    }\n+    return destIndex + length;\n+}\n+\n+inline int32_t\n appendUnchanged(UChar *dest, int32_t destIndex, int32_t destCapacity,\n                 const UChar *s, int32_t length, uint32_t options, icu::Edits *edits) {\n-    if(length>0) {\n-        if(edits!=NULL) {\n-            edits->addUnchanged(length);\n-        }\n-        if(options & U_OMIT_UNCHANGED_TEXT) {\n-            return destIndex;\n-        }\n-        if(length>(INT32_MAX-destIndex)) {\n-            return -1;  // integer overflow\n-        }\n-        if((destIndex+length)<=destCapacity) {\n-            u_memcpy(dest+destIndex, s, length);\n-        }\n-        destIndex+=length;\n+    if (length <= 0) {\n+        return destIndex;\n     }\n-    return destIndex;\n+    return appendNonEmptyUnchanged(dest, destIndex, destCapacity, s, length, options, edits);\n }\n \n-static UChar32 U_CALLCONV\n+UChar32 U_CALLCONV\n utf16_caseContextIterator(void *context, int8_t dir) {\n     UCaseContext *csc=(UCaseContext *)context;\n     UChar32 c;\n@@ -197,39 +195,205 @@ utf16_caseContextIterator(void *context, int8_t dir) {\n     return U_SENTINEL;\n }\n \n-/*\n- * Case-maps [srcStart..srcLimit[ but takes\n- * context [0..srcLength[ into account.\n+/**\n+ * caseLocale >= 0: Lowercases [srcStart..srcLimit[ but takes context [0..srcLength[ into account.\n+ * caseLocale < 0: Case-folds [srcStart..srcLimit[.\n  */\n-static int32_t\n-_caseMap(int32_t caseLocale, uint32_t options, UCaseMapFull *map,\n-         UChar *dest, int32_t destCapacity,\n-         const UChar *src, UCaseContext *csc,\n-         int32_t srcStart, int32_t srcLimit,\n-         icu::Edits *edits,\n-         UErrorCode &errorCode) {\n-    /* case mapping loop */\n-    int32_t srcIndex=srcStart;\n-    int32_t destIndex=0;\n-    while(srcIndex<srcLimit) {\n-        int32_t cpStart;\n-        csc->cpStart=cpStart=srcIndex;\n+int32_t toLower(int32_t caseLocale, uint32_t options,\n+                UChar *dest, int32_t destCapacity,\n+                const UChar *src, UCaseContext *csc, int32_t srcStart, int32_t srcLimit,\n+                icu::Edits *edits, UErrorCode &errorCode) {\n+    const int8_t *latinToLower;\n+    if (caseLocale == UCASE_LOC_ROOT ||\n+            (caseLocale >= 0 ?\n+                !(caseLocale == UCASE_LOC_TURKISH || caseLocale == UCASE_LOC_LITHUANIAN) :\n+                (options & _FOLD_CASE_OPTIONS_MASK) == U_FOLD_CASE_DEFAULT)) {\n+        latinToLower = LatinCase::TO_LOWER_NORMAL;\n+    } else {\n+        latinToLower = LatinCase::TO_LOWER_TR_LT;\n+    }\n+    const UTrie2 *trie = ucase_getTrie();\n+    int32_t destIndex = 0;\n+    int32_t prev = srcStart;\n+    int32_t srcIndex = srcStart;\n+    for (;;) {\n+        // fast path for simple cases\n+        UChar lead;\n+        while (srcIndex < srcLimit) {\n+            lead = src[srcIndex];\n+            int32_t delta;\n+            if (lead < LatinCase::LONG_S) {\n+                int8_t d = latinToLower[lead];\n+                if (d == LatinCase::EXC) { break; }\n+                ++srcIndex;\n+                if (d == 0) { continue; }\n+                delta = d;\n+            } else if (lead >= 0xd800) {\n+                break;  // surrogate or higher\n+            } else {\n+                uint16_t props = UTRIE2_GET16_FROM_U16_SINGLE_LEAD(trie, lead);\n+                if (UCASE_HAS_EXCEPTION(props)) { break; }\n+                ++srcIndex;\n+                if (!UCASE_IS_UPPER_OR_TITLE(props) || (delta = UCASE_GET_DELTA(props)) == 0) {\n+                    continue;\n+                }\n+            }\n+            lead += delta;\n+            destIndex = appendUnchanged(dest, destIndex, destCapacity,\n+                                        src + prev, srcIndex - 1 - prev, options, edits);\n+            if (destIndex >= 0) {\n+                destIndex = appendUChar(dest, destIndex, destCapacity, lead);\n+                if (edits != nullptr) {\n+                    edits->addReplace(1, 1);\n+                }\n+            }\n+            if (destIndex < 0) {\n+                errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n+                return 0;\n+            }\n+            prev = srcIndex;\n+        }\n+        if (srcIndex >= srcLimit) {\n+            break;\n+        }\n+        // slow path\n+        int32_t cpStart = srcIndex++;\n+        UChar trail;\n         UChar32 c;\n-        U16_NEXT(src, srcIndex, srcLimit, c);\n-        csc->cpLimit=srcIndex;\n+        if (U16_IS_LEAD(lead) && srcIndex < srcLimit && U16_IS_TRAIL(trail = src[srcIndex])) {\n+            c = U16_GET_SUPPLEMENTARY(lead, trail);\n+            ++srcIndex;\n+        } else {\n+            c = lead;\n+        }\n         const UChar *s;\n-        c=map(c, utf16_caseContextIterator, csc, &s, caseLocale);\n-        destIndex = appendResult(dest, destIndex, destCapacity, c, s,\n-                                 srcIndex - cpStart, options, edits);\n-        if (destIndex < 0) {\n-            errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n-            return 0;\n+        if (caseLocale >= 0) {\n+            csc->cpStart = cpStart;\n+            csc->cpLimit = srcIndex;\n+            c = ucase_toFullLower(c, utf16_caseContextIterator, csc, &s, caseLocale);\n+        } else {\n+            c = ucase_toFullFolding(c, &s, options);\n         }\n+        if (c >= 0) {\n+            destIndex = appendUnchanged(dest, destIndex, destCapacity,\n+                                        src + prev, cpStart - prev, options, edits);\n+            if (destIndex >= 0) {\n+                destIndex = appendResult(dest, destIndex, destCapacity, c, s,\n+                                         srcIndex - cpStart, options, edits);\n+            }\n+            if (destIndex < 0) {\n+                errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n+                return 0;\n+            }\n+            prev = srcIndex;\n+        }\n+    }\n+    destIndex = appendUnchanged(dest, destIndex, destCapacity,\n+                                src + prev, srcIndex - prev, options, edits);\n+    if (destIndex < 0) {\n+        errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n+        return 0;\n     }\n+    return destIndex;\n+}\n \n+int32_t toUpper(int32_t caseLocale, uint32_t options,\n+                UChar *dest, int32_t destCapacity,\n+                const UChar *src, UCaseContext *csc, int32_t srcLength,\n+                icu::Edits *edits, UErrorCode &errorCode) {\n+    const int8_t *latinToUpper;\n+    if (caseLocale == UCASE_LOC_TURKISH) {\n+        latinToUpper = LatinCase::TO_UPPER_TR;\n+    } else {\n+        latinToUpper = LatinCase::TO_UPPER_NORMAL;\n+    }\n+    const UTrie2 *trie = ucase_getTrie();\n+    int32_t destIndex = 0;\n+    int32_t prev = 0;\n+    int32_t srcIndex = 0;\n+    for (;;) {\n+        // fast path for simple cases\n+        UChar lead;\n+        while (srcIndex < srcLength) {\n+            lead = src[srcIndex];\n+            int32_t delta;\n+            if (lead < LatinCase::LONG_S) {\n+                int8_t d = latinToUpper[lead];\n+                if (d == LatinCase::EXC) { break; }\n+                ++srcIndex;\n+                if (d == 0) { continue; }\n+                delta = d;\n+            } else if (lead >= 0xd800) {\n+                break;  // surrogate or higher\n+            } else {\n+                uint16_t props = UTRIE2_GET16_FROM_U16_SINGLE_LEAD(trie, lead);\n+                if (UCASE_HAS_EXCEPTION(props)) { break; }\n+                ++srcIndex;\n+                if (UCASE_GET_TYPE(props) != UCASE_LOWER || (delta = UCASE_GET_DELTA(props)) == 0) {\n+                    continue;\n+                }\n+            }\n+            lead += delta;\n+            destIndex = appendUnchanged(dest, destIndex, destCapacity,\n+                                        src + prev, srcIndex - 1 - prev, options, edits);\n+            if (destIndex >= 0) {\n+                destIndex = appendUChar(dest, destIndex, destCapacity, lead);\n+                if (edits != nullptr) {\n+                    edits->addReplace(1, 1);\n+                }\n+            }\n+            if (destIndex < 0) {\n+                errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n+                return 0;\n+            }\n+            prev = srcIndex;\n+        }\n+        if (srcIndex >= srcLength) {\n+            break;\n+        }\n+        // slow path\n+        int32_t cpStart;\n+        csc->cpStart = cpStart = srcIndex++;\n+        UChar trail;\n+        UChar32 c;\n+        if (U16_IS_LEAD(lead) && srcIndex < srcLength && U16_IS_TRAIL(trail = src[srcIndex])) {\n+            c = U16_GET_SUPPLEMENTARY(lead, trail);\n+            ++srcIndex;\n+        } else {\n+            c = lead;\n+        }\n+        csc->cpLimit = srcIndex;\n+        const UChar *s;\n+        c = ucase_toFullUpper(c, utf16_caseContextIterator, csc, &s, caseLocale);\n+        if (c >= 0) {\n+            destIndex = appendUnchanged(dest, destIndex, destCapacity,\n+                                        src + prev, cpStart - prev, options, edits);\n+            if (destIndex >= 0) {\n+                destIndex = appendResult(dest, destIndex, destCapacity, c, s,\n+                                         srcIndex - cpStart, options, edits);\n+            }\n+            if (destIndex < 0) {\n+                errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n+                return 0;\n+            }\n+            prev = srcIndex;\n+        }\n+    }\n+    destIndex = appendUnchanged(dest, destIndex, destCapacity,\n+                                src + prev, srcIndex - prev, options, edits);\n+    if (destIndex < 0) {\n+        errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n+        return 0;\n+    }\n     return destIndex;\n }\n \n+}  // namespace\n+\n+U_NAMESPACE_END\n+\n+U_NAMESPACE_USE\n+\n #if !UCONFIG_NO_BREAK_ITERATION\n \n U_CFUNC int32_t U_CALLCONV\n@@ -344,11 +508,10 @@ ustrcase_internalToTitle(int32_t caseLocale, uint32_t options, BreakIterator *it\n                     if((options&U_TITLECASE_NO_LOWERCASE)==0) {\n                         /* Normal operation: Lowercase the rest of the word. */\n                         destIndex+=\n-                            _caseMap(\n-                                caseLocale, options, ucase_toFullLower,\n+                            toLower(\n+                                caseLocale, options,\n                                 dest+destIndex, destCapacity-destIndex,\n-                                src, &csc,\n-                                titleLimit, index,\n+                                src, &csc, titleLimit, index,\n                                 edits, errorCode);\n                         if(errorCode==U_BUFFER_OVERFLOW_ERROR) {\n                             errorCode=U_ZERO_ERROR;\n@@ -1013,8 +1176,8 @@ ustrcase_internalToLower(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_IT\n     UCaseContext csc=UCASECONTEXT_INITIALIZER;\n     csc.p=(void *)src;\n     csc.limit=srcLength;\n-    int32_t destIndex = _caseMap(\n-        caseLocale, options, ucase_toFullLower,\n+    int32_t destIndex = toLower(\n+        caseLocale, options,\n         dest, destCapacity,\n         src, &csc, 0, srcLength,\n         edits, errorCode);\n@@ -1035,10 +1198,10 @@ ustrcase_internalToUpper(int32_t caseLocale, uint32_t options, UCASEMAP_BREAK_IT\n         UCaseContext csc=UCASECONTEXT_INITIALIZER;\n         csc.p=(void *)src;\n         csc.limit=srcLength;\n-        destIndex = _caseMap(\n-            caseLocale, options, ucase_toFullUpper,\n+        destIndex = toUpper(\n+            caseLocale, options,\n             dest, destCapacity,\n-            src, &csc, 0, srcLength,\n+            src, &csc, srcLength,\n             edits, errorCode);\n     }\n     return checkOverflowAndEditsError(destIndex, destCapacity, edits, errorCode);\n@@ -1050,23 +1213,11 @@ ustrcase_internalFold(int32_t /* caseLocale */, uint32_t options, UCASEMAP_BREAK\n                       const UChar *src, int32_t srcLength,\n                       icu::Edits *edits,\n                       UErrorCode &errorCode) {\n-    /* case mapping loop */\n-    int32_t srcIndex = 0;\n-    int32_t destIndex = 0;\n-    while (srcIndex < srcLength) {\n-        int32_t cpStart = srcIndex;\n-        UChar32 c;\n-        U16_NEXT(src, srcIndex, srcLength, c);\n-        const UChar *s;\n-        c = ucase_toFullFolding(c, &s, options);\n-        destIndex = appendResult(dest, destIndex, destCapacity, c, s,\n-                                 srcIndex - cpStart, options, edits);\n-        if (destIndex < 0) {\n-            errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n-            return 0;\n-        }\n-    }\n-\n+    int32_t destIndex = toLower(\n+        -1, options,\n+        dest, destCapacity,\n+        src, nullptr, 0, srcLength,\n+        edits, errorCode);\n     return checkOverflowAndEditsError(destIndex, destCapacity, edits, errorCode);\n }\n "
        },
        {
            "sha": "9dd241a12bfa16788e4a6aeb06488c4df9a12a13",
            "filename": "deps/icu-small/source/common/utf_impl.cpp",
            "status": "modified",
            "additions": 42,
            "deletions": 45,
            "changes": 87,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Futf_impl.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Futf_impl.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futf_impl.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -238,33 +238,45 @@ utf8_prevCharSafeBody(const uint8_t *s, int32_t start, int32_t *pi, UChar32 c, U\n     int32_t i=*pi;\n     if(U8_IS_TRAIL(c) && i>start) {\n         uint8_t b1=s[--i];\n-        if(0xc2<=b1 && b1<0xe0) {\n-            *pi=i;\n-            return ((b1-0xc0)<<6)|(c&0x3f);\n+        if(U8_IS_LEAD(b1)) {\n+            if(b1<0xe0) {\n+                *pi=i;\n+                return ((b1-0xc0)<<6)|(c&0x3f);\n+            } else if(b1<0xf0 ? U8_IS_VALID_LEAD3_AND_T1(b1, c) : U8_IS_VALID_LEAD4_AND_T1(b1, c)) {\n+                // Truncated 3- or 4-byte sequence.\n+                *pi=i;\n+                return errorValue(1, strict);\n+            }\n         } else if(U8_IS_TRAIL(b1) && i>start) {\n             // Extract the value bits from the last trail byte.\n             c&=0x3f;\n             uint8_t b2=s[--i];\n-            if(0xe0<=b2 && b2<0xf0) {\n-                b2&=0xf;\n-                if(strict!=-2) {\n-                    if(U8_IS_VALID_LEAD3_AND_T1(b2, b1)) {\n-                        *pi=i;\n-                        c=(b2<<12)|((b1&0x3f)<<6)|c;\n-                        if(strict<=0 || !U_IS_UNICODE_NONCHAR(c)) {\n-                            return c;\n-                        } else {\n-                            // strict: forbid non-characters like U+fffe\n-                            return errorValue(2, strict);\n+            if(0xe0<=b2 && b2<=0xf4) {\n+                if(b2<0xf0) {\n+                    b2&=0xf;\n+                    if(strict!=-2) {\n+                        if(U8_IS_VALID_LEAD3_AND_T1(b2, b1)) {\n+                            *pi=i;\n+                            c=(b2<<12)|((b1&0x3f)<<6)|c;\n+                            if(strict<=0 || !U_IS_UNICODE_NONCHAR(c)) {\n+                                return c;\n+                            } else {\n+                                // strict: forbid non-characters like U+fffe\n+                                return errorValue(2, strict);\n+                            }\n+                        }\n+                    } else {\n+                        // strict=-2 -> lenient: allow surrogates\n+                        b1-=0x80;\n+                        if((b2>0 || b1>=0x20)) {\n+                            *pi=i;\n+                            return (b2<<12)|(b1<<6)|c;\n                         }\n                     }\n-                } else {\n-                    // strict=-2 -> lenient: allow surrogates\n-                    b1-=0x80;\n-                    if((b2>0 || b1>=0x20)) {\n-                        *pi=i;\n-                        return (b2<<12)|(b1<<6)|c;\n-                    }\n+                } else if(U8_IS_VALID_LEAD4_AND_T1(b2, b1)) {\n+                    // Truncated 4-byte sequence.\n+                    *pi=i;\n+                    return errorValue(2, strict);\n                 }\n             } else if(U8_IS_TRAIL(b2) && i>start) {\n                 uint8_t b3=s[--i];\n@@ -281,16 +293,7 @@ utf8_prevCharSafeBody(const uint8_t *s, int32_t start, int32_t *pi, UChar32 c, U\n                         }\n                     }\n                 }\n-            } else if(0xf0<=b2 && b2<=0xf4 && U8_IS_VALID_LEAD4_AND_T1(b2, b1)) {\n-                // Truncated 4-byte sequence.\n-                *pi=i;\n-                return errorValue(2, strict);\n             }\n-        } else if((0xe0<=b1 && b1<0xf0 && U8_IS_VALID_LEAD3_AND_T1(b1, c)) ||\n-                (0xf0<=b1 && b1<=0xf4 && U8_IS_VALID_LEAD4_AND_T1(b1, c))) {\n-            // Truncated 3- or 4-byte sequence.\n-            *pi=i;\n-            return errorValue(1, strict);\n         }\n     }\n     return errorValue(0, strict);\n@@ -303,29 +306,23 @@ utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i) {\n     uint8_t c=s[i];\n     if(U8_IS_TRAIL(c) && i>start) {\n         uint8_t b1=s[--i];\n-        if(0xc2<=b1 && b1<0xe0) {\n-            return i;\n+        if(U8_IS_LEAD(b1)) {\n+            if(b1<0xe0 ||\n+                    (b1<0xf0 ? U8_IS_VALID_LEAD3_AND_T1(b1, c) : U8_IS_VALID_LEAD4_AND_T1(b1, c))) {\n+                return i;\n+            }\n         } else if(U8_IS_TRAIL(b1) && i>start) {\n             uint8_t b2=s[--i];\n-            if(0xe0<=b2 && b2<0xf0) {\n-                if(U8_IS_VALID_LEAD3_AND_T1(b2, b1)) {\n+            if(0xe0<=b2 && b2<=0xf4) {\n+                if(b2<0xf0 ? U8_IS_VALID_LEAD3_AND_T1(b2, b1) : U8_IS_VALID_LEAD4_AND_T1(b2, b1)) {\n                     return i;\n                 }\n             } else if(U8_IS_TRAIL(b2) && i>start) {\n                 uint8_t b3=s[--i];\n-                if(0xf0<=b3 && b3<=0xf4) {\n-                    if(U8_IS_VALID_LEAD4_AND_T1(b3, b2)) {\n-                        return i;\n-                    }\n+                if(0xf0<=b3 && b3<=0xf4 && U8_IS_VALID_LEAD4_AND_T1(b3, b2)) {\n+                    return i;\n                 }\n-            } else if(0xf0<=b2 && b2<=0xf4 && U8_IS_VALID_LEAD4_AND_T1(b2, b1)) {\n-                // Truncated 4-byte sequence.\n-                return i;\n             }\n-        } else if((0xe0<=b1 && b1<0xf0 && U8_IS_VALID_LEAD3_AND_T1(b1, c)) ||\n-                (0xf0<=b1 && b1<=0xf4 && U8_IS_VALID_LEAD4_AND_T1(b1, c))) {\n-            // Truncated 3- or 4-byte sequence.\n-            return i;\n         }\n     }\n     return orig_i;"
        },
        {
            "sha": "641027a1a3f448ae6e9571ced95131537b470ea6",
            "filename": "deps/icu-small/source/common/utrie.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -556,7 +556,7 @@ struct UNewTrie {\n      * Index values at build-time are 32 bits wide for easier processing.\n      * Bit 31 is set if the data block is used by multiple index values (from utrie_setRange()).\n      */\n-    int32_t index[UTRIE_MAX_INDEX_LENGTH];\n+    int32_t index[UTRIE_MAX_INDEX_LENGTH+UTRIE_SURROGATE_BLOCK_COUNT];\n     uint32_t *data;\n \n     uint32_t leadUnitValue;"
        },
        {
            "sha": "5a23572eb64af20b0b69d2727900c950476856de",
            "filename": "deps/icu-small/source/common/uts46.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Futs46.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Futs46.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futs46.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -1126,7 +1126,6 @@ isASCIIOkBiDi(const char *s, int32_t length) {\n \n UBool\n UTS46::isLabelOkContextJ(const UChar *label, int32_t labelLength) const {\n-    const UBiDiProps *bdp=ubidi_getSingleton();\n     // [IDNA2008-Tables]\n     // 200C..200D  ; CONTEXTJ    # ZERO WIDTH NON-JOINER..ZERO WIDTH JOINER\n     for(int32_t i=0; i<labelLength; ++i) {\n@@ -1148,7 +1147,7 @@ UTS46::isLabelOkContextJ(const UChar *label, int32_t labelLength) const {\n             }\n             // check precontext (Joining_Type:{L,D})(Joining_Type:T)*\n             for(;;) {\n-                UJoiningType type=ubidi_getJoiningType(bdp, c);\n+                UJoiningType type=ubidi_getJoiningType(c);\n                 if(type==U_JT_TRANSPARENT) {\n                     if(j==0) {\n                         return FALSE;\n@@ -1166,7 +1165,7 @@ UTS46::isLabelOkContextJ(const UChar *label, int32_t labelLength) const {\n                     return FALSE;\n                 }\n                 U16_NEXT_UNSAFE(label, j, c);\n-                UJoiningType type=ubidi_getJoiningType(bdp, c);\n+                UJoiningType type=ubidi_getJoiningType(c);\n                 if(type==U_JT_TRANSPARENT) {\n                     // just skip this character\n                 } else if(type==U_JT_RIGHT_JOINING || type==U_JT_DUAL_JOINING) {"
        },
        {
            "sha": "5d6a0504ba682a32461ff20626e82fc2a87f0dd1",
            "filename": "deps/icu-small/source/common/utypes.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Futypes.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fcommon%2Futypes.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futypes.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -125,7 +125,8 @@ _uFmtErrorName[U_FMT_PARSE_ERROR_LIMIT - U_FMT_PARSE_ERROR_START] = {\n     \"U_UNDEFINED_KEYWORD\",\n     \"U_DEFAULT_KEYWORD_MISSING\",\n     \"U_DECIMAL_NUMBER_SYNTAX_ERROR\",\n-    \"U_FORMAT_INEXACT_ERROR\"\n+    \"U_FORMAT_INEXACT_ERROR\",\n+    \"U_NUMBER_ARG_OUTOFBOUNDS_ERROR\"\n };\n \n static const char * const"
        },
        {
            "sha": "e9c24d8d1a78822c99efda00d11bed8a45d9eb24",
            "filename": "deps/icu-small/source/data/in/icudt61l.dat",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fdata%2Fin%2Ficudt61l.dat",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fdata%2Fin%2Ficudt61l.dat",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fdata%2Fin%2Ficudt61l.dat?ref=64211405dab824a570e52d000891c49415cc42b8",
            "previous_filename": "deps/icu-small/source/data/in/icudt60l.dat"
        },
        {
            "sha": "f4a082c5b20e5e40d5a6642649425518a30d6028",
            "filename": "deps/icu-small/source/i18n/alphaindex.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 9,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Falphaindex.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Falphaindex.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Falphaindex.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -725,7 +725,7 @@ void AlphabeticIndex::addIndexExemplars(const Locale &locale, UErrorCode &status\n     }\n \n     // question: should we add auxiliary exemplars?\n-    if (exemplars.containsSome(0x61, 0x7A) /* a-z */ || exemplars.size() == 0) {\n+    if (exemplars.containsSome(0x61, 0x7A) /* a-z */ || exemplars.isEmpty()) {\n         exemplars.add(0x61, 0x7A);\n     }\n     if (exemplars.containsSome(0xAC00, 0xD7A3)) {  // Hangul syllables\n@@ -740,14 +740,9 @@ void AlphabeticIndex::addIndexExemplars(const Locale &locale, UErrorCode &status\n         // cut down to small list\n         // make use of the fact that Ethiopic is allocated in 8's, where\n         // the base is 0 mod 8.\n-        UnicodeSet ethiopic(\n-            UNICODE_STRING_SIMPLE(\"[[:Block=Ethiopic:]&[:Script=Ethiopic:]]\"), status);\n-        UnicodeSetIterator it(ethiopic);\n-        while (it.next() && !it.isString()) {\n-            if ((it.getCodepoint() & 0x7) != 0) {\n-                exemplars.remove(it.getCodepoint());\n-            }\n-        }\n+        UnicodeSet ethiopic(UnicodeString(u\"[ሀለሐመሠረሰሸቀቈቐቘበቨተቸኀኈነኘአከኰኸዀወዐዘዠየደዸጀገጐጘጠጨጰጸፀፈፐፘ]\"), status);\n+        ethiopic.retainAll(exemplars);\n+        exemplars.remove(u'ሀ', 0x137F).addAll(ethiopic);\n     }\n \n     // Upper-case any that aren't already so."
        },
        {
            "sha": "61757cb250f77de5d224da5ca406732dbd6e4c32",
            "filename": "deps/icu-small/source/i18n/calendar.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fcalendar.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fcalendar.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fcalendar.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -3223,14 +3223,14 @@ int32_t Calendar::handleComputeJulianDay(UCalendarDateFields bestField)  {\n         bestField == UCAL_DAY_OF_WEEK_IN_MONTH);\n     int32_t year;\n \n-    if (bestField == UCAL_WEEK_OF_YEAR) {\n-        year = internalGet(UCAL_YEAR_WOY, handleGetExtendedYear());\n-        internalSet(UCAL_EXTENDED_YEAR, year);\n+    if (bestField == UCAL_WEEK_OF_YEAR && newerField(UCAL_YEAR_WOY, UCAL_YEAR) == UCAL_YEAR_WOY) {\n+        year = internalGet(UCAL_YEAR_WOY);\n     } else {\n         year = handleGetExtendedYear();\n-        internalSet(UCAL_EXTENDED_YEAR, year);\n     }\n \n+    internalSet(UCAL_EXTENDED_YEAR, year);\n+\n #if defined (U_DEBUG_CAL)\n     fprintf(stderr, \"%s:%d: bestField= %s - y=%d\\n\", __FILE__, __LINE__, fldName(bestField), year);\n #endif"
        },
        {
            "sha": "12e05b4482fab2d45352f20cbe57401feafb0038",
            "filename": "deps/icu-small/source/i18n/collationiterator.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fcollationiterator.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fcollationiterator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fcollationiterator.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -34,12 +34,12 @@ class UVector32;\n // Export an explicit template instantiation of the MaybeStackArray that\n //    is used as a data member of CEBuffer.\n //\n-//    MSVC requires this, even though it should not be necessary.\n-//    No direct access to the MaybeStackArray leaks out of the i18n library.\n+//    When building DLLs for Windows this is required even though\n+//    no direct access to the MaybeStackArray leaks out of the i18n library.\n //\n // See digitlst.h, pluralaffix.h, datefmt.h, and others for similar examples.\n //\n-#if defined (_MSC_VER)\n+#if U_PF_WINDOWS <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN\n template class U_I18N_API MaybeStackArray<int64_t, CEBUFFER_INITIAL_CAPACITY>;\n #endif\n "
        },
        {
            "sha": "680c3120a1e0f9c64be3969a9db9f480b424f887",
            "filename": "deps/icu-small/source/i18n/dcfmtsym.cpp",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdcfmtsym.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdcfmtsym.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdcfmtsym.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -38,6 +38,7 @@\n #include \"uresimp.h\"\n #include \"ureslocs.h\"\n #include \"charstr.h\"\n+#include \"uassert.h\"\n \n // *****************************************************************************\n // class DecimalFormatSymbols\n@@ -165,6 +166,7 @@ DecimalFormatSymbols::operator=(const DecimalFormatSymbols& rhs)\n         uprv_strcpy(actualLocale, rhs.actualLocale);\n         fIsCustomCurrencySymbol = rhs.fIsCustomCurrencySymbol;\n         fIsCustomIntlCurrencySymbol = rhs.fIsCustomIntlCurrencySymbol;\n+        fCodePointZero = rhs.fCodePointZero;\n     }\n     return *this;\n }\n@@ -196,6 +198,7 @@ DecimalFormatSymbols::operator==(const DecimalFormatSymbols& that) const\n             return FALSE;\n         }\n     }\n+    // No need to check fCodePointZero since it is based on fSymbols\n     return locale == that.locale &&\n         uprv_strcmp(validLocale, that.validLocale) == 0 &&\n         uprv_strcmp(actualLocale, that.actualLocale) == 0;\n@@ -433,6 +436,24 @@ DecimalFormatSymbols::initialize(const Locale& loc, UErrorCode& status,\n     // Let the monetary number separators equal the default number separators if necessary.\n     sink.resolveMissingMonetarySeparators(fSymbols);\n \n+    // Resolve codePointZero\n+    UChar32 tempCodePointZero;\n+    for (int32_t i=0; i<=9; i++) {\n+        const UnicodeString& stringDigit = getConstDigitSymbol(i);\n+        if (stringDigit.countChar32() != 1) {\n+            tempCodePointZero = -1;\n+            break;\n+        }\n+        UChar32 cp = stringDigit.char32At(0);\n+        if (i == 0) {\n+            tempCodePointZero = cp;\n+        } else if (cp != tempCodePointZero + i) {\n+            tempCodePointZero = -1;\n+            break;\n+        }\n+    }\n+    fCodePointZero = tempCodePointZero;\n+\n     // Obtain currency data from the currency API.  This is strictly\n     // for backward compatibility; we don't use DecimalFormatSymbols\n     // for currency data anymore.\n@@ -530,6 +551,8 @@ DecimalFormatSymbols::initialize() {\n     fSymbols[kExponentMultiplicationSymbol] = (UChar)0xd7; // 'x' multiplication symbol for exponents\n     fIsCustomCurrencySymbol = FALSE;\n     fIsCustomIntlCurrencySymbol = FALSE;\n+    fCodePointZero = 0x30;\n+    U_ASSERT(fCodePointZero == fSymbols[kZeroDigitSymbol].char32At(0));\n \n }\n "
        },
        {
            "sha": "c19493bdf3bbeea53682f3f042aa07448e10c338",
            "filename": "deps/icu-small/source/i18n/decNumber.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2FdecNumber.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2FdecNumber.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2FdecNumber.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -627,10 +627,12 @@ U_CAPI decNumber * U_EXPORT2 uprv_decNumberFromString(decNumber *dn, const char\n \n       for (; *c=='0' && *(c+1)!='\\0';) c++;  /* strip insignificant zeros  */\n       firstexp=c;                            /* save exponent digit place  */\n+      uInt uexponent = 0;   /* Avoid undefined behavior on signed int overflow */\n       for (; ;c++) {\n         if (*c<'0' || *c>'9') break;         /* not a digit  */\n-        exponent=X10(exponent)+(Int)*c-(Int)'0';\n+        uexponent=X10(uexponent)+(uInt)*c-(uInt)'0';\n         } /* c  */\n+      exponent = (Int)uexponent;\n       /* if not now on a '\\0', *c must not be a digit  */\n       if (*c!='\\0') break;\n "
        },
        {
            "sha": "80a1870f33ef8d0adab62990346f6c6d2910848d",
            "filename": "deps/icu-small/source/i18n/decimalformatpattern.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdecimalformatpattern.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdecimalformatpattern.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdecimalformatpattern.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -50,10 +50,12 @@ static void syntaxError(const UnicodeString& pattern,\n     parseError.preContext[stop-start] = 0;\n \n     //for post-context\n-    start = pos+1;\n-    stop  = ((pos+U_PARSE_CONTEXT_LEN)<=pattern.length()) ? (pos+(U_PARSE_CONTEXT_LEN-1)) :\n-        pattern.length();\n-    pattern.extract(start,stop-start,parseError.postContext,0);\n+    start = pattern.moveIndex32(pos, 1);\n+    stop = pos + U_PARSE_CONTEXT_LEN - 1;\n+    if (stop > pattern.length()) {\n+        stop = pattern.length();\n+    }\n+    pattern.extract(start, stop - start, parseError.postContext, 0);\n     //null terminate the buffer\n     parseError.postContext[stop-start]= 0;\n }"
        },
        {
            "sha": "37760defd708bc9e41090125b409d39fcb2c0e9e",
            "filename": "deps/icu-small/source/i18n/digitlst.cpp",
            "status": "modified",
            "additions": 49,
            "deletions": 1,
            "changes": 50,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdigitlst.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdigitlst.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdigitlst.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -44,12 +44,15 @@\n #include \"digitinterval.h\"\n #include \"ucln_in.h\"\n #include \"umutex.h\"\n+#include \"double-conversion.h\"\n #include <stdlib.h>\n #include <limits.h>\n #include <string.h>\n #include <stdio.h>\n #include <limits>\n \n+using icu::double_conversion::DoubleToStringConverter;\n+\n #if !defined(U_USE_STRTOD_L)\n # if U_PLATFORM_USES_ONLY_WIN32_API\n #   define U_USE_STRTOD_L 1\n@@ -850,8 +853,53 @@ DigitList::set(double source)\n         } else {\n             uprv_strcpy(rep,\"inf\");\n         }\n+    } else if (uprv_isNaN(source)) {\n+        uprv_strcpy(rep, \"NaN\");\n     } else {\n-        sprintf(rep, \"%+1.*e\", MAX_DBL_DIGITS - 1, source);\n+        bool sign;\n+        int32_t length;\n+        int32_t point;\n+        DoubleToStringConverter::DoubleToAscii(\n+            source,\n+            DoubleToStringConverter::DtoaMode::SHORTEST,\n+            0,\n+            rep + 1,\n+            sizeof(rep),\n+            &sign,\n+            &length,\n+            &point\n+        );\n+\n+        // Convert the raw buffer into a string for decNumber\n+        int32_t power = point - length;\n+        if (sign) {\n+            rep[0] = '-';\n+        } else {\n+            rep[0] = '0';\n+        }\n+        length++;\n+        rep[length++] = 'E';\n+        if (power < 0) {\n+            rep[length++] = '-';\n+            power = -power;\n+        } else {\n+            rep[length++] = '+';\n+        }\n+        if (power < 10) {\n+            rep[length++] = power + '0';\n+        } else if (power < 100) {\n+            rep[length++] = (power / 10) + '0';\n+            rep[length++] = (power % 10) + '0';\n+        } else {\n+            U_ASSERT(power < 1000);\n+            rep[length + 2] = (power % 10) + '0';\n+            power /= 10;\n+            rep[length + 1] = (power % 10) + '0';\n+            power /= 10;\n+            rep[length] = power + '0';\n+            length += 3;\n+        }\n+        rep[length++] = 0;\n     }\n     U_ASSERT(uprv_strlen(rep) < sizeof(rep));\n "
        },
        {
            "sha": "07d0b0eb0f8717ef6a38fdeda464e5b166e8fa02",
            "filename": "deps/icu-small/source/i18n/double-conversion-bignum-dtoa.cpp",
            "status": "added",
            "additions": 659,
            "deletions": 0,
            "changes": 659,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum-dtoa.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum-dtoa.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum-dtoa.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,659 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#include <math.h>\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-bignum-dtoa.h\"\n+\n+#include \"double-conversion-bignum.h\"\n+#include \"double-conversion-ieee.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+static int NormalizedExponent(uint64_t significand, int exponent) {\n+  ASSERT(significand != 0);\n+  while ((significand & Double::kHiddenBit) == 0) {\n+    significand = significand << 1;\n+    exponent = exponent - 1;\n+  }\n+  return exponent;\n+}\n+\n+\n+// Forward declarations:\n+// Returns an estimation of k such that 10^(k-1) <= v < 10^k.\n+static int EstimatePower(int exponent);\n+// Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator\n+// and denominator.\n+static void InitialScaledStartValues(uint64_t significand,\n+                                     int exponent,\n+                                     bool lower_boundary_is_closer,\n+                                     int estimated_power,\n+                                     bool need_boundary_deltas,\n+                                     Bignum* numerator,\n+                                     Bignum* denominator,\n+                                     Bignum* delta_minus,\n+                                     Bignum* delta_plus);\n+// Multiplies numerator/denominator so that its values lies in the range 1-10.\n+// Returns decimal_point s.t.\n+//  v = numerator'/denominator' * 10^(decimal_point-1)\n+//     where numerator' and denominator' are the values of numerator and\n+//     denominator after the call to this function.\n+static void FixupMultiply10(int estimated_power, bool is_even,\n+                            int* decimal_point,\n+                            Bignum* numerator, Bignum* denominator,\n+                            Bignum* delta_minus, Bignum* delta_plus);\n+// Generates digits from the left to the right and stops when the generated\n+// digits yield the shortest decimal representation of v.\n+static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,\n+                                   Bignum* delta_minus, Bignum* delta_plus,\n+                                   bool is_even,\n+                                   Vector<char> buffer, int* length);\n+// Generates 'requested_digits' after the decimal point.\n+static void BignumToFixed(int requested_digits, int* decimal_point,\n+                          Bignum* numerator, Bignum* denominator,\n+                          Vector<char>(buffer), int* length);\n+// Generates 'count' digits of numerator/denominator.\n+// Once 'count' digits have been produced rounds the result depending on the\n+// remainder (remainders of exactly .5 round upwards). Might update the\n+// decimal_point when rounding up (for example for 0.9999).\n+static void GenerateCountedDigits(int count, int* decimal_point,\n+                                  Bignum* numerator, Bignum* denominator,\n+                                  Vector<char>(buffer), int* length);\n+\n+\n+void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,\n+                Vector<char> buffer, int* length, int* decimal_point) {\n+  ASSERT(v > 0);\n+  ASSERT(!Double(v).IsSpecial());\n+  uint64_t significand;\n+  int exponent;\n+  bool lower_boundary_is_closer;\n+  if (mode == BIGNUM_DTOA_SHORTEST_SINGLE) {\n+    float f = static_cast<float>(v);\n+    ASSERT(f == v);\n+    significand = Single(f).Significand();\n+    exponent = Single(f).Exponent();\n+    lower_boundary_is_closer = Single(f).LowerBoundaryIsCloser();\n+  } else {\n+    significand = Double(v).Significand();\n+    exponent = Double(v).Exponent();\n+    lower_boundary_is_closer = Double(v).LowerBoundaryIsCloser();\n+  }\n+  bool need_boundary_deltas =\n+      (mode == BIGNUM_DTOA_SHORTEST || mode == BIGNUM_DTOA_SHORTEST_SINGLE);\n+\n+  bool is_even = (significand & 1) == 0;\n+  int normalized_exponent = NormalizedExponent(significand, exponent);\n+  // estimated_power might be too low by 1.\n+  int estimated_power = EstimatePower(normalized_exponent);\n+\n+  // Shortcut for Fixed.\n+  // The requested digits correspond to the digits after the point. If the\n+  // number is much too small, then there is no need in trying to get any\n+  // digits.\n+  if (mode == BIGNUM_DTOA_FIXED && -estimated_power - 1 > requested_digits) {\n+    buffer[0] = '\\0';\n+    *length = 0;\n+    // Set decimal-point to -requested_digits. This is what Gay does.\n+    // Note that it should not have any effect anyways since the string is\n+    // empty.\n+    *decimal_point = -requested_digits;\n+    return;\n+  }\n+\n+  Bignum numerator;\n+  Bignum denominator;\n+  Bignum delta_minus;\n+  Bignum delta_plus;\n+  // Make sure the bignum can grow large enough. The smallest double equals\n+  // 4e-324. In this case the denominator needs fewer than 324*4 binary digits.\n+  // The maximum double is 1.7976931348623157e308 which needs fewer than\n+  // 308*4 binary digits.\n+  ASSERT(Bignum::kMaxSignificantBits >= 324*4);\n+  InitialScaledStartValues(significand, exponent, lower_boundary_is_closer,\n+                           estimated_power, need_boundary_deltas,\n+                           &numerator, &denominator,\n+                           &delta_minus, &delta_plus);\n+  // We now have v = (numerator / denominator) * 10^estimated_power.\n+  FixupMultiply10(estimated_power, is_even, decimal_point,\n+                  &numerator, &denominator,\n+                  &delta_minus, &delta_plus);\n+  // We now have v = (numerator / denominator) * 10^(decimal_point-1), and\n+  //  1 <= (numerator + delta_plus) / denominator < 10\n+  switch (mode) {\n+    case BIGNUM_DTOA_SHORTEST:\n+    case BIGNUM_DTOA_SHORTEST_SINGLE:\n+      GenerateShortestDigits(&numerator, &denominator,\n+                             &delta_minus, &delta_plus,\n+                             is_even, buffer, length);\n+      break;\n+    case BIGNUM_DTOA_FIXED:\n+      BignumToFixed(requested_digits, decimal_point,\n+                    &numerator, &denominator,\n+                    buffer, length);\n+      break;\n+    case BIGNUM_DTOA_PRECISION:\n+      GenerateCountedDigits(requested_digits, decimal_point,\n+                            &numerator, &denominator,\n+                            buffer, length);\n+      break;\n+    default:\n+      UNREACHABLE();\n+  }\n+  buffer[*length] = '\\0';\n+}\n+\n+\n+// The procedure starts generating digits from the left to the right and stops\n+// when the generated digits yield the shortest decimal representation of v. A\n+// decimal representation of v is a number lying closer to v than to any other\n+// double, so it converts to v when read.\n+//\n+// This is true if d, the decimal representation, is between m- and m+, the\n+// upper and lower boundaries. d must be strictly between them if !is_even.\n+//           m- := (numerator - delta_minus) / denominator\n+//           m+ := (numerator + delta_plus) / denominator\n+//\n+// Precondition: 0 <= (numerator+delta_plus) / denominator < 10.\n+//   If 1 <= (numerator+delta_plus) / denominator < 10 then no leading 0 digit\n+//   will be produced. This should be the standard precondition.\n+static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,\n+                                   Bignum* delta_minus, Bignum* delta_plus,\n+                                   bool is_even,\n+                                   Vector<char> buffer, int* length) {\n+  // Small optimization: if delta_minus and delta_plus are the same just reuse\n+  // one of the two bignums.\n+  if (Bignum::Equal(*delta_minus, *delta_plus)) {\n+    delta_plus = delta_minus;\n+  }\n+  *length = 0;\n+  for (;;) {\n+    uint16_t digit;\n+    digit = numerator->DivideModuloIntBignum(*denominator);\n+    ASSERT(digit <= 9);  // digit is a uint16_t and therefore always positive.\n+    // digit = numerator / denominator (integer division).\n+    // numerator = numerator % denominator.\n+    buffer[(*length)++] = static_cast<char>(digit + '0');\n+\n+    // Can we stop already?\n+    // If the remainder of the division is less than the distance to the lower\n+    // boundary we can stop. In this case we simply round down (discarding the\n+    // remainder).\n+    // Similarly we test if we can round up (using the upper boundary).\n+    bool in_delta_room_minus;\n+    bool in_delta_room_plus;\n+    if (is_even) {\n+      in_delta_room_minus = Bignum::LessEqual(*numerator, *delta_minus);\n+    } else {\n+      in_delta_room_minus = Bignum::Less(*numerator, *delta_minus);\n+    }\n+    if (is_even) {\n+      in_delta_room_plus =\n+          Bignum::PlusCompare(*numerator, *delta_plus, *denominator) >= 0;\n+    } else {\n+      in_delta_room_plus =\n+          Bignum::PlusCompare(*numerator, *delta_plus, *denominator) > 0;\n+    }\n+    if (!in_delta_room_minus && !in_delta_room_plus) {\n+      // Prepare for next iteration.\n+      numerator->Times10();\n+      delta_minus->Times10();\n+      // We optimized delta_plus to be equal to delta_minus (if they share the\n+      // same value). So don't multiply delta_plus if they point to the same\n+      // object.\n+      if (delta_minus != delta_plus) {\n+        delta_plus->Times10();\n+      }\n+    } else if (in_delta_room_minus && in_delta_room_plus) {\n+      // Let's see if 2*numerator < denominator.\n+      // If yes, then the next digit would be < 5 and we can round down.\n+      int compare = Bignum::PlusCompare(*numerator, *numerator, *denominator);\n+      if (compare < 0) {\n+        // Remaining digits are less than .5. -> Round down (== do nothing).\n+      } else if (compare > 0) {\n+        // Remaining digits are more than .5 of denominator. -> Round up.\n+        // Note that the last digit could not be a '9' as otherwise the whole\n+        // loop would have stopped earlier.\n+        // We still have an assert here in case the preconditions were not\n+        // satisfied.\n+        ASSERT(buffer[(*length) - 1] != '9');\n+        buffer[(*length) - 1]++;\n+      } else {\n+        // Halfway case.\n+        // TODO(floitsch): need a way to solve half-way cases.\n+        //   For now let's round towards even (since this is what Gay seems to\n+        //   do).\n+\n+        if ((buffer[(*length) - 1] - '0') % 2 == 0) {\n+          // Round down => Do nothing.\n+        } else {\n+          ASSERT(buffer[(*length) - 1] != '9');\n+          buffer[(*length) - 1]++;\n+        }\n+      }\n+      return;\n+    } else if (in_delta_room_minus) {\n+      // Round down (== do nothing).\n+      return;\n+    } else {  // in_delta_room_plus\n+      // Round up.\n+      // Note again that the last digit could not be '9' since this would have\n+      // stopped the loop earlier.\n+      // We still have an ASSERT here, in case the preconditions were not\n+      // satisfied.\n+      ASSERT(buffer[(*length) -1] != '9');\n+      buffer[(*length) - 1]++;\n+      return;\n+    }\n+  }\n+}\n+\n+\n+// Let v = numerator / denominator < 10.\n+// Then we generate 'count' digits of d = x.xxxxx... (without the decimal point)\n+// from left to right. Once 'count' digits have been produced we decide wether\n+// to round up or down. Remainders of exactly .5 round upwards. Numbers such\n+// as 9.999999 propagate a carry all the way, and change the\n+// exponent (decimal_point), when rounding upwards.\n+static void GenerateCountedDigits(int count, int* decimal_point,\n+                                  Bignum* numerator, Bignum* denominator,\n+                                  Vector<char> buffer, int* length) {\n+  ASSERT(count >= 0);\n+  for (int i = 0; i < count - 1; ++i) {\n+    uint16_t digit;\n+    digit = numerator->DivideModuloIntBignum(*denominator);\n+    ASSERT(digit <= 9);  // digit is a uint16_t and therefore always positive.\n+    // digit = numerator / denominator (integer division).\n+    // numerator = numerator % denominator.\n+    buffer[i] = static_cast<char>(digit + '0');\n+    // Prepare for next iteration.\n+    numerator->Times10();\n+  }\n+  // Generate the last digit.\n+  uint16_t digit;\n+  digit = numerator->DivideModuloIntBignum(*denominator);\n+  if (Bignum::PlusCompare(*numerator, *numerator, *denominator) >= 0) {\n+    digit++;\n+  }\n+  ASSERT(digit <= 10);\n+  buffer[count - 1] = static_cast<char>(digit + '0');\n+  // Correct bad digits (in case we had a sequence of '9's). Propagate the\n+  // carry until we hat a non-'9' or til we reach the first digit.\n+  for (int i = count - 1; i > 0; --i) {\n+    if (buffer[i] != '0' + 10) break;\n+    buffer[i] = '0';\n+    buffer[i - 1]++;\n+  }\n+  if (buffer[0] == '0' + 10) {\n+    // Propagate a carry past the top place.\n+    buffer[0] = '1';\n+    (*decimal_point)++;\n+  }\n+  *length = count;\n+}\n+\n+\n+// Generates 'requested_digits' after the decimal point. It might omit\n+// trailing '0's. If the input number is too small then no digits at all are\n+// generated (ex.: 2 fixed digits for 0.00001).\n+//\n+// Input verifies:  1 <= (numerator + delta) / denominator < 10.\n+static void BignumToFixed(int requested_digits, int* decimal_point,\n+                          Bignum* numerator, Bignum* denominator,\n+                          Vector<char>(buffer), int* length) {\n+  // Note that we have to look at more than just the requested_digits, since\n+  // a number could be rounded up. Example: v=0.5 with requested_digits=0.\n+  // Even though the power of v equals 0 we can't just stop here.\n+  if (-(*decimal_point) > requested_digits) {\n+    // The number is definitively too small.\n+    // Ex: 0.001 with requested_digits == 1.\n+    // Set decimal-point to -requested_digits. This is what Gay does.\n+    // Note that it should not have any effect anyways since the string is\n+    // empty.\n+    *decimal_point = -requested_digits;\n+    *length = 0;\n+    return;\n+  } else if (-(*decimal_point) == requested_digits) {\n+    // We only need to verify if the number rounds down or up.\n+    // Ex: 0.04 and 0.06 with requested_digits == 1.\n+    ASSERT(*decimal_point == -requested_digits);\n+    // Initially the fraction lies in range (1, 10]. Multiply the denominator\n+    // by 10 so that we can compare more easily.\n+    denominator->Times10();\n+    if (Bignum::PlusCompare(*numerator, *numerator, *denominator) >= 0) {\n+      // If the fraction is >= 0.5 then we have to include the rounded\n+      // digit.\n+      buffer[0] = '1';\n+      *length = 1;\n+      (*decimal_point)++;\n+    } else {\n+      // Note that we caught most of similar cases earlier.\n+      *length = 0;\n+    }\n+    return;\n+  } else {\n+    // The requested digits correspond to the digits after the point.\n+    // The variable 'needed_digits' includes the digits before the point.\n+    int needed_digits = (*decimal_point) + requested_digits;\n+    GenerateCountedDigits(needed_digits, decimal_point,\n+                          numerator, denominator,\n+                          buffer, length);\n+  }\n+}\n+\n+\n+// Returns an estimation of k such that 10^(k-1) <= v < 10^k where\n+// v = f * 2^exponent and 2^52 <= f < 2^53.\n+// v is hence a normalized double with the given exponent. The output is an\n+// approximation for the exponent of the decimal approimation .digits * 10^k.\n+//\n+// The result might undershoot by 1 in which case 10^k <= v < 10^k+1.\n+// Note: this property holds for v's upper boundary m+ too.\n+//    10^k <= m+ < 10^k+1.\n+//   (see explanation below).\n+//\n+// Examples:\n+//  EstimatePower(0)   => 16\n+//  EstimatePower(-52) => 0\n+//\n+// Note: e >= 0 => EstimatedPower(e) > 0. No similar claim can be made for e<0.\n+static int EstimatePower(int exponent) {\n+  // This function estimates log10 of v where v = f*2^e (with e == exponent).\n+  // Note that 10^floor(log10(v)) <= v, but v <= 10^ceil(log10(v)).\n+  // Note that f is bounded by its container size. Let p = 53 (the double's\n+  // significand size). Then 2^(p-1) <= f < 2^p.\n+  //\n+  // Given that log10(v) == log2(v)/log2(10) and e+(len(f)-1) is quite close\n+  // to log2(v) the function is simplified to (e+(len(f)-1)/log2(10)).\n+  // The computed number undershoots by less than 0.631 (when we compute log3\n+  // and not log10).\n+  //\n+  // Optimization: since we only need an approximated result this computation\n+  // can be performed on 64 bit integers. On x86/x64 architecture the speedup is\n+  // not really measurable, though.\n+  //\n+  // Since we want to avoid overshooting we decrement by 1e10 so that\n+  // floating-point imprecisions don't affect us.\n+  //\n+  // Explanation for v's boundary m+: the computation takes advantage of\n+  // the fact that 2^(p-1) <= f < 2^p. Boundaries still satisfy this requirement\n+  // (even for denormals where the delta can be much more important).\n+\n+  const double k1Log10 = 0.30102999566398114;  // 1/lg(10)\n+\n+  // For doubles len(f) == 53 (don't forget the hidden bit).\n+  const int kSignificandSize = Double::kSignificandSize;\n+  double estimate = ceil((exponent + kSignificandSize - 1) * k1Log10 - 1e-10);\n+  return static_cast<int>(estimate);\n+}\n+\n+\n+// See comments for InitialScaledStartValues.\n+static void InitialScaledStartValuesPositiveExponent(\n+    uint64_t significand, int exponent,\n+    int estimated_power, bool need_boundary_deltas,\n+    Bignum* numerator, Bignum* denominator,\n+    Bignum* delta_minus, Bignum* delta_plus) {\n+  // A positive exponent implies a positive power.\n+  ASSERT(estimated_power >= 0);\n+  // Since the estimated_power is positive we simply multiply the denominator\n+  // by 10^estimated_power.\n+\n+  // numerator = v.\n+  numerator->AssignUInt64(significand);\n+  numerator->ShiftLeft(exponent);\n+  // denominator = 10^estimated_power.\n+  denominator->AssignPowerUInt16(10, estimated_power);\n+\n+  if (need_boundary_deltas) {\n+    // Introduce a common denominator so that the deltas to the boundaries are\n+    // integers.\n+    denominator->ShiftLeft(1);\n+    numerator->ShiftLeft(1);\n+    // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common\n+    // denominator (of 2) delta_plus equals 2^e.\n+    delta_plus->AssignUInt16(1);\n+    delta_plus->ShiftLeft(exponent);\n+    // Same for delta_minus. The adjustments if f == 2^p-1 are done later.\n+    delta_minus->AssignUInt16(1);\n+    delta_minus->ShiftLeft(exponent);\n+  }\n+}\n+\n+\n+// See comments for InitialScaledStartValues\n+static void InitialScaledStartValuesNegativeExponentPositivePower(\n+    uint64_t significand, int exponent,\n+    int estimated_power, bool need_boundary_deltas,\n+    Bignum* numerator, Bignum* denominator,\n+    Bignum* delta_minus, Bignum* delta_plus) {\n+  // v = f * 2^e with e < 0, and with estimated_power >= 0.\n+  // This means that e is close to 0 (have a look at how estimated_power is\n+  // computed).\n+\n+  // numerator = significand\n+  //  since v = significand * 2^exponent this is equivalent to\n+  //  numerator = v * / 2^-exponent\n+  numerator->AssignUInt64(significand);\n+  // denominator = 10^estimated_power * 2^-exponent (with exponent < 0)\n+  denominator->AssignPowerUInt16(10, estimated_power);\n+  denominator->ShiftLeft(-exponent);\n+\n+  if (need_boundary_deltas) {\n+    // Introduce a common denominator so that the deltas to the boundaries are\n+    // integers.\n+    denominator->ShiftLeft(1);\n+    numerator->ShiftLeft(1);\n+    // Let v = f * 2^e, then m+ - v = 1/2 * 2^e; With the common\n+    // denominator (of 2) delta_plus equals 2^e.\n+    // Given that the denominator already includes v's exponent the distance\n+    // to the boundaries is simply 1.\n+    delta_plus->AssignUInt16(1);\n+    // Same for delta_minus. The adjustments if f == 2^p-1 are done later.\n+    delta_minus->AssignUInt16(1);\n+  }\n+}\n+\n+\n+// See comments for InitialScaledStartValues\n+static void InitialScaledStartValuesNegativeExponentNegativePower(\n+    uint64_t significand, int exponent,\n+    int estimated_power, bool need_boundary_deltas,\n+    Bignum* numerator, Bignum* denominator,\n+    Bignum* delta_minus, Bignum* delta_plus) {\n+  // Instead of multiplying the denominator with 10^estimated_power we\n+  // multiply all values (numerator and deltas) by 10^-estimated_power.\n+\n+  // Use numerator as temporary container for power_ten.\n+  Bignum* power_ten = numerator;\n+  power_ten->AssignPowerUInt16(10, -estimated_power);\n+\n+  if (need_boundary_deltas) {\n+    // Since power_ten == numerator we must make a copy of 10^estimated_power\n+    // before we complete the computation of the numerator.\n+    // delta_plus = delta_minus = 10^estimated_power\n+    delta_plus->AssignBignum(*power_ten);\n+    delta_minus->AssignBignum(*power_ten);\n+  }\n+\n+  // numerator = significand * 2 * 10^-estimated_power\n+  //  since v = significand * 2^exponent this is equivalent to\n+  // numerator = v * 10^-estimated_power * 2 * 2^-exponent.\n+  // Remember: numerator has been abused as power_ten. So no need to assign it\n+  //  to itself.\n+  ASSERT(numerator == power_ten);\n+  numerator->MultiplyByUInt64(significand);\n+\n+  // denominator = 2 * 2^-exponent with exponent < 0.\n+  denominator->AssignUInt16(1);\n+  denominator->ShiftLeft(-exponent);\n+\n+  if (need_boundary_deltas) {\n+    // Introduce a common denominator so that the deltas to the boundaries are\n+    // integers.\n+    numerator->ShiftLeft(1);\n+    denominator->ShiftLeft(1);\n+    // With this shift the boundaries have their correct value, since\n+    // delta_plus = 10^-estimated_power, and\n+    // delta_minus = 10^-estimated_power.\n+    // These assignments have been done earlier.\n+    // The adjustments if f == 2^p-1 (lower boundary is closer) are done later.\n+  }\n+}\n+\n+\n+// Let v = significand * 2^exponent.\n+// Computes v / 10^estimated_power exactly, as a ratio of two bignums, numerator\n+// and denominator. The functions GenerateShortestDigits and\n+// GenerateCountedDigits will then convert this ratio to its decimal\n+// representation d, with the required accuracy.\n+// Then d * 10^estimated_power is the representation of v.\n+// (Note: the fraction and the estimated_power might get adjusted before\n+// generating the decimal representation.)\n+//\n+// The initial start values consist of:\n+//  - a scaled numerator: s.t. numerator/denominator == v / 10^estimated_power.\n+//  - a scaled (common) denominator.\n+//  optionally (used by GenerateShortestDigits to decide if it has the shortest\n+//  decimal converting back to v):\n+//  - v - m-: the distance to the lower boundary.\n+//  - m+ - v: the distance to the upper boundary.\n+//\n+// v, m+, m-, and therefore v - m- and m+ - v all share the same denominator.\n+//\n+// Let ep == estimated_power, then the returned values will satisfy:\n+//  v / 10^ep = numerator / denominator.\n+//  v's boundarys m- and m+:\n+//    m- / 10^ep == v / 10^ep - delta_minus / denominator\n+//    m+ / 10^ep == v / 10^ep + delta_plus / denominator\n+//  Or in other words:\n+//    m- == v - delta_minus * 10^ep / denominator;\n+//    m+ == v + delta_plus * 10^ep / denominator;\n+//\n+// Since 10^(k-1) <= v < 10^k    (with k == estimated_power)\n+//  or       10^k <= v < 10^(k+1)\n+//  we then have 0.1 <= numerator/denominator < 1\n+//           or    1 <= numerator/denominator < 10\n+//\n+// It is then easy to kickstart the digit-generation routine.\n+//\n+// The boundary-deltas are only filled if the mode equals BIGNUM_DTOA_SHORTEST\n+// or BIGNUM_DTOA_SHORTEST_SINGLE.\n+\n+static void InitialScaledStartValues(uint64_t significand,\n+                                     int exponent,\n+                                     bool lower_boundary_is_closer,\n+                                     int estimated_power,\n+                                     bool need_boundary_deltas,\n+                                     Bignum* numerator,\n+                                     Bignum* denominator,\n+                                     Bignum* delta_minus,\n+                                     Bignum* delta_plus) {\n+  if (exponent >= 0) {\n+    InitialScaledStartValuesPositiveExponent(\n+        significand, exponent, estimated_power, need_boundary_deltas,\n+        numerator, denominator, delta_minus, delta_plus);\n+  } else if (estimated_power >= 0) {\n+    InitialScaledStartValuesNegativeExponentPositivePower(\n+        significand, exponent, estimated_power, need_boundary_deltas,\n+        numerator, denominator, delta_minus, delta_plus);\n+  } else {\n+    InitialScaledStartValuesNegativeExponentNegativePower(\n+        significand, exponent, estimated_power, need_boundary_deltas,\n+        numerator, denominator, delta_minus, delta_plus);\n+  }\n+\n+  if (need_boundary_deltas && lower_boundary_is_closer) {\n+    // The lower boundary is closer at half the distance of \"normal\" numbers.\n+    // Increase the common denominator and adapt all but the delta_minus.\n+    denominator->ShiftLeft(1);  // *2\n+    numerator->ShiftLeft(1);    // *2\n+    delta_plus->ShiftLeft(1);   // *2\n+  }\n+}\n+\n+\n+// This routine multiplies numerator/denominator so that its values lies in the\n+// range 1-10. That is after a call to this function we have:\n+//    1 <= (numerator + delta_plus) /denominator < 10.\n+// Let numerator the input before modification and numerator' the argument\n+// after modification, then the output-parameter decimal_point is such that\n+//  numerator / denominator * 10^estimated_power ==\n+//    numerator' / denominator' * 10^(decimal_point - 1)\n+// In some cases estimated_power was too low, and this is already the case. We\n+// then simply adjust the power so that 10^(k-1) <= v < 10^k (with k ==\n+// estimated_power) but do not touch the numerator or denominator.\n+// Otherwise the routine multiplies the numerator and the deltas by 10.\n+static void FixupMultiply10(int estimated_power, bool is_even,\n+                            int* decimal_point,\n+                            Bignum* numerator, Bignum* denominator,\n+                            Bignum* delta_minus, Bignum* delta_plus) {\n+  bool in_range;\n+  if (is_even) {\n+    // For IEEE doubles half-way cases (in decimal system numbers ending with 5)\n+    // are rounded to the closest floating-point number with even significand.\n+    in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) >= 0;\n+  } else {\n+    in_range = Bignum::PlusCompare(*numerator, *delta_plus, *denominator) > 0;\n+  }\n+  if (in_range) {\n+    // Since numerator + delta_plus >= denominator we already have\n+    // 1 <= numerator/denominator < 10. Simply update the estimated_power.\n+    *decimal_point = estimated_power + 1;\n+  } else {\n+    *decimal_point = estimated_power;\n+    numerator->Times10();\n+    if (Bignum::Equal(*delta_minus, *delta_plus)) {\n+      delta_minus->Times10();\n+      delta_plus->AssignBignum(*delta_minus);\n+    } else {\n+      delta_minus->Times10();\n+      delta_plus->Times10();\n+    }\n+  }\n+}\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "edc21b0f2e4d5e2bdb75ef6c4738e66f452f70a2",
            "filename": "deps/icu-small/source/i18n/double-conversion-bignum-dtoa.h",
            "status": "added",
            "additions": 102,
            "deletions": 0,
            "changes": 102,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum-dtoa.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum-dtoa.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum-dtoa.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,102 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#ifndef DOUBLE_CONVERSION_BIGNUM_DTOA_H_\n+#define DOUBLE_CONVERSION_BIGNUM_DTOA_H_\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-utils.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+enum BignumDtoaMode {\n+  // Return the shortest correct representation.\n+  // For example the output of 0.299999999999999988897 is (the less accurate but\n+  // correct) 0.3.\n+  BIGNUM_DTOA_SHORTEST,\n+  // Same as BIGNUM_DTOA_SHORTEST but for single-precision floats.\n+  BIGNUM_DTOA_SHORTEST_SINGLE,\n+  // Return a fixed number of digits after the decimal point.\n+  // For instance fixed(0.1, 4) becomes 0.1000\n+  // If the input number is big, the output will be big.\n+  BIGNUM_DTOA_FIXED,\n+  // Return a fixed number of digits, no matter what the exponent is.\n+  BIGNUM_DTOA_PRECISION\n+};\n+\n+// Converts the given double 'v' to ascii.\n+// The result should be interpreted as buffer * 10^(point-length).\n+// The buffer will be null-terminated.\n+//\n+// The input v must be > 0 and different from NaN, and Infinity.\n+//\n+// The output depends on the given mode:\n+//  - SHORTEST: produce the least amount of digits for which the internal\n+//   identity requirement is still satisfied. If the digits are printed\n+//   (together with the correct exponent) then reading this number will give\n+//   'v' again. The buffer will choose the representation that is closest to\n+//   'v'. If there are two at the same distance, than the number is round up.\n+//   In this mode the 'requested_digits' parameter is ignored.\n+//  - FIXED: produces digits necessary to print a given number with\n+//   'requested_digits' digits after the decimal point. The produced digits\n+//   might be too short in which case the caller has to fill the gaps with '0's.\n+//   Example: toFixed(0.001, 5) is allowed to return buffer=\"1\", point=-2.\n+//   Halfway cases are rounded up. The call toFixed(0.15, 2) thus returns\n+//     buffer=\"2\", point=0.\n+//   Note: the length of the returned buffer has no meaning wrt the significance\n+//   of its digits. That is, just because it contains '0's does not mean that\n+//   any other digit would not satisfy the internal identity requirement.\n+//  - PRECISION: produces 'requested_digits' where the first digit is not '0'.\n+//   Even though the length of produced digits usually equals\n+//   'requested_digits', the function is allowed to return fewer digits, in\n+//   which case the caller has to fill the missing digits with '0's.\n+//   Halfway cases are again rounded up.\n+// 'BignumDtoa' expects the given buffer to be big enough to hold all digits\n+// and a terminating null-character.\n+void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,\n+                Vector<char> buffer, int* length, int* point);\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+\n+#endif  // DOUBLE_CONVERSION_BIGNUM_DTOA_H_\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "d5682af35f866dd7c1586038451b8a602e6195ca",
            "filename": "deps/icu-small/source/i18n/double-conversion-bignum.cpp",
            "status": "added",
            "additions": 784,
            "deletions": 0,
            "changes": 784,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,784 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-bignum.h\"\n+#include \"double-conversion-utils.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+Bignum::Bignum()\n+    : bigits_(bigits_buffer_, kBigitCapacity), used_digits_(0), exponent_(0) {\n+  for (int i = 0; i < kBigitCapacity; ++i) {\n+    bigits_[i] = 0;\n+  }\n+}\n+\n+\n+template<typename S>\n+static int BitSize(S value) {\n+  (void) value;  // Mark variable as used.\n+  return 8 * sizeof(value);\n+}\n+\n+// Guaranteed to lie in one Bigit.\n+void Bignum::AssignUInt16(uint16_t value) {\n+  ASSERT(kBigitSize >= BitSize(value));\n+  Zero();\n+  if (value == 0) return;\n+\n+  EnsureCapacity(1);\n+  bigits_[0] = value;\n+  used_digits_ = 1;\n+}\n+\n+\n+void Bignum::AssignUInt64(uint64_t value) {\n+  const int kUInt64Size = 64;\n+\n+  Zero();\n+  if (value == 0) return;\n+\n+  int needed_bigits = kUInt64Size / kBigitSize + 1;\n+  EnsureCapacity(needed_bigits);\n+  for (int i = 0; i < needed_bigits; ++i) {\n+    bigits_[i] = value & kBigitMask;\n+    value = value >> kBigitSize;\n+  }\n+  used_digits_ = needed_bigits;\n+  Clamp();\n+}\n+\n+\n+void Bignum::AssignBignum(const Bignum& other) {\n+  exponent_ = other.exponent_;\n+  for (int i = 0; i < other.used_digits_; ++i) {\n+    bigits_[i] = other.bigits_[i];\n+  }\n+  // Clear the excess digits (if there were any).\n+  for (int i = other.used_digits_; i < used_digits_; ++i) {\n+    bigits_[i] = 0;\n+  }\n+  used_digits_ = other.used_digits_;\n+}\n+\n+\n+static uint64_t ReadUInt64(Vector<const char> buffer,\n+                           int from,\n+                           int digits_to_read) {\n+  uint64_t result = 0;\n+  for (int i = from; i < from + digits_to_read; ++i) {\n+    int digit = buffer[i] - '0';\n+    ASSERT(0 <= digit && digit <= 9);\n+    result = result * 10 + digit;\n+  }\n+  return result;\n+}\n+\n+\n+void Bignum::AssignDecimalString(Vector<const char> value) {\n+  // 2^64 = 18446744073709551616 > 10^19\n+  const int kMaxUint64DecimalDigits = 19;\n+  Zero();\n+  int length = value.length();\n+  unsigned int pos = 0;\n+  // Let's just say that each digit needs 4 bits.\n+  while (length >= kMaxUint64DecimalDigits) {\n+    uint64_t digits = ReadUInt64(value, pos, kMaxUint64DecimalDigits);\n+    pos += kMaxUint64DecimalDigits;\n+    length -= kMaxUint64DecimalDigits;\n+    MultiplyByPowerOfTen(kMaxUint64DecimalDigits);\n+    AddUInt64(digits);\n+  }\n+  uint64_t digits = ReadUInt64(value, pos, length);\n+  MultiplyByPowerOfTen(length);\n+  AddUInt64(digits);\n+  Clamp();\n+}\n+\n+\n+static int HexCharValue(char c) {\n+  if ('0' <= c && c <= '9') return c - '0';\n+  if ('a' <= c && c <= 'f') return 10 + c - 'a';\n+  ASSERT('A' <= c && c <= 'F');\n+  return 10 + c - 'A';\n+}\n+\n+\n+void Bignum::AssignHexString(Vector<const char> value) {\n+  Zero();\n+  int length = value.length();\n+\n+  int needed_bigits = length * 4 / kBigitSize + 1;\n+  EnsureCapacity(needed_bigits);\n+  int string_index = length - 1;\n+  for (int i = 0; i < needed_bigits - 1; ++i) {\n+    // These bigits are guaranteed to be \"full\".\n+    Chunk current_bigit = 0;\n+    for (int j = 0; j < kBigitSize / 4; j++) {\n+      current_bigit += HexCharValue(value[string_index--]) << (j * 4);\n+    }\n+    bigits_[i] = current_bigit;\n+  }\n+  used_digits_ = needed_bigits - 1;\n+\n+  Chunk most_significant_bigit = 0;  // Could be = 0;\n+  for (int j = 0; j <= string_index; ++j) {\n+    most_significant_bigit <<= 4;\n+    most_significant_bigit += HexCharValue(value[j]);\n+  }\n+  if (most_significant_bigit != 0) {\n+    bigits_[used_digits_] = most_significant_bigit;\n+    used_digits_++;\n+  }\n+  Clamp();\n+}\n+\n+\n+void Bignum::AddUInt64(uint64_t operand) {\n+  if (operand == 0) return;\n+  Bignum other;\n+  other.AssignUInt64(operand);\n+  AddBignum(other);\n+}\n+\n+\n+void Bignum::AddBignum(const Bignum& other) {\n+  ASSERT(IsClamped());\n+  ASSERT(other.IsClamped());\n+\n+  // If this has a greater exponent than other append zero-bigits to this.\n+  // After this call exponent_ <= other.exponent_.\n+  Align(other);\n+\n+  // There are two possibilities:\n+  //   aaaaaaaaaaa 0000  (where the 0s represent a's exponent)\n+  //     bbbbb 00000000\n+  //   ----------------\n+  //   ccccccccccc 0000\n+  // or\n+  //    aaaaaaaaaa 0000\n+  //  bbbbbbbbb 0000000\n+  //  -----------------\n+  //  cccccccccccc 0000\n+  // In both cases we might need a carry bigit.\n+\n+  EnsureCapacity(1 + Max(BigitLength(), other.BigitLength()) - exponent_);\n+  Chunk carry = 0;\n+  int bigit_pos = other.exponent_ - exponent_;\n+  ASSERT(bigit_pos >= 0);\n+  for (int i = 0; i < other.used_digits_; ++i) {\n+    Chunk sum = bigits_[bigit_pos] + other.bigits_[i] + carry;\n+    bigits_[bigit_pos] = sum & kBigitMask;\n+    carry = sum >> kBigitSize;\n+    bigit_pos++;\n+  }\n+\n+  while (carry != 0) {\n+    Chunk sum = bigits_[bigit_pos] + carry;\n+    bigits_[bigit_pos] = sum & kBigitMask;\n+    carry = sum >> kBigitSize;\n+    bigit_pos++;\n+  }\n+  used_digits_ = Max(bigit_pos, used_digits_);\n+  ASSERT(IsClamped());\n+}\n+\n+\n+void Bignum::SubtractBignum(const Bignum& other) {\n+  ASSERT(IsClamped());\n+  ASSERT(other.IsClamped());\n+  // We require this to be bigger than other.\n+  ASSERT(LessEqual(other, *this));\n+\n+  Align(other);\n+\n+  int offset = other.exponent_ - exponent_;\n+  Chunk borrow = 0;\n+  int i;\n+  for (i = 0; i < other.used_digits_; ++i) {\n+    ASSERT((borrow == 0) || (borrow == 1));\n+    Chunk difference = bigits_[i + offset] - other.bigits_[i] - borrow;\n+    bigits_[i + offset] = difference & kBigitMask;\n+    borrow = difference >> (kChunkSize - 1);\n+  }\n+  while (borrow != 0) {\n+    Chunk difference = bigits_[i + offset] - borrow;\n+    bigits_[i + offset] = difference & kBigitMask;\n+    borrow = difference >> (kChunkSize - 1);\n+    ++i;\n+  }\n+  Clamp();\n+}\n+\n+\n+void Bignum::ShiftLeft(int shift_amount) {\n+  if (used_digits_ == 0) return;\n+  exponent_ += shift_amount / kBigitSize;\n+  int local_shift = shift_amount % kBigitSize;\n+  EnsureCapacity(used_digits_ + 1);\n+  BigitsShiftLeft(local_shift);\n+}\n+\n+\n+void Bignum::MultiplyByUInt32(uint32_t factor) {\n+  if (factor == 1) return;\n+  if (factor == 0) {\n+    Zero();\n+    return;\n+  }\n+  if (used_digits_ == 0) return;\n+\n+  // The product of a bigit with the factor is of size kBigitSize + 32.\n+  // Assert that this number + 1 (for the carry) fits into double chunk.\n+  ASSERT(kDoubleChunkSize >= kBigitSize + 32 + 1);\n+  DoubleChunk carry = 0;\n+  for (int i = 0; i < used_digits_; ++i) {\n+    DoubleChunk product = static_cast<DoubleChunk>(factor) * bigits_[i] + carry;\n+    bigits_[i] = static_cast<Chunk>(product & kBigitMask);\n+    carry = (product >> kBigitSize);\n+  }\n+  while (carry != 0) {\n+    EnsureCapacity(used_digits_ + 1);\n+    bigits_[used_digits_] = carry & kBigitMask;\n+    used_digits_++;\n+    carry >>= kBigitSize;\n+  }\n+}\n+\n+\n+void Bignum::MultiplyByUInt64(uint64_t factor) {\n+  if (factor == 1) return;\n+  if (factor == 0) {\n+    Zero();\n+    return;\n+  }\n+  ASSERT(kBigitSize < 32);\n+  uint64_t carry = 0;\n+  uint64_t low = factor & 0xFFFFFFFF;\n+  uint64_t high = factor >> 32;\n+  for (int i = 0; i < used_digits_; ++i) {\n+    uint64_t product_low = low * bigits_[i];\n+    uint64_t product_high = high * bigits_[i];\n+    uint64_t tmp = (carry & kBigitMask) + product_low;\n+    bigits_[i] = tmp & kBigitMask;\n+    carry = (carry >> kBigitSize) + (tmp >> kBigitSize) +\n+        (product_high << (32 - kBigitSize));\n+  }\n+  while (carry != 0) {\n+    EnsureCapacity(used_digits_ + 1);\n+    bigits_[used_digits_] = carry & kBigitMask;\n+    used_digits_++;\n+    carry >>= kBigitSize;\n+  }\n+}\n+\n+\n+void Bignum::MultiplyByPowerOfTen(int exponent) {\n+  const uint64_t kFive27 = UINT64_2PART_C(0x6765c793, fa10079d);\n+  const uint16_t kFive1 = 5;\n+  const uint16_t kFive2 = kFive1 * 5;\n+  const uint16_t kFive3 = kFive2 * 5;\n+  const uint16_t kFive4 = kFive3 * 5;\n+  const uint16_t kFive5 = kFive4 * 5;\n+  const uint16_t kFive6 = kFive5 * 5;\n+  const uint32_t kFive7 = kFive6 * 5;\n+  const uint32_t kFive8 = kFive7 * 5;\n+  const uint32_t kFive9 = kFive8 * 5;\n+  const uint32_t kFive10 = kFive9 * 5;\n+  const uint32_t kFive11 = kFive10 * 5;\n+  const uint32_t kFive12 = kFive11 * 5;\n+  const uint32_t kFive13 = kFive12 * 5;\n+  const uint32_t kFive1_to_12[] =\n+      { kFive1, kFive2, kFive3, kFive4, kFive5, kFive6,\n+        kFive7, kFive8, kFive9, kFive10, kFive11, kFive12 };\n+\n+  ASSERT(exponent >= 0);\n+  if (exponent == 0) return;\n+  if (used_digits_ == 0) return;\n+\n+  // We shift by exponent at the end just before returning.\n+  int remaining_exponent = exponent;\n+  while (remaining_exponent >= 27) {\n+    MultiplyByUInt64(kFive27);\n+    remaining_exponent -= 27;\n+  }\n+  while (remaining_exponent >= 13) {\n+    MultiplyByUInt32(kFive13);\n+    remaining_exponent -= 13;\n+  }\n+  if (remaining_exponent > 0) {\n+    MultiplyByUInt32(kFive1_to_12[remaining_exponent - 1]);\n+  }\n+  ShiftLeft(exponent);\n+}\n+\n+\n+void Bignum::Square() {\n+  ASSERT(IsClamped());\n+  int product_length = 2 * used_digits_;\n+  EnsureCapacity(product_length);\n+\n+  // Comba multiplication: compute each column separately.\n+  // Example: r = a2a1a0 * b2b1b0.\n+  //    r =  1    * a0b0 +\n+  //        10    * (a1b0 + a0b1) +\n+  //        100   * (a2b0 + a1b1 + a0b2) +\n+  //        1000  * (a2b1 + a1b2) +\n+  //        10000 * a2b2\n+  //\n+  // In the worst case we have to accumulate nb-digits products of digit*digit.\n+  //\n+  // Assert that the additional number of bits in a DoubleChunk are enough to\n+  // sum up used_digits of Bigit*Bigit.\n+  if ((1 << (2 * (kChunkSize - kBigitSize))) <= used_digits_) {\n+    UNIMPLEMENTED();\n+  }\n+  DoubleChunk accumulator = 0;\n+  // First shift the digits so we don't overwrite them.\n+  int copy_offset = used_digits_;\n+  for (int i = 0; i < used_digits_; ++i) {\n+    bigits_[copy_offset + i] = bigits_[i];\n+  }\n+  // We have two loops to avoid some 'if's in the loop.\n+  for (int i = 0; i < used_digits_; ++i) {\n+    // Process temporary digit i with power i.\n+    // The sum of the two indices must be equal to i.\n+    int bigit_index1 = i;\n+    int bigit_index2 = 0;\n+    // Sum all of the sub-products.\n+    while (bigit_index1 >= 0) {\n+      Chunk chunk1 = bigits_[copy_offset + bigit_index1];\n+      Chunk chunk2 = bigits_[copy_offset + bigit_index2];\n+      accumulator += static_cast<DoubleChunk>(chunk1) * chunk2;\n+      bigit_index1--;\n+      bigit_index2++;\n+    }\n+    bigits_[i] = static_cast<Chunk>(accumulator) & kBigitMask;\n+    accumulator >>= kBigitSize;\n+  }\n+  for (int i = used_digits_; i < product_length; ++i) {\n+    int bigit_index1 = used_digits_ - 1;\n+    int bigit_index2 = i - bigit_index1;\n+    // Invariant: sum of both indices is again equal to i.\n+    // Inner loop runs 0 times on last iteration, emptying accumulator.\n+    while (bigit_index2 < used_digits_) {\n+      Chunk chunk1 = bigits_[copy_offset + bigit_index1];\n+      Chunk chunk2 = bigits_[copy_offset + bigit_index2];\n+      accumulator += static_cast<DoubleChunk>(chunk1) * chunk2;\n+      bigit_index1--;\n+      bigit_index2++;\n+    }\n+    // The overwritten bigits_[i] will never be read in further loop iterations,\n+    // because bigit_index1 and bigit_index2 are always greater\n+    // than i - used_digits_.\n+    bigits_[i] = static_cast<Chunk>(accumulator) & kBigitMask;\n+    accumulator >>= kBigitSize;\n+  }\n+  // Since the result was guaranteed to lie inside the number the\n+  // accumulator must be 0 now.\n+  ASSERT(accumulator == 0);\n+\n+  // Don't forget to update the used_digits and the exponent.\n+  used_digits_ = product_length;\n+  exponent_ *= 2;\n+  Clamp();\n+}\n+\n+\n+void Bignum::AssignPowerUInt16(uint16_t base, int power_exponent) {\n+  ASSERT(base != 0);\n+  ASSERT(power_exponent >= 0);\n+  if (power_exponent == 0) {\n+    AssignUInt16(1);\n+    return;\n+  }\n+  Zero();\n+  int shifts = 0;\n+  // We expect base to be in range 2-32, and most often to be 10.\n+  // It does not make much sense to implement different algorithms for counting\n+  // the bits.\n+  while ((base & 1) == 0) {\n+    base >>= 1;\n+    shifts++;\n+  }\n+  int bit_size = 0;\n+  int tmp_base = base;\n+  while (tmp_base != 0) {\n+    tmp_base >>= 1;\n+    bit_size++;\n+  }\n+  int final_size = bit_size * power_exponent;\n+  // 1 extra bigit for the shifting, and one for rounded final_size.\n+  EnsureCapacity(final_size / kBigitSize + 2);\n+\n+  // Left to Right exponentiation.\n+  int mask = 1;\n+  while (power_exponent >= mask) mask <<= 1;\n+\n+  // The mask is now pointing to the bit above the most significant 1-bit of\n+  // power_exponent.\n+  // Get rid of first 1-bit;\n+  mask >>= 2;\n+  uint64_t this_value = base;\n+\n+  bool delayed_multipliciation = false;\n+  const uint64_t max_32bits = 0xFFFFFFFF;\n+  while (mask != 0 && this_value <= max_32bits) {\n+    this_value = this_value * this_value;\n+    // Verify that there is enough space in this_value to perform the\n+    // multiplication.  The first bit_size bits must be 0.\n+    if ((power_exponent & mask) != 0) {\n+      uint64_t base_bits_mask =\n+          ~((static_cast<uint64_t>(1) << (64 - bit_size)) - 1);\n+      bool high_bits_zero = (this_value & base_bits_mask) == 0;\n+      if (high_bits_zero) {\n+        this_value *= base;\n+      } else {\n+        delayed_multipliciation = true;\n+      }\n+    }\n+    mask >>= 1;\n+  }\n+  AssignUInt64(this_value);\n+  if (delayed_multipliciation) {\n+    MultiplyByUInt32(base);\n+  }\n+\n+  // Now do the same thing as a bignum.\n+  while (mask != 0) {\n+    Square();\n+    if ((power_exponent & mask) != 0) {\n+      MultiplyByUInt32(base);\n+    }\n+    mask >>= 1;\n+  }\n+\n+  // And finally add the saved shifts.\n+  ShiftLeft(shifts * power_exponent);\n+}\n+\n+\n+// Precondition: this/other < 16bit.\n+uint16_t Bignum::DivideModuloIntBignum(const Bignum& other) {\n+  ASSERT(IsClamped());\n+  ASSERT(other.IsClamped());\n+  ASSERT(other.used_digits_ > 0);\n+\n+  // Easy case: if we have less digits than the divisor than the result is 0.\n+  // Note: this handles the case where this == 0, too.\n+  if (BigitLength() < other.BigitLength()) {\n+    return 0;\n+  }\n+\n+  Align(other);\n+\n+  uint16_t result = 0;\n+\n+  // Start by removing multiples of 'other' until both numbers have the same\n+  // number of digits.\n+  while (BigitLength() > other.BigitLength()) {\n+    // This naive approach is extremely inefficient if `this` divided by other\n+    // is big. This function is implemented for doubleToString where\n+    // the result should be small (less than 10).\n+    ASSERT(other.bigits_[other.used_digits_ - 1] >= ((1 << kBigitSize) / 16));\n+    ASSERT(bigits_[used_digits_ - 1] < 0x10000);\n+    // Remove the multiples of the first digit.\n+    // Example this = 23 and other equals 9. -> Remove 2 multiples.\n+    result += static_cast<uint16_t>(bigits_[used_digits_ - 1]);\n+    SubtractTimes(other, bigits_[used_digits_ - 1]);\n+  }\n+\n+  ASSERT(BigitLength() == other.BigitLength());\n+\n+  // Both bignums are at the same length now.\n+  // Since other has more than 0 digits we know that the access to\n+  // bigits_[used_digits_ - 1] is safe.\n+  Chunk this_bigit = bigits_[used_digits_ - 1];\n+  Chunk other_bigit = other.bigits_[other.used_digits_ - 1];\n+\n+  if (other.used_digits_ == 1) {\n+    // Shortcut for easy (and common) case.\n+    int quotient = this_bigit / other_bigit;\n+    bigits_[used_digits_ - 1] = this_bigit - other_bigit * quotient;\n+    ASSERT(quotient < 0x10000);\n+    result += static_cast<uint16_t>(quotient);\n+    Clamp();\n+    return result;\n+  }\n+\n+  int division_estimate = this_bigit / (other_bigit + 1);\n+  ASSERT(division_estimate < 0x10000);\n+  result += static_cast<uint16_t>(division_estimate);\n+  SubtractTimes(other, division_estimate);\n+\n+  if (other_bigit * (division_estimate + 1) > this_bigit) {\n+    // No need to even try to subtract. Even if other's remaining digits were 0\n+    // another subtraction would be too much.\n+    return result;\n+  }\n+\n+  while (LessEqual(other, *this)) {\n+    SubtractBignum(other);\n+    result++;\n+  }\n+  return result;\n+}\n+\n+\n+template<typename S>\n+static int SizeInHexChars(S number) {\n+  ASSERT(number > 0);\n+  int result = 0;\n+  while (number != 0) {\n+    number >>= 4;\n+    result++;\n+  }\n+  return result;\n+}\n+\n+\n+static char HexCharOfValue(int value) {\n+  ASSERT(0 <= value && value <= 16);\n+  if (value < 10) return static_cast<char>(value + '0');\n+  return static_cast<char>(value - 10 + 'A');\n+}\n+\n+\n+bool Bignum::ToHexString(char* buffer, int buffer_size) const {\n+  ASSERT(IsClamped());\n+  // Each bigit must be printable as separate hex-character.\n+  ASSERT(kBigitSize % 4 == 0);\n+  const int kHexCharsPerBigit = kBigitSize / 4;\n+\n+  if (used_digits_ == 0) {\n+    if (buffer_size < 2) return false;\n+    buffer[0] = '0';\n+    buffer[1] = '\\0';\n+    return true;\n+  }\n+  // We add 1 for the terminating '\\0' character.\n+  int needed_chars = (BigitLength() - 1) * kHexCharsPerBigit +\n+      SizeInHexChars(bigits_[used_digits_ - 1]) + 1;\n+  if (needed_chars > buffer_size) return false;\n+  int string_index = needed_chars - 1;\n+  buffer[string_index--] = '\\0';\n+  for (int i = 0; i < exponent_; ++i) {\n+    for (int j = 0; j < kHexCharsPerBigit; ++j) {\n+      buffer[string_index--] = '0';\n+    }\n+  }\n+  for (int i = 0; i < used_digits_ - 1; ++i) {\n+    Chunk current_bigit = bigits_[i];\n+    for (int j = 0; j < kHexCharsPerBigit; ++j) {\n+      buffer[string_index--] = HexCharOfValue(current_bigit & 0xF);\n+      current_bigit >>= 4;\n+    }\n+  }\n+  // And finally the last bigit.\n+  Chunk most_significant_bigit = bigits_[used_digits_ - 1];\n+  while (most_significant_bigit != 0) {\n+    buffer[string_index--] = HexCharOfValue(most_significant_bigit & 0xF);\n+    most_significant_bigit >>= 4;\n+  }\n+  return true;\n+}\n+\n+\n+Bignum::Chunk Bignum::BigitAt(int index) const {\n+  if (index >= BigitLength()) return 0;\n+  if (index < exponent_) return 0;\n+  return bigits_[index - exponent_];\n+}\n+\n+\n+int Bignum::Compare(const Bignum& a, const Bignum& b) {\n+  ASSERT(a.IsClamped());\n+  ASSERT(b.IsClamped());\n+  int bigit_length_a = a.BigitLength();\n+  int bigit_length_b = b.BigitLength();\n+  if (bigit_length_a < bigit_length_b) return -1;\n+  if (bigit_length_a > bigit_length_b) return +1;\n+  for (int i = bigit_length_a - 1; i >= Min(a.exponent_, b.exponent_); --i) {\n+    Chunk bigit_a = a.BigitAt(i);\n+    Chunk bigit_b = b.BigitAt(i);\n+    if (bigit_a < bigit_b) return -1;\n+    if (bigit_a > bigit_b) return +1;\n+    // Otherwise they are equal up to this digit. Try the next digit.\n+  }\n+  return 0;\n+}\n+\n+\n+int Bignum::PlusCompare(const Bignum& a, const Bignum& b, const Bignum& c) {\n+  ASSERT(a.IsClamped());\n+  ASSERT(b.IsClamped());\n+  ASSERT(c.IsClamped());\n+  if (a.BigitLength() < b.BigitLength()) {\n+    return PlusCompare(b, a, c);\n+  }\n+  if (a.BigitLength() + 1 < c.BigitLength()) return -1;\n+  if (a.BigitLength() > c.BigitLength()) return +1;\n+  // The exponent encodes 0-bigits. So if there are more 0-digits in 'a' than\n+  // 'b' has digits, then the bigit-length of 'a'+'b' must be equal to the one\n+  // of 'a'.\n+  if (a.exponent_ >= b.BigitLength() && a.BigitLength() < c.BigitLength()) {\n+    return -1;\n+  }\n+\n+  Chunk borrow = 0;\n+  // Starting at min_exponent all digits are == 0. So no need to compare them.\n+  int min_exponent = Min(Min(a.exponent_, b.exponent_), c.exponent_);\n+  for (int i = c.BigitLength() - 1; i >= min_exponent; --i) {\n+    Chunk chunk_a = a.BigitAt(i);\n+    Chunk chunk_b = b.BigitAt(i);\n+    Chunk chunk_c = c.BigitAt(i);\n+    Chunk sum = chunk_a + chunk_b;\n+    if (sum > chunk_c + borrow) {\n+      return +1;\n+    } else {\n+      borrow = chunk_c + borrow - sum;\n+      if (borrow > 1) return -1;\n+      borrow <<= kBigitSize;\n+    }\n+  }\n+  if (borrow == 0) return 0;\n+  return -1;\n+}\n+\n+\n+void Bignum::Clamp() {\n+  while (used_digits_ > 0 && bigits_[used_digits_ - 1] == 0) {\n+    used_digits_--;\n+  }\n+  if (used_digits_ == 0) {\n+    // Zero.\n+    exponent_ = 0;\n+  }\n+}\n+\n+\n+bool Bignum::IsClamped() const {\n+  return used_digits_ == 0 || bigits_[used_digits_ - 1] != 0;\n+}\n+\n+\n+void Bignum::Zero() {\n+  for (int i = 0; i < used_digits_; ++i) {\n+    bigits_[i] = 0;\n+  }\n+  used_digits_ = 0;\n+  exponent_ = 0;\n+}\n+\n+\n+void Bignum::Align(const Bignum& other) {\n+  if (exponent_ > other.exponent_) {\n+    // If \"X\" represents a \"hidden\" digit (by the exponent) then we are in the\n+    // following case (a == this, b == other):\n+    // a:  aaaaaaXXXX   or a:   aaaaaXXX\n+    // b:     bbbbbbX      b: bbbbbbbbXX\n+    // We replace some of the hidden digits (X) of a with 0 digits.\n+    // a:  aaaaaa000X   or a:   aaaaa0XX\n+    int zero_digits = exponent_ - other.exponent_;\n+    EnsureCapacity(used_digits_ + zero_digits);\n+    for (int i = used_digits_ - 1; i >= 0; --i) {\n+      bigits_[i + zero_digits] = bigits_[i];\n+    }\n+    for (int i = 0; i < zero_digits; ++i) {\n+      bigits_[i] = 0;\n+    }\n+    used_digits_ += zero_digits;\n+    exponent_ -= zero_digits;\n+    ASSERT(used_digits_ >= 0);\n+    ASSERT(exponent_ >= 0);\n+  }\n+}\n+\n+\n+void Bignum::BigitsShiftLeft(int shift_amount) {\n+  ASSERT(shift_amount < kBigitSize);\n+  ASSERT(shift_amount >= 0);\n+  Chunk carry = 0;\n+  for (int i = 0; i < used_digits_; ++i) {\n+    Chunk new_carry = bigits_[i] >> (kBigitSize - shift_amount);\n+    bigits_[i] = ((bigits_[i] << shift_amount) + carry) & kBigitMask;\n+    carry = new_carry;\n+  }\n+  if (carry != 0) {\n+    bigits_[used_digits_] = carry;\n+    used_digits_++;\n+  }\n+}\n+\n+\n+void Bignum::SubtractTimes(const Bignum& other, int factor) {\n+  ASSERT(exponent_ <= other.exponent_);\n+  if (factor < 3) {\n+    for (int i = 0; i < factor; ++i) {\n+      SubtractBignum(other);\n+    }\n+    return;\n+  }\n+  Chunk borrow = 0;\n+  int exponent_diff = other.exponent_ - exponent_;\n+  for (int i = 0; i < other.used_digits_; ++i) {\n+    DoubleChunk product = static_cast<DoubleChunk>(factor) * other.bigits_[i];\n+    DoubleChunk remove = borrow + product;\n+    Chunk difference = bigits_[i + exponent_diff] - (remove & kBigitMask);\n+    bigits_[i + exponent_diff] = difference & kBigitMask;\n+    borrow = static_cast<Chunk>((difference >> (kChunkSize - 1)) +\n+                                (remove >> kBigitSize));\n+  }\n+  for (int i = other.used_digits_ + exponent_diff; i < used_digits_; ++i) {\n+    if (borrow == 0) return;\n+    Chunk difference = bigits_[i] - borrow;\n+    bigits_[i] = difference & kBigitMask;\n+    borrow = difference >> (kChunkSize - 1);\n+  }\n+  Clamp();\n+}\n+\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "d1af3bf5e77b15a84633da46ea48188d35609b7e",
            "filename": "deps/icu-small/source/i18n/double-conversion-bignum.h",
            "status": "added",
            "additions": 162,
            "deletions": 0,
            "changes": 162,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-bignum.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,162 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#ifndef DOUBLE_CONVERSION_BIGNUM_H_\n+#define DOUBLE_CONVERSION_BIGNUM_H_\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-utils.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+class Bignum {\n+ public:\n+  // 3584 = 128 * 28. We can represent 2^3584 > 10^1000 accurately.\n+  // This bignum can encode much bigger numbers, since it contains an\n+  // exponent.\n+  static const int kMaxSignificantBits = 3584;\n+\n+  Bignum();\n+  void AssignUInt16(uint16_t value);\n+  void AssignUInt64(uint64_t value);\n+  void AssignBignum(const Bignum& other);\n+\n+  void AssignDecimalString(Vector<const char> value);\n+  void AssignHexString(Vector<const char> value);\n+\n+  void AssignPowerUInt16(uint16_t base, int exponent);\n+\n+  void AddUInt64(uint64_t operand);\n+  void AddBignum(const Bignum& other);\n+  // Precondition: this >= other.\n+  void SubtractBignum(const Bignum& other);\n+\n+  void Square();\n+  void ShiftLeft(int shift_amount);\n+  void MultiplyByUInt32(uint32_t factor);\n+  void MultiplyByUInt64(uint64_t factor);\n+  void MultiplyByPowerOfTen(int exponent);\n+  void Times10() { return MultiplyByUInt32(10); }\n+  // Pseudocode:\n+  //  int result = this / other;\n+  //  this = this % other;\n+  // In the worst case this function is in O(this/other).\n+  uint16_t DivideModuloIntBignum(const Bignum& other);\n+\n+  bool ToHexString(char* buffer, int buffer_size) const;\n+\n+  // Returns\n+  //  -1 if a < b,\n+  //   0 if a == b, and\n+  //  +1 if a > b.\n+  static int Compare(const Bignum& a, const Bignum& b);\n+  static bool Equal(const Bignum& a, const Bignum& b) {\n+    return Compare(a, b) == 0;\n+  }\n+  static bool LessEqual(const Bignum& a, const Bignum& b) {\n+    return Compare(a, b) <= 0;\n+  }\n+  static bool Less(const Bignum& a, const Bignum& b) {\n+    return Compare(a, b) < 0;\n+  }\n+  // Returns Compare(a + b, c);\n+  static int PlusCompare(const Bignum& a, const Bignum& b, const Bignum& c);\n+  // Returns a + b == c\n+  static bool PlusEqual(const Bignum& a, const Bignum& b, const Bignum& c) {\n+    return PlusCompare(a, b, c) == 0;\n+  }\n+  // Returns a + b <= c\n+  static bool PlusLessEqual(const Bignum& a, const Bignum& b, const Bignum& c) {\n+    return PlusCompare(a, b, c) <= 0;\n+  }\n+  // Returns a + b < c\n+  static bool PlusLess(const Bignum& a, const Bignum& b, const Bignum& c) {\n+    return PlusCompare(a, b, c) < 0;\n+  }\n+ private:\n+  typedef uint32_t Chunk;\n+  typedef uint64_t DoubleChunk;\n+\n+  static const int kChunkSize = sizeof(Chunk) * 8;\n+  static const int kDoubleChunkSize = sizeof(DoubleChunk) * 8;\n+  // With bigit size of 28 we loose some bits, but a double still fits easily\n+  // into two chunks, and more importantly we can use the Comba multiplication.\n+  static const int kBigitSize = 28;\n+  static const Chunk kBigitMask = (1 << kBigitSize) - 1;\n+  // Every instance allocates kBigitLength chunks on the stack. Bignums cannot\n+  // grow. There are no checks if the stack-allocated space is sufficient.\n+  static const int kBigitCapacity = kMaxSignificantBits / kBigitSize;\n+\n+  void EnsureCapacity(int size) {\n+    if (size > kBigitCapacity) {\n+      UNREACHABLE();\n+    }\n+  }\n+  void Align(const Bignum& other);\n+  void Clamp();\n+  bool IsClamped() const;\n+  void Zero();\n+  // Requires this to have enough capacity (no tests done).\n+  // Updates used_digits_ if necessary.\n+  // shift_amount must be < kBigitSize.\n+  void BigitsShiftLeft(int shift_amount);\n+  // BigitLength includes the \"hidden\" digits encoded in the exponent.\n+  int BigitLength() const { return used_digits_ + exponent_; }\n+  Chunk BigitAt(int index) const;\n+  void SubtractTimes(const Bignum& other, int factor);\n+\n+  Chunk bigits_buffer_[kBigitCapacity];\n+  // A vector backed by bigits_buffer_. This way accesses to the array are\n+  // checked for out-of-bounds errors.\n+  Vector<Chunk> bigits_;\n+  int used_digits_;\n+  // The Bignum's value equals value(bigits_) * 2^(exponent_ * kBigitSize).\n+  int exponent_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(Bignum);\n+};\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+\n+#endif  // DOUBLE_CONVERSION_BIGNUM_H_\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "e49700444c6b489c4ac45c8f6d79e2ef1ac10b08",
            "filename": "deps/icu-small/source/i18n/double-conversion-cached-powers.cpp",
            "status": "added",
            "additions": 193,
            "deletions": 0,
            "changes": 193,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-cached-powers.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-cached-powers.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-cached-powers.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,193 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2006-2008 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#include <stdarg.h>\n+#include <limits.h>\n+#include <math.h>\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-utils.h\"\n+\n+#include \"double-conversion-cached-powers.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+struct CachedPower {\n+  uint64_t significand;\n+  int16_t binary_exponent;\n+  int16_t decimal_exponent;\n+};\n+\n+static const CachedPower kCachedPowers[] = {\n+  {UINT64_2PART_C(0xfa8fd5a0, 081c0288), -1220, -348},\n+  {UINT64_2PART_C(0xbaaee17f, a23ebf76), -1193, -340},\n+  {UINT64_2PART_C(0x8b16fb20, 3055ac76), -1166, -332},\n+  {UINT64_2PART_C(0xcf42894a, 5dce35ea), -1140, -324},\n+  {UINT64_2PART_C(0x9a6bb0aa, 55653b2d), -1113, -316},\n+  {UINT64_2PART_C(0xe61acf03, 3d1a45df), -1087, -308},\n+  {UINT64_2PART_C(0xab70fe17, c79ac6ca), -1060, -300},\n+  {UINT64_2PART_C(0xff77b1fc, bebcdc4f), -1034, -292},\n+  {UINT64_2PART_C(0xbe5691ef, 416bd60c), -1007, -284},\n+  {UINT64_2PART_C(0x8dd01fad, 907ffc3c), -980, -276},\n+  {UINT64_2PART_C(0xd3515c28, 31559a83), -954, -268},\n+  {UINT64_2PART_C(0x9d71ac8f, ada6c9b5), -927, -260},\n+  {UINT64_2PART_C(0xea9c2277, 23ee8bcb), -901, -252},\n+  {UINT64_2PART_C(0xaecc4991, 4078536d), -874, -244},\n+  {UINT64_2PART_C(0x823c1279, 5db6ce57), -847, -236},\n+  {UINT64_2PART_C(0xc2109436, 4dfb5637), -821, -228},\n+  {UINT64_2PART_C(0x9096ea6f, 3848984f), -794, -220},\n+  {UINT64_2PART_C(0xd77485cb, 25823ac7), -768, -212},\n+  {UINT64_2PART_C(0xa086cfcd, 97bf97f4), -741, -204},\n+  {UINT64_2PART_C(0xef340a98, 172aace5), -715, -196},\n+  {UINT64_2PART_C(0xb23867fb, 2a35b28e), -688, -188},\n+  {UINT64_2PART_C(0x84c8d4df, d2c63f3b), -661, -180},\n+  {UINT64_2PART_C(0xc5dd4427, 1ad3cdba), -635, -172},\n+  {UINT64_2PART_C(0x936b9fce, bb25c996), -608, -164},\n+  {UINT64_2PART_C(0xdbac6c24, 7d62a584), -582, -156},\n+  {UINT64_2PART_C(0xa3ab6658, 0d5fdaf6), -555, -148},\n+  {UINT64_2PART_C(0xf3e2f893, dec3f126), -529, -140},\n+  {UINT64_2PART_C(0xb5b5ada8, aaff80b8), -502, -132},\n+  {UINT64_2PART_C(0x87625f05, 6c7c4a8b), -475, -124},\n+  {UINT64_2PART_C(0xc9bcff60, 34c13053), -449, -116},\n+  {UINT64_2PART_C(0x964e858c, 91ba2655), -422, -108},\n+  {UINT64_2PART_C(0xdff97724, 70297ebd), -396, -100},\n+  {UINT64_2PART_C(0xa6dfbd9f, b8e5b88f), -369, -92},\n+  {UINT64_2PART_C(0xf8a95fcf, 88747d94), -343, -84},\n+  {UINT64_2PART_C(0xb9447093, 8fa89bcf), -316, -76},\n+  {UINT64_2PART_C(0x8a08f0f8, bf0f156b), -289, -68},\n+  {UINT64_2PART_C(0xcdb02555, 653131b6), -263, -60},\n+  {UINT64_2PART_C(0x993fe2c6, d07b7fac), -236, -52},\n+  {UINT64_2PART_C(0xe45c10c4, 2a2b3b06), -210, -44},\n+  {UINT64_2PART_C(0xaa242499, 697392d3), -183, -36},\n+  {UINT64_2PART_C(0xfd87b5f2, 8300ca0e), -157, -28},\n+  {UINT64_2PART_C(0xbce50864, 92111aeb), -130, -20},\n+  {UINT64_2PART_C(0x8cbccc09, 6f5088cc), -103, -12},\n+  {UINT64_2PART_C(0xd1b71758, e219652c), -77, -4},\n+  {UINT64_2PART_C(0x9c400000, 00000000), -50, 4},\n+  {UINT64_2PART_C(0xe8d4a510, 00000000), -24, 12},\n+  {UINT64_2PART_C(0xad78ebc5, ac620000), 3, 20},\n+  {UINT64_2PART_C(0x813f3978, f8940984), 30, 28},\n+  {UINT64_2PART_C(0xc097ce7b, c90715b3), 56, 36},\n+  {UINT64_2PART_C(0x8f7e32ce, 7bea5c70), 83, 44},\n+  {UINT64_2PART_C(0xd5d238a4, abe98068), 109, 52},\n+  {UINT64_2PART_C(0x9f4f2726, 179a2245), 136, 60},\n+  {UINT64_2PART_C(0xed63a231, d4c4fb27), 162, 68},\n+  {UINT64_2PART_C(0xb0de6538, 8cc8ada8), 189, 76},\n+  {UINT64_2PART_C(0x83c7088e, 1aab65db), 216, 84},\n+  {UINT64_2PART_C(0xc45d1df9, 42711d9a), 242, 92},\n+  {UINT64_2PART_C(0x924d692c, a61be758), 269, 100},\n+  {UINT64_2PART_C(0xda01ee64, 1a708dea), 295, 108},\n+  {UINT64_2PART_C(0xa26da399, 9aef774a), 322, 116},\n+  {UINT64_2PART_C(0xf209787b, b47d6b85), 348, 124},\n+  {UINT64_2PART_C(0xb454e4a1, 79dd1877), 375, 132},\n+  {UINT64_2PART_C(0x865b8692, 5b9bc5c2), 402, 140},\n+  {UINT64_2PART_C(0xc83553c5, c8965d3d), 428, 148},\n+  {UINT64_2PART_C(0x952ab45c, fa97a0b3), 455, 156},\n+  {UINT64_2PART_C(0xde469fbd, 99a05fe3), 481, 164},\n+  {UINT64_2PART_C(0xa59bc234, db398c25), 508, 172},\n+  {UINT64_2PART_C(0xf6c69a72, a3989f5c), 534, 180},\n+  {UINT64_2PART_C(0xb7dcbf53, 54e9bece), 561, 188},\n+  {UINT64_2PART_C(0x88fcf317, f22241e2), 588, 196},\n+  {UINT64_2PART_C(0xcc20ce9b, d35c78a5), 614, 204},\n+  {UINT64_2PART_C(0x98165af3, 7b2153df), 641, 212},\n+  {UINT64_2PART_C(0xe2a0b5dc, 971f303a), 667, 220},\n+  {UINT64_2PART_C(0xa8d9d153, 5ce3b396), 694, 228},\n+  {UINT64_2PART_C(0xfb9b7cd9, a4a7443c), 720, 236},\n+  {UINT64_2PART_C(0xbb764c4c, a7a44410), 747, 244},\n+  {UINT64_2PART_C(0x8bab8eef, b6409c1a), 774, 252},\n+  {UINT64_2PART_C(0xd01fef10, a657842c), 800, 260},\n+  {UINT64_2PART_C(0x9b10a4e5, e9913129), 827, 268},\n+  {UINT64_2PART_C(0xe7109bfb, a19c0c9d), 853, 276},\n+  {UINT64_2PART_C(0xac2820d9, 623bf429), 880, 284},\n+  {UINT64_2PART_C(0x80444b5e, 7aa7cf85), 907, 292},\n+  {UINT64_2PART_C(0xbf21e440, 03acdd2d), 933, 300},\n+  {UINT64_2PART_C(0x8e679c2f, 5e44ff8f), 960, 308},\n+  {UINT64_2PART_C(0xd433179d, 9c8cb841), 986, 316},\n+  {UINT64_2PART_C(0x9e19db92, b4e31ba9), 1013, 324},\n+  {UINT64_2PART_C(0xeb96bf6e, badf77d9), 1039, 332},\n+  {UINT64_2PART_C(0xaf87023b, 9bf0ee6b), 1066, 340},\n+};\n+\n+static const int kCachedPowersOffset = 348;  // -1 * the first decimal_exponent.\n+static const double kD_1_LOG2_10 = 0.30102999566398114;  //  1 / lg(10)\n+// Difference between the decimal exponents in the table above.\n+const int PowersOfTenCache::kDecimalExponentDistance = 8;\n+const int PowersOfTenCache::kMinDecimalExponent = -348;\n+const int PowersOfTenCache::kMaxDecimalExponent = 340;\n+\n+void PowersOfTenCache::GetCachedPowerForBinaryExponentRange(\n+    int min_exponent,\n+    int max_exponent,\n+    DiyFp* power,\n+    int* decimal_exponent) {\n+  int kQ = DiyFp::kSignificandSize;\n+  double k = ceil((min_exponent + kQ - 1) * kD_1_LOG2_10);\n+  int foo = kCachedPowersOffset;\n+  int index =\n+      (foo + static_cast<int>(k) - 1) / kDecimalExponentDistance + 1;\n+  ASSERT(0 <= index && index < static_cast<int>(ARRAY_SIZE(kCachedPowers)));\n+  CachedPower cached_power = kCachedPowers[index];\n+  ASSERT(min_exponent <= cached_power.binary_exponent);\n+  (void) max_exponent;  // Mark variable as used.\n+  ASSERT(cached_power.binary_exponent <= max_exponent);\n+  *decimal_exponent = cached_power.decimal_exponent;\n+  *power = DiyFp(cached_power.significand, cached_power.binary_exponent);\n+}\n+\n+\n+void PowersOfTenCache::GetCachedPowerForDecimalExponent(int requested_exponent,\n+                                                        DiyFp* power,\n+                                                        int* found_exponent) {\n+  ASSERT(kMinDecimalExponent <= requested_exponent);\n+  ASSERT(requested_exponent < kMaxDecimalExponent + kDecimalExponentDistance);\n+  int index =\n+      (requested_exponent + kCachedPowersOffset) / kDecimalExponentDistance;\n+  CachedPower cached_power = kCachedPowers[index];\n+  *power = DiyFp(cached_power.significand, cached_power.binary_exponent);\n+  *found_exponent = cached_power.decimal_exponent;\n+  ASSERT(*found_exponent <= requested_exponent);\n+  ASSERT(requested_exponent < *found_exponent + kDecimalExponentDistance);\n+}\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "438746b143293f33c5488200e44bd1fe9c1b8967",
            "filename": "deps/icu-small/source/i18n/double-conversion-cached-powers.h",
            "status": "added",
            "additions": 82,
            "deletions": 0,
            "changes": 82,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-cached-powers.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-cached-powers.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-cached-powers.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,82 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#ifndef DOUBLE_CONVERSION_CACHED_POWERS_H_\n+#define DOUBLE_CONVERSION_CACHED_POWERS_H_\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-diy-fp.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+class PowersOfTenCache {\n+ public:\n+\n+  // Not all powers of ten are cached. The decimal exponent of two neighboring\n+  // cached numbers will differ by kDecimalExponentDistance.\n+  static const int kDecimalExponentDistance;\n+\n+  static const int kMinDecimalExponent;\n+  static const int kMaxDecimalExponent;\n+\n+  // Returns a cached power-of-ten with a binary exponent in the range\n+  // [min_exponent; max_exponent] (boundaries included).\n+  static void GetCachedPowerForBinaryExponentRange(int min_exponent,\n+                                                   int max_exponent,\n+                                                   DiyFp* power,\n+                                                   int* decimal_exponent);\n+\n+  // Returns a cached power of ten x ~= 10^k such that\n+  //   k <= decimal_exponent < k + kCachedPowersDecimalDistance.\n+  // The given decimal_exponent must satisfy\n+  //   kMinDecimalExponent <= requested_exponent, and\n+  //   requested_exponent < kMaxDecimalExponent + kDecimalExponentDistance.\n+  static void GetCachedPowerForDecimalExponent(int requested_exponent,\n+                                               DiyFp* power,\n+                                               int* found_exponent);\n+};\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+\n+#endif  // DOUBLE_CONVERSION_CACHED_POWERS_H_\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "f38430c6c3c90fc3a71e6e7a19e38e3d90ab30ee",
            "filename": "deps/icu-small/source/i18n/double-conversion-diy-fp.cpp",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-diy-fp.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-diy-fp.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-diy-fp.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,74 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-diy-fp.h\"\n+#include \"double-conversion-utils.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+void DiyFp::Multiply(const DiyFp& other) {\n+  // Simply \"emulates\" a 128 bit multiplication.\n+  // However: the resulting number only contains 64 bits. The least\n+  // significant 64 bits are only used for rounding the most significant 64\n+  // bits.\n+  const uint64_t kM32 = 0xFFFFFFFFU;\n+  uint64_t a = f_ >> 32;\n+  uint64_t b = f_ & kM32;\n+  uint64_t c = other.f_ >> 32;\n+  uint64_t d = other.f_ & kM32;\n+  uint64_t ac = a * c;\n+  uint64_t bc = b * c;\n+  uint64_t ad = a * d;\n+  uint64_t bd = b * d;\n+  uint64_t tmp = (bd >> 32) + (ad & kM32) + (bc & kM32);\n+  // By adding 1U << 31 to tmp we round the final result.\n+  // Halfway cases will be round up.\n+  tmp += 1U << 31;\n+  uint64_t result_f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);\n+  e_ += other.e_ + 64;\n+  f_ = result_f;\n+}\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "21896851d22d3244007f1852d3621ff2f11d19b0",
            "filename": "deps/icu-small/source/i18n/double-conversion-diy-fp.h",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-diy-fp.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-diy-fp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-diy-fp.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,136 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#ifndef DOUBLE_CONVERSION_DIY_FP_H_\n+#define DOUBLE_CONVERSION_DIY_FP_H_\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-utils.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+// This \"Do It Yourself Floating Point\" class implements a floating-point number\n+// with a uint64 significand and an int exponent. Normalized DiyFp numbers will\n+// have the most significant bit of the significand set.\n+// Multiplication and Subtraction do not normalize their results.\n+// DiyFp are not designed to contain special doubles (NaN and Infinity).\n+class DiyFp {\n+ public:\n+  static const int kSignificandSize = 64;\n+\n+  DiyFp() : f_(0), e_(0) {}\n+  DiyFp(uint64_t significand, int exponent) : f_(significand), e_(exponent) {}\n+\n+  // this = this - other.\n+  // The exponents of both numbers must be the same and the significand of this\n+  // must be bigger than the significand of other.\n+  // The result will not be normalized.\n+  void Subtract(const DiyFp& other) {\n+    ASSERT(e_ == other.e_);\n+    ASSERT(f_ >= other.f_);\n+    f_ -= other.f_;\n+  }\n+\n+  // Returns a - b.\n+  // The exponents of both numbers must be the same and this must be bigger\n+  // than other. The result will not be normalized.\n+  static DiyFp Minus(const DiyFp& a, const DiyFp& b) {\n+    DiyFp result = a;\n+    result.Subtract(b);\n+    return result;\n+  }\n+\n+\n+  // this = this * other.\n+  void Multiply(const DiyFp& other);\n+\n+  // returns a * b;\n+  static DiyFp Times(const DiyFp& a, const DiyFp& b) {\n+    DiyFp result = a;\n+    result.Multiply(b);\n+    return result;\n+  }\n+\n+  void Normalize() {\n+    ASSERT(f_ != 0);\n+    uint64_t significand = f_;\n+    int exponent = e_;\n+\n+    // This method is mainly called for normalizing boundaries. In general\n+    // boundaries need to be shifted by 10 bits. We thus optimize for this case.\n+    const uint64_t k10MSBits = UINT64_2PART_C(0xFFC00000, 00000000);\n+    while ((significand & k10MSBits) == 0) {\n+      significand <<= 10;\n+      exponent -= 10;\n+    }\n+    while ((significand & kUint64MSB) == 0) {\n+      significand <<= 1;\n+      exponent--;\n+    }\n+    f_ = significand;\n+    e_ = exponent;\n+  }\n+\n+  static DiyFp Normalize(const DiyFp& a) {\n+    DiyFp result = a;\n+    result.Normalize();\n+    return result;\n+  }\n+\n+  uint64_t f() const { return f_; }\n+  int e() const { return e_; }\n+\n+  void set_f(uint64_t new_value) { f_ = new_value; }\n+  void set_e(int new_value) { e_ = new_value; }\n+\n+ private:\n+  static const uint64_t kUint64MSB = UINT64_2PART_C(0x80000000, 00000000);\n+\n+  uint64_t f_;\n+  int e_;\n+};\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+\n+#endif  // DOUBLE_CONVERSION_DIY_FP_H_\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "8d1499a79b4a2e553d71f7934604f1818483d7a7",
            "filename": "deps/icu-small/source/i18n/double-conversion-fast-dtoa.cpp",
            "status": "added",
            "additions": 683,
            "deletions": 0,
            "changes": 683,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-fast-dtoa.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-fast-dtoa.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-fast-dtoa.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,683 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2012 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-fast-dtoa.h\"\n+\n+#include \"double-conversion-cached-powers.h\"\n+#include \"double-conversion-diy-fp.h\"\n+#include \"double-conversion-ieee.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+// The minimal and maximal target exponent define the range of w's binary\n+// exponent, where 'w' is the result of multiplying the input by a cached power\n+// of ten.\n+//\n+// A different range might be chosen on a different platform, to optimize digit\n+// generation, but a smaller range requires more powers of ten to be cached.\n+static const int kMinimalTargetExponent = -60;\n+static const int kMaximalTargetExponent = -32;\n+\n+\n+// Adjusts the last digit of the generated number, and screens out generated\n+// solutions that may be inaccurate. A solution may be inaccurate if it is\n+// outside the safe interval, or if we cannot prove that it is closer to the\n+// input than a neighboring representation of the same length.\n+//\n+// Input: * buffer containing the digits of too_high / 10^kappa\n+//        * the buffer's length\n+//        * distance_too_high_w == (too_high - w).f() * unit\n+//        * unsafe_interval == (too_high - too_low).f() * unit\n+//        * rest = (too_high - buffer * 10^kappa).f() * unit\n+//        * ten_kappa = 10^kappa * unit\n+//        * unit = the common multiplier\n+// Output: returns true if the buffer is guaranteed to contain the closest\n+//    representable number to the input.\n+//  Modifies the generated digits in the buffer to approach (round towards) w.\n+static bool RoundWeed(Vector<char> buffer,\n+                      int length,\n+                      uint64_t distance_too_high_w,\n+                      uint64_t unsafe_interval,\n+                      uint64_t rest,\n+                      uint64_t ten_kappa,\n+                      uint64_t unit) {\n+  uint64_t small_distance = distance_too_high_w - unit;\n+  uint64_t big_distance = distance_too_high_w + unit;\n+  // Let w_low  = too_high - big_distance, and\n+  //     w_high = too_high - small_distance.\n+  // Note: w_low < w < w_high\n+  //\n+  // The real w (* unit) must lie somewhere inside the interval\n+  // ]w_low; w_high[ (often written as \"(w_low; w_high)\")\n+\n+  // Basically the buffer currently contains a number in the unsafe interval\n+  // ]too_low; too_high[ with too_low < w < too_high\n+  //\n+  //  too_high - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  //                     ^v 1 unit            ^      ^                 ^      ^\n+  //  boundary_high ---------------------     .      .                 .      .\n+  //                     ^v 1 unit            .      .                 .      .\n+  //   - - - - - - - - - - - - - - - - - - -  +  - - + - - - - - -     .      .\n+  //                                          .      .         ^       .      .\n+  //                                          .  big_distance  .       .      .\n+  //                                          .      .         .       .    rest\n+  //                              small_distance     .         .       .      .\n+  //                                          v      .         .       .      .\n+  //  w_high - - - - - - - - - - - - - - - - - -     .         .       .      .\n+  //                     ^v 1 unit                   .         .       .      .\n+  //  w ----------------------------------------     .         .       .      .\n+  //                     ^v 1 unit                   v         .       .      .\n+  //  w_low  - - - - - - - - - - - - - - - - - - - - -         .       .      .\n+  //                                                           .       .      v\n+  //  buffer --------------------------------------------------+-------+--------\n+  //                                                           .       .\n+  //                                                  safe_interval    .\n+  //                                                           v       .\n+  //   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     .\n+  //                     ^v 1 unit                                     .\n+  //  boundary_low -------------------------                     unsafe_interval\n+  //                     ^v 1 unit                                     v\n+  //  too_low  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+  //\n+  //\n+  // Note that the value of buffer could lie anywhere inside the range too_low\n+  // to too_high.\n+  //\n+  // boundary_low, boundary_high and w are approximations of the real boundaries\n+  // and v (the input number). They are guaranteed to be precise up to one unit.\n+  // In fact the error is guaranteed to be strictly less than one unit.\n+  //\n+  // Anything that lies outside the unsafe interval is guaranteed not to round\n+  // to v when read again.\n+  // Anything that lies inside the safe interval is guaranteed to round to v\n+  // when read again.\n+  // If the number inside the buffer lies inside the unsafe interval but not\n+  // inside the safe interval then we simply do not know and bail out (returning\n+  // false).\n+  //\n+  // Similarly we have to take into account the imprecision of 'w' when finding\n+  // the closest representation of 'w'. If we have two potential\n+  // representations, and one is closer to both w_low and w_high, then we know\n+  // it is closer to the actual value v.\n+  //\n+  // By generating the digits of too_high we got the largest (closest to\n+  // too_high) buffer that is still in the unsafe interval. In the case where\n+  // w_high < buffer < too_high we try to decrement the buffer.\n+  // This way the buffer approaches (rounds towards) w.\n+  // There are 3 conditions that stop the decrementation process:\n+  //   1) the buffer is already below w_high\n+  //   2) decrementing the buffer would make it leave the unsafe interval\n+  //   3) decrementing the buffer would yield a number below w_high and farther\n+  //      away than the current number. In other words:\n+  //              (buffer{-1} < w_high) && w_high - buffer{-1} > buffer - w_high\n+  // Instead of using the buffer directly we use its distance to too_high.\n+  // Conceptually rest ~= too_high - buffer\n+  // We need to do the following tests in this order to avoid over- and\n+  // underflows.\n+  ASSERT(rest <= unsafe_interval);\n+  while (rest < small_distance &&  // Negated condition 1\n+         unsafe_interval - rest >= ten_kappa &&  // Negated condition 2\n+         (rest + ten_kappa < small_distance ||  // buffer{-1} > w_high\n+          small_distance - rest >= rest + ten_kappa - small_distance)) {\n+    buffer[length - 1]--;\n+    rest += ten_kappa;\n+  }\n+\n+  // We have approached w+ as much as possible. We now test if approaching w-\n+  // would require changing the buffer. If yes, then we have two possible\n+  // representations close to w, but we cannot decide which one is closer.\n+  if (rest < big_distance &&\n+      unsafe_interval - rest >= ten_kappa &&\n+      (rest + ten_kappa < big_distance ||\n+       big_distance - rest > rest + ten_kappa - big_distance)) {\n+    return false;\n+  }\n+\n+  // Weeding test.\n+  //   The safe interval is [too_low + 2 ulp; too_high - 2 ulp]\n+  //   Since too_low = too_high - unsafe_interval this is equivalent to\n+  //      [too_high - unsafe_interval + 4 ulp; too_high - 2 ulp]\n+  //   Conceptually we have: rest ~= too_high - buffer\n+  return (2 * unit <= rest) && (rest <= unsafe_interval - 4 * unit);\n+}\n+\n+\n+// Rounds the buffer upwards if the result is closer to v by possibly adding\n+// 1 to the buffer. If the precision of the calculation is not sufficient to\n+// round correctly, return false.\n+// The rounding might shift the whole buffer in which case the kappa is\n+// adjusted. For example \"99\", kappa = 3 might become \"10\", kappa = 4.\n+//\n+// If 2*rest > ten_kappa then the buffer needs to be round up.\n+// rest can have an error of +/- 1 unit. This function accounts for the\n+// imprecision and returns false, if the rounding direction cannot be\n+// unambiguously determined.\n+//\n+// Precondition: rest < ten_kappa.\n+static bool RoundWeedCounted(Vector<char> buffer,\n+                             int length,\n+                             uint64_t rest,\n+                             uint64_t ten_kappa,\n+                             uint64_t unit,\n+                             int* kappa) {\n+  ASSERT(rest < ten_kappa);\n+  // The following tests are done in a specific order to avoid overflows. They\n+  // will work correctly with any uint64 values of rest < ten_kappa and unit.\n+  //\n+  // If the unit is too big, then we don't know which way to round. For example\n+  // a unit of 50 means that the real number lies within rest +/- 50. If\n+  // 10^kappa == 40 then there is no way to tell which way to round.\n+  if (unit >= ten_kappa) return false;\n+  // Even if unit is just half the size of 10^kappa we are already completely\n+  // lost. (And after the previous test we know that the expression will not\n+  // over/underflow.)\n+  if (ten_kappa - unit <= unit) return false;\n+  // If 2 * (rest + unit) <= 10^kappa we can safely round down.\n+  if ((ten_kappa - rest > rest) && (ten_kappa - 2 * rest >= 2 * unit)) {\n+    return true;\n+  }\n+  // If 2 * (rest - unit) >= 10^kappa, then we can safely round up.\n+  if ((rest > unit) && (ten_kappa - (rest - unit) <= (rest - unit))) {\n+    // Increment the last digit recursively until we find a non '9' digit.\n+    buffer[length - 1]++;\n+    for (int i = length - 1; i > 0; --i) {\n+      if (buffer[i] != '0' + 10) break;\n+      buffer[i] = '0';\n+      buffer[i - 1]++;\n+    }\n+    // If the first digit is now '0'+ 10 we had a buffer with all '9's. With the\n+    // exception of the first digit all digits are now '0'. Simply switch the\n+    // first digit to '1' and adjust the kappa. Example: \"99\" becomes \"10\" and\n+    // the power (the kappa) is increased.\n+    if (buffer[0] == '0' + 10) {\n+      buffer[0] = '1';\n+      (*kappa) += 1;\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n+// Returns the biggest power of ten that is less than or equal to the given\n+// number. We furthermore receive the maximum number of bits 'number' has.\n+//\n+// Returns power == 10^(exponent_plus_one-1) such that\n+//    power <= number < power * 10.\n+// If number_bits == 0 then 0^(0-1) is returned.\n+// The number of bits must be <= 32.\n+// Precondition: number < (1 << (number_bits + 1)).\n+\n+// Inspired by the method for finding an integer log base 10 from here:\n+// http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10\n+static unsigned int const kSmallPowersOfTen[] =\n+    {0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,\n+     1000000000};\n+\n+static void BiggestPowerTen(uint32_t number,\n+                            int number_bits,\n+                            uint32_t* power,\n+                            int* exponent_plus_one) {\n+  ASSERT(number < (1u << (number_bits + 1)));\n+  // 1233/4096 is approximately 1/lg(10).\n+  int exponent_plus_one_guess = ((number_bits + 1) * 1233 >> 12);\n+  // We increment to skip over the first entry in the kPowersOf10 table.\n+  // Note: kPowersOf10[i] == 10^(i-1).\n+  exponent_plus_one_guess++;\n+  // We don't have any guarantees that 2^number_bits <= number.\n+  if (number < kSmallPowersOfTen[exponent_plus_one_guess]) {\n+    exponent_plus_one_guess--;\n+  }\n+  *power = kSmallPowersOfTen[exponent_plus_one_guess];\n+  *exponent_plus_one = exponent_plus_one_guess;\n+}\n+\n+// Generates the digits of input number w.\n+// w is a floating-point number (DiyFp), consisting of a significand and an\n+// exponent. Its exponent is bounded by kMinimalTargetExponent and\n+// kMaximalTargetExponent.\n+//       Hence -60 <= w.e() <= -32.\n+//\n+// Returns false if it fails, in which case the generated digits in the buffer\n+// should not be used.\n+// Preconditions:\n+//  * low, w and high are correct up to 1 ulp (unit in the last place). That\n+//    is, their error must be less than a unit of their last digits.\n+//  * low.e() == w.e() == high.e()\n+//  * low < w < high, and taking into account their error: low~ <= high~\n+//  * kMinimalTargetExponent <= w.e() <= kMaximalTargetExponent\n+// Postconditions: returns false if procedure fails.\n+//   otherwise:\n+//     * buffer is not null-terminated, but len contains the number of digits.\n+//     * buffer contains the shortest possible decimal digit-sequence\n+//       such that LOW < buffer * 10^kappa < HIGH, where LOW and HIGH are the\n+//       correct values of low and high (without their error).\n+//     * if more than one decimal representation gives the minimal number of\n+//       decimal digits then the one closest to W (where W is the correct value\n+//       of w) is chosen.\n+// Remark: this procedure takes into account the imprecision of its input\n+//   numbers. If the precision is not enough to guarantee all the postconditions\n+//   then false is returned. This usually happens rarely (~0.5%).\n+//\n+// Say, for the sake of example, that\n+//   w.e() == -48, and w.f() == 0x1234567890abcdef\n+// w's value can be computed by w.f() * 2^w.e()\n+// We can obtain w's integral digits by simply shifting w.f() by -w.e().\n+//  -> w's integral part is 0x1234\n+//  w's fractional part is therefore 0x567890abcdef.\n+// Printing w's integral part is easy (simply print 0x1234 in decimal).\n+// In order to print its fraction we repeatedly multiply the fraction by 10 and\n+// get each digit. Example the first digit after the point would be computed by\n+//   (0x567890abcdef * 10) >> 48. -> 3\n+// The whole thing becomes slightly more complicated because we want to stop\n+// once we have enough digits. That is, once the digits inside the buffer\n+// represent 'w' we can stop. Everything inside the interval low - high\n+// represents w. However we have to pay attention to low, high and w's\n+// imprecision.\n+static bool DigitGen(DiyFp low,\n+                     DiyFp w,\n+                     DiyFp high,\n+                     Vector<char> buffer,\n+                     int* length,\n+                     int* kappa) {\n+  ASSERT(low.e() == w.e() && w.e() == high.e());\n+  ASSERT(low.f() + 1 <= high.f() - 1);\n+  ASSERT(kMinimalTargetExponent <= w.e() && w.e() <= kMaximalTargetExponent);\n+  // low, w and high are imprecise, but by less than one ulp (unit in the last\n+  // place).\n+  // If we remove (resp. add) 1 ulp from low (resp. high) we are certain that\n+  // the new numbers are outside of the interval we want the final\n+  // representation to lie in.\n+  // Inversely adding (resp. removing) 1 ulp from low (resp. high) would yield\n+  // numbers that are certain to lie in the interval. We will use this fact\n+  // later on.\n+  // We will now start by generating the digits within the uncertain\n+  // interval. Later we will weed out representations that lie outside the safe\n+  // interval and thus _might_ lie outside the correct interval.\n+  uint64_t unit = 1;\n+  DiyFp too_low = DiyFp(low.f() - unit, low.e());\n+  DiyFp too_high = DiyFp(high.f() + unit, high.e());\n+  // too_low and too_high are guaranteed to lie outside the interval we want the\n+  // generated number in.\n+  DiyFp unsafe_interval = DiyFp::Minus(too_high, too_low);\n+  // We now cut the input number into two parts: the integral digits and the\n+  // fractionals. We will not write any decimal separator though, but adapt\n+  // kappa instead.\n+  // Reminder: we are currently computing the digits (stored inside the buffer)\n+  // such that:   too_low < buffer * 10^kappa < too_high\n+  // We use too_high for the digit_generation and stop as soon as possible.\n+  // If we stop early we effectively round down.\n+  DiyFp one = DiyFp(static_cast<uint64_t>(1) << -w.e(), w.e());\n+  // Division by one is a shift.\n+  uint32_t integrals = static_cast<uint32_t>(too_high.f() >> -one.e());\n+  // Modulo by one is an and.\n+  uint64_t fractionals = too_high.f() & (one.f() - 1);\n+  uint32_t divisor;\n+  int divisor_exponent_plus_one;\n+  BiggestPowerTen(integrals, DiyFp::kSignificandSize - (-one.e()),\n+                  &divisor, &divisor_exponent_plus_one);\n+  *kappa = divisor_exponent_plus_one;\n+  *length = 0;\n+  // Loop invariant: buffer = too_high / 10^kappa  (integer division)\n+  // The invariant holds for the first iteration: kappa has been initialized\n+  // with the divisor exponent + 1. And the divisor is the biggest power of ten\n+  // that is smaller than integrals.\n+  while (*kappa > 0) {\n+    int digit = integrals / divisor;\n+    ASSERT(digit <= 9);\n+    buffer[*length] = static_cast<char>('0' + digit);\n+    (*length)++;\n+    integrals %= divisor;\n+    (*kappa)--;\n+    // Note that kappa now equals the exponent of the divisor and that the\n+    // invariant thus holds again.\n+    uint64_t rest =\n+        (static_cast<uint64_t>(integrals) << -one.e()) + fractionals;\n+    // Invariant: too_high = buffer * 10^kappa + DiyFp(rest, one.e())\n+    // Reminder: unsafe_interval.e() == one.e()\n+    if (rest < unsafe_interval.f()) {\n+      // Rounding down (by not emitting the remaining digits) yields a number\n+      // that lies within the unsafe interval.\n+      return RoundWeed(buffer, *length, DiyFp::Minus(too_high, w).f(),\n+                       unsafe_interval.f(), rest,\n+                       static_cast<uint64_t>(divisor) << -one.e(), unit);\n+    }\n+    divisor /= 10;\n+  }\n+\n+  // The integrals have been generated. We are at the point of the decimal\n+  // separator. In the following loop we simply multiply the remaining digits by\n+  // 10 and divide by one. We just need to pay attention to multiply associated\n+  // data (like the interval or 'unit'), too.\n+  // Note that the multiplication by 10 does not overflow, because w.e >= -60\n+  // and thus one.e >= -60.\n+  ASSERT(one.e() >= -60);\n+  ASSERT(fractionals < one.f());\n+  ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 >= one.f());\n+  for (;;) {\n+    fractionals *= 10;\n+    unit *= 10;\n+    unsafe_interval.set_f(unsafe_interval.f() * 10);\n+    // Integer division by one.\n+    int digit = static_cast<int>(fractionals >> -one.e());\n+    ASSERT(digit <= 9);\n+    buffer[*length] = static_cast<char>('0' + digit);\n+    (*length)++;\n+    fractionals &= one.f() - 1;  // Modulo by one.\n+    (*kappa)--;\n+    if (fractionals < unsafe_interval.f()) {\n+      return RoundWeed(buffer, *length, DiyFp::Minus(too_high, w).f() * unit,\n+                       unsafe_interval.f(), fractionals, one.f(), unit);\n+    }\n+  }\n+}\n+\n+\n+\n+// Generates (at most) requested_digits digits of input number w.\n+// w is a floating-point number (DiyFp), consisting of a significand and an\n+// exponent. Its exponent is bounded by kMinimalTargetExponent and\n+// kMaximalTargetExponent.\n+//       Hence -60 <= w.e() <= -32.\n+//\n+// Returns false if it fails, in which case the generated digits in the buffer\n+// should not be used.\n+// Preconditions:\n+//  * w is correct up to 1 ulp (unit in the last place). That\n+//    is, its error must be strictly less than a unit of its last digit.\n+//  * kMinimalTargetExponent <= w.e() <= kMaximalTargetExponent\n+//\n+// Postconditions: returns false if procedure fails.\n+//   otherwise:\n+//     * buffer is not null-terminated, but length contains the number of\n+//       digits.\n+//     * the representation in buffer is the most precise representation of\n+//       requested_digits digits.\n+//     * buffer contains at most requested_digits digits of w. If there are less\n+//       than requested_digits digits then some trailing '0's have been removed.\n+//     * kappa is such that\n+//            w = buffer * 10^kappa + eps with |eps| < 10^kappa / 2.\n+//\n+// Remark: This procedure takes into account the imprecision of its input\n+//   numbers. If the precision is not enough to guarantee all the postconditions\n+//   then false is returned. This usually happens rarely, but the failure-rate\n+//   increases with higher requested_digits.\n+static bool DigitGenCounted(DiyFp w,\n+                            int requested_digits,\n+                            Vector<char> buffer,\n+                            int* length,\n+                            int* kappa) {\n+  ASSERT(kMinimalTargetExponent <= w.e() && w.e() <= kMaximalTargetExponent);\n+  ASSERT(kMinimalTargetExponent >= -60);\n+  ASSERT(kMaximalTargetExponent <= -32);\n+  // w is assumed to have an error less than 1 unit. Whenever w is scaled we\n+  // also scale its error.\n+  uint64_t w_error = 1;\n+  // We cut the input number into two parts: the integral digits and the\n+  // fractional digits. We don't emit any decimal separator, but adapt kappa\n+  // instead. Example: instead of writing \"1.2\" we put \"12\" into the buffer and\n+  // increase kappa by 1.\n+  DiyFp one = DiyFp(static_cast<uint64_t>(1) << -w.e(), w.e());\n+  // Division by one is a shift.\n+  uint32_t integrals = static_cast<uint32_t>(w.f() >> -one.e());\n+  // Modulo by one is an and.\n+  uint64_t fractionals = w.f() & (one.f() - 1);\n+  uint32_t divisor;\n+  int divisor_exponent_plus_one;\n+  BiggestPowerTen(integrals, DiyFp::kSignificandSize - (-one.e()),\n+                  &divisor, &divisor_exponent_plus_one);\n+  *kappa = divisor_exponent_plus_one;\n+  *length = 0;\n+\n+  // Loop invariant: buffer = w / 10^kappa  (integer division)\n+  // The invariant holds for the first iteration: kappa has been initialized\n+  // with the divisor exponent + 1. And the divisor is the biggest power of ten\n+  // that is smaller than 'integrals'.\n+  while (*kappa > 0) {\n+    int digit = integrals / divisor;\n+    ASSERT(digit <= 9);\n+    buffer[*length] = static_cast<char>('0' + digit);\n+    (*length)++;\n+    requested_digits--;\n+    integrals %= divisor;\n+    (*kappa)--;\n+    // Note that kappa now equals the exponent of the divisor and that the\n+    // invariant thus holds again.\n+    if (requested_digits == 0) break;\n+    divisor /= 10;\n+  }\n+\n+  if (requested_digits == 0) {\n+    uint64_t rest =\n+        (static_cast<uint64_t>(integrals) << -one.e()) + fractionals;\n+    return RoundWeedCounted(buffer, *length, rest,\n+                            static_cast<uint64_t>(divisor) << -one.e(), w_error,\n+                            kappa);\n+  }\n+\n+  // The integrals have been generated. We are at the point of the decimal\n+  // separator. In the following loop we simply multiply the remaining digits by\n+  // 10 and divide by one. We just need to pay attention to multiply associated\n+  // data (the 'unit'), too.\n+  // Note that the multiplication by 10 does not overflow, because w.e >= -60\n+  // and thus one.e >= -60.\n+  ASSERT(one.e() >= -60);\n+  ASSERT(fractionals < one.f());\n+  ASSERT(UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF) / 10 >= one.f());\n+  while (requested_digits > 0 && fractionals > w_error) {\n+    fractionals *= 10;\n+    w_error *= 10;\n+    // Integer division by one.\n+    int digit = static_cast<int>(fractionals >> -one.e());\n+    ASSERT(digit <= 9);\n+    buffer[*length] = static_cast<char>('0' + digit);\n+    (*length)++;\n+    requested_digits--;\n+    fractionals &= one.f() - 1;  // Modulo by one.\n+    (*kappa)--;\n+  }\n+  if (requested_digits != 0) return false;\n+  return RoundWeedCounted(buffer, *length, fractionals, one.f(), w_error,\n+                          kappa);\n+}\n+\n+\n+// Provides a decimal representation of v.\n+// Returns true if it succeeds, otherwise the result cannot be trusted.\n+// There will be *length digits inside the buffer (not null-terminated).\n+// If the function returns true then\n+//        v == (double) (buffer * 10^decimal_exponent).\n+// The digits in the buffer are the shortest representation possible: no\n+// 0.09999999999999999 instead of 0.1. The shorter representation will even be\n+// chosen even if the longer one would be closer to v.\n+// The last digit will be closest to the actual v. That is, even if several\n+// digits might correctly yield 'v' when read again, the closest will be\n+// computed.\n+static bool Grisu3(double v,\n+                   FastDtoaMode mode,\n+                   Vector<char> buffer,\n+                   int* length,\n+                   int* decimal_exponent) {\n+  DiyFp w = Double(v).AsNormalizedDiyFp();\n+  // boundary_minus and boundary_plus are the boundaries between v and its\n+  // closest floating-point neighbors. Any number strictly between\n+  // boundary_minus and boundary_plus will round to v when convert to a double.\n+  // Grisu3 will never output representations that lie exactly on a boundary.\n+  DiyFp boundary_minus, boundary_plus;\n+  if (mode == FAST_DTOA_SHORTEST) {\n+    Double(v).NormalizedBoundaries(&boundary_minus, &boundary_plus);\n+  } else {\n+    ASSERT(mode == FAST_DTOA_SHORTEST_SINGLE);\n+    float single_v = static_cast<float>(v);\n+    Single(single_v).NormalizedBoundaries(&boundary_minus, &boundary_plus);\n+  }\n+  ASSERT(boundary_plus.e() == w.e());\n+  DiyFp ten_mk;  // Cached power of ten: 10^-k\n+  int mk;        // -k\n+  int ten_mk_minimal_binary_exponent =\n+     kMinimalTargetExponent - (w.e() + DiyFp::kSignificandSize);\n+  int ten_mk_maximal_binary_exponent =\n+     kMaximalTargetExponent - (w.e() + DiyFp::kSignificandSize);\n+  PowersOfTenCache::GetCachedPowerForBinaryExponentRange(\n+      ten_mk_minimal_binary_exponent,\n+      ten_mk_maximal_binary_exponent,\n+      &ten_mk, &mk);\n+  ASSERT((kMinimalTargetExponent <= w.e() + ten_mk.e() +\n+          DiyFp::kSignificandSize) &&\n+         (kMaximalTargetExponent >= w.e() + ten_mk.e() +\n+          DiyFp::kSignificandSize));\n+  // Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a\n+  // 64 bit significand and ten_mk is thus only precise up to 64 bits.\n+\n+  // The DiyFp::Times procedure rounds its result, and ten_mk is approximated\n+  // too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now\n+  // off by a small amount.\n+  // In fact: scaled_w - w*10^k < 1ulp (unit in the last place) of scaled_w.\n+  // In other words: let f = scaled_w.f() and e = scaled_w.e(), then\n+  //           (f-1) * 2^e < w*10^k < (f+1) * 2^e\n+  DiyFp scaled_w = DiyFp::Times(w, ten_mk);\n+  ASSERT(scaled_w.e() ==\n+         boundary_plus.e() + ten_mk.e() + DiyFp::kSignificandSize);\n+  // In theory it would be possible to avoid some recomputations by computing\n+  // the difference between w and boundary_minus/plus (a power of 2) and to\n+  // compute scaled_boundary_minus/plus by subtracting/adding from\n+  // scaled_w. However the code becomes much less readable and the speed\n+  // enhancements are not terriffic.\n+  DiyFp scaled_boundary_minus = DiyFp::Times(boundary_minus, ten_mk);\n+  DiyFp scaled_boundary_plus  = DiyFp::Times(boundary_plus,  ten_mk);\n+\n+  // DigitGen will generate the digits of scaled_w. Therefore we have\n+  // v == (double) (scaled_w * 10^-mk).\n+  // Set decimal_exponent == -mk and pass it to DigitGen. If scaled_w is not an\n+  // integer than it will be updated. For instance if scaled_w == 1.23 then\n+  // the buffer will be filled with \"123\" und the decimal_exponent will be\n+  // decreased by 2.\n+  int kappa;\n+  bool result = DigitGen(scaled_boundary_minus, scaled_w, scaled_boundary_plus,\n+                         buffer, length, &kappa);\n+  *decimal_exponent = -mk + kappa;\n+  return result;\n+}\n+\n+\n+// The \"counted\" version of grisu3 (see above) only generates requested_digits\n+// number of digits. This version does not generate the shortest representation,\n+// and with enough requested digits 0.1 will at some point print as 0.9999999...\n+// Grisu3 is too imprecise for real halfway cases (1.5 will not work) and\n+// therefore the rounding strategy for halfway cases is irrelevant.\n+static bool Grisu3Counted(double v,\n+                          int requested_digits,\n+                          Vector<char> buffer,\n+                          int* length,\n+                          int* decimal_exponent) {\n+  DiyFp w = Double(v).AsNormalizedDiyFp();\n+  DiyFp ten_mk;  // Cached power of ten: 10^-k\n+  int mk;        // -k\n+  int ten_mk_minimal_binary_exponent =\n+     kMinimalTargetExponent - (w.e() + DiyFp::kSignificandSize);\n+  int ten_mk_maximal_binary_exponent =\n+     kMaximalTargetExponent - (w.e() + DiyFp::kSignificandSize);\n+  PowersOfTenCache::GetCachedPowerForBinaryExponentRange(\n+      ten_mk_minimal_binary_exponent,\n+      ten_mk_maximal_binary_exponent,\n+      &ten_mk, &mk);\n+  ASSERT((kMinimalTargetExponent <= w.e() + ten_mk.e() +\n+          DiyFp::kSignificandSize) &&\n+         (kMaximalTargetExponent >= w.e() + ten_mk.e() +\n+          DiyFp::kSignificandSize));\n+  // Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a\n+  // 64 bit significand and ten_mk is thus only precise up to 64 bits.\n+\n+  // The DiyFp::Times procedure rounds its result, and ten_mk is approximated\n+  // too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now\n+  // off by a small amount.\n+  // In fact: scaled_w - w*10^k < 1ulp (unit in the last place) of scaled_w.\n+  // In other words: let f = scaled_w.f() and e = scaled_w.e(), then\n+  //           (f-1) * 2^e < w*10^k < (f+1) * 2^e\n+  DiyFp scaled_w = DiyFp::Times(w, ten_mk);\n+\n+  // We now have (double) (scaled_w * 10^-mk).\n+  // DigitGen will generate the first requested_digits digits of scaled_w and\n+  // return together with a kappa such that scaled_w ~= buffer * 10^kappa. (It\n+  // will not always be exactly the same since DigitGenCounted only produces a\n+  // limited number of digits.)\n+  int kappa;\n+  bool result = DigitGenCounted(scaled_w, requested_digits,\n+                                buffer, length, &kappa);\n+  *decimal_exponent = -mk + kappa;\n+  return result;\n+}\n+\n+\n+bool FastDtoa(double v,\n+              FastDtoaMode mode,\n+              int requested_digits,\n+              Vector<char> buffer,\n+              int* length,\n+              int* decimal_point) {\n+  ASSERT(v > 0);\n+  ASSERT(!Double(v).IsSpecial());\n+\n+  bool result = false;\n+  int decimal_exponent = 0;\n+  switch (mode) {\n+    case FAST_DTOA_SHORTEST:\n+    case FAST_DTOA_SHORTEST_SINGLE:\n+      result = Grisu3(v, mode, buffer, length, &decimal_exponent);\n+      break;\n+    case FAST_DTOA_PRECISION:\n+      result = Grisu3Counted(v, requested_digits,\n+                             buffer, length, &decimal_exponent);\n+      break;\n+    default:\n+      UNREACHABLE();\n+  }\n+  if (result) {\n+    *decimal_point = *length + decimal_exponent;\n+    buffer[*length] = '\\0';\n+  }\n+  return result;\n+}\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "58a6470052c63c495c4a05627949dc88724b12fc",
            "filename": "deps/icu-small/source/i18n/double-conversion-fast-dtoa.h",
            "status": "added",
            "additions": 106,
            "deletions": 0,
            "changes": 106,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-fast-dtoa.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-fast-dtoa.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-fast-dtoa.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,106 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#ifndef DOUBLE_CONVERSION_FAST_DTOA_H_\n+#define DOUBLE_CONVERSION_FAST_DTOA_H_\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-utils.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+enum FastDtoaMode {\n+  // Computes the shortest representation of the given input. The returned\n+  // result will be the most accurate number of this length. Longer\n+  // representations might be more accurate.\n+  FAST_DTOA_SHORTEST,\n+  // Same as FAST_DTOA_SHORTEST but for single-precision floats.\n+  FAST_DTOA_SHORTEST_SINGLE,\n+  // Computes a representation where the precision (number of digits) is\n+  // given as input. The precision is independent of the decimal point.\n+  FAST_DTOA_PRECISION\n+};\n+\n+// FastDtoa will produce at most kFastDtoaMaximalLength digits. This does not\n+// include the terminating '\\0' character.\n+static const int kFastDtoaMaximalLength = 17;\n+// Same for single-precision numbers.\n+static const int kFastDtoaMaximalSingleLength = 9;\n+\n+// Provides a decimal representation of v.\n+// The result should be interpreted as buffer * 10^(point - length).\n+//\n+// Precondition:\n+//   * v must be a strictly positive finite double.\n+//\n+// Returns true if it succeeds, otherwise the result can not be trusted.\n+// There will be *length digits inside the buffer followed by a null terminator.\n+// If the function returns true and mode equals\n+//   - FAST_DTOA_SHORTEST, then\n+//     the parameter requested_digits is ignored.\n+//     The result satisfies\n+//         v == (double) (buffer * 10^(point - length)).\n+//     The digits in the buffer are the shortest representation possible. E.g.\n+//     if 0.099999999999 and 0.1 represent the same double then \"1\" is returned\n+//     with point = 0.\n+//     The last digit will be closest to the actual v. That is, even if several\n+//     digits might correctly yield 'v' when read again, the buffer will contain\n+//     the one closest to v.\n+//   - FAST_DTOA_PRECISION, then\n+//     the buffer contains requested_digits digits.\n+//     the difference v - (buffer * 10^(point-length)) is closest to zero for\n+//     all possible representations of requested_digits digits.\n+//     If there are two values that are equally close, then FastDtoa returns\n+//     false.\n+// For both modes the buffer must be large enough to hold the result.\n+bool FastDtoa(double d,\n+              FastDtoaMode mode,\n+              int requested_digits,\n+              Vector<char> buffer,\n+              int* length,\n+              int* decimal_point);\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+\n+#endif  // DOUBLE_CONVERSION_FAST_DTOA_H_\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "952bcea27f6615cba56f2b5d558e0d263c64c5ec",
            "filename": "deps/icu-small/source/i18n/double-conversion-ieee.h",
            "status": "added",
            "additions": 420,
            "deletions": 0,
            "changes": 420,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-ieee.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-ieee.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-ieee.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,420 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2012 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#ifndef DOUBLE_CONVERSION_DOUBLE_H_\n+#define DOUBLE_CONVERSION_DOUBLE_H_\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-diy-fp.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+// We assume that doubles and uint64_t have the same endianness.\n+static uint64_t double_to_uint64(double d) { return BitCast<uint64_t>(d); }\n+static double uint64_to_double(uint64_t d64) { return BitCast<double>(d64); }\n+static uint32_t float_to_uint32(float f) { return BitCast<uint32_t>(f); }\n+static float uint32_to_float(uint32_t d32) { return BitCast<float>(d32); }\n+\n+// Helper functions for doubles.\n+class Double {\n+ public:\n+  static const uint64_t kSignMask = UINT64_2PART_C(0x80000000, 00000000);\n+  static const uint64_t kExponentMask = UINT64_2PART_C(0x7FF00000, 00000000);\n+  static const uint64_t kSignificandMask = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);\n+  static const uint64_t kHiddenBit = UINT64_2PART_C(0x00100000, 00000000);\n+  static const int kPhysicalSignificandSize = 52;  // Excludes the hidden bit.\n+  static const int kSignificandSize = 53;\n+\n+  Double() : d64_(0) {}\n+  explicit Double(double d) : d64_(double_to_uint64(d)) {}\n+  explicit Double(uint64_t d64) : d64_(d64) {}\n+  explicit Double(DiyFp diy_fp)\n+    : d64_(DiyFpToUint64(diy_fp)) {}\n+\n+  // The value encoded by this Double must be greater or equal to +0.0.\n+  // It must not be special (infinity, or NaN).\n+  DiyFp AsDiyFp() const {\n+    ASSERT(Sign() > 0);\n+    ASSERT(!IsSpecial());\n+    return DiyFp(Significand(), Exponent());\n+  }\n+\n+  // The value encoded by this Double must be strictly greater than 0.\n+  DiyFp AsNormalizedDiyFp() const {\n+    ASSERT(value() > 0.0);\n+    uint64_t f = Significand();\n+    int e = Exponent();\n+\n+    // The current double could be a denormal.\n+    while ((f & kHiddenBit) == 0) {\n+      f <<= 1;\n+      e--;\n+    }\n+    // Do the final shifts in one go.\n+    f <<= DiyFp::kSignificandSize - kSignificandSize;\n+    e -= DiyFp::kSignificandSize - kSignificandSize;\n+    return DiyFp(f, e);\n+  }\n+\n+  // Returns the double's bit as uint64.\n+  uint64_t AsUint64() const {\n+    return d64_;\n+  }\n+\n+  // Returns the next greater double. Returns +infinity on input +infinity.\n+  double NextDouble() const {\n+    if (d64_ == kInfinity) return Double(kInfinity).value();\n+    if (Sign() < 0 && Significand() == 0) {\n+      // -0.0\n+      return 0.0;\n+    }\n+    if (Sign() < 0) {\n+      return Double(d64_ - 1).value();\n+    } else {\n+      return Double(d64_ + 1).value();\n+    }\n+  }\n+\n+  double PreviousDouble() const {\n+    if (d64_ == (kInfinity | kSignMask)) return -Infinity();\n+    if (Sign() < 0) {\n+      return Double(d64_ + 1).value();\n+    } else {\n+      if (Significand() == 0) return -0.0;\n+      return Double(d64_ - 1).value();\n+    }\n+  }\n+\n+  int Exponent() const {\n+    if (IsDenormal()) return kDenormalExponent;\n+\n+    uint64_t d64 = AsUint64();\n+    int biased_e =\n+        static_cast<int>((d64 & kExponentMask) >> kPhysicalSignificandSize);\n+    return biased_e - kExponentBias;\n+  }\n+\n+  uint64_t Significand() const {\n+    uint64_t d64 = AsUint64();\n+    uint64_t significand = d64 & kSignificandMask;\n+    if (!IsDenormal()) {\n+      return significand + kHiddenBit;\n+    } else {\n+      return significand;\n+    }\n+  }\n+\n+  // Returns true if the double is a denormal.\n+  bool IsDenormal() const {\n+    uint64_t d64 = AsUint64();\n+    return (d64 & kExponentMask) == 0;\n+  }\n+\n+  // We consider denormals not to be special.\n+  // Hence only Infinity and NaN are special.\n+  bool IsSpecial() const {\n+    uint64_t d64 = AsUint64();\n+    return (d64 & kExponentMask) == kExponentMask;\n+  }\n+\n+  bool IsNan() const {\n+    uint64_t d64 = AsUint64();\n+    return ((d64 & kExponentMask) == kExponentMask) &&\n+        ((d64 & kSignificandMask) != 0);\n+  }\n+\n+  bool IsInfinite() const {\n+    uint64_t d64 = AsUint64();\n+    return ((d64 & kExponentMask) == kExponentMask) &&\n+        ((d64 & kSignificandMask) == 0);\n+  }\n+\n+  int Sign() const {\n+    uint64_t d64 = AsUint64();\n+    return (d64 & kSignMask) == 0? 1: -1;\n+  }\n+\n+  // Precondition: the value encoded by this Double must be greater or equal\n+  // than +0.0.\n+  DiyFp UpperBoundary() const {\n+    ASSERT(Sign() > 0);\n+    return DiyFp(Significand() * 2 + 1, Exponent() - 1);\n+  }\n+\n+  // Computes the two boundaries of this.\n+  // The bigger boundary (m_plus) is normalized. The lower boundary has the same\n+  // exponent as m_plus.\n+  // Precondition: the value encoded by this Double must be greater than 0.\n+  void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {\n+    ASSERT(value() > 0.0);\n+    DiyFp v = this->AsDiyFp();\n+    DiyFp m_plus = DiyFp::Normalize(DiyFp((v.f() << 1) + 1, v.e() - 1));\n+    DiyFp m_minus;\n+    if (LowerBoundaryIsCloser()) {\n+      m_minus = DiyFp((v.f() << 2) - 1, v.e() - 2);\n+    } else {\n+      m_minus = DiyFp((v.f() << 1) - 1, v.e() - 1);\n+    }\n+    m_minus.set_f(m_minus.f() << (m_minus.e() - m_plus.e()));\n+    m_minus.set_e(m_plus.e());\n+    *out_m_plus = m_plus;\n+    *out_m_minus = m_minus;\n+  }\n+\n+  bool LowerBoundaryIsCloser() const {\n+    // The boundary is closer if the significand is of the form f == 2^p-1 then\n+    // the lower boundary is closer.\n+    // Think of v = 1000e10 and v- = 9999e9.\n+    // Then the boundary (== (v - v-)/2) is not just at a distance of 1e9 but\n+    // at a distance of 1e8.\n+    // The only exception is for the smallest normal: the largest denormal is\n+    // at the same distance as its successor.\n+    // Note: denormals have the same exponent as the smallest normals.\n+    bool physical_significand_is_zero = ((AsUint64() & kSignificandMask) == 0);\n+    return physical_significand_is_zero && (Exponent() != kDenormalExponent);\n+  }\n+\n+  double value() const { return uint64_to_double(d64_); }\n+\n+  // Returns the significand size for a given order of magnitude.\n+  // If v = f*2^e with 2^p-1 <= f <= 2^p then p+e is v's order of magnitude.\n+  // This function returns the number of significant binary digits v will have\n+  // once it's encoded into a double. In almost all cases this is equal to\n+  // kSignificandSize. The only exceptions are denormals. They start with\n+  // leading zeroes and their effective significand-size is hence smaller.\n+  static int SignificandSizeForOrderOfMagnitude(int order) {\n+    if (order >= (kDenormalExponent + kSignificandSize)) {\n+      return kSignificandSize;\n+    }\n+    if (order <= kDenormalExponent) return 0;\n+    return order - kDenormalExponent;\n+  }\n+\n+  static double Infinity() {\n+    return Double(kInfinity).value();\n+  }\n+\n+  static double NaN() {\n+    return Double(kNaN).value();\n+  }\n+\n+ private:\n+  static const int kExponentBias = 0x3FF + kPhysicalSignificandSize;\n+  static const int kDenormalExponent = -kExponentBias + 1;\n+  static const int kMaxExponent = 0x7FF - kExponentBias;\n+  static const uint64_t kInfinity = UINT64_2PART_C(0x7FF00000, 00000000);\n+  static const uint64_t kNaN = UINT64_2PART_C(0x7FF80000, 00000000);\n+\n+  const uint64_t d64_;\n+\n+  static uint64_t DiyFpToUint64(DiyFp diy_fp) {\n+    uint64_t significand = diy_fp.f();\n+    int exponent = diy_fp.e();\n+    while (significand > kHiddenBit + kSignificandMask) {\n+      significand >>= 1;\n+      exponent++;\n+    }\n+    if (exponent >= kMaxExponent) {\n+      return kInfinity;\n+    }\n+    if (exponent < kDenormalExponent) {\n+      return 0;\n+    }\n+    while (exponent > kDenormalExponent && (significand & kHiddenBit) == 0) {\n+      significand <<= 1;\n+      exponent--;\n+    }\n+    uint64_t biased_exponent;\n+    if (exponent == kDenormalExponent && (significand & kHiddenBit) == 0) {\n+      biased_exponent = 0;\n+    } else {\n+      biased_exponent = static_cast<uint64_t>(exponent + kExponentBias);\n+    }\n+    return (significand & kSignificandMask) |\n+        (biased_exponent << kPhysicalSignificandSize);\n+  }\n+\n+  DISALLOW_COPY_AND_ASSIGN(Double);\n+};\n+\n+class Single {\n+ public:\n+  static const uint32_t kSignMask = 0x80000000;\n+  static const uint32_t kExponentMask = 0x7F800000;\n+  static const uint32_t kSignificandMask = 0x007FFFFF;\n+  static const uint32_t kHiddenBit = 0x00800000;\n+  static const int kPhysicalSignificandSize = 23;  // Excludes the hidden bit.\n+  static const int kSignificandSize = 24;\n+\n+  Single() : d32_(0) {}\n+  explicit Single(float f) : d32_(float_to_uint32(f)) {}\n+  explicit Single(uint32_t d32) : d32_(d32) {}\n+\n+  // The value encoded by this Single must be greater or equal to +0.0.\n+  // It must not be special (infinity, or NaN).\n+  DiyFp AsDiyFp() const {\n+    ASSERT(Sign() > 0);\n+    ASSERT(!IsSpecial());\n+    return DiyFp(Significand(), Exponent());\n+  }\n+\n+  // Returns the single's bit as uint64.\n+  uint32_t AsUint32() const {\n+    return d32_;\n+  }\n+\n+  int Exponent() const {\n+    if (IsDenormal()) return kDenormalExponent;\n+\n+    uint32_t d32 = AsUint32();\n+    int biased_e =\n+        static_cast<int>((d32 & kExponentMask) >> kPhysicalSignificandSize);\n+    return biased_e - kExponentBias;\n+  }\n+\n+  uint32_t Significand() const {\n+    uint32_t d32 = AsUint32();\n+    uint32_t significand = d32 & kSignificandMask;\n+    if (!IsDenormal()) {\n+      return significand + kHiddenBit;\n+    } else {\n+      return significand;\n+    }\n+  }\n+\n+  // Returns true if the single is a denormal.\n+  bool IsDenormal() const {\n+    uint32_t d32 = AsUint32();\n+    return (d32 & kExponentMask) == 0;\n+  }\n+\n+  // We consider denormals not to be special.\n+  // Hence only Infinity and NaN are special.\n+  bool IsSpecial() const {\n+    uint32_t d32 = AsUint32();\n+    return (d32 & kExponentMask) == kExponentMask;\n+  }\n+\n+  bool IsNan() const {\n+    uint32_t d32 = AsUint32();\n+    return ((d32 & kExponentMask) == kExponentMask) &&\n+        ((d32 & kSignificandMask) != 0);\n+  }\n+\n+  bool IsInfinite() const {\n+    uint32_t d32 = AsUint32();\n+    return ((d32 & kExponentMask) == kExponentMask) &&\n+        ((d32 & kSignificandMask) == 0);\n+  }\n+\n+  int Sign() const {\n+    uint32_t d32 = AsUint32();\n+    return (d32 & kSignMask) == 0? 1: -1;\n+  }\n+\n+  // Computes the two boundaries of this.\n+  // The bigger boundary (m_plus) is normalized. The lower boundary has the same\n+  // exponent as m_plus.\n+  // Precondition: the value encoded by this Single must be greater than 0.\n+  void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {\n+    ASSERT(value() > 0.0);\n+    DiyFp v = this->AsDiyFp();\n+    DiyFp m_plus = DiyFp::Normalize(DiyFp((v.f() << 1) + 1, v.e() - 1));\n+    DiyFp m_minus;\n+    if (LowerBoundaryIsCloser()) {\n+      m_minus = DiyFp((v.f() << 2) - 1, v.e() - 2);\n+    } else {\n+      m_minus = DiyFp((v.f() << 1) - 1, v.e() - 1);\n+    }\n+    m_minus.set_f(m_minus.f() << (m_minus.e() - m_plus.e()));\n+    m_minus.set_e(m_plus.e());\n+    *out_m_plus = m_plus;\n+    *out_m_minus = m_minus;\n+  }\n+\n+  // Precondition: the value encoded by this Single must be greater or equal\n+  // than +0.0.\n+  DiyFp UpperBoundary() const {\n+    ASSERT(Sign() > 0);\n+    return DiyFp(Significand() * 2 + 1, Exponent() - 1);\n+  }\n+\n+  bool LowerBoundaryIsCloser() const {\n+    // The boundary is closer if the significand is of the form f == 2^p-1 then\n+    // the lower boundary is closer.\n+    // Think of v = 1000e10 and v- = 9999e9.\n+    // Then the boundary (== (v - v-)/2) is not just at a distance of 1e9 but\n+    // at a distance of 1e8.\n+    // The only exception is for the smallest normal: the largest denormal is\n+    // at the same distance as its successor.\n+    // Note: denormals have the same exponent as the smallest normals.\n+    bool physical_significand_is_zero = ((AsUint32() & kSignificandMask) == 0);\n+    return physical_significand_is_zero && (Exponent() != kDenormalExponent);\n+  }\n+\n+  float value() const { return uint32_to_float(d32_); }\n+\n+  static float Infinity() {\n+    return Single(kInfinity).value();\n+  }\n+\n+  static float NaN() {\n+    return Single(kNaN).value();\n+  }\n+\n+ private:\n+  static const int kExponentBias = 0x7F + kPhysicalSignificandSize;\n+  static const int kDenormalExponent = -kExponentBias + 1;\n+  static const int kMaxExponent = 0xFF - kExponentBias;\n+  static const uint32_t kInfinity = 0x7F800000;\n+  static const uint32_t kNaN = 0x7FC00000;\n+\n+  const uint32_t d32_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(Single);\n+};\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+\n+#endif  // DOUBLE_CONVERSION_DOUBLE_H_\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "02795b4bc565ae9d08452e4c18c76e5c46998745",
            "filename": "deps/icu-small/source/i18n/double-conversion-utils.h",
            "status": "added",
            "additions": 358,
            "deletions": 0,
            "changes": 358,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-utils.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-utils.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion-utils.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,358 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#ifndef DOUBLE_CONVERSION_UTILS_H_\n+#define DOUBLE_CONVERSION_UTILS_H_\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+// ICU PATCH: Use U_ASSERT instead of <assert.h>\n+#include \"uassert.h\"\n+#define ASSERT U_ASSERT\n+\n+#ifndef UNIMPLEMENTED\n+#define UNIMPLEMENTED() (abort())\n+#endif\n+#ifndef DOUBLE_CONVERSION_NO_RETURN\n+#ifdef _MSC_VER\n+#define DOUBLE_CONVERSION_NO_RETURN __declspec(noreturn)\n+#else\n+#define DOUBLE_CONVERSION_NO_RETURN __attribute__((noreturn))\n+#endif\n+#endif\n+#ifndef UNREACHABLE\n+#ifdef _MSC_VER\n+void DOUBLE_CONVERSION_NO_RETURN abort_noreturn();\n+inline void abort_noreturn() { abort(); }\n+#define UNREACHABLE()   (abort_noreturn())\n+#else\n+#define UNREACHABLE()   (abort())\n+#endif\n+#endif\n+\n+\n+// Double operations detection based on target architecture.\n+// Linux uses a 80bit wide floating point stack on x86. This induces double\n+// rounding, which in turn leads to wrong results.\n+// An easy way to test if the floating-point operations are correct is to\n+// evaluate: 89255.0/1e22. If the floating-point stack is 64 bits wide then\n+// the result is equal to 89255e-22.\n+// The best way to test this, is to create a division-function and to compare\n+// the output of the division with the expected result. (Inlining must be\n+// disabled.)\n+// On Linux,x86 89255e-22 != Div_double(89255.0/1e22)\n+// ICU PATCH: Enable ARM builds for Windows with 'defined(_M_ARM)'.\n+#if defined(_M_X64) || defined(__x86_64__) || \\\n+    defined(__ARMEL__) || defined(__avr32__) || defined(_M_ARM) || \\\n+    defined(__hppa__) || defined(__ia64__) || \\\n+    defined(__mips__) || \\\n+    defined(__powerpc__) || defined(__ppc__) || defined(__ppc64__) || \\\n+    defined(_POWER) || defined(_ARCH_PPC) || defined(_ARCH_PPC64) || \\\n+    defined(__sparc__) || defined(__sparc) || defined(__s390__) || \\\n+    defined(__SH4__) || defined(__alpha__) || \\\n+    defined(_MIPS_ARCH_MIPS32R2) || \\\n+    defined(__AARCH64EL__) || defined(__aarch64__) || \\\n+    defined(__riscv)\n+#define DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS 1\n+#elif defined(__mc68000__)\n+#undef DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS\n+#elif defined(_M_IX86) || defined(__i386__) || defined(__i386)\n+#if defined(_WIN32)\n+// Windows uses a 64bit wide floating point stack.\n+#define DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS 1\n+#else\n+#undef DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS\n+#endif  // _WIN32\n+#else\n+#error Target architecture was not detected as supported by Double-Conversion.\n+#endif\n+\n+#if defined(__GNUC__)\n+#define DOUBLE_CONVERSION_UNUSED __attribute__((unused))\n+#else\n+#define DOUBLE_CONVERSION_UNUSED\n+#endif\n+\n+#if defined(_WIN32) && !defined(__MINGW32__)\n+\n+typedef signed char int8_t;\n+typedef unsigned char uint8_t;\n+typedef short int16_t;  // NOLINT\n+typedef unsigned short uint16_t;  // NOLINT\n+typedef int int32_t;\n+typedef unsigned int uint32_t;\n+typedef __int64 int64_t;\n+typedef unsigned __int64 uint64_t;\n+// intptr_t and friends are defined in crtdefs.h through stdio.h.\n+\n+#else\n+\n+#include <stdint.h>\n+\n+#endif\n+\n+typedef uint16_t uc16;\n+\n+// The following macro works on both 32 and 64-bit platforms.\n+// Usage: instead of writing 0x1234567890123456\n+//      write UINT64_2PART_C(0x12345678,90123456);\n+#define UINT64_2PART_C(a, b) (((static_cast<uint64_t>(a) << 32) + 0x##b##u))\n+\n+\n+// The expression ARRAY_SIZE(a) is a compile-time constant of type\n+// size_t which represents the number of elements of the given\n+// array. You should only use ARRAY_SIZE on statically allocated\n+// arrays.\n+#ifndef ARRAY_SIZE\n+#define ARRAY_SIZE(a)                                   \\\n+  ((sizeof(a) / sizeof(*(a))) /                         \\\n+  static_cast<size_t>(!(sizeof(a) % sizeof(*(a)))))\n+#endif\n+\n+// A macro to disallow the evil copy constructor and operator= functions\n+// This should be used in the private: declarations for a class\n+#ifndef DISALLOW_COPY_AND_ASSIGN\n+#define DISALLOW_COPY_AND_ASSIGN(TypeName)      \\\n+  TypeName(const TypeName&);                    \\\n+  void operator=(const TypeName&)\n+#endif\n+\n+// A macro to disallow all the implicit constructors, namely the\n+// default constructor, copy constructor and operator= functions.\n+//\n+// This should be used in the private: declarations for a class\n+// that wants to prevent anyone from instantiating it. This is\n+// especially useful for classes containing only static methods.\n+#ifndef DISALLOW_IMPLICIT_CONSTRUCTORS\n+#define DISALLOW_IMPLICIT_CONSTRUCTORS(TypeName) \\\n+  TypeName();                                    \\\n+  DISALLOW_COPY_AND_ASSIGN(TypeName)\n+#endif\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+static const int kCharSize = sizeof(char);\n+\n+// Returns the maximum of the two parameters.\n+template <typename T>\n+static T Max(T a, T b) {\n+  return a < b ? b : a;\n+}\n+\n+\n+// Returns the minimum of the two parameters.\n+template <typename T>\n+static T Min(T a, T b) {\n+  return a < b ? a : b;\n+}\n+\n+\n+inline int StrLength(const char* string) {\n+  size_t length = strlen(string);\n+  ASSERT(length == static_cast<size_t>(static_cast<int>(length)));\n+  return static_cast<int>(length);\n+}\n+\n+// This is a simplified version of V8's Vector class.\n+template <typename T>\n+class Vector {\n+ public:\n+  Vector() : start_(NULL), length_(0) {}\n+  Vector(T* data, int len) : start_(data), length_(len) {\n+    ASSERT(len == 0 || (len > 0 && data != NULL));\n+  }\n+\n+  // Returns a vector using the same backing storage as this one,\n+  // spanning from and including 'from', to but not including 'to'.\n+  Vector<T> SubVector(int from, int to) {\n+    ASSERT(to <= length_);\n+    ASSERT(from < to);\n+    ASSERT(0 <= from);\n+    return Vector<T>(start() + from, to - from);\n+  }\n+\n+  // Returns the length of the vector.\n+  int length() const { return length_; }\n+\n+  // Returns whether or not the vector is empty.\n+  bool is_empty() const { return length_ == 0; }\n+\n+  // Returns the pointer to the start of the data in the vector.\n+  T* start() const { return start_; }\n+\n+  // Access individual vector elements - checks bounds in debug mode.\n+  T& operator[](int index) const {\n+    ASSERT(0 <= index && index < length_);\n+    return start_[index];\n+  }\n+\n+  T& first() { return start_[0]; }\n+\n+  T& last() { return start_[length_ - 1]; }\n+\n+ private:\n+  T* start_;\n+  int length_;\n+};\n+\n+\n+// Helper class for building result strings in a character buffer. The\n+// purpose of the class is to use safe operations that checks the\n+// buffer bounds on all operations in debug mode.\n+class StringBuilder {\n+ public:\n+  StringBuilder(char* buffer, int buffer_size)\n+      : buffer_(buffer, buffer_size), position_(0) { }\n+\n+  ~StringBuilder() { if (!is_finalized()) Finalize(); }\n+\n+  int size() const { return buffer_.length(); }\n+\n+  // Get the current position in the builder.\n+  int position() const {\n+    ASSERT(!is_finalized());\n+    return position_;\n+  }\n+\n+  // Reset the position.\n+  void Reset() { position_ = 0; }\n+\n+  // Add a single character to the builder. It is not allowed to add\n+  // 0-characters; use the Finalize() method to terminate the string\n+  // instead.\n+  void AddCharacter(char c) {\n+    ASSERT(c != '\\0');\n+    ASSERT(!is_finalized() && position_ < buffer_.length());\n+    buffer_[position_++] = c;\n+  }\n+\n+  // Add an entire string to the builder. Uses strlen() internally to\n+  // compute the length of the input string.\n+  void AddString(const char* s) {\n+    AddSubstring(s, StrLength(s));\n+  }\n+\n+  // Add the first 'n' characters of the given string 's' to the\n+  // builder. The input string must have enough characters.\n+  void AddSubstring(const char* s, int n) {\n+    ASSERT(!is_finalized() && position_ + n < buffer_.length());\n+    ASSERT(static_cast<size_t>(n) <= strlen(s));\n+    memmove(&buffer_[position_], s, n * kCharSize);\n+    position_ += n;\n+  }\n+\n+\n+  // Add character padding to the builder. If count is non-positive,\n+  // nothing is added to the builder.\n+  void AddPadding(char c, int count) {\n+    for (int i = 0; i < count; i++) {\n+      AddCharacter(c);\n+    }\n+  }\n+\n+  // Finalize the string by 0-terminating it and returning the buffer.\n+  char* Finalize() {\n+    ASSERT(!is_finalized() && position_ < buffer_.length());\n+    buffer_[position_] = '\\0';\n+    // Make sure nobody managed to add a 0-character to the\n+    // buffer while building the string.\n+    ASSERT(strlen(buffer_.start()) == static_cast<size_t>(position_));\n+    position_ = -1;\n+    ASSERT(is_finalized());\n+    return buffer_.start();\n+  }\n+\n+ private:\n+  Vector<char> buffer_;\n+  int position_;\n+\n+  bool is_finalized() const { return position_ < 0; }\n+\n+  DISALLOW_IMPLICIT_CONSTRUCTORS(StringBuilder);\n+};\n+\n+// The type-based aliasing rule allows the compiler to assume that pointers of\n+// different types (for some definition of different) never alias each other.\n+// Thus the following code does not work:\n+//\n+// float f = foo();\n+// int fbits = *(int*)(&f);\n+//\n+// The compiler 'knows' that the int pointer can't refer to f since the types\n+// don't match, so the compiler may cache f in a register, leaving random data\n+// in fbits.  Using C++ style casts makes no difference, however a pointer to\n+// char data is assumed to alias any other pointer.  This is the 'memcpy\n+// exception'.\n+//\n+// Bit_cast uses the memcpy exception to move the bits from a variable of one\n+// type of a variable of another type.  Of course the end result is likely to\n+// be implementation dependent.  Most compilers (gcc-4.2 and MSVC 2005)\n+// will completely optimize BitCast away.\n+//\n+// There is an additional use for BitCast.\n+// Recent gccs will warn when they see casts that may result in breakage due to\n+// the type-based aliasing rule.  If you have checked that there is no breakage\n+// you can use BitCast to cast one pointer type to another.  This confuses gcc\n+// enough that it can no longer see that you have cast one pointer type to\n+// another thus avoiding the warning.\n+template <class Dest, class Source>\n+inline Dest BitCast(const Source& source) {\n+  // Compile time assertion: sizeof(Dest) == sizeof(Source)\n+  // A compile error here means your Dest and Source have different sizes.\n+  DOUBLE_CONVERSION_UNUSED\n+      typedef char VerifySizesAreEqual[sizeof(Dest) == sizeof(Source) ? 1 : -1];\n+\n+  Dest dest;\n+  memmove(&dest, &source, sizeof(dest));\n+  return dest;\n+}\n+\n+template <class Dest, class Source>\n+inline Dest BitCast(Source* source) {\n+  return BitCast<Dest>(reinterpret_cast<uintptr_t>(source));\n+}\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+\n+#endif  // DOUBLE_CONVERSION_UTILS_H_\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "8629284aa0e0f5eef00a7f790ef74b45de680a5a",
            "filename": "deps/icu-small/source/i18n/double-conversion.cpp",
            "status": "added",
            "additions": 1005,
            "deletions": 0,
            "changes": 1005,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,1005 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2010 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#include <limits.h>\n+#include <math.h>\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+// The files fixed-dtoa.h and strtod.h are not needed.\n+\n+#include \"double-conversion.h\"\n+\n+#include \"double-conversion-bignum-dtoa.h\"\n+#include \"double-conversion-fast-dtoa.h\"\n+#include \"double-conversion-ieee.h\"\n+#include \"double-conversion-utils.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+#if 0  // not needed for ICU\n+const DoubleToStringConverter& DoubleToStringConverter::EcmaScriptConverter() {\n+  int flags = UNIQUE_ZERO | EMIT_POSITIVE_EXPONENT_SIGN;\n+  static DoubleToStringConverter converter(flags,\n+                                           \"Infinity\",\n+                                           \"NaN\",\n+                                           'e',\n+                                           -6, 21,\n+                                           6, 0);\n+  return converter;\n+}\n+\n+\n+bool DoubleToStringConverter::HandleSpecialValues(\n+    double value,\n+    StringBuilder* result_builder) const {\n+  Double double_inspect(value);\n+  if (double_inspect.IsInfinite()) {\n+    if (infinity_symbol_ == NULL) return false;\n+    if (value < 0) {\n+      result_builder->AddCharacter('-');\n+    }\n+    result_builder->AddString(infinity_symbol_);\n+    return true;\n+  }\n+  if (double_inspect.IsNan()) {\n+    if (nan_symbol_ == NULL) return false;\n+    result_builder->AddString(nan_symbol_);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\n+void DoubleToStringConverter::CreateExponentialRepresentation(\n+    const char* decimal_digits,\n+    int length,\n+    int exponent,\n+    StringBuilder* result_builder) const {\n+  ASSERT(length != 0);\n+  result_builder->AddCharacter(decimal_digits[0]);\n+  if (length != 1) {\n+    result_builder->AddCharacter('.');\n+    result_builder->AddSubstring(&decimal_digits[1], length-1);\n+  }\n+  result_builder->AddCharacter(exponent_character_);\n+  if (exponent < 0) {\n+    result_builder->AddCharacter('-');\n+    exponent = -exponent;\n+  } else {\n+    if ((flags_ & EMIT_POSITIVE_EXPONENT_SIGN) != 0) {\n+      result_builder->AddCharacter('+');\n+    }\n+  }\n+  if (exponent == 0) {\n+    result_builder->AddCharacter('0');\n+    return;\n+  }\n+  ASSERT(exponent < 1e4);\n+  const int kMaxExponentLength = 5;\n+  char buffer[kMaxExponentLength + 1];\n+  buffer[kMaxExponentLength] = '\\0';\n+  int first_char_pos = kMaxExponentLength;\n+  while (exponent > 0) {\n+    buffer[--first_char_pos] = '0' + (exponent % 10);\n+    exponent /= 10;\n+  }\n+  result_builder->AddSubstring(&buffer[first_char_pos],\n+                               kMaxExponentLength - first_char_pos);\n+}\n+\n+\n+void DoubleToStringConverter::CreateDecimalRepresentation(\n+    const char* decimal_digits,\n+    int length,\n+    int decimal_point,\n+    int digits_after_point,\n+    StringBuilder* result_builder) const {\n+  // Create a representation that is padded with zeros if needed.\n+  if (decimal_point <= 0) {\n+      // \"0.00000decimal_rep\" or \"0.000decimal_rep00\".\n+    result_builder->AddCharacter('0');\n+    if (digits_after_point > 0) {\n+      result_builder->AddCharacter('.');\n+      result_builder->AddPadding('0', -decimal_point);\n+      ASSERT(length <= digits_after_point - (-decimal_point));\n+      result_builder->AddSubstring(decimal_digits, length);\n+      int remaining_digits = digits_after_point - (-decimal_point) - length;\n+      result_builder->AddPadding('0', remaining_digits);\n+    }\n+  } else if (decimal_point >= length) {\n+    // \"decimal_rep0000.00000\" or \"decimal_rep.0000\".\n+    result_builder->AddSubstring(decimal_digits, length);\n+    result_builder->AddPadding('0', decimal_point - length);\n+    if (digits_after_point > 0) {\n+      result_builder->AddCharacter('.');\n+      result_builder->AddPadding('0', digits_after_point);\n+    }\n+  } else {\n+    // \"decima.l_rep000\".\n+    ASSERT(digits_after_point > 0);\n+    result_builder->AddSubstring(decimal_digits, decimal_point);\n+    result_builder->AddCharacter('.');\n+    ASSERT(length - decimal_point <= digits_after_point);\n+    result_builder->AddSubstring(&decimal_digits[decimal_point],\n+                                 length - decimal_point);\n+    int remaining_digits = digits_after_point - (length - decimal_point);\n+    result_builder->AddPadding('0', remaining_digits);\n+  }\n+  if (digits_after_point == 0) {\n+    if ((flags_ & EMIT_TRAILING_DECIMAL_POINT) != 0) {\n+      result_builder->AddCharacter('.');\n+    }\n+    if ((flags_ & EMIT_TRAILING_ZERO_AFTER_POINT) != 0) {\n+      result_builder->AddCharacter('0');\n+    }\n+  }\n+}\n+\n+\n+bool DoubleToStringConverter::ToShortestIeeeNumber(\n+    double value,\n+    StringBuilder* result_builder,\n+    DoubleToStringConverter::DtoaMode mode) const {\n+  ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE);\n+  if (Double(value).IsSpecial()) {\n+    return HandleSpecialValues(value, result_builder);\n+  }\n+\n+  int decimal_point;\n+  bool sign;\n+  const int kDecimalRepCapacity = kBase10MaximalLength + 1;\n+  char decimal_rep[kDecimalRepCapacity];\n+  int decimal_rep_length;\n+\n+  DoubleToAscii(value, mode, 0, decimal_rep, kDecimalRepCapacity,\n+                &sign, &decimal_rep_length, &decimal_point);\n+\n+  bool unique_zero = (flags_ & UNIQUE_ZERO) != 0;\n+  if (sign && (value != 0.0 || !unique_zero)) {\n+    result_builder->AddCharacter('-');\n+  }\n+\n+  int exponent = decimal_point - 1;\n+  if ((decimal_in_shortest_low_ <= exponent) &&\n+      (exponent < decimal_in_shortest_high_)) {\n+    CreateDecimalRepresentation(decimal_rep, decimal_rep_length,\n+                                decimal_point,\n+                                Max(0, decimal_rep_length - decimal_point),\n+                                result_builder);\n+  } else {\n+    CreateExponentialRepresentation(decimal_rep, decimal_rep_length, exponent,\n+                                    result_builder);\n+  }\n+  return true;\n+}\n+\n+\n+bool DoubleToStringConverter::ToFixed(double value,\n+                                      int requested_digits,\n+                                      StringBuilder* result_builder) const {\n+  ASSERT(kMaxFixedDigitsBeforePoint == 60);\n+  const double kFirstNonFixed = 1e60;\n+\n+  if (Double(value).IsSpecial()) {\n+    return HandleSpecialValues(value, result_builder);\n+  }\n+\n+  if (requested_digits > kMaxFixedDigitsAfterPoint) return false;\n+  if (value >= kFirstNonFixed || value <= -kFirstNonFixed) return false;\n+\n+  // Find a sufficiently precise decimal representation of n.\n+  int decimal_point;\n+  bool sign;\n+  // Add space for the '\\0' byte.\n+  const int kDecimalRepCapacity =\n+      kMaxFixedDigitsBeforePoint + kMaxFixedDigitsAfterPoint + 1;\n+  char decimal_rep[kDecimalRepCapacity];\n+  int decimal_rep_length;\n+  DoubleToAscii(value, FIXED, requested_digits,\n+                decimal_rep, kDecimalRepCapacity,\n+                &sign, &decimal_rep_length, &decimal_point);\n+\n+  bool unique_zero = ((flags_ & UNIQUE_ZERO) != 0);\n+  if (sign && (value != 0.0 || !unique_zero)) {\n+    result_builder->AddCharacter('-');\n+  }\n+\n+  CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,\n+                              requested_digits, result_builder);\n+  return true;\n+}\n+\n+\n+bool DoubleToStringConverter::ToExponential(\n+    double value,\n+    int requested_digits,\n+    StringBuilder* result_builder) const {\n+  if (Double(value).IsSpecial()) {\n+    return HandleSpecialValues(value, result_builder);\n+  }\n+\n+  if (requested_digits < -1) return false;\n+  if (requested_digits > kMaxExponentialDigits) return false;\n+\n+  int decimal_point;\n+  bool sign;\n+  // Add space for digit before the decimal point and the '\\0' character.\n+  const int kDecimalRepCapacity = kMaxExponentialDigits + 2;\n+  ASSERT(kDecimalRepCapacity > kBase10MaximalLength);\n+  char decimal_rep[kDecimalRepCapacity];\n+  int decimal_rep_length;\n+\n+  if (requested_digits == -1) {\n+    DoubleToAscii(value, SHORTEST, 0,\n+                  decimal_rep, kDecimalRepCapacity,\n+                  &sign, &decimal_rep_length, &decimal_point);\n+  } else {\n+    DoubleToAscii(value, PRECISION, requested_digits + 1,\n+                  decimal_rep, kDecimalRepCapacity,\n+                  &sign, &decimal_rep_length, &decimal_point);\n+    ASSERT(decimal_rep_length <= requested_digits + 1);\n+\n+    for (int i = decimal_rep_length; i < requested_digits + 1; ++i) {\n+      decimal_rep[i] = '0';\n+    }\n+    decimal_rep_length = requested_digits + 1;\n+  }\n+\n+  bool unique_zero = ((flags_ & UNIQUE_ZERO) != 0);\n+  if (sign && (value != 0.0 || !unique_zero)) {\n+    result_builder->AddCharacter('-');\n+  }\n+\n+  int exponent = decimal_point - 1;\n+  CreateExponentialRepresentation(decimal_rep,\n+                                  decimal_rep_length,\n+                                  exponent,\n+                                  result_builder);\n+  return true;\n+}\n+\n+\n+bool DoubleToStringConverter::ToPrecision(double value,\n+                                          int precision,\n+                                          StringBuilder* result_builder) const {\n+  if (Double(value).IsSpecial()) {\n+    return HandleSpecialValues(value, result_builder);\n+  }\n+\n+  if (precision < kMinPrecisionDigits || precision > kMaxPrecisionDigits) {\n+    return false;\n+  }\n+\n+  // Find a sufficiently precise decimal representation of n.\n+  int decimal_point;\n+  bool sign;\n+  // Add one for the terminating null character.\n+  const int kDecimalRepCapacity = kMaxPrecisionDigits + 1;\n+  char decimal_rep[kDecimalRepCapacity];\n+  int decimal_rep_length;\n+\n+  DoubleToAscii(value, PRECISION, precision,\n+                decimal_rep, kDecimalRepCapacity,\n+                &sign, &decimal_rep_length, &decimal_point);\n+  ASSERT(decimal_rep_length <= precision);\n+\n+  bool unique_zero = ((flags_ & UNIQUE_ZERO) != 0);\n+  if (sign && (value != 0.0 || !unique_zero)) {\n+    result_builder->AddCharacter('-');\n+  }\n+\n+  // The exponent if we print the number as x.xxeyyy. That is with the\n+  // decimal point after the first digit.\n+  int exponent = decimal_point - 1;\n+\n+  int extra_zero = ((flags_ & EMIT_TRAILING_ZERO_AFTER_POINT) != 0) ? 1 : 0;\n+  if ((-decimal_point + 1 > max_leading_padding_zeroes_in_precision_mode_) ||\n+      (decimal_point - precision + extra_zero >\n+       max_trailing_padding_zeroes_in_precision_mode_)) {\n+    // Fill buffer to contain 'precision' digits.\n+    // Usually the buffer is already at the correct length, but 'DoubleToAscii'\n+    // is allowed to return less characters.\n+    for (int i = decimal_rep_length; i < precision; ++i) {\n+      decimal_rep[i] = '0';\n+    }\n+\n+    CreateExponentialRepresentation(decimal_rep,\n+                                    precision,\n+                                    exponent,\n+                                    result_builder);\n+  } else {\n+    CreateDecimalRepresentation(decimal_rep, decimal_rep_length, decimal_point,\n+                                Max(0, precision - decimal_point),\n+                                result_builder);\n+  }\n+  return true;\n+}\n+#endif // not needed for ICU\n+\n+\n+static BignumDtoaMode DtoaToBignumDtoaMode(\n+    DoubleToStringConverter::DtoaMode dtoa_mode) {\n+  switch (dtoa_mode) {\n+    case DoubleToStringConverter::SHORTEST:  return BIGNUM_DTOA_SHORTEST;\n+    case DoubleToStringConverter::SHORTEST_SINGLE:\n+        return BIGNUM_DTOA_SHORTEST_SINGLE;\n+    case DoubleToStringConverter::FIXED:     return BIGNUM_DTOA_FIXED;\n+    case DoubleToStringConverter::PRECISION: return BIGNUM_DTOA_PRECISION;\n+    default:\n+      UNREACHABLE();\n+  }\n+}\n+\n+\n+void DoubleToStringConverter::DoubleToAscii(double v,\n+                                            DtoaMode mode,\n+                                            int requested_digits,\n+                                            char* buffer,\n+                                            int buffer_length,\n+                                            bool* sign,\n+                                            int* length,\n+                                            int* point) {\n+  Vector<char> vector(buffer, buffer_length);\n+  ASSERT(!Double(v).IsSpecial());\n+  ASSERT(mode == SHORTEST || mode == SHORTEST_SINGLE || requested_digits >= 0);\n+\n+  if (Double(v).Sign() < 0) {\n+    *sign = true;\n+    v = -v;\n+  } else {\n+    *sign = false;\n+  }\n+\n+  if (mode == PRECISION && requested_digits == 0) {\n+    vector[0] = '\\0';\n+    *length = 0;\n+    return;\n+  }\n+\n+  if (v == 0) {\n+    vector[0] = '0';\n+    vector[1] = '\\0';\n+    *length = 1;\n+    *point = 1;\n+    return;\n+  }\n+\n+  bool fast_worked;\n+  switch (mode) {\n+    case SHORTEST:\n+      fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST, 0, vector, length, point);\n+      break;\n+#if 0 // not needed for ICU\n+    case SHORTEST_SINGLE:\n+      fast_worked = FastDtoa(v, FAST_DTOA_SHORTEST_SINGLE, 0,\n+                             vector, length, point);\n+      break;\n+    case FIXED:\n+      fast_worked = FastFixedDtoa(v, requested_digits, vector, length, point);\n+      break;\n+    case PRECISION:\n+      fast_worked = FastDtoa(v, FAST_DTOA_PRECISION, requested_digits,\n+                             vector, length, point);\n+      break;\n+#endif // not needed for ICU\n+    default:\n+      fast_worked = false;\n+      UNREACHABLE();\n+  }\n+  if (fast_worked) return;\n+\n+  // If the fast dtoa didn't succeed use the slower bignum version.\n+  BignumDtoaMode bignum_mode = DtoaToBignumDtoaMode(mode);\n+  BignumDtoa(v, bignum_mode, requested_digits, vector, length, point);\n+  vector[*length] = '\\0';\n+}\n+\n+\n+#if 0 // not needed for ICU\n+// Consumes the given substring from the iterator.\n+// Returns false, if the substring does not match.\n+template <class Iterator>\n+static bool ConsumeSubString(Iterator* current,\n+                             Iterator end,\n+                             const char* substring) {\n+  ASSERT(**current == *substring);\n+  for (substring++; *substring != '\\0'; substring++) {\n+    ++*current;\n+    if (*current == end || **current != *substring) return false;\n+  }\n+  ++*current;\n+  return true;\n+}\n+\n+\n+// Maximum number of significant digits in decimal representation.\n+// The longest possible double in decimal representation is\n+// (2^53 - 1) * 2 ^ -1074 that is (2 ^ 53 - 1) * 5 ^ 1074 / 10 ^ 1074\n+// (768 digits). If we parse a number whose first digits are equal to a\n+// mean of 2 adjacent doubles (that could have up to 769 digits) the result\n+// must be rounded to the bigger one unless the tail consists of zeros, so\n+// we don't need to preserve all the digits.\n+const int kMaxSignificantDigits = 772;\n+\n+\n+static const char kWhitespaceTable7[] = { 32, 13, 10, 9, 11, 12 };\n+static const int kWhitespaceTable7Length = ARRAY_SIZE(kWhitespaceTable7);\n+\n+\n+static const uc16 kWhitespaceTable16[] = {\n+  160, 8232, 8233, 5760, 6158, 8192, 8193, 8194, 8195,\n+  8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279\n+};\n+static const int kWhitespaceTable16Length = ARRAY_SIZE(kWhitespaceTable16);\n+\n+\n+static bool isWhitespace(int x) {\n+  if (x < 128) {\n+    for (int i = 0; i < kWhitespaceTable7Length; i++) {\n+      if (kWhitespaceTable7[i] == x) return true;\n+    }\n+  } else {\n+    for (int i = 0; i < kWhitespaceTable16Length; i++) {\n+      if (kWhitespaceTable16[i] == x) return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\n+// Returns true if a nonspace found and false if the end has reached.\n+template <class Iterator>\n+static inline bool AdvanceToNonspace(Iterator* current, Iterator end) {\n+  while (*current != end) {\n+    if (!isWhitespace(**current)) return true;\n+    ++*current;\n+  }\n+  return false;\n+}\n+\n+\n+static bool isDigit(int x, int radix) {\n+  return (x >= '0' && x <= '9' && x < '0' + radix)\n+      || (radix > 10 && x >= 'a' && x < 'a' + radix - 10)\n+      || (radix > 10 && x >= 'A' && x < 'A' + radix - 10);\n+}\n+\n+\n+static double SignedZero(bool sign) {\n+  return sign ? -0.0 : 0.0;\n+}\n+\n+\n+// Returns true if 'c' is a decimal digit that is valid for the given radix.\n+//\n+// The function is small and could be inlined, but VS2012 emitted a warning\n+// because it constant-propagated the radix and concluded that the last\n+// condition was always true. By moving it into a separate function the\n+// compiler wouldn't warn anymore.\n+#if _MSC_VER\n+#pragma optimize(\"\",off)\n+static bool IsDecimalDigitForRadix(int c, int radix) {\n+  return '0' <= c && c <= '9' && (c - '0') < radix;\n+}\n+#pragma optimize(\"\",on)\n+#else\n+static bool inline IsDecimalDigitForRadix(int c, int radix) {\n+\treturn '0' <= c && c <= '9' && (c - '0') < radix;\n+}\n+#endif\n+// Returns true if 'c' is a character digit that is valid for the given radix.\n+// The 'a_character' should be 'a' or 'A'.\n+//\n+// The function is small and could be inlined, but VS2012 emitted a warning\n+// because it constant-propagated the radix and concluded that the first\n+// condition was always false. By moving it into a separate function the\n+// compiler wouldn't warn anymore.\n+static bool IsCharacterDigitForRadix(int c, int radix, char a_character) {\n+  return radix > 10 && c >= a_character && c < a_character + radix - 10;\n+}\n+\n+\n+// Parsing integers with radix 2, 4, 8, 16, 32. Assumes current != end.\n+template <int radix_log_2, class Iterator>\n+static double RadixStringToIeee(Iterator* current,\n+                                Iterator end,\n+                                bool sign,\n+                                bool allow_trailing_junk,\n+                                double junk_string_value,\n+                                bool read_as_double,\n+                                bool* result_is_junk) {\n+  ASSERT(*current != end);\n+\n+  const int kDoubleSize = Double::kSignificandSize;\n+  const int kSingleSize = Single::kSignificandSize;\n+  const int kSignificandSize = read_as_double? kDoubleSize: kSingleSize;\n+\n+  *result_is_junk = true;\n+\n+  // Skip leading 0s.\n+  while (**current == '0') {\n+    ++(*current);\n+    if (*current == end) {\n+      *result_is_junk = false;\n+      return SignedZero(sign);\n+    }\n+  }\n+\n+  int64_t number = 0;\n+  int exponent = 0;\n+  const int radix = (1 << radix_log_2);\n+\n+  do {\n+    int digit;\n+    if (IsDecimalDigitForRadix(**current, radix)) {\n+      digit = static_cast<char>(**current) - '0';\n+    } else if (IsCharacterDigitForRadix(**current, radix, 'a')) {\n+      digit = static_cast<char>(**current) - 'a' + 10;\n+    } else if (IsCharacterDigitForRadix(**current, radix, 'A')) {\n+      digit = static_cast<char>(**current) - 'A' + 10;\n+    } else {\n+      if (allow_trailing_junk || !AdvanceToNonspace(current, end)) {\n+        break;\n+      } else {\n+        return junk_string_value;\n+      }\n+    }\n+\n+    number = number * radix + digit;\n+    int overflow = static_cast<int>(number >> kSignificandSize);\n+    if (overflow != 0) {\n+      // Overflow occurred. Need to determine which direction to round the\n+      // result.\n+      int overflow_bits_count = 1;\n+      while (overflow > 1) {\n+        overflow_bits_count++;\n+        overflow >>= 1;\n+      }\n+\n+      int dropped_bits_mask = ((1 << overflow_bits_count) - 1);\n+      int dropped_bits = static_cast<int>(number) & dropped_bits_mask;\n+      number >>= overflow_bits_count;\n+      exponent = overflow_bits_count;\n+\n+      bool zero_tail = true;\n+      for (;;) {\n+        ++(*current);\n+        if (*current == end || !isDigit(**current, radix)) break;\n+        zero_tail = zero_tail && **current == '0';\n+        exponent += radix_log_2;\n+      }\n+\n+      if (!allow_trailing_junk && AdvanceToNonspace(current, end)) {\n+        return junk_string_value;\n+      }\n+\n+      int middle_value = (1 << (overflow_bits_count - 1));\n+      if (dropped_bits > middle_value) {\n+        number++;  // Rounding up.\n+      } else if (dropped_bits == middle_value) {\n+        // Rounding to even to consistency with decimals: half-way case rounds\n+        // up if significant part is odd and down otherwise.\n+        if ((number & 1) != 0 || !zero_tail) {\n+          number++;  // Rounding up.\n+        }\n+      }\n+\n+      // Rounding up may cause overflow.\n+      if ((number & ((int64_t)1 << kSignificandSize)) != 0) {\n+        exponent++;\n+        number >>= 1;\n+      }\n+      break;\n+    }\n+    ++(*current);\n+  } while (*current != end);\n+\n+  ASSERT(number < ((int64_t)1 << kSignificandSize));\n+  ASSERT(static_cast<int64_t>(static_cast<double>(number)) == number);\n+\n+  *result_is_junk = false;\n+\n+  if (exponent == 0) {\n+    if (sign) {\n+      if (number == 0) return -0.0;\n+      number = -number;\n+    }\n+    return static_cast<double>(number);\n+  }\n+\n+  ASSERT(number != 0);\n+  return Double(DiyFp(number, exponent)).value();\n+}\n+\n+\n+template <class Iterator>\n+double StringToDoubleConverter::StringToIeee(\n+    Iterator input,\n+    int length,\n+    bool read_as_double,\n+    int* processed_characters_count) const {\n+  Iterator current = input;\n+  Iterator end = input + length;\n+\n+  *processed_characters_count = 0;\n+\n+  const bool allow_trailing_junk = (flags_ & ALLOW_TRAILING_JUNK) != 0;\n+  const bool allow_leading_spaces = (flags_ & ALLOW_LEADING_SPACES) != 0;\n+  const bool allow_trailing_spaces = (flags_ & ALLOW_TRAILING_SPACES) != 0;\n+  const bool allow_spaces_after_sign = (flags_ & ALLOW_SPACES_AFTER_SIGN) != 0;\n+\n+  // To make sure that iterator dereferencing is valid the following\n+  // convention is used:\n+  // 1. Each '++current' statement is followed by check for equality to 'end'.\n+  // 2. If AdvanceToNonspace returned false then current == end.\n+  // 3. If 'current' becomes equal to 'end' the function returns or goes to\n+  // 'parsing_done'.\n+  // 4. 'current' is not dereferenced after the 'parsing_done' label.\n+  // 5. Code before 'parsing_done' may rely on 'current != end'.\n+  if (current == end) return empty_string_value_;\n+\n+  if (allow_leading_spaces || allow_trailing_spaces) {\n+    if (!AdvanceToNonspace(&current, end)) {\n+      *processed_characters_count = static_cast<int>(current - input);\n+      return empty_string_value_;\n+    }\n+    if (!allow_leading_spaces && (input != current)) {\n+      // No leading spaces allowed, but AdvanceToNonspace moved forward.\n+      return junk_string_value_;\n+    }\n+  }\n+\n+  // The longest form of simplified number is: \"-<significant digits>.1eXXX\\0\".\n+  const int kBufferSize = kMaxSignificantDigits + 10;\n+  char buffer[kBufferSize];  // NOLINT: size is known at compile time.\n+  int buffer_pos = 0;\n+\n+  // Exponent will be adjusted if insignificant digits of the integer part\n+  // or insignificant leading zeros of the fractional part are dropped.\n+  int exponent = 0;\n+  int significant_digits = 0;\n+  int insignificant_digits = 0;\n+  bool nonzero_digit_dropped = false;\n+\n+  bool sign = false;\n+\n+  if (*current == '+' || *current == '-') {\n+    sign = (*current == '-');\n+    ++current;\n+    Iterator next_non_space = current;\n+    // Skip following spaces (if allowed).\n+    if (!AdvanceToNonspace(&next_non_space, end)) return junk_string_value_;\n+    if (!allow_spaces_after_sign && (current != next_non_space)) {\n+      return junk_string_value_;\n+    }\n+    current = next_non_space;\n+  }\n+\n+  if (infinity_symbol_ != NULL) {\n+    if (*current == infinity_symbol_[0]) {\n+      if (!ConsumeSubString(&current, end, infinity_symbol_)) {\n+        return junk_string_value_;\n+      }\n+\n+      if (!(allow_trailing_spaces || allow_trailing_junk) && (current != end)) {\n+        return junk_string_value_;\n+      }\n+      if (!allow_trailing_junk && AdvanceToNonspace(&current, end)) {\n+        return junk_string_value_;\n+      }\n+\n+      ASSERT(buffer_pos == 0);\n+      *processed_characters_count = static_cast<int>(current - input);\n+      return sign ? -Double::Infinity() : Double::Infinity();\n+    }\n+  }\n+\n+  if (nan_symbol_ != NULL) {\n+    if (*current == nan_symbol_[0]) {\n+      if (!ConsumeSubString(&current, end, nan_symbol_)) {\n+        return junk_string_value_;\n+      }\n+\n+      if (!(allow_trailing_spaces || allow_trailing_junk) && (current != end)) {\n+        return junk_string_value_;\n+      }\n+      if (!allow_trailing_junk && AdvanceToNonspace(&current, end)) {\n+        return junk_string_value_;\n+      }\n+\n+      ASSERT(buffer_pos == 0);\n+      *processed_characters_count = static_cast<int>(current - input);\n+      return sign ? -Double::NaN() : Double::NaN();\n+    }\n+  }\n+\n+  bool leading_zero = false;\n+  if (*current == '0') {\n+    ++current;\n+    if (current == end) {\n+      *processed_characters_count = static_cast<int>(current - input);\n+      return SignedZero(sign);\n+    }\n+\n+    leading_zero = true;\n+\n+    // It could be hexadecimal value.\n+    if ((flags_ & ALLOW_HEX) && (*current == 'x' || *current == 'X')) {\n+      ++current;\n+      if (current == end || !isDigit(*current, 16)) {\n+        return junk_string_value_;  // \"0x\".\n+      }\n+\n+      bool result_is_junk;\n+      double result = RadixStringToIeee<4>(&current,\n+                                           end,\n+                                           sign,\n+                                           allow_trailing_junk,\n+                                           junk_string_value_,\n+                                           read_as_double,\n+                                           &result_is_junk);\n+      if (!result_is_junk) {\n+        if (allow_trailing_spaces) AdvanceToNonspace(&current, end);\n+        *processed_characters_count = static_cast<int>(current - input);\n+      }\n+      return result;\n+    }\n+\n+    // Ignore leading zeros in the integer part.\n+    while (*current == '0') {\n+      ++current;\n+      if (current == end) {\n+        *processed_characters_count = static_cast<int>(current - input);\n+        return SignedZero(sign);\n+      }\n+    }\n+  }\n+\n+  bool octal = leading_zero && (flags_ & ALLOW_OCTALS) != 0;\n+\n+  // Copy significant digits of the integer part (if any) to the buffer.\n+  while (*current >= '0' && *current <= '9') {\n+    if (significant_digits < kMaxSignificantDigits) {\n+      ASSERT(buffer_pos < kBufferSize);\n+      buffer[buffer_pos++] = static_cast<char>(*current);\n+      significant_digits++;\n+      // Will later check if it's an octal in the buffer.\n+    } else {\n+      insignificant_digits++;  // Move the digit into the exponential part.\n+      nonzero_digit_dropped = nonzero_digit_dropped || *current != '0';\n+    }\n+    octal = octal && *current < '8';\n+    ++current;\n+    if (current == end) goto parsing_done;\n+  }\n+\n+  if (significant_digits == 0) {\n+    octal = false;\n+  }\n+\n+  if (*current == '.') {\n+    if (octal && !allow_trailing_junk) return junk_string_value_;\n+    if (octal) goto parsing_done;\n+\n+    ++current;\n+    if (current == end) {\n+      if (significant_digits == 0 && !leading_zero) {\n+        return junk_string_value_;\n+      } else {\n+        goto parsing_done;\n+      }\n+    }\n+\n+    if (significant_digits == 0) {\n+      // octal = false;\n+      // Integer part consists of 0 or is absent. Significant digits start after\n+      // leading zeros (if any).\n+      while (*current == '0') {\n+        ++current;\n+        if (current == end) {\n+          *processed_characters_count = static_cast<int>(current - input);\n+          return SignedZero(sign);\n+        }\n+        exponent--;  // Move this 0 into the exponent.\n+      }\n+    }\n+\n+    // There is a fractional part.\n+    // We don't emit a '.', but adjust the exponent instead.\n+    while (*current >= '0' && *current <= '9') {\n+      if (significant_digits < kMaxSignificantDigits) {\n+        ASSERT(buffer_pos < kBufferSize);\n+        buffer[buffer_pos++] = static_cast<char>(*current);\n+        significant_digits++;\n+        exponent--;\n+      } else {\n+        // Ignore insignificant digits in the fractional part.\n+        nonzero_digit_dropped = nonzero_digit_dropped || *current != '0';\n+      }\n+      ++current;\n+      if (current == end) goto parsing_done;\n+    }\n+  }\n+\n+  if (!leading_zero && exponent == 0 && significant_digits == 0) {\n+    // If leading_zeros is true then the string contains zeros.\n+    // If exponent < 0 then string was [+-]\\.0*...\n+    // If significant_digits != 0 the string is not equal to 0.\n+    // Otherwise there are no digits in the string.\n+    return junk_string_value_;\n+  }\n+\n+  // Parse exponential part.\n+  if (*current == 'e' || *current == 'E') {\n+    if (octal && !allow_trailing_junk) return junk_string_value_;\n+    if (octal) goto parsing_done;\n+    ++current;\n+    if (current == end) {\n+      if (allow_trailing_junk) {\n+        goto parsing_done;\n+      } else {\n+        return junk_string_value_;\n+      }\n+    }\n+    char exponen_sign = '+';\n+    if (*current == '+' || *current == '-') {\n+      exponen_sign = static_cast<char>(*current);\n+      ++current;\n+      if (current == end) {\n+        if (allow_trailing_junk) {\n+          goto parsing_done;\n+        } else {\n+          return junk_string_value_;\n+        }\n+      }\n+    }\n+\n+    if (current == end || *current < '0' || *current > '9') {\n+      if (allow_trailing_junk) {\n+        goto parsing_done;\n+      } else {\n+        return junk_string_value_;\n+      }\n+    }\n+\n+    const int max_exponent = INT_MAX / 2;\n+    ASSERT(-max_exponent / 2 <= exponent && exponent <= max_exponent / 2);\n+    int num = 0;\n+    do {\n+      // Check overflow.\n+      int digit = *current - '0';\n+      if (num >= max_exponent / 10\n+          && !(num == max_exponent / 10 && digit <= max_exponent % 10)) {\n+        num = max_exponent;\n+      } else {\n+        num = num * 10 + digit;\n+      }\n+      ++current;\n+    } while (current != end && *current >= '0' && *current <= '9');\n+\n+    exponent += (exponen_sign == '-' ? -num : num);\n+  }\n+\n+  if (!(allow_trailing_spaces || allow_trailing_junk) && (current != end)) {\n+    return junk_string_value_;\n+  }\n+  if (!allow_trailing_junk && AdvanceToNonspace(&current, end)) {\n+    return junk_string_value_;\n+  }\n+  if (allow_trailing_spaces) {\n+    AdvanceToNonspace(&current, end);\n+  }\n+\n+  parsing_done:\n+  exponent += insignificant_digits;\n+\n+  if (octal) {\n+    double result;\n+    bool result_is_junk;\n+    char* start = buffer;\n+    result = RadixStringToIeee<3>(&start,\n+                                  buffer + buffer_pos,\n+                                  sign,\n+                                  allow_trailing_junk,\n+                                  junk_string_value_,\n+                                  read_as_double,\n+                                  &result_is_junk);\n+    ASSERT(!result_is_junk);\n+    *processed_characters_count = static_cast<int>(current - input);\n+    return result;\n+  }\n+\n+  if (nonzero_digit_dropped) {\n+    buffer[buffer_pos++] = '1';\n+    exponent--;\n+  }\n+\n+  ASSERT(buffer_pos < kBufferSize);\n+  buffer[buffer_pos] = '\\0';\n+\n+  double converted;\n+  if (read_as_double) {\n+    converted = Strtod(Vector<const char>(buffer, buffer_pos), exponent);\n+  } else {\n+    converted = Strtof(Vector<const char>(buffer, buffer_pos), exponent);\n+  }\n+  *processed_characters_count = static_cast<int>(current - input);\n+  return sign? -converted: converted;\n+}\n+\n+\n+double StringToDoubleConverter::StringToDouble(\n+    const char* buffer,\n+    int length,\n+    int* processed_characters_count) const {\n+  return StringToIeee(buffer, length, true, processed_characters_count);\n+}\n+\n+\n+double StringToDoubleConverter::StringToDouble(\n+    const uc16* buffer,\n+    int length,\n+    int* processed_characters_count) const {\n+  return StringToIeee(buffer, length, true, processed_characters_count);\n+}\n+\n+\n+float StringToDoubleConverter::StringToFloat(\n+    const char* buffer,\n+    int length,\n+    int* processed_characters_count) const {\n+  return static_cast<float>(StringToIeee(buffer, length, false,\n+                                         processed_characters_count));\n+}\n+\n+\n+float StringToDoubleConverter::StringToFloat(\n+    const uc16* buffer,\n+    int length,\n+    int* processed_characters_count) const {\n+  return static_cast<float>(StringToIeee(buffer, length, false,\n+                                         processed_characters_count));\n+}\n+#endif // not needed for ICU\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "0939412734a6bbc3978426869494af8e65238c85",
            "filename": "deps/icu-small/source/i18n/double-conversion.h",
            "status": "added",
            "additions": 566,
            "deletions": 0,
            "changes": 566,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdouble-conversion.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -0,0 +1,566 @@\n+// © 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// From the double-conversion library. Original license:\n+//\n+// Copyright 2012 the V8 project authors. All rights reserved.\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+//       notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+//       copyright notice, this list of conditions and the following\n+//       disclaimer in the documentation and/or other materials provided\n+//       with the distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+//       contributors may be used to endorse or promote products derived\n+//       from this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+// ICU PATCH: ifdef around UCONFIG_NO_FORMATTING\n+#include \"unicode/utypes.h\"\n+#if !UCONFIG_NO_FORMATTING\n+\n+#ifndef DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_\n+#define DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_\n+\n+// ICU PATCH: Customize header file paths for ICU.\n+\n+#include \"double-conversion-utils.h\"\n+\n+// ICU PATCH: Wrap in ICU namespace\n+U_NAMESPACE_BEGIN\n+\n+namespace double_conversion {\n+\n+class DoubleToStringConverter {\n+ public:\n+#if 0 // not needed for ICU\n+  // When calling ToFixed with a double > 10^kMaxFixedDigitsBeforePoint\n+  // or a requested_digits parameter > kMaxFixedDigitsAfterPoint then the\n+  // function returns false.\n+  static const int kMaxFixedDigitsBeforePoint = 60;\n+  static const int kMaxFixedDigitsAfterPoint = 60;\n+\n+  // When calling ToExponential with a requested_digits\n+  // parameter > kMaxExponentialDigits then the function returns false.\n+  static const int kMaxExponentialDigits = 120;\n+\n+  // When calling ToPrecision with a requested_digits\n+  // parameter < kMinPrecisionDigits or requested_digits > kMaxPrecisionDigits\n+  // then the function returns false.\n+  static const int kMinPrecisionDigits = 1;\n+  static const int kMaxPrecisionDigits = 120;\n+\n+  enum Flags {\n+    NO_FLAGS = 0,\n+    EMIT_POSITIVE_EXPONENT_SIGN = 1,\n+    EMIT_TRAILING_DECIMAL_POINT = 2,\n+    EMIT_TRAILING_ZERO_AFTER_POINT = 4,\n+    UNIQUE_ZERO = 8\n+  };\n+\n+  // Flags should be a bit-or combination of the possible Flags-enum.\n+  //  - NO_FLAGS: no special flags.\n+  //  - EMIT_POSITIVE_EXPONENT_SIGN: when the number is converted into exponent\n+  //    form, emits a '+' for positive exponents. Example: 1.2e+2.\n+  //  - EMIT_TRAILING_DECIMAL_POINT: when the input number is an integer and is\n+  //    converted into decimal format then a trailing decimal point is appended.\n+  //    Example: 2345.0 is converted to \"2345.\".\n+  //  - EMIT_TRAILING_ZERO_AFTER_POINT: in addition to a trailing decimal point\n+  //    emits a trailing '0'-character. This flag requires the\n+  //    EXMIT_TRAILING_DECIMAL_POINT flag.\n+  //    Example: 2345.0 is converted to \"2345.0\".\n+  //  - UNIQUE_ZERO: \"-0.0\" is converted to \"0.0\".\n+  //\n+  // Infinity symbol and nan_symbol provide the string representation for these\n+  // special values. If the string is NULL and the special value is encountered\n+  // then the conversion functions return false.\n+  //\n+  // The exponent_character is used in exponential representations. It is\n+  // usually 'e' or 'E'.\n+  //\n+  // When converting to the shortest representation the converter will\n+  // represent input numbers in decimal format if they are in the interval\n+  // [10^decimal_in_shortest_low; 10^decimal_in_shortest_high[\n+  //    (lower boundary included, greater boundary excluded).\n+  // Example: with decimal_in_shortest_low = -6 and\n+  //               decimal_in_shortest_high = 21:\n+  //   ToShortest(0.000001)  -> \"0.000001\"\n+  //   ToShortest(0.0000001) -> \"1e-7\"\n+  //   ToShortest(111111111111111111111.0)  -> \"111111111111111110000\"\n+  //   ToShortest(100000000000000000000.0)  -> \"100000000000000000000\"\n+  //   ToShortest(1111111111111111111111.0) -> \"1.1111111111111111e+21\"\n+  //\n+  // When converting to precision mode the converter may add\n+  // max_leading_padding_zeroes before returning the number in exponential\n+  // format.\n+  // Example with max_leading_padding_zeroes_in_precision_mode = 6.\n+  //   ToPrecision(0.0000012345, 2) -> \"0.0000012\"\n+  //   ToPrecision(0.00000012345, 2) -> \"1.2e-7\"\n+  // Similarily the converter may add up to\n+  // max_trailing_padding_zeroes_in_precision_mode in precision mode to avoid\n+  // returning an exponential representation. A zero added by the\n+  // EMIT_TRAILING_ZERO_AFTER_POINT flag is counted for this limit.\n+  // Examples for max_trailing_padding_zeroes_in_precision_mode = 1:\n+  //   ToPrecision(230.0, 2) -> \"230\"\n+  //   ToPrecision(230.0, 2) -> \"230.\"  with EMIT_TRAILING_DECIMAL_POINT.\n+  //   ToPrecision(230.0, 2) -> \"2.3e2\" with EMIT_TRAILING_ZERO_AFTER_POINT.\n+  DoubleToStringConverter(int flags,\n+                          const char* infinity_symbol,\n+                          const char* nan_symbol,\n+                          char exponent_character,\n+                          int decimal_in_shortest_low,\n+                          int decimal_in_shortest_high,\n+                          int max_leading_padding_zeroes_in_precision_mode,\n+                          int max_trailing_padding_zeroes_in_precision_mode)\n+      : flags_(flags),\n+        infinity_symbol_(infinity_symbol),\n+        nan_symbol_(nan_symbol),\n+        exponent_character_(exponent_character),\n+        decimal_in_shortest_low_(decimal_in_shortest_low),\n+        decimal_in_shortest_high_(decimal_in_shortest_high),\n+        max_leading_padding_zeroes_in_precision_mode_(\n+            max_leading_padding_zeroes_in_precision_mode),\n+        max_trailing_padding_zeroes_in_precision_mode_(\n+            max_trailing_padding_zeroes_in_precision_mode) {\n+    // When 'trailing zero after the point' is set, then 'trailing point'\n+    // must be set too.\n+    ASSERT(((flags & EMIT_TRAILING_DECIMAL_POINT) != 0) ||\n+        !((flags & EMIT_TRAILING_ZERO_AFTER_POINT) != 0));\n+  }\n+\n+  // Returns a converter following the EcmaScript specification.\n+  static const DoubleToStringConverter& EcmaScriptConverter();\n+\n+  // Computes the shortest string of digits that correctly represent the input\n+  // number. Depending on decimal_in_shortest_low and decimal_in_shortest_high\n+  // (see constructor) it then either returns a decimal representation, or an\n+  // exponential representation.\n+  // Example with decimal_in_shortest_low = -6,\n+  //              decimal_in_shortest_high = 21,\n+  //              EMIT_POSITIVE_EXPONENT_SIGN activated, and\n+  //              EMIT_TRAILING_DECIMAL_POINT deactived:\n+  //   ToShortest(0.000001)  -> \"0.000001\"\n+  //   ToShortest(0.0000001) -> \"1e-7\"\n+  //   ToShortest(111111111111111111111.0)  -> \"111111111111111110000\"\n+  //   ToShortest(100000000000000000000.0)  -> \"100000000000000000000\"\n+  //   ToShortest(1111111111111111111111.0) -> \"1.1111111111111111e+21\"\n+  //\n+  // Note: the conversion may round the output if the returned string\n+  // is accurate enough to uniquely identify the input-number.\n+  // For example the most precise representation of the double 9e59 equals\n+  // \"899999999999999918767229449717619953810131273674690656206848\", but\n+  // the converter will return the shorter (but still correct) \"9e59\".\n+  //\n+  // Returns true if the conversion succeeds. The conversion always succeeds\n+  // except when the input value is special and no infinity_symbol or\n+  // nan_symbol has been given to the constructor.\n+  bool ToShortest(double value, StringBuilder* result_builder) const {\n+    return ToShortestIeeeNumber(value, result_builder, SHORTEST);\n+  }\n+\n+  // Same as ToShortest, but for single-precision floats.\n+  bool ToShortestSingle(float value, StringBuilder* result_builder) const {\n+    return ToShortestIeeeNumber(value, result_builder, SHORTEST_SINGLE);\n+  }\n+\n+\n+  // Computes a decimal representation with a fixed number of digits after the\n+  // decimal point. The last emitted digit is rounded.\n+  //\n+  // Examples:\n+  //   ToFixed(3.12, 1) -> \"3.1\"\n+  //   ToFixed(3.1415, 3) -> \"3.142\"\n+  //   ToFixed(1234.56789, 4) -> \"1234.5679\"\n+  //   ToFixed(1.23, 5) -> \"1.23000\"\n+  //   ToFixed(0.1, 4) -> \"0.1000\"\n+  //   ToFixed(1e30, 2) -> \"1000000000000000019884624838656.00\"\n+  //   ToFixed(0.1, 30) -> \"0.100000000000000005551115123126\"\n+  //   ToFixed(0.1, 17) -> \"0.10000000000000001\"\n+  //\n+  // If requested_digits equals 0, then the tail of the result depends on\n+  // the EMIT_TRAILING_DECIMAL_POINT and EMIT_TRAILING_ZERO_AFTER_POINT.\n+  // Examples, for requested_digits == 0,\n+  //   let EMIT_TRAILING_DECIMAL_POINT and EMIT_TRAILING_ZERO_AFTER_POINT be\n+  //    - false and false: then 123.45 -> 123\n+  //                             0.678 -> 1\n+  //    - true and false: then 123.45 -> 123.\n+  //                            0.678 -> 1.\n+  //    - true and true: then 123.45 -> 123.0\n+  //                           0.678 -> 1.0\n+  //\n+  // Returns true if the conversion succeeds. The conversion always succeeds\n+  // except for the following cases:\n+  //   - the input value is special and no infinity_symbol or nan_symbol has\n+  //     been provided to the constructor,\n+  //   - 'value' > 10^kMaxFixedDigitsBeforePoint, or\n+  //   - 'requested_digits' > kMaxFixedDigitsAfterPoint.\n+  // The last two conditions imply that the result will never contain more than\n+  // 1 + kMaxFixedDigitsBeforePoint + 1 + kMaxFixedDigitsAfterPoint characters\n+  // (one additional character for the sign, and one for the decimal point).\n+  bool ToFixed(double value,\n+               int requested_digits,\n+               StringBuilder* result_builder) const;\n+\n+  // Computes a representation in exponential format with requested_digits\n+  // after the decimal point. The last emitted digit is rounded.\n+  // If requested_digits equals -1, then the shortest exponential representation\n+  // is computed.\n+  //\n+  // Examples with EMIT_POSITIVE_EXPONENT_SIGN deactivated, and\n+  //               exponent_character set to 'e'.\n+  //   ToExponential(3.12, 1) -> \"3.1e0\"\n+  //   ToExponential(5.0, 3) -> \"5.000e0\"\n+  //   ToExponential(0.001, 2) -> \"1.00e-3\"\n+  //   ToExponential(3.1415, -1) -> \"3.1415e0\"\n+  //   ToExponential(3.1415, 4) -> \"3.1415e0\"\n+  //   ToExponential(3.1415, 3) -> \"3.142e0\"\n+  //   ToExponential(123456789000000, 3) -> \"1.235e14\"\n+  //   ToExponential(1000000000000000019884624838656.0, -1) -> \"1e30\"\n+  //   ToExponential(1000000000000000019884624838656.0, 32) ->\n+  //                     \"1.00000000000000001988462483865600e30\"\n+  //   ToExponential(1234, 0) -> \"1e3\"\n+  //\n+  // Returns true if the conversion succeeds. The conversion always succeeds\n+  // except for the following cases:\n+  //   - the input value is special and no infinity_symbol or nan_symbol has\n+  //     been provided to the constructor,\n+  //   - 'requested_digits' > kMaxExponentialDigits.\n+  // The last condition implies that the result will never contain more than\n+  // kMaxExponentialDigits + 8 characters (the sign, the digit before the\n+  // decimal point, the decimal point, the exponent character, the\n+  // exponent's sign, and at most 3 exponent digits).\n+  bool ToExponential(double value,\n+                     int requested_digits,\n+                     StringBuilder* result_builder) const;\n+\n+  // Computes 'precision' leading digits of the given 'value' and returns them\n+  // either in exponential or decimal format, depending on\n+  // max_{leading|trailing}_padding_zeroes_in_precision_mode (given to the\n+  // constructor).\n+  // The last computed digit is rounded.\n+  //\n+  // Example with max_leading_padding_zeroes_in_precision_mode = 6.\n+  //   ToPrecision(0.0000012345, 2) -> \"0.0000012\"\n+  //   ToPrecision(0.00000012345, 2) -> \"1.2e-7\"\n+  // Similarily the converter may add up to\n+  // max_trailing_padding_zeroes_in_precision_mode in precision mode to avoid\n+  // returning an exponential representation. A zero added by the\n+  // EMIT_TRAILING_ZERO_AFTER_POINT flag is counted for this limit.\n+  // Examples for max_trailing_padding_zeroes_in_precision_mode = 1:\n+  //   ToPrecision(230.0, 2) -> \"230\"\n+  //   ToPrecision(230.0, 2) -> \"230.\"  with EMIT_TRAILING_DECIMAL_POINT.\n+  //   ToPrecision(230.0, 2) -> \"2.3e2\" with EMIT_TRAILING_ZERO_AFTER_POINT.\n+  // Examples for max_trailing_padding_zeroes_in_precision_mode = 3, and no\n+  //    EMIT_TRAILING_ZERO_AFTER_POINT:\n+  //   ToPrecision(123450.0, 6) -> \"123450\"\n+  //   ToPrecision(123450.0, 5) -> \"123450\"\n+  //   ToPrecision(123450.0, 4) -> \"123500\"\n+  //   ToPrecision(123450.0, 3) -> \"123000\"\n+  //   ToPrecision(123450.0, 2) -> \"1.2e5\"\n+  //\n+  // Returns true if the conversion succeeds. The conversion always succeeds\n+  // except for the following cases:\n+  //   - the input value is special and no infinity_symbol or nan_symbol has\n+  //     been provided to the constructor,\n+  //   - precision < kMinPericisionDigits\n+  //   - precision > kMaxPrecisionDigits\n+  // The last condition implies that the result will never contain more than\n+  // kMaxPrecisionDigits + 7 characters (the sign, the decimal point, the\n+  // exponent character, the exponent's sign, and at most 3 exponent digits).\n+  bool ToPrecision(double value,\n+                   int precision,\n+                   StringBuilder* result_builder) const;\n+#endif // not needed for ICU\n+\n+  enum DtoaMode {\n+    // Produce the shortest correct representation.\n+    // For example the output of 0.299999999999999988897 is (the less accurate\n+    // but correct) 0.3.\n+    SHORTEST,\n+    // Same as SHORTEST, but for single-precision floats.\n+    SHORTEST_SINGLE,\n+    // Produce a fixed number of digits after the decimal point.\n+    // For instance fixed(0.1, 4) becomes 0.1000\n+    // If the input number is big, the output will be big.\n+    FIXED,\n+    // Fixed number of digits (independent of the decimal point).\n+    PRECISION\n+  };\n+\n+  // The maximal number of digits that are needed to emit a double in base 10.\n+  // A higher precision can be achieved by using more digits, but the shortest\n+  // accurate representation of any double will never use more digits than\n+  // kBase10MaximalLength.\n+  // Note that DoubleToAscii null-terminates its input. So the given buffer\n+  // should be at least kBase10MaximalLength + 1 characters long.\n+  static const int kBase10MaximalLength = 17;\n+\n+  // Converts the given double 'v' to ascii. 'v' must not be NaN, +Infinity, or\n+  // -Infinity. In SHORTEST_SINGLE-mode this restriction also applies to 'v'\n+  // after it has been casted to a single-precision float. That is, in this\n+  // mode static_cast<float>(v) must not be NaN, +Infinity or -Infinity.\n+  //\n+  // The result should be interpreted as buffer * 10^(point-length).\n+  //\n+  // The output depends on the given mode:\n+  //  - SHORTEST: produce the least amount of digits for which the internal\n+  //   identity requirement is still satisfied. If the digits are printed\n+  //   (together with the correct exponent) then reading this number will give\n+  //   'v' again. The buffer will choose the representation that is closest to\n+  //   'v'. If there are two at the same distance, than the one farther away\n+  //   from 0 is chosen (halfway cases - ending with 5 - are rounded up).\n+  //   In this mode the 'requested_digits' parameter is ignored.\n+  //  - SHORTEST_SINGLE: same as SHORTEST but with single-precision.\n+  //  - FIXED: produces digits necessary to print a given number with\n+  //   'requested_digits' digits after the decimal point. The produced digits\n+  //   might be too short in which case the caller has to fill the remainder\n+  //   with '0's.\n+  //   Example: toFixed(0.001, 5) is allowed to return buffer=\"1\", point=-2.\n+  //   Halfway cases are rounded towards +/-Infinity (away from 0). The call\n+  //   toFixed(0.15, 2) thus returns buffer=\"2\", point=0.\n+  //   The returned buffer may contain digits that would be truncated from the\n+  //   shortest representation of the input.\n+  //  - PRECISION: produces 'requested_digits' where the first digit is not '0'.\n+  //   Even though the length of produced digits usually equals\n+  //   'requested_digits', the function is allowed to return fewer digits, in\n+  //   which case the caller has to fill the missing digits with '0's.\n+  //   Halfway cases are again rounded away from 0.\n+  // DoubleToAscii expects the given buffer to be big enough to hold all\n+  // digits and a terminating null-character. In SHORTEST-mode it expects a\n+  // buffer of at least kBase10MaximalLength + 1. In all other modes the\n+  // requested_digits parameter and the padding-zeroes limit the size of the\n+  // output. Don't forget the decimal point, the exponent character and the\n+  // terminating null-character when computing the maximal output size.\n+  // The given length is only used in debug mode to ensure the buffer is big\n+  // enough.\n+  // ICU PATCH: Export this as U_I18N_API for unit tests.\n+  static void U_I18N_API DoubleToAscii(double v,\n+                            DtoaMode mode,\n+                            int requested_digits,\n+                            char* buffer,\n+                            int buffer_length,\n+                            bool* sign,\n+                            int* length,\n+                            int* point);\n+\n+#if 0 // not needed for ICU\n+ private:\n+  // Implementation for ToShortest and ToShortestSingle.\n+  bool ToShortestIeeeNumber(double value,\n+                            StringBuilder* result_builder,\n+                            DtoaMode mode) const;\n+\n+  // If the value is a special value (NaN or Infinity) constructs the\n+  // corresponding string using the configured infinity/nan-symbol.\n+  // If either of them is NULL or the value is not special then the\n+  // function returns false.\n+  bool HandleSpecialValues(double value, StringBuilder* result_builder) const;\n+  // Constructs an exponential representation (i.e. 1.234e56).\n+  // The given exponent assumes a decimal point after the first decimal digit.\n+  void CreateExponentialRepresentation(const char* decimal_digits,\n+                                       int length,\n+                                       int exponent,\n+                                       StringBuilder* result_builder) const;\n+  // Creates a decimal representation (i.e 1234.5678).\n+  void CreateDecimalRepresentation(const char* decimal_digits,\n+                                   int length,\n+                                   int decimal_point,\n+                                   int digits_after_point,\n+                                   StringBuilder* result_builder) const;\n+\n+  const int flags_;\n+  const char* const infinity_symbol_;\n+  const char* const nan_symbol_;\n+  const char exponent_character_;\n+  const int decimal_in_shortest_low_;\n+  const int decimal_in_shortest_high_;\n+  const int max_leading_padding_zeroes_in_precision_mode_;\n+  const int max_trailing_padding_zeroes_in_precision_mode_;\n+\n+  DISALLOW_IMPLICIT_CONSTRUCTORS(DoubleToStringConverter);\n+};\n+\n+\n+class StringToDoubleConverter {\n+ public:\n+  // Enumeration for allowing octals and ignoring junk when converting\n+  // strings to numbers.\n+  enum Flags {\n+    NO_FLAGS = 0,\n+    ALLOW_HEX = 1,\n+    ALLOW_OCTALS = 2,\n+    ALLOW_TRAILING_JUNK = 4,\n+    ALLOW_LEADING_SPACES = 8,\n+    ALLOW_TRAILING_SPACES = 16,\n+    ALLOW_SPACES_AFTER_SIGN = 32\n+  };\n+\n+  // Flags should be a bit-or combination of the possible Flags-enum.\n+  //  - NO_FLAGS: no special flags.\n+  //  - ALLOW_HEX: recognizes the prefix \"0x\". Hex numbers may only be integers.\n+  //      Ex: StringToDouble(\"0x1234\") -> 4660.0\n+  //          In StringToDouble(\"0x1234.56\") the characters \".56\" are trailing\n+  //          junk. The result of the call is hence dependent on\n+  //          the ALLOW_TRAILING_JUNK flag and/or the junk value.\n+  //      With this flag \"0x\" is a junk-string. Even with ALLOW_TRAILING_JUNK,\n+  //      the string will not be parsed as \"0\" followed by junk.\n+  //\n+  //  - ALLOW_OCTALS: recognizes the prefix \"0\" for octals:\n+  //      If a sequence of octal digits starts with '0', then the number is\n+  //      read as octal integer. Octal numbers may only be integers.\n+  //      Ex: StringToDouble(\"01234\") -> 668.0\n+  //          StringToDouble(\"012349\") -> 12349.0  // Not a sequence of octal\n+  //                                               // digits.\n+  //          In StringToDouble(\"01234.56\") the characters \".56\" are trailing\n+  //          junk. The result of the call is hence dependent on\n+  //          the ALLOW_TRAILING_JUNK flag and/or the junk value.\n+  //          In StringToDouble(\"01234e56\") the characters \"e56\" are trailing\n+  //          junk, too.\n+  //  - ALLOW_TRAILING_JUNK: ignore trailing characters that are not part of\n+  //      a double literal.\n+  //  - ALLOW_LEADING_SPACES: skip over leading whitespace, including spaces,\n+  //                          new-lines, and tabs.\n+  //  - ALLOW_TRAILING_SPACES: ignore trailing whitespace.\n+  //  - ALLOW_SPACES_AFTER_SIGN: ignore whitespace after the sign.\n+  //       Ex: StringToDouble(\"-   123.2\") -> -123.2.\n+  //           StringToDouble(\"+   123.2\") -> 123.2\n+  //\n+  // empty_string_value is returned when an empty string is given as input.\n+  // If ALLOW_LEADING_SPACES or ALLOW_TRAILING_SPACES are set, then a string\n+  // containing only spaces is converted to the 'empty_string_value', too.\n+  //\n+  // junk_string_value is returned when\n+  //  a) ALLOW_TRAILING_JUNK is not set, and a junk character (a character not\n+  //     part of a double-literal) is found.\n+  //  b) ALLOW_TRAILING_JUNK is set, but the string does not start with a\n+  //     double literal.\n+  //\n+  // infinity_symbol and nan_symbol are strings that are used to detect\n+  // inputs that represent infinity and NaN. They can be null, in which case\n+  // they are ignored.\n+  // The conversion routine first reads any possible signs. Then it compares the\n+  // following character of the input-string with the first character of\n+  // the infinity, and nan-symbol. If either matches, the function assumes, that\n+  // a match has been found, and expects the following input characters to match\n+  // the remaining characters of the special-value symbol.\n+  // This means that the following restrictions apply to special-value symbols:\n+  //  - they must not start with signs ('+', or '-'),\n+  //  - they must not have the same first character.\n+  //  - they must not start with digits.\n+  //\n+  // Examples:\n+  //  flags = ALLOW_HEX | ALLOW_TRAILING_JUNK,\n+  //  empty_string_value = 0.0,\n+  //  junk_string_value = NaN,\n+  //  infinity_symbol = \"infinity\",\n+  //  nan_symbol = \"nan\":\n+  //    StringToDouble(\"0x1234\") -> 4660.0.\n+  //    StringToDouble(\"0x1234K\") -> 4660.0.\n+  //    StringToDouble(\"\") -> 0.0  // empty_string_value.\n+  //    StringToDouble(\" \") -> NaN  // junk_string_value.\n+  //    StringToDouble(\" 1\") -> NaN  // junk_string_value.\n+  //    StringToDouble(\"0x\") -> NaN  // junk_string_value.\n+  //    StringToDouble(\"-123.45\") -> -123.45.\n+  //    StringToDouble(\"--123.45\") -> NaN  // junk_string_value.\n+  //    StringToDouble(\"123e45\") -> 123e45.\n+  //    StringToDouble(\"123E45\") -> 123e45.\n+  //    StringToDouble(\"123e+45\") -> 123e45.\n+  //    StringToDouble(\"123E-45\") -> 123e-45.\n+  //    StringToDouble(\"123e\") -> 123.0  // trailing junk ignored.\n+  //    StringToDouble(\"123e-\") -> 123.0  // trailing junk ignored.\n+  //    StringToDouble(\"+NaN\") -> NaN  // NaN string literal.\n+  //    StringToDouble(\"-infinity\") -> -inf.  // infinity literal.\n+  //    StringToDouble(\"Infinity\") -> NaN  // junk_string_value.\n+  //\n+  //  flags = ALLOW_OCTAL | ALLOW_LEADING_SPACES,\n+  //  empty_string_value = 0.0,\n+  //  junk_string_value = NaN,\n+  //  infinity_symbol = NULL,\n+  //  nan_symbol = NULL:\n+  //    StringToDouble(\"0x1234\") -> NaN  // junk_string_value.\n+  //    StringToDouble(\"01234\") -> 668.0.\n+  //    StringToDouble(\"\") -> 0.0  // empty_string_value.\n+  //    StringToDouble(\" \") -> 0.0  // empty_string_value.\n+  //    StringToDouble(\" 1\") -> 1.0\n+  //    StringToDouble(\"0x\") -> NaN  // junk_string_value.\n+  //    StringToDouble(\"0123e45\") -> NaN  // junk_string_value.\n+  //    StringToDouble(\"01239E45\") -> 1239e45.\n+  //    StringToDouble(\"-infinity\") -> NaN  // junk_string_value.\n+  //    StringToDouble(\"NaN\") -> NaN  // junk_string_value.\n+  StringToDoubleConverter(int flags,\n+                          double empty_string_value,\n+                          double junk_string_value,\n+                          const char* infinity_symbol,\n+                          const char* nan_symbol)\n+      : flags_(flags),\n+        empty_string_value_(empty_string_value),\n+        junk_string_value_(junk_string_value),\n+        infinity_symbol_(infinity_symbol),\n+        nan_symbol_(nan_symbol) {\n+  }\n+\n+  // Performs the conversion.\n+  // The output parameter 'processed_characters_count' is set to the number\n+  // of characters that have been processed to read the number.\n+  // Spaces than are processed with ALLOW_{LEADING|TRAILING}_SPACES are included\n+  // in the 'processed_characters_count'. Trailing junk is never included.\n+  double StringToDouble(const char* buffer,\n+                        int length,\n+                        int* processed_characters_count) const;\n+\n+  // Same as StringToDouble above but for 16 bit characters.\n+  double StringToDouble(const uc16* buffer,\n+                        int length,\n+                        int* processed_characters_count) const;\n+\n+  // Same as StringToDouble but reads a float.\n+  // Note that this is not equivalent to static_cast<float>(StringToDouble(...))\n+  // due to potential double-rounding.\n+  float StringToFloat(const char* buffer,\n+                      int length,\n+                      int* processed_characters_count) const;\n+\n+  // Same as StringToFloat above but for 16 bit characters.\n+  float StringToFloat(const uc16* buffer,\n+                      int length,\n+                      int* processed_characters_count) const;\n+\n+ private:\n+  const int flags_;\n+  const double empty_string_value_;\n+  const double junk_string_value_;\n+  const char* const infinity_symbol_;\n+  const char* const nan_symbol_;\n+\n+  template <class Iterator>\n+  double StringToIeee(Iterator start_pointer,\n+                      int length,\n+                      bool read_as_double,\n+                      int* processed_characters_count) const;\n+\n+  DISALLOW_IMPLICIT_CONSTRUCTORS(StringToDoubleConverter);\n+#endif // not needed for ICU\n+};\n+\n+}  // namespace double_conversion\n+\n+// ICU PATCH: Close ICU namespace\n+U_NAMESPACE_END\n+\n+#endif  // DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_\n+#endif // ICU PATCH: close #if !UCONFIG_NO_FORMATTING"
        },
        {
            "sha": "aefd70464eb2d8acee6fae588a7f162fa5bbd202",
            "filename": "deps/icu-small/source/i18n/dtptngen.cpp",
            "status": "modified",
            "additions": 67,
            "deletions": 23,
            "changes": 90,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtptngen.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtptngen.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtptngen.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -261,12 +261,21 @@ static const char* const CLDR_FIELD_APPEND[] = {\n     \"Hour\", \"Minute\", \"Second\", \"*\", \"Timezone\"\n };\n \n-static const char* const CLDR_FIELD_NAME[] = {\n+static const char* const CLDR_FIELD_NAME[UDATPG_FIELD_COUNT] = {\n     \"era\", \"year\", \"quarter\", \"month\", \"week\", \"weekOfMonth\", \"weekday\",\n     \"dayOfYear\", \"weekdayOfMonth\", \"day\", \"dayperiod\", // The UDATPG_x_FIELD constants and these fields have a different order than in ICU4J\n     \"hour\", \"minute\", \"second\", \"*\", \"zone\"\n };\n \n+static const char* const CLDR_FIELD_WIDTH[] = { // [UDATPG_WIDTH_COUNT]\n+    \"\", \"-short\", \"-narrow\"\n+};\n+\n+// TODO(ticket:13619): remove when definition uncommented in dtptngen.h.\n+static const int32_t UDATPG_WIDTH_COUNT = UDATPG_NARROW + 1;\n+static constexpr UDateTimePGDisplayWidth UDATPG_WIDTH_APPENDITEM = UDATPG_WIDE;\n+static constexpr int32_t UDATPG_FIELD_KEY_MAX = 24; // max length of CLDR field tag (type + width)\n+\n // For appendItems\n static const UChar UDATPG_ItemFormat[]= {0x7B, 0x30, 0x7D, 0x20, 0x251C, 0x7B, 0x32, 0x7D, 0x3A,\n     0x20, 0x7B, 0x31, 0x7D, 0x2524, 0};  // {0} \\u251C{2}: {1}\\u2524\n@@ -379,10 +388,11 @@ DateTimePatternGenerator::operator=(const DateTimePatternGenerator& other) {\n     }\n     for (int32_t i=0; i< UDATPG_FIELD_COUNT; ++i ) {\n         appendItemFormats[i] = other.appendItemFormats[i];\n-        appendItemNames[i] = other.appendItemNames[i];\n-        // NUL-terminate for the C API.\n-        appendItemFormats[i].getTerminatedBuffer();\n-        appendItemNames[i].getTerminatedBuffer();\n+        appendItemFormats[i].getTerminatedBuffer(); // NUL-terminate for the C API.\n+        for (int32_t j=0; j< UDATPG_WIDTH_COUNT; ++j ) {\n+            fieldDisplayNames[i][j] = other.fieldDisplayNames[i][j];\n+            fieldDisplayNames[i][j].getTerminatedBuffer(); // NUL-terminate for the C API.\n+        }\n     }\n     UErrorCode status = U_ZERO_ERROR;\n     patternMap->copyFrom(*other.patternMap, status);\n@@ -399,10 +409,14 @@ DateTimePatternGenerator::operator==(const DateTimePatternGenerator& other) cons\n     if ((pLocale==other.pLocale) && (patternMap->equals(*other.patternMap)) &&\n         (dateTimeFormat==other.dateTimeFormat) && (decimal==other.decimal)) {\n         for ( int32_t i=0 ; i<UDATPG_FIELD_COUNT; ++i ) {\n-           if ((appendItemFormats[i] != other.appendItemFormats[i]) ||\n-               (appendItemNames[i] != other.appendItemNames[i]) ) {\n-               return FALSE;\n-           }\n+            if (appendItemFormats[i] != other.appendItemFormats[i]) {\n+                return FALSE;\n+            }\n+            for (int32_t j=0; j< UDATPG_WIDTH_COUNT; ++j ) {\n+                if (fieldDisplayNames[i][j] != other.fieldDisplayNames[i][j]) {\n+                    return FALSE;\n+                }\n+            }\n         }\n         return TRUE;\n     }\n@@ -824,15 +838,16 @@ struct DateTimePatternGenerator::AppendItemNamesSink : public ResourceSink {\n         ResourceTable itemsTable = value.getTable(errorCode);\n         if (U_FAILURE(errorCode)) { return; }\n         for (int32_t i = 0; itemsTable.getKeyAndValue(i, key, value); ++i) {\n-            UDateTimePatternField field = dtpg.getAppendNameNumber(key);\n+            UDateTimePGDisplayWidth width;\n+            UDateTimePatternField field = dtpg.getFieldAndWidthIndices(key, &width);\n             if (field == UDATPG_FIELD_COUNT) { continue; }\n             ResourceTable detailsTable = value.getTable(errorCode);\n             if (U_FAILURE(errorCode)) { return; }\n             for (int32_t j = 0; detailsTable.getKeyAndValue(j, key, value); ++j) {\n                 if (uprv_strcmp(key, \"dn\") != 0) { continue; }\n                 const UnicodeString& valueStr = value.getUnicodeString(errorCode);\n-                if (dtpg.getAppendItemName(field).isEmpty() && !valueStr.isEmpty()) {\n-                    dtpg.setAppendItemName(field, valueStr);\n+                if (dtpg.getFieldDisplayName(field,width).isEmpty() && !valueStr.isEmpty()) {\n+                    dtpg.setFieldDisplayName(field,width,valueStr);\n                 }\n                 break;\n             }\n@@ -841,8 +856,7 @@ struct DateTimePatternGenerator::AppendItemNamesSink : public ResourceSink {\n \n     void fillInMissing() {\n         for (int32_t i = 0; i < UDATPG_FIELD_COUNT; i++) {\n-            UDateTimePatternField field = (UDateTimePatternField)i;\n-            UnicodeString& valueStr = dtpg.getMutableAppendItemName(field);\n+            UnicodeString& valueStr = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, UDATPG_WIDE);\n             if (valueStr.isEmpty()) {\n                 valueStr = CAP_F;\n                 U_ASSERT(i < 20);\n@@ -857,6 +871,12 @@ struct DateTimePatternGenerator::AppendItemNamesSink : public ResourceSink {\n                 // NUL-terminate for the C API.\n                 valueStr.getTerminatedBuffer();\n             }\n+            for (int32_t j = 1; j < UDATPG_WIDTH_COUNT; j++) {\n+                UnicodeString& valueStr = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)j);\n+                if (valueStr.isEmpty()) {\n+                    valueStr = dtpg.getFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)(j-1));\n+                }\n+            }\n         }\n     }\n };\n@@ -969,25 +989,35 @@ DateTimePatternGenerator::getAppendItemFormat(UDateTimePatternField field) const\n \n void\n DateTimePatternGenerator::setAppendItemName(UDateTimePatternField field, const UnicodeString& value) {\n-    appendItemNames[field] = value;\n-    // NUL-terminate for the C API.\n-    appendItemNames[field].getTerminatedBuffer();\n+    setFieldDisplayName(field, UDATPG_WIDTH_APPENDITEM, value);\n }\n \n const UnicodeString&\n DateTimePatternGenerator::getAppendItemName(UDateTimePatternField field) const {\n-    return appendItemNames[field];\n+    return fieldDisplayNames[field][UDATPG_WIDTH_APPENDITEM];\n+}\n+\n+void\n+DateTimePatternGenerator::setFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width, const UnicodeString& value) {\n+    fieldDisplayNames[field][width] = value;\n+    // NUL-terminate for the C API.\n+    fieldDisplayNames[field][width].getTerminatedBuffer();\n+}\n+\n+UnicodeString\n+DateTimePatternGenerator::getFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width) const {\n+    return fieldDisplayNames[field][width];\n }\n \n UnicodeString&\n-DateTimePatternGenerator::getMutableAppendItemName(UDateTimePatternField field) {\n-    return appendItemNames[field];\n+DateTimePatternGenerator::getMutableFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width) {\n+    return fieldDisplayNames[field][width];\n }\n \n void\n DateTimePatternGenerator::getAppendName(UDateTimePatternField field, UnicodeString& value) {\n     value = SINGLE_QUOTE;\n-    value += appendItemNames[field];\n+    value += fieldDisplayNames[field][UDATPG_WIDTH_APPENDITEM];\n     value += SINGLE_QUOTE;\n }\n \n@@ -1312,9 +1342,23 @@ DateTimePatternGenerator::getAppendFormatNumber(const char* field) const {\n }\n \n UDateTimePatternField\n-DateTimePatternGenerator::getAppendNameNumber(const char* field) const {\n+DateTimePatternGenerator::getFieldAndWidthIndices(const char* key, UDateTimePGDisplayWidth* widthP) const {\n+    char cldrFieldKey[UDATPG_FIELD_KEY_MAX + 1];\n+    uprv_strncpy(cldrFieldKey, key, UDATPG_FIELD_KEY_MAX);\n+    cldrFieldKey[UDATPG_FIELD_KEY_MAX]=0; // ensure termination\n+    *widthP = UDATPG_WIDE;\n+    char* hyphenPtr = uprv_strchr(cldrFieldKey, '-');\n+    if (hyphenPtr) {\n+        for (int32_t i=UDATPG_WIDTH_COUNT-1; i>0; --i) {\n+            if (uprv_strcmp(CLDR_FIELD_WIDTH[i], hyphenPtr)==0) {\n+                *widthP=(UDateTimePGDisplayWidth)i;\n+                break;\n+            }\n+        }\n+        *hyphenPtr = 0; // now delete width portion of key\n+    }\n     for (int32_t i=0; i<UDATPG_FIELD_COUNT; ++i ) {\n-        if (uprv_strcmp(CLDR_FIELD_NAME[i],field)==0) {\n+        if (uprv_strcmp(CLDR_FIELD_NAME[i],cldrFieldKey)==0) {\n             return (UDateTimePatternField)i;\n         }\n     }"
        },
        {
            "sha": "11615a1e5141d38077b84d3eaced53862e5b8a19",
            "filename": "deps/icu-small/source/i18n/islamcal.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fislamcal.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fislamcal.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fislamcal.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -614,7 +614,7 @@ void IslamicCalendar::handleComputeFields(int32_t julianDay, UErrorCode &status)\n             days = julianDay - ASTRONOMICAL_EPOC;\n         }\n         // Use the civil calendar approximation, which is just arithmetic\n-        year  = (int)ClockMath::floorDivide( (double)(30 * days + 10646) , 10631.0 );\n+        year  = (int32_t)ClockMath::floorDivide(30 * (int64_t)days + 10646, (int64_t)10631);\n         month = (int32_t)uprv_ceil((days - 29 - yearStart(year)) / 29.5 );\n         month = month<11?month:11;\n         startDate = monthStart(year, month);"
        },
        {
            "sha": "996a20c2e043e8c6ae1e70cebb1ba9a4d37e39db",
            "filename": "deps/icu-small/source/i18n/measfmt.cpp",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasfmt.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -764,10 +764,11 @@ UnicodeString &MeasureFormat::formatMeasurePerUnit(\n     if (U_FAILURE(status)) {\n         return appendTo;\n     }\n-    MeasureUnit *resolvedUnit =\n-            MeasureUnit::resolveUnitPerUnit(measure.getUnit(), perUnit);\n-    if (resolvedUnit != NULL) {\n-        Measure newMeasure(measure.getNumber(), resolvedUnit, status);\n+    bool isResolved = false;\n+    MeasureUnit resolvedUnit =\n+        MeasureUnit::resolveUnitPerUnit(measure.getUnit(), perUnit, &isResolved);\n+    if (isResolved) {\n+        Measure newMeasure(measure.getNumber(), new MeasureUnit(resolvedUnit), status);\n         return formatMeasure(\n                 newMeasure, **numberFormat, appendTo, pos, status);\n     }\n@@ -1061,9 +1062,13 @@ UnicodeString &MeasureFormat::formatNumeric(\n     }\n \n     // Format time. draft becomes something like '5:30:45'\n+    // #13606: DateFormat is not thread-safe, but MeasureFormat advertises itself as thread-safe.\n     FieldPosition smallestFieldPosition(smallestField);\n     UnicodeString draft;\n+    static UMutex dateFmtMutex = U_MUTEX_INITIALIZER;\n+    umtx_lock(&dateFmtMutex);\n     dateFmt.format(date, draft, smallestFieldPosition, status);\n+    umtx_unlock(&dateFmtMutex);\n \n     // If we find field for smallest amount replace it with the formatted\n     // smallest amount from above taking care to replace the integer part"
        },
        {
            "sha": "e21afcba029e04fe555c2f56f72e7636f5bda89d",
            "filename": "deps/icu-small/source/i18n/measunit.cpp",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasunit.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasunit.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasunit.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -1211,8 +1211,8 @@ int32_t MeasureUnit::internalGetIndexForTypeAndSubtype(const char *type, const c\n     return gIndexes[t] + st - gOffsets[t];\n }\n \n-MeasureUnit *MeasureUnit::resolveUnitPerUnit(\n-        const MeasureUnit &unit, const MeasureUnit &perUnit) {\n+MeasureUnit MeasureUnit::resolveUnitPerUnit(\n+        const MeasureUnit &unit, const MeasureUnit &perUnit, bool* isResolved) {\n     int32_t unitOffset = unit.getOffset();\n     int32_t perUnitOffset = perUnit.getOffset();\n \n@@ -1233,10 +1233,13 @@ MeasureUnit *MeasureUnit::resolveUnitPerUnit(\n         } else {\n             // We found a resolution for our unit / per-unit combo\n             // return it.\n-            return new MeasureUnit(midRow[2], midRow[3]);\n+            *isResolved = true;\n+            return MeasureUnit(midRow[2], midRow[3]);\n         }\n     }\n-    return NULL;\n+\n+    *isResolved = false;\n+    return MeasureUnit();\n }\n \n MeasureUnit *MeasureUnit::create(int typeId, int subTypeId, UErrorCode &status) {"
        },
        {
            "sha": "659cfcbbf5a85781f2783d06cd5500fcbebb9ada",
            "filename": "deps/icu-small/source/i18n/nfrs.cpp",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrs.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrs.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrs.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -681,7 +681,7 @@ static void dumpUS(FILE* f, const UnicodeString& us) {\n #endif\n \n UBool\n-NFRuleSet::parse(const UnicodeString& text, ParsePosition& pos, double upperBound, Formattable& result) const\n+NFRuleSet::parse(const UnicodeString& text, ParsePosition& pos, double upperBound, uint32_t nonNumericalExecutedRuleMask, Formattable& result) const\n {\n     // try matching each rule in the rule set against the text being\n     // parsed.  Whichever one matches the most characters is the one\n@@ -707,9 +707,12 @@ NFRuleSet::parse(const UnicodeString& text, ParsePosition& pos, double upperBoun\n #endif\n     // Try each of the negative rules, fraction rules, infinity rules and NaN rules\n     for (int i = 0; i < NON_NUMERICAL_RULE_LENGTH; i++) {\n-        if (nonNumericalRules[i]) {\n+        if (nonNumericalRules[i] && ((nonNumericalExecutedRuleMask >> i) & 1) == 0) {\n+            // Mark this rule as being executed so that we don't try to execute it again.\n+            nonNumericalExecutedRuleMask |= 1 << i;\n+\n             Formattable tempResult;\n-            UBool success = nonNumericalRules[i]->doParse(text, workingPos, 0, upperBound, tempResult);\n+            UBool success = nonNumericalRules[i]->doParse(text, workingPos, 0, upperBound, nonNumericalExecutedRuleMask, tempResult);\n             if (success && (workingPos.getIndex() > highWaterMark.getIndex())) {\n                 result = tempResult;\n                 highWaterMark = workingPos;\n@@ -748,7 +751,7 @@ NFRuleSet::parse(const UnicodeString& text, ParsePosition& pos, double upperBoun\n                 continue;\n             }\n             Formattable tempResult;\n-            UBool success = rules[i]->doParse(text, workingPos, fIsFractionRuleSet, upperBound, tempResult);\n+            UBool success = rules[i]->doParse(text, workingPos, fIsFractionRuleSet, upperBound, nonNumericalExecutedRuleMask, tempResult);\n             if (success && workingPos.getIndex() > highWaterMark.getIndex()) {\n                 result = tempResult;\n                 highWaterMark = workingPos;"
        },
        {
            "sha": "c56fc0707851a74b05e961eec1ed23e6d1804ff1",
            "filename": "deps/icu-small/source/i18n/nfrs.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrs.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrs.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrs.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -55,7 +55,7 @@ class NFRuleSet : public UMemory {\n     void  format(int64_t number, UnicodeString& toAppendTo, int32_t pos, int32_t recursionCount, UErrorCode& status) const;\n     void  format(double number, UnicodeString& toAppendTo, int32_t pos, int32_t recursionCount, UErrorCode& status) const;\n \n-    UBool parse(const UnicodeString& text, ParsePosition& pos, double upperBound, Formattable& result) const;\n+    UBool parse(const UnicodeString& text, ParsePosition& pos, double upperBound, uint32_t nonNumericalExecutedRuleMask, Formattable& result) const;\n \n     void appendRules(UnicodeString& result) const; // toString\n "
        },
        {
            "sha": "9f5deb31683291c26e7ca383d62731c476e62fb4",
            "filename": "deps/icu-small/source/i18n/nfrule.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -900,6 +900,7 @@ NFRule::doParse(const UnicodeString& text,\n                 ParsePosition& parsePosition,\n                 UBool isFractionRule,\n                 double upperBound,\n+                uint32_t nonNumericalExecutedRuleMask,\n                 Formattable& resVal) const\n {\n     // internally we operate on a copy of the string being parsed\n@@ -1002,6 +1003,7 @@ NFRule::doParse(const UnicodeString& text,\n         temp.setTo(ruleText, sub1Pos, sub2Pos - sub1Pos);\n         double partialResult = matchToDelimiter(workText, start, tempBaseValue,\n             temp, pp, sub1,\n+            nonNumericalExecutedRuleMask,\n             upperBound);\n \n         // if we got a successful match (or were trying to match a\n@@ -1022,6 +1024,7 @@ NFRule::doParse(const UnicodeString& text,\n             temp.setTo(ruleText, sub2Pos, ruleText.length() - sub2Pos);\n             partialResult = matchToDelimiter(workText2, 0, partialResult,\n                 temp, pp2, sub2,\n+                nonNumericalExecutedRuleMask,\n                 upperBound);\n \n             // if we got a successful match on this second\n@@ -1158,6 +1161,7 @@ NFRule::matchToDelimiter(const UnicodeString& text,\n                          const UnicodeString& delimiter,\n                          ParsePosition& pp,\n                          const NFSubstitution* sub,\n+                         uint32_t nonNumericalExecutedRuleMask,\n                          double upperBound) const\n {\n \tUErrorCode status = U_ZERO_ERROR;\n@@ -1191,6 +1195,7 @@ NFRule::matchToDelimiter(const UnicodeString& text,\n #else\n                     formatter->isLenient(),\n #endif\n+                    nonNumericalExecutedRuleMask,\n                     result);\n \n                 // if the substitution could match all the text up to\n@@ -1244,6 +1249,7 @@ NFRule::matchToDelimiter(const UnicodeString& text,\n #else\n             formatter->isLenient(),\n #endif\n+            nonNumericalExecutedRuleMask,\n             result);\n         if (success && (tempPP.getIndex() != 0)) {\n             // if there's a successful match (or it's a null"
        },
        {
            "sha": "843a4a0762bb0181f1b059fdf2ccdbf3597790ae",
            "filename": "deps/icu-small/source/i18n/nfrule.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -74,6 +74,7 @@ class NFRule : public UMemory {\n                   ParsePosition& pos,\n                   UBool isFractional,\n                   double upperBound,\n+                  uint32_t nonNumericalExecutedRuleMask,\n                   Formattable& result) const;\n \n     UBool shouldRollBack(int64_t number) const;\n@@ -94,6 +95,7 @@ class NFRule : public UMemory {\n     int32_t indexOfAnyRulePrefix() const;\n     double matchToDelimiter(const UnicodeString& text, int32_t startPos, double baseValue,\n                             const UnicodeString& delimiter, ParsePosition& pp, const NFSubstitution* sub,\n+                            uint32_t nonNumericalExecutedRuleMask,\n                             double upperBound) const;\n     void stripPrefix(UnicodeString& text, const UnicodeString& prefix, ParsePosition& pp) const;\n "
        },
        {
            "sha": "ea817453d87c18b434e9e5a9c6d8c74f772733ab",
            "filename": "deps/icu-small/source/i18n/nfsubs.cpp",
            "status": "modified",
            "additions": 14,
            "deletions": 7,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfsubs.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfsubs.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfsubs.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -155,6 +155,7 @@ class ModulusSubstitution : public NFSubstitution {\n         double baseValue,\n         double upperBound,\n         UBool lenientParse,\n+        uint32_t nonNumericalExecutedRuleMask,\n         Formattable& result) const;\n \n     virtual double composeRuleValue(double newRuleValue, double oldRuleValue) const {\n@@ -221,6 +222,7 @@ class FractionalPartSubstitution : public NFSubstitution {\n         double baseValue,\n         double upperBound,\n         UBool lenientParse,\n+        uint32_t nonNumericalExecutedRuleMask,\n         Formattable& result) const;\n \n     virtual double composeRuleValue(double newRuleValue, double oldRuleValue) const { return newRuleValue + oldRuleValue; }\n@@ -292,6 +294,7 @@ class NumeratorSubstitution : public NFSubstitution {\n         double baseValue,\n         double upperBound,\n         UBool /*lenientParse*/,\n+        uint32_t nonNumericalExecutedRuleMask,\n         Formattable& result) const;\n \n     virtual double composeRuleValue(double newRuleValue, double oldRuleValue) const { return newRuleValue / oldRuleValue; }\n@@ -689,6 +692,7 @@ NFSubstitution::doParse(const UnicodeString& text,\n                         double baseValue,\n                         double upperBound,\n                         UBool lenientParse,\n+                        uint32_t nonNumericalExecutedRuleMask,\n                         Formattable& result) const\n {\n #ifdef RBNF_DEBUG\n@@ -709,7 +713,7 @@ NFSubstitution::doParse(const UnicodeString& text,\n     // on), then also try parsing the text using a default-\n     // constructed NumberFormat\n     if (ruleSet != NULL) {\n-        ruleSet->parse(text, parsePosition, upperBound, result);\n+        ruleSet->parse(text, parsePosition, upperBound, nonNumericalExecutedRuleMask, result);\n         if (lenientParse && !ruleSet->isFractionRuleSet() && parsePosition.getIndex() == 0) {\n             UErrorCode status = U_ZERO_ERROR;\n             NumberFormat* fmt = NumberFormat::createInstance(status);\n@@ -931,18 +935,19 @@ ModulusSubstitution::doParse(const UnicodeString& text,\n                              double baseValue,\n                              double upperBound,\n                              UBool lenientParse,\n+                             uint32_t nonNumericalExecutedRuleMask,\n                              Formattable& result) const\n {\n     // if this isn't a >>> substitution, we can just use the\n     // inherited parse() routine to do the parsing\n     if (ruleToUse == NULL) {\n-        return NFSubstitution::doParse(text, parsePosition, baseValue, upperBound, lenientParse, result);\n+        return NFSubstitution::doParse(text, parsePosition, baseValue, upperBound, lenientParse, nonNumericalExecutedRuleMask, result);\n \n         // but if it IS a >>> substitution, we have to do it here: we\n         // use the specific rule's doParse() method, and then we have to\n         // do some of the other work of NFRuleSet.parse()\n     } else {\n-        ruleToUse->doParse(text, parsePosition, FALSE, upperBound, result);\n+        ruleToUse->doParse(text, parsePosition, FALSE, upperBound, nonNumericalExecutedRuleMask, result);\n \n         if (parsePosition.getIndex() != 0) {\n             UErrorCode status = U_ZERO_ERROR;\n@@ -1118,12 +1123,13 @@ FractionalPartSubstitution::doParse(const UnicodeString& text,\n                 double baseValue,\n                 double /*upperBound*/,\n                 UBool lenientParse,\n+                uint32_t nonNumericalExecutedRuleMask,\n                 Formattable& resVal) const\n {\n     // if we're not in byDigits mode, we can just use the inherited\n     // doParse()\n     if (!byDigits) {\n-        return NFSubstitution::doParse(text, parsePosition, baseValue, 0, lenientParse, resVal);\n+        return NFSubstitution::doParse(text, parsePosition, baseValue, 0, lenientParse, nonNumericalExecutedRuleMask, resVal);\n \n         // if we ARE in byDigits mode, parse the text one digit at a time\n         // using this substitution's owning rule set (we do this by setting\n@@ -1141,7 +1147,7 @@ FractionalPartSubstitution::doParse(const UnicodeString& text,\n         while (workText.length() > 0 && workPos.getIndex() != 0) {\n             workPos.setIndex(0);\n             Formattable temp;\n-            getRuleSet()->parse(workText, workPos, 10, temp);\n+            getRuleSet()->parse(workText, workPos, 10, nonNumericalExecutedRuleMask, temp);\n             UErrorCode status = U_ZERO_ERROR;\n             digit = temp.getLong(status);\n //            digit = temp.getType() == Formattable::kLong ?\n@@ -1249,6 +1255,7 @@ NumeratorSubstitution::doParse(const UnicodeString& text,\n                                double baseValue,\n                                double upperBound,\n                                UBool /*lenientParse*/,\n+                               uint32_t nonNumericalExecutedRuleMask,\n                                Formattable& result) const\n {\n     // we don't have to do anything special to do the parsing here,\n@@ -1267,7 +1274,7 @@ NumeratorSubstitution::doParse(const UnicodeString& text,\n \n         while (workText.length() > 0 && workPos.getIndex() != 0) {\n             workPos.setIndex(0);\n-            getRuleSet()->parse(workText, workPos, 1, temp); // parse zero or nothing at all\n+            getRuleSet()->parse(workText, workPos, 1, nonNumericalExecutedRuleMask, temp); // parse zero or nothing at all\n             if (workPos.getIndex() == 0) {\n                 // we failed, either there were no more zeros, or the number was formatted with digits\n                 // either way, we're done\n@@ -1289,7 +1296,7 @@ NumeratorSubstitution::doParse(const UnicodeString& text,\n     }\n \n     // we've parsed off the zeros, now let's parse the rest from our current position\n-    NFSubstitution::doParse(workText, parsePosition, withZeros ? 1 : baseValue, upperBound, FALSE, result);\n+    NFSubstitution::doParse(workText, parsePosition, withZeros ? 1 : baseValue, upperBound, FALSE, nonNumericalExecutedRuleMask, result);\n \n     if (withZeros) {\n         // any base value will do in this case.  is there a way to"
        },
        {
            "sha": "08de06f2a38e1eeb304607b8f999758379b335b5",
            "filename": "deps/icu-small/source/i18n/nfsubs.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfsubs.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfsubs.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfsubs.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -191,6 +191,7 @@ class NFSubstitution : public UObject {\n         double baseValue,\n         double upperBound,\n         UBool lenientParse,\n+        uint32_t nonNumericalExecutedRuleMask,\n         Formattable& result) const;\n \n     /**"
        },
        {
            "sha": "df4b267af5a00468105a976fe814c05febb1bd0b",
            "filename": "deps/icu-small/source/i18n/number_affixutils.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_affixutils.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_affixutils.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_affixutils.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -70,6 +70,7 @@ int32_t AffixUtils::estimateLength(const CharSequence &patternString, UErrorCode\n         case STATE_FIRST_QUOTE:\n         case STATE_INSIDE_QUOTE:\n             status = U_ILLEGAL_ARGUMENT_ERROR;\n+            break;\n         default:\n             break;\n     }"
        },
        {
            "sha": "cc0d8fd2a20ccec5543b5976de27b4539f9ee9ae",
            "filename": "deps/icu-small/source/i18n/number_compact.cpp",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_compact.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_compact.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_compact.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -262,7 +262,6 @@ void CompactHandler::precomputeAllModifiers(MutablePatternModifier &buildReferen\n         buildReference.setPatternInfo(&patternInfo);\n         info.mod = buildReference.createImmutable(status);\n         if (U_FAILURE(status)) { return; }\n-        info.numDigits = patternInfo.positive.integerTotal;\n         info.patternString = patternString;\n     }\n }\n@@ -286,7 +285,6 @@ void CompactHandler::processQuantity(DecimalQuantity &quantity, MicroProps &micr\n \n     StandardPlural::Form plural = quantity.getStandardPlural(rules);\n     const UChar *patternString = data.getPattern(magnitude, plural);\n-    int numDigits = -1;\n     if (patternString == nullptr) {\n         // Use the default (non-compact) modifier.\n         // No need to take any action.\n@@ -299,7 +297,6 @@ void CompactHandler::processQuantity(DecimalQuantity &quantity, MicroProps &micr\n             const CompactModInfo &info = precomputedMods[i];\n             if (u_strcmp(patternString, info.patternString) == 0) {\n                 info.mod->applyToMicros(micros, quantity);\n-                numDigits = info.numDigits;\n                 break;\n             }\n         }\n@@ -313,12 +310,8 @@ void CompactHandler::processQuantity(DecimalQuantity &quantity, MicroProps &micr\n         PatternParser::parseToPatternInfo(UnicodeString(patternString), patternInfo, status);\n         static_cast<MutablePatternModifier*>(const_cast<Modifier*>(micros.modMiddle))\n             ->setPatternInfo(&patternInfo);\n-        numDigits = patternInfo.positive.integerTotal;\n     }\n \n-    // FIXME: Deal with numDigits == 0 (Awaiting a test case)\n-    (void)numDigits;\n-\n     // We already performed rounding. Do not perform it again.\n     micros.rounding = Rounder::constructPassThrough();\n }"
        },
        {
            "sha": "f7adf36416e92f0435facf5d6f80c30bbda6f941",
            "filename": "deps/icu-small/source/i18n/number_compact.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_compact.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_compact.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_compact.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -52,7 +52,6 @@ class CompactData : public MultiplierProducer {\n struct CompactModInfo {\n     const ImmutablePatternModifier *mod;\n     const UChar* patternString;\n-    int32_t numDigits;\n };\n \n class CompactHandler : public MicroPropsGenerator, public UMemory {"
        },
        {
            "sha": "b68df26ba26167dc704fd808c8e9078061f61e61",
            "filename": "deps/icu-small/source/i18n/number_decimalquantity.cpp",
            "status": "modified",
            "additions": 45,
            "deletions": 22,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimalquantity.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimalquantity.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimalquantity.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -14,12 +14,15 @@\n #include \"decContext.h\"\n #include \"decNumber.h\"\n #include \"number_roundingutils.h\"\n+#include \"double-conversion.h\"\n #include \"unicode/plurrule.h\"\n \n using namespace icu;\n using namespace icu::number;\n using namespace icu::number::impl;\n \n+using icu::double_conversion::DoubleToStringConverter;\n+\n namespace {\n \n int8_t NEGATIVE_FLAG = 1;\n@@ -265,6 +268,10 @@ bool DecimalQuantity::isNegative() const {\n     return (flags & NEGATIVE_FLAG) != 0;\n }\n \n+int8_t DecimalQuantity::signum() const {\n+    return isNegative() ? -1 : isZero() ? 0 : 1;\n+}\n+\n bool DecimalQuantity::isInfinite() const {\n     return (flags & INFINITY_FLAG) != 0;\n }\n@@ -392,31 +399,27 @@ void DecimalQuantity::_setToDoubleFast(double n) {\n }\n \n void DecimalQuantity::convertToAccurateDouble() {\n-    double n = origDouble;\n-    U_ASSERT(n != 0);\n+    U_ASSERT(origDouble != 0);\n     int32_t delta = origDelta;\n-    setBcdToZero();\n \n-    // Call the slow oracle function (Double.toString in Java, sprintf in C++).\n-    // The <float.h> constant DBL_DIG defines a platform-specific number of digits in a double.\n-    // However, this tends to be too low (see #11318). Instead, we always use 14 decimal places.\n-    static constexpr size_t CAP = 1 + 14 + 8; // Extra space for '+', '.', e+NNN, and '\\0'\n-    char dstr[CAP];\n-    snprintf(dstr, CAP, \"%+1.14e\", n);\n-\n-    // uprv_decNumberFromString() will parse the string expecting '.' as a\n-    // decimal separator, however sprintf() can use ',' in certain locales.\n-    // Overwrite a ',' with '.' here before proceeding.\n-    char *decimalSeparator = strchr(dstr, ',');\n-    if (decimalSeparator != nullptr) {\n-        *decimalSeparator = '.';\n-    }\n-\n-    StringPiece sp(dstr);\n-    DecNumberWithStorage dn;\n-    stringToDecNumber(dstr, dn);\n-    _setToDecNumber(dn.getAlias());\n+    // Call the slow oracle function (Double.toString in Java, DoubleToAscii in C++).\n+    char buffer[DoubleToStringConverter::kBase10MaximalLength + 1];\n+    bool sign; // unused; always positive\n+    int32_t length;\n+    int32_t point;\n+    DoubleToStringConverter::DoubleToAscii(\n+        origDouble,\n+        DoubleToStringConverter::DtoaMode::SHORTEST,\n+        0,\n+        buffer,\n+        sizeof(buffer),\n+        &sign,\n+        &length,\n+        &point\n+    );\n \n+    setBcdToZero();\n+    readDoubleConversionToBcd(buffer, length, point);\n     scale += delta;\n     explicitExactDouble = true;\n }\n@@ -833,6 +836,26 @@ void DecimalQuantity::readDecNumberToBcd(decNumber *dn) {\n     precision = dn->digits;\n }\n \n+void DecimalQuantity::readDoubleConversionToBcd(\n+        const char* buffer, int32_t length, int32_t point) {\n+    // NOTE: Despite the fact that double-conversion's API is called\n+    // \"DoubleToAscii\", they actually use '0' (as opposed to u8'0').\n+    if (length > 16) {\n+        ensureCapacity(length);\n+        for (int32_t i = 0; i < length; i++) {\n+            fBCD.bcdBytes.ptr[i] = buffer[length-i-1] - '0';\n+        }\n+    } else {\n+        uint64_t result = 0L;\n+        for (int32_t i = 0; i < length; i++) {\n+            result |= static_cast<uint64_t>(buffer[length-i-1] - '0') << (4 * i);\n+        }\n+        fBCD.bcdLong = result;\n+    }\n+    scale = point - length;\n+    precision = length;\n+}\n+\n void DecimalQuantity::compact() {\n     if (usingBytes) {\n         int32_t delta = 0;"
        },
        {
            "sha": "4309c3c6380ac421765946705d982847135f3037",
            "filename": "deps/icu-small/source/i18n/number_decimalquantity.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimalquantity.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimalquantity.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimalquantity.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -115,6 +115,9 @@ class U_I18N_API DecimalQuantity : public IFixedDecimal, public UMemory {\n     /** @return Whether the value represented by this {@link DecimalQuantity} is less than zero. */\n     bool isNegative() const;\n \n+    /** @return -1 if the value is negative; 1 if positive; or 0 if zero. */\n+    int8_t signum() const;\n+\n     /** @return Whether the value represented by this {@link DecimalQuantity} is infinite. */\n     bool isInfinite() const U_OVERRIDE;\n \n@@ -395,6 +398,8 @@ class U_I18N_API DecimalQuantity : public IFixedDecimal, public UMemory {\n \n     void readDecNumberToBcd(decNumber *dn);\n \n+    void readDoubleConversionToBcd(const char* buffer, int32_t length, int32_t point);\n+\n     void copyBcdFrom(const DecimalQuantity &other);\n \n     /**"
        },
        {
            "sha": "96356cad45321d05d0bb117d586ff05aa5133d26",
            "filename": "deps/icu-small/source/i18n/number_decimfmtprops.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimfmtprops.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimfmtprops.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimfmtprops.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -19,8 +19,8 @@ U_NAMESPACE_BEGIN\n \n // Export an explicit template instantiation of the LocalPointer that is used as a\n // data member of CurrencyPluralInfoWrapper.\n-// (MSVC requires this, even though it should not be necessary.)\n-#if defined (_MSC_VER)\n+// (When building DLLs for Windows this is required.)\n+#if U_PF_WINDOWS <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN\n // Ignore warning 4661 as LocalPointerBase does not use operator== or operator!=\n #pragma warning(suppress: 4661)\n template class U_I18N_API LocalPointerBase<CurrencyPluralInfo>;"
        },
        {
            "sha": "27113106c5045117efdc9eb1d4a5e3a467df1d94",
            "filename": "deps/icu-small/source/i18n/number_fluent.cpp",
            "status": "modified",
            "additions": 27,
            "deletions": 4,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_fluent.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_fluent.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_fluent.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -33,18 +33,39 @@ Derived NumberFormatterSettings<Derived>::unit(const icu::MeasureUnit &unit) con\n }\n \n template<typename Derived>\n-Derived NumberFormatterSettings<Derived>::adoptUnit(const icu::MeasureUnit *unit) const {\n+Derived NumberFormatterSettings<Derived>::adoptUnit(icu::MeasureUnit *unit) const {\n     Derived copy(*this);\n     // Just copy the unit into the MacroProps by value, and delete it since we have ownership.\n     // NOTE: Slicing occurs here. However, CurrencyUnit can be restored from MeasureUnit.\n     // TimeUnit may be affected, but TimeUnit is not as relevant to number formatting.\n     if (unit != nullptr) {\n+      // TODO: On nullptr, reset to default value?\n         copy.fMacros.unit = *unit;\n         delete unit;\n     }\n     return copy;\n }\n \n+template<typename Derived>\n+Derived NumberFormatterSettings<Derived>::perUnit(const icu::MeasureUnit &perUnit) const {\n+    Derived copy(*this);\n+    // See comments above about slicing.\n+    copy.fMacros.perUnit = perUnit;\n+    return copy;\n+}\n+\n+template<typename Derived>\n+Derived NumberFormatterSettings<Derived>::adoptPerUnit(icu::MeasureUnit *perUnit) const {\n+    Derived copy(*this);\n+    // See comments above about slicing and ownership.\n+    if (perUnit != nullptr) {\n+      // TODO: On nullptr, reset to default value?\n+        copy.fMacros.perUnit = *perUnit;\n+        delete perUnit;\n+    }\n+    return copy;\n+}\n+\n template<typename Derived>\n Derived NumberFormatterSettings<Derived>::rounding(const Rounder &rounder) const {\n     Derived copy(*this);\n@@ -54,9 +75,11 @@ Derived NumberFormatterSettings<Derived>::rounding(const Rounder &rounder) const\n }\n \n template<typename Derived>\n-Derived NumberFormatterSettings<Derived>::grouping(const Grouper &grouper) const {\n+Derived NumberFormatterSettings<Derived>::grouping(const UGroupingStrategy &strategy) const {\n     Derived copy(*this);\n-    copy.fMacros.grouper = grouper;\n+    // NOTE: This is slightly different than how the setting is stored in Java\n+    // because we want to put it on the stack.\n+    copy.fMacros.grouper = Grouper::forStrategy(strategy);\n     return copy;\n }\n \n@@ -75,7 +98,7 @@ Derived NumberFormatterSettings<Derived>::symbols(const DecimalFormatSymbols &sy\n }\n \n template<typename Derived>\n-Derived NumberFormatterSettings<Derived>::adoptSymbols(const NumberingSystem *ns) const {\n+Derived NumberFormatterSettings<Derived>::adoptSymbols(NumberingSystem *ns) const {\n     Derived copy(*this);\n     copy.fMacros.symbols.setTo(ns);\n     return copy;"
        },
        {
            "sha": "bc96cb15dabf9024214a83d4a57bc4f760e83d57",
            "filename": "deps/icu-small/source/i18n/number_formatimpl.cpp",
            "status": "modified",
            "additions": 83,
            "deletions": 26,
            "changes": 109,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_formatimpl.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_formatimpl.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_formatimpl.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -17,6 +17,8 @@\n #include \"unicode/dcfmtsym.h\"\n #include \"number_scientific.h\"\n #include \"number_compact.h\"\n+#include \"uresimp.h\"\n+#include \"ureslocs.h\"\n \n using namespace icu;\n using namespace icu::number;\n@@ -88,6 +90,37 @@ const char16_t *getPatternForStyle(const Locale &locale, const char *nsName, Cld\n     return pattern;\n }\n \n+struct CurrencyFormatInfoResult {\n+    bool exists;\n+    const char16_t* pattern;\n+    const char16_t* decimalSeparator;\n+    const char16_t* groupingSeparator;\n+};\n+CurrencyFormatInfoResult getCurrencyFormatInfo(const Locale& locale, const char* isoCode, UErrorCode& status) {\n+    // TODO: Load this data in a centralized location like ICU4J?\n+    // TODO: Parts of this same data are loaded in dcfmtsym.cpp; should clean up.\n+    CurrencyFormatInfoResult result = { false, nullptr, nullptr, nullptr };\n+    if (U_FAILURE(status)) return result;\n+    CharString key;\n+    key.append(\"Currencies/\", status);\n+    key.append(isoCode, status);\n+    UErrorCode localStatus = status;\n+    LocalUResourceBundlePointer bundle(ures_open(U_ICUDATA_CURR, locale.getName(), &localStatus));\n+    ures_getByKeyWithFallback(bundle.getAlias(), key.data(), bundle.getAlias(), &localStatus);\n+    if (U_SUCCESS(localStatus) && ures_getSize(bundle.getAlias())>2) { // the length is 3 if more data is present\n+        ures_getByIndex(bundle.getAlias(), 2, bundle.getAlias(), &localStatus);\n+        int32_t dummy;\n+        result.exists = true;\n+        result.pattern = ures_getStringByIndex(bundle.getAlias(), 0, &dummy, &localStatus);\n+        result.decimalSeparator = ures_getStringByIndex(bundle.getAlias(), 1, &dummy, &localStatus);\n+        result.groupingSeparator = ures_getStringByIndex(bundle.getAlias(), 2, &dummy, &localStatus);\n+        status = localStatus;\n+    } else if (localStatus != U_MISSING_RESOURCE_ERROR) {\n+        status = localStatus;\n+    }\n+    return result;\n+}\n+\n inline bool unitIsCurrency(const MeasureUnit &unit) {\n     return uprv_strcmp(\"currency\", unit.getType()) == 0;\n }\n@@ -161,8 +194,9 @@ NumberFormatterImpl::macrosToMicroGenerator(const MacroProps &macros, bool safe,\n     bool isPercent = isNoUnit && unitIsPercent(macros.unit);\n     bool isPermille = isNoUnit && unitIsPermille(macros.unit);\n     bool isCldrUnit = !isCurrency && !isNoUnit;\n-    bool isAccounting =\n-            macros.sign == UNUM_SIGN_ACCOUNTING || macros.sign == UNUM_SIGN_ACCOUNTING_ALWAYS;\n+    bool isAccounting = macros.sign == UNUM_SIGN_ACCOUNTING\n+            || macros.sign == UNUM_SIGN_ACCOUNTING_ALWAYS\n+            || macros.sign == UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO;\n     CurrencyUnit currency(kDefaultCurrency, status);\n     if (isCurrency) {\n         currency = CurrencyUnit(macros.unit, status); // Restore CurrencyUnit from MeasureUnit\n@@ -185,20 +219,51 @@ NumberFormatterImpl::macrosToMicroGenerator(const MacroProps &macros, bool safe,\n     }\n     const char *nsName = U_SUCCESS(status) ? ns->getName() : \"latn\";\n \n-    // Load and parse the pattern string.  It is used for grouping sizes and affixes only.\n-    CldrPatternStyle patternStyle;\n-    if (isPercent || isPermille) {\n-        patternStyle = CLDR_PATTERN_STYLE_PERCENT;\n-    } else if (!isCurrency || unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {\n-        patternStyle = CLDR_PATTERN_STYLE_DECIMAL;\n-    } else if (isAccounting) {\n-        // NOTE: Although ACCOUNTING and ACCOUNTING_ALWAYS are only supported in currencies right now,\n-        // the API contract allows us to add support to other units in the future.\n-        patternStyle = CLDR_PATTERN_STYLE_ACCOUNTING;\n+    // Resolve the symbols. Do this here because currency may need to customize them.\n+    if (macros.symbols.isDecimalFormatSymbols()) {\n+        fMicros.symbols = macros.symbols.getDecimalFormatSymbols();\n     } else {\n-        patternStyle = CLDR_PATTERN_STYLE_CURRENCY;\n+        fMicros.symbols = new DecimalFormatSymbols(macros.locale, *ns, status);\n+        // Give ownership to the NumberFormatterImpl.\n+        fSymbols.adoptInstead(fMicros.symbols);\n+    }\n+\n+    // Load and parse the pattern string. It is used for grouping sizes and affixes only.\n+    // If we are formatting currency, check for a currency-specific pattern.\n+    const char16_t* pattern = nullptr;\n+    if (isCurrency) {\n+        CurrencyFormatInfoResult info = getCurrencyFormatInfo(macros.locale, currency.getSubtype(), status);\n+        if (info.exists) {\n+            pattern = info.pattern;\n+            // It's clunky to clone an object here, but this code is not frequently executed.\n+            DecimalFormatSymbols* symbols = new DecimalFormatSymbols(*fMicros.symbols);\n+            fMicros.symbols = symbols;\n+            fSymbols.adoptInstead(symbols);\n+            symbols->setSymbol(\n+                DecimalFormatSymbols::ENumberFormatSymbol::kMonetarySeparatorSymbol,\n+                UnicodeString(info.decimalSeparator),\n+                FALSE);\n+            symbols->setSymbol(\n+                DecimalFormatSymbols::ENumberFormatSymbol::kMonetaryGroupingSeparatorSymbol,\n+                UnicodeString(info.groupingSeparator),\n+                FALSE);\n+        }\n+    }\n+    if (pattern == nullptr) {\n+        CldrPatternStyle patternStyle;\n+        if (isPercent || isPermille) {\n+            patternStyle = CLDR_PATTERN_STYLE_PERCENT;\n+        } else if (!isCurrency || unitWidth == UNUM_UNIT_WIDTH_FULL_NAME) {\n+            patternStyle = CLDR_PATTERN_STYLE_DECIMAL;\n+        } else if (isAccounting) {\n+            // NOTE: Although ACCOUNTING and ACCOUNTING_ALWAYS are only supported in currencies right now,\n+            // the API contract allows us to add support to other units in the future.\n+            patternStyle = CLDR_PATTERN_STYLE_ACCOUNTING;\n+        } else {\n+            patternStyle = CLDR_PATTERN_STYLE_CURRENCY;\n+        }\n+        pattern = getPatternForStyle(macros.locale, nsName, patternStyle, status);\n     }\n-    const char16_t *pattern = getPatternForStyle(macros.locale, nsName, patternStyle, status);\n     auto patternInfo = new ParsedPatternInfo();\n     fPatternInfo.adoptInstead(patternInfo);\n     PatternParser::parseToPatternInfo(UnicodeString(pattern), *patternInfo, status);\n@@ -207,15 +272,6 @@ NumberFormatterImpl::macrosToMicroGenerator(const MacroProps &macros, bool safe,\n     /// START POPULATING THE DEFAULT MICROPROPS AND BUILDING THE MICROPROPS GENERATOR ///\n     /////////////////////////////////////////////////////////////////////////////////////\n \n-    // Symbols\n-    if (macros.symbols.isDecimalFormatSymbols()) {\n-        fMicros.symbols = macros.symbols.getDecimalFormatSymbols();\n-    } else {\n-        fMicros.symbols = new DecimalFormatSymbols(macros.locale, *ns, status);\n-        // Give ownership to the NumberFormatterImpl.\n-        fSymbols.adoptInstead(fMicros.symbols);\n-    }\n-\n     // Rounding strategy\n     if (!macros.rounder.isBogus()) {\n         fMicros.rounding = macros.rounder;\n@@ -233,11 +289,11 @@ NumberFormatterImpl::macrosToMicroGenerator(const MacroProps &macros, bool safe,\n         fMicros.grouping = macros.grouper;\n     } else if (macros.notation.fType == Notation::NTN_COMPACT) {\n         // Compact notation uses minGrouping by default since ICU 59\n-        fMicros.grouping = Grouper::minTwoDigits();\n+        fMicros.grouping = Grouper::forStrategy(UNUM_GROUPING_MIN2);\n     } else {\n-        fMicros.grouping = Grouper::defaults();\n+        fMicros.grouping = Grouper::forStrategy(UNUM_GROUPING_AUTO);\n     }\n-    fMicros.grouping.setLocaleData(*fPatternInfo);\n+    fMicros.grouping.setLocaleData(*fPatternInfo, macros.locale);\n \n     // Padding strategy\n     if (!macros.padder.isBogus()) {\n@@ -308,6 +364,7 @@ NumberFormatterImpl::macrosToMicroGenerator(const MacroProps &macros, bool safe,\n                         LongNameHandler::forMeasureUnit(\n                                 macros.locale,\n                                 macros.unit,\n+                                macros.perUnit,\n                                 unitWidth,\n                                 resolvePluralRules(macros.rules, macros.locale, status),\n                                 chain,"
        },
        {
            "sha": "a2b1bbd6b3388e3bd3c4da3271f60c008ba913a5",
            "filename": "deps/icu-small/source/i18n/number_grouping.cpp",
            "status": "modified",
            "additions": 47,
            "deletions": 13,
            "changes": 60,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_grouping.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_grouping.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_grouping.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -7,36 +7,70 @@\n \n #include \"unicode/numberformatter.h\"\n #include \"number_patternstring.h\"\n+#include \"uresimp.h\"\n \n using namespace icu;\n using namespace icu::number;\n using namespace icu::number::impl;\n \n-Grouper Grouper::defaults() {\n-    return {-2, -2, false};\n+namespace {\n+\n+int16_t getMinGroupingForLocale(const Locale& locale) {\n+    // TODO: Cache this?\n+    UErrorCode localStatus = U_ZERO_ERROR;\n+    LocalUResourceBundlePointer bundle(ures_open(NULL, locale.getName(), &localStatus));\n+    int32_t resultLen = 0;\n+    const char16_t* result = ures_getStringByKeyWithFallback(\n+        bundle.getAlias(),\n+        \"NumberElements/minimumGroupingDigits\",\n+        &resultLen,\n+        &localStatus);\n+    // TODO: Is it safe to assume resultLen == 1? Would locales set minGrouping >= 10?\n+    if (U_FAILURE(localStatus) || resultLen != 1) {\n+        return 1;\n+    }\n+    return result[0] - u'0';\n }\n \n-Grouper Grouper::minTwoDigits() {\n-    return {-2, -2, true};\n }\n \n-Grouper Grouper::none() {\n-    return {-1, -1, false};\n+Grouper Grouper::forStrategy(UGroupingStrategy grouping) {\n+    switch (grouping) {\n+    case UNUM_GROUPING_OFF:\n+        return {-1, -1, -2};\n+    case UNUM_GROUPING_AUTO:\n+        return {-2, -2, -2};\n+    case UNUM_GROUPING_MIN2:\n+        return {-2, -2, -3};\n+    case UNUM_GROUPING_ON_ALIGNED:\n+        return {-4, -4, 1};\n+    case UNUM_GROUPING_THOUSANDS:\n+        return {3, 3, 1};\n+    default:\n+        U_ASSERT(FALSE);\n+    }\n }\n \n-void Grouper::setLocaleData(const impl::ParsedPatternInfo &patternInfo) {\n-    if (fGrouping1 != -2) {\n+void Grouper::setLocaleData(const impl::ParsedPatternInfo &patternInfo, const Locale& locale) {\n+    if (fGrouping1 != -2 && fGrouping2 != -4) {\n         return;\n     }\n-    auto grouping1 = static_cast<int8_t> (patternInfo.positive.groupingSizes & 0xffff);\n-    auto grouping2 = static_cast<int8_t> ((patternInfo.positive.groupingSizes >> 16) & 0xffff);\n-    auto grouping3 = static_cast<int8_t> ((patternInfo.positive.groupingSizes >> 32) & 0xffff);\n+    auto grouping1 = static_cast<int16_t> (patternInfo.positive.groupingSizes & 0xffff);\n+    auto grouping2 = static_cast<int16_t> ((patternInfo.positive.groupingSizes >> 16) & 0xffff);\n+    auto grouping3 = static_cast<int16_t> ((patternInfo.positive.groupingSizes >> 32) & 0xffff);\n     if (grouping2 == -1) {\n-        grouping1 = -1;\n+        grouping1 = fGrouping1 == -4 ? (short) 3 : (short) -1;\n     }\n     if (grouping3 == -1) {\n         grouping2 = grouping1;\n     }\n+    if (fMinGrouping == -2) {\n+        fMinGrouping = getMinGroupingForLocale(locale);\n+    } else if (fMinGrouping == -3) {\n+        fMinGrouping = uprv_max(2, getMinGroupingForLocale(locale));\n+    } else {\n+        // leave fMinGrouping alone\n+    }\n     fGrouping1 = grouping1;\n     fGrouping2 = grouping2;\n }\n@@ -49,7 +83,7 @@ bool Grouper::groupAtPosition(int32_t position, const impl::DecimalQuantity &val\n     }\n     position -= fGrouping1;\n     return position >= 0 && (position % fGrouping2) == 0\n-           && value.getUpperDisplayMagnitude() - fGrouping1 + 1 >= (fMin2 ? 2 : 1);\n+           && value.getUpperDisplayMagnitude() - fGrouping1 + 1 >= fMinGrouping;\n }\n \n #endif /* #if !UCONFIG_NO_FORMATTING */"
        },
        {
            "sha": "4a612273f5e530f25f7fd729325e32b8a06ec183",
            "filename": "deps/icu-small/source/i18n/number_integerwidth.cpp",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_integerwidth.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_integerwidth.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_integerwidth.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -13,25 +13,28 @@ using namespace icu;\n using namespace icu::number;\n using namespace icu::number::impl;\n \n-IntegerWidth::IntegerWidth(int8_t minInt, int8_t maxInt) {\n+IntegerWidth::IntegerWidth(digits_t minInt, digits_t maxInt) {\n     fUnion.minMaxInt.fMinInt = minInt;\n     fUnion.minMaxInt.fMaxInt = maxInt;\n }\n \n IntegerWidth IntegerWidth::zeroFillTo(int32_t minInt) {\n     if (minInt >= 0 && minInt <= kMaxIntFracSig) {\n-        return {static_cast<int8_t>(minInt), -1};\n+        return {static_cast<digits_t>(minInt), -1};\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n IntegerWidth IntegerWidth::truncateAt(int32_t maxInt) {\n     if (fHasError) { return *this; }  // No-op on error\n-    if (maxInt >= 0 && maxInt <= kMaxIntFracSig) {\n-        return {fUnion.minMaxInt.fMinInt, static_cast<int8_t>(maxInt)};\n+    digits_t minInt = fUnion.minMaxInt.fMinInt;\n+    if (maxInt >= 0 && maxInt <= kMaxIntFracSig && minInt <= maxInt) {\n+        return {minInt, static_cast<digits_t>(maxInt)};\n+    } else if (maxInt == -1) {\n+        return {minInt, -1};\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n "
        },
        {
            "sha": "5c363442e7c03331fd0ccb3ddb3fdb138d4de16f",
            "filename": "deps/icu-small/source/i18n/number_longnames.cpp",
            "status": "modified",
            "additions": 126,
            "deletions": 24,
            "changes": 150,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -5,6 +5,7 @@\n \n #if !UCONFIG_NO_FORMATTING && !UPRV_INCOMPLETE_CPP11_SUPPORT\n \n+#include \"unicode/simpleformatter.h\"\n #include \"unicode/ures.h\"\n #include \"ureslocs.h\"\n #include \"charstr.h\"\n@@ -19,6 +20,37 @@ using namespace icu::number::impl;\n \n namespace {\n \n+constexpr int32_t DNAM_INDEX = StandardPlural::Form::COUNT;\n+constexpr int32_t PER_INDEX = StandardPlural::Form::COUNT + 1;\n+constexpr int32_t ARRAY_LENGTH = StandardPlural::Form::COUNT + 2;\n+\n+static int32_t getIndex(const char* pluralKeyword, UErrorCode& status) {\n+    // pluralKeyword can also be \"dnam\" or \"per\"\n+    if (uprv_strcmp(pluralKeyword, \"dnam\") == 0) {\n+        return DNAM_INDEX;\n+    } else if (uprv_strcmp(pluralKeyword, \"per\") == 0) {\n+        return PER_INDEX;\n+    } else {\n+        StandardPlural::Form plural = StandardPlural::fromString(pluralKeyword, status);\n+        return plural;\n+    }\n+}\n+\n+static UnicodeString getWithPlural(\n+        const UnicodeString* strings,\n+        int32_t plural,\n+        UErrorCode& status) {\n+    UnicodeString result = strings[plural];\n+    if (result.isBogus()) {\n+        result = strings[StandardPlural::Form::OTHER];\n+    }\n+    if (result.isBogus()) {\n+        // There should always be data in the \"other\" plural variant.\n+        status = U_INTERNAL_PROGRAM_ERROR;\n+    }\n+    return result;\n+}\n+\n \n //////////////////////////\n /// BEGIN DATA LOADING ///\n@@ -28,25 +60,21 @@ class PluralTableSink : public ResourceSink {\n   public:\n     explicit PluralTableSink(UnicodeString *outArray) : outArray(outArray) {\n         // Initialize the array to bogus strings.\n-        for (int32_t i = 0; i < StandardPlural::Form::COUNT; i++) {\n+        for (int32_t i = 0; i < ARRAY_LENGTH; i++) {\n             outArray[i].setToBogus();\n         }\n     }\n \n     void put(const char *key, ResourceValue &value, UBool /*noFallback*/, UErrorCode &status) U_OVERRIDE {\n         ResourceTable pluralsTable = value.getTable(status);\n         if (U_FAILURE(status)) { return; }\n-        for (int i = 0; pluralsTable.getKeyAndValue(i, key, value); ++i) {\n-            // In MeasureUnit data, ignore dnam and per units for now.\n-            if (uprv_strcmp(key, \"dnam\") == 0 || uprv_strcmp(key, \"per\") == 0) {\n-                continue;\n-            }\n-            StandardPlural::Form plural = StandardPlural::fromString(key, status);\n+        for (int32_t i = 0; pluralsTable.getKeyAndValue(i, key, value); ++i) {\n+            int32_t index = getIndex(key, status);\n             if (U_FAILURE(status)) { return; }\n-            if (!outArray[plural].isBogus()) {\n+            if (!outArray[index].isBogus()) {\n                 continue;\n             }\n-            outArray[plural] = value.getUnicodeString(status);\n+            outArray[index] = value.getUnicodeString(status);\n             if (U_FAILURE(status)) { return; }\n         }\n     }\n@@ -105,31 +133,95 @@ void getCurrencyLongNameData(const Locale &locale, const CurrencyUnit &currency,\n     }\n }\n \n+UnicodeString getPerUnitFormat(const Locale& locale, const UNumberUnitWidth &width, UErrorCode& status) {\n+    LocalUResourceBundlePointer unitsBundle(ures_open(U_ICUDATA_UNIT, locale.getName(), &status));\n+    if (U_FAILURE(status)) { return {}; }\n+    CharString key;\n+    key.append(\"units\", status);\n+    if (width == UNUM_UNIT_WIDTH_NARROW) {\n+        key.append(\"Narrow\", status);\n+    } else if (width == UNUM_UNIT_WIDTH_SHORT) {\n+        key.append(\"Short\", status);\n+    }\n+    key.append(\"/compound/per\", status);\n+    int32_t len = 0;\n+    const UChar* ptr = ures_getStringByKeyWithFallback(unitsBundle.getAlias(), key.data(), &len, &status);\n+    return UnicodeString(ptr, len);\n+}\n+\n ////////////////////////\n /// END DATA LOADING ///\n ////////////////////////\n \n } // namespace\n \n LongNameHandler\n-LongNameHandler::forMeasureUnit(const Locale &loc, const MeasureUnit &unit, const UNumberUnitWidth &width,\n-                                const PluralRules *rules, const MicroPropsGenerator *parent,\n-                                UErrorCode &status) {\n+LongNameHandler::forMeasureUnit(const Locale &loc, const MeasureUnit &unitRef, const MeasureUnit &perUnit,\n+                                const UNumberUnitWidth &width, const PluralRules *rules,\n+                                const MicroPropsGenerator *parent, UErrorCode &status) {\n+    MeasureUnit unit = unitRef;\n+    if (uprv_strcmp(perUnit.getType(), \"none\") != 0) {\n+        // Compound unit: first try to simplify (e.g., meters per second is its own unit).\n+        bool isResolved = false;\n+        MeasureUnit resolved = MeasureUnit::resolveUnitPerUnit(unit, perUnit, &isResolved);\n+        if (isResolved) {\n+            unit = resolved;\n+        } else {\n+            // No simplified form is available.\n+            return forCompoundUnit(loc, unit, perUnit, width, rules, parent, status);\n+        }\n+    }\n+\n     LongNameHandler result(rules, parent);\n-    UnicodeString simpleFormats[StandardPlural::Form::COUNT];\n+    UnicodeString simpleFormats[ARRAY_LENGTH];\n     getMeasureData(loc, unit, width, simpleFormats, status);\n     if (U_FAILURE(status)) { return result; }\n     // TODO: What field to use for units?\n     simpleFormatsToModifiers(simpleFormats, UNUM_FIELD_COUNT, result.fModifiers, status);\n     return result;\n }\n \n+LongNameHandler\n+LongNameHandler::forCompoundUnit(const Locale &loc, const MeasureUnit &unit, const MeasureUnit &perUnit,\n+                                 const UNumberUnitWidth &width, const PluralRules *rules,\n+                                 const MicroPropsGenerator *parent, UErrorCode &status) {\n+    LongNameHandler result(rules, parent);\n+    UnicodeString primaryData[ARRAY_LENGTH];\n+    getMeasureData(loc, unit, width, primaryData, status);\n+    if (U_FAILURE(status)) { return result; }\n+    UnicodeString secondaryData[ARRAY_LENGTH];\n+    getMeasureData(loc, perUnit, width, secondaryData, status);\n+    if (U_FAILURE(status)) { return result; }\n+\n+    UnicodeString perUnitFormat;\n+    if (!secondaryData[PER_INDEX].isBogus()) {\n+        perUnitFormat = secondaryData[PER_INDEX];\n+    } else {\n+        UnicodeString rawPerUnitFormat = getPerUnitFormat(loc, width, status);\n+        if (U_FAILURE(status)) { return result; }\n+        // rawPerUnitFormat is something like \"{0}/{1}\"; we need to substitute in the secondary unit.\n+        SimpleFormatter compiled(rawPerUnitFormat, 2, 2, status);\n+        if (U_FAILURE(status)) { return result; }\n+        UnicodeString secondaryFormat = getWithPlural(secondaryData, StandardPlural::Form::ONE, status);\n+        if (U_FAILURE(status)) { return result; }\n+        SimpleFormatter secondaryCompiled(secondaryFormat, 1, 1, status);\n+        if (U_FAILURE(status)) { return result; }\n+        UnicodeString secondaryString = secondaryCompiled.getTextWithNoArguments().trim();\n+        // TODO: Why does UnicodeString need to be explicit in the following line?\n+        compiled.format(UnicodeString(u\"{0}\"), secondaryString, perUnitFormat, status);\n+        if (U_FAILURE(status)) { return result; }\n+    }\n+    // TODO: What field to use for units?\n+    multiSimpleFormatsToModifiers(primaryData, perUnitFormat, UNUM_FIELD_COUNT, result.fModifiers, status);\n+    return result;\n+}\n+\n LongNameHandler LongNameHandler::forCurrencyLongNames(const Locale &loc, const CurrencyUnit &currency,\n                                                       const PluralRules *rules,\n                                                       const MicroPropsGenerator *parent,\n                                                       UErrorCode &status) {\n     LongNameHandler result(rules, parent);\n-    UnicodeString simpleFormats[StandardPlural::Form::COUNT];\n+    UnicodeString simpleFormats[ARRAY_LENGTH];\n     getCurrencyLongNameData(loc, currency, simpleFormats, status);\n     if (U_FAILURE(status)) { return result; }\n     simpleFormatsToModifiers(simpleFormats, UNUM_CURRENCY_FIELD, result.fModifiers, status);\n@@ -139,20 +231,30 @@ LongNameHandler LongNameHandler::forCurrencyLongNames(const Locale &loc, const C\n void LongNameHandler::simpleFormatsToModifiers(const UnicodeString *simpleFormats, Field field,\n                                                SimpleModifier *output, UErrorCode &status) {\n     for (int32_t i = 0; i < StandardPlural::Form::COUNT; i++) {\n-        UnicodeString simpleFormat = simpleFormats[i];\n-        if (simpleFormat.isBogus()) {\n-            simpleFormat = simpleFormats[StandardPlural::Form::OTHER];\n-        }\n-        if (simpleFormat.isBogus()) {\n-            // There should always be data in the \"other\" plural variant.\n-            status = U_INTERNAL_PROGRAM_ERROR;\n-            return;\n-        }\n-        SimpleFormatter compiledFormatter(simpleFormat, 1, 1, status);\n+        UnicodeString simpleFormat = getWithPlural(simpleFormats, i, status);\n+        if (U_FAILURE(status)) { return; }\n+        SimpleFormatter compiledFormatter(simpleFormat, 0, 1, status);\n+        if (U_FAILURE(status)) { return; }\n         output[i] = SimpleModifier(compiledFormatter, field, false);\n     }\n }\n \n+void LongNameHandler::multiSimpleFormatsToModifiers(const UnicodeString *leadFormats, UnicodeString trailFormat,\n+                                                    Field field, SimpleModifier *output, UErrorCode &status) {\n+    SimpleFormatter trailCompiled(trailFormat, 1, 1, status);\n+    if (U_FAILURE(status)) { return; }\n+    for (int32_t i = 0; i < StandardPlural::Form::COUNT; i++) {\n+        UnicodeString leadFormat = getWithPlural(leadFormats, i, status);\n+        if (U_FAILURE(status)) { return; }\n+        UnicodeString compoundFormat;\n+        trailCompiled.format(leadFormat, compoundFormat, status);\n+        if (U_FAILURE(status)) { return; }\n+        SimpleFormatter compoundCompiled(compoundFormat, 0, 1, status);\n+        if (U_FAILURE(status)) { return; }\n+        output[i] = SimpleModifier(compoundCompiled, field, false);\n+    }\n+}\n+\n void LongNameHandler::processQuantity(DecimalQuantity &quantity, MicroProps &micros,\n                                       UErrorCode &status) const {\n     parent->processQuantity(quantity, micros, status);"
        },
        {
            "sha": "8738bb99e7d2e64d4f90c3b5420f70b16fce186a",
            "filename": "deps/icu-small/source/i18n/number_longnames.h",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -21,8 +21,9 @@ class LongNameHandler : public MicroPropsGenerator, public UMemory {\n                          const MicroPropsGenerator *parent, UErrorCode &status);\n \n     static LongNameHandler\n-    forMeasureUnit(const Locale &loc, const MeasureUnit &unit, const UNumberUnitWidth &width,\n-                   const PluralRules *rules, const MicroPropsGenerator *parent, UErrorCode &status);\n+    forMeasureUnit(const Locale &loc, const MeasureUnit &unit, const MeasureUnit &perUnit,\n+                   const UNumberUnitWidth &width, const PluralRules *rules,\n+                   const MicroPropsGenerator *parent, UErrorCode &status);\n \n     void\n     processQuantity(DecimalQuantity &quantity, MicroProps &micros, UErrorCode &status) const U_OVERRIDE;\n@@ -35,8 +36,15 @@ class LongNameHandler : public MicroPropsGenerator, public UMemory {\n     LongNameHandler(const PluralRules *rules, const MicroPropsGenerator *parent)\n             : rules(rules), parent(parent) {}\n \n+    static LongNameHandler\n+    forCompoundUnit(const Locale &loc, const MeasureUnit &unit, const MeasureUnit &perUnit,\n+                    const UNumberUnitWidth &width, const PluralRules *rules,\n+                    const MicroPropsGenerator *parent, UErrorCode &status);\n+\n     static void simpleFormatsToModifiers(const UnicodeString *simpleFormats, Field field,\n                                          SimpleModifier *output, UErrorCode &status);\n+    static void multiSimpleFormatsToModifiers(const UnicodeString *leadFormats, UnicodeString trailFormat,\n+                                         Field field, SimpleModifier *output, UErrorCode &status);\n };\n \n }  // namespace impl"
        },
        {
            "sha": "872b97010d74b7f4fa0847b10ebbedfce0f3fb87",
            "filename": "deps/icu-small/source/i18n/number_modifiers.cpp",
            "status": "modified",
            "additions": 49,
            "deletions": 27,
            "changes": 76,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -74,19 +74,29 @@ bool ConstantAffixModifier::isStrong() const {\n \n SimpleModifier::SimpleModifier(const SimpleFormatter &simpleFormatter, Field field, bool strong)\n         : fCompiledPattern(simpleFormatter.compiledPattern), fField(field), fStrong(strong) {\n-    U_ASSERT(1 ==\n-             SimpleFormatter::getArgumentLimit(fCompiledPattern.getBuffer(), fCompiledPattern.length()));\n-    if (fCompiledPattern.charAt(1) != 0) {\n+    int32_t argLimit = SimpleFormatter::getArgumentLimit(\n+            fCompiledPattern.getBuffer(), fCompiledPattern.length());\n+    if (argLimit == 0) {\n+        // No arguments in compiled pattern\n         fPrefixLength = fCompiledPattern.charAt(1) - ARG_NUM_LIMIT;\n-        fSuffixOffset = 3 + fPrefixLength;\n-    } else {\n-        fPrefixLength = 0;\n-        fSuffixOffset = 2;\n-    }\n-    if (3 + fPrefixLength < fCompiledPattern.length()) {\n-        fSuffixLength = fCompiledPattern.charAt(fSuffixOffset) - ARG_NUM_LIMIT;\n-    } else {\n+        U_ASSERT(2 + fPrefixLength == fCompiledPattern.length());\n+        // Set suffixOffset = -1 to indicate no arguments in compiled pattern.\n+        fSuffixOffset = -1;\n         fSuffixLength = 0;\n+    } else {\n+        U_ASSERT(argLimit == 1);\n+        if (fCompiledPattern.charAt(1) != 0) {\n+            fPrefixLength = fCompiledPattern.charAt(1) - ARG_NUM_LIMIT;\n+            fSuffixOffset = 3 + fPrefixLength;\n+        } else {\n+            fPrefixLength = 0;\n+            fSuffixOffset = 2;\n+        }\n+        if (3 + fPrefixLength < fCompiledPattern.length()) {\n+            fSuffixLength = fCompiledPattern.charAt(fSuffixOffset) - ARG_NUM_LIMIT;\n+        } else {\n+            fSuffixLength = 0;\n+        }\n     }\n }\n \n@@ -123,26 +133,37 @@ bool SimpleModifier::isStrong() const {\n int32_t\n SimpleModifier::formatAsPrefixSuffix(NumberStringBuilder &result, int32_t startIndex, int32_t endIndex,\n                                      Field field, UErrorCode &status) const {\n-    if (fPrefixLength > 0) {\n-        result.insert(startIndex, fCompiledPattern, 2, 2 + fPrefixLength, field, status);\n-    }\n-    if (fSuffixLength > 0) {\n-        result.insert(\n-                endIndex + fPrefixLength,\n-                fCompiledPattern,\n-                1 + fSuffixOffset,\n-                1 + fSuffixOffset + fSuffixLength,\n-                field,\n-                status);\n+    if (fSuffixOffset == -1) {\n+        // There is no argument for the inner number; overwrite the entire segment with our string.\n+        return result.splice(startIndex, endIndex, fCompiledPattern, 2, 2 + fPrefixLength, field, status);\n+    } else {\n+        if (fPrefixLength > 0) {\n+            result.insert(startIndex, fCompiledPattern, 2, 2 + fPrefixLength, field, status);\n+        }\n+        if (fSuffixLength > 0) {\n+            result.insert(\n+                    endIndex + fPrefixLength,\n+                    fCompiledPattern,\n+                    1 + fSuffixOffset,\n+                    1 + fSuffixOffset + fSuffixLength,\n+                    field,\n+                    status);\n+        }\n+        return fPrefixLength + fSuffixLength;\n     }\n-    return fPrefixLength + fSuffixLength;\n }\n \n int32_t ConstantMultiFieldModifier::apply(NumberStringBuilder &output, int leftIndex, int rightIndex,\n                                           UErrorCode &status) const {\n-    // Insert the suffix first since inserting the prefix will change the rightIndex\n-    int32_t length = output.insert(rightIndex, fSuffix, status);\n-    length += output.insert(leftIndex, fPrefix, status);\n+    int32_t length = output.insert(leftIndex, fPrefix, status);\n+    if (fOverwrite) {\n+        length += output.splice(\n+            leftIndex + length,\n+            rightIndex + length,\n+            UnicodeString(), 0, 0,\n+            UNUM_FIELD_COUNT, status);\n+    }\n+    length += output.insert(rightIndex + length, fSuffix, status);\n     return length;\n }\n \n@@ -162,10 +183,11 @@ bool ConstantMultiFieldModifier::isStrong() const {\n \n CurrencySpacingEnabledModifier::CurrencySpacingEnabledModifier(const NumberStringBuilder &prefix,\n                                                                const NumberStringBuilder &suffix,\n+                                                               bool overwrite,\n                                                                bool strong,\n                                                                const DecimalFormatSymbols &symbols,\n                                                                UErrorCode &status)\n-        : ConstantMultiFieldModifier(prefix, suffix, strong) {\n+        : ConstantMultiFieldModifier(prefix, suffix, overwrite, strong) {\n     // Check for currency spacing. Do not build the UnicodeSets unless there is\n     // a currency code point at a boundary.\n     if (prefix.length() > 0 && prefix.fieldAt(prefix.length() - 1) == UNUM_CURRENCY_FIELD) {"
        },
        {
            "sha": "4762a6f6d37a2deb53f17de2f9d541f308c76cf3",
            "filename": "deps/icu-small/source/i18n/number_modifiers.h",
            "status": "modified",
            "additions": 31,
            "deletions": 16,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -103,8 +103,15 @@ class U_I18N_API SimpleModifier : public Modifier, public UMemory {\n  */\n class U_I18N_API ConstantMultiFieldModifier : public Modifier, public UMemory {\n   public:\n-    ConstantMultiFieldModifier(const NumberStringBuilder &prefix, const NumberStringBuilder &suffix,\n-                               bool strong) : fPrefix(prefix), fSuffix(suffix), fStrong(strong) {}\n+    ConstantMultiFieldModifier(\n+            const NumberStringBuilder &prefix,\n+            const NumberStringBuilder &suffix,\n+            bool overwrite,\n+            bool strong)\n+      : fPrefix(prefix),\n+        fSuffix(suffix),\n+        fOverwrite(overwrite),\n+        fStrong(strong) {}\n \n     int32_t apply(NumberStringBuilder &output, int32_t leftIndex, int32_t rightIndex,\n                   UErrorCode &status) const U_OVERRIDE;\n@@ -120,15 +127,21 @@ class U_I18N_API ConstantMultiFieldModifier : public Modifier, public UMemory {\n     // value and is treated internally as immutable.\n     NumberStringBuilder fPrefix;\n     NumberStringBuilder fSuffix;\n+    bool fOverwrite;\n     bool fStrong;\n };\n \n /** Identical to {@link ConstantMultiFieldModifier}, but supports currency spacing. */\n class U_I18N_API CurrencySpacingEnabledModifier : public ConstantMultiFieldModifier {\n   public:\n     /** Safe code path */\n-    CurrencySpacingEnabledModifier(const NumberStringBuilder &prefix, const NumberStringBuilder &suffix,\n-                                   bool strong, const DecimalFormatSymbols &symbols, UErrorCode &status);\n+    CurrencySpacingEnabledModifier(\n+            const NumberStringBuilder &prefix,\n+            const NumberStringBuilder &suffix,\n+            bool overwrite,\n+            bool strong,\n+            const DecimalFormatSymbols &symbols,\n+            UErrorCode &status);\n \n     int32_t apply(NumberStringBuilder &output, int32_t leftIndex, int32_t rightIndex,\n                   UErrorCode &status) const U_OVERRIDE;\n@@ -216,31 +229,33 @@ class U_I18N_API ParameterizedModifier : public UMemory {\n         }\n     }\n \n-    void adoptPositiveNegativeModifiers(const Modifier *positive, const Modifier *negative) {\n-        mods[0] = positive;\n-        mods[1] = negative;\n+    void adoptPositiveNegativeModifiers(\n+            const Modifier *positive, const Modifier *zero, const Modifier *negative) {\n+        mods[2] = positive;\n+        mods[1] = zero;\n+        mods[0] = negative;\n     }\n \n     /** The modifier is ADOPTED. */\n-    void adoptSignPluralModifier(bool isNegative, StandardPlural::Form plural, const Modifier *mod) {\n-        mods[getModIndex(isNegative, plural)] = mod;\n+    void adoptSignPluralModifier(int8_t signum, StandardPlural::Form plural, const Modifier *mod) {\n+        mods[getModIndex(signum, plural)] = mod;\n     }\n \n     /** Returns a reference to the modifier; no ownership change. */\n-    const Modifier *getModifier(bool isNegative) const {\n-        return mods[isNegative ? 1 : 0];\n+    const Modifier *getModifier(int8_t signum) const {\n+        return mods[signum + 1];\n     }\n \n     /** Returns a reference to the modifier; no ownership change. */\n-    const Modifier *getModifier(bool isNegative, StandardPlural::Form plural) const {\n-        return mods[getModIndex(isNegative, plural)];\n+    const Modifier *getModifier(int8_t signum, StandardPlural::Form plural) const {\n+        return mods[getModIndex(signum, plural)];\n     }\n \n   private:\n-    const Modifier *mods[2 * StandardPlural::COUNT];\n+    const Modifier *mods[3 * StandardPlural::COUNT];\n \n-    inline static int32_t getModIndex(bool isNegative, StandardPlural::Form plural) {\n-        return static_cast<int32_t>(plural) * 2 + (isNegative ? 1 : 0);\n+    inline static int32_t getModIndex(int8_t signum, StandardPlural::Form plural) {\n+        return static_cast<int32_t>(plural) * 3 + (signum + 1);\n     }\n };\n "
        },
        {
            "sha": "f4ad333354d0c7ee48b10fa91c4357c871a6e390",
            "filename": "deps/icu-small/source/i18n/number_notation.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_notation.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_notation.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_notation.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -54,13 +54,13 @@ Notation Notation::simple() {\n \n ScientificNotation\n ScientificNotation::withMinExponentDigits(int32_t minExponentDigits) const {\n-    if (minExponentDigits >= 0 && minExponentDigits < kMaxIntFracSig) {\n+    if (minExponentDigits >= 1 && minExponentDigits <= kMaxIntFracSig) {\n         ScientificSettings settings = fUnion.scientific;\n-        settings.fMinExponentDigits = (int8_t) minExponentDigits;\n+        settings.fMinExponentDigits = static_cast<digits_t>(minExponentDigits);\n         NotationUnion union_ = {settings};\n         return {NTN_SCIENTIFIC, union_};\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n "
        },
        {
            "sha": "b1db3490cd4489f3f9371d08ef784006c879d698",
            "filename": "deps/icu-small/source/i18n/number_padding.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_padding.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_padding.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_padding.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -43,7 +43,7 @@ Padder Padder::codePoints(UChar32 cp, int32_t targetWidth, UNumberFormatPadPosit\n     if (targetWidth >= 0) {\n         return {cp, targetWidth, position};\n     } else {\n-        return {U_NUMBER_PADDING_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n "
        },
        {
            "sha": "e182104c9116e7606cccd022cb3816ec0a7847f4",
            "filename": "deps/icu-small/source/i18n/number_patternmodifier.cpp",
            "status": "modified",
            "additions": 48,
            "deletions": 24,
            "changes": 72,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -38,8 +38,8 @@ MutablePatternModifier::setSymbols(const DecimalFormatSymbols *symbols, const Cu\n     this->rules = rules;\n }\n \n-void MutablePatternModifier::setNumberProperties(bool isNegative, StandardPlural::Form plural) {\n-    this->isNegative = isNegative;\n+void MutablePatternModifier::setNumberProperties(int8_t signum, StandardPlural::Form plural) {\n+    this->signum = signum;\n     this->plural = plural;\n }\n \n@@ -74,10 +74,12 @@ MutablePatternModifier::createImmutableAndChain(const MicroPropsGenerator *paren\n     if (needsPlurals()) {\n         // Slower path when we require the plural keyword.\n         for (StandardPlural::Form plural : STANDARD_PLURAL_VALUES) {\n-            setNumberProperties(false, plural);\n-            pm->adoptSignPluralModifier(false, plural, createConstantModifier(status));\n-            setNumberProperties(true, plural);\n-            pm->adoptSignPluralModifier(true, plural, createConstantModifier(status));\n+            setNumberProperties(1, plural);\n+            pm->adoptSignPluralModifier(1, plural, createConstantModifier(status));\n+            setNumberProperties(0, plural);\n+            pm->adoptSignPluralModifier(0, plural, createConstantModifier(status));\n+            setNumberProperties(-1, plural);\n+            pm->adoptSignPluralModifier(-1, plural, createConstantModifier(status));\n         }\n         if (U_FAILURE(status)) {\n             delete pm;\n@@ -86,11 +88,13 @@ MutablePatternModifier::createImmutableAndChain(const MicroPropsGenerator *paren\n         return new ImmutablePatternModifier(pm, rules, parent);  // adopts pm\n     } else {\n         // Faster path when plural keyword is not needed.\n-        setNumberProperties(false, StandardPlural::Form::COUNT);\n+        setNumberProperties(1, StandardPlural::Form::COUNT);\n         Modifier *positive = createConstantModifier(status);\n-        setNumberProperties(true, StandardPlural::Form::COUNT);\n+        setNumberProperties(0, StandardPlural::Form::COUNT);\n+        Modifier *zero = createConstantModifier(status);\n+        setNumberProperties(-1, StandardPlural::Form::COUNT);\n         Modifier *negative = createConstantModifier(status);\n-        pm->adoptPositiveNegativeModifiers(positive, negative);\n+        pm->adoptPositiveNegativeModifiers(positive, zero, negative);\n         if (U_FAILURE(status)) {\n             delete pm;\n             return nullptr;\n@@ -105,9 +109,9 @@ ConstantMultiFieldModifier *MutablePatternModifier::createConstantModifier(UErro\n     insertPrefix(a, 0, status);\n     insertSuffix(b, 0, status);\n     if (patternInfo->hasCurrencySign()) {\n-        return new CurrencySpacingEnabledModifier(a, b, fStrong, *symbols, status);\n+        return new CurrencySpacingEnabledModifier(a, b, !patternInfo->hasBody(), fStrong, *symbols, status);\n     } else {\n-        return new ConstantMultiFieldModifier(a, b, fStrong);\n+        return new ConstantMultiFieldModifier(a, b, !patternInfo->hasBody(), fStrong);\n     }\n }\n \n@@ -123,13 +127,13 @@ void ImmutablePatternModifier::processQuantity(DecimalQuantity &quantity, MicroP\n \n void ImmutablePatternModifier::applyToMicros(MicroProps &micros, DecimalQuantity &quantity) const {\n     if (rules == nullptr) {\n-        micros.modMiddle = pm->getModifier(quantity.isNegative());\n+        micros.modMiddle = pm->getModifier(quantity.signum());\n     } else {\n         // TODO: Fix this. Avoid the copy.\n         DecimalQuantity copy(quantity);\n         copy.roundToInfinity();\n         StandardPlural::Form plural = copy.getStandardPlural(rules);\n-        micros.modMiddle = pm->getModifier(quantity.isNegative(), plural);\n+        micros.modMiddle = pm->getModifier(quantity.signum(), plural);\n     }\n }\n \n@@ -149,9 +153,9 @@ void MutablePatternModifier::processQuantity(DecimalQuantity &fq, MicroProps &mi\n         // TODO: Fix this. Avoid the copy.\n         DecimalQuantity copy(fq);\n         micros.rounding.apply(copy, status);\n-        nonConstThis->setNumberProperties(fq.isNegative(), copy.getStandardPlural(rules));\n+        nonConstThis->setNumberProperties(fq.signum(), copy.getStandardPlural(rules));\n     } else {\n-        nonConstThis->setNumberProperties(fq.isNegative(), StandardPlural::Form::COUNT);\n+        nonConstThis->setNumberProperties(fq.signum(), StandardPlural::Form::COUNT);\n     }\n     micros.modMiddle = this;\n }\n@@ -163,9 +167,23 @@ int32_t MutablePatternModifier::apply(NumberStringBuilder &output, int32_t leftI\n     auto nonConstThis = const_cast<MutablePatternModifier *>(this);\n     int32_t prefixLen = nonConstThis->insertPrefix(output, leftIndex, status);\n     int32_t suffixLen = nonConstThis->insertSuffix(output, rightIndex + prefixLen, status);\n+    // If the pattern had no decimal stem body (like #,##0.00), overwrite the value.\n+    int32_t overwriteLen = 0;\n+    if (!patternInfo->hasBody()) {\n+        overwriteLen = output.splice(\n+            leftIndex + prefixLen, rightIndex + prefixLen,\n+            UnicodeString(), 0, 0, UNUM_FIELD_COUNT,\n+            status);\n+    }\n     CurrencySpacingEnabledModifier::applyCurrencySpacing(\n-            output, leftIndex, prefixLen, rightIndex + prefixLen, suffixLen, *symbols, status);\n-    return prefixLen + suffixLen;\n+            output,\n+            leftIndex,\n+            prefixLen,\n+            rightIndex + overwriteLen + prefixLen,\n+            suffixLen,\n+            *symbols,\n+            status);\n+    return prefixLen + overwriteLen + suffixLen;\n }\n \n int32_t MutablePatternModifier::getPrefixLength(UErrorCode &status) const {\n@@ -230,13 +248,16 @@ UnicodeString MutablePatternModifier::getSymbol(AffixPatternType type) const {\n             } else if (unitWidth == UNumberUnitWidth::UNUM_UNIT_WIDTH_HIDDEN) {\n                 return UnicodeString();\n             } else {\n+                UCurrNameStyle selector = (unitWidth == UNumberUnitWidth::UNUM_UNIT_WIDTH_NARROW)\n+                        ? UCurrNameStyle::UCURR_NARROW_SYMBOL_NAME\n+                        : UCurrNameStyle::UCURR_SYMBOL_NAME;\n                 UErrorCode status = U_ZERO_ERROR;\n                 UBool isChoiceFormat = FALSE;\n                 int32_t symbolLen = 0;\n                 const char16_t *symbol = ucurr_getName(\n                         currencyCode,\n                         symbols->getLocale().getName(),\n-                        UCurrNameStyle::UCURR_SYMBOL_NAME,\n+                        selector,\n                         &isChoiceFormat,\n                         &symbolLen,\n                         &status);\n@@ -278,14 +299,17 @@ void MutablePatternModifier::enterCharSequenceMode(bool isPrefix) {\n     inCharSequenceMode = true;\n \n     // Should the output render '+' where '-' would normally appear in the pattern?\n-    plusReplacesMinusSign = !isNegative && (\n-            signDisplay == UNUM_SIGN_ALWAYS ||\n-            signDisplay == UNUM_SIGN_ACCOUNTING_ALWAYS) &&\n-                            patternInfo->positiveHasPlusSign() == false;\n+    plusReplacesMinusSign = signum != -1\n+            && (signDisplay == UNUM_SIGN_ALWAYS\n+                    || signDisplay == UNUM_SIGN_ACCOUNTING_ALWAYS\n+                    || (signum == 1\n+                            && (signDisplay == UNUM_SIGN_EXCEPT_ZERO\n+                                    || signDisplay == UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO)))\n+            && patternInfo->positiveHasPlusSign() == false;\n \n     // Should we use the affix from the negative subpattern? (If not, we will use the positive subpattern.)\n     bool useNegativeAffixPattern = patternInfo->hasNegativeSubpattern() && (\n-            isNegative || (patternInfo->negativeHasMinusSign() && plusReplacesMinusSign));\n+            signum == -1 || (patternInfo->negativeHasMinusSign() && plusReplacesMinusSign));\n \n     // Resolve the flags for the affix pattern.\n     fFlags = 0;\n@@ -303,7 +327,7 @@ void MutablePatternModifier::enterCharSequenceMode(bool isPrefix) {\n     // Should we prepend a sign to the pattern?\n     if (!isPrefix || useNegativeAffixPattern) {\n         prependSign = false;\n-    } else if (isNegative) {\n+    } else if (signum == -1) {\n         prependSign = signDisplay != UNUM_SIGN_NEVER;\n     } else {\n         prependSign = plusReplacesMinusSign;"
        },
        {
            "sha": "9c8b95f7764436c6fe28fd1a38c4baaae04eb265",
            "filename": "deps/icu-small/source/i18n/number_patternmodifier.h",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -18,8 +18,8 @@ U_NAMESPACE_BEGIN\n \n // Export an explicit template instantiation of the LocalPointer that is used as a\n // data member of ParameterizedModifier.\n-// (MSVC requires this, even though it should not be necessary.)\n-#if defined (_MSC_VER)\n+// (When building DLLs for Windows this is required.)\n+#if U_PF_WINDOWS <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN\n // Ignore warning 4661 as LocalPointerBase does not use operator== or operator!=\n #pragma warning(suppress: 4661)\n template class U_I18N_API LocalPointerBase<number::impl::ParameterizedModifier>;\n@@ -125,13 +125,13 @@ class U_I18N_API MutablePatternModifier\n     /**\n      * Sets attributes of the current number being processed.\n      *\n-     * @param isNegative\n-     *            Whether the number is negative.\n+     * @param signum\n+     *            -1 if negative; +1 if positive; or 0 if zero.\n      * @param plural\n-     *            The plural form of the number, required only if the pattern contains the triple currency sign, \"¤¤¤\"\n-     *            (and as indicated by {@link #needsPlurals()}).\n+     *            The plural form of the number, required only if the pattern contains the triple\n+     *            currency sign, \"¤¤¤\" (and as indicated by {@link #needsPlurals()}).\n      */\n-    void setNumberProperties(bool isNegative, StandardPlural::Form plural);\n+    void setNumberProperties(int8_t signum, StandardPlural::Form plural);\n \n     /**\n      * Returns true if the pattern represented by this MurkyModifier requires a plural keyword in order to localize.\n@@ -211,7 +211,7 @@ class U_I18N_API MutablePatternModifier\n     const PluralRules *rules;\n \n     // Number details (initialized in setNumberProperties)\n-    bool isNegative;\n+    int8_t signum;\n     StandardPlural::Form plural;\n \n     // QuantityChain details (initialized in addToChain)"
        },
        {
            "sha": "20178824b0e20a1d3217c83059089c7a2e93b556",
            "filename": "deps/icu-small/source/i18n/number_patternstring.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternstring.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternstring.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternstring.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -95,6 +95,10 @@ bool ParsedPatternInfo::containsSymbolType(AffixPatternType type, UErrorCode &st\n     return AffixUtils::containsType(UnicodeStringCharSequence(pattern), type, status);\n }\n \n+bool ParsedPatternInfo::hasBody() const {\n+    return positive.integerTotal > 0;\n+}\n+\n /////////////////////////////////////////////////////\n /// BEGIN RECURSIVE DESCENT PARSER IMPLEMENTATION ///\n /////////////////////////////////////////////////////"
        },
        {
            "sha": "ec44290d66397c78d2697afff5df1360a5a9ccd8",
            "filename": "deps/icu-small/source/i18n/number_patternstring.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternstring.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternstring.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternstring.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -84,6 +84,8 @@ struct U_I18N_API ParsedPatternInfo : public AffixPatternProvider, public UMemor\n \n     bool containsSymbolType(AffixPatternType type, UErrorCode &status) const U_OVERRIDE;\n \n+    bool hasBody() const U_OVERRIDE;\n+\n   private:\n     struct U_I18N_API ParserState {\n         const UnicodeString &pattern; // reference to the parent"
        },
        {
            "sha": "fd4dafdf983b61a289be460d8af4eef6fac78be5",
            "filename": "deps/icu-small/source/i18n/number_rounding.cpp",
            "status": "modified",
            "additions": 54,
            "deletions": 42,
            "changes": 96,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_rounding.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_rounding.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_rounding.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -58,23 +58,23 @@ FractionRounder Rounder::fixedFraction(int32_t minMaxFractionPlaces) {\n     if (minMaxFractionPlaces >= 0 && minMaxFractionPlaces <= kMaxIntFracSig) {\n         return constructFraction(minMaxFractionPlaces, minMaxFractionPlaces);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n FractionRounder Rounder::minFraction(int32_t minFractionPlaces) {\n     if (minFractionPlaces >= 0 && minFractionPlaces <= kMaxIntFracSig) {\n         return constructFraction(minFractionPlaces, -1);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n FractionRounder Rounder::maxFraction(int32_t maxFractionPlaces) {\n     if (maxFractionPlaces >= 0 && maxFractionPlaces <= kMaxIntFracSig) {\n         return constructFraction(0, maxFractionPlaces);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n@@ -83,48 +83,48 @@ FractionRounder Rounder::minMaxFraction(int32_t minFractionPlaces, int32_t maxFr\n         minFractionPlaces <= maxFractionPlaces) {\n         return constructFraction(minFractionPlaces, maxFractionPlaces);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n Rounder Rounder::fixedDigits(int32_t minMaxSignificantDigits) {\n-    if (minMaxSignificantDigits >= 0 && minMaxSignificantDigits <= kMaxIntFracSig) {\n+    if (minMaxSignificantDigits >= 1 && minMaxSignificantDigits <= kMaxIntFracSig) {\n         return constructSignificant(minMaxSignificantDigits, minMaxSignificantDigits);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n Rounder Rounder::minDigits(int32_t minSignificantDigits) {\n-    if (minSignificantDigits >= 0 && minSignificantDigits <= kMaxIntFracSig) {\n+    if (minSignificantDigits >= 1 && minSignificantDigits <= kMaxIntFracSig) {\n         return constructSignificant(minSignificantDigits, -1);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n Rounder Rounder::maxDigits(int32_t maxSignificantDigits) {\n-    if (maxSignificantDigits >= 0 && maxSignificantDigits <= kMaxIntFracSig) {\n-        return constructSignificant(0, maxSignificantDigits);\n+    if (maxSignificantDigits >= 1 && maxSignificantDigits <= kMaxIntFracSig) {\n+        return constructSignificant(1, maxSignificantDigits);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n Rounder Rounder::minMaxDigits(int32_t minSignificantDigits, int32_t maxSignificantDigits) {\n-    if (minSignificantDigits >= 0 && maxSignificantDigits <= kMaxIntFracSig &&\n+    if (minSignificantDigits >= 1 && maxSignificantDigits <= kMaxIntFracSig &&\n         minSignificantDigits <= maxSignificantDigits) {\n         return constructSignificant(minSignificantDigits, maxSignificantDigits);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n IncrementRounder Rounder::increment(double roundingIncrement) {\n     if (roundingIncrement > 0.0) {\n         return constructIncrement(roundingIncrement, 0);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n@@ -139,19 +139,19 @@ Rounder Rounder::withMode(RoundingMode roundingMode) const {\n \n Rounder FractionRounder::withMinDigits(int32_t minSignificantDigits) const {\n     if (fType == RND_ERROR) { return *this; } // no-op in error state\n-    if (minSignificantDigits >= 0 && minSignificantDigits <= kMaxIntFracSig) {\n+    if (minSignificantDigits >= 1 && minSignificantDigits <= kMaxIntFracSig) {\n         return constructFractionSignificant(*this, minSignificantDigits, -1);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n Rounder FractionRounder::withMaxDigits(int32_t maxSignificantDigits) const {\n     if (fType == RND_ERROR) { return *this; } // no-op in error state\n-    if (maxSignificantDigits >= 0 && maxSignificantDigits <= kMaxIntFracSig) {\n+    if (maxSignificantDigits >= 1 && maxSignificantDigits <= kMaxIntFracSig) {\n         return constructFractionSignificant(*this, -1, maxSignificantDigits);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n@@ -185,14 +185,14 @@ Rounder IncrementRounder::withMinFraction(int32_t minFrac) const {\n     if (minFrac >= 0 && minFrac <= kMaxIntFracSig) {\n         return constructIncrement(fUnion.increment.fIncrement, minFrac);\n     } else {\n-        return {U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR};\n+        return {U_NUMBER_ARG_OUTOFBOUNDS_ERROR};\n     }\n }\n \n FractionRounder Rounder::constructFraction(int32_t minFrac, int32_t maxFrac) {\n     FractionSignificantSettings settings;\n-    settings.fMinFrac = static_cast<int8_t> (minFrac);\n-    settings.fMaxFrac = static_cast<int8_t> (maxFrac);\n+    settings.fMinFrac = static_cast<digits_t>(minFrac);\n+    settings.fMaxFrac = static_cast<digits_t>(maxFrac);\n     settings.fMinSig = -1;\n     settings.fMaxSig = -1;\n     RounderUnion union_;\n@@ -204,8 +204,8 @@ Rounder Rounder::constructSignificant(int32_t minSig, int32_t maxSig) {\n     FractionSignificantSettings settings;\n     settings.fMinFrac = -1;\n     settings.fMaxFrac = -1;\n-    settings.fMinSig = static_cast<int8_t>(minSig);\n-    settings.fMaxSig = static_cast<int8_t>(maxSig);\n+    settings.fMinSig = static_cast<digits_t>(minSig);\n+    settings.fMaxSig = static_cast<digits_t>(maxSig);\n     RounderUnion union_;\n     union_.fracSig = settings;\n     return {RND_SIGNIFICANT, union_, kDefaultMode};\n@@ -214,8 +214,8 @@ Rounder Rounder::constructSignificant(int32_t minSig, int32_t maxSig) {\n Rounder\n Rounder::constructFractionSignificant(const FractionRounder &base, int32_t minSig, int32_t maxSig) {\n     FractionSignificantSettings settings = base.fUnion.fracSig;\n-    settings.fMinSig = static_cast<int8_t>(minSig);\n-    settings.fMaxSig = static_cast<int8_t>(maxSig);\n+    settings.fMinSig = static_cast<digits_t>(minSig);\n+    settings.fMaxSig = static_cast<digits_t>(maxSig);\n     RounderUnion union_;\n     union_.fracSig = settings;\n     return {RND_FRACTION_SIGNIFICANT, union_, kDefaultMode};\n@@ -224,7 +224,7 @@ Rounder::constructFractionSignificant(const FractionRounder &base, int32_t minSi\n IncrementRounder Rounder::constructIncrement(double increment, int32_t minFrac) {\n     IncrementSettings settings;\n     settings.fIncrement = increment;\n-    settings.fMinFrac = minFrac;\n+    settings.fMinFrac = static_cast<digits_t>(minFrac);\n     RounderUnion union_;\n     union_.increment = settings;\n     return {RND_INCREMENT, union_, kDefaultMode};\n@@ -251,28 +251,39 @@ void Rounder::setLocaleData(const CurrencyUnit &currency, UErrorCode &status) {\n int32_t\n Rounder::chooseMultiplierAndApply(impl::DecimalQuantity &input, const impl::MultiplierProducer &producer,\n                                   UErrorCode &status) {\n-    // TODO: Make a better and more efficient implementation.\n-    // TODO: Avoid the object creation here.\n-    DecimalQuantity copy(input);\n-\n+    // Do not call this method with zero.\n     U_ASSERT(!input.isZero());\n-    int32_t magnitude = input.getMagnitude();\n-    int32_t multiplier = producer.getMultiplier(magnitude);\n+\n+    // Perform the first attempt at rounding.\n+    int magnitude = input.getMagnitude();\n+    int multiplier = producer.getMultiplier(magnitude);\n     input.adjustMagnitude(multiplier);\n     apply(input, status);\n \n-    // If the number turned to zero when rounding, do not re-attempt the rounding.\n-    if (!input.isZero() && input.getMagnitude() == magnitude + multiplier + 1) {\n-        magnitude += 1;\n-        input = copy;\n-        multiplier = producer.getMultiplier(magnitude);\n-        input.adjustMagnitude(multiplier);\n-        U_ASSERT(input.getMagnitude() == magnitude + multiplier - 1);\n-        apply(input, status);\n-        U_ASSERT(input.getMagnitude() == magnitude + multiplier);\n+    // If the number rounded to zero, exit.\n+    if (input.isZero() || U_FAILURE(status)) {\n+        return multiplier;\n+    }\n+\n+    // If the new magnitude after rounding is the same as it was before rounding, then we are done.\n+    // This case applies to most numbers.\n+    if (input.getMagnitude() == magnitude + multiplier) {\n+        return multiplier;\n     }\n \n-    return multiplier;\n+    // If the above case DIDN'T apply, then we have a case like 99.9 -> 100 or 999.9 -> 1000:\n+    // The number rounded up to the next magnitude. Check if the multiplier changes; if it doesn't,\n+    // we do not need to make any more adjustments.\n+    int _multiplier = producer.getMultiplier(magnitude + 1);\n+    if (multiplier == _multiplier) {\n+        return multiplier;\n+    }\n+\n+    // We have a case like 999.9 -> 1000, where the correct output is \"1K\", not \"1000\".\n+    // Fix the magnitude and re-apply the rounding strategy.\n+    input.adjustMagnitude(_multiplier - multiplier);\n+    apply(input, status);\n+    return _multiplier;\n }\n \n /** This is the method that contains the actual rounding logic. */\n@@ -331,6 +342,7 @@ void Rounder::apply(impl::DecimalQuantity &value, UErrorCode& status) const {\n         case RND_CURRENCY:\n             // Call .withCurrency() before .apply()!\n             U_ASSERT(false);\n+            break;\n \n         case RND_PASS_THROUGH:\n             break;"
        },
        {
            "sha": "37159d7e53a60a0d10f98e94995f6389b205deda",
            "filename": "deps/icu-small/source/i18n/number_stringbuilder.cpp",
            "status": "modified",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -191,6 +191,30 @@ NumberStringBuilder::insert(int32_t index, const UnicodeString &unistr, int32_t\n     return count;\n }\n \n+int32_t\n+NumberStringBuilder::splice(int32_t startThis, int32_t endThis,  const UnicodeString &unistr,\n+                            int32_t startOther, int32_t endOther, Field field, UErrorCode& status) {\n+    int32_t thisLength = endThis - startThis;\n+    int32_t otherLength = endOther - startOther;\n+    int32_t count = otherLength - thisLength;\n+    int32_t position;\n+    if (count > 0) {\n+        // Overall, chars need to be added.\n+        position = prepareForInsert(startThis, count, status);\n+    } else {\n+        // Overall, chars need to be removed or kept the same.\n+        position = remove(startThis, -count);\n+    }\n+    if (U_FAILURE(status)) {\n+        return count;\n+    }\n+    for (int32_t i = 0; i < otherLength; i++) {\n+        getCharPtr()[position + i] = unistr.charAt(startOther + i);\n+        getFieldPtr()[position + i] = field;\n+    }\n+    return count;\n+}\n+\n int32_t NumberStringBuilder::append(const NumberStringBuilder &other, UErrorCode &status) {\n     return insert(fLength, other, status);\n }\n@@ -296,6 +320,19 @@ int32_t NumberStringBuilder::prepareForInsertHelper(int32_t index, int32_t count\n     return fZero + index;\n }\n \n+int32_t NumberStringBuilder::remove(int32_t index, int32_t count) {\n+    // TODO: Reset the heap here?  (If the string after removal can fit on stack?)\n+    int32_t position = index + fZero;\n+    uprv_memmove2(getCharPtr() + position,\n+            getCharPtr() + position + count,\n+            sizeof(char16_t) * (fLength - index - count));\n+    uprv_memmove2(getFieldPtr() + position,\n+            getFieldPtr() + position + count,\n+            sizeof(Field) * (fLength - index - count));\n+    fLength -= count;\n+    return position;\n+}\n+\n UnicodeString NumberStringBuilder::toUnicodeString() const {\n     return UnicodeString(getCharPtr() + fZero, fLength);\n }"
        },
        {
            "sha": "a97cc9ca026ad09a6c026181ec0bd791bcdfbe3d",
            "filename": "deps/icu-small/source/i18n/number_stringbuilder.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -77,6 +77,9 @@ class U_I18N_API NumberStringBuilder : public UMemory {\n     int32_t insert(int32_t index, const UnicodeString &unistr, int32_t start, int32_t end, Field field,\n                    UErrorCode &status);\n \n+    int32_t splice(int32_t startThis, int32_t endThis,  const UnicodeString &unistr,\n+                   int32_t startOther, int32_t endOther, Field field, UErrorCode& status);\n+\n     int32_t append(const NumberStringBuilder &other, UErrorCode &status);\n \n     int32_t insert(int32_t index, const NumberStringBuilder &other, UErrorCode &status);\n@@ -123,6 +126,8 @@ class U_I18N_API NumberStringBuilder : public UMemory {\n     int32_t prepareForInsert(int32_t index, int32_t count, UErrorCode &status);\n \n     int32_t prepareForInsertHelper(int32_t index, int32_t count, UErrorCode &status);\n+\n+    int32_t remove(int32_t index, int32_t count);\n };\n \n } // namespace impl"
        },
        {
            "sha": "c01765e2cea6c6c0f3dacdd24407fc272cce18cf",
            "filename": "deps/icu-small/source/i18n/number_types.h",
            "status": "modified",
            "additions": 19,
            "deletions": 5,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_types.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_types.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_types.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -31,7 +31,7 @@ typedef UNumberFormatPadPosition PadPosition;\n typedef UNumberCompactStyle CompactStyle;\n \n // ICU4J Equivalent: RoundingUtils.MAX_INT_FRAC_SIG\n-static constexpr int32_t kMaxIntFracSig = 100;\n+static constexpr int32_t kMaxIntFracSig = 999;\n \n // ICU4J Equivalent: RoundingUtils.DEFAULT_ROUNDING_MODE\n static constexpr RoundingMode kDefaultMode = RoundingMode::UNUM_FOUND_HALFEVEN;\n@@ -42,10 +42,6 @@ static constexpr char16_t kFallbackPaddingString[] = u\" \";\n // ICU4J Equivalent: NumberFormatterImpl.DEFAULT_CURRENCY\n static constexpr char16_t kDefaultCurrency[] = u\"XXX\";\n \n-// FIXME: New error codes:\n-static constexpr UErrorCode U_NUMBER_DIGIT_WIDTH_OUTOFBOUNDS_ERROR = U_ILLEGAL_ARGUMENT_ERROR;\n-static constexpr UErrorCode U_NUMBER_PADDING_WIDTH_OUTOFBOUNDS_ERROR = U_ILLEGAL_ARGUMENT_ERROR;\n-\n // Forward declarations:\n \n class Modifier;\n@@ -142,6 +138,13 @@ class U_I18N_API AffixPatternProvider {\n     virtual bool negativeHasMinusSign() const = 0;\n \n     virtual bool containsSymbolType(AffixPatternType, UErrorCode &) const = 0;\n+\n+    /**\n+     * True if the pattern has a number placeholder like \"0\" or \"#,##0.00\"; false if the pattern does not\n+     * have one. This is used in cases like compact notation, where the pattern replaces the entire\n+     * number instead of rendering the number.\n+     */\n+    virtual bool hasBody() const = 0;\n };\n \n /**\n@@ -230,10 +233,21 @@ class U_I18N_API MicroPropsGenerator {\n     virtual void processQuantity(DecimalQuantity& quantity, MicroProps& micros, UErrorCode& status) const = 0;\n };\n \n+/**\n+ * An interface used by compact notation and scientific notation to choose a multiplier while rounding.\n+ */\n class MultiplierProducer {\n   public:\n     virtual ~MultiplierProducer() = default;\n \n+    /**\n+     * Maps a magnitude to a multiplier in powers of ten. For example, in compact notation in English, a magnitude of 5\n+     * (e.g., 100,000) should return a multiplier of -3, since the number is displayed in thousands.\n+     *\n+     * @param magnitude\n+     *            The power of ten of the input number.\n+     * @return The shift in powers of ten.\n+     */\n     virtual int32_t getMultiplier(int32_t magnitude) const = 0;\n };\n "
        },
        {
            "sha": "3385f300b11afe6110c285bcec12c38c742f36cf",
            "filename": "deps/icu-small/source/i18n/rbnf.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Frbnf.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Frbnf.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Frbnf.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -1371,7 +1371,7 @@ RuleBasedNumberFormat::parse(const UnicodeString& text,\n             ParsePosition working_pp(0);\n             Formattable working_result;\n \n-            rp->parse(workingText, working_pp, kMaxDouble, working_result);\n+            rp->parse(workingText, working_pp, kMaxDouble, 0, working_result);\n             if (working_pp.getIndex() > high_pp.getIndex()) {\n                 high_pp = working_pp;\n                 high_result = working_result;"
        },
        {
            "sha": "410ff9513bb82acc0d0363d8ad57cec3e8ed41ff",
            "filename": "deps/icu-small/source/i18n/regexcmp.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fregexcmp.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fregexcmp.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fregexcmp.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -4450,11 +4450,9 @@ UnicodeSet *RegexCompile::createSetForProperty(const UnicodeString &propName, UB\n     //    See if the property looks like a Java \"InBlockName\", which\n     //    we will recast as \"Block=BlockName\"\n     //\n-    static const UChar IN[] = {0x49, 0x6E, 0};  // \"In\"\n-    static const UChar BLOCK[] = {0x42, 0x6C, 0x6f, 0x63, 0x6b, 0x3d, 00};  // \"Block=\"\n-    if (mPropName.startsWith(IN, 2) && propName.length()>=3) {\n+    if (mPropName.startsWith(u\"In\", 2) && propName.length()>=3) {\n         setExpr.truncate(4);   // Leaves \"[\\p{\", or \"[\\P{\"\n-        setExpr.append(BLOCK, -1);\n+        setExpr.append(u\"Block=\", -1);\n         setExpr.append(UnicodeString(mPropName, 2));  // Property with the leading \"In\" removed.\n         setExpr.append(chRBrace);\n         setExpr.append(chRBracket);"
        },
        {
            "sha": "f2521822078169d464af9dc9717b2aa8a013e230",
            "filename": "deps/icu-small/source/i18n/rematch.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Frematch.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Frematch.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Frematch.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -5469,7 +5469,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu\n                 if (lbStartIdx < 0) {\n                     // First time through loop.\n                     lbStartIdx = fp->fInputIdx - minML;\n-                    if (lbStartIdx > 0) {\n+                    if (lbStartIdx > 0 && lbStartIdx < fInputLength) {\n                         U16_SET_CP_START(inputBuf, 0, lbStartIdx);\n                     }\n                 } else {\n@@ -5546,7 +5546,7 @@ void RegexMatcher::MatchChunkAt(int32_t startIdx, UBool toEnd, UErrorCode &statu\n                 if (lbStartIdx < 0) {\n                     // First time through loop.\n                     lbStartIdx = fp->fInputIdx - minML;\n-                    if (lbStartIdx > 0) {\n+                    if (lbStartIdx > 0 && lbStartIdx < fInputLength) {\n                         U16_SET_CP_START(inputBuf, 0, lbStartIdx);\n                     }\n                 } else {"
        },
        {
            "sha": "9bce8ed55705eefa540bac560bd5c67e0b4ca01e",
            "filename": "deps/icu-small/source/i18n/simpletz.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fsimpletz.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fsimpletz.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fsimpletz.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -177,7 +177,7 @@ void SimpleTimeZone::construct(int32_t rawOffsetGMT,\n \n     decodeRules(status);\n \n-    if (savingsDST <= 0) {\n+    if (savingsDST == 0) {\n         status = U_ILLEGAL_ARGUMENT_ERROR;\n     }\n }\n@@ -686,7 +686,7 @@ SimpleTimeZone::setRawOffset(int32_t offsetMillis)\n void\n SimpleTimeZone::setDSTSavings(int32_t millisSavedDuringDST, UErrorCode& status)\n {\n-    if (millisSavedDuringDST <= 0) {\n+    if (millisSavedDuringDST == 0) {\n         status = U_ILLEGAL_ARGUMENT_ERROR;\n     }\n     else {"
        },
        {
            "sha": "7d3392da2235032cc794a7b05619d5573f421e1d",
            "filename": "deps/icu-small/source/i18n/ucol.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fucol.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fucol.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fucol.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -95,6 +95,7 @@ ucol_safeClone(const UCollator *coll, void * /*stackBuffer*/, int32_t * pBufferS\n     Collator *newColl = Collator::fromUCollator(coll)->clone();\n     if (newColl == NULL) {\n         *status = U_MEMORY_ALLOCATION_ERROR;\n+        return nullptr;\n     } else {\n         *status = U_SAFECLONE_ALLOCATED_WARNING;\n     }"
        },
        {
            "sha": "76975ecc01de638af22f6028c699ccbb3897f9e4",
            "filename": "deps/icu-small/source/i18n/ucol_res.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fucol_res.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fucol_res.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fucol_res.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -451,6 +451,7 @@ CollationLoader::loadFromData(UErrorCode &errorCode) {\n     const CollationCacheEntry *entry = new CollationCacheEntry(validLocale, t.getAlias());\n     if(entry == NULL) {\n         errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return nullptr;\n     } else {\n         t.orphan();\n     }"
        },
        {
            "sha": "febf73b3ce499fdcaf4ea3504d80bc1a7f8bed63",
            "filename": "deps/icu-small/source/i18n/udatpg.cpp",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fudatpg.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Fudatpg.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fudatpg.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -181,6 +181,25 @@ udatpg_getAppendItemName(const UDateTimePatternGenerator *dtpg,\n     return result.getBuffer();\n }\n \n+U_CAPI int32_t U_EXPORT2\n+udatpg_getFieldDisplayName(const UDateTimePatternGenerator *dtpg,\n+                           UDateTimePatternField field,\n+                           UDateTimePGDisplayWidth width,\n+                           UChar *fieldName, int32_t capacity,\n+                           UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode))\n+        return -1;\n+    if (fieldName == NULL ? capacity != 0 : capacity < 0) {\n+        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return -1;\n+    }\n+    UnicodeString result = ((const DateTimePatternGenerator *)dtpg)->getFieldDisplayName(field,width);\n+    if (fieldName == NULL) {\n+        return result.length();\n+    }\n+    return result.extract(fieldName, capacity, *pErrorCode);\n+}\n+\n U_CAPI void U_EXPORT2\n udatpg_setDateTimeFormat(const UDateTimePatternGenerator *dtpg,\n                          const UChar *dtFormat, int32_t length) {"
        },
        {
            "sha": "d682d2d0e742789cb4c965b1ed0bd7a0d710510f",
            "filename": "deps/icu-small/source/i18n/unicode/compactdecimalformat.h",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcompactdecimalformat.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcompactdecimalformat.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcompactdecimalformat.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -16,7 +16,7 @@\n #include \"unicode/utypes.h\"\n /**\n  * \\file\n- * \\brief C++ API: Formats decimal numbers in compact form.\n+ * \\brief C++ API: Compatibility APIs for compact decimal number formatting.\n  */\n \n #if !UCONFIG_NO_FORMATTING\n@@ -30,6 +30,11 @@ U_NAMESPACE_BEGIN\n class PluralRules;\n \n /**\n+ * <p><strong>IMPORTANT:</strong> New users are strongly encouraged to see if\n+ * numberformatter.h fits their use case.  Although not deprecated, this header\n+ * is provided for backwards compatibility only.\n+ * <hr/>\n+ *\n  * The CompactDecimalFormat produces abbreviated numbers, suitable for display in\n  * environments will limited real estate. For example, 'Hits: 1.2B' instead of\n  * 'Hits: 1,200,000,000'. The format will be appropriate for the given language,\n@@ -56,6 +61,9 @@ class U_I18N_API CompactDecimalFormat : public DecimalFormat {\n \n      /**\n       * Returns a compact decimal instance for specified locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n       * @param inLocale the given locale.\n       * @param style whether to use short or long style.\n       * @param status error code returned  here."
        },
        {
            "sha": "c895183931546ea1c30c23f751b441a70ffc76d4",
            "filename": "deps/icu-small/source/i18n/unicode/datefmt.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdatefmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdatefmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdatefmt.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -44,7 +44,8 @@ class TimeZone;\n class DateTimePatternGenerator;\n \n // explicit template instantiation. see digitlst.h\n-#if defined (_MSC_VER)\n+// (When building DLLs for Windows this is required.)\n+#if U_PF_WINDOWS <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN\n template class U_I18N_API EnumSet<UDateFormatBooleanAttribute,\n             0,\n             UDAT_BOOLEAN_ATTRIBUTE_COUNT>;"
        },
        {
            "sha": "e58befa31bda88ccb4ee094700b53ee961467ead",
            "filename": "deps/icu-small/source/i18n/unicode/dcfmtsym.h",
            "status": "modified",
            "additions": 59,
            "deletions": 8,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdcfmtsym.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdcfmtsym.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdcfmtsym.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -80,10 +80,6 @@ U_NAMESPACE_BEGIN\n  * If you supply a pattern with multiple grouping characters, the interval\n  * between the last one and the end of the integer is the one that is\n  * used. So \"#,##,###,####\" == \"######,####\" == \"##,####,####\".\n- * <P>\n- * This class only handles localized digits where the 10 digits are\n- * contiguous in Unicode, from 0 to 9. Other digits sets (such as\n- * superscripts) would need a different subclass.\n  */\n class U_I18N_API DecimalFormatSymbols : public UObject {\n public:\n@@ -396,6 +392,13 @@ class U_I18N_API DecimalFormatSymbols : public UObject {\n     inline UBool isCustomIntlCurrencySymbol() const {\n         return fIsCustomIntlCurrencySymbol;\n     }\n+\n+    /**\n+     * @internal For ICU use only\n+     */\n+    inline UChar32 getCodePointZero() const {\n+        return fCodePointZero;\n+    }\n #endif  /* U_HIDE_INTERNAL_API */\n \n     /**\n@@ -410,9 +413,22 @@ class U_I18N_API DecimalFormatSymbols : public UObject {\n      * @return the format symbol by the param 'symbol'\n      * @internal\n      */\n-    inline const UnicodeString &getConstSymbol(ENumberFormatSymbol symbol) const;\n+    inline const UnicodeString& getConstSymbol(ENumberFormatSymbol symbol) const;\n \n #ifndef U_HIDE_INTERNAL_API\n+    /**\n+     * Returns the const UnicodeString reference, like getConstSymbol,\n+     * corresponding to the digit with the given value.  This is equivalent\n+     * to accessing the symbol from getConstSymbol with the corresponding\n+     * key, such as kZeroDigitSymbol or kOneDigitSymbol.\n+     *\n+     * @param digit The digit, an integer between 0 and 9 inclusive.\n+     *              If outside the range 0 to 9, the zero digit is returned.\n+     * @return the format symbol for the given digit.\n+     * @internal This API is currently for ICU use only.\n+     */\n+    inline const UnicodeString& getConstDigitSymbol(int32_t digit) const;\n+\n     /**\n      * Returns that pattern stored in currecy info. Internal API for use by NumberFormat API.\n      * @internal\n@@ -444,6 +460,22 @@ class U_I18N_API DecimalFormatSymbols : public UObject {\n      */\n     UnicodeString fNoSymbol;\n \n+    /**\n+     * Dealing with code points is faster than dealing with strings when formatting. Because of\n+     * this, we maintain a value containing the zero code point that is used whenever digitStrings\n+     * represents a sequence of ten code points in order.\n+     *\n+     * <p>If the value stored here is positive, it means that the code point stored in this value\n+     * corresponds to the digitStrings array, and codePointZero can be used instead of the\n+     * digitStrings array for the purposes of efficient formatting; if -1, then digitStrings does\n+     * *not* contain a sequence of code points, and it must be used directly.\n+     *\n+     * <p>It is assumed that codePointZero always shadows the value in digitStrings. codePointZero\n+     * should never be set directly; rather, it should be updated only when digitStrings mutates.\n+     * That is, the flow of information is digitStrings -> codePointZero, not the other way.\n+     */\n+    UChar32 fCodePointZero;\n+\n     Locale locale;\n \n     char actualLocale[ULOC_FULLNAME_CAPACITY];\n@@ -469,7 +501,7 @@ DecimalFormatSymbols::getSymbol(ENumberFormatSymbol symbol) const {\n     return *strPtr;\n }\n \n-// See comments above for this function. Not hidden with #ifndef U_HIDE_INTERNAL_API\n+// See comments above for this function. Not hidden with #ifdef U_HIDE_INTERNAL_API\n inline const UnicodeString &\n DecimalFormatSymbols::getConstSymbol(ENumberFormatSymbol symbol) const {\n     const UnicodeString *strPtr;\n@@ -481,6 +513,19 @@ DecimalFormatSymbols::getConstSymbol(ENumberFormatSymbol symbol) const {\n     return *strPtr;\n }\n \n+#ifndef U_HIDE_INTERNAL_API\n+inline const UnicodeString& DecimalFormatSymbols::getConstDigitSymbol(int32_t digit) const {\n+    if (digit < 0 || digit > 9) {\n+        digit = 0;\n+    }\n+    if (digit == 0) {\n+        return fSymbols[kZeroDigitSymbol];\n+    }\n+    ENumberFormatSymbol key = static_cast<ENumberFormatSymbol>(kOneDigitSymbol + digit - 1);\n+    return fSymbols[key];\n+}\n+#endif\n+\n // -------------------------------------\n \n inline void\n@@ -497,14 +542,20 @@ DecimalFormatSymbols::setSymbol(ENumberFormatSymbol symbol, const UnicodeString\n \n     // If the zero digit is being set to a known zero digit according to Unicode,\n     // then we automatically set the corresponding 1-9 digits\n-    if ( propogateDigits && symbol == kZeroDigitSymbol && value.countChar32() == 1 ) {\n+    // Also record updates to fCodePointZero. Be conservative if in doubt.\n+    if (symbol == kZeroDigitSymbol) {\n         UChar32 sym = value.char32At(0);\n-        if ( u_charDigitValue(sym) == 0 ) {\n+        if ( propogateDigits && u_charDigitValue(sym) == 0 && value.countChar32() == 1 ) {\n+            fCodePointZero = sym;\n             for ( int8_t i = 1 ; i<= 9 ; i++ ) {\n                 sym++;\n                 fSymbols[(int)kOneDigitSymbol+i-1] = UnicodeString(sym);\n             }\n+        } else {\n+            fCodePointZero = -1;\n         }\n+    } else if (symbol >= kOneDigitSymbol && symbol <= kNineDigitSymbol) {\n+        fCodePointZero = -1;\n     }\n }\n "
        },
        {
            "sha": "b062208d9b1f93574678d25b8fe7b717987a5760",
            "filename": "deps/icu-small/source/i18n/unicode/decimfmt.h",
            "status": "modified",
            "additions": 25,
            "deletions": 2,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdecimfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdecimfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdecimfmt.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -30,7 +30,7 @@\n #include \"unicode/utypes.h\"\n /**\n  * \\file\n- * \\brief C++ API: Formats decimal numbers.\n+ * \\brief C++ API: Compatibility APIs for decimal formatting.\n  */\n \n #if !UCONFIG_NO_FORMATTING\n@@ -67,13 +67,19 @@ class PluralRules;\n class VisibleDigitsWithExponent;\n \n // explicit template instantiation. see digitlst.h\n-#if defined (_MSC_VER)\n+// (When building DLLs for Windows this is required.)\n+#if U_PF_WINDOWS <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN\n template class U_I18N_API    EnumSet<UNumberFormatAttribute,\n             UNUM_MAX_NONBOOLEAN_ATTRIBUTE+1,\n             UNUM_LIMIT_BOOLEAN_ATTRIBUTE>;\n #endif\n \n /**\n+ * <p><strong>IMPORTANT:</strong> New users are strongly encouraged to see if\n+ * numberformatter.h fits their use case.  Although not deprecated, this header\n+ * is provided for backwards compatibility only.\n+ * <hr/>\n+ *\n  * DecimalFormat is a concrete subclass of NumberFormat that formats decimal\n  * numbers. It has a variety of features designed to make it possible to parse\n  * and format numbers in any locale, including support for Western, Arabic, or\n@@ -688,6 +694,9 @@ class U_I18N_API DecimalFormat: public NumberFormat {\n      * on NumberFormat such as createInstance. These factories will\n      * return the most appropriate sub-class of NumberFormat for a given\n      * locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of DecimalFormat.\n      * @param status    Output param set to success/failure code. If the\n      *                  pattern is invalid this will be set to a failure code.\n      * @stable ICU 2.0\n@@ -703,6 +712,9 @@ class U_I18N_API DecimalFormat: public NumberFormat {\n      * on NumberFormat such as createInstance. These factories will\n      * return the most appropriate sub-class of NumberFormat for a given\n      * locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of DecimalFormat.\n      * @param pattern   A non-localized pattern string.\n      * @param status    Output param set to success/failure code. If the\n      *                  pattern is invalid this will be set to a failure code.\n@@ -721,6 +733,9 @@ class U_I18N_API DecimalFormat: public NumberFormat {\n      * createInstance or createCurrencyInstance. If you need only minor adjustments\n      * to a standard format, you can modify the format returned by\n      * a NumberFormat factory method.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of DecimalFormat.\n      *\n      * @param pattern           a non-localized pattern string\n      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not\n@@ -826,6 +841,9 @@ class U_I18N_API DecimalFormat: public NumberFormat {\n      * createInstance or createCurrencyInstance. If you need only minor adjustments\n      * to a standard format, you can modify the format returned by\n      * a NumberFormat factory method.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of DecimalFormat.\n      *\n      * @param pattern           a non-localized pattern string\n      * @param symbolsToAdopt    the set of symbols to be used.  The caller should not\n@@ -849,6 +867,9 @@ class U_I18N_API DecimalFormat: public NumberFormat {\n      * createInstance or createCurrencyInstance. If you need only minor adjustments\n      * to a standard format, you can modify the format returned by\n      * a NumberFormat factory method.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of DecimalFormat.\n      *\n      * @param pattern           a non-localized pattern string\n      * @param symbols   the set of symbols to be used\n@@ -1964,12 +1985,14 @@ class U_I18N_API DecimalFormat: public NumberFormat {\n     UCurrencyUsage getCurrencyUsage() const;\n \n \n+#ifndef U_HIDE_DEPRECATED_API\n     /**\n      * The resource tags we use to retrieve decimal format data from\n      * locale resource bundles.\n      * @deprecated ICU 3.4. This string has no public purpose. Please don't use it.\n      */\n     static const char fgNumberPatterns[];\n+#endif  // U_HIDE_DEPRECATED_API\n \n #ifndef U_HIDE_INTERNAL_API\n     /**"
        },
        {
            "sha": "feb465e799740136a528b7f16ce159791d3f6017",
            "filename": "deps/icu-small/source/i18n/unicode/dtptngen.h",
            "status": "modified",
            "additions": 26,
            "deletions": 4,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdtptngen.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdtptngen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdtptngen.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -263,14 +263,29 @@ class U_I18N_API DateTimePatternGenerator : public UObject {\n \n     /**\n      * Getter corresponding to setAppendItemNames. Values below 0 or at or above\n-     * UDATPG_FIELD_COUNT are illegal arguments.\n+     * UDATPG_FIELD_COUNT are illegal arguments. Note: The more general method\n+     * for getting date/time field display names is getFieldDisplayName.\n      *\n      * @param field  such as UDATPG_ERA_FIELD.\n      * @return name for field\n+     * @see getFieldDisplayName\n      * @stable ICU 3.8\n      */\n     const UnicodeString& getAppendItemName(UDateTimePatternField field) const;\n \n+#ifndef U_HIDE_DRAFT_API\n+    /**\n+     * The general interface to get a display name for a particular date/time field,\n+     * in one of several possible display widths.\n+     *\n+     * @param field  The desired UDateTimePatternField, such as UDATPG_ERA_FIELD.\n+     * @param width  The desired UDateTimePGDisplayWidth, such as UDATPG_ABBREVIATED.\n+     * @return.      The display name for field\n+     * @draft ICU 61\n+     */\n+    UnicodeString getFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width) const;\n+#endif  // U_HIDE_DRAFT_API\n+\n     /**\n      * The DateTimeFormat is a message format pattern used to compose date and\n      * time patterns. The default pattern in the root locale is \"{1} {0}\", where\n@@ -507,13 +522,17 @@ class U_I18N_API DateTimePatternGenerator : public UObject {\n      */\n     DateTimePatternGenerator& operator=(const DateTimePatternGenerator& other);\n \n+    // TODO(ticket:13619): re-enable when UDATPG_NARROW no longer in  draft mode.\n+    // static const int32_t UDATPG_WIDTH_COUNT = UDATPG_NARROW + 1;\n+\n     Locale pLocale;  // pattern locale\n     FormatParser *fp;\n     DateTimeMatcher* dtMatcher;\n     DistanceInfo *distanceInfo;\n     PatternMap *patternMap;\n     UnicodeString appendItemFormats[UDATPG_FIELD_COUNT];\n-    UnicodeString appendItemNames[UDATPG_FIELD_COUNT];\n+    // TODO(ticket:13619): [3] -> UDATPG_WIDTH_COUNT\n+    UnicodeString fieldDisplayNames[UDATPG_FIELD_COUNT][3];\n     UnicodeString dateTimeFormat;\n     UnicodeString decimal;\n     DateTimeMatcher *skipMatcher;\n@@ -543,8 +562,11 @@ class U_I18N_API DateTimePatternGenerator : public UObject {\n     void setDateTimeFromCalendar(const Locale& locale, UErrorCode& status);\n     void setDecimalSymbols(const Locale& locale, UErrorCode& status);\n     UDateTimePatternField getAppendFormatNumber(const char* field) const;\n-    UDateTimePatternField getAppendNameNumber(const char* field) const;\n-    UnicodeString& getMutableAppendItemName(UDateTimePatternField field);\n+#ifndef U_HIDE_DRAFT_API\n+    UDateTimePatternField getFieldAndWidthIndices(const char* key, UDateTimePGDisplayWidth* widthP) const;\n+    void setFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width, const UnicodeString& value);\n+    UnicodeString& getMutableFieldDisplayName(UDateTimePatternField field, UDateTimePGDisplayWidth width);\n+#endif  // U_HIDE_DRAFT_API\n     void getAppendName(UDateTimePatternField field, UnicodeString& value);\n     UnicodeString mapSkeletonMetacharacters(const UnicodeString& patternForm, int32_t* flags, UErrorCode& status);\n     int32_t getCanonicalIndex(const UnicodeString& field);"
        },
        {
            "sha": "14399dd59a700a8b103cfb6a3c2024b56a8fe544",
            "filename": "deps/icu-small/source/i18n/unicode/measfmt.h",
            "status": "modified",
            "additions": 16,
            "deletions": 3,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasfmt.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -22,7 +22,7 @@\n \n /**\n  * \\file\n- * \\brief C++ API: Formatter for measure objects.\n+ * \\brief C++ API: Compatibility APIs for measure formatting.\n  */\n \n /**\n@@ -87,8 +87,9 @@ class ListFormatter;\n class DateFormat;\n \n /**\n- *\n- * A formatter for measure objects.\n+ * <p><strong>IMPORTANT:</strong> New users are strongly encouraged to see if\n+ * numberformatter.h fits their use case.  Although not deprecated, this header\n+ * is provided for backwards compatibility only.\n  *\n  * @see Format\n  * @author Alan Liu\n@@ -101,13 +102,19 @@ class U_I18N_API MeasureFormat : public Format {\n \n     /**\n      * Constructor.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @stable ICU 53\n      */\n     MeasureFormat(\n             const Locale &locale, UMeasureFormatWidth width, UErrorCode &status);\n \n     /**\n      * Constructor.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @stable ICU 53\n      */\n     MeasureFormat(\n@@ -227,6 +234,9 @@ class U_I18N_API MeasureFormat : public Format {\n     /**\n      * Return a formatter for CurrencyAmount objects in the given\n      * locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @param locale desired locale\n      * @param ec input-output error code\n      * @return a formatter object, or NULL upon error\n@@ -238,6 +248,9 @@ class U_I18N_API MeasureFormat : public Format {\n     /**\n      * Return a formatter for CurrencyAmount objects in the default\n      * locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @param ec input-output error code\n      * @return a formatter object, or NULL upon error\n      * @stable ICU 3.0"
        },
        {
            "sha": "f7ddb4e20c559f0ce3ca786250bde571a163f9b6",
            "filename": "deps/icu-small/source/i18n/unicode/measunit.h",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasunit.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasunit.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasunit.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -196,8 +196,8 @@ class U_I18N_API MeasureUnit: public UObject {\n      * ICU use only.\n      * @internal\n      */\n-    static MeasureUnit *resolveUnitPerUnit(\n-            const MeasureUnit &unit, const MeasureUnit &perUnit);\n+    static MeasureUnit resolveUnitPerUnit(\n+            const MeasureUnit &unit, const MeasureUnit &perUnit, bool* isResolved);\n #endif /* U_HIDE_INTERNAL_API */\n \n // All code between the \"Start generated createXXX methods\" comment and\n@@ -832,15 +832,13 @@ class U_I18N_API MeasureUnit: public UObject {\n      */\n     static MeasureUnit *createPicometer(UErrorCode &status);\n \n-#ifndef U_HIDE_DRAFT_API\n     /**\n      * Returns unit of length: point.\n      * Caller owns returned value and must free it.\n      * @param status ICU error code.\n-     * @draft ICU 59\n+     * @stable ICU 59\n      */\n     static MeasureUnit *createPoint(UErrorCode &status);\n-#endif  /* U_HIDE_DRAFT_API */\n \n     /**\n      * Returns unit of length: yard."
        },
        {
            "sha": "290e77e8806040a9ccce261db5131d33f307ddfe",
            "filename": "deps/icu-small/source/i18n/unicode/nounit.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnounit.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnounit.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnounit.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -10,17 +10,17 @@\n #ifndef __NOUNIT_H__\n #define __NOUNIT_H__\n \n+#include \"unicode/utypes.h\"\n+\n+#if !UCONFIG_NO_FORMATTING\n+\n+#include \"unicode/measunit.h\"\n \n /**\n  * \\file\n  * \\brief C++ API: units for percent and permille\n  */\n \n-\n-#include \"unicode/measunit.h\"\n-\n-#if !UCONFIG_NO_FORMATTING\n-\n U_NAMESPACE_BEGIN\n \n #ifndef U_HIDE_DRAFT_API"
        },
        {
            "sha": "3fbb33cceeabf78c1608dfb0b39bbae382fa84fd",
            "filename": "deps/icu-small/source/i18n/unicode/numberformatter.h",
            "status": "modified",
            "additions": 307,
            "deletions": 111,
            "changes": 418,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumberformatter.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumberformatter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumberformatter.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -88,10 +88,6 @@\n  * </ul>\n  *\n  * <p>\n- * * The narrow format for currencies is not currently supported; this is a known issue that will be fixed in a\n- * future version. See #11666 for more information.\n- *\n- * <p>\n  * This enum is similar to {@link com.ibm.icu.text.MeasureFormat.FormatWidth}.\n  *\n  * @draft ICU 60\n@@ -155,27 +151,122 @@ typedef enum UNumberUnitWidth {\n      *\n      * @draft ICU 60\n      */\n-            UNUM_UNIT_WIDTH_HIDDEN,\n+            UNUM_UNIT_WIDTH_HIDDEN\n \n+#ifndef U_HIDE_INTERNAL_API\n+    ,\n     /**\n      * One more than the highest UNumberUnitWidth value.\n      *\n      * @internal ICU 60: The numeric value may change over time; see ICU ticket #12420.\n      */\n             UNUM_UNIT_WIDTH_COUNT\n+#endif  // U_HIDE_INTERNAL_API\n } UNumberUnitWidth;\n \n /**\n- * An enum declaring how to denote positive and negative numbers. Example outputs when formatting 123 and -123 in\n- * <em>en-US</em>:\n+ * An enum declaring the strategy for when and how to display grouping separators (i.e., the\n+ * separator, often a comma or period, after every 2-3 powers of ten). The choices are several\n+ * pre-built strategies for different use cases that employ locale data whenever possible. Example\n+ * outputs for 1234 and 1234567 in <em>en-IN</em>:\n+ *\n+ * <ul>\n+ * <li>OFF: 1234 and 12345\n+ * <li>MIN2: 1234 and 12,34,567\n+ * <li>AUTO: 1,234 and 12,34,567\n+ * <li>ON_ALIGNED: 1,234 and 12,34,567\n+ * <li>THOUSANDS: 1,234 and 1,234,567\n+ * </ul>\n  *\n  * <p>\n+ * The default is AUTO, which displays grouping separators unless the locale data says that grouping\n+ * is not customary. To force grouping for all numbers greater than 1000 consistently across locales,\n+ * use ON_ALIGNED. On the other hand, to display grouping less frequently than the default, use MIN2\n+ * or OFF. See the docs of each option for details.\n+ *\n+ * <p>\n+ * Note: This enum specifies the strategy for grouping sizes. To set which character to use as the\n+ * grouping separator, use the \"symbols\" setter.\n+ *\n+ * @draft ICU 61\n+ */\n+typedef enum UGroupingStrategy {\n+    /**\n+     * Do not display grouping separators in any locale.\n+     *\n+     * @draft ICU 61\n+     */\n+    UNUM_GROUPING_OFF,\n+\n+    /**\n+     * Display grouping using locale defaults, except do not show grouping on values smaller than\n+     * 10000 (such that there is a <em>minimum of two digits</em> before the first separator).\n+     *\n+     * <p>\n+     * Note that locales may restrict grouping separators to be displayed only on 1 million or\n+     * greater (for example, ee and hu) or disable grouping altogether (for example, bg currency).\n+     *\n+     * <p>\n+     * Locale data is used to determine whether to separate larger numbers into groups of 2\n+     * (customary in South Asia) or groups of 3 (customary in Europe and the Americas).\n+     *\n+     * @draft ICU 61\n+     */\n+    UNUM_GROUPING_MIN2,\n+\n+    /**\n+     * Display grouping using the default strategy for all locales. This is the default behavior.\n+     *\n+     * <p>\n+     * Note that locales may restrict grouping separators to be displayed only on 1 million or\n+     * greater (for example, ee and hu) or disable grouping altogether (for example, bg currency).\n+     *\n+     * <p>\n+     * Locale data is used to determine whether to separate larger numbers into groups of 2\n+     * (customary in South Asia) or groups of 3 (customary in Europe and the Americas).\n+     *\n+     * @draft ICU 61\n+     */\n+    UNUM_GROUPING_AUTO,\n+\n+    /**\n+     * Always display the grouping separator on values of at least 1000.\n+     *\n+     * <p>\n+     * This option ignores the locale data that restricts or disables grouping, described in MIN2 and\n+     * AUTO. This option may be useful to normalize the alignment of numbers, such as in a\n+     * spreadsheet.\n+     *\n+     * <p>\n+     * Locale data is used to determine whether to separate larger numbers into groups of 2\n+     * (customary in South Asia) or groups of 3 (customary in Europe and the Americas).\n+     *\n+     * @draft ICU 61\n+     */\n+    UNUM_GROUPING_ON_ALIGNED,\n+\n+    /**\n+     * Use the Western defaults: groups of 3 and enabled for all numbers 1000 or greater. Do not use\n+     * locale data for determining the grouping strategy.\n+     *\n+     * @draft ICU 61\n+     */\n+    UNUM_GROUPING_THOUSANDS\n+\n+} UGroupingStrategy;\n+\n+/**\n+ * An enum declaring how to denote positive and negative numbers. Example outputs when formatting\n+ * 123, 0, and -123 in <em>en-US</em>:\n+ *\n  * <ul>\n- * <li>AUTO: \"123\", \"-123\"\n- * <li>ALWAYS: \"+123\", \"-123\"\n- * <li>NEVER: \"123\", \"123\"\n- * <li>ACCOUNTING: \"$123\", \"($123)\"\n- * <li>ACCOUNTING_ALWAYS: \"+$123\", \"($123)\"\n+ * <li>AUTO: \"123\", \"0\", and \"-123\"\n+ * <li>ALWAYS: \"+123\", \"+0\", and \"-123\"\n+ * <li>NEVER: \"123\", \"0\", and \"123\"\n+ * <li>ACCOUNTING: \"$123\", \"$0\", and \"($123)\"\n+ * <li>ACCOUNTING_ALWAYS: \"+$123\", \"+$0\", and \"($123)\"\n+ * <li>EXCEPT_ZERO: \"+123\", \"0\", and \"-123\"\n+ * <li>ACCOUNTING_EXCEPT_ZERO: \"+$123\", \"$0\", and \"($123)\"\n  * </ul>\n  *\n  * <p>\n@@ -190,21 +281,22 @@ typedef enum UNumberSignDisplay {\n      *\n      * @draft ICU 60\n      */\n-            UNUM_SIGN_AUTO,\n+    UNUM_SIGN_AUTO,\n \n     /**\n-     * Show the minus sign on negative numbers and the plus sign on positive numbers.\n+     * Show the minus sign on negative numbers and the plus sign on positive numbers, including zero.\n+     * To hide the sign on zero, see {@link UNUM_SIGN_EXCEPT_ZERO}.\n      *\n      * @draft ICU 60\n      */\n-            UNUM_SIGN_ALWAYS,\n+    UNUM_SIGN_ALWAYS,\n \n     /**\n      * Do not show the sign on positive or negative numbers.\n      *\n      * @draft ICU 60\n      */\n-            UNUM_SIGN_NEVER,\n+    UNUM_SIGN_NEVER,\n \n     /**\n      * Use the locale-dependent accounting format on negative numbers, and do not show the sign on positive numbers.\n@@ -220,22 +312,44 @@ typedef enum UNumberSignDisplay {\n      *\n      * @draft ICU 60\n      */\n-            UNUM_SIGN_ACCOUNTING,\n+    UNUM_SIGN_ACCOUNTING,\n \n     /**\n-     * Use the locale-dependent accounting format on negative numbers, and show the plus sign on positive numbers.\n-     * For more information on the accounting format, see the ACCOUNTING sign display strategy.\n+     * Use the locale-dependent accounting format on negative numbers, and show the plus sign on\n+     * positive numbers, including zero. For more information on the accounting format, see the\n+     * ACCOUNTING sign display strategy. To hide the sign on zero, see\n+     * {@link UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO}.\n      *\n      * @draft ICU 60\n      */\n-            UNUM_SIGN_ACCOUNTING_ALWAYS,\n+    UNUM_SIGN_ACCOUNTING_ALWAYS,\n+\n+    /**\n+     * Show the minus sign on negative numbers and the plus sign on positive numbers. Do not show a\n+     * sign on zero.\n+     *\n+     * @draft ICU 61\n+     */\n+    UNUM_SIGN_EXCEPT_ZERO,\n+\n+    /**\n+     * Use the locale-dependent accounting format on negative numbers, and show the plus sign on\n+     * positive numbers. Do not show a sign on zero. For more information on the accounting format,\n+     * see the ACCOUNTING sign display strategy.\n+     *\n+     * @draft ICU 61\n+     */\n+    UNUM_SIGN_ACCOUNTING_EXCEPT_ZERO\n \n+#ifndef U_HIDE_INTERNAL_API\n+    ,\n     /**\n      * One more than the highest UNumberSignDisplay value.\n      *\n      * @internal ICU 60: The numeric value may change over time; see ICU ticket #12420.\n      */\n-            UNUM_SIGN_COUNT\n+    UNUM_SIGN_COUNT\n+#endif  // U_HIDE_INTERNAL_API\n } UNumberSignDisplay;\n \n /**\n@@ -261,14 +375,17 @@ typedef enum UNumberDecimalSeparatorDisplay {\n      *\n      * @draft ICU 60\n      */\n-            UNUM_DECIMAL_SEPARATOR_ALWAYS,\n+            UNUM_DECIMAL_SEPARATOR_ALWAYS\n \n+#ifndef U_HIDE_INTERNAL_API\n+    ,\n     /**\n      * One more than the highest UNumberDecimalSeparatorDisplay value.\n      *\n      * @internal ICU 60: The numeric value may change over time; see ICU ticket #12420.\n      */\n             UNUM_DECIMAL_SEPARATOR_COUNT\n+#endif  // U_HIDE_INTERNAL_API\n } UNumberDecimalMarkDisplay;\n \n U_NAMESPACE_BEGIN namespace number {  // icu::number\n@@ -283,11 +400,27 @@ class Rounder;\n class FractionRounder;\n class CurrencyRounder;\n class IncrementRounder;\n-class Grouper;\n class IntegerWidth;\n \n namespace impl {\n \n+#ifndef U_HIDE_INTERNAL_API\n+/**\n+ * Datatype for minimum/maximum fraction digits. Must be able to hold kMaxIntFracSig.\n+ *\n+ * @internal\n+ */\n+typedef int16_t digits_t;\n+\n+/**\n+ * Use a default threshold of 3. This means that the third time .format() is called, the data structures get built\n+ * using the \"safe\" code path. The first two calls to .format() will trigger the unsafe code path.\n+ *\n+ * @internal\n+ */\n+static constexpr int32_t DEFAULT_THRESHOLD = 3;\n+#endif  // U_HIDE_INTERNAL_API\n+\n // Forward declarations:\n class Padder;\n struct MacroProps;\n@@ -471,7 +604,7 @@ class U_I18N_API Notation : public UMemory {\n         struct ScientificSettings {\n             int8_t fEngineeringInterval;\n             bool fRequireMinInt;\n-            int8_t fMinExponentDigits;\n+            impl::digits_t fMinExponentDigits;\n             UNumberSignDisplay fExponentSignDisplay;\n         } scientific;\n \n@@ -786,14 +919,14 @@ class U_I18N_API Rounder : public UMemory {\n     union RounderUnion {\n         struct FractionSignificantSettings {\n             // For RND_FRACTION, RND_SIGNIFICANT, and RND_FRACTION_SIGNIFICANT\n-            int8_t fMinFrac;\n-            int8_t fMaxFrac;\n-            int8_t fMinSig;\n-            int8_t fMaxSig;\n+            impl::digits_t fMinFrac;\n+            impl::digits_t fMaxFrac;\n+            impl::digits_t fMinSig;\n+            impl::digits_t fMaxSig;\n         } fracSig;\n         struct IncrementSettings {\n             double fIncrement;\n-            int32_t fMinFrac;\n+            impl::digits_t fMinFrac;\n         } increment; // For RND_INCREMENT\n         UCurrencyUsage currencyUsage; // For RND_CURRENCY\n         UErrorCode errorCode; // For RND_ERROR\n@@ -836,6 +969,20 @@ class U_I18N_API Rounder : public UMemory {\n     /** Version of {@link #apply} that obeys minInt constraints. Used for scientific notation compatibility mode. */\n     void apply(impl::DecimalQuantity &value, int32_t minInt, UErrorCode status);\n \n+    /**\n+     * Rounding endpoint used by Engineering and Compact notation. Chooses the most appropriate multiplier (magnitude\n+     * adjustment), applies the adjustment, rounds, and returns the chosen multiplier.\n+     *\n+     * <p>\n+     * In most cases, this is simple. However, when rounding the number causes it to cross a multiplier boundary, we\n+     * need to re-do the rounding. For example, to display 999,999 in Engineering notation with 2 sigfigs, first you\n+     * guess the multiplier to be -3. However, then you end up getting 1000E3, which is not the correct output. You then\n+     * change your multiplier to be -6, and you get 1.0E6, which is correct.\n+     *\n+     * @param input The quantity to process.\n+     * @param producer Function to call to return a multiplier based on a magnitude.\n+     * @return The number of orders of magnitude the input was adjusted by this method.\n+     */\n     int32_t\n     chooseMultiplierAndApply(impl::DecimalQuantity &input, const impl::MultiplierProducer &producer,\n                              UErrorCode &status);\n@@ -1002,53 +1149,6 @@ class U_I18N_API IncrementRounder : public Rounder {\n     friend class Rounder;\n };\n \n-/**\n- * @internal This API is a technical preview.  It is likely to change in an upcoming release.\n- */\n-class U_I18N_API Grouper : public UMemory {\n-  public:\n-    /**\n-     * @internal This API is a technical preview.  It is likely to change in an upcoming release.\n-     */\n-    static Grouper defaults();\n-\n-    /**\n-     * @internal This API is a technical preview.  It is likely to change in an upcoming release.\n-     */\n-    static Grouper minTwoDigits();\n-\n-    /**\n-     * @internal This API is a technical preview.  It is likely to change in an upcoming release.\n-     */\n-    static Grouper none();\n-\n-  private:\n-    int8_t fGrouping1; // -3 means \"bogus\"; -2 means \"needs locale data\"; -1 means \"no grouping\"\n-    int8_t fGrouping2;\n-    bool fMin2;\n-\n-    Grouper(int8_t grouping1, int8_t grouping2, bool min2)\n-            : fGrouping1(grouping1), fGrouping2(grouping2), fMin2(min2) {}\n-\n-    Grouper() : fGrouping1(-3) {};\n-\n-    bool isBogus() const {\n-        return fGrouping1 == -3;\n-    }\n-\n-    /** NON-CONST: mutates the current instance. */\n-    void setLocaleData(const impl::ParsedPatternInfo &patternInfo);\n-\n-    bool groupAtPosition(int32_t position, const impl::DecimalQuantity &value) const;\n-\n-    // To allow MacroProps/MicroProps to initialize empty instances:\n-    friend struct impl::MacroProps;\n-    friend struct impl::MicroProps;\n-\n-    // To allow NumberFormatterImpl to access isBogus() and perform other operations:\n-    friend class impl::NumberFormatterImpl;\n-};\n-\n /**\n  * A class that defines the strategy for padding and truncating integers before the decimal separator.\n  *\n@@ -1080,7 +1180,8 @@ class U_I18N_API IntegerWidth : public UMemory {\n      * For example, with maxInt=3, the number 1234 will get printed as \"234\".\n      *\n      * @param maxInt\n-     *            The maximum number of places before the decimal separator.\n+     *            The maximum number of places before the decimal separator. maxInt == -1 means no\n+     *            truncation.\n      * @return An IntegerWidth for passing to the NumberFormatter integerWidth() setter.\n      * @draft ICU 60\n      * @see NumberFormatter\n@@ -1090,14 +1191,14 @@ class U_I18N_API IntegerWidth : public UMemory {\n   private:\n     union {\n         struct {\n-            int8_t fMinInt;\n-            int8_t fMaxInt;\n+            impl::digits_t fMinInt;\n+            impl::digits_t fMaxInt;\n         } minMaxInt;\n         UErrorCode errorCode;\n     } fUnion;\n     bool fHasError = false;\n \n-    IntegerWidth(int8_t minInt, int8_t maxInt);\n+    IntegerWidth(impl::digits_t minInt, impl::digits_t maxInt);\n \n     IntegerWidth(UErrorCode errorCode) { // NOLINT\n         fUnion.errorCode = errorCode;\n@@ -1132,14 +1233,7 @@ class U_I18N_API IntegerWidth : public UMemory {\n \n namespace impl {\n \n-/**\n- * Use a default threshold of 3. This means that the third time .format() is called, the data structures get built\n- * using the \"safe\" code path. The first two calls to .format() will trigger the unsafe code path.\n- *\n- * @internal\n- */\n-static constexpr int32_t DEFAULT_THRESHOLD = 3;\n-\n+// Do not enclose entire SymbolsWrapper with #ifndef U_HIDE_INTERNAL_API, needed for a protected field\n /** @internal */\n class U_I18N_API SymbolsWrapper : public UMemory {\n   public:\n@@ -1155,6 +1249,7 @@ class U_I18N_API SymbolsWrapper : public UMemory {\n     /** @internal */\n     SymbolsWrapper &operator=(const SymbolsWrapper &other);\n \n+#ifndef U_HIDE_INTERNAL_API\n     /**\n      * The provided object is copied, but we do not adopt it.\n      * @internal\n@@ -1202,6 +1297,7 @@ class U_I18N_API SymbolsWrapper : public UMemory {\n         }\n         return FALSE;\n     }\n+#endif  // U_HIDE_INTERNAL_API\n \n   private:\n     enum SymbolsPointerType {\n@@ -1218,14 +1314,72 @@ class U_I18N_API SymbolsWrapper : public UMemory {\n     void doCleanup();\n };\n \n+// Do not enclose entire Grouper with #ifndef U_HIDE_INTERNAL_API, needed for a protected field\n+/** @internal */\n+class U_I18N_API Grouper : public UMemory {\n+  public:\n+#ifndef U_HIDE_INTERNAL_API\n+    /** @internal */\n+    static Grouper forStrategy(UGroupingStrategy grouping);\n+\n+    // Future: static Grouper forProperties(DecimalFormatProperties& properties);\n+\n+    /** @internal */\n+    Grouper(int16_t grouping1, int16_t grouping2, int16_t minGrouping)\n+            : fGrouping1(grouping1), fGrouping2(grouping2), fMinGrouping(minGrouping) {}\n+#endif  // U_HIDE_INTERNAL_API\n+\n+  private:\n+    /**\n+     * The grouping sizes, with the following special values:\n+     * <ul>\n+     * <li>-1 = no grouping\n+     * <li>-2 = needs locale data\n+     * <li>-4 = fall back to Western grouping if not in locale\n+     * </ul>\n+     */\n+    int16_t fGrouping1;\n+    int16_t fGrouping2;\n+\n+    /**\n+     * The minimum gropuing size, with the following special values:\n+     * <ul>\n+     * <li>-2 = needs locale data\n+     * <li>-3 = no less than 2\n+     * </ul>\n+     */\n+    int16_t fMinGrouping;\n+\n+    Grouper() : fGrouping1(-3) {};\n+\n+    bool isBogus() const {\n+        return fGrouping1 == -3;\n+    }\n+\n+    /** NON-CONST: mutates the current instance. */\n+    void setLocaleData(const impl::ParsedPatternInfo &patternInfo, const Locale& locale);\n+\n+    bool groupAtPosition(int32_t position, const impl::DecimalQuantity &value) const;\n+\n+    // To allow MacroProps/MicroProps to initialize empty instances:\n+    friend struct MacroProps;\n+    friend struct MicroProps;\n+\n+    // To allow NumberFormatterImpl to access isBogus() and perform other operations:\n+    friend class NumberFormatterImpl;\n+};\n+\n+// Do not enclose entire Padder with #ifndef U_HIDE_INTERNAL_API, needed for a protected field\n /** @internal */\n class U_I18N_API Padder : public UMemory {\n   public:\n+#ifndef U_HIDE_INTERNAL_API\n     /** @internal */\n     static Padder none();\n \n     /** @internal */\n     static Padder codePoints(UChar32 cp, int32_t targetWidth, UNumberFormatPadPosition position);\n+#endif  // U_HIDE_INTERNAL_API\n \n   private:\n     UChar32 fWidth;  // -3 = error; -2 = bogus; -1 = no padding\n@@ -1275,6 +1429,7 @@ class U_I18N_API Padder : public UMemory {\n     friend class impl::NumberFormatterImpl;\n };\n \n+// Do not enclose entire MacroProps with #ifndef U_HIDE_INTERNAL_API, needed for a protected field\n /** @internal */\n struct U_I18N_API MacroProps : public UMemory {\n     /** @internal */\n@@ -1283,6 +1438,9 @@ struct U_I18N_API MacroProps : public UMemory {\n     /** @internal */\n     MeasureUnit unit; // = NoUnit::base();\n \n+    /** @internal */\n+    MeasureUnit perUnit; // = NoUnit::base();\n+\n     /** @internal */\n     Rounder rounder;  // = Rounder();  (bogus)\n \n@@ -1375,29 +1533,30 @@ class U_I18N_API NumberFormatterSettings {\n      * <li>Percent: \"12.3%\"\n      * </ul>\n      *\n-     * <p>\n      * All units will be properly localized with locale data, and all units are compatible with notation styles,\n      * rounding strategies, and other number formatter settings.\n      *\n-     * <p>\n-     * Pass this method any instance of {@link MeasureUnit}. For units of measure:\n+     * Pass this method any instance of {@link MeasureUnit}. For units of measure (which often involve the\n+     * factory methods that return a pointer):\n      *\n      * <pre>\n-     * NumberFormatter.with().adoptUnit(MeasureUnit::createMeter(status))\n+     * NumberFormatter::with().adoptUnit(MeasureUnit::createMeter(status))\n      * </pre>\n      *\n      * Currency:\n      *\n      * <pre>\n-     * NumberFormatter.with()::unit(CurrencyUnit(u\"USD\", status))\n+     * NumberFormatter::with().unit(CurrencyUnit(u\"USD\", status))\n      * </pre>\n      *\n      * Percent:\n      *\n      * <pre>\n-     * NumberFormatter.with()::unit(NoUnit.percent())\n+     * NumberFormatter::with().unit(NoUnit.percent())\n      * </pre>\n      *\n+     * See {@link #perUnit} for information on how to format strings like \"5 meters per second\".\n+     *\n      * The default is to render without units (equivalent to NoUnit.base()).\n      *\n      * @param unit\n@@ -1406,22 +1565,65 @@ class U_I18N_API NumberFormatterSettings {\n      * @see MeasureUnit\n      * @see Currency\n      * @see NoUnit\n+     * @see #perUnit\n      * @draft ICU 60\n      */\n     Derived unit(const icu::MeasureUnit &unit) const;\n \n     /**\n      * Like unit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory\n-     * methods, which return pointers that need ownership.\n+     * methods, which return pointers that need ownership.  Example:\n+     *\n+     * <pre>\n+     * NumberFormatter::with().adoptUnit(MeasureUnit::createMeter(status))\n+     * </pre>\n      *\n      * @param unit\n-     * The unit to render.\n+     *            The unit to render.\n      * @return The fluent chain.\n      * @see #unit\n      * @see MeasureUnit\n      * @draft ICU 60\n      */\n-    Derived adoptUnit(const icu::MeasureUnit *unit) const;\n+    Derived adoptUnit(icu::MeasureUnit *unit) const;\n+\n+    /**\n+     * Sets a unit to be used in the denominator. For example, to format \"3 m/s\", pass METER to the unit and SECOND to\n+     * the perUnit.\n+     *\n+     * Pass this method any instance of {@link MeasureUnit}.  Since MeasureUnit factory methods return pointers, the\n+     * {@link #adoptPerUnit} version of this method is often more useful.\n+     *\n+     * The default is not to display any unit in the denominator.\n+     *\n+     * If a per-unit is specified without a primary unit via {@link #unit}, the behavior is undefined.\n+     *\n+     * @param perUnit\n+     *            The unit to render in the denominator.\n+     * @return The fluent chain\n+     * @see #unit\n+     * @draft ICU 61\n+     */\n+    Derived perUnit(const icu::MeasureUnit &perUnit) const;\n+\n+    /**\n+     * Like perUnit(), but takes ownership of a pointer.  Convenient for use with the MeasureFormat factory\n+     * methods, which return pointers that need ownership.  Example:\n+     *\n+     * <pre>\n+     * NumberFormatter::with()\n+     *      .adoptUnit(MeasureUnit::createMeter(status))\n+     *      .adoptPerUnit(MeasureUnit::createSecond(status))\n+     * </pre>\n+     *\n+     * @param perUnit\n+     *            The unit to render in the denominator.\n+     * @return The fluent chain.\n+     * @see #perUnit\n+     * @see MeasureUnit\n+     * @draft ICU 61\n+     */\n+    Derived adoptPerUnit(icu::MeasureUnit *perUnit) const;\n \n     /**\n      * Specifies the rounding strategy to use when formatting numbers.\n@@ -1456,8 +1658,6 @@ class U_I18N_API NumberFormatterSettings {\n      */\n     Derived rounding(const Rounder &rounder) const;\n \n-#ifndef U_HIDE_INTERNAL_API\n-\n     /**\n      * Specifies the grouping strategy to use when formatting numbers.\n      *\n@@ -1471,25 +1671,21 @@ class U_I18N_API NumberFormatterSettings {\n      * The exact grouping widths will be chosen based on the locale.\n      *\n      * <p>\n-     * Pass this method the return value of one of the factory methods on {@link Grouper}. For example:\n+     * Pass this method an element from the {@link UGroupingStrategy} enum. For example:\n      *\n      * <pre>\n-     * NumberFormatter::with().grouping(Grouper::min2())\n+     * NumberFormatter::with().grouping(UNUM_GROUPING_MIN2)\n      * </pre>\n      *\n-     * The default is to perform grouping without concern for the minimum grouping digits.\n+     * The default is to perform grouping according to locale data; most locales, but not all locales,\n+     * enable it by default.\n      *\n-     * @param grouper\n+     * @param strategy\n      *            The grouping strategy to use.\n      * @return The fluent chain.\n-     * @see Grouper\n-     * @see Notation\n-     * @internal\n-     * @internal ICU 60: This API is technical preview.\n+     * @draft ICU 61\n      */\n-    Derived grouping(const Grouper &grouper) const;\n-\n-#endif  /* U_HIDE_INTERNAL_API */\n+    Derived grouping(const UGroupingStrategy &strategy) const;\n \n     /**\n      * Specifies the minimum and maximum number of digits to render before the decimal mark.\n@@ -1592,7 +1788,7 @@ class U_I18N_API NumberFormatterSettings {\n      * @see NumberingSystem\n      * @draft ICU 60\n      */\n-    Derived adoptSymbols(const NumberingSystem *symbols) const;\n+    Derived adoptSymbols(NumberingSystem *symbols) const;\n \n     /**\n      * Sets the width of the unit (measure unit or currency).  Most common values:"
        },
        {
            "sha": "1332f5256628e37ddde2196d8e73f98aa46e0579",
            "filename": "deps/icu-small/source/i18n/unicode/numfmt.h",
            "status": "modified",
            "additions": 32,
            "deletions": 5,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumfmt.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -28,7 +28,7 @@\n \n /**\n  * \\file\n- * \\brief C++ API: Abstract base class for all number formats.\n+ * \\brief C++ API: Compatibility APIs for number formatting.\n  */\n \n #if !UCONFIG_NO_FORMATTING\n@@ -53,16 +53,16 @@ class StringEnumeration;\n #endif\n \n /**\n+ * <p><strong>IMPORTANT:</strong> New users are strongly encouraged to see if\n+ * numberformatter.h fits their use case.  Although not deprecated, this header\n+ * is provided for backwards compatibility only.\n+ * <hr/>\n  *\n  * Abstract base class for all number formats.  Provides interface for\n  * formatting and parsing a number.  Also provides methods for\n  * determining which locales have number formats, and what their names\n  * are.\n  *\n- * <p><strong>NOTE:</strong> Starting in ICU 60, there is a new set of APIs for localized number\n- * formatting that are designed to be an improvement over DecimalFormat.  New users are discouraged\n- * from using DecimalFormat.  For more information, see numberformatter.h.\n- *\n  * \\headerfile unicode/numfmt.h \"unicode/numfmt.h\"\n  * <P>\n  * NumberFormat helps you to format and parse numbers for any locale.\n@@ -708,6 +708,9 @@ class U_I18N_API NumberFormat : public Format {\n     /**\n      * Create a default style NumberFormat for the current default locale.\n      * The default formatting style is locale dependent.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @stable ICU 2.0\n      */\n     static NumberFormat* U_EXPORT2 createInstance(UErrorCode&);\n@@ -716,13 +719,19 @@ class U_I18N_API NumberFormat : public Format {\n      * Create a default style NumberFormat for the specified locale.\n      * The default formatting style is locale dependent.\n      * @param inLocale    the given locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @stable ICU 2.0\n      */\n     static NumberFormat* U_EXPORT2 createInstance(const Locale& inLocale,\n                                         UErrorCode&);\n \n     /**\n      * Create a specific style NumberFormat for the specified locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @param desiredLocale    the given locale.\n      * @param style            the given style.\n      * @param errorCode        Output param filled with success/failure status.\n@@ -759,12 +768,18 @@ class U_I18N_API NumberFormat : public Format {\n \n     /**\n      * Returns a currency format for the current default locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @stable ICU 2.0\n      */\n     static NumberFormat* U_EXPORT2 createCurrencyInstance(UErrorCode&);\n \n     /**\n      * Returns a currency format for the specified locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @param inLocale    the given locale.\n      * @stable ICU 2.0\n      */\n@@ -773,12 +788,18 @@ class U_I18N_API NumberFormat : public Format {\n \n     /**\n      * Returns a percentage format for the current default locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @stable ICU 2.0\n      */\n     static NumberFormat* U_EXPORT2 createPercentInstance(UErrorCode&);\n \n     /**\n      * Returns a percentage format for the specified locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @param inLocale    the given locale.\n      * @stable ICU 2.0\n      */\n@@ -787,12 +808,18 @@ class U_I18N_API NumberFormat : public Format {\n \n     /**\n      * Returns a scientific format for the current default locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @stable ICU 2.0\n      */\n     static NumberFormat* U_EXPORT2 createScientificInstance(UErrorCode&);\n \n     /**\n      * Returns a scientific format for the specified locale.\n+     * <p>\n+     * <strong>NOTE:</strong> New users are strongly encouraged to use\n+     * {@link NumberFormatter} instead of NumberFormat.\n      * @param inLocale    the given locale.\n      * @stable ICU 2.0\n      */"
        },
        {
            "sha": "7f5f1664cca503562e22a7eb7a7cd8b973d2bd50",
            "filename": "deps/icu-small/source/i18n/unicode/simpletz.h",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fsimpletz.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fsimpletz.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fsimpletz.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -647,7 +647,8 @@ class U_I18N_API SimpleTimeZone: public BasicTimeZone {\n      * Sets the amount of time in ms that the clock is advanced during DST.\n      * @param millisSavedDuringDST the number of milliseconds the time is\n      * advanced with respect to standard time when the daylight savings rules\n-     * are in effect. A positive number, typically one hour (3600000).\n+     * are in effect. Typically one hour (+3600000). The amount could be negative,\n+     * but not 0.\n      * @param status  An UErrorCode to receive the status.\n      * @stable ICU 2.0\n      */\n@@ -657,7 +658,8 @@ class U_I18N_API SimpleTimeZone: public BasicTimeZone {\n      * Returns the amount of time in ms that the clock is advanced during DST.\n      * @return the number of milliseconds the time is\n      * advanced with respect to standard time when the daylight savings rules\n-     * are in effect. A positive number, typically one hour (3600000).\n+     * are in effect. Typically one hour (+3600000). The amount could be negative,\n+     * but not 0.\n      * @stable ICU 2.0\n      */\n     virtual int32_t getDSTSavings(void) const;"
        },
        {
            "sha": "54f1254346d10d868e74418da98aeb31876efc37",
            "filename": "deps/icu-small/source/i18n/unicode/udatpg.h",
            "status": "modified",
            "additions": 52,
            "deletions": 1,
            "changes": 53,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fudatpg.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fudatpg.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fudatpg.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -95,6 +95,21 @@ typedef enum UDateTimePatternField {\n     UDATPG_FIELD_COUNT\n } UDateTimePatternField;\n \n+#ifndef U_HIDE_DRAFT_API\n+/**\n+ * Field display name width constants for udatpg_getFieldDisplayName().\n+ * @draft ICU 61\n+ */\n+typedef enum UDateTimePGDisplayWidth {\n+    /** @draft ICU 61 */\n+    UDATPG_WIDE,\n+    /** @draft ICU 61 */\n+    UDATPG_ABBREVIATED,\n+    /** @draft ICU 61 */\n+    UDATPG_NARROW\n+} UDateTimePGDisplayWidth;\n+#endif  // U_HIDE_DRAFT_API\n+\n /**\n  * Masks to control forcing the length of specified fields in the returned\n  * pattern to match those in the skeleton (when this would not happen\n@@ -410,19 +425,55 @@ udatpg_setAppendItemName(UDateTimePatternGenerator *dtpg,\n \n /**\n  * Getter corresponding to setAppendItemNames. Values below 0 or at or above\n- * UDATPG_FIELD_COUNT are illegal arguments.\n+ * UDATPG_FIELD_COUNT are illegal arguments. Note: The more general function\n+ * for getting date/time field display names is udatpg_getFieldDisplayName.\n  *\n  * @param dtpg   a pointer to UDateTimePatternGenerator.\n  * @param field  UDateTimePatternField, such as UDATPG_ERA_FIELD\n  * @param pLength A pointer that will receive the length of the name for field.\n  * @return name for field\n+ * @see udatpg_getFieldDisplayName\n  * @stable ICU 3.8\n  */\n U_STABLE const UChar * U_EXPORT2\n udatpg_getAppendItemName(const UDateTimePatternGenerator *dtpg,\n                          UDateTimePatternField field,\n                          int32_t *pLength);\n \n+#ifndef U_HIDE_DRAFT_API\n+/**\n+ * The general interface to get a display name for a particular date/time field,\n+ * in one of several possible display widths.\n+ *\n+ * @param dtpg\n+ *          A pointer to the UDateTimePatternGenerator object with the localized\n+ *          display names.\n+ * @param field\n+ *          The desired UDateTimePatternField, such as UDATPG_ERA_FIELD.\n+ * @param width\n+ *          The desired UDateTimePGDisplayWidth, such as UDATPG_ABBREVIATED.\n+ * @param fieldName\n+ *          A pointer to a buffer to receive the NULL-terminated display name. If the name\n+ *          fits into fieldName but cannot be  NULL-terminated (length == capacity) then\n+ *          the error code is set to U_STRING_NOT_TERMINATED_WARNING. If the name doesn't\n+ *          fit into fieldName then the error code is set to U_BUFFER_OVERFLOW_ERROR.\n+ * @param capacity\n+ *          The size of fieldName (in UChars).\n+ * @param pErrorCode\n+ *          A pointer to a UErrorCode to receive any errors\n+ * @return\n+ *         The full length of the name; if greater than capacity, fieldName contains a\n+ *         truncated result.\n+ * @draft ICU 61\n+ */\n+U_DRAFT int32_t U_EXPORT2\n+udatpg_getFieldDisplayName(const UDateTimePatternGenerator *dtpg,\n+                           UDateTimePatternField field,\n+                           UDateTimePGDisplayWidth width,\n+                           UChar *fieldName, int32_t capacity,\n+                           UErrorCode *pErrorCode);\n+#endif  // U_HIDE_DRAFT_API\n+\n /**\n  * The DateTimeFormat is a message format pattern used to compose date and\n  * time patterns. The default pattern in the root locale is \"{1} {0}\", where"
        },
        {
            "sha": "0e7b9fffbab2b258203c00b583e370fe056d51df",
            "filename": "deps/icu-small/source/i18n/unicode/unum.h",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Funum.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Funum.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Funum.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -33,6 +33,9 @@\n  *\n  * <h2> Number Format C API </h2>\n  *\n+ * <p><strong>IMPORTANT:</strong> New users with C++ capabilities are\n+ * strongly encouraged to see if numberformatter.h fits their use case.\n+ *\n  * Number Format C API  Provides functions for\n  * formatting and parsing a number.  Also provides methods for\n  * determining which locales have number formats, and what their names\n@@ -559,7 +562,6 @@ unum_formatDouble(    const    UNumberFormat*  fmt,\n             UFieldPosition  *pos, /* 0 if ignore */\n             UErrorCode*     status);\n \n-#ifndef U_HIDE_DRAFT_API\n /**\n * Format a double using a UNumberFormat according to the UNumberFormat's locale,\n * and initialize a UFieldPositionIterator that enumerates the subcomponents of\n@@ -600,17 +602,16 @@ unum_formatDouble(    const    UNumberFormat*  fmt,\n * @see unum_parseDouble\n * @see UFieldPositionIterator\n * @see UNumberFormatFields\n-* @draft ICU 59\n+* @stable ICU 59\n */\n-U_DRAFT int32_t U_EXPORT2\n+U_STABLE int32_t U_EXPORT2\n unum_formatDoubleForFields(const UNumberFormat* format,\n                            double number,\n                            UChar* result,\n                            int32_t resultLength,\n                            UFieldPositionIterator* fpositer,\n                            UErrorCode* status);\n \n-#endif  /* U_HIDE_DRAFT_API */\n \n /**\n * Format a decimal number using a UNumberFormat."
        },
        {
            "sha": "690846bc89cd013a49ba9eeb3146066e734ebd41",
            "filename": "deps/icu-small/source/i18n/unicode/upluralrules.h",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fupluralrules.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fupluralrules.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fupluralrules.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -175,7 +175,6 @@ uplrules_selectWithFormat(const UPluralRules *uplrules,\n \n #endif  /* U_HIDE_INTERNAL_API */\n \n-#ifndef U_HIDE_DRAFT_API\n /**\n  * Creates a string enumeration of all plural rule keywords used in this\n  * UPluralRules object. The rule \"other\" is always present by default.\n@@ -184,12 +183,11 @@ uplrules_selectWithFormat(const UPluralRules *uplrules,\n  * @param status A pointer to a UErrorCode to receive any errors.\n  * @return a string enumeration over plural rule keywords, or NULL\n  * upon error. The caller is responsible for closing the result.\n- * @draft ICU 59\n+ * @stable ICU 59\n  */\n-U_DRAFT UEnumeration* U_EXPORT2\n+U_STABLE UEnumeration* U_EXPORT2\n uplrules_getKeywords(const UPluralRules *uplrules,\n                      UErrorCode *status);\n-#endif  /* U_HIDE_DRAFT_API */\n \n #endif /* #if !UCONFIG_NO_FORMATTING */\n "
        },
        {
            "sha": "7672b4428fba3cd6f632c1557d012c0d7486a88f",
            "filename": "deps/icu-small/source/i18n/unicode/utrans.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Futrans.h",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Futrans.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Futrans.h?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -382,7 +382,7 @@ utrans_openIDs(UErrorCode *pErrorCode);\n U_STABLE void U_EXPORT2\n utrans_trans(const UTransliterator* trans,\n              UReplaceable* rep,\n-             UReplaceableCallbacks* repFunc,\n+             const UReplaceableCallbacks* repFunc,\n              int32_t start,\n              int32_t* limit,\n              UErrorCode* status);\n@@ -433,7 +433,7 @@ utrans_trans(const UTransliterator* trans,\n U_STABLE void U_EXPORT2\n utrans_transIncremental(const UTransliterator* trans,\n                         UReplaceable* rep,\n-                        UReplaceableCallbacks* repFunc,\n+                        const UReplaceableCallbacks* repFunc,\n                         UTransPosition* pos,\n                         UErrorCode* status);\n "
        },
        {
            "sha": "370384363483e741c712243aadeff22c07a7c596",
            "filename": "deps/icu-small/source/i18n/uregex.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Furegex.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Furegex.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Furegex.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -1465,8 +1465,10 @@ int32_t RegexCImpl::appendReplacement(RegularExpression    *regexp,\n \n         int32_t groupNum  = 0;\n         U_ASSERT(c == DOLLARSIGN);\n-        UChar32 c32;\n-        U16_GET(replacementText, 0, replIdx, replacementLength, c32);\n+        UChar32 c32 = -1;\n+        if (replIdx < replacementLength) {\n+            U16_GET(replacementText, 0, replIdx, replacementLength, c32);\n+        }\n         if (u_isdigit(c32)) {\n             int32_t numDigits = 0;\n             int32_t numCaptureGroups = m->fPattern->fGroupMap->size();"
        },
        {
            "sha": "31070dd43fbe4ed6f1ed626953cefc275934120c",
            "filename": "deps/icu-small/source/i18n/utrans.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Futrans.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Fi18n%2Futrans.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Futrans.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -41,12 +41,12 @@ U_NAMESPACE_BEGIN\n class ReplaceableGlue : public Replaceable {\n \n     UReplaceable *rep;\n-    UReplaceableCallbacks *func;\n+    const UReplaceableCallbacks *func;\n \n public:\n \n     ReplaceableGlue(UReplaceable *replaceable,\n-                    UReplaceableCallbacks *funcCallback);\n+                    const UReplaceableCallbacks *funcCallback);\n \n     virtual ~ReplaceableGlue();\n \n@@ -88,7 +88,7 @@ class ReplaceableGlue : public Replaceable {\n UOBJECT_DEFINE_RTTI_IMPLEMENTATION(ReplaceableGlue)\n \n ReplaceableGlue::ReplaceableGlue(UReplaceable *replaceable,\n-                                 UReplaceableCallbacks *funcCallback)\n+                                 const UReplaceableCallbacks *funcCallback)\n   : Replaceable()\n {\n     this->rep = replaceable;\n@@ -398,7 +398,7 @@ utrans_openIDs(UErrorCode *pErrorCode) {\n U_CAPI void U_EXPORT2\n utrans_trans(const UTransliterator* trans,\n              UReplaceable* rep,\n-             UReplaceableCallbacks* repFunc,\n+             const UReplaceableCallbacks* repFunc,\n              int32_t start,\n              int32_t* limit,\n              UErrorCode* status) {\n@@ -418,7 +418,7 @@ utrans_trans(const UTransliterator* trans,\n U_CAPI void U_EXPORT2\n utrans_transIncremental(const UTransliterator* trans,\n                         UReplaceable* rep,\n-                        UReplaceableCallbacks* repFunc,\n+                        const UReplaceableCallbacks* repFunc,\n                         UTransPosition* pos,\n                         UErrorCode* status) {\n "
        },
        {
            "sha": "f51a86ea96fc1b805b3083d7fa36246ee3a05595",
            "filename": "deps/icu-small/source/tools/escapesrc/escapesrc.cpp",
            "status": "modified",
            "additions": 77,
            "deletions": 61,
            "changes": 138,
            "blob_url": "https://github.com/nodejs/node/blob/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Ftools%2Fescapesrc%2Fescapesrc.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/64211405dab824a570e52d000891c49415cc42b8/deps%2Ficu-small%2Fsource%2Ftools%2Fescapesrc%2Fescapesrc.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Fescapesrc%2Fescapesrc.cpp?ref=64211405dab824a570e52d000891c49415cc42b8",
            "patch": "@@ -4,64 +4,92 @@\n #include <stdio.h>\n #include <string>\n #include <stdlib.h>\n-#include <unistd.h>\n #include <errno.h>\n #include <string.h>\n #include <iostream>\n #include <fstream>\n \n-// with caution:\n+// We only use U8_* macros, which are entirely inline.\n #include \"unicode/utf8.h\"\n \n+// This contains a codepage and ISO 14882:1998 illegality table.\n+// Use \"make gen-table\" to rebuild it.\n+#include \"cptbl.h\"\n+\n+/**\n+ * What is this?\n+ *\n+ * \"This\" is a preprocessor that makes an attempt to convert fully valid C++11 source code\n+ * in utf-8 into something consumable by certain compilers (Solaris, xlC)\n+ * which aren't quite standards compliant.\n+ *\n+ * - u\"<unicode>\" or u'<unicode>' gets converted to u\"\\uNNNN\" or u'\\uNNNN'\n+ * - u8\"<unicode>\" gets converted to \"\\xAA\\xBB\\xCC\\xDD\" etc.\n+ *   (some compilers do not support the u8 prefix correctly.)\n+ * - if the system is EBCDIC-based, that is used to correct the input characters.\n+ *\n+ * Usage:\n+ *   escapesrc infile.cpp outfile.cpp\n+ * Normally this is invoked by the build stage, with a rule such as:\n+ *\n+ * _%.cpp: $(srcdir)/%.cpp\n+ *       @$(BINDIR)/escapesrc$(EXEEXT) $< $@\n+ * %.o: _%.cpp\n+ *       $(COMPILE.cc) ... $@ $<\n+ *\n+ * In the Makefiles, SKIP_ESCAPING=YES is used to prevent escapesrc.cpp\n+ * from being itself escaped.\n+ */\n+\n+\n static const char\n   kSPACE   = 0x20,\n   kTAB     = 0x09,\n   kLF      = 0x0A,\n   kCR      = 0x0D;\n-  // kHASH    = 0x23,\n-  // kSLASH   = 0x2f,\n-  // kSTAR    = 0x2A,\n-\n-# include \"cptbl.h\"\n \n+// For convenience\n # define cp1047_to_8859(c) cp1047_8859_1[c]\n \n+// Our app's name\n std::string prog;\n \n+/**\n+ * Give the usual 1-line documentation and exit\n+ */\n void usage() {\n   fprintf(stderr, \"%s: usage: %s infile.cpp outfile.cpp\\n\", prog.c_str(), prog.c_str());\n }\n \n-\n+/**\n+ * Delete the output file (if any)\n+ * We want to delete even if we didn't generate, because it might be stale.\n+ */\n int cleanup(const std::string &outfile) {\n   const char *outstr = outfile.c_str();\n   if(outstr && *outstr) {\n-    int rc = unlink(outstr);\n+    int rc = std::remove(outstr);\n     if(rc == 0) {\n       fprintf(stderr, \"%s: deleted %s\\n\", prog.c_str(), outstr);\n       return 0;\n     } else {\n       if( errno == ENOENT ) {\n         return 0; // File did not exist - no error.\n       } else {\n-        perror(\"unlink\");\n+        perror(\"std::remove\");\n         return 1;\n       }\n     }\n   }\n   return 0;\n }\n \n-// inline bool hasNonAscii(const char *line, size_t len) {\n-//   const unsigned char *uline = reinterpret_cast<const unsigned char*>(line);\n-//   for(size_t i=0;i<len; i++) {\n-//     if( uline[i] > 0x7F) {\n-//       return true;\n-//     }\n-//   }\n-//   return false;\n-// }\n-\n+/**\n+ * Skip across any known whitespace.\n+ * @param p startpoint\n+ * @param e limit\n+ * @return first non-whitespace char\n+ */\n inline const char *skipws(const char *p, const char *e) {\n   for(;p<e;p++) {\n     switch(*p) {\n@@ -77,30 +105,11 @@ inline const char *skipws(const char *p, const char *e) {\n   return p;\n }\n \n-// inline bool isCommentOrEmpty(const char* line, size_t len) {\n-//   const char *p = line;\n-//   const char *e = line+len;\n-//   p = skipws(p,e);\n-//   if(p==e) {\n-//     return true; // whitespace only\n-//   }\n-//   p++;\n-//   switch(*p) {\n-//   case kHASH: return true; // #directive\n-//   case kSLASH:\n-//     p++;\n-//     if(p==e) return false; // single slash\n-//     switch(*p) {\n-//     case kSLASH: // '/ /'\n-//     case kSTAR: // '/ *'\n-//       return true; // start of comment\n-//     default: return false; // something else\n-//     }\n-//   default: return false; // something else\n-//   }\n-//   /*NOTREACHED*/\n-// }\n-\n+/**\n+ * Append a byte, hex encoded\n+ * @param outstr sstring to append to\n+ * @param byte the byte to append\n+ */\n void appendByte(std::string &outstr,\n                 uint8_t byte) {\n     char tmp2[5];\n@@ -109,6 +118,11 @@ void appendByte(std::string &outstr,\n }\n \n /**\n+ * Append the bytes from 'linestr' into outstr, with escaping\n+ * @param outstr the output buffer\n+ * @param linestr the input buffer\n+ * @param pos in/out: the current char under consideration\n+ * @param chars the number of chars to consider\n  * @return true on failure\n  */\n bool appendUtf8(std::string &outstr,\n@@ -141,6 +155,7 @@ bool appendUtf8(std::string &outstr,\n }\n \n /**\n+ * Fixup u8\"x\"\n  * @param linestr string to mutate. Already escaped into \\u format.\n  * @param origpos beginning, points to 'u8\"'\n  * @param pos end, points to \"\n@@ -184,9 +199,11 @@ bool fixu8(std::string &linestr, size_t origpos, size_t &endpos) {\n }\n \n /**\n- * fix the string at the position\n- * false = no err\n- * true = had err\n+ * fix the u\"x\"/u'x'/u8\"x\" string at the position\n+ * u8'x' is not supported, sorry.\n+ * @param linestr the input string\n+ * @param pos the position\n+ * @return false = no err, true = had err\n  */\n bool fixAt(std::string &linestr, size_t pos) {\n   size_t origpos = pos;\n@@ -292,8 +309,12 @@ bool fixAt(std::string &linestr, size_t pos) {\n }\n \n /**\n+ * Fixup an entire line\n  * false = no err\n  * true = had err\n+ * @param no the line number (not used)\n+ * @param linestr the string to fix\n+ * @return true if any err, else false\n  */\n bool fixLine(int /*no*/, std::string &linestr) {\n   const char *line = linestr.c_str();\n@@ -304,17 +325,6 @@ bool fixLine(int /*no*/, std::string &linestr) {\n     return false; // Nothing to do. No u' or u\" detected\n   }\n \n-  // lines such as u8\"\\u0308\" are all ASCII.\n-  // // Quick Check: all ascii?\n-  // if(!hasNonAscii(line, len)) {\n-  //   return false; // ASCII\n-  // }\n-\n-  // // comment or empty line?\n-  // if(isCommentOrEmpty(line, len)) {\n-  //   return false; // Comment or just empty\n-  // }\n-\n   // start from the end and find all u\" cases\n   size_t pos = len = linestr.size();\n   while((pos>0) && (pos = linestr.rfind(\"u\\\"\", pos)) != std::string::npos) {\n@@ -345,6 +355,12 @@ bool fixLine(int /*no*/, std::string &linestr) {\n   return false;\n }\n \n+/**\n+ * Convert a whole file\n+ * @param infile\n+ * @param outfile\n+ * @return 1 on err, 0 otherwise\n+ */\n int convert(const std::string &infile, const std::string &outfile) {\n   fprintf(stderr, \"escapesrc: %s -> %s\\n\", infile.c_str(), outfile.c_str());\n \n@@ -386,6 +402,9 @@ int convert(const std::string &infile, const std::string &outfile) {\n   return 0;\n }\n \n+/**\n+ * Main function\n+ */\n int main(int argc, const char *argv[]) {\n   prog = argv[0];\n \n@@ -399,6 +418,3 @@ int main(int argc, const char *argv[]) {\n \n   return convert(infile, outfile);\n }\n-\n-\n-#include \"utf_impl.cpp\""
        }
    ],
    "stats": {
        "total": 10970,
        "additions": 8959,
        "deletions": 2011
    }
}