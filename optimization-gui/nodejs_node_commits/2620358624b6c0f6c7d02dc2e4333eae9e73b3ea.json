{
    "author": "targos",
    "message": "fs: move utility functions to internal/fs\n\nPR-URL: https://github.com/nodejs/node/pull/18777\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "2620358624b6c0f6c7d02dc2e4333eae9e73b3ea",
    "files": [
        {
            "sha": "f78703762975b95746d849694faa089ad86336b8",
            "filename": "lib/fs.js",
            "status": "modified",
            "additions": 18,
            "deletions": 291,
            "changes": 309,
            "blob_url": "https://github.com/nodejs/node/blob/2620358624b6c0f6c7d02dc2e4333eae9e73b3ea/lib%2Ffs.js",
            "raw_url": "https://github.com/nodejs/node/raw/2620358624b6c0f6c7d02dc2e4333eae9e73b3ea/lib%2Ffs.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ffs.js?ref=2620358624b6c0f6c7d02dc2e4333eae9e73b3ea",
            "patch": "@@ -37,14 +37,29 @@ const { Buffer } = require('buffer');\n const errors = require('internal/errors');\n const { Readable, Writable } = require('stream');\n const EventEmitter = require('events');\n-const { FSReqWrap } = binding;\n+const { FSReqWrap, statValues } = binding;\n const { FSEvent } = process.binding('fs_event_wrap');\n const internalFS = require('internal/fs');\n const { getPathFromURL } = require('internal/url');\n const internalUtil = require('internal/util');\n const {\n-  assertEncoding,\n-  stringToFlags\n+  copyObject,\n+  getOptions,\n+  isUint32,\n+  modeNum,\n+  nullCheck,\n+  preprocessSymlinkDestination,\n+  Stats,\n+  statsFromValues,\n+  stringToFlags,\n+  stringToSymlinkType,\n+  toUnixTimestamp,\n+  validateBuffer,\n+  validateLen,\n+  validateOffsetLengthRead,\n+  validateOffsetLengthWrite,\n+  validatePath,\n+  validateUint32\n } = internalFS;\n const {\n   CHAR_FORWARD_SLASH,\n@@ -70,9 +85,6 @@ const errnoException = errors.errnoException;\n \n let truncateWarn = true;\n \n-function isInt32(n) { return n === (n | 0); }\n-function isUint32(n) { return n === (n >>> 0); }\n-\n function showTruncateDeprecation() {\n   if (truncateWarn) {\n     process.emitWarning(\n@@ -83,35 +95,6 @@ function showTruncateDeprecation() {\n   }\n }\n \n-function getOptions(options, defaultOptions) {\n-  if (options === null || options === undefined ||\n-      typeof options === 'function') {\n-    return defaultOptions;\n-  }\n-\n-  if (typeof options === 'string') {\n-    defaultOptions = util._extend({}, defaultOptions);\n-    defaultOptions.encoding = options;\n-    options = defaultOptions;\n-  } else if (typeof options !== 'object') {\n-    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n-                               'options',\n-                               ['string', 'Object'],\n-                               options);\n-  }\n-\n-  if (options.encoding !== 'buffer')\n-    assertEncoding(options.encoding);\n-  return options;\n-}\n-\n-function copyObject(source) {\n-  var target = {};\n-  for (var key in source)\n-    target[key] = source[key];\n-  return target;\n-}\n-\n function handleErrorFromBinding(ctx) {\n   if (ctx.errno !== undefined) {  // libuv error numbers\n     const err = errors.uvException(ctx);\n@@ -175,117 +158,6 @@ function makeCallback(cb) {\n   };\n }\n \n-function validateBuffer(buffer) {\n-  if (!isUint8Array(buffer)) {\n-    const err = new errors.TypeError('ERR_INVALID_ARG_TYPE', 'buffer',\n-                                     ['Buffer', 'Uint8Array']);\n-    Error.captureStackTrace(err, validateBuffer);\n-    throw err;\n-  }\n-}\n-\n-function validateLen(len) {\n-  let err;\n-\n-  if (!isInt32(len))\n-    err = new errors.TypeError('ERR_INVALID_ARG_TYPE', 'len', 'integer');\n-\n-  if (err !== undefined) {\n-    Error.captureStackTrace(err, validateLen);\n-    throw err;\n-  }\n-}\n-\n-function validateOffsetLengthRead(offset, length, bufferLength) {\n-  let err;\n-\n-  if (offset < 0 || offset >= bufferLength) {\n-    err = new errors.RangeError('ERR_OUT_OF_RANGE', 'offset');\n-  } else if (length < 0 || offset + length > bufferLength) {\n-    err = new errors.RangeError('ERR_OUT_OF_RANGE', 'length');\n-  }\n-\n-  if (err !== undefined) {\n-    Error.captureStackTrace(err, validateOffsetLengthRead);\n-    throw err;\n-  }\n-}\n-\n-function validateOffsetLengthWrite(offset, length, byteLength) {\n-  let err;\n-\n-  if (offset > byteLength) {\n-    err = new errors.RangeError('ERR_OUT_OF_RANGE', 'offset');\n-  } else if (offset + length > byteLength || offset + length > kMaxLength) {\n-    err = new errors.RangeError('ERR_OUT_OF_RANGE', 'length');\n-  }\n-\n-  if (err !== undefined) {\n-    Error.captureStackTrace(err, validateOffsetLengthWrite);\n-    throw err;\n-  }\n-}\n-\n-// Check if the path contains null types if it is a string nor Uint8Array,\n-// otherwise return silently.\n-function nullCheck(path, propName, throwError = true) {\n-  const pathIsString = typeof path === 'string';\n-  const pathIsUint8Array = isUint8Array(path);\n-\n-  // We can only perform meaningful checks on strings and Uint8Arrays.\n-  if (!pathIsString && !pathIsUint8Array) {\n-    return;\n-  }\n-\n-  if (pathIsString && path.indexOf('\\u0000') === -1) {\n-    return;\n-  } else if (pathIsUint8Array && path.indexOf(0) === -1) {\n-    return;\n-  }\n-\n-  const err = new errors.Error(\n-    'ERR_INVALID_ARG_VALUE', propName, path,\n-    'must be a string or Uint8Array without null bytes');\n-\n-  if (throwError) {\n-    Error.captureStackTrace(err, nullCheck);\n-    throw err;\n-  }\n-  return err;\n-}\n-\n-function validatePath(path, propName) {\n-  let err;\n-\n-  if (propName === undefined) {\n-    propName = 'path';\n-  }\n-\n-  if (typeof path !== 'string' && !isUint8Array(path)) {\n-    err = new errors.TypeError('ERR_INVALID_ARG_TYPE', propName,\n-                               ['string', 'Buffer', 'URL']);\n-  } else {\n-    err = nullCheck(path, propName, false);\n-  }\n-\n-  if (err !== undefined) {\n-    Error.captureStackTrace(err, validatePath);\n-    throw err;\n-  }\n-}\n-\n-function validateUint32(value, propName) {\n-  let err;\n-\n-  if (!isUint32(value))\n-    err = new errors.TypeError('ERR_INVALID_ARG_TYPE', propName, 'integer');\n-\n-  if (err !== undefined) {\n-    Error.captureStackTrace(err, validateUint32);\n-    throw err;\n-  }\n-}\n-\n // Special case of `makeCallback()` that is specific to async `*stat()` calls as\n // an optimization, since the data passed back to the callback needs to be\n // transformed anyway.\n@@ -308,85 +180,8 @@ function isFd(path) {\n   return (path >>> 0) === path;\n }\n \n-// Constructor for file stats.\n-function Stats(\n-  dev,\n-  mode,\n-  nlink,\n-  uid,\n-  gid,\n-  rdev,\n-  blksize,\n-  ino,\n-  size,\n-  blocks,\n-  atim_msec,\n-  mtim_msec,\n-  ctim_msec,\n-  birthtim_msec\n-) {\n-  this.dev = dev;\n-  this.mode = mode;\n-  this.nlink = nlink;\n-  this.uid = uid;\n-  this.gid = gid;\n-  this.rdev = rdev;\n-  this.blksize = blksize;\n-  this.ino = ino;\n-  this.size = size;\n-  this.blocks = blocks;\n-  this.atimeMs = atim_msec;\n-  this.mtimeMs = mtim_msec;\n-  this.ctimeMs = ctim_msec;\n-  this.birthtimeMs = birthtim_msec;\n-  this.atime = new Date(atim_msec + 0.5);\n-  this.mtime = new Date(mtim_msec + 0.5);\n-  this.ctime = new Date(ctim_msec + 0.5);\n-  this.birthtime = new Date(birthtim_msec + 0.5);\n-}\n fs.Stats = Stats;\n \n-Stats.prototype._checkModeProperty = function(property) {\n-  return ((this.mode & S_IFMT) === property);\n-};\n-\n-Stats.prototype.isDirectory = function() {\n-  return this._checkModeProperty(constants.S_IFDIR);\n-};\n-\n-Stats.prototype.isFile = function() {\n-  return this._checkModeProperty(S_IFREG);\n-};\n-\n-Stats.prototype.isBlockDevice = function() {\n-  return this._checkModeProperty(constants.S_IFBLK);\n-};\n-\n-Stats.prototype.isCharacterDevice = function() {\n-  return this._checkModeProperty(constants.S_IFCHR);\n-};\n-\n-Stats.prototype.isSymbolicLink = function() {\n-  return this._checkModeProperty(S_IFLNK);\n-};\n-\n-Stats.prototype.isFIFO = function() {\n-  return this._checkModeProperty(S_IFIFO);\n-};\n-\n-Stats.prototype.isSocket = function() {\n-  return this._checkModeProperty(S_IFSOCK);\n-};\n-\n-const statValues = binding.statValues;\n-\n-function statsFromValues(stats = statValues) {\n-  return new Stats(stats[0], stats[1], stats[2], stats[3], stats[4], stats[5],\n-                   stats[6] < 0 ? undefined : stats[6], stats[7], stats[8],\n-                   stats[9] < 0 ? undefined : stats[9], stats[10], stats[11],\n-                   stats[12], stats[13]);\n-}\n-\n // Don't allow mode to accidentally be overwritten.\n Object.defineProperties(fs, {\n   F_OK: { enumerable: true, value: constants.F_OK || 0 },\n@@ -760,16 +555,6 @@ fs.closeSync = function(fd) {\n   handleErrorFromBinding(ctx);\n };\n \n-function modeNum(m, def) {\n-  if (typeof m === 'number')\n-    return m;\n-  if (typeof m === 'string')\n-    return parseInt(m, 8);\n-  if (def)\n-    return modeNum(def);\n-  return undefined;\n-}\n-\n fs.open = function(path, flags, mode, callback_) {\n   var callback = makeCallback(arguments[arguments.length - 1]);\n   mode = modeNum(mode, 0o666);\n@@ -1162,42 +947,6 @@ fs.readlinkSync = function(path, options) {\n   return result;\n };\n \n-function preprocessSymlinkDestination(path, type, linkPath) {\n-  if (!isWindows) {\n-    // No preprocessing is needed on Unix.\n-    return path;\n-  } else if (type === 'junction') {\n-    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n-    // A relative target is relative to the link's parent directory.\n-    path = pathModule.resolve(linkPath, '..', path);\n-    return pathModule.toNamespacedPath(path);\n-  } else {\n-    // Windows symlinks don't tolerate forward slashes.\n-    return ('' + path).replace(/\\//g, '\\\\');\n-  }\n-}\n-\n-function stringToSymlinkType(type) {\n-  let flags = 0;\n-  if (typeof type === 'string') {\n-    switch (type) {\n-      case 'dir':\n-        flags |= constants.UV_FS_SYMLINK_DIR;\n-        break;\n-      case 'junction':\n-        flags |= constants.UV_FS_SYMLINK_JUNCTION;\n-        break;\n-      case 'file':\n-        break;\n-      default:\n-        const err = new errors.Error('ERR_FS_INVALID_SYMLINK_TYPE', type);\n-        Error.captureStackTrace(err, stringToSymlinkType);\n-        throw err;\n-    }\n-  }\n-  return flags;\n-}\n-\n fs.symlink = function(target, path, type_, callback_) {\n   var type = (typeof type_ === 'string' ? type_ : null);\n   var callback = makeCallback(arguments[arguments.length - 1]);\n@@ -1421,28 +1170,6 @@ fs.chownSync = function(path, uid, gid) {\n   return binding.chown(pathModule.toNamespacedPath(path), uid, gid);\n };\n \n-// converts Date or number to a fractional UNIX timestamp\n-function toUnixTimestamp(time, name = 'time') {\n-  // eslint-disable-next-line eqeqeq\n-  if (typeof time === 'string' && +time == time) {\n-    return +time;\n-  }\n-  if (Number.isFinite(time)) {\n-    if (time < 0) {\n-      return Date.now() / 1000;\n-    }\n-    return time;\n-  }\n-  if (util.isDate(time)) {\n-    // convert to 123.456 UNIX timestamp\n-    return time.getTime() / 1000;\n-  }\n-  throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n-                             name,\n-                             ['Date', 'Time in seconds'],\n-                             time);\n-}\n-\n // exported for unit tests, not for public consumption\n fs._toUnixTimestamp = toUnixTimestamp;\n "
        },
        {
            "sha": "9c5c4d8ad7936f7a8d8ab28cc0240f73aaede3dd",
            "filename": "lib/internal/fs.js",
            "status": "modified",
            "additions": 322,
            "deletions": 3,
            "changes": 325,
            "blob_url": "https://github.com/nodejs/node/blob/2620358624b6c0f6c7d02dc2e4333eae9e73b3ea/lib%2Finternal%2Ffs.js",
            "raw_url": "https://github.com/nodejs/node/raw/2620358624b6c0f6c7d02dc2e4333eae9e73b3ea/lib%2Finternal%2Ffs.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs.js?ref=2620358624b6c0f6c7d02dc2e4333eae9e73b3ea",
            "patch": "@@ -1,9 +1,11 @@\n 'use strict';\n \n-const { Buffer } = require('buffer');\n+const { Buffer, kMaxLength } = require('buffer');\n const { Writable } = require('stream');\n const errors = require('internal/errors');\n+const { isUint8Array } = require('internal/util/types');\n const fs = require('fs');\n+const pathModule = require('path');\n const util = require('util');\n \n const {\n@@ -14,15 +16,189 @@ const {\n   O_RDWR,\n   O_SYNC,\n   O_TRUNC,\n-  O_WRONLY\n+  O_WRONLY,\n+  S_IFBLK,\n+  S_IFCHR,\n+  S_IFDIR,\n+  S_IFIFO,\n+  S_IFLNK,\n+  S_IFMT,\n+  S_IFREG,\n+  S_IFSOCK,\n+  UV_FS_SYMLINK_DIR,\n+  UV_FS_SYMLINK_JUNCTION\n } = process.binding('constants').fs;\n+const { statValues } = process.binding('fs');\n+\n+const isWindows = process.platform === 'win32';\n \n function assertEncoding(encoding) {\n   if (encoding && !Buffer.isEncoding(encoding)) {\n     throw new errors.TypeError('ERR_INVALID_OPT_VALUE_ENCODING', encoding);\n   }\n }\n \n+function copyObject(source) {\n+  var target = {};\n+  for (var key in source)\n+    target[key] = source[key];\n+  return target;\n+}\n+\n+function getOptions(options, defaultOptions) {\n+  if (options === null || options === undefined ||\n+      typeof options === 'function') {\n+    return defaultOptions;\n+  }\n+\n+  if (typeof options === 'string') {\n+    defaultOptions = util._extend({}, defaultOptions);\n+    defaultOptions.encoding = options;\n+    options = defaultOptions;\n+  } else if (typeof options !== 'object') {\n+    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n+                               'options',\n+                               ['string', 'Object'],\n+                               options);\n+  }\n+\n+  if (options.encoding !== 'buffer')\n+    assertEncoding(options.encoding);\n+  return options;\n+}\n+\n+function isInt32(n) { return n === (n | 0); }\n+function isUint32(n) { return n === (n >>> 0); }\n+\n+function modeNum(m, def) {\n+  if (typeof m === 'number')\n+    return m;\n+  if (typeof m === 'string')\n+    return parseInt(m, 8);\n+  if (def)\n+    return modeNum(def);\n+  return undefined;\n+}\n+\n+// Check if the path contains null types if it is a string nor Uint8Array,\n+// otherwise return silently.\n+function nullCheck(path, propName, throwError = true) {\n+  const pathIsString = typeof path === 'string';\n+  const pathIsUint8Array = isUint8Array(path);\n+\n+  // We can only perform meaningful checks on strings and Uint8Arrays.\n+  if (!pathIsString && !pathIsUint8Array) {\n+    return;\n+  }\n+\n+  if (pathIsString && path.indexOf('\\u0000') === -1) {\n+    return;\n+  } else if (pathIsUint8Array && path.indexOf(0) === -1) {\n+    return;\n+  }\n+\n+  const err = new errors.Error(\n+    'ERR_INVALID_ARG_VALUE', propName, path,\n+    'must be a string or Uint8Array without null bytes');\n+\n+  if (throwError) {\n+    Error.captureStackTrace(err, nullCheck);\n+    throw err;\n+  }\n+  return err;\n+}\n+\n+function preprocessSymlinkDestination(path, type, linkPath) {\n+  if (!isWindows) {\n+    // No preprocessing is needed on Unix.\n+    return path;\n+  } else if (type === 'junction') {\n+    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n+    // A relative target is relative to the link's parent directory.\n+    path = pathModule.resolve(linkPath, '..', path);\n+    return pathModule.toNamespacedPath(path);\n+  } else {\n+    // Windows symlinks don't tolerate forward slashes.\n+    return ('' + path).replace(/\\//g, '\\\\');\n+  }\n+}\n+\n+// Constructor for file stats.\n+function Stats(\n+  dev,\n+  mode,\n+  nlink,\n+  uid,\n+  gid,\n+  rdev,\n+  blksize,\n+  ino,\n+  size,\n+  blocks,\n+  atim_msec,\n+  mtim_msec,\n+  ctim_msec,\n+  birthtim_msec\n+) {\n+  this.dev = dev;\n+  this.mode = mode;\n+  this.nlink = nlink;\n+  this.uid = uid;\n+  this.gid = gid;\n+  this.rdev = rdev;\n+  this.blksize = blksize;\n+  this.ino = ino;\n+  this.size = size;\n+  this.blocks = blocks;\n+  this.atimeMs = atim_msec;\n+  this.mtimeMs = mtim_msec;\n+  this.ctimeMs = ctim_msec;\n+  this.birthtimeMs = birthtim_msec;\n+  this.atime = new Date(atim_msec + 0.5);\n+  this.mtime = new Date(mtim_msec + 0.5);\n+  this.ctime = new Date(ctim_msec + 0.5);\n+  this.birthtime = new Date(birthtim_msec + 0.5);\n+}\n+\n+Stats.prototype._checkModeProperty = function(property) {\n+  return ((this.mode & S_IFMT) === property);\n+};\n+\n+Stats.prototype.isDirectory = function() {\n+  return this._checkModeProperty(S_IFDIR);\n+};\n+\n+Stats.prototype.isFile = function() {\n+  return this._checkModeProperty(S_IFREG);\n+};\n+\n+Stats.prototype.isBlockDevice = function() {\n+  return this._checkModeProperty(S_IFBLK);\n+};\n+\n+Stats.prototype.isCharacterDevice = function() {\n+  return this._checkModeProperty(S_IFCHR);\n+};\n+\n+Stats.prototype.isSymbolicLink = function() {\n+  return this._checkModeProperty(S_IFLNK);\n+};\n+\n+Stats.prototype.isFIFO = function() {\n+  return this._checkModeProperty(S_IFIFO);\n+};\n+\n+Stats.prototype.isSocket = function() {\n+  return this._checkModeProperty(S_IFSOCK);\n+};\n+\n+function statsFromValues(stats = statValues) {\n+  return new Stats(stats[0], stats[1], stats[2], stats[3], stats[4], stats[5],\n+                   stats[6] < 0 ? undefined : stats[6], stats[7], stats[8],\n+                   stats[9] < 0 ? undefined : stats[9], stats[10], stats[11],\n+                   stats[12], stats[13]);\n+}\n+\n function stringToFlags(flags) {\n   if (typeof flags === 'number') {\n     return flags;\n@@ -56,6 +232,27 @@ function stringToFlags(flags) {\n   throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 'flags', flags);\n }\n \n+function stringToSymlinkType(type) {\n+  let flags = 0;\n+  if (typeof type === 'string') {\n+    switch (type) {\n+      case 'dir':\n+        flags |= UV_FS_SYMLINK_DIR;\n+        break;\n+      case 'junction':\n+        flags |= UV_FS_SYMLINK_JUNCTION;\n+        break;\n+      case 'file':\n+        break;\n+      default:\n+        const err = new errors.Error('ERR_FS_INVALID_SYMLINK_TYPE', type);\n+        Error.captureStackTrace(err, stringToSymlinkType);\n+        throw err;\n+    }\n+  }\n+  return flags;\n+}\n+\n // Temporary hack for process.stdout and process.stderr when piped to files.\n function SyncWriteStream(fd, options) {\n   Writable.call(this);\n@@ -95,9 +292,131 @@ SyncWriteStream.prototype.destroy = function() {\n   return true;\n };\n \n+// converts Date or number to a fractional UNIX timestamp\n+function toUnixTimestamp(time, name = 'time') {\n+  // eslint-disable-next-line eqeqeq\n+  if (typeof time === 'string' && +time == time) {\n+    return +time;\n+  }\n+  if (Number.isFinite(time)) {\n+    if (time < 0) {\n+      return Date.now() / 1000;\n+    }\n+    return time;\n+  }\n+  if (util.isDate(time)) {\n+    // convert to 123.456 UNIX timestamp\n+    return time.getTime() / 1000;\n+  }\n+  throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n+                             name,\n+                             ['Date', 'Time in seconds'],\n+                             time);\n+}\n+\n+function validateBuffer(buffer) {\n+  if (!isUint8Array(buffer)) {\n+    const err = new errors.TypeError('ERR_INVALID_ARG_TYPE', 'buffer',\n+                                     ['Buffer', 'Uint8Array']);\n+    Error.captureStackTrace(err, validateBuffer);\n+    throw err;\n+  }\n+}\n+\n+function validateLen(len) {\n+  let err;\n+\n+  if (!isInt32(len))\n+    err = new errors.TypeError('ERR_INVALID_ARG_TYPE', 'len', 'integer');\n+\n+  if (err !== undefined) {\n+    Error.captureStackTrace(err, validateLen);\n+    throw err;\n+  }\n+}\n+\n+function validateOffsetLengthRead(offset, length, bufferLength) {\n+  let err;\n+\n+  if (offset < 0 || offset >= bufferLength) {\n+    err = new errors.RangeError('ERR_OUT_OF_RANGE', 'offset');\n+  } else if (length < 0 || offset + length > bufferLength) {\n+    err = new errors.RangeError('ERR_OUT_OF_RANGE', 'length');\n+  }\n+\n+  if (err !== undefined) {\n+    Error.captureStackTrace(err, validateOffsetLengthRead);\n+    throw err;\n+  }\n+}\n+\n+function validateOffsetLengthWrite(offset, length, byteLength) {\n+  let err;\n+\n+  if (offset > byteLength) {\n+    err = new errors.RangeError('ERR_OUT_OF_RANGE', 'offset');\n+  } else if (offset + length > byteLength || offset + length > kMaxLength) {\n+    err = new errors.RangeError('ERR_OUT_OF_RANGE', 'length');\n+  }\n+\n+  if (err !== undefined) {\n+    Error.captureStackTrace(err, validateOffsetLengthWrite);\n+    throw err;\n+  }\n+}\n+\n+function validatePath(path, propName) {\n+  let err;\n+\n+  if (propName === undefined) {\n+    propName = 'path';\n+  }\n+\n+  if (typeof path !== 'string' && !isUint8Array(path)) {\n+    err = new errors.TypeError('ERR_INVALID_ARG_TYPE', propName,\n+                               ['string', 'Buffer', 'URL']);\n+  } else {\n+    err = nullCheck(path, propName, false);\n+  }\n+\n+  if (err !== undefined) {\n+    Error.captureStackTrace(err, validatePath);\n+    throw err;\n+  }\n+}\n+\n+function validateUint32(value, propName) {\n+  let err;\n+\n+  if (!isUint32(value))\n+    err = new errors.TypeError('ERR_INVALID_ARG_TYPE', propName, 'integer');\n+\n+  if (err !== undefined) {\n+    Error.captureStackTrace(err, validateUint32);\n+    throw err;\n+  }\n+}\n+\n module.exports = {\n   assertEncoding,\n+  copyObject,\n+  getOptions,\n+  isInt32,\n+  isUint32,\n+  modeNum,\n+  nullCheck,\n+  preprocessSymlinkDestination,\n+  realpathCacheKey: Symbol('realpathCacheKey'),\n+  statsFromValues,\n   stringToFlags,\n+  stringToSymlinkType,\n+  Stats,\n   SyncWriteStream,\n-  realpathCacheKey: Symbol('realpathCacheKey')\n+  toUnixTimestamp,\n+  validateBuffer,\n+  validateLen,\n+  validateOffsetLengthRead,\n+  validateOffsetLengthWrite,\n+  validatePath,\n+  validateUint32\n };"
        }
    ],
    "stats": {
        "total": 634,
        "additions": 340,
        "deletions": 294
    }
}