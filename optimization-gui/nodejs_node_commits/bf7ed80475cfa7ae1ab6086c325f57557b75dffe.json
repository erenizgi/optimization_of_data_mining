{
    "author": "suresh-srinivas",
    "message": "src: initial large page (2M) support\n\nPR-URL: https://github.com/nodejs/node/pull/22079\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Denys Otrishko <shishugi@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "bf7ed80475cfa7ae1ab6086c325f57557b75dffe",
    "files": [
        {
            "sha": "538ae0445a5b47e5c4ac652fc2915aacdfe54f05",
            "filename": "configure.py",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/configure.py",
            "raw_url": "https://github.com/nodejs/node/raw/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/configure.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/configure.py?ref=bf7ed80475cfa7ae1ab6086c325f57557b75dffe",
            "patch": "@@ -388,6 +388,12 @@\n     dest='with_etw',\n     help='build with ETW (default is true on Windows)')\n \n+parser.add_option('--use-largepages',\n+    action='store_true',\n+    dest='node_use_large_pages',\n+    help='build with Large Pages support. This feature is supported only on Linux kernel' +\n+         '>= 2.6.38 with Transparent Huge pages enabled')\n+\n intl_optgroup.add_option('--with-intl',\n     action='store',\n     dest='with_intl',\n@@ -998,6 +1004,24 @@ def configure_node(o):\n   else:\n     o['variables']['node_use_dtrace'] = 'false'\n \n+  if options.node_use_large_pages and flavor != 'linux':\n+    raise Exception(\n+      'Large pages are supported only on Linux Systems.')\n+  if options.node_use_large_pages and flavor == 'linux':\n+    if options.shared or options.enable_static:\n+      raise Exception(\n+        'Large pages are supported only while creating node executable.')\n+    if target_arch!=\"x64\":\n+      raise Exception(\n+        'Large pages are supported only x64 platform.')\n+    # Example full version string: 2.6.32-696.28.1.el6.x86_64\n+    FULL_KERNEL_VERSION=os.uname()[2]\n+    KERNEL_VERSION=FULL_KERNEL_VERSION.split('-')[0]\n+    if KERNEL_VERSION < \"2.6.38\":\n+      raise Exception(\n+        'Large pages need Linux kernel version >= 2.6.38')\n+  o['variables']['node_use_large_pages'] = b(options.node_use_large_pages)\n+\n   if options.no_ifaddrs:\n     o['defines'] += ['SUNOS_NO_IFADDRS']\n "
        },
        {
            "sha": "c2823cacb43aec1c01c02f0ccc5cd74e7992e4ab",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=bf7ed80475cfa7ae1ab6086c325f57557b75dffe",
            "patch": "@@ -578,6 +578,15 @@\n             'src/tls_wrap.h'\n           ],\n         }],\n+        [ 'node_use_large_pages==\"true\" and OS==\"linux\"', {\n+          'defines': [ 'NODE_ENABLE_LARGE_CODE_PAGES=1' ],\n+          # The current implementation of Large Pages is under Linux.\n+          # Other implementations are possible but not currently supported.\n+          'sources': [\n+            'src/large_pages/node_large_page.cc',\n+            'src/large_pages/node_large_page.h'\n+          ],\n+        }],\n         [ 'use_openssl_def==1', {\n           # TODO(bnoordhuis) Make all platforms export the same list of symbols.\n           # Teach mkssldef.py to generate linker maps that UNIX linkers understand."
        },
        {
            "sha": "0b27e6ad2c1ac42735e956f581f4fc8438f36362",
            "filename": "node.gypi",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/node.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/node.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gypi?ref=bf7ed80475cfa7ae1ab6086c325f57557b75dffe",
            "patch": "@@ -292,6 +292,12 @@\n       'ldflags': [ '-Wl,-z,relro',\n                    '-Wl,-z,now' ]\n     }],\n+    [ 'OS==\"linux\" and target_arch==\"x64\" and node_use_large_pages==\"true\"', {\n+      'ldflags': [\n+        '-Wl,-T',\n+        '<!(realpath src/large_pages/ld.implicit.script)',\n+      ]\n+    }],\n     [ 'node_use_openssl==\"true\"', {\n       'defines': [ 'HAVE_OPENSSL=1' ],\n       'conditions': ["
        },
        {
            "sha": "ad7ce1b2e2e5cfd13787ceee805f1cae835ff3a2",
            "filename": "src/large_pages/ld.implicit.script",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/src%2Flarge_pages%2Fld.implicit.script",
            "raw_url": "https://github.com/nodejs/node/raw/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/src%2Flarge_pages%2Fld.implicit.script",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Flarge_pages%2Fld.implicit.script?ref=bf7ed80475cfa7ae1ab6086c325f57557b75dffe",
            "patch": "@@ -0,0 +1,8 @@\n+  SECTIONS {\n+  .lpstub            : { *(.lpstub) }\n+  }\n+  PROVIDE (__nodetext = .);\n+  PROVIDE (_nodetext = .);\n+  PROVIDE (nodetext = .);\n+  INSERT BEFORE .text;\n+"
        },
        {
            "sha": "4b860d9ccb47ca01d40cd765f0dce9a627cc4f0b",
            "filename": "src/large_pages/node_large_page.cc",
            "status": "added",
            "additions": 276,
            "deletions": 0,
            "changes": 276,
            "blob_url": "https://github.com/nodejs/node/blob/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/src%2Flarge_pages%2Fnode_large_page.cc",
            "raw_url": "https://github.com/nodejs/node/raw/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/src%2Flarge_pages%2Fnode_large_page.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Flarge_pages%2Fnode_large_page.cc?ref=bf7ed80475cfa7ae1ab6086c325f57557b75dffe",
            "patch": "@@ -0,0 +1,276 @@\n+// Copyright (C) 2018 Intel Corporation\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"),\n+// to deal in the Software without restriction, including without limitation\n+// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+// and/or sell copies of the Software, and to permit persons to whom\n+// the Software is furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included\n+// in all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n+// OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\n+// OR OTHER DEALINGS IN THE SOFTWARE.\n+//\n+// SPDX-License-Identifier: MIT\n+\n+#include <errno.h>\n+#include <fcntl.h>  // _O_RDWR\n+#include <limits.h>  // PATH_MAX\n+#include <locale.h>\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <sys/mman.h>\n+#include <string>\n+#include <fstream>\n+#include <iostream>\n+#include <sstream>\n+#include <unistd.h>  // readlink\n+\n+// The functions in this file map the text segment of node into 2M pages.\n+// The algorithm is simple\n+// Find the text region of node binary in memory\n+// 1: Examine the /proc/self/maps to determine the currently mapped text\n+// region and obtain the start and end\n+// Modify the start to point to the very beginning of node text segment\n+// (from variable nodetext setup in ld.script)\n+// Align the address of start and end to Large Page Boundaries\n+//\n+// 2: Move the text region to large pages\n+// Map a new area and copy the original code there\n+// Use mmap using the start address with MAP_FIXED so we get exactly the\n+// same virtual address\n+// Use madvise with MADV_HUGE_PAGE to use Anonymous 2M Pages\n+// If successful copy the code there and unmap the original region.\n+\n+extern char __nodetext;\n+\n+namespace node {\n+\n+struct text_region {\n+  char* from;\n+  char* to;\n+  int   total_hugepages;\n+  bool  found_text_region;\n+};\n+\n+static const size_t hps = 2L * 1024 * 1024;\n+\n+static void PrintSystemError(int error) {\n+  fprintf(stderr, \"Hugepages WARNING: %s\\n\", strerror(error));\n+  return;\n+}\n+\n+inline int64_t hugepage_align_up(int64_t addr) {\n+  return (((addr) + (hps) - 1) & ~((hps) - 1));\n+}\n+\n+inline int64_t hugepage_align_down(int64_t addr) {\n+  return ((addr) & ~((hps) - 1));\n+}\n+\n+// The format of the maps file is the following\n+// address           perms offset  dev   inode       pathname\n+// 00400000-00452000 r-xp 00000000 08:02 173521      /usr/bin/dbus-daemon\n+// This is also handling the case where the first line is not the binary\n+\n+static struct text_region FindNodeTextRegion() {\n+  std::ifstream ifs;\n+  std::string map_line;\n+  std::string permission;\n+  std::string dev;\n+  char dash;\n+  int64_t  start, end, offset, inode;\n+  struct text_region nregion;\n+\n+  nregion.found_text_region = false;\n+\n+  ifs.open(\"/proc/self/maps\");\n+  if (!ifs) {\n+    fprintf(stderr, \"Could not open /proc/self/maps\\n\");\n+    return nregion;\n+  }\n+\n+  std::string exename;\n+  {\n+      char selfexe[PATH_MAX];\n+      ssize_t count = readlink(\"/proc/self/exe\", selfexe, PATH_MAX);\n+      exename = std::string(selfexe, count);\n+  }\n+\n+  while (std::getline(ifs, map_line)) {\n+    std::istringstream iss(map_line);\n+    iss >> std::hex >> start;\n+    iss >> dash;\n+    iss >> std::hex >> end;\n+    iss >> permission;\n+    iss >> offset;\n+    iss >> dev;\n+    iss >> inode;\n+    if (inode != 0) {\n+      std::string pathname;\n+      iss >> pathname;\n+      if (pathname == exename && permission == \"r-xp\") {\n+        start = reinterpret_cast<uint64_t>(&__nodetext);\n+        char* from = reinterpret_cast<char*>(hugepage_align_up(start));\n+        char* to = reinterpret_cast<char*>(hugepage_align_down(end));\n+\n+        if (from < to) {\n+          size_t size = to - from;\n+          nregion.found_text_region = true;\n+          nregion.from = from;\n+          nregion.to = to;\n+          nregion.total_hugepages = size / hps;\n+        }\n+        break;\n+      }\n+    }\n+  }\n+\n+  ifs.close();\n+  return nregion;\n+}\n+\n+static bool IsTransparentHugePagesEnabled() {\n+  std::ifstream ifs;\n+\n+  ifs.open(\"/sys/kernel/mm/transparent_hugepage/enabled\");\n+  if (!ifs) {\n+    fprintf(stderr, \"Could not open file: \" \\\n+                    \"/sys/kernel/mm/transparent_hugepage/enabled\\n\");\n+    return false;\n+  }\n+\n+  std::string always, madvise, never;\n+  if (ifs.is_open()) {\n+    while (ifs >> always >> madvise >> never) {}\n+  }\n+\n+  int ret_status = false;\n+\n+  if (always.compare(\"[always]\") == 0)\n+    ret_status = true;\n+  else if (madvise.compare(\"[madvise]\") == 0)\n+    ret_status = true;\n+  else if (never.compare(\"[never]\") == 0)\n+    ret_status = false;\n+\n+  ifs.close();\n+  return ret_status;\n+}\n+\n+// Moving the text region to large pages. We need to be very careful.\n+// 1: This function itself should not be moved.\n+// We use a gcc attributes\n+// (__section__) to put it outside the \".text\" section\n+// (__aligned__) to align it at 2M boundary\n+// (__noline__) to not inline this function\n+// 2: This function should not call any function(s) that might be moved.\n+// a. map a new area and copy the original code there\n+// b. mmap using the start address with MAP_FIXED so we get exactly\n+//    the same virtual address\n+// c. madvise with MADV_HUGE_PAGE\n+// d. If successful copy the code there and unmap the original region\n+int\n+__attribute__((__section__(\".lpstub\")))\n+__attribute__((__aligned__(hps)))\n+__attribute__((__noinline__))\n+MoveTextRegionToLargePages(const text_region& r) {\n+  void* nmem = nullptr;\n+  void* tmem = nullptr;\n+  int ret = 0;\n+\n+  size_t size = r.to - r.from;\n+  void* start = r.from;\n+\n+  // Allocate temporary region preparing for copy\n+  nmem = mmap(nullptr, size,\n+              PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (nmem == MAP_FAILED) {\n+    PrintSystemError(errno);\n+    return -1;\n+  }\n+\n+  memcpy(nmem, r.from, size);\n+\n+// We already know the original page is r-xp\n+// (PROT_READ, PROT_EXEC, MAP_PRIVATE)\n+// We want PROT_WRITE because we are writing into it.\n+// We want it at the fixed address and we use MAP_FIXED.\n+  tmem = mmap(start, size,\n+              PROT_READ | PROT_WRITE | PROT_EXEC,\n+              MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1 , 0);\n+  if (tmem == MAP_FAILED) {\n+    PrintSystemError(errno);\n+    munmap(nmem, size);\n+    return -1;\n+  }\n+\n+  ret = madvise(tmem, size, MADV_HUGEPAGE);\n+  if (ret == -1) {\n+    PrintSystemError(errno);\n+    ret = munmap(tmem, size);\n+    if (ret == -1) {\n+      PrintSystemError(errno);\n+    }\n+    ret = munmap(nmem, size);\n+    if (ret == -1) {\n+      PrintSystemError(errno);\n+    }\n+\n+    return -1;\n+  }\n+\n+  memcpy(start, nmem, size);\n+  ret = mprotect(start, size, PROT_READ | PROT_EXEC);\n+  if (ret == -1) {\n+    PrintSystemError(errno);\n+    ret = munmap(tmem, size);\n+    if (ret == -1) {\n+      PrintSystemError(errno);\n+    }\n+    ret = munmap(nmem, size);\n+    if (ret == -1) {\n+      PrintSystemError(errno);\n+    }\n+    return -1;\n+  }\n+\n+  // Release the old/temporary mapped region\n+  ret = munmap(nmem, size);\n+  if (ret == -1) {\n+    PrintSystemError(errno);\n+  }\n+\n+  return ret;\n+}\n+\n+// This is the primary API called from main\n+int MapStaticCodeToLargePages() {\n+  struct text_region r = FindNodeTextRegion();\n+  if (r.found_text_region == false) {\n+    fprintf(stderr, \"Hugepages WARNING: failed to find text region\\n\");\n+    return -1;\n+  }\n+\n+  if (r.from > reinterpret_cast<void*>(&MoveTextRegionToLargePages))\n+    return MoveTextRegionToLargePages(r);\n+\n+  return -1;\n+}\n+\n+bool IsLargePagesEnabled() {\n+  return IsTransparentHugePagesEnabled();\n+}\n+\n+}  // namespace node"
        },
        {
            "sha": "bce505585cf0d0089744de91c5f7f9ba5290a8e7",
            "filename": "src/large_pages/node_large_page.h",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/src%2Flarge_pages%2Fnode_large_page.h",
            "raw_url": "https://github.com/nodejs/node/raw/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/src%2Flarge_pages%2Fnode_large_page.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Flarge_pages%2Fnode_large_page.h?ref=bf7ed80475cfa7ae1ab6086c325f57557b75dffe",
            "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2018 Intel Corporation\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"),\n+// to deal in the Software without restriction, including without limitation\n+// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+// and/or sell copies of the Software, and to permit persons to whom\n+// the Software is furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included\n+// in all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n+// OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\n+// OR OTHER DEALINGS IN THE SOFTWARE.\n+//\n+// SPDX-License-Identifier: MIT\n+\n+#ifndef SRC_LARGE_PAGES_NODE_LARGE_PAGE_H_\n+#define SRC_LARGE_PAGES_NODE_LARGE_PAGE_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+\n+namespace node {\n+bool IsLargePagesEnabled();\n+int MapStaticCodeToLargePages();\n+}  // namespace node\n+\n+#endif  // NODE_WANT_INTERNALS\n+#endif  // SRC_LARGE_PAGES_NODE_LARGE_PAGE_H_"
        },
        {
            "sha": "dde5c21c7c8a204413c66284d2557537e00e876f",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/bf7ed80475cfa7ae1ab6086c325f57557b75dffe/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=bf7ed80475cfa7ae1ab6086c325f57557b75dffe",
            "patch": "@@ -69,6 +69,10 @@\n #include \"../deps/v8/src/third_party/vtune/v8-vtune.h\"\n #endif\n \n+#ifdef NODE_ENABLE_LARGE_CODE_PAGES\n+#include \"large_pages/node_large_page.h\"\n+#endif\n+\n #include <errno.h>\n #include <fcntl.h>  // _O_RDWR\n #include <limits.h>  // PATH_MAX\n@@ -2959,6 +2963,14 @@ int Start(int argc, char** argv) {\n \n   CHECK_GT(argc, 0);\n \n+#ifdef NODE_ENABLE_LARGE_CODE_PAGES\n+  if (node::IsLargePagesEnabled()) {\n+    if (node::MapStaticCodeToLargePages() != 0) {\n+      fprintf(stderr, \"Reverting to default page size\\n\");\n+    }\n+  }\n+#endif\n+\n   // Hack around with the argv pointer. Used for process.title = \"blah\".\n   argv = uv_setup_args(argc, argv);\n "
        }
    ],
    "stats": {
        "total": 370,
        "additions": 370,
        "deletions": 0
    }
}