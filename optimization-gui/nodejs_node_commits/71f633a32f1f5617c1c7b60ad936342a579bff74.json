{
    "author": "addaleax",
    "message": "src: allow UTF-16 in generic StringBytes decode call\n\nThis allows removing a number of special cases in other\nparts of the code, at least one of which was incorrect\nin expecting aligned input when that was not guaranteed.\n\nFixes: https://github.com/nodejs/node/issues/22358\n\nPR-URL: https://github.com/nodejs/node/pull/22622\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>",
    "sha": "71f633a32f1f5617c1c7b60ad936342a579bff74",
    "files": [
        {
            "sha": "90e764f386a8a975deeffb0fc91688fcd20ed10d",
            "filename": "src/node.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fnode.h",
            "raw_url": "https://github.com/nodejs/node/raw/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fnode.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.h?ref=71f633a32f1f5617c1c7b60ad936342a579bff74",
            "patch": "@@ -410,7 +410,6 @@ NODE_DEPRECATED(\"Use FatalException(isolate, ...)\",\n   return FatalException(v8::Isolate::GetCurrent(), try_catch);\n })\n \n-// Don't call with encoding=UCS2.\n NODE_EXTERN v8::Local<v8::Value> Encode(v8::Isolate* isolate,\n                                         const char* buf,\n                                         size_t len,"
        },
        {
            "sha": "7c4c0d9f657b2456e260c5e41aef890da72f6300",
            "filename": "src/node_buffer.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 59,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fnode_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fnode_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.cc?ref=71f633a32f1f5617c1c7b60ad936342a579bff74",
            "patch": "@@ -467,65 +467,6 @@ void StringSlice(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-template <>\n-void StringSlice<UCS2>(const FunctionCallbackInfo<Value>& args) {\n-  Isolate* isolate = args.GetIsolate();\n-  Environment* env = Environment::GetCurrent(isolate);\n-\n-  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());\n-  SPREAD_BUFFER_ARG(args.This(), ts_obj);\n-\n-  if (ts_obj_length == 0)\n-    return args.GetReturnValue().SetEmptyString();\n-\n-  SLICE_START_END(args[0], args[1], ts_obj_length)\n-  length /= 2;\n-\n-  const char* data = ts_obj_data + start;\n-  const uint16_t* buf;\n-  bool release = false;\n-\n-  // Node's \"ucs2\" encoding expects LE character data inside a Buffer, so we\n-  // need to reorder on BE platforms.  See https://nodejs.org/api/buffer.html\n-  // regarding Node's \"ucs2\" encoding specification.\n-  const bool aligned = (reinterpret_cast<uintptr_t>(data) % sizeof(*buf) == 0);\n-  if (IsLittleEndian() && !aligned) {\n-    // Make a copy to avoid unaligned accesses in v8::String::NewFromTwoByte().\n-    // This applies ONLY to little endian platforms, as misalignment will be\n-    // handled by a byte-swapping operation in StringBytes::Encode on\n-    // big endian platforms.\n-    uint16_t* copy = new uint16_t[length];\n-    for (size_t i = 0, k = 0; i < length; i += 1, k += 2) {\n-      // Assumes that the input is little endian.\n-      const uint8_t lo = static_cast<uint8_t>(data[k + 0]);\n-      const uint8_t hi = static_cast<uint8_t>(data[k + 1]);\n-      copy[i] = lo | hi << 8;\n-    }\n-    buf = copy;\n-    release = true;\n-  } else {\n-    buf = reinterpret_cast<const uint16_t*>(data);\n-  }\n-\n-  Local<Value> error;\n-  MaybeLocal<Value> ret =\n-      StringBytes::Encode(isolate,\n-                          buf,\n-                          length,\n-                          &error);\n-\n-  if (release)\n-    delete[] buf;\n-\n-  if (ret.IsEmpty()) {\n-    CHECK(!error.IsEmpty());\n-    isolate->ThrowException(error);\n-    return;\n-  }\n-  args.GetReturnValue().Set(ret.ToLocalChecked());\n-}\n-\n-\n // bytesCopied = copy(buffer, target[, targetStart][, sourceStart][, sourceEnd])\n void Copy(const FunctionCallbackInfo<Value> &args) {\n   Environment* env = Environment::GetCurrent(args);"
        },
        {
            "sha": "e4c4c0a7dbb34c7b855eda9b1507c8411aabbb30",
            "filename": "src/string_bytes.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 25,
            "changes": 57,
            "blob_url": "https://github.com/nodejs/node/blob/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fstring_bytes.cc",
            "raw_url": "https://github.com/nodejs/node/raw/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fstring_bytes.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_bytes.cc?ref=71f633a32f1f5617c1c7b60ad936342a579bff74",
            "patch": "@@ -625,7 +625,6 @@ MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,\n                                       size_t buflen,\n                                       enum encoding encoding,\n                                       Local<Value>* error) {\n-  CHECK_NE(encoding, UCS2);\n   CHECK_BUFLEN_IN_RANGE(buflen);\n \n   if (!buflen && encoding != BUFFER) {\n@@ -703,6 +702,37 @@ MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,\n       return ExternOneByteString::New(isolate, dst, dlen, error);\n     }\n \n+    case UCS2: {\n+      if (IsBigEndian()) {\n+        uint16_t* dst = node::UncheckedMalloc<uint16_t>(buflen / 2);\n+        if (dst == nullptr) {\n+          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);\n+          return MaybeLocal<Value>();\n+        }\n+        for (size_t i = 0, k = 0; k < buflen / 2; i += 2, k += 1) {\n+          // The input is in *little endian*, because that's what Node.js\n+          // expects, so the high byte comes after the low byte.\n+          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);\n+          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);\n+          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;\n+        }\n+        return ExternTwoByteString::New(isolate, dst, buflen / 2, error);\n+      }\n+      if (reinterpret_cast<uintptr_t>(buf) % 2 != 0) {\n+        // Unaligned data still means we can't directly pass it to V8.\n+        char* dst = node::UncheckedMalloc(buflen);\n+        if (dst == nullptr) {\n+          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);\n+          return MaybeLocal<Value>();\n+        }\n+        memcpy(dst, buf, buflen);\n+        return ExternTwoByteString::New(\n+            isolate, reinterpret_cast<uint16_t*>(dst), buflen / 2, error);\n+      }\n+      return ExternTwoByteString::NewFromCopy(\n+          isolate, reinterpret_cast<const uint16_t*>(buf), buflen / 2, error);\n+    }\n+\n     default:\n       CHECK(0 && \"unknown encoding\");\n       break;\n@@ -742,30 +772,7 @@ MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,\n                                       enum encoding encoding,\n                                       Local<Value>* error) {\n   const size_t len = strlen(buf);\n-  MaybeLocal<Value> ret;\n-  if (encoding == UCS2) {\n-    // In Node, UCS2 means utf16le. The data must be in little-endian\n-    // order and must be aligned on 2-bytes. This returns an empty\n-    // value if it's not aligned and ensures the appropriate byte order\n-    // on big endian architectures.\n-    const bool be = IsBigEndian();\n-    if (len % 2 != 0)\n-      return ret;\n-    std::vector<uint16_t> vec(len / 2);\n-    for (size_t i = 0, k = 0; i < len; i += 2, k += 1) {\n-      const uint8_t hi = static_cast<uint8_t>(buf[i + 0]);\n-      const uint8_t lo = static_cast<uint8_t>(buf[i + 1]);\n-      vec[k] = be ?\n-          static_cast<uint16_t>(hi) << 8 | lo\n-          : static_cast<uint16_t>(lo) << 8 | hi;\n-    }\n-    ret = vec.empty() ?\n-        static_cast< Local<Value> >(String::Empty(isolate))\n-        : StringBytes::Encode(isolate, &vec[0], vec.size(), error);\n-  } else {\n-    ret = StringBytes::Encode(isolate, buf, len, encoding, error);\n-  }\n-  return ret;\n+  return Encode(isolate, buf, len, encoding, error);\n }\n \n }  // namespace node"
        },
        {
            "sha": "87a296663e15aa620ec73ceece242445a3d689bc",
            "filename": "src/string_bytes.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fstring_bytes.h",
            "raw_url": "https://github.com/nodejs/node/raw/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fstring_bytes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_bytes.h?ref=71f633a32f1f5617c1c7b60ad936342a579bff74",
            "patch": "@@ -90,7 +90,6 @@ class StringBytes {\n                       int* chars_written = nullptr);\n \n   // Take the bytes in the src, and turn it into a Buffer or String.\n-  // Don't call with encoding=UCS2.\n   static v8::MaybeLocal<v8::Value> Encode(v8::Isolate* isolate,\n                                           const char* buf,\n                                           size_t buflen,"
        },
        {
            "sha": "fa8201faff2944ea46d64cb3268ba5f08116ee5b",
            "filename": "src/string_decoder.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fstring_decoder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/71f633a32f1f5617c1c7b60ad936342a579bff74/src%2Fstring_decoder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_decoder.cc?ref=71f633a32f1f5617c1c7b60ad936342a579bff74",
            "patch": "@@ -30,16 +30,6 @@ MaybeLocal<String> MakeString(Isolate* isolate,\n         data,\n         v8::NewStringType::kNormal,\n         length);\n-  } else if (encoding == UCS2) {\n-#ifdef DEBUG\n-    CHECK_EQ(reinterpret_cast<uintptr_t>(data) % 2, 0);\n-    CHECK_EQ(length % 2, 0);\n-#endif\n-    ret = StringBytes::Encode(\n-        isolate,\n-        reinterpret_cast<const uint16_t*>(data),\n-        length / 2,\n-        &error);\n   } else {\n     ret = StringBytes::Encode(\n         isolate,"
        },
        {
            "sha": "6e4f4b121d20d768c1750181fa4329f99bd3187e",
            "filename": "test/parallel/test-string-decoder.js",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/71f633a32f1f5617c1c7b60ad936342a579bff74/test%2Fparallel%2Ftest-string-decoder.js",
            "raw_url": "https://github.com/nodejs/node/raw/71f633a32f1f5617c1c7b60ad936342a579bff74/test%2Fparallel%2Ftest-string-decoder.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-string-decoder.js?ref=71f633a32f1f5617c1c7b60ad936342a579bff74",
            "patch": "@@ -143,6 +143,14 @@ decoder = new StringDecoder('utf16le');\n assert.strictEqual(decoder.write(Buffer.from('3DD84D', 'hex')), '\\ud83d');\n assert.strictEqual(decoder.end(), '');\n \n+// Regression test for https://github.com/nodejs/node/issues/22358\n+// (unaligned UTF-16 access).\n+decoder = new StringDecoder('utf16le');\n+assert.strictEqual(decoder.write(Buffer.alloc(1)), '');\n+assert.strictEqual(decoder.write(Buffer.alloc(20)), '\\0'.repeat(10));\n+assert.strictEqual(decoder.write(Buffer.alloc(48)), '\\0'.repeat(24));\n+assert.strictEqual(decoder.end(), '');\n+\n common.expectsError(\n   () => new StringDecoder(1),\n   {"
        }
    ],
    "stats": {
        "total": 136,
        "additions": 40,
        "deletions": 96
    }
}