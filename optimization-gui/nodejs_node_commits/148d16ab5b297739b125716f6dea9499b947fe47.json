{
    "author": "Trott",
    "message": "doc: do not announce obvious examples\n\nRemove \"Examples:\" labels that announce things that are clearly\nexamples.\n\nPR-URL: https://github.com/nodejs/node/pull/19270\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Tobias Nießen <tniessen@tnie.de>",
    "sha": "148d16ab5b297739b125716f6dea9499b947fe47",
    "files": [
        {
            "sha": "139493e1e183b189913522b048ae8d786852c885",
            "filename": "doc/api/buffer.md",
            "status": "modified",
            "additions": 0,
            "deletions": 72,
            "changes": 72,
            "blob_url": "https://github.com/nodejs/node/blob/148d16ab5b297739b125716f6dea9499b947fe47/doc%2Fapi%2Fbuffer.md",
            "raw_url": "https://github.com/nodejs/node/raw/148d16ab5b297739b125716f6dea9499b947fe47/doc%2Fapi%2Fbuffer.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fbuffer.md?ref=148d16ab5b297739b125716f6dea9499b947fe47",
            "patch": "@@ -23,8 +23,6 @@ resized.\n The `Buffer` class is a global within Node.js, making it unlikely that one\n would need to ever use `require('buffer').Buffer`.\n \n-Examples:\n-\n ```js\n // Creates a zero-filled Buffer of length 10.\n const buf1 = Buffer.alloc(10);\n@@ -485,8 +483,6 @@ changes:\n Creates a new `Buffer` containing the given JavaScript string `string`. If\n provided, the `encoding` parameter identifies the character encoding of `string`.\n \n-Examples:\n-\n ```js\n const buf1 = new Buffer('this is a tést');\n const buf2 = new Buffer('7468697320697320612074c3a97374', 'hex');\n@@ -895,8 +891,6 @@ added: v5.10.0\n Creates a new `Buffer` containing the given JavaScript string `string`. If\n provided, the `encoding` parameter identifies the character encoding of `string`.\n \n-Examples:\n-\n ```js\n const buf1 = Buffer.from('this is a tést');\n const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');\n@@ -1048,8 +1042,6 @@ Comparison is based on the actual sequence of bytes in each `Buffer`.\n * `1` is returned if `target` should come *before* `buf` when sorted.\n * `-1` is returned if `target` should come *after* `buf` when sorted.\n \n-Examples:\n-\n ```js\n const buf1 = Buffer.from('ABC');\n const buf2 = Buffer.from('BCD');\n@@ -1074,8 +1066,6 @@ The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd`\n arguments can be used to limit the comparison to specific ranges within `target`\n and `buf` respectively.\n \n-Examples:\n-\n ```js\n const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);\n@@ -1185,8 +1175,6 @@ changes:\n Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,\n `false` otherwise.\n \n-Examples:\n-\n ```js\n const buf1 = Buffer.from('ABC');\n const buf2 = Buffer.from('414243', 'hex');\n@@ -1277,8 +1265,6 @@ added: v5.3.0\n \n Equivalent to [`buf.indexOf() !== -1`][`buf.indexOf()`].\n \n-Examples:\n-\n ```js\n const buf = Buffer.from('this is a buffer');\n \n@@ -1327,8 +1313,6 @@ If `value` is:\n   * a number, `value` will be interpreted as an unsigned 8-bit integer\n   value between `0` and `255`.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from('this is a buffer');\n \n@@ -1427,8 +1411,6 @@ changes:\n Identical to [`buf.indexOf()`], except `buf` is searched from back to front\n instead of front to back.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from('this buffer is a buffer');\n \n@@ -1513,8 +1495,6 @@ can result in undefined and inconsistent behavior. Applications that wish to\n modify the length of a `Buffer` should therefore treat `length` as read-only and\n use [`buf.slice()`] to create a new `Buffer`.\n \n-Examples:\n-\n ```js\n let buf = Buffer.allocUnsafe(10);\n \n@@ -1556,8 +1536,6 @@ Reads a 64-bit double from `buf` at the specified `offset` with specified\n endian format (`readDoubleBE()` returns big endian, `readDoubleLE()` returns\n little endian).\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n \n@@ -1590,8 +1568,6 @@ Reads a 32-bit float from `buf` at the specified `offset` with specified\n endian format (`readFloatBE()` returns big endian, `readFloatLE()` returns\n little endian).\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([1, 2, 3, 4]);\n \n@@ -1623,8 +1599,6 @@ Reads a signed 8-bit integer from `buf` at the specified `offset`.\n \n Integers read from a `Buffer` are interpreted as two's complement signed values.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([-1, 5]);\n \n@@ -1656,8 +1630,6 @@ the specified endian format (`readInt16BE()` returns big endian,\n \n Integers read from a `Buffer` are interpreted as two's complement signed values.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([0, 5]);\n \n@@ -1689,8 +1661,6 @@ the specified endian format (`readInt32BE()` returns big endian,\n \n Integers read from a `Buffer` are interpreted as two's complement signed values.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([0, 0, 0, 5]);\n \n@@ -1721,8 +1691,6 @@ Reads `byteLength` number of bytes from `buf` at the specified `offset`\n and interprets the result as a two's complement signed value. Supports up to 48\n bits of accuracy.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n \n@@ -1751,8 +1719,6 @@ changes:\n \n Reads an unsigned 8-bit integer from `buf` at the specified `offset`.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([1, -2]);\n \n@@ -1782,8 +1748,6 @@ Reads an unsigned 16-bit integer from `buf` at the specified `offset` with\n specified endian format (`readUInt16BE()` returns big endian, `readUInt16LE()`\n returns little endian).\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([0x12, 0x34, 0x56]);\n \n@@ -1817,8 +1781,6 @@ Reads an unsigned 32-bit integer from `buf` at the specified `offset` with\n specified endian format (`readUInt32BE()` returns big endian,\n `readUInt32LE()` returns little endian).\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);\n \n@@ -1849,8 +1811,6 @@ Reads `byteLength` number of bytes from `buf` at the specified `offset`\n and interprets the result as an unsigned integer. Supports up to 48\n bits of accuracy.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);\n \n@@ -1915,8 +1875,6 @@ console.log(buf2.toString('ascii', 0, buf2.length));\n Specifying negative indexes causes the slice to be generated relative to the\n end of `buf` rather than the beginning.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from('buffer');\n \n@@ -1943,8 +1901,6 @@ added: v5.10.0\n Interprets `buf` as an array of unsigned 16-bit integers and swaps the byte-order\n *in-place*. Throws a `RangeError` if [`buf.length`] is not a multiple of 2.\n \n-Examples:\n-\n ```js\n const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n \n@@ -1972,8 +1928,6 @@ added: v5.10.0\n Interprets `buf` as an array of unsigned 32-bit integers and swaps the byte-order\n *in-place*. Throws a `RangeError` if [`buf.length`] is not a multiple of 4.\n \n-Examples:\n-\n ```js\n const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n \n@@ -2001,8 +1955,6 @@ added: v6.3.0\n Interprets `buf` as an array of 64-bit numbers and swaps the byte-order *in-place*.\n Throws a `RangeError` if [`buf.length`] is not a multiple of 8.\n \n-Examples:\n-\n ```js\n const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);\n \n@@ -2069,8 +2021,6 @@ Decodes `buf` to a string according to the specified character encoding in\n The maximum length of a string instance (in UTF-16 code units) is available\n as [`buffer.constants.MAX_STRING_LENGTH`][].\n \n-Examples:\n-\n ```js\n const buf1 = Buffer.allocUnsafe(26);\n \n@@ -2104,8 +2054,6 @@ added: v1.1.0\n Creates and returns an [iterator] for `buf` values (bytes). This function is\n called automatically when a `Buffer` is used in a `for..of` statement.\n \n-Examples:\n-\n ```js\n const buf = Buffer.from('buffer');\n \n@@ -2179,8 +2127,6 @@ format (`writeDoubleBE()` writes big endian, `writeDoubleLE()` writes little\n endian). `value` *should* be a valid 64-bit double. Behavior is undefined when\n `value` is anything other than a 64-bit double.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(8);\n \n@@ -2215,8 +2161,6 @@ format (`writeFloatBE()` writes big endian, `writeFloatLE()` writes little\n endian). `value` *should* be a valid 32-bit float. Behavior is undefined when\n `value` is anything other than a 32-bit float.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(4);\n \n@@ -2251,8 +2195,6 @@ a signed 8-bit integer.\n \n `value` is interpreted and written as a two's complement signed integer.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(2);\n \n@@ -2285,8 +2227,6 @@ when `value` is anything other than a signed 16-bit integer.\n \n `value` is interpreted and written as a two's complement signed integer.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(4);\n \n@@ -2319,8 +2259,6 @@ when `value` is anything other than a signed 32-bit integer.\n \n `value` is interpreted and written as a two's complement signed integer.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(8);\n \n@@ -2351,8 +2289,6 @@ Writes `byteLength` bytes of `value` to `buf` at the specified `offset`.\n Supports up to 48 bits of accuracy. Behavior is undefined when `value` is\n anything other than a signed integer.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(6);\n \n@@ -2385,8 +2321,6 @@ Writes `value` to `buf` at the specified `offset`. `value` *should* be a\n valid unsigned 8-bit integer. Behavior is undefined when `value` is anything\n other than an unsigned 8-bit integer.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(4);\n \n@@ -2419,8 +2353,6 @@ format (`writeUInt16BE()` writes big endian, `writeUInt16LE()` writes little\n endian). `value` should be a valid unsigned 16-bit integer. Behavior is\n undefined when `value` is anything other than an unsigned 16-bit integer.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(4);\n \n@@ -2457,8 +2389,6 @@ format (`writeUInt32BE()` writes big endian, `writeUInt32LE()` writes little\n endian). `value` should be a valid unsigned 32-bit integer. Behavior is\n undefined when `value` is anything other than an unsigned 32-bit integer.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(4);\n \n@@ -2494,8 +2424,6 @@ Writes `byteLength` bytes of `value` to `buf` at the specified `offset`.\n Supports up to 48 bits of accuracy. Behavior is undefined when `value` is\n anything other than an unsigned integer.\n \n-Examples:\n-\n ```js\n const buf = Buffer.allocUnsafe(6);\n "
        }
    ],
    "stats": {
        "total": 72,
        "additions": 0,
        "deletions": 72
    }
}