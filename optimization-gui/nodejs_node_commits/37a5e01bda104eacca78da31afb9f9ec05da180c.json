{
    "author": "Rantanen",
    "message": "lib: ensure readable stream flows to end\n\nIf a readable stream was set up with `highWaterMark 0`, the while-loop\nin `maybeReadMore_` function would never execute.\n\nThe while loop now has an extra or-condition for the case where the\nstream is flowing and there are no items. The or-condition is adapted\nfrom the emit-condition of the `addChunk` function.\n\nThe `addChunk` also contains a check for `state.sync`. However that part\nof the check was omitted here because the `maybeReadMore_` is executed\nusing `process.nextTick`. `state.sync` is set and then unset  within the\n`read()` function so it should never be in effect in `maybeReadMore_`.\n\nFixes: https://github.com/nodejs/node/issues/24915\n\nPR-URL: https://github.com/nodejs/node/pull/24918\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "37a5e01bda104eacca78da31afb9f9ec05da180c",
    "files": [
        {
            "sha": "fbab2362037a3d4221f9940786188f9b6dd4f02c",
            "filename": "lib/_stream_readable.js",
            "status": "modified",
            "additions": 26,
            "deletions": 4,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/37a5e01bda104eacca78da31afb9f9ec05da180c/lib%2F_stream_readable.js",
            "raw_url": "https://github.com/nodejs/node/raw/37a5e01bda104eacca78da31afb9f9ec05da180c/lib%2F_stream_readable.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_stream_readable.js?ref=37a5e01bda104eacca78da31afb9f9ec05da180c",
            "patch": "@@ -568,16 +568,38 @@ function maybeReadMore(stream, state) {\n }\n \n function maybeReadMore_(stream, state) {\n-  var len = state.length;\n+  // Attempt to read more data if we should.\n+  //\n+  // The conditions for reading more data are (one of):\n+  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n+  //   is responsible for filling the buffer with enough data if such data\n+  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n+  //   we should _not_ attempt to buffer any extra data. We'll get more data\n+  //   when the stream consumer calls read() instead.\n+  // - No data in the buffer, and the stream is in flowing mode. In this mode\n+  //   the loop below is responsible for ensuring read() is called. Failing to\n+  //   call read here would abort the flow and there's no other mechanism for\n+  //   continuing the flow if the stream consumer has just subscribed to the\n+  //   'data' event.\n+  //\n+  // In addition to the above conditions to keep reading data, the following\n+  // conditions prevent the data from being read:\n+  // - The stream has ended (state.ended).\n+  // - There is already a pending 'read' operation (state.reading). This is a\n+  //   case where the the stream has called the implementation defined _read()\n+  //   method, but they are processing the call asynchronously and have _not_\n+  //   called push() with new data. In this case we skip performing more\n+  //   read()s. The execution ends in this method again after the _read() ends\n+  //   up calling push() with more data.\n   while (!state.reading && !state.ended &&\n-         state.length < state.highWaterMark) {\n+         (state.length < state.highWaterMark ||\n+          (state.flowing && state.length === 0))) {\n+    const len = state.length;\n     debug('maybeReadMore read 0');\n     stream.read(0);\n     if (len === state.length)\n       // didn't get any data, stop spinning.\n       break;\n-    else\n-      len = state.length;\n   }\n   state.readingMore = false;\n }"
        },
        {
            "sha": "866b524893d5304320c0b2b88536b09c8d514ab0",
            "filename": "test/parallel/test-stream-readable-hwm-0-async.js",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/37a5e01bda104eacca78da31afb9f9ec05da180c/test%2Fparallel%2Ftest-stream-readable-hwm-0-async.js",
            "raw_url": "https://github.com/nodejs/node/raw/37a5e01bda104eacca78da31afb9f9ec05da180c/test%2Fparallel%2Ftest-stream-readable-hwm-0-async.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream-readable-hwm-0-async.js?ref=37a5e01bda104eacca78da31afb9f9ec05da180c",
            "patch": "@@ -0,0 +1,27 @@\n+'use strict';\n+\n+const common = require('../common');\n+\n+// This test ensures that Readable stream will continue to call _read\n+// for streams with highWaterMark === 0 once the stream returns data\n+// by calling push() asynchronously.\n+\n+const { Readable } = require('stream');\n+\n+let count = 5;\n+\n+const r = new Readable({\n+  // Called 6 times: First 5 return data, last one signals end of stream.\n+  read: common.mustCall(() => {\n+    process.nextTick(common.mustCall(() => {\n+      if (count--)\n+        r.push('a');\n+      else\n+        r.push(null);\n+    }));\n+  }, 6),\n+  highWaterMark: 0,\n+});\n+\n+r.on('end', common.mustCall());\n+r.on('data', common.mustCall(5));"
        },
        {
            "sha": "5f0186d720dd636efebf6536ba02c1e7a23527e3",
            "filename": "test/parallel/test-stream-readable-hwm-0-no-flow-data.js",
            "status": "added",
            "additions": 104,
            "deletions": 0,
            "changes": 104,
            "blob_url": "https://github.com/nodejs/node/blob/37a5e01bda104eacca78da31afb9f9ec05da180c/test%2Fparallel%2Ftest-stream-readable-hwm-0-no-flow-data.js",
            "raw_url": "https://github.com/nodejs/node/raw/37a5e01bda104eacca78da31afb9f9ec05da180c/test%2Fparallel%2Ftest-stream-readable-hwm-0-no-flow-data.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream-readable-hwm-0-no-flow-data.js?ref=37a5e01bda104eacca78da31afb9f9ec05da180c",
            "patch": "@@ -0,0 +1,104 @@\n+'use strict';\n+\n+const common = require('../common');\n+\n+// Ensure that subscribing the 'data' event will not make the stream flow.\n+// The 'data' event will require calling read() by hand.\n+//\n+// The test is written for the (somewhat rare) highWaterMark: 0 streams to\n+// specifically catch any regressions that might occur with these streams.\n+\n+const assert = require('assert');\n+const { Readable } = require('stream');\n+\n+const streamData = [ 'a', null ];\n+\n+// Track the calls so we can assert their order later.\n+const calls = [];\n+const r = new Readable({\n+  read: common.mustCall(() => {\n+    calls.push('_read:' + streamData[0]);\n+    process.nextTick(() => {\n+      calls.push('push:' + streamData[0]);\n+      r.push(streamData.shift());\n+    });\n+  }, streamData.length),\n+  highWaterMark: 0,\n+\n+  // Object mode is used here just for testing convenience. It really\n+  // shouldn't affect the order of events. Just the data and its format.\n+  objectMode: true,\n+});\n+\n+assert.strictEqual(r.readableFlowing, null);\n+r.on('readable', common.mustCall(() => {\n+  calls.push('readable');\n+}, 2));\n+assert.strictEqual(r.readableFlowing, false);\n+r.on('data', common.mustCall((data) => {\n+  calls.push('data:' + data);\n+}, 1));\n+r.on('end', common.mustCall(() => {\n+  calls.push('end');\n+}));\n+assert.strictEqual(r.readableFlowing, false);\n+\n+// The stream emits the events asynchronously but that's not guaranteed to\n+// happen on the next tick (especially since the _read implementation above\n+// uses process.nextTick).\n+//\n+// We use setImmediate here to give the stream enough time to emit all the\n+// events it's about to emit.\n+setImmediate(() => {\n+\n+  // Only the _read, push, readable calls have happened. No data must be\n+  // emitted yet.\n+  assert.deepStrictEqual(calls, ['_read:a', 'push:a', 'readable']);\n+\n+  // Calling 'r.read()' should trigger the data event.\n+  assert.strictEqual(r.read(), 'a');\n+  assert.deepStrictEqual(\n+    calls,\n+    ['_read:a', 'push:a', 'readable', 'data:a']);\n+\n+  // The next 'read()' will return null because hwm: 0 does not buffer any\n+  // data and the _read implementation above does the push() asynchronously.\n+  //\n+  // Note: This 'null' signals \"no data available\". It isn't the end-of-stream\n+  // null value as the stream doesn't know yet that it is about to reach the\n+  // end.\n+  //\n+  // Using setImmediate again to give the stream enough time to emit all the\n+  // events it wants to emit.\n+  assert.strictEqual(r.read(), null);\n+  setImmediate(() => {\n+\n+    // There's a new 'readable' event after the data has been pushed.\n+    // The 'end' event will be emitted only after a 'read()'.\n+    //\n+    // This is somewhat special for the case where the '_read' implementation\n+    // calls 'push' asynchronously. If 'push' was synchronous, the 'end' event\n+    // would be emitted here _before_ we call read().\n+    assert.deepStrictEqual(\n+      calls,\n+      ['_read:a', 'push:a', 'readable', 'data:a',\n+       '_read:null', 'push:null', 'readable']);\n+\n+    assert.strictEqual(r.read(), null);\n+\n+    // While it isn't really specified whether the 'end' event should happen\n+    // synchronously with read() or not, we'll assert the current behavior\n+    // ('end' event happening on the next tick after read()) so any changes\n+    // to it are noted and acknowledged in the future.\n+    assert.deepStrictEqual(\n+      calls,\n+      ['_read:a', 'push:a', 'readable', 'data:a',\n+       '_read:null', 'push:null', 'readable']);\n+    process.nextTick(() => {\n+      assert.deepStrictEqual(\n+        calls,\n+        ['_read:a', 'push:a', 'readable', 'data:a',\n+         '_read:null', 'push:null', 'readable', 'end']);\n+    });\n+  });\n+});"
        }
    ],
    "stats": {
        "total": 161,
        "additions": 157,
        "deletions": 4
    }
}