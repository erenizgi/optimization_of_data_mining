{
    "author": "addaleax",
    "message": "src: pass along errors from fs object creations\n\nPR-URL: https://github.com/nodejs/node/pull/25822\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>",
    "sha": "63d398c9bbf94e1d5da7f287473137234353c622",
    "files": [
        {
            "sha": "5513be3d7c77c1d93c42026020e57aeb08fb9a18",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 47,
            "deletions": 19,
            "changes": 66,
            "blob_url": "https://github.com/nodejs/node/blob/63d398c9bbf94e1d5da7f287473137234353c622/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/63d398c9bbf94e1d5da7f287473137234353c622/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=63d398c9bbf94e1d5da7f287473137234353c622",
            "patch": "@@ -110,20 +110,29 @@ typedef void(*uv_fs_callback_t)(uv_fs_t*);\n // The FileHandle object wraps a file descriptor and will close it on garbage\n // collection if necessary. If that happens, a process warning will be\n // emitted (or a fatal exception will occur if the fd cannot be closed.)\n-FileHandle::FileHandle(Environment* env, int fd, Local<Object> obj)\n-    : AsyncWrap(env,\n-                obj.IsEmpty() ? env->fd_constructor_template()\n-                    ->NewInstance(env->context()).ToLocalChecked() : obj,\n-                AsyncWrap::PROVIDER_FILEHANDLE),\n+FileHandle::FileHandle(Environment* env, Local<Object> obj, int fd)\n+    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_FILEHANDLE),\n       StreamBase(env),\n       fd_(fd) {\n   MakeWeak();\n+}\n+\n+FileHandle* FileHandle::New(Environment* env, int fd, Local<Object> obj) {\n+  if (obj.IsEmpty() && !env->fd_constructor_template()\n+                            ->NewInstance(env->context())\n+                            .ToLocal(&obj)) {\n+    return nullptr;\n+  }\n   v8::PropertyAttribute attr =\n       static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete);\n-  object()->DefineOwnProperty(env->context(),\n-                              FIXED_ONE_BYTE_STRING(env->isolate(), \"fd\"),\n-                              Integer::New(env->isolate(), fd),\n-                              attr).FromJust();\n+  if (obj->DefineOwnProperty(env->context(),\n+                             env->fd_string(),\n+                             Integer::New(env->isolate(), fd),\n+                             attr)\n+          .IsNothing()) {\n+    return nullptr;\n+  }\n+  return new FileHandle(env, obj, fd);\n }\n \n void FileHandle::New(const FunctionCallbackInfo<Value>& args) {\n@@ -132,7 +141,8 @@ void FileHandle::New(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n \n   FileHandle* handle =\n-      new FileHandle(env, args[0].As<Int32>()->Value(), args.This());\n+      FileHandle::New(env, args[0].As<Int32>()->Value(), args.This());\n+  if (handle == nullptr) return;\n   if (args[1]->IsNumber())\n     handle->read_offset_ = args[1]->IntegerValue(env->context()).FromJust();\n   if (args[2]->IsNumber())\n@@ -232,7 +242,14 @@ inline MaybeLocal<Promise> FileHandle::ClosePromise() {\n   CHECK(!reading_);\n   if (!closed_ && !closing_) {\n     closing_ = true;\n-    CloseReq* req = new CloseReq(env(), promise, object());\n+    Local<Object> close_req_obj;\n+    if (!env()\n+             ->fdclose_constructor_template()\n+             ->NewInstance(env()->context())\n+             .ToLocal(&close_req_obj)) {\n+      return MaybeLocal<Promise>();\n+    }\n+    CloseReq* req = new CloseReq(env(), close_req_obj, promise, object());\n     auto AfterClose = uv_fs_callback_t{[](uv_fs_t* req) {\n       std::unique_ptr<CloseReq> close(CloseReq::from_req(req));\n       CHECK_NOT_NULL(close);\n@@ -260,7 +277,9 @@ inline MaybeLocal<Promise> FileHandle::ClosePromise() {\n void FileHandle::Close(const FunctionCallbackInfo<Value>& args) {\n   FileHandle* fd;\n   ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());\n-  args.GetReturnValue().Set(fd->ClosePromise().ToLocalChecked());\n+  Local<Promise> ret;\n+  if (!fd->ClosePromise().ToLocal(&ret)) return;\n+  args.GetReturnValue().Set(ret);\n }\n \n \n@@ -318,8 +337,13 @@ int FileHandle::ReadStart() {\n       read_wrap->AsyncReset();\n       read_wrap->file_handle_ = this;\n     } else {\n-      Local<Object> wrap_obj = env()->filehandlereadwrap_template()\n-          ->NewInstance(env()->context()).ToLocalChecked();\n+      Local<Object> wrap_obj;\n+      if (!env()\n+               ->filehandlereadwrap_template()\n+               ->NewInstance(env()->context())\n+               .ToLocal(&wrap_obj)) {\n+        return UV_EBUSY;\n+      }\n       read_wrap.reset(new FileHandleReadWrap(this, wrap_obj));\n     }\n   }\n@@ -520,7 +544,8 @@ void AfterOpenFileHandle(uv_fs_t* req) {\n   FSReqAfterScope after(req_wrap, req);\n \n   if (after.Proceed()) {\n-    FileHandle* fd = new FileHandle(req_wrap->env(), req->result);\n+    FileHandle* fd = FileHandle::New(req_wrap->env(), req->result);\n+    if (fd == nullptr) return;\n     req_wrap->Resolve(fd->object());\n   }\n }\n@@ -724,15 +749,18 @@ inline int SyncCall(Environment* env, Local<Value> ctx, FSReqWrapSync* req_wrap,\n   return err;\n }\n \n+// TODO(addaleax): Currently, callers check the return value and assume\n+// that nullptr indicates a synchronous call, rather than a failure.\n+// Failure conditions should be disambiguated and handled appropriately.\n inline FSReqBase* GetReqWrap(Environment* env, Local<Value> value,\n                              bool use_bigint = false) {\n   if (value->IsObject()) {\n     return Unwrap<FSReqBase>(value.As<Object>());\n   } else if (value->StrictEquals(env->fs_use_promises_symbol())) {\n     if (use_bigint) {\n-      return new FSReqPromise<uint64_t, BigUint64Array>(env, use_bigint);\n+      return FSReqPromise<uint64_t, BigUint64Array>::New(env, use_bigint);\n     } else {\n-      return new FSReqPromise<double, Float64Array>(env, use_bigint);\n+      return FSReqPromise<double, Float64Array>::New(env, use_bigint);\n     }\n   }\n   return nullptr;\n@@ -1562,8 +1590,8 @@ static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {\n     if (result < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n-    HandleScope scope(isolate);\n-    FileHandle* fd = new FileHandle(env, result);\n+    FileHandle* fd = FileHandle::New(env, result);\n+    if (fd == nullptr) return;\n     args.GetReturnValue().Set(fd->object());\n   }\n }"
        },
        {
            "sha": "5ae01df9ef6106fd39136280e8d45f20a104ec8c",
            "filename": "src/node_file.h",
            "status": "modified",
            "additions": 24,
            "deletions": 18,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/63d398c9bbf94e1d5da7f287473137234353c622/src%2Fnode_file.h",
            "raw_url": "https://github.com/nodejs/node/raw/63d398c9bbf94e1d5da7f287473137234353c622/src%2Fnode_file.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.h?ref=63d398c9bbf94e1d5da7f287473137234353c622",
            "patch": "@@ -237,17 +237,19 @@ inline Local<Value> FillGlobalStatsArray(Environment* env,\n template <typename NativeT = double, typename V8T = v8::Float64Array>\n class FSReqPromise : public FSReqBase {\n  public:\n-  explicit FSReqPromise(Environment* env, bool use_bigint)\n-      : FSReqBase(env,\n-                  env->fsreqpromise_constructor_template()\n-                      ->NewInstance(env->context()).ToLocalChecked(),\n-                  AsyncWrap::PROVIDER_FSREQPROMISE,\n-                  use_bigint),\n-        stats_field_array_(env->isolate(), kFsStatsFieldsNumber) {\n-    const auto resolver =\n-      Promise::Resolver::New(env->context()).ToLocalChecked();\n-    USE(object()->Set(env->context(), env->promise_string(),\n-                      resolver).FromJust());\n+  static FSReqPromise* New(Environment* env, bool use_bigint) {\n+    v8::Local<Object> obj;\n+    if (!env->fsreqpromise_constructor_template()\n+             ->NewInstance(env->context())\n+             .ToLocal(&obj)) {\n+      return nullptr;\n+    }\n+    v8::Local<v8::Promise::Resolver> resolver;\n+    if (!v8::Promise::Resolver::New(env->context()).ToLocal(&resolver) ||\n+        obj->Set(env->context(), env->promise_string(), resolver).IsNothing()) {\n+      return nullptr;\n+    }\n+    return new FSReqPromise(env, obj, use_bigint);\n   }\n \n   ~FSReqPromise() override {\n@@ -304,6 +306,10 @@ class FSReqPromise : public FSReqBase {\n   FSReqPromise& operator=(const FSReqPromise&&) = delete;\n \n  private:\n+  FSReqPromise(Environment* env, v8::Local<v8::Object> obj, bool use_bigint)\n+      : FSReqBase(env, obj, AsyncWrap::PROVIDER_FSREQPROMISE, use_bigint),\n+        stats_field_array_(env->isolate(), kFsStatsFieldsNumber) {}\n+\n   bool finished_ = false;\n   AliasedBuffer<NativeT, V8T> stats_field_array_;\n };\n@@ -356,9 +362,9 @@ class FileHandleReadWrap : public ReqWrap<uv_fs_t> {\n // the object is garbage collected\n class FileHandle : public AsyncWrap, public StreamBase {\n  public:\n-  FileHandle(Environment* env,\n-             int fd,\n-             v8::Local<v8::Object> obj = v8::Local<v8::Object>());\n+  static FileHandle* New(Environment* env,\n+                         int fd,\n+                         v8::Local<v8::Object> obj = v8::Local<v8::Object>());\n   virtual ~FileHandle();\n \n   static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n@@ -404,19 +410,19 @@ class FileHandle : public AsyncWrap, public StreamBase {\n   FileHandle& operator=(const FileHandle&&) = delete;\n \n  private:\n+  FileHandle(Environment* env, v8::Local<v8::Object> obj, int fd);\n+\n   // Synchronous close that emits a warning\n   void Close();\n   void AfterClose();\n \n   class CloseReq : public ReqWrap<uv_fs_t> {\n    public:\n     CloseReq(Environment* env,\n+             Local<Object> obj,\n              Local<Promise> promise,\n              Local<Value> ref)\n-        : ReqWrap(env,\n-                  env->fdclose_constructor_template()\n-                      ->NewInstance(env->context()).ToLocalChecked(),\n-                  AsyncWrap::PROVIDER_FILEHANDLECLOSEREQ) {\n+        : ReqWrap(env, obj, AsyncWrap::PROVIDER_FILEHANDLECLOSEREQ) {\n       promise_.Reset(env->isolate(), promise);\n       ref_.Reset(env->isolate(), ref);\n     }"
        }
    ],
    "stats": {
        "total": 108,
        "additions": 71,
        "deletions": 37
    }
}