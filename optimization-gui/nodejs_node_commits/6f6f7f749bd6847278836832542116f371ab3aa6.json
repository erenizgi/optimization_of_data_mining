{
    "author": "apapirovski",
    "message": "lib: add internal PriorityQueue class\n\nAn efficient JS implementation of a binary heap on top of an array with\nworst-case O(log n) runtime for all operations, including arbitrary\nitem removal (unlike O(n) for most binary heap array implementations).\n\nPR-URL: https://github.com/nodejs/node/pull/20555\nFixes: https://github.com/nodejs/node/issues/16105\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Jeremiah Senkpiel <fishrock123@rocketmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "6f6f7f749bd6847278836832542116f371ab3aa6",
    "files": [
        {
            "sha": "51a696439a28640650f2fee5e86d1e5f141ef2a9",
            "filename": "benchmark/util/priority-queue.js",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/6f6f7f749bd6847278836832542116f371ab3aa6/benchmark%2Futil%2Fpriority-queue.js",
            "raw_url": "https://github.com/nodejs/node/raw/6f6f7f749bd6847278836832542116f371ab3aa6/benchmark%2Futil%2Fpriority-queue.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Futil%2Fpriority-queue.js?ref=6f6f7f749bd6847278836832542116f371ab3aa6",
            "patch": "@@ -0,0 +1,18 @@\n+'use strict';\n+\n+const common = require('../common');\n+\n+const bench = common.createBenchmark(main, {\n+  n: [1e6]\n+}, { flags: ['--expose-internals'] });\n+\n+function main({ n, type }) {\n+  const PriorityQueue = require('internal/priority_queue');\n+  const queue = new PriorityQueue();\n+  bench.start();\n+  for (var i = 0; i < n; i++)\n+    queue.insert(Math.random() * 1e7 | 0);\n+  for (i = 0; i < n; i++)\n+    queue.shift();\n+  bench.end(n);\n+}"
        },
        {
            "sha": "cb046507a667d947f8b40adf1a9a0b6ded2ddb18",
            "filename": "lib/internal/priority_queue.js",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/nodejs/node/blob/6f6f7f749bd6847278836832542116f371ab3aa6/lib%2Finternal%2Fpriority_queue.js",
            "raw_url": "https://github.com/nodejs/node/raw/6f6f7f749bd6847278836832542116f371ab3aa6/lib%2Finternal%2Fpriority_queue.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fpriority_queue.js?ref=6f6f7f749bd6847278836832542116f371ab3aa6",
            "patch": "@@ -0,0 +1,111 @@\n+'use strict';\n+\n+const kCompare = Symbol('compare');\n+const kHeap = Symbol('heap');\n+const kSetPosition = Symbol('setPosition');\n+const kSize = Symbol('size');\n+\n+// The PriorityQueue is a basic implementation of a binary heap that accepts\n+// a custom sorting function via its constructor. This function is passed\n+// the two nodes to compare, similar to the native Array#sort. Crucially\n+// this enables priority queues that are based on a comparison of more than\n+// just a single criteria.\n+\n+module.exports = class PriorityQueue {\n+  constructor(comparator, setPosition) {\n+    if (comparator !== undefined)\n+      this[kCompare] = comparator;\n+    if (setPosition !== undefined)\n+      this[kSetPosition] = setPosition;\n+\n+    this[kHeap] = new Array(64);\n+    this[kSize] = 0;\n+  }\n+\n+  [kCompare](a, b) {\n+    return a - b;\n+  }\n+\n+  insert(value) {\n+    const heap = this[kHeap];\n+    let pos = ++this[kSize];\n+\n+    if (heap.length === pos)\n+      heap.length *= 2;\n+\n+    const compare = this[kCompare];\n+    const setPosition = this[kSetPosition];\n+    while (pos > 1) {\n+      const parent = heap[pos / 2 | 0];\n+      if (compare(parent, value) <= 0)\n+        break;\n+      heap[pos] = parent;\n+      if (setPosition !== undefined)\n+        setPosition(parent, pos);\n+      pos = pos / 2 | 0;\n+    }\n+    heap[pos] = value;\n+    if (setPosition !== undefined)\n+      setPosition(value, pos);\n+  }\n+\n+  peek() {\n+    return this[kHeap][1];\n+  }\n+\n+  percolateDown(pos) {\n+    const compare = this[kCompare];\n+    const setPosition = this[kSetPosition];\n+    const heap = this[kHeap];\n+    const size = this[kSize];\n+    const item = heap[pos];\n+\n+    while (pos * 2 <= size) {\n+      let childIndex = pos * 2 + 1;\n+      if (childIndex > size || compare(heap[pos * 2], heap[childIndex]) < 0)\n+        childIndex = pos * 2;\n+      const child = heap[childIndex];\n+      if (compare(item, child) <= 0)\n+        break;\n+      if (setPosition !== undefined)\n+        setPosition(child, pos);\n+      heap[pos] = child;\n+      pos = childIndex;\n+    }\n+    heap[pos] = item;\n+    if (setPosition !== undefined)\n+      setPosition(item, pos);\n+  }\n+\n+  removeAt(pos) {\n+    const heap = this[kHeap];\n+    const size = --this[kSize];\n+    heap[pos] = heap[size + 1];\n+    heap[size + 1] = undefined;\n+\n+    if (size > 0)\n+      this.percolateDown(1);\n+  }\n+\n+  remove(value) {\n+    const heap = this[kHeap];\n+    const pos = heap.indexOf(value);\n+    if (pos < 1)\n+      return false;\n+\n+    this.removeAt(pos);\n+\n+    return true;\n+  }\n+\n+  shift() {\n+    const heap = this[kHeap];\n+    const value = heap[1];\n+    if (value === undefined)\n+      return;\n+\n+    this.removeAt(1);\n+\n+    return value;\n+  }\n+};"
        },
        {
            "sha": "038e5219bcc0fe18b6835b5967b8c6444e31489f",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/6f6f7f749bd6847278836832542116f371ab3aa6/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/6f6f7f749bd6847278836832542116f371ab3aa6/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=6f6f7f749bd6847278836832542116f371ab3aa6",
            "patch": "@@ -123,6 +123,7 @@\n       'lib/internal/safe_globals.js',\n       'lib/internal/net.js',\n       'lib/internal/os.js',\n+      'lib/internal/priority_queue.js',\n       'lib/internal/process/esm_loader.js',\n       'lib/internal/process/methods.js',\n       'lib/internal/process/next_tick.js',"
        },
        {
            "sha": "5b8f53a1766bb5e93b7eb9bdec96c57369003898",
            "filename": "test/parallel/test-priority-queue.js",
            "status": "added",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/nodejs/node/blob/6f6f7f749bd6847278836832542116f371ab3aa6/test%2Fparallel%2Ftest-priority-queue.js",
            "raw_url": "https://github.com/nodejs/node/raw/6f6f7f749bd6847278836832542116f371ab3aa6/test%2Fparallel%2Ftest-priority-queue.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-priority-queue.js?ref=6f6f7f749bd6847278836832542116f371ab3aa6",
            "patch": "@@ -0,0 +1,97 @@\n+// Flags: --expose-internals\n+'use strict';\n+\n+require('../common');\n+\n+const assert = require('assert');\n+const PriorityQueue = require('internal/priority_queue');\n+\n+{\n+  // Checks that the queue is fundamentally correct.\n+  const queue = new PriorityQueue();\n+  for (let i = 15; i > 0; i--)\n+    queue.insert(i);\n+\n+  for (let i = 1; i < 16; i++) {\n+    assert.strictEqual(queue.peek(), i);\n+    assert.strictEqual(queue.shift(), i);\n+  }\n+\n+  assert.strictEqual(queue.shift(), undefined);\n+\n+  // Reverse the order.\n+  for (let i = 1; i < 16; i++)\n+    queue.insert(i);\n+\n+  for (let i = 1; i < 16; i++) {\n+    assert.strictEqual(queue.shift(), i);\n+  }\n+\n+  assert.strictEqual(queue.shift(), undefined);\n+}\n+\n+{\n+  // Checks that the queue is capable of resizing and fitting more elements.\n+  const queue = new PriorityQueue();\n+  for (let i = 2048; i > 0; i--)\n+    queue.insert(i);\n+\n+  for (let i = 1; i < 2049; i++) {\n+    assert.strictEqual(queue.shift(), i);\n+  }\n+\n+  assert.strictEqual(queue.shift(), undefined);\n+}\n+\n+{\n+  // Checks that remove works as expected.\n+  const queue = new PriorityQueue();\n+  for (let i = 16; i > 0; i--)\n+    queue.insert(i);\n+\n+  const removed = [5, 10, 15];\n+  for (const id of removed)\n+    assert(queue.remove(id));\n+\n+  assert(!queue.remove(100));\n+  assert(!queue.remove(-100));\n+\n+  for (let i = 1; i < 17; i++) {\n+    if (removed.indexOf(i) < 0)\n+      assert.strictEqual(queue.shift(), i);\n+  }\n+\n+  assert.strictEqual(queue.shift(), undefined);\n+}\n+\n+{\n+  // Make a max heap with a custom sort function.\n+  const queue = new PriorityQueue((a, b) => b - a);\n+  for (let i = 1; i < 17; i++)\n+    queue.insert(i);\n+\n+  for (let i = 16; i > 0; i--) {\n+    assert.strictEqual(queue.shift(), i);\n+  }\n+\n+  assert.strictEqual(queue.shift(), undefined);\n+}\n+\n+{\n+  // Make a min heap that accepts objects as values, which necessitates\n+  // a custom sorting function. In addition, add a setPosition function\n+  // as 2nd param which provides a reference to the node in the heap\n+  // and allows speedy deletions.\n+  const queue = new PriorityQueue((a, b) => {\n+    return a.value - b.value;\n+  }, (node, pos) => (node.position = pos));\n+  for (let i = 1; i < 17; i++)\n+    queue.insert({ value: i, position: null });\n+\n+  for (let i = 1; i < 17; i++) {\n+    assert.strictEqual(queue.peek().value, i);\n+    queue.removeAt(queue.peek().position);\n+  }\n+\n+  assert.strictEqual(queue.peek(), undefined);\n+}"
        }
    ],
    "stats": {
        "total": 227,
        "additions": 227,
        "deletions": 0
    }
}