{
    "author": "Trott",
    "message": "doc: remove \"note that\" from fs doc\n\nRemove \"note that\" from the fs documentation, along with other minor\nnearby improvements.\n\nBefore:\n\n    Note that some characters are obscured by Strong Bad's head.\n\nAfter:\n\n    Some characters are obscured by Strong Bad's head.\n\nPR-URL: https://github.com/nodejs/node/pull/21646\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Сковорода Никита Андреевич <chalkerx@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>",
    "sha": "f545ae9589f97de0f403b61b5b3075bbb527309b",
    "files": [
        {
            "sha": "aa1a43f1ecc14c72ec3fff74c785401ed2f1b023",
            "filename": "doc/api/fs.md",
            "status": "modified",
            "additions": 56,
            "deletions": 62,
            "changes": 118,
            "blob_url": "https://github.com/nodejs/node/blob/f545ae9589f97de0f403b61b5b3075bbb527309b/doc%2Fapi%2Ffs.md",
            "raw_url": "https://github.com/nodejs/node/raw/f545ae9589f97de0f403b61b5b3075bbb527309b/doc%2Fapi%2Ffs.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ffs.md?ref=f545ae9589f97de0f403b61b5b3075bbb527309b",
            "patch": "@@ -45,9 +45,9 @@ try {\n }\n ```\n \n-Note that there is no guaranteed ordering when using asynchronous methods.\n-So the following is prone to error because the `fs.stat()` operation may\n-complete before the `fs.rename()` operation.\n+There is no guaranteed ordering when using asynchronous methods. So the\n+following is prone to error because the `fs.stat()` operation may complete\n+before the `fs.rename()` operation:\n \n ```js\n fs.rename('/tmp/hello', '/tmp/world', (err) => {\n@@ -150,8 +150,8 @@ fs.open(Buffer.from('/open/some/file.txt'), 'r', (err, fd) => {\n });\n ```\n \n-*Note:* On Windows Node.js follows the concept of per-drive working directory.\n-This behavior can be observed when using a drive path without a backslash. For\n+On Windows, Node.js follows the concept of per-drive working directory. This\n+behavior can be observed when using a drive path without a backslash. For\n example `fs.readdirSync('c:\\\\')` can potentially return a different result than\n `fs.readdirSync('c:')`. For more information, see\n [this MSDN page][MSDN-Rel-Path].\n@@ -278,9 +278,9 @@ eventually cause an application to crash.\n \n ## Threadpool Usage\n \n-Note that all file system APIs except `fs.FSWatcher()` and those that are\n-explicitly synchronous use libuv's threadpool, which can have surprising and\n-negative performance implications for some applications, see the\n+All file system APIs except `fs.FSWatcher()` and those that are explicitly\n+synchronous use libuv's threadpool, which can have surprising and negative\n+performance implications for some applications. See the\n [`UV_THREADPOOL_SIZE`][] documentation for more information.\n \n ## Class: fs.FSWatcher\n@@ -689,15 +689,13 @@ The times in the stat object have the following semantics:\n * `birthtime` \"Birth Time\" - Time of file creation. Set once when the\n   file is created. On filesystems where birthtime is not available,\n   this field may instead hold either the `ctime` or\n-  `1970-01-01T00:00Z` (ie, unix epoch timestamp `0`). Note that this\n-  value may be greater than `atime` or `mtime` in this case. On Darwin\n-  and other FreeBSD variants, also set if the `atime` is explicitly\n-  set to an earlier value than the current `birthtime` using the\n-  utimes(2) system call.\n+  `1970-01-01T00:00Z` (ie, unix epoch timestamp `0`). This value may be greater\n+  than `atime` or `mtime` in this case. On Darwin and other FreeBSD variants,\n+  also set if the `atime` is explicitly set to an earlier value than the current\n+  `birthtime` using the utimes(2) system call.\n \n-Prior to Node.js v0.12, the `ctime` held the `birthtime` on Windows\n-systems. Note that as of v0.12, `ctime` is not \"creation time\", and\n-on Unix systems, it never was.\n+Prior to Node.js 0.12, the `ctime` held the `birthtime` on Windows systems. As\n+of 0.12, `ctime` is not \"creation time\", and on Unix systems, it never was.\n \n ## Class: fs.WriteStream\n <!-- YAML\n@@ -1117,11 +1115,10 @@ For example, the octal value `0o765` means:\n * The group may read and write the file.\n * Others may read and execute the file.\n \n-Note: When using raw numbers where file modes are expected,\n-any value larger than `0o777` may result in platform-specific\n-behaviors that are not supported to work consistently.\n-Therefore constants like `S_ISVTX`, `S_ISGID` or `S_ISUID` are\n-not exposed in `fs.constants`.\n+When using raw numbers where file modes are expected, any value larger than\n+`0o777` may result in platform-specific behaviors that are not supported to work\n+consistently. Therefore constants like `S_ISVTX`, `S_ISGID` or `S_ISUID` are not\n+exposed in `fs.constants`.\n \n Caveats: on Windows only the write permission can be changed, and the\n distinction among the permissions of group, owner or others is not\n@@ -1378,8 +1375,8 @@ The `encoding` can be any one of those accepted by [`Buffer`][].\n \n If `fd` is specified, `ReadStream` will ignore the `path` argument and will use\n the specified file descriptor. This means that no `'open'` event will be\n-emitted. Note that `fd` should be blocking; non-blocking `fd`s should be passed\n-to [`net.Socket`][].\n+emitted. `fd` should be blocking; non-blocking `fd`s should be passed to\n+[`net.Socket`][].\n \n If `autoClose` is false, then the file descriptor won't be closed, even if\n there's an error. It is the application's responsibility to close it and make\n@@ -1442,8 +1439,8 @@ file descriptor leak.\n \n Like [`ReadStream`][], if `fd` is specified, [`WriteStream`][] will ignore the\n `path` argument and will use the specified file descriptor. This means that no\n-`'open'` event will be emitted. Note that `fd` should be blocking; non-blocking\n-`fd`s should be passed to [`net.Socket`][].\n+`'open'` event will be emitted. `fd` should be blocking; non-blocking `fd`s\n+should be passed to [`net.Socket`][].\n \n If `options` is a string, then it specifies the encoding.\n \n@@ -1473,11 +1470,11 @@ fs.exists('/etc/passwd', (exists) => {\n });\n ```\n \n-**Note that the parameter to this callback is not consistent with other\n-Node.js callbacks.** Normally, the first parameter to a Node.js callback is\n-an `err` parameter, optionally followed by other parameters. The\n-`fs.exists()` callback has only one boolean parameter. This is one reason\n-`fs.access()` is recommended instead of `fs.exists()`.\n+**The parameters for this callback are not consistent with other Node.js\n+callbacks.** Normally, the first parameter to a Node.js callback is an `err`\n+parameter, optionally followed by other parameters. The `fs.exists()` callback\n+has only one boolean parameter. This is one reason `fs.access()` is recommended\n+instead of `fs.exists()`.\n \n Using `fs.exists()` to check for the existence of a file before calling\n `fs.open()`, `fs.readFile()` or `fs.writeFile()` is not recommended. Doing\n@@ -1573,10 +1570,9 @@ changes:\n Synchronous version of [`fs.exists()`][].\n Returns `true` if the path exists, `false` otherwise.\n \n-Note that `fs.exists()` is deprecated, but `fs.existsSync()` is not.\n-(The `callback` parameter to `fs.exists()` accepts parameters that are\n-inconsistent with other Node.js callbacks. `fs.existsSync()` does not use\n-a callback.)\n+`fs.exists()` is deprecated, but `fs.existsSync()` is not. The `callback`\n+parameter to `fs.exists()` accepts parameters that are inconsistent with other\n+Node.js callbacks. `fs.existsSync()` does not use a callback.\n \n ## fs.fchmod(fd, mode, callback)\n <!-- YAML\n@@ -2149,9 +2145,8 @@ fs.mkdtemp(tmpDir, (err, folder) => {\n   if (err) throw err;\n   console.log(folder);\n   // Will print something similar to `/tmpabc123`.\n-  // Note that a new temporary directory is created\n-  // at the file system root rather than *within*\n-  // the /tmp directory.\n+  // A new temporary directory is created at the file system root\n+  // rather than *within* the /tmp directory.\n });\n \n // This method is *CORRECT*:\n@@ -2204,8 +2199,8 @@ changes:\n Asynchronous file open. See open(2).\n \n `mode` sets the file mode (permission and sticky bits), but only if the file was\n-created. Note that on Windows only the write permission can be manipulated,\n-see [`fs.chmod()`][].\n+created. On Windows, only the write permission can be manipulated; see\n+[`fs.chmod()`][].\n \n The callback gets two arguments `(err, fd)`.\n \n@@ -2843,9 +2838,9 @@ changes:\n Asynchronous symlink(2). No arguments other than a possible exception are given\n to the completion callback. The `type` argument can be set to `'dir'`,\n `'file'`, or `'junction'` and is only available on\n-Windows (ignored on other platforms). Note that Windows junction points require\n-the destination path to be absolute. When using `'junction'`, the `target`\n-argument will automatically be normalized to absolute path.\n+Windows (ignored on other platforms). Windows junction points require the\n+destination path to be absolute. When using `'junction'`, the `target` argument\n+will automatically be normalized to absolute path.\n \n Here is an example below:\n \n@@ -3086,10 +3081,10 @@ The listener callback gets two arguments `(eventType, filename)`. `eventType`\n is either `'rename'` or `'change'`, and `filename` is the name of the file\n which triggered the event.\n \n-Note that on most platforms, `'rename'` is emitted whenever a filename appears\n-or disappears in the directory.\n+On most platforms, `'rename'` is emitted whenever a filename appears or\n+disappears in the directory.\n \n-Also note the listener callback is attached to the `'change'` event fired by\n+The listener callback is attached to the `'change'` event fired by\n [`fs.FSWatcher`][], but it is not the same thing as the `'change'` value of\n `eventType`.\n \n@@ -3266,9 +3261,8 @@ The callback will be given three arguments `(err, bytesWritten, buffer)` where\n If this method is invoked as its [`util.promisify()`][]ed version, it returns\n a `Promise` for an `Object` with `bytesWritten` and `buffer` properties.\n \n-Note that it is unsafe to use `fs.write` multiple times on the same file\n-without waiting for the callback. For this scenario,\n-`fs.createWriteStream` is strongly recommended.\n+It is unsafe to use `fs.write()` multiple times on the same file without waiting\n+for the callback. For this scenario, `fs.createWriteStream()` is recommended.\n \n On Linux, positional writes don't work when the file is opened in append mode.\n The kernel ignores the position argument and always appends the data to\n@@ -3310,12 +3304,12 @@ the current position. See pwrite(2).\n `encoding` is the expected string encoding.\n \n The callback will receive the arguments `(err, written, string)` where `written`\n-specifies how many _bytes_ the passed string required to be written. Note that\n-bytes written is not the same as string characters. See [`Buffer.byteLength`][].\n+specifies how many _bytes_ the passed string required to be written. Bytes\n+written is not necessarily the same as string characters written. See\n+[`Buffer.byteLength`][].\n \n-Note that it is unsafe to use `fs.write` multiple times on the same file\n-without waiting for the callback. For this scenario,\n-`fs.createWriteStream` is strongly recommended.\n+It is unsafe to use `fs.write()` multiple times on the same file without waiting\n+for the callback. For this scenario, `fs.createWriteStream()` is recommended.\n \n On Linux, positional writes don't work when the file is opened in append mode.\n The kernel ignores the position argument and always appends the data to\n@@ -3372,9 +3366,9 @@ fs.writeFile('message.txt', 'Hello Node.js', 'utf8', callback);\n \n Any specified file descriptor has to support writing.\n \n-Note that it is unsafe to use `fs.writeFile` multiple times on the same file\n-without waiting for the callback. For this scenario,\n-`fs.createWriteStream` is strongly recommended.\n+It is unsafe to use `fs.writeFile()` multiple times on the same file without\n+waiting for the callback. For this scenario, `fs.createWriteStream()` is\n+recommended.\n \n If a file descriptor is specified as the `file`, it will not be closed\n automatically.\n@@ -4161,9 +4155,9 @@ Creates a symbolic link then resolves the `Promise` with no arguments upon\n success.\n \n The `type` argument is only used on Windows platforms and can be one of `'dir'`,\n-`'file'`, or `'junction'`. Note that Windows junction\n-points require the destination path to be absolute. When using `'junction'`,\n-the `target` argument will automatically be normalized to absolute path.\n+`'file'`, or `'junction'`. Windows junction points require the destination path\n+to be absolute. When using `'junction'`, the `target` argument will\n+automatically be normalized to absolute path.\n \n ### fsPromises.truncate(path[, len])\n <!-- YAML\n@@ -4525,9 +4519,9 @@ string:\n   skipping the potentially stale local cache. It has a very real impact on\n   I/O performance so using this flag is not recommended unless it is needed.\n \n-  Note that this doesn't turn `fs.open()` or `fsPromises.open()` into a\n-  synchronous blocking call. If synchronous operation is desired, something\n-  like `fs.openSync()` should be used.\n+  This doesn't turn `fs.open()` or `fsPromises.open()` into a synchronous\n+  blocking call. If synchronous operation is desired, something like\n+  `fs.openSync()` should be used.\n \n * `'w'` - Open file for writing.\n   The file is created (if it does not exist) or truncated (if it exists)."
        }
    ],
    "stats": {
        "total": 118,
        "additions": 56,
        "deletions": 62
    }
}