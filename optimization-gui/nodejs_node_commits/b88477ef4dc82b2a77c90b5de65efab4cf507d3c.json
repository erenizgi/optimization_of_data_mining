{
    "author": "vsemozhetbyt",
    "message": "tools: fix comment nits in tools/doc/*.js files\n\n* Unify first letters case.\n* Unify periods.\n* Delete excess spaces.\n* Add some blank lines as logical delimiters.\n* Remove obvious comments.\n* Combine short lines, rewrap lines more logically.\n* Fix typos.\n* \"XXX\" -> \"TODO:\", OSX -> macOS.\n\nPR-URL: https://github.com/nodejs/node/pull/19696\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Shingo Inoue <leko.noor@gmail.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>",
    "sha": "b88477ef4dc82b2a77c90b5de65efab4cf507d3c",
    "files": [
        {
            "sha": "9fcc71ed93f0c90a9b208d73e62d88e75f5ce712",
            "filename": "tools/doc/addon-verify.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Faddon-verify.js",
            "raw_url": "https://github.com/nodejs/node/raw/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Faddon-verify.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Faddon-verify.js?ref=b88477ef4dc82b2a77c90b5de65efab4cf507d3c",
            "patch": "@@ -47,7 +47,7 @@ function once(fn) {\n }\n \n function verifyFiles(files, blockName, onprogress, ondone) {\n-  // must have a .cc and a .js to be a valid test\n+  // Must have a .cc and a .js to be a valid test.\n   if (!Object.keys(files).some((name) => /\\.cc$/.test(name)) ||\n       !Object.keys(files).some((name) => /\\.js$/.test(name))) {\n     return;\n@@ -95,7 +95,7 @@ ${files[name].replace(\n   });\n \n   fs.mkdir(dir, function() {\n-    // Ignore errors\n+    // Ignore errors.\n \n     const done = once(ondone);\n     var waiting = files.length;"
        },
        {
            "sha": "553b52935fd7091ddb6c49e79e8dccc18dd0b69f",
            "filename": "tools/doc/common.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Fcommon.js",
            "raw_url": "https://github.com/nodejs/node/raw/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Fcommon.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Fcommon.js?ref=b88477ef4dc82b2a77c90b5de65efab4cf507d3c",
            "patch": "@@ -15,7 +15,7 @@ function extractAndParseYAML(text) {\n              .replace(/^<!-- YAML/, '')\n              .replace(/-->$/, '');\n \n-  // js-yaml.safeLoad() throws on error\n+  // js-yaml.safeLoad() throws on error.\n   const meta = yaml.safeLoad(text);\n \n   if (meta.added) {"
        },
        {
            "sha": "0da9dba4e6558fa2f7d90f9a5dd2b4c660c93985",
            "filename": "tools/doc/generate.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Fgenerate.js",
            "raw_url": "https://github.com/nodejs/node/raw/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Fgenerate.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Fgenerate.js?ref=b88477ef4dc82b2a77c90b5de65efab4cf507d3c",
            "patch": "@@ -24,8 +24,8 @@\n const processIncludes = require('./preprocess.js');\n const fs = require('fs');\n \n-// parse the args.\n-// Don't use nopt or whatever for this.  It's simple enough.\n+// Parse the args.\n+// Don't use nopt or whatever for this. It's simple enough.\n \n const args = process.argv.slice(2);\n let format = 'json';\n@@ -56,7 +56,7 @@ if (!filename) {\n \n fs.readFile(filename, 'utf8', (er, input) => {\n   if (er) throw er;\n-  // process the input for @include lines\n+  // Process the input for @include lines.\n   processIncludes(filename, input, next);\n });\n "
        },
        {
            "sha": "ff0230309ee99a24e8448b3ed355d870feb00e2d",
            "filename": "tools/doc/html.js",
            "status": "modified",
            "additions": 23,
            "deletions": 23,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Fhtml.js",
            "raw_url": "https://github.com/nodejs/node/raw/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Fhtml.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Fhtml.js?ref=b88477ef4dc82b2a77c90b5de65efab4cf507d3c",
            "patch": "@@ -33,7 +33,7 @@ module.exports = toHTML;\n const STABILITY_TEXT_REG_EXP = /(.*:)\\s*(\\d)([\\s\\S]*)/;\n const DOC_CREATED_REG_EXP = /<!--\\s*introduced_in\\s*=\\s*v([0-9]+)\\.([0-9]+)\\.([0-9]+)\\s*-->/;\n \n-// customized heading without id attribute\n+// Customized heading without id attribute.\n const renderer = new marked.Renderer();\n renderer.heading = function(text, level) {\n   return `<h${level}>${text}</h${level}>\\n`;\n@@ -42,7 +42,7 @@ marked.setOptions({\n   renderer: renderer\n });\n \n-// TODO(chrisdickinson): never stop vomitting / fix this.\n+// TODO(chrisdickinson): never stop vomiting / fix this.\n const gtocPath = path.resolve(path.join(\n   __dirname,\n   '..',\n@@ -128,16 +128,16 @@ function render(opts, cb) {\n   var { lexed, filename, template } = opts;\n   const nodeVersion = opts.nodeVersion || process.version;\n \n-  // get the section\n+  // Get the section.\n   const section = getSection(lexed);\n \n   filename = path.basename(filename, '.md');\n \n   parseText(lexed);\n   lexed = parseLists(lexed);\n \n-  // generate the table of contents.\n-  // this mutates the lexed contents in-place.\n+  // Generate the table of contents.\n+  // This mutates the lexed contents in-place.\n   buildToc(lexed, filename, function(er, toc) {\n     if (er) return cb(er);\n \n@@ -162,8 +162,8 @@ function render(opts, cb) {\n \n     template = template.replace(/__ALTDOCS__/, altDocs(filename));\n \n-    // content has to be the last thing we do with\n-    // the lexed tokens, because it's destructive.\n+    // Content has to be the last thing we do with the lexed tokens,\n+    // because it's destructive.\n     const content = marked.parser(lexed);\n     template = template.replace(/__CONTENT__/g, content);\n \n@@ -188,7 +188,7 @@ function analyticsScript(analytics) {\n   `;\n }\n \n-// replace placeholders in text tokens\n+// Replace placeholders in text tokens.\n function replaceInText(text) {\n   return linkJsTypeDocs(linkManPages(text));\n }\n@@ -244,8 +244,8 @@ function altDocs(filename) {\n   `;\n }\n \n-// handle general body-text replacements\n-// for example, link man page references to the actual page\n+// Handle general body-text replacements.\n+// For example, link man page references to the actual page.\n function parseText(lexed) {\n   lexed.forEach(function(tok) {\n     if (tok.type === 'table') {\n@@ -272,8 +272,8 @@ function parseText(lexed) {\n   });\n }\n \n-// just update the list item text in-place.\n-// lists that come right after a heading are what we're after.\n+// Just update the list item text in-place.\n+// Lists that come right after a heading are what we're after.\n function parseLists(input) {\n   var state = null;\n   const savedState = [];\n@@ -299,8 +299,8 @@ function parseLists(input) {\n         const stabilityMatch = tok.text.match(STABILITY_TEXT_REG_EXP);\n         const stability = Number(stabilityMatch[2]);\n         const isStabilityIndex =\n-          index - 2 === headingIndex || // general\n-          index - 3 === headingIndex;   // with api_metadata block\n+          index - 2 === headingIndex || // General.\n+          index - 3 === headingIndex;   // With api_metadata block.\n \n         if (heading && isStabilityIndex) {\n           heading.stability = stability;\n@@ -408,17 +408,17 @@ function parseYAML(text) {\n   return html.join('\\n');\n }\n \n-// Syscalls which appear in the docs, but which only exist in BSD / OSX\n+// Syscalls which appear in the docs, but which only exist in BSD / macOS.\n const BSD_ONLY_SYSCALLS = new Set(['lchmod']);\n \n-// Handle references to man pages, eg \"open(2)\" or \"lchmod(2)\"\n-// Returns modified text, with such refs replace with HTML links, for example\n-// '<a href=\"http://man7.org/linux/man-pages/man2/open.2.html\">open(2)</a>'\n+// Handle references to man pages, eg \"open(2)\" or \"lchmod(2)\".\n+// Returns modified text, with such refs replaced with HTML links, for example\n+// '<a href=\"http://man7.org/linux/man-pages/man2/open.2.html\">open(2)</a>'.\n function linkManPages(text) {\n   return text.replace(\n     /(^|\\s)([a-z.]+)\\((\\d)([a-z]?)\\)/gm,\n     (match, beginning, name, number, optionalCharacter) => {\n-      // name consists of lowercase letters, number is a single digit\n+      // Name consists of lowercase letters, number is a single digit.\n       const displayAs = `${name}(${number}${optionalCharacter})`;\n       if (BSD_ONLY_SYSCALLS.has(name)) {\n         return `${beginning}<a href=\"https://www.freebsd.org/cgi/man.cgi?query=${name}` +\n@@ -436,7 +436,7 @@ function linkJsTypeDocs(text) {\n   var typeMatches;\n \n   // Handle types, for example the source Markdown might say\n-  // \"This argument should be a {Number} or {String}\"\n+  // \"This argument should be a {Number} or {String}\".\n   for (i = 0; i < parts.length; i += 2) {\n     typeMatches = parts[i].match(/\\{([^}]+)\\}/g);\n     if (typeMatches) {\n@@ -446,7 +446,7 @@ function linkJsTypeDocs(text) {\n     }\n   }\n \n-  //XXX maybe put more stuff here?\n+  // TODO: maybe put more stuff here?\n   return parts.join('`');\n }\n \n@@ -461,7 +461,7 @@ function parseAPIHeader(text) {\n   return text;\n }\n \n-// section is just the first heading\n+// Section is just the first heading.\n function getSection(lexed) {\n   for (var i = 0, l = lexed.length; i < l; i++) {\n     var tok = lexed[i];\n@@ -533,7 +533,7 @@ const numberRe = /^(\\d*)/;\n function versionSort(a, b) {\n   a = a.trim();\n   b = b.trim();\n-  let i = 0;  // common prefix length\n+  let i = 0; // Common prefix length.\n   while (i < a.length && i < b.length && a[i] === b[i]) i++;\n   a = a.substr(i);\n   b = b.substr(i);"
        },
        {
            "sha": "6eaee8c7fc1688ae46337a313e51456451156d44",
            "filename": "tools/doc/json.js",
            "status": "modified",
            "additions": 42,
            "deletions": 41,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Fjson.js",
            "raw_url": "https://github.com/nodejs/node/raw/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Fjson.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Fjson.js?ref=b88477ef4dc82b2a77c90b5de65efab4cf507d3c",
            "patch": "@@ -23,13 +23,13 @@\n \n module.exports = doJSON;\n \n-// Take the lexed input, and return a JSON-encoded object\n-// A module looks like this: https://gist.github.com/1777387\n+// Take the lexed input, and return a JSON-encoded object.\n+// A module looks like this: https://gist.github.com/1777387.\n \n const common = require('./common.js');\n const marked = require('marked');\n \n-// customized heading without id attribute\n+// Customized heading without id attribute.\n const renderer = new marked.Renderer();\n renderer.heading = function(text, level) {\n   return `<h${level}>${text}</h${level}>\\n`;\n@@ -68,20 +68,19 @@ function doJSON(input, filename, cb) {\n                             JSON.stringify(tok)));\n       }\n \n-      // Sometimes we have two headings with a single\n-      // blob of description.  Treat as a clone.\n+      // Sometimes we have two headings with a single blob of description.\n+      // Treat as a clone.\n       if (current &&\n           state === 'AFTERHEADING' &&\n           depth === tok.depth) {\n         var clone = current;\n         current = newSection(tok);\n         current.clone = clone;\n-        // don't keep it around on the stack.\n+        // Don't keep it around on the stack.\n         stack.pop();\n       } else {\n-        // if the level is greater than the current depth,\n-        // then it's a child, so we should just leave the stack\n-        // as it is.\n+        // If the level is greater than the current depth,\n+        // then it's a child, so we should just leave the stack as it is.\n         // However, if it's a sibling or higher, then it implies\n         // the closure of the other sections that came before.\n         // root is always considered the level=0 section,\n@@ -99,19 +98,19 @@ function doJSON(input, filename, cb) {\n       stack.push(current);\n       state = 'AFTERHEADING';\n       return;\n-    } // heading\n+    }\n \n-    // Immediately after a heading, we can expect the following\n+    // Immediately after a heading, we can expect the following:\n     //\n-    // { type: 'blockquote_start' }\n+    // { type: 'blockquote_start' },\n     // { type: 'paragraph', text: 'Stability: ...' },\n-    // { type: 'blockquote_end' }\n+    // { type: 'blockquote_end' },\n     //\n-    // a list: starting with list_start, ending with list_end,\n+    // A list: starting with list_start, ending with list_end,\n     // maybe containing other nested lists in each item.\n     //\n-    // If one of these isn't found, then anything that comes between\n-    // here and the next heading should be parsed as the desc.\n+    // If one of these isn't found, then anything that comes\n+    // between here and the next heading should be parsed as the desc.\n     var stability;\n     if (state === 'AFTERHEADING') {\n       if (type === 'blockquote_start') {\n@@ -171,7 +170,7 @@ function doJSON(input, filename, cb) {\n \n   });\n \n-  // finish any sections left open\n+  // Finish any sections left open.\n   while (root !== (current = stack.pop())) {\n     finishSection(current, stack[stack.length - 1]);\n   }\n@@ -180,14 +179,15 @@ function doJSON(input, filename, cb) {\n }\n \n \n-// go from something like this:\n+// Go from something like this:\n+//\n // [ { type: 'list_item_start' },\n //   { type: 'text',\n //     text: '`settings` Object, Optional' },\n //   { type: 'list_start', ordered: false },\n //   { type: 'list_item_start' },\n //   { type: 'text',\n-//     text: 'exec: String, file path to worker file.  Default: `__filename`' },\n+//     text: 'exec: String, file path to worker file. Default: `__filename`' },\n //   { type: 'list_item_end' },\n //   { type: 'list_item_start' },\n //   { type: 'text',\n@@ -204,7 +204,9 @@ function doJSON(input, filename, cb) {\n //   { type: 'list_end' },\n //   { type: 'list_item_end' },\n //   { type: 'list_end' } ]\n+//\n // to something like:\n+//\n // [ { name: 'settings',\n //     type: 'object',\n //     optional: true,\n@@ -228,7 +230,7 @@ function processList(section) {\n   var current;\n   const stack = [];\n \n-  // for now, *just* build the heirarchical list\n+  // For now, *just* build the hierarchical list.\n   list.forEach(function(tok) {\n     const type = tok.type;\n     if (type === 'space') return;\n@@ -260,23 +262,23 @@ function processList(section) {\n     }\n   });\n \n-  // shove the name in there for properties, since they are always\n-  // just going to be the value etc.\n+  // Shove the name in there for properties,\n+  // since they are always just going to be the value etc.\n   if (section.type === 'property' && values[0]) {\n     values[0].textRaw = `\\`${section.name}\\` ${values[0].textRaw}`;\n   }\n \n-  // now pull the actual values out of the text bits.\n+  // Now pull the actual values out of the text bits.\n   values.forEach(parseListItem);\n \n   // Now figure out what this list actually means.\n-  // depending on the section type, the list could be different things.\n+  // Depending on the section type, the list could be different things.\n \n   switch (section.type) {\n     case 'ctor':\n     case 'classMethod':\n     case 'method':\n-      // each item is an argument, unless the name is 'return',\n+      // Each item is an argument, unless the name is 'return',\n       // in which case it's the return value.\n       section.signatures = section.signatures || [];\n       var sig = {};\n@@ -292,8 +294,8 @@ function processList(section) {\n       break;\n \n     case 'property':\n-      // there should be only one item, which is the value.\n-      // copy the data up to the section.\n+      // There should be only one item, which is the value.\n+      // Copy the data up to the section.\n       var value = values[0] || {};\n       delete value.name;\n       section.typeof = value.type || section.typeof;\n@@ -304,7 +306,7 @@ function processList(section) {\n       break;\n \n     case 'event':\n-      // event: each item is an argument.\n+      // Event: each item is an argument.\n       section.params = values;\n       break;\n \n@@ -336,7 +338,7 @@ function parseSignature(text, sig) {\n     var optional = false;\n     var def;\n \n-    // for grouped optional params such as someMethod(a[, b[, c]])\n+    // For grouped optional params such as someMethod(a[, b[, c]]).\n     var pos;\n     for (pos = 0; pos < p.length; pos++) {\n       if (optionalCharDict[p[pos]] === undefined) { break; }\n@@ -358,7 +360,7 @@ function parseSignature(text, sig) {\n     if (!param) {\n       param = sig.params[i] = { name: p };\n     }\n-    // at this point, the name should match.\n+    // At this point, the name should match.\n     if (p !== param.name) {\n       console.error('Warning: invalid param \"%s\"', p);\n       console.error(` > ${JSON.stringify(param)}`);\n@@ -374,8 +376,8 @@ function parseListItem(item) {\n   if (item.options) item.options.forEach(parseListItem);\n   if (!item.textRaw) return;\n \n-  // the goal here is to find the name, type, default, and optional.\n-  // anything left over is 'desc'\n+  // The goal here is to find the name, type, default, and optional.\n+  // Anything left over is 'desc'.\n   var text = item.textRaw.trim();\n   // text = text.replace(/^(Argument|Param)s?\\s*:?\\s*/i, '');\n \n@@ -449,9 +451,8 @@ function finishSection(section, parent) {\n   if (!section.list) section.list = [];\n   processList(section);\n \n-  // classes sometimes have various 'ctor' children\n-  // which are actually just descriptions of a constructor\n-  // class signature.\n+  // Classes sometimes have various 'ctor' children\n+  // which are actually just descriptions of a constructor class signature.\n   // Merge them into the parent.\n   if (section.type === 'class' && section.ctors) {\n     section.signatures = section.signatures || [];\n@@ -466,8 +467,8 @@ function finishSection(section, parent) {\n     delete section.ctors;\n   }\n \n-  // properties are a bit special.\n-  // their \"type\" is the type of object, not \"property\"\n+  // Properties are a bit special.\n+  // Their \"type\" is the type of object, not \"property\".\n   if (section.properties) {\n     section.properties.forEach(function(p) {\n       if (p.typeof) p.type = p.typeof;\n@@ -476,7 +477,7 @@ function finishSection(section, parent) {\n     });\n   }\n \n-  // handle clones\n+  // Handle clones.\n   if (section.clone) {\n     var clone = section.clone;\n     delete section.clone;\n@@ -494,7 +495,7 @@ function finishSection(section, parent) {\n     plur = `${section.type}s`;\n   }\n \n-  // if the parent's type is 'misc', then it's just a random\n+  // If the parent's type is 'misc', then it's just a random\n   // collection of stuff, like the \"globals\" section.\n   // Make the children top-level items.\n   if (section.type === 'misc') {\n@@ -554,7 +555,7 @@ function deepCopy_(src) {\n }\n \n \n-// these parse out the contents of an H# tag\n+// These parse out the contents of an H# tag.\n const eventExpr = /^Event(?::|\\s)+['\"]?([^\"']+).*$/i;\n const classExpr = /^Class:\\s*([^ ]+).*$/i;\n const propExpr = /^[^.]+\\.([^ .()]+)\\s*$/;\n@@ -566,7 +567,7 @@ var paramExpr = /\\((.*)\\);?$/;\n \n function newSection(tok) {\n   const section = {};\n-  // infer the type from the text.\n+  // Infer the type from the text.\n   const text = section.textRaw = tok.text;\n   if (text.match(eventExpr)) {\n     section.type = 'event';"
        },
        {
            "sha": "1cbd1a5552b00dfaa7a538d221f8d8b97013f083",
            "filename": "tools/doc/type-parser.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Ftype-parser.js",
            "raw_url": "https://github.com/nodejs/node/raw/b88477ef4dc82b2a77c90b5de65efab4cf507d3c/tools%2Fdoc%2Ftype-parser.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Ftype-parser.js?ref=b88477ef4dc82b2a77c90b5de65efab4cf507d3c",
            "patch": "@@ -5,7 +5,7 @@ const jsDocPrefix = 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/';\n const jsPrimitiveUrl = `${jsDocPrefix}Data_structures`;\n const jsPrimitives = {\n   'boolean': 'Boolean',\n-  'integer': 'Number', // not a primitive, used for clarification\n+  'integer': 'Number', // Not a primitive, used for clarification.\n   'null': 'Null',\n   'number': 'Number',\n   'string': 'String',\n@@ -110,7 +110,7 @@ function toLink(typeInput) {\n       let typeUrl = null;\n \n       // To support type[], type[][] etc., we store the full string\n-      // and use the bracket-less version to lookup the type URL\n+      // and use the bracket-less version to lookup the type URL.\n       const typeTextFull = typeText;\n       typeText = typeText.replace(arrayPart, '');\n "
        }
    ],
    "stats": {
        "total": 145,
        "additions": 73,
        "deletions": 72
    }
}