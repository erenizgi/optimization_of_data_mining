{
    "author": "ryzokuken",
    "message": "vm: add bindings for v8::CompileFunctionInContext\n\nAdds a method compileFunction to the vm module, which serves as a\nbinding for v8::CompileFunctionInContext with appropriate args for\nspecifying the details, and provide params for the wrapper.\n\nEventually, we would be changing Module._compile to use this internally\nover the standard Module.wrap\n\nPR-URL: https://github.com/nodejs/node/pull/21571\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "1abbe0a2123e8333922894258389c2d5c1568472",
    "files": [
        {
            "sha": "e7aafb9e74e65c11aad6b413fc244444402b0e1d",
            "filename": "doc/api/vm.md",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/1abbe0a2123e8333922894258389c2d5c1568472/doc%2Fapi%2Fvm.md",
            "raw_url": "https://github.com/nodejs/node/raw/1abbe0a2123e8333922894258389c2d5c1568472/doc%2Fapi%2Fvm.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fvm.md?ref=1abbe0a2123e8333922894258389c2d5c1568472",
            "patch": "@@ -637,6 +637,34 @@ console.log(globalVar);\n // 1000\n ```\n \n+## vm.compileFunction(code[, params[, options]])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `code` {string} The body of the function to compile.\n+* `params` {string[]} An array of strings containing all parameters for the\n+  function.\n+* `options` {Object}\n+  * `filename` {string} Specifies the filename used in stack traces produced\n+    by this script. **Default:** `''`.\n+  * `lineOffset` {number} Specifies the line number offset that is displayed\n+    in stack traces produced by this script. **Default:** `0`.\n+  * `columnOffset` {number} Specifies the column number offset that is displayed\n+    in stack traces produced by this script. **Default:** `0`.\n+  * `cachedData` {Buffer} Provides an optional `Buffer` with V8's code cache\n+    data for the supplied source.\n+  * `produceCachedData` {boolean} Specifies whether to produce new cache data.\n+    **Default:** `false`.\n+  * `parsingContext` {Object} The sandbox/context in which the said function\n+    should be compiled in.\n+  * `contextExtensions` {Object[]} An array containing a collection of context\n+    extensions (objects wrapping the current scope) to be applied while\n+    compiling. **Default:** `[]`.\n+\n+Compiles the given code into the provided context/sandbox (if no context is\n+supplied, the current context is used), and returns it wrapped inside a\n+function with the given `params`.\n+\n ## vm.createContext([sandbox[, options]])\n <!-- YAML\n added: v0.3.1"
        },
        {
            "sha": "6ec40f9bcabeef2fac5e0d4989afd9e6ba3770e7",
            "filename": "lib/vm.js",
            "status": "modified",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/nodejs/node/blob/1abbe0a2123e8333922894258389c2d5c1568472/lib%2Fvm.js",
            "raw_url": "https://github.com/nodejs/node/raw/1abbe0a2123e8333922894258389c2d5c1568472/lib%2Fvm.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fvm.js?ref=1abbe0a2123e8333922894258389c2d5c1568472",
            "patch": "@@ -26,12 +26,17 @@ const {\n   ContextifyScript,\n   makeContext,\n   isContext: _isContext,\n+  compileFunction: _compileFunction\n } = internalBinding('contextify');\n+\n const { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\n const { isUint8Array } = require('internal/util/types');\n const { validateInt32, validateUint32 } = require('internal/validators');\n const kParsingContext = Symbol('script parsing context');\n \n+const ArrayForEach = Function.call.bind(Array.prototype.forEach);\n+const ArrayIsArray = Array.isArray;\n+\n class Script extends ContextifyScript {\n   constructor(code, options = {}) {\n     code = `${code}`;\n@@ -286,6 +291,94 @@ function runInThisContext(code, options) {\n   return createScript(code, options).runInThisContext(options);\n }\n \n+function compileFunction(code, params, options = {}) {\n+  if (typeof code !== 'string') {\n+    throw new ERR_INVALID_ARG_TYPE('code', 'string', code);\n+  }\n+  if (params !== undefined) {\n+    if (!ArrayIsArray(params)) {\n+      throw new ERR_INVALID_ARG_TYPE('params', 'Array', params);\n+    }\n+    ArrayForEach(params, (param, i) => {\n+      if (typeof param !== 'string') {\n+        throw new ERR_INVALID_ARG_TYPE(`params[${i}]`, 'string', param);\n+      }\n+    });\n+  }\n+\n+  const {\n+    filename = '',\n+    columnOffset = 0,\n+    lineOffset = 0,\n+    cachedData = undefined,\n+    produceCachedData = false,\n+    parsingContext = undefined,\n+    contextExtensions = [],\n+  } = options;\n+\n+  if (typeof filename !== 'string') {\n+    throw new ERR_INVALID_ARG_TYPE('options.filename', 'string', filename);\n+  }\n+  validateUint32(columnOffset, 'options.columnOffset');\n+  validateUint32(lineOffset, 'options.lineOffset');\n+  if (cachedData !== undefined && !isUint8Array(cachedData)) {\n+    throw new ERR_INVALID_ARG_TYPE(\n+      'options.cachedData',\n+      'Uint8Array',\n+      cachedData\n+    );\n+  }\n+  if (typeof produceCachedData !== 'boolean') {\n+    throw new ERR_INVALID_ARG_TYPE(\n+      'options.produceCachedData',\n+      'boolean',\n+      produceCachedData\n+    );\n+  }\n+  if (parsingContext !== undefined) {\n+    if (\n+      typeof parsingContext !== 'object' ||\n+      parsingContext === null ||\n+      !isContext(parsingContext)\n+    ) {\n+      throw new ERR_INVALID_ARG_TYPE(\n+        'options.parsingContext',\n+        'Context',\n+        parsingContext\n+      );\n+    }\n+  }\n+  if (!ArrayIsArray(contextExtensions)) {\n+    throw new ERR_INVALID_ARG_TYPE(\n+      'options.contextExtensions',\n+      'Array',\n+      contextExtensions\n+    );\n+  }\n+  ArrayForEach(contextExtensions, (extension, i) => {\n+    if (typeof extension !== 'object') {\n+      throw new ERR_INVALID_ARG_TYPE(\n+        `options.contextExtensions[${i}]`,\n+        'object',\n+        extension\n+      );\n+    }\n+  });\n+\n+  return _compileFunction(\n+    code,\n+    filename,\n+    lineOffset,\n+    columnOffset,\n+    cachedData,\n+    produceCachedData,\n+    parsingContext,\n+    contextExtensions,\n+    params\n+  );\n+}\n+\n+\n module.exports = {\n   Script,\n   createContext,\n@@ -294,6 +387,7 @@ module.exports = {\n   runInNewContext,\n   runInThisContext,\n   isContext,\n+  compileFunction,\n };\n \n if (process.binding('config').experimentalVMModules) {"
        },
        {
            "sha": "070c6bab604319f42ef47ece7a69ee8db3797206",
            "filename": "src/node_contextify.cc",
            "status": "modified",
            "additions": 139,
            "deletions": 0,
            "changes": 139,
            "blob_url": "https://github.com/nodejs/node/blob/1abbe0a2123e8333922894258389c2d5c1568472/src%2Fnode_contextify.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1abbe0a2123e8333922894258389c2d5c1568472/src%2Fnode_contextify.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.cc?ref=1abbe0a2123e8333922894258389c2d5c1568472",
            "patch": "@@ -209,6 +209,7 @@ void ContextifyContext::Init(Environment* env, Local<Object> target) {\n \n   env->SetMethod(target, \"makeContext\", MakeContext);\n   env->SetMethod(target, \"isContext\", IsContext);\n+  env->SetMethod(target, \"compileFunction\", CompileFunction);\n }\n \n \n@@ -987,6 +988,144 @@ class ContextifyScript : public BaseObject {\n };\n \n \n+void ContextifyContext::CompileFunction(\n+    const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  Local<Context> context = env->context();\n+\n+  // Argument 1: source code\n+  CHECK(args[0]->IsString());\n+  Local<String> code = args[0].As<String>();\n+\n+  // Argument 2: filename\n+  CHECK(args[1]->IsString());\n+  Local<String> filename = args[1].As<String>();\n+\n+  // Argument 3: line offset\n+  CHECK(args[2]->IsNumber());\n+  Local<Integer> line_offset = args[2].As<Integer>();\n+\n+  // Argument 4: column offset\n+  CHECK(args[3]->IsNumber());\n+  Local<Integer> column_offset = args[3].As<Integer>();\n+\n+  // Argument 5: cached data (optional)\n+  Local<Uint8Array> cached_data_buf;\n+  if (!args[4]->IsUndefined()) {\n+    CHECK(args[4]->IsUint8Array());\n+    cached_data_buf = args[4].As<Uint8Array>();\n+  }\n+\n+  // Argument 6: produce cache data\n+  CHECK(args[5]->IsBoolean());\n+  bool produce_cached_data = args[5]->IsTrue();\n+\n+  // Argument 7: parsing context (optional)\n+  Local<Context> parsing_context;\n+  if (!args[6]->IsUndefined()) {\n+    CHECK(args[6]->IsObject());\n+    ContextifyContext* sandbox =\n+        ContextifyContext::ContextFromContextifiedSandbox(\n+            env, args[6].As<Object>());\n+    CHECK_NOT_NULL(sandbox);\n+    parsing_context = sandbox->context();\n+  } else {\n+    parsing_context = context;\n+  }\n+\n+  // Argument 8: context extensions (optional)\n+  Local<Array> context_extensions_buf;\n+  if (!args[7]->IsUndefined()) {\n+    CHECK(args[7]->IsArray());\n+    context_extensions_buf = args[7].As<Array>();\n+  }\n+\n+  // Argument 9: params for the function (optional)\n+  Local<Array> params_buf;\n+  if (!args[8]->IsUndefined()) {\n+    CHECK(args[8]->IsArray());\n+    params_buf = args[8].As<Array>();\n+  }\n+\n+  // Read cache from cached data buffer\n+  ScriptCompiler::CachedData* cached_data = nullptr;\n+  if (!cached_data_buf.IsEmpty()) {\n+    ArrayBuffer::Contents contents = cached_data_buf->Buffer()->GetContents();\n+    uint8_t* data = static_cast<uint8_t*>(contents.Data());\n+    cached_data = new ScriptCompiler::CachedData(\n+      data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());\n+  }\n+\n+  ScriptOrigin origin(filename, line_offset, column_offset);\n+  ScriptCompiler::Source source(code, origin, cached_data);\n+  ScriptCompiler::CompileOptions options;\n+  if (source.GetCachedData() == nullptr) {\n+    options = ScriptCompiler::kNoCompileOptions;\n+  } else {\n+    options = ScriptCompiler::kConsumeCodeCache;\n+  }\n+\n+  TryCatch try_catch(isolate);\n+  Context::Scope scope(parsing_context);\n+\n+  // Read context extensions from buffer\n+  std::vector<Local<Object>> context_extensions;\n+  if (!context_extensions_buf.IsEmpty()) {\n+    for (uint32_t n = 0; n < context_extensions_buf->Length(); n++) {\n+      Local<Value> val;\n+      if (!context_extensions_buf->Get(context, n).ToLocal(&val)) return;\n+      CHECK(val->IsObject());\n+      context_extensions.push_back(val.As<Object>());\n+    }\n+  }\n+\n+  // Read params from params buffer\n+  std::vector<Local<String>> params;\n+  if (!params_buf.IsEmpty()) {\n+    for (uint32_t n = 0; n < params_buf->Length(); n++) {\n+      Local<Value> val;\n+      if (!params_buf->Get(context, n).ToLocal(&val)) return;\n+      CHECK(val->IsString());\n+      params.push_back(val.As<String>());\n+    }\n+  }\n+\n+  MaybeLocal<Function> maybe_fun = ScriptCompiler::CompileFunctionInContext(\n+      context, &source, params.size(), params.data(),\n+      context_extensions.size(), context_extensions.data(), options);\n+\n+  Local<Function> fun;\n+  if (maybe_fun.IsEmpty() || !maybe_fun.ToLocal(&fun)) {\n+    ContextifyScript::DecorateErrorStack(env, try_catch);\n+    try_catch.ReThrow();\n+    return;\n+  }\n+\n+  if (produce_cached_data) {\n+    const std::unique_ptr<ScriptCompiler::CachedData>\n+        cached_data(ScriptCompiler::CreateCodeCacheForFunction(fun, code));\n+    bool cached_data_produced = cached_data != nullptr;\n+    if (cached_data_produced) {\n+      MaybeLocal<Object> buf = Buffer::Copy(\n+          env,\n+          reinterpret_cast<const char*>(cached_data->data),\n+          cached_data->length);\n+      if (fun->Set(\n+          parsing_context,\n+          env->cached_data_string(),\n+          buf.ToLocalChecked()).IsNothing()) return;\n+    }\n+    if (fun->Set(\n+        parsing_context,\n+        env->cached_data_produced_string(),\n+        Boolean::New(isolate, cached_data_produced)).IsNothing()) return;\n+  }\n+\n+  args.GetReturnValue().Set(fun);\n+}\n+\n+\n void Initialize(Local<Object> target,\n                 Local<Value> unused,\n                 Local<Context> context) {"
        },
        {
            "sha": "965303a79bbdb1cd94a48530037cbbf2e88f269d",
            "filename": "src/node_contextify.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/1abbe0a2123e8333922894258389c2d5c1568472/src%2Fnode_contextify.h",
            "raw_url": "https://github.com/nodejs/node/raw/1abbe0a2123e8333922894258389c2d5c1568472/src%2Fnode_contextify.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.h?ref=1abbe0a2123e8333922894258389c2d5c1568472",
            "patch": "@@ -58,6 +58,8 @@ class ContextifyContext {\n  private:\n   static void MakeContext(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void IsContext(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void CompileFunction(\n+      const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void WeakCallback(\n       const v8::WeakCallbackInfo<ContextifyContext>& data);\n   static void PropertyGetterCallback("
        },
        {
            "sha": "c5adde4e5b2c4b8720755eaacddb1476a3933b62",
            "filename": "test/parallel/test-vm-basic.js",
            "status": "modified",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/nodejs/node/blob/1abbe0a2123e8333922894258389c2d5c1568472/test%2Fparallel%2Ftest-vm-basic.js",
            "raw_url": "https://github.com/nodejs/node/raw/1abbe0a2123e8333922894258389c2d5c1568472/test%2Fparallel%2Ftest-vm-basic.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-basic.js?ref=1abbe0a2123e8333922894258389c2d5c1568472",
            "patch": "@@ -128,3 +128,145 @@ const vm = require('vm');\n              'Received type object'\n   });\n });\n+\n+// vm.compileFunction\n+{\n+  assert.strictEqual(\n+    vm.compileFunction('console.log(\"Hello, World!\")').toString(),\n+    'function () {\\nconsole.log(\"Hello, World!\")\\n}'\n+  );\n+\n+  assert.strictEqual(\n+    vm.compileFunction(\n+      'return p + q + r + s + t',\n+      ['p', 'q', 'r', 's', 't']\n+    )('ab', 'cd', 'ef', 'gh', 'ij'),\n+    'abcdefghij'\n+  );\n+\n+  vm.compileFunction('return'); // Should not throw on 'return'\n+\n+  common.expectsError(() => {\n+    vm.compileFunction(\n+      '});\\n\\n(function() {\\nconsole.log(1);\\n})();\\n\\n(function() {'\n+    );\n+  }, {\n+    type: SyntaxError,\n+    message: 'Unexpected token }'\n+  });\n+\n+  // Tests for failed argument validation\n+  common.expectsError(() => vm.compileFunction(), {\n+    type: TypeError,\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    message: 'The \"code\" argument must be of type string. ' +\n+      'Received type undefined'\n+  });\n+\n+  vm.compileFunction(''); // Should pass without params or options\n+\n+  common.expectsError(() => vm.compileFunction('', null), {\n+    type: TypeError,\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    message: 'The \"params\" argument must be of type Array. ' +\n+      'Received type object'\n+  });\n+\n+  // vm.compileFunction('', undefined, null);\n+\n+  const optionTypes = {\n+    'filename': 'string',\n+    'columnOffset': 'number',\n+    'lineOffset': 'number',\n+    'cachedData': 'Uint8Array',\n+    'produceCachedData': 'boolean',\n+  };\n+\n+  for (const option in optionTypes) {\n+    common.expectsError(() => {\n+      vm.compileFunction('', undefined, { [option]: null });\n+    }, {\n+      type: TypeError,\n+      code: 'ERR_INVALID_ARG_TYPE',\n+      message: `The \"options.${option}\" property must be of type ` +\n+        `${optionTypes[option]}. Received type object`\n+    });\n+  }\n+\n+  // Testing for context-based failures\n+  [Boolean(), Number(), null, String(), Symbol(), {}].forEach(\n+    (value) => {\n+      common.expectsError(() => {\n+        vm.compileFunction('', undefined, { parsingContext: value });\n+      }, {\n+        type: TypeError,\n+        code: 'ERR_INVALID_ARG_TYPE',\n+        message: 'The \"options.parsingContext\" property must be of type ' +\n+          `Context. Received type ${typeof value}`\n+      });\n+    }\n+  );\n+\n+  assert.strictEqual(\n+    vm.compileFunction(\n+      'return a;',\n+      undefined,\n+      { contextExtensions: [{ a: 5 }] }\n+    )(),\n+    5\n+  );\n+\n+  common.expectsError(() => {\n+    vm.compileFunction('', undefined, { contextExtensions: null });\n+  }, {\n+    type: TypeError,\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    message: 'The \"options.contextExtensions\" property must be of type Array' +\n+       '. Received type object'\n+  });\n+\n+  common.expectsError(() => {\n+    vm.compileFunction('', undefined, { contextExtensions: [0] });\n+  }, {\n+    type: TypeError,\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    message: 'The \"options.contextExtensions[0]\" property must be of type ' +\n+       'object. Received type number'\n+  });\n+\n+  const oldLimit = Error.stackTraceLimit;\n+  // Setting value to run the last three tests\n+  Error.stackTraceLimit = 1;\n+\n+  common.expectsError(() => {\n+    vm.compileFunction('throw new Error(\"Sample Error\")')();\n+  }, {\n+    message: 'Sample Error',\n+    stack: 'Error: Sample Error\\n    at <anonymous>:1:7'\n+  });\n+\n+  common.expectsError(() => {\n+    vm.compileFunction(\n+      'throw new Error(\"Sample Error\")',\n+      [],\n+      { lineOffset: 3 }\n+    )();\n+  }, {\n+    message: 'Sample Error',\n+    stack: 'Error: Sample Error\\n    at <anonymous>:4:7'\n+  });\n+\n+  common.expectsError(() => {\n+    vm.compileFunction(\n+      'throw new Error(\"Sample Error\")',\n+      [],\n+      { columnOffset: 3 }\n+    )();\n+  }, {\n+    message: 'Sample Error',\n+    stack: 'Error: Sample Error\\n    at <anonymous>:1:10'\n+  });\n+\n+  // Resetting value\n+  Error.stackTraceLimit = oldLimit;\n+}"
        }
    ],
    "stats": {
        "total": 405,
        "additions": 405,
        "deletions": 0
    }
}