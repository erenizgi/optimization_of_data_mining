{
    "author": "BridgeAR",
    "message": "buffer: refactor all read/write functions\n\nThere are a lot of changes in this commit:\n\n1) Remove the `noAssert` argument from all read and write functions.\n2) Improve the performance of all read floating point functions\n   significantly. This is done by switching to TypedArrays as the\n   write floating point write functions.\n3) No implicit type coercion for offset and byteLength anymore.\n4) Adds a lot of tests.\n5) Moves the read and write functions to the internal buffer file\n   to split the files in smaller chunks.\n6) Reworked a lot of existing tests.\n7) Improve the performane of all all read write functions by using\n   a faster input validation and by improving function logic.\n8) Significantly improved the performance of all read int functions.\n   This is done by using a implementation without a loop.\n9) Improved error handling.\n10) Rename test file to use the correct subsystem.\n\nPR-URL: https://github.com/nodejs/node/pull/18395\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
    "files": [
        {
            "sha": "06c69f5abcf4e1f09a821b3f0d06cd139f7b3c6d",
            "filename": "doc/api/buffer.md",
            "status": "modified",
            "additions": 144,
            "deletions": 125,
            "changes": 269,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/doc%2Fapi%2Fbuffer.md",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/doc%2Fapi%2Fbuffer.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fbuffer.md?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -1538,31 +1538,32 @@ deprecated: v8.0.0\n \n The `buf.parent` property is a deprecated alias for `buf.buffer`.\n \n-### buf.readDoubleBE(offset[, noAssert])\n-### buf.readDoubleLE(offset[, noAssert])\n+### buf.readDoubleBE(offset)\n+### buf.readDoubleLE(offset)\n <!-- YAML\n added: v0.11.15\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.\n-* `noAssert` {boolean} Skip `offset` validation? **Default:** `false`\n * Returns: {number}\n \n Reads a 64-bit double from `buf` at the specified `offset` with specified\n endian format (`readDoubleBE()` returns big endian, `readDoubleLE()` returns\n little endian).\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);\n \n-console.log(buf.readDoubleBE());\n+console.log(buf.readDoubleBE(0));\n // Prints: 8.20788039913184e-304\n-console.log(buf.readDoubleLE());\n+console.log(buf.readDoubleLE(0));\n // Prints: 5.447603722011605e-270\n console.log(buf.readDoubleLE(1));\n // Throws an exception: RangeError: Index out of range\n@@ -1571,31 +1572,32 @@ console.log(buf.readDoubleLE(1, true));\n // This will result in a segmentation fault! Don't do this!\n ```\n \n-### buf.readFloatBE(offset[, noAssert])\n-### buf.readFloatLE(offset[, noAssert])\n+### buf.readFloatBE(offset)\n+### buf.readFloatLE(offset)\n <!-- YAML\n added: v0.11.15\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 4`.\n-* `noAssert` {boolean} Skip `offset` validation? **Default:** `false`\n * Returns: {number}\n \n Reads a 32-bit float from `buf` at the specified `offset` with specified\n endian format (`readFloatBE()` returns big endian, `readFloatLE()` returns\n little endian).\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n const buf = Buffer.from([1, 2, 3, 4]);\n \n-console.log(buf.readFloatBE());\n+console.log(buf.readFloatBE(0));\n // Prints: 2.387939260590663e-38\n-console.log(buf.readFloatLE());\n+console.log(buf.readFloatLE(0));\n // Prints: 1.539989614439558e-36\n console.log(buf.readFloatLE(1));\n // Throws an exception: RangeError: Index out of range\n@@ -1604,20 +1606,21 @@ console.log(buf.readFloatLE(1, true));\n // This will result in a segmentation fault! Don't do this!\n ```\n \n-### buf.readInt8(offset[, noAssert])\n+### buf.readInt8(offset)\n <!-- YAML\n added: v0.5.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 1`.\n-* `noAssert` {boolean} Skip `offset` validation? **Default:** `false`\n * Returns: {integer}\n \n Reads a signed 8-bit integer from `buf` at the specified `offset`.\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Integers read from a `Buffer` are interpreted as two's complement signed values.\n \n Examples:\n@@ -1633,88 +1636,91 @@ console.log(buf.readInt8(2));\n // Throws an exception: RangeError: Index out of range\n ```\n \n-### buf.readInt16BE(offset[, noAssert])\n-### buf.readInt16LE(offset[, noAssert])\n+### buf.readInt16BE(offset)\n+### buf.readInt16LE(offset)\n <!-- YAML\n added: v0.5.5\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 2`.\n-* `noAssert` {boolean} Skip `offset` validation? **Default:** `false`\n * Returns: {integer}\n \n Reads a signed 16-bit integer from `buf` at the specified `offset` with\n the specified endian format (`readInt16BE()` returns big endian,\n `readInt16LE()` returns little endian).\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Integers read from a `Buffer` are interpreted as two's complement signed values.\n \n Examples:\n \n ```js\n const buf = Buffer.from([0, 5]);\n \n-console.log(buf.readInt16BE());\n+console.log(buf.readInt16BE(0));\n // Prints: 5\n-console.log(buf.readInt16LE());\n+console.log(buf.readInt16LE(0));\n // Prints: 1280\n console.log(buf.readInt16LE(1));\n // Throws an exception: RangeError: Index out of range\n ```\n \n-### buf.readInt32BE(offset[, noAssert])\n-### buf.readInt32LE(offset[, noAssert])\n+### buf.readInt32BE(offset)\n+### buf.readInt32LE(offset)\n <!-- YAML\n added: v0.5.5\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 4`.\n-* `noAssert` {boolean} Skip `offset` validation? **Default:** `false`\n * Returns: {integer}\n \n Reads a signed 32-bit integer from `buf` at the specified `offset` with\n the specified endian format (`readInt32BE()` returns big endian,\n `readInt32LE()` returns little endian).\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Integers read from a `Buffer` are interpreted as two's complement signed values.\n \n Examples:\n \n ```js\n const buf = Buffer.from([0, 0, 0, 5]);\n \n-console.log(buf.readInt32BE());\n+console.log(buf.readInt32BE(0));\n // Prints: 5\n-console.log(buf.readInt32LE());\n+console.log(buf.readInt32LE(0));\n // Prints: 83886080\n console.log(buf.readInt32LE(1));\n // Throws an exception: RangeError: Index out of range\n ```\n \n-### buf.readIntBE(offset, byteLength[, noAssert])\n-### buf.readIntLE(offset, byteLength[, noAssert])\n+### buf.readIntBE(offset, byteLength)\n+### buf.readIntLE(offset, byteLength)\n <!-- YAML\n added: v0.11.15\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset and\n+                 byteLength to uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - byteLength`.\n * `byteLength` {integer} Number of bytes to read. Must satisfy: `0 < byteLength <= 6`.\n-* `noAssert` {boolean} Skip `offset` and `byteLength` validation? **Default:** `false`.\n * Returns: {integer}\n \n Reads `byteLength` number of bytes from `buf` at the specified `offset`\n and interprets the result as a two's complement signed value. Supports up to 48\n bits of accuracy.\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -1730,20 +1736,21 @@ console.log(buf.readIntBE(1, 0).toString(16));\n // Throws ERR_OUT_OF_RANGE:\n ```\n \n-### buf.readUInt8(offset[, noAssert])\n+### buf.readUInt8(offset)\n <!-- YAML\n added: v0.5.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 1`.\n-* `noAssert` {boolean} Skip `offset` validation? **Default:** `false`\n * Returns: {integer}\n \n Reads an unsigned 8-bit integer from `buf` at the specified `offset`.\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -1757,23 +1764,24 @@ console.log(buf.readUInt8(2));\n // Throws an exception: RangeError: Index out of range\n ```\n \n-### buf.readUInt16BE(offset[, noAssert])\n-### buf.readUInt16LE(offset[, noAssert])\n+### buf.readUInt16BE(offset)\n+### buf.readUInt16LE(offset)\n <!-- YAML\n added: v0.5.5\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 2`.\n-* `noAssert` {boolean} Skip `offset` validation? **Default:** `false`\n * Returns: {integer}\n \n Reads an unsigned 16-bit integer from `buf` at the specified `offset` with\n specified endian format (`readUInt16BE()` returns big endian, `readUInt16LE()`\n returns little endian).\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -1791,23 +1799,24 @@ console.log(buf.readUInt16LE(2).toString(16));\n // Throws an exception: RangeError: Index out of range\n ```\n \n-### buf.readUInt32BE(offset[, noAssert])\n-### buf.readUInt32LE(offset[, noAssert])\n+### buf.readUInt32BE(offset)\n+### buf.readUInt32LE(offset)\n <!-- YAML\n added: v0.5.5\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 4`.\n-* `noAssert` {boolean} Skip `offset` validation? **Default:** `false`\n * Returns: {integer}\n \n Reads an unsigned 32-bit integer from `buf` at the specified `offset` with\n specified endian format (`readUInt32BE()` returns big endian,\n `readUInt32LE()` returns little endian).\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -1821,24 +1830,25 @@ console.log(buf.readUInt32LE(1).toString(16));\n // Throws an exception: RangeError: Index out of range\n ```\n \n-### buf.readUIntBE(offset, byteLength[, noAssert])\n-### buf.readUIntLE(offset, byteLength[, noAssert])\n+### buf.readUIntBE(offset, byteLength)\n+### buf.readUIntLE(offset, byteLength)\n <!-- YAML\n added: v0.11.15\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset and\n+                 byteLength to uint32 anymore.\n -->\n \n * `offset` {integer} Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - byteLength`.\n * `byteLength` {integer} Number of bytes to read. Must satisfy: `0 < byteLength <= 6`.\n-* `noAssert` {boolean} Skip `offset` and `byteLength` validation? **Default:** `false`\n * Returns: {integer}\n \n Reads `byteLength` number of bytes from `buf` at the specified `offset`\n and interprets the result as an unsigned integer. Supports up to 48\n bits of accuracy.\n \n-Setting `noAssert` to `true` allows `offset` to be beyond the end of `buf`, but\n-the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -2149,25 +2159,26 @@ console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);\n // Prints: 12 bytes: ½ + ¼ = ¾\n ```\n \n-### buf.writeDoubleBE(value, offset[, noAssert])\n-### buf.writeDoubleLE(value, offset[, noAssert])\n+### buf.writeDoubleBE(value, offset)\n+### buf.writeDoubleLE(value, offset)\n <!-- YAML\n added: v0.11.15\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `value` {number} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.\n-* `noAssert` {boolean} Skip `value` and `offset` validation? **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `value` to `buf` at the specified `offset` with specified endian\n format (`writeDoubleBE()` writes big endian, `writeDoubleLE()` writes little\n endian). `value` *should* be a valid 64-bit double. Behavior is undefined when\n `value` is anything other than a 64-bit double.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -2184,25 +2195,26 @@ console.log(buf);\n // Prints: <Buffer d7 5f f9 dd b7 d5 eb 43>\n ```\n \n-### buf.writeFloatBE(value, offset[, noAssert])\n-### buf.writeFloatLE(value, offset[, noAssert])\n+### buf.writeFloatBE(value, offset)\n+### buf.writeFloatLE(value, offset)\n <!-- YAML\n added: v0.11.15\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `value` {number} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 4`.\n-* `noAssert` {boolean} Skip `value` and `offset` validation? **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `value` to `buf` at the specified `offset` with specified endian\n format (`writeFloatBE()` writes big endian, `writeFloatLE()` writes little\n endian). `value` *should* be a valid 32-bit float. Behavior is undefined when\n `value` is anything other than a 32-bit float.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -2219,23 +2231,24 @@ console.log(buf);\n // Prints: <Buffer bb fe 4a 4f>\n ```\n \n-### buf.writeInt8(value, offset[, noAssert])\n+### buf.writeInt8(value, offset)\n <!-- YAML\n added: v0.5.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `value` {integer} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 1`.\n-* `noAssert` {boolean} Skip `value` and `offset` validation? **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `value` to `buf` at the specified `offset`. `value` *should* be a valid\n signed 8-bit integer. Behavior is undefined when `value` is anything other than\n a signed 8-bit integer.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n `value` is interpreted and written as a two's complement signed integer.\n \n Examples:\n@@ -2250,25 +2263,26 @@ console.log(buf);\n // Prints: <Buffer 02 fe>\n ```\n \n-### buf.writeInt16BE(value, offset[, noAssert])\n-### buf.writeInt16LE(value, offset[, noAssert])\n+### buf.writeInt16BE(value, offset)\n+### buf.writeInt16LE(value, offset)\n <!-- YAML\n added: v0.5.5\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `value` {integer} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 2`.\n-* `noAssert` {boolean} Skip `value` and `offset` validation? **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `value` to `buf` at the specified `offset` with specified endian\n format (`writeInt16BE()` writes big endian, `writeInt16LE()` writes little\n endian). `value` *should* be a valid signed 16-bit integer. Behavior is undefined\n when `value` is anything other than a signed 16-bit integer.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n `value` is interpreted and written as a two's complement signed integer.\n \n Examples:\n@@ -2283,25 +2297,26 @@ console.log(buf);\n // Prints: <Buffer 01 02 04 03>\n ```\n \n-### buf.writeInt32BE(value, offset[, noAssert])\n-### buf.writeInt32LE(value, offset[, noAssert])\n+### buf.writeInt32BE(value, offset)\n+### buf.writeInt32LE(value, offset)\n <!-- YAML\n added: v0.5.5\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `value` {integer} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 4`.\n-* `noAssert` {boolean} Skip `value` and `offset` validation? **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `value` to `buf` at the specified `offset` with specified endian\n format (`writeInt32BE()` writes big endian, `writeInt32LE()` writes little\n endian). `value` *should* be a valid signed 32-bit integer. Behavior is undefined\n when `value` is anything other than a signed 32-bit integer.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n `value` is interpreted and written as a two's complement signed integer.\n \n Examples:\n@@ -2316,26 +2331,26 @@ console.log(buf);\n // Prints: <Buffer 01 02 03 04 08 07 06 05>\n ```\n \n-### buf.writeIntBE(value, offset, byteLength[, noAssert])\n-### buf.writeIntLE(value, offset, byteLength[, noAssert])\n+### buf.writeIntBE(value, offset, byteLength)\n+### buf.writeIntLE(value, offset, byteLength)\n <!-- YAML\n added: v0.11.15\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset and\n+                 byteLength to uint32 anymore.\n -->\n \n * `value` {integer} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - byteLength`.\n * `byteLength` {integer} Number of bytes to write. Must satisfy: `0 < byteLength <= 6`.\n-* `noAssert` {boolean} Skip `value`, `offset`, and `byteLength` validation?\n-  **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `byteLength` bytes of `value` to `buf` at the specified `offset`.\n Supports up to 48 bits of accuracy. Behavior is undefined when `value` is\n anything other than a signed integer.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -2352,23 +2367,24 @@ console.log(buf);\n // Prints: <Buffer ab 90 78 56 34 12>\n ```\n \n-### buf.writeUInt8(value, offset[, noAssert])\n+### buf.writeUInt8(value, offset)\n <!-- YAML\n added: v0.5.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `value` {integer} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 1`.\n-* `noAssert` {boolean} Skip `value` and `offset` validation? **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `value` to `buf` at the specified `offset`. `value` *should* be a\n valid unsigned 8-bit integer. Behavior is undefined when `value` is anything\n other than an unsigned 8-bit integer.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -2383,25 +2399,26 @@ console.log(buf);\n // Prints: <Buffer 03 04 23 42>\n ```\n \n-### buf.writeUInt16BE(value, offset[, noAssert])\n-### buf.writeUInt16LE(value, offset[, noAssert])\n+### buf.writeUInt16BE(value, offset)\n+### buf.writeUInt16LE(value, offset)\n <!-- YAML\n added: v0.5.5\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `value` {integer} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 2`.\n-* `noAssert` {boolean} Skip `value` and `offset` validation? **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `value` to `buf` at the specified `offset` with specified endian\n format (`writeUInt16BE()` writes big endian, `writeUInt16LE()` writes little\n endian). `value` should be a valid unsigned 16-bit integer. Behavior is\n undefined when `value` is anything other than an unsigned 16-bit integer.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -2420,25 +2437,26 @@ console.log(buf);\n // Prints: <Buffer ad de ef be>\n ```\n \n-### buf.writeUInt32BE(value, offset[, noAssert])\n-### buf.writeUInt32LE(value, offset[, noAssert])\n+### buf.writeUInt32BE(value, offset)\n+### buf.writeUInt32LE(value, offset)\n <!-- YAML\n added: v0.5.5\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset to\n+                 uint32 anymore.\n -->\n \n * `value` {integer} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 4`.\n-* `noAssert` {boolean} Skip `value` and `offset` validation? **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `value` to `buf` at the specified `offset` with specified endian\n format (`writeUInt32BE()` writes big endian, `writeUInt32LE()` writes little\n endian). `value` should be a valid unsigned 32-bit integer. Behavior is\n undefined when `value` is anything other than an unsigned 32-bit integer.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n Examples:\n \n ```js\n@@ -2455,26 +2473,27 @@ console.log(buf);\n // Prints: <Buffer ce fa ed fe>\n ```\n \n-### buf.writeUIntBE(value, offset, byteLength[, noAssert])\n-### buf.writeUIntLE(value, offset, byteLength[, noAssert])\n+### buf.writeUIntBE(value, offset, byteLength)\n+### buf.writeUIntLE(value, offset, byteLength)\n <!-- YAML\n added: v0.5.5\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18395\n+    description: Removed noAssert and no implicit coercion of the offset and\n+                 byteLength to uint32 anymore.\n -->\n \n * `value` {integer} Number to be written to `buf`.\n * `offset` {integer} Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - byteLength`.\n * `byteLength` {integer} Number of bytes to write. Must satisfy: `0 < byteLength <= 6`.\n-* `noAssert` {boolean} Skip `value`, `offset`, and `byteLength` validation?\n   **Default:** `false`\n * Returns: {integer} `offset` plus the number of bytes written.\n \n Writes `byteLength` bytes of `value` to `buf` at the specified `offset`.\n Supports up to 48 bits of accuracy. Behavior is undefined when `value` is\n anything other than an unsigned integer.\n \n-Setting `noAssert` to `true` allows the encoded form of `value` to extend beyond\n-the end of `buf`, but the resulting behavior is undefined.\n-\n Examples:\n \n ```js"
        },
        {
            "sha": "ead43b453d46ac0f375efb3daa8f2009bff528cf",
            "filename": "lib/buffer.js",
            "status": "modified",
            "additions": 4,
            "deletions": 551,
            "changes": 555,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/lib%2Fbuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/lib%2Fbuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fbuffer.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -68,6 +68,10 @@ internalBuffer.FastBuffer = FastBuffer;\n \n Buffer.prototype = FastBuffer.prototype;\n \n+for (const [name, method] of Object.entries(internalBuffer.readWrites)) {\n+  Buffer.prototype[name] = method;\n+}\n+\n const constants = Object.defineProperties({}, {\n   MAX_LENGTH: {\n     value: kMaxLength,\n@@ -81,12 +85,6 @@ const constants = Object.defineProperties({}, {\n   }\n });\n \n-// Temporary buffers to convert numbers.\n-const float32Array = new Float32Array(1);\n-const uInt8Float32Array = new Uint8Array(float32Array.buffer);\n-const float64Array = new Float64Array(1);\n-const uInt8Float64Array = new Uint8Array(float64Array.buffer);\n-\n Buffer.poolSize = 8 * 1024;\n var poolSize, poolOffset, allocPool;\n \n@@ -998,551 +996,6 @@ Buffer.prototype.slice = function slice(start, end) {\n   return new FastBuffer(this.buffer, this.byteOffset + start, newLength);\n };\n \n-function checkOffset(offset, ext, length) {\n-  if (offset + ext > length)\n-    throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n-}\n-\n-function checkByteLength(byteLength) {\n-  if (byteLength < 1 || byteLength > 6) {\n-    throw new errors.RangeError('ERR_OUT_OF_RANGE',\n-                                'byteLength',\n-                                '>= 1 and <= 6');\n-  }\n-}\n-\n-Buffer.prototype.readUIntLE =\n-  function readUIntLE(offset, byteLength, noAssert) {\n-    offset = offset >>> 0;\n-    byteLength = byteLength >>> 0;\n-    if (!noAssert) {\n-      checkByteLength(byteLength);\n-      checkOffset(offset, byteLength, this.length);\n-    }\n-\n-    var val = this[offset];\n-    var mul = 1;\n-    var i = 0;\n-    while (++i < byteLength && (mul *= 0x100))\n-      val += this[offset + i] * mul;\n-\n-    return val;\n-  };\n-\n-Buffer.prototype.readUIntBE =\n-  function readUIntBE(offset, byteLength, noAssert) {\n-    offset = offset >>> 0;\n-    byteLength = byteLength >>> 0;\n-    if (!noAssert) {\n-      checkByteLength(byteLength);\n-      checkOffset(offset, byteLength, this.length);\n-    }\n-\n-    var val = this[offset + --byteLength];\n-    var mul = 1;\n-    while (byteLength > 0 && (mul *= 0x100))\n-      val += this[offset + --byteLength] * mul;\n-\n-    return val;\n-  };\n-\n-Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 1, this.length);\n-  return this[offset];\n-};\n-\n-Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 2, this.length);\n-  return this[offset] | (this[offset + 1] << 8);\n-};\n-\n-Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 2, this.length);\n-  return (this[offset] << 8) | this[offset + 1];\n-};\n-\n-Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 4, this.length);\n-\n-  return ((this[offset]) |\n-      (this[offset + 1] << 8) |\n-      (this[offset + 2] << 16)) +\n-      (this[offset + 3] * 0x1000000);\n-};\n-\n-Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 4, this.length);\n-\n-  return (this[offset] * 0x1000000) +\n-      ((this[offset + 1] << 16) |\n-      (this[offset + 2] << 8) |\n-      this[offset + 3]);\n-};\n-\n-Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n-  offset = offset >>> 0;\n-  byteLength = byteLength >>> 0;\n-\n-  if (!noAssert) {\n-    checkByteLength(byteLength);\n-    checkOffset(offset, byteLength, this.length);\n-  }\n-\n-  var val = this[offset];\n-  var mul = 1;\n-  var i = 0;\n-  while (++i < byteLength && (mul *= 0x100))\n-    val += this[offset + i] * mul;\n-  mul *= 0x80;\n-\n-  if (val >= mul)\n-    val -= Math.pow(2, 8 * byteLength);\n-\n-  return val;\n-};\n-\n-Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n-  offset = offset >>> 0;\n-  byteLength = byteLength >>> 0;\n-\n-  if (!noAssert) {\n-    checkByteLength(byteLength);\n-    checkOffset(offset, byteLength, this.length);\n-  }\n-\n-  var i = byteLength;\n-  var mul = 1;\n-  var val = this[offset + --i];\n-  while (i > 0 && (mul *= 0x100))\n-    val += this[offset + --i] * mul;\n-  mul *= 0x80;\n-\n-  if (val >= mul)\n-    val -= Math.pow(2, 8 * byteLength);\n-\n-  return val;\n-};\n-\n-Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 1, this.length);\n-  var val = this[offset];\n-  return !(val & 0x80) ? val : (0xff - val + 1) * -1;\n-};\n-\n-Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 2, this.length);\n-  var val = this[offset] | (this[offset + 1] << 8);\n-  return (val & 0x8000) ? val | 0xFFFF0000 : val;\n-};\n-\n-Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 2, this.length);\n-  var val = this[offset + 1] | (this[offset] << 8);\n-  return (val & 0x8000) ? val | 0xFFFF0000 : val;\n-};\n-\n-Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 4, this.length);\n-\n-  return (this[offset]) |\n-      (this[offset + 1] << 8) |\n-      (this[offset + 2] << 16) |\n-      (this[offset + 3] << 24);\n-};\n-\n-Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOffset(offset, 4, this.length);\n-\n-  return (this[offset] << 24) |\n-      (this[offset + 1] << 16) |\n-      (this[offset + 2] << 8) |\n-      (this[offset + 3]);\n-};\n-\n-// For the casual reader who has not at the current time memorized the\n-// IEEE-754 standard in full detail: floating point numbers consist of\n-// a fraction, an exponent and a sign bit: 23+8+1 bits for single precision\n-// numbers and 52+11+1 bits for double precision numbers.\n-//\n-// A zero exponent is either a positive or negative zero, if the fraction\n-// is zero, or a denormalized number when it is non-zero.  Multiplying the\n-// fraction by the smallest possible denormal yields the denormalized number.\n-//\n-// An all-bits-one exponent is either a positive or negative infinity, if\n-// the fraction is zero, or NaN when it is non-zero.  The standard allows\n-// both quiet and signaling NaNs but since NaN is a canonical value in\n-// JavaScript, we cannot (and do not) distinguish between the two.\n-//\n-// Other exponents are regular numbers and are computed by subtracting the bias\n-// from the exponent (127 for single precision, 1023 for double precision),\n-// yielding an exponent in the ranges -126-127 and -1022-1024 respectively.\n-//\n-// Of interest is that the fraction of a normal number has an extra bit of\n-// precision that is not stored but is reconstructed by adding one after\n-// multiplying the fraction with the result of 2**-bits_in_fraction.\n-\n-function toDouble(x0, x1) {\n-  const frac = x0 + 0x100000000 * (x1 & 0xFFFFF);\n-  const expt = (x1 >>> 20) & 2047;\n-  const sign = (x1 >>> 31) ? -1 : 1;\n-  if (expt === 0) {\n-    if (frac === 0) return sign * 0;\n-    return sign * frac * 2 ** -1074;\n-  } else if (expt === 2047) {\n-    if (frac === 0) return sign * Infinity;\n-    return NaN;\n-  }\n-  return sign * 2 ** (expt - 1023) * (1 + frac * 2 ** -52);\n-}\n-\n-function toFloat(x) {\n-  const frac = x & 0x7FFFFF;\n-  const expt = (x >>> 23) & 255;\n-  const sign = (x >>> 31) ? -1 : 1;\n-  if (expt === 0) {\n-    if (frac === 0) return sign * 0;\n-    return sign * frac * 2 ** -149;\n-  } else if (expt === 255) {\n-    if (frac === 0) return sign * Infinity;\n-    return NaN;\n-  }\n-  return sign * 2 ** (expt - 127) * (1 + frac * 2 ** -23);\n-}\n-\n-Buffer.prototype.readDoubleBE = function(offset, noAssert) {\n-  offset = offset >>> 0;\n-  const x1 = this.readUInt32BE(offset + 0, noAssert);\n-  const x0 = this.readUInt32BE(offset + 4, noAssert);\n-  return toDouble(x0, x1);\n-};\n-\n-Buffer.prototype.readDoubleLE = function(offset, noAssert) {\n-  offset = offset >>> 0;\n-  const x0 = this.readUInt32LE(offset + 0, noAssert);\n-  const x1 = this.readUInt32LE(offset + 4, noAssert);\n-  return toDouble(x0, x1);\n-};\n-\n-Buffer.prototype.readFloatBE = function(offset, noAssert) {\n-  offset = offset >>> 0;\n-  return toFloat(this.readUInt32BE(offset, noAssert));\n-};\n-\n-Buffer.prototype.readFloatLE = function(offset, noAssert) {\n-  offset = offset >>> 0;\n-  return toFloat(this.readUInt32LE(offset, noAssert));\n-};\n-\n-function checkOOB(buffer, offset, ext) {\n-  if (offset + ext > buffer.length)\n-    throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n-}\n-\n-function checkInt(buffer, value, offset, ext, max, min) {\n-  if (value > max || value < min)\n-    throw new errors.RangeError('ERR_INVALID_OPT_VALUE', 'value', value);\n-  checkOOB(buffer, offset, ext);\n-}\n-\n-Buffer.prototype.writeUIntLE =\n-  function writeUIntLE(value, offset, byteLength, noAssert) {\n-    value = +value;\n-    offset = offset >>> 0;\n-    byteLength = byteLength >>> 0;\n-    if (!noAssert) {\n-      const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n-      checkInt(this, value, offset, byteLength, maxBytes, 0);\n-    }\n-\n-    var mul = 1;\n-    var i = 0;\n-    this[offset] = value;\n-    while (++i < byteLength && (mul *= 0x100))\n-      this[offset + i] = (value / mul) >>> 0;\n-\n-    return offset + byteLength;\n-  };\n-\n-Buffer.prototype.writeUIntBE =\n-  function writeUIntBE(value, offset, byteLength, noAssert) {\n-    value = +value;\n-    offset = offset >>> 0;\n-    byteLength = byteLength >>> 0;\n-    if (!noAssert) {\n-      const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n-      checkInt(this, value, offset, byteLength, maxBytes, 0);\n-    }\n-\n-    var i = byteLength - 1;\n-    var mul = 1;\n-    this[offset + i] = value;\n-    while (--i >= 0 && (mul *= 0x100))\n-      this[offset + i] = (value / mul) >>> 0;\n-\n-    return offset + byteLength;\n-  };\n-\n-Buffer.prototype.writeUInt8 =\n-  function writeUInt8(value, offset, noAssert) {\n-    value = +value;\n-    offset = offset >>> 0;\n-    if (!noAssert)\n-      checkInt(this, value, offset, 1, 0xff, 0);\n-    this[offset] = value;\n-    return offset + 1;\n-  };\n-\n-Buffer.prototype.writeUInt16LE =\n-  function writeUInt16LE(value, offset, noAssert) {\n-    value = +value;\n-    offset = offset >>> 0;\n-    if (!noAssert)\n-      checkInt(this, value, offset, 2, 0xffff, 0);\n-    this[offset] = value;\n-    this[offset + 1] = (value >>> 8);\n-    return offset + 2;\n-  };\n-\n-Buffer.prototype.writeUInt16BE =\n-  function writeUInt16BE(value, offset, noAssert) {\n-    value = +value;\n-    offset = offset >>> 0;\n-    if (!noAssert)\n-      checkInt(this, value, offset, 2, 0xffff, 0);\n-    this[offset] = (value >>> 8);\n-    this[offset + 1] = value;\n-    return offset + 2;\n-  };\n-\n-Buffer.prototype.writeUInt32LE =\n-  function writeUInt32LE(value, offset, noAssert) {\n-    value = +value;\n-    offset = offset >>> 0;\n-    if (!noAssert)\n-      checkInt(this, value, offset, 4, 0xffffffff, 0);\n-    this[offset + 3] = (value >>> 24);\n-    this[offset + 2] = (value >>> 16);\n-    this[offset + 1] = (value >>> 8);\n-    this[offset] = value;\n-    return offset + 4;\n-  };\n-\n-Buffer.prototype.writeUInt32BE =\n-  function writeUInt32BE(value, offset, noAssert) {\n-    value = +value;\n-    offset = offset >>> 0;\n-    if (!noAssert)\n-      checkInt(this, value, offset, 4, 0xffffffff, 0);\n-    this[offset] = (value >>> 24);\n-    this[offset + 1] = (value >>> 16);\n-    this[offset + 2] = (value >>> 8);\n-    this[offset + 3] = value;\n-    return offset + 4;\n-  };\n-\n-Buffer.prototype.writeIntLE =\n-  function writeIntLE(value, offset, byteLength, noAssert) {\n-    value = +value;\n-    offset = offset >>> 0;\n-    if (!noAssert) {\n-      checkInt(this,\n-               value,\n-               offset,\n-               byteLength,\n-               Math.pow(2, 8 * byteLength - 1) - 1,\n-               -Math.pow(2, 8 * byteLength - 1));\n-    }\n-\n-    var i = 0;\n-    var mul = 1;\n-    var sub = 0;\n-    this[offset] = value;\n-    while (++i < byteLength && (mul *= 0x100)) {\n-      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0)\n-        sub = 1;\n-      this[offset + i] = ((value / mul) >> 0) - sub;\n-    }\n-\n-    return offset + byteLength;\n-  };\n-\n-Buffer.prototype.writeIntBE =\n-  function writeIntBE(value, offset, byteLength, noAssert) {\n-    value = +value;\n-    offset = offset >>> 0;\n-    if (!noAssert) {\n-      checkInt(this,\n-               value,\n-               offset,\n-               byteLength,\n-               Math.pow(2, 8 * byteLength - 1) - 1,\n-               -Math.pow(2, 8 * byteLength - 1));\n-    }\n-\n-    var i = byteLength - 1;\n-    var mul = 1;\n-    var sub = 0;\n-    this[offset + i] = value;\n-    while (--i >= 0 && (mul *= 0x100)) {\n-      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0)\n-        sub = 1;\n-      this[offset + i] = ((value / mul) >> 0) - sub;\n-    }\n-\n-    return offset + byteLength;\n-  };\n-\n-Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n-  value = +value;\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkInt(this, value, offset, 1, 0x7f, -0x80);\n-  this[offset] = value;\n-  return offset + 1;\n-};\n-\n-Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n-  value = +value;\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n-  this[offset] = value;\n-  this[offset + 1] = (value >>> 8);\n-  return offset + 2;\n-};\n-\n-Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n-  value = +value;\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n-  this[offset] = (value >>> 8);\n-  this[offset + 1] = value;\n-  return offset + 2;\n-};\n-\n-Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n-  value = +value;\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n-  this[offset] = value;\n-  this[offset + 1] = (value >>> 8);\n-  this[offset + 2] = (value >>> 16);\n-  this[offset + 3] = (value >>> 24);\n-  return offset + 4;\n-};\n-\n-Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n-  value = +value;\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n-  this[offset] = (value >>> 24);\n-  this[offset + 1] = (value >>> 16);\n-  this[offset + 2] = (value >>> 8);\n-  this[offset + 3] = value;\n-  return offset + 4;\n-};\n-\n-function writeDoubleForwards(val, offset, noAssert) {\n-  val = +val;\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOOB(this, offset, 8);\n-\n-  float64Array[0] = val;\n-  this[offset++] = uInt8Float64Array[0];\n-  this[offset++] = uInt8Float64Array[1];\n-  this[offset++] = uInt8Float64Array[2];\n-  this[offset++] = uInt8Float64Array[3];\n-  this[offset++] = uInt8Float64Array[4];\n-  this[offset++] = uInt8Float64Array[5];\n-  this[offset++] = uInt8Float64Array[6];\n-  this[offset++] = uInt8Float64Array[7];\n-  return offset;\n-}\n-\n-function writeDoubleBackwards(val, offset, noAssert) {\n-  val = +val;\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOOB(this, offset, 8);\n-\n-  float64Array[0] = val;\n-  this[offset++] = uInt8Float64Array[7];\n-  this[offset++] = uInt8Float64Array[6];\n-  this[offset++] = uInt8Float64Array[5];\n-  this[offset++] = uInt8Float64Array[4];\n-  this[offset++] = uInt8Float64Array[3];\n-  this[offset++] = uInt8Float64Array[2];\n-  this[offset++] = uInt8Float64Array[1];\n-  this[offset++] = uInt8Float64Array[0];\n-  return offset;\n-}\n-\n-function writeFloatForwards(val, offset, noAssert) {\n-  val = +val;\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOOB(this, offset, 4);\n-\n-  float32Array[0] = val;\n-  this[offset++] = uInt8Float32Array[0];\n-  this[offset++] = uInt8Float32Array[1];\n-  this[offset++] = uInt8Float32Array[2];\n-  this[offset++] = uInt8Float32Array[3];\n-  return offset;\n-}\n-\n-function writeFloatBackwards(val, offset, noAssert) {\n-  val = +val;\n-  offset = offset >>> 0;\n-  if (!noAssert)\n-    checkOOB(this, offset, 4);\n-\n-  float32Array[0] = val;\n-  this[offset++] = uInt8Float32Array[3];\n-  this[offset++] = uInt8Float32Array[2];\n-  this[offset++] = uInt8Float32Array[1];\n-  this[offset++] = uInt8Float32Array[0];\n-  return offset;\n-}\n-\n-// Check endianness.\n-float32Array[0] = -1;\n-if (uInt8Float32Array[3] === 0) { // Big endian.\n-  Buffer.prototype.writeFloatLE = writeFloatBackwards;\n-  Buffer.prototype.writeFloatBE = writeFloatForwards;\n-  Buffer.prototype.writeDoubleLE = writeDoubleBackwards;\n-  Buffer.prototype.writeDoubleBE = writeDoubleForwards;\n-} else { // Small endian.\n-  Buffer.prototype.writeFloatLE = writeFloatForwards;\n-  Buffer.prototype.writeFloatBE = writeFloatBackwards;\n-  Buffer.prototype.writeDoubleLE = writeDoubleForwards;\n-  Buffer.prototype.writeDoubleBE = writeDoubleBackwards;\n-}\n-\n function swap(b, n, m) {\n   const i = b[n];\n   b[n] = b[m];"
        },
        {
            "sha": "b5da69a5b3e27bb9acdcbb4e4bbd219112461a03",
            "filename": "lib/internal/buffer.js",
            "status": "modified",
            "additions": 785,
            "deletions": 1,
            "changes": 786,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/lib%2Finternal%2Fbuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/lib%2Finternal%2Fbuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbuffer.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -1,13 +1,797 @@\n 'use strict';\n \n const binding = process.binding('buffer');\n+const { TypeError, RangeError } = require('internal/errors');\n const { setupBufferJS } = binding;\n \n // Remove from the binding so that function is only available as exported here.\n // (That is, for internal use only.)\n delete binding.setupBufferJS;\n \n+// Temporary buffers to convert numbers.\n+const float32Array = new Float32Array(1);\n+const uInt8Float32Array = new Uint8Array(float32Array.buffer);\n+const float64Array = new Float64Array(1);\n+const uInt8Float64Array = new Uint8Array(float64Array.buffer);\n+\n+// Check endianness.\n+float32Array[0] = -1;\n+const bigEndian = uInt8Float32Array[3] === 0;\n+\n+function checkBounds(buf, offset, byteLength) {\n+  checkNumberType(offset);\n+  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n+    boundsError(offset, buf.length - (byteLength + 1));\n+}\n+\n+function checkInt(value, min, max, buf, offset, byteLength) {\n+  if (value > max || value < min) {\n+    throw new RangeError('ERR_OUT_OF_RANGE',\n+                         'value', `>= ${min} and <= ${max}`, value);\n+  }\n+  checkBounds(buf, offset, byteLength);\n+}\n+\n+function checkNumberType(value, type) {\n+  if (typeof value !== 'number') {\n+    throw new TypeError('ERR_INVALID_ARG_TYPE',\n+                        type || 'offset', 'number', value);\n+  }\n+}\n+\n+function boundsError(value, length, type) {\n+  if (Math.floor(value) !== value) {\n+    checkNumberType(value, type);\n+    throw new RangeError('ERR_OUT_OF_RANGE',\n+                         type || 'offset', 'an integer', value);\n+  }\n+\n+  if (length < 0)\n+    throw new RangeError('ERR_BUFFER_OUT_OF_BOUNDS', null, true);\n+\n+  throw new RangeError('ERR_OUT_OF_RANGE',\n+                       type || 'offset',\n+                       `>= ${type ? 1 : 0} and <= ${length}`,\n+                       value);\n+}\n+\n+// Read integers.\n+function readUIntLE(offset, byteLength) {\n+  if (byteLength === 6)\n+    return readUInt48LE(this, offset);\n+  if (byteLength === 5)\n+    return readUInt40LE(this, offset);\n+  if (byteLength === 3)\n+    return readUInt24LE(this, offset);\n+  if (byteLength === 4)\n+    return this.readUInt32LE(offset);\n+  if (byteLength === 2)\n+    return this.readUInt16LE(offset);\n+  if (byteLength === 1)\n+    return this.readUInt8(offset);\n+\n+  boundsError(byteLength, 6, 'byteLength');\n+}\n+\n+function readUInt48LE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 5];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 6);\n+\n+  return first +\n+    buf[++offset] * 2 ** 8 +\n+    buf[++offset] * 2 ** 16 +\n+    buf[++offset] * 2 ** 24 +\n+    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n+}\n+\n+function readUInt40LE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 4];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 5);\n+\n+  return first +\n+    buf[++offset] * 2 ** 8 +\n+    buf[++offset] * 2 ** 16 +\n+    buf[++offset] * 2 ** 24 +\n+    last * 2 ** 32;\n+}\n+\n+function readUInt32LE(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 3];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 4);\n+\n+  return first +\n+    this[++offset] * 2 ** 8 +\n+    this[++offset] * 2 ** 16 +\n+    last * 2 ** 24;\n+}\n+\n+function readUInt24LE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 2];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 3);\n+\n+  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n+}\n+\n+function readUInt16LE(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 1];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 2);\n+\n+  return first + last * 2 ** 8;\n+}\n+\n+function readUInt8(offset) {\n+  checkNumberType(offset);\n+  const val = this[offset];\n+  if (val === undefined)\n+    boundsError(offset, this.length - 1);\n+\n+  return val;\n+}\n+\n+function readUIntBE(offset, byteLength) {\n+  if (byteLength === 6)\n+    return readUInt48BE(this, offset);\n+  if (byteLength === 5)\n+    return readUInt40BE(this, offset);\n+  if (byteLength === 3)\n+    return readUInt24BE(this, offset);\n+  if (byteLength === 4)\n+    return this.readUInt32BE(offset);\n+  if (byteLength === 2)\n+    return this.readUInt16BE(offset);\n+  if (byteLength === 1)\n+    return this.readUInt8(offset);\n+\n+  boundsError(byteLength, 6, 'byteLength');\n+}\n+\n+function readUInt48BE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 5];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 6);\n+\n+  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n+    buf[++offset] * 2 ** 24 +\n+    buf[++offset] * 2 ** 16 +\n+    buf[++offset] * 2 ** 8 +\n+    last;\n+}\n+\n+function readUInt40BE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 4];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 5);\n+\n+  return first * 2 ** 32 +\n+    buf[++offset] * 2 ** 24 +\n+    buf[++offset] * 2 ** 16 +\n+    buf[++offset] * 2 ** 8 +\n+    last;\n+}\n+\n+function readUInt32BE(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 3];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 4);\n+\n+  return first * 2 ** 24 +\n+    this[++offset] * 2 ** 16 +\n+    this[++offset] * 2 ** 8 +\n+    last;\n+}\n+\n+function readUInt24BE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 2];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 3);\n+\n+  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n+}\n+\n+function readUInt16BE(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 1];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 2);\n+\n+  return first * 2 ** 8 + last;\n+}\n+\n+function readIntLE(offset, byteLength) {\n+  if (byteLength === 6)\n+    return readInt48LE(this, offset);\n+  if (byteLength === 5)\n+    return readInt40LE(this, offset);\n+  if (byteLength === 3)\n+    return readInt24LE(this, offset);\n+  if (byteLength === 4)\n+    return this.readInt32LE(offset);\n+  if (byteLength === 2)\n+    return this.readInt16LE(offset);\n+  if (byteLength === 1)\n+    return this.readInt8(offset);\n+\n+  boundsError(byteLength, 6, 'byteLength');\n+}\n+\n+function readInt48LE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 5];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 6);\n+\n+  const val = buf[offset + 4] + last * 2 ** 8;\n+  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n+    first +\n+    buf[++offset] * 2 ** 8 +\n+    buf[++offset] * 2 ** 16 +\n+    buf[++offset] * 2 ** 24;\n+}\n+\n+function readInt40LE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 4];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 5);\n+\n+  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n+    first +\n+    buf[++offset] * 2 ** 8 +\n+    buf[++offset] * 2 ** 16 +\n+    buf[++offset] * 2 ** 24;\n+}\n+\n+function readInt32LE(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 3];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 4);\n+\n+  return first +\n+    this[++offset] * 2 ** 8 +\n+    this[++offset] * 2 ** 16 +\n+    (last << 24); // Overflow\n+}\n+\n+function readInt24LE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 2];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 3);\n+\n+  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n+  return val | (val & 2 ** 23) * 0x1fe;\n+}\n+\n+function readInt16LE(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 1];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 2);\n+\n+  const val = first + last * 2 ** 8;\n+  return val | (val & 2 ** 15) * 0x1fffe;\n+}\n+\n+function readInt8(offset) {\n+  checkNumberType(offset);\n+  const val = this[offset];\n+  if (val === undefined)\n+    boundsError(offset, this.length - 1);\n+\n+  return val | (val & 2 ** 7) * 0x1fffffe;\n+}\n+\n+function readIntBE(offset, byteLength) {\n+  if (byteLength === 6)\n+    return readInt48BE(this, offset);\n+  if (byteLength === 5)\n+    return readInt40BE(this, offset);\n+  if (byteLength === 3)\n+    return readInt24BE(this, offset);\n+  if (byteLength === 4)\n+    return this.readInt32BE(offset);\n+  if (byteLength === 2)\n+    return this.readInt16BE(offset);\n+  if (byteLength === 1)\n+    return this.readInt8(offset);\n+\n+  boundsError(byteLength, 6, 'byteLength');\n+}\n+\n+function readInt48BE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 5];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 6);\n+\n+  const val = buf[++offset] + first * 2 ** 8;\n+  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n+    buf[++offset] * 2 ** 24 +\n+    buf[++offset] * 2 ** 16 +\n+    buf[++offset] * 2 ** 8 +\n+    last;\n+}\n+\n+function readInt40BE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 4];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 5);\n+\n+  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n+    buf[++offset] * 2 ** 24 +\n+    buf[++offset] * 2 ** 16 +\n+    buf[++offset] * 2 ** 8 +\n+    last;\n+}\n+\n+function readInt32BE(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 3];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 4);\n+\n+  return (first << 24) + // Overflow\n+    this[++offset] * 2 ** 16 +\n+    this[++offset] * 2 ** 8 +\n+    last;\n+}\n+\n+function readInt24BE(buf, offset) {\n+  checkNumberType(offset);\n+  const first = buf[offset];\n+  const last = buf[offset + 2];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, buf.length - 3);\n+\n+  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n+  return val | (val & 2 ** 23) * 0x1fe;\n+}\n+\n+function readInt16BE(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 1];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 2);\n+\n+  const val = first * 2 ** 8 + last;\n+  return val | (val & 2 ** 15) * 0x1fffe;\n+}\n+\n+// Read floats\n+function readFloatBackwards(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 3];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 4);\n+\n+  uInt8Float32Array[3] = first;\n+  uInt8Float32Array[2] = this[++offset];\n+  uInt8Float32Array[1] = this[++offset];\n+  uInt8Float32Array[0] = last;\n+  return float32Array[0];\n+}\n+\n+function readFloatForwards(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 3];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 4);\n+\n+  uInt8Float32Array[0] = first;\n+  uInt8Float32Array[1] = this[++offset];\n+  uInt8Float32Array[2] = this[++offset];\n+  uInt8Float32Array[3] = last;\n+  return float32Array[0];\n+}\n+\n+function readDoubleBackwards(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 7];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 8);\n+\n+  uInt8Float64Array[7] = first;\n+  uInt8Float64Array[6] = this[++offset];\n+  uInt8Float64Array[5] = this[++offset];\n+  uInt8Float64Array[4] = this[++offset];\n+  uInt8Float64Array[3] = this[++offset];\n+  uInt8Float64Array[2] = this[++offset];\n+  uInt8Float64Array[1] = this[++offset];\n+  uInt8Float64Array[0] = last;\n+  return float64Array[0];\n+}\n+\n+function readDoubleForwards(offset) {\n+  checkNumberType(offset);\n+  const first = this[offset];\n+  const last = this[offset + 7];\n+  if (first === undefined || last === undefined)\n+    boundsError(offset, this.length - 8);\n+\n+  uInt8Float64Array[0] = first;\n+  uInt8Float64Array[1] = this[++offset];\n+  uInt8Float64Array[2] = this[++offset];\n+  uInt8Float64Array[3] = this[++offset];\n+  uInt8Float64Array[4] = this[++offset];\n+  uInt8Float64Array[5] = this[++offset];\n+  uInt8Float64Array[6] = this[++offset];\n+  uInt8Float64Array[7] = last;\n+  return float64Array[0];\n+}\n+\n+// Write integers.\n+function writeUIntLE(value, offset, byteLength) {\n+  if (byteLength === 6)\n+    return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);\n+  if (byteLength === 5)\n+    return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);\n+  if (byteLength === 3)\n+    return writeU_Int24LE(this, value, offset, 0, 0xffffff);\n+  if (byteLength === 4)\n+    return writeU_Int32LE(this, value, offset, 0, 0xffffffff);\n+  if (byteLength === 2)\n+    return writeU_Int16LE(this, value, offset, 0, 0xffff);\n+  if (byteLength === 1)\n+    return writeU_Int8(this, value, offset, 0, 0xff);\n+\n+  boundsError(byteLength, 6, 'byteLength');\n+}\n+\n+function writeU_Int48LE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 5);\n+\n+  const newVal = Math.floor(value * 2 ** -32);\n+  buf[offset++] = value;\n+  buf[offset++] = (value >>> 8);\n+  buf[offset++] = (value >>> 16);\n+  buf[offset++] = (value >>> 24);\n+  buf[offset++] = newVal;\n+  buf[offset++] = (newVal >>> 8);\n+  return offset;\n+}\n+\n+function writeU_Int40LE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 4);\n+\n+  const newVal = value;\n+  buf[offset++] = value;\n+  buf[offset++] = (value >>> 8);\n+  buf[offset++] = (value >>> 16);\n+  buf[offset++] = (value >>> 24);\n+  buf[offset++] = Math.floor(newVal * 2 ** -32);\n+  return offset;\n+}\n+\n+function writeU_Int32LE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 3);\n+\n+  buf[offset++] = value;\n+  buf[offset++] = (value >>> 8);\n+  buf[offset++] = (value >>> 16);\n+  buf[offset++] = (value >>> 24);\n+  return offset;\n+}\n+\n+function writeUInt32LE(value, offset) {\n+  return writeU_Int32LE(this, value, offset, 0, 0xffffffff);\n+}\n+\n+function writeU_Int24LE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 2);\n+\n+  buf[offset++] = value;\n+  buf[offset++] = (value >>> 8);\n+  buf[offset++] = (value >>> 16);\n+  return offset;\n+}\n+\n+function writeU_Int16LE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 1);\n+\n+  buf[offset++] = value;\n+  buf[offset++] = (value >>> 8);\n+  return offset;\n+}\n+\n+function writeUInt16LE(value, offset) {\n+  return writeU_Int16LE(this, value, offset, 0, 0xffff);\n+}\n+\n+function writeU_Int8(buf, value, offset, min, max) {\n+  value = +value;\n+  // `checkInt()` can not be used here because it checks two entries.\n+  checkNumberType(offset);\n+  if (value > max || value < min) {\n+    throw new RangeError('ERR_OUT_OF_RANGE',\n+                         'value',\n+                         `>= ${min} and <= ${max}`, value);\n+  }\n+  if (buf[offset] === undefined)\n+    boundsError(offset, buf.length - 1);\n+\n+  buf[offset] = value;\n+  return offset + 1;\n+}\n+\n+function writeUInt8(value, offset) {\n+  return writeU_Int8(this, value, offset, 0, 0xff);\n+}\n+\n+function writeUIntBE(value, offset, byteLength) {\n+  if (byteLength === 6)\n+    return writeU_Int48BE(this, value, offset, 0, 0xffffffffffffff);\n+  if (byteLength === 5)\n+    return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);\n+  if (byteLength === 3)\n+    return writeU_Int24BE(this, value, offset, 0, 0xffffff);\n+  if (byteLength === 4)\n+    return writeU_Int32BE(this, value, offset, 0, 0xffffffff);\n+  if (byteLength === 2)\n+    return writeU_Int16BE(this, value, offset, 0, 0xffff);\n+  if (byteLength === 1)\n+    return writeU_Int8(this, value, offset, 0, 0xff);\n+\n+  boundsError(byteLength, 6, 'byteLength');\n+}\n+\n+function writeU_Int48BE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 5);\n+\n+  const newVal = Math.floor(value * 2 ** -32);\n+  buf[offset++] = (newVal >>> 8);\n+  buf[offset++] = newVal;\n+  buf[offset++] = (value >>> 24);\n+  buf[offset++] = (value >>> 16);\n+  buf[offset++] = (value >>> 8);\n+  buf[offset++] = value;\n+  return offset;\n+}\n+\n+function writeU_Int40BE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 4);\n+\n+  buf[offset++] = Math.floor(value * 2 ** -32);\n+  buf[offset++] = (value >>> 24);\n+  buf[offset++] = (value >>> 16);\n+  buf[offset++] = (value >>> 8);\n+  buf[offset++] = value;\n+  return offset;\n+}\n+\n+function writeU_Int32BE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 3);\n+\n+  buf[offset++] = (value >>> 24);\n+  buf[offset++] = (value >>> 16);\n+  buf[offset++] = (value >>> 8);\n+  buf[offset++] = value;\n+  return offset;\n+}\n+\n+function writeUInt32BE(value, offset) {\n+  return writeU_Int32BE(this, value, offset, 0, 0xffffffff);\n+}\n+\n+function writeU_Int24BE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 2);\n+\n+  buf[offset++] = (value >>> 16);\n+  buf[offset++] = (value >>> 8);\n+  buf[offset++] = value;\n+  return offset;\n+}\n+\n+function writeU_Int16BE(buf, value, offset, min, max) {\n+  value = +value;\n+  checkInt(value, min, max, buf, offset, 1);\n+\n+  buf[offset++] = (value >>> 8);\n+  buf[offset++] = value;\n+  return offset;\n+}\n+\n+function writeUInt16BE(value, offset) {\n+  return writeU_Int16BE(this, value, offset, 0, 0xffffffff);\n+}\n+\n+function writeIntLE(value, offset, byteLength) {\n+  if (byteLength === 6)\n+    return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);\n+  if (byteLength === 5)\n+    return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);\n+  if (byteLength === 3)\n+    return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);\n+  if (byteLength === 4)\n+    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);\n+  if (byteLength === 2)\n+    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);\n+  if (byteLength === 1)\n+    return writeU_Int8(this, value, offset, -0x80, 0x7f);\n+\n+  boundsError(byteLength, 6, 'byteLength');\n+}\n+\n+function writeInt32LE(value, offset) {\n+  return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);\n+}\n+\n+function writeInt16LE(value, offset) {\n+  return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);\n+}\n+\n+function writeInt8(value, offset) {\n+  return writeU_Int8(this, value, offset, -0x80, 0x7f);\n+}\n+\n+function writeIntBE(value, offset, byteLength) {\n+  if (byteLength === 6)\n+    return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);\n+  if (byteLength === 5)\n+    return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);\n+  if (byteLength === 3)\n+    return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);\n+  if (byteLength === 4)\n+    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);\n+  if (byteLength === 2)\n+    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);\n+  if (byteLength === 1)\n+    return writeU_Int8(this, value, offset, -0x80, 0x7f);\n+\n+  boundsError(byteLength, 6, 'byteLength');\n+}\n+\n+function writeInt32BE(value, offset) {\n+  return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);\n+}\n+\n+function writeInt16BE(value, offset) {\n+  return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);\n+}\n+\n+// Write floats.\n+function writeDoubleForwards(val, offset) {\n+  val = +val;\n+  checkBounds(this, offset, 7);\n+\n+  float64Array[0] = val;\n+  this[offset++] = uInt8Float64Array[0];\n+  this[offset++] = uInt8Float64Array[1];\n+  this[offset++] = uInt8Float64Array[2];\n+  this[offset++] = uInt8Float64Array[3];\n+  this[offset++] = uInt8Float64Array[4];\n+  this[offset++] = uInt8Float64Array[5];\n+  this[offset++] = uInt8Float64Array[6];\n+  this[offset++] = uInt8Float64Array[7];\n+  return offset;\n+}\n+\n+function writeDoubleBackwards(val, offset) {\n+  val = +val;\n+  checkBounds(this, offset, 7);\n+\n+  float64Array[0] = val;\n+  this[offset++] = uInt8Float64Array[7];\n+  this[offset++] = uInt8Float64Array[6];\n+  this[offset++] = uInt8Float64Array[5];\n+  this[offset++] = uInt8Float64Array[4];\n+  this[offset++] = uInt8Float64Array[3];\n+  this[offset++] = uInt8Float64Array[2];\n+  this[offset++] = uInt8Float64Array[1];\n+  this[offset++] = uInt8Float64Array[0];\n+  return offset;\n+}\n+\n+function writeFloatForwards(val, offset) {\n+  val = +val;\n+  checkBounds(this, offset, 3);\n+\n+  float32Array[0] = val;\n+  this[offset++] = uInt8Float32Array[0];\n+  this[offset++] = uInt8Float32Array[1];\n+  this[offset++] = uInt8Float32Array[2];\n+  this[offset++] = uInt8Float32Array[3];\n+  return offset;\n+}\n+\n+function writeFloatBackwards(val, offset) {\n+  val = +val;\n+  checkBounds(this, offset, 3);\n+\n+  float32Array[0] = val;\n+  this[offset++] = uInt8Float32Array[3];\n+  this[offset++] = uInt8Float32Array[2];\n+  this[offset++] = uInt8Float32Array[1];\n+  this[offset++] = uInt8Float32Array[0];\n+  return offset;\n+}\n+\n // FastBuffer wil be inserted here by lib/buffer.js\n module.exports = {\n-  setupBufferJS\n+  setupBufferJS,\n+  // Container to export all read write functions.\n+  readWrites: {\n+    readUIntLE,\n+    readUInt32LE,\n+    readUInt16LE,\n+    readUInt8,\n+    readUIntBE,\n+    readUInt32BE,\n+    readUInt16BE,\n+    readIntLE,\n+    readInt32LE,\n+    readInt16LE,\n+    readInt8,\n+    readIntBE,\n+    readInt32BE,\n+    readInt16BE,\n+    writeUIntLE,\n+    writeUInt32LE,\n+    writeUInt16LE,\n+    writeUInt8,\n+    writeUIntBE,\n+    writeUInt32BE,\n+    writeUInt16BE,\n+    writeIntLE,\n+    writeInt32LE,\n+    writeInt16LE,\n+    writeInt8,\n+    writeIntBE,\n+    writeInt32BE,\n+    writeInt16BE,\n+    readFloatLE: bigEndian ? readFloatBackwards : readFloatForwards,\n+    readFloatBE: bigEndian ? readFloatForwards : readFloatBackwards,\n+    readDoubleLE: bigEndian ? readDoubleBackwards : readDoubleForwards,\n+    readDoubleBE: bigEndian ? readDoubleForwards : readDoubleBackwards,\n+    writeFloatLE: bigEndian ? writeFloatBackwards : writeFloatForwards,\n+    writeFloatBE: bigEndian ? writeFloatForwards : writeFloatBackwards,\n+    writeDoubleLE: bigEndian ? writeDoubleBackwards : writeDoubleForwards,\n+    writeDoubleBE: bigEndian ? writeDoubleForwards : writeDoubleBackwards\n+  }\n };"
        },
        {
            "sha": "b7f9359a00489c27263ea90142d04cd404364560",
            "filename": "test/parallel/test-buffer-arraybuffer.js",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-arraybuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-arraybuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-arraybuffer.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -42,13 +42,6 @@ assert.throws(function() {\n   Buffer.from(new AB());\n }, TypeError);\n \n-// write{Double,Float}{LE,BE} with noAssert should not crash, cf. #3766\n-const b = Buffer.allocUnsafe(1);\n-b.writeFloatLE(11.11, 0, true);\n-b.writeFloatBE(11.11, 0, true);\n-b.writeDoubleLE(11.11, 0, true);\n-b.writeDoubleBE(11.11, 0, true);\n-\n // Test the byteOffset and length arguments\n {\n   const ab = new Uint8Array(5);"
        },
        {
            "sha": "e6a4f872b8326090cfdfc171bc25dbcc3a54adc4",
            "filename": "test/parallel/test-buffer-read.js",
            "status": "modified",
            "additions": 2,
            "deletions": 23,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-read.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-read.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-read.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -6,16 +6,11 @@ const assert = require('assert');\n const buf = Buffer.from([0xa4, 0xfd, 0x48, 0xea, 0xcf, 0xff, 0xd9, 0x01, 0xde]);\n \n function read(buff, funx, args, expected) {\n-\n   assert.strictEqual(buff[funx](...args), expected);\n   common.expectsError(\n     () => buff[funx](-1, args[1]),\n-    {\n-      code: 'ERR_INDEX_OUT_OF_RANGE'\n-    }\n+    { code: 'ERR_OUT_OF_RANGE' }\n   );\n-\n-  assert.strictEqual(buff[funx](...args, true), expected);\n }\n \n // testing basic functionality of readDoubleBE() and readDoubleLE()\n@@ -123,7 +118,7 @@ assert.throws(() => Buffer.allocUnsafe(8).readFloatLE(-1), RangeError);\n                      (0xFFFFFFFF >> (32 - bits)));\n });\n \n-// test for common read(U)IntLE/BE\n+// Test for common read(U)IntLE/BE\n {\n   const buf = Buffer.from([0x01, 0x02, 0x03, 0x04, 0x05, 0x06]);\n \n@@ -144,19 +139,3 @@ assert.throws(() => Buffer.allocUnsafe(8).readFloatLE(-1), RangeError);\n   assert.strictEqual(buf.readIntLE(0, 6), 0x060504030201);\n   assert.strictEqual(buf.readIntBE(0, 6), 0x010203040506);\n }\n-\n-// test for byteLength parameter not between 1 and 6 (inclusive)\n-common.expectsError(() => { buf.readIntLE(1); }, { code: 'ERR_OUT_OF_RANGE' });\n-common.expectsError(() => { buf.readIntLE(1, 'string'); },\n-                    { code: 'ERR_OUT_OF_RANGE' });\n-common.expectsError(() => { buf.readIntLE(1, 0); },\n-                    { code: 'ERR_OUT_OF_RANGE' });\n-common.expectsError(() => { buf.readIntLE(1, 7); },\n-                    { code: 'ERR_OUT_OF_RANGE' });\n-common.expectsError(() => { buf.readIntBE(1); }, { code: 'ERR_OUT_OF_RANGE' });\n-common.expectsError(() => { buf.readIntBE(1, 'string'); },\n-                    { code: 'ERR_OUT_OF_RANGE' });\n-common.expectsError(() => { buf.readIntBE(1, 0); },\n-                    { code: 'ERR_OUT_OF_RANGE' });\n-common.expectsError(() => { buf.readIntBE(1, 7); },\n-                    { code: 'ERR_OUT_OF_RANGE' });"
        },
        {
            "sha": "2853142e3506ff9b9f8628da66a07975cbe27732",
            "filename": "test/parallel/test-buffer-readdouble.js",
            "status": "added",
            "additions": 138,
            "deletions": 0,
            "changes": 138,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-readdouble.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-readdouble.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-readdouble.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -0,0 +1,138 @@\n+'use strict';\n+\n+require('../common');\n+const assert = require('assert');\n+\n+// Test (64 bit) double\n+const buffer = Buffer.allocUnsafe(8);\n+\n+buffer[0] = 0x55;\n+buffer[1] = 0x55;\n+buffer[2] = 0x55;\n+buffer[3] = 0x55;\n+buffer[4] = 0x55;\n+buffer[5] = 0x55;\n+buffer[6] = 0xd5;\n+buffer[7] = 0x3f;\n+assert.strictEqual(buffer.readDoubleBE(0), 1.1945305291680097e+103);\n+assert.strictEqual(buffer.readDoubleLE(0), 0.3333333333333333);\n+\n+buffer[0] = 1;\n+buffer[1] = 0;\n+buffer[2] = 0;\n+buffer[3] = 0;\n+buffer[4] = 0;\n+buffer[5] = 0;\n+buffer[6] = 0xf0;\n+buffer[7] = 0x3f;\n+assert.strictEqual(buffer.readDoubleBE(0), 7.291122019655968e-304);\n+assert.strictEqual(buffer.readDoubleLE(0), 1.0000000000000002);\n+\n+buffer[0] = 2;\n+assert.strictEqual(buffer.readDoubleBE(0), 4.778309726801735e-299);\n+assert.strictEqual(buffer.readDoubleLE(0), 1.0000000000000004);\n+\n+buffer[0] = 1;\n+buffer[6] = 0;\n+buffer[7] = 0;\n+assert.strictEqual(buffer.readDoubleBE(0), 7.291122019556398e-304);\n+assert.strictEqual(buffer.readDoubleLE(0), 5e-324);\n+\n+buffer[0] = 0xff;\n+buffer[1] = 0xff;\n+buffer[2] = 0xff;\n+buffer[3] = 0xff;\n+buffer[4] = 0xff;\n+buffer[5] = 0xff;\n+buffer[6] = 0x0f;\n+buffer[7] = 0x00;\n+assert.ok(Number.isNaN(buffer.readDoubleBE(0)));\n+assert.strictEqual(buffer.readDoubleLE(0), 2.225073858507201e-308);\n+\n+buffer[6] = 0xef;\n+buffer[7] = 0x7f;\n+assert.ok(Number.isNaN(buffer.readDoubleBE(0)));\n+assert.strictEqual(buffer.readDoubleLE(0), 1.7976931348623157e+308);\n+\n+buffer[0] = 0;\n+buffer[1] = 0;\n+buffer[2] = 0;\n+buffer[3] = 0;\n+buffer[4] = 0;\n+buffer[5] = 0;\n+buffer[6] = 0xf0;\n+buffer[7] = 0x3f;\n+assert.strictEqual(buffer.readDoubleBE(0), 3.03865e-319);\n+assert.strictEqual(buffer.readDoubleLE(0), 1);\n+\n+buffer[6] = 0;\n+buffer[7] = 0x40;\n+assert.strictEqual(buffer.readDoubleBE(0), 3.16e-322);\n+assert.strictEqual(buffer.readDoubleLE(0), 2);\n+\n+buffer[7] = 0xc0;\n+assert.strictEqual(buffer.readDoubleBE(0), 9.5e-322);\n+assert.strictEqual(buffer.readDoubleLE(0), -2);\n+\n+buffer[6] = 0x10;\n+buffer[7] = 0;\n+assert.strictEqual(buffer.readDoubleBE(0), 2.0237e-320);\n+assert.strictEqual(buffer.readDoubleLE(0), 2.2250738585072014e-308);\n+\n+buffer[6] = 0;\n+assert.strictEqual(buffer.readDoubleBE(0), 0);\n+assert.strictEqual(buffer.readDoubleLE(0), 0);\n+assert.ok(1 / buffer.readDoubleLE(0) >= 0);\n+\n+buffer[7] = 0x80;\n+assert.strictEqual(buffer.readDoubleBE(0), 6.3e-322);\n+assert.strictEqual(buffer.readDoubleLE(0), -0);\n+assert.ok(1 / buffer.readDoubleLE(0) < 0);\n+\n+buffer[6] = 0xf0;\n+buffer[7] = 0x7f;\n+assert.strictEqual(buffer.readDoubleBE(0), 3.0418e-319);\n+assert.strictEqual(buffer.readDoubleLE(0), Infinity);\n+\n+buffer[7] = 0xff;\n+assert.strictEqual(buffer.readDoubleBE(0), 3.04814e-319);\n+assert.strictEqual(buffer.readDoubleLE(0), -Infinity);\n+\n+['readDoubleLE', 'readDoubleBE'].forEach((fn) => {\n+  ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((off) => {\n+    assert.throws(\n+      () => buffer[fn](off),\n+      { code: 'ERR_INVALID_ARG_TYPE' }\n+    );\n+  });\n+\n+  [Infinity, -1, 1].forEach((offset) => {\n+    assert.throws(\n+      () => buffer[fn](offset),\n+      {\n+        code: 'ERR_OUT_OF_RANGE',\n+        name: 'RangeError [ERR_OUT_OF_RANGE]',\n+        message: 'The value of \"offset\" is out of range. ' +\n+                 `It must be >= 0 and <= 0. Received ${offset}`\n+      });\n+  });\n+\n+  assert.throws(\n+    () => Buffer.alloc(1)[fn](1),\n+    {\n+      code: 'ERR_BUFFER_OUT_OF_BOUNDS',\n+      name: 'RangeError [ERR_BUFFER_OUT_OF_BOUNDS]',\n+      message: 'Attempt to write outside buffer bounds'\n+    });\n+\n+  [NaN, 1.01].forEach((offset) => {\n+    assert.throws(\n+      () => buffer[fn](offset),\n+      {\n+        code: 'ERR_OUT_OF_RANGE',\n+        name: 'RangeError [ERR_OUT_OF_RANGE]',\n+        message: 'The value of \"offset\" is out of range. ' +\n+                 `It must be an integer. Received ${offset}`\n+      });\n+  });\n+});"
        },
        {
            "sha": "8e1e0ba5bb34b29cf612903f6ac220a13e4598d3",
            "filename": "test/parallel/test-buffer-readfloat.js",
            "status": "added",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-readfloat.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-readfloat.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-readfloat.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -0,0 +1,101 @@\n+'use strict';\n+\n+require('../common');\n+const assert = require('assert');\n+\n+// Test 32 bit float\n+const buffer = Buffer.alloc(4);\n+\n+buffer[0] = 0;\n+buffer[1] = 0;\n+buffer[2] = 0x80;\n+buffer[3] = 0x3f;\n+assert.strictEqual(buffer.readFloatBE(0), 4.600602988224807e-41);\n+assert.strictEqual(buffer.readFloatLE(0), 1);\n+\n+buffer[0] = 0;\n+buffer[1] = 0;\n+buffer[2] = 0;\n+buffer[3] = 0xc0;\n+assert.strictEqual(buffer.readFloatBE(0), 2.6904930515036488e-43);\n+assert.strictEqual(buffer.readFloatLE(0), -2);\n+\n+buffer[0] = 0xff;\n+buffer[1] = 0xff;\n+buffer[2] = 0x7f;\n+buffer[3] = 0x7f;\n+assert.ok(Number.isNaN(buffer.readFloatBE(0)));\n+assert.strictEqual(buffer.readFloatLE(0), 3.4028234663852886e+38);\n+\n+buffer[0] = 0xab;\n+buffer[1] = 0xaa;\n+buffer[2] = 0xaa;\n+buffer[3] = 0x3e;\n+assert.strictEqual(buffer.readFloatBE(0), -1.2126478207002966e-12);\n+assert.strictEqual(buffer.readFloatLE(0), 0.3333333432674408);\n+\n+buffer[0] = 0;\n+buffer[1] = 0;\n+buffer[2] = 0;\n+buffer[3] = 0;\n+assert.strictEqual(buffer.readFloatBE(0), 0);\n+assert.strictEqual(buffer.readFloatLE(0), 0);\n+assert.ok(1 / buffer.readFloatLE(0) >= 0);\n+\n+buffer[3] = 0x80;\n+assert.strictEqual(buffer.readFloatBE(0), 1.793662034335766e-43);\n+assert.strictEqual(buffer.readFloatLE(0), -0);\n+assert.ok(1 / buffer.readFloatLE(0) < 0);\n+\n+buffer[0] = 0;\n+buffer[1] = 0;\n+buffer[2] = 0x80;\n+buffer[3] = 0x7f;\n+assert.strictEqual(buffer.readFloatBE(0), 4.609571298396486e-41);\n+assert.strictEqual(buffer.readFloatLE(0), Infinity);\n+\n+buffer[0] = 0;\n+buffer[1] = 0;\n+buffer[2] = 0x80;\n+buffer[3] = 0xff;\n+assert.strictEqual(buffer.readFloatBE(0), 4.627507918739843e-41);\n+assert.strictEqual(buffer.readFloatLE(0), -Infinity);\n+\n+['readFloatLE', 'readFloatBE'].forEach((fn) => {\n+  ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((off) => {\n+    assert.throws(\n+      () => buffer[fn](off),\n+      { code: 'ERR_INVALID_ARG_TYPE' }\n+    );\n+  });\n+\n+  [Infinity, -1, 1].forEach((offset) => {\n+    assert.throws(\n+      () => buffer[fn](offset),\n+      {\n+        code: 'ERR_OUT_OF_RANGE',\n+        name: 'RangeError [ERR_OUT_OF_RANGE]',\n+        message: 'The value of \"offset\" is out of range. ' +\n+                 `It must be >= 0 and <= 0. Received ${offset}`\n+      });\n+  });\n+\n+  assert.throws(\n+    () => Buffer.alloc(1)[fn](1),\n+    {\n+      code: 'ERR_BUFFER_OUT_OF_BOUNDS',\n+      name: 'RangeError [ERR_BUFFER_OUT_OF_BOUNDS]',\n+      message: 'Attempt to write outside buffer bounds'\n+    });\n+\n+  [NaN, 1.01].forEach((offset) => {\n+    assert.throws(\n+      () => buffer[fn](offset),\n+      {\n+        code: 'ERR_OUT_OF_RANGE',\n+        name: 'RangeError [ERR_OUT_OF_RANGE]',\n+        message: 'The value of \"offset\" is out of range. ' +\n+                 `It must be an integer. Received ${offset}`\n+      });\n+  });\n+});"
        },
        {
            "sha": "6cb11ee5a03ccebd4ee1d4a7fbf5f8326f92ff1b",
            "filename": "test/parallel/test-buffer-readint.js",
            "status": "added",
            "additions": 195,
            "deletions": 0,
            "changes": 195,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-readint.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-readint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-readint.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -0,0 +1,195 @@\n+'use strict';\n+\n+require('../common');\n+const assert = require('assert');\n+\n+// Test OOB\n+{\n+  const buffer = Buffer.alloc(4);\n+\n+  ['Int8', 'Int16BE', 'Int16LE', 'Int32BE', 'Int32LE'].forEach((fn) => {\n+    ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((o) => {\n+      assert.throws(\n+        () => buffer[`read${fn}`](o),\n+        {\n+          code: 'ERR_INVALID_ARG_TYPE',\n+          name: 'TypeError [ERR_INVALID_ARG_TYPE]'\n+        });\n+    });\n+\n+    [Infinity, -1, -4294967295].forEach((offset) => {\n+      assert.throws(\n+        () => buffer[`read${fn}`](offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]'\n+        });\n+    });\n+\n+    [NaN, 1.01].forEach((offset) => {\n+      assert.throws(\n+        () => buffer[`read${fn}`](offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"offset\" is out of range. ' +\n+                   `It must be an integer. Received ${offset}`\n+        });\n+    });\n+  });\n+}\n+\n+// Test 8 bit signed integers\n+{\n+  const data = Buffer.alloc(4);\n+\n+  data[0] = 0x23;\n+  assert.strictEqual(data.readInt8(0), 0x23);\n+\n+  data[0] = 0xff;\n+  assert.strictEqual(data.readInt8(0), -1);\n+\n+  data[0] = 0x87;\n+  data[1] = 0xab;\n+  data[2] = 0x7c;\n+  data[3] = 0xef;\n+  assert.strictEqual(data.readInt8(0), -121);\n+  assert.strictEqual(data.readInt8(1), -85);\n+  assert.strictEqual(data.readInt8(2), 124);\n+  assert.strictEqual(data.readInt8(3), -17);\n+}\n+\n+// Test 16 bit integers\n+{\n+  const buffer = Buffer.alloc(6);\n+\n+  buffer[0] = 0x16;\n+  buffer[1] = 0x79;\n+  assert.strictEqual(buffer.readInt16BE(0), 0x1679);\n+  assert.strictEqual(buffer.readInt16LE(0), 0x7916);\n+\n+  buffer[0] = 0xff;\n+  buffer[1] = 0x80;\n+  assert.strictEqual(buffer.readInt16BE(0), -128);\n+  assert.strictEqual(buffer.readInt16LE(0), -32513);\n+\n+  buffer[0] = 0x77;\n+  buffer[1] = 0x65;\n+  buffer[2] = 0x65;\n+  buffer[3] = 0x6e;\n+  buffer[4] = 0x69;\n+  buffer[5] = 0x78;\n+  assert.strictEqual(buffer.readInt16BE(0), 0x7765);\n+  assert.strictEqual(buffer.readInt16BE(1), 0x6565);\n+  assert.strictEqual(buffer.readInt16BE(2), 0x656e);\n+  assert.strictEqual(buffer.readInt16BE(3), 0x6e69);\n+  assert.strictEqual(buffer.readInt16BE(4), 0x6978);\n+  assert.strictEqual(buffer.readInt16LE(0), 0x6577);\n+  assert.strictEqual(buffer.readInt16LE(1), 0x6565);\n+  assert.strictEqual(buffer.readInt16LE(2), 0x6e65);\n+  assert.strictEqual(buffer.readInt16LE(3), 0x696e);\n+  assert.strictEqual(buffer.readInt16LE(4), 0x7869);\n+}\n+\n+// Test 32 bit integers\n+{\n+  const buffer = Buffer.alloc(6);\n+\n+  buffer[0] = 0x43;\n+  buffer[1] = 0x53;\n+  buffer[2] = 0x16;\n+  buffer[3] = 0x79;\n+  assert.strictEqual(buffer.readInt32BE(0), 0x43531679);\n+  assert.strictEqual(buffer.readInt32LE(0), 0x79165343);\n+\n+  buffer[0] = 0xff;\n+  buffer[1] = 0xfe;\n+  buffer[2] = 0xef;\n+  buffer[3] = 0xfa;\n+  assert.strictEqual(buffer.readInt32BE(0), -69638);\n+  assert.strictEqual(buffer.readInt32LE(0), -84934913);\n+\n+  buffer[0] = 0x42;\n+  buffer[1] = 0xc3;\n+  buffer[2] = 0x95;\n+  buffer[3] = 0xa9;\n+  buffer[4] = 0x36;\n+  buffer[5] = 0x17;\n+  assert.strictEqual(buffer.readInt32BE(0), 0x42c395a9);\n+  assert.strictEqual(buffer.readInt32BE(1), -1013601994);\n+  assert.strictEqual(buffer.readInt32BE(2), -1784072681);\n+  assert.strictEqual(buffer.readInt32LE(0), -1449802942);\n+  assert.strictEqual(buffer.readInt32LE(1), 917083587);\n+  assert.strictEqual(buffer.readInt32LE(2), 389458325);\n+}\n+\n+// Test Int\n+{\n+  const buffer = Buffer.alloc(8);\n+\n+  // Check byteLength.\n+  ['readIntBE', 'readIntLE'].forEach((fn) => {\n+    ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((len) => {\n+      assert.throws(\n+        () => buffer[fn](0, len),\n+        { code: 'ERR_INVALID_ARG_TYPE' });\n+    });\n+\n+    [Infinity, -1].forEach((byteLength) => {\n+      assert.throws(\n+        () => buffer[fn](0, byteLength),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          message: 'The value of \"byteLength\" is out of range. ' +\n+                   `It must be >= 1 and <= 6. Received ${byteLength}`\n+        });\n+    });\n+\n+    [NaN, 1.01].forEach((byteLength) => {\n+      assert.throws(\n+        () => buffer[fn](0, byteLength),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"byteLength\" is out of range. ' +\n+                   `It must be an integer. Received ${byteLength}`\n+        });\n+    });\n+  });\n+\n+  // Test 1 to 6 bytes.\n+  for (let i = 1; i < 6; i++) {\n+    ['readIntBE', 'readIntLE'].forEach((fn) => {\n+      ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((o) => {\n+        assert.throws(\n+          () => buffer[fn](o, i),\n+          {\n+            code: 'ERR_INVALID_ARG_TYPE',\n+            name: 'TypeError [ERR_INVALID_ARG_TYPE]'\n+          });\n+      });\n+\n+      [Infinity, -1, -4294967295].forEach((offset) => {\n+        assert.throws(\n+          () => buffer[fn](offset, i),\n+          {\n+            code: 'ERR_OUT_OF_RANGE',\n+            name: 'RangeError [ERR_OUT_OF_RANGE]',\n+            message: 'The value of \"offset\" is out of range. ' +\n+                     `It must be >= 0 and <= ${8 - i}. Received ${offset}`\n+          });\n+      });\n+\n+      [NaN, 1.01].forEach((offset) => {\n+        assert.throws(\n+          () => buffer[fn](offset, i),\n+          {\n+            code: 'ERR_OUT_OF_RANGE',\n+            name: 'RangeError [ERR_OUT_OF_RANGE]',\n+            message: 'The value of \"offset\" is out of range. ' +\n+                     `It must be an integer. Received ${offset}`\n+          });\n+      });\n+    });\n+  }\n+}"
        },
        {
            "sha": "a521e01129a09442a79762c222149f89b0f36be2",
            "filename": "test/parallel/test-buffer-write-noassert.js",
            "status": "removed",
            "additions": 0,
            "deletions": 95,
            "changes": 95,
            "blob_url": "https://github.com/nodejs/node/blob/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-buffer-write-noassert.js",
            "raw_url": "https://github.com/nodejs/node/raw/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-buffer-write-noassert.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-write-noassert.js?ref=a6c490cc8e8c848d6c4d5b8739827198055fe40f",
            "patch": "@@ -1,95 +0,0 @@\n-'use strict';\n-require('../common');\n-const assert = require('assert');\n-\n-// testing buffer write functions\n-\n-const outOfRange = /^RangeError\\b.*\\bIndex out of range$/;\n-\n-function write(funx, args, result, res) {\n-  {\n-    const buf = Buffer.alloc(9);\n-    assert.strictEqual(buf[funx](...args), result);\n-    assert.deepStrictEqual(buf, res);\n-  }\n-\n-  writeInvalidOffset(-1);\n-  writeInvalidOffset(9);\n-\n-  {\n-    const buf2 = Buffer.alloc(9);\n-    assert.strictEqual(buf2[funx](...args, true), result);\n-    assert.deepStrictEqual(buf2, res);\n-  }\n-\n-  function writeInvalidOffset(offset) {\n-    const newArgs = Array.from(args);\n-    newArgs[1] = offset;\n-    assert.throws(() => Buffer.alloc(9)[funx](...newArgs), outOfRange);\n-\n-    const buf = Buffer.alloc(9);\n-    buf[funx](...newArgs, true);\n-    assert.deepStrictEqual(buf, Buffer.alloc(9));\n-  }\n-}\n-\n-write('writeInt8', [1, 0], 1, Buffer.from([1, 0, 0, 0, 0, 0, 0, 0, 0]));\n-write('writeIntBE', [1, 1, 4], 5, Buffer.from([0, 0, 0, 0, 1, 0, 0, 0, 0]));\n-write('writeIntLE', [1, 1, 4], 5, Buffer.from([0, 1, 0, 0, 0, 0, 0, 0, 0]));\n-write('writeInt16LE', [1, 1], 3, Buffer.from([0, 1, 0, 0, 0, 0, 0, 0, 0]));\n-write('writeInt16BE', [1, 1], 3, Buffer.from([0, 0, 1, 0, 0, 0, 0, 0, 0]));\n-write('writeInt32LE', [1, 1], 5, Buffer.from([0, 1, 0, 0, 0, 0, 0, 0, 0]));\n-write('writeInt32BE', [1, 1], 5, Buffer.from([0, 0, 0, 0, 1, 0, 0, 0, 0]));\n-write('writeUInt8', [1, 0], 1, Buffer.from([1, 0, 0, 0, 0, 0, 0, 0, 0]));\n-write('writeUIntLE', [1, 1, 4], 5, Buffer.from([0, 1, 0, 0, 0, 0, 0, 0, 0]));\n-write('writeUIntBE', [1, 1, 4], 5, Buffer.from([0, 0, 0, 0, 1, 0, 0, 0, 0]));\n-write('writeUInt16LE', [1, 1], 3, Buffer.from([0, 1, 0, 0, 0, 0, 0, 0, 0]));\n-write('writeUInt16BE', [1, 1], 3, Buffer.from([0, 0, 1, 0, 0, 0, 0, 0, 0]));\n-write('writeUInt32LE', [1, 1], 5, Buffer.from([0, 1, 0, 0, 0, 0, 0, 0, 0]));\n-write('writeUInt32BE', [1, 1], 5, Buffer.from([0, 0, 0, 0, 1, 0, 0, 0, 0]));\n-write('writeDoubleBE', [1, 1], 9, Buffer.from([0, 63, 240, 0, 0, 0, 0, 0, 0]));\n-write('writeDoubleLE', [1, 1], 9, Buffer.from([0, 0, 0, 0, 0, 0, 0, 240, 63]));\n-write('writeFloatBE', [1, 1], 5, Buffer.from([0, 63, 128, 0, 0, 0, 0, 0, 0]));\n-write('writeFloatLE', [1, 1], 5, Buffer.from([0, 0, 0, 128, 63, 0, 0, 0, 0]));\n-\n-function writePartial(funx, args, result, res) {\n-  assert.throws(() => Buffer.alloc(9)[funx](...args), outOfRange);\n-  const buf = Buffer.alloc(9);\n-  assert.strictEqual(buf[funx](...args, true), result);\n-  assert.deepStrictEqual(buf, res);\n-}\n-\n-// Test partial writes (cases where the buffer isn't large enough to hold the\n-// entire value, but is large enough to hold parts of it).\n-writePartial('writeIntBE', [0x0eadbeef, 6, 4], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0x0e, 0xad, 0xbe]));\n-writePartial('writeIntLE', [0x0eadbeef, 6, 4], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0xef, 0xbe, 0xad]));\n-writePartial('writeInt16BE', [0x1234, 8], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0x12]));\n-writePartial('writeInt16LE', [0x1234, 8], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0x34]));\n-writePartial('writeInt32BE', [0x0eadbeef, 6], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0x0e, 0xad, 0xbe]));\n-writePartial('writeInt32LE', [0x0eadbeef, 6], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0xef, 0xbe, 0xad]));\n-writePartial('writeUIntBE', [0xdeadbeef, 6, 4], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0xde, 0xad, 0xbe]));\n-writePartial('writeUIntLE', [0xdeadbeef, 6, 4], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0xef, 0xbe, 0xad]));\n-writePartial('writeUInt16BE', [0x1234, 8], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0x12]));\n-writePartial('writeUInt16LE', [0x1234, 8], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0x34]));\n-writePartial('writeUInt32BE', [0xdeadbeef, 6], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0xde, 0xad, 0xbe]));\n-writePartial('writeUInt32LE', [0xdeadbeef, 6], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0xef, 0xbe, 0xad]));\n-writePartial('writeDoubleBE', [1, 2], 10,\n-             Buffer.from([0, 0, 63, 240, 0, 0, 0, 0, 0]));\n-writePartial('writeDoubleLE', [1, 2], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 240]));\n-writePartial('writeFloatBE', [1, 6], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 63, 128, 0]));\n-writePartial('writeFloatLE', [1, 6], 10,\n-             Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 128]));"
        },
        {
            "sha": "8f56e93f734deab7ad9a25ee7d35fd5018932b71",
            "filename": "test/parallel/test-buffer-writedouble.js",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-writedouble.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-writedouble.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-writedouble.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -0,0 +1,119 @@\n+'use strict';\n+\n+// Tests to verify doubles are correctly written\n+\n+require('../common');\n+const assert = require('assert');\n+\n+const buffer = Buffer.allocUnsafe(16);\n+\n+buffer.writeDoubleBE(2.225073858507201e-308, 0);\n+buffer.writeDoubleLE(2.225073858507201e-308, 8);\n+assert.ok(buffer.equals(new Uint8Array([\n+  0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00\n+])));\n+\n+buffer.writeDoubleBE(1.0000000000000004, 0);\n+buffer.writeDoubleLE(1.0000000000000004, 8);\n+assert.ok(buffer.equals(new Uint8Array([\n+  0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n+  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f\n+])));\n+\n+buffer.writeDoubleBE(-2, 0);\n+buffer.writeDoubleLE(-2, 8);\n+assert.ok(buffer.equals(new Uint8Array([\n+  0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0\n+])));\n+\n+buffer.writeDoubleBE(1.7976931348623157e+308, 0);\n+buffer.writeDoubleLE(1.7976931348623157e+308, 8);\n+assert.ok(buffer.equals(new Uint8Array([\n+  0x7f, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0x7f\n+])));\n+\n+buffer.writeDoubleBE(0 * -1, 0);\n+buffer.writeDoubleLE(0 * -1, 8);\n+assert.ok(buffer.equals(new Uint8Array([\n+  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80\n+])));\n+\n+buffer.writeDoubleBE(Infinity, 0);\n+buffer.writeDoubleLE(Infinity, 8);\n+\n+assert.ok(buffer.equals(new Uint8Array([\n+  0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x7F\n+])));\n+\n+assert.strictEqual(buffer.readDoubleBE(0), Infinity);\n+assert.strictEqual(buffer.readDoubleLE(8), Infinity);\n+\n+buffer.writeDoubleBE(-Infinity, 0);\n+buffer.writeDoubleLE(-Infinity, 8);\n+\n+assert.ok(buffer.equals(new Uint8Array([\n+  0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF\n+])));\n+\n+assert.strictEqual(buffer.readDoubleBE(0), -Infinity);\n+assert.strictEqual(buffer.readDoubleLE(8), -Infinity);\n+\n+buffer.writeDoubleBE(NaN, 0);\n+buffer.writeDoubleLE(NaN, 8);\n+\n+assert.ok(buffer.equals(new Uint8Array([\n+  0x7F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x7F\n+])));\n+\n+assert.ok(Number.isNaN(buffer.readDoubleBE(0)));\n+assert.ok(Number.isNaN(buffer.readDoubleLE(8)));\n+\n+// OOB in writeDouble{LE,BE} should throw.\n+{\n+  const small = Buffer.allocUnsafe(1);\n+\n+  ['writeDoubleLE', 'writeDoubleBE'].forEach((fn) => {\n+    assert.throws(\n+      () => small[fn](11.11, 0),\n+      {\n+        code: 'ERR_BUFFER_OUT_OF_BOUNDS',\n+        name: 'RangeError [ERR_BUFFER_OUT_OF_BOUNDS]',\n+        message: 'Attempt to write outside buffer bounds'\n+      });\n+\n+    ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((off) => {\n+      assert.throws(\n+        () => small[fn](23, off),\n+        { code: 'ERR_INVALID_ARG_TYPE' });\n+    });\n+\n+    [Infinity, -1, 9].forEach((offset) => {\n+      assert.throws(\n+        () => buffer[fn](23, offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"offset\" is out of range. ' +\n+                     `It must be >= 0 and <= 8. Received ${offset}`\n+        });\n+    });\n+\n+    [NaN, 1.01].forEach((offset) => {\n+      assert.throws(\n+        () => buffer[fn](42, offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"offset\" is out of range. ' +\n+                   `It must be an integer. Received ${offset}`\n+        });\n+    });\n+  });\n+}"
        },
        {
            "sha": "865b8838dae5dd0cc14566216324842947986c15",
            "filename": "test/parallel/test-buffer-writefloat.js",
            "status": "added",
            "additions": 102,
            "deletions": 0,
            "changes": 102,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-writefloat.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-writefloat.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-writefloat.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -0,0 +1,102 @@\n+'use strict';\n+\n+// Tests to verify floats are correctly written\n+\n+require('../common');\n+const assert = require('assert');\n+\n+const buffer = Buffer.allocUnsafe(8);\n+\n+buffer.writeFloatBE(1, 0);\n+buffer.writeFloatLE(1, 4);\n+assert.ok(buffer.equals(\n+  new Uint8Array([ 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f ])));\n+\n+buffer.writeFloatBE(1 / 3, 0);\n+buffer.writeFloatLE(1 / 3, 4);\n+assert.ok(buffer.equals(\n+  new Uint8Array([ 0x3e, 0xaa, 0xaa, 0xab, 0xab, 0xaa, 0xaa, 0x3e ])));\n+\n+buffer.writeFloatBE(3.4028234663852886e+38, 0);\n+buffer.writeFloatLE(3.4028234663852886e+38, 4);\n+assert.ok(buffer.equals(\n+  new Uint8Array([ 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f ])));\n+\n+buffer.writeFloatLE(1.1754943508222875e-38, 0);\n+buffer.writeFloatBE(1.1754943508222875e-38, 4);\n+assert.ok(buffer.equals(\n+  new Uint8Array([ 0x00, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00 ])));\n+\n+buffer.writeFloatBE(0 * -1, 0);\n+buffer.writeFloatLE(0 * -1, 4);\n+assert.ok(buffer.equals(\n+  new Uint8Array([ 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80 ])));\n+\n+buffer.writeFloatBE(Infinity, 0);\n+buffer.writeFloatLE(Infinity, 4);\n+assert.ok(buffer.equals(\n+  new Uint8Array([ 0x7F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7F ])));\n+\n+assert.strictEqual(buffer.readFloatBE(0), Infinity);\n+assert.strictEqual(buffer.readFloatLE(4), Infinity);\n+\n+buffer.writeFloatBE(-Infinity, 0);\n+buffer.writeFloatLE(-Infinity, 4);\n+assert.ok(buffer.equals(\n+  new Uint8Array([ 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF ])));\n+\n+assert.strictEqual(buffer.readFloatBE(0), -Infinity);\n+assert.strictEqual(buffer.readFloatLE(4), -Infinity);\n+\n+buffer.writeFloatBE(NaN, 0);\n+buffer.writeFloatLE(NaN, 4);\n+assert.ok(buffer.equals(\n+  new Uint8Array([ 0x7F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F ])));\n+\n+assert.ok(Number.isNaN(buffer.readFloatBE(0)));\n+assert.ok(Number.isNaN(buffer.readFloatLE(4)));\n+\n+// OOB in writeFloat{LE,BE} should throw.\n+{\n+  const small = Buffer.allocUnsafe(1);\n+\n+  ['writeFloatLE', 'writeFloatBE'].forEach((fn) => {\n+    assert.throws(\n+      () => small[fn](11.11, 0),\n+      {\n+        code: 'ERR_BUFFER_OUT_OF_BOUNDS',\n+        name: 'RangeError [ERR_BUFFER_OUT_OF_BOUNDS]',\n+        message: 'Attempt to write outside buffer bounds'\n+      });\n+\n+    ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((off) => {\n+      assert.throws(\n+        () => small[fn](23, off),\n+        { code: 'ERR_INVALID_ARG_TYPE' }\n+      );\n+    });\n+\n+    [Infinity, -1, 5].forEach((offset) => {\n+      assert.throws(\n+        () => buffer[fn](23, offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"offset\" is out of range. ' +\n+                   `It must be >= 0 and <= 4. Received ${offset}`\n+        }\n+      );\n+    });\n+\n+    [NaN, 1.01].forEach((offset) => {\n+      assert.throws(\n+        () => buffer[fn](42, offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"offset\" is out of range. ' +\n+                   `It must be an integer. Received ${offset}`\n+        });\n+    });\n+  });\n+}"
        },
        {
            "sha": "adddb35afee75ec0cfc3fd67a4b498d834fff7ca",
            "filename": "test/parallel/test-buffer-writeint.js",
            "status": "added",
            "additions": 235,
            "deletions": 0,
            "changes": 235,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-writeint.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-writeint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-writeint.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -0,0 +1,235 @@\n+'use strict';\n+\n+// Tests to verify signed integers are correctly written\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const errorOutOfBounds = common.expectsError({\n+  code: 'ERR_OUT_OF_RANGE',\n+  type: RangeError,\n+  message: new RegExp('^The value of \"value\" is out of range\\\\. ' +\n+                      'It must be >= -\\\\d+ and <= \\\\d+\\\\. Received .+$')\n+}, 10);\n+\n+// Test 8 bit\n+{\n+  const buffer = Buffer.alloc(2);\n+\n+  buffer.writeInt8(0x23, 0);\n+  buffer.writeInt8(-5, 1);\n+  assert.ok(buffer.equals(new Uint8Array([ 0x23, 0xfb ])));\n+\n+  /* Make sure we handle min/max correctly */\n+  buffer.writeInt8(0x7f, 0);\n+  buffer.writeInt8(-0x80, 1);\n+  assert.ok(buffer.equals(new Uint8Array([ 0x7f, 0x80 ])));\n+\n+  assert.throws(() => {\n+    buffer.writeInt8(0x7f + 1, 0);\n+  }, errorOutOfBounds);\n+  assert.throws(() => {\n+    buffer.writeInt8(-0x80 - 1, 0);\n+  }, errorOutOfBounds);\n+\n+  ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((off) => {\n+    assert.throws(\n+      () => buffer.writeInt8(23, off),\n+      { code: 'ERR_INVALID_ARG_TYPE' });\n+  });\n+\n+  [NaN, Infinity, -1, 1.01].forEach((off) => {\n+    assert.throws(\n+      () => buffer.writeInt8(23, off),\n+      { code: 'ERR_OUT_OF_RANGE' });\n+  });\n+}\n+\n+// Test 16 bit\n+{\n+  const buffer = Buffer.alloc(4);\n+\n+  buffer.writeInt16BE(0x0023, 0);\n+  buffer.writeInt16LE(0x0023, 2);\n+  assert.ok(buffer.equals(new Uint8Array([ 0x00, 0x23, 0x23, 0x00 ])));\n+\n+  buffer.writeInt16BE(-5, 0);\n+  buffer.writeInt16LE(-5, 2);\n+  assert.ok(buffer.equals(new Uint8Array([ 0xff, 0xfb, 0xfb, 0xff ])));\n+\n+  buffer.writeInt16BE(-1679, 0);\n+  buffer.writeInt16LE(-1679, 2);\n+  assert.ok(buffer.equals(new Uint8Array([ 0xf9, 0x71, 0x71, 0xf9 ])));\n+\n+  /* Make sure we handle min/max correctly */\n+  buffer.writeInt16BE(0x7fff, 0);\n+  buffer.writeInt16BE(-0x8000, 2);\n+  assert.ok(buffer.equals(new Uint8Array([ 0x7f, 0xff, 0x80, 0x00 ])));\n+\n+  buffer.writeInt16LE(0x7fff, 0);\n+  buffer.writeInt16LE(-0x8000, 2);\n+  assert.ok(buffer.equals(new Uint8Array([ 0xff, 0x7f, 0x00, 0x80 ])));\n+\n+  ['writeInt16BE', 'writeInt16LE'].forEach((fn) => {\n+    assert.throws(() => {\n+      buffer[fn](0x7fff + 1, 0);\n+    }, errorOutOfBounds);\n+    assert.throws(() => {\n+      buffer[fn](-0x8000 - 1, 0);\n+    }, errorOutOfBounds);\n+\n+    ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((off) => {\n+      assert.throws(\n+        () => buffer[fn](23, off),\n+        { code: 'ERR_INVALID_ARG_TYPE' });\n+    });\n+\n+    [NaN, Infinity, -1, 1.01].forEach((off) => {\n+      assert.throws(\n+        () => buffer[fn](23, off),\n+        { code: 'ERR_OUT_OF_RANGE' });\n+    });\n+  });\n+}\n+\n+// Test 32 bit\n+{\n+  const buffer = Buffer.alloc(8);\n+\n+  buffer.writeInt32BE(0x23, 0);\n+  buffer.writeInt32LE(0x23, 4);\n+  assert.ok(buffer.equals(new Uint8Array([\n+    0x00, 0x00, 0x00, 0x23, 0x23, 0x00, 0x00, 0x00\n+  ])));\n+\n+  buffer.writeInt32BE(-5, 0);\n+  buffer.writeInt32LE(-5, 4);\n+  assert.ok(buffer.equals(new Uint8Array([\n+    0xff, 0xff, 0xff, 0xfb, 0xfb, 0xff, 0xff, 0xff\n+  ])));\n+\n+  buffer.writeInt32BE(-805306713, 0);\n+  buffer.writeInt32LE(-805306713, 4);\n+  assert.ok(buffer.equals(new Uint8Array([\n+    0xcf, 0xff, 0xfe, 0xa7, 0xa7, 0xfe, 0xff, 0xcf\n+  ])));\n+\n+  /* Make sure we handle min/max correctly */\n+  buffer.writeInt32BE(0x7fffffff, 0);\n+  buffer.writeInt32BE(-0x80000000, 4);\n+  assert.ok(buffer.equals(new Uint8Array([\n+    0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00\n+  ])));\n+\n+  buffer.writeInt32LE(0x7fffffff, 0);\n+  buffer.writeInt32LE(-0x80000000, 4);\n+  assert.ok(buffer.equals(new Uint8Array([\n+    0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x80\n+  ])));\n+\n+  ['writeInt32BE', 'writeInt32LE'].forEach((fn) => {\n+    assert.throws(() => {\n+      buffer[fn](0x7fffffff + 1, 0);\n+    }, errorOutOfBounds);\n+    assert.throws(() => {\n+      buffer[fn](-0x80000000 - 1, 0);\n+    }, errorOutOfBounds);\n+\n+    ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((off) => {\n+      assert.throws(\n+        () => buffer[fn](23, off),\n+        { code: 'ERR_INVALID_ARG_TYPE' });\n+    });\n+\n+    [NaN, Infinity, -1, 1.01].forEach((off) => {\n+      assert.throws(\n+        () => buffer[fn](23, off),\n+        { code: 'ERR_OUT_OF_RANGE' });\n+    });\n+  });\n+}\n+\n+// Test Int\n+{\n+  const data = Buffer.alloc(8);\n+\n+  // Check byteLength.\n+  ['writeIntBE', 'writeIntLE'].forEach((fn) => {\n+    ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((o) => {\n+      assert.throws(\n+        () => data[fn](23, 0, o),\n+        { code: 'ERR_INVALID_ARG_TYPE' });\n+    });\n+\n+    [Infinity, -1].forEach((offset) => {\n+      assert.throws(\n+        () => data[fn](23, 0, offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          message: 'The value of \"byteLength\" is out of range. ' +\n+                   `It must be >= 1 and <= 6. Received ${offset}`\n+        }\n+      );\n+    });\n+\n+    [NaN, 1.01].forEach((byteLength) => {\n+      assert.throws(\n+        () => data[fn](42, 0, byteLength),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"byteLength\" is out of range. ' +\n+                   `It must be an integer. Received ${byteLength}`\n+        });\n+    });\n+  });\n+\n+  // Test 1 to 6 bytes.\n+  for (let i = 1; i < 6; i++) {\n+    ['writeIntBE', 'writeIntLE'].forEach((fn) => {\n+      const min = -(2 ** (i * 8 - 1));\n+      const max = 2 ** (i * 8 - 1) - 1;\n+\n+      [min - 1, max + 1].forEach((val) => {\n+        assert.throws(() => {\n+          data[fn](val, 0, i);\n+        }, {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"value\" is out of range. ' +\n+                   `It must be >= ${min} and <= ${max}. Received ${val}`\n+        });\n+      });\n+\n+      ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((o) => {\n+        assert.throws(\n+          () => data[fn](min, o, i),\n+          {\n+            code: 'ERR_INVALID_ARG_TYPE',\n+            name: 'TypeError [ERR_INVALID_ARG_TYPE]'\n+          });\n+      });\n+\n+      [Infinity, -1, -4294967295].forEach((offset) => {\n+        assert.throws(\n+          () => data[fn](min, offset, i),\n+          {\n+            code: 'ERR_OUT_OF_RANGE',\n+            name: 'RangeError [ERR_OUT_OF_RANGE]',\n+            message: 'The value of \"offset\" is out of range. ' +\n+                     `It must be >= 0 and <= ${8 - i}. Received ${offset}`\n+          });\n+      });\n+\n+      [NaN, 1.01].forEach((offset) => {\n+        assert.throws(\n+          () => data[fn](max, offset, i),\n+          {\n+            code: 'ERR_OUT_OF_RANGE',\n+            name: 'RangeError [ERR_OUT_OF_RANGE]',\n+            message: 'The value of \"offset\" is out of range. ' +\n+                     `It must be an integer. Received ${offset}`\n+          });\n+      });\n+    });\n+  }\n+}"
        },
        {
            "sha": "3d6f81264195a60d89a95022910c106b0e262af6",
            "filename": "test/parallel/test-buffer-writeuint.js",
            "status": "added",
            "additions": 190,
            "deletions": 0,
            "changes": 190,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-writeuint.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-buffer-writeuint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-writeuint.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "patch": "@@ -0,0 +1,190 @@\n+'use strict';\n+\n+require('../common');\n+const assert = require('assert');\n+\n+/*\n+ * We need to check the following things:\n+ *  - We are correctly resolving big endian (doesn't mean anything for 8 bit)\n+ *  - Correctly resolving little endian (doesn't mean anything for 8 bit)\n+ *  - Correctly using the offsets\n+ *  - Correctly interpreting values that are beyond the signed range as unsigned\n+ */\n+\n+{ // OOB\n+  const data = Buffer.alloc(8);\n+  ['UInt8', 'UInt16BE', 'UInt16LE', 'UInt32BE', 'UInt32LE'].forEach((fn) => {\n+    ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((o) => {\n+      assert.throws(\n+        () => data[`write${fn}`](23, o),\n+        { code: 'ERR_INVALID_ARG_TYPE' });\n+    });\n+\n+    [NaN, Infinity, -1, 1.01].forEach((o) => {\n+      assert.throws(\n+        () => data[`write${fn}`](23, o),\n+        { code: 'ERR_OUT_OF_RANGE' });\n+    });\n+  });\n+}\n+\n+{ // Test 8 bit\n+  const data = Buffer.alloc(4);\n+\n+  data.writeUInt8(23, 0);\n+  data.writeUInt8(23, 1);\n+  data.writeUInt8(23, 2);\n+  data.writeUInt8(23, 3);\n+  assert.ok(data.equals(new Uint8Array([23, 23, 23, 23])));\n+\n+  data.writeUInt8(23, 0);\n+  data.writeUInt8(23, 1);\n+  data.writeUInt8(23, 2);\n+  data.writeUInt8(23, 3);\n+  assert.ok(data.equals(new Uint8Array([23, 23, 23, 23])));\n+\n+  data.writeUInt8(255, 0);\n+  assert.strictEqual(data[0], 255);\n+\n+  data.writeUInt8(255, 0);\n+  assert.strictEqual(data[0], 255);\n+}\n+\n+// Test 16 bit\n+{\n+  let value = 0x2343;\n+  const data = Buffer.alloc(4);\n+\n+  data.writeUInt16BE(value, 0);\n+  assert.ok(data.equals(new Uint8Array([0x23, 0x43, 0, 0])));\n+\n+  data.writeUInt16BE(value, 1);\n+  assert.ok(data.equals(new Uint8Array([0x23, 0x23, 0x43, 0])));\n+\n+  data.writeUInt16BE(value, 2);\n+  assert.ok(data.equals(new Uint8Array([0x23, 0x23, 0x23, 0x43])));\n+\n+  data.writeUInt16LE(value, 0);\n+  assert.ok(data.equals(new Uint8Array([0x43, 0x23, 0x23, 0x43])));\n+\n+  data.writeUInt16LE(value, 1);\n+  assert.ok(data.equals(new Uint8Array([0x43, 0x43, 0x23, 0x43])));\n+\n+  data.writeUInt16LE(value, 2);\n+  assert.ok(data.equals(new Uint8Array([0x43, 0x43, 0x43, 0x23])));\n+\n+  value = 0xff80;\n+  data.writeUInt16LE(value, 0);\n+  assert.ok(data.equals(new Uint8Array([0x80, 0xff, 0x43, 0x23])));\n+\n+  data.writeUInt16BE(value, 0);\n+  assert.ok(data.equals(new Uint8Array([0xff, 0x80, 0x43, 0x23])));\n+}\n+\n+// Test 32 bit\n+{\n+  const data = Buffer.alloc(6);\n+  const value = 0xe7f90a6d;\n+\n+  data.writeUInt32BE(value, 0);\n+  assert.ok(data.equals(new Uint8Array([0xe7, 0xf9, 0x0a, 0x6d, 0, 0])));\n+\n+  data.writeUInt32BE(value, 1);\n+  assert.ok(data.equals(new Uint8Array([0xe7, 0xe7, 0xf9, 0x0a, 0x6d, 0])));\n+\n+  data.writeUInt32BE(value, 2);\n+  assert.ok(data.equals(new Uint8Array([0xe7, 0xe7, 0xe7, 0xf9, 0x0a, 0x6d])));\n+\n+  data.writeUInt32LE(value, 0);\n+  assert.ok(data.equals(new Uint8Array([0x6d, 0x0a, 0xf9, 0xe7, 0x0a, 0x6d])));\n+\n+  data.writeUInt32LE(value, 1);\n+  assert.ok(data.equals(new Uint8Array([0x6d, 0x6d, 0x0a, 0xf9, 0xe7, 0x6d])));\n+\n+  data.writeUInt32LE(value, 2);\n+  assert.ok(data.equals(new Uint8Array([0x6d, 0x6d, 0x6d, 0x0a, 0xf9, 0xe7])));\n+}\n+\n+// Test UInt\n+{\n+  const data = Buffer.alloc(8);\n+  let val = 0x100;\n+\n+  // Check byteLength.\n+  ['writeUIntBE', 'writeUIntLE'].forEach((fn) => {\n+    ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((o) => {\n+      assert.throws(\n+        () => data[fn](23, 0, o),\n+        { code: 'ERR_INVALID_ARG_TYPE' });\n+    });\n+\n+    [Infinity, -1].forEach((offset) => {\n+      assert.throws(\n+        () => data[fn](23, 0, offset),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          message: 'The value of \"byteLength\" is out of range. ' +\n+                   `It must be >= 1 and <= 6. Received ${offset}`\n+        }\n+      );\n+    });\n+\n+    [NaN, 1.01].forEach((byteLength) => {\n+      assert.throws(\n+        () => data[fn](42, 0, byteLength),\n+        {\n+          code: 'ERR_OUT_OF_RANGE',\n+          name: 'RangeError [ERR_OUT_OF_RANGE]',\n+          message: 'The value of \"byteLength\" is out of range. ' +\n+                   `It must be an integer. Received ${byteLength}`\n+        });\n+    });\n+  });\n+\n+  // Test 1 to 6 bytes.\n+  for (let i = 1; i < 6; i++) {\n+    ['writeUIntBE', 'writeUIntLE'].forEach((fn) => {\n+      assert.throws(() => {\n+        data[fn](val, 0, i);\n+      }, {\n+        code: 'ERR_OUT_OF_RANGE',\n+        name: 'RangeError [ERR_OUT_OF_RANGE]',\n+        message: 'The value of \"value\" is out of range. ' +\n+                 `It must be >= 0 and <= ${val - 1}. Received ${val}`\n+      });\n+\n+      ['', '0', null, undefined, {}, [], () => {}, true, false].forEach((o) => {\n+        assert.throws(\n+          () => data[fn](23, o, i),\n+          {\n+            code: 'ERR_INVALID_ARG_TYPE',\n+            name: 'TypeError [ERR_INVALID_ARG_TYPE]'\n+          });\n+      });\n+\n+      [Infinity, -1, -4294967295].forEach((offset) => {\n+        assert.throws(\n+          () => data[fn](val - 1, offset, i),\n+          {\n+            code: 'ERR_OUT_OF_RANGE',\n+            name: 'RangeError [ERR_OUT_OF_RANGE]',\n+            message: 'The value of \"offset\" is out of range. ' +\n+                     `It must be >= 0 and <= ${8 - i}. Received ${offset}`\n+          });\n+      });\n+\n+      [NaN, 1.01].forEach((offset) => {\n+        assert.throws(\n+          () => data[fn](val - 1, offset, i),\n+          {\n+            code: 'ERR_OUT_OF_RANGE',\n+            name: 'RangeError [ERR_OUT_OF_RANGE]',\n+            message: 'The value of \"offset\" is out of range. ' +\n+                     `It must be an integer. Received ${offset}`\n+          });\n+      });\n+    });\n+\n+    val *= 0x100;\n+  }\n+}"
        },
        {
            "sha": "c59fc18108c2b9f373e63e152aa7b829e129ff1c",
            "filename": "test/parallel/test-http-zerolengthbuffer.js",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-http-zerolengthbuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e/test%2Fparallel%2Ftest-http-zerolengthbuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-zerolengthbuffer.js?ref=e8bb1f35df079cf0111fc18a8a24ec0a2d66eb3e",
            "previous_filename": "test/parallel/test-zerolengthbufferbug.js"
        },
        {
            "sha": "f635edba9038d327485499cf44c18b58602ddbd0",
            "filename": "test/parallel/test-readdouble.js",
            "status": "removed",
            "additions": 0,
            "deletions": 129,
            "changes": 129,
            "blob_url": "https://github.com/nodejs/node/blob/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-readdouble.js",
            "raw_url": "https://github.com/nodejs/node/raw/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-readdouble.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-readdouble.js?ref=a6c490cc8e8c848d6c4d5b8739827198055fe40f",
            "patch": "@@ -1,129 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-'use strict';\n-/*\n- * Tests to verify we're reading in doubles correctly\n- */\n-require('../common');\n-const assert = require('assert');\n-\n-/*\n- * Test (64 bit) double\n- */\n-const buffer = Buffer.allocUnsafe(8);\n-\n-buffer[0] = 0x55;\n-buffer[1] = 0x55;\n-buffer[2] = 0x55;\n-buffer[3] = 0x55;\n-buffer[4] = 0x55;\n-buffer[5] = 0x55;\n-buffer[6] = 0xd5;\n-buffer[7] = 0x3f;\n-assert.strictEqual(1.1945305291680097e+103, buffer.readDoubleBE(0));\n-assert.strictEqual(0.3333333333333333, buffer.readDoubleLE(0));\n-\n-buffer[0] = 1;\n-buffer[1] = 0;\n-buffer[2] = 0;\n-buffer[3] = 0;\n-buffer[4] = 0;\n-buffer[5] = 0;\n-buffer[6] = 0xf0;\n-buffer[7] = 0x3f;\n-assert.strictEqual(7.291122019655968e-304, buffer.readDoubleBE(0));\n-assert.strictEqual(1.0000000000000002, buffer.readDoubleLE(0));\n-\n-buffer[0] = 2;\n-assert.strictEqual(4.778309726801735e-299, buffer.readDoubleBE(0));\n-assert.strictEqual(1.0000000000000004, buffer.readDoubleLE(0));\n-\n-buffer[0] = 1;\n-buffer[6] = 0;\n-buffer[7] = 0;\n-assert.strictEqual(7.291122019556398e-304, buffer.readDoubleBE(0));\n-assert.strictEqual(5e-324, buffer.readDoubleLE(0));\n-\n-buffer[0] = 0xff;\n-buffer[1] = 0xff;\n-buffer[2] = 0xff;\n-buffer[3] = 0xff;\n-buffer[4] = 0xff;\n-buffer[5] = 0xff;\n-buffer[6] = 0x0f;\n-buffer[7] = 0x00;\n-assert.ok(Number.isNaN(buffer.readDoubleBE(0)));\n-assert.strictEqual(2.225073858507201e-308, buffer.readDoubleLE(0));\n-\n-buffer[6] = 0xef;\n-buffer[7] = 0x7f;\n-assert.ok(Number.isNaN(buffer.readDoubleBE(0)));\n-assert.strictEqual(1.7976931348623157e+308, buffer.readDoubleLE(0));\n-\n-buffer[0] = 0;\n-buffer[1] = 0;\n-buffer[2] = 0;\n-buffer[3] = 0;\n-buffer[4] = 0;\n-buffer[5] = 0;\n-buffer[6] = 0xf0;\n-buffer[7] = 0x3f;\n-assert.strictEqual(3.03865e-319, buffer.readDoubleBE(0));\n-assert.strictEqual(1, buffer.readDoubleLE(0));\n-\n-buffer[6] = 0;\n-buffer[7] = 0x40;\n-assert.strictEqual(3.16e-322, buffer.readDoubleBE(0));\n-assert.strictEqual(2, buffer.readDoubleLE(0));\n-\n-buffer[7] = 0xc0;\n-assert.strictEqual(9.5e-322, buffer.readDoubleBE(0));\n-assert.strictEqual(-2, buffer.readDoubleLE(0));\n-\n-buffer[6] = 0x10;\n-buffer[7] = 0;\n-assert.strictEqual(2.0237e-320, buffer.readDoubleBE(0));\n-assert.strictEqual(2.2250738585072014e-308, buffer.readDoubleLE(0));\n-\n-buffer[6] = 0;\n-assert.strictEqual(0, buffer.readDoubleBE(0));\n-assert.strictEqual(0, buffer.readDoubleLE(0));\n-assert.strictEqual(false, 1 / buffer.readDoubleLE(0) < 0);\n-\n-buffer[7] = 0x80;\n-assert.strictEqual(6.3e-322, buffer.readDoubleBE(0));\n-assert.strictEqual(-0, buffer.readDoubleLE(0));\n-assert.strictEqual(true, 1 / buffer.readDoubleLE(0) < 0);\n-\n-buffer[6] = 0xf0;\n-buffer[7] = 0x7f;\n-assert.strictEqual(3.0418e-319, buffer.readDoubleBE(0));\n-assert.strictEqual(Infinity, buffer.readDoubleLE(0));\n-\n-buffer[7] = 0xff;\n-assert.strictEqual(3.04814e-319, buffer.readDoubleBE(0));\n-assert.strictEqual(-Infinity, buffer.readDoubleLE(0));\n-\n-buffer.writeDoubleBE(246800);\n-assert.strictEqual(buffer.readDoubleBE(), 246800);\n-assert.strictEqual(buffer.readDoubleBE(0.7), 246800);\n-assert.strictEqual(buffer.readDoubleBE(NaN), 246800);"
        },
        {
            "sha": "ce7469977ead85ab6296a804fe2b06ba3111f7b0",
            "filename": "test/parallel/test-readfloat.js",
            "status": "removed",
            "additions": 0,
            "deletions": 92,
            "changes": 92,
            "blob_url": "https://github.com/nodejs/node/blob/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-readfloat.js",
            "raw_url": "https://github.com/nodejs/node/raw/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-readfloat.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-readfloat.js?ref=a6c490cc8e8c848d6c4d5b8739827198055fe40f",
            "patch": "@@ -1,92 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-'use strict';\n-/*\n- * Tests to verify we're reading in floats correctly\n- */\n-require('../common');\n-const assert = require('assert');\n-\n-/*\n- * Test (32 bit) float\n- */\n-function test(clazz) {\n-  const buffer = new clazz(4);\n-\n-  buffer[0] = 0;\n-  buffer[1] = 0;\n-  buffer[2] = 0x80;\n-  buffer[3] = 0x3f;\n-  assert.strictEqual(4.600602988224807e-41, buffer.readFloatBE(0));\n-  assert.strictEqual(1, buffer.readFloatLE(0));\n-\n-  buffer[0] = 0;\n-  buffer[1] = 0;\n-  buffer[2] = 0;\n-  buffer[3] = 0xc0;\n-  assert.strictEqual(2.6904930515036488e-43, buffer.readFloatBE(0));\n-  assert.strictEqual(-2, buffer.readFloatLE(0));\n-\n-  buffer[0] = 0xff;\n-  buffer[1] = 0xff;\n-  buffer[2] = 0x7f;\n-  buffer[3] = 0x7f;\n-  assert.ok(Number.isNaN(buffer.readFloatBE(0)));\n-  assert.strictEqual(3.4028234663852886e+38, buffer.readFloatLE(0));\n-\n-  buffer[0] = 0xab;\n-  buffer[1] = 0xaa;\n-  buffer[2] = 0xaa;\n-  buffer[3] = 0x3e;\n-  assert.strictEqual(-1.2126478207002966e-12, buffer.readFloatBE(0));\n-  assert.strictEqual(0.3333333432674408, buffer.readFloatLE(0));\n-\n-  buffer[0] = 0;\n-  buffer[1] = 0;\n-  buffer[2] = 0;\n-  buffer[3] = 0;\n-  assert.strictEqual(0, buffer.readFloatBE(0));\n-  assert.strictEqual(0, buffer.readFloatLE(0));\n-  assert.strictEqual(false, 1 / buffer.readFloatLE(0) < 0);\n-\n-  buffer[3] = 0x80;\n-  assert.strictEqual(1.793662034335766e-43, buffer.readFloatBE(0));\n-  assert.strictEqual(-0, buffer.readFloatLE(0));\n-  assert.strictEqual(true, 1 / buffer.readFloatLE(0) < 0);\n-\n-  buffer[0] = 0;\n-  buffer[1] = 0;\n-  buffer[2] = 0x80;\n-  buffer[3] = 0x7f;\n-  assert.strictEqual(4.609571298396486e-41, buffer.readFloatBE(0));\n-  assert.strictEqual(Infinity, buffer.readFloatLE(0));\n-\n-  buffer[0] = 0;\n-  buffer[1] = 0;\n-  buffer[2] = 0x80;\n-  buffer[3] = 0xff;\n-  assert.strictEqual(4.627507918739843e-41, buffer.readFloatBE(0));\n-  assert.strictEqual(-Infinity, buffer.readFloatLE(0));\n-}\n-\n-\n-test(Buffer);"
        },
        {
            "sha": "42b9d1e61ebc43c6e1fe6d70044b139b1c9a4f04",
            "filename": "test/parallel/test-readint.js",
            "status": "removed",
            "additions": 0,
            "deletions": 119,
            "changes": 119,
            "blob_url": "https://github.com/nodejs/node/blob/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-readint.js",
            "raw_url": "https://github.com/nodejs/node/raw/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-readint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-readint.js?ref=a6c490cc8e8c848d6c4d5b8739827198055fe40f",
            "patch": "@@ -1,119 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-'use strict';\n-/*\n- * Tests to verify we're reading in signed integers correctly\n- */\n-require('../common');\n-const assert = require('assert');\n-\n-/*\n- * Test 8 bit signed integers\n- */\n-function test8(clazz) {\n-  const data = new clazz(4);\n-\n-  data[0] = 0x23;\n-  assert.strictEqual(0x23, data.readInt8(0));\n-\n-  data[0] = 0xff;\n-  assert.strictEqual(-1, data.readInt8(0));\n-\n-  data[0] = 0x87;\n-  data[1] = 0xab;\n-  data[2] = 0x7c;\n-  data[3] = 0xef;\n-  assert.strictEqual(-121, data.readInt8(0));\n-  assert.strictEqual(-85, data.readInt8(1));\n-  assert.strictEqual(124, data.readInt8(2));\n-  assert.strictEqual(-17, data.readInt8(3));\n-}\n-\n-\n-function test16(clazz) {\n-  const buffer = new clazz(6);\n-\n-  buffer[0] = 0x16;\n-  buffer[1] = 0x79;\n-  assert.strictEqual(0x1679, buffer.readInt16BE(0));\n-  assert.strictEqual(0x7916, buffer.readInt16LE(0));\n-\n-  buffer[0] = 0xff;\n-  buffer[1] = 0x80;\n-  assert.strictEqual(-128, buffer.readInt16BE(0));\n-  assert.strictEqual(-32513, buffer.readInt16LE(0));\n-\n-  /* test offset with weenix */\n-  buffer[0] = 0x77;\n-  buffer[1] = 0x65;\n-  buffer[2] = 0x65;\n-  buffer[3] = 0x6e;\n-  buffer[4] = 0x69;\n-  buffer[5] = 0x78;\n-  assert.strictEqual(0x7765, buffer.readInt16BE(0));\n-  assert.strictEqual(0x6565, buffer.readInt16BE(1));\n-  assert.strictEqual(0x656e, buffer.readInt16BE(2));\n-  assert.strictEqual(0x6e69, buffer.readInt16BE(3));\n-  assert.strictEqual(0x6978, buffer.readInt16BE(4));\n-  assert.strictEqual(0x6577, buffer.readInt16LE(0));\n-  assert.strictEqual(0x6565, buffer.readInt16LE(1));\n-  assert.strictEqual(0x6e65, buffer.readInt16LE(2));\n-  assert.strictEqual(0x696e, buffer.readInt16LE(3));\n-  assert.strictEqual(0x7869, buffer.readInt16LE(4));\n-}\n-\n-\n-function test32(clazz) {\n-  const buffer = new clazz(6);\n-\n-  buffer[0] = 0x43;\n-  buffer[1] = 0x53;\n-  buffer[2] = 0x16;\n-  buffer[3] = 0x79;\n-  assert.strictEqual(0x43531679, buffer.readInt32BE(0));\n-  assert.strictEqual(0x79165343, buffer.readInt32LE(0));\n-\n-  buffer[0] = 0xff;\n-  buffer[1] = 0xfe;\n-  buffer[2] = 0xef;\n-  buffer[3] = 0xfa;\n-  assert.strictEqual(-69638, buffer.readInt32BE(0));\n-  assert.strictEqual(-84934913, buffer.readInt32LE(0));\n-\n-  buffer[0] = 0x42;\n-  buffer[1] = 0xc3;\n-  buffer[2] = 0x95;\n-  buffer[3] = 0xa9;\n-  buffer[4] = 0x36;\n-  buffer[5] = 0x17;\n-  assert.strictEqual(0x42c395a9, buffer.readInt32BE(0));\n-  assert.strictEqual(-1013601994, buffer.readInt32BE(1));\n-  assert.strictEqual(-1784072681, buffer.readInt32BE(2));\n-  assert.strictEqual(-1449802942, buffer.readInt32LE(0));\n-  assert.strictEqual(917083587, buffer.readInt32LE(1));\n-  assert.strictEqual(389458325, buffer.readInt32LE(2));\n-}\n-\n-\n-test8(Buffer);\n-test16(Buffer);\n-test32(Buffer);"
        },
        {
            "sha": "cb1b0701531f06bab3c92e5db0169fddb6d2ab89",
            "filename": "test/parallel/test-writedouble.js",
            "status": "removed",
            "additions": 0,
            "deletions": 197,
            "changes": 197,
            "blob_url": "https://github.com/nodejs/node/blob/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-writedouble.js",
            "raw_url": "https://github.com/nodejs/node/raw/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-writedouble.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-writedouble.js?ref=a6c490cc8e8c848d6c4d5b8739827198055fe40f",
            "patch": "@@ -1,197 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-'use strict';\n-/*\n- * Tests to verify we're writing doubles correctly\n- */\n-require('../common');\n-const assert = require('assert');\n-\n-function test(clazz) {\n-  const buffer = new clazz(16);\n-\n-  buffer.writeDoubleBE(2.225073858507201e-308, 0);\n-  buffer.writeDoubleLE(2.225073858507201e-308, 8);\n-  assert.strictEqual(0x00, buffer[0]);\n-  assert.strictEqual(0x0f, buffer[1]);\n-  assert.strictEqual(0xff, buffer[2]);\n-  assert.strictEqual(0xff, buffer[3]);\n-  assert.strictEqual(0xff, buffer[4]);\n-  assert.strictEqual(0xff, buffer[5]);\n-  assert.strictEqual(0xff, buffer[6]);\n-  assert.strictEqual(0xff, buffer[7]);\n-  assert.strictEqual(0xff, buffer[8]);\n-  assert.strictEqual(0xff, buffer[9]);\n-  assert.strictEqual(0xff, buffer[10]);\n-  assert.strictEqual(0xff, buffer[11]);\n-  assert.strictEqual(0xff, buffer[12]);\n-  assert.strictEqual(0xff, buffer[13]);\n-  assert.strictEqual(0x0f, buffer[14]);\n-  assert.strictEqual(0x00, buffer[15]);\n-\n-  buffer.writeDoubleBE(1.0000000000000004, 0);\n-  buffer.writeDoubleLE(1.0000000000000004, 8);\n-  assert.strictEqual(0x3f, buffer[0]);\n-  assert.strictEqual(0xf0, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x02, buffer[7]);\n-  assert.strictEqual(0x02, buffer[8]);\n-  assert.strictEqual(0x00, buffer[9]);\n-  assert.strictEqual(0x00, buffer[10]);\n-  assert.strictEqual(0x00, buffer[11]);\n-  assert.strictEqual(0x00, buffer[12]);\n-  assert.strictEqual(0x00, buffer[13]);\n-  assert.strictEqual(0xf0, buffer[14]);\n-  assert.strictEqual(0x3f, buffer[15]);\n-\n-  buffer.writeDoubleBE(-2, 0);\n-  buffer.writeDoubleLE(-2, 8);\n-  assert.strictEqual(0xc0, buffer[0]);\n-  assert.strictEqual(0x00, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x00, buffer[7]);\n-  assert.strictEqual(0x00, buffer[8]);\n-  assert.strictEqual(0x00, buffer[9]);\n-  assert.strictEqual(0x00, buffer[10]);\n-  assert.strictEqual(0x00, buffer[11]);\n-  assert.strictEqual(0x00, buffer[12]);\n-  assert.strictEqual(0x00, buffer[13]);\n-  assert.strictEqual(0x00, buffer[14]);\n-  assert.strictEqual(0xc0, buffer[15]);\n-\n-  buffer.writeDoubleBE(1.7976931348623157e+308, 0);\n-  buffer.writeDoubleLE(1.7976931348623157e+308, 8);\n-  assert.strictEqual(0x7f, buffer[0]);\n-  assert.strictEqual(0xef, buffer[1]);\n-  assert.strictEqual(0xff, buffer[2]);\n-  assert.strictEqual(0xff, buffer[3]);\n-  assert.strictEqual(0xff, buffer[4]);\n-  assert.strictEqual(0xff, buffer[5]);\n-  assert.strictEqual(0xff, buffer[6]);\n-  assert.strictEqual(0xff, buffer[7]);\n-  assert.strictEqual(0xff, buffer[8]);\n-  assert.strictEqual(0xff, buffer[9]);\n-  assert.strictEqual(0xff, buffer[10]);\n-  assert.strictEqual(0xff, buffer[11]);\n-  assert.strictEqual(0xff, buffer[12]);\n-  assert.strictEqual(0xff, buffer[13]);\n-  assert.strictEqual(0xef, buffer[14]);\n-  assert.strictEqual(0x7f, buffer[15]);\n-\n-  buffer.writeDoubleBE(0 * -1, 0);\n-  buffer.writeDoubleLE(0 * -1, 8);\n-  assert.strictEqual(0x80, buffer[0]);\n-  assert.strictEqual(0x00, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x00, buffer[7]);\n-  assert.strictEqual(0x00, buffer[8]);\n-  assert.strictEqual(0x00, buffer[9]);\n-  assert.strictEqual(0x00, buffer[10]);\n-  assert.strictEqual(0x00, buffer[11]);\n-  assert.strictEqual(0x00, buffer[12]);\n-  assert.strictEqual(0x00, buffer[13]);\n-  assert.strictEqual(0x00, buffer[14]);\n-  assert.strictEqual(0x80, buffer[15]);\n-\n-  buffer.writeDoubleBE(Infinity, 0);\n-  buffer.writeDoubleLE(Infinity, 8);\n-  assert.strictEqual(0x7F, buffer[0]);\n-  assert.strictEqual(0xF0, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x00, buffer[7]);\n-  assert.strictEqual(0x00, buffer[8]);\n-  assert.strictEqual(0x00, buffer[9]);\n-  assert.strictEqual(0x00, buffer[10]);\n-  assert.strictEqual(0x00, buffer[11]);\n-  assert.strictEqual(0x00, buffer[12]);\n-  assert.strictEqual(0x00, buffer[13]);\n-  assert.strictEqual(0xF0, buffer[14]);\n-  assert.strictEqual(0x7F, buffer[15]);\n-  assert.strictEqual(Infinity, buffer.readDoubleBE(0));\n-  assert.strictEqual(Infinity, buffer.readDoubleLE(8));\n-\n-  buffer.writeDoubleBE(-Infinity, 0);\n-  buffer.writeDoubleLE(-Infinity, 8);\n-  assert.strictEqual(0xFF, buffer[0]);\n-  assert.strictEqual(0xF0, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x00, buffer[7]);\n-  assert.strictEqual(0x00, buffer[8]);\n-  assert.strictEqual(0x00, buffer[9]);\n-  assert.strictEqual(0x00, buffer[10]);\n-  assert.strictEqual(0x00, buffer[11]);\n-  assert.strictEqual(0x00, buffer[12]);\n-  assert.strictEqual(0x00, buffer[13]);\n-  assert.strictEqual(0xF0, buffer[14]);\n-  assert.strictEqual(0xFF, buffer[15]);\n-  assert.strictEqual(-Infinity, buffer.readDoubleBE(0));\n-  assert.strictEqual(-Infinity, buffer.readDoubleLE(8));\n-\n-  buffer.writeDoubleBE(NaN, 0);\n-  buffer.writeDoubleLE(NaN, 8);\n-  // Darwin ia32 does the other kind of NaN.\n-  // Compiler bug.  No one really cares.\n-  assert(0x7F === buffer[0] || 0xFF === buffer[0]);\n-  // mips processors use a slightly different NaN\n-  assert(0xF8 === buffer[1] || 0xF7 === buffer[1]);\n-  assert(0x00 === buffer[2] || 0xFF === buffer[2]);\n-  assert(0x00 === buffer[3] || 0xFF === buffer[3]);\n-  assert(0x00 === buffer[4] || 0xFF === buffer[4]);\n-  assert(0x00 === buffer[5] || 0xFF === buffer[5]);\n-  assert(0x00 === buffer[6] || 0xFF === buffer[6]);\n-  assert(0x00 === buffer[7] || 0xFF === buffer[7]);\n-  assert(0x00 === buffer[8] || 0xFF === buffer[8]);\n-  assert(0x00 === buffer[9] || 0xFF === buffer[9]);\n-  assert(0x00 === buffer[10] || 0xFF === buffer[10]);\n-  assert(0x00 === buffer[11] || 0xFF === buffer[11]);\n-  assert(0x00 === buffer[12] || 0xFF === buffer[12]);\n-  assert(0x00 === buffer[13] || 0xFF === buffer[13]);\n-  assert(0xF8 === buffer[14] || 0xF7 === buffer[14]);\n-  // Darwin ia32 does the other kind of NaN.\n-  // Compiler bug.  No one really cares.\n-  assert(0x7F === buffer[15] || 0xFF === buffer[15]);\n-  assert.ok(Number.isNaN(buffer.readDoubleBE(0)));\n-  assert.ok(Number.isNaN(buffer.readDoubleLE(8)));\n-}\n-\n-\n-test(Buffer);"
        },
        {
            "sha": "b22b9e8c92489923aa3a3ceb21eb3a5b378891b0",
            "filename": "test/parallel/test-writefloat.js",
            "status": "removed",
            "additions": 0,
            "deletions": 135,
            "changes": 135,
            "blob_url": "https://github.com/nodejs/node/blob/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-writefloat.js",
            "raw_url": "https://github.com/nodejs/node/raw/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-writefloat.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-writefloat.js?ref=a6c490cc8e8c848d6c4d5b8739827198055fe40f",
            "patch": "@@ -1,135 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-'use strict';\n-/*\n- * Tests to verify we're writing floats correctly\n- */\n-require('../common');\n-const assert = require('assert');\n-\n-function test(clazz) {\n-  const buffer = new clazz(8);\n-\n-  buffer.writeFloatBE(1, 0);\n-  buffer.writeFloatLE(1, 4);\n-  assert.strictEqual(0x3f, buffer[0]);\n-  assert.strictEqual(0x80, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x80, buffer[6]);\n-  assert.strictEqual(0x3f, buffer[7]);\n-\n-  buffer.writeFloatBE(1 / 3, 0);\n-  buffer.writeFloatLE(1 / 3, 4);\n-  assert.strictEqual(0x3e, buffer[0]);\n-  assert.strictEqual(0xaa, buffer[1]);\n-  assert.strictEqual(0xaa, buffer[2]);\n-  assert.strictEqual(0xab, buffer[3]);\n-  assert.strictEqual(0xab, buffer[4]);\n-  assert.strictEqual(0xaa, buffer[5]);\n-  assert.strictEqual(0xaa, buffer[6]);\n-  assert.strictEqual(0x3e, buffer[7]);\n-\n-  buffer.writeFloatBE(3.4028234663852886e+38, 0);\n-  buffer.writeFloatLE(3.4028234663852886e+38, 4);\n-  assert.strictEqual(0x7f, buffer[0]);\n-  assert.strictEqual(0x7f, buffer[1]);\n-  assert.strictEqual(0xff, buffer[2]);\n-  assert.strictEqual(0xff, buffer[3]);\n-  assert.strictEqual(0xff, buffer[4]);\n-  assert.strictEqual(0xff, buffer[5]);\n-  assert.strictEqual(0x7f, buffer[6]);\n-  assert.strictEqual(0x7f, buffer[7]);\n-\n-  buffer.writeFloatLE(1.1754943508222875e-38, 0);\n-  buffer.writeFloatBE(1.1754943508222875e-38, 4);\n-  assert.strictEqual(0x00, buffer[0]);\n-  assert.strictEqual(0x00, buffer[1]);\n-  assert.strictEqual(0x80, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x80, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x00, buffer[7]);\n-\n-  buffer.writeFloatBE(0 * -1, 0);\n-  buffer.writeFloatLE(0 * -1, 4);\n-  assert.strictEqual(0x80, buffer[0]);\n-  assert.strictEqual(0x00, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x80, buffer[7]);\n-\n-  buffer.writeFloatBE(Infinity, 0);\n-  buffer.writeFloatLE(Infinity, 4);\n-  assert.strictEqual(0x7F, buffer[0]);\n-  assert.strictEqual(0x80, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x80, buffer[6]);\n-  assert.strictEqual(0x7F, buffer[7]);\n-  assert.strictEqual(Infinity, buffer.readFloatBE(0));\n-  assert.strictEqual(Infinity, buffer.readFloatLE(4));\n-\n-  buffer.writeFloatBE(-Infinity, 0);\n-  buffer.writeFloatLE(-Infinity, 4);\n-  // Darwin ia32 does the other kind of NaN.\n-  // Compiler bug.  No one really cares.\n-  assert(0xFF === buffer[0] || 0x7F === buffer[0]);\n-  assert.strictEqual(0x80, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x80, buffer[6]);\n-  assert.strictEqual(0xFF, buffer[7]);\n-  assert.strictEqual(-Infinity, buffer.readFloatBE(0));\n-  assert.strictEqual(-Infinity, buffer.readFloatLE(4));\n-\n-  buffer.writeFloatBE(NaN, 0);\n-  buffer.writeFloatLE(NaN, 4);\n-  // Darwin ia32 does the other kind of NaN.\n-  // Compiler bug.  No one really cares.\n-  assert(0x7F === buffer[0] || 0xFF === buffer[0]);\n-  // mips processors use a slightly different NaN\n-  assert(0xC0 === buffer[1] || 0xBF === buffer[1]);\n-  assert(0x00 === buffer[2] || 0xFF === buffer[2]);\n-  assert(0x00 === buffer[3] || 0xFF === buffer[3]);\n-  assert(0x00 === buffer[4] || 0xFF === buffer[4]);\n-  assert(0x00 === buffer[5] || 0xFF === buffer[5]);\n-  assert(0xC0 === buffer[6] || 0xBF === buffer[6]);\n-  // Darwin ia32 does the other kind of NaN.\n-  // Compiler bug.  No one really cares.\n-  assert(0x7F === buffer[7] || 0xFF === buffer[7]);\n-  assert.ok(Number.isNaN(buffer.readFloatBE(0)));\n-  assert.ok(Number.isNaN(buffer.readFloatLE(4)));\n-}\n-\n-\n-test(Buffer);"
        },
        {
            "sha": "1e0a8e8812ecb210e7cfe88f93fae021852dec65",
            "filename": "test/parallel/test-writeint.js",
            "status": "removed",
            "additions": 0,
            "deletions": 194,
            "changes": 194,
            "blob_url": "https://github.com/nodejs/node/blob/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-writeint.js",
            "raw_url": "https://github.com/nodejs/node/raw/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-writeint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-writeint.js?ref=a6c490cc8e8c848d6c4d5b8739827198055fe40f",
            "patch": "@@ -1,194 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-'use strict';\n-/*\n- * Tests to verify we're writing signed integers correctly\n- */\n-const common = require('../common');\n-const assert = require('assert');\n-const errorOutOfBounds = common.expectsError({\n-  code: 'ERR_INVALID_OPT_VALUE',\n-  type: RangeError,\n-  message: /^The value \"[^\"]*\" is invalid for option \"value\"$/\n-}, 12);\n-\n-function test8(clazz) {\n-  const buffer = new clazz(2);\n-\n-  buffer.writeInt8(0x23, 0);\n-  buffer.writeInt8(-5, 1);\n-\n-  assert.strictEqual(0x23, buffer[0]);\n-  assert.strictEqual(0xfb, buffer[1]);\n-\n-  /* Make sure we handle truncation correctly */\n-  assert.throws(() => {\n-    buffer.writeInt8(0xabc, 0);\n-  }, errorOutOfBounds);\n-  assert.throws(() => {\n-    buffer.writeInt8(0xabc, 0);\n-  }, errorOutOfBounds);\n-\n-  /* Make sure we handle min/max correctly */\n-  buffer.writeInt8(0x7f, 0);\n-  buffer.writeInt8(-0x80, 1);\n-\n-  assert.strictEqual(0x7f, buffer[0]);\n-  assert.strictEqual(0x80, buffer[1]);\n-  assert.throws(() => {\n-    buffer.writeInt8(0x7f + 1, 0);\n-  }, errorOutOfBounds);\n-  assert.throws(() => {\n-    buffer.writeInt8(-0x80 - 1, 0);\n-  }, errorOutOfBounds);\n-}\n-\n-\n-function test16(clazz) {\n-  const buffer = new clazz(6);\n-\n-  buffer.writeInt16BE(0x0023, 0);\n-  buffer.writeInt16LE(0x0023, 2);\n-  assert.strictEqual(0x00, buffer[0]);\n-  assert.strictEqual(0x23, buffer[1]);\n-  assert.strictEqual(0x23, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-\n-  buffer.writeInt16BE(-5, 0);\n-  buffer.writeInt16LE(-5, 2);\n-  assert.strictEqual(0xff, buffer[0]);\n-  assert.strictEqual(0xfb, buffer[1]);\n-  assert.strictEqual(0xfb, buffer[2]);\n-  assert.strictEqual(0xff, buffer[3]);\n-\n-  buffer.writeInt16BE(-1679, 1);\n-  buffer.writeInt16LE(-1679, 3);\n-  assert.strictEqual(0xf9, buffer[1]);\n-  assert.strictEqual(0x71, buffer[2]);\n-  assert.strictEqual(0x71, buffer[3]);\n-  assert.strictEqual(0xf9, buffer[4]);\n-\n-  /* Make sure we handle min/max correctly */\n-  buffer.writeInt16BE(0x7fff, 0);\n-  buffer.writeInt16BE(-0x8000, 2);\n-  assert.strictEqual(0x7f, buffer[0]);\n-  assert.strictEqual(0xff, buffer[1]);\n-  assert.strictEqual(0x80, buffer[2]);\n-  assert.strictEqual(0x00, buffer[3]);\n-  assert.throws(() => {\n-    buffer.writeInt16BE(0x7fff + 1, 0);\n-  }, errorOutOfBounds);\n-  assert.throws(() => {\n-    buffer.writeInt16BE(-0x8000 - 1, 0);\n-  }, errorOutOfBounds);\n-\n-  buffer.writeInt16LE(0x7fff, 0);\n-  buffer.writeInt16LE(-0x8000, 2);\n-  assert.strictEqual(0xff, buffer[0]);\n-  assert.strictEqual(0x7f, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x80, buffer[3]);\n-  assert.throws(() => {\n-    buffer.writeInt16LE(0x7fff + 1, 0);\n-  }, errorOutOfBounds);\n-  assert.throws(() => {\n-    buffer.writeInt16LE(-0x8000 - 1, 0);\n-  }, errorOutOfBounds);\n-}\n-\n-\n-function test32(clazz) {\n-  const buffer = new clazz(8);\n-\n-  buffer.writeInt32BE(0x23, 0);\n-  buffer.writeInt32LE(0x23, 4);\n-  assert.strictEqual(0x00, buffer[0]);\n-  assert.strictEqual(0x00, buffer[1]);\n-  assert.strictEqual(0x00, buffer[2]);\n-  assert.strictEqual(0x23, buffer[3]);\n-  assert.strictEqual(0x23, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x00, buffer[7]);\n-\n-  buffer.writeInt32BE(-5, 0);\n-  buffer.writeInt32LE(-5, 4);\n-  assert.strictEqual(0xff, buffer[0]);\n-  assert.strictEqual(0xff, buffer[1]);\n-  assert.strictEqual(0xff, buffer[2]);\n-  assert.strictEqual(0xfb, buffer[3]);\n-  assert.strictEqual(0xfb, buffer[4]);\n-  assert.strictEqual(0xff, buffer[5]);\n-  assert.strictEqual(0xff, buffer[6]);\n-  assert.strictEqual(0xff, buffer[7]);\n-\n-  buffer.writeInt32BE(-805306713, 0);\n-  buffer.writeInt32LE(-805306713, 4);\n-  assert.strictEqual(0xcf, buffer[0]);\n-  assert.strictEqual(0xff, buffer[1]);\n-  assert.strictEqual(0xfe, buffer[2]);\n-  assert.strictEqual(0xa7, buffer[3]);\n-  assert.strictEqual(0xa7, buffer[4]);\n-  assert.strictEqual(0xfe, buffer[5]);\n-  assert.strictEqual(0xff, buffer[6]);\n-  assert.strictEqual(0xcf, buffer[7]);\n-\n-  /* Make sure we handle min/max correctly */\n-  buffer.writeInt32BE(0x7fffffff, 0);\n-  buffer.writeInt32BE(-0x80000000, 4);\n-  assert.strictEqual(0x7f, buffer[0]);\n-  assert.strictEqual(0xff, buffer[1]);\n-  assert.strictEqual(0xff, buffer[2]);\n-  assert.strictEqual(0xff, buffer[3]);\n-  assert.strictEqual(0x80, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x00, buffer[7]);\n-  assert.throws(() => {\n-    buffer.writeInt32BE(0x7fffffff + 1, 0);\n-  }, errorOutOfBounds);\n-  assert.throws(() => {\n-    buffer.writeInt32BE(-0x80000000 - 1, 0);\n-  }, errorOutOfBounds);\n-\n-  buffer.writeInt32LE(0x7fffffff, 0);\n-  buffer.writeInt32LE(-0x80000000, 4);\n-  assert.strictEqual(0xff, buffer[0]);\n-  assert.strictEqual(0xff, buffer[1]);\n-  assert.strictEqual(0xff, buffer[2]);\n-  assert.strictEqual(0x7f, buffer[3]);\n-  assert.strictEqual(0x00, buffer[4]);\n-  assert.strictEqual(0x00, buffer[5]);\n-  assert.strictEqual(0x00, buffer[6]);\n-  assert.strictEqual(0x80, buffer[7]);\n-  assert.throws(() => {\n-    buffer.writeInt32LE(0x7fffffff + 1, 0);\n-  }, errorOutOfBounds);\n-  assert.throws(() => {\n-    buffer.writeInt32LE(-0x80000000 - 1, 0);\n-  }, errorOutOfBounds);\n-}\n-\n-\n-test8(Buffer);\n-test16(Buffer);\n-test32(Buffer);"
        },
        {
            "sha": "0863135b2b8b05253bcca0cab540586c7540b029",
            "filename": "test/parallel/test-writeuint.js",
            "status": "removed",
            "additions": 0,
            "deletions": 171,
            "changes": 171,
            "blob_url": "https://github.com/nodejs/node/blob/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-writeuint.js",
            "raw_url": "https://github.com/nodejs/node/raw/a6c490cc8e8c848d6c4d5b8739827198055fe40f/test%2Fparallel%2Ftest-writeuint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-writeuint.js?ref=a6c490cc8e8c848d6c4d5b8739827198055fe40f",
            "patch": "@@ -1,171 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-'use strict';\n-/*\n- * A battery of tests to help us read a series of uints\n- */\n-const common = require('../common');\n-const assert = require('assert');\n-\n-/*\n- * We need to check the following things:\n- *  - We are correctly resolving big endian (doesn't mean anything for 8 bit)\n- *  - Correctly resolving little endian (doesn't mean anything for 8 bit)\n- *  - Correctly using the offsets\n- *  - Correctly interpreting values that are beyond the signed range as unsigned\n- */\n-function test8(clazz) {\n-  const data = new clazz(4);\n-\n-  data.writeUInt8(23, 0);\n-  data.writeUInt8(23, 1);\n-  data.writeUInt8(23, 2);\n-  data.writeUInt8(23, 3);\n-  assert.strictEqual(23, data[0]);\n-  assert.strictEqual(23, data[1]);\n-  assert.strictEqual(23, data[2]);\n-  assert.strictEqual(23, data[3]);\n-\n-  data.writeUInt8(23, 0);\n-  data.writeUInt8(23, 1);\n-  data.writeUInt8(23, 2);\n-  data.writeUInt8(23, 3);\n-  assert.strictEqual(23, data[0]);\n-  assert.strictEqual(23, data[1]);\n-  assert.strictEqual(23, data[2]);\n-  assert.strictEqual(23, data[3]);\n-\n-  data.writeUInt8(255, 0);\n-  assert.strictEqual(255, data[0]);\n-\n-  data.writeUInt8(255, 0);\n-  assert.strictEqual(255, data[0]);\n-}\n-\n-\n-function test16(clazz) {\n-  let value = 0x2343;\n-  const data = new clazz(4);\n-\n-  data.writeUInt16BE(value, 0);\n-  assert.strictEqual(0x23, data[0]);\n-  assert.strictEqual(0x43, data[1]);\n-\n-  data.writeUInt16BE(value, 1);\n-  assert.strictEqual(0x23, data[1]);\n-  assert.strictEqual(0x43, data[2]);\n-\n-  data.writeUInt16BE(value, 2);\n-  assert.strictEqual(0x23, data[2]);\n-  assert.strictEqual(0x43, data[3]);\n-\n-  data.writeUInt16LE(value, 0);\n-  assert.strictEqual(0x23, data[1]);\n-  assert.strictEqual(0x43, data[0]);\n-\n-  data.writeUInt16LE(value, 1);\n-  assert.strictEqual(0x23, data[2]);\n-  assert.strictEqual(0x43, data[1]);\n-\n-  data.writeUInt16LE(value, 2);\n-  assert.strictEqual(0x23, data[3]);\n-  assert.strictEqual(0x43, data[2]);\n-\n-  value = 0xff80;\n-  data.writeUInt16LE(value, 0);\n-  assert.strictEqual(0xff, data[1]);\n-  assert.strictEqual(0x80, data[0]);\n-\n-  data.writeUInt16BE(value, 0);\n-  assert.strictEqual(0xff, data[0]);\n-  assert.strictEqual(0x80, data[1]);\n-}\n-\n-\n-function test32(clazz) {\n-  const data = new clazz(6);\n-  const value = 0xe7f90a6d;\n-\n-  data.writeUInt32BE(value, 0);\n-  assert.strictEqual(0xe7, data[0]);\n-  assert.strictEqual(0xf9, data[1]);\n-  assert.strictEqual(0x0a, data[2]);\n-  assert.strictEqual(0x6d, data[3]);\n-\n-  data.writeUInt32BE(value, 1);\n-  assert.strictEqual(0xe7, data[1]);\n-  assert.strictEqual(0xf9, data[2]);\n-  assert.strictEqual(0x0a, data[3]);\n-  assert.strictEqual(0x6d, data[4]);\n-\n-  data.writeUInt32BE(value, 2);\n-  assert.strictEqual(0xe7, data[2]);\n-  assert.strictEqual(0xf9, data[3]);\n-  assert.strictEqual(0x0a, data[4]);\n-  assert.strictEqual(0x6d, data[5]);\n-\n-  data.writeUInt32LE(value, 0);\n-  assert.strictEqual(0xe7, data[3]);\n-  assert.strictEqual(0xf9, data[2]);\n-  assert.strictEqual(0x0a, data[1]);\n-  assert.strictEqual(0x6d, data[0]);\n-\n-  data.writeUInt32LE(value, 1);\n-  assert.strictEqual(0xe7, data[4]);\n-  assert.strictEqual(0xf9, data[3]);\n-  assert.strictEqual(0x0a, data[2]);\n-  assert.strictEqual(0x6d, data[1]);\n-\n-  data.writeUInt32LE(value, 2);\n-  assert.strictEqual(0xe7, data[5]);\n-  assert.strictEqual(0xf9, data[4]);\n-  assert.strictEqual(0x0a, data[3]);\n-  assert.strictEqual(0x6d, data[2]);\n-}\n-\n-\n-function testUint(clazz) {\n-  const data = new clazz(8);\n-  let val = 1;\n-\n-  // Test 0 to 5 bytes.\n-  for (let i = 0; i <= 5; i++) {\n-    const errMsg = common.expectsError({\n-      code: 'ERR_INVALID_OPT_VALUE',\n-      type: RangeError,\n-      message: /^The value \"[^\"]*\" is invalid for option \"value\"$/\n-    }, 2);\n-    assert.throws(() => {\n-      data.writeUIntBE(val, 0, i);\n-    }, errMsg);\n-    assert.throws(() => {\n-      data.writeUIntLE(val, 0, i);\n-    }, errMsg);\n-    val *= 0x100;\n-  }\n-}\n-\n-\n-test8(Buffer);\n-test16(Buffer);\n-test32(Buffer);\n-testUint(Buffer);"
        }
    ],
    "stats": {
        "total": 3854,
        "additions": 2015,
        "deletions": 1839
    }
}