{
    "author": "jasnell",
    "message": "test: refactor structure of common/index\n\nPR-URL: https://github.com/nodejs/node/pull/22511\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "286ca2c12de1c7b5cb17cb9ae5928fb8090d7ba2",
    "files": [
        {
            "sha": "cb9256aae50f90c33390630c1ae4991bd7e53171",
            "filename": "test/common/index.js",
            "status": "modified",
            "additions": 229,
            "deletions": 205,
            "changes": 434,
            "blob_url": "https://github.com/nodejs/node/blob/286ca2c12de1c7b5cb17cb9ae5928fb8090d7ba2/test%2Fcommon%2Findex.js",
            "raw_url": "https://github.com/nodejs/node/raw/286ca2c12de1c7b5cb17cb9ae5928fb8090d7ba2/test%2Fcommon%2Findex.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcommon%2Findex.js?ref=286ca2c12de1c7b5cb17cb9ae5928fb8090d7ba2",
            "patch": "@@ -30,20 +30,15 @@ const { exec, execSync, spawnSync } = require('child_process');\n const util = require('util');\n const { fixturesDir } = require('./fixtures');\n const tmpdir = require('./tmpdir');\n+const {\n+  bits,\n+  hasIntl,\n+  hasSmallICU\n+} = process.binding('config');\n \n const noop = () => {};\n \n-Object.defineProperty(exports, 'PORT', {\n-  get: () => {\n-    if (+process.env.TEST_PARALLEL) {\n-      throw new Error('common.PORT cannot be used in a parallelized test');\n-    }\n-    return +process.env.NODE_COMMON_PORT || 12346;\n-  },\n-  enumerable: true\n-});\n-\n-exports.isMainThread = (() => {\n+const isMainThread = (() => {\n   try {\n     return require('worker_threads').isMainThread;\n   } catch {\n@@ -52,27 +47,28 @@ exports.isMainThread = (() => {\n   }\n })();\n \n-exports.isWindows = process.platform === 'win32';\n-exports.isWOW64 = exports.isWindows &&\n-                  (process.env.PROCESSOR_ARCHITEW6432 !== undefined);\n-exports.isAIX = process.platform === 'aix';\n-exports.isLinuxPPCBE = (process.platform === 'linux') &&\n-                       (process.arch === 'ppc64') &&\n-                       (os.endianness() === 'BE');\n-exports.isSunOS = process.platform === 'sunos';\n-exports.isFreeBSD = process.platform === 'freebsd';\n-exports.isOpenBSD = process.platform === 'openbsd';\n-exports.isLinux = process.platform === 'linux';\n-exports.isOSX = process.platform === 'darwin';\n-\n-exports.enoughTestMem = os.totalmem() > 0x70000000; /* 1.75 Gb */\n+const isWindows = process.platform === 'win32';\n+const isWOW64 = isWindows && (process.env.PROCESSOR_ARCHITEW6432 !== undefined);\n+const isAIX = process.platform === 'aix';\n+const isLinuxPPCBE = (process.platform === 'linux') &&\n+                     (process.arch === 'ppc64') &&\n+                     (os.endianness() === 'BE');\n+const isSunOS = process.platform === 'sunos';\n+const isFreeBSD = process.platform === 'freebsd';\n+const isOpenBSD = process.platform === 'openbsd';\n+const isLinux = process.platform === 'linux';\n+const isOSX = process.platform === 'darwin';\n+\n+const enoughTestMem = os.totalmem() > 0x70000000; /* 1.75 Gb */\n const cpus = os.cpus();\n-exports.enoughTestCpu = Array.isArray(cpus) &&\n-                        (cpus.length > 1 || cpus[0].speed > 999);\n+const enoughTestCpu = Array.isArray(cpus) &&\n+                      (cpus.length > 1 || cpus[0].speed > 999);\n+\n+const rootDir = isWindows ? 'c:\\\\' : '/';\n \n-exports.rootDir = exports.isWindows ? 'c:\\\\' : '/';\n+const buildType = process.config.target_defaults.default_configuration;\n \n-exports.buildType = process.config.target_defaults.default_configuration;\n+const hasCrypto = Boolean(process.versions.openssl);\n \n // If env var is set then enable async_hook hooks for all tests.\n if (process.env.NODE_TEST_WITH_ASYNC_HOOKS) {\n@@ -126,9 +122,8 @@ let opensslCli = null;\n let inFreeBSDJail = null;\n let localhostIPv4 = null;\n \n-exports.localIPv6Hosts = ['localhost'];\n-if (exports.isLinux) {\n-  exports.localIPv6Hosts = [\n+const localIPv6Hosts =\n+  isLinux ? [\n     // Debian/Ubuntu\n     'ip6-localhost',\n     'ip6-loopback',\n@@ -139,96 +134,20 @@ if (exports.isLinux) {\n \n     // Typically universal\n     'localhost',\n-  ];\n-}\n-\n-Object.defineProperty(exports, 'inFreeBSDJail', {\n-  get: function() {\n-    if (inFreeBSDJail !== null) return inFreeBSDJail;\n-\n-    if (exports.isFreeBSD &&\n-      execSync('sysctl -n security.jail.jailed').toString() ===\n-      '1\\n') {\n-      inFreeBSDJail = true;\n-    } else {\n-      inFreeBSDJail = false;\n-    }\n-    return inFreeBSDJail;\n-  }\n-});\n-\n-Object.defineProperty(exports, 'localhostIPv4', {\n-  get: function() {\n-    if (localhostIPv4 !== null) return localhostIPv4;\n-\n-    if (exports.inFreeBSDJail) {\n-      // Jailed network interfaces are a bit special - since we need to jump\n-      // through loops, as well as this being an exception case, assume the\n-      // user will provide this instead.\n-      if (process.env.LOCALHOST) {\n-        localhostIPv4 = process.env.LOCALHOST;\n-      } else {\n-        console.error('Looks like we\\'re in a FreeBSD Jail. ' +\n-                      'Please provide your default interface address ' +\n-                      'as LOCALHOST or expect some tests to fail.');\n-      }\n-    }\n-\n-    if (localhostIPv4 === null) localhostIPv4 = '127.0.0.1';\n-\n-    return localhostIPv4;\n-  }\n-});\n+  ] : [ 'localhost' ];\n \n-Object.defineProperty(exports, 'localhostIPv6', {\n-  get: () => '::1'\n-});\n-\n-// opensslCli defined lazily to reduce overhead of spawnSync\n-Object.defineProperty(exports, 'opensslCli', { get: function() {\n-  if (opensslCli !== null) return opensslCli;\n-\n-  if (process.config.variables.node_shared_openssl) {\n-    // use external command\n-    opensslCli = 'openssl';\n-  } else {\n-    // use command built from sources included in Node.js repository\n-    opensslCli = path.join(path.dirname(process.execPath), 'openssl-cli');\n-  }\n-\n-  if (exports.isWindows) opensslCli += '.exe';\n-\n-  const opensslCmd = spawnSync(opensslCli, ['version']);\n-  if (opensslCmd.status !== 0 || opensslCmd.error !== undefined) {\n-    // openssl command cannot be executed\n-    opensslCli = false;\n-  }\n-  return opensslCli;\n-}, enumerable: true });\n-\n-Object.defineProperty(exports, 'hasCrypto', {\n-  get: function() {\n-    return Boolean(process.versions.openssl);\n-  }\n-});\n-\n-Object.defineProperty(exports, 'hasFipsCrypto', {\n-  get: function() {\n-    return exports.hasCrypto && require('crypto').fips;\n-  }\n-});\n-\n-{\n+const PIPE = (() => {\n   const localRelative = path.relative(process.cwd(), `${tmpdir.path}/`);\n-  const pipePrefix = exports.isWindows ? '\\\\\\\\.\\\\pipe\\\\' : localRelative;\n+  const pipePrefix = isWindows ? '\\\\\\\\.\\\\pipe\\\\' : localRelative;\n   const pipeName = `node-test.${process.pid}.sock`;\n-  exports.PIPE = path.join(pipePrefix, pipeName);\n-}\n+  return path.join(pipePrefix, pipeName);\n+})();\n \n+let hasIPv6;\n {\n   const iFaces = os.networkInterfaces();\n-  const re = exports.isWindows ? /Loopback Pseudo-Interface/ : /lo/;\n-  exports.hasIPv6 = Object.keys(iFaces).some(function(name) {\n+  const re = isWindows ? /Loopback Pseudo-Interface/ : /lo/;\n+  hasIPv6 = Object.keys(iFaces).some(function(name) {\n     return re.test(name) && iFaces[name].some(function(info) {\n       return info.family === 'IPv6';\n     });\n@@ -240,9 +159,9 @@ Object.defineProperty(exports, 'hasFipsCrypto', {\n  * `$node --abort-on-uncaught-exception $file child`\n  * the process aborts.\n  */\n-exports.childShouldThrowAndAbort = function() {\n+function childShouldThrowAndAbort() {\n   let testCmd = '';\n-  if (!exports.isWindows) {\n+  if (!isWindows) {\n     // Do not create core files, as it can take a lot of disk space on\n     // continuous testing and developers' machines\n     testCmd += 'ulimit -c 0 && ';\n@@ -254,33 +173,33 @@ exports.childShouldThrowAndAbort = function() {\n     const errMsg = 'Test should have aborted ' +\n                    `but instead exited with exit code ${exitCode}` +\n                    ` and signal ${signal}`;\n-    assert(exports.nodeProcessAborted(exitCode, signal), errMsg);\n+    assert(nodeProcessAborted(exitCode, signal), errMsg);\n   });\n-};\n+}\n \n-exports.ddCommand = function(filename, kilobytes) {\n-  if (exports.isWindows) {\n+function ddCommand(filename, kilobytes) {\n+  if (isWindows) {\n     const p = path.resolve(fixturesDir, 'create-file.js');\n     return `\"${process.argv[0]}\" \"${p}\" \"${filename}\" ${kilobytes * 1024}`;\n   } else {\n     return `dd if=/dev/zero of=\"${filename}\" bs=1024 count=${kilobytes}`;\n   }\n-};\n+}\n \n \n-exports.pwdCommand = exports.isWindows ?\n+const pwdCommand = isWindows ?\n   ['cmd.exe', ['/d', '/c', 'cd']] :\n   ['pwd', []];\n \n \n-exports.platformTimeout = function(ms) {\n+function platformTimeout(ms) {\n   if (process.features.debug)\n     ms = 2 * ms;\n \n   if (global.__coverage__)\n     ms = 4 * ms;\n \n-  if (exports.isAIX)\n+  if (isAIX)\n     return 2 * ms; // default localhost speed is slower on AIX\n \n   if (process.arch !== 'arm')\n@@ -295,7 +214,7 @@ exports.platformTimeout = function(ms) {\n     return 2 * ms;  // ARMv7\n \n   return ms; // ARMv8+\n-};\n+}\n \n let knownGlobals = [\n   Buffer,\n@@ -339,7 +258,6 @@ if (process.env.NODE_TEST_KNOWN_GLOBALS) {\n function allowGlobals(...whitelist) {\n   knownGlobals = knownGlobals.concat(whitelist);\n }\n-exports.allowGlobals = allowGlobals;\n \n function leakedGlobals() {\n   const leaked = [];\n@@ -356,7 +274,6 @@ function leakedGlobals() {\n     return leaked;\n   }\n }\n-exports.leakedGlobals = leakedGlobals;\n \n process.on('exit', function() {\n   const leaked = leakedGlobals();\n@@ -391,19 +308,19 @@ function runCallChecks(exitCode) {\n   if (failed.length) process.exit(1);\n }\n \n-exports.mustCall = function(fn, exact) {\n+function mustCall(fn, exact) {\n   return _mustCallInner(fn, exact, 'exact');\n-};\n+}\n \n-exports.mustCallAtLeast = function(fn, minimum) {\n+function mustCallAtLeast(fn, minimum) {\n   return _mustCallInner(fn, minimum, 'minimum');\n-};\n+}\n \n-exports.mustCallAsync = function(fn, exact) {\n-  return exports.mustCall((...args) => {\n-    return Promise.resolve(fn(...args)).then(exports.mustCall((val) => val));\n+function mustCallAsync(fn, exact) {\n+  return mustCall((...args) => {\n+    return Promise.resolve(fn(...args)).then(mustCall((val) => val));\n   }, exact);\n-};\n+}\n \n function _mustCallInner(fn, criteria = 1, field) {\n   if (process._exiting)\n@@ -436,28 +353,28 @@ function _mustCallInner(fn, criteria = 1, field) {\n   };\n }\n \n-exports.hasMultiLocalhost = function hasMultiLocalhost() {\n+function hasMultiLocalhost() {\n   const { internalBinding } = require('internal/test/binding');\n   const { TCP, constants: TCPConstants } = internalBinding('tcp_wrap');\n   const t = new TCP(TCPConstants.SOCKET);\n   const ret = t.bind('127.0.0.2', 0);\n   t.close();\n   return ret === 0;\n-};\n+}\n \n-exports.skipIfEslintMissing = function() {\n+function skipIfEslintMissing() {\n   if (!fs.existsSync(\n     path.join(__dirname, '..', '..', 'tools', 'node_modules', 'eslint')\n   )) {\n-    exports.skip('missing ESLint');\n+    skip('missing ESLint');\n   }\n-};\n+}\n \n-exports.canCreateSymLink = function() {\n+function canCreateSymLink() {\n   // On Windows, creating symlinks requires admin privileges.\n   // We'll only try to run symlink test if we have enough privileges.\n   // On other platforms, creating symlinks shouldn't need admin privileges\n-  if (exports.isWindows) {\n+  if (isWindows) {\n     // whoami.exe needs to be the one from System32\n     // If unix tools are in the path, they can shadow the one we want,\n     // so use the full path while executing whoami\n@@ -473,9 +390,9 @@ exports.canCreateSymLink = function() {\n   }\n   // On non-Windows platforms, this always returns `true`\n   return true;\n-};\n+}\n \n-exports.getCallSite = function getCallSite(top) {\n+function getCallSite(top) {\n   const originalStackFormatter = Error.prepareStackTrace;\n   Error.prepareStackTrace = (err, stack) =>\n     `${stack[0].getFileName()}:${stack[0].getLineNumber()}`;\n@@ -485,29 +402,29 @@ exports.getCallSite = function getCallSite(top) {\n   err.stack;\n   Error.prepareStackTrace = originalStackFormatter;\n   return err.stack;\n-};\n+}\n \n-exports.mustNotCall = function(msg) {\n-  const callSite = exports.getCallSite(exports.mustNotCall);\n+function mustNotCall(msg) {\n+  const callSite = getCallSite(mustNotCall);\n   return function mustNotCall() {\n     assert.fail(\n       `${msg || 'function should not have been called'} at ${callSite}`);\n   };\n-};\n+}\n \n-exports.printSkipMessage = function(msg) {\n+function printSkipMessage(msg) {\n   console.log(`1..0 # Skipped: ${msg}`);\n-};\n+}\n \n-exports.skip = function(msg) {\n-  exports.printSkipMessage(msg);\n+function skip(msg) {\n+  printSkipMessage(msg);\n   process.exit(0);\n-};\n+}\n \n // Returns true if the exit code \"exitCode\" and/or signal name \"signal\"\n // represent the exit code and/or signal name of a node process that aborted,\n // false otherwise.\n-exports.nodeProcessAborted = function nodeProcessAborted(exitCode, signal) {\n+function nodeProcessAborted(exitCode, signal) {\n   // Depending on the compiler used, node will exit with either\n   // exit code 132 (SIGILL), 133 (SIGTRAP) or 134 (SIGABRT).\n   let expectedExitCodes = [132, 133, 134];\n@@ -524,7 +441,7 @@ exports.nodeProcessAborted = function nodeProcessAborted(exitCode, signal) {\n   // which corresponds to exit code 3221225477 (0xC0000005)\n   // (ii) Otherwise, _exit(134) which is called in place of abort() due to\n   // raising SIGABRT exiting with ambiguous exit code '3' by default\n-  if (exports.isWindows)\n+  if (isWindows)\n     expectedExitCodes = [0xC0000005, 134];\n \n   // When using --abort-on-uncaught-exception, V8 will use\n@@ -539,28 +456,26 @@ exports.nodeProcessAborted = function nodeProcessAborted(exitCode, signal) {\n   } else {\n     return expectedExitCodes.includes(exitCode);\n   }\n-};\n+}\n \n-exports.busyLoop = function busyLoop(time) {\n+function busyLoop(time) {\n   const startTime = Date.now();\n   const stopTime = startTime + time;\n   while (Date.now() < stopTime) {}\n-};\n+}\n \n-exports.isAlive = function isAlive(pid) {\n+function isAlive(pid) {\n   try {\n     process.kill(pid, 'SIGCONT');\n     return true;\n   } catch (e) {\n     return false;\n   }\n-};\n-\n-exports.noWarnCode = undefined;\n+}\n \n-function expectWarning(name, expected) {\n+function _expectWarning(name, expected) {\n   const map = new Map(expected);\n-  return exports.mustCall((warning) => {\n+  return mustCall((warning) => {\n     assert.strictEqual(warning.name, name);\n     assert.ok(map.has(warning.message),\n               `unexpected error message: \"${warning.message}\"`);\n@@ -576,7 +491,7 @@ function expectWarningByName(name, expected, code) {\n   if (typeof expected === 'string') {\n     expected = [[expected, code]];\n   }\n-  process.on('warning', expectWarning(name, expected));\n+  process.on('warning', _expectWarning(name, expected));\n }\n \n function expectWarningByMap(warningMap) {\n@@ -593,33 +508,21 @@ function expectWarningByMap(warningMap) {\n       }\n       expected = [[expected[0], expected[1]]];\n     }\n-    catchWarning[name] = expectWarning(name, expected);\n+    catchWarning[name] = _expectWarning(name, expected);\n   });\n   process.on('warning', (warning) => catchWarning[warning.name](warning));\n }\n \n // accepts a warning name and description or array of descriptions or a map\n // of warning names to description(s)\n // ensures a warning is generated for each name/description pair\n-exports.expectWarning = function(nameOrMap, expected, code) {\n+function expectWarning(nameOrMap, expected, code) {\n   if (typeof nameOrMap === 'string') {\n     expectWarningByName(nameOrMap, expected, code);\n   } else {\n     expectWarningByMap(nameOrMap);\n   }\n-};\n-\n-Object.defineProperty(exports, 'hasIntl', {\n-  get: function() {\n-    return process.binding('config').hasIntl;\n-  }\n-});\n-\n-Object.defineProperty(exports, 'hasSmallICU', {\n-  get: function() {\n-    return process.binding('config').hasSmallICU;\n-  }\n-});\n+}\n \n class Comparison {\n   constructor(obj, keys) {\n@@ -631,7 +534,7 @@ class Comparison {\n }\n \n // Useful for testing expected internal/error objects\n-exports.expectsError = function expectsError(fn, settings, exact) {\n+function expectsError(fn, settings, exact) {\n   if (typeof fn !== 'function') {\n     exact = settings;\n     settings = fn;\n@@ -706,26 +609,26 @@ exports.expectsError = function expectsError(fn, settings, exact) {\n     assert.throws(fn, innerFn);\n     return;\n   }\n-  return exports.mustCall(innerFn, exact);\n-};\n+  return mustCall(innerFn, exact);\n+}\n \n-exports.skipIfInspectorDisabled = function skipIfInspectorDisabled() {\n+function skipIfInspectorDisabled() {\n   if (process.config.variables.v8_enable_inspector === 0) {\n-    exports.skip('V8 inspector is disabled');\n+    skip('V8 inspector is disabled');\n   }\n-  if (!exports.isMainThread) {\n+  if (!isMainThread) {\n     // TODO(addaleax): Fix me.\n-    exports.skip('V8 inspector is not available in Workers');\n+    skip('V8 inspector is not available in Workers');\n   }\n-};\n+}\n \n-exports.skipIf32Bits = function skipIf32Bits() {\n-  if (process.binding('config').bits < 64) {\n-    exports.skip('The tested feature is not available in 32bit builds');\n+function skipIf32Bits() {\n+  if (bits < 64) {\n+    skip('The tested feature is not available in 32bit builds');\n   }\n-};\n+}\n \n-exports.getArrayBufferViews = function getArrayBufferViews(buf) {\n+function getArrayBufferViews(buf) {\n   const { buffer, byteOffset, byteLength } = buf;\n \n   const out = [];\n@@ -750,20 +653,20 @@ exports.getArrayBufferViews = function getArrayBufferViews(buf) {\n     }\n   }\n   return out;\n-};\n+}\n \n-exports.getBufferSources = function getBufferSources(buf) {\n-  return [...exports.getArrayBufferViews(buf), new Uint8Array(buf).buffer];\n-};\n+function getBufferSources(buf) {\n+  return [...getArrayBufferViews(buf), new Uint8Array(buf).buffer];\n+}\n \n // Crash the process on unhandled rejections.\n const crashOnUnhandledRejection = (err) => { throw err; };\n process.on('unhandledRejection', crashOnUnhandledRejection);\n-exports.disableCrashOnUnhandledRejection = function() {\n+function disableCrashOnUnhandledRejection() {\n   process.removeListener('unhandledRejection', crashOnUnhandledRejection);\n-};\n+}\n \n-exports.getTTYfd = function getTTYfd() {\n+function getTTYfd() {\n   // Do our best to grab a tty fd.\n   const tty = require('tty');\n   // Don't attempt fd 0 as it is not writable on Windows.\n@@ -778,9 +681,9 @@ exports.getTTYfd = function getTTYfd() {\n     }\n   }\n   return ttyFd;\n-};\n+}\n \n-exports.runWithInvalidFD = function(func) {\n+function runWithInvalidFD(func) {\n   let fd = 1 << 30;\n   // Get first known bad file descriptor. 1 << 30 is usually unlikely to\n   // be an valid one.\n@@ -790,5 +693,126 @@ exports.runWithInvalidFD = function(func) {\n     return func(fd);\n   }\n \n-  exports.printSkipMessage('Could not generate an invalid fd');\n+  printSkipMessage('Could not generate an invalid fd');\n+}\n+\n+module.exports = {\n+  allowGlobals,\n+  buildType,\n+  busyLoop,\n+  canCreateSymLink,\n+  childShouldThrowAndAbort,\n+  ddCommand,\n+  disableCrashOnUnhandledRejection,\n+  enoughTestCpu,\n+  enoughTestMem,\n+  expectsError,\n+  expectWarning,\n+  getArrayBufferViews,\n+  getBufferSources,\n+  getCallSite,\n+  getTTYfd,\n+  hasIntl,\n+  hasCrypto,\n+  hasIPv6,\n+  hasSmallICU,\n+  hasMultiLocalhost,\n+  isAIX,\n+  isAlive,\n+  isFreeBSD,\n+  isLinux,\n+  isLinuxPPCBE,\n+  isMainThread,\n+  isOpenBSD,\n+  isOSX,\n+  isSunOS,\n+  isWindows,\n+  isWOW64,\n+  leakedGlobals,\n+  localIPv6Hosts,\n+  mustCall,\n+  mustCallAsync,\n+  mustCallAtLeast,\n+  mustNotCall,\n+  nodeProcessAborted,\n+  noWarnCode: undefined,\n+  PIPE,\n+  platformTimeout,\n+  printSkipMessage,\n+  pwdCommand,\n+  rootDir,\n+  runWithInvalidFD,\n+  skip,\n+  skipIf32Bits,\n+  skipIfEslintMissing,\n+  skipIfInspectorDisabled,\n+\n+  get localhostIPv6() { return '::1'; },\n+\n+  get hasFipsCrypto() {\n+    return hasCrypto && require('crypto').fips;\n+  },\n+\n+  get inFreeBSDJail() {\n+    if (inFreeBSDJail !== null) return inFreeBSDJail;\n+\n+    if (exports.isFreeBSD &&\n+        execSync('sysctl -n security.jail.jailed').toString() === '1\\n') {\n+      inFreeBSDJail = true;\n+    } else {\n+      inFreeBSDJail = false;\n+    }\n+    return inFreeBSDJail;\n+  },\n+\n+  get localhostIPv4() {\n+    if (localhostIPv4 !== null) return localhostIPv4;\n+\n+    if (this.inFreeBSDJail) {\n+      // Jailed network interfaces are a bit special - since we need to jump\n+      // through loops, as well as this being an exception case, assume the\n+      // user will provide this instead.\n+      if (process.env.LOCALHOST) {\n+        localhostIPv4 = process.env.LOCALHOST;\n+      } else {\n+        console.error('Looks like we\\'re in a FreeBSD Jail. ' +\n+                      'Please provide your default interface address ' +\n+                      'as LOCALHOST or expect some tests to fail.');\n+      }\n+    }\n+\n+    if (localhostIPv4 === null) localhostIPv4 = '127.0.0.1';\n+\n+    return localhostIPv4;\n+  },\n+\n+  // opensslCli defined lazily to reduce overhead of spawnSync\n+  get opensslCli() {\n+    if (opensslCli !== null) return opensslCli;\n+\n+    if (process.config.variables.node_shared_openssl) {\n+      // use external command\n+      opensslCli = 'openssl';\n+    } else {\n+      // use command built from sources included in Node.js repository\n+      opensslCli = path.join(path.dirname(process.execPath), 'openssl-cli');\n+    }\n+\n+    if (exports.isWindows) opensslCli += '.exe';\n+\n+    const opensslCmd = spawnSync(opensslCli, ['version']);\n+    if (opensslCmd.status !== 0 || opensslCmd.error !== undefined) {\n+      // openssl command cannot be executed\n+      opensslCli = false;\n+    }\n+    return opensslCli;\n+  },\n+\n+  get PORT() {\n+    if (+process.env.TEST_PARALLEL) {\n+      throw new Error('common.PORT cannot be used in a parallelized test');\n+    }\n+    return +process.env.NODE_COMMON_PORT || 12346;\n+  }\n+\n };"
        },
        {
            "sha": "e0842011c663c930f49aa6f8993e71ba055e6488",
            "filename": "test/common/index.mjs",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/286ca2c12de1c7b5cb17cb9ae5928fb8090d7ba2/test%2Fcommon%2Findex.mjs",
            "raw_url": "https://github.com/nodejs/node/raw/286ca2c12de1c7b5cb17cb9ae5928fb8090d7ba2/test%2Fcommon%2Findex.mjs",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcommon%2Findex.mjs?ref=286ca2c12de1c7b5cb17cb9ae5928fb8090d7ba2",
            "patch": "@@ -23,8 +23,6 @@ const {\n   hasIPv6,\n   childShouldThrowAndAbort,\n   ddCommand,\n-  spawnPwd,\n-  spawnSyncPwd,\n   platformTimeout,\n   allowGlobals,\n   leakedGlobals,\n@@ -75,8 +73,6 @@ export {\n   hasIPv6,\n   childShouldThrowAndAbort,\n   ddCommand,\n-  spawnPwd,\n-  spawnSyncPwd,\n   platformTimeout,\n   allowGlobals,\n   leakedGlobals,"
        }
    ],
    "stats": {
        "total": 438,
        "additions": 229,
        "deletions": 209
    }
}