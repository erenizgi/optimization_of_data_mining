{
    "author": "apapirovski",
    "message": "timers: run nextTicks after each immediate and timer\n\nIn order to better match the browser behaviour, run nextTicks (and\nsubsequently the microtask queue) after each individual Timer and\nImmediate, rather than after the whole list is processed. The\ncurrent behaviour is somewhat of a performance micro-optimization\nand also partly dictated by how timer handles were implemented.\n\nPR-URL: https://github.com/nodejs/node/pull/22842\nFixes: https://github.com/nodejs/node/issues/22257\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Jeremiah Senkpiel <fishrock123@rocketmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "e7af9830e98fcda7e7a11e0b13b667163cc8c940",
    "files": [
        {
            "sha": "781e505ae41ea25ede7d18ef8f9555c2f12a499f",
            "filename": "benchmark/timers/timers-timeout-nexttick.js",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/benchmark%2Ftimers%2Ftimers-timeout-nexttick.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/benchmark%2Ftimers%2Ftimers-timeout-nexttick.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Ftimers%2Ftimers-timeout-nexttick.js?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -0,0 +1,36 @@\n+'use strict';\n+const common = require('../common.js');\n+\n+// The following benchmark measures setting up n * 1e6 timeouts,\n+// as well as scheduling a next tick from each timeout. Those\n+// then get executed on the next uv tick.\n+\n+const bench = common.createBenchmark(main, {\n+  n: [5e4, 5e6],\n+});\n+\n+function main({ n }) {\n+  let count = 0;\n+\n+  // Function tracking on the hidden class in V8 can cause misleading\n+  // results in this benchmark if only a single function is used â€”\n+  // alternate between two functions for a fairer benchmark.\n+\n+  function cb() {\n+    process.nextTick(counter);\n+  }\n+  function cb2() {\n+    process.nextTick(counter);\n+  }\n+  function counter() {\n+    count++;\n+    if (count === n)\n+      bench.end(n);\n+  }\n+\n+  for (var i = 0; i < n; i++) {\n+    setTimeout(i % 2 ? cb : cb2, 1);\n+  }\n+\n+  bench.start();\n+}"
        },
        {
            "sha": "3907271bbfa26c9c72ecb01fa5dbb62f61cf4c72",
            "filename": "doc/api/process.md",
            "status": "modified",
            "additions": 5,
            "deletions": 13,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/doc%2Fapi%2Fprocess.md",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/doc%2Fapi%2Fprocess.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fprocess.md?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -1461,13 +1461,11 @@ changes:\n * `callback` {Function}\n * `...args` {any} Additional arguments to pass when invoking the `callback`\n \n-The `process.nextTick()` method adds the `callback` to the \"next tick queue\".\n-Once the current turn of the event loop turn runs to completion, all callbacks\n-currently in the next tick queue will be called.\n-\n-This is *not* a simple alias to [`setTimeout(fn, 0)`][]. It is much more\n-efficient. It runs before any additional I/O events (including\n-timers) fire in subsequent ticks of the event loop.\n+`process.nextTick()` adds `callback` to the \"next tick queue\". This queue is\n+fully drained after the current operation on the JavaScript stack runs to\n+completion and before the event loop is allowed to continue. As a result, it's\n+possible to create an infinite loop if one were to recursively call\n+`process.nextTick()`.\n \n ```js\n console.log('start');\n@@ -1542,11 +1540,6 @@ function definitelyAsync(arg, cb) {\n }\n ```\n \n-The next tick queue is completely drained on each pass of the event loop\n-**before** additional I/O is processed. As a result, recursively setting\n-`nextTick()` callbacks will block any I/O from happening, just like a\n-`while(true);` loop.\n-\n ## process.noDeprecation\n <!-- YAML\n added: v0.8.0\n@@ -2162,7 +2155,6 @@ cases:\n [`require()`]: globals.html#globals_require\n [`require.main`]: modules.html#modules_accessing_the_main_module\n [`require.resolve()`]: modules.html#modules_require_resolve_request_options\n-[`setTimeout(fn, 0)`]: timers.html#timers_settimeout_callback_delay_args\n [`v8.setFlagsFromString()`]: v8.html#v8_v8_setflagsfromstring_flags\n [Android building]: https://github.com/nodejs/node/blob/master/BUILDING.md#androidandroid-based-devices-eg-firefox-os\n [Child Process]: child_process.html"
        },
        {
            "sha": "046449d6581dbf5d18d698a60455e9955d5a0725",
            "filename": "lib/internal/process/next_tick.js",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/lib%2Finternal%2Fprocess%2Fnext_tick.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/lib%2Finternal%2Fprocess%2Fnext_tick.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fnext_tick.js?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -26,7 +26,7 @@ function setupNextTick(_setupNextTick, _setupPromises) {\n   const [\n     tickInfo,\n     runMicrotasks\n-  ] = _setupNextTick(_tickCallback);\n+  ] = _setupNextTick(internalTickCallback);\n \n   // *Must* match Environment::TickInfo::Fields in src/env.h.\n   const kHasScheduled = 0;\n@@ -39,6 +39,15 @@ function setupNextTick(_setupNextTick, _setupPromises) {\n   process._tickCallback = _tickCallback;\n \n   function _tickCallback() {\n+    if (tickInfo[kHasScheduled] === 0 && tickInfo[kHasPromiseRejections] === 0)\n+      runMicrotasks();\n+    if (tickInfo[kHasScheduled] === 0 && tickInfo[kHasPromiseRejections] === 0)\n+      return;\n+\n+    internalTickCallback();\n+  }\n+\n+  function internalTickCallback() {\n     let tock;\n     do {\n       while (tock = queue.shift()) {"
        },
        {
            "sha": "575dcf25f6e481f98590a86b3500346aa464da57",
            "filename": "lib/timers.js",
            "status": "modified",
            "additions": 76,
            "deletions": 99,
            "changes": 175,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/lib%2Ftimers.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/lib%2Ftimers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ftimers.js?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -254,16 +254,17 @@ function processTimers(now) {\n   debug('process timer lists %d', now);\n   nextExpiry = Infinity;\n \n-  let list, ran;\n+  let list;\n+  let ranAtLeastOneList = false;\n   while (list = queue.peek()) {\n     if (list.expiry > now) {\n       nextExpiry = list.expiry;\n       return refCount > 0 ? nextExpiry : -nextExpiry;\n     }\n-    if (ran)\n+    if (ranAtLeastOneList)\n       runNextTicks();\n     else\n-      ran = true;\n+      ranAtLeastOneList = true;\n     listOnTimeout(list, now);\n   }\n   return 0;\n@@ -275,6 +276,7 @@ function listOnTimeout(list, now) {\n   debug('timeout callback %d', msecs);\n \n   var diff, timer;\n+  let ranAtLeastOneTimer = false;\n   while (timer = L.peek(list)) {\n     diff = now - timer._idleStart;\n \n@@ -288,6 +290,11 @@ function listOnTimeout(list, now) {\n       return;\n     }\n \n+    if (ranAtLeastOneTimer)\n+      runNextTicks();\n+    else\n+      ranAtLeastOneTimer = true;\n+\n     // The actual logic for when a timeout happens.\n     L.remove(timer);\n \n@@ -307,7 +314,33 @@ function listOnTimeout(list, now) {\n \n     emitBefore(asyncId, timer[trigger_async_id_symbol]);\n \n-    tryOnTimeout(timer);\n+    let start;\n+    if (timer._repeat)\n+      start = getLibuvNow();\n+\n+    try {\n+      const args = timer._timerArgs;\n+      if (!args)\n+        timer._onTimeout();\n+      else\n+        Reflect.apply(timer._onTimeout, timer, args);\n+    } finally {\n+      if (timer._repeat && timer._idleTimeout !== -1) {\n+        timer._idleTimeout = timer._repeat;\n+        if (start === undefined)\n+          start = getLibuvNow();\n+        insert(timer, timer[kRefed], start);\n+      } else {\n+        if (timer[kRefed])\n+          refCount--;\n+        timer[kRefed] = null;\n+\n+        if (destroyHooksExist() && !timer._destroyed) {\n+          emitDestroy(timer[async_id_symbol]);\n+          timer._destroyed = true;\n+        }\n+      }\n+    }\n \n     emitAfter(asyncId);\n   }\n@@ -327,30 +360,6 @@ function listOnTimeout(list, now) {\n }\n \n \n-// An optimization so that the try/finally only de-optimizes (since at least v8\n-// 4.7) what is in this smaller function.\n-function tryOnTimeout(timer, start) {\n-  if (start === undefined && timer._repeat)\n-    start = getLibuvNow();\n-  try {\n-    ontimeout(timer);\n-  } finally {\n-    if (timer._repeat) {\n-      rearm(timer, start);\n-    } else {\n-      if (timer[kRefed])\n-        refCount--;\n-      timer[kRefed] = null;\n-\n-      if (destroyHooksExist() && !timer._destroyed) {\n-        emitDestroy(timer[async_id_symbol]);\n-        timer._destroyed = true;\n-      }\n-    }\n-  }\n-}\n-\n-\n // Remove a timer. Cancels the timeout and resets the relevant timer properties.\n function unenroll(item) {\n   // Fewer checks may be possible, but these cover everything.\n@@ -456,26 +465,6 @@ setTimeout[internalUtil.promisify.custom] = function(after, value) {\n exports.setTimeout = setTimeout;\n \n \n-function ontimeout(timer) {\n-  const args = timer._timerArgs;\n-  if (typeof timer._onTimeout !== 'function')\n-    return Promise.resolve(timer._onTimeout, args[0]);\n-  if (!args)\n-    timer._onTimeout();\n-  else\n-    Reflect.apply(timer._onTimeout, timer, args);\n-}\n-\n-function rearm(timer, start) {\n-  // Do not re-arm unenroll'd or closed timers.\n-  if (timer._idleTimeout === -1)\n-    return;\n-\n-  timer._idleTimeout = timer._repeat;\n-  insert(timer, timer[kRefed], start);\n-}\n-\n-\n const clearTimeout = exports.clearTimeout = function clearTimeout(timer) {\n   if (timer && timer._onTimeout) {\n     timer._onTimeout = null;\n@@ -601,75 +590,63 @@ function processImmediate() {\n   const queue = outstandingQueue.head !== null ?\n     outstandingQueue : immediateQueue;\n   var immediate = queue.head;\n-  const tail = queue.tail;\n \n   // Clear the linked list early in case new `setImmediate()` calls occur while\n   // immediate callbacks are executed\n-  queue.head = queue.tail = null;\n-\n-  let count = 0;\n-  let refCount = 0;\n+  if (queue !== outstandingQueue) {\n+    queue.head = queue.tail = null;\n+    immediateInfo[kHasOutstanding] = 1;\n+  }\n \n+  let prevImmediate;\n+  let ranAtLeastOneImmediate = false;\n   while (immediate !== null) {\n-    immediate._destroyed = true;\n+    if (ranAtLeastOneImmediate)\n+      runNextTicks();\n+    else\n+      ranAtLeastOneImmediate = true;\n \n-    const asyncId = immediate[async_id_symbol];\n-    emitBefore(asyncId, immediate[trigger_async_id_symbol]);\n+    // It's possible for this current Immediate to be cleared while executing\n+    // the next tick queue above, which means we need to use the previous\n+    // Immediate's _idleNext which is guaranteed to not have been cleared.\n+    if (immediate._destroyed) {\n+      outstandingQueue.head = immediate = prevImmediate._idleNext;\n+      continue;\n+    }\n \n-    count++;\n+    immediate._destroyed = true;\n+\n+    immediateInfo[kCount]--;\n     if (immediate[kRefed])\n-      refCount++;\n+      immediateInfo[kRefCount]--;\n     immediate[kRefed] = null;\n \n-    tryOnImmediate(immediate, tail, count, refCount);\n+    prevImmediate = immediate;\n \n-    emitAfter(asyncId);\n+    const asyncId = immediate[async_id_symbol];\n+    emitBefore(asyncId, immediate[trigger_async_id_symbol]);\n \n-    immediate = immediate._idleNext;\n-  }\n+    try {\n+      const argv = immediate._argv;\n+      if (!argv)\n+        immediate._onImmediate();\n+      else\n+        Reflect.apply(immediate._onImmediate, immediate, argv);\n+    } finally {\n+      immediate._onImmediate = null;\n \n-  immediateInfo[kCount] -= count;\n-  immediateInfo[kRefCount] -= refCount;\n-  immediateInfo[kHasOutstanding] = 0;\n-}\n+      if (destroyHooksExist())\n+        emitDestroy(asyncId);\n \n-// An optimization so that the try/finally only de-optimizes (since at least v8\n-// 4.7) what is in this smaller function.\n-function tryOnImmediate(immediate, oldTail, count, refCount) {\n-  var threw = true;\n-  try {\n-    // make the actual call outside the try/finally to allow it to be optimized\n-    runCallback(immediate);\n-    threw = false;\n-  } finally {\n-    immediate._onImmediate = null;\n-\n-    if (destroyHooksExist()) {\n-      emitDestroy(immediate[async_id_symbol]);\n+      outstandingQueue.head = immediate = immediate._idleNext;\n     }\n \n-    if (threw) {\n-      immediateInfo[kCount] -= count;\n-      immediateInfo[kRefCount] -= refCount;\n-\n-      if (immediate._idleNext !== null) {\n-        // Handle any remaining Immediates after error handling has resolved,\n-        // assuming we're still alive to do so.\n-        outstandingQueue.head = immediate._idleNext;\n-        outstandingQueue.tail = oldTail;\n-        immediateInfo[kHasOutstanding] = 1;\n-      }\n-    }\n+    emitAfter(asyncId);\n   }\n-}\n \n-function runCallback(timer) {\n-  const argv = timer._argv;\n-  if (typeof timer._onImmediate !== 'function')\n-    return Promise.resolve(timer._onImmediate, argv[0]);\n-  if (!argv)\n-    return timer._onImmediate();\n-  Reflect.apply(timer._onImmediate, timer, argv);\n+  if (queue === outstandingQueue)\n+    outstandingQueue.head = null;\n+  immediateInfo[kHasOutstanding] = 0;\n }\n \n "
        },
        {
            "sha": "4d0eba3a8537a600d818f4756d0c6ce684c011bd",
            "filename": "test/message/events_unhandled_error_nexttick.out",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Fevents_unhandled_error_nexttick.out",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Fevents_unhandled_error_nexttick.out",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fmessage%2Fevents_unhandled_error_nexttick.out?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -14,6 +14,7 @@ Error\n     at bootstrapNodeJSCore (internal/bootstrap/node.js:*:*)\n Emitted 'error' event at:\n     at process.nextTick (*events_unhandled_error_nexttick.js:*:*)\n+    at internalTickCallback (internal/process/next_tick.js:*:*)\n     at process._tickCallback (internal/process/next_tick.js:*:*)\n     at Function.Module.runMain (internal/modules/cjs/loader.js:*:*)\n     at startup (internal/bootstrap/node.js:*:*)"
        },
        {
            "sha": "09b00de80fa08013dba8937946faf3cfa33e4a45",
            "filename": "test/message/nexttick_throw.out",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Fnexttick_throw.out",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Fnexttick_throw.out",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fmessage%2Fnexttick_throw.out?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -4,6 +4,7 @@\n         ^\n ReferenceError: undefined_reference_error_maker is not defined\n     at *test*message*nexttick_throw.js:*:*\n+    at internalTickCallback (internal/process/next_tick.js:*:*)\n     at process._tickCallback (internal/process/next_tick.js:*:*)\n     at Function.Module.runMain (internal/modules/cjs/loader.js:*:*)\n     at startup (internal/bootstrap/node.js:*:*)"
        },
        {
            "sha": "bbf996bb56a13c482b7da7465be7a04737031a7c",
            "filename": "test/message/stdin_messages.out",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Fstdin_messages.out",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Fstdin_messages.out",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fmessage%2Fstdin_messages.out?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -12,7 +12,7 @@ SyntaxError: Strict mode code may not include a with statement\n     at Socket.<anonymous> (internal/bootstrap/node.js:*:*)\n     at Socket.emit (events.js:*:*)\n     at endReadableNT (_stream_readable.js:*:*)\n-    at process._tickCallback (internal/process/next_tick.js:*:*)\n+    at process.internalTickCallback (internal/process/next_tick.js:*:*)\n 42\n 42\n [stdin]:1\n@@ -29,7 +29,7 @@ Error: hello\n     at Socket.<anonymous> (internal/bootstrap/node.js:*:*)\n     at Socket.emit (events.js:*:*)\n     at endReadableNT (_stream_readable.js:*:*)\n-    at process._tickCallback (internal/process/next_tick.js:*:*)\n+    at process.internalTickCallback (internal/process/next_tick.js:*:*)\n [stdin]:1\n throw new Error(\"hello\")\n ^\n@@ -44,7 +44,7 @@ Error: hello\n     at Socket.<anonymous> (internal/bootstrap/node.js:*:*)\n     at Socket.emit (events.js:*:*)\n     at endReadableNT (_stream_readable.js:*:*)\n-    at process._tickCallback (internal/process/next_tick.js:*:*)\n+    at process.internalTickCallback (internal/process/next_tick.js:*:*)\n 100\n [stdin]:1\n var x = 100; y = x;\n@@ -60,7 +60,7 @@ ReferenceError: y is not defined\n     at Socket.<anonymous> (internal/bootstrap/node.js:*:*)\n     at Socket.emit (events.js:*:*)\n     at endReadableNT (_stream_readable.js:*:*)\n-    at process._tickCallback (internal/process/next_tick.js:*:*)\n+    at process.internalTickCallback (internal/process/next_tick.js:*:*)\n \n [stdin]:1\n var ______________________________________________; throw 10"
        },
        {
            "sha": "d97f8b1887cfe4974f415287d2e89dfabec47cfe",
            "filename": "test/message/timeout_throw.out",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Ftimeout_throw.out",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Ftimeout_throw.out",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fmessage%2Ftimeout_throw.out?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -3,7 +3,5 @@\n   ^\n ReferenceError: undefined_reference_error_maker is not defined\n     at Timeout._onTimeout (*test*message*timeout_throw.js:*:*)\n-    at ontimeout (timers.js:*:*)\n-    at tryOnTimeout (timers.js:*:*)\n     at listOnTimeout (timers.js:*:*)\n     at processTimers (timers.js:*:*)"
        },
        {
            "sha": "cf12c647ac67b1d79d1f9996259430c6487cefd2",
            "filename": "test/message/unhandled_promise_trace_warnings.out",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Funhandled_promise_trace_warnings.out",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fmessage%2Funhandled_promise_trace_warnings.out",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fmessage%2Funhandled_promise_trace_warnings.out?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -14,6 +14,7 @@\n     at *\n     at *\n     at *\n+    at *\n (node:*) Error: This was rejected\n     at * (*test*message*unhandled_promise_trace_warnings.js:*)\n     at *\n@@ -32,12 +33,11 @@\n     at *\n     at *\n     at *\n+    at *\n (node:*) PromiseRejectionHandledWarning: Promise rejection was handled asynchronously (rejection id: 1)\n     at handledRejection (internal/process/promises.js:*)\n     at handler (internal/process/promises.js:*)\n     at Promise.then *\n     at Promise.catch *\n     at Immediate.setImmediate (*test*message*unhandled_promise_trace_warnings.js:*)\n     at *\n-    at *\n-    at *"
        },
        {
            "sha": "f22273e01c9db8de70fce39b5ec46dfffda7d05a",
            "filename": "test/parallel/test-process-fatal-exception-tick.js",
            "status": "removed",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/4e9e0d339efa46316d90d6f2618afd0c0fc6cd34/test%2Fparallel%2Ftest-process-fatal-exception-tick.js",
            "raw_url": "https://github.com/nodejs/node/raw/4e9e0d339efa46316d90d6f2618afd0c0fc6cd34/test%2Fparallel%2Ftest-process-fatal-exception-tick.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-process-fatal-exception-tick.js?ref=4e9e0d339efa46316d90d6f2618afd0c0fc6cd34",
            "patch": "@@ -1,26 +0,0 @@\n-'use strict';\n-\n-const common = require('../common');\n-const assert = require('assert');\n-\n-if (!common.isMainThread)\n-  common.skip('Error handling timing is different in Workers');\n-\n-// If a process encounters an uncaughtException, it should schedule\n-// processing of nextTicks on the next Immediates cycle but not\n-// before all Immediates are handled\n-\n-let stage = 0;\n-\n-process.once('uncaughtException', common.expectsError({\n-  type: Error,\n-  message: 'caughtException'\n-}));\n-\n-setImmediate(() => {\n-  stage++;\n-  process.nextTick(() => assert.strictEqual(stage, 2));\n-});\n-setTimeout(() => setImmediate(() => stage++), 1);\n-common.busyLoop(10);\n-throw new Error('caughtException');"
        },
        {
            "sha": "7e7cabeda744330292254057686020898026540c",
            "filename": "test/parallel/test-repl-underscore.js",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fparallel%2Ftest-repl-underscore.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fparallel%2Ftest-repl-underscore.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-repl-underscore.js?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -195,8 +195,6 @@ function testError() {\n       /setImmediate/,\n       /^    at/,\n       /^    at/,\n-      /^    at/,\n-      /^    at/,\n     ];\n     for (const line of lines) {\n       const expected = expectedLines.shift();"
        },
        {
            "sha": "dd793eead03438195a013255f3544c68bc9bfee5",
            "filename": "test/parallel/test-timers-immediate-queue.js",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fparallel%2Ftest-timers-immediate-queue.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fparallel%2Ftest-timers-immediate-queue.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-timers-immediate-queue.js?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -33,11 +33,14 @@ const assert = require('assert');\n let ticked = false;\n \n let hit = 0;\n-const QUEUE = 1000;\n+const QUEUE = 10;\n \n function run() {\n-  if (hit === 0)\n-    process.nextTick(function() { ticked = true; });\n+  if (hit === 0) {\n+    setTimeout(() => { ticked = true; }, 1);\n+    const now = Date.now();\n+    while (Date.now() - now < 2);\n+  }\n \n   if (ticked) return;\n "
        },
        {
            "sha": "89ebf6c8c1a9d71478294ff7a945f8df53f71217",
            "filename": "test/parallel/test-timers-next-tick.js",
            "status": "modified",
            "additions": 21,
            "deletions": 6,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fparallel%2Ftest-timers-next-tick.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7af9830e98fcda7e7a11e0b13b667163cc8c940/test%2Fparallel%2Ftest-timers-next-tick.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-timers-next-tick.js?ref=e7af9830e98fcda7e7a11e0b13b667163cc8c940",
            "patch": "@@ -2,14 +2,29 @@\n \n const common = require('../common');\n \n-// This test documents an internal implementation detail of the Timers:\n-// since timers of different durations are stored in separate lists,\n-// a nextTick queue will clear after each list of timers. While this\n-// behaviour is not documented it could be relied on by Node's users.\n+// This test verifies that the next tick queue runs after each\n+// individual Timeout, as well as each individual Immediate.\n \n setTimeout(common.mustCall(() => {\n-  process.nextTick(() => { clearTimeout(t2); });\n+  process.nextTick(() => {\n+    // Confirm that clearing Timeouts from a next tick doesn't explode.\n+    clearTimeout(t2);\n+    clearTimeout(t3);\n+  });\n }), 1);\n-const t2 = setTimeout(common.mustNotCall(), 2);\n+const t2 = setTimeout(common.mustNotCall(), 1);\n+const t3 = setTimeout(common.mustNotCall(), 1);\n+setTimeout(common.mustCall(), 1);\n \n common.busyLoop(5);\n+\n+setImmediate(common.mustCall(() => {\n+  process.nextTick(() => {\n+    // Confirm that clearing Immediates from a next tick doesn't explode.\n+    clearImmediate(i2);\n+    clearImmediate(i3);\n+  });\n+}));\n+const i2 = setImmediate(common.mustNotCall());\n+const i3 = setImmediate(common.mustNotCall());\n+setImmediate(common.mustCall());"
        }
    ],
    "stats": {
        "total": 320,
        "additions": 162,
        "deletions": 158
    }
}