{
    "author": "addaleax",
    "message": "worker: initial implementation\n\nImplement multi-threading support for most of the API.\n\nThanks to Stephen Belanger for reviewing this change in its\noriginal form, to Olivia Hugger for reviewing the\ndocumentation and some of the tests coming along with it,\nand to Alexey Orlenko and Timothy Gu for reviewing other\nparts of the tests.\n\nRefs: https://github.com/ayojs/ayo/pull/110\nRefs: https://github.com/ayojs/ayo/pull/114\nRefs: https://github.com/ayojs/ayo/pull/117\n\nPR-URL: https://github.com/nodejs/node/pull/20876\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Shingo Inoue <leko.noor@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "0df031acadcc6490379d72676203a980c8d60592",
    "files": [
        {
            "sha": "972d0971c4b0598ebb99df8878ad574bfeac1000",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -1313,6 +1313,13 @@ but not provided in the `transferList` for that call.\n \n An [ES6 module][] could not be resolved.\n \n+<a id=\"ERR_MISSING_PLATFORM_FOR_WORKER\"></a>\n+### ERR_MISSING_PLATFORM_FOR_WORKER\n+\n+The V8 platform used by this instance of Node.js does not support creating\n+Workers. This is caused by lack of embedder support for Workers. In particular,\n+this error will not occur with standard builds of Node.js.\n+\n <a id=\"ERR_MODULE_RESOLUTION_LEGACY\"></a>\n ### ERR_MODULE_RESOLUTION_LEGACY\n \n@@ -1722,6 +1729,22 @@ The fulfilled value of a linking promise is not a `vm.Module` object.\n The current module's status does not allow for this operation. The specific\n meaning of the error depends on the specific function.\n \n+<a id=\"ERR_WORKER_NEED_ABSOLUTE_PATH\"></a>\n+### ERR_WORKER_NEED_ABSOLUTE_PATH\n+\n+The path for the main script of a worker is not an absolute path.\n+\n+<a id=\"ERR_WORKER_UNSERIALIZABLE_ERROR\"></a>\n+### ERR_WORKER_UNSERIALIZABLE_ERROR\n+\n+All attempts at serializing an uncaught exception from a worker thread failed.\n+\n+<a id=\"ERR_WORKER_UNSUPPORTED_EXTENSION\"></a>\n+### ERR_WORKER_UNSUPPORTED_EXTENSION\n+\n+The pathname used for the main script of a worker has an\n+unknown file extension.\n+\n <a id=\"ERR_ZLIB_INITIALIZATION_FAILED\"></a>\n ### ERR_ZLIB_INITIALIZATION_FAILED\n "
        },
        {
            "sha": "0a9c52a44c3e2356c60c80536f0c235fff0a2612",
            "filename": "doc/api/process.md",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/doc%2Fapi%2Fprocess.md",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/doc%2Fapi%2Fprocess.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fprocess.md?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -410,6 +410,8 @@ added: v0.7.0\n The `process.abort()` method causes the Node.js process to exit immediately and\n generate a core file.\n \n+This feature is not available in [`Worker`][] threads.\n+\n ## process.arch\n <!-- YAML\n added: v0.5.0\n@@ -517,6 +519,8 @@ try {\n }\n ```\n \n+This feature is not available in [`Worker`][] threads.\n+\n ## process.config\n <!-- YAML\n added: v0.7.7\n@@ -918,6 +922,8 @@ console.log(process.env.test);\n // => 1\n ```\n \n+`process.env` is read-only in [`Worker`][] threads.\n+\n ## process.execArgv\n <!-- YAML\n added: v0.7.7\n@@ -1030,6 +1036,9 @@ If it is necessary to terminate the Node.js process due to an error condition,\n throwing an *uncaught* error and allowing the process to terminate accordingly\n is safer than calling `process.exit()`.\n \n+In [`Worker`][] threads, this function stops the current thread rather\n+than the current process.\n+\n ## process.exitCode\n <!-- YAML\n added: v0.11.8\n@@ -1203,6 +1212,7 @@ console.log(process.getgroups());         // [ 27, 30, 46, 1000 ]\n \n This function is only available on POSIX platforms (i.e. not Windows or\n Android).\n+This feature is not available in [`Worker`][] threads.\n \n ## process.kill(pid[, signal])\n <!-- YAML\n@@ -1306,6 +1316,9 @@ The _heap_ is where objects, strings, and closures are stored. Variables are\n stored in the _stack_ and the actual JavaScript code resides in the\n _code segment_.\n \n+When using [`Worker`][] threads, `rss` will be a value that is valid for the\n+entire process, while the other fields will only refer to the current thread.\n+\n ## process.nextTick(callback[, ...args])\n <!-- YAML\n added: v0.1.26\n@@ -1569,6 +1582,7 @@ if (process.getegid && process.setegid) {\n \n This function is only available on POSIX platforms (i.e. not Windows or\n Android).\n+This feature is not available in [`Worker`][] threads.\n \n ## process.seteuid(id)\n <!-- YAML\n@@ -1596,6 +1610,7 @@ if (process.geteuid && process.seteuid) {\n \n This function is only available on POSIX platforms (i.e. not Windows or\n Android).\n+This feature is not available in [`Worker`][] threads.\n \n ## process.setgid(id)\n <!-- YAML\n@@ -1623,6 +1638,7 @@ if (process.getgid && process.setgid) {\n \n This function is only available on POSIX platforms (i.e. not Windows or\n Android).\n+This feature is not available in [`Worker`][] threads.\n \n ## process.setgroups(groups)\n <!-- YAML\n@@ -1639,6 +1655,7 @@ The `groups` array can contain numeric group IDs, group names or both.\n \n This function is only available on POSIX platforms (i.e. not Windows or\n Android).\n+This feature is not available in [`Worker`][] threads.\n \n ## process.setuid(id)\n <!-- YAML\n@@ -1664,6 +1681,7 @@ if (process.getuid && process.setuid) {\n \n This function is only available on POSIX platforms (i.e. not Windows or\n Android).\n+This feature is not available in [`Worker`][] threads.\n \n ## process.setUncaughtExceptionCaptureCallback(fn)\n <!-- YAML\n@@ -1700,6 +1718,8 @@ a [Writable][] stream.\n `process.stderr` differs from other Node.js streams in important ways, see\n [note on process I/O][] for more information.\n \n+This feature is not available in [`Worker`][] threads.\n+\n ## process.stdin\n \n * {Stream}\n@@ -1732,6 +1752,8 @@ In \"old\" streams mode the `stdin` stream is paused by default, so one\n must call `process.stdin.resume()` to read from it. Note also that calling\n `process.stdin.resume()` itself would switch stream to \"old\" mode.\n \n+This feature is not available in [`Worker`][] threads.\n+\n ## process.stdout\n \n * {Stream}\n@@ -1750,6 +1772,8 @@ process.stdin.pipe(process.stdout);\n `process.stdout` differs from other Node.js streams in important ways, see\n [note on process I/O][] for more information.\n \n+This feature is not available in [`Worker`][] threads.\n+\n ### A note on process I/O\n \n `process.stdout` and `process.stderr` differ from other Node.js streams in\n@@ -1865,6 +1889,8 @@ console.log(\n );\n ```\n \n+This feature is not available in [`Worker`][] threads.\n+\n ## process.uptime()\n <!-- YAML\n added: v0.5.0\n@@ -1992,6 +2018,7 @@ cases:\n [`ChildProcess`]: child_process.html#child_process_class_childprocess\n [`Error`]: errors.html#errors_class_error\n [`EventEmitter`]: events.html#events_class_eventemitter\n+[`Worker`]: worker.html#worker_worker\n [`console.error()`]: console.html#console_console_error_data_args\n [`console.log()`]: console.html#console_console_log_data_args\n [`domain`]: domain.html"
        },
        {
            "sha": "f3b79199c1a1e9c18265701758e1bb1569a23654",
            "filename": "doc/api/vm.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/doc%2Fapi%2Fvm.md",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/doc%2Fapi%2Fvm.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fvm.md?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -174,7 +174,7 @@ const contextifiedSandbox = vm.createContext({ secret: 42 });\n \n Creates a new ES `Module` object.\n \n-*Note*: Properties assigned to the `import.meta` object that are objects may\n+Properties assigned to the `import.meta` object that are objects may\n allow the `Module` to access information outside the specified `context`, if the\n object is created in the top level context. Use `vm.runInContext()` to create\n objects in a specific context."
        },
        {
            "sha": "3517a4c86ac767cfed2da4b6c530dd4fdcf0d47f",
            "filename": "doc/api/worker.md",
            "status": "modified",
            "additions": 297,
            "deletions": 2,
            "changes": 299,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/doc%2Fapi%2Fworker.md",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/doc%2Fapi%2Fworker.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fworker.md?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -4,6 +4,94 @@\n \n > Stability: 1 - Experimental\n \n+The `worker` module provides a way to create multiple environments running\n+on independent threads, and to create message channels between them. It\n+can be accessed using:\n+\n+```js\n+const worker = require('worker');\n+```\n+\n+Workers are useful for performing CPU-intensive JavaScript operations; do not\n+use them for I/O, since Node.js’s built-in mechanisms for performing operations\n+asynchronously already treat it more efficiently than Worker threads can.\n+\n+Workers, unlike child processes or when using the `cluster` module, can also\n+share memory efficiently by transferring `ArrayBuffer` instances or sharing\n+`SharedArrayBuffer` instances between them.\n+\n+## Example\n+\n+```js\n+const { Worker, isMainThread, parentPort, workerData } = require('worker');\n+\n+if (isMainThread) {\n+  module.exports = async function parseJSAsync(script) {\n+    return new Promise((resolve, reject) => {\n+      const worker = new Worker(__filename, {\n+        workerData: script\n+      });\n+      worker.on('message', resolve);\n+      worker.on('error', reject);\n+      worker.on('exit', (code) => {\n+        if (code !== 0)\n+          reject(new Error(`Worker stopped with exit code ${code}`));\n+      });\n+    });\n+  };\n+} else {\n+  const { parse } = require('some-js-parsing-library');\n+  const script = workerData;\n+  parentPort.postMessage(parse(script));\n+}\n+```\n+\n+Note that this example spawns a Worker thread for each `parse` call.\n+In practice, it is strongly recommended to use a pool of Workers for these\n+kinds of tasks, since the overhead of creating Workers would likely exceed the\n+benefit of handing the work off to it.\n+\n+## worker.isMainThread\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {boolean}\n+\n+Is `true` if this code is not running inside of a [`Worker`][] thread.\n+\n+## worker.parentPort\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {null|MessagePort}\n+\n+If this thread was spawned as a [`Worker`][], this will be a [`MessagePort`][]\n+allowing communication with the parent thread. Messages sent using\n+`parentPort.postMessage()` will be available in the parent thread\n+using `worker.on('message')`, and messages sent from the parent thread\n+using `worker.postMessage()` will be available in this thread using\n+`parentPort.on('message')`.\n+\n+## worker.threadId\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {integer}\n+\n+An integer identifier for the current thread. On the corresponding worker object\n+(if there is any), it is available as [`worker.threadId`][].\n+\n+## worker.workerData\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+An arbitrary JavaScript value that contains a clone of the data passed\n+to this thread’s `Worker` constructor.\n+\n ## Class: MessageChannel\n <!-- YAML\n added: REPLACEME\n@@ -21,7 +109,7 @@ const { MessageChannel } = require('worker');\n const { port1, port2 } = new MessageChannel();\n port1.on('message', (message) => console.log('received', message));\n port2.postMessage({ foo: 'bar' });\n-// prints: received { foo: 'bar' }\n+// prints: received { foo: 'bar' } from the `port1.on('message')` listener\n ```\n \n ## Class: MessagePort\n@@ -141,13 +229,220 @@ If listeners are attached or removed using `.on('message')`, the port will\n be `ref()`ed and `unref()`ed automatically depending on whether\n listeners for the event exist.\n \n+## Class: Worker\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+The `Worker` class represents an independent JavaScript execution thread.\n+Most Node.js APIs are available inside of it.\n+\n+Notable differences inside a Worker environment are:\n+\n+- The [`process.stdin`][], [`process.stdout`][] and [`process.stderr`][]\n+  properties are set to `null`.\n+- The [`require('worker').isMainThread`][] property is set to `false`.\n+- The [`require('worker').parentPort`][] message port is available,\n+- [`process.exit()`][] does not stop the whole program, just the single thread,\n+  and [`process.abort()`][] is not available.\n+- [`process.chdir()`][] and `process` methods that set group or user ids\n+  are not available.\n+- [`process.env`][] is a read-only reference to the environment variables.\n+- [`process.title`][] cannot be modified.\n+- Signals will not be delivered through [`process.on('...')`][Signals events].\n+- Execution may stop at any point as a result of [`worker.terminate()`][]\n+  being invoked.\n+- IPC channels from parent processes are not accessible.\n+\n+Currently, the following differences also exist until they are addressed:\n+\n+- The [`inspector`][] module is not available yet.\n+- Native addons are not supported yet.\n+\n+Creating `Worker` instances inside of other `Worker`s is possible.\n+\n+Like [Web Workers][] and the [`cluster` module][], two-way communication can be\n+achieved through inter-thread message passing. Internally, a `Worker` has a\n+built-in pair of [`MessagePort`][]s that are already associated with each other\n+when the `Worker` is created. While the `MessagePort` object on the parent side\n+is not directly exposed, its functionalities are exposed through\n+[`worker.postMessage()`][] and the [`worker.on('message')`][] event\n+on the `Worker` object for the parent thread.\n+\n+To create custom messaging channels (which is encouraged over using the default\n+global channel because it facilitates separation of concerns), users can create\n+a `MessageChannel` object on either thread and pass one of the\n+`MessagePort`s on that `MessageChannel` to the other thread through a\n+pre-existing channel, such as the global one.\n+\n+See [`port.postMessage()`][] for more information on how messages are passed,\n+and what kind of JavaScript values can be successfully transported through\n+the thread barrier.\n+\n+For example:\n+\n+```js\n+const assert = require('assert');\n+const { Worker, MessageChannel, MessagePort, isMainThread } = require('worker');\n+if (isMainThread) {\n+  const worker = new Worker(__filename);\n+  const subChannel = new MessageChannel();\n+  worker.postMessage({ hereIsYourPort: subChannel.port1 }, [subChannel.port1]);\n+  subChannel.port2.on('message', (value) => {\n+    console.log('received:', value);\n+  });\n+} else {\n+  require('worker').once('workerMessage', (value) => {\n+    assert(value.hereIsYourPort instanceof MessagePort);\n+    value.hereIsYourPort.postMessage('the worker is sending this');\n+    value.hereIsYourPort.close();\n+  });\n+}\n+```\n+\n+### new Worker(filename, options)\n+\n+* `filename` {string} The absolute path to the Worker’s main script.\n+  If `options.eval` is true, this is a string containing JavaScript code rather\n+  than a path.\n+* `options` {Object}\n+  * `eval` {boolean} If true, interpret the first argument to the constructor\n+    as a script that is executed once the worker is online.\n+  * `data` {any} Any JavaScript value that will be cloned and made\n+    available as [`require('worker').workerData`][]. The cloning will occur as\n+    described in the [HTML structured clone algorithm][], and an error will be\n+    thrown if the object cannot be cloned (e.g. because it contains\n+    `function`s).\n+\n+### Event: 'error'\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `err` {Error}\n+\n+The `'error'` event is emitted if the worker thread throws an uncaught\n+exception. In that case, the worker will be terminated.\n+\n+### Event: 'exit'\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `exitCode` {integer}\n+\n+The `'exit'` event is emitted once the worker has stopped. If the worker\n+exited by calling [`process.exit()`][], the `exitCode` parameter will be the\n+passed exit code. If the worker was terminated, the `exitCode` parameter will\n+be `1`.\n+\n+### Event: 'message'\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `value` {any} The transmitted value\n+\n+The `'message'` event is emitted when the worker thread has invoked\n+[`require('worker').postMessage()`][]. See the [`port.on('message')`][] event\n+for more details.\n+\n+### Event: 'online'\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+The `'online'` event is emitted when the worker thread has started executing\n+JavaScript code.\n+\n+### worker.postMessage(value[, transferList])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `value` {any}\n+* `transferList` {Object[]}\n+\n+Send a message to the worker that will be received via\n+[`require('worker').on('workerMessage')`][]. See [`port.postMessage()`][] for\n+more details.\n+\n+### worker.ref()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Opposite of `unref()`, calling `ref()` on a previously `unref()`ed worker will\n+*not* let the program exit if it's the only active handle left (the default\n+behavior). If the worker is `ref()`ed, calling `ref()` again will have\n+no effect.\n+\n+### worker.terminate([callback])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `callback` {Function}\n+\n+Stop all JavaScript execution in the worker thread as soon as possible.\n+`callback` is an optional function that is invoked once this operation is known\n+to have completed.\n+\n+**Warning**: Currently, not all code in the internals of Node.js is prepared to\n+expect termination at arbitrary points in time and may crash if it encounters\n+that condition. Consequently, you should currently only call `.terminate()` if\n+it is known that the Worker thread is not accessing Node.js core modules other\n+than what is exposed in the `worker` module.\n+\n+### worker.threadId\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {integer}\n+\n+An integer identifier for the referenced thread. Inside the worker thread,\n+it is available as [`require('worker').threadId`][].\n+\n+### worker.unref()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Calling `unref()` on a worker will allow the thread to exit if this is the only\n+active handle in the event system. If the worker is already `unref()`ed calling\n+`unref()` again will have no effect.\n+\n [`Buffer`]: buffer.html\n-[child processes]: child_process.html\n [`EventEmitter`]: events.html\n [`MessagePort`]: #worker_class_messageport\n [`port.postMessage()`]: #worker_port_postmessage_value_transferlist\n+[`Worker`]: #worker_class_worker\n+[`worker.terminate()`]: #worker_worker_terminate_callback\n+[`worker.postMessage()`]: #worker_worker_postmessage_value_transferlist_1\n+[`worker.on('message')`]: #worker_event_message_1\n+[`worker.threadId`]: #worker_worker_threadid_1\n+[`port.on('message')`]: #worker_event_message\n+[`process.exit()`]: process.html#process_process_exit_code\n+[`process.abort()`]: process.html#process_process_abort\n+[`process.chdir()`]: process.html#process_process_chdir_directory\n+[`process.env`]: process.html#process_process_env\n+[`process.stdin`]: process.html#process_process_stdin\n+[`process.stderr`]: process.html#process_process_stderr\n+[`process.stdout`]: process.html#process_process_stdout\n+[`process.title`]: process.html#process_process_title\n+[`require('worker').workerData`]: #worker_worker_workerdata\n+[`require('worker').on('workerMessage')`]: #worker_event_workermessage\n+[`require('worker').postMessage()`]: #worker_worker_postmessage_value_transferlist\n+[`require('worker').isMainThread`]: #worker_worker_ismainthread\n+[`require('worker').threadId`]: #worker_worker_threadid\n+[`cluster` module]: cluster.html\n+[`inspector`]: inspector.html\n [v8.serdes]: v8.html#v8_serialization_api\n [`SharedArrayBuffer`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\n+[Signals events]: process.html#process_signal_events\n [`Uint8Array`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n [browser `MessagePort`]: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\n+[child processes]: child_process.html\n [HTML structured clone algorithm]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n+[Web Workers]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API"
        },
        {
            "sha": "f4ec71fd6c2105b4e1f2ecd474fd453e3992fd79",
            "filename": "lib/inspector.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/lib%2Finspector.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/lib%2Finspector.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finspector.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -12,7 +12,7 @@ const {\n const util = require('util');\n const { Connection, open, url } = process.binding('inspector');\n \n-if (!Connection)\n+if (!Connection || !require('internal/worker').isMainThread)\n   throw new ERR_INSPECTOR_NOT_AVAILABLE();\n \n const connectionSymbol = Symbol('connectionProperty');"
        },
        {
            "sha": "4817ec110a99e52d8da0168149d3ea3aa8608307",
            "filename": "lib/internal/bootstrap/node.js",
            "status": "modified",
            "additions": 10,
            "deletions": 5,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Fnode.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -24,6 +24,7 @@\n                                 _shouldAbortOnUncaughtToggle },\n                               { internalBinding, NativeModule }) {\n   const exceptionHandlerState = { captureFn: null };\n+  const isMainThread = internalBinding('worker').threadId === 0;\n \n   function startup() {\n     const EventEmitter = NativeModule.require('events');\n@@ -100,7 +101,9 @@\n       NativeModule.require('internal/inspector_async_hook').setup();\n     }\n \n-    _process.setupChannel();\n+    if (isMainThread)\n+      _process.setupChannel();\n+\n     _process.setupRawDebug(_rawDebug);\n \n     const browserGlobals = !process._noBrowserGlobals;\n@@ -175,8 +178,11 @@\n     // are running from a script and running the REPL - but there are a few\n     // others like the debugger or running --eval arguments. Here we decide\n     // which mode we run in.\n-\n-    if (NativeModule.exists('_third_party_main')) {\n+    if (internalBinding('worker').getEnvMessagePort() !== undefined) {\n+      // This means we are in a Worker context, and any script execution\n+      // will be directed by the worker module.\n+      NativeModule.require('internal/worker').setupChild(evalScript);\n+    } else if (NativeModule.exists('_third_party_main')) {\n       // To allow people to extend Node in different ways, this hook allows\n       // one to drop a file lib/_third_party_main.js into the build\n       // directory which will be executed instead of Node's normal loading.\n@@ -542,15 +548,14 @@\n     return `process.binding('inspector').callAndPauseOnStart(${fn}, {})`;\n   }\n \n-  function evalScript(name) {\n+  function evalScript(name, body = wrapForBreakOnFirstLine(process._eval)) {\n     const CJSModule = NativeModule.require('internal/modules/cjs/loader');\n     const path = NativeModule.require('path');\n     const cwd = tryGetCwd(path);\n \n     const module = new CJSModule(name);\n     module.filename = path.join(cwd, name);\n     module.paths = CJSModule._nodeModulePaths(cwd);\n-    const body = wrapForBreakOnFirstLine(process._eval);\n     const script = `global.__filename = ${JSON.stringify(name)};\\n` +\n                    'global.exports = exports;\\n' +\n                    'global.module = module;\\n' +"
        },
        {
            "sha": "d59531debbd0428104ca73344a2c1038d8c307bf",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -844,4 +844,9 @@ E('ERR_VM_MODULE_NOT_LINKED',\n E('ERR_VM_MODULE_NOT_MODULE',\n   'Provided module is not an instance of Module', Error);\n E('ERR_VM_MODULE_STATUS', 'Module status %s', Error);\n+E('ERR_WORKER_NEED_ABSOLUTE_PATH',\n+  'The worker script filename must be an absolute path. Received \"%s\"',\n+  TypeError);\n+E('ERR_WORKER_UNSERIALIZABLE_ERROR',\n+  'Serializing an uncaught exception failed', Error);\n E('ERR_ZLIB_INITIALIZATION_FAILED', 'Initialization failed', Error);"
        },
        {
            "sha": "f01be32be4b6a383623a0e01a483527eb93d4453",
            "filename": "lib/internal/process.js",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fprocess.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fprocess.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -16,6 +16,7 @@ const util = require('util');\n const constants = process.binding('constants').os.signals;\n const assert = require('assert').strict;\n const { deprecate } = require('internal/util');\n+const { isMainThread } = require('internal/worker');\n \n process.assert = deprecate(\n   function(x, msg) {\n@@ -186,6 +187,11 @@ function setupKillAndExit() {\n \n \n function setupSignalHandlers() {\n+  if (!isMainThread) {\n+    // Worker threads don't receive signals.\n+    return;\n+  }\n+\n   const signalWraps = Object.create(null);\n   let Signal;\n "
        },
        {
            "sha": "9a954f6a9b93cf8ee926f4a650ce22fb0b4c2cea",
            "filename": "lib/internal/process/methods.js",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fprocess%2Fmethods.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fprocess%2Fmethods.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fmethods.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -8,11 +8,18 @@ const {\n   validateMode,\n   validateUint32\n } = require('internal/validators');\n+const {\n+  isMainThread\n+} = require('internal/worker');\n \n function setupProcessMethods(_chdir, _cpuUsage, _hrtime, _memoryUsage,\n                              _rawDebug, _umask, _initgroups, _setegid,\n                              _seteuid, _setgid, _setuid, _setgroups) {\n   // Non-POSIX platforms like Windows don't have certain methods.\n+  // Workers also lack these methods since they change process-global state.\n+  if (!isMainThread)\n+    return;\n+\n   if (_setgid !== undefined) {\n     setupPosixMethods(_initgroups, _setegid, _seteuid,\n                       _setgid, _setuid, _setgroups);"
        },
        {
            "sha": "76e6ab85140535d775c530392c2263ce678d59c4",
            "filename": "lib/internal/process/stdio.js",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fprocess%2Fstdio.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fprocess%2Fstdio.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fstdio.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -6,6 +6,7 @@ const {\n   ERR_UNKNOWN_STDIN_TYPE,\n   ERR_UNKNOWN_STREAM_TYPE\n } = require('internal/errors').codes;\n+const { isMainThread } = require('internal/worker');\n \n exports.setup = setupStdio;\n \n@@ -16,6 +17,8 @@ function setupStdio() {\n \n   function getStdout() {\n     if (stdout) return stdout;\n+    if (!isMainThread)\n+      return new (require('stream').Writable)({ write(b, e, cb) { cb(); } });\n     stdout = createWritableStdioStream(1);\n     stdout.destroySoon = stdout.destroy;\n     stdout._destroy = function(er, cb) {\n@@ -31,6 +34,8 @@ function setupStdio() {\n \n   function getStderr() {\n     if (stderr) return stderr;\n+    if (!isMainThread)\n+      return new (require('stream').Writable)({ write(b, e, cb) { cb(); } });\n     stderr = createWritableStdioStream(2);\n     stderr.destroySoon = stderr.destroy;\n     stderr._destroy = function(er, cb) {\n@@ -46,6 +51,8 @@ function setupStdio() {\n \n   function getStdin() {\n     if (stdin) return stdin;\n+    if (!isMainThread)\n+      return new (require('stream').Readable)({ read() { this.push(null); } });\n \n     const tty_wrap = process.binding('tty_wrap');\n     const fd = 0;"
        },
        {
            "sha": "3dd73415ded862687f308c5c97bb9991fc13f5ff",
            "filename": "lib/internal/util/inspector.js",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Futil%2Finspector.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Futil%2Finspector.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil%2Finspector.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -1,6 +1,8 @@\n 'use strict';\n \n-const hasInspector = process.config.variables.v8_enable_inspector === 1;\n+// TODO(addaleax): Figure out how to integrate the inspector with workers.\n+const hasInspector = process.config.variables.v8_enable_inspector === 1 &&\n+  require('internal/worker').isMainThread;\n const inspector = hasInspector ? require('inspector') : undefined;\n \n let session;"
        },
        {
            "sha": "c982478b9334e86c321dee956283a490b444aeef",
            "filename": "lib/internal/worker.js",
            "status": "modified",
            "additions": 218,
            "deletions": 3,
            "changes": 221,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fworker.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/lib%2Finternal%2Fworker.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fworker.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -1,24 +1,49 @@\n 'use strict';\n \n+const Buffer = require('buffer').Buffer;\n const EventEmitter = require('events');\n+const assert = require('assert');\n+const path = require('path');\n const util = require('util');\n+const {\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_WORKER_NEED_ABSOLUTE_PATH,\n+  ERR_WORKER_UNSERIALIZABLE_ERROR\n+} = require('internal/errors').codes;\n \n const { internalBinding } = require('internal/bootstrap/loaders');\n const { MessagePort, MessageChannel } = internalBinding('messaging');\n const { handle_onclose } = internalBinding('symbols');\n+const { clearAsyncIdStack } = require('internal/async_hooks');\n \n util.inherits(MessagePort, EventEmitter);\n \n+const {\n+  Worker: WorkerImpl,\n+  getEnvMessagePort,\n+  threadId\n+} = internalBinding('worker');\n+\n+const isMainThread = threadId === 0;\n+\n const kOnMessageListener = Symbol('kOnMessageListener');\n+const kHandle = Symbol('kHandle');\n+const kPort = Symbol('kPort');\n+const kPublicPort = Symbol('kPublicPort');\n+const kDispose = Symbol('kDispose');\n+const kOnExit = Symbol('kOnExit');\n+const kOnMessage = Symbol('kOnMessage');\n+const kOnCouldNotSerializeErr = Symbol('kOnCouldNotSerializeErr');\n+const kOnErrorMessage = Symbol('kOnErrorMessage');\n \n const debug = util.debuglog('worker');\n \n-// A MessagePort consists of a handle (that wraps around an\n+// A communication channel consisting of a handle (that wraps around an\n // uv_async_t) which can receive information from other threads and emits\n // .onmessage events, and a function used for sending data to a MessagePort\n // in some other thread.\n MessagePort.prototype[kOnMessageListener] = function onmessage(payload) {\n-  debug('received message', payload);\n+  debug(`[${threadId}] received message`, payload);\n   // Emit the deserialized object to userland.\n   this.emit('message', payload);\n };\n@@ -79,6 +104,9 @@ MessagePort.prototype.close = function(cb) {\n   originalClose.call(this);\n };\n \n+const drainMessagePort = MessagePort.prototype.drain;\n+delete MessagePort.prototype.drain;\n+\n function setupPortReferencing(port, eventEmitter, eventName) {\n   // Keep track of whether there are any workerMessage listeners:\n   // If there are some, ref() the channel so it keeps the event loop alive.\n@@ -99,7 +127,194 @@ function setupPortReferencing(port, eventEmitter, eventName) {\n   });\n }\n \n+\n+class Worker extends EventEmitter {\n+  constructor(filename, options = {}) {\n+    super();\n+    debug(`[${threadId}] create new worker`, filename, options);\n+    if (typeof filename !== 'string') {\n+      throw new ERR_INVALID_ARG_TYPE('filename', 'string', filename);\n+    }\n+\n+    if (!options.eval && !path.isAbsolute(filename)) {\n+      throw new ERR_WORKER_NEED_ABSOLUTE_PATH(filename);\n+    }\n+\n+    // Set up the C++ handle for the worker, as well as some internal wiring.\n+    this[kHandle] = new WorkerImpl();\n+    this[kHandle].onexit = (code) => this[kOnExit](code);\n+    this[kPort] = this[kHandle].messagePort;\n+    this[kPort].on('message', (data) => this[kOnMessage](data));\n+    this[kPort].start();\n+    this[kPort].unref();\n+    debug(`[${threadId}] created Worker with ID ${this.threadId}`);\n+\n+    const { port1, port2 } = new MessageChannel();\n+    this[kPublicPort] = port1;\n+    this[kPublicPort].on('message', (message) => this.emit('message', message));\n+    setupPortReferencing(this[kPublicPort], this, 'message');\n+    this[kPort].postMessage({\n+      type: 'loadScript',\n+      filename,\n+      doEval: !!options.eval,\n+      workerData: options.workerData,\n+      publicPort: port2\n+    }, [port2]);\n+    // Actually start the new thread now that everything is in place.\n+    this[kHandle].startThread();\n+  }\n+\n+  [kOnExit](code) {\n+    debug(`[${threadId}] hears end event for Worker ${this.threadId}`);\n+    drainMessagePort.call(this[kPublicPort]);\n+    this[kDispose]();\n+    this.emit('exit', code);\n+    this.removeAllListeners();\n+  }\n+\n+  [kOnCouldNotSerializeErr]() {\n+    this.emit('error', new ERR_WORKER_UNSERIALIZABLE_ERROR());\n+  }\n+\n+  [kOnErrorMessage](serialized) {\n+    // This is what is called for uncaught exceptions.\n+    const error = deserializeError(serialized);\n+    this.emit('error', error);\n+  }\n+\n+  [kOnMessage](message) {\n+    switch (message.type) {\n+      case 'upAndRunning':\n+        return this.emit('online');\n+      case 'couldNotSerializeError':\n+        return this[kOnCouldNotSerializeErr]();\n+      case 'errorMessage':\n+        return this[kOnErrorMessage](message.error);\n+    }\n+\n+    assert.fail(`Unknown worker message type ${message.type}`);\n+  }\n+\n+  [kDispose]() {\n+    this[kHandle].onexit = null;\n+    this[kHandle] = null;\n+    this[kPort] = null;\n+    this[kPublicPort] = null;\n+  }\n+\n+  postMessage(...args) {\n+    this[kPublicPort].postMessage(...args);\n+  }\n+\n+  terminate(callback) {\n+    if (this[kHandle] === null) return;\n+\n+    debug(`[${threadId}] terminates Worker with ID ${this.threadId}`);\n+\n+    if (typeof callback !== 'undefined')\n+      this.once('exit', (exitCode) => callback(null, exitCode));\n+\n+    this[kHandle].stopThread();\n+  }\n+\n+  ref() {\n+    if (this[kHandle] === null) return;\n+\n+    this[kHandle].ref();\n+    this[kPublicPort].ref();\n+  }\n+\n+  unref() {\n+    if (this[kHandle] === null) return;\n+\n+    this[kHandle].unref();\n+    this[kPublicPort].unref();\n+  }\n+\n+  get threadId() {\n+    if (this[kHandle] === null) return -1;\n+\n+    return this[kHandle].threadId;\n+  }\n+}\n+\n+let originalFatalException;\n+\n+function setupChild(evalScript) {\n+  // Called during bootstrap to set up worker script execution.\n+  debug(`[${threadId}] is setting up worker child environment`);\n+  const port = getEnvMessagePort();\n+\n+  const publicWorker = require('worker');\n+\n+  port.on('message', (message) => {\n+    if (message.type === 'loadScript') {\n+      const { filename, doEval, workerData, publicPort } = message;\n+      publicWorker.parentPort = publicPort;\n+      setupPortReferencing(publicPort, publicPort, 'message');\n+      publicWorker.workerData = workerData;\n+      debug(`[${threadId}] starts worker script ${filename} ` +\n+            `(eval = ${eval}) at cwd = ${process.cwd()}`);\n+      port.unref();\n+      port.postMessage({ type: 'upAndRunning' });\n+      if (doEval) {\n+        evalScript('[worker eval]', filename);\n+      } else {\n+        process.argv[1] = filename; // script filename\n+        require('module').runMain();\n+      }\n+      return;\n+    }\n+\n+    assert.fail(`Unknown worker message type ${message.type}`);\n+  });\n+\n+  port.start();\n+\n+  originalFatalException = process._fatalException;\n+  process._fatalException = fatalException;\n+\n+  function fatalException(error) {\n+    debug(`[${threadId}] gets fatal exception`);\n+    let caught = false;\n+    try {\n+      caught = originalFatalException.call(this, error);\n+    } catch (e) {\n+      error = e;\n+    }\n+    debug(`[${threadId}] fatal exception caught = ${caught}`);\n+\n+    if (!caught) {\n+      let serialized;\n+      try {\n+        serialized = serializeError(error);\n+      } catch {}\n+      debug(`[${threadId}] fatal exception serialized = ${!!serialized}`);\n+      if (serialized)\n+        port.postMessage({ type: 'errorMessage', error: serialized });\n+      else\n+        port.postMessage({ type: 'couldNotSerializeError' });\n+      clearAsyncIdStack();\n+    }\n+  }\n+}\n+\n+// TODO(addaleax): These can be improved a lot.\n+function serializeError(error) {\n+  return Buffer.from(util.inspect(error), 'utf8');\n+}\n+\n+function deserializeError(error) {\n+  return Buffer.from(error.buffer,\n+                     error.byteOffset,\n+                     error.byteLength).toString('utf8');\n+}\n+\n module.exports = {\n   MessagePort,\n-  MessageChannel\n+  MessageChannel,\n+  threadId,\n+  Worker,\n+  setupChild,\n+  isMainThread\n };"
        },
        {
            "sha": "0609650cd5731d5767117288e3c28b2956c78164",
            "filename": "lib/worker.js",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/lib%2Fworker.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/lib%2Fworker.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fworker.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -1,5 +1,18 @@\n 'use strict';\n \n-const { MessagePort, MessageChannel } = require('internal/worker');\n+const {\n+  isMainThread,\n+  MessagePort,\n+  MessageChannel,\n+  threadId,\n+  Worker\n+} = require('internal/worker');\n \n-module.exports = { MessagePort, MessageChannel };\n+module.exports = {\n+  isMainThread,\n+  MessagePort,\n+  MessageChannel,\n+  threadId,\n+  Worker,\n+  parentPort: null\n+};"
        },
        {
            "sha": "e9a2cb46a851dab247f9aa6dcc9414ecd3ba14ef",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -349,6 +349,7 @@\n         'src/node_v8.cc',\n         'src/node_stat_watcher.cc',\n         'src/node_watchdog.cc',\n+        'src/node_worker.cc',\n         'src/node_zlib.cc',\n         'src/node_i18n.cc',\n         'src/pipe_wrap.cc',\n@@ -407,6 +408,7 @@\n         'src/node_wrap.h',\n         'src/node_revert.h',\n         'src/node_i18n.h',\n+        'src/node_worker.h',\n         'src/pipe_wrap.h',\n         'src/tty_wrap.h',\n         'src/tcp_wrap.h',"
        },
        {
            "sha": "b2f96477b490e046b57927f7c918a92ed3b5f265",
            "filename": "src/async_wrap.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fasync_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fasync_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.h?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -67,6 +67,7 @@ namespace node {\n   V(TTYWRAP)                                                                  \\\n   V(UDPSENDWRAP)                                                              \\\n   V(UDPWRAP)                                                                  \\\n+  V(WORKER)                                                                   \\\n   V(WRITEWRAP)                                                                \\\n   V(ZLIB)\n "
        },
        {
            "sha": "06a29223973c5dfccdf4e7b172eeec05fe5fe7d7",
            "filename": "src/base_object-inl.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fbase_object-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fbase_object-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fbase_object-inl.h?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -65,6 +65,14 @@ v8::Local<v8::Object> BaseObject::object() {\n   return PersistentToLocal(env_->isolate(), persistent_handle_);\n }\n \n+v8::Local<v8::Object> BaseObject::object(v8::Isolate* isolate) {\n+  v8::Local<v8::Object> handle = object();\n+#ifdef DEBUG\n+  CHECK_EQ(handle->CreationContext()->GetIsolate(), isolate);\n+  CHECK_EQ(env_->isolate(), isolate);\n+#endif\n+  return handle;\n+}\n \n Environment* BaseObject::env() const {\n   return env_;"
        },
        {
            "sha": "38291d598feb1cf5ba9fbb4652311ef49eb35760",
            "filename": "src/base_object.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fbase_object.h",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fbase_object.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fbase_object.h?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -43,6 +43,10 @@ class BaseObject {\n   // persistent.IsEmpty() is true.\n   inline v8::Local<v8::Object> object();\n \n+  // Same as the above, except it additionally verifies that this object\n+  // is associated with the passed Isolate in debug mode.\n+  inline v8::Local<v8::Object> object(v8::Isolate* isolate);\n+\n   inline Persistent<v8::Object>& persistent();\n \n   inline Environment* env() const;"
        },
        {
            "sha": "f9db02562d9c8a5abb31281d0d2402f58f1b0c7a",
            "filename": "src/bootstrapper.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fbootstrapper.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fbootstrapper.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fbootstrapper.cc?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -114,12 +114,14 @@ void SetupBootstrapObject(Environment* env,\n   BOOTSTRAP_METHOD(_umask, Umask);\n \n #if defined(__POSIX__) && !defined(__ANDROID__) && !defined(__CloudABI__)\n-  BOOTSTRAP_METHOD(_initgroups, InitGroups);\n-  BOOTSTRAP_METHOD(_setegid, SetEGid);\n-  BOOTSTRAP_METHOD(_seteuid, SetEUid);\n-  BOOTSTRAP_METHOD(_setgid, SetGid);\n-  BOOTSTRAP_METHOD(_setuid, SetUid);\n-  BOOTSTRAP_METHOD(_setgroups, SetGroups);\n+  if (env->is_main_thread()) {\n+    BOOTSTRAP_METHOD(_initgroups, InitGroups);\n+    BOOTSTRAP_METHOD(_setegid, SetEGid);\n+    BOOTSTRAP_METHOD(_seteuid, SetEUid);\n+    BOOTSTRAP_METHOD(_setgid, SetGid);\n+    BOOTSTRAP_METHOD(_setuid, SetUid);\n+    BOOTSTRAP_METHOD(_setgroups, SetGroups);\n+  }\n #endif  // __POSIX__ && !defined(__ANDROID__) && !defined(__CloudABI__)\n \n   Local<String> should_abort_on_uncaught_toggle ="
        },
        {
            "sha": "23e6d5b0632f2c58c29ca561f00c9287fa6e4d6e",
            "filename": "src/callback_scope.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fcallback_scope.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fcallback_scope.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fcallback_scope.cc?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -79,6 +79,11 @@ void InternalCallbackScope::Close() {\n   closed_ = true;\n   HandleScope handle_scope(env_->isolate());\n \n+  if (!env_->can_call_into_js()) return;\n+  if (failed_ && !env_->is_main_thread() && env_->is_stopping_worker()) {\n+    env_->async_hooks()->clear_async_id_stack();\n+  }\n+\n   if (pushed_ids_)\n     env_->async_hooks()->pop_async_id(async_context_.async_id);\n "
        },
        {
            "sha": "eeb419b4a0fad206913adec2ac289a7c6ebb300c",
            "filename": "src/env-inl.h",
            "status": "modified",
            "additions": 30,
            "deletions": 1,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fenv-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fenv-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv-inl.h?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -582,13 +582,42 @@ void Environment::SetUnrefImmediate(native_immediate_callback cb,\n }\n \n inline bool Environment::can_call_into_js() const {\n-  return can_call_into_js_;\n+  return can_call_into_js_ && (is_main_thread() || !is_stopping_worker());\n }\n \n inline void Environment::set_can_call_into_js(bool can_call_into_js) {\n   can_call_into_js_ = can_call_into_js;\n }\n \n+inline bool Environment::is_main_thread() const {\n+  return thread_id_ == 0;\n+}\n+\n+inline double Environment::thread_id() const {\n+  return thread_id_;\n+}\n+\n+inline void Environment::set_thread_id(double id) {\n+  thread_id_ = id;\n+}\n+\n+inline worker::Worker* Environment::worker_context() const {\n+  return worker_context_;\n+}\n+\n+inline void Environment::set_worker_context(worker::Worker* context) {\n+  CHECK_EQ(worker_context_, nullptr);  // Should be set only once.\n+  worker_context_ = context;\n+}\n+\n+inline void Environment::add_sub_worker_context(worker::Worker* context) {\n+  sub_worker_contexts_.insert(context);\n+}\n+\n+inline void Environment::remove_sub_worker_context(worker::Worker* context) {\n+  sub_worker_contexts_.erase(context);\n+}\n+\n inline performance::performance_state* Environment::performance_state() {\n   return performance_state_.get();\n }"
        },
        {
            "sha": "8df59d1546dbddf4e1eeb26e2c770747ed473415",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 26,
            "deletions": 1,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -4,6 +4,7 @@\n #include \"node_buffer.h\"\n #include \"node_platform.h\"\n #include \"node_file.h\"\n+#include \"node_worker.h\"\n #include \"tracing/agent.h\"\n \n #include <stdio.h>\n@@ -25,6 +26,7 @@ using v8::StackTrace;\n using v8::String;\n using v8::Symbol;\n using v8::Value;\n+using worker::Worker;\n \n IsolateData::IsolateData(Isolate* isolate,\n                          uv_loop_t* event_loop,\n@@ -444,7 +446,9 @@ void Environment::RunAndClearNativeImmediates() {\n         if (it->refed_)\n           ref_count++;\n         if (UNLIKELY(try_catch.HasCaught())) {\n-          FatalException(isolate(), try_catch);\n+          if (!try_catch.HasTerminated())\n+            FatalException(isolate(), try_catch);\n+\n           // Bail out, remove the already executed callbacks from list\n           // and set up a new TryCatch for the other pending callbacks.\n           std::move_backward(it, list.end(), list.begin() + (list.end() - it));\n@@ -632,4 +636,25 @@ void Environment::AsyncHooks::grow_async_ids_stack() {\n \n uv_key_t Environment::thread_local_env = {};\n \n+void Environment::Exit(int exit_code) {\n+  if (is_main_thread())\n+    exit(exit_code);\n+  else\n+    worker_context_->Exit(exit_code);\n+}\n+\n+void Environment::stop_sub_worker_contexts() {\n+  while (!sub_worker_contexts_.empty()) {\n+    Worker* w = *sub_worker_contexts_.begin();\n+    remove_sub_worker_context(w);\n+    w->Exit(1);\n+    w->JoinThread();\n+  }\n+}\n+\n+bool Environment::is_stopping_worker() const {\n+  CHECK(!is_main_thread());\n+  return worker_context_->is_stopped();\n+}\n+\n }  // namespace node"
        },
        {
            "sha": "cf6873e5fe7c6ad5e91942e52f027f00c141184b",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 28,
            "deletions": 1,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -55,6 +55,10 @@ namespace performance {\n class performance_state;\n }\n \n+namespace worker {\n+class Worker;\n+}\n+\n namespace loader {\n class ModuleWrap;\n \n@@ -193,7 +197,10 @@ struct PackageConfig {\n   V(mac_string, \"mac\")                                                        \\\n   V(main_string, \"main\")                                                      \\\n   V(max_buffer_string, \"maxBuffer\")                                           \\\n+  V(max_semi_space_size_string, \"maxSemiSpaceSize\")                           \\\n+  V(max_old_space_size_string, \"maxOldSpaceSize\")                             \\\n   V(message_string, \"message\")                                                \\\n+  V(message_port_string, \"messagePort\")                                       \\\n   V(message_port_constructor_string, \"MessagePort\")                           \\\n   V(minttl_string, \"minttl\")                                                  \\\n   V(modulus_string, \"modulus\")                                                \\\n@@ -280,6 +287,7 @@ struct PackageConfig {\n   V(subject_string, \"subject\")                                                \\\n   V(subjectaltname_string, \"subjectaltname\")                                  \\\n   V(syscall_string, \"syscall\")                                                \\\n+  V(thread_id_string, \"threadId\")                                             \\\n   V(ticketkeycallback_string, \"onticketkeycallback\")                          \\\n   V(timeout_string, \"timeout\")                                                \\\n   V(tls_ticket_string, \"tlsTicket\")                                           \\\n@@ -328,6 +336,7 @@ struct PackageConfig {\n   V(http2stream_constructor_template, v8::ObjectTemplate)                     \\\n   V(immediate_callback_function, v8::Function)                                \\\n   V(inspector_console_api_object, v8::Object)                                 \\\n+  V(message_port, v8::Object)                                                 \\\n   V(message_port_constructor_template, v8::FunctionTemplate)                  \\\n   V(pbkdf2_constructor_template, v8::ObjectTemplate)                          \\\n   V(pipe_constructor_template, v8::FunctionTemplate)                          \\\n@@ -601,6 +610,7 @@ class Environment {\n \n   void RegisterHandleCleanups();\n   void CleanupHandles();\n+  void Exit(int code);\n \n   // Register clean-up cb to be called on environment destruction.\n   inline void RegisterHandleCleanup(uv_handle_t* handle,\n@@ -714,6 +724,18 @@ class Environment {\n   inline bool can_call_into_js() const;\n   inline void set_can_call_into_js(bool can_call_into_js);\n \n+  // TODO(addaleax): This should be inline.\n+  bool is_stopping_worker() const;\n+\n+  inline bool is_main_thread() const;\n+  inline double thread_id() const;\n+  inline void set_thread_id(double id);\n+  inline worker::Worker* worker_context() const;\n+  inline void set_worker_context(worker::Worker* context);\n+  inline void add_sub_worker_context(worker::Worker* context);\n+  inline void remove_sub_worker_context(worker::Worker* context);\n+  void stop_sub_worker_contexts();\n+\n   inline void ThrowError(const char* errmsg);\n   inline void ThrowTypeError(const char* errmsg);\n   inline void ThrowRangeError(const char* errmsg);\n@@ -855,12 +877,15 @@ class Environment {\n   std::vector<double> destroy_async_id_list_;\n \n   AliasedBuffer<uint32_t, v8::Uint32Array> should_abort_on_uncaught_toggle_;\n-\n   int should_not_abort_scope_counter_ = 0;\n \n   std::unique_ptr<performance::performance_state> performance_state_;\n   std::unordered_map<std::string, uint64_t> performance_marks_;\n+\n   bool can_call_into_js_ = true;\n+  double thread_id_ = 0;\n+  std::unordered_set<worker::Worker*> sub_worker_contexts_;\n+\n \n #if HAVE_INSPECTOR\n   std::unique_ptr<inspector::Agent> inspector_agent_;\n@@ -893,6 +918,8 @@ class Environment {\n   std::vector<std::unique_ptr<fs::FileHandleReadWrap>>\n       file_handle_read_wrap_freelist_;\n \n+  worker::Worker* worker_context_ = nullptr;\n+\n   struct ExitCallback {\n     void (*cb_)(void* arg);\n     void* arg_;"
        },
        {
            "sha": "e562a62f3d1bb274f1c51a4c0b0217623c6d72e0",
            "filename": "src/js_stream.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 5,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fjs_stream.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fjs_stream.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_stream.cc?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -44,7 +44,8 @@ bool JSStream::IsClosing() {\n   TryCatch try_catch(env()->isolate());\n   Local<Value> value;\n   if (!MakeCallback(env()->isclosing_string(), 0, nullptr).ToLocal(&value)) {\n-    FatalException(env()->isolate(), try_catch);\n+    if (!try_catch.HasTerminated())\n+      FatalException(env()->isolate(), try_catch);\n     return true;\n   }\n   return value->IsTrue();\n@@ -59,7 +60,8 @@ int JSStream::ReadStart() {\n   int value_int = UV_EPROTO;\n   if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||\n       !value->Int32Value(env()->context()).To(&value_int)) {\n-    FatalException(env()->isolate(), try_catch);\n+    if (!try_catch.HasTerminated())\n+      FatalException(env()->isolate(), try_catch);\n   }\n   return value_int;\n }\n@@ -73,7 +75,8 @@ int JSStream::ReadStop() {\n   int value_int = UV_EPROTO;\n   if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||\n       !value->Int32Value(env()->context()).To(&value_int)) {\n-    FatalException(env()->isolate(), try_catch);\n+    if (!try_catch.HasTerminated())\n+      FatalException(env()->isolate(), try_catch);\n   }\n   return value_int;\n }\n@@ -94,7 +97,8 @@ int JSStream::DoShutdown(ShutdownWrap* req_wrap) {\n                     arraysize(argv),\n                     argv).ToLocal(&value) ||\n       !value->Int32Value(env()->context()).To(&value_int)) {\n-    FatalException(env()->isolate(), try_catch);\n+    if (!try_catch.HasTerminated())\n+      FatalException(env()->isolate(), try_catch);\n   }\n   return value_int;\n }\n@@ -128,7 +132,8 @@ int JSStream::DoWrite(WriteWrap* w,\n                     arraysize(argv),\n                     argv).ToLocal(&value) ||\n       !value->Int32Value(env()->context()).To(&value_int)) {\n-    FatalException(env()->isolate(), try_catch);\n+    if (!try_catch.HasTerminated())\n+      FatalException(env()->isolate(), try_catch);\n   }\n   return value_int;\n }"
        },
        {
            "sha": "663e4a222eba91a3099c30a3a181eea81dd1ab85",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 75,
            "deletions": 41,
            "changes": 116,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -1021,9 +1021,9 @@ void AppendExceptionLine(Environment* env,\n }\n \n \n-static void ReportException(Environment* env,\n-                            Local<Value> er,\n-                            Local<Message> message) {\n+void ReportException(Environment* env,\n+                     Local<Value> er,\n+                     Local<Message> message) {\n   CHECK(!er.IsEmpty());\n   HandleScope scope(env->isolate());\n \n@@ -1110,9 +1110,9 @@ static void ReportException(Environment* env, const TryCatch& try_catch) {\n \n \n // Executes a str within the current v8 context.\n-static Local<Value> ExecuteString(Environment* env,\n-                                  Local<String> source,\n-                                  Local<String> filename) {\n+static MaybeLocal<Value> ExecuteString(Environment* env,\n+                                       Local<String> source,\n+                                       Local<String> filename) {\n   EscapableHandleScope scope(env->isolate());\n   TryCatch try_catch(env->isolate());\n \n@@ -1125,13 +1125,19 @@ static Local<Value> ExecuteString(Environment* env,\n       v8::Script::Compile(env->context(), source, &origin);\n   if (script.IsEmpty()) {\n     ReportException(env, try_catch);\n-    exit(3);\n+    env->Exit(3);\n+    return MaybeLocal<Value>();\n   }\n \n   MaybeLocal<Value> result = script.ToLocalChecked()->Run(env->context());\n   if (result.IsEmpty()) {\n+    if (try_catch.HasTerminated()) {\n+      env->isolate()->CancelTerminateExecution();\n+      return MaybeLocal<Value>();\n+    }\n     ReportException(env, try_catch);\n-    exit(4);\n+    env->Exit(4);\n+    return MaybeLocal<Value>();\n   }\n \n   return scope.Escape(result.ToLocalChecked());\n@@ -1230,6 +1236,7 @@ static void Abort(const FunctionCallbackInfo<Value>& args) {\n \n void Chdir(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n \n   CHECK_EQ(args.Length(), 1);\n   CHECK(args[0]->IsString());\n@@ -1411,6 +1418,7 @@ static void GetEGid(const FunctionCallbackInfo<Value>& args) {\n \n void SetGid(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n \n   CHECK_EQ(args.Length(), 1);\n   CHECK(args[0]->IsUint32() || args[0]->IsString());\n@@ -1430,6 +1438,7 @@ void SetGid(const FunctionCallbackInfo<Value>& args) {\n \n void SetEGid(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n \n   CHECK_EQ(args.Length(), 1);\n   CHECK(args[0]->IsUint32() || args[0]->IsString());\n@@ -1449,6 +1458,7 @@ void SetEGid(const FunctionCallbackInfo<Value>& args) {\n \n void SetUid(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n \n   CHECK_EQ(args.Length(), 1);\n   CHECK(args[0]->IsUint32() || args[0]->IsString());\n@@ -1468,6 +1478,7 @@ void SetUid(const FunctionCallbackInfo<Value>& args) {\n \n void SetEUid(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n \n   CHECK_EQ(args.Length(), 1);\n   CHECK(args[0]->IsUint32() || args[0]->IsString());\n@@ -1629,9 +1640,10 @@ static void WaitForInspectorDisconnect(Environment* env) {\n \n \n static void Exit(const FunctionCallbackInfo<Value>& args) {\n-  WaitForInspectorDisconnect(Environment::GetCurrent(args));\n+  Environment* env = Environment::GetCurrent(args);\n+  WaitForInspectorDisconnect(env);\n   v8_platform.StopTracingAgent();\n-  exit(args[0]->Int32Value());\n+  env->Exit(args[0]->Int32Value());\n }\n \n \n@@ -2040,6 +2052,9 @@ void FatalException(Isolate* isolate,\n     Local<Value> caught =\n         fatal_exception_function->Call(process_object, 1, &error);\n \n+    if (fatal_try_catch.HasTerminated())\n+      return;\n+\n     if (fatal_try_catch.HasCaught()) {\n       // The fatal exception function threw, so we must exit\n       ReportException(env, fatal_try_catch);\n@@ -2053,6 +2068,12 @@ void FatalException(Isolate* isolate,\n \n \n void FatalException(Isolate* isolate, const TryCatch& try_catch) {\n+  // If we try to print out a termination exception, we'd just get 'null',\n+  // so just crashing here with that information seems like a better idea,\n+  // and in particular it seems like we should handle terminations at the call\n+  // site for this function rather than by printing them out somewhere.\n+  CHECK(!try_catch.HasTerminated());\n+\n   HandleScope scope(isolate);\n   if (!try_catch.IsVerbose()) {\n     FatalException(isolate, try_catch.Exception(), try_catch.Message());\n@@ -2574,11 +2595,12 @@ void SetupProcessObject(Environment* env,\n   Local<Object> process = env->process_object();\n \n   auto title_string = FIXED_ONE_BYTE_STRING(env->isolate(), \"title\");\n-  CHECK(process->SetAccessor(env->context(),\n-                             title_string,\n-                             ProcessTitleGetter,\n-                             ProcessTitleSetter,\n-                             env->as_external()).FromJust());\n+  CHECK(process->SetAccessor(\n+      env->context(),\n+      title_string,\n+      ProcessTitleGetter,\n+      env->is_main_thread() ? ProcessTitleSetter : nullptr,\n+      env->as_external()).FromJust());\n \n   // process.version\n   READONLY_PROPERTY(process,\n@@ -2862,25 +2884,27 @@ void SetupProcessObject(Environment* env,\n   CHECK(process->SetAccessor(env->context(),\n                              debug_port_string,\n                              DebugPortGetter,\n-                             DebugPortSetter,\n+                             env->is_main_thread() ? DebugPortSetter : nullptr,\n                              env->as_external()).FromJust());\n \n   // define various internal methods\n-  env->SetMethod(process,\n-                 \"_startProfilerIdleNotifier\",\n-                 StartProfilerIdleNotifier);\n-  env->SetMethod(process,\n-                 \"_stopProfilerIdleNotifier\",\n-                 StopProfilerIdleNotifier);\n+  if (env->is_main_thread()) {\n+    env->SetMethod(process,\n+                   \"_startProfilerIdleNotifier\",\n+                   StartProfilerIdleNotifier);\n+    env->SetMethod(process,\n+                   \"_stopProfilerIdleNotifier\",\n+                   StopProfilerIdleNotifier);\n+    env->SetMethod(process, \"abort\", Abort);\n+    env->SetMethod(process, \"chdir\", Chdir);\n+    env->SetMethod(process, \"umask\", Umask);\n+  }\n+\n   env->SetMethod(process, \"_getActiveRequests\", GetActiveRequests);\n   env->SetMethod(process, \"_getActiveHandles\", GetActiveHandles);\n   env->SetMethod(process, \"reallyExit\", Exit);\n-  env->SetMethod(process, \"abort\", Abort);\n-  env->SetMethod(process, \"chdir\", Chdir);\n   env->SetMethod(process, \"cwd\", Cwd);\n \n-  env->SetMethod(process, \"umask\", Umask);\n-\n #if defined(__POSIX__) && !defined(__ANDROID__) && !defined(__CloudABI__)\n   env->SetMethod(process, \"getuid\", GetUid);\n   env->SetMethod(process, \"geteuid\", GetEUid);\n@@ -2890,16 +2914,17 @@ void SetupProcessObject(Environment* env,\n #endif  // __POSIX__ && !defined(__ANDROID__) && !defined(__CloudABI__)\n \n   env->SetMethod(process, \"_kill\", Kill);\n+  env->SetMethod(process, \"dlopen\", DLOpen);\n \n-  env->SetMethod(process, \"_debugProcess\", DebugProcess);\n-  env->SetMethod(process, \"_debugEnd\", DebugEnd);\n+  if (env->is_main_thread()) {\n+    env->SetMethod(process, \"_debugProcess\", DebugProcess);\n+    env->SetMethod(process, \"_debugEnd\", DebugEnd);\n+  }\n \n   env->SetMethod(process, \"hrtime\", Hrtime);\n \n   env->SetMethod(process, \"cpuUsage\", CPUUsage);\n \n-  env->SetMethod(process, \"dlopen\", DLOpen);\n-\n   env->SetMethod(process, \"uptime\", Uptime);\n   env->SetMethod(process, \"memoryUsage\", MemoryUsage);\n }\n@@ -2935,8 +2960,10 @@ void RawDebug(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-static Local<Function> GetBootstrapper(Environment* env, Local<String> source,\n-                                  Local<String> script_name) {\n+static MaybeLocal<Function> GetBootstrapper(\n+    Environment* env,\n+    Local<String> source,\n+    Local<String> script_name) {\n   EscapableHandleScope scope(env->isolate());\n \n   TryCatch try_catch(env->isolate());\n@@ -2947,16 +2974,17 @@ static Local<Function> GetBootstrapper(Environment* env, Local<String> source,\n   try_catch.SetVerbose(false);\n \n   // Execute the bootstrapper javascript file\n-  Local<Value> bootstrapper_v = ExecuteString(env, source, script_name);\n+  MaybeLocal<Value> bootstrapper_v = ExecuteString(env, source, script_name);\n+  if (bootstrapper_v.IsEmpty())  // This happens when execution was interrupted.\n+    return MaybeLocal<Function>();\n+\n   if (try_catch.HasCaught())  {\n     ReportException(env, try_catch);\n     exit(10);\n   }\n \n-  CHECK(bootstrapper_v->IsFunction());\n-  Local<Function> bootstrapper = Local<Function>::Cast(bootstrapper_v);\n-\n-  return scope.Escape(bootstrapper);\n+  CHECK(bootstrapper_v.ToLocalChecked()->IsFunction());\n+  return scope.Escape(bootstrapper_v.ToLocalChecked().As<Function>());\n }\n \n static bool ExecuteBootstrapper(Environment* env, Local<Function> bootstrapper,\n@@ -2995,13 +3023,18 @@ void LoadEnvironment(Environment* env) {\n   // node_js2c.\n   Local<String> loaders_name =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"internal/bootstrap/loaders.js\");\n-  Local<Function> loaders_bootstrapper =\n+  MaybeLocal<Function> loaders_bootstrapper =\n       GetBootstrapper(env, LoadersBootstrapperSource(env), loaders_name);\n   Local<String> node_name =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"internal/bootstrap/node.js\");\n-  Local<Function> node_bootstrapper =\n+  MaybeLocal<Function> node_bootstrapper =\n       GetBootstrapper(env, NodeBootstrapperSource(env), node_name);\n \n+  if (loaders_bootstrapper.IsEmpty() || node_bootstrapper.IsEmpty()) {\n+    // Execution was interrupted.\n+    return;\n+  }\n+\n   // Add a reference to the global object\n   Local<Object> global = env->context()->Global();\n \n@@ -3049,7 +3082,7 @@ void LoadEnvironment(Environment* env) {\n \n   // Bootstrap internal loaders\n   Local<Value> bootstrapped_loaders;\n-  if (!ExecuteBootstrapper(env, loaders_bootstrapper,\n+  if (!ExecuteBootstrapper(env, loaders_bootstrapper.ToLocalChecked(),\n                            arraysize(loaders_bootstrapper_args),\n                            loaders_bootstrapper_args,\n                            &bootstrapped_loaders)) {\n@@ -3065,7 +3098,7 @@ void LoadEnvironment(Environment* env) {\n     bootstrapper,\n     bootstrapped_loaders\n   };\n-  if (!ExecuteBootstrapper(env, node_bootstrapper,\n+  if (!ExecuteBootstrapper(env, node_bootstrapper.ToLocalChecked(),\n                            arraysize(node_bootstrapper_args),\n                            node_bootstrapper_args,\n                            &bootstrapped_node)) {\n@@ -4279,6 +4312,7 @@ inline int Start(Isolate* isolate, IsolateData* isolate_data,\n   WaitForInspectorDisconnect(&env);\n \n   env.set_can_call_into_js(false);\n+  env.stop_sub_worker_contexts();\n   env.RunCleanup();\n   RunAtExit(&env);\n "
        },
        {
            "sha": "2c97088cc553b4c9985cf0a4253b13cbef4018c6",
            "filename": "src/node_errors.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_errors.h",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_errors.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_errors.h?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -34,6 +34,7 @@ namespace node {\n   V(ERR_MISSING_ARGS, TypeError)                                             \\\n   V(ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST, TypeError)                    \\\n   V(ERR_MISSING_MODULE, Error)                                               \\\n+  V(ERR_MISSING_PLATFORM_FOR_WORKER, Error)                                  \\\n   V(ERR_SCRIPT_EXECUTION_INTERRUPTED, Error)                                 \\\n   V(ERR_SCRIPT_EXECUTION_TIMEOUT, Error)                                     \\\n   V(ERR_STRING_TOO_LONG, Error)                                              \\\n@@ -68,6 +69,9 @@ namespace node {\n   V(ERR_MEMORY_ALLOCATION_FAILED, \"Failed to allocate memory\")               \\\n   V(ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST,                               \\\n     \"MessagePort was found in message but not listed in transferList\")       \\\n+  V(ERR_MISSING_PLATFORM_FOR_WORKER,                                         \\\n+    \"The V8 platform used by this instance of Node does not support \"        \\\n+    \"creating Workers\")                                                      \\\n   V(ERR_SCRIPT_EXECUTION_INTERRUPTED,                                        \\\n     \"Script execution was interrupted by `SIGINT`\")                          \\\n   V(ERR_TRANSFERRING_EXTERNALIZED_SHAREDARRAYBUFFER,                         \\"
        },
        {
            "sha": "7760eb26c6c15cc1333530d86c5b5f883b3775b1",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -137,6 +137,7 @@ struct sockaddr;\n     V(util)                                                                   \\\n     V(uv)                                                                     \\\n     V(v8)                                                                     \\\n+    V(worker)                                                                 \\\n     V(zlib)\n \n #define NODE_BUILTIN_MODULES(V)                                               \\\n@@ -314,6 +315,10 @@ class FatalTryCatch : public v8::TryCatch {\n   Environment* env_;\n };\n \n+void ReportException(Environment* env,\n+                     v8::Local<v8::Value> er,\n+                     v8::Local<v8::Message> message);\n+\n v8::Maybe<bool> ProcessEmitWarning(Environment* env, const char* fmt, ...);\n v8::Maybe<bool> ProcessEmitDeprecationWarning(Environment* env,\n                                               const char* warning,"
        },
        {
            "sha": "352749ea48f48395c389999fd7a60e49609bfbd7",
            "filename": "src/node_messaging.cc",
            "status": "modified",
            "additions": 26,
            "deletions": 3,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_messaging.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_messaging.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.cc?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -57,7 +57,7 @@ class DeserializerDelegate : public ValueDeserializer::Delegate {\n     if (!deserializer->ReadUint32(&id))\n       return MaybeLocal<Object>();\n     CHECK_LE(id, message_ports_.size());\n-    return message_ports_[id]->object();\n+    return message_ports_[id]->object(isolate);\n   };\n \n   MaybeLocal<SharedArrayBuffer> GetSharedArrayBufferFromId(\n@@ -436,7 +436,7 @@ MessagePort* MessagePort::New(\n \n void MessagePort::OnMessage() {\n   HandleScope handle_scope(env()->isolate());\n-  Local<Context> context = object()->CreationContext();\n+  Local<Context> context = object(env()->isolate())->CreationContext();\n \n   // data_ can only ever be modified by the owner thread, so no need to lock.\n   // However, the message port may be transferred while it is processing\n@@ -447,6 +447,13 @@ void MessagePort::OnMessage() {\n     {\n       // Get the head of the message queue.\n       Mutex::ScopedLock lock(data_->mutex_);\n+\n+      if (stop_event_loop_) {\n+        CHECK(!data_->receiving_messages_);\n+        uv_stop(env()->event_loop());\n+        break;\n+      }\n+\n       if (!data_->receiving_messages_)\n         break;\n       if (data_->incoming_messages_.empty())\n@@ -514,8 +521,9 @@ void MessagePort::Send(Message&& message) {\n \n void MessagePort::Send(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Local<Context> context = object(env->isolate())->CreationContext();\n   Message msg;\n-  if (msg.Serialize(env, object()->CreationContext(), args[0], args[1])\n+  if (msg.Serialize(env, context, args[0], args[1])\n           .IsNothing()) {\n     return;\n   }\n@@ -548,6 +556,14 @@ void MessagePort::Stop() {\n   data_->receiving_messages_ = false;\n }\n \n+void MessagePort::StopEventLoop() {\n+  Mutex::ScopedLock lock(data_->mutex_);\n+  data_->receiving_messages_ = false;\n+  stop_event_loop_ = true;\n+\n+  TriggerAsync();\n+}\n+\n void MessagePort::Start(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   MessagePort* port;\n@@ -570,6 +586,12 @@ void MessagePort::Stop(const FunctionCallbackInfo<Value>& args) {\n   port->Stop();\n }\n \n+void MessagePort::Drain(const FunctionCallbackInfo<Value>& args) {\n+  MessagePort* port;\n+  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());\n+  port->OnMessage();\n+}\n+\n size_t MessagePort::self_size() const {\n   Mutex::ScopedLock lock(data_->mutex_);\n   size_t sz = sizeof(*this) + sizeof(*data_);\n@@ -604,6 +626,7 @@ MaybeLocal<Function> GetMessagePortConstructor(\n     env->SetProtoMethod(m, \"postMessage\", MessagePort::PostMessage);\n     env->SetProtoMethod(m, \"start\", MessagePort::Start);\n     env->SetProtoMethod(m, \"stop\", MessagePort::Stop);\n+    env->SetProtoMethod(m, \"drain\", MessagePort::Drain);\n     env->SetProtoMethod(m, \"close\", HandleWrap::Close);\n     env->SetProtoMethod(m, \"unref\", HandleWrap::Unref);\n     env->SetProtoMethod(m, \"ref\", HandleWrap::Ref);"
        },
        {
            "sha": "9a13437d19a3311093fbf44aaaab033ede5b57ab",
            "filename": "src/node_messaging.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_messaging.h",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_messaging.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.h?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -133,11 +133,15 @@ class MessagePort : public HandleWrap {\n   void Start();\n   // Stop processing messages on this port as a receiving end.\n   void Stop();\n+  // Stop processing messages on this port as a receiving end,\n+  // and stop the event loop that this port is associated with.\n+  void StopEventLoop();\n \n   static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void PostMessage(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void Start(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void Stop(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void Drain(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n   // Turns `a` and `b` into siblings, i.e. connects the sending side of one\n   // to the receiving side of the other. This is not thread-safe.\n@@ -160,6 +164,7 @@ class MessagePort : public HandleWrap {\n   inline uv_async_t* async();\n \n   std::unique_ptr<MessagePortData> data_ = nullptr;\n+  bool stop_event_loop_ = false;\n \n   friend class MessagePortData;\n };"
        },
        {
            "sha": "366dca353d345ce83c9a4524e799946fc524101e",
            "filename": "src/node_worker.cc",
            "status": "added",
            "additions": 428,
            "deletions": 0,
            "changes": 428,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_worker.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_worker.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_worker.cc?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,428 @@\n+#include \"node_worker.h\"\n+#include \"node_errors.h\"\n+#include \"node_internals.h\"\n+#include \"node_buffer.h\"\n+#include \"node_perf.h\"\n+#include \"util.h\"\n+#include \"util-inl.h\"\n+#include \"async_wrap.h\"\n+#include \"async_wrap-inl.h\"\n+\n+using v8::ArrayBuffer;\n+using v8::Context;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::FunctionTemplate;\n+using v8::HandleScope;\n+using v8::Integer;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Locker;\n+using v8::Number;\n+using v8::Object;\n+using v8::SealHandleScope;\n+using v8::String;\n+using v8::Value;\n+\n+namespace node {\n+namespace worker {\n+\n+namespace {\n+\n+double next_thread_id = 1;\n+Mutex next_thread_id_mutex;\n+\n+}  // anonymous namespace\n+\n+Worker::Worker(Environment* env, Local<Object> wrap)\n+    : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_WORKER) {\n+  // Generate a new thread id.\n+  {\n+    Mutex::ScopedLock next_thread_id_lock(next_thread_id_mutex);\n+    thread_id_ = next_thread_id++;\n+  }\n+  wrap->Set(env->context(),\n+            env->thread_id_string(),\n+            Number::New(env->isolate(), thread_id_)).FromJust();\n+\n+  // Set up everything that needs to be set up in the parent environment.\n+  parent_port_ = MessagePort::New(env, env->context());\n+  if (parent_port_ == nullptr) {\n+    // This can happen e.g. because execution is terminating.\n+    return;\n+  }\n+\n+  child_port_data_.reset(new MessagePortData(nullptr));\n+  MessagePort::Entangle(parent_port_, child_port_data_.get());\n+\n+  object()->Set(env->context(),\n+                env->message_port_string(),\n+                parent_port_->object()).FromJust();\n+\n+  array_buffer_allocator_.reset(CreateArrayBufferAllocator());\n+\n+  isolate_ = NewIsolate(array_buffer_allocator_.get());\n+  CHECK_NE(isolate_, nullptr);\n+  CHECK_EQ(uv_loop_init(&loop_), 0);\n+\n+  thread_exit_async_.reset(new uv_async_t);\n+  thread_exit_async_->data = this;\n+  CHECK_EQ(uv_async_init(env->event_loop(),\n+                         thread_exit_async_.get(),\n+                         [](uv_async_t* handle) {\n+    static_cast<Worker*>(handle->data)->OnThreadStopped();\n+  }), 0);\n+\n+  {\n+    // Enter an environment capable of executing code in the child Isolate\n+    // (and only in it).\n+    Locker locker(isolate_);\n+    Isolate::Scope isolate_scope(isolate_);\n+    HandleScope handle_scope(isolate_);\n+\n+    isolate_data_.reset(CreateIsolateData(isolate_,\n+                                          &loop_,\n+                                          env->isolate_data()->platform(),\n+                                          array_buffer_allocator_.get()));\n+    CHECK(isolate_data_);\n+\n+    Local<Context> context = NewContext(isolate_);\n+    Context::Scope context_scope(context);\n+\n+    // TODO(addaleax): Use CreateEnvironment(), or generally another public API.\n+    env_.reset(new Environment(isolate_data_.get(),\n+                               context,\n+                               nullptr));\n+    CHECK_NE(env_, nullptr);\n+    env_->set_abort_on_uncaught_exception(false);\n+    env_->set_worker_context(this);\n+    env_->set_thread_id(thread_id_);\n+\n+    env_->Start(0, nullptr, 0, nullptr, env->profiler_idle_notifier_started());\n+  }\n+\n+  // The new isolate won't be bothered on this thread again.\n+  isolate_->DiscardThreadSpecificMetadata();\n+}\n+\n+bool Worker::is_stopped() const {\n+  Mutex::ScopedLock stopped_lock(stopped_mutex_);\n+  return stopped_;\n+}\n+\n+void Worker::Run() {\n+  MultiIsolatePlatform* platform = isolate_data_->platform();\n+  CHECK_NE(platform, nullptr);\n+\n+  {\n+    Locker locker(isolate_);\n+    Isolate::Scope isolate_scope(isolate_);\n+    SealHandleScope outer_seal(isolate_);\n+\n+    {\n+      Context::Scope context_scope(env_->context());\n+      HandleScope handle_scope(isolate_);\n+\n+      {\n+        HandleScope handle_scope(isolate_);\n+        Mutex::ScopedLock lock(mutex_);\n+        // Set up the message channel for receiving messages in the child.\n+        child_port_ = MessagePort::New(env_.get(),\n+                                       env_->context(),\n+                                       std::move(child_port_data_));\n+        // MessagePort::New() may return nullptr if execution is terminated\n+        // within it.\n+        if (child_port_ != nullptr)\n+          env_->set_message_port(child_port_->object(isolate_));\n+      }\n+\n+      if (!is_stopped()) {\n+        HandleScope handle_scope(isolate_);\n+        Environment::AsyncCallbackScope callback_scope(env_.get());\n+        env_->async_hooks()->push_async_ids(1, 0);\n+        // This loads the Node bootstrapping code.\n+        LoadEnvironment(env_.get());\n+        env_->async_hooks()->pop_async_id(1);\n+      }\n+\n+      {\n+        SealHandleScope seal(isolate_);\n+        bool more;\n+        env_->performance_state()->Mark(\n+            node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);\n+        do {\n+          if (is_stopped()) break;\n+          uv_run(&loop_, UV_RUN_DEFAULT);\n+          if (is_stopped()) break;\n+\n+          platform->DrainBackgroundTasks(isolate_);\n+\n+          more = uv_loop_alive(&loop_);\n+          if (more && !is_stopped())\n+            continue;\n+\n+          EmitBeforeExit(env_.get());\n+\n+          // Emit `beforeExit` if the loop became alive either after emitting\n+          // event, or after running some callbacks.\n+          more = uv_loop_alive(&loop_);\n+        } while (more == true);\n+        env_->performance_state()->Mark(\n+            node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_EXIT);\n+      }\n+    }\n+\n+    {\n+      int exit_code;\n+      bool stopped = is_stopped();\n+      if (!stopped)\n+        exit_code = EmitExit(env_.get());\n+      Mutex::ScopedLock lock(mutex_);\n+      if (exit_code_ == 0 && !stopped)\n+        exit_code_ = exit_code;\n+    }\n+\n+    env_->set_can_call_into_js(false);\n+    Isolate::DisallowJavascriptExecutionScope disallow_js(isolate_,\n+        Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);\n+\n+    // Grab the parent-to-child channel and render is unusable.\n+    MessagePort* child_port;\n+    {\n+      Mutex::ScopedLock lock(mutex_);\n+      child_port = child_port_;\n+      child_port_ = nullptr;\n+    }\n+\n+    {\n+      Context::Scope context_scope(env_->context());\n+      child_port->Close();\n+      env_->stop_sub_worker_contexts();\n+      env_->RunCleanup();\n+      RunAtExit(env_.get());\n+\n+      {\n+        Mutex::ScopedLock stopped_lock(stopped_mutex_);\n+        stopped_ = true;\n+      }\n+\n+      env_->RunCleanup();\n+\n+      // This call needs to be made while the `Environment` is still alive\n+      // because we assume that it is available for async tracking in the\n+      // NodePlatform implementation.\n+      platform->DrainBackgroundTasks(isolate_);\n+    }\n+\n+    env_.reset();\n+  }\n+\n+  DisposeIsolate();\n+\n+  // Need to run the loop one more time to close the platform's uv_async_t\n+  uv_run(&loop_, UV_RUN_ONCE);\n+\n+  {\n+    Mutex::ScopedLock lock(mutex_);\n+    CHECK(thread_exit_async_);\n+    scheduled_on_thread_stopped_ = true;\n+    uv_async_send(thread_exit_async_.get());\n+  }\n+}\n+\n+void Worker::DisposeIsolate() {\n+  if (isolate_ == nullptr)\n+    return;\n+\n+  CHECK(isolate_data_);\n+  MultiIsolatePlatform* platform = isolate_data_->platform();\n+  platform->CancelPendingDelayedTasks(isolate_);\n+\n+  isolate_data_.reset();\n+\n+  isolate_->Dispose();\n+  isolate_ = nullptr;\n+}\n+\n+void Worker::JoinThread() {\n+  if (thread_joined_)\n+    return;\n+  CHECK_EQ(uv_thread_join(&tid_), 0);\n+  thread_joined_ = true;\n+\n+  env()->remove_sub_worker_context(this);\n+\n+  if (thread_exit_async_) {\n+    env()->CloseHandle(thread_exit_async_.release(), [](uv_async_t* async) {\n+      delete async;\n+    });\n+\n+    if (scheduled_on_thread_stopped_)\n+      OnThreadStopped();\n+  }\n+}\n+\n+void Worker::OnThreadStopped() {\n+  Mutex::ScopedLock lock(mutex_);\n+  scheduled_on_thread_stopped_ = false;\n+\n+  {\n+    Mutex::ScopedLock stopped_lock(stopped_mutex_);\n+    CHECK(stopped_);\n+  }\n+\n+  CHECK_EQ(child_port_, nullptr);\n+  parent_port_ = nullptr;\n+\n+  // It's okay to join the thread while holding the mutex because\n+  // OnThreadStopped means it's no longer doing any work that might grab it\n+  // and really just silently exiting.\n+  JoinThread();\n+\n+  {\n+    HandleScope handle_scope(env()->isolate());\n+    Context::Scope context_scope(env()->context());\n+\n+    // Reset the parent port as we're closing it now anyway.\n+    object()->Set(env()->context(),\n+                  env()->message_port_string(),\n+                  Undefined(env()->isolate())).FromJust();\n+\n+    Local<Value> code = Integer::New(env()->isolate(), exit_code_);\n+    MakeCallback(env()->onexit_string(), 1, &code);\n+  }\n+\n+  // JoinThread() cleared all libuv handles bound to this Worker,\n+  // the C++ object is no longer needed for anything now.\n+  MakeWeak();\n+}\n+\n+Worker::~Worker() {\n+  Mutex::ScopedLock lock(mutex_);\n+  JoinThread();\n+\n+  CHECK(stopped_);\n+  CHECK(thread_joined_);\n+  CHECK_EQ(child_port_, nullptr);\n+  CHECK_EQ(uv_loop_close(&loop_), 0);\n+\n+  // This has most likely already happened within the worker thread -- this\n+  // is just in case Worker creation failed early.\n+  DisposeIsolate();\n+}\n+\n+void Worker::New(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  CHECK(args.IsConstructCall());\n+\n+  if (env->isolate_data()->platform() == nullptr) {\n+    THROW_ERR_MISSING_PLATFORM_FOR_WORKER(env);\n+    return;\n+  }\n+\n+  new Worker(env, args.This());\n+}\n+\n+void Worker::StartThread(const FunctionCallbackInfo<Value>& args) {\n+  Worker* w;\n+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());\n+  Mutex::ScopedLock lock(w->mutex_);\n+\n+  w->env()->add_sub_worker_context(w);\n+  w->stopped_ = false;\n+  CHECK_EQ(uv_thread_create(&w->tid_, [](void* arg) {\n+    static_cast<Worker*>(arg)->Run();\n+  }, static_cast<void*>(w)), 0);\n+  w->thread_joined_ = false;\n+}\n+\n+void Worker::StopThread(const FunctionCallbackInfo<Value>& args) {\n+  Worker* w;\n+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());\n+\n+  w->Exit(1);\n+  w->JoinThread();\n+}\n+\n+void Worker::Ref(const FunctionCallbackInfo<Value>& args) {\n+  Worker* w;\n+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());\n+  if (w->thread_exit_async_)\n+    uv_ref(reinterpret_cast<uv_handle_t*>(w->thread_exit_async_.get()));\n+}\n+\n+void Worker::Unref(const FunctionCallbackInfo<Value>& args) {\n+  Worker* w;\n+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());\n+  if (w->thread_exit_async_)\n+    uv_unref(reinterpret_cast<uv_handle_t*>(w->thread_exit_async_.get()));\n+}\n+\n+void Worker::Exit(int code) {\n+  Mutex::ScopedLock lock(mutex_);\n+  Mutex::ScopedLock stopped_lock(stopped_mutex_);\n+  if (!stopped_) {\n+    CHECK_NE(env_, nullptr);\n+    stopped_ = true;\n+    exit_code_ = code;\n+    if (child_port_ != nullptr)\n+      child_port_->StopEventLoop();\n+    isolate_->TerminateExecution();\n+  }\n+}\n+\n+size_t Worker::self_size() const {\n+  return sizeof(*this);\n+}\n+\n+namespace {\n+\n+// Return the MessagePort that is global for this Environment and communicates\n+// with the internal [kPort] port of the JS Worker class in the parent thread.\n+void GetEnvMessagePort(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Local<Object> port = env->message_port();\n+  if (!port.IsEmpty()) {\n+    CHECK_EQ(port->CreationContext()->GetIsolate(), args.GetIsolate());\n+    args.GetReturnValue().Set(port);\n+  }\n+}\n+\n+void InitWorker(Local<Object> target,\n+                Local<Value> unused,\n+                Local<Context> context,\n+                void* priv) {\n+  Environment* env = Environment::GetCurrent(context);\n+\n+  {\n+    Local<FunctionTemplate> w = env->NewFunctionTemplate(Worker::New);\n+\n+    w->InstanceTemplate()->SetInternalFieldCount(1);\n+\n+    AsyncWrap::AddWrapMethods(env, w);\n+    env->SetProtoMethod(w, \"startThread\", Worker::StartThread);\n+    env->SetProtoMethod(w, \"stopThread\", Worker::StopThread);\n+    env->SetProtoMethod(w, \"ref\", Worker::Ref);\n+    env->SetProtoMethod(w, \"unref\", Worker::Unref);\n+\n+    Local<String> workerString =\n+        FIXED_ONE_BYTE_STRING(env->isolate(), \"Worker\");\n+    w->SetClassName(workerString);\n+    target->Set(workerString, w->GetFunction());\n+  }\n+\n+  env->SetMethod(target, \"getEnvMessagePort\", GetEnvMessagePort);\n+\n+  auto thread_id_string = FIXED_ONE_BYTE_STRING(env->isolate(), \"threadId\");\n+  target->Set(env->context(),\n+              thread_id_string,\n+              Number::New(env->isolate(), env->thread_id())).FromJust();\n+}\n+\n+}  // anonymous namespace\n+\n+}  // namespace worker\n+}  // namespace node\n+\n+NODE_MODULE_CONTEXT_AWARE_INTERNAL(worker, node::worker::InitWorker)"
        },
        {
            "sha": "0a98d2f11ef00fc472d0e49a20b05d2d372fbea1",
            "filename": "src/node_worker.h",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_worker.h",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/src%2Fnode_worker.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_worker.h?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,83 @@\n+#ifndef SRC_NODE_WORKER_H_\n+#define SRC_NODE_WORKER_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"node_messaging.h\"\n+#include <unordered_map>\n+\n+namespace node {\n+namespace worker {\n+\n+// A worker thread, as represented in its parent thread.\n+class Worker : public AsyncWrap {\n+ public:\n+  Worker(Environment* env, v8::Local<v8::Object> wrap);\n+  ~Worker();\n+\n+  // Run the worker. This is only called from the worker thread.\n+  void Run();\n+\n+  // Forcibly exit the thread with a specified exit code. This may be called\n+  // from any thread.\n+  void Exit(int code);\n+\n+  // Wait for the worker thread to stop (in a blocking manner).\n+  void JoinThread();\n+\n+  size_t self_size() const override;\n+  bool is_stopped() const;\n+\n+  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void StartThread(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void StopThread(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void GetMessagePort(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void Ref(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void Unref(const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n+ private:\n+  void OnThreadStopped();\n+  void DisposeIsolate();\n+\n+  uv_loop_t loop_;\n+  DeleteFnPtr<IsolateData, FreeIsolateData> isolate_data_;\n+  DeleteFnPtr<Environment, FreeEnvironment> env_;\n+  v8::Isolate* isolate_ = nullptr;\n+  DeleteFnPtr<ArrayBufferAllocator, FreeArrayBufferAllocator>\n+      array_buffer_allocator_;\n+  uv_thread_t tid_;\n+\n+  // This mutex protects access to all variables listed below it.\n+  mutable Mutex mutex_;\n+\n+  // Currently only used for telling the parent thread that the child\n+  // thread exited.\n+  std::unique_ptr<uv_async_t> thread_exit_async_;\n+  bool scheduled_on_thread_stopped_ = false;\n+\n+  // This mutex only protects stopped_. If both locks are acquired, this needs\n+  // to be the latter one.\n+  mutable Mutex stopped_mutex_;\n+  bool stopped_ = true;\n+\n+  bool thread_joined_ = true;\n+  int exit_code_ = 0;\n+  double thread_id_ = -1;\n+\n+  std::unique_ptr<MessagePortData> child_port_data_;\n+\n+  // The child port is always kept alive by the child Environment's persistent\n+  // handle to it.\n+  MessagePort* child_port_ = nullptr;\n+  // This is always kept alive because the JS object associated with the Worker\n+  // instance refers to it via its [kPort] property.\n+  MessagePort* parent_port_ = nullptr;\n+};\n+\n+}  // namespace worker\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+\n+#endif  // SRC_NODE_WORKER_H_"
        },
        {
            "sha": "b712248b2788e8af048517e50841f756fde7aac3",
            "filename": "test/fixtures/worker-script.mjs",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Ffixtures%2Fworker-script.mjs",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Ffixtures%2Fworker-script.mjs",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Ffixtures%2Fworker-script.mjs?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,3 @@\n+import worker from 'worker';\n+\n+worker.parentPort.postMessage('Hello, world!');"
        },
        {
            "sha": "7ae922adbc4e40562d419b32e43ee278773bf885",
            "filename": "test/parallel/test-message-channel-sharedarraybuffer.js",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-message-channel-sharedarraybuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-message-channel-sharedarraybuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-message-channel-sharedarraybuffer.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,28 @@\n+// Flags: --expose-gc --experimental-worker\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const { Worker } = require('worker');\n+\n+{\n+  const sharedArrayBuffer = new SharedArrayBuffer(12);\n+  const local = Buffer.from(sharedArrayBuffer);\n+\n+  const w = new Worker(`\n+    const { parentPort } = require('worker');\n+    parentPort.on('message', ({ sharedArrayBuffer }) => {\n+      const local = Buffer.from(sharedArrayBuffer);\n+      local.write('world!', 6);\n+      parentPort.postMessage('written!');\n+    });\n+  `, { eval: true });\n+  w.on('message', common.mustCall(() => {\n+    assert.strictEqual(local.toString(), 'Hello world!');\n+    global.gc();\n+    w.terminate();\n+  }));\n+  w.postMessage({ sharedArrayBuffer });\n+  // This would be a race condition if the memory regions were overlapping\n+  local.write('Hello ');\n+}"
        },
        {
            "sha": "eb13fa57c6aa0f7dd51b7699857e7575fa84df04",
            "filename": "test/parallel/test-message-channel.js",
            "status": "modified",
            "additions": 21,
            "deletions": 1,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-message-channel.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-message-channel.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-message-channel.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -2,7 +2,7 @@\n 'use strict';\n const common = require('../common');\n const assert = require('assert');\n-const { MessageChannel } = require('worker');\n+const { MessageChannel, MessagePort, Worker } = require('worker');\n \n {\n   const channel = new MessageChannel();\n@@ -24,3 +24,23 @@ const { MessageChannel } = require('worker');\n   channel.port2.on('close', common.mustCall());\n   channel.port2.close();\n }\n+\n+{\n+  const channel = new MessageChannel();\n+\n+  const w = new Worker(`\n+    const { MessagePort } = require('worker');\n+    const assert = require('assert');\n+    require('worker').parentPort.on('message', ({ port }) => {\n+      assert(port instanceof MessagePort);\n+      port.postMessage('works');\n+    });\n+  `, { eval: true });\n+  w.postMessage({ port: channel.port2 }, [ channel.port2 ]);\n+  assert(channel.port1 instanceof MessagePort);\n+  assert(channel.port2 instanceof MessagePort);\n+  channel.port1.on('message', common.mustCall((message) => {\n+    assert.strictEqual(message, 'works');\n+    w.terminate();\n+  }));\n+}"
        },
        {
            "sha": "ba4f6aa51a9d41c2bf829019769f2e14f40a5955",
            "filename": "test/parallel/test-worker-cleanup-handles.js",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-cleanup-handles.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-cleanup-handles.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-cleanup-handles.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,30 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const { Worker, isMainThread, parentPort } = require('worker');\n+const { Server } = require('net');\n+const fs = require('fs');\n+\n+if (isMainThread) {\n+  const w = new Worker(__filename);\n+  let fd = null;\n+  w.on('message', common.mustCall((fd_) => {\n+    assert.strictEqual(typeof fd_, 'number');\n+    fd = fd_;\n+  }));\n+  w.on('exit', common.mustCall((code) => {\n+    if (fd === -1) {\n+      // This happens when server sockets don’t have file descriptors,\n+      // i.e. on Windows.\n+      return;\n+    }\n+    common.expectsError(() => fs.fstatSync(fd),\n+                        { code: 'EBADF' });\n+  }));\n+} else {\n+  const server = new Server();\n+  server.listen(0);\n+  parentPort.postMessage(server._handle.fd);\n+  server.unref();\n+}"
        },
        {
            "sha": "079a29d52e09a3463e429f6fe676f1b6f8fffe32",
            "filename": "test/parallel/test-worker-dns-terminate.js",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-dns-terminate.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-dns-terminate.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-dns-terminate.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,15 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const { Worker } = require('worker');\n+\n+const w = new Worker(`\n+const dns = require('dns');\n+dns.lookup('nonexistent.org', () => {});\n+require('worker').parentPort.postMessage('0');\n+`, { eval: true });\n+\n+w.on('message', common.mustCall(() => {\n+  // This should not crash the worker during a DNS request.\n+  w.terminate(common.mustCall());\n+}));"
        },
        {
            "sha": "4189eeca3f8908a0d8dbb0457db39c147572b5fc",
            "filename": "test/parallel/test-worker-esmodule.js",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-esmodule.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-esmodule.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-esmodule.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,11 @@\n+// Flags: --experimental-worker --experimental-modules\n+'use strict';\n+const common = require('../common');\n+const fixtures = require('../common/fixtures');\n+const assert = require('assert');\n+const { Worker } = require('worker');\n+\n+const w = new Worker(fixtures.path('worker-script.mjs'));\n+w.on('message', common.mustCall((message) => {\n+  assert.strictEqual(message, 'Hello, world!');\n+}));"
        },
        {
            "sha": "34b1e0acaf2f2f70271b003d428170db0b3ee765",
            "filename": "test/parallel/test-worker-memory.js",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-memory.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-memory.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-memory.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,41 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const util = require('util');\n+const { Worker } = require('worker');\n+\n+const numWorkers = +process.env.JOBS || require('os').cpus().length;\n+\n+// Verify that a Worker's memory isn't kept in memory after the thread finishes.\n+\n+function run(n, done) {\n+  if (n <= 0)\n+    return done();\n+  const worker = new Worker(\n+    'require(\\'worker\\').parentPort.postMessage(2 + 2)',\n+    { eval: true });\n+  worker.on('message', common.mustCall((value) => {\n+    assert.strictEqual(value, 4);\n+  }));\n+  worker.on('exit', common.mustCall(() => {\n+    run(n - 1, done);\n+  }));\n+}\n+\n+const startStats = process.memoryUsage();\n+let finished = 0;\n+for (let i = 0; i < numWorkers; ++i) {\n+  run(60 / numWorkers, () => {\n+    if (++finished === numWorkers) {\n+      const finishStats = process.memoryUsage();\n+      // A typical value for this ratio would be ~1.15.\n+      // 5 as a upper limit is generous, but the main point is that we\n+      // don't have the memory of 50 Isolates/Node.js environments just lying\n+      // around somewhere.\n+      assert.ok(finishStats.rss / startStats.rss < 5,\n+                'Unexpected memory overhead: ' +\n+                util.inspect([startStats, finishStats]));\n+    }\n+  });\n+}"
        },
        {
            "sha": "b010a7dbe5727f3baaae41640325955a6f0b06e2",
            "filename": "test/parallel/test-worker-nexttick-terminate.js",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-nexttick-terminate.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-nexttick-terminate.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-nexttick-terminate.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,20 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const { Worker } = require('worker');\n+\n+// Checks that terminating in the middle of `process.nextTick()` does not\n+// Crash the process.\n+\n+const w = new Worker(`\n+require('worker').parentPort.postMessage('0');\n+process.nextTick(() => {\n+  while(1);\n+});\n+`, { eval: true });\n+\n+w.on('message', common.mustCall(() => {\n+  setTimeout(() => {\n+    w.terminate(common.mustCall());\n+  }, 1);\n+}));"
        },
        {
            "sha": "37798f334387d858516d3d5d579bc3700da72aed",
            "filename": "test/parallel/test-worker-syntax-error-file.js",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-syntax-error-file.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-syntax-error-file.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-syntax-error-file.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,18 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const fixtures = require('../common/fixtures');\n+const assert = require('assert');\n+const { Worker } = require('worker');\n+\n+// Do not use isMainThread so that this test itself can be run inside a Worker.\n+if (!process.env.HAS_STARTED_WORKER) {\n+  process.env.HAS_STARTED_WORKER = 1;\n+  const w = new Worker(fixtures.path('syntax', 'bad_syntax.js'));\n+  w.on('message', common.mustNotCall());\n+  w.on('error', common.mustCall((err) => {\n+    assert(/SyntaxError/.test(err));\n+  }));\n+} else {\n+  throw new Error('foo');\n+}"
        },
        {
            "sha": "8f9812a721132b0fc64b59b9ce5680a1c00663a7",
            "filename": "test/parallel/test-worker-syntax-error.js",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-syntax-error.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-syntax-error.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-syntax-error.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,17 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const { Worker } = require('worker');\n+\n+// Do not use isMainThread so that this test itself can be run inside a Worker.\n+if (!process.env.HAS_STARTED_WORKER) {\n+  process.env.HAS_STARTED_WORKER = 1;\n+  const w = new Worker('abc)', { eval: true });\n+  w.on('message', common.mustNotCall());\n+  w.on('error', common.mustCall((err) => {\n+    assert(/SyntaxError/.test(err));\n+  }));\n+} else {\n+  throw new Error('foo');\n+}"
        },
        {
            "sha": "c1d2a5f4fcab1625ea8b9d8248916e1a67305a77",
            "filename": "test/parallel/test-worker-uncaught-exception-async.js",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-uncaught-exception-async.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-uncaught-exception-async.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-uncaught-exception-async.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,20 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const { Worker } = require('worker');\n+\n+// Do not use isMainThread so that this test itself can be run inside a Worker.\n+if (!process.env.HAS_STARTED_WORKER) {\n+  process.env.HAS_STARTED_WORKER = 1;\n+  const w = new Worker(__filename);\n+  w.on('message', common.mustNotCall());\n+  w.on('error', common.mustCall((err) => {\n+    // TODO(addaleax): be more specific here\n+    assert(/foo/.test(err));\n+  }));\n+} else {\n+  setImmediate(() => {\n+    throw new Error('foo');\n+  });\n+}"
        },
        {
            "sha": "b0e3ad11fae839fd34fb513688668c2234924b23",
            "filename": "test/parallel/test-worker-uncaught-exception.js",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-uncaught-exception.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker-uncaught-exception.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-uncaught-exception.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,18 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const { Worker } = require('worker');\n+\n+// Do not use isMainThread so that this test itself can be run inside a Worker.\n+if (!process.env.HAS_STARTED_WORKER) {\n+  process.env.HAS_STARTED_WORKER = 1;\n+  const w = new Worker(__filename);\n+  w.on('message', common.mustNotCall());\n+  w.on('error', common.mustCall((err) => {\n+    // TODO(addaleax): be more specific here\n+    assert(/foo/.test(err));\n+  }));\n+} else {\n+  throw new Error('foo');\n+}"
        },
        {
            "sha": "3fa6e67a347b37b5adecbea08229a13d0dc18491",
            "filename": "test/parallel/test-worker.js",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fparallel%2Ftest-worker.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -0,0 +1,18 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const { Worker, isMainThread, parentPort } = require('worker');\n+\n+if (isMainThread) {\n+  const w = new Worker(__filename);\n+  w.on('message', common.mustCall((message) => {\n+    assert.strictEqual(message, 'Hello, world!');\n+  }));\n+} else {\n+  setImmediate(() => {\n+    process.nextTick(() => {\n+      parentPort.postMessage('Hello, world!');\n+    });\n+  });\n+}"
        },
        {
            "sha": "af08d7b6567018d8a418fbdad29b1fb63b475c97",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/0df031acadcc6490379d72676203a980c8d60592/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/0df031acadcc6490379d72676203a980c8d60592/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=0df031acadcc6490379d72676203a980c8d60592",
            "patch": "@@ -38,6 +38,7 @@ common.crashOnUnhandledRejection();\n     // TODO(addaleax): Test for these\n     delete providers.STREAMPIPE;\n     delete providers.MESSAGEPORT;\n+    delete providers.WORKER;\n \n     const objKeys = Object.keys(providers);\n     if (objKeys.length > 0)"
        }
    ],
    "stats": {
        "total": 1703,
        "additions": 1629,
        "deletions": 74
    }
}