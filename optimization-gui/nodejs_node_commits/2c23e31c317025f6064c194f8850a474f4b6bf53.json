{
    "author": "joyeecheung",
    "message": "src: throw ERR_INVALID_ARG_TYPE in C++ argument checks\n\n- Moves THROW_AND_RETURN_IF_NOT_BUFFER and\n  THROW_AND_RETURN_IF_NOT_STRING from node_crypto.cc to\n  node_errors.h so it can be reused.\n- Move THROW_AND_RETURN_UNLESS_BUFFER in util.h to\n  node_buffer.cc and call THROW_AND_RETURN_IF_NOT_BUFFER\n  there. The only other reference to THROW_AND_RETURN_UNLESS_BUFFER in\n  node_i18n.cc can be safely replaced by an assertion since\n  the argument will be checked in JS land.\n- Migrate ERR_INVALID_ARG_TYPE errors in C++. We can move the\n  checks to JS land if possible later without having to\n  go semver-major.\n\nPR-URL: https://github.com/nodejs/node/pull/20121\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Jeremiah Senkpiel <fishrock123@rocketmail.com>",
    "sha": "2c23e31c317025f6064c194f8850a474f4b6bf53",
    "files": [
        {
            "sha": "b735fd8e3b37190da61459b9bee1de0c16ea4749",
            "filename": "src/module_wrap.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fmodule_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fmodule_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmodule_wrap.cc?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -4,6 +4,7 @@\n #include \"module_wrap.h\"\n \n #include \"env.h\"\n+#include \"node_errors.h\"\n #include \"node_url.h\"\n #include \"util-inl.h\"\n #include \"node_internals.h\"\n@@ -677,8 +678,8 @@ void ModuleWrap::Resolve(const FunctionCallbackInfo<Value>& args) {\n   URL url(*url_utf8, url_utf8.length());\n \n   if (url.flags() & URL_FLAGS_FAILED) {\n-    env->ThrowError(\"second argument is not a URL string\");\n-    return;\n+    return node::THROW_ERR_INVALID_ARG_TYPE(\n+        env, \"second argument is not a URL string\");\n   }\n \n   Maybe<URL> result = node::loader::Resolve(env, specifier_std, url);"
        },
        {
            "sha": "997e4fd2299cdbadec67da036ff4a30af3ad87a8",
            "filename": "src/node_buffer.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.cc?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -37,6 +37,9 @@\n \n #define MIN(a, b) ((a) < (b) ? (a) : (b))\n \n+#define THROW_AND_RETURN_UNLESS_BUFFER(env, obj)                            \\\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, obj, \"argument\")\n+\n #define THROW_AND_RETURN_IF_OOB(r)                                          \\\n   do {                                                                      \\\n     if (!(r)) return node::THROW_ERR_INDEX_OUT_OF_RANGE(env);               \\\n@@ -657,8 +660,7 @@ void StringWrite(const FunctionCallbackInfo<Value>& args) {\n   THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());\n   SPREAD_BUFFER_ARG(args.This(), ts_obj);\n \n-  if (!args[0]->IsString())\n-    return env->ThrowTypeError(\"Argument must be a string\");\n+  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], \"argument\");\n \n   Local<String> str = args[0]->ToString(env->context()).ToLocalChecked();\n "
        },
        {
            "sha": "cd7032d6c3eb1af4e5483eb72b8f5b68a965dd1f",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 34,
            "changes": 56,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -21,6 +21,7 @@\n \n #include \"node.h\"\n #include \"node_buffer.h\"\n+#include \"node_errors.h\"\n #include \"node_constants.h\"\n #include \"node_crypto.h\"\n #include \"node_crypto_bio.h\"\n@@ -45,20 +46,6 @@\n #include <memory>\n #include <vector>\n \n-#define THROW_AND_RETURN_IF_NOT_BUFFER(val, prefix)           \\\n-  do {                                                        \\\n-    if (!Buffer::HasInstance(val)) {                          \\\n-      return env->ThrowTypeError(prefix \" must be a buffer\"); \\\n-    }                                                         \\\n-  } while (0)\n-\n-#define THROW_AND_RETURN_IF_NOT_STRING(val, prefix)           \\\n-  do {                                                        \\\n-    if (!val->IsString()) {                                   \\\n-      return env->ThrowTypeError(prefix \" must be a string\"); \\\n-    }                                                         \\\n-  } while (0)\n-\n static const char PUBLIC_KEY_PFX[] =  \"-----BEGIN PUBLIC KEY-----\";\n static const int PUBLIC_KEY_PFX_LEN = sizeof(PUBLIC_KEY_PFX) - 1;\n static const char PUBRSA_KEY_PFX[] =  \"-----BEGIN RSA PUBLIC KEY-----\";\n@@ -518,7 +505,7 @@ void SecureContext::SetKey(const FunctionCallbackInfo<Value>& args) {\n     if (args[1]->IsUndefined() || args[1]->IsNull())\n       len = 1;\n     else\n-      THROW_AND_RETURN_IF_NOT_STRING(args[1], \"Pass phrase\");\n+      THROW_AND_RETURN_IF_NOT_STRING(env, args[1], \"Pass phrase\");\n   }\n \n   BIO *bio = LoadBIO(env, args[0]);\n@@ -916,7 +903,7 @@ void SecureContext::SetCiphers(const FunctionCallbackInfo<Value>& args) {\n     return env->ThrowTypeError(\"Ciphers argument is mandatory\");\n   }\n \n-  THROW_AND_RETURN_IF_NOT_STRING(args[0], \"Ciphers\");\n+  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], \"Ciphers\");\n \n   const node::Utf8Value ciphers(args.GetIsolate(), args[0]);\n   SSL_CTX_set_cipher_list(sc->ctx_, *ciphers);\n@@ -931,7 +918,7 @@ void SecureContext::SetECDHCurve(const FunctionCallbackInfo<Value>& args) {\n   if (args.Length() != 1)\n     return env->ThrowTypeError(\"ECDH curve name argument is mandatory\");\n \n-  THROW_AND_RETURN_IF_NOT_STRING(args[0], \"ECDH curve name\");\n+  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], \"ECDH curve name\");\n \n   node::Utf8Value curve(env->isolate(), args[0]);\n \n@@ -989,7 +976,8 @@ void SecureContext::SetOptions(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());\n \n   if (args.Length() != 1 || !args[0]->IntegerValue()) {\n-    return sc->env()->ThrowTypeError(\"Options must be an integer value\");\n+    return THROW_ERR_INVALID_ARG_TYPE(\n+        sc->env(), \"Options must be an integer value\");\n   }\n \n   SSL_CTX_set_options(\n@@ -1008,7 +996,7 @@ void SecureContext::SetSessionIdContext(\n     return env->ThrowTypeError(\"Session ID context argument is mandatory\");\n   }\n \n-  THROW_AND_RETURN_IF_NOT_STRING(args[0], \"Session ID context\");\n+  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], \"Session ID context\");\n \n   const node::Utf8Value sessionIdContext(args.GetIsolate(), args[0]);\n   const unsigned char* sid_ctx =\n@@ -1043,8 +1031,8 @@ void SecureContext::SetSessionTimeout(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());\n \n   if (args.Length() != 1 || !args[0]->IsInt32()) {\n-    return sc->env()->ThrowTypeError(\n-        \"Session timeout must be a 32-bit integer\");\n+    return THROW_ERR_INVALID_ARG_TYPE(\n+        sc->env(), \"Session timeout must be a 32-bit integer\");\n   }\n \n   int32_t sessionTimeout = args[0]->Int32Value();\n@@ -1085,7 +1073,7 @@ void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {\n   }\n \n   if (args.Length() >= 2) {\n-    THROW_AND_RETURN_IF_NOT_BUFFER(args[1], \"Pass phrase\");\n+    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], \"Pass phrase\");\n     size_t passlen = Buffer::Length(args[1]);\n     pass = new char[passlen + 1];\n     memcpy(pass, Buffer::Data(args[1]), passlen);\n@@ -1212,7 +1200,7 @@ void SecureContext::SetTicketKeys(const FunctionCallbackInfo<Value>& args) {\n     return env->ThrowTypeError(\"Ticket keys argument is mandatory\");\n   }\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(args[0], \"Ticket keys\");\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Ticket keys\");\n \n   if (Buffer::Length(args[0]) != 48) {\n     return env->ThrowTypeError(\"Ticket keys length must be 48 bytes\");\n@@ -1964,7 +1952,7 @@ void SSLWrap<Base>::SetSession(const FunctionCallbackInfo<Value>& args) {\n     return env->ThrowError(\"Session argument is mandatory\");\n   }\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(args[0], \"Session\");\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Session\");\n   size_t slen = Buffer::Length(args[0]);\n   char* sbuf = new char[slen];\n   memcpy(sbuf, Buffer::Data(args[0]), slen);\n@@ -2088,7 +2076,7 @@ void SSLWrap<Base>::SetOCSPResponse(\n   if (args.Length() < 1)\n     return env->ThrowTypeError(\"OCSP response argument is mandatory\");\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(args[0], \"OCSP response\");\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"OCSP response\");\n \n   w->ocsp_response_.Reset(args.GetIsolate(), args[0].As<Object>());\n #endif  // NODE__HAVE_TLSEXT_STATUS_CB\n@@ -3937,11 +3925,11 @@ template <PublicKeyCipher::Operation operation,\n void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(args[0], \"Key\");\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Key\");\n   char* kbuf = Buffer::Data(args[0]);\n   ssize_t klen = Buffer::Length(args[0]);\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(args[1], \"Data\");\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], \"Data\");\n   char* buf = Buffer::Data(args[1]);\n   ssize_t len = Buffer::Length(args[1]);\n \n@@ -4097,7 +4085,7 @@ void DiffieHellman::DiffieHellmanGroup(\n     return env->ThrowError(\"Group name argument is mandatory\");\n   }\n \n-  THROW_AND_RETURN_IF_NOT_STRING(args[0], \"Group name\");\n+  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], \"Group name\");\n \n   bool initialized = false;\n \n@@ -4246,7 +4234,7 @@ void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n   if (args.Length() == 0) {\n     return env->ThrowError(\"Other party's public key argument is mandatory\");\n   } else {\n-    THROW_AND_RETURN_IF_NOT_BUFFER(args[0], \"Other party's public key\");\n+    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Other party's public key\");\n     key = BN_bin2bn(\n         reinterpret_cast<unsigned char*>(Buffer::Data(args[0])),\n         Buffer::Length(args[0]),\n@@ -4319,7 +4307,7 @@ void DiffieHellman::SetKey(const v8::FunctionCallbackInfo<v8::Value>& args,\n \n   if (!Buffer::HasInstance(args[0])) {\n     snprintf(errmsg, sizeof(errmsg), \"%s must be a buffer\", what);\n-    return env->ThrowTypeError(errmsg);\n+    return THROW_ERR_INVALID_ARG_TYPE(env, errmsg);\n   }\n \n   BIGNUM* num =\n@@ -4397,7 +4385,7 @@ void ECDH::New(const FunctionCallbackInfo<Value>& args) {\n   MarkPopErrorOnReturn mark_pop_error_on_return;\n \n   // TODO(indutny): Support raw curves?\n-  THROW_AND_RETURN_IF_NOT_STRING(args[0], \"ECDH curve name\");\n+  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], \"ECDH curve name\");\n   node::Utf8Value curve(env->isolate(), args[0]);\n \n   int nid = OBJ_sn2nid(*curve);\n@@ -4454,7 +4442,7 @@ EC_POINT* ECDH::BufferToPoint(Environment* env,\n void ECDH::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(args[0], \"Data\");\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Data\");\n \n   ECDH* ecdh;\n   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());\n@@ -4557,7 +4545,7 @@ void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {\n   ECDH* ecdh;\n   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(args[0], \"Private key\");\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Private key\");\n \n   BIGNUM* priv = BN_bin2bn(\n       reinterpret_cast<unsigned char*>(Buffer::Data(args[0].As<Object>())),\n@@ -4611,7 +4599,7 @@ void ECDH::SetPublicKey(const FunctionCallbackInfo<Value>& args) {\n   ECDH* ecdh;\n   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(args[0], \"Public key\");\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Public key\");\n \n   MarkPopErrorOnReturn mark_pop_error_on_return;\n "
        },
        {
            "sha": "29e6276824ae6dbae2ebc2ede9c20df24f91443e",
            "filename": "src/node_dtrace.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 15,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_dtrace.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_dtrace.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_dtrace.cc?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -42,6 +42,7 @@\n #define NODE_GC_DONE(arg0, arg1, arg2)\n #endif\n \n+#include \"node_errors.h\"\n #include \"node_internals.h\"\n \n #include <string.h>\n@@ -60,7 +61,7 @@ using v8::Value;\n \n #define SLURP_STRING(obj, member, valp)                                    \\\n   if (!(obj)->IsObject()) {                                                \\\n-    return env->ThrowError(                                                \\\n+    return node::THROW_ERR_INVALID_ARG_TYPE(env,                           \\\n         \"expected object for \" #obj \" to contain string member \" #member); \\\n   }                                                                        \\\n   node::Utf8Value _##member(env->isolate(),                                \\\n@@ -70,23 +71,23 @@ using v8::Value;\n \n #define SLURP_INT(obj, member, valp)                                       \\\n   if (!(obj)->IsObject()) {                                                \\\n-    return env->ThrowError(                                                \\\n-      \"expected object for \" #obj \" to contain integer member \" #member);  \\\n+    return node::THROW_ERR_INVALID_ARG_TYPE(env,                           \\\n+        \"expected object for \" #obj \" to contain integer member \" #member);\\\n   }                                                                        \\\n   *valp = obj->Get(OneByteString(env->isolate(), #member))                 \\\n       ->Int32Value();\n \n #define SLURP_OBJECT(obj, member, valp)                                    \\\n   if (!(obj)->IsObject()) {                                                \\\n-    return env->ThrowError(                                                \\\n-      \"expected object for \" #obj \" to contain object member \" #member);   \\\n+    return node::THROW_ERR_INVALID_ARG_TYPE(env,                           \\\n+        \"expected object for \" #obj \" to contain object member \" #member); \\\n   }                                                                        \\\n   *valp = Local<Object>::Cast(obj->Get(OneByteString(env->isolate(), #member)));\n \n #define SLURP_CONNECTION(arg, conn)                                        \\\n   if (!(arg)->IsObject()) {                                                \\\n-    return env->ThrowError(                                                \\\n-      \"expected argument \" #arg \" to be a connection object\");             \\\n+    return node::THROW_ERR_INVALID_ARG_TYPE(env,                           \\\n+        \"expected argument \" #arg \" to be a connection object\");           \\\n   }                                                                        \\\n   node_dtrace_connection_t conn;                                           \\\n   Local<Object> _##conn = Local<Object>::Cast(arg);                        \\\n@@ -103,8 +104,8 @@ using v8::Value;\n \n #define SLURP_CONNECTION_HTTP_CLIENT(arg, conn)                            \\\n   if (!(arg)->IsObject()) {                                                \\\n-    return env->ThrowError(                                                \\\n-      \"expected argument \" #arg \" to be a connection object\");             \\\n+    return node::THROW_ERR_INVALID_ARG_TYPE(env,                           \\\n+        \"expected argument \" #arg \" to be a connection object\");           \\\n   }                                                                        \\\n   node_dtrace_connection_t conn;                                           \\\n   Local<Object> _##conn = Local<Object>::Cast(arg);                        \\\n@@ -115,12 +116,12 @@ using v8::Value;\n \n #define SLURP_CONNECTION_HTTP_CLIENT_RESPONSE(arg0, arg1, conn)            \\\n   if (!(arg0)->IsObject()) {                                               \\\n-    return env->ThrowError(                                                \\\n-      \"expected argument \" #arg0 \" to be a connection object\");            \\\n+    return node::THROW_ERR_INVALID_ARG_TYPE(env,                           \\\n+        \"expected argument \" #arg0 \" to be a connection object\");          \\\n   }                                                                        \\\n   if (!(arg1)->IsObject()) {                                               \\\n-    return env->ThrowError(                                                \\\n-      \"expected argument \" #arg1 \" to be a connection object\");            \\\n+    return node::THROW_ERR_INVALID_ARG_TYPE(env,                           \\\n+        \"expected argument \" #arg1 \" to be a connection object\");          \\\n   }                                                                        \\\n   node_dtrace_connection_t conn;                                           \\\n   Local<Object> _##conn = Local<Object>::Cast(arg0);                       \\\n@@ -166,8 +167,8 @@ void DTRACE_HTTP_SERVER_REQUEST(const FunctionCallbackInfo<Value>& args) {\n   SLURP_OBJECT(arg0, headers, &headers);\n \n   if (!(headers)->IsObject()) {\n-    return env->ThrowError(\n-      \"expected object for request to contain string member headers\");\n+    return node::THROW_ERR_INVALID_ARG_TYPE(env,\n+        \"expected object for request to contain string member headers\");\n   }\n \n   Local<Value> strfwdfor = headers->Get(env->x_forwarded_string());"
        },
        {
            "sha": "1ebedc2fcb5a9b28cab4cd5f0ece08797a5b0875",
            "filename": "src/node_errors.h",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_errors.h",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_errors.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_errors.h?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -18,6 +18,7 @@ namespace node {\n \n #define ERRORS_WITH_CODE(V)                                                  \\\n   V(ERR_INDEX_OUT_OF_RANGE, RangeError)                                      \\\n+  V(ERR_INVALID_ARG_TYPE, TypeError)                                         \\\n   V(ERR_MEMORY_ALLOCATION_FAILED, Error)                                     \\\n   V(ERR_STRING_TOO_LONG, Error)                                              \\\n   V(ERR_BUFFER_TOO_LARGE, Error)\n@@ -74,6 +75,20 @@ inline v8::Local<v8::Value> ERR_STRING_TOO_LONG(v8::Isolate *isolate) {\n   return ERR_STRING_TOO_LONG(isolate, message);\n }\n \n+#define THROW_AND_RETURN_IF_NOT_BUFFER(env, val, prefix)                     \\\n+  do {                                                                       \\\n+    if (!Buffer::HasInstance(val))                                           \\\n+      return node::THROW_ERR_INVALID_ARG_TYPE(env,                           \\\n+                                              prefix \" must be a buffer\");   \\\n+  } while (0)\n+\n+#define THROW_AND_RETURN_IF_NOT_STRING(env, val, prefix)                     \\\n+  do {                                                                       \\\n+    if (!val->IsString())                                                    \\\n+      return node::THROW_ERR_INVALID_ARG_TYPE(env,                           \\\n+                                              prefix \" must be a string\");   \\\n+  } while (0)\n+\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"
        },
        {
            "sha": "f491d2191d7b5589d6af4167e5ad475effec75d7",
            "filename": "src/node_i18n.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_i18n.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_i18n.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_i18n.cc?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -46,6 +46,7 @@\n \n #include \"node.h\"\n #include \"node_buffer.h\"\n+#include \"node_errors.h\"\n #include \"env-inl.h\"\n #include \"util-inl.h\"\n #include \"base_object-inl.h\"\n@@ -447,7 +448,7 @@ void Transcode(const FunctionCallbackInfo<Value>&args) {\n   UErrorCode status = U_ZERO_ERROR;\n   MaybeLocal<Object> result;\n \n-  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);\n+  CHECK(Buffer::HasInstance(args[0]));\n   SPREAD_BUFFER_ARG(args[0], ts_obj);\n   const enum encoding fromEncoding = ParseEncoding(isolate, args[1], BUFFER);\n   const enum encoding toEncoding = ParseEncoding(isolate, args[2], BUFFER);"
        },
        {
            "sha": "6ace942c29fd560fcc7bea3da06ab83179c7d9dd",
            "filename": "src/node_serdes.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 5,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_serdes.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fnode_serdes.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_serdes.cc?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -1,5 +1,6 @@\n #include \"node_internals.h\"\n #include \"node_buffer.h\"\n+#include \"node_errors.h\"\n #include \"base_object-inl.h\"\n \n namespace node {\n@@ -209,7 +210,8 @@ void SerializerContext::TransferArrayBuffer(\n   if (id.IsNothing()) return;\n \n   if (!args[1]->IsArrayBuffer())\n-    return ctx->env()->ThrowTypeError(\"arrayBuffer must be an ArrayBuffer\");\n+    return node::THROW_ERR_INVALID_ARG_TYPE(\n+        ctx->env(), \"arrayBuffer must be an ArrayBuffer\");\n \n   Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();\n   ctx->serializer_.TransferArrayBuffer(id.FromJust(), ab);\n@@ -255,7 +257,8 @@ void SerializerContext::WriteRawBytes(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n \n   if (!args[0]->IsUint8Array()) {\n-    return ctx->env()->ThrowTypeError(\"source must be a Uint8Array\");\n+    return node::THROW_ERR_INVALID_ARG_TYPE(\n+        ctx->env(), \"source must be a Uint8Array\");\n   }\n \n   ctx->serializer_.WriteRawBytes(Buffer::Data(args[0]),\n@@ -305,7 +308,8 @@ void DeserializerContext::New(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n   if (!args[0]->IsUint8Array()) {\n-    return env->ThrowTypeError(\"buffer must be a Uint8Array\");\n+    return node::THROW_ERR_INVALID_ARG_TYPE(\n+        env, \"buffer must be a Uint8Array\");\n   }\n \n   new DeserializerContext(env, args.This(), args[0]);\n@@ -349,8 +353,8 @@ void DeserializerContext::TransferArrayBuffer(\n     return;\n   }\n \n-  return ctx->env()->ThrowTypeError(\"arrayBuffer must be an ArrayBuffer or \"\n-                                    \"SharedArrayBuffer\");\n+  return node::THROW_ERR_INVALID_ARG_TYPE(\n+      ctx->env(), \"arrayBuffer must be an ArrayBuffer or SharedArrayBuffer\");\n }\n \n void DeserializerContext::GetWireFormatVersion("
        },
        {
            "sha": "801b7f4b2f45603aa85931e6d622f849fba5a53d",
            "filename": "src/stream_base.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fstream_base.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Fstream_base.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.cc?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -3,6 +3,7 @@\n \n #include \"node.h\"\n #include \"node_buffer.h\"\n+#include \"node_errors.h\"\n #include \"node_internals.h\"\n #include \"env-inl.h\"\n #include \"js_stream.h\"\n@@ -175,7 +176,7 @@ int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n   if (!args[1]->IsUint8Array()) {\n-    env->ThrowTypeError(\"Second argument must be a buffer\");\n+    node::THROW_ERR_INVALID_ARG_TYPE(env, \"Second argument must be a buffer\");\n     return 0;\n   }\n "
        },
        {
            "sha": "c8bad8171e3bc11f07ef1af19661bd75c1c91afd",
            "filename": "src/util.h",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Futil.h",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/src%2Futil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.h?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -414,12 +414,6 @@ class BufferValue : public MaybeStackBuffer<char> {\n   explicit BufferValue(v8::Isolate* isolate, v8::Local<v8::Value> value);\n };\n \n-#define THROW_AND_RETURN_UNLESS_BUFFER(env, obj)                            \\\n-  do {                                                                      \\\n-    if (!Buffer::HasInstance(obj))                                          \\\n-      return env->ThrowTypeError(\"argument should be a Buffer\");            \\\n-  } while (0)\n-\n #define SPREAD_BUFFER_ARG(val, name)                                          \\\n   CHECK((val)->IsArrayBufferView());                                          \\\n   v8::Local<v8::ArrayBufferView> name = (val).As<v8::ArrayBufferView>();      \\"
        },
        {
            "sha": "daab9c9edc12e9cf20759e07158f1db3706e1e7c",
            "filename": "test/parallel/test-buffer-alloc.js",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/test%2Fparallel%2Ftest-buffer-alloc.js",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/test%2Fparallel%2Ftest-buffer-alloc.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-alloc.js?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -935,9 +935,13 @@ Buffer.poolSize = 0;\n assert(Buffer.allocUnsafe(1).parent instanceof ArrayBuffer);\n Buffer.poolSize = ps;\n \n-// Test Buffer.copy() segfault\n-assert.throws(() => Buffer.allocUnsafe(10).copy(),\n-              /TypeError: argument should be a Buffer/);\n+common.expectsError(\n+  () => Buffer.allocUnsafe(10).copy(),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: 'argument must be a buffer'\n+  });\n \n const regErrorMsg =\n   new RegExp('The first argument must be one of type string, Buffer, ' +"
        },
        {
            "sha": "a8652dc06357ccccca94cef175c1793eed47ff1b",
            "filename": "test/parallel/test-stream-base-typechecking.js",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/test%2Fparallel%2Ftest-stream-base-typechecking.js",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/test%2Fparallel%2Ftest-stream-base-typechecking.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream-base-typechecking.js?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -1,13 +1,16 @@\n 'use strict';\n const common = require('../common');\n-const assert = require('assert');\n const net = require('net');\n \n const server = net.createServer().listen(0, common.mustCall(() => {\n   const client = net.connect(server.address().port, common.mustCall(() => {\n-    assert.throws(() => {\n+    common.expectsError(() => {\n       client.write('broken', 'buffer');\n-    }, /^TypeError: Second argument must be a buffer$/);\n+    }, {\n+      type: TypeError,\n+      code: 'ERR_INVALID_ARG_TYPE',\n+      message: 'Second argument must be a buffer'\n+    });\n     client.destroy();\n     server.close();\n   }));"
        },
        {
            "sha": "3840acc024389825bed4e0df5336377a7159035e",
            "filename": "test/parallel/test-tls-basic-validations.js",
            "status": "modified",
            "additions": 57,
            "deletions": 21,
            "changes": 78,
            "blob_url": "https://github.com/nodejs/node/blob/2c23e31c317025f6064c194f8850a474f4b6bf53/test%2Fparallel%2Ftest-tls-basic-validations.js",
            "raw_url": "https://github.com/nodejs/node/raw/2c23e31c317025f6064c194f8850a474f4b6bf53/test%2Fparallel%2Ftest-tls-basic-validations.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-basic-validations.js?ref=2c23e31c317025f6064c194f8850a474f4b6bf53",
            "patch": "@@ -7,35 +7,71 @@ if (!common.hasCrypto)\n const assert = require('assert');\n const tls = require('tls');\n \n-assert.throws(() => tls.createSecureContext({ ciphers: 1 }),\n-              /TypeError: Ciphers must be a string/);\n+common.expectsError(\n+  () => tls.createSecureContext({ ciphers: 1 }),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: 'Ciphers must be a string'\n+  });\n \n-assert.throws(() => tls.createServer({ ciphers: 1 }),\n-              /TypeError: Ciphers must be a string/);\n+common.expectsError(\n+  () => tls.createServer({ ciphers: 1 }),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: 'Ciphers must be a string'\n+  });\n \n-assert.throws(() => tls.createSecureContext({ key: 'dummykey', passphrase: 1 }),\n-              /TypeError: Pass phrase must be a string/);\n+common.expectsError(\n+  () => tls.createSecureContext({ key: 'dummykey', passphrase: 1 }),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: 'Pass phrase must be a string'\n+  });\n \n-assert.throws(() => tls.createServer({ key: 'dummykey', passphrase: 1 }),\n-              /TypeError: Pass phrase must be a string/);\n+common.expectsError(\n+  () => tls.createServer({ key: 'dummykey', passphrase: 1 }),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: 'Pass phrase must be a string'\n+  });\n \n-assert.throws(() => tls.createServer({ ecdhCurve: 1 }),\n-              /TypeError: ECDH curve name must be a string/);\n+common.expectsError(\n+  () => tls.createServer({ ecdhCurve: 1 }),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: 'ECDH curve name must be a string'\n+  });\n \n-common.expectsError(() => tls.createServer({ handshakeTimeout: 'abcd' }),\n-                    {\n-                      code: 'ERR_INVALID_ARG_TYPE',\n-                      type: TypeError,\n-                      message: 'The \"options.handshakeTimeout\" property must ' +\n-                               'be of type number. Received type string'\n-                    }\n+common.expectsError(\n+  () => tls.createServer({ handshakeTimeout: 'abcd' }),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: 'The \"options.handshakeTimeout\" property must ' +\n+              'be of type number. Received type string'\n+  }\n );\n \n-assert.throws(() => tls.createServer({ sessionTimeout: 'abcd' }),\n-              /TypeError: Session timeout must be a 32-bit integer/);\n+common.expectsError(\n+  () => tls.createServer({ sessionTimeout: 'abcd' }),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: 'Session timeout must be a 32-bit integer'\n+  });\n \n-assert.throws(() => tls.createServer({ ticketKeys: 'abcd' }),\n-              /TypeError: Ticket keys must be a buffer/);\n+common.expectsError(\n+  () => tls.createServer({ ticketKeys: 'abcd' }),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: 'Ticket keys must be a buffer'\n+  });\n \n assert.throws(() => tls.createServer({ ticketKeys: Buffer.alloc(0) }),\n               /TypeError: Ticket keys length must be 48 bytes/);"
        }
    ],
    "stats": {
        "total": 236,
        "additions": 143,
        "deletions": 93
    }
}