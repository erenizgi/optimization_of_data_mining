{
    "author": "addaleax",
    "message": "doc: fix up warning text about character devices\n\nThe text contained a number of inaccuracies:\n\n- The main thread is never blocked by a stream close.\n- There is no such thing as an EOF character on the OS level,\n  the libuv level, or the Node.js stream level.\n- These streams *do* respond to `.close()`, but pending\n  reads can delay this indefinitely.\n- Pushing a random character into the stream works only when\n  the source data can be controlled; Using the JS `.push()`\n  method is something different, and does not “unblock” any threads.\n\nRefs: https://github.com/nodejs/node/pull/21212\n\nPR-URL: https://github.com/nodejs/node/pull/22569\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>",
    "sha": "f2338ed195de0040c0e4122f891b3e64ab487a79",
    "files": [
        {
            "sha": "a1db7b5483e919041a1db33040ff5eee897f97cf",
            "filename": "doc/api/fs.md",
            "status": "modified",
            "additions": 11,
            "deletions": 10,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/f2338ed195de0040c0e4122f891b3e64ab487a79/doc%2Fapi%2Ffs.md",
            "raw_url": "https://github.com/nodejs/node/raw/f2338ed195de0040c0e4122f891b3e64ab487a79/doc%2Fapi%2Ffs.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ffs.md?ref=f2338ed195de0040c0e4122f891b3e64ab487a79",
            "patch": "@@ -1454,23 +1454,24 @@ the specified file descriptor. This means that no `'open'` event will be\n emitted. `fd` should be blocking; non-blocking `fd`s should be passed to\n [`net.Socket`][].\n \n-The blocking `fd`, if pointing to a character device (such as keyboard or\n-sound card) can potentially block the main thread on stream close. This is\n-because these devices do not produce EOF character as part of their data\n-flow cycle, and thereby exemplify endless streams. As a result, they do not\n-respond to `stream.close()`. A workaround is to close the stream first\n-using `stream.close()` and then push a random character into the stream, and\n-issue a single read. This unblocks the reader thread, leads to the completion\n-of the data flow cycle, and the actual closing of the stream.\n+If `fd` points to a character device that only supports blocking reads\n+(such as keyboard or sound card), read operations do not finish until data is\n+available. This can prevent the process from exiting and the stream from\n+closing naturally.\n \n ```js\n const fs = require('fs');\n // Create a stream from some character  device.\n const stream = fs.createReadStream('/dev/input/event0');\n setTimeout(() => {\n-  stream.close(); // This does not close the stream.\n+  stream.close(); // This may not close the stream.\n+  // Artificially marking end-of-stream, as if the underlying resource had\n+  // indicated end-of-file by itself, allows the stream to close.\n+  // This does not cancel pending read operations, and if there is such an\n+  // operation, the process may still not be able to exit successfully\n+  // until it finishes.\n   stream.push(null);\n-  stream.read(0); // Pushing a null and reading leads to close.\n+  stream.read(0);\n }, 100);\n ```\n "
        }
    ],
    "stats": {
        "total": 21,
        "additions": 11,
        "deletions": 10
    }
}