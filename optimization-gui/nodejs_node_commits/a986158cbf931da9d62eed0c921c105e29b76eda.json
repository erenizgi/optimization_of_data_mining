{
    "author": "apapirovski",
    "message": "timers: re-enter C++ less frequently\n\nPass in Timer.now() as an argument of kOnTimeout instead of always\nre-entering C++ to get it. Also don't constantly call Timer.now()\nfrom ontimeout, even when it isn't needed. Improves performance\non our pooled benchmark by upwards of 40%.\n\nPR-URL: https://github.com/nodejs/node/pull/18486\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Jeremiah Senkpiel <fishrock123@rocketmail.com>",
    "sha": "a986158cbf931da9d62eed0c921c105e29b76eda",
    "files": [
        {
            "sha": "83affee7d83e694815b43a3a8161ef28c8ab4707",
            "filename": "lib/timers.js",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/a986158cbf931da9d62eed0c921c105e29b76eda/lib%2Ftimers.js",
            "raw_url": "https://github.com/nodejs/node/raw/a986158cbf931da9d62eed0c921c105e29b76eda/lib%2Ftimers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ftimers.js?ref=a986158cbf931da9d62eed0c921c105e29b76eda",
            "patch": "@@ -223,13 +223,11 @@ function TimersList(msecs, unrefed) {\n \n // adds listOnTimeout to the C++ object prototype, as\n // V8 would not inline it otherwise.\n-TimerWrap.prototype[kOnTimeout] = function listOnTimeout() {\n+TimerWrap.prototype[kOnTimeout] = function listOnTimeout(now) {\n   var list = this._list;\n   var msecs = list.msecs;\n \n   debug('timeout callback %d', msecs);\n-\n-  var now = TimerWrap.now();\n   debug('now: %d', now);\n \n   var diff, timer;\n@@ -430,11 +428,12 @@ setTimeout[internalUtil.promisify.custom] = function(after, value) {\n exports.setTimeout = setTimeout;\n \n \n-function ontimeout(timer) {\n+function ontimeout(timer, start) {\n   var args = timer._timerArgs;\n   if (typeof timer._onTimeout !== 'function')\n     return promiseResolve(timer._onTimeout, args[0]);\n-  const start = TimerWrap.now();\n+  if (start === undefined && timer._repeat)\n+    start = TimerWrap.now();\n   if (!args)\n     timer._onTimeout();\n   else\n@@ -518,11 +517,11 @@ exports.clearInterval = function(timer) {\n };\n \n \n-function unrefdHandle() {\n+function unrefdHandle(now) {\n   try {\n     // Don't attempt to call the callback if it is not a function.\n     if (typeof this.owner._onTimeout === 'function') {\n-      ontimeout(this.owner);\n+      ontimeout(this.owner, now);\n     }\n   } finally {\n     // Make sure we clean up if the callback is no longer a function"
        },
        {
            "sha": "f1b423d3669ed57a0cc664a1e9d1d293310bf3d2",
            "filename": "src/timer_wrap.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/a986158cbf931da9d62eed0c921c105e29b76eda/src%2Ftimer_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a986158cbf931da9d62eed0c921c105e29b76eda/src%2Ftimer_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftimer_wrap.cc?ref=a986158cbf931da9d62eed0c921c105e29b76eda",
            "patch": "@@ -37,6 +37,7 @@ using v8::FunctionTemplate;\n using v8::HandleScope;\n using v8::Integer;\n using v8::Local;\n+using v8::Number;\n using v8::Object;\n using v8::String;\n using v8::Value;\n@@ -139,8 +140,10 @@ class TimerWrap : public HandleWrap {\n     HandleScope handle_scope(env->isolate());\n     Context::Scope context_scope(env->context());\n     Local<Value> ret;\n+    Local<Value> args[1];\n     do {\n-      ret = wrap->MakeCallback(kOnTimeout, 0, nullptr).ToLocalChecked();\n+      args[0] = GetNow(env);\n+      ret = wrap->MakeCallback(kOnTimeout, 1, args).ToLocalChecked();\n     } while (ret->IsUndefined() &&\n              !env->tick_info()->has_thrown() &&\n              wrap->object()->Get(env->context(),\n@@ -150,14 +153,18 @@ class TimerWrap : public HandleWrap {\n \n   static void Now(const FunctionCallbackInfo<Value>& args) {\n     Environment* env = Environment::GetCurrent(args);\n+    args.GetReturnValue().Set(GetNow(env));\n+  }\n+\n+  static Local<Value> GetNow(Environment* env) {\n     uv_update_time(env->event_loop());\n     uint64_t now = uv_now(env->event_loop());\n     CHECK(now >= env->timer_base());\n     now -= env->timer_base();\n     if (now <= 0xfffffff)\n-      args.GetReturnValue().Set(static_cast<uint32_t>(now));\n+      return Integer::New(env->isolate(), static_cast<uint32_t>(now));\n     else\n-      args.GetReturnValue().Set(static_cast<double>(now));\n+      return Number::New(env->isolate(), static_cast<double>(now));\n   }\n \n   uv_timer_t handle_;"
        }
    ],
    "stats": {
        "total": 26,
        "additions": 16,
        "deletions": 10
    }
}