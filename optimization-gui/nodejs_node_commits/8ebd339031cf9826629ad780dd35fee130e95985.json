{
    "author": "addaleax",
    "message": "worker: improve integration with native addons\n\nAllow loading add-ons from multiple Node.js instances if they are\ndeclared context-aware; in particular, this applies to N-API addons.\n\nAlso, plug a memory leak that occurred when registering N-API addons.\n\nRefs: https://github.com/nodejs/node/pull/23319\n\nPR-URL: https://github.com/nodejs/node/pull/26175\nFixes: https://github.com/nodejs/node/issues/21481\nFixes: https://github.com/nodejs/node/issues/21783\nFixes: https://github.com/nodejs/node/issues/25662\nFixes: https://github.com/nodejs/node/issues/20239\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>",
    "sha": "8ebd339031cf9826629ad780dd35fee130e95985",
    "files": [
        {
            "sha": "1c811b50c21a47a024710c9330b82c793c74d38a",
            "filename": "doc/api/addons.md",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/doc%2Fapi%2Faddons.md",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/doc%2Fapi%2Faddons.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Faddons.md?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -251,6 +251,11 @@ down. If necessary, such hooks can be removed using\n `RemoveEnvironmentCleanupHook()` before they are run, which has the same\n signature.\n \n+In order to be loaded from multiple Node.js environments,\n+such as a main thread and a Worker thread, an add-on needs to either:\n+- Be an N-API addon, or\n+- Be declared as context-aware using `NODE_MODULE_INIT()` as described above\n+\n ### Building\n \n Once the source code has been written, it must be compiled into the binary"
        },
        {
            "sha": "54bd66a6ea683e48436cab30422c177e9a2cbf8d",
            "filename": "doc/api/worker_threads.md",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/doc%2Fapi%2Fworker_threads.md",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/doc%2Fapi%2Fworker_threads.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fworker_threads.md?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -360,11 +360,8 @@ Notable differences inside a Worker environment are:\n   being invoked.\n - IPC channels from parent processes are not accessible.\n - The [`trace_events`][] module is not supported.\n-\n-Currently, the following differences also exist until they are addressed:\n-\n-- The [`inspector`][] module is not available yet.\n-- Native addons are not supported yet.\n+- Native add-ons can only be loaded from multiple threads if they fulfill\n+  [certain conditions][Addons worker support].\n \n Creating `Worker` instances inside of other `Worker`s is possible.\n \n@@ -580,7 +577,6 @@ active handle in the event system. If the worker is already `unref()`ed calling\n [`WebAssembly.Module`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module\n [`Worker`]: #worker_threads_class_worker\n [`cluster` module]: cluster.html\n-[`inspector`]: inspector.html\n [`port.on('message')`]: #worker_threads_event_message\n [`port.postMessage()`]: #worker_threads_port_postmessage_value_transferlist\n [`process.abort()`]: process.html#process_process_abort\n@@ -602,6 +598,7 @@ active handle in the event system. If the worker is already `unref()`ed calling\n [`worker.postMessage()`]: #worker_threads_worker_postmessage_value_transferlist\n [`worker.terminate()`]: #worker_threads_worker_terminate_callback\n [`worker.threadId`]: #worker_threads_worker_threadid_1\n+[Addons worker support]: addons.html#addons_worker_support\n [HTML structured clone algorithm]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n [Signals events]: process.html#process_signal_events\n [Web Workers]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API"
        },
        {
            "sha": "bfc0c12aad2e77085346c933f14cabf4e81d8ce4",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -484,7 +484,7 @@ void napi_module_register_by_symbol(v8::Local<v8::Object> exports,\n void napi_module_register(napi_module* mod) {\n   node::node_module* nm = new node::node_module {\n     -1,\n-    mod->nm_flags,\n+    mod->nm_flags | NM_F_DELETEME,\n     nullptr,\n     mod->nm_filename,\n     nullptr,"
        },
        {
            "sha": "7b87ba6bffd2e78a60e29846ae7d00f686dedc4b",
            "filename": "src/node_binding.cc",
            "status": "modified",
            "additions": 221,
            "deletions": 12,
            "changes": 233,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/src%2Fnode_binding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/src%2Fnode_binding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_binding.cc?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -2,6 +2,7 @@\n #include \"env-inl.h\"\n #include \"node_native_module.h\"\n #include \"util.h\"\n+#include <atomic>\n \n #if HAVE_OPENSSL\n #define NODE_BUILTIN_OPENSSL_MODULES(V) V(crypto) V(tls_wrap)\n@@ -96,6 +97,130 @@\n NODE_BUILTIN_MODULES(V)\n #undef V\n \n+#ifdef _AIX\n+// On AIX, dlopen() behaves differently from other operating systems, in that\n+// it returns unique values from each call, rather than identical values, when\n+// loading the same handle.\n+// We try to work around that by providing wrappers for the dlopen() family of\n+// functions, and using st_dev and st_ino for the file that is to be loaded\n+// as keys for a cache.\n+\n+namespace node {\n+namespace dlwrapper {\n+\n+struct dl_wrap {\n+  uint64_t st_dev;\n+  uint64_t st_ino;\n+  uint64_t refcount;\n+  void* real_handle;\n+\n+  struct hash {\n+    size_t operator()(const dl_wrap* wrap) const {\n+      return std::hash<uint64_t>()(wrap->st_dev) ^\n+             std::hash<uint64_t>()(wrap->st_ino);\n+    }\n+  };\n+\n+  struct equal {\n+    bool operator()(const dl_wrap* a,\n+                    const dl_wrap* b) const {\n+      return a->st_dev == b->st_dev && a->st_ino == b->st_ino;\n+    }\n+  };\n+};\n+\n+static Mutex dlhandles_mutex;\n+static std::unordered_set<dl_wrap*, dl_wrap::hash, dl_wrap::equal>\n+    dlhandles;\n+static thread_local std::string dlerror_storage;\n+\n+char* wrapped_dlerror() {\n+  return &dlerror_storage[0];\n+}\n+\n+void* wrapped_dlopen(const char* filename, int flags) {\n+  CHECK_NOT_NULL(filename);  // This deviates from the 'real' dlopen().\n+  Mutex::ScopedLock lock(dlhandles_mutex);\n+\n+  uv_fs_t req;\n+  OnScopeLeave cleanup([&]() { uv_fs_req_cleanup(&req); });\n+  int rc = uv_fs_stat(nullptr, &req, filename, nullptr);\n+\n+  if (rc != 0) {\n+    dlerror_storage = uv_strerror(rc);\n+    return nullptr;\n+  }\n+\n+  dl_wrap search = {\n+    req.statbuf.st_dev,\n+    req.statbuf.st_ino,\n+    0, nullptr\n+  };\n+\n+  auto it = dlhandles.find(&search);\n+  if (it != dlhandles.end()) {\n+    (*it)->refcount++;\n+    return *it;\n+  }\n+\n+  void* real_handle = dlopen(filename, flags);\n+  if (real_handle == nullptr) {\n+    dlerror_storage = dlerror();\n+    return nullptr;\n+  }\n+  dl_wrap* wrap = new dl_wrap();\n+  wrap->st_dev = req.statbuf.st_dev;\n+  wrap->st_ino = req.statbuf.st_ino;\n+  wrap->refcount = 1;\n+  wrap->real_handle = real_handle;\n+  dlhandles.insert(wrap);\n+  return wrap;\n+}\n+\n+int wrapped_dlclose(void* handle) {\n+  Mutex::ScopedLock lock(dlhandles_mutex);\n+  dl_wrap* wrap = static_cast<dl_wrap*>(handle);\n+  int ret = 0;\n+  CHECK_GE(wrap->refcount, 1);\n+  if (--wrap->refcount == 0) {\n+    ret = dlclose(wrap->real_handle);\n+    if (ret != 0) dlerror_storage = dlerror();\n+    dlhandles.erase(wrap);\n+    delete wrap;\n+  }\n+  return ret;\n+}\n+\n+void* wrapped_dlsym(void* handle, const char* symbol) {\n+  if (handle == RTLD_DEFAULT || handle == RTLD_NEXT)\n+    return dlsym(handle, symbol);\n+  dl_wrap* wrap = static_cast<dl_wrap*>(handle);\n+  return dlsym(wrap->real_handle, symbol);\n+}\n+\n+#define dlopen node::dlwrapper::wrapped_dlopen\n+#define dlerror node::dlwrapper::wrapped_dlerror\n+#define dlclose node::dlwrapper::wrapped_dlclose\n+#define dlsym node::dlwrapper::wrapped_dlsym\n+\n+}  // namespace dlwrapper\n+}  // namespace node\n+\n+#endif  // _AIX\n+\n+#ifdef __linux__\n+static bool libc_may_be_musl() {\n+  static std::atomic_bool retval;  // Cache the return value.\n+  static std::atomic_bool has_cached_retval { false };\n+  if (has_cached_retval) return retval;\n+  retval = dlsym(RTLD_DEFAULT, \"gnu_get_libc_version\") == nullptr;\n+  has_cached_retval = true;\n+  return retval;\n+}\n+#else  // __linux__\n+static bool libc_may_be_musl() { return false; }\n+#endif  // __linux__\n+\n namespace node {\n \n using v8::Context;\n@@ -110,7 +235,6 @@ using v8::Value;\n // Globals per process\n static node_module* modlist_internal;\n static node_module* modlist_linked;\n-static node_module* modlist_addon;\n static uv_once_t init_modpending_once = UV_ONCE_INIT;\n static uv_key_t thread_local_modpending;\n \n@@ -136,6 +260,57 @@ extern \"C\" void node_module_register(void* m) {\n \n namespace binding {\n \n+static struct global_handle_map_t {\n+ public:\n+  void set(void* handle, node_module* mod) {\n+    CHECK_NE(handle, nullptr);\n+    Mutex::ScopedLock lock(mutex_);\n+\n+    map_[handle].module = mod;\n+    // We need to store this flag internally to avoid a chicken-and-egg problem\n+    // during cleanup. By the time we actually use the flag's value,\n+    // the shared object has been unloaded, and its memory would be gone,\n+    // making it impossible to access fields of `mod` --\n+    // unless `mod` *is* dynamically allocated, but we cannot know that\n+    // without checking the flag.\n+    map_[handle].wants_delete_module = mod->nm_flags & NM_F_DELETEME;\n+    map_[handle].refcount++;\n+  }\n+\n+  node_module* get_and_increase_refcount(void* handle) {\n+    CHECK_NE(handle, nullptr);\n+    Mutex::ScopedLock lock(mutex_);\n+\n+    auto it = map_.find(handle);\n+    if (it == map_.end()) return nullptr;\n+    it->second.refcount++;\n+    return it->second.module;\n+  }\n+\n+  void erase(void* handle) {\n+    CHECK_NE(handle, nullptr);\n+    Mutex::ScopedLock lock(mutex_);\n+\n+    auto it = map_.find(handle);\n+    if (it == map_.end()) return;\n+    CHECK_GE(it->second.refcount, 1);\n+    if (--it->second.refcount == 0) {\n+      if (it->second.wants_delete_module)\n+        delete it->second.module;\n+      map_.erase(handle);\n+    }\n+  }\n+\n+ private:\n+  Mutex mutex_;\n+  struct Entry {\n+    unsigned int refcount;\n+    bool wants_delete_module;\n+    node_module* module;\n+  };\n+  std::unordered_map<void*, Entry> map_;\n+} global_handle_map;\n+\n DLib::DLib(const char* filename, int flags)\n     : filename_(filename), flags_(flags), handle_(nullptr) {}\n \n@@ -149,7 +324,21 @@ bool DLib::Open() {\n \n void DLib::Close() {\n   if (handle_ == nullptr) return;\n-  dlclose(handle_);\n+\n+  if (libc_may_be_musl()) {\n+    // musl libc implements dlclose() as a no-op which returns 0.\n+    // As a consequence, trying to re-load a previously closed addon at a later\n+    // point will not call its static constructors, which Node.js uses.\n+    // Therefore, when we may be using musl libc, we assume that the shared\n+    // object exists indefinitely and keep it in our handle map.\n+    return;\n+  }\n+\n+  int err = dlclose(handle_);\n+  if (err == 0) {\n+    if (has_entry_in_global_handle_map_)\n+      global_handle_map.erase(handle_);\n+  }\n   handle_ = nullptr;\n }\n \n@@ -170,6 +359,8 @@ bool DLib::Open() {\n \n void DLib::Close() {\n   if (handle_ == nullptr) return;\n+  if (has_entry_in_global_handle_map_)\n+    global_handle_map.erase(handle_);\n   uv_dlclose(&lib_);\n   handle_ = nullptr;\n }\n@@ -181,6 +372,16 @@ void* DLib::GetSymbolAddress(const char* name) {\n }\n #endif  // !__POSIX__\n \n+void DLib::SaveInGlobalHandleMap(node_module* mp) {\n+  has_entry_in_global_handle_map_ = true;\n+  global_handle_map.set(handle_, mp);\n+}\n+\n+node_module* DLib::GetSavedModuleFromGlobalHandleMap() {\n+  has_entry_in_global_handle_map_ = true;\n+  return global_handle_map.get_and_increase_refcount(handle_);\n+}\n+\n using InitializerCallback = void (*)(Local<Object> exports,\n                                      Local<Value> module,\n                                      Local<Context> context);\n@@ -235,12 +436,15 @@ void DLOpen(const FunctionCallbackInfo<Value>& args) {\n \n   node::Utf8Value filename(env->isolate(), args[1]);  // Cast\n   env->TryLoadAddon(*filename, flags, [&](DLib* dlib) {\n+    static Mutex dlib_load_mutex;\n+    Mutex::ScopedLock lock(dlib_load_mutex);\n+\n     const bool is_opened = dlib->Open();\n \n     // Objects containing v14 or later modules will have registered themselves\n     // on the pending list.  Activate all of them now.  At present, only one\n     // module per object is supported.\n-    node_module* const mp =\n+    node_module* mp =\n         static_cast<node_module*>(uv_key_get(&thread_local_modpending));\n     uv_key_set(&thread_local_modpending, nullptr);\n \n@@ -257,17 +461,24 @@ void DLOpen(const FunctionCallbackInfo<Value>& args) {\n       return false;\n     }\n \n-    if (mp == nullptr) {\n+    if (mp != nullptr) {\n+      mp->nm_dso_handle = dlib->handle_;\n+      dlib->SaveInGlobalHandleMap(mp);\n+    } else {\n       if (auto callback = GetInitializerCallback(dlib)) {\n         callback(exports, module, context);\n+        return true;\n       } else if (auto napi_callback = GetNapiInitializerCallback(dlib)) {\n         napi_module_register_by_symbol(exports, module, context, napi_callback);\n+        return true;\n       } else {\n-        dlib->Close();\n-        env->ThrowError(\"Module did not self-register.\");\n-        return false;\n+        mp = dlib->GetSavedModuleFromGlobalHandleMap();\n+        if (mp == nullptr || mp->nm_context_register_func == nullptr) {\n+          dlib->Close();\n+          env->ThrowError(\"Module did not self-register.\");\n+          return false;\n+        }\n       }\n-      return true;\n     }\n \n     // -1 is used for N-API modules\n@@ -300,10 +511,8 @@ void DLOpen(const FunctionCallbackInfo<Value>& args) {\n     }\n     CHECK_EQ(mp->nm_flags & NM_F_BUILTIN, 0);\n \n-    mp->nm_dso_handle = dlib->handle_;\n-    mp->nm_link = modlist_addon;\n-    modlist_addon = mp;\n-\n+    // Do not keep the lock while running userland addon loading code.\n+    Mutex::ScopedUnlock unlock(lock);\n     if (mp->nm_context_register_func != nullptr) {\n       mp->nm_context_register_func(exports, module, context, mp->nm_priv);\n     } else if (mp->nm_register_func != nullptr) {"
        },
        {
            "sha": "fcd7f34ac6a57aeed3d2a0bff5b4b7226faf00a5",
            "filename": "src/node_binding.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/src%2Fnode_binding.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/src%2Fnode_binding.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_binding.h?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -18,6 +18,7 @@ enum {\n   NM_F_BUILTIN = 1 << 0,  // Unused.\n   NM_F_LINKED = 1 << 1,\n   NM_F_INTERNAL = 1 << 2,\n+  NM_F_DELETEME = 1 << 3,\n };\n \n #define NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags)           \\\n@@ -62,6 +63,8 @@ class DLib {\n   bool Open();\n   void Close();\n   void* GetSymbolAddress(const char* name);\n+  void SaveInGlobalHandleMap(node_module* mp);\n+  node_module* GetSavedModuleFromGlobalHandleMap();\n \n   const std::string filename_;\n   const int flags_;\n@@ -70,6 +73,7 @@ class DLib {\n #ifndef __POSIX__\n   uv_lib_t lib_;\n #endif\n+  bool has_entry_in_global_handle_map_ = false;\n \n  private:\n   DISALLOW_COPY_AND_ASSIGN(DLib);"
        },
        {
            "sha": "feba6aa5eb02029ac5cf81e55f6ea2b4339398d9",
            "filename": "test/addons/dlopen-ping-pong/test-worker.js",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/test%2Faddons%2Fdlopen-ping-pong%2Ftest-worker.js",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/test%2Faddons%2Fdlopen-ping-pong%2Ftest-worker.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons%2Fdlopen-ping-pong%2Ftest-worker.js?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -0,0 +1,20 @@\n+'use strict';\n+const common = require('../../common');\n+\n+if (common.isWindows)\n+  common.skip('dlopen global symbol loading is not supported on this os.');\n+\n+const assert = require('assert');\n+const { Worker } = require('worker_threads');\n+\n+// Check that modules that are not declared as context-aware cannot be re-loaded\n+// from workers.\n+\n+const bindingPath = require.resolve(`./build/${common.buildType}/binding`);\n+require(bindingPath);\n+\n+new Worker(`require(${JSON.stringify(bindingPath)})`, { eval: true })\n+  .on('error', common.mustCall((err) => {\n+    assert.strictEqual(err.constructor, Error);\n+    assert.strictEqual(err.message, 'Module did not self-register.');\n+  }));"
        },
        {
            "sha": "01c857c43ebcfc622e2568066bf05d2032a93760",
            "filename": "test/addons/worker-addon/binding.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/test%2Faddons%2Fworker-addon%2Fbinding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/test%2Faddons%2Fworker-addon%2Fbinding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons%2Fworker-addon%2Fbinding.cc?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -21,7 +21,7 @@ struct statically_allocated {\n   }\n   ~statically_allocated() {\n     assert(count == 0);\n-    printf(\"dtor\");\n+    printf(\"dtor \");\n   }\n } var;\n "
        },
        {
            "sha": "ef158e98b144694701ccdfbc2f2e7ad56f2b4a45",
            "filename": "test/addons/worker-addon/test.js",
            "status": "modified",
            "additions": 51,
            "deletions": 9,
            "changes": 60,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/test%2Faddons%2Fworker-addon%2Ftest.js",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/test%2Faddons%2Fworker-addon%2Ftest.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons%2Fworker-addon%2Ftest.js?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -1,3 +1,4 @@\n+// Flags: --experimental-report\n 'use strict';\n const common = require('../../common');\n const assert = require('assert');\n@@ -6,21 +7,62 @@ const path = require('path');\n const { Worker } = require('worker_threads');\n const binding = path.resolve(__dirname, `./build/${common.buildType}/binding`);\n \n-if (process.argv[2] === 'worker') {\n-  new Worker(`require(${JSON.stringify(binding)});`, { eval: true });\n-  return;\n-} else if (process.argv[2] === 'main-thread') {\n-  process.env.addExtraItemToEventLoop = 'yes';\n-  require(binding);\n-  return;\n+switch (process.argv[2]) {\n+  case 'both':\n+    require(binding);\n+    // fallthrough\n+  case 'worker-twice':\n+  case 'worker':\n+    const worker = new Worker(`require(${JSON.stringify(binding)});`, {\n+      eval: true\n+    });\n+    if (process.argv[2] === 'worker-twice') {\n+      worker.on('exit', common.mustCall(() => {\n+        new Worker(`require(${JSON.stringify(binding)});`, {\n+          eval: true\n+        });\n+      }));\n+    }\n+    return;\n+  case 'main-thread':\n+    process.env.addExtraItemToEventLoop = 'yes';\n+    require(binding);\n+    return;\n }\n \n-for (const test of ['worker', 'main-thread']) {\n+// Use process.report to figure out if we might be running under musl libc.\n+const glibc = JSON.parse(process.report.getReport()).header.glibcVersionRuntime;\n+assert(typeof glibc === 'string' || glibc === undefined, glibc);\n+\n+const libcMayBeMusl = common.isLinux && glibc === undefined;\n+\n+for (const { test, expected } of [\n+  { test: 'worker', expected: [ 'ctor cleanup dtor ' ] },\n+  { test: 'main-thread', expected: [ 'ctor cleanup dtor ' ] },\n+  // We always only have 1 instance of the shared object in memory, so\n+  // 1 ctor and 1 dtor call. If we attach the module to 2 Environments,\n+  // we expect 2 cleanup calls, otherwise one.\n+  { test: 'both', expected: [ 'ctor cleanup cleanup dtor ' ] },\n+  {\n+    test: 'worker-twice',\n+    // In this case, we load and unload an addon, then load and unload again.\n+    // musl doesn't support unloading, so the output may be missing\n+    // a dtor + ctor pair.\n+    expected: [\n+      'ctor cleanup dtor ctor cleanup dtor '\n+    ].concat(libcMayBeMusl ? [\n+      'ctor cleanup cleanup dtor ',\n+    ] : [])\n+  },\n+]) {\n+  console.log('spawning test', test);\n   const proc = child_process.spawnSync(process.execPath, [\n     __filename,\n     test\n   ]);\n+  process.stderr.write(proc.stderr.toString());\n   assert.strictEqual(proc.stderr.toString(), '');\n-  assert.strictEqual(proc.stdout.toString(), 'ctor cleanup dtor');\n+  assert(expected.includes(proc.stdout.toString()),\n+         `${proc.stdout.toString()} is not included in ${expected}`);\n   assert.strictEqual(proc.status, 0);\n }"
        },
        {
            "sha": "dd28e26a561295a9441fa884b67221163d1ce265",
            "filename": "test/node-api/1_hello_world/test.js",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/test%2Fnode-api%2F1_hello_world%2Ftest.js",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/test%2Fnode-api%2F1_hello_world%2Ftest.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fnode-api%2F1_hello_world%2Ftest.js?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -1,6 +1,8 @@\n 'use strict';\n const common = require('../../common');\n const assert = require('assert');\n+const { Worker } = require('worker_threads');\n+\n const bindingPath = require.resolve(`./build/${common.buildType}/binding`);\n const binding = require(bindingPath);\n assert.strictEqual(binding.hello(), 'world');\n@@ -11,3 +13,10 @@ delete require.cache[bindingPath];\n const rebinding = require(bindingPath);\n assert.strictEqual(rebinding.hello(), 'world');\n assert.notStrictEqual(binding.hello, rebinding.hello);\n+\n+// Test that workers can load addons declared using NAPI_MODULE_INIT().\n+new Worker(`\n+const { parentPort } = require('worker_threads');\n+const msg = require(${JSON.stringify(bindingPath)}).hello();\n+parentPort.postMessage(msg)`, { eval: true })\n+  .on('message', common.mustCall((msg) => assert.strictEqual(msg, 'world')));"
        },
        {
            "sha": "7c7224c073dda36ea577b95b2db62320c30fcc07",
            "filename": "test/node-api/test_worker_terminate/test.js",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/test%2Fnode-api%2Ftest_worker_terminate%2Ftest.js",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/test%2Fnode-api%2Ftest_worker_terminate%2Ftest.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fnode-api%2Ftest_worker_terminate%2Ftest.js?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -4,6 +4,11 @@ const assert = require('assert');\n const { Worker, isMainThread, workerData } = require('worker_threads');\n \n if (isMainThread) {\n+  // Load the addon in the main thread first.\n+  // This checks that N-API addons can be loaded from multiple contexts\n+  // when they are not loaded through NAPI_MODULE().\n+  require(`./build/${common.buildType}/test_worker_terminate`);\n+\n   const counter = new Int32Array(new SharedArrayBuffer(4));\n   const worker = new Worker(__filename, { workerData: { counter } });\n   worker.on('exit', common.mustCall(() => {"
        },
        {
            "sha": "517cae4203732343a7ea8c6a4023137c9c6a3c64",
            "filename": "test/node-api/test_worker_terminate/test_worker_terminate.c",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8ebd339031cf9826629ad780dd35fee130e95985/test%2Fnode-api%2Ftest_worker_terminate%2Ftest_worker_terminate.c",
            "raw_url": "https://github.com/nodejs/node/raw/8ebd339031cf9826629ad780dd35fee130e95985/test%2Fnode-api%2Ftest_worker_terminate%2Ftest_worker_terminate.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fnode-api%2Ftest_worker_terminate%2Ftest_worker_terminate.c?ref=8ebd339031cf9826629ad780dd35fee130e95985",
            "patch": "@@ -36,4 +36,6 @@ napi_value Init(napi_env env, napi_value exports) {\n   return exports;\n }\n \n+// Do not start using NAPI_MODULE_INIT() here, so that we can test\n+// compatibility of Workers with NAPI_MODULE().\n NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)"
        }
    ],
    "stats": {
        "total": 351,
        "additions": 322,
        "deletions": 29
    }
}