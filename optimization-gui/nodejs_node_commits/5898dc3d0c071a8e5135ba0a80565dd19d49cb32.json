{
    "author": "addaleax",
    "message": "src: simplify handles for libuv streams\n\nInstead of passing along the handle object, just set it as a\nproperty on the stream handle object and let the read handler\ngrab it from there.\n\nPR-URL: https://github.com/nodejs/node/pull/18334\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "5898dc3d0c071a8e5135ba0a80565dd19d49cb32",
    "files": [
        {
            "sha": "2bade01f95f209cacbf3e33feeb64bf81e09afda",
            "filename": "lib/internal/child_process.js",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/lib%2Finternal%2Fchild_process.js",
            "raw_url": "https://github.com/nodejs/node/raw/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/lib%2Finternal%2Fchild_process.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fchild_process.js?ref=5898dc3d0c071a8e5135ba0a80565dd19d49cb32",
            "patch": "@@ -465,7 +465,10 @@ function setupChannel(target, channel) {\n   var jsonBuffer = '';\n   var pendingHandle = null;\n   channel.buffering = false;\n-  channel.onread = function(nread, pool, recvHandle) {\n+  channel.pendingHandle = null;\n+  channel.onread = function(nread, pool) {\n+    const recvHandle = channel.pendingHandle;\n+    channel.pendingHandle = null;\n     // TODO(bnoordhuis) Check that nread > 0.\n     if (pool) {\n       if (recvHandle)"
        },
        {
            "sha": "734261359565c4035f5dea6644e4c62315e34950",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=5898dc3d0c071a8e5135ba0a80565dd19d49cb32",
            "patch": "@@ -210,6 +210,7 @@ class ModuleWrap;\n   V(owner_string, \"owner\")                                                    \\\n   V(parse_error_string, \"Parse Error\")                                        \\\n   V(path_string, \"path\")                                                      \\\n+  V(pending_handle_string, \"pendingHandle\")                                   \\\n   V(pbkdf2_error_string, \"PBKDF2 Error\")                                      \\\n   V(pid_string, \"pid\")                                                        \\\n   V(pipe_string, \"pipe\")                                                      \\"
        },
        {
            "sha": "76922c1d8af77d42fca4f3f5a95c3c61b789153d",
            "filename": "src/stream_base-inl.h",
            "status": "modified",
            "additions": 3,
            "deletions": 7,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_base-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_base-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base-inl.h?ref=5898dc3d0c071a8e5135ba0a80565dd19d49cb32",
            "patch": "@@ -33,9 +33,7 @@ inline StreamListener::~StreamListener() {\n \n inline void StreamListener::PassReadErrorToPreviousListener(ssize_t nread) {\n   CHECK_NE(previous_listener_, nullptr);\n-  previous_listener_->OnStreamRead(nread,\n-                                   uv_buf_init(nullptr, 0),\n-                                   UV_UNKNOWN_HANDLE);\n+  previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));\n }\n \n \n@@ -85,12 +83,10 @@ inline uv_buf_t StreamResource::EmitAlloc(size_t suggested_size) {\n   return listener_->OnStreamAlloc(suggested_size);\n }\n \n-inline void StreamResource::EmitRead(ssize_t nread,\n-                                     const uv_buf_t& buf,\n-                                     uv_handle_type pending) {\n+inline void StreamResource::EmitRead(ssize_t nread, const uv_buf_t& buf) {\n   if (nread > 0)\n     bytes_read_ += static_cast<uint64_t>(nread);\n-  listener_->OnStreamRead(nread, buf, pending);\n+  listener_->OnStreamRead(nread, buf);\n }\n \n inline void StreamResource::EmitAfterWrite(WriteWrap* w, int status) {"
        },
        {
            "sha": "8bdcebe88ab19f58150deddecd96bf28e90c48fc",
            "filename": "src/stream_base.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 21,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_base.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_base.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.cc?ref=5898dc3d0c071a8e5135ba0a80565dd19d49cb32",
            "patch": "@@ -437,23 +437,17 @@ void StreamBase::AfterWrite(WriteWrap* req_wrap, int status) {\n }\n \n \n-void StreamBase::CallJSOnreadMethod(ssize_t nread,\n-                                    Local<Object> buf,\n-                                    Local<Object> handle) {\n+void StreamBase::CallJSOnreadMethod(ssize_t nread, Local<Object> buf) {\n   Environment* env = env_;\n \n   Local<Value> argv[] = {\n     Integer::New(env->isolate(), nread),\n-    buf,\n-    handle\n+    buf\n   };\n \n   if (argv[1].IsEmpty())\n     argv[1] = Undefined(env->isolate());\n \n-  if (argv[2].IsEmpty())\n-    argv[2] = Undefined(env->isolate());\n-\n   AsyncWrap* wrap = GetAsyncWrap();\n   CHECK_NE(wrap, nullptr);\n   wrap->MakeCallback(env->onread_string(), arraysize(argv), argv);\n@@ -495,19 +489,6 @@ uv_buf_t StreamListener::OnStreamAlloc(size_t suggested_size) {\n   return uv_buf_init(Malloc(suggested_size), suggested_size);\n }\n \n-void StreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n-  // This cannot be virtual because it is just as valid to override the other\n-  // OnStreamRead() callback.\n-  CHECK(0 && \"OnStreamRead() needs to be implemented\");\n-}\n-\n-void StreamListener::OnStreamRead(ssize_t nread,\n-                                  const uv_buf_t& buf,\n-                                  uv_handle_type pending) {\n-  CHECK_EQ(pending, UV_UNKNOWN_HANDLE);\n-  OnStreamRead(nread, buf);\n-}\n-\n \n void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n   CHECK_NE(stream_, nullptr);"
        },
        {
            "sha": "f18b6bda0a08a44a3d14545eecba4920aad835ef",
            "filename": "src/stream_base.h",
            "status": "modified",
            "additions": 2,
            "deletions": 16,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_base.h",
            "raw_url": "https://github.com/nodejs/node/raw/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_base.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.h?ref=5898dc3d0c071a8e5135ba0a80565dd19d49cb32",
            "patch": "@@ -150,17 +150,8 @@ class StreamListener {\n   // with base nullpptr in case of an error.\n   // `nread` is the number of read bytes (which is at most the buffer length),\n   // or, if negative, a libuv error code.\n-  // The variant with a `uv_handle_type` argument is used by libuv-backed\n-  // streams for handle transfers (e.g. passing net.Socket instances between\n-  // cluster workers). For all other streams, overriding the simple variant\n-  // should be sufficient.\n-  // By default, the second variant crashes if `pending` is set and otherwise\n-  // calls the simple variant.\n   virtual void OnStreamRead(ssize_t nread,\n                             const uv_buf_t& buf) = 0;\n-  virtual void OnStreamRead(ssize_t nread,\n-                            const uv_buf_t& buf,\n-                            uv_handle_type pending);\n \n   // This is called once a Write has finished. `status` may be 0 or,\n   // if negative, a libuv error code.\n@@ -229,9 +220,7 @@ class StreamResource {\n   uv_buf_t EmitAlloc(size_t suggested_size);\n   // Call the current listener's OnStreamRead() method and update the\n   // stream's read byte counter.\n-  void EmitRead(ssize_t nread,\n-                const uv_buf_t& buf = uv_buf_init(nullptr, 0),\n-                uv_handle_type pending = UV_UNKNOWN_HANDLE);\n+  void EmitRead(ssize_t nread, const uv_buf_t& buf = uv_buf_init(nullptr, 0));\n   // Call the current listener's OnStreamAfterWrite() method.\n   void EmitAfterWrite(WriteWrap* w, int status);\n \n@@ -260,10 +249,7 @@ class StreamBase : public StreamResource {\n   virtual bool IsIPCPipe();\n   virtual int GetFD();\n \n-  void CallJSOnreadMethod(\n-      ssize_t nread,\n-      v8::Local<v8::Object> buf,\n-      v8::Local<v8::Object> handle = v8::Local<v8::Object>());\n+  void CallJSOnreadMethod(ssize_t nread, v8::Local<v8::Object> buf);\n \n   // These are called by the respective {Write,Shutdown}Wrap class.\n   virtual void AfterShutdown(ShutdownWrap* req, int status);"
        },
        {
            "sha": "bc10cf80e828f1471829feee9ce512ee64fa7a9b",
            "filename": "src/stream_wrap.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 60,
            "changes": 98,
            "blob_url": "https://github.com/nodejs/node/blob/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.cc?ref=5898dc3d0c071a8e5135ba0a80565dd19d49cb32",
            "patch": "@@ -93,7 +93,6 @@ LibuvStreamWrap::LibuvStreamWrap(Environment* env,\n                  provider),\n       StreamBase(env),\n       stream_(stream) {\n-  PushStreamListener(this);\n }\n \n \n@@ -146,7 +145,13 @@ bool LibuvStreamWrap::IsIPCPipe() {\n \n \n int LibuvStreamWrap::ReadStart() {\n-  return uv_read_start(stream(), OnAlloc, OnRead);\n+  return uv_read_start(stream(), [](uv_handle_t* handle,\n+                                    size_t suggested_size,\n+                                    uv_buf_t* buf) {\n+    static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf);\n+  }, [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {\n+    static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf);\n+  });\n }\n \n \n@@ -155,16 +160,11 @@ int LibuvStreamWrap::ReadStop() {\n }\n \n \n-void LibuvStreamWrap::OnAlloc(uv_handle_t* handle,\n-                              size_t suggested_size,\n-                              uv_buf_t* buf) {\n-  LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(handle->data);\n-  HandleScope scope(wrap->env()->isolate());\n-  Context::Scope context_scope(wrap->env()->context());\n-\n-  CHECK_EQ(wrap->stream(), reinterpret_cast<uv_stream_t*>(handle));\n+void LibuvStreamWrap::OnUvAlloc(size_t suggested_size, uv_buf_t* buf) {\n+  HandleScope scope(env()->isolate());\n+  Context::Scope context_scope(env()->context());\n \n-  *buf = wrap->EmitAlloc(suggested_size);\n+  *buf = EmitAlloc(suggested_size);\n }\n \n \n@@ -190,64 +190,47 @@ static Local<Object> AcceptHandle(Environment* env, LibuvStreamWrap* parent) {\n }\n \n \n-void LibuvStreamWrap::OnStreamRead(ssize_t nread,\n-                                   const uv_buf_t& buf,\n-                                   uv_handle_type pending) {\n-  HandleScope handle_scope(env()->isolate());\n+void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) {\n+  HandleScope scope(env()->isolate());\n   Context::Scope context_scope(env()->context());\n-\n-  if (nread <= 0) {\n-    free(buf.base);\n-    if (nread < 0)\n-      CallJSOnreadMethod(nread, Local<Object>());\n-    return;\n-  }\n-\n-  CHECK_LE(static_cast<size_t>(nread), buf.len);\n-\n-  Local<Object> pending_obj;\n-\n-  if (pending == UV_TCP) {\n-    pending_obj = AcceptHandle<TCPWrap, uv_tcp_t>(env(), this);\n-  } else if (pending == UV_NAMED_PIPE) {\n-    pending_obj = AcceptHandle<PipeWrap, uv_pipe_t>(env(), this);\n-  } else if (pending == UV_UDP) {\n-    pending_obj = AcceptHandle<UDPWrap, uv_udp_t>(env(), this);\n-  } else {\n-    CHECK_EQ(pending, UV_UNKNOWN_HANDLE);\n-  }\n-\n-  Local<Object> obj = Buffer::New(env(), buf.base, nread).ToLocalChecked();\n-  CallJSOnreadMethod(nread, obj, pending_obj);\n-}\n-\n-\n-void LibuvStreamWrap::OnRead(uv_stream_t* handle,\n-                             ssize_t nread,\n-                             const uv_buf_t* buf) {\n-  LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(handle->data);\n-  HandleScope scope(wrap->env()->isolate());\n-  Context::Scope context_scope(wrap->env()->context());\n   uv_handle_type type = UV_UNKNOWN_HANDLE;\n \n-  if (wrap->is_named_pipe_ipc() &&\n-      uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(handle)) > 0) {\n-    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(handle));\n+  if (is_named_pipe_ipc() &&\n+      uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) {\n+    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));\n   }\n \n   // We should not be getting this callback if someone as already called\n   // uv_close() on the handle.\n-  CHECK_EQ(wrap->persistent().IsEmpty(), false);\n+  CHECK_EQ(persistent().IsEmpty(), false);\n \n   if (nread > 0) {\n-    if (wrap->is_tcp()) {\n+    if (is_tcp()) {\n       NODE_COUNT_NET_BYTES_RECV(nread);\n-    } else if (wrap->is_named_pipe()) {\n+    } else if (is_named_pipe()) {\n       NODE_COUNT_PIPE_BYTES_RECV(nread);\n     }\n+\n+    Local<Object> pending_obj;\n+\n+    if (type == UV_TCP) {\n+      pending_obj = AcceptHandle<TCPWrap, uv_tcp_t>(env(), this);\n+    } else if (type == UV_NAMED_PIPE) {\n+      pending_obj = AcceptHandle<PipeWrap, uv_pipe_t>(env(), this);\n+    } else if (type == UV_UDP) {\n+      pending_obj = AcceptHandle<UDPWrap, uv_udp_t>(env(), this);\n+    } else {\n+      CHECK_EQ(type, UV_UNKNOWN_HANDLE);\n+    }\n+\n+    if (!pending_obj.IsEmpty()) {\n+      object()->Set(env()->context(),\n+                    env()->pending_handle_string(),\n+                    pending_obj).FromJust();\n+    }\n   }\n \n-  wrap->EmitRead(nread, *buf, type);\n+  EmitRead(nread, *buf);\n }\n \n \n@@ -373,11 +356,6 @@ void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) {\n   req_wrap->Done(status);\n }\n \n-\n-void LibuvStreamWrap::AfterWrite(WriteWrap* w, int status) {\n-  StreamBase::AfterWrite(w, status);\n-}\n-\n }  // namespace node\n \n NODE_BUILTIN_MODULE_CONTEXT_AWARE(stream_wrap,"
        },
        {
            "sha": "e5ad25b91e6feabc0c191db1fd6a59900d6685a8",
            "filename": "src/stream_wrap.h",
            "status": "modified",
            "additions": 3,
            "deletions": 23,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/5898dc3d0c071a8e5135ba0a80565dd19d49cb32/src%2Fstream_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.h?ref=5898dc3d0c071a8e5135ba0a80565dd19d49cb32",
            "patch": "@@ -33,9 +33,7 @@\n \n namespace node {\n \n-class LibuvStreamWrap : public HandleWrap,\n-                        public StreamListener,\n-                        public StreamBase {\n+class LibuvStreamWrap : public HandleWrap, public StreamBase {\n  public:\n   static void Initialize(v8::Local<v8::Object> target,\n                          v8::Local<v8::Value> unused,\n@@ -93,30 +91,12 @@ class LibuvStreamWrap : public HandleWrap,\n   static void SetBlocking(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n   // Callbacks for libuv\n-  static void OnAlloc(uv_handle_t* handle,\n-                      size_t suggested_size,\n-                      uv_buf_t* buf);\n+  void OnUvAlloc(size_t suggested_size, uv_buf_t* buf);\n+  void OnUvRead(ssize_t nread, const uv_buf_t* buf);\n \n-  static void OnRead(uv_stream_t* handle,\n-                     ssize_t nread,\n-                     const uv_buf_t* buf);\n   static void AfterUvWrite(uv_write_t* req, int status);\n   static void AfterUvShutdown(uv_shutdown_t* req, int status);\n \n-  // Resource interface implementation\n-  void OnStreamRead(ssize_t nread,\n-                    const uv_buf_t& buf) override {\n-    CHECK(0 && \"must not be called\");\n-  }\n-  void OnStreamRead(ssize_t nread,\n-                    const uv_buf_t& buf,\n-                    uv_handle_type pending) override;\n-  void OnStreamAfterWrite(WriteWrap* w, int status) override {\n-    previous_listener_->OnStreamAfterWrite(w, status);\n-  }\n-\n-  void AfterWrite(WriteWrap* req_wrap, int status) override;\n-\n   uv_stream_t* const stream_;\n };\n "
        }
    ],
    "stats": {
        "total": 181,
        "additions": 53,
        "deletions": 128
    }
}