{
    "author": "BridgeAR",
    "message": "assert: adjust loose assertions\n\nThis changes the loose deep equal comparison by using the same logic\nas done in the strict deep equal comparison besides comparing\nprimitives loosely, not comparing symbol properties and not comparing\nthe prototype.\n\n`assert.deepEqual` is still commenly used and this is likely the\nbiggest pitfall.\n\nMost changes are only minor and won't have a big impact besides\nlikely fixing user expectations.\n\nPR-URL: https://github.com/nodejs/node/pull/25008\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "7493db21b667ed746d39c9b54357eac4287232e3",
    "files": [
        {
            "sha": "67bc9afbabccbe8d41e7192b9e0b23d0caa6d342",
            "filename": "doc/api/assert.md",
            "status": "modified",
            "additions": 32,
            "deletions": 15,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/7493db21b667ed746d39c9b54357eac4287232e3/doc%2Fapi%2Fassert.md",
            "raw_url": "https://github.com/nodejs/node/raw/7493db21b667ed746d39c9b54357eac4287232e3/doc%2Fapi%2Fassert.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fassert.md?ref=7493db21b667ed746d39c9b54357eac4287232e3",
            "patch": "@@ -163,6 +163,10 @@ An alias of [`assert.ok()`][].\n <!-- YAML\n added: v0.1.21\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/25008\n+    description: The type tags are now properly compared and there are a couple\n+                 minor comparison adjustments to make the check less surprising.\n   - version: v9.0.0\n     pr-url: https://github.com/nodejs/node/pull/15001\n     description: The `Error` names and messages are now properly compared\n@@ -191,26 +195,39 @@ An alias of [`assert.deepStrictEqual()`][].\n \n > Stability: 0 - Deprecated: Use [`assert.deepStrictEqual()`][] instead.\n \n-Tests for deep equality between the `actual` and `expected` parameters.\n-Primitive values are compared with the [Abstract Equality Comparison][]\n-( `==` ).\n+Tests for deep equality between the `actual` and `expected` parameters. Consider\n+using [`assert.deepStrictEqual()`][] instead. [`assert.deepEqual()`][] can have\n+potentially surprising results.\n+\n+\"Deep\" equality means that the enumerable \"own\" properties of child objects\n+are also recursively evaluated by the following rules.\n+\n+### Comparison details\n+\n+* Primitive values are compared with the [Abstract Equality Comparison][]\n+  ( `==` ).\n+* [Type tags][Object.prototype.toString()] of objects should be the same.\n+* Only [enumerable \"own\" properties][] are considered.\n+* [`Error`][] names and messages are always compared, even if these are not\n+  enumerable properties.\n+* [Object wrappers][] are compared both as objects and unwrapped values.\n+* `Object` properties are compared unordered.\n+* [`Map`][] keys and [`Set`][] items are compared unordered.\n+* Recursion stops when both sides differ or both sides encounter a circular\n+  reference.\n+* Implementation does not test the [`[[Prototype]]`][prototype-spec] of\n+  objects.\n+* [`Symbol`][] properties are not compared.\n+* [`WeakMap`][] and [`WeakSet`][] comparison does not rely on their values.\n \n-Only [enumerable \"own\" properties][] are considered. The\n-[`assert.deepEqual()`][] implementation does not test the\n-[`[[Prototype]]`][prototype-spec] of objects or enumerable own [`Symbol`][]\n-properties. For such checks, consider using [`assert.deepStrictEqual()`][]\n-instead. [`assert.deepEqual()`][] can have potentially surprising results. The\n-following example does not throw an `AssertionError` because the properties on\n-the [`RegExp`][] object are not enumerable:\n+The following example does not throw an `AssertionError` because the primitives\n+are considered equal by the [Abstract Equality Comparison][] ( `==` ).\n \n ```js\n // WARNING: This does not throw an AssertionError!\n-assert.deepEqual(/a/gi, new Date());\n+assert.deepEqual('+00000000', false);\n ```\n \n-An exception is made for [`Map`][] and [`Set`][]. `Map`s and `Set`s have their\n-contained items compared too, as expected.\n-\n \"Deep\" equality means that the enumerable \"own\" properties of child objects\n are evaluated also:\n \n@@ -304,7 +321,7 @@ are recursively evaluated also by the following rules.\n * Enumerable own [`Symbol`][] properties are compared as well.\n * [Object wrappers][] are compared both as objects and unwrapped values.\n * `Object` properties are compared unordered.\n-* `Map` keys and `Set` items are compared unordered.\n+* [`Map`][] keys and [`Set`][] items are compared unordered.\n * Recursion stops when both sides differ or both sides encounter a circular\n   reference.\n * [`WeakMap`][] and [`WeakSet`][] comparison does not rely on their values. See"
        },
        {
            "sha": "3470f206661557877745d9b6133a11144d486a32",
            "filename": "lib/internal/util/comparisons.js",
            "status": "modified",
            "additions": 47,
            "deletions": 106,
            "changes": 153,
            "blob_url": "https://github.com/nodejs/node/blob/7493db21b667ed746d39c9b54357eac4287232e3/lib%2Finternal%2Futil%2Fcomparisons.js",
            "raw_url": "https://github.com/nodejs/node/raw/7493db21b667ed746d39c9b54357eac4287232e3/lib%2Finternal%2Futil%2Fcomparisons.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil%2Fcomparisons.js?ref=7493db21b667ed746d39c9b54357eac4287232e3",
            "patch": "@@ -14,7 +14,9 @@ const {\n   isStringObject,\n   isBooleanObject,\n   isBigIntObject,\n-  isSymbolObject\n+  isSymbolObject,\n+  isFloat32Array,\n+  isFloat64Array\n } = require('internal/util/types');\n const {\n   getOwnNonIndexProperties,\n@@ -84,18 +86,6 @@ function areEqualArrayBuffers(buf1, buf2) {\n     compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;\n }\n \n-function isFloatTypedArrayTag(tag) {\n-  return tag === '[object Float32Array]' || tag === '[object Float64Array]';\n-}\n-\n-function isArguments(tag) {\n-  return tag === '[object Arguments]';\n-}\n-\n-function isObjectOrArrayTag(tag) {\n-  return tag === '[object Array]' || tag === '[object Object]';\n-}\n-\n function isEqualBoxedPrimitive(val1, val2) {\n   if (isNumberObject(val1)) {\n     return isNumberObject(val2) &&\n@@ -132,23 +122,45 @@ function isEqualBoxedPrimitive(val1, val2) {\n // For strict comparison, objects should have\n // a) The same built-in type tags\n // b) The same prototypes.\n-function strictDeepEqual(val1, val2, memos) {\n-  if (typeof val1 !== 'object') {\n-    return typeof val1 === 'number' && numberIsNaN(val1) &&\n-      numberIsNaN(val2);\n+\n+function innerDeepEqual(val1, val2, strict, memos) {\n+  // All identical values are equivalent, as determined by ===.\n+  if (val1 === val2) {\n+    if (val1 !== 0)\n+      return true;\n+    return strict ? objectIs(val1, val2) : true;\n   }\n-  if (typeof val2 !== 'object' || val1 === null || val2 === null) {\n-    return false;\n+\n+  // Check more closely if val1 and val2 are equal.\n+  if (strict) {\n+    if (typeof val1 !== 'object') {\n+      return typeof val1 === 'number' && numberIsNaN(val1) &&\n+        numberIsNaN(val2);\n+    }\n+    if (typeof val2 !== 'object' || val1 === null || val2 === null) {\n+      return false;\n+    }\n+    if (getPrototypeOf(val1) !== getPrototypeOf(val2)) {\n+      return false;\n+    }\n+  } else {\n+    if (val1 === null || typeof val1 !== 'object') {\n+      if (val2 === null || typeof val2 !== 'object') {\n+        // eslint-disable-next-line eqeqeq\n+        return val1 == val2;\n+      }\n+      return false;\n+    }\n+    if (val2 === null || typeof val2 !== 'object') {\n+      return false;\n+    }\n   }\n   const val1Tag = objectToString(val1);\n   const val2Tag = objectToString(val2);\n \n   if (val1Tag !== val2Tag) {\n     return false;\n   }\n-  if (getPrototypeOf(val1) !== getPrototypeOf(val2)) {\n-    return false;\n-  }\n   if (Array.isArray(val1)) {\n     // Check for sparse arrays and general fast path\n     if (val1.length !== val2.length) {\n@@ -159,10 +171,10 @@ function strictDeepEqual(val1, val2, memos) {\n     if (keys1.length !== keys2.length) {\n       return false;\n     }\n-    return keyCheck(val1, val2, kStrict, memos, kIsArray, keys1);\n+    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);\n   }\n   if (val1Tag === '[object Object]') {\n-    return keyCheck(val1, val2, kStrict, memos, kNoIterator);\n+    return keyCheck(val1, val2, strict, memos, kNoIterator);\n   }\n   if (isDate(val1)) {\n     if (dateGetTime(val1) !== dateGetTime(val2)) {\n@@ -174,13 +186,16 @@ function strictDeepEqual(val1, val2, memos) {\n     }\n   } else if (isNativeError(val1) || val1 instanceof Error) {\n     // Do not compare the stack as it might differ even though the error itself\n-    // is otherwise identical. The non-enumerable name should be identical as\n-    // the prototype is also identical. Otherwise this is caught later on.\n-    if (val1.message !== val2.message) {\n+    // is otherwise identical.\n+    if (val1.message !== val2.message || val1.name !== val2.name) {\n       return false;\n     }\n   } else if (isArrayBufferView(val1)) {\n-    if (!areSimilarTypedArrays(val1, val2)) {\n+    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {\n+      if (!areSimilarFloatArrays(val1, val2)) {\n+        return false;\n+      }\n+    } else if (!areSimilarTypedArrays(val1, val2)) {\n       return false;\n     }\n     // Buffer.compare returns true, so val1.length === val2.length. If they both\n@@ -191,84 +206,25 @@ function strictDeepEqual(val1, val2, memos) {\n     if (keys1.length !== keys2.length) {\n       return false;\n     }\n-    return keyCheck(val1, val2, kStrict, memos, kNoIterator, keys1);\n+    return keyCheck(val1, val2, strict, memos, kNoIterator, keys1);\n   } else if (isSet(val1)) {\n     if (!isSet(val2) || val1.size !== val2.size) {\n       return false;\n     }\n-    return keyCheck(val1, val2, kStrict, memos, kIsSet);\n+    return keyCheck(val1, val2, strict, memos, kIsSet);\n   } else if (isMap(val1)) {\n     if (!isMap(val2) || val1.size !== val2.size) {\n       return false;\n     }\n-    return keyCheck(val1, val2, kStrict, memos, kIsMap);\n+    return keyCheck(val1, val2, strict, memos, kIsMap);\n   } else if (isAnyArrayBuffer(val1)) {\n     if (!areEqualArrayBuffers(val1, val2)) {\n       return false;\n     }\n   } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {\n     return false;\n   }\n-  return keyCheck(val1, val2, kStrict, memos, kNoIterator);\n-}\n-\n-function looseDeepEqual(val1, val2, memos) {\n-  if (val1 === null || typeof val1 !== 'object') {\n-    if (val2 === null || typeof val2 !== 'object') {\n-      // eslint-disable-next-line eqeqeq\n-      return val1 == val2;\n-    }\n-    return false;\n-  }\n-  if (val2 === null || typeof val2 !== 'object') {\n-    return false;\n-  }\n-  const val1Tag = objectToString(val1);\n-  const val2Tag = objectToString(val2);\n-  if (val1Tag === val2Tag) {\n-    if (isObjectOrArrayTag(val1Tag)) {\n-      return keyCheck(val1, val2, kLoose, memos, kNoIterator);\n-    }\n-    if (isArrayBufferView(val1)) {\n-      if (isFloatTypedArrayTag(val1Tag)) {\n-        return areSimilarFloatArrays(val1, val2);\n-      }\n-      return areSimilarTypedArrays(val1, val2);\n-    }\n-    if (isDate(val1) && isDate(val2)) {\n-      return val1.getTime() === val2.getTime();\n-    }\n-    if (isRegExp(val1) && isRegExp(val2)) {\n-      return areSimilarRegExps(val1, val2);\n-    }\n-    if (val1 instanceof Error && val2 instanceof Error) {\n-      if (val1.message !== val2.message || val1.name !== val2.name)\n-        return false;\n-    }\n-  // Ensure reflexivity of deepEqual with `arguments` objects.\n-  // See https://github.com/nodejs/node-v0.x-archive/pull/7178\n-  } else if (isArguments(val1Tag) || isArguments(val2Tag)) {\n-    return false;\n-  }\n-  if (isSet(val1)) {\n-    if (!isSet(val2) || val1.size !== val2.size) {\n-      return false;\n-    }\n-    return keyCheck(val1, val2, kLoose, memos, kIsSet);\n-  } else if (isMap(val1)) {\n-    if (!isMap(val2) || val1.size !== val2.size) {\n-      return false;\n-    }\n-    return keyCheck(val1, val2, kLoose, memos, kIsMap);\n-  } else if (isSet(val2) || isMap(val2)) {\n-    return false;\n-  }\n-  if (isAnyArrayBuffer(val1) && isAnyArrayBuffer(val2)) {\n-    if (!areEqualArrayBuffers(val1, val2)) {\n-      return false;\n-    }\n-  }\n-  return keyCheck(val1, val2, kLoose, memos, kNoIterator);\n+  return keyCheck(val1, val2, strict, memos, kNoIterator);\n }\n \n function getEnumerables(val, keys) {\n@@ -370,21 +326,6 @@ function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\n   return areEq;\n }\n \n-function innerDeepEqual(val1, val2, strict, memos) {\n-  // All identical values are equivalent, as determined by ===.\n-  if (val1 === val2) {\n-    if (val1 !== 0)\n-      return true;\n-    return strict ? objectIs(val1, val2) : true;\n-  }\n-\n-  // Check more closely if val1 and val2 are equal.\n-  if (strict === true)\n-    return strictDeepEqual(val1, val2, memos);\n-\n-  return looseDeepEqual(val1, val2, memos);\n-}\n-\n function setHasEqualElement(set, val1, strict, memo) {\n   // Go looking.\n   for (const val2 of set) {"
        },
        {
            "sha": "b271d43c805d0ebd2f7b5e3d5b8d0c33504babdb",
            "filename": "test/es-module/test-esm-dynamic-import.js",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/7493db21b667ed746d39c9b54357eac4287232e3/test%2Fes-module%2Ftest-esm-dynamic-import.js",
            "raw_url": "https://github.com/nodejs/node/raw/7493db21b667ed746d39c9b54357eac4287232e3/test%2Fes-module%2Ftest-esm-dynamic-import.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fes-module%2Ftest-esm-dynamic-import.js?ref=7493db21b667ed746d39c9b54357eac4287232e3",
            "patch": "@@ -23,9 +23,12 @@ function expectMissingModuleError(result) {\n function expectOkNamespace(result) {\n   Promise.resolve(result)\n     .then(common.mustCall((ns) => {\n-      // Can't deepStrictEqual because ns isn't a normal object\n-      // eslint-disable-next-line no-restricted-properties\n-      assert.deepEqual(ns, { default: true });\n+      const expected = { default: true };\n+      Object.defineProperty(expected, Symbol.toStringTag, {\n+        value: 'Module'\n+      });\n+      Object.setPrototypeOf(expected, Object.getPrototypeOf(ns));\n+      assert.deepStrictEqual(ns, expected);\n     }));\n }\n "
        },
        {
            "sha": "c0b80adffcaa1a4ac5bd766a4ab4e5a327fa637b",
            "filename": "test/parallel/test-assert-checktag.js",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/7493db21b667ed746d39c9b54357eac4287232e3/test%2Fparallel%2Ftest-assert-checktag.js",
            "raw_url": "https://github.com/nodejs/node/raw/7493db21b667ed746d39c9b54357eac4287232e3/test%2Fparallel%2Ftest-assert-checktag.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-assert-checktag.js?ref=7493db21b667ed746d39c9b54357eac4287232e3",
            "patch": "@@ -18,8 +18,8 @@ if (process.stdout.isTTY)\n   FakeDate.prototype = Date.prototype;\n   const fake = new FakeDate();\n \n-  assert.deepEqual(date, fake);\n-  assert.deepEqual(fake, date);\n+  assert.notDeepEqual(date, fake);\n+  assert.notDeepEqual(fake, date);\n \n   // For deepStrictEqual we check the runtime type,\n   // then reveal the fakeness of the fake date\n@@ -45,7 +45,7 @@ if (process.stdout.isTTY)\n   for (const prop of Object.keys(global)) {\n     fakeGlobal[prop] = global[prop];\n   }\n-  assert.deepEqual(fakeGlobal, global);\n+  assert.notDeepEqual(fakeGlobal, global);\n   // Message will be truncated anyway, don't validate\n   assert.throws(() => assert.deepStrictEqual(fakeGlobal, global),\n                 assert.AssertionError);\n@@ -57,7 +57,7 @@ if (process.stdout.isTTY)\n   for (const prop of Object.keys(process)) {\n     fakeProcess[prop] = process[prop];\n   }\n-  assert.deepEqual(fakeProcess, process);\n+  assert.notDeepEqual(fakeProcess, process);\n   // Message will be truncated anyway, don't validate\n   assert.throws(() => assert.deepStrictEqual(fakeProcess, process),\n                 assert.AssertionError);"
        },
        {
            "sha": "65ebec7bba96135217578ffa4f5562ecb2aa01ae",
            "filename": "test/parallel/test-assert-deep.js",
            "status": "modified",
            "additions": 22,
            "deletions": 28,
            "changes": 50,
            "blob_url": "https://github.com/nodejs/node/blob/7493db21b667ed746d39c9b54357eac4287232e3/test%2Fparallel%2Ftest-assert-deep.js",
            "raw_url": "https://github.com/nodejs/node/raw/7493db21b667ed746d39c9b54357eac4287232e3/test%2Fparallel%2Ftest-assert-deep.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-assert-deep.js?ref=7493db21b667ed746d39c9b54357eac4287232e3",
            "patch": "@@ -75,7 +75,7 @@ assert.deepEqual(arr, buf);\n                '  ]'\n     }\n   );\n-  assert.deepEqual(buf2, buf);\n+  assert.notDeepEqual(buf2, buf);\n }\n \n {\n@@ -94,7 +94,7 @@ assert.deepEqual(arr, buf);\n                '  ]'\n     }\n   );\n-  assert.deepEqual(arr, arr2);\n+  assert.notDeepEqual(arr, arr2);\n }\n \n const date = new Date('2016');\n@@ -110,8 +110,8 @@ const date2 = new MyDate('2016');\n \n // deepEqual returns true as long as the time are the same,\n // but deepStrictEqual checks own properties\n-assert.deepEqual(date, date2);\n-assert.deepEqual(date2, date);\n+assert.notDeepEqual(date, date2);\n+assert.notDeepEqual(date2, date);\n assert.throws(\n   () => assert.deepStrictEqual(date, date2),\n   {\n@@ -143,7 +143,7 @@ const re2 = new MyRegExp('test');\n \n // deepEqual returns true as long as the regexp-specific properties\n // are the same, but deepStrictEqual checks all properties\n-assert.deepEqual(re1, re2);\n+assert.notDeepEqual(re1, re2);\n assert.throws(\n   () => assert.deepStrictEqual(re1, re2),\n   {\n@@ -157,28 +157,24 @@ assert.throws(\n // but deepStrictEqual should throw.\n {\n   const similar = new Set([\n-    { 0: '1' },  // Object\n     { 0: 1 },  // Object\n     new String('1'),  // Object\n-    ['1'],  // Array\n     [1],  // Array\n     date2,  // Date with this[0] = '1'\n     re2,  // RegExp with this[0] = '1'\n     new Int8Array([1]), // Int8Array\n-    new Uint8Array([1]), // Uint8Array\n     new Int16Array([1]), // Int16Array\n     new Uint16Array([1]), // Uint16Array\n     new Int32Array([1]), // Int32Array\n     new Uint32Array([1]), // Uint32Array\n-    Buffer.from([1]),\n-    // Arguments {'0': '1'} is not here\n-    // See https://github.com/nodejs/node-v0.x-archive/pull/7178\n+    Buffer.from([1]), // Uint8Array\n+    (function() { return arguments; })(1)\n   ]);\n \n   for (const a of similar) {\n     for (const b of similar) {\n       if (a !== b) {\n-        assert.deepEqual(a, b);\n+        assert.notDeepEqual(a, b);\n         assert.throws(\n           () => assert.deepStrictEqual(a, b),\n           { code: 'ERR_ASSERTION' }\n@@ -576,7 +572,7 @@ assertNotDeepOrStrict(\n // Handle sparse arrays.\n {\n   assertDeepAndStrictEqual([1, , , 3], [1, , , 3]);\n-  assertOnlyDeepEqual([1, , , 3], [1, , , 3, , , ]);\n+  assertNotDeepOrStrict([1, , , 3], [1, , , 3, , , ]);\n   const a = new Array(3);\n   const b = new Array(3);\n   a[2] = true;\n@@ -594,13 +590,11 @@ assertNotDeepOrStrict(\n   assertNotDeepOrStrict(err1, new Error('foo2'), assert.AssertionError);\n   assertNotDeepOrStrict(err1, new TypeError('foo1'), assert.AssertionError);\n   assertDeepAndStrictEqual(err1, new Error('foo1'));\n-  // TODO: evaluate if this should throw or not. The same applies for RegExp\n-  // Date and any object that has the same keys but not the same prototype.\n-  assertOnlyDeepEqual(err1, {});\n+  assertNotDeepOrStrict(err1, {}, AssertionError);\n }\n \n // Handle NaN\n-assert.throws(() => { assert.deepEqual(NaN, NaN); }, assert.AssertionError);\n+assert.notDeepEqual(NaN, NaN);\n assert.deepStrictEqual(NaN, NaN);\n assert.deepStrictEqual({ a: NaN }, { a: NaN });\n assert.deepStrictEqual([ 1, 2, NaN, 4 ], [ 1, 2, NaN, 4 ]);\n@@ -609,11 +603,11 @@ assert.deepStrictEqual([ 1, 2, NaN, 4 ], [ 1, 2, NaN, 4 ]);\n {\n   const boxedString = new String('test');\n   const boxedSymbol = Object(Symbol());\n-  assertOnlyDeepEqual(new Boolean(true), Object(false));\n-  assertOnlyDeepEqual(Object(true), new Number(1));\n-  assertOnlyDeepEqual(new Number(2), new Number(1));\n-  assertOnlyDeepEqual(boxedSymbol, Object(Symbol()));\n-  assertOnlyDeepEqual(boxedSymbol, {});\n+  assertNotDeepOrStrict(new Boolean(true), Object(false));\n+  assertNotDeepOrStrict(Object(true), new Number(1));\n+  assertNotDeepOrStrict(new Number(2), new Number(1));\n+  assertNotDeepOrStrict(boxedSymbol, Object(Symbol()));\n+  assertNotDeepOrStrict(boxedSymbol, {});\n   assertDeepAndStrictEqual(boxedSymbol, boxedSymbol);\n   assertDeepAndStrictEqual(Object(true), Object(true));\n   assertDeepAndStrictEqual(Object(2), Object(2));\n@@ -645,7 +639,7 @@ assertDeepAndStrictEqual(-0, -0);\n   const b = new Uint8Array(4);\n   a[symbol1] = true;\n   b[symbol1] = false;\n-  assertOnlyDeepEqual(a, b);\n+  assertNotDeepOrStrict(a, b);\n   b[symbol1] = true;\n   assertDeepAndStrictEqual(a, b);\n   // The same as TypedArrays is valid for boxed primitives\n@@ -700,7 +694,7 @@ assert.deepEqual({ a: 4, b: '2' }, { a: 4, b: '2' });\n assert.deepEqual([4], ['4']);\n assert.throws(\n   () => assert.deepEqual({ a: 4 }, { a: 4, b: true }), AssertionError);\n-assert.deepEqual(['a'], { 0: 'a' });\n+assert.notDeepEqual(['a'], { 0: 'a' });\n assert.deepEqual({ a: 4, b: '1' }, { b: '1', a: 4 });\n const a1 = [1, 2, 3];\n const a2 = [1, 2, 3];\n@@ -759,10 +753,10 @@ assertOnlyDeepEqual(true, 1);\n }\n \n // Primitive wrappers and object.\n-assertOnlyDeepEqual(new String('a'), ['a']);\n-assertOnlyDeepEqual(new String('a'), { 0: 'a' });\n-assertOnlyDeepEqual(new Number(1), {});\n-assertOnlyDeepEqual(new Boolean(true), {});\n+assertNotDeepOrStrict(new String('a'), ['a']);\n+assertNotDeepOrStrict(new String('a'), { 0: 'a' });\n+assertNotDeepOrStrict(new Number(1), {});\n+assertNotDeepOrStrict(new Boolean(true), {});\n \n // Same number of keys but different key names.\n assertNotDeepOrStrict({ a: 1 }, { b: 1 });"
        },
        {
            "sha": "6be4c10595ab4591defe1578981e622a553aad5a",
            "filename": "test/parallel/test-assert-typedarray-deepequal.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/7493db21b667ed746d39c9b54357eac4287232e3/test%2Fparallel%2Ftest-assert-typedarray-deepequal.js",
            "raw_url": "https://github.com/nodejs/node/raw/7493db21b667ed746d39c9b54357eac4287232e3/test%2Fparallel%2Ftest-assert-typedarray-deepequal.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-assert-typedarray-deepequal.js?ref=7493db21b667ed746d39c9b54357eac4287232e3",
            "patch": "@@ -29,15 +29,15 @@ const equalArrayPairs = [\n ];\n \n const looseEqualArrayPairs = [\n-  [new Float64Array([+0.0]), new Float32Array([-0.0])],\n-  [new Int16Array(256), new Uint16Array(256)],\n-  [new Int16Array([256]), new Uint16Array([256])],\n   [new Float32Array([+0.0]), new Float32Array([-0.0])],\n-  [new Float64Array([+0.0]), new Float64Array([-0.0])],\n-  [new ArrayBuffer(3), new SharedArrayBuffer(3)]\n+  [new Float64Array([+0.0]), new Float64Array([-0.0])]\n ];\n \n const notEqualArrayPairs = [\n+  [new ArrayBuffer(3), new SharedArrayBuffer(3)],\n+  [new Int16Array(256), new Uint16Array(256)],\n+  [new Int16Array([256]), new Uint16Array([256])],\n+  [new Float64Array([+0.0]), new Float32Array([-0.0])],\n   [new Uint8Array(2), new Uint8Array(3)],\n   [new Uint8Array([1, 2, 3]), new Uint8Array([4, 5, 6])],\n   [new Uint8ClampedArray([300, 2, 3]), new Uint8Array([300, 2, 3])],"
        }
    ],
    "stats": {
        "total": 277,
        "additions": 116,
        "deletions": 161
    }
}