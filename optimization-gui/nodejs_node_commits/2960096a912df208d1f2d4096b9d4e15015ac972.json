{
    "author": "juggernaut451",
    "message": "test: refactor of test-tls-over-http-tunnel\n\nPR-URL: https://github.com/nodejs/node/pull/18784\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "2960096a912df208d1f2d4096b9d4e15015ac972",
    "files": [
        {
            "sha": "f3f2bb3f2726edad7de01bba3ea6846ce7d36652",
            "filename": "test/parallel/test-tls-over-http-tunnel.js",
            "status": "modified",
            "additions": 26,
            "deletions": 23,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/2960096a912df208d1f2d4096b9d4e15015ac972/test%2Fparallel%2Ftest-tls-over-http-tunnel.js",
            "raw_url": "https://github.com/nodejs/node/raw/2960096a912df208d1f2d4096b9d4e15015ac972/test%2Fparallel%2Ftest-tls-over-http-tunnel.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-over-http-tunnel.js?ref=2960096a912df208d1f2d4096b9d4e15015ac972",
            "patch": "@@ -24,6 +24,9 @@ const common = require('../common');\n if (!common.hasCrypto)\n   common.skip('missing crypto');\n \n+// This test ensures that the data received through tls over http tunnel\n+// is same as what is sent.\n+\n const assert = require('assert');\n const https = require('https');\n const net = require('net');\n@@ -37,21 +40,21 @@ const cert = fixtures.readKey('agent1-cert.pem');\n \n const options = { key, cert };\n \n-const server = https.createServer(options, function(req, res) {\n+const server = https.createServer(options, common.mustCall((req, res) => {\n   console.log('SERVER: got request');\n   res.writeHead(200, {\n     'content-type': 'text/plain'\n   });\n   console.log('SERVER: sending response');\n   res.end('hello world\\n');\n-});\n+}));\n \n-const proxy = net.createServer(function(clientSocket) {\n+const proxy = net.createServer((clientSocket) => {\n   console.log('PROXY: got a client connection');\n \n   let serverSocket = null;\n \n-  clientSocket.on('data', function(chunk) {\n+  clientSocket.on('data', (chunk) => {\n     if (!serverSocket) {\n       // Verify the CONNECT request\n       assert.strictEqual(`CONNECT localhost:${server.address().port} ` +\n@@ -65,39 +68,39 @@ const proxy = net.createServer(function(clientSocket) {\n       console.log('PROXY: creating a tunnel');\n \n       // create the tunnel\n-      serverSocket = net.connect(server.address().port, function() {\n+      serverSocket = net.connect(server.address().port, common.mustCall(() => {\n         console.log('PROXY: replying to client CONNECT request');\n \n         // Send the response\n         clientSocket.write('HTTP/1.1 200 OK\\r\\nProxy-Connections: keep' +\n-                           '-alive\\r\\nConnections: keep-alive\\r\\nVia: ' +\n-                           `localhost:${proxy.address().port}\\r\\n\\r\\n`);\n-      });\n+          '-alive\\r\\nConnections: keep-alive\\r\\nVia: ' +\n+          `localhost:${proxy.address().port}\\r\\n\\r\\n`);\n+      }));\n \n-      serverSocket.on('data', function(chunk) {\n+      serverSocket.on('data', (chunk) => {\n         clientSocket.write(chunk);\n       });\n \n-      serverSocket.on('end', function() {\n+      serverSocket.on('end', common.mustCall(() => {\n         clientSocket.destroy();\n-      });\n+      }));\n     } else {\n       serverSocket.write(chunk);\n     }\n   });\n \n-  clientSocket.on('end', function() {\n+  clientSocket.on('end', () => {\n     serverSocket.destroy();\n   });\n });\n \n server.listen(0);\n \n-proxy.listen(0, function() {\n+proxy.listen(0, common.mustCall(() => {\n   console.log('CLIENT: Making CONNECT request');\n \n   const req = http.request({\n-    port: this.address().port,\n+    port: proxy.address().port,\n     method: 'CONNECT',\n     path: `localhost:${server.address().port}`,\n     headers: {\n@@ -117,7 +120,7 @@ proxy.listen(0, function() {\n \n   function onUpgrade(res, socket, head) {\n     // Hacky.\n-    process.nextTick(function() {\n+    process.nextTick(() => {\n       onConnect(res, socket, head);\n     });\n   }\n@@ -145,29 +148,29 @@ proxy.listen(0, function() {\n       socket: socket,  // reuse the socket\n       agent: false,\n       rejectUnauthorized: false\n-    }, function(res) {\n+    }, (res) => {\n       assert.strictEqual(200, res.statusCode);\n \n-      res.on('data', function(chunk) {\n+      res.on('data', common.mustCall((chunk) => {\n         assert.strictEqual('hello world\\n', chunk.toString());\n         console.log('CLIENT: got HTTPS response');\n         gotRequest = true;\n-      });\n+      }));\n \n-      res.on('end', function() {\n+      res.on('end', common.mustCall(() => {\n         proxy.close();\n         server.close();\n-      });\n-    }).on('error', function(er) {\n+      }));\n+    }).on('error', (er) => {\n       // We're ok with getting ECONNRESET in this test, but it's\n       // timing-dependent, and thus unreliable. Any other errors\n       // are just failures, though.\n       if (er.code !== 'ECONNRESET')\n         throw er;\n     }).end();\n   }\n-});\n+}));\n \n-process.on('exit', function() {\n+process.on('exit', () => {\n   assert.ok(gotRequest);\n });"
        }
    ],
    "stats": {
        "total": 49,
        "additions": 26,
        "deletions": 23
    }
}