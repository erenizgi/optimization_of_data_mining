{
    "author": "BridgeAR",
    "message": "util,assert: improve comparison performance\n\nThis adds a smarter logic to compare object keys (including symbols)\nand it also skips the object key comparison for (typed) arrays, if\npossible.\n\nBesides that it adds a fast path for empty objects, arrays, sets and\nmaps and fast paths for sets and maps with an unequal size.\n\nOn top of that a few functions are now safer to call by using\nuncurryThis and by caching the actual function.\n\nOverall, this is a significant performance boost for comparisons.\n\nPR-URL: https://github.com/nodejs/node/pull/22258\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Rich Trott <rtrott@gmail.com>",
    "sha": "d164d9d606af4061be1a198e2b3e91973464d40c",
    "files": [
        {
            "sha": "9f636f31a3d629b9d0ff777597946e704e00cb9e",
            "filename": "lib/internal/util/comparisons.js",
            "status": "modified",
            "additions": 198,
            "deletions": 118,
            "changes": 316,
            "blob_url": "https://github.com/nodejs/node/blob/d164d9d606af4061be1a198e2b3e91973464d40c/lib%2Finternal%2Futil%2Fcomparisons.js",
            "raw_url": "https://github.com/nodejs/node/raw/d164d9d606af4061be1a198e2b3e91973464d40c/lib%2Finternal%2Futil%2Fcomparisons.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil%2Fcomparisons.js?ref=d164d9d606af4061be1a198e2b3e91973464d40c",
            "patch": "@@ -5,32 +5,52 @@ const { isArrayBufferView } = require('internal/util/types');\n const { internalBinding } = require('internal/bootstrap/loaders');\n const { isDate, isMap, isRegExp, isSet } = internalBinding('types');\n \n-function objectToString(o) {\n-  return Object.prototype.toString.call(o);\n+const ReflectApply = Reflect.apply;\n+\n+function uncurryThis(func) {\n+  return (thisArg, ...args) => ReflectApply(func, thisArg, args);\n }\n \n+const kStrict = true;\n+const kLoose = false;\n+\n+const kNoIterator = 0;\n+const kIsArray = 1;\n+const kIsSet = 2;\n+const kIsMap = 3;\n+\n+const objectToString = uncurryThis(Object.prototype.toString);\n+const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n+const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\n+\n+const objectKeys = Object.keys;\n+const getPrototypeOf = Object.getPrototypeOf;\n+const getOwnPropertySymbols = Object.getOwnPropertySymbols;\n+const objectIs = Object.is;\n+const numberIsNaN = Number.isNaN;\n+\n // Check if they have the same source and flags\n function areSimilarRegExps(a, b) {\n   return a.source === b.source && a.flags === b.flags;\n }\n \n-// For small buffers it's faster to compare the buffer in a loop. The c++\n-// barrier including the Uint8Array operation takes the advantage of the faster\n-// binary compare otherwise. The break even point was at about 300 characters.\n-function areSimilarTypedArrays(a, b, max) {\n-  const len = a.byteLength;\n-  if (len !== b.byteLength) {\n+function areSimilarFloatArrays(a, b) {\n+  if (a.byteLength !== b.byteLength) {\n     return false;\n   }\n-  if (len < max) {\n-    for (var offset = 0; offset < len; offset++) {\n-      if (a[offset] !== b[offset]) {\n-        return false;\n-      }\n+  for (var offset = 0; offset < a.byteLength; offset++) {\n+    if (a[offset] !== b[offset]) {\n+      return false;\n     }\n-    return true;\n   }\n-  return compare(new Uint8Array(a.buffer, a.byteOffset, len),\n+  return true;\n+}\n+\n+function areSimilarTypedArrays(a, b) {\n+  if (a.byteLength !== b.byteLength) {\n+    return false;\n+  }\n+  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength),\n                  new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;\n }\n \n@@ -66,8 +86,8 @@ function isObjectOrArrayTag(tag) {\n // b) The same prototypes.\n function strictDeepEqual(val1, val2, memos) {\n   if (typeof val1 !== 'object') {\n-    return typeof val1 === 'number' && Number.isNaN(val1) &&\n-      Number.isNaN(val2);\n+    return typeof val1 === 'number' && numberIsNaN(val1) &&\n+      numberIsNaN(val2);\n   }\n   if (typeof val2 !== 'object' || val1 === null || val2 === null) {\n     return false;\n@@ -78,21 +98,38 @@ function strictDeepEqual(val1, val2, memos) {\n   if (val1Tag !== val2Tag) {\n     return false;\n   }\n-  if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {\n+  if (getPrototypeOf(val1) !== getPrototypeOf(val2)) {\n     return false;\n   }\n   if (val1Tag === '[object Array]') {\n     // Check for sparse arrays and general fast path\n-    if (val1.length !== val2.length)\n+    if (val1.length !== val2.length) {\n+      return false;\n+    }\n+    const keys = objectKeys(val1);\n+    if (keys.length !== objectKeys(val2).length) {\n       return false;\n-    // Skip testing the part below and continue with the keyCheck.\n-    return keyCheck(val1, val2, true, memos);\n+    }\n+    // Fast path for non sparse arrays (no key comparison for indices\n+    // properties).\n+    // See https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys\n+    if (val1.length === keys.length) {\n+      if (keys.length === 0 || keys[val1.length - 1] === `${val1.length - 1}`) {\n+        return keyCheck(val1, val2, kStrict, memos, kIsArray, []);\n+      }\n+    } else if (keys.length > val1.length &&\n+               keys[val1.length - 1] === `${val1.length - 1}`) {\n+      const minimalKeys = keys.slice(val1.length);\n+      return keyCheck(val1, val2, kStrict, memos, kIsArray, minimalKeys);\n+    }\n+    // Only set this to kIsArray in case the array is not sparse!\n+    return keyCheck(val1, val2, kStrict, memos, kNoIterator, keys);\n   }\n   if (val1Tag === '[object Object]') {\n-    // Skip testing the part below and continue with the keyCheck.\n-    return keyCheck(val1, val2, true, memos);\n+    return keyCheck(val1, val2, kStrict, memos, kNoIterator);\n   }\n   if (isDate(val1)) {\n+    // TODO: Make these safe.\n     if (val1.getTime() !== val2.getTime()) {\n       return false;\n     }\n@@ -108,35 +145,52 @@ function strictDeepEqual(val1, val2, memos) {\n       return false;\n     }\n   } else if (isArrayBufferView(val1)) {\n-    if (!areSimilarTypedArrays(val1, val2,\n-                               isFloatTypedArrayTag(val1Tag) ? 0 : 300)) {\n+    if (!areSimilarTypedArrays(val1, val2)) {\n       return false;\n     }\n     // Buffer.compare returns true, so val1.length === val2.length\n-    // if they both only contain numeric keys, we don't need to exam further\n-    return keyCheck(val1, val2, true, memos, val1.length,\n-                    val2.length);\n+    // if they both only contain numeric keys, we don't need to exam further.\n+    const keys = objectKeys(val1);\n+    if (keys.length !== objectKeys(val2).length) {\n+      return false;\n+    }\n+    if (keys.length === val1.length) {\n+      return keyCheck(val1, val2, kStrict, memos, kNoIterator, []);\n+    }\n+    // Only compare the special keys.\n+    const minimalKeys = keys.slice(val1.length);\n+    return keyCheck(val1, val2, kStrict, memos, kNoIterator, minimalKeys);\n+  } else if (isSet(val1)) {\n+    if (!isSet(val2) || val1.size !== val2.size) {\n+      return false;\n+    }\n+    return keyCheck(val1, val2, kStrict, memos, kIsSet);\n+  } else if (isMap(val1)) {\n+    if (!isMap(val2) || val1.size !== val2.size) {\n+      return false;\n+    }\n+    return keyCheck(val1, val2, kStrict, memos, kIsMap);\n+  // TODO: Make the valueOf checks safe.\n   } else if (typeof val1.valueOf === 'function') {\n     const val1Value = val1.valueOf();\n-    // Note: Boxed string keys are going to be compared again by Object.keys\n     if (val1Value !== val1) {\n       if (typeof val2.valueOf !== 'function') {\n         return false;\n       }\n       if (!innerDeepEqual(val1Value, val2.valueOf(), true))\n         return false;\n-      // Fast path for boxed primitives\n-      var lengthval1 = 0;\n-      var lengthval2 = 0;\n+      // Fast path for boxed primitive strings.\n       if (typeof val1Value === 'string') {\n-        lengthval1 = val1.length;\n-        lengthval2 = val2.length;\n+        const keys = objectKeys(val1);\n+        if (keys.length !== objectKeys(val2).length) {\n+          return false;\n+        }\n+        const minimalKeys = keys.slice(val1.length);\n+        return keyCheck(val1, val2, kStrict, memos, kNoIterator, minimalKeys);\n       }\n-      return keyCheck(val1, val2, true, memos, lengthval1,\n-                      lengthval2);\n     }\n   }\n-  return keyCheck(val1, val2, true, memos);\n+  return keyCheck(val1, val2, kStrict, memos, kNoIterator);\n }\n \n function looseDeepEqual(val1, val2, memos) {\n@@ -150,84 +204,114 @@ function looseDeepEqual(val1, val2, memos) {\n   if (val2 === null || typeof val2 !== 'object') {\n     return false;\n   }\n-  if (isDate(val1) && isDate(val2)) {\n-    return val1.getTime() === val2.getTime();\n-  }\n-  if (isRegExp(val1) && isRegExp(val2)) {\n-    return areSimilarRegExps(val1, val2);\n-  }\n-  if (val1 instanceof Error && val2 instanceof Error) {\n-    if (val1.message !== val2.message || val1.name !== val2.name)\n-      return false;\n-  }\n   const val1Tag = objectToString(val1);\n   const val2Tag = objectToString(val2);\n   if (val1Tag === val2Tag) {\n-    if (!isObjectOrArrayTag(val1Tag) && isArrayBufferView(val1)) {\n-      return areSimilarTypedArrays(val1, val2,\n-                                   isFloatTypedArrayTag(val1Tag) ?\n-                                     Infinity : 300);\n+    if (isObjectOrArrayTag(val1Tag)) {\n+      return keyCheck(val1, val2, kLoose, memos, kNoIterator);\n+    }\n+    if (isArrayBufferView(val1)) {\n+      if (isFloatTypedArrayTag(val1Tag)) {\n+        return areSimilarFloatArrays(val1, val2);\n+      }\n+      return areSimilarTypedArrays(val1, val2);\n+    }\n+    if (isDate(val1) && isDate(val2)) {\n+      return val1.getTime() === val2.getTime();\n+    }\n+    if (isRegExp(val1) && isRegExp(val2)) {\n+      return areSimilarRegExps(val1, val2);\n+    }\n+    if (val1 instanceof Error && val2 instanceof Error) {\n+      if (val1.message !== val2.message || val1.name !== val2.name)\n+        return false;\n     }\n   // Ensure reflexivity of deepEqual with `arguments` objects.\n   // See https://github.com/nodejs/node-v0.x-archive/pull/7178\n   } else if (isArguments(val1Tag) || isArguments(val2Tag)) {\n     return false;\n   }\n-  return keyCheck(val1, val2, false, memos);\n+  if (isSet(val1)) {\n+    if (!isSet(val2) || val1.size !== val2.size) {\n+      return false;\n+    }\n+    return keyCheck(val1, val2, kLoose, memos, kIsSet);\n+  } else if (isMap(val1)) {\n+    if (!isMap(val2) || val1.size !== val2.size) {\n+      return false;\n+    }\n+    return keyCheck(val1, val2, kLoose, memos, kIsMap);\n+  } else if (isSet(val2) || isMap(val2)) {\n+    return false;\n+  }\n+  return keyCheck(val1, val2, kLoose, memos, kNoIterator);\n+}\n+\n+function getEnumerables(val, keys) {\n+  return keys.filter((k) => propertyIsEnumerable(val, k));\n }\n \n-function keyCheck(val1, val2, strict, memos, lengthA, lengthB) {\n+function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\n   // For all remaining Object pairs, including Array, objects and Maps,\n   // equivalence is determined by having:\n   // a) The same number of owned enumerable properties\n   // b) The same set of keys/indexes (although not necessarily the same order)\n   // c) Equivalent values for every corresponding key/index\n   // d) For Sets and Maps, equal contents\n   // Note: this accounts for both named and indexed properties on Arrays.\n-  var aKeys = Object.keys(val1);\n-  var bKeys = Object.keys(val2);\n-  var i;\n+  if (arguments.length === 5) {\n+    aKeys = objectKeys(val1);\n+    const bKeys = objectKeys(val2);\n \n-  // The pair must have the same number of owned properties.\n-  if (aKeys.length !== bKeys.length)\n-    return false;\n+    // The pair must have the same number of owned properties.\n+    if (aKeys.length !== bKeys.length) {\n+      return false;\n+    }\n+  }\n+\n+  // Cheap key test\n+  let i = 0;\n+  for (; i < aKeys.length; i++) {\n+    if (!hasOwnProperty(val2, aKeys[i])) {\n+      return false;\n+    }\n+  }\n \n   if (strict) {\n-    var symbolKeysA = Object.getOwnPropertySymbols(val1);\n-    var symbolKeysB = Object.getOwnPropertySymbols(val2);\n+    const symbolKeysA = getOwnPropertySymbols(val1);\n     if (symbolKeysA.length !== 0) {\n-      symbolKeysA = symbolKeysA.filter((k) =>\n-        propertyIsEnumerable.call(val1, k));\n-      symbolKeysB = symbolKeysB.filter((k) =>\n-        propertyIsEnumerable.call(val2, k));\n-      if (symbolKeysA.length !== symbolKeysB.length)\n+      let count = 0;\n+      for (i = 0; i < symbolKeysA.length; i++) {\n+        const key = symbolKeysA[i];\n+        if (propertyIsEnumerable(val1, key)) {\n+          if (!propertyIsEnumerable(val2, key)) {\n+            return false;\n+          }\n+          aKeys.push(key);\n+          count++;\n+        } else if (propertyIsEnumerable(val2, key)) {\n+          return false;\n+        }\n+      }\n+      const symbolKeysB = getOwnPropertySymbols(val2);\n+      if (symbolKeysA.length !== symbolKeysB.length &&\n+          getEnumerables(val2, symbolKeysB).length !== count) {\n         return false;\n-    } else if (symbolKeysB.length !== 0 && symbolKeysB.filter((k) =>\n-      propertyIsEnumerable.call(val2, k)).length !== 0) {\n-      return false;\n-    }\n-    if (lengthA !== undefined) {\n-      if (aKeys.length !== lengthA || bKeys.length !== lengthB)\n+      }\n+    } else {\n+      const symbolKeysB = getOwnPropertySymbols(val2);\n+      if (symbolKeysB.length !== 0 &&\n+          getEnumerables(val2, symbolKeysB).length !== 0) {\n         return false;\n-      if (symbolKeysA.length === 0)\n-        return true;\n-      aKeys = [];\n-      bKeys = [];\n-    }\n-    if (symbolKeysA.length !== 0) {\n-      aKeys.push(...symbolKeysA);\n-      bKeys.push(...symbolKeysB);\n+      }\n     }\n   }\n \n-  // Cheap key test:\n-  const keys = {};\n-  for (i = 0; i < aKeys.length; i++) {\n-    keys[aKeys[i]] = true;\n-  }\n-  for (i = 0; i < aKeys.length; i++) {\n-    if (keys[bKeys[i]] === undefined)\n-      return false;\n+  if (aKeys.length === 0 &&\n+      (iterationType === kNoIterator ||\n+        iterationType === kIsArray && val1.length === 0 ||\n+      val1.size === 0)) {\n+    return true;\n   }\n \n   // Use memos to handle cycles.\n@@ -254,7 +338,7 @@ function keyCheck(val1, val2, strict, memos, lengthA, lengthB) {\n   memos.val1.set(val1, memos.position);\n   memos.val2.set(val2, memos.position);\n \n-  const areEq = objEquiv(val1, val2, strict, aKeys, memos);\n+  const areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);\n \n   memos.val1.delete(val1);\n   memos.val2.delete(val2);\n@@ -267,7 +351,7 @@ function innerDeepEqual(val1, val2, strict, memos) {\n   if (val1 === val2) {\n     if (val1 !== 0)\n       return true;\n-    return strict ? Object.is(val1, val2) : true;\n+    return strict ? objectIs(val1, val2) : true;\n   }\n \n   // Check more closely if val1 and val2 are equal.\n@@ -297,7 +381,7 @@ function setHasLoosePrim(a, b, val) {\n   if (altValues === undefined)\n     return false;\n \n-  var matches = 1;\n+  let matches = 1;\n   for (var i = 0; i < altValues.length; i++) {\n     if (b.has(altValues[i])) {\n       matches--;\n@@ -310,19 +394,9 @@ function setHasLoosePrim(a, b, val) {\n }\n \n function setEquiv(a, b, strict, memo) {\n-  // This code currently returns false for this pair of sets:\n-  //   assert.deepEqual(new Set(['1', 1]), new Set([1]))\n-  //\n-  // In theory, all the items in the first set have a corresponding == value in\n-  // the second set, but the sets have different sizes. Its a silly case,\n-  // and more evidence that deepStrictEqual should always be preferred over\n-  // deepEqual.\n-  if (a.size !== b.size)\n-    return false;\n-\n   // This is a lazily initiated Set of entries which have to be compared\n   // pairwise.\n-  var set = null;\n+  let set = null;\n   for (const val of a) {\n     // Note: Checking for the objects first improves the performance for object\n     // heavy sets but it is a minor slow down for primitives. As they are fast\n@@ -405,7 +479,7 @@ function mapHasLoosePrim(a, b, key1, memo, item1, item2) {\n   const setA = new Set();\n   const setB = new Set();\n \n-  var keyCount = 1;\n+  let keyCount = 1;\n \n   setA.add(item1);\n   if (b.has(key1)) {\n@@ -454,10 +528,7 @@ function mapHasEqualEntry(set, map, key1, item1, strict, memo) {\n }\n \n function mapEquiv(a, b, strict, memo) {\n-  if (a.size !== b.size)\n-    return false;\n-\n-  var set = null;\n+  let set = null;\n \n   for (const [key, item1] of a) {\n     if (typeof key === 'object' && key !== null) {\n@@ -492,35 +563,44 @@ function mapEquiv(a, b, strict, memo) {\n   return true;\n }\n \n-function objEquiv(a, b, strict, keys, memos) {\n+function objEquiv(a, b, strict, keys, memos, iterationType) {\n   // Sets and maps don't have their entries accessible via normal object\n   // properties.\n-  if (isSet(a)) {\n-    if (!isSet(b) || !setEquiv(a, b, strict, memos))\n+  let i = 0;\n+\n+  if (iterationType === kIsSet) {\n+    if (!setEquiv(a, b, strict, memos)) {\n       return false;\n-  } else if (isMap(a)) {\n-    if (!isMap(b) || !mapEquiv(a, b, strict, memos))\n+    }\n+  } else if (iterationType === kIsMap) {\n+    if (!mapEquiv(a, b, strict, memos)) {\n       return false;\n-  } else if (isSet(b) || isMap(b)) {\n-    return false;\n+    }\n+  } else if (iterationType === kIsArray) {\n+    for (; i < a.length; i++) {\n+      if (!innerDeepEqual(a[i], b[i], strict, memos)) {\n+        return false;\n+      }\n+    }\n   }\n \n   // The pair must have equivalent values for every corresponding key.\n   // Possibly expensive deep test:\n-  for (var i = 0; i < keys.length; i++) {\n+  for (i = 0; i < keys.length; i++) {\n     const key = keys[i];\n-    if (!innerDeepEqual(a[key], b[key], strict, memos))\n+    if (!innerDeepEqual(a[key], b[key], strict, memos)) {\n       return false;\n+    }\n   }\n   return true;\n }\n \n function isDeepEqual(val1, val2) {\n-  return innerDeepEqual(val1, val2, false);\n+  return innerDeepEqual(val1, val2, kLoose);\n }\n \n function isDeepStrictEqual(val1, val2) {\n-  return innerDeepEqual(val1, val2, true);\n+  return innerDeepEqual(val1, val2, kStrict);\n }\n \n module.exports = {"
        },
        {
            "sha": "2360a935b737763713ddb71b2b56fe010412e155",
            "filename": "test/parallel/test-assert-deep.js",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/d164d9d606af4061be1a198e2b3e91973464d40c/test%2Fparallel%2Ftest-assert-deep.js",
            "raw_url": "https://github.com/nodejs/node/raw/d164d9d606af4061be1a198e2b3e91973464d40c/test%2Fparallel%2Ftest-assert-deep.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-assert-deep.js?ref=d164d9d606af4061be1a198e2b3e91973464d40c",
            "patch": "@@ -901,3 +901,10 @@ assert.deepStrictEqual(obj1, obj2);\n   a.valueOf = undefined;\n   assertNotDeepOrStrict(a, new String(1));\n }\n+\n+// Basic array out of bounds check.\n+{\n+  const arr = [1, 2, 3];\n+  arr[2 ** 32] = true;\n+  assertNotDeepOrStrict(arr, [1, 2, 3]);\n+}"
        }
    ],
    "stats": {
        "total": 323,
        "additions": 205,
        "deletions": 118
    }
}