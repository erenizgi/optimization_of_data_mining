{
    "author": "shigeki",
    "message": "test: add tls write error regression test\n\nAdd a mock TLS socket implementation and a regression test for\nthe previous commit.\n\nRefs: https://github.com/nodejs-private/security/issues/189\nPR-URL: https://github.com/nodejs-private/node-private/pull/127\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Evan Lucas <evanlucas@me.com>",
    "sha": "785e5ba48cb57a05c9c0966a502d34ac03084561",
    "files": [
        {
            "sha": "3560af671bce2518b3934dfe9107b1199dec4545",
            "filename": "test/common/tls.js",
            "status": "added",
            "additions": 176,
            "deletions": 0,
            "changes": 176,
            "blob_url": "https://github.com/nodejs/node/blob/785e5ba48cb57a05c9c0966a502d34ac03084561/test%2Fcommon%2Ftls.js",
            "raw_url": "https://github.com/nodejs/node/raw/785e5ba48cb57a05c9c0966a502d34ac03084561/test%2Fcommon%2Ftls.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcommon%2Ftls.js?ref=785e5ba48cb57a05c9c0966a502d34ac03084561",
            "patch": "@@ -0,0 +1,176 @@\n+/* eslint-disable node-core/required-modules, node-core/crypto-check */\n+\n+'use strict';\n+const crypto = require('crypto');\n+const net = require('net');\n+\n+exports.ccs = Buffer.from('140303000101', 'hex');\n+\n+class TestTLSSocket extends net.Socket {\n+  constructor(server_cert) {\n+    super();\n+    this.server_cert = server_cert;\n+    this.version = Buffer.from('0303', 'hex');\n+    this.handshake_list = [];\n+    // AES128-GCM-SHA256\n+    this.ciphers = Buffer.from('000002009c0', 'hex');\n+    this.pre_master_secret =\n+      Buffer.concat([this.version, crypto.randomBytes(46)]);\n+    this.master_secret = null;\n+    this.write_seq = 0;\n+    this.client_random = crypto.randomBytes(32);\n+\n+    this.on('handshake', (msg) => {\n+      this.handshake_list.push(msg);\n+    });\n+\n+    this.on('server_random', (server_random) => {\n+      this.master_secret = PRF12('sha256', this.pre_master_secret,\n+                                 'master secret',\n+                                 Buffer.concat([this.client_random,\n+                                                server_random]),\n+                                 48);\n+      const key_block = PRF12('sha256', this.master_secret,\n+                              'key expansion',\n+                              Buffer.concat([server_random,\n+                                             this.client_random]),\n+                              40);\n+      this.client_writeKey = key_block.slice(0, 16);\n+      this.client_writeIV = key_block.slice(32, 36);\n+    });\n+  }\n+\n+  createClientHello() {\n+    const compressions = Buffer.from('0100', 'hex'); // null\n+    const msg = addHandshakeHeader(0x01, Buffer.concat([\n+      this.version, this.client_random, this.ciphers, compressions\n+    ]));\n+    this.emit('handshake', msg);\n+    return addRecordHeader(0x16, msg);\n+  }\n+\n+  createClientKeyExchange() {\n+    const encrypted_pre_master_secret = crypto.publicEncrypt({\n+      key: this.server_cert,\n+      padding: crypto.constants.RSA_PKCS1_PADDING\n+    }, this.pre_master_secret);\n+    const length = Buffer.alloc(2);\n+    length.writeUIntBE(encrypted_pre_master_secret.length, 0, 2);\n+    const msg = addHandshakeHeader(0x10, Buffer.concat([\n+      length, encrypted_pre_master_secret]));\n+    this.emit('handshake', msg);\n+    return addRecordHeader(0x16, msg);\n+  }\n+\n+  createFinished() {\n+    const shasum = crypto.createHash('sha256');\n+    shasum.update(Buffer.concat(this.handshake_list));\n+    const message_hash = shasum.digest();\n+    const r = PRF12('sha256', this.master_secret,\n+                    'client finished', message_hash, 12);\n+    const msg = addHandshakeHeader(0x14, r);\n+    this.emit('handshake', msg);\n+    return addRecordHeader(0x16, msg);\n+  }\n+\n+  createIllegalHandshake() {\n+    const illegal_handshake = Buffer.alloc(5);\n+    return addRecordHeader(0x16, illegal_handshake);\n+  }\n+\n+  parseTLSFrame(buf) {\n+    let offset = 0;\n+    const record = buf.slice(offset, 5);\n+    const type = record[0];\n+    const length = record.slice(3, 5).readUInt16BE(0);\n+    offset += 5;\n+    let remaining = buf.slice(offset, offset + length);\n+    if (type === 0x16) {\n+      do {\n+        remaining = this.parseTLSHandshake(remaining);\n+      } while (remaining.length > 0);\n+    }\n+    offset += length;\n+    return buf.slice(offset);\n+  }\n+\n+  parseTLSHandshake(buf) {\n+    let offset = 0;\n+    const handshake_type = buf[offset];\n+    if (handshake_type === 0x02) {\n+      const server_random = buf.slice(6, 6 + 32);\n+      this.emit('server_random', server_random);\n+    }\n+    offset += 1;\n+    const length = buf.readUIntBE(offset, 3);\n+    offset += 3;\n+    const handshake = buf.slice(0, offset + length);\n+    this.emit('handshake', handshake);\n+    offset += length;\n+    const remaining = buf.slice(offset);\n+    return remaining;\n+  }\n+\n+  encrypt(plain) {\n+    const type = plain.slice(0, 1);\n+    const version = plain.slice(1, 3);\n+    const nonce = crypto.randomBytes(8);\n+    const iv = Buffer.concat([this.client_writeIV.slice(0, 4), nonce]);\n+    const bob = crypto.createCipheriv('aes-128-gcm', this.client_writeKey, iv);\n+    const write_seq = Buffer.alloc(8);\n+    write_seq.writeUInt32BE(this.write_seq++, 4);\n+    const aad = Buffer.concat([write_seq, plain.slice(0, 5)]);\n+    bob.setAAD(aad);\n+    const encrypted1 = bob.update(plain.slice(5));\n+    const encrypted = Buffer.concat([encrypted1, bob.final()]);\n+    const tag = bob.getAuthTag();\n+    const length = Buffer.alloc(2);\n+    length.writeUInt16BE(nonce.length + encrypted.length + tag.length, 0);\n+    return Buffer.concat([type, version, length, nonce, encrypted, tag]);\n+  }\n+}\n+\n+function addRecordHeader(type, frame) {\n+  const record_layer = Buffer.from('0003030000', 'hex');\n+  record_layer[0] = type;\n+  record_layer.writeUInt16BE(frame.length, 3);\n+  return Buffer.concat([record_layer, frame]);\n+}\n+\n+function addHandshakeHeader(type, msg) {\n+  const handshake_header = Buffer.alloc(4);\n+  handshake_header[0] = type;\n+  handshake_header.writeUIntBE(msg.length, 1, 3);\n+  return Buffer.concat([handshake_header, msg]);\n+}\n+\n+function PRF12(algo, secret, label, seed, size) {\n+  const newSeed = Buffer.concat([Buffer.from(label, 'utf8'), seed]);\n+  return P_hash(algo, secret, newSeed, size);\n+}\n+\n+function P_hash(algo, secret, seed, size) {\n+  const result = Buffer.alloc(size);\n+  let hmac = crypto.createHmac(algo, secret);\n+  hmac.update(seed);\n+  let a = hmac.digest();\n+  let j = 0;\n+  while (j < size) {\n+    hmac = crypto.createHmac(algo, secret);\n+    hmac.update(a);\n+    hmac.update(seed);\n+    const b = hmac.digest();\n+    let todo = b.length;\n+    if (j + todo > size) {\n+      todo = size - j;\n+    }\n+    b.copy(result, j, 0, todo);\n+    j += todo;\n+    hmac = crypto.createHmac(algo, secret);\n+    hmac.update(a);\n+    a = hmac.digest();\n+  }\n+  return result;\n+}\n+\n+exports.TestTLSSocket = TestTLSSocket;"
        },
        {
            "sha": "2783e62d063a28ee2227bb6d828bf6687f5fc5ef",
            "filename": "test/parallel/test-tls-write-error.js",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/785e5ba48cb57a05c9c0966a502d34ac03084561/test%2Fparallel%2Ftest-tls-write-error.js",
            "raw_url": "https://github.com/nodejs/node/raw/785e5ba48cb57a05c9c0966a502d34ac03084561/test%2Fparallel%2Ftest-tls-write-error.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-write-error.js?ref=785e5ba48cb57a05c9c0966a502d34ac03084561",
            "patch": "@@ -0,0 +1,55 @@\n+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+\n+const { TestTLSSocket, ccs } = require('../common/tls');\n+const fixtures = require('../common/fixtures');\n+const https = require('https');\n+\n+// Regression test for an use-after-free bug in the TLS implementation that\n+// would occur when `SSL_write()` failed.\n+// Refs: https://github.com/nodejs-private/security/issues/189\n+\n+const server_key = fixtures.readKey('agent1-key.pem');\n+const server_cert = fixtures.readKey('agent1-cert.pem');\n+\n+const opts = {\n+  key: server_key,\n+  cert: server_cert\n+};\n+\n+const server = https.createServer(opts, (req, res) => {\n+  res.write('hello');\n+}).listen(0, common.mustCall(() => {\n+  const client = new TestTLSSocket(server_cert);\n+\n+  client.connect({\n+    host: 'localhost',\n+    port: server.address().port\n+  }, common.mustCall(() => {\n+    const ch = client.createClientHello();\n+    client.write(ch);\n+  }));\n+\n+  client.once('data', common.mustCall((buf) => {\n+    let remaining = buf;\n+    do {\n+      remaining = client.parseTLSFrame(remaining);\n+    } while (remaining.length > 0);\n+\n+    const cke = client.createClientKeyExchange();\n+    const finished = client.createFinished();\n+    const ill = client.createIllegalHandshake();\n+    const frames = Buffer.concat([\n+      cke,\n+      ccs,\n+      client.encrypt(finished),\n+      client.encrypt(ill)\n+    ]);\n+    client.write(frames, common.mustCall(() => {\n+      client.end();\n+      server.close();\n+    }));\n+  }));\n+}));"
        }
    ],
    "stats": {
        "total": 231,
        "additions": 231,
        "deletions": 0
    }
}