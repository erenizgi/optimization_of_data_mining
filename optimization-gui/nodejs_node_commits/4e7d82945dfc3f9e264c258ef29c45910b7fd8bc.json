{
    "author": "cjihrig",
    "message": "deps: upgrade to libuv 1.23.0\n\nNotable changes:\n- Restores compatibility with the old IPC protocol.\n- Adds uv_open_osfhandle().\n- Adds uv_os_{get,set}priority().\n\nPR-URL: https://github.com/nodejs/node/pull/22365\nFixes: https://github.com/nodejs/node/issues/21671\nFixes: https://github.com/nodejs/node/issues/15433\nRefs: https://github.com/nodejs/node/pull/21675\nRefs: https://github.com/nodejs/node-addon-api/issues/304\nRefs: https://github.com/nodejs/abi-stable-node/issues/318\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
    "files": [
        {
            "sha": "0ba7c067681477341cd494f39f96d0682ef7fae5",
            "filename": "deps/uv/AUTHORS",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FAUTHORS?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -345,3 +345,4 @@ Peter Johnson <johnson.peter@gmail.com>\n Paolo Greppi <paolo.greppi@libpf.com>\n Shelley Vohr <shelley.vohr@gmail.com>\n Ujjwal Sharma <usharma1998@gmail.com>\n+Michał Kozakiewicz <michalkozakiewicz3@gmail.com>"
        },
        {
            "sha": "4f13efc8e6ef2b3fc4152d0280056dd68d6fb1fe",
            "filename": "deps/uv/CMakeLists.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FCMakeLists.txt",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FCMakeLists.txt",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FCMakeLists.txt?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -98,6 +98,7 @@ set(uv_test_sources\n     test/test-poll-closesocket.c\n     test/test-poll-oob.c\n     test/test-poll.c\n+    test/test-process-priority.c\n     test/test-process-title-threadsafe.c\n     test/test-process-title.c\n     test/test-queue-foreach-delete.c"
        },
        {
            "sha": "b57cea4baf150afc46ab6dbab4fb35a67dac7857",
            "filename": "deps/uv/ChangeLog",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FChangeLog",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FChangeLog",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FChangeLog?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -1,3 +1,25 @@\n+2018.08.18, Version 1.23.0 (Stable), 7ebb26225f2eaae6db22f4ef34ce76fa16ff89ec\n+\n+Changes since version 1.22.0:\n+\n+* win,pipe: restore compatibility with the old IPC framing protocol (Bert\n+  Belder)\n+\n+* fs: add uv_open_osfhandle (Bartosz Sosnowski)\n+\n+* doc: update Visual C++ Build Tools URL (Michał Kozakiewicz)\n+\n+* unix: loop starvation on successful write complete (jBarz)\n+\n+* win: add uv__getnameinfo_work() error handling (A. Hauptmann)\n+\n+* win: return UV_ENOMEM from uv_loop_init() (cjihrig)\n+\n+* unix,win: add uv_os_{get,set}priority() (cjihrig)\n+\n+* test: fix warning in test-tcp-open (Santiago Gimeno)\n+\n+\n 2018.07.11, Version 1.22.0 (Stable), 8568f78a777d79d35eb7d6994617267b9fb33967\n \n Changes since version 1.21.0:"
        },
        {
            "sha": "a217faab3cea253202161449ba3353059a94c1b3",
            "filename": "deps/uv/Makefile.am",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FMakefile.am",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FMakefile.am",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FMakefile.am?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -224,6 +224,7 @@ test_run_tests_SOURCES = test/blackhole-server.c \\\n                          test/test-poll-close-doesnt-corrupt-stack.c \\\n                          test/test-poll-closesocket.c \\\n                          test/test-poll-oob.c \\\n+                         test/test-process-priority.c \\\n                          test/test-process-title.c \\\n                          test/test-process-title-threadsafe.c \\\n                          test/test-queue-foreach-delete.c \\"
        },
        {
            "sha": "cb9e26c1e03a7acc3b2cbcb8729e8abfa24bdb53",
            "filename": "deps/uv/README.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FREADME.md?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -349,7 +349,7 @@ See the [guidelines for contributing][].\n [libuv_banner]: https://raw.githubusercontent.com/libuv/libuv/master/img/banner.png\n [x32]: https://en.wikipedia.org/wiki/X32_ABI\n [Python 2.6 or 2.7]: https://www.python.org/downloads/\n-[Visual C++ Build Tools]: http://landinghub.visualstudio.com/visual-cpp-build-tools\n+[Visual C++ Build Tools]: https://visualstudio.microsoft.com/visual-cpp-build-tools/\n [Visual Studio 2015 Update 3]: https://www.visualstudio.com/vs/older-downloads/\n [Visual Studio 2017]: https://www.visualstudio.com/downloads/\n [Git for Windows]: http://git-scm.com/download/win"
        },
        {
            "sha": "6e084fd04d9a7dbe7e43f8dc04dff9449250c3d9",
            "filename": "deps/uv/configure.ac",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fconfigure.ac",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fconfigure.ac",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fconfigure.ac?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -13,7 +13,7 @@\n # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n \n AC_PREREQ(2.57)\n-AC_INIT([libuv], [1.22.0], [https://github.com/libuv/libuv/issues])\n+AC_INIT([libuv], [1.23.0], [https://github.com/libuv/libuv/issues])\n AC_CONFIG_MACRO_DIR([m4])\n m4_include([m4/libuv-extra-automake-flags.m4])\n m4_include([m4/as_case.m4])"
        },
        {
            "sha": "fcf70a35a1f66df4b0b40f48cf87ea0fe10efa33",
            "filename": "deps/uv/docs/src/fs.rst",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -403,6 +403,15 @@ Helper functions\n \n     .. versionadded:: 1.12.0\n \n+.. c:function:: int uv_open_osfhandle(uv_os_fd_t os_fd)\n+\n+   For a OS-dependent handle, get the file descriptor in the C runtime.\n+   On UNIX, returns the ``os_fd`` intact. On Windows, this calls `_open_osfhandle <https://msdn.microsoft.com/en-us/library/bdts1c9x.aspx>`_.\n+   Note that the return value is still owned by the CRT,\n+   any attempts to close it or to use it after closing the handle may lead to malfunction.\n+\n+    .. versionadded:: 1.23.0\n+\n File open constants\n -------------------\n "
        },
        {
            "sha": "529d588c5d4bd12d2b1dbb2a49ac1361299d2d82",
            "filename": "deps/uv/docs/src/misc.rst",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fdocs%2Fsrc%2Fmisc.rst",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fdocs%2Fsrc%2Fmisc.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Fmisc.rst?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -517,3 +517,31 @@ API\n     storage required to hold the value.\n \n     .. versionadded:: 1.12.0\n+\n+.. c:function:: int uv_os_getpriority(uv_pid_t pid, int* priority)\n+\n+    Retrieves the scheduling priority of the process specified by `pid`. The\n+    returned value of `priority` is between -20 (high priority) and 19 (low\n+    priority).\n+\n+    .. note::\n+        On Windows, the returned priority will equal one of the `UV_PRIORITY`\n+        constants.\n+\n+    .. versionadded:: 1.23.0\n+\n+.. c:function:: int uv_os_setpriority(uv_pid_t pid, int priority)\n+\n+    Sets the scheduling priority of the process specified by `pid`. The\n+    `priority` value range is between -20 (high priority) and 19 (low priority).\n+    The constants `UV_PRIORITY_LOW`, `UV_PRIORITY_BELOW_NORMAL`,\n+    `UV_PRIORITY_NORMAL`, `UV_PRIORITY_ABOVE_NORMAL`, `UV_PRIORITY_HIGH`, and\n+    `UV_PRIORITY_HIGHEST` are also provided for convenience.\n+\n+    .. note::\n+        On Windows, this function utilizes `SetPriorityClass()`. The `priority`\n+        argument is mapped to a Windows priority class. When retrieving the\n+        process priority, the result will equal one of the `UV_PRIORITY`\n+        constants, and not necessarily the exact value of `priority`.\n+\n+    .. versionadded:: 1.23.0"
        },
        {
            "sha": "717c2e570b9eb9d5364cb22aba38900b52080cc7",
            "filename": "deps/uv/include/uv.h",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Finclude%2Fuv.h",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Finclude%2Fuv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv.h?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -1065,6 +1065,7 @@ UV_EXTERN int uv_set_process_title(const char* title);\n UV_EXTERN int uv_resident_set_memory(size_t* rss);\n UV_EXTERN int uv_uptime(double* uptime);\n UV_EXTERN uv_os_fd_t uv_get_osfhandle(int fd);\n+UV_EXTERN int uv_open_osfhandle(uv_os_fd_t os_fd);\n \n typedef struct {\n   long tv_sec;\n@@ -1099,6 +1100,16 @@ UV_EXTERN void uv_os_free_passwd(uv_passwd_t* pwd);\n UV_EXTERN uv_pid_t uv_os_getpid(void);\n UV_EXTERN uv_pid_t uv_os_getppid(void);\n \n+#define UV_PRIORITY_LOW 19\n+#define UV_PRIORITY_BELOW_NORMAL 10\n+#define UV_PRIORITY_NORMAL 0\n+#define UV_PRIORITY_ABOVE_NORMAL -7\n+#define UV_PRIORITY_HIGH -14\n+#define UV_PRIORITY_HIGHEST -20\n+\n+UV_EXTERN int uv_os_getpriority(uv_pid_t pid, int* priority);\n+UV_EXTERN int uv_os_setpriority(uv_pid_t pid, int priority);\n+\n UV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);\n UV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);\n "
        },
        {
            "sha": "30e1d5a6f92bf81d2769d217b314d16eaba11ad3",
            "filename": "deps/uv/include/uv/version.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fversion.h?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -31,7 +31,7 @@\n  */\n \n #define UV_VERSION_MAJOR 1\n-#define UV_VERSION_MINOR 22\n+#define UV_VERSION_MINOR 23\n #define UV_VERSION_PATCH 0\n #define UV_VERSION_IS_RELEASE 1\n #define UV_VERSION_SUFFIX \"\""
        },
        {
            "sha": "f92446ff42b86bed7aa9ea683ad4eb40d248b258",
            "filename": "deps/uv/src/unix/core.c",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fcore.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -1338,6 +1338,9 @@ uv_os_fd_t uv_get_osfhandle(int fd) {\n   return fd;\n }\n \n+int uv_open_osfhandle(uv_os_fd_t os_fd) {\n+  return os_fd;\n+}\n \n uv_pid_t uv_os_getpid(void) {\n   return getpid();\n@@ -1347,3 +1350,31 @@ uv_pid_t uv_os_getpid(void) {\n uv_pid_t uv_os_getppid(void) {\n   return getppid();\n }\n+\n+\n+int uv_os_getpriority(uv_pid_t pid, int* priority) {\n+  int r;\n+\n+  if (priority == NULL)\n+    return UV_EINVAL;\n+\n+  errno = 0;\n+  r = getpriority(PRIO_PROCESS, (int) pid);\n+\n+  if (r == -1 && errno != 0)\n+    return UV__ERR(errno);\n+\n+  *priority = r;\n+  return 0;\n+}\n+\n+\n+int uv_os_setpriority(uv_pid_t pid, int priority) {\n+  if (priority < UV_PRIORITY_HIGHEST || priority > UV_PRIORITY_LOW)\n+    return UV_EINVAL;\n+\n+  if (setpriority(PRIO_PROCESS, (int) pid, priority) != 0)\n+    return UV__ERR(errno);\n+\n+  return 0;\n+}"
        },
        {
            "sha": "5a96b66b17bfd5404b7d5f3749e7b056fd64d11a",
            "filename": "deps/uv/src/unix/stream.c",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fstream.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -950,10 +950,16 @@ static void uv__write(uv_stream_t* stream) {\n static void uv__write_callbacks(uv_stream_t* stream) {\n   uv_write_t* req;\n   QUEUE* q;\n+  QUEUE pq;\n \n-  while (!QUEUE_EMPTY(&stream->write_completed_queue)) {\n+  if (QUEUE_EMPTY(&stream->write_completed_queue))\n+    return;\n+\n+  QUEUE_MOVE(&stream->write_completed_queue, &pq);\n+\n+  while (!QUEUE_EMPTY(&pq)) {\n     /* Pop a req off write_completed_queue. */\n-    q = QUEUE_HEAD(&stream->write_completed_queue);\n+    q = QUEUE_HEAD(&pq);\n     req = QUEUE_DATA(q, uv_write_t, queue);\n     QUEUE_REMOVE(q);\n     uv__req_unregister(stream->loop, req);\n@@ -969,8 +975,6 @@ static void uv__write_callbacks(uv_stream_t* stream) {\n     if (req->cb)\n       req->cb(req, req->error);\n   }\n-\n-  assert(QUEUE_EMPTY(&stream->write_completed_queue));\n }\n \n "
        },
        {
            "sha": "afdf01e7878913f88bf1f7d6be0f31db22d7d1a6",
            "filename": "deps/uv/src/win/core.c",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Fcore.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Fcore.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fcore.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -249,8 +249,10 @@ int uv_loop_init(uv_loop_t* loop) {\n   loop->endgame_handles = NULL;\n \n   loop->timer_heap = timer_heap = uv__malloc(sizeof(*timer_heap));\n-  if (timer_heap == NULL)\n+  if (timer_heap == NULL) {\n+    err = UV_ENOMEM;\n     goto fail_timers_alloc;\n+  }\n \n   heap_init(timer_heap);\n "
        },
        {
            "sha": "71785a9fa657182b5d9e9d424c80ffb004bd446b",
            "filename": "deps/uv/src/win/getnameinfo.c",
            "status": "modified",
            "additions": 28,
            "deletions": 21,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Fgetnameinfo.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Fgetnameinfo.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fgetnameinfo.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -42,7 +42,7 @@ static void uv__getnameinfo_work(struct uv__work* w) {\n   uv_getnameinfo_t* req;\n   WCHAR host[NI_MAXHOST];\n   WCHAR service[NI_MAXSERV];\n-  int ret = 0;\n+  int ret;\n \n   req = container_of(w, uv_getnameinfo_t, work_req);\n   if (GetNameInfoW((struct sockaddr*)&req->storage,\n@@ -53,27 +53,34 @@ static void uv__getnameinfo_work(struct uv__work* w) {\n                    ARRAY_SIZE(service),\n                    req->flags)) {\n     ret = WSAGetLastError();\n+    req->retcode = uv__getaddrinfo_translate_error(ret);\n+    return;\n+  }\n+\n+  ret = WideCharToMultiByte(CP_UTF8,\n+                            0,\n+                            host,\n+                            -1,\n+                            req->host,\n+                            sizeof(req->host),\n+                            NULL,\n+                            NULL);\n+  if (ret == 0) {\n+    req->retcode = uv_translate_sys_error(GetLastError());\n+    return;\n+  }\n+\n+  ret = WideCharToMultiByte(CP_UTF8,\n+                            0,\n+                            service,\n+                            -1,\n+                            req->service,\n+                            sizeof(req->service),\n+                            NULL,\n+                            NULL);\n+  if (ret == 0) {\n+    req->retcode = uv_translate_sys_error(GetLastError());\n   }\n-  req->retcode = uv__getaddrinfo_translate_error(ret);\n-\n-  /* convert results to UTF-8 */\n-  WideCharToMultiByte(CP_UTF8,\n-                      0,\n-                      host,\n-                      -1,\n-                      req->host,\n-                      sizeof(req->host),\n-                      NULL,\n-                      NULL);\n-\n-  WideCharToMultiByte(CP_UTF8,\n-                      0,\n-                      service,\n-                      -1,\n-                      req->service,\n-                      sizeof(req->service),\n-                      NULL,\n-                      NULL);\n }\n \n "
        },
        {
            "sha": "9d76c3f5420997290e5f3ecd2af50159cd2cd569",
            "filename": "deps/uv/src/win/handle.c",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Fhandle.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Fhandle.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fhandle.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -157,3 +157,7 @@ int uv_is_closing(const uv_handle_t* handle) {\n uv_os_fd_t uv_get_osfhandle(int fd) {\n   return uv__get_osfhandle(fd);\n }\n+\n+int uv_open_osfhandle(uv_os_fd_t os_fd) {\n+  return _open_osfhandle((intptr_t) os_fd, 0);\n+}"
        },
        {
            "sha": "634b9f776ccc6720e6ec4b7045be9a898ca9c5b8",
            "filename": "deps/uv/src/win/internal.h",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Finternal.h",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Finternal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Finternal.h?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -61,10 +61,15 @@ extern UV_THREAD_LOCAL int uv__crt_assert_enabled;\n  * TCP\n  */\n \n+typedef enum {\n+  UV__IPC_SOCKET_XFER_NONE = 0,\n+  UV__IPC_SOCKET_XFER_TCP_CONNECTION,\n+  UV__IPC_SOCKET_XFER_TCP_SERVER\n+} uv__ipc_socket_xfer_type_t;\n+\n typedef struct {\n   WSAPROTOCOL_INFOW socket_info;\n   uint32_t delayed_error;\n-  uint32_t flags; /* Either zero or UV_HANDLE_CONNECTION. */\n } uv__ipc_socket_xfer_info_t;\n \n int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb);\n@@ -89,8 +94,11 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle);\n \n int uv__tcp_xfer_export(uv_tcp_t* handle,\n                         int pid,\n+                        uv__ipc_socket_xfer_type_t* xfer_type,\n+                        uv__ipc_socket_xfer_info_t* xfer_info);\n+int uv__tcp_xfer_import(uv_tcp_t* tcp,\n+                        uv__ipc_socket_xfer_type_t xfer_type,\n                         uv__ipc_socket_xfer_info_t* xfer_info);\n-int uv__tcp_xfer_import(uv_tcp_t* tcp, uv__ipc_socket_xfer_info_t* xfer_info);\n \n \n /*"
        },
        {
            "sha": "382290e69f4afa85949639c4d96fed6abaaa21d5",
            "filename": "deps/uv/src/win/pipe.c",
            "status": "modified",
            "additions": 113,
            "deletions": 59,
            "changes": 172,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -25,11 +25,12 @@\n #include <stdlib.h>\n #include <string.h>\n \n-#include \"uv.h\"\n-#include \"internal.h\"\n #include \"handle-inl.h\"\n-#include \"stream-inl.h\"\n+#include \"internal.h\"\n #include \"req-inl.h\"\n+#include \"stream-inl.h\"\n+#include \"uv-common.h\"\n+#include \"uv.h\"\n \n #include <aclapi.h>\n #include <accctrl.h>\n@@ -52,19 +53,36 @@ static const int pipe_prefix_len = sizeof(pipe_prefix) - 1;\n \n /* IPC incoming xfer queue item. */\n typedef struct {\n+  uv__ipc_socket_xfer_type_t xfer_type;\n   uv__ipc_socket_xfer_info_t xfer_info;\n   QUEUE member;\n } uv__ipc_xfer_queue_item_t;\n \n-/* IPC frame types. */\n-enum { UV__IPC_DATA_FRAME = 0, UV__IPC_XFER_FRAME = 1 };\n+/* IPC frame header flags. */\n+/* clang-format off */\n+enum {\n+  UV__IPC_FRAME_HAS_DATA                = 0x01,\n+  UV__IPC_FRAME_HAS_SOCKET_XFER         = 0x02,\n+  UV__IPC_FRAME_XFER_IS_TCP_CONNECTION  = 0x04,\n+  /* These are combinations of the flags above. */\n+  UV__IPC_FRAME_XFER_FLAGS              = 0x06,\n+  UV__IPC_FRAME_VALID_FLAGS             = 0x07\n+};\n+/* clang-format on */\n \n /* IPC frame header. */\n typedef struct {\n-  uint32_t type;\n-  uint32_t payload_length;\n+  uint32_t flags;\n+  uint32_t reserved1;   /* Ignored. */\n+  uint32_t data_length; /* Must be zero if there is no data. */\n+  uint32_t reserved2;   /* Must be zero. */\n } uv__ipc_frame_header_t;\n \n+/* To implement the IPC protocol correctly, these structures must have exactly\n+ * the right size. */\n+STATIC_ASSERT(sizeof(uv__ipc_frame_header_t) == 16);\n+STATIC_ASSERT(sizeof(uv__ipc_socket_xfer_info_t) == 632);\n+\n /* Coalesced write request. */\n typedef struct {\n   uv_write_t req;       /* Internal heap-allocated write request. */\n@@ -878,7 +896,8 @@ int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client) {\n     server->pipe.conn.ipc_xfer_queue_length--;\n     item = QUEUE_DATA(q, uv__ipc_xfer_queue_item_t, member);\n \n-    err = uv__tcp_xfer_import((uv_tcp_t*) client, &item->xfer_info);\n+    err = uv__tcp_xfer_import(\n+        (uv_tcp_t*) client, item->xfer_type, &item->xfer_info);\n     if (err != 0)\n       return err;\n \n@@ -1458,10 +1477,10 @@ int uv__pipe_write_ipc(uv_loop_t* loop,\n   uv_buf_t stack_bufs[6];\n   uv_buf_t* bufs;\n   size_t buf_count, buf_index;\n-  uv__ipc_frame_header_t xfer_frame_header;\n+  uv__ipc_frame_header_t frame_header;\n+  uv__ipc_socket_xfer_type_t xfer_type = UV__IPC_SOCKET_XFER_NONE;\n   uv__ipc_socket_xfer_info_t xfer_info;\n-  uv__ipc_frame_header_t data_frame_header;\n-  size_t data_length;\n+  uint64_t data_length;\n   size_t i;\n   int err;\n \n@@ -1472,29 +1491,27 @@ int uv__pipe_write_ipc(uv_loop_t* loop,\n   if (data_length > UINT32_MAX)\n     return WSAENOBUFS; /* Maps to UV_ENOBUFS. */\n \n-  /* Prepare xfer frame payload. */\n-  if (send_handle) {\n+  /* Prepare the frame's socket xfer payload. */\n+  if (send_handle != NULL) {\n     uv_tcp_t* send_tcp_handle = (uv_tcp_t*) send_handle;\n \n     /* Verify that `send_handle` it is indeed a tcp handle. */\n     if (send_tcp_handle->type != UV_TCP)\n       return ERROR_NOT_SUPPORTED;\n \n     /* Export the tcp handle. */\n-    err = uv__tcp_xfer_export(\n-        send_tcp_handle, uv__pipe_get_ipc_remote_pid(handle), &xfer_info);\n+    err = uv__tcp_xfer_export(send_tcp_handle,\n+                              uv__pipe_get_ipc_remote_pid(handle),\n+                              &xfer_type,\n+                              &xfer_info);\n     if (err != 0)\n       return err;\n   }\n \n   /* Compute the number of uv_buf_t's required. */\n-  buf_count = 0;\n-  if (send_handle != NULL) {\n-    buf_count += 2; /* One for the frame header, one for the payload. */\n-  }\n-  if (data_buf_count > 0) {\n-    buf_count += 1 + data_buf_count; /* One extra for the frame header. */\n-  }\n+  buf_count = 1 + data_buf_count; /* Frame header and data buffers. */\n+  if (send_handle != NULL)\n+    buf_count += 1; /* One extra for the socket xfer information. */\n \n   /* Use the on-stack buffer array if it is big enough; otherwise allocate\n    * space for it on the heap. */\n@@ -1509,25 +1526,32 @@ int uv__pipe_write_ipc(uv_loop_t* loop,\n   }\n   buf_index = 0;\n \n-  if (send_handle != NULL) {\n-    /* Add xfer frame header. */\n-    xfer_frame_header.type = UV__IPC_XFER_FRAME;\n-    xfer_frame_header.payload_length = sizeof xfer_info;\n-    bufs[buf_index++] =\n-        uv_buf_init((char*) &xfer_frame_header, sizeof xfer_frame_header);\n+  /* Initialize frame header and add it to the buffers list. */\n+  memset(&frame_header, 0, sizeof frame_header);\n+  bufs[buf_index++] = uv_buf_init((char*) &frame_header, sizeof frame_header);\n \n-    /* Add xfer frame payload. */\n+  if (send_handle != NULL) {\n+    /* Add frame header flags. */\n+    switch (xfer_type) {\n+      case UV__IPC_SOCKET_XFER_TCP_CONNECTION:\n+        frame_header.flags |= UV__IPC_FRAME_HAS_SOCKET_XFER |\n+                              UV__IPC_FRAME_XFER_IS_TCP_CONNECTION;\n+        break;\n+      case UV__IPC_SOCKET_XFER_TCP_SERVER:\n+        frame_header.flags |= UV__IPC_FRAME_HAS_SOCKET_XFER;\n+        break;\n+      default:\n+        assert(0);  // Unreachable.\n+    }\n+    /* Add xfer info buffer. */\n     bufs[buf_index++] = uv_buf_init((char*) &xfer_info, sizeof xfer_info);\n   }\n \n   if (data_length > 0) {\n-    /* Add data frame header. */\n-    data_frame_header.type = UV__IPC_DATA_FRAME;\n-    data_frame_header.payload_length = (uint32_t) data_length;\n-    bufs[buf_index++] =\n-        uv_buf_init((char*) &data_frame_header, sizeof data_frame_header);\n-\n-    /* Add data buffers. */\n+    /* Update frame header. */\n+    frame_header.flags |= UV__IPC_FRAME_HAS_DATA;\n+    frame_header.data_length = (uint32_t) data_length;\n+    /* Add data buffers to buffers list. */\n     for (i = 0; i < data_buf_count; i++)\n       bufs[buf_index++] = data_bufs[i];\n   }\n@@ -1601,14 +1625,18 @@ static void uv_pipe_read_error_or_eof(uv_loop_t* loop, uv_pipe_t* handle,\n \n \n static void uv__pipe_queue_ipc_xfer_info(\n-    uv_pipe_t* handle, uv__ipc_socket_xfer_info_t* xfer_info) {\n+    uv_pipe_t* handle,\n+    uv__ipc_socket_xfer_type_t xfer_type,\n+    uv__ipc_socket_xfer_info_t* xfer_info) {\n   uv__ipc_xfer_queue_item_t* item;\n \n   item = (uv__ipc_xfer_queue_item_t*) uv__malloc(sizeof(*item));\n   if (item == NULL)\n     uv_fatal_error(ERROR_OUTOFMEMORY, \"uv__malloc\");\n \n-  memcpy(&item->xfer_info, xfer_info, sizeof(item->xfer_info));\n+  item->xfer_type = xfer_type;\n+  item->xfer_info = *xfer_info;\n+\n   QUEUE_INSERT_TAIL(&handle->pipe.conn.ipc_xfer_queue, &item->member);\n   handle->pipe.conn.ipc_xfer_queue_length++;\n }\n@@ -1678,7 +1706,7 @@ static DWORD uv__pipe_read_ipc(uv_loop_t* loop, uv_pipe_t* handle) {\n   int err;\n \n   if (*data_remaining > 0) {\n-    /* Read data frame payload. */\n+    /* Read frame data payload. */\n     DWORD bytes_read =\n         uv__pipe_read_data(loop, handle, *data_remaining, *data_remaining);\n     *data_remaining -= bytes_read;\n@@ -1687,6 +1715,8 @@ static DWORD uv__pipe_read_ipc(uv_loop_t* loop, uv_pipe_t* handle) {\n   } else {\n     /* Start of a new IPC frame. */\n     uv__ipc_frame_header_t frame_header;\n+    uint32_t xfer_flags;\n+    uv__ipc_socket_xfer_type_t xfer_type;\n     uv__ipc_socket_xfer_info_t xfer_info;\n \n     /* Read the IPC frame header. */\n@@ -1695,33 +1725,57 @@ static DWORD uv__pipe_read_ipc(uv_loop_t* loop, uv_pipe_t* handle) {\n     if (err)\n       goto error;\n \n-    if (frame_header.type == UV__IPC_DATA_FRAME) {\n-      /* Data frame: capture payload length. Actual data will be read in\n-       * subsequent call to uv__pipe_read_ipc(). */\n-      *data_remaining = frame_header.payload_length;\n+    /* Validate that flags are valid. */\n+    if ((frame_header.flags & ~UV__IPC_FRAME_VALID_FLAGS) != 0)\n+      goto invalid;\n+    /* Validate that reserved2 is zero. */\n+    if (frame_header.reserved2 != 0)\n+      goto invalid;\n+\n+    /* Parse xfer flags. */\n+    xfer_flags = frame_header.flags & UV__IPC_FRAME_XFER_FLAGS;\n+    if (xfer_flags & UV__IPC_FRAME_HAS_SOCKET_XFER) {\n+      /* Socket coming -- determine the type. */\n+      xfer_type = xfer_flags & UV__IPC_FRAME_XFER_IS_TCP_CONNECTION\n+                      ? UV__IPC_SOCKET_XFER_TCP_CONNECTION\n+                      : UV__IPC_SOCKET_XFER_TCP_SERVER;\n+    } else if (xfer_flags == 0) {\n+      /* No socket. */\n+      xfer_type = UV__IPC_SOCKET_XFER_NONE;\n+    } else {\n+      /* Invalid flags. */\n+      goto invalid;\n+    }\n \n-      /* Return number of bytes read. */\n-      return sizeof frame_header;\n+    /* Parse data frame information. */\n+    if (frame_header.flags & UV__IPC_FRAME_HAS_DATA) {\n+      *data_remaining = frame_header.data_length;\n+    } else if (frame_header.data_length != 0) {\n+      /* Data length greater than zero but data flag not set -- invalid. */\n+      goto invalid;\n+    }\n \n-    } else if (frame_header.type == UV__IPC_XFER_FRAME) {\n-      /* Xfer frame: read the payload. */\n-      assert(frame_header.payload_length == sizeof xfer_info);\n-      err =\n-          uv__pipe_read_exactly(handle->handle, &xfer_info, sizeof xfer_info);\n-      if (err)\n-        goto error;\n+    /* If no socket xfer info follows, return here. Data will be read in a\n+     * subsequent invocation of uv__pipe_read_ipc(). */\n+    if (xfer_type == UV__IPC_SOCKET_XFER_NONE)\n+      return sizeof frame_header; /* Number of bytes read. */\n \n-      /* Store the pending socket info. */\n-      uv__pipe_queue_ipc_xfer_info(handle, &xfer_info);\n+    /* Read transferred socket information. */\n+    err = uv__pipe_read_exactly(handle->handle, &xfer_info, sizeof xfer_info);\n+    if (err)\n+      goto error;\n \n-      /* Return number of bytes read. */\n-      return sizeof frame_header + sizeof xfer_info;\n-    }\n+    /* Store the pending socket info. */\n+    uv__pipe_queue_ipc_xfer_info(handle, xfer_type, &xfer_info);\n \n-    /* Invalid frame. */\n-    err = WSAECONNABORTED; /* Maps to UV_ECONNABORTED. */\n+    /* Return number of bytes read. */\n+    return sizeof frame_header + sizeof xfer_info;\n   }\n \n+invalid:\n+  /* Invalid frame. */\n+  err = WSAECONNABORTED; /* Maps to UV_ECONNABORTED. */\n+\n error:\n   uv_pipe_read_error_or_eof(loop, handle, err, uv_null_buf_);\n   return 0; /* Break out of read loop. */"
        },
        {
            "sha": "8b6f0a5c99bd70e94551b1b15954e240a0111a84",
            "filename": "deps/uv/src/win/tcp.c",
            "status": "modified",
            "additions": 21,
            "deletions": 13,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Ftcp.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Ftcp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ftcp.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -1191,8 +1191,12 @@ void uv_process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,\n \n int uv__tcp_xfer_export(uv_tcp_t* handle,\n                         int target_pid,\n+                        uv__ipc_socket_xfer_type_t* xfer_type,\n                         uv__ipc_socket_xfer_info_t* xfer_info) {\n-  if (!(handle->flags & UV_HANDLE_CONNECTION)) {\n+  if (handle->flags & UV_HANDLE_CONNECTION) {\n+    *xfer_type = UV__IPC_SOCKET_XFER_TCP_CONNECTION;\n+  } else {\n+    *xfer_type = UV__IPC_SOCKET_XFER_TCP_SERVER;\n     /* We're about to share the socket with another process. Because this is a\n      * listening socket, we assume that the other process will be accepting\n      * connections on it. Thus, before sharing the socket with another process,\n@@ -1208,12 +1212,9 @@ int uv__tcp_xfer_export(uv_tcp_t* handle,\n     }\n   }\n \n-  if (WSADuplicateSocketW(\n-          handle->socket, target_pid, &xfer_info->socket_info)) {\n+  if (WSADuplicateSocketW(handle->socket, target_pid, &xfer_info->socket_info))\n     return WSAGetLastError();\n-  }\n   xfer_info->delayed_error = handle->delayed_error;\n-  xfer_info->flags = handle->flags & UV_HANDLE_CONNECTION;\n \n   /* Mark the local copy of the handle as 'shared' so we behave in a way that's\n    * friendly to the process(es) that we share the socket with. */\n@@ -1223,14 +1224,21 @@ int uv__tcp_xfer_export(uv_tcp_t* handle,\n }\n \n \n-int uv__tcp_xfer_import(uv_tcp_t* tcp, uv__ipc_socket_xfer_info_t* xfer_info) {\n+int uv__tcp_xfer_import(uv_tcp_t* tcp,\n+                        uv__ipc_socket_xfer_type_t xfer_type,\n+                        uv__ipc_socket_xfer_info_t* xfer_info) {\n   int err;\n-  SOCKET socket = WSASocketW(FROM_PROTOCOL_INFO,\n-                             FROM_PROTOCOL_INFO,\n-                             FROM_PROTOCOL_INFO,\n-                             &xfer_info->socket_info,\n-                             0,\n-                             WSA_FLAG_OVERLAPPED);\n+  SOCKET socket;\n+\n+  assert(xfer_type == UV__IPC_SOCKET_XFER_TCP_SERVER ||\n+         xfer_type == UV__IPC_SOCKET_XFER_TCP_CONNECTION);\n+\n+  socket = WSASocketW(FROM_PROTOCOL_INFO,\n+                      FROM_PROTOCOL_INFO,\n+                      FROM_PROTOCOL_INFO,\n+                      &xfer_info->socket_info,\n+                      0,\n+                      WSA_FLAG_OVERLAPPED);\n \n   if (socket == INVALID_SOCKET) {\n     return WSAGetLastError();\n@@ -1246,7 +1254,7 @@ int uv__tcp_xfer_import(uv_tcp_t* tcp, uv__ipc_socket_xfer_info_t* xfer_info) {\n   tcp->delayed_error = xfer_info->delayed_error;\n   tcp->flags |= UV_HANDLE_BOUND | UV_HANDLE_SHARED_TCP_SOCKET;\n \n-  if (xfer_info->flags & UV_HANDLE_CONNECTION) {\n+  if (xfer_type == UV__IPC_SOCKET_XFER_TCP_CONNECTION) {\n     uv_connection_init((uv_stream_t*)tcp);\n     tcp->flags |= UV_HANDLE_READABLE | UV_HANDLE_WRITABLE;\n   }"
        },
        {
            "sha": "c994984fe65a252da9e7bead81f3870a5843beb0",
            "filename": "deps/uv/src/win/util.c",
            "status": "modified",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Futil.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Fsrc%2Fwin%2Futil.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Futil.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -1530,3 +1530,97 @@ int uv_os_gethostname(char* buffer, size_t* size) {\n   *size = len;\n   return 0;\n }\n+\n+\n+static int uv__get_handle(uv_pid_t pid, int access, HANDLE* handle) {\n+  int r;\n+\n+  if (pid == 0)\n+    *handle = GetCurrentProcess();\n+  else\n+    *handle = OpenProcess(access, FALSE, pid);\n+\n+  if (*handle == NULL) {\n+    r = GetLastError();\n+\n+    if (r == ERROR_INVALID_PARAMETER)\n+      return UV_ESRCH;\n+    else\n+      return uv_translate_sys_error(r);\n+  }\n+\n+  return 0;\n+}\n+\n+\n+int uv_os_getpriority(uv_pid_t pid, int* priority) {\n+  HANDLE handle;\n+  int r;\n+\n+  if (priority == NULL)\n+    return UV_EINVAL;\n+\n+  r = uv__get_handle(pid, PROCESS_QUERY_LIMITED_INFORMATION, &handle);\n+\n+  if (r != 0)\n+    return r;\n+\n+  r = GetPriorityClass(handle);\n+\n+  if (r == 0) {\n+    r = uv_translate_sys_error(GetLastError());\n+  } else {\n+    /* Map Windows priority classes to Unix nice values. */\n+    if (r == REALTIME_PRIORITY_CLASS)\n+      *priority = UV_PRIORITY_HIGHEST;\n+    else if (r == HIGH_PRIORITY_CLASS)\n+      *priority = UV_PRIORITY_HIGH;\n+    else if (r == ABOVE_NORMAL_PRIORITY_CLASS)\n+      *priority = UV_PRIORITY_ABOVE_NORMAL;\n+    else if (r == NORMAL_PRIORITY_CLASS)\n+      *priority = UV_PRIORITY_NORMAL;\n+    else if (r == BELOW_NORMAL_PRIORITY_CLASS)\n+      *priority = UV_PRIORITY_BELOW_NORMAL;\n+    else  /* IDLE_PRIORITY_CLASS */\n+      *priority = UV_PRIORITY_LOW;\n+\n+    r = 0;\n+  }\n+\n+  CloseHandle(handle);\n+  return r;\n+}\n+\n+\n+int uv_os_setpriority(uv_pid_t pid, int priority) {\n+  HANDLE handle;\n+  int priority_class;\n+  int r;\n+\n+  /* Map Unix nice values to Windows priority classes. */\n+  if (priority < UV_PRIORITY_HIGHEST || priority > UV_PRIORITY_LOW)\n+    return UV_EINVAL;\n+  else if (priority < UV_PRIORITY_HIGH)\n+    priority_class = REALTIME_PRIORITY_CLASS;\n+  else if (priority < UV_PRIORITY_ABOVE_NORMAL)\n+    priority_class = HIGH_PRIORITY_CLASS;\n+  else if (priority < UV_PRIORITY_NORMAL)\n+    priority_class = ABOVE_NORMAL_PRIORITY_CLASS;\n+  else if (priority < UV_PRIORITY_BELOW_NORMAL)\n+    priority_class = NORMAL_PRIORITY_CLASS;\n+  else if (priority < UV_PRIORITY_LOW)\n+    priority_class = BELOW_NORMAL_PRIORITY_CLASS;\n+  else\n+    priority_class = IDLE_PRIORITY_CLASS;\n+\n+  r = uv__get_handle(pid, PROCESS_SET_INFORMATION, &handle);\n+\n+  if (r != 0)\n+    return r;\n+\n+  if (SetPriorityClass(handle, priority_class) == 0)\n+    r = uv_translate_sys_error(GetLastError());\n+\n+  CloseHandle(handle);\n+  return r;\n+}"
        },
        {
            "sha": "9c1e8bec205f5d9e699a99075a0221a4ff9c81bc",
            "filename": "deps/uv/test/test-fs.c",
            "status": "modified",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest-fs.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest-fs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fs.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -3069,6 +3069,52 @@ TEST_IMPL(get_osfhandle_valid_handle) {\n   return 0;\n }\n \n+TEST_IMPL(open_osfhandle_valid_handle) {\n+  int r;\n+  uv_os_fd_t handle;\n+  int fd;\n+\n+  /* Setup. */\n+  unlink(\"test_file\");\n+\n+  loop = uv_default_loop();\n+\n+  r = uv_fs_open(NULL,\n+                 &open_req1,\n+                 \"test_file\",\n+                 O_RDWR | O_CREAT,\n+                 S_IWUSR | S_IRUSR,\n+                 NULL);\n+  ASSERT(r >= 0);\n+  ASSERT(open_req1.result >= 0);\n+  uv_fs_req_cleanup(&open_req1);\n+\n+  handle = uv_get_osfhandle(open_req1.result);\n+#ifdef _WIN32\n+  ASSERT(handle != INVALID_HANDLE_VALUE);\n+#else\n+  ASSERT(handle >= 0);\n+#endif\n+\n+  fd = uv_open_osfhandle(handle);\n+#ifdef _WIN32\n+  ASSERT(fd > 0);\n+#else\n+  ASSERT(fd == open_req1.result);\n+#endif\n+\n+  r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);\n+  ASSERT(r == 0);\n+  ASSERT(close_req.result == 0);\n+  uv_fs_req_cleanup(&close_req);\n+\n+  /* Cleanup. */\n+  unlink(\"test_file\");\n+\n+  MAKE_VALGRIND_HAPPY();\n+  return 0;\n+}\n+\n TEST_IMPL(fs_file_pos_after_op_with_offset) {\n   int r;\n "
        },
        {
            "sha": "b501722d4dc83badede0e744556086a77e68cee6",
            "filename": "deps/uv/test/test-list.h",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest-list.h",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest-list.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-list.h?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -121,6 +121,7 @@ TEST_DECLARE   (tcp_bind6_error_addrnotavail)\n TEST_DECLARE   (tcp_bind6_error_fault)\n TEST_DECLARE   (tcp_bind6_error_inval)\n TEST_DECLARE   (tcp_bind6_localhost_ok)\n+TEST_DECLARE   (tcp_write_ready)\n TEST_DECLARE   (udp_alloc_cb_fail)\n TEST_DECLARE   (udp_bind)\n TEST_DECLARE   (udp_bind_reuseaddr)\n@@ -213,6 +214,7 @@ TEST_DECLARE   (pipe_close_stdout_read_stdin)\n TEST_DECLARE   (pipe_set_non_blocking)\n TEST_DECLARE   (pipe_set_chmod)\n TEST_DECLARE   (process_ref)\n+TEST_DECLARE   (process_priority)\n TEST_DECLARE   (has_ref)\n TEST_DECLARE   (active)\n TEST_DECLARE   (embed)\n@@ -334,6 +336,7 @@ TEST_DECLARE   (fs_rename_to_existing_file)\n TEST_DECLARE   (fs_write_multiple_bufs)\n TEST_DECLARE   (fs_read_write_null_arguments)\n TEST_DECLARE   (get_osfhandle_valid_handle)\n+TEST_DECLARE   (open_osfhandle_valid_handle)\n TEST_DECLARE   (fs_write_alotof_bufs)\n TEST_DECLARE   (fs_write_alotof_bufs_with_offset)\n TEST_DECLARE   (fs_file_pos_after_op_with_offset)\n@@ -544,6 +547,8 @@ TASK_LIST_START\n   TEST_ENTRY  (tcp_open_bound)\n   TEST_ENTRY  (tcp_open_connected)\n   TEST_HELPER (tcp_open_connected, tcp4_echo_server)\n+  TEST_ENTRY  (tcp_write_ready)\n+  TEST_HELPER (tcp_write_ready, tcp4_echo_server)\n \n   TEST_ENTRY  (tcp_shutdown_after_write)\n   TEST_HELPER (tcp_shutdown_after_write, tcp4_echo_server)\n@@ -685,6 +690,7 @@ TASK_LIST_START\n   TEST_ENTRY  (pipe_ref4)\n   TEST_HELPER (pipe_ref4, pipe_echo_server)\n   TEST_ENTRY  (process_ref)\n+  TEST_ENTRY  (process_priority)\n   TEST_ENTRY  (has_ref)\n \n   TEST_ENTRY  (loop_handles)\n@@ -887,6 +893,7 @@ TASK_LIST_START\n   TEST_ENTRY  (fs_fchmod_archive_readonly)\n #endif\n   TEST_ENTRY  (get_osfhandle_valid_handle)\n+  TEST_ENTRY  (open_osfhandle_valid_handle)\n   TEST_ENTRY  (threadpool_queue_work_simple)\n   TEST_ENTRY  (threadpool_queue_work_einval)\n   TEST_ENTRY  (threadpool_multiple_event_loops)"
        },
        {
            "sha": "ebee6b90afd5558735213b0893dde0e37534a524",
            "filename": "deps/uv/test/test-process-priority.c",
            "status": "added",
            "additions": 81,
            "deletions": 0,
            "changes": 81,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest-process-priority.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest-process-priority.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-process-priority.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -0,0 +1,81 @@\n+/* Copyright libuv contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+\n+\n+TEST_IMPL(process_priority) {\n+  int priority;\n+  int r;\n+  int i;\n+\n+#if defined(__MVS__)\n+  if (uv_os_setpriority(0, 0) == UV_ENOSYS)\n+    RETURN_SKIP(\"functionality not supported on zOS\");\n+#endif\n+\n+  /* Verify that passing a NULL pointer returns UV_EINVAL. */\n+  r = uv_os_getpriority(0, NULL);\n+  ASSERT(r == UV_EINVAL);\n+\n+  /* Verify that all valid values work. */\n+  for (i = UV_PRIORITY_HIGHEST; i <= UV_PRIORITY_LOW; i++) {\n+    r = uv_os_setpriority(0, i);\n+\n+    /* If UV_EACCES is returned, the current user doesn't have permission to\n+       set this specific priority. */\n+    if (r == UV_EACCES)\n+      continue;\n+\n+    ASSERT(r == 0);\n+    ASSERT(uv_os_getpriority(0, &priority) == 0);\n+\n+    /* Verify that the priority values match on Unix, and are range mapped\n+       on Windows. */\n+#ifndef _WIN32\n+    ASSERT(priority == i);\n+#else\n+    if (i < UV_PRIORITY_HIGH)\n+      ASSERT(priority == UV_PRIORITY_HIGHEST);\n+    else if (i < UV_PRIORITY_ABOVE_NORMAL)\n+      ASSERT(priority == UV_PRIORITY_HIGH);\n+    else if (i < UV_PRIORITY_NORMAL)\n+      ASSERT(priority == UV_PRIORITY_ABOVE_NORMAL);\n+    else if (i < UV_PRIORITY_BELOW_NORMAL)\n+      ASSERT(priority == UV_PRIORITY_NORMAL);\n+    else if (i < UV_PRIORITY_LOW)\n+      ASSERT(priority == UV_PRIORITY_BELOW_NORMAL);\n+    else\n+      ASSERT(priority == UV_PRIORITY_LOW);\n+#endif\n+\n+    /* Verify that the current PID and 0 are equivalent. */\n+    ASSERT(uv_os_getpriority(uv_os_getpid(), &r) == 0);\n+    ASSERT(priority == r);\n+  }\n+\n+  /* Verify that invalid priorities return UV_EINVAL. */\n+  ASSERT(uv_os_setpriority(0, UV_PRIORITY_HIGHEST - 1) == UV_EINVAL);\n+  ASSERT(uv_os_setpriority(0, UV_PRIORITY_LOW + 1) == UV_EINVAL);\n+\n+  return 0;\n+}"
        },
        {
            "sha": "0d92886d61f2259544a5c36a53de6b5830c0745f",
            "filename": "deps/uv/test/test-tcp-open.c",
            "status": "modified",
            "additions": 110,
            "deletions": 1,
            "changes": 111,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest-tcp-open.c",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest-tcp-open.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-tcp-open.c?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -30,13 +30,16 @@\n #endif\n \n static int shutdown_cb_called = 0;\n+static int shutdown_requested = 0;\n static int connect_cb_called = 0;\n static int write_cb_called = 0;\n static int close_cb_called = 0;\n \n static uv_connect_t connect_req;\n static uv_shutdown_t shutdown_req;\n static uv_write_t write_req;\n+static uv_timer_t tm;\n+static uv_tcp_t client;\n \n \n static void startup(void) {\n@@ -115,6 +118,20 @@ static void read_cb(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf) {\n     ASSERT(memcmp(\"PING\", buf->base, nread) == 0);\n   }\n   else {\n+    ASSERT(nread == UV_EOF);\n+    uv_close((uv_handle_t*)tcp, close_cb);\n+  }\n+}\n+\n+\n+static void read1_cb(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf) {\n+  int i;\n+  ASSERT(tcp != NULL);\n+\n+  if (nread >= 0) {\n+    for (i = 0; i < nread; ++i)\n+      ASSERT(buf->base[i] == 'P');\n+  } else {\n     ASSERT(nread == UV_EOF);\n     printf(\"GOT EOF\\n\");\n     uv_close((uv_handle_t*)tcp, close_cb);\n@@ -134,6 +151,37 @@ static void write_cb(uv_write_t* req, int status) {\n }\n \n \n+static void write1_cb(uv_write_t* req, int status) {\n+  uv_buf_t buf;\n+  int r;\n+\n+  ASSERT(req != NULL);\n+  if (status) {\n+    ASSERT(shutdown_cb_called);\n+    return;\n+  }\n+\n+  if (shutdown_requested)\n+    return;\n+\n+  buf = uv_buf_init(\"P\", 1);\n+  r = uv_write(&write_req, req->handle, &buf, 1, write1_cb);\n+  ASSERT(r == 0);\n+\n+  write_cb_called++;\n+}\n+\n+\n+static void timer_cb(uv_timer_t* handle) {\n+  int r;\n+\n+  /* Shutdown on drain. */\n+  r = uv_shutdown(&shutdown_req, (uv_stream_t*) &client, shutdown_cb);\n+  ASSERT(r == 0);\n+  shutdown_requested++;\n+}\n+\n+\n static void connect_cb(uv_connect_t* req, int status) {\n   uv_buf_t buf = uv_buf_init(\"PING\", 4);\n   uv_stream_t* stream;\n@@ -158,9 +206,35 @@ static void connect_cb(uv_connect_t* req, int status) {\n }\n \n \n+static void connect1_cb(uv_connect_t* req, int status) {\n+  uv_buf_t buf;\n+  uv_stream_t* stream;\n+  int r;\n+\n+  ASSERT(req == &connect_req);\n+  ASSERT(status == 0);\n+\n+  stream = req->handle;\n+  connect_cb_called++;\n+\n+  r = uv_timer_init(uv_default_loop(), &tm);\n+  ASSERT(r == 0);\n+\n+  r = uv_timer_start(&tm, timer_cb, 2000, 0);\n+  ASSERT(r == 0);\n+\n+  buf = uv_buf_init(\"P\", 1);\n+  r = uv_write(&write_req, stream, &buf, 1, write1_cb);\n+  ASSERT(r == 0);\n+\n+  /* Start reading */\n+  r = uv_read_start(stream, alloc_cb, read1_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n TEST_IMPL(tcp_open) {\n   struct sockaddr_in addr;\n-  uv_tcp_t client;\n   uv_os_sock_t sock;\n   int r;\n \n@@ -289,3 +363,38 @@ TEST_IMPL(tcp_open_connected) {\n   MAKE_VALGRIND_HAPPY();\n   return 0;\n }\n+\n+\n+TEST_IMPL(tcp_write_ready) {\n+  struct sockaddr_in addr;\n+  uv_os_sock_t sock;\n+  int r;\n+\n+  ASSERT(0 == uv_ip4_addr(\"127.0.0.1\", TEST_PORT, &addr));\n+\n+  startup();\n+  sock = create_tcp_socket();\n+\n+  r = uv_tcp_init(uv_default_loop(), &client);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_open(&client, sock);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_connect(&connect_req,\n+                     &client,\n+                     (const struct sockaddr*) &addr,\n+                     connect1_cb);\n+  ASSERT(r == 0);\n+\n+  uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n+\n+  ASSERT(shutdown_cb_called == 1);\n+  ASSERT(shutdown_requested == 1);\n+  ASSERT(connect_cb_called == 1);\n+  ASSERT(write_cb_called > 0);\n+  ASSERT(close_cb_called == 1);\n+\n+  MAKE_VALGRIND_HAPPY();\n+  return 0;\n+}"
        },
        {
            "sha": "855eda1c50003a4449c10b4f0206006648b250d7",
            "filename": "deps/uv/test/test.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/4e7d82945dfc3f9e264c258ef29c45910b7fd8bc/deps%2Fuv%2Ftest%2Ftest.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest.gyp?ref=4e7d82945dfc3f9e264c258ef29c45910b7fd8bc",
            "patch": "@@ -80,6 +80,7 @@\n         'test-poll-close-doesnt-corrupt-stack.c',\n         'test-poll-closesocket.c',\n         'test-poll-oob.c',\n+        'test-process-priority.c',\n         'test-process-title.c',\n         'test-process-title-threadsafe.c',\n         'test-queue-foreach-delete.c',"
        }
    ],
    "stats": {
        "total": 737,
        "additions": 633,
        "deletions": 104
    }
}