{
    "author": "addaleax",
    "message": "src: keep track of open requests\n\nWorkers cannot shut down while requests are open, so keep a counter\nthat is increased whenever libuv requests are made and decreased\nwhenever their callback is called.\n\nThis also applies to other embedders, who may want to shut down\nan `Environment` instance early.\n\nMany thanks for Stephen Belanger for reviewing the original version of\nthis commit in the Ayo.js project.\n\nFixes: https://github.com/nodejs/node/issues/20517\nRefs: https://github.com/ayojs/ayo/pull/85\nPR-URL: https://github.com/nodejs/node/pull/19377\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "1db0039c505c6081f1d0d84cc24133ed6659e539",
    "files": [
        {
            "sha": "f115656353cff343b18ae8326362c961d2336063",
            "filename": "src/env-inl.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fenv-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fenv-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv-inl.h?ref=1db0039c505c6081f1d0d84cc24133ed6659e539",
            "patch": "@@ -371,6 +371,15 @@ inline void Environment::CloseHandle(T* handle, OnCloseCallback callback) {\n   });\n }\n \n+void Environment::IncreaseWaitingRequestCounter() {\n+  request_waiting_++;\n+}\n+\n+void Environment::DecreaseWaitingRequestCounter() {\n+  request_waiting_--;\n+  CHECK_GE(request_waiting_, 0);\n+}\n+\n inline uv_loop_t* Environment::event_loop() const {\n   return isolate_data()->event_loop();\n }"
        },
        {
            "sha": "e5b9c0fd6aad4ef7836bb8d82cb72863debd1fef",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=1db0039c505c6081f1d0d84cc24133ed6659e539",
            "patch": "@@ -107,7 +107,6 @@ Environment::Environment(IsolateData* isolate_data,\n #if HAVE_INSPECTOR\n       inspector_agent_(new inspector::Agent(this)),\n #endif\n-      handle_cleanup_waiting_(0),\n       http_parser_buffer_(nullptr),\n       fs_stats_field_array_(isolate_, kFsStatsFieldsLength * 2),\n       context_(context->GetIsolate(), context) {\n@@ -241,8 +240,11 @@ void Environment::CleanupHandles() {\n     hc.cb_(this, hc.handle_, hc.arg_);\n   handle_cleanup_queue_.clear();\n \n-  while (handle_cleanup_waiting_ != 0 || !handle_wrap_queue_.IsEmpty())\n+  while (handle_cleanup_waiting_ != 0 ||\n+         request_waiting_ != 0 ||\n+         !handle_wrap_queue_.IsEmpty()) {\n     uv_run(event_loop(), UV_RUN_ONCE);\n+  }\n }\n \n void Environment::StartProfilerIdleNotifier() {"
        },
        {
            "sha": "de3014249ea852767e1798a67294d2567f1ecda7",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=1db0039c505c6081f1d0d84cc24133ed6659e539",
            "patch": "@@ -601,6 +601,9 @@ class Environment {\n   inline uv_check_t* immediate_check_handle();\n   inline uv_idle_t* immediate_idle_handle();\n \n+  inline void IncreaseWaitingRequestCounter();\n+  inline void DecreaseWaitingRequestCounter();\n+\n   inline AsyncHooks* async_hooks();\n   inline ImmediateInfo* immediate_info();\n   inline TickInfo* tick_info();\n@@ -833,7 +836,8 @@ class Environment {\n   HandleWrapQueue handle_wrap_queue_;\n   ReqWrapQueue req_wrap_queue_;\n   std::list<HandleCleanup> handle_cleanup_queue_;\n-  int handle_cleanup_waiting_;\n+  int handle_cleanup_waiting_ = 0;\n+  int request_waiting_ = 0;\n \n   double* heap_statistics_buffer_ = nullptr;\n   double* heap_space_statistics_buffer_ = nullptr;"
        },
        {
            "sha": "91a47a12d92751d24bb9b62dc25e3e2fde3f25e3",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=1db0039c505c6081f1d0d84cc24133ed6659e539",
            "patch": "@@ -3388,6 +3388,9 @@ class Work : public node::AsyncResource {\n       // Establish a handle scope here so that every callback doesn't have to.\n       // Also it is needed for the exception-handling below.\n       v8::HandleScope scope(env->isolate);\n+      node::Environment* env_ = node::Environment::GetCurrent(env->isolate);\n+      env_->DecreaseWaitingRequestCounter();\n+\n       CallbackScope callback_scope(work);\n \n       NAPI_CALL_INTO_MODULE(env,\n@@ -3488,6 +3491,8 @@ napi_status napi_queue_async_work(napi_env env, napi_async_work work) {\n \n   uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);\n \n+  node::Environment* env_ = node::Environment::GetCurrent(env->isolate);\n+  env_->IncreaseWaitingRequestCounter();\n   CALL_UV(env, uv_queue_work(event_loop,\n                              w->Request(),\n                              uvimpl::Work::ExecuteCallback,"
        },
        {
            "sha": "10e4f593914ae896c32fef802746e6da68945274",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=1db0039c505c6081f1d0d84cc24133ed6659e539",
            "patch": "@@ -4639,9 +4639,12 @@ void PBKDF2Request::After() {\n \n \n void PBKDF2Request::After(uv_work_t* work_req, int status) {\n-  CHECK_EQ(status, 0);\n   std::unique_ptr<PBKDF2Request> req(\n       ContainerOf(&PBKDF2Request::work_req_, work_req));\n+  req->env()->DecreaseWaitingRequestCounter();\n+  if (status == UV_ECANCELED)\n+    return;\n+  CHECK_EQ(status, 0);\n   req->After();\n }\n \n@@ -4692,6 +4695,7 @@ void PBKDF2(const FunctionCallbackInfo<Value>& args) {\n   if (args[5]->IsFunction()) {\n     obj->Set(env->context(), env->ondone_string(), args[5]).FromJust();\n \n+    env->IncreaseWaitingRequestCounter();\n     uv_queue_work(env->event_loop(),\n                   req.release()->work_req(),\n                   PBKDF2Request::Work,\n@@ -4831,10 +4835,13 @@ void RandomBytesCheck(RandomBytesRequest* req, Local<Value> (*argv)[2]) {\n \n \n void RandomBytesAfter(uv_work_t* work_req, int status) {\n-  CHECK_EQ(status, 0);\n   std::unique_ptr<RandomBytesRequest> req(\n       ContainerOf(&RandomBytesRequest::work_req_, work_req));\n   Environment* env = req->env();\n+  env->DecreaseWaitingRequestCounter();\n+  if (status == UV_ECANCELED)\n+    return;\n+  CHECK_EQ(status, 0);\n   HandleScope handle_scope(env->isolate());\n   Context::Scope context_scope(env->context());\n   Local<Value> argv[2];\n@@ -4874,6 +4881,7 @@ void RandomBytes(const FunctionCallbackInfo<Value>& args) {\n   if (args[1]->IsFunction()) {\n     obj->Set(env->context(), env->ondone_string(), args[1]).FromJust();\n \n+    env->IncreaseWaitingRequestCounter();\n     uv_queue_work(env->event_loop(),\n                   req.release()->work_req(),\n                   RandomBytesWork,\n@@ -4913,6 +4921,7 @@ void RandomBytesBuffer(const FunctionCallbackInfo<Value>& args) {\n   if (args[3]->IsFunction()) {\n     obj->Set(env->context(), env->ondone_string(), args[3]).FromJust();\n \n+    env->IncreaseWaitingRequestCounter();\n     uv_queue_work(env->event_loop(),\n                   req.release()->work_req(),\n                   RandomBytesWork,"
        },
        {
            "sha": "3249905dfbfaf9c1d56dc35f36f9709f01966e6f",
            "filename": "src/node_zlib.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fnode_zlib.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Fnode_zlib.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_zlib.cc?ref=1db0039c505c6081f1d0d84cc24133ed6659e539",
            "patch": "@@ -214,6 +214,7 @@ class ZCtx : public AsyncWrap {\n     }\n \n     // async version\n+    env->IncreaseWaitingRequestCounter();\n     uv_queue_work(env->event_loop(), work_req, ZCtx::Process, ZCtx::After);\n   }\n \n@@ -361,10 +362,17 @@ class ZCtx : public AsyncWrap {\n \n   // v8 land!\n   static void After(uv_work_t* work_req, int status) {\n-    CHECK_EQ(status, 0);\n-\n     ZCtx* ctx = ContainerOf(&ZCtx::work_req_, work_req);\n     Environment* env = ctx->env();\n+    ctx->write_in_progress_ = false;\n+\n+    env->DecreaseWaitingRequestCounter();\n+    if (status == UV_ECANCELED) {\n+      ctx->Close();\n+      return;\n+    }\n+\n+    CHECK_EQ(status, 0);\n \n     HandleScope handle_scope(env->isolate());\n     Context::Scope context_scope(env->context());\n@@ -374,7 +382,6 @@ class ZCtx : public AsyncWrap {\n \n     ctx->write_result_[0] = ctx->strm_.avail_out;\n     ctx->write_result_[1] = ctx->strm_.avail_in;\n-    ctx->write_in_progress_ = false;\n \n     // call the write() cb\n     Local<Function> cb = PersistentToLocal(env->isolate(),"
        },
        {
            "sha": "e3b26c1f5c6030e88ff3d95d37b2e4f10032662c",
            "filename": "src/req_wrap-inl.h",
            "status": "modified",
            "additions": 28,
            "deletions": 15,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Freq_wrap-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Freq_wrap-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Freq_wrap-inl.h?ref=1db0039c505c6081f1d0d84cc24133ed6659e539",
            "patch": "@@ -20,6 +20,8 @@ ReqWrap<T>::ReqWrap(Environment* env,\n   // FIXME(bnoordhuis) The fact that a reinterpret_cast is needed is\n   // arguably a good indicator that there should be more than one queue.\n   env->req_wrap_queue()->PushBack(reinterpret_cast<ReqWrap<uv_req_t>*>(this));\n+\n+  Reset();\n }\n \n template <typename T>\n@@ -33,14 +35,21 @@ void ReqWrap<T>::Dispatched() {\n   req_.data = this;\n }\n \n+template <typename T>\n+void ReqWrap<T>::Reset() {\n+  original_callback_ = nullptr;\n+  req_.data = nullptr;\n+}\n+\n template <typename T>\n ReqWrap<T>* ReqWrap<T>::from_req(T* req) {\n   return ContainerOf(&ReqWrap<T>::req_, req);\n }\n \n template <typename T>\n void ReqWrap<T>::Cancel() {\n-  uv_cancel(reinterpret_cast<uv_req_t*>(&req_));\n+  if (req_.data == this)  // Only cancel if already dispatched.\n+    uv_cancel(reinterpret_cast<uv_req_t*>(&req_));\n }\n \n // Below is dark template magic designed to invoke libuv functions that\n@@ -95,7 +104,7 @@ struct CallLibuvFunction<ReqT, void(*)(ReqT*, Args...)> {\n template <typename ReqT, typename T>\n struct MakeLibuvRequestCallback {\n   static T For(ReqWrap<ReqT>* req_wrap, T v) {\n-    static_assert(!std::is_function<T>::value,\n+    static_assert(!is_callable<T>::value,\n                   \"MakeLibuvRequestCallback missed a callback\");\n     return v;\n   }\n@@ -109,6 +118,7 @@ struct MakeLibuvRequestCallback<ReqT, void(*)(ReqT*, Args...)> {\n \n   static void Wrapper(ReqT* req, Args... args) {\n     ReqWrap<ReqT>* req_wrap = ContainerOf(&ReqWrap<ReqT>::req_, req);\n+    req_wrap->env()->DecreaseWaitingRequestCounter();\n     F original_callback = reinterpret_cast<F>(req_wrap->original_callback_);\n     original_callback(req, args...);\n   }\n@@ -128,23 +138,26 @@ int ReqWrap<T>::Dispatch(LibuvFunction fn, Args... args) {\n \n   // This expands as:\n   //\n-  // return fn(env()->event_loop(), req(), arg1, arg2, Wrapper, arg3, ...)\n-  //           ^                                       ^        ^\n-  //           |                                       |        |\n-  //           \\-- Omitted if `fn` has no              |        |\n-  //               first `uv_loop_t*` argument         |        |\n-  //                                                   |        |\n-  //     A function callback whose first argument      |        |\n-  //     matches the libuv request type is replaced ---/        |\n-  //     by the `Wrapper` method defined above                  |\n-  //                                                            |\n-  //            Other (non-function) arguments are passed  -----/\n-  //            through verbatim\n-  return CallLibuvFunction<T, LibuvFunction>::Call(\n+  // int err = fn(env()->event_loop(), req(), arg1, arg2, Wrapper, arg3, ...)\n+  //              ^                                       ^        ^\n+  //              |                                       |        |\n+  //              \\-- Omitted if `fn` has no              |        |\n+  //                  first `uv_loop_t*` argument         |        |\n+  //                                                      |        |\n+  //        A function callback whose first argument      |        |\n+  //        matches the libuv request type is replaced ---/        |\n+  //        by the `Wrapper` method defined above                  |\n+  //                                                               |\n+  //               Other (non-function) arguments are passed  -----/\n+  //               through verbatim\n+  int err = CallLibuvFunction<T, LibuvFunction>::Call(\n       fn,\n       env()->event_loop(),\n       req(),\n       MakeLibuvRequestCallback<T, Args>::For(this, args)...);\n+  if (err >= 0)\n+    env()->IncreaseWaitingRequestCounter();\n+  return err;\n }\n \n }  // namespace node"
        },
        {
            "sha": "8f8d0cf28855943769f574683934629b464cf7a1",
            "filename": "src/req_wrap.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Freq_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Freq_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Freq_wrap.h?ref=1db0039c505c6081f1d0d84cc24133ed6659e539",
            "patch": "@@ -20,6 +20,8 @@ class ReqWrap : public AsyncWrap {\n   // Call this after the req has been dispatched, if that did not already\n   // happen by using Dispatch().\n   inline void Dispatched();\n+  // Call this after a request has finished, if re-using this object is planned.\n+  inline void Reset();\n   T* req() { return &req_; }\n   inline void Cancel();\n "
        },
        {
            "sha": "2c66104e9d24ac82db75d3952402a368b828ea98",
            "filename": "src/util.h",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Futil.h",
            "raw_url": "https://github.com/nodejs/node/raw/1db0039c505c6081f1d0d84cc24133ed6659e539/src%2Futil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.h?ref=1db0039c505c6081f1d0d84cc24133ed6659e539",
            "patch": "@@ -447,8 +447,16 @@ struct MallocedBuffer {\n   MallocedBuffer& operator=(const MallocedBuffer&) = delete;\n };\n \n-}  // namespace node\n+// Test whether some value can be called with ().\n+template<typename T, typename = void>\n+struct is_callable : std::is_function<T> { };\n+\n+template<typename T>\n+struct is_callable<T, typename std::enable_if<\n+    std::is_same<decltype(void(&T::operator())), void>::value\n+    >::type> : std::true_type { };\n \n+}  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n "
        }
    ],
    "stats": {
        "total": 107,
        "additions": 83,
        "deletions": 24
    }
}