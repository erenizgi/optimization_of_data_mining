{
    "author": "addaleax",
    "message": "worker: add `SharedArrayBuffer` sharing\n\nLogic is added to the `MessagePort` mechanism that\nattaches hidden objects to those instances when they are transferred\nthat track their lifetime and maintain a reference count, to make\nsure that memory is freed at the appropriate times.\n\nThanks to Stephen Belanger for reviewing this change in its original PR.\n\nRefs: https://github.com/ayojs/ayo/pull/106\n\nPR-URL: https://github.com/nodejs/node/pull/20876\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Shingo Inoue <leko.noor@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "b0404047c1e4f7652aaf6ecf911d5850d5acf570",
    "files": [
        {
            "sha": "974ff2e46710db4c849df23070fba204911e9d88",
            "filename": "doc/api/worker.md",
            "status": "modified",
            "additions": 11,
            "deletions": 4,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/b0404047c1e4f7652aaf6ecf911d5850d5acf570/doc%2Fapi%2Fworker.md",
            "raw_url": "https://github.com/nodejs/node/raw/b0404047c1e4f7652aaf6ecf911d5850d5acf570/doc%2Fapi%2Fworker.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fworker.md?ref=b0404047c1e4f7652aaf6ecf911d5850d5acf570",
            "patch": "@@ -85,14 +85,16 @@ to stringify.\n \n `transferList` may be a list of `ArrayBuffer` and `MessagePort` objects.\n After transferring, they will not be usable on the sending side of the channel\n-anymore (even if they are not contained in `value`).\n+anymore (even if they are not contained in `value`). Unlike with\n+[child processes][], transferring handles such as network sockets is currently\n+not supported.\n+\n+If `value` contains [`SharedArrayBuffer`][] instances, those will be accessible\n+from either thread. They cannot be listed in `transferList`.\n \n `value` may still contain `ArrayBuffer` instances that are not in\n `transferList`; in that case, the underlying memory is copied rather than moved.\n \n-For more information on the serialization and deserialization mechanisms\n-behind this API, see the [serialization API of the `v8` module][v8.serdes].\n-\n Because the object cloning uses the structured clone algorithm,\n non-enumerable properties, property accessors, and object prototypes are\n not preserved. In particular, [`Buffer`][] objects will be read as\n@@ -101,6 +103,9 @@ plain [`Uint8Array`][]s on the receiving side.\n The message object will be cloned immediately, and can be modified after\n posting without having side effects.\n \n+For more information on the serialization and deserialization mechanisms\n+behind this API, see the [serialization API of the `v8` module][v8.serdes].\n+\n ### port.ref()\n <!-- YAML\n added: REPLACEME\n@@ -137,10 +142,12 @@ be `ref()`ed and `unref()`ed automatically depending on whether\n listeners for the event exist.\n \n [`Buffer`]: buffer.html\n+[child processes]: child_process.html\n [`EventEmitter`]: events.html\n [`MessagePort`]: #worker_class_messageport\n [`port.postMessage()`]: #worker_port_postmessage_value_transferlist\n [v8.serdes]: v8.html#v8_serialization_api\n+[`SharedArrayBuffer`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\n [`Uint8Array`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n [browser `MessagePort`]: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort\n [HTML structured clone algorithm]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm"
        },
        {
            "sha": "804c102a5b7eabd09a08f99f8a6d9356c7dc39f9",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/b0404047c1e4f7652aaf6ecf911d5850d5acf570/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/b0404047c1e4f7652aaf6ecf911d5850d5acf570/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=b0404047c1e4f7652aaf6ecf911d5850d5acf570",
            "patch": "@@ -353,6 +353,7 @@\n         'src/node_i18n.cc',\n         'src/pipe_wrap.cc',\n         'src/process_wrap.cc',\n+        'src/sharedarraybuffer_metadata.cc',\n         'src/signal_wrap.cc',\n         'src/spawn_sync.cc',\n         'src/string_bytes.cc',\n@@ -412,6 +413,7 @@\n         'src/udp_wrap.h',\n         'src/req_wrap.h',\n         'src/req_wrap-inl.h',\n+        'src/sharedarraybuffer_metadata.h',\n         'src/string_bytes.h',\n         'src/string_decoder.h',\n         'src/string_decoder-inl.h',"
        },
        {
            "sha": "f1e9ccaef268f0bda9017bc90bc1f67cbd14a85b",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=b0404047c1e4f7652aaf6ecf911d5850d5acf570",
            "patch": "@@ -106,6 +106,7 @@ struct PackageConfig {\n   V(decorated_private_symbol, \"node:decorated\")                               \\\n   V(napi_env, \"node:napi:env\")                                                \\\n   V(napi_wrapper, \"node:napi:wrapper\")                                        \\\n+  V(sab_lifetimepartner_symbol, \"node:sharedArrayBufferLifetimePartner\")      \\\n \n // Symbols are per-isolate primitives but Environment proxies them\n // for the sake of convenience.\n@@ -338,6 +339,7 @@ struct PackageConfig {\n   V(promise_wrap_template, v8::ObjectTemplate)                                \\\n   V(push_values_to_array_function, v8::Function)                              \\\n   V(randombytes_constructor_template, v8::ObjectTemplate)                     \\\n+  V(sab_lifetimepartner_constructor_template, v8::FunctionTemplate)           \\\n   V(script_context_constructor_template, v8::FunctionTemplate)                \\\n   V(script_data_constructor_function, v8::Function)                           \\\n   V(secure_context_constructor_template, v8::FunctionTemplate)                \\"
        },
        {
            "sha": "931ce7b8fdbf330399d3bf737e16c861a75ae75d",
            "filename": "src/node_errors.h",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fnode_errors.h",
            "raw_url": "https://github.com/nodejs/node/raw/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fnode_errors.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_errors.h?ref=b0404047c1e4f7652aaf6ecf911d5850d5acf570",
            "patch": "@@ -37,6 +37,7 @@ namespace node {\n   V(ERR_SCRIPT_EXECUTION_INTERRUPTED, Error)                                 \\\n   V(ERR_SCRIPT_EXECUTION_TIMEOUT, Error)                                     \\\n   V(ERR_STRING_TOO_LONG, Error)                                              \\\n+  V(ERR_TRANSFERRING_EXTERNALIZED_SHAREDARRAYBUFFER, TypeError)              \\\n \n #define V(code, type)                                                         \\\n   inline v8::Local<v8::Value> code(v8::Isolate* isolate,                      \\\n@@ -68,7 +69,9 @@ namespace node {\n   V(ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST,                               \\\n     \"MessagePort was found in message but not listed in transferList\")       \\\n   V(ERR_SCRIPT_EXECUTION_INTERRUPTED,                                        \\\n-    \"Script execution was interrupted by `SIGINT`\")\n+    \"Script execution was interrupted by `SIGINT`\")                          \\\n+  V(ERR_TRANSFERRING_EXTERNALIZED_SHAREDARRAYBUFFER,                         \\\n+    \"Cannot serialize externalized SharedArrayBuffer\")                       \\\n \n #define V(code, message)                                                     \\\n   inline v8::Local<v8::Value> code(v8::Isolate* isolate) {                   \\"
        },
        {
            "sha": "ede38cc817bfbb9a6105be61df8eb151b4d1c6ce",
            "filename": "src/node_messaging.cc",
            "status": "modified",
            "additions": 54,
            "deletions": 3,
            "changes": 57,
            "blob_url": "https://github.com/nodejs/node/blob/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fnode_messaging.cc",
            "raw_url": "https://github.com/nodejs/node/raw/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fnode_messaging.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.cc?ref=b0404047c1e4f7652aaf6ecf911d5850d5acf570",
            "patch": "@@ -24,6 +24,7 @@ using v8::Maybe;\n using v8::MaybeLocal;\n using v8::Nothing;\n using v8::Object;\n+using v8::SharedArrayBuffer;\n using v8::String;\n using v8::Value;\n using v8::ValueDeserializer;\n@@ -43,8 +44,13 @@ class DeserializerDelegate : public ValueDeserializer::Delegate {\n  public:\n   DeserializerDelegate(Message* m,\n                        Environment* env,\n-                       const std::vector<MessagePort*>& message_ports)\n-    : env_(env), msg_(m), message_ports_(message_ports) {}\n+                       const std::vector<MessagePort*>& message_ports,\n+                       const std::vector<Local<SharedArrayBuffer>>&\n+                           shared_array_buffers)\n+    : env_(env),\n+      msg_(m),\n+      message_ports_(message_ports),\n+      shared_array_buffers_(shared_array_buffers) {}\n \n   MaybeLocal<Object> ReadHostObject(Isolate* isolate) override {\n     // Currently, only MessagePort hosts objects are supported, so identifying\n@@ -56,12 +62,19 @@ class DeserializerDelegate : public ValueDeserializer::Delegate {\n     return message_ports_[id]->object();\n   };\n \n+  MaybeLocal<SharedArrayBuffer> GetSharedArrayBufferFromId(\n+      Isolate* isolate, uint32_t clone_id) override {\n+    CHECK_LE(clone_id, shared_array_buffers_.size());\n+    return shared_array_buffers_[clone_id];\n+  }\n+\n   ValueDeserializer* deserializer = nullptr;\n \n  private:\n   Environment* env_;\n   Message* msg_;\n   const std::vector<MessagePort*>& message_ports_;\n+  const std::vector<Local<SharedArrayBuffer>>& shared_array_buffers_;\n };\n \n }  // anonymous namespace\n@@ -87,7 +100,18 @@ MaybeLocal<Value> Message::Deserialize(Environment* env,\n   }\n   message_ports_.clear();\n \n-  DeserializerDelegate delegate(this, env, ports);\n+  std::vector<Local<SharedArrayBuffer>> shared_array_buffers;\n+  // Attach all transfered SharedArrayBuffers to their new Isolate.\n+  for (uint32_t i = 0; i < shared_array_buffers_.size(); ++i) {\n+    Local<SharedArrayBuffer> sab;\n+    if (!shared_array_buffers_[i]->GetSharedArrayBuffer(env, context)\n+            .ToLocal(&sab))\n+      return MaybeLocal<Value>();\n+    shared_array_buffers.push_back(sab);\n+  }\n+  shared_array_buffers_.clear();\n+\n+  DeserializerDelegate delegate(this, env, ports, shared_array_buffers);\n   ValueDeserializer deserializer(\n       env->isolate(),\n       reinterpret_cast<const uint8_t*>(main_message_buf_.data),\n@@ -112,6 +136,11 @@ MaybeLocal<Value> Message::Deserialize(Environment* env,\n       deserializer.ReadValue(context).FromMaybe(Local<Value>()));\n }\n \n+void Message::AddSharedArrayBuffer(\n+    SharedArrayBufferMetadataReference reference) {\n+  shared_array_buffers_.push_back(reference);\n+}\n+\n void Message::AddMessagePort(std::unique_ptr<MessagePortData>&& data) {\n   message_ports_.emplace_back(std::move(data));\n }\n@@ -139,6 +168,27 @@ class SerializerDelegate : public ValueSerializer::Delegate {\n     return Nothing<bool>();\n   }\n \n+  Maybe<uint32_t> GetSharedArrayBufferId(\n+      Isolate* isolate,\n+      Local<SharedArrayBuffer> shared_array_buffer) override {\n+    uint32_t i;\n+    for (i = 0; i < seen_shared_array_buffers_.size(); ++i) {\n+      if (seen_shared_array_buffers_[i] == shared_array_buffer)\n+        return Just(i);\n+    }\n+\n+    auto reference = SharedArrayBufferMetadata::ForSharedArrayBuffer(\n+        env_,\n+        context_,\n+        shared_array_buffer);\n+    if (!reference) {\n+      return Nothing<uint32_t>();\n+    }\n+    seen_shared_array_buffers_.push_back(shared_array_buffer);\n+    msg_->AddSharedArrayBuffer(reference);\n+    return Just(i);\n+  }\n+\n   void Finish() {\n     // Only close the MessagePort handles and actually transfer them\n     // once we know that serialization succeeded.\n@@ -166,6 +216,7 @@ class SerializerDelegate : public ValueSerializer::Delegate {\n   Environment* env_;\n   Local<Context> context_;\n   Message* msg_;\n+  std::vector<Local<SharedArrayBuffer>> seen_shared_array_buffers_;\n   std::vector<MessagePort*> ports_;\n \n   friend class worker::Message;"
        },
        {
            "sha": "ff8fcc72439e9f42a29d04b8eef7806077def262",
            "filename": "src/node_messaging.h",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fnode_messaging.h",
            "raw_url": "https://github.com/nodejs/node/raw/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fnode_messaging.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.h?ref=b0404047c1e4f7652aaf6ecf911d5850d5acf570",
            "patch": "@@ -5,8 +5,8 @@\n \n #include \"env.h\"\n #include \"node_mutex.h\"\n+#include \"sharedarraybuffer_metadata.h\"\n #include <list>\n-#include <memory>\n \n namespace node {\n namespace worker {\n@@ -37,13 +37,17 @@ class Message {\n                             v8::Local<v8::Value> input,\n                             v8::Local<v8::Value> transfer_list);\n \n+  // Internal method of Message that is called when a new SharedArrayBuffer\n+  // object is encountered in the incoming value's structure.\n+  void AddSharedArrayBuffer(SharedArrayBufferMetadataReference ref);\n   // Internal method of Message that is called once serialization finishes\n   // and that transfers ownership of `data` to this message.\n   void AddMessagePort(std::unique_ptr<MessagePortData>&& data);\n \n  private:\n   MallocedBuffer<char> main_message_buf_;\n   std::vector<MallocedBuffer<char>> array_buffer_contents_;\n+  std::vector<SharedArrayBufferMetadataReference> shared_array_buffers_;\n   std::vector<std::unique_ptr<MessagePortData>> message_ports_;\n \n   friend class MessagePort;"
        },
        {
            "sha": "86476a9f12c38b0d735c2385510f6518a8c3beb2",
            "filename": "src/sharedarraybuffer_metadata.cc",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/nodejs/node/blob/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fsharedarraybuffer_metadata.cc",
            "raw_url": "https://github.com/nodejs/node/raw/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fsharedarraybuffer_metadata.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fsharedarraybuffer_metadata.cc?ref=b0404047c1e4f7652aaf6ecf911d5850d5acf570",
            "patch": "@@ -0,0 +1,129 @@\n+#include \"sharedarraybuffer_metadata.h\"\n+#include \"base_object.h\"\n+#include \"base_object-inl.h\"\n+#include \"node_errors.h\"\n+\n+using v8::Context;\n+using v8::Function;\n+using v8::FunctionTemplate;\n+using v8::Local;\n+using v8::Maybe;\n+using v8::MaybeLocal;\n+using v8::Nothing;\n+using v8::Object;\n+using v8::SharedArrayBuffer;\n+using v8::Value;\n+\n+namespace node {\n+namespace worker {\n+\n+namespace {\n+\n+// Yield a JS constructor for SABLifetimePartner objects in the form of a\n+// standard API object, that has a single field for containing the raw\n+// SABLiftimePartner* pointer.\n+Local<Function> GetSABLifetimePartnerConstructor(\n+    Environment* env, Local<Context> context) {\n+  Local<FunctionTemplate> templ;\n+  templ = env->sab_lifetimepartner_constructor_template();\n+  if (!templ.IsEmpty())\n+    return templ->GetFunction(context).ToLocalChecked();\n+\n+  templ = BaseObject::MakeLazilyInitializedJSTemplate(env);\n+  templ->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(),\n+                                            \"SABLifetimePartner\"));\n+  env->set_sab_lifetimepartner_constructor_template(templ);\n+\n+  return GetSABLifetimePartnerConstructor(env, context);\n+}\n+\n+class SABLifetimePartner : public BaseObject {\n+ public:\n+  SABLifetimePartner(Environment* env,\n+                     Local<Object> obj,\n+                     SharedArrayBufferMetadataReference r)\n+    : BaseObject(env, obj),\n+      reference(r) {\n+    MakeWeak();\n+  }\n+\n+  SharedArrayBufferMetadataReference reference;\n+};\n+\n+}  // anonymous namespace\n+\n+SharedArrayBufferMetadataReference\n+SharedArrayBufferMetadata::ForSharedArrayBuffer(\n+    Environment* env,\n+    Local<Context> context,\n+    Local<SharedArrayBuffer> source) {\n+  Local<Value> lifetime_partner;\n+\n+  if (!source->GetPrivate(context,\n+                          env->sab_lifetimepartner_symbol())\n+                              .ToLocal(&lifetime_partner)) {\n+    return nullptr;\n+  }\n+\n+  if (lifetime_partner->IsObject() &&\n+      env->sab_lifetimepartner_constructor_template()\n+         ->HasInstance(lifetime_partner)) {\n+    CHECK(source->IsExternal());\n+    SABLifetimePartner* partner =\n+        Unwrap<SABLifetimePartner>(lifetime_partner.As<Object>());\n+    CHECK_NE(partner, nullptr);\n+    return partner->reference;\n+  }\n+\n+  if (source->IsExternal()) {\n+    // If this is an external SharedArrayBuffer but we do not see a lifetime\n+    // partner object, it was not us who externalized it. In that case, there\n+    // is no way to serialize it, because it's unclear how the memory\n+    // is actually owned.\n+    THROW_ERR_TRANSFERRING_EXTERNALIZED_SHAREDARRAYBUFFER(env);\n+    return nullptr;\n+  }\n+\n+  SharedArrayBuffer::Contents contents = source->Externalize();\n+  SharedArrayBufferMetadataReference r(new SharedArrayBufferMetadata(\n+      contents.Data(), contents.ByteLength()));\n+  if (r->AssignToSharedArrayBuffer(env, context, source).IsNothing())\n+    return nullptr;\n+  return r;\n+}\n+\n+Maybe<bool> SharedArrayBufferMetadata::AssignToSharedArrayBuffer(\n+    Environment* env, Local<Context> context,\n+    Local<SharedArrayBuffer> target) {\n+  CHECK(target->IsExternal());\n+  Local<Function> ctor = GetSABLifetimePartnerConstructor(env, context);\n+  Local<Object> obj;\n+  if (!ctor->NewInstance(context).ToLocal(&obj))\n+    return Nothing<bool>();\n+\n+  new SABLifetimePartner(env, obj, shared_from_this());\n+  return target->SetPrivate(context,\n+                            env->sab_lifetimepartner_symbol(),\n+                            obj);\n+}\n+\n+SharedArrayBufferMetadata::SharedArrayBufferMetadata(void* data, size_t size)\n+  : data(data), size(size) { }\n+\n+SharedArrayBufferMetadata::~SharedArrayBufferMetadata() {\n+  free(data);\n+}\n+\n+MaybeLocal<SharedArrayBuffer> SharedArrayBufferMetadata::GetSharedArrayBuffer(\n+    Environment* env, Local<Context> context) {\n+  Local<SharedArrayBuffer> obj =\n+      SharedArrayBuffer::New(env->isolate(), data, size);\n+\n+  if (AssignToSharedArrayBuffer(env, context, obj).IsNothing())\n+    return MaybeLocal<SharedArrayBuffer>();\n+\n+  return obj;\n+}\n+\n+}  // namespace worker\n+}  // namespace node"
        },
        {
            "sha": "84bfd224fabcf88ba9bbb576e1f4cef54272c284",
            "filename": "src/sharedarraybuffer_metadata.h",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fsharedarraybuffer_metadata.h",
            "raw_url": "https://github.com/nodejs/node/raw/b0404047c1e4f7652aaf6ecf911d5850d5acf570/src%2Fsharedarraybuffer_metadata.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fsharedarraybuffer_metadata.h?ref=b0404047c1e4f7652aaf6ecf911d5850d5acf570",
            "patch": "@@ -0,0 +1,67 @@\n+#ifndef SRC_SHAREDARRAYBUFFER_METADATA_H_\n+#define SRC_SHAREDARRAYBUFFER_METADATA_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"node.h\"\n+#include <memory>\n+\n+namespace node {\n+namespace worker {\n+\n+class SharedArrayBufferMetadata;\n+\n+// This is an object associated with a SharedArrayBuffer, which keeps track\n+// of a cross-thread reference count. Once a SharedArrayBuffer is transferred\n+// for the first time (or is attempted to be transferred), one of these objects\n+// is created, and the SharedArrayBuffer is moved from internalized mode into\n+// externalized mode (i.e. the JS engine no longer frees the memory on its own).\n+//\n+// This will always be referred to using a std::shared_ptr, since it keeps\n+// a reference count and is guaranteed to be thread-safe.\n+typedef std::shared_ptr<SharedArrayBufferMetadata>\n+    SharedArrayBufferMetadataReference;\n+\n+class SharedArrayBufferMetadata\n+    : public std::enable_shared_from_this<SharedArrayBufferMetadata> {\n+ public:\n+  static SharedArrayBufferMetadataReference ForSharedArrayBuffer(\n+      Environment* env,\n+      v8::Local<v8::Context> context,\n+      v8::Local<v8::SharedArrayBuffer> source);\n+  ~SharedArrayBufferMetadata();\n+\n+  // Create a SharedArrayBuffer object for a specific Environment and Context.\n+  // The created SharedArrayBuffer will be in externalized mode and has\n+  // a hidden object attached to it, during whose lifetime the reference\n+  // count is increased by 1.\n+  v8::MaybeLocal<v8::SharedArrayBuffer> GetSharedArrayBuffer(\n+      Environment* env, v8::Local<v8::Context> context);\n+\n+  SharedArrayBufferMetadata(SharedArrayBufferMetadata&& other) = delete;\n+  SharedArrayBufferMetadata& operator=(\n+      SharedArrayBufferMetadata&& other) = delete;\n+  SharedArrayBufferMetadata& operator=(\n+      const SharedArrayBufferMetadata&) = delete;\n+  SharedArrayBufferMetadata(const SharedArrayBufferMetadata&) = delete;\n+\n+ private:\n+  explicit SharedArrayBufferMetadata(void* data, size_t size);\n+\n+  // Attach a lifetime tracker object with a reference count to `target`.\n+  v8::Maybe<bool> AssignToSharedArrayBuffer(\n+      Environment* env,\n+      v8::Local<v8::Context> context,\n+      v8::Local<v8::SharedArrayBuffer> target);\n+\n+  void* data = nullptr;\n+  size_t size = 0;\n+};\n+\n+}  // namespace worker\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+\n+#endif  // SRC_SHAREDARRAYBUFFER_METADATA_H_"
        }
    ],
    "stats": {
        "total": 283,
        "additions": 274,
        "deletions": 9
    }
}