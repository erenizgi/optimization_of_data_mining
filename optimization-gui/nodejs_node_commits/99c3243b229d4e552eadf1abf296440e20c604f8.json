{
    "author": "joyeecheung",
    "message": "src: move v8_platform implementation into node_v8_platform-inl.h\n\nSo that the v8_platform global variable can be referenced in other\nfiles.\n\nPR-URL: https://github.com/nodejs/node/pull/25541\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "99c3243b229d4e552eadf1abf296440e20c604f8",
    "files": [
        {
            "sha": "0ddc81fcba704e818bb4dc66b8962ea49ca833df",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/99c3243b229d4e552eadf1abf296440e20c604f8/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/99c3243b229d4e552eadf1abf296440e20c604f8/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=99c3243b229d4e552eadf1abf296440e20c604f8",
            "patch": "@@ -493,6 +493,7 @@\n         'src/node_union_bytes.h',\n         'src/node_url.h',\n         'src/node_version.h',\n+        'src/node_v8_platform-inl.h',\n         'src/node_watchdog.h',\n         'src/node_worker.h',\n         'src/pipe_wrap.h',"
        },
        {
            "sha": "137dc83b76a7ec854c06e1a83ba661c9e448a240",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=99c3243b229d4e552eadf1abf296440e20c604f8",
            "patch": "@@ -8,6 +8,7 @@\n #include \"node_options-inl.h\"\n #include \"node_platform.h\"\n #include \"node_process.h\"\n+#include \"node_v8_platform-inl.h\"\n #include \"node_worker.h\"\n #include \"tracing/agent.h\"\n #include \"tracing/traced_value.h\""
        },
        {
            "sha": "fb8467a1b9d3e097e44d37728afc2c12fb8acb6e",
            "filename": "src/inspector/tracing_agent.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Finspector%2Ftracing_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Finspector%2Ftracing_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Ftracing_agent.cc?ref=99c3243b229d4e552eadf1abf296440e20c604f8",
            "patch": "@@ -1,6 +1,7 @@\n #include \"tracing_agent.h\"\n #include \"main_thread_interface.h\"\n #include \"node_internals.h\"\n+#include \"node_v8_platform-inl.h\"\n \n #include \"env-inl.h\"\n #include \"v8.h\""
        },
        {
            "sha": "b9f4403829963f87ce73c6117cb3dac5920c0884",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 179,
            "changes": 196,
            "blob_url": "https://github.com/nodejs/node/blob/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=99c3243b229d4e552eadf1abf296440e20c604f8",
            "patch": "@@ -32,8 +32,8 @@\n #include \"node_platform.h\"\n #include \"node_process.h\"\n #include \"node_revert.h\"\n+#include \"node_v8_platform-inl.h\"\n #include \"node_version.h\"\n-#include \"tracing/traced_value.h\"\n \n #if HAVE_OPENSSL\n #include \"node_crypto.h\"\n@@ -56,8 +56,6 @@\n #include \"handle_wrap.h\"\n #include \"req_wrap-inl.h\"\n #include \"string_bytes.h\"\n-#include \"tracing/agent.h\"\n-#include \"tracing/node_trace_writer.h\"\n #include \"util.h\"\n #include \"uv.h\"\n #if NODE_USE_V8_PLATFORM\n@@ -165,169 +163,10 @@ bool v8_initialized = false;\n // node_internals.h\n // process-relative uptime base, initialized at start-up\n double prog_start_time;\n-}  // namespace per_process\n-\n-// Ensures that __metadata trace events are only emitted\n-// when tracing is enabled.\n-class NodeTraceStateObserver :\n-    public TracingController::TraceStateObserver {\n- public:\n-  void OnTraceEnabled() override {\n-    char name_buffer[512];\n-    if (uv_get_process_title(name_buffer, sizeof(name_buffer)) == 0) {\n-      // Only emit the metadata event if the title can be retrieved\n-      // successfully. Ignore it otherwise.\n-      TRACE_EVENT_METADATA1(\"__metadata\", \"process_name\",\n-                            \"name\", TRACE_STR_COPY(name_buffer));\n-    }\n-    TRACE_EVENT_METADATA1(\"__metadata\",\n-                          \"version\",\n-                          \"node\",\n-                          per_process::metadata.versions.node.c_str());\n-    TRACE_EVENT_METADATA1(\"__metadata\", \"thread_name\",\n-                          \"name\", \"JavaScriptMainThread\");\n-\n-    auto trace_process = tracing::TracedValue::Create();\n-    trace_process->BeginDictionary(\"versions\");\n-\n-#define V(key)                                                                 \\\n-  trace_process->SetString(#key, per_process::metadata.versions.key.c_str());\n-\n-    NODE_VERSIONS_KEYS(V)\n-#undef V\n-\n-    trace_process->EndDictionary();\n-\n-    trace_process->SetString(\"arch\", per_process::metadata.arch.c_str());\n-    trace_process->SetString(\"platform\",\n-                             per_process::metadata.platform.c_str());\n-\n-    trace_process->BeginDictionary(\"release\");\n-    trace_process->SetString(\"name\",\n-                             per_process::metadata.release.name.c_str());\n-#if NODE_VERSION_IS_LTS\n-    trace_process->SetString(\"lts\", per_process::metadata.release.lts.c_str());\n-#endif\n-    trace_process->EndDictionary();\n-    TRACE_EVENT_METADATA1(\"__metadata\", \"node\",\n-                          \"process\", std::move(trace_process));\n-\n-    // This only runs the first time tracing is enabled\n-    controller_->RemoveTraceStateObserver(this);\n-  }\n-\n-  void OnTraceDisabled() override {\n-    // Do nothing here. This should never be called because the\n-    // observer removes itself when OnTraceEnabled() is called.\n-    UNREACHABLE();\n-  }\n-\n-  explicit NodeTraceStateObserver(TracingController* controller) :\n-      controller_(controller) {}\n-  ~NodeTraceStateObserver() override {}\n-\n- private:\n-  TracingController* controller_;\n-};\n-\n-static struct {\n-#if NODE_USE_V8_PLATFORM\n-  void Initialize(int thread_pool_size) {\n-    tracing_agent_.reset(new tracing::Agent());\n-    node::tracing::TraceEventHelper::SetAgent(tracing_agent_.get());\n-    node::tracing::TracingController* controller =\n-        tracing_agent_->GetTracingController();\n-    trace_state_observer_.reset(new NodeTraceStateObserver(controller));\n-    controller->AddTraceStateObserver(trace_state_observer_.get());\n-    StartTracingAgent();\n-    // Tracing must be initialized before platform threads are created.\n-    platform_ = new NodePlatform(thread_pool_size, controller);\n-    V8::InitializePlatform(platform_);\n-  }\n-\n-  void Dispose() {\n-    StopTracingAgent();\n-    platform_->Shutdown();\n-    delete platform_;\n-    platform_ = nullptr;\n-    // Destroy tracing after the platform (and platform threads) have been\n-    // stopped.\n-    tracing_agent_.reset(nullptr);\n-    trace_state_observer_.reset(nullptr);\n-  }\n-\n-  void DrainVMTasks(Isolate* isolate) {\n-    platform_->DrainTasks(isolate);\n-  }\n \n-  void CancelVMTasks(Isolate* isolate) {\n-    platform_->CancelPendingDelayedTasks(isolate);\n-  }\n-\n-  void StartTracingAgent() {\n-    if (per_process::cli_options->trace_event_categories.empty()) {\n-      tracing_file_writer_ = tracing_agent_->DefaultHandle();\n-    } else {\n-      std::vector<std::string> categories =\n-          SplitString(per_process::cli_options->trace_event_categories, ',');\n-\n-      tracing_file_writer_ = tracing_agent_->AddClient(\n-          std::set<std::string>(std::make_move_iterator(categories.begin()),\n-                                std::make_move_iterator(categories.end())),\n-          std::unique_ptr<tracing::AsyncTraceWriter>(\n-              new tracing::NodeTraceWriter(\n-                  per_process::cli_options->trace_event_file_pattern)),\n-          tracing::Agent::kUseDefaultCategories);\n-    }\n-  }\n-\n-  void StopTracingAgent() {\n-    tracing_file_writer_.reset();\n-  }\n-\n-  tracing::AgentWriterHandle* GetTracingAgentWriter() {\n-    return &tracing_file_writer_;\n-  }\n-\n-  NodePlatform* Platform() {\n-    return platform_;\n-  }\n-\n-  std::unique_ptr<NodeTraceStateObserver> trace_state_observer_;\n-  std::unique_ptr<tracing::Agent> tracing_agent_;\n-  tracing::AgentWriterHandle tracing_file_writer_;\n-  NodePlatform* platform_;\n-#else  // !NODE_USE_V8_PLATFORM\n-  void Initialize(int thread_pool_size) {}\n-  void Dispose() {}\n-  void DrainVMTasks(Isolate* isolate) {}\n-  void CancelVMTasks(Isolate* isolate) {}\n-\n-  void StartTracingAgent() {\n-    if (!trace_enabled_categories.empty()) {\n-      fprintf(stderr, \"Node compiled with NODE_USE_V8_PLATFORM=0, \"\n-                      \"so event tracing is not available.\\n\");\n-    }\n-  }\n-  void StopTracingAgent() {}\n-\n-  tracing::AgentWriterHandle* GetTracingAgentWriter() {\n-    return nullptr;\n-  }\n-\n-  NodePlatform* Platform() {\n-    return nullptr;\n-  }\n-#endif  // !NODE_USE_V8_PLATFORM\n-} v8_platform;\n-\n-tracing::AgentWriterHandle* GetTracingAgentWriter() {\n-  return v8_platform.GetTracingAgentWriter();\n-}\n-\n-void DisposePlatform() {\n-  v8_platform.Dispose();\n-}\n+// node_v8_platform-inl.h\n+struct V8Platform v8_platform;\n+}  // namespace per_process\n \n #ifdef __POSIX__\n static const unsigned kMaxSignal = 32;\n@@ -1258,7 +1097,7 @@ Environment* GetCurrentEnvironment(Local<Context> context) {\n \n \n MultiIsolatePlatform* GetMainThreadMultiIsolatePlatform() {\n-  return v8_platform.Platform();\n+  return per_process::v8_platform.Platform();\n }\n \n \n@@ -1270,8 +1109,8 @@ MultiIsolatePlatform* CreatePlatform(\n \n \n MultiIsolatePlatform* InitializeV8Platform(int thread_pool_size) {\n-  v8_platform.Initialize(thread_pool_size);\n-  return v8_platform.Platform();\n+  per_process::v8_platform.Initialize(thread_pool_size);\n+  return per_process::v8_platform.Platform();\n }\n \n \n@@ -1359,7 +1198,7 @@ inline int Start(Isolate* isolate, IsolateData* isolate_data,\n     do {\n       uv_run(env.event_loop(), UV_RUN_DEFAULT);\n \n-      v8_platform.DrainVMTasks(isolate);\n+      per_process::v8_platform.DrainVMTasks(isolate);\n \n       more = uv_loop_alive(env.event_loop());\n       if (more)\n@@ -1387,8 +1226,8 @@ inline int Start(Isolate* isolate, IsolateData* isolate_data,\n   env.RunCleanup();\n   RunAtExit(&env);\n \n-  v8_platform.DrainVMTasks(isolate);\n-  v8_platform.CancelVMTasks(isolate);\n+  per_process::v8_platform.DrainVMTasks(isolate);\n+  per_process::v8_platform.CancelVMTasks(isolate);\n #if defined(LEAK_SANITIZER)\n   __lsan_do_leak_check();\n #endif\n@@ -1416,7 +1255,7 @@ Isolate* NewIsolate(ArrayBufferAllocator* allocator, uv_loop_t* event_loop) {\n \n   // Register the isolate on the platform before the isolate gets initialized,\n   // so that the isolate can access the platform during initialization.\n-  v8_platform.Platform()->RegisterIsolate(isolate, event_loop);\n+  per_process::v8_platform.Platform()->RegisterIsolate(isolate, event_loop);\n   Isolate::Initialize(isolate, params);\n \n   isolate->AddMessageListenerWithErrorLevel(OnMessage,\n@@ -1462,11 +1301,10 @@ inline int Start(uv_loop_t* event_loop,\n     Isolate::Scope isolate_scope(isolate);\n     HandleScope handle_scope(isolate);\n     std::unique_ptr<IsolateData, decltype(&FreeIsolateData)> isolate_data(\n-        CreateIsolateData(\n-            isolate,\n-            event_loop,\n-            v8_platform.Platform(),\n-            allocator.get()),\n+        CreateIsolateData(isolate,\n+                          event_loop,\n+                          per_process::v8_platform.Platform(),\n+                          allocator.get()),\n         &FreeIsolateData);\n     // TODO(addaleax): This should load a real per-Isolate option, currently\n     // this is still effectively per-process.\n@@ -1484,7 +1322,7 @@ inline int Start(uv_loop_t* event_loop,\n   }\n \n   isolate->Dispose();\n-  v8_platform.Platform()->UnregisterIsolate(isolate);\n+  per_process::v8_platform.Platform()->UnregisterIsolate(isolate);\n \n   return exit_code;\n }\n@@ -1549,7 +1387,7 @@ int Start(int argc, char** argv) {\n   // that happen to terminate during shutdown from being run unsafely.\n   // Since uv_run cannot be called, uv_async handles held by the platform\n   // will never be fully cleaned up.\n-  v8_platform.Dispose();\n+  per_process::v8_platform.Dispose();\n \n   return exit_code;\n }"
        },
        {
            "sha": "d972e2e5bd5916030a3bbfbe029fb735876913eb",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=99c3243b229d4e552eadf1abf296440e20c604f8",
            "patch": "@@ -244,9 +244,6 @@ int ThreadPoolWork::CancelWork() {\n   return uv_cancel(reinterpret_cast<uv_req_t*>(&work_req_));\n }\n \n-tracing::AgentWriterHandle* GetTracingAgentWriter();\n-void DisposePlatform();\n-\n #define TRACING_CATEGORY_NODE \"node\"\n #define TRACING_CATEGORY_NODE1(one)                                           \\\n     TRACING_CATEGORY_NODE \",\"                                                 \\"
        },
        {
            "sha": "9538e75d2c54edd755a53c31a7401c0e1de92a6f",
            "filename": "src/node_trace_events.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fnode_trace_events.cc",
            "raw_url": "https://github.com/nodejs/node/raw/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fnode_trace_events.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_trace_events.cc?ref=99c3243b229d4e552eadf1abf296440e20c604f8",
            "patch": "@@ -1,8 +1,8 @@\n+#include \"base_object-inl.h\"\n+#include \"env.h\"\n #include \"node.h\"\n-#include \"node_internals.h\"\n+#include \"node_v8_platform-inl.h\"\n #include \"tracing/agent.h\"\n-#include \"env.h\"\n-#include \"base_object-inl.h\"\n \n #include <set>\n #include <string>"
        },
        {
            "sha": "ed91ee3a0225512793cc2ba860002409ac412327",
            "filename": "src/node_v8_platform-inl.h",
            "status": "added",
            "additions": 178,
            "deletions": 0,
            "changes": 178,
            "blob_url": "https://github.com/nodejs/node/blob/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fnode_v8_platform-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/99c3243b229d4e552eadf1abf296440e20c604f8/src%2Fnode_v8_platform-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_v8_platform-inl.h?ref=99c3243b229d4e552eadf1abf296440e20c604f8",
            "patch": "@@ -0,0 +1,178 @@\n+#ifndef SRC_NODE_V8_PLATFORM_INL_H_\n+#define SRC_NODE_V8_PLATFORM_INL_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"env-inl.h\"\n+#include \"node.h\"\n+#include \"node_metadata.h\"\n+#include \"node_options.h\"\n+#include \"tracing/node_trace_writer.h\"\n+#include \"tracing/trace_event.h\"\n+#include \"tracing/traced_value.h\"\n+\n+namespace node {\n+\n+// Ensures that __metadata trace events are only emitted\n+// when tracing is enabled.\n+class NodeTraceStateObserver\n+    : public v8::TracingController::TraceStateObserver {\n+ public:\n+  inline void OnTraceEnabled() override {\n+    char name_buffer[512];\n+    if (uv_get_process_title(name_buffer, sizeof(name_buffer)) == 0) {\n+      // Only emit the metadata event if the title can be retrieved\n+      // successfully. Ignore it otherwise.\n+      TRACE_EVENT_METADATA1(\n+          \"__metadata\", \"process_name\", \"name\", TRACE_STR_COPY(name_buffer));\n+    }\n+    TRACE_EVENT_METADATA1(\"__metadata\",\n+                          \"version\",\n+                          \"node\",\n+                          per_process::metadata.versions.node.c_str());\n+    TRACE_EVENT_METADATA1(\n+        \"__metadata\", \"thread_name\", \"name\", \"JavaScriptMainThread\");\n+\n+    auto trace_process = tracing::TracedValue::Create();\n+    trace_process->BeginDictionary(\"versions\");\n+\n+#define V(key)                                                                 \\\n+  trace_process->SetString(#key, per_process::metadata.versions.key.c_str());\n+\n+    NODE_VERSIONS_KEYS(V)\n+#undef V\n+\n+    trace_process->EndDictionary();\n+\n+    trace_process->SetString(\"arch\", per_process::metadata.arch.c_str());\n+    trace_process->SetString(\"platform\",\n+                             per_process::metadata.platform.c_str());\n+\n+    trace_process->BeginDictionary(\"release\");\n+    trace_process->SetString(\"name\",\n+                             per_process::metadata.release.name.c_str());\n+#if NODE_VERSION_IS_LTS\n+    trace_process->SetString(\"lts\", per_process::metadata.release.lts.c_str());\n+#endif\n+    trace_process->EndDictionary();\n+    TRACE_EVENT_METADATA1(\n+        \"__metadata\", \"node\", \"process\", std::move(trace_process));\n+\n+    // This only runs the first time tracing is enabled\n+    controller_->RemoveTraceStateObserver(this);\n+  }\n+\n+  inline void OnTraceDisabled() override {\n+    // Do nothing here. This should never be called because the\n+    // observer removes itself when OnTraceEnabled() is called.\n+    UNREACHABLE();\n+  }\n+\n+  explicit NodeTraceStateObserver(v8::TracingController* controller)\n+      : controller_(controller) {}\n+  ~NodeTraceStateObserver() override {}\n+\n+ private:\n+  v8::TracingController* controller_;\n+};\n+\n+struct V8Platform {\n+#if NODE_USE_V8_PLATFORM\n+  inline void Initialize(int thread_pool_size) {\n+    tracing_agent_.reset(new tracing::Agent());\n+    node::tracing::TraceEventHelper::SetAgent(tracing_agent_.get());\n+    node::tracing::TracingController* controller =\n+        tracing_agent_->GetTracingController();\n+    trace_state_observer_.reset(new NodeTraceStateObserver(controller));\n+    controller->AddTraceStateObserver(trace_state_observer_.get());\n+    StartTracingAgent();\n+    // Tracing must be initialized before platform threads are created.\n+    platform_ = new NodePlatform(thread_pool_size, controller);\n+    v8::V8::InitializePlatform(platform_);\n+  }\n+\n+  inline void Dispose() {\n+    StopTracingAgent();\n+    platform_->Shutdown();\n+    delete platform_;\n+    platform_ = nullptr;\n+    // Destroy tracing after the platform (and platform threads) have been\n+    // stopped.\n+    tracing_agent_.reset(nullptr);\n+    trace_state_observer_.reset(nullptr);\n+  }\n+\n+  inline void DrainVMTasks(v8::Isolate* isolate) {\n+    platform_->DrainTasks(isolate);\n+  }\n+\n+  inline void CancelVMTasks(v8::Isolate* isolate) {\n+    platform_->CancelPendingDelayedTasks(isolate);\n+  }\n+\n+  inline void StartTracingAgent() {\n+    if (per_process::cli_options->trace_event_categories.empty()) {\n+      tracing_file_writer_ = tracing_agent_->DefaultHandle();\n+    } else {\n+      std::vector<std::string> categories =\n+          SplitString(per_process::cli_options->trace_event_categories, ',');\n+\n+      tracing_file_writer_ = tracing_agent_->AddClient(\n+          std::set<std::string>(std::make_move_iterator(categories.begin()),\n+                                std::make_move_iterator(categories.end())),\n+          std::unique_ptr<tracing::AsyncTraceWriter>(\n+              new tracing::NodeTraceWriter(\n+                  per_process::cli_options->trace_event_file_pattern)),\n+          tracing::Agent::kUseDefaultCategories);\n+    }\n+  }\n+\n+  inline void StopTracingAgent() { tracing_file_writer_.reset(); }\n+\n+  inline tracing::AgentWriterHandle* GetTracingAgentWriter() {\n+    return &tracing_file_writer_;\n+  }\n+\n+  inline NodePlatform* Platform() { return platform_; }\n+\n+  std::unique_ptr<NodeTraceStateObserver> trace_state_observer_;\n+  std::unique_ptr<tracing::Agent> tracing_agent_;\n+  tracing::AgentWriterHandle tracing_file_writer_;\n+  NodePlatform* platform_;\n+#else   // !NODE_USE_V8_PLATFORM\n+  inline void Initialize(int thread_pool_size) {}\n+  inline void Dispose() {}\n+  inline void DrainVMTasks(v8::Isolate* isolate) {}\n+  inline void CancelVMTasks(v8::Isolate* isolate) {}\n+  inline void StartTracingAgent() {\n+    if (!trace_enabled_categories.empty()) {\n+      fprintf(stderr,\n+              \"Node compiled with NODE_USE_V8_PLATFORM=0, \"\n+              \"so event tracing is not available.\\n\");\n+    }\n+  }\n+  inline void StopTracingAgent() {}\n+\n+  inline tracing::AgentWriterHandle* GetTracingAgentWriter() { return nullptr; }\n+\n+  inline NodePlatform* Platform() { return nullptr; }\n+#endif  // !NODE_USE_V8_PLATFORM\n+};\n+\n+namespace per_process {\n+extern struct V8Platform v8_platform;\n+}\n+\n+inline tracing::AgentWriterHandle* GetTracingAgentWriter() {\n+  return per_process::v8_platform.GetTracingAgentWriter();\n+}\n+\n+inline void DisposePlatform() {\n+  per_process::v8_platform.Dispose();\n+}\n+\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#endif  // SRC_NODE_V8_PLATFORM_INL_H_"
        }
    ],
    "stats": {
        "total": 386,
        "additions": 201,
        "deletions": 185
    }
}