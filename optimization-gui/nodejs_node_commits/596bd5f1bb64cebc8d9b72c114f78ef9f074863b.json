{
    "author": "unknown",
    "message": "src: factor out Node.js-agnostic N-APIs\n\nSplit the Node.js ECMAScript API (N-EAPI?) into its own header and\nimplementation files. The motivation is that the ECMAScript API stand\non its own so it might be embedded separately, implementation and all.\n\nPortions of the implementation used by both files are stored in\n`node_api_impl.h`.\n\nThe checked boxes below indicate that the given API remains in\n`node_api.h`, whereas the lack of a checkbox indicates that the API was\nmoved to `node_ecma_api.h`.\n\n* [x] NAPI_MODULE\n* [x] NAPI_MODULE_INIT\n* [x] napi_acquire_threadsafe_function\n* [x] napi_add_env_cleanup_hook\n* [x] napi_async_destroy\n* [x] napi_async_init\n* [x] napi_call_threadsafe_function\n* [x] napi_cancel_async_work\n* [x] napi_close_callback_scope\n* [x] napi_create_async_work\n* [x] napi_create_buffer\n* [x] napi_create_buffer_copy\n* [x] napi_create_external_buffer\n* [x] napi_create_threadsafe_function\n* [x] napi_delete_async_work\n* [x] napi_fatal_error\n* [x] napi_fatal_exception\n* [x] napi_get_buffer_info\n* [x] napi_get_node_version\n* [x] napi_get_threadsafe_function_context\n* [x] napi_get_uv_event_loop\n* [x] napi_is_buffer\n* [x] napi_make_callback\n* [x] napi_module_register\n* [x] napi_open_callback_scope\n* [x] napi_queue_async_work\n* [x] napi_ref_threadsafe_function\n* [x] napi_release_threadsafe_function\n* [x] napi_remove_env_cleanup_hook\n* [x] napi_unref_threadsafe_function\n* [ ] napi_add_finalizer\n* [ ] napi_adjust_external_memory\n* [ ] napi_call_function\n* [ ] napi_close_escapable_handle_scope\n* [ ] napi_close_handle_scope\n* [ ] napi_coerce_to_bool\n* [ ] napi_coerce_to_number\n* [ ] napi_coerce_to_object\n* [ ] napi_coerce_to_string\n* [ ] napi_create_array\n* [ ] napi_create_arraybuffer\n* [ ] napi_create_array_with_length\n* [ ] napi_create_bigint_int64\n* [ ] napi_create_bigint_uint64\n* [ ] napi_create_bigint_words\n* [ ] napi_create_dataview\n* [ ] napi_create_double\n* [ ] napi_create_error\n* [ ] napi_create_external\n* [ ] napi_create_external_arraybuffer\n* [ ] napi_create_function\n* [ ] napi_create_int32\n* [ ] napi_create_int64\n* [ ] napi_create_object\n* [ ] napi_create_promise\n* [ ] napi_create_range_error\n* [ ] napi_create_reference\n* [ ] napi_create_string_latin1\n* [ ] napi_create_string_utf16\n* [ ] napi_create_string_utf8\n* [ ] napi_create_symbol\n* [ ] napi_create_typedarray\n* [ ] napi_create_type_error\n* [ ] napi_create_uint32\n* [ ] napi_define_class\n* [ ] napi_define_properties\n* [ ] napi_delete_element\n* [ ] napi_delete_property\n* [ ] napi_delete_reference\n* [ ] napi_escape_handle\n* [ ] napi_get_and_clear_last_exception\n* [ ] napi_get_arraybuffer_info\n* [ ] napi_get_array_length\n* [ ] napi_get_boolean\n* [ ] napi_get_cb_info\n* [ ] napi_get_dataview_info\n* [ ] napi_get_element\n* [ ] napi_get_global\n* [ ] napi_get_last_error_info\n* [ ] napi_get_named_property\n* [ ] napi_get_new_target\n* [ ] napi_get_null\n* [ ] napi_get_property\n* [ ] napi_get_property_names\n* [ ] napi_get_prototype\n* [ ] napi_get_reference_value\n* [ ] napi_get_typedarray_info\n* [ ] napi_get_undefined\n* [ ] napi_get_value_bigint_int64\n* [ ] napi_get_value_bigint_uint64\n* [ ] napi_get_value_bigint_words\n* [ ] napi_get_value_bool\n* [ ] napi_get_value_double\n* [ ] napi_get_value_external\n* [ ] napi_get_value_int32\n* [ ] napi_get_value_int64\n* [ ] napi_get_value_string_latin1\n* [ ] napi_get_value_string_utf16\n* [ ] napi_get_value_string_utf8\n* [ ] napi_get_value_uint32\n* [ ] napi_get_version\n* [ ] napi_has_element\n* [ ] napi_has_named_property\n* [ ] napi_has_own_property\n* [ ] napi_has_property\n* [ ] napi_instanceof\n* [ ] napi_is_array\n* [ ] napi_is_arraybuffer\n* [ ] napi_is_dataview\n* [ ] napi_is_error\n* [ ] napi_is_exception_pending\n* [ ] napi_is_promise\n* [ ] napi_is_typedarray\n* [ ] napi_new_instance\n* [ ] napi_open_escapable_handle_scope\n* [ ] napi_open_handle_scope\n* [ ] napi_reference_ref\n* [ ] napi_reference_unref\n* [ ] napi_reject_deferred\n* [ ] napi_remove_wrap\n* [ ] napi_resolve_deferred\n* [ ] napi_run_script\n* [ ] napi_set_element\n* [ ] napi_set_named_property\n* [ ] napi_set_property\n* [ ] napi_strict_equals\n* [ ] napi_throw\n* [ ] napi_throw_error\n* [ ] napi_throw_range_error\n* [ ] napi_throw_type_error\n* [ ] napi_typeof\n* [ ] napi_unwrap\n* [ ] napi_wrap\n\nPR-URL: https://github.com/nodejs/node/pull/23786\nReviewed-By: Yazhong Liu <yorkiefixer@gmail.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>",
    "sha": "596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
    "files": [
        {
            "sha": "3dc34995cce21301e6c8d052c1d355b98e77ff54",
            "filename": "Makefile",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/Makefile",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/Makefile",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/Makefile?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -393,7 +393,8 @@ ADDONS_NAPI_BINDING_SOURCES := \\\n # Implicitly depends on $(NODE_EXE), see the build-addons-napi rule for rationale.\n test/addons-napi/.buildstamp: $(ADDONS_PREREQS) \\\n \t$(ADDONS_NAPI_BINDING_GYPS) $(ADDONS_NAPI_BINDING_SOURCES) \\\n-\tsrc/node_api.h src/node_api_types.h\n+\tsrc/node_api.h src/node_api_types.h src/js_native_api.h \\\n+\tsrc/js_native_api_types.h src/js_native_api_v8.h src/js_native_api_v8_internals.h\n \t@$(call run_build_addons,\"$$PWD/test/addons-napi\",$@)\n \n .PHONY: build-addons-napi"
        },
        {
            "sha": "33d9f561bec31321994e4851b23558657f99cbe5",
            "filename": "doc/api/n-api.md",
            "status": "modified",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/doc%2Fapi%2Fn-api.md",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/doc%2Fapi%2Fn-api.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fn-api.md?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -155,6 +155,65 @@ available to the module code.\n \n \\* Indicates that the N-API version was released as experimental\n \n+The N-APIs associated strictly with accessing ECMAScript features from native\n+code can be found separately in `js_native_api.h` and `js_native_api_types.h`.\n+The APIs defined in these headers are included in `node_api.h` and\n+`node_api_types.h`. The headers are structured in this way in order to allow\n+implementations of N-API outside of Node.js. For those implementations the\n+Node.js specific APIs may not be applicable.\n+\n+The Node.js-specific parts of an addon can be separated from the code that\n+exposes the actual functionality to the JavaScript environment so that the\n+latter may be used with multiple implementations of N-API. In the example below,\n+`addon.c` and `addon.h` refer only to `js_native_api.h`. This ensures that\n+`addon.c` can be reused to compile against either the Node.js implementation of\n+N-API or any implementation of N-API outside of Node.js.\n+\n+`addon_node.c` is a separate file that contains the Node.js specific entry point\n+to the addon and which instantiates the addon by calling into `addon.c` when the\n+addon is loaded into a Node.js environment.\n+\n+```C\n+// addon.h\n+#ifndef _ADDON_H_\n+#define _ADDON_H_\n+#include <js_native_api.h>\n+napi_value create_addon(napi_env env);\n+#endif  // _ADDON_H_\n+```\n+\n+```C\n+// addon.c\n+#include \"addon.h\"\n+napi_value create_addon(napi_env env) {\n+  napi_value result;\n+  assert(napi_create_object(env, &result) == napi_ok);\n+  napi_value exported_function;\n+  assert(napi_create_function(env,\n+                              \"doSomethingUseful\",\n+                              NAPI_AUTO_LENGTH,\n+                              DoSomethingUseful,\n+                              NULL,\n+                              &exported_function) == napi_ok);\n+  assert(napi_set_named_property(env,\n+                                 result,\n+                                 \"doSomethingUseful\",\n+                                 exported_function) == napi_ok);\n+  return result;\n+}\n+```\n+\n+```C\n+// addon_node.c\n+#include <node_api.h>\n+\n+static napi_value Init(napi_env env, napi_value exports) {\n+  return create_addon(env);\n+}\n+\n+NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)\n+```\n+\n ## Basic N-API Data Types\n \n N-API exposes the following fundamental datatypes as abstractions that are"
        },
        {
            "sha": "b40933a0ebc0c494d76165f46ec59ff2b1cbaed0",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -334,6 +334,11 @@\n         'src/fs_event_wrap.cc',\n         'src/handle_wrap.cc',\n         'src/heap_utils.cc',\n+        'src/js_native_api.h',\n+        'src/js_native_api_types.h',\n+        'src/js_native_api_v8.cc',\n+        'src/js_native_api_v8.h',\n+        'src/js_native_api_v8_internals.h',\n         'src/js_stream.cc',\n         'src/module_wrap.cc',\n         'src/node.cc',"
        },
        {
            "sha": "01707d78ccaa465a7e7edda2a4f61a22a7e29180",
            "filename": "src/js_native_api.h",
            "status": "added",
            "additions": 485,
            "deletions": 0,
            "changes": 485,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api.h",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_native_api.h?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -0,0 +1,485 @@\n+#ifndef SRC_JS_NATIVE_API_H_\n+#define SRC_JS_NATIVE_API_H_\n+\n+#include <stddef.h>\n+#include <stdbool.h>\n+#include \"js_native_api_types.h\"\n+\n+#ifndef NAPI_VERSION\n+#ifdef NAPI_EXPERIMENTAL\n+// Use INT_MAX, this should only be consumed by the pre-processor anyway.\n+#define NAPI_VERSION 2147483647\n+#else\n+// The baseline version for N-API\n+#define NAPI_VERSION 3\n+#endif\n+#endif\n+\n+// If you need __declspec(dllimport), either include <node_api.h> instead, or\n+// define NAPI_EXTERN as __declspec(dllimport) on the compiler's command line.\n+#ifndef NAPI_EXTERN\n+  #ifdef _WIN32\n+    #define NAPI_EXTERN __declspec(dllexport)\n+  #else\n+    #define NAPI_EXTERN /* nothing */\n+  #endif\n+#endif\n+\n+#define NAPI_AUTO_LENGTH SIZE_MAX\n+\n+#ifdef __cplusplus\n+#define EXTERN_C_START extern \"C\" {\n+#define EXTERN_C_END }\n+#else\n+#define EXTERN_C_START\n+#define EXTERN_C_END\n+#endif\n+\n+EXTERN_C_START\n+\n+NAPI_EXTERN napi_status\n+napi_get_last_error_info(napi_env env,\n+                         const napi_extended_error_info** result);\n+\n+// Getters for defined singletons\n+NAPI_EXTERN napi_status napi_get_undefined(napi_env env, napi_value* result);\n+NAPI_EXTERN napi_status napi_get_null(napi_env env, napi_value* result);\n+NAPI_EXTERN napi_status napi_get_global(napi_env env, napi_value* result);\n+NAPI_EXTERN napi_status napi_get_boolean(napi_env env,\n+                                         bool value,\n+                                         napi_value* result);\n+\n+// Methods to create Primitive types/Objects\n+NAPI_EXTERN napi_status napi_create_object(napi_env env, napi_value* result);\n+NAPI_EXTERN napi_status napi_create_array(napi_env env, napi_value* result);\n+NAPI_EXTERN napi_status napi_create_array_with_length(napi_env env,\n+                                                      size_t length,\n+                                                      napi_value* result);\n+NAPI_EXTERN napi_status napi_create_double(napi_env env,\n+                                           double value,\n+                                           napi_value* result);\n+NAPI_EXTERN napi_status napi_create_int32(napi_env env,\n+                                          int32_t value,\n+                                          napi_value* result);\n+NAPI_EXTERN napi_status napi_create_uint32(napi_env env,\n+                                           uint32_t value,\n+                                           napi_value* result);\n+NAPI_EXTERN napi_status napi_create_int64(napi_env env,\n+                                          int64_t value,\n+                                          napi_value* result);\n+NAPI_EXTERN napi_status napi_create_string_latin1(napi_env env,\n+                                                  const char* str,\n+                                                  size_t length,\n+                                                  napi_value* result);\n+NAPI_EXTERN napi_status napi_create_string_utf8(napi_env env,\n+                                                const char* str,\n+                                                size_t length,\n+                                                napi_value* result);\n+NAPI_EXTERN napi_status napi_create_string_utf16(napi_env env,\n+                                                 const char16_t* str,\n+                                                 size_t length,\n+                                                 napi_value* result);\n+NAPI_EXTERN napi_status napi_create_symbol(napi_env env,\n+                                           napi_value description,\n+                                           napi_value* result);\n+NAPI_EXTERN napi_status napi_create_function(napi_env env,\n+                                             const char* utf8name,\n+                                             size_t length,\n+                                             napi_callback cb,\n+                                             void* data,\n+                                             napi_value* result);\n+NAPI_EXTERN napi_status napi_create_error(napi_env env,\n+                                          napi_value code,\n+                                          napi_value msg,\n+                                          napi_value* result);\n+NAPI_EXTERN napi_status napi_create_type_error(napi_env env,\n+                                               napi_value code,\n+                                               napi_value msg,\n+                                               napi_value* result);\n+NAPI_EXTERN napi_status napi_create_range_error(napi_env env,\n+                                                napi_value code,\n+                                                napi_value msg,\n+                                                napi_value* result);\n+\n+// Methods to get the native napi_value from Primitive type\n+NAPI_EXTERN napi_status napi_typeof(napi_env env,\n+                                    napi_value value,\n+                                    napi_valuetype* result);\n+NAPI_EXTERN napi_status napi_get_value_double(napi_env env,\n+                                              napi_value value,\n+                                              double* result);\n+NAPI_EXTERN napi_status napi_get_value_int32(napi_env env,\n+                                             napi_value value,\n+                                             int32_t* result);\n+NAPI_EXTERN napi_status napi_get_value_uint32(napi_env env,\n+                                              napi_value value,\n+                                              uint32_t* result);\n+NAPI_EXTERN napi_status napi_get_value_int64(napi_env env,\n+                                             napi_value value,\n+                                             int64_t* result);\n+NAPI_EXTERN napi_status napi_get_value_bool(napi_env env,\n+                                            napi_value value,\n+                                            bool* result);\n+\n+// Copies LATIN-1 encoded bytes from a string into a buffer.\n+NAPI_EXTERN napi_status napi_get_value_string_latin1(napi_env env,\n+                                                     napi_value value,\n+                                                     char* buf,\n+                                                     size_t bufsize,\n+                                                     size_t* result);\n+\n+// Copies UTF-8 encoded bytes from a string into a buffer.\n+NAPI_EXTERN napi_status napi_get_value_string_utf8(napi_env env,\n+                                                   napi_value value,\n+                                                   char* buf,\n+                                                   size_t bufsize,\n+                                                   size_t* result);\n+\n+// Copies UTF-16 encoded bytes from a string into a buffer.\n+NAPI_EXTERN napi_status napi_get_value_string_utf16(napi_env env,\n+                                                    napi_value value,\n+                                                    char16_t* buf,\n+                                                    size_t bufsize,\n+                                                    size_t* result);\n+\n+// Methods to coerce values\n+// These APIs may execute user scripts\n+NAPI_EXTERN napi_status napi_coerce_to_bool(napi_env env,\n+                                            napi_value value,\n+                                            napi_value* result);\n+NAPI_EXTERN napi_status napi_coerce_to_number(napi_env env,\n+                                              napi_value value,\n+                                              napi_value* result);\n+NAPI_EXTERN napi_status napi_coerce_to_object(napi_env env,\n+                                              napi_value value,\n+                                              napi_value* result);\n+NAPI_EXTERN napi_status napi_coerce_to_string(napi_env env,\n+                                              napi_value value,\n+                                              napi_value* result);\n+\n+// Methods to work with Objects\n+NAPI_EXTERN napi_status napi_get_prototype(napi_env env,\n+                                           napi_value object,\n+                                           napi_value* result);\n+NAPI_EXTERN napi_status napi_get_property_names(napi_env env,\n+                                                napi_value object,\n+                                                napi_value* result);\n+NAPI_EXTERN napi_status napi_set_property(napi_env env,\n+                                          napi_value object,\n+                                          napi_value key,\n+                                          napi_value value);\n+NAPI_EXTERN napi_status napi_has_property(napi_env env,\n+                                          napi_value object,\n+                                          napi_value key,\n+                                          bool* result);\n+NAPI_EXTERN napi_status napi_get_property(napi_env env,\n+                                          napi_value object,\n+                                          napi_value key,\n+                                          napi_value* result);\n+NAPI_EXTERN napi_status napi_delete_property(napi_env env,\n+                                             napi_value object,\n+                                             napi_value key,\n+                                             bool* result);\n+NAPI_EXTERN napi_status napi_has_own_property(napi_env env,\n+                                              napi_value object,\n+                                              napi_value key,\n+                                              bool* result);\n+NAPI_EXTERN napi_status napi_set_named_property(napi_env env,\n+                                          napi_value object,\n+                                          const char* utf8name,\n+                                          napi_value value);\n+NAPI_EXTERN napi_status napi_has_named_property(napi_env env,\n+                                          napi_value object,\n+                                          const char* utf8name,\n+                                          bool* result);\n+NAPI_EXTERN napi_status napi_get_named_property(napi_env env,\n+                                          napi_value object,\n+                                          const char* utf8name,\n+                                          napi_value* result);\n+NAPI_EXTERN napi_status napi_set_element(napi_env env,\n+                                         napi_value object,\n+                                         uint32_t index,\n+                                         napi_value value);\n+NAPI_EXTERN napi_status napi_has_element(napi_env env,\n+                                         napi_value object,\n+                                         uint32_t index,\n+                                         bool* result);\n+NAPI_EXTERN napi_status napi_get_element(napi_env env,\n+                                         napi_value object,\n+                                         uint32_t index,\n+                                         napi_value* result);\n+NAPI_EXTERN napi_status napi_delete_element(napi_env env,\n+                                            napi_value object,\n+                                            uint32_t index,\n+                                            bool* result);\n+NAPI_EXTERN napi_status\n+napi_define_properties(napi_env env,\n+                       napi_value object,\n+                       size_t property_count,\n+                       const napi_property_descriptor* properties);\n+\n+// Methods to work with Arrays\n+NAPI_EXTERN napi_status napi_is_array(napi_env env,\n+                                      napi_value value,\n+                                      bool* result);\n+NAPI_EXTERN napi_status napi_get_array_length(napi_env env,\n+                                              napi_value value,\n+                                              uint32_t* result);\n+\n+// Methods to compare values\n+NAPI_EXTERN napi_status napi_strict_equals(napi_env env,\n+                                           napi_value lhs,\n+                                           napi_value rhs,\n+                                           bool* result);\n+\n+// Methods to work with Functions\n+NAPI_EXTERN napi_status napi_call_function(napi_env env,\n+                                           napi_value recv,\n+                                           napi_value func,\n+                                           size_t argc,\n+                                           const napi_value* argv,\n+                                           napi_value* result);\n+NAPI_EXTERN napi_status napi_new_instance(napi_env env,\n+                                          napi_value constructor,\n+                                          size_t argc,\n+                                          const napi_value* argv,\n+                                          napi_value* result);\n+NAPI_EXTERN napi_status napi_instanceof(napi_env env,\n+                                        napi_value object,\n+                                        napi_value constructor,\n+                                        bool* result);\n+\n+// Methods to work with napi_callbacks\n+\n+// Gets all callback info in a single call. (Ugly, but faster.)\n+NAPI_EXTERN napi_status napi_get_cb_info(\n+    napi_env env,               // [in] NAPI environment handle\n+    napi_callback_info cbinfo,  // [in] Opaque callback-info handle\n+    size_t* argc,      // [in-out] Specifies the size of the provided argv array\n+                       // and receives the actual count of args.\n+    napi_value* argv,  // [out] Array of values\n+    napi_value* this_arg,  // [out] Receives the JS 'this' arg for the call\n+    void** data);          // [out] Receives the data pointer for the callback.\n+\n+NAPI_EXTERN napi_status napi_get_new_target(napi_env env,\n+                                            napi_callback_info cbinfo,\n+                                            napi_value* result);\n+NAPI_EXTERN napi_status\n+napi_define_class(napi_env env,\n+                  const char* utf8name,\n+                  size_t length,\n+                  napi_callback constructor,\n+                  void* data,\n+                  size_t property_count,\n+                  const napi_property_descriptor* properties,\n+                  napi_value* result);\n+\n+// Methods to work with external data objects\n+NAPI_EXTERN napi_status napi_wrap(napi_env env,\n+                                  napi_value js_object,\n+                                  void* native_object,\n+                                  napi_finalize finalize_cb,\n+                                  void* finalize_hint,\n+                                  napi_ref* result);\n+NAPI_EXTERN napi_status napi_unwrap(napi_env env,\n+                                    napi_value js_object,\n+                                    void** result);\n+NAPI_EXTERN napi_status napi_remove_wrap(napi_env env,\n+                                         napi_value js_object,\n+                                         void** result);\n+NAPI_EXTERN napi_status napi_create_external(napi_env env,\n+                                             void* data,\n+                                             napi_finalize finalize_cb,\n+                                             void* finalize_hint,\n+                                             napi_value* result);\n+NAPI_EXTERN napi_status napi_get_value_external(napi_env env,\n+                                                napi_value value,\n+                                                void** result);\n+\n+// Methods to control object lifespan\n+\n+// Set initial_refcount to 0 for a weak reference, >0 for a strong reference.\n+NAPI_EXTERN napi_status napi_create_reference(napi_env env,\n+                                              napi_value value,\n+                                              uint32_t initial_refcount,\n+                                              napi_ref* result);\n+\n+// Deletes a reference. The referenced value is released, and may\n+// be GC'd unless there are other references to it.\n+NAPI_EXTERN napi_status napi_delete_reference(napi_env env, napi_ref ref);\n+\n+// Increments the reference count, optionally returning the resulting count.\n+// After this call the  reference will be a strong reference because its\n+// refcount is >0, and the referenced object is effectively \"pinned\".\n+// Calling this when the refcount is 0 and the object is unavailable\n+// results in an error.\n+NAPI_EXTERN napi_status napi_reference_ref(napi_env env,\n+                                           napi_ref ref,\n+                                           uint32_t* result);\n+\n+// Decrements the reference count, optionally returning the resulting count.\n+// If the result is 0 the reference is now weak and the object may be GC'd\n+// at any time if there are no other references. Calling this when the\n+// refcount is already 0 results in an error.\n+NAPI_EXTERN napi_status napi_reference_unref(napi_env env,\n+                                             napi_ref ref,\n+                                             uint32_t* result);\n+\n+// Attempts to get a referenced value. If the reference is weak,\n+// the value might no longer be available, in that case the call\n+// is still successful but the result is NULL.\n+NAPI_EXTERN napi_status napi_get_reference_value(napi_env env,\n+                                                 napi_ref ref,\n+                                                 napi_value* result);\n+\n+NAPI_EXTERN napi_status napi_open_handle_scope(napi_env env,\n+                                               napi_handle_scope* result);\n+NAPI_EXTERN napi_status napi_close_handle_scope(napi_env env,\n+                                                napi_handle_scope scope);\n+NAPI_EXTERN napi_status\n+napi_open_escapable_handle_scope(napi_env env,\n+                                 napi_escapable_handle_scope* result);\n+NAPI_EXTERN napi_status\n+napi_close_escapable_handle_scope(napi_env env,\n+                                  napi_escapable_handle_scope scope);\n+\n+NAPI_EXTERN napi_status napi_escape_handle(napi_env env,\n+                                           napi_escapable_handle_scope scope,\n+                                           napi_value escapee,\n+                                           napi_value* result);\n+\n+// Methods to support error handling\n+NAPI_EXTERN napi_status napi_throw(napi_env env, napi_value error);\n+NAPI_EXTERN napi_status napi_throw_error(napi_env env,\n+                                         const char* code,\n+                                         const char* msg);\n+NAPI_EXTERN napi_status napi_throw_type_error(napi_env env,\n+                                         const char* code,\n+                                         const char* msg);\n+NAPI_EXTERN napi_status napi_throw_range_error(napi_env env,\n+                                         const char* code,\n+                                         const char* msg);\n+NAPI_EXTERN napi_status napi_is_error(napi_env env,\n+                                      napi_value value,\n+                                      bool* result);\n+\n+// Methods to support catching exceptions\n+NAPI_EXTERN napi_status napi_is_exception_pending(napi_env env, bool* result);\n+NAPI_EXTERN napi_status napi_get_and_clear_last_exception(napi_env env,\n+                                                          napi_value* result);\n+\n+// Methods to work with array buffers and typed arrays\n+NAPI_EXTERN napi_status napi_is_arraybuffer(napi_env env,\n+                                            napi_value value,\n+                                            bool* result);\n+NAPI_EXTERN napi_status napi_create_arraybuffer(napi_env env,\n+                                                size_t byte_length,\n+                                                void** data,\n+                                                napi_value* result);\n+NAPI_EXTERN napi_status\n+napi_create_external_arraybuffer(napi_env env,\n+                                 void* external_data,\n+                                 size_t byte_length,\n+                                 napi_finalize finalize_cb,\n+                                 void* finalize_hint,\n+                                 napi_value* result);\n+NAPI_EXTERN napi_status napi_get_arraybuffer_info(napi_env env,\n+                                                  napi_value arraybuffer,\n+                                                  void** data,\n+                                                  size_t* byte_length);\n+NAPI_EXTERN napi_status napi_is_typedarray(napi_env env,\n+                                           napi_value value,\n+                                           bool* result);\n+NAPI_EXTERN napi_status napi_create_typedarray(napi_env env,\n+                                               napi_typedarray_type type,\n+                                               size_t length,\n+                                               napi_value arraybuffer,\n+                                               size_t byte_offset,\n+                                               napi_value* result);\n+NAPI_EXTERN napi_status napi_get_typedarray_info(napi_env env,\n+                                                 napi_value typedarray,\n+                                                 napi_typedarray_type* type,\n+                                                 size_t* length,\n+                                                 void** data,\n+                                                 napi_value* arraybuffer,\n+                                                 size_t* byte_offset);\n+\n+NAPI_EXTERN napi_status napi_create_dataview(napi_env env,\n+                                             size_t length,\n+                                             napi_value arraybuffer,\n+                                             size_t byte_offset,\n+                                             napi_value* result);\n+NAPI_EXTERN napi_status napi_is_dataview(napi_env env,\n+                                         napi_value value,\n+                                         bool* result);\n+NAPI_EXTERN napi_status napi_get_dataview_info(napi_env env,\n+                                               napi_value dataview,\n+                                               size_t* bytelength,\n+                                               void** data,\n+                                               napi_value* arraybuffer,\n+                                               size_t* byte_offset);\n+\n+// version management\n+NAPI_EXTERN napi_status napi_get_version(napi_env env, uint32_t* result);\n+\n+// Promises\n+NAPI_EXTERN napi_status napi_create_promise(napi_env env,\n+                                            napi_deferred* deferred,\n+                                            napi_value* promise);\n+NAPI_EXTERN napi_status napi_resolve_deferred(napi_env env,\n+                                              napi_deferred deferred,\n+                                              napi_value resolution);\n+NAPI_EXTERN napi_status napi_reject_deferred(napi_env env,\n+                                             napi_deferred deferred,\n+                                             napi_value rejection);\n+NAPI_EXTERN napi_status napi_is_promise(napi_env env,\n+                                        napi_value promise,\n+                                        bool* is_promise);\n+\n+// Running a script\n+NAPI_EXTERN napi_status napi_run_script(napi_env env,\n+                                        napi_value script,\n+                                        napi_value* result);\n+\n+// Memory management\n+NAPI_EXTERN napi_status napi_adjust_external_memory(napi_env env,\n+                                                    int64_t change_in_bytes,\n+                                                    int64_t* adjusted_value);\n+\n+#ifdef NAPI_EXPERIMENTAL\n+\n+NAPI_EXTERN napi_status napi_create_bigint_int64(napi_env env,\n+                                                 int64_t value,\n+                                                 napi_value* result);\n+NAPI_EXTERN napi_status napi_create_bigint_uint64(napi_env env,\n+                                                  uint64_t value,\n+                                                  napi_value* result);\n+NAPI_EXTERN napi_status napi_create_bigint_words(napi_env env,\n+                                                 int sign_bit,\n+                                                 size_t word_count,\n+                                                 const uint64_t* words,\n+                                                 napi_value* result);\n+NAPI_EXTERN napi_status napi_get_value_bigint_int64(napi_env env,\n+                                                    napi_value value,\n+                                                    int64_t* result,\n+                                                    bool* lossless);\n+NAPI_EXTERN napi_status napi_get_value_bigint_uint64(napi_env env,\n+                                                     napi_value value,\n+                                                     uint64_t* result,\n+                                                     bool* lossless);\n+NAPI_EXTERN napi_status napi_get_value_bigint_words(napi_env env,\n+                                                    napi_value value,\n+                                                    int* sign_bit,\n+                                                    size_t* word_count,\n+                                                    uint64_t* words);\n+NAPI_EXTERN napi_status napi_add_finalizer(napi_env env,\n+                                           napi_value js_object,\n+                                           void* native_object,\n+                                           napi_finalize finalize_cb,\n+                                           void* finalize_hint,\n+                                           napi_ref* result);\n+#endif  // NAPI_EXPERIMENTAL\n+\n+EXTERN_C_END\n+\n+#endif  // SRC_JS_NATIVE_API_H_"
        },
        {
            "sha": "a4739957991e3f7a197003b88ef03ec743ce2425",
            "filename": "src/js_native_api_types.h",
            "status": "added",
            "additions": 108,
            "deletions": 0,
            "changes": 108,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api_types.h",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api_types.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_native_api_types.h?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -0,0 +1,108 @@\n+#ifndef SRC_JS_NATIVE_API_TYPES_H_\n+#define SRC_JS_NATIVE_API_TYPES_H_\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+#if !defined __cplusplus || (defined(_MSC_VER) && _MSC_VER < 1900)\n+    typedef uint16_t char16_t;\n+#endif\n+\n+// JSVM API types are all opaque pointers for ABI stability\n+// typedef undefined structs instead of void* for compile time type safety\n+typedef struct napi_env__* napi_env;\n+typedef struct napi_value__* napi_value;\n+typedef struct napi_ref__* napi_ref;\n+typedef struct napi_handle_scope__* napi_handle_scope;\n+typedef struct napi_escapable_handle_scope__* napi_escapable_handle_scope;\n+typedef struct napi_callback_info__* napi_callback_info;\n+typedef struct napi_deferred__* napi_deferred;\n+\n+typedef enum {\n+  napi_default = 0,\n+  napi_writable = 1 << 0,\n+  napi_enumerable = 1 << 1,\n+  napi_configurable = 1 << 2,\n+\n+  // Used with napi_define_class to distinguish static properties\n+  // from instance properties. Ignored by napi_define_properties.\n+  napi_static = 1 << 10,\n+} napi_property_attributes;\n+\n+typedef enum {\n+  // ES6 types (corresponds to typeof)\n+  napi_undefined,\n+  napi_null,\n+  napi_boolean,\n+  napi_number,\n+  napi_string,\n+  napi_symbol,\n+  napi_object,\n+  napi_function,\n+  napi_external,\n+  napi_bigint,\n+} napi_valuetype;\n+\n+typedef enum {\n+  napi_int8_array,\n+  napi_uint8_array,\n+  napi_uint8_clamped_array,\n+  napi_int16_array,\n+  napi_uint16_array,\n+  napi_int32_array,\n+  napi_uint32_array,\n+  napi_float32_array,\n+  napi_float64_array,\n+  napi_bigint64_array,\n+  napi_biguint64_array,\n+} napi_typedarray_type;\n+\n+typedef enum {\n+  napi_ok,\n+  napi_invalid_arg,\n+  napi_object_expected,\n+  napi_string_expected,\n+  napi_name_expected,\n+  napi_function_expected,\n+  napi_number_expected,\n+  napi_boolean_expected,\n+  napi_array_expected,\n+  napi_generic_failure,\n+  napi_pending_exception,\n+  napi_cancelled,\n+  napi_escape_called_twice,\n+  napi_handle_scope_mismatch,\n+  napi_callback_scope_mismatch,\n+  napi_queue_full,\n+  napi_closing,\n+  napi_bigint_expected,\n+} napi_status;\n+\n+typedef napi_value (*napi_callback)(napi_env env,\n+                                    napi_callback_info info);\n+typedef void (*napi_finalize)(napi_env env,\n+                              void* finalize_data,\n+                              void* finalize_hint);\n+\n+typedef struct {\n+  // One of utf8name or name should be NULL.\n+  const char* utf8name;\n+  napi_value name;\n+\n+  napi_callback method;\n+  napi_callback getter;\n+  napi_callback setter;\n+  napi_value value;\n+\n+  napi_property_attributes attributes;\n+  void* data;\n+} napi_property_descriptor;\n+\n+typedef struct {\n+  const char* error_message;\n+  void* engine_reserved;\n+  uint32_t engine_error_code;\n+  napi_status error_code;\n+} napi_extended_error_info;\n+\n+#endif  // SRC_JS_NATIVE_API_TYPES_H_"
        },
        {
            "sha": "b28376afb7ceddac8ca5d48688ce4f1488ed024d",
            "filename": "src/js_native_api_v8.cc",
            "status": "added",
            "additions": 2907,
            "deletions": 0,
            "changes": 2907,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api_v8.cc",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api_v8.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_native_api_v8.cc?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -0,0 +1,2907 @@\n+#include <limits.h>  // INT_MAX\n+#include <cmath>\n+#define NAPI_EXPERIMENTAL\n+#include \"js_native_api_v8.h\"\n+#include \"js_native_api.h\"\n+\n+#define CHECK_MAYBE_NOTHING(env, maybe, status) \\\n+  RETURN_STATUS_IF_FALSE((env), !((maybe).IsNothing()), (status))\n+\n+#define CHECK_TO_NUMBER(env, context, result, src) \\\n+  CHECK_TO_TYPE((env), Number, (context), (result), (src), napi_number_expected)\n+\n+#define CHECK_TO_BOOL(env, context, result, src)            \\\n+  CHECK_TO_TYPE((env), Boolean, (context), (result), (src), \\\n+    napi_boolean_expected)\n+\n+// n-api defines NAPI_AUTO_LENGHTH as the indicator that a string\n+// is null terminated. For V8 the equivalent is -1. The assert\n+// validates that our cast of NAPI_AUTO_LENGTH results in -1 as\n+// needed by V8.\n+#define CHECK_NEW_FROM_UTF8_LEN(env, result, str, len)                   \\\n+  do {                                                                   \\\n+    static_assert(static_cast<int>(NAPI_AUTO_LENGTH) == -1,              \\\n+                  \"Casting NAPI_AUTO_LENGTH to int must result in -1\");  \\\n+    RETURN_STATUS_IF_FALSE((env),                                        \\\n+        (len == NAPI_AUTO_LENGTH) || len <= INT_MAX,                     \\\n+        napi_invalid_arg);                                               \\\n+    auto str_maybe = v8::String::NewFromUtf8(                            \\\n+        (env)->isolate, (str), v8::NewStringType::kInternalized,         \\\n+        static_cast<int>(len));                                          \\\n+    CHECK_MAYBE_EMPTY((env), str_maybe, napi_generic_failure);           \\\n+    (result) = str_maybe.ToLocalChecked();                               \\\n+  } while (0)\n+\n+#define CHECK_NEW_FROM_UTF8(env, result, str) \\\n+  CHECK_NEW_FROM_UTF8_LEN((env), (result), (str), NAPI_AUTO_LENGTH)\n+\n+#define CREATE_TYPED_ARRAY(                                                    \\\n+    env, type, size_of_element, buffer, byte_offset, length, out)              \\\n+  do {                                                                         \\\n+    if ((size_of_element) > 1) {                                               \\\n+      THROW_RANGE_ERROR_IF_FALSE(                                              \\\n+          (env), (byte_offset) % (size_of_element) == 0,                       \\\n+          \"ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT\",                             \\\n+          \"start offset of \"#type\" should be a multiple of \"#size_of_element); \\\n+    }                                                                          \\\n+    THROW_RANGE_ERROR_IF_FALSE((env), (length) * (size_of_element) +           \\\n+        (byte_offset) <= buffer->ByteLength(),                                 \\\n+        \"ERR_NAPI_INVALID_TYPEDARRAY_LENGTH\",                                  \\\n+        \"Invalid typed array length\");                                         \\\n+    (out) = v8::type::New((buffer), (byte_offset), (length));                  \\\n+  } while (0)\n+\n+namespace v8impl {\n+\n+namespace {\n+\n+inline static napi_status\n+V8NameFromPropertyDescriptor(napi_env env,\n+                             const napi_property_descriptor* p,\n+                             v8::Local<v8::Name>* result) {\n+  if (p->utf8name != nullptr) {\n+    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);\n+  } else {\n+    v8::Local<v8::Value> property_value =\n+      v8impl::V8LocalValueFromJsValue(p->name);\n+\n+    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);\n+    *result = property_value.As<v8::Name>();\n+  }\n+\n+  return napi_ok;\n+}\n+\n+// convert from n-api property attributes to v8::PropertyAttribute\n+inline static v8::PropertyAttribute V8PropertyAttributesFromDescriptor(\n+    const napi_property_descriptor* descriptor) {\n+  unsigned int attribute_flags = v8::PropertyAttribute::None;\n+\n+  if (descriptor->getter != nullptr || descriptor->setter != nullptr) {\n+    // The napi_writable attribute is ignored for accessor descriptors, but\n+    // V8 requires the ReadOnly attribute to match nonexistence of a setter.\n+    attribute_flags |= (descriptor->setter == nullptr ?\n+      v8::PropertyAttribute::ReadOnly : v8::PropertyAttribute::None);\n+  } else if ((descriptor->attributes & napi_writable) == 0) {\n+    attribute_flags |= v8::PropertyAttribute::ReadOnly;\n+  }\n+\n+  if ((descriptor->attributes & napi_enumerable) == 0) {\n+    attribute_flags |= v8::PropertyAttribute::DontEnum;\n+  }\n+  if ((descriptor->attributes & napi_configurable) == 0) {\n+    attribute_flags |= v8::PropertyAttribute::DontDelete;\n+  }\n+\n+  return static_cast<v8::PropertyAttribute>(attribute_flags);\n+}\n+\n+inline static napi_deferred\n+JsDeferredFromNodePersistent(v8impl::Persistent<v8::Value>* local) {\n+  return reinterpret_cast<napi_deferred>(local);\n+}\n+\n+inline static v8impl::Persistent<v8::Value>*\n+NodePersistentFromJsDeferred(napi_deferred local) {\n+  return reinterpret_cast<v8impl::Persistent<v8::Value>*>(local);\n+}\n+\n+class HandleScopeWrapper {\n+ public:\n+  explicit HandleScopeWrapper(v8::Isolate* isolate) : scope(isolate) {}\n+\n+ private:\n+  v8::HandleScope scope;\n+};\n+\n+// In node v0.10 version of v8, there is no EscapableHandleScope and the\n+// node v0.10 port use HandleScope::Close(Local<T> v) to mimic the behavior\n+// of a EscapableHandleScope::Escape(Local<T> v), but it is not the same\n+// semantics. This is an example of where the api abstraction fail to work\n+// across different versions.\n+class EscapableHandleScopeWrapper {\n+ public:\n+  explicit EscapableHandleScopeWrapper(v8::Isolate* isolate)\n+      : scope(isolate), escape_called_(false) {}\n+  bool escape_called() const {\n+    return escape_called_;\n+  }\n+  template <typename T>\n+  v8::Local<T> Escape(v8::Local<T> handle) {\n+    escape_called_ = true;\n+    return scope.Escape(handle);\n+  }\n+\n+ private:\n+  v8::EscapableHandleScope scope;\n+  bool escape_called_;\n+};\n+\n+inline static napi_handle_scope\n+JsHandleScopeFromV8HandleScope(HandleScopeWrapper* s) {\n+  return reinterpret_cast<napi_handle_scope>(s);\n+}\n+\n+inline static HandleScopeWrapper*\n+V8HandleScopeFromJsHandleScope(napi_handle_scope s) {\n+  return reinterpret_cast<HandleScopeWrapper*>(s);\n+}\n+\n+inline static napi_escapable_handle_scope\n+JsEscapableHandleScopeFromV8EscapableHandleScope(\n+    EscapableHandleScopeWrapper* s) {\n+  return reinterpret_cast<napi_escapable_handle_scope>(s);\n+}\n+\n+inline static EscapableHandleScopeWrapper*\n+V8EscapableHandleScopeFromJsEscapableHandleScope(\n+    napi_escapable_handle_scope s) {\n+  return reinterpret_cast<EscapableHandleScopeWrapper*>(s);\n+}\n+\n+inline static napi_status ConcludeDeferred(napi_env env,\n+                                           napi_deferred deferred,\n+                                           napi_value result,\n+                                           bool is_resolved) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->isolate->GetCurrentContext();\n+  v8impl::Persistent<v8::Value>* deferred_ref =\n+      NodePersistentFromJsDeferred(deferred);\n+  v8::Local<v8::Value> v8_deferred =\n+      v8::Local<v8::Value>::New(env->isolate, *deferred_ref);\n+\n+  auto v8_resolver = v8::Local<v8::Promise::Resolver>::Cast(v8_deferred);\n+\n+  v8::Maybe<bool> success = is_resolved ?\n+      v8_resolver->Resolve(context, v8impl::V8LocalValueFromJsValue(result)) :\n+      v8_resolver->Reject(context, v8impl::V8LocalValueFromJsValue(result));\n+\n+  delete deferred_ref;\n+\n+  RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure);\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+// Wrapper around v8impl::Persistent that implements reference counting.\n+class Reference : private Finalizer {\n+ private:\n+  Reference(napi_env env,\n+            v8::Local<v8::Value> value,\n+            uint32_t initial_refcount,\n+            bool delete_self,\n+            napi_finalize finalize_callback,\n+            void* finalize_data,\n+            void* finalize_hint)\n+       : Finalizer(env, finalize_callback, finalize_data, finalize_hint),\n+        _persistent(env->isolate, value),\n+        _refcount(initial_refcount),\n+        _delete_self(delete_self) {\n+    if (initial_refcount == 0) {\n+      _persistent.SetWeak(\n+          this, FinalizeCallback, v8::WeakCallbackType::kParameter);\n+    }\n+  }\n+\n+ public:\n+  void* Data() {\n+    return _finalize_data;\n+  }\n+\n+  static Reference* New(napi_env env,\n+                        v8::Local<v8::Value> value,\n+                        uint32_t initial_refcount,\n+                        bool delete_self,\n+                        napi_finalize finalize_callback = nullptr,\n+                        void* finalize_data = nullptr,\n+                        void* finalize_hint = nullptr) {\n+    return new Reference(env,\n+      value,\n+      initial_refcount,\n+      delete_self,\n+      finalize_callback,\n+      finalize_data,\n+      finalize_hint);\n+  }\n+\n+  static void Delete(Reference* reference) {\n+    delete reference;\n+  }\n+\n+  uint32_t Ref() {\n+    if (++_refcount == 1) {\n+      _persistent.ClearWeak();\n+    }\n+\n+    return _refcount;\n+  }\n+\n+  uint32_t Unref() {\n+    if (_refcount == 0) {\n+        return 0;\n+    }\n+    if (--_refcount == 0) {\n+      _persistent.SetWeak(\n+          this, FinalizeCallback, v8::WeakCallbackType::kParameter);\n+    }\n+\n+    return _refcount;\n+  }\n+\n+  uint32_t RefCount() {\n+    return _refcount;\n+  }\n+\n+  v8::Local<v8::Value> Get() {\n+    if (_persistent.IsEmpty()) {\n+      return v8::Local<v8::Value>();\n+    } else {\n+      return v8::Local<v8::Value>::New(_env->isolate, _persistent);\n+    }\n+  }\n+\n+ private:\n+  static void FinalizeCallback(const v8::WeakCallbackInfo<Reference>& data) {\n+    Reference* reference = data.GetParameter();\n+    reference->_persistent.Reset();\n+\n+    // Check before calling the finalize callback, because the callback might\n+    // delete it.\n+    bool delete_self = reference->_delete_self;\n+    napi_env env = reference->_env;\n+\n+    if (reference->_finalize_callback != nullptr) {\n+      NAPI_CALL_INTO_MODULE_THROW(env,\n+        reference->_finalize_callback(\n+            reference->_env,\n+            reference->_finalize_data,\n+            reference->_finalize_hint));\n+    }\n+\n+    if (delete_self) {\n+      Delete(reference);\n+    }\n+  }\n+\n+  v8impl::Persistent<v8::Value> _persistent;\n+  uint32_t _refcount;\n+  bool _delete_self;\n+};\n+\n+enum UnwrapAction {\n+  KeepWrap,\n+  RemoveWrap\n+};\n+\n+inline static napi_status Unwrap(napi_env env,\n+                                 napi_value js_object,\n+                                 void** result,\n+                                 UnwrapAction action) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, js_object);\n+  if (action == KeepWrap) {\n+    CHECK_ARG(env, result);\n+  }\n+\n+  v8::Isolate* isolate = env->isolate;\n+  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n+\n+  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);\n+  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);\n+  v8::Local<v8::Object> obj = value.As<v8::Object>();\n+\n+  auto val = obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper))\n+      .ToLocalChecked();\n+  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);\n+  Reference* reference =\n+      static_cast<v8impl::Reference*>(val.As<v8::External>()->Value());\n+\n+  if (result) {\n+    *result = reference->Data();\n+  }\n+\n+  if (action == RemoveWrap) {\n+    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))\n+        .FromJust());\n+    Reference::Delete(reference);\n+  }\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+//=== Function napi_callback wrapper =================================\n+\n+// Use this data structure to associate callback data with each N-API function\n+// exposed to JavaScript. The structure is stored in a v8::External which gets\n+// passed into our callback wrapper. This reduces the performance impact of\n+// calling through N-API.\n+// Ref: benchmark/misc/function_call\n+// Discussion (incl. perf. data): https://github.com/nodejs/node/pull/21072\n+struct CallbackBundle {\n+  // Bind the lifecycle of `this` C++ object to a JavaScript object.\n+  // We never delete a CallbackBundle C++ object directly.\n+  void BindLifecycleTo(v8::Isolate* isolate, v8::Local<v8::Value> target) {\n+    handle.Reset(isolate, target);\n+    handle.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);\n+  }\n+\n+  napi_env       env;      // Necessary to invoke C++ NAPI callback\n+  void*          cb_data;  // The user provided callback data\n+  napi_callback  function_or_getter;\n+  napi_callback  setter;\n+  v8impl::Persistent<v8::Value> handle;  // Die with this JavaScript object\n+\n+ private:\n+  static void WeakCallback(v8::WeakCallbackInfo<CallbackBundle> const& info) {\n+    // Use the \"WeakCallback mechanism\" to delete the C++ `bundle` object.\n+    // This will be called when the v8::External containing `this` pointer\n+    // is being GC-ed.\n+    CallbackBundle* bundle = info.GetParameter();\n+    if (bundle != nullptr) {\n+      delete bundle;\n+    }\n+  }\n+};\n+\n+// Base class extended by classes that wrap V8 function and property callback\n+// info.\n+class CallbackWrapper {\n+ public:\n+  CallbackWrapper(napi_value this_arg, size_t args_length, void* data)\n+      : _this(this_arg), _args_length(args_length), _data(data) {}\n+\n+  virtual napi_value GetNewTarget() = 0;\n+  virtual void Args(napi_value* buffer, size_t bufferlength) = 0;\n+  virtual void SetReturnValue(napi_value value) = 0;\n+\n+  napi_value This() { return _this; }\n+\n+  size_t ArgsLength() { return _args_length; }\n+\n+  void* Data() { return _data; }\n+\n+ protected:\n+  const napi_value _this;\n+  const size_t _args_length;\n+  void* _data;\n+};\n+\n+template <typename Info, napi_callback CallbackBundle::*FunctionField>\n+class CallbackWrapperBase : public CallbackWrapper {\n+ public:\n+  CallbackWrapperBase(const Info& cbinfo, const size_t args_length)\n+      : CallbackWrapper(JsValueFromV8LocalValue(cbinfo.This()),\n+                        args_length,\n+                        nullptr),\n+        _cbinfo(cbinfo) {\n+    _bundle = reinterpret_cast<CallbackBundle*>(\n+        v8::Local<v8::External>::Cast(cbinfo.Data())->Value());\n+    _data = _bundle->cb_data;\n+  }\n+\n+  napi_value GetNewTarget() override { return nullptr; }\n+\n+ protected:\n+  void InvokeCallback() {\n+    napi_callback_info cbinfo_wrapper = reinterpret_cast<napi_callback_info>(\n+        static_cast<CallbackWrapper*>(this));\n+\n+    // All other pointers we need are stored in `_bundle`\n+    napi_env env = _bundle->env;\n+    napi_callback cb = _bundle->*FunctionField;\n+\n+    napi_value result;\n+    NAPI_CALL_INTO_MODULE_THROW(env, result = cb(env, cbinfo_wrapper));\n+\n+    if (result != nullptr) {\n+      this->SetReturnValue(result);\n+    }\n+  }\n+\n+  const Info& _cbinfo;\n+  CallbackBundle* _bundle;\n+};\n+\n+class FunctionCallbackWrapper\n+    : public CallbackWrapperBase<v8::FunctionCallbackInfo<v8::Value>,\n+                                 &CallbackBundle::function_or_getter> {\n+ public:\n+  static void Invoke(const v8::FunctionCallbackInfo<v8::Value>& info) {\n+    FunctionCallbackWrapper cbwrapper(info);\n+    cbwrapper.InvokeCallback();\n+  }\n+\n+  explicit FunctionCallbackWrapper(\n+      const v8::FunctionCallbackInfo<v8::Value>& cbinfo)\n+      : CallbackWrapperBase(cbinfo, cbinfo.Length()) {}\n+\n+  napi_value GetNewTarget() override {\n+    if (_cbinfo.IsConstructCall()) {\n+      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());\n+    } else {\n+      return nullptr;\n+    }\n+  }\n+\n+  /*virtual*/\n+  void Args(napi_value* buffer, size_t buffer_length) override {\n+    size_t i = 0;\n+    size_t min = std::min(buffer_length, _args_length);\n+\n+    for (; i < min; i += 1) {\n+      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);\n+    }\n+\n+    if (i < buffer_length) {\n+      napi_value undefined =\n+          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));\n+      for (; i < buffer_length; i += 1) {\n+        buffer[i] = undefined;\n+      }\n+    }\n+  }\n+\n+  /*virtual*/\n+  void SetReturnValue(napi_value value) override {\n+    v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+    _cbinfo.GetReturnValue().Set(val);\n+  }\n+};\n+\n+class GetterCallbackWrapper\n+    : public CallbackWrapperBase<v8::PropertyCallbackInfo<v8::Value>,\n+                                 &CallbackBundle::function_or_getter> {\n+ public:\n+  static void Invoke(v8::Local<v8::Name> property,\n+                     const v8::PropertyCallbackInfo<v8::Value>& info) {\n+    GetterCallbackWrapper cbwrapper(info);\n+    cbwrapper.InvokeCallback();\n+  }\n+\n+  explicit GetterCallbackWrapper(\n+      const v8::PropertyCallbackInfo<v8::Value>& cbinfo)\n+      : CallbackWrapperBase(cbinfo, 0) {}\n+\n+  /*virtual*/\n+  void Args(napi_value* buffer, size_t buffer_length) override {\n+    if (buffer_length > 0) {\n+      napi_value undefined =\n+          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));\n+      for (size_t i = 0; i < buffer_length; i += 1) {\n+        buffer[i] = undefined;\n+      }\n+    }\n+  }\n+\n+  /*virtual*/\n+  void SetReturnValue(napi_value value) override {\n+    v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+    _cbinfo.GetReturnValue().Set(val);\n+  }\n+};\n+\n+class SetterCallbackWrapper\n+    : public CallbackWrapperBase<v8::PropertyCallbackInfo<void>,\n+                                 &CallbackBundle::setter> {\n+ public:\n+  static void Invoke(v8::Local<v8::Name> property,\n+                     v8::Local<v8::Value> value,\n+                     const v8::PropertyCallbackInfo<void>& info) {\n+    SetterCallbackWrapper cbwrapper(info, value);\n+    cbwrapper.InvokeCallback();\n+  }\n+\n+  SetterCallbackWrapper(const v8::PropertyCallbackInfo<void>& cbinfo,\n+                        const v8::Local<v8::Value>& value)\n+      : CallbackWrapperBase(cbinfo, 1), _value(value) {}\n+\n+  /*virtual*/\n+  void Args(napi_value* buffer, size_t buffer_length) override {\n+    if (buffer_length > 0) {\n+      buffer[0] = v8impl::JsValueFromV8LocalValue(_value);\n+\n+      if (buffer_length > 1) {\n+        napi_value undefined = v8impl::JsValueFromV8LocalValue(\n+            v8::Undefined(_cbinfo.GetIsolate()));\n+        for (size_t i = 1; i < buffer_length; i += 1) {\n+          buffer[i] = undefined;\n+        }\n+      }\n+    }\n+  }\n+\n+  /*virtual*/\n+  void SetReturnValue(napi_value value) override {\n+    // Ignore any value returned from a setter callback.\n+  }\n+\n+ private:\n+  const v8::Local<v8::Value>& _value;\n+};\n+\n+// Creates an object to be made available to the static function callback\n+// wrapper, used to retrieve the native callback function and data pointer.\n+static\n+v8::Local<v8::Value> CreateFunctionCallbackData(napi_env env,\n+                                                napi_callback cb,\n+                                                void* data) {\n+  CallbackBundle* bundle = new CallbackBundle();\n+  bundle->function_or_getter = cb;\n+  bundle->cb_data = data;\n+  bundle->env = env;\n+  v8::Local<v8::Value> cbdata = v8::External::New(env->isolate, bundle);\n+  bundle->BindLifecycleTo(env->isolate, cbdata);\n+\n+  return cbdata;\n+}\n+\n+// Creates an object to be made available to the static getter/setter\n+// callback wrapper, used to retrieve the native getter/setter callback\n+// function and data pointer.\n+inline v8::Local<v8::Value> CreateAccessorCallbackData(napi_env env,\n+                                                       napi_callback getter,\n+                                                       napi_callback setter,\n+                                                       void* data) {\n+  CallbackBundle* bundle = new CallbackBundle();\n+  bundle->function_or_getter = getter;\n+  bundle->setter = setter;\n+  bundle->cb_data = data;\n+  bundle->env = env;\n+  v8::Local<v8::Value> cbdata = v8::External::New(env->isolate, bundle);\n+  bundle->BindLifecycleTo(env->isolate, cbdata);\n+\n+  return cbdata;\n+}\n+\n+enum WrapType {\n+  retrievable,\n+  anonymous\n+};\n+\n+template <WrapType wrap_type>\n+inline napi_status Wrap(napi_env env,\n+                        napi_value js_object,\n+                        void* native_object,\n+                        napi_finalize finalize_cb,\n+                        void* finalize_hint,\n+                        napi_ref* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, js_object);\n+\n+  v8::Local<v8::Context> context = env->context();\n+\n+  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);\n+  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);\n+  v8::Local<v8::Object> obj = value.As<v8::Object>();\n+\n+  if (wrap_type == retrievable) {\n+    // If we've already wrapped this object, we error out.\n+    RETURN_STATUS_IF_FALSE(env,\n+        !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper))\n+            .FromJust(),\n+        napi_invalid_arg);\n+  } else if (wrap_type == anonymous) {\n+    // If no finalize callback is provided, we error out.\n+    CHECK_ARG(env, finalize_cb);\n+  }\n+\n+  v8impl::Reference* reference = nullptr;\n+  if (result != nullptr) {\n+    // The returned reference should be deleted via napi_delete_reference()\n+    // ONLY in response to the finalize callback invocation. (If it is deleted\n+    // before then, then the finalize callback will never be invoked.)\n+    // Therefore a finalize callback is required when returning a reference.\n+    CHECK_ARG(env, finalize_cb);\n+    reference = v8impl::Reference::New(\n+        env, obj, 0, false, finalize_cb, native_object, finalize_hint);\n+    *result = reinterpret_cast<napi_ref>(reference);\n+  } else {\n+    // Create a self-deleting reference.\n+    reference = v8impl::Reference::New(env, obj, 0, true, finalize_cb,\n+        native_object, finalize_cb == nullptr ? nullptr : finalize_hint);\n+  }\n+\n+  if (wrap_type == retrievable) {\n+    CHECK(obj->SetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper),\n+          v8::External::New(env->isolate, reference)).FromJust());\n+  }\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+}  // end of anonymous namespace\n+\n+}  // end of namespace v8impl\n+\n+// Warning: Keep in-sync with napi_status enum\n+static\n+const char* error_messages[] = {nullptr,\n+                                \"Invalid argument\",\n+                                \"An object was expected\",\n+                                \"A string was expected\",\n+                                \"A string or symbol was expected\",\n+                                \"A function was expected\",\n+                                \"A number was expected\",\n+                                \"A boolean was expected\",\n+                                \"An array was expected\",\n+                                \"Unknown failure\",\n+                                \"An exception is pending\",\n+                                \"The async work item was cancelled\",\n+                                \"napi_escape_handle already called on scope\",\n+                                \"Invalid handle scope usage\",\n+                                \"Invalid callback scope usage\",\n+                                \"Thread-safe function queue is full\",\n+                                \"Thread-safe function handle is closing\",\n+                                \"A bigint was expected\",\n+};\n+\n+napi_status napi_get_last_error_info(napi_env env,\n+                                     const napi_extended_error_info** result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  // you must update this assert to reference the last message\n+  // in the napi_status enum each time a new error message is added.\n+  // We don't have a napi_status_last as this would result in an ABI\n+  // change each time a message was added.\n+  static_assert(\n+      NAPI_ARRAYSIZE(error_messages) == napi_bigint_expected + 1,\n+      \"Count of error messages must match count of error values\");\n+  CHECK_LE(env->last_error.error_code, napi_callback_scope_mismatch);\n+\n+  // Wait until someone requests the last error information to fetch the error\n+  // message string\n+  env->last_error.error_message =\n+      error_messages[env->last_error.error_code];\n+\n+  *result = &(env->last_error);\n+  return napi_ok;\n+}\n+\n+napi_status napi_create_function(napi_env env,\n+                                 const char* utf8name,\n+                                 size_t length,\n+                                 napi_callback cb,\n+                                 void* callback_data,\n+                                 napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+  CHECK_ARG(env, cb);\n+\n+  v8::Isolate* isolate = env->isolate;\n+  v8::Local<v8::Function> return_value;\n+  v8::EscapableHandleScope scope(isolate);\n+  v8::Local<v8::Value> cbdata =\n+      v8impl::CreateFunctionCallbackData(env, cb, callback_data);\n+\n+  RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::MaybeLocal<v8::Function> maybe_function =\n+      v8::Function::New(context,\n+                        v8impl::FunctionCallbackWrapper::Invoke,\n+                        cbdata);\n+  CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure);\n+\n+  return_value = scope.Escape(maybe_function.ToLocalChecked());\n+\n+  if (utf8name != nullptr) {\n+    v8::Local<v8::String> name_string;\n+    CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);\n+    return_value->SetName(name_string);\n+  }\n+\n+  *result = v8impl::JsValueFromV8LocalValue(return_value);\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_define_class(napi_env env,\n+                              const char* utf8name,\n+                              size_t length,\n+                              napi_callback constructor,\n+                              void* callback_data,\n+                              size_t property_count,\n+                              const napi_property_descriptor* properties,\n+                              napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+  CHECK_ARG(env, constructor);\n+\n+  v8::Isolate* isolate = env->isolate;\n+\n+  v8::EscapableHandleScope scope(isolate);\n+  v8::Local<v8::Value> cbdata =\n+      v8impl::CreateFunctionCallbackData(env, constructor, callback_data);\n+\n+  RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);\n+\n+  v8::Local<v8::FunctionTemplate> tpl = v8::FunctionTemplate::New(\n+      isolate, v8impl::FunctionCallbackWrapper::Invoke, cbdata);\n+\n+  v8::Local<v8::String> name_string;\n+  CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);\n+  tpl->SetClassName(name_string);\n+\n+  size_t static_property_count = 0;\n+  for (size_t i = 0; i < property_count; i++) {\n+    const napi_property_descriptor* p = properties + i;\n+\n+    if ((p->attributes & napi_static) != 0) {\n+      // Static properties are handled separately below.\n+      static_property_count++;\n+      continue;\n+    }\n+\n+    v8::Local<v8::Name> property_name;\n+    napi_status status =\n+        v8impl::V8NameFromPropertyDescriptor(env, p, &property_name);\n+\n+    if (status != napi_ok) {\n+      return napi_set_last_error(env, status);\n+    }\n+\n+    v8::PropertyAttribute attributes =\n+        v8impl::V8PropertyAttributesFromDescriptor(p);\n+\n+    // This code is similar to that in napi_define_properties(); the\n+    // difference is it applies to a template instead of an object.\n+    if (p->getter != nullptr || p->setter != nullptr) {\n+      v8::Local<v8::Value> cbdata = v8impl::CreateAccessorCallbackData(\n+        env, p->getter, p->setter, p->data);\n+\n+      tpl->PrototypeTemplate()->SetAccessor(\n+        property_name,\n+        p->getter ? v8impl::GetterCallbackWrapper::Invoke : nullptr,\n+        p->setter ? v8impl::SetterCallbackWrapper::Invoke : nullptr,\n+        cbdata,\n+        v8::AccessControl::DEFAULT,\n+        attributes);\n+    } else if (p->method != nullptr) {\n+      v8::Local<v8::Value> cbdata =\n+          v8impl::CreateFunctionCallbackData(env, p->method, p->data);\n+\n+      RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);\n+\n+      v8::Local<v8::FunctionTemplate> t =\n+        v8::FunctionTemplate::New(isolate,\n+          v8impl::FunctionCallbackWrapper::Invoke,\n+          cbdata,\n+          v8::Signature::New(isolate, tpl));\n+\n+      tpl->PrototypeTemplate()->Set(property_name, t, attributes);\n+    } else {\n+      v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(p->value);\n+      tpl->PrototypeTemplate()->Set(property_name, value, attributes);\n+    }\n+  }\n+\n+  v8::Local<v8::Context> context = env->context();\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      scope.Escape(tpl->GetFunction(context).ToLocalChecked()));\n+\n+  if (static_property_count > 0) {\n+    std::vector<napi_property_descriptor> static_descriptors;\n+    static_descriptors.reserve(static_property_count);\n+\n+    for (size_t i = 0; i < property_count; i++) {\n+      const napi_property_descriptor* p = properties + i;\n+      if ((p->attributes & napi_static) != 0) {\n+        static_descriptors.push_back(*p);\n+      }\n+    }\n+\n+    napi_status status =\n+        napi_define_properties(env,\n+                               *result,\n+                               static_descriptors.size(),\n+                               static_descriptors.data());\n+    if (status != napi_ok) return status;\n+  }\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_get_property_names(napi_env env,\n+                                    napi_value object,\n+                                    napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  auto maybe_propertynames = obj->GetPropertyNames(context);\n+\n+  CHECK_MAYBE_EMPTY(env, maybe_propertynames, napi_generic_failure);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      maybe_propertynames.ToLocalChecked());\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_set_property(napi_env env,\n+                              napi_value object,\n+                              napi_value key,\n+                              napi_value value) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, key);\n+  CHECK_ARG(env, value);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+\n+  v8::Maybe<bool> set_maybe = obj->Set(context, k, val);\n+\n+  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_has_property(napi_env env,\n+                              napi_value object,\n+                              napi_value key,\n+                              bool* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+  CHECK_ARG(env, key);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);\n+  v8::Maybe<bool> has_maybe = obj->Has(context, k);\n+\n+  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);\n+\n+  *result = has_maybe.FromMaybe(false);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_get_property(napi_env env,\n+                              napi_value object,\n+                              napi_value key,\n+                              napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, key);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  auto get_maybe = obj->Get(context, k);\n+\n+  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);\n+\n+  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();\n+  *result = v8impl::JsValueFromV8LocalValue(val);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_delete_property(napi_env env,\n+                                 napi_value object,\n+                                 napi_value key,\n+                                 bool* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, key);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+  v8::Maybe<bool> delete_maybe = obj->Delete(context, k);\n+  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);\n+\n+  if (result != nullptr)\n+    *result = delete_maybe.FromMaybe(false);\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_has_own_property(napi_env env,\n+                                  napi_value object,\n+                                  napi_value key,\n+                                  bool* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, key);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);\n+  RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected);\n+  v8::Maybe<bool> has_maybe = obj->HasOwnProperty(context, k.As<v8::Name>());\n+  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);\n+  *result = has_maybe.FromMaybe(false);\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_set_named_property(napi_env env,\n+                                    napi_value object,\n+                                    const char* utf8name,\n+                                    napi_value value) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, value);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  v8::Local<v8::Name> key;\n+  CHECK_NEW_FROM_UTF8(env, key, utf8name);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+\n+  v8::Maybe<bool> set_maybe = obj->Set(context, key, val);\n+\n+  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_has_named_property(napi_env env,\n+                                    napi_value object,\n+                                    const char* utf8name,\n+                                    bool* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  v8::Local<v8::Name> key;\n+  CHECK_NEW_FROM_UTF8(env, key, utf8name);\n+\n+  v8::Maybe<bool> has_maybe = obj->Has(context, key);\n+\n+  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);\n+\n+  *result = has_maybe.FromMaybe(false);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_get_named_property(napi_env env,\n+                                    napi_value object,\n+                                    const char* utf8name,\n+                                    napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+\n+  v8::Local<v8::Name> key;\n+  CHECK_NEW_FROM_UTF8(env, key, utf8name);\n+\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  auto get_maybe = obj->Get(context, key);\n+\n+  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);\n+\n+  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();\n+  *result = v8impl::JsValueFromV8LocalValue(val);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_set_element(napi_env env,\n+                             napi_value object,\n+                             uint32_t index,\n+                             napi_value value) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, value);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  auto set_maybe = obj->Set(context, index, val);\n+\n+  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_has_element(napi_env env,\n+                             napi_value object,\n+                             uint32_t index,\n+                             bool* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  v8::Maybe<bool> has_maybe = obj->Has(context, index);\n+\n+  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);\n+\n+  *result = has_maybe.FromMaybe(false);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_get_element(napi_env env,\n+                             napi_value object,\n+                             uint32_t index,\n+                             napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  auto get_maybe = obj->Get(context, index);\n+\n+  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(get_maybe.ToLocalChecked());\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_delete_element(napi_env env,\n+                                napi_value object,\n+                                uint32_t index,\n+                                bool* result) {\n+  NAPI_PREAMBLE(env);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+  v8::Maybe<bool> delete_maybe = obj->Delete(context, index);\n+  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);\n+\n+  if (result != nullptr)\n+    *result = delete_maybe.FromMaybe(false);\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_define_properties(napi_env env,\n+                                   napi_value object,\n+                                   size_t property_count,\n+                                   const napi_property_descriptor* properties) {\n+  NAPI_PREAMBLE(env);\n+  if (property_count > 0) {\n+    CHECK_ARG(env, properties);\n+  }\n+\n+  v8::Local<v8::Context> context = env->context();\n+\n+  v8::Local<v8::Object> obj;\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  for (size_t i = 0; i < property_count; i++) {\n+    const napi_property_descriptor* p = &properties[i];\n+\n+    v8::Local<v8::Name> property_name;\n+    napi_status status =\n+        v8impl::V8NameFromPropertyDescriptor(env, p, &property_name);\n+\n+    if (status != napi_ok) {\n+      return napi_set_last_error(env, status);\n+    }\n+\n+    v8::PropertyAttribute attributes =\n+        v8impl::V8PropertyAttributesFromDescriptor(p);\n+\n+    if (p->getter != nullptr || p->setter != nullptr) {\n+      v8::Local<v8::Value> cbdata = v8impl::CreateAccessorCallbackData(\n+        env,\n+        p->getter,\n+        p->setter,\n+        p->data);\n+\n+      auto set_maybe = obj->SetAccessor(\n+        context,\n+        property_name,\n+        p->getter ? v8impl::GetterCallbackWrapper::Invoke : nullptr,\n+        p->setter ? v8impl::SetterCallbackWrapper::Invoke : nullptr,\n+        cbdata,\n+        v8::AccessControl::DEFAULT,\n+        attributes);\n+\n+      if (!set_maybe.FromMaybe(false)) {\n+        return napi_set_last_error(env, napi_invalid_arg);\n+      }\n+    } else if (p->method != nullptr) {\n+      v8::Local<v8::Value> cbdata =\n+          v8impl::CreateFunctionCallbackData(env, p->method, p->data);\n+\n+      CHECK_MAYBE_EMPTY(env, cbdata, napi_generic_failure);\n+\n+      v8::MaybeLocal<v8::Function> maybe_fn =\n+          v8::Function::New(context,\n+                            v8impl::FunctionCallbackWrapper::Invoke,\n+                            cbdata);\n+\n+      CHECK_MAYBE_EMPTY(env, maybe_fn, napi_generic_failure);\n+\n+      auto define_maybe = obj->DefineOwnProperty(\n+        context, property_name, maybe_fn.ToLocalChecked(), attributes);\n+\n+      if (!define_maybe.FromMaybe(false)) {\n+        return napi_set_last_error(env, napi_generic_failure);\n+      }\n+    } else {\n+      v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(p->value);\n+\n+      auto define_maybe =\n+          obj->DefineOwnProperty(context, property_name, value, attributes);\n+\n+      if (!define_maybe.FromMaybe(false)) {\n+        return napi_set_last_error(env, napi_invalid_arg);\n+      }\n+    }\n+  }\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_is_array(napi_env env, napi_value value, bool* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+\n+  *result = val->IsArray();\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_array_length(napi_env env,\n+                                  napi_value value,\n+                                  uint32_t* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected);\n+\n+  v8::Local<v8::Array> arr = val.As<v8::Array>();\n+  *result = arr->Length();\n+\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_strict_equals(napi_env env,\n+                               napi_value lhs,\n+                               napi_value rhs,\n+                               bool* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, lhs);\n+  CHECK_ARG(env, rhs);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> a = v8impl::V8LocalValueFromJsValue(lhs);\n+  v8::Local<v8::Value> b = v8impl::V8LocalValueFromJsValue(rhs);\n+\n+  *result = a->StrictEquals(b);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_get_prototype(napi_env env,\n+                               napi_value object,\n+                               napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+\n+  v8::Local<v8::Object> obj;\n+  CHECK_TO_OBJECT(env, context, obj, object);\n+\n+  v8::Local<v8::Value> val = obj->GetPrototype();\n+  *result = v8impl::JsValueFromV8LocalValue(val);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_create_object(napi_env env, napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Object::New(env->isolate));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_array(napi_env env, napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Array::New(env->isolate));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_array_with_length(napi_env env,\n+                                          size_t length,\n+                                          napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Array::New(env->isolate, length));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_string_latin1(napi_env env,\n+                                      const char* str,\n+                                      size_t length,\n+                                      napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  auto isolate = env->isolate;\n+  auto str_maybe =\n+      v8::String::NewFromOneByte(isolate,\n+                                 reinterpret_cast<const uint8_t*>(str),\n+                                 v8::NewStringType::kInternalized,\n+                                 length);\n+  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_string_utf8(napi_env env,\n+                                    const char* str,\n+                                    size_t length,\n+                                    napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::String> s;\n+  CHECK_NEW_FROM_UTF8_LEN(env, s, str, length);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(s);\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_string_utf16(napi_env env,\n+                                     const char16_t* str,\n+                                     size_t length,\n+                                     napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  auto isolate = env->isolate;\n+  auto str_maybe =\n+      v8::String::NewFromTwoByte(isolate,\n+                                 reinterpret_cast<const uint16_t*>(str),\n+                                 v8::NewStringType::kInternalized,\n+                                 length);\n+  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_double(napi_env env,\n+                               double value,\n+                               napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Number::New(env->isolate, value));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_int32(napi_env env,\n+                              int32_t value,\n+                              napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Integer::New(env->isolate, value));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_uint32(napi_env env,\n+                               uint32_t value,\n+                               napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Integer::NewFromUnsigned(env->isolate, value));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_int64(napi_env env,\n+                              int64_t value,\n+                              napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Number::New(env->isolate, static_cast<double>(value)));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_bigint_int64(napi_env env,\n+                                     int64_t value,\n+                                     napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::BigInt::New(env->isolate, value));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_bigint_uint64(napi_env env,\n+                                      uint64_t value,\n+                                      napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::BigInt::NewFromUnsigned(env->isolate, value));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_bigint_words(napi_env env,\n+                                     int sign_bit,\n+                                     size_t word_count,\n+                                     const uint64_t* words,\n+                                     napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, words);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+\n+  if (word_count > INT_MAX) {\n+    napi_throw_range_error(env, nullptr, \"Maximum BigInt size exceeded\");\n+    return napi_set_last_error(env, napi_pending_exception);\n+  }\n+\n+  v8::MaybeLocal<v8::BigInt> b = v8::BigInt::NewFromWords(\n+      context, sign_bit, word_count, words);\n+\n+  if (try_catch.HasCaught()) {\n+    return napi_set_last_error(env, napi_pending_exception);\n+  } else {\n+    CHECK_MAYBE_EMPTY(env, b, napi_generic_failure);\n+    *result = v8impl::JsValueFromV8LocalValue(b.ToLocalChecked());\n+    return napi_clear_last_error(env);\n+  }\n+}\n+\n+napi_status napi_get_boolean(napi_env env, bool value, napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Isolate* isolate = env->isolate;\n+\n+  if (value) {\n+    *result = v8impl::JsValueFromV8LocalValue(v8::True(isolate));\n+  } else {\n+    *result = v8impl::JsValueFromV8LocalValue(v8::False(isolate));\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_symbol(napi_env env,\n+                               napi_value description,\n+                               napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Isolate* isolate = env->isolate;\n+\n+  if (description == nullptr) {\n+    *result = v8impl::JsValueFromV8LocalValue(v8::Symbol::New(isolate));\n+  } else {\n+    v8::Local<v8::Value> desc = v8impl::V8LocalValueFromJsValue(description);\n+    RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected);\n+\n+    *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Symbol::New(isolate, desc.As<v8::String>()));\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+static inline napi_status set_error_code(napi_env env,\n+                                         v8::Local<v8::Value> error,\n+                                         napi_value code,\n+                                         const char* code_cstring) {\n+  if ((code != nullptr) || (code_cstring != nullptr)) {\n+    v8::Isolate* isolate = env->isolate;\n+    v8::Local<v8::Context> context = env->context();\n+    v8::Local<v8::Object> err_object = error.As<v8::Object>();\n+\n+    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);\n+    if (code != nullptr) {\n+      code_value = v8impl::V8LocalValueFromJsValue(code);\n+      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);\n+    } else {\n+      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);\n+    }\n+\n+    v8::Local<v8::Name> code_key;\n+    CHECK_NEW_FROM_UTF8(env, code_key, \"code\");\n+\n+    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);\n+    RETURN_STATUS_IF_FALSE(env,\n+                           set_maybe.FromMaybe(false),\n+                           napi_generic_failure);\n+\n+    // now update the name to be \"name [code]\" where name is the\n+    // original name and code is the code associated with the Error\n+    v8::Local<v8::String> name_string;\n+    CHECK_NEW_FROM_UTF8(env, name_string, \"\");\n+    v8::Local<v8::Name> name_key;\n+    CHECK_NEW_FROM_UTF8(env, name_key, \"name\");\n+\n+    auto maybe_name = err_object->Get(context, name_key);\n+    if (!maybe_name.IsEmpty()) {\n+      v8::Local<v8::Value> name = maybe_name.ToLocalChecked();\n+      if (name->IsString()) {\n+        name_string =\n+            v8::String::Concat(isolate, name_string, name.As<v8::String>());\n+      }\n+    }\n+    name_string = v8::String::Concat(\n+        isolate, name_string, NAPI_FIXED_ONE_BYTE_STRING(isolate, \" [\"));\n+    name_string =\n+        v8::String::Concat(isolate, name_string, code_value.As<v8::String>());\n+    name_string = v8::String::Concat(\n+        isolate, name_string, NAPI_FIXED_ONE_BYTE_STRING(isolate, \"]\"));\n+\n+    set_maybe = err_object->Set(context, name_key, name_string);\n+    RETURN_STATUS_IF_FALSE(env,\n+                           set_maybe.FromMaybe(false),\n+                           napi_generic_failure);\n+  }\n+  return napi_ok;\n+}\n+\n+napi_status napi_create_error(napi_env env,\n+                              napi_value code,\n+                              napi_value msg,\n+                              napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, msg);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);\n+  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);\n+\n+  v8::Local<v8::Value> error_obj =\n+      v8::Exception::Error(message_value.As<v8::String>());\n+  napi_status status = set_error_code(env, error_obj, code, nullptr);\n+  if (status != napi_ok) return status;\n+\n+  *result = v8impl::JsValueFromV8LocalValue(error_obj);\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_type_error(napi_env env,\n+                                   napi_value code,\n+                                   napi_value msg,\n+                                   napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, msg);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);\n+  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);\n+\n+  v8::Local<v8::Value> error_obj =\n+      v8::Exception::TypeError(message_value.As<v8::String>());\n+  napi_status status = set_error_code(env, error_obj, code, nullptr);\n+  if (status != napi_ok) return status;\n+\n+  *result = v8impl::JsValueFromV8LocalValue(error_obj);\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_range_error(napi_env env,\n+                                    napi_value code,\n+                                    napi_value msg,\n+                                    napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, msg);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);\n+  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);\n+\n+  v8::Local<v8::Value> error_obj =\n+      v8::Exception::RangeError(message_value.As<v8::String>());\n+  napi_status status = set_error_code(env, error_obj, code, nullptr);\n+  if (status != napi_ok) return status;\n+\n+  *result = v8impl::JsValueFromV8LocalValue(error_obj);\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_typeof(napi_env env,\n+                        napi_value value,\n+                        napi_valuetype* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> v = v8impl::V8LocalValueFromJsValue(value);\n+\n+  if (v->IsNumber()) {\n+    *result = napi_number;\n+  } else if (v->IsBigInt()) {\n+    *result = napi_bigint;\n+  } else if (v->IsString()) {\n+    *result = napi_string;\n+  } else if (v->IsFunction()) {\n+    // This test has to come before IsObject because IsFunction\n+    // implies IsObject\n+    *result = napi_function;\n+  } else if (v->IsExternal()) {\n+    // This test has to come before IsObject because IsExternal\n+    // implies IsObject\n+    *result = napi_external;\n+  } else if (v->IsObject()) {\n+    *result = napi_object;\n+  } else if (v->IsBoolean()) {\n+    *result = napi_boolean;\n+  } else if (v->IsUndefined()) {\n+    *result = napi_undefined;\n+  } else if (v->IsSymbol()) {\n+    *result = napi_symbol;\n+  } else if (v->IsNull()) {\n+    *result = napi_null;\n+  } else {\n+    // Should not get here unless V8 has added some new kind of value.\n+    return napi_set_last_error(env, napi_invalid_arg);\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_undefined(napi_env env, napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Undefined(env->isolate));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_null(napi_env env, napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(\n+        v8::Null(env->isolate));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+// Gets all callback info in a single call. (Ugly, but faster.)\n+napi_status napi_get_cb_info(\n+    napi_env env,               // [in] NAPI environment handle\n+    napi_callback_info cbinfo,  // [in] Opaque callback-info handle\n+    size_t* argc,      // [in-out] Specifies the size of the provided argv array\n+                       // and receives the actual count of args.\n+    napi_value* argv,  // [out] Array of values\n+    napi_value* this_arg,  // [out] Receives the JS 'this' arg for the call\n+    void** data) {         // [out] Receives the data pointer for the callback.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, cbinfo);\n+\n+  v8impl::CallbackWrapper* info =\n+      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);\n+\n+  if (argv != nullptr) {\n+    CHECK_ARG(env, argc);\n+    info->Args(argv, *argc);\n+  }\n+  if (argc != nullptr) {\n+    *argc = info->ArgsLength();\n+  }\n+  if (this_arg != nullptr) {\n+    *this_arg = info->This();\n+  }\n+  if (data != nullptr) {\n+    *data = info->Data();\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_new_target(napi_env env,\n+                                napi_callback_info cbinfo,\n+                                napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, cbinfo);\n+  CHECK_ARG(env, result);\n+\n+  v8impl::CallbackWrapper* info =\n+      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);\n+\n+  *result = info->GetNewTarget();\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_call_function(napi_env env,\n+                               napi_value recv,\n+                               napi_value func,\n+                               size_t argc,\n+                               const napi_value* argv,\n+                               napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, recv);\n+  if (argc > 0) {\n+    CHECK_ARG(env, argv);\n+  }\n+\n+  v8::Local<v8::Context> context = env->context();\n+\n+  v8::Local<v8::Value> v8recv = v8impl::V8LocalValueFromJsValue(recv);\n+\n+  v8::Local<v8::Function> v8func;\n+  CHECK_TO_FUNCTION(env, v8func, func);\n+\n+  auto maybe = v8func->Call(context, v8recv, argc,\n+    reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));\n+\n+  if (try_catch.HasCaught()) {\n+    return napi_set_last_error(env, napi_pending_exception);\n+  } else {\n+    if (result != nullptr) {\n+      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);\n+      *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());\n+    }\n+    return napi_clear_last_error(env);\n+  }\n+}\n+\n+napi_status napi_get_global(napi_env env, napi_value* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(env->context()->Global());\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_throw(napi_env env, napi_value error) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, error);\n+\n+  v8::Isolate* isolate = env->isolate;\n+\n+  isolate->ThrowException(v8impl::V8LocalValueFromJsValue(error));\n+  // any VM calls after this point and before returning\n+  // to the javascript invoker will fail\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_throw_error(napi_env env,\n+                             const char* code,\n+                             const char* msg) {\n+  NAPI_PREAMBLE(env);\n+\n+  v8::Isolate* isolate = env->isolate;\n+  v8::Local<v8::String> str;\n+  CHECK_NEW_FROM_UTF8(env, str, msg);\n+\n+  v8::Local<v8::Value> error_obj = v8::Exception::Error(str);\n+  napi_status status = set_error_code(env, error_obj, nullptr, code);\n+  if (status != napi_ok) return status;\n+\n+  isolate->ThrowException(error_obj);\n+  // any VM calls after this point and before returning\n+  // to the javascript invoker will fail\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_throw_type_error(napi_env env,\n+                                  const char* code,\n+                                  const char* msg) {\n+  NAPI_PREAMBLE(env);\n+\n+  v8::Isolate* isolate = env->isolate;\n+  v8::Local<v8::String> str;\n+  CHECK_NEW_FROM_UTF8(env, str, msg);\n+\n+  v8::Local<v8::Value> error_obj = v8::Exception::TypeError(str);\n+  napi_status status = set_error_code(env, error_obj, nullptr, code);\n+  if (status != napi_ok) return status;\n+\n+  isolate->ThrowException(error_obj);\n+  // any VM calls after this point and before returning\n+  // to the javascript invoker will fail\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_throw_range_error(napi_env env,\n+                                   const char* code,\n+                                   const char* msg) {\n+  NAPI_PREAMBLE(env);\n+\n+  v8::Isolate* isolate = env->isolate;\n+  v8::Local<v8::String> str;\n+  CHECK_NEW_FROM_UTF8(env, str, msg);\n+\n+  v8::Local<v8::Value> error_obj = v8::Exception::RangeError(str);\n+  napi_status status = set_error_code(env, error_obj, nullptr, code);\n+  if (status != napi_ok) return status;\n+\n+  isolate->ThrowException(error_obj);\n+  // any VM calls after this point and before returning\n+  // to the javascript invoker will fail\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_is_error(napi_env env, napi_value value, bool* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot\n+  // throw JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  *result = val->IsNativeError();\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_value_double(napi_env env,\n+                                  napi_value value,\n+                                  double* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);\n+\n+  *result = val.As<v8::Number>()->Value();\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_value_int32(napi_env env,\n+                                 napi_value value,\n+                                 int32_t* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+\n+  if (val->IsInt32()) {\n+    *result = val.As<v8::Int32>()->Value();\n+  } else {\n+    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);\n+\n+    // Empty context: https://github.com/nodejs/node/issues/14379\n+    v8::Local<v8::Context> context;\n+    *result = val->Int32Value(context).FromJust();\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_value_uint32(napi_env env,\n+                                  napi_value value,\n+                                  uint32_t* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+\n+  if (val->IsUint32()) {\n+    *result = val.As<v8::Uint32>()->Value();\n+  } else {\n+    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);\n+\n+    // Empty context: https://github.com/nodejs/node/issues/14379\n+    v8::Local<v8::Context> context;\n+    *result = val->Uint32Value(context).FromJust();\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_value_int64(napi_env env,\n+                                 napi_value value,\n+                                 int64_t* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+\n+  // This is still a fast path very likely to be taken.\n+  if (val->IsInt32()) {\n+    *result = val.As<v8::Int32>()->Value();\n+    return napi_clear_last_error(env);\n+  }\n+\n+  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);\n+\n+  // v8::Value::IntegerValue() converts NaN, +Inf, and -Inf to INT64_MIN,\n+  // inconsistent with v8::Value::Int32Value() which converts those values to 0.\n+  // Special-case all non-finite values to match that behavior.\n+  double doubleValue = val.As<v8::Number>()->Value();\n+  if (std::isfinite(doubleValue)) {\n+    // Empty context: https://github.com/nodejs/node/issues/14379\n+    v8::Local<v8::Context> context;\n+    *result = val->IntegerValue(context).FromJust();\n+  } else {\n+    *result = 0;\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_value_bigint_int64(napi_env env,\n+                                        napi_value value,\n+                                        int64_t* result,\n+                                        bool* lossless) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+  CHECK_ARG(env, lossless);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+\n+  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);\n+\n+  *result = val.As<v8::BigInt>()->Int64Value(lossless);\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_value_bigint_uint64(napi_env env,\n+                                         napi_value value,\n+                                         uint64_t* result,\n+                                         bool* lossless) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+  CHECK_ARG(env, lossless);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+\n+  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);\n+\n+  *result = val.As<v8::BigInt>()->Uint64Value(lossless);\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_value_bigint_words(napi_env env,\n+                                        napi_value value,\n+                                        int* sign_bit,\n+                                        size_t* word_count,\n+                                        uint64_t* words) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, word_count);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+\n+  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);\n+\n+  v8::Local<v8::BigInt> big = val.As<v8::BigInt>();\n+\n+  int word_count_int = *word_count;\n+\n+  if (sign_bit == nullptr && words == nullptr) {\n+    word_count_int = big->WordCount();\n+  } else {\n+    CHECK_ARG(env, sign_bit);\n+    CHECK_ARG(env, words);\n+    big->ToWordsArray(sign_bit, &word_count_int, words);\n+  }\n+\n+  *word_count = word_count_int;\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_value_bool(napi_env env, napi_value value, bool* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected);\n+\n+  *result = val.As<v8::Boolean>()->Value();\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+// Copies a JavaScript string into a LATIN-1 string buffer. The result is the\n+// number of bytes (excluding the null terminator) copied into buf.\n+// A sufficient buffer size should be greater than the length of string,\n+// reserving space for null terminator.\n+// If bufsize is insufficient, the string will be truncated and null terminated.\n+// If buf is NULL, this method returns the length of the string (in bytes)\n+// via the result parameter.\n+// The result argument is optional unless buf is NULL.\n+napi_status napi_get_value_string_latin1(napi_env env,\n+                                         napi_value value,\n+                                         char* buf,\n+                                         size_t bufsize,\n+                                         size_t* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);\n+\n+  if (!buf) {\n+    CHECK_ARG(env, result);\n+    *result = val.As<v8::String>()->Length();\n+  } else {\n+    int copied =\n+        val.As<v8::String>()->WriteOneByte(env->isolate,\n+                                           reinterpret_cast<uint8_t*>(buf),\n+                                           0,\n+                                           bufsize - 1,\n+                                           v8::String::NO_NULL_TERMINATION);\n+\n+    buf[copied] = '\\0';\n+    if (result != nullptr) {\n+      *result = copied;\n+    }\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+// Copies a JavaScript string into a UTF-8 string buffer. The result is the\n+// number of bytes (excluding the null terminator) copied into buf.\n+// A sufficient buffer size should be greater than the length of string,\n+// reserving space for null terminator.\n+// If bufsize is insufficient, the string will be truncated and null terminated.\n+// If buf is NULL, this method returns the length of the string (in bytes)\n+// via the result parameter.\n+// The result argument is optional unless buf is NULL.\n+napi_status napi_get_value_string_utf8(napi_env env,\n+                                       napi_value value,\n+                                       char* buf,\n+                                       size_t bufsize,\n+                                       size_t* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);\n+\n+  if (!buf) {\n+    CHECK_ARG(env, result);\n+    *result = val.As<v8::String>()->Utf8Length(env->isolate);\n+  } else {\n+    int copied = val.As<v8::String>()->WriteUtf8(\n+        env->isolate,\n+        buf,\n+        bufsize - 1,\n+        nullptr,\n+        v8::String::REPLACE_INVALID_UTF8 | v8::String::NO_NULL_TERMINATION);\n+\n+    buf[copied] = '\\0';\n+    if (result != nullptr) {\n+      *result = copied;\n+    }\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+// Copies a JavaScript string into a UTF-16 string buffer. The result is the\n+// number of 2-byte code units (excluding the null terminator) copied into buf.\n+// A sufficient buffer size should be greater than the length of string,\n+// reserving space for null terminator.\n+// If bufsize is insufficient, the string will be truncated and null terminated.\n+// If buf is NULL, this method returns the length of the string (in 2-byte\n+// code units) via the result parameter.\n+// The result argument is optional unless buf is NULL.\n+napi_status napi_get_value_string_utf16(napi_env env,\n+                                        napi_value value,\n+                                        char16_t* buf,\n+                                        size_t bufsize,\n+                                        size_t* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);\n+\n+  if (!buf) {\n+    CHECK_ARG(env, result);\n+    // V8 assumes UTF-16 length is the same as the number of characters.\n+    *result = val.As<v8::String>()->Length();\n+  } else {\n+    int copied = val.As<v8::String>()->Write(env->isolate,\n+                                             reinterpret_cast<uint16_t*>(buf),\n+                                             0,\n+                                             bufsize - 1,\n+                                             v8::String::NO_NULL_TERMINATION);\n+\n+    buf[copied] = '\\0';\n+    if (result != nullptr) {\n+      *result = copied;\n+    }\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_coerce_to_object(napi_env env,\n+                                  napi_value value,\n+                                  napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Object> obj;\n+  CHECK_TO_OBJECT(env, context, obj, value);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(obj);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_coerce_to_bool(napi_env env,\n+                                napi_value value,\n+                                napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Boolean> b;\n+\n+  CHECK_TO_BOOL(env, context, b, value);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(b);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_coerce_to_number(napi_env env,\n+                                  napi_value value,\n+                                  napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::Number> num;\n+\n+  CHECK_TO_NUMBER(env, context, num, value);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(num);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_coerce_to_string(napi_env env,\n+                                  napi_value value,\n+                                  napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+  v8::Local<v8::String> str;\n+\n+  CHECK_TO_STRING(env, context, str, value);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(str);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_wrap(napi_env env,\n+                      napi_value js_object,\n+                      void* native_object,\n+                      napi_finalize finalize_cb,\n+                      void* finalize_hint,\n+                      napi_ref* result) {\n+  return v8impl::Wrap<v8impl::retrievable>(env,\n+                                           js_object,\n+                                           native_object,\n+                                           finalize_cb,\n+                                           finalize_hint,\n+                                           result);\n+}\n+\n+napi_status napi_unwrap(napi_env env, napi_value obj, void** result) {\n+  return v8impl::Unwrap(env, obj, result, v8impl::KeepWrap);\n+}\n+\n+napi_status napi_remove_wrap(napi_env env, napi_value obj, void** result) {\n+  return v8impl::Unwrap(env, obj, result, v8impl::RemoveWrap);\n+}\n+\n+napi_status napi_create_external(napi_env env,\n+                                 void* data,\n+                                 napi_finalize finalize_cb,\n+                                 void* finalize_hint,\n+                                 napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Isolate* isolate = env->isolate;\n+\n+  v8::Local<v8::Value> external_value = v8::External::New(isolate, data);\n+\n+  // The Reference object will delete itself after invoking the finalizer\n+  // callback.\n+  v8impl::Reference::New(env,\n+      external_value,\n+      0,\n+      true,\n+      finalize_cb,\n+      data,\n+      finalize_hint);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(external_value);\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_value_external(napi_env env,\n+                                    napi_value value,\n+                                    void** result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);\n+\n+  v8::Local<v8::External> external_value = val.As<v8::External>();\n+  *result = external_value->Value();\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+// Set initial_refcount to 0 for a weak reference, >0 for a strong reference.\n+napi_status napi_create_reference(napi_env env,\n+                                  napi_value value,\n+                                  uint32_t initial_refcount,\n+                                  napi_ref* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(value);\n+\n+  if (!(v8_value->IsObject() || v8_value->IsFunction())) {\n+    return napi_set_last_error(env, napi_object_expected);\n+  }\n+\n+  v8impl::Reference* reference =\n+      v8impl::Reference::New(env, v8_value, initial_refcount, false);\n+\n+  *result = reinterpret_cast<napi_ref>(reference);\n+  return napi_clear_last_error(env);\n+}\n+\n+// Deletes a reference. The referenced value is released, and may be GC'd unless\n+// there are other references to it.\n+napi_status napi_delete_reference(napi_env env, napi_ref ref) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, ref);\n+\n+  v8impl::Reference::Delete(reinterpret_cast<v8impl::Reference*>(ref));\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+// Increments the reference count, optionally returning the resulting count.\n+// After this call the reference will be a strong reference because its\n+// refcount is >0, and the referenced object is effectively \"pinned\".\n+// Calling this when the refcount is 0 and the object is unavailable\n+// results in an error.\n+napi_status napi_reference_ref(napi_env env, napi_ref ref, uint32_t* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, ref);\n+\n+  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);\n+  uint32_t count = reference->Ref();\n+\n+  if (result != nullptr) {\n+    *result = count;\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+// Decrements the reference count, optionally returning the resulting count. If\n+// the result is 0 the reference is now weak and the object may be GC'd at any\n+// time if there are no other references. Calling this when the refcount is\n+// already 0 results in an error.\n+napi_status napi_reference_unref(napi_env env, napi_ref ref, uint32_t* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, ref);\n+\n+  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);\n+\n+  if (reference->RefCount() == 0) {\n+    return napi_set_last_error(env, napi_generic_failure);\n+  }\n+\n+  uint32_t count = reference->Unref();\n+\n+  if (result != nullptr) {\n+    *result = count;\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+// Attempts to get a referenced value. If the reference is weak, the value might\n+// no longer be available, in that case the call is still successful but the\n+// result is NULL.\n+napi_status napi_get_reference_value(napi_env env,\n+                                     napi_ref ref,\n+                                     napi_value* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, ref);\n+  CHECK_ARG(env, result);\n+\n+  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);\n+  *result = v8impl::JsValueFromV8LocalValue(reference->Get());\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_open_handle_scope(napi_env env, napi_handle_scope* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsHandleScopeFromV8HandleScope(\n+      new v8impl::HandleScopeWrapper(env->isolate));\n+  env->open_handle_scopes++;\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_close_handle_scope(napi_env env, napi_handle_scope scope) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, scope);\n+  if (env->open_handle_scopes == 0) {\n+    return napi_handle_scope_mismatch;\n+  }\n+\n+  env->open_handle_scopes--;\n+  delete v8impl::V8HandleScopeFromJsHandleScope(scope);\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_open_escapable_handle_scope(\n+    napi_env env,\n+    napi_escapable_handle_scope* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = v8impl::JsEscapableHandleScopeFromV8EscapableHandleScope(\n+      new v8impl::EscapableHandleScopeWrapper(env->isolate));\n+  env->open_handle_scopes++;\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_close_escapable_handle_scope(\n+    napi_env env,\n+    napi_escapable_handle_scope scope) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, scope);\n+  if (env->open_handle_scopes == 0) {\n+    return napi_handle_scope_mismatch;\n+  }\n+\n+  delete v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);\n+  env->open_handle_scopes--;\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_escape_handle(napi_env env,\n+                               napi_escapable_handle_scope scope,\n+                               napi_value escapee,\n+                               napi_value* result) {\n+  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n+  // JS exceptions.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, scope);\n+  CHECK_ARG(env, escapee);\n+  CHECK_ARG(env, result);\n+\n+  v8impl::EscapableHandleScopeWrapper* s =\n+      v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);\n+  if (!s->escape_called()) {\n+    *result = v8impl::JsValueFromV8LocalValue(\n+        s->Escape(v8impl::V8LocalValueFromJsValue(escapee)));\n+    return napi_clear_last_error(env);\n+  }\n+  return napi_set_last_error(env, napi_escape_called_twice);\n+}\n+\n+napi_status napi_new_instance(napi_env env,\n+                              napi_value constructor,\n+                              size_t argc,\n+                              const napi_value* argv,\n+                              napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, constructor);\n+  if (argc > 0) {\n+    CHECK_ARG(env, argv);\n+  }\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Context> context = env->context();\n+\n+  v8::Local<v8::Function> ctor;\n+  CHECK_TO_FUNCTION(env, ctor, constructor);\n+\n+  auto maybe = ctor->NewInstance(context, argc,\n+    reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));\n+\n+  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_instanceof(napi_env env,\n+                            napi_value object,\n+                            napi_value constructor,\n+                            bool* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, object);\n+  CHECK_ARG(env, result);\n+\n+  *result = false;\n+\n+  v8::Local<v8::Object> ctor;\n+  v8::Local<v8::Context> context = env->context();\n+\n+  CHECK_TO_OBJECT(env, context, ctor, constructor);\n+\n+  if (!ctor->IsFunction()) {\n+    napi_throw_type_error(env,\n+                          \"ERR_NAPI_CONS_FUNCTION\",\n+                          \"Constructor must be a function\");\n+\n+    return napi_set_last_error(env, napi_function_expected);\n+  }\n+\n+  napi_status status = napi_generic_failure;\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(object);\n+  auto maybe_result = val->InstanceOf(context, ctor);\n+  CHECK_MAYBE_NOTHING(env, maybe_result, status);\n+  *result = maybe_result.FromJust();\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+// Methods to support catching exceptions\n+napi_status napi_is_exception_pending(napi_env env, bool* result) {\n+  // NAPI_PREAMBLE is not used here: this function must execute when there is a\n+  // pending exception.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  *result = !env->last_exception.IsEmpty();\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_and_clear_last_exception(napi_env env,\n+                                              napi_value* result) {\n+  // NAPI_PREAMBLE is not used here: this function must execute when there is a\n+  // pending exception.\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+\n+  if (env->last_exception.IsEmpty()) {\n+    return napi_get_undefined(env, result);\n+  } else {\n+    *result = v8impl::JsValueFromV8LocalValue(\n+      v8::Local<v8::Value>::New(env->isolate, env->last_exception));\n+    env->last_exception.Reset();\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_is_arraybuffer(napi_env env, napi_value value, bool* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  *result = val->IsArrayBuffer();\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_arraybuffer(napi_env env,\n+                                    size_t byte_length,\n+                                    void** data,\n+                                    napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Isolate* isolate = env->isolate;\n+  v8::Local<v8::ArrayBuffer> buffer =\n+      v8::ArrayBuffer::New(isolate, byte_length);\n+\n+  // Optionally return a pointer to the buffer's data, to avoid another call to\n+  // retrieve it.\n+  if (data != nullptr) {\n+    *data = buffer->GetContents().Data();\n+  }\n+\n+  *result = v8impl::JsValueFromV8LocalValue(buffer);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_create_external_arraybuffer(napi_env env,\n+                                             void* external_data,\n+                                             size_t byte_length,\n+                                             napi_finalize finalize_cb,\n+                                             void* finalize_hint,\n+                                             napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, result);\n+\n+  v8::Isolate* isolate = env->isolate;\n+  v8::Local<v8::ArrayBuffer> buffer =\n+      v8::ArrayBuffer::New(isolate, external_data, byte_length);\n+\n+  if (finalize_cb != nullptr) {\n+    // Create a self-deleting weak reference that invokes the finalizer\n+    // callback.\n+    v8impl::Reference::New(env,\n+        buffer,\n+        0,\n+        true,\n+        finalize_cb,\n+        external_data,\n+        finalize_hint);\n+  }\n+\n+  *result = v8impl::JsValueFromV8LocalValue(buffer);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_get_arraybuffer_info(napi_env env,\n+                                      napi_value arraybuffer,\n+                                      void** data,\n+                                      size_t* byte_length) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, arraybuffer);\n+\n+  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);\n+  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);\n+\n+  v8::ArrayBuffer::Contents contents =\n+      value.As<v8::ArrayBuffer>()->GetContents();\n+\n+  if (data != nullptr) {\n+    *data = contents.Data();\n+  }\n+\n+  if (byte_length != nullptr) {\n+    *byte_length = contents.ByteLength();\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_is_typedarray(napi_env env, napi_value value, bool* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  *result = val->IsTypedArray();\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_typedarray(napi_env env,\n+                                   napi_typedarray_type type,\n+                                   size_t length,\n+                                   napi_value arraybuffer,\n+                                   size_t byte_offset,\n+                                   napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, arraybuffer);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);\n+  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);\n+\n+  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();\n+  v8::Local<v8::TypedArray> typedArray;\n+\n+  switch (type) {\n+    case napi_int8_array:\n+      CREATE_TYPED_ARRAY(\n+          env, Int8Array, 1, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_uint8_array:\n+      CREATE_TYPED_ARRAY(\n+          env, Uint8Array, 1, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_uint8_clamped_array:\n+      CREATE_TYPED_ARRAY(\n+          env, Uint8ClampedArray, 1, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_int16_array:\n+      CREATE_TYPED_ARRAY(\n+          env, Int16Array, 2, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_uint16_array:\n+      CREATE_TYPED_ARRAY(\n+          env, Uint16Array, 2, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_int32_array:\n+      CREATE_TYPED_ARRAY(\n+          env, Int32Array, 4, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_uint32_array:\n+      CREATE_TYPED_ARRAY(\n+          env, Uint32Array, 4, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_float32_array:\n+      CREATE_TYPED_ARRAY(\n+          env, Float32Array, 4, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_float64_array:\n+      CREATE_TYPED_ARRAY(\n+          env, Float64Array, 8, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_bigint64_array:\n+      CREATE_TYPED_ARRAY(\n+          env, BigInt64Array, 8, buffer, byte_offset, length, typedArray);\n+      break;\n+    case napi_biguint64_array:\n+      CREATE_TYPED_ARRAY(\n+          env, BigUint64Array, 8, buffer, byte_offset, length, typedArray);\n+      break;\n+    default:\n+      return napi_set_last_error(env, napi_invalid_arg);\n+  }\n+\n+  *result = v8impl::JsValueFromV8LocalValue(typedArray);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_get_typedarray_info(napi_env env,\n+                                     napi_value typedarray,\n+                                     napi_typedarray_type* type,\n+                                     size_t* length,\n+                                     void** data,\n+                                     napi_value* arraybuffer,\n+                                     size_t* byte_offset) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, typedarray);\n+\n+  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(typedarray);\n+  RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg);\n+\n+  v8::Local<v8::TypedArray> array = value.As<v8::TypedArray>();\n+\n+  if (type != nullptr) {\n+    if (value->IsInt8Array()) {\n+      *type = napi_int8_array;\n+    } else if (value->IsUint8Array()) {\n+      *type = napi_uint8_array;\n+    } else if (value->IsUint8ClampedArray()) {\n+      *type = napi_uint8_clamped_array;\n+    } else if (value->IsInt16Array()) {\n+      *type = napi_int16_array;\n+    } else if (value->IsUint16Array()) {\n+      *type = napi_uint16_array;\n+    } else if (value->IsInt32Array()) {\n+      *type = napi_int32_array;\n+    } else if (value->IsUint32Array()) {\n+      *type = napi_uint32_array;\n+    } else if (value->IsFloat32Array()) {\n+      *type = napi_float32_array;\n+    } else if (value->IsFloat64Array()) {\n+      *type = napi_float64_array;\n+    } else if (value->IsBigInt64Array()) {\n+      *type = napi_bigint64_array;\n+    } else if (value->IsBigUint64Array()) {\n+      *type = napi_biguint64_array;\n+    }\n+  }\n+\n+  if (length != nullptr) {\n+    *length = array->Length();\n+  }\n+\n+  v8::Local<v8::ArrayBuffer> buffer = array->Buffer();\n+  if (data != nullptr) {\n+    *data = static_cast<uint8_t*>(buffer->GetContents().Data()) +\n+            array->ByteOffset();\n+  }\n+\n+  if (arraybuffer != nullptr) {\n+    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);\n+  }\n+\n+  if (byte_offset != nullptr) {\n+    *byte_offset = array->ByteOffset();\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_dataview(napi_env env,\n+                                 size_t byte_length,\n+                                 napi_value arraybuffer,\n+                                 size_t byte_offset,\n+                                 napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, arraybuffer);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);\n+  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);\n+\n+  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();\n+  if (byte_length + byte_offset > buffer->ByteLength()) {\n+    napi_throw_range_error(\n+        env,\n+        \"ERR_NAPI_INVALID_DATAVIEW_ARGS\",\n+        \"byte_offset + byte_length should be less than or \"\n+        \"equal to the size in bytes of the array passed in\");\n+    return napi_set_last_error(env, napi_pending_exception);\n+  }\n+  v8::Local<v8::DataView> DataView = v8::DataView::New(buffer, byte_offset,\n+                                                       byte_length);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(DataView);\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_is_dataview(napi_env env, napi_value value, bool* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, value);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n+  *result = val->IsDataView();\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_dataview_info(napi_env env,\n+                                   napi_value dataview,\n+                                   size_t* byte_length,\n+                                   void** data,\n+                                   napi_value* arraybuffer,\n+                                   size_t* byte_offset) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, dataview);\n+\n+  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(dataview);\n+  RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg);\n+\n+  v8::Local<v8::DataView> array = value.As<v8::DataView>();\n+\n+  if (byte_length != nullptr) {\n+    *byte_length = array->ByteLength();\n+  }\n+\n+  v8::Local<v8::ArrayBuffer> buffer = array->Buffer();\n+  if (data != nullptr) {\n+    *data = static_cast<uint8_t*>(buffer->GetContents().Data()) +\n+            array->ByteOffset();\n+  }\n+\n+  if (arraybuffer != nullptr) {\n+    *arraybuffer = v8impl::JsValueFromV8LocalValue(buffer);\n+  }\n+\n+  if (byte_offset != nullptr) {\n+    *byte_offset = array->ByteOffset();\n+  }\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_get_version(napi_env env, uint32_t* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, result);\n+  *result = NAPI_VERSION;\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_create_promise(napi_env env,\n+                                napi_deferred* deferred,\n+                                napi_value* promise) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, deferred);\n+  CHECK_ARG(env, promise);\n+\n+  auto maybe = v8::Promise::Resolver::New(env->context());\n+  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);\n+\n+  auto v8_resolver = maybe.ToLocalChecked();\n+  auto v8_deferred = new v8impl::Persistent<v8::Value>();\n+  v8_deferred->Reset(env->isolate, v8_resolver);\n+\n+  *deferred = v8impl::JsDeferredFromNodePersistent(v8_deferred);\n+  *promise = v8impl::JsValueFromV8LocalValue(v8_resolver->GetPromise());\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_resolve_deferred(napi_env env,\n+                                  napi_deferred deferred,\n+                                  napi_value resolution) {\n+  return v8impl::ConcludeDeferred(env, deferred, resolution, true);\n+}\n+\n+napi_status napi_reject_deferred(napi_env env,\n+                                 napi_deferred deferred,\n+                                 napi_value resolution) {\n+  return v8impl::ConcludeDeferred(env, deferred, resolution, false);\n+}\n+\n+napi_status napi_is_promise(napi_env env,\n+                            napi_value promise,\n+                            bool* is_promise) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, promise);\n+  CHECK_ARG(env, is_promise);\n+\n+  *is_promise = v8impl::V8LocalValueFromJsValue(promise)->IsPromise();\n+\n+  return napi_clear_last_error(env);\n+}\n+\n+napi_status napi_run_script(napi_env env,\n+                            napi_value script,\n+                            napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, script);\n+  CHECK_ARG(env, result);\n+\n+  v8::Local<v8::Value> v8_script = v8impl::V8LocalValueFromJsValue(script);\n+\n+  if (!v8_script->IsString()) {\n+    return napi_set_last_error(env, napi_string_expected);\n+  }\n+\n+  v8::Local<v8::Context> context = env->context();\n+\n+  auto maybe_script = v8::Script::Compile(context,\n+      v8::Local<v8::String>::Cast(v8_script));\n+  CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure);\n+\n+  auto script_result =\n+      maybe_script.ToLocalChecked()->Run(context);\n+  CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure);\n+\n+  *result = v8impl::JsValueFromV8LocalValue(script_result.ToLocalChecked());\n+  return GET_RETURN_STATUS(env);\n+}\n+\n+napi_status napi_add_finalizer(napi_env env,\n+                               napi_value js_object,\n+                               void* native_object,\n+                               napi_finalize finalize_cb,\n+                               void* finalize_hint,\n+                               napi_ref* result) {\n+  return v8impl::Wrap<v8impl::anonymous>(env,\n+                                         js_object,\n+                                         native_object,\n+                                         finalize_cb,\n+                                         finalize_hint,\n+                                         result);\n+}\n+\n+napi_status napi_adjust_external_memory(napi_env env,\n+                                        int64_t change_in_bytes,\n+                                        int64_t* adjusted_value) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, adjusted_value);\n+\n+  *adjusted_value = env->isolate->AdjustAmountOfExternalAllocatedMemory(\n+      change_in_bytes);\n+\n+  return napi_clear_last_error(env);\n+}"
        },
        {
            "sha": "d5402845dc6af6026474418ec1ac1e8a31d82c4f",
            "filename": "src/js_native_api_v8.h",
            "status": "added",
            "additions": 202,
            "deletions": 0,
            "changes": 202,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api_v8.h",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api_v8.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_native_api_v8.h?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -0,0 +1,202 @@\n+#ifndef SRC_JS_NATIVE_API_V8_H_\n+#define SRC_JS_NATIVE_API_V8_H_\n+\n+#include <string.h>\n+#include \"js_native_api_types.h\"\n+#include \"js_native_api_v8_internals.h\"\n+\n+struct napi_env__ {\n+  explicit napi_env__(v8::Local<v8::Context> context)\n+      : isolate(context->GetIsolate()),\n+        context_persistent(isolate, context) {\n+    CHECK_EQ(isolate, context->GetIsolate());\n+  }\n+  v8::Isolate* const isolate;  // Shortcut for context()->GetIsolate()\n+  v8impl::Persistent<v8::Context> context_persistent;\n+\n+  inline v8::Local<v8::Context> context() const {\n+    return v8impl::PersistentToLocal::Strong(context_persistent);\n+  }\n+\n+  inline void Ref() { refs++; }\n+  inline void Unref() { if ( --refs == 0) delete this; }\n+\n+  v8impl::Persistent<v8::Value> last_exception;\n+  napi_extended_error_info last_error;\n+  int open_handle_scopes = 0;\n+  int open_callback_scopes = 0;\n+  int refs = 1;\n+};\n+\n+static inline napi_status napi_clear_last_error(napi_env env) {\n+  env->last_error.error_code = napi_ok;\n+\n+  // TODO(boingoing): Should this be a callback?\n+  env->last_error.engine_error_code = 0;\n+  env->last_error.engine_reserved = nullptr;\n+  return napi_ok;\n+}\n+\n+static inline\n+napi_status napi_set_last_error(napi_env env, napi_status error_code,\n+                                uint32_t engine_error_code = 0,\n+                                void* engine_reserved = nullptr) {\n+  env->last_error.error_code = error_code;\n+  env->last_error.engine_error_code = engine_error_code;\n+  env->last_error.engine_reserved = engine_reserved;\n+  return error_code;\n+}\n+\n+#define RETURN_STATUS_IF_FALSE(env, condition, status)                  \\\n+  do {                                                                  \\\n+    if (!(condition)) {                                                 \\\n+      return napi_set_last_error((env), (status));                      \\\n+    }                                                                   \\\n+  } while (0)\n+\n+#define CHECK_ENV(env)          \\\n+  do {                          \\\n+    if ((env) == nullptr) {     \\\n+      return napi_invalid_arg;  \\\n+    }                           \\\n+  } while (0)\n+\n+#define CHECK_ARG(env, arg) \\\n+  RETURN_STATUS_IF_FALSE((env), ((arg) != nullptr), napi_invalid_arg)\n+\n+#define CHECK_MAYBE_EMPTY(env, maybe, status) \\\n+  RETURN_STATUS_IF_FALSE((env), !((maybe).IsEmpty()), (status))\n+\n+// NAPI_PREAMBLE is not wrapped in do..while: try_catch must have function scope\n+#define NAPI_PREAMBLE(env)                                       \\\n+  CHECK_ENV((env));                                              \\\n+  RETURN_STATUS_IF_FALSE((env), (env)->last_exception.IsEmpty(), \\\n+                         napi_pending_exception);                \\\n+  napi_clear_last_error((env));                                  \\\n+  v8impl::TryCatch try_catch((env))\n+\n+#define CHECK_TO_TYPE(env, type, context, result, src, status)                \\\n+  do {                                                                        \\\n+    CHECK_ARG((env), (src));                                                  \\\n+    auto maybe = v8impl::V8LocalValueFromJsValue((src))->To##type((context)); \\\n+    CHECK_MAYBE_EMPTY((env), maybe, (status));                                \\\n+    (result) = maybe.ToLocalChecked();                                        \\\n+  } while (0)\n+\n+#define CHECK_TO_FUNCTION(env, result, src)                                 \\\n+  do {                                                                      \\\n+    CHECK_ARG((env), (src));                                                \\\n+    v8::Local<v8::Value> v8value = v8impl::V8LocalValueFromJsValue((src));  \\\n+    RETURN_STATUS_IF_FALSE((env), v8value->IsFunction(), napi_invalid_arg); \\\n+    (result) = v8value.As<v8::Function>();                                  \\\n+  } while (0)\n+\n+#define CHECK_TO_OBJECT(env, context, result, src) \\\n+  CHECK_TO_TYPE((env), Object, (context), (result), (src), napi_object_expected)\n+\n+#define CHECK_TO_STRING(env, context, result, src) \\\n+  CHECK_TO_TYPE((env), String, (context), (result), (src), napi_string_expected)\n+\n+#define GET_RETURN_STATUS(env)      \\\n+  (!try_catch.HasCaught() ? napi_ok \\\n+                         : napi_set_last_error((env), napi_pending_exception))\n+\n+#define THROW_RANGE_ERROR_IF_FALSE(env, condition, error, message) \\\n+  do {                                                             \\\n+    if (!(condition)) {                                            \\\n+      napi_throw_range_error((env), (error), (message));           \\\n+      return napi_set_last_error((env), napi_generic_failure);     \\\n+    }                                                              \\\n+  } while (0)\n+\n+#define NAPI_CALL_INTO_MODULE(env, call, handle_exception)                   \\\n+  do {                                                                       \\\n+    int open_handle_scopes = (env)->open_handle_scopes;                      \\\n+    int open_callback_scopes = (env)->open_callback_scopes;                  \\\n+    napi_clear_last_error((env));                                            \\\n+    call;                                                                    \\\n+    CHECK_EQ((env)->open_handle_scopes, open_handle_scopes);                 \\\n+    CHECK_EQ((env)->open_callback_scopes, open_callback_scopes);             \\\n+    if (!(env)->last_exception.IsEmpty()) {                                  \\\n+      handle_exception(                                                      \\\n+          v8::Local<v8::Value>::New((env)->isolate, (env)->last_exception)); \\\n+      (env)->last_exception.Reset();                                         \\\n+    }                                                                        \\\n+  } while (0)\n+\n+#define NAPI_CALL_INTO_MODULE_THROW(env, call) \\\n+  NAPI_CALL_INTO_MODULE((env), call, (env)->isolate->ThrowException)\n+\n+namespace v8impl {\n+\n+//=== Conversion between V8 Handles and napi_value ========================\n+\n+// This asserts v8::Local<> will always be implemented with a single\n+// pointer field so that we can pass it around as a void*.\n+static_assert(sizeof(v8::Local<v8::Value>) == sizeof(napi_value),\n+  \"Cannot convert between v8::Local<v8::Value> and napi_value\");\n+\n+inline napi_value JsValueFromV8LocalValue(v8::Local<v8::Value> local) {\n+  return reinterpret_cast<napi_value>(*local);\n+}\n+\n+inline v8::Local<v8::Value> V8LocalValueFromJsValue(napi_value v) {\n+  v8::Local<v8::Value> local;\n+  memcpy(&local, &v, sizeof(v));\n+  return local;\n+}\n+\n+// Adapter for napi_finalize callbacks.\n+class Finalizer {\n+ protected:\n+  Finalizer(napi_env env,\n+            napi_finalize finalize_callback,\n+            void* finalize_data,\n+            void* finalize_hint)\n+    : _env(env),\n+      _finalize_callback(finalize_callback),\n+      _finalize_data(finalize_data),\n+      _finalize_hint(finalize_hint) {\n+  }\n+\n+  ~Finalizer() {\n+  }\n+\n+ public:\n+  static Finalizer* New(napi_env env,\n+                        napi_finalize finalize_callback = nullptr,\n+                        void* finalize_data = nullptr,\n+                        void* finalize_hint = nullptr) {\n+    return new Finalizer(\n+      env, finalize_callback, finalize_data, finalize_hint);\n+  }\n+\n+  static void Delete(Finalizer* finalizer) {\n+    delete finalizer;\n+  }\n+\n+ protected:\n+  napi_env _env;\n+  napi_finalize _finalize_callback;\n+  void* _finalize_data;\n+  void* _finalize_hint;\n+};\n+\n+class TryCatch : public v8::TryCatch {\n+ public:\n+  explicit TryCatch(napi_env env)\n+      : v8::TryCatch(env->isolate), _env(env) {}\n+\n+  ~TryCatch() {\n+    if (HasCaught()) {\n+      _env->last_exception.Reset(_env->isolate, Exception());\n+    }\n+  }\n+\n+ private:\n+  napi_env _env;\n+};\n+\n+}  // end of namespace v8impl\n+\n+#endif  // SRC_JS_NATIVE_API_V8_H_"
        },
        {
            "sha": "91baae6a3b8201f6bc8222850e754fc6032b62e9",
            "filename": "src/js_native_api_v8_internals.h",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api_v8_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fjs_native_api_v8_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_native_api_v8_internals.h?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -0,0 +1,35 @@\n+#ifndef SRC_JS_NATIVE_API_V8_INTERNALS_H_\n+#define SRC_JS_NATIVE_API_V8_INTERNALS_H_\n+\n+// The V8 implementation of N-API, including `js_native_api_v8.h` uses certain\n+// idioms which require definition here. For example, it uses a variant of\n+// persistent references which need not be reset in the constructor. It is the\n+// responsibility of this file to define these idioms.\n+\n+// In the case of the Node.js implementation of N-API some of the idioms are\n+// imported directly from Node.js by including `node_internals.h` below. Others\n+// are bridged to remove references to the `node` namespace.\n+\n+#include \"node_version.h\"\n+#include \"env.h\"\n+#include \"node_internals.h\"\n+\n+#define NAPI_ARRAYSIZE(array) \\\n+  node::arraysize((array))\n+\n+#define NAPI_FIXED_ONE_BYTE_STRING(isolate, string) \\\n+  node::FIXED_ONE_BYTE_STRING((isolate), (string))\n+\n+#define NAPI_PRIVATE_KEY(context, suffix) \\\n+  (node::Environment::GetCurrent((context))->napi_ ## suffix())\n+\n+namespace v8impl {\n+\n+template <typename T>\n+using Persistent = node::Persistent<T>;\n+\n+using PersistentToLocal = node::PersistentToLocal;\n+\n+}  // end of namespace v8impl\n+\n+#endif  // SRC_JS_NATIVE_API_V8_INTERNALS_H_"
        },
        {
            "sha": "20428d40fadbdf7c73e409f0b57aa44151b0bd3d",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 90,
            "deletions": 3186,
            "changes": 3276,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b"
        },
        {
            "sha": "b36f6d4b7a4b9ed4f737249e38e877540be321ec",
            "filename": "src/node_api.h",
            "status": "modified",
            "additions": 25,
            "deletions": 496,
            "changes": 521,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fnode_api.h",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fnode_api.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.h?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -1,39 +1,17 @@\n #ifndef SRC_NODE_API_H_\n #define SRC_NODE_API_H_\n \n-#include <stddef.h>\n-#include <stdbool.h>\n+#ifdef BUILDING_NODE_EXTENSION\n+  #ifdef _WIN32\n+    // Building native module against node\n+    #define NAPI_EXTERN __declspec(dllimport)\n+  #endif\n+#endif\n+#include \"js_native_api.h\"\n #include \"node_api_types.h\"\n \n struct uv_loop_s;  // Forward declaration.\n \n-#ifndef NAPI_VERSION\n-#ifdef NAPI_EXPERIMENTAL\n-// Use INT_MAX, this should only be consumed by the pre-processor anyway.\n-#define NAPI_VERSION 2147483647\n-#else\n-// The baseline version for N-API\n-#define NAPI_VERSION 3\n-#endif\n-#endif\n-\n-#ifdef _WIN32\n-  #ifdef BUILDING_NODE_EXTENSION\n-    #ifdef EXTERNAL_NAPI\n-      // Building external N-API, or native module against external N-API\n-      #define NAPI_EXTERN /* nothing */\n-    #else\n-      // Building native module against node with built-in N-API\n-      #define NAPI_EXTERN __declspec(dllimport)\n-    #endif\n-  #else\n-    // Building node with built-in N-API\n-    #define NAPI_EXTERN __declspec(dllexport)\n-  #endif\n-#else\n-  #define NAPI_EXTERN /* nothing */\n-#endif\n-\n #ifdef _WIN32\n # define NAPI_MODULE_EXPORT __declspec(dllexport)\n #else\n@@ -46,7 +24,6 @@ struct uv_loop_s;  // Forward declaration.\n #define NAPI_NO_RETURN\n #endif\n \n-\n typedef napi_value (*napi_addon_register_func)(napi_env env,\n                                                napi_value exports);\n \n@@ -75,14 +52,6 @@ typedef struct {\n   static void fn(void)\n #endif\n \n-#ifdef __cplusplus\n-#define EXTERN_C_START extern \"C\" {\n-#define EXTERN_C_END }\n-#else\n-#define EXTERN_C_START\n-#define EXTERN_C_END\n-#endif\n-\n #define NAPI_MODULE_X(modname, regfunc, priv, flags)                  \\\n   EXTERN_C_START                                                      \\\n     static napi_module _module =                                      \\\n@@ -122,347 +91,31 @@ typedef struct {\n   napi_value NAPI_MODULE_INITIALIZER(napi_env env,                    \\\n                                      napi_value exports)\n \n-#define NAPI_AUTO_LENGTH SIZE_MAX\n-\n EXTERN_C_START\n \n NAPI_EXTERN void napi_module_register(napi_module* mod);\n \n-NAPI_EXTERN napi_status\n-napi_get_last_error_info(napi_env env,\n-                         const napi_extended_error_info** result);\n-\n NAPI_EXTERN NAPI_NO_RETURN void napi_fatal_error(const char* location,\n                                                  size_t location_len,\n                                                  const char* message,\n                                                  size_t message_len);\n \n-// Getters for defined singletons\n-NAPI_EXTERN napi_status napi_get_undefined(napi_env env, napi_value* result);\n-NAPI_EXTERN napi_status napi_get_null(napi_env env, napi_value* result);\n-NAPI_EXTERN napi_status napi_get_global(napi_env env, napi_value* result);\n-NAPI_EXTERN napi_status napi_get_boolean(napi_env env,\n-                                         bool value,\n-                                         napi_value* result);\n-\n-// Methods to create Primitive types/Objects\n-NAPI_EXTERN napi_status napi_create_object(napi_env env, napi_value* result);\n-NAPI_EXTERN napi_status napi_create_array(napi_env env, napi_value* result);\n-NAPI_EXTERN napi_status napi_create_array_with_length(napi_env env,\n-                                                      size_t length,\n-                                                      napi_value* result);\n-NAPI_EXTERN napi_status napi_create_double(napi_env env,\n-                                           double value,\n-                                           napi_value* result);\n-NAPI_EXTERN napi_status napi_create_int32(napi_env env,\n-                                          int32_t value,\n-                                          napi_value* result);\n-NAPI_EXTERN napi_status napi_create_uint32(napi_env env,\n-                                           uint32_t value,\n-                                           napi_value* result);\n-NAPI_EXTERN napi_status napi_create_int64(napi_env env,\n-                                          int64_t value,\n-                                          napi_value* result);\n-NAPI_EXTERN napi_status napi_create_string_latin1(napi_env env,\n-                                                  const char* str,\n-                                                  size_t length,\n-                                                  napi_value* result);\n-NAPI_EXTERN napi_status napi_create_string_utf8(napi_env env,\n-                                                const char* str,\n-                                                size_t length,\n-                                                napi_value* result);\n-NAPI_EXTERN napi_status napi_create_string_utf16(napi_env env,\n-                                                 const char16_t* str,\n-                                                 size_t length,\n-                                                 napi_value* result);\n-NAPI_EXTERN napi_status napi_create_symbol(napi_env env,\n-                                           napi_value description,\n-                                           napi_value* result);\n-NAPI_EXTERN napi_status napi_create_function(napi_env env,\n-                                             const char* utf8name,\n-                                             size_t length,\n-                                             napi_callback cb,\n-                                             void* data,\n-                                             napi_value* result);\n-NAPI_EXTERN napi_status napi_create_error(napi_env env,\n-                                          napi_value code,\n-                                          napi_value msg,\n-                                          napi_value* result);\n-NAPI_EXTERN napi_status napi_create_type_error(napi_env env,\n-                                               napi_value code,\n-                                               napi_value msg,\n-                                               napi_value* result);\n-NAPI_EXTERN napi_status napi_create_range_error(napi_env env,\n-                                                napi_value code,\n-                                                napi_value msg,\n-                                                napi_value* result);\n+// Methods for custom handling of async operations\n+NAPI_EXTERN napi_status napi_async_init(napi_env env,\n+                                        napi_value async_resource,\n+                                        napi_value async_resource_name,\n+                                        napi_async_context* result);\n \n-// Methods to get the native napi_value from Primitive type\n-NAPI_EXTERN napi_status napi_typeof(napi_env env,\n-                                    napi_value value,\n-                                    napi_valuetype* result);\n-NAPI_EXTERN napi_status napi_get_value_double(napi_env env,\n-                                              napi_value value,\n-                                              double* result);\n-NAPI_EXTERN napi_status napi_get_value_int32(napi_env env,\n-                                             napi_value value,\n-                                             int32_t* result);\n-NAPI_EXTERN napi_status napi_get_value_uint32(napi_env env,\n-                                              napi_value value,\n-                                              uint32_t* result);\n-NAPI_EXTERN napi_status napi_get_value_int64(napi_env env,\n-                                             napi_value value,\n-                                             int64_t* result);\n-NAPI_EXTERN napi_status napi_get_value_bool(napi_env env,\n-                                            napi_value value,\n-                                            bool* result);\n-\n-// Copies LATIN-1 encoded bytes from a string into a buffer.\n-NAPI_EXTERN napi_status napi_get_value_string_latin1(napi_env env,\n-                                                     napi_value value,\n-                                                     char* buf,\n-                                                     size_t bufsize,\n-                                                     size_t* result);\n-\n-// Copies UTF-8 encoded bytes from a string into a buffer.\n-NAPI_EXTERN napi_status napi_get_value_string_utf8(napi_env env,\n-                                                   napi_value value,\n-                                                   char* buf,\n-                                                   size_t bufsize,\n-                                                   size_t* result);\n-\n-// Copies UTF-16 encoded bytes from a string into a buffer.\n-NAPI_EXTERN napi_status napi_get_value_string_utf16(napi_env env,\n-                                                    napi_value value,\n-                                                    char16_t* buf,\n-                                                    size_t bufsize,\n-                                                    size_t* result);\n-\n-// Methods to coerce values\n-// These APIs may execute user scripts\n-NAPI_EXTERN napi_status napi_coerce_to_bool(napi_env env,\n-                                            napi_value value,\n-                                            napi_value* result);\n-NAPI_EXTERN napi_status napi_coerce_to_number(napi_env env,\n-                                              napi_value value,\n-                                              napi_value* result);\n-NAPI_EXTERN napi_status napi_coerce_to_object(napi_env env,\n-                                              napi_value value,\n-                                              napi_value* result);\n-NAPI_EXTERN napi_status napi_coerce_to_string(napi_env env,\n-                                              napi_value value,\n-                                              napi_value* result);\n-\n-// Methods to work with Objects\n-NAPI_EXTERN napi_status napi_get_prototype(napi_env env,\n-                                           napi_value object,\n-                                           napi_value* result);\n-NAPI_EXTERN napi_status napi_get_property_names(napi_env env,\n-                                                napi_value object,\n-                                                napi_value* result);\n-NAPI_EXTERN napi_status napi_set_property(napi_env env,\n-                                          napi_value object,\n-                                          napi_value key,\n-                                          napi_value value);\n-NAPI_EXTERN napi_status napi_has_property(napi_env env,\n-                                          napi_value object,\n-                                          napi_value key,\n-                                          bool* result);\n-NAPI_EXTERN napi_status napi_get_property(napi_env env,\n-                                          napi_value object,\n-                                          napi_value key,\n-                                          napi_value* result);\n-NAPI_EXTERN napi_status napi_delete_property(napi_env env,\n-                                             napi_value object,\n-                                             napi_value key,\n-                                             bool* result);\n-NAPI_EXTERN napi_status napi_has_own_property(napi_env env,\n-                                              napi_value object,\n-                                              napi_value key,\n-                                              bool* result);\n-NAPI_EXTERN napi_status napi_set_named_property(napi_env env,\n-                                          napi_value object,\n-                                          const char* utf8name,\n-                                          napi_value value);\n-NAPI_EXTERN napi_status napi_has_named_property(napi_env env,\n-                                          napi_value object,\n-                                          const char* utf8name,\n-                                          bool* result);\n-NAPI_EXTERN napi_status napi_get_named_property(napi_env env,\n-                                          napi_value object,\n-                                          const char* utf8name,\n-                                          napi_value* result);\n-NAPI_EXTERN napi_status napi_set_element(napi_env env,\n-                                         napi_value object,\n-                                         uint32_t index,\n-                                         napi_value value);\n-NAPI_EXTERN napi_status napi_has_element(napi_env env,\n-                                         napi_value object,\n-                                         uint32_t index,\n-                                         bool* result);\n-NAPI_EXTERN napi_status napi_get_element(napi_env env,\n-                                         napi_value object,\n-                                         uint32_t index,\n-                                         napi_value* result);\n-NAPI_EXTERN napi_status napi_delete_element(napi_env env,\n-                                            napi_value object,\n-                                            uint32_t index,\n-                                            bool* result);\n-NAPI_EXTERN napi_status\n-napi_define_properties(napi_env env,\n-                       napi_value object,\n-                       size_t property_count,\n-                       const napi_property_descriptor* properties);\n-\n-// Methods to work with Arrays\n-NAPI_EXTERN napi_status napi_is_array(napi_env env,\n-                                      napi_value value,\n-                                      bool* result);\n-NAPI_EXTERN napi_status napi_get_array_length(napi_env env,\n-                                              napi_value value,\n-                                              uint32_t* result);\n-\n-// Methods to compare values\n-NAPI_EXTERN napi_status napi_strict_equals(napi_env env,\n-                                           napi_value lhs,\n-                                           napi_value rhs,\n-                                           bool* result);\n-\n-// Methods to work with Functions\n-NAPI_EXTERN napi_status napi_call_function(napi_env env,\n+NAPI_EXTERN napi_status napi_async_destroy(napi_env env,\n+                                           napi_async_context async_context);\n+\n+NAPI_EXTERN napi_status napi_make_callback(napi_env env,\n+                                           napi_async_context async_context,\n                                            napi_value recv,\n                                            napi_value func,\n                                            size_t argc,\n                                            const napi_value* argv,\n                                            napi_value* result);\n-NAPI_EXTERN napi_status napi_new_instance(napi_env env,\n-                                          napi_value constructor,\n-                                          size_t argc,\n-                                          const napi_value* argv,\n-                                          napi_value* result);\n-NAPI_EXTERN napi_status napi_instanceof(napi_env env,\n-                                        napi_value object,\n-                                        napi_value constructor,\n-                                        bool* result);\n-\n-// Methods to work with napi_callbacks\n-\n-// Gets all callback info in a single call. (Ugly, but faster.)\n-NAPI_EXTERN napi_status napi_get_cb_info(\n-    napi_env env,               // [in] NAPI environment handle\n-    napi_callback_info cbinfo,  // [in] Opaque callback-info handle\n-    size_t* argc,      // [in-out] Specifies the size of the provided argv array\n-                       // and receives the actual count of args.\n-    napi_value* argv,  // [out] Array of values\n-    napi_value* this_arg,  // [out] Receives the JS 'this' arg for the call\n-    void** data);          // [out] Receives the data pointer for the callback.\n-\n-NAPI_EXTERN napi_status napi_get_new_target(napi_env env,\n-                                            napi_callback_info cbinfo,\n-                                            napi_value* result);\n-NAPI_EXTERN napi_status\n-napi_define_class(napi_env env,\n-                  const char* utf8name,\n-                  size_t length,\n-                  napi_callback constructor,\n-                  void* data,\n-                  size_t property_count,\n-                  const napi_property_descriptor* properties,\n-                  napi_value* result);\n-\n-// Methods to work with external data objects\n-NAPI_EXTERN napi_status napi_wrap(napi_env env,\n-                                  napi_value js_object,\n-                                  void* native_object,\n-                                  napi_finalize finalize_cb,\n-                                  void* finalize_hint,\n-                                  napi_ref* result);\n-NAPI_EXTERN napi_status napi_unwrap(napi_env env,\n-                                    napi_value js_object,\n-                                    void** result);\n-NAPI_EXTERN napi_status napi_remove_wrap(napi_env env,\n-                                         napi_value js_object,\n-                                         void** result);\n-NAPI_EXTERN napi_status napi_create_external(napi_env env,\n-                                             void* data,\n-                                             napi_finalize finalize_cb,\n-                                             void* finalize_hint,\n-                                             napi_value* result);\n-NAPI_EXTERN napi_status napi_get_value_external(napi_env env,\n-                                                napi_value value,\n-                                                void** result);\n-\n-// Methods to control object lifespan\n-\n-// Set initial_refcount to 0 for a weak reference, >0 for a strong reference.\n-NAPI_EXTERN napi_status napi_create_reference(napi_env env,\n-                                              napi_value value,\n-                                              uint32_t initial_refcount,\n-                                              napi_ref* result);\n-\n-// Deletes a reference. The referenced value is released, and may\n-// be GC'd unless there are other references to it.\n-NAPI_EXTERN napi_status napi_delete_reference(napi_env env, napi_ref ref);\n-\n-// Increments the reference count, optionally returning the resulting count.\n-// After this call the  reference will be a strong reference because its\n-// refcount is >0, and the referenced object is effectively \"pinned\".\n-// Calling this when the refcount is 0 and the object is unavailable\n-// results in an error.\n-NAPI_EXTERN napi_status napi_reference_ref(napi_env env,\n-                                           napi_ref ref,\n-                                           uint32_t* result);\n-\n-// Decrements the reference count, optionally returning the resulting count.\n-// If the result is 0 the reference is now weak and the object may be GC'd\n-// at any time if there are no other references. Calling this when the\n-// refcount is already 0 results in an error.\n-NAPI_EXTERN napi_status napi_reference_unref(napi_env env,\n-                                             napi_ref ref,\n-                                             uint32_t* result);\n-\n-// Attempts to get a referenced value. If the reference is weak,\n-// the value might no longer be available, in that case the call\n-// is still successful but the result is NULL.\n-NAPI_EXTERN napi_status napi_get_reference_value(napi_env env,\n-                                                 napi_ref ref,\n-                                                 napi_value* result);\n-\n-NAPI_EXTERN napi_status napi_open_handle_scope(napi_env env,\n-                                               napi_handle_scope* result);\n-NAPI_EXTERN napi_status napi_close_handle_scope(napi_env env,\n-                                                napi_handle_scope scope);\n-NAPI_EXTERN napi_status\n-napi_open_escapable_handle_scope(napi_env env,\n-                                 napi_escapable_handle_scope* result);\n-NAPI_EXTERN napi_status\n-napi_close_escapable_handle_scope(napi_env env,\n-                                  napi_escapable_handle_scope scope);\n-\n-NAPI_EXTERN napi_status napi_escape_handle(napi_env env,\n-                                           napi_escapable_handle_scope scope,\n-                                           napi_value escapee,\n-                                           napi_value* result);\n-\n-// Methods to support error handling\n-NAPI_EXTERN napi_status napi_throw(napi_env env, napi_value error);\n-NAPI_EXTERN napi_status napi_throw_error(napi_env env,\n-                                         const char* code,\n-                                         const char* msg);\n-NAPI_EXTERN napi_status napi_throw_type_error(napi_env env,\n-                                         const char* code,\n-                                         const char* msg);\n-NAPI_EXTERN napi_status napi_throw_range_error(napi_env env,\n-                                         const char* code,\n-                                         const char* msg);\n-NAPI_EXTERN napi_status napi_is_error(napi_env env,\n-                                      napi_value value,\n-                                      bool* result);\n-\n-// Methods to support catching exceptions\n-NAPI_EXTERN napi_status napi_is_exception_pending(napi_env env, bool* result);\n-NAPI_EXTERN napi_status napi_get_and_clear_last_exception(napi_env env,\n-                                                          napi_value* result);\n \n // Methods to provide node::Buffer functionality with napi types\n NAPI_EXTERN napi_status napi_create_buffer(napi_env env,\n@@ -488,57 +141,6 @@ NAPI_EXTERN napi_status napi_get_buffer_info(napi_env env,\n                                              void** data,\n                                              size_t* length);\n \n-// Methods to work with array buffers and typed arrays\n-NAPI_EXTERN napi_status napi_is_arraybuffer(napi_env env,\n-                                            napi_value value,\n-                                            bool* result);\n-NAPI_EXTERN napi_status napi_create_arraybuffer(napi_env env,\n-                                                size_t byte_length,\n-                                                void** data,\n-                                                napi_value* result);\n-NAPI_EXTERN napi_status\n-napi_create_external_arraybuffer(napi_env env,\n-                                 void* external_data,\n-                                 size_t byte_length,\n-                                 napi_finalize finalize_cb,\n-                                 void* finalize_hint,\n-                                 napi_value* result);\n-NAPI_EXTERN napi_status napi_get_arraybuffer_info(napi_env env,\n-                                                  napi_value arraybuffer,\n-                                                  void** data,\n-                                                  size_t* byte_length);\n-NAPI_EXTERN napi_status napi_is_typedarray(napi_env env,\n-                                           napi_value value,\n-                                           bool* result);\n-NAPI_EXTERN napi_status napi_create_typedarray(napi_env env,\n-                                               napi_typedarray_type type,\n-                                               size_t length,\n-                                               napi_value arraybuffer,\n-                                               size_t byte_offset,\n-                                               napi_value* result);\n-NAPI_EXTERN napi_status napi_get_typedarray_info(napi_env env,\n-                                                 napi_value typedarray,\n-                                                 napi_typedarray_type* type,\n-                                                 size_t* length,\n-                                                 void** data,\n-                                                 napi_value* arraybuffer,\n-                                                 size_t* byte_offset);\n-\n-NAPI_EXTERN napi_status napi_create_dataview(napi_env env,\n-                                             size_t length,\n-                                             napi_value arraybuffer,\n-                                             size_t byte_offset,\n-                                             napi_value* result);\n-NAPI_EXTERN napi_status napi_is_dataview(napi_env env,\n-                                         napi_value value,\n-                                         bool* result);\n-NAPI_EXTERN napi_status napi_get_dataview_info(napi_env env,\n-                                               napi_value dataview,\n-                                               size_t* bytelength,\n-                                               void** data,\n-                                               napi_value* arraybuffer,\n-                                               size_t* byte_offset);\n-\n // Methods to manage simple async operations\n NAPI_EXTERN\n napi_status napi_create_async_work(napi_env env,\n@@ -555,54 +157,11 @@ NAPI_EXTERN napi_status napi_queue_async_work(napi_env env,\n NAPI_EXTERN napi_status napi_cancel_async_work(napi_env env,\n                                                napi_async_work work);\n \n-// Methods for custom handling of async operations\n-NAPI_EXTERN napi_status napi_async_init(napi_env env,\n-                                        napi_value async_resource,\n-                                        napi_value async_resource_name,\n-                                        napi_async_context* result);\n-\n-NAPI_EXTERN napi_status napi_async_destroy(napi_env env,\n-                                           napi_async_context async_context);\n-\n-NAPI_EXTERN napi_status napi_make_callback(napi_env env,\n-                                           napi_async_context async_context,\n-                                           napi_value recv,\n-                                           napi_value func,\n-                                           size_t argc,\n-                                           const napi_value* argv,\n-                                           napi_value* result);\n-\n // version management\n-NAPI_EXTERN napi_status napi_get_version(napi_env env, uint32_t* result);\n-\n NAPI_EXTERN\n napi_status napi_get_node_version(napi_env env,\n                                   const napi_node_version** version);\n \n-// Promises\n-NAPI_EXTERN napi_status napi_create_promise(napi_env env,\n-                                            napi_deferred* deferred,\n-                                            napi_value* promise);\n-NAPI_EXTERN napi_status napi_resolve_deferred(napi_env env,\n-                                              napi_deferred deferred,\n-                                              napi_value resolution);\n-NAPI_EXTERN napi_status napi_reject_deferred(napi_env env,\n-                                             napi_deferred deferred,\n-                                             napi_value rejection);\n-NAPI_EXTERN napi_status napi_is_promise(napi_env env,\n-                                        napi_value promise,\n-                                        bool* is_promise);\n-\n-// Memory management\n-NAPI_EXTERN napi_status napi_adjust_external_memory(napi_env env,\n-                                                    int64_t change_in_bytes,\n-                                                    int64_t* adjusted_value);\n-\n-// Running a script\n-NAPI_EXTERN napi_status napi_run_script(napi_env env,\n-                                        napi_value script,\n-                                        napi_value* result);\n-\n #if NAPI_VERSION >= 2\n \n // Return the current libuv event loop for a given environment\n@@ -613,14 +172,6 @@ NAPI_EXTERN napi_status napi_get_uv_event_loop(napi_env env,\n \n #if NAPI_VERSION >= 3\n \n-NAPI_EXTERN napi_status napi_open_callback_scope(napi_env env,\n-                                                 napi_value resource_object,\n-                                                 napi_async_context context,\n-                                                 napi_callback_scope* result);\n-\n-NAPI_EXTERN napi_status napi_close_callback_scope(napi_env env,\n-                                                  napi_callback_scope scope);\n-\n NAPI_EXTERN napi_status napi_fatal_exception(napi_env env, napi_value err);\n \n NAPI_EXTERN napi_status napi_add_env_cleanup_hook(napi_env env,\n@@ -631,6 +182,14 @@ NAPI_EXTERN napi_status napi_remove_env_cleanup_hook(napi_env env,\n                                                      void (*fun)(void* arg),\n                                                      void* arg);\n \n+NAPI_EXTERN napi_status napi_open_callback_scope(napi_env env,\n+                                                 napi_value resource_object,\n+                                                 napi_async_context context,\n+                                                 napi_callback_scope* result);\n+\n+NAPI_EXTERN napi_status napi_close_callback_scope(napi_env env,\n+                                                  napi_callback_scope scope);\n+\n #endif  // NAPI_VERSION >= 3\n \n #ifdef NAPI_EXPERIMENTAL\n@@ -671,36 +230,6 @@ napi_unref_threadsafe_function(napi_env env, napi_threadsafe_function func);\n NAPI_EXTERN napi_status\n napi_ref_threadsafe_function(napi_env env, napi_threadsafe_function func);\n \n-NAPI_EXTERN napi_status napi_create_bigint_int64(napi_env env,\n-                                                 int64_t value,\n-                                                 napi_value* result);\n-NAPI_EXTERN napi_status napi_create_bigint_uint64(napi_env env,\n-                                                  uint64_t value,\n-                                                  napi_value* result);\n-NAPI_EXTERN napi_status napi_create_bigint_words(napi_env env,\n-                                                 int sign_bit,\n-                                                 size_t word_count,\n-                                                 const uint64_t* words,\n-                                                 napi_value* result);\n-NAPI_EXTERN napi_status napi_get_value_bigint_int64(napi_env env,\n-                                                    napi_value value,\n-                                                    int64_t* result,\n-                                                    bool* lossless);\n-NAPI_EXTERN napi_status napi_get_value_bigint_uint64(napi_env env,\n-                                                     napi_value value,\n-                                                     uint64_t* result,\n-                                                     bool* lossless);\n-NAPI_EXTERN napi_status napi_get_value_bigint_words(napi_env env,\n-                                                    napi_value value,\n-                                                    int* sign_bit,\n-                                                    size_t* word_count,\n-                                                    uint64_t* words);\n-NAPI_EXTERN napi_status napi_add_finalizer(napi_env env,\n-                                           napi_value js_object,\n-                                           void* native_object,\n-                                           napi_finalize finalize_cb,\n-                                           void* finalize_hint,\n-                                           napi_ref* result);\n #endif  // NAPI_EXPERIMENTAL\n \n EXTERN_C_END"
        },
        {
            "sha": "ab4f7ac58cb3dde48e7a387501459cd3ffb95914",
            "filename": "src/node_api_types.h",
            "status": "modified",
            "additions": 1,
            "deletions": 102,
            "changes": 103,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fnode_api_types.h",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/src%2Fnode_api_types.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api_types.h?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -1,89 +1,15 @@\n #ifndef SRC_NODE_API_TYPES_H_\n #define SRC_NODE_API_TYPES_H_\n \n-#include <stddef.h>\n-#include <stdint.h>\n+#include \"js_native_api_types.h\"\n \n-#if !defined __cplusplus || (defined(_MSC_VER) && _MSC_VER < 1900)\n-    typedef uint16_t char16_t;\n-#endif\n-\n-// JSVM API types are all opaque pointers for ABI stability\n-// typedef undefined structs instead of void* for compile time type safety\n-typedef struct napi_env__* napi_env;\n-typedef struct napi_value__* napi_value;\n-typedef struct napi_ref__* napi_ref;\n-typedef struct napi_handle_scope__* napi_handle_scope;\n-typedef struct napi_escapable_handle_scope__* napi_escapable_handle_scope;\n typedef struct napi_callback_scope__* napi_callback_scope;\n-typedef struct napi_callback_info__* napi_callback_info;\n typedef struct napi_async_context__* napi_async_context;\n typedef struct napi_async_work__* napi_async_work;\n-typedef struct napi_deferred__* napi_deferred;\n #ifdef NAPI_EXPERIMENTAL\n typedef struct napi_threadsafe_function__* napi_threadsafe_function;\n #endif  // NAPI_EXPERIMENTAL\n \n-typedef enum {\n-  napi_default = 0,\n-  napi_writable = 1 << 0,\n-  napi_enumerable = 1 << 1,\n-  napi_configurable = 1 << 2,\n-\n-  // Used with napi_define_class to distinguish static properties\n-  // from instance properties. Ignored by napi_define_properties.\n-  napi_static = 1 << 10,\n-} napi_property_attributes;\n-\n-typedef enum {\n-  // ES6 types (corresponds to typeof)\n-  napi_undefined,\n-  napi_null,\n-  napi_boolean,\n-  napi_number,\n-  napi_string,\n-  napi_symbol,\n-  napi_object,\n-  napi_function,\n-  napi_external,\n-  napi_bigint,\n-} napi_valuetype;\n-\n-typedef enum {\n-  napi_int8_array,\n-  napi_uint8_array,\n-  napi_uint8_clamped_array,\n-  napi_int16_array,\n-  napi_uint16_array,\n-  napi_int32_array,\n-  napi_uint32_array,\n-  napi_float32_array,\n-  napi_float64_array,\n-  napi_bigint64_array,\n-  napi_biguint64_array,\n-} napi_typedarray_type;\n-\n-typedef enum {\n-  napi_ok,\n-  napi_invalid_arg,\n-  napi_object_expected,\n-  napi_string_expected,\n-  napi_name_expected,\n-  napi_function_expected,\n-  napi_number_expected,\n-  napi_boolean_expected,\n-  napi_array_expected,\n-  napi_generic_failure,\n-  napi_pending_exception,\n-  napi_cancelled,\n-  napi_escape_called_twice,\n-  napi_handle_scope_mismatch,\n-  napi_callback_scope_mismatch,\n-  napi_queue_full,\n-  napi_closing,\n-  napi_bigint_expected,\n-} napi_status;\n-\n #ifdef NAPI_EXPERIMENTAL\n typedef enum {\n   napi_tsfn_release,\n@@ -96,45 +22,18 @@ typedef enum {\n } napi_threadsafe_function_call_mode;\n #endif  // NAPI_EXPERIMENTAL\n \n-typedef napi_value (*napi_callback)(napi_env env,\n-                                    napi_callback_info info);\n-typedef void (*napi_finalize)(napi_env env,\n-                              void* finalize_data,\n-                              void* finalize_hint);\n typedef void (*napi_async_execute_callback)(napi_env env,\n                                             void* data);\n typedef void (*napi_async_complete_callback)(napi_env env,\n                                              napi_status status,\n                                              void* data);\n-\n #ifdef NAPI_EXPERIMENTAL\n typedef void (*napi_threadsafe_function_call_js)(napi_env env,\n                                                  napi_value js_callback,\n                                                  void* context,\n                                                  void* data);\n #endif  // NAPI_EXPERIMENTAL\n \n-typedef struct {\n-  // One of utf8name or name should be NULL.\n-  const char* utf8name;\n-  napi_value name;\n-\n-  napi_callback method;\n-  napi_callback getter;\n-  napi_callback setter;\n-  napi_value value;\n-\n-  napi_property_attributes attributes;\n-  void* data;\n-} napi_property_descriptor;\n-\n-typedef struct {\n-  const char* error_message;\n-  void* engine_reserved;\n-  uint32_t engine_error_code;\n-  napi_status error_code;\n-} napi_extended_error_info;\n-\n typedef struct {\n   uint32_t major;\n   uint32_t minor;"
        },
        {
            "sha": "380ca6b27bb306c77be633c20dc03b0f16ce238f",
            "filename": "test/addons-napi/6_object_wrap/binding.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F6_object_wrap%2Fbinding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F6_object_wrap%2Fbinding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2F6_object_wrap%2Fbinding.cc?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -1,3 +1,4 @@\n+#include <node_api.h>\n #include \"myobject.h\"\n #include \"../common.h\"\n "
        },
        {
            "sha": "f67dddf406299f6854da2a5bd9532e242cf1961c",
            "filename": "test/addons-napi/6_object_wrap/myobject.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F6_object_wrap%2Fmyobject.h",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F6_object_wrap%2Fmyobject.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2F6_object_wrap%2Fmyobject.h?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -1,7 +1,7 @@\n #ifndef TEST_ADDONS_NAPI_6_OBJECT_WRAP_MYOBJECT_H_\n #define TEST_ADDONS_NAPI_6_OBJECT_WRAP_MYOBJECT_H_\n \n-#include <node_api.h>\n+#include <js_native_api.h>\n \n class MyObject {\n  public:"
        },
        {
            "sha": "a5df612393ccec7450bfe81633be7e533fd35d0d",
            "filename": "test/addons-napi/7_factory_wrap/binding.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F7_factory_wrap%2Fbinding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F7_factory_wrap%2Fbinding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2F7_factory_wrap%2Fbinding.cc?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -1,3 +1,4 @@\n+#include <node_api.h>\n #include \"myobject.h\"\n #include \"../common.h\"\n "
        },
        {
            "sha": "24883dfa3a0c29e4af47fa0c8f1e66e24f5f89ac",
            "filename": "test/addons-napi/7_factory_wrap/myobject.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F7_factory_wrap%2Fmyobject.h",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F7_factory_wrap%2Fmyobject.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2F7_factory_wrap%2Fmyobject.h?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -1,7 +1,7 @@\n #ifndef TEST_ADDONS_NAPI_7_FACTORY_WRAP_MYOBJECT_H_\n #define TEST_ADDONS_NAPI_7_FACTORY_WRAP_MYOBJECT_H_\n \n-#include <node_api.h>\n+#include <js_native_api.h>\n \n class MyObject {\n  public:"
        },
        {
            "sha": "f978fe151954aefdd664bea39ceb248638776ce9",
            "filename": "test/addons-napi/8_passing_wrapped/binding.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F8_passing_wrapped%2Fbinding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F8_passing_wrapped%2Fbinding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2F8_passing_wrapped%2Fbinding.cc?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -1,3 +1,4 @@\n+#include <node_api.h>\n #include \"myobject.h\"\n #include \"../common.h\"\n "
        },
        {
            "sha": "f1637b8dfee34e6d992d24cd747e829c097442a4",
            "filename": "test/addons-napi/8_passing_wrapped/myobject.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F8_passing_wrapped%2Fmyobject.h",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/test%2Faddons-napi%2F8_passing_wrapped%2Fmyobject.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2F8_passing_wrapped%2Fmyobject.h?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -1,7 +1,7 @@\n #ifndef TEST_ADDONS_NAPI_8_PASSING_WRAPPED_MYOBJECT_H_\n #define TEST_ADDONS_NAPI_8_PASSING_WRAPPED_MYOBJECT_H_\n \n-#include <node_api.h>\n+#include <js_native_api.h>\n \n class MyObject {\n  public:"
        },
        {
            "sha": "af8e9e27086d963b00190bfa701280b7f47dd6da",
            "filename": "tools/install.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/tools%2Finstall.py",
            "raw_url": "https://github.com/nodejs/node/raw/596bd5f1bb64cebc8d9b72c114f78ef9f074863b/tools%2Finstall.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Finstall.py?ref=596bd5f1bb64cebc8d9b72c114f78ef9f074863b",
            "patch": "@@ -169,6 +169,8 @@ def ignore_inspector_headers(files, dest):\n     'config.gypi',\n     'src/node.h',\n     'src/node_api.h',\n+    'src/js_native_api.h',\n+    'src/js_native_api_types.h',\n     'src/node_api_types.h',\n     'src/node_buffer.h',\n     'src/node_object_wrap.h',"
        }
    ],
    "stats": {
        "total": 7715,
        "additions": 3927,
        "deletions": 3788
    }
}