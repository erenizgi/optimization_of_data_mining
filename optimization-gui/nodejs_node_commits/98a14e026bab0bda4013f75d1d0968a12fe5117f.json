{
    "author": "codedot",
    "message": "tls: expose Finished messages in TLSSocket\n\nExposes SSL_get_finished and SSL_get_peer_finished routines in OpenSSL\nas tlsSocket.getFinished and tlsSocket.getPeerFinished, respectively.\n\nPR-URL: https://github.com/nodejs/node/pull/19102\nFixes: https://github.com/nodejs/node/issues/19055\nRefs: https://github.com/ripple/rippled/issues/2413\nReviewed-By: Fedor Indutny <fedor.indutny@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "98a14e026bab0bda4013f75d1d0968a12fe5117f",
    "files": [
        {
            "sha": "d3f3fdadff18afda5e484f714555e57df4f84c62",
            "filename": "doc/api/tls.md",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/98a14e026bab0bda4013f75d1d0968a12fe5117f/doc%2Fapi%2Ftls.md",
            "raw_url": "https://github.com/nodejs/node/raw/98a14e026bab0bda4013f75d1d0968a12fe5117f/doc%2Fapi%2Ftls.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ftls.md?ref=98a14e026bab0bda4013f75d1d0968a12fe5117f",
            "patch": "@@ -583,6 +583,23 @@ if called on a server socket. The supported types are `'DH'` and `'ECDH'`. The\n \n For Example: `{ type: 'ECDH', name: 'prime256v1', size: 256 }`\n \n+### tlsSocket.getFinished()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {Buffer|undefined} The latest `Finished` message that has been\n+sent to the socket as part of a SSL/TLS handshake, or `undefined` if\n+no `Finished` message has been sent yet.\n+\n+As the `Finished` messages are message digests of the complete handshake\n+(with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can\n+be used for external authentication procedures when the authentication\n+provided by SSL/TLS is not desired or is not enough.\n+\n+Corresponds to the `SSL_get_finished` routine in OpenSSL and may be used\n+to implement the `tls-unique` channel binding from [RFC 5929][].\n+\n ### tlsSocket.getPeerCertificate([detailed])\n <!-- YAML\n added: v0.11.4\n@@ -628,6 +645,23 @@ For example:\n \n If the peer does not provide a certificate, an empty object will be returned.\n \n+### tlsSocket.getPeerFinished()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {Buffer|undefined} The latest `Finished` message that is expected\n+or has actually been received from the socket as part of a SSL/TLS handshake,\n+or `undefined` if there is no `Finished` message so far.\n+\n+As the `Finished` messages are message digests of the complete handshake\n+(with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can\n+be used for external authentication procedures when the authentication\n+provided by SSL/TLS is not desired or is not enough.\n+\n+Corresponds to the `SSL_get_peer_finished` routine in OpenSSL and may be used\n+to implement the `tls-unique` channel binding from [RFC 5929][].\n+\n ### tlsSocket.getProtocol()\n <!-- YAML\n added: v5.7.0\n@@ -1368,3 +1402,4 @@ where `secure_socket` has the same API as `pair.cleartext`.\n [specific attacks affecting larger AES key sizes]: https://www.schneier.com/blog/archives/2009/07/another_new_aes.html\n [tls.Server]: #tls_class_tls_server\n [`dns.lookup()`]: dns.html#dns_dns_lookup_hostname_options_callback\n+[RFC 5929]: https://tools.ietf.org/html/rfc5929"
        },
        {
            "sha": "8ac497902eb596b78ed81f8f8c6b07b341a5e3c3",
            "filename": "lib/_tls_wrap.js",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/98a14e026bab0bda4013f75d1d0968a12fe5117f/lib%2F_tls_wrap.js",
            "raw_url": "https://github.com/nodejs/node/raw/98a14e026bab0bda4013f75d1d0968a12fe5117f/lib%2F_tls_wrap.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_tls_wrap.js?ref=98a14e026bab0bda4013f75d1d0968a12fe5117f",
            "patch": "@@ -692,6 +692,16 @@ TLSSocket.prototype.getPeerCertificate = function(detailed) {\n   return null;\n };\n \n+TLSSocket.prototype.getFinished = function() {\n+  if (this._handle)\n+    return this._handle.getFinished();\n+};\n+\n+TLSSocket.prototype.getPeerFinished = function() {\n+  if (this._handle)\n+    return this._handle.getPeerFinished();\n+};\n+\n TLSSocket.prototype.getSession = function() {\n   if (this._handle) {\n     return this._handle.getSession();"
        },
        {
            "sha": "92e98e2eb2ed11b3f4ec55001568de7068462050",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/98a14e026bab0bda4013f75d1d0968a12fe5117f/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/98a14e026bab0bda4013f75d1d0968a12fe5117f/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=98a14e026bab0bda4013f75d1d0968a12fe5117f",
            "patch": "@@ -1606,6 +1606,8 @@ void SSLWrap<Base>::AddMethods(Environment* env, Local<FunctionTemplate> t) {\n   HandleScope scope(env->isolate());\n \n   env->SetProtoMethod(t, \"getPeerCertificate\", GetPeerCertificate);\n+  env->SetProtoMethod(t, \"getFinished\", GetFinished);\n+  env->SetProtoMethod(t, \"getPeerFinished\", GetPeerFinished);\n   env->SetProtoMethod(t, \"getSession\", GetSession);\n   env->SetProtoMethod(t, \"setSession\", SetSession);\n   env->SetProtoMethod(t, \"loadSession\", LoadSession);\n@@ -2120,6 +2122,52 @@ void SSLWrap<Base>::GetPeerCertificate(\n }\n \n \n+template <class Base>\n+void SSLWrap<Base>::GetFinished(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  Base* w;\n+  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n+\n+  // We cannot just pass nullptr to SSL_get_finished()\n+  // because it would further be propagated to memcpy(),\n+  // where the standard requirements as described in ISO/IEC 9899:2011\n+  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.\n+  // Thus, we use a dummy byte.\n+  char dummy[1];\n+  size_t len = SSL_get_finished(w->ssl_, dummy, sizeof dummy);\n+  if (len == 0)\n+    return;\n+\n+  char* buf = Malloc(len);\n+  CHECK_EQ(len, SSL_get_finished(w->ssl_, buf, len));\n+  args.GetReturnValue().Set(Buffer::New(env, buf, len).ToLocalChecked());\n+}\n+\n+\n+template <class Base>\n+void SSLWrap<Base>::GetPeerFinished(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  Base* w;\n+  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n+\n+  // We cannot just pass nullptr to SSL_get_peer_finished()\n+  // because it would further be propagated to memcpy(),\n+  // where the standard requirements as described in ISO/IEC 9899:2011\n+  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.\n+  // Thus, we use a dummy byte.\n+  char dummy[1];\n+  size_t len = SSL_get_peer_finished(w->ssl_, dummy, sizeof dummy);\n+  if (len == 0)\n+    return;\n+\n+  char* buf = Malloc(len);\n+  CHECK_EQ(len, SSL_get_peer_finished(w->ssl_, buf, len));\n+  args.GetReturnValue().Set(Buffer::New(env, buf, len).ToLocalChecked());\n+}\n+\n+\n template <class Base>\n void SSLWrap<Base>::GetSession(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);"
        },
        {
            "sha": "668781aca9da1e68ffd43069565c5d94412cab27",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/98a14e026bab0bda4013f75d1d0968a12fe5117f/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/98a14e026bab0bda4013f75d1d0968a12fe5117f/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=98a14e026bab0bda4013f75d1d0968a12fe5117f",
            "patch": "@@ -269,6 +269,8 @@ class SSLWrap {\n \n   static void GetPeerCertificate(\n       const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void GetFinished(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void GetPeerFinished(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void GetSession(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void SetSession(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void LoadSession(const v8::FunctionCallbackInfo<v8::Value>& args);"
        },
        {
            "sha": "8b52934b049d95cad06a878d77ee96f4c6331496",
            "filename": "test/parallel/test-tls-finished.js",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/nodejs/node/blob/98a14e026bab0bda4013f75d1d0968a12fe5117f/test%2Fparallel%2Ftest-tls-finished.js",
            "raw_url": "https://github.com/nodejs/node/raw/98a14e026bab0bda4013f75d1d0968a12fe5117f/test%2Fparallel%2Ftest-tls-finished.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-finished.js?ref=98a14e026bab0bda4013f75d1d0968a12fe5117f",
            "patch": "@@ -0,0 +1,66 @@\n+'use strict';\n+\n+const common = require('../common');\n+const fixtures = require('../common/fixtures');\n+\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+\n+// This test ensures that tlsSocket.getFinished() and\n+// tlsSocket.getPeerFinished() return undefined before\n+// secure connection is established, and return non-empty\n+// Buffer objects with Finished messages afterwards, also\n+// verifying alice.getFinished() == bob.getPeerFinished()\n+// and alice.getPeerFinished() == bob.getFinished().\n+\n+const assert = require('assert');\n+const tls = require('tls');\n+\n+const msg = {};\n+const pem = (n) => fixtures.readKey(`${n}.pem`);\n+const server = tls.createServer({\n+  key: pem('agent1-key'),\n+  cert: pem('agent1-cert')\n+}, common.mustCall((alice) => {\n+  msg.server = {\n+    alice: alice.getFinished(),\n+    bob: alice.getPeerFinished()\n+  };\n+  server.close();\n+}));\n+\n+server.listen(0, common.mustCall(() => {\n+  const bob = tls.connect({\n+    port: server.address().port,\n+    rejectUnauthorized: false\n+  }, common.mustCall(() => {\n+    msg.client = {\n+      alice: bob.getPeerFinished(),\n+      bob: bob.getFinished()\n+    };\n+    bob.end();\n+  }));\n+\n+  msg.before = {\n+    alice: bob.getPeerFinished(),\n+    bob: bob.getFinished()\n+  };\n+}));\n+\n+process.on('exit', () => {\n+  assert.strictEqual(undefined, msg.before.alice);\n+  assert.strictEqual(undefined, msg.before.bob);\n+\n+  assert(Buffer.isBuffer(msg.server.alice));\n+  assert(Buffer.isBuffer(msg.server.bob));\n+  assert(Buffer.isBuffer(msg.client.alice));\n+  assert(Buffer.isBuffer(msg.client.bob));\n+\n+  assert(msg.server.alice.length > 0);\n+  assert(msg.server.bob.length > 0);\n+  assert(msg.client.alice.length > 0);\n+  assert(msg.client.bob.length > 0);\n+\n+  assert(msg.server.alice.equals(msg.client.alice));\n+  assert(msg.server.bob.equals(msg.client.bob));\n+});"
        }
    ],
    "stats": {
        "total": 161,
        "additions": 161,
        "deletions": 0
    }
}