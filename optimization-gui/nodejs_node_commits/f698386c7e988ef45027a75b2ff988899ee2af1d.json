{
    "author": "cjihrig",
    "message": "deps: upgrade to libuv 1.25.0\n\nPR-URL: https://github.com/nodejs/node/pull/25571\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Santiago Gimeno <santiago.gimeno@gmail.com>",
    "sha": "f698386c7e988ef45027a75b2ff988899ee2af1d",
    "files": [
        {
            "sha": "8a559787b49a75562412af803f51cfb1c2235188",
            "filename": "deps/uv/.mailmap",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2F.mailmap",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2F.mailmap",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2F.mailmap?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -45,3 +45,4 @@ Yazhong Liu <yorkiefixer@gmail.com>\n Yuki Okumura <mjt@cltn.org>\n jBarz <jBarz@users.noreply.github.com> <jbarboza@ca.ibm.com>\n jBarz <jBarz@users.noreply.github.com> <jbarz@users.noreply.github.com>\n+ptlomholt <pt@lomholt.com>"
        },
        {
            "sha": "3317efeb1ac8afca8e9e0ce241993b5c35cf5df2",
            "filename": "deps/uv/AUTHORS",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FAUTHORS?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -362,3 +362,7 @@ Ashe Connor <ashe@kivikakk.ee>\n Rick <lcw0622@163.com>\n Ivan Krylov <krylov.r00t@gmail.com>\n Michael Meier <michael.meier@leica-geosystems.com>\n+ptlomholt <pt@lomholt.com>\n+Victor Costan <pwnall@chromium.org>\n+sid <sidyhe@hotmail.com>\n+Kevin Adler <kadler@us.ibm.com>"
        },
        {
            "sha": "fa268a13ed666191b03575ad938e5c4224ad7e49",
            "filename": "deps/uv/CMakeLists.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2FCMakeLists.txt",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2FCMakeLists.txt",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FCMakeLists.txt?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -167,6 +167,7 @@ set(uv_test_sources\n     test/test-udp-send-immediate.c\n     test/test-udp-send-unreachable.c\n     test/test-udp-try-send.c\n+    test/test-uname.c\n     test/test-walk-handles.c\n     test/test-watcher-cross-stop.c)\n \n@@ -211,7 +212,7 @@ if(WIN32)\n else()\n   list(APPEND uv_defines _FILE_OFFSET_BITS=64 _LARGEFILE_SOURCE)\n   if(NOT CMAKE_SYSTEM_NAME STREQUAL \"Android\")\n-    # Android has pthread as part of its c library, not as a separate \n+    # Android has pthread as part of its c library, not as a separate\n     # libpthread.so.\n     list(APPEND uv_libraries pthread)\n   endif()"
        },
        {
            "sha": "3652829ce7790b1a215360e3243a9118579896f4",
            "filename": "deps/uv/ChangeLog",
            "status": "modified",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2FChangeLog",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2FChangeLog",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FChangeLog?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -1,3 +1,54 @@\n+2019.01.19, Version 1.25.0 (Stable), 4a10a9d425863330af199e4b74bd688e62d945f1\n+\n+Changes since version 1.24.1:\n+\n+* Revert \"win,fs: retry if uv_fs_rename fails\" (Ben Noordhuis)\n+\n+* aix: manually trigger fs event monitoring (Gireesh Punathil)\n+\n+* unix: rename WRITE_RETRY_ON_ERROR macro (Ben Noordhuis)\n+\n+* darwin: DRY platform-specific error check (Ben Noordhuis)\n+\n+* unix: refactor uv__write() (Ben Noordhuis)\n+\n+* unix: don't send handle twice on partial write (Ben Noordhuis)\n+\n+* tty,win: fix Alt+key under WSL (Bartosz Sosnowski)\n+\n+* build: support running tests in out-of-tree builds (Jameson Nash)\n+\n+* fsevents: really watch files with fsevents on macos 10.7+ (Jameson Nash)\n+\n+* thread,mingw64: need intrin.h header for SSE2 MemoryBarrier (Jameson Nash)\n+\n+* win: fix sizeof-pointer-div warning (cjihrig)\n+\n+* unix,win: add uv_os_uname() (cjihrig)\n+\n+* win, tty: fix CreateFileW() return value check (Bartosz Sosnowski)\n+\n+* unix: enable IPv6 tests on OpenBSD (ptlomholt)\n+\n+* test: fix test-ipc spawn_helper exit_cb (Santiago Gimeno)\n+\n+* test: fix test-ipc tests (Santiago Gimeno)\n+\n+* unix: better handling of unsupported F_FULLFSYNC (Victor Costan)\n+\n+* win,test: de-flake fs_event_watch_dir_short_path (Refael Ackermann)\n+\n+* win: fix msvc warning (sid)\n+\n+* openbsd: switch to libuv's barrier implementation (ptlomholt)\n+\n+* unix,stream: fix zero byte writes (Santiago Gimeno)\n+\n+* ibmi: return EISDIR on read from directory fd (Kevin Adler)\n+\n+* build: wrap long lines in Makefile.am (cjihrig)\n+\n+\n 2018.12.17, Version 1.24.1 (Stable), 274f2bd3b70847cadd9a3965577a87e666ab9ac3\n \n Changes since version 1.24.0:"
        },
        {
            "sha": "d8a01574f3cf2c5ae5b05d8892bbba7c7e030dce",
            "filename": "deps/uv/Makefile.am",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2FMakefile.am",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2FMakefile.am",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FMakefile.am?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -20,7 +20,9 @@ AM_CPPFLAGS = -I$(top_srcdir)/include \\\n include_HEADERS=include/uv.h\n \n uvincludedir = $(includedir)/uv\n-uvinclude_HEADERS=include/uv/errno.h include/uv/threadpool.h include/uv/version.h\n+uvinclude_HEADERS = include/uv/errno.h \\\n+                    include/uv/threadpool.h \\\n+                    include/uv/version.h\n \n CLEANFILES =\n \n@@ -293,6 +295,7 @@ test_run_tests_SOURCES = test/blackhole-server.c \\\n                          test/test-udp-send-immediate.c \\\n                          test/test-udp-send-unreachable.c \\\n                          test/test-udp-try-send.c \\\n+                         test/test-uname.c \\\n                          test/test-walk-handles.c \\\n                          test/test-watcher-cross-stop.c\n test_run_tests_LDADD = libuv.la\n@@ -306,7 +309,9 @@ test_run_tests_SOURCES += test/runner-unix.c \\\n endif\n \n if AIX\n-test_run_tests_CFLAGS += -D_ALL_SOURCE -D_XOPEN_SOURCE=500 -D_LINUX_SOURCE_COMPAT\n+test_run_tests_CFLAGS += -D_ALL_SOURCE \\\n+                         -D_XOPEN_SOURCE=500 \\\n+                         -D_LINUX_SOURCE_COMPAT\n endif\n \n if LINUX"
        },
        {
            "sha": "ab656c83d23502731f70863cc0a46e8594a87bd2",
            "filename": "deps/uv/configure.ac",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fconfigure.ac",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fconfigure.ac",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fconfigure.ac?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -13,7 +13,7 @@\n # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n \n AC_PREREQ(2.57)\n-AC_INIT([libuv], [1.24.1], [https://github.com/libuv/libuv/issues])\n+AC_INIT([libuv], [1.25.0], [https://github.com/libuv/libuv/issues])\n AC_CONFIG_MACRO_DIR([m4])\n m4_include([m4/libuv-extra-automake-flags.m4])\n m4_include([m4/as_case.m4])\n@@ -73,4 +73,6 @@ AS_CASE([$host_os], [kfreebsd*], [\n ])\n AC_CHECK_HEADERS([sys/ahafs_evProds.h])\n AC_CONFIG_FILES([Makefile libuv.pc])\n+AC_CONFIG_LINKS([test/fixtures/empty_file:test/fixtures/empty_file])\n+AC_CONFIG_LINKS([test/fixtures/load_error.node:test/fixtures/load_error.node])\n AC_OUTPUT"
        },
        {
            "sha": "af97ec3a6488825befca0c46aef62dc62c8b0396",
            "filename": "deps/uv/docs/src/fs.rst",
            "status": "modified",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -233,15 +233,6 @@ API\n \n     Equivalent to :man:`rename(2)`.\n \n-    .. note::\n-        On Windows if this function fails with ``UV_EBUSY``, ``UV_EPERM`` or\n-        ``UV_EACCES``, it will retry to rename the file up to four times with\n-        250ms wait between attempts before giving up. If both `path` and\n-        `new_path` are existing directories this function will work only if\n-        target directory is empty.\n-\n-    .. versionchanged:: 1.24.0 Added retrying and directory move support on Windows.\n-\n .. c:function:: int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb)\n \n     Equivalent to :man:`fsync(2)`."
        },
        {
            "sha": "81c03a853031804bf804098acb6400b873748290",
            "filename": "deps/uv/docs/src/misc.rst",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fdocs%2Fsrc%2Fmisc.rst",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fdocs%2Fsrc%2Fmisc.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Fmisc.rst?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -145,6 +145,19 @@ Data types\n             char* homedir;\n         } uv_passwd_t;\n \n+.. c:type:: uv_utsname_t\n+\n+    Data type for operating system name and version information.\n+\n+    ::\n+\n+        typedef struct uv_utsname_s {\n+            char sysname[256];\n+            char release[256];\n+            char version[256];\n+            char machine[256];\n+        } uv_utsname_t;\n+\n \n API\n ---\n@@ -549,3 +562,12 @@ API\n         for others it will be silently reduced to `PRIORITY_HIGH`.\n \n     .. versionadded:: 1.23.0\n+\n+.. c:function:: int uv_os_uname(uv_utsname_t* buffer)\n+\n+    Retrieves system information in `buffer`. The populated data includes the\n+    operating system name, release, version, and machine. On non-Windows\n+    systems, `uv_os_uname()` is a thin wrapper around :man:`uname(3)`. Returns\n+    zero on success, and a non-zero error value otherwise.\n+\n+    .. versionadded:: 1.25.0"
        },
        {
            "sha": "a46b229dfd166e8128b92776be9681148771e5f2",
            "filename": "deps/uv/include/uv.h",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Finclude%2Fuv.h",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Finclude%2Fuv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv.h?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -234,6 +234,7 @@ typedef struct uv_cpu_info_s uv_cpu_info_t;\n typedef struct uv_interface_address_s uv_interface_address_t;\n typedef struct uv_dirent_s uv_dirent_t;\n typedef struct uv_passwd_s uv_passwd_t;\n+typedef struct uv_utsname_s uv_utsname_t;\n \n typedef enum {\n   UV_LOOP_BLOCK_SIGNAL\n@@ -968,13 +969,13 @@ enum uv_process_flags {\n    */\n   UV_PROCESS_WINDOWS_HIDE = (1 << 4),\n   /*\n-   * Hide the subprocess console window that would normally be created. This \n+   * Hide the subprocess console window that would normally be created. This\n    * option is only meaningful on Windows systems. On Unix it is silently\n    * ignored.\n    */\n   UV_PROCESS_WINDOWS_HIDE_CONSOLE = (1 << 5),\n   /*\n-   * Hide the subprocess GUI window that would normally be created. This \n+   * Hide the subprocess GUI window that would normally be created. This\n    * option is only meaningful on Windows systems. On Unix it is silently\n    * ignored.\n    */\n@@ -1054,6 +1055,16 @@ struct uv_passwd_s {\n   char* homedir;\n };\n \n+struct uv_utsname_s {\n+  char sysname[256];\n+  char release[256];\n+  char version[256];\n+  char machine[256];\n+  /* This struct does not contain the nodename and domainname fields present in\n+     the utsname type. domainname is a GNU extension. Both fields are referred\n+     to as meaningless in the docs. */\n+};\n+\n typedef enum {\n   UV_DIRENT_UNKNOWN,\n   UV_DIRENT_FILE,\n@@ -1135,6 +1146,8 @@ UV_EXTERN int uv_os_unsetenv(const char* name);\n \n UV_EXTERN int uv_os_gethostname(char* buffer, size_t* size);\n \n+UV_EXTERN int uv_os_uname(uv_utsname_t* buffer);\n+\n \n typedef enum {\n   UV_FS_UNKNOWN = -1,"
        },
        {
            "sha": "d887d7211f1d1e9abbf7b517c9bc52296b728ed0",
            "filename": "deps/uv/include/uv/unix.h",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Finclude%2Fuv%2Funix.h",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Finclude%2Fuv%2Funix.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Funix.h?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -136,7 +136,9 @@ typedef pthread_cond_t uv_cond_t;\n typedef pthread_key_t uv_key_t;\n \n /* Note: guard clauses should match uv_barrier_init's in src/unix/thread.c. */\n-#if defined(_AIX) || !defined(PTHREAD_BARRIER_SERIAL_THREAD)\n+#if defined(_AIX) || \\\n+    defined(__OpenBSD__) || \\\n+    !defined(PTHREAD_BARRIER_SERIAL_THREAD)\n /* TODO(bnoordhuis) Merge into uv_barrier_t in v2. */\n struct _uv_barrier {\n   uv_mutex_t mutex;"
        },
        {
            "sha": "136772128ab35ac4fa7df5c1abd0abc4432a2707",
            "filename": "deps/uv/include/uv/version.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fversion.h?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -31,8 +31,8 @@\n  */\n \n #define UV_VERSION_MAJOR 1\n-#define UV_VERSION_MINOR 24\n-#define UV_VERSION_PATCH 1\n+#define UV_VERSION_MINOR 25\n+#define UV_VERSION_PATCH 0\n #define UV_VERSION_IS_RELEASE 1\n #define UV_VERSION_SUFFIX \"\"\n "
        },
        {
            "sha": "337e58e0adc02f2f74054fc9f98b34c84920d0e0",
            "filename": "deps/uv/src/unix/aix.c",
            "status": "modified",
            "additions": 17,
            "deletions": 2,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Faix.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Faix.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Faix.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -555,7 +555,7 @@ static int uv__setup_ahafs(const char* filename, int *fd) {\n     sprintf(mon_file_write_string, \"CHANGED=YES;WAIT_TYPE=WAIT_IN_SELECT;INFO_LVL=1\");\n \n   rc = write(*fd, mon_file_write_string, strlen(mon_file_write_string)+1);\n-  if (rc < 0)\n+  if (rc < 0 && errno != EBUSY)\n     return UV__ERR(errno);\n \n   return 0;\n@@ -728,10 +728,16 @@ int uv_fs_event_start(uv_fs_event_t* handle,\n   char cwd[PATH_MAX];\n   char absolute_path[PATH_MAX];\n   char readlink_cwd[PATH_MAX];\n+  struct timeval zt;\n+  fd_set pollfd;\n \n \n   /* Figure out whether filename is absolute or not */\n-  if (filename[0] == '/') {\n+  if (filename[0] == '\\0') {\n+    /* Missing a pathname */\n+    return UV_ENOENT;\n+  }\n+  else if (filename[0] == '/') {\n     /* We have absolute pathname */\n     /* TODO(bnoordhuis) Check uv__strscpy() return value. */\n     uv__strscpy(absolute_path, filename, sizeof(absolute_path));\n@@ -768,6 +774,15 @@ int uv_fs_event_start(uv_fs_event_t* handle,\n \n   uv__io_start(handle->loop, &handle->event_watcher, POLLIN);\n \n+  /* AHAFS wants someone to poll for it to start mointoring.\n+   *  so kick-start it so that we don't miss an event in the\n+   *  eventuality of an event that occurs in the current loop. */\n+  do {\n+    memset(&zt, 0, sizeof(zt));\n+    FD_ZERO(&pollfd);\n+    FD_SET(fd, &pollfd);\n+    rc = select(fd + 1, &pollfd, NULL, NULL, &zt);\n+  } while (rc == -1 && errno == EINTR);\n   return 0;\n #else\n   return UV_ENOSYS;"
        },
        {
            "sha": "3c2253f0c9c952dd3736b4e5eeb260d3b812add9",
            "filename": "deps/uv/src/unix/bsd-ifaddrs.c",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fbsd-ifaddrs.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fbsd-ifaddrs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fbsd-ifaddrs.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -52,13 +52,10 @@ static int uv__ifaddr_exclude(struct ifaddrs *ent, int exclude_type) {\n    */\n   if (ent->ifa_addr->sa_family == AF_LINK)\n     return 1;\n-#elif defined(__NetBSD__)\n+#elif defined(__NetBSD__) || defined(__OpenBSD__)\n   if (ent->ifa_addr->sa_family != PF_INET &&\n       ent->ifa_addr->sa_family != PF_INET6)\n     return 1;\n-#elif defined(__OpenBSD__)\n-  if (ent->ifa_addr->sa_family != PF_INET)\n-    return 1;\n #endif\n   return 0;\n }"
        },
        {
            "sha": "cd57ce20ba2edb07da377350a20b8c46937c2df1",
            "filename": "deps/uv/src/unix/core.c",
            "status": "modified",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fcore.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -40,6 +40,7 @@\n #include <sys/uio.h> /* writev */\n #include <sys/resource.h> /* getrusage */\n #include <pwd.h>\n+#include <sys/utsname.h>\n \n #ifdef __sun\n # include <netdb.h> /* MAXHOSTNAMELEN on Solaris */\n@@ -1357,3 +1358,59 @@ int uv_os_setpriority(uv_pid_t pid, int priority) {\n \n   return 0;\n }\n+\n+\n+int uv_os_uname(uv_utsname_t* buffer) {\n+  struct utsname buf;\n+  int r;\n+\n+  if (buffer == NULL)\n+    return UV_EINVAL;\n+\n+  if (uname(&buf) == -1) {\n+    r = UV__ERR(errno);\n+    goto error;\n+  }\n+\n+  r = uv__strscpy(buffer->sysname, buf.sysname, sizeof(buffer->sysname));\n+  if (r == UV_E2BIG)\n+    goto error;\n+\n+#ifdef _AIX\n+  r = snprintf(buffer->release,\n+               sizeof(buffer->release),\n+               \"%s.%s\",\n+               buf.version,\n+               buf.release);\n+  if (r >= sizeof(buffer->release)) {\n+    r = UV_E2BIG;\n+    goto error;\n+  }\n+#else\n+  r = uv__strscpy(buffer->release, buf.release, sizeof(buffer->release));\n+  if (r == UV_E2BIG)\n+    goto error;\n+#endif\n+\n+  r = uv__strscpy(buffer->version, buf.version, sizeof(buffer->version));\n+  if (r == UV_E2BIG)\n+    goto error;\n+\n+#if defined(_AIX) || defined(__PASE__)\n+  r = uv__strscpy(buffer->machine, \"ppc64\", sizeof(buffer->machine));\n+#else\n+  r = uv__strscpy(buffer->machine, buf.machine, sizeof(buffer->machine));\n+#endif\n+\n+  if (r == UV_E2BIG)\n+    goto error;\n+\n+  return 0;\n+\n+error:\n+  buffer->sysname[0] = '\\0';\n+  buffer->release[0] = '\\0';\n+  buffer->version[0] = '\\0';\n+  buffer->machine[0] = '\\0';\n+  return r;\n+}"
        },
        {
            "sha": "91bb82f725e884a8034e78b899f6af88296b2400",
            "filename": "deps/uv/src/unix/fs.c",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Ffs.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Ffs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ffs.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -155,7 +155,7 @@ static ssize_t uv__fs_fsync(uv_fs_t* req) {\n   int r;\n \n   r = fcntl(req->file, F_FULLFSYNC);\n-  if (r != 0 && errno == ENOTTY)\n+  if (r != 0)\n     r = fsync(req->file);\n   return r;\n #else\n@@ -317,6 +317,18 @@ static ssize_t uv__fs_read(uv_fs_t* req) {\n   req->bufs = NULL;\n   req->nbufs = 0;\n \n+#ifdef __PASE__\n+  /* PASE returns EOPNOTSUPP when reading a directory, convert to EISDIR */\n+  if (result == -1 && errno == EOPNOTSUPP) {\n+    struct stat buf;\n+    ssize_t rc;\n+    rc = fstat(req->file, &buf);\n+    if (rc == 0 && S_ISDIR(buf.st_mode)) {\n+      errno = EISDIR;\n+    }\n+  }\n+#endif\n+\n   return result;\n }\n "
        },
        {
            "sha": "c430562b37298a0065f6d39ecbb7e2857c863ca1",
            "filename": "deps/uv/src/unix/fsevents.c",
            "status": "modified",
            "additions": 36,
            "deletions": 34,
            "changes": 70,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Ffsevents.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Ffsevents.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ffsevents.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -255,42 +255,55 @@ static void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,\n       path = paths[i];\n       len = strlen(path);\n \n+      if (handle->realpath_len == 0)\n+        continue; /* This should be unreachable */\n+\n       /* Filter out paths that are outside handle's request */\n-      if (strncmp(path, handle->realpath, handle->realpath_len) != 0)\n+      if (len < handle->realpath_len)\n+        continue;\n+\n+      if (handle->realpath_len != len &&\n+          path[handle->realpath_len] != '/')\n+        /* Make sure that realpath actually named a directory,\n+         * or that we matched the whole string */\n         continue;\n \n-      if (handle->realpath_len > 1 || *handle->realpath != '/') {\n+      if (memcmp(path, handle->realpath, handle->realpath_len) != 0)\n+        continue;\n+\n+      if (!(handle->realpath_len == 1 && handle->realpath[0] == '/')) {\n+        /* Remove common prefix, unless the watched folder is \"/\" */\n         path += handle->realpath_len;\n         len -= handle->realpath_len;\n \n-        /* Skip forward slash */\n-        if (*path != '\\0') {\n+        /* Ignore events with path equal to directory itself */\n+        if (len <= 1 && (flags & kFSEventStreamEventFlagItemIsDir))\n+          continue;\n+\n+        if (len == 0) {\n+          /* Since we're using fsevents to watch the file itself,\n+           * realpath == path, and we now need to get the basename of the file back\n+           * (for commonality with other codepaths and platforms). */\n+          while (len < handle->realpath_len && path[-1] != '/') {\n+            path--;\n+            len++;\n+          }\n+          /* Created and Removed seem to be always set, but don't make sense */\n+          flags &= ~kFSEventsRenamed;\n+        } else {\n+          /* Skip forward slash */\n           path++;\n           len--;\n         }\n       }\n \n-#ifdef MAC_OS_X_VERSION_10_7\n-      /* Ignore events with path equal to directory itself */\n-      if (len == 0)\n-        continue;\n-#else\n-      if (len == 0 && (flags & kFSEventStreamEventFlagItemIsDir))\n-        continue;\n-#endif /* MAC_OS_X_VERSION_10_7 */\n-\n       /* Do not emit events from subdirectories (without option set) */\n-      if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 && *path != 0) {\n+      if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 && *path != '\\0') {\n         pos = strchr(path + 1, '/');\n         if (pos != NULL)\n           continue;\n       }\n \n-#ifndef MAC_OS_X_VERSION_10_7\n-      path = \"\";\n-      len = 0;\n-#endif /* MAC_OS_X_VERSION_10_7 */\n-\n       event = uv__malloc(sizeof(*event) + len);\n       if (event == NULL)\n         break;\n@@ -299,22 +312,11 @@ static void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,\n       memcpy(event->path, path, len + 1);\n       event->events = UV_RENAME;\n \n-#ifdef MAC_OS_X_VERSION_10_7\n-      if (0 != (flags & kFSEventsModified) &&\n-          0 == (flags & kFSEventsRenamed)) {\n-        event->events = UV_CHANGE;\n-      }\n-#else\n-      if (0 != (flags & kFSEventsModified) &&\n-          0 != (flags & kFSEventStreamEventFlagItemIsDir) &&\n-          0 == (flags & kFSEventStreamEventFlagItemRenamed)) {\n-        event->events = UV_CHANGE;\n-      }\n-      if (0 == (flags & kFSEventStreamEventFlagItemIsDir) &&\n-          0 == (flags & kFSEventStreamEventFlagItemRenamed)) {\n-        event->events = UV_CHANGE;\n+      if (0 == (flags & kFSEventsRenamed)) {\n+        if (0 != (flags & kFSEventsModified) ||\n+            0 == (flags & kFSEventStreamEventFlagItemIsDir))\n+          event->events = UV_CHANGE;\n       }\n-#endif /* MAC_OS_X_VERSION_10_7 */\n \n       QUEUE_INSERT_TAIL(&head, &event->member);\n     }"
        },
        {
            "sha": "c059893a46e992a84c43daefe86f2b1ce311ec07",
            "filename": "deps/uv/src/unix/internal.h",
            "status": "modified",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Finternal.h",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Finternal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Finternal.h?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -284,24 +284,6 @@ int uv__fsevents_init(uv_fs_event_t* handle);\n int uv__fsevents_close(uv_fs_event_t* handle);\n void uv__fsevents_loop_delete(uv_loop_t* loop);\n \n-/* OSX < 10.7 has no file events, polyfill them */\n-#ifndef MAC_OS_X_VERSION_10_7\n-\n-static const int kFSEventStreamCreateFlagFileEvents = 0x00000010;\n-static const int kFSEventStreamEventFlagItemCreated = 0x00000100;\n-static const int kFSEventStreamEventFlagItemRemoved = 0x00000200;\n-static const int kFSEventStreamEventFlagItemInodeMetaMod = 0x00000400;\n-static const int kFSEventStreamEventFlagItemRenamed = 0x00000800;\n-static const int kFSEventStreamEventFlagItemModified = 0x00001000;\n-static const int kFSEventStreamEventFlagItemFinderInfoMod = 0x00002000;\n-static const int kFSEventStreamEventFlagItemChangeOwner = 0x00004000;\n-static const int kFSEventStreamEventFlagItemXattrMod = 0x00008000;\n-static const int kFSEventStreamEventFlagItemIsFile = 0x00010000;\n-static const int kFSEventStreamEventFlagItemIsDir = 0x00020000;\n-static const int kFSEventStreamEventFlagItemIsSymlink = 0x00040000;\n-\n-#endif /* __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1070 */\n-\n #endif /* defined(__APPLE__) */\n \n UV_UNUSED(static void uv__update_time(uv_loop_t* loop)) {"
        },
        {
            "sha": "c24f96e1399c69b438d7cb0a9833790a662770d1",
            "filename": "deps/uv/src/unix/kqueue.c",
            "status": "modified",
            "additions": 39,
            "deletions": 40,
            "changes": 79,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fkqueue.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fkqueue.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fkqueue.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -452,79 +452,78 @@ int uv_fs_event_start(uv_fs_event_t* handle,\n                       uv_fs_event_cb cb,\n                       const char* path,\n                       unsigned int flags) {\n-#if defined(__APPLE__)\n-  struct stat statbuf;\n-#endif /* defined(__APPLE__) */\n   int fd;\n \n   if (uv__is_active(handle))\n     return UV_EINVAL;\n \n-  /* TODO open asynchronously - but how do we report back errors? */\n-  fd = open(path, O_RDONLY);\n-  if (fd == -1)\n-    return UV__ERR(errno);\n-\n-  uv__handle_start(handle);\n-  uv__io_init(&handle->event_watcher, uv__fs_event, fd);\n-  handle->path = uv__strdup(path);\n-  handle->cb = cb;\n-\n #if defined(__APPLE__)\n-  if (uv__has_forked_with_cfrunloop)\n-    goto fallback;\n-\n   /* Nullify field to perform checks later */\n   handle->cf_cb = NULL;\n   handle->realpath = NULL;\n   handle->realpath_len = 0;\n   handle->cf_flags = flags;\n \n-  if (fstat(fd, &statbuf))\n-    goto fallback;\n-  /* FSEvents works only with directories */\n-  if (!(statbuf.st_mode & S_IFDIR))\n-    goto fallback;\n-\n-  /* The fallback fd is no longer needed */\n-  uv__close(fd);\n-  handle->event_watcher.fd = -1;\n-\n-  return uv__fsevents_init(handle);\n-\n-fallback:\n+  if (!uv__has_forked_with_cfrunloop) {\n+    int r;\n+    /* The fallback fd is not used */\n+    handle->event_watcher.fd = -1;\n+    handle->path = uv__strdup(path);\n+    if (handle->path == NULL)\n+      return UV_ENOMEM;\n+    handle->cb = cb;\n+    r = uv__fsevents_init(handle);\n+    if (r == 0) {\n+      uv__handle_start(handle);\n+    } else {\n+      uv__free(handle->path);\n+      handle->path = NULL;\n+    }\n+    return r;\n+  }\n #endif /* defined(__APPLE__) */\n \n+  /* TODO open asynchronously - but how do we report back errors? */\n+  fd = open(path, O_RDONLY);\n+  if (fd == -1)\n+    return UV__ERR(errno);\n+\n+  handle->path = uv__strdup(path);\n+  if (handle->path == NULL)\n+    return UV_ENOMEM;\n+  handle->cb = cb;\n+  uv__handle_start(handle);\n+  uv__io_init(&handle->event_watcher, uv__fs_event, fd);\n   uv__io_start(handle->loop, &handle->event_watcher, POLLIN);\n \n   return 0;\n }\n \n \n int uv_fs_event_stop(uv_fs_event_t* handle) {\n+  int r;\n+  r = 0;\n+\n   if (!uv__is_active(handle))\n     return 0;\n \n   uv__handle_stop(handle);\n \n #if defined(__APPLE__)\n-  if (uv__has_forked_with_cfrunloop || uv__fsevents_close(handle))\n-#endif /* defined(__APPLE__) */\n-  {\n-    uv__io_close(handle->loop, &handle->event_watcher);\n-  }\n-\n-  uv__free(handle->path);\n-  handle->path = NULL;\n+  if (!uv__has_forked_with_cfrunloop)\n+    r = uv__fsevents_close(handle);\n+#endif\n \n   if (handle->event_watcher.fd != -1) {\n-    /* When FSEvents is used, we don't use the event_watcher's fd under certain\n-     * confitions. (see uv_fs_event_start) */\n+    uv__io_close(handle->loop, &handle->event_watcher);\n     uv__close(handle->event_watcher.fd);\n     handle->event_watcher.fd = -1;\n   }\n \n-  return 0;\n+  uv__free(handle->path);\n+  handle->path = NULL;\n+\n+  return r;\n }\n \n "
        },
        {
            "sha": "7e4d5fc7ffd429942e67023a962ff21cebed8430",
            "filename": "deps/uv/src/unix/stream.c",
            "status": "modified",
            "additions": 69,
            "deletions": 92,
            "changes": 161,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fstream.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -58,11 +58,19 @@ struct uv__stream_select_s {\n   fd_set* swrite;\n   size_t swrite_sz;\n };\n-# define WRITE_RETRY_ON_ERROR(send_handle) \\\n+\n+/* Due to a possible kernel bug at least in OS X 10.10 \"Yosemite\",\n+ * EPROTOTYPE can be returned while trying to write to a socket that is\n+ * shutting down. If we retry the write, we should get the expected EPIPE\n+ * instead.\n+ */\n+# define RETRY_ON_WRITE_ERROR(errno) (errno == EINTR || errno == EPROTOTYPE)\n+# define IS_TRANSIENT_WRITE_ERROR(errno, send_handle) \\\n     (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS || \\\n-     (errno == EMSGSIZE && send_handle))\n+     (errno == EMSGSIZE && send_handle != NULL))\n #else\n-# define WRITE_RETRY_ON_ERROR(send_handle) \\\n+# define RETRY_ON_WRITE_ERROR(errno) (errno == EINTR)\n+# define IS_TRANSIENT_WRITE_ERROR(errno, send_handle) \\\n     (errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS)\n #endif /* defined(__APPLE__) */\n \n@@ -700,6 +708,14 @@ static void uv__drain(uv_stream_t* stream) {\n }\n \n \n+static ssize_t uv__writev(int fd, struct iovec* vec, size_t n) {\n+  if (n == 1)\n+    return write(fd, vec->iov_base, vec->iov_len);\n+  else\n+    return writev(fd, vec, n);\n+}\n+\n+\n static size_t uv__write_req_size(uv_write_t* req) {\n   size_t size;\n \n@@ -712,6 +728,37 @@ static size_t uv__write_req_size(uv_write_t* req) {\n }\n \n \n+/* Returns 1 if all write request data has been written, or 0 if there is still\n+ * more data to write.\n+ *\n+ * Note: the return value only says something about the *current* request.\n+ * There may still be other write requests sitting in the queue.\n+ */\n+static int uv__write_req_update(uv_stream_t* stream,\n+                                uv_write_t* req,\n+                                size_t n) {\n+  uv_buf_t* buf;\n+  size_t len;\n+\n+  assert(n <= stream->write_queue_size);\n+  stream->write_queue_size -= n;\n+\n+  buf = req->bufs + req->write_index;\n+\n+  do {\n+    len = n < buf->len ? n : buf->len;\n+    buf->base += len;\n+    buf->len -= len;\n+    buf += (buf->len == 0);  /* Advance to next buffer if this one is empty. */\n+    n -= len;\n+  } while (n > 0);\n+\n+  req->write_index = buf - req->bufs;\n+\n+  return req->write_index == req->nbufs;\n+}\n+\n+\n static void uv__write_req_finish(uv_write_t* req) {\n   uv_stream_t* stream = req->handle;\n \n@@ -832,102 +879,32 @@ static void uv__write(uv_stream_t* stream) {\n       *pi = fd_to_send;\n     }\n \n-    do {\n+    do\n       n = sendmsg(uv__stream_fd(stream), &msg, 0);\n-    }\n-#if defined(__APPLE__)\n-    /*\n-     * Due to a possible kernel bug at least in OS X 10.10 \"Yosemite\",\n-     * EPROTOTYPE can be returned while trying to write to a socket that is\n-     * shutting down. If we retry the write, we should get the expected EPIPE\n-     * instead.\n-     */\n-    while (n == -1 && (errno == EINTR || errno == EPROTOTYPE));\n-#else\n-    while (n == -1 && errno == EINTR);\n-#endif\n-  } else {\n-    do {\n-      if (iovcnt == 1) {\n-        n = write(uv__stream_fd(stream), iov[0].iov_base, iov[0].iov_len);\n-      } else {\n-        n = writev(uv__stream_fd(stream), iov, iovcnt);\n-      }\n-    }\n-#if defined(__APPLE__)\n-    /*\n-     * Due to a possible kernel bug at least in OS X 10.10 \"Yosemite\",\n-     * EPROTOTYPE can be returned while trying to write to a socket that is\n-     * shutting down. If we retry the write, we should get the expected EPIPE\n-     * instead.\n-     */\n-    while (n == -1 && (errno == EINTR || errno == EPROTOTYPE));\n-#else\n-    while (n == -1 && errno == EINTR);\n-#endif\n-  }\n+    while (n == -1 && RETRY_ON_WRITE_ERROR(errno));\n \n-  if (n < 0) {\n-    if (!WRITE_RETRY_ON_ERROR(req->send_handle)) {\n-      err = UV__ERR(errno);\n-      goto error;\n-    } else if (stream->flags & UV_HANDLE_BLOCKING_WRITES) {\n-      /* If this is a blocking stream, try again. */\n-      goto start;\n-    }\n+    /* Ensure the handle isn't sent again in case this is a partial write. */\n+    if (n >= 0)\n+      req->send_handle = NULL;\n   } else {\n-    /* Successful write */\n-\n-    while (n >= 0) {\n-      uv_buf_t* buf = &(req->bufs[req->write_index]);\n-      size_t len = buf->len;\n-\n-      assert(req->write_index < req->nbufs);\n-\n-      if ((size_t)n < len) {\n-        buf->base += n;\n-        buf->len -= n;\n-        stream->write_queue_size -= n;\n-        n = 0;\n-\n-        /* There is more to write. */\n-        if (stream->flags & UV_HANDLE_BLOCKING_WRITES) {\n-          /*\n-           * If we're blocking then we should not be enabling the write\n-           * watcher - instead we need to try again.\n-           */\n-          goto start;\n-        } else {\n-          /* Break loop and ensure the watcher is pending. */\n-          break;\n-        }\n-\n-      } else {\n-        /* Finished writing the buf at index req->write_index. */\n-        req->write_index++;\n-\n-        assert((size_t)n >= len);\n-        n -= len;\n-\n-        assert(stream->write_queue_size >= len);\n-        stream->write_queue_size -= len;\n+    do\n+      n = uv__writev(uv__stream_fd(stream), iov, iovcnt);\n+    while (n == -1 && RETRY_ON_WRITE_ERROR(errno));\n+  }\n \n-        if (req->write_index == req->nbufs) {\n-          /* Then we're done! */\n-          assert(n == 0);\n-          uv__write_req_finish(req);\n-          /* TODO: start trying to write the next request. */\n-          return;\n-        }\n-      }\n-    }\n+  if (n == -1 && !IS_TRANSIENT_WRITE_ERROR(errno, req->send_handle)) {\n+    err = UV__ERR(errno);\n+    goto error;\n   }\n \n-  /* Either we've counted n down to zero or we've got EAGAIN. */\n-  assert(n == 0 || n == -1);\n+  if (n >= 0 && uv__write_req_update(stream, req, n)) {\n+    uv__write_req_finish(req);\n+    return;  /* TODO(bnoordhuis) Start trying to write the next request. */\n+  }\n \n-  /* Only non-blocking streams should use the write_watcher. */\n-  assert(!(stream->flags & UV_HANDLE_BLOCKING_WRITES));\n+  /* If this is a blocking stream, try again. */\n+  if (stream->flags & UV_HANDLE_BLOCKING_WRITES)\n+    goto start;\n \n   /* We're not done. */\n   uv__io_start(stream->loop, &stream->io_watcher, POLLOUT);"
        },
        {
            "sha": "8bcb857610fa98cd0aa0b796f6f97020b7a41f7f",
            "filename": "deps/uv/src/unix/thread.c",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fthread.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fthread.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fthread.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -48,8 +48,10 @@\n STATIC_ASSERT(sizeof(uv_barrier_t) == sizeof(pthread_barrier_t));\n #endif\n \n-/* Note: guard clauses should match uv_barrier_t's in include/uv/uv-unix.h. */\n-#if defined(_AIX) || !defined(PTHREAD_BARRIER_SERIAL_THREAD)\n+/* Note: guard clauses should match uv_barrier_t's in include/uv/unix.h. */\n+#if defined(_AIX) || \\\n+    defined(__OpenBSD__) || \\\n+    !defined(PTHREAD_BARRIER_SERIAL_THREAD)\n int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {\n   struct _uv_barrier* b;\n   int rc;"
        },
        {
            "sha": "ec337ec8b8dfc261749be19981b2ad545ba6454f",
            "filename": "deps/uv/src/unix/udp.c",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fudp.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Funix%2Fudp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fudp.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -760,14 +760,16 @@ int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl) {\n  * IP_MULTICAST_TTL, so hardcode the size of the option in the IPv6 case,\n  * and use the general uv__setsockopt_maybe_char call otherwise.\n  */\n-#if defined(__sun) || defined(_AIX) || defined(__MVS__)\n+#if defined(__sun) || defined(_AIX) || defined(__OpenBSD__) || \\\n+    defined(__MVS__)\n   if (handle->flags & UV_HANDLE_IPV6)\n     return uv__setsockopt(handle,\n                           IP_MULTICAST_TTL,\n                           IPV6_MULTICAST_HOPS,\n                           &ttl,\n                           sizeof(ttl));\n-#endif /* defined(__sun) || defined(_AIX) || defined(__MVS__) */\n+#endif /* defined(__sun) || defined(_AIX) || defined(__OpenBSD__) || \\\n+    defined(__MVS__) */\n \n   return uv__setsockopt_maybe_char(handle,\n                                    IP_MULTICAST_TTL,\n@@ -783,14 +785,16 @@ int uv_udp_set_multicast_loop(uv_udp_t* handle, int on) {\n  * IP_MULTICAST_LOOP, so hardcode the size of the option in the IPv6 case,\n  * and use the general uv__setsockopt_maybe_char call otherwise.\n  */\n-#if defined(__sun) || defined(_AIX) || defined(__MVS__)\n+#if defined(__sun) || defined(_AIX) || defined(__OpenBSD__) || \\\n+    defined(__MVS__) \n   if (handle->flags & UV_HANDLE_IPV6)\n     return uv__setsockopt(handle,\n                           IP_MULTICAST_LOOP,\n                           IPV6_MULTICAST_LOOP,\n                           &on,\n                           sizeof(on));\n-#endif /* defined(__sun) || defined(_AIX) || defined(__MVS__) */\n+#endif /* defined(__sun) || defined(_AIX) ||defined(__OpenBSD__) ||\n+    defined(__MVS__) */\n \n   return uv__setsockopt_maybe_char(handle,\n                                    IP_MULTICAST_LOOP,"
        },
        {
            "sha": "acf8e1107e9786ee5777522a76dc5b10c7dd2ff9",
            "filename": "deps/uv/src/win/fs-event.c",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Ffs-event.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Ffs-event.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ffs-event.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -230,8 +230,11 @@ int uv_fs_event_start(uv_fs_event_t* handle,\n      */\n \n     /* Convert to short path. */\n-    short_path = short_path_buffer;\n-    if (!GetShortPathNameW(pathw, short_path, ARRAY_SIZE(short_path))) {\n+    if (GetShortPathNameW(pathw,\n+                          short_path_buffer,\n+                          ARRAY_SIZE(short_path_buffer))) {\n+      short_path = short_path_buffer;\n+    } else {\n       short_path = NULL;\n     }\n "
        },
        {
            "sha": "65d936bf08f55586cf0786ae29cfdef9d8388858",
            "filename": "deps/uv/src/win/fs.c",
            "status": "modified",
            "additions": 2,
            "deletions": 70,
            "changes": 72,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -42,8 +42,6 @@\n #define UV_FS_FREE_PTR           0x0008\n #define UV_FS_CLEANEDUP          0x0010\n \n-#define UV__RENAME_RETRIES       4\n-#define UV__RENAME_WAIT          250\n \n #define INIT(subtype)                                                         \\\n   do {                                                                        \\\n@@ -1360,78 +1358,12 @@ static void fs__fstat(uv_fs_t* req) {\n \n \n static void fs__rename(uv_fs_t* req) {\n-  int tries;\n-  int sys_errno;\n-  int result;\n-  int try_rmdir;\n-  WCHAR* src, *dst;\n-  DWORD src_attrib, dst_attrib;\n-\n-  src = req->file.pathw;\n-  dst = req->fs.info.new_pathw;\n-  try_rmdir = 0;\n-\n-  /* Do some checks to fail early. */\n-  src_attrib = GetFileAttributesW(src);\n-  if (src_attrib == INVALID_FILE_ATTRIBUTES) {\n+  if (!MoveFileExW(req->file.pathw, req->fs.info.new_pathw, MOVEFILE_REPLACE_EXISTING)) {\n     SET_REQ_WIN32_ERROR(req, GetLastError());\n     return;\n   }\n-  dst_attrib = GetFileAttributesW(dst);\n-  if (dst_attrib != INVALID_FILE_ATTRIBUTES) {\n-    if (dst_attrib & FILE_ATTRIBUTE_READONLY) {\n-      req->result = UV_EPERM;\n-      return;\n-    }\n-    /* Renaming folder to a folder name that already exist will fail on\n-     * Windows. We will try to delete target folder first.\n-     */\n-    if (src_attrib & FILE_ATTRIBUTE_DIRECTORY &&\n-        dst_attrib & FILE_ATTRIBUTE_DIRECTORY)\n-        try_rmdir = 1;\n-  }\n-\n-  /* Sometimes an antivirus or indexing software can lock the target or the\n-   * source file/directory. This is annoying for users, in such cases we will\n-   * retry couple of times with some delay before failing.\n-   */\n-  for (tries = 0; tries < UV__RENAME_RETRIES; ++tries) {\n-    if (tries > 0)\n-      Sleep(UV__RENAME_WAIT);\n-\n-    if (try_rmdir) {\n-      result = _wrmdir(dst) == 0 ? 0 : uv_translate_sys_error(_doserrno);\n-      switch (result)\n-      {\n-      case 0:\n-      case UV_ENOENT:\n-        /* Folder removed or did not exist at all. */\n-        try_rmdir = 0;\n-        break;\n-      case UV_ENOTEMPTY:\n-        /* Non-empty target folder, fail instantly. */\n-        SET_REQ_RESULT(req, -1);\n-        return;\n-      default:\n-        /* All other errors - try to move file anyway and handle the error\n-         * there, retrying folder deletion next time around.\n-         */\n-        break;\n-      }\n-    }\n-\n-    if (MoveFileExW(src, dst, MOVEFILE_REPLACE_EXISTING) != 0) {\n-      SET_REQ_RESULT(req, 0);\n-      return;\n-    }\n \n-    sys_errno = GetLastError();\n-    result = uv_translate_sys_error(sys_errno);\n-    if (result != UV_EBUSY && result != UV_EPERM && result != UV_EACCES)\n-      break;\n-  }\n-  req->sys_errno_ = sys_errno;\n-  req->result = result;\n+  SET_REQ_RESULT(req, 0);\n }\n \n "
        },
        {
            "sha": "277f6497a25234e57f5b3d44632f186551e08659",
            "filename": "deps/uv/src/win/pipe.c",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -1310,7 +1310,6 @@ static int uv__pipe_write_data(uv_loop_t* loop,\n                                uv_pipe_t* handle,\n                                const uv_buf_t bufs[],\n                                size_t nbufs,\n-                               uv_stream_t* send_handle,\n                                uv_write_cb cb,\n                                int copy_always) {\n   int err;\n@@ -1321,7 +1320,7 @@ static int uv__pipe_write_data(uv_loop_t* loop,\n \n   UV_REQ_INIT(req, UV_WRITE);\n   req->handle = (uv_stream_t*) handle;\n-  req->send_handle = send_handle;\n+  req->send_handle = NULL;\n   req->cb = cb;\n   /* Private fields. */\n   req->coalesced = 0;\n@@ -1558,8 +1557,7 @@ int uv__pipe_write_ipc(uv_loop_t* loop,\n \n   /* Write buffers. We set the `always_copy` flag, so it is not a problem that\n    * some of the written data lives on the stack. */\n-  err = uv__pipe_write_data(\n-      loop, req, handle, bufs, buf_count, send_handle, cb, 1);\n+  err = uv__pipe_write_data(loop, req, handle, bufs, buf_count, cb, 1);\n \n   /* If we had to heap-allocate the bufs array, free it now. */\n   if (bufs != stack_bufs) {\n@@ -1583,8 +1581,7 @@ int uv__pipe_write(uv_loop_t* loop,\n   } else {\n     /* Non-IPC pipe write: put data on the wire directly. */\n     assert(send_handle == NULL);\n-    return uv__pipe_write_data(\n-        loop, req, handle, bufs, nbufs, NULL, cb, 0);\n+    return uv__pipe_write_data(loop, req, handle, bufs, nbufs, cb, 0);\n   }\n }\n "
        },
        {
            "sha": "fd4b7c98688f691cb56eb72d39d12866a05323c0",
            "filename": "deps/uv/src/win/thread.c",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -23,6 +23,12 @@\n #include <limits.h>\n #include <stdlib.h>\n \n+#if defined(__MINGW64_VERSION_MAJOR)\n+/* MemoryBarrier expands to __mm_mfence in some cases (x86+sse2), which may\n+ * require this header in some versions of mingw64. */\n+#include <intrin.h>\n+#endif\n+\n #include \"uv.h\"\n #include \"internal.h\"\n "
        },
        {
            "sha": "f38e9a88636e4b049e0b68c3a28b02cf22f790d3",
            "filename": "deps/uv/src/win/tty.c",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -164,7 +164,7 @@ void uv_console_init(void) {\n                                        OPEN_EXISTING,\n                                        0,\n                                        0);\n-  if (uv__tty_console_handle != NULL) {\n+  if (uv__tty_console_handle != INVALID_HANDLE_VALUE) {\n     QueueUserWorkItem(uv__tty_console_resize_message_loop_thread,\n                       NULL,\n                       WT_EXECUTELONGFUNCTION);\n@@ -360,6 +360,8 @@ int uv_tty_set_mode(uv_tty_t* tty, uv_tty_mode_t mode) {\n     }\n   } else {\n     was_reading = 0;\n+    alloc_cb = NULL;\n+    read_cb = NULL;\n   }\n \n   uv_sem_wait(&uv_tty_output_lock);\n@@ -733,8 +735,9 @@ void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,\n \n       /* Ignore keyup events, unless the left alt key was held and a valid\n        * unicode character was emitted. */\n-      if (!KEV.bKeyDown && !(((KEV.dwControlKeyState & LEFT_ALT_PRESSED) ||\n-          KEV.wVirtualKeyCode==VK_MENU) && KEV.uChar.UnicodeChar != 0)) {\n+      if (!KEV.bKeyDown &&\n+          KEV.wVirtualKeyCode != VK_MENU &&\n+          KEV.uChar.UnicodeChar != 0) {\n         continue;\n       }\n "
        },
        {
            "sha": "923789129e92e0475d5cfc3df52d04b556867d69",
            "filename": "deps/uv/src/win/util.c",
            "status": "modified",
            "additions": 117,
            "deletions": 0,
            "changes": 117,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Futil.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Futil.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Futil.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -1627,3 +1627,120 @@ int uv_os_setpriority(uv_pid_t pid, int priority) {\n   CloseHandle(handle);\n   return r;\n }\n+\n+\n+int uv_os_uname(uv_utsname_t* buffer) {\n+  /* Implementation loosely based on\n+     https://github.com/gagern/gnulib/blob/master/lib/uname.c */\n+  OSVERSIONINFOW os_info;\n+  SYSTEM_INFO system_info;\n+  int processor_level;\n+  int r;\n+\n+  if (buffer == NULL)\n+    return UV_EINVAL;\n+\n+  uv__once_init();\n+  os_info.dwOSVersionInfoSize = sizeof(os_info);\n+  os_info.szCSDVersion[0] = L'\\0';\n+\n+  /* Try calling RtlGetVersion(), and fall back to the deprecated GetVersionEx()\n+     if RtlGetVersion() is not available. */\n+  if (pRtlGetVersion) {\n+    pRtlGetVersion(&os_info);\n+  } else {\n+    /* Silence GetVersionEx() deprecation warning. */\n+    #pragma warning(suppress : 4996)\n+    if (GetVersionExW(&os_info) == 0) {\n+      r = uv_translate_sys_error(GetLastError());\n+      goto error;\n+    }\n+  }\n+\n+  /* Populate the version field. */\n+  if (WideCharToMultiByte(CP_UTF8,\n+                          0,\n+                          os_info.szCSDVersion,\n+                          -1,\n+                          buffer->version,\n+                          sizeof(buffer->version),\n+                          NULL,\n+                          NULL) == 0) {\n+    r = uv_translate_sys_error(GetLastError());\n+    goto error;\n+  }\n+\n+  /* Populate the sysname field. */\n+#ifdef __MINGW32__\n+  r = snprintf(buffer->sysname,\n+               sizeof(buffer->sysname),\n+               \"MINGW32_NT-%u.%u\",\n+               (unsigned int) os_info.dwMajorVersion,\n+               (unsigned int) os_info.dwMinorVersion);\n+  assert(r < sizeof(buffer->sysname));\n+#else\n+  uv__strscpy(buffer->sysname, \"Windows_NT\", sizeof(buffer->sysname));\n+#endif\n+\n+  /* Populate the release field. */\n+  r = snprintf(buffer->release,\n+               sizeof(buffer->release),\n+               \"%d.%d.%d\",\n+               (unsigned int) os_info.dwMajorVersion,\n+               (unsigned int) os_info.dwMinorVersion,\n+               (unsigned int) os_info.dwBuildNumber);\n+  assert(r < sizeof(buffer->release));\n+\n+  /* Populate the machine field. */\n+  GetSystemInfo(&system_info);\n+\n+  switch (system_info.wProcessorArchitecture) {\n+    case PROCESSOR_ARCHITECTURE_AMD64:\n+      uv__strscpy(buffer->machine, \"x86_64\", sizeof(buffer->machine));\n+      break;\n+    case PROCESSOR_ARCHITECTURE_IA64:\n+      uv__strscpy(buffer->machine, \"ia64\", sizeof(buffer->machine));\n+      break;\n+    case PROCESSOR_ARCHITECTURE_INTEL:\n+      uv__strscpy(buffer->machine, \"i386\", sizeof(buffer->machine));\n+\n+      if (system_info.wProcessorLevel > 3) {\n+        processor_level = system_info.wProcessorLevel < 6 ?\n+                          system_info.wProcessorLevel : 6;\n+        buffer->machine[1] = '0' + processor_level;\n+      }\n+\n+      break;\n+    case PROCESSOR_ARCHITECTURE_IA32_ON_WIN64:\n+      uv__strscpy(buffer->machine, \"i686\", sizeof(buffer->machine));\n+      break;\n+    case PROCESSOR_ARCHITECTURE_MIPS:\n+      uv__strscpy(buffer->machine, \"mips\", sizeof(buffer->machine));\n+      break;\n+    case PROCESSOR_ARCHITECTURE_ALPHA:\n+    case PROCESSOR_ARCHITECTURE_ALPHA64:\n+      uv__strscpy(buffer->machine, \"alpha\", sizeof(buffer->machine));\n+      break;\n+    case PROCESSOR_ARCHITECTURE_PPC:\n+      uv__strscpy(buffer->machine, \"powerpc\", sizeof(buffer->machine));\n+      break;\n+    case PROCESSOR_ARCHITECTURE_SHX:\n+      uv__strscpy(buffer->machine, \"sh\", sizeof(buffer->machine));\n+      break;\n+    case PROCESSOR_ARCHITECTURE_ARM:\n+      uv__strscpy(buffer->machine, \"arm\", sizeof(buffer->machine));\n+      break;\n+    default:\n+      uv__strscpy(buffer->machine, \"unknown\", sizeof(buffer->machine));\n+      break;\n+  }\n+\n+  return 0;\n+\n+error:\n+  buffer->sysname[0] = '\\0';\n+  buffer->release[0] = '\\0';\n+  buffer->version[0] = '\\0';\n+  buffer->machine[0] = '\\0';\n+  return r;\n+}"
        },
        {
            "sha": "fbbbceed95ebcf569a2de9c23c715f210ab3be3e",
            "filename": "deps/uv/src/win/winapi.c",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -26,6 +26,7 @@\n \n \n /* Ntdll function pointers */\n+sRtlGetVersion pRtlGetVersion;\n sRtlNtStatusToDosError pRtlNtStatusToDosError;\n sNtDeviceIoControlFile pNtDeviceIoControlFile;\n sNtQueryInformationFile pNtQueryInformationFile;\n@@ -55,6 +56,9 @@ void uv_winapi_init(void) {\n     uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n   }\n \n+  pRtlGetVersion = (sRtlGetVersion) GetProcAddress(ntdll_module,\n+                                                   \"RtlGetVersion\");\n+\n   pRtlNtStatusToDosError = (sRtlNtStatusToDosError) GetProcAddress(\n       ntdll_module,\n       \"RtlNtStatusToDosError\");"
        },
        {
            "sha": "82c5ed46711d2f3abc20c742be6cae0cce4e3cfc",
            "filename": "deps/uv/src/win/winapi.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.h",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.h?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -4519,6 +4519,9 @@ typedef VOID (NTAPI *PIO_APC_ROUTINE)\n               PIO_STATUS_BLOCK IoStatusBlock,\n               ULONG Reserved);\n \n+typedef NTSTATUS (NTAPI *sRtlGetVersion)\n+                 (PRTL_OSVERSIONINFOW lpVersionInformation);\n+\n typedef ULONG (NTAPI *sRtlNtStatusToDosError)\n               (NTSTATUS Status);\n \n@@ -4707,6 +4710,7 @@ typedef HWINEVENTHOOK (WINAPI *sSetWinEventHook)\n \n \n /* Ntdll function pointers */\n+extern sRtlGetVersion pRtlGetVersion;\n extern sRtlNtStatusToDosError pRtlNtStatusToDosError;\n extern sNtDeviceIoControlFile pNtDeviceIoControlFile;\n extern sNtQueryInformationFile pNtQueryInformationFile;"
        },
        {
            "sha": "eba28ecb9aa0a50d41b97f2393588aa4d88a468d",
            "filename": "deps/uv/test/run-tests.c",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Frun-tests.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Frun-tests.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Frun-tests.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -42,6 +42,7 @@ int ipc_helper_tcp_connection(void);\n int ipc_helper_closed_handle(void);\n int ipc_send_recv_helper(void);\n int ipc_helper_bind_twice(void);\n+int ipc_helper_send_zero(void);\n int stdio_over_pipes_helper(void);\n int spawn_stdin_stdout(void);\n int spawn_tcp_server_helper(void);\n@@ -104,6 +105,10 @@ static int maybe_run_test(int argc, char **argv) {\n     return ipc_helper_bind_twice();\n   }\n \n+  if (strcmp(argv[1], \"ipc_helper_send_zero\") == 0) {\n+    return ipc_helper_send_zero();\n+  }\n+\n   if (strcmp(argv[1], \"stdio_over_pipes_helper\") == 0) {\n     return stdio_over_pipes_helper();\n   }"
        },
        {
            "sha": "ea34bd63a70625c3e2c60d5a1bbb087c5f0bbb2e",
            "filename": "deps/uv/test/test-fs-event.c",
            "status": "modified",
            "additions": 71,
            "deletions": 31,
            "changes": 102,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-fs-event.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-fs-event.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fs-event.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -480,6 +480,8 @@ TEST_IMPL(fs_event_watch_dir_recursive) {\n #ifdef _WIN32\n TEST_IMPL(fs_event_watch_dir_short_path) {\n   uv_loop_t* loop;\n+  uv_fs_t req;\n+  int has_shortnames;\n   int r;\n \n   /* Setup */\n@@ -489,26 +491,37 @@ TEST_IMPL(fs_event_watch_dir_short_path) {\n   create_dir(\"watch_dir\");\n   create_file(\"watch_dir/file1\");\n \n-  r = uv_fs_event_init(loop, &fs_event);\n-  ASSERT(r == 0);\n-  r = uv_fs_event_start(&fs_event, fs_event_cb_dir, \"watch_~1\", 0);\n-  ASSERT(r == 0);\n-  r = uv_timer_init(loop, &timer);\n-  ASSERT(r == 0);\n-  r = uv_timer_start(&timer, timer_cb_file, 100, 0);\n-  ASSERT(r == 0);\n+  /* Newer version of Windows ship with\n+     HKLM\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\\NtfsDisable8dot3NameCreation\n+     not equal to 0. So we verify the files we created are addressable by a 8.3\n+     short name */\n+  has_shortnames = uv_fs_stat(NULL, &req, \"watch_~1\", NULL) != UV_ENOENT;\n+  if (has_shortnames) {\n+    r = uv_fs_event_init(loop, &fs_event);\n+    ASSERT(r == 0);\n+    r = uv_fs_event_start(&fs_event, fs_event_cb_dir, \"watch_~1\", 0);\n+    ASSERT(r == 0);\n+    r = uv_timer_init(loop, &timer);\n+    ASSERT(r == 0);\n+    r = uv_timer_start(&timer, timer_cb_file, 100, 0);\n+    ASSERT(r == 0);\n \n-  uv_run(loop, UV_RUN_DEFAULT);\n+    uv_run(loop, UV_RUN_DEFAULT);\n \n-  ASSERT(fs_event_cb_called == 1);\n-  ASSERT(timer_cb_called == 1);\n-  ASSERT(close_cb_called == 1);\n+    ASSERT(fs_event_cb_called == 1);\n+    ASSERT(timer_cb_called == 1);\n+    ASSERT(close_cb_called == 1);\n+  }\n \n   /* Cleanup */\n   remove(\"watch_dir/file1\");\n   remove(\"watch_dir/\");\n \n   MAKE_VALGRIND_HAPPY();\n+\n+  if (!has_shortnames)\n+    RETURN_SKIP(\"Was not able to address files with 8.3 short name.\");\n+\n   return 0;\n }\n #endif\n@@ -576,6 +589,14 @@ TEST_IMPL(fs_event_watch_file_exact_path) {\n   create_dir(\"watch_dir\");\n   create_file(\"watch_dir/file.js\");\n   create_file(\"watch_dir/file.jsx\");\n+#if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_12)\n+  /* Empirically, FSEvents seems to (reliably) report the preceeding\n+   * create_file events prior to macOS 10.11.6 in the subsequent fs_watch\n+   * creation, but that behavior hasn't been observed to occur on newer\n+   * versions. Give a long delay here to let the system settle before running\n+   * the test. */\n+  uv_sleep(1100);\n+#endif\n \n   r = uv_fs_event_init(loop, &fs_event);\n   ASSERT(r == 0);\n@@ -648,7 +669,7 @@ TEST_IMPL(fs_event_watch_file_current_dir) {\n   r = uv_timer_init(loop, &timer);\n   ASSERT(r == 0);\n \n-  r = uv_timer_start(&timer, timer_cb_touch, 100, 0);\n+  r = uv_timer_start(&timer, timer_cb_touch, 1100, 0);\n   ASSERT(r == 0);\n \n   ASSERT(timer_cb_touch_called == 0);\n@@ -936,32 +957,48 @@ TEST_IMPL(fs_event_getpath) {\n   RETURN_SKIP(NO_FS_EVENTS);\n #endif\n   uv_loop_t* loop = uv_default_loop();\n+  unsigned i;\n   int r;\n   char buf[1024];\n   size_t len;\n+  const char* const watch_dir[] = {\n+    \"watch_dir\",\n+    \"watch_dir/\",\n+    \"watch_dir///\",\n+    \"watch_dir/subfolder/..\",\n+    \"watch_dir//subfolder//..//\",\n+  };\n \n   create_dir(\"watch_dir\");\n+  create_dir(\"watch_dir/subfolder\");\n \n-  r = uv_fs_event_init(loop, &fs_event);\n-  ASSERT(r == 0);\n-  len = sizeof buf;\n-  r = uv_fs_event_getpath(&fs_event, buf, &len);\n-  ASSERT(r == UV_EINVAL);\n-  r = uv_fs_event_start(&fs_event, fail_cb, \"watch_dir\", 0);\n-  ASSERT(r == 0);\n-  len = sizeof buf;\n-  r = uv_fs_event_getpath(&fs_event, buf, &len);\n-  ASSERT(r == 0);\n-  ASSERT(buf[len - 1] != 0);\n-  ASSERT(buf[len] == '\\0');\n-  ASSERT(memcmp(buf, \"watch_dir\", len) == 0);\n-  r = uv_fs_event_stop(&fs_event);\n-  ASSERT(r == 0);\n-  uv_close((uv_handle_t*) &fs_event, close_cb);\n \n-  uv_run(loop, UV_RUN_DEFAULT);\n+  for (i = 0; i < ARRAY_SIZE(watch_dir); i++) {\n+    r = uv_fs_event_init(loop, &fs_event);\n+    ASSERT(r == 0);\n+    len = sizeof buf;\n+    r = uv_fs_event_getpath(&fs_event, buf, &len);\n+    ASSERT(r == UV_EINVAL);\n+    r = uv_fs_event_start(&fs_event, fail_cb, watch_dir[i], 0);\n+    ASSERT(r == 0);\n+    len = 0;\n+    r = uv_fs_event_getpath(&fs_event, buf, &len);\n+    ASSERT(r == UV_ENOBUFS);\n+    ASSERT(len < sizeof buf); /* sanity check */\n+    ASSERT(len == strlen(watch_dir[i]) + 1);\n+    r = uv_fs_event_getpath(&fs_event, buf, &len);\n+    ASSERT(r == 0);\n+    ASSERT(len == strlen(watch_dir[i]));\n+    ASSERT(strcmp(buf, watch_dir[i]) == 0);\n+    r = uv_fs_event_stop(&fs_event);\n+    ASSERT(r == 0);\n+    uv_close((uv_handle_t*) &fs_event, close_cb);\n \n-  ASSERT(close_cb_called == 1);\n+    uv_run(loop, UV_RUN_DEFAULT);\n+\n+    ASSERT(close_cb_called == 1);\n+    close_cb_called = 0;\n+  }\n \n   remove(\"watch_dir/\");\n   MAKE_VALGRIND_HAPPY();\n@@ -1082,6 +1119,9 @@ TEST_IMPL(fs_event_watch_invalid_path) {\n   r = uv_fs_event_start(&fs_event, fs_event_cb_file, \"<:;\", 0);\n   ASSERT(r != 0);\n   ASSERT(uv_is_active((uv_handle_t*) &fs_event) == 0);\n+  r = uv_fs_event_start(&fs_event, fs_event_cb_file, \"\", 0);\n+  ASSERT(r != 0);\n+  ASSERT(uv_is_active((uv_handle_t*) &fs_event) == 0);\n   MAKE_VALGRIND_HAPPY();\n   return 0;\n }"
        },
        {
            "sha": "753fb7b7c209e771f0feb9ff478dc36fe767f076",
            "filename": "deps/uv/test/test-ipc-heavy-traffic-deadlock-bug.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-ipc-heavy-traffic-deadlock-bug.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-ipc-heavy-traffic-deadlock-bug.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-ipc-heavy-traffic-deadlock-bug.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -55,7 +55,7 @@ static void write_cb(uv_write_t* req, int status) {\n }\n \n static void shutdown_cb(uv_shutdown_t* req, int status) {\n-  ASSERT(status == 0);\n+  ASSERT(status == 0 || status == UV_ENOTCONN);\n   uv_close((uv_handle_t*) req->handle, NULL);\n }\n "
        },
        {
            "sha": "12d4e33221f4cf1f69e8882821ab56a5571f6f5d",
            "filename": "deps/uv/test/test-ipc-send-recv.c",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-ipc-send-recv.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-ipc-send-recv.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-ipc-send-recv.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -149,7 +149,6 @@ static void connect_cb(uv_connect_t* req, int status) {\n                 &ctx.send.stream,\n                 NULL);\n   ASSERT(r == 0);\n-  ASSERT(ctx.write_req.send_handle == &ctx.send.stream);\n \n   /* Perform two writes to the same pipe to make sure that on Windows we are\n    * not running into issue 505:\n@@ -161,7 +160,6 @@ static void connect_cb(uv_connect_t* req, int status) {\n                 &ctx.send2.stream,\n                 NULL);\n   ASSERT(r == 0);\n-  ASSERT(ctx.write_req2.send_handle == &ctx.send2.stream);\n \n   r = uv_read_start((uv_stream_t*)&ctx.channel, alloc_cb, recv_cb);\n   ASSERT(r == 0);\n@@ -346,7 +344,6 @@ static void read_cb(uv_stream_t* handle,\n                   &recv->stream,\n                   write2_cb);\n     ASSERT(r == 0);\n-    ASSERT(write_req->send_handle == &recv->stream);\n   } while (uv_pipe_pending_count(pipe) > 0);\n }\n "
        },
        {
            "sha": "88d04ba143cff4f37855977d2e433d481602bf13",
            "filename": "deps/uv/test/test-ipc.c",
            "status": "modified",
            "additions": 112,
            "deletions": 29,
            "changes": 141,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-ipc.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-ipc.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-ipc.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -39,12 +39,15 @@ static int local_conn_accepted;\n static int remote_conn_accepted;\n static int tcp_server_listening;\n static uv_write_t write_req;\n+static uv_write_t write_req2;\n static uv_write_t conn_notify_req;\n static int close_cb_called;\n static int connection_accepted;\n static int tcp_conn_read_cb_called;\n static int tcp_conn_write_cb_called;\n static int closed_handle_data_read;\n+static int closed_handle_write;\n+static int send_zero_write;\n \n typedef struct {\n   uv_connect_t conn_req;\n@@ -54,7 +57,15 @@ typedef struct {\n \n #define CONN_COUNT 100\n #define BACKLOG 128\n-#define LARGE_SIZE 1000000\n+#define LARGE_SIZE 100000\n+\n+static uv_buf_t large_buf;\n+static char buffer[LARGE_SIZE];\n+static uv_write_t write_reqs[300];\n+static int write_reqs_completed;\n+\n+static unsigned int write_until_data_queued(void);\n+static void send_handle_and_close(void);\n \n \n static void close_server_conn_cb(uv_handle_t* handle) {\n@@ -92,6 +103,7 @@ static void exit_cb(uv_process_t* process,\n   printf(\"exit_cb\\n\");\n   exit_cb_called++;\n   ASSERT(exit_status == 0);\n+  ASSERT(term_signal == 0);\n   uv_close((uv_handle_t*)process, NULL);\n }\n \n@@ -420,6 +432,14 @@ static void on_read_closed_handle(uv_stream_t* handle,\n #endif\n \n \n+static void on_read_send_zero(uv_stream_t* handle,\n+                              ssize_t nread,\n+                              const uv_buf_t* buf) {\n+  ASSERT(nread == 0 || nread == UV_EOF);\n+  free(buf->base);\n+}\n+\n+\n static int run_ipc_test(const char* helper, uv_read_cb read_cb) {\n   uv_process_t process;\n   int r;\n@@ -544,6 +564,13 @@ TEST_IMPL(ipc_listen_after_bind_twice) {\n }\n #endif\n \n+TEST_IMPL(ipc_send_zero) {\n+  int r;\n+  r = run_ipc_test(\"ipc_helper_send_zero\", on_read_send_zero);\n+  ASSERT(r == 0);\n+  return 0;\n+}\n+\n \n /* Everything here runs in a child process. */\n \n@@ -573,14 +600,25 @@ static void tcp_connection_write_cb(uv_write_t* req, int status) {\n static void closed_handle_large_write_cb(uv_write_t* req, int status) {\n   ASSERT(status == 0);\n   ASSERT(closed_handle_data_read = LARGE_SIZE);\n+  if (++write_reqs_completed == ARRAY_SIZE(write_reqs)) {\n+    write_reqs_completed = 0;\n+    if (write_until_data_queued() > 0)\n+      send_handle_and_close();\n+  }\n }\n \n \n static void closed_handle_write_cb(uv_write_t* req, int status) {\n   ASSERT(status == UV_EBADF);\n+  closed_handle_write = 1;\n }\n \n \n+static void send_zero_write_cb(uv_write_t* req, int status) {\n+  ASSERT(status == 0);\n+  send_zero_write++;\n+}\n+\n static void on_tcp_child_process_read(uv_stream_t* tcp,\n                                       ssize_t nread,\n                                       const uv_buf_t* buf) {\n@@ -688,7 +726,6 @@ int ipc_helper(int listen_after_write) {\n    * over which a handle will be transmitted.\n    */\n   struct sockaddr_in addr;\n-  uv_write_t write_req;\n   int r;\n   uv_buf_t buf;\n \n@@ -788,26 +825,28 @@ int ipc_helper_tcp_connection(void) {\n   return 0;\n }\n \n-\n-int ipc_helper_closed_handle(void) {\n+static unsigned int write_until_data_queued() {\n+  unsigned int i;\n   int r;\n-  struct sockaddr_in addr;\n-  uv_write_t write_req;\n-  uv_write_t write_req2;\n-  uv_buf_t buf;\n-  char buffer[LARGE_SIZE];\n \n-  r = uv_pipe_init(uv_default_loop(), &channel, 1);\n-  ASSERT(r == 0);\n-\n-  uv_pipe_open(&channel, 0);\n+  i = 0;\n+  do {\n+    r = uv_write(&write_reqs[i],\n+                 (uv_stream_t*)&channel,\n+                 &large_buf,\n+                 1,\n+                 closed_handle_large_write_cb);\n+    ASSERT(r == 0);\n+    i++;\n+  } while (((uv_stream_t*)&channel)->write_queue_size == 0 &&\n+           i < ARRAY_SIZE(write_reqs));\n \n-  ASSERT(1 == uv_is_readable((uv_stream_t*) &channel));\n-  ASSERT(1 == uv_is_writable((uv_stream_t*) &channel));\n-  ASSERT(0 == uv_is_closing((uv_handle_t*) &channel));\n+  return ((uv_stream_t*)&channel)->write_queue_size;\n+}\n \n-  memset(buffer, '.', LARGE_SIZE);\n-  buf = uv_buf_init(buffer, LARGE_SIZE);\n+static void send_handle_and_close() {\n+  int r;\n+  struct sockaddr_in addr;\n \n   r = uv_tcp_init(uv_default_loop(), &tcp_server);\n   ASSERT(r == 0);\n@@ -817,26 +856,40 @@ int ipc_helper_closed_handle(void) {\n   r = uv_tcp_bind(&tcp_server, (const struct sockaddr*) &addr, 0);\n   ASSERT(r == 0);\n \n-  r = uv_write(&write_req,\n-               (uv_stream_t*)&channel,\n-               &buf,\n-               1,\n-               closed_handle_large_write_cb);\n-  ASSERT(r == 0);\n-\n-  r = uv_write2(&write_req2,\n+  r = uv_write2(&write_req,\n                 (uv_stream_t*)&channel,\n-                &buf,\n+                &large_buf,\n                 1,\n                 (uv_stream_t*)&tcp_server,\n                 closed_handle_write_cb);\n   ASSERT(r == 0);\n \n   uv_close((uv_handle_t*)&tcp_server, NULL);\n+}\n+\n+int ipc_helper_closed_handle(void) {\n+  int r;\n+\n+  memset(buffer, '.', LARGE_SIZE);\n+  large_buf = uv_buf_init(buffer, LARGE_SIZE);\n+\n+  r = uv_pipe_init(uv_default_loop(), &channel, 1);\n+  ASSERT(r == 0);\n+\n+  uv_pipe_open(&channel, 0);\n+\n+  ASSERT(1 == uv_is_readable((uv_stream_t*) &channel));\n+  ASSERT(1 == uv_is_writable((uv_stream_t*) &channel));\n+  ASSERT(0 == uv_is_closing((uv_handle_t*) &channel));\n+\n+  if (write_until_data_queued() > 0)\n+    send_handle_and_close();\n \n   r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n   ASSERT(r == 0);\n \n+  ASSERT(closed_handle_write == 1);\n+\n   MAKE_VALGRIND_HAPPY();\n   return 0;\n }\n@@ -848,8 +901,6 @@ int ipc_helper_bind_twice(void) {\n    * over which two handles will be transmitted.\n    */\n   struct sockaddr_in addr;\n-  uv_write_t write_req;\n-  uv_write_t write_req2;\n   int r;\n   uv_buf_t buf;\n \n@@ -889,3 +940,35 @@ int ipc_helper_bind_twice(void) {\n   MAKE_VALGRIND_HAPPY();\n   return 0;\n }\n+\n+int ipc_helper_send_zero(void) {\n+  int r;\n+  uv_buf_t zero_buf;\n+\n+  zero_buf = uv_buf_init(0, 0);\n+\n+  r = uv_pipe_init(uv_default_loop(), &channel, 0);\n+  ASSERT(r == 0);\n+\n+  uv_pipe_open(&channel, 0);\n+\n+  ASSERT(1 == uv_is_readable((uv_stream_t*) &channel));\n+  ASSERT(1 == uv_is_writable((uv_stream_t*) &channel));\n+  ASSERT(0 == uv_is_closing((uv_handle_t*) &channel));\n+\n+  r = uv_write(&write_req,\n+               (uv_stream_t*)&channel,\n+               &zero_buf,\n+               1,\n+               send_zero_write_cb);\n+\n+  ASSERT(r == 0);\n+\n+  r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n+  ASSERT(r == 0);\n+\n+  ASSERT(send_zero_write == 1);\n+\n+  MAKE_VALGRIND_HAPPY();\n+  return 0;\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "53372c90f769f8d8b6d33753a314f21eaa29e5e2",
            "filename": "deps/uv/test/test-list.h",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-list.h",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-list.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-list.h?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -69,6 +69,7 @@ TEST_DECLARE   (ipc_send_recv_pipe_inprocess)\n TEST_DECLARE   (ipc_send_recv_tcp)\n TEST_DECLARE   (ipc_send_recv_tcp_inprocess)\n TEST_DECLARE   (ipc_tcp_connection)\n+TEST_DECLARE   (ipc_send_zero)\n #ifndef _WIN32\n TEST_DECLARE   (ipc_closed_handle)\n #endif\n@@ -436,16 +437,21 @@ TEST_DECLARE  (fork_socketpair)\n TEST_DECLARE  (fork_socketpair_started)\n TEST_DECLARE  (fork_signal_to_child)\n TEST_DECLARE  (fork_signal_to_child_closed)\n+#ifndef __APPLE__ /* This is forbidden in a fork child: The process has forked\n+                     and you cannot use this CoreFoundation functionality\n+                     safely. You MUST exec(). */\n TEST_DECLARE  (fork_fs_events_child)\n TEST_DECLARE  (fork_fs_events_child_dir)\n TEST_DECLARE  (fork_fs_events_file_parent_child)\n+#endif\n #ifndef __MVS__\n TEST_DECLARE  (fork_threadpool_queue_work_simple)\n #endif\n #endif\n \n TEST_DECLARE  (idna_toascii)\n TEST_DECLARE  (utf8_decode1)\n+TEST_DECLARE  (uname)\n \n TASK_LIST_START\n   TEST_ENTRY_CUSTOM (platform_output, 0, 1, 5000)\n@@ -510,6 +516,7 @@ TASK_LIST_START\n   TEST_ENTRY  (ipc_send_recv_tcp)\n   TEST_ENTRY  (ipc_send_recv_tcp_inprocess)\n   TEST_ENTRY  (ipc_tcp_connection)\n+  TEST_ENTRY  (ipc_send_zero)\n #ifndef _WIN32\n   TEST_ENTRY  (ipc_closed_handle)\n #endif\n@@ -945,15 +952,18 @@ TASK_LIST_START\n   TEST_ENTRY  (fork_socketpair_started)\n   TEST_ENTRY  (fork_signal_to_child)\n   TEST_ENTRY  (fork_signal_to_child_closed)\n+#ifndef __APPLE__\n   TEST_ENTRY  (fork_fs_events_child)\n   TEST_ENTRY  (fork_fs_events_child_dir)\n   TEST_ENTRY  (fork_fs_events_file_parent_child)\n+#endif\n #ifndef __MVS__\n   TEST_ENTRY  (fork_threadpool_queue_work_simple)\n #endif\n #endif\n \n   TEST_ENTRY  (utf8_decode1)\n+  TEST_ENTRY  (uname)\n \n /* Doesn't work on z/OS because that platform uses EBCDIC, not ASCII. */\n #ifndef __MVS__"
        },
        {
            "sha": "e651e5c582956ed278695e9be1607fbcddd6b5c2",
            "filename": "deps/uv/test/test-platform-output.c",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-platform-output.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-platform-output.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-platform-output.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -35,6 +35,7 @@ TEST_IMPL(platform_output) {\n   uv_cpu_info_t* cpus;\n   uv_interface_address_t* interfaces;\n   uv_passwd_t pwd;\n+  uv_utsname_t uname;\n   int count;\n   int i;\n   int err;\n@@ -153,5 +154,13 @@ TEST_IMPL(platform_output) {\n   ASSERT(ppid > 0);\n   printf(\"uv_os_getppid: %d\\n\", (int) ppid);\n \n+  err = uv_os_uname(&uname);\n+  ASSERT(err == 0);\n+  printf(\"uv_os_uname:\\n\");\n+  printf(\"  sysname: %s\\n\", uname.sysname);\n+  printf(\"  release: %s\\n\", uname.release);\n+  printf(\"  version: %s\\n\", uname.version);\n+  printf(\"  machine: %s\\n\", uname.machine);\n+\n   return 0;\n }"
        },
        {
            "sha": "105a17fe67771a288fbb7e382de6330b8bdd3fd9",
            "filename": "deps/uv/test/test-uname.c",
            "status": "added",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-uname.c",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest-uname.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-uname.c?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -0,0 +1,69 @@\n+/* Copyright libuv project contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+#include <string.h>\n+\n+#ifndef _WIN32\n+# include <sys/utsname.h>\n+#endif\n+\n+TEST_IMPL(uname) {\n+#ifndef _WIN32\n+  struct utsname buf;\n+#endif\n+#ifdef _AIX\n+  char temp[256];\n+#endif\n+  uv_utsname_t buffer;\n+  int r;\n+\n+  /* Verify that NULL is handled properly. */\n+  r = uv_os_uname(NULL);\n+  ASSERT(r == UV_EINVAL);\n+\n+  /* Verify the happy path. */\n+  r = uv_os_uname(&buffer);\n+  ASSERT(r == 0);\n+\n+#ifndef _WIN32\n+  ASSERT(uname(&buf) != -1);\n+  ASSERT(strcmp(buffer.sysname, buf.sysname) == 0);\n+  ASSERT(strcmp(buffer.version, buf.version) == 0);\n+\n+# ifdef _AIX\n+  snprintf(temp, sizeof(temp), \"%s.%s\", buf.version, buf.release);\n+  ASSERT(strcmp(buffer.release, temp) == 0);\n+# else\n+  ASSERT(strcmp(buffer.release, buf.release) == 0);\n+# endif /* _AIX */\n+\n+# if defined(_AIX) || defined(__PASE__)\n+  ASSERT(strcmp(buffer.machine, \"ppc64\") == 0);\n+# else\n+  ASSERT(strcmp(buffer.machine, buf.machine) == 0);\n+# endif /* defined(_AIX) || defined(__PASE__) */\n+\n+#endif /* _WIN32 */\n+\n+  return 0;\n+}"
        },
        {
            "sha": "604925861e525aad865737b54ebf45a24fcb7a2a",
            "filename": "deps/uv/test/test.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/f698386c7e988ef45027a75b2ff988899ee2af1d/deps%2Fuv%2Ftest%2Ftest.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest.gyp?ref=f698386c7e988ef45027a75b2ff988899ee2af1d",
            "patch": "@@ -154,6 +154,7 @@\n         'test-udp-multicast-interface.c',\n         'test-udp-multicast-interface6.c',\n         'test-udp-try-send.c',\n+        'test-uname.c',\n       ],\n       'conditions': [\n         [ 'OS==\"win\"', {"
        }
    ],
    "stats": {
        "total": 1139,
        "additions": 779,
        "deletions": 360
    }
}