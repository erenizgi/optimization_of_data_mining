{
    "author": "addaleax",
    "message": "zlib: track memory allocated by zlib\n\nProvide a custom memory allocator for zlib, and track\nmemory allocated by the library with it.\n\nRight now this “only” makes reported external memory\nusage (much) more accurate and protects against zlib\nmemory leaks, but it generally will enable us to give\nmore accurate memory usage statistics for zlib.\n\nPR-URL: https://github.com/nodejs/node/pull/21608\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "ed715ef8900afa5056ebd5ef995e89eebd4987c2",
    "files": [
        {
            "sha": "893209d4d42012af1a262fc522eced1bb05d8b39",
            "filename": "src/node_zlib.cc",
            "status": "modified",
            "additions": 64,
            "deletions": 13,
            "changes": 77,
            "blob_url": "https://github.com/nodejs/node/blob/ed715ef8900afa5056ebd5ef995e89eebd4987c2/src%2Fnode_zlib.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ed715ef8900afa5056ebd5ef995e89eebd4987c2/src%2Fnode_zlib.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_zlib.cc?ref=ed715ef8900afa5056ebd5ef995e89eebd4987c2",
            "patch": "@@ -34,6 +34,7 @@\n #include <stdlib.h>\n #include <string.h>\n #include <sys/types.h>\n+#include <atomic>\n \n namespace node {\n \n@@ -97,6 +98,8 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   ~ZCtx() override {\n     CHECK_EQ(false, write_in_progress_ && \"write in progress\");\n     Close();\n+    CHECK_EQ(zlib_memory_, 0);\n+    CHECK_EQ(unreported_allocations_, 0);\n   }\n \n   void Close() {\n@@ -109,17 +112,15 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     CHECK(init_done_ && \"close before init\");\n     CHECK_LE(mode_, UNZIP);\n \n+    AllocScope alloc_scope(this);\n     int status = Z_OK;\n     if (mode_ == DEFLATE || mode_ == GZIP || mode_ == DEFLATERAW) {\n       status = deflateEnd(&strm_);\n-      int64_t change_in_bytes = -static_cast<int64_t>(kDeflateContextSize);\n-      env()->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);\n     } else if (mode_ == INFLATE || mode_ == GUNZIP || mode_ == INFLATERAW ||\n                mode_ == UNZIP) {\n       status = inflateEnd(&strm_);\n-      int64_t change_in_bytes = -static_cast<int64_t>(kInflateContextSize);\n-      env()->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);\n     }\n+\n     CHECK(status == Z_OK || status == Z_DATA_ERROR);\n     mode_ = NONE;\n \n@@ -165,6 +166,8 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n       CHECK(0 && \"Invalid flush value\");\n     }\n \n+    AllocScope alloc_scope(ctx);\n+\n     Bytef* in;\n     Bytef* out;\n     size_t in_off, in_len, out_off, out_len;\n@@ -355,6 +358,8 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n \n   // v8 land!\n   void AfterThreadPoolWork(int status) override {\n+    AllocScope alloc_scope(this);\n+\n     write_in_progress_ = false;\n \n     if (status == UV_ECANCELED) {\n@@ -505,14 +510,15 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n                    int strategy, uint32_t* write_result,\n                    Local<Function> write_js_callback, char* dictionary,\n                    size_t dictionary_len) {\n+    AllocScope alloc_scope(ctx);\n     ctx->level_ = level;\n     ctx->windowBits_ = windowBits;\n     ctx->memLevel_ = memLevel;\n     ctx->strategy_ = strategy;\n \n-    ctx->strm_.zalloc = Z_NULL;\n-    ctx->strm_.zfree = Z_NULL;\n-    ctx->strm_.opaque = Z_NULL;\n+    ctx->strm_.zalloc = AllocForZlib;\n+    ctx->strm_.zfree = FreeForZlib;\n+    ctx->strm_.opaque = static_cast<void*>(ctx);\n \n     ctx->flush_ = Z_NO_FLUSH;\n \n@@ -540,16 +546,12 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n                                  ctx->windowBits_,\n                                  ctx->memLevel_,\n                                  ctx->strategy_);\n-        ctx->env()->isolate()\n-            ->AdjustAmountOfExternalAllocatedMemory(kDeflateContextSize);\n         break;\n       case INFLATE:\n       case GUNZIP:\n       case INFLATERAW:\n       case UNZIP:\n         ctx->err_ = inflateInit2(&ctx->strm_, ctx->windowBits_);\n-        ctx->env()->isolate()\n-            ->AdjustAmountOfExternalAllocatedMemory(kInflateContextSize);\n         break;\n       default:\n         UNREACHABLE();\n@@ -605,6 +607,8 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   }\n \n   static void Params(ZCtx* ctx, int level, int strategy) {\n+    AllocScope alloc_scope(ctx);\n+\n     ctx->err_ = Z_OK;\n \n     switch (ctx->mode_) {\n@@ -622,6 +626,8 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   }\n \n   void Reset() {\n+    AllocScope alloc_scope(this);\n+\n     err_ = Z_OK;\n \n     switch (mode_) {\n@@ -660,8 +666,51 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     }\n   }\n \n-  static const int kDeflateContextSize = 16384;  // approximate\n-  static const int kInflateContextSize = 10240;  // approximate\n+  // Allocation functions provided to zlib itself. We store the real size of\n+  // the allocated memory chunk just before the \"payload\" memory we return\n+  // to zlib.\n+  // Because we use zlib off the thread pool, we can not report memory directly\n+  // to V8; rather, we first store it as \"unreported\" memory in a separate\n+  // field and later report it back from the main thread.\n+  static void* AllocForZlib(void* data, uInt items, uInt size) {\n+    ZCtx* ctx = static_cast<ZCtx*>(data);\n+    size_t real_size =\n+        MultiplyWithOverflowCheck(static_cast<size_t>(items),\n+                                  static_cast<size_t>(size)) + sizeof(size_t);\n+    char* memory = UncheckedMalloc(real_size);\n+    if (UNLIKELY(memory == nullptr)) return nullptr;\n+    *reinterpret_cast<size_t*>(memory) = real_size;\n+    ctx->unreported_allocations_.fetch_add(real_size,\n+                                           std::memory_order_relaxed);\n+    return memory + sizeof(size_t);\n+  }\n+\n+  static void FreeForZlib(void* data, void* pointer) {\n+    if (UNLIKELY(pointer == nullptr)) return;\n+    ZCtx* ctx = static_cast<ZCtx*>(data);\n+    char* real_pointer = static_cast<char*>(pointer) - sizeof(size_t);\n+    size_t real_size = *reinterpret_cast<size_t*>(real_pointer);\n+    ctx->unreported_allocations_.fetch_sub(real_size,\n+                                           std::memory_order_relaxed);\n+    free(real_pointer);\n+  }\n+\n+  // This is called on the main thread after zlib may have allocated something\n+  // in order to report it back to V8.\n+  void AdjustAmountOfExternalAllocatedMemory() {\n+    ssize_t report =\n+        unreported_allocations_.exchange(0, std::memory_order_relaxed);\n+    if (report == 0) return;\n+    CHECK_IMPLIES(report < 0, zlib_memory_ >= static_cast<size_t>(-report));\n+    zlib_memory_ += report;\n+    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(report);\n+  }\n+\n+  struct AllocScope {\n+    explicit AllocScope(ZCtx* ctx) : ctx(ctx) {}\n+    ~AllocScope() { ctx->AdjustAmountOfExternalAllocatedMemory(); }\n+    ZCtx* ctx;\n+  };\n \n   Bytef* dictionary_;\n   size_t dictionary_len_;\n@@ -680,6 +729,8 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   unsigned int gzip_id_bytes_read_;\n   uint32_t* write_result_;\n   Persistent<Function> write_js_callback_;\n+  std::atomic<ssize_t> unreported_allocations_{0};\n+  size_t zlib_memory_ = 0;\n };\n \n "
        }
    ],
    "stats": {
        "total": 77,
        "additions": 64,
        "deletions": 13
    }
}