{
    "author": "tniessen",
    "message": "crypto: always accept certificates as public keys\n\nPR-URL: https://github.com/nodejs/node/pull/24234\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "8f300bc8a74ba236aa04536d66cfdfa448843012",
    "files": [
        {
            "sha": "fc1e2ae70cad2a49977821dd189f3026c222f0b7",
            "filename": "doc/api/crypto.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8f300bc8a74ba236aa04536d66cfdfa448843012/doc%2Fapi%2Fcrypto.md",
            "raw_url": "https://github.com/nodejs/node/raw/8f300bc8a74ba236aa04536d66cfdfa448843012/doc%2Fapi%2Fcrypto.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fcrypto.md?ref=8f300bc8a74ba236aa04536d66cfdfa448843012",
            "patch": "@@ -1831,6 +1831,8 @@ Creates and returns a new key object containing a public key. If `key` is a\n string or `Buffer`, `format` is assumed to be `'pem'`; otherwise, `key`\n must be an object with the properties described above.\n \n+If the format is `'pem'`, the `'key'` may also be an X.509 certificate.\n+\n ### crypto.createSecretKey(key)\n <!-- YAML\n added: REPLACEME"
        },
        {
            "sha": "3dff06f671756c7883ee454bf6ade356e4968d2d",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 19,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/8f300bc8a74ba236aa04536d66cfdfa448843012/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8f300bc8a74ba236aa04536d66cfdfa448843012/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=8f300bc8a74ba236aa04536d66cfdfa448843012",
            "patch": "@@ -2737,8 +2737,7 @@ static ParsePublicKeyResult TryParsePublicKey(\n \n static ParsePublicKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,\n                                               const char* key_pem,\n-                                              int key_pem_len,\n-                                              bool allow_certificate) {\n+                                              int key_pem_len) {\n   BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n   if (!bp)\n     return ParsePublicKeyResult::kParsePublicFailed;\n@@ -2759,8 +2758,7 @@ static ParsePublicKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,\n       [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n         return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);\n       });\n-  if (ret != ParsePublicKeyResult::kParsePublicNotRecognized ||\n-      !allow_certificate)\n+  if (ret != ParsePublicKeyResult::kParsePublicNotRecognized)\n     return ret;\n \n   // X.509 fallback.\n@@ -2775,11 +2773,10 @@ static ParsePublicKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,\n static bool ParsePublicKey(EVPKeyPointer* pkey,\n                            const PublicKeyEncodingConfig& config,\n                            const char* key,\n-                           size_t key_len,\n-                           bool allow_certificate) {\n+                           size_t key_len) {\n   if (config.format_ == kKeyFormatPEM) {\n     ParsePublicKeyResult r =\n-        ParsePublicKeyPEM(pkey, key, key_len, allow_certificate);\n+        ParsePublicKeyPEM(pkey, key, key_len);\n     return r == ParsePublicKeyResult::kParsePublicOk;\n   } else {\n     CHECK_EQ(config.format_, kKeyFormatDER);\n@@ -3029,15 +3026,14 @@ static PublicKeyEncodingConfig GetPublicKeyEncodingFromJs(\n static ManagedEVPPKey GetPublicKeyFromJs(\n     const FunctionCallbackInfo<Value>& args,\n     unsigned int* offset,\n-    bool allow_key_object,\n-    bool allow_certificate) {\n+    bool allow_key_object) {\n   if (args[*offset]->IsString() || Buffer::HasInstance(args[*offset])) {\n     Environment* env = Environment::GetCurrent(args);\n     ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);\n     PublicKeyEncodingConfig config =\n         GetPublicKeyEncodingFromJs(args, offset, kKeyContextInput);\n     EVPKeyPointer pkey;\n-    ParsePublicKey(&pkey, config, key.get(), key.size(), allow_certificate);\n+    ParsePublicKey(&pkey, config, key.get(), key.size());\n     if (!pkey)\n       ThrowCryptoError(env, ERR_get_error(), \"Failed to read public key\");\n     return ManagedEVPPKey(pkey.release());\n@@ -3158,8 +3154,7 @@ static bool IsRSAPrivateKey(const unsigned char* data, size_t size) {\n static ManagedEVPPKey GetPublicOrPrivateKeyFromJs(\n     const FunctionCallbackInfo<Value>& args,\n     unsigned int* offset,\n-    bool allow_key_object,\n-    bool allow_certificate) {\n+    bool allow_key_object) {\n   if (args[*offset]->IsString() || Buffer::HasInstance(args[*offset])) {\n     Environment* env = Environment::GetCurrent(args);\n     ByteSource data = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);\n@@ -3173,8 +3168,7 @@ static ManagedEVPPKey GetPublicOrPrivateKeyFromJs(\n       // For PEM, we can easily determine whether it is a public or private key\n       // by looking for the respective PEM tags.\n       ParsePublicKeyResult ret = ParsePublicKeyPEM(&pkey, data.get(),\n-                                                   data.size(),\n-                                                   allow_certificate);\n+                                                   data.size());\n       if (ret == ParsePublicKeyResult::kParsePublicNotRecognized) {\n         pkey = ParsePrivateKey(config, data.get(), data.size());\n       }\n@@ -3199,8 +3193,7 @@ static ManagedEVPPKey GetPublicOrPrivateKeyFromJs(\n       }\n \n       if (is_public) {\n-        ParsePublicKey(&pkey, config, data.get(), data.size(),\n-                       allow_certificate);\n+        ParsePublicKey(&pkey, config, data.get(), data.size());\n       } else {\n         pkey = ParsePrivateKey(config, data.get(), data.size());\n       }\n@@ -3413,7 +3406,7 @@ void KeyObject::Init(const FunctionCallbackInfo<Value>& args) {\n     CHECK_EQ(args.Length(), 3);\n \n     offset = 0;\n-    pkey = GetPublicKeyFromJs(args, &offset, false, false);\n+    pkey = GetPublicKeyFromJs(args, &offset, false);\n     if (!pkey)\n       return;\n     key->InitPublic(pkey);\n@@ -4695,7 +4688,7 @@ void Verify::VerifyFinal(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());\n \n   unsigned int offset = 0;\n-  ManagedEVPPKey pkey = GetPublicKeyFromJs(args, &offset, true, true);\n+  ManagedEVPPKey pkey = GetPublicKeyFromJs(args, &offset, true);\n \n   char* hbuf = Buffer::Data(args[offset]);\n   ssize_t hlen = Buffer::Length(args[offset]);\n@@ -4751,7 +4744,7 @@ void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n   unsigned int offset = 0;\n-  ManagedEVPPKey pkey = GetPublicOrPrivateKeyFromJs(args, &offset, true, true);\n+  ManagedEVPPKey pkey = GetPublicOrPrivateKeyFromJs(args, &offset, true);\n   if (!pkey)\n     return;\n "
        }
    ],
    "stats": {
        "total": 33,
        "additions": 14,
        "deletions": 19
    }
}