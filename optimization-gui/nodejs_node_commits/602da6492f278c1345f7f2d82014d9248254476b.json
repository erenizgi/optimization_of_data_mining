{
    "author": "unknown",
    "message": "src: add context-aware init macro and doc\n\nIntroduces macros `NODE_MODULE_INITIALIZER` which expands to the name\nof the special symbol that process.dlopen() will look for to initialize\nan addon, and `NODE_MODULE_INIT()` which creates the boilerplate for\na context-aware module which can be loaded multiple times via the\nspecial symbol mechanism.\n\nAdditionally, provides an example of using the new macro to construct\nan addon which stores per-addon-instance data in a heap-allocated\nstructure that gets passed to each binding, rather than in a collection\nof global static variables.\n\nRe: https://github.com/nodejs/node/issues/21291#issuecomment-396729727\nPR-URL: https://github.com/nodejs/node/pull/21318\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>",
    "sha": "602da6492f278c1345f7f2d82014d9248254476b",
    "files": [
        {
            "sha": "9ea0a6b6446ce457f3db6b6b60032126d590cb14",
            "filename": "doc/api/addons.md",
            "status": "modified",
            "additions": 135,
            "deletions": 0,
            "changes": 135,
            "blob_url": "https://github.com/nodejs/node/blob/602da6492f278c1345f7f2d82014d9248254476b/doc%2Fapi%2Faddons.md",
            "raw_url": "https://github.com/nodejs/node/raw/602da6492f278c1345f7f2d82014d9248254476b/doc%2Fapi%2Faddons.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Faddons.md?ref=602da6492f278c1345f7f2d82014d9248254476b",
            "patch": "@@ -98,6 +98,140 @@ the `.node` suffix).\n In the `hello.cc` example, then, the initialization function is `Initialize`\n and the addon module name is `addon`.\n \n+When building addons with `node-gyp`, using the macro `NODE_GYP_MODULE_NAME` as\n+the first parameter of `NODE_MODULE()` will ensure that the name of the final\n+binary will be passed to `NODE_MODULE()`.\n+\n+### Context-aware addons\n+\n+There are environments in which Node.js addons may need to be loaded multiple\n+times in multiple contexts. For example, the [Electron][] runtime runs multiple\n+instances of Node.js in a single process. Each instance will have its own\n+`require()` cache, and thus each instance will need a native addon to behave\n+correctly when loaded via `require()`. From the addon's perspective, this means\n+that it must support multiple initializations.\n+\n+A context-aware addon can be constructed by using the macro\n+`NODE_MODULE_INITIALIZER`, which expands to the name of a function which Node.js\n+will expect to find when it loads an addon. An addon can thus be initialized as\n+in the following example:\n+\n+```cpp\n+using namespace v8;\n+\n+extern \"C\" NODE_MODULE_EXPORT void\n+NODE_MODULE_INITIALIZER(Local<Object> exports,\n+                        Local<Value> module,\n+                        Local<Context> context) {\n+  /* Perform addon initialization steps here. */\n+}\n+```\n+\n+Another option is to use the macro `NODE_MODULE_INIT()`, which will also\n+construct a context-aware addon. Unlike `NODE_MODULE()`, which is used to\n+construct an addon around a given addon initializer function,\n+`NODE_MODULE_INIT()` serves as the declaration of such an initializer to be\n+followed by a function body.\n+\n+The following three variables may be used inside the function body following an\n+invocation of `NODE_MODULE_INIT()`:\n+* `Local<Object> exports`,\n+* `Local<Value> module`, and\n+* `Local<Context> context`\n+\n+The choice to build a context-aware addon carries with it the responsibility of\n+carefully managing global static data. Since the addon may be loaded multiple\n+times, potentially even from different threads, any global static data stored\n+in the addon must be properly protected, and must not contain any persistent\n+references to JavaScript objects. The reason for this is that JavaScript\n+objects are only valid in one context, and will likely cause a crash when\n+accessed from the wrong context or from a different thread than the one on which\n+they were created.\n+\n+The context-aware addon can be structured to avoid global static data by\n+performing the following steps:\n+* defining a class which will hold per-addon-instance data. Such\n+a class should include a `v8::Persistent<v8::Object>` which will hold a weak\n+reference to the addon's `exports` object. The callback associated with the weak\n+reference will then destroy the instance of the class.\n+* constructing an instance of this class in the addon initializer such that the\n+`v8::Persistent<v8::Object>` is set to the `exports` object.\n+* storing the instance of the class in a `v8::External`, and\n+* passing the `v8::External` to all methods exposed to JavaScript by passing it\n+to the `v8::FunctionTemplate` constructor which creates the native-backed\n+JavaScript functions. The `v8::FunctionTemplate` constructor's third parameter\n+accepts the `v8::External`.\n+\n+This will ensure that the per-addon-instance data reaches each binding that can\n+be called from JavaScript. The per-addon-instance data must also be passed into\n+any asynchronous callbacks the addon may create.\n+\n+The following example illustrates the implementation of a context-aware addon:\n+\n+```cpp\n+#include <node.h>\n+\n+using namespace v8;\n+\n+class AddonData {\n+ public:\n+  AddonData(Isolate* isolate, Local<Object> exports):\n+      call_count(0) {\n+    // Link the existence of this object instance to the existence of exports.\n+    exports_.Reset(isolate, exports);\n+    exports_.SetWeak(this, DeleteMe, WeakCallbackType::kParameter);\n+  }\n+\n+  ~AddonData() {\n+    if (!exports_.IsEmpty()) {\n+      // Reset the reference to avoid leaking data.\n+      exports_.ClearWeak();\n+      exports_.Reset();\n+    }\n+  }\n+\n+  // Per-addon data.\n+  int call_count;\n+\n+ private:\n+  // Method to call when \"exports\" is about to be garbage-collected.\n+  static void DeleteMe(const WeakCallbackInfo<AddonData>& info) {\n+    delete info.GetParameter();\n+  }\n+\n+  // Weak handle to the \"exports\" object. An instance of this class will be\n+  // destroyed along with the exports object to which it is weakly bound.\n+  v8::Persistent<v8::Object> exports_;\n+};\n+\n+static void Method(const v8::FunctionCallbackInfo<v8::Value>& info) {\n+  // Retrieve the per-addon-instance data.\n+  AddonData* data =\n+      reinterpret_cast<AddonData*>(info.Data().As<External>()->Value());\n+  data->call_count++;\n+  info.GetReturnValue().Set((double)data->call_count);\n+}\n+\n+// Initialize this addon to be context-aware.\n+NODE_MODULE_INIT(/* exports, module, context */) {\n+  Isolate* isolate = context->GetIsolate();\n+\n+  // Create a new instance of AddonData for this instance of the addon.\n+  AddonData* data = new AddonData(isolate, exports);\n+  // Wrap the data in a v8::External so we can pass it to the method we expose.\n+  Local<External> external = External::New(isolate, data);\n+\n+  // Expose the method \"Method\" to JavaScript, and make sure it receives the\n+  // per-addon-instance data we created above by passing `external` as the\n+  // third parameter to the FunctionTemplate constructor.\n+  exports->Set(context,\n+               String::NewFromUtf8(isolate, \"method\", NewStringType::kNormal)\n+                  .ToLocalChecked(),\n+               FunctionTemplate::New(isolate, Method, external)\n+                  ->GetFunction(context).ToLocalChecked()).FromJust();\n+}\n+```\n+\n ### Building\n \n Once the source code has been written, it must be compiled into the binary\n@@ -1162,6 +1296,7 @@ Test in JavaScript by running:\n require('./build/Release/addon');\n ```\n \n+[Electron]: https://electronjs.org/\n [Embedder's Guide]: https://github.com/v8/v8/wiki/Embedder's%20Guide\n [Linking to Node.js' own dependencies]: #addons_linking_to_node_js_own_dependencies\n [Native Abstractions for Node.js]: https://github.com/nodejs/nan"
        },
        {
            "sha": "ed2c074b92268758b4f20f274a798d7d5fad2830",
            "filename": "src/node.h",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/602da6492f278c1345f7f2d82014d9248254476b/src%2Fnode.h",
            "raw_url": "https://github.com/nodejs/node/raw/602da6492f278c1345f7f2d82014d9248254476b/src%2Fnode.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.h?ref=602da6492f278c1345f7f2d82014d9248254476b",
            "patch": "@@ -579,6 +579,28 @@ extern \"C\" NODE_EXTERN void node_module_register(void* mod);\n  */\n #define NODE_MODULE_DECL /* nothing */\n \n+#define NODE_MODULE_INITIALIZER_BASE node_register_module_v\n+\n+#define NODE_MODULE_INITIALIZER_X(base, version)                      \\\n+    NODE_MODULE_INITIALIZER_X_HELPER(base, version)\n+\n+#define NODE_MODULE_INITIALIZER_X_HELPER(base, version) base##version\n+\n+#define NODE_MODULE_INITIALIZER                                       \\\n+  NODE_MODULE_INITIALIZER_X(NODE_MODULE_INITIALIZER_BASE,             \\\n+      NODE_MODULE_VERSION)\n+\n+#define NODE_MODULE_INIT()                                            \\\n+  extern \"C\" NODE_MODULE_EXPORT void                                  \\\n+  NODE_MODULE_INITIALIZER(v8::Local<v8::Object> exports,              \\\n+                          v8::Local<v8::Value> module,                \\\n+                          v8::Local<v8::Context> context);            \\\n+  NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME,                     \\\n+                            NODE_MODULE_INITIALIZER)                  \\\n+  void NODE_MODULE_INITIALIZER(v8::Local<v8::Object> exports,         \\\n+                               v8::Local<v8::Value> module,           \\\n+                               v8::Local<v8::Context> context)\n+\n /* Called after the event loop exits but before the VM is disposed.\n  * Callbacks are run in reverse order of registration, i.e. newest first.\n  */"
        },
        {
            "sha": "341b58f9a640d87e28cb7005ea8eadbc437ccbca",
            "filename": "test/addons/hello-world/binding.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/602da6492f278c1345f7f2d82014d9248254476b/test%2Faddons%2Fhello-world%2Fbinding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/602da6492f278c1345f7f2d82014d9248254476b/test%2Faddons%2Fhello-world%2Fbinding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons%2Fhello-world%2Fbinding.cc?ref=602da6492f278c1345f7f2d82014d9248254476b",
            "patch": "@@ -6,13 +6,12 @@ void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {\n   args.GetReturnValue().Set(v8::String::NewFromUtf8(isolate, \"world\"));\n }\n \n-#define CONCAT(a, b) CONCAT_HELPER(a, b)\n-#define CONCAT_HELPER(a, b) a##b\n-#define INITIALIZER CONCAT(node_register_module_v, NODE_MODULE_VERSION)\n-\n-extern \"C\" NODE_MODULE_EXPORT void INITIALIZER(v8::Local<v8::Object> exports,\n-                                               v8::Local<v8::Value> module,\n-                                               v8::Local<v8::Context> context) {\n+// Not using the full NODE_MODULE_INIT() macro here because we want to test the\n+// addon loader's reaction to the FakeInit() entry point below.\n+extern \"C\" NODE_MODULE_EXPORT void\n+NODE_MODULE_INITIALIZER(v8::Local<v8::Object> exports,\n+                        v8::Local<v8::Value> module,\n+                        v8::Local<v8::Context> context) {\n   NODE_SET_METHOD(exports, \"hello\", Method);\n }\n "
        }
    ],
    "stats": {
        "total": 170,
        "additions": 163,
        "deletions": 7
    }
}