{
    "author": "unknown",
    "message": "inspector: add a \"NodeTracing\" domain support\n\nThis change adds a new inspector domain for receiving Node tracing\ndata.\n  1. Node.js now can extend Inspector protocol with new domains with\n     the API defined in the src/inspector/node_protocol.pdl.\n  2. Plumbing code will be generated at the build time. /json/protocol\n     HTTP endpoint returns both V8 and Node.js inspector protocol.\n  3. \"NodeTracing\" domain was introduced. It is based on the Chrome\n     \"Tracing\" domain.\n\nPR-URL: https://github.com/nodejs/node/pull/20608\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "47bdc716f83462b6ab938315d11de6c92be082ac",
    "files": [
        {
            "sha": "ecdb1479568b9342930b98b3f5a64f86ae427ecf",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 165,
            "deletions": 48,
            "changes": 213,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -455,17 +455,24 @@\n             'src/inspector_js_api.cc',\n             'src/inspector_socket.cc',\n             'src/inspector_socket_server.cc',\n+            'src/inspector/tracing_agent.cc',\n+            'src/inspector/node_string.cc',\n             'src/inspector_agent.h',\n             'src/inspector_io.h',\n             'src/inspector_socket.h',\n             'src/inspector_socket_server.h',\n+            'src/inspector/node_string.h',\n+            'src/inspector/tracing_agent.h',\n+            '<@(node_inspector_generated_sources)'\n           ],\n           'dependencies': [\n+            'node_protocol_generated_sources#host',\n             'v8_inspector_compress_protocol_json#host',\n           ],\n           'include_dirs': [\n             '<(SHARED_INTERMEDIATE_DIR)/include', # for inspector\n             '<(SHARED_INTERMEDIATE_DIR)',\n+            '<(SHARED_INTERMEDIATE_DIR)/src', # for inspector\n           ],\n         }, {\n           'defines': [ 'HAVE_INSPECTOR=0' ]\n@@ -677,54 +684,6 @@\n         } ]\n       ]\n     },\n-    {\n-      'target_name': 'v8_inspector_compress_protocol_json',\n-      'type': 'none',\n-      'toolsets': ['host'],\n-      'conditions': [\n-        [ 'v8_enable_inspector==1', {\n-          'copies': [\n-            {\n-              'destination': '<(SHARED_INTERMEDIATE_DIR)',\n-              'files': ['deps/v8/src/inspector/js_protocol.pdl']\n-            }\n-          ],\n-          'actions': [\n-            {\n-              'action_name': 'v8_inspector_convert_protocol_to_json',\n-              'inputs': [\n-                '<(SHARED_INTERMEDIATE_DIR)/js_protocol.pdl',\n-              ],\n-              'outputs': [\n-                '<(SHARED_INTERMEDIATE_DIR)/js_protocol.json',\n-              ],\n-              'action': [\n-                'python',\n-                'deps/v8/third_party/inspector_protocol/ConvertProtocolToJSON.py',\n-                '<@(_inputs)',\n-                '<@(_outputs)',\n-              ],\n-            },\n-            {\n-              'action_name': 'v8_inspector_compress_protocol_json',\n-              'process_outputs_as_sources': 1,\n-              'inputs': [\n-                '<(SHARED_INTERMEDIATE_DIR)/js_protocol.json',\n-              ],\n-              'outputs': [\n-                '<(SHARED_INTERMEDIATE_DIR)/v8_inspector_protocol_json.h',\n-              ],\n-              'action': [\n-                'python',\n-                'tools/compress_json.py',\n-                '<@(_inputs)',\n-                '<@(_outputs)',\n-              ],\n-            },\n-          ],\n-        }],\n-      ],\n-    },\n     {\n       'target_name': 'node_js2c',\n       'type': 'none',\n@@ -1044,5 +1003,163 @@\n         },\n       ]\n     }], # end aix section\n+    [ 'v8_enable_inspector==1', {\n+      'variables': {\n+        'protocol_path': 'deps/v8/third_party/inspector_protocol',\n+        'node_inspector_path': 'src/inspector',\n+        'node_inspector_generated_sources': [\n+          '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/Forward.h',\n+          '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/Protocol.cpp',\n+          '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/Protocol.h',\n+          '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/NodeTracing.cpp',\n+          '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/NodeTracing.h',\n+        ],\n+        'node_protocol_files': [\n+          '<(protocol_path)/lib/Allocator_h.template',\n+          '<(protocol_path)/lib/Array_h.template',\n+          '<(protocol_path)/lib/Collections_h.template',\n+          '<(protocol_path)/lib/DispatcherBase_cpp.template',\n+          '<(protocol_path)/lib/DispatcherBase_h.template',\n+          '<(protocol_path)/lib/ErrorSupport_cpp.template',\n+          '<(protocol_path)/lib/ErrorSupport_h.template',\n+          '<(protocol_path)/lib/Forward_h.template',\n+          '<(protocol_path)/lib/FrontendChannel_h.template',\n+          '<(protocol_path)/lib/Maybe_h.template',\n+          '<(protocol_path)/lib/Object_cpp.template',\n+          '<(protocol_path)/lib/Object_h.template',\n+          '<(protocol_path)/lib/Parser_cpp.template',\n+          '<(protocol_path)/lib/Parser_h.template',\n+          '<(protocol_path)/lib/Protocol_cpp.template',\n+          '<(protocol_path)/lib/ValueConversions_h.template',\n+          '<(protocol_path)/lib/Values_cpp.template',\n+          '<(protocol_path)/lib/Values_h.template',\n+          '<(protocol_path)/templates/Exported_h.template',\n+          '<(protocol_path)/templates/Imported_h.template',\n+          '<(protocol_path)/templates/TypeBuilder_cpp.template',\n+          '<(protocol_path)/templates/TypeBuilder_h.template',\n+          '<(protocol_path)/CodeGenerator.py',\n+        ]\n+      },\n+      'targets': [\n+        {\n+          'target_name': 'prepare_protocol_json',\n+          'type': 'none',\n+          'toolsets': ['host'],\n+          'copies': [\n+            {\n+              'files': [\n+                '<(node_inspector_path)/node_protocol_config.json',\n+                '<(node_inspector_path)/node_protocol.pdl'\n+              ],\n+              'destination': '<(SHARED_INTERMEDIATE_DIR)',\n+            }\n+          ],\n+          'actions': [\n+            {\n+              'action_name': 'convert_node_protocol_to_json',\n+              'inputs': [\n+                '<(SHARED_INTERMEDIATE_DIR)/node_protocol.pdl',\n+              ],\n+              'outputs': [\n+                '<(SHARED_INTERMEDIATE_DIR)/node_protocol.json',\n+              ],\n+              'action': [\n+                'python',\n+                'deps/v8/third_party/inspector_protocol/ConvertProtocolToJSON.py',\n+                '<@(_inputs)',\n+                '<@(_outputs)',\n+              ],\n+            },\n+          ]\n+        },\n+        {\n+          'target_name': 'node_protocol_generated_sources',\n+          'type': 'none',\n+          'toolsets': ['host'],\n+          'dependencies': ['prepare_protocol_json'],\n+          'actions': [\n+            {\n+              'action_name': 'node_protocol_generated_sources',\n+              'inputs': [\n+                '<(SHARED_INTERMEDIATE_DIR)/node_protocol_config.json',\n+                '<(SHARED_INTERMEDIATE_DIR)/node_protocol.json',\n+                '<@(node_protocol_files)',\n+              ],\n+              'outputs': [\n+                '<@(node_inspector_generated_sources)',\n+              ],\n+              'action': [\n+                'python',\n+                '<(protocol_path)/CodeGenerator.py',\n+                '--jinja_dir', '<@(protocol_path)/..',\n+                '--output_base', '<(SHARED_INTERMEDIATE_DIR)/src/',\n+                '--config', '<(SHARED_INTERMEDIATE_DIR)/node_protocol_config.json',\n+              ],\n+              'message': 'Generating node protocol sources from protocol json',\n+            },\n+          ]\n+        },\n+        {\n+          'target_name': 'v8_inspector_compress_protocol_json',\n+          'type': 'none',\n+          'toolsets': ['host'],\n+          'copies': [\n+            {\n+              'destination': '<(SHARED_INTERMEDIATE_DIR)',\n+              'files': ['deps/v8/src/inspector/js_protocol.pdl']\n+            }\n+          ],\n+          'actions': [\n+            {\n+              'action_name': 'v8_inspector_convert_protocol_to_json',\n+              'inputs': [\n+                '<(SHARED_INTERMEDIATE_DIR)/js_protocol.pdl',\n+              ],\n+              'outputs': [\n+                '<(SHARED_INTERMEDIATE_DIR)/js_protocol.json',\n+              ],\n+              'action': [\n+                'python',\n+                'deps/v8/third_party/inspector_protocol/ConvertProtocolToJSON.py',\n+                '<@(_inputs)',\n+                '<@(_outputs)',\n+              ],\n+            },\n+            {\n+              'action_name': 'concatenate_protocols',\n+              'inputs': [\n+                '<(SHARED_INTERMEDIATE_DIR)/js_protocol.json',\n+                '<(SHARED_INTERMEDIATE_DIR)/node_protocol.json',\n+              ],\n+              'outputs': [\n+                '<(SHARED_INTERMEDIATE_DIR)/concatenated_protocol.json',\n+              ],\n+              'action': [\n+                'python',\n+                'deps/v8/third_party/inspector_protocol/ConcatenateProtocols.py',\n+                '<@(_inputs)',\n+                '<@(_outputs)',\n+              ],\n+            },\n+            {\n+              'action_name': 'v8_inspector_compress_protocol_json',\n+              'process_outputs_as_sources': 1,\n+              'inputs': [\n+                '<(SHARED_INTERMEDIATE_DIR)/concatenated_protocol.json',\n+              ],\n+              'outputs': [\n+                '<(SHARED_INTERMEDIATE_DIR)/v8_inspector_protocol_json.h',\n+              ],\n+              'action': [\n+                'python',\n+                'tools/compress_json.py',\n+                '<@(_inputs)',\n+                '<@(_outputs)',\n+              ],\n+            },\n+          ],\n+        },\n+      ]\n+    }]\n   ], # end conditions block\n }"
        },
        {
            "sha": "27b3d814c88d0abd79a3e6194fce8d92766f64e9",
            "filename": "src/inspector/node_protocol.pdl",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Fnode_protocol.pdl",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Fnode_protocol.pdl",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fnode_protocol.pdl?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -0,0 +1,39 @@\n+# Please notify @nodejs/v8-inspector and @nodejs/trace-events before modifying this file\n+version\n+  major 1\n+  minor 0\n+\n+experimental domain NodeTracing\n+  type TraceConfig extends object\n+    properties\n+      # Controls how the trace buffer stores data.\n+      optional enum recordMode\n+        recordUntilFull\n+        recordContinuously\n+        recordAsMuchAsPossible\n+      # Included category filters.\n+      array of string includedCategories\n+\n+  # Gets supported tracing categories.\n+  command getCategories\n+    returns\n+      # A list of supported tracing categories.\n+      array of string categories\n+\n+  # Start trace events collection.\n+  command start\n+    parameters\n+      TraceConfig traceConfig\n+\n+  # Stop trace events collection. Remaining collected events will be sent as a sequence of\n+  # dataCollected events followed by tracingComplete event.\n+  command stop\n+\n+  # Contains an bucket of collected trace events.\n+  event dataCollected\n+    parameters\n+      array of object value\n+\n+  # Signals that tracing is stopped and there is no trace buffers pending flush, all data were\n+  # delivered via dataCollected events.\n+  event tracingComplete"
        },
        {
            "sha": "7cea20ae937616f92032382f7f76893d465575fa",
            "filename": "src/inspector/node_protocol_config.json",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Fnode_protocol_config.json",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Fnode_protocol_config.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fnode_protocol_config.json?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -0,0 +1,27 @@\n+{\n+    \"protocol\": {\n+        \"path\": \"node_protocol.json\",\n+        \"package\": \"src/node/inspector/protocol\",\n+        \"output\": \"node/inspector/protocol\",\n+        \"namespace\": [\"node\", \"inspector\", \"protocol\"],\n+        \"options\": [\n+            {\n+                \"domain\": \"NodeTracing\"\n+            }\n+        ]\n+    },\n+    \"exported\": {\n+        \"package\": \"include/inspector\",\n+        \"output\": \"../../include/inspector\",\n+        \"string_header\": \"v8-inspector.h\",\n+        \"string_in\": \"StringView\",\n+        \"string_out\": \"std::unique_ptr<StringBuffer>\",\n+        \"to_string_out\": \"StringBufferImpl::adopt(%s)\",\n+        \"export_macro\": \"V8_EXPORT\"\n+    },\n+    \"lib\": {\n+        \"package\": \"src/node/inspector/protocol\",\n+        \"output\": \"node/inspector/protocol\",\n+        \"string_header\": \"inspector/node_string.h\"\n+    }\n+}"
        },
        {
            "sha": "cb9e90c20e807a10f7aa2b1b09d78a586822ac32",
            "filename": "src/inspector/node_string.cc",
            "status": "added",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Fnode_string.cc",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Fnode_string.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fnode_string.cc?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -0,0 +1,92 @@\n+#include \"node_string.h\"\n+#include \"node/inspector/protocol/Protocol.h\"\n+\n+#include <unicode/unistr.h>\n+\n+namespace node {\n+namespace inspector {\n+namespace protocol {\n+namespace StringUtil {\n+\n+size_t kNotFound = std::string::npos;\n+\n+// NOLINTNEXTLINE(runtime/references) V8 API requirement\n+void builderAppendQuotedString(StringBuilder& builder, const String& string) {\n+  builder.put('\"');\n+  if (!string.empty()) {\n+    icu::UnicodeString utf16 = icu::UnicodeString::fromUTF8(\n+        icu::StringPiece(string.data(), string.length()));\n+    escapeWideStringForJSON(\n+        reinterpret_cast<const uint16_t*>(utf16.getBuffer()), utf16.length(),\n+        &builder);\n+  }\n+  builder.put('\"');\n+}\n+\n+std::unique_ptr<Value> parseJSON(const String& string) {\n+  if (string.empty())\n+    return nullptr;\n+\n+  icu::UnicodeString utf16 =\n+      icu::UnicodeString::fromUTF8(icu::StringPiece(string.data(),\n+                                                    string.length()));\n+  return parseJSONCharacters(\n+      reinterpret_cast<const uint16_t*>(utf16.getBuffer()), utf16.length());\n+}\n+\n+std::unique_ptr<Value> parseJSON(v8_inspector::StringView string) {\n+  if (string.length() == 0)\n+    return nullptr;\n+  if (string.is8Bit())\n+    return parseJSONCharacters(string.characters8(), string.length());\n+  return parseJSONCharacters(string.characters16(), string.length());\n+}\n+\n+String StringViewToUtf8(v8_inspector::StringView view) {\n+  if (view.length() == 0)\n+    return \"\";\n+  if (view.is8Bit()) {\n+    return std::string(reinterpret_cast<const char*>(view.characters8()),\n+                       view.length());\n+  }\n+  const uint16_t* source = view.characters16();\n+  const UChar* unicodeSource = reinterpret_cast<const UChar*>(source);\n+  static_assert(sizeof(*source) == sizeof(*unicodeSource),\n+                \"sizeof(*source) == sizeof(*unicodeSource)\");\n+\n+  size_t result_length = view.length() * sizeof(*source);\n+  std::string result(result_length, '\\0');\n+  icu::UnicodeString utf16(unicodeSource, view.length());\n+  // ICU components for std::string compatibility are not enabled in build...\n+  bool done = false;\n+  while (!done) {\n+    icu::CheckedArrayByteSink sink(&result[0], result_length);\n+    utf16.toUTF8(sink);\n+    result_length = sink.NumberOfBytesAppended();\n+    result.resize(result_length);\n+    done = !sink.Overflowed();\n+  }\n+  return result;\n+}\n+\n+String fromDouble(double d) {\n+  std::ostringstream stream;\n+  stream.imbue(std::locale(\"C\"));  // Ignore locale\n+  stream << d;\n+  return stream.str();\n+}\n+\n+double toDouble(const char* buffer, size_t length, bool* ok) {\n+  std::istringstream stream(std::string(buffer, length));\n+  stream.imbue(std::locale(\"C\"));  // Ignore locale\n+  double d;\n+  stream >> d;\n+  *ok = !stream.fail();\n+  return d;\n+}\n+\n+}  // namespace StringUtil\n+}  // namespace protocol\n+}  // namespace inspector\n+}  // namespace node\n+"
        },
        {
            "sha": "468aec96b56e799e731718bdf913da9508ad47dd",
            "filename": "src/inspector/node_string.h",
            "status": "added",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Fnode_string.h",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Fnode_string.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fnode_string.h?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -0,0 +1,79 @@\n+// Bridges V8 Inspector generated code with the std::string used by the Node\n+// Compare to V8 counterpart - deps/v8/src/inspector/string-util.h\n+#ifndef SRC_INSPECTOR_NODE_STRING_H_\n+#define SRC_INSPECTOR_NODE_STRING_H_\n+\n+#include \"util.h\"\n+#include \"v8-inspector.h\"\n+\n+#include <cstring>\n+#include <sstream>\n+#include <string>\n+\n+namespace node {\n+namespace inspector {\n+namespace protocol {\n+\n+class Value;\n+\n+using String = std::string;\n+using StringBuilder = std::ostringstream;\n+\n+namespace StringUtil {\n+// NOLINTNEXTLINE(runtime/references) This is V8 API...\n+inline void builderAppend(StringBuilder& builder, char c) {\n+  builder.put(c);\n+}\n+\n+// NOLINTNEXTLINE(runtime/references)\n+inline void builderAppend(StringBuilder& builder, const char* value,\n+                          size_t length) {\n+  builder.write(value, length);\n+}\n+\n+// NOLINTNEXTLINE(runtime/references)\n+inline void builderAppend(StringBuilder& builder, const char* value) {\n+  builderAppend(builder, value, std::strlen(value));\n+}\n+\n+// NOLINTNEXTLINE(runtime/references)\n+inline void builderAppend(StringBuilder& builder, const String& string) {\n+  builder << string;\n+}\n+\n+// NOLINTNEXTLINE(runtime/references)\n+inline void builderReserve(StringBuilder& builder, size_t) {\n+  // ostringstream does not have a counterpart\n+}\n+inline String substring(const String& string, size_t start, size_t count) {\n+  return string.substr(start, count);\n+}\n+inline String fromInteger(int n) {\n+  return std::to_string(n);\n+}\n+inline String builderToString(const StringBuilder& builder) {\n+  return builder.str();\n+}\n+inline size_t find(const String& string, const char* substring) {\n+  return string.find(substring);\n+}\n+String fromDouble(double d);\n+double toDouble(const char* buffer, size_t length, bool* ok);\n+\n+String StringViewToUtf8(v8_inspector::StringView view);\n+\n+// NOLINTNEXTLINE(runtime/references)\n+void builderAppendQuotedString(StringBuilder& builder, const String&);\n+std::unique_ptr<Value> parseJSON(const String&);\n+std::unique_ptr<Value> parseJSON(v8_inspector::StringView view);\n+\n+extern size_t kNotFound;\n+}  // namespace StringUtil\n+}  // namespace protocol\n+}  // namespace inspector\n+}  // namespace node\n+\n+#define DCHECK CHECK\n+#define DCHECK_LT CHECK_LT\n+\n+#endif  // SRC_INSPECTOR_NODE_STRING_H_"
        },
        {
            "sha": "2d98fa1ee527cc881cdd0233e1b650142d0c3e6b",
            "filename": "src/inspector/tracing_agent.cc",
            "status": "added",
            "additions": 106,
            "deletions": 0,
            "changes": 106,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Ftracing_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Ftracing_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Ftracing_agent.cc?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -0,0 +1,106 @@\n+#include \"tracing_agent.h\"\n+\n+#include \"env-inl.h\"\n+#include \"v8.h\"\n+\n+#include <set>\n+#include <sstream>\n+\n+namespace node {\n+namespace inspector {\n+namespace protocol {\n+\n+namespace {\n+using v8::platform::tracing::TraceWriter;\n+\n+class InspectorTraceWriter : public node::tracing::AsyncTraceWriter {\n+ public:\n+  explicit InspectorTraceWriter(NodeTracing::Frontend* frontend)\n+                                : frontend_(frontend) {}\n+\n+  void AppendTraceEvent(\n+      v8::platform::tracing::TraceObject* trace_event) override {\n+    if (!json_writer_)\n+      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_, \"value\"));\n+    json_writer_->AppendTraceEvent(trace_event);\n+  }\n+\n+  void Flush(bool) override {\n+    if (!json_writer_)\n+      return;\n+    json_writer_.reset();\n+    std::ostringstream result(\n+        \"{\\\"method\\\":\\\"NodeTracing.dataCollected\\\",\\\"data\\\":\",\n+        std::ostringstream::ate);\n+    result << stream_.str();\n+    result << \"}\";\n+    frontend_->sendRawNotification(result.str());\n+    stream_.str(\"\");\n+  }\n+\n+ private:\n+  std::unique_ptr<TraceWriter> json_writer_;\n+  std::ostringstream stream_;\n+  NodeTracing::Frontend* frontend_;\n+};\n+}  // namespace\n+\n+TracingAgent::TracingAgent(Environment* env)\n+                           : env_(env),\n+                             trace_writer_(\n+                                  tracing::Agent::EmptyClientHandle()) {\n+}\n+\n+TracingAgent::~TracingAgent() {\n+  trace_writer_.reset();\n+}\n+\n+void TracingAgent::Wire(UberDispatcher* dispatcher) {\n+  frontend_ = std::make_unique<NodeTracing::Frontend>(dispatcher->channel());\n+  NodeTracing::Dispatcher::wire(dispatcher, this);\n+}\n+\n+DispatchResponse TracingAgent::start(\n+    std::unique_ptr<protocol::NodeTracing::TraceConfig> traceConfig) {\n+  if (trace_writer_ != nullptr) {\n+    return DispatchResponse::Error(\n+        \"Call NodeTracing::end to stop tracing before updating the config\");\n+  }\n+\n+  std::set<std::string> categories_set;\n+  protocol::Array<std::string>* categories =\n+      traceConfig->getIncludedCategories();\n+  for (size_t i = 0; i < categories->length(); i++)\n+    categories_set.insert(categories->get(i));\n+\n+  if (categories_set.empty())\n+    return DispatchResponse::Error(\"At least one category should be enabled\");\n+\n+  trace_writer_ = env_->tracing_agent()->AddClient(\n+      categories_set, std::make_unique<InspectorTraceWriter>(frontend_.get()));\n+  return DispatchResponse::OK();\n+}\n+\n+DispatchResponse TracingAgent::stop() {\n+  trace_writer_.reset();\n+  frontend_->tracingComplete();\n+  return DispatchResponse::OK();\n+}\n+\n+DispatchResponse TracingAgent::getCategories(\n+    std::unique_ptr<protocol::Array<String>>* categories) {\n+  *categories = Array<String>::create();\n+  categories->get()->addItem(\"node\");\n+  categories->get()->addItem(\"node.async\");\n+  categories->get()->addItem(\"node.bootstrap\");\n+  categories->get()->addItem(\"node.fs.sync\");\n+  categories->get()->addItem(\"node.perf\");\n+  categories->get()->addItem(\"node.perf.usertiming\");\n+  categories->get()->addItem(\"node.perf.timerify\");\n+  categories->get()->addItem(\"v8\");\n+  return DispatchResponse::OK();\n+}\n+\n+}  // namespace protocol\n+}  // namespace inspector\n+}  // namespace node"
        },
        {
            "sha": "478107c5acdd64fba10899b59b3dba4e4de645bf",
            "filename": "src/inspector/tracing_agent.h",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Ftracing_agent.h",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector%2Ftracing_agent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Ftracing_agent.h?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -0,0 +1,45 @@\n+#ifndef SRC_INSPECTOR_TRACING_AGENT_H_\n+#define SRC_INSPECTOR_TRACING_AGENT_H_\n+\n+#include \"node/inspector/protocol/NodeTracing.h\"\n+#include \"v8.h\"\n+\n+\n+namespace node {\n+class Environment;\n+\n+namespace tracing {\n+class Agent;\n+}  // namespace tracing\n+\n+namespace inspector {\n+namespace protocol {\n+\n+class TracingAgent : public NodeTracing::Backend {\n+ public:\n+  explicit TracingAgent(Environment*);\n+  ~TracingAgent() override;\n+\n+  void Wire(UberDispatcher* dispatcher);\n+\n+  DispatchResponse start(\n+      std::unique_ptr<protocol::NodeTracing::TraceConfig> traceConfig) override;\n+  DispatchResponse stop() override;\n+  DispatchResponse getCategories(\n+      std::unique_ptr<protocol::Array<String>>* categories) override;\n+\n+ private:\n+  void DisconnectTraceClient();\n+\n+  Environment* env_;\n+  std::unique_ptr<std::pair<tracing::Agent*, int>,\n+                  void (*)(std::pair<tracing::Agent*, int>*)> trace_writer_;\n+  std::unique_ptr<NodeTracing::Frontend> frontend_;\n+};\n+\n+\n+}  // namespace protocol\n+}  // namespace inspector\n+}  // namespace node\n+\n+#endif  // SRC_INSPECTOR_TRACING_AGENT_H_"
        },
        {
            "sha": "50aa23b63cd1d09ef1a765244dcb0683e2c7a5f2",
            "filename": "src/inspector_agent.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 6,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.cc?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -1,6 +1,9 @@\n #include \"inspector_agent.h\"\n \n #include \"inspector_io.h\"\n+#include \"inspector/node_string.h\"\n+#include \"inspector/tracing_agent.h\"\n+#include \"node/inspector/protocol/Protocol.h\"\n #include \"node_internals.h\"\n #include \"v8-inspector.h\"\n #include \"v8-platform.h\"\n@@ -187,18 +190,35 @@ static int StartDebugSignalHandler() {\n const int NANOS_PER_MSEC = 1000000;\n const int CONTEXT_GROUP_ID = 1;\n \n-class ChannelImpl final : public v8_inspector::V8Inspector::Channel {\n+class ChannelImpl final : public v8_inspector::V8Inspector::Channel,\n+                          public protocol::FrontendChannel {\n  public:\n-  explicit ChannelImpl(const std::unique_ptr<V8Inspector>& inspector,\n+  explicit ChannelImpl(Environment* env,\n+                       const std::unique_ptr<V8Inspector>& inspector,\n                        std::unique_ptr<InspectorSessionDelegate> delegate)\n                        : delegate_(std::move(delegate)) {\n     session_ = inspector->connect(1, this, StringView());\n+    node_dispatcher_ = std::make_unique<protocol::UberDispatcher>(this);\n+    tracing_agent_ = std::make_unique<protocol::TracingAgent>(env);\n+    tracing_agent_->Wire(node_dispatcher_.get());\n   }\n \n-  virtual ~ChannelImpl() {}\n+  virtual ~ChannelImpl() {\n+    tracing_agent_->disable();\n+    tracing_agent_.reset();  // Dispose before the dispatchers\n+  }\n \n   void dispatchProtocolMessage(const StringView& message) {\n-    session_->dispatchProtocolMessage(message);\n+    std::unique_ptr<protocol::DictionaryValue> parsed;\n+    std::string method;\n+    node_dispatcher_->getCommandName(\n+        protocol::StringUtil::StringViewToUtf8(message), &method, &parsed);\n+    if (v8_inspector::V8InspectorSession::canDispatchMethod(\n+            Utf8ToStringView(method)->string())) {\n+      session_->dispatchProtocolMessage(message);\n+    } else {\n+      node_dispatcher_->dispatch(std::move(parsed));\n+    }\n   }\n \n   void schedulePauseOnNextStatement(const std::string& reason) {\n@@ -224,8 +244,25 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel {\n     delegate_->SendMessageToFrontend(message);\n   }\n \n+  void sendMessageToFrontend(const std::string& message) {\n+    sendMessageToFrontend(Utf8ToStringView(message)->string());\n+  }\n+\n+  using Serializable = protocol::Serializable;\n+\n+  void sendProtocolResponse(int callId,\n+                            std::unique_ptr<Serializable> message) override {\n+    sendMessageToFrontend(message->serialize());\n+  }\n+  void sendProtocolNotification(\n+      std::unique_ptr<Serializable> message) override {\n+    sendMessageToFrontend(message->serialize());\n+  }\n+\n+  std::unique_ptr<protocol::TracingAgent> tracing_agent_;\n   std::unique_ptr<InspectorSessionDelegate> delegate_;\n   std::unique_ptr<v8_inspector::V8InspectorSession> session_;\n+  std::unique_ptr<protocol::UberDispatcher> node_dispatcher_;\n };\n \n class InspectorTimer {\n@@ -369,7 +406,8 @@ class NodeInspectorClient : public V8InspectorClient {\n     int session_id = next_session_id_++;\n     // TODO(addaleax): Revert back to using make_unique once we get issues\n     // with CI resolved (i.e. revert the patch that added this comment).\n-    channels_[session_id].reset(new ChannelImpl(client_, std::move(delegate)));\n+    channels_[session_id].reset(\n+        new ChannelImpl(env_, client_, std::move(delegate)));\n     return session_id;\n   }\n \n@@ -638,7 +676,8 @@ void Agent::DisableAsyncHook() {\n   }\n }\n \n-void Agent::ToggleAsyncHook(Isolate* isolate, const Persistent<Function>& fn) {\n+void Agent::ToggleAsyncHook(Isolate* isolate,\n+                            const node::Persistent<Function>& fn) {\n   HandleScope handle_scope(isolate);\n   CHECK(!fn.IsEmpty());\n   auto context = parent_env_->context();"
        },
        {
            "sha": "21cf4c9f1253dab47d38a2e156e417a6c16e72de",
            "filename": "src/inspector_agent.h",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector_agent.h",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector_agent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.h?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -10,7 +10,7 @@\n #endif\n \n #include \"node_debug_options.h\"\n-#include \"node_platform.h\"\n+#include \"node_persistent.h\"\n #include \"v8.h\"\n \n namespace v8_inspector {\n@@ -20,6 +20,7 @@ class StringView;\n namespace node {\n // Forward declaration to break recursive dependency chain with src/env.h.\n class Environment;\n+class NodePlatform;\n struct ContextInfo;\n \n namespace inspector {\n@@ -102,7 +103,7 @@ class Agent {\n \n  private:\n   void ToggleAsyncHook(v8::Isolate* isolate,\n-                       const Persistent<v8::Function>& fn);\n+                       const node::Persistent<v8::Function>& fn);\n \n   node::Environment* parent_env_;\n   std::shared_ptr<NodeInspectorClient> client_;\n@@ -113,8 +114,8 @@ class Agent {\n \n   bool pending_enable_async_hook_;\n   bool pending_disable_async_hook_;\n-  Persistent<v8::Function> enable_async_hook_function_;\n-  Persistent<v8::Function> disable_async_hook_function_;\n+  node::Persistent<v8::Function> enable_async_hook_function_;\n+  node::Persistent<v8::Function> disable_async_hook_function_;\n };\n \n }  // namespace inspector"
        },
        {
            "sha": "ce18e989737b5acd612f4e57a95bc654dd12e50a",
            "filename": "src/inspector_io.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 26,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector_io.cc",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector_io.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.cc?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -1,6 +1,7 @@\n #include \"inspector_io.h\"\n \n #include \"inspector_socket_server.h\"\n+#include \"inspector/node_string.h\"\n #include \"env-inl.h\"\n #include \"node.h\"\n #include \"node_crypto.h\"\n@@ -62,31 +63,6 @@ std::string GenerateID() {\n   return uuid;\n }\n \n-std::string StringViewToUtf8(const StringView& view) {\n-  if (view.is8Bit()) {\n-    return std::string(reinterpret_cast<const char*>(view.characters8()),\n-                       view.length());\n-  }\n-  const uint16_t* source = view.characters16();\n-  const UChar* unicodeSource = reinterpret_cast<const UChar*>(source);\n-  static_assert(sizeof(*source) == sizeof(*unicodeSource),\n-                \"sizeof(*source) == sizeof(*unicodeSource)\");\n-\n-  size_t result_length = view.length() * sizeof(*source);\n-  std::string result(result_length, '\\0');\n-  icu::UnicodeString utf16(unicodeSource, view.length());\n-  // ICU components for std::string compatibility are not enabled in build...\n-  bool done = false;\n-  while (!done) {\n-    icu::CheckedArrayByteSink sink(&result[0], result_length);\n-    utf16.toUTF8(sink);\n-    result_length = sink.NumberOfBytesAppended();\n-    result.resize(result_length);\n-    done = !sink.Overflowed();\n-  }\n-  return result;\n-}\n-\n void HandleSyncCloseCb(uv_handle_t* handle) {\n   *static_cast<bool*>(handle->data) = true;\n }\n@@ -272,7 +248,8 @@ void InspectorIo::IoThreadAsyncCb(uv_async_t* async) {\n       break;\n     case TransportAction::kSendMessage:\n       transport->Send(session_id,\n-                      StringViewToUtf8(std::get<2>(outgoing)->string()));\n+                      protocol::StringUtil::StringViewToUtf8(\n+                          std::get<2>(outgoing)->string()));\n       break;\n     case TransportAction::kAcceptSession:\n       transport->AcceptSession(session_id);"
        },
        {
            "sha": "05de2d17cd3badf1ab0d6a6c9583010db8f5fb3f",
            "filename": "src/inspector_io.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector_io.h",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Finspector_io.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.h?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -7,7 +7,7 @@\n #include \"uv.h\"\n \n #include <deque>\n-#include <map>\n+#include <unordered_map>\n #include <memory>\n #include <stddef.h>\n "
        },
        {
            "sha": "a3ddfb61a9532820bd6c60f6b61de710046b2519",
            "filename": "src/tracing/agent.cc",
            "status": "modified",
            "additions": 107,
            "deletions": 46,
            "changes": 153,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fagent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fagent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fagent.cc?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -8,11 +8,43 @@\n namespace node {\n namespace tracing {\n \n+namespace {\n+\n+class ScopedSuspendTracing {\n+ public:\n+  ScopedSuspendTracing(TracingController* controller, Agent* agent)\n+                       : controller_(controller), agent_(agent) {\n+    controller->StopTracing();\n+  }\n+\n+  ~ScopedSuspendTracing() {\n+    TraceConfig* config = agent_->CreateTraceConfig();\n+    if (config != nullptr) {\n+      controller_->StartTracing(config);\n+    }\n+  }\n+\n+ private:\n+  TracingController* controller_;\n+  Agent* agent_;\n+};\n+\n+std::set<std::string> flatten(\n+    const std::unordered_map<int, std::set<std::string>>& map) {\n+  std::set<std::string> result;\n+  for (const auto& id_value : map)\n+    result.insert(id_value.second.begin(), id_value.second.end());\n+  return result;\n+}\n+\n+}  // namespace\n+\n using v8::platform::tracing::TraceConfig;\n+using v8::platform::tracing::TraceWriter;\n using std::string;\n \n Agent::Agent(const std::string& log_file_pattern)\n-    : log_file_pattern_(log_file_pattern) {\n+    : log_file_pattern_(log_file_pattern), file_writer_(EmptyClientHandle()) {\n   tracing_controller_ = new TracingController();\n   tracing_controller_->Initialize(nullptr);\n }\n@@ -23,11 +55,9 @@ void Agent::Start() {\n \n   CHECK_EQ(uv_loop_init(&tracing_loop_), 0);\n \n-  NodeTraceWriter* trace_writer =\n-      new NodeTraceWriter(log_file_pattern_, &tracing_loop_);\n-  TraceBuffer* trace_buffer = new NodeTraceBuffer(\n-      NodeTraceBuffer::kBufferChunks, trace_writer, &tracing_loop_);\n-  tracing_controller_->Initialize(trace_buffer);\n+  NodeTraceBuffer* trace_buffer_ = new NodeTraceBuffer(\n+      NodeTraceBuffer::kBufferChunks, this, &tracing_loop_);\n+  tracing_controller_->Initialize(trace_buffer_);\n \n   // This thread should be created *after* async handles are created\n   // (within NodeTraceWriter and NodeTraceBuffer constructors).\n@@ -36,7 +66,23 @@ void Agent::Start() {\n   started_ = true;\n }\n \n+Agent::ClientHandle Agent::AddClient(const std::set<std::string>& categories,\n+                                     std::unique_ptr<AsyncTraceWriter> writer) {\n+  Start();\n+  ScopedSuspendTracing suspend(tracing_controller_, this);\n+  int id = next_writer_id_++;\n+  writers_[id] = std::move(writer);\n+  categories_[id] = categories;\n+\n+  auto client_id = new std::pair<Agent*, int>(this, id);\n+  return ClientHandle(client_id, &DisconnectClient);\n+}\n+\n void Agent::Stop() {\n+  file_writer_.reset();\n+}\n+\n+void Agent::StopTracing() {\n   if (!started_)\n     return;\n   // Perform final Flush on TraceBuffer. We don't want the tracing controller\n@@ -49,79 +95,94 @@ void Agent::Stop() {\n   uv_thread_join(&thread_);\n }\n \n+void Agent::Disconnect(int client) {\n+  ScopedSuspendTracing suspend(tracing_controller_, this);\n+  writers_.erase(client);\n+  categories_.erase(client);\n+}\n+\n // static\n void Agent::ThreadCb(void* arg) {\n   Agent* agent = static_cast<Agent*>(arg);\n   uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);\n }\n \n void Agent::Enable(const std::string& categories) {\n-  if (!categories.empty()) {\n-    std::stringstream category_list(categories);\n-    while (category_list.good()) {\n-      std::string category;\n-      getline(category_list, category, ',');\n-      categories_.insert(category.c_str());\n-    }\n-    RestartTracing();\n+  if (categories.empty())\n+    return;\n+  std::set<std::string> categories_set;\n+  std::stringstream category_list(categories);\n+  while (category_list.good()) {\n+    std::string category;\n+    getline(category_list, category, ',');\n+    categories_set.insert(category);\n   }\n+  Enable(categories_set);\n }\n \n void Agent::Enable(const std::set<std::string>& categories) {\n-  if (!categories.empty()) {\n-    categories_.insert(categories.begin(), categories.end());\n-    RestartTracing();\n-  }\n-}\n+  std::string cats;\n+  for (const std::string cat : categories)\n+    cats += cat + \", \";\n+  if (categories.empty())\n+    return;\n \n-void Agent::Disable(const std::set<std::string>& categories) {\n-  if (!categories.empty()) {\n-    for (auto category : categories) {\n-      auto pos = categories_.lower_bound(category);\n-      if (pos != categories_.end())\n-        categories_.erase(pos);\n-    }\n-    RestartTracing();\n+  file_writer_categories_.insert(categories.begin(), categories.end());\n+  std::set<std::string> full_list(file_writer_categories_.begin(),\n+                                  file_writer_categories_.end());\n+  if (!file_writer_) {\n+    // Ensure background thread is running\n+    Start();\n+    std::unique_ptr<NodeTraceWriter> writer(\n+        new NodeTraceWriter(log_file_pattern_, &tracing_loop_));\n+    file_writer_ = AddClient(full_list, std::move(writer));\n+  } else {\n+    ScopedSuspendTracing suspend(tracing_controller_, this);\n+    categories_[file_writer_->second] = full_list;\n   }\n }\n \n-void Agent::RestartTracing() {\n-  static bool warned;\n-  if (!warned) {\n-    warned = true;\n-    fprintf(stderr, \"Warning: Trace event is an experimental feature \"\n-            \"and could change at any time.\\n\");\n+void Agent::Disable(const std::set<std::string>& categories) {\n+  for (auto category : categories) {\n+    auto it = file_writer_categories_.find(category);\n+    if (it != file_writer_categories_.end())\n+      file_writer_categories_.erase(it);\n   }\n-  Start();  // Start the agent if it hasn't already been started\n-  tracing_controller_->StopTracing();\n-  auto config = CreateTraceConfig();\n-  if (config != nullptr)\n-    tracing_controller_->StartTracing(config);\n+  if (!file_writer_)\n+    return;\n+  ScopedSuspendTracing suspend(tracing_controller_, this);\n+  categories_[file_writer_->second] = { file_writer_categories_.begin(),\n+                                        file_writer_categories_.end() };\n }\n \n TraceConfig* Agent::CreateTraceConfig() {\n   if (categories_.empty())\n     return nullptr;\n   TraceConfig* trace_config = new TraceConfig();\n-  for (auto category = categories_.begin();\n-       category != categories_.end();\n-       category = categories_.upper_bound(*category)) {\n-    trace_config->AddIncludedCategory(category->c_str());\n+  for (const auto& category : flatten(categories_)) {\n+    trace_config->AddIncludedCategory(category.c_str());\n   }\n   return trace_config;\n }\n \n std::string Agent::GetEnabledCategories() {\n   std::string categories;\n-  for (auto category = categories_.begin();\n-       category != categories_.end();\n-       category = categories_.upper_bound(*category)) {\n+  for (const auto& category : flatten(categories_)) {\n     if (!categories.empty())\n       categories += ',';\n-    categories += *category;\n+    categories += category;\n   }\n   return categories;\n }\n \n+void Agent::AppendTraceEvent(TraceObject* trace_event) {\n+  for (const auto& id_writer : writers_)\n+    id_writer.second->AppendTraceEvent(trace_event);\n+}\n+\n+void Agent::Flush(bool blocking) {\n+  for (const auto& id_writer : writers_)\n+    id_writer.second->Flush(blocking);\n+}\n }  // namespace tracing\n }  // namespace node"
        },
        {
            "sha": "fd7984275969baee24527c8bd789bc8019c7c043",
            "filename": "src/tracing/agent.h",
            "status": "modified",
            "additions": 38,
            "deletions": 4,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fagent.h",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fagent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fagent.h?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -7,11 +7,20 @@\n \n #include <set>\n #include <string>\n+#include <unordered_map>\n \n namespace node {\n namespace tracing {\n \n using v8::platform::tracing::TraceConfig;\n+using v8::platform::tracing::TraceObject;\n+\n+class AsyncTraceWriter {\n+ public:\n+  virtual ~AsyncTraceWriter() {}\n+  virtual void AppendTraceEvent(TraceObject* trace_event) = 0;\n+  virtual void Flush(bool blocking) = 0;\n+};\n \n class TracingController : public v8::platform::tracing::TracingController {\n  public:\n@@ -22,33 +31,58 @@ class TracingController : public v8::platform::tracing::TracingController {\n   }\n };\n \n+\n class Agent {\n  public:\n+  // Resetting the pointer disconnects client\n+  using ClientHandle = std::unique_ptr<std::pair<Agent*, int>,\n+                                       void (*)(std::pair<Agent*, int>*)>;\n+\n+  static ClientHandle EmptyClientHandle() {\n+    return ClientHandle(nullptr, DisconnectClient);\n+  }\n   explicit Agent(const std::string& log_file_pattern);\n   void Stop();\n \n   TracingController* GetTracingController() { return tracing_controller_; }\n \n+  // Destroying the handle disconnects the client\n+  ClientHandle AddClient(const std::set<std::string>& categories,\n+                         std::unique_ptr<AsyncTraceWriter> writer);\n+\n+  // These 3 methods operate on a \"default\" client, e.g. the file writer\n   void Enable(const std::string& categories);\n   void Enable(const std::set<std::string>& categories);\n   void Disable(const std::set<std::string>& categories);\n   std::string GetEnabledCategories();\n \n+  void AppendTraceEvent(TraceObject* trace_event);\n+  void Flush(bool blocking);\n+\n+  TraceConfig* CreateTraceConfig();\n+\n  private:\n   static void ThreadCb(void* arg);\n+  static void DisconnectClient(std::pair<Agent*, int>* id_agent) {\n+    id_agent->first->Disconnect(id_agent->second);\n+    delete id_agent;\n+  }\n \n   void Start();\n-  void RestartTracing();\n-\n-  TraceConfig* CreateTraceConfig();\n+  void StopTracing();\n+  void Disconnect(int client);\n \n   const std::string& log_file_pattern_;\n   uv_thread_t thread_;\n   uv_loop_t tracing_loop_;\n   bool started_ = false;\n \n-  std::multiset<std::string> categories_;\n+  std::unordered_map<int, std::set<std::string>> categories_;\n   TracingController* tracing_controller_ = nullptr;\n+  ClientHandle file_writer_;\n+  int next_writer_id_ = 1;\n+  std::unordered_map<int, std::unique_ptr<AsyncTraceWriter>> writers_;\n+  std::multiset<std::string> file_writer_categories_;\n };\n \n }  // namespace tracing"
        },
        {
            "sha": "1765b88df1ea94b85aae6c6e9005c26d9f3a1a63",
            "filename": "src/tracing/node_trace_buffer.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fnode_trace_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fnode_trace_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fnode_trace_buffer.cc?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -4,9 +4,9 @@ namespace node {\n namespace tracing {\n \n InternalTraceBuffer::InternalTraceBuffer(size_t max_chunks, uint32_t id,\n-                                         NodeTraceWriter* trace_writer)\n+                                         Agent* agent)\n     : flushing_(false), max_chunks_(max_chunks),\n-      trace_writer_(trace_writer), id_(id) {\n+      agent_(agent), id_(id) {\n   chunks_.resize(max_chunks);\n }\n \n@@ -59,14 +59,14 @@ void InternalTraceBuffer::Flush(bool blocking) {\n       for (size_t i = 0; i < total_chunks_; ++i) {\n         auto& chunk = chunks_[i];\n         for (size_t j = 0; j < chunk->size(); ++j) {\n-          trace_writer_->AppendTraceEvent(chunk->GetEventAt(j));\n+          agent_->AppendTraceEvent(chunk->GetEventAt(j));\n         }\n       }\n       total_chunks_ = 0;\n       flushing_ = false;\n     }\n   }\n-  trace_writer_->Flush(blocking);\n+  agent_->Flush(blocking);\n }\n \n uint64_t InternalTraceBuffer::MakeHandle(\n@@ -87,10 +87,10 @@ void InternalTraceBuffer::ExtractHandle(\n }\n \n NodeTraceBuffer::NodeTraceBuffer(size_t max_chunks,\n-    NodeTraceWriter* trace_writer, uv_loop_t* tracing_loop)\n-    : tracing_loop_(tracing_loop), trace_writer_(trace_writer),\n-      buffer1_(max_chunks, 0, trace_writer),\n-      buffer2_(max_chunks, 1, trace_writer) {\n+    Agent* agent, uv_loop_t* tracing_loop)\n+    : tracing_loop_(tracing_loop), agent_(agent),\n+      buffer1_(max_chunks, 0, agent),\n+      buffer2_(max_chunks, 1, agent) {\n   current_buf_.store(&buffer1_);\n \n   flush_signal_.data = this;"
        },
        {
            "sha": "f08e6a69da2104c4dd7fb9d9dd9d1dde0b7f3624",
            "filename": "src/tracing/node_trace_buffer.h",
            "status": "modified",
            "additions": 5,
            "deletions": 7,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fnode_trace_buffer.h",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fnode_trace_buffer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fnode_trace_buffer.h?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -1,8 +1,8 @@\n #ifndef SRC_TRACING_NODE_TRACE_BUFFER_H_\n #define SRC_TRACING_NODE_TRACE_BUFFER_H_\n \n+#include \"tracing/agent.h\"\n #include \"node_mutex.h\"\n-#include \"tracing/node_trace_writer.h\"\n #include \"libplatform/v8-tracing.h\"\n \n #include <atomic>\n@@ -19,8 +19,7 @@ class NodeTraceBuffer;\n \n class InternalTraceBuffer {\n  public:\n-  InternalTraceBuffer(size_t max_chunks, uint32_t id,\n-                      NodeTraceWriter* trace_writer);\n+  InternalTraceBuffer(size_t max_chunks, uint32_t id, Agent* agent);\n \n   TraceObject* AddTraceEvent(uint64_t* handle);\n   TraceObject* GetEventByHandle(uint64_t handle);\n@@ -42,7 +41,7 @@ class InternalTraceBuffer {\n   Mutex mutex_;\n   bool flushing_;\n   size_t max_chunks_;\n-  NodeTraceWriter* trace_writer_;\n+  Agent* agent_;\n   std::vector<std::unique_ptr<TraceBufferChunk>> chunks_;\n   size_t total_chunks_ = 0;\n   uint32_t current_chunk_seq_ = 1;\n@@ -51,8 +50,7 @@ class InternalTraceBuffer {\n \n class NodeTraceBuffer : public TraceBuffer {\n  public:\n-  NodeTraceBuffer(size_t max_chunks, NodeTraceWriter* trace_writer,\n-                  uv_loop_t* tracing_loop);\n+  NodeTraceBuffer(size_t max_chunks, Agent* agent, uv_loop_t* tracing_loop);\n   ~NodeTraceBuffer();\n \n   TraceObject* AddTraceEvent(uint64_t* handle) override;\n@@ -74,7 +72,7 @@ class NodeTraceBuffer : public TraceBuffer {\n   Mutex exit_mutex_;\n   // Used to wait until async handles have been closed.\n   ConditionVariable exit_cond_;\n-  std::unique_ptr<NodeTraceWriter> trace_writer_;\n+  Agent* agent_;\n   std::atomic<InternalTraceBuffer*> current_buf_;\n   InternalTraceBuffer buffer1_;\n   InternalTraceBuffer buffer2_;"
        },
        {
            "sha": "88ff3e6e7c159d754346e0e6c1df5df83d96fd25",
            "filename": "src/tracing/node_trace_writer.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fnode_trace_writer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fnode_trace_writer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fnode_trace_writer.cc?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -126,12 +126,6 @@ void NodeTraceWriter::FlushSignalCb(uv_async_t* signal) {\n   trace_writer->FlushPrivate();\n }\n \n-// TODO(matthewloring): Remove (is it necessary to change the API?\n-// Since because of WriteSuffix it no longer matters whether it's true or false)\n-void NodeTraceWriter::Flush() {\n-  Flush(true);\n-}\n-\n void NodeTraceWriter::Flush(bool blocking) {\n   Mutex::ScopedLock scoped_lock(request_mutex_);\n   if (!json_trace_writer_) {"
        },
        {
            "sha": "b2d5e7912fa01d9d59bbb79d8f7b77a4279fafbf",
            "filename": "src/tracing/node_trace_writer.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fnode_trace_writer.h",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/src%2Ftracing%2Fnode_trace_writer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fnode_trace_writer.h?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -6,6 +6,7 @@\n \n #include \"node_mutex.h\"\n #include \"libplatform/v8-tracing.h\"\n+#include \"tracing/agent.h\"\n #include \"uv.h\"\n \n namespace node {\n@@ -14,15 +15,14 @@ namespace tracing {\n using v8::platform::tracing::TraceObject;\n using v8::platform::tracing::TraceWriter;\n \n-class NodeTraceWriter : public TraceWriter {\n+class NodeTraceWriter : public AsyncTraceWriter {\n  public:\n   explicit NodeTraceWriter(const std::string& log_file_pattern,\n                            uv_loop_t* tracing_loop);\n   ~NodeTraceWriter();\n \n   void AppendTraceEvent(TraceObject* trace_event) override;\n-  void Flush() override;\n-  void Flush(bool blocking);\n+  void Flush(bool blocking) override;\n \n   static const int kTracesPerFile = 1 << 19;\n "
        },
        {
            "sha": "c899eeae7139080c81b00f0671c0e8d0ffb83c0f",
            "filename": "test/parallel/test-inspector-multisession-js.js",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/test%2Fparallel%2Ftest-inspector-multisession-js.js",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/test%2Fparallel%2Ftest-inspector-multisession-js.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-inspector-multisession-js.js?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -56,4 +56,8 @@ async function test() {\n \n common.crashOnUnhandledRejection();\n \n-test();\n+const interval = setInterval(() => {}, 1000);\n+test().then(() => {\n+  clearInterval(interval);\n+  console.log('Done!');\n+});"
        },
        {
            "sha": "61a853a265780cc4f87a1fcc336cf40165adda93",
            "filename": "test/parallel/test-inspector-tracing-domain.js",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/nodejs/node/blob/47bdc716f83462b6ab938315d11de6c92be082ac/test%2Fparallel%2Ftest-inspector-tracing-domain.js",
            "raw_url": "https://github.com/nodejs/node/raw/47bdc716f83462b6ab938315d11de6c92be082ac/test%2Fparallel%2Ftest-inspector-tracing-domain.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-inspector-tracing-domain.js?ref=47bdc716f83462b6ab938315d11de6c92be082ac",
            "patch": "@@ -0,0 +1,70 @@\n+'use strict';\n+\n+const common = require('../common');\n+\n+common.skipIfInspectorDisabled();\n+\n+const assert = require('assert');\n+const { Session } = require('inspector');\n+\n+const session = new Session();\n+\n+function compareIgnoringOrder(array1, array2) {\n+  const set = new Set(array1);\n+  const test = set.size === array2.length && array2.every((el) => set.has(el));\n+  assert.ok(test, `[${array1}] differs from [${array2}]`);\n+}\n+\n+function post(message, data) {\n+  return new Promise((resolve, reject) => {\n+    session.post(message, data, (err, result) => {\n+      if (err)\n+        reject(new Error(JSON.stringify(err)));\n+      else\n+        resolve(result);\n+    });\n+  });\n+}\n+\n+function generateTrace() {\n+  return new Promise((resolve) => setTimeout(() => {\n+    for (let i = 0; i << 1000000; i++) {\n+      'test' + i;\n+    }\n+    resolve();\n+  }, 1));\n+}\n+\n+async function test() {\n+  // This interval ensures Node does not terminate till the test is finished.\n+  // Inspector session does not keep the node process running (e.g. it does not\n+  // have async handles on the main event loop). It is debatable whether this\n+  // should be considered a bug, and there are no plans to fix it atm.\n+  const interval = setInterval(() => {}, 5000);\n+  session.connect();\n+  let traceNotification = null;\n+  let tracingComplete = false;\n+  session.on('NodeTracing.dataCollected', (n) => traceNotification = n);\n+  session.on('NodeTracing.tracingComplete', () => tracingComplete = true);\n+  const { categories } = await post('NodeTracing.getCategories');\n+  compareIgnoringOrder(['node', 'node.async', 'node.bootstrap', 'node.fs.sync',\n+                        'node.perf', 'node.perf.usertiming',\n+                        'node.perf.timerify', 'v8'],\n+                       categories);\n+\n+  const traceConfig = { includedCategories: ['node'] };\n+  await post('NodeTracing.start', { traceConfig });\n+\n+  for (let i = 0; i < 5; i++)\n+    await generateTrace();\n+  JSON.stringify(await post('NodeTracing.stop', { traceConfig }));\n+  session.disconnect();\n+  assert(traceNotification.data.value.length > 0);\n+  assert(tracingComplete);\n+  clearInterval(interval);\n+  console.log('Success');\n+}\n+\n+common.crashOnUnhandledRejection();\n+\n+test();"
        }
    ],
    "stats": {
        "total": 1003,
        "additions": 843,
        "deletions": 160
    }
}