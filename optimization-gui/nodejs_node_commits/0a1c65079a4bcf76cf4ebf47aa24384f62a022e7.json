{
    "author": "tniessen",
    "message": "crypto: add support for PEM-level encryption\n\nThis adds support for PEM-level encryption as defined in RFC 1421.\nPEM-level encryption is intentionally unsupported for PKCS#8 private\nkeys since PKCS#8 defines a newer encryption format.\n\nPR-URL: https://github.com/nodejs/node/pull/23151\nRefs: https://github.com/nodejs/node/pull/22660\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "0a1c65079a4bcf76cf4ebf47aa24384f62a022e7",
    "files": [
        {
            "sha": "b3025ee9d9cabad79d43462f391347824198f830",
            "filename": "lib/internal/crypto/keygen.js",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/0a1c65079a4bcf76cf4ebf47aa24384f62a022e7/lib%2Finternal%2Fcrypto%2Fkeygen.js",
            "raw_url": "https://github.com/nodejs/node/raw/0a1c65079a4bcf76cf4ebf47aa24384f62a022e7/lib%2Finternal%2Fcrypto%2Fkeygen.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fkeygen.js?ref=0a1c65079a4bcf76cf4ebf47aa24384f62a022e7",
            "patch": "@@ -140,7 +140,9 @@ function parseKeyEncoding(keyType, options) {\n   if (cipher != null) {\n     if (typeof cipher !== 'string')\n       throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding.cipher', cipher);\n-    if (privateType !== PK_ENCODING_PKCS8) {\n+    if (privateFormat === PK_FORMAT_DER &&\n+        (privateType === PK_ENCODING_PKCS1 ||\n+         privateType === PK_ENCODING_SEC1)) {\n       throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n         strPrivateType, 'does not support encryption');\n     }"
        },
        {
            "sha": "9fdb5fdfcc0ce6e196ec6b3a82bf578f53031df3",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 12,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/0a1c65079a4bcf76cf4ebf47aa24384f62a022e7/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0a1c65079a4bcf76cf4ebf47aa24384f62a022e7/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=0a1c65079a4bcf76cf4ebf47aa24384f62a022e7",
            "patch": "@@ -5060,20 +5060,24 @@ class GenerateKeyPairJob : public CryptoJob {\n \n     // Now do the same for the private key (which is a bit more difficult).\n     if (private_key_encoding_.type_ == PK_ENCODING_PKCS1) {\n-      // PKCS#1 is only permitted for RSA keys and without encryption.\n+      // PKCS#1 is only permitted for RSA keys.\n       CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);\n-      CHECK_NULL(private_key_encoding_.cipher_);\n \n       RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));\n       if (private_key_encoding_.format_ == PK_FORMAT_PEM) {\n         // Encode PKCS#1 as PEM.\n-        if (PEM_write_bio_RSAPrivateKey(bio.get(), rsa.get(),\n-                                        nullptr, nullptr, 0,\n-                                        nullptr, nullptr) != 1)\n+        char* pass = private_key_encoding_.passphrase_.get();\n+        if (PEM_write_bio_RSAPrivateKey(\n+                bio.get(), rsa.get(),\n+                private_key_encoding_.cipher_,\n+                reinterpret_cast<unsigned char*>(pass),\n+                private_key_encoding_.passphrase_length_,\n+                nullptr, nullptr) != 1)\n           return false;\n       } else {\n-        // Encode PKCS#1 as DER.\n+        // Encode PKCS#1 as DER. This does not permit encryption.\n         CHECK_EQ(private_key_encoding_.format_, PK_FORMAT_DER);\n+        CHECK_NULL(private_key_encoding_.cipher_);\n         if (i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1)\n           return false;\n       }\n@@ -5101,20 +5105,24 @@ class GenerateKeyPairJob : public CryptoJob {\n     } else {\n       CHECK_EQ(private_key_encoding_.type_, PK_ENCODING_SEC1);\n \n-      // SEC1 is only permitted for EC keys and without encryption.\n+      // SEC1 is only permitted for EC keys.\n       CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_EC);\n-      CHECK_NULL(private_key_encoding_.cipher_);\n \n       ECKeyPointer ec_key(EVP_PKEY_get1_EC_KEY(pkey));\n       if (private_key_encoding_.format_ == PK_FORMAT_PEM) {\n         // Encode SEC1 as PEM.\n-        if (PEM_write_bio_ECPrivateKey(bio.get(), ec_key.get(),\n-                                       nullptr, nullptr, 0,\n-                                       nullptr, nullptr) != 1)\n+        char* pass = private_key_encoding_.passphrase_.get();\n+        if (PEM_write_bio_ECPrivateKey(\n+                bio.get(), ec_key.get(),\n+                private_key_encoding_.cipher_,\n+                reinterpret_cast<unsigned char*>(pass),\n+                private_key_encoding_.passphrase_length_,\n+                nullptr, nullptr) != 1)\n           return false;\n       } else {\n-        // Encode SEC1 as DER.\n+        // Encode SEC1 as DER. This does not permit encryption.\n         CHECK_EQ(private_key_encoding_.format_, PK_FORMAT_DER);\n+        CHECK_NULL(private_key_encoding_.cipher_);\n         if (i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1)\n           return false;\n       }"
        },
        {
            "sha": "af60c662f9340dc6df60dd6cf46fd81756d97776",
            "filename": "test/parallel/test-crypto-keygen.js",
            "status": "modified",
            "additions": 74,
            "deletions": 4,
            "changes": 78,
            "blob_url": "https://github.com/nodejs/node/blob/0a1c65079a4bcf76cf4ebf47aa24384f62a022e7/test%2Fparallel%2Ftest-crypto-keygen.js",
            "raw_url": "https://github.com/nodejs/node/raw/0a1c65079a4bcf76cf4ebf47aa24384f62a022e7/test%2Fparallel%2Ftest-crypto-keygen.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-keygen.js?ref=0a1c65079a4bcf76cf4ebf47aa24384f62a022e7",
            "patch": "@@ -47,19 +47,23 @@ function testSignVerify(publicKey, privateKey) {\n }\n \n // Constructs a regular expression for a PEM-encoded key with the given label.\n-function getRegExpForPEM(label) {\n+function getRegExpForPEM(label, cipher) {\n   const head = `\\\\-\\\\-\\\\-\\\\-\\\\-BEGIN ${label}\\\\-\\\\-\\\\-\\\\-\\\\-`;\n+  const rfc1421Header = cipher == null ? '' :\n+    `\\nProc-Type: 4,ENCRYPTED\\nDEK-Info: ${cipher},[^\\n]+\\n`;\n   const body = '([a-zA-Z0-9\\\\+/=]{64}\\n)*[a-zA-Z0-9\\\\+/=]{1,64}';\n   const end = `\\\\-\\\\-\\\\-\\\\-\\\\-END ${label}\\\\-\\\\-\\\\-\\\\-\\\\-`;\n-  return new RegExp(`^${head}\\n${body}\\n${end}\\n$`);\n+  return new RegExp(`^${head}${rfc1421Header}\\n${body}\\n${end}\\n$`);\n }\n \n const pkcs1PubExp = getRegExpForPEM('RSA PUBLIC KEY');\n const pkcs1PrivExp = getRegExpForPEM('RSA PRIVATE KEY');\n+const pkcs1EncExp = (cipher) => getRegExpForPEM('RSA PRIVATE KEY', cipher);\n const spkiExp = getRegExpForPEM('PUBLIC KEY');\n const pkcs8Exp = getRegExpForPEM('PRIVATE KEY');\n const pkcs8EncExp = getRegExpForPEM('ENCRYPTED PRIVATE KEY');\n const sec1Exp = getRegExpForPEM('EC PRIVATE KEY');\n+const sec1EncExp = (cipher) => getRegExpForPEM('EC PRIVATE KEY', cipher);\n \n // Since our own APIs only accept PEM, not DER, we need to convert DER to PEM\n // for testing.\n@@ -137,6 +141,42 @@ function convertDERToPEM(label, der) {\n     testEncryptDecrypt(publicKey, privateKey);\n     testSignVerify(publicKey, privateKey);\n   }));\n+\n+  // Now do the same with an encrypted private key.\n+  generateKeyPair('rsa', {\n+    publicExponent: 0x10001,\n+    modulusLength: 4096,\n+    publicKeyEncoding: {\n+      type: 'pkcs1',\n+      format: 'der'\n+    },\n+    privateKeyEncoding: {\n+      type: 'pkcs1',\n+      format: 'pem',\n+      cipher: 'aes-256-cbc',\n+      passphrase: 'secret'\n+    }\n+  }, common.mustCall((err, publicKeyDER, privateKey) => {\n+    assert.ifError(err);\n+\n+    // The public key is encoded as DER (which is binary) instead of PEM. We\n+    // will still need to convert it to PEM for testing.\n+    assert(Buffer.isBuffer(publicKeyDER));\n+    const publicKey = convertDERToPEM('RSA PUBLIC KEY', publicKeyDER);\n+    assertApproximateSize(publicKey, 720);\n+\n+    assert.strictEqual(typeof privateKey, 'string');\n+    assert(pkcs1EncExp('AES-256-CBC').test(privateKey));\n+\n+    // Since the private key is encrypted, signing shouldn't work anymore.\n+    assert.throws(() => {\n+      testSignVerify(publicKey, privateKey);\n+    }, /bad decrypt|asn1 encoding routines/);\n+\n+    const key = { key: privateKey, passphrase: 'secret' };\n+    testEncryptDecrypt(publicKey, key);\n+    testSignVerify(publicKey, key);\n+  }));\n }\n \n {\n@@ -203,6 +243,36 @@ function convertDERToPEM(label, der) {\n \n     testSignVerify(publicKey, privateKey);\n   }));\n+\n+  // Do the same with an encrypted private key.\n+  generateKeyPair('ec', {\n+    namedCurve: 'prime256v1',\n+    paramEncoding: 'named',\n+    publicKeyEncoding: {\n+      type: 'spki',\n+      format: 'pem'\n+    },\n+    privateKeyEncoding: {\n+      type: 'sec1',\n+      format: 'pem',\n+      cipher: 'aes-128-cbc',\n+      passphrase: 'secret'\n+    }\n+  }, common.mustCall((err, publicKey, privateKey) => {\n+    assert.ifError(err);\n+\n+    assert.strictEqual(typeof publicKey, 'string');\n+    assert(spkiExp.test(publicKey));\n+    assert.strictEqual(typeof privateKey, 'string');\n+    assert(sec1EncExp('AES-128-CBC').test(privateKey));\n+\n+    // Since the private key is encrypted, signing shouldn't work anymore.\n+    assert.throws(() => {\n+      testSignVerify(publicKey, privateKey);\n+    }, /bad decrypt|asn1 encoding routines/);\n+\n+    testSignVerify(publicKey, { key: privateKey, passphrase: 'secret' });\n+  }));\n }\n \n {\n@@ -640,7 +710,7 @@ function convertDERToPEM(label, der) {\n     });\n   }\n \n-  // Attempting to encrypt a non-PKCS#8 key.\n+  // Attempting to encrypt a DER-encoded, non-PKCS#8 key.\n   for (const type of ['pkcs1', 'sec1']) {\n     common.expectsError(() => {\n       generateKeyPairSync(type === 'pkcs1' ? 'rsa' : 'ec', {\n@@ -649,7 +719,7 @@ function convertDERToPEM(label, der) {\n         publicKeyEncoding: { type: 'spki', format: 'pem' },\n         privateKeyEncoding: {\n           type,\n-          format: 'pem',\n+          format: 'der',\n           cipher: 'aes-128-cbc',\n           passphrase: 'hello'\n         }"
        }
    ],
    "stats": {
        "total": 114,
        "additions": 97,
        "deletions": 17
    }
}