{
    "author": "Trott",
    "message": "doc: alphabetize tls options\n\nAlphabetize the lists of options for tls.createServer() and\ntls.createSecureContext().\n\nPR-URL: https://github.com/nodejs/node/pull/21139\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>",
    "sha": "25c92a90262e4bdaa97999f5fade56a9551701c9",
    "files": [
        {
            "sha": "9d7130888799275624ec5101705f138c181aa437",
            "filename": "doc/api/tls.md",
            "status": "modified",
            "additions": 53,
            "deletions": 53,
            "changes": 106,
            "blob_url": "https://github.com/nodejs/node/blob/25c92a90262e4bdaa97999f5fade56a9551701c9/doc%2Fapi%2Ftls.md",
            "raw_url": "https://github.com/nodejs/node/raw/25c92a90262e4bdaa97999f5fade56a9551701c9/doc%2Fapi%2Ftls.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ftls.md?ref=25c92a90262e4bdaa97999f5fade56a9551701c9",
            "patch": "@@ -1024,34 +1024,6 @@ changes:\n -->\n \n * `options` {Object}\n-  * `pfx` {string|string[]|Buffer|Buffer[]|Object[]} Optional PFX or PKCS12\n-    encoded private key and certificate chain. `pfx` is an alternative to\n-    providing `key` and `cert` individually. PFX is usually encrypted, if it is,\n-    `passphrase` will be used to decrypt it. Multiple PFX can be provided either\n-    as an array of unencrypted PFX buffers, or an array of objects in the form\n-    `{buf: <string|buffer>[, passphrase: <string>]}`. The object form can only\n-    occur in an array. `object.passphrase` is optional. Encrypted PFX will be\n-    decrypted with `object.passphrase` if provided, or `options.passphrase` if\n-    it is not.\n-  * `key` {string|string[]|Buffer|Buffer[]|Object[]} Optional private keys in\n-    PEM format. PEM allows the option of private keys being encrypted. Encrypted\n-    keys will be decrypted with `options.passphrase`. Multiple keys using\n-    different algorithms can be provided either as an array of unencrypted key\n-    strings or buffers, or an array of objects in the form `{pem:\n-    <string|buffer>[, passphrase: <string>]}`. The object form can only occur in\n-    an array. `object.passphrase` is optional. Encrypted keys will be decrypted\n-    with `object.passphrase` if provided, or `options.passphrase` if it is not.\n-  * `passphrase` {string} Optional shared passphrase used for a single private\n-    key and/or a PFX.\n-  * `cert` {string|string[]|Buffer|Buffer[]} Optional cert chains in PEM format.\n-    One cert chain should be provided per private key. Each cert chain should\n-    consist of the PEM formatted certificate for a provided private `key`,\n-    followed by the PEM formatted intermediate certificates (if any), in order,\n-    and not including the root CA (the root CA must be pre-known to the peer,\n-    see `ca`). When providing multiple cert chains, they do not have to be in\n-    the same order as their private keys in `key`. If the intermediate\n-    certificates are not provided, the peer will not be able to validate the\n-    certificate, and the handshake will fail.\n   * `ca` {string|string[]|Buffer|Buffer[]} Optionally override the trusted CA\n     certificates. Default is to trust the well-known CAs curated by Mozilla.\n     Mozilla's CAs are completely replaced when CAs are explicitly specified\n@@ -1067,19 +1039,17 @@ changes:\n     certificate can match or chain to.\n     For self-signed certificates, the certificate is its own CA, and must be\n     provided.\n+  * `cert` {string|string[]|Buffer|Buffer[]} Optional cert chains in PEM format.\n+    One cert chain should be provided per private key. Each cert chain should\n+    consist of the PEM formatted certificate for a provided private `key`,\n+    followed by the PEM formatted intermediate certificates (if any), in order,\n+    and not including the root CA (the root CA must be pre-known to the peer,\n+    see `ca`). When providing multiple cert chains, they do not have to be in\n+    the same order as their private keys in `key`. If the intermediate\n+    certificates are not provided, the peer will not be able to validate the\n+    certificate, and the handshake will fail.\n   * `ciphers` {string} Optional cipher suite specification, replacing the\n     default. For more information, see [modifying the default cipher suite][].\n-  * `honorCipherOrder` {boolean} Attempt to use the server's cipher suite\n-    preferences instead of the client's. When `true`, causes\n-    `SSL_OP_CIPHER_SERVER_PREFERENCE` to be set in `secureOptions`, see\n-    [OpenSSL Options][] for more information.\n-  * `ecdhCurve` {string} A string describing a named curve or a colon separated\n-    list of curve NIDs or names, for example `P-521:P-384:P-256`, to use for\n-    ECDH key agreement, or `false` to disable ECDH. Set to `auto` to select the\n-    curve automatically. Use [`crypto.getCurves()`][] to obtain a list of\n-    available curve names. On recent releases, `openssl ecparam -list_curves`\n-    will also display the name and description of each available elliptic curve.\n-    **Default:** [`tls.DEFAULT_ECDH_CURVE`].\n   * `clientCertEngine` {string} Optional name of an OpenSSL engine which can\n     provide the client certificate.\n   * `crl` {string|string[]|Buffer|Buffer[]} Optional PEM formatted\n@@ -1090,6 +1060,36 @@ changes:\n     error will be thrown. It is strongly recommended to use 2048 bits or larger\n     for stronger security. If omitted or invalid, the parameters are silently\n     discarded and DHE ciphers will not be available.\n+  * `ecdhCurve` {string} A string describing a named curve or a colon separated\n+    list of curve NIDs or names, for example `P-521:P-384:P-256`, to use for\n+    ECDH key agreement, or `false` to disable ECDH. Set to `auto` to select the\n+    curve automatically. Use [`crypto.getCurves()`][] to obtain a list of\n+    available curve names. On recent releases, `openssl ecparam -list_curves`\n+    will also display the name and description of each available elliptic curve.\n+    **Default:** [`tls.DEFAULT_ECDH_CURVE`].\n+  * `honorCipherOrder` {boolean} Attempt to use the server's cipher suite\n+    preferences instead of the client's. When `true`, causes\n+    `SSL_OP_CIPHER_SERVER_PREFERENCE` to be set in `secureOptions`, see\n+    [OpenSSL Options][] for more information.\n+  * `key` {string|string[]|Buffer|Buffer[]|Object[]} Optional private keys in\n+    PEM format. PEM allows the option of private keys being encrypted. Encrypted\n+    keys will be decrypted with `options.passphrase`. Multiple keys using\n+    different algorithms can be provided either as an array of unencrypted key\n+    strings or buffers, or an array of objects in the form `{pem:\n+    <string|buffer>[, passphrase: <string>]}`. The object form can only occur in\n+    an array. `object.passphrase` is optional. Encrypted keys will be decrypted\n+    with `object.passphrase` if provided, or `options.passphrase` if it is not.\n+  * `passphrase` {string} Optional shared passphrase used for a single private\n+    key and/or a PFX.\n+  * `pfx` {string|string[]|Buffer|Buffer[]|Object[]} Optional PFX or PKCS12\n+    encoded private key and certificate chain. `pfx` is an alternative to\n+    providing `key` and `cert` individually. PFX is usually encrypted, if it is,\n+    `passphrase` will be used to decrypt it. Multiple PFX can be provided either\n+    as an array of unencrypted PFX buffers, or an array of objects in the form\n+    `{buf: <string|buffer>[, passphrase: <string>]}`. The object form can only\n+    occur in an array. `object.passphrase` is optional. Encrypted PFX will be\n+    decrypted with `object.passphrase` if provided, or `options.passphrase` if\n+    it is not.\n   * `secureOptions` {number} Optionally affect the OpenSSL protocol behavior,\n     which is not usually necessary. This should be used carefully if at all!\n     Value is a numeric bitmask of the `SSL_OP_*` options from\n@@ -1133,38 +1133,38 @@ changes:\n -->\n \n * `options` {Object}\n+  * `ALPNProtocols`: {string[]|Buffer[]|Uint8Array[]|Buffer|Uint8Array}\n+    An array of strings, `Buffer`s or `Uint8Array`s, or a single `Buffer` or\n+    `Uint8Array` containing the supported ALPN protocols. `Buffer`s should have\n+    the format `[len][name][len][name]...` e.g. `0x05hello0x05world`, where the\n+    first byte is the length of the next protocol name. Passing an array is\n+    usually much simpler, e.g. `['hello', 'world']`.\n+    (Protocols should be ordered by their priority.)\n   * `clientCertEngine` {string} Optional name of an OpenSSL engine which can\n     provide the client certificate.\n   * `handshakeTimeout` {number} Abort the connection if the SSL/TLS handshake\n     does not finish in the specified number of milliseconds.\n     A `'tlsClientError'` is emitted on the `tls.Server` object whenever\n     a handshake times out. **Default:** `120000` (120 seconds).\n-  * `requestCert` {boolean} If `true` the server will request a certificate from\n-    clients that connect and attempt to verify that certificate. **Default:**\n-    `false`.\n   * `rejectUnauthorized` {boolean} If not `false` the server will reject any\n     connection which is not authorized with the list of supplied CAs. This\n     option only has an effect if `requestCert` is `true`. **Default:** `true`.\n-  * `ALPNProtocols`: {string[]|Buffer[]|Uint8Array[]|Buffer|Uint8Array}\n-    An array of strings, `Buffer`s or `Uint8Array`s, or a single `Buffer` or\n-    `Uint8Array` containing the supported ALPN protocols. `Buffer`s should have\n-    the format `[len][name][len][name]...` e.g. `0x05hello0x05world`, where the\n-    first byte is the length of the next protocol name. Passing an array is\n-    usually much simpler, e.g. `['hello', 'world']`.\n-    (Protocols should be ordered by their priority.)\n+  * `requestCert` {boolean} If `true` the server will request a certificate from\n+    clients that connect and attempt to verify that certificate. **Default:**\n+    `false`.\n+  * `sessionTimeout` {number} An integer specifying the number of seconds after\n+    which the TLS session identifiers and TLS session tickets created by the\n+    server will time out. See [`SSL_CTX_set_timeout`] for more details.\n   * `SNICallback(servername, cb)` {Function} A function that will be called if\n     the client supports SNI TLS extension. Two arguments will be passed when\n     called: `servername` and `cb`. `SNICallback` should invoke `cb(null, ctx)`,\n     where `ctx` is a `SecureContext` instance. (`tls.createSecureContext(...)`\n     can be used to get a proper `SecureContext`.) If `SNICallback` wasn't\n     provided the default callback with high-level API will be used (see below).\n-  * `sessionTimeout` {number} An integer specifying the number of seconds after\n-    which the TLS session identifiers and TLS session tickets created by the\n-    server will time out. See [`SSL_CTX_set_timeout`] for more details.\n   * `ticketKeys`: A 48-byte `Buffer` instance consisting of a 16-byte prefix,\n     a 16-byte HMAC key, and a 16-byte AES key. This can be used to accept TLS\n     session tickets on multiple instances of the TLS server.\n-  * ...: Any [`tls.createSecureContext()`][] options can be provided. For\n+  * ...: Any [`tls.createSecureContext()`][] option can be provided. For\n     servers, the identity options (`pfx` or `key`/`cert`) are usually required.\n * `secureConnectionListener` {Function}\n "
        }
    ],
    "stats": {
        "total": 106,
        "additions": 53,
        "deletions": 53
    }
}