{
    "author": "ryzokuken",
    "message": "test: rename tests with descriptive filenames\n\nRefs: https://github.com/nodejs/node/issues/19105\nRefs: https://github.com/nodejs/node/blob/master/doc/guides/writing-tests.md#test-structure\n\nPR-URL: https://github.com/nodejs/node/pull/19608\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>",
    "sha": "ff7c2ccf230d0fd43402229da38a238ea1ee039f",
    "files": [
        {
            "sha": "bb4e1a0c41166648f6fe6118527ebccee960633a",
            "filename": "test/parallel/test-async-wrap-GH13045.js",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-async-wrap-GH13045.js",
            "raw_url": "https://github.com/nodejs/node/raw/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-async-wrap-GH13045.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-async-wrap-GH13045.js?ref=7e07687230894e2c8d84e91e71251d21609e062e",
            "patch": "@@ -1,55 +0,0 @@\n-'use strict';\n-const common = require('../common');\n-if (!common.hasCrypto)\n-  common.skip('missing crypto');\n-\n-// Refs: https://github.com/nodejs/node/issues/13045\n-// An HTTP Agent reuses a TLSSocket, and makes a failed call to `asyncReset`.\n-\n-const assert = require('assert');\n-const https = require('https');\n-const fixtures = require('../common/fixtures');\n-\n-const serverOptions = {\n-  key: fixtures.readKey('agent1-key.pem'),\n-  cert: fixtures.readKey('agent1-cert.pem'),\n-  ca: fixtures.readKey('ca1-cert.pem')\n-};\n-\n-const server = https.createServer(serverOptions, common.mustCall((req, res) => {\n-  res.end('hello world\\n');\n-}, 2));\n-\n-server.listen(0, common.mustCall(function() {\n-  const port = this.address().port;\n-  const clientOptions = {\n-    agent: new https.Agent({\n-      keepAlive: true,\n-      rejectUnauthorized: false\n-    }),\n-    port: port\n-  };\n-\n-  const req = https.get(clientOptions, common.mustCall((res) => {\n-    assert.strictEqual(res.statusCode, 200);\n-    res.on('error', (err) => assert.fail(err));\n-    res.socket.on('error', (err) => assert.fail(err));\n-    res.resume();\n-    // drain the socket and wait for it to be free to reuse\n-    res.socket.once('free', () => {\n-      // This is the pain point. Internally the Agent will call\n-      // `socket._handle.asyncReset()` and if the _handle does not implement\n-      // `asyncReset` this will throw TypeError\n-      const req2 = https.get(clientOptions, common.mustCall((res2) => {\n-        assert.strictEqual(res.statusCode, 200);\n-        res2.on('error', (err) => assert.fail(err));\n-        res2.socket.on('error', (err) => assert.fail(err));\n-        // this should be the end of the test\n-        res2.destroy();\n-        server.close();\n-      }));\n-      req2.on('error', (err) => assert.fail(err));\n-    });\n-  }));\n-  req.on('error', (err) => assert.fail(err));\n-}));"
        },
        {
            "sha": "37160741fcd8e70a7bd10f64b9ee8391b3aaee8e",
            "filename": "test/parallel/test-async-wrap-tlssocket-asyncreset.js",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/nodejs/node/blob/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-async-wrap-tlssocket-asyncreset.js",
            "raw_url": "https://github.com/nodejs/node/raw/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-async-wrap-tlssocket-asyncreset.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-async-wrap-tlssocket-asyncreset.js?ref=ff7c2ccf230d0fd43402229da38a238ea1ee039f",
            "patch": "@@ -0,0 +1,66 @@\n+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto) common.skip('missing crypto');\n+const fixtures = require('../common/fixtures');\n+\n+// An HTTP Agent reuses a TLSSocket, and makes a failed call to `asyncReset`.\n+// Refs: https://github.com/nodejs/node/issues/13045\n+\n+const assert = require('assert');\n+const https = require('https');\n+\n+const serverOptions = {\n+  key: fixtures.readKey('agent1-key.pem'),\n+  cert: fixtures.readKey('agent1-cert.pem'),\n+  ca: fixtures.readKey('ca1-cert.pem')\n+};\n+\n+const server = https.createServer(\n+  serverOptions,\n+  common.mustCall((req, res) => {\n+    res.end('hello world\\n');\n+  }, 2)\n+);\n+\n+server.listen(\n+  0,\n+  common.mustCall(function() {\n+    const port = this.address().port;\n+    const clientOptions = {\n+      agent: new https.Agent({\n+        keepAlive: true,\n+        rejectUnauthorized: false\n+      }),\n+      port: port\n+    };\n+\n+    const req = https.get(\n+      clientOptions,\n+      common.mustCall((res) => {\n+        assert.strictEqual(res.statusCode, 200);\n+        res.on('error', (err) => assert.fail(err));\n+        res.socket.on('error', (err) => assert.fail(err));\n+        res.resume();\n+        // drain the socket and wait for it to be free to reuse\n+        res.socket.once('free', () => {\n+          // This is the pain point. Internally the Agent will call\n+          // `socket._handle.asyncReset()` and if the _handle does not implement\n+          // `asyncReset` this will throw TypeError\n+          const req2 = https.get(\n+            clientOptions,\n+            common.mustCall((res2) => {\n+              assert.strictEqual(res.statusCode, 200);\n+              res2.on('error', (err) => assert.fail(err));\n+              res2.socket.on('error', (err) => assert.fail(err));\n+              // this should be the end of the test\n+              res2.destroy();\n+              server.close();\n+            })\n+          );\n+          req2.on('error', (err) => assert.fail(err));\n+        });\n+      })\n+    );\n+    req.on('error', (err) => assert.fail(err));\n+  })\n+);"
        },
        {
            "sha": "87b599c7bb29f277ba89be40380d7787d5148fb0",
            "filename": "test/parallel/test-child-process-fork-closed-channel-segfault.js",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/nodejs/node/blob/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-child-process-fork-closed-channel-segfault.js",
            "raw_url": "https://github.com/nodejs/node/raw/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-child-process-fork-closed-channel-segfault.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-child-process-fork-closed-channel-segfault.js?ref=ff7c2ccf230d0fd43402229da38a238ea1ee039f",
            "patch": "@@ -0,0 +1,75 @@\n+'use strict';\n+const common = require('../common');\n+\n+// Before https://github.com/nodejs/node/pull/2847 a child process trying\n+// (asynchronously) to use the closed channel to it's creator caused a segfault.\n+\n+const assert = require('assert');\n+const cluster = require('cluster');\n+const net = require('net');\n+\n+if (!cluster.isMaster) {\n+  // Exit on first received handle to leave the queue non-empty in master\n+  process.on('message', function() {\n+    process.exit(1);\n+  });\n+  return;\n+}\n+\n+const server = net\n+  .createServer(function(s) {\n+    if (common.isWindows) {\n+      s.on('error', function(err) {\n+        // Prevent possible ECONNRESET errors from popping up\n+        if (err.code !== 'ECONNRESET') throw err;\n+      });\n+    }\n+    setTimeout(function() {\n+      s.destroy();\n+    }, 100);\n+  })\n+  .listen(0, function() {\n+    const worker = cluster.fork();\n+\n+    function send(callback) {\n+      const s = net.connect(server.address().port, function() {\n+        worker.send({}, s, callback);\n+      });\n+\n+      // https://github.com/nodejs/node/issues/3635#issuecomment-157714683\n+      // ECONNREFUSED or ECONNRESET errors can happen if this connection is\n+      // still establishing while the server has already closed.\n+      // EMFILE can happen if the worker __and__ the server had already closed.\n+      s.on('error', function(err) {\n+        if (\n+          err.code !== 'ECONNRESET' &&\n+          err.code !== 'ECONNREFUSED' &&\n+          err.code !== 'EMFILE'\n+        ) {\n+          throw err;\n+        }\n+      });\n+    }\n+\n+    worker.process.once(\n+      'close',\n+      common.mustCall(function() {\n+        // Otherwise the crash on `channel.fd` access may happen\n+        assert.strictEqual(worker.process.channel, null);\n+        server.close();\n+      })\n+    );\n+\n+    worker.on('online', function() {\n+      send(function(err) {\n+        assert.ifError(err);\n+        send(function(err) {\n+          // Ignore errors when sending the second handle because the worker\n+          // may already have exited.\n+          if (err && err.message !== 'Channel closed') {\n+            throw err;\n+          }\n+        });\n+      });\n+    });\n+  });"
        },
        {
            "sha": "9e4412d1f7373856441f4a8a2674441857916b04",
            "filename": "test/parallel/test-child-process-fork-regr-gh-2847.js",
            "status": "removed",
            "additions": 0,
            "deletions": 69,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-child-process-fork-regr-gh-2847.js",
            "raw_url": "https://github.com/nodejs/node/raw/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-child-process-fork-regr-gh-2847.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-child-process-fork-regr-gh-2847.js?ref=7e07687230894e2c8d84e91e71251d21609e062e",
            "patch": "@@ -1,69 +0,0 @@\n-// Before https://github.com/nodejs/node/pull/2847 a child process trying\n-// (asynchronously) to use the closed channel to it's creator caused a segfault.\n-'use strict';\n-\n-const common = require('../common');\n-const assert = require('assert');\n-\n-const cluster = require('cluster');\n-const net = require('net');\n-\n-if (!cluster.isMaster) {\n-  // Exit on first received handle to leave the queue non-empty in master\n-  process.on('message', function() {\n-    process.exit(1);\n-  });\n-  return;\n-}\n-\n-const server = net.createServer(function(s) {\n-  if (common.isWindows) {\n-    s.on('error', function(err) {\n-      // Prevent possible ECONNRESET errors from popping up\n-      if (err.code !== 'ECONNRESET')\n-        throw err;\n-    });\n-  }\n-  setTimeout(function() {\n-    s.destroy();\n-  }, 100);\n-}).listen(0, function() {\n-  const worker = cluster.fork();\n-\n-  function send(callback) {\n-    const s = net.connect(server.address().port, function() {\n-      worker.send({}, s, callback);\n-    });\n-\n-    // https://github.com/nodejs/node/issues/3635#issuecomment-157714683\n-    // ECONNREFUSED or ECONNRESET errors can happen if this connection is still\n-    // establishing while the server has already closed.\n-    // EMFILE can happen if the worker __and__ the server had already closed.\n-    s.on('error', function(err) {\n-      if ((err.code !== 'ECONNRESET') &&\n-          (err.code !== 'ECONNREFUSED') &&\n-          (err.code !== 'EMFILE')) {\n-        throw err;\n-      }\n-    });\n-  }\n-\n-  worker.process.once('close', common.mustCall(function() {\n-    // Otherwise the crash on `channel.fd` access may happen\n-    assert.strictEqual(worker.process.channel, null);\n-    server.close();\n-  }));\n-\n-  worker.on('online', function() {\n-    send(function(err) {\n-      assert.ifError(err);\n-      send(function(err) {\n-        // Ignore errors when sending the second handle because the worker\n-        // may already have exited.\n-        if (err && err.message !== 'Channel closed') {\n-          throw err;\n-        }\n-      });\n-    });\n-  });\n-});"
        },
        {
            "sha": "2780d4bdf676add063c2d61bf271e1ab9371e5fc",
            "filename": "test/parallel/test-http-pipeline-assertionerror-finish.js",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-http-pipeline-assertionerror-finish.js",
            "raw_url": "https://github.com/nodejs/node/raw/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-http-pipeline-assertionerror-finish.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-pipeline-assertionerror-finish.js?ref=ff7c2ccf230d0fd43402229da38a238ea1ee039f",
            "patch": "@@ -0,0 +1,34 @@\n+'use strict';\n+const common = require('../common');\n+\n+// This test ensures that Node.js doesn't crash with an AssertionError at\n+// `ServerResponse.resOnFinish` because of an out-of-order 'finish' bug in\n+// pipelining.\n+// https://github.com/nodejs/node/issues/2639\n+\n+const http = require('http');\n+const net = require('net');\n+\n+const COUNT = 10;\n+\n+const server = http\n+  .createServer(\n+    common.mustCall((req, res) => {\n+      // Close the server, we have only one TCP connection anyway\n+      server.close();\n+      res.writeHead(200);\n+      res.write('data');\n+\n+      setTimeout(function() {\n+        res.end();\n+      }, (Math.random() * 100) | 0);\n+    }, COUNT)\n+  )\n+  .listen(0, function() {\n+    const s = net.connect(this.address().port);\n+\n+    const big = 'GET / HTTP/1.0\\r\\n\\r\\n'.repeat(COUNT);\n+\n+    s.write(big);\n+    s.resume();\n+  });"
        },
        {
            "sha": "8eaf5588aaf2bdec55afc1f9940196c8cebdb43b",
            "filename": "test/parallel/test-http-pipeline-regr-2639.js",
            "status": "removed",
            "additions": 0,
            "deletions": 24,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-http-pipeline-regr-2639.js",
            "raw_url": "https://github.com/nodejs/node/raw/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-http-pipeline-regr-2639.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-pipeline-regr-2639.js?ref=7e07687230894e2c8d84e91e71251d21609e062e",
            "patch": "@@ -1,24 +0,0 @@\n-'use strict';\n-const common = require('../common');\n-const http = require('http');\n-const net = require('net');\n-\n-const COUNT = 10;\n-\n-const server = http.createServer(common.mustCall((req, res) => {\n-  // Close the server, we have only one TCP connection anyway\n-  server.close();\n-  res.writeHead(200);\n-  res.write('data');\n-\n-  setTimeout(function() {\n-    res.end();\n-  }, (Math.random() * 100) | 0);\n-}, COUNT)).listen(0, function() {\n-  const s = net.connect(this.address().port);\n-\n-  const big = 'GET / HTTP/1.0\\r\\n\\r\\n'.repeat(COUNT);\n-\n-  s.write(big);\n-  s.resume();\n-});"
        },
        {
            "sha": "c940b8d3841b52892ee6c9086af22301cec40d17",
            "filename": "test/parallel/test-http-pipeline-regr-3332.js",
            "status": "removed",
            "additions": 0,
            "deletions": 27,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-http-pipeline-regr-3332.js",
            "raw_url": "https://github.com/nodejs/node/raw/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-http-pipeline-regr-3332.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-pipeline-regr-3332.js?ref=7e07687230894e2c8d84e91e71251d21609e062e",
            "patch": "@@ -1,27 +0,0 @@\n-'use strict';\n-require('../common');\n-const http = require('http');\n-const net = require('net');\n-const Countdown = require('../common/countdown');\n-\n-const big = Buffer.alloc(16 * 1024, 'A');\n-\n-const COUNT = 1e4;\n-\n-const countdown = new Countdown(COUNT, () => {\n-  server.close();\n-  client.end();\n-});\n-\n-let client;\n-const server = http.createServer(function(req, res) {\n-  res.end(big, function() {\n-    countdown.dec();\n-  });\n-}).listen(0, function() {\n-  const req = 'GET / HTTP/1.1\\r\\n\\r\\n'.repeat(COUNT);\n-  client = net.connect(this.address().port, function() {\n-    client.write(req);\n-  });\n-  client.resume();\n-});"
        },
        {
            "sha": "02c1e1787be6f33256219705e91a18fc480589c1",
            "filename": "test/parallel/test-http-pipeline-regr-3508.js",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-http-pipeline-regr-3508.js",
            "raw_url": "https://github.com/nodejs/node/raw/7e07687230894e2c8d84e91e71251d21609e062e/test%2Fparallel%2Ftest-http-pipeline-regr-3508.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-pipeline-regr-3508.js?ref=7e07687230894e2c8d84e91e71251d21609e062e",
            "patch": "@@ -1,55 +0,0 @@\n-'use strict';\n-require('../common');\n-const http = require('http');\n-const net = require('net');\n-\n-let once = false;\n-let first = null;\n-let second = null;\n-\n-const chunk = Buffer.alloc(1024, 'X');\n-\n-let size = 0;\n-\n-let more;\n-let done;\n-\n-const server = http.createServer(function(req, res) {\n-  if (!once)\n-    server.close();\n-  once = true;\n-\n-  if (first === null) {\n-    first = res;\n-    return;\n-  }\n-  if (second === null) {\n-    second = res;\n-    res.write(chunk);\n-  } else {\n-    res.end(chunk);\n-  }\n-  size += res.outputSize;\n-  if (size <= req.socket.writableHighWaterMark) {\n-    more();\n-    return;\n-  }\n-  done();\n-}).on('upgrade', function(req, socket) {\n-  second.end(chunk, function() {\n-    socket.end();\n-  });\n-  first.end('hello');\n-}).listen(0, function() {\n-  const s = net.connect(this.address().port);\n-  more = function() {\n-    s.write('GET / HTTP/1.1\\r\\n\\r\\n');\n-  };\n-  done = function() {\n-    s.write('GET / HTTP/1.1\\r\\n\\r\\n' +\n-            'GET / HTTP/1.1\\r\\nConnection: upgrade\\r\\nUpgrade: ws\\r\\n\\r\\naaa');\n-  };\n-  more();\n-  more();\n-  s.resume();\n-});"
        },
        {
            "sha": "aa5db56f77862b577219a6394ec01252b54ce9c8",
            "filename": "test/parallel/test-http-pipeline-requests-connection-leak.js",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-http-pipeline-requests-connection-leak.js",
            "raw_url": "https://github.com/nodejs/node/raw/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-http-pipeline-requests-connection-leak.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-pipeline-requests-connection-leak.js?ref=ff7c2ccf230d0fd43402229da38a238ea1ee039f",
            "patch": "@@ -0,0 +1,34 @@\n+'use strict';\n+require('../common');\n+const Countdown = require('../common/countdown');\n+\n+// This test ensures Node.js doesn't behave erratically when receiving pipelined\n+// requests\n+// https://github.com/nodejs/node/issues/3332\n+\n+const http = require('http');\n+const net = require('net');\n+\n+const big = Buffer.alloc(16 * 1024, 'A');\n+\n+const COUNT = 1e4;\n+\n+const countdown = new Countdown(COUNT, () => {\n+  server.close();\n+  client.end();\n+});\n+\n+let client;\n+const server = http\n+  .createServer(function(req, res) {\n+    res.end(big, function() {\n+      countdown.dec();\n+    });\n+  })\n+  .listen(0, function() {\n+    const req = 'GET / HTTP/1.1\\r\\n\\r\\n'.repeat(COUNT);\n+    client = net.connect(this.address().port, function() {\n+      client.write(req);\n+    });\n+    client.resume();\n+  });"
        },
        {
            "sha": "0cb20e761727668da17a00103a720fd154d94f09",
            "filename": "test/parallel/test-http-pipeline-socket-parser-typeerror.js",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-http-pipeline-socket-parser-typeerror.js",
            "raw_url": "https://github.com/nodejs/node/raw/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-http-pipeline-socket-parser-typeerror.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-pipeline-socket-parser-typeerror.js?ref=ff7c2ccf230d0fd43402229da38a238ea1ee039f",
            "patch": "@@ -0,0 +1,64 @@\n+'use strict';\n+require('../common');\n+\n+// This test ensures that Node.js doesn't crash because of a TypeError by\n+// checking in `connectionListener` that the socket still has the parser.\n+// https://github.com/nodejs/node/issues/3508\n+\n+const http = require('http');\n+const net = require('net');\n+\n+let once = false;\n+let first = null;\n+let second = null;\n+\n+const chunk = Buffer.alloc(1024, 'X');\n+\n+let size = 0;\n+\n+let more;\n+let done;\n+\n+const server = http\n+  .createServer(function(req, res) {\n+    if (!once) server.close();\n+    once = true;\n+\n+    if (first === null) {\n+      first = res;\n+      return;\n+    }\n+    if (second === null) {\n+      second = res;\n+      res.write(chunk);\n+    } else {\n+      res.end(chunk);\n+    }\n+    size += res.outputSize;\n+    if (size <= req.socket.writableHighWaterMark) {\n+      more();\n+      return;\n+    }\n+    done();\n+  })\n+  .on('upgrade', function(req, socket) {\n+    second.end(chunk, function() {\n+      socket.end();\n+    });\n+    first.end('hello');\n+  })\n+  .listen(0, function() {\n+    const s = net.connect(this.address().port);\n+    more = function() {\n+      s.write('GET / HTTP/1.1\\r\\n\\r\\n');\n+    };\n+    done = function() {\n+      s.write(\n+        'GET / HTTP/1.1\\r\\n\\r\\n' +\n+          'GET / HTTP/1.1\\r\\nConnection: upgrade\\r\\nUpgrade: ws\\r\\n\\r\\naaa'\n+      );\n+    };\n+    more();\n+    more();\n+    s.resume();\n+  });"
        },
        {
            "sha": "3be100b740417fa977bf180df0543b18579efee9",
            "filename": "test/parallel/test-http-request-large-payload.js",
            "status": "renamed",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-http-request-large-payload.js",
            "raw_url": "https://github.com/nodejs/node/raw/ff7c2ccf230d0fd43402229da38a238ea1ee039f/test%2Fparallel%2Ftest-http-request-large-payload.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-request-large-payload.js?ref=ff7c2ccf230d0fd43402229da38a238ea1ee039f",
            "patch": "@@ -1,5 +1,10 @@\n 'use strict';\n require('../common');\n+\n+// This test ensures Node.js doesn't throw an error when making requests with\n+// the payload 16kb or more in size.\n+// https://github.com/nodejs/node/issues/2821\n+\n const http = require('http');\n \n const server = http.createServer(function(req, res) {\n@@ -10,7 +15,6 @@ const server = http.createServer(function(req, res) {\n });\n \n server.listen(0, function() {\n-\n   const req = http.request({\n     method: 'POST',\n     port: this.address().port",
            "previous_filename": "test/parallel/test-http-regr-gh-2821.js"
        }
    ],
    "stats": {
        "total": 509,
        "additions": 278,
        "deletions": 231
    }
}