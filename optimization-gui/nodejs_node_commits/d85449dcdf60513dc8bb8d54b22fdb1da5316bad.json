{
    "author": "jasnell",
    "message": "trace_events: add traced_value.cc/traced_value.h\n\nPort of the V8 internal v8::tracing::TracedValue that allows\nstructured data to be included in the trace event. The v8 class\nis not exported in the public API so we cannot use it directly.\n\nThis is a simplified and slightly modified port. This commit only\nadds the class, it does not add uses of it. Those will come in\nseparate PRs/commits.\n\nPR-URL: https://github.com/nodejs/node/pull/21475\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "d85449dcdf60513dc8bb8d54b22fdb1da5316bad",
    "files": [
        {
            "sha": "d89296246c3f84f4f95a33b067a1ee2c70c05d5d",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/d85449dcdf60513dc8bb8d54b22fdb1da5316bad/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/d85449dcdf60513dc8bb8d54b22fdb1da5316bad/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=d85449dcdf60513dc8bb8d54b22fdb1da5316bad",
            "patch": "@@ -380,6 +380,7 @@\n         'src/tracing/node_trace_buffer.cc',\n         'src/tracing/node_trace_writer.cc',\n         'src/tracing/trace_event.cc',\n+        'src/tracing/traced_value.cc',\n         'src/tty_wrap.cc',\n         'src/udp_wrap.cc',\n         'src/util.cc',\n@@ -440,6 +441,7 @@\n         'src/tracing/node_trace_buffer.h',\n         'src/tracing/node_trace_writer.h',\n         'src/tracing/trace_event.h',\n+        'src/tracing/traced_value.h',\n         'src/util.h',\n         'src/util-inl.h',\n         'deps/http_parser/http_parser.h',\n@@ -953,6 +955,7 @@\n         'test/cctest/test_node_postmortem_metadata.cc',\n         'test/cctest/test_environment.cc',\n         'test/cctest/test_platform.cc',\n+        'test/cctest/test_traced_value.cc',\n         'test/cctest/test_util.cc',\n         'test/cctest/test_url.cc'\n       ],"
        },
        {
            "sha": "e256df267eb5a9b118e2704f4912cb6b29a46428",
            "filename": "src/tracing/traced_value.cc",
            "status": "added",
            "additions": 224,
            "deletions": 0,
            "changes": 224,
            "blob_url": "https://github.com/nodejs/node/blob/d85449dcdf60513dc8bb8d54b22fdb1da5316bad/src%2Ftracing%2Ftraced_value.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d85449dcdf60513dc8bb8d54b22fdb1da5316bad/src%2Ftracing%2Ftraced_value.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Ftraced_value.cc?ref=d85449dcdf60513dc8bb8d54b22fdb1da5316bad",
            "patch": "@@ -0,0 +1,224 @@\n+// Copyright 2016 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \"tracing/traced_value.h\"\n+\n+#include <math.h>\n+#include <sstream>\n+#include <stdio.h>\n+#include <string>\n+\n+#if defined(NODE_HAVE_I18N_SUPPORT)\n+#include <unicode/utf8.h>\n+#include <unicode/utypes.h>\n+#endif\n+\n+#if defined(_STLP_VENDOR_CSTD)\n+// STLPort doesn't import fpclassify into the std namespace.\n+#define FPCLASSIFY_NAMESPACE\n+#else\n+#define FPCLASSIFY_NAMESPACE std\n+#endif\n+\n+namespace node {\n+namespace tracing {\n+\n+namespace {\n+\n+std::string EscapeString(const char* value) {\n+  std::string result;\n+  result += '\"';\n+  char number_buffer[10];\n+#if defined(NODE_HAVE_I18N_SUPPORT)\n+  int32_t len = strlen(value);\n+  int32_t p = 0;\n+  int32_t i = 0;\n+  for (; i < len; p = i) {\n+    UChar32 c;\n+    U8_NEXT_OR_FFFD(value, i, len, c);\n+    switch (c) {\n+      case '\\b': result += \"\\\\b\"; break;\n+      case '\\f': result += \"\\\\f\"; break;\n+      case '\\n': result += \"\\\\n\"; break;\n+      case '\\r': result += \"\\\\r\"; break;\n+      case '\\t': result += \"\\\\t\"; break;\n+      case '\\\\': result += \"\\\\\\\\\"; break;\n+      case '\"': result += \"\\\\\\\"\"; break;\n+      default:\n+        if (c < 32 || c > 126) {\n+          snprintf(\n+              number_buffer, arraysize(number_buffer), \"\\\\u%04X\",\n+              static_cast<uint16_t>(static_cast<uint16_t>(c)));\n+          result += number_buffer;\n+        } else {\n+          result.append(value + p, i - p);\n+        }\n+    }\n+  }\n+#else\n+  // If we do not have ICU, use a modified version of the non-UTF8 aware\n+  // code from V8's own TracedValue implementation. Note, however, This\n+  // will not produce correctly serialized results for UTF8 values.\n+  while (*value) {\n+    char c = *value++;\n+    switch (c) {\n+      case '\\b': result += \"\\\\b\"; break;\n+      case '\\f': result += \"\\\\f\"; break;\n+      case '\\n': result += \"\\\\n\"; break;\n+      case '\\r': result += \"\\\\r\"; break;\n+      case '\\t': result += \"\\\\t\"; break;\n+      case '\\\\': result += \"\\\\\\\\\"; break;\n+      case '\"': result += \"\\\\\\\"\"; break;\n+      default:\n+        if (c < '\\x20') {\n+          snprintf(\n+              number_buffer, arraysize(number_buffer), \"\\\\u%04X\",\n+              static_cast<unsigned>(static_cast<unsigned char>(c)));\n+          result += number_buffer;\n+        } else {\n+          result += c;\n+        }\n+    }\n+  }\n+#endif  // defined(NODE_HAVE_I18N_SUPPORT)\n+  result += '\"';\n+  return result;\n+}\n+\n+std::string DoubleToCString(double v) {\n+  switch (FPCLASSIFY_NAMESPACE::fpclassify(v)) {\n+    case FP_NAN: return \"\\\"NaN\\\"\";\n+    case FP_INFINITE: return (v < 0.0 ? \"\\\"-Infinity\\\"\" : \"\\\"Infinity\\\"\");\n+    case FP_ZERO: return \"0\";\n+    default:\n+      // This is a far less sophisticated version than the one used inside v8.\n+      std::ostringstream stream;\n+      stream.imbue(std::locale(\"C\"));  // Ignore locale\n+      stream << v;\n+      return stream.str();\n+  }\n+}\n+\n+}  // namespace\n+\n+std::unique_ptr<TracedValue> TracedValue::Create() {\n+  return std::unique_ptr<TracedValue>(new TracedValue(false));\n+}\n+\n+std::unique_ptr<TracedValue> TracedValue::CreateArray() {\n+  return std::unique_ptr<TracedValue>(new TracedValue(true));\n+}\n+\n+TracedValue::TracedValue(bool root_is_array) :\n+    first_item_(true), root_is_array_(root_is_array) {}\n+\n+TracedValue::~TracedValue() {}\n+\n+void TracedValue::SetInteger(const char* name, int value) {\n+  WriteName(name);\n+  data_ += std::to_string(value);\n+}\n+\n+void TracedValue::SetDouble(const char* name, double value) {\n+  WriteName(name);\n+  data_ += DoubleToCString(value);\n+}\n+\n+void TracedValue::SetBoolean(const char* name, bool value) {\n+  WriteName(name);\n+  data_ += value ? \"true\" : \"false\";\n+}\n+\n+void TracedValue::SetNull(const char* name) {\n+  WriteName(name);\n+  data_ += \"null\";\n+}\n+\n+void TracedValue::SetString(const char* name, const char* value) {\n+  WriteName(name);\n+  data_ += EscapeString(value);\n+}\n+\n+void TracedValue::BeginDictionary(const char* name) {\n+  WriteName(name);\n+  data_ += '{';\n+  first_item_ = true;\n+}\n+\n+void TracedValue::BeginArray(const char* name) {\n+  WriteName(name);\n+  data_ += '[';\n+  first_item_ = true;\n+}\n+\n+void TracedValue::AppendInteger(int value) {\n+  WriteComma();\n+  data_ += std::to_string(value);\n+}\n+\n+void TracedValue::AppendDouble(double value) {\n+  WriteComma();\n+  data_ += DoubleToCString(value);\n+}\n+\n+void TracedValue::AppendBoolean(bool value) {\n+  WriteComma();\n+  data_ += value ? \"true\" : \"false\";\n+}\n+\n+void TracedValue::AppendNull() {\n+  WriteComma();\n+  data_ += \"null\";\n+}\n+\n+void TracedValue::AppendString(const char* value) {\n+  WriteComma();\n+  data_ += EscapeString(value);\n+}\n+\n+void TracedValue::BeginDictionary() {\n+  WriteComma();\n+  data_ += '{';\n+  first_item_ = true;\n+}\n+\n+void TracedValue::BeginArray() {\n+  WriteComma();\n+  data_ += '[';\n+  first_item_ = true;\n+}\n+\n+void TracedValue::EndDictionary() {\n+  data_ += '}';\n+  first_item_ = false;\n+}\n+\n+void TracedValue::EndArray() {\n+  data_ += ']';\n+  first_item_ = false;\n+}\n+\n+void TracedValue::WriteComma() {\n+  if (first_item_) {\n+    first_item_ = false;\n+  } else {\n+    data_ += ',';\n+  }\n+}\n+\n+void TracedValue::WriteName(const char* name) {\n+  WriteComma();\n+  data_ += '\"';\n+  data_ += name;\n+  data_ += \"\\\":\";\n+}\n+\n+void TracedValue::AppendAsTraceFormat(std::string* out) const {\n+  *out += root_is_array_ ? '[' : '{';\n+  *out += data_;\n+  *out += root_is_array_ ? ']' : '}';\n+}\n+\n+}  // namespace tracing\n+}  // namespace node"
        },
        {
            "sha": "84e24c952528f55593fdead9b351ca32e1a8931c",
            "filename": "src/tracing/traced_value.h",
            "status": "added",
            "additions": 68,
            "deletions": 0,
            "changes": 68,
            "blob_url": "https://github.com/nodejs/node/blob/d85449dcdf60513dc8bb8d54b22fdb1da5316bad/src%2Ftracing%2Ftraced_value.h",
            "raw_url": "https://github.com/nodejs/node/raw/d85449dcdf60513dc8bb8d54b22fdb1da5316bad/src%2Ftracing%2Ftraced_value.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Ftraced_value.h?ref=d85449dcdf60513dc8bb8d54b22fdb1da5316bad",
            "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2016 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef SRC_TRACING_TRACED_VALUE_H_\n+#define SRC_TRACING_TRACED_VALUE_H_\n+\n+#include \"node_internals.h\"\n+#include \"v8.h\"\n+\n+#include <stddef.h>\n+#include <memory>\n+#include <string>\n+\n+namespace node {\n+namespace tracing {\n+\n+class TracedValue : public v8::ConvertableToTraceFormat {\n+ public:\n+  ~TracedValue() override;\n+\n+  static std::unique_ptr<TracedValue> Create();\n+  static std::unique_ptr<TracedValue> CreateArray();\n+\n+  void EndDictionary();\n+  void EndArray();\n+\n+  // These methods assume that |name| is a long lived \"quoted\" string.\n+  void SetInteger(const char* name, int value);\n+  void SetDouble(const char* name, double value);\n+  void SetBoolean(const char* name, bool value);\n+  void SetNull(const char* name);\n+  void SetString(const char* name, const char* value);\n+  void SetString(const char* name, const std::string& value) {\n+    SetString(name, value.c_str());\n+  }\n+  void BeginDictionary(const char* name);\n+  void BeginArray(const char* name);\n+\n+  void AppendInteger(int);\n+  void AppendDouble(double);\n+  void AppendBoolean(bool);\n+  void AppendNull();\n+  void AppendString(const char*);\n+  void AppendString(const std::string& value) { AppendString(value.c_str()); }\n+  void BeginArray();\n+  void BeginDictionary();\n+\n+  // ConvertableToTraceFormat implementation.\n+  void AppendAsTraceFormat(std::string* out) const override;\n+\n+ private:\n+  explicit TracedValue(bool root_is_array = false);\n+\n+  void WriteComma();\n+  void WriteName(const char* name);\n+\n+  std::string data_;\n+  bool first_item_;\n+  bool root_is_array_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(TracedValue);\n+};\n+\n+}  // namespace tracing\n+}  // namespace node\n+\n+#endif  // SRC_TRACING_TRACED_VALUE_H_"
        },
        {
            "sha": "5329c78446ca6ff310c5a0c9a1fd840d9086e104",
            "filename": "test/cctest/test_traced_value.cc",
            "status": "added",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/nodejs/node/blob/d85449dcdf60513dc8bb8d54b22fdb1da5316bad/test%2Fcctest%2Ftest_traced_value.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d85449dcdf60513dc8bb8d54b22fdb1da5316bad/test%2Fcctest%2Ftest_traced_value.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcctest%2Ftest_traced_value.cc?ref=d85449dcdf60513dc8bb8d54b22fdb1da5316bad",
            "patch": "@@ -0,0 +1,96 @@\n+#include \"tracing/traced_value.h\"\n+\n+#include <math.h>\n+#include <stddef.h>\n+#include <string.h>\n+\n+#include \"gtest/gtest.h\"\n+\n+using node::tracing::TracedValue;\n+\n+TEST(TracedValue, Object) {\n+  auto traced_value = TracedValue::Create();\n+  traced_value->SetString(\"a\", \"b\");\n+  traced_value->SetInteger(\"b\", 1);\n+  traced_value->SetDouble(\"c\", 1.234);\n+  traced_value->SetDouble(\"d\", NAN);\n+  traced_value->SetDouble(\"e\", INFINITY);\n+  traced_value->SetDouble(\"f\", -INFINITY);\n+  traced_value->SetDouble(\"g\", 1.23e7);\n+  traced_value->SetBoolean(\"h\", false);\n+  traced_value->SetBoolean(\"i\", true);\n+  traced_value->SetNull(\"j\");\n+  traced_value->BeginDictionary(\"k\");\n+  traced_value->SetString(\"l\", \"m\");\n+  traced_value->EndDictionary();\n+\n+  std::string string;\n+  traced_value->AppendAsTraceFormat(&string);\n+\n+  static const char* check = \"{\\\"a\\\":\\\"b\\\",\\\"b\\\":1,\\\"c\\\":1.234,\\\"d\\\":\\\"NaN\\\",\"\n+                             \"\\\"e\\\":\\\"Infinity\\\",\\\"f\\\":\\\"-Infinity\\\",\\\"g\\\":\"\n+                             \"1.23e+07,\\\"h\\\":false,\\\"i\\\":true,\\\"j\\\":null,\\\"k\\\":\"\n+                             \"{\\\"l\\\":\\\"m\\\"}}\";\n+\n+  EXPECT_EQ(check, string);\n+}\n+\n+TEST(TracedValue, Array) {\n+  auto traced_value = TracedValue::CreateArray();\n+  traced_value->AppendString(\"a\");\n+  traced_value->AppendInteger(1);\n+  traced_value->AppendDouble(1.234);\n+  traced_value->AppendDouble(NAN);\n+  traced_value->AppendDouble(INFINITY);\n+  traced_value->AppendDouble(-INFINITY);\n+  traced_value->AppendDouble(1.23e7);\n+  traced_value->AppendBoolean(false);\n+  traced_value->AppendBoolean(true);\n+  traced_value->AppendNull();\n+  traced_value->BeginDictionary();\n+  traced_value->BeginArray(\"foo\");\n+  traced_value->EndArray();\n+  traced_value->EndDictionary();\n+\n+  std::string string;\n+  traced_value->AppendAsTraceFormat(&string);\n+\n+  static const char* check = \"[\\\"a\\\",1,1.234,\\\"NaN\\\",\\\"Infinity\\\",\"\n+                             \"\\\"-Infinity\\\",1.23e+07,false,true,null,\"\n+                             \"{\\\"foo\\\":[]}]\";\n+\n+  EXPECT_EQ(check, string);\n+}\n+\n+#define UTF8_SEQUENCE \"1\" \"\\xE2\\x82\\xAC\" \"23\\\"\\x01\\b\\f\\n\\r\\t\\\\\"\n+#if defined(NODE_HAVE_I18N_SUPPORT)\n+# define UTF8_RESULT                                                          \\\n+  \"\\\"1\\\\u20AC23\\\\\\\"\\\\u0001\\\\b\\\\f\\\\n\\\\r\\\\t\\\\\\\\\\\"\"\n+#else\n+# define UTF8_RESULT                                                          \\\n+  \"\\\"1\\\\u00E2\\\\u0082\\\\u00AC23\\\\\\\"\\\\u0001\\\\b\\\\f\\\\n\\\\r\\\\t\\\\\\\\\\\"\"\n+#endif\n+\n+TEST(TracedValue, EscapingObject) {\n+  auto traced_value = TracedValue::Create();\n+  traced_value->SetString(\"a\", UTF8_SEQUENCE);\n+\n+  std::string string;\n+  traced_value->AppendAsTraceFormat(&string);\n+\n+  static const char* check = \"{\\\"a\\\":\" UTF8_RESULT \"}\";\n+\n+  EXPECT_EQ(check, string);\n+}\n+\n+TEST(TracedValue, EscapingArray) {\n+  auto traced_value = TracedValue::CreateArray();\n+  traced_value->AppendString(UTF8_SEQUENCE);\n+\n+  std::string string;\n+  traced_value->AppendAsTraceFormat(&string);\n+\n+  static const char* check = \"[\" UTF8_RESULT \"]\";\n+\n+  EXPECT_EQ(check, string);\n+}"
        }
    ],
    "stats": {
        "total": 391,
        "additions": 391,
        "deletions": 0
    }
}