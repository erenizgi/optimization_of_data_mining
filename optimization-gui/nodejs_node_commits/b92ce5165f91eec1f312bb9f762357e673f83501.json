{
    "author": "jasnell",
    "message": "http2: add origin frame support\n\nPR-URL: https://github.com/nodejs/node/pull/22956\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "b92ce5165f91eec1f312bb9f762357e673f83501",
    "files": [
        {
            "sha": "139bc9a825280d6583d82e74ec5c1fd2a2950967",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/b92ce5165f91eec1f312bb9f762357e673f83501/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/b92ce5165f91eec1f312bb9f762357e673f83501/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=b92ce5165f91eec1f312bb9f762357e673f83501",
            "patch": "@@ -925,6 +925,11 @@ An invalid HTTP/2 header value was specified.\n An invalid HTTP informational status code has been specified. Informational\n status codes must be an integer between `100` and `199` (inclusive).\n \n+<a id=\"ERR_HTTP2_INVALID_ORIGIN\"></a>\n+### ERR_HTTP2_INVALID_ORIGIN\n+\n+HTTP/2 `ORIGIN` frames require a valid origin.\n+\n <a id=\"ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH\"></a>\n ### ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH\n \n@@ -975,6 +980,11 @@ Nested push streams are not permitted.\n An attempt was made to directly manipulate (read, write, pause, resume, etc.) a\n socket attached to an `Http2Session`.\n \n+<a id=\"ERR_HTTP2_ORIGIN_LENGTH\"></a>\n+### ERR_HTTP2_ORIGIN_LENGTH\n+\n+HTTP/2 `ORIGIN` frames are limited to a length of 16382 bytes.\n+\n <a id=\"ERR_HTTP2_OUT_OF_STREAMS\"></a>\n ### ERR_HTTP2_OUT_OF_STREAMS\n "
        },
        {
            "sha": "205c0dc85b8102e246eec1d5bbd8622abed1a330",
            "filename": "doc/api/http2.md",
            "status": "modified",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/b92ce5165f91eec1f312bb9f762357e673f83501/doc%2Fapi%2Fhttp2.md",
            "raw_url": "https://github.com/nodejs/node/raw/b92ce5165f91eec1f312bb9f762357e673f83501/doc%2Fapi%2Fhttp2.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fhttp2.md?ref=b92ce5165f91eec1f312bb9f762357e673f83501",
            "patch": "@@ -432,6 +432,8 @@ If the `Http2Session` is connected to a `TLSSocket`, the `originSet` property\n will return an `Array` of origins for which the `Http2Session` may be\n considered authoritative.\n \n+The `originSet` property is only available when using a secure TLS connection.\n+\n #### http2session.pendingSettingsAck\n <!-- YAML\n added: v8.4.0\n@@ -670,6 +672,56 @@ The protocol identifier (`'h2'` in the examples) may be any valid\n The syntax of these values is not validated by the Node.js implementation and\n are passed through as provided by the user or received from the peer.\n \n+#### serverhttp2session.origin(...origins)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `origins` { string | URL | Object } One or more URL Strings passed as\n+  separate arguments.\n+\n+Submits an `ORIGIN` frame (as defined by [RFC 8336][]) to the connected client\n+to advertise the set of origins for which the server is capable of providing\n+authoritative responses.\n+\n+```js\n+const http2 = require('http2');\n+const options = getSecureOptionsSomehow();\n+const server = http2.createSecureServer(options);\n+server.on('stream', (stream) => {\n+  stream.respond();\n+  stream.end('ok');\n+});\n+server.on('session', (session) => {\n+  session.origin('https://example.com', 'https://example.org');\n+});\n+```\n+\n+When a string is passed as an `origin`, it will be parsed as a URL and the\n+origin will be derived. For instance, the origin for the HTTP URL\n+`'https://example.org/foo/bar'` is the ASCII string\n+`'https://example.org'`. An error will be thrown if either the given string\n+cannot be parsed as a URL or if a valid origin cannot be derived.\n+\n+A `URL` object, or any object with an `origin` property, may be passed as\n+an `origin`, in which case the value of the `origin` property will be\n+used. The value of the `origin` property *must* be a properly serialized\n+ASCII origin.\n+\n+Alternatively, the `origins` option may be used when creating a new HTTP/2\n+server using the `http2.createSecureServer()` method:\n+\n+```js\n+const http2 = require('http2');\n+const options = getSecureOptionsSomehow();\n+options.origins = ['https://example.com', 'https://example.org'];\n+const server = http2.createSecureServer(options);\n+server.on('stream', (stream) => {\n+  stream.respond();\n+  stream.end('ok');\n+});\n+```\n+\n ### Class: ClientHttp2Session\n <!-- YAML\n added: v8.4.0\n@@ -700,6 +752,30 @@ client.on('altsvc', (alt, origin, streamId) => {\n });\n ```\n \n+#### Event: 'origin'\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `origins` {string[]}\n+\n+The `'origin'`  event is emitted whenever an `ORIGIN` frame is received by\n+the client. The event is emitted with an array of `origin` strings. The\n+`http2session.originSet` will be updated to include the received\n+origins.\n+\n+```js\n+const http2 = require('http2');\n+const client = http2.connect('https://example.org');\n+\n+client.on('origin', (origins) => {\n+  for (let n = 0; n < origins.length; n++)\n+    console.log(origins[n]);\n+});\n+```\n+\n+The `'origin'` event is only emitted when using a secure TLS connection.\n+\n #### clienthttp2session.request(headers[, options])\n <!-- YAML\n added: v8.4.0\n@@ -1914,6 +1990,10 @@ server.listen(80);\n <!-- YAML\n added: v8.4.0\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/22956\n+    description: Added the `origins` option to automatically send an `ORIGIN`\n+                 frame on `Http2Session` startup.\n   - version: v8.9.3\n     pr-url: https://github.com/nodejs/node/pull/17105\n     description: Added the `maxOutstandingPings` option with a default limit of\n@@ -1977,6 +2057,8 @@ changes:\n     remote peer upon connection.\n   * ...: Any [`tls.createServer()`][] options can be provided. For\n     servers, the identity options (`pfx` or `key`/`cert`) are usually required.\n+  * `origins` {string[]} An array of origin strings to send within an `ORIGIN`\n+    frame immediately following creation of a new server `Http2Session`.\n * `onRequestHandler` {Function} See [Compatibility API][]\n * Returns: {Http2SecureServer}\n \n@@ -3268,6 +3350,7 @@ following additional properties:\n [Performance Observer]: perf_hooks.html\n [Readable Stream]: stream.html#stream_class_stream_readable\n [RFC 7838]: https://tools.ietf.org/html/rfc7838\n+[RFC 8336]: https://tools.ietf.org/html/rfc8336\n [Using `options.selectPadding()`]: #http2_using_options_selectpadding\n [`'checkContinue'`]: #http2_event_checkcontinue\n [`'request'`]: #http2_event_request"
        },
        {
            "sha": "e3c5a2b0b68559741a66ab4255c6524af9236b02",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/b92ce5165f91eec1f312bb9f762357e673f83501/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/b92ce5165f91eec1f312bb9f762357e673f83501/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=b92ce5165f91eec1f312bb9f762357e673f83501",
            "patch": "@@ -567,6 +567,8 @@ E('ERR_HTTP2_INVALID_HEADER_VALUE',\n   'Invalid value \"%s\" for header \"%s\"', TypeError);\n E('ERR_HTTP2_INVALID_INFO_STATUS',\n   'Invalid informational status code: %s', RangeError);\n+E('ERR_HTTP2_INVALID_ORIGIN',\n+  'HTTP/2 ORIGIN frames require a valid origin', TypeError);\n E('ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH',\n   'Packed settings length must be a multiple of six', RangeError);\n E('ERR_HTTP2_INVALID_PSEUDOHEADER',\n@@ -582,6 +584,8 @@ E('ERR_HTTP2_NESTED_PUSH',\n E('ERR_HTTP2_NO_SOCKET_MANIPULATION',\n   'HTTP/2 sockets should not be directly manipulated (e.g. read and written)',\n   Error);\n+E('ERR_HTTP2_ORIGIN_LENGTH',\n+  'HTTP/2 ORIGIN frames are limited to 16382 bytes', TypeError);\n E('ERR_HTTP2_OUT_OF_STREAMS',\n   'No stream ID is available because maximum stream ID has been reached',\n   Error);"
        },
        {
            "sha": "96ca97f8933119588e25d003b3e59347583a974e",
            "filename": "lib/internal/http2/core.js",
            "status": "modified",
            "additions": 86,
            "deletions": 17,
            "changes": 103,
            "blob_url": "https://github.com/nodejs/node/blob/b92ce5165f91eec1f312bb9f762357e673f83501/lib%2Finternal%2Fhttp2%2Fcore.js",
            "raw_url": "https://github.com/nodejs/node/raw/b92ce5165f91eec1f312bb9f762357e673f83501/lib%2Finternal%2Fhttp2%2Fcore.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fhttp2%2Fcore.js?ref=b92ce5165f91eec1f312bb9f762357e673f83501",
            "patch": "@@ -43,13 +43,15 @@ const {\n     ERR_HTTP2_HEADERS_AFTER_RESPOND,\n     ERR_HTTP2_HEADERS_SENT,\n     ERR_HTTP2_INVALID_INFO_STATUS,\n+    ERR_HTTP2_INVALID_ORIGIN,\n     ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH,\n     ERR_HTTP2_INVALID_SESSION,\n     ERR_HTTP2_INVALID_SETTING_VALUE,\n     ERR_HTTP2_INVALID_STREAM,\n     ERR_HTTP2_MAX_PENDING_SETTINGS_ACK,\n     ERR_HTTP2_NESTED_PUSH,\n     ERR_HTTP2_NO_SOCKET_MANIPULATION,\n+    ERR_HTTP2_ORIGIN_LENGTH,\n     ERR_HTTP2_OUT_OF_STREAMS,\n     ERR_HTTP2_PAYLOAD_FORBIDDEN,\n     ERR_HTTP2_PING_CANCEL,\n@@ -148,6 +150,7 @@ const kInfoHeaders = Symbol('sent-info-headers');\n const kLocalSettings = Symbol('local-settings');\n const kOptions = Symbol('options');\n const kOwner = owner_symbol;\n+const kOrigin = Symbol('origin');\n const kProceed = Symbol('proceed');\n const kProtocol = Symbol('protocol');\n const kProxySocket = Symbol('proxy-socket');\n@@ -209,6 +212,7 @@ const {\n   HTTP_STATUS_NO_CONTENT,\n   HTTP_STATUS_NOT_MODIFIED,\n   HTTP_STATUS_SWITCHING_PROTOCOLS,\n+  HTTP_STATUS_MISDIRECTED_REQUEST,\n \n   STREAM_OPTION_EMPTY_PAYLOAD,\n   STREAM_OPTION_GET_TRAILERS\n@@ -299,6 +303,11 @@ function onSessionHeaders(handle, id, cat, flags, headers) {\n     } else {\n       event = endOfStream ? 'trailers' : 'headers';\n     }\n+    const session = stream.session;\n+    if (status === HTTP_STATUS_MISDIRECTED_REQUEST) {\n+      const originSet = session[kState].originSet = initOriginSet(session);\n+      originSet.delete(stream[kOrigin]);\n+    }\n     debug(`Http2Stream ${id} [Http2Session ` +\n           `${sessionName(type)}]: emitting stream '${event}' event`);\n     process.nextTick(emit, stream, event, obj, flags, headers);\n@@ -429,6 +438,39 @@ function onAltSvc(stream, origin, alt) {\n   session.emit('altsvc', alt, origin, stream);\n }\n \n+function initOriginSet(session) {\n+  let originSet = session[kState].originSet;\n+  if (originSet === undefined) {\n+    const socket = session[kSocket];\n+    session[kState].originSet = originSet = new Set();\n+    if (socket.servername != null) {\n+      let originString = `https://${socket.servername}`;\n+      if (socket.remotePort != null)\n+        originString += `:${socket.remotePort}`;\n+      // We have to ensure that it is a properly serialized\n+      // ASCII origin string. The socket.servername might not\n+      // be properly ASCII encoded.\n+      originSet.add((new URL(originString)).origin);\n+    }\n+  }\n+  return originSet;\n+}\n+\n+function onOrigin(origins) {\n+  const session = this[kOwner];\n+  if (session.destroyed)\n+    return;\n+  debug(`Http2Session ${sessionName(session[kType])}: origin received: ` +\n+        `${origins.join(', ')}`);\n+  session[kUpdateTimer]();\n+  if (!session.encrypted || session.destroyed)\n+    return undefined;\n+  const originSet = initOriginSet(session);\n+  for (var n = 0; n < origins.length; n++)\n+    originSet.add(origins[n]);\n+  session.emit('origin', origins);\n+}\n+\n // Receiving a GOAWAY frame from the connected peer is a signal that no\n // new streams should be created. If the code === NGHTTP2_NO_ERROR, we\n // are going to send our close, but allow existing frames to close\n@@ -782,6 +824,7 @@ function setupHandle(socket, type, options) {\n   handle.onframeerror = onFrameError;\n   handle.ongoawaydata = onGoawayData;\n   handle.onaltsvc = onAltSvc;\n+  handle.onorigin = onOrigin;\n \n   if (typeof options.selectPadding === 'function')\n     handle.ongetpadding = onSelectPadding(options.selectPadding);\n@@ -808,6 +851,12 @@ function setupHandle(socket, type, options) {\n     options.settings : {};\n \n   this.settings(settings);\n+\n+  if (type === NGHTTP2_SESSION_SERVER &&\n+      Array.isArray(options.origins)) {\n+    this.origin(...options.origins);\n+  }\n+\n   process.nextTick(emit, this, 'connect', this, socket);\n }\n \n@@ -947,23 +996,7 @@ class Http2Session extends EventEmitter {\n   get originSet() {\n     if (!this.encrypted || this.destroyed)\n       return undefined;\n-\n-    let originSet = this[kState].originSet;\n-    if (originSet === undefined) {\n-      const socket = this[kSocket];\n-      this[kState].originSet = originSet = new Set();\n-      if (socket.servername != null) {\n-        let originString = `https://${socket.servername}`;\n-        if (socket.remotePort != null)\n-          originString += `:${socket.remotePort}`;\n-        // We have to ensure that it is a properly serialized\n-        // ASCII origin string. The socket.servername might not\n-        // be properly ASCII encoded.\n-        originSet.add((new URL(originString)).origin);\n-      }\n-    }\n-\n-    return Array.from(originSet);\n+    return Array.from(initOriginSet(this));\n   }\n \n   // True if the Http2Session is still waiting for the socket to connect\n@@ -1338,6 +1371,40 @@ class ServerHttp2Session extends Http2Session {\n \n     this[kHandle].altsvc(stream, origin || '', alt);\n   }\n+\n+  // Submits an origin frame to be sent.\n+  origin(...origins) {\n+    if (this.destroyed)\n+      throw new ERR_HTTP2_INVALID_SESSION();\n+\n+    if (origins.length === 0)\n+      return;\n+\n+    let arr = '';\n+    let len = 0;\n+    const count = origins.length;\n+    for (var i = 0; i < count; i++) {\n+      let origin = origins[i];\n+      if (typeof origin === 'string') {\n+        origin = (new URL(origin)).origin;\n+      } else if (origin != null && typeof origin === 'object') {\n+        origin = origin.origin;\n+      }\n+      if (typeof origin !== 'string')\n+        throw new ERR_INVALID_ARG_TYPE('origin', 'string', origin);\n+      if (origin === 'null')\n+        throw new ERR_HTTP2_INVALID_ORIGIN();\n+\n+      arr += `${origin}\\0`;\n+      len += origin.length;\n+    }\n+\n+    if (len > 16382)\n+      throw new ERR_HTTP2_ORIGIN_LENGTH();\n+\n+    this[kHandle].origin(arr, count);\n+  }\n+\n }\n \n // ClientHttp2Session instances have to wait for the socket to connect after\n@@ -1406,6 +1473,8 @@ class ClientHttp2Session extends Http2Session {\n \n     const stream = new ClientHttp2Stream(this, undefined, undefined, {});\n     stream[kSentHeaders] = headers;\n+    stream[kOrigin] = `${headers[HTTP2_HEADER_SCHEME]}://` +\n+                      `${headers[HTTP2_HEADER_AUTHORITY]}`;\n \n     // Close the writable side of the stream if options.endStream is set.\n     if (options.endStream)"
        },
        {
            "sha": "aafb3f6e0c79882628d64e33bfe630b26c6abf9b",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/b92ce5165f91eec1f312bb9f762357e673f83501/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/b92ce5165f91eec1f312bb9f762357e673f83501/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=b92ce5165f91eec1f312bb9f762357e673f83501",
            "patch": "@@ -224,6 +224,7 @@ struct PackageConfig {\n   V(onnewsession_string, \"onnewsession\")                                      \\\n   V(onocspresponse_string, \"onocspresponse\")                                  \\\n   V(ongoawaydata_string, \"ongoawaydata\")                                      \\\n+  V(onorigin_string, \"onorigin\")                                              \\\n   V(onpriority_string, \"onpriority\")                                          \\\n   V(onread_string, \"onread\")                                                  \\\n   V(onreadstart_string, \"onreadstart\")                                        \\"
        },
        {
            "sha": "837d58c81cbfb56515784a5c0be645cf0316f0a4",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 120,
            "deletions": 6,
            "changes": 126,
            "blob_url": "https://github.com/nodejs/node/blob/b92ce5165f91eec1f312bb9f762357e673f83501/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/b92ce5165f91eec1f312bb9f762357e673f83501/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=b92ce5165f91eec1f312bb9f762357e673f83501",
            "patch": "@@ -95,7 +95,7 @@ Http2Scope::~Http2Scope() {\n // instances to configure an appropriate nghttp2_options struct. The class\n // uses a single TypedArray instance that is shared with the JavaScript side\n // to more efficiently pass values back and forth.\n-Http2Options::Http2Options(Environment* env) {\n+Http2Options::Http2Options(Environment* env, nghttp2_session_type type) {\n   nghttp2_option_new(&options_);\n \n   // We manually handle flow control within a session in order to\n@@ -106,10 +106,12 @@ Http2Options::Http2Options(Environment* env) {\n   // are required to buffer.\n   nghttp2_option_set_no_auto_window_update(options_, 1);\n \n-  // Enable built in support for ALTSVC frames. Once we add support for\n-  // other non-built in extension frames, this will need to be handled\n-  // a bit differently. For now, let's let nghttp2 take care of it.\n-  nghttp2_option_set_builtin_recv_extension_type(options_, NGHTTP2_ALTSVC);\n+  // Enable built in support for receiving ALTSVC and ORIGIN frames (but\n+  // only on client side sessions\n+  if (type == NGHTTP2_SESSION_CLIENT) {\n+    nghttp2_option_set_builtin_recv_extension_type(options_, NGHTTP2_ALTSVC);\n+    nghttp2_option_set_builtin_recv_extension_type(options_, NGHTTP2_ORIGIN);\n+  }\n \n   AliasedBuffer<uint32_t, Uint32Array>& buffer =\n       env->http2_state()->options_buffer;\n@@ -413,6 +415,56 @@ Headers::Headers(Isolate* isolate,\n   }\n }\n \n+Origins::Origins(Isolate* isolate,\n+                 Local<Context> context,\n+                 Local<String> origin_string,\n+                 size_t origin_count) : count_(origin_count) {\n+  int origin_string_len = origin_string->Length();\n+  if (count_ == 0) {\n+    CHECK_EQ(origin_string_len, 0);\n+    return;\n+  }\n+\n+  // Allocate a single buffer with count_ nghttp2_nv structs, followed\n+  // by the raw header data as passed from JS. This looks like:\n+  // | possible padding | nghttp2_nv | nghttp2_nv | ... | header contents |\n+  buf_.AllocateSufficientStorage((alignof(nghttp2_origin_entry) - 1) +\n+                                 count_ * sizeof(nghttp2_origin_entry) +\n+                                 origin_string_len);\n+\n+  // Make sure the start address is aligned appropriately for an nghttp2_nv*.\n+  char* start = reinterpret_cast<char*>(\n+      ROUND_UP(reinterpret_cast<uintptr_t>(*buf_),\n+               alignof(nghttp2_origin_entry)));\n+  char* origin_contents = start + (count_ * sizeof(nghttp2_origin_entry));\n+  nghttp2_origin_entry* const nva =\n+      reinterpret_cast<nghttp2_origin_entry*>(start);\n+\n+  CHECK_LE(origin_contents + origin_string_len, *buf_ + buf_.length());\n+  CHECK_EQ(origin_string->WriteOneByte(\n+               isolate,\n+               reinterpret_cast<uint8_t*>(origin_contents),\n+               0,\n+               origin_string_len,\n+               String::NO_NULL_TERMINATION),\n+           origin_string_len);\n+\n+  size_t n = 0;\n+  char* p;\n+  for (p = origin_contents; p < origin_contents + origin_string_len; n++) {\n+    if (n >= count_) {\n+      static uint8_t zero = '\\0';\n+      nva[0].origin = &zero;\n+      nva[0].origin_len = 1;\n+      count_ = 1;\n+      return;\n+    }\n+\n+    nva[n].origin = reinterpret_cast<uint8_t*>(p);\n+    nva[n].origin_len = strlen(p);\n+    p += nva[n].origin_len + 1;\n+  }\n+}\n \n // Sets the various callback functions that nghttp2 will use to notify us\n // about significant events while processing http2 stuff.\n@@ -548,7 +600,7 @@ Http2Session::Http2Session(Environment* env,\n   statistics_.start_time = uv_hrtime();\n \n   // Capture the configuration options for this session\n-  Http2Options opts(env);\n+  Http2Options opts(env, type);\n \n   max_session_memory_ = opts.GetMaxSessionMemory();\n \n@@ -933,6 +985,9 @@ int Http2Session::OnFrameReceive(nghttp2_session* handle,\n     case NGHTTP2_ALTSVC:\n       session->HandleAltSvcFrame(frame);\n       break;\n+    case NGHTTP2_ORIGIN:\n+      session->HandleOriginFrame(frame);\n+      break;\n     default:\n       break;\n   }\n@@ -1365,6 +1420,41 @@ void Http2Session::HandleAltSvcFrame(const nghttp2_frame* frame) {\n   MakeCallback(env()->onaltsvc_string(), arraysize(argv), argv);\n }\n \n+void Http2Session::HandleOriginFrame(const nghttp2_frame* frame) {\n+  Isolate* isolate = env()->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env()->context();\n+  Context::Scope context_scope(context);\n+\n+  Debug(this, \"handling origin frame\");\n+\n+  nghttp2_extension ext = frame->ext;\n+  nghttp2_ext_origin* origin = static_cast<nghttp2_ext_origin*>(ext.payload);\n+\n+  Local<Array> holder = Array::New(isolate);\n+  Local<Function> fn = env()->push_values_to_array_function();\n+  Local<Value> argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n+\n+  size_t n = 0;\n+  while (n < origin->nov) {\n+    size_t j = 0;\n+    while (n < origin->nov && j < arraysize(argv)) {\n+      auto entry = origin->ov[n++];\n+      argv[j++] =\n+        String::NewFromOneByte(isolate,\n+                               entry.origin,\n+                               v8::NewStringType::kNormal,\n+                               entry.origin_len).ToLocalChecked();\n+    }\n+    if (j > 0)\n+      fn->Call(context, holder, j, argv).ToLocalChecked();\n+  }\n+\n+  Local<Value> args[1] = { holder };\n+\n+  MakeCallback(env()->onorigin_string(), arraysize(args), args);\n+}\n+\n // Called by OnFrameReceived when a complete PING frame has been received.\n void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {\n   bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;\n@@ -2613,6 +2703,11 @@ void Http2Session::AltSvc(int32_t id,\n                                  origin, origin_len, value, value_len), 0);\n }\n \n+void Http2Session::Origin(nghttp2_origin_entry* ov, size_t count) {\n+  Http2Scope h2scope(this);\n+  CHECK_EQ(nghttp2_submit_origin(session_, NGHTTP2_FLAG_NONE, ov, count), 0);\n+}\n+\n // Submits an AltSvc frame to be sent to the connected peer.\n void Http2Session::AltSvc(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n@@ -2641,6 +2736,24 @@ void Http2Session::AltSvc(const FunctionCallbackInfo<Value>& args) {\n   session->AltSvc(id, *origin, origin_len, *value, value_len);\n }\n \n+void Http2Session::Origin(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Local<Context> context = env->context();\n+  Http2Session* session;\n+  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());\n+\n+  Local<String> origin_string = args[0].As<String>();\n+  int count = args[1]->IntegerValue(context).ToChecked();\n+\n+\n+  Origins origins(env->isolate(),\n+                  env->context(),\n+                  origin_string,\n+                  count);\n+\n+  session->Origin(*origins, origins.length());\n+}\n+\n // Submits a PING frame to be sent to the connected peer.\n void Http2Session::Ping(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n@@ -2874,6 +2987,7 @@ void Initialize(Local<Object> target,\n   session->SetClassName(http2SessionClassName);\n   session->InstanceTemplate()->SetInternalFieldCount(1);\n   AsyncWrap::AddWrapMethods(env, session);\n+  env->SetProtoMethod(session, \"origin\", Http2Session::Origin);\n   env->SetProtoMethod(session, \"altsvc\", Http2Session::AltSvc);\n   env->SetProtoMethod(session, \"ping\", Http2Session::Ping);\n   env->SetProtoMethod(session, \"consume\", Http2Session::Consume);"
        },
        {
            "sha": "7fa230979a87cbcc70885a57189d1d9de30afd7f",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 26,
            "deletions": 1,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/b92ce5165f91eec1f312bb9f762357e673f83501/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/b92ce5165f91eec1f312bb9f762357e673f83501/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=b92ce5165f91eec1f312bb9f762357e673f83501",
            "patch": "@@ -364,7 +364,7 @@ class Http2Scope {\n // configured.\n class Http2Options {\n  public:\n-  explicit Http2Options(Environment* env);\n+  Http2Options(Environment* env, nghttp2_session_type type);\n \n   ~Http2Options() {\n     nghttp2_option_del(options_);\n@@ -700,6 +700,8 @@ class Http2Session : public AsyncWrap, public StreamListener {\n               size_t origin_len,\n               uint8_t* value,\n               size_t value_len);\n+  void Origin(nghttp2_origin_entry* ov, size_t count);\n+\n \n   bool Ping(v8::Local<v8::Function> function);\n \n@@ -796,6 +798,7 @@ class Http2Session : public AsyncWrap, public StreamListener {\n   static void RefreshState(const FunctionCallbackInfo<Value>& args);\n   static void Ping(const FunctionCallbackInfo<Value>& args);\n   static void AltSvc(const FunctionCallbackInfo<Value>& args);\n+  static void Origin(const FunctionCallbackInfo<Value>& args);\n \n   template <get_setting fn>\n   static void RefreshSettings(const FunctionCallbackInfo<Value>& args);\n@@ -871,6 +874,7 @@ class Http2Session : public AsyncWrap, public StreamListener {\n   void HandleSettingsFrame(const nghttp2_frame* frame);\n   void HandlePingFrame(const nghttp2_frame* frame);\n   void HandleAltSvcFrame(const nghttp2_frame* frame);\n+  void HandleOriginFrame(const nghttp2_frame* frame);\n \n   // nghttp2 callbacks\n   static int OnBeginHeadersCallback(\n@@ -1224,6 +1228,27 @@ class Headers {\n   MaybeStackBuffer<char, 3000> buf_;\n };\n \n+class Origins {\n+ public:\n+  Origins(Isolate* isolate,\n+          Local<Context> context,\n+          Local<v8::String> origin_string,\n+          size_t origin_count);\n+  ~Origins() {}\n+\n+  nghttp2_origin_entry* operator*() {\n+    return reinterpret_cast<nghttp2_origin_entry*>(*buf_);\n+  }\n+\n+  size_t length() const {\n+    return count_;\n+  }\n+\n+ private:\n+  size_t count_;\n+  MaybeStackBuffer<char, 512> buf_;\n+};\n+\n }  // namespace http2\n }  // namespace node\n "
        },
        {
            "sha": "6312d1f00649f0acf124383a068cb865de61e668",
            "filename": "test/parallel/test-http2-origin.js",
            "status": "added",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/nodejs/node/blob/b92ce5165f91eec1f312bb9f762357e673f83501/test%2Fparallel%2Ftest-http2-origin.js",
            "raw_url": "https://github.com/nodejs/node/raw/b92ce5165f91eec1f312bb9f762357e673f83501/test%2Fparallel%2Ftest-http2-origin.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-origin.js?ref=b92ce5165f91eec1f312bb9f762357e673f83501",
            "patch": "@@ -0,0 +1,179 @@\n+'use strict';\n+\n+const {\n+  hasCrypto,\n+  mustCall,\n+  mustNotCall,\n+  skip\n+} = require('../common');\n+if (!hasCrypto)\n+  skip('missing crypto');\n+\n+const {\n+  deepStrictEqual,\n+  strictEqual,\n+  throws\n+} = require('assert');\n+const {\n+  createSecureServer,\n+  createServer,\n+  connect\n+} = require('http2');\n+const Countdown = require('../common/countdown');\n+\n+const { readKey } = require('../common/fixtures');\n+\n+const key = readKey('agent8-key.pem', 'binary');\n+const cert = readKey('agent8-cert.pem', 'binary');\n+const ca = readKey('fake-startcom-root-cert.pem', 'binary');\n+\n+{\n+  const server = createSecureServer({ key, cert });\n+  server.on('stream', mustCall((stream) => {\n+    stream.session.origin('https://example.org/a/b/c',\n+                          new URL('https://example.com'));\n+    stream.respond();\n+    stream.end('ok');\n+  }));\n+  server.on('session', mustCall((session) => {\n+    session.origin('https://foo.org/a/b/c', new URL('https://bar.org'));\n+\n+    // Won't error, but won't send anything\n+    session.origin();\n+\n+    [0, true, {}, []].forEach((input) => {\n+      throws(\n+        () => session.origin(input),\n+        {\n+          code: 'ERR_INVALID_ARG_TYPE',\n+          name: 'TypeError [ERR_INVALID_ARG_TYPE]'\n+        }\n+      );\n+    });\n+\n+    [new URL('foo://bar'), 'foo://bar'].forEach((input) => {\n+      throws(\n+        () => session.origin(input),\n+        {\n+          code: 'ERR_HTTP2_INVALID_ORIGIN',\n+          name: 'TypeError [ERR_HTTP2_INVALID_ORIGIN]'\n+        }\n+      );\n+    });\n+\n+    ['not a valid url'].forEach((input) => {\n+      throws(\n+        () => session.origin(input),\n+        {\n+          code: 'ERR_INVALID_URL',\n+          name: 'TypeError [ERR_INVALID_URL]'\n+        }\n+      );\n+    });\n+  }));\n+\n+  server.listen(0, mustCall(() => {\n+    const originSet = [`https://localhost:${server.address().port}`];\n+    const client = connect(originSet[0], { ca });\n+    const checks = [\n+      ['https://foo.org', 'https://bar.org'],\n+      ['https://example.org', 'https://example.com']\n+    ];\n+\n+    const countdown = new Countdown(2, () => {\n+      client.close();\n+      server.close();\n+    });\n+\n+    client.on('origin', mustCall((origins) => {\n+      const check = checks.shift();\n+      originSet.push(...check);\n+      deepStrictEqual(originSet, client.originSet);\n+      deepStrictEqual(origins, check);\n+      countdown.dec();\n+    }, 2));\n+\n+    client.request().on('close', mustCall()).resume();\n+  }));\n+}\n+\n+// Test automatically sending origin on connection start\n+{\n+  const origins = [ 'https://foo.org/a/b/c', 'https://bar.org' ];\n+  const server = createSecureServer({ key, cert, origins });\n+  server.on('stream', mustCall((stream) => {\n+    stream.respond();\n+    stream.end('ok');\n+  }));\n+\n+  server.listen(0, mustCall(() => {\n+    const check = ['https://foo.org', 'https://bar.org'];\n+    const originSet = [`https://localhost:${server.address().port}`];\n+    const client = connect(originSet[0], { ca });\n+\n+    client.on('origin', mustCall((origins) => {\n+      originSet.push(...check);\n+      deepStrictEqual(originSet, client.originSet);\n+      deepStrictEqual(origins, check);\n+      client.close();\n+      server.close();\n+    }));\n+\n+    client.request().on('close', mustCall()).resume();\n+  }));\n+}\n+\n+// If return status is 421, the request origin must be removed from the\n+// originSet\n+{\n+  const server = createSecureServer({ key, cert });\n+  server.on('stream', mustCall((stream) => {\n+    stream.respond({ ':status': 421 });\n+    stream.end();\n+  }));\n+  server.on('session', mustCall((session) => {\n+    session.origin('https://foo.org');\n+  }));\n+\n+  server.listen(0, mustCall(() => {\n+    const origin = `https://localhost:${server.address().port}`;\n+    const client = connect(origin, { ca });\n+\n+    client.on('origin', mustCall((origins) => {\n+      deepStrictEqual([origin, 'https://foo.org'], client.originSet);\n+      const req = client.request({ ':authority': 'foo.org' });\n+      req.on('response', mustCall((headers) => {\n+        strictEqual(421, headers[':status']);\n+        deepStrictEqual([origin], client.originSet);\n+      }));\n+      req.resume();\n+      req.on('close', mustCall(() => {\n+        client.close();\n+        server.close();\n+      }));\n+    }, 1));\n+  }));\n+}\n+\n+// Origin is ignored on plain text HTTP/2 connections... server will still\n+// send them, but client will ignore them.\n+{\n+  const server = createServer();\n+  server.on('stream', mustCall((stream) => {\n+    stream.session.origin('https://example.org',\n+                          new URL('https://example.com'));\n+    stream.respond();\n+    stream.end('ok');\n+  }));\n+  server.listen(0, mustCall(() => {\n+    const client = connect(`http://localhost:${server.address().port}`);\n+    client.on('origin', mustNotCall());\n+    strictEqual(client.originSet, undefined);\n+    const req = client.request();\n+    req.resume();\n+    req.on('close', mustCall(() => {\n+      client.close();\n+      server.close();\n+    }));\n+  }));\n+}"
        }
    ],
    "stats": {
        "total": 533,
        "additions": 509,
        "deletions": 24
    }
}