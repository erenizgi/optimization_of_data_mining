{
    "author": "joyeecheung",
    "message": "src: always compile and store code cache for native modules\n\nThis patch changes the NativeModuleLoader to always try to find\ncode cache for native modules when it compiles them, and always\nproduce and store the code cache after compilation. The cache\nmap is protected by a mutex and can be accessed by different\nthreads - including the worker threads and the main thread. Hence any\nthread can reuse the code cache if the native module has already\nbeen compiled by another thread - in particular the cache of the\nbootstrappers and per_context.js will always be hit when a new thread\nis spun.\n\nThis results in a ~6% startup overhead in the worst case\n(when only the main thread is launched without requiring any additional\nnative module - it now needs to do the extra work of finding and\nstoring caches), which balances out the recent improvements by moving\nthe compilation to C++, but it also leads to a ~60% improvement in\nthe best case (when a worker thread is spun and requires a lot of native\nmodules thus hitting the cache compiled by the main thread).\n\nPR-URL: https://github.com/nodejs/node/pull/24950\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5",
    "files": [
        {
            "sha": "725425b2cec4f1a84c55cbc45ee375e83a197c37",
            "filename": "lib/internal/bootstrap/cache.js",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/lib%2Finternal%2Fbootstrap%2Fcache.js",
            "raw_url": "https://github.com/nodejs/node/raw/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/lib%2Finternal%2Fbootstrap%2Fcache.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Fcache.js?ref=0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5",
            "patch": "@@ -6,7 +6,9 @@\n // cannot be tampered with even with --expose-internals.\n \n const { NativeModule } = require('internal/bootstrap/loaders');\n-const { source, compileCodeCache } = internalBinding('native_module');\n+const {\n+  source, getCodeCache, compileFunction\n+} = internalBinding('native_module');\n const { hasTracing } = process.binding('config');\n \n const depsModule = Object.keys(source).filter(\n@@ -69,6 +71,7 @@ module.exports = {\n     (key) => !cannotUseCache.includes(key)\n   ),\n   getSource(id) { return source[id]; },\n-  getCodeCache: compileCodeCache,\n+  getCodeCache,\n+  compileFunction,\n   cannotUseCache\n };"
        },
        {
            "sha": "d830b846c90f6e68cc93766c5d67f639e52ef173",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5",
            "patch": "@@ -110,7 +110,6 @@ typedef int mode_t;\n \n namespace node {\n \n-using native_module::NativeModuleLoader;\n using options_parser::kAllowedInEnvironment;\n using options_parser::kDisallowedInEnvironment;\n using v8::Array;\n@@ -162,7 +161,6 @@ double prog_start_time;\n Mutex per_process_opts_mutex;\n std::shared_ptr<PerProcessOptions> per_process_opts {\n     new PerProcessOptions() };\n-NativeModuleLoader per_process_loader;\n static Mutex node_isolate_mutex;\n static Isolate* node_isolate;\n \n@@ -1187,7 +1185,7 @@ static MaybeLocal<Value> ExecuteBootstrapper(\n     const char* id,\n     std::vector<Local<String>>* parameters,\n     std::vector<Local<Value>>* arguments) {\n-  MaybeLocal<Value> ret = per_process_loader.CompileAndCall(\n+  MaybeLocal<Value> ret = per_process::native_module_loader.CompileAndCall(\n       env->context(), id, parameters, arguments, env);\n \n   // If there was an error during bootstrap then it was either handled by the\n@@ -1906,7 +1904,7 @@ Local<Context> NewContext(Isolate* isolate,\n     std::vector<Local<String>> parameters = {\n         FIXED_ONE_BYTE_STRING(isolate, \"global\")};\n     std::vector<Local<Value>> arguments = {context->Global()};\n-    MaybeLocal<Value> result = per_process_loader.CompileAndCall(\n+    MaybeLocal<Value> result = per_process::native_module_loader.CompileAndCall(\n         context, \"internal/per_context\", &parameters, &arguments, nullptr);\n     if (result.IsEmpty()) {\n       // Execution failed during context creation."
        },
        {
            "sha": "4a47c744c2d7fbf5a965611d593e3ed7395fff29",
            "filename": "src/node_binding.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode_binding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode_binding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_binding.cc?ref=0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5",
            "patch": "@@ -411,13 +411,14 @@ void GetInternalBinding(const FunctionCallbackInfo<Value>& args) {\n         exports->SetPrototype(env->context(), Null(env->isolate())).FromJust());\n     DefineConstants(env->isolate(), exports);\n   } else if (!strcmp(*module_v, \"natives\")) {\n-    exports = per_process_loader.GetSourceObject(env->context());\n+    exports = per_process::native_module_loader.GetSourceObject(env->context());\n     // Legacy feature: process.binding('natives').config contains stringified\n     // config.gypi\n     CHECK(exports\n               ->Set(env->context(),\n                     env->config_string(),\n-                    per_process_loader.GetConfigString(env->isolate()))\n+                    per_process::native_module_loader.GetConfigString(\n+                        env->isolate()))\n               .FromJust());\n   } else {\n     return ThrowIfNoSuchModule(env, *module_v);"
        },
        {
            "sha": "d9a72a10a440ea8f4d6600aec99c08dafc7ef14d",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5",
            "patch": "@@ -91,7 +91,6 @@ extern bool v8_initialized;\n \n extern Mutex per_process_opts_mutex;\n extern std::shared_ptr<PerProcessOptions> per_process_opts;\n-extern native_module::NativeModuleLoader per_process_loader;\n \n // Forward declaration\n class Environment;"
        },
        {
            "sha": "d7fa5798d0b92e76b2f97e5e8e692c01b056a1b8",
            "filename": "src/node_native_module.cc",
            "status": "modified",
            "additions": 85,
            "deletions": 90,
            "changes": 175,
            "blob_url": "https://github.com/nodejs/node/blob/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode_native_module.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode_native_module.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_native_module.cc?ref=0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5",
            "patch": "@@ -3,6 +3,11 @@\n #include \"node_internals.h\"\n \n namespace node {\n+\n+namespace per_process {\n+native_module::NativeModuleLoader native_module_loader;\n+}  // namespace per_process\n+\n namespace native_module {\n \n using v8::Array;\n@@ -78,13 +83,14 @@ void NativeModuleLoader::GetCacheUsage(\n void NativeModuleLoader::SourceObjectGetter(\n     Local<Name> property, const PropertyCallbackInfo<Value>& info) {\n   Local<Context> context = info.GetIsolate()->GetCurrentContext();\n-  info.GetReturnValue().Set(per_process_loader.GetSourceObject(context));\n+  info.GetReturnValue().Set(\n+      per_process::native_module_loader.GetSourceObject(context));\n }\n \n void NativeModuleLoader::ConfigStringGetter(\n     Local<Name> property, const PropertyCallbackInfo<Value>& info) {\n   info.GetReturnValue().Set(\n-      per_process_loader.GetConfigString(info.GetIsolate()));\n+      per_process::native_module_loader.GetConfigString(info.GetIsolate()));\n }\n \n Local<Object> NativeModuleLoader::GetSourceObject(\n@@ -96,41 +102,62 @@ Local<String> NativeModuleLoader::GetConfigString(Isolate* isolate) const {\n   return config_.ToStringChecked(isolate);\n }\n \n-Local<String> NativeModuleLoader::GetSource(Isolate* isolate,\n-                                            const char* id) const {\n-  const auto it = source_.find(id);\n-  CHECK_NE(it, source_.end());\n-  return it->second.ToStringChecked(isolate);\n-}\n-\n NativeModuleLoader::NativeModuleLoader() : config_(GetConfig()) {\n   LoadJavaScriptSource();\n   LoadCodeCache();\n }\n \n-void NativeModuleLoader::CompileCodeCache(\n-    const FunctionCallbackInfo<Value>& args) {\n+// This is supposed to be run only by the main thread in\n+// tools/generate_code_cache.js\n+void NativeModuleLoader::GetCodeCache(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  CHECK(env->is_main_thread());\n+\n   CHECK(args[0]->IsString());\n-  node::Utf8Value id(env->isolate(), args[0].As<String>());\n+  node::Utf8Value id_v(isolate, args[0].As<String>());\n+  const char* id = *id_v;\n \n-  // TODO(joyeecheung): allow compiling cache for bootstrapper by\n-  // switching on id\n-  MaybeLocal<Value> result =\n-      CompileAsModule(env, *id, CompilationResultType::kCodeCache);\n-  if (!result.IsEmpty()) {\n-    args.GetReturnValue().Set(result.ToLocalChecked());\n+  const NativeModuleLoader& loader = per_process::native_module_loader;\n+  MaybeLocal<Uint8Array> ret = loader.GetCodeCache(isolate, id);\n+  if (!ret.IsEmpty()) {\n+    args.GetReturnValue().Set(ret.ToLocalChecked());\n   }\n }\n \n+// This is supposed to be run only by the main thread in\n+// tools/generate_code_cache.js\n+MaybeLocal<Uint8Array> NativeModuleLoader::GetCodeCache(Isolate* isolate,\n+                                                        const char* id) const {\n+  EscapableHandleScope scope(isolate);\n+  Mutex::ScopedLock lock(code_cache_mutex_);\n+\n+  ScriptCompiler::CachedData* cached_data = nullptr;\n+  const auto it = code_cache_.find(id);\n+  if (it == code_cache_.end()) {\n+    // The module has not been compiled before.\n+    return MaybeLocal<Uint8Array>();\n+  }\n+\n+  cached_data = it->second.get();\n+\n+  MallocedBuffer<uint8_t> copied(cached_data->length);\n+  memcpy(copied.data, cached_data->data, cached_data->length);\n+  Local<ArrayBuffer> buf =\n+      ArrayBuffer::New(isolate,\n+                       copied.release(),\n+                       cached_data->length,\n+                       ArrayBufferCreationMode::kInternalized);\n+  return scope.Escape(Uint8Array::New(buf, 0, cached_data->length));\n+}\n+\n void NativeModuleLoader::CompileFunction(\n     const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   CHECK(args[0]->IsString());\n   node::Utf8Value id(env->isolate(), args[0].As<String>());\n \n-  MaybeLocal<Value> result =\n-      CompileAsModule(env, *id, CompilationResultType::kFunction);\n+  MaybeLocal<Function> result = CompileAsModule(env, *id);\n   if (!result.IsEmpty()) {\n     args.GetReturnValue().Set(result.ToLocalChecked());\n   }\n@@ -145,57 +172,43 @@ MaybeLocal<Value> NativeModuleLoader::CompileAndCall(\n     std::vector<Local<Value>>* arguments,\n     Environment* optional_env) {\n   Isolate* isolate = context->GetIsolate();\n-  MaybeLocal<Value> compiled = per_process_loader.LookupAndCompile(\n-      context, id, parameters, CompilationResultType::kFunction, nullptr);\n+  MaybeLocal<Function> compiled =\n+      per_process::native_module_loader.LookupAndCompile(\n+          context, id, parameters, nullptr);\n   if (compiled.IsEmpty()) {\n-    return compiled;\n+    return MaybeLocal<Value>();\n   }\n   Local<Function> fn = compiled.ToLocalChecked().As<Function>();\n   return fn->Call(\n       context, v8::Null(isolate), arguments->size(), arguments->data());\n }\n \n-MaybeLocal<Value> NativeModuleLoader::CompileAsModule(\n-    Environment* env, const char* id, CompilationResultType result) {\n+MaybeLocal<Function> NativeModuleLoader::CompileAsModule(Environment* env,\n+                                                         const char* id) {\n   std::vector<Local<String>> parameters = {env->exports_string(),\n                                            env->require_string(),\n                                            env->module_string(),\n                                            env->process_string(),\n                                            env->internal_binding_string()};\n-  return per_process_loader.LookupAndCompile(\n-      env->context(), id, &parameters, result, env);\n-}\n-\n-// Returns nullptr if there is no code cache corresponding to the id\n-ScriptCompiler::CachedData* NativeModuleLoader::GetCachedData(\n-    const char* id) const {\n-  const auto it = per_process_loader.code_cache_.find(id);\n-  // This could be false if the module cannot be cached somehow.\n-  // See lib/internal/bootstrap/cache.js on the modules that cannot be cached\n-  if (it == per_process_loader.code_cache_.end()) {\n-    return nullptr;\n-  }\n-\n-  const uint8_t* code_cache_value = it->second.one_bytes_data();\n-  size_t code_cache_length = it->second.length();\n-\n-  return new ScriptCompiler::CachedData(code_cache_value, code_cache_length);\n+  return per_process::native_module_loader.LookupAndCompile(\n+      env->context(), id, &parameters, env);\n }\n \n // Returns Local<Function> of the compiled module if return_code_cache\n // is false (we are only compiling the function).\n // Otherwise return a Local<Object> containing the cache.\n-MaybeLocal<Value> NativeModuleLoader::LookupAndCompile(\n+MaybeLocal<Function> NativeModuleLoader::LookupAndCompile(\n     Local<Context> context,\n     const char* id,\n     std::vector<Local<String>>* parameters,\n-    CompilationResultType result_type,\n     Environment* optional_env) {\n   Isolate* isolate = context->GetIsolate();\n   EscapableHandleScope scope(isolate);\n   Local<Value> ret;  // Used to convert to MaybeLocal before return\n \n-  Local<String> source = GetSource(isolate, id);\n+  const auto source_it = source_.find(id);\n+  CHECK_NE(source_it, source_.end());\n+  Local<String> source = source_it->second.ToStringChecked(isolate);\n \n   std::string filename_s = id + std::string(\".js\");\n   Local<String> filename =\n@@ -204,31 +217,24 @@ MaybeLocal<Value> NativeModuleLoader::LookupAndCompile(\n   Local<Integer> column_offset = Integer::New(isolate, 0);\n   ScriptOrigin origin(filename, line_offset, column_offset);\n \n-  bool use_cache = false;\n-  ScriptCompiler::CachedData* cached_data = nullptr;\n+  Mutex::ScopedLock lock(code_cache_mutex_);\n \n-  // 1. We won't even check the existence of the cache if the binary is not\n-  //    built with them.\n-  // 2. If we are generating code cache for tools/general_code_cache.js, we\n-  //    are not going to use any cache ourselves.\n-  if (has_code_cache_ && result_type == CompilationResultType::kFunction) {\n-    cached_data = GetCachedData(id);\n-    if (cached_data != nullptr) {\n-      use_cache = true;\n+  ScriptCompiler::CachedData* cached_data = nullptr;\n+  {\n+    auto cache_it = code_cache_.find(id);\n+    if (cache_it != code_cache_.end()) {\n+      // Transfer ownership to ScriptCompiler::Source later.\n+      cached_data = cache_it->second.release();\n+      code_cache_.erase(cache_it);\n     }\n   }\n \n+  const bool use_cache = cached_data != nullptr;\n+  ScriptCompiler::CompileOptions options =\n+      use_cache ? ScriptCompiler::kConsumeCodeCache\n+                : ScriptCompiler::kEagerCompile;\n   ScriptCompiler::Source script_source(source, origin, cached_data);\n \n-  ScriptCompiler::CompileOptions options;\n-  if (result_type == CompilationResultType::kCodeCache) {\n-    options = ScriptCompiler::kEagerCompile;\n-  } else if (use_cache) {\n-    options = ScriptCompiler::kConsumeCodeCache;\n-  } else {\n-    options = ScriptCompiler::kNoCompileOptions;\n-  }\n-\n   MaybeLocal<Function> maybe_fun =\n       ScriptCompiler::CompileFunctionInContext(context,\n                                                &script_source,\n@@ -244,10 +250,14 @@ MaybeLocal<Value> NativeModuleLoader::LookupAndCompile(\n     // In the case of early errors, v8 is already capable of\n     // decorating the stack for us - note that we use CompileFunctionInContext\n     // so there is no need to worry about wrappers.\n-    return MaybeLocal<Value>();\n+    return MaybeLocal<Function>();\n   }\n \n   Local<Function> fun = maybe_fun.ToLocalChecked();\n+  // XXX(joyeecheung): this bookkeeping is not exactly accurate because\n+  // it only starts after the Environment is created, so the per_context.js\n+  // will never be in any of these two sets, but the two sets are only for\n+  // testing anyway.\n   if (use_cache) {\n     if (optional_env != nullptr) {\n       // This could happen when Node is run with any v8 flag, but\n@@ -264,29 +274,15 @@ MaybeLocal<Value> NativeModuleLoader::LookupAndCompile(\n     }\n   }\n \n-  if (result_type == CompilationResultType::kCodeCache) {\n-    std::unique_ptr<ScriptCompiler::CachedData> cached_data(\n-        ScriptCompiler::CreateCodeCacheForFunction(fun));\n-    CHECK_NE(cached_data, nullptr);\n-    size_t cached_data_length = cached_data->length;\n-    // Since we have no special allocator to create an ArrayBuffer\n-    // from a new'ed pointer, we will need to copy it - but this\n-    // code path is only run by the tooling that generates the code\n-    // cache to be bundled in the binary\n-    // so it should be fine.\n-    MallocedBuffer<uint8_t> copied(cached_data->length);\n-    memcpy(copied.data, cached_data->data, cached_data_length);\n-    Local<ArrayBuffer> buf =\n-        ArrayBuffer::New(isolate,\n-                         copied.release(),\n-                         cached_data_length,\n-                         ArrayBufferCreationMode::kInternalized);\n-    ret = Uint8Array::New(buf, 0, cached_data_length);\n-  } else {\n-    ret = fun;\n-  }\n+  // Generate new cache for next compilation\n+  std::unique_ptr<ScriptCompiler::CachedData> new_cached_data(\n+      ScriptCompiler::CreateCodeCacheForFunction(fun));\n+  CHECK_NE(new_cached_data, nullptr);\n \n-  return scope.Escape(ret);\n+  // The old entry should've been erased by now so we can just emplace\n+  code_cache_.emplace(id, std::move(new_cached_data));\n+\n+  return scope.Escape(fun);\n }\n \n void NativeModuleLoader::Initialize(Local<Object> target,\n@@ -320,8 +316,7 @@ void NativeModuleLoader::Initialize(Local<Object> target,\n       target, \"getCacheUsage\", NativeModuleLoader::GetCacheUsage);\n   env->SetMethod(\n       target, \"compileFunction\", NativeModuleLoader::CompileFunction);\n-  env->SetMethod(\n-      target, \"compileCodeCache\", NativeModuleLoader::CompileCodeCache);\n+  env->SetMethod(target, \"getCodeCache\", NativeModuleLoader::GetCodeCache);\n   // internalBinding('native_module') should be frozen\n   target->SetIntegrityLevel(context, IntegrityLevel::kFrozen).FromJust();\n }"
        },
        {
            "sha": "2e5821c2cfc6a13cce041050f0b39e600c1d460a",
            "filename": "src/node_native_module.h",
            "status": "modified",
            "additions": 25,
            "deletions": 22,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode_native_module.h",
            "raw_url": "https://github.com/nodejs/node/raw/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/src%2Fnode_native_module.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_native_module.h?ref=0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5",
            "patch": "@@ -7,14 +7,17 @@\n #include <set>\n #include <string>\n #include \"env.h\"\n+#include \"node_mutex.h\"\n #include \"node_union_bytes.h\"\n #include \"v8.h\"\n \n namespace node {\n namespace native_module {\n \n using NativeModuleRecordMap = std::map<std::string, UnionBytes>;\n-using NativeModuleHashMap = std::map<std::string, std::string>;\n+using NativeModuleCacheMap =\n+    std::unordered_map<std::string,\n+                       std::unique_ptr<v8::ScriptCompiler::CachedData>>;\n \n // The native (C++) side of the NativeModule in JS land, which\n // handles compilation and caching of builtin modules (NativeModule)\n@@ -25,16 +28,12 @@ using NativeModuleHashMap = std::map<std::string, std::string>;\n // The instances of this class are per-process.\n class NativeModuleLoader {\n  public:\n-  // kCodeCache indicates that the compilation result should be returned\n-  // as a Uint8Array, whereas kFunction indicates that the result should\n-  // be returned as a Function.\n-  // TODO(joyeecheung): it's possible to always produce code cache\n-  // on the main thread and consume them in worker threads, or just\n-  // share the cache among all the threads, although\n-  // we need to decide whether to do that even when workers are not used.\n-  enum class CompilationResultType { kCodeCache, kFunction };\n-\n   NativeModuleLoader();\n+  // TODO(joyeecheung): maybe we should make this a singleton, instead of\n+  // putting it in per_process.\n+  NativeModuleLoader(const NativeModuleLoader&) = delete;\n+  NativeModuleLoader& operator=(const NativeModuleLoader&) = delete;\n+\n   static void Initialize(v8::Local<v8::Object> target,\n                          v8::Local<v8::Value> unused,\n                          v8::Local<v8::Context> context,\n@@ -43,8 +42,6 @@ class NativeModuleLoader {\n   // Returns config.gypi as a JSON string\n   v8::Local<v8::String> GetConfigString(v8::Isolate* isolate) const;\n \n-  v8::Local<v8::String> GetSource(v8::Isolate* isolate, const char* id) const;\n-\n   // Run a script with JS source bundled inside the binary as if it's wrapped\n   // in a function called with a null receiver and arguments specified in C++.\n   // The returned value is empty if an exception is encountered.\n@@ -68,8 +65,10 @@ class NativeModuleLoader {\n   static void ConfigStringGetter(\n       v8::Local<v8::Name> property,\n       const v8::PropertyCallbackInfo<v8::Value>& info);\n-  // Compile code cache for a specific native module\n-  static void CompileCodeCache(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  // Get code cache for a specific native module\n+  static void GetCodeCache(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  v8::MaybeLocal<v8::Uint8Array> GetCodeCache(v8::Isolate* isolate,\n+                                              const char* id) const;\n   // Compile a specific native module as a function\n   static void CompileFunction(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n@@ -82,30 +81,34 @@ class NativeModuleLoader {\n   // in node_code_cache_stub.cc\n   void LoadCodeCache();      // Loads data into code_cache_\n \n-  v8::ScriptCompiler::CachedData* GetCachedData(const char* id) const;\n-\n   // Compile a script as a NativeModule that can be loaded via\n   // NativeModule.p.require in JS land.\n-  static v8::MaybeLocal<v8::Value> CompileAsModule(\n-      Environment* env, const char* id, CompilationResultType result_type);\n+  static v8::MaybeLocal<v8::Function> CompileAsModule(Environment* env,\n+                                                      const char* id);\n \n   // For bootstrappers optional_env may be a nullptr.\n   // If an exception is encountered (e.g. source code contains\n   // syntax error), the returned value is empty.\n-  v8::MaybeLocal<v8::Value> LookupAndCompile(\n+  v8::MaybeLocal<v8::Function> LookupAndCompile(\n       v8::Local<v8::Context> context,\n       const char* id,\n       std::vector<v8::Local<v8::String>>* parameters,\n-      CompilationResultType result_type,\n       Environment* optional_env);\n \n-  bool has_code_cache_ = false;\n   NativeModuleRecordMap source_;\n-  NativeModuleRecordMap code_cache_;\n+  NativeModuleCacheMap code_cache_;\n   UnionBytes config_;\n+\n+  // Used to synchronize access to the code cache map\n+  Mutex code_cache_mutex_;\n };\n \n }  // namespace native_module\n+\n+namespace per_process {\n+extern native_module::NativeModuleLoader native_module_loader;\n+}  // namespace per_process\n+\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"
        },
        {
            "sha": "367e72168a6b679ddded6db36109357db607b398",
            "filename": "test/code-cache/test-code-cache.js",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/test%2Fcode-cache%2Ftest-code-cache.js",
            "raw_url": "https://github.com/nodejs/node/raw/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/test%2Fcode-cache%2Ftest-code-cache.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcode-cache%2Ftest-code-cache.js?ref=0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5",
            "patch": "@@ -43,11 +43,17 @@ const loadedModules = process.moduleLoadList\n // are all compiled without cache and we are doing the bookkeeping right.\n if (process.config.variables.node_code_cache_path === undefined) {\n   console.log('The binary is not configured with code cache');\n-  assert.deepStrictEqual(compiledWithCache, new Set());\n-\n-  for (const key of loadedModules) {\n-    assert(compiledWithoutCache.has(key),\n-           `\"${key}\" should've been compiled without code cache`);\n+  if (isMainThread) {\n+    assert.deepStrictEqual(compiledWithCache, new Set());\n+    for (const key of loadedModules) {\n+      assert(compiledWithoutCache.has(key),\n+             `\"${key}\" should've been compiled without code cache`);\n+    }\n+  } else {\n+    // TODO(joyeecheung): create a list of modules whose cache can be shared\n+    // from the main thread to the worker thread and check that their\n+    // cache are hit\n+    assert.notDeepStrictEqual(compiledWithCache, new Set());\n   }\n } else {\n   console.log('The binary is configured with code cache');"
        },
        {
            "sha": "a434f640c291578c88257c4606a4782191ac80d5",
            "filename": "tools/generate_code_cache.js",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/tools%2Fgenerate_code_cache.js",
            "raw_url": "https://github.com/nodejs/node/raw/0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5/tools%2Fgenerate_code_cache.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fgenerate_code_cache.js?ref=0858e5d9d8db085cb83b3f1f3f94ed6b550a7bc5",
            "patch": "@@ -9,6 +9,7 @@\n \n const {\n   getCodeCache,\n+  compileFunction,\n   cachableBuiltins\n } = require('internal/bootstrap/cache');\n \n@@ -57,10 +58,13 @@ function getInitalizer(key, cache) {\n   const defName = `${key.replace(/\\//g, '_').replace(/-/g, '_')}_raw`;\n   const definition = `static const uint8_t ${defName}[] = {\\n` +\n                      `${cache.join(',')}\\n};`;\n+  const dataDef = 'std::make_unique<v8::ScriptCompiler::CachedData>(' +\n+                  `${defName}, static_cast<int>(arraysize(${defName})), ` +\n+                  'policy)';\n   const initializer =\n     'code_cache_.emplace(\\n' +\n     `  \"${key}\",\\n` +\n-    `  UnionBytes(${defName}, arraysize(${defName}))\\n` +\n+    `  ${dataDef}\\n` +\n     ');';\n   return {\n     definition, initializer\n@@ -82,6 +86,7 @@ function lexical(a, b) {\n }\n \n for (const key of cachableBuiltins.sort(lexical)) {\n+  compileFunction(key);  // compile it\n   const cachedData = getCodeCache(key);\n   if (!isUint8Array(cachedData)) {\n     console.error(`Failed to generate code cache for '${key}'`);\n@@ -110,7 +115,7 @@ namespace native_module {\n ${cacheDefinitions.join('\\n\\n')}\n \n void NativeModuleLoader::LoadCodeCache() {\n-  has_code_cache_ = true;\n+  auto policy = v8::ScriptCompiler::CachedData::BufferPolicy::BufferNotOwned;\n   ${cacheInitializers.join('\\n  ')}\n }\n "
        }
    ],
    "stats": {
        "total": 266,
        "additions": 138,
        "deletions": 128
    }
}