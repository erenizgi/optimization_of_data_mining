{
    "author": "targos",
    "message": "deps: update V8 to 6.5.254.31\n\nPR-URL: https://github.com/nodejs/node/pull/18453\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Yang Guo <yangguo@chromium.org>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>",
    "sha": "88786fecff336342a56e6f2e7ff3b286be716e47",
    "files": [
        {
            "sha": "f07fc1cb6221050b9897c7eb59e010c180d46b42",
            "filename": "deps/v8/.gitignore",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2F.gitignore",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2F.gitignore",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2F.gitignore?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -50,9 +50,6 @@\n /test/fuzzer/wasm_corpus\n /test/fuzzer/wasm_corpus.tar.gz\n /test/mozilla/data\n-/test/promises-aplus/promises-tests\n-/test/promises-aplus/promises-tests.tar.gz\n-/test/promises-aplus/sinon\n /test/test262/data\n /test/test262/data.tar\n /test/test262/harness\n@@ -94,6 +91,7 @@ TAGS\n bsuite\n compile_commands.json\n d8\n+!/test/mjsunit/d8\n d8_g\n gccauses\n gcsuspects"
        },
        {
            "sha": "b2b01df888281ee20bfbbc2ddf9309bd31daca8d",
            "filename": "deps/v8/AUTHORS",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FAUTHORS?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -96,6 +96,7 @@ Luis Reis <luis.m.reis@gmail.com>\n Luke Zarko <lukezarko@gmail.com>\n Maciej Małecki <me@mmalecki.com>\n Marcin Cieślak <saper@marcincieslak.com>\n+Marcin Wiącek <marcin@mwiacek.com>\n Mateusz Czeladka <mateusz.szczap@gmail.com>\n Mathias Bynens <mathias@qiwi.be>\n Matt Hanselman <mjhanselman@gmail.com>\n@@ -106,6 +107,7 @@ Michael Smith <mike@w3.org>\n Michaël Zasso <mic.besace@gmail.com>\n Mike Gilbert <floppymaster@gmail.com>\n Mike Pennisi <mike@mikepennisi.com>\n+Mikhail Gusarov <dottedmag@dottedmag.net>\n Milton Chiang <milton.chiang@mediatek.com>\n Myeong-bo Shim <m0609.shim@samsung.com>\n Nicolas Antonius Ernst Leopold Maria Kaiser <nikai@nikai.net>\n@@ -118,6 +120,7 @@ Peter Rybin <peter.rybin@gmail.com>\n Peter Varga <pvarga@inf.u-szeged.hu>\n Peter Wong <peter.wm.wong@gmail.com>\n Paul Lind <plind44@gmail.com>\n+Qingyan Li <qingyan.liqy@alibaba-inc.com>\n Qiuyi Zhang <qiuyi.zqy@alibaba-inc.com>\n Rafal Krypa <rafal@krypa.net>\n Refael Ackermann <refack@gmail.com>\n@@ -133,6 +136,8 @@ Sanjoy Das <sanjoy@playingwithpointers.com>\n Seo Sanghyeon <sanxiyn@gmail.com>\n Stefan Penner <stefan.penner@gmail.com>\n Sylvestre Ledru <sledru@mozilla.com>\n+Taketoshi Aono <brn@b6n.ch>\n+Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\n Tobias Burnus <burnus@net-b.de>\n Victor Costan <costan@gmail.com>\n Vlad Burlik <vladbph@gmail.com>"
        },
        {
            "sha": "49707659723ca26ce786c6b04e20fac78bed2405",
            "filename": "deps/v8/BUILD.gn",
            "status": "modified",
            "additions": 61,
            "deletions": 14,
            "changes": 75,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FBUILD.gn",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FBUILD.gn",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FBUILD.gn?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -89,6 +89,9 @@ declare_args() {\n   # Sets -dV8_CONCURRENT_MARKING\n   v8_enable_concurrent_marking = true\n \n+  # Enables various testing features.\n+  v8_enable_test_features = \"\"\n+\n   # Build the snapshot with unwinding information for perf.\n   # Sets -dV8_USE_SNAPSHOT_WITH_UNWINDING_INFO.\n   v8_perf_prof_unwinding_info = false\n@@ -133,8 +136,6 @@ declare_args() {\n   # while rolling in a new version of V8.\n   v8_check_microtasks_scopes_consistency = \"\"\n \n-  v8_monolithic = false\n-\n   # Enable mitigations for executing untrusted code.\n   v8_untrusted_code_mitigations = true\n }\n@@ -152,6 +153,9 @@ if (v8_enable_disassembler == \"\") {\n if (v8_enable_trace_maps == \"\") {\n   v8_enable_trace_maps = is_debug\n }\n+if (v8_enable_test_features == \"\") {\n+  v8_enable_test_features = is_debug || dcheck_always_on\n+}\n if (v8_enable_v8_checks == \"\") {\n   v8_enable_v8_checks = is_debug\n }\n@@ -278,6 +282,10 @@ config(\"features\") {\n   if (v8_enable_trace_feedback_updates) {\n     defines += [ \"V8_TRACE_FEEDBACK_UPDATES\" ]\n   }\n+  if (v8_enable_test_features) {\n+    defines += [ \"V8_ENABLE_ALLOCATION_TIMEOUT\" ]\n+    defines += [ \"V8_ENABLE_FORCE_SLOW_PATH\" ]\n+  }\n   if (v8_enable_v8_checks) {\n     defines += [ \"V8_ENABLE_CHECKS\" ]\n   }\n@@ -511,6 +519,12 @@ config(\"toolchain\") {\n       # TODO(hans): Remove once http://crbug.com/428099 is resolved.\n       \"-Winconsistent-missing-override\",\n     ]\n+\n+    if (v8_current_cpu != \"mips\" && v8_current_cpu != \"mipsel\") {\n+      # We exclude MIPS because the IsMipsArchVariant macro causes trouble.\n+      cflags += [ \"-Wunreachable-code\" ]\n+    }\n+\n     if (v8_current_cpu == \"x64\" || v8_current_cpu == \"arm64\" ||\n         v8_current_cpu == \"mips64el\") {\n       cflags += [ \"-Wshorten-64-to-32\" ]\n@@ -575,12 +589,10 @@ action(\"js2c\") {\n     \"src/js/macros.py\",\n     \"src/messages.h\",\n     \"src/js/prologue.js\",\n-    \"src/js/v8natives.js\",\n     \"src/js/array.js\",\n     \"src/js/typedarray.js\",\n     \"src/js/messages.js\",\n     \"src/js/spread.js\",\n-    \"src/js/proxy.js\",\n     \"src/debug/mirrors.js\",\n     \"src/debug/debug.js\",\n     \"src/debug/liveedit.js\",\n@@ -755,6 +767,10 @@ action(\"postmortem-metadata\") {\n     \"src/objects-inl.h\",\n     \"src/objects/code-inl.h\",\n     \"src/objects/code.h\",\n+    \"src/objects/data-handler.h\",\n+    \"src/objects/data-handler-inl.h\",\n+    \"src/objects/fixed-array-inl.h\",\n+    \"src/objects/fixed-array.h\",\n     \"src/objects/js-array-inl.h\",\n     \"src/objects/js-array.h\",\n     \"src/objects/js-regexp-inl.h\",\n@@ -1680,6 +1696,10 @@ v8_source_set(\"v8_base\") {\n     \"src/heap/spaces.h\",\n     \"src/heap/store-buffer.cc\",\n     \"src/heap/store-buffer.h\",\n+    \"src/heap/stress-marking-observer.cc\",\n+    \"src/heap/stress-marking-observer.h\",\n+    \"src/heap/stress-scavenge-observer.cc\",\n+    \"src/heap/stress-scavenge-observer.h\",\n     \"src/heap/sweeper.cc\",\n     \"src/heap/sweeper.h\",\n     \"src/heap/worklist.h\",\n@@ -1803,6 +1823,8 @@ v8_source_set(\"v8_base\") {\n     \"src/objects/debug-objects.h\",\n     \"src/objects/descriptor-array.h\",\n     \"src/objects/dictionary.h\",\n+    \"src/objects/fixed-array-inl.h\",\n+    \"src/objects/fixed-array.h\",\n     \"src/objects/frame-array-inl.h\",\n     \"src/objects/frame-array.h\",\n     \"src/objects/hash-table-inl.h\",\n@@ -1811,6 +1833,8 @@ v8_source_set(\"v8_base\") {\n     \"src/objects/intl-objects.h\",\n     \"src/objects/js-array-inl.h\",\n     \"src/objects/js-array.h\",\n+    \"src/objects/js-collection-inl.h\",\n+    \"src/objects/js-collection.h\",\n     \"src/objects/js-regexp-inl.h\",\n     \"src/objects/js-regexp.h\",\n     \"src/objects/literal-objects-inl.h\",\n@@ -1974,6 +1998,8 @@ v8_source_set(\"v8_base\") {\n     \"src/safepoint-table.h\",\n     \"src/setup-isolate.h\",\n     \"src/signature.h\",\n+    \"src/simulator-base.cc\",\n+    \"src/simulator-base.h\",\n     \"src/simulator.h\",\n     \"src/snapshot/builtin-deserializer-allocator.cc\",\n     \"src/snapshot/builtin-deserializer-allocator.h\",\n@@ -2032,6 +2058,7 @@ v8_source_set(\"v8_base\") {\n     \"src/string-stream.h\",\n     \"src/strtod.cc\",\n     \"src/strtod.h\",\n+    \"src/third_party/utf8-decoder/utf8-decoder.h\",\n     \"src/tracing/trace-event.cc\",\n     \"src/tracing/trace-event.h\",\n     \"src/tracing/traced-value.cc\",\n@@ -2066,16 +2093,20 @@ v8_source_set(\"v8_base\") {\n     \"src/v8threads.h\",\n     \"src/value-serializer.cc\",\n     \"src/value-serializer.h\",\n+    \"src/vector-slot-pair.cc\",\n+    \"src/vector-slot-pair.h\",\n     \"src/vector.h\",\n     \"src/version.cc\",\n     \"src/version.h\",\n     \"src/visitors.cc\",\n     \"src/visitors.h\",\n     \"src/vm-state-inl.h\",\n     \"src/vm-state.h\",\n+    \"src/wasm/baseline/liftoff-assembler-defs.h\",\n     \"src/wasm/baseline/liftoff-assembler.cc\",\n     \"src/wasm/baseline/liftoff-assembler.h\",\n     \"src/wasm/baseline/liftoff-compiler.cc\",\n+    \"src/wasm/baseline/liftoff-register.h\",\n     \"src/wasm/compilation-manager.cc\",\n     \"src/wasm/compilation-manager.h\",\n     \"src/wasm/decoder.h\",\n@@ -2097,15 +2128,18 @@ v8_source_set(\"v8_base\") {\n     \"src/wasm/streaming-decoder.h\",\n     \"src/wasm/wasm-api.cc\",\n     \"src/wasm/wasm-api.h\",\n+    \"src/wasm/wasm-code-manager.cc\",\n+    \"src/wasm/wasm-code-manager.h\",\n     \"src/wasm/wasm-code-specialization.cc\",\n     \"src/wasm/wasm-code-specialization.h\",\n     \"src/wasm/wasm-code-wrapper.cc\",\n     \"src/wasm/wasm-code-wrapper.h\",\n+    \"src/wasm/wasm-constants.h\",\n     \"src/wasm/wasm-debug.cc\",\n+    \"src/wasm/wasm-engine.cc\",\n+    \"src/wasm/wasm-engine.h\",\n     \"src/wasm/wasm-external-refs.cc\",\n     \"src/wasm/wasm-external-refs.h\",\n-    \"src/wasm/wasm-heap.cc\",\n-    \"src/wasm/wasm-heap.h\",\n     \"src/wasm/wasm-interpreter.cc\",\n     \"src/wasm/wasm-interpreter.h\",\n     \"src/wasm/wasm-js.cc\",\n@@ -2184,7 +2218,6 @@ v8_source_set(\"v8_base\") {\n       \"src/ia32/sse-instr.h\",\n       \"src/regexp/ia32/regexp-macro-assembler-ia32.cc\",\n       \"src/regexp/ia32/regexp-macro-assembler-ia32.h\",\n-      \"src/wasm/baseline/ia32/liftoff-assembler-ia32-defs.h\",\n       \"src/wasm/baseline/ia32/liftoff-assembler-ia32.h\",\n     ]\n   } else if (v8_current_cpu == \"x64\") {\n@@ -2199,7 +2232,6 @@ v8_source_set(\"v8_base\") {\n       \"src/regexp/x64/regexp-macro-assembler-x64.cc\",\n       \"src/regexp/x64/regexp-macro-assembler-x64.h\",\n       \"src/third_party/valgrind/valgrind.h\",\n-      \"src/wasm/baseline/x64/liftoff-assembler-x64-defs.h\",\n       \"src/wasm/baseline/x64/liftoff-assembler-x64.h\",\n       \"src/x64/assembler-x64-inl.h\",\n       \"src/x64/assembler-x64.cc\",\n@@ -2253,7 +2285,6 @@ v8_source_set(\"v8_base\") {\n       \"src/debug/arm/debug-arm.cc\",\n       \"src/regexp/arm/regexp-macro-assembler-arm.cc\",\n       \"src/regexp/arm/regexp-macro-assembler-arm.h\",\n-      \"src/wasm/baseline/arm/liftoff-assembler-arm-defs.h\",\n       \"src/wasm/baseline/arm/liftoff-assembler-arm.h\",\n     ]\n   } else if (v8_current_cpu == \"arm64\") {\n@@ -2299,7 +2330,6 @@ v8_source_set(\"v8_base\") {\n       \"src/debug/arm64/debug-arm64.cc\",\n       \"src/regexp/arm64/regexp-macro-assembler-arm64.cc\",\n       \"src/regexp/arm64/regexp-macro-assembler-arm64.h\",\n-      \"src/wasm/baseline/arm64/liftoff-assembler-arm64-defs.h\",\n       \"src/wasm/baseline/arm64/liftoff-assembler-arm64.h\",\n     ]\n     if (use_jumbo_build) {\n@@ -2336,7 +2366,6 @@ v8_source_set(\"v8_base\") {\n       \"src/mips/simulator-mips.h\",\n       \"src/regexp/mips/regexp-macro-assembler-mips.cc\",\n       \"src/regexp/mips/regexp-macro-assembler-mips.h\",\n-      \"src/wasm/baseline/mips/liftoff-assembler-mips-defs.h\",\n       \"src/wasm/baseline/mips/liftoff-assembler-mips.h\",\n     ]\n   } else if (v8_current_cpu == \"mips64\" || v8_current_cpu == \"mips64el\") {\n@@ -2366,7 +2395,6 @@ v8_source_set(\"v8_base\") {\n       \"src/mips64/simulator-mips64.h\",\n       \"src/regexp/mips64/regexp-macro-assembler-mips64.cc\",\n       \"src/regexp/mips64/regexp-macro-assembler-mips64.h\",\n-      \"src/wasm/baseline/mips64/liftoff-assembler-mips64-defs.h\",\n       \"src/wasm/baseline/mips64/liftoff-assembler-mips64.h\",\n     ]\n   } else if (v8_current_cpu == \"ppc\" || v8_current_cpu == \"ppc64\") {\n@@ -2396,7 +2424,6 @@ v8_source_set(\"v8_base\") {\n       \"src/ppc/simulator-ppc.h\",\n       \"src/regexp/ppc/regexp-macro-assembler-ppc.cc\",\n       \"src/regexp/ppc/regexp-macro-assembler-ppc.h\",\n-      \"src/wasm/baseline/ppc/liftoff-assembler-ppc-defs.h\",\n       \"src/wasm/baseline/ppc/liftoff-assembler-ppc.h\",\n     ]\n   } else if (v8_current_cpu == \"s390\" || v8_current_cpu == \"s390x\") {\n@@ -2426,7 +2453,6 @@ v8_source_set(\"v8_base\") {\n       \"src/s390/macro-assembler-s390.h\",\n       \"src/s390/simulator-s390.cc\",\n       \"src/s390/simulator-s390.h\",\n-      \"src/wasm/baseline/s390/liftoff-assembler-s390-defs.h\",\n       \"src/wasm/baseline/s390/liftoff-assembler-s390.h\",\n     ]\n   }\n@@ -2506,6 +2532,8 @@ v8_component(\"v8_libbase\") {\n     \"src/base/once.cc\",\n     \"src/base/once.h\",\n     \"src/base/optional.h\",\n+    \"src/base/page-allocator.cc\",\n+    \"src/base/page-allocator.h\",\n     \"src/base/platform/condition-variable.cc\",\n     \"src/base/platform/condition-variable.h\",\n     \"src/base/platform/elapsed-timer.h\",\n@@ -2812,6 +2840,7 @@ group(\"v8_fuzzers\") {\n   testonly = true\n   deps = [\n     \":v8_simple_json_fuzzer\",\n+    \":v8_simple_multi_return_fuzzer\",\n     \":v8_simple_parser_fuzzer\",\n     \":v8_simple_regexp_fuzzer\",\n     \":v8_simple_wasm_async_fuzzer\",\n@@ -3062,6 +3091,24 @@ v8_source_set(\"json_fuzzer\") {\n v8_fuzzer(\"json_fuzzer\") {\n }\n \n+v8_source_set(\"multi_return_fuzzer\") {\n+  sources = [\n+    \"test/fuzzer/multi-return.cc\",\n+  ]\n+\n+  deps = [\n+    \":fuzzer_support\",\n+  ]\n+\n+  configs = [\n+    \":external_config\",\n+    \":internal_config_base\",\n+  ]\n+}\n+\n+v8_fuzzer(\"multi_return_fuzzer\") {\n+}\n+\n v8_source_set(\"parser_fuzzer\") {\n   sources = [\n     \"test/fuzzer/parser.cc\","
        },
        {
            "sha": "1fe3135a011707b4e5e4299d4633c7ef6ad7dc5a",
            "filename": "deps/v8/ChangeLog",
            "status": "modified",
            "additions": 1300,
            "deletions": 0,
            "changes": 1300,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FChangeLog",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FChangeLog",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FChangeLog?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -1,3 +1,1303 @@\n+2018-01-17: Version 6.5.254\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-17: Version 6.5.253\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-17: Version 6.5.252\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-17: Version 6.5.251\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-17: Version 6.5.250\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-17: Version 6.5.249\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-17: Version 6.5.248\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-17: Version 6.5.247\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-17: Version 6.5.246\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.245\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.244\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.243\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.242\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.241\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.240\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.239\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.238\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.237\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.236\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.235\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.234\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.233\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.232\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.231\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.230\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.229\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.228\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.227\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.226\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.225\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.224\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.223\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.222\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.221\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-16: Version 6.5.220\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.219\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.218\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.217\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.216\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.215\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.214\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.213\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.212\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.211\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.210\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.209\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.208\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.207\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.206\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.205\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.204\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.203\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.202\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.201\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.200\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-15: Version 6.5.199\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-14: Version 6.5.198\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-13: Version 6.5.197\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-12: Version 6.5.196\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-12: Version 6.5.195\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-12: Version 6.5.194\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-12: Version 6.5.193\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-12: Version 6.5.192\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-12: Version 6.5.191\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-12: Version 6.5.190\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-12: Version 6.5.189\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.188\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.187\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.186\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.185\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.184\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.183\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.182\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.181\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.180\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.179\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.178\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.177\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.176\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.175\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.174\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-11: Version 6.5.173\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.172\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.171\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.170\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.169\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.168\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.167\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.166\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.165\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.164\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-10: Version 6.5.163\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.162\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.161\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.160\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.159\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.158\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.157\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.156\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.155\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.154\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.153\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.152\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-09: Version 6.5.151\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-08: Version 6.5.150\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-08: Version 6.5.149\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-08: Version 6.5.148\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-08: Version 6.5.147\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-05: Version 6.5.146\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-05: Version 6.5.145\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-05: Version 6.5.144\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-05: Version 6.5.143\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-05: Version 6.5.142\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-05: Version 6.5.141\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-05: Version 6.5.140\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.139\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.138\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.137\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.136\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.135\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.134\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.133\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.132\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.131\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.130\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.129\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.128\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.127\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-04: Version 6.5.126\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-03: Version 6.5.125\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-03: Version 6.5.124\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-02: Version 6.5.123\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-02: Version 6.5.122\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-02: Version 6.5.121\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-02: Version 6.5.120\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-02: Version 6.5.119\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-02: Version 6.5.118\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-01-02: Version 6.5.117\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-29: Version 6.5.116\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-29: Version 6.5.115\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-29: Version 6.5.114\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-29: Version 6.5.113\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-29: Version 6.5.112\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-29: Version 6.5.111\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-28: Version 6.5.110\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-28: Version 6.5.109\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-27: Version 6.5.108\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-22: Version 6.5.107\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-22: Version 6.5.106\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-22: Version 6.5.105\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-22: Version 6.5.104\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-21: Version 6.5.103\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-21: Version 6.5.102\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.101\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.100\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.99\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.98\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.97\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.96\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.95\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.94\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.93\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.92\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.91\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-20: Version 6.5.90\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.89\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.88\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.87\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.86\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.85\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.84\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.83\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.82\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.81\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.80\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.79\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.78\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-19: Version 6.5.77\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-18: Version 6.5.76\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-18: Version 6.5.75\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-18: Version 6.5.74\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-16: Version 6.5.73\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-15: Version 6.5.72\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-15: Version 6.5.71\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-15: Version 6.5.70\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-14: Version 6.5.69\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-14: Version 6.5.68\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-13: Version 6.5.67\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-13: Version 6.5.66\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-13: Version 6.5.65\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.64\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.63\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.62\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.61\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.60\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.59\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.58\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.57\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.56\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.55\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.54\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-12: Version 6.5.53\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.52\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.51\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.50\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.49\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.48\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.47\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.46\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.45\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.44\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.43\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-11: Version 6.5.42\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-10: Version 6.5.41\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-10: Version 6.5.40\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-09: Version 6.5.39\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-09: Version 6.5.38\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.37\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.36\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.35\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.34\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.33\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.32\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.31\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.30\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.29\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.28\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-08: Version 6.5.27\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.26\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.25\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.24\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.23\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.22\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.21\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.20\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.19\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.18\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.17\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.16\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-07: Version 6.5.15\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-06: Version 6.5.14\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-06: Version 6.5.13\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-05: Version 6.5.12\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-05: Version 6.5.11\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-05: Version 6.5.10\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-05: Version 6.5.9\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-05: Version 6.5.8\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-04: Version 6.5.7\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-04: Version 6.5.6\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-04: Version 6.5.5\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-04: Version 6.5.4\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-04: Version 6.5.3\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-04: Version 6.5.2\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-12-03: Version 6.5.1\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-11-30: Version 6.4.394\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-11-30: Version 6.4.393\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-11-29: Version 6.4.392\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-11-29: Version 6.4.391\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-11-29: Version 6.4.390\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2017-11-29: Version 6.4.389\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n 2017-11-29: Version 6.4.388\n \n         Performance and stability improvements on all platforms."
        },
        {
            "sha": "bc9e4e0a90c8af9bcad01c680c1c21483451a4cb",
            "filename": "deps/v8/DEPS",
            "status": "modified",
            "additions": 29,
            "deletions": 18,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FDEPS",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FDEPS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FDEPS?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -5,27 +5,32 @@\n vars = {\n   'checkout_instrumented_libraries': False,\n   'chromium_url': 'https://chromium.googlesource.com',\n+  'build_for_node': False,\n }\n \n deps = {\n   'v8/build':\n-    Var('chromium_url') + '/chromium/src/build.git' + '@' + '9338ce52d0b9bcef34c38285fbd5023b62739fac',\n+    Var('chromium_url') + '/chromium/src/build.git' + '@' + 'b3a78cd03a95c30ff10f863f736249eb04f0f34d',\n   'v8/tools/gyp':\n     Var('chromium_url') + '/external/gyp.git' + '@' + 'd61a9397e668fa9843c4aa7da9e79460fe590bfb',\n   'v8/third_party/icu':\n-    Var('chromium_url') + '/chromium/deps/icu.git' + '@' + '741688ebf328da9adc52505248bf4e2ef868722c',\n+    Var('chromium_url') + '/chromium/deps/icu.git' + '@' + 'c8ca2962b46670ec89071ffd1291688983cd319c',\n   'v8/third_party/instrumented_libraries':\n-    Var('chromium_url') + '/chromium/src/third_party/instrumented_libraries.git' + '@' + '28417458ac4dc79f68915079d0f283f682504cc0',\n+    Var('chromium_url') + '/chromium/src/third_party/instrumented_libraries.git' + '@' + 'b7578b4132cf73ca3265e2ee0b7bd0a422a54ebf',\n   'v8/buildtools':\n-    Var('chromium_url') + '/chromium/buildtools.git' + '@' + '505de88083136eefd056e5ee4ca0f01fe9b33de8',\n+    Var('chromium_url') + '/chromium/buildtools.git' + '@' + '6fe4a3251488f7af86d64fc25cf442e817cf6133',\n   'v8/base/trace_event/common':\n     Var('chromium_url') + '/chromium/src/base/trace_event/common.git' + '@' + '0e9a47d74970bee1bbfc063c47215406f8918699',\n+  'v8/third_party/android_ndk': {\n+    'url': Var('chromium_url') + '/android_ndk.git' + '@' + 'e951c37287c7d8cd915bf8d4149fd4a06d808b55',\n+    'condition': 'checkout_android',\n+  },\n   'v8/third_party/android_tools': {\n-    'url': Var('chromium_url') + '/android_tools.git' + '@' + 'a2e9bc7c1b41d983577907df51d339fb1e0fd02f',\n+    'url': Var('chromium_url') + '/android_tools.git' + '@' + 'c78b25872734e0038ae2a333edc645cd96bc232d',\n     'condition': 'checkout_android',\n   },\n   'v8/third_party/catapult': {\n-    'url': Var('chromium_url') + '/catapult.git' + '@' + '11d7efb857ae77eff1cea4640e3f3d9ac49cba0a',\n+    'url': Var('chromium_url') + '/catapult.git' + '@' + 'b4826a52853c9c2778d496f6c6fa853f777f94df',\n     'condition': 'checkout_android',\n   },\n   'v8/third_party/colorama/src': {\n@@ -37,7 +42,7 @@ deps = {\n   'v8/third_party/markupsafe':\n     Var('chromium_url') + '/chromium/src/third_party/markupsafe.git' + '@' + '8f45f5cfa0009d2a70589bcda0349b8cb2b72783',\n   'v8/tools/swarming_client':\n-    Var('chromium_url') + '/infra/luci/client-py.git' + '@' + '4bd9152f8a975d57c972c071dfb4ddf668e02200',\n+    Var('chromium_url') + '/infra/luci/client-py.git' + '@' + '88229872dd17e71658fe96763feaa77915d8cbd6',\n   'v8/testing/gtest':\n     Var('chromium_url') + '/external/github.com/google/googletest.git' + '@' + '6f8a66431cb592dad629028a50b3dd418a408c87',\n   'v8/testing/gmock':\n@@ -47,15 +52,15 @@ deps = {\n   'v8/test/mozilla/data':\n     Var('chromium_url') + '/v8/deps/third_party/mozilla-tests.git' + '@' + 'f6c578a10ea707b1a8ab0b88943fe5115ce2b9be',\n   'v8/test/test262/data':\n-    Var('chromium_url') + '/external/github.com/tc39/test262.git' + '@' + '5d4c667b271a9b39d0de73aef5ffe6879c6f8811',\n+    Var('chromium_url') + '/external/github.com/tc39/test262.git' + '@' + '8311965251953d4745aeb68c98fb71fab2eac1d0',\n   'v8/test/test262/harness':\n     Var('chromium_url') + '/external/github.com/test262-utils/test262-harness-py.git' + '@' + '0f2acdd882c84cff43b9d60df7574a1901e2cdcd',\n   'v8/tools/clang':\n-    Var('chromium_url') + '/chromium/src/tools/clang.git' + '@' + '8688d267571de76a56746324dcc249bf4232b85a',\n+    Var('chromium_url') + '/chromium/src/tools/clang.git' + '@' + '27088876ff821e8a1518383576a43662a3255d56',\n   'v8/tools/luci-go':\n-    Var('chromium_url') + '/chromium/src/tools/luci-go.git' + '@' + '45a8a51fda92e123619a69e7644d9c64a320b0c1',\n+    Var('chromium_url') + '/chromium/src/tools/luci-go.git' + '@' + 'd882048313f6f51df29856406fa03b620c1d0205',\n   'v8/test/wasm-js':\n-    Var('chromium_url') + '/external/github.com/WebAssembly/spec.git' + '@' + 'a7e226a92e660a3d5413cfea4269824f513259d2',\n+    Var('chromium_url') + '/external/github.com/WebAssembly/spec.git' + '@' + 'a25083ac7076b05e3f304ec9e093ef1b1ee09422',\n }\n \n recursedeps = [\n@@ -93,7 +98,7 @@ hooks = [\n   {\n     'name': 'clang_format_win',\n     'pattern': '.',\n-    'condition': 'host_os == \"win\"',\n+    'condition': 'host_os == \"win\" and build_for_node != True',\n     'action': [ 'download_from_google_storage',\n                 '--no_resume',\n                 '--platform=win32',\n@@ -105,7 +110,7 @@ hooks = [\n   {\n     'name': 'clang_format_mac',\n     'pattern': '.',\n-    'condition': 'host_os == \"mac\"',\n+    'condition': 'host_os == \"mac\" and build_for_node != True',\n     'action': [ 'download_from_google_storage',\n                 '--no_resume',\n                 '--platform=darwin',\n@@ -117,7 +122,7 @@ hooks = [\n   {\n     'name': 'clang_format_linux',\n     'pattern': '.',\n-    'condition': 'host_os == \"linux\"',\n+    'condition': 'host_os == \"linux\" and build_for_node != True',\n     'action': [ 'download_from_google_storage',\n                 '--no_resume',\n                 '--platform=linux*',\n@@ -129,6 +134,7 @@ hooks = [\n   {\n     'name': 'gcmole',\n     'pattern': '.',\n+    'condition': 'build_for_node != True',\n     # TODO(machenbach): Insert condition and remove GYP_DEFINES dependency.\n     'action': [\n         'python',\n@@ -138,6 +144,7 @@ hooks = [\n   {\n     'name': 'jsfunfuzz',\n     'pattern': '.',\n+    'condition': 'build_for_node != True',\n     # TODO(machenbach): Insert condition and remove GYP_DEFINES dependency.\n     'action': [\n         'python',\n@@ -148,7 +155,7 @@ hooks = [\n   {\n     'name': 'luci-go_win',\n     'pattern': '.',\n-    'condition': 'host_os == \"win\"',\n+    'condition': 'host_os == \"win\" and build_for_node != True',\n     'action': [ 'download_from_google_storage',\n                 '--no_resume',\n                 '--platform=win32',\n@@ -160,7 +167,7 @@ hooks = [\n   {\n     'name': 'luci-go_mac',\n     'pattern': '.',\n-    'condition': 'host_os == \"mac\"',\n+    'condition': 'host_os == \"mac\" and build_for_node != True',\n     'action': [ 'download_from_google_storage',\n                 '--no_resume',\n                 '--platform=darwin',\n@@ -172,7 +179,7 @@ hooks = [\n   {\n     'name': 'luci-go_linux',\n     'pattern': '.',\n-    'condition': 'host_os == \"linux\"',\n+    'condition': 'host_os == \"linux\" and build_for_node != True',\n     'action': [ 'download_from_google_storage',\n                 '--no_resume',\n                 '--platform=linux*',\n@@ -221,6 +228,7 @@ hooks = [\n   {\n     'name': 'wasm_spec_tests',\n     'pattern': '.',\n+    'condition': 'build_for_node != True',\n     'action': [ 'download_from_google_storage',\n                 '--no_resume',\n                 '--no_auth',\n@@ -232,6 +240,7 @@ hooks = [\n   {\n     'name': 'closure_compiler',\n     'pattern': '.',\n+    'condition': 'build_for_node != True',\n     'action': [ 'download_from_google_storage',\n                 '--no_resume',\n                 '--no_auth',\n@@ -246,6 +255,7 @@ hooks = [\n     # change.\n     'name': 'sysroot',\n     'pattern': '.',\n+    'condition': 'build_for_node != True',\n     'action': [\n         'python',\n         'v8/build/linux/sysroot_scripts/install-sysroot.py',\n@@ -287,7 +297,7 @@ hooks = [\n   {\n     'name': 'binutils',\n     'pattern': 'v8/third_party/binutils',\n-    'condition': 'host_os == \"linux\"',\n+    'condition': 'host_os == \"linux\" and build_for_node != True',\n     'action': [\n         'python',\n         'v8/third_party/binutils/download.py',\n@@ -313,6 +323,7 @@ hooks = [\n     # A change to a .gyp, .gypi, or to GYP itself should run the generator.\n     'name': 'regyp_if_needed',\n     'pattern': '.',\n+    'condition': 'build_for_node != True',\n     'action': ['python', 'v8/gypfiles/gyp_v8', '--running-as-hook'],\n   },\n   # Download and initialize \"vpython\" VirtualEnv environment packages."
        },
        {
            "sha": "b69e8f5089168c9ee8acbb0051769bf377b57e54",
            "filename": "deps/v8/PRESUBMIT.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FPRESUBMIT.py",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2FPRESUBMIT.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FPRESUBMIT.py?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -430,6 +430,6 @@ def affects_intl(f):\n   return output_api.EnsureCQIncludeTrybotsAreAdded(\n       cl,\n       [\n-        'master.tryserver.v8:v8_linux_noi18n_rel_ng'\n+        'luci.v8.try:v8_linux_noi18n_rel_ng'\n       ],\n       'Automatically added noi18n trybots to run tests on CQ.')"
        },
        {
            "sha": "e4dcf1cc46a8205be425b51d554dd007d7e6f384",
            "filename": "deps/v8/build_overrides/build.gni",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fbuild_overrides%2Fbuild.gni",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fbuild_overrides%2Fbuild.gni",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fbuild_overrides%2Fbuild.gni?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -8,7 +8,7 @@ build_with_chromium = false\n \n # Uncomment these to specify a different NDK location and version in\n # non-Chromium builds.\n-# default_android_ndk_root = \"//third_party/android_tools/ndk\"\n+# default_android_ndk_root = \"//third_party/android_ndk\"\n # default_android_ndk_version = \"r10e\"\n \n # Some non-Chromium builds don't support building java targets."
        },
        {
            "sha": "ce9953ac68ce1fff8edc552e676fab38adf017a9",
            "filename": "deps/v8/gni/v8.gni",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fgni%2Fv8.gni",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fgni%2Fv8.gni",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fgni%2Fv8.gni?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -45,6 +45,9 @@ declare_args() {\n \n   # Use static libraries instead of source_sets.\n   v8_static_library = false\n+\n+  # Enable monolithic static library for embedders.\n+  v8_monolithic = false\n }\n \n if (v8_use_external_startup_data == \"\") {\n@@ -97,7 +100,7 @@ if (v8_code_coverage && !is_clang) {\n   ]\n }\n \n-if (is_posix && v8_enable_backtrace) {\n+if (is_posix && (v8_enable_backtrace || v8_monolithic)) {\n   v8_remove_configs += [ \"//build/config/gcc:symbol_visibility_hidden\" ]\n   v8_add_configs += [ \"//build/config/gcc:symbol_visibility_default\" ]\n }"
        },
        {
            "sha": "2f9cf858c03c74e61d4a49a7f715dbc2ef245a31",
            "filename": "deps/v8/gypfiles/all.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fgypfiles%2Fall.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fgypfiles%2Fall.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fgypfiles%2Fall.gyp?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -33,6 +33,7 @@\n             '../test/benchmarks/benchmarks.gyp:*',\n             '../test/debugger/debugger.gyp:*',\n             '../test/default.gyp:*',\n+            '../test/d8_default.gyp:*',\n             '../test/intl/intl.gyp:*',\n             '../test/message/message.gyp:*',\n             '../test/mjsunit/mjsunit.gyp:*',"
        },
        {
            "sha": "ec47f1c0abc2be3f4551b90945131715bab35998",
            "filename": "deps/v8/gypfiles/standalone.gypi",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fgypfiles%2Fstandalone.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fgypfiles%2Fstandalone.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fgypfiles%2Fstandalone.gypi?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -296,7 +296,7 @@\n           'variables': {\n             # The Android toolchain needs to use the absolute path to the NDK\n             # because it is used at different levels in the GYP files.\n-            'android_ndk_root%': '<(base_dir)/third_party/android_tools/ndk/',\n+            'android_ndk_root%': '<(base_dir)/third_party/android_ndk/',\n             'android_host_arch%': \"<!(uname -m | sed -e 's/i[3456]86/x86/')\",\n             # Version of the NDK. Used to ensure full rebuilds on NDK rolls.\n             'android_ndk_version%': 'r12b',"
        },
        {
            "sha": "6de8234fb83bcf7f792888d4dce9a1beb37f6243",
            "filename": "deps/v8/include/v8-inspector.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finclude%2Fv8-inspector.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finclude%2Fv8-inspector.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8-inspector.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -149,8 +149,9 @@ class V8_EXPORT V8InspectorSession {\n \n   // Remote objects.\n   virtual std::unique_ptr<protocol::Runtime::API::RemoteObject> wrapObject(\n-      v8::Local<v8::Context>, v8::Local<v8::Value>,\n-      const StringView& groupName) = 0;\n+      v8::Local<v8::Context>, v8::Local<v8::Value>, const StringView& groupName,\n+      bool generatePreview) = 0;\n+\n   virtual bool unwrapObject(std::unique_ptr<StringBuffer>* error,\n                             const StringView& objectId, v8::Local<v8::Value>*,\n                             v8::Local<v8::Context>*,"
        },
        {
            "sha": "2bb14df93e9badb6ec5571d6c5b8838ef2fb10c2",
            "filename": "deps/v8/include/v8-platform.h",
            "status": "modified",
            "additions": 91,
            "deletions": 1,
            "changes": 92,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finclude%2Fv8-platform.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finclude%2Fv8-platform.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8-platform.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -166,6 +166,74 @@ class TracingController {\n   virtual void RemoveTraceStateObserver(TraceStateObserver*) {}\n };\n \n+/**\n+ * A V8 memory page allocator.\n+ *\n+ * Can be implemented by an embedder to manage large host OS allocations.\n+ */\n+class PageAllocator {\n+ public:\n+  virtual ~PageAllocator() = default;\n+\n+  /**\n+   * Gets the page granularity for AllocatePages and FreePages. Addresses and\n+   * lengths for those calls should be multiples of AllocatePageSize().\n+   */\n+  virtual size_t AllocatePageSize() = 0;\n+\n+  /**\n+   * Gets the page granularity for SetPermissions and ReleasePages. Addresses\n+   * and lengths for those calls should be multiples of CommitPageSize().\n+   */\n+  virtual size_t CommitPageSize() = 0;\n+\n+  /**\n+   * Sets the random seed so that GetRandomMmapAddr() will generate repeatable\n+   * sequences of random mmap addresses.\n+   */\n+  virtual void SetRandomMmapSeed(int64_t seed) = 0;\n+\n+  /**\n+   * Returns a randomized address, suitable for memory allocation under ASLR.\n+   * The address will be aligned to AllocatePageSize.\n+   */\n+  virtual void* GetRandomMmapAddr() = 0;\n+\n+  /**\n+   * Memory permissions.\n+   */\n+  enum Permission {\n+    kNoAccess,\n+    kReadWrite,\n+    // TODO(hpayer): Remove this flag. Memory should never be rwx.\n+    kReadWriteExecute,\n+    kReadExecute\n+  };\n+\n+  /**\n+   * Allocates memory in range with the given alignment and permission.\n+   */\n+  virtual void* AllocatePages(void* address, size_t length, size_t alignment,\n+                              Permission permissions) = 0;\n+\n+  /**\n+   * Frees memory in a range that was allocated by a call to AllocatePages.\n+   */\n+  virtual bool FreePages(void* address, size_t length) = 0;\n+\n+  /**\n+   * Releases memory in a range that was allocated by a call to AllocatePages.\n+   */\n+  virtual bool ReleasePages(void* address, size_t length,\n+                            size_t new_length) = 0;\n+\n+  /**\n+   * Sets permissions on pages in an allocated range.\n+   */\n+  virtual bool SetPermissions(void* address, size_t length,\n+                              Permission permissions) = 0;\n+};\n+\n /**\n  * V8 Platform abstraction layer.\n  *\n@@ -186,14 +254,36 @@ class Platform {\n \n   virtual ~Platform() = default;\n \n+  /**\n+   * Allows the embedder to manage memory page allocations.\n+   */\n+  virtual PageAllocator* GetPageAllocator() {\n+    // TODO(bbudge) Make this abstract after all embedders implement this.\n+    return nullptr;\n+  }\n+\n   /**\n    * Enables the embedder to respond in cases where V8 can't allocate large\n    * blocks of memory. V8 retries the failed allocation once after calling this\n    * method. On success, execution continues; otherwise V8 exits with a fatal\n    * error.\n    * Embedder overrides of this function must NOT call back into V8.\n    */\n-  virtual void OnCriticalMemoryPressure() {}\n+  virtual void OnCriticalMemoryPressure() {\n+    // TODO(bbudge) Remove this when embedders override the following method.\n+    // See crbug.com/634547.\n+  }\n+\n+  /**\n+   * Enables the embedder to respond in cases where V8 can't allocate large\n+   * memory regions. The |length| parameter is the amount of memory needed.\n+   * Returns true if memory is now available. Returns false if no memory could\n+   * be made available. V8 will retry allocations until this method returns\n+   * false.\n+   *\n+   * Embedder overrides of this function must NOT call back into V8.\n+   */\n+  virtual bool OnCriticalMemoryPressure(size_t length) { return false; }\n \n   /**\n    * Gets the number of threads that are used to execute background tasks. Is"
        },
        {
            "sha": "6cc98294ec5179965f601d87bbd976c6e09a7641",
            "filename": "deps/v8/include/v8-version.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finclude%2Fv8-version.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finclude%2Fv8-version.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8-version.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -9,9 +9,9 @@\n // NOTE these macros are used by some of the tool scripts and the build\n // system so their names cannot be changed without changing the scripts.\n #define V8_MAJOR_VERSION 6\n-#define V8_MINOR_VERSION 4\n-#define V8_BUILD_NUMBER 388\n-#define V8_PATCH_LEVEL 46\n+#define V8_MINOR_VERSION 5\n+#define V8_BUILD_NUMBER 254\n+#define V8_PATCH_LEVEL 31\n \n // Use 1 for candidates and 0 otherwise.\n // (Boolean macro values are not supported by all preprocessors.)"
        },
        {
            "sha": "acb3efbc711d57b0a18ed0d37628c524f879c14c",
            "filename": "deps/v8/include/v8.h",
            "status": "modified",
            "additions": 190,
            "deletions": 376,
            "changes": 566,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finclude%2Fv8.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finclude%2Fv8.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -313,6 +313,7 @@ class Local {\n   friend class String;\n   friend class Object;\n   friend class Context;\n+  friend class Isolate;\n   friend class Private;\n   template<class F> friend class internal::CustomArguments;\n   friend Local<Primitive> Undefined(Isolate* isolate);\n@@ -1129,15 +1130,15 @@ class V8_EXPORT Location {\n };\n \n /**\n- * This is an unfinished experimental feature, and is only exposed\n- * here for internal testing purposes. DO NOT USE.\n- *\n  * A compiled JavaScript module.\n  */\n class V8_EXPORT Module {\n  public:\n   /**\n    * The different states a module can be in.\n+   * This corresponds to the states used in ECMAScript except that \"evaluated\"\n+   * is split into kEvaluated and kErrored, indicating success and failure,\n+   * respectively.\n    */\n   enum Status {\n     kUninstantiated,\n@@ -1191,9 +1192,6 @@ class V8_EXPORT Module {\n    * instantiation. (In the case where the callback throws an exception, that\n    * exception is propagated.)\n    */\n-  V8_DEPRECATED(\"Use Maybe<bool> version\",\n-                bool Instantiate(Local<Context> context,\n-                                 ResolveCallback callback));\n   V8_WARN_UNUSED_RESULT Maybe<bool> InstantiateModule(Local<Context> context,\n                                                       ResolveCallback callback);\n \n@@ -1423,7 +1421,8 @@ class V8_EXPORT ScriptCompiler {\n     kConsumeParserCache,\n     kProduceCodeCache,\n     kProduceFullCodeCache,\n-    kConsumeCodeCache\n+    kConsumeCodeCache,\n+    kEagerCompile\n   };\n \n   /**\n@@ -1443,7 +1442,8 @@ class V8_EXPORT ScriptCompiler {\n     kNoCacheBecauseExtensionModule,\n     kNoCacheBecausePacScript,\n     kNoCacheBecauseInDocumentWrite,\n-    kNoCacheBecauseResourceWithNoCacheHandler\n+    kNoCacheBecauseResourceWithNoCacheHandler,\n+    kNoCacheBecauseDeferredProduceCodeCache\n   };\n \n   /**\n@@ -1459,11 +1459,6 @@ class V8_EXPORT ScriptCompiler {\n    * \\return Compiled script object (context independent; for running it must be\n    *   bound to a context).\n    */\n-  static V8_DEPRECATED(\"Use maybe version\",\n-                       Local<UnboundScript> CompileUnbound(\n-                           Isolate* isolate, Source* source,\n-                           CompileOptions options = kNoCompileOptions,\n-                           NoCacheReason no_cache_reason = kNoCacheNoReason));\n   static V8_WARN_UNUSED_RESULT MaybeLocal<UnboundScript> CompileUnboundScript(\n       Isolate* isolate, Source* source,\n       CompileOptions options = kNoCompileOptions,\n@@ -1480,11 +1475,6 @@ class V8_EXPORT ScriptCompiler {\n    *   when this function was called. When run it will always use this\n    *   context.\n    */\n-  static V8_DEPRECATED(\n-      \"Use maybe version\",\n-      Local<Script> Compile(Isolate* isolate, Source* source,\n-                            CompileOptions options = kNoCompileOptions,\n-                            NoCacheReason no_cache_reason = kNoCacheNoReason));\n   static V8_WARN_UNUSED_RESULT MaybeLocal<Script> Compile(\n       Local<Context> context, Source* source,\n       CompileOptions options = kNoCompileOptions,\n@@ -1512,11 +1502,6 @@ class V8_EXPORT ScriptCompiler {\n    * (ScriptStreamingTask has been run). V8 doesn't construct the source string\n    * during streaming, so the embedder needs to pass the full source here.\n    */\n-  static V8_DEPRECATED(\"Use maybe version\",\n-                       Local<Script> Compile(Isolate* isolate,\n-                                             StreamedSource* source,\n-                                             Local<String> full_source_string,\n-                                             const ScriptOrigin& origin));\n   static V8_WARN_UNUSED_RESULT MaybeLocal<Script> Compile(\n       Local<Context> context, StreamedSource* source,\n       Local<String> full_source_string, const ScriptOrigin& origin);\n@@ -1542,9 +1527,6 @@ class V8_EXPORT ScriptCompiler {\n   static uint32_t CachedDataVersionTag();\n \n   /**\n-   * This is an unfinished experimental feature, and is only exposed\n-   * here for internal testing purposes. DO NOT USE.\n-   *\n    * Compile an ES module, returning a Module that encapsulates\n    * the compiled code.\n    *\n@@ -1576,6 +1558,14 @@ class V8_EXPORT ScriptCompiler {\n       Local<String> arguments[], size_t context_extension_count,\n       Local<Object> context_extensions[]);\n \n+  /**\n+   * Creates and returns code cache for the specified unbound_script.\n+   * This will return nullptr if the script cannot be serialized. The\n+   * CachedData returned by this function should be owned by the caller.\n+   */\n+  static CachedData* CreateCodeCache(Local<UnboundScript> unbound_script,\n+                                     Local<String> source);\n+\n  private:\n   static V8_WARN_UNUSED_RESULT MaybeLocal<UnboundScript> CompileUnboundInternal(\n       Isolate* isolate, Source* source, CompileOptions options,\n@@ -1647,7 +1637,6 @@ class V8_EXPORT Message {\n    * Returns the index within the line of the last character where\n    * the error occurred.\n    */\n-  V8_DEPRECATED(\"Use maybe version\", int GetEndColumn() const);\n   V8_WARN_UNUSED_RESULT Maybe<int> GetEndColumn(Local<Context> context) const;\n \n   /**\n@@ -1703,11 +1692,6 @@ class V8_EXPORT StackTrace {\n    */\n   int GetFrameCount() const;\n \n-  /**\n-   * Returns StackTrace as a v8::Array that contains StackFrame objects.\n-   */\n-  V8_DEPRECATED(\"Use native API instead\", Local<Array> AsArray());\n-\n   /**\n    * Grab a snapshot of the current JavaScript execution stack.\n    *\n@@ -1829,8 +1813,6 @@ class V8_EXPORT JSON {\n    * \\param json_string The string to parse.\n    * \\return The corresponding value if successfully parsed.\n    */\n-  static V8_DEPRECATED(\"Use the maybe version taking context\",\n-                       Local<Value> Parse(Local<String> json_string));\n   static V8_DEPRECATE_SOON(\"Use the maybe version taking context\",\n                            MaybeLocal<Value> Parse(Isolate* isolate,\n                                                    Local<String> json_string));\n@@ -2366,34 +2348,24 @@ class V8_EXPORT Value : public Data {\n                     Local<Number> ToNumber(Isolate* isolate) const);\n   V8_DEPRECATE_SOON(\"Use maybe version\",\n                     Local<String> ToString(Isolate* isolate) const);\n-  V8_DEPRECATED(\"Use maybe version\",\n-                Local<String> ToDetailString(Isolate* isolate) const);\n   V8_DEPRECATE_SOON(\"Use maybe version\",\n                     Local<Object> ToObject(Isolate* isolate) const);\n   V8_DEPRECATE_SOON(\"Use maybe version\",\n                     Local<Integer> ToInteger(Isolate* isolate) const);\n-  V8_DEPRECATED(\"Use maybe version\",\n-                Local<Uint32> ToUint32(Isolate* isolate) const);\n   V8_DEPRECATE_SOON(\"Use maybe version\",\n                     Local<Int32> ToInt32(Isolate* isolate) const);\n \n   inline V8_DEPRECATE_SOON(\"Use maybe version\",\n                            Local<Boolean> ToBoolean() const);\n-  inline V8_DEPRECATED(\"Use maybe version\", Local<Number> ToNumber() const);\n   inline V8_DEPRECATE_SOON(\"Use maybe version\", Local<String> ToString() const);\n-  inline V8_DEPRECATED(\"Use maybe version\",\n-                       Local<String> ToDetailString() const);\n   inline V8_DEPRECATE_SOON(\"Use maybe version\", Local<Object> ToObject() const);\n   inline V8_DEPRECATE_SOON(\"Use maybe version\",\n                            Local<Integer> ToInteger() const);\n-  inline V8_DEPRECATED(\"Use maybe version\", Local<Uint32> ToUint32() const);\n-  inline V8_DEPRECATED(\"Use maybe version\", Local<Int32> ToInt32() const);\n \n   /**\n    * Attempts to convert a string to an array index.\n    * Returns an empty handle if the conversion fails.\n    */\n-  V8_DEPRECATED(\"Use maybe version\", Local<Uint32> ToArrayIndex() const);\n   V8_WARN_UNUSED_RESULT MaybeLocal<Uint32> ToArrayIndex(\n       Local<Context> context) const;\n \n@@ -2724,13 +2696,6 @@ class V8_EXPORT String : public Name {\n       Isolate* isolate, const char* data, v8::NewStringType type,\n       int length = -1);\n \n-  /** Allocates a new string from Latin-1 data.*/\n-  static V8_DEPRECATED(\n-      \"Use maybe version\",\n-      Local<String> NewFromOneByte(Isolate* isolate, const uint8_t* data,\n-                                   NewStringType type = kNormalString,\n-                                   int length = -1));\n-\n   /** Allocates a new string from Latin-1 data.  Only returns an empty value\n    * when length > kMaxLength. **/\n   static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewFromOneByte(\n@@ -2764,9 +2729,6 @@ class V8_EXPORT String : public Name {\n    * should the underlying buffer be deallocated or modified except through the\n    * destructor of the external string resource.\n    */\n-  static V8_DEPRECATED(\"Use maybe version\",\n-                       Local<String> NewExternal(\n-                           Isolate* isolate, ExternalStringResource* resource));\n   static V8_WARN_UNUSED_RESULT MaybeLocal<String> NewExternalTwoByte(\n       Isolate* isolate, ExternalStringResource* resource);\n \n@@ -2951,8 +2913,12 @@ class V8_EXPORT Private : public Data {\n    */\n   static Local<Private> ForApi(Isolate* isolate, Local<String> name);\n \n+  V8_INLINE static Private* Cast(Data* data);\n+\n  private:\n   Private();\n+\n+  static void CheckCast(Data* that);\n };\n \n \n@@ -3152,19 +3118,6 @@ class V8_EXPORT Object : public Value {\n   V8_WARN_UNUSED_RESULT Maybe<bool> DefineProperty(\n       Local<Context> context, Local<Name> key, PropertyDescriptor& descriptor);\n \n-  // Sets an own property on this object bypassing interceptors and\n-  // overriding accessors or read-only properties.\n-  //\n-  // Note that if the object has an interceptor the property will be set\n-  // locally, but since the interceptor takes precedence the local property\n-  // will only be returned if the interceptor doesn't return a value.\n-  //\n-  // Note also that this only works for named properties.\n-  V8_DEPRECATED(\"Use CreateDataProperty / DefineOwnProperty\",\n-                Maybe<bool> ForceSet(Local<Context> context, Local<Value> key,\n-                                     Local<Value> value,\n-                                     PropertyAttribute attribs = None));\n-\n   V8_DEPRECATE_SOON(\"Use maybe version\", Local<Value> Get(Local<Value> key));\n   V8_WARN_UNUSED_RESULT MaybeLocal<Value> Get(Local<Context> context,\n                                               Local<Value> key);\n@@ -3178,16 +3131,12 @@ class V8_EXPORT Object : public Value {\n    * any combination of ReadOnly, DontEnum and DontDelete. Returns\n    * None when the property doesn't exist.\n    */\n-  V8_DEPRECATED(\"Use maybe version\",\n-                PropertyAttribute GetPropertyAttributes(Local<Value> key));\n   V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute> GetPropertyAttributes(\n       Local<Context> context, Local<Value> key);\n \n   /**\n    * Returns Object.getOwnPropertyDescriptor as per ES2016 section 19.1.2.6.\n    */\n-  V8_DEPRECATED(\"Use maybe version\",\n-                Local<Value> GetOwnPropertyDescriptor(Local<Name> key));\n   V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetOwnPropertyDescriptor(\n       Local<Context> context, Local<Name> key);\n \n@@ -3214,28 +3163,12 @@ class V8_EXPORT Object : public Value {\n   V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,\n                                            Local<Value> key);\n \n-  V8_DEPRECATED(\"Use maybe version\", bool Has(uint32_t index));\n   V8_WARN_UNUSED_RESULT Maybe<bool> Has(Local<Context> context,\n                                         uint32_t index);\n \n-  V8_DEPRECATED(\"Use maybe version\", bool Delete(uint32_t index));\n   V8_WARN_UNUSED_RESULT Maybe<bool> Delete(Local<Context> context,\n                                            uint32_t index);\n \n-  V8_DEPRECATED(\"Use maybe version\",\n-                bool SetAccessor(Local<String> name,\n-                                 AccessorGetterCallback getter,\n-                                 AccessorSetterCallback setter = 0,\n-                                 Local<Value> data = Local<Value>(),\n-                                 AccessControl settings = DEFAULT,\n-                                 PropertyAttribute attribute = None));\n-  V8_DEPRECATED(\"Use maybe version\",\n-                bool SetAccessor(Local<Name> name,\n-                                 AccessorNameGetterCallback getter,\n-                                 AccessorNameSetterCallback setter = 0,\n-                                 Local<Value> data = Local<Value>(),\n-                                 AccessControl settings = DEFAULT,\n-                                 PropertyAttribute attribute = None));\n   V8_WARN_UNUSED_RESULT Maybe<bool> SetAccessor(Local<Context> context,\n                           Local<Name> name,\n                           AccessorNameGetterCallback getter,\n@@ -3314,7 +3247,6 @@ class V8_EXPORT Object : public Value {\n    * be skipped by __proto__ and it does not consult the security\n    * handler.\n    */\n-  V8_DEPRECATED(\"Use maybe version\", bool SetPrototype(Local<Value> prototype));\n   V8_WARN_UNUSED_RESULT Maybe<bool> SetPrototype(Local<Context> context,\n                                                  Local<Value> prototype);\n \n@@ -3329,7 +3261,6 @@ class V8_EXPORT Object : public Value {\n    * This is different from Value::ToString() that may call\n    * user-defined toString function. This one does not.\n    */\n-  V8_DEPRECATED(\"Use maybe version\", Local<String> ObjectProtoToString());\n   V8_WARN_UNUSED_RESULT MaybeLocal<String> ObjectProtoToString(\n       Local<Context> context);\n \n@@ -3380,9 +3311,6 @@ class V8_EXPORT Object : public Value {\n   void SetAlignedPointerInInternalFields(int argc, int indices[],\n                                          void* values[]);\n \n-  // Testers for local properties.\n-  V8_DEPRECATED(\"Use maybe version\", bool HasOwnProperty(Local<String> key));\n-\n   /**\n    * HasOwnProperty() is like JavaScript's Object.prototype.hasOwnProperty().\n    *\n@@ -3422,9 +3350,6 @@ class V8_EXPORT Object : public Value {\n    * If result.IsEmpty() no real property was located in the prototype chain.\n    * This means interceptors in the prototype chain are not called.\n    */\n-  V8_DEPRECATED(\n-      \"Use maybe version\",\n-      Local<Value> GetRealNamedPropertyInPrototypeChain(Local<String> key));\n   V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetRealNamedPropertyInPrototypeChain(\n       Local<Context> context, Local<Name> key);\n \n@@ -3433,10 +3358,6 @@ class V8_EXPORT Object : public Value {\n    * which can be None or any combination of ReadOnly, DontEnum and DontDelete.\n    * Interceptors in the prototype chain are not called.\n    */\n-  V8_DEPRECATED(\n-      \"Use maybe version\",\n-      Maybe<PropertyAttribute> GetRealNamedPropertyAttributesInPrototypeChain(\n-          Local<String> key));\n   V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute>\n   GetRealNamedPropertyAttributesInPrototypeChain(Local<Context> context,\n                                                  Local<Name> key);\n@@ -3446,8 +3367,6 @@ class V8_EXPORT Object : public Value {\n    * in the prototype chain.\n    * This means interceptors in the prototype chain are not called.\n    */\n-  V8_DEPRECATED(\"Use maybe version\",\n-                Local<Value> GetRealNamedProperty(Local<String> key));\n   V8_WARN_UNUSED_RESULT MaybeLocal<Value> GetRealNamedProperty(\n       Local<Context> context, Local<Name> key);\n \n@@ -3456,9 +3375,6 @@ class V8_EXPORT Object : public Value {\n    * None or any combination of ReadOnly, DontEnum and DontDelete.\n    * Interceptors in the prototype chain are not called.\n    */\n-  V8_DEPRECATED(\"Use maybe version\",\n-                Maybe<PropertyAttribute> GetRealNamedPropertyAttributes(\n-                    Local<String> key));\n   V8_WARN_UNUSED_RESULT Maybe<PropertyAttribute> GetRealNamedPropertyAttributes(\n       Local<Context> context, Local<Name> key);\n \n@@ -3511,9 +3427,6 @@ class V8_EXPORT Object : public Value {\n    * Call an Object as a function if a callback is set by the\n    * ObjectTemplate::SetCallAsFunctionHandler method.\n    */\n-  V8_DEPRECATED(\"Use maybe version\",\n-                Local<Value> CallAsFunction(Local<Value> recv, int argc,\n-                                            Local<Value> argv[]));\n   V8_WARN_UNUSED_RESULT MaybeLocal<Value> CallAsFunction(Local<Context> context,\n                                                          Local<Value> recv,\n                                                          int argc,\n@@ -3524,8 +3437,6 @@ class V8_EXPORT Object : public Value {\n    * ObjectTemplate::SetCallAsFunctionHandler method.\n    * Note: This method behaves like the Function::NewInstance method.\n    */\n-  V8_DEPRECATED(\"Use maybe version\",\n-                Local<Value> CallAsConstructor(int argc, Local<Value> argv[]));\n   V8_WARN_UNUSED_RESULT MaybeLocal<Value> CallAsConstructor(\n       Local<Context> context, int argc, Local<Value> argv[]);\n \n@@ -3553,16 +3464,6 @@ class V8_EXPORT Array : public Object {\n  public:\n   uint32_t Length() const;\n \n-  /**\n-   * Clones an element at index |index|.  Returns an empty\n-   * handle if cloning fails (for any reason).\n-   */\n-  V8_DEPRECATED(\"Cloning is not supported.\",\n-                Local<Object> CloneElementAt(uint32_t index));\n-  V8_DEPRECATED(\"Cloning is not supported.\",\n-                MaybeLocal<Object> CloneElementAt(Local<Context> context,\n-                                                  uint32_t index));\n-\n   /**\n    * Creates a JavaScript array with the given length. If the length\n    * is negative the returned array will have length 0.\n@@ -3885,12 +3786,9 @@ class V8_EXPORT Function : public Object {\n       Local<Function> New(Isolate* isolate, FunctionCallback callback,\n                           Local<Value> data = Local<Value>(), int length = 0));\n \n-  V8_DEPRECATED(\"Use maybe version\",\n-                Local<Object> NewInstance(int argc, Local<Value> argv[]) const);\n   V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewInstance(\n       Local<Context> context, int argc, Local<Value> argv[]) const;\n \n-  V8_DEPRECATED(\"Use maybe version\", Local<Object> NewInstance() const);\n   V8_WARN_UNUSED_RESULT MaybeLocal<Object> NewInstance(\n       Local<Context> context) const {\n     return NewInstance(context, 0, nullptr);\n@@ -3937,11 +3835,6 @@ class V8_EXPORT Function : public Object {\n    */\n   int GetScriptColumnNumber() const;\n \n-  /**\n-   * Tells whether this function is builtin.\n-   */\n-  V8_DEPRECATED(\"this should no longer be used.\", bool IsBuiltin() const);\n-\n   /**\n    * Returns scriptId.\n    */\n@@ -3983,8 +3876,8 @@ class V8_EXPORT Promise : public Object {\n     /**\n      * Create a new resolver, along with an associated promise in pending state.\n      */\n-    static V8_DEPRECATE_SOON(\"Use maybe version\",\n-                             Local<Resolver> New(Isolate* isolate));\n+    static V8_DEPRECATED(\"Use maybe version\",\n+                         Local<Resolver> New(Isolate* isolate));\n     static V8_WARN_UNUSED_RESULT MaybeLocal<Resolver> New(\n         Local<Context> context);\n \n@@ -3997,11 +3890,11 @@ class V8_EXPORT Promise : public Object {\n      * Resolve/reject the associated promise with a given value.\n      * Ignored if the promise is no longer pending.\n      */\n-    V8_DEPRECATE_SOON(\"Use maybe version\", void Resolve(Local<Value> value));\n+    V8_DEPRECATED(\"Use maybe version\", void Resolve(Local<Value> value));\n     V8_WARN_UNUSED_RESULT Maybe<bool> Resolve(Local<Context> context,\n                                               Local<Value> value);\n \n-    V8_DEPRECATE_SOON(\"Use maybe version\", void Reject(Local<Value> value));\n+    V8_DEPRECATED(\"Use maybe version\", void Reject(Local<Value> value));\n     V8_WARN_UNUSED_RESULT Maybe<bool> Reject(Local<Context> context,\n                                              Local<Value> value);\n \n@@ -4018,13 +3911,9 @@ class V8_EXPORT Promise : public Object {\n    * an argument. If the promise is already resolved/rejected, the handler is\n    * invoked at the end of turn.\n    */\n-  V8_DEPRECATED(\"Use maybe version\",\n-                Local<Promise> Catch(Local<Function> handler));\n   V8_WARN_UNUSED_RESULT MaybeLocal<Promise> Catch(Local<Context> context,\n                                                   Local<Function> handler);\n \n-  V8_DEPRECATED(\"Use maybe version\",\n-                Local<Promise> Then(Local<Function> handler));\n   V8_WARN_UNUSED_RESULT MaybeLocal<Promise> Then(Local<Context> context,\n                                                  Local<Function> handler);\n \n@@ -4133,7 +4022,7 @@ class V8_EXPORT PropertyDescriptor {\n  */\n class V8_EXPORT Proxy : public Object {\n  public:\n-  Local<Object> GetTarget();\n+  Local<Value> GetTarget();\n   Local<Value> GetHandler();\n   bool IsRevoked();\n   void Revoke();\n@@ -4918,7 +4807,6 @@ class V8_EXPORT NumberObject : public Object {\n class V8_EXPORT BooleanObject : public Object {\n  public:\n   static Local<Value> New(Isolate* isolate, bool value);\n-  V8_DEPRECATED(\"Pass an isolate\", static Local<Value> New(bool value));\n \n   bool ValueOf() const;\n \n@@ -5460,7 +5348,8 @@ typedef bool (*AccessCheckCallback)(Local<Context> accessing_context,\n  *    v8::Local<v8::ObjectTemplate> instance_t = t->InstanceTemplate();\n  *    instance_t->SetAccessor(String::NewFromUtf8(isolate, \"instance_accessor\"),\n  *                            InstanceAccessorCallback);\n- *    instance_t->SetNamedPropertyHandler(PropertyHandlerCallback);\n+ *    instance_t->SetHandler(\n+ *        NamedPropertyHandlerConfiguration(PropertyHandlerCallback));\n  *    instance_t->Set(String::NewFromUtf8(isolate, \"instance_property\"),\n  *                    Number::New(isolate, 3));\n  *\n@@ -5638,8 +5527,12 @@ class V8_EXPORT FunctionTemplate : public Template {\n    */\n   bool HasInstance(Local<Value> object);\n \n+  V8_INLINE static FunctionTemplate* Cast(Data* data);\n+\n  private:\n   FunctionTemplate();\n+\n+  static void CheckCast(Data* that);\n   friend class Context;\n   friend class ObjectTemplate;\n };\n@@ -5786,7 +5679,6 @@ class V8_EXPORT ObjectTemplate : public Template {\n   static Local<ObjectTemplate> New(\n       Isolate* isolate,\n       Local<FunctionTemplate> constructor = Local<FunctionTemplate>());\n-  static V8_DEPRECATED(\"Use isolate version\", Local<ObjectTemplate> New());\n \n   /** Get a template included in the snapshot by index. */\n   static MaybeLocal<ObjectTemplate> FromSnapshot(Isolate* isolate,\n@@ -5858,13 +5750,16 @@ class V8_EXPORT ObjectTemplate : public Template {\n    * \\param data A piece of data that will be passed to the callbacks\n    *   whenever they are invoked.\n    */\n-  // TODO(dcarney): deprecate\n-  void SetNamedPropertyHandler(NamedPropertyGetterCallback getter,\n-                               NamedPropertySetterCallback setter = 0,\n-                               NamedPropertyQueryCallback query = 0,\n-                               NamedPropertyDeleterCallback deleter = 0,\n-                               NamedPropertyEnumeratorCallback enumerator = 0,\n-                               Local<Value> data = Local<Value>());\n+  V8_DEPRECATE_SOON(\n+      \"Use SetHandler(const NamedPropertyHandlerConfiguration) \"\n+      \"with the kOnlyInterceptStrings flag set.\",\n+      void SetNamedPropertyHandler(\n+          NamedPropertyGetterCallback getter,\n+          NamedPropertySetterCallback setter = 0,\n+          NamedPropertyQueryCallback query = 0,\n+          NamedPropertyDeleterCallback deleter = 0,\n+          NamedPropertyEnumeratorCallback enumerator = 0,\n+          Local<Value> data = Local<Value>()));\n \n   /**\n    * Sets a named property handler on the object template.\n@@ -5984,10 +5879,13 @@ class V8_EXPORT ObjectTemplate : public Template {\n    */\n   void SetImmutableProto();\n \n+  V8_INLINE static ObjectTemplate* Cast(Data* data);\n+\n  private:\n   ObjectTemplate();\n   static Local<ObjectTemplate> New(internal::Isolate* isolate,\n                                    Local<FunctionTemplate> constructor);\n+  static void CheckCast(Data* that);\n   friend class FunctionTemplate;\n };\n \n@@ -6005,8 +5903,12 @@ class V8_EXPORT Signature : public Data {\n       Isolate* isolate,\n       Local<FunctionTemplate> receiver = Local<FunctionTemplate>());\n \n+  V8_INLINE static Signature* Cast(Data* data);\n+\n  private:\n   Signature();\n+\n+  static void CheckCast(Data* that);\n };\n \n \n@@ -6020,8 +5922,12 @@ class V8_EXPORT AccessorSignature : public Data {\n       Isolate* isolate,\n       Local<FunctionTemplate> receiver = Local<FunctionTemplate>());\n \n+  V8_INLINE static AccessorSignature* Cast(Data* data);\n+\n  private:\n   AccessorSignature();\n+\n+  static void CheckCast(Data* that);\n };\n \n \n@@ -6215,8 +6121,6 @@ class V8_EXPORT Exception {\n    * or capture the current stack trace if not available.\n    */\n   static Local<Message> CreateMessage(Isolate* isolate, Local<Value> exception);\n-  V8_DEPRECATED(\"Use version with an Isolate*\",\n-                static Local<Message> CreateMessage(Local<Value> exception));\n \n   /**\n    * Returns the original stack trace that was captured at the creation time\n@@ -6338,11 +6242,6 @@ class PromiseRejectMessage {\n   V8_INLINE PromiseRejectEvent GetEvent() const { return event_; }\n   V8_INLINE Local<Value> GetValue() const { return value_; }\n \n-  V8_DEPRECATED(\"Use v8::Exception::CreateMessage(GetValue())->GetStackTrace()\",\n-                V8_INLINE Local<StackTrace> GetStackTrace() const) {\n-    return stack_trace_;\n-  }\n-\n  private:\n   Local<Promise> promise_;\n   PromiseRejectEvent event_;\n@@ -6496,6 +6395,8 @@ class V8_EXPORT HeapStatistics {\n   size_t heap_size_limit() { return heap_size_limit_; }\n   size_t malloced_memory() { return malloced_memory_; }\n   size_t peak_malloced_memory() { return peak_malloced_memory_; }\n+  size_t number_of_native_contexts() { return number_of_native_contexts_; }\n+  size_t number_of_detached_contexts() { return number_of_detached_contexts_; }\n \n   /**\n    * Returns a 0/1 boolean, which signifies whether the V8 overwrite heap\n@@ -6513,6 +6414,8 @@ class V8_EXPORT HeapStatistics {\n   size_t malloced_memory_;\n   size_t peak_malloced_memory_;\n   bool does_zap_garbage_;\n+  size_t number_of_native_contexts_;\n+  size_t number_of_detached_contexts_;\n \n   friend class V8;\n   friend class Isolate;\n@@ -7064,6 +6967,7 @@ class V8_EXPORT Isolate {\n     kErrorPrepareStackTrace = 44,\n     kErrorStackTraceLimit = 45,\n     kWebAssemblyInstantiation = 46,\n+    kDeoptimizerDisableSpeculation = 47,\n \n     // If you add new values here, you'll also need to update Chromium's:\n     // web_feature.mojom, UseCounterCallback.cpp, and enums.xml. V8 changes to\n@@ -7125,9 +7029,6 @@ class V8_EXPORT Isolate {\n       HostImportModuleDynamicallyCallback callback);\n \n   /**\n-   * This is an unfinished experimental feature, and is only exposed\n-   * here for internal testing purposes. DO NOT USE.\n-   *\n    * This specifies the callback called by the upcoming importa.meta\n    * language feature to retrieve host-defined meta data for a module.\n    */\n@@ -7202,6 +7103,14 @@ class V8_EXPORT Isolate {\n    */\n   V8_INLINE static uint32_t GetNumberOfDataSlots();\n \n+  /**\n+   * Return data that was previously attached to the isolate snapshot via\n+   * SnapshotCreator, and removes the reference to it.\n+   * Repeated call with the same index returns an empty MaybeLocal.\n+   */\n+  template <class T>\n+  V8_INLINE MaybeLocal<T> GetDataFromSnapshotOnce(size_t index);\n+\n   /**\n    * Get statistics about the heap memory usage.\n    */\n@@ -7315,7 +7224,7 @@ class V8_EXPORT Isolate {\n    * context of the top-most JavaScript frame.  If there are no\n    * JavaScript frames an empty handle is returned.\n    */\n-  V8_DEPRECATE_SOON(\n+  V8_DEPRECATED(\n       \"Calling context concept is not compatible with tail calls, and will be \"\n       \"removed.\",\n       Local<Context> GetCallingContext());\n@@ -7492,18 +7401,17 @@ class V8_EXPORT Isolate {\n    * further callbacks.\n    */\n   void AddCallCompletedCallback(CallCompletedCallback callback);\n-  V8_DEPRECATE_SOON(\n+  V8_DEPRECATED(\n       \"Use callback with parameter\",\n       void AddCallCompletedCallback(DeprecatedCallCompletedCallback callback));\n \n   /**\n    * Removes callback that was installed by AddCallCompletedCallback.\n    */\n   void RemoveCallCompletedCallback(CallCompletedCallback callback);\n-  V8_DEPRECATE_SOON(\n-      \"Use callback with parameter\",\n-      void RemoveCallCompletedCallback(\n-          DeprecatedCallCompletedCallback callback));\n+  V8_DEPRECATED(\"Use callback with parameter\",\n+                void RemoveCallCompletedCallback(\n+                    DeprecatedCallCompletedCallback callback));\n \n   /**\n    * Set the PromiseHook callback for various promise lifecycle\n@@ -7518,38 +7426,36 @@ class V8_EXPORT Isolate {\n   void SetPromiseRejectCallback(PromiseRejectCallback callback);\n \n   /**\n-   * Experimental: Runs the Microtask Work Queue until empty\n+   * Runs the Microtask Work Queue until empty\n    * Any exceptions thrown by microtask callbacks are swallowed.\n    */\n   void RunMicrotasks();\n \n   /**\n-   * Experimental: Enqueues the callback to the Microtask Work Queue\n+   * Enqueues the callback to the Microtask Work Queue\n    */\n   void EnqueueMicrotask(Local<Function> microtask);\n \n   /**\n-   * Experimental: Enqueues the callback to the Microtask Work Queue\n+   * Enqueues the callback to the Microtask Work Queue\n    */\n   void EnqueueMicrotask(MicrotaskCallback microtask, void* data = NULL);\n \n   /**\n-   * Experimental: Controls how Microtasks are invoked. See MicrotasksPolicy\n-   * for details.\n+   * Controls how Microtasks are invoked. See MicrotasksPolicy for details.\n    */\n   void SetMicrotasksPolicy(MicrotasksPolicy policy);\n-  V8_DEPRECATE_SOON(\"Use SetMicrotasksPolicy\",\n-                    void SetAutorunMicrotasks(bool autorun));\n+  V8_DEPRECATED(\"Use SetMicrotasksPolicy\",\n+                void SetAutorunMicrotasks(bool autorun));\n \n   /**\n-   * Experimental: Returns the policy controlling how Microtasks are invoked.\n+   * Returns the policy controlling how Microtasks are invoked.\n    */\n   MicrotasksPolicy GetMicrotasksPolicy() const;\n-  V8_DEPRECATE_SOON(\"Use GetMicrotasksPolicy\",\n-                    bool WillAutorunMicrotasks() const);\n+  V8_DEPRECATED(\"Use GetMicrotasksPolicy\", bool WillAutorunMicrotasks() const);\n \n   /**\n-   * Experimental: adds a callback to notify the host application after\n+   * Adds a callback to notify the host application after\n    * microtasks were run. The callback is triggered by explicit RunMicrotasks\n    * call or automatic microtasks execution (see SetAutorunMicrotasks).\n    *\n@@ -7603,9 +7509,6 @@ class V8_EXPORT Isolate {\n    */\n   bool IdleNotificationDeadline(double deadline_in_seconds);\n \n-  V8_DEPRECATED(\"use IdleNotificationDeadline()\",\n-                bool IdleNotification(int idle_time_in_ms));\n-\n   /**\n    * Optional notification that the system is running low on memory.\n    * V8 uses these notifications to attempt to free memory.\n@@ -7847,6 +7750,7 @@ class V8_EXPORT Isolate {\n   template <class K, class V, class Traits>\n   friend class PersistentValueMapBase;\n \n+  internal::Object** GetDataFromSnapshotOnce(size_t index);\n   void ReportExternalAllocationLimitReached();\n   void CheckMemoryPressure();\n };\n@@ -7886,17 +7790,6 @@ typedef uintptr_t (*ReturnAddressLocationResolver)(\n  */\n class V8_EXPORT V8 {\n  public:\n-  /** Set the callback to invoke in case of fatal errors. */\n-  V8_INLINE static V8_DEPRECATED(\n-      \"Use isolate version\",\n-      void SetFatalErrorHandler(FatalErrorCallback that));\n-\n-  /**\n-  * Check if V8 is dead and therefore unusable.  This is the case after\n-  * fatal errors such as out-of-memory situations.\n-  */\n-  V8_INLINE static V8_DEPRECATED(\"Use isolate version\", bool IsDead());\n-\n   /**\n    * Hand startup data to V8, in case the embedder has chosen to build\n    * V8 with external startup data.\n@@ -7937,35 +7830,6 @@ class V8_EXPORT V8 {\n   /** Set the callback to invoke in case of Dcheck failures. */\n   static void SetDcheckErrorHandler(DcheckErrorCallback that);\n \n-  /**\n-   * Adds a message listener.\n-   *\n-   * The same message listener can be added more than once and in that\n-   * case it will be called more than once for each message.\n-   *\n-   * If data is specified, it will be passed to the callback when it is called.\n-   * Otherwise, the exception object will be passed to the callback instead.\n-   */\n-  V8_INLINE static V8_DEPRECATED(\n-      \"Use isolate version\",\n-      bool AddMessageListener(MessageCallback that,\n-                              Local<Value> data = Local<Value>()));\n-\n-  /**\n-   * Remove all message listeners from the specified callback function.\n-   */\n-  V8_INLINE static V8_DEPRECATED(\n-      \"Use isolate version\", void RemoveMessageListeners(MessageCallback that));\n-\n-  /**\n-   * Tells V8 to capture current stack trace when uncaught exception occurs\n-   * and report it to the message listeners. The option is off by default.\n-   */\n-  V8_INLINE static V8_DEPRECATED(\n-      \"Use isolate version\",\n-      void SetCaptureStackTraceForUncaughtExceptions(\n-          bool capture, int frame_limit = 10,\n-          StackTrace::StackTraceOptions options = StackTrace::kOverview));\n \n   /**\n    * Sets V8 flags from a string.\n@@ -7982,11 +7846,6 @@ class V8_EXPORT V8 {\n   /** Get the version string. */\n   static const char* GetVersion();\n \n-  /** Callback function for reporting failed access checks.*/\n-  V8_INLINE static V8_DEPRECATED(\n-      \"Use isolate version\",\n-      void SetFailedAccessCheckCallbackFunction(FailedAccessCheckCallback));\n-\n   /**\n    * Initializes V8. This function needs to be called before the first Isolate\n    * is created. It always returns true.\n@@ -8006,51 +7865,6 @@ class V8_EXPORT V8 {\n   static void SetReturnAddressLocationResolver(\n       ReturnAddressLocationResolver return_address_resolver);\n \n-  /**\n-   * Forcefully terminate the current thread of JavaScript execution\n-   * in the given isolate.\n-   *\n-   * This method can be used by any thread even if that thread has not\n-   * acquired the V8 lock with a Locker object.\n-   *\n-   * \\param isolate The isolate in which to terminate the current JS execution.\n-   */\n-  V8_INLINE static V8_DEPRECATED(\"Use isolate version\",\n-                                 void TerminateExecution(Isolate* isolate));\n-\n-  /**\n-   * Is V8 terminating JavaScript execution.\n-   *\n-   * Returns true if JavaScript execution is currently terminating\n-   * because of a call to TerminateExecution.  In that case there are\n-   * still JavaScript frames on the stack and the termination\n-   * exception is still active.\n-   *\n-   * \\param isolate The isolate in which to check.\n-   */\n-  V8_INLINE static V8_DEPRECATED(\n-      \"Use isolate version\",\n-      bool IsExecutionTerminating(Isolate* isolate = NULL));\n-\n-  /**\n-   * Resume execution capability in the given isolate, whose execution\n-   * was previously forcefully terminated using TerminateExecution().\n-   *\n-   * When execution is forcefully terminated using TerminateExecution(),\n-   * the isolate can not resume execution until all JavaScript frames\n-   * have propagated the uncatchable exception which is generated.  This\n-   * method allows the program embedding the engine to handle the\n-   * termination event and resume execution capability, even if\n-   * JavaScript frames remain on the stack.\n-   *\n-   * This method can be used by any thread even if that thread has not\n-   * acquired the V8 lock with a Locker object.\n-   *\n-   * \\param isolate The isolate in which to resume execution capability.\n-   */\n-  V8_INLINE static V8_DEPRECATED(\n-      \"Use isolate version\", void CancelTerminateExecution(Isolate* isolate));\n-\n   /**\n    * Releases any resources used by v8 and stops any utility threads\n    * that may be running.  Note that disposing v8 is permanent, it\n@@ -8062,26 +7876,6 @@ class V8_EXPORT V8 {\n    */\n   static bool Dispose();\n \n-  /**\n-   * Iterates through all external resources referenced from current isolate\n-   * heap.  GC is not invoked prior to iterating, therefore there is no\n-   * guarantee that visited objects are still alive.\n-   */\n-  V8_INLINE static V8_DEPRECATED(\n-      \"Use isolate version\",\n-      void VisitExternalResources(ExternalResourceVisitor* visitor));\n-\n-  /**\n-   * Initialize the ICU library bundled with V8. The embedder should only\n-   * invoke this method when using the bundled ICU. Returns true on success.\n-   *\n-   * If V8 was compiled with the ICU data in an external file, the location\n-   * of the data file has to be provided.\n-   */\n-  V8_DEPRECATE_SOON(\n-      \"Use version with default location.\",\n-      static bool InitializeICU(const char* icu_data_file = nullptr));\n-\n   /**\n    * Initialize the ICU library bundled with V8. The embedder should only\n    * invoke this method when using the bundled ICU. If V8 was compiled with\n@@ -8253,6 +8047,24 @@ class V8_EXPORT SnapshotCreator {\n    */\n   size_t AddTemplate(Local<Template> template_obj);\n \n+  /**\n+   * Attach arbitrary V8::Data to the context snapshot, which can be retrieved\n+   * via Context::GetDataFromSnapshot after deserialization. This data does not\n+   * survive when a new snapshot is created from an existing snapshot.\n+   * \\returns the index for retrieval.\n+   */\n+  template <class T>\n+  V8_INLINE size_t AddData(Local<Context> context, Local<T> object);\n+\n+  /**\n+   * Attach arbitrary V8::Data to the isolate snapshot, which can be retrieved\n+   * via Isolate::GetDataFromSnapshot after deserialization. This data does not\n+   * survive when a new snapshot is created from an existing snapshot.\n+   * \\returns the index for retrieval.\n+   */\n+  template <class T>\n+  V8_INLINE size_t AddData(Local<T> object);\n+\n   /**\n    * Created a snapshot data blob.\n    * This must not be called from within a handle scope.\n@@ -8268,6 +8080,9 @@ class V8_EXPORT SnapshotCreator {\n   void operator=(const SnapshotCreator&) = delete;\n \n  private:\n+  size_t AddData(Local<Context> context, internal::Object* object);\n+  size_t AddData(internal::Object* object);\n+\n   void* data_;\n };\n \n@@ -8385,13 +8200,6 @@ inline Maybe<void> JustVoid() { return Maybe<void>(Maybe<void>::JustTag()); }\n  */\n class V8_EXPORT TryCatch {\n  public:\n-  /**\n-   * Creates a new try/catch block and registers it with v8.  Note that\n-   * all TryCatch blocks should be stack allocated because the memory\n-   * location itself is compared against JavaScript try/catch blocks.\n-   */\n-  V8_DEPRECATED(\"Use isolate version\", TryCatch());\n-\n   /**\n    * Creates a new try/catch block and registers it with v8.  Note that\n    * all TryCatch blocks should be stack allocated because the memory\n@@ -8454,7 +8262,7 @@ class V8_EXPORT TryCatch {\n    * Returns the .stack property of the thrown object.  If no .stack\n    * property is present an empty handle is returned.\n    */\n-  V8_DEPRECATE_SOON(\"Use maybe version.\", Local<Value> StackTrace() const);\n+  V8_DEPRECATED(\"Use maybe version.\", Local<Value> StackTrace() const);\n   V8_WARN_UNUSED_RESULT MaybeLocal<Value> StackTrace(\n       Local<Context> context) const;\n \n@@ -8763,9 +8571,12 @@ class V8_EXPORT Context {\n   void SetErrorMessageForCodeGenerationFromStrings(Local<String> message);\n \n   /**\n-   * Estimate the memory in bytes retained by this context.\n+   * Return data that was previously attached to the context snapshot via\n+   * SnapshotCreator, and removes the reference to it.\n+   * Repeated call with the same index returns an empty MaybeLocal.\n    */\n-  V8_DEPRECATED(\"no longer supported\", size_t EstimatedSize());\n+  template <class T>\n+  V8_INLINE MaybeLocal<T> GetDataFromSnapshotOnce(size_t index);\n \n   /**\n    * Stack-allocated class which sets the execution context for all\n@@ -8809,6 +8620,7 @@ class V8_EXPORT Context {\n   friend class Object;\n   friend class Function;\n \n+  internal::Object** GetDataFromSnapshotOnce(size_t index);\n   Local<Value> SlowGetEmbedderData(int index);\n   void* SlowGetAlignedPointerFromEmbedderData(int index);\n };\n@@ -9072,9 +8884,9 @@ class Internals {\n   static const int kFirstNonstringType = 0x80;\n   static const int kOddballType = 0x83;\n   static const int kForeignType = 0x87;\n-  static const int kJSSpecialApiObjectType = 0xbc;\n-  static const int kJSApiObjectType = 0xc0;\n-  static const int kJSObjectType = 0xc1;\n+  static const int kJSSpecialApiObjectType = 0x410;\n+  static const int kJSApiObjectType = 0x420;\n+  static const int kJSObjectType = 0x421;\n \n   static const int kUndefinedOddballKind = 5;\n   static const int kNullOddballKind = 3;\n@@ -9186,6 +8998,29 @@ class Internals {\n   }\n };\n \n+// Only perform cast check for types derived from v8::Data since\n+// other types do not implement the Cast method.\n+template <bool PerformCheck>\n+struct CastCheck {\n+  template <class T>\n+  static void Perform(T* data);\n+};\n+\n+template <>\n+template <class T>\n+void CastCheck<true>::Perform(T* data) {\n+  T::Cast(data);\n+}\n+\n+template <>\n+template <class T>\n+void CastCheck<false>::Perform(T* data) {}\n+\n+template <class T>\n+V8_INLINE void PerformCastCheck(T* data) {\n+  CastCheck<std::is_base_of<Data, T>::value>::Perform(data);\n+}\n+\n }  // namespace internal\n \n \n@@ -9649,6 +9484,33 @@ void Template::Set(Isolate* isolate, const char* name, Local<Data> value) {\n       value);\n }\n \n+FunctionTemplate* FunctionTemplate::Cast(Data* data) {\n+#ifdef V8_ENABLE_CHECKS\n+  CheckCast(data);\n+#endif\n+  return reinterpret_cast<FunctionTemplate*>(data);\n+}\n+\n+ObjectTemplate* ObjectTemplate::Cast(Data* data) {\n+#ifdef V8_ENABLE_CHECKS\n+  CheckCast(data);\n+#endif\n+  return reinterpret_cast<ObjectTemplate*>(data);\n+}\n+\n+Signature* Signature::Cast(Data* data) {\n+#ifdef V8_ENABLE_CHECKS\n+  CheckCast(data);\n+#endif\n+  return reinterpret_cast<Signature*>(data);\n+}\n+\n+AccessorSignature* AccessorSignature::Cast(Data* data) {\n+#ifdef V8_ENABLE_CHECKS\n+  CheckCast(data);\n+#endif\n+  return reinterpret_cast<AccessorSignature*>(data);\n+}\n \n Local<Value> Object::GetInternalField(int index) {\n #ifndef V8_ENABLE_CHECKS\n@@ -9826,24 +9688,12 @@ Local<Boolean> Value::ToBoolean() const {\n }\n \n \n-Local<Number> Value::ToNumber() const {\n-  return ToNumber(Isolate::GetCurrent()->GetCurrentContext())\n-      .FromMaybe(Local<Number>());\n-}\n-\n-\n Local<String> Value::ToString() const {\n   return ToString(Isolate::GetCurrent()->GetCurrentContext())\n       .FromMaybe(Local<String>());\n }\n \n \n-Local<String> Value::ToDetailString() const {\n-  return ToDetailString(Isolate::GetCurrent()->GetCurrentContext())\n-      .FromMaybe(Local<String>());\n-}\n-\n-\n Local<Object> Value::ToObject() const {\n   return ToObject(Isolate::GetCurrent()->GetCurrentContext())\n       .FromMaybe(Local<Object>());\n@@ -9856,18 +9706,6 @@ Local<Integer> Value::ToInteger() const {\n }\n \n \n-Local<Uint32> Value::ToUint32() const {\n-  return ToUint32(Isolate::GetCurrent()->GetCurrentContext())\n-      .FromMaybe(Local<Uint32>());\n-}\n-\n-\n-Local<Int32> Value::ToInt32() const {\n-  return ToInt32(Isolate::GetCurrent()->GetCurrentContext())\n-      .FromMaybe(Local<Int32>());\n-}\n-\n-\n Boolean* Boolean::Cast(v8::Value* value) {\n #ifdef V8_ENABLE_CHECKS\n   CheckCast(value);\n@@ -9892,6 +9730,14 @@ Symbol* Symbol::Cast(v8::Value* value) {\n }\n \n \n+Private* Private::Cast(Data* data) {\n+#ifdef V8_ENABLE_CHECKS\n+  CheckCast(data);\n+#endif\n+  return reinterpret_cast<Private*>(data);\n+}\n+\n+\n Number* Number::Cast(v8::Value* value) {\n #ifdef V8_ENABLE_CHECKS\n   CheckCast(value);\n@@ -10251,6 +10097,12 @@ uint32_t Isolate::GetNumberOfDataSlots() {\n   return I::kNumIsolateDataSlots;\n }\n \n+template <class T>\n+MaybeLocal<T> Isolate::GetDataFromSnapshotOnce(size_t index) {\n+  T* data = reinterpret_cast<T*>(GetDataFromSnapshotOnce(index));\n+  if (data) internal::PerformCastCheck(data);\n+  return Local<T>(data);\n+}\n \n int64_t Isolate::AdjustAmountOfExternalAllocatedMemory(\n     int64_t change_in_bytes) {\n@@ -10310,63 +10162,25 @@ void* Context::GetAlignedPointerFromEmbedderData(int index) {\n #endif\n }\n \n-bool V8::IsDead() {\n-  Isolate* isolate = Isolate::GetCurrent();\n-  return isolate->IsDead();\n-}\n-\n-\n-bool V8::AddMessageListener(MessageCallback that, Local<Value> data) {\n-  Isolate* isolate = Isolate::GetCurrent();\n-  return isolate->AddMessageListener(that, data);\n-}\n-\n-\n-void V8::RemoveMessageListeners(MessageCallback that) {\n-  Isolate* isolate = Isolate::GetCurrent();\n-  isolate->RemoveMessageListeners(that);\n-}\n-\n-\n-void V8::SetFailedAccessCheckCallbackFunction(\n-    FailedAccessCheckCallback callback) {\n-  Isolate* isolate = Isolate::GetCurrent();\n-  isolate->SetFailedAccessCheckCallbackFunction(callback);\n-}\n-\n-\n-void V8::SetCaptureStackTraceForUncaughtExceptions(\n-    bool capture, int frame_limit, StackTrace::StackTraceOptions options) {\n-  Isolate* isolate = Isolate::GetCurrent();\n-  isolate->SetCaptureStackTraceForUncaughtExceptions(capture, frame_limit,\n-                                                     options);\n-}\n-\n-\n-void V8::SetFatalErrorHandler(FatalErrorCallback callback) {\n-  Isolate* isolate = Isolate::GetCurrent();\n-  isolate->SetFatalErrorHandler(callback);\n-}\n-\n-void V8::TerminateExecution(Isolate* isolate) { isolate->TerminateExecution(); }\n-\n-\n-bool V8::IsExecutionTerminating(Isolate* isolate) {\n-  if (isolate == NULL) {\n-    isolate = Isolate::GetCurrent();\n-  }\n-  return isolate->IsExecutionTerminating();\n+template <class T>\n+MaybeLocal<T> Context::GetDataFromSnapshotOnce(size_t index) {\n+  T* data = reinterpret_cast<T*>(GetDataFromSnapshotOnce(index));\n+  if (data) internal::PerformCastCheck(data);\n+  return Local<T>(data);\n }\n \n-\n-void V8::CancelTerminateExecution(Isolate* isolate) {\n-  isolate->CancelTerminateExecution();\n+template <class T>\n+size_t SnapshotCreator::AddData(Local<Context> context, Local<T> object) {\n+  T* object_ptr = *object;\n+  internal::Object** p = reinterpret_cast<internal::Object**>(object_ptr);\n+  return AddData(context, *p);\n }\n \n-\n-void V8::VisitExternalResources(ExternalResourceVisitor* visitor) {\n-  Isolate* isolate = Isolate::GetCurrent();\n-  isolate->VisitExternalResources(visitor);\n+template <class T>\n+size_t SnapshotCreator::AddData(Local<T> object) {\n+  T* object_ptr = *object;\n+  internal::Object** p = reinterpret_cast<internal::Object**>(object_ptr);\n+  return AddData(*p);\n }\n \n /**"
        },
        {
            "sha": "3d20f403f68eb9e0b5266656d6360e6ce51b3f40",
            "filename": "deps/v8/infra/config/PRESUBMIT.py",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Fconfig%2FPRESUBMIT.py",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Fconfig%2FPRESUBMIT.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finfra%2Fconfig%2FPRESUBMIT.py?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -0,0 +1,29 @@\n+# Copyright 2018 the V8 project authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style license that can be\n+# found in the LICENSE file.\n+\n+\"\"\"Presubmit script for changes in the infrastructure configs.\n+\n+See http://dev.chromium.org/developers/how-tos/depottools/presubmit-scripts\n+for more details about the presubmit API built into gcl.\n+\"\"\"\n+\n+\n+def _CommonChecks(input_api, output_api):\n+  \"\"\"Checks common to both upload and commit.\"\"\"\n+  results = []\n+  results.extend(\n+      input_api.canned_checks.CheckChangedLUCIConfigs(input_api, output_api))\n+  return results\n+\n+\n+def CheckChangeOnUpload(input_api, output_api):\n+  results = []\n+  results.extend(_CommonChecks(input_api, output_api))\n+  return results\n+\n+\n+def CheckChangeOnCommit(input_api, output_api):\n+  results = []\n+  results.extend(_CommonChecks(input_api, output_api))\n+  return results"
        },
        {
            "sha": "d57b117f10bcf47bcd7392293da70a5f02b78001",
            "filename": "deps/v8/infra/config/cq.cfg",
            "status": "modified",
            "additions": 18,
            "deletions": 28,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Fconfig%2Fcq.cfg",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Fconfig%2Fcq.cfg",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finfra%2Fconfig%2Fcq.cfg?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -25,23 +25,12 @@ verifiers {\n       name: \"luci.v8.try\"\n       builders { name: \"v8_android_arm_compile_rel\" }\n       builders { name: \"v8_fuchsia_rel_ng\" }\n-      builders { name: \"v8_linux64_gcc_compile_dbg\" }\n-      builders { name: \"v8_linux_gcc_compile_rel\" }\n-      builders { name: \"v8_linux_shared_compile_rel\" }\n-      builders { name: \"v8_presubmit\" }\n-      builders {\n-        name: \"v8_win64_msvc_compile_rel\"\n-        experiment_percentage: 20\n-      }\n-    }\n-    buckets {\n-      name: \"master.tryserver.v8\"\n-      builders { name: \"v8_node_linux64_rel\" }\n       builders { name: \"v8_linux64_asan_rel_ng\" }\n       builders {\n         name: \"v8_linux64_asan_rel_ng_triggered\"\n         triggered_by: \"v8_linux64_asan_rel_ng\"\n       }\n+      builders { name: \"v8_linux64_gcc_compile_dbg\" }\n       builders { name: \"v8_linux64_gyp_rel_ng\" }\n       builders {\n         name: \"v8_linux64_gyp_rel_ng_triggered\"\n@@ -52,6 +41,10 @@ verifiers {\n         name: \"v8_linux64_rel_ng_triggered\"\n         triggered_by: \"v8_linux64_rel_ng\"\n       }\n+      builders {\n+        name: \"v8_linux64_sanitizer_coverage_rel\"\n+        experiment_percentage: 100\n+      }\n       builders { name: \"v8_linux64_verify_csa_rel_ng\" }\n       builders {\n         name: \"v8_linux64_verify_csa_rel_ng_triggered\"\n@@ -67,14 +60,19 @@ verifiers {\n         name: \"v8_linux_arm_rel_ng_triggered\"\n         triggered_by: \"v8_linux_arm_rel_ng\"\n       }\n+      builders {\n+        name: \"v8_linux_blink_rel\"\n+        experiment_percentage: 100\n+      }\n       builders { name: \"v8_linux_chromium_gn_rel\" }\n       builders { name: \"v8_linux_dbg_ng\" }\n       builders {\n         name: \"v8_linux_dbg_ng_triggered\"\n         triggered_by: \"v8_linux_dbg_ng\"\n       }\n-      builders { name: \"v8_linux_mipsel_compile_rel\" }\n+      builders { name: \"v8_linux_gcc_compile_rel\" }\n       builders { name: \"v8_linux_mips64el_compile_rel\" }\n+      builders { name: \"v8_linux_mipsel_compile_rel\" }\n       builders { name: \"v8_linux_nodcheck_rel_ng\" }\n       builders {\n         name: \"v8_linux_nodcheck_rel_ng_triggered\"\n@@ -85,6 +83,7 @@ verifiers {\n         name: \"v8_linux_rel_ng_triggered\"\n         triggered_by: \"v8_linux_rel_ng\"\n       }\n+      builders { name: \"v8_linux_shared_compile_rel\" }\n       builders { name: \"v8_linux_verify_csa_rel_ng\" }\n       builders {\n         name: \"v8_linux_verify_csa_rel_ng_triggered\"\n@@ -95,6 +94,12 @@ verifiers {\n         name: \"v8_mac_rel_ng_triggered\"\n         triggered_by: \"v8_mac_rel_ng\"\n       }\n+      builders { name: \"v8_node_linux64_rel\" }\n+      builders { name: \"v8_presubmit\" }\n+      builders {\n+        name: \"v8_win64_msvc_compile_rel\"\n+        experiment_percentage: 20\n+      }\n       builders { name: \"v8_win64_rel_ng\" }\n       builders {\n         name: \"v8_win64_rel_ng_triggered\"\n@@ -111,21 +116,6 @@ verifiers {\n         name: \"v8_win_rel_ng_triggered\"\n         triggered_by: \"v8_win_rel_ng\"\n       }\n-      builders {\n-        name: \"v8_linux_blink_rel\"\n-        experiment_percentage: 100\n-      }\n-      builders {\n-        name: \"v8_linux64_sanitizer_coverage_rel\"\n-        experiment_percentage: 100\n-      }\n-    }\n-    buckets {\n-      name: \"master.tryserver.chromium.win\"\n-      builders {\n-        name: \"win_chromium_compile_dbg_ng\"\n-        experiment_percentage: 100\n-      }\n     }\n   }\n "
        },
        {
            "sha": "e025c98f9e2239980e2d4720c9f3fef84007ced1",
            "filename": "deps/v8/infra/mb/mb_config.pyl",
            "status": "modified",
            "additions": 18,
            "deletions": 1,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Fmb%2Fmb_config.pyl",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Fmb%2Fmb_config.pyl",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finfra%2Fmb%2Fmb_config.pyl?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -204,7 +204,8 @@\n       'v8_linux_gcc_rel': 'gn_release_x86_gcc_minimal_symbols',\n       'v8_linux_shared_compile_rel': 'gn_release_x86_shared_verify_heap',\n       'v8_linux64_gcc_compile_dbg': 'gn_debug_x64_gcc',\n-      'v8_linux64_rel_ng': 'gn_release_x64_trybot',\n+      'v8_linux64_fyi_rel_ng': 'gn_release_x64_test_features_trybot',\n+      'v8_linux64_rel_ng': 'gn_release_x64_test_features_trybot',\n       'v8_linux64_verify_csa_rel_ng': 'gn_release_x64_verify_csa',\n       'v8_linux64_gyp_rel_ng': 'gyp_release_x64',\n       'v8_linux64_asan_rel_ng': 'gn_release_x64_asan_minimal_symbols',\n@@ -428,6 +429,8 @@\n       'gn', 'release_bot', 'x64', 'minimal_symbols', 'swarming'],\n     'gn_release_x64_trybot': [\n       'gn', 'release_trybot', 'x64', 'swarming'],\n+    'gn_release_x64_test_features_trybot': [\n+      'gn', 'release_trybot', 'x64', 'swarming', 'v8_enable_test_features'],\n     'gn_release_x64_tsan': [\n       'gn', 'release_bot', 'x64', 'tsan', 'swarming'],\n     'gn_release_x64_tsan_concurrent_marking': [\n@@ -555,6 +558,7 @@\n     },\n \n     'asan': {\n+      'mixins': ['v8_enable_test_features'],\n       'gn_args': 'is_asan=true',\n       'gyp_defines': 'clang=1 asan=1',\n     },\n@@ -565,12 +569,14 @@\n     },\n \n     'cfi': {\n+      'mixins': ['v8_enable_test_features'],\n       'gn_args': ('is_cfi=true use_cfi_cast=true use_cfi_diag=true '\n                   'use_cfi_recover=false'),\n       'gyp_defines': 'cfi_vptr=1 cfi_diag=1',\n     },\n \n     'cfi_clusterfuzz': {\n+      'mixins': ['v8_enable_test_features'],\n       'gn_args': ('is_cfi=true use_cfi_cast=true use_cfi_diag=true '\n                   'use_cfi_recover=true'),\n       'gyp_defines': 'cfi_vptr=1 cfi_diag=1',\n@@ -647,6 +653,7 @@\n     },\n \n     'lsan': {\n+      'mixins': ['v8_enable_test_features'],\n       'gn_args': 'is_lsan=true',\n       'gyp_defines': 'lsan=1',\n     },\n@@ -662,11 +669,13 @@\n     },\n \n     'msan': {\n+      'mixins': ['v8_enable_test_features'],\n       'gn_args': ('is_msan=true msan_track_origins=2 '\n                   'use_prebuilt_instrumented_libraries=true'),\n     },\n \n     'msan_no_origins': {\n+      'mixins': ['v8_enable_test_features'],\n       'gn_args': ('is_msan=true msan_track_origins=0 '\n                   'use_prebuilt_instrumented_libraries=true'),\n     },\n@@ -756,18 +765,21 @@\n     },\n \n     'tsan': {\n+      'mixins': ['v8_enable_test_features'],\n       'gn_args': 'is_tsan=true',\n       'gyp_defines': 'clang=1 tsan=1',\n     },\n \n     'ubsan_vptr': {\n+      'mixins': ['v8_enable_test_features'],\n       # TODO(krasin): Remove is_ubsan_no_recover=true when\n       # https://llvm.org/bugs/show_bug.cgi?id=25569 is fixed and just use\n       # ubsan_vptr instead.\n       'gn_args': 'is_ubsan_vptr=true is_ubsan_no_recover=true',\n     },\n \n     'ubsan_vptr_recover': {\n+      'mixins': ['v8_enable_test_features'],\n       # Ubsan vptr with recovery.\n       'gn_args': 'is_ubsan_vptr=true is_ubsan_no_recover=false',\n     },\n@@ -782,6 +794,7 @@\n     },\n \n     'v8_correctness_fuzzer': {\n+      'mixins': ['v8_enable_test_features'],\n       'gn_args': 'v8_correctness_fuzzer=true v8_multi_arch_build=true',\n     },\n \n@@ -795,6 +808,10 @@\n       'gyp_defines': 'v8_enable_slow_dchecks=1',\n     },\n \n+    'v8_enable_test_features': {\n+      'gn_args': 'v8_enable_test_features=true',\n+    },\n+\n     'v8_enable_verify_predictable': {\n       'gn_args': 'v8_enable_verify_predictable=true',\n       'gyp_defines': 'v8_enable_verify_predictable=1',"
        },
        {
            "sha": "8658768cac91021a485ed208f1ae896b1c7856bd",
            "filename": "deps/v8/infra/testing/README.md",
            "status": "modified",
            "additions": 28,
            "deletions": 8,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Ftesting%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Ftesting%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finfra%2Ftesting%2FREADME.md?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -1,8 +1,15 @@\n # Src-side test specifications\n \n-The infra/testing folder in V8 contains test specifications, consumed and\n-executed by the continuous infrastructure. Every master has an optional file\n-named `<mastername>.pyl`. E.g. `tryserver.v8.pyl`.\n+Src-side test specifications enable developers to quickly add tests running on\n+specific bots on V8's continuous infrastructure (CI) or tryserver. Features to\n+be tested must live behind runtime flags, which are mapped to named testing\n+variants specified [here](https://chromium.googlesource.com/v8/v8/+/master/tools/testrunner/local/variants.py).\n+Changes to src-side test specifications go through CQ like any other CL and\n+require tests added for specific trybots to pass.\n+\n+The test specifications are defined in a V8-side folder called infra/testing.\n+Every master has an optional file named `<mastername>.pyl`. E.g.\n+`tryserver.v8.pyl`.\n \n The structure of each file is:\n ```\n@@ -21,10 +28,10 @@ The structure of each file is:\n The `<buildername>` is a string name of the builder to execute the tests.\n `<test-spec name>` is a label defining a test specification matching the\n [infra-side](https://chromium.googlesource.com/chromium/tools/build/+/master/scripts/slave/recipe_modules/v8/testing.py#58).\n-The `<variant name>` is a testing variant as specified in\n-`v8/tools/testrunner/local/variants.py`. `<number of shards>` is optional\n-(default 1), but can be provided to increase the swarming shards for\n-long-running tests.\n+The `<variant name>` is a testing variant specified\n+[here](https://chromium.googlesource.com/v8/v8/+/master/tools/testrunner/local/variants.py).\n+`<number of shards>` is optional (default 1), but can be provided to increase\n+the swarming shards for long-running tests.\n \n Example:\n ```\n@@ -47,4 +54,17 @@ tryserver.v8:\n client.v8:\n   V8 Linux64\n   V8 Linux64 - debug\n-```\n\\ No newline at end of file\n+```\n+\n+Please only add tests that are expected to pass, or skip failing tests via\n+status file for the selected testing variants only. If you want to add FYI tests\n+(i.e. not closing the tree and not blocking CQ) you can do so for the following\n+set of bots:\n+\n+```\n+tryserver.v8:\n+  v8_linux64_fyi_rel_ng_triggered\n+client.v8:\n+  V8 Linux64 - fyi\n+  V8 Linux64 - debug - fyi\n+```"
        },
        {
            "sha": "ab1744fc78b33e3f0b32bda55dd81fc82675f80c",
            "filename": "deps/v8/infra/testing/client.v8.pyl",
            "status": "modified",
            "additions": 36,
            "deletions": 1,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Ftesting%2Fclient.v8.pyl",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Ftesting%2Fclient.v8.pyl",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finfra%2Ftesting%2Fclient.v8.pyl?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -10,4 +10,39 @@\n   # 'V8 Linux64 - debug': [\n   #   {'name': 'benchmarks', 'variant': 'default', 'shards': 1},\n   # ],\n-}\n\\ No newline at end of file\n+\n+  'V8 Linux - debug': [\n+    {'name': 'd8testing', 'variant': 'code_serializer', 'shards': 1},\n+    {'name': 'mozilla', 'variant': 'code_serializer', 'shards': 1},\n+    {'name': 'test262_variants', 'variant': 'code_serializer', 'shards': 1},\n+    {'name': 'benchmarks', 'variant': 'code_serializer', 'shards': 1},\n+  ],\n+  'V8 Linux - gc stress': [\n+    {'name': 'mjsunit', 'variant': 'slow_path', 'shards': 2},\n+  ],\n+  'V8 Linux64': [\n+    {'name': 'v8testing', 'variant': 'minor_mc', 'shards': 1},\n+  ],\n+  'V8 Linux64 - debug': [\n+    {'name': 'v8testing', 'variant': 'minor_mc', 'shards': 1},\n+    {'name': 'v8testing', 'variant': 'slow_path', 'shards': 1},\n+  ],\n+  'V8 Linux64 ASAN': [\n+    {'name': 'v8testing', 'variant': 'slow_path', 'shards': 1},\n+  ],\n+  'V8 Linux64 TSAN': [\n+    {'name': 'v8testing', 'variant': 'slow_path', 'shards': 1},\n+  ],\n+  'V8 Linux64 - fyi': [\n+    {'name': 'v8testing', 'variant': 'infra_staging', 'shards': 1},\n+    {'name': 'test262_variants', 'variant': 'infra_staging', 'shards': 2},\n+    {'name': 'mjsunit', 'variant': 'stress_sampling', 'shards': 1},\n+    {'name': 'webkit', 'variant': 'stress_sampling', 'shards': 1},\n+  ],\n+  'V8 Linux64 - debug - fyi': [\n+    {'name': 'v8testing', 'variant': 'infra_staging', 'shards': 2},\n+    {'name': 'test262_variants', 'variant': 'infra_staging', 'shards': 3},\n+    {'name': 'mjsunit', 'variant': 'stress_sampling', 'shards': 1},\n+    {'name': 'webkit', 'variant': 'stress_sampling', 'shards': 1},\n+  ],\n+}"
        },
        {
            "sha": "ee6abae5d533d3e1fcbd26ce37cd17ea7b1bdc8d",
            "filename": "deps/v8/infra/testing/tryserver.v8.pyl",
            "status": "modified",
            "additions": 21,
            "deletions": 1,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Ftesting%2Ftryserver.v8.pyl",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Finfra%2Ftesting%2Ftryserver.v8.pyl",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finfra%2Ftesting%2Ftryserver.v8.pyl?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -7,4 +7,24 @@\n   # 'v8_linux64_rel_ng_triggered': [\n   #   {'name': 'benchmarks', 'variant': 'default', 'shards': 1},\n   # ],\n-}\n\\ No newline at end of file\n+\n+  'v8_linux64_fyi_rel_ng_triggered': [\n+    {'name': 'v8testing', 'variant': 'infra_staging', 'shards': 2},\n+    {'name': 'test262_variants', 'variant': 'infra_staging', 'shards': 2},\n+    {'name': 'mjsunit', 'variant': 'stress_sampling', 'shards': 1},\n+    {'name': 'webkit', 'variant': 'stress_sampling', 'shards': 1},\n+  ],\n+  'v8_linux64_rel_ng_triggered': [\n+    {'name': 'v8testing', 'variant': 'minor_mc', 'shards': 1},\n+    {'name': 'v8testing', 'variant': 'slow_path', 'shards': 1},\n+  ],\n+  'v8_linux_gc_stress_dbg': [\n+    {'name': 'mjsunit', 'variant': 'slow_path', 'shards': 2},\n+  ],\n+  'v8_linux64_asan_rel_ng_triggered': [\n+    {'name': 'v8testing', 'variant': 'slow_path', 'shards': 1},\n+  ],\n+  'v8_linux64_tsan_rel': [\n+    {'name': 'v8testing', 'variant': 'slow_path', 'shards': 1},\n+  ],\n+}"
        },
        {
            "sha": "eb8928868572131a454ad03213d723a282765ac1",
            "filename": "deps/v8/src/accessors.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 18,
            "changes": 39,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Faccessors.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Faccessors.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Faccessors.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -102,7 +102,7 @@ void Accessors::ReconfigureToDataProperty(\n     const v8::PropertyCallbackInfo<v8::Boolean>& info) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n   RuntimeCallTimerScope stats_scope(\n-      isolate, &RuntimeCallStats::ReconfigureToDataProperty);\n+      isolate, RuntimeCallCounterId::kReconfigureToDataProperty);\n   HandleScope scope(isolate);\n   Handle<Object> receiver = Utils::OpenHandle(*info.This());\n   Handle<JSObject> holder =\n@@ -147,7 +147,8 @@ void Accessors::ArrayLengthGetter(\n     v8::Local<v8::Name> name,\n     const v8::PropertyCallbackInfo<v8::Value>& info) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::ArrayLengthGetter);\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kArrayLengthGetter);\n   DisallowHeapAllocation no_allocation;\n   HandleScope scope(isolate);\n   JSArray* holder = JSArray::cast(*Utils::OpenHandle(*info.Holder()));\n@@ -159,7 +160,8 @@ void Accessors::ArrayLengthSetter(\n     v8::Local<v8::Name> name, v8::Local<v8::Value> val,\n     const v8::PropertyCallbackInfo<v8::Boolean>& info) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::ArrayLengthSetter);\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kArrayLengthSetter);\n   HandleScope scope(isolate);\n \n   DCHECK(Utils::OpenHandle(*name)->SameValue(isolate->heap()->length_string()));\n@@ -272,7 +274,8 @@ void Accessors::StringLengthGetter(\n     v8::Local<v8::Name> name,\n     const v8::PropertyCallbackInfo<v8::Value>& info) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::StringLengthGetter);\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kStringLengthGetter);\n   DisallowHeapAllocation no_allocation;\n   HandleScope scope(isolate);\n \n@@ -546,9 +549,8 @@ void Accessors::ScriptEvalFromScriptGetter(\n   Handle<Script> script(\n       Script::cast(Handle<JSValue>::cast(object)->value()), isolate);\n   Handle<Object> result = isolate->factory()->undefined_value();\n-  if (!script->eval_from_shared()->IsUndefined(isolate)) {\n-    Handle<SharedFunctionInfo> eval_from_shared(\n-        SharedFunctionInfo::cast(script->eval_from_shared()));\n+  if (script->has_eval_from_shared()) {\n+    Handle<SharedFunctionInfo> eval_from_shared(script->eval_from_shared());\n     if (eval_from_shared->script()->IsScript()) {\n       Handle<Script> eval_from_script(Script::cast(eval_from_shared->script()));\n       result = Script::GetWrapper(eval_from_script);\n@@ -608,9 +610,8 @@ void Accessors::ScriptEvalFromFunctionNameGetter(\n   Handle<Script> script(\n       Script::cast(Handle<JSValue>::cast(object)->value()), isolate);\n   Handle<Object> result = isolate->factory()->undefined_value();\n-  if (!script->eval_from_shared()->IsUndefined(isolate)) {\n-    Handle<SharedFunctionInfo> shared(\n-        SharedFunctionInfo::cast(script->eval_from_shared()));\n+  if (script->has_eval_from_shared()) {\n+    Handle<SharedFunctionInfo> shared(script->eval_from_shared());\n     // Find the name of the function calling eval.\n     result = Handle<Object>(shared->name(), isolate);\n   }\n@@ -644,7 +645,7 @@ void Accessors::FunctionPrototypeGetter(\n     const v8::PropertyCallbackInfo<v8::Value>& info) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n   RuntimeCallTimerScope timer(isolate,\n-                              &RuntimeCallStats::FunctionPrototypeGetter);\n+                              RuntimeCallCounterId::kFunctionPrototypeGetter);\n   HandleScope scope(isolate);\n   Handle<JSFunction> function =\n       Handle<JSFunction>::cast(Utils::OpenHandle(*info.Holder()));\n@@ -657,7 +658,7 @@ void Accessors::FunctionPrototypeSetter(\n     const v8::PropertyCallbackInfo<v8::Boolean>& info) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n   RuntimeCallTimerScope timer(isolate,\n-                              &RuntimeCallStats::FunctionPrototypeSetter);\n+                              RuntimeCallCounterId::kFunctionPrototypeSetter);\n   HandleScope scope(isolate);\n   Handle<Object> value = Utils::OpenHandle(*val);\n   Handle<JSFunction> object =\n@@ -681,7 +682,8 @@ void Accessors::FunctionLengthGetter(\n     v8::Local<v8::Name> name,\n     const v8::PropertyCallbackInfo<v8::Value>& info) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::FunctionLengthGetter);\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kFunctionLengthGetter);\n   HandleScope scope(isolate);\n   Handle<JSFunction> function =\n       Handle<JSFunction>::cast(Utils::OpenHandle(*info.Holder()));\n@@ -950,16 +952,17 @@ class FrameFunctionIterator {\n  private:\n   MaybeHandle<JSFunction> next() {\n     while (true) {\n-      inlined_frame_index_--;\n-      if (inlined_frame_index_ == -1) {\n+      if (inlined_frame_index_ <= 0) {\n         if (!frame_iterator_.done()) {\n           frame_iterator_.Advance();\n           frames_.clear();\n+          inlined_frame_index_ = -1;\n           GetFrames();\n         }\n         if (inlined_frame_index_ == -1) return MaybeHandle<JSFunction>();\n-        inlined_frame_index_--;\n       }\n+\n+      --inlined_frame_index_;\n       Handle<JSFunction> next_function =\n           frames_[inlined_frame_index_].AsJavaScript().function();\n       // Skip functions from other origins.\n@@ -1057,7 +1060,7 @@ void Accessors::BoundFunctionLengthGetter(\n     v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n   RuntimeCallTimerScope timer(isolate,\n-                              &RuntimeCallStats::BoundFunctionLengthGetter);\n+                              RuntimeCallCounterId::kBoundFunctionLengthGetter);\n   HandleScope scope(isolate);\n   Handle<JSBoundFunction> function =\n       Handle<JSBoundFunction>::cast(Utils::OpenHandle(*info.Holder()));\n@@ -1084,7 +1087,7 @@ void Accessors::BoundFunctionNameGetter(\n     v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n   RuntimeCallTimerScope timer(isolate,\n-                              &RuntimeCallStats::BoundFunctionNameGetter);\n+                              RuntimeCallCounterId::kBoundFunctionNameGetter);\n   HandleScope scope(isolate);\n   Handle<JSBoundFunction> function =\n       Handle<JSBoundFunction>::cast(Utils::OpenHandle(*info.Holder()));"
        },
        {
            "sha": "e17de159c12b09b10314ae0f936e0ccbf1392c8b",
            "filename": "deps/v8/src/allocation.cc",
            "status": "modified",
            "additions": 130,
            "deletions": 57,
            "changes": 187,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fallocation.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fallocation.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fallocation.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -6,7 +6,9 @@\n \n #include <stdlib.h>  // For free, malloc.\n #include \"src/base/bits.h\"\n+#include \"src/base/lazy-instance.h\"\n #include \"src/base/logging.h\"\n+#include \"src/base/page-allocator.h\"\n #include \"src/base/platform/platform.h\"\n #include \"src/utils.h\"\n #include \"src/v8.h\"\n@@ -38,26 +40,44 @@ void* AlignedAllocInternal(size_t size, size_t alignment) {\n   return ptr;\n }\n \n+// TODO(bbudge) Simplify this once all embedders implement a page allocator.\n+struct InitializePageAllocator {\n+  static void Construct(void* page_allocator_ptr_arg) {\n+    auto page_allocator_ptr =\n+        reinterpret_cast<v8::PageAllocator**>(page_allocator_ptr_arg);\n+    v8::PageAllocator* page_allocator =\n+        V8::GetCurrentPlatform()->GetPageAllocator();\n+    if (page_allocator == nullptr) {\n+      static v8::base::PageAllocator default_allocator;\n+      page_allocator = &default_allocator;\n+    }\n+    *page_allocator_ptr = page_allocator;\n+  }\n+};\n+\n+static base::LazyInstance<v8::PageAllocator*, InitializePageAllocator>::type\n+    page_allocator = LAZY_INSTANCE_INITIALIZER;\n+\n+v8::PageAllocator* GetPageAllocator() { return page_allocator.Get(); }\n+\n+// We will attempt allocation this many times. After each failure, we call\n+// OnCriticalMemoryPressure to try to free some memory.\n+const int kAllocationTries = 2;\n+\n }  // namespace\n \n void* Malloced::New(size_t size) {\n-  void* result = malloc(size);\n+  void* result = AllocWithRetry(size);\n   if (result == nullptr) {\n-    V8::GetCurrentPlatform()->OnCriticalMemoryPressure();\n-    result = malloc(size);\n-    if (result == nullptr) {\n-      V8::FatalProcessOutOfMemory(\"Malloced operator new\");\n-    }\n+    V8::FatalProcessOutOfMemory(\"Malloced operator new\");\n   }\n   return result;\n }\n \n-\n void Malloced::Delete(void* p) {\n   free(p);\n }\n \n-\n char* StrDup(const char* str) {\n   int length = StrLength(str);\n   char* result = NewArray<char>(length + 1);\n@@ -66,7 +86,6 @@ char* StrDup(const char* str) {\n   return result;\n }\n \n-\n char* StrNDup(const char* str, int n) {\n   int length = StrLength(str);\n   if (n < length) length = n;\n@@ -76,22 +95,31 @@ char* StrNDup(const char* str, int n) {\n   return result;\n }\n \n+void* AllocWithRetry(size_t size) {\n+  void* result = nullptr;\n+  for (int i = 0; i < kAllocationTries; ++i) {\n+    result = malloc(size);\n+    if (result != nullptr) break;\n+    if (!OnCriticalMemoryPressure(size)) break;\n+  }\n+  return result;\n+}\n \n void* AlignedAlloc(size_t size, size_t alignment) {\n   DCHECK_LE(V8_ALIGNOF(void*), alignment);\n   DCHECK(base::bits::IsPowerOfTwo(alignment));\n-  void* ptr = AlignedAllocInternal(size, alignment);\n-  if (ptr == nullptr) {\n-    V8::GetCurrentPlatform()->OnCriticalMemoryPressure();\n-    ptr = AlignedAllocInternal(size, alignment);\n-    if (ptr == nullptr) {\n-      V8::FatalProcessOutOfMemory(\"AlignedAlloc\");\n-    }\n+  void* result = nullptr;\n+  for (int i = 0; i < kAllocationTries; ++i) {\n+    result = AlignedAllocInternal(size, alignment);\n+    if (result != nullptr) break;\n+    if (!OnCriticalMemoryPressure(size + alignment)) break;\n   }\n-  return ptr;\n+  if (result == nullptr) {\n+    V8::FatalProcessOutOfMemory(\"AlignedAlloc\");\n+  }\n+  return result;\n }\n \n-\n void AlignedFree(void *ptr) {\n #if V8_OS_WIN\n   _aligned_free(ptr);\n@@ -103,27 +131,88 @@ void AlignedFree(void *ptr) {\n #endif\n }\n \n-byte* AllocateSystemPage(void* address, size_t* allocated) {\n-  size_t page_size = base::OS::AllocatePageSize();\n-  void* result = base::OS::Allocate(address, page_size, page_size,\n-                                    base::OS::MemoryPermission::kReadWrite);\n+size_t AllocatePageSize() { return GetPageAllocator()->AllocatePageSize(); }\n+\n+size_t CommitPageSize() { return GetPageAllocator()->CommitPageSize(); }\n+\n+void SetRandomMmapSeed(int64_t seed) {\n+  GetPageAllocator()->SetRandomMmapSeed(seed);\n+}\n+\n+void* GetRandomMmapAddr() { return GetPageAllocator()->GetRandomMmapAddr(); }\n+\n+void* AllocatePages(void* address, size_t size, size_t alignment,\n+                    PageAllocator::Permission access) {\n+  void* result = nullptr;\n+  for (int i = 0; i < kAllocationTries; ++i) {\n+    result =\n+        GetPageAllocator()->AllocatePages(address, size, alignment, access);\n+    if (result != nullptr) break;\n+    size_t request_size = size + alignment - AllocatePageSize();\n+    if (!OnCriticalMemoryPressure(request_size)) break;\n+  }\n+#if defined(LEAK_SANITIZER)\n+  if (result != nullptr) {\n+    __lsan_register_root_region(result, size);\n+  }\n+#endif\n+  return result;\n+}\n+\n+bool FreePages(void* address, const size_t size) {\n+  bool result = GetPageAllocator()->FreePages(address, size);\n+#if defined(LEAK_SANITIZER)\n+  if (result) {\n+    __lsan_unregister_root_region(address, size);\n+  }\n+#endif\n+  return result;\n+}\n+\n+bool ReleasePages(void* address, size_t size, size_t new_size) {\n+  DCHECK_LT(new_size, size);\n+  bool result = GetPageAllocator()->ReleasePages(address, size, new_size);\n+#if defined(LEAK_SANITIZER)\n+  if (result) {\n+    __lsan_unregister_root_region(address, size);\n+    __lsan_register_root_region(address, new_size);\n+  }\n+#endif\n+  return result;\n+}\n+\n+bool SetPermissions(void* address, size_t size,\n+                    PageAllocator::Permission access) {\n+  return GetPageAllocator()->SetPermissions(address, size, access);\n+}\n+\n+byte* AllocatePage(void* address, size_t* allocated) {\n+  size_t page_size = AllocatePageSize();\n+  void* result =\n+      AllocatePages(address, page_size, page_size, PageAllocator::kReadWrite);\n   if (result != nullptr) *allocated = page_size;\n   return static_cast<byte*>(result);\n }\n \n+bool OnCriticalMemoryPressure(size_t length) {\n+  // TODO(bbudge) Rework retry logic once embedders implement the more\n+  // informative overload.\n+  if (!V8::GetCurrentPlatform()->OnCriticalMemoryPressure(length)) {\n+    V8::GetCurrentPlatform()->OnCriticalMemoryPressure();\n+  }\n+  return true;\n+}\n+\n VirtualMemory::VirtualMemory() : address_(nullptr), size_(0) {}\n \n VirtualMemory::VirtualMemory(size_t size, void* hint, size_t alignment)\n     : address_(nullptr), size_(0) {\n-  size_t page_size = base::OS::AllocatePageSize();\n+  size_t page_size = AllocatePageSize();\n   size_t alloc_size = RoundUp(size, page_size);\n-  address_ = base::OS::Allocate(hint, alloc_size, alignment,\n-                                base::OS::MemoryPermission::kNoAccess);\n+  address_ =\n+      AllocatePages(hint, alloc_size, alignment, PageAllocator::kNoAccess);\n   if (address_ != nullptr) {\n     size_ = alloc_size;\n-#if defined(LEAK_SANITIZER)\n-    __lsan_register_root_region(address_, size_);\n-#endif\n   }\n }\n \n@@ -139,18 +228,17 @@ void VirtualMemory::Reset() {\n }\n \n bool VirtualMemory::SetPermissions(void* address, size_t size,\n-                                   base::OS::MemoryPermission access) {\n+                                   PageAllocator::Permission access) {\n   CHECK(InVM(address, size));\n-  bool result = base::OS::SetPermissions(address, size, access);\n+  bool result = v8::internal::SetPermissions(address, size, access);\n   DCHECK(result);\n   USE(result);\n   return result;\n }\n \n size_t VirtualMemory::Release(void* free_start) {\n   DCHECK(IsReserved());\n-  DCHECK(IsAddressAligned(static_cast<Address>(free_start),\n-                          base::OS::CommitPageSize()));\n+  DCHECK(IsAddressAligned(static_cast<Address>(free_start), CommitPageSize()));\n   // Notice: Order is important here. The VirtualMemory object might live\n   // inside the allocated region.\n   const size_t free_size = size_ - (reinterpret_cast<size_t>(free_start) -\n@@ -159,11 +247,7 @@ size_t VirtualMemory::Release(void* free_start) {\n   DCHECK_LT(address_, free_start);\n   DCHECK_LT(free_start, reinterpret_cast<void*>(\n                             reinterpret_cast<size_t>(address_) + size_));\n-#if defined(LEAK_SANITIZER)\n-  __lsan_unregister_root_region(address_, size_);\n-  __lsan_register_root_region(address_, size_ - free_size);\n-#endif\n-  CHECK(base::OS::Release(free_start, free_size));\n+  CHECK(ReleasePages(address_, size_, size_ - free_size));\n   size_ -= free_size;\n   return free_size;\n }\n@@ -176,10 +260,7 @@ void VirtualMemory::Free() {\n   size_t size = size_;\n   CHECK(InVM(address, size));\n   Reset();\n-#if defined(LEAK_SANITIZER)\n-  __lsan_unregister_root_region(address, size);\n-#endif\n-  CHECK(base::OS::Free(address, size));\n+  CHECK(FreePages(address, size));\n }\n \n void VirtualMemory::TakeControl(VirtualMemory* from) {\n@@ -190,30 +271,22 @@ void VirtualMemory::TakeControl(VirtualMemory* from) {\n }\n \n bool AllocVirtualMemory(size_t size, void* hint, VirtualMemory* result) {\n-  VirtualMemory first_try(size, hint);\n-  if (first_try.IsReserved()) {\n-    result->TakeControl(&first_try);\n+  VirtualMemory vm(size, hint);\n+  if (vm.IsReserved()) {\n+    result->TakeControl(&vm);\n     return true;\n   }\n-\n-  V8::GetCurrentPlatform()->OnCriticalMemoryPressure();\n-  VirtualMemory second_try(size, hint);\n-  result->TakeControl(&second_try);\n-  return result->IsReserved();\n+  return false;\n }\n \n bool AlignedAllocVirtualMemory(size_t size, size_t alignment, void* hint,\n                                VirtualMemory* result) {\n-  VirtualMemory first_try(size, hint, alignment);\n-  if (first_try.IsReserved()) {\n-    result->TakeControl(&first_try);\n+  VirtualMemory vm(size, hint, alignment);\n+  if (vm.IsReserved()) {\n+    result->TakeControl(&vm);\n     return true;\n   }\n-\n-  V8::GetCurrentPlatform()->OnCriticalMemoryPressure();\n-  VirtualMemory second_try(size, hint, alignment);\n-  result->TakeControl(&second_try);\n-  return result->IsReserved();\n+  return false;\n }\n \n }  // namespace internal"
        },
        {
            "sha": "9bb47c8f05d2a1f0f025a43ee6bbde19c61f8f29",
            "filename": "deps/v8/src/allocation.h",
            "status": "modified",
            "additions": 60,
            "deletions": 7,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fallocation.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fallocation.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fallocation.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -72,14 +72,68 @@ class FreeStoreAllocationPolicy {\n   INLINE(static void Delete(void* p)) { Malloced::Delete(p); }\n };\n \n+// Performs a malloc, with retry logic on failure. Returns nullptr on failure.\n+// Call free to release memory allocated with this function.\n+void* AllocWithRetry(size_t size);\n \n void* AlignedAlloc(size_t size, size_t alignment);\n void AlignedFree(void *ptr);\n \n-// Allocates a single system memory page with read/write permissions. The\n-// address parameter is a hint. Returns the base address of the memory, or null\n-// on failure. Permissions can be changed on the base address.\n-byte* AllocateSystemPage(void* address, size_t* allocated);\n+// Gets the page granularity for AllocatePages and FreePages. Addresses returned\n+// by AllocatePages and AllocatePage are aligned to this size.\n+V8_EXPORT_PRIVATE size_t AllocatePageSize();\n+\n+// Gets the granularity at which the permissions and release calls can be made.\n+V8_EXPORT_PRIVATE size_t CommitPageSize();\n+\n+// Sets the random seed so that GetRandomMmapAddr() will generate repeatable\n+// sequences of random mmap addresses.\n+V8_EXPORT_PRIVATE void SetRandomMmapSeed(int64_t seed);\n+\n+// Generate a random address to be used for hinting allocation calls.\n+V8_EXPORT_PRIVATE void* GetRandomMmapAddr();\n+\n+// Allocates memory. Permissions are set according to the access argument.\n+// |address| is a hint. |size| and |alignment| must be multiples of\n+// AllocatePageSize(). Returns the address of the allocated memory, with the\n+// specified size and alignment, or nullptr on failure.\n+V8_EXPORT_PRIVATE\n+V8_WARN_UNUSED_RESULT void* AllocatePages(void* address, size_t size,\n+                                          size_t alignment,\n+                                          PageAllocator::Permission access);\n+\n+// Frees memory allocated by a call to AllocatePages. |address| and |size| must\n+// be multiples of AllocatePageSize(). Returns true on success, otherwise false.\n+V8_EXPORT_PRIVATE\n+V8_WARN_UNUSED_RESULT bool FreePages(void* address, const size_t size);\n+\n+// Releases memory that is no longer needed. The range specified by |address|\n+// and |size| must be an allocated memory region. |size| and |new_size| must be\n+// multiples of CommitPageSize(). Memory from |new_size| to |size| is released.\n+// Released memory is left in an undefined state, so it should not be accessed.\n+// Returns true on success, otherwise false.\n+V8_EXPORT_PRIVATE\n+V8_WARN_UNUSED_RESULT bool ReleasePages(void* address, size_t size,\n+                                        size_t new_size);\n+\n+// Sets permissions according to |access|. |address| and |size| must be\n+// multiples of CommitPageSize(). Setting permission to kNoAccess may\n+// cause the memory contents to be lost. Returns true on success, otherwise\n+// false.\n+V8_EXPORT_PRIVATE\n+V8_WARN_UNUSED_RESULT bool SetPermissions(void* address, size_t size,\n+                                          PageAllocator::Permission access);\n+\n+// Convenience function that allocates a single system page with read and write\n+// permissions. |address| is a hint. Returns the base address of the memory and\n+// the page size via |allocated| on success. Returns nullptr on failure.\n+V8_EXPORT_PRIVATE\n+V8_WARN_UNUSED_RESULT byte* AllocatePage(void* address, size_t* allocated);\n+\n+// Function that may release reserved memory regions to allow failed allocations\n+// to succeed. |length| is the amount of memory needed. Returns |true| if memory\n+// could be released, false otherwise.\n+V8_EXPORT_PRIVATE bool OnCriticalMemoryPressure(size_t length);\n \n // Represents and controls an area of reserved memory.\n class V8_EXPORT_PRIVATE VirtualMemory {\n@@ -90,8 +144,7 @@ class V8_EXPORT_PRIVATE VirtualMemory {\n   // Reserves virtual memory containing an area of the given size that is\n   // aligned per alignment. This may not be at the position returned by\n   // address().\n-  VirtualMemory(size_t size, void* hint,\n-                size_t alignment = base::OS::AllocatePageSize());\n+  VirtualMemory(size_t size, void* hint, size_t alignment = AllocatePageSize());\n \n   // Construct a virtual memory by assigning it some already mapped address\n   // and size.\n@@ -131,7 +184,7 @@ class V8_EXPORT_PRIVATE VirtualMemory {\n   // Sets permissions according to the access argument. address and size must be\n   // multiples of CommitPageSize(). Returns true on success, otherwise false.\n   bool SetPermissions(void* address, size_t size,\n-                      base::OS::MemoryPermission access);\n+                      PageAllocator::Permission access);\n \n   // Releases memory after |free_start|. Returns the number of bytes released.\n   size_t Release(void* free_start);"
        },
        {
            "sha": "b8336f97c4fbe2103199ac537df1dc5d76220fae",
            "filename": "deps/v8/src/api-arguments-inl.h",
            "status": "modified",
            "additions": 197,
            "deletions": 95,
            "changes": 292,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi-arguments-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi-arguments-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi-arguments-inl.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -13,146 +13,248 @@\n namespace v8 {\n namespace internal {\n \n-#define SIDE_EFFECT_CHECK(ISOLATE, F, RETURN_TYPE)            \\\n-  do {                                                        \\\n-    if (ISOLATE->needs_side_effect_check() &&                 \\\n-        !PerformSideEffectCheck(ISOLATE, FUNCTION_ADDR(F))) { \\\n-      return Handle<RETURN_TYPE>();                           \\\n-    }                                                         \\\n-  } while (false)\n-\n-#define FOR_EACH_CALLBACK_TABLE_MAPPING_1_NAME(F)                  \\\n-  F(AccessorNameGetterCallback, \"get\", v8::Value, Object)          \\\n-  F(GenericNamedPropertyQueryCallback, \"has\", v8::Integer, Object) \\\n-  F(GenericNamedPropertyDeleterCallback, \"delete\", v8::Boolean, Object)\n-\n-#define WRITE_CALL_1_NAME(Function, type, ApiReturn, InternalReturn)          \\\n-  Handle<InternalReturn> PropertyCallbackArguments::Call(Function f,          \\\n-                                                         Handle<Name> name) { \\\n+#define FOR_EACH_CALLBACK(F)           \\\n+  F(Query, query, Object, v8::Integer) \\\n+  F(Deleter, deleter, Object, v8::Boolean)\n+\n+#define PREPARE_CALLBACK_INFO(ISOLATE, F, RETURN_VALUE, API_RETURN_TYPE) \\\n+  if (ISOLATE->needs_side_effect_check() &&                              \\\n+      !PerformSideEffectCheck(ISOLATE, FUNCTION_ADDR(F))) {              \\\n+    return RETURN_VALUE();                                               \\\n+  }                                                                      \\\n+  VMState<EXTERNAL> state(ISOLATE);                                      \\\n+  ExternalCallbackScope call_scope(ISOLATE, FUNCTION_ADDR(F));           \\\n+  PropertyCallbackInfo<API_RETURN_TYPE> callback_info(begin());\n+\n+#define CREATE_NAMED_CALLBACK(Function, type, ReturnType, ApiReturnType)      \\\n+  Handle<ReturnType> PropertyCallbackArguments::CallNamed##Function(          \\\n+      Handle<InterceptorInfo> interceptor, Handle<Name> name) {               \\\n+    DCHECK(interceptor->is_named());                                          \\\n+    DCHECK(!name->IsPrivate());                                               \\\n+    DCHECK_IMPLIES(name->IsSymbol(), interceptor->can_intercept_symbols());   \\\n     Isolate* isolate = this->isolate();                                       \\\n-    SIDE_EFFECT_CHECK(isolate, f, InternalReturn);                            \\\n-    RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::Function);        \\\n-    VMState<EXTERNAL> state(isolate);                                         \\\n-    ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f));              \\\n-    PropertyCallbackInfo<ApiReturn> info(begin());                            \\\n+    RuntimeCallTimerScope timer(                                              \\\n+        isolate, RuntimeCallCounterId::kNamed##Function##Callback);           \\\n+    DCHECK(!name->IsPrivate());                                               \\\n+    GenericNamedProperty##Function##Callback f =                              \\\n+        ToCData<GenericNamedProperty##Function##Callback>(                    \\\n+            interceptor->type());                                             \\\n+    PREPARE_CALLBACK_INFO(isolate, f, Handle<ReturnType>, ApiReturnType);     \\\n     LOG(isolate,                                                              \\\n-        ApiNamedPropertyAccess(\"interceptor-named-\" type, holder(), *name));  \\\n-    f(v8::Utils::ToLocal(name), info);                                        \\\n-    return GetReturnValue<InternalReturn>(isolate);                           \\\n+        ApiNamedPropertyAccess(\"interceptor-named-\" #type, holder(), *name)); \\\n+    f(v8::Utils::ToLocal(name), callback_info);                               \\\n+    return GetReturnValue<ReturnType>(isolate);                               \\\n   }\n \n-FOR_EACH_CALLBACK_TABLE_MAPPING_1_NAME(WRITE_CALL_1_NAME)\n-\n-#undef FOR_EACH_CALLBACK_TABLE_MAPPING_1_NAME\n-#undef WRITE_CALL_1_NAME\n+FOR_EACH_CALLBACK(CREATE_NAMED_CALLBACK)\n+#undef CREATE_NAMED_CALLBACK\n \n-#define FOR_EACH_CALLBACK_TABLE_MAPPING_1_INDEX(F)            \\\n-  F(IndexedPropertyGetterCallback, \"get\", v8::Value, Object)  \\\n-  F(IndexedPropertyQueryCallback, \"has\", v8::Integer, Object) \\\n-  F(IndexedPropertyDeleterCallback, \"delete\", v8::Boolean, Object)\n-\n-#define WRITE_CALL_1_INDEX(Function, type, ApiReturn, InternalReturn)      \\\n-  Handle<InternalReturn> PropertyCallbackArguments::Call(Function f,       \\\n-                                                         uint32_t index) { \\\n+#define CREATE_INDEXED_CALLBACK(Function, type, ReturnType, ApiReturnType) \\\n+  Handle<ReturnType> PropertyCallbackArguments::CallIndexed##Function(     \\\n+      Handle<InterceptorInfo> interceptor, uint32_t index) {               \\\n+    DCHECK(!interceptor->is_named());                                      \\\n     Isolate* isolate = this->isolate();                                    \\\n-    SIDE_EFFECT_CHECK(isolate, f, InternalReturn);                         \\\n-    RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::Function);     \\\n-    VMState<EXTERNAL> state(isolate);                                      \\\n-    ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f));           \\\n-    PropertyCallbackInfo<ApiReturn> info(begin());                         \\\n-    LOG(isolate, ApiIndexedPropertyAccess(\"interceptor-indexed-\" type,     \\\n+    RuntimeCallTimerScope timer(                                           \\\n+        isolate, RuntimeCallCounterId::kIndexed##Function##Callback);      \\\n+    IndexedProperty##Function##Callback f =                                \\\n+        ToCData<IndexedProperty##Function##Callback>(interceptor->type()); \\\n+    PREPARE_CALLBACK_INFO(isolate, f, Handle<ReturnType>, ApiReturnType);  \\\n+    LOG(isolate, ApiIndexedPropertyAccess(\"interceptor-indexed-\" #type,    \\\n                                           holder(), index));               \\\n-    f(index, info);                                                        \\\n-    return GetReturnValue<InternalReturn>(isolate);                        \\\n+    f(index, callback_info);                                               \\\n+    return GetReturnValue<ReturnType>(isolate);                            \\\n   }\n \n-FOR_EACH_CALLBACK_TABLE_MAPPING_1_INDEX(WRITE_CALL_1_INDEX)\n+FOR_EACH_CALLBACK(CREATE_INDEXED_CALLBACK)\n+\n+#undef FOR_EACH_CALLBACK\n+#undef CREATE_INDEXED_CALLBACK\n+\n+Handle<Object> PropertyCallbackArguments::CallNamedGetter(\n+    Handle<InterceptorInfo> interceptor, Handle<Name> name) {\n+  DCHECK(interceptor->is_named());\n+  DCHECK_IMPLIES(name->IsSymbol(), interceptor->can_intercept_symbols());\n+  DCHECK(!name->IsPrivate());\n+  Isolate* isolate = this->isolate();\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kNamedGetterCallback);\n+  LOG(isolate,\n+      ApiNamedPropertyAccess(\"interceptor-named-getter\", holder(), *name));\n+  GenericNamedPropertyGetterCallback f =\n+      ToCData<GenericNamedPropertyGetterCallback>(interceptor->getter());\n+  return BasicCallNamedGetterCallback(f, name);\n+}\n+\n+Handle<Object> PropertyCallbackArguments::CallNamedDescriptor(\n+    Handle<InterceptorInfo> interceptor, Handle<Name> name) {\n+  DCHECK(interceptor->is_named());\n+  DCHECK_IMPLIES(name->IsSymbol(), interceptor->can_intercept_symbols());\n+  Isolate* isolate = this->isolate();\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kNamedDescriptorCallback);\n+  LOG(isolate,\n+      ApiNamedPropertyAccess(\"interceptor-named-descriptor\", holder(), *name));\n+  GenericNamedPropertyDescriptorCallback f =\n+      ToCData<GenericNamedPropertyDescriptorCallback>(\n+          interceptor->descriptor());\n+  return BasicCallNamedGetterCallback(f, name);\n+}\n+\n+Handle<Object> PropertyCallbackArguments::BasicCallNamedGetterCallback(\n+    GenericNamedPropertyGetterCallback f, Handle<Name> name) {\n+  DCHECK(!name->IsPrivate());\n+  Isolate* isolate = this->isolate();\n+  PREPARE_CALLBACK_INFO(isolate, f, Handle<Object>, v8::Value);\n+  f(v8::Utils::ToLocal(name), callback_info);\n+  return GetReturnValue<Object>(isolate);\n+}\n \n-#undef FOR_EACH_CALLBACK_TABLE_MAPPING_1_INDEX\n-#undef WRITE_CALL_1_INDEX\n+Handle<Object> PropertyCallbackArguments::CallNamedSetter(\n+    Handle<InterceptorInfo> interceptor, Handle<Name> name,\n+    Handle<Object> value) {\n+  DCHECK_IMPLIES(name->IsSymbol(), interceptor->can_intercept_symbols());\n+  GenericNamedPropertySetterCallback f =\n+      ToCData<GenericNamedPropertySetterCallback>(interceptor->setter());\n+  return CallNamedSetterCallback(f, name, value);\n+}\n \n-Handle<Object> PropertyCallbackArguments::Call(\n+Handle<Object> PropertyCallbackArguments::CallNamedSetterCallback(\n     GenericNamedPropertySetterCallback f, Handle<Name> name,\n     Handle<Object> value) {\n+  DCHECK(!name->IsPrivate());\n   Isolate* isolate = this->isolate();\n-  SIDE_EFFECT_CHECK(isolate, f, Object);\n-  RuntimeCallTimerScope timer(\n-      isolate, &RuntimeCallStats::GenericNamedPropertySetterCallback);\n-  VMState<EXTERNAL> state(isolate);\n-  ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f));\n-  PropertyCallbackInfo<v8::Value> info(begin());\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kNamedSetterCallback);\n+  PREPARE_CALLBACK_INFO(isolate, f, Handle<Object>, v8::Value);\n   LOG(isolate,\n       ApiNamedPropertyAccess(\"interceptor-named-set\", holder(), *name));\n-  f(v8::Utils::ToLocal(name), v8::Utils::ToLocal(value), info);\n+  f(v8::Utils::ToLocal(name), v8::Utils::ToLocal(value), callback_info);\n   return GetReturnValue<Object>(isolate);\n }\n \n-Handle<Object> PropertyCallbackArguments::Call(\n-    GenericNamedPropertyDefinerCallback f, Handle<Name> name,\n+Handle<Object> PropertyCallbackArguments::CallNamedDefiner(\n+    Handle<InterceptorInfo> interceptor, Handle<Name> name,\n     const v8::PropertyDescriptor& desc) {\n+  DCHECK(interceptor->is_named());\n+  DCHECK(!name->IsPrivate());\n+  DCHECK_IMPLIES(name->IsSymbol(), interceptor->can_intercept_symbols());\n   Isolate* isolate = this->isolate();\n-  SIDE_EFFECT_CHECK(isolate, f, Object);\n-  RuntimeCallTimerScope timer(\n-      isolate, &RuntimeCallStats::GenericNamedPropertyDefinerCallback);\n-  VMState<EXTERNAL> state(isolate);\n-  ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f));\n-  PropertyCallbackInfo<v8::Value> info(begin());\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kNamedDefinerCallback);\n+  GenericNamedPropertyDefinerCallback f =\n+      ToCData<GenericNamedPropertyDefinerCallback>(interceptor->definer());\n+  PREPARE_CALLBACK_INFO(isolate, f, Handle<Object>, v8::Value);\n   LOG(isolate,\n       ApiNamedPropertyAccess(\"interceptor-named-define\", holder(), *name));\n-  f(v8::Utils::ToLocal(name), desc, info);\n+  f(v8::Utils::ToLocal(name), desc, callback_info);\n   return GetReturnValue<Object>(isolate);\n }\n \n-Handle<Object> PropertyCallbackArguments::Call(IndexedPropertySetterCallback f,\n-                                               uint32_t index,\n-                                               Handle<Object> value) {\n+Handle<Object> PropertyCallbackArguments::CallIndexedSetter(\n+    Handle<InterceptorInfo> interceptor, uint32_t index, Handle<Object> value) {\n+  DCHECK(!interceptor->is_named());\n   Isolate* isolate = this->isolate();\n-  SIDE_EFFECT_CHECK(isolate, f, Object);\n   RuntimeCallTimerScope timer(isolate,\n-                              &RuntimeCallStats::IndexedPropertySetterCallback);\n-  VMState<EXTERNAL> state(isolate);\n-  ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f));\n-  PropertyCallbackInfo<v8::Value> info(begin());\n+                              RuntimeCallCounterId::kIndexedSetterCallback);\n+  IndexedPropertySetterCallback f =\n+      ToCData<IndexedPropertySetterCallback>(interceptor->setter());\n+  PREPARE_CALLBACK_INFO(isolate, f, Handle<Object>, v8::Value);\n   LOG(isolate,\n       ApiIndexedPropertyAccess(\"interceptor-indexed-set\", holder(), index));\n-  f(index, v8::Utils::ToLocal(value), info);\n+  f(index, v8::Utils::ToLocal(value), callback_info);\n   return GetReturnValue<Object>(isolate);\n }\n \n-Handle<Object> PropertyCallbackArguments::Call(\n-    IndexedPropertyDefinerCallback f, uint32_t index,\n+Handle<Object> PropertyCallbackArguments::CallIndexedDefiner(\n+    Handle<InterceptorInfo> interceptor, uint32_t index,\n     const v8::PropertyDescriptor& desc) {\n+  DCHECK(!interceptor->is_named());\n   Isolate* isolate = this->isolate();\n-  SIDE_EFFECT_CHECK(isolate, f, Object);\n-  RuntimeCallTimerScope timer(\n-      isolate, &RuntimeCallStats::IndexedPropertyDefinerCallback);\n-  VMState<EXTERNAL> state(isolate);\n-  ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f));\n-  PropertyCallbackInfo<v8::Value> info(begin());\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kIndexedDefinerCallback);\n+  IndexedPropertyDefinerCallback f =\n+      ToCData<IndexedPropertyDefinerCallback>(interceptor->definer());\n+  PREPARE_CALLBACK_INFO(isolate, f, Handle<Object>, v8::Value);\n   LOG(isolate,\n       ApiIndexedPropertyAccess(\"interceptor-indexed-define\", holder(), index));\n-  f(index, desc, info);\n+  f(index, desc, callback_info);\n   return GetReturnValue<Object>(isolate);\n }\n \n-void PropertyCallbackArguments::Call(AccessorNameSetterCallback f,\n-                                     Handle<Name> name, Handle<Object> value) {\n+Handle<Object> PropertyCallbackArguments::CallIndexedGetter(\n+    Handle<InterceptorInfo> interceptor, uint32_t index) {\n+  DCHECK(!interceptor->is_named());\n   Isolate* isolate = this->isolate();\n-  if (isolate->needs_side_effect_check() &&\n-      !PerformSideEffectCheck(isolate, FUNCTION_ADDR(f))) {\n-    return;\n-  }\n   RuntimeCallTimerScope timer(isolate,\n-                              &RuntimeCallStats::AccessorNameSetterCallback);\n-  VMState<EXTERNAL> state(isolate);\n-  ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f));\n-  PropertyCallbackInfo<void> info(begin());\n+                              RuntimeCallCounterId::kNamedGetterCallback);\n   LOG(isolate,\n-      ApiNamedPropertyAccess(\"interceptor-named-set\", holder(), *name));\n-  f(v8::Utils::ToLocal(name), v8::Utils::ToLocal(value), info);\n+      ApiIndexedPropertyAccess(\"interceptor-indexed-getter\", holder(), index));\n+  IndexedPropertyGetterCallback f =\n+      ToCData<IndexedPropertyGetterCallback>(interceptor->getter());\n+  return BasicCallIndexedGetterCallback(f, index);\n+}\n+\n+Handle<Object> PropertyCallbackArguments::CallIndexedDescriptor(\n+    Handle<InterceptorInfo> interceptor, uint32_t index) {\n+  DCHECK(!interceptor->is_named());\n+  Isolate* isolate = this->isolate();\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kIndexedDescriptorCallback);\n+  LOG(isolate, ApiIndexedPropertyAccess(\"interceptor-indexed-descriptor\",\n+                                        holder(), index));\n+  IndexedPropertyDescriptorCallback f =\n+      ToCData<IndexedPropertyDescriptorCallback>(interceptor->descriptor());\n+  return BasicCallIndexedGetterCallback(f, index);\n+}\n+\n+Handle<Object> PropertyCallbackArguments::BasicCallIndexedGetterCallback(\n+    IndexedPropertyGetterCallback f, uint32_t index) {\n+  Isolate* isolate = this->isolate();\n+  PREPARE_CALLBACK_INFO(isolate, f, Handle<Object>, v8::Value);\n+  f(index, callback_info);\n+  return GetReturnValue<Object>(isolate);\n+}\n+\n+Handle<JSObject> PropertyCallbackArguments::CallPropertyEnumerator(\n+    Handle<InterceptorInfo> interceptor) {\n+  // For now there is a single enumerator for indexed and named properties.\n+  IndexedPropertyEnumeratorCallback f =\n+      v8::ToCData<IndexedPropertyEnumeratorCallback>(interceptor->enumerator());\n+  // TODO(cbruni): assert same type for indexed and named callback.\n+  Isolate* isolate = this->isolate();\n+  PREPARE_CALLBACK_INFO(isolate, f, Handle<JSObject>, v8::Array);\n+  f(callback_info);\n+  return GetReturnValue<JSObject>(isolate);\n+}\n+\n+// -------------------------------------------------------------------------\n+// Accessors\n+\n+Handle<Object> PropertyCallbackArguments::CallAccessorGetter(\n+    Handle<AccessorInfo> info, Handle<Name> name) {\n+  Isolate* isolate = this->isolate();\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kAccessorGetterCallback);\n+  LOG(isolate, ApiNamedPropertyAccess(\"accessor-getter\", holder(), *name));\n+  AccessorNameGetterCallback f =\n+      ToCData<AccessorNameGetterCallback>(info->getter());\n+  return BasicCallNamedGetterCallback(f, name);\n+}\n+\n+void PropertyCallbackArguments::CallAccessorSetter(\n+    Handle<AccessorInfo> accessor_info, Handle<Name> name,\n+    Handle<Object> value) {\n+  Isolate* isolate = this->isolate();\n+  RuntimeCallTimerScope timer(isolate,\n+                              RuntimeCallCounterId::kAccessorSetterCallback);\n+  AccessorNameSetterCallback f =\n+      ToCData<AccessorNameSetterCallback>(accessor_info->setter());\n+  PREPARE_CALLBACK_INFO(isolate, f, void, void);\n+  LOG(isolate, ApiNamedPropertyAccess(\"accessor-setter\", holder(), *name));\n+  f(v8::Utils::ToLocal(name), v8::Utils::ToLocal(value), callback_info);\n }\n \n-#undef SIDE_EFFECT_CHECK\n+#undef PREPARE_CALLBACK_INFO\n \n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "1302e32b665e2f8fd722eb463a7470daa04e6d04",
            "filename": "deps/v8/src/api-arguments.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 14,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi-arguments.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi-arguments.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi-arguments.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -3,6 +3,7 @@\n // found in the LICENSE file.\n \n #include \"src/api-arguments.h\"\n+#include \"src/api-arguments-inl.h\"\n \n #include \"src/debug/debug.h\"\n #include \"src/objects-inl.h\"\n@@ -18,27 +19,30 @@ Handle<Object> FunctionCallbackArguments::Call(FunctionCallback f) {\n       !isolate->debug()->PerformSideEffectCheckForCallback(FUNCTION_ADDR(f))) {\n     return Handle<Object>();\n   }\n-  RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::FunctionCallback);\n+  RuntimeCallTimerScope timer(isolate, RuntimeCallCounterId::kFunctionCallback);\n   VMState<EXTERNAL> state(isolate);\n   ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f));\n   FunctionCallbackInfo<v8::Value> info(begin(), argv_, argc_);\n   f(info);\n   return GetReturnValue<Object>(isolate);\n }\n \n-Handle<JSObject> PropertyCallbackArguments::Call(\n-    IndexedPropertyEnumeratorCallback f) {\n-  Isolate* isolate = this->isolate();\n-  if (isolate->needs_side_effect_check() &&\n-      !isolate->debug()->PerformSideEffectCheckForCallback(FUNCTION_ADDR(f))) {\n-    return Handle<JSObject>();\n-  }\n-  RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::PropertyCallback);\n-  VMState<EXTERNAL> state(isolate);\n-  ExternalCallbackScope call_scope(isolate, FUNCTION_ADDR(f));\n-  PropertyCallbackInfo<v8::Array> info(begin());\n-  f(info);\n-  return GetReturnValue<JSObject>(isolate);\n+Handle<JSObject> PropertyCallbackArguments::CallNamedEnumerator(\n+    Handle<InterceptorInfo> interceptor) {\n+  DCHECK(interceptor->is_named());\n+  LOG(isolate(), ApiObjectAccess(\"interceptor-named-enumerator\", holder()));\n+  RuntimeCallTimerScope timer(isolate(),\n+                              RuntimeCallCounterId::kNamedEnumeratorCallback);\n+  return CallPropertyEnumerator(interceptor);\n+}\n+\n+Handle<JSObject> PropertyCallbackArguments::CallIndexedEnumerator(\n+    Handle<InterceptorInfo> interceptor) {\n+  DCHECK(!interceptor->is_named());\n+  LOG(isolate(), ApiObjectAccess(\"interceptor-indexed-enumerator\", holder()));\n+  RuntimeCallTimerScope timer(isolate(),\n+                              RuntimeCallCounterId::kIndexedEnumeratorCallback);\n+  return CallPropertyEnumerator(interceptor);\n }\n \n bool PropertyCallbackArguments::PerformSideEffectCheck(Isolate* isolate,"
        },
        {
            "sha": "42d58b88a81031a7089d333b442907af1e232f6d",
            "filename": "deps/v8/src/api-arguments.h",
            "status": "modified",
            "additions": 54,
            "deletions": 27,
            "changes": 81,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi-arguments.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi-arguments.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi-arguments.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -99,6 +99,54 @@ class PropertyCallbackArguments\n     DCHECK(values[T::kIsolateIndex]->IsSmi());\n   }\n \n+  // -------------------------------------------------------------------------\n+  // Accessor Callbacks\n+  // Also used for AccessorSetterCallback.\n+  inline void CallAccessorSetter(Handle<AccessorInfo> info, Handle<Name> name,\n+                                 Handle<Object> value);\n+  // Also used for AccessorGetterCallback, AccessorNameGetterCallback.\n+  inline Handle<Object> CallAccessorGetter(Handle<AccessorInfo> info,\n+                                           Handle<Name> name);\n+\n+  // -------------------------------------------------------------------------\n+  // Named Interceptor Callbacks\n+  inline Handle<Object> CallNamedQuery(Handle<InterceptorInfo> interceptor,\n+                                       Handle<Name> name);\n+  inline Handle<Object> CallNamedGetter(Handle<InterceptorInfo> interceptor,\n+                                        Handle<Name> name);\n+  inline Handle<Object> CallNamedSetter(Handle<InterceptorInfo> interceptor,\n+                                        Handle<Name> name,\n+                                        Handle<Object> value);\n+  inline Handle<Object> CallNamedSetterCallback(\n+      GenericNamedPropertySetterCallback callback, Handle<Name> name,\n+      Handle<Object> value);\n+  inline Handle<Object> CallNamedDefiner(Handle<InterceptorInfo> interceptor,\n+                                         Handle<Name> name,\n+                                         const v8::PropertyDescriptor& desc);\n+  inline Handle<Object> CallNamedDeleter(Handle<InterceptorInfo> interceptor,\n+                                         Handle<Name> name);\n+  inline Handle<Object> CallNamedDescriptor(Handle<InterceptorInfo> interceptor,\n+                                            Handle<Name> name);\n+  Handle<JSObject> CallNamedEnumerator(Handle<InterceptorInfo> interceptor);\n+\n+  // -------------------------------------------------------------------------\n+  // Indexed Interceptor Callbacks\n+  inline Handle<Object> CallIndexedQuery(Handle<InterceptorInfo> interceptor,\n+                                         uint32_t index);\n+  inline Handle<Object> CallIndexedGetter(Handle<InterceptorInfo> interceptor,\n+                                          uint32_t index);\n+  inline Handle<Object> CallIndexedSetter(Handle<InterceptorInfo> interceptor,\n+                                          uint32_t index, Handle<Object> value);\n+  inline Handle<Object> CallIndexedDefiner(Handle<InterceptorInfo> interceptor,\n+                                           uint32_t index,\n+                                           const v8::PropertyDescriptor& desc);\n+  inline Handle<Object> CallIndexedDeleter(Handle<InterceptorInfo> interceptor,\n+                                           uint32_t index);\n+  inline Handle<Object> CallIndexedDescriptor(\n+      Handle<InterceptorInfo> interceptor, uint32_t index);\n+  Handle<JSObject> CallIndexedEnumerator(Handle<InterceptorInfo> interceptor);\n+\n+ private:\n   /*\n    * The following Call functions wrap the calling of all callbacks to handle\n    * calling either the old or the new style callbacks depending on which one\n@@ -107,35 +155,14 @@ class PropertyCallbackArguments\n    * and used if it's been set to anything inside the callback.\n    * New style callbacks always use the return value.\n    */\n-  Handle<JSObject> Call(IndexedPropertyEnumeratorCallback f);\n-\n-  inline Handle<Object> Call(AccessorNameGetterCallback f, Handle<Name> name);\n-  inline Handle<Object> Call(GenericNamedPropertyQueryCallback f,\n-                             Handle<Name> name);\n-  inline Handle<Object> Call(GenericNamedPropertyDeleterCallback f,\n-                             Handle<Name> name);\n-\n-  inline Handle<Object> Call(IndexedPropertyGetterCallback f, uint32_t index);\n-  inline Handle<Object> Call(IndexedPropertyQueryCallback f, uint32_t index);\n-  inline Handle<Object> Call(IndexedPropertyDeleterCallback f, uint32_t index);\n-\n-  inline Handle<Object> Call(GenericNamedPropertySetterCallback f,\n-                             Handle<Name> name, Handle<Object> value);\n+  inline Handle<JSObject> CallPropertyEnumerator(\n+      Handle<InterceptorInfo> interceptor);\n \n-  inline Handle<Object> Call(GenericNamedPropertyDefinerCallback f,\n-                             Handle<Name> name,\n-                             const v8::PropertyDescriptor& desc);\n+  inline Handle<Object> BasicCallIndexedGetterCallback(\n+      IndexedPropertyGetterCallback f, uint32_t index);\n+  inline Handle<Object> BasicCallNamedGetterCallback(\n+      GenericNamedPropertyGetterCallback f, Handle<Name> name);\n \n-  inline Handle<Object> Call(IndexedPropertySetterCallback f, uint32_t index,\n-                             Handle<Object> value);\n-\n-  inline Handle<Object> Call(IndexedPropertyDefinerCallback f, uint32_t index,\n-                             const v8::PropertyDescriptor& desc);\n-\n-  inline void Call(AccessorNameSetterCallback f, Handle<Name> name,\n-                   Handle<Object> value);\n-\n- private:\n   inline JSObject* holder() {\n     return JSObject::cast(this->begin()[T::kHolderIndex]);\n   }"
        },
        {
            "sha": "b8f03a89a80cebabacea8a92e9dfda5d12a3e249",
            "filename": "deps/v8/src/api-natives.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi-natives.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi-natives.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi-natives.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -705,7 +705,7 @@ Handle<JSFunction> ApiNatives::CreateApiFunction(\n     // that is undetectable but not callable, we need to update the types.h\n     // to allow encoding this.\n     CHECK(!obj->instance_call_handler()->IsUndefined(isolate));\n-    map->set_is_undetectable();\n+    map->set_is_undetectable(true);\n   }\n \n   // Mark as needs_access_check if needed.\n@@ -716,20 +716,20 @@ Handle<JSFunction> ApiNatives::CreateApiFunction(\n \n   // Set interceptor information in the map.\n   if (!obj->named_property_handler()->IsUndefined(isolate)) {\n-    map->set_has_named_interceptor();\n+    map->set_has_named_interceptor(true);\n     map->set_may_have_interesting_symbols(true);\n   }\n   if (!obj->indexed_property_handler()->IsUndefined(isolate)) {\n-    map->set_has_indexed_interceptor();\n+    map->set_has_indexed_interceptor(true);\n   }\n \n   // Mark instance as callable in the map.\n   if (!obj->instance_call_handler()->IsUndefined(isolate)) {\n-    map->set_is_callable();\n+    map->set_is_callable(true);\n     map->set_is_constructor(true);\n   }\n \n-  if (immutable_proto) map->set_immutable_proto(true);\n+  if (immutable_proto) map->set_is_immutable_proto(true);\n \n   return result;\n }"
        },
        {
            "sha": "147cc397f226d3c503184769c65555ea7b7ed57c",
            "filename": "deps/v8/src/api.cc",
            "status": "modified",
            "additions": 386,
            "deletions": 593,
            "changes": 979,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -8,9 +8,6 @@\n #ifdef V8_USE_ADDRESS_SANITIZER\n #include <sanitizer/asan_interface.h>\n #endif  // V8_USE_ADDRESS_SANITIZER\n-#if defined(LEAK_SANITIZER)\n-#include <sanitizer/lsan_interface.h>\n-#endif            // defined(LEAK_SANITIZER)\n #include <cmath>  // For isnan.\n #include <limits>\n #include <vector>\n@@ -84,6 +81,7 @@\n #include \"src/vm-state-inl.h\"\n #include \"src/wasm/compilation-manager.h\"\n #include \"src/wasm/streaming-decoder.h\"\n+#include \"src/wasm/wasm-engine.h\"\n #include \"src/wasm/wasm-objects-inl.h\"\n #include \"src/wasm/wasm-result.h\"\n #include \"src/wasm/wasm-serialization.h\"\n@@ -110,9 +108,9 @@ namespace v8 {\n  * TODO(jochen): Remove calls form API methods to DO_NOT_USE macros.\n  */\n \n-#define LOG_API(isolate, class_name, function_name)                       \\\n-  i::RuntimeCallTimerScope _runtime_timer(                                \\\n-      isolate, &i::RuntimeCallStats::API_##class_name##_##function_name); \\\n+#define LOG_API(isolate, class_name, function_name)                           \\\n+  i::RuntimeCallTimerScope _runtime_timer(                                    \\\n+      isolate, i::RuntimeCallCounterId::kAPI_##class_name##_##function_name); \\\n   LOG(isolate, ApiEntryCall(\"v8::\" #class_name \"::\" #function_name))\n \n #define ENTER_V8_DO_NOT_USE(isolate) i::VMState<v8::OTHER> __state__((isolate))\n@@ -326,9 +324,9 @@ void i::V8::FatalProcessOutOfMemory(const char* location, bool is_heap_oom) {\n   if (isolate == nullptr) {\n     // On a background thread -> we cannot retrieve memory information from the\n     // Isolate. Write easy-to-recognize values on the stack.\n-    memset(last_few_messages, 0x0badc0de, Heap::kTraceRingBufferSize + 1);\n-    memset(js_stacktrace, 0x0badc0de, Heap::kStacktraceBufferSize + 1);\n-    memset(&heap_stats, 0xbadc0de, sizeof(heap_stats));\n+    memset(last_few_messages, 0x0BADC0DE, Heap::kTraceRingBufferSize + 1);\n+    memset(js_stacktrace, 0x0BADC0DE, Heap::kStacktraceBufferSize + 1);\n+    memset(&heap_stats, 0xBADC0DE, sizeof(heap_stats));\n     // Note that the embedder's oom handler won't be called in this case. We\n     // just crash.\n     FATAL(\"API fatal error handler returned after process out of memory\");\n@@ -404,7 +402,10 @@ void i::V8::FatalProcessOutOfMemory(const char* location, bool is_heap_oom) {\n \n void Utils::ReportApiFailure(const char* location, const char* message) {\n   i::Isolate* isolate = i::Isolate::Current();\n-  FatalErrorCallback callback = isolate->exception_behavior();\n+  FatalErrorCallback callback = nullptr;\n+  if (isolate != nullptr) {\n+    callback = isolate->exception_behavior();\n+  }\n   if (callback == nullptr) {\n     base::OS::PrintError(\"\\n#\\n# Fatal error in %s\\n# %s\\n#\\n\\n\", location,\n                          message);\n@@ -483,23 +484,34 @@ namespace {\n class ArrayBufferAllocator : public v8::ArrayBuffer::Allocator {\n  public:\n   virtual void* Allocate(size_t length) {\n-    void* data = AllocateUninitialized(length);\n-    return data == nullptr ? data : memset(data, 0, length);\n+#if V8_OS_AIX && _LINUX_SOURCE_COMPAT\n+    // Work around for GCC bug on AIX\n+    // See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79839\n+    void* data = __linux_calloc(length, 1);\n+#else\n+    void* data = calloc(length, 1);\n+#endif\n+    return data;\n   }\n-  virtual void* AllocateUninitialized(size_t length) { return malloc(length); }\n+\n+  virtual void* AllocateUninitialized(size_t length) {\n+#if V8_OS_AIX && _LINUX_SOURCE_COMPAT\n+    // Work around for GCC bug on AIX\n+    // See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79839\n+    void* data = __linux_malloc(length);\n+#else\n+    void* data = malloc(length);\n+#endif\n+    return data;\n+  }\n+\n   virtual void Free(void* data, size_t) { free(data); }\n \n   virtual void* Reserve(size_t length) {\n-    size_t page_size = base::OS::AllocatePageSize();\n+    size_t page_size = i::AllocatePageSize();\n     size_t allocated = RoundUp(length, page_size);\n-    void* address =\n-        base::OS::Allocate(base::OS::GetRandomMmapAddr(), allocated, page_size,\n-                           base::OS::MemoryPermission::kNoAccess);\n-#if defined(LEAK_SANITIZER)\n-    if (address != nullptr) {\n-      __lsan_register_root_region(address, allocated);\n-    }\n-#endif\n+    void* address = i::AllocatePages(i::GetRandomMmapAddr(), allocated,\n+                                     page_size, PageAllocator::kNoAccess);\n     return address;\n   }\n \n@@ -510,7 +522,9 @@ class ArrayBufferAllocator : public v8::ArrayBuffer::Allocator {\n         return Free(data, length);\n       }\n       case v8::ArrayBuffer::Allocator::AllocationMode::kReservation: {\n-        CHECK(base::OS::Free(data, length));\n+        size_t page_size = i::AllocatePageSize();\n+        size_t allocated = RoundUp(length, page_size);\n+        CHECK(i::FreePages(data, allocated));\n         return;\n       }\n     }\n@@ -521,11 +535,11 @@ class ArrayBufferAllocator : public v8::ArrayBuffer::Allocator {\n       v8::ArrayBuffer::Allocator::Protection protection) {\n     DCHECK(protection == v8::ArrayBuffer::Allocator::Protection::kNoAccess ||\n            protection == v8::ArrayBuffer::Allocator::Protection::kReadWrite);\n-    base::OS::MemoryPermission permission =\n+    PageAllocator::Permission permission =\n         (protection == v8::ArrayBuffer::Allocator::Protection::kReadWrite)\n-            ? base::OS::MemoryPermission::kReadWrite\n-            : base::OS::MemoryPermission::kNoAccess;\n-    CHECK(base::OS::SetPermissions(data, length, permission));\n+            ? PageAllocator::kReadWrite\n+            : PageAllocator::kNoAccess;\n+    CHECK(i::SetPermissions(data, length, permission));\n   }\n };\n \n@@ -562,7 +576,6 @@ struct SnapshotCreatorData {\n       : isolate_(isolate),\n         default_context_(),\n         contexts_(isolate),\n-        templates_(isolate),\n         created_(false) {}\n \n   static SnapshotCreatorData* cast(void* data) {\n@@ -574,7 +587,6 @@ struct SnapshotCreatorData {\n   Persistent<Context> default_context_;\n   SerializeInternalFieldsCallback default_embedder_fields_serializer_;\n   PersistentValueVector<Context> contexts_;\n-  PersistentValueVector<Template> templates_;\n   std::vector<SerializeInternalFieldsCallback> embedder_fields_serializers_;\n   bool created_;\n };\n@@ -634,23 +646,81 @@ size_t SnapshotCreator::AddContext(Local<Context> context,\n   DCHECK(!data->created_);\n   Isolate* isolate = data->isolate_;\n   CHECK_EQ(isolate, context->GetIsolate());\n-  size_t index = static_cast<int>(data->contexts_.Size());\n+  size_t index = data->contexts_.Size();\n   data->contexts_.Append(context);\n   data->embedder_fields_serializers_.push_back(callback);\n   return index;\n }\n \n size_t SnapshotCreator::AddTemplate(Local<Template> template_obj) {\n-  DCHECK(!template_obj.IsEmpty());\n+  return AddData(template_obj);\n+}\n+\n+size_t SnapshotCreator::AddData(i::Object* object) {\n+  DCHECK_NOT_NULL(object);\n   SnapshotCreatorData* data = SnapshotCreatorData::cast(data_);\n   DCHECK(!data->created_);\n-  DCHECK_EQ(reinterpret_cast<i::Isolate*>(data->isolate_),\n-            Utils::OpenHandle(*template_obj)->GetIsolate());\n-  size_t index = static_cast<int>(data->templates_.Size());\n-  data->templates_.Append(template_obj);\n+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(data->isolate_);\n+  i::HandleScope scope(isolate);\n+  i::Handle<i::Object> obj(object, isolate);\n+  i::Handle<i::ArrayList> list;\n+  if (!isolate->heap()->serialized_objects()->IsArrayList()) {\n+    list = i::ArrayList::New(isolate, 1);\n+  } else {\n+    list = i::Handle<i::ArrayList>(\n+        i::ArrayList::cast(isolate->heap()->serialized_objects()));\n+  }\n+  size_t index = static_cast<size_t>(list->Length());\n+  list = i::ArrayList::Add(list, obj);\n+  isolate->heap()->SetSerializedObjects(*list);\n   return index;\n }\n \n+size_t SnapshotCreator::AddData(Local<Context> context, i::Object* object) {\n+  DCHECK_NOT_NULL(object);\n+  DCHECK(!SnapshotCreatorData::cast(data_)->created_);\n+  i::Handle<i::Context> ctx = Utils::OpenHandle(*context);\n+  i::Isolate* isolate = ctx->GetIsolate();\n+  i::HandleScope scope(isolate);\n+  i::Handle<i::Object> obj(object, isolate);\n+  i::Handle<i::ArrayList> list;\n+  if (!ctx->serialized_objects()->IsArrayList()) {\n+    list = i::ArrayList::New(isolate, 1);\n+  } else {\n+    list =\n+        i::Handle<i::ArrayList>(i::ArrayList::cast(ctx->serialized_objects()));\n+  }\n+  size_t index = static_cast<size_t>(list->Length());\n+  list = i::ArrayList::Add(list, obj);\n+  ctx->set_serialized_objects(*list);\n+  return index;\n+}\n+\n+namespace {\n+void ConvertSerializedObjectsToFixedArray(Local<Context> context) {\n+  i::Handle<i::Context> ctx = Utils::OpenHandle(*context);\n+  i::Isolate* isolate = ctx->GetIsolate();\n+  if (!ctx->serialized_objects()->IsArrayList()) {\n+    ctx->set_serialized_objects(isolate->heap()->empty_fixed_array());\n+  } else {\n+    i::Handle<i::ArrayList> list(i::ArrayList::cast(ctx->serialized_objects()));\n+    i::Handle<i::FixedArray> elements = i::ArrayList::Elements(list);\n+    ctx->set_serialized_objects(*elements);\n+  }\n+}\n+\n+void ConvertSerializedObjectsToFixedArray(i::Isolate* isolate) {\n+  if (!isolate->heap()->serialized_objects()->IsArrayList()) {\n+    isolate->heap()->SetSerializedObjects(isolate->heap()->empty_fixed_array());\n+  } else {\n+    i::Handle<i::ArrayList> list(\n+        i::ArrayList::cast(isolate->heap()->serialized_objects()));\n+    i::Handle<i::FixedArray> elements = i::ArrayList::Elements(list);\n+    isolate->heap()->SetSerializedObjects(*elements);\n+  }\n+}\n+}  // anonymous namespace\n+\n StartupData SnapshotCreator::CreateBlob(\n     SnapshotCreator::FunctionCodeHandling function_code_handling) {\n   SnapshotCreatorData* data = SnapshotCreatorData::cast(data_);\n@@ -661,15 +731,16 @@ StartupData SnapshotCreator::CreateBlob(\n   int num_additional_contexts = static_cast<int>(data->contexts_.Size());\n \n   {\n-    int num_templates = static_cast<int>(data->templates_.Size());\n     i::HandleScope scope(isolate);\n-    i::Handle<i::FixedArray> templates =\n-        isolate->factory()->NewFixedArray(num_templates, i::TENURED);\n-    for (int i = 0; i < num_templates; i++) {\n-      templates->set(i, *v8::Utils::OpenHandle(*data->templates_.Get(i)));\n+    // Convert list of context-independent data to FixedArray.\n+    ConvertSerializedObjectsToFixedArray(isolate);\n+\n+    // Convert lists of context-dependent data to FixedArray.\n+    ConvertSerializedObjectsToFixedArray(\n+        data->default_context_.Get(data->isolate_));\n+    for (int i = 0; i < num_additional_contexts; i++) {\n+      ConvertSerializedObjectsToFixedArray(data->contexts_.Get(i));\n     }\n-    isolate->heap()->SetSerializedTemplates(*templates);\n-    data->templates_.Clear();\n \n     // We need to store the global proxy size upfront in case we need the\n     // bootstrapper to create a global proxy before we deserialize the context.\n@@ -695,13 +766,13 @@ StartupData SnapshotCreator::CreateBlob(\n \n   i::DisallowHeapAllocation no_gc_from_here_on;\n \n-  std::vector<i::Object*> contexts;\n-  contexts.reserve(num_additional_contexts);\n-  i::Object* default_context;\n+  int num_contexts = num_additional_contexts + 1;\n+  std::vector<i::Context*> contexts;\n+  contexts.reserve(num_contexts);\n   {\n     i::HandleScope scope(isolate);\n-    default_context =\n-        *v8::Utils::OpenHandle(*data->default_context_.Get(data->isolate_));\n+    contexts.push_back(\n+        *v8::Utils::OpenHandle(*data->default_context_.Get(data->isolate_)));\n     data->default_context_.Reset();\n     for (int i = 0; i < num_additional_contexts; i++) {\n       i::Handle<i::Context> context =\n@@ -711,6 +782,10 @@ StartupData SnapshotCreator::CreateBlob(\n     data->contexts_.Clear();\n   }\n \n+  // Check that values referenced by global/eternal handles are accounted for.\n+  i::SerializedHandleChecker handle_checker(isolate, &contexts);\n+  CHECK(handle_checker.CheckGlobalAndEternalHandles());\n+\n   // Complete in-object slack tracking for all functions.\n   i::HeapIterator heap_iterator(isolate->heap());\n   while (i::HeapObject* current_obj = heap_iterator.next()) {\n@@ -724,26 +799,18 @@ StartupData SnapshotCreator::CreateBlob(\n \n   // Serialize each context with a new partial serializer.\n   std::vector<i::SnapshotData*> context_snapshots;\n-  context_snapshots.reserve(num_additional_contexts + 1);\n+  context_snapshots.reserve(num_contexts);\n \n   // TODO(6593): generalize rehashing, and remove this flag.\n   bool can_be_rehashed = true;\n \n-  {\n-    // The default context is created with a handler for embedder fields which\n-    // determines how they are handled if encountered during serialization.\n+  for (int i = 0; i < num_contexts; i++) {\n+    bool is_default_context = i == 0;\n     i::PartialSerializer partial_serializer(\n         isolate, &startup_serializer,\n-        data->default_embedder_fields_serializer_);\n-    partial_serializer.Serialize(&default_context, false);\n-    can_be_rehashed = can_be_rehashed && partial_serializer.can_be_rehashed();\n-    context_snapshots.push_back(new i::SnapshotData(&partial_serializer));\n-  }\n-\n-  for (int i = 0; i < num_additional_contexts; i++) {\n-    i::PartialSerializer partial_serializer(\n-        isolate, &startup_serializer, data->embedder_fields_serializers_[i]);\n-    partial_serializer.Serialize(&contexts[i], true);\n+        is_default_context ? data->default_embedder_fields_serializer_\n+                           : data->embedder_fields_serializers_[i - 1]);\n+    partial_serializer.Serialize(&contexts[i], !is_default_context);\n     can_be_rehashed = can_be_rehashed && partial_serializer.can_be_rehashed();\n     context_snapshots.push_back(new i::SnapshotData(&partial_serializer));\n   }\n@@ -767,6 +834,7 @@ StartupData SnapshotCreator::CreateBlob(\n     delete context_snapshot;\n   }\n   data->created_ = true;\n+\n   return result;\n }\n \n@@ -911,7 +979,8 @@ void ResourceConstraints::ConfigureDefaults(uint64_t physical_memory,\n                                             uint64_t virtual_memory_limit) {\n   set_max_semi_space_size_in_kb(\n       i::Heap::ComputeMaxSemiSpaceSize(physical_memory));\n-  set_max_old_space_size(i::Heap::ComputeMaxOldGenerationSize(physical_memory));\n+  set_max_old_space_size(\n+      static_cast<int>(i::Heap::ComputeMaxOldGenerationSize(physical_memory)));\n   set_max_zone_pool_size(i::AccountingAllocator::kMaxPoolSize);\n \n   if (virtual_memory_limit > 0 && i::kRequiresCodeRange) {\n@@ -926,9 +995,7 @@ void ResourceConstraints::ConfigureDefaults(uint64_t physical_memory,\n void SetResourceConstraints(i::Isolate* isolate,\n                             const ResourceConstraints& constraints) {\n   size_t semi_space_size = constraints.max_semi_space_size_in_kb();\n-  size_t old_space_size =\n-      static_cast<size_t>(\n-          static_cast<unsigned int>(constraints.max_old_space_size()));\n+  int old_space_size = constraints.max_old_space_size();\n   size_t code_range_size = constraints.code_range_size();\n   size_t max_pool_size = constraints.max_zone_pool_size();\n   if (semi_space_size != 0 || old_space_size != 0 || code_range_size != 0) {\n@@ -1409,10 +1476,10 @@ Local<FunctionTemplate> FunctionTemplate::New(\n MaybeLocal<FunctionTemplate> FunctionTemplate::FromSnapshot(Isolate* isolate,\n                                                             size_t index) {\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n-  i::FixedArray* templates = i_isolate->heap()->serialized_templates();\n+  i::FixedArray* serialized_objects = i_isolate->heap()->serialized_objects();\n   int int_index = static_cast<int>(index);\n-  if (int_index < templates->length()) {\n-    i::Object* info = templates->get(int_index);\n+  if (int_index < serialized_objects->length()) {\n+    i::Object* info = serialized_objects->get(int_index);\n     if (info->IsFunctionTemplateInfo()) {\n       return Utils::ToLocal(i::Handle<i::FunctionTemplateInfo>(\n           i::FunctionTemplateInfo::cast(info)));\n@@ -1593,10 +1660,6 @@ Local<ObjectTemplate> ObjectTemplate::New(\n }\n \n \n-Local<ObjectTemplate> ObjectTemplate::New() {\n-  return New(i::Isolate::Current(), Local<FunctionTemplate>());\n-}\n-\n static Local<ObjectTemplate> ObjectTemplateNew(\n     i::Isolate* isolate, v8::Local<FunctionTemplate> constructor,\n     bool do_not_cache) {\n@@ -1626,10 +1689,10 @@ Local<ObjectTemplate> ObjectTemplate::New(\n MaybeLocal<ObjectTemplate> ObjectTemplate::FromSnapshot(Isolate* isolate,\n                                                         size_t index) {\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n-  i::FixedArray* templates = i_isolate->heap()->serialized_templates();\n+  i::FixedArray* serialized_objects = i_isolate->heap()->serialized_objects();\n   int int_index = static_cast<int>(index);\n-  if (int_index < templates->length()) {\n-    i::Object* info = templates->get(int_index);\n+  if (int_index < serialized_objects->length()) {\n+    i::Object* info = serialized_objects->get(int_index);\n     if (info->IsObjectTemplateInfo()) {\n       return Utils::ToLocal(\n           i::Handle<i::ObjectTemplateInfo>(i::ObjectTemplateInfo::cast(info)));\n@@ -1748,11 +1811,10 @@ static i::Handle<i::InterceptorInfo> CreateInterceptorInfo(\n     i::Isolate* isolate, Getter getter, Setter setter, Query query,\n     Descriptor descriptor, Deleter remover, Enumerator enumerator,\n     Definer definer, Local<Value> data, PropertyHandlerFlags flags) {\n-  DCHECK(query == nullptr ||\n-         descriptor == nullptr);  // Either intercept attributes or descriptor.\n-  DCHECK(query == nullptr ||\n-         definer ==\n-             nullptr);  // Only use descriptor callback with definer callback.\n+  // Either intercept attributes or descriptor.\n+  DCHECK(query == nullptr || descriptor == nullptr);\n+  // Only use descriptor callback with definer callback.\n+  DCHECK(query == nullptr || definer == nullptr);\n   auto obj = i::Handle<i::InterceptorInfo>::cast(\n       isolate->factory()->NewStruct(i::INTERCEPTOR_INFO_TYPE, i::TENURED));\n   obj->set_flags(0);\n@@ -1779,6 +1841,32 @@ static i::Handle<i::InterceptorInfo> CreateInterceptorInfo(\n   return obj;\n }\n \n+template <typename Getter, typename Setter, typename Query, typename Descriptor,\n+          typename Deleter, typename Enumerator, typename Definer>\n+static i::Handle<i::InterceptorInfo> CreateNamedInterceptorInfo(\n+    i::Isolate* isolate, Getter getter, Setter setter, Query query,\n+    Descriptor descriptor, Deleter remover, Enumerator enumerator,\n+    Definer definer, Local<Value> data, PropertyHandlerFlags flags) {\n+  auto interceptor =\n+      CreateInterceptorInfo(isolate, getter, setter, query, descriptor, remover,\n+                            enumerator, definer, data, flags);\n+  interceptor->set_is_named(true);\n+  return interceptor;\n+}\n+\n+template <typename Getter, typename Setter, typename Query, typename Descriptor,\n+          typename Deleter, typename Enumerator, typename Definer>\n+static i::Handle<i::InterceptorInfo> CreateIndexedInterceptorInfo(\n+    i::Isolate* isolate, Getter getter, Setter setter, Query query,\n+    Descriptor descriptor, Deleter remover, Enumerator enumerator,\n+    Definer definer, Local<Value> data, PropertyHandlerFlags flags) {\n+  auto interceptor =\n+      CreateInterceptorInfo(isolate, getter, setter, query, descriptor, remover,\n+                            enumerator, definer, data, flags);\n+  interceptor->set_is_named(false);\n+  return interceptor;\n+}\n+\n template <typename Getter, typename Setter, typename Query, typename Descriptor,\n           typename Deleter, typename Enumerator, typename Definer>\n static void ObjectTemplateSetNamedPropertyHandler(\n@@ -1790,11 +1878,13 @@ static void ObjectTemplateSetNamedPropertyHandler(\n   i::HandleScope scope(isolate);\n   auto cons = EnsureConstructor(isolate, templ);\n   EnsureNotInstantiated(cons, \"ObjectTemplateSetNamedPropertyHandler\");\n-  auto obj = CreateInterceptorInfo(isolate, getter, setter, query, descriptor,\n-                                   remover, enumerator, definer, data, flags);\n+  auto obj =\n+      CreateNamedInterceptorInfo(isolate, getter, setter, query, descriptor,\n+                                 remover, enumerator, definer, data, flags);\n   cons->set_named_property_handler(*obj);\n }\n \n+// TODO(cbruni) deprecate.\n void ObjectTemplate::SetNamedPropertyHandler(\n     NamedPropertyGetterCallback getter, NamedPropertySetterCallback setter,\n     NamedPropertyQueryCallback query, NamedPropertyDeleterCallback remover,\n@@ -1867,12 +1957,12 @@ void ObjectTemplate::SetAccessCheckCallbackAndHandler(\n       i::Handle<i::AccessCheckInfo>::cast(struct_info);\n \n   SET_FIELD_WRAPPED(info, set_callback, callback);\n-  auto named_interceptor = CreateInterceptorInfo(\n+  auto named_interceptor = CreateNamedInterceptorInfo(\n       isolate, named_handler.getter, named_handler.setter, named_handler.query,\n       named_handler.descriptor, named_handler.deleter, named_handler.enumerator,\n       named_handler.definer, named_handler.data, named_handler.flags);\n   info->set_named_interceptor(*named_interceptor);\n-  auto indexed_interceptor = CreateInterceptorInfo(\n+  auto indexed_interceptor = CreateIndexedInterceptorInfo(\n       isolate, indexed_handler.getter, indexed_handler.setter,\n       indexed_handler.query, indexed_handler.descriptor,\n       indexed_handler.deleter, indexed_handler.enumerator,\n@@ -1895,10 +1985,10 @@ void ObjectTemplate::SetHandler(\n   i::HandleScope scope(isolate);\n   auto cons = EnsureConstructor(isolate, this);\n   EnsureNotInstantiated(cons, \"v8::ObjectTemplate::SetHandler\");\n-  auto obj = CreateInterceptorInfo(isolate, config.getter, config.setter,\n-                                   config.query, config.descriptor,\n-                                   config.deleter, config.enumerator,\n-                                   config.definer, config.data, config.flags);\n+  auto obj = CreateIndexedInterceptorInfo(\n+      isolate, config.getter, config.setter, config.query, config.descriptor,\n+      config.deleter, config.enumerator, config.definer, config.data,\n+      config.flags);\n   cons->set_indexed_property_handler(*obj);\n }\n \n@@ -2239,11 +2329,6 @@ Local<Value> Module::GetModuleNamespace() {\n \n int Module::GetIdentityHash() const { return Utils::OpenHandle(this)->hash(); }\n \n-bool Module::Instantiate(Local<Context> context,\n-                         Module::ResolveCallback callback) {\n-  return InstantiateModule(context, callback).FromMaybe(false);\n-}\n-\n Maybe<bool> Module::InstantiateModule(Local<Context> context,\n                                       Module::ResolveCallback callback) {\n   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n@@ -2361,18 +2446,6 @@ MaybeLocal<UnboundScript> ScriptCompiler::CompileUnboundScript(\n   return CompileUnboundInternal(v8_isolate, source, options, no_cache_reason);\n }\n \n-Local<UnboundScript> ScriptCompiler::CompileUnbound(\n-    Isolate* v8_isolate, Source* source, CompileOptions options,\n-    NoCacheReason no_cache_reason) {\n-  Utils::ApiCheck(\n-      !source->GetResourceOptions().IsModule(),\n-      \"v8::ScriptCompiler::CompileUnbound\",\n-      \"v8::ScriptCompiler::CompileModule must be used to compile modules\");\n-  RETURN_TO_LOCAL_UNCHECKED(\n-      CompileUnboundInternal(v8_isolate, source, options, no_cache_reason),\n-      UnboundScript);\n-}\n-\n MaybeLocal<Script> ScriptCompiler::Compile(Local<Context> context,\n                                            Source* source,\n                                            CompileOptions options,\n@@ -2389,13 +2462,6 @@ MaybeLocal<Script> ScriptCompiler::Compile(Local<Context> context,\n   return result->BindToCurrentContext();\n }\n \n-Local<Script> ScriptCompiler::Compile(Isolate* v8_isolate, Source* source,\n-                                      CompileOptions options,\n-                                      NoCacheReason no_cache_reason) {\n-  auto context = v8_isolate->GetCurrentContext();\n-  RETURN_TO_LOCAL_UNCHECKED(Compile(context, source, options), Script);\n-}\n-\n MaybeLocal<Module> ScriptCompiler::CompileModule(Isolate* isolate,\n                                                  Source* source) {\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n@@ -2459,57 +2525,27 @@ MaybeLocal<Function> ScriptCompiler::CompileFunctionInContext(\n   PREPARE_FOR_EXECUTION(v8_context, ScriptCompiler, CompileFunctionInContext,\n                         Function);\n   TRACE_EVENT_CALL_STATS_SCOPED(isolate, \"v8\", \"V8.ScriptCompiler\");\n-  i::Handle<i::String> source_string;\n-  auto factory = isolate->factory();\n-  if (arguments_count) {\n-    source_string = factory->NewStringFromStaticChars(\"(function(\");\n-    for (size_t i = 0; i < arguments_count; ++i) {\n-      IsIdentifierHelper helper;\n-      if (!helper.Check(*Utils::OpenHandle(*arguments[i]))) {\n-        return Local<Function>();\n-      }\n-      has_pending_exception =\n-          !factory->NewConsString(source_string,\n-                                  Utils::OpenHandle(*arguments[i]))\n-               .ToHandle(&source_string);\n-      RETURN_ON_FAILED_EXECUTION(Function);\n-      if (i + 1 == arguments_count) continue;\n-      has_pending_exception =\n-          !factory->NewConsString(source_string,\n-                                  factory->LookupSingleCharacterStringFromCode(\n-                                      ',')).ToHandle(&source_string);\n-      RETURN_ON_FAILED_EXECUTION(Function);\n-    }\n-    i::Handle<i::String> brackets;\n-    brackets = factory->NewStringFromStaticChars(\"){\");\n-    has_pending_exception = !factory->NewConsString(source_string, brackets)\n-                                 .ToHandle(&source_string);\n-    RETURN_ON_FAILED_EXECUTION(Function);\n-  } else {\n-    source_string = factory->NewStringFromStaticChars(\"(function(){\");\n-  }\n-\n-  int scope_position = source_string->length();\n-  has_pending_exception =\n-      !factory->NewConsString(source_string,\n-                              Utils::OpenHandle(*source->source_string))\n-           .ToHandle(&source_string);\n-  RETURN_ON_FAILED_EXECUTION(Function);\n-  // Include \\n in case the source contains a line end comment.\n-  auto brackets = factory->NewStringFromStaticChars(\"\\n})\");\n-  has_pending_exception =\n-      !factory->NewConsString(source_string, brackets).ToHandle(&source_string);\n-  RETURN_ON_FAILED_EXECUTION(Function);\n \n   i::Handle<i::Context> context = Utils::OpenHandle(*v8_context);\n   i::Handle<i::SharedFunctionInfo> outer_info(context->closure()->shared(),\n                                               isolate);\n+\n+  i::Handle<i::JSFunction> fun;\n+  i::Handle<i::FixedArray> arguments_list =\n+      isolate->factory()->NewFixedArray(static_cast<int>(arguments_count));\n+  for (int i = 0; i < static_cast<int>(arguments_count); i++) {\n+    IsIdentifierHelper helper;\n+    i::Handle<i::String> argument = Utils::OpenHandle(*arguments[i]);\n+    if (!helper.Check(*argument)) return Local<Function>();\n+    arguments_list->set(i, *argument);\n+  }\n+\n   for (size_t i = 0; i < context_extension_count; ++i) {\n     i::Handle<i::JSReceiver> extension =\n         Utils::OpenHandle(*context_extensions[i]);\n     if (!extension->IsJSObject()) return Local<Function>();\n     i::Handle<i::JSFunction> closure(context->closure(), isolate);\n-    context = factory->NewWithContext(\n+    context = isolate->factory()->NewWithContext(\n         closure, context,\n         i::ScopeInfo::CreateForWithScope(\n             isolate, context->IsNativeContext()\n@@ -2519,8 +2555,6 @@ MaybeLocal<Function> ScriptCompiler::CompileFunctionInContext(\n   }\n \n   i::Handle<i::Object> name_obj;\n-  int eval_scope_position = 0;\n-  int eval_position = i::kNoSourcePosition;\n   int line_offset = 0;\n   int column_offset = 0;\n   if (!source->resource_name.IsEmpty()) {\n@@ -2532,27 +2566,15 @@ MaybeLocal<Function> ScriptCompiler::CompileFunctionInContext(\n   if (!source->resource_column_offset.IsEmpty()) {\n     column_offset = static_cast<int>(source->resource_column_offset->Value());\n   }\n-  i::Handle<i::JSFunction> fun;\n-  has_pending_exception =\n-      !i::Compiler::GetFunctionFromEval(\n-           source_string, outer_info, context, i::LanguageMode::kSloppy,\n-           i::ONLY_SINGLE_FUNCTION_LITERAL, i::kNoSourcePosition,\n-           eval_scope_position, eval_position, line_offset,\n-           column_offset - scope_position, name_obj, source->resource_options)\n-           .ToHandle(&fun);\n-  if (has_pending_exception) {\n-    isolate->ReportPendingMessages();\n-  }\n-  RETURN_ON_FAILED_EXECUTION(Function);\n \n-  i::Handle<i::Object> result;\n+  i::Handle<i::JSFunction> result;\n   has_pending_exception =\n-      !i::Execution::Call(isolate, fun,\n-                          Utils::OpenHandle(*v8_context->Global()), 0,\n-                          nullptr).ToHandle(&result);\n+      !i::Compiler::GetWrappedFunction(\n+           Utils::OpenHandle(*source->source_string), arguments_list, context,\n+           line_offset, column_offset, name_obj, source->resource_options)\n+           .ToHandle(&result);\n   RETURN_ON_FAILED_EXECUTION(Function);\n-  RETURN_ESCAPED(\n-      Utils::CallableToLocal(i::Handle<i::JSFunction>::cast(result)));\n+  RETURN_ESCAPED(Utils::CallableToLocal(result));\n }\n \n \n@@ -2587,6 +2609,9 @@ MaybeLocal<Script> ScriptCompiler::Compile(Local<Context> context,\n   i::StreamedSource* source = v8_source->impl();\n   i::Handle<i::String> str = Utils::OpenHandle(*(full_source_string));\n   i::Handle<i::Script> script = isolate->factory()->NewScript(str);\n+  if (isolate->NeedsSourcePositionsForProfiling()) {\n+    i::Script::InitLineEnds(script);\n+  }\n   if (!origin.ResourceName().IsEmpty()) {\n     script->set_name(*Utils::OpenHandle(*(origin.ResourceName())));\n   }\n@@ -2643,23 +2668,49 @@ MaybeLocal<Script> ScriptCompiler::Compile(Local<Context> context,\n   RETURN_ESCAPED(bound);\n }\n \n-\n-Local<Script> ScriptCompiler::Compile(Isolate* v8_isolate,\n-                                      StreamedSource* v8_source,\n-                                      Local<String> full_source_string,\n-                                      const ScriptOrigin& origin) {\n-  auto context = v8_isolate->GetCurrentContext();\n-  RETURN_TO_LOCAL_UNCHECKED(\n-      Compile(context, v8_source, full_source_string, origin), Script);\n-}\n-\n-\n uint32_t ScriptCompiler::CachedDataVersionTag() {\n   return static_cast<uint32_t>(base::hash_combine(\n       internal::Version::Hash(), internal::FlagList::Hash(),\n       static_cast<uint32_t>(internal::CpuFeatures::SupportedFeatures())));\n }\n \n+ScriptCompiler::CachedData* ScriptCompiler::CreateCodeCache(\n+    Local<UnboundScript> unbound_script, Local<String> source) {\n+  i::Handle<i::SharedFunctionInfo> shared =\n+      i::Handle<i::SharedFunctionInfo>::cast(\n+          Utils::OpenHandle(*unbound_script));\n+  i::Isolate* isolate = shared->GetIsolate();\n+  TRACE_EVENT_CALL_STATS_SCOPED(isolate, \"v8\", \"V8.Execute\");\n+  base::ElapsedTimer timer;\n+  if (i::FLAG_profile_deserialization) {\n+    timer.Start();\n+  }\n+  i::HistogramTimerScope histogram_timer(\n+      isolate->counters()->compile_serialize());\n+  i::RuntimeCallTimerScope runtimeTimer(\n+      isolate, i::RuntimeCallCounterId::kCompileSerialize);\n+  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.compile\"), \"V8.CompileSerialize\");\n+\n+  DCHECK(shared->is_toplevel());\n+  i::Handle<i::Script> script(i::Script::cast(shared->script()));\n+  // TODO(7110): Enable serialization of Asm modules once the AsmWasmData is\n+  // context independent.\n+  if (script->ContainsAsmModule()) return nullptr;\n+  if (isolate->debug()->is_loaded()) return nullptr;\n+\n+  i::ScriptData* script_data =\n+      i::CodeSerializer::Serialize(isolate, shared, Utils::OpenHandle(*source));\n+  CachedData* result = new CachedData(\n+      script_data->data(), script_data->length(), CachedData::BufferOwned);\n+  script_data->ReleaseDataOwnership();\n+  delete script_data;\n+\n+  if (i::FLAG_profile_deserialization) {\n+    i::PrintF(\"[Serializing took %0.3f ms]\\n\",\n+              timer.Elapsed().InMillisecondsF());\n+  }\n+  return result;\n+}\n \n MaybeLocal<Script> Script::Compile(Local<Context> context, Local<String> source,\n                                    ScriptOrigin* origin) {\n@@ -2691,24 +2742,6 @@ Local<Script> Script::Compile(v8::Local<String> source,\n \n // --- E x c e p t i o n s ---\n \n-\n-v8::TryCatch::TryCatch()\n-    : isolate_(i::Isolate::Current()),\n-      next_(isolate_->try_catch_handler()),\n-      is_verbose_(false),\n-      can_continue_(true),\n-      capture_message_(true),\n-      rethrow_(false),\n-      has_terminated_(false) {\n-  ResetInternal();\n-  // Special handling for simulators which have a separate JS stack.\n-  js_stack_comparable_address_ =\n-      reinterpret_cast<void*>(i::SimulatorStack::RegisterCTryCatch(\n-          isolate_, i::GetCurrentStackPosition()));\n-  isolate_->RegisterTryCatchHandler(this);\n-}\n-\n-\n v8::TryCatch::TryCatch(v8::Isolate* isolate)\n     : isolate_(reinterpret_cast<i::Isolate*>(isolate)),\n       next_(isolate_->try_catch_handler()),\n@@ -2963,13 +2996,6 @@ Maybe<int> Message::GetEndColumn(Local<Context> context) const {\n }\n \n \n-int Message::GetEndColumn() const {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  const int default_value = kNoColumnInfo;\n-  return GetEndColumn(context).FromMaybe(default_value);\n-}\n-\n-\n bool Message::IsSharedCrossOrigin() const {\n   i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n@@ -3030,65 +3056,6 @@ int StackTrace::GetFrameCount() const {\n   return Utils::OpenHandle(this)->length();\n }\n \n-namespace {\n-i::Handle<i::JSObject> NewFrameObject(i::Isolate* isolate,\n-                                      i::Handle<i::StackFrameInfo> frame) {\n-  i::Handle<i::JSObject> frame_obj =\n-      isolate->factory()->NewJSObject(isolate->object_function());\n-  i::JSObject::AddProperty(\n-      frame_obj, handle(isolate->heap()->line_string()),\n-      handle(i::Smi::FromInt(frame->line_number() + 1), isolate), i::NONE);\n-  i::JSObject::AddProperty(\n-      frame_obj, handle(isolate->heap()->column_string()),\n-      handle(i::Smi::FromInt(frame->column_number() + 1), isolate), i::NONE);\n-  i::JSObject::AddProperty(frame_obj,\n-                           isolate->factory()->InternalizeOneByteString(\n-                               STATIC_CHAR_VECTOR(\"scriptId\")),\n-                           handle(i::Smi::FromInt(frame->script_id()), isolate),\n-                           i::NONE);\n-  i::JSObject::AddProperty(frame_obj,\n-                           isolate->factory()->InternalizeOneByteString(\n-                               STATIC_CHAR_VECTOR(\"scriptName\")),\n-                           handle(frame->script_name(), isolate), i::NONE);\n-  i::JSObject::AddProperty(frame_obj,\n-                           isolate->factory()->InternalizeOneByteString(\n-                               STATIC_CHAR_VECTOR(\"scriptNameOrSourceURL\")),\n-                           handle(frame->script_name_or_source_url(), isolate),\n-                           i::NONE);\n-  i::JSObject::AddProperty(frame_obj,\n-                           isolate->factory()->InternalizeOneByteString(\n-                               STATIC_CHAR_VECTOR(\"functionName\")),\n-                           handle(frame->function_name(), isolate), i::NONE);\n-  i::JSObject::AddProperty(frame_obj,\n-                           isolate->factory()->InternalizeOneByteString(\n-                               STATIC_CHAR_VECTOR(\"isEval\")),\n-                           isolate->factory()->ToBoolean(frame->is_eval()),\n-                           i::NONE);\n-  i::JSObject::AddProperty(\n-      frame_obj,\n-      isolate->factory()->InternalizeOneByteString(\n-          STATIC_CHAR_VECTOR(\"isConstructor\")),\n-      isolate->factory()->ToBoolean(frame->is_constructor()), i::NONE);\n-  return frame_obj;\n-}\n-}  // namespace\n-\n-Local<Array> StackTrace::AsArray() {\n-  i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();\n-  i::Handle<i::FixedArray> self = Utils::OpenHandle(this);\n-  int frame_count = self->length();\n-  i::Handle<i::FixedArray> frames =\n-      isolate->factory()->NewFixedArray(frame_count);\n-  for (int i = 0; i < frame_count; ++i) {\n-    auto obj = handle(self->get(i), isolate);\n-    auto frame = i::Handle<i::StackFrameInfo>::cast(obj);\n-    i::Handle<i::JSObject> frame_obj = NewFrameObject(isolate, frame);\n-    frames->set(i, *frame_obj);\n-  }\n-  return Utils::ToLocal(isolate->factory()->NewJSArrayWithElements(\n-      frames, i::PACKED_ELEMENTS, frame_count));\n-}\n-\n \n Local<StackTrace> StackTrace::CurrentStackTrace(\n     Isolate* isolate,\n@@ -3193,10 +3160,6 @@ MaybeLocal<Value> JSON::Parse(Local<Context> context,\n   RETURN_ESCAPED(result);\n }\n \n-Local<Value> JSON::Parse(Local<String> json_string) {\n-  RETURN_TO_LOCAL_UNCHECKED(Parse(Local<Context>(), json_string), Value);\n-}\n-\n MaybeLocal<String> JSON::Stringify(Local<Context> context,\n                                    Local<Value> json_object,\n                                    Local<String> gap) {\n@@ -3707,12 +3670,6 @@ MaybeLocal<String> Value::ToDetailString(Local<Context> context) const {\n }\n \n \n-Local<String> Value::ToDetailString(Isolate* isolate) const {\n-  RETURN_TO_LOCAL_UNCHECKED(ToDetailString(isolate->GetCurrentContext()),\n-                            String);\n-}\n-\n-\n MaybeLocal<Object> Value::ToObject(Local<Context> context) const {\n   auto obj = Utils::OpenHandle(this);\n   if (obj->IsJSReceiver()) return ToApiHandle<Object>(obj);\n@@ -3806,11 +3763,6 @@ MaybeLocal<Uint32> Value::ToUint32(Local<Context> context) const {\n }\n \n \n-Local<Uint32> Value::ToUint32(Isolate* isolate) const {\n-  RETURN_TO_LOCAL_UNCHECKED(ToUint32(isolate->GetCurrentContext()), Uint32);\n-}\n-\n-\n void i::Internals::CheckInitializedImpl(v8::Isolate* external_isolate) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(external_isolate);\n   Utils::ApiCheck(isolate != nullptr && !isolate->IsDead(),\n@@ -3866,6 +3818,15 @@ void v8::Symbol::CheckCast(v8::Value* that) {\n }\n \n \n+void v8::Private::CheckCast(v8::Data* that) {\n+  i::Handle<i::Object> obj = Utils::OpenHandle(that);\n+  Utils::ApiCheck(obj->IsSymbol() &&\n+                  i::Handle<i::Symbol>::cast(obj)->is_private(),\n+                  \"v8::Private::Cast\",\n+                  \"Could not convert to private\");\n+}\n+\n+\n void v8::Number::CheckCast(v8::Value* that) {\n   i::Handle<i::Object> obj = Utils::OpenHandle(that);\n   Utils::ApiCheck(obj->IsNumber(),\n@@ -4180,17 +4141,6 @@ MaybeLocal<Uint32> Value::ToArrayIndex(Local<Context> context) const {\n }\n \n \n-Local<Uint32> Value::ToArrayIndex() const {\n-  auto self = Utils::OpenHandle(this);\n-  if (self->IsSmi()) {\n-    if (i::Smi::ToInt(*self) >= 0) return Utils::Uint32ToLocal(self);\n-    return Local<Uint32>();\n-  }\n-  auto context = ContextFromHeapObject(self);\n-  RETURN_TO_LOCAL_UNCHECKED(ToArrayIndex(context), Uint32);\n-}\n-\n-\n Maybe<bool> Value::Equals(Local<Context> context, Local<Value> that) const {\n   auto self = Utils::OpenHandle(this);\n   auto other = Utils::OpenHandle(*that);\n@@ -4469,39 +4419,6 @@ Maybe<bool> v8::Object::DefineProperty(v8::Local<v8::Context> context,\n   return success;\n }\n \n-MUST_USE_RESULT\n-static i::MaybeHandle<i::Object> DefineObjectProperty(\n-    i::Handle<i::JSObject> js_object, i::Handle<i::Object> key,\n-    i::Handle<i::Object> value, i::PropertyAttributes attrs) {\n-  i::Isolate* isolate = js_object->GetIsolate();\n-  bool success = false;\n-  i::LookupIterator it = i::LookupIterator::PropertyOrElement(\n-      isolate, js_object, key, &success, i::LookupIterator::OWN);\n-  if (!success) return i::MaybeHandle<i::Object>();\n-\n-  return i::JSObject::DefineOwnPropertyIgnoreAttributes(\n-      &it, value, attrs, i::JSObject::FORCE_FIELD);\n-}\n-\n-\n-Maybe<bool> v8::Object::ForceSet(v8::Local<v8::Context> context,\n-                                 v8::Local<Value> key, v8::Local<Value> value,\n-                                 v8::PropertyAttribute attribs) {\n-  auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n-  ENTER_V8_NO_SCRIPT(isolate, context, Object, ForceSet, Nothing<bool>(),\n-                     i::HandleScope);\n-  auto self = i::Handle<i::JSObject>::cast(Utils::OpenHandle(this));\n-  auto key_obj = Utils::OpenHandle(*key);\n-  auto value_obj = Utils::OpenHandle(*value);\n-  has_pending_exception =\n-      DefineObjectProperty(self, key_obj, value_obj,\n-                           static_cast<i::PropertyAttributes>(attribs))\n-          .is_null();\n-  RETURN_ON_FAILED_EXECUTION_PRIMITIVE(bool);\n-  return Just(true);\n-}\n-\n-\n Maybe<bool> v8::Object::SetPrivate(Local<Context> context, Local<Private> key,\n                                    Local<Value> value) {\n   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n@@ -4595,12 +4512,6 @@ Maybe<PropertyAttribute> v8::Object::GetPropertyAttributes(\n }\n \n \n-PropertyAttribute v8::Object::GetPropertyAttributes(v8::Local<Value> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  return GetPropertyAttributes(context, key)\n-      .FromMaybe(static_cast<PropertyAttribute>(i::NONE));\n-}\n-\n MaybeLocal<Value> v8::Object::GetOwnPropertyDescriptor(Local<Context> context,\n                                                        Local<Name> key) {\n   PREPARE_FOR_EXECUTION(context, Object, GetOwnPropertyDescriptor, Value);\n@@ -4618,11 +4529,6 @@ MaybeLocal<Value> v8::Object::GetOwnPropertyDescriptor(Local<Context> context,\n   RETURN_ESCAPED(Utils::ToLocal(desc.ToObject(isolate)));\n }\n \n-Local<Value> v8::Object::GetOwnPropertyDescriptor(Local<Name> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  RETURN_TO_LOCAL_UNCHECKED(GetOwnPropertyDescriptor(context, key), Value);\n-}\n-\n \n Local<Value> v8::Object::GetPrototype() {\n   auto isolate = Utils::OpenHandle(this)->GetIsolate();\n@@ -4650,11 +4556,6 @@ Maybe<bool> v8::Object::SetPrototype(Local<Context> context,\n }\n \n \n-bool v8::Object::SetPrototype(Local<Value> value) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  return SetPrototype(context, value).FromMaybe(false);\n-}\n-\n Local<Object> v8::Object::FindInstanceInPrototypeChain(\n     v8::Local<FunctionTemplate> tmpl) {\n   auto self = Utils::OpenHandle(this);\n@@ -4733,12 +4634,6 @@ MaybeLocal<String> v8::Object::ObjectProtoToString(Local<Context> context) {\n }\n \n \n-Local<String> v8::Object::ObjectProtoToString() {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  RETURN_TO_LOCAL_UNCHECKED(ObjectProtoToString(context), String);\n-}\n-\n-\n Local<String> v8::Object::GetConstructorName() {\n   auto self = Utils::OpenHandle(this);\n   i::Handle<i::String> name = i::JSReceiver::GetConstructorName(self);\n@@ -4850,12 +4745,6 @@ Maybe<bool> v8::Object::Delete(Local<Context> context, uint32_t index) {\n }\n \n \n-bool v8::Object::Delete(uint32_t index) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  return Delete(context, index).FromMaybe(false);\n-}\n-\n-\n Maybe<bool> v8::Object::Has(Local<Context> context, uint32_t index) {\n   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n   ENTER_V8(isolate, context, Object, Has, Nothing<bool>(), i::HandleScope);\n@@ -4867,11 +4756,6 @@ Maybe<bool> v8::Object::Has(Local<Context> context, uint32_t index) {\n }\n \n \n-bool v8::Object::Has(uint32_t index) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  return Has(context, index).FromMaybe(false);\n-}\n-\n template <typename Getter, typename Setter, typename Data>\n static Maybe<bool> ObjectSetAccessor(Local<Context> context, Object* self,\n                                      Local<Name> name, Getter getter,\n@@ -4918,27 +4802,6 @@ Maybe<bool> Object::SetAccessor(Local<Context> context, Local<Name> name,\n }\n \n \n-bool Object::SetAccessor(Local<String> name, AccessorGetterCallback getter,\n-                         AccessorSetterCallback setter, v8::Local<Value> data,\n-                         AccessControl settings, PropertyAttribute attributes) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  return ObjectSetAccessor(context, this, name, getter, setter, data, settings,\n-                           attributes, i::FLAG_disable_old_api_accessors)\n-      .FromMaybe(false);\n-}\n-\n-\n-bool Object::SetAccessor(Local<Name> name, AccessorNameGetterCallback getter,\n-                         AccessorNameSetterCallback setter,\n-                         v8::Local<Value> data, AccessControl settings,\n-                         PropertyAttribute attributes) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  return ObjectSetAccessor(context, this, name, getter, setter, data, settings,\n-                           attributes, i::FLAG_disable_old_api_accessors)\n-      .FromMaybe(false);\n-}\n-\n-\n void Object::SetAccessorProperty(Local<Name> name, Local<Function> getter,\n                                  Local<Function> setter,\n                                  PropertyAttribute attribute,\n@@ -4992,12 +4855,6 @@ Maybe<bool> v8::Object::HasOwnProperty(Local<Context> context, uint32_t index) {\n   return result;\n }\n \n-bool v8::Object::HasOwnProperty(Local<String> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  return HasOwnProperty(context, key).FromMaybe(false);\n-}\n-\n-\n Maybe<bool> v8::Object::HasRealNamedProperty(Local<Context> context,\n                                              Local<Name> key) {\n   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n@@ -5099,14 +4956,6 @@ MaybeLocal<Value> v8::Object::GetRealNamedPropertyInPrototypeChain(\n }\n \n \n-Local<Value> v8::Object::GetRealNamedPropertyInPrototypeChain(\n-    Local<String> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  RETURN_TO_LOCAL_UNCHECKED(GetRealNamedPropertyInPrototypeChain(context, key),\n-                            Value);\n-}\n-\n-\n Maybe<PropertyAttribute>\n v8::Object::GetRealNamedPropertyAttributesInPrototypeChain(\n     Local<Context> context, Local<Name> key) {\n@@ -5133,13 +4982,6 @@ v8::Object::GetRealNamedPropertyAttributesInPrototypeChain(\n }\n \n \n-Maybe<PropertyAttribute>\n-v8::Object::GetRealNamedPropertyAttributesInPrototypeChain(Local<String> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  return GetRealNamedPropertyAttributesInPrototypeChain(context, key);\n-}\n-\n-\n MaybeLocal<Value> v8::Object::GetRealNamedProperty(Local<Context> context,\n                                                    Local<Name> key) {\n   PREPARE_FOR_EXECUTION(context, Object, GetRealNamedProperty, Value);\n@@ -5156,12 +4998,6 @@ MaybeLocal<Value> v8::Object::GetRealNamedProperty(Local<Context> context,\n }\n \n \n-Local<Value> v8::Object::GetRealNamedProperty(Local<String> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  RETURN_TO_LOCAL_UNCHECKED(GetRealNamedProperty(context, key), Value);\n-}\n-\n-\n Maybe<PropertyAttribute> v8::Object::GetRealNamedPropertyAttributes(\n     Local<Context> context, Local<Name> key) {\n   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n@@ -5183,13 +5019,6 @@ Maybe<PropertyAttribute> v8::Object::GetRealNamedPropertyAttributes(\n }\n \n \n-Maybe<PropertyAttribute> v8::Object::GetRealNamedPropertyAttributes(\n-    Local<String> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  return GetRealNamedPropertyAttributes(context, key);\n-}\n-\n-\n Local<v8::Object> v8::Object::Clone() {\n   auto self = i::Handle<i::JSObject>::cast(Utils::OpenHandle(this));\n   auto isolate = self->GetIsolate();\n@@ -5245,15 +5074,6 @@ MaybeLocal<Value> Object::CallAsFunction(Local<Context> context,\n }\n \n \n-Local<v8::Value> Object::CallAsFunction(v8::Local<v8::Value> recv, int argc,\n-                                        v8::Local<v8::Value> argv[]) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  Local<Value>* argv_cast = reinterpret_cast<Local<Value>*>(argv);\n-  RETURN_TO_LOCAL_UNCHECKED(CallAsFunction(context, recv, argc, argv_cast),\n-                            Value);\n-}\n-\n-\n MaybeLocal<Value> Object::CallAsConstructor(Local<Context> context, int argc,\n                                             Local<Value> argv[]) {\n   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n@@ -5272,13 +5092,6 @@ MaybeLocal<Value> Object::CallAsConstructor(Local<Context> context, int argc,\n }\n \n \n-Local<v8::Value> Object::CallAsConstructor(int argc,\n-                                           v8::Local<v8::Value> argv[]) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  Local<Value>* argv_cast = reinterpret_cast<Local<Value>*>(argv);\n-  RETURN_TO_LOCAL_UNCHECKED(CallAsConstructor(context, argc, argv_cast), Value);\n-}\n-\n MaybeLocal<Function> Function::New(Local<Context> context,\n                                    FunctionCallback callback, Local<Value> data,\n                                    int length, ConstructorBehavior behavior) {\n@@ -5300,12 +5113,6 @@ Local<Function> Function::New(Isolate* v8_isolate, FunctionCallback callback,\n }\n \n \n-Local<v8::Object> Function::NewInstance() const {\n-  return NewInstance(Isolate::GetCurrent()->GetCurrentContext(), 0, nullptr)\n-      .FromMaybe(Local<Object>());\n-}\n-\n-\n MaybeLocal<Object> Function::NewInstance(Local<Context> context, int argc,\n                                          v8::Local<v8::Value> argv[]) const {\n   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n@@ -5324,13 +5131,6 @@ MaybeLocal<Object> Function::NewInstance(Local<Context> context, int argc,\n }\n \n \n-Local<v8::Object> Function::NewInstance(int argc,\n-                                        v8::Local<v8::Value> argv[]) const {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  RETURN_TO_LOCAL_UNCHECKED(NewInstance(context, argc, argv), Object);\n-}\n-\n-\n MaybeLocal<v8::Value> Function::Call(Local<Context> context,\n                                      v8::Local<v8::Value> recv, int argc,\n                                      v8::Local<v8::Value> argv[]) {\n@@ -5340,6 +5140,8 @@ MaybeLocal<v8::Value> Function::Call(Local<Context> context,\n            InternalEscapableScope);\n   i::TimerEventScope<i::TimerEventExecute> timer_scope(isolate);\n   auto self = Utils::OpenHandle(this);\n+  Utils::ApiCheck(!self.is_null(), \"v8::Function::Call\",\n+                  \"Function to be called is a null pointer\");\n   i::Handle<i::Object> recv_obj = Utils::OpenHandle(*recv);\n   STATIC_ASSERT(sizeof(v8::Local<v8::Value>) == sizeof(i::Object**));\n   i::Handle<i::Object>* args = reinterpret_cast<i::Handle<i::Object>*>(argv);\n@@ -5474,16 +5276,6 @@ int Function::GetScriptColumnNumber() const {\n }\n \n \n-bool Function::IsBuiltin() const {\n-  auto self = Utils::OpenHandle(this);\n-  if (!self->IsJSFunction()) {\n-    return false;\n-  }\n-  auto func = i::Handle<i::JSFunction>::cast(self);\n-  return !func->shared()->IsUserJavaScript();\n-}\n-\n-\n int Function::ScriptId() const {\n   auto self = Utils::OpenHandle(this);\n   if (!self->IsJSFunction()) {\n@@ -6397,7 +6189,9 @@ HeapStatistics::HeapStatistics()\n       heap_size_limit_(0),\n       malloced_memory_(0),\n       peak_malloced_memory_(0),\n-      does_zap_garbage_(0) {}\n+      does_zap_garbage_(0),\n+      number_of_native_contexts_(0),\n+      number_of_detached_contexts_(0) {}\n \n HeapSpaceStatistics::HeapSpaceStatistics(): space_name_(0),\n                                             space_size_(0),\n@@ -6415,10 +6209,6 @@ HeapObjectStatistics::HeapObjectStatistics()\n HeapCodeStatistics::HeapCodeStatistics()\n     : code_and_metadata_size_(0), bytecode_and_metadata_size_(0) {}\n \n-bool v8::V8::InitializeICU(const char* icu_data_file) {\n-  return i::InitializeICU(icu_data_file);\n-}\n-\n bool v8::V8::InitializeICUDefaultLocation(const char* exec_path,\n                                           const char* icu_data_file) {\n   return i::InitializeICUDefaultLocation(exec_path, icu_data_file);\n@@ -6724,7 +6514,31 @@ void Context::SetErrorMessageForCodeGenerationFromStrings(Local<String> error) {\n   context->set_error_message_for_code_gen_from_strings(*error_handle);\n }\n \n-size_t Context::EstimatedSize() { return 0; }\n+namespace {\n+i::Object** GetSerializedDataFromFixedArray(i::Isolate* isolate,\n+                                            i::FixedArray* list, size_t index) {\n+  if (index < static_cast<size_t>(list->length())) {\n+    int int_index = static_cast<int>(index);\n+    i::Object* object = list->get(int_index);\n+    if (!object->IsTheHole(isolate)) {\n+      list->set_the_hole(isolate, int_index);\n+      // Shrink the list so that the last element is not the hole.\n+      int last = list->length() - 1;\n+      while (last >= 0 && list->is_the_hole(isolate, last)) last--;\n+      list->Shrink(last + 1);\n+      return i::Handle<i::Object>(object, isolate).location();\n+    }\n+  }\n+  return nullptr;\n+}\n+}  // anonymous namespace\n+\n+i::Object** Context::GetDataFromSnapshotOnce(size_t index) {\n+  auto context = Utils::OpenHandle(this);\n+  i::Isolate* i_isolate = context->GetIsolate();\n+  i::FixedArray* list = i::FixedArray::cast(context->serialized_objects());\n+  return GetSerializedDataFromFixedArray(i_isolate, list, index);\n+}\n \n MaybeLocal<v8::Object> ObjectTemplate::NewInstance(Local<Context> context) {\n   PREPARE_FOR_EXECUTION(context, ObjectTemplate, NewInstance, Object);\n@@ -6742,6 +6556,29 @@ Local<v8::Object> ObjectTemplate::NewInstance() {\n   RETURN_TO_LOCAL_UNCHECKED(NewInstance(context), Object);\n }\n \n+void v8::ObjectTemplate::CheckCast(Data* that) {\n+  i::Handle<i::Object> obj = Utils::OpenHandle(that);\n+  Utils::ApiCheck(obj->IsObjectTemplateInfo(), \"v8::ObjectTemplate::Cast\",\n+                  \"Could not convert to object template\");\n+}\n+\n+void v8::FunctionTemplate::CheckCast(Data* that) {\n+  i::Handle<i::Object> obj = Utils::OpenHandle(that);\n+  Utils::ApiCheck(obj->IsFunctionTemplateInfo(), \"v8::FunctionTemplate::Cast\",\n+                  \"Could not convert to function template\");\n+}\n+\n+void v8::Signature::CheckCast(Data* that) {\n+  i::Handle<i::Object> obj = Utils::OpenHandle(that);\n+  Utils::ApiCheck(obj->IsFunctionTemplateInfo(), \"v8::Signature::Cast\",\n+                  \"Could not convert to signature\");\n+}\n+\n+void v8::AccessorSignature::CheckCast(Data* that) {\n+  i::Handle<i::Object> obj = Utils::OpenHandle(that);\n+  Utils::ApiCheck(obj->IsFunctionTemplateInfo(), \"v8::AccessorSignature::Cast\",\n+                  \"Could not convert to accessor signature\");\n+}\n \n MaybeLocal<v8::Function> FunctionTemplate::GetFunction(Local<Context> context) {\n   PREPARE_FOR_EXECUTION(context, FunctionTemplate, GetFunction, Function);\n@@ -6915,16 +6752,6 @@ MaybeLocal<String> String::NewFromUtf8(Isolate* isolate, const char* data,\n }\n \n \n-Local<String> String::NewFromOneByte(Isolate* isolate,\n-                                     const uint8_t* data,\n-                                     NewStringType type,\n-                                     int length) {\n-  NEW_STRING(isolate, String, NewFromOneByte, uint8_t, data,\n-             static_cast<v8::NewStringType>(type), length);\n-  RETURN_TO_LOCAL_UNCHECKED(result, String);\n-}\n-\n-\n MaybeLocal<String> String::NewFromOneByte(Isolate* isolate, const uint8_t* data,\n                                           v8::NewStringType type, int length) {\n   NEW_STRING(isolate, String, NewFromOneByte, uint8_t, data, type, length);\n@@ -6991,12 +6818,6 @@ MaybeLocal<String> v8::String::NewExternalTwoByte(\n }\n \n \n-Local<String> v8::String::NewExternal(\n-    Isolate* isolate, v8::String::ExternalStringResource* resource) {\n-  RETURN_TO_LOCAL_UNCHECKED(NewExternalTwoByte(isolate, resource), String);\n-}\n-\n-\n MaybeLocal<String> v8::String::NewExternalOneByte(\n     Isolate* isolate, v8::String::ExternalOneByteStringResource* resource) {\n   CHECK(resource && resource->data());\n@@ -7133,11 +6954,6 @@ Local<v8::Value> v8::BooleanObject::New(Isolate* isolate, bool value) {\n }\n \n \n-Local<v8::Value> v8::BooleanObject::New(bool value) {\n-  return New(Isolate::GetCurrent(), value);\n-}\n-\n-\n bool v8::BooleanObject::ValueOf() const {\n   i::Handle<i::Object> obj = Utils::OpenHandle(this);\n   i::Handle<i::JSValue> jsvalue = i::Handle<i::JSValue>::cast(obj);\n@@ -7306,27 +7122,6 @@ uint32_t v8::Array::Length() const {\n }\n \n \n-MaybeLocal<Object> Array::CloneElementAt(Local<Context> context,\n-                                         uint32_t index) {\n-  PREPARE_FOR_EXECUTION(context, Array, CloneElementAt, Object);\n-  auto self = Utils::OpenHandle(this);\n-  if (!self->HasObjectElements()) return Local<Object>();\n-  i::FixedArray* elms = i::FixedArray::cast(self->elements());\n-  i::Object* paragon = elms->get(index);\n-  if (!paragon->IsJSObject()) return Local<Object>();\n-  i::Handle<i::JSObject> paragon_handle(i::JSObject::cast(paragon));\n-  Local<Object> result;\n-  has_pending_exception =\n-      !ToLocal<Object>(isolate->factory()->CopyJSObject(paragon_handle),\n-                       &result);\n-  RETURN_ON_FAILED_EXECUTION(Object);\n-  RETURN_ESCAPED(result);\n-}\n-\n-\n-Local<Object> Array::CloneElementAt(uint32_t index) { return Local<Object>(); }\n-\n-\n Local<v8::Map> v8::Map::New(Isolate* isolate) {\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n   LOG_API(i_isolate, Map, New);\n@@ -7643,12 +7438,6 @@ MaybeLocal<Promise> Promise::Catch(Local<Context> context,\n }\n \n \n-Local<Promise> Promise::Catch(Local<Function> handler) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  RETURN_TO_LOCAL_UNCHECKED(Catch(context, handler), Promise);\n-}\n-\n-\n MaybeLocal<Promise> Promise::Then(Local<Context> context,\n                                   Local<Function> handler) {\n   PREPARE_FOR_EXECUTION(context, Promise, Then, Promise);\n@@ -7663,12 +7452,6 @@ MaybeLocal<Promise> Promise::Then(Local<Context> context,\n }\n \n \n-Local<Promise> Promise::Then(Local<Function> handler) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n-  RETURN_TO_LOCAL_UNCHECKED(Then(context, handler), Promise);\n-}\n-\n-\n bool Promise::HasHandler() {\n   i::Handle<i::JSReceiver> promise = Utils::OpenHandle(this);\n   i::Isolate* isolate = promise->GetIsolate();\n@@ -7700,9 +7483,9 @@ Promise::PromiseState Promise::State() {\n   return static_cast<PromiseState>(js_promise->status());\n }\n \n-Local<Object> Proxy::GetTarget() {\n+Local<Value> Proxy::GetTarget() {\n   i::Handle<i::JSProxy> self = Utils::OpenHandle(this);\n-  i::Handle<i::JSReceiver> target(self->target());\n+  i::Handle<i::Object> target(self->target(), self->GetIsolate());\n   return Utils::ToLocal(target);\n }\n \n@@ -7742,8 +7525,8 @@ Local<String> WasmCompiledModule::GetWasmWireBytes() {\n   i::Handle<i::WasmModuleObject> obj =\n       i::Handle<i::WasmModuleObject>::cast(Utils::OpenHandle(this));\n   i::Handle<i::WasmCompiledModule> compiled_part =\n-      i::handle(i::WasmCompiledModule::cast(obj->compiled_module()));\n-  i::Handle<i::String> wire_bytes(compiled_part->module_bytes());\n+      i::handle(obj->compiled_module());\n+  i::Handle<i::String> wire_bytes(compiled_part->shared()->module_bytes());\n   return Local<String>::Cast(Utils::ToLocal(wire_bytes));\n }\n \n@@ -7782,46 +7565,22 @@ WasmCompiledModule::SerializedModule WasmCompiledModule::Serialize() {\n       i::Handle<i::WasmModuleObject>::cast(Utils::OpenHandle(this));\n   i::Handle<i::WasmCompiledModule> compiled_part =\n       i::handle(i::WasmCompiledModule::cast(obj->compiled_module()));\n-  if (i::FLAG_wasm_jit_to_native) {\n-    i::Isolate* isolate = obj->GetIsolate();\n-\n-    return i::wasm::NativeModuleSerializer::SerializeWholeModule(isolate,\n-                                                                 compiled_part);\n-  } else {\n-    std::unique_ptr<i::ScriptData> script_data =\n-        i::WasmCompiledModuleSerializer::SerializeWasmModule(obj->GetIsolate(),\n-                                                             compiled_part);\n-    script_data->ReleaseDataOwnership();\n-\n-    size_t size = static_cast<size_t>(script_data->length());\n-    return {std::unique_ptr<const uint8_t[]>(script_data->data()), size};\n-  }\n+  return i::wasm::SerializeNativeModule(obj->GetIsolate(), compiled_part);\n }\n \n MaybeLocal<WasmCompiledModule> WasmCompiledModule::Deserialize(\n     Isolate* isolate,\n     const WasmCompiledModule::CallerOwnedBuffer& serialized_module,\n     const WasmCompiledModule::CallerOwnedBuffer& wire_bytes) {\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n-  i::MaybeHandle<i::FixedArray> maybe_compiled_part;\n-  if (i::FLAG_wasm_jit_to_native) {\n-    maybe_compiled_part =\n-        i::wasm::NativeModuleDeserializer::DeserializeFullBuffer(\n-            i_isolate, {serialized_module.first, serialized_module.second},\n-            {wire_bytes.first, wire_bytes.second});\n-  } else {\n-    int size = static_cast<int>(serialized_module.second);\n-    i::ScriptData sc(serialized_module.first, size);\n-    maybe_compiled_part =\n-        i::WasmCompiledModuleSerializer::DeserializeWasmModule(\n-            i_isolate, &sc, {wire_bytes.first, wire_bytes.second});\n-  }\n-  i::Handle<i::FixedArray> compiled_part;\n-  if (!maybe_compiled_part.ToHandle(&compiled_part)) {\n+  i::MaybeHandle<i::WasmCompiledModule> maybe_compiled_module =\n+      i::wasm::DeserializeNativeModule(\n+          i_isolate, {serialized_module.first, serialized_module.second},\n+          {wire_bytes.first, wire_bytes.second});\n+  i::Handle<i::WasmCompiledModule> compiled_module;\n+  if (!maybe_compiled_module.ToHandle(&compiled_module)) {\n     return MaybeLocal<WasmCompiledModule>();\n   }\n-  i::Handle<i::WasmCompiledModule> compiled_module =\n-      handle(i::WasmCompiledModule::cast(*compiled_part));\n   return Local<WasmCompiledModule>::Cast(\n       Utils::ToLocal(i::Handle<i::JSObject>::cast(\n           i::WasmModuleObject::New(i_isolate, compiled_module))));\n@@ -7866,8 +7625,10 @@ WasmModuleObjectBuilderStreaming::WasmModuleObjectBuilderStreaming(\n     i::Handle<i::JSPromise> promise = Utils::OpenHandle(*GetPromise());\n     i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n     streaming_decoder_ =\n-        i_isolate->wasm_compilation_manager()->StartStreamingCompilation(\n-            i_isolate, handle(i_isolate->context()), promise);\n+        i_isolate->wasm_engine()\n+            ->compilation_manager()\n+            ->StartStreamingCompilation(i_isolate, handle(i_isolate->context()),\n+                                        promise);\n   }\n }\n \n@@ -7907,7 +7668,8 @@ void WasmModuleObjectBuilderStreaming::Finish() {\n   // will be resolved when we move to true streaming compilation.\n   i::wasm::AsyncCompile(reinterpret_cast<i::Isolate*>(isolate_),\n                         Utils::OpenHandle(*promise_.Get(isolate_)),\n-                        {wire_bytes.get(), wire_bytes.get() + total_size_});\n+                        {wire_bytes.get(), wire_bytes.get() + total_size_},\n+                        false);\n }\n \n void WasmModuleObjectBuilderStreaming::Abort(Local<Value> exception) {\n@@ -7917,6 +7679,12 @@ void WasmModuleObjectBuilderStreaming::Abort(Local<Value> exception) {\n   if (promise->State() != v8::Promise::kPending) return;\n   if (i::FLAG_wasm_stream_compilation) streaming_decoder_->Abort();\n \n+  // If there is no exception, then we do not reject the promise. The reason is\n+  // that 'no exception' indicates that we are in a ScriptForbiddenScope, which\n+  // means that it is not allowed to reject the promise at the moment, or\n+  // execute any other JavaScript code.\n+  if (exception.IsEmpty()) return;\n+\n   Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate_);\n   i::HandleScope scope(i_isolate);\n@@ -7973,6 +7741,14 @@ v8::ArrayBuffer::Contents v8::ArrayBuffer::Externalize() {\n   Utils::ApiCheck(!self->is_external(), \"v8_ArrayBuffer_Externalize\",\n                   \"ArrayBuffer already externalized\");\n   self->set_is_external(true);\n+  if (self->has_guard_region()) {\n+    // Since this is being externalized, the Wasm Allocation Tracker can no\n+    // longer track it.\n+    //\n+    // TODO(eholk): Find a way to track this across externalization\n+    isolate->wasm_engine()->allocation_tracker()->ReleaseAddressSpace(\n+        self->allocation_length());\n+  }\n   isolate->heap()->UnregisterArrayBuffer(*self);\n \n   return GetContents();\n@@ -8188,6 +7964,14 @@ v8::SharedArrayBuffer::Contents v8::SharedArrayBuffer::Externalize() {\n   Utils::ApiCheck(!self->is_external(), \"v8_SharedArrayBuffer_Externalize\",\n                   \"SharedArrayBuffer already externalized\");\n   self->set_is_external(true);\n+  if (self->has_guard_region()) {\n+    // Since this is being externalized, the Wasm Allocation Tracker can no\n+    // longer track it.\n+    //\n+    // TODO(eholk): Find a way to track this across externalization\n+    isolate->wasm_engine()->allocation_tracker()->ReleaseAddressSpace(\n+        self->allocation_length());\n+  }\n   isolate->heap()->UnregisterArrayBuffer(*self);\n   return GetContents();\n }\n@@ -8197,14 +7981,14 @@ v8::SharedArrayBuffer::Contents v8::SharedArrayBuffer::GetContents() {\n   i::Handle<i::JSArrayBuffer> self = Utils::OpenHandle(this);\n   size_t byte_length = static_cast<size_t>(self->byte_length()->Number());\n   Contents contents;\n+  contents.allocation_base_ = self->allocation_base();\n+  contents.allocation_length_ = self->allocation_length();\n+  contents.allocation_mode_ =\n+      self->has_guard_region()\n+          ? ArrayBufferAllocator::Allocator::AllocationMode::kReservation\n+          : ArrayBufferAllocator::Allocator::AllocationMode::kNormal;\n   contents.data_ = self->backing_store();\n   contents.byte_length_ = byte_length;\n-  // SharedArrayBuffers never have guard regions, so their allocation and data\n-  // are equivalent.\n-  contents.allocation_base_ = self->backing_store();\n-  contents.allocation_length_ = byte_length;\n-  contents.allocation_mode_ =\n-      ArrayBufferAllocator::Allocator::AllocationMode::kNormal;\n   return contents;\n }\n \n@@ -8727,6 +8511,11 @@ Isolate::SuppressMicrotaskExecutionScope::~SuppressMicrotaskExecutionScope() {\n   isolate_->handle_scope_implementer()->DecrementCallDepth();\n }\n \n+i::Object** Isolate::GetDataFromSnapshotOnce(size_t index) {\n+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(this);\n+  i::FixedArray* list = i_isolate->heap()->serialized_objects();\n+  return GetSerializedDataFromFixedArray(i_isolate, list, index);\n+}\n \n void Isolate::GetHeapStatistics(HeapStatistics* heap_statistics) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n@@ -8742,6 +8531,9 @@ void Isolate::GetHeapStatistics(HeapStatistics* heap_statistics) {\n       isolate->allocator()->GetCurrentMemoryUsage();\n   heap_statistics->peak_malloced_memory_ =\n       isolate->allocator()->GetMaxMemoryUsage();\n+  heap_statistics->number_of_native_contexts_ = heap->NumberOfNativeContexts();\n+  heap_statistics->number_of_detached_contexts_ =\n+      heap->NumberOfDetachedContexts();\n   heap_statistics->does_zap_garbage_ = heap->ShouldZapGarbage();\n }\n \n@@ -8870,7 +8662,6 @@ void Isolate::RemoveCallCompletedCallback(CallCompletedCallback callback) {\n   isolate->RemoveCallCompletedCallback(callback);\n }\n \n-\n void Isolate::AddCallCompletedCallback(\n     DeprecatedCallCompletedCallback callback) {\n   AddCallCompletedCallback(reinterpret_cast<CallCompletedCallback>(callback));\n@@ -8985,15 +8776,6 @@ void Isolate::SetAddHistogramSampleFunction(\n }\n \n \n-bool Isolate::IdleNotification(int idle_time_in_ms) {\n-  // Returning true tells the caller that it need not\n-  // continue to call IdleNotification.\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n-  if (!i::FLAG_use_idle_notification) return true;\n-  return isolate->heap()->IdleNotification(idle_time_in_ms);\n-}\n-\n-\n bool Isolate::IdleNotificationDeadline(double deadline_in_seconds) {\n   // Returning true tells the caller that it need not\n   // continue to call IdleNotification.\n@@ -9346,14 +9128,6 @@ Local<Message> Exception::CreateMessage(Isolate* isolate,\n }\n \n \n-Local<Message> Exception::CreateMessage(Local<Value> exception) {\n-  i::Handle<i::Object> obj = Utils::OpenHandle(*exception);\n-  if (!obj->IsHeapObject()) return Local<Message>();\n-  i::Isolate* isolate = i::HeapObject::cast(*obj)->GetIsolate();\n-  return CreateMessage(reinterpret_cast<Isolate*>(isolate), exception);\n-}\n-\n-\n Local<StackTrace> Exception::GetStackTrace(Local<Value> exception) {\n   i::Handle<i::Object> obj = Utils::OpenHandle(*exception);\n   if (!obj->IsJSObject()) return Local<StackTrace>();\n@@ -9664,9 +9438,9 @@ bool debug::Script::GetPossibleBreakpoints(\n   CHECK(!start.IsEmpty());\n   i::Handle<i::Script> script = Utils::OpenHandle(this);\n   if (script->type() == i::Script::TYPE_WASM) {\n-    i::Handle<i::WasmCompiledModule> compiled_module(\n-        i::WasmCompiledModule::cast(script->wasm_compiled_module()));\n-    return compiled_module->GetPossibleBreakpoints(start, end, locations);\n+    i::WasmSharedModuleData* shared =\n+        i::WasmCompiledModule::cast(script->wasm_compiled_module())->shared();\n+    return shared->GetPossibleBreakpoints(start, end, locations);\n   }\n \n   i::Script::InitLineEnds(script);\n@@ -9715,6 +9489,7 @@ int debug::Script::GetSourceOffset(const debug::Location& location) const {\n   i::Handle<i::Script> script = Utils::OpenHandle(this);\n   if (script->type() == i::Script::TYPE_WASM) {\n     return i::WasmCompiledModule::cast(script->wasm_compiled_module())\n+               ->shared()\n                ->GetFunctionOffset(location.GetLineNumber()) +\n            location.GetColumnNumber();\n   }\n@@ -9784,8 +9559,9 @@ int debug::WasmScript::NumFunctions() const {\n   DCHECK_EQ(i::Script::TYPE_WASM, script->type());\n   i::WasmCompiledModule* compiled_module =\n       i::WasmCompiledModule::cast(script->wasm_compiled_module());\n-  DCHECK_GE(i::kMaxInt, compiled_module->module()->functions.size());\n-  return static_cast<int>(compiled_module->module()->functions.size());\n+  i::wasm::WasmModule* module = compiled_module->shared()->module();\n+  DCHECK_GE(i::kMaxInt, module->functions.size());\n+  return static_cast<int>(module->functions.size());\n }\n \n int debug::WasmScript::NumImportedFunctions() const {\n@@ -9794,8 +9570,9 @@ int debug::WasmScript::NumImportedFunctions() const {\n   DCHECK_EQ(i::Script::TYPE_WASM, script->type());\n   i::WasmCompiledModule* compiled_module =\n       i::WasmCompiledModule::cast(script->wasm_compiled_module());\n-  DCHECK_GE(i::kMaxInt, compiled_module->module()->num_imported_functions);\n-  return static_cast<int>(compiled_module->module()->num_imported_functions);\n+  i::wasm::WasmModule* module = compiled_module->shared()->module();\n+  DCHECK_GE(i::kMaxInt, module->num_imported_functions);\n+  return static_cast<int>(module->num_imported_functions);\n }\n \n std::pair<int, int> debug::WasmScript::GetFunctionRange(\n@@ -9805,10 +9582,10 @@ std::pair<int, int> debug::WasmScript::GetFunctionRange(\n   DCHECK_EQ(i::Script::TYPE_WASM, script->type());\n   i::WasmCompiledModule* compiled_module =\n       i::WasmCompiledModule::cast(script->wasm_compiled_module());\n+  i::wasm::WasmModule* module = compiled_module->shared()->module();\n   DCHECK_LE(0, function_index);\n-  DCHECK_GT(compiled_module->module()->functions.size(), function_index);\n-  i::wasm::WasmFunction& func =\n-      compiled_module->module()->functions[function_index];\n+  DCHECK_GT(module->functions.size(), function_index);\n+  i::wasm::WasmFunction& func = module->functions[function_index];\n   DCHECK_GE(i::kMaxInt, func.code.offset());\n   DCHECK_GE(i::kMaxInt, func.code.end_offset());\n   return std::make_pair(static_cast<int>(func.code.offset()),\n@@ -9822,7 +9599,7 @@ debug::WasmDisassembly debug::WasmScript::DisassembleFunction(\n   DCHECK_EQ(i::Script::TYPE_WASM, script->type());\n   i::WasmCompiledModule* compiled_module =\n       i::WasmCompiledModule::cast(script->wasm_compiled_module());\n-  return compiled_module->DisassembleFunction(function_index);\n+  return compiled_module->shared()->DisassembleFunction(function_index);\n }\n \n debug::Location::Location(int line_number, int column_number)\n@@ -9851,9 +9628,6 @@ void debug::GetLoadedScripts(v8::Isolate* v8_isolate,\n                              PersistentValueVector<debug::Script>& scripts) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n-  // TODO(kozyatinskiy): remove this GC once tests are dealt with.\n-  isolate->heap()->CollectAllGarbage(i::Heap::kMakeHeapIterableMask,\n-                                     i::GarbageCollectionReason::kDebugger);\n   {\n     i::DisallowHeapAllocation no_gc;\n     i::Script::Iterator iterator(isolate);\n@@ -10913,7 +10687,7 @@ void InvokeAccessorGetterCallback(\n   // Leaving JavaScript.\n   Isolate* isolate = reinterpret_cast<Isolate*>(info.GetIsolate());\n   RuntimeCallTimerScope timer(isolate,\n-                              &RuntimeCallStats::AccessorGetterCallback);\n+                              RuntimeCallCounterId::kAccessorGetterCallback);\n   Address getter_address = reinterpret_cast<Address>(reinterpret_cast<intptr_t>(\n       getter));\n   VMState<EXTERNAL> state(isolate);\n@@ -10926,14 +10700,33 @@ void InvokeFunctionCallback(const v8::FunctionCallbackInfo<v8::Value>& info,\n                             v8::FunctionCallback callback) {\n   Isolate* isolate = reinterpret_cast<Isolate*>(info.GetIsolate());\n   RuntimeCallTimerScope timer(isolate,\n-                              &RuntimeCallStats::InvokeFunctionCallback);\n+                              RuntimeCallCounterId::kInvokeFunctionCallback);\n   Address callback_address =\n       reinterpret_cast<Address>(reinterpret_cast<intptr_t>(callback));\n   VMState<EXTERNAL> state(isolate);\n   ExternalCallbackScope call_scope(isolate, callback_address);\n   callback(info);\n }\n \n+// Undefine macros for jumbo build.\n+#undef LOG_API\n+#undef ENTER_V8_DO_NOT_USE\n+#undef ENTER_V8_HELPER_DO_NOT_USE\n+#undef PREPARE_FOR_DEBUG_INTERFACE_EXECUTION_WITH_ISOLATE\n+#undef PREPARE_FOR_EXECUTION_WITH_CONTEXT\n+#undef PREPARE_FOR_EXECUTION\n+#undef ENTER_V8\n+#undef ENTER_V8_NO_SCRIPT\n+#undef ENTER_V8_NO_SCRIPT_NO_EXCEPTION\n+#undef ENTER_V8_FOR_NEW_CONTEXT\n+#undef EXCEPTION_BAILOUT_CHECK_SCOPED_DO_NOT_USE\n+#undef RETURN_ON_FAILED_EXECUTION\n+#undef RETURN_ON_FAILED_EXECUTION_PRIMITIVE\n+#undef RETURN_TO_LOCAL_UNCHECKED\n+#undef RETURN_ESCAPED\n+#undef SET_FIELD_WRAPPED\n+#undef NEW_STRING\n+#undef CALLBACK_SETTER\n \n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "7bd03c37dab0f2cd65c51c02180d3df95a664b35",
            "filename": "deps/v8/src/api.h",
            "status": "modified",
            "additions": 23,
            "deletions": 1,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fapi.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -11,6 +11,7 @@\n #include \"src/detachable-vector.h\"\n #include \"src/factory.h\"\n #include \"src/isolate.h\"\n+#include \"src/objects/js-collection.h\"\n \n namespace v8 {\n \n@@ -404,6 +405,7 @@ class HandleScopeImplementer {\n         call_depth_(0),\n         microtasks_depth_(0),\n         microtasks_suppressions_(0),\n+        entered_contexts_count_(0),\n         entered_context_count_during_microtasks_(0),\n #ifdef DEBUG\n         debug_microtasks_depth_(0),\n@@ -530,6 +532,7 @@ class HandleScopeImplementer {\n   int call_depth_;\n   int microtasks_depth_;\n   int microtasks_suppressions_;\n+  size_t entered_contexts_count_;\n   size_t entered_context_count_during_microtasks_;\n #ifdef DEBUG\n   int debug_microtasks_depth_;\n@@ -545,10 +548,25 @@ class HandleScopeImplementer {\n \n   friend class DeferredHandles;\n   friend class DeferredHandleScope;\n+  friend class HandleScopeImplementerOffsets;\n \n   DISALLOW_COPY_AND_ASSIGN(HandleScopeImplementer);\n };\n \n+class HandleScopeImplementerOffsets {\n+ public:\n+  enum Offsets {\n+    kMicrotaskContext = offsetof(HandleScopeImplementer, microtask_context_),\n+    kEnteredContexts = offsetof(HandleScopeImplementer, entered_contexts_),\n+    kEnteredContextsCount =\n+        offsetof(HandleScopeImplementer, entered_contexts_count_),\n+    kEnteredContextCountDuringMicrotasks = offsetof(\n+        HandleScopeImplementer, entered_context_count_during_microtasks_)\n+  };\n+\n+ private:\n+  DISALLOW_IMPLICIT_CONSTRUCTORS(HandleScopeImplementerOffsets);\n+};\n \n const int kHandleBlockSize = v8::internal::KB - 2;  // fit in one page\n \n@@ -583,9 +601,13 @@ bool HandleScopeImplementer::HasSavedContexts() {\n \n void HandleScopeImplementer::EnterContext(Handle<Context> context) {\n   entered_contexts_.push_back(*context);\n+  entered_contexts_count_ = entered_contexts_.size();\n }\n \n-void HandleScopeImplementer::LeaveContext() { entered_contexts_.pop_back(); }\n+void HandleScopeImplementer::LeaveContext() {\n+  entered_contexts_.pop_back();\n+  entered_contexts_count_ = entered_contexts_.size();\n+}\n \n bool HandleScopeImplementer::LastEnteredContextWas(Handle<Context> context) {\n   return !entered_contexts_.empty() && entered_contexts_.back() == *context;"
        },
        {
            "sha": "d01e77314a8b883bbe2dba0142fc16e3ba8f730f",
            "filename": "deps/v8/src/arguments.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farguments.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farguments.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farguments.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -85,7 +85,7 @@ double ClobberDoubleRegisters(double x1, double x2, double x3, double x4);\n                                                                               \\\n   V8_NOINLINE static Type Stats_##Name(int args_length, Object** args_object, \\\n                                        Isolate* isolate) {                    \\\n-    RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::Name);            \\\n+    RuntimeCallTimerScope timer(isolate, RuntimeCallCounterId::k##Name);      \\\n     TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.runtime\"),                     \\\n                  \"V8.Runtime_\" #Name);                                        \\\n     Arguments args(args_length, args_object);                                 \\"
        },
        {
            "sha": "f420f2e5cb1592f35170ad47dcce4caa9a886aaf",
            "filename": "deps/v8/src/arm/assembler-arm-inl.h",
            "status": "modified",
            "additions": 9,
            "deletions": 21,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm-inl.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -68,7 +68,7 @@ void RelocInfo::apply(intptr_t delta) {\n \n Address RelocInfo::target_address() {\n   DCHECK(IsCodeTarget(rmode_) || IsRuntimeEntry(rmode_) || IsWasmCall(rmode_));\n-  return Assembler::target_address_at(pc_, host_);\n+  return Assembler::target_address_at(pc_, constant_pool_);\n }\n \n Address RelocInfo::target_address_address() {\n@@ -85,7 +85,7 @@ Address RelocInfo::target_address_address() {\n \n Address RelocInfo::constant_pool_entry_address() {\n   DCHECK(IsInConstantPool());\n-  return Assembler::constant_pool_entry_address(pc_, host_->constant_pool());\n+  return Assembler::constant_pool_entry_address(pc_, constant_pool_);\n }\n \n \n@@ -95,21 +95,21 @@ int RelocInfo::target_address_size() {\n \n HeapObject* RelocInfo::target_object() {\n   DCHECK(IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT);\n-  return HeapObject::cast(\n-      reinterpret_cast<Object*>(Assembler::target_address_at(pc_, host_)));\n+  return HeapObject::cast(reinterpret_cast<Object*>(\n+      Assembler::target_address_at(pc_, constant_pool_)));\n }\n \n Handle<HeapObject> RelocInfo::target_object_handle(Assembler* origin) {\n   DCHECK(IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT);\n-  return Handle<HeapObject>(\n-      reinterpret_cast<HeapObject**>(Assembler::target_address_at(pc_, host_)));\n+  return Handle<HeapObject>(reinterpret_cast<HeapObject**>(\n+      Assembler::target_address_at(pc_, constant_pool_)));\n }\n \n void RelocInfo::set_target_object(HeapObject* target,\n                                   WriteBarrierMode write_barrier_mode,\n                                   ICacheFlushMode icache_flush_mode) {\n   DCHECK(IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT);\n-  Assembler::set_target_address_at(target->GetIsolate(), pc_, host_,\n+  Assembler::set_target_address_at(target->GetIsolate(), pc_, constant_pool_,\n                                    reinterpret_cast<Address>(target),\n                                    icache_flush_mode);\n   if (write_barrier_mode == UPDATE_WRITE_BARRIER && host() != nullptr) {\n@@ -122,7 +122,7 @@ void RelocInfo::set_target_object(HeapObject* target,\n \n Address RelocInfo::target_external_reference() {\n   DCHECK(rmode_ == EXTERNAL_REFERENCE);\n-  return Assembler::target_address_at(pc_, host_);\n+  return Assembler::target_address_at(pc_, constant_pool_);\n }\n \n \n@@ -158,7 +158,7 @@ void RelocInfo::WipeOut(Isolate* isolate) {\n   if (IsInternalReference(rmode_)) {\n     Memory::Address_at(pc_) = nullptr;\n   } else {\n-    Assembler::set_target_address_at(isolate, pc_, host_, nullptr);\n+    Assembler::set_target_address_at(isolate, pc_, constant_pool_, nullptr);\n   }\n }\n \n@@ -382,18 +382,6 @@ void Assembler::set_target_address_at(Isolate* isolate, Address pc,\n   }\n }\n \n-Address Assembler::target_address_at(Address pc, Code* code) {\n-  Address constant_pool = code ? code->constant_pool() : nullptr;\n-  return target_address_at(pc, constant_pool);\n-}\n-\n-void Assembler::set_target_address_at(Isolate* isolate, Address pc, Code* code,\n-                                      Address target,\n-                                      ICacheFlushMode icache_flush_mode) {\n-  Address constant_pool = code ? code->constant_pool() : nullptr;\n-  set_target_address_at(isolate, pc, constant_pool, target, icache_flush_mode);\n-}\n-\n EnsureSpace::EnsureSpace(Assembler* assembler) { assembler->CheckBuffer(); }\n \n }  // namespace internal"
        },
        {
            "sha": "a615d6749679d068c4ac29ace9c5075ae1d531e2",
            "filename": "deps/v8/src/arm/assembler-arm.cc",
            "status": "modified",
            "additions": 73,
            "deletions": 57,
            "changes": 130,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -72,7 +72,7 @@ static unsigned CpuFeaturesFromCommandLine() {\n             \"                       armv7+sudiv\\n\"\n             \"                       armv7\\n\"\n             \"                       armv6\\n\");\n-    CHECK(false);\n+    FATAL(\"arm-arch\");\n   }\n \n   // If any of the old (deprecated) flags are specified, print a warning, but\n@@ -339,21 +339,23 @@ bool RelocInfo::IsInConstantPool() {\n }\n \n Address RelocInfo::embedded_address() const {\n-  return Assembler::target_address_at(pc_, host_);\n+  return Assembler::target_address_at(pc_, constant_pool_);\n }\n \n uint32_t RelocInfo::embedded_size() const {\n-  return reinterpret_cast<uint32_t>(Assembler::target_address_at(pc_, host_));\n+  return reinterpret_cast<uint32_t>(\n+      Assembler::target_address_at(pc_, constant_pool_));\n }\n \n void RelocInfo::set_embedded_address(Isolate* isolate, Address address,\n                                      ICacheFlushMode flush_mode) {\n-  Assembler::set_target_address_at(isolate, pc_, host_, address, flush_mode);\n+  Assembler::set_target_address_at(isolate, pc_, constant_pool_, address,\n+                                   flush_mode);\n }\n \n void RelocInfo::set_embedded_size(Isolate* isolate, uint32_t size,\n                                   ICacheFlushMode flush_mode) {\n-  Assembler::set_target_address_at(isolate, pc_, host_,\n+  Assembler::set_target_address_at(isolate, pc_, constant_pool_,\n                                    reinterpret_cast<Address>(size), flush_mode);\n }\n \n@@ -474,7 +476,6 @@ void NeonMemOperand::SetAlignment(int align) {\n       break;\n     default:\n       UNREACHABLE();\n-      align_ = 0;\n       break;\n   }\n }\n@@ -519,31 +520,31 @@ const Instr kBlxRegMask =\n const Instr kBlxRegPattern =\n     B24 | B21 | 15 * B16 | 15 * B12 | 15 * B8 | BLX;\n const Instr kBlxIp = al | kBlxRegPattern | ip.code();\n-const Instr kMovMvnMask = 0x6d * B21 | 0xf * B16;\n-const Instr kMovMvnPattern = 0xd * B21;\n+const Instr kMovMvnMask = 0x6D * B21 | 0xF * B16;\n+const Instr kMovMvnPattern = 0xD * B21;\n const Instr kMovMvnFlip = B22;\n-const Instr kMovLeaveCCMask = 0xdff * B16;\n-const Instr kMovLeaveCCPattern = 0x1a0 * B16;\n+const Instr kMovLeaveCCMask = 0xDFF * B16;\n+const Instr kMovLeaveCCPattern = 0x1A0 * B16;\n const Instr kMovwPattern = 0x30 * B20;\n const Instr kMovtPattern = 0x34 * B20;\n const Instr kMovwLeaveCCFlip = 0x5 * B21;\n-const Instr kMovImmedMask = 0x7f * B21;\n-const Instr kMovImmedPattern = 0x1d * B21;\n-const Instr kOrrImmedMask = 0x7f * B21;\n-const Instr kOrrImmedPattern = 0x1c * B21;\n-const Instr kCmpCmnMask = 0xdd * B20 | 0xf * B12;\n+const Instr kMovImmedMask = 0x7F * B21;\n+const Instr kMovImmedPattern = 0x1D * B21;\n+const Instr kOrrImmedMask = 0x7F * B21;\n+const Instr kOrrImmedPattern = 0x1C * B21;\n+const Instr kCmpCmnMask = 0xDD * B20 | 0xF * B12;\n const Instr kCmpCmnPattern = 0x15 * B20;\n const Instr kCmpCmnFlip = B21;\n const Instr kAddSubFlip = 0x6 * B21;\n-const Instr kAndBicFlip = 0xe * B21;\n+const Instr kAndBicFlip = 0xE * B21;\n \n // A mask for the Rd register for push, pop, ldr, str instructions.\n const Instr kLdrRegFpOffsetPattern = al | B26 | L | Offset | fp.code() * B16;\n const Instr kStrRegFpOffsetPattern = al | B26 | Offset | fp.code() * B16;\n const Instr kLdrRegFpNegOffsetPattern =\n     al | B26 | L | NegOffset | fp.code() * B16;\n const Instr kStrRegFpNegOffsetPattern = al | B26 | NegOffset | fp.code() * B16;\n-const Instr kLdrStrInstrTypeMask = 0xffff0000;\n+const Instr kLdrStrInstrTypeMask = 0xFFFF0000;\n \n Assembler::Assembler(IsolateData isolate_data, void* buffer, int buffer_size)\n     : AssemblerBase(isolate_data, buffer, buffer_size),\n@@ -1046,7 +1047,7 @@ bool FitsShifter(uint32_t imm32, uint32_t* rotate_imm, uint32_t* immed_8,\n   // imm32 must be unsigned.\n   for (int rot = 0; rot < 16; rot++) {\n     uint32_t imm8 = base::bits::RotateLeft32(imm32, 2 * rot);\n-    if ((imm8 <= 0xff)) {\n+    if ((imm8 <= 0xFF)) {\n       *rotate_imm = rot;\n       *immed_8 = imm8;\n       return true;\n@@ -1172,7 +1173,7 @@ void Assembler::Move32BitImmediate(Register rd, const Operand& x,\n     if (CpuFeatures::IsSupported(ARMv7)) {\n       uint32_t imm32 = static_cast<uint32_t>(x.immediate());\n       CpuFeatureScope scope(this, ARMv7);\n-      movw(target, imm32 & 0xffff, cond);\n+      movw(target, imm32 & 0xFFFF, cond);\n       movt(target, imm32 >> 16, cond);\n     }\n     if (target.code() != rd.code()) {\n@@ -1187,7 +1188,7 @@ void Assembler::Move32BitImmediate(Register rd, const Operand& x,\n       immediate = x.immediate();\n     }\n     ConstantPoolAddEntry(pc_offset(), x.rmode_, immediate);\n-    ldr(rd, MemOperand(pc, 0), cond);\n+    ldr_pcrel(rd, 0, cond);\n   }\n }\n \n@@ -1234,7 +1235,7 @@ void Assembler::AddrMode1(Instr instr, Register rd, Register rn,\n         // This means that finding the even number of trailing zeroes of the\n         // immediate allows us to more efficiently split it:\n         int trailing_zeroes = base::bits::CountTrailingZeros(imm) & ~1u;\n-        uint32_t mask = (0xff << trailing_zeroes);\n+        uint32_t mask = (0xFF << trailing_zeroes);\n         add(rd, rd, Operand(imm & mask), LeaveCC, cond);\n         imm = imm & ~mask;\n       } while (!ImmediateFitsAddrMode1Instruction(imm));\n@@ -1294,6 +1295,9 @@ bool Assembler::AddrMode1TryEncodeOperand(Instr* instr, const Operand& x) {\n \n void Assembler::AddrMode2(Instr instr, Register rd, const MemOperand& x) {\n   DCHECK((instr & ~(kCondMask | B | L)) == B26);\n+  // This method does not handle pc-relative addresses. ldr_pcrel() should be\n+  // used instead.\n+  DCHECK(x.rn_ != pc);\n   int am = x.am_;\n   if (!x.rm_.is_valid()) {\n     // Immediate offset.\n@@ -1331,6 +1335,9 @@ void Assembler::AddrMode2(Instr instr, Register rd, const MemOperand& x) {\n void Assembler::AddrMode3(Instr instr, Register rd, const MemOperand& x) {\n   DCHECK((instr & ~(kCondMask | L | S6 | H)) == (B4 | B7));\n   DCHECK(x.rn_.is_valid());\n+  // This method does not handle pc-relative addresses. ldr_pcrel() should be\n+  // used instead.\n+  DCHECK(x.rn_ != pc);\n   int am = x.am_;\n   bool is_load = (instr & L) == L;\n   if (!x.rm_.is_valid()) {\n@@ -1353,7 +1360,7 @@ void Assembler::AddrMode3(Instr instr, Register rd, const MemOperand& x) {\n       return;\n     }\n     DCHECK_GE(offset_8, 0);  // no masking needed\n-    instr |= B | (offset_8 >> 4)*B8 | (offset_8 & 0xf);\n+    instr |= B | (offset_8 >> 4) * B8 | (offset_8 & 0xF);\n   } else if (x.shift_imm_ != 0) {\n     // Scaled register offsets are not supported, compute the offset separately\n     // to a scratch register.\n@@ -1709,16 +1716,16 @@ void Assembler::sdiv(Register dst, Register src1, Register src2,\n                      Condition cond) {\n   DCHECK(dst != pc && src1 != pc && src2 != pc);\n   DCHECK(IsEnabled(SUDIV));\n-  emit(cond | B26 | B25| B24 | B20 | dst.code()*B16 | 0xf * B12 |\n-       src2.code()*B8 | B4 | src1.code());\n+  emit(cond | B26 | B25 | B24 | B20 | dst.code() * B16 | 0xF * B12 |\n+       src2.code() * B8 | B4 | src1.code());\n }\n \n \n void Assembler::udiv(Register dst, Register src1, Register src2,\n                      Condition cond) {\n   DCHECK(dst != pc && src1 != pc && src2 != pc);\n   DCHECK(IsEnabled(SUDIV));\n-  emit(cond | B26 | B25 | B24 | B21 | B20 | dst.code() * B16 | 0xf * B12 |\n+  emit(cond | B26 | B25 | B24 | B21 | B20 | dst.code() * B16 | 0xF * B12 |\n        src2.code() * B8 | B4 | src1.code());\n }\n \n@@ -1742,7 +1749,7 @@ void Assembler::smmla(Register dst, Register src1, Register src2, Register srcA,\n void Assembler::smmul(Register dst, Register src1, Register src2,\n                       Condition cond) {\n   DCHECK(dst != pc && src1 != pc && src2 != pc);\n-  emit(cond | B26 | B25 | B24 | B22 | B20 | dst.code() * B16 | 0xf * B12 |\n+  emit(cond | B26 | B25 | B24 | B22 | B20 | dst.code() * B16 | 0xF * B12 |\n        src2.code() * B8 | B4 | src1.code());\n }\n \n@@ -1824,8 +1831,8 @@ void Assembler::usat(Register dst,\n       sh = 1;\n   }\n \n-  emit(cond | 0x6*B24 | 0xe*B20 | satpos*B16 | dst.code()*B12 |\n-       src.shift_imm_*B7 | sh*B6 | 0x1*B4 | src.rm_.code());\n+  emit(cond | 0x6 * B24 | 0xE * B20 | satpos * B16 | dst.code() * B12 |\n+       src.shift_imm_ * B7 | sh * B6 | 0x1 * B4 | src.rm_.code());\n }\n \n \n@@ -1844,8 +1851,8 @@ void Assembler::ubfx(Register dst,\n   DCHECK(dst != pc && src != pc);\n   DCHECK((lsb >= 0) && (lsb <= 31));\n   DCHECK((width >= 1) && (width <= (32 - lsb)));\n-  emit(cond | 0xf*B23 | B22 | B21 | (width - 1)*B16 | dst.code()*B12 |\n-       lsb*B7 | B6 | B4 | src.code());\n+  emit(cond | 0xF * B23 | B22 | B21 | (width - 1) * B16 | dst.code() * B12 |\n+       lsb * B7 | B6 | B4 | src.code());\n }\n \n \n@@ -1863,8 +1870,8 @@ void Assembler::sbfx(Register dst,\n   DCHECK(dst != pc && src != pc);\n   DCHECK((lsb >= 0) && (lsb <= 31));\n   DCHECK((width >= 1) && (width <= (32 - lsb)));\n-  emit(cond | 0xf*B23 | B21 | (width - 1)*B16 | dst.code()*B12 |\n-       lsb*B7 | B6 | B4 | src.code());\n+  emit(cond | 0xF * B23 | B21 | (width - 1) * B16 | dst.code() * B12 |\n+       lsb * B7 | B6 | B4 | src.code());\n }\n \n \n@@ -1878,7 +1885,7 @@ void Assembler::bfc(Register dst, int lsb, int width, Condition cond) {\n   DCHECK((lsb >= 0) && (lsb <= 31));\n   DCHECK((width >= 1) && (width <= (32 - lsb)));\n   int msb = lsb + width - 1;\n-  emit(cond | 0x1f*B22 | msb*B16 | dst.code()*B12 | lsb*B7 | B4 | 0xf);\n+  emit(cond | 0x1F * B22 | msb * B16 | dst.code() * B12 | lsb * B7 | B4 | 0xF);\n }\n \n \n@@ -1896,7 +1903,7 @@ void Assembler::bfi(Register dst,\n   DCHECK((lsb >= 0) && (lsb <= 31));\n   DCHECK((width >= 1) && (width <= (32 - lsb)));\n   int msb = lsb + width - 1;\n-  emit(cond | 0x1f*B22 | msb*B16 | dst.code()*B12 | lsb*B7 | B4 |\n+  emit(cond | 0x1F * B22 | msb * B16 | dst.code() * B12 | lsb * B7 | B4 |\n        src.code());\n }\n \n@@ -2073,8 +2080,8 @@ void Assembler::mrs(Register dst, SRegister s, Condition cond) {\n \n void Assembler::msr(SRegisterFieldMask fields, const Operand& src,\n                     Condition cond) {\n-  DCHECK_NE(fields & 0x000f0000, 0);  // At least one field must be set.\n-  DCHECK(((fields & 0xfff0ffff) == CPSR) || ((fields & 0xfff0ffff) == SPSR));\n+  DCHECK_NE(fields & 0x000F0000, 0);  // At least one field must be set.\n+  DCHECK(((fields & 0xFFF0FFFF) == CPSR) || ((fields & 0xFFF0FFFF) == SPSR));\n   Instr instr;\n   if (src.IsImmediate()) {\n     // Immediate.\n@@ -2159,13 +2166,23 @@ void Assembler::strd(Register src1, Register src2,\n   AddrMode3(cond | B7 | B6 | B5 | B4, src1, dst);\n }\n \n+void Assembler::ldr_pcrel(Register dst, int imm12, Condition cond) {\n+  AddrMode am = Offset;\n+  if (imm12 < 0) {\n+    imm12 = -imm12;\n+    am = NegOffset;\n+  }\n+  DCHECK(is_uint12(imm12));\n+  emit(cond | B26 | am | L | pc.code() * B16 | dst.code() * B12 | imm12);\n+}\n+\n // Load/Store exclusive instructions.\n void Assembler::ldrex(Register dst, Register src, Condition cond) {\n   // Instruction details available in ARM DDI 0406C.b, A8.8.75.\n   // cond(31-28) | 00011001(27-20) | Rn(19-16) | Rt(15-12) | 111110011111(11-0)\n   DCHECK(dst != pc);\n   DCHECK(src != pc);\n-  emit(cond | B24 | B23 | B20 | src.code() * B16 | dst.code() * B12 | 0xf9f);\n+  emit(cond | B24 | B23 | B20 | src.code() * B16 | dst.code() * B12 | 0xF9F);\n }\n \n void Assembler::strex(Register src1, Register src2, Register dst,\n@@ -2178,7 +2195,7 @@ void Assembler::strex(Register src1, Register src2, Register dst,\n   DCHECK(src2 != pc);\n   DCHECK(src1 != dst);\n   DCHECK(src1 != src2);\n-  emit(cond | B24 | B23 | dst.code() * B16 | src1.code() * B12 | 0xf9 * B4 |\n+  emit(cond | B24 | B23 | dst.code() * B16 | src1.code() * B12 | 0xF9 * B4 |\n        src2.code());\n }\n \n@@ -2188,7 +2205,7 @@ void Assembler::ldrexb(Register dst, Register src, Condition cond) {\n   DCHECK(dst != pc);\n   DCHECK(src != pc);\n   emit(cond | B24 | B23 | B22 | B20 | src.code() * B16 | dst.code() * B12 |\n-       0xf9f);\n+       0xF9F);\n }\n \n void Assembler::strexb(Register src1, Register src2, Register dst,\n@@ -2202,7 +2219,7 @@ void Assembler::strexb(Register src1, Register src2, Register dst,\n   DCHECK(src1 != dst);\n   DCHECK(src1 != src2);\n   emit(cond | B24 | B23 | B22 | dst.code() * B16 | src1.code() * B12 |\n-       0xf9 * B4 | src2.code());\n+       0xF9 * B4 | src2.code());\n }\n \n void Assembler::ldrexh(Register dst, Register src, Condition cond) {\n@@ -2211,7 +2228,7 @@ void Assembler::ldrexh(Register dst, Register src, Condition cond) {\n   DCHECK(dst != pc);\n   DCHECK(src != pc);\n   emit(cond | B24 | B23 | B22 | B21 | B20 | src.code() * B16 |\n-       dst.code() * B12 | 0xf9f);\n+       dst.code() * B12 | 0xF9F);\n }\n \n void Assembler::strexh(Register src1, Register src2, Register dst,\n@@ -2225,7 +2242,7 @@ void Assembler::strexh(Register src1, Register src2, Register dst,\n   DCHECK(src1 != dst);\n   DCHECK(src1 != src2);\n   emit(cond | B24 | B23 | B22 | B21 | dst.code() * B16 | src1.code() * B12 |\n-       0xf9 * B4 | src2.code());\n+       0xF9 * B4 | src2.code());\n }\n \n // Preload instructions.\n@@ -2242,8 +2259,8 @@ void Assembler::pld(const MemOperand& address) {\n     U = 0;\n   }\n   DCHECK_LT(offset, 4096);\n-  emit(kSpecialCondition | B26 | B24 | U | B22 | B20 | address.rn().code()*B16 |\n-       0xf*B12 | offset);\n+  emit(kSpecialCondition | B26 | B24 | U | B22 | B20 |\n+       address.rn().code() * B16 | 0xF * B12 | offset);\n }\n \n \n@@ -2305,7 +2322,7 @@ void Assembler::stop(const char* msg, Condition cond, int32_t code) {\n \n void Assembler::bkpt(uint32_t imm16) {\n   DCHECK(is_uint16(imm16));\n-  emit(al | B24 | B21 | (imm16 >> 4)*B8 | BKPT | (imm16 & 0xf));\n+  emit(al | B24 | B21 | (imm16 >> 4) * B8 | BKPT | (imm16 & 0xF));\n }\n \n \n@@ -2318,7 +2335,7 @@ void Assembler::svc(uint32_t imm24, Condition cond) {\n void Assembler::dmb(BarrierOption option) {\n   if (CpuFeatures::IsSupported(ARMv7)) {\n     // Details available in ARM DDI 0406C.b, A8-378.\n-    emit(kSpecialCondition | 0x57ff * B12 | 5 * B4 | option);\n+    emit(kSpecialCondition | 0x57FF * B12 | 5 * B4 | option);\n   } else {\n     // Details available in ARM DDI 0406C.b, B3-1750.\n     // CP15DMB: CRn=c7, opc1=0, CRm=c10, opc2=5, Rt is ignored.\n@@ -2330,7 +2347,7 @@ void Assembler::dmb(BarrierOption option) {\n void Assembler::dsb(BarrierOption option) {\n   if (CpuFeatures::IsSupported(ARMv7)) {\n     // Details available in ARM DDI 0406C.b, A8-380.\n-    emit(kSpecialCondition | 0x57ff * B12 | 4 * B4 | option);\n+    emit(kSpecialCondition | 0x57FF * B12 | 4 * B4 | option);\n   } else {\n     // Details available in ARM DDI 0406C.b, B3-1750.\n     // CP15DSB: CRn=c7, opc1=0, CRm=c10, opc2=4, Rt is ignored.\n@@ -2342,7 +2359,7 @@ void Assembler::dsb(BarrierOption option) {\n void Assembler::isb(BarrierOption option) {\n   if (CpuFeatures::IsSupported(ARMv7)) {\n     // Details available in ARM DDI 0406C.b, A8-389.\n-    emit(kSpecialCondition | 0x57ff * B12 | 6 * B4 | option);\n+    emit(kSpecialCondition | 0x57FF * B12 | 6 * B4 | option);\n   } else {\n     // Details available in ARM DDI 0406C.b, B3-1750.\n     // CP15ISB: CRn=c7, opc1=0, CRm=c5, opc2=4, Rt is ignored.\n@@ -2728,7 +2745,7 @@ void Assembler::vstm(BlockAddrMode am, Register base, SwVfpRegister first,\n static void DoubleAsTwoUInt32(Double d, uint32_t* lo, uint32_t* hi) {\n   uint64_t i = d.AsUint64();\n \n-  *lo = i & 0xffffffff;\n+  *lo = i & 0xFFFFFFFF;\n   *hi = i >> 32;\n }\n \n@@ -2757,12 +2774,12 @@ static bool FitsVmovFPImmediate(Double d, uint32_t* encoding) {\n   DoubleAsTwoUInt32(d, &lo, &hi);\n \n   // The most obvious constraint is the long block of zeroes.\n-  if ((lo != 0) || ((hi & 0xffff) != 0)) {\n+  if ((lo != 0) || ((hi & 0xFFFF) != 0)) {\n     return false;\n   }\n \n   // Bits 61:54 must be all clear or all set.\n-  if (((hi & 0x3fc00000) != 0) && ((hi & 0x3fc00000) != 0x3fc00000)) {\n+  if (((hi & 0x3FC00000) != 0) && ((hi & 0x3FC00000) != 0x3FC00000)) {\n     return false;\n   }\n \n@@ -2773,7 +2790,7 @@ static bool FitsVmovFPImmediate(Double d, uint32_t* encoding) {\n \n   // Create the encoded immediate in the form:\n   //  [00000000,0000abcd,00000000,0000efgh]\n-  *encoding  = (hi >> 16) & 0xf;      // Low nybble.\n+  *encoding = (hi >> 16) & 0xF;       // Low nybble.\n   *encoding |= (hi >> 4) & 0x70000;   // Low three bits of the high nybble.\n   *encoding |= (hi >> 12) & 0x80000;  // Top bit of the high nybble.\n \n@@ -2852,8 +2869,7 @@ void Assembler::vmov(const DwVfpRegister dst, Double imm,\n       // We only have one spare scratch register.\n       mov(scratch, Operand(lo));\n       vmov(dst, VmovIndexLo, scratch);\n-      if (((lo & 0xffff) == (hi & 0xffff)) &&\n-          CpuFeatures::IsSupported(ARMv7)) {\n+      if (((lo & 0xFFFF) == (hi & 0xFFFF)) && CpuFeatures::IsSupported(ARMv7)) {\n         CpuFeatureScope scope(this, ARMv7);\n         movt(scratch, hi >> 16);\n       } else {\n@@ -3193,7 +3209,7 @@ void Assembler::vcvt_f64_s32(const DwVfpRegister dst,\n   dst.split_code(&vd, &d);\n   int imm5 = 32 - fraction_bits;\n   int i = imm5 & 1;\n-  int imm4 = (imm5 >> 1) & 0xf;\n+  int imm4 = (imm5 >> 1) & 0xF;\n   emit(cond | 0xE*B24 | B23 | d*B22 | 0x3*B20 | B19 | 0x2*B16 |\n        vd*B12 | 0x5*B9 | B8 | B7 | B6 | i*B5 | imm4);\n }\n@@ -4973,12 +4989,12 @@ Instr Assembler::GetMovWPattern() { return kMovwPattern; }\n \n Instr Assembler::EncodeMovwImmediate(uint32_t immediate) {\n   DCHECK_LT(immediate, 0x10000);\n-  return ((immediate & 0xf000) << 4) | (immediate & 0xfff);\n+  return ((immediate & 0xF000) << 4) | (immediate & 0xFFF);\n }\n \n \n Instr Assembler::PatchMovwImmediate(Instr instruction, uint32_t immediate) {\n-  instruction &= ~EncodeMovwImmediate(0xffff);\n+  instruction &= ~EncodeMovwImmediate(0xFFFF);\n   return instruction | EncodeMovwImmediate(immediate);\n }\n "
        },
        {
            "sha": "8b95aad886a20c60449c43adf2ffadd46fe3e8ed",
            "filename": "deps/v8/src/arm/assembler-arm.h",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -173,6 +173,7 @@ GENERAL_REGISTERS(DECLARE_REGISTER)\n #undef DECLARE_REGISTER\n constexpr Register no_reg = Register::no_reg();\n \n+constexpr bool kPadArguments = false;\n constexpr bool kSimpleFPAliasing = false;\n constexpr bool kSimdMaskRegisters = false;\n \n@@ -652,10 +653,6 @@ class Assembler : public AssemblerBase {\n   INLINE(static void set_target_address_at(\n       Isolate* isolate, Address pc, Address constant_pool, Address target,\n       ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED));\n-  INLINE(static Address target_address_at(Address pc, Code* code));\n-  INLINE(static void set_target_address_at(\n-      Isolate* isolate, Address pc, Code* code, Address target,\n-      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED));\n \n   // Return the code target address at a call site from the return address\n   // of that call in the instruction stream.\n@@ -907,6 +904,9 @@ class Assembler : public AssemblerBase {\n             Register src2,\n             const MemOperand& dst, Condition cond = al);\n \n+  // Load literal from a pc relative address.\n+  void ldr_pcrel(Register dst, int imm12, Condition cond = al);\n+\n   // Load/Store exclusive instructions\n   void ldrex(Register dst, Register src, Condition cond = al);\n   void strex(Register src1, Register src2, Register dst, Condition cond = al);\n@@ -1344,6 +1344,10 @@ class Assembler : public AssemblerBase {\n \n   void pop();\n \n+  void vpush(QwNeonRegister src, Condition cond = al) {\n+    vstm(db_w, sp, src.low(), src.high(), cond);\n+  }\n+\n   void vpush(DwVfpRegister src, Condition cond = al) {\n     vstm(db_w, sp, src, src, cond);\n   }"
        },
        {
            "sha": "ee706c7656e62e101ba46a00f97963cf1846dc9d",
            "filename": "deps/v8/src/arm/code-stubs-arm.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 19,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fcode-stubs-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fcode-stubs-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fcode-stubs-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -83,7 +83,7 @@ void DoubleToIStub::Generate(MacroAssembler* masm) {\n   if (masm->emit_debug_code()) {\n     // Scratch is exponent - 1.\n     __ cmp(scratch, Operand(30 - 1));\n-    __ Check(ge, kUnexpectedValue);\n+    __ Check(ge, AbortReason::kUnexpectedValue);\n   }\n \n   // We don't have to handle cases where 0 <= exponent <= 20 for which we would\n@@ -116,8 +116,8 @@ void DoubleToIStub::Generate(MacroAssembler* masm) {\n   // double_high LSR 31 equals zero.\n   // New result = (result eor 0) + 0 = result.\n   // If the input was negative, we have to negate the result.\n-  // Input_high ASR 31 equals 0xffffffff and double_high LSR 31 equals 1.\n-  // New result = (result eor 0xffffffff) + 1 = 0 - result.\n+  // Input_high ASR 31 equals 0xFFFFFFFF and double_high LSR 31 equals 1.\n+  // New result = (result eor 0xFFFFFFFF) + 1 = 0 - result.\n   __ eor(result_reg, result_reg, Operand(double_high, ASR, 31));\n   __ add(result_reg, result_reg, Operand(double_high, LSR, 31));\n \n@@ -414,6 +414,8 @@ void JSEntryStub::Generate(MacroAssembler* masm) {\n   // Set up the reserved register for 0.0.\n   __ vmov(kDoubleRegZero, Double(0.0));\n \n+  __ InitializeRootRegister();\n+\n   // Get address of argv, see stm above.\n   // r0: code entry\n   // r1: function\n@@ -509,12 +511,7 @@ void JSEntryStub::Generate(MacroAssembler* masm) {\n   // r2: receiver\n   // r3: argc\n   // r4: argv\n-  if (type() == StackFrame::CONSTRUCT_ENTRY) {\n-    __ Call(BUILTIN_CODE(isolate(), JSConstructEntryTrampoline),\n-            RelocInfo::CODE_TARGET);\n-  } else {\n-    __ Call(BUILTIN_CODE(isolate(), JSEntryTrampoline), RelocInfo::CODE_TARGET);\n-  }\n+  __ Call(EntryTrampoline(), RelocInfo::CODE_TARGET);\n \n   // Unlink this frame from the handler chain.\n   __ PopStackHandler();\n@@ -681,7 +678,7 @@ static void CreateArrayDispatch(MacroAssembler* masm,\n     }\n \n     // If we reached this point there is a problem.\n-    __ Abort(kUnexpectedElementsKindInArrayConstructor);\n+    __ Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n   } else {\n     UNREACHABLE();\n   }\n@@ -723,7 +720,7 @@ static void CreateArrayDispatchOneArgument(MacroAssembler* masm,\n     if (FLAG_debug_code) {\n       __ ldr(r5, FieldMemOperand(r2, 0));\n       __ CompareRoot(r5, Heap::kAllocationSiteMapRootIndex);\n-      __ Assert(eq, kExpectedAllocationSite);\n+      __ Assert(eq, AbortReason::kExpectedAllocationSite);\n     }\n \n     // Save the resulting elements kind in type info. We can't just store r3\n@@ -747,7 +744,7 @@ static void CreateArrayDispatchOneArgument(MacroAssembler* masm,\n     }\n \n     // If we reached this point there is a problem.\n-    __ Abort(kUnexpectedElementsKindInArrayConstructor);\n+    __ Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n   } else {\n     UNREACHABLE();\n   }\n@@ -824,9 +821,9 @@ void ArrayConstructorStub::Generate(MacroAssembler* masm) {\n     __ ldr(r4, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n     // Will both indicate a nullptr and a Smi.\n     __ tst(r4, Operand(kSmiTagMask));\n-    __ Assert(ne, kUnexpectedInitialMapForArrayFunction);\n+    __ Assert(ne, AbortReason::kUnexpectedInitialMapForArrayFunction);\n     __ CompareObjectType(r4, r4, r5, MAP_TYPE);\n-    __ Assert(eq, kUnexpectedInitialMapForArrayFunction);\n+    __ Assert(eq, AbortReason::kUnexpectedInitialMapForArrayFunction);\n \n     // We should either have undefined in r2 or a valid AllocationSite\n     __ AssertUndefinedOrAllocationSite(r2, r4);\n@@ -904,9 +901,9 @@ void InternalArrayConstructorStub::Generate(MacroAssembler* masm) {\n     __ ldr(r3, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n     // Will both indicate a nullptr and a Smi.\n     __ tst(r3, Operand(kSmiTagMask));\n-    __ Assert(ne, kUnexpectedInitialMapForArrayFunction);\n+    __ Assert(ne, AbortReason::kUnexpectedInitialMapForArrayFunction);\n     __ CompareObjectType(r3, r3, r4, MAP_TYPE);\n-    __ Assert(eq, kUnexpectedInitialMapForArrayFunction);\n+    __ Assert(eq, AbortReason::kUnexpectedInitialMapForArrayFunction);\n   }\n \n   // Figure out the right elements kind\n@@ -922,8 +919,9 @@ void InternalArrayConstructorStub::Generate(MacroAssembler* masm) {\n     __ cmp(r3, Operand(PACKED_ELEMENTS));\n     __ b(eq, &done);\n     __ cmp(r3, Operand(HOLEY_ELEMENTS));\n-    __ Assert(eq,\n-              kInvalidElementsKindForInternalArrayOrInternalPackedArray);\n+    __ Assert(\n+        eq,\n+        AbortReason::kInvalidElementsKindForInternalArrayOrInternalPackedArray);\n     __ bind(&done);\n   }\n \n@@ -1025,7 +1023,7 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,\n   if (__ emit_debug_code()) {\n     __ ldr(r1, MemOperand(r9, kLevelOffset));\n     __ cmp(r1, r6);\n-    __ Check(eq, kUnexpectedLevelAfterReturnFromApiCall);\n+    __ Check(eq, AbortReason::kUnexpectedLevelAfterReturnFromApiCall);\n   }\n   __ sub(r6, r6, Operand(1));\n   __ str(r6, MemOperand(r9, kLevelOffset));"
        },
        {
            "sha": "9fb2eb4e8dbf43f04851b1cfc6bcfe53fe33f2ff",
            "filename": "deps/v8/src/arm/codegen-arm.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 12,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fcodegen-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fcodegen-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fcodegen-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -24,8 +24,7 @@ MemCopyUint8Function CreateMemCopyUint8Function(Isolate* isolate,\n   return stub;\n #else\n   size_t allocated = 0;\n-  byte* buffer =\n-      AllocateSystemPage(isolate->heap()->GetRandomMmapAddr(), &allocated);\n+  byte* buffer = AllocatePage(isolate->heap()->GetRandomMmapAddr(), &allocated);\n   if (buffer == nullptr) return stub;\n \n   MacroAssembler masm(isolate, buffer, static_cast<int>(allocated),\n@@ -170,8 +169,7 @@ MemCopyUint8Function CreateMemCopyUint8Function(Isolate* isolate,\n   DCHECK(!RelocInfo::RequiresRelocation(isolate, desc));\n \n   Assembler::FlushICache(isolate, buffer, allocated);\n-  CHECK(base::OS::SetPermissions(buffer, allocated,\n-                                 base::OS::MemoryPermission::kReadExecute));\n+  CHECK(SetPermissions(buffer, allocated, PageAllocator::kReadExecute));\n   return FUNCTION_CAST<MemCopyUint8Function>(buffer);\n #endif\n }\n@@ -184,8 +182,7 @@ MemCopyUint16Uint8Function CreateMemCopyUint16Uint8Function(\n   return stub;\n #else\n   size_t allocated = 0;\n-  byte* buffer =\n-      AllocateSystemPage(isolate->heap()->GetRandomMmapAddr(), &allocated);\n+  byte* buffer = AllocatePage(isolate->heap()->GetRandomMmapAddr(), &allocated);\n   if (buffer == nullptr) return stub;\n \n   MacroAssembler masm(isolate, buffer, static_cast<int>(allocated),\n@@ -261,8 +258,7 @@ MemCopyUint16Uint8Function CreateMemCopyUint16Uint8Function(\n   masm.GetCode(isolate, &desc);\n \n   Assembler::FlushICache(isolate, buffer, allocated);\n-  CHECK(base::OS::SetPermissions(buffer, allocated,\n-                                 base::OS::MemoryPermission::kReadExecute));\n+  CHECK(SetPermissions(buffer, allocated, PageAllocator::kReadExecute));\n   return FUNCTION_CAST<MemCopyUint16Uint8Function>(buffer);\n #endif\n }\n@@ -273,8 +269,7 @@ UnaryMathFunctionWithIsolate CreateSqrtFunction(Isolate* isolate) {\n   return nullptr;\n #else\n   size_t allocated = 0;\n-  byte* buffer =\n-      AllocateSystemPage(isolate->heap()->GetRandomMmapAddr(), &allocated);\n+  byte* buffer = AllocatePage(isolate->heap()->GetRandomMmapAddr(), &allocated);\n   if (buffer == nullptr) return nullptr;\n \n   MacroAssembler masm(isolate, buffer, static_cast<int>(allocated),\n@@ -290,8 +285,7 @@ UnaryMathFunctionWithIsolate CreateSqrtFunction(Isolate* isolate) {\n   DCHECK(!RelocInfo::RequiresRelocation(isolate, desc));\n \n   Assembler::FlushICache(isolate, buffer, allocated);\n-  CHECK(base::OS::SetPermissions(buffer, allocated,\n-                                 base::OS::MemoryPermission::kReadExecute));\n+  CHECK(SetPermissions(buffer, allocated, PageAllocator::kReadExecute));\n   return FUNCTION_CAST<UnaryMathFunctionWithIsolate>(buffer);\n #endif\n }"
        },
        {
            "sha": "b50948fc36591465fc97013e0c9abfc22c4280f9",
            "filename": "deps/v8/src/arm/constants-arm.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fconstants-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fconstants-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fconstants-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -20,7 +20,7 @@ Float64 Instruction::DoubleImmedVmov() const {\n   // where B = ~b. Only the high 16 bits are affected.\n   uint64_t high16;\n   high16  = (Bits(17, 16) << 4) | Bits(3, 0);   // xxxxxxxx,xxcdefgh.\n-  high16 |= (0xff * Bit(18)) << 6;              // xxbbbbbb,bbxxxxxx.\n+  high16 |= (0xFF * Bit(18)) << 6;              // xxbbbbbb,bbxxxxxx.\n   high16 |= (Bit(18) ^ 1) << 14;                // xBxxxxxx,xxxxxxxx.\n   high16 |= Bit(19) << 15;                      // axxxxxxx,xxxxxxxx.\n "
        },
        {
            "sha": "1c865afb093ef0284b365226699523aa0e66829f",
            "filename": "deps/v8/src/arm/constants-arm.h",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fconstants-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fconstants-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fconstants-arm.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -34,9 +34,6 @@ inline int DecodeConstantPoolLength(int instr) {\n   return ((instr >> 4) & 0xfff0) | (instr & 0xf);\n }\n \n-// Used in code age prologue - ldr(pc, MemOperand(pc, -4))\n-const int kCodeAgeJumpInstruction = 0xe51ff004;\n-\n // Number of registers in normal ARM mode.\n const int kNumRegisters = 16;\n "
        },
        {
            "sha": "9a21ef862c335c1d3a8e7523687f8691bd95cecc",
            "filename": "deps/v8/src/arm/deoptimizer-arm.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fdeoptimizer-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fdeoptimizer-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fdeoptimizer-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -245,9 +245,9 @@ void Deoptimizer::TableEntryGenerator::GeneratePrologue() {\n   // Note that registers are still live when jumping to an entry.\n \n   // We need to be able to generate immediates up to kMaxNumberOfEntries. On\n-  // ARMv7, we can use movw (with a maximum immediate of 0xffff). On ARMv6, we\n+  // ARMv7, we can use movw (with a maximum immediate of 0xFFFF). On ARMv6, we\n   // need two instructions.\n-  STATIC_ASSERT((kMaxNumberOfEntries - 1) <= 0xffff);\n+  STATIC_ASSERT((kMaxNumberOfEntries - 1) <= 0xFFFF);\n   UseScratchRegisterScope temps(masm());\n   Register scratch = temps.Acquire();\n   if (CpuFeatures::IsSupported(ARMv7)) {\n@@ -263,7 +263,7 @@ void Deoptimizer::TableEntryGenerator::GeneratePrologue() {\n     __ bind(&done);\n   } else {\n     // We want to keep table_entry_size_ == 8 (since this is the common case),\n-    // but we need two instructions to load most immediates over 0xff. To handle\n+    // but we need two instructions to load most immediates over 0xFF. To handle\n     // this, we set the low byte in the main table, and then set the high byte\n     // in a separate table if necessary.\n     Label high_fixes[256];\n@@ -272,7 +272,7 @@ void Deoptimizer::TableEntryGenerator::GeneratePrologue() {\n     for (int i = 0; i < count(); i++) {\n       int start = masm()->pc_offset();\n       USE(start);\n-      __ mov(scratch, Operand(i & 0xff));  // Set the low byte.\n+      __ mov(scratch, Operand(i & 0xFF));  // Set the low byte.\n       __ b(&high_fixes[i >> 8]);      // Jump to the secondary table.\n       DCHECK_EQ(table_entry_size_, masm()->pc_offset() - start);\n     }"
        },
        {
            "sha": "9951136561980afe42bfecdd02ac5b39ad8f5b54",
            "filename": "deps/v8/src/arm/disasm-arm.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 26,
            "changes": 44,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fdisasm-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fdisasm-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fdisasm-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -541,7 +541,7 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {\n       // 'msg: for simulator break instructions\n       DCHECK(STRING_STARTS_WITH(format, \"msg\"));\n       byte* str =\n-          reinterpret_cast<byte*>(instr->InstructionBits() & 0x0fffffff);\n+          reinterpret_cast<byte*>(instr->InstructionBits() & 0x0FFFFFFF);\n       out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,\n                                   \"%s\", converter_.NameInCode(str));\n       return 3;\n@@ -819,7 +819,7 @@ void Decoder::DecodeType01(Instruction* instr) {\n           Unknown(instr);  // not used by V8\n         }\n       }\n-    } else if ((instr->Bit(20) == 0) && ((instr->Bits(7, 4) & 0xd) == 0xd)) {\n+    } else if ((instr->Bit(20) == 0) && ((instr->Bits(7, 4) & 0xD) == 0xD)) {\n       // ldrd, strd\n       switch (instr->PUField()) {\n         case da_x: {\n@@ -905,7 +905,7 @@ void Decoder::DecodeType01(Instruction* instr) {\n     }\n   } else if ((type == 0) && instr->IsMiscType0()) {\n     if ((instr->Bits(27, 23) == 2) && (instr->Bits(21, 20) == 2) &&\n-        (instr->Bits(15, 4) == 0xf00)) {\n+        (instr->Bits(15, 4) == 0xF00)) {\n       Format(instr, \"msr'cond 'spec_reg'spec_reg_fields, 'rm\");\n     } else if ((instr->Bits(27, 23) == 2) && (instr->Bits(21, 20) == 0) &&\n                (instr->Bits(11, 0) == 0)) {\n@@ -1285,8 +1285,8 @@ void Decoder::DecodeType3(Instruction* instr) {\n                 }\n               } else {\n                 // PU == 0b01, BW == 0b11, Bits(9, 6) != 0b0001\n-                if ((instr->Bits(20, 16) == 0x1f) &&\n-                    (instr->Bits(11, 4) == 0xf3)) {\n+                if ((instr->Bits(20, 16) == 0x1F) &&\n+                    (instr->Bits(11, 4) == 0xF3)) {\n                   Format(instr, \"rbit'cond 'rd, 'rm\");\n                 } else {\n                   UNREACHABLE();\n@@ -1561,7 +1561,7 @@ void Decoder::DecodeTypeVFP(Instruction* instr) {\n       const char* rt_name = converter_.NameOfCPURegister(instr->RtValue());\n       if (instr->Bit(23) == 0) {\n         int opc1_opc2 = (instr->Bits(22, 21) << 2) | instr->Bits(6, 5);\n-        if ((opc1_opc2 & 0xb) == 0) {\n+        if ((opc1_opc2 & 0xB) == 0) {\n           // NeonS32/NeonU32\n           if (instr->Bit(21) == 0x0) {\n             Format(instr, \"vmov'cond.32 'Dd[0], 'rt\");\n@@ -1597,7 +1597,7 @@ void Decoder::DecodeTypeVFP(Instruction* instr) {\n       }\n     } else if ((instr->VLValue() == 0x1) && (instr->VCValue() == 0x1)) {\n       int opc1_opc2 = (instr->Bits(22, 21) << 2) | instr->Bits(6, 5);\n-      if ((opc1_opc2 & 0xb) == 0) {\n+      if ((opc1_opc2 & 0xB) == 0) {\n         // NeonS32 / NeonU32\n         if (instr->Bit(21) == 0x0) {\n           Format(instr, \"vmov'cond.32 'rt, 'Dd[0]\");\n@@ -1972,22 +1972,22 @@ void Decoder::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xa: {\n+        case 0xA: {\n           // vpmin/vpmax.s<size> Dd, Dm, Dn.\n           const char* op = instr->Bit(4) == 1 ? \"vpmin\" : \"vpmax\";\n           out_buffer_pos_ +=\n               SNPrintF(out_buffer_ + out_buffer_pos_, \"%s.s%d d%d, d%d, d%d\",\n                        op, size, Vd, Vn, Vm);\n           break;\n         }\n-        case 0xb: {\n+        case 0xB: {\n           // vpadd.i<size> Dd, Dm, Dn.\n           out_buffer_pos_ +=\n               SNPrintF(out_buffer_ + out_buffer_pos_, \"vpadd.i%d d%d, d%d, d%d\",\n                        size, Vd, Vn, Vm);\n           break;\n         }\n-        case 0xd: {\n+        case 0xD: {\n           if (instr->Bit(4) == 0) {\n             const char* op = (instr->Bits(21, 20) == 0) ? \"vadd\" : \"vsub\";\n             // vadd/vsub.f32 Qd, Qm, Qn.\n@@ -1998,7 +1998,7 @@ void Decoder::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xe: {\n+        case 0xE: {\n           if (instr->Bits(21, 20) == 0 && instr->Bit(4) == 0) {\n             // vceq.f32 Qd, Qm, Qn.\n             out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,\n@@ -2008,7 +2008,7 @@ void Decoder::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xf: {\n+        case 0xF: {\n           if (instr->Bit(20) == 0 && instr->Bit(6) == 1) {\n             if (instr->Bit(4) == 1) {\n               // vrecps/vrsqrts.f32 Qd, Qm, Qn.\n@@ -2158,15 +2158,15 @@ void Decoder::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xa: {\n+        case 0xA: {\n           // vpmin/vpmax.u<size> Dd, Dm, Dn.\n           const char* op = instr->Bit(4) == 1 ? \"vpmin\" : \"vpmax\";\n           out_buffer_pos_ +=\n               SNPrintF(out_buffer_ + out_buffer_pos_, \"%s.u%d d%d, d%d, d%d\",\n                        op, size, Vd, Vn, Vm);\n           break;\n         }\n-        case 0xd: {\n+        case 0xD: {\n           if (instr->Bits(21, 20) == 0 && instr->Bit(6) == 1 &&\n               instr->Bit(4) == 1) {\n             // vmul.f32 Qd, Qm, Qn\n@@ -2182,7 +2182,7 @@ void Decoder::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xe: {\n+        case 0xE: {\n           if (instr->Bit(20) == 0 && instr->Bit(4) == 0) {\n             const char* op = (instr->Bit(21) == 0) ? \"vcge\" : \"vcgt\";\n             // vcge/vcgt.f32 Qd, Qm, Qn.\n@@ -2332,12 +2332,12 @@ void Decoder::DecodeSpecialCondition(Instruction* instr) {\n                      instr->Bit(6) == 1) {\n             int size = kBitsPerByte * (1 << instr->Bits(19, 18));\n             char type = instr->Bit(10) != 0 ? 'f' : 's';\n-            if (instr->Bits(9, 6) == 0xd) {\n+            if (instr->Bits(9, 6) == 0xD) {\n               // vabs<type>.<size> Qd, Qm.\n               out_buffer_pos_ +=\n                   SNPrintF(out_buffer_ + out_buffer_pos_, \"vabs.%c%d q%d, q%d\",\n                            type, size, Vd, Vm);\n-            } else if (instr->Bits(9, 6) == 0xf) {\n+            } else if (instr->Bits(9, 6) == 0xF) {\n               // vneg<type>.<size> Qd, Qm.\n               out_buffer_pos_ +=\n                   SNPrintF(out_buffer_ + out_buffer_pos_, \"vneg.%c%d q%d, q%d\",\n@@ -2423,7 +2423,7 @@ void Decoder::DecodeSpecialCondition(Instruction* instr) {\n       break;\n     case 0xA:\n     case 0xB:\n-      if ((instr->Bits(22, 20) == 5) && (instr->Bits(15, 12) == 0xf)) {\n+      if ((instr->Bits(22, 20) == 5) && (instr->Bits(15, 12) == 0xF)) {\n         const char* rn_name = converter_.NameOfCPURegister(instr->Bits(19, 16));\n         int offset = instr->Bits(11, 0);\n         if (offset == 0) {\n@@ -2601,14 +2601,6 @@ int Decoder::InstructionDecode(byte* instr_ptr) {\n                                 \"constant pool begin (length %d)\",\n                                 DecodeConstantPoolLength(instruction_bits));\n     return Instruction::kInstrSize;\n-  } else if (instruction_bits == kCodeAgeJumpInstruction) {\n-    // The code age prologue has a constant immediately following the jump\n-    // instruction.\n-    Instruction* target = Instruction::At(instr_ptr + Instruction::kInstrSize);\n-    DecodeType2(instr);\n-    SNPrintF(out_buffer_ + out_buffer_pos_,\n-             \" (0x%08x)\", target->InstructionBits());\n-    return 2 * Instruction::kInstrSize;\n   }\n   switch (instr->TypeValue()) {\n     case 0:"
        },
        {
            "sha": "6b7498fde523dc80f4c15e41c4b826c41b764beb",
            "filename": "deps/v8/src/arm/interface-descriptors-arm.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Finterface-descriptors-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Finterface-descriptors-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Finterface-descriptors-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -45,8 +45,6 @@ const Register LoadDescriptor::SlotRegister() { return r0; }\n \n const Register LoadWithVectorDescriptor::VectorRegister() { return r3; }\n \n-const Register LoadICProtoArrayDescriptor::HandlerRegister() { return r4; }\n-\n const Register StoreDescriptor::ReceiverRegister() { return r1; }\n const Register StoreDescriptor::NameRegister() { return r2; }\n const Register StoreDescriptor::ValueRegister() { return r0; }\n@@ -204,6 +202,11 @@ void TransitionElementsKindDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n+void AbortJSDescriptor::InitializePlatformSpecific(\n+    CallInterfaceDescriptorData* data) {\n+  Register registers[] = {r1};\n+  data->InitializePlatformSpecific(arraysize(registers), registers);\n+}\n \n void AllocateHeapNumberDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {"
        },
        {
            "sha": "30190d3f34d438af05a4a84c829340dabf0c7c4f",
            "filename": "deps/v8/src/arm/macro-assembler-arm.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 67,
            "changes": 96,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -224,44 +224,6 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,\n   Call(code.address(), rmode, cond, mode);\n }\n \n-void MacroAssembler::CallDeoptimizer(Address target) {\n-  BlockConstPoolScope block_const_pool(this);\n-\n-  uintptr_t target_raw = reinterpret_cast<uintptr_t>(target);\n-\n-  // Use ip directly instead of using UseScratchRegisterScope, as we do not\n-  // preserve scratch registers across calls.\n-\n-  // We use blx, like a call, but it does not return here. The link register is\n-  // used by the deoptimizer to work out what called it.\n-  if (CpuFeatures::IsSupported(ARMv7)) {\n-    CpuFeatureScope scope(this, ARMv7);\n-    movw(ip, target_raw & 0xffff);\n-    movt(ip, (target_raw >> 16) & 0xffff);\n-    blx(ip);\n-  } else {\n-    // We need to load a literal, but we can't use the usual constant pool\n-    // because we call this from a patcher, and cannot afford the guard\n-    // instruction and other administrative overhead.\n-    ldr(ip, MemOperand(pc, (2 * kInstrSize) - kPcLoadDelta));\n-    blx(ip);\n-    dd(target_raw);\n-  }\n-}\n-\n-int MacroAssembler::CallDeoptimizerSize() {\n-  // ARMv7+:\n-  //    movw    ip, ...\n-  //    movt    ip, ...\n-  //    blx     ip              @ This never returns.\n-  //\n-  // ARMv6:\n-  //    ldr     ip, =address\n-  //    blx     ip              @ This never returns.\n-  //    .word   address\n-  return 3 * kInstrSize;\n-}\n-\n void TurboAssembler::Ret(Condition cond) { bx(lr, cond); }\n \n void TurboAssembler::Drop(int count, Condition cond) {\n@@ -608,7 +570,7 @@ void MacroAssembler::RecordWrite(Register object, Register address,\n     Register scratch = temps.Acquire();\n     ldr(scratch, MemOperand(address));\n     cmp(scratch, value);\n-    Check(eq, kWrongAddressOrValuePassedToRecordWrite);\n+    Check(eq, AbortReason::kWrongAddressOrValuePassedToRecordWrite);\n   }\n \n   if (remembered_set_action == OMIT_REMEMBERED_SET &&\n@@ -985,7 +947,7 @@ void TurboAssembler::LslPair(Register dst_low, Register dst_high,\n   rsb(scratch, shift, Operand(32), SetCC);\n   b(gt, &less_than_32);\n   // If shift >= 32\n-  and_(scratch, shift, Operand(0x1f));\n+  and_(scratch, shift, Operand(0x1F));\n   lsl(dst_high, src_low, Operand(scratch));\n   mov(dst_low, Operand(0));\n   jmp(&done);\n@@ -1010,7 +972,7 @@ void TurboAssembler::LslPair(Register dst_low, Register dst_high,\n     Move(dst_high, src_low);\n     Move(dst_low, Operand(0));\n   } else if (shift >= 32) {\n-    shift &= 0x1f;\n+    shift &= 0x1F;\n     lsl(dst_high, src_low, Operand(shift));\n     mov(dst_low, Operand(0));\n   } else {\n@@ -1031,7 +993,7 @@ void TurboAssembler::LsrPair(Register dst_low, Register dst_high,\n   rsb(scratch, shift, Operand(32), SetCC);\n   b(gt, &less_than_32);\n   // If shift >= 32\n-  and_(scratch, shift, Operand(0x1f));\n+  and_(scratch, shift, Operand(0x1F));\n   lsr(dst_low, src_high, Operand(scratch));\n   mov(dst_high, Operand(0));\n   jmp(&done);\n@@ -1054,7 +1016,7 @@ void TurboAssembler::LsrPair(Register dst_low, Register dst_high,\n     mov(dst_low, src_high);\n     mov(dst_high, Operand(0));\n   } else if (shift > 32) {\n-    shift &= 0x1f;\n+    shift &= 0x1F;\n     lsr(dst_low, src_high, Operand(shift));\n     mov(dst_high, Operand(0));\n   } else if (shift == 0) {\n@@ -1078,7 +1040,7 @@ void TurboAssembler::AsrPair(Register dst_low, Register dst_high,\n   rsb(scratch, shift, Operand(32), SetCC);\n   b(gt, &less_than_32);\n   // If shift >= 32\n-  and_(scratch, shift, Operand(0x1f));\n+  and_(scratch, shift, Operand(0x1F));\n   asr(dst_low, src_high, Operand(scratch));\n   asr(dst_high, src_high, Operand(31));\n   jmp(&done);\n@@ -1100,7 +1062,7 @@ void TurboAssembler::AsrPair(Register dst_low, Register dst_high,\n     mov(dst_low, src_high);\n     asr(dst_high, src_high, Operand(31));\n   } else if (shift > 32) {\n-    shift &= 0x1f;\n+    shift &= 0x1F;\n     asr(dst_low, src_high, Operand(shift));\n     asr(dst_high, src_high, Operand(31));\n   } else if (shift == 0) {\n@@ -1218,7 +1180,6 @@ int TurboAssembler::ActivationFrameAlignment() {\n #endif  // V8_HOST_ARCH_ARM\n }\n \n-\n void MacroAssembler::LeaveExitFrame(bool save_doubles, Register argument_count,\n                                     bool argument_count_is_length) {\n   ConstantPoolUnavailableScope constant_pool_unavailable(this);\n@@ -1244,6 +1205,7 @@ void MacroAssembler::LeaveExitFrame(bool save_doubles, Register argument_count,\n       Operand(ExternalReference(IsolateAddressId::kContextAddress, isolate())));\n   ldr(cp, MemOperand(scratch));\n #ifdef DEBUG\n+  mov(r3, Operand(Context::kInvalidContext));\n   mov(scratch,\n       Operand(ExternalReference(IsolateAddressId::kContextAddress, isolate())));\n   str(r3, MemOperand(scratch));\n@@ -1307,7 +1269,7 @@ void TurboAssembler::PrepareForTailCall(const ParameterCount& callee_args_count,\n \n   if (FLAG_debug_code) {\n     cmp(src_reg, dst_reg);\n-    Check(lo, kStackAccessBelowStackPointer);\n+    Check(lo, AbortReason::kStackAccessBelowStackPointer);\n   }\n \n   // Restore caller's frame pointer and return address now as they will be\n@@ -1539,15 +1501,15 @@ void MacroAssembler::MaybeDropFrames() {\n \n void MacroAssembler::PushStackHandler() {\n   // Adjust this code if not the case.\n-  STATIC_ASSERT(StackHandlerConstants::kSize == 1 * kPointerSize);\n+  STATIC_ASSERT(StackHandlerConstants::kSize == 2 * kPointerSize);\n   STATIC_ASSERT(StackHandlerConstants::kNextOffset == 0 * kPointerSize);\n \n+  Push(Smi::kZero);  // Padding.\n   // Link the current handler as the next handler.\n   mov(r6,\n       Operand(ExternalReference(IsolateAddressId::kHandlerAddress, isolate())));\n   ldr(r5, MemOperand(r6));\n   push(r5);\n-\n   // Set this new handler as the current one.\n   str(sp, MemOperand(r6));\n }\n@@ -1560,8 +1522,8 @@ void MacroAssembler::PopStackHandler() {\n   pop(r1);\n   mov(scratch,\n       Operand(ExternalReference(IsolateAddressId::kHandlerAddress, isolate())));\n-  add(sp, sp, Operand(StackHandlerConstants::kSize - kPointerSize));\n   str(r1, MemOperand(scratch));\n+  add(sp, sp, Operand(StackHandlerConstants::kSize - kPointerSize));\n }\n \n \n@@ -1660,9 +1622,9 @@ void TurboAssembler::TryInlineTruncateDoubleToI(Register result,\n   UseScratchRegisterScope temps(this);\n   Register scratch = temps.Acquire();\n \n-  // If result is not saturated (0x7fffffff or 0x80000000), we are done.\n+  // If result is not saturated (0x7FFFFFFF or 0x80000000), we are done.\n   sub(scratch, result, Operand(1));\n-  cmp(scratch, Operand(0x7ffffffe));\n+  cmp(scratch, Operand(0x7FFFFFFE));\n   b(lt, done);\n }\n \n@@ -1765,24 +1727,24 @@ void MacroAssembler::DecrementCounter(StatsCounter* counter, int value,\n   }\n }\n \n-void TurboAssembler::Assert(Condition cond, BailoutReason reason) {\n+void TurboAssembler::Assert(Condition cond, AbortReason reason) {\n   if (emit_debug_code())\n     Check(cond, reason);\n }\n \n-void TurboAssembler::Check(Condition cond, BailoutReason reason) {\n+void TurboAssembler::Check(Condition cond, AbortReason reason) {\n   Label L;\n   b(cond, &L);\n   Abort(reason);\n   // will not return here\n   bind(&L);\n }\n \n-void TurboAssembler::Abort(BailoutReason reason) {\n+void TurboAssembler::Abort(AbortReason reason) {\n   Label abort_start;\n   bind(&abort_start);\n #ifdef DEBUG\n-  const char* msg = GetBailoutReason(reason);\n+  const char* msg = GetAbortReason(reason);\n   if (msg != nullptr) {\n     RecordComment(\"Abort message: \");\n     RecordComment(msg);\n@@ -1873,7 +1835,7 @@ void MacroAssembler::AssertNotSmi(Register object) {\n   if (emit_debug_code()) {\n     STATIC_ASSERT(kSmiTag == 0);\n     tst(object, Operand(kSmiTagMask));\n-    Check(ne, kOperandIsASmi);\n+    Check(ne, AbortReason::kOperandIsASmi);\n   }\n }\n \n@@ -1882,31 +1844,31 @@ void MacroAssembler::AssertSmi(Register object) {\n   if (emit_debug_code()) {\n     STATIC_ASSERT(kSmiTag == 0);\n     tst(object, Operand(kSmiTagMask));\n-    Check(eq, kOperandIsNotSmi);\n+    Check(eq, AbortReason::kOperandIsNotASmi);\n   }\n }\n \n void MacroAssembler::AssertFixedArray(Register object) {\n   if (emit_debug_code()) {\n     STATIC_ASSERT(kSmiTag == 0);\n     tst(object, Operand(kSmiTagMask));\n-    Check(ne, kOperandIsASmiAndNotAFixedArray);\n+    Check(ne, AbortReason::kOperandIsASmiAndNotAFixedArray);\n     push(object);\n     CompareObjectType(object, object, object, FIXED_ARRAY_TYPE);\n     pop(object);\n-    Check(eq, kOperandIsNotAFixedArray);\n+    Check(eq, AbortReason::kOperandIsNotAFixedArray);\n   }\n }\n \n void MacroAssembler::AssertFunction(Register object) {\n   if (emit_debug_code()) {\n     STATIC_ASSERT(kSmiTag == 0);\n     tst(object, Operand(kSmiTagMask));\n-    Check(ne, kOperandIsASmiAndNotAFunction);\n+    Check(ne, AbortReason::kOperandIsASmiAndNotAFunction);\n     push(object);\n     CompareObjectType(object, object, object, JS_FUNCTION_TYPE);\n     pop(object);\n-    Check(eq, kOperandIsNotAFunction);\n+    Check(eq, AbortReason::kOperandIsNotAFunction);\n   }\n }\n \n@@ -1915,18 +1877,18 @@ void MacroAssembler::AssertBoundFunction(Register object) {\n   if (emit_debug_code()) {\n     STATIC_ASSERT(kSmiTag == 0);\n     tst(object, Operand(kSmiTagMask));\n-    Check(ne, kOperandIsASmiAndNotABoundFunction);\n+    Check(ne, AbortReason::kOperandIsASmiAndNotABoundFunction);\n     push(object);\n     CompareObjectType(object, object, object, JS_BOUND_FUNCTION_TYPE);\n     pop(object);\n-    Check(eq, kOperandIsNotABoundFunction);\n+    Check(eq, AbortReason::kOperandIsNotABoundFunction);\n   }\n }\n \n void MacroAssembler::AssertGeneratorObject(Register object) {\n   if (!emit_debug_code()) return;\n   tst(object, Operand(kSmiTagMask));\n-  Check(ne, kOperandIsASmiAndNotAGeneratorObject);\n+  Check(ne, AbortReason::kOperandIsASmiAndNotAGeneratorObject);\n \n   // Load map\n   Register map = object;\n@@ -1945,7 +1907,7 @@ void MacroAssembler::AssertGeneratorObject(Register object) {\n   bind(&do_check);\n   // Restore generator object to register and perform assertion\n   pop(object);\n-  Check(eq, kOperandIsNotAGeneratorObject);\n+  Check(eq, AbortReason::kOperandIsNotAGeneratorObject);\n }\n \n void MacroAssembler::AssertUndefinedOrAllocationSite(Register object,\n@@ -1957,7 +1919,7 @@ void MacroAssembler::AssertUndefinedOrAllocationSite(Register object,\n     b(eq, &done_checking);\n     ldr(scratch, FieldMemOperand(object, HeapObject::kMapOffset));\n     CompareRoot(scratch, Heap::kAllocationSiteMapRootIndex);\n-    Assert(eq, kExpectedUndefinedOrCell);\n+    Assert(eq, AbortReason::kExpectedUndefinedOrCell);\n     bind(&done_checking);\n   }\n }"
        },
        {
            "sha": "cf731cbedbfda6c67b5b2d5d05c1af7aafe69196",
            "filename": "deps/v8/src/arm/macro-assembler-arm.h",
            "status": "modified",
            "additions": 3,
            "deletions": 7,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -294,13 +294,13 @@ class TurboAssembler : public Assembler {\n \n   // Calls Abort(msg) if the condition cond is not satisfied.\n   // Use --debug_code to enable.\n-  void Assert(Condition cond, BailoutReason reason);\n+  void Assert(Condition cond, AbortReason reason);\n \n   // Like Assert(), but always enabled.\n-  void Check(Condition cond, BailoutReason reason);\n+  void Check(Condition cond, AbortReason reason);\n \n   // Print a message to stdout and abort execution.\n-  void Abort(BailoutReason msg);\n+  void Abort(AbortReason msg);\n \n   inline bool AllowThisStubCall(CodeStub* stub);\n \n@@ -579,10 +579,6 @@ class MacroAssembler : public TurboAssembler {\n   MacroAssembler(Isolate* isolate, void* buffer, int size,\n                  CodeObjectRequired create_code_object);\n \n-  // Used for patching in calls to the deoptimizer.\n-  void CallDeoptimizer(Address target);\n-  static int CallDeoptimizerSize();\n-\n   // Swap two registers.  If the scratch register is omitted then a slightly\n   // less efficient form using xor instead of mov is emitted.\n   void Swap(Register reg1, Register reg2, Register scratch = no_reg,"
        },
        {
            "sha": "52fe9022375fb9513a4ae9287a5a4d6aab0c220e",
            "filename": "deps/v8/src/arm/simulator-arm.cc",
            "status": "modified",
            "additions": 61,
            "deletions": 177,
            "changes": 238,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fsimulator-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fsimulator-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fsimulator-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -259,11 +259,9 @@ void ArmDebugger::Debug() {\n             for (int i = 0; i < DwVfpRegister::NumRegisters(); i++) {\n               dvalue = GetVFPDoubleRegisterValue(i);\n               uint64_t as_words = bit_cast<uint64_t>(dvalue);\n-              PrintF(\"%3s: %f 0x%08x %08x\\n\",\n-                     VFPRegisters::Name(i, true),\n-                     dvalue,\n-                     static_cast<uint32_t>(as_words >> 32),\n-                     static_cast<uint32_t>(as_words & 0xffffffff));\n+              PrintF(\"%3s: %f 0x%08x %08x\\n\", VFPRegisters::Name(i, true),\n+                     dvalue, static_cast<uint32_t>(as_words >> 32),\n+                     static_cast<uint32_t>(as_words & 0xFFFFFFFF));\n             }\n           } else {\n             if (GetValue(arg1, &value)) {\n@@ -273,11 +271,9 @@ void ArmDebugger::Debug() {\n               PrintF(\"%s: %f 0x%08x\\n\", arg1, svalue, as_word);\n             } else if (GetVFPDoubleValue(arg1, &dvalue)) {\n               uint64_t as_words = bit_cast<uint64_t>(dvalue);\n-              PrintF(\"%s: %f 0x%08x %08x\\n\",\n-                     arg1,\n-                     dvalue,\n+              PrintF(\"%s: %f 0x%08x %08x\\n\", arg1, dvalue,\n                      static_cast<uint32_t>(as_words >> 32),\n-                     static_cast<uint32_t>(as_words & 0xffffffff));\n+                     static_cast<uint32_t>(as_words & 0xFFFFFFFF));\n             } else {\n               PrintF(\"%s unrecognized\\n\", arg1);\n             }\n@@ -575,6 +571,10 @@ void Simulator::set_last_debugger_input(char* input) {\n   last_debugger_input_ = input;\n }\n \n+void Simulator::SetRedirectInstruction(Instruction* instruction) {\n+  instruction->SetInstructionBits(al | (0xF * B24) | kCallRtRedirected);\n+}\n+\n void Simulator::FlushICache(base::CustomMatcherHashMap* i_cache,\n                             void* start_addr, size_t size) {\n   intptr_t start = reinterpret_cast<intptr_t>(start_addr);\n@@ -644,21 +644,12 @@ void Simulator::CheckICache(base::CustomMatcherHashMap* i_cache,\n }\n \n \n-void Simulator::Initialize(Isolate* isolate) {\n-  if (isolate->simulator_initialized()) return;\n-  isolate->set_simulator_initialized(true);\n-  ::v8::internal::ExternalReference::set_redirector(isolate,\n-                                                    &RedirectExternalReference);\n-}\n-\n-\n Simulator::Simulator(Isolate* isolate) : isolate_(isolate) {\n   i_cache_ = isolate_->simulator_i_cache();\n   if (i_cache_ == nullptr) {\n     i_cache_ = new base::CustomMatcherHashMap(&ICacheMatch);\n     isolate_->set_simulator_i_cache(i_cache_);\n   }\n-  Initialize(isolate);\n   // Set up simulator support first. Some of this information is needed to\n   // setup the architecture state.\n   size_t stack_size = 1 * 1024*1024;  // allocate 1MB for stack\n@@ -715,100 +706,6 @@ Simulator::~Simulator() {\n   free(stack_);\n }\n \n-// When the generated code calls an external reference we need to catch that in\n-// the simulator.  The external reference will be a function compiled for the\n-// host architecture.  We need to call that function instead of trying to\n-// execute it with the simulator.  We do that by redirecting the external\n-// reference to a svc (Supervisor Call) instruction that is handled by\n-// the simulator.  We write the original destination of the jump just at a known\n-// offset from the svc instruction so the simulator knows what to call.\n-class Redirection {\n- public:\n-  Redirection(Isolate* isolate, void* external_function,\n-              ExternalReference::Type type)\n-      : external_function_(external_function),\n-        swi_instruction_(al | (0xf * B24) | kCallRtRedirected),\n-        type_(type),\n-        next_(nullptr) {\n-    next_ = isolate->simulator_redirection();\n-    Simulator::current(isolate)->\n-        FlushICache(isolate->simulator_i_cache(),\n-                    reinterpret_cast<void*>(&swi_instruction_),\n-                    Instruction::kInstrSize);\n-    isolate->set_simulator_redirection(this);\n-  }\n-\n-  void* address_of_swi_instruction() {\n-    return reinterpret_cast<void*>(&swi_instruction_);\n-  }\n-\n-  void* external_function() { return external_function_; }\n-  ExternalReference::Type type() { return type_; }\n-\n-  static Redirection* Get(Isolate* isolate, void* external_function,\n-                          ExternalReference::Type type) {\n-    Redirection* current = isolate->simulator_redirection();\n-    for (; current != nullptr; current = current->next_) {\n-      if (current->external_function_ == external_function &&\n-          current->type_ == type) {\n-        return current;\n-      }\n-    }\n-    return new Redirection(isolate, external_function, type);\n-  }\n-\n-  static Redirection* FromSwiInstruction(Instruction* swi_instruction) {\n-    char* addr_of_swi = reinterpret_cast<char*>(swi_instruction);\n-    char* addr_of_redirection =\n-        addr_of_swi - offsetof(Redirection, swi_instruction_);\n-    return reinterpret_cast<Redirection*>(addr_of_redirection);\n-  }\n-\n-  static void* ReverseRedirection(int32_t reg) {\n-    Redirection* redirection = FromSwiInstruction(\n-        reinterpret_cast<Instruction*>(reinterpret_cast<void*>(reg)));\n-    return redirection->external_function();\n-  }\n-\n-  static void DeleteChain(Redirection* redirection) {\n-    while (redirection != nullptr) {\n-      Redirection* next = redirection->next_;\n-      delete redirection;\n-      redirection = next;\n-    }\n-  }\n-\n- private:\n-  void* external_function_;\n-  uint32_t swi_instruction_;\n-  ExternalReference::Type type_;\n-  Redirection* next_;\n-};\n-\n-\n-// static\n-void Simulator::TearDown(base::CustomMatcherHashMap* i_cache,\n-                         Redirection* first) {\n-  Redirection::DeleteChain(first);\n-  if (i_cache != nullptr) {\n-    for (base::HashMap::Entry* entry = i_cache->Start(); entry != nullptr;\n-         entry = i_cache->Next(entry)) {\n-      delete static_cast<CachePage*>(entry->value);\n-    }\n-    delete i_cache;\n-  }\n-}\n-\n-\n-void* Simulator::RedirectExternalReference(Isolate* isolate,\n-                                           void* external_function,\n-                                           ExternalReference::Type type) {\n-  base::LockGuard<base::Mutex> lock_guard(\n-      isolate->simulator_redirection_mutex());\n-  Redirection* redirection = Redirection::Get(isolate, external_function, type);\n-  return redirection->address_of_swi_instruction();\n-}\n-\n \n // Get the active Simulator for the current thread.\n Simulator* Simulator::current(Isolate* isolate) {\n@@ -1035,9 +932,9 @@ void Simulator::SetFpResult(const double& result) {\n \n void Simulator::TrashCallerSaveRegisters() {\n   // We don't trash the registers with the return value.\n-  registers_[2] = 0x50Bad4U;\n-  registers_[3] = 0x50Bad4U;\n-  registers_[12] = 0x50Bad4U;\n+  registers_[2] = 0x50BAD4U;\n+  registers_[3] = 0x50BAD4U;\n+  registers_[12] = 0x50BAD4U;\n }\n \n \n@@ -1292,7 +1189,7 @@ void Simulator::SetVFlag(bool val) {\n bool Simulator::CarryFrom(int32_t left, int32_t right, int32_t carry) {\n   uint32_t uleft = static_cast<uint32_t>(left);\n   uint32_t uright = static_cast<uint32_t>(right);\n-  uint32_t urest  = 0xffffffffU - uleft;\n+  uint32_t urest = 0xFFFFFFFFU - uleft;\n \n   return (uright > urest) ||\n          (carry && (((uright + 1) > urest) || (uright > (urest - 1))));\n@@ -1409,7 +1306,7 @@ int32_t Simulator::GetShiftRm(Instruction* instr, bool* carry_out) {\n       case ASR: {\n         if (shift_amount == 0) {\n           if (result < 0) {\n-            result = 0xffffffff;\n+            result = 0xFFFFFFFF;\n             *carry_out = true;\n           } else {\n             result = 0;\n@@ -1468,7 +1365,7 @@ int32_t Simulator::GetShiftRm(Instruction* instr, bool* carry_out) {\n   } else {\n     // by register\n     int rs = instr->RsValue();\n-    shift_amount = get_register(rs) &0xff;\n+    shift_amount = get_register(rs) & 0xFF;\n     switch (shift) {\n       case ASR: {\n         if (shift_amount == 0) {\n@@ -1481,7 +1378,7 @@ int32_t Simulator::GetShiftRm(Instruction* instr, bool* carry_out) {\n           DCHECK_GE(shift_amount, 32);\n           if (result < 0) {\n             *carry_out = true;\n-            result = 0xffffffff;\n+            result = 0xFFFFFFFF;\n           } else {\n             *carry_out = false;\n             result = 0;\n@@ -1739,7 +1636,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {\n       bool stack_aligned =\n           (get_register(sp)\n            & (::v8::internal::FLAG_sim_stack_alignment - 1)) == 0;\n-      Redirection* redirection = Redirection::FromSwiInstruction(instr);\n+      Redirection* redirection = Redirection::FromInstruction(instr);\n       int32_t arg0 = get_register(r0);\n       int32_t arg1 = get_register(r1);\n       int32_t arg2 = get_register(r2);\n@@ -1982,7 +1879,7 @@ Float32 Simulator::canonicalizeNaN(Float32 value) {\n double Simulator::canonicalizeNaN(double value) {\n   // Default NaN value, see \"NaN handling\" in \"IEEE 754 standard implementation\n   // choices\" of the ARM Reference Manual.\n-  constexpr uint64_t kDefaultNaN = V8_UINT64_C(0x7FF8000000000000);\n+  constexpr uint64_t kDefaultNaN = uint64_t{0x7FF8000000000000};\n   if (FPSCR_default_NaN_mode_ && std::isnan(value)) {\n     value = bit_cast<double>(kDefaultNaN);\n   }\n@@ -1993,7 +1890,7 @@ Float64 Simulator::canonicalizeNaN(Float64 value) {\n   // Default NaN value, see \"NaN handling\" in \"IEEE 754 standard implementation\n   // choices\" of the ARM Reference Manual.\n   constexpr Float64 kDefaultNaN =\n-      Float64::FromBits(V8_UINT64_C(0x7FF8000000000000));\n+      Float64::FromBits(uint64_t{0x7FF8000000000000});\n   return FPSCR_default_NaN_mode_ && value.is_nan() ? kDefaultNaN : value;\n }\n \n@@ -2036,7 +1933,7 @@ void Simulator::DisableStop(uint32_t code) {\n void Simulator::IncreaseStopCounter(uint32_t code) {\n   DCHECK_LE(code, kMaxStopCode);\n   DCHECK(isWatchedStop(code));\n-  if ((watched_stops_[code].count & ~(1 << 31)) == 0x7fffffff) {\n+  if ((watched_stops_[code].count & ~(1 << 31)) == 0x7FFFFFFF) {\n     PrintF(\"Stop counter for code %i has overflowed.\\n\"\n            \"Enabling this code and reseting the counter to 0.\\n\", code);\n     watched_stops_[code].count = 0;\n@@ -2137,14 +2034,14 @@ void Simulator::DecodeType01(Instruction* instr) {\n             int64_t right_op = static_cast<int32_t>(rs_val);\n             uint64_t result = left_op * right_op;\n             hi_res = static_cast<int32_t>(result >> 32);\n-            lo_res = static_cast<int32_t>(result & 0xffffffff);\n+            lo_res = static_cast<int32_t>(result & 0xFFFFFFFF);\n           } else {\n             // unsigned multiply\n             uint64_t left_op  = static_cast<uint32_t>(rm_val);\n             uint64_t right_op = static_cast<uint32_t>(rs_val);\n             uint64_t result = left_op * right_op;\n             hi_res = static_cast<int32_t>(result >> 32);\n-            lo_res = static_cast<int32_t>(result & 0xffffffff);\n+            lo_res = static_cast<int32_t>(result & 0xFFFFFFFF);\n           }\n           set_register(rd_lo, lo_res);\n           set_register(rd_hi, hi_res);\n@@ -2316,7 +2213,7 @@ void Simulator::DecodeType01(Instruction* instr) {\n           }\n         }\n       }\n-      if (((instr->Bits(7, 4) & 0xd) == 0xd) && (instr->Bit(20) == 0)) {\n+      if (((instr->Bits(7, 4) & 0xD) == 0xD) && (instr->Bit(20) == 0)) {\n         DCHECK_EQ(rd % 2, 0);\n         if (instr->HasH()) {\n           // The strd instruction.\n@@ -2357,7 +2254,7 @@ void Simulator::DecodeType01(Instruction* instr) {\n     }\n   } else if ((type == 0) && instr->IsMiscType0()) {\n     if ((instr->Bits(27, 23) == 2) && (instr->Bits(21, 20) == 2) &&\n-        (instr->Bits(15, 4) == 0xf00)) {\n+        (instr->Bits(15, 4) == 0xF00)) {\n       // MSR\n       int rm = instr->RmValue();\n       DCHECK_NE(pc, rm);  // UNPREDICTABLE\n@@ -2569,8 +2466,8 @@ void Simulator::DecodeType01(Instruction* instr) {\n           SetVFlag(OverflowFrom(alu_out, rn_val, shifter_operand, false));\n         } else {\n           // Format(instr, \"movt'cond 'rd, 'imm\").\n-          alu_out = (get_register(rd) & 0xffff) |\n-              (instr->ImmedMovwMovtValue() << 16);\n+          alu_out =\n+              (get_register(rd) & 0xFFFF) | (instr->ImmedMovwMovtValue() << 16);\n           set_register(rd, alu_out);\n         }\n         break;\n@@ -2987,8 +2884,8 @@ void Simulator::DecodeType3(Instruction* instr) {\n                 }\n               } else {\n                 // PU == 0b01, BW == 0b11, Bits(9, 6) != 0b0001\n-                if ((instr->Bits(20, 16) == 0x1f) &&\n-                    (instr->Bits(11, 4) == 0xf3)) {\n+                if ((instr->Bits(20, 16) == 0x1F) &&\n+                    (instr->Bits(11, 4) == 0xF3)) {\n                   // Rbit.\n                   uint32_t rm_val = get_register(instr->RmValue());\n                   set_register(rd, base::bits::ReverseBits(rm_val));\n@@ -3084,7 +2981,7 @@ void Simulator::DecodeType3(Instruction* instr) {\n           uint32_t rd_val =\n               static_cast<uint32_t>(get_register(instr->RdValue()));\n           uint32_t bitcount = msbit - lsbit + 1;\n-          uint32_t mask = 0xffffffffu >> (32 - bitcount);\n+          uint32_t mask = 0xFFFFFFFFu >> (32 - bitcount);\n           rd_val &= ~(mask << lsbit);\n           if (instr->RmValue() != 15) {\n             // bfi - bitfield insert.\n@@ -3422,7 +3319,7 @@ void Simulator::DecodeTypeVFP(Instruction* instr) {\n         int vd = instr->VFPNRegValue(kDoublePrecision);\n         int rt = instr->RtValue();\n         int opc1_opc2 = (instr->Bits(22, 21) << 2) | instr->Bits(6, 5);\n-        if ((opc1_opc2 & 0xb) == 0) {\n+        if ((opc1_opc2 & 0xB) == 0) {\n           // NeonS32/NeonU32\n           uint32_t data[2];\n           get_d_register(vd, data);\n@@ -3500,7 +3397,7 @@ void Simulator::DecodeTypeVFP(Instruction* instr) {\n       int opc1_opc2 = (instr->Bits(22, 21) << 2) | instr->Bits(6, 5);\n       uint64_t data;\n       get_d_register(vn, &data);\n-      if ((opc1_opc2 & 0xb) == 0) {\n+      if ((opc1_opc2 & 0xB) == 0) {\n         // NeonS32 / NeonU32\n         int32_t int_data[2];\n         memcpy(int_data, &data, sizeof(int_data));\n@@ -3514,14 +3411,14 @@ void Simulator::DecodeTypeVFP(Instruction* instr) {\n           int i = opc1_opc2 & 0x7;\n           int shift = i * kBitsPerByte;\n           uint32_t scalar = (data >> shift) & 0xFFu;\n-          if (!u && (scalar & 0x80) != 0) scalar |= 0xffffff00;\n+          if (!u && (scalar & 0x80) != 0) scalar |= 0xFFFFFF00;\n           set_register(rt, scalar);\n         } else if ((opc1_opc2 & 0x1) != 0) {\n           // NeonS16 / NeonU16\n           int i = (opc1_opc2 >> 1) & 0x3;\n           int shift = i * kBitsPerByte * kShortSize;\n           uint32_t scalar = (data >> shift) & 0xFFFFu;\n-          if (!u && (scalar & 0x8000) != 0) scalar |= 0xffff0000;\n+          if (!u && (scalar & 0x8000) != 0) scalar |= 0xFFFF0000;\n           set_register(rt, scalar);\n         } else {\n           UNREACHABLE();  // Not used by V8.\n@@ -3702,7 +3599,7 @@ bool get_inv_op_vfp_flag(VFPRoundingMode mode,\n                          double val,\n                          bool unsigned_) {\n   DCHECK((mode == RN) || (mode == RM) || (mode == RZ));\n-  double max_uint = static_cast<double>(0xffffffffu);\n+  double max_uint = static_cast<double>(0xFFFFFFFFu);\n   double max_int = static_cast<double>(kMaxInt);\n   double min_int = static_cast<double>(kMinInt);\n \n@@ -3744,7 +3641,7 @@ int VFPConversionSaturate(double val, bool unsigned_res) {\n     return 0;\n   } else {\n     if (unsigned_res) {\n-      return (val < 0) ? 0 : 0xffffffffu;\n+      return (val < 0) ? 0 : 0xFFFFFFFFu;\n     } else {\n       return (val < 0) ? kMinInt : kMaxInt;\n     }\n@@ -4496,7 +4393,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xa: {\n+        case 0xA: {\n           // vpmin/vpmax.s<size> Dd, Dm, Dn.\n           NeonSize size = static_cast<NeonSize>(instr->Bits(21, 20));\n           bool min = instr->Bit(4) != 0;\n@@ -4516,7 +4413,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xb: {\n+        case 0xB: {\n           // vpadd.i<size> Dd, Dm, Dn.\n           NeonSize size = static_cast<NeonSize>(instr->Bits(21, 20));\n           switch (size) {\n@@ -4535,7 +4432,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xd: {\n+        case 0xD: {\n           if (instr->Bit(4) == 0) {\n             float src1[4], src2[4];\n             get_neon_register(Vn, src1);\n@@ -4555,7 +4452,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xe: {\n+        case 0xE: {\n           if (instr->Bits(21, 20) == 0 && instr->Bit(4) == 0) {\n             // vceq.f32.\n             float src1[4], src2[4];\n@@ -4571,7 +4468,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xf: {\n+        case 0xF: {\n           if (instr->Bit(20) == 0 && instr->Bit(6) == 1) {\n             float src1[4], src2[4];\n             get_neon_register(Vn, src1);\n@@ -4862,7 +4759,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xa: {\n+        case 0xA: {\n           // vpmin/vpmax.u<size> Dd, Dm, Dn.\n           NeonSize size = static_cast<NeonSize>(instr->Bits(21, 20));\n           bool min = instr->Bit(4) != 0;\n@@ -4882,7 +4779,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xd: {\n+        case 0xD: {\n           if (instr->Bits(21, 20) == 0 && instr->Bit(6) == 1 &&\n               instr->Bit(4) == 1) {\n             // vmul.f32 Qd, Qn, Qm\n@@ -4902,7 +4799,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           }\n           break;\n         }\n-        case 0xe: {\n+        case 0xE: {\n           if (instr->Bit(20) == 0 && instr->Bit(4) == 0) {\n             // vcge/vcgt.f32 Qd, Qm, Qn\n             bool ge = instr->Bit(21) == 0;\n@@ -5014,15 +4911,15 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           if ((imm4 & 0x1) != 0) {\n             size = 8;\n             index = imm4 >> 1;\n-            mask = 0xffu;\n+            mask = 0xFFu;\n           } else if ((imm4 & 0x2) != 0) {\n             size = 16;\n             index = imm4 >> 2;\n-            mask = 0xffffu;\n+            mask = 0xFFFFu;\n           } else {\n             size = 32;\n             index = imm4 >> 3;\n-            mask = 0xffffffffu;\n+            mask = 0xFFFFFFFFu;\n           }\n           uint64_t d_data;\n           get_d_register(vm, &d_data);\n@@ -5275,7 +5172,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n           int Vd = instr->VFPDRegValue(kSimd128Precision);\n           int Vm = instr->VFPMRegValue(kSimd128Precision);\n           NeonSize size = static_cast<NeonSize>(instr->Bits(19, 18));\n-          if (instr->Bits(9, 6) == 0xd) {\n+          if (instr->Bits(9, 6) == 0xD) {\n             // vabs<type>.<size> Qd, Qm\n             if (instr->Bit(10) != 0) {\n               // floating point (clear sign bits)\n@@ -5302,7 +5199,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n                   break;\n               }\n             }\n-          } else if (instr->Bits(9, 6) == 0xf) {\n+          } else if (instr->Bits(9, 6) == 0xF) {\n             // vneg<type>.<size> Qd, Qm (signed integer)\n             if (instr->Bit(10) != 0) {\n               // floating point (toggle sign bits)\n@@ -5561,7 +5458,7 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {\n       break;\n     case 0xA:\n     case 0xB:\n-      if ((instr->Bits(22, 20) == 5) && (instr->Bits(15, 12) == 0xf)) {\n+      if ((instr->Bits(22, 20) == 5) && (instr->Bits(15, 12) == 0xF)) {\n         // pld: ignore instruction.\n       } else if (instr->SpecialValue() == 0xA && instr->Bits(22, 20) == 7) {\n         // dsb, dmb, isb: ignore instruction for now.\n@@ -5893,18 +5790,16 @@ void Simulator::CallInternal(byte* entry) {\n   set_register(r11, r11_val);\n }\n \n-\n-int32_t Simulator::Call(byte* entry, int argument_count, ...) {\n-  va_list parameters;\n-  va_start(parameters, argument_count);\n+intptr_t Simulator::CallImpl(byte* entry, int argument_count,\n+                             const intptr_t* arguments) {\n   // Set up arguments\n \n   // First four arguments passed in registers.\n-  DCHECK_GE(argument_count, 4);\n-  set_register(r0, va_arg(parameters, int32_t));\n-  set_register(r1, va_arg(parameters, int32_t));\n-  set_register(r2, va_arg(parameters, int32_t));\n-  set_register(r3, va_arg(parameters, int32_t));\n+  int reg_arg_count = std::min(4, argument_count);\n+  if (reg_arg_count > 0) set_register(r0, arguments[0]);\n+  if (reg_arg_count > 1) set_register(r1, arguments[1]);\n+  if (reg_arg_count > 2) set_register(r2, arguments[2]);\n+  if (reg_arg_count > 3) set_register(r3, arguments[3]);\n \n   // Remaining arguments passed on stack.\n   int original_stack = get_register(sp);\n@@ -5914,11 +5809,8 @@ int32_t Simulator::Call(byte* entry, int argument_count, ...) {\n     entry_stack &= -base::OS::ActivationFrameAlignment();\n   }\n   // Store remaining arguments on stack, from low to high memory.\n-  intptr_t* stack_argument = reinterpret_cast<intptr_t*>(entry_stack);\n-  for (int i = 4; i < argument_count; i++) {\n-    stack_argument[i - 4] = va_arg(parameters, int32_t);\n-  }\n-  va_end(parameters);\n+  memcpy(reinterpret_cast<intptr_t*>(entry_stack), arguments + reg_arg_count,\n+         (argument_count - reg_arg_count) * sizeof(*arguments));\n   set_register(sp, entry_stack);\n \n   CallInternal(entry);\n@@ -5927,12 +5819,10 @@ int32_t Simulator::Call(byte* entry, int argument_count, ...) {\n   CHECK_EQ(entry_stack, get_register(sp));\n   set_register(sp, original_stack);\n \n-  int32_t result = get_register(r0);\n-  return result;\n+  return get_register(r0);\n }\n \n-\n-void Simulator::CallFP(byte* entry, double d0, double d1) {\n+int32_t Simulator::CallFPImpl(byte* entry, double d0, double d1) {\n   if (use_eabi_hardfloat()) {\n     set_d_register_from_double(0, d0);\n     set_d_register_from_double(1, d1);\n@@ -5941,13 +5831,7 @@ void Simulator::CallFP(byte* entry, double d0, double d1) {\n     set_register_pair_from_double(2, &d1);\n   }\n   CallInternal(entry);\n-}\n-\n-\n-int32_t Simulator::CallFPReturnsInt(byte* entry, double d0, double d1) {\n-  CallFP(entry, d0, d1);\n-  int32_t result = get_register(r0);\n-  return result;\n+  return get_register(r0);\n }\n \n "
        },
        {
            "sha": "1cb11ffd96e85fd92acf16d1ea449d2b001b01e4",
            "filename": "deps/v8/src/arm/simulator-arm.h",
            "status": "modified",
            "additions": 21,
            "deletions": 103,
            "changes": 124,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fsimulator-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm%2Fsimulator-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fsimulator-arm.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -2,11 +2,10 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-\n // Declares a Simulator for ARM instructions if we are not generating a native\n // ARM binary. This Simulator allows us to run and debug ARM code generation on\n // regular desktop machines.\n-// V8 calls into generated code by \"calling\" the CALL_GENERATED_CODE macro,\n+// V8 calls into generated code by using the GeneratedCode class,\n // which will start execution in the Simulator or forwards to the real entry\n // on a ARM HW platform.\n \n@@ -18,56 +17,13 @@\n #include \"src/base/platform/mutex.h\"\n #include \"src/boxed-float.h\"\n \n-#if !defined(USE_SIMULATOR)\n-// Running without a simulator on a native arm platform.\n-\n-namespace v8 {\n-namespace internal {\n-\n-// When running without a simulator we call the entry directly.\n-#define CALL_GENERATED_CODE(isolate, entry, p0, p1, p2, p3, p4) \\\n-  (entry(p0, p1, p2, p3, p4))\n-\n-typedef int (*arm_regexp_matcher)(String*, int, const byte*, const byte*, int*,\n-                                  int, Address, int, Isolate*);\n-\n-// Call the generated regexp code directly. The code at the entry address\n-// should act as a function matching the type arm_regexp_matcher.\n-#define CALL_GENERATED_REGEXP_CODE(isolate, entry, p0, p1, p2, p3, p4, p5, p6, \\\n-                                   p7, p8)                                     \\\n-  (FUNCTION_CAST<arm_regexp_matcher>(entry)(p0, p1, p2, p3, p4, p5, p6, p7, p8))\n-\n-// The stack limit beyond which we will throw stack overflow errors in\n-// generated code. Because generated code on arm uses the C stack, we\n-// just use the C stack limit.\n-class SimulatorStack : public v8::internal::AllStatic {\n- public:\n-  static inline uintptr_t JsLimitFromCLimit(v8::internal::Isolate* isolate,\n-                                            uintptr_t c_limit) {\n-    USE(isolate);\n-    return c_limit;\n-  }\n-\n-  static inline uintptr_t RegisterCTryCatch(v8::internal::Isolate* isolate,\n-                                            uintptr_t try_catch_address) {\n-    USE(isolate);\n-    return try_catch_address;\n-  }\n-\n-  static inline void UnregisterCTryCatch(v8::internal::Isolate* isolate) {\n-    USE(isolate);\n-  }\n-};\n-\n-}  // namespace internal\n-}  // namespace v8\n-\n-#else  // !defined(USE_SIMULATOR)\n+#if defined(USE_SIMULATOR)\n // Running with a simulator.\n \n #include \"src/arm/constants-arm.h\"\n #include \"src/assembler.h\"\n #include \"src/base/hashmap.h\"\n+#include \"src/simulator-base.h\"\n \n namespace v8 {\n namespace internal {\n@@ -102,8 +58,7 @@ class CachePage {\n   char validity_map_[kValidityMapSize];  // One byte per line.\n };\n \n-\n-class Simulator {\n+class Simulator : public SimulatorBase {\n  public:\n   friend class ArmDebugger;\n   enum Register {\n@@ -134,7 +89,7 @@ class Simulator {\n \n   // The currently executing Simulator instance. Potentially there can be one\n   // for each native thread.\n-  static Simulator* current(v8::internal::Isolate* isolate);\n+  V8_EXPORT_PRIVATE static Simulator* current(v8::internal::Isolate* isolate);\n \n   // Accessors for register state. Reading the pc value adheres to the ARM\n   // architecture specification and is off by a 8 from the currently executing\n@@ -203,18 +158,16 @@ class Simulator {\n   // Executes ARM instructions until the PC reaches end_sim_pc.\n   void Execute();\n \n-  // Call on program start.\n-  static void Initialize(Isolate* isolate);\n-\n-  static void TearDown(base::CustomMatcherHashMap* i_cache, Redirection* first);\n+  template <typename Return, typename... Args>\n+  Return Call(byte* entry, Args... args) {\n+    return VariadicCall<Return>(this, &Simulator::CallImpl, entry, args...);\n+  }\n \n-  // V8 generally calls into generated JS code with 5 parameters and into\n-  // generated RegExp code with 7 parameters. This is a convenience function,\n-  // which sets up the simulator state and grabs the result on return.\n-  int32_t Call(byte* entry, int argument_count, ...);\n   // Alternative: call a 2-argument double function.\n-  void CallFP(byte* entry, double d0, double d1);\n-  int32_t CallFPReturnsInt(byte* entry, double d0, double d1);\n+  template <typename Return>\n+  Return CallFP(byte* entry, double d0, double d1) {\n+    return ConvertReturn<Return>(CallFPImpl(entry, d0, d1));\n+  }\n \n   // Push an address onto the JS stack.\n   uintptr_t PushAddress(uintptr_t address);\n@@ -226,6 +179,9 @@ class Simulator {\n   void set_last_debugger_input(char* input);\n   char* last_debugger_input() { return last_debugger_input_; }\n \n+  // Redirection support.\n+  static void SetRedirectInstruction(Instruction* instruction);\n+\n   // ICache checking.\n   static void FlushICache(base::CustomMatcherHashMap* i_cache, void* start,\n                           size_t size);\n@@ -255,6 +211,10 @@ class Simulator {\n     end_sim_pc = -2\n   };\n \n+  V8_EXPORT_PRIVATE intptr_t CallImpl(byte* entry, int argument_count,\n+                                      const intptr_t* arguments);\n+  intptr_t CallFPImpl(byte* entry, double d0, double d1);\n+\n   // Unsupported instructions use Format to print an error and stop execution.\n   void Format(Instruction* instr, const char* format);\n \n@@ -369,11 +329,6 @@ class Simulator {\n   static CachePage* GetCachePage(base::CustomMatcherHashMap* i_cache,\n                                  void* page);\n \n-  // Runtime call support. Uses the isolate in a thread-safe way.\n-  static void* RedirectExternalReference(\n-      Isolate* isolate, void* external_function,\n-      v8::internal::ExternalReference::Type type);\n-\n   // Handle arguments and return value for runtime FP functions.\n   void GetFpArgs(double* x, double* y, int32_t* z);\n   void SetFpResult(const double& result);\n@@ -541,45 +496,8 @@ class Simulator {\n   static base::LazyInstance<GlobalMonitor>::type global_monitor_;\n };\n \n-\n-// When running with the simulator transition into simulated execution at this\n-// point.\n-#define CALL_GENERATED_CODE(isolate, entry, p0, p1, p2, p3, p4) \\\n-  reinterpret_cast<Object*>(Simulator::current(isolate)->Call(  \\\n-      FUNCTION_ADDR(entry), 5, p0, p1, p2, p3, p4))\n-\n-#define CALL_GENERATED_FP_INT(isolate, entry, p0, p1) \\\n-  Simulator::current(isolate)->CallFPReturnsInt(FUNCTION_ADDR(entry), p0, p1)\n-\n-#define CALL_GENERATED_REGEXP_CODE(isolate, entry, p0, p1, p2, p3, p4, p5, p6, \\\n-                                   p7, p8)                                     \\\n-  Simulator::current(isolate)->Call(entry, 9, p0, p1, p2, p3, p4, p5, p6, p7,  \\\n-                                    p8)\n-\n-// The simulator has its own stack. Thus it has a different stack limit from\n-// the C-based native code.  The JS-based limit normally points near the end of\n-// the simulator stack.  When the C-based limit is exhausted we reflect that by\n-// lowering the JS-based limit as well, to make stack checks trigger.\n-class SimulatorStack : public v8::internal::AllStatic {\n- public:\n-  static inline uintptr_t JsLimitFromCLimit(v8::internal::Isolate* isolate,\n-                                            uintptr_t c_limit) {\n-    return Simulator::current(isolate)->StackLimit(c_limit);\n-  }\n-\n-  static inline uintptr_t RegisterCTryCatch(v8::internal::Isolate* isolate,\n-                                            uintptr_t try_catch_address) {\n-    Simulator* sim = Simulator::current(isolate);\n-    return sim->PushAddress(try_catch_address);\n-  }\n-\n-  static inline void UnregisterCTryCatch(v8::internal::Isolate* isolate) {\n-    Simulator::current(isolate)->PopAddress();\n-  }\n-};\n-\n }  // namespace internal\n }  // namespace v8\n \n-#endif  // !defined(USE_SIMULATOR)\n+#endif  // defined(USE_SIMULATOR)\n #endif  // V8_ARM_SIMULATOR_ARM_H_"
        },
        {
            "sha": "11c4bbf33f995679bec871e8dddd5fbd0a7047c6",
            "filename": "deps/v8/src/arm64/assembler-arm64-inl.h",
            "status": "modified",
            "additions": 8,
            "deletions": 22,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64-inl.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -532,12 +532,6 @@ Address Assembler::target_address_at(Address pc, Address constant_pool) {\n }\n \n \n-Address Assembler::target_address_at(Address pc, Code* code) {\n-  Address constant_pool = code ? code->constant_pool() : nullptr;\n-  return target_address_at(pc, constant_pool);\n-}\n-\n-\n Address Assembler::target_address_from_return_address(Address pc) {\n   // Returns the address of the call target from the return address that will\n   // be returned to after a call.\n@@ -615,22 +609,14 @@ void Assembler::set_target_address_at(Isolate* isolate, Address pc,\n }\n \n \n-void Assembler::set_target_address_at(Isolate* isolate, Address pc, Code* code,\n-                                      Address target,\n-                                      ICacheFlushMode icache_flush_mode) {\n-  Address constant_pool = code ? code->constant_pool() : nullptr;\n-  set_target_address_at(isolate, pc, constant_pool, target, icache_flush_mode);\n-}\n-\n-\n int RelocInfo::target_address_size() {\n   return kPointerSize;\n }\n \n \n Address RelocInfo::target_address() {\n   DCHECK(IsCodeTarget(rmode_) || IsRuntimeEntry(rmode_) || IsWasmCall(rmode_));\n-  return Assembler::target_address_at(pc_, host_);\n+  return Assembler::target_address_at(pc_, constant_pool_);\n }\n \n Address RelocInfo::target_address_address() {\n@@ -647,21 +633,21 @@ Address RelocInfo::constant_pool_entry_address() {\n \n HeapObject* RelocInfo::target_object() {\n   DCHECK(IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT);\n-  return HeapObject::cast(\n-      reinterpret_cast<Object*>(Assembler::target_address_at(pc_, host_)));\n+  return HeapObject::cast(reinterpret_cast<Object*>(\n+      Assembler::target_address_at(pc_, constant_pool_)));\n }\n \n Handle<HeapObject> RelocInfo::target_object_handle(Assembler* origin) {\n   DCHECK(IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT);\n-  return Handle<HeapObject>(\n-      reinterpret_cast<HeapObject**>(Assembler::target_address_at(pc_, host_)));\n+  return Handle<HeapObject>(reinterpret_cast<HeapObject**>(\n+      Assembler::target_address_at(pc_, constant_pool_)));\n }\n \n void RelocInfo::set_target_object(HeapObject* target,\n                                   WriteBarrierMode write_barrier_mode,\n                                   ICacheFlushMode icache_flush_mode) {\n   DCHECK(IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT);\n-  Assembler::set_target_address_at(target->GetIsolate(), pc_, host_,\n+  Assembler::set_target_address_at(target->GetIsolate(), pc_, constant_pool_,\n                                    reinterpret_cast<Address>(target),\n                                    icache_flush_mode);\n   if (write_barrier_mode == UPDATE_WRITE_BARRIER && host() != nullptr) {\n@@ -674,7 +660,7 @@ void RelocInfo::set_target_object(HeapObject* target,\n \n Address RelocInfo::target_external_reference() {\n   DCHECK(rmode_ == EXTERNAL_REFERENCE);\n-  return Assembler::target_address_at(pc_, host_);\n+  return Assembler::target_address_at(pc_, constant_pool_);\n }\n \n \n@@ -711,7 +697,7 @@ void RelocInfo::WipeOut(Isolate* isolate) {\n   if (IsInternalReference(rmode_)) {\n     Memory::Address_at(pc_) = nullptr;\n   } else {\n-    Assembler::set_target_address_at(isolate, pc_, host_, nullptr);\n+    Assembler::set_target_address_at(isolate, pc_, constant_pool_, nullptr);\n   }\n }\n "
        },
        {
            "sha": "a031884e1f70f2a9235a2c423dd854bc89d62000",
            "filename": "deps/v8/src/arm64/assembler-arm64.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 29,
            "changes": 56,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -147,9 +147,6 @@ CPURegList CPURegList::GetSafepointSavedRegisters() {\n   // is a caller-saved register according to the procedure call standard.\n   list.Combine(18);\n \n-  // Drop jssp as the stack pointer doesn't need to be included.\n-  list.Remove(28);\n-\n   // Add the link register (x30) to the safepoint list.\n   list.Combine(30);\n \n@@ -186,7 +183,8 @@ uint32_t RelocInfo::embedded_size() const {\n \n void RelocInfo::set_embedded_address(Isolate* isolate, Address address,\n                                      ICacheFlushMode flush_mode) {\n-  Assembler::set_target_address_at(isolate, pc_, host_, address, flush_mode);\n+  Assembler::set_target_address_at(isolate, pc_, constant_pool_, address,\n+                                   flush_mode);\n }\n \n void RelocInfo::set_embedded_size(Isolate* isolate, uint32_t size,\n@@ -2636,7 +2634,7 @@ Instr Assembler::LoadStoreStructAddrModeField(const MemOperand& addr) {\n     } else {\n       // The immediate post index addressing mode is indicated by rm = 31.\n       // The immediate is implied by the number of vector registers used.\n-      addr_field |= (0x1f << Rm_offset);\n+      addr_field |= (0x1F << Rm_offset);\n     }\n   } else {\n     DCHECK(addr.IsImmediateOffset() && (addr.offset() == 0));\n@@ -3003,7 +3001,7 @@ void Assembler::fmov(const VRegister& vd, double imm) {\n   } else {\n     DCHECK(vd.Is2D());\n     Instr op = NEONModifiedImmediate_MOVI | NEONModifiedImmediateOpBit;\n-    Emit(NEON_Q | op | ImmNEONFP(imm) | NEONCmode(0xf) | Rd(vd));\n+    Emit(NEON_Q | op | ImmNEONFP(imm) | NEONCmode(0xF) | Rd(vd));\n   }\n }\n \n@@ -3015,7 +3013,7 @@ void Assembler::fmov(const VRegister& vd, float imm) {\n     DCHECK(vd.Is2S() | vd.Is4S());\n     Instr op = NEONModifiedImmediate_MOVI;\n     Instr q = vd.Is4S() ? NEON_Q : 0;\n-    Emit(q | op | ImmNEONFP(imm) | NEONCmode(0xf) | Rd(vd));\n+    Emit(q | op | ImmNEONFP(imm) | NEONCmode(0xF) | Rd(vd));\n   }\n }\n \n@@ -3596,15 +3594,15 @@ void Assembler::movi(const VRegister& vd, const uint64_t imm, Shift shift,\n     DCHECK_EQ(shift_amount, 0);\n     int imm8 = 0;\n     for (int i = 0; i < 8; ++i) {\n-      int byte = (imm >> (i * 8)) & 0xff;\n-      DCHECK((byte == 0) || (byte == 0xff));\n-      if (byte == 0xff) {\n+      int byte = (imm >> (i * 8)) & 0xFF;\n+      DCHECK((byte == 0) || (byte == 0xFF));\n+      if (byte == 0xFF) {\n         imm8 |= (1 << i);\n       }\n     }\n     Instr q = vd.Is2D() ? NEON_Q : 0;\n     Emit(q | NEONModImmOp(1) | NEONModifiedImmediate_MOVI |\n-         ImmNEONabcdefgh(imm8) | NEONCmode(0xe) | Rd(vd));\n+         ImmNEONabcdefgh(imm8) | NEONCmode(0xE) | Rd(vd));\n   } else if (shift == LSL) {\n     NEONModifiedImmShiftLsl(vd, static_cast<int>(imm), shift_amount,\n                             NEONModifiedImmediate_MOVI);\n@@ -3953,7 +3951,7 @@ uint32_t Assembler::FPToImm8(double imm) {\n   // bit6: 0b00.0000\n   uint64_t bit6 = ((bits >> 61) & 0x1) << 6;\n   // bit5_to_0: 00cd.efgh\n-  uint64_t bit5_to_0 = (bits >> 48) & 0x3f;\n+  uint64_t bit5_to_0 = (bits >> 48) & 0x3F;\n \n   return static_cast<uint32_t>(bit7 | bit6 | bit5_to_0);\n }\n@@ -3971,7 +3969,7 @@ void Assembler::MoveWide(const Register& rd, uint64_t imm, int shift,\n     // Check that the top 32 bits are zero (a positive 32-bit number) or top\n     // 33 bits are one (a negative 32-bit number, sign extended to 64 bits).\n     DCHECK(((imm >> kWRegSizeInBits) == 0) ||\n-           ((imm >> (kWRegSizeInBits - 1)) == 0x1ffffffff));\n+           ((imm >> (kWRegSizeInBits - 1)) == 0x1FFFFFFFF));\n     imm &= kWRegMask;\n   }\n \n@@ -3984,16 +3982,16 @@ void Assembler::MoveWide(const Register& rd, uint64_t imm, int shift,\n     // Calculate a new immediate and shift combination to encode the immediate\n     // argument.\n     shift = 0;\n-    if ((imm & ~0xffffUL) == 0) {\n+    if ((imm & ~0xFFFFUL) == 0) {\n       // Nothing to do.\n-    } else if ((imm & ~(0xffffUL << 16)) == 0) {\n+    } else if ((imm & ~(0xFFFFUL << 16)) == 0) {\n       imm >>= 16;\n       shift = 1;\n-    } else if ((imm & ~(0xffffUL << 32)) == 0) {\n+    } else if ((imm & ~(0xFFFFUL << 32)) == 0) {\n       DCHECK(rd.Is64Bits());\n       imm >>= 32;\n       shift = 2;\n-    } else if ((imm & ~(0xffffUL << 48)) == 0) {\n+    } else if ((imm & ~(0xFFFFUL << 48)) == 0) {\n       DCHECK(rd.Is64Bits());\n       imm >>= 48;\n       shift = 3;\n@@ -4247,7 +4245,7 @@ void Assembler::NEONModifiedImmShiftMsl(const VRegister& vd, const int imm8,\n   DCHECK(is_uint8(imm8));\n \n   int cmode_0 = (shift_amount >> 4) & 1;\n-  int cmode = 0xc | cmode_0;\n+  int cmode = 0xC | cmode_0;\n \n   Instr q = vd.IsQ() ? NEON_Q : 0;\n \n@@ -4343,7 +4341,7 @@ void Assembler::DataProcExtendedRegister(const Register& rd,\n \n bool Assembler::IsImmAddSub(int64_t immediate) {\n   return is_uint12(immediate) ||\n-         (is_uint12(immediate >> 12) && ((immediate & 0xfff) == 0));\n+         (is_uint12(immediate >> 12) && ((immediate & 0xFFF) == 0));\n }\n \n void Assembler::LoadStore(const CPURegister& rt,\n@@ -4526,7 +4524,7 @@ bool Assembler::IsImmLogical(uint64_t value,\n     clz_a = CountLeadingZeros(a, kXRegSizeInBits);\n     int clz_c = CountLeadingZeros(c, kXRegSizeInBits);\n     d = clz_a - clz_c;\n-    mask = ((V8_UINT64_C(1) << d) - 1);\n+    mask = ((uint64_t{1} << d) - 1);\n     out_n = 0;\n   } else {\n     // Handle degenerate cases.\n@@ -4547,7 +4545,7 @@ bool Assembler::IsImmLogical(uint64_t value,\n       // the general case above, and set the N bit in the output.\n       clz_a = CountLeadingZeros(a, kXRegSizeInBits);\n       d = 64;\n-      mask = ~V8_UINT64_C(0);\n+      mask = ~uint64_t{0};\n       out_n = 1;\n     }\n   }\n@@ -4596,7 +4594,7 @@ bool Assembler::IsImmLogical(uint64_t value,\n \n   // Count the set bits in our basic stretch. The special case of clz(0) == -1\n   // makes the answer come out right for stretches that reach the very top of\n-  // the word (e.g. numbers like 0xffffc00000000000).\n+  // the word (e.g. numbers like 0xFFFFC00000000000).\n   int clz_b = (b == 0) ? -1 : CountLeadingZeros(b, kXRegSizeInBits);\n   int s = clz_a - clz_b;\n \n@@ -4628,7 +4626,7 @@ bool Assembler::IsImmLogical(uint64_t value,\n   //\n   // So we 'or' (-d << 1) with our computed s to form imms.\n   *n = out_n;\n-  *imm_s = ((-d << 1) | (s - 1)) & 0x3f;\n+  *imm_s = ((-d << 1) | (s - 1)) & 0x3F;\n   *imm_r = r;\n \n   return true;\n@@ -4645,13 +4643,13 @@ bool Assembler::IsImmFP32(float imm) {\n   // aBbb.bbbc.defg.h000.0000.0000.0000.0000\n   uint32_t bits = bit_cast<uint32_t>(imm);\n   // bits[19..0] are cleared.\n-  if ((bits & 0x7ffff) != 0) {\n+  if ((bits & 0x7FFFF) != 0) {\n     return false;\n   }\n \n   // bits[29..25] are all set or all cleared.\n-  uint32_t b_pattern = (bits >> 16) & 0x3e00;\n-  if (b_pattern != 0 && b_pattern != 0x3e00) {\n+  uint32_t b_pattern = (bits >> 16) & 0x3E00;\n+  if (b_pattern != 0 && b_pattern != 0x3E00) {\n     return false;\n   }\n \n@@ -4670,13 +4668,13 @@ bool Assembler::IsImmFP64(double imm) {\n   // 0000.0000.0000.0000.0000.0000.0000.0000\n   uint64_t bits = bit_cast<uint64_t>(imm);\n   // bits[47..0] are cleared.\n-  if ((bits & 0xffffffffffffL) != 0) {\n+  if ((bits & 0xFFFFFFFFFFFFL) != 0) {\n     return false;\n   }\n \n   // bits[61..54] are all set or all cleared.\n-  uint32_t b_pattern = (bits >> 48) & 0x3fc0;\n-  if (b_pattern != 0 && b_pattern != 0x3fc0) {\n+  uint32_t b_pattern = (bits >> 48) & 0x3FC0;\n+  if (b_pattern != 0 && b_pattern != 0x3FC0) {\n     return false;\n   }\n "
        },
        {
            "sha": "2deae8aaa462a9e1e9b1ae302897201bfbe8438b",
            "filename": "deps/v8/src/arm64/assembler-arm64.h",
            "status": "modified",
            "additions": 3,
            "deletions": 12,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -39,7 +39,8 @@ namespace internal {\n #define ALLOCATABLE_GENERAL_REGISTERS(R)                  \\\n   R(x0)  R(x1)  R(x2)  R(x3)  R(x4)  R(x5)  R(x6)  R(x7)  \\\n   R(x8)  R(x9)  R(x10) R(x11) R(x12) R(x13) R(x14) R(x15) \\\n-  R(x18) R(x19) R(x20) R(x21) R(x22) R(x23) R(x24) R(x27)\n+  R(x18) R(x19) R(x20) R(x21) R(x22) R(x23) R(x24) R(x27) \\\n+  R(x28)\n \n #define FLOAT_REGISTERS(V)                                \\\n   V(s0)  V(s1)  V(s2)  V(s3)  V(s4)  V(s5)  V(s6)  V(s7)  \\\n@@ -295,6 +296,7 @@ class Register : public CPURegister {\n static_assert(IS_TRIVIALLY_COPYABLE(Register),\n               \"Register can efficiently be passed by value\");\n \n+constexpr bool kPadArguments = true;\n constexpr bool kSimpleFPAliasing = true;\n constexpr bool kSimdMaskRegisters = false;\n \n@@ -479,13 +481,6 @@ ALIAS_REGISTER(Register, root, x26);\n ALIAS_REGISTER(Register, rr, x26);\n // Context pointer register.\n ALIAS_REGISTER(Register, cp, x27);\n-// We use a register as a JS stack pointer to overcome the restriction on the\n-// architectural SP alignment.\n-// We chose x28 because it is contiguous with the other specific purpose\n-// registers.\n-STATIC_ASSERT(kJSSPCode == 28);\n-ALIAS_REGISTER(Register, jssp, x28);\n-ALIAS_REGISTER(Register, wjssp, w28);\n ALIAS_REGISTER(Register, fp, x29);\n ALIAS_REGISTER(Register, lr, x30);\n ALIAS_REGISTER(Register, xzr, x31);\n@@ -1001,10 +996,6 @@ class Assembler : public AssemblerBase {\n   inline static void set_target_address_at(\n       Isolate* isolate, Address pc, Address constant_pool, Address target,\n       ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n-  static inline Address target_address_at(Address pc, Code* code);\n-  static inline void set_target_address_at(\n-      Isolate* isolate, Address pc, Code* code, Address target,\n-      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n \n   // Return the code target address at a call site from the return address of\n   // that call in the instruction stream."
        },
        {
            "sha": "52f92b6af9ac607a8688473766b740f53ab4f7c0",
            "filename": "deps/v8/src/arm64/code-stubs-arm64.cc",
            "status": "modified",
            "additions": 62,
            "deletions": 90,
            "changes": 152,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fcode-stubs-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fcode-stubs-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fcode-stubs-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -30,7 +30,7 @@ namespace internal {\n \n void ArrayNArgumentsConstructorStub::Generate(MacroAssembler* masm) {\n   __ Mov(x5, Operand(x0, LSL, kPointerSizeLog2));\n-  __ Str(x1, MemOperand(jssp, x5));\n+  __ Str(x1, MemOperand(__ StackPointer(), x5));\n   __ Push(x1, x2);\n   __ Add(x0, x0, Operand(3));\n   __ TailCallRuntime(Runtime::kNewArray);\n@@ -42,7 +42,6 @@ void DoubleToIStub::Generate(MacroAssembler* masm) {\n   Register result = destination();\n \n   DCHECK(result.Is64Bits());\n-  DCHECK(jssp.Is(masm->StackPointer()));\n \n   UseScratchRegisterScope temps(masm);\n   Register scratch1 = temps.AcquireX();\n@@ -75,7 +74,7 @@ void DoubleToIStub::Generate(MacroAssembler* masm) {\n   if (masm->emit_debug_code()) {\n     __ Cmp(exponent, HeapNumber::kExponentBias + 63);\n     // Exponents less than this should have been handled by the Fcvt case.\n-    __ Check(ge, kUnexpectedValue);\n+    __ Check(ge, AbortReason::kUnexpectedValue);\n   }\n \n   // Isolate the mantissa bits, and set the implicit '1'.\n@@ -100,8 +99,8 @@ void DoubleToIStub::Generate(MacroAssembler* masm) {\n \n void MathPowStub::Generate(MacroAssembler* masm) {\n   // Stack on entry:\n-  // jssp[0]: Exponent (as a tagged value).\n-  // jssp[1]: Base (as a tagged value).\n+  // sp[0]: Exponent (as a tagged value).\n+  // sp[1]: Base (as a tagged value).\n   //\n   // The (tagged) result will be returned in x0, as a heap number.\n \n@@ -276,15 +275,14 @@ void CEntryStub::Generate(MacroAssembler* masm) {\n   // The stack on entry holds the arguments and the receiver, with the receiver\n   // at the highest address:\n   //\n-  //    jssp]argc-1]: receiver\n-  //    jssp[argc-2]: arg[argc-2]\n+  //    sp]argc-1]: receiver\n+  //    sp[argc-2]: arg[argc-2]\n   //    ...           ...\n-  //    jssp[1]:      arg[1]\n-  //    jssp[0]:      arg[0]\n+  //    sp[1]:      arg[1]\n+  //    sp[0]:      arg[0]\n   //\n   // The arguments are in reverse order, so that arg[argc-2] is actually the\n   // first argument to the target function and arg[0] is the last.\n-  DCHECK(jssp.Is(__ StackPointer()));\n   const Register& argc_input = x0;\n   const Register& target_input = x1;\n \n@@ -385,7 +383,7 @@ void CEntryStub::Generate(MacroAssembler* masm) {\n     __ Ldr(temp, MemOperand(fp, ExitFrameConstants::kSPOffset));\n     __ Ldr(temp, MemOperand(temp, -static_cast<int64_t>(kXRegSize)));\n     __ Cmp(temp, x12);\n-    __ Check(eq, kReturnAddressNotFoundInFrame);\n+    __ Check(eq, AbortReason::kReturnAddressNotFoundInFrame);\n   }\n \n   // Call the builtin.\n@@ -415,19 +413,14 @@ void CEntryStub::Generate(MacroAssembler* masm) {\n   __ Peek(argc, 2 * kPointerSize);\n   __ Peek(target, 3 * kPointerSize);\n \n-  __ LeaveExitFrame(save_doubles(), x10);\n-  DCHECK(jssp.Is(__ StackPointer()));\n+  __ LeaveExitFrame(save_doubles(), x10, x9);\n   if (!argv_in_register()) {\n     // Drop the remaining stack slots and return from the stub.\n     __ DropArguments(x11);\n   }\n   __ AssertFPCRState();\n   __ Ret();\n \n-  // The stack pointer is still csp if we aren't returning, and the frame\n-  // hasn't changed (except for the return address).\n-  __ SetStackPointer(csp);\n-\n   // Handling of exception.\n   __ Bind(&exception_returned);\n \n@@ -453,18 +446,16 @@ void CEntryStub::Generate(MacroAssembler* masm) {\n     __ CallCFunction(find_handler, 3);\n   }\n \n-  // We didn't execute a return case, so the stack frame hasn't been updated\n-  // (except for the return address slot). However, we don't need to initialize\n-  // jssp because the throw method will immediately overwrite it when it\n-  // unwinds the stack.\n-  __ SetStackPointer(jssp);\n-\n   // Retrieve the handler context, SP and FP.\n   __ Mov(cp, Operand(pending_handler_context_address));\n   __ Ldr(cp, MemOperand(cp));\n-  __ Mov(jssp, Operand(pending_handler_sp_address));\n-  __ Ldr(jssp, MemOperand(jssp));\n-  __ Mov(csp, jssp);\n+  {\n+    UseScratchRegisterScope temps(masm);\n+    Register scratch = temps.AcquireX();\n+    __ Mov(scratch, Operand(pending_handler_sp_address));\n+    __ Ldr(scratch, MemOperand(scratch));\n+    __ Mov(csp, scratch);\n+  }\n   __ Mov(fp, Operand(pending_handler_fp_address));\n   __ Ldr(fp, MemOperand(fp));\n \n@@ -481,9 +472,8 @@ void CEntryStub::Generate(MacroAssembler* masm) {\n   __ Br(x10);\n }\n \n-\n // This is the entry point from C++. 5 arguments are provided in x0-x4.\n-// See use of the CALL_GENERATED_CODE macro for example in src/execution.cc.\n+// See use of the JSEntryFunction for example in src/execution.cc.\n // Input:\n //   x0: code entry.\n //   x1: function.\n@@ -493,7 +483,6 @@ void CEntryStub::Generate(MacroAssembler* masm) {\n // Output:\n //   x0: result.\n void JSEntryStub::Generate(MacroAssembler* masm) {\n-  DCHECK(jssp.Is(__ StackPointer()));\n   Register code_entry = x0;\n \n   // Enable instruction instrumentation. This only works on the simulator, and\n@@ -502,21 +491,16 @@ void JSEntryStub::Generate(MacroAssembler* masm) {\n \n   Label invoke, handler_entry, exit;\n \n-  // Push callee-saved registers and synchronize the system stack pointer (csp)\n-  // and the JavaScript stack pointer (jssp).\n-  //\n-  // We must not write to jssp until after the PushCalleeSavedRegisters()\n-  // call, since jssp is itself a callee-saved register.\n-  __ SetStackPointer(csp);\n   __ PushCalleeSavedRegisters();\n-  __ Mov(jssp, csp);\n-  __ SetStackPointer(jssp);\n \n   ProfileEntryHookStub::MaybeCallEntryHook(masm);\n \n   // Set up the reserved register for 0.0.\n   __ Fmov(fp_zero, 0.0);\n \n+  // Initialize the root array register\n+  __ InitializeRootRegister();\n+\n   // Build an entry frame (see layout below).\n   StackFrame::Type marker = type();\n   int64_t bad_frame_pointer = -1L;  // Bad frame pointer to fail if it is used.\n@@ -527,7 +511,7 @@ void JSEntryStub::Generate(MacroAssembler* masm) {\n \n   __ Push(x13, x12, xzr, x10);\n   // Set up fp.\n-  __ Sub(fp, jssp, EntryFrameConstants::kCallerFPOffset);\n+  __ Sub(fp, __ StackPointer(), EntryFrameConstants::kCallerFPOffset);\n \n   // Push the JS entry frame marker. Also set js_entry_sp if this is the\n   // outermost JS call.\n@@ -546,14 +530,15 @@ void JSEntryStub::Generate(MacroAssembler* masm) {\n   __ Str(fp, MemOperand(x10));\n \n   __ Bind(&done);\n-  __ Push(x12);\n+  __ Push(x12, padreg);\n \n   // The frame set up looks like this:\n-  // jssp[0] : JS entry frame marker.\n-  // jssp[1] : C entry FP.\n-  // jssp[2] : stack frame marker.\n-  // jssp[3] : stack frame marker.\n-  // jssp[4] : bad frame pointer 0xfff...ff   <- fp points here.\n+  // sp[0] : padding.\n+  // sp[1] : JS entry frame marker.\n+  // sp[2] : C entry FP.\n+  // sp[3] : stack frame marker.\n+  // sp[4] : stack frame marker.\n+  // sp[5] : bad frame pointer 0xFFF...FF   <- fp points here.\n \n   // Jump to a faked try block that does the invoke, with a faked catch\n   // block that sets the pending exception.\n@@ -583,19 +568,23 @@ void JSEntryStub::Generate(MacroAssembler* masm) {\n   __ Bind(&invoke);\n \n   // Push new stack handler.\n-  DCHECK(jssp.Is(__ StackPointer()));\n-  static_assert(StackHandlerConstants::kSize == 1 * kPointerSize,\n+  static_assert(StackHandlerConstants::kSize == 2 * kPointerSize,\n                 \"Unexpected offset for StackHandlerConstants::kSize\");\n   static_assert(StackHandlerConstants::kNextOffset == 0 * kPointerSize,\n                 \"Unexpected offset for StackHandlerConstants::kNextOffset\");\n \n   // Link the current handler as the next handler.\n   __ Mov(x11, ExternalReference(IsolateAddressId::kHandlerAddress, isolate()));\n   __ Ldr(x10, MemOperand(x11));\n-  __ Push(x10);\n+  __ Push(padreg, x10);\n \n   // Set this new handler as the current one.\n-  __ Str(jssp, MemOperand(x11));\n+  {\n+    UseScratchRegisterScope temps(masm);\n+    Register scratch = temps.AcquireX();\n+    __ Mov(scratch, __ StackPointer());\n+    __ Str(scratch, MemOperand(x11));\n+  }\n \n   // If an exception not caught by another handler occurs, this handler\n   // returns control to the code after the B(&invoke) above, which\n@@ -612,37 +601,32 @@ void JSEntryStub::Generate(MacroAssembler* masm) {\n   // x2: receiver.\n   // x3: argc.\n   // x4: argv.\n-\n-  if (type() == StackFrame::CONSTRUCT_ENTRY) {\n-    __ Call(BUILTIN_CODE(isolate(), JSConstructEntryTrampoline),\n-            RelocInfo::CODE_TARGET);\n-  } else {\n-    __ Call(BUILTIN_CODE(isolate(), JSEntryTrampoline), RelocInfo::CODE_TARGET);\n-  }\n+  __ Call(EntryTrampoline(), RelocInfo::CODE_TARGET);\n \n   // Pop the stack handler and unlink this frame from the handler chain.\n   static_assert(StackHandlerConstants::kNextOffset == 0 * kPointerSize,\n                 \"Unexpected offset for StackHandlerConstants::kNextOffset\");\n-  __ Pop(x10);\n+  __ Pop(x10, padreg);\n   __ Mov(x11, ExternalReference(IsolateAddressId::kHandlerAddress, isolate()));\n-  __ Drop(StackHandlerConstants::kSize - kXRegSize, kByteSizeInBytes);\n+  __ Drop(StackHandlerConstants::kSlotCount - 2);\n   __ Str(x10, MemOperand(x11));\n \n   __ Bind(&exit);\n   // x0 holds the result.\n   // The stack pointer points to the top of the entry frame pushed on entry from\n   // C++ (at the beginning of this stub):\n-  // jssp[0] : JS entry frame marker.\n-  // jssp[1] : C entry FP.\n-  // jssp[2] : stack frame marker.\n-  // jssp[3] : stack frmae marker.\n-  // jssp[4] : bad frame pointer 0xfff...ff   <- fp points here.\n+  // sp[0] : padding.\n+  // sp[1] : JS entry frame marker.\n+  // sp[2] : C entry FP.\n+  // sp[3] : stack frame marker.\n+  // sp[4] : stack frame marker.\n+  // sp[5] : bad frame pointer 0xFFF...FF   <- fp points here.\n \n   // Check if the current stack frame is marked as the outermost JS frame.\n   Label non_outermost_js_2;\n   {\n     Register c_entry_fp = x11;\n-    __ Pop(x10, c_entry_fp);\n+    __ PeekPair(x10, c_entry_fp, 1 * kPointerSize);\n     __ Cmp(x10, StackFrame::OUTERMOST_JSENTRY_FRAME);\n     __ B(ne, &non_outermost_js_2);\n     __ Mov(x12, ExternalReference(js_entry_sp));\n@@ -656,21 +640,17 @@ void JSEntryStub::Generate(MacroAssembler* masm) {\n   }\n \n   // Reset the stack to the callee saved registers.\n-  __ Drop(-EntryFrameConstants::kCallerFPOffset, kByteSizeInBytes);\n+  static_assert(EntryFrameConstants::kFixedFrameSize % (2 * kPointerSize) == 0,\n+                \"Size of entry frame is not a multiple of 16 bytes\");\n+  __ Drop(EntryFrameConstants::kFixedFrameSize / kPointerSize);\n   // Restore the callee-saved registers and return.\n-  DCHECK(jssp.Is(__ StackPointer()));\n-  __ Mov(csp, jssp);\n-  __ SetStackPointer(csp);\n   __ PopCalleeSavedRegisters();\n-  // After this point, we must not modify jssp because it is a callee-saved\n-  // register which we have just restored.\n   __ Ret();\n }\n \n-// The entry hook is a \"BumpSystemStackPointer\" instruction (sub), followed by\n-// a \"Push lr\" instruction, followed by a call.\n+// The entry hook is a Push (stp) instruction, followed by a call.\n static const unsigned int kProfileEntryHookCallSize =\n-    Assembler::kCallSizeWithRelocation + (2 * kInstructionSize);\n+    (1 * kInstructionSize) + Assembler::kCallSizeWithRelocation;\n \n void ProfileEntryHookStub::MaybeCallEntryHookDelayed(TurboAssembler* tasm,\n                                                      Zone* zone) {\n@@ -748,14 +728,6 @@ void ProfileEntryHookStub::Generate(MacroAssembler* masm) {\n \n \n void DirectCEntryStub::Generate(MacroAssembler* masm) {\n-  // When calling into C++ code the stack pointer must be csp.\n-  // Therefore this code must use csp for peek/poke operations when the\n-  // stub is generated. When the stub is called\n-  // (via DirectCEntryStub::GenerateCall), the caller must setup an ExitFrame\n-  // and configure the stack pointer *before* doing the call.\n-  const Register old_stack_pointer = __ StackPointer();\n-  __ SetStackPointer(csp);\n-\n   // Put return address on the stack (accessible to GC through exit frame pc).\n   __ Poke(lr, 0);\n   // Call the C++ function.\n@@ -764,8 +736,6 @@ void DirectCEntryStub::Generate(MacroAssembler* masm) {\n   __ Peek(lr, 0);\n   __ AssertFPCRState();\n   __ Ret();\n-\n-  __ SetStackPointer(old_stack_pointer);\n }\n \n void DirectCEntryStub::GenerateCall(MacroAssembler* masm,\n@@ -806,7 +776,7 @@ static void CreateArrayDispatch(MacroAssembler* masm,\n     }\n \n     // If we reached this point there is a problem.\n-    __ Abort(kUnexpectedElementsKindInArrayConstructor);\n+    __ Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n \n   } else {\n     UNREACHABLE();\n@@ -856,7 +826,7 @@ static void CreateArrayDispatchOneArgument(MacroAssembler* masm,\n       __ Ldr(x10, FieldMemOperand(allocation_site, 0));\n       __ JumpIfNotRoot(x10, Heap::kAllocationSiteMapRootIndex,\n                        &normal_sequence);\n-      __ Assert(eq, kExpectedAllocationSite);\n+      __ Assert(eq, AbortReason::kExpectedAllocationSite);\n     }\n \n     // Save the resulting elements kind in type info. We can't just store 'kind'\n@@ -884,7 +854,7 @@ static void CreateArrayDispatchOneArgument(MacroAssembler* masm,\n     }\n \n     // If we reached this point there is a problem.\n-    __ Abort(kUnexpectedElementsKindInArrayConstructor);\n+    __ Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n   } else {\n     UNREACHABLE();\n   }\n@@ -972,7 +942,7 @@ void ArrayConstructorStub::Generate(MacroAssembler* masm) {\n     __ JumpIfSmi(x10, &unexpected_map);\n     __ JumpIfObjectType(x10, x10, x11, MAP_TYPE, &map_ok);\n     __ Bind(&unexpected_map);\n-    __ Abort(kUnexpectedInitialMapForArrayFunction);\n+    __ Abort(AbortReason::kUnexpectedInitialMapForArrayFunction);\n     __ Bind(&map_ok);\n \n     // We should either have undefined in the allocation_site register or a\n@@ -1069,7 +1039,7 @@ void InternalArrayConstructorStub::Generate(MacroAssembler* masm) {\n     __ JumpIfSmi(x10, &unexpected_map);\n     __ JumpIfObjectType(x10, x10, x11, MAP_TYPE, &map_ok);\n     __ Bind(&unexpected_map);\n-    __ Abort(kUnexpectedInitialMapForArrayFunction);\n+    __ Abort(AbortReason::kUnexpectedInitialMapForArrayFunction);\n     __ Bind(&map_ok);\n   }\n \n@@ -1085,7 +1055,9 @@ void InternalArrayConstructorStub::Generate(MacroAssembler* masm) {\n     Label done;\n     __ Cmp(x3, PACKED_ELEMENTS);\n     __ Ccmp(x3, HOLEY_ELEMENTS, ZFlag, ne);\n-    __ Assert(eq, kInvalidElementsKindForInternalArrayOrInternalPackedArray);\n+    __ Assert(\n+        eq,\n+        AbortReason::kInvalidElementsKindForInternalArrayOrInternalPackedArray);\n   }\n \n   Label fast_elements_case;\n@@ -1202,7 +1174,7 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,\n   if (__ emit_debug_code()) {\n     __ Ldr(w1, MemOperand(handle_scope_base, kLevelOffset));\n     __ Cmp(w1, level_reg);\n-    __ Check(eq, kUnexpectedLevelAfterReturnFromApiCall);\n+    __ Check(eq, AbortReason::kUnexpectedLevelAfterReturnFromApiCall);\n   }\n   __ Sub(level_reg, level_reg, 1);\n   __ Str(level_reg, MemOperand(handle_scope_base, kLevelOffset));\n@@ -1218,7 +1190,7 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,\n   __ Peek(x21, (spill_offset + 2) * kXRegSize);\n   __ Peek(x22, (spill_offset + 3) * kXRegSize);\n \n-  __ LeaveExitFrame(false, x1);\n+  __ LeaveExitFrame(false, x1, x5);\n \n   // Check if the function scheduled an exception.\n   __ Mov(x5, ExternalReference::scheduled_exception_address(isolate));"
        },
        {
            "sha": "b02dd5d2d799fce0e8af8f44e918f10be7a7dac6",
            "filename": "deps/v8/src/arm64/constants-arm64.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fconstants-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fconstants-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fconstants-arm64.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -101,7 +101,6 @@ const int kIp1Code = 17;\n const int kFramePointerRegCode = 29;\n const int kLinkRegCode = 30;\n const int kZeroRegCode = 31;\n-const int kJSSPCode = 28;\n const int kSPRegInternalCode = 63;\n const unsigned kRegCodeMask = 0x1f;\n const unsigned kShiftAmountWRegMask = 0x1f;"
        },
        {
            "sha": "26ec06e094c46abbf8db1386ba31d58084b33c35",
            "filename": "deps/v8/src/arm64/cpu-arm64.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fcpu-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fcpu-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fcpu-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -31,7 +31,7 @@ class CacheLineSizes {\n   uint32_t ExtractCacheLineSize(int cache_line_size_shift) const {\n     // The cache type register holds the size of cache lines in words as a\n     // power of two.\n-    return 4 << ((cache_type_register_ >> cache_line_size_shift) & 0xf);\n+    return 4 << ((cache_type_register_ >> cache_line_size_shift) & 0xF);\n   }\n \n   uint32_t cache_type_register_;"
        },
        {
            "sha": "8269e8e50a3a71e27f06cbbc9a440a7355352b46",
            "filename": "deps/v8/src/arm64/deoptimizer-arm64.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fdeoptimizer-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fdeoptimizer-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fdeoptimizer-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -108,11 +108,9 @@ void Deoptimizer::TableEntryGenerator::Generate() {\n   __ PushCPURegList(saved_float_registers);\n \n   // We save all the registers except sp, lr and the masm scratches.\n-  CPURegList saved_registers(CPURegister::kRegister, kXRegSizeInBits, 0, 27);\n+  CPURegList saved_registers(CPURegister::kRegister, kXRegSizeInBits, 0, 28);\n   saved_registers.Remove(ip0);\n   saved_registers.Remove(ip1);\n-  // TODO(arm): padding here can be replaced with jssp/x28 when allocatable.\n-  saved_registers.Combine(padreg);\n   saved_registers.Combine(fp);\n   DCHECK_EQ(saved_registers.Count() % 2, 0);\n   __ PushCPURegList(saved_registers);\n@@ -220,8 +218,12 @@ void Deoptimizer::TableEntryGenerator::Generate() {\n   }\n   __ Pop(x4, padreg);  // Restore deoptimizer object (class Deoptimizer).\n \n-  __ Ldr(__ StackPointer(),\n-         MemOperand(x4, Deoptimizer::caller_frame_top_offset()));\n+  {\n+    UseScratchRegisterScope temps(masm());\n+    Register scratch = temps.AcquireX();\n+    __ Ldr(scratch, MemOperand(x4, Deoptimizer::caller_frame_top_offset()));\n+    __ Mov(__ StackPointer(), scratch);\n+  }\n \n   // Replace the current (input) frame with the output frames.\n   Label outer_push_loop, inner_push_loop,\n@@ -324,7 +326,7 @@ void Deoptimizer::TableEntryGenerator::GeneratePrologue() {\n   if (__ emit_debug_code()) {\n     // Ensure the entry_id looks sensible, ie. 0 <= entry_id < count().\n     __ Cmp(entry_id, count());\n-    __ Check(lo, kOffsetOutOfRange);\n+    __ Check(lo, AbortReason::kOffsetOutOfRange);\n   }\n }\n "
        },
        {
            "sha": "41c654b214da6bd2ed5764110b3e9014e7158b1f",
            "filename": "deps/v8/src/arm64/disasm-arm64.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 28,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fdisasm-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fdisasm-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fdisasm-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -256,27 +256,26 @@ void DisassemblingDecoder::VisitLogicalImmediate(Instruction* instr) {\n \n bool DisassemblingDecoder::IsMovzMovnImm(unsigned reg_size, uint64_t value) {\n   DCHECK((reg_size == kXRegSizeInBits) ||\n-         ((reg_size == kWRegSizeInBits) && (value <= 0xffffffff)));\n+         ((reg_size == kWRegSizeInBits) && (value <= 0xFFFFFFFF)));\n \n   // Test for movz: 16-bits set at positions 0, 16, 32 or 48.\n-  if (((value & 0xffffffffffff0000UL) == 0UL) ||\n-      ((value & 0xffffffff0000ffffUL) == 0UL) ||\n-      ((value & 0xffff0000ffffffffUL) == 0UL) ||\n-      ((value & 0x0000ffffffffffffUL) == 0UL)) {\n+  if (((value & 0xFFFFFFFFFFFF0000UL) == 0UL) ||\n+      ((value & 0xFFFFFFFF0000FFFFUL) == 0UL) ||\n+      ((value & 0xFFFF0000FFFFFFFFUL) == 0UL) ||\n+      ((value & 0x0000FFFFFFFFFFFFUL) == 0UL)) {\n     return true;\n   }\n \n   // Test for movn: NOT(16-bits set at positions 0, 16, 32 or 48).\n   if ((reg_size == kXRegSizeInBits) &&\n-      (((value & 0xffffffffffff0000UL) == 0xffffffffffff0000UL) ||\n-       ((value & 0xffffffff0000ffffUL) == 0xffffffff0000ffffUL) ||\n-       ((value & 0xffff0000ffffffffUL) == 0xffff0000ffffffffUL) ||\n-       ((value & 0x0000ffffffffffffUL) == 0x0000ffffffffffffUL))) {\n+      (((value & 0xFFFFFFFFFFFF0000UL) == 0xFFFFFFFFFFFF0000UL) ||\n+       ((value & 0xFFFFFFFF0000FFFFUL) == 0xFFFFFFFF0000FFFFUL) ||\n+       ((value & 0xFFFF0000FFFFFFFFUL) == 0xFFFF0000FFFFFFFFUL) ||\n+       ((value & 0x0000FFFFFFFFFFFFUL) == 0x0000FFFFFFFFFFFFUL))) {\n     return true;\n   }\n-  if ((reg_size == kWRegSizeInBits) &&\n-      (((value & 0xffff0000) == 0xffff0000) ||\n-       ((value & 0x0000ffff) == 0x0000ffff))) {\n+  if ((reg_size == kWRegSizeInBits) && (((value & 0xFFFF0000) == 0xFFFF0000) ||\n+                                        ((value & 0x0000FFFF) == 0x0000FFFF))) {\n     return true;\n   }\n   return false;\n@@ -3332,8 +3331,6 @@ void DisassemblingDecoder::AppendRegisterNameToOutput(const CPURegister& reg) {\n     // Filter special registers\n     if (reg.IsX() && (reg.code() == 27)) {\n       AppendToOutput(\"cp\");\n-    } else if (reg.IsX() && (reg.code() == 28)) {\n-      AppendToOutput(\"jssp\");\n     } else if (reg.IsX() && (reg.code() == 29)) {\n       AppendToOutput(\"fp\");\n     } else if (reg.IsX() && (reg.code() == 30)) {\n@@ -3469,7 +3466,7 @@ int DisassemblingDecoder::SubstituteRegisterField(Instruction* instr,\n     case 'e':\n       // This is register Rm, but using a 4-bit specifier. Used in NEON\n       // by-element instructions.\n-      reg_num = (instr->Rm() & 0xf);\n+      reg_num = (instr->Rm() & 0xF);\n       break;\n     case 'a':\n       reg_num = instr->Ra();\n@@ -3545,8 +3542,6 @@ int DisassemblingDecoder::SubstituteRegisterField(Instruction* instr,\n       return field_len;\n     default:\n       UNREACHABLE();\n-      reg_type = CPURegister::kRegister;\n-      reg_size = kXRegSizeInBits;\n   }\n \n   if ((reg_type == CPURegister::kRegister) && (reg_num == kZeroRegCode) &&\n@@ -3569,7 +3564,7 @@ int DisassemblingDecoder::SubstituteImmediateField(Instruction* instr,\n         uint64_t imm = static_cast<uint64_t>(instr->ImmMoveWide())\n                        << (16 * instr->ShiftMoveWide());\n         if (format[5] == 'N') imm = ~imm;\n-        if (!instr->SixtyFourBits()) imm &= UINT64_C(0xffffffff);\n+        if (!instr->SixtyFourBits()) imm &= UINT64_C(0xFFFFFFFF);\n         AppendToOutput(\"#0x%\" PRIx64, imm);\n       } else {\n         DCHECK_EQ(format[5], 'L');\n@@ -3696,7 +3691,7 @@ int DisassemblingDecoder::SubstituteImmediateField(Instruction* instr,\n             vm_index = (vm_index << 1) | instr->NEONM();\n           }\n           AppendToOutput(\"%d\", vm_index);\n-          return strlen(\"IVByElemIndex\");\n+          return static_cast<int>(strlen(\"IVByElemIndex\"));\n         }\n         case 'I': {  // INS element.\n           if (strncmp(format, \"IVInsIndex\", strlen(\"IVInsIndex\")) == 0) {\n@@ -3709,11 +3704,11 @@ int DisassemblingDecoder::SubstituteImmediateField(Instruction* instr,\n               rn_index = imm4 >> tz;\n               if (strncmp(format, \"IVInsIndex1\", strlen(\"IVInsIndex1\")) == 0) {\n                 AppendToOutput(\"%d\", rd_index);\n-                return strlen(\"IVInsIndex1\");\n+                return static_cast<int>(strlen(\"IVInsIndex1\"));\n               } else if (strncmp(format, \"IVInsIndex2\",\n                                  strlen(\"IVInsIndex2\")) == 0) {\n                 AppendToOutput(\"%d\", rn_index);\n-                return strlen(\"IVInsIndex2\");\n+                return static_cast<int>(strlen(\"IVInsIndex2\"));\n               }\n             }\n             return 0;\n@@ -3728,38 +3723,38 @@ int DisassemblingDecoder::SubstituteImmediateField(Instruction* instr,\n               0) {\n             AppendToOutput(\"#0x%\" PRIx32 \" (%.4f)\", instr->ImmNEONabcdefgh(),\n                            instr->ImmNEONFP32());\n-            return strlen(\"IVMIImmFPSingle\");\n+            return static_cast<int>(strlen(\"IVMIImmFPSingle\"));\n           } else if (strncmp(format, \"IVMIImmFPDouble\",\n                              strlen(\"IVMIImmFPDouble\")) == 0) {\n             AppendToOutput(\"#0x%\" PRIx32 \" (%.4f)\", instr->ImmNEONabcdefgh(),\n                            instr->ImmNEONFP64());\n-            return strlen(\"IVMIImmFPDouble\");\n+            return static_cast<int>(strlen(\"IVMIImmFPDouble\"));\n           } else if (strncmp(format, \"IVMIImm8\", strlen(\"IVMIImm8\")) == 0) {\n             uint64_t imm8 = instr->ImmNEONabcdefgh();\n             AppendToOutput(\"#0x%\" PRIx64, imm8);\n-            return strlen(\"IVMIImm8\");\n+            return static_cast<int>(strlen(\"IVMIImm8\"));\n           } else if (strncmp(format, \"IVMIImm\", strlen(\"IVMIImm\")) == 0) {\n             uint64_t imm8 = instr->ImmNEONabcdefgh();\n             uint64_t imm = 0;\n             for (int i = 0; i < 8; ++i) {\n               if (imm8 & (1 << i)) {\n-                imm |= (UINT64_C(0xff) << (8 * i));\n+                imm |= (UINT64_C(0xFF) << (8 * i));\n               }\n             }\n             AppendToOutput(\"#0x%\" PRIx64, imm);\n-            return strlen(\"IVMIImm\");\n+            return static_cast<int>(strlen(\"IVMIImm\"));\n           } else if (strncmp(format, \"IVMIShiftAmt1\",\n                              strlen(\"IVMIShiftAmt1\")) == 0) {\n             int cmode = instr->NEONCmode();\n             int shift_amount = 8 * ((cmode >> 1) & 3);\n             AppendToOutput(\"#%d\", shift_amount);\n-            return strlen(\"IVMIShiftAmt1\");\n+            return static_cast<int>(strlen(\"IVMIShiftAmt1\"));\n           } else if (strncmp(format, \"IVMIShiftAmt2\",\n                              strlen(\"IVMIShiftAmt2\")) == 0) {\n             int cmode = instr->NEONCmode();\n             int shift_amount = 8 << (cmode & 1);\n             AppendToOutput(\"#%d\", shift_amount);\n-            return strlen(\"IVMIShiftAmt2\");\n+            return static_cast<int>(strlen(\"IVMIShiftAmt2\"));\n           } else {\n             UNIMPLEMENTED();\n             return 0;"
        },
        {
            "sha": "48909d5b2d8ea2d02ea1e60a2663960f4f12ea9f",
            "filename": "deps/v8/src/arm64/eh-frame-arm64.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Feh-frame-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Feh-frame-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Feh-frame-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -9,7 +9,6 @@ namespace v8 {\n namespace internal {\n \n static const int kX0DwarfCode = 0;\n-static const int kJsSpDwarfCode = 28;\n static const int kFpDwarfCode = 29;\n static const int kLrDwarfCode = 30;\n static const int kCSpDwarfCode = 31;\n@@ -29,13 +28,11 @@ void EhFrameWriter::WriteInitialStateInCie() {\n // static\n int EhFrameWriter::RegisterToDwarfCode(Register name) {\n   switch (name.code()) {\n-    case kRegCode_x28:\n-      return kJsSpDwarfCode;\n     case kRegCode_x29:\n       return kFpDwarfCode;\n     case kRegCode_x30:\n       return kLrDwarfCode;\n-    case kRegCode_x31:\n+    case kSPRegInternalCode:\n       return kCSpDwarfCode;\n     case kRegCode_x0:\n       return kX0DwarfCode;\n@@ -54,8 +51,6 @@ const char* EhFrameDisassembler::DwarfRegisterCodeToString(int code) {\n       return \"fp\";\n     case kLrDwarfCode:\n       return \"lr\";\n-    case kJsSpDwarfCode:\n-      return \"jssp\";\n     case kCSpDwarfCode:\n       return \"csp\";  // This could be zr as well\n     default:"
        },
        {
            "sha": "a33707978685bcb3a450babfa6998c12e1b0861f",
            "filename": "deps/v8/src/arm64/frame-constants-arm64.h",
            "status": "modified",
            "additions": 23,
            "deletions": 2,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fframe-constants-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fframe-constants-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fframe-constants-arm64.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -8,10 +8,31 @@\n namespace v8 {\n namespace internal {\n \n+// The layout of an EntryFrame is as follows:\n+//\n+//  slot      Entry frame\n+//       +---------------------+-----------------------\n+//   0   |  bad frame pointer  |  <-- frame ptr\n+//       |   (0xFFF.. FF)      |\n+//       |- - - - - - - - - - -|\n+//   1   | stack frame marker  |\n+//       |      (ENTRY)        |\n+//       |- - - - - - - - - - -|\n+//   2   | stack frame marker  |\n+//       |        (0)          |\n+//       |- - - - - - - - - - -|\n+//   3   |     C entry FP      |\n+//       |- - - - - - - - - - -|\n+//   4   |   JS entry frame    |\n+//       |       marker        |\n+//       |- - - - - - - - - - -|\n+//   5   |      padding        |  <-- stack ptr\n+//  -----+---------------------+-----------------------\n+//\n class EntryFrameConstants : public AllStatic {\n  public:\n-  static const int kCallerFPOffset =\n-      -(StandardFrameConstants::kFixedFrameSizeFromFp + kPointerSize);\n+  static const int kCallerFPOffset = -3 * kPointerSize;\n+  static const int kFixedFrameSize = 6 * kPointerSize;\n };\n \n class ExitFrameConstants : public TypedFrameConstants {"
        },
        {
            "sha": "0a1528741785cf408bfcdb48e0de26c7ded62db9",
            "filename": "deps/v8/src/arm64/instructions-arm64-constants.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Finstructions-arm64-constants.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Finstructions-arm64-constants.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Finstructions-arm64-constants.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -21,26 +21,26 @@ namespace internal {\n // then move this code back into instructions-arm64.cc with the same types\n // that client code uses.\n \n-extern const uint16_t kFP16PositiveInfinity = 0x7c00;\n-extern const uint16_t kFP16NegativeInfinity = 0xfc00;\n-extern const uint32_t kFP32PositiveInfinity = 0x7f800000;\n-extern const uint32_t kFP32NegativeInfinity = 0xff800000;\n-extern const uint64_t kFP64PositiveInfinity = 0x7ff0000000000000UL;\n-extern const uint64_t kFP64NegativeInfinity = 0xfff0000000000000UL;\n+extern const uint16_t kFP16PositiveInfinity = 0x7C00;\n+extern const uint16_t kFP16NegativeInfinity = 0xFC00;\n+extern const uint32_t kFP32PositiveInfinity = 0x7F800000;\n+extern const uint32_t kFP32NegativeInfinity = 0xFF800000;\n+extern const uint64_t kFP64PositiveInfinity = 0x7FF0000000000000UL;\n+extern const uint64_t kFP64NegativeInfinity = 0xFFF0000000000000UL;\n \n // This value is a signalling NaN as both a double and as a float (taking the\n // least-significant word).\n-extern const uint64_t kFP64SignallingNaN = 0x7ff000007f800001;\n-extern const uint32_t kFP32SignallingNaN = 0x7f800001;\n+extern const uint64_t kFP64SignallingNaN = 0x7FF000007F800001;\n+extern const uint32_t kFP32SignallingNaN = 0x7F800001;\n \n // A similar value, but as a quiet NaN.\n-extern const uint64_t kFP64QuietNaN = 0x7ff800007fc00001;\n-extern const uint32_t kFP32QuietNaN = 0x7fc00001;\n+extern const uint64_t kFP64QuietNaN = 0x7FF800007FC00001;\n+extern const uint32_t kFP32QuietNaN = 0x7FC00001;\n \n // The default NaN values (for FPCR.DN=1).\n-extern const uint64_t kFP64DefaultNaN = 0x7ff8000000000000UL;\n-extern const uint32_t kFP32DefaultNaN = 0x7fc00000;\n-extern const uint16_t kFP16DefaultNaN = 0x7e00;\n+extern const uint64_t kFP64DefaultNaN = 0x7FF8000000000000UL;\n+extern const uint32_t kFP32DefaultNaN = 0x7FC00000;\n+extern const uint16_t kFP16DefaultNaN = 0x7E00;\n \n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "8e9cce71973878e73b8af028988c6a83e5212017",
            "filename": "deps/v8/src/arm64/instrument-arm64.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Finstrument-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Finstrument-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Finstrument-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -189,8 +189,8 @@ void Instrument::DumpEventMarker(unsigned marker) {\n   // line.\n   static Counter* counter = GetCounter(\"Instruction\");\n \n-  fprintf(output_stream_, \"# %c%c @ %\" PRId64 \"\\n\", marker & 0xff,\n-          (marker >> 8) & 0xff, counter->count());\n+  fprintf(output_stream_, \"# %c%c @ %\" PRId64 \"\\n\", marker & 0xFF,\n+          (marker >> 8) & 0xFF, counter->count());\n }\n \n "
        },
        {
            "sha": "17b058bd013797701b6094928fa9b34659eef2a1",
            "filename": "deps/v8/src/arm64/interface-descriptors-arm64.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Finterface-descriptors-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Finterface-descriptors-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Finterface-descriptors-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -45,8 +45,6 @@ const Register LoadDescriptor::SlotRegister() { return x0; }\n \n const Register LoadWithVectorDescriptor::VectorRegister() { return x3; }\n \n-const Register LoadICProtoArrayDescriptor::HandlerRegister() { return x4; }\n-\n const Register StoreDescriptor::ReceiverRegister() { return x1; }\n const Register StoreDescriptor::NameRegister() { return x2; }\n const Register StoreDescriptor::ValueRegister() { return x0; }\n@@ -209,6 +207,11 @@ void TransitionElementsKindDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n+void AbortJSDescriptor::InitializePlatformSpecific(\n+    CallInterfaceDescriptorData* data) {\n+  Register registers[] = {x1};\n+  data->InitializePlatformSpecific(arraysize(registers), registers);\n+}\n \n void AllocateHeapNumberDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {"
        },
        {
            "sha": "0861551d8977482dd9b7327396c771d12b81b8b7",
            "filename": "deps/v8/src/arm64/macro-assembler-arm64-inl.h",
            "status": "modified",
            "additions": 25,
            "deletions": 29,
            "changes": 54,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64-inl.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -1048,7 +1048,6 @@ void MacroAssembler::AlignAndSetCSPForFrame() {\n   DCHECK_GE(sp_alignment, 16);\n   DCHECK(base::bits::IsPowerOfTwo(sp_alignment));\n   Bic(csp, StackPointer(), sp_alignment - 1);\n-  SetStackPointer(csp);\n }\n \n void TurboAssembler::BumpSystemStackPointer(const Operand& space) {\n@@ -1140,22 +1139,6 @@ void MacroAssembler::SmiUntagToFloat(VRegister dst, Register src) {\n   Scvtf(dst, src, kSmiShift);\n }\n \n-\n-void MacroAssembler::SmiTagAndPush(Register src) {\n-  STATIC_ASSERT((static_cast<unsigned>(kSmiShift) == kWRegSizeInBits) &&\n-                (static_cast<unsigned>(kSmiValueSize) == kWRegSizeInBits) &&\n-                (kSmiTag == 0));\n-  Push(src.W(), wzr);\n-}\n-\n-\n-void MacroAssembler::SmiTagAndPush(Register src1, Register src2) {\n-  STATIC_ASSERT((static_cast<unsigned>(kSmiShift) == kWRegSizeInBits) &&\n-                (static_cast<unsigned>(kSmiValueSize) == kWRegSizeInBits) &&\n-                (kSmiTag == 0));\n-  Push(src1.W(), wzr, src2.W(), wzr);\n-}\n-\n void TurboAssembler::JumpIfSmi(Register value, Label* smi_label,\n                                Label* not_smi_label) {\n   STATIC_ASSERT((kSmiTagSize == 1) && (kSmiTag == 0));\n@@ -1222,7 +1205,7 @@ void MacroAssembler::ObjectTag(Register tagged_obj, Register obj) {\n   if (emit_debug_code()) {\n     Label ok;\n     Tbz(obj, 0, &ok);\n-    Abort(kObjectTagged);\n+    Abort(AbortReason::kObjectTagged);\n     Bind(&ok);\n   }\n   Orr(tagged_obj, obj, kHeapObjectTag);\n@@ -1234,7 +1217,7 @@ void MacroAssembler::ObjectUntag(Register untagged_obj, Register obj) {\n   if (emit_debug_code()) {\n     Label ok;\n     Tbnz(obj, 0, &ok);\n-    Abort(kObjectNotTagged);\n+    Abort(AbortReason::kObjectNotTagged);\n     Bind(&ok);\n   }\n   Bic(untagged_obj, obj, kHeapObjectTag);\n@@ -1246,7 +1229,10 @@ void TurboAssembler::Push(Handle<HeapObject> handle) {\n   UseScratchRegisterScope temps(this);\n   Register tmp = temps.AcquireX();\n   Mov(tmp, Operand(handle));\n-  Push(tmp);\n+  // This is only used in test-heap.cc, for generating code that is not\n+  // executed. Push a padding slot together with the handle here, to\n+  // satisfy the alignment requirement.\n+  Push(padreg, tmp);\n }\n \n void TurboAssembler::Push(Smi* smi) {\n@@ -1355,21 +1341,31 @@ void TurboAssembler::Drop(const Register& count, uint64_t unit_size) {\n \n void TurboAssembler::DropArguments(const Register& count,\n                                    ArgumentsCountMode mode) {\n+  int extra_slots = 1;  // Padding slot.\n   if (mode == kCountExcludesReceiver) {\n-    UseScratchRegisterScope temps(this);\n-    Register tmp = temps.AcquireX();\n-    Add(tmp, count, 1);\n-    Drop(tmp);\n-  } else {\n-    Drop(count);\n+    // Add a slot for the receiver.\n+    ++extra_slots;\n+  }\n+  UseScratchRegisterScope temps(this);\n+  Register tmp = temps.AcquireX();\n+  Add(tmp, count, extra_slots);\n+  Bic(tmp, tmp, 1);\n+  Drop(tmp, kXRegSize);\n+}\n+\n+void TurboAssembler::DropArguments(int64_t count, ArgumentsCountMode mode) {\n+  if (mode == kCountExcludesReceiver) {\n+    // Add a slot for the receiver.\n+    ++count;\n   }\n+  Drop(RoundUp(count, 2), kXRegSize);\n }\n \n-void TurboAssembler::DropSlots(int64_t count, uint64_t unit_size) {\n-  Drop(count, unit_size);\n+void TurboAssembler::DropSlots(int64_t count) {\n+  Drop(RoundUp(count, 2), kXRegSize);\n }\n \n-void TurboAssembler::PushArgument(const Register& arg) { Push(arg); }\n+void TurboAssembler::PushArgument(const Register& arg) { Push(padreg, arg); }\n \n void MacroAssembler::DropBySMI(const Register& count_smi, uint64_t unit_size) {\n   DCHECK(unit_size == 0 || base::bits::IsPowerOfTwo(unit_size));"
        },
        {
            "sha": "3869046f7494fb2e37c524f7657f7b86c6a24e4a",
            "filename": "deps/v8/src/arm64/macro-assembler-arm64.cc",
            "status": "modified",
            "additions": 115,
            "deletions": 214,
            "changes": 329,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -44,7 +44,6 @@ TurboAssembler::TurboAssembler(Isolate* isolate, void* buffer, int buffer_size,\n #endif\n       tmp_list_(DefaultTmpList()),\n       fptmp_list_(DefaultFPTmpList()),\n-      sp_(jssp),\n       use_real_aborts_(true) {\n   if (create_code_object == CodeObjectRequired::kYes) {\n     code_object_ =\n@@ -160,7 +159,7 @@ void TurboAssembler::LogicalMacro(const Register& rd, const Register& rn,\n           UNREACHABLE();\n       }\n     } else if ((rd.Is64Bits() && (immediate == -1L)) ||\n-               (rd.Is32Bits() && (immediate == 0xffffffffL))) {\n+               (rd.Is32Bits() && (immediate == 0xFFFFFFFFL))) {\n       switch (op) {\n         case AND:\n           Mov(rd, rn);\n@@ -252,15 +251,15 @@ void TurboAssembler::Mov(const Register& rd, uint64_t imm) {\n     // Generic immediate case. Imm will be represented by\n     //   [imm3, imm2, imm1, imm0], where each imm is 16 bits.\n     // A move-zero or move-inverted is generated for the first non-zero or\n-    // non-0xffff immX, and a move-keep for subsequent non-zero immX.\n+    // non-0xFFFF immX, and a move-keep for subsequent non-zero immX.\n \n     uint64_t ignored_halfword = 0;\n     bool invert_move = false;\n-    // If the number of 0xffff halfwords is greater than the number of 0x0000\n+    // If the number of 0xFFFF halfwords is greater than the number of 0x0000\n     // halfwords, it's more efficient to use move-inverted.\n     if (CountClearHalfWords(~imm, reg_size) >\n         CountClearHalfWords(imm, reg_size)) {\n-      ignored_halfword = 0xffffL;\n+      ignored_halfword = 0xFFFFL;\n       invert_move = true;\n     }\n \n@@ -274,11 +273,11 @@ void TurboAssembler::Mov(const Register& rd, uint64_t imm) {\n     DCHECK_EQ(reg_size % 16, 0);\n     bool first_mov_done = false;\n     for (int i = 0; i < (rd.SizeInBits() / 16); i++) {\n-      uint64_t imm16 = (imm >> (16 * i)) & 0xffffL;\n+      uint64_t imm16 = (imm >> (16 * i)) & 0xFFFFL;\n       if (imm16 != ignored_halfword) {\n         if (!first_mov_done) {\n           if (invert_move) {\n-            movn(temp, (~imm16) & 0xffffL, 16 * i);\n+            movn(temp, (~imm16) & 0xFFFFL, 16 * i);\n           } else {\n             movz(temp, imm16, 16 * i);\n           }\n@@ -356,18 +355,18 @@ void TurboAssembler::Mov(const Register& rd, const Operand& operand,\n \n void TurboAssembler::Movi16bitHelper(const VRegister& vd, uint64_t imm) {\n   DCHECK(is_uint16(imm));\n-  int byte1 = (imm & 0xff);\n-  int byte2 = ((imm >> 8) & 0xff);\n+  int byte1 = (imm & 0xFF);\n+  int byte2 = ((imm >> 8) & 0xFF);\n   if (byte1 == byte2) {\n     movi(vd.Is64Bits() ? vd.V8B() : vd.V16B(), byte1);\n   } else if (byte1 == 0) {\n     movi(vd, byte2, LSL, 8);\n   } else if (byte2 == 0) {\n     movi(vd, byte1);\n-  } else if (byte1 == 0xff) {\n-    mvni(vd, ~byte2 & 0xff, LSL, 8);\n-  } else if (byte2 == 0xff) {\n-    mvni(vd, ~byte1 & 0xff);\n+  } else if (byte1 == 0xFF) {\n+    mvni(vd, ~byte2 & 0xFF, LSL, 8);\n+  } else if (byte2 == 0xFF) {\n+    mvni(vd, ~byte1 & 0xFF);\n   } else {\n     UseScratchRegisterScope temps(this);\n     Register temp = temps.AcquireW();\n@@ -382,11 +381,11 @@ void TurboAssembler::Movi32bitHelper(const VRegister& vd, uint64_t imm) {\n   uint8_t bytes[sizeof(imm)];\n   memcpy(bytes, &imm, sizeof(imm));\n \n-  // All bytes are either 0x00 or 0xff.\n+  // All bytes are either 0x00 or 0xFF.\n   {\n     bool all0orff = true;\n     for (int i = 0; i < 4; ++i) {\n-      if ((bytes[i] != 0) && (bytes[i] != 0xff)) {\n+      if ((bytes[i] != 0) && (bytes[i] != 0xFF)) {\n         all0orff = false;\n         break;\n       }\n@@ -400,47 +399,47 @@ void TurboAssembler::Movi32bitHelper(const VRegister& vd, uint64_t imm) {\n \n   // Of the 4 bytes, only one byte is non-zero.\n   for (int i = 0; i < 4; i++) {\n-    if ((imm & (0xff << (i * 8))) == imm) {\n+    if ((imm & (0xFF << (i * 8))) == imm) {\n       movi(vd, bytes[i], LSL, i * 8);\n       return;\n     }\n   }\n \n-  // Of the 4 bytes, only one byte is not 0xff.\n+  // Of the 4 bytes, only one byte is not 0xFF.\n   for (int i = 0; i < 4; i++) {\n-    uint32_t mask = ~(0xff << (i * 8));\n+    uint32_t mask = ~(0xFF << (i * 8));\n     if ((imm & mask) == mask) {\n-      mvni(vd, ~bytes[i] & 0xff, LSL, i * 8);\n+      mvni(vd, ~bytes[i] & 0xFF, LSL, i * 8);\n       return;\n     }\n   }\n \n   // Immediate is of the form 0x00MMFFFF.\n-  if ((imm & 0xff00ffff) == 0x0000ffff) {\n+  if ((imm & 0xFF00FFFF) == 0x0000FFFF) {\n     movi(vd, bytes[2], MSL, 16);\n     return;\n   }\n \n   // Immediate is of the form 0x0000MMFF.\n-  if ((imm & 0xffff00ff) == 0x000000ff) {\n+  if ((imm & 0xFFFF00FF) == 0x000000FF) {\n     movi(vd, bytes[1], MSL, 8);\n     return;\n   }\n \n   // Immediate is of the form 0xFFMM0000.\n-  if ((imm & 0xff00ffff) == 0xff000000) {\n-    mvni(vd, ~bytes[2] & 0xff, MSL, 16);\n+  if ((imm & 0xFF00FFFF) == 0xFF000000) {\n+    mvni(vd, ~bytes[2] & 0xFF, MSL, 16);\n     return;\n   }\n   // Immediate is of the form 0xFFFFMM00.\n-  if ((imm & 0xffff00ff) == 0xffff0000) {\n-    mvni(vd, ~bytes[1] & 0xff, MSL, 8);\n+  if ((imm & 0xFFFF00FF) == 0xFFFF0000) {\n+    mvni(vd, ~bytes[1] & 0xFF, MSL, 8);\n     return;\n   }\n \n   // Top and bottom 16-bits are equal.\n-  if (((imm >> 16) & 0xffff) == (imm & 0xffff)) {\n-    Movi16bitHelper(vd.Is64Bits() ? vd.V4H() : vd.V8H(), imm & 0xffff);\n+  if (((imm >> 16) & 0xFFFF) == (imm & 0xFFFF)) {\n+    Movi16bitHelper(vd.Is64Bits() ? vd.V4H() : vd.V8H(), imm & 0xFFFF);\n     return;\n   }\n \n@@ -454,12 +453,12 @@ void TurboAssembler::Movi32bitHelper(const VRegister& vd, uint64_t imm) {\n }\n \n void TurboAssembler::Movi64bitHelper(const VRegister& vd, uint64_t imm) {\n-  // All bytes are either 0x00 or 0xff.\n+  // All bytes are either 0x00 or 0xFF.\n   {\n     bool all0orff = true;\n     for (int i = 0; i < 8; ++i) {\n-      int byteval = (imm >> (i * 8)) & 0xff;\n-      if (byteval != 0 && byteval != 0xff) {\n+      int byteval = (imm >> (i * 8)) & 0xFF;\n+      if (byteval != 0 && byteval != 0xFF) {\n         all0orff = false;\n         break;\n       }\n@@ -471,8 +470,8 @@ void TurboAssembler::Movi64bitHelper(const VRegister& vd, uint64_t imm) {\n   }\n \n   // Top and bottom 32-bits are equal.\n-  if (((imm >> 32) & 0xffffffff) == (imm & 0xffffffff)) {\n-    Movi32bitHelper(vd.Is64Bits() ? vd.V2S() : vd.V4S(), imm & 0xffffffff);\n+  if (((imm >> 32) & 0xFFFFFFFF) == (imm & 0xFFFFFFFF)) {\n+    Movi32bitHelper(vd.Is64Bits() ? vd.V2S() : vd.V4S(), imm & 0xFFFFFFFF);\n     return;\n   }\n \n@@ -547,7 +546,7 @@ unsigned TurboAssembler::CountClearHalfWords(uint64_t imm, unsigned reg_size) {\n   DCHECK_EQ(reg_size % 8, 0);\n   int count = 0;\n   for (unsigned i = 0; i < (reg_size / 16); i++) {\n-    if ((imm & 0xffff) == 0) {\n+    if ((imm & 0xFFFF) == 0) {\n       count++;\n     }\n     imm >>= 16;\n@@ -563,9 +562,8 @@ bool TurboAssembler::IsImmMovz(uint64_t imm, unsigned reg_size) {\n   return CountClearHalfWords(imm, reg_size) >= ((reg_size / 16) - 1);\n }\n \n-\n // The movn instruction can generate immediates containing an arbitrary 16-bit\n-// half-word, with remaining bits set, eg. 0xffff1234, 0xffff1234ffffffff.\n+// half-word, with remaining bits set, eg. 0xFFFF1234, 0xFFFF1234FFFFFFFF.\n bool TurboAssembler::IsImmMovn(uint64_t imm, unsigned reg_size) {\n   return IsImmMovz(~imm, reg_size);\n }\n@@ -1375,7 +1373,7 @@ void TurboAssembler::Poke(const CPURegister& src, const Operand& offset) {\n     DCHECK_GE(offset.ImmediateValue(), 0);\n   } else if (emit_debug_code()) {\n     Cmp(xzr, offset);\n-    Check(le, kStackAccessBelowStackPointer);\n+    Check(le, AbortReason::kStackAccessBelowStackPointer);\n   }\n \n   Str(src, MemOperand(StackPointer(), offset));\n@@ -1387,7 +1385,7 @@ void MacroAssembler::Peek(const CPURegister& dst, const Operand& offset) {\n     DCHECK_GE(offset.ImmediateValue(), 0);\n   } else if (emit_debug_code()) {\n     Cmp(xzr, offset);\n-    Check(le, kStackAccessBelowStackPointer);\n+    Check(le, AbortReason::kStackAccessBelowStackPointer);\n   }\n \n   Ldr(dst, MemOperand(StackPointer(), offset));\n@@ -1426,7 +1424,7 @@ void MacroAssembler::PushCalleeSavedRegisters() {\n   stp(d8, d9, tos);\n \n   stp(x29, x30, tos);\n-  stp(x27, x28, tos);    // x28 = jssp\n+  stp(x27, x28, tos);\n   stp(x25, x26, tos);\n   stp(x23, x24, tos);\n   stp(x21, x22, tos);\n@@ -1448,7 +1446,7 @@ void MacroAssembler::PopCalleeSavedRegisters() {\n   ldp(x21, x22, tos);\n   ldp(x23, x24, tos);\n   ldp(x25, x26, tos);\n-  ldp(x27, x28, tos);    // x28 = jssp\n+  ldp(x27, x28, tos);\n   ldp(x29, x30, tos);\n \n   ldp(d8, d9, tos);\n@@ -1479,7 +1477,7 @@ void TurboAssembler::AssertStackConsistency() {\n       { DontEmitDebugCodeScope dont_emit_debug_code_scope(this);\n         // Restore StackPointer().\n         sub(StackPointer(), csp, StackPointer());\n-        Abort(kTheCurrentStackPointerIsBelowCsp);\n+        Abort(AbortReason::kTheCurrentStackPointerIsBelowCsp);\n       }\n \n       bind(&ok);\n@@ -1531,7 +1529,7 @@ void TurboAssembler::CopyDoubleWords(Register dst, Register src, Register count,\n     Subs(pointer1, pointer1, pointer2);\n     B(lt, &pointer1_below_pointer2);\n     Cmp(pointer1, count);\n-    Check(ge, kOffsetOutOfRange);\n+    Check(ge, AbortReason::kOffsetOutOfRange);\n     Bind(&pointer1_below_pointer2);\n     Add(pointer1, pointer1, pointer2);\n   }\n@@ -1595,7 +1593,7 @@ void TurboAssembler::AssertFPCRState(Register fpcr) {\n     B(eq, &done);\n \n     Bind(&unexpected_mode);\n-    Abort(kUnexpectedFPCRMode);\n+    Abort(AbortReason::kUnexpectedFPCRMode);\n \n     Bind(&done);\n   }\n@@ -1632,15 +1630,15 @@ void TurboAssembler::Move(Register dst, Register src) { Mov(dst, src); }\n void TurboAssembler::Move(Register dst, Handle<HeapObject> x) { Mov(dst, x); }\n void TurboAssembler::Move(Register dst, Smi* src) { Mov(dst, src); }\n \n-void TurboAssembler::AssertSmi(Register object, BailoutReason reason) {\n+void TurboAssembler::AssertSmi(Register object, AbortReason reason) {\n   if (emit_debug_code()) {\n     STATIC_ASSERT(kSmiTag == 0);\n     Tst(object, kSmiTagMask);\n     Check(eq, reason);\n   }\n }\n \n-void MacroAssembler::AssertNotSmi(Register object, BailoutReason reason) {\n+void MacroAssembler::AssertNotSmi(Register object, AbortReason reason) {\n   if (emit_debug_code()) {\n     STATIC_ASSERT(kSmiTag == 0);\n     Tst(object, kSmiTagMask);\n@@ -1650,44 +1648,44 @@ void MacroAssembler::AssertNotSmi(Register object, BailoutReason reason) {\n \n void MacroAssembler::AssertFixedArray(Register object) {\n   if (emit_debug_code()) {\n-    AssertNotSmi(object, kOperandIsASmiAndNotAFixedArray);\n+    AssertNotSmi(object, AbortReason::kOperandIsASmiAndNotAFixedArray);\n \n     UseScratchRegisterScope temps(this);\n     Register temp = temps.AcquireX();\n \n     CompareObjectType(object, temp, temp, FIXED_ARRAY_TYPE);\n-    Check(eq, kOperandIsNotAFixedArray);\n+    Check(eq, AbortReason::kOperandIsNotAFixedArray);\n   }\n }\n \n void MacroAssembler::AssertFunction(Register object) {\n   if (emit_debug_code()) {\n-    AssertNotSmi(object, kOperandIsASmiAndNotAFunction);\n+    AssertNotSmi(object, AbortReason::kOperandIsASmiAndNotAFunction);\n \n     UseScratchRegisterScope temps(this);\n     Register temp = temps.AcquireX();\n \n     CompareObjectType(object, temp, temp, JS_FUNCTION_TYPE);\n-    Check(eq, kOperandIsNotAFunction);\n+    Check(eq, AbortReason::kOperandIsNotAFunction);\n   }\n }\n \n \n void MacroAssembler::AssertBoundFunction(Register object) {\n   if (emit_debug_code()) {\n-    AssertNotSmi(object, kOperandIsASmiAndNotABoundFunction);\n+    AssertNotSmi(object, AbortReason::kOperandIsASmiAndNotABoundFunction);\n \n     UseScratchRegisterScope temps(this);\n     Register temp = temps.AcquireX();\n \n     CompareObjectType(object, temp, temp, JS_BOUND_FUNCTION_TYPE);\n-    Check(eq, kOperandIsNotABoundFunction);\n+    Check(eq, AbortReason::kOperandIsNotABoundFunction);\n   }\n }\n \n void MacroAssembler::AssertGeneratorObject(Register object) {\n   if (!emit_debug_code()) return;\n-  AssertNotSmi(object, kOperandIsASmiAndNotAGeneratorObject);\n+  AssertNotSmi(object, AbortReason::kOperandIsASmiAndNotAGeneratorObject);\n \n   // Load map\n   UseScratchRegisterScope temps(this);\n@@ -1704,7 +1702,7 @@ void MacroAssembler::AssertGeneratorObject(Register object) {\n \n   bind(&do_check);\n   // Restore generator object to register and perform assertion\n-  Check(eq, kOperandIsNotAGeneratorObject);\n+  Check(eq, AbortReason::kOperandIsNotAGeneratorObject);\n }\n \n void MacroAssembler::AssertUndefinedOrAllocationSite(Register object) {\n@@ -1716,7 +1714,7 @@ void MacroAssembler::AssertUndefinedOrAllocationSite(Register object) {\n     JumpIfRoot(object, Heap::kUndefinedValueRootIndex, &done_checking);\n     Ldr(scratch, FieldMemOperand(object, HeapObject::kMapOffset));\n     CompareRoot(scratch, Heap::kAllocationSiteMapRootIndex);\n-    Assert(eq, kExpectedUndefinedOrCell);\n+    Assert(eq, AbortReason::kExpectedUndefinedOrCell);\n     Bind(&done_checking);\n   }\n }\n@@ -1726,7 +1724,7 @@ void TurboAssembler::AssertPositiveOrZero(Register value) {\n     Label done;\n     int sign_bit = value.Is64Bits() ? kXSignBit : kWSignBit;\n     Tbz(value, sign_bit, &done);\n-    Abort(kUnexpectedNegativeValue);\n+    Abort(AbortReason::kUnexpectedNegativeValue);\n     Bind(&done);\n   }\n }\n@@ -1855,72 +1853,14 @@ void TurboAssembler::CallCFunction(Register function, int num_of_reg_args,\n     DCHECK_LE(num_of_double_args + num_of_reg_args, 2);\n   }\n \n-  // We rely on the frame alignment being 16 bytes, which means we never need\n-  // to align the CSP by an unknown number of bytes and we always know the delta\n-  // between the stack pointer and the frame pointer.\n-  DCHECK_EQ(ActivationFrameAlignment(), 16);\n-\n-  // If the stack pointer is not csp, we need to derive an aligned csp from the\n-  // current stack pointer.\n-  const Register old_stack_pointer = StackPointer();\n-  if (!csp.Is(old_stack_pointer)) {\n-    AssertStackConsistency();\n-\n-    int sp_alignment = ActivationFrameAlignment();\n-    // The current stack pointer is a callee saved register, and is preserved\n-    // across the call.\n-    DCHECK(kCalleeSaved.IncludesAliasOf(old_stack_pointer));\n-\n-    // If more than eight arguments are passed to the function, we expect the\n-    // ninth argument onwards to have been placed on the csp-based stack\n-    // already. We assume csp already points to the last stack-passed argument\n-    // in that case.\n-    // Otherwise, align and synchronize the system stack pointer with jssp.\n-    if (num_of_reg_args <= kRegisterPassedArguments) {\n-      Bic(csp, old_stack_pointer, sp_alignment - 1);\n-    }\n-    SetStackPointer(csp);\n-  }\n-\n   // Call directly. The function called cannot cause a GC, or allow preemption,\n   // so the return address in the link register stays correct.\n   Call(function);\n \n-  if (csp.Is(old_stack_pointer)) {\n-    if (num_of_reg_args > kRegisterPassedArguments) {\n-      // Drop the register passed arguments.\n-      int claim_slots = RoundUp(num_of_reg_args - kRegisterPassedArguments, 2);\n-      Drop(claim_slots);\n-    }\n-  } else {\n-    DCHECK(jssp.Is(old_stack_pointer));\n-    if (emit_debug_code()) {\n-      UseScratchRegisterScope temps(this);\n-      Register temp = temps.AcquireX();\n-\n-      if (num_of_reg_args > kRegisterPassedArguments) {\n-        // We don't need to drop stack arguments, as the stack pointer will be\n-        // jssp when returning from this function. However, in debug builds, we\n-        // can check that jssp is as expected.\n-        int claim_slots =\n-            RoundUp(num_of_reg_args - kRegisterPassedArguments, 2);\n-\n-        // Check jssp matches the previous value on the stack.\n-        Ldr(temp, MemOperand(csp, claim_slots * kPointerSize));\n-        Cmp(jssp, temp);\n-        Check(eq, kTheStackWasCorruptedByMacroAssemblerCall);\n-      } else {\n-        // Because the stack pointer must be aligned on a 16-byte boundary, the\n-        // aligned csp can be up to 12 bytes below the jssp. This is the case\n-        // where we only pushed one W register on top of an aligned jssp.\n-        Sub(temp, csp, old_stack_pointer);\n-        // We want temp <= 0 && temp >= -12.\n-        Cmp(temp, 0);\n-        Ccmp(temp, -12, NFlag, le);\n-        Check(ge, kTheStackWasCorruptedByMacroAssemblerCall);\n-      }\n-    }\n-    SetStackPointer(old_stack_pointer);\n+  if (num_of_reg_args > kRegisterPassedArguments) {\n+    // Drop the register passed arguments.\n+    int claim_slots = RoundUp(num_of_reg_args - kRegisterPassedArguments, 2);\n+    Drop(claim_slots);\n   }\n }\n \n@@ -1997,10 +1937,10 @@ void TurboAssembler::Call(Address target, RelocInfo::Mode rmode) {\n     // Addresses are 48 bits so we never need to load the upper 16 bits.\n     uint64_t imm = reinterpret_cast<uint64_t>(target);\n     // If we don't use ARM tagged addresses, the 16 higher bits must be 0.\n-    DCHECK_EQ((imm >> 48) & 0xffff, 0);\n-    movz(temp, (imm >> 0) & 0xffff, 0);\n-    movk(temp, (imm >> 16) & 0xffff, 16);\n-    movk(temp, (imm >> 32) & 0xffff, 32);\n+    DCHECK_EQ((imm >> 48) & 0xFFFF, 0);\n+    movz(temp, (imm >> 0) & 0xFFFF, 0);\n+    movk(temp, (imm >> 16) & 0xFFFF, 16);\n+    movk(temp, (imm >> 32) & 0xFFFF, 32);\n   } else {\n     Ldr(temp, Immediate(reinterpret_cast<intptr_t>(target), rmode));\n   }\n@@ -2160,23 +2100,32 @@ void TurboAssembler::PrepareForTailCall(const ParameterCount& callee_args_count,\n   // after we drop current frame. We add kPointerSize to count the receiver\n   // argument which is not included into formal parameters count.\n   Register dst_reg = scratch0;\n-  add(dst_reg, fp, Operand(caller_args_count_reg, LSL, kPointerSizeLog2));\n-  add(dst_reg, dst_reg,\n-      Operand(StandardFrameConstants::kCallerSPOffset + kPointerSize));\n+  Add(dst_reg, fp, Operand(caller_args_count_reg, LSL, kPointerSizeLog2));\n+  Add(dst_reg, dst_reg, StandardFrameConstants::kCallerSPOffset + kPointerSize);\n+  // Round dst_reg up to a multiple of 16 bytes, so that we overwrite any\n+  // potential padding.\n+  Add(dst_reg, dst_reg, 15);\n+  Bic(dst_reg, dst_reg, 15);\n \n   Register src_reg = caller_args_count_reg;\n   // Calculate the end of source area. +kPointerSize is for the receiver.\n   if (callee_args_count.is_reg()) {\n-    add(src_reg, jssp, Operand(callee_args_count.reg(), LSL, kPointerSizeLog2));\n-    add(src_reg, src_reg, Operand(kPointerSize));\n+    Add(src_reg, StackPointer(),\n+        Operand(callee_args_count.reg(), LSL, kPointerSizeLog2));\n+    Add(src_reg, src_reg, kPointerSize);\n   } else {\n-    add(src_reg, jssp,\n-        Operand((callee_args_count.immediate() + 1) * kPointerSize));\n+    Add(src_reg, StackPointer(),\n+        (callee_args_count.immediate() + 1) * kPointerSize);\n   }\n \n+  // Round src_reg up to a multiple of 16 bytes, so we include any potential\n+  // padding in the copy.\n+  Add(src_reg, src_reg, 15);\n+  Bic(src_reg, src_reg, 15);\n+\n   if (FLAG_debug_code) {\n     Cmp(src_reg, dst_reg);\n-    Check(lo, kStackAccessBelowStackPointer);\n+    Check(lo, AbortReason::kStackAccessBelowStackPointer);\n   }\n \n   // Restore caller's frame pointer and return address now as they will be\n@@ -2196,12 +2145,11 @@ void TurboAssembler::PrepareForTailCall(const ParameterCount& callee_args_count,\n   Ldr(tmp_reg, MemOperand(src_reg, -kPointerSize, PreIndex));\n   Str(tmp_reg, MemOperand(dst_reg, -kPointerSize, PreIndex));\n   bind(&entry);\n-  Cmp(jssp, src_reg);\n+  Cmp(StackPointer(), src_reg);\n   B(ne, &loop);\n \n   // Leave current frame.\n-  Mov(jssp, dst_reg);\n-  SetStackPointer(jssp);\n+  Mov(StackPointer(), dst_reg);\n   AssertStackConsistency();\n }\n \n@@ -2412,12 +2360,12 @@ void TurboAssembler::TryConvertDoubleToInt64(Register result,\n   // the modulo operation on an integer register so we convert to a 64-bit\n   // integer.\n   //\n-  // Fcvtzs will saturate to INT64_MIN (0x800...00) or INT64_MAX (0x7ff...ff)\n+  // Fcvtzs will saturate to INT64_MIN (0x800...00) or INT64_MAX (0x7FF...FF)\n   // when the double is out of range. NaNs and infinities will be converted to 0\n   // (as ECMA-262 requires).\n   Fcvtzs(result.X(), double_input);\n \n-  // The values INT64_MIN (0x800...00) or INT64_MAX (0x7ff...ff) are not\n+  // The values INT64_MIN (0x800...00) or INT64_MAX (0x7FF...FF) are not\n   // representable using a double, so if the result is one of those then we know\n   // that saturation occurred, and we need to manually handle the conversion.\n   //\n@@ -2437,17 +2385,6 @@ void TurboAssembler::TruncateDoubleToIDelayed(Zone* zone, Register result,\n   // contain our truncated int32 result.\n   TryConvertDoubleToInt64(result, double_input, &done);\n \n-  const Register old_stack_pointer = StackPointer();\n-  if (csp.Is(old_stack_pointer)) {\n-    // This currently only happens during compiler-unittest. If it arises\n-    // during regular code generation the DoubleToI stub should be updated to\n-    // cope with csp and have an extra parameter indicating which stack pointer\n-    // it should use.\n-    Push(jssp, xzr);  // Push xzr to maintain csp required 16-bytes alignment.\n-    Mov(jssp, csp);\n-    SetStackPointer(jssp);\n-  }\n-\n   // If we fell through then inline version didn't succeed - call stub instead.\n   Push(lr, double_input);\n \n@@ -2458,21 +2395,14 @@ void TurboAssembler::TruncateDoubleToIDelayed(Zone* zone, Register result,\n   DCHECK_EQ(xzr.SizeInBytes(), double_input.SizeInBytes());\n   Pop(xzr, lr);  // xzr to drop the double input on the stack.\n \n-  if (csp.Is(old_stack_pointer)) {\n-    Mov(csp, jssp);\n-    SetStackPointer(csp);\n-    AssertStackConsistency();\n-    Pop(xzr, jssp);\n-  }\n-\n   Bind(&done);\n   // Keep our invariant that the upper 32 bits are zero.\n   Uxtw(result.W(), result.W());\n }\n \n void TurboAssembler::Prologue() {\n   Push(lr, fp, cp, x1);\n-  Add(fp, jssp, StandardFrameConstants::kFixedFrameSizeFromFp);\n+  Add(fp, StackPointer(), StandardFrameConstants::kFixedFrameSizeFromFp);\n }\n \n void TurboAssembler::EnterFrame(StackFrame::Type type) {\n@@ -2481,15 +2411,14 @@ void TurboAssembler::EnterFrame(StackFrame::Type type) {\n   Register code_reg = temps.AcquireX();\n \n   if (type == StackFrame::INTERNAL) {\n-    DCHECK(jssp.Is(StackPointer()));\n     Mov(type_reg, StackFrame::TypeToMarker(type));\n     Mov(code_reg, Operand(CodeObject()));\n     Push(lr, fp, type_reg, code_reg);\n-    Add(fp, jssp, InternalFrameConstants::kFixedFrameSizeFromFp);\n-    // jssp[4] : lr\n-    // jssp[3] : fp\n-    // jssp[1] : type\n-    // jssp[0] : [code object]\n+    Add(fp, StackPointer(), InternalFrameConstants::kFixedFrameSizeFromFp);\n+    // sp[4] : lr\n+    // sp[3] : fp\n+    // sp[1] : type\n+    // sp[0] : [code object]\n   } else if (type == StackFrame::WASM_COMPILED) {\n     DCHECK(csp.Is(StackPointer()));\n     Mov(type_reg, StackFrame::TypeToMarker(type));\n@@ -2502,7 +2431,6 @@ void TurboAssembler::EnterFrame(StackFrame::Type type) {\n     // csp[0] : for alignment\n   } else {\n     DCHECK_EQ(type, StackFrame::CONSTRUCT);\n-    DCHECK(jssp.Is(StackPointer()));\n     Mov(type_reg, StackFrame::TypeToMarker(type));\n \n     // Users of this frame type push a context pointer after the type field,\n@@ -2511,11 +2439,12 @@ void TurboAssembler::EnterFrame(StackFrame::Type type) {\n \n     // The context pointer isn't part of the fixed frame, so add an extra slot\n     // to account for it.\n-    Add(fp, jssp, TypedFrameConstants::kFixedFrameSizeFromFp + kPointerSize);\n-    // jssp[3] : lr\n-    // jssp[2] : fp\n-    // jssp[1] : type\n-    // jssp[0] : cp\n+    Add(fp, StackPointer(),\n+        TypedFrameConstants::kFixedFrameSizeFromFp + kPointerSize);\n+    // sp[3] : lr\n+    // sp[2] : fp\n+    // sp[1] : type\n+    // sp[0] : cp\n   }\n }\n \n@@ -2526,10 +2455,9 @@ void TurboAssembler::LeaveFrame(StackFrame::Type type) {\n     AssertStackConsistency();\n     Pop(fp, lr);\n   } else {\n-    DCHECK(jssp.Is(StackPointer()));\n     // Drop the execution stack down to the frame pointer and restore\n     // the caller frame pointer and return address.\n-    Mov(jssp, fp);\n+    Mov(StackPointer(), fp);\n     AssertStackConsistency();\n     Pop(fp, lr);\n   }\n@@ -2560,7 +2488,6 @@ void MacroAssembler::ExitFrameRestoreFPRegs() {\n void MacroAssembler::EnterExitFrame(bool save_doubles, const Register& scratch,\n                                     int extra_space,\n                                     StackFrame::Type frame_type) {\n-  DCHECK(jssp.Is(StackPointer()));\n   DCHECK(frame_type == StackFrame::EXIT ||\n          frame_type == StackFrame::BUILTIN_EXIT);\n \n@@ -2576,7 +2503,7 @@ void MacroAssembler::EnterExitFrame(bool save_doubles, const Register& scratch,\n   //          fp[-8]: STUB marker\n   //          fp[-16]: Space reserved for SPOffset.\n   //          fp[-24]: CodeObject()\n-  //  jssp -> fp[-32]: padding\n+  //    sp -> fp[-32]: padding\n   STATIC_ASSERT((2 * kPointerSize) == ExitFrameConstants::kCallerSPOffset);\n   STATIC_ASSERT((1 * kPointerSize) == ExitFrameConstants::kCallerPCOffset);\n   STATIC_ASSERT((0 * kPointerSize) == ExitFrameConstants::kCallerFPOffset);\n@@ -2610,23 +2537,11 @@ void MacroAssembler::EnterExitFrame(bool save_doubles, const Register& scratch,\n   //         fp[-16]: Space reserved for SPOffset.\n   //         fp[-24]: CodeObject()\n   //         fp[-24 - fp_size]: Saved doubles (if save_doubles is true).\n-  //         jssp[8]: Extra space reserved for caller (if extra_space != 0).\n-  // jssp -> jssp[0]: Space reserved for the return address.\n+  //         sp[8]: Extra space reserved for caller (if extra_space != 0).\n+  //   sp -> sp[0]: Space reserved for the return address.\n \n-  // Align and synchronize the system stack pointer with jssp.\n-  AlignAndSetCSPForFrame();\n   DCHECK(csp.Is(StackPointer()));\n \n-  //         fp[8]: CallerPC (lr)\n-  //   fp -> fp[0]: CallerFP (old fp)\n-  //         fp[-8]: STUB marker\n-  //         fp[-16]: Space reserved for SPOffset.\n-  //         fp[-24]: CodeObject()\n-  //         fp[-24 - fp_size]: Saved doubles (if save_doubles is true).\n-  //         csp[8]: Memory reserved for the caller if extra_space != 0.\n-  //                 Alignment padding, if necessary.\n-  //  csp -> csp[0]: Space reserved for the return address.\n-\n   // ExitFrame::GetStateForFramePointer expects to find the return address at\n   // the memory address immediately below the pointer stored in SPOffset.\n   // It is not safe to derive much else from SPOffset, because the size of the\n@@ -2638,7 +2553,8 @@ void MacroAssembler::EnterExitFrame(bool save_doubles, const Register& scratch,\n \n // Leave the current exit frame.\n void MacroAssembler::LeaveExitFrame(bool restore_doubles,\n-                                    const Register& scratch) {\n+                                    const Register& scratch,\n+                                    const Register& scratch2) {\n   DCHECK(csp.Is(StackPointer()));\n \n   if (restore_doubles) {\n@@ -2652,9 +2568,10 @@ void MacroAssembler::LeaveExitFrame(bool restore_doubles,\n \n   if (emit_debug_code()) {\n     // Also emit debug code to clear the cp in the top frame.\n+    Mov(scratch2, Operand(Context::kInvalidContext));\n     Mov(scratch, Operand(ExternalReference(IsolateAddressId::kContextAddress,\n                                            isolate())));\n-    Str(xzr, MemOperand(scratch));\n+    Str(scratch2, MemOperand(scratch));\n   }\n   // Clear the frame pointer from the top frame.\n   Mov(scratch, Operand(ExternalReference(IsolateAddressId::kCEntryFPAddress,\n@@ -2665,8 +2582,7 @@ void MacroAssembler::LeaveExitFrame(bool restore_doubles,\n   //         fp[8]: CallerPC (lr)\n   //   fp -> fp[0]: CallerFP (old fp)\n   //         fp[...]: The rest of the frame.\n-  Mov(jssp, fp);\n-  SetStackPointer(jssp);\n+  Mov(csp, fp);\n   AssertStackConsistency();\n   Pop(fp, lr);\n }\n@@ -2830,27 +2746,22 @@ void MacroAssembler::PushSafepointRegisters() {\n \n int MacroAssembler::SafepointRegisterStackIndex(int reg_code) {\n   // Make sure the safepoint registers list is what we expect.\n-  DCHECK_EQ(CPURegList::GetSafepointSavedRegisters().list(), 0x6ffcffff);\n+  DCHECK_EQ(CPURegList::GetSafepointSavedRegisters().list(), 0x6FFCFFFF);\n \n   // Safepoint registers are stored contiguously on the stack, but not all the\n   // registers are saved. The following registers are excluded:\n   //  - x16 and x17 (ip0 and ip1) because they shouldn't be preserved outside of\n   //    the macro assembler.\n-  //  - x28 (jssp) because JS stack pointer doesn't need to be included in\n-  //    safepoint registers.\n   //  - x31 (csp) because the system stack pointer doesn't need to be included\n   //    in safepoint registers.\n   //\n   // This function implements the mapping of register code to index into the\n   // safepoint register slots.\n   if ((reg_code >= 0) && (reg_code <= 15)) {\n     return reg_code;\n-  } else if ((reg_code >= 18) && (reg_code <= 27)) {\n+  } else if ((reg_code >= 18) && (reg_code <= 30)) {\n     // Skip ip0 and ip1.\n     return reg_code - 2;\n-  } else if ((reg_code == 29) || (reg_code == 30)) {\n-    // Also skip jssp.\n-    return reg_code - 3;\n   } else {\n     // This register has no safepoint register slot.\n     UNREACHABLE();\n@@ -2909,7 +2820,7 @@ void MacroAssembler::RecordWriteField(Register object, int offset,\n     Label ok;\n     Tst(scratch, kPointerSize - 1);\n     B(eq, &ok);\n-    Abort(kUnalignedCellInWriteBarrier);\n+    Abort(AbortReason::kUnalignedCellInWriteBarrier);\n     Bind(&ok);\n   }\n \n@@ -2975,11 +2886,9 @@ void TurboAssembler::CallRecordWriteStub(\n   Register fp_mode_parameter(callable.descriptor().GetRegisterParameter(\n       RecordWriteDescriptor::kFPMode));\n \n-  Push(object);\n-  Push(address);\n+  Push(object, address);\n \n-  Pop(slot_parameter);\n-  Pop(object_parameter);\n+  Pop(slot_parameter, object_parameter);\n \n   Mov(isolate_parameter, ExternalReference::isolate_address(isolate()));\n   Move(remembered_set_parameter, Smi::FromEnum(remembered_set_action));\n@@ -3008,7 +2917,7 @@ void MacroAssembler::RecordWrite(Register object, Register address,\n \n     Ldr(temp, MemOperand(address));\n     Cmp(temp, value);\n-    Check(eq, kWrongAddressOrValuePassedToRecordWrite);\n+    Check(eq, AbortReason::kWrongAddressOrValuePassedToRecordWrite);\n   }\n \n   // First, check if a write barrier is even needed. The tests below\n@@ -3052,47 +2961,40 @@ void MacroAssembler::RecordWrite(Register object, Register address,\n   }\n }\n \n-void TurboAssembler::Assert(Condition cond, BailoutReason reason) {\n+void TurboAssembler::Assert(Condition cond, AbortReason reason) {\n   if (emit_debug_code()) {\n     Check(cond, reason);\n   }\n }\n \n void MacroAssembler::AssertRegisterIsRoot(Register reg,\n                                           Heap::RootListIndex index,\n-                                          BailoutReason reason) {\n+                                          AbortReason reason) {\n   if (emit_debug_code()) {\n     CompareRoot(reg, index);\n     Check(eq, reason);\n   }\n }\n \n-void TurboAssembler::Check(Condition cond, BailoutReason reason) {\n+void TurboAssembler::Check(Condition cond, AbortReason reason) {\n   Label ok;\n   B(cond, &ok);\n   Abort(reason);\n   // Will not return here.\n   Bind(&ok);\n }\n \n-void TurboAssembler::Abort(BailoutReason reason) {\n+void TurboAssembler::Abort(AbortReason reason) {\n #ifdef DEBUG\n   RecordComment(\"Abort message: \");\n-  RecordComment(GetBailoutReason(reason));\n+  RecordComment(GetAbortReason(reason));\n \n   if (FLAG_trap_on_abort) {\n     Brk(0);\n     return;\n   }\n #endif\n \n-  // Abort is used in some contexts where csp is the stack pointer. In order to\n-  // simplify the CallRuntime code, make sure that jssp is the stack pointer.\n-  // There is no risk of register corruption here because Abort doesn't return.\n-  Register old_stack_pointer = StackPointer();\n-  SetStackPointer(jssp);\n-  Mov(jssp, old_stack_pointer);\n-\n   // We need some scratch registers for the MacroAssembler, so make sure we have\n   // some. This is safe here because Abort never returns.\n   RegList old_tmp_list = TmpList()->list();\n@@ -3128,11 +3030,10 @@ void TurboAssembler::Abort(BailoutReason reason) {\n     {\n       BlockPoolsScope scope(this);\n       Bind(&msg_address);\n-      EmitStringData(GetBailoutReason(reason));\n+      EmitStringData(GetAbortReason(reason));\n     }\n   }\n \n-  SetStackPointer(old_stack_pointer);\n   TmpList()->set_list(old_tmp_list);\n }\n \n@@ -3266,7 +3167,7 @@ void MacroAssembler::PrintfNoPreserve(const char * format,\n   // We don't pass any arguments on the stack, but we still need to align the C\n   // stack pointer to a 16-byte boundary for PCS compliance.\n   if (!csp.Is(StackPointer())) {\n-    Bic(csp, StackPointer(), 0xf);\n+    Bic(csp, StackPointer(), 0xF);\n   }\n \n   CallPrintf(arg_count, pcs);"
        },
        {
            "sha": "47c08f262261474d0df9c34565deea28c11e9a6b",
            "filename": "deps/v8/src/arm64/macro-assembler-arm64.h",
            "status": "modified",
            "additions": 26,
            "deletions": 56,
            "changes": 82,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -216,12 +216,6 @@ class TurboAssembler : public Assembler {\n   bool allow_macro_instructions() const { return allow_macro_instructions_; }\n #endif\n \n-  // Set the current stack pointer, but don't generate any code.\n-  inline void SetStackPointer(const Register& stack_pointer) {\n-    DCHECK(!TmpList()->IncludesAliasOf(stack_pointer));\n-    sp_ = stack_pointer;\n-  }\n-\n   // Activation support.\n   void EnterFrame(StackFrame::Type type);\n   void EnterFrame(StackFrame::Type type, bool load_constant_pool_pointer_reg) {\n@@ -574,17 +568,18 @@ class TurboAssembler : public Assembler {\n \n   // Calls Abort(msg) if the condition cond is not satisfied.\n   // Use --debug_code to enable.\n-  void Assert(Condition cond, BailoutReason reason);\n+  void Assert(Condition cond, AbortReason reason);\n \n-  void AssertSmi(Register object, BailoutReason reason = kOperandIsNotASmi);\n+  void AssertSmi(Register object,\n+                 AbortReason reason = AbortReason::kOperandIsNotASmi);\n \n   // Like Assert(), but always enabled.\n-  void Check(Condition cond, BailoutReason reason);\n+  void Check(Condition cond, AbortReason reason);\n \n   inline void Debug(const char* message, uint32_t code, Instr params = BREAK);\n \n   // Print a message to stderr and abort execution.\n-  void Abort(BailoutReason reason);\n+  void Abort(AbortReason reason);\n \n   // If emit_debug_code() is true, emit a run-time check to ensure that\n   // StackPointer() does not point below the system stack pointer.\n@@ -619,8 +614,8 @@ class TurboAssembler : public Assembler {\n   static CPURegList DefaultTmpList();\n   static CPURegList DefaultFPTmpList();\n \n-  // Return the current stack pointer, as set by SetStackPointer.\n-  inline const Register& StackPointer() const { return sp_; }\n+  // Return the stack pointer.\n+  inline const Register& StackPointer() const { return csp; }\n \n   // Move macros.\n   inline void Mvn(const Register& rd, uint64_t imm);\n@@ -711,25 +706,22 @@ class TurboAssembler : public Assembler {\n   inline void Drop(int64_t count, uint64_t unit_size = kXRegSize);\n   inline void Drop(const Register& count, uint64_t unit_size = kXRegSize);\n \n-  // Drop arguments from stack without actually accessing memory.\n-  // This will currently drop 'count' arguments from the stack.\n+  // Drop 'count' arguments from the stack, rounded up to a multiple of two,\n+  // without actually accessing memory.\n   // We assume the size of the arguments is the pointer size.\n   // An optional mode argument is passed, which can indicate we need to\n   // explicitly add the receiver to the count.\n-  // TODO(arm64): Update this to round up the number of bytes dropped to\n-  // a multiple of 16, so that we can remove jssp.\n   enum ArgumentsCountMode { kCountIncludesReceiver, kCountExcludesReceiver };\n   inline void DropArguments(const Register& count,\n                             ArgumentsCountMode mode = kCountIncludesReceiver);\n+  inline void DropArguments(int64_t count,\n+                            ArgumentsCountMode mode = kCountIncludesReceiver);\n \n-  // Drop slots from stack without actually accessing memory.\n-  // This will currently drop 'count' slots of the given size from the stack.\n-  // TODO(arm64): Update this to round up the number of bytes dropped to\n-  // a multiple of 16, so that we can remove jssp.\n-  inline void DropSlots(int64_t count, uint64_t unit_size = kXRegSize);\n+  // Drop 'count' slots from stack, rounded up to a multiple of two, without\n+  // actually accessing memory.\n+  inline void DropSlots(int64_t count);\n \n-  // Push a single argument to the stack.\n-  // TODO(arm64): Update this to push a padding slot above the argument.\n+  // Push a single argument, with padding, to the stack.\n   inline void PushArgument(const Register& arg);\n \n   // Re-synchronizes the system stack pointer (csp) with the current stack\n@@ -769,8 +761,7 @@ class TurboAssembler : public Assembler {\n   LS_MACRO_LIST(DECLARE_FUNCTION)\n #undef DECLARE_FUNCTION\n \n-  // Push or pop up to 4 registers of the same width to or from the stack,\n-  // using the current stack pointer as set by SetStackPointer.\n+  // Push or pop up to 4 registers of the same width to or from the stack.\n   //\n   // If an argument register is 'NoReg', all further arguments are also assumed\n   // to be 'NoReg', and are thus not pushed or popped.\n@@ -784,9 +775,8 @@ class TurboAssembler : public Assembler {\n   // It is not valid to pop into the same register more than once in one\n   // operation, not even into the zero register.\n   //\n-  // If the current stack pointer (as set by SetStackPointer) is csp, then it\n-  // must be aligned to 16 bytes on entry and the total size of the specified\n-  // registers must also be a multiple of 16 bytes.\n+  // The stack pointer must be aligned to 16 bytes on entry and the total size\n+  // of the specified registers must also be a multiple of 16 bytes.\n   //\n   // Even if the current stack pointer is not the system stack pointer (csp),\n   // Push (and derived methods) will still modify the system stack pointer in\n@@ -1291,9 +1281,6 @@ class TurboAssembler : public Assembler {\n   CPURegList tmp_list_;\n   CPURegList fptmp_list_;\n \n-  // The register to use as a stack pointer for stack operations.\n-  Register sp_;\n-\n   bool use_real_aborts_;\n \n   // Helps resolve branching to labels potentially out of range.\n@@ -1707,10 +1694,6 @@ class MacroAssembler : public TurboAssembler {\n   //\n   // Note that registers are not checked for invalid values. Use this method\n   // only if you know that the GC won't try to examine the values on the stack.\n-  //\n-  // This method must not be called unless the current stack pointer (as set by\n-  // SetStackPointer) is the system stack pointer (csp), and is aligned to\n-  // ActivationFrameAlignment().\n   void PushCalleeSavedRegisters();\n \n   // Restore the callee-saved registers (as defined by AAPCS64).\n@@ -1719,10 +1702,6 @@ class MacroAssembler : public TurboAssembler {\n   // thus come from higher addresses.\n   // Floating-point registers are popped after general-purpose registers, and\n   // thus come from higher addresses.\n-  //\n-  // This method must not be called unless the current stack pointer (as set by\n-  // SetStackPointer) is the system stack pointer (csp), and is aligned to\n-  // ActivationFrameAlignment().\n   void PopCalleeSavedRegisters();\n \n   // Align csp for a frame, as per ActivationFrameAlignment, and make it the\n@@ -1752,10 +1731,6 @@ class MacroAssembler : public TurboAssembler {\n   inline void SmiUntagToDouble(VRegister dst, Register src);\n   inline void SmiUntagToFloat(VRegister dst, Register src);\n \n-  // Tag and push in one step.\n-  inline void SmiTagAndPush(Register src);\n-  inline void SmiTagAndPush(Register src1, Register src2);\n-\n   inline void JumpIfNotSmi(Register value, Label* not_smi_label);\n   inline void JumpIfBothSmi(Register value1, Register value2,\n                             Label* both_smi_label,\n@@ -1771,7 +1746,8 @@ class MacroAssembler : public TurboAssembler {\n                                Label* not_smi_label);\n \n   // Abort execution if argument is a smi, enabled via --debug-code.\n-  void AssertNotSmi(Register object, BailoutReason reason = kOperandIsASmi);\n+  void AssertNotSmi(Register object,\n+                    AbortReason reason = AbortReason::kOperandIsASmi);\n \n   inline void ObjectTag(Register tagged_obj, Register obj);\n   inline void ObjectUntag(Register untagged_obj, Register obj);\n@@ -1948,19 +1924,14 @@ class MacroAssembler : public TurboAssembler {\n   // ---------------------------------------------------------------------------\n   // Frames.\n \n-  // The stack pointer has to switch between csp and jssp when setting up and\n-  // destroying the exit frame. Hence preserving/restoring the registers is\n-  // slightly more complicated than simple push/pop operations.\n   void ExitFramePreserveFPRegs();\n   void ExitFrameRestoreFPRegs();\n \n   // Enter exit frame. Exit frames are used when calling C code from generated\n   // (JavaScript) code.\n   //\n-  // The stack pointer must be jssp on entry, and will be set to csp by this\n-  // function. The frame pointer is also configured, but the only other\n-  // registers modified by this function are the provided scratch register, and\n-  // jssp.\n+  // The only registers modified by this function are the provided scratch\n+  // register, the frame pointer and the stack pointer.\n   //\n   // The 'extra_space' argument can be used to allocate some space in the exit\n   // frame that will be ignored by the GC. This space will be reserved in the\n@@ -1989,10 +1960,10 @@ class MacroAssembler : public TurboAssembler {\n   //  * Preserved doubles are restored (if restore_doubles is true).\n   //  * The frame information is removed from the top frame.\n   //  * The exit frame is dropped.\n-  //  * The stack pointer is reset to jssp.\n   //\n   // The stack pointer must be csp on entry.\n-  void LeaveExitFrame(bool save_doubles, const Register& scratch);\n+  void LeaveExitFrame(bool save_doubles, const Register& scratch,\n+                      const Register& scratch2);\n \n   // Load the global proxy from the current context.\n   void LoadGlobalProxy(Register dst) {\n@@ -2042,9 +2013,8 @@ class MacroAssembler : public TurboAssembler {\n   // Debugging.\n \n   void AssertRegisterIsRoot(\n-      Register reg,\n-      Heap::RootListIndex index,\n-      BailoutReason reason = kRegisterDidNotMatchExpectedRoot);\n+      Register reg, Heap::RootListIndex index,\n+      AbortReason reason = AbortReason::kRegisterDidNotMatchExpectedRoot);\n \n   // Abort if the specified register contains the invalid color bit pattern.\n   // The pattern must be in bits [1:0] of 'reg' register."
        },
        {
            "sha": "d0c464dfbe4567cbad76dc71130721fa3d07714e",
            "filename": "deps/v8/src/arm64/simulator-arm64.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 187,
            "changes": 227,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -98,13 +98,6 @@ SimSystemRegister SimSystemRegister::DefaultValueFor(SystemRegister id) {\n }\n \n \n-void Simulator::Initialize(Isolate* isolate) {\n-  if (isolate->simulator_initialized()) return;\n-  isolate->set_simulator_initialized(true);\n-  ExternalReference::set_redirector(isolate, &RedirectExternalReference);\n-}\n-\n-\n // Get the active Simulator for the current thread.\n Simulator* Simulator::current(Isolate* isolate) {\n   Isolate::PerIsolateThreadData* isolate_data =\n@@ -124,8 +117,7 @@ Simulator* Simulator::current(Isolate* isolate) {\n   return sim;\n }\n \n-\n-void Simulator::CallVoid(byte* entry, CallArgument* args) {\n+void Simulator::CallImpl(byte* entry, CallArgument* args) {\n   int index_x = 0;\n   int index_d = 0;\n \n@@ -167,63 +159,6 @@ void Simulator::CallVoid(byte* entry, CallArgument* args) {\n   set_sp(original_stack);\n }\n \n-\n-int64_t Simulator::CallInt64(byte* entry, CallArgument* args) {\n-  CallVoid(entry, args);\n-  return xreg(0);\n-}\n-\n-\n-double Simulator::CallDouble(byte* entry, CallArgument* args) {\n-  CallVoid(entry, args);\n-  return dreg(0);\n-}\n-\n-\n-int64_t Simulator::CallJS(byte* entry,\n-                          Object* new_target,\n-                          Object* target,\n-                          Object* revc,\n-                          int64_t argc,\n-                          Object*** argv) {\n-  CallArgument args[] = {\n-    CallArgument(new_target),\n-    CallArgument(target),\n-    CallArgument(revc),\n-    CallArgument(argc),\n-    CallArgument(argv),\n-    CallArgument::End()\n-  };\n-  return CallInt64(entry, args);\n-}\n-\n-\n-int64_t Simulator::CallRegExp(byte* entry,\n-                              String* input,\n-                              int64_t start_offset,\n-                              const byte* input_start,\n-                              const byte* input_end,\n-                              int* output,\n-                              int64_t output_size,\n-                              Address stack_base,\n-                              int64_t direct_call,\n-                              Isolate* isolate) {\n-  CallArgument args[] = {\n-    CallArgument(input),\n-    CallArgument(start_offset),\n-    CallArgument(input_start),\n-    CallArgument(input_end),\n-    CallArgument(output),\n-    CallArgument(output_size),\n-    CallArgument(stack_base),\n-    CallArgument(direct_call),\n-    CallArgument(isolate),\n-    CallArgument::End()\n-  };\n-  return CallInt64(entry, args);\n-}\n-\n-\n void Simulator::CheckPCSComplianceAndRun() {\n   // Adjust JS-based stack limit to C-based stack limit.\n   isolate_->stack_guard()->AdjustStackLimitForSimulator();\n@@ -350,6 +285,11 @@ uintptr_t Simulator::StackLimit(uintptr_t c_limit) const {\n   return stack_limit_ + 1024;\n }\n \n+void Simulator::SetRedirectInstruction(Instruction* instruction) {\n+  instruction->SetInstructionBits(\n+      HLT | Assembler::ImmException(kImmExceptionIsRedirectedCall));\n+}\n+\n Simulator::Simulator(Decoder<DispatchingDecoderVisitor>* decoder,\n                      Isolate* isolate, FILE* stream)\n     : decoder_(decoder),\n@@ -392,7 +332,7 @@ void Simulator::Init(FILE* stream) {\n   stack_limit_ = stack_ + stack_protection_size_;\n   uintptr_t tos = stack_ + stack_size_ - stack_protection_size_;\n   // The stack pointer must be 16-byte aligned.\n-  set_sp(tos & ~0xfUL);\n+  set_sp(tos & ~0xFUL);\n \n   stream_ = stream;\n   print_disasm_ = new PrintDisassembler(stream_);\n@@ -412,11 +352,11 @@ void Simulator::ResetState() {\n   // Reset registers to 0.\n   pc_ = nullptr;\n   for (unsigned i = 0; i < kNumberOfRegisters; i++) {\n-    set_xreg(i, 0xbadbeef);\n+    set_xreg(i, 0xBADBEEF);\n   }\n   for (unsigned i = 0; i < kNumberOfVRegisters; i++) {\n     // Set FP registers to a value that is NaN in both 32-bit and 64-bit FP.\n-    set_dreg_bits(i, 0x7ff000007f800001UL);\n+    set_dreg_bits(i, 0x7FF000007F800001UL);\n   }\n   // Returning to address 0 exits the Simulator.\n   set_lr(kEndOfSimAddress);\n@@ -458,82 +398,6 @@ void Simulator::RunFrom(Instruction* start) {\n }\n \n \n-// When the generated code calls an external reference we need to catch that in\n-// the simulator.  The external reference will be a function compiled for the\n-// host architecture.  We need to call that function instead of trying to\n-// execute it with the simulator.  We do that by redirecting the external\n-// reference to a svc (Supervisor Call) instruction that is handled by\n-// the simulator.  We write the original destination of the jump just at a known\n-// offset from the svc instruction so the simulator knows what to call.\n-class Redirection {\n- public:\n-  Redirection(Isolate* isolate, void* external_function,\n-              ExternalReference::Type type)\n-      : external_function_(external_function), type_(type), next_(nullptr) {\n-    redirect_call_.SetInstructionBits(\n-        HLT | Assembler::ImmException(kImmExceptionIsRedirectedCall));\n-    next_ = isolate->simulator_redirection();\n-    // TODO(all): Simulator flush I cache\n-    isolate->set_simulator_redirection(this);\n-  }\n-\n-  void* address_of_redirect_call() {\n-    return reinterpret_cast<void*>(&redirect_call_);\n-  }\n-\n-  template <typename T>\n-  T external_function() { return reinterpret_cast<T>(external_function_); }\n-\n-  ExternalReference::Type type() { return type_; }\n-\n-  static Redirection* Get(Isolate* isolate, void* external_function,\n-                          ExternalReference::Type type) {\n-    Redirection* current = isolate->simulator_redirection();\n-    for (; current != nullptr; current = current->next_) {\n-      if (current->external_function_ == external_function &&\n-          current->type_ == type) {\n-        return current;\n-      }\n-    }\n-    return new Redirection(isolate, external_function, type);\n-  }\n-\n-  static Redirection* FromHltInstruction(Instruction* redirect_call) {\n-    char* addr_of_hlt = reinterpret_cast<char*>(redirect_call);\n-    char* addr_of_redirection =\n-        addr_of_hlt - offsetof(Redirection, redirect_call_);\n-    return reinterpret_cast<Redirection*>(addr_of_redirection);\n-  }\n-\n-  static void* ReverseRedirection(int64_t reg) {\n-    Redirection* redirection =\n-        FromHltInstruction(reinterpret_cast<Instruction*>(reg));\n-    return redirection->external_function<void*>();\n-  }\n-\n-  static void DeleteChain(Redirection* redirection) {\n-    while (redirection != nullptr) {\n-      Redirection* next = redirection->next_;\n-      delete redirection;\n-      redirection = next;\n-    }\n-  }\n-\n- private:\n-  void* external_function_;\n-  Instruction redirect_call_;\n-  ExternalReference::Type type_;\n-  Redirection* next_;\n-};\n-\n-\n-// static\n-void Simulator::TearDown(base::CustomMatcherHashMap* i_cache,\n-                         Redirection* first) {\n-  Redirection::DeleteChain(first);\n-}\n-\n-\n // Calls into the V8 runtime are based on this very simple interface.\n // Note: To be able to return two values from some calls the code in runtime.cc\n // uses the ObjectPair structure.\n@@ -561,20 +425,20 @@ typedef void (*SimulatorRuntimeProfilingGetterCall)(int64_t arg0, int64_t arg1,\n                                                     void* arg2);\n \n void Simulator::DoRuntimeCall(Instruction* instr) {\n-  Redirection* redirection = Redirection::FromHltInstruction(instr);\n+  Redirection* redirection = Redirection::FromInstruction(instr);\n \n   // The called C code might itself call simulated code, so any\n   // caller-saved registers (including lr) could still be clobbered by a\n   // redirected call.\n   Instruction* return_address = lr();\n \n-  int64_t external = redirection->external_function<int64_t>();\n+  int64_t external =\n+      reinterpret_cast<int64_t>(redirection->external_function());\n \n-  TraceSim(\"Call to host function at %p\\n\",\n-           redirection->external_function<void*>());\n+  TraceSim(\"Call to host function at %p\\n\", redirection->external_function());\n \n   // SP must be 16-byte-aligned at the call interface.\n-  bool stack_alignment_exception = ((sp() & 0xf) != 0);\n+  bool stack_alignment_exception = ((sp() & 0xF) != 0);\n   if (stack_alignment_exception) {\n     TraceSim(\"  with unaligned stack 0x%016\" PRIx64 \".\\n\", sp());\n     FATAL(\"ALIGNMENT EXCEPTION\");\n@@ -761,28 +625,17 @@ void Simulator::DoRuntimeCall(Instruction* instr) {\n   set_pc(return_address);\n }\n \n-\n-void* Simulator::RedirectExternalReference(Isolate* isolate,\n-                                           void* external_function,\n-                                           ExternalReference::Type type) {\n-  base::LockGuard<base::Mutex> lock_guard(\n-      isolate->simulator_redirection_mutex());\n-  Redirection* redirection = Redirection::Get(isolate, external_function, type);\n-  return redirection->address_of_redirect_call();\n-}\n-\n-\n const char* Simulator::xreg_names[] = {\n-\"x0\",  \"x1\",  \"x2\",  \"x3\",  \"x4\",   \"x5\",  \"x6\",  \"x7\",\n-\"x8\",  \"x9\",  \"x10\", \"x11\", \"x12\",  \"x13\", \"x14\", \"x15\",\n-\"ip0\", \"ip1\", \"x18\", \"x19\", \"x20\",  \"x21\", \"x22\", \"x23\",\n-\"x24\", \"x25\", \"x26\", \"cp\",  \"jssp\", \"fp\",  \"lr\",  \"xzr\", \"csp\"};\n+    \"x0\",  \"x1\",  \"x2\",  \"x3\",  \"x4\",  \"x5\",  \"x6\",  \"x7\",  \"x8\",\n+    \"x9\",  \"x10\", \"x11\", \"x12\", \"x13\", \"x14\", \"x15\", \"ip0\", \"ip1\",\n+    \"x18\", \"x19\", \"x20\", \"x21\", \"x22\", \"x23\", \"x24\", \"x25\", \"x26\",\n+    \"cp\",  \"x28\", \"fp\",  \"lr\",  \"xzr\", \"csp\"};\n \n const char* Simulator::wreg_names[] = {\n-\"w0\",  \"w1\",  \"w2\",  \"w3\",  \"w4\",    \"w5\",  \"w6\",  \"w7\",\n-\"w8\",  \"w9\",  \"w10\", \"w11\", \"w12\",   \"w13\", \"w14\", \"w15\",\n-\"w16\", \"w17\", \"w18\", \"w19\", \"w20\",   \"w21\", \"w22\", \"w23\",\n-\"w24\", \"w25\", \"w26\", \"wcp\", \"wjssp\", \"wfp\", \"wlr\", \"wzr\", \"wcsp\"};\n+    \"w0\",  \"w1\",  \"w2\",  \"w3\",  \"w4\",  \"w5\",  \"w6\",  \"w7\",  \"w8\",\n+    \"w9\",  \"w10\", \"w11\", \"w12\", \"w13\", \"w14\", \"w15\", \"w16\", \"w17\",\n+    \"w18\", \"w19\", \"w20\", \"w21\", \"w22\", \"w23\", \"w24\", \"w25\", \"w26\",\n+    \"wcp\", \"w28\", \"wfp\", \"wlr\", \"wzr\", \"wcsp\"};\n \n const char* Simulator::sreg_names[] = {\n \"s0\",  \"s1\",  \"s2\",  \"s3\",  \"s4\",  \"s5\",  \"s6\",  \"s7\",\n@@ -1294,9 +1147,9 @@ void Simulator::PrintRegister(unsigned code, Reg31Mode r31mode) {\n // a floating-point interpretation or a memory access annotation).\n void Simulator::PrintVRegisterRawHelper(unsigned code, int bytes, int lsb) {\n   // The template for vector types:\n-  //   \"# v{code}: 0xffeeddccbbaa99887766554433221100\".\n+  //   \"# v{code}: 0xFFEEDDCCBBAA99887766554433221100\".\n   // An example with bytes=4 and lsb=8:\n-  //   \"# v{code}:         0xbbaa9988                \".\n+  //   \"# v{code}:         0xBBAA9988                \".\n   fprintf(stream_, \"# %s%5s: %s\", clr_vreg_name, VRegNameForCode(code),\n           clr_vreg_value);\n \n@@ -1393,8 +1246,8 @@ void Simulator::PrintVRegisterFPHelper(unsigned code,\n void Simulator::PrintRegisterRawHelper(unsigned code, Reg31Mode r31mode,\n                                        int size_in_bytes) {\n   // The template for all supported sizes.\n-  //   \"# x{code}: 0xffeeddccbbaa9988\"\n-  //   \"# w{code}:         0xbbaa9988\"\n+  //   \"# x{code}: 0xFFEEDDCCBBAA9988\"\n+  //   \"# w{code}:         0xBBAA9988\"\n   //   \"# w{code}<15:0>:       0x9988\"\n   //   \"# w{code}<7:0>:          0x88\"\n   unsigned padding_chars = (kXRegSize - size_in_bytes) * 2;\n@@ -2367,8 +2220,8 @@ void Simulator::VisitMoveWideImmediate(Instruction* instr) {\n         unsigned reg_code = instr->Rd();\n         int64_t prev_xn_val = is_64_bits ? xreg(reg_code)\n                                          : wreg(reg_code);\n-        new_xn_val = (prev_xn_val & ~(0xffffL << shift)) | shifted_imm16;\n-      break;\n+        new_xn_val = (prev_xn_val & ~(0xFFFFL << shift)) | shifted_imm16;\n+        break;\n     }\n     case MOVZ_w:\n     case MOVZ_x: {\n@@ -2532,14 +2385,14 @@ static int64_t MultiplyHighSigned(int64_t u, int64_t v) {\n   uint64_t u0, v0, w0;\n   int64_t u1, v1, w1, w2, t;\n \n-  u0 = u & 0xffffffffL;\n+  u0 = u & 0xFFFFFFFFL;\n   u1 = u >> 32;\n-  v0 = v & 0xffffffffL;\n+  v0 = v & 0xFFFFFFFFL;\n   v1 = v >> 32;\n \n   w0 = u0 * v0;\n   t = u1 * v0 + (w0 >> 32);\n-  w1 = t & 0xffffffffL;\n+  w1 = t & 0xFFFFFFFFL;\n   w2 = t >> 32;\n   w1 = u0 * v1 + w1;\n \n@@ -3344,7 +3197,7 @@ void Simulator::Debug() {\n         int next_arg = 1;\n \n         if (strcmp(cmd, \"stack\") == 0) {\n-          cur = reinterpret_cast<int64_t*>(jssp());\n+          cur = reinterpret_cast<int64_t*>(sp());\n \n         } else {  // \"mem\"\n           int64_t value;\n@@ -3381,7 +3234,7 @@ void Simulator::Debug() {\n             PrintF(\" (\");\n             if ((value & kSmiTagMask) == 0) {\n               STATIC_ASSERT(kSmiValueSize == 32);\n-              int32_t untagged = (value >> kSmiShift) & 0xffffffff;\n+              int32_t untagged = (value >> kSmiShift) & 0xFFFFFFFF;\n               PrintF(\"smi %\" PRId32, untagged);\n             } else {\n               obj->ShortPrint();\n@@ -4344,7 +4197,7 @@ void Simulator::VisitNEONByIndexedElement(Instruction* instr) {\n   int rm_reg = instr->Rm();\n   int index = (instr->NEONH() << 1) | instr->NEONL();\n   if (instr->NEONSize() == 1) {\n-    rm_reg &= 0xf;\n+    rm_reg &= 0xF;\n     index = (index << 1) | instr->NEONM();\n   }\n \n@@ -4909,9 +4762,9 @@ void Simulator::VisitNEONModifiedImmediate(Instruction* instr) {\n     case 0x6:\n       vform = (q == 1) ? kFormat4S : kFormat2S;\n       if (cmode_0 == 0) {\n-        imm = imm8 << 8 | 0x000000ff;\n+        imm = imm8 << 8 | 0x000000FF;\n       } else {\n-        imm = imm8 << 16 | 0x0000ffff;\n+        imm = imm8 << 16 | 0x0000FFFF;\n       }\n       break;\n     case 0x7:\n@@ -4923,18 +4776,18 @@ void Simulator::VisitNEONModifiedImmediate(Instruction* instr) {\n         imm = 0;\n         for (int i = 0; i < 8; ++i) {\n           if (imm8 & (1 << i)) {\n-            imm |= (UINT64_C(0xff) << (8 * i));\n+            imm |= (UINT64_C(0xFF) << (8 * i));\n           }\n         }\n-      } else {  // cmode_0 == 1, cmode == 0xf.\n+      } else {  // cmode_0 == 1, cmode == 0xF.\n         if (op_bit == 0) {\n           vform = q ? kFormat4S : kFormat2S;\n           imm = bit_cast<uint32_t>(instr->ImmNEONFP32());\n         } else if (q == 1) {\n           vform = kFormat2D;\n           imm = bit_cast<uint64_t>(instr->ImmNEONFP64());\n         } else {\n-          DCHECK((q == 0) && (op_bit == 1) && (cmode == 0xf));\n+          DCHECK((q == 0) && (op_bit == 1) && (cmode == 0xF));\n           VisitUnallocated(instr);\n         }\n       }\n@@ -5278,7 +5131,7 @@ void Simulator::VisitNEONScalarByIndexedElement(Instruction* instr) {\n   int rm_reg = instr->Rm();\n   int index = (instr->NEONH() << 1) | instr->NEONL();\n   if (instr->NEONSize() == 1) {\n-    rm_reg &= 0xf;\n+    rm_reg &= 0xF;\n     index = (index << 1) | instr->NEONM();\n   }\n "
        },
        {
            "sha": "a8f229d764eb534452aac48de17b6d829693e6ad",
            "filename": "deps/v8/src/arm64/simulator-arm64.h",
            "status": "modified",
            "additions": 35,
            "deletions": 121,
            "changes": 156,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-arm64.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -16,56 +16,13 @@\n #include \"src/assembler.h\"\n #include \"src/base/compiler-specific.h\"\n #include \"src/globals.h\"\n+#include \"src/simulator-base.h\"\n #include \"src/utils.h\"\n \n namespace v8 {\n namespace internal {\n \n-#if !defined(USE_SIMULATOR)\n-\n-// Running without a simulator on a native ARM64 platform.\n-// When running without a simulator we call the entry directly.\n-#define CALL_GENERATED_CODE(isolate, entry, p0, p1, p2, p3, p4) \\\n-  (entry(p0, p1, p2, p3, p4))\n-\n-typedef int (*arm64_regexp_matcher)(String* input,\n-                                    int64_t start_offset,\n-                                    const byte* input_start,\n-                                    const byte* input_end,\n-                                    int* output,\n-                                    int64_t output_size,\n-                                    Address stack_base,\n-                                    int64_t direct_call,\n-                                    Isolate* isolate);\n-\n-// Call the generated regexp code directly. The code at the entry address\n-// should act as a function matching the type arm64_regexp_matcher.\n-#define CALL_GENERATED_REGEXP_CODE(isolate, entry, p0, p1, p2, p3, p4, p5, p6, \\\n-                                   p7, p8)                                     \\\n-  (FUNCTION_CAST<arm64_regexp_matcher>(entry)(p0, p1, p2, p3, p4, p5, p6, p7,  \\\n-                                              p8))\n-\n-// Running without a simulator there is nothing to do.\n-class SimulatorStack : public v8::internal::AllStatic {\n- public:\n-  static uintptr_t JsLimitFromCLimit(v8::internal::Isolate* isolate,\n-                                     uintptr_t c_limit) {\n-    USE(isolate);\n-    return c_limit;\n-  }\n-\n-  static uintptr_t RegisterCTryCatch(v8::internal::Isolate* isolate,\n-                                     uintptr_t try_catch_address) {\n-    USE(isolate);\n-    return try_catch_address;\n-  }\n-\n-  static void UnregisterCTryCatch(v8::internal::Isolate* isolate) {\n-    USE(isolate);\n-  }\n-};\n-\n-#else  // !defined(USE_SIMULATOR)\n+#if defined(USE_SIMULATOR)\n \n // Assemble the specified IEEE-754 components into the target type and apply\n // appropriate rounding.\n@@ -269,6 +226,10 @@ T FPRound(int64_t sign, int64_t exponent, uint64_t mantissa,\n   }\n }\n \n+class CachePage {\n+  // TODO(all): Simulate instruction cache.\n+};\n+\n // Representation of memory, with typed getters and setters for access.\n class SimMemory {\n  public:\n@@ -680,8 +641,11 @@ class LogicVRegister {\n   bool round_[kQRegSize];\n };\n \n-class Simulator : public DecoderVisitor {\n+// Using multiple inheritance here is permitted because {DecoderVisitor} is a\n+// pure interface class with only pure virtual methods.\n+class Simulator : public DecoderVisitor, public SimulatorBase {\n  public:\n+  static void SetRedirectInstruction(Instruction* instruction);\n   static void FlushICache(base::CustomMatcherHashMap* i_cache, void* start,\n                           size_t size) {\n     USE(i_cache);\n@@ -696,42 +660,7 @@ class Simulator : public DecoderVisitor {\n \n   // System functions.\n \n-  static void Initialize(Isolate* isolate);\n-\n-  static void TearDown(base::CustomMatcherHashMap* i_cache, Redirection* first);\n-\n-  static Simulator* current(v8::internal::Isolate* isolate);\n-\n-  class CallArgument;\n-\n-  // Call an arbitrary function taking an arbitrary number of arguments. The\n-  // varargs list must be a set of arguments with type CallArgument, and\n-  // terminated by CallArgument::End().\n-  void CallVoid(byte* entry, CallArgument* args);\n-\n-  // Like CallVoid, but expect a return value.\n-  int64_t CallInt64(byte* entry, CallArgument* args);\n-  double CallDouble(byte* entry, CallArgument* args);\n-\n-  // V8 calls into generated JS code with 5 parameters and into\n-  // generated RegExp code with 10 parameters. These are convenience functions,\n-  // which set up the simulator state and grab the result on return.\n-  int64_t CallJS(byte* entry,\n-                 Object* new_target,\n-                 Object* target,\n-                 Object* revc,\n-                 int64_t argc,\n-                 Object*** argv);\n-  int64_t CallRegExp(byte* entry,\n-                     String* input,\n-                     int64_t start_offset,\n-                     const byte* input_start,\n-                     const byte* input_end,\n-                     int* output,\n-                     int64_t output_size,\n-                     Address stack_base,\n-                     int64_t direct_call,\n-                     Isolate* isolate);\n+  V8_EXPORT_PRIVATE static Simulator* current(v8::internal::Isolate* isolate);\n \n   // A wrapper class that stores an argument for one of the above Call\n   // functions.\n@@ -787,6 +716,14 @@ class Simulator : public DecoderVisitor {\n     CallArgument() { type_ = NO_ARG; }\n   };\n \n+  // Call an arbitrary function taking an arbitrary number of arguments.\n+  template <typename Return, typename... Args>\n+  Return Call(byte* entry, Args... args) {\n+    // Convert all arguments to CallArgument.\n+    CallArgument call_args[] = {CallArgument(args)..., CallArgument::End()};\n+    CallImpl(entry, call_args);\n+    return ReadReturn<Return>();\n+  }\n \n   // Start the debugging command line.\n   void Debug();\n@@ -806,10 +743,6 @@ class Simulator : public DecoderVisitor {\n \n   void ResetState();\n \n-  // Runtime call support. Uses the isolate in a thread-safe way.\n-  static void* RedirectExternalReference(Isolate* isolate,\n-                                         void* external_function,\n-                                         ExternalReference::Type type);\n   void DoRuntimeCall(Instruction* instr);\n \n   // Run the simulator.\n@@ -958,7 +891,6 @@ class Simulator : public DecoderVisitor {\n   inline SimVRegister& vreg(unsigned code) { return vregisters_[code]; }\n \n   int64_t sp() { return xreg(31, Reg31IsStackPointer); }\n-  int64_t jssp() { return xreg(kJSSPCode, Reg31IsStackPointer); }\n   int64_t fp() {\n       return xreg(kFramePointerRegCode, Reg31IsStackPointer);\n   }\n@@ -2345,6 +2277,21 @@ class Simulator : public DecoderVisitor {\n  private:\n   void Init(FILE* stream);\n \n+  V8_EXPORT_PRIVATE void CallImpl(byte* entry, CallArgument* args);\n+\n+  // Read floating point return values.\n+  template <typename T>\n+  typename std::enable_if<std::is_floating_point<T>::value, T>::type\n+  ReadReturn() {\n+    return static_cast<T>(dreg(0));\n+  }\n+  // Read non-float return values.\n+  template <typename T>\n+  typename std::enable_if<!std::is_floating_point<T>::value, T>::type\n+  ReadReturn() {\n+    return ConvertReturn<T>(xreg(0));\n+  }\n+\n   template <typename T>\n   static T FPDefaultNaN();\n \n@@ -2407,40 +2354,7 @@ inline float Simulator::FPDefaultNaN<float>() {\n   return kFP32DefaultNaN;\n }\n \n-// When running with the simulator transition into simulated execution at this\n-// point.\n-#define CALL_GENERATED_CODE(isolate, entry, p0, p1, p2, p3, p4)  \\\n-  reinterpret_cast<Object*>(Simulator::current(isolate)->CallJS( \\\n-      FUNCTION_ADDR(entry), p0, p1, p2, p3, p4))\n-\n-#define CALL_GENERATED_REGEXP_CODE(isolate, entry, p0, p1, p2, p3, p4, p5, p6, \\\n-                                   p7, p8)                                     \\\n-  static_cast<int>(Simulator::current(isolate)->CallRegExp(                    \\\n-      entry, p0, p1, p2, p3, p4, p5, p6, p7, p8))\n-\n-// The simulator has its own stack. Thus it has a different stack limit from\n-// the C-based native code.  The JS-based limit normally points near the end of\n-// the simulator stack.  When the C-based limit is exhausted we reflect that by\n-// lowering the JS-based limit as well, to make stack checks trigger.\n-class SimulatorStack : public v8::internal::AllStatic {\n- public:\n-  static uintptr_t JsLimitFromCLimit(v8::internal::Isolate* isolate,\n-                                            uintptr_t c_limit) {\n-    return Simulator::current(isolate)->StackLimit(c_limit);\n-  }\n-\n-  static uintptr_t RegisterCTryCatch(v8::internal::Isolate* isolate,\n-                                     uintptr_t try_catch_address) {\n-    Simulator* sim = Simulator::current(isolate);\n-    return sim->PushAddress(try_catch_address);\n-  }\n-\n-  static void UnregisterCTryCatch(v8::internal::Isolate* isolate) {\n-    Simulator::current(isolate)->PopAddress();\n-  }\n-};\n-\n-#endif  // !defined(USE_SIMULATOR)\n+#endif  // defined(USE_SIMULATOR)\n \n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "9ee5ea6cc880b892940cf6739a48e159dd6ea739",
            "filename": "deps/v8/src/arm64/simulator-logic-arm64.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-logic-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-logic-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-logic-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -3986,9 +3986,9 @@ T Simulator::FPRecipEstimate(T op, FPRounding rounding) {\n     } else {\n       // Return FPMaxNormal(sign).\n       if (sizeof(T) == sizeof(float)) {\n-        return float_pack(sign, 0xfe, 0x07fffff);\n+        return float_pack(sign, 0xFE, 0x07FFFFF);\n       } else {\n-        return double_pack(sign, 0x7fe, 0x0fffffffffffffl);\n+        return double_pack(sign, 0x7FE, 0x0FFFFFFFFFFFFFl);\n       }\n     }\n   } else {"
        },
        {
            "sha": "f8804d8b9375eccbe5ae94acf305857395edb879",
            "filename": "deps/v8/src/arm64/utils-arm64.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Futils-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Farm64%2Futils-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Futils-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -98,7 +98,7 @@ int CountTrailingZeros(uint64_t value, int width) {\n     return static_cast<int>(base::bits::CountTrailingZeros64(value));\n   }\n   return static_cast<int>(base::bits::CountTrailingZeros32(\n-      static_cast<uint32_t>(value & 0xfffffffff)));\n+      static_cast<uint32_t>(value & 0xFFFFFFFFF)));\n }\n \n \n@@ -108,7 +108,7 @@ int CountSetBits(uint64_t value, int width) {\n     return static_cast<int>(base::bits::CountPopulation(value));\n   }\n   return static_cast<int>(\n-      base::bits::CountPopulation(static_cast<uint32_t>(value & 0xfffffffff)));\n+      base::bits::CountPopulation(static_cast<uint32_t>(value & 0xFFFFFFFFF)));\n }\n \n int LowestSetBitPosition(uint64_t value) {"
        },
        {
            "sha": "6be80bf7afb53fea4aa50cf05c10a167c7b84d09",
            "filename": "deps/v8/src/asmjs/asm-parser.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 19,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-parser.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-parser.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-parser.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -292,8 +292,7 @@ void AsmJsParser::Begin(AsmJsScanner::token_t label) {\n \n void AsmJsParser::Loop(AsmJsScanner::token_t label) {\n   BareBegin(BlockKind::kLoop, label);\n-  int position = static_cast<int>(scanner_.Position());\n-  DCHECK_EQ(position, scanner_.Position());\n+  size_t position = scanner_.Position();\n   current_function_builder_->AddAsmWasmOffset(position, position);\n   current_function_builder_->EmitWithU8(kExprLoop, kLocalVoid);\n }\n@@ -450,7 +449,7 @@ void AsmJsParser::ValidateModuleVar(bool mutable_variable) {\n     DeclareGlobal(info, mutable_variable, AsmType::Double(), kWasmF64,\n                   WasmInitExpr(dvalue));\n   } else if (CheckForUnsigned(&uvalue)) {\n-    if (uvalue > 0x7fffffff) {\n+    if (uvalue > 0x7FFFFFFF) {\n       FAIL(\"Numeric literal out of range\");\n     }\n     DeclareGlobal(info, mutable_variable,\n@@ -461,7 +460,7 @@ void AsmJsParser::ValidateModuleVar(bool mutable_variable) {\n       DeclareGlobal(info, mutable_variable, AsmType::Double(), kWasmF64,\n                     WasmInitExpr(-dvalue));\n     } else if (CheckForUnsigned(&uvalue)) {\n-      if (uvalue > 0x7fffffff) {\n+      if (uvalue > 0x7FFFFFFF) {\n         FAIL(\"Numeric literal out of range\");\n       }\n       DeclareGlobal(info, mutable_variable,\n@@ -742,8 +741,7 @@ void AsmJsParser::ValidateFunction() {\n   return_type_ = nullptr;\n \n   // Record start of the function, used as position for the stack check.\n-  int start_position = static_cast<int>(scanner_.Position());\n-  current_function_builder_->SetAsmFunctionStartPosition(start_position);\n+  current_function_builder_->SetAsmFunctionStartPosition(scanner_.Position());\n \n   CachedVector<AsmType*> params(cached_asm_type_p_vectors_);\n   ValidateFunctionParams(&params);\n@@ -902,7 +900,7 @@ void AsmJsParser::ValidateFunctionLocals(size_t param_count,\n           current_function_builder_->EmitF64Const(-dvalue);\n           current_function_builder_->EmitSetLocal(info->index);\n         } else if (CheckForUnsigned(&uvalue)) {\n-          if (uvalue > 0x7fffffff) {\n+          if (uvalue > 0x7FFFFFFF) {\n             FAIL(\"Numeric literal out of range\");\n           }\n           info->kind = VarKind::kLocal;\n@@ -954,7 +952,7 @@ void AsmJsParser::ValidateFunctionLocals(size_t param_count,\n             current_function_builder_->EmitF32Const(dvalue);\n             current_function_builder_->EmitSetLocal(info->index);\n           } else if (CheckForUnsigned(&uvalue)) {\n-            if (uvalue > 0x7fffffff) {\n+            if (uvalue > 0x7FFFFFFF) {\n               FAIL(\"Numeric literal out of range\");\n             }\n             info->kind = VarKind::kLocal;\n@@ -1337,7 +1335,7 @@ void AsmJsParser::ValidateCase() {\n     FAIL(\"Expected numeric literal\");\n   }\n   // TODO(bradnelson): Share negation plumbing.\n-  if ((negate && uvalue > 0x80000000) || (!negate && uvalue > 0x7fffffff)) {\n+  if ((negate && uvalue > 0x80000000) || (!negate && uvalue > 0x7FFFFFFF)) {\n     FAIL(\"Numeric literal out of range\");\n   }\n   int32_t value = static_cast<int32_t>(uvalue);\n@@ -1398,11 +1396,11 @@ AsmType* AsmJsParser::NumericLiteral() {\n     current_function_builder_->EmitF64Const(dvalue);\n     return AsmType::Double();\n   } else if (CheckForUnsigned(&uvalue)) {\n-    if (uvalue <= 0x7fffffff) {\n+    if (uvalue <= 0x7FFFFFFF) {\n       current_function_builder_->EmitI32Const(static_cast<int32_t>(uvalue));\n       return AsmType::FixNum();\n     } else {\n-      DCHECK_LE(uvalue, 0xffffffff);\n+      DCHECK_LE(uvalue, 0xFFFFFFFF);\n       current_function_builder_->EmitI32Const(static_cast<int32_t>(uvalue));\n       return AsmType::Unsigned();\n     }\n@@ -1553,7 +1551,7 @@ AsmType* AsmJsParser::UnaryExpression() {\n   if (Check('-')) {\n     uint32_t uvalue;\n     if (CheckForUnsigned(&uvalue)) {\n-      // TODO(bradnelson): was supposed to be 0x7fffffff, check errata.\n+      // TODO(bradnelson): was supposed to be 0x7FFFFFFF, check errata.\n       if (uvalue <= 0x80000000) {\n         current_function_builder_->EmitI32Const(-static_cast<int32_t>(uvalue));\n       } else {\n@@ -1621,7 +1619,7 @@ AsmType* AsmJsParser::UnaryExpression() {\n       if (!ret->IsA(AsmType::Intish())) {\n         FAILn(\"operator ~ expects intish\");\n       }\n-      current_function_builder_->EmitI32Const(0xffffffff);\n+      current_function_builder_->EmitI32Const(0xFFFFFFFF);\n       current_function_builder_->Emit(kExprI32Xor);\n       ret = AsmType::Signed();\n     }\n@@ -2066,8 +2064,8 @@ AsmType* AsmJsParser::ParenthesizedExpression() {\n AsmType* AsmJsParser::ValidateCall() {\n   AsmType* return_type = call_coercion_;\n   call_coercion_ = nullptr;\n-  int call_pos = static_cast<int>(scanner_.Position());\n-  int to_number_pos = static_cast<int>(call_coercion_position_);\n+  size_t call_pos = scanner_.Position();\n+  size_t to_number_pos = call_coercion_position_;\n   bool allow_peek = (call_coercion_deferred_position_ == scanner_.Position());\n   AsmJsScanner::token_t function_name = Consume();\n \n@@ -2113,7 +2111,7 @@ AsmType* AsmJsParser::ValidateCall() {\n     tmp.emplace(this);\n     current_function_builder_->EmitSetLocal(tmp->get());\n     // The position of function table calls is after the table lookup.\n-    call_pos = static_cast<int>(scanner_.Position());\n+    call_pos = scanner_.Position();\n   } else {\n     VarInfo* function_info = GetVarInfo(function_name);\n     if (function_info->kind == VarKind::kUnused) {\n@@ -2176,7 +2174,7 @@ AsmType* AsmJsParser::ValidateCall() {\n       (return_type == nullptr || return_type->IsA(AsmType::Float()))) {\n     DCHECK_NULL(call_coercion_deferred_);\n     call_coercion_deferred_ = AsmType::Signed();\n-    to_number_pos = static_cast<int>(scanner_.Position());\n+    to_number_pos = scanner_.Position();\n     return_type = AsmType::Signed();\n   } else if (return_type == nullptr) {\n     to_number_pos = call_pos;  // No conversion.\n@@ -2395,9 +2393,9 @@ void AsmJsParser::ValidateHeapAccess() {\n     // TODO(bradnelson): Check more things.\n     // TODO(mstarzinger): Clarify and explain where this limit is coming from,\n     // as it is not mandated by the spec directly.\n-    if (offset > 0x7fffffff ||\n+    if (offset > 0x7FFFFFFF ||\n         static_cast<uint64_t>(offset) * static_cast<uint64_t>(size) >\n-            0x7fffffff) {\n+            0x7FFFFFFF) {\n       FAIL(\"Heap access out of range\");\n     }\n     if (Check(']')) {"
        },
        {
            "sha": "af41208eadd3e340975c87e51e4792d6d4cac185",
            "filename": "deps/v8/src/asmjs/asm-scanner.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-scanner.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-scanner.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-scanner.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -15,7 +15,7 @@ namespace internal {\n namespace {\n // Cap number of identifiers to ensure we can assign both global and\n // local ones a token id in the range of an int32_t.\n-static const int kMaxIdentifierCount = 0xf000000;\n+static const int kMaxIdentifierCount = 0xF000000;\n };\n \n AsmJsScanner::AsmJsScanner(Utf16CharacterStream* stream)"
        },
        {
            "sha": "1b83735bc9718bc02c7c307b3fb5ff42e1204418",
            "filename": "deps/v8/src/assembler.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 5,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fassembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fassembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fassembler.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -131,14 +131,14 @@ static struct V8_ALIGNED(16) {\n static struct V8_ALIGNED(16) {\n   uint64_t a;\n   uint64_t b;\n-} double_absolute_constant = {V8_UINT64_C(0x7FFFFFFFFFFFFFFF),\n-                              V8_UINT64_C(0x7FFFFFFFFFFFFFFF)};\n+} double_absolute_constant = {uint64_t{0x7FFFFFFFFFFFFFFF},\n+                              uint64_t{0x7FFFFFFFFFFFFFFF}};\n \n static struct V8_ALIGNED(16) {\n   uint64_t a;\n   uint64_t b;\n-} double_negate_constant = {V8_UINT64_C(0x8000000000000000),\n-                            V8_UINT64_C(0x8000000000000000)};\n+} double_negate_constant = {uint64_t{0x8000000000000000},\n+                            uint64_t{0x8000000000000000}};\n \n const char* const RelocInfo::kFillerCommentString = \"DEOPTIMIZATION PADDING\";\n \n@@ -351,7 +351,7 @@ void RelocInfo::set_target_address(Isolate* isolate, Address target,\n                                    WriteBarrierMode write_barrier_mode,\n                                    ICacheFlushMode icache_flush_mode) {\n   DCHECK(IsCodeTarget(rmode_) || IsRuntimeEntry(rmode_) || IsWasmCall(rmode_));\n-  Assembler::set_target_address_at(isolate, pc_, host_, target,\n+  Assembler::set_target_address_at(isolate, pc_, constant_pool_, target,\n                                    icache_flush_mode);\n   if (write_barrier_mode == UPDATE_WRITE_BARRIER && host() != nullptr &&\n       IsCodeTarget(rmode_)) {\n@@ -801,6 +801,16 @@ ExternalReference ExternalReference::builtins_address(Isolate* isolate) {\n   return ExternalReference(isolate->builtins()->builtins_table_address());\n }\n \n+ExternalReference ExternalReference::handle_scope_implementer_address(\n+    Isolate* isolate) {\n+  return ExternalReference(isolate->handle_scope_implementer_address());\n+}\n+\n+ExternalReference ExternalReference::pending_microtask_count_address(\n+    Isolate* isolate) {\n+  return ExternalReference(isolate->pending_microtask_count_address());\n+}\n+\n ExternalReference ExternalReference::interpreter_dispatch_table_address(\n     Isolate* isolate) {\n   return ExternalReference(isolate->interpreter()->dispatch_table_address());\n@@ -1002,6 +1012,16 @@ ExternalReference ExternalReference::wasm_word64_popcnt(Isolate* isolate) {\n       Redirect(isolate, FUNCTION_ADDR(wasm::word64_popcnt_wrapper)));\n }\n \n+ExternalReference ExternalReference::wasm_word32_rol(Isolate* isolate) {\n+  return ExternalReference(\n+      Redirect(isolate, FUNCTION_ADDR(wasm::word32_rol_wrapper)));\n+}\n+\n+ExternalReference ExternalReference::wasm_word32_ror(Isolate* isolate) {\n+  return ExternalReference(\n+      Redirect(isolate, FUNCTION_ADDR(wasm::word32_ror_wrapper)));\n+}\n+\n static void f64_acos_wrapper(double* param) {\n   WriteDoubleValue(param, base::ieee754::acos(ReadDoubleValue(param)));\n }\n@@ -1514,6 +1534,12 @@ ExternalReference ExternalReference::runtime_function_table_address(\n       const_cast<Runtime::Function*>(Runtime::RuntimeFunctionTable(isolate)));\n }\n \n+ExternalReference ExternalReference::invalidate_prototype_chains_function(\n+    Isolate* isolate) {\n+  return ExternalReference(\n+      Redirect(isolate, FUNCTION_ADDR(JSObject::InvalidatePrototypeChains)));\n+}\n+\n double power_helper(Isolate* isolate, double x, double y) {\n   int y_int = static_cast<int>(y);\n   if (y == y_int) {"
        },
        {
            "sha": "0cebdbc2d707997c07c7ac63659adbb5c3431384",
            "filename": "deps/v8/src/assembler.h",
            "status": "modified",
            "additions": 20,
            "deletions": 8,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fassembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fassembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fassembler.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -36,6 +36,7 @@\n #define V8_ASSEMBLER_H_\n \n #include <forward_list>\n+#include <iosfwd>\n \n #include \"src/allocation.h\"\n #include \"src/builtins/builtins.h\"\n@@ -54,9 +55,6 @@ namespace v8 {\n class ApiFunction;\n \n namespace internal {\n-namespace wasm {\n-class WasmCode;\n-}\n \n // Forward declarations.\n class Isolate;\n@@ -486,6 +484,7 @@ class RelocInfo {\n   Mode rmode() const {  return rmode_; }\n   intptr_t data() const { return data_; }\n   Code* host() const { return host_; }\n+  Address constant_pool() const { return constant_pool_; }\n \n   // Apply a relocation by delta bytes. When the code object is moved, PC\n   // relative addresses have to be updated as well as absolute addresses\n@@ -625,9 +624,6 @@ class RelocInfo {\n   byte* pc_;\n   Mode rmode_;\n   intptr_t data_;\n-  // TODO(mtrofin): try remove host_, if all we need is the constant_pool_ or\n-  // other few attributes, like start address, etc. This is so that we can reuse\n-  // RelocInfo for WasmCode without having a modal design.\n   Code* host_;\n   Address constant_pool_ = nullptr;\n   friend class RelocIterator;\n@@ -830,6 +826,9 @@ class ExternalReference BASE_EMBEDDED {\n   // The builtins table as an external reference, used by lazy deserialization.\n   static ExternalReference builtins_address(Isolate* isolate);\n \n+  static ExternalReference handle_scope_implementer_address(Isolate* isolate);\n+  static ExternalReference pending_microtask_count_address(Isolate* isolate);\n+\n   // One-of-a-kind references. These references are not part of a general\n   // pattern. This means that they have to be added to the\n   // ExternalReferenceTable in serialize.cc manually.\n@@ -875,6 +874,8 @@ class ExternalReference BASE_EMBEDDED {\n   static ExternalReference wasm_word64_ctz(Isolate* isolate);\n   static ExternalReference wasm_word32_popcnt(Isolate* isolate);\n   static ExternalReference wasm_word64_popcnt(Isolate* isolate);\n+  static ExternalReference wasm_word32_rol(Isolate* isolate);\n+  static ExternalReference wasm_word32_ror(Isolate* isolate);\n   static ExternalReference wasm_float64_pow(Isolate* isolate);\n   static ExternalReference wasm_set_thread_in_wasm_flag(Isolate* isolate);\n   static ExternalReference wasm_clear_thread_in_wasm_flag(Isolate* isolate);\n@@ -1019,6 +1020,9 @@ class ExternalReference BASE_EMBEDDED {\n   V8_EXPORT_PRIVATE static ExternalReference runtime_function_table_address(\n       Isolate* isolate);\n \n+  static ExternalReference invalidate_prototype_chains_function(\n+      Isolate* isolate);\n+\n   Address address() const { return reinterpret_cast<Address>(address_); }\n \n   // Used to read out the last step action of the debugger.\n@@ -1328,16 +1332,24 @@ class RegisterBase {\n \n   int bit() const { return 1 << code(); }\n \n-  inline bool operator==(SubType other) const {\n+  inline constexpr bool operator==(SubType other) const {\n     return reg_code_ == other.reg_code_;\n   }\n-  inline bool operator!=(SubType other) const { return !(*this == other); }\n+  inline constexpr bool operator!=(SubType other) const {\n+    return reg_code_ != other.reg_code_;\n+  }\n \n  protected:\n   explicit constexpr RegisterBase(int code) : reg_code_(code) {}\n   int reg_code_;\n };\n \n+template <typename SubType, int kAfterLastRegister>\n+inline std::ostream& operator<<(std::ostream& os,\n+                                RegisterBase<SubType, kAfterLastRegister> reg) {\n+  return reg.is_valid() ? os << \"r\" << reg.code() : os << \"<invalid reg>\";\n+}\n+\n }  // namespace internal\n }  // namespace v8\n #endif  // V8_ASSEMBLER_H_"
        },
        {
            "sha": "ade1a85349ed222ccaac9f9ab970f0542586347d",
            "filename": "deps/v8/src/ast/ast-numbering.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 19,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fast-numbering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fast-numbering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fast-numbering.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -16,10 +16,7 @@ class AstNumberingVisitor final : public AstVisitor<AstNumberingVisitor> {\n  public:\n   AstNumberingVisitor(uintptr_t stack_limit, Zone* zone,\n                       Compiler::EagerInnerFunctionLiterals* eager_literals)\n-      : zone_(zone),\n-        eager_literals_(eager_literals),\n-        suspend_count_(0),\n-        dont_optimize_reason_(kNoReason) {\n+      : zone_(zone), eager_literals_(eager_literals), suspend_count_(0) {\n     InitializeAstVisitor(stack_limit);\n   }\n \n@@ -39,19 +36,12 @@ class AstNumberingVisitor final : public AstVisitor<AstNumberingVisitor> {\n   void VisitArguments(ZoneList<Expression*>* arguments);\n   void VisitLiteralProperty(LiteralProperty* property);\n \n-  void DisableOptimization(BailoutReason reason) {\n-    dont_optimize_reason_ = reason;\n-  }\n-\n-  BailoutReason dont_optimize_reason() const { return dont_optimize_reason_; }\n-\n   Zone* zone() const { return zone_; }\n \n   Zone* zone_;\n   Compiler::EagerInnerFunctionLiterals* eager_literals_;\n   int suspend_count_;\n   FunctionKind function_kind_;\n-  BailoutReason dont_optimize_reason_;\n \n   DEFINE_AST_VISITOR_SUBCLASS_MEMBERS();\n   DISALLOW_COPY_AND_ASSIGN(AstNumberingVisitor);\n@@ -80,7 +70,6 @@ void AstNumberingVisitor::VisitDebuggerStatement(DebuggerStatement* node) {\n \n void AstNumberingVisitor::VisitNativeFunctionLiteral(\n     NativeFunctionLiteral* node) {\n-  DisableOptimization(kNativeFunctionLiteral);\n }\n \n void AstNumberingVisitor::VisitDoExpression(DoExpression* node) {\n@@ -206,6 +195,11 @@ void AstNumberingVisitor::VisitProperty(Property* node) {\n   Visit(node->obj());\n }\n \n+void AstNumberingVisitor::VisitResolvedProperty(ResolvedProperty* node) {\n+  Visit(node->object());\n+  Visit(node->property());\n+}\n+\n void AstNumberingVisitor::VisitAssignment(Assignment* node) {\n   Visit(node->target());\n   Visit(node->value());\n@@ -262,6 +256,7 @@ void AstNumberingVisitor::VisitForInStatement(ForInStatement* node) {\n \n void AstNumberingVisitor::VisitForOfStatement(ForOfStatement* node) {\n   Visit(node->assign_iterator());  // Not part of loop.\n+  Visit(node->assign_next());\n   node->set_first_suspend_id(suspend_count_);\n   Visit(node->next_result());\n   Visit(node->result_done());\n@@ -326,11 +321,6 @@ void AstNumberingVisitor::VisitObjectLiteral(ObjectLiteral* node) {\n   for (int i = 0; i < node->properties()->length(); i++) {\n     VisitLiteralProperty(node->properties()->at(i));\n   }\n-  node->InitDepthAndFlags();\n-  // Mark all computed expressions that are bound to a key that\n-  // is shadowed by a later occurrence of the same key. For the\n-  // marked expressions, no store code will be is emitted.\n-  node->CalculateEmitStore(zone_);\n }\n \n void AstNumberingVisitor::VisitLiteralProperty(LiteralProperty* node) {\n@@ -342,7 +332,6 @@ void AstNumberingVisitor::VisitArrayLiteral(ArrayLiteral* node) {\n   for (int i = 0; i < node->values()->length(); i++) {\n     Visit(node->values()->at(i));\n   }\n-  node->InitDepthAndFlags();\n }\n \n void AstNumberingVisitor::VisitCall(Call* node) {\n@@ -402,7 +391,6 @@ bool AstNumberingVisitor::Renumber(FunctionLiteral* node) {\n   VisitDeclarations(scope->declarations());\n   VisitStatements(node->body());\n \n-  node->set_dont_optimize_reason(dont_optimize_reason());\n   node->set_suspend_count(suspend_count_);\n \n   return !HasStackOverflow();"
        },
        {
            "sha": "3679ec762ae19b0b8fd1a8b7e3904abbc12541f0",
            "filename": "deps/v8/src/ast/ast-traversal-visitor.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fast-traversal-visitor.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fast-traversal-visitor.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fast-traversal-visitor.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -243,6 +243,7 @@ void AstTraversalVisitor<Subclass>::VisitForStatement(ForStatement* stmt) {\n template <class Subclass>\n void AstTraversalVisitor<Subclass>::VisitForInStatement(ForInStatement* stmt) {\n   PROCESS_NODE(stmt);\n+  RECURSE(Visit(stmt->each()));\n   RECURSE(Visit(stmt->enumerable()));\n   RECURSE(Visit(stmt->body()));\n }\n@@ -391,6 +392,14 @@ void AstTraversalVisitor<Subclass>::VisitProperty(Property* expr) {\n   RECURSE_EXPRESSION(Visit(expr->key()));\n }\n \n+template <class Subclass>\n+void AstTraversalVisitor<Subclass>::VisitResolvedProperty(\n+    ResolvedProperty* expr) {\n+  PROCESS_EXPRESSION(expr);\n+  RECURSE_EXPRESSION(VisitVariableProxy(expr->object()));\n+  RECURSE_EXPRESSION(VisitVariableProxy(expr->property()));\n+}\n+\n template <class Subclass>\n void AstTraversalVisitor<Subclass>::VisitCall(Call* expr) {\n   PROCESS_EXPRESSION(expr);"
        },
        {
            "sha": "da14d874759eb407fd2c2e0fe9e58281801d975b",
            "filename": "deps/v8/src/ast/ast.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 12,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fast.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fast.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fast.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -514,18 +514,17 @@ bool ArrayLiteral::is_empty() const {\n }\n \n int ArrayLiteral::InitDepthAndFlags() {\n-  DCHECK_LT(first_spread_index_, 0);\n   if (is_initialized()) return depth();\n \n-  int constants_length = values()->length();\n+  int constants_length =\n+      first_spread_index_ >= 0 ? first_spread_index_ : values()->length();\n \n   // Fill in the literals.\n-  bool is_simple = true;\n+  bool is_simple = first_spread_index_ < 0;\n   int depth_acc = 1;\n   int array_index = 0;\n   for (; array_index < constants_length; array_index++) {\n     Expression* element = values()->at(array_index);\n-    DCHECK(!element->IsSpread());\n     MaterializedLiteral* literal = element->AsMaterializedLiteral();\n     if (literal != nullptr) {\n       int subliteral_depth = literal->InitDepthAndFlags() + 1;\n@@ -546,11 +545,10 @@ int ArrayLiteral::InitDepthAndFlags() {\n }\n \n void ArrayLiteral::BuildConstantElements(Isolate* isolate) {\n-  DCHECK_LT(first_spread_index_, 0);\n-\n   if (!constant_elements_.is_null()) return;\n \n-  int constants_length = values()->length();\n+  int constants_length =\n+      first_spread_index_ >= 0 ? first_spread_index_ : values()->length();\n   ElementsKind kind = FIRST_FAST_ELEMENTS_KIND;\n   Handle<FixedArray> fixed_array =\n       isolate->factory()->NewFixedArrayWithHoles(constants_length);\n@@ -614,11 +612,6 @@ bool ArrayLiteral::IsFastCloningSupported() const {\n              ConstructorBuiltins::kMaximumClonedShallowArrayElements;\n }\n \n-void ArrayLiteral::RewindSpreads() {\n-  values_->Rewind(first_spread_index_);\n-  first_spread_index_ = -1;\n-}\n-\n bool MaterializedLiteral::IsSimple() const {\n   if (IsArrayLiteral()) return AsArrayLiteral()->is_simple();\n   if (IsObjectLiteral()) return AsObjectLiteral()->is_simple();\n@@ -812,6 +805,10 @@ Call::CallType Call::GetCallType() const {\n     }\n   }\n \n+  if (expression()->IsResolvedProperty()) {\n+    return RESOLVED_PROPERTY_CALL;\n+  }\n+\n   return OTHER_CALL;\n }\n "
        },
        {
            "sha": "f608621d3b167d115ca452e014ae72ca282c535b",
            "filename": "deps/v8/src/ast/ast.h",
            "status": "modified",
            "additions": 56,
            "deletions": 15,
            "changes": 71,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fast.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fast.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fast.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -94,6 +94,7 @@ namespace internal {\n   V(Literal)                    \\\n   V(NativeFunctionLiteral)      \\\n   V(Property)                   \\\n+  V(ResolvedProperty)           \\\n   V(RewritableExpression)       \\\n   V(Spread)                     \\\n   V(SuperCallReference)         \\\n@@ -590,11 +591,13 @@ class ForInStatement final : public ForEachStatement {\n class ForOfStatement final : public ForEachStatement {\n  public:\n   void Initialize(Statement* body, Variable* iterator,\n-                  Expression* assign_iterator, Expression* next_result,\n-                  Expression* result_done, Expression* assign_each) {\n+                  Expression* assign_iterator, Expression* assign_next,\n+                  Expression* next_result, Expression* result_done,\n+                  Expression* assign_each) {\n     ForEachStatement::Initialize(body);\n     iterator_ = iterator;\n     assign_iterator_ = assign_iterator;\n+    assign_next_ = assign_next;\n     next_result_ = next_result;\n     result_done_ = result_done;\n     assign_each_ = assign_each;\n@@ -609,6 +612,9 @@ class ForOfStatement final : public ForEachStatement {\n     return assign_iterator_;\n   }\n \n+  // iteratorRecord.next = iterator.next\n+  Expression* assign_next() const { return assign_next_; }\n+\n   // result = iterator.next()  // with type check\n   Expression* next_result() const {\n     return next_result_;\n@@ -624,6 +630,12 @@ class ForOfStatement final : public ForEachStatement {\n     return assign_each_;\n   }\n \n+  void set_assign_iterator(Expression* e) { assign_iterator_ = e; }\n+  void set_assign_next(Expression* e) { assign_next_ = e; }\n+  void set_next_result(Expression* e) { next_result_ = e; }\n+  void set_result_done(Expression* e) { result_done_ = e; }\n+  void set_assign_each(Expression* e) { assign_each_ = e; }\n+\n  private:\n   friend class AstNodeFactory;\n \n@@ -637,6 +649,7 @@ class ForOfStatement final : public ForEachStatement {\n \n   Variable* iterator_;\n   Expression* assign_iterator_;\n+  Expression* assign_next_;\n   Expression* next_result_;\n   Expression* result_done_;\n   Expression* assign_each_;\n@@ -1450,22 +1463,23 @@ class ArrayLiteral final : public AggregateLiteral {\n   }\n \n   // Provide a mechanism for iterating through values to rewrite spreads.\n-  ZoneList<Expression*>::iterator FirstSpread() const {\n+  ZoneList<Expression*>::iterator FirstSpreadOrEndValue() const {\n     return (first_spread_index_ >= 0) ? values_->begin() + first_spread_index_\n                                       : values_->end();\n   }\n+  ZoneList<Expression*>::iterator BeginValue() const {\n+    return values_->begin();\n+  }\n   ZoneList<Expression*>::iterator EndValue() const { return values_->end(); }\n \n-  // Rewind an array literal omitting everything from the first spread on.\n-  void RewindSpreads();\n-\n  private:\n   friend class AstNodeFactory;\n \n   ArrayLiteral(ZoneList<Expression*>* values, int first_spread_index, int pos)\n       : AggregateLiteral(pos, kArrayLiteral),\n         first_spread_index_(first_spread_index),\n-        values_(values) {}\n+        values_(values) {\n+  }\n \n   int first_spread_index_;\n   Handle<ConstantElementsPair> constant_elements_;\n@@ -1606,6 +1620,25 @@ class Property final : public Expression {\n   Expression* key_;\n };\n \n+// ResolvedProperty pairs a receiver field with a value field. It allows Call\n+// to support arbitrary receivers while still taking advantage of TypeFeedback.\n+class ResolvedProperty final : public Expression {\n+ public:\n+  VariableProxy* object() const { return object_; }\n+  VariableProxy* property() const { return property_; }\n+\n+  void set_object(VariableProxy* e) { object_ = e; }\n+  void set_property(VariableProxy* e) { property_ = e; }\n+\n+ private:\n+  friend class AstNodeFactory;\n+\n+  ResolvedProperty(VariableProxy* obj, VariableProxy* property, int pos)\n+      : Expression(pos, kResolvedProperty), object_(obj), property_(property) {}\n+\n+  VariableProxy* object_;\n+  VariableProxy* property_;\n+};\n \n class Call final : public Expression {\n  public:\n@@ -1632,6 +1665,7 @@ class Call final : public Expression {\n     NAMED_SUPER_PROPERTY_CALL,\n     KEYED_SUPER_PROPERTY_CALL,\n     SUPER_CALL,\n+    RESOLVED_PROPERTY_CALL,\n     OTHER_CALL\n   };\n \n@@ -1697,11 +1731,10 @@ class CallNew final : public Expression {\n   ZoneList<Expression*>* arguments_;\n };\n \n-\n // The CallRuntime class does not represent any official JavaScript\n // language construct. Instead it is used to call a C or JS function\n // with a set of arguments. This is used from the builtins that are\n-// implemented in JavaScript (see \"v8natives.js\").\n+// implemented in JavaScript.\n class CallRuntime final : public Expression {\n  public:\n   ZoneList<Expression*>* arguments() const { return arguments_; }\n@@ -2104,15 +2137,13 @@ class YieldStar final : public Suspend {\n   //   - One for awaiting the iterator result yielded by the delegated iterator\n   //     (await_delegated_iterator_output_suspend_id)\n   int await_iterator_close_suspend_id() const {\n-    DCHECK_NE(-1, await_iterator_close_suspend_id_);\n     return await_iterator_close_suspend_id_;\n   }\n   void set_await_iterator_close_suspend_id(int id) {\n     await_iterator_close_suspend_id_ = id;\n   }\n \n   int await_delegated_iterator_output_suspend_id() const {\n-    DCHECK_NE(-1, await_delegated_iterator_output_suspend_id_);\n     return await_delegated_iterator_output_suspend_id_;\n   }\n   void set_await_delegated_iterator_output_suspend_id(int id) {\n@@ -2168,7 +2199,8 @@ class FunctionLiteral final : public Expression {\n     kAnonymousExpression,\n     kNamedExpression,\n     kDeclaration,\n-    kAccessorOrMethod\n+    kAccessorOrMethod,\n+    kWrapped,\n   };\n \n   enum IdType { kIdTypeInvalid = -1, kIdTypeTopLevel = 0 };\n@@ -2199,6 +2231,7 @@ class FunctionLiteral final : public Expression {\n   bool is_anonymous_expression() const {\n     return function_type() == kAnonymousExpression;\n   }\n+  bool is_wrapped() const { return function_type() == kWrapped; }\n   LanguageMode language_mode() const;\n \n   static bool NeedsHomeObject(Expression* expr);\n@@ -2274,7 +2307,9 @@ class FunctionLiteral final : public Expression {\n   }\n   FunctionKind kind() const;\n \n-  bool dont_optimize() { return dont_optimize_reason() != kNoReason; }\n+  bool dont_optimize() {\n+    return dont_optimize_reason() != BailoutReason::kNoReason;\n+  }\n   BailoutReason dont_optimize_reason() {\n     return DontOptimizeReasonField::decode(bit_field_);\n   }\n@@ -2337,14 +2372,14 @@ class FunctionLiteral final : public Expression {\n                   Pretenure::encode(false) |\n                   HasDuplicateParameters::encode(has_duplicate_parameters ==\n                                                  kHasDuplicateParameters) |\n-                  DontOptimizeReasonField::encode(kNoReason) |\n+                  DontOptimizeReasonField::encode(BailoutReason::kNoReason) |\n                   RequiresInstanceFieldsInitializer::encode(false);\n     if (eager_compile_hint == kShouldEagerCompile) SetShouldEagerCompile();\n     DCHECK_EQ(body == nullptr, expected_property_count < 0);\n   }\n \n   class FunctionTypeBits\n-      : public BitField<FunctionType, Expression::kNextBitFieldIndex, 2> {};\n+      : public BitField<FunctionType, Expression::kNextBitFieldIndex, 3> {};\n   class Pretenure : public BitField<bool, FunctionTypeBits::kNext, 1> {};\n   class HasDuplicateParameters : public BitField<bool, Pretenure::kNext, 1> {};\n   class DontOptimizeReasonField\n@@ -2993,6 +3028,12 @@ class AstNodeFactory final BASE_EMBEDDED {\n     return new (zone_) Property(obj, key, pos);\n   }\n \n+  ResolvedProperty* NewResolvedProperty(VariableProxy* obj,\n+                                        VariableProxy* property,\n+                                        int pos = kNoSourcePosition) {\n+    return new (zone_) ResolvedProperty(obj, property, pos);\n+  }\n+\n   Call* NewCall(Expression* expression, ZoneList<Expression*>* arguments,\n                 int pos, Call::PossiblyEval possibly_eval = Call::NOT_EVAL) {\n     return new (zone_) Call(expression, arguments, pos, possibly_eval);"
        },
        {
            "sha": "374c84828985685d2aec200db7b71aff11f578c0",
            "filename": "deps/v8/src/ast/prettyprinter.cc",
            "status": "modified",
            "additions": 39,
            "deletions": 4,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -26,6 +26,7 @@ CallPrinter::CallPrinter(Isolate* isolate, bool is_user_js)\n   is_iterator_error_ = false;\n   is_async_iterator_error_ = false;\n   is_user_js_ = is_user_js;\n+  function_kind_ = kNormalFunction;\n   InitializeAstVisitor(isolate);\n }\n \n@@ -187,7 +188,10 @@ void CallPrinter::VisitDebuggerStatement(DebuggerStatement* node) {}\n \n \n void CallPrinter::VisitFunctionLiteral(FunctionLiteral* node) {\n+  FunctionKind last_function_kind = function_kind_;\n+  function_kind_ = node->kind();\n   FindStatements(node->body());\n+  function_kind_ = last_function_kind;\n }\n \n \n@@ -250,7 +254,17 @@ void CallPrinter::VisitArrayLiteral(ArrayLiteral* node) {\n   Print(\"[\");\n   for (int i = 0; i < node->values()->length(); i++) {\n     if (i != 0) Print(\",\");\n-    Find(node->values()->at(i), true);\n+    Expression* subexpr = node->values()->at(i);\n+    Spread* spread = subexpr->AsSpread();\n+    if (spread != nullptr && !found_ &&\n+        position_ == spread->expression()->position()) {\n+      found_ = true;\n+      is_iterator_error_ = true;\n+      Find(spread->expression(), true);\n+      done_ = true;\n+      return;\n+    }\n+    Find(subexpr, true);\n   }\n   Print(\"]\");\n }\n@@ -277,7 +291,17 @@ void CallPrinter::VisitCompoundAssignment(CompoundAssignment* node) {\n \n void CallPrinter::VisitYield(Yield* node) { Find(node->expression()); }\n \n-void CallPrinter::VisitYieldStar(YieldStar* node) { Find(node->expression()); }\n+void CallPrinter::VisitYieldStar(YieldStar* node) {\n+  if (!found_ && position_ == node->expression()->position()) {\n+    found_ = true;\n+    if (IsAsyncFunction(function_kind_))\n+      is_async_iterator_error_ = true;\n+    else\n+      is_iterator_error_ = true;\n+    Print(\"yield* \");\n+  }\n+  Find(node->expression());\n+}\n \n void CallPrinter::VisitAwait(Await* node) { Find(node->expression()); }\n \n@@ -302,6 +326,7 @@ void CallPrinter::VisitProperty(Property* node) {\n   }\n }\n \n+void CallPrinter::VisitResolvedProperty(ResolvedProperty* node) {}\n \n void CallPrinter::VisitCall(Call* node) {\n   bool was_found = false;\n@@ -960,8 +985,10 @@ void AstPrinter::VisitTryCatchStatement(TryCatchStatement* node) {\n       UNREACHABLE();\n   }\n   Print(\" %s\\n\", prediction);\n-  PrintLiteralWithModeIndented(\"CATCHVAR\", node->scope()->catch_variable(),\n-                               node->scope()->catch_variable()->raw_name());\n+  if (node->scope()) {\n+    PrintLiteralWithModeIndented(\"CATCHVAR\", node->scope()->catch_variable(),\n+                                 node->scope()->catch_variable()->raw_name());\n+  }\n   PrintIndentedVisit(\"CATCH\", node->catch_block());\n }\n \n@@ -1223,6 +1250,14 @@ void AstPrinter::VisitProperty(Property* node) {\n   }\n }\n \n+void AstPrinter::VisitResolvedProperty(ResolvedProperty* node) {\n+  EmbeddedVector<char, 128> buf;\n+  SNPrintF(buf, \"RESOLVED-PROPERTY\");\n+  IndentedScope indent(this, buf.start(), node->position());\n+\n+  PrintIndentedVisit(\"RECEIVER\", node->object());\n+  PrintIndentedVisit(\"PROPERTY\", node->property());\n+}\n \n void AstPrinter::VisitCall(Call* node) {\n   EmbeddedVector<char, 128> buf;"
        },
        {
            "sha": "d93137b7cf10b1312f9769f36fe03e59886b1abb",
            "filename": "deps/v8/src/ast/prettyprinter.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -50,6 +50,7 @@ class CallPrinter final : public AstVisitor<CallPrinter> {\n   bool is_iterator_error_;\n   bool is_async_iterator_error_;\n   bool is_call_error_;\n+  FunctionKind function_kind_;\n   DEFINE_AST_VISITOR_SUBCLASS_MEMBERS();\n \n  protected:"
        },
        {
            "sha": "8f2f85080cb196d9a98ec72804890f98b9e23532",
            "filename": "deps/v8/src/ast/scopes.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 17,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fscopes.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fscopes.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fscopes.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -147,8 +147,6 @@ Scope::Scope(Zone* zone, Scope* outer_scope, ScopeType scope_type)\n   DCHECK_NE(SCRIPT_SCOPE, scope_type);\n   SetDefaults();\n   set_language_mode(outer_scope->language_mode());\n-  force_context_allocation_ =\n-      !is_function_scope() && outer_scope->has_forced_context_allocation();\n   outer_scope_->AddInnerScope(this);\n }\n \n@@ -649,8 +647,8 @@ void DeclarationScope::Analyze(ParseInfo* info) {\n   RuntimeCallTimerScope runtimeTimer(\n       info->runtime_call_stats(),\n       info->on_background_thread()\n-          ? &RuntimeCallStats::CompileBackgroundScopeAnalysis\n-          : &RuntimeCallStats::CompileScopeAnalysis);\n+          ? RuntimeCallCounterId::kCompileBackgroundScopeAnalysis\n+          : RuntimeCallCounterId::kCompileScopeAnalysis);\n   DCHECK_NOT_NULL(info->literal());\n   DeclarationScope* scope = info->literal()->scope();\n \n@@ -1370,12 +1368,8 @@ bool Scope::AllowsLazyParsingWithoutUnresolvedVariables(\n     if (s->is_catch_scope()) continue;\n     // With scopes do not introduce variables that need allocation.\n     if (s->is_with_scope()) continue;\n-    // Module scopes context-allocate all variables, and have no\n-    // {this} or {arguments} variables whose existence depends on\n-    // references to them.\n-    if (s->is_module_scope()) continue;\n-    // Only block scopes and function scopes should disallow preparsing.\n-    DCHECK(s->is_block_scope() || s->is_function_scope());\n+    DCHECK(s->is_module_scope() || s->is_block_scope() ||\n+           s->is_function_scope());\n     return false;\n   }\n   return true;\n@@ -1443,6 +1437,10 @@ bool Scope::NeedsScopeInfo() const {\n   return NeedsContext();\n }\n \n+bool Scope::ShouldBanArguments() {\n+  return GetReceiverScope()->should_ban_arguments();\n+}\n+\n DeclarationScope* Scope::GetReceiverScope() {\n   Scope* scope = this;\n   while (!scope->is_script_scope() &&\n@@ -1734,9 +1732,6 @@ void Scope::Print(int n) {\n     if (scope->was_lazily_parsed()) Indent(n1, \"// lazily parsed\\n\");\n     if (scope->ShouldEagerCompile()) Indent(n1, \"// will be compiled\\n\");\n   }\n-  if (has_forced_context_allocation()) {\n-    Indent(n1, \"// forces context allocation\\n\");\n-  }\n   if (num_stack_slots_ > 0) {\n     Indent(n1, \"// \");\n     PrintF(\"%d stack slots\\n\", num_stack_slots_);\n@@ -2111,11 +2106,8 @@ bool Scope::MustAllocateInContext(Variable* var) {\n   // an eval() call or a runtime with lookup), it must be allocated in the\n   // context.\n   //\n-  // Exceptions: If the scope as a whole has forced context allocation, all\n-  // variables will have context allocation, even temporaries.  Otherwise\n-  // temporary variables are always stack-allocated.  Catch-bound variables are\n+  // Temporary variables are always stack-allocated.  Catch-bound variables are\n   // always context-allocated.\n-  if (has_forced_context_allocation()) return true;\n   if (var->mode() == TEMPORARY) return false;\n   if (is_catch_scope()) return true;\n   if ((is_script_scope() || is_eval_scope()) &&"
        },
        {
            "sha": "d2e88863199df4073899ac1f4551c2b4d8f07dda",
            "filename": "deps/v8/src/ast/scopes.h",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fscopes.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fast%2Fscopes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fscopes.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -334,14 +334,6 @@ class V8_EXPORT_PRIVATE Scope : public NON_EXPORTED_BASE(ZoneObject) {\n   bool is_hidden() const { return is_hidden_; }\n   void set_is_hidden() { is_hidden_ = true; }\n \n-  // In some cases we want to force context allocation for a whole scope.\n-  void ForceContextAllocation() {\n-    DCHECK(!already_resolved_);\n-    force_context_allocation_ = true;\n-  }\n-  bool has_forced_context_allocation() const {\n-    return force_context_allocation_;\n-  }\n   void ForceContextAllocationForParameters() {\n     DCHECK(!already_resolved_);\n     force_context_allocation_for_parameters_ = true;\n@@ -404,6 +396,8 @@ class V8_EXPORT_PRIVATE Scope : public NON_EXPORTED_BASE(ZoneObject) {\n     return static_cast<Variable*>(variables_.Start()->value);\n   }\n \n+  bool ShouldBanArguments();\n+\n   // ---------------------------------------------------------------------------\n   // Variable allocation.\n \n@@ -704,6 +698,10 @@ class V8_EXPORT_PRIVATE DeclarationScope : public Scope {\n   bool asm_module() const { return asm_module_; }\n   void set_asm_module();\n \n+  bool should_ban_arguments() const {\n+    return IsClassFieldsInitializerFunction(function_kind());\n+  }\n+\n   void DeclareThis(AstValueFactory* ast_value_factory);\n   void DeclareArguments(AstValueFactory* ast_value_factory);\n   void DeclareDefaultFunctionVariables(AstValueFactory* ast_value_factory);"
        },
        {
            "sha": "7cf983861cbf0c395a88026bbddb9066d786da2f",
            "filename": "deps/v8/src/bailout-reason.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 5,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbailout-reason.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbailout-reason.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbailout-reason.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -8,13 +8,24 @@\n namespace v8 {\n namespace internal {\n \n-const char* GetBailoutReason(BailoutReason reason) {\n-  DCHECK_LT(reason, kLastErrorMessage);\n #define ERROR_MESSAGES_TEXTS(C, T) T,\n+\n+const char* GetBailoutReason(BailoutReason reason) {\n+  DCHECK_LT(reason, BailoutReason::kLastErrorMessage);\n+  DCHECK_GE(reason, BailoutReason::kNoReason);\n   static const char* error_messages_[] = {\n-      ERROR_MESSAGES_LIST(ERROR_MESSAGES_TEXTS)};\n-#undef ERROR_MESSAGES_TEXTS\n-  return error_messages_[reason];\n+      BAILOUT_MESSAGES_LIST(ERROR_MESSAGES_TEXTS)};\n+  return error_messages_[static_cast<int>(reason)];\n }\n+\n+const char* GetAbortReason(AbortReason reason) {\n+  DCHECK_LT(reason, AbortReason::kLastErrorMessage);\n+  DCHECK_GE(reason, AbortReason::kNoReason);\n+  static const char* error_messages_[] = {\n+      ABORT_MESSAGES_LIST(ERROR_MESSAGES_TEXTS)};\n+  return error_messages_[static_cast<int>(reason)];\n+}\n+\n+#undef ERROR_MESSAGES_TEXTS\n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "c8e81c69d42adebba9dac4610d091bfd09385513",
            "filename": "deps/v8/src/bailout-reason.h",
            "status": "modified",
            "additions": 41,
            "deletions": 82,
            "changes": 123,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbailout-reason.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbailout-reason.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbailout-reason.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -8,158 +8,117 @@\n namespace v8 {\n namespace internal {\n \n-// TODO(svenpanne) introduce an AbortReason and partition this list\n-#define ERROR_MESSAGES_LIST(V)                                                 \\\n+#define ABORT_MESSAGES_LIST(V)                                                 \\\n   V(kNoReason, \"no reason\")                                                    \\\n                                                                                \\\n   V(k32BitValueInRegisterIsNotZeroExtended,                                    \\\n     \"32 bit value in register is not zero-extended\")                           \\\n+  V(kAPICallReturnedInvalidObject, \"API call returned invalid object\")         \\\n   V(kAllocatingNonEmptyPackedArray, \"Allocating non-empty packed array\")       \\\n   V(kAllocationIsNotDoubleAligned, \"Allocation is not double aligned\")         \\\n-  V(kAPICallReturnedInvalidObject, \"API call returned invalid object\")         \\\n-  V(kBailedOutDueToDependencyChange, \"Bailed out due to dependency change\")    \\\n-  V(kClassConstructorFunction, \"Class constructor function\")                   \\\n-  V(kClassLiteral, \"Class literal\")                                            \\\n-  V(kCodeGenerationFailed, \"Code generation failed\")                           \\\n   V(kCodeObjectNotProperlyPatched, \"Code object not properly patched\")         \\\n-  V(kComputedPropertyName, \"Computed property name\")                           \\\n-  V(kContextAllocatedArguments, \"Context-allocated arguments\")                 \\\n-  V(kDebuggerStatement, \"DebuggerStatement\")                                   \\\n-  V(kDeclarationInCatchContext, \"Declaration in catch context\")                \\\n-  V(kDeclarationInWithContext, \"Declaration in with context\")                  \\\n-  V(kDynamicImport, \"Dynamic module import\")                                   \\\n-  V(kCyclicObjectStateDetectedInEscapeAnalysis,                                \\\n-    \"Cyclic object state detected by escape analysis\")                         \\\n-  V(kEval, \"eval\")                                                             \\\n   V(kExpectedAllocationSite, \"Expected allocation site\")                       \\\n-  V(kExpectedBooleanValue, \"Expected boolean value\")                           \\\n   V(kExpectedFeedbackVector, \"Expected feedback vector\")                       \\\n-  V(kExpectedHeapNumber, \"Expected HeapNumber\")                                \\\n-  V(kExpectedNonIdenticalObjects, \"Expected non-identical objects\")            \\\n   V(kExpectedOptimizationSentinel,                                             \\\n     \"Expected optimized code cell or optimization sentinel\")                   \\\n-  V(kExpectedNewSpaceObject, \"Expected new space object\")                      \\\n   V(kExpectedUndefinedOrCell, \"Expected undefined or cell in register\")        \\\n-  V(kForOfStatement, \"ForOfStatement\")                                         \\\n-  V(kFunctionBeingDebugged, \"Function is being debugged\")                      \\\n-  V(kFunctionCallsEval, \"Function calls eval\")                                 \\\n   V(kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry,                      \\\n     \"The function_data field should be a BytecodeArray on interpreter entry\")  \\\n-  V(kGenerator, \"Generator\")                                                   \\\n-  V(kGetIterator, \"GetIterator\")                                               \\\n-  V(kGraphBuildingFailed, \"Optimized graph construction failed\")               \\\n-  V(kHeapNumberMapRegisterClobbered, \"HeapNumberMap register clobbered\")       \\\n-  V(kIndexIsNegative, \"Index is negative\")                                     \\\n-  V(kIndexIsTooLarge, \"Index is too large\")                                    \\\n-  V(kInputGPRIsExpectedToHaveUpper32Cleared,                                   \\\n-    \"Input GPR is expected to have upper32 cleared\")                           \\\n   V(kInputStringTooLong, \"Input string too long\")                              \\\n   V(kInvalidBytecode, \"Invalid bytecode\")                                      \\\n   V(kInvalidElementsKindForInternalArrayOrInternalPackedArray,                 \\\n     \"Invalid ElementsKind for InternalArray or InternalPackedArray\")           \\\n-  V(kInvalidFullCodegenState, \"invalid full-codegen state\")                    \\\n   V(kInvalidHandleScopeLevel, \"Invalid HandleScope level\")                     \\\n   V(kInvalidJumpTableIndex, \"Invalid jump table index\")                        \\\n   V(kInvalidRegisterFileInGenerator, \"invalid register file in generator\")     \\\n-  V(kLiveEdit, \"LiveEdit\")                                                     \\\n   V(kMissingBytecodeArray, \"Missing bytecode array from function\")             \\\n-  V(kNativeFunctionLiteral, \"Native function literal\")                         \\\n-  V(kNoCasesLeft, \"No cases left\")                                             \\\n-  V(kNonObject, \"Non-object value\")                                            \\\n-  V(kNotEnoughVirtualRegistersRegalloc,                                        \\\n-    \"Not enough virtual registers (regalloc)\")                                 \\\n+  V(kObjectNotTagged, \"The object is not tagged\")                              \\\n+  V(kObjectTagged, \"The object is tagged\")                                     \\\n   V(kOffsetOutOfRange, \"Offset out of range\")                                  \\\n+  V(kOperandIsASmi, \"Operand is a smi\")                                        \\\n   V(kOperandIsASmiAndNotABoundFunction,                                        \\\n     \"Operand is a smi and not a bound function\")                               \\\n   V(kOperandIsASmiAndNotAFixedArray, \"Operand is a smi and not a fixed array\") \\\n   V(kOperandIsASmiAndNotAFunction, \"Operand is a smi and not a function\")      \\\n   V(kOperandIsASmiAndNotAGeneratorObject,                                      \\\n     \"Operand is a smi and not a generator object\")                             \\\n-  V(kOperandIsASmi, \"Operand is a smi\")                                        \\\n   V(kOperandIsNotABoundFunction, \"Operand is not a bound function\")            \\\n   V(kOperandIsNotAFixedArray, \"Operand is not a fixed array\")                  \\\n   V(kOperandIsNotAFunction, \"Operand is not a function\")                       \\\n   V(kOperandIsNotAGeneratorObject, \"Operand is not a generator object\")        \\\n   V(kOperandIsNotASmi, \"Operand is not a smi\")                                 \\\n-  V(kOperandIsNotSmi, \"Operand is not smi\")                                    \\\n-  V(kObjectTagged, \"The object is tagged\")                                     \\\n-  V(kObjectNotTagged, \"The object is not tagged\")                              \\\n-  V(kOptimizationDisabled, \"Optimization disabled\")                            \\\n-  V(kOptimizationDisabledForTest, \"Optimization disabled for test\")            \\\n   V(kReceivedInvalidReturnAddress, \"Received invalid return address\")          \\\n-  V(kReferenceToAVariableWhichRequiresDynamicLookup,                           \\\n-    \"Reference to a variable which requires dynamic lookup\")                   \\\n-  V(kReferenceToModuleVariable, \"Reference to module-allocated variable\")      \\\n   V(kRegisterDidNotMatchExpectedRoot, \"Register did not match expected root\")  \\\n   V(kRegisterWasClobbered, \"Register was clobbered\")                           \\\n-  V(kRememberedSetPointerInNewSpace, \"Remembered set pointer is in new space\") \\\n-  V(kRestParameter, \"Rest parameters\")                                         \\\n   V(kReturnAddressNotFoundInFrame, \"Return address not found in frame\")        \\\n-  V(kSpreadCall, \"Call with spread argument\")                                  \\\n+  V(kShouldNotDirectlyEnterOsrFunction,                                        \\\n+    \"Should not directly enter OSR-compiled function\")                         \\\n   V(kStackAccessBelowStackPointer, \"Stack access below stack pointer\")         \\\n   V(kStackFrameTypesMustMatch, \"Stack frame types must match\")                 \\\n-  V(kSuperReference, \"Super reference\")                                        \\\n-  V(kTailCall, \"Tail call\")                                                    \\\n   V(kTheCurrentStackPointerIsBelowCsp,                                         \\\n     \"The current stack pointer is below csp\")                                  \\\n   V(kTheStackWasCorruptedByMacroAssemblerCall,                                 \\\n     \"The stack was corrupted by MacroAssembler::Call()\")                       \\\n-  V(kTooManyParameters, \"Too many parameters\")                                 \\\n-  V(kTryCatchStatement, \"TryCatchStatement\")                                   \\\n-  V(kTryFinallyStatement, \"TryFinallyStatement\")                               \\\n-  V(kUnalignedAllocationInNewSpace, \"Unaligned allocation in new space\")       \\\n   V(kUnalignedCellInWriteBarrier, \"Unaligned cell in write barrier\")           \\\n-  V(kUnexpectedColorFound, \"Unexpected color bit pattern found\")               \\\n   V(kUnexpectedElementsKindInArrayConstructor,                                 \\\n     \"Unexpected ElementsKind in array constructor\")                            \\\n-  V(kUnexpectedFallthroughFromCharCodeAtSlowCase,                              \\\n-    \"Unexpected fallthrough from CharCodeAt slow case\")                        \\\n-  V(kUnexpectedFallThroughFromStringComparison,                                \\\n-    \"Unexpected fall-through from string comparison\")                          \\\n-  V(kUnexpectedFallthroughToCharCodeAtSlowCase,                                \\\n-    \"Unexpected fallthrough to CharCodeAt slow case\")                          \\\n+  V(kUnexpectedFPCRMode, \"Unexpected FPCR mode.\")                              \\\n+  V(kUnexpectedFunctionIDForInvokeIntrinsic,                                   \\\n+    \"Unexpected runtime function id for the InvokeIntrinsic bytecode\")         \\\n+  V(kUnexpectedInitialMapForArrayFunction,                                     \\\n+    \"Unexpected initial map for Array function\")                               \\\n   V(kUnexpectedInitialMapForArrayFunction1,                                    \\\n     \"Unexpected initial map for Array function (1)\")                           \\\n   V(kUnexpectedInitialMapForArrayFunction2,                                    \\\n     \"Unexpected initial map for Array function (2)\")                           \\\n-  V(kUnexpectedInitialMapForArrayFunction,                                     \\\n-    \"Unexpected initial map for Array function\")                               \\\n   V(kUnexpectedInitialMapForInternalArrayFunction,                             \\\n     \"Unexpected initial map for InternalArray function\")                       \\\n   V(kUnexpectedLevelAfterReturnFromApiCall,                                    \\\n     \"Unexpected level after return from api call\")                             \\\n   V(kUnexpectedNegativeValue, \"Unexpected negative value\")                     \\\n-  V(kUnexpectedFunctionIDForInvokeIntrinsic,                                   \\\n-    \"Unexpected runtime function id for the InvokeIntrinsic bytecode\")         \\\n-  V(kUnexpectedFPCRMode, \"Unexpected FPCR mode.\")                              \\\n-  V(kUnexpectedStackDepth, \"Unexpected operand stack depth in full-codegen\")   \\\n+  V(kUnexpectedReturnFromFrameDropper,                                         \\\n+    \"Unexpectedly returned from dropping frames\")                              \\\n+  V(kUnexpectedReturnFromThrow, \"Unexpectedly returned from a throw\")          \\\n+  V(kUnexpectedReturnFromWasmTrap,                                             \\\n+    \"Should not return after throwing a wasm trap\")                            \\\n   V(kUnexpectedStackPointer, \"The stack pointer is not the expected value\")    \\\n-  V(kUnexpectedStringType, \"Unexpected string type\")                           \\\n   V(kUnexpectedValue, \"Unexpected value\")                                      \\\n   V(kUnsupportedModuleOperation, \"Unsupported module operation\")               \\\n   V(kUnsupportedNonPrimitiveCompare, \"Unsupported non-primitive compare\")      \\\n-  V(kUnexpectedReturnFromFrameDropper,                                         \\\n-    \"Unexpectedly returned from dropping frames\")                              \\\n-  V(kUnexpectedReturnFromThrow, \"Unexpectedly returned from a throw\")          \\\n-  V(kVariableResolvedToWithContext, \"Variable resolved to with context\")       \\\n-  V(kWithStatement, \"WithStatement\")                                           \\\n-  V(kWrongFunctionContext, \"Wrong context passed to function\")                 \\\n   V(kWrongAddressOrValuePassedToRecordWrite,                                   \\\n     \"Wrong address or value passed to RecordWrite\")                            \\\n   V(kWrongArgumentCountForInvokeIntrinsic,                                     \\\n     \"Wrong number of arguments for intrinsic\")                                 \\\n-  V(kShouldNotDirectlyEnterOsrFunction,                                        \\\n-    \"Should not directly enter OSR-compiled function\")                         \\\n-  V(kUnexpectedReturnFromWasmTrap,                                             \\\n-    \"Should not return after throwing a wasm trap\")\n+  V(kWrongFunctionContext, \"Wrong context passed to function\")\n+\n+#define BAILOUT_MESSAGES_LIST(V)                                            \\\n+  V(kNoReason, \"no reason\")                                                 \\\n+                                                                            \\\n+  V(kBailedOutDueToDependencyChange, \"Bailed out due to dependency change\") \\\n+  V(kCodeGenerationFailed, \"Code generation failed\")                        \\\n+  V(kCyclicObjectStateDetectedInEscapeAnalysis,                             \\\n+    \"Cyclic object state detected by escape analysis\")                      \\\n+  V(kFunctionBeingDebugged, \"Function is being debugged\")                   \\\n+  V(kGraphBuildingFailed, \"Optimized graph construction failed\")            \\\n+  V(kLiveEdit, \"LiveEdit\")                                                  \\\n+  V(kNativeFunctionLiteral, \"Native function literal\")                      \\\n+  V(kNotEnoughVirtualRegistersRegalloc,                                     \\\n+    \"Not enough virtual registers (regalloc)\")                              \\\n+  V(kOptimizationDisabled, \"Optimization disabled\")                         \\\n+  V(kOptimizationDisabledForTest, \"Optimization disabled for test\")\n \n #define ERROR_MESSAGES_CONSTANTS(C, T) C,\n-enum BailoutReason {\n-  ERROR_MESSAGES_LIST(ERROR_MESSAGES_CONSTANTS) kLastErrorMessage\n+enum class BailoutReason {\n+  BAILOUT_MESSAGES_LIST(ERROR_MESSAGES_CONSTANTS) kLastErrorMessage\n+};\n+\n+enum class AbortReason {\n+  ABORT_MESSAGES_LIST(ERROR_MESSAGES_CONSTANTS) kLastErrorMessage\n };\n #undef ERROR_MESSAGES_CONSTANTS\n \n const char* GetBailoutReason(BailoutReason reason);\n+const char* GetAbortReason(AbortReason reason);\n \n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "a9c31c20d6dc3e0586592a6783a3eecdedae2e00",
            "filename": "deps/v8/src/base/DEPS",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2FDEPS",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2FDEPS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2FDEPS?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -1,6 +1,7 @@\n include_rules = [\n   \"-include\",\n   \"+include/v8config.h\",\n+  \"+include/v8-platform.h\",\n   \"-src\",\n   \"+src/base\",\n ]"
        },
        {
            "sha": "22e0511dc7d8b866b13b0c33ea74df3239aa4dee",
            "filename": "deps/v8/src/base/cpu.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fcpu.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fcpu.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fcpu.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -356,12 +356,12 @@ CPU::CPU()\n   // Interpret CPU feature information.\n   if (num_ids > 0) {\n     __cpuid(cpu_info, 1);\n-    stepping_ = cpu_info[0] & 0xf;\n-    model_ = ((cpu_info[0] >> 4) & 0xf) + ((cpu_info[0] >> 12) & 0xf0);\n-    family_ = (cpu_info[0] >> 8) & 0xf;\n+    stepping_ = cpu_info[0] & 0xF;\n+    model_ = ((cpu_info[0] >> 4) & 0xF) + ((cpu_info[0] >> 12) & 0xF0);\n+    family_ = (cpu_info[0] >> 8) & 0xF;\n     type_ = (cpu_info[0] >> 12) & 0x3;\n-    ext_model_ = (cpu_info[0] >> 16) & 0xf;\n-    ext_family_ = (cpu_info[0] >> 20) & 0xff;\n+    ext_model_ = (cpu_info[0] >> 16) & 0xF;\n+    ext_family_ = (cpu_info[0] >> 20) & 0xFF;\n     has_fpu_ = (cpu_info[3] & 0x00000001) != 0;\n     has_cmov_ = (cpu_info[3] & 0x00008000) != 0;\n     has_mmx_ = (cpu_info[3] & 0x00800000) != 0;\n@@ -378,16 +378,16 @@ CPU::CPU()\n \n     if (family_ == 0x6) {\n       switch (model_) {\n-        case 0x1c:  // SLT\n+        case 0x1C:  // SLT\n         case 0x26:\n         case 0x36:\n         case 0x27:\n         case 0x35:\n         case 0x37:  // SLM\n-        case 0x4a:\n-        case 0x4d:\n-        case 0x4c:  // AMT\n-        case 0x6e:\n+        case 0x4A:\n+        case 0x4D:\n+        case 0x4C:  // AMT\n+        case 0x6E:\n           is_atom_ = true;\n       }\n     }"
        },
        {
            "sha": "ec3add1682be13b838ade38a36a41c24add1678b",
            "filename": "deps/v8/src/base/debug/stack_trace_posix.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fdebug%2Fstack_trace_posix.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fdebug%2Fstack_trace_posix.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fdebug%2Fstack_trace_posix.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -400,7 +400,7 @@ char* itoa_r(intptr_t i, char* buf, size_t sz, int base, size_t padding) {\n   if (n > sz) return nullptr;\n \n   if (base < 2 || base > 16) {\n-    buf[0] = '\\000';\n+    buf[0] = '\\0';\n     return nullptr;\n   }\n \n@@ -415,7 +415,7 @@ char* itoa_r(intptr_t i, char* buf, size_t sz, int base, size_t padding) {\n \n     // Make sure we can write the '-' character.\n     if (++n > sz) {\n-      buf[0] = '\\000';\n+      buf[0] = '\\0';\n       return nullptr;\n     }\n     *start++ = '-';\n@@ -427,7 +427,7 @@ char* itoa_r(intptr_t i, char* buf, size_t sz, int base, size_t padding) {\n   do {\n     // Make sure there is still enough space left in our output buffer.\n     if (++n > sz) {\n-      buf[0] = '\\000';\n+      buf[0] = '\\0';\n       return nullptr;\n     }\n \n@@ -439,7 +439,7 @@ char* itoa_r(intptr_t i, char* buf, size_t sz, int base, size_t padding) {\n   } while (j > 0 || padding > 0);\n \n   // Terminate the output with a NUL character.\n-  *ptr = '\\000';\n+  *ptr = '\\0';\n \n   // Conversion to ASCII actually resulted in the digits being in reverse\n   // order. We can't easily generate them in forward order, as we can't tell"
        },
        {
            "sha": "dffb91f3cc1af4d1261e6c04658a148a56254871",
            "filename": "deps/v8/src/base/functional.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Ffunctional.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Ffunctional.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Ffunctional.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -69,18 +69,18 @@ V8_INLINE size_t hash_value_unsigned(T v) {\n // This code was taken from MurmurHash.\n size_t hash_combine(size_t seed, size_t value) {\n #if V8_HOST_ARCH_32_BIT\n-  const uint32_t c1 = 0xcc9e2d51;\n-  const uint32_t c2 = 0x1b873593;\n+  const uint32_t c1 = 0xCC9E2D51;\n+  const uint32_t c2 = 0x1B873593;\n \n   value *= c1;\n   value = bits::RotateRight32(value, 15);\n   value *= c2;\n \n   seed ^= value;\n   seed = bits::RotateRight32(seed, 13);\n-  seed = seed * 5 + 0xe6546b64;\n+  seed = seed * 5 + 0xE6546B64;\n #else\n-  const uint64_t m = V8_UINT64_C(0xc6a4a7935bd1e995);\n+  const uint64_t m = uint64_t{0xC6A4A7935BD1E995};\n   const uint32_t r = 47;\n \n   value *= m;"
        },
        {
            "sha": "54f7e2e6aaa1131f970c048cbafc7cd6bf309a39",
            "filename": "deps/v8/src/base/ieee754.cc",
            "status": "modified",
            "additions": 141,
            "deletions": 141,
            "changes": 282,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fieee754.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fieee754.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fieee754.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -225,16 +225,16 @@ int32_t __ieee754_rem_pio2(double x, double *y) {\n \n   z = 0;\n   GET_HIGH_WORD(hx, x); /* high word of x */\n-  ix = hx & 0x7fffffff;\n-  if (ix <= 0x3fe921fb) { /* |x| ~<= pi/4 , no need for reduction */\n+  ix = hx & 0x7FFFFFFF;\n+  if (ix <= 0x3FE921FB) { /* |x| ~<= pi/4 , no need for reduction */\n     y[0] = x;\n     y[1] = 0;\n     return 0;\n   }\n-  if (ix < 0x4002d97c) { /* |x| < 3pi/4, special case with n=+-1 */\n+  if (ix < 0x4002D97C) { /* |x| < 3pi/4, special case with n=+-1 */\n     if (hx > 0) {\n       z = x - pio2_1;\n-      if (ix != 0x3ff921fb) { /* 33+53 bit pi is good enough */\n+      if (ix != 0x3FF921FB) { /* 33+53 bit pi is good enough */\n         y[0] = z - pio2_1t;\n         y[1] = (z - y[0]) - pio2_1t;\n       } else { /* near pi/2, use 33+33+53 bit pi */\n@@ -245,7 +245,7 @@ int32_t __ieee754_rem_pio2(double x, double *y) {\n       return 1;\n     } else { /* negative x */\n       z = x + pio2_1;\n-      if (ix != 0x3ff921fb) { /* 33+53 bit pi is good enough */\n+      if (ix != 0x3FF921FB) { /* 33+53 bit pi is good enough */\n         y[0] = z + pio2_1t;\n         y[1] = (z - y[0]) + pio2_1t;\n       } else { /* near pi/2, use 33+33+53 bit pi */\n@@ -256,7 +256,7 @@ int32_t __ieee754_rem_pio2(double x, double *y) {\n       return -1;\n     }\n   }\n-  if (ix <= 0x413921fb) { /* |x| ~<= 2^19*(pi/2), medium size */\n+  if (ix <= 0x413921FB) { /* |x| ~<= 2^19*(pi/2), medium size */\n     t = fabs(x);\n     n = static_cast<int32_t>(t * invpio2 + half);\n     fn = static_cast<double>(n);\n@@ -269,15 +269,15 @@ int32_t __ieee754_rem_pio2(double x, double *y) {\n       j = ix >> 20;\n       y[0] = r - w;\n       GET_HIGH_WORD(high, y[0]);\n-      i = j - ((high >> 20) & 0x7ff);\n+      i = j - ((high >> 20) & 0x7FF);\n       if (i > 16) { /* 2nd iteration needed, good to 118 */\n         t = r;\n         w = fn * pio2_2;\n         r = t - w;\n         w = fn * pio2_2t - ((t - r) - w);\n         y[0] = r - w;\n         GET_HIGH_WORD(high, y[0]);\n-        i = j - ((high >> 20) & 0x7ff);\n+        i = j - ((high >> 20) & 0x7FF);\n         if (i > 49) { /* 3rd iteration need, 151 bits acc */\n           t = r;      /* will cover all possible cases */\n           w = fn * pio2_3;\n@@ -299,7 +299,7 @@ int32_t __ieee754_rem_pio2(double x, double *y) {\n   /*\n    * all other (large) arguments\n    */\n-  if (ix >= 0x7ff00000) { /* x is inf or NaN */\n+  if (ix >= 0x7FF00000) { /* x is inf or NaN */\n     y[0] = y[1] = x - x;\n     return 0;\n   }\n@@ -331,7 +331,7 @@ int32_t __ieee754_rem_pio2(double x, double *y) {\n  *\n  * Algorithm\n  *      1. Since cos(-x) = cos(x), we need only to consider positive x.\n- *      2. if x < 2^-27 (hx<0x3e400000 0), return 1 with inexact if x!=0.\n+ *      2. if x < 2^-27 (hx<0x3E400000 0), return 1 with inexact if x!=0.\n  *      3. cos(x) is approximated by a polynomial of degree 14 on\n  *         [0,pi/4]\n  *                                       4            14\n@@ -370,16 +370,16 @@ V8_INLINE double __kernel_cos(double x, double y) {\n   double a, iz, z, r, qx;\n   int32_t ix;\n   GET_HIGH_WORD(ix, x);\n-  ix &= 0x7fffffff;                           /* ix = |x|'s high word*/\n-  if (ix < 0x3e400000) {                      /* if x < 2**27 */\n+  ix &= 0x7FFFFFFF;                           /* ix = |x|'s high word*/\n+  if (ix < 0x3E400000) {                      /* if x < 2**27 */\n     if (static_cast<int>(x) == 0) return one; /* generate inexact */\n   }\n   z = x * x;\n   r = z * (C1 + z * (C2 + z * (C3 + z * (C4 + z * (C5 + z * C6)))));\n   if (ix < 0x3FD33333) { /* if |x| < 0.3 */\n     return one - (0.5 * z - (z * r - x * y));\n   } else {\n-    if (ix > 0x3fe90000) { /* x > 0.78125 */\n+    if (ix > 0x3FE90000) { /* x > 0.78125 */\n       qx = 0.28125;\n     } else {\n       INSERT_WORDS(qx, ix - 0x00200000, 0); /* x/4 */\n@@ -585,16 +585,16 @@ int __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec,\n           iq[i] = 0x1000000 - j;\n         }\n       } else {\n-        iq[i] = 0xffffff - j;\n+        iq[i] = 0xFFFFFF - j;\n       }\n     }\n     if (q0 > 0) { /* rare case: chance is 1 in 12 */\n       switch (q0) {\n         case 1:\n-          iq[jz - 1] &= 0x7fffff;\n+          iq[jz - 1] &= 0x7FFFFF;\n           break;\n         case 2:\n-          iq[jz - 1] &= 0x3fffff;\n+          iq[jz - 1] &= 0x3FFFFF;\n           break;\n       }\n     }\n@@ -706,7 +706,7 @@ int __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec,\n  *\n  * Algorithm\n  *      1. Since sin(-x) = -sin(x), we need only to consider positive x.\n- *      2. if x < 2^-27 (hx<0x3e400000 0), return x with inexact if x!=0.\n+ *      2. if x < 2^-27 (hx<0x3E400000 0), return x with inexact if x!=0.\n  *      3. sin(x) is approximated by a polynomial of degree 13 on\n  *         [0,pi/4]\n  *                               3            13\n@@ -738,8 +738,8 @@ V8_INLINE double __kernel_sin(double x, double y, int iy) {\n   double z, r, v;\n   int32_t ix;\n   GET_HIGH_WORD(ix, x);\n-  ix &= 0x7fffffff;      /* high word of x */\n-  if (ix < 0x3e400000) { /* |x| < 2**-27 */\n+  ix &= 0x7FFFFFFF;      /* high word of x */\n+  if (ix < 0x3E400000) { /* |x| < 2**-27 */\n     if (static_cast<int>(x) == 0) return x;\n   } /* generate inexact */\n   z = x * x;\n@@ -761,7 +761,7 @@ V8_INLINE double __kernel_sin(double x, double y, int iy) {\n  *\n  * Algorithm\n  *      1. Since tan(-x) = -tan(x), we need only to consider positive x.\n- *      2. if x < 2^-28 (hx<0x3e300000 0), return x with inexact if x!=0.\n+ *      2. if x < 2^-28 (hx<0x3E300000 0), return x with inexact if x!=0.\n  *      3. tan(x) is approximated by a odd polynomial of degree 27 on\n  *         [0,0.67434]\n  *                               3             27\n@@ -813,8 +813,8 @@ double __kernel_tan(double x, double y, int iy) {\n   int32_t ix, hx;\n \n   GET_HIGH_WORD(hx, x);             /* high word of x */\n-  ix = hx & 0x7fffffff;             /* high word of |x| */\n-  if (ix < 0x3e300000) {            /* x < 2**-28 */\n+  ix = hx & 0x7FFFFFFF;             /* high word of |x| */\n+  if (ix < 0x3E300000) {            /* x < 2**-28 */\n     if (static_cast<int>(x) == 0) { /* generate inexact */\n       uint32_t low;\n       GET_LOW_WORD(low, x);\n@@ -934,20 +934,20 @@ double acos(double x) {\n   double z, p, q, r, w, s, c, df;\n   int32_t hx, ix;\n   GET_HIGH_WORD(hx, x);\n-  ix = hx & 0x7fffffff;\n-  if (ix >= 0x3ff00000) { /* |x| >= 1 */\n+  ix = hx & 0x7FFFFFFF;\n+  if (ix >= 0x3FF00000) { /* |x| >= 1 */\n     uint32_t lx;\n     GET_LOW_WORD(lx, x);\n-    if (((ix - 0x3ff00000) | lx) == 0) { /* |x|==1 */\n+    if (((ix - 0x3FF00000) | lx) == 0) { /* |x|==1 */\n       if (hx > 0)\n         return 0.0; /* acos(1) = 0  */\n       else\n         return pi + 2.0 * pio2_lo; /* acos(-1)= pi */\n     }\n     return (x - x) / (x - x); /* acos(|x|>1) is NaN */\n   }\n-  if (ix < 0x3fe00000) {                            /* |x| < 0.5 */\n-    if (ix <= 0x3c600000) return pio2_hi + pio2_lo; /*if|x|<2**-57*/\n+  if (ix < 0x3FE00000) {                            /* |x| < 0.5 */\n+    if (ix <= 0x3C600000) return pio2_hi + pio2_lo; /*if|x|<2**-57*/\n     z = x * x;\n     p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n     q = one + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n@@ -996,15 +996,15 @@ double acosh(double x) {\n   int32_t hx;\n   uint32_t lx;\n   EXTRACT_WORDS(hx, lx, x);\n-  if (hx < 0x3ff00000) { /* x < 1 */\n+  if (hx < 0x3FF00000) { /* x < 1 */\n     return (x - x) / (x - x);\n-  } else if (hx >= 0x41b00000) { /* x > 2**28 */\n-    if (hx >= 0x7ff00000) {      /* x is inf of NaN */\n+  } else if (hx >= 0x41B00000) { /* x > 2**28 */\n+    if (hx >= 0x7FF00000) {      /* x is inf of NaN */\n       return x + x;\n     } else {\n       return log(x) + ln2; /* acosh(huge)=log(2x) */\n     }\n-  } else if (((hx - 0x3ff00000) | lx) == 0) {\n+  } else if (((hx - 0x3FF00000) | lx) == 0) {\n     return 0.0;                 /* acosh(1) = 0 */\n   } else if (hx > 0x40000000) { /* 2**28 > x > 2 */\n     t = x * x;\n@@ -1067,15 +1067,15 @@ double asin(double x) {\n \n   t = 0;\n   GET_HIGH_WORD(hx, x);\n-  ix = hx & 0x7fffffff;\n-  if (ix >= 0x3ff00000) { /* |x|>= 1 */\n+  ix = hx & 0x7FFFFFFF;\n+  if (ix >= 0x3FF00000) { /* |x|>= 1 */\n     uint32_t lx;\n     GET_LOW_WORD(lx, x);\n-    if (((ix - 0x3ff00000) | lx) == 0) /* asin(1)=+-pi/2 with inexact */\n+    if (((ix - 0x3FF00000) | lx) == 0) /* asin(1)=+-pi/2 with inexact */\n       return x * pio2_hi + x * pio2_lo;\n     return (x - x) / (x - x);       /* asin(|x|>1) is NaN */\n-  } else if (ix < 0x3fe00000) {     /* |x|<0.5 */\n-    if (ix < 0x3e400000) {          /* if |x| < 2**-27 */\n+  } else if (ix < 0x3FE00000) {     /* |x|<0.5 */\n+    if (ix < 0x3E400000) {          /* if |x| < 2**-27 */\n       if (huge + x > one) return x; /* return x with inexact if x!=0*/\n     } else {\n       t = x * x;\n@@ -1127,12 +1127,12 @@ double asinh(double x) {\n   double t, w;\n   int32_t hx, ix;\n   GET_HIGH_WORD(hx, x);\n-  ix = hx & 0x7fffffff;\n-  if (ix >= 0x7ff00000) return x + x; /* x is inf or NaN */\n-  if (ix < 0x3e300000) {              /* |x|<2**-28 */\n+  ix = hx & 0x7FFFFFFF;\n+  if (ix >= 0x7FF00000) return x + x; /* x is inf or NaN */\n+  if (ix < 0x3E300000) {              /* |x|<2**-28 */\n     if (huge + x > one) return x;     /* return x inexact except 0 */\n   }\n-  if (ix > 0x41b00000) { /* |x| > 2**28 */\n+  if (ix > 0x41B00000) { /* |x| > 2**28 */\n     w = log(fabs(x)) + ln2;\n   } else if (ix > 0x40000000) { /* 2**28 > |x| > 2.0 */\n     t = fabs(x);\n@@ -1202,26 +1202,26 @@ double atan(double x) {\n   int32_t ix, hx, id;\n \n   GET_HIGH_WORD(hx, x);\n-  ix = hx & 0x7fffffff;\n+  ix = hx & 0x7FFFFFFF;\n   if (ix >= 0x44100000) { /* if |x| >= 2^66 */\n     uint32_t low;\n     GET_LOW_WORD(low, x);\n-    if (ix > 0x7ff00000 || (ix == 0x7ff00000 && (low != 0)))\n+    if (ix > 0x7FF00000 || (ix == 0x7FF00000 && (low != 0)))\n       return x + x; /* NaN */\n     if (hx > 0)\n       return atanhi[3] + *(volatile double *)&atanlo[3];\n     else\n       return -atanhi[3] - *(volatile double *)&atanlo[3];\n   }\n-  if (ix < 0x3fdc0000) {            /* |x| < 0.4375 */\n-    if (ix < 0x3e400000) {          /* |x| < 2^-27 */\n+  if (ix < 0x3FDC0000) {            /* |x| < 0.4375 */\n+    if (ix < 0x3E400000) {          /* |x| < 2^-27 */\n       if (huge + x > one) return x; /* raise inexact */\n     }\n     id = -1;\n   } else {\n     x = fabs(x);\n-    if (ix < 0x3ff30000) {   /* |x| < 1.1875 */\n-      if (ix < 0x3fe60000) { /* 7/16 <=|x|<11/16 */\n+    if (ix < 0x3FF30000) {   /* |x| < 1.1875 */\n+      if (ix < 0x3FE60000) { /* 7/16 <=|x|<11/16 */\n         id = 0;\n         x = (2.0 * x - one) / (2.0 + x);\n       } else { /* 11/16<=|x|< 19/16 */\n@@ -1294,14 +1294,14 @@ double atan2(double y, double x) {\n   uint32_t lx, ly;\n \n   EXTRACT_WORDS(hx, lx, x);\n-  ix = hx & 0x7fffffff;\n+  ix = hx & 0x7FFFFFFF;\n   EXTRACT_WORDS(hy, ly, y);\n-  iy = hy & 0x7fffffff;\n-  if (((ix | ((lx | -static_cast<int32_t>(lx)) >> 31)) > 0x7ff00000) ||\n-      ((iy | ((ly | -static_cast<int32_t>(ly)) >> 31)) > 0x7ff00000)) {\n+  iy = hy & 0x7FFFFFFF;\n+  if (((ix | ((lx | -static_cast<int32_t>(lx)) >> 31)) > 0x7FF00000) ||\n+      ((iy | ((ly | -static_cast<int32_t>(ly)) >> 31)) > 0x7FF00000)) {\n     return x + y; /* x or y is NaN */\n   }\n-  if (((hx - 0x3ff00000) | lx) == 0) return atan(y); /* x=1.0 */\n+  if (((hx - 0x3FF00000) | lx) == 0) return atan(y); /* x=1.0 */\n   m = ((hy >> 31) & 1) | ((hx >> 30) & 2);           /* 2*sign(x)+sign(y) */\n \n   /* when y = 0 */\n@@ -1320,8 +1320,8 @@ double atan2(double y, double x) {\n   if ((ix | lx) == 0) return (hy < 0) ? -pi_o_2 - tiny : pi_o_2 + tiny;\n \n   /* when x is INF */\n-  if (ix == 0x7ff00000) {\n-    if (iy == 0x7ff00000) {\n+  if (ix == 0x7FF00000) {\n+    if (iy == 0x7FF00000) {\n       switch (m) {\n         case 0:\n           return pi_o_4 + tiny; /* atan(+INF,+INF) */\n@@ -1346,7 +1346,7 @@ double atan2(double y, double x) {\n     }\n   }\n   /* when y is INF */\n-  if (iy == 0x7ff00000) return (hy < 0) ? -pi_o_2 - tiny : pi_o_2 + tiny;\n+  if (iy == 0x7FF00000) return (hy < 0) ? -pi_o_2 - tiny : pi_o_2 + tiny;\n \n   /* compute y/x */\n   k = (iy - ix) >> 20;\n@@ -1408,10 +1408,10 @@ double cos(double x) {\n   GET_HIGH_WORD(ix, x);\n \n   /* |x| ~< pi/4 */\n-  ix &= 0x7fffffff;\n-  if (ix <= 0x3fe921fb) {\n+  ix &= 0x7FFFFFFF;\n+  if (ix <= 0x3FE921FB) {\n     return __kernel_cos(x, z);\n-  } else if (ix >= 0x7ff00000) {\n+  } else if (ix >= 0x7FF00000) {\n     /* cos(Inf or NaN) is NaN */\n     return x - x;\n   } else {\n@@ -1497,18 +1497,18 @@ double exp(double x) {\n       one = 1.0,\n       halF[2] = {0.5, -0.5},\n       o_threshold = 7.09782712893383973096e+02,  /* 0x40862E42, 0xFEFA39EF */\n-      u_threshold = -7.45133219101941108420e+02, /* 0xc0874910, 0xD52D3051 */\n-      ln2HI[2] = {6.93147180369123816490e-01,    /* 0x3fe62e42, 0xfee00000 */\n-                  -6.93147180369123816490e-01},  /* 0xbfe62e42, 0xfee00000 */\n-      ln2LO[2] = {1.90821492927058770002e-10,    /* 0x3dea39ef, 0x35793c76 */\n-                  -1.90821492927058770002e-10},  /* 0xbdea39ef, 0x35793c76 */\n-      invln2 = 1.44269504088896338700e+00,       /* 0x3ff71547, 0x652b82fe */\n+      u_threshold = -7.45133219101941108420e+02, /* 0xC0874910, 0xD52D3051 */\n+      ln2HI[2] = {6.93147180369123816490e-01,    /* 0x3FE62E42, 0xFEE00000 */\n+                  -6.93147180369123816490e-01},  /* 0xBFE62E42, 0xFEE00000 */\n+      ln2LO[2] = {1.90821492927058770002e-10,    /* 0x3DEA39EF, 0x35793C76 */\n+                  -1.90821492927058770002e-10},  /* 0xBDEA39EF, 0x35793C76 */\n+      invln2 = 1.44269504088896338700e+00,       /* 0x3FF71547, 0x652B82FE */\n       P1 = 1.66666666666666019037e-01,           /* 0x3FC55555, 0x5555553E */\n       P2 = -2.77777777770155933842e-03,          /* 0xBF66C16C, 0x16BEBD93 */\n       P3 = 6.61375632143793436117e-05,           /* 0x3F11566A, 0xAF25DE2C */\n       P4 = -1.65339022054652515390e-06,          /* 0xBEBBBD41, 0xC5D26BF1 */\n       P5 = 4.13813679705723846039e-08,           /* 0x3E663769, 0x72BEA4D0 */\n-      E = 2.718281828459045;                     /* 0x4005bf0a, 0x8b145769 */\n+      E = 2.718281828459045;                     /* 0x4005BF0A, 0x8B145769 */\n \n   static volatile double\n       huge = 1.0e+300,\n@@ -1521,14 +1521,14 @@ double exp(double x) {\n \n   GET_HIGH_WORD(hx, x);\n   xsb = (hx >> 31) & 1; /* sign bit of x */\n-  hx &= 0x7fffffff;     /* high word of |x| */\n+  hx &= 0x7FFFFFFF;     /* high word of |x| */\n \n   /* filter out non-finite argument */\n   if (hx >= 0x40862E42) { /* if |x|>=709.78... */\n-    if (hx >= 0x7ff00000) {\n+    if (hx >= 0x7FF00000) {\n       uint32_t lx;\n       GET_LOW_WORD(lx, x);\n-      if (((hx & 0xfffff) | lx) != 0)\n+      if (((hx & 0xFFFFF) | lx) != 0)\n         return x + x; /* NaN */\n       else\n         return (xsb == 0) ? x : 0.0; /* exp(+-inf)={inf,0} */\n@@ -1538,7 +1538,7 @@ double exp(double x) {\n   }\n \n   /* argument reduction */\n-  if (hx > 0x3fd62e42) {   /* if  |x| > 0.5 ln2 */\n+  if (hx > 0x3FD62E42) {   /* if  |x| > 0.5 ln2 */\n     if (hx < 0x3FF0A2B2) { /* and |x| < 1.5 ln2 */\n       /* TODO(rtoy): We special case exp(1) here to return the correct\n        * value of E, as the computation below would get the last bit\n@@ -1555,7 +1555,7 @@ double exp(double x) {\n       lo = t * ln2LO[0];\n     }\n     STRICT_ASSIGN(double, x, hi - lo);\n-  } else if (hx < 0x3e300000) {         /* when |x|<2**-28 */\n+  } else if (hx < 0x3E300000) {         /* when |x|<2**-28 */\n     if (huge + x > one) return one + x; /* trigger inexact */\n   } else {\n     k = 0;\n@@ -1564,9 +1564,9 @@ double exp(double x) {\n   /* x is now in primary range */\n   t = x * x;\n   if (k >= -1021) {\n-    INSERT_WORDS(twopk, 0x3ff00000 + (k << 20), 0);\n+    INSERT_WORDS(twopk, 0x3FF00000 + (k << 20), 0);\n   } else {\n-    INSERT_WORDS(twopk, 0x3ff00000 + ((k + 1000) << 20), 0);\n+    INSERT_WORDS(twopk, 0x3FF00000 + ((k + 1000) << 20), 0);\n   }\n   c = x - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n   if (k == 0) {\n@@ -1607,13 +1607,13 @@ double atanh(double x) {\n   int32_t hx, ix;\n   uint32_t lx;\n   EXTRACT_WORDS(hx, lx, x);\n-  ix = hx & 0x7fffffff;\n-  if ((ix | ((lx | -static_cast<int32_t>(lx)) >> 31)) > 0x3ff00000) /* |x|>1 */\n+  ix = hx & 0x7FFFFFFF;\n+  if ((ix | ((lx | -static_cast<int32_t>(lx)) >> 31)) > 0x3FF00000) /* |x|>1 */\n     return (x - x) / (x - x);\n-  if (ix == 0x3ff00000) return x / zero;\n-  if (ix < 0x3e300000 && (huge + x) > zero) return x; /* x<2**-28 */\n+  if (ix == 0x3FF00000) return x / zero;\n+  if (ix < 0x3E300000 && (huge + x) > zero) return x; /* x<2**-28 */\n   SET_HIGH_WORD(x, ix);\n-  if (ix < 0x3fe00000) { /* x < 0.5 */\n+  if (ix < 0x3FE00000) { /* x < 0.5 */\n     t = x + x;\n     t = 0.5 * log1p(t + t * x / (one - x));\n   } else {\n@@ -1699,21 +1699,21 @@ double log(double x) {\n \n   k = 0;\n   if (hx < 0x00100000) { /* x < 2**-1022  */\n-    if (((hx & 0x7fffffff) | lx) == 0)\n+    if (((hx & 0x7FFFFFFF) | lx) == 0)\n       return -two54 / vzero;           /* log(+-0)=-inf */\n     if (hx < 0) return (x - x) / zero; /* log(-#) = NaN */\n     k -= 54;\n     x *= two54; /* subnormal number, scale up x */\n     GET_HIGH_WORD(hx, x);\n   }\n-  if (hx >= 0x7ff00000) return x + x;\n+  if (hx >= 0x7FF00000) return x + x;\n   k += (hx >> 20) - 1023;\n-  hx &= 0x000fffff;\n-  i = (hx + 0x95f64) & 0x100000;\n-  SET_HIGH_WORD(x, hx | (i ^ 0x3ff00000)); /* normalize x or x/2 */\n+  hx &= 0x000FFFFF;\n+  i = (hx + 0x95F64) & 0x100000;\n+  SET_HIGH_WORD(x, hx | (i ^ 0x3FF00000)); /* normalize x or x/2 */\n   k += (i >> 20);\n   f = x - 1.0;\n-  if ((0x000fffff & (2 + hx)) < 3) { /* -2**-20 <= f < 2**-20 */\n+  if ((0x000FFFFF & (2 + hx)) < 3) { /* -2**-20 <= f < 2**-20 */\n     if (f == zero) {\n       if (k == 0) {\n         return zero;\n@@ -1733,9 +1733,9 @@ double log(double x) {\n   s = f / (2.0 + f);\n   dk = static_cast<double>(k);\n   z = s * s;\n-  i = hx - 0x6147a;\n+  i = hx - 0x6147A;\n   w = z * z;\n-  j = 0x6b851 - hx;\n+  j = 0x6B851 - hx;\n   t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n   t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n   i |= j;\n@@ -1838,30 +1838,30 @@ double log1p(double x) {\n   int32_t k, hx, hu, ax;\n \n   GET_HIGH_WORD(hx, x);\n-  ax = hx & 0x7fffffff;\n+  ax = hx & 0x7FFFFFFF;\n \n   k = 1;\n   if (hx < 0x3FDA827A) {    /* 1+x < sqrt(2)+ */\n-    if (ax >= 0x3ff00000) { /* x <= -1.0 */\n+    if (ax >= 0x3FF00000) { /* x <= -1.0 */\n       if (x == -1.0)\n         return -two54 / vzero; /* log1p(-1)=+inf */\n       else\n         return (x - x) / (x - x); /* log1p(x<-1)=NaN */\n     }\n-    if (ax < 0x3e200000) {    /* |x| < 2**-29 */\n+    if (ax < 0x3E200000) {    /* |x| < 2**-29 */\n       if (two54 + x > zero    /* raise inexact */\n-          && ax < 0x3c900000) /* |x| < 2**-54 */\n+          && ax < 0x3C900000) /* |x| < 2**-54 */\n         return x;\n       else\n         return x - x * x * 0.5;\n     }\n-    if (hx > 0 || hx <= static_cast<int32_t>(0xbfd2bec4)) {\n+    if (hx > 0 || hx <= static_cast<int32_t>(0xBFD2BEC4)) {\n       k = 0;\n       f = x;\n       hu = 1;\n     } /* sqrt(2)/2- <= 1+x < sqrt(2)+ */\n   }\n-  if (hx >= 0x7ff00000) return x + x;\n+  if (hx >= 0x7FF00000) return x + x;\n   if (k != 0) {\n     if (hx < 0x43400000) {\n       STRICT_ASSIGN(double, u, 1.0 + x);\n@@ -1875,19 +1875,19 @@ double log1p(double x) {\n       k = (hu >> 20) - 1023;\n       c = 0;\n     }\n-    hu &= 0x000fffff;\n+    hu &= 0x000FFFFF;\n     /*\n      * The approximation to sqrt(2) used in thresholds is not\n      * critical.  However, the ones used above must give less\n      * strict bounds than the one here so that the k==0 case is\n      * never reached from here, since here we have committed to\n      * using the correction term but don't use it if k==0.\n      */\n-    if (hu < 0x6a09e) {                  /* u ~< sqrt(2) */\n-      SET_HIGH_WORD(u, hu | 0x3ff00000); /* normalize u */\n+    if (hu < 0x6A09E) {                  /* u ~< sqrt(2) */\n+      SET_HIGH_WORD(u, hu | 0x3FF00000); /* normalize u */\n     } else {\n       k += 1;\n-      SET_HIGH_WORD(u, hu | 0x3fe00000); /* normalize u/2 */\n+      SET_HIGH_WORD(u, hu | 0x3FE00000); /* normalize u/2 */\n       hu = (0x00100000 - hu) >> 2;\n     }\n     f = u - 1.0;\n@@ -2012,8 +2012,8 @@ static inline double k_log1p(double f) {\n double log2(double x) {\n   static const double\n       two54 = 1.80143985094819840000e+16,   /* 0x43500000, 0x00000000 */\n-      ivln2hi = 1.44269504072144627571e+00, /* 0x3ff71547, 0x65200000 */\n-      ivln2lo = 1.67517131648865118353e-10; /* 0x3de705fc, 0x2eefa200 */\n+      ivln2hi = 1.44269504072144627571e+00, /* 0x3FF71547, 0x65200000 */\n+      ivln2lo = 1.67517131648865118353e-10; /* 0x3DE705FC, 0x2EEFA200 */\n \n   static const double zero = 0.0;\n   static volatile double vzero = 0.0;\n@@ -2026,19 +2026,19 @@ double log2(double x) {\n \n   k = 0;\n   if (hx < 0x00100000) { /* x < 2**-1022  */\n-    if (((hx & 0x7fffffff) | lx) == 0)\n+    if (((hx & 0x7FFFFFFF) | lx) == 0)\n       return -two54 / vzero;           /* log(+-0)=-inf */\n     if (hx < 0) return (x - x) / zero; /* log(-#) = NaN */\n     k -= 54;\n     x *= two54; /* subnormal number, scale up x */\n     GET_HIGH_WORD(hx, x);\n   }\n-  if (hx >= 0x7ff00000) return x + x;\n-  if (hx == 0x3ff00000 && lx == 0) return zero; /* log(1) = +0 */\n+  if (hx >= 0x7FF00000) return x + x;\n+  if (hx == 0x3FF00000 && lx == 0) return zero; /* log(1) = +0 */\n   k += (hx >> 20) - 1023;\n-  hx &= 0x000fffff;\n-  i = (hx + 0x95f64) & 0x100000;\n-  SET_HIGH_WORD(x, hx | (i ^ 0x3ff00000)); /* normalize x or x/2 */\n+  hx &= 0x000FFFFF;\n+  i = (hx + 0x95F64) & 0x100000;\n+  SET_HIGH_WORD(x, hx | (i ^ 0x3FF00000)); /* normalize x or x/2 */\n   k += (i >> 20);\n   y = static_cast<double>(k);\n   f = x - 1.0;\n@@ -2133,20 +2133,20 @@ double log10(double x) {\n \n   k = 0;\n   if (hx < 0x00100000) { /* x < 2**-1022  */\n-    if (((hx & 0x7fffffff) | lx) == 0)\n+    if (((hx & 0x7FFFFFFF) | lx) == 0)\n       return -two54 / vzero;           /* log(+-0)=-inf */\n     if (hx < 0) return (x - x) / zero; /* log(-#) = NaN */\n     k -= 54;\n     x *= two54; /* subnormal number, scale up x */\n     GET_HIGH_WORD(hx, x);\n     GET_LOW_WORD(lx, x);\n   }\n-  if (hx >= 0x7ff00000) return x + x;\n-  if (hx == 0x3ff00000 && lx == 0) return zero; /* log(1) = +0 */\n+  if (hx >= 0x7FF00000) return x + x;\n+  if (hx == 0x3FF00000 && lx == 0) return zero; /* log(1) = +0 */\n   k += (hx >> 20) - 1023;\n \n   i = (k & 0x80000000) >> 31;\n-  hx = (hx & 0x000fffff) | ((0x3ff - i) << 20);\n+  hx = (hx & 0x000FFFFF) | ((0x3FF - i) << 20);\n   y = k + i;\n   SET_HIGH_WORD(x, hx);\n   SET_LOW_WORD(x, lx);\n@@ -2254,9 +2254,9 @@ double expm1(double x) {\n       one = 1.0,\n       tiny = 1.0e-300,\n       o_threshold = 7.09782712893383973096e+02, /* 0x40862E42, 0xFEFA39EF */\n-      ln2_hi = 6.93147180369123816490e-01,      /* 0x3fe62e42, 0xfee00000 */\n-      ln2_lo = 1.90821492927058770002e-10,      /* 0x3dea39ef, 0x35793c76 */\n-      invln2 = 1.44269504088896338700e+00,      /* 0x3ff71547, 0x652b82fe */\n+      ln2_hi = 6.93147180369123816490e-01,      /* 0x3FE62E42, 0xFEE00000 */\n+      ln2_lo = 1.90821492927058770002e-10,      /* 0x3DEA39EF, 0x35793C76 */\n+      invln2 = 1.44269504088896338700e+00,      /* 0x3FF71547, 0x652B82FE */\n       /* Scaled Q's: Qn_here = 2**n * Qn_above, for R(2*z) where z = hxs =\n          x*x/2: */\n       Q1 = -3.33333333333331316428e-02, /* BFA11111 111110F4 */\n@@ -2273,15 +2273,15 @@ double expm1(double x) {\n \n   GET_HIGH_WORD(hx, x);\n   xsb = hx & 0x80000000; /* sign bit of x */\n-  hx &= 0x7fffffff;      /* high word of |x| */\n+  hx &= 0x7FFFFFFF;      /* high word of |x| */\n \n   /* filter out huge and non-finite argument */\n   if (hx >= 0x4043687A) {   /* if |x|>=56*ln2 */\n     if (hx >= 0x40862E42) { /* if |x|>=709.78... */\n-      if (hx >= 0x7ff00000) {\n+      if (hx >= 0x7FF00000) {\n         uint32_t low;\n         GET_LOW_WORD(low, x);\n-        if (((hx & 0xfffff) | low) != 0)\n+        if (((hx & 0xFFFFF) | low) != 0)\n           return x + x; /* NaN */\n         else\n           return (xsb == 0) ? x : -1.0; /* exp(+-inf)={inf,-1} */\n@@ -2295,7 +2295,7 @@ double expm1(double x) {\n   }\n \n   /* argument reduction */\n-  if (hx > 0x3fd62e42) {   /* if  |x| > 0.5 ln2 */\n+  if (hx > 0x3FD62E42) {   /* if  |x| > 0.5 ln2 */\n     if (hx < 0x3FF0A2B2) { /* and |x| < 1.5 ln2 */\n       if (xsb == 0) {\n         hi = x - ln2_hi;\n@@ -2314,7 +2314,7 @@ double expm1(double x) {\n     }\n     STRICT_ASSIGN(double, x, hi - lo);\n     c = (hi - x) - lo;\n-  } else if (hx < 0x3c900000) { /* when |x|<2**-54, return x */\n+  } else if (hx < 0x3C900000) { /* when |x|<2**-54, return x */\n     t = huge + x;               /* return x with inexact flags when x!=0 */\n     return x - (t - (huge + x));\n   } else {\n@@ -2330,7 +2330,7 @@ double expm1(double x) {\n   if (k == 0) {\n     return x - (x * e - hxs); /* c is 0 */\n   } else {\n-    INSERT_WORDS(twopk, 0x3ff00000 + (k << 20), 0); /* 2^k */\n+    INSERT_WORDS(twopk, 0x3FF00000 + (k << 20), 0); /* 2^k */\n     e = (x * (e - c) - c);\n     e -= hxs;\n     if (k == -1) return 0.5 * (x - e) - 0.5;\n@@ -2353,11 +2353,11 @@ double expm1(double x) {\n     }\n     t = one;\n     if (k < 20) {\n-      SET_HIGH_WORD(t, 0x3ff00000 - (0x200000 >> k)); /* t=1-2^-k */\n+      SET_HIGH_WORD(t, 0x3FF00000 - (0x200000 >> k)); /* t=1-2^-k */\n       y = t - (e - x);\n       y = y * twopk;\n     } else {\n-      SET_HIGH_WORD(t, ((0x3ff - k) << 20)); /* 2^-k */\n+      SET_HIGH_WORD(t, ((0x3FF - k) << 20)); /* 2^-k */\n       y = x - (e + t);\n       y += one;\n       y = y * twopk;\n@@ -2372,11 +2372,11 @@ double cbrt(double x) {\n       B2 = 696219795; /* B2 = (1023-1023/3-54/3-0.03306235651)*2**20 */\n \n   /* |1/cbrt(x) - p(x)| < 2**-23.5 (~[-7.93e-8, 7.929e-8]). */\n-  static const double P0 = 1.87595182427177009643, /* 0x3ffe03e6, 0x0f61e692 */\n-      P1 = -1.88497979543377169875,                /* 0xbffe28e0, 0x92f02420 */\n-      P2 = 1.621429720105354466140,                /* 0x3ff9f160, 0x4a49d6c2 */\n-      P3 = -0.758397934778766047437,               /* 0xbfe844cb, 0xbee751d9 */\n-      P4 = 0.145996192886612446982;                /* 0x3fc2b000, 0xd4e4edd7 */\n+  static const double P0 = 1.87595182427177009643, /* 0x3FFE03E6, 0x0F61E692 */\n+      P1 = -1.88497979543377169875,                /* 0xBFFE28E0, 0x92F02420 */\n+      P2 = 1.621429720105354466140,                /* 0x3FF9F160, 0x4A49D6C2 */\n+      P3 = -0.758397934778766047437,               /* 0xBFE844CB, 0xBEE751D9 */\n+      P4 = 0.145996192886612446982;                /* 0x3FC2B000, 0xD4E4EDD7 */\n \n   int32_t hx;\n   union {\n@@ -2390,7 +2390,7 @@ double cbrt(double x) {\n   EXTRACT_WORDS(hx, low, x);\n   sign = hx & 0x80000000; /* sign= sign(x) */\n   hx ^= sign;\n-  if (hx >= 0x7ff00000) return (x + x); /* cbrt(NaN,INF) is itself */\n+  if (hx >= 0x7FF00000) return (x + x); /* cbrt(NaN,INF) is itself */\n \n   /*\n    * Rough cbrt to 5 bits:\n@@ -2412,7 +2412,7 @@ double cbrt(double x) {\n     SET_HIGH_WORD(t, 0x43500000);    /* set t= 2**54 */\n     t *= x;\n     GET_HIGH_WORD(high, t);\n-    INSERT_WORDS(t, sign | ((high & 0x7fffffff) / 3 + B2), 0);\n+    INSERT_WORDS(t, sign | ((high & 0x7FFFFFFF) / 3 + B2), 0);\n   } else {\n     INSERT_WORDS(t, sign | (hx / 3 + B1), 0);\n   }\n@@ -2441,7 +2441,7 @@ double cbrt(double x) {\n    * before the final error is larger than 0.667 ulps.\n    */\n   u.value = t;\n-  u.bits = (u.bits + 0x80000000) & 0xffffffffc0000000ULL;\n+  u.bits = (u.bits + 0x80000000) & 0xFFFFFFFFC0000000ULL;\n   t = u.value;\n \n   /* one step Newton iteration to 53 bits with error < 0.667 ulps */\n@@ -2492,10 +2492,10 @@ double sin(double x) {\n   GET_HIGH_WORD(ix, x);\n \n   /* |x| ~< pi/4 */\n-  ix &= 0x7fffffff;\n-  if (ix <= 0x3fe921fb) {\n+  ix &= 0x7FFFFFFF;\n+  if (ix <= 0x3FE921FB) {\n     return __kernel_sin(x, z, 0);\n-  } else if (ix >= 0x7ff00000) {\n+  } else if (ix >= 0x7FF00000) {\n     /* sin(Inf or NaN) is NaN */\n     return x - x;\n   } else {\n@@ -2551,10 +2551,10 @@ double tan(double x) {\n   GET_HIGH_WORD(ix, x);\n \n   /* |x| ~< pi/4 */\n-  ix &= 0x7fffffff;\n-  if (ix <= 0x3fe921fb) {\n+  ix &= 0x7FFFFFFF;\n+  if (ix <= 0x3FE921FB) {\n     return __kernel_tan(x, z, 1);\n-  } else if (ix >= 0x7ff00000) {\n+  } else if (ix >= 0x7FF00000) {\n     /* tan(Inf or NaN) is NaN */\n     return x - x; /* NaN */\n   } else {\n@@ -2596,14 +2596,14 @@ double cosh(double x) {\n \n   /* High word of |x|. */\n   GET_HIGH_WORD(ix, x);\n-  ix &= 0x7fffffff;\n+  ix &= 0x7FFFFFFF;\n \n   // |x| in [0,0.5*log2], return 1+expm1(|x|)^2/(2*exp(|x|))\n-  if (ix < 0x3fd62e43) {\n+  if (ix < 0x3FD62E43) {\n     double t = expm1(fabs(x));\n     double w = one + t;\n     // For |x| < 2^-55, cosh(x) = 1\n-    if (ix < 0x3c800000) return w;\n+    if (ix < 0x3C800000) return w;\n     return one + (t * t) / (w + w);\n   }\n \n@@ -2614,7 +2614,7 @@ double cosh(double x) {\n   }\n \n   // |x| in [22, log(maxdouble)], return half*exp(|x|)\n-  if (ix < 0x40862e42) return half * exp(fabs(x));\n+  if (ix < 0x40862E42) return half * exp(fabs(x));\n \n   // |x| in [log(maxdouble), overflowthreshold]\n   if (fabs(x) <= KCOSH_OVERFLOW) {\n@@ -2624,7 +2624,7 @@ double cosh(double x) {\n   }\n \n   /* x is INF or NaN */\n-  if (ix >= 0x7ff00000) return x * x;\n+  if (ix >= 0x7FF00000) return x * x;\n \n   // |x| > overflowthreshold.\n   return huge * huge;\n@@ -2653,7 +2653,7 @@ double sinh(double x) {\n   static const double KSINH_OVERFLOW = 710.4758600739439,\n                       TWO_M28 =\n                           3.725290298461914e-9,  // 2^-28, empty lower half\n-      LOG_MAXD = 709.7822265625;  // 0x40862e42 00000000, empty lower half\n+      LOG_MAXD = 709.7822265625;  // 0x40862E42 00000000, empty lower half\n   static const double shuge = 1.0e307;\n \n   double h = (x < 0) ? -0.5 : 0.5;\n@@ -2712,10 +2712,10 @@ double tanh(double x) {\n   int32_t jx, ix;\n \n   GET_HIGH_WORD(jx, x);\n-  ix = jx & 0x7fffffff;\n+  ix = jx & 0x7FFFFFFF;\n \n   /* x is INF or NaN */\n-  if (ix >= 0x7ff00000) {\n+  if (ix >= 0x7FF00000) {\n     if (jx >= 0)\n       return one / x + one; /* tanh(+-inf)=+-1 */\n     else\n@@ -2724,10 +2724,10 @@ double tanh(double x) {\n \n   /* |x| < 22 */\n   if (ix < 0x40360000) {            /* |x|<22 */\n-    if (ix < 0x3e300000) {          /* |x|<2**-28 */\n+    if (ix < 0x3E300000) {          /* |x|<2**-28 */\n       if (huge + x > one) return x; /* tanh(tiny) = tiny with inexact */\n     }\n-    if (ix >= 0x3ff00000) { /* |x|>=1  */\n+    if (ix >= 0x3FF00000) { /* |x|>=1  */\n       t = expm1(two * fabs(x));\n       z = one - two / (t + two);\n     } else {"
        },
        {
            "sha": "e965382b8d3756b9c46293df444550c11cd9fb3c",
            "filename": "deps/v8/src/base/lazy-instance.h",
            "status": "modified",
            "additions": 4,
            "deletions": 8,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Flazy-instance.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Flazy-instance.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Flazy-instance.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -168,17 +168,13 @@ struct LazyInstanceImpl {\n   typedef typename AllocationTrait::StorageType StorageType;\n \n  private:\n-  static void InitInstance(StorageType* storage) {\n-    AllocationTrait::template InitStorageUsingTrait<CreateTrait>(storage);\n+  static void InitInstance(void* storage) {\n+    AllocationTrait::template InitStorageUsingTrait<CreateTrait>(\n+        static_cast<StorageType*>(storage));\n   }\n \n   void Init() const {\n-    InitOnceTrait::Init(\n-        &once_,\n-        // Casts to void* are needed here to avoid breaking strict aliasing\n-        // rules.\n-        reinterpret_cast<void(*)(void*)>(&InitInstance),  // NOLINT\n-        reinterpret_cast<void*>(&storage_));\n+    InitOnceTrait::Init(&once_, &InitInstance, static_cast<void*>(&storage_));\n   }\n \n  public:"
        },
        {
            "sha": "ad5349ac7ebe3e3ad9298b30ec8c149546fd1fd9",
            "filename": "deps/v8/src/base/logging.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Flogging.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Flogging.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Flogging.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -119,8 +119,6 @@ DEFINE_CHECK_OP_IMPL(GT)\n }  // namespace base\n }  // namespace v8\n \n-\n-// Contains protection against recursive calls (faults while handling faults).\n void V8_Fatal(const char* file, int line, const char* format, ...) {\n   fflush(stdout);\n   fflush(stderr);"
        },
        {
            "sha": "5275fdc6a6e174cbe8a6808f1db0edde6bb4abeb",
            "filename": "deps/v8/src/base/logging.h",
            "status": "modified",
            "additions": 4,
            "deletions": 14,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Flogging.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Flogging.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Flogging.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -20,23 +20,13 @@\n V8_BASE_EXPORT V8_NOINLINE void V8_Dcheck(const char* file, int line,\n                                           const char* message);\n \n-// The FATAL, UNREACHABLE and UNIMPLEMENTED macros are useful during\n-// development, but they should not be relied on in the final product.\n #ifdef DEBUG\n-#define FATAL(msg)                              \\\n-  V8_Fatal(__FILE__, __LINE__, \"%s\", (msg))\n-#define UNIMPLEMENTED()                         \\\n-  V8_Fatal(__FILE__, __LINE__, \"unimplemented code\")\n-#define UNREACHABLE()                           \\\n-  V8_Fatal(__FILE__, __LINE__, \"unreachable code\")\n+#define FATAL(...) V8_Fatal(__FILE__, __LINE__, __VA_ARGS__)\n #else\n-#define FATAL(msg)                              \\\n-  V8_Fatal(\"\", 0, \"%s\", (msg))\n-#define UNIMPLEMENTED()                         \\\n-  V8_Fatal(\"\", 0, \"unimplemented code\")\n-#define UNREACHABLE() V8_Fatal(\"\", 0, \"unreachable code\")\n+#define FATAL(...) V8_Fatal(\"\", 0, __VA_ARGS__)\n #endif\n-\n+#define UNIMPLEMENTED() FATAL(\"unimplemented code\")\n+#define UNREACHABLE() FATAL(\"unreachable code\")\n \n namespace v8 {\n namespace base {"
        },
        {
            "sha": "a265408d910812bb6537df3419180a29fc6b096b",
            "filename": "deps/v8/src/base/macros.h",
            "status": "modified",
            "additions": 33,
            "deletions": 24,
            "changes": 57,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fmacros.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fmacros.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fmacros.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -5,6 +5,8 @@\n #ifndef V8_BASE_MACROS_H_\n #define V8_BASE_MACROS_H_\n \n+#include <limits>\n+\n #include \"src/base/compiler-specific.h\"\n #include \"src/base/format-macros.h\"\n #include \"src/base/logging.h\"\n@@ -167,18 +169,23 @@ V8_INLINE Dest bit_cast(Source const& source) {\n #define DISABLE_ASAN\n #endif\n \n-// DISABLE_CFI_PERF -- Disable Control Flow Integrity checks for Perf reasons.\n-#if !defined(DISABLE_CFI_PERF)\n+// Helper macro to define no_sanitize attributes only with clang.\n #if defined(__clang__) && defined(__has_attribute)\n #if __has_attribute(no_sanitize)\n-#define DISABLE_CFI_PERF __attribute__((no_sanitize(\"cfi\")))\n-#endif\n+#define CLANG_NO_SANITIZE(what) __attribute__((no_sanitize(what)))\n #endif\n #endif\n-#if !defined(DISABLE_CFI_PERF)\n-#define DISABLE_CFI_PERF\n+#if !defined(CLANG_NO_SANITIZE)\n+#define CLANG_NO_SANITIZE(what)\n #endif\n \n+// DISABLE_CFI_PERF -- Disable Control Flow Integrity checks for Perf reasons.\n+#define DISABLE_CFI_PERF CLANG_NO_SANITIZE(\"cfi\")\n+\n+// DISABLE_CFI_ICALL -- Disable Control Flow Integrity indirect call checks,\n+// useful because calls into JITed code can not be CFI verified.\n+#define DISABLE_CFI_ICALL CLANG_NO_SANITIZE(\"cfi-icall\")\n+\n #if V8_CC_GNU\n #define V8_IMMEDIATE_CRASH() __builtin_trap()\n #else\n@@ -214,34 +221,16 @@ struct Use {\n // than defining __STDC_CONSTANT_MACROS before including <stdint.h>, and it\n // works on compilers that don't have it (like MSVC).\n #if V8_CC_MSVC\n-# define V8_UINT64_C(x)   (x ## UI64)\n-# define V8_INT64_C(x)    (x ## I64)\n # if V8_HOST_ARCH_64_BIT\n-#  define V8_INTPTR_C(x)  (x ## I64)\n #  define V8_PTR_PREFIX   \"ll\"\n # else\n-#  define V8_INTPTR_C(x)  (x)\n #  define V8_PTR_PREFIX   \"\"\n # endif  // V8_HOST_ARCH_64_BIT\n #elif V8_CC_MINGW64\n-# define V8_UINT64_C(x)   (x ## ULL)\n-# define V8_INT64_C(x)    (x ## LL)\n-# define V8_INTPTR_C(x)   (x ## LL)\n # define V8_PTR_PREFIX    \"I64\"\n #elif V8_HOST_ARCH_64_BIT\n-# if V8_OS_MACOSX || V8_OS_OPENBSD\n-#  define V8_UINT64_C(x)   (x ## ULL)\n-#  define V8_INT64_C(x)    (x ## LL)\n-# else\n-#  define V8_UINT64_C(x)   (x ## UL)\n-#  define V8_INT64_C(x)    (x ## L)\n-# endif\n-# define V8_INTPTR_C(x)   (x ## L)\n # define V8_PTR_PREFIX    \"l\"\n #else\n-# define V8_UINT64_C(x)   (x ## ULL)\n-# define V8_INT64_C(x)    (x ## LL)\n-# define V8_INTPTR_C(x)   (x)\n #if V8_OS_AIX\n #define V8_PTR_PREFIX \"l\"\n #else\n@@ -329,4 +318,24 @@ inline void* AlignedAddress(void* address, size_t alignment) {\n                                  ~static_cast<uintptr_t>(alignment - 1));\n }\n \n+// Bounds checks for float to integer conversions, which does truncation. Hence,\n+// the range of legal values is (min - 1, max + 1).\n+template <typename int_t, typename float_t, typename biggest_int_t = int64_t>\n+bool is_inbounds(float_t v) {\n+  static_assert(sizeof(int_t) < sizeof(biggest_int_t),\n+                \"int_t can't be bounds checked by the compiler\");\n+  constexpr float_t kLowerBound =\n+      static_cast<float_t>(std::numeric_limits<int_t>::min()) - 1;\n+  constexpr float_t kUpperBound =\n+      static_cast<float_t>(std::numeric_limits<int_t>::max()) + 1;\n+  constexpr bool kLowerBoundIsMin =\n+      static_cast<biggest_int_t>(kLowerBound) ==\n+      static_cast<biggest_int_t>(std::numeric_limits<int_t>::min());\n+  constexpr bool kUpperBoundIsMax =\n+      static_cast<biggest_int_t>(kUpperBound) ==\n+      static_cast<biggest_int_t>(std::numeric_limits<int_t>::max());\n+  return (kLowerBoundIsMin ? (kLowerBound <= v) : (kLowerBound < v)) &&\n+         (kUpperBoundIsMax ? (v <= kUpperBound) : (v < kUpperBound));\n+}\n+\n #endif   // V8_BASE_MACROS_H_"
        },
        {
            "sha": "3e5e21925dac7fb6efb04c6bbda09cf73b3f7ad0",
            "filename": "deps/v8/src/base/once.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fonce.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fonce.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fonce.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -15,7 +15,7 @@\n namespace v8 {\n namespace base {\n \n-void CallOnceImpl(OnceType* once, PointerArgFunction init_func, void* arg) {\n+void CallOnceImpl(OnceType* once, std::function<void()> init_func) {\n   AtomicWord state = Acquire_Load(once);\n   // Fast path. The provided function was already executed.\n   if (state == ONCE_STATE_DONE) {\n@@ -34,7 +34,7 @@ void CallOnceImpl(OnceType* once, PointerArgFunction init_func, void* arg) {\n   if (state == ONCE_STATE_UNINITIALIZED) {\n     // We are the first thread to call this function, so we have to call the\n     // function.\n-    init_func(arg);\n+    init_func();\n     Release_Store(once, ONCE_STATE_DONE);\n   } else {\n     // Another thread has already started executing the function. We need to"
        },
        {
            "sha": "f355ef52ae64c8ea94ad5d419bda5b96f5de2b3c",
            "filename": "deps/v8/src/base/once.h",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fonce.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fonce.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fonce.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -53,6 +53,7 @@\n #define V8_BASE_ONCE_H_\n \n #include <stddef.h>\n+#include <functional>\n \n #include \"src/base/atomicops.h\"\n #include \"src/base/base-export.h\"\n@@ -80,13 +81,12 @@ struct OneArgFunction {\n   typedef void (*type)(T);\n };\n \n-V8_BASE_EXPORT void CallOnceImpl(OnceType* once, PointerArgFunction init_func,\n-                                 void* arg);\n+V8_BASE_EXPORT void CallOnceImpl(OnceType* once,\n+                                 std::function<void()> init_func);\n \n inline void CallOnce(OnceType* once, NoArgFunction init_func) {\n   if (Acquire_Load(once) != ONCE_STATE_DONE) {\n-    CallOnceImpl(once, reinterpret_cast<PointerArgFunction>(init_func),\n-                 nullptr);\n+    CallOnceImpl(once, init_func);\n   }\n }\n \n@@ -95,8 +95,7 @@ template <typename Arg>\n inline void CallOnce(OnceType* once,\n     typename OneArgFunction<Arg*>::type init_func, Arg* arg) {\n   if (Acquire_Load(once) != ONCE_STATE_DONE) {\n-    CallOnceImpl(once, reinterpret_cast<PointerArgFunction>(init_func),\n-        static_cast<void*>(arg));\n+    CallOnceImpl(once, [=]() { init_func(arg); });\n   }\n }\n "
        },
        {
            "sha": "25ee2e47214c02866fa669900dfb86d3857f1d5e",
            "filename": "deps/v8/src/base/page-allocator.cc",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fpage-allocator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fpage-allocator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fpage-allocator.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2017 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \"src/base/page-allocator.h\"\n+\n+#include \"src/base/platform/platform.h\"\n+\n+namespace v8 {\n+namespace base {\n+\n+#define STATIC_ASSERT_ENUM(a, b)                            \\\n+  static_assert(static_cast<int>(a) == static_cast<int>(b), \\\n+                \"mismatching enum: \" #a)\n+\n+STATIC_ASSERT_ENUM(PageAllocator::kNoAccess,\n+                   base::OS::MemoryPermission::kNoAccess);\n+STATIC_ASSERT_ENUM(PageAllocator::kReadWrite,\n+                   base::OS::MemoryPermission::kReadWrite);\n+STATIC_ASSERT_ENUM(PageAllocator::kReadWriteExecute,\n+                   base::OS::MemoryPermission::kReadWriteExecute);\n+STATIC_ASSERT_ENUM(PageAllocator::kReadExecute,\n+                   base::OS::MemoryPermission::kReadExecute);\n+\n+#undef STATIC_ASSERT_ENUM\n+\n+size_t PageAllocator::AllocatePageSize() {\n+  return base::OS::AllocatePageSize();\n+}\n+\n+size_t PageAllocator::CommitPageSize() { return base::OS::CommitPageSize(); }\n+\n+void PageAllocator::SetRandomMmapSeed(int64_t seed) {\n+  base::OS::SetRandomMmapSeed(seed);\n+}\n+\n+void* PageAllocator::GetRandomMmapAddr() {\n+  return base::OS::GetRandomMmapAddr();\n+}\n+\n+void* PageAllocator::AllocatePages(void* address, size_t size, size_t alignment,\n+                                   PageAllocator::Permission access) {\n+  return base::OS::Allocate(address, size, alignment,\n+                            static_cast<base::OS::MemoryPermission>(access));\n+}\n+\n+bool PageAllocator::FreePages(void* address, size_t size) {\n+  return base::OS::Free(address, size);\n+}\n+\n+bool PageAllocator::ReleasePages(void* address, size_t size, size_t new_size) {\n+  DCHECK_LT(new_size, size);\n+  return base::OS::Release(reinterpret_cast<uint8_t*>(address) + new_size,\n+                           size - new_size);\n+}\n+\n+bool PageAllocator::SetPermissions(void* address, size_t size,\n+                                   PageAllocator::Permission access) {\n+  return base::OS::SetPermissions(\n+      address, size, static_cast<base::OS::MemoryPermission>(access));\n+}\n+\n+}  // namespace base\n+}  // namespace v8"
        },
        {
            "sha": "ff817cdba22738413da8d1faf731210f675af0be",
            "filename": "deps/v8/src/base/page-allocator.h",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fpage-allocator.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fpage-allocator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fpage-allocator.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8_BASE_PAGE_ALLOCATOR_H_\n+#define V8_BASE_PAGE_ALLOCATOR_H_\n+\n+#include \"include/v8-platform.h\"\n+#include \"src/base/base-export.h\"\n+#include \"src/base/compiler-specific.h\"\n+\n+namespace v8 {\n+namespace base {\n+\n+class V8_BASE_EXPORT PageAllocator\n+    : public NON_EXPORTED_BASE(::v8::PageAllocator) {\n+ public:\n+  virtual ~PageAllocator() = default;\n+\n+  size_t AllocatePageSize() override;\n+\n+  size_t CommitPageSize() override;\n+\n+  void SetRandomMmapSeed(int64_t seed) override;\n+\n+  void* GetRandomMmapAddr() override;\n+\n+  void* AllocatePages(void* address, size_t size, size_t alignment,\n+                      PageAllocator::Permission access) override;\n+\n+  bool FreePages(void* address, size_t size) override;\n+\n+  bool ReleasePages(void* address, size_t size, size_t new_size) override;\n+\n+  bool SetPermissions(void* address, size_t size,\n+                      PageAllocator::Permission access) override;\n+};\n+\n+}  // namespace base\n+}  // namespace v8\n+#endif  // V8_BASE_PAGE_ALLOCATOR_H_"
        },
        {
            "sha": "38a7070e8539597e67963ea3a0b7136a0edce86b",
            "filename": "deps/v8/src/base/platform/platform-fuchsia.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-fuchsia.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-fuchsia.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-fuchsia.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -124,12 +124,11 @@ bool OS::HasLazyCommits() {\n }\n \n std::vector<OS::SharedLibraryAddress> OS::GetSharedLibraryAddresses() {\n-  CHECK(false);  // TODO(scottmg): Port, https://crbug.com/731217.\n-  return std::vector<SharedLibraryAddress>();\n+  UNREACHABLE();  // TODO(scottmg): Port, https://crbug.com/731217.\n }\n \n void OS::SignalCodeMovingGC() {\n-  CHECK(false);  // TODO(scottmg): Port, https://crbug.com/731217.\n+  UNREACHABLE();  // TODO(scottmg): Port, https://crbug.com/731217.\n }\n \n }  // namespace base"
        },
        {
            "sha": "5edbd7648b537d0482ad94e2dc31e017b8a9af28",
            "filename": "deps/v8/src/base/platform/platform-posix.cc",
            "status": "modified",
            "additions": 35,
            "deletions": 23,
            "changes": 58,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-posix.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-posix.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-posix.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -89,6 +89,7 @@ const char* g_gc_fake_mmap = nullptr;\n \n static LazyInstance<RandomNumberGenerator>::type\n     platform_random_number_generator = LAZY_INSTANCE_INITIALIZER;\n+static LazyMutex rng_mutex = LAZY_MUTEX_INITIALIZER;\n \n #if !V8_OS_FUCHSIA\n #if V8_OS_MACOSX\n@@ -130,11 +131,9 @@ int GetFlagsForMemoryPermission(OS::MemoryPermission access) {\n }\n \n void* Allocate(void* address, size_t size, OS::MemoryPermission access) {\n-  const size_t actual_size = RoundUp(size, OS::AllocatePageSize());\n   int prot = GetProtectionFromMemoryPermission(access);\n   int flags = GetFlagsForMemoryPermission(access);\n-  void* result =\n-      mmap(address, actual_size, prot, flags, kMmapFd, kMmapFdOffset);\n+  void* result = mmap(address, size, prot, flags, kMmapFd, kMmapFdOffset);\n   if (result == MAP_FAILED) return nullptr;\n   return result;\n }\n@@ -167,11 +166,7 @@ int ReclaimInaccessibleMemory(void* address, size_t size) {\n \n }  // namespace\n \n-void OS::Initialize(int64_t random_seed, bool hard_abort,\n-                    const char* const gc_fake_mmap) {\n-  if (random_seed) {\n-    platform_random_number_generator.Pointer()->SetSeed(random_seed);\n-  }\n+void OS::Initialize(bool hard_abort, const char* const gc_fake_mmap) {\n   g_hard_abort = hard_abort;\n   g_gc_fake_mmap = gc_fake_mmap;\n }\n@@ -206,46 +201,61 @@ size_t OS::CommitPageSize() {\n   return page_size;\n }\n \n+// static\n+void OS::SetRandomMmapSeed(int64_t seed) {\n+  if (seed) {\n+    LockGuard<Mutex> guard(rng_mutex.Pointer());\n+    platform_random_number_generator.Pointer()->SetSeed(seed);\n+  }\n+}\n+\n // static\n void* OS::GetRandomMmapAddr() {\n-#if defined(ADDRESS_SANITIZER) || defined(MEMORY_SANITIZER) || \\\n-    defined(THREAD_SANITIZER)\n-  // Dynamic tools do not support custom mmap addresses.\n-  return nullptr;\n-#endif\n   uintptr_t raw_addr;\n-  platform_random_number_generator.Pointer()->NextBytes(&raw_addr,\n-                                                        sizeof(raw_addr));\n+  {\n+    LockGuard<Mutex> guard(rng_mutex.Pointer());\n+    platform_random_number_generator.Pointer()->NextBytes(&raw_addr,\n+                                                          sizeof(raw_addr));\n+  }\n+#if defined(V8_USE_ADDRESS_SANITIZER) || defined(MEMORY_SANITIZER) || \\\n+    defined(THREAD_SANITIZER) || defined(LEAK_SANITIZER)\n+  // If random hint addresses interfere with address ranges hard coded in\n+  // sanitizers, bad things happen. This address range is copied from TSAN\n+  // source but works with all tools.\n+  // See crbug.com/539863.\n+  raw_addr &= 0x007fffff0000ULL;\n+  raw_addr += 0x7e8000000000ULL;\n+#else\n #if V8_TARGET_ARCH_X64\n   // Currently available CPUs have 48 bits of virtual addressing.  Truncate\n   // the hint address to 46 bits to give the kernel a fighting chance of\n   // fulfilling our placement request.\n-  raw_addr &= V8_UINT64_C(0x3ffffffff000);\n+  raw_addr &= uint64_t{0x3FFFFFFFF000};\n #elif V8_TARGET_ARCH_PPC64\n #if V8_OS_AIX\n   // AIX: 64 bits of virtual addressing, but we limit address range to:\n   //   a) minimize Segment Lookaside Buffer (SLB) misses and\n-  raw_addr &= V8_UINT64_C(0x3ffff000);\n+  raw_addr &= uint64_t{0x3FFFF000};\n   // Use extra address space to isolate the mmap regions.\n-  raw_addr += V8_UINT64_C(0x400000000000);\n+  raw_addr += uint64_t{0x400000000000};\n #elif V8_TARGET_BIG_ENDIAN\n   // Big-endian Linux: 44 bits of virtual addressing.\n-  raw_addr &= V8_UINT64_C(0x03fffffff000);\n+  raw_addr &= uint64_t{0x03FFFFFFF000};\n #else\n   // Little-endian Linux: 48 bits of virtual addressing.\n-  raw_addr &= V8_UINT64_C(0x3ffffffff000);\n+  raw_addr &= uint64_t{0x3FFFFFFFF000};\n #endif\n #elif V8_TARGET_ARCH_S390X\n   // Linux on Z uses bits 22-32 for Region Indexing, which translates to 42 bits\n   // of virtual addressing.  Truncate to 40 bits to allow kernel chance to\n   // fulfill request.\n-  raw_addr &= V8_UINT64_C(0xfffffff000);\n+  raw_addr &= uint64_t{0xFFFFFFF000};\n #elif V8_TARGET_ARCH_S390\n   // 31 bits of virtual addressing.  Truncate to 29 bits to allow kernel chance\n   // to fulfill request.\n-  raw_addr &= 0x1ffff000;\n+  raw_addr &= 0x1FFFF000;\n #else\n-  raw_addr &= 0x3ffff000;\n+  raw_addr &= 0x3FFFF000;\n \n #ifdef __sun\n   // For our Solaris/illumos mmap hint, we pick a random address in the bottom\n@@ -268,6 +278,7 @@ void* OS::GetRandomMmapAddr() {\n   // 10.6 and 10.7.\n   raw_addr += 0x20000000;\n #endif\n+#endif\n #endif\n   return reinterpret_cast<void*>(raw_addr);\n }\n@@ -283,6 +294,7 @@ void* OS::Allocate(void* address, size_t size, size_t alignment,\n   address = AlignedAddress(address, alignment);\n   // Add the maximum misalignment so we are guaranteed an aligned base address.\n   size_t request_size = size + (alignment - page_size);\n+  request_size = RoundUp(request_size, OS::AllocatePageSize());\n   void* result = base::Allocate(address, request_size, access);\n   if (result == nullptr) return nullptr;\n "
        },
        {
            "sha": "22580cc407fd994725b913c2e44881e851a14588",
            "filename": "deps/v8/src/base/platform/platform-win32.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 12,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-win32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-win32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-win32.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -674,8 +674,15 @@ void OS::StrNCpy(char* dest, int length, const char* src, size_t n) {\n #undef _TRUNCATE\n #undef STRUNCATE\n \n-// The allocation alignment is the guaranteed alignment for\n-// VirtualAlloc'ed blocks of memory.\n+static LazyInstance<RandomNumberGenerator>::type\n+    platform_random_number_generator = LAZY_INSTANCE_INITIALIZER;\n+static LazyMutex rng_mutex = LAZY_MUTEX_INITIALIZER;\n+\n+void OS::Initialize(bool hard_abort, const char* const gc_fake_mmap) {\n+  g_hard_abort = hard_abort;\n+}\n+\n+// static\n size_t OS::AllocatePageSize() {\n   static size_t allocate_alignment = 0;\n   if (allocate_alignment == 0) {\n@@ -686,6 +693,7 @@ size_t OS::AllocatePageSize() {\n   return allocate_alignment;\n }\n \n+// static\n size_t OS::CommitPageSize() {\n   static size_t page_size = 0;\n   if (page_size == 0) {\n@@ -697,17 +705,15 @@ size_t OS::CommitPageSize() {\n   return page_size;\n }\n \n-static LazyInstance<RandomNumberGenerator>::type\n-    platform_random_number_generator = LAZY_INSTANCE_INITIALIZER;\n-\n-void OS::Initialize(int64_t random_seed, bool hard_abort,\n-                    const char* const gc_fake_mmap) {\n-  if (random_seed) {\n-    platform_random_number_generator.Pointer()->SetSeed(random_seed);\n+// static\n+void OS::SetRandomMmapSeed(int64_t seed) {\n+  if (seed) {\n+    LockGuard<Mutex> guard(rng_mutex.Pointer());\n+    platform_random_number_generator.Pointer()->SetSeed(seed);\n   }\n-  g_hard_abort = hard_abort;\n }\n \n+// static\n void* OS::GetRandomMmapAddr() {\n // The address range used to randomize RWX allocations in OS::Allocate\n // Try not to map pages into the default range that windows loads DLLs\n@@ -722,8 +728,11 @@ void* OS::GetRandomMmapAddr() {\n   static const uintptr_t kAllocationRandomAddressMax = 0x3FFF0000;\n #endif\n   uintptr_t address;\n-  platform_random_number_generator.Pointer()->NextBytes(&address,\n-                                                        sizeof(address));\n+  {\n+    LockGuard<Mutex> guard(rng_mutex.Pointer());\n+    platform_random_number_generator.Pointer()->NextBytes(&address,\n+                                                          sizeof(address));\n+  }\n   address <<= kPageSizeBits;\n   address += kAllocationRandomAddressMin;\n   address &= kAllocationRandomAddressMax;"
        },
        {
            "sha": "8a4545c607f91af235b8c236f9c7859da061daa4",
            "filename": "deps/v8/src/base/platform/platform.h",
            "status": "modified",
            "additions": 29,
            "deletions": 39,
            "changes": 68,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -36,6 +36,7 @@\n #endif\n \n namespace v8 {\n+\n namespace base {\n \n // ----------------------------------------------------------------------------\n@@ -93,10 +94,9 @@ inline intptr_t InternalGetExistingThreadLocal(intptr_t index) {\n \n #endif  // V8_NO_FAST_TLS\n \n-\n+class PageAllocator;\n class TimezoneCache;\n \n-\n // ----------------------------------------------------------------------------\n // OS\n //\n@@ -107,11 +107,9 @@ class TimezoneCache;\n class V8_BASE_EXPORT OS {\n  public:\n   // Initialize the OS class.\n-  // - random_seed: Used for the GetRandomMmapAddress() if non-zero.\n   // - hard_abort: If true, OS::Abort() will crash instead of aborting.\n   // - gc_fake_mmap: Name of the file for fake gc mmap used in ll_prof.\n-  static void Initialize(int64_t random_seed, bool hard_abort,\n-                         const char* const gc_fake_mmap);\n+  static void Initialize(bool hard_abort, const char* const gc_fake_mmap);\n \n   // Returns the accumulated user time for thread. This routine\n   // can be used for profiling. The implementation should\n@@ -157,6 +155,8 @@ class V8_BASE_EXPORT OS {\n   static PRINTF_FORMAT(1, 2) void PrintError(const char* format, ...);\n   static PRINTF_FORMAT(1, 0) void VPrintError(const char* format, va_list args);\n \n+  // Memory permissions. These should be kept in sync with the ones in\n+  // v8::PageAllocator.\n   enum class MemoryPermission {\n     kNoAccess,\n     kReadWrite,\n@@ -165,40 +165,6 @@ class V8_BASE_EXPORT OS {\n     kReadExecute\n   };\n \n-  // Gets the page granularity for Allocate. Addresses returned by Allocate are\n-  // aligned to this size.\n-  static size_t AllocatePageSize();\n-\n-  // Gets the granularity at which the permissions and commit calls can be made.\n-  static size_t CommitPageSize();\n-\n-  // Generate a random address to be used for hinting allocation calls.\n-  static void* GetRandomMmapAddr();\n-\n-  // Allocates memory. Permissions are set according to the access argument.\n-  // The address parameter is a hint. The size and alignment parameters must be\n-  // multiples of AllocatePageSize(). Returns the address of the allocated\n-  // memory, with the specified size and alignment, or nullptr on failure.\n-  V8_WARN_UNUSED_RESULT static void* Allocate(void* address, size_t size,\n-                                              size_t alignment,\n-                                              MemoryPermission access);\n-\n-  // Frees memory allocated by a call to Allocate. address and size must be\n-  // multiples of AllocatePageSize(). Returns true on success, otherwise false.\n-  V8_WARN_UNUSED_RESULT static bool Free(void* address, const size_t size);\n-\n-  // Releases memory that is no longer needed. The range specified by address\n-  // and size must be part of an allocated memory region, and must be multiples\n-  // of CommitPageSize(). Released memory is left in an undefined state, so it\n-  // should not be accessed. Returns true on success, otherwise false.\n-  V8_WARN_UNUSED_RESULT static bool Release(void* address, size_t size);\n-\n-  // Sets permissions according to the access argument. address and size must be\n-  // multiples of CommitPageSize(). Setting permission to kNoAccess may cause\n-  // the memory contents to be lost. Returns true on success, otherwise false.\n-  V8_WARN_UNUSED_RESULT static bool SetPermissions(void* address, size_t size,\n-                                                   MemoryPermission access);\n-\n   static bool HasLazyCommits();\n \n   // Sleep for a specified time interval.\n@@ -280,6 +246,30 @@ class V8_BASE_EXPORT OS {\n   static int GetCurrentThreadId();\n \n  private:\n+  // These classes use the private memory management API below.\n+  friend class MemoryMappedFile;\n+  friend class PosixMemoryMappedFile;\n+  friend class v8::base::PageAllocator;\n+\n+  static size_t AllocatePageSize();\n+\n+  static size_t CommitPageSize();\n+\n+  static void SetRandomMmapSeed(int64_t seed);\n+\n+  static void* GetRandomMmapAddr();\n+\n+  V8_WARN_UNUSED_RESULT static void* Allocate(void* address, size_t size,\n+                                              size_t alignment,\n+                                              MemoryPermission access);\n+\n+  V8_WARN_UNUSED_RESULT static bool Free(void* address, const size_t size);\n+\n+  V8_WARN_UNUSED_RESULT static bool Release(void* address, size_t size);\n+\n+  V8_WARN_UNUSED_RESULT static bool SetPermissions(void* address, size_t size,\n+                                                   MemoryPermission access);\n+\n   static const int msPerSecond = 1000;\n \n #if V8_OS_POSIX"
        },
        {
            "sha": "59506645238e1a954e02ec4ca13777634d0c0eaf",
            "filename": "deps/v8/src/base/platform/semaphore.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fsemaphore.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fsemaphore.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fsemaphore.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -136,7 +136,7 @@ bool Semaphore::WaitFor(const TimeDelta& rel_time) {\n \n Semaphore::Semaphore(int count) {\n   DCHECK_GE(count, 0);\n-  native_handle_ = ::CreateSemaphoreA(nullptr, count, 0x7fffffff, nullptr);\n+  native_handle_ = ::CreateSemaphoreA(nullptr, count, 0x7FFFFFFF, nullptr);\n   DCHECK_NOT_NULL(native_handle_);\n }\n "
        },
        {
            "sha": "1fcd7aecceaa997632d4bbb6fba3ed376f1bb41b",
            "filename": "deps/v8/src/base/platform/time.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Ftime.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Ftime.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Ftime.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -298,8 +298,7 @@ Time Time::NowFromSystemTime() {\n \n \n // Time between windows epoch and standard epoch.\n-static const int64_t kTimeToEpochInMicroseconds = V8_INT64_C(11644473600000000);\n-\n+static const int64_t kTimeToEpochInMicroseconds = int64_t{11644473600000000};\n \n Time Time::FromFiletime(FILETIME ft) {\n   if (ft.dwLowDateTime == 0 && ft.dwHighDateTime == 0) {"
        },
        {
            "sha": "f63f1ad99e6c287b9ebcf910132e1302f5288b20",
            "filename": "deps/v8/src/base/safe_conversions.h",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fsafe_conversions.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Fsafe_conversions.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fsafe_conversions.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -53,8 +53,7 @@ inline Dst saturated_cast(Src value) {\n \n     // Should fail only on attempting to assign NaN to a saturated integer.\n     case internal::RANGE_INVALID:\n-      CHECK(false);\n-      return std::numeric_limits<Dst>::max();\n+      UNREACHABLE();\n   }\n \n   UNREACHABLE();"
        },
        {
            "sha": "afe5a1f0989c31300b2d4b98ac6b275e9031c56f",
            "filename": "deps/v8/src/base/utils/random-number-generator.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Futils%2Frandom-number-generator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Futils%2Frandom-number-generator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Futils%2Frandom-number-generator.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -213,9 +213,9 @@ void RandomNumberGenerator::SetSeed(int64_t seed) {\n \n uint64_t RandomNumberGenerator::MurmurHash3(uint64_t h) {\n   h ^= h >> 33;\n-  h *= V8_UINT64_C(0xFF51AFD7ED558CCD);\n+  h *= uint64_t{0xFF51AFD7ED558CCD};\n   h ^= h >> 33;\n-  h *= V8_UINT64_C(0xC4CEB9FE1A85EC53);\n+  h *= uint64_t{0xC4CEB9FE1A85EC53};\n   h ^= h >> 33;\n   return h;\n }"
        },
        {
            "sha": "321ce861fbd530d71ffc490b460713dc8fe0472c",
            "filename": "deps/v8/src/base/utils/random-number-generator.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Futils%2Frandom-number-generator.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbase%2Futils%2Frandom-number-generator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Futils%2Frandom-number-generator.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -113,8 +113,8 @@ class V8_BASE_EXPORT RandomNumberGenerator final {\n   // Static and exposed for external use.\n   static inline double ToDouble(uint64_t state0, uint64_t state1) {\n     // Exponent for double values for [1.0 .. 2.0)\n-    static const uint64_t kExponentBits = V8_UINT64_C(0x3FF0000000000000);\n-    static const uint64_t kMantissaMask = V8_UINT64_C(0x000FFFFFFFFFFFFF);\n+    static const uint64_t kExponentBits = uint64_t{0x3FF0000000000000};\n+    static const uint64_t kMantissaMask = uint64_t{0x000FFFFFFFFFFFFF};\n     uint64_t random = ((state0 + state1) & kMantissaMask) | kExponentBits;\n     return bit_cast<double>(random) - 1;\n   }"
        },
        {
            "sha": "a0a398b7aada1ffb7f5d0b5397d7f6a2d085584b",
            "filename": "deps/v8/src/bignum.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbignum.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbignum.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbignum.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -278,7 +278,7 @@ void Bignum::MultiplyByUInt64(uint64_t factor) {\n \n \n void Bignum::MultiplyByPowerOfTen(int exponent) {\n-  const uint64_t kFive27 = V8_2PART_UINT64_C(0x6765c793, fa10079d);\n+  const uint64_t kFive27 = V8_2PART_UINT64_C(0x6765C793, fa10079d);\n   const uint16_t kFive1 = 5;\n   const uint16_t kFive2 = kFive1 * 5;\n   const uint16_t kFive3 = kFive2 * 5;"
        },
        {
            "sha": "399b705f00897fb2be40ee9a39ccf37f67c662ff",
            "filename": "deps/v8/src/bootstrapper.cc",
            "status": "modified",
            "additions": 126,
            "deletions": 56,
            "changes": 182,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbootstrapper.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbootstrapper.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbootstrapper.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -214,10 +214,12 @@ class Genesis BASE_EMBEDDED {\n   HARMONY_SHIPPING(DECLARE_FEATURE_INITIALIZATION)\n #undef DECLARE_FEATURE_INITIALIZATION\n \n+  enum ArrayBufferKind {\n+    ARRAY_BUFFER,\n+    SHARED_ARRAY_BUFFER,\n+  };\n   Handle<JSFunction> CreateArrayBuffer(Handle<String> name,\n-                                       Builtins::Name call_byteLength,\n-                                       BuiltinFunctionId byteLength_id,\n-                                       Builtins::Name call_slice);\n+                                       ArrayBufferKind array_buffer_kind);\n   Handle<JSFunction> InstallInternalArray(Handle<JSObject> target,\n                                           const char* name,\n                                           ElementsKind elements_kind);\n@@ -780,7 +782,7 @@ void Genesis::CreateObjectFunction(Handle<JSFunction> empty_function) {\n                               \"EmptyObjectPrototype\");\n   map->set_is_prototype_map(true);\n   // Ban re-setting Object.prototype.__proto__ to prevent Proxy security bug\n-  map->set_immutable_proto(true);\n+  map->set_is_immutable_proto(true);\n   object_function_prototype->set_map(*map);\n \n   // Complete setting up empty function.\n@@ -1073,19 +1075,44 @@ void Genesis::CreateJSProxyMaps() {\n   // constructable proxies.\n   Handle<Map> proxy_map = factory()->NewMap(JS_PROXY_TYPE, JSProxy::kSize,\n                                             TERMINAL_FAST_ELEMENTS_KIND);\n-  proxy_map->set_dictionary_map(true);\n+  proxy_map->set_is_dictionary_map(true);\n   proxy_map->set_may_have_interesting_symbols(true);\n   native_context()->set_proxy_map(*proxy_map);\n \n   Handle<Map> proxy_callable_map = Map::Copy(proxy_map, \"callable Proxy\");\n-  proxy_callable_map->set_is_callable();\n+  proxy_callable_map->set_is_callable(true);\n   native_context()->set_proxy_callable_map(*proxy_callable_map);\n   proxy_callable_map->SetConstructor(native_context()->function_function());\n \n   Handle<Map> proxy_constructor_map =\n       Map::Copy(proxy_callable_map, \"constructor Proxy\");\n   proxy_constructor_map->set_is_constructor(true);\n   native_context()->set_proxy_constructor_map(*proxy_constructor_map);\n+\n+  {\n+    Handle<Map> map =\n+        factory()->NewMap(JS_OBJECT_TYPE, JSProxyRevocableResult::kSize,\n+                          TERMINAL_FAST_ELEMENTS_KIND, 2);\n+    Map::EnsureDescriptorSlack(map, 2);\n+\n+    {  // proxy\n+      Descriptor d = Descriptor::DataField(factory()->proxy_string(),\n+                                           JSProxyRevocableResult::kProxyIndex,\n+                                           NONE, Representation::Tagged());\n+      map->AppendDescriptor(&d);\n+    }\n+    {  // revoke\n+      Descriptor d = Descriptor::DataField(factory()->revoke_string(),\n+                                           JSProxyRevocableResult::kRevokeIndex,\n+                                           NONE, Representation::Tagged());\n+      map->AppendDescriptor(&d);\n+    }\n+\n+    Map::SetPrototype(map, isolate()->initial_object_prototype());\n+    map->SetConstructor(native_context()->object_function());\n+\n+    native_context()->set_proxy_revocable_result_map(*map);\n+  }\n }\n \n namespace {\n@@ -1227,7 +1254,7 @@ Handle<JSGlobalObject> Genesis::CreateNewGlobals(\n   }\n \n   js_global_object_function->initial_map()->set_is_prototype_map(true);\n-  js_global_object_function->initial_map()->set_dictionary_map(true);\n+  js_global_object_function->initial_map()->set_is_dictionary_map(true);\n   js_global_object_function->initial_map()->set_may_have_interesting_symbols(\n       true);\n   Handle<JSGlobalObject> global_object =\n@@ -1481,9 +1508,9 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n         object_function, \"keys\", Builtins::kObjectKeys, 1, true);\n     native_context()->set_object_keys(*object_keys);\n     SimpleInstallFunction(object_function, factory->entries_string(),\n-                          Builtins::kObjectEntries, 1, false);\n+                          Builtins::kObjectEntries, 1, true);\n     SimpleInstallFunction(object_function, factory->values_string(),\n-                          Builtins::kObjectValues, 1, false);\n+                          Builtins::kObjectValues, 1, true);\n \n     SimpleInstallFunction(isolate->initial_object_prototype(),\n                           \"__defineGetter__\", Builtins::kObjectDefineGetter, 2,\n@@ -1517,6 +1544,9 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n                               factory->proto_string(),\n                               Builtins::kObjectPrototypeGetProto,\n                               Builtins::kObjectPrototypeSetProto, DONT_ENUM);\n+\n+    SimpleInstallFunction(isolate->initial_object_prototype(), \"toLocaleString\",\n+                          Builtins::kObjectPrototypeToLocaleString, 0, true);\n   }\n \n   Handle<JSObject> global(native_context()->global_object());\n@@ -1679,12 +1709,18 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n                           DONT_ENUM);\n \n     SimpleInstallFunction(proto, \"concat\", Builtins::kArrayConcat, 1, false);\n-    SimpleInstallFunction(proto, \"pop\", Builtins::kFastArrayPop, 0, false);\n-    SimpleInstallFunction(proto, \"push\", Builtins::kFastArrayPush, 1, false);\n-    SimpleInstallFunction(proto, \"shift\", Builtins::kFastArrayShift, 0, false);\n+    SimpleInstallFunction(proto, \"find\", Builtins::kArrayPrototypeFind, 1,\n+                          false);\n+    SimpleInstallFunction(proto, \"findIndex\",\n+                          Builtins::kArrayPrototypeFindIndex, 1, false);\n+    SimpleInstallFunction(proto, \"pop\", Builtins::kArrayPrototypePop, 0, false);\n+    SimpleInstallFunction(proto, \"push\", Builtins::kArrayPrototypePush, 1,\n+                          false);\n+    SimpleInstallFunction(proto, \"shift\", Builtins::kArrayPrototypeShift, 0,\n+                          false);\n     SimpleInstallFunction(proto, \"unshift\", Builtins::kArrayUnshift, 1, false);\n     if (FLAG_enable_experimental_builtins) {\n-      SimpleInstallFunction(proto, \"slice\", Builtins::kFastArraySlice, 2,\n+      SimpleInstallFunction(proto, \"slice\", Builtins::kArrayPrototypeSlice, 2,\n                             false);\n     } else {\n       SimpleInstallFunction(proto, \"slice\", Builtins::kArraySlice, 2, false);\n@@ -1798,6 +1834,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n     Handle<JSFunction> number_fun = InstallFunction(\n         global, \"Number\", JS_VALUE_TYPE, JSValue::kSize, 0,\n         isolate->initial_object_prototype(), Builtins::kNumberConstructor);\n+    number_fun->shared()->set_builtin_function_id(kNumberConstructor);\n     number_fun->shared()->DontAdaptArguments();\n     number_fun->shared()->SetConstructStub(\n         *BUILTIN_CODE(isolate, NumberConstructor_ConstructStub));\n@@ -1942,6 +1979,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n     Handle<JSFunction> string_fun = InstallFunction(\n         global, \"String\", JS_VALUE_TYPE, JSValue::kSize, 0,\n         isolate->initial_object_prototype(), Builtins::kStringConstructor);\n+    string_fun->shared()->set_builtin_function_id(kStringConstructor);\n     string_fun->shared()->SetConstructStub(\n         *BUILTIN_CODE(isolate, StringConstructor_ConstructStub));\n     string_fun->shared()->DontAdaptArguments();\n@@ -2123,6 +2161,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n     Handle<JSFunction> symbol_fun = InstallFunction(\n         global, \"Symbol\", JS_VALUE_TYPE, JSValue::kSize, 0,\n         factory->the_hole_value(), Builtins::kSymbolConstructor);\n+    symbol_fun->shared()->set_builtin_function_id(kSymbolConstructor);\n     symbol_fun->shared()->SetConstructStub(\n         *BUILTIN_CODE(isolate, SymbolConstructor_ConstructStub));\n     symbol_fun->shared()->set_length(0);\n@@ -2135,6 +2174,8 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n                           false);\n \n     // Install well-known symbols.\n+    InstallConstant(isolate, symbol_fun, \"asyncIterator\",\n+                    factory->async_iterator_symbol());\n     InstallConstant(isolate, symbol_fun, \"hasInstance\",\n                     factory->has_instance_symbol());\n     InstallConstant(isolate, symbol_fun, \"isConcatSpreadable\",\n@@ -2362,11 +2403,11 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n \n     Handle<JSFunction> promise_then =\n         SimpleInstallFunction(prototype, isolate->factory()->then_string(),\n-                              Builtins::kPromiseThen, 2, true);\n+                              Builtins::kPromisePrototypeThen, 2, true);\n     native_context()->set_promise_then(*promise_then);\n \n     Handle<JSFunction> promise_catch = SimpleInstallFunction(\n-        prototype, \"catch\", Builtins::kPromiseCatch, 1, true);\n+        prototype, \"catch\", Builtins::kPromisePrototypeCatch, 1, true);\n     native_context()->set_promise_catch(*promise_catch);\n \n     // Force the Promise constructor to fast properties, so that we can use the\n@@ -2410,8 +2451,9 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n     }\n \n     {  // Internal: PromiseHandle\n-      Handle<JSFunction> function = SimpleCreateFunction(\n-          isolate, factory->empty_string(), Builtins::kPromiseHandle, 5, false);\n+      Handle<JSFunction> function =\n+          SimpleCreateFunction(isolate, factory->empty_string(),\n+                               Builtins::kPromiseHandleJS, 5, false);\n       native_context()->set_promise_handle(*function);\n     }\n \n@@ -2921,10 +2963,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n \n   {  // -- A r r a y B u f f e r\n     Handle<String> name = factory->InternalizeUtf8String(\"ArrayBuffer\");\n-    Handle<JSFunction> array_buffer_fun =\n-        CreateArrayBuffer(name, Builtins::kArrayBufferPrototypeGetByteLength,\n-                          BuiltinFunctionId::kArrayBufferByteLength,\n-                          Builtins::kArrayBufferPrototypeSlice);\n+    Handle<JSFunction> array_buffer_fun = CreateArrayBuffer(name, ARRAY_BUFFER);\n     JSObject::AddProperty(global, name, array_buffer_fun, DONT_ENUM);\n     InstallWithIntrinsicDefaultProto(isolate, array_buffer_fun,\n                                      Context::ARRAY_BUFFER_FUN_INDEX);\n@@ -2940,10 +2979,8 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n \n   {  // -- S h a r e d A r r a y B u f f e r\n     Handle<String> name = factory->InternalizeUtf8String(\"SharedArrayBuffer\");\n-    Handle<JSFunction> shared_array_buffer_fun = CreateArrayBuffer(\n-        name, Builtins::kSharedArrayBufferPrototypeGetByteLength,\n-        BuiltinFunctionId::kSharedArrayBufferByteLength,\n-        Builtins::kSharedArrayBufferPrototypeSlice);\n+    Handle<JSFunction> shared_array_buffer_fun =\n+        CreateArrayBuffer(name, SHARED_ARRAY_BUFFER);\n     InstallWithIntrinsicDefaultProto(isolate, shared_array_buffer_fun,\n                                      Context::SHARED_ARRAY_BUFFER_FUN_INDEX);\n     InstallSpeciesGetter(shared_array_buffer_fun);\n@@ -3415,6 +3452,15 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n \n     native_context()->set_proxy_function(*proxy_function);\n     InstallFunction(global, name, proxy_function, factory->Object_string());\n+\n+    SimpleInstallFunction(proxy_function, \"revocable\",\n+                          Builtins::kProxyRevocable, 2, true);\n+\n+    {  // Internal: ProxyRevoke\n+      Handle<SharedFunctionInfo> info = SimpleCreateSharedFunctionInfo(\n+          isolate, Builtins::kProxyRevoke, factory->empty_string(), 0);\n+      native_context()->set_proxy_revoke_shared_fun(*info);\n+    }\n   }\n \n   {  // -- R e f l e c t\n@@ -3467,7 +3513,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,\n         factory->NewMap(JS_BOUND_FUNCTION_TYPE, JSBoundFunction::kSize,\n                         TERMINAL_FAST_ELEMENTS_KIND, 0);\n     map->SetConstructor(native_context()->object_function());\n-    map->set_is_callable();\n+    map->set_is_callable(true);\n     Map::SetPrototype(map, empty_function);\n \n     PropertyAttributes roc_attribs =\n@@ -4301,10 +4347,13 @@ EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_regexp_property)\n EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_function_sent)\n EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_function_tostring)\n EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_public_fields)\n+EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_private_fields)\n+EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_static_fields)\n EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_class_fields)\n EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_dynamic_import)\n EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_import_meta)\n EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_restrict_constructor_return)\n+EMPTY_INITIALIZE_GLOBAL_FOR_FEATURE(harmony_optional_catch_binding)\n \n void InstallPublicSymbol(Factory* factory, Handle<Context> native_context,\n                          const char* name, Handle<Symbol> value) {\n@@ -4362,20 +4411,13 @@ void Genesis::InitializeGlobal_harmony_array_prototype_values() {\n                         NONE);\n }\n \n-void Genesis::InitializeGlobal_harmony_async_iteration() {\n-  if (!FLAG_harmony_async_iteration) return;\n-  Handle<JSFunction> symbol_fun(native_context()->symbol_function());\n-  InstallConstant(isolate(), symbol_fun, \"asyncIterator\",\n-                  factory()->async_iterator_symbol());\n-}\n-\n void Genesis::InitializeGlobal_harmony_promise_finally() {\n   if (!FLAG_harmony_promise_finally) return;\n \n   Handle<JSFunction> constructor(native_context()->promise_function());\n   Handle<JSObject> prototype(JSObject::cast(constructor->instance_prototype()));\n-  SimpleInstallFunction(prototype, \"finally\", Builtins::kPromiseFinally, 1,\n-                        true, DONT_ENUM);\n+  SimpleInstallFunction(prototype, \"finally\",\n+                        Builtins::kPromisePrototypeFinally, 1, true, DONT_ENUM);\n \n   // The promise prototype map has changed because we added a property\n   // to prototype, so we update the saved map.\n@@ -4421,6 +4463,7 @@ void Genesis::InitializeGlobal_harmony_bigint() {\n   Handle<JSFunction> bigint_fun =\n       InstallFunction(global, \"BigInt\", JS_VALUE_TYPE, JSValue::kSize, 0,\n                       factory->the_hole_value(), Builtins::kBigIntConstructor);\n+  bigint_fun->shared()->set_builtin_function_id(kBigIntConstructor);\n   bigint_fun->shared()->DontAdaptArguments();\n   bigint_fun->shared()->SetConstructStub(\n       *BUILTIN_CODE(isolate(), BigIntConstructor_ConstructStub));\n@@ -4492,10 +4535,8 @@ void Genesis::InitializeGlobal_harmony_plural_rules() {\n \n #endif  // V8_INTL_SUPPORT\n \n-Handle<JSFunction> Genesis::CreateArrayBuffer(Handle<String> name,\n-                                              Builtins::Name call_byteLength,\n-                                              BuiltinFunctionId byteLength_id,\n-                                              Builtins::Name call_slice) {\n+Handle<JSFunction> Genesis::CreateArrayBuffer(\n+    Handle<String> name, ArrayBufferKind array_buffer_kind) {\n   // Create the %ArrayBufferPrototype%\n   // Setup the {prototype} with the given {name} for @@toStringTag.\n   Handle<JSObject> prototype =\n@@ -4519,15 +4560,33 @@ Handle<JSFunction> Genesis::CreateArrayBuffer(Handle<String> name,\n   JSObject::AddProperty(prototype, factory()->constructor_string(),\n                         array_buffer_fun, DONT_ENUM);\n \n-  SimpleInstallFunction(array_buffer_fun, factory()->isView_string(),\n-                        Builtins::kArrayBufferIsView, 1, true, DONT_ENUM,\n-                        kArrayBufferIsView);\n+  switch (array_buffer_kind) {\n+    case ARRAY_BUFFER:\n+      SimpleInstallFunction(array_buffer_fun, factory()->isView_string(),\n+                            Builtins::kArrayBufferIsView, 1, true, DONT_ENUM,\n+                            kArrayBufferIsView);\n+\n+      // Install the \"byteLength\" getter on the {prototype}.\n+      SimpleInstallGetter(prototype, factory()->byte_length_string(),\n+                          Builtins::kArrayBufferPrototypeGetByteLength, false,\n+                          BuiltinFunctionId::kArrayBufferByteLength);\n+\n+      SimpleInstallFunction(prototype, \"slice\",\n+                            Builtins::kArrayBufferPrototypeSlice, 2, true);\n+      break;\n \n-  // Install the \"byteLength\" getter on the {prototype}.\n-  SimpleInstallGetter(prototype, factory()->byte_length_string(),\n-                      call_byteLength, false, byteLength_id);\n+    case SHARED_ARRAY_BUFFER:\n+      // Install the \"byteLength\" getter on the {prototype}.\n+      SimpleInstallGetter(prototype, factory()->byte_length_string(),\n+                          Builtins::kSharedArrayBufferPrototypeGetByteLength,\n+                          false,\n+                          BuiltinFunctionId::kSharedArrayBufferByteLength);\n \n-  SimpleInstallFunction(prototype, \"slice\", call_slice, 2, true);\n+      SimpleInstallFunction(prototype, \"slice\",\n+                            Builtins::kSharedArrayBufferPrototypeSlice, 2,\n+                            true);\n+      break;\n+  }\n \n   return array_buffer_fun;\n }\n@@ -4823,9 +4882,9 @@ bool Genesis::InstallNatives(GlobalContextType context_type) {\n   }\n \n   // Create a constructor for RegExp results (a variant of Array that\n-  // predefines the two properties index and match).\n+  // predefines the properties index, input, and groups).\n   {\n-    // RegExpResult initial map.\n+    // JSRegExpResult initial map.\n \n     // Find global.Array.prototype to inherit from.\n     Handle<JSFunction> array_constructor(native_context()->array_function());\n@@ -4834,16 +4893,20 @@ bool Genesis::InstallNatives(GlobalContextType context_type) {\n \n     // Add initial map.\n     Handle<Map> initial_map = factory()->NewMap(\n-        JS_ARRAY_TYPE, JSRegExpResult::kSize, TERMINAL_FAST_ELEMENTS_KIND, 2);\n+        JS_ARRAY_TYPE, JSRegExpResult::kSize, TERMINAL_FAST_ELEMENTS_KIND,\n+        JSRegExpResult::kInObjectPropertyCount);\n     initial_map->SetConstructor(*array_constructor);\n \n     // Set prototype on map.\n-    initial_map->set_non_instance_prototype(false);\n+    initial_map->set_has_non_instance_prototype(false);\n     Map::SetPrototype(initial_map, array_prototype);\n \n-    // Update map with length accessor from Array and add \"index\" and \"input\".\n-    Map::EnsureDescriptorSlack(initial_map, 3);\n+    // Update map with length accessor from Array and add \"index\", \"input\" and\n+    // \"groups\".\n+    Map::EnsureDescriptorSlack(initial_map,\n+                               JSRegExpResult::kInObjectPropertyCount + 1);\n \n+    // length descriptor.\n     {\n       JSFunction* array_function = native_context()->array_function();\n       Handle<DescriptorArray> array_descriptors(\n@@ -4857,20 +4920,31 @@ bool Genesis::InstallNatives(GlobalContextType context_type) {\n           array_descriptors->GetDetails(old).attributes());\n       initial_map->AppendDescriptor(&d);\n     }\n+\n+    // index descriptor.\n     {\n       Descriptor d = Descriptor::DataField(factory()->index_string(),\n                                            JSRegExpResult::kIndexIndex, NONE,\n                                            Representation::Tagged());\n       initial_map->AppendDescriptor(&d);\n     }\n \n+    // input descriptor.\n     {\n       Descriptor d = Descriptor::DataField(factory()->input_string(),\n                                            JSRegExpResult::kInputIndex, NONE,\n                                            Representation::Tagged());\n       initial_map->AppendDescriptor(&d);\n     }\n \n+    // groups descriptor.\n+    {\n+      Descriptor d = Descriptor::DataField(factory()->groups_string(),\n+                                           JSRegExpResult::kGroupsIndex, NONE,\n+                                           Representation::Tagged());\n+      initial_map->AppendDescriptor(&d);\n+    }\n+\n     native_context()->set_regexp_result_map(*initial_map);\n   }\n \n@@ -5482,10 +5556,6 @@ Genesis::Genesis(\n \n   ConfigureUtilsObject(context_type);\n \n-  // Check that the script context table is empty except for the 'this' binding.\n-  // We do not need script contexts for native scripts.\n-  DCHECK_EQ(1, native_context()->script_context_table()->used());\n-\n   native_context()->ResetErrorsThrown();\n   result_ = native_context();\n }"
        },
        {
            "sha": "2b2b9c2b340dfae2947faee59193ebc60e8c9d05",
            "filename": "deps/v8/src/builtins/arm/builtins-arm.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 46,
            "changes": 91,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm%2Fbuiltins-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm%2Fbuiltins-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm%2Fbuiltins-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -116,9 +116,9 @@ void Builtins::Generate_InternalArrayConstructor(MacroAssembler* masm) {\n     // Initial map for the builtin InternalArray functions should be maps.\n     __ ldr(r2, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n     __ SmiTst(r2);\n-    __ Assert(ne, kUnexpectedInitialMapForInternalArrayFunction);\n+    __ Assert(ne, AbortReason::kUnexpectedInitialMapForInternalArrayFunction);\n     __ CompareObjectType(r2, r3, r4, MAP_TYPE);\n-    __ Assert(eq, kUnexpectedInitialMapForInternalArrayFunction);\n+    __ Assert(eq, AbortReason::kUnexpectedInitialMapForInternalArrayFunction);\n   }\n \n   // Run the native code for the InternalArray function called as a normal\n@@ -143,9 +143,9 @@ void Builtins::Generate_ArrayConstructor(MacroAssembler* masm) {\n     // Initial map for the builtin Array functions should be maps.\n     __ ldr(r2, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n     __ SmiTst(r2);\n-    __ Assert(ne, kUnexpectedInitialMapForArrayFunction);\n+    __ Assert(ne, AbortReason::kUnexpectedInitialMapForArrayFunction);\n     __ CompareObjectType(r2, r3, r4, MAP_TYPE);\n-    __ Assert(eq, kUnexpectedInitialMapForArrayFunction);\n+    __ Assert(eq, AbortReason::kUnexpectedInitialMapForArrayFunction);\n   }\n \n   __ mov(r3, r1);\n@@ -283,14 +283,16 @@ void Generate_JSConstructStubGeneric(MacroAssembler* masm,\n     Label post_instantiation_deopt_entry, not_create_implicit_receiver;\n \n     // Preserve the incoming parameters on the stack.\n+    __ LoadRoot(r4, Heap::kTheHoleValueRootIndex);\n     __ SmiTag(r0);\n-    __ Push(cp, r0, r1, r3);\n+    __ Push(cp, r0, r1, r4, r3);\n \n     // ----------- S t a t e -------------\n     //  --        sp[0*kPointerSize]: new target\n-    //  -- r1 and sp[1*kPointerSize]: constructor function\n-    //  --        sp[2*kPointerSize]: number of arguments (tagged)\n-    //  --        sp[3*kPointerSize]: context\n+    //  --        sp[1*kPointerSize]: padding\n+    //  -- r1 and sp[2*kPointerSize]: constructor function\n+    //  --        sp[3*kPointerSize]: number of arguments (tagged)\n+    //  --        sp[4*kPointerSize]: context\n     // -----------------------------------\n \n     __ ldr(r4, FieldMemOperand(r1, JSFunction::kSharedFunctionInfoOffset));\n@@ -332,9 +334,10 @@ void Generate_JSConstructStubGeneric(MacroAssembler* masm,\n     //  --                 r3: new target\n     //  -- sp[0*kPointerSize]: implicit receiver\n     //  -- sp[1*kPointerSize]: implicit receiver\n-    //  -- sp[2*kPointerSize]: constructor function\n-    //  -- sp[3*kPointerSize]: number of arguments (tagged)\n-    //  -- sp[4*kPointerSize]: context\n+    //  -- sp[2*kPointerSize]: padding\n+    //  -- sp[3*kPointerSize]: constructor function\n+    //  -- sp[4*kPointerSize]: number of arguments (tagged)\n+    //  -- sp[5*kPointerSize]: context\n     // -----------------------------------\n \n     // Restore constructor function and argument count.\n@@ -355,9 +358,10 @@ void Generate_JSConstructStubGeneric(MacroAssembler* masm,\n     //  --                        r5: counter\n     //  --        sp[0*kPointerSize]: implicit receiver\n     //  --        sp[1*kPointerSize]: implicit receiver\n-    //  -- r1 and sp[2*kPointerSize]: constructor function\n-    //  --        sp[3*kPointerSize]: number of arguments (tagged)\n-    //  --        sp[4*kPointerSize]: context\n+    //  --        sp[2*kPointerSize]: padding\n+    //  -- r1 and sp[3*kPointerSize]: constructor function\n+    //  --        sp[4*kPointerSize]: number of arguments (tagged)\n+    //  --        sp[5*kPointerSize]: context\n     // -----------------------------------\n     __ b(&entry);\n \n@@ -375,9 +379,10 @@ void Generate_JSConstructStubGeneric(MacroAssembler* masm,\n     // ----------- S t a t e -------------\n     //  --                 r0: constructor result\n     //  -- sp[0*kPointerSize]: implicit receiver\n-    //  -- sp[1*kPointerSize]: constructor function\n-    //  -- sp[2*kPointerSize]: number of arguments\n-    //  -- sp[3*kPointerSize]: context\n+    //  -- sp[1*kPointerSize]: padding\n+    //  -- sp[2*kPointerSize]: constructor function\n+    //  -- sp[3*kPointerSize]: number of arguments\n+    //  -- sp[4*kPointerSize]: context\n     // -----------------------------------\n \n     // Store offset of return address for deoptimizer.\n@@ -541,7 +546,7 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n     __ ldr(r3, FieldMemOperand(r4, JSFunction::kSharedFunctionInfoOffset));\n     __ ldr(r3, FieldMemOperand(r3, SharedFunctionInfo::kFunctionDataOffset));\n     __ CompareObjectType(r3, r3, r3, BYTECODE_ARRAY_TYPE);\n-    __ Assert(eq, kMissingBytecodeArray);\n+    __ Assert(eq, AbortReason::kMissingBytecodeArray);\n   }\n \n   // Resume (Ignition/TurboFan) generator object.\n@@ -629,8 +634,6 @@ static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,\n     __ mov(cp, Operand(context_address));\n     __ ldr(cp, MemOperand(cp));\n \n-    __ InitializeRootRegister();\n-\n     // Push the function and the receiver onto the stack.\n     __ Push(r1, r2);\n \n@@ -776,6 +779,9 @@ static void MaybeTailCallOptimizedCodeSlot(MacroAssembler* masm,\n            Operand(Smi::FromEnum(OptimizationMarker::kNone)));\n     __ b(eq, &fallthrough);\n \n+    TailCallRuntimeIfMarkerEquals(masm, optimized_code_entry,\n+                                  OptimizationMarker::kLogFirstExecution,\n+                                  Runtime::kFunctionFirstExecution);\n     TailCallRuntimeIfMarkerEquals(masm, optimized_code_entry,\n                                   OptimizationMarker::kCompileOptimized,\n                                   Runtime::kCompileOptimized_NotConcurrent);\n@@ -791,7 +797,7 @@ static void MaybeTailCallOptimizedCodeSlot(MacroAssembler* masm,\n         __ cmp(\n             optimized_code_entry,\n             Operand(Smi::FromEnum(OptimizationMarker::kInOptimizationQueue)));\n-        __ Assert(eq, kExpectedOptimizationSentinel);\n+        __ Assert(eq, AbortReason::kExpectedOptimizationSentinel);\n       }\n       __ jmp(&fallthrough);\n     }\n@@ -871,7 +877,6 @@ static void AdvanceBytecodeOffset(MacroAssembler* masm, Register bytecode_array,\n   __ ldrb(bytecode, MemOperand(bytecode_array, bytecode_offset));\n   __ add(bytecode_size_table, bytecode_size_table,\n          Operand(2 * kIntSize * interpreter::Bytecodes::kBytecodeCount));\n-  __ jmp(&load_size);\n \n   // Load the size of the current bytecode.\n   __ bind(&load_size);\n@@ -935,10 +940,12 @@ void Builtins::Generate_InterpreterEntryTrampoline(MacroAssembler* masm) {\n   // Check function data field is actually a BytecodeArray object.\n   if (FLAG_debug_code) {\n     __ SmiTst(kInterpreterBytecodeArrayRegister);\n-    __ Assert(ne, kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n+    __ Assert(\n+        ne, AbortReason::kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n     __ CompareObjectType(kInterpreterBytecodeArrayRegister, r0, no_reg,\n                          BYTECODE_ARRAY_TYPE);\n-    __ Assert(eq, kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n+    __ Assert(\n+        eq, AbortReason::kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n   }\n \n   // Reset code age.\n@@ -1194,10 +1201,12 @@ static void Generate_InterpreterEnterBytecode(MacroAssembler* masm) {\n   if (FLAG_debug_code) {\n     // Check function data field is actually a BytecodeArray object.\n     __ SmiTst(kInterpreterBytecodeArrayRegister);\n-    __ Assert(ne, kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n+    __ Assert(\n+        ne, AbortReason::kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n     __ CompareObjectType(kInterpreterBytecodeArrayRegister, r1, no_reg,\n                          BYTECODE_ARRAY_TYPE);\n-    __ Assert(eq, kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n+    __ Assert(\n+        eq, AbortReason::kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n   }\n \n   // Get the target bytecode offset from the frame.\n@@ -1259,7 +1268,7 @@ void Builtins::Generate_CheckOptimizationMarker(MacroAssembler* masm) {\n   // The feedback vector must be defined.\n   if (FLAG_debug_code) {\n     __ CompareRoot(feedback_vector, Heap::kUndefinedValueRootIndex);\n-    __ Assert(ne, BailoutReason::kExpectedFeedbackVector);\n+    __ Assert(ne, AbortReason::kExpectedFeedbackVector);\n   }\n \n   // Is there an optimization marker or optimized code in the feedback vector?\n@@ -1799,8 +1808,9 @@ static void EnterArgumentsAdaptorFrame(MacroAssembler* masm) {\n   __ mov(r4, Operand(StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR)));\n   __ stm(db_w, sp, r0.bit() | r1.bit() | r4.bit() |\n                        fp.bit() | lr.bit());\n+  __ Push(Smi::kZero);  // Padding.\n   __ add(fp, sp,\n-         Operand(StandardFrameConstants::kFixedFrameSizeFromFp + kPointerSize));\n+         Operand(ArgumentsAdaptorFrameConstants::kFixedFrameSizeFromFp));\n }\n \n static void LeaveArgumentsAdaptorFrame(MacroAssembler* masm) {\n@@ -1809,8 +1819,7 @@ static void LeaveArgumentsAdaptorFrame(MacroAssembler* masm) {\n   // -----------------------------------\n   // Get the number of arguments passed (as a smi), tear down the frame and\n   // then tear down the parameters.\n-  __ ldr(r1, MemOperand(fp, -(StandardFrameConstants::kFixedFrameSizeFromFp +\n-                              kPointerSize)));\n+  __ ldr(r1, MemOperand(fp, ArgumentsAdaptorFrameConstants::kLengthOffset));\n \n   __ LeaveFrame(StackFrame::ARGUMENTS_ADAPTOR);\n   __ add(sp, sp, Operand::PointerOffsetFromSmiKey(r1));\n@@ -1889,7 +1898,7 @@ void Builtins::Generate_CallOrConstructForwardVarargs(MacroAssembler* masm,\n     __ JumpIfSmi(r3, &new_target_not_constructor);\n     __ ldr(scratch, FieldMemOperand(r3, HeapObject::kMapOffset));\n     __ ldrb(scratch, FieldMemOperand(scratch, Map::kBitFieldOffset));\n-    __ tst(scratch, Operand(1 << Map::kIsConstructor));\n+    __ tst(scratch, Operand(Map::IsConstructorBit::kMask));\n     __ b(ne, &new_target_constructor);\n     __ bind(&new_target_not_constructor);\n     {\n@@ -2178,7 +2187,7 @@ void Builtins::Generate_Call(MacroAssembler* masm, ConvertReceiverMode mode) {\n \n   // Check if target has a [[Call]] internal method.\n   __ ldrb(r4, FieldMemOperand(r4, Map::kBitFieldOffset));\n-  __ tst(r4, Operand(1 << Map::kIsCallable));\n+  __ tst(r4, Operand(Map::IsCallableBit::kMask));\n   __ b(eq, &non_callable);\n \n   // Check if target is a proxy and call CallProxy external builtin\n@@ -2268,7 +2277,7 @@ void Builtins::Generate_Construct(MacroAssembler* masm) {\n \n   // Check if target has a [[Construct]] internal method.\n   __ ldrb(r2, FieldMemOperand(r4, Map::kBitFieldOffset));\n-  __ tst(r2, Operand(1 << Map::kIsConstructor));\n+  __ tst(r2, Operand(Map::IsConstructorBit::kMask));\n   __ b(eq, &non_constructor);\n \n   // Only dispatch to bound functions after checking whether they are\n@@ -2337,17 +2346,6 @@ void Builtins::Generate_Abort(MacroAssembler* masm) {\n   __ TailCallRuntime(Runtime::kAbort);\n }\n \n-// static\n-void Builtins::Generate_AbortJS(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- r1 : message as String object\n-  //  -- lr : return address\n-  // -----------------------------------\n-  __ Push(r1);\n-  __ Move(cp, Smi::kZero);\n-  __ TailCallRuntime(Runtime::kAbortJS);\n-}\n-\n void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- r0 : actual number of arguments\n@@ -2434,8 +2432,9 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n     __ LoadRoot(scratch, Heap::kUndefinedValueRootIndex);\n     __ sub(r4, fp, Operand(r2, LSL, kPointerSizeLog2));\n     // Adjust for frame.\n-    __ sub(r4, r4, Operand(StandardFrameConstants::kFixedFrameSizeFromFp +\n-                           2 * kPointerSize));\n+    __ sub(r4, r4,\n+           Operand(ArgumentsAdaptorFrameConstants::kFixedFrameSizeFromFp +\n+                   kPointerSize));\n \n     Label fill;\n     __ bind(&fill);"
        },
        {
            "sha": "dd92af89bb0dc1a6e3ab1e58d0b389d6eea3119c",
            "filename": "deps/v8/src/builtins/arm64/builtins-arm64.cc",
            "status": "modified",
            "additions": 365,
            "deletions": 222,
            "changes": 587,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm64%2Fbuiltins-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm64%2Fbuiltins-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm64%2Fbuiltins-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -111,9 +111,9 @@ void Builtins::Generate_InternalArrayConstructor(MacroAssembler* masm) {\n     // Initial map for the builtin InternalArray functions should be maps.\n     __ Ldr(x10, FieldMemOperand(x1, JSFunction::kPrototypeOrInitialMapOffset));\n     __ Tst(x10, kSmiTagMask);\n-    __ Assert(ne, kUnexpectedInitialMapForInternalArrayFunction);\n+    __ Assert(ne, AbortReason::kUnexpectedInitialMapForInternalArrayFunction);\n     __ CompareObjectType(x10, x11, x12, MAP_TYPE);\n-    __ Assert(eq, kUnexpectedInitialMapForInternalArrayFunction);\n+    __ Assert(eq, AbortReason::kUnexpectedInitialMapForInternalArrayFunction);\n   }\n \n   // Run the native code for the InternalArray function called as a normal\n@@ -138,9 +138,9 @@ void Builtins::Generate_ArrayConstructor(MacroAssembler* masm) {\n     // Initial map for the builtin Array functions should be maps.\n     __ Ldr(x10, FieldMemOperand(x1, JSFunction::kPrototypeOrInitialMapOffset));\n     __ Tst(x10, kSmiTagMask);\n-    __ Assert(ne, kUnexpectedInitialMapForArrayFunction);\n+    __ Assert(ne, AbortReason::kUnexpectedInitialMapForArrayFunction);\n     __ CompareObjectType(x10, x11, x12, MAP_TYPE);\n-    __ Assert(eq, kUnexpectedInitialMapForArrayFunction);\n+    __ Assert(eq, AbortReason::kUnexpectedInitialMapForArrayFunction);\n   }\n \n   // Run the native code for the Array function called as a normal function.\n@@ -210,7 +210,7 @@ void Generate_JSBuiltinsConstructStubHelper(MacroAssembler* masm) {\n       // Check that FrameScope pushed the context on to the stack already.\n       __ Peek(x2, 0);\n       __ Cmp(x2, cp);\n-      __ Check(eq, kUnexpectedValue);\n+      __ Check(eq, AbortReason::kUnexpectedValue);\n     }\n \n     // Push number of arguments.\n@@ -315,7 +315,7 @@ void Generate_JSConstructStubGeneric(MacroAssembler* masm,\n       // Check that FrameScope pushed the context on to the stack already.\n       __ Peek(x2, 0);\n       __ Cmp(x2, cp);\n-      __ Check(eq, kUnexpectedValue);\n+      __ Check(eq, AbortReason::kUnexpectedValue);\n     }\n \n     // Preserve the incoming parameters on the stack.\n@@ -348,10 +348,11 @@ void Generate_JSConstructStubGeneric(MacroAssembler* masm,\n \n     // ----------- S t a t e -------------\n     //  --                          x0: receiver\n-    //  -- Slot 3 / sp[0*kPointerSize]: new target\n-    //  -- Slot 2 / sp[1*kPointerSize]: constructor function\n-    //  -- Slot 1 / sp[2*kPointerSize]: number of arguments (tagged)\n-    //  -- Slot 0 / sp[3*kPointerSize]: context\n+    //  -- Slot 4 / sp[0*kPointerSize]: new target\n+    //  -- Slot 3 / sp[1*kPointerSize]: padding\n+    //  -- Slot 2 / sp[2*kPointerSize]: constructor function\n+    //  -- Slot 1 / sp[3*kPointerSize]: number of arguments (tagged)\n+    //  -- Slot 0 / sp[4*kPointerSize]: context\n     // -----------------------------------\n     // Deoptimizer enters here.\n     masm->isolate()->heap()->SetConstructStubCreateDeoptPCOffset(\n@@ -388,9 +389,10 @@ void Generate_JSConstructStubGeneric(MacroAssembler* masm,\n     //  --        sp[0*kPointerSize]: implicit receiver (overwrite if argc odd)\n     //  --        sp[1*kPointerSize]: implicit receiver\n     //  --        sp[2*kPointerSize]: implicit receiver\n-    //  -- x1 and sp[3*kPointerSize]: constructor function\n-    //  --        sp[4*kPointerSize]: number of arguments (tagged)\n-    //  --        sp[5*kPointerSize]: context\n+    //  --        sp[3*kPointerSize]: padding\n+    //  -- x1 and sp[4*kPointerSize]: constructor function\n+    //  --        sp[5*kPointerSize]: number of arguments (tagged)\n+    //  --        sp[6*kPointerSize]: context\n     // -----------------------------------\n \n     // Round the number of arguments down to the next even number, and claim\n@@ -416,14 +418,8 @@ void Generate_JSConstructStubGeneric(MacroAssembler* masm,\n     __ InvokeFunction(x1, x3, actual, CALL_FUNCTION);\n \n     // ----------- S t a t e -------------\n-    // If argc is odd:\n-    //  -- sp[0*kPointerSize]: implicit receiver\n-    //  -- sp[1*kPointerSize]: constructor function\n-    //  -- sp[2*kPointerSize]: number of arguments\n-    //  -- sp[3*kPointerSize]: context\n-    // If argc is even:\n     //  -- sp[0*kPointerSize]: implicit receiver\n-    //  -- sp[1*kPointerSize]: implicit receiver\n+    //  -- sp[1*kPointerSize]: padding\n     //  -- sp[2*kPointerSize]: constructor function\n     //  -- sp[3*kPointerSize]: number of arguments\n     //  -- sp[4*kPointerSize]: context\n@@ -556,18 +552,23 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n   // Check the stack for overflow. We are not trying to catch interruptions\n   // (i.e. debug break and preemption) here, so check the \"real stack limit\".\n   Label stack_overflow;\n-  __ CompareRoot(jssp, Heap::kRealStackLimitRootIndex);\n+  __ CompareRoot(__ StackPointer(), Heap::kRealStackLimitRootIndex);\n   __ B(lo, &stack_overflow);\n \n   // Get number of arguments for generator function.\n   __ Ldr(x10, FieldMemOperand(x4, JSFunction::kSharedFunctionInfoOffset));\n   __ Ldr(w10,\n          FieldMemOperand(x10, SharedFunctionInfo::kFormalParameterCountOffset));\n \n-  // Claim slots for arguments and receiver.\n-  __ Add(x11, x10, 1);\n+  // Claim slots for arguments and receiver (rounded up to a multiple of two).\n+  __ Add(x11, x10, 2);\n+  __ Bic(x11, x11, 1);\n   __ Claim(x11);\n \n+  // Store padding (which might be replaced by the receiver).\n+  __ Sub(x11, x11, 1);\n+  __ Poke(padreg, Operand(x11, LSL, kPointerSizeLog2));\n+\n   // Poke receiver into highest claimed slot.\n   __ Ldr(x5, FieldMemOperand(x1, JSGeneratorObject::kReceiverOffset));\n   __ Poke(x5, Operand(x10, LSL, kPointerSizeLog2));\n@@ -578,8 +579,8 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n   //  -- x10                      : argument count\n   //  -- cp                       : generator context\n   //  -- lr                       : return address\n-  //  -- jssp[arg count]          : generator receiver\n-  //  -- jssp[0 .. arg count - 1] : claimed for args\n+  //  -- sp[arg count]            : generator receiver\n+  //  -- sp[0 .. arg count - 1]   : claimed for args\n   // -----------------------------------\n \n   // Push holes for arguments to generator function. Since the parser forced\n@@ -603,7 +604,7 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n     __ Ldr(x3, FieldMemOperand(x4, JSFunction::kSharedFunctionInfoOffset));\n     __ Ldr(x3, FieldMemOperand(x3, SharedFunctionInfo::kFunctionDataOffset));\n     __ CompareObjectType(x3, x3, x3, BYTECODE_ARRAY_TYPE);\n-    __ Assert(eq, kMissingBytecodeArray);\n+    __ Assert(eq, AbortReason::kMissingBytecodeArray);\n   }\n \n   // Resume (Ignition/TurboFan) generator object.\n@@ -624,20 +625,20 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n   __ Bind(&prepare_step_in_if_stepping);\n   {\n     FrameScope scope(masm, StackFrame::INTERNAL);\n-    __ Push(x1);\n+    __ Push(x1, padreg);\n     __ PushArgument(x4);\n     __ CallRuntime(Runtime::kDebugOnFunctionCall);\n-    __ Pop(x1);\n+    __ Pop(padreg, x1);\n     __ Ldr(x4, FieldMemOperand(x1, JSGeneratorObject::kFunctionOffset));\n   }\n   __ B(&stepping_prepared);\n \n   __ Bind(&prepare_step_in_suspended_generator);\n   {\n     FrameScope scope(masm, StackFrame::INTERNAL);\n-    __ Push(x1);\n+    __ Push(x1, padreg);\n     __ CallRuntime(Runtime::kDebugPrepareStepInSuspendedGenerator);\n-    __ Pop(x1);\n+    __ Pop(padreg, x1);\n     __ Ldr(x4, FieldMemOperand(x1, JSGeneratorObject::kFunctionOffset));\n   }\n   __ B(&stepping_prepared);\n@@ -652,8 +653,6 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n \n static void Generate_StackOverflowCheck(MacroAssembler* masm, Register num_args,\n                                         Label* stack_overflow) {\n-  DCHECK(masm->StackPointer().Is(jssp));\n-\n   UseScratchRegisterScope temps(masm);\n   Register scratch = temps.AcquireX();\n \n@@ -767,10 +766,10 @@ static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,\n     __ Mov(x23, x19);\n     __ Mov(x24, x19);\n     __ Mov(x25, x19);\n+    __ Mov(x28, x19);\n     // Don't initialize the reserved registers.\n     // x26 : root register (root).\n     // x27 : context pointer (cp).\n-    // x28 : JS stack pointer (jssp).\n     // x29 : frame pointer (fp).\n \n     Handle<Code> builtin = is_construct\n@@ -820,7 +819,7 @@ static void LeaveInterpreterFrame(MacroAssembler* masm, Register scratch) {\n   // Drop receiver + arguments.\n   if (__ emit_debug_code()) {\n     __ Tst(args_size, kPointerSize - 1);\n-    __ Check(eq, kUnexpectedValue);\n+    __ Check(eq, AbortReason::kUnexpectedValue);\n   }\n   __ Lsr(args_size, args_size, kPointerSizeLog2);\n   __ DropArguments(args_size);\n@@ -872,6 +871,9 @@ static void MaybeTailCallOptimizedCodeSlot(MacroAssembler* masm,\n                         Operand(Smi::FromEnum(OptimizationMarker::kNone)), eq,\n                         &fallthrough);\n \n+    TailCallRuntimeIfMarkerEquals(masm, optimized_code_entry,\n+                                  OptimizationMarker::kLogFirstExecution,\n+                                  Runtime::kFunctionFirstExecution);\n     TailCallRuntimeIfMarkerEquals(masm, optimized_code_entry,\n                                   OptimizationMarker::kCompileOptimized,\n                                   Runtime::kCompileOptimized_NotConcurrent);\n@@ -887,7 +889,7 @@ static void MaybeTailCallOptimizedCodeSlot(MacroAssembler* masm,\n         __ Cmp(\n             optimized_code_entry,\n             Operand(Smi::FromEnum(OptimizationMarker::kInOptimizationQueue)));\n-        __ Assert(eq, kExpectedOptimizationSentinel);\n+        __ Assert(eq, AbortReason::kExpectedOptimizationSentinel);\n       }\n       __ B(&fallthrough);\n     }\n@@ -967,7 +969,6 @@ static void AdvanceBytecodeOffset(MacroAssembler* masm, Register bytecode_array,\n   __ Ldrb(bytecode, MemOperand(bytecode_array, bytecode_offset));\n   __ Add(bytecode_size_table, bytecode_size_table,\n          Operand(2 * kIntSize * interpreter::Bytecodes::kBytecodeCount));\n-  __ B(&load_size);\n \n   // Load the size of the current bytecode.\n   __ Bind(&load_size);\n@@ -985,7 +986,6 @@ static void AdvanceBytecodeOffset(MacroAssembler* masm, Register bytecode_array,\n //   - x3: the incoming new target or generator object\n //   - cp: our context.\n //   - fp: our caller's frame pointer.\n-//   - jssp: stack pointer.\n //   - lr: return address.\n //\n // The function builds an interpreter frame.  See InterpreterFrameConstants in\n@@ -1009,7 +1009,7 @@ void Builtins::Generate_InterpreterEntryTrampoline(MacroAssembler* masm) {\n   // the frame (that is done below).\n   FrameScope frame_scope(masm, StackFrame::MANUAL);\n   __ Push(lr, fp, cp, closure);\n-  __ Add(fp, jssp, StandardFrameConstants::kFixedFrameSizeFromFp);\n+  __ Add(fp, __ StackPointer(), StandardFrameConstants::kFixedFrameSizeFromFp);\n \n   // Get the bytecode array from the function object (or from the DebugInfo if\n   // it is present) and load it into kInterpreterBytecodeArrayRegister.\n@@ -1030,11 +1030,13 @@ void Builtins::Generate_InterpreterEntryTrampoline(MacroAssembler* masm) {\n \n   // Check function data field is actually a BytecodeArray object.\n   if (FLAG_debug_code) {\n-    __ AssertNotSmi(kInterpreterBytecodeArrayRegister,\n-                    kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n+    __ AssertNotSmi(\n+        kInterpreterBytecodeArrayRegister,\n+        AbortReason::kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n     __ CompareObjectType(kInterpreterBytecodeArrayRegister, x0, x0,\n                          BYTECODE_ARRAY_TYPE);\n-    __ Assert(eq, kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n+    __ Assert(\n+        eq, AbortReason::kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n   }\n \n   // Reset code age.\n@@ -1058,8 +1060,7 @@ void Builtins::Generate_InterpreterEntryTrampoline(MacroAssembler* masm) {\n \n     // Do a stack check to ensure we don't go over the limit.\n     Label ok;\n-    DCHECK(jssp.Is(__ StackPointer()));\n-    __ Sub(x10, jssp, Operand(x11));\n+    __ Sub(x10, __ StackPointer(), Operand(x11));\n     __ CompareRoot(x10, Heap::kRealStackLimitRootIndex);\n     __ B(hs, &ok);\n     __ CallRuntime(Runtime::kThrowStackOverflow);\n@@ -1181,10 +1182,19 @@ static void Generate_InterpreterPushArgs(MacroAssembler* masm,\n   __ Unreachable();\n   __ Bind(&done);\n \n-  // TODO(arm64): Claim one extra slot for padding and store padreg to the\n-  // padding slot.\n+  // Round up to an even number of slots and claim them.\n+  __ Add(slots_to_claim, slots_to_claim, 1);\n+  __ Bic(slots_to_claim, slots_to_claim, 1);\n   __ Claim(slots_to_claim);\n \n+  {\n+    // Store padding, which may be overwritten.\n+    UseScratchRegisterScope temps(masm);\n+    Register scratch = temps.AcquireX();\n+    __ Sub(scratch, slots_to_claim, 1);\n+    __ Poke(padreg, Operand(scratch, LSL, kPointerSizeLog2));\n+  }\n+\n   if (receiver_mode == ConvertReceiverMode::kNullOrUndefined) {\n     // Store \"undefined\" as the receiver arg if we need to.\n     Register receiver = x14;\n@@ -1311,11 +1321,13 @@ static void Generate_InterpreterEnterBytecode(MacroAssembler* masm) {\n \n   if (FLAG_debug_code) {\n     // Check function data field is actually a BytecodeArray object.\n-    __ AssertNotSmi(kInterpreterBytecodeArrayRegister,\n-                    kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n+    __ AssertNotSmi(\n+        kInterpreterBytecodeArrayRegister,\n+        AbortReason::kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n     __ CompareObjectType(kInterpreterBytecodeArrayRegister, x1, x1,\n                          BYTECODE_ARRAY_TYPE);\n-    __ Assert(eq, kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n+    __ Assert(\n+        eq, AbortReason::kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry);\n   }\n \n   // Get the target bytecode offset from the frame.\n@@ -1375,7 +1387,7 @@ void Builtins::Generate_CheckOptimizationMarker(MacroAssembler* masm) {\n   // The feedback vector must be defined.\n   if (FLAG_debug_code) {\n     __ CompareRoot(feedback_vector, Heap::kUndefinedValueRootIndex);\n-    __ Assert(ne, BailoutReason::kExpectedFeedbackVector);\n+    __ Assert(ne, AbortReason::kExpectedFeedbackVector);\n   }\n \n   // Is there an optimization marker or optimized code in the feedback vector?\n@@ -1634,7 +1646,7 @@ void Generate_ContinueToBuiltinHelper(MacroAssembler* masm,\n                        kPointerSize;\n \n   // Set up frame pointer.\n-  __ Add(fp, jssp, frame_size);\n+  __ Add(fp, __ StackPointer(), frame_size);\n \n   if (with_result) {\n     // Overwrite the hole inserted by the deoptimizer with the return value from\n@@ -1770,9 +1782,9 @@ void Builtins::Generate_InterpreterOnStackReplacement(MacroAssembler* masm) {\n void Builtins::Generate_FunctionPrototypeApply(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- x0       : argc\n-  //  -- jssp[0]  : argArray (if argc == 2)\n-  //  -- jssp[8]  : thisArg  (if argc >= 1)\n-  //  -- jssp[16] : receiver\n+  //  -- sp[0]    : argArray (if argc == 2)\n+  //  -- sp[8]    : thisArg  (if argc >= 1)\n+  //  -- sp[16]   : receiver\n   // -----------------------------------\n   ASM_LOCATION(\"Builtins::Generate_FunctionPrototypeApply\");\n \n@@ -1824,7 +1836,7 @@ void Builtins::Generate_FunctionPrototypeApply(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- x2      : argArray\n   //  -- x1      : receiver\n-  //  -- jssp[0] : thisArg\n+  //  -- sp[0]   : thisArg\n   // -----------------------------------\n \n   // 2. We don't need to check explicitly for callable receiver here,\n@@ -1855,55 +1867,65 @@ void Builtins::Generate_FunctionPrototypeApply(MacroAssembler* masm) {\n void Builtins::Generate_FunctionPrototypeCall(MacroAssembler* masm) {\n   Register argc = x0;\n   Register function = x1;\n-  Register scratch1 = x10;\n-  Register scratch2 = x11;\n \n   ASM_LOCATION(\"Builtins::Generate_FunctionPrototypeCall\");\n \n-  // 1. Make sure we have at least one argument.\n+  // 1. Get the callable to call (passed as receiver) from the stack.\n+  __ Peek(function, Operand(argc, LSL, kXRegSizeLog2));\n+\n+  // 2. Handle case with no arguments.\n   {\n-    Label done;\n-    __ Cbnz(argc, &done);\n-    __ LoadRoot(scratch1, Heap::kUndefinedValueRootIndex);\n-    __ Push(scratch1);\n-    __ Mov(argc, 1);\n-    __ Bind(&done);\n+    Label non_zero;\n+    Register scratch = x10;\n+    __ Cbnz(argc, &non_zero);\n+    __ LoadRoot(scratch, Heap::kUndefinedValueRootIndex);\n+    // Overwrite receiver with undefined, which will be the new receiver.\n+    // We do not need to overwrite the padding slot above it with anything.\n+    __ Poke(scratch, 0);\n+    // Call function. The argument count is already zero.\n+    __ Jump(masm->isolate()->builtins()->Call(), RelocInfo::CODE_TARGET);\n+    __ Bind(&non_zero);\n   }\n \n-  // 2. Get the callable to call (passed as receiver) from the stack.\n-  __ Peek(function, Operand(argc, LSL, kXRegSizeLog2));\n+  // 3. Overwrite the receiver with padding. If argc is odd, this is all we\n+  //    need to do.\n+  Label arguments_ready;\n+  __ Poke(padreg, Operand(argc, LSL, kXRegSizeLog2));\n+  __ Tbnz(argc, 0, &arguments_ready);\n \n-  // 3. Shift arguments and return address one slot down on the stack\n-  //    (overwriting the original receiver).  Adjust argument count to make\n-  //    the original first argument the new receiver.\n+  // 4. If argc is even:\n+  //    Copy arguments two slots higher in memory, overwriting the original\n+  //    receiver and padding.\n   {\n     Label loop;\n-    // Calculate the copy start address (destination). Copy end address is jssp.\n-    __ SlotAddress(scratch2, argc);\n-    __ Sub(scratch1, scratch2, kPointerSize);\n-\n-    __ Bind(&loop);\n-    __ Ldr(x12, MemOperand(scratch1, -kPointerSize, PostIndex));\n-    __ Str(x12, MemOperand(scratch2, -kPointerSize, PostIndex));\n-    __ Cmp(scratch1, jssp);\n-    __ B(ge, &loop);\n-    // Adjust the actual number of arguments and remove the top element\n-    // (which is a copy of the last argument).\n-    __ Sub(argc, argc, 1);\n-    __ Drop(1);\n+    Register copy_from = x10;\n+    Register copy_to = x11;\n+    Register count = x12;\n+    Register last_arg_slot = x13;\n+    __ Mov(count, argc);\n+    __ Sub(last_arg_slot, argc, 1);\n+    __ SlotAddress(copy_from, last_arg_slot);\n+    __ Add(copy_to, copy_from, 2 * kPointerSize);\n+    __ CopyDoubleWords(copy_to, copy_from, count,\n+                       TurboAssembler::kSrcLessThanDst);\n+    // Drop two slots. These are copies of the last two arguments.\n+    __ Drop(2);\n   }\n \n-  // 4. Call the callable.\n+  // 5. Adjust argument count to make the original first argument the new\n+  //    receiver and call the callable.\n+  __ Bind(&arguments_ready);\n+  __ Sub(argc, argc, 1);\n   __ Jump(masm->isolate()->builtins()->Call(), RelocInfo::CODE_TARGET);\n }\n \n void Builtins::Generate_ReflectApply(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- x0       : argc\n-  //  -- jssp[0]  : argumentsList (if argc == 3)\n-  //  -- jssp[8]  : thisArgument  (if argc >= 2)\n-  //  -- jssp[16] : target        (if argc >= 1)\n-  //  -- jssp[24] : receiver\n+  //  -- sp[0]    : argumentsList (if argc == 3)\n+  //  -- sp[8]    : thisArgument  (if argc >= 2)\n+  //  -- sp[16]   : target        (if argc >= 1)\n+  //  -- sp[24]   : receiver\n   // -----------------------------------\n   ASM_LOCATION(\"Builtins::Generate_ReflectApply\");\n \n@@ -1962,7 +1984,7 @@ void Builtins::Generate_ReflectApply(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- x2      : argumentsList\n   //  -- x1      : target\n-  //  -- jssp[0] : thisArgument\n+  //  -- sp[0]   : thisArgument\n   // -----------------------------------\n \n   // 2. We don't need to check explicitly for callable target here,\n@@ -1977,10 +1999,10 @@ void Builtins::Generate_ReflectApply(MacroAssembler* masm) {\n void Builtins::Generate_ReflectConstruct(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- x0       : argc\n-  //  -- jssp[0]  : new.target (optional)\n-  //  -- jssp[8]  : argumentsList\n-  //  -- jssp[16] : target\n-  //  -- jssp[24] : receiver\n+  //  -- sp[0]    : new.target (optional)\n+  //  -- sp[8]    : argumentsList\n+  //  -- sp[16]   : target\n+  //  -- sp[24]   : receiver\n   // -----------------------------------\n   ASM_LOCATION(\"Builtins::Generate_ReflectConstruct\");\n \n@@ -2044,7 +2066,7 @@ void Builtins::Generate_ReflectConstruct(MacroAssembler* masm) {\n   //  -- x2      : argumentsList\n   //  -- x1      : target\n   //  -- x3      : new.target\n-  //  -- jssp[0] : receiver (undefined)\n+  //  -- sp[0]   : receiver (undefined)\n   // -----------------------------------\n \n   // 2. We don't need to check explicitly for constructor target here,\n@@ -2060,32 +2082,94 @@ void Builtins::Generate_ReflectConstruct(MacroAssembler* masm) {\n           RelocInfo::CODE_TARGET);\n }\n \n-static void EnterArgumentsAdaptorFrame(MacroAssembler* masm) {\n+namespace {\n+\n+void EnterArgumentsAdaptorFrame(MacroAssembler* masm) {\n   __ Push(lr, fp);\n   __ Mov(x11, StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR));\n   __ Push(x11, x1);  // x1: function\n-  // We do not yet push the number of arguments, to maintain a 16-byte aligned\n-  // stack pointer. This is done in step (3) in\n-  // Generate_ArgumentsAdaptorTrampoline.\n-  __ Add(fp, jssp, StandardFrameConstants::kFixedFrameSizeFromFp);\n+  __ SmiTag(x11, x0);  // x0: number of arguments.\n+  __ Push(x11, padreg);\n+  __ Add(fp, __ StackPointer(),\n+         ArgumentsAdaptorFrameConstants::kFixedFrameSizeFromFp);\n }\n \n-static void LeaveArgumentsAdaptorFrame(MacroAssembler* masm) {\n+void LeaveArgumentsAdaptorFrame(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- x0 : result being passed through\n   // -----------------------------------\n   // Get the number of arguments passed (as a smi), tear down the frame and\n   // then drop the parameters and the receiver.\n-  __ Ldr(x10, MemOperand(fp, -(StandardFrameConstants::kFixedFrameSizeFromFp +\n-                               kPointerSize)));\n-  __ Mov(jssp, fp);\n+  __ Ldr(x10, MemOperand(fp, ArgumentsAdaptorFrameConstants::kLengthOffset));\n+  __ Mov(__ StackPointer(), fp);\n   __ Pop(fp, lr);\n \n   // Drop actual parameters and receiver.\n   __ SmiUntag(x10);\n   __ DropArguments(x10, TurboAssembler::kCountExcludesReceiver);\n }\n \n+// Prepares the stack for copying the varargs. First we claim the necessary\n+// slots, taking care of potential padding. Then we copy the existing arguments\n+// one slot up or one slot down, as needed.\n+void Generate_PrepareForCopyingVarargs(MacroAssembler* masm, Register argc,\n+                                       Register len) {\n+  Label len_odd, exit;\n+  Register slots_to_copy = x10;  // If needed.\n+  __ Add(slots_to_copy, argc, 1);\n+  __ Add(argc, argc, len);\n+  __ Tbnz(len, 0, &len_odd);\n+  __ Claim(len);\n+  __ B(&exit);\n+\n+  __ Bind(&len_odd);\n+  // Claim space we need. If argc is even, slots_to_claim = len + 1, as we need\n+  // one extra padding slot. If argc is odd, we know that the original arguments\n+  // will have a padding slot we can reuse (since len is odd), so\n+  // slots_to_claim = len - 1.\n+  {\n+    Register scratch = x11;\n+    Register slots_to_claim = x12;\n+    __ Add(slots_to_claim, len, 1);\n+    __ And(scratch, argc, 1);\n+    __ Sub(slots_to_claim, slots_to_claim, Operand(scratch, LSL, 1));\n+    __ Claim(slots_to_claim);\n+  }\n+\n+  Label copy_down;\n+  __ Tbz(slots_to_copy, 0, &copy_down);\n+\n+  // Copy existing arguments one slot up.\n+  {\n+    Register src = x11;\n+    Register dst = x12;\n+    Register scratch = x13;\n+    __ Sub(scratch, argc, 1);\n+    __ SlotAddress(src, scratch);\n+    __ SlotAddress(dst, argc);\n+    __ CopyDoubleWords(dst, src, slots_to_copy,\n+                       TurboAssembler::kSrcLessThanDst);\n+  }\n+  __ B(&exit);\n+\n+  // Copy existing arguments one slot down and add padding.\n+  __ Bind(&copy_down);\n+  {\n+    Register src = x11;\n+    Register dst = x12;\n+    Register scratch = x13;\n+    __ Add(src, len, 1);\n+    __ Mov(dst, len);  // CopySlots will corrupt dst.\n+    __ CopySlots(dst, src, slots_to_copy);\n+    __ Add(scratch, argc, 1);\n+    __ Poke(padreg, Operand(scratch, LSL, kPointerSizeLog2));  // Store padding.\n+  }\n+\n+  __ Bind(&exit);\n+}\n+\n+}  // namespace\n+\n // static\n void Builtins::Generate_CallOrConstructVarargs(MacroAssembler* masm,\n                                                Handle<Code> code) {\n@@ -2118,30 +2202,34 @@ void Builtins::Generate_CallOrConstructVarargs(MacroAssembler* masm,\n     __ Bind(&done);\n   }\n \n-  // Push arguments onto the stack (thisArgument is already on the stack).\n-  {\n-    Label done, push, loop;\n-    Register src = x5;\n+  // Skip argument setup if we don't need to push any varargs.\n+  Label done;\n+  __ Cbz(len, &done);\n \n-    __ Add(src, arguments_list, FixedArray::kHeaderSize - kHeapObjectTag);\n-    __ Add(argc, argc, len);  // The 'len' argument for Call() or Construct().\n-    __ Cbz(len, &done);\n+  Generate_PrepareForCopyingVarargs(masm, argc, len);\n+\n+  // Push varargs.\n+  {\n+    Label loop;\n+    Register src = x10;\n     Register the_hole_value = x11;\n     Register undefined_value = x12;\n-    // We do not use the CompareRoot macro as it would do a LoadRoot behind the\n-    // scenes and we want to avoid that in a loop.\n+    Register scratch = x13;\n+    __ Add(src, arguments_list, FixedArray::kHeaderSize - kHeapObjectTag);\n     __ LoadRoot(the_hole_value, Heap::kTheHoleValueRootIndex);\n     __ LoadRoot(undefined_value, Heap::kUndefinedValueRootIndex);\n-    __ Claim(len);\n+    // We do not use the CompareRoot macro as it would do a LoadRoot behind the\n+    // scenes and we want to avoid that in a loop.\n+    // TODO(all): Consider using Ldp and Stp.\n     __ Bind(&loop);\n     __ Sub(len, len, 1);\n-    __ Ldr(x10, MemOperand(src, kPointerSize, PostIndex));\n-    __ Cmp(x10, the_hole_value);\n-    __ Csel(x10, x10, undefined_value, ne);\n-    __ Poke(x10, Operand(len, LSL, kPointerSizeLog2));\n+    __ Ldr(scratch, MemOperand(src, kPointerSize, PostIndex));\n+    __ Cmp(scratch, the_hole_value);\n+    __ Csel(scratch, scratch, undefined_value, ne);\n+    __ Poke(scratch, Operand(len, LSL, kPointerSizeLog2));\n     __ Cbnz(len, &loop);\n-    __ Bind(&done);\n   }\n+  __ Bind(&done);\n \n   // Tail-call to the actual Call or Construct builtin.\n   __ Jump(code, RelocInfo::CODE_TARGET);\n@@ -2158,13 +2246,16 @@ void Builtins::Generate_CallOrConstructForwardVarargs(MacroAssembler* masm,\n   //  -- x2 : start index (to support rest parameters)\n   // -----------------------------------\n \n+  Register argc = x0;\n+  Register start_index = x2;\n+\n   // Check if new.target has a [[Construct]] internal method.\n   if (mode == CallOrConstructMode::kConstruct) {\n     Label new_target_constructor, new_target_not_constructor;\n     __ JumpIfSmi(x3, &new_target_not_constructor);\n     __ Ldr(x5, FieldMemOperand(x3, HeapObject::kMapOffset));\n     __ Ldrb(x5, FieldMemOperand(x5, Map::kBitFieldOffset));\n-    __ TestAndBranchIfAnySet(x5, 1 << Map::kIsConstructor,\n+    __ TestAndBranchIfAnySet(x5, Map::IsConstructorBit::kMask,\n                              &new_target_constructor);\n     __ Bind(&new_target_not_constructor);\n     {\n@@ -2177,49 +2268,57 @@ void Builtins::Generate_CallOrConstructForwardVarargs(MacroAssembler* masm,\n   }\n \n   // Check if we have an arguments adaptor frame below the function frame.\n-  Label arguments_adaptor, arguments_done;\n-  __ Ldr(x5, MemOperand(fp, StandardFrameConstants::kCallerFPOffset));\n-  __ Ldr(x4, MemOperand(x5, CommonFrameConstants::kContextOrFrameTypeOffset));\n-  __ Cmp(x4, StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR));\n-  __ B(eq, &arguments_adaptor);\n-  {\n-    __ Ldr(x6, MemOperand(fp, JavaScriptFrameConstants::kFunctionOffset));\n-    __ Ldr(x6, FieldMemOperand(x6, JSFunction::kSharedFunctionInfoOffset));\n-    __ Ldrsw(x6, FieldMemOperand(\n-                     x6, SharedFunctionInfo::kFormalParameterCountOffset));\n-    __ Mov(x5, fp);\n-  }\n-  __ B(&arguments_done);\n-  __ Bind(&arguments_adaptor);\n+  // args_fp will point to the frame that contains the actual arguments, which\n+  // will be the current frame unless we have an arguments adaptor frame, in\n+  // which case args_fp points to the arguments adaptor frame.\n+  Register args_fp = x5;\n+  Register len = x6;\n   {\n-    // Just load the length from ArgumentsAdaptorFrame.\n-    __ Ldrsw(x6, UntagSmiMemOperand(\n-                     x5, ArgumentsAdaptorFrameConstants::kLengthOffset));\n+    Label arguments_adaptor, arguments_done;\n+    Register scratch = x10;\n+    __ Ldr(args_fp, MemOperand(fp, StandardFrameConstants::kCallerFPOffset));\n+    __ Ldr(x4, MemOperand(args_fp,\n+                          CommonFrameConstants::kContextOrFrameTypeOffset));\n+    __ Cmp(x4, StackFrame::TypeToMarker(StackFrame::ARGUMENTS_ADAPTOR));\n+    __ B(eq, &arguments_adaptor);\n+    {\n+      __ Ldr(scratch,\n+             MemOperand(fp, JavaScriptFrameConstants::kFunctionOffset));\n+      __ Ldr(scratch,\n+             FieldMemOperand(scratch, JSFunction::kSharedFunctionInfoOffset));\n+      __ Ldrsw(len,\n+               FieldMemOperand(\n+                   scratch, SharedFunctionInfo::kFormalParameterCountOffset));\n+      __ Mov(args_fp, fp);\n+    }\n+    __ B(&arguments_done);\n+    __ Bind(&arguments_adaptor);\n+    {\n+      // Just load the length from ArgumentsAdaptorFrame.\n+      __ Ldrsw(len,\n+               UntagSmiMemOperand(\n+                   args_fp, ArgumentsAdaptorFrameConstants::kLengthOffset));\n+    }\n+    __ Bind(&arguments_done);\n   }\n-  __ Bind(&arguments_done);\n \n   Label stack_done, stack_overflow;\n-  __ Subs(x6, x6, x2);\n+  __ Subs(len, len, start_index);\n   __ B(le, &stack_done);\n-  {\n-    // Check for stack overflow.\n-    Generate_StackOverflowCheck(masm, x6, &stack_overflow);\n+  // Check for stack overflow.\n+  Generate_StackOverflowCheck(masm, x6, &stack_overflow);\n \n-    // Forward the arguments from the caller frame.\n-    {\n-      Label loop;\n-      __ Add(x5, x5, kPointerSize);\n-      __ Add(x0, x0, x6);\n-      __ Bind(&loop);\n-      {\n-        __ Ldr(x4, MemOperand(x5, x6, LSL, kPointerSizeLog2));\n-        __ Push(x4);\n-        __ Subs(x6, x6, 1);\n-        __ B(ne, &loop);\n-      }\n-    }\n+  Generate_PrepareForCopyingVarargs(masm, argc, len);\n+\n+  // Push varargs.\n+  {\n+    Register dst = x13;\n+    __ Add(args_fp, args_fp, 2 * kPointerSize);\n+    __ SlotAddress(dst, 0);\n+    __ CopyDoubleWords(dst, args_fp, len);\n   }\n   __ B(&stack_done);\n+\n   __ Bind(&stack_overflow);\n   __ TailCallRuntime(Runtime::kThrowStackOverflow);\n   __ Bind(&stack_done);\n@@ -2338,12 +2437,16 @@ void Generate_PushBoundArguments(MacroAssembler* masm) {\n   //  -- x3 : new.target (only in case of [[Construct]])\n   // -----------------------------------\n \n+  Register bound_argc = x4;\n+  Register bound_argv = x2;\n+\n   // Load [[BoundArguments]] into x2 and length of that into x4.\n   Label no_bound_arguments;\n-  __ Ldr(x2, FieldMemOperand(x1, JSBoundFunction::kBoundArgumentsOffset));\n-  __ Ldrsw(x4, UntagSmiFieldMemOperand(x2, FixedArray::kLengthOffset));\n-  __ Cmp(x4, 0);\n-  __ B(eq, &no_bound_arguments);\n+  __ Ldr(bound_argv,\n+         FieldMemOperand(x1, JSBoundFunction::kBoundArgumentsOffset));\n+  __ Ldrsw(bound_argc,\n+           UntagSmiFieldMemOperand(bound_argv, FixedArray::kLengthOffset));\n+  __ Cbz(bound_argc, &no_bound_arguments);\n   {\n     // ----------- S t a t e -------------\n     //  -- x0 : the number of arguments (not including the receiver)\n@@ -2353,44 +2456,97 @@ void Generate_PushBoundArguments(MacroAssembler* masm) {\n     //  -- x4 : the number of [[BoundArguments]]\n     // -----------------------------------\n \n+    Register argc = x0;\n+\n+    // Check for stack overflow.\n     {\n-      Label done;\n-      __ Claim(x4);\n       // Check the stack for overflow. We are not trying to catch interruptions\n       // (i.e. debug break and preemption) here, so check the \"real stack\n       // limit\".\n-      __ CompareRoot(jssp, Heap::kRealStackLimitRootIndex);\n+      Label done;\n+      __ LoadRoot(x10, Heap::kRealStackLimitRootIndex);\n+      // Make x10 the space we have left. The stack might already be overflowed\n+      // here which will cause x10 to become negative.\n+      __ Sub(x10, masm->StackPointer(), x10);\n+      // Check if the arguments will overflow the stack.\n+      __ Cmp(x10, Operand(bound_argc, LSL, kPointerSizeLog2));\n       __ B(gt, &done);  // Signed comparison.\n-      // Restore the stack pointer.\n-      __ Drop(x4);\n-      {\n-        FrameScope scope(masm, StackFrame::MANUAL);\n-        __ EnterFrame(StackFrame::INTERNAL);\n-        __ CallRuntime(Runtime::kThrowStackOverflow);\n-      }\n+      __ TailCallRuntime(Runtime::kThrowStackOverflow);\n       __ Bind(&done);\n     }\n \n-    UseScratchRegisterScope temps(masm);\n-    Register argc = temps.AcquireX();\n-    // Relocate arguments down the stack.\n-    __ Mov(argc, x0);\n-    __ CopySlots(0, x4, argc);\n+    // Check if we need padding.\n+    Label copy_args, copy_bound_args;\n+    Register total_argc = x15;\n+    Register slots_to_claim = x12;\n+    __ Add(total_argc, argc, bound_argc);\n+    __ Mov(slots_to_claim, bound_argc);\n+    __ Tbz(bound_argc, 0, &copy_args);\n+\n+    // Load receiver before we start moving the arguments. We will only\n+    // need this in this path because the bound arguments are odd.\n+    Register receiver = x14;\n+    __ Peek(receiver, Operand(argc, LSL, kPointerSizeLog2));\n \n-    // Copy [[BoundArguments]] to the stack (below the arguments). The first\n-    // element of the array is copied to the highest address.\n+    // Claim space we need. If argc is even, slots_to_claim = bound_argc + 1,\n+    // as we need one extra padding slot. If argc is odd, we know that the\n+    // original arguments will have a padding slot we can reuse (since\n+    // bound_argc is odd), so slots_to_claim = bound_argc - 1.\n     {\n-      Label loop;\n-      __ Ldrsw(x4, UntagSmiFieldMemOperand(x2, FixedArray::kLengthOffset));\n-      __ Add(x2, x2, FixedArray::kHeaderSize - kHeapObjectTag);\n-      __ SlotAddress(x11, x0);\n-      __ Add(x0, x0, x4);\n-      __ Bind(&loop);\n-      __ Sub(x4, x4, 1);\n-      __ Ldr(x10, MemOperand(x2, x4, LSL, kPointerSizeLog2));\n-      // Poke into claimed area of stack.\n-      __ Str(x10, MemOperand(x11, kPointerSize, PostIndex));\n-      __ Cbnz(x4, &loop);\n+      Register scratch = x11;\n+      __ Add(slots_to_claim, bound_argc, 1);\n+      __ And(scratch, total_argc, 1);\n+      __ Sub(slots_to_claim, slots_to_claim, Operand(scratch, LSL, 1));\n+    }\n+\n+    // Copy bound arguments.\n+    __ Bind(&copy_args);\n+    // Skip claim and copy of existing arguments in the special case where we\n+    // do not need to claim any slots (this will be the case when\n+    // bound_argc == 1 and the existing arguments have padding we can reuse).\n+    __ Cbz(slots_to_claim, &copy_bound_args);\n+    __ Claim(slots_to_claim);\n+    {\n+      Register count = x10;\n+      // Relocate arguments to a lower address.\n+      __ Mov(count, argc);\n+      __ CopySlots(0, slots_to_claim, count);\n+\n+      __ Bind(&copy_bound_args);\n+      // Copy [[BoundArguments]] to the stack (below the arguments). The first\n+      // element of the array is copied to the highest address.\n+      {\n+        Label loop;\n+        Register counter = x10;\n+        Register scratch = x11;\n+        Register copy_to = x12;\n+        __ Add(bound_argv, bound_argv,\n+               FixedArray::kHeaderSize - kHeapObjectTag);\n+        __ SlotAddress(copy_to, argc);\n+        __ Add(argc, argc,\n+               bound_argc);  // Update argc to include bound arguments.\n+        __ Lsl(counter, bound_argc, kPointerSizeLog2);\n+        __ Bind(&loop);\n+        __ Sub(counter, counter, kPointerSize);\n+        __ Ldr(scratch, MemOperand(bound_argv, counter));\n+        // Poke into claimed area of stack.\n+        __ Str(scratch, MemOperand(copy_to, kPointerSize, PostIndex));\n+        __ Cbnz(counter, &loop);\n+      }\n+\n+      {\n+        Label done;\n+        Register scratch = x10;\n+        __ Tbz(bound_argc, 0, &done);\n+        // Store receiver.\n+        __ Add(scratch, __ StackPointer(),\n+               Operand(total_argc, LSL, kPointerSizeLog2));\n+        __ Str(receiver, MemOperand(scratch, kPointerSize, PostIndex));\n+        __ Tbnz(total_argc, 0, &done);\n+        // Store padding.\n+        __ Str(padreg, MemOperand(scratch));\n+        __ Bind(&done);\n+      }\n     }\n   }\n   __ Bind(&no_bound_arguments);\n@@ -2438,7 +2594,7 @@ void Builtins::Generate_Call(MacroAssembler* masm, ConvertReceiverMode mode) {\n \n   // Check if target has a [[Call]] internal method.\n   __ Ldrb(x4, FieldMemOperand(x4, Map::kBitFieldOffset));\n-  __ TestAndBranchIfAllClear(x4, 1 << Map::kIsCallable, &non_callable);\n+  __ TestAndBranchIfAllClear(x4, Map::IsCallableBit::kMask, &non_callable);\n \n   // Check if target is a proxy and call CallProxy external builtin\n   __ Cmp(x5, JS_PROXY_TYPE);\n@@ -2533,7 +2689,8 @@ void Builtins::Generate_Construct(MacroAssembler* masm) {\n \n   // Check if target has a [[Construct]] internal method.\n   __ Ldrb(x2, FieldMemOperand(x4, Map::kBitFieldOffset));\n-  __ TestAndBranchIfAllClear(x2, 1 << Map::kIsConstructor, &non_constructor);\n+  __ TestAndBranchIfAllClear(x2, Map::IsConstructorBit::kMask,\n+                             &non_constructor);\n \n   // Only dispatch to bound functions after checking whether they are\n   // constructors.\n@@ -2605,19 +2762,6 @@ void Builtins::Generate_Abort(MacroAssembler* masm) {\n   __ TailCallRuntime(Runtime::kAbort);\n }\n \n-// static\n-void Builtins::Generate_AbortJS(MacroAssembler* masm) {\n-  ASM_LOCATION(\"Builtins::Generate_AbortJS\");\n-  // ----------- S t a t e -------------\n-  //  -- x1 : message as String object\n-  //  -- lr : return address\n-  // -----------------------------------\n-  MacroAssembler::NoUseRealAbortsScope no_use_real_aborts(masm);\n-  __ PushArgument(x1);\n-  __ Move(cp, Smi::kZero);\n-  __ TailCallRuntime(Runtime::kAbortJS);\n-}\n-\n void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   ASM_LOCATION(\"Builtins::Generate_ArgumentsAdaptorTrampoline\");\n   // ----------- S t a t e -------------\n@@ -2651,14 +2795,16 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   //   4   |     num of      |                            |\n   //       |   actual args   |                            |\n   //       |- - - - - - - - -|                            |\n-  //  [5]  |    [padding]    |                            |\n+  //   5   |     padding     |                            |\n   //       |-----------------+----                        |\n-  // 5+pad |    receiver     |   ^                        |\n+  //  [6]  |    [padding]    |   ^                        |\n+  //       |- - - - - - - - -|   |                        |\n+  // 6+pad |    receiver     |   |                        |\n   //       |  (parameter 0)  |   |                        |\n   //       |- - - - - - - - -|   |                        |\n-  // 6+pad |   parameter 1   |   |                        |\n+  // 7+pad |   parameter 1   |   |                        |\n   //       |- - - - - - - - -| Frame slots ----> expected args\n-  // 7+pad |   parameter 2   |   |                        |\n+  // 8+pad |   parameter 2   |   |                        |\n   //       |- - - - - - - - -|   |                        |\n   //       |                 |   |                        |\n   //  ...  |       ...       |   |                        |\n@@ -2671,7 +2817,8 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   //       |   [undefined]   |   v   <-- stack ptr        v\n   //  -----+-----------------+---------------------------------\n   //\n-  // There is an optional slot of padding to ensure stack alignment.\n+  // There is an optional slot of padding above the receiver to ensure stack\n+  // alignment of the arguments.\n   // If the number of expected arguments is larger than the number of actual\n   // arguments, the remaining expected slots will be filled with undefined.\n \n@@ -2695,10 +2842,10 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   Register argc_unused_actual = x14;\n   Register scratch1 = x15, scratch2 = x16;\n \n-  // We need slots for the expected arguments, with two extra slots for the\n-  // number of actual arguments and the receiver.\n+  // We need slots for the expected arguments, with one extra slot for the\n+  // receiver.\n   __ RecordComment(\"-- Stack check --\");\n-  __ Add(scratch1, argc_expected, 2);\n+  __ Add(scratch1, argc_expected, 1);\n   Generate_StackOverflowCheck(masm, scratch1, &stack_overflow);\n \n   // Round up number of slots to be even, to maintain stack alignment.\n@@ -2707,7 +2854,7 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   __ Bic(scratch1, scratch1, 1);\n   __ Claim(scratch1, kPointerSize);\n \n-  __ Mov(copy_to, jssp);\n+  __ Mov(copy_to, __ StackPointer());\n \n   // Preparing the expected arguments is done in four steps, the order of\n   // which is chosen so we can use LDP/STP and avoid conditional branches as\n@@ -2738,7 +2885,9 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n \n   __ Bind(&enough_arguments);\n   // (2) Copy all of the actual arguments, or as many as we need.\n+  Label skip_copy;\n   __ RecordComment(\"-- Copy actual arguments --\");\n+  __ Cbz(argc_to_copy, &skip_copy);\n   __ Add(copy_end, copy_to, Operand(argc_to_copy, LSL, kPointerSizeLog2));\n   __ Add(copy_from, fp, 2 * kPointerSize);\n   // Adjust for difference between actual and expected arguments.\n@@ -2755,21 +2904,22 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   __ Stp(scratch1, scratch2, MemOperand(copy_to, 2 * kPointerSize, PostIndex));\n   __ Cmp(copy_end, copy_to);\n   __ B(hi, &copy_2_by_2);\n+  __ Bind(&skip_copy);\n \n-  // (3) Store number of actual arguments and padding. The padding might be\n-  // unnecessary, in which case it will be overwritten by the receiver.\n-  __ RecordComment(\"-- Store number of args and padding --\");\n-  __ SmiTag(scratch1, argc_actual);\n-  __ Stp(xzr, scratch1, MemOperand(fp, -4 * kPointerSize));\n+  // (3) Store padding, which might be overwritten by the receiver, if it is not\n+  // necessary.\n+  __ RecordComment(\"-- Store padding --\");\n+  __ Str(padreg, MemOperand(fp, -5 * kPointerSize));\n \n-  // (4) Store receiver. Calculate target address from jssp to avoid checking\n+  // (4) Store receiver. Calculate target address from the sp to avoid checking\n   // for padding. Storing the receiver will overwrite either the extra slot\n   // we copied with the actual arguments, if we did copy one, or the padding we\n   // stored above.\n   __ RecordComment(\"-- Store receiver --\");\n   __ Add(copy_from, fp, 2 * kPointerSize);\n   __ Ldr(scratch1, MemOperand(copy_from, argc_actual, LSL, kPointerSizeLog2));\n-  __ Str(scratch1, MemOperand(jssp, argc_expected, LSL, kPointerSizeLog2));\n+  __ Str(scratch1,\n+         MemOperand(__ StackPointer(), argc_expected, LSL, kPointerSizeLog2));\n \n   // Arguments have been adapted. Now call the entry point.\n   __ RecordComment(\"-- Call entry point --\");\n@@ -2805,10 +2955,6 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n }\n \n void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {\n-  // Wasm code uses the csp. This builtin excepts to use the jssp.\n-  // Thus, move csp to jssp when entering this builtin (called from wasm).\n-  DCHECK(masm->StackPointer().is(jssp));\n-  __ Move(jssp, csp);\n   {\n     FrameScope scope(masm, StackFrame::INTERNAL);\n \n@@ -2833,9 +2979,6 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {\n     __ PopDRegList(fp_regs);\n     __ PopXRegList(gp_regs);\n   }\n-  // Move back to csp land. jssp now has the same value as when entering this\n-  // function, but csp might have changed in the runtime call.\n-  __ Move(csp, jssp);\n   // Now jump to the instructions of the returned code object.\n   __ Jump(x8);\n }"
        },
        {
            "sha": "027baa287395b2a2e65ad1296f3da6d3c3842c71",
            "filename": "deps/v8/src/builtins/builtins-array-gen.cc",
            "status": "modified",
            "additions": 454,
            "deletions": 85,
            "changes": 539,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -31,6 +31,8 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n   typedef std::function<void(ArrayBuiltinCodeStubAssembler* masm)>\n       PostLoopAction;\n \n+  enum class MissingPropertyMode { kSkip, kUseUndefined };\n+\n   void FindResultGenerator() { a_.Bind(UndefinedConstant()); }\n \n   Node* FindProcessor(Node* k_value, Node* k) {\n@@ -383,6 +385,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n       const char* name, const BuiltinResultGenerator& generator,\n       const CallResultProcessor& processor, const PostLoopAction& action,\n       const Callable& slow_case_continuation,\n+      MissingPropertyMode missing_property_mode,\n       ForEachDirection direction = ForEachDirection::kForward) {\n     Label non_array(this), array_changes(this, {&k_, &a_, &to_});\n \n@@ -439,7 +442,8 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n \n     generator(this);\n \n-    HandleFastElements(processor, action, &fully_spec_compliant_, direction);\n+    HandleFastElements(processor, action, &fully_spec_compliant_, direction,\n+                       missing_property_mode);\n \n     BIND(&fully_spec_compliant_);\n \n@@ -550,6 +554,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n \n   void GenerateIteratingArrayBuiltinLoopContinuation(\n       const CallResultProcessor& processor, const PostLoopAction& action,\n+      MissingPropertyMode missing_property_mode,\n       ForEachDirection direction = ForEachDirection::kForward) {\n     Label loop(this, {&k_, &a_, &to_});\n     Label after_loop(this);\n@@ -558,11 +563,11 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n     {\n       if (direction == ForEachDirection::kForward) {\n         // 8. Repeat, while k < len\n-        GotoIfNumericGreaterThanOrEqual(k(), len_, &after_loop);\n+        GotoIfNumberGreaterThanOrEqual(k(), len_, &after_loop);\n       } else {\n         // OR\n         // 10. Repeat, while k >= 0\n-        GotoIfNumericGreaterThanOrEqual(SmiConstant(-1), k(), &after_loop);\n+        GotoIfNumberGreaterThanOrEqual(SmiConstant(-1), k(), &after_loop);\n       }\n \n       Label done_element(this, &to_);\n@@ -572,12 +577,15 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n       // index in the range [0, 2^32-1).\n       CSA_ASSERT(this, IsNumberArrayIndex(k()));\n \n-      // b. Let kPresent be HasProperty(O, Pk).\n-      // c. ReturnIfAbrupt(kPresent).\n-      Node* k_present = HasProperty(o(), k(), context(), kHasProperty);\n+      if (missing_property_mode == MissingPropertyMode::kSkip) {\n+        // b. Let kPresent be HasProperty(O, Pk).\n+        // c. ReturnIfAbrupt(kPresent).\n+        TNode<Oddball> k_present =\n+            HasProperty(o(), k(), context(), kHasProperty);\n \n-      // d. If kPresent is true, then\n-      GotoIf(WordNotEqual(k_present, TrueConstant()), &done_element);\n+        // d. If kPresent is true, then\n+        GotoIf(IsFalse(k_present), &done_element);\n+      }\n \n       // i. Let kValue be Get(O, Pk).\n       // ii. ReturnIfAbrupt(kValue).\n@@ -655,7 +663,8 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n   void VisitAllFastElementsOneKind(ElementsKind kind,\n                                    const CallResultProcessor& processor,\n                                    Label* array_changed, ParameterMode mode,\n-                                   ForEachDirection direction) {\n+                                   ForEachDirection direction,\n+                                   MissingPropertyMode missing_property_mode) {\n     Comment(\"begin VisitAllFastElementsOneKind\");\n     VARIABLE(original_map, MachineRepresentation::kTagged);\n     original_map.Bind(LoadMap(o()));\n@@ -670,7 +679,8 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n         list, start, end,\n         [=, &original_map](Node* index) {\n           k_.Bind(ParameterToTagged(index, mode));\n-          Label one_element_done(this), hole_element(this);\n+          Label one_element_done(this), hole_element(this),\n+              process_element(this);\n \n           // Check if o's map has changed during the callback. If so, we have to\n           // fall back to the slower spec implementation for the rest of the\n@@ -693,24 +703,32 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n                               ? FixedArray::kHeaderSize\n                               : (FixedArray::kHeaderSize - kHeapObjectTag);\n           Node* offset = ElementOffsetFromIndex(index, kind, mode, base_size);\n-          Node* value = nullptr;\n+          VARIABLE(value, MachineRepresentation::kTagged);\n           if (kind == PACKED_ELEMENTS) {\n-            value = LoadObjectField(elements, offset);\n-            GotoIf(WordEqual(value, TheHoleConstant()), &hole_element);\n+            value.Bind(LoadObjectField(elements, offset));\n+            GotoIf(WordEqual(value.value(), TheHoleConstant()), &hole_element);\n           } else {\n             Node* double_value =\n                 LoadDoubleWithHoleCheck(elements, offset, &hole_element);\n-            value = AllocateHeapNumberWithValue(double_value);\n+            value.Bind(AllocateHeapNumberWithValue(double_value));\n           }\n-          a_.Bind(processor(this, value, k()));\n-          Goto(&one_element_done);\n+          Goto(&process_element);\n \n           BIND(&hole_element);\n-          // Check if o's prototype change unexpectedly has elements after the\n-          // callback in the case of a hole.\n-          BranchIfPrototypesHaveNoElements(o_map, &one_element_done,\n-                                           array_changed);\n-\n+          if (missing_property_mode == MissingPropertyMode::kSkip) {\n+            // Check if o's prototype change unexpectedly has elements after\n+            // the callback in the case of a hole.\n+            BranchIfPrototypesHaveNoElements(o_map, &one_element_done,\n+                                             array_changed);\n+          } else {\n+            value.Bind(UndefinedConstant());\n+            Goto(&process_element);\n+          }\n+          BIND(&process_element);\n+          {\n+            a_.Bind(processor(this, value.value(), k()));\n+            Goto(&one_element_done);\n+          }\n           BIND(&one_element_done);\n         },\n         1, mode, advance_mode);\n@@ -719,7 +737,8 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n \n   void HandleFastElements(const CallResultProcessor& processor,\n                           const PostLoopAction& action, Label* slow,\n-                          ForEachDirection direction) {\n+                          ForEachDirection direction,\n+                          MissingPropertyMode missing_property_mode) {\n     Label switch_on_elements_kind(this), fast_elements(this),\n         maybe_double_elements(this), fast_double_elements(this);\n \n@@ -742,7 +761,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n     BIND(&fast_elements);\n     {\n       VisitAllFastElementsOneKind(PACKED_ELEMENTS, processor, slow, mode,\n-                                  direction);\n+                                  direction, missing_property_mode);\n \n       action(this);\n \n@@ -757,7 +776,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n     BIND(&fast_double_elements);\n     {\n       VisitAllFastElementsOneKind(PACKED_DOUBLE_ELEMENTS, processor, slow, mode,\n-                                  direction);\n+                                  direction, missing_property_mode);\n \n       action(this);\n \n@@ -879,7 +898,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {\n   ElementsKind source_elements_kind_ = ElementsKind::NO_ELEMENTS;\n };\n \n-TF_BUILTIN(FastArrayPop, CodeStubAssembler) {\n+TF_BUILTIN(ArrayPrototypePop, CodeStubAssembler) {\n   Node* argc = Parameter(BuiltinDescriptor::kArgumentsCount);\n   Node* context = Parameter(BuiltinDescriptor::kContext);\n   CSA_ASSERT(this, IsUndefined(Parameter(BuiltinDescriptor::kNewTarget)));\n@@ -977,7 +996,7 @@ TF_BUILTIN(FastArrayPop, CodeStubAssembler) {\n   }\n }\n \n-TF_BUILTIN(FastArrayPush, CodeStubAssembler) {\n+TF_BUILTIN(ArrayPrototypePush, CodeStubAssembler) {\n   TVARIABLE(IntPtrT, arg_index);\n   Label default_label(this, &arg_index);\n   Label smi_transition(this);\n@@ -1106,9 +1125,10 @@ TF_BUILTIN(FastArrayPush, CodeStubAssembler) {\n   }\n }\n \n-class FastArraySliceCodeStubAssembler : public CodeStubAssembler {\n+class ArrayPrototypeSliceCodeStubAssembler : public CodeStubAssembler {\n  public:\n-  explicit FastArraySliceCodeStubAssembler(compiler::CodeAssemblerState* state)\n+  explicit ArrayPrototypeSliceCodeStubAssembler(\n+      compiler::CodeAssemblerState* state)\n       : CodeStubAssembler(state) {}\n \n   Node* HandleFastSlice(Node* context, Node* array, Node* from, Node* count,\n@@ -1245,11 +1265,11 @@ class FastArraySliceCodeStubAssembler : public CodeStubAssembler {\n   void CopyOneElement(Node* context, Node* o, Node* a, Node* p_k, Variable& n) {\n     // b. Let kPresent be HasProperty(O, Pk).\n     // c. ReturnIfAbrupt(kPresent).\n-    Node* k_present = HasProperty(o, p_k, context, kHasProperty);\n+    TNode<Oddball> k_present = HasProperty(o, p_k, context, kHasProperty);\n \n     // d. If kPresent is true, then\n     Label done_element(this);\n-    GotoIf(WordNotEqual(k_present, TrueConstant()), &done_element);\n+    GotoIf(IsFalse(k_present), &done_element);\n \n     // i. Let kValue be Get(O, Pk).\n     // ii. ReturnIfAbrupt(kValue).\n@@ -1264,10 +1284,10 @@ class FastArraySliceCodeStubAssembler : public CodeStubAssembler {\n   }\n };\n \n-TF_BUILTIN(FastArraySlice, FastArraySliceCodeStubAssembler) {\n+TF_BUILTIN(ArrayPrototypeSlice, ArrayPrototypeSliceCodeStubAssembler) {\n   Node* const argc =\n       ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n-  Node* const context = Parameter(BuiltinDescriptor::kContext);\n+  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n   Label slow(this, Label::kDeferred), fast_elements_kind(this);\n \n   CodeStubArguments args(this, argc);\n@@ -1339,15 +1359,15 @@ TF_BUILTIN(FastArraySlice, FastArraySliceCodeStubAssembler) {\n \n   // 5. Let relativeStart be ToInteger(start).\n   // 6. ReturnIfAbrupt(relativeStart).\n-  Node* arg0 = args.GetOptionalArgumentValue(0, SmiConstant(0));\n-  Node* relative_start = ToInteger(context, arg0);\n+  TNode<Object> arg0 = CAST(args.GetOptionalArgumentValue(0, SmiConstant(0)));\n+  Node* relative_start = ToInteger_Inline(context, arg0);\n \n   // 7. If relativeStart < 0, let k be max((len + relativeStart),0);\n   //    else let k be min(relativeStart, len.value()).\n   VARIABLE(k, MachineRepresentation::kTagged);\n   Label relative_start_positive(this), relative_start_done(this);\n-  GotoIfNumericGreaterThanOrEqual(relative_start, SmiConstant(0),\n-                                  &relative_start_positive);\n+  GotoIfNumberGreaterThanOrEqual(relative_start, SmiConstant(0),\n+                                 &relative_start_positive);\n   k.Bind(NumberMax(NumberAdd(len.value(), relative_start), NumberConstant(0)));\n   Goto(&relative_start_done);\n   BIND(&relative_start_positive);\n@@ -1358,11 +1378,12 @@ TF_BUILTIN(FastArraySlice, FastArraySliceCodeStubAssembler) {\n   // 8. If end is undefined, let relativeEnd be len;\n   //    else let relativeEnd be ToInteger(end).\n   // 9. ReturnIfAbrupt(relativeEnd).\n-  Node* end = args.GetOptionalArgumentValue(1, UndefinedConstant());\n+  TNode<Object> end =\n+      CAST(args.GetOptionalArgumentValue(1, UndefinedConstant()));\n   Label end_undefined(this), end_done(this);\n   VARIABLE(relative_end, MachineRepresentation::kTagged);\n   GotoIf(WordEqual(end, UndefinedConstant()), &end_undefined);\n-  relative_end.Bind(ToInteger(context, end));\n+  relative_end.Bind(ToInteger_Inline(context, end));\n   Goto(&end_done);\n   BIND(&end_undefined);\n   relative_end.Bind(len.value());\n@@ -1373,8 +1394,8 @@ TF_BUILTIN(FastArraySlice, FastArraySliceCodeStubAssembler) {\n   //     else let final be min(relativeEnd, len).\n   VARIABLE(final, MachineRepresentation::kTagged);\n   Label relative_end_positive(this), relative_end_done(this);\n-  GotoIfNumericGreaterThanOrEqual(relative_end.value(), NumberConstant(0),\n-                                  &relative_end_positive);\n+  GotoIfNumberGreaterThanOrEqual(relative_end.value(), NumberConstant(0),\n+                                 &relative_end_positive);\n   final.Bind(NumberMax(NumberAdd(len.value(), relative_end.value()),\n                        NumberConstant(0)));\n   Goto(&relative_end_done);\n@@ -1412,7 +1433,7 @@ TF_BUILTIN(FastArraySlice, FastArraySliceCodeStubAssembler) {\n   BIND(&loop);\n   {\n     // 15. Repeat, while k < final\n-    GotoIfNumericGreaterThanOrEqual(k.value(), final.value(), &after_loop);\n+    GotoIfNumberGreaterThanOrEqual(k.value(), final.value(), &after_loop);\n \n     Node* p_k = k.value();  //  ToString(context, k.value()) is no-op\n \n@@ -1438,7 +1459,7 @@ TF_BUILTIN(FastArraySlice, FastArraySliceCodeStubAssembler) {\n   args.PopAndReturn(a);\n }\n \n-TF_BUILTIN(FastArrayShift, CodeStubAssembler) {\n+TF_BUILTIN(ArrayPrototypeShift, CodeStubAssembler) {\n   Node* argc = Parameter(BuiltinDescriptor::kArgumentsCount);\n   Node* context = Parameter(BuiltinDescriptor::kContext);\n   CSA_ASSERT(this, IsUndefined(Parameter(BuiltinDescriptor::kNewTarget)));\n@@ -1619,6 +1640,206 @@ TF_BUILTIN(CloneFastJSArray, ArrayBuiltinCodeStubAssembler) {\n   Return(CloneFastJSArray(context, array, mode));\n }\n \n+TF_BUILTIN(ArrayFindLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* array = Parameter(Descriptor::kArray);\n+  Node* object = Parameter(Descriptor::kObject);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+  Node* to = Parameter(Descriptor::kTo);\n+\n+  InitIteratingArrayBuiltinLoopContinuation(context, receiver, callbackfn,\n+                                            this_arg, array, object, initial_k,\n+                                            len, to);\n+\n+  GenerateIteratingArrayBuiltinLoopContinuation(\n+      &ArrayBuiltinCodeStubAssembler::FindProcessor,\n+      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n+      MissingPropertyMode::kUseUndefined, ForEachDirection::kForward);\n+}\n+\n+// Continuation that is called after an eager deoptimization from TF (ex. the\n+// array changes during iteration).\n+TF_BUILTIN(ArrayFindLoopEagerDeoptContinuation, ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+\n+  Return(CallBuiltin(Builtins::kArrayFindLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, UndefinedConstant(), receiver,\n+                     initial_k, len, UndefinedConstant()));\n+}\n+\n+// Continuation that is called after a lazy deoptimization from TF (ex. the\n+// callback function is no longer callable).\n+TF_BUILTIN(ArrayFindLoopLazyDeoptContinuation, ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+\n+  Return(CallBuiltin(Builtins::kArrayFindLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, UndefinedConstant(), receiver,\n+                     initial_k, len, UndefinedConstant()));\n+}\n+\n+// Continuation that is called after a lazy deoptimization from TF that happens\n+// right after the callback and it's returned value must be handled before\n+// iteration continues.\n+TF_BUILTIN(ArrayFindLoopAfterCallbackLazyDeoptContinuation,\n+           ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+  Node* found_value = Parameter(Descriptor::kFoundValue);\n+  Node* is_found = Parameter(Descriptor::kIsFound);\n+\n+  // This custom lazy deopt point is right after the callback. find() needs\n+  // to pick up at the next step, which is returning the element if the callback\n+  // value is truthy.  Otherwise, continue the search by calling the\n+  // continuation.\n+  Label if_true(this), if_false(this);\n+  BranchIfToBooleanIsTrue(is_found, &if_true, &if_false);\n+  BIND(&if_true);\n+  Return(found_value);\n+  BIND(&if_false);\n+  Return(CallBuiltin(Builtins::kArrayFindLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, UndefinedConstant(), receiver,\n+                     initial_k, len, UndefinedConstant()));\n+}\n+\n+// ES #sec-get-%typedarray%.prototype.find\n+TF_BUILTIN(ArrayPrototypeFind, ArrayBuiltinCodeStubAssembler) {\n+  Node* argc =\n+      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+  CodeStubArguments args(this, argc);\n+  Node* context = Parameter(BuiltinDescriptor::kContext);\n+  Node* new_target = Parameter(BuiltinDescriptor::kNewTarget);\n+  Node* receiver = args.GetReceiver();\n+  Node* callbackfn = args.GetOptionalArgumentValue(0);\n+  Node* this_arg = args.GetOptionalArgumentValue(1);\n+\n+  InitIteratingArrayBuiltinBody(context, receiver, callbackfn, this_arg,\n+                                new_target, argc);\n+\n+  GenerateIteratingArrayBuiltinBody(\n+      \"Array.prototype.find\",\n+      &ArrayBuiltinCodeStubAssembler::FindResultGenerator,\n+      &ArrayBuiltinCodeStubAssembler::FindProcessor,\n+      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n+      Builtins::CallableFor(isolate(), Builtins::kArrayFindLoopContinuation),\n+      MissingPropertyMode::kUseUndefined, ForEachDirection::kForward);\n+}\n+\n+TF_BUILTIN(ArrayFindIndexLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* array = Parameter(Descriptor::kArray);\n+  Node* object = Parameter(Descriptor::kObject);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+  Node* to = Parameter(Descriptor::kTo);\n+\n+  InitIteratingArrayBuiltinLoopContinuation(context, receiver, callbackfn,\n+                                            this_arg, array, object, initial_k,\n+                                            len, to);\n+\n+  GenerateIteratingArrayBuiltinLoopContinuation(\n+      &ArrayBuiltinCodeStubAssembler::FindIndexProcessor,\n+      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n+      MissingPropertyMode::kUseUndefined, ForEachDirection::kForward);\n+}\n+\n+TF_BUILTIN(ArrayFindIndexLoopEagerDeoptContinuation,\n+           ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+\n+  Return(CallBuiltin(Builtins::kArrayFindIndexLoopContinuation, context,\n+                     receiver, callbackfn, this_arg, SmiConstant(-1), receiver,\n+                     initial_k, len, UndefinedConstant()));\n+}\n+\n+TF_BUILTIN(ArrayFindIndexLoopLazyDeoptContinuation,\n+           ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+\n+  Return(CallBuiltin(Builtins::kArrayFindIndexLoopContinuation, context,\n+                     receiver, callbackfn, this_arg, SmiConstant(-1), receiver,\n+                     initial_k, len, UndefinedConstant()));\n+}\n+\n+TF_BUILTIN(ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation,\n+           ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+  Node* found_value = Parameter(Descriptor::kFoundValue);\n+  Node* is_found = Parameter(Descriptor::kIsFound);\n+\n+  // This custom lazy deopt point is right after the callback. find() needs\n+  // to pick up at the next step, which is returning the element if the callback\n+  // value is truthy.  Otherwise, continue the search by calling the\n+  // continuation.\n+  Label if_true(this), if_false(this);\n+  BranchIfToBooleanIsTrue(is_found, &if_true, &if_false);\n+  BIND(&if_true);\n+  Return(found_value);\n+  BIND(&if_false);\n+  Return(CallBuiltin(Builtins::kArrayFindIndexLoopContinuation, context,\n+                     receiver, callbackfn, this_arg, SmiConstant(-1), receiver,\n+                     initial_k, len, UndefinedConstant()));\n+}\n+\n+// ES #sec-get-%typedarray%.prototype.findIndex\n+TF_BUILTIN(ArrayPrototypeFindIndex, ArrayBuiltinCodeStubAssembler) {\n+  Node* argc =\n+      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+  CodeStubArguments args(this, argc);\n+  Node* context = Parameter(BuiltinDescriptor::kContext);\n+  Node* new_target = Parameter(BuiltinDescriptor::kNewTarget);\n+  Node* receiver = args.GetReceiver();\n+  Node* callbackfn = args.GetOptionalArgumentValue(0);\n+  Node* this_arg = args.GetOptionalArgumentValue(1);\n+\n+  InitIteratingArrayBuiltinBody(context, receiver, callbackfn, this_arg,\n+                                new_target, argc);\n+\n+  GenerateIteratingArrayBuiltinBody(\n+      \"Array.prototype.findIndex\",\n+      &ArrayBuiltinCodeStubAssembler::FindIndexResultGenerator,\n+      &ArrayBuiltinCodeStubAssembler::FindIndexProcessor,\n+      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n+      Builtins::CallableFor(isolate(),\n+                            Builtins::kArrayFindIndexLoopContinuation),\n+      MissingPropertyMode::kUseUndefined, ForEachDirection::kForward);\n+}\n+\n // ES #sec-get-%typedarray%.prototype.find\n TF_BUILTIN(TypedArrayPrototypeFind, ArrayBuiltinCodeStubAssembler) {\n   Node* argc =\n@@ -1678,7 +1899,8 @@ TF_BUILTIN(ArrayForEachLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n \n   GenerateIteratingArrayBuiltinLoopContinuation(\n       &ArrayBuiltinCodeStubAssembler::ForEachProcessor,\n-      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction);\n+      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(ArrayForEachLoopEagerDeoptContinuation,\n@@ -1690,11 +1912,9 @@ TF_BUILTIN(ArrayForEachLoopEagerDeoptContinuation,\n   Node* initial_k = Parameter(Descriptor::kInitialK);\n   Node* len = Parameter(Descriptor::kLength);\n \n-  Callable stub(Builtins::CallableFor(isolate(),\n-                                      Builtins::kArrayForEachLoopContinuation));\n-  Return(CallStub(stub, context, receiver, callbackfn, this_arg,\n-                  UndefinedConstant(), receiver, initial_k, len,\n-                  UndefinedConstant()));\n+  Return(CallBuiltin(Builtins::kArrayForEachLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, UndefinedConstant(), receiver,\n+                     initial_k, len, UndefinedConstant()));\n }\n \n TF_BUILTIN(ArrayForEachLoopLazyDeoptContinuation,\n@@ -1706,11 +1926,9 @@ TF_BUILTIN(ArrayForEachLoopLazyDeoptContinuation,\n   Node* initial_k = Parameter(Descriptor::kInitialK);\n   Node* len = Parameter(Descriptor::kLength);\n \n-  Callable stub(Builtins::CallableFor(isolate(),\n-                                      Builtins::kArrayForEachLoopContinuation));\n-  Return(CallStub(stub, context, receiver, callbackfn, this_arg,\n-                  UndefinedConstant(), receiver, initial_k, len,\n-                  UndefinedConstant()));\n+  Return(CallBuiltin(Builtins::kArrayForEachLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, UndefinedConstant(), receiver,\n+                     initial_k, len, UndefinedConstant()));\n }\n \n TF_BUILTIN(ArrayForEach, ArrayBuiltinCodeStubAssembler) {\n@@ -1731,8 +1949,8 @@ TF_BUILTIN(ArrayForEach, ArrayBuiltinCodeStubAssembler) {\n       &ArrayBuiltinCodeStubAssembler::ForEachResultGenerator,\n       &ArrayBuiltinCodeStubAssembler::ForEachProcessor,\n       &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n-      Builtins::CallableFor(isolate(),\n-                            Builtins::kArrayForEachLoopContinuation));\n+      Builtins::CallableFor(isolate(), Builtins::kArrayForEachLoopContinuation),\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(TypedArrayPrototypeForEach, ArrayBuiltinCodeStubAssembler) {\n@@ -1755,6 +1973,48 @@ TF_BUILTIN(TypedArrayPrototypeForEach, ArrayBuiltinCodeStubAssembler) {\n       &ArrayBuiltinCodeStubAssembler::NullPostLoopAction);\n }\n \n+TF_BUILTIN(ArraySomeLoopLazyDeoptContinuation, ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+  Node* result = Parameter(Descriptor::kResult);\n+\n+  // This custom lazy deopt point is right after the callback. every() needs\n+  // to pick up at the next step, which is either continuing to the next\n+  // array element or returning false if {result} is false.\n+  Label true_continue(this), false_continue(this);\n+\n+  // iii. If selected is true, then...\n+  BranchIfToBooleanIsTrue(result, &true_continue, &false_continue);\n+  BIND(&true_continue);\n+  { Return(TrueConstant()); }\n+  BIND(&false_continue);\n+  {\n+    // Increment k.\n+    initial_k = NumberInc(initial_k);\n+\n+    Return(CallBuiltin(Builtins::kArraySomeLoopContinuation, context, receiver,\n+                       callbackfn, this_arg, FalseConstant(), receiver,\n+                       initial_k, len, UndefinedConstant()));\n+  }\n+}\n+\n+TF_BUILTIN(ArraySomeLoopEagerDeoptContinuation, ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+\n+  Return(CallBuiltin(Builtins::kArraySomeLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, FalseConstant(), receiver, initial_k,\n+                     len, UndefinedConstant()));\n+}\n+\n TF_BUILTIN(ArraySomeLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n   Node* context = Parameter(Descriptor::kContext);\n   Node* receiver = Parameter(Descriptor::kReceiver);\n@@ -1772,7 +2032,8 @@ TF_BUILTIN(ArraySomeLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n \n   GenerateIteratingArrayBuiltinLoopContinuation(\n       &ArrayBuiltinCodeStubAssembler::SomeProcessor,\n-      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction);\n+      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(ArraySome, ArrayBuiltinCodeStubAssembler) {\n@@ -1793,7 +2054,8 @@ TF_BUILTIN(ArraySome, ArrayBuiltinCodeStubAssembler) {\n       &ArrayBuiltinCodeStubAssembler::SomeResultGenerator,\n       &ArrayBuiltinCodeStubAssembler::SomeProcessor,\n       &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n-      Builtins::CallableFor(isolate(), Builtins::kArraySomeLoopContinuation));\n+      Builtins::CallableFor(isolate(), Builtins::kArraySomeLoopContinuation),\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(TypedArrayPrototypeSome, ArrayBuiltinCodeStubAssembler) {\n@@ -1816,6 +2078,49 @@ TF_BUILTIN(TypedArrayPrototypeSome, ArrayBuiltinCodeStubAssembler) {\n       &ArrayBuiltinCodeStubAssembler::NullPostLoopAction);\n }\n \n+TF_BUILTIN(ArrayEveryLoopLazyDeoptContinuation, ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+  Node* result = Parameter(Descriptor::kResult);\n+\n+  // This custom lazy deopt point is right after the callback. every() needs\n+  // to pick up at the next step, which is either continuing to the next\n+  // array element or returning false if {result} is false.\n+  Label true_continue(this), false_continue(this);\n+\n+  // iii. If selected is true, then...\n+  BranchIfToBooleanIsTrue(result, &true_continue, &false_continue);\n+  BIND(&true_continue);\n+  {\n+    // Increment k.\n+    initial_k = NumberInc(initial_k);\n+\n+    Return(CallBuiltin(Builtins::kArrayEveryLoopContinuation, context, receiver,\n+                       callbackfn, this_arg, TrueConstant(), receiver,\n+                       initial_k, len, UndefinedConstant()));\n+  }\n+  BIND(&false_continue);\n+  { Return(FalseConstant()); }\n+}\n+\n+TF_BUILTIN(ArrayEveryLoopEagerDeoptContinuation,\n+           ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* this_arg = Parameter(Descriptor::kThisArg);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+\n+  Return(CallBuiltin(Builtins::kArrayEveryLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, TrueConstant(), receiver, initial_k,\n+                     len, UndefinedConstant()));\n+}\n+\n TF_BUILTIN(ArrayEveryLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n   Node* context = Parameter(Descriptor::kContext);\n   Node* receiver = Parameter(Descriptor::kReceiver);\n@@ -1833,7 +2138,8 @@ TF_BUILTIN(ArrayEveryLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n \n   GenerateIteratingArrayBuiltinLoopContinuation(\n       &ArrayBuiltinCodeStubAssembler::EveryProcessor,\n-      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction);\n+      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(ArrayEvery, ArrayBuiltinCodeStubAssembler) {\n@@ -1854,7 +2160,8 @@ TF_BUILTIN(ArrayEvery, ArrayBuiltinCodeStubAssembler) {\n       &ArrayBuiltinCodeStubAssembler::EveryResultGenerator,\n       &ArrayBuiltinCodeStubAssembler::EveryProcessor,\n       &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n-      Builtins::CallableFor(isolate(), Builtins::kArrayEveryLoopContinuation));\n+      Builtins::CallableFor(isolate(), Builtins::kArrayEveryLoopContinuation),\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(TypedArrayPrototypeEvery, ArrayBuiltinCodeStubAssembler) {\n@@ -1894,7 +2201,38 @@ TF_BUILTIN(ArrayReduceLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n \n   GenerateIteratingArrayBuiltinLoopContinuation(\n       &ArrayBuiltinCodeStubAssembler::ReduceProcessor,\n-      &ArrayBuiltinCodeStubAssembler::ReducePostLoopAction);\n+      &ArrayBuiltinCodeStubAssembler::ReducePostLoopAction,\n+      MissingPropertyMode::kSkip);\n+}\n+\n+TF_BUILTIN(ArrayReduceLoopEagerDeoptContinuation,\n+           ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* accumulator = Parameter(Descriptor::kAccumulator);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+\n+  Callable stub(\n+      Builtins::CallableFor(isolate(), Builtins::kArrayReduceLoopContinuation));\n+  Return(CallStub(stub, context, receiver, callbackfn, UndefinedConstant(),\n+                  accumulator, receiver, initial_k, len, UndefinedConstant()));\n+}\n+\n+TF_BUILTIN(ArrayReduceLoopLazyDeoptContinuation,\n+           ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+  Node* result = Parameter(Descriptor::kResult);\n+\n+  Callable stub(\n+      Builtins::CallableFor(isolate(), Builtins::kArrayReduceLoopContinuation));\n+  Return(CallStub(stub, context, receiver, callbackfn, UndefinedConstant(),\n+                  result, receiver, initial_k, len, UndefinedConstant()));\n }\n \n TF_BUILTIN(ArrayReduce, ArrayBuiltinCodeStubAssembler) {\n@@ -1915,7 +2253,8 @@ TF_BUILTIN(ArrayReduce, ArrayBuiltinCodeStubAssembler) {\n       &ArrayBuiltinCodeStubAssembler::ReduceResultGenerator,\n       &ArrayBuiltinCodeStubAssembler::ReduceProcessor,\n       &ArrayBuiltinCodeStubAssembler::ReducePostLoopAction,\n-      Builtins::CallableFor(isolate(), Builtins::kArrayReduceLoopContinuation));\n+      Builtins::CallableFor(isolate(), Builtins::kArrayReduceLoopContinuation),\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(TypedArrayPrototypeReduce, ArrayBuiltinCodeStubAssembler) {\n@@ -1956,7 +2295,37 @@ TF_BUILTIN(ArrayReduceRightLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n   GenerateIteratingArrayBuiltinLoopContinuation(\n       &ArrayBuiltinCodeStubAssembler::ReduceProcessor,\n       &ArrayBuiltinCodeStubAssembler::ReducePostLoopAction,\n-      ForEachDirection::kReverse);\n+      MissingPropertyMode::kSkip, ForEachDirection::kReverse);\n+}\n+\n+TF_BUILTIN(ArrayReduceRightLoopEagerDeoptContinuation,\n+           ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* accumulator = Parameter(Descriptor::kAccumulator);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+\n+  Callable stub(Builtins::CallableFor(\n+      isolate(), Builtins::kArrayReduceRightLoopContinuation));\n+  Return(CallStub(stub, context, receiver, callbackfn, UndefinedConstant(),\n+                  accumulator, receiver, initial_k, len, UndefinedConstant()));\n+}\n+\n+TF_BUILTIN(ArrayReduceRightLoopLazyDeoptContinuation,\n+           ArrayBuiltinCodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* callbackfn = Parameter(Descriptor::kCallbackFn);\n+  Node* initial_k = Parameter(Descriptor::kInitialK);\n+  Node* len = Parameter(Descriptor::kLength);\n+  Node* result = Parameter(Descriptor::kResult);\n+\n+  Callable stub(Builtins::CallableFor(\n+      isolate(), Builtins::kArrayReduceRightLoopContinuation));\n+  Return(CallStub(stub, context, receiver, callbackfn, UndefinedConstant(),\n+                  result, receiver, initial_k, len, UndefinedConstant()));\n }\n \n TF_BUILTIN(ArrayReduceRight, ArrayBuiltinCodeStubAssembler) {\n@@ -1979,7 +2348,7 @@ TF_BUILTIN(ArrayReduceRight, ArrayBuiltinCodeStubAssembler) {\n       &ArrayBuiltinCodeStubAssembler::ReducePostLoopAction,\n       Builtins::CallableFor(isolate(),\n                             Builtins::kArrayReduceRightLoopContinuation),\n-      ForEachDirection::kReverse);\n+      MissingPropertyMode::kSkip, ForEachDirection::kReverse);\n }\n \n TF_BUILTIN(TypedArrayPrototypeReduceRight, ArrayBuiltinCodeStubAssembler) {\n@@ -2020,7 +2389,8 @@ TF_BUILTIN(ArrayFilterLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n \n   GenerateIteratingArrayBuiltinLoopContinuation(\n       &ArrayBuiltinCodeStubAssembler::FilterProcessor,\n-      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction);\n+      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(ArrayFilterLoopEagerDeoptContinuation,\n@@ -2034,10 +2404,9 @@ TF_BUILTIN(ArrayFilterLoopEagerDeoptContinuation,\n   Node* len = Parameter(Descriptor::kLength);\n   Node* to = Parameter(Descriptor::kTo);\n \n-  Callable stub(\n-      Builtins::CallableFor(isolate(), Builtins::kArrayFilterLoopContinuation));\n-  Return(CallStub(stub, context, receiver, callbackfn, this_arg, array,\n-                  receiver, initial_k, len, to));\n+  Return(CallBuiltin(Builtins::kArrayFilterLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, array, receiver, initial_k, len,\n+                     to));\n }\n \n TF_BUILTIN(ArrayFilterLoopLazyDeoptContinuation,\n@@ -2077,10 +2446,9 @@ TF_BUILTIN(ArrayFilterLoopLazyDeoptContinuation,\n   // Increment k.\n   initial_k = NumberInc(initial_k);\n \n-  Callable stub(\n-      Builtins::CallableFor(isolate(), Builtins::kArrayFilterLoopContinuation));\n-  Return(CallStub(stub, context, receiver, callbackfn, this_arg, array,\n-                  receiver, initial_k, len, to.value()));\n+  Return(CallBuiltin(Builtins::kArrayFilterLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, array, receiver, initial_k, len,\n+                     to.value()));\n }\n \n TF_BUILTIN(ArrayFilter, ArrayBuiltinCodeStubAssembler) {\n@@ -2101,7 +2469,8 @@ TF_BUILTIN(ArrayFilter, ArrayBuiltinCodeStubAssembler) {\n       &ArrayBuiltinCodeStubAssembler::FilterResultGenerator,\n       &ArrayBuiltinCodeStubAssembler::FilterProcessor,\n       &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n-      Builtins::CallableFor(isolate(), Builtins::kArrayFilterLoopContinuation));\n+      Builtins::CallableFor(isolate(), Builtins::kArrayFilterLoopContinuation),\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(ArrayMapLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n@@ -2121,7 +2490,8 @@ TF_BUILTIN(ArrayMapLoopContinuation, ArrayBuiltinCodeStubAssembler) {\n \n   GenerateIteratingArrayBuiltinLoopContinuation(\n       &ArrayBuiltinCodeStubAssembler::SpecCompliantMapProcessor,\n-      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction);\n+      &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(ArrayMapLoopEagerDeoptContinuation, ArrayBuiltinCodeStubAssembler) {\n@@ -2133,10 +2503,9 @@ TF_BUILTIN(ArrayMapLoopEagerDeoptContinuation, ArrayBuiltinCodeStubAssembler) {\n   Node* initial_k = Parameter(Descriptor::kInitialK);\n   Node* len = Parameter(Descriptor::kLength);\n \n-  Callable stub(\n-      Builtins::CallableFor(isolate(), Builtins::kArrayMapLoopContinuation));\n-  Return(CallStub(stub, context, receiver, callbackfn, this_arg, array,\n-                  receiver, initial_k, len, UndefinedConstant()));\n+  Return(CallBuiltin(Builtins::kArrayMapLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, array, receiver, initial_k, len,\n+                     UndefinedConstant()));\n }\n \n TF_BUILTIN(ArrayMapLoopLazyDeoptContinuation, ArrayBuiltinCodeStubAssembler) {\n@@ -2159,10 +2528,9 @@ TF_BUILTIN(ArrayMapLoopLazyDeoptContinuation, ArrayBuiltinCodeStubAssembler) {\n   // Then we have to increment k before going on.\n   initial_k = NumberInc(initial_k);\n \n-  Callable stub(\n-      Builtins::CallableFor(isolate(), Builtins::kArrayMapLoopContinuation));\n-  Return(CallStub(stub, context, receiver, callbackfn, this_arg, array,\n-                  receiver, initial_k, len, UndefinedConstant()));\n+  Return(CallBuiltin(Builtins::kArrayMapLoopContinuation, context, receiver,\n+                     callbackfn, this_arg, array, receiver, initial_k, len,\n+                     UndefinedConstant()));\n }\n \n TF_BUILTIN(ArrayMap, ArrayBuiltinCodeStubAssembler) {\n@@ -2182,7 +2550,8 @@ TF_BUILTIN(ArrayMap, ArrayBuiltinCodeStubAssembler) {\n       \"Array.prototype.map\", &ArrayBuiltinCodeStubAssembler::MapResultGenerator,\n       &ArrayBuiltinCodeStubAssembler::FastMapProcessor,\n       &ArrayBuiltinCodeStubAssembler::NullPostLoopAction,\n-      Builtins::CallableFor(isolate(), Builtins::kArrayMapLoopContinuation));\n+      Builtins::CallableFor(isolate(), Builtins::kArrayMapLoopContinuation),\n+      MissingPropertyMode::kSkip);\n }\n \n TF_BUILTIN(TypedArrayPrototypeMap, ArrayBuiltinCodeStubAssembler) {\n@@ -2848,7 +3217,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {\n           {\n             Label if_invalid(this, Label::kDeferred);\n             // A fast array iterator transitioned to a slow iterator during\n-            // iteration. Invalidate fast_array_iteration_prtoector cell to\n+            // iteration. Invalidate fast_array_iteration_protector cell to\n             // prevent potential deopt loops.\n             StoreObjectFieldNoWriteBarrier(\n                 iterator, JSArrayIterator::kIteratedObjectMapOffset,\n@@ -2877,7 +3246,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {\n         length = var_length.value();\n       }\n \n-      GotoIfNumericGreaterThanOrEqual(index, length, &set_done);\n+      GotoIfNumberGreaterThanOrEqual(index, length, &set_done);\n \n       StoreObjectField(iterator, JSArrayIterator::kNextIndexOffset,\n                        NumberInc(index));"
        },
        {
            "sha": "0cdcb57a3f9b8613afcaa6bdcc170b247bd5ae5b",
            "filename": "deps/v8/src/builtins/builtins-async-gen.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -161,6 +161,7 @@ void AsyncBuiltinsAssembler::InitializeNativeClosure(Node* context,\n   CSA_ASSERT(this, WordEqual(LoadMapInstanceSizeInWords(function_map),\n                              IntPtrConstant(JSFunction::kSizeWithoutPrototype /\n                                             kPointerSize)));\n+  STATIC_ASSERT(JSFunction::kSizeWithoutPrototype == 7 * kPointerSize);\n   StoreMapNoWriteBarrier(function, function_map);\n   StoreObjectFieldRoot(function, JSObject::kPropertiesOrHashOffset,\n                        Heap::kEmptyFixedArrayRootIndex);"
        },
        {
            "sha": "392040c9955537942240e96170f6dea9b944611e",
            "filename": "deps/v8/src/builtins/builtins-collections-gen.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-collections-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-collections-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-collections-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -232,10 +232,9 @@ void BaseCollectionsAssembler::AddConstructorEntriesFromIterable(\n \n   TNode<Object> add_func = GetAddFunction(variant, context, collection);\n   IteratorBuiltinsAssembler iterator_assembler(this->state());\n-  TNode<Object> iterator =\n-      CAST(iterator_assembler.GetIterator(context, iterable));\n+  IteratorRecord iterator = iterator_assembler.GetIterator(context, iterable);\n \n-  CSA_ASSERT(this, Word32BinaryNot(IsUndefined(iterator)));\n+  CSA_ASSERT(this, Word32BinaryNot(IsUndefined(iterator.object)));\n \n   TNode<Object> fast_iterator_result_map =\n       LoadContextElement(native_context, Context::ITERATOR_RESULT_MAP_INDEX);"
        },
        {
            "sha": "5c3883a870ead417f2ac154e5ab7ee507d80cc8a",
            "filename": "deps/v8/src/builtins/builtins-constructor-gen.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -134,6 +134,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewClosure(Node* shared_info,\n \n     BIND(&cell_done);\n   }\n+  STATIC_ASSERT(JSFunction::kSizeWithoutPrototype == 7 * kPointerSize);\n   StoreObjectFieldNoWriteBarrier(result, JSFunction::kFeedbackVectorOffset,\n                                  literals_cell);\n   StoreObjectFieldNoWriteBarrier(result, JSFunction::kSharedFunctionInfoOffset,\n@@ -457,10 +458,10 @@ Node* ConstructorBuiltinsAssembler::EmitCreateShallowObjectLiteral(\n   VARIABLE(var_properties, MachineRepresentation::kTagged);\n   {\n     Node* bit_field_3 = LoadMapBitField3(boilerplate_map);\n-    GotoIf(IsSetWord32<Map::Deprecated>(bit_field_3), call_runtime);\n+    GotoIf(IsSetWord32<Map::IsDeprecatedBit>(bit_field_3), call_runtime);\n     // Directly copy over the property store for dict-mode boilerplates.\n     Label if_dictionary(this), if_fast(this), done(this);\n-    Branch(IsSetWord32<Map::DictionaryMap>(bit_field_3), &if_dictionary,\n+    Branch(IsSetWord32<Map::IsDictionaryMapBit>(bit_field_3), &if_dictionary,\n            &if_fast);\n     BIND(&if_dictionary);\n     {\n@@ -636,8 +637,8 @@ Node* ConstructorBuiltinsAssembler::EmitCreateEmptyObjectLiteral(\n   CSA_ASSERT(this, IsMap(map));\n   // Ensure that slack tracking is disabled for the map.\n   STATIC_ASSERT(Map::kNoSlackTracking == 0);\n-  CSA_ASSERT(this,\n-             IsClearWord32<Map::ConstructionCounter>(LoadMapBitField3(map)));\n+  CSA_ASSERT(\n+      this, IsClearWord32<Map::ConstructionCounterBits>(LoadMapBitField3(map)));\n   Node* empty_fixed_array = EmptyFixedArrayConstant();\n   Node* result =\n       AllocateJSObjectFromMap(map, empty_fixed_array, empty_fixed_array);"
        },
        {
            "sha": "98e0f2c8b2bd1e3eb1dcf4ed15b53a16bcc3dac8",
            "filename": "deps/v8/src/builtins/builtins-conversion-gen.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 5,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-conversion-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-conversion-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-conversion-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -99,10 +99,9 @@ TF_BUILTIN(NonPrimitiveToPrimitive_String, ConversionBuiltinsAssembler) {\n }\n \n TF_BUILTIN(StringToNumber, CodeStubAssembler) {\n-  Node* context = Parameter(Descriptor::kContext);\n   Node* input = Parameter(Descriptor::kArgument);\n \n-  Return(StringToNumber(context, input));\n+  Return(StringToNumber(input));\n }\n \n TF_BUILTIN(ToName, CodeStubAssembler) {\n@@ -145,10 +144,9 @@ TF_BUILTIN(ToNumber, CodeStubAssembler) {\n \n // ES section #sec-tostring-applied-to-the-number-type\n TF_BUILTIN(NumberToString, CodeStubAssembler) {\n-  Node* context = Parameter(Descriptor::kContext);\n   Node* input = Parameter(Descriptor::kArgument);\n \n-  Return(NumberToString(context, input));\n+  Return(NumberToString(input));\n }\n \n // ES section #sec-tostring\n@@ -330,7 +328,14 @@ TF_BUILTIN(ToInteger, CodeStubAssembler) {\n   Node* context = Parameter(Descriptor::kContext);\n   Node* input = Parameter(Descriptor::kArgument);\n \n-  Return(ToInteger(context, input));\n+  Return(ToInteger(context, input, kNoTruncation));\n+}\n+\n+TF_BUILTIN(ToInteger_TruncateMinusZero, CodeStubAssembler) {\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* input = Parameter(Descriptor::kArgument);\n+\n+  Return(ToInteger(context, input, kTruncateMinusZero));\n }\n \n // ES6 section 7.1.13 ToObject (argument)"
        },
        {
            "sha": "0ffd15df7c08fa9ac684f0528b57f22d521f185c",
            "filename": "deps/v8/src/builtins/builtins-definitions.h",
            "status": "modified",
            "additions": 64,
            "deletions": 21,
            "changes": 85,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-definitions.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-definitions.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-definitions.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -91,8 +91,9 @@ namespace internal {\n   ASM(StackCheck)                                                              \\\n                                                                                \\\n   /* String helpers */                                                         \\\n-  TFC(StringCharAt, StringCharAt, 1)                                           \\\n-  TFC(StringCharCodeAt, StringCharCodeAt, 1)                                   \\\n+  TFC(StringCharAt, StringAt, 1)                                               \\\n+  TFC(StringCharCodeAt, StringAt, 1)                                           \\\n+  TFC(StringCodePointAt, StringAt, 1)                                          \\\n   TFC(StringEqual, Compare, 1)                                                 \\\n   TFC(StringGreaterThan, Compare, 1)                                           \\\n   TFC(StringGreaterThanOrEqual, Compare, 1)                                    \\\n@@ -190,6 +191,7 @@ namespace internal {\n   TFC(NumberToString, TypeConversion, 1)                                       \\\n   TFC(ToString, TypeConversion, 1)                                             \\\n   TFC(ToInteger, TypeConversion, 1)                                            \\\n+  TFC(ToInteger_TruncateMinusZero, TypeConversion, 1)                          \\\n   TFC(ToLength, TypeConversion, 1)                                             \\\n   TFC(ClassOf, Typeof, 1)                                                      \\\n   TFC(Typeof, Typeof, 1)                                                       \\\n@@ -199,41 +201,37 @@ namespace internal {\n   TFC(ToBooleanLazyDeoptContinuation, TypeConversionStackParameter, 1)         \\\n                                                                                \\\n   /* Handlers */                                                               \\\n-  TFH(LoadICProtoArray, LoadICProtoArray)                                      \\\n-  TFH(LoadICProtoArrayThrowIfNonexistent, LoadICProtoArray)                    \\\n   TFH(KeyedLoadIC_Megamorphic, LoadWithVector)                                 \\\n-  TFH(KeyedLoadIC_Miss, LoadWithVector)                                        \\\n   TFH(KeyedLoadIC_PolymorphicName, LoadWithVector)                             \\\n   TFH(KeyedLoadIC_Slow, LoadWithVector)                                        \\\n   TFH(KeyedStoreIC_Megamorphic, StoreWithVector)                               \\\n-  TFH(KeyedStoreIC_Miss, StoreWithVector)                                      \\\n   TFH(KeyedStoreIC_Slow, StoreWithVector)                                      \\\n-  TFH(LoadGlobalIC_Miss, LoadGlobalWithVector)                                 \\\n-  TFH(LoadGlobalIC_Slow, LoadGlobalWithVector)                                 \\\n+  TFH(LoadGlobalIC_Slow, LoadWithVector)                                       \\\n   TFH(LoadField, LoadField)                                                    \\\n   TFH(LoadIC_FunctionPrototype, LoadWithVector)                                \\\n-  TFH(LoadIC_Miss, LoadWithVector)                                             \\\n   TFH(LoadIC_Slow, LoadWithVector)                                             \\\n   TFH(LoadIC_StringLength, LoadWithVector)                                     \\\n   TFH(LoadIC_StringWrapperLength, LoadWithVector)                              \\\n   TFH(LoadIC_Uninitialized, LoadWithVector)                                    \\\n   TFH(StoreGlobalIC_Slow, StoreWithVector)                                     \\\n-  TFH(StoreIC_Miss, StoreWithVector)                                           \\\n   TFH(StoreIC_Uninitialized, StoreWithVector)                                  \\\n                                                                                \\\n   /* Promise helpers */                                                        \\\n   TFS(ResolveNativePromise, kPromise, kValue)                                  \\\n   TFS(RejectNativePromise, kPromise, kValue, kDebugEvent)                      \\\n   TFS(PerformNativePromiseThen, kPromise, kResolveReaction, kRejectReaction,   \\\n       kResultPromise)                                                          \\\n+  TFS(EnqueueMicrotask, kMicrotask)                                            \\\n+  TFC(RunMicrotasks, RunMicrotasks, 1)                                         \\\n+  TFS(PromiseResolveThenableJob, kMicrotask)                                   \\\n                                                                                \\\n   /* Object property helpers */                                                \\\n   TFS(HasProperty, kKey, kObject)                                              \\\n   TFS(DeleteProperty, kObject, kKey, kLanguageMode)                            \\\n                                                                                \\\n   /* Abort */                                                                  \\\n   ASM(Abort)                                                                   \\\n-  ASM(AbortJS)                                                                 \\\n+  TFC(AbortJS, AbortJS, 1)                                                     \\\n                                                                                \\\n   /* Built-in functions for Javascript */                                      \\\n   /* Special internal builtins */                                              \\\n@@ -255,16 +253,16 @@ namespace internal {\n   TFJ(ArrayIndexOf, SharedFunctionInfo::kDontAdaptArgumentsSentinel)           \\\n   /* ES6 #sec-array.prototype.pop */                                           \\\n   CPP(ArrayPop)                                                                \\\n-  TFJ(FastArrayPop, SharedFunctionInfo::kDontAdaptArgumentsSentinel)           \\\n+  TFJ(ArrayPrototypePop, SharedFunctionInfo::kDontAdaptArgumentsSentinel)      \\\n   /* ES6 #sec-array.prototype.push */                                          \\\n   CPP(ArrayPush)                                                               \\\n-  TFJ(FastArrayPush, SharedFunctionInfo::kDontAdaptArgumentsSentinel)          \\\n+  TFJ(ArrayPrototypePush, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \\\n   /* ES6 #sec-array.prototype.shift */                                         \\\n   CPP(ArrayShift)                                                              \\\n-  TFJ(FastArrayShift, SharedFunctionInfo::kDontAdaptArgumentsSentinel)         \\\n+  TFJ(ArrayPrototypeShift, SharedFunctionInfo::kDontAdaptArgumentsSentinel)    \\\n   /* ES6 #sec-array.prototype.slice */                                         \\\n   CPP(ArraySlice)                                                              \\\n-  TFJ(FastArraySlice, SharedFunctionInfo::kDontAdaptArgumentsSentinel)         \\\n+  TFJ(ArrayPrototypeSlice, SharedFunctionInfo::kDontAdaptArgumentsSentinel)    \\\n   /* ES6 #sec-array.prototype.splice */                                        \\\n   CPP(ArraySplice)                                                             \\\n   /* ES6 #sec-array.prototype.unshift */                                       \\\n@@ -283,10 +281,18 @@ namespace internal {\n   /* ES6 #sec-array.prototype.every */                                         \\\n   TFS(ArrayEveryLoopContinuation, kReceiver, kCallbackFn, kThisArg, kArray,    \\\n       kObject, kInitialK, kLength, kTo)                                        \\\n+  TFJ(ArrayEveryLoopEagerDeoptContinuation, 4, kCallbackFn, kThisArg,          \\\n+      kInitialK, kLength)                                                      \\\n+  TFJ(ArrayEveryLoopLazyDeoptContinuation, 5, kCallbackFn, kThisArg,           \\\n+      kInitialK, kLength, kResult)                                             \\\n   TFJ(ArrayEvery, SharedFunctionInfo::kDontAdaptArgumentsSentinel)             \\\n   /* ES6 #sec-array.prototype.some */                                          \\\n   TFS(ArraySomeLoopContinuation, kReceiver, kCallbackFn, kThisArg, kArray,     \\\n       kObject, kInitialK, kLength, kTo)                                        \\\n+  TFJ(ArraySomeLoopEagerDeoptContinuation, 4, kCallbackFn, kThisArg,           \\\n+      kInitialK, kLength)                                                      \\\n+  TFJ(ArraySomeLoopLazyDeoptContinuation, 5, kCallbackFn, kThisArg, kInitialK, \\\n+      kLength, kResult)                                                        \\\n   TFJ(ArraySome, SharedFunctionInfo::kDontAdaptArgumentsSentinel)              \\\n   /* ES6 #sec-array.prototype.filter */                                        \\\n   TFS(ArrayFilterLoopContinuation, kReceiver, kCallbackFn, kThisArg, kArray,   \\\n@@ -307,13 +313,42 @@ namespace internal {\n   /* ES6 #sec-array.prototype.reduce */                                        \\\n   TFS(ArrayReduceLoopContinuation, kReceiver, kCallbackFn, kThisArg,           \\\n       kAccumulator, kObject, kInitialK, kLength, kTo)                          \\\n+  TFJ(ArrayReduceLoopEagerDeoptContinuation, 4, kCallbackFn, kInitialK,        \\\n+      kLength, kAccumulator)                                                   \\\n+  TFJ(ArrayReduceLoopLazyDeoptContinuation, 4, kCallbackFn, kInitialK,         \\\n+      kLength, kResult)                                                        \\\n   TFJ(ArrayReduce, SharedFunctionInfo::kDontAdaptArgumentsSentinel)            \\\n   /* ES6 #sec-array.prototype.reduceRight */                                   \\\n   TFS(ArrayReduceRightLoopContinuation, kReceiver, kCallbackFn, kThisArg,      \\\n       kAccumulator, kObject, kInitialK, kLength, kTo)                          \\\n+  TFJ(ArrayReduceRightLoopEagerDeoptContinuation, 4, kCallbackFn, kInitialK,   \\\n+      kLength, kAccumulator)                                                   \\\n+  TFJ(ArrayReduceRightLoopLazyDeoptContinuation, 4, kCallbackFn, kInitialK,    \\\n+      kLength, kResult)                                                        \\\n   TFJ(ArrayReduceRight, SharedFunctionInfo::kDontAdaptArgumentsSentinel)       \\\n   /* ES6 #sec-array.prototype.entries */                                       \\\n   TFJ(ArrayPrototypeEntries, 0)                                                \\\n+  /* ES6 #sec-array.prototype.find */                                          \\\n+  TFS(ArrayFindLoopContinuation, kReceiver, kCallbackFn, kThisArg, kArray,     \\\n+      kObject, kInitialK, kLength, kTo)                                        \\\n+  TFJ(ArrayFindLoopEagerDeoptContinuation, 4, kCallbackFn, kThisArg,           \\\n+      kInitialK, kLength)                                                      \\\n+  TFJ(ArrayFindLoopLazyDeoptContinuation, 5, kCallbackFn, kThisArg, kInitialK, \\\n+      kLength, kResult)                                                        \\\n+  TFJ(ArrayFindLoopAfterCallbackLazyDeoptContinuation, 6, kCallbackFn,         \\\n+      kThisArg, kInitialK, kLength, kFoundValue, kIsFound)                     \\\n+  TFJ(ArrayPrototypeFind, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \\\n+  /* ES6 #sec-array.prototype.findIndex */                                     \\\n+  TFS(ArrayFindIndexLoopContinuation, kReceiver, kCallbackFn, kThisArg,        \\\n+      kArray, kObject, kInitialK, kLength, kTo)                                \\\n+  TFJ(ArrayFindIndexLoopEagerDeoptContinuation, 4, kCallbackFn, kThisArg,      \\\n+      kInitialK, kLength)                                                      \\\n+  TFJ(ArrayFindIndexLoopLazyDeoptContinuation, 5, kCallbackFn, kThisArg,       \\\n+      kInitialK, kLength, kResult)                                             \\\n+  TFJ(ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation, 6, kCallbackFn,    \\\n+      kThisArg, kInitialK, kLength, kFoundValue, kIsFound)                     \\\n+  TFJ(ArrayPrototypeFindIndex,                                                 \\\n+      SharedFunctionInfo::kDontAdaptArgumentsSentinel)                         \\\n   /* ES6 #sec-array.prototype.keys */                                          \\\n   TFJ(ArrayPrototypeKeys, 0)                                                   \\\n   /* ES6 #sec-array.prototype.values */                                        \\\n@@ -555,6 +590,8 @@ namespace internal {\n   TFH(LoadICTrampoline, Load)                                                  \\\n   TFH(KeyedLoadIC, LoadWithVector)                                             \\\n   TFH(KeyedLoadICTrampoline, Load)                                             \\\n+  TFH(StoreGlobalIC, StoreGlobalWithVector)                                    \\\n+  TFH(StoreGlobalICTrampoline, StoreGlobal)                                    \\\n   TFH(StoreIC, StoreWithVector)                                                \\\n   TFH(StoreICTrampoline, Store)                                                \\\n   TFH(KeyedStoreIC, StoreWithVector)                                           \\\n@@ -718,7 +755,7 @@ namespace internal {\n   CPP(ObjectDefineProperties)                                                  \\\n   CPP(ObjectDefineProperty)                                                    \\\n   CPP(ObjectDefineSetter)                                                      \\\n-  CPP(ObjectEntries)                                                           \\\n+  TFJ(ObjectEntries, 1, kObject)                                               \\\n   CPP(ObjectFreeze)                                                            \\\n   TFJ(ObjectGetOwnPropertyDescriptor,                                          \\\n       SharedFunctionInfo::kDontAdaptArgumentsSentinel)                         \\\n@@ -745,8 +782,10 @@ namespace internal {\n   CPP(ObjectPrototypePropertyIsEnumerable)                                     \\\n   CPP(ObjectPrototypeGetProto)                                                 \\\n   CPP(ObjectPrototypeSetProto)                                                 \\\n+  /* ES #sec-object.prototype.tolocalestring */                                \\\n+  TFJ(ObjectPrototypeToLocaleString, 0)                                        \\\n   CPP(ObjectSeal)                                                              \\\n-  CPP(ObjectValues)                                                            \\\n+  TFJ(ObjectValues, 1, kObject)                                                \\\n                                                                                \\\n   /* instanceof */                                                             \\\n   TFC(OrdinaryHasInstance, Compare, 1)                                         \\\n@@ -771,21 +810,23 @@ namespace internal {\n   TFJ(PromiseRejectClosure, 1, kValue)                                         \\\n   TFJ(PromiseAllResolveElementClosure, 1, kValue)                              \\\n   /* ES #sec-promise.prototype.then */                                         \\\n-  TFJ(PromiseThen, 2, kOnFullfilled, kOnRejected)                              \\\n+  TFJ(PromisePrototypeThen, 2, kOnFullfilled, kOnRejected)                     \\\n   /* ES #sec-promise.prototype.catch */                                        \\\n-  TFJ(PromiseCatch, 1, kOnRejected)                                            \\\n+  TFJ(PromisePrototypeCatch, 1, kOnRejected)                                   \\\n   /* ES #sec-fulfillpromise */                                                 \\\n   TFJ(ResolvePromise, 2, kPromise, kValue)                                     \\\n   TFS(PromiseHandleReject, kPromise, kOnReject, kException)                    \\\n-  TFJ(PromiseHandle, 5, kValue, kHandler, kDeferredPromise,                    \\\n+  TFS(PromiseHandle, kValue, kHandler, kDeferredPromise, kDeferredOnResolve,   \\\n+      kDeferredOnReject)                                                       \\\n+  TFJ(PromiseHandleJS, 5, kValue, kHandler, kDeferredPromise,                  \\\n       kDeferredOnResolve, kDeferredOnReject)                                   \\\n   /* ES #sec-promise.resolve */                                                \\\n   TFJ(PromiseResolveWrapper, 1, kValue)                                        \\\n   TFS(PromiseResolve, kConstructor, kValue)                                    \\\n   /* ES #sec-promise.reject */                                                 \\\n   TFJ(PromiseReject, 1, kReason)                                               \\\n   TFJ(InternalPromiseReject, 3, kPromise, kReason, kDebugEvent)                \\\n-  TFJ(PromiseFinally, 1, kOnFinally)                                           \\\n+  TFJ(PromisePrototypeFinally, 1, kOnFinally)                                  \\\n   TFJ(PromiseThenFinally, 1, kValue)                                           \\\n   TFJ(PromiseCatchFinally, 1, kReason)                                         \\\n   TFJ(PromiseValueThunkFinally, 0)                                             \\\n@@ -799,6 +840,8 @@ namespace internal {\n   TFJ(ProxyConstructor, 0)                                                     \\\n   TFJ(ProxyConstructor_ConstructStub,                                          \\\n       SharedFunctionInfo::kDontAdaptArgumentsSentinel)                         \\\n+  TFJ(ProxyRevocable, 2, kTarget, kHandler)                                    \\\n+  TFJ(ProxyRevoke, 0)                                                          \\\n   TFS(ProxyGetProperty, kProxy, kName, kReceiverValue)                         \\\n   TFS(ProxyHasProperty, kProxy, kName)                                         \\\n   TFS(ProxySetProperty, kProxy, kName, kValue, kReceiverValue, kLanguageMode)  \\"
        },
        {
            "sha": "7c1db5093db7fd96e7b1bcdd3e48972cf6e4236b",
            "filename": "deps/v8/src/builtins/builtins-function-gen.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-function-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-function-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-function-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -6,7 +6,6 @@\n #include \"src/builtins/builtins.h\"\n #include \"src/code-stub-assembler.h\"\n #include \"src/frame-constants.h\"\n-#include \"src/zone/zone-list-inl.h\"  // TODO(mstarzinger): Temporary cycle breaker.\n \n namespace v8 {\n namespace internal {"
        },
        {
            "sha": "48c28ab730781ebb13d9e220572202c43d7c9267",
            "filename": "deps/v8/src/builtins/builtins-handler-gen.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 54,
            "changes": 54,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-handler-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-handler-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-handler-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -23,17 +23,6 @@ TF_BUILTIN(LoadIC_StringWrapperLength, CodeStubAssembler) {\n   Return(LoadStringLengthAsSmi(string));\n }\n \n-TF_BUILTIN(KeyedLoadIC_Miss, CodeStubAssembler) {\n-  Node* receiver = Parameter(Descriptor::kReceiver);\n-  Node* name = Parameter(Descriptor::kName);\n-  Node* slot = Parameter(Descriptor::kSlot);\n-  Node* vector = Parameter(Descriptor::kVector);\n-  Node* context = Parameter(Descriptor::kContext);\n-\n-  TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, name, slot,\n-                  vector);\n-}\n-\n TF_BUILTIN(KeyedLoadIC_Slow, CodeStubAssembler) {\n   Node* receiver = Parameter(Descriptor::kReceiver);\n   Node* name = Parameter(Descriptor::kName);\n@@ -52,18 +41,6 @@ void Builtins::Generate_StoreIC_Uninitialized(\n   StoreICUninitializedGenerator::Generate(state);\n }\n \n-TF_BUILTIN(KeyedStoreIC_Miss, CodeStubAssembler) {\n-  Node* receiver = Parameter(Descriptor::kReceiver);\n-  Node* name = Parameter(Descriptor::kName);\n-  Node* value = Parameter(Descriptor::kValue);\n-  Node* slot = Parameter(Descriptor::kSlot);\n-  Node* vector = Parameter(Descriptor::kVector);\n-  Node* context = Parameter(Descriptor::kContext);\n-\n-  TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context, value, slot, vector,\n-                  receiver, name);\n-}\n-\n TF_BUILTIN(KeyedStoreIC_Slow, CodeStubAssembler) {\n   Node* receiver = Parameter(Descriptor::kReceiver);\n   Node* name = Parameter(Descriptor::kName);\n@@ -78,15 +55,6 @@ TF_BUILTIN(KeyedStoreIC_Slow, CodeStubAssembler) {\n                   receiver, name);\n }\n \n-TF_BUILTIN(LoadGlobalIC_Miss, CodeStubAssembler) {\n-  Node* name = Parameter(Descriptor::kName);\n-  Node* slot = Parameter(Descriptor::kSlot);\n-  Node* vector = Parameter(Descriptor::kVector);\n-  Node* context = Parameter(Descriptor::kContext);\n-\n-  TailCallRuntime(Runtime::kLoadGlobalIC_Miss, context, name, slot, vector);\n-}\n-\n TF_BUILTIN(LoadGlobalIC_Slow, CodeStubAssembler) {\n   Node* name = Parameter(Descriptor::kName);\n   Node* slot = Parameter(Descriptor::kSlot);\n@@ -110,16 +78,6 @@ TF_BUILTIN(LoadIC_FunctionPrototype, CodeStubAssembler) {\n   TailCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name, slot, vector);\n }\n \n-TF_BUILTIN(LoadIC_Miss, CodeStubAssembler) {\n-  Node* receiver = Parameter(Descriptor::kReceiver);\n-  Node* name = Parameter(Descriptor::kName);\n-  Node* slot = Parameter(Descriptor::kSlot);\n-  Node* vector = Parameter(Descriptor::kVector);\n-  Node* context = Parameter(Descriptor::kContext);\n-\n-  TailCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name, slot, vector);\n-}\n-\n TF_BUILTIN(LoadIC_Slow, CodeStubAssembler) {\n   Node* receiver = Parameter(Descriptor::kReceiver);\n   Node* name = Parameter(Descriptor::kName);\n@@ -128,18 +86,6 @@ TF_BUILTIN(LoadIC_Slow, CodeStubAssembler) {\n   TailCallRuntime(Runtime::kGetProperty, context, receiver, name);\n }\n \n-TF_BUILTIN(StoreIC_Miss, CodeStubAssembler) {\n-  Node* receiver = Parameter(Descriptor::kReceiver);\n-  Node* name = Parameter(Descriptor::kName);\n-  Node* value = Parameter(Descriptor::kValue);\n-  Node* slot = Parameter(Descriptor::kSlot);\n-  Node* vector = Parameter(Descriptor::kVector);\n-  Node* context = Parameter(Descriptor::kContext);\n-\n-  TailCallRuntime(Runtime::kStoreIC_Miss, context, value, slot, vector,\n-                  receiver, name);\n-}\n-\n TF_BUILTIN(StoreGlobalIC_Slow, CodeStubAssembler) {\n   Node* receiver = Parameter(Descriptor::kReceiver);\n   Node* name = Parameter(Descriptor::kName);"
        },
        {
            "sha": "94613a6a32ce02956cb5af1fc4c8e43376c5e583",
            "filename": "deps/v8/src/builtins/builtins-ic-gen.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-ic-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-ic-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-ic-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -29,6 +29,8 @@ IC_BUILTIN(LoadField)\n IC_BUILTIN(KeyedLoadICTrampoline)\n IC_BUILTIN(KeyedLoadIC_Megamorphic)\n IC_BUILTIN(KeyedLoadIC_PolymorphicName)\n+IC_BUILTIN(StoreGlobalIC)\n+IC_BUILTIN(StoreGlobalICTrampoline)\n IC_BUILTIN(StoreIC)\n IC_BUILTIN(StoreICTrampoline)\n IC_BUILTIN(KeyedStoreIC)\n@@ -40,8 +42,6 @@ IC_BUILTIN_PARAM(LoadGlobalICTrampoline, LoadGlobalICTrampoline,\n                  NOT_INSIDE_TYPEOF)\n IC_BUILTIN_PARAM(LoadGlobalICInsideTypeofTrampoline, LoadGlobalICTrampoline,\n                  INSIDE_TYPEOF)\n-IC_BUILTIN_PARAM(LoadICProtoArray, LoadICProtoArray, false)\n-IC_BUILTIN_PARAM(LoadICProtoArrayThrowIfNonexistent, LoadICProtoArray, true)\n \n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "bb4b66e3a4646154ba22b1ece5f76d559ebb62ce",
            "filename": "deps/v8/src/builtins/builtins-internal-gen.cc",
            "status": "modified",
            "additions": 448,
            "deletions": 1,
            "changes": 449,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-internal-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-internal-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-internal-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n+#include \"src/api.h\"\n #include \"src/builtins/builtins-utils-gen.h\"\n #include \"src/builtins/builtins.h\"\n #include \"src/code-stub-assembler.h\"\n@@ -13,6 +14,9 @@\n namespace v8 {\n namespace internal {\n \n+template <typename T>\n+using TNode = compiler::TNode<T>;\n+\n // -----------------------------------------------------------------------------\n // Interrupt and stack checks.\n \n@@ -583,7 +587,7 @@ TF_BUILTIN(ForInFilter, CodeStubAssembler) {\n   CSA_ASSERT(this, IsString(key));\n \n   Label if_true(this), if_false(this);\n-  Node* result = HasProperty(object, key, context, kForInHasProperty);\n+  TNode<Oddball> result = HasProperty(object, key, context, kForInHasProperty);\n   Branch(IsTrue(result), &if_true, &if_false);\n \n   BIND(&if_true);\n@@ -607,5 +611,448 @@ TF_BUILTIN(SameValue, CodeStubAssembler) {\n   Return(FalseConstant());\n }\n \n+class InternalBuiltinsAssembler : public CodeStubAssembler {\n+ public:\n+  explicit InternalBuiltinsAssembler(compiler::CodeAssemblerState* state)\n+      : CodeStubAssembler(state) {}\n+\n+  TNode<IntPtrT> GetPendingMicrotaskCount();\n+  void SetPendingMicrotaskCount(TNode<IntPtrT> count);\n+\n+  TNode<FixedArray> GetMicrotaskQueue();\n+  void SetMicrotaskQueue(TNode<FixedArray> queue);\n+\n+  TNode<Context> GetCurrentContext();\n+  void SetCurrentContext(TNode<Context> context);\n+\n+  void EnterMicrotaskContext(TNode<Context> context);\n+  void LeaveMicrotaskContext();\n+\n+  TNode<Object> GetPendingException() {\n+    auto ref = ExternalReference(kPendingExceptionAddress, isolate());\n+    return TNode<Object>::UncheckedCast(\n+        Load(MachineType::AnyTagged(), ExternalConstant(ref)));\n+  }\n+  void ClearPendingException() {\n+    auto ref = ExternalReference(kPendingExceptionAddress, isolate());\n+    StoreNoWriteBarrier(MachineRepresentation::kTagged, ExternalConstant(ref),\n+                        TheHoleConstant());\n+  }\n+\n+  TNode<Object> GetScheduledException() {\n+    auto ref = ExternalReference::scheduled_exception_address(isolate());\n+    return TNode<Object>::UncheckedCast(\n+        Load(MachineType::AnyTagged(), ExternalConstant(ref)));\n+  }\n+  void ClearScheduledException() {\n+    auto ref = ExternalReference::scheduled_exception_address(isolate());\n+    StoreNoWriteBarrier(MachineRepresentation::kTagged, ExternalConstant(ref),\n+                        TheHoleConstant());\n+  }\n+};\n+\n+TNode<IntPtrT> InternalBuiltinsAssembler::GetPendingMicrotaskCount() {\n+  auto ref = ExternalReference::pending_microtask_count_address(isolate());\n+  if (kIntSize == 8) {\n+    return TNode<IntPtrT>::UncheckedCast(\n+        Load(MachineType::Int64(), ExternalConstant(ref)));\n+  } else {\n+    Node* const value = Load(MachineType::Int32(), ExternalConstant(ref));\n+    return ChangeInt32ToIntPtr(value);\n+  }\n+}\n+\n+void InternalBuiltinsAssembler::SetPendingMicrotaskCount(TNode<IntPtrT> count) {\n+  auto ref = ExternalReference::pending_microtask_count_address(isolate());\n+  auto rep = kIntSize == 8 ? MachineRepresentation::kWord64\n+                           : MachineRepresentation::kWord32;\n+  if (kIntSize == 4 && kPointerSize == 8) {\n+    Node* const truncated_count =\n+        TruncateInt64ToInt32(TNode<Int64T>::UncheckedCast(count));\n+    StoreNoWriteBarrier(rep, ExternalConstant(ref), truncated_count);\n+  } else {\n+    StoreNoWriteBarrier(rep, ExternalConstant(ref), count);\n+  }\n+}\n+\n+TNode<FixedArray> InternalBuiltinsAssembler::GetMicrotaskQueue() {\n+  return TNode<FixedArray>::UncheckedCast(\n+      LoadRoot(Heap::kMicrotaskQueueRootIndex));\n+}\n+\n+void InternalBuiltinsAssembler::SetMicrotaskQueue(TNode<FixedArray> queue) {\n+  StoreRoot(Heap::kMicrotaskQueueRootIndex, queue);\n+}\n+\n+TNode<Context> InternalBuiltinsAssembler::GetCurrentContext() {\n+  auto ref = ExternalReference(kContextAddress, isolate());\n+  return TNode<Context>::UncheckedCast(\n+      Load(MachineType::AnyTagged(), ExternalConstant(ref)));\n+}\n+\n+void InternalBuiltinsAssembler::SetCurrentContext(TNode<Context> context) {\n+  auto ref = ExternalReference(kContextAddress, isolate());\n+  StoreNoWriteBarrier(MachineRepresentation::kTagged, ExternalConstant(ref),\n+                      context);\n+}\n+\n+void InternalBuiltinsAssembler::EnterMicrotaskContext(\n+    TNode<Context> microtask_context) {\n+  auto ref = ExternalReference::handle_scope_implementer_address(isolate());\n+  Node* const hsi = Load(MachineType::Pointer(), ExternalConstant(ref));\n+  StoreNoWriteBarrier(\n+      MachineType::PointerRepresentation(), hsi,\n+      IntPtrConstant(HandleScopeImplementerOffsets::kMicrotaskContext),\n+      BitcastTaggedToWord(microtask_context));\n+\n+  // Load mirrored std::vector length from\n+  // HandleScopeImplementer::entered_contexts_count_\n+  auto type = kSizetSize == 8 ? MachineType::Uint64() : MachineType::Uint32();\n+  Node* entered_contexts_length = Load(\n+      type, hsi,\n+      IntPtrConstant(HandleScopeImplementerOffsets::kEnteredContextsCount));\n+\n+  auto rep = kSizetSize == 8 ? MachineRepresentation::kWord64\n+                             : MachineRepresentation::kWord32;\n+\n+  StoreNoWriteBarrier(\n+      rep, hsi,\n+      IntPtrConstant(\n+          HandleScopeImplementerOffsets::kEnteredContextCountDuringMicrotasks),\n+      entered_contexts_length);\n+}\n+\n+void InternalBuiltinsAssembler::LeaveMicrotaskContext() {\n+  auto ref = ExternalReference::handle_scope_implementer_address(isolate());\n+\n+  Node* const hsi = Load(MachineType::Pointer(), ExternalConstant(ref));\n+  StoreNoWriteBarrier(\n+      MachineType::PointerRepresentation(), hsi,\n+      IntPtrConstant(HandleScopeImplementerOffsets::kMicrotaskContext),\n+      IntPtrConstant(0));\n+  if (kSizetSize == 4) {\n+    StoreNoWriteBarrier(\n+        MachineRepresentation::kWord32, hsi,\n+        IntPtrConstant(HandleScopeImplementerOffsets::\n+                           kEnteredContextCountDuringMicrotasks),\n+        Int32Constant(0));\n+  } else {\n+    StoreNoWriteBarrier(\n+        MachineRepresentation::kWord64, hsi,\n+        IntPtrConstant(HandleScopeImplementerOffsets::\n+                           kEnteredContextCountDuringMicrotasks),\n+        Int64Constant(0));\n+  }\n+}\n+\n+TF_BUILTIN(EnqueueMicrotask, InternalBuiltinsAssembler) {\n+  Node* microtask = Parameter(Descriptor::kMicrotask);\n+\n+  TNode<IntPtrT> num_tasks = GetPendingMicrotaskCount();\n+  TNode<IntPtrT> new_num_tasks = IntPtrAdd(num_tasks, IntPtrConstant(1));\n+  TNode<FixedArray> queue = GetMicrotaskQueue();\n+  TNode<IntPtrT> queue_length = LoadAndUntagFixedArrayBaseLength(queue);\n+\n+  Label if_append(this), if_grow(this), done(this);\n+  Branch(WordEqual(num_tasks, queue_length), &if_grow, &if_append);\n+\n+  BIND(&if_grow);\n+  {\n+    // Determine the new queue length and check if we need to allocate\n+    // in large object space (instead of just going to new space, where\n+    // we also know that we don't need any write barriers for setting\n+    // up the new queue object).\n+    Label if_newspace(this), if_lospace(this, Label::kDeferred);\n+    TNode<IntPtrT> new_queue_length =\n+        IntPtrMax(IntPtrConstant(8), IntPtrAdd(num_tasks, num_tasks));\n+    Branch(IntPtrLessThanOrEqual(new_queue_length,\n+                                 IntPtrConstant(FixedArray::kMaxRegularLength)),\n+           &if_newspace, &if_lospace);\n+\n+    BIND(&if_newspace);\n+    {\n+      // This is the likely case where the new queue fits into new space,\n+      // and thus we don't need any write barriers for initializing it.\n+      TNode<FixedArray> new_queue =\n+          CAST(AllocateFixedArray(PACKED_ELEMENTS, new_queue_length));\n+      CopyFixedArrayElements(PACKED_ELEMENTS, queue, new_queue, num_tasks,\n+                             SKIP_WRITE_BARRIER);\n+      StoreFixedArrayElement(new_queue, num_tasks, microtask,\n+                             SKIP_WRITE_BARRIER);\n+      FillFixedArrayWithValue(PACKED_ELEMENTS, new_queue, new_num_tasks,\n+                              new_queue_length, Heap::kUndefinedValueRootIndex);\n+      SetMicrotaskQueue(new_queue);\n+      Goto(&done);\n+    }\n+\n+    BIND(&if_lospace);\n+    {\n+      // The fallback case where the new queue ends up in large object space.\n+      TNode<FixedArray> new_queue = CAST(AllocateFixedArray(\n+          PACKED_ELEMENTS, new_queue_length, INTPTR_PARAMETERS,\n+          AllocationFlag::kAllowLargeObjectAllocation));\n+      CopyFixedArrayElements(PACKED_ELEMENTS, queue, new_queue, num_tasks);\n+      StoreFixedArrayElement(new_queue, num_tasks, microtask);\n+      FillFixedArrayWithValue(PACKED_ELEMENTS, new_queue, new_num_tasks,\n+                              new_queue_length, Heap::kUndefinedValueRootIndex);\n+      SetMicrotaskQueue(new_queue);\n+      Goto(&done);\n+    }\n+  }\n+\n+  BIND(&if_append);\n+  {\n+    StoreFixedArrayElement(queue, num_tasks, microtask);\n+    Goto(&done);\n+  }\n+\n+  BIND(&done);\n+  SetPendingMicrotaskCount(new_num_tasks);\n+  Return(UndefinedConstant());\n+}\n+\n+TF_BUILTIN(RunMicrotasks, InternalBuiltinsAssembler) {\n+  Label init_queue_loop(this);\n+\n+  Goto(&init_queue_loop);\n+  BIND(&init_queue_loop);\n+  {\n+    TVARIABLE(IntPtrT, index, IntPtrConstant(0));\n+    Label loop(this, &index);\n+\n+    TNode<IntPtrT> num_tasks = GetPendingMicrotaskCount();\n+    ReturnIf(IntPtrEqual(num_tasks, IntPtrConstant(0)), UndefinedConstant());\n+\n+    TNode<FixedArray> queue = GetMicrotaskQueue();\n+\n+    CSA_ASSERT(this, IntPtrGreaterThanOrEqual(\n+                         LoadAndUntagFixedArrayBaseLength(queue), num_tasks));\n+    CSA_ASSERT(this, IntPtrGreaterThan(num_tasks, IntPtrConstant(0)));\n+\n+    SetPendingMicrotaskCount(IntPtrConstant(0));\n+    SetMicrotaskQueue(\n+        TNode<FixedArray>::UncheckedCast(EmptyFixedArrayConstant()));\n+\n+    Goto(&loop);\n+    BIND(&loop);\n+    {\n+      TNode<HeapObject> microtask =\n+          TNode<HeapObject>::UncheckedCast(LoadFixedArrayElement(queue, index));\n+      index = IntPtrAdd(index, IntPtrConstant(1));\n+\n+      CSA_ASSERT(this, TaggedIsNotSmi(microtask));\n+\n+      TNode<Map> microtask_map = LoadMap(microtask);\n+      TNode<Int32T> microtask_type = LoadMapInstanceType(microtask_map);\n+\n+      Label is_call_handler_info(this);\n+      Label is_function(this);\n+      Label is_promise_resolve_thenable_job(this);\n+      Label is_promise_reaction_job(this);\n+      Label is_unreachable(this);\n+\n+      int32_t case_values[] = {TUPLE3_TYPE,  // CallHandlerInfo\n+                               JS_FUNCTION_TYPE,\n+                               PROMISE_RESOLVE_THENABLE_JOB_INFO_TYPE,\n+                               PROMISE_REACTION_JOB_INFO_TYPE};\n+\n+      Label* case_labels[] = {&is_call_handler_info, &is_function,\n+                              &is_promise_resolve_thenable_job,\n+                              &is_promise_reaction_job};\n+\n+      static_assert(arraysize(case_values) == arraysize(case_labels), \"\");\n+      Switch(microtask_type, &is_unreachable, case_values, case_labels,\n+             arraysize(case_labels));\n+\n+      BIND(&is_call_handler_info);\n+      {\n+        // Bailout to C++ slow path for the remainder of the loop.\n+        auto index_ref =\n+            ExternalReference(kMicrotaskQueueBailoutIndexAddress, isolate());\n+        auto count_ref =\n+            ExternalReference(kMicrotaskQueueBailoutCountAddress, isolate());\n+        auto rep = kIntSize == 4 ? MachineRepresentation::kWord32\n+                                 : MachineRepresentation::kWord64;\n+\n+        // index was pre-incremented, decrement for bailout to C++.\n+        Node* value = IntPtrSub(index, IntPtrConstant(1));\n+\n+        if (kPointerSize == 4) {\n+          DCHECK_EQ(kIntSize, 4);\n+          StoreNoWriteBarrier(rep, ExternalConstant(index_ref), value);\n+          StoreNoWriteBarrier(rep, ExternalConstant(count_ref), num_tasks);\n+        } else {\n+          Node* count = num_tasks;\n+          if (kIntSize == 4) {\n+            value = TruncateInt64ToInt32(value);\n+            count = TruncateInt64ToInt32(count);\n+          }\n+          StoreNoWriteBarrier(rep, ExternalConstant(index_ref), value);\n+          StoreNoWriteBarrier(rep, ExternalConstant(count_ref), count);\n+        }\n+\n+        Return(queue);\n+      }\n+\n+      BIND(&is_function);\n+      {\n+        Label cont(this);\n+        VARIABLE(exception, MachineRepresentation::kTagged, TheHoleConstant());\n+        TNode<Context> old_context = GetCurrentContext();\n+        TNode<Context> fn_context = TNode<Context>::UncheckedCast(\n+            LoadObjectField(microtask, JSFunction::kContextOffset));\n+        TNode<Context> native_context =\n+            TNode<Context>::UncheckedCast(LoadNativeContext(fn_context));\n+        SetCurrentContext(native_context);\n+        EnterMicrotaskContext(fn_context);\n+        Node* const call = CallJS(CodeFactory::Call(isolate()), native_context,\n+                                  microtask, UndefinedConstant());\n+        GotoIfException(call, &cont);\n+        Goto(&cont);\n+        BIND(&cont);\n+        LeaveMicrotaskContext();\n+        SetCurrentContext(old_context);\n+        Branch(IntPtrLessThan(index, num_tasks), &loop, &init_queue_loop);\n+      }\n+\n+      BIND(&is_promise_resolve_thenable_job);\n+      {\n+        VARIABLE(exception, MachineRepresentation::kTagged, TheHoleConstant());\n+        TNode<Context> old_context = GetCurrentContext();\n+        TNode<Context> microtask_context =\n+            TNode<Context>::UncheckedCast(LoadObjectField(\n+                microtask, PromiseResolveThenableJobInfo::kContextOffset));\n+        TNode<Context> native_context =\n+            TNode<Context>::UncheckedCast(LoadNativeContext(microtask_context));\n+        SetCurrentContext(native_context);\n+        EnterMicrotaskContext(microtask_context);\n+\n+        Label if_unhandled_exception(this), done(this);\n+        Node* const ret = CallBuiltin(Builtins::kPromiseResolveThenableJob,\n+                                      native_context, microtask);\n+        GotoIfException(ret, &if_unhandled_exception, &exception);\n+        Goto(&done);\n+\n+        BIND(&if_unhandled_exception);\n+        CallRuntime(Runtime::kReportMessage, native_context, exception.value());\n+        Goto(&done);\n+\n+        BIND(&done);\n+        LeaveMicrotaskContext();\n+        SetCurrentContext(old_context);\n+\n+        Branch(IntPtrLessThan(index, num_tasks), &loop, &init_queue_loop);\n+      }\n+\n+      BIND(&is_promise_reaction_job);\n+      {\n+        Label if_multiple(this);\n+        Label if_single(this);\n+\n+        Node* const value =\n+            LoadObjectField(microtask, PromiseReactionJobInfo::kValueOffset);\n+        Node* const tasks =\n+            LoadObjectField(microtask, PromiseReactionJobInfo::kTasksOffset);\n+        Node* const deferred_promises = LoadObjectField(\n+            microtask, PromiseReactionJobInfo::kDeferredPromiseOffset);\n+        Node* const deferred_on_resolves = LoadObjectField(\n+            microtask, PromiseReactionJobInfo::kDeferredOnResolveOffset);\n+        Node* const deferred_on_rejects = LoadObjectField(\n+            microtask, PromiseReactionJobInfo::kDeferredOnRejectOffset);\n+\n+        TNode<Context> old_context = GetCurrentContext();\n+        TNode<Context> microtask_context = TNode<Context>::UncheckedCast(\n+            LoadObjectField(microtask, PromiseReactionJobInfo::kContextOffset));\n+        TNode<Context> native_context =\n+            TNode<Context>::UncheckedCast(LoadNativeContext(microtask_context));\n+        SetCurrentContext(native_context);\n+        EnterMicrotaskContext(microtask_context);\n+\n+        Branch(IsFixedArray(deferred_promises), &if_multiple, &if_single);\n+\n+        BIND(&if_single);\n+        {\n+          CallBuiltin(Builtins::kPromiseHandle, native_context, value, tasks,\n+                      deferred_promises, deferred_on_resolves,\n+                      deferred_on_rejects);\n+          LeaveMicrotaskContext();\n+          SetCurrentContext(old_context);\n+          Branch(IntPtrLessThan(index, num_tasks), &loop, &init_queue_loop);\n+        }\n+\n+        BIND(&if_multiple);\n+        {\n+          TVARIABLE(IntPtrT, inner_index, IntPtrConstant(0));\n+          TNode<IntPtrT> inner_length =\n+              LoadAndUntagFixedArrayBaseLength(deferred_promises);\n+          Label inner_loop(this, &inner_index), done(this);\n+\n+          CSA_ASSERT(this, IntPtrGreaterThan(inner_length, IntPtrConstant(0)));\n+          Goto(&inner_loop);\n+          BIND(&inner_loop);\n+          {\n+            Node* const task = LoadFixedArrayElement(tasks, inner_index);\n+            Node* const deferred_promise =\n+                LoadFixedArrayElement(deferred_promises, inner_index);\n+            Node* const deferred_on_resolve =\n+                LoadFixedArrayElement(deferred_on_resolves, inner_index);\n+            Node* const deferred_on_reject =\n+                LoadFixedArrayElement(deferred_on_rejects, inner_index);\n+            CallBuiltin(Builtins::kPromiseHandle, native_context, value, task,\n+                        deferred_promise, deferred_on_resolve,\n+                        deferred_on_reject);\n+            inner_index = IntPtrAdd(inner_index, IntPtrConstant(1));\n+            Branch(IntPtrLessThan(inner_index, inner_length), &inner_loop,\n+                   &done);\n+          }\n+          BIND(&done);\n+\n+          LeaveMicrotaskContext();\n+          SetCurrentContext(old_context);\n+\n+          Branch(IntPtrLessThan(index, num_tasks), &loop, &init_queue_loop);\n+        }\n+      }\n+\n+      BIND(&is_unreachable);\n+      Unreachable();\n+    }\n+  }\n+}\n+\n+TF_BUILTIN(PromiseResolveThenableJob, InternalBuiltinsAssembler) {\n+  VARIABLE(exception, MachineRepresentation::kTagged, TheHoleConstant());\n+  Callable call = CodeFactory::Call(isolate());\n+  Label reject_promise(this, Label::kDeferred);\n+  TNode<PromiseResolveThenableJobInfo> microtask =\n+      TNode<PromiseResolveThenableJobInfo>::UncheckedCast(\n+          Parameter(Descriptor::kMicrotask));\n+  TNode<Context> context =\n+      TNode<Context>::UncheckedCast(Parameter(Descriptor::kContext));\n+\n+  TNode<JSReceiver> thenable = TNode<JSReceiver>::UncheckedCast(LoadObjectField(\n+      microtask, PromiseResolveThenableJobInfo::kThenableOffset));\n+  TNode<JSReceiver> then = TNode<JSReceiver>::UncheckedCast(\n+      LoadObjectField(microtask, PromiseResolveThenableJobInfo::kThenOffset));\n+  TNode<JSFunction> resolve = TNode<JSFunction>::UncheckedCast(LoadObjectField(\n+      microtask, PromiseResolveThenableJobInfo::kResolveOffset));\n+  TNode<JSFunction> reject = TNode<JSFunction>::UncheckedCast(\n+      LoadObjectField(microtask, PromiseResolveThenableJobInfo::kRejectOffset));\n+\n+  Node* const result = CallJS(call, context, then, thenable, resolve, reject);\n+  GotoIfException(result, &reject_promise, &exception);\n+  Return(UndefinedConstant());\n+\n+  BIND(&reject_promise);\n+  CallJS(call, context, reject, UndefinedConstant(), exception.value());\n+  Return(UndefinedConstant());\n+}\n+\n+TF_BUILTIN(AbortJS, CodeStubAssembler) {\n+  Node* message = Parameter(Descriptor::kObject);\n+  Node* reason = SmiConstant(0);\n+  TailCallRuntime(Runtime::kAbortJS, reason, message);\n+}\n+\n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "88641b04e26c168bde6d166dea9bc0586e59a7e7",
            "filename": "deps/v8/src/builtins/builtins-intl-gen.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-intl-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-intl-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-intl-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -8,7 +8,6 @@\n \n #include \"src/builtins/builtins-utils-gen.h\"\n #include \"src/code-stub-assembler.h\"\n-#include \"src/zone/zone-list-inl.h\"  // TODO(mstarzinger): Temporary cycle breaker.\n \n namespace v8 {\n namespace internal {"
        },
        {
            "sha": "f6a6d8588084c0dc6a74c71bca5b59bd6a371421",
            "filename": "deps/v8/src/builtins/builtins-iterator-gen.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 28,
            "changes": 53,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-iterator-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-iterator-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-iterator-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -11,19 +11,20 @@ namespace internal {\n \n using compiler::Node;\n \n-Node* IteratorBuiltinsAssembler::GetIterator(Node* context, Node* object,\n-                                             Label* if_exception,\n-                                             Variable* exception) {\n+IteratorRecord IteratorBuiltinsAssembler::GetIterator(Node* context,\n+                                                      Node* object,\n+                                                      Label* if_exception,\n+                                                      Variable* exception) {\n   Node* method = GetProperty(context, object, factory()->iterator_symbol());\n   GotoIfException(method, if_exception, exception);\n \n   Callable callable = CodeFactory::Call(isolate());\n   Node* iterator = CallJS(callable, context, method, object);\n   GotoIfException(iterator, if_exception, exception);\n \n-  Label done(this), if_notobject(this, Label::kDeferred);\n+  Label get_next(this), if_notobject(this, Label::kDeferred);\n   GotoIf(TaggedIsSmi(iterator), &if_notobject);\n-  Branch(IsJSReceiver(iterator), &done, &if_notobject);\n+  Branch(IsJSReceiver(iterator), &get_next, &if_notobject);\n \n   BIND(&if_notobject);\n   {\n@@ -34,24 +35,21 @@ Node* IteratorBuiltinsAssembler::GetIterator(Node* context, Node* object,\n     Unreachable();\n   }\n \n-  BIND(&done);\n-  return iterator;\n+  BIND(&get_next);\n+  Node* const next = GetProperty(context, iterator, factory()->next_string());\n+  GotoIfException(next, if_exception, exception);\n+\n+  return IteratorRecord{TNode<JSReceiver>::UncheckedCast(iterator),\n+                        TNode<Object>::UncheckedCast(next)};\n }\n \n-Node* IteratorBuiltinsAssembler::IteratorStep(Node* context, Node* iterator,\n-                                              Label* if_done,\n-                                              Node* fast_iterator_result_map,\n-                                              Label* if_exception,\n-                                              Variable* exception) {\n+Node* IteratorBuiltinsAssembler::IteratorStep(\n+    Node* context, const IteratorRecord& iterator, Label* if_done,\n+    Node* fast_iterator_result_map, Label* if_exception, Variable* exception) {\n   DCHECK_NOT_NULL(if_done);\n-\n-  // IteratorNext\n-  Node* next_method = GetProperty(context, iterator, factory()->next_string());\n-  GotoIfException(next_method, if_exception, exception);\n-\n   // 1. a. Let result be ? Invoke(iterator, \"next\", « »).\n   Callable callable = CodeFactory::Call(isolate());\n-  Node* result = CallJS(callable, context, next_method, iterator);\n+  Node* result = CallJS(callable, context, iterator.next, iterator.object);\n   GotoIfException(result, if_exception, exception);\n \n   // 3. If Type(result) is not Object, throw a TypeError exception.\n@@ -129,20 +127,20 @@ Node* IteratorBuiltinsAssembler::IteratorValue(Node* context, Node* result,\n   return var_value.value();\n }\n \n-void IteratorBuiltinsAssembler::IteratorCloseOnException(Node* context,\n-                                                         Node* iterator,\n-                                                         Label* if_exception,\n-                                                         Variable* exception) {\n+void IteratorBuiltinsAssembler::IteratorCloseOnException(\n+    Node* context, const IteratorRecord& iterator, Label* if_exception,\n+    Variable* exception) {\n   // Perform ES #sec-iteratorclose when an exception occurs. This simpler\n   // algorithm does not include redundant steps which are never reachable from\n   // the spec IteratorClose algorithm.\n   DCHECK_NOT_NULL(if_exception);\n   DCHECK_NOT_NULL(exception);\n   CSA_ASSERT(this, IsNotTheHole(exception->value()));\n-  CSA_ASSERT(this, IsJSReceiver(iterator));\n+  CSA_ASSERT(this, IsJSReceiver(iterator.object));\n \n   // Let return be ? GetMethod(iterator, \"return\").\n-  Node* method = GetProperty(context, iterator, factory()->return_string());\n+  Node* method =\n+      GetProperty(context, iterator.object, factory()->return_string());\n   GotoIfException(method, if_exception, exception);\n \n   // If return is undefined, return Completion(completion).\n@@ -152,17 +150,16 @@ void IteratorBuiltinsAssembler::IteratorCloseOnException(Node* context,\n     // Let innerResult be Call(return, iterator, « »).\n     // If an exception occurs, the original exception remains bound\n     Node* inner_result =\n-        CallJS(CodeFactory::Call(isolate()), context, method, iterator);\n+        CallJS(CodeFactory::Call(isolate()), context, method, iterator.object);\n     GotoIfException(inner_result, if_exception, nullptr);\n \n     // (If completion.[[Type]] is throw) return Completion(completion).\n     Goto(if_exception);\n   }\n }\n \n-void IteratorBuiltinsAssembler::IteratorCloseOnException(Node* context,\n-                                                         Node* iterator,\n-                                                         Variable* exception) {\n+void IteratorBuiltinsAssembler::IteratorCloseOnException(\n+    Node* context, const IteratorRecord& iterator, Variable* exception) {\n   Label rethrow(this, Label::kDeferred);\n   IteratorCloseOnException(context, iterator, &rethrow, exception);\n "
        },
        {
            "sha": "42627b8437ff40e10af50c9f5e190dba6060035f",
            "filename": "deps/v8/src/builtins/builtins-iterator-gen.h",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-iterator-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-iterator-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-iterator-gen.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -19,16 +19,17 @@ class IteratorBuiltinsAssembler : public CodeStubAssembler {\n \n   // https://tc39.github.io/ecma262/#sec-getiterator --- never used for\n   // @@asyncIterator.\n-  Node* GetIterator(Node* context, Node* object, Label* if_exception = nullptr,\n-                    Variable* exception = nullptr);\n+  IteratorRecord GetIterator(Node* context, Node* object,\n+                             Label* if_exception = nullptr,\n+                             Variable* exception = nullptr);\n \n   // https://tc39.github.io/ecma262/#sec-iteratorstep\n   // Returns `false` if the iterator is done, otherwise returns an\n   // iterator result.\n   // `fast_iterator_result_map` refers to the map for the JSIteratorResult\n   // object, loaded from the native context.\n-  Node* IteratorStep(Node* context, Node* iterator, Label* if_done,\n-                     Node* fast_iterator_result_map = nullptr,\n+  Node* IteratorStep(Node* context, const IteratorRecord& iterator,\n+                     Label* if_done, Node* fast_iterator_result_map = nullptr,\n                      Label* if_exception = nullptr,\n                      Variable* exception = nullptr);\n \n@@ -42,9 +43,9 @@ class IteratorBuiltinsAssembler : public CodeStubAssembler {\n                       Variable* exception = nullptr);\n \n   // https://tc39.github.io/ecma262/#sec-iteratorclose\n-  void IteratorCloseOnException(Node* context, Node* iterator,\n+  void IteratorCloseOnException(Node* context, const IteratorRecord& iterator,\n                                 Label* if_exception, Variable* exception);\n-  void IteratorCloseOnException(Node* context, Node* iterator,\n+  void IteratorCloseOnException(Node* context, const IteratorRecord& iterator,\n                                 Variable* exception);\n };\n "
        },
        {
            "sha": "d588113cdd1210099c39fb2df08aeedbea5a5294",
            "filename": "deps/v8/src/builtins/builtins-math-gen.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-math-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-math-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-math-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -8,7 +8,6 @@\n #include \"src/builtins/builtins.h\"\n #include \"src/code-factory.h\"\n #include \"src/code-stub-assembler.h\"\n-#include \"src/zone/zone-list-inl.h\"  // TODO(mstarzinger): Temporary cycle breaker.\n \n namespace v8 {\n namespace internal {\n@@ -162,7 +161,7 @@ void MathBuiltinsAssembler::MathMaxMin(\n                                                     SloppyTNode<Float64T>),\n     double default_val) {\n   CodeStubArguments arguments(this, ChangeInt32ToIntPtr(argc));\n-  argc = arguments.GetLength();\n+  argc = arguments.GetLength(INTPTR_PARAMETERS);\n \n   VARIABLE(result, MachineRepresentation::kFloat64);\n   result.Bind(Float64Constant(default_val));"
        },
        {
            "sha": "9e344820dcca6dd42219f9678297b5ee72b1345c",
            "filename": "deps/v8/src/builtins/builtins-object-gen.cc",
            "status": "modified",
            "additions": 319,
            "deletions": 2,
            "changes": 321,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -16,6 +16,8 @@ namespace internal {\n // ES6 section 19.1 Object Objects\n \n typedef compiler::Node Node;\n+template <class T>\n+using TNode = CodeStubAssembler::TNode<T>;\n \n class ObjectBuiltinsAssembler : public CodeStubAssembler {\n  public:\n@@ -34,6 +36,46 @@ class ObjectBuiltinsAssembler : public CodeStubAssembler {\n   Node* ConstructDataDescriptor(Node* context, Node* value, Node* writable,\n                                 Node* enumerable, Node* configurable);\n   Node* GetAccessorOrUndefined(Node* accessor, Label* if_bailout);\n+\n+  Node* IsSpecialReceiverMap(SloppyTNode<Map> map);\n+};\n+\n+class ObjectEntriesValuesBuiltinsAssembler : public ObjectBuiltinsAssembler {\n+ public:\n+  explicit ObjectEntriesValuesBuiltinsAssembler(\n+      compiler::CodeAssemblerState* state)\n+      : ObjectBuiltinsAssembler(state) {}\n+\n+ protected:\n+  enum CollectType { kEntries, kValues };\n+\n+  TNode<Word32T> IsStringWrapperElementsKind(TNode<Map> map);\n+\n+  TNode<BoolT> IsPropertyEnumerable(TNode<Uint32T> details);\n+\n+  TNode<BoolT> IsPropertyKindAccessor(TNode<Uint32T> kind);\n+\n+  TNode<BoolT> IsPropertyKindData(TNode<Uint32T> kind);\n+\n+  TNode<Uint32T> HasHiddenPrototype(TNode<Map> map);\n+\n+  TNode<Uint32T> LoadPropertyKind(TNode<Uint32T> details) {\n+    return DecodeWord32<PropertyDetails::KindField>(details);\n+  }\n+\n+  void GetOwnValuesOrEntries(TNode<Context> context, TNode<Object> maybe_object,\n+                             CollectType collect_type);\n+\n+  void GotoIfMapHasSlowProperties(TNode<Map> map, Label* if_slow);\n+\n+  TNode<JSArray> FastGetOwnValuesOrEntries(\n+      TNode<Context> context, TNode<JSObject> object,\n+      Label* if_call_runtime_with_fast_path, Label* if_no_properties,\n+      CollectType collect_type);\n+\n+  TNode<JSArray> FinalizeValuesOrEntriesJSArray(\n+      TNode<Context> context, TNode<FixedArray> values_or_entries,\n+      TNode<IntPtrT> size, TNode<Map> array_map, Label* if_empty);\n };\n \n void ObjectBuiltinsAssembler::ReturnToStringFormat(Node* context,\n@@ -97,6 +139,265 @@ Node* ObjectBuiltinsAssembler::ConstructDataDescriptor(Node* context,\n   return js_desc;\n }\n \n+Node* ObjectBuiltinsAssembler::IsSpecialReceiverMap(SloppyTNode<Map> map) {\n+  CSA_SLOW_ASSERT(this, IsMap(map));\n+  Node* is_special = IsSpecialReceiverInstanceType(LoadMapInstanceType(map));\n+  uint32_t mask =\n+      Map::HasNamedInterceptorBit::kMask | Map::IsAccessCheckNeededBit::kMask;\n+  USE(mask);\n+  // Interceptors or access checks imply special receiver.\n+  CSA_ASSERT(this,\n+             SelectConstant(IsSetWord32(LoadMapBitField(map), mask), is_special,\n+                            Int32Constant(1), MachineRepresentation::kWord32));\n+  return is_special;\n+}\n+\n+TNode<Word32T>\n+ObjectEntriesValuesBuiltinsAssembler::IsStringWrapperElementsKind(\n+    TNode<Map> map) {\n+  Node* kind = LoadMapElementsKind(map);\n+  return Word32Or(\n+      Word32Equal(kind, Int32Constant(FAST_STRING_WRAPPER_ELEMENTS)),\n+      Word32Equal(kind, Int32Constant(SLOW_STRING_WRAPPER_ELEMENTS)));\n+}\n+\n+TNode<BoolT> ObjectEntriesValuesBuiltinsAssembler::IsPropertyEnumerable(\n+    TNode<Uint32T> details) {\n+  TNode<Uint32T> attributes =\n+      DecodeWord32<PropertyDetails::AttributesField>(details);\n+  return IsNotSetWord32(attributes, PropertyAttributes::DONT_ENUM);\n+}\n+\n+TNode<BoolT> ObjectEntriesValuesBuiltinsAssembler::IsPropertyKindAccessor(\n+    TNode<Uint32T> kind) {\n+  return Word32Equal(kind, Int32Constant(PropertyKind::kAccessor));\n+}\n+\n+TNode<BoolT> ObjectEntriesValuesBuiltinsAssembler::IsPropertyKindData(\n+    TNode<Uint32T> kind) {\n+  return Word32Equal(kind, Int32Constant(PropertyKind::kData));\n+}\n+\n+TNode<Uint32T> ObjectEntriesValuesBuiltinsAssembler::HasHiddenPrototype(\n+    TNode<Map> map) {\n+  TNode<Uint32T> bit_field3 = LoadMapBitField3(map);\n+  return DecodeWord32<Map::HasHiddenPrototypeBit>(bit_field3);\n+}\n+\n+void ObjectEntriesValuesBuiltinsAssembler::GetOwnValuesOrEntries(\n+    TNode<Context> context, TNode<Object> maybe_object,\n+    CollectType collect_type) {\n+  TNode<JSObject> object = TNode<JSObject>::UncheckedCast(\n+      CallBuiltin(Builtins::kToObject, context, maybe_object));\n+\n+  Label if_call_runtime_with_fast_path(this, Label::kDeferred),\n+      if_call_runtime(this, Label::kDeferred),\n+      if_no_properties(this, Label::kDeferred);\n+\n+  TNode<Map> map = LoadMap(object);\n+  GotoIfNot(IsJSObjectMap(map), &if_call_runtime);\n+  GotoIfMapHasSlowProperties(map, &if_call_runtime);\n+\n+  TNode<FixedArrayBase> elements = LoadElements(object);\n+  // If the object has elements, we treat it as slow case.\n+  // So, we go to runtime call.\n+  GotoIfNot(IsEmptyFixedArray(elements), &if_call_runtime_with_fast_path);\n+\n+  TNode<JSArray> result = FastGetOwnValuesOrEntries(\n+      context, object, &if_call_runtime_with_fast_path, &if_no_properties,\n+      collect_type);\n+  Return(result);\n+\n+  BIND(&if_no_properties);\n+  {\n+    Node* native_context = LoadNativeContext(context);\n+    Node* array_map = LoadJSArrayElementsMap(PACKED_ELEMENTS, native_context);\n+    Node* empty_array = AllocateJSArray(PACKED_ELEMENTS, array_map,\n+                                        IntPtrConstant(0), SmiConstant(0));\n+    Return(empty_array);\n+  }\n+\n+  BIND(&if_call_runtime_with_fast_path);\n+  {\n+    // In slow case, we simply call runtime.\n+    if (collect_type == CollectType::kEntries) {\n+      Return(CallRuntime(Runtime::kObjectEntries, context, object));\n+    } else {\n+      DCHECK(collect_type == CollectType::kValues);\n+      Return(CallRuntime(Runtime::kObjectValues, context, object));\n+    }\n+  }\n+\n+  BIND(&if_call_runtime);\n+  {\n+    // In slow case, we simply call runtime.\n+    if (collect_type == CollectType::kEntries) {\n+      Return(CallRuntime(Runtime::kObjectEntriesSkipFastPath, context, object));\n+    } else {\n+      DCHECK(collect_type == CollectType::kValues);\n+      Return(CallRuntime(Runtime::kObjectValuesSkipFastPath, context, object));\n+    }\n+  }\n+}\n+\n+void ObjectEntriesValuesBuiltinsAssembler::GotoIfMapHasSlowProperties(\n+    TNode<Map> map, Label* if_slow) {\n+  GotoIf(IsStringWrapperElementsKind(map), if_slow);\n+  GotoIf(IsSpecialReceiverMap(map), if_slow);\n+  GotoIf(HasHiddenPrototype(map), if_slow);\n+  GotoIf(IsDictionaryMap(map), if_slow);\n+}\n+\n+TNode<JSArray> ObjectEntriesValuesBuiltinsAssembler::FastGetOwnValuesOrEntries(\n+    TNode<Context> context, TNode<JSObject> object,\n+    Label* if_call_runtime_with_fast_path, Label* if_no_properties,\n+    CollectType collect_type) {\n+  Node* native_context = LoadNativeContext(context);\n+  TNode<Map> array_map =\n+      LoadJSArrayElementsMap(PACKED_ELEMENTS, native_context);\n+  TNode<Map> map = LoadMap(object);\n+  TNode<Uint32T> bit_field3 = LoadMapBitField3(map);\n+\n+  Label if_has_enum_cache(this), if_not_has_enum_cache(this),\n+      collect_entries(this);\n+  Node* object_enum_length =\n+      DecodeWordFromWord32<Map::EnumLengthBits>(bit_field3);\n+  Node* has_enum_cache = WordNotEqual(\n+      object_enum_length, IntPtrConstant(kInvalidEnumCacheSentinel));\n+\n+  // In case, we found enum_cache in object,\n+  // we use it as array_length becuase it has same size for\n+  // Object.(entries/values) result array object length.\n+  // So object_enum_length use less memory space than\n+  // NumberOfOwnDescriptorsBits value.\n+  // And in case, if enum_cache_not_found,\n+  // we call runtime and initialize enum_cache for subsequent call of\n+  // CSA fast path.\n+  Branch(has_enum_cache, &if_has_enum_cache, if_call_runtime_with_fast_path);\n+\n+  BIND(&if_has_enum_cache);\n+  {\n+    GotoIf(WordEqual(object_enum_length, IntPtrConstant(0)), if_no_properties);\n+    TNode<FixedArray> values_or_entries = TNode<FixedArray>::UncheckedCast(\n+        AllocateFixedArray(PACKED_ELEMENTS, object_enum_length,\n+                           INTPTR_PARAMETERS, kAllowLargeObjectAllocation));\n+\n+    // If in case we have enum_cache,\n+    // we can't detect accessor of object until loop through descritpros.\n+    // So if object might have accessor,\n+    // we will remain invalid addresses of FixedArray.\n+    // Because in that case, we need to jump to runtime call.\n+    // So the array filled by the-hole even if enum_cache exists.\n+    FillFixedArrayWithValue(PACKED_ELEMENTS, values_or_entries,\n+                            IntPtrConstant(0), object_enum_length,\n+                            Heap::kTheHoleValueRootIndex);\n+\n+    TVARIABLE(IntPtrT, var_result_index, IntPtrConstant(0));\n+    TVARIABLE(IntPtrT, var_descriptor_index, IntPtrConstant(0));\n+    Variable* vars[] = {&var_descriptor_index, &var_result_index};\n+    // Let desc be ? O.[[GetOwnProperty]](key).\n+    TNode<DescriptorArray> descriptors = LoadMapDescriptors(map);\n+    Label loop(this, 2, vars), after_loop(this), loop_condition(this);\n+    Branch(IntPtrEqual(var_descriptor_index, object_enum_length), &after_loop,\n+           &loop);\n+\n+    // We dont use BuildFastLoop.\n+    // Instead, we use hand-written loop\n+    // because of we need to use 'continue' functionality.\n+    BIND(&loop);\n+    {\n+      // Currently, we will not invoke getters,\n+      // so, map will not be changed.\n+      CSA_ASSERT(this, WordEqual(map, LoadMap(object)));\n+      TNode<Uint32T> descriptor_index = TNode<Uint32T>::UncheckedCast(\n+          TruncateWordToWord32(var_descriptor_index));\n+      Node* next_key = DescriptorArrayGetKey(descriptors, descriptor_index);\n+\n+      // Skip Symbols.\n+      GotoIf(IsSymbol(next_key), &loop_condition);\n+\n+      TNode<Uint32T> details = TNode<Uint32T>::UncheckedCast(\n+          DescriptorArrayGetDetails(descriptors, descriptor_index));\n+      TNode<Uint32T> kind = LoadPropertyKind(details);\n+\n+      // If property is accessor, we escape fast path and call runtime.\n+      GotoIf(IsPropertyKindAccessor(kind), if_call_runtime_with_fast_path);\n+      CSA_ASSERT(this, IsPropertyKindData(kind));\n+\n+      // If desc is not undefined and desc.[[Enumerable]] is true, then\n+      GotoIfNot(IsPropertyEnumerable(details), &loop_condition);\n+\n+      VARIABLE(var_property_value, MachineRepresentation::kTagged,\n+               UndefinedConstant());\n+      Node* descriptor_name_index = DescriptorNumberToIndex(descriptor_index);\n+\n+      // Let value be ? Get(O, key).\n+      LoadPropertyFromFastObject(object, map, descriptors,\n+                                 descriptor_name_index, details,\n+                                 &var_property_value);\n+\n+      // If kind is \"value\", append value to properties.\n+      Node* value = var_property_value.value();\n+\n+      if (collect_type == CollectType::kEntries) {\n+        // Let entry be CreateArrayFromList(« key, value »).\n+        Node* array = nullptr;\n+        Node* elements = nullptr;\n+        std::tie(array, elements) = AllocateUninitializedJSArrayWithElements(\n+            PACKED_ELEMENTS, array_map, SmiConstant(2), nullptr,\n+            IntPtrConstant(2));\n+        StoreFixedArrayElement(elements, 0, next_key, SKIP_WRITE_BARRIER);\n+        StoreFixedArrayElement(elements, 1, value, SKIP_WRITE_BARRIER);\n+        value = array;\n+      }\n+\n+      StoreFixedArrayElement(values_or_entries, var_result_index, value);\n+      Increment(&var_result_index, 1);\n+      Goto(&loop_condition);\n+\n+      BIND(&loop_condition);\n+      {\n+        Increment(&var_descriptor_index, 1);\n+        Branch(IntPtrEqual(var_descriptor_index, object_enum_length),\n+               &after_loop, &loop);\n+      }\n+    }\n+    BIND(&after_loop);\n+    return FinalizeValuesOrEntriesJSArray(context, values_or_entries,\n+                                          var_result_index, array_map,\n+                                          if_no_properties);\n+  }\n+}\n+\n+TNode<JSArray>\n+ObjectEntriesValuesBuiltinsAssembler::FinalizeValuesOrEntriesJSArray(\n+    TNode<Context> context, TNode<FixedArray> result, TNode<IntPtrT> size,\n+    TNode<Map> array_map, Label* if_empty) {\n+  CSA_ASSERT(this, IsJSArrayMap(array_map));\n+\n+  GotoIf(IntPtrEqual(size, IntPtrConstant(0)), if_empty);\n+  Node* array = AllocateUninitializedJSArrayWithoutElements(\n+      array_map, SmiTag(size), nullptr);\n+  StoreObjectField(array, JSArray::kElementsOffset, result);\n+  return TNode<JSArray>::UncheckedCast(array);\n+}\n+\n+TF_BUILTIN(ObjectPrototypeToLocaleString, CodeStubAssembler) {\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n+  TNode<Object> receiver = CAST(Parameter(Descriptor::kReceiver));\n+\n+  Label if_null_or_undefined(this, Label::kDeferred);\n+  GotoIf(IsNullOrUndefined(receiver), &if_null_or_undefined);\n+\n+  TNode<Object> method =\n+      CAST(GetProperty(context, receiver, factory()->toString_string()));\n+  Return(CallJS(CodeFactory::Call(isolate()), context, method, receiver));\n+\n+  BIND(&if_null_or_undefined);\n+  ThrowTypeError(context, MessageTemplate::kCalledOnNullOrUndefined,\n+                 \"Object.prototype.toLocaleString\");\n+}\n+\n TF_BUILTIN(ObjectPrototypeHasOwnProperty, ObjectBuiltinsAssembler) {\n   Node* object = Parameter(Descriptor::kReceiver);\n   Node* key = Parameter(Descriptor::kKey);\n@@ -250,6 +551,22 @@ TF_BUILTIN(ObjectKeys, ObjectBuiltinsAssembler) {\n   }\n }\n \n+TF_BUILTIN(ObjectValues, ObjectEntriesValuesBuiltinsAssembler) {\n+  TNode<JSObject> object =\n+      TNode<JSObject>::UncheckedCast(Parameter(Descriptor::kObject));\n+  TNode<Context> context =\n+      TNode<Context>::UncheckedCast(Parameter(Descriptor::kContext));\n+  GetOwnValuesOrEntries(context, object, CollectType::kValues);\n+}\n+\n+TF_BUILTIN(ObjectEntries, ObjectEntriesValuesBuiltinsAssembler) {\n+  TNode<JSObject> object =\n+      TNode<JSObject>::UncheckedCast(Parameter(Descriptor::kObject));\n+  TNode<Context> context =\n+      TNode<Context>::UncheckedCast(Parameter(Descriptor::kContext));\n+  GetOwnValuesOrEntries(context, object, CollectType::kEntries);\n+}\n+\n // ES #sec-object.prototype.isprototypeof\n TF_BUILTIN(ObjectPrototypeIsPrototypeOf, ObjectBuiltinsAssembler) {\n   Node* receiver = Parameter(Descriptor::kReceiver);\n@@ -550,7 +867,7 @@ TF_BUILTIN(ObjectPrototypeToString, ObjectBuiltinsAssembler) {\n       GotoIf(IsNull(holder), &return_default);\n       Node* holder_map = LoadMap(holder);\n       Node* holder_bit_field3 = LoadMapBitField3(holder_map);\n-      GotoIf(IsSetWord32<Map::MayHaveInterestingSymbols>(holder_bit_field3),\n+      GotoIf(IsSetWord32<Map::MayHaveInterestingSymbolsBit>(holder_bit_field3),\n              &return_generic);\n       var_holder.Bind(LoadMapPrototype(holder_map));\n       Goto(&loop);\n@@ -615,7 +932,7 @@ TF_BUILTIN(ObjectCreate, ObjectBuiltinsAssembler) {\n               &call_runtime);\n     // Handle dictionary objects or fast objects with properties in runtime.\n     Node* bit_field3 = LoadMapBitField3(properties_map);\n-    GotoIf(IsSetWord32<Map::DictionaryMap>(bit_field3), &call_runtime);\n+    GotoIf(IsSetWord32<Map::IsDictionaryMapBit>(bit_field3), &call_runtime);\n     Branch(IsSetWord32<Map::NumberOfOwnDescriptorsBits>(bit_field3),\n            &call_runtime, &no_properties);\n   }"
        },
        {
            "sha": "4e353b9260053173b930d7e9311c7d6eeaa9a65b",
            "filename": "deps/v8/src/builtins/builtins-object.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -395,31 +395,6 @@ BUILTIN(ObjectIsSealed) {\n   return isolate->heap()->ToBoolean(result.FromJust());\n }\n \n-BUILTIN(ObjectValues) {\n-  HandleScope scope(isolate);\n-  Handle<Object> object = args.atOrUndefined(isolate, 1);\n-  Handle<JSReceiver> receiver;\n-  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, receiver,\n-                                     Object::ToObject(isolate, object));\n-  Handle<FixedArray> values;\n-  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(\n-      isolate, values, JSReceiver::GetOwnValues(receiver, ENUMERABLE_STRINGS));\n-  return *isolate->factory()->NewJSArrayWithElements(values);\n-}\n-\n-BUILTIN(ObjectEntries) {\n-  HandleScope scope(isolate);\n-  Handle<Object> object = args.atOrUndefined(isolate, 1);\n-  Handle<JSReceiver> receiver;\n-  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, receiver,\n-                                     Object::ToObject(isolate, object));\n-  Handle<FixedArray> entries;\n-  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(\n-      isolate, entries,\n-      JSReceiver::GetOwnEntries(receiver, ENUMERABLE_STRINGS));\n-  return *isolate->factory()->NewJSArrayWithElements(entries);\n-}\n-\n BUILTIN(ObjectGetOwnPropertyDescriptors) {\n   HandleScope scope(isolate);\n   Handle<Object> object = args.atOrUndefined(isolate, 1);"
        },
        {
            "sha": "1a3ebcd8923f93d21dea08a4aec900c708390b19",
            "filename": "deps/v8/src/builtins/builtins-promise-gen.cc",
            "status": "modified",
            "additions": 104,
            "deletions": 113,
            "changes": 217,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-promise-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-promise-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-promise-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -161,12 +161,12 @@ Node* PromiseBuiltinsAssembler::NewPromiseCapability(Node* context,\n     Node* resolve =\n         LoadObjectField(capability, PromiseCapability::kResolveOffset);\n     GotoIf(TaggedIsSmi(resolve), &if_notcallable);\n-    GotoIfNot(IsCallableMap(LoadMap(resolve)), &if_notcallable);\n+    GotoIfNot(IsCallable(resolve), &if_notcallable);\n \n     Node* reject =\n         LoadObjectField(capability, PromiseCapability::kRejectOffset);\n     GotoIf(TaggedIsSmi(reject), &if_notcallable);\n-    GotoIfNot(IsCallableMap(LoadMap(reject)), &if_notcallable);\n+    GotoIfNot(IsCallable(reject), &if_notcallable);\n \n     StoreObjectField(capability, PromiseCapability::kPromiseOffset, promise);\n \n@@ -189,25 +189,6 @@ Node* PromiseBuiltinsAssembler::NewPromiseCapability(Node* context,\n   return var_result.value();\n }\n \n-void PromiseBuiltinsAssembler::InitializeFunctionContext(Node* native_context,\n-                                                         Node* context,\n-                                                         int slots) {\n-  DCHECK_GE(slots, Context::MIN_CONTEXT_SLOTS);\n-  StoreMapNoWriteBarrier(context, Heap::kFunctionContextMapRootIndex);\n-  StoreObjectFieldNoWriteBarrier(context, FixedArray::kLengthOffset,\n-                                 SmiConstant(slots));\n-\n-  Node* const empty_fn =\n-      LoadContextElement(native_context, Context::CLOSURE_INDEX);\n-  StoreContextElementNoWriteBarrier(context, Context::CLOSURE_INDEX, empty_fn);\n-  StoreContextElementNoWriteBarrier(context, Context::PREVIOUS_INDEX,\n-                                    UndefinedConstant());\n-  StoreContextElementNoWriteBarrier(context, Context::EXTENSION_INDEX,\n-                                    TheHoleConstant());\n-  StoreContextElementNoWriteBarrier(context, Context::NATIVE_CONTEXT_INDEX,\n-                                    native_context);\n-}\n-\n Node* PromiseBuiltinsAssembler::CreatePromiseContext(Node* native_context,\n                                                      int slots) {\n   DCHECK_GE(slots, Context::MIN_CONTEXT_SLOTS);\n@@ -366,8 +347,6 @@ Node* PromiseBuiltinsAssembler::InternalPromiseThen(Node* context,\n   VARIABLE(var_deferred_on_resolve, MachineRepresentation::kTagged);\n   VARIABLE(var_deferred_on_reject, MachineRepresentation::kTagged);\n \n-  GotoIfForceSlowPath(&promise_capability);\n-\n   Branch(WordEqual(promise_fun, constructor), &fast_promise_capability,\n          &promise_capability);\n \n@@ -415,16 +394,11 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(\n       append_callbacks(this);\n   GotoIf(TaggedIsSmi(on_resolve), &if_onresolvenotcallable);\n \n-  Isolate* isolate = this->isolate();\n-  Node* const on_resolve_map = LoadMap(on_resolve);\n-  Branch(IsCallableMap(on_resolve_map), &onrejectcheck,\n-         &if_onresolvenotcallable);\n+  Branch(IsCallable(on_resolve), &onrejectcheck, &if_onresolvenotcallable);\n \n   BIND(&if_onresolvenotcallable);\n   {\n-    Node* const default_resolve_handler_symbol = HeapConstant(\n-        isolate->factory()->promise_default_resolve_handler_symbol());\n-    var_on_resolve.Bind(default_resolve_handler_symbol);\n+    var_on_resolve.Bind(PromiseDefaultResolveHandlerSymbolConstant());\n     Goto(&onrejectcheck);\n   }\n \n@@ -433,15 +407,11 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(\n     Label if_onrejectnotcallable(this);\n     GotoIf(TaggedIsSmi(on_reject), &if_onrejectnotcallable);\n \n-    Node* const on_reject_map = LoadMap(on_reject);\n-    Branch(IsCallableMap(on_reject_map), &append_callbacks,\n-           &if_onrejectnotcallable);\n+    Branch(IsCallable(on_reject), &append_callbacks, &if_onrejectnotcallable);\n \n     BIND(&if_onrejectnotcallable);\n     {\n-      Node* const default_reject_handler_symbol = HeapConstant(\n-          isolate->factory()->promise_default_reject_handler_symbol());\n-      var_on_reject.Bind(default_reject_handler_symbol);\n+      var_on_reject.Bind(PromiseDefaultRejectHandlerSymbolConstant());\n       Goto(&append_callbacks);\n     }\n   }\n@@ -558,8 +528,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(\n       Node* info = AllocatePromiseReactionJobInfo(\n           result, var_on_resolve.value(), deferred_promise, deferred_on_resolve,\n           deferred_on_reject, context);\n-      // TODO(gsathya): Move this to TF\n-      CallRuntime(Runtime::kEnqueuePromiseReactionJob, context, info);\n+      CallBuiltin(Builtins::kEnqueueMicrotask, NoContextConstant(), info);\n       Goto(&out);\n \n       BIND(&reject);\n@@ -578,8 +547,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(\n           Node* info = AllocatePromiseReactionJobInfo(\n               result, var_on_reject.value(), deferred_promise,\n               deferred_on_resolve, deferred_on_reject, context);\n-          // TODO(gsathya): Move this to TF\n-          CallRuntime(Runtime::kEnqueuePromiseReactionJob, context, info);\n+          CallBuiltin(Builtins::kEnqueueMicrotask, NoContextConstant(), info);\n           Goto(&out);\n         }\n       }\n@@ -787,8 +755,7 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,\n     // 12. Perform EnqueueJob(\"PromiseJobs\",\n     // PromiseResolveThenableJob, « promise, resolution, thenAction»).\n     BIND(&enqueue);\n-    // TODO(gsathya): Move this to TF\n-    CallRuntime(Runtime::kEnqueuePromiseResolveThenableJob, context, info);\n+    CallBuiltin(Builtins::kEnqueueMicrotask, NoContextConstant(), info);\n     Goto(&out);\n   }\n \n@@ -846,7 +813,7 @@ void PromiseBuiltinsAssembler::PromiseFulfill(\n       result, tasks, deferred_promise, deferred_on_resolve, deferred_on_reject,\n       context);\n \n-  CallRuntime(Runtime::kEnqueuePromiseReactionJob, context, info);\n+  CallBuiltin(Builtins::kEnqueueMicrotask, NoContextConstant(), info);\n   Goto(&do_promisereset);\n \n   BIND(&do_promisereset);\n@@ -1080,19 +1047,18 @@ TF_BUILTIN(PromiseConstructor, PromiseBuiltinsAssembler) {\n     Node *resolve, *reject;\n     std::tie(resolve, reject) = CreatePromiseResolvingFunctions(\n         var_result.value(), TrueConstant(), native_context);\n-    Callable call_callable = CodeFactory::Call(isolate);\n \n-    Node* const maybe_exception = CallJS(call_callable, context, executor,\n-                                         UndefinedConstant(), resolve, reject);\n+    Node* const maybe_exception = CallJS(\n+        CodeFactory::Call(isolate, ConvertReceiverMode::kNullOrUndefined),\n+        context, executor, UndefinedConstant(), resolve, reject);\n \n     GotoIfException(maybe_exception, &if_rejectpromise, &var_reason);\n     Branch(is_debug_active, &debug_pop, &out);\n \n     BIND(&if_rejectpromise);\n     {\n-      Callable call_callable = CodeFactory::Call(isolate);\n-      CallJS(call_callable, context, reject, UndefinedConstant(),\n-             var_reason.value());\n+      CallJS(CodeFactory::Call(isolate, ConvertReceiverMode::kNullOrUndefined),\n+             context, reject, UndefinedConstant(), var_reason.value());\n       Branch(is_debug_active, &debug_pop, &out);\n     }\n \n@@ -1130,8 +1096,8 @@ TF_BUILTIN(PromiseInternalConstructor, PromiseBuiltinsAssembler) {\n }\n \n // ES#sec-promise.prototype.then\n-// Promise.prototype.catch ( onFulfilled, onRejected )\n-TF_BUILTIN(PromiseThen, PromiseBuiltinsAssembler) {\n+// Promise.prototype.then ( onFulfilled, onRejected )\n+TF_BUILTIN(PromisePrototypeThen, PromiseBuiltinsAssembler) {\n   // 1. Let promise be the this value.\n   Node* const promise = Parameter(Descriptor::kReceiver);\n   Node* const on_resolve = Parameter(Descriptor::kOnFullfilled);\n@@ -1169,7 +1135,6 @@ TF_BUILTIN(PromiseHandleReject, PromiseBuiltinsAssembler) {\n   Node* const exception = Parameter(Descriptor::kException);\n   Node* const context = Parameter(Descriptor::kContext);\n \n-  Callable call_callable = CodeFactory::Call(isolate());\n   VARIABLE(var_unused, MachineRepresentation::kTagged);\n \n   Label if_internalhandler(this), if_customhandler(this, Label::kDeferred);\n@@ -1183,7 +1148,15 @@ TF_BUILTIN(PromiseHandleReject, PromiseBuiltinsAssembler) {\n \n   BIND(&if_customhandler);\n   {\n-    CallJS(call_callable, context, on_reject, UndefinedConstant(), exception);\n+    VARIABLE(var_exception, MachineRepresentation::kTagged, TheHoleConstant());\n+    Label if_exception(this);\n+    Node* const ret = CallJS(\n+        CodeFactory::Call(isolate(), ConvertReceiverMode::kNullOrUndefined),\n+        context, on_reject, UndefinedConstant(), exception);\n+    GotoIfException(ret, &if_exception, &var_exception);\n+    Return(UndefinedConstant());\n+    BIND(&if_exception);\n+    CallRuntime(Runtime::kReportMessage, context, var_exception.value());\n     Return(UndefinedConstant());\n   }\n }\n@@ -1225,9 +1198,7 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {\n     BIND(&if_defaulthandler);\n     {\n       Label if_resolve(this), if_reject(this);\n-      Node* const default_resolve_handler_symbol = HeapConstant(\n-          isolate->factory()->promise_default_resolve_handler_symbol());\n-      Branch(WordEqual(default_resolve_handler_symbol, handler), &if_resolve,\n+      Branch(IsPromiseDefaultResolveHandlerSymbol(handler), &if_resolve,\n              &if_reject);\n \n       BIND(&if_resolve);\n@@ -1246,9 +1217,9 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {\n \n     BIND(&if_callablehandler);\n     {\n-      Callable call_callable = CodeFactory::Call(isolate);\n-      Node* const result =\n-          CallJS(call_callable, context, handler, UndefinedConstant(), value);\n+      Node* const result = CallJS(\n+          CodeFactory::Call(isolate, ConvertReceiverMode::kNullOrUndefined),\n+          context, handler, UndefinedConstant(), value);\n       var_result.Bind(result);\n       GotoIfException(result, &if_rejectpromise, &var_reason);\n       Branch(IsUndefined(deferred_on_resolve), &if_internalhandler,\n@@ -1261,10 +1232,10 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {\n \n     BIND(&if_customhandler);\n     {\n-      Callable call_callable = CodeFactory::Call(isolate);\n-      Node* const maybe_exception =\n-          CallJS(call_callable, context, deferred_on_resolve,\n-                 UndefinedConstant(), var_result.value());\n+      Node* const maybe_exception = CallJS(\n+          CodeFactory::Call(isolate, ConvertReceiverMode::kNullOrUndefined),\n+          context, deferred_on_resolve, UndefinedConstant(),\n+          var_result.value());\n       GotoIfException(maybe_exception, &if_rejectpromise, &var_reason);\n       Goto(&promisehook_after);\n     }\n@@ -1297,9 +1268,23 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {\n   }\n }\n \n+TF_BUILTIN(PromiseHandleJS, PromiseBuiltinsAssembler) {\n+  Node* const value = Parameter(Descriptor::kValue);\n+  Node* const handler = Parameter(Descriptor::kHandler);\n+  Node* const deferred_promise = Parameter(Descriptor::kDeferredPromise);\n+  Node* const deferred_on_resolve = Parameter(Descriptor::kDeferredOnResolve);\n+  Node* const deferred_on_reject = Parameter(Descriptor::kDeferredOnReject);\n+  Node* const context = Parameter(Descriptor::kContext);\n+\n+  Node* const result =\n+      CallBuiltin(Builtins::kPromiseHandle, context, value, handler,\n+                  deferred_promise, deferred_on_resolve, deferred_on_reject);\n+  Return(result);\n+}\n+\n // ES#sec-promise.prototype.catch\n // Promise.prototype.catch ( onRejected )\n-TF_BUILTIN(PromiseCatch, PromiseBuiltinsAssembler) {\n+TF_BUILTIN(PromisePrototypeCatch, PromiseBuiltinsAssembler) {\n   // 1. Let promise be the this value.\n   Node* const promise = Parameter(Descriptor::kReceiver);\n   Node* const on_resolve = UndefinedConstant();\n@@ -1321,9 +1306,9 @@ TF_BUILTIN(PromiseCatch, PromiseBuiltinsAssembler) {\n   {\n     Node* const then =\n         GetProperty(context, promise, isolate()->factory()->then_string());\n-    Callable call_callable = CodeFactory::Call(isolate());\n-    Node* const result =\n-        CallJS(call_callable, context, then, promise, on_resolve, on_reject);\n+    Node* const result = CallJS(\n+        CodeFactory::Call(isolate(), ConvertReceiverMode::kNotNullOrUndefined),\n+        context, then, promise, on_resolve, on_reject);\n     Return(result);\n   }\n }\n@@ -1407,10 +1392,10 @@ TF_BUILTIN(PromiseResolve, PromiseBuiltinsAssembler) {\n     {\n       Node* const capability = NewPromiseCapability(context, constructor);\n \n-      Callable call_callable = CodeFactory::Call(isolate);\n       Node* const resolve =\n           LoadObjectField(capability, PromiseCapability::kResolveOffset);\n-      CallJS(call_callable, context, resolve, UndefinedConstant(), value);\n+      CallJS(CodeFactory::Call(isolate, ConvertReceiverMode::kNullOrUndefined),\n+             context, resolve, UndefinedConstant(), value);\n \n       Node* const result =\n           LoadObjectField(capability, PromiseCapability::kPromiseOffset);\n@@ -1468,8 +1453,6 @@ TF_BUILTIN(PromiseReject, PromiseBuiltinsAssembler) {\n   Label if_nativepromise(this), if_custompromise(this, Label::kDeferred);\n   Node* const native_context = LoadNativeContext(context);\n \n-  GotoIfForceSlowPath(&if_custompromise);\n-\n   Node* const promise_fun =\n       LoadContextElement(native_context, Context::PROMISE_FUNCTION_INDEX);\n   Branch(WordEqual(promise_fun, receiver), &if_nativepromise,\n@@ -1492,8 +1475,8 @@ TF_BUILTIN(PromiseReject, PromiseBuiltinsAssembler) {\n     // 4. Perform ? Call(promiseCapability.[[Reject]], undefined, « r »).\n     Node* const reject =\n         LoadObjectField(capability, PromiseCapability::kRejectOffset);\n-    Callable call_callable = CodeFactory::Call(isolate());\n-    CallJS(call_callable, context, reject, UndefinedConstant(), reason);\n+    CallJS(CodeFactory::Call(isolate(), ConvertReceiverMode::kNullOrUndefined),\n+           context, reject, UndefinedConstant(), reason);\n \n     // 5. Return promiseCapability.[[Promise]].\n     Node* const promise =\n@@ -1567,9 +1550,9 @@ TF_BUILTIN(PromiseThenFinally, PromiseBuiltinsAssembler) {\n   CSA_ASSERT(this, IsCallable(on_finally));\n \n   // 3. Let result be ?  Call(onFinally).\n-  Callable call_callable = CodeFactory::Call(isolate());\n-  Node* const result =\n-      CallJS(call_callable, context, on_finally, UndefinedConstant());\n+  Node* const result = CallJS(\n+      CodeFactory::Call(isolate(), ConvertReceiverMode::kNullOrUndefined),\n+      context, on_finally, UndefinedConstant());\n \n   // 4. Let C be F.[[Constructor]].\n   Node* const constructor = LoadContextElement(context, kConstructorSlot);\n@@ -1588,8 +1571,9 @@ TF_BUILTIN(PromiseThenFinally, PromiseBuiltinsAssembler) {\n   // 8. Return ? Invoke(promise, \"then\", « valueThunk »).\n   Node* const promise_then =\n     GetProperty(context, promise, factory()->then_string());\n-  Node* const result_promise = CallJS(call_callable, context,\n-                                      promise_then, promise, value_thunk);\n+  Node* const result_promise = CallJS(\n+      CodeFactory::Call(isolate(), ConvertReceiverMode::kNotNullOrUndefined),\n+      context, promise_then, promise, value_thunk);\n   Return(result_promise);\n }\n \n@@ -1628,9 +1612,9 @@ TF_BUILTIN(PromiseCatchFinally, PromiseBuiltinsAssembler) {\n   CSA_ASSERT(this, IsCallable(on_finally));\n \n   // 3. Let result be ? Call(onFinally).\n-  Callable call_callable = CodeFactory::Call(isolate());\n-  Node* result =\n-    CallJS(call_callable, context, on_finally, UndefinedConstant());\n+  Node* result = CallJS(\n+      CodeFactory::Call(isolate(), ConvertReceiverMode::kNullOrUndefined),\n+      context, on_finally, UndefinedConstant());\n \n   // 4. Let C be F.[[Constructor]].\n   Node* const constructor = LoadContextElement(context, kConstructorSlot);\n@@ -1649,22 +1633,23 @@ TF_BUILTIN(PromiseCatchFinally, PromiseBuiltinsAssembler) {\n   // 8. Return ? Invoke(promise, \"then\", « thrower »).\n   Node* const promise_then =\n     GetProperty(context, promise, factory()->then_string());\n-  Node* const result_promise = CallJS(call_callable, context,\n-                                      promise_then, promise, thrower);\n+  Node* const result_promise = CallJS(\n+      CodeFactory::Call(isolate(), ConvertReceiverMode::kNotNullOrUndefined),\n+      context, promise_then, promise, thrower);\n   Return(result_promise);\n }\n \n-TF_BUILTIN(PromiseFinally, PromiseBuiltinsAssembler) {\n+TF_BUILTIN(PromisePrototypeFinally, PromiseBuiltinsAssembler) {\n   CSA_ASSERT_JS_ARGC_EQ(this, 1);\n \n   // 1.  Let promise be the this value.\n   Node* const promise = Parameter(Descriptor::kReceiver);\n   Node* const on_finally = Parameter(Descriptor::kOnFinally);\n   Node* const context = Parameter(Descriptor::kContext);\n \n-  // 2. If IsPromise(promise) is false, throw a TypeError exception.\n-  ThrowIfNotInstanceType(context, promise, JS_PROMISE_TYPE,\n-                         \"Promise.prototype.finally\");\n+  // 2. If Type(promise) is not Object, throw a TypeError exception.\n+  ThrowIfNotJSReceiver(context, promise, MessageTemplate::kCalledOnNonObject,\n+                       \"Promise.prototype.finally\");\n \n   // 3. Let C be ? SpeciesConstructor(promise, %Promise%).\n   Node* const native_context = LoadNativeContext(context);\n@@ -1714,9 +1699,10 @@ TF_BUILTIN(PromiseFinally, PromiseBuiltinsAssembler) {\n   BIND(&perform_finally);\n   Node* const promise_then =\n     GetProperty(context, promise, factory()->then_string());\n-  Node* const result_promise =\n-    CallJS(CodeFactory::Call(isolate()), context, promise_then, promise,\n-           var_then_finally.value(), var_catch_finally.value());\n+  Node* const result_promise = CallJS(\n+      CodeFactory::Call(isolate(), ConvertReceiverMode::kNotNullOrUndefined),\n+      context, promise_then, promise, var_then_finally.value(),\n+      var_catch_finally.value());\n   Return(result_promise);\n }\n \n@@ -1758,8 +1744,9 @@ TF_BUILTIN(PerformNativePromiseThen, PromiseBuiltinsAssembler) {\n }\n \n Node* PromiseBuiltinsAssembler::PerformPromiseAll(\n-    Node* context, Node* constructor, Node* capability, Node* iterator,\n-    Label* if_exception, Variable* var_exception) {\n+    Node* context, Node* constructor, Node* capability,\n+    const IteratorRecord& iterator, Label* if_exception,\n+    Variable* var_exception) {\n   IteratorBuiltinsAssembler iter_assembler(state());\n   Label close_iterator(this);\n \n@@ -1805,8 +1792,9 @@ Node* PromiseBuiltinsAssembler::PerformPromiseAll(\n         GetProperty(context, constructor, factory()->resolve_string());\n     GotoIfException(promise_resolve, &close_iterator, var_exception);\n \n-    Node* const next_promise = CallJS(CodeFactory::Call(isolate()), context,\n-                                      promise_resolve, constructor, next_value);\n+    Node* const next_promise = CallJS(\n+        CodeFactory::Call(isolate(), ConvertReceiverMode::kNotNullOrUndefined),\n+        context, promise_resolve, constructor, next_value);\n     GotoIfException(next_promise, &close_iterator, var_exception);\n \n     // Let resolveElement be a new built-in function object as defined in\n@@ -1844,7 +1832,7 @@ Node* PromiseBuiltinsAssembler::PerformPromiseAll(\n       BIND(&if_outofrange);\n       {\n         // If the incremented value is out of Smi range, crash.\n-        Abort(kOffsetOutOfRange);\n+        Abort(AbortReason::kOffsetOutOfRange);\n       }\n \n       BIND(&done);\n@@ -1857,7 +1845,8 @@ Node* PromiseBuiltinsAssembler::PerformPromiseAll(\n     GotoIfException(then, &close_iterator, var_exception);\n \n     Node* const then_call = CallJS(\n-        CodeFactory::Call(isolate()), context, then, next_promise, resolve,\n+        CodeFactory::Call(isolate(), ConvertReceiverMode::kNotNullOrUndefined),\n+        context, then, next_promise, resolve,\n         LoadObjectField(capability, PromiseCapability::kRejectOffset));\n     GotoIfException(then_call, &close_iterator, var_exception);\n \n@@ -1899,9 +1888,9 @@ Node* PromiseBuiltinsAssembler::PerformPromiseAll(\n \n     Node* const resolve =\n         LoadObjectField(capability, PromiseCapability::kResolveOffset);\n-    Node* const resolve_call =\n-        CallJS(CodeFactory::Call(isolate()), context, resolve,\n-               UndefinedConstant(), values_array);\n+    Node* const resolve_call = CallJS(\n+        CodeFactory::Call(isolate(), ConvertReceiverMode::kNullOrUndefined),\n+        context, resolve, UndefinedConstant(), values_array);\n     GotoIfException(resolve_call, if_exception, var_exception);\n     Goto(&return_promise);\n \n@@ -1963,7 +1952,7 @@ TF_BUILTIN(PromiseAll, PromiseBuiltinsAssembler) {\n   // Let iterator be GetIterator(iterable).\n   // IfAbruptRejectPromise(iterator, promiseCapability).\n   Node* const iterable = Parameter(Descriptor::kIterable);\n-  Node* const iterator = iter_assembler.GetIterator(\n+  IteratorRecord iterator = iter_assembler.GetIterator(\n       context, iterable, &reject_promise, &var_exception);\n \n   // Let result be PerformPromiseAll(iteratorRecord, C, promiseCapability).\n@@ -1982,9 +1971,8 @@ TF_BUILTIN(PromiseAll, PromiseBuiltinsAssembler) {\n     CSA_SLOW_ASSERT(this, IsNotTheHole(var_exception.value()));\n     Node* const reject =\n         LoadObjectField(capability, PromiseCapability::kRejectOffset);\n-    Callable callable = CodeFactory::Call(isolate());\n-    CallJS(callable, context, reject, UndefinedConstant(),\n-           var_exception.value());\n+    CallJS(CodeFactory::Call(isolate(), ConvertReceiverMode::kNullOrUndefined),\n+           context, reject, UndefinedConstant(), var_exception.value());\n \n     Node* const promise =\n         LoadObjectField(capability, PromiseCapability::kPromiseOffset);\n@@ -2059,8 +2047,8 @@ TF_BUILTIN(PromiseAllResolveElementClosure, PromiseBuiltinsAssembler) {\n       LoadContextElement(context, kPromiseAllResolveElementCapabilitySlot);\n   Node* const resolve =\n       LoadObjectField(capability, PromiseCapability::kResolveOffset);\n-  CallJS(CodeFactory::Call(isolate()), context, resolve, UndefinedConstant(),\n-         values_array);\n+  CallJS(CodeFactory::Call(isolate(), ConvertReceiverMode::kNullOrUndefined),\n+         context, resolve, UndefinedConstant(), values_array);\n   Return(UndefinedConstant());\n \n   BIND(&already_called);\n@@ -2101,7 +2089,7 @@ TF_BUILTIN(PromiseRace, PromiseBuiltinsAssembler) {\n   // Let iterator be GetIterator(iterable).\n   // IfAbruptRejectPromise(iterator, promiseCapability).\n   Node* const iterable = Parameter(Descriptor::kIterable);\n-  Node* const iterator = iter_assembler.GetIterator(\n+  IteratorRecord iterator = iter_assembler.GetIterator(\n       context, iterable, &reject_promise, &var_exception);\n \n   // Let result be PerformPromiseRace(iteratorRecord, C, promiseCapability).\n@@ -2134,8 +2122,10 @@ TF_BUILTIN(PromiseRace, PromiseBuiltinsAssembler) {\n           GetProperty(context, receiver, factory()->resolve_string());\n       GotoIfException(promise_resolve, &close_iterator, &var_exception);\n \n-      Node* const next_promise = CallJS(CodeFactory::Call(isolate()), context,\n-                                        promise_resolve, receiver, next_value);\n+      Node* const next_promise =\n+          CallJS(CodeFactory::Call(isolate(),\n+                                   ConvertReceiverMode::kNotNullOrUndefined),\n+                 context, promise_resolve, receiver, next_value);\n       GotoIfException(next_promise, &close_iterator, &var_exception);\n \n       // Perform ? Invoke(nextPromise, \"then\", « resolveElement,\n@@ -2144,8 +2134,10 @@ TF_BUILTIN(PromiseRace, PromiseBuiltinsAssembler) {\n           GetProperty(context, next_promise, factory()->then_string());\n       GotoIfException(then, &close_iterator, &var_exception);\n \n-      Node* const then_call = CallJS(CodeFactory::Call(isolate()), context,\n-                                     then, next_promise, resolve, reject);\n+      Node* const then_call =\n+          CallJS(CodeFactory::Call(isolate(),\n+                                   ConvertReceiverMode::kNotNullOrUndefined),\n+                 context, then, next_promise, resolve, reject);\n       GotoIfException(then_call, &close_iterator, &var_exception);\n \n       // For catch prediction, mark that rejections here are semantically\n@@ -2172,9 +2164,8 @@ TF_BUILTIN(PromiseRace, PromiseBuiltinsAssembler) {\n   {\n     Node* const reject =\n         LoadObjectField(capability, PromiseCapability::kRejectOffset);\n-    Callable callable = CodeFactory::Call(isolate());\n-    CallJS(callable, context, reject, UndefinedConstant(),\n-           var_exception.value());\n+    CallJS(CodeFactory::Call(isolate(), ConvertReceiverMode::kNullOrUndefined),\n+           context, reject, UndefinedConstant(), var_exception.value());\n \n     Node* const promise =\n         LoadObjectField(capability, PromiseCapability::kPromiseOffset);"
        },
        {
            "sha": "366c7c22cdcb6302729be090a0e64a19fa158d84",
            "filename": "deps/v8/src/builtins/builtins-promise-gen.h",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-promise-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-promise-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-promise-gen.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -137,7 +137,6 @@ class PromiseBuiltinsAssembler : public CodeStubAssembler {\n   void BranchIfFastPath(Node* native_context, Node* promise_fun, Node* promise,\n                         Label* if_isunmodified, Label* if_ismodified);\n \n-  void InitializeFunctionContext(Node* native_context, Node* context, int len);\n   Node* CreatePromiseContext(Node* native_context, int slots);\n   void PromiseFulfill(Node* context, Node* promise, Node* result,\n                       v8::Promise::PromiseState status);\n@@ -158,7 +157,7 @@ class PromiseBuiltinsAssembler : public CodeStubAssembler {\n   Node* CreateThrowerFunction(Node* reason, Node* native_context);\n \n   Node* PerformPromiseAll(Node* context, Node* constructor, Node* capability,\n-                          Node* iterator, Label* if_exception,\n+                          const IteratorRecord& record, Label* if_exception,\n                           Variable* var_exception);\n \n   Node* IncrementSmiCell(Node* cell, Label* if_overflow = nullptr);"
        },
        {
            "sha": "64e838d53ac244929f931e9530897b323e221afc",
            "filename": "deps/v8/src/builtins/builtins-proxy-gen.cc",
            "status": "modified",
            "additions": 100,
            "deletions": 0,
            "changes": 100,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-proxy-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-proxy-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-proxy-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -126,6 +126,106 @@ TF_BUILTIN(ProxyConstructor_ConstructStub, ProxiesCodeStubAssembler) {\n   ThrowTypeError(context, MessageTemplate::kProxyHandlerOrTargetRevoked);\n }\n \n+Node* ProxiesCodeStubAssembler::CreateProxyRevokeFunctionContext(\n+    Node* proxy, Node* native_context) {\n+  Node* const context = Allocate(FixedArray::SizeFor(kProxyContextLength));\n+  StoreMapNoWriteBarrier(context, Heap::kFunctionContextMapRootIndex);\n+  InitializeFunctionContext(native_context, context, kProxyContextLength);\n+  StoreContextElementNoWriteBarrier(context, kProxySlot, proxy);\n+  return context;\n+}\n+\n+Node* ProxiesCodeStubAssembler::AllocateProxyRevokeFunction(Node* proxy,\n+                                                            Node* context) {\n+  Node* const native_context = LoadNativeContext(context);\n+\n+  Node* const proxy_context =\n+      CreateProxyRevokeFunctionContext(proxy, native_context);\n+  Node* const revoke_map = LoadContextElement(\n+      native_context, Context::STRICT_FUNCTION_WITHOUT_PROTOTYPE_MAP_INDEX);\n+  Node* const revoke_info =\n+      LoadContextElement(native_context, Context::PROXY_REVOKE_SHARED_FUN);\n+\n+  return AllocateFunctionWithMapAndContext(revoke_map, revoke_info,\n+                                           proxy_context);\n+}\n+\n+TF_BUILTIN(ProxyRevocable, ProxiesCodeStubAssembler) {\n+  Node* const target = Parameter(Descriptor::kTarget);\n+  Node* const handler = Parameter(Descriptor::kHandler);\n+  Node* const context = Parameter(Descriptor::kContext);\n+  Node* const native_context = LoadNativeContext(context);\n+\n+  Label throw_proxy_non_object(this, Label::kDeferred),\n+      throw_proxy_handler_or_target_revoked(this, Label::kDeferred),\n+      return_create_proxy(this);\n+\n+  GotoIf(TaggedIsSmi(target), &throw_proxy_non_object);\n+  GotoIfNot(IsJSReceiver(target), &throw_proxy_non_object);\n+  GotoIfRevokedProxy(target, &throw_proxy_handler_or_target_revoked);\n+\n+  GotoIf(TaggedIsSmi(handler), &throw_proxy_non_object);\n+  GotoIfNot(IsJSReceiver(handler), &throw_proxy_non_object);\n+  GotoIfRevokedProxy(handler, &throw_proxy_handler_or_target_revoked);\n+\n+  Node* const proxy = AllocateProxy(target, handler, context);\n+  Node* const revoke = AllocateProxyRevokeFunction(proxy, context);\n+\n+  Node* const result = Allocate(JSProxyRevocableResult::kSize);\n+  Node* const result_map = LoadContextElement(\n+      native_context, Context::PROXY_REVOCABLE_RESULT_MAP_INDEX);\n+  StoreMapNoWriteBarrier(result, result_map);\n+  StoreObjectFieldRoot(result, JSProxyRevocableResult::kPropertiesOrHashOffset,\n+                       Heap::kEmptyFixedArrayRootIndex);\n+  StoreObjectFieldRoot(result, JSProxyRevocableResult::kElementsOffset,\n+                       Heap::kEmptyFixedArrayRootIndex);\n+  StoreObjectFieldNoWriteBarrier(result, JSProxyRevocableResult::kProxyOffset,\n+                                 proxy);\n+  StoreObjectFieldNoWriteBarrier(result, JSProxyRevocableResult::kRevokeOffset,\n+                                 revoke);\n+  Return(result);\n+\n+  BIND(&throw_proxy_non_object);\n+  ThrowTypeError(context, MessageTemplate::kProxyNonObject);\n+\n+  BIND(&throw_proxy_handler_or_target_revoked);\n+  ThrowTypeError(context, MessageTemplate::kProxyHandlerOrTargetRevoked);\n+}\n+\n+// Proxy Revocation Functions\n+// https://tc39.github.io/ecma262/#sec-proxy-revocation-functions\n+TF_BUILTIN(ProxyRevoke, ProxiesCodeStubAssembler) {\n+  Node* const context = Parameter(Descriptor::kContext);\n+\n+  // 1. Let p be F.[[RevocableProxy]].\n+  Node* const proxy_slot = IntPtrConstant(kProxySlot);\n+  Node* const proxy = LoadContextElement(context, proxy_slot);\n+\n+  Label revoke_called(this);\n+\n+  // 2. If p is null, ...\n+  GotoIf(IsNull(proxy), &revoke_called);\n+\n+  // 3. Set F.[[RevocableProxy]] to null.\n+  StoreContextElement(context, proxy_slot, NullConstant());\n+\n+  // 4. Assert: p is a Proxy object.\n+  CSA_ASSERT(this, IsJSProxy(proxy));\n+\n+  // 5. Set p.[[ProxyTarget]] to null.\n+  StoreObjectField(proxy, JSProxy::kTargetOffset, NullConstant());\n+\n+  // 6. Set p.[[ProxyHandler]] to null.\n+  StoreObjectField(proxy, JSProxy::kHandlerOffset, NullConstant());\n+\n+  // 7. Return undefined.\n+  Return(UndefinedConstant());\n+\n+  BIND(&revoke_called);\n+  // 2. ... return undefined.\n+  Return(UndefinedConstant());\n+}\n+\n TF_BUILTIN(CallProxy, ProxiesCodeStubAssembler) {\n   Node* argc = Parameter(Descriptor::kActualArgumentsCount);\n   Node* argc_ptr = ChangeInt32ToIntPtr(argc);"
        },
        {
            "sha": "92b175bfde94c199dc02703f29acb7dc4e550a75",
            "filename": "deps/v8/src/builtins/builtins-proxy-gen.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-proxy-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-proxy-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-proxy-gen.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -27,17 +27,26 @@ class ProxiesCodeStubAssembler : public CodeStubAssembler {\n                          Node* receiver);\n \n  protected:\n+  enum ProxyRevokeFunctionContextSlot {\n+    kProxySlot = Context::MIN_CONTEXT_SLOTS,\n+    kProxyContextLength,\n+  };\n+\n   void GotoIfRevokedProxy(Node* object, Label* if_proxy_revoked);\n   Node* AllocateProxy(Node* target, Node* handler, Node* context);\n   Node* AllocateJSArrayForCodeStubArguments(Node* context,\n                                             CodeStubArguments& args, Node* argc,\n                                             ParameterMode mode);\n+  Node* AllocateProxyRevokeFunction(Node* proxy, Node* context);\n   void CheckHasTrapResult(Node* context, Node* target, Node* proxy, Node* name,\n                           Label* check_passed, Label* if_bailout);\n \n   void CheckGetSetTrapResult(Node* context, Node* target, Node* proxy,\n                              Node* name, Node* trap_result, Label* if_not_found,\n                              JSProxy::AccessKind access_kind);\n+\n+ private:\n+  Node* CreateProxyRevokeFunctionContext(Node* proxy, Node* native_context);\n };\n \n }  // namespace internal"
        },
        {
            "sha": "4227c628d1c41a252ef0d7a217945ed53fea2e2f",
            "filename": "deps/v8/src/builtins/builtins-regexp-gen.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 40,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -62,15 +62,15 @@ Node* RegExpBuiltinsAssembler::AllocateRegExpResult(Node* context, Node* length,\n       LoadContextElement(native_context, Context::REGEXP_RESULT_MAP_INDEX);\n   StoreMapNoWriteBarrier(result, map);\n \n-  Node* const empty_array = EmptyFixedArrayConstant();\n-  DCHECK(Heap::RootIsImmortalImmovable(Heap::kEmptyFixedArrayRootIndex));\n   StoreObjectFieldNoWriteBarrier(result, JSArray::kPropertiesOrHashOffset,\n-                                 empty_array);\n+                                 EmptyFixedArrayConstant());\n   StoreObjectFieldNoWriteBarrier(result, JSArray::kElementsOffset, elements);\n   StoreObjectFieldNoWriteBarrier(result, JSArray::kLengthOffset, length);\n \n   StoreObjectFieldNoWriteBarrier(result, JSRegExpResult::kIndexOffset, index);\n-  StoreObjectField(result, JSRegExpResult::kInputOffset, input);\n+  StoreObjectFieldNoWriteBarrier(result, JSRegExpResult::kInputOffset, input);\n+  StoreObjectFieldNoWriteBarrier(result, JSRegExpResult::kGroupsOffset,\n+                                 UndefinedConstant());\n \n   // Initialize the elements.\n \n@@ -223,8 +223,6 @@ Node* RegExpBuiltinsAssembler::ConstructNewResultFromMatchInfo(\n     // Allocate a new object to store the named capture properties.\n     // TODO(jgruber): Could be optimized by adding the object map to the heap\n     // root list.\n-    // TODO(jgruber): Replace CreateDataProperty runtime calls once we have\n-    // equivalent functionality in CSA.\n \n     Node* const native_context = LoadNativeContext(context);\n     Node* const map = LoadContextElement(\n@@ -233,14 +231,7 @@ Node* RegExpBuiltinsAssembler::ConstructNewResultFromMatchInfo(\n         AllocateNameDictionary(NameDictionary::kInitialCapacity);\n \n     Node* const group_object = AllocateJSObjectFromMap(map, properties);\n-\n-    // Store it on the result as a 'group' property.\n-\n-    {\n-      Node* const name = HeapConstant(isolate()->factory()->groups_string());\n-      CallRuntime(Runtime::kCreateDataProperty, context, result, name,\n-                  group_object);\n-    }\n+    StoreObjectField(result, JSRegExpResult::kGroupsOffset, group_object);\n \n     // One or more named captures exist, add a property for each one.\n \n@@ -267,6 +258,9 @@ Node* RegExpBuiltinsAssembler::ConstructNewResultFromMatchInfo(\n       Node* const capture =\n           LoadFixedArrayElement(result_elements, SmiUntag(index));\n \n+      // TODO(jgruber): Calling into runtime to create each property is slow.\n+      // Either we should create properties entirely in CSA (should be doable),\n+      // or only call runtime once and loop there.\n       CallRuntime(Runtime::kCreateDataProperty, context, group_object, name,\n                   capture);\n \n@@ -834,7 +828,7 @@ Node* RegExpBuiltinsAssembler::IsFastRegExpNoPrototype(Node* const context,\n   Label out(this);\n   VARIABLE(var_result, MachineRepresentation::kWord32);\n \n-#if defined(DEBUG) || defined(ENABLE_FASTSLOW_SWITCH)\n+#ifdef V8_ENABLE_FORCE_SLOW_PATH\n   var_result.Bind(Int32Constant(0));\n   GotoIfForceSlowPath(&out);\n #endif\n@@ -1225,8 +1219,7 @@ TF_BUILTIN(RegExpPrototypeFlagsGetter, RegExpBuiltinsAssembler) {\n   Node* const receiver = maybe_receiver;\n \n   Label if_isfastpath(this), if_isslowpath(this, Label::kDeferred);\n-  Branch(IsFastRegExpNoPrototype(context, receiver, map), &if_isfastpath,\n-         &if_isslowpath);\n+  BranchIfFastRegExp(context, receiver, map, &if_isfastpath, &if_isslowpath);\n \n   BIND(&if_isfastpath);\n   Return(FlagsGetter(context, receiver, true));\n@@ -2543,7 +2536,7 @@ TF_BUILTIN(RegExpSplit, RegExpBuiltinsAssembler) {\n   // to verify the constructor property and jump to the slow path if it has\n   // been changed.\n \n-  // Convert {maybe_limit} to a uint32, capping at the maximal smi value.\n+  // Verify {maybe_limit}.\n \n   VARIABLE(var_limit, MachineRepresentation::kTagged, maybe_limit);\n   Label if_limitissmimax(this), runtime(this, Label::kDeferred);\n@@ -2552,21 +2545,12 @@ TF_BUILTIN(RegExpSplit, RegExpBuiltinsAssembler) {\n     Label next(this);\n \n     GotoIf(IsUndefined(maybe_limit), &if_limitissmimax);\n-    GotoIf(TaggedIsPositiveSmi(maybe_limit), &next);\n-\n-    var_limit.Bind(ToUint32(context, maybe_limit));\n-    {\n-      // ToUint32(limit) could potentially change the shape of the RegExp\n-      // object. Recheck that we are still on the fast path and bail to runtime\n-      // otherwise.\n-      {\n-        Label next(this);\n-        BranchIfFastRegExp(context, regexp, &next, &runtime);\n-        BIND(&next);\n-      }\n+    Branch(TaggedIsPositiveSmi(maybe_limit), &next, &runtime);\n \n-      Branch(TaggedIsPositiveSmi(var_limit.value()), &next, &if_limitissmimax);\n-    }\n+    // We need to be extra-strict and require the given limit to be either\n+    // undefined or a positive smi. We can't call ToUint32(maybe_limit) since\n+    // that might move us onto the slow path, resulting in ordering spec\n+    // violations (see https://crbug.com/801171).\n \n     BIND(&if_limitissmimax);\n     {\n@@ -2590,13 +2574,8 @@ TF_BUILTIN(RegExpSplit, RegExpBuiltinsAssembler) {\n   RegExpPrototypeSplitBody(context, regexp, string, var_limit.value());\n \n   BIND(&runtime);\n-  {\n-    // The runtime call passes in limit to ensure the second ToUint32(limit)\n-    // call is not observable.\n-    CSA_ASSERT(this, IsNumber(var_limit.value()));\n-    Return(CallRuntime(Runtime::kRegExpSplit, context, regexp, string,\n-                       var_limit.value()));\n-  }\n+  Return(CallRuntime(Runtime::kRegExpSplit, context, regexp, string,\n+                     var_limit.value()));\n }\n \n // ES#sec-regexp.prototype-@@split\n@@ -2740,7 +2719,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(\n           TNode<IntPtrT> int_elem = SmiUntag(elem);\n           TNode<IntPtrT> new_match_start =\n               Signed(IntPtrAdd(WordShr(int_elem, IntPtrConstant(11)),\n-                               WordAnd(int_elem, IntPtrConstant(0x7ff))));\n+                               WordAnd(int_elem, IntPtrConstant(0x7FF))));\n           var_match_start = SmiTag(new_match_start);\n           Goto(&loop_epilogue);\n         }"
        },
        {
            "sha": "278a48c68e9f7651f174374ff642dfb3115e538f",
            "filename": "deps/v8/src/builtins/builtins-sharedarraybuffer-gen.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-sharedarraybuffer-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-sharedarraybuffer-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-sharedarraybuffer-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -213,7 +213,7 @@ TF_BUILTIN(AtomicsStore, SharedArrayBufferBuiltinsAssembler) {\n   ValidateAtomicIndex(array, index_word32, context);\n   Node* index_word = ChangeUint32ToWord(index_word32);\n \n-  Node* value_integer = ToInteger(context, value);\n+  Node* value_integer = ToInteger_Inline(CAST(context), CAST(value));\n   Node* value_word32 = TruncateTaggedToWord32(context, value_integer);\n \n #if DEBUG\n@@ -266,7 +266,7 @@ TF_BUILTIN(AtomicsExchange, SharedArrayBufferBuiltinsAssembler) {\n       ConvertTaggedAtomicIndexToWord32(index, context, &index_integer);\n   ValidateAtomicIndex(array, index_word32, context);\n \n-  Node* value_integer = ToInteger(context, value);\n+  Node* value_integer = ToInteger_Inline(CAST(context), CAST(value));\n \n #if DEBUG\n   DebugSanityCheckAtomicIndex(array, index_word32, context);\n@@ -340,8 +340,8 @@ TF_BUILTIN(AtomicsCompareExchange, SharedArrayBufferBuiltinsAssembler) {\n       ConvertTaggedAtomicIndexToWord32(index, context, &index_integer);\n   ValidateAtomicIndex(array, index_word32, context);\n \n-  Node* old_value_integer = ToInteger(context, old_value);\n-  Node* new_value_integer = ToInteger(context, new_value);\n+  Node* old_value_integer = ToInteger_Inline(CAST(context), CAST(old_value));\n+  Node* new_value_integer = ToInteger_Inline(CAST(context), CAST(new_value));\n \n #if DEBUG\n   DebugSanityCheckAtomicIndex(array, index_word32, context);\n@@ -436,7 +436,7 @@ void SharedArrayBufferBuiltinsAssembler::AtomicBinopBuiltinCommon(\n       ConvertTaggedAtomicIndexToWord32(index, context, &index_integer);\n   ValidateAtomicIndex(array, index_word32, context);\n \n-  Node* value_integer = ToInteger(context, value);\n+  Node* value_integer = ToInteger_Inline(CAST(context), CAST(value));\n \n #if DEBUG\n   // In Debug mode, we re-validate the index as a sanity check because"
        },
        {
            "sha": "195572de8ed0f38cea7776f62437fcc25ce077ad",
            "filename": "deps/v8/src/builtins/builtins-string-gen.cc",
            "status": "modified",
            "additions": 106,
            "deletions": 130,
            "changes": 236,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -126,8 +126,8 @@ Node* StringBuiltinsAssembler::PointerToStringDataAtIndex(\n \n void StringBuiltinsAssembler::ConvertAndBoundsCheckStartArgument(\n     Node* context, Variable* var_start, Node* start, Node* string_length) {\n-  TNode<Object> const start_int =\n-      ToInteger(context, start, CodeStubAssembler::kTruncateMinusZero);\n+  TNode<Object> const start_int = ToInteger_Inline(\n+      CAST(context), CAST(start), CodeStubAssembler::kTruncateMinusZero);\n   TNode<Smi> const zero = SmiConstant(0);\n \n   Label done(this);\n@@ -319,6 +319,31 @@ void StringBuiltinsAssembler::StringEqual_Loop(\n   }\n }\n \n+void StringBuiltinsAssembler::GenerateStringAt(char const* method_name,\n+                                               TNode<Context> context,\n+                                               Node* receiver,\n+                                               TNode<Object> maybe_position,\n+                                               TNode<Object> default_return,\n+                                               StringAtAccessor accessor) {\n+  // Check that {receiver} is coercible to Object and convert it to a String.\n+  TNode<String> string = ToThisString(context, receiver, method_name);\n+\n+  // Convert the {position} to a Smi and check that it's in bounds of the\n+  // {string}.\n+  Label if_outofbounds(this, Label::kDeferred);\n+  TNode<Number> position = ToInteger_Inline(\n+      context, maybe_position, CodeStubAssembler::kTruncateMinusZero);\n+  GotoIfNot(TaggedIsSmi(position), &if_outofbounds);\n+  TNode<IntPtrT> index = SmiUntag(CAST(position));\n+  TNode<IntPtrT> length = LoadStringLengthAsWord(string);\n+  GotoIfNot(UintPtrLessThan(index, length), &if_outofbounds);\n+  TNode<Object> result = accessor(string, length, index);\n+  Return(result);\n+\n+  BIND(&if_outofbounds);\n+  Return(default_return);\n+}\n+\n void StringBuiltinsAssembler::GenerateStringRelationalComparison(Node* context,\n                                                                  Node* left,\n                                                                  Node* right,\n@@ -526,28 +551,43 @@ TF_BUILTIN(StringGreaterThanOrEqual, StringBuiltinsAssembler) {\n                                      Operation::kGreaterThanOrEqual);\n }\n \n-TF_BUILTIN(StringCharAt, CodeStubAssembler) {\n+TF_BUILTIN(StringCharAt, StringBuiltinsAssembler) {\n   Node* receiver = Parameter(Descriptor::kReceiver);\n   Node* position = Parameter(Descriptor::kPosition);\n \n   // Load the character code at the {position} from the {receiver}.\n-  Node* code = StringCharCodeAt(receiver, position);\n+  TNode<Int32T> code = StringCharCodeAt(receiver, position);\n \n   // And return the single character string with only that {code}\n-  Node* result = StringFromCharCode(code);\n+  TNode<String> result = StringFromCharCode(code);\n   Return(result);\n }\n \n-TF_BUILTIN(StringCharCodeAt, CodeStubAssembler) {\n+TF_BUILTIN(StringCharCodeAt, StringBuiltinsAssembler) {\n   Node* receiver = Parameter(Descriptor::kReceiver);\n   Node* position = Parameter(Descriptor::kPosition);\n \n   // Load the character code at the {position} from the {receiver}.\n-  Node* code = StringCharCodeAt(receiver, position);\n+  TNode<Int32T> code = StringCharCodeAt(receiver, position);\n+\n+  // And return it as TaggedSigned value.\n+  // TODO(turbofan): Allow builtins to return values untagged.\n+  TNode<Smi> result = SmiFromWord32(code);\n+  Return(result);\n+}\n+\n+TF_BUILTIN(StringCodePointAt, StringBuiltinsAssembler) {\n+  Node* receiver = Parameter(Descriptor::kReceiver);\n+  Node* position = Parameter(Descriptor::kPosition);\n \n+  // TODO(sigurds) Figure out if passing length as argument pays off.\n+  TNode<IntPtrT> length = LoadStringLengthAsWord(receiver);\n+  // Load the character code at the {position} from the {receiver}.\n+  TNode<Int32T> code =\n+      LoadSurrogatePairAt(receiver, length, position, UnicodeEncoding::UTF32);\n   // And return it as TaggedSigned value.\n   // TODO(turbofan): Allow builtins to return values untagged.\n-  Node* result = SmiFromWord32(code);\n+  TNode<Smi> result = SmiFromWord32(code);\n   Return(result);\n }\n \n@@ -563,7 +603,7 @@ TF_BUILTIN(StringFromCharCode, CodeStubAssembler) {\n   Node* context = Parameter(BuiltinDescriptor::kContext);\n \n   CodeStubArguments arguments(this, ChangeInt32ToIntPtr(argc));\n-  TNode<Smi> smi_argc = SmiTag(arguments.GetLength());\n+  TNode<Smi> smi_argc = SmiTag(arguments.GetLength(INTPTR_PARAMETERS));\n   // Check if we have exactly one argument (plus the implicit receiver), i.e.\n   // if the parent frame is not an arguments adaptor frame.\n   Label if_oneargument(this), if_notoneargument(this);\n@@ -577,7 +617,8 @@ TF_BUILTIN(StringFromCharCode, CodeStubAssembler) {\n     // string on the fly otherwise.\n     Node* code = arguments.AtIndex(0);\n     Node* code32 = TruncateTaggedToWord32(context, code);\n-    Node* code16 = Word32And(code32, Int32Constant(String::kMaxUtf16CodeUnit));\n+    TNode<Int32T> code16 =\n+        Signed(Word32And(code32, Int32Constant(String::kMaxUtf16CodeUnit)));\n     Node* result = StringFromCharCode(code16);\n     arguments.PopAndReturn(result);\n   }\n@@ -662,115 +703,49 @@ TF_BUILTIN(StringFromCharCode, CodeStubAssembler) {\n }\n \n // ES6 #sec-string.prototype.charat\n-TF_BUILTIN(StringPrototypeCharAt, CodeStubAssembler) {\n+TF_BUILTIN(StringPrototypeCharAt, StringBuiltinsAssembler) {\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   Node* receiver = Parameter(Descriptor::kReceiver);\n-  Node* position = Parameter(Descriptor::kPosition);\n-  Node* context = Parameter(Descriptor::kContext);\n-\n-  // Check that {receiver} is coercible to Object and convert it to a String.\n-  receiver = ToThisString(context, receiver, \"String.prototype.charAt\");\n-\n-  // Convert the {position} to a Smi and check that it's in bounds of the\n-  // {receiver}.\n-  {\n-    Label return_emptystring(this, Label::kDeferred);\n-    position =\n-        ToInteger(context, position, CodeStubAssembler::kTruncateMinusZero);\n-    GotoIfNot(TaggedIsSmi(position), &return_emptystring);\n-\n-    // Determine the actual length of the {receiver} String.\n-    TNode<Smi> receiver_length = LoadStringLengthAsSmi(receiver);\n-\n-    // Return \"\" if the Smi {position} is outside the bounds of the {receiver}.\n-    Label if_positioninbounds(this);\n-    Branch(SmiAboveOrEqual(position, receiver_length), &return_emptystring,\n-           &if_positioninbounds);\n-\n-    BIND(&return_emptystring);\n-    Return(EmptyStringConstant());\n-\n-    BIND(&if_positioninbounds);\n-  }\n-\n-  // Load the character code at the {position} from the {receiver}.\n-  CSA_ASSERT(this, IntPtrLessThan(SmiUntag(position),\n-                                  LoadStringLengthAsWord(receiver)));\n-  CSA_ASSERT(this,\n-             IntPtrGreaterThanOrEqual(SmiUntag(position), IntPtrConstant(0)));\n-  Node* code = StringCharCodeAt(receiver, SmiUntag(position));\n+  TNode<Object> maybe_position = CAST(Parameter(Descriptor::kPosition));\n \n-  // And return the single character string with only that {code}.\n-  Node* result = StringFromCharCode(code);\n-  Return(result);\n+  GenerateStringAt(\"String.prototype.charAt\", context, receiver, maybe_position,\n+                   EmptyStringConstant(),\n+                   [this](TNode<String> string, TNode<IntPtrT> length,\n+                          TNode<IntPtrT> index) {\n+                     TNode<Int32T> code = StringCharCodeAt(string, index);\n+                     return StringFromCharCode(code);\n+                   });\n }\n \n // ES6 #sec-string.prototype.charcodeat\n-TF_BUILTIN(StringPrototypeCharCodeAt, CodeStubAssembler) {\n+TF_BUILTIN(StringPrototypeCharCodeAt, StringBuiltinsAssembler) {\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   Node* receiver = Parameter(Descriptor::kReceiver);\n-  Node* position = Parameter(Descriptor::kPosition);\n-  Node* context = Parameter(Descriptor::kContext);\n-\n-  // Check that {receiver} is coercible to Object and convert it to a String.\n-  receiver = ToThisString(context, receiver, \"String.prototype.charCodeAt\");\n-\n-  // Convert the {position} to a Smi and check that it's in bounds of the\n-  // {receiver}.\n-  {\n-    Label return_nan(this, Label::kDeferred);\n-    position =\n-        ToInteger(context, position, CodeStubAssembler::kTruncateMinusZero);\n-    GotoIfNot(TaggedIsSmi(position), &return_nan);\n-\n-    // Determine the actual length of the {receiver} String.\n-    TNode<Smi> receiver_length = LoadStringLengthAsSmi(receiver);\n-\n-    // Return NaN if the Smi {position} is outside the bounds of the {receiver}.\n-    Label if_positioninbounds(this);\n-    Branch(SmiAboveOrEqual(position, receiver_length), &return_nan,\n-           &if_positioninbounds);\n+  TNode<Object> maybe_position = CAST(Parameter(Descriptor::kPosition));\n \n-    BIND(&return_nan);\n-    Return(NaNConstant());\n-\n-    BIND(&if_positioninbounds);\n-  }\n-\n-  // Load the character at the {position} from the {receiver}.\n-  Node* value = StringCharCodeAt(receiver, SmiUntag(position));\n-  Node* result = SmiFromWord32(value);\n-  Return(result);\n+  GenerateStringAt(\"String.prototype.charCodeAt\", context, receiver,\n+                   maybe_position, NanConstant(),\n+                   [this](TNode<String> receiver, TNode<IntPtrT> length,\n+                          TNode<IntPtrT> index) {\n+                     Node* value = StringCharCodeAt(receiver, index);\n+                     return SmiFromWord32(value);\n+                   });\n }\n \n // ES6 #sec-string.prototype.codepointat\n TF_BUILTIN(StringPrototypeCodePointAt, StringBuiltinsAssembler) {\n-  Node* context = Parameter(Descriptor::kContext);\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   Node* receiver = Parameter(Descriptor::kReceiver);\n-  Node* position = Parameter(Descriptor::kPosition);\n-\n-  // Check that {receiver} is coercible to Object and convert it to a String.\n-  receiver = ToThisString(context, receiver, \"String.prototype.codePointAt\");\n-\n-  // Convert the {position} to a Smi and check that it's in bounds of the\n-  // {receiver}.\n-  Label if_inbounds(this), if_outofbounds(this, Label::kDeferred);\n-  position =\n-      ToInteger(context, position, CodeStubAssembler::kTruncateMinusZero);\n-  GotoIfNot(TaggedIsSmi(position), &if_outofbounds);\n-  TNode<IntPtrT> untagged_position = SmiUntag(position);\n-  TNode<IntPtrT> receiver_length = LoadStringLengthAsWord(receiver);\n-  Branch(UintPtrLessThan(untagged_position, receiver_length), &if_inbounds,\n-         &if_outofbounds);\n-\n-  BIND(&if_inbounds);\n-  {\n-    Node* value = LoadSurrogatePairAt(\n-        receiver, receiver_length, untagged_position, UnicodeEncoding::UTF32);\n-    Node* result = SmiFromWord32(value);\n-    Return(result);\n-  }\n+  TNode<Object> maybe_position = CAST(Parameter(Descriptor::kPosition));\n \n-  BIND(&if_outofbounds);\n-  Return(UndefinedConstant());\n+  GenerateStringAt(\"String.prototype.codePointAt\", context, receiver,\n+                   maybe_position, UndefinedConstant(),\n+                   [this](TNode<String> receiver, TNode<IntPtrT> length,\n+                          TNode<IntPtrT> index) {\n+                     Node* value = LoadSurrogatePairAt(receiver, length, index,\n+                                                       UnicodeEncoding::UTF32);\n+                     return SmiFromWord32(value);\n+                   });\n }\n \n // ES6 String.prototype.concat(...args)\n@@ -999,7 +974,7 @@ void StringIncludesIndexOfAssembler::Generate(SearchVariant variant) {\n   CodeStubArguments arguments(this, ChangeInt32ToIntPtr(argc));\n   Node* const receiver = arguments.GetReceiver();\n   // From now on use word-size argc value.\n-  argc = arguments.GetLength();\n+  argc = arguments.GetLength(INTPTR_PARAMETERS);\n \n   VARIABLE(var_search_string, MachineRepresentation::kTagged);\n   VARIABLE(var_position, MachineRepresentation::kTagged);\n@@ -1217,16 +1192,17 @@ TF_BUILTIN(StringPrototypeRepeat, StringBuiltinsAssembler) {\n   Label invalid_count(this), invalid_string_length(this),\n       return_emptystring(this);\n \n-  Node* const context = Parameter(Descriptor::kContext);\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   Node* const receiver = Parameter(Descriptor::kReceiver);\n-  Node* const count = Parameter(Descriptor::kCount);\n+  TNode<Object> count = CAST(Parameter(Descriptor::kCount));\n   Node* const string =\n       ToThisString(context, receiver, \"String.prototype.repeat\");\n   Node* const is_stringempty =\n       SmiEqual(LoadStringLengthAsSmi(string), SmiConstant(0));\n \n-  VARIABLE(var_count, MachineRepresentation::kTagged,\n-           ToInteger(context, count, CodeStubAssembler::kTruncateMinusZero));\n+  VARIABLE(\n+      var_count, MachineRepresentation::kTagged,\n+      ToInteger_Inline(context, count, CodeStubAssembler::kTruncateMinusZero));\n \n   // Verifies a valid count and takes a fast path when the result will be an\n   // empty string.\n@@ -1713,8 +1689,8 @@ TF_BUILTIN(StringPrototypeSlice, StringBuiltinsAssembler) {\n   CodeStubArguments args(this, argc);\n   Node* const receiver = args.GetReceiver();\n   Node* const start = args.GetOptionalArgumentValue(kStart);\n-  Node* const end = args.GetOptionalArgumentValue(kEnd);\n-  Node* const context = Parameter(BuiltinDescriptor::kContext);\n+  TNode<Object> end = CAST(args.GetOptionalArgumentValue(kEnd));\n+  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n \n   TNode<Smi> const smi_zero = SmiConstant(0);\n \n@@ -1737,7 +1713,7 @@ TF_BUILTIN(StringPrototypeSlice, StringBuiltinsAssembler) {\n \n   // else let intEnd be ? ToInteger(end).\n   Node* const end_int =\n-      ToInteger(context, end, CodeStubAssembler::kTruncateMinusZero);\n+      ToInteger_Inline(context, end, CodeStubAssembler::kTruncateMinusZero);\n \n   // 7. If intEnd < 0, let to be max(len + intEnd, 0);\n   //    otherwise let to be min(intEnd, len).\n@@ -1893,8 +1869,8 @@ TF_BUILTIN(StringPrototypeSubstr, StringBuiltinsAssembler) {\n \n   Node* const receiver = args.GetReceiver();\n   Node* const start = args.GetOptionalArgumentValue(kStartArg);\n-  Node* const length = args.GetOptionalArgumentValue(kLengthArg);\n-  Node* const context = Parameter(BuiltinDescriptor::kContext);\n+  TNode<Object> length = CAST(args.GetOptionalArgumentValue(kLengthArg));\n+  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n \n   Label out(this);\n \n@@ -1925,8 +1901,8 @@ TF_BUILTIN(StringPrototypeSubstr, StringBuiltinsAssembler) {\n     Goto(&if_issmi);\n \n     BIND(&if_isnotundefined);\n-    var_length =\n-        ToInteger(context, length, CodeStubAssembler::kTruncateMinusZero);\n+    var_length = ToInteger_Inline(context, length,\n+                                  CodeStubAssembler::kTruncateMinusZero);\n   }\n \n   TVARIABLE(Smi, var_result_length);\n@@ -1984,7 +1960,7 @@ TNode<Smi> StringBuiltinsAssembler::ToSmiBetweenZeroAnd(\n   TVARIABLE(Smi, var_result);\n \n   TNode<Object> const value_int =\n-      this->ToInteger(context, value, CodeStubAssembler::kTruncateMinusZero);\n+      ToInteger_Inline(context, value, CodeStubAssembler::kTruncateMinusZero);\n \n   Label if_issmi(this), if_isnotsmi(this, Label::kDeferred);\n   Branch(TaggedIsSmi(value_int), &if_issmi, &if_isnotsmi);\n@@ -2296,14 +2272,14 @@ TF_BUILTIN(StringPrototypeIterator, CodeStubAssembler) {\n \n // Return the |word32| codepoint at {index}. Supports SeqStrings and\n // ExternalStrings.\n-TNode<Uint32T> StringBuiltinsAssembler::LoadSurrogatePairAt(\n+TNode<Int32T> StringBuiltinsAssembler::LoadSurrogatePairAt(\n     SloppyTNode<String> string, SloppyTNode<IntPtrT> length,\n     SloppyTNode<IntPtrT> index, UnicodeEncoding encoding) {\n   Label handle_surrogate_pair(this), return_result(this);\n-  TVARIABLE(Uint32T, var_result);\n-  TVARIABLE(Uint32T, var_trail);\n+  TVARIABLE(Int32T, var_result);\n+  TVARIABLE(Int32T, var_trail);\n   var_result = StringCharCodeAt(string, index);\n-  var_trail = Unsigned(Int32Constant(0));\n+  var_trail = Int32Constant(0);\n \n   GotoIf(Word32NotEqual(Word32And(var_result, Int32Constant(0xFC00)),\n                         Int32Constant(0xD800)),\n@@ -2318,8 +2294,8 @@ TNode<Uint32T> StringBuiltinsAssembler::LoadSurrogatePairAt(\n \n   BIND(&handle_surrogate_pair);\n   {\n-    TNode<Uint32T> lead = var_result;\n-    TNode<Uint32T> trail = var_trail;\n+    TNode<Int32T> lead = var_result;\n+    TNode<Int32T> trail = var_trail;\n \n     // Check that this path is only taken if a surrogate pair is found\n     CSA_SLOW_ASSERT(this,\n@@ -2331,7 +2307,7 @@ TNode<Uint32T> StringBuiltinsAssembler::LoadSurrogatePairAt(\n \n     switch (encoding) {\n       case UnicodeEncoding::UTF16:\n-        var_result = Unsigned(Word32Or(\n+        var_result = Signed(Word32Or(\n // Need to swap the order for big-endian platforms\n #if V8_TARGET_BIG_ENDIAN\n             Word32Shl(lead, Int32Constant(16)), trail));\n@@ -2347,8 +2323,8 @@ TNode<Uint32T> StringBuiltinsAssembler::LoadSurrogatePairAt(\n             Int32Constant(0x10000 - (0xD800 << 10) - 0xDC00);\n \n         // (lead << 10) + trail + SURROGATE_OFFSET\n-        var_result = Unsigned(Int32Add(Word32Shl(lead, Int32Constant(10)),\n-                                       Int32Add(trail, surrogate_offset)));\n+        var_result = Signed(Int32Add(Word32Shl(lead, Int32Constant(10)),\n+                                     Int32Add(trail, surrogate_offset)));\n         break;\n       }\n     }\n@@ -2387,8 +2363,8 @@ TF_BUILTIN(StringIteratorPrototypeNext, StringBuiltinsAssembler) {\n   BIND(&next_codepoint);\n   {\n     UnicodeEncoding encoding = UnicodeEncoding::UTF16;\n-    Node* ch = LoadSurrogatePairAt(string, length, position, encoding);\n-    Node* value = StringFromCodePoint(ch, encoding);\n+    TNode<Int32T> ch = LoadSurrogatePairAt(string, length, position, encoding);\n+    TNode<String> value = StringFromCodePoint(ch, encoding);\n     var_value.Bind(value);\n     TNode<IntPtrT> length = LoadStringLengthAsWord(value);\n     StoreObjectFieldNoWriteBarrier(iterator, JSStringIterator::kNextIndexOffset,"
        },
        {
            "sha": "1bd5429fdba6bb527fe22091b911e41d420c3f66",
            "filename": "deps/v8/src/builtins/builtins-string-gen.h",
            "status": "modified",
            "additions": 13,
            "deletions": 4,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -57,10 +57,19 @@ class StringBuiltinsAssembler : public CodeStubAssembler {\n                                  SloppyTNode<Object> value,\n                                  SloppyTNode<Smi> limit);\n \n-  TNode<Uint32T> LoadSurrogatePairAt(SloppyTNode<String> string,\n-                                     SloppyTNode<IntPtrT> length,\n-                                     SloppyTNode<IntPtrT> index,\n-                                     UnicodeEncoding encoding);\n+  typedef std::function<TNode<Object>(\n+      TNode<String> receiver, TNode<IntPtrT> length, TNode<IntPtrT> index)>\n+      StringAtAccessor;\n+\n+  void GenerateStringAt(const char* method_name, TNode<Context> context,\n+                        Node* receiver, TNode<Object> maybe_position,\n+                        TNode<Object> default_return,\n+                        StringAtAccessor accessor);\n+\n+  TNode<Int32T> LoadSurrogatePairAt(SloppyTNode<String> string,\n+                                    SloppyTNode<IntPtrT> length,\n+                                    SloppyTNode<IntPtrT> index,\n+                                    UnicodeEncoding encoding);\n \n   void StringIndexOf(Node* const subject_string, Node* const search_string,\n                      Node* const position, std::function<void(Node*)> f_return);"
        },
        {
            "sha": "d2e447538d47d7c9f19eca5063552c15d324c244",
            "filename": "deps/v8/src/builtins/builtins-string.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -324,8 +324,8 @@ namespace {\n inline bool ToUpperOverflows(uc32 character) {\n   // y with umlauts and the micro sign are the only characters that stop\n   // fitting into one-byte when converting to uppercase.\n-  static const uc32 yuml_code = 0xff;\n-  static const uc32 micro_code = 0xb5;\n+  static const uc32 yuml_code = 0xFF;\n+  static const uc32 micro_code = 0xB5;\n   return (character == yuml_code || character == micro_code);\n }\n "
        },
        {
            "sha": "b830a8597d0fef52eb3f8ce6af7f9d4a9f7645d4",
            "filename": "deps/v8/src/builtins/builtins-typedarray-gen.cc",
            "status": "modified",
            "additions": 90,
            "deletions": 117,
            "changes": 207,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typedarray-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typedarray-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typedarray-gen.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -36,15 +36,17 @@ class TypedArrayBuiltinsAssembler : public CodeStubAssembler {\n                                                   const char* method_name,\n                                                   IterationKind iteration_kind);\n \n-  void SetupTypedArray(Node* holder, Node* length, Node* byte_offset,\n-                       Node* byte_length);\n-  void AttachBuffer(Node* holder, Node* buffer, Node* map, Node* length,\n-                    Node* byte_offset);\n-\n-  Node* LoadMapForType(Node* array);\n-  Node* CalculateExternalPointer(Node* backing_store, Node* byte_offset);\n+  void SetupTypedArray(TNode<JSTypedArray> holder, TNode<Smi> length,\n+                       TNode<Number> byte_offset, TNode<Number> byte_length);\n+  void AttachBuffer(TNode<JSTypedArray> holder, TNode<JSArrayBuffer> buffer,\n+                    TNode<Map> map, TNode<Smi> length,\n+                    TNode<Number> byte_offset);\n+\n+  TNode<Map> LoadMapForType(TNode<JSTypedArray> array);\n+  TNode<UintPtrT> CalculateExternalPointer(TNode<UintPtrT> backing_store,\n+                                           TNode<Number> byte_offset);\n   Node* LoadDataPtr(Node* typed_array);\n-  Node* ByteLengthIsValid(Node* byte_length);\n+  TNode<BoolT> ByteLengthIsValid(TNode<Number> byte_length);\n \n   // Returns true if kind is either UINT8_ELEMENTS or UINT8_CLAMPED_ELEMENTS.\n   TNode<Word32T> IsUint8ElementsKind(TNode<Word32T> kind);\n@@ -78,9 +80,8 @@ class TypedArrayBuiltinsAssembler : public CodeStubAssembler {\n                                                TNode<IntPtrT> offset);\n };\n \n-Node* TypedArrayBuiltinsAssembler::LoadMapForType(Node* array) {\n-  CSA_ASSERT(this, IsJSTypedArray(array));\n-\n+TNode<Map> TypedArrayBuiltinsAssembler::LoadMapForType(\n+    TNode<JSTypedArray> array) {\n   Label unreachable(this), done(this);\n   Label uint8_elements(this), uint8_clamped_elements(this), int8_elements(this),\n       uint16_elements(this), int16_elements(this), uint32_elements(this),\n@@ -99,10 +100,10 @@ Node* TypedArrayBuiltinsAssembler::LoadMapForType(Node* array) {\n   DCHECK_EQ(kTypedElementsKindCount, arraysize(elements_kinds));\n   DCHECK_EQ(kTypedElementsKindCount, arraysize(elements_kind_labels));\n \n-  VARIABLE(var_typed_map, MachineRepresentation::kTagged);\n+  TVARIABLE(Map, var_typed_map);\n \n-  Node* array_map = LoadMap(array);\n-  Node* elements_kind = LoadMapElementsKind(array_map);\n+  TNode<Map> array_map = LoadMap(array);\n+  TNode<Int32T> elements_kind = LoadMapElementsKind(array_map);\n   Switch(elements_kind, &unreachable, elements_kinds, elements_kind_labels,\n          kTypedElementsKindCount);\n \n@@ -113,15 +114,15 @@ Node* TypedArrayBuiltinsAssembler::LoadMapForType(Node* array) {\n       ExternalArrayType type =\n           isolate()->factory()->GetArrayTypeFromElementsKind(kind);\n       Handle<Map> map(isolate()->heap()->MapForFixedTypedArray(type));\n-      var_typed_map.Bind(HeapConstant(map));\n+      var_typed_map = HeapConstant(map);\n       Goto(&done);\n     }\n   }\n \n   BIND(&unreachable);\n   { Unreachable(); }\n   BIND(&done);\n-  return var_typed_map.value();\n+  return var_typed_map;\n }\n \n // The byte_offset can be higher than Smi range, in which case to perform the\n@@ -131,25 +132,21 @@ Node* TypedArrayBuiltinsAssembler::LoadMapForType(Node* array) {\n // can't allocate an array bigger than our 32-bit arithmetic range anyway. 64\n // bit platforms could theoretically have an offset up to 2^35 - 1, so we may\n // need to convert the float heap number to an intptr.\n-Node* TypedArrayBuiltinsAssembler::CalculateExternalPointer(Node* backing_store,\n-                                                            Node* byte_offset) {\n-  return IntPtrAdd(backing_store,\n-                   ChangeNonnegativeNumberToUintPtr(byte_offset));\n+TNode<UintPtrT> TypedArrayBuiltinsAssembler::CalculateExternalPointer(\n+    TNode<UintPtrT> backing_store, TNode<Number> byte_offset) {\n+  return Unsigned(\n+      IntPtrAdd(backing_store, ChangeNonnegativeNumberToUintPtr(byte_offset)));\n }\n \n // Setup the TypedArray which is under construction.\n //  - Set the length.\n //  - Set the byte_offset.\n //  - Set the byte_length.\n //  - Set EmbedderFields to 0.\n-void TypedArrayBuiltinsAssembler::SetupTypedArray(Node* holder, Node* length,\n-                                                  Node* byte_offset,\n-                                                  Node* byte_length) {\n-  CSA_ASSERT(this, IsJSTypedArray(holder));\n-  CSA_ASSERT(this, TaggedIsSmi(length));\n-  CSA_ASSERT(this, IsNumber(byte_offset));\n-  CSA_ASSERT(this, IsNumber(byte_length));\n-\n+void TypedArrayBuiltinsAssembler::SetupTypedArray(TNode<JSTypedArray> holder,\n+                                                  TNode<Smi> length,\n+                                                  TNode<Number> byte_offset,\n+                                                  TNode<Number> byte_length) {\n   StoreObjectField(holder, JSTypedArray::kLengthOffset, length);\n   StoreObjectField(holder, JSArrayBufferView::kByteOffsetOffset, byte_offset);\n   StoreObjectField(holder, JSArrayBufferView::kByteLengthOffset, byte_length);\n@@ -160,15 +157,11 @@ void TypedArrayBuiltinsAssembler::SetupTypedArray(Node* holder, Node* length,\n }\n \n // Attach an off-heap buffer to a TypedArray.\n-void TypedArrayBuiltinsAssembler::AttachBuffer(Node* holder, Node* buffer,\n-                                               Node* map, Node* length,\n-                                               Node* byte_offset) {\n-  CSA_ASSERT(this, IsJSTypedArray(holder));\n-  CSA_ASSERT(this, IsJSArrayBuffer(buffer));\n-  CSA_ASSERT(this, IsMap(map));\n-  CSA_ASSERT(this, TaggedIsSmi(length));\n-  CSA_ASSERT(this, IsNumber(byte_offset));\n-\n+void TypedArrayBuiltinsAssembler::AttachBuffer(TNode<JSTypedArray> holder,\n+                                               TNode<JSArrayBuffer> buffer,\n+                                               TNode<Map> map,\n+                                               TNode<Smi> length,\n+                                               TNode<Number> byte_offset) {\n   StoreObjectField(holder, JSArrayBufferView::kBufferOffset, buffer);\n \n   Node* elements = Allocate(FixedTypedArrayBase::kHeaderSize);\n@@ -177,10 +170,11 @@ void TypedArrayBuiltinsAssembler::AttachBuffer(Node* holder, Node* buffer,\n   StoreObjectFieldNoWriteBarrier(\n       elements, FixedTypedArrayBase::kBasePointerOffset, SmiConstant(0));\n \n-  Node* backing_store = LoadObjectField(\n-      buffer, JSArrayBuffer::kBackingStoreOffset, MachineType::Pointer());\n+  TNode<UintPtrT> backing_store =\n+      LoadObjectField<UintPtrT>(buffer, JSArrayBuffer::kBackingStoreOffset);\n \n-  Node* external_pointer = CalculateExternalPointer(backing_store, byte_offset);\n+  TNode<UintPtrT> external_pointer =\n+      CalculateExternalPointer(backing_store, byte_offset);\n   StoreObjectFieldNoWriteBarrier(\n       elements, FixedTypedArrayBase::kExternalPointerOffset, external_pointer,\n       MachineType::PointerRepresentation());\n@@ -189,42 +183,34 @@ void TypedArrayBuiltinsAssembler::AttachBuffer(Node* holder, Node* buffer,\n }\n \n TF_BUILTIN(TypedArrayInitializeWithBuffer, TypedArrayBuiltinsAssembler) {\n-  Node* holder = Parameter(Descriptor::kHolder);\n-  Node* length = Parameter(Descriptor::kLength);\n-  Node* buffer = Parameter(Descriptor::kBuffer);\n-  Node* element_size = Parameter(Descriptor::kElementSize);\n-  Node* byte_offset = Parameter(Descriptor::kByteOffset);\n-\n-  CSA_ASSERT(this, IsJSTypedArray(holder));\n-  CSA_ASSERT(this, TaggedIsSmi(length));\n-  CSA_ASSERT(this, IsJSArrayBuffer(buffer));\n-  CSA_ASSERT(this, TaggedIsSmi(element_size));\n-  CSA_ASSERT(this, IsNumber(byte_offset));\n+  TNode<JSTypedArray> holder = CAST(Parameter(Descriptor::kHolder));\n+  TNode<Smi> length = CAST(Parameter(Descriptor::kLength));\n+  TNode<JSArrayBuffer> buffer = CAST(Parameter(Descriptor::kBuffer));\n+  TNode<Smi> element_size = CAST(Parameter(Descriptor::kElementSize));\n+  TNode<Number> byte_offset = CAST(Parameter(Descriptor::kByteOffset));\n \n-  Node* fixed_typed_map = LoadMapForType(holder);\n+  TNode<Map> fixed_typed_map = LoadMapForType(holder);\n \n   // SmiMul returns a heap number in case of Smi overflow.\n-  Node* byte_length = SmiMul(length, element_size);\n-  CSA_ASSERT(this, IsNumber(byte_length));\n+  TNode<Number> byte_length = SmiMul(length, element_size);\n \n   SetupTypedArray(holder, length, byte_offset, byte_length);\n   AttachBuffer(holder, buffer, fixed_typed_map, length, byte_offset);\n   Return(UndefinedConstant());\n }\n \n TF_BUILTIN(TypedArrayInitialize, TypedArrayBuiltinsAssembler) {\n-  Node* holder = Parameter(Descriptor::kHolder);\n-  Node* length = Parameter(Descriptor::kLength);\n-  Node* element_size = Parameter(Descriptor::kElementSize);\n+  TNode<JSTypedArray> holder = CAST(Parameter(Descriptor::kHolder));\n+  TNode<Smi> length = CAST(Parameter(Descriptor::kLength));\n+  TNode<Smi> element_size = CAST(Parameter(Descriptor::kElementSize));\n   Node* initialize = Parameter(Descriptor::kInitialize);\n-  Node* context = Parameter(Descriptor::kContext);\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n \n-  CSA_ASSERT(this, IsJSTypedArray(holder));\n   CSA_ASSERT(this, TaggedIsPositiveSmi(length));\n   CSA_ASSERT(this, TaggedIsPositiveSmi(element_size));\n   CSA_ASSERT(this, IsBoolean(initialize));\n \n-  Node* byte_offset = SmiConstant(0);\n+  TNode<Smi> byte_offset = SmiConstant(0);\n \n   static const int32_t fta_base_data_offset =\n       FixedTypedArrayBase::kDataOffset - kHeapObjectTag;\n@@ -235,16 +221,16 @@ TF_BUILTIN(TypedArrayInitialize, TypedArrayBuiltinsAssembler) {\n   VARIABLE(var_total_size, MachineType::PointerRepresentation());\n \n   // SmiMul returns a heap number in case of Smi overflow.\n-  Node* byte_length = SmiMul(length, element_size);\n-  CSA_ASSERT(this, IsNumber(byte_length));\n+  TNode<Number> byte_length = SmiMul(length, element_size);\n \n   SetupTypedArray(holder, length, byte_offset, byte_length);\n \n-  Node* fixed_typed_map = LoadMapForType(holder);\n+  TNode<Map> fixed_typed_map = LoadMapForType(holder);\n   GotoIf(TaggedIsNotSmi(byte_length), &allocate_off_heap);\n   GotoIf(\n       SmiGreaterThan(byte_length, SmiConstant(V8_TYPED_ARRAY_MAX_SIZE_IN_HEAP)),\n       &allocate_off_heap);\n+  TNode<IntPtrT> word_byte_length = SmiToWord(CAST(byte_length));\n   Goto(&allocate_on_heap);\n \n   BIND(&allocate_on_heap);\n@@ -297,15 +283,15 @@ TF_BUILTIN(TypedArrayInitialize, TypedArrayBuiltinsAssembler) {\n     DCHECK_EQ(0, FixedTypedArrayBase::kHeaderSize & kObjectAlignmentMask);\n     Node* aligned_header_size =\n         IntPtrConstant(FixedTypedArrayBase::kHeaderSize + kObjectAlignmentMask);\n-    Node* size = IntPtrAdd(SmiToWord(byte_length), aligned_header_size);\n+    Node* size = IntPtrAdd(word_byte_length, aligned_header_size);\n     var_total_size.Bind(WordAnd(size, IntPtrConstant(~kObjectAlignmentMask)));\n     Goto(&allocate_elements);\n   }\n \n   BIND(&aligned);\n   {\n     Node* header_size = IntPtrConstant(FixedTypedArrayBase::kHeaderSize);\n-    var_total_size.Bind(IntPtrAdd(SmiToWord(byte_length), header_size));\n+    var_total_size.Bind(IntPtrAdd(word_byte_length, header_size));\n     Goto(&allocate_elements);\n   }\n \n@@ -344,37 +330,36 @@ TF_BUILTIN(TypedArrayInitialize, TypedArrayBuiltinsAssembler) {\n         ExternalConstant(ExternalReference::libc_memset_function(isolate()));\n     CallCFunction3(MachineType::AnyTagged(), MachineType::Pointer(),\n                    MachineType::IntPtr(), MachineType::UintPtr(), memset,\n-                   backing_store, IntPtrConstant(0), SmiToWord(byte_length));\n+                   backing_store, IntPtrConstant(0), word_byte_length);\n     Goto(&done);\n   }\n \n-  VARIABLE(var_buffer, MachineRepresentation::kTagged);\n+  TVARIABLE(JSArrayBuffer, var_buffer);\n \n   BIND(&allocate_off_heap);\n   {\n     GotoIf(IsFalse(initialize), &allocate_off_heap_no_init);\n \n     Node* buffer_constructor = LoadContextElement(\n         LoadNativeContext(context), Context::ARRAY_BUFFER_FUN_INDEX);\n-    var_buffer.Bind(ConstructJS(CodeFactory::Construct(isolate()), context,\n-                                buffer_constructor, byte_length));\n+    var_buffer = CAST(ConstructJS(CodeFactory::Construct(isolate()), context,\n+                                  buffer_constructor, byte_length));\n     Goto(&attach_buffer);\n   }\n \n   BIND(&allocate_off_heap_no_init);\n   {\n     Node* buffer_constructor_noinit = LoadContextElement(\n         LoadNativeContext(context), Context::ARRAY_BUFFER_NOINIT_FUN_INDEX);\n-    var_buffer.Bind(CallJS(CodeFactory::Call(isolate()), context,\n-                           buffer_constructor_noinit, UndefinedConstant(),\n-                           byte_length));\n+    var_buffer = CAST(CallJS(CodeFactory::Call(isolate()), context,\n+                             buffer_constructor_noinit, UndefinedConstant(),\n+                             byte_length));\n     Goto(&attach_buffer);\n   }\n \n   BIND(&attach_buffer);\n   {\n-    AttachBuffer(holder, var_buffer.value(), fixed_typed_map, length,\n-                 byte_offset);\n+    AttachBuffer(holder, var_buffer, fixed_typed_map, length, byte_offset);\n     Goto(&done);\n   }\n \n@@ -385,26 +370,26 @@ TF_BUILTIN(TypedArrayInitialize, TypedArrayBuiltinsAssembler) {\n // ES6 #sec-typedarray-length\n TF_BUILTIN(TypedArrayConstructByLength, TypedArrayBuiltinsAssembler) {\n   Node* holder = Parameter(Descriptor::kHolder);\n-  Node* length = Parameter(Descriptor::kLength);\n-  Node* element_size = Parameter(Descriptor::kElementSize);\n-  Node* context = Parameter(Descriptor::kContext);\n+  TNode<Object> maybe_length = CAST(Parameter(Descriptor::kLength));\n+  TNode<Object> element_size = CAST(Parameter(Descriptor::kElementSize));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n \n   CSA_ASSERT(this, IsJSTypedArray(holder));\n   CSA_ASSERT(this, TaggedIsPositiveSmi(element_size));\n \n-  Node* initialize = TrueConstant();\n-\n   Label invalid_length(this);\n \n-  length = ToInteger(context, length, CodeStubAssembler::kTruncateMinusZero);\n+  TNode<Number> length = ToInteger_Inline(\n+      context, maybe_length, CodeStubAssembler::kTruncateMinusZero);\n+\n   // The maximum length of a TypedArray is MaxSmi().\n   // Note: this is not per spec, but rather a constraint of our current\n   // representation (which uses smi's).\n   GotoIf(TaggedIsNotSmi(length), &invalid_length);\n   GotoIf(SmiLessThan(length, SmiConstant(0)), &invalid_length);\n \n   CallBuiltin(Builtins::kTypedArrayInitialize, context, holder, length,\n-              element_size, initialize);\n+              element_size, TrueConstant());\n   Return(UndefinedConstant());\n \n   BIND(&invalid_length);\n@@ -419,10 +404,10 @@ TF_BUILTIN(TypedArrayConstructByLength, TypedArrayBuiltinsAssembler) {\n TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {\n   Node* holder = Parameter(Descriptor::kHolder);\n   Node* buffer = Parameter(Descriptor::kBuffer);\n-  Node* byte_offset = Parameter(Descriptor::kByteOffset);\n+  TNode<Object> byte_offset = CAST(Parameter(Descriptor::kByteOffset));\n   Node* length = Parameter(Descriptor::kLength);\n   Node* element_size = Parameter(Descriptor::kElementSize);\n-  Node* context = Parameter(Descriptor::kContext);\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n \n   CSA_ASSERT(this, IsJSTypedArray(holder));\n   CSA_ASSERT(this, IsJSArrayBuffer(buffer));\n@@ -440,8 +425,8 @@ TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {\n \n   GotoIf(IsUndefined(byte_offset), &check_length);\n \n-  offset.Bind(\n-      ToInteger(context, byte_offset, CodeStubAssembler::kTruncateMinusZero));\n+  offset.Bind(ToInteger_Inline(context, byte_offset,\n+                               CodeStubAssembler::kTruncateMinusZero));\n   Branch(TaggedIsSmi(offset.value()), &offset_is_smi, &offset_not_smi);\n \n   // Check that the offset is a multiple of the element size.\n@@ -569,25 +554,27 @@ Node* TypedArrayBuiltinsAssembler::LoadDataPtr(Node* typed_array) {\n   return IntPtrAdd(base_pointer, external_pointer);\n }\n \n-Node* TypedArrayBuiltinsAssembler::ByteLengthIsValid(Node* byte_length) {\n+TNode<BoolT> TypedArrayBuiltinsAssembler::ByteLengthIsValid(\n+    TNode<Number> byte_length) {\n   Label smi(this), done(this);\n-  VARIABLE(is_valid, MachineRepresentation::kWord32);\n+  TVARIABLE(BoolT, is_valid);\n   GotoIf(TaggedIsSmi(byte_length), &smi);\n \n-  CSA_ASSERT(this, IsHeapNumber(byte_length));\n-  Node* float_value = LoadHeapNumberValue(byte_length);\n-  Node* max_byte_length_double =\n+  TNode<Float64T> float_value = LoadHeapNumberValue(CAST(byte_length));\n+  TNode<Float64T> max_byte_length_double =\n       Float64Constant(FixedTypedArrayBase::kMaxByteLength);\n-  is_valid.Bind(Float64LessThanOrEqual(float_value, max_byte_length_double));\n+  is_valid = Float64LessThanOrEqual(float_value, max_byte_length_double);\n   Goto(&done);\n \n   BIND(&smi);\n-  Node* max_byte_length = IntPtrConstant(FixedTypedArrayBase::kMaxByteLength);\n-  is_valid.Bind(UintPtrLessThanOrEqual(SmiUntag(byte_length), max_byte_length));\n+  TNode<IntPtrT> max_byte_length =\n+      IntPtrConstant(FixedTypedArrayBase::kMaxByteLength);\n+  is_valid =\n+      UintPtrLessThanOrEqual(SmiUntag(CAST(byte_length)), max_byte_length);\n   Goto(&done);\n \n   BIND(&done);\n-  return is_valid.value();\n+  return is_valid;\n }\n \n TF_BUILTIN(TypedArrayConstructByArrayLike, TypedArrayBuiltinsAssembler) {\n@@ -611,8 +598,8 @@ TF_BUILTIN(TypedArrayConstructByArrayLike, TypedArrayBuiltinsAssembler) {\n   Return(UndefinedConstant());\n \n   BIND(&fill);\n-  Node* holder_kind = LoadMapElementsKind(LoadMap(holder));\n-  Node* source_kind = LoadMapElementsKind(LoadMap(array_like));\n+  TNode<Int32T> holder_kind = LoadMapElementsKind(LoadMap(holder));\n+  TNode<Int32T> source_kind = LoadMapElementsKind(LoadMap(array_like));\n   GotoIf(Word32Equal(holder_kind, source_kind), &fast_copy);\n \n   // Copy using the elements accessor.\n@@ -632,9 +619,10 @@ TF_BUILTIN(TypedArrayConstructByArrayLike, TypedArrayBuiltinsAssembler) {\n                                      array_like, JSTypedArray::kBufferOffset)),\n                                  Int32Constant(0)));\n \n-    Node* byte_length = SmiMul(length, element_size);\n+    TNode<Number> byte_length = SmiMul(length, element_size);\n     CSA_ASSERT(this, ByteLengthIsValid(byte_length));\n-    Node* byte_length_intptr = ChangeNonnegativeNumberToUintPtr(byte_length);\n+    TNode<UintPtrT> byte_length_intptr =\n+        ChangeNonnegativeNumberToUintPtr(byte_length);\n     CSA_ASSERT(this, UintPtrLessThanOrEqual(\n                          byte_length_intptr,\n                          IntPtrConstant(FixedTypedArrayBase::kMaxByteLength)));\n@@ -831,24 +819,9 @@ void TypedArrayBuiltinsAssembler::SetTypedArraySource(\n \n   BIND(&fast_c_call);\n   {\n-    // Overlapping backing stores of different element kinds are handled in\n-    // runtime. We're a bit conservative here and bail to runtime if ranges\n-    // overlap and element kinds differ.\n-\n-    TNode<IntPtrT> target_byte_length =\n-        IntPtrMul(target_length, target_el_size);\n     CSA_ASSERT(\n-        this, UintPtrGreaterThanOrEqual(target_byte_length, IntPtrConstant(0)));\n-\n-    TNode<IntPtrT> target_data_end_ptr =\n-        IntPtrAdd(target_data_ptr, target_byte_length);\n-    TNode<IntPtrT> source_data_end_ptr =\n-        IntPtrAdd(source_data_ptr, source_byte_length);\n-\n-    GotoIfNot(\n-        Word32Or(UintPtrLessThanOrEqual(target_data_end_ptr, source_data_ptr),\n-                 UintPtrLessThanOrEqual(source_data_end_ptr, target_data_ptr)),\n-        call_runtime);\n+        this, UintPtrGreaterThanOrEqual(\n+                  IntPtrMul(target_length, target_el_size), IntPtrConstant(0)));\n \n     TNode<IntPtrT> source_length =\n         LoadAndUntagObjectField(source, JSTypedArray::kLengthOffset);\n@@ -959,8 +932,8 @@ TF_BUILTIN(TypedArrayPrototypeSet, TypedArrayBuiltinsAssembler) {\n \n   // Normalize offset argument (using ToInteger) and handle heap number cases.\n   TNode<Object> offset = args.GetOptionalArgumentValue(1, SmiConstant(0));\n-  TNode<Number> offset_num = ToInteger(context, offset, kTruncateMinusZero);\n-  CSA_ASSERT(this, IsNumberNormalized(offset_num));\n+  TNode<Number> offset_num =\n+      ToInteger_Inline(context, offset, kTruncateMinusZero);\n \n   // Since ToInteger always returns a Smi if the given value is within Smi\n   // range, and the only corner case of -0.0 has already been truncated to 0.0,"
        },
        {
            "sha": "6af5eff357248222df13f3947592478f093ac502",
            "filename": "deps/v8/src/builtins/builtins-utils-gen.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-utils-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-utils-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-utils-gen.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -47,6 +47,9 @@ class CodeAssemblerState;\n   void Builtins::Generate_##Name(compiler::CodeAssemblerState* state) {  \\\n     Name##Assembler assembler(state);                                    \\\n     state->SetInitialDebugInformation(#Name, __FILE__, __LINE__);        \\\n+    if (Builtins::KindOf(Builtins::k##Name) == Builtins::TFJ) {          \\\n+      assembler.PerformStackCheck(assembler.GetJSContextParameter());    \\\n+    }                                                                    \\\n     assembler.Generate##Name##Impl();                                    \\\n   }                                                                      \\\n   void Name##Assembler::Generate##Name##Impl()"
        },
        {
            "sha": "3493e776b6f859990ad2b9b978cd2091e013c78d",
            "filename": "deps/v8/src/builtins/builtins-utils.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-utils.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-utils.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-utils.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -85,7 +85,8 @@ class BuiltinArguments : public Arguments {\n   V8_NOINLINE static Object* Builtin_Impl_Stats_##name(                       \\\n       int args_length, Object** args_object, Isolate* isolate) {              \\\n     BuiltinArguments args(args_length, args_object);                          \\\n-    RuntimeCallTimerScope timer(isolate, &RuntimeCallStats::Builtin_##name);  \\\n+    RuntimeCallTimerScope timer(isolate,                                      \\\n+                                RuntimeCallCounterId::kBuiltin_##name);       \\\n     TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"v8.runtime\"),                     \\\n                  \"V8.Builtin_\" #name);                                        \\\n     return Builtin_Impl_##name(args, isolate);                                \\"
        },
        {
            "sha": "dc175e50b70756a22d0cb070d5a07990356cd713",
            "filename": "deps/v8/src/builtins/builtins.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47",
            "patch": "@@ -172,11 +172,25 @@ Callable Builtins::CallableFor(Isolate* isolate, Name name) {\n #undef CASE_OTHER\n     case kArrayFilterLoopEagerDeoptContinuation:\n     case kArrayFilterLoopLazyDeoptContinuation:\n+    case kArrayEveryLoopEagerDeoptContinuation:\n+    case kArrayEveryLoopLazyDeoptContinuation:\n+    case kArrayFindIndexLoopAfterCallbackLazyDeoptContinuation:\n+    case kArrayFindIndexLoopEagerDeoptContinuation:\n+    case kArrayFindIndexLoopLazyDeoptContinuation:\n+    case kArrayFindLoopAfterCallbackLazyDeoptContinuation:\n+    case kArrayFindLoopEagerDeoptContinuation:\n+    case kArrayFindLoopLazyDeoptContinuation:\n     case kArrayForEach:\n     case kArrayForEachLoopEagerDeoptContinuation:\n     case kArrayForEachLoopLazyDeoptContinuation:\n     case kArrayMapLoopEagerDeoptContinuation:\n     case kArrayMapLoopLazyDeoptContinuation:\n+    case kArrayReduceLoopEagerDeoptContinuation:\n+    case kArrayReduceLoopLazyDeoptContinuation:\n+    case kArrayReduceRightLoopEagerDeoptContinuation:\n+    case kArrayReduceRightLoopLazyDeoptContinuation:\n+    case kArraySomeLoopEagerDeoptContinuation:\n+    case kArraySomeLoopLazyDeoptContinuation:\n     case kConsoleAssert:\n       return Callable(code, BuiltinDescriptor(isolate));\n     default:\n@@ -213,12 +227,30 @@ bool Builtins::IsLazy(int index) {\n   // TODO(wasm): Remove wasm builtins once immovability is no longer required.\n   switch (index) {\n     case kAbort:  // Required by wasm.\n+    case kArrayFindLoopEagerDeoptContinuation:  // https://crbug.com/v8/6786.\n+    case kArrayFindLoopLazyDeoptContinuation:   // https://crbug.com/v8/6786.\n+    // https://crbug.com/v8/6786.\n+    case kArrayFindLoopAfterCallbackLazyDeoptContinuation:\n+    // https://crbug.com/v8/6786.\n+    case kArrayFindIndexLoopEagerDeoptContinuation:\n+    // https://crbug.com/v8/6786.\n+    case kArrayFindIndexLoopLazyDeoptContinuation:\n+    // https://crbug.com/v8/6786.\n+    case kArrayFindIndexLoopAfterCallbackLazyDeoptContinuation:\n     case kArrayForEachLoopEagerDeoptContinuation:  // https://crbug.com/v8/6786.\n     case kArrayForEachLoopLazyDeoptContinuation:   // https://crbug.com/v8/6786.\n     case kArrayMapLoopEagerDeoptContinuation:      // https://crbug.com/v8/6786.\n     case kArrayMapLoopLazyDeoptContinuation:       // https://crbug.com/v8/6786.\n+    case kArrayEveryLoopEagerDeoptContinuation:    // https://crbug.com/v8/6786.\n+    case kArrayEveryLoopLazyDeoptContinuation:     // https://crbug.com/v8/6786.\n     case kArrayFilterLoopEagerDeoptContinuation:   // https://crbug.com/v8/6786.\n     case kArrayFilterLoopLazyDeoptContinuation:    // https://crbug.com/v8/6786.\n+    case kArrayReduceLoopEagerDeoptContinuation:   // https://crbug.com/v8/6786.\n+    case kArrayReduceLoopLazyDeoptContinuation:    // https://crbug.com/v8/6786.\n+    case kArrayReduceRightLoopEagerDeoptContinuation:\n+    case kArrayReduceRightLoopLazyDeoptContinuation:\n+    case kArraySomeLoopEagerDeoptContinuation:  // https://crbug.com/v8/6786.\n+    case kArraySomeLoopLazyDeoptContinuation:   // https://crbug.com/v8/6786.\n     case kCheckOptimizationMarker:\n     case kCompileLazy:\n     case kDeserializeLazy:"
        },
        {
            "sha": "368e6670c10034b0ad3c1ee5fa4498d8d4bef558",
            "filename": "deps/v8/src/builtins/ia32/builtins-ia32.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fia32%2Fbuiltins-ia32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fia32%2Fbuiltins-ia32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fia32%2Fbuiltins-ia32.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "7af02bb32e01d4964d662fc6326dfc8104e19ca8",
            "filename": "deps/v8/src/builtins/mips/builtins-mips.cc",
            "status": "modified",
            "additions": 60,
            "deletions": 55,
            "changes": 115,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips%2Fbuiltins-mips.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips%2Fbuiltins-mips.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips%2Fbuiltins-mips.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "266393070c7e11894aaadaa45c2a4b6cf6d0a3e0",
            "filename": "deps/v8/src/builtins/mips64/builtins-mips64.cc",
            "status": "modified",
            "additions": 60,
            "deletions": 55,
            "changes": 115,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips64%2Fbuiltins-mips64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips64%2Fbuiltins-mips64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips64%2Fbuiltins-mips64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "34da70ff0f3509ecbc2383a6e402e10b7b6b14ac",
            "filename": "deps/v8/src/builtins/ppc/builtins-ppc.cc",
            "status": "modified",
            "additions": 55,
            "deletions": 52,
            "changes": 107,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fppc%2Fbuiltins-ppc.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fppc%2Fbuiltins-ppc.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fppc%2Fbuiltins-ppc.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "020b04b91d6bafb11aa4df9d3470899c41d005b6",
            "filename": "deps/v8/src/builtins/s390/builtins-s390.cc",
            "status": "modified",
            "additions": 56,
            "deletions": 53,
            "changes": 109,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fs390%2Fbuiltins-s390.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fs390%2Fbuiltins-s390.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fs390%2Fbuiltins-s390.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "5a09658867f53ddd83eefb965c3977ed8bdb36f0",
            "filename": "deps/v8/src/builtins/setup-builtins-internal.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fsetup-builtins-internal.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fsetup-builtins-internal.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fsetup-builtins-internal.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "cd35abb3625209a2e34910a486942973c56d0f04",
            "filename": "deps/v8/src/builtins/x64/builtins-x64.cc",
            "status": "modified",
            "additions": 57,
            "deletions": 55,
            "changes": 112,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fx64%2Fbuiltins-x64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fbuiltins%2Fx64%2Fbuiltins-x64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fx64%2Fbuiltins-x64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "08c9781414cb6c4fb82b045fb3a37e5c7cbbc8c9",
            "filename": "deps/v8/src/cached-powers.cc",
            "status": "modified",
            "additions": 87,
            "deletions": 87,
            "changes": 174,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcached-powers.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcached-powers.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcached-powers.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "e5b72b6fabcb3235fe58ede3d1e3a8e2418e6034",
            "filename": "deps/v8/src/code-factory.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-factory.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-factory.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-factory.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "079f16899af59ab03d8e76109affbbd045dea557",
            "filename": "deps/v8/src/code-factory.h",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-factory.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-factory.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-factory.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "f98e7fe519297ea9ac369e36c4ccc3e555a5fbd4",
            "filename": "deps/v8/src/code-stub-assembler.cc",
            "status": "modified",
            "additions": 605,
            "deletions": 645,
            "changes": 1250,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "4a72b203a78c0d9b68a1ee300ba74948176e6218",
            "filename": "deps/v8/src/code-stub-assembler.h",
            "status": "modified",
            "additions": 137,
            "deletions": 81,
            "changes": 218,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "2b98a5bfc78575898464b30cf565db36fcf87eaa",
            "filename": "deps/v8/src/code-stubs.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 42,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-stubs.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-stubs.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stubs.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "751a89fdbdf1eddede3da339c72154c795aab6cd",
            "filename": "deps/v8/src/code-stubs.h",
            "status": "modified",
            "additions": 56,
            "deletions": 102,
            "changes": 158,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-stubs.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcode-stubs.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stubs.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "27e6dbb9dabcf1e418876d2e9dbe0b49a84deb0a",
            "filename": "deps/v8/src/compilation-info.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompilation-info.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompilation-info.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompilation-info.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "bb5812002ee19f2cfdf173e55bb5de5f1a44787a",
            "filename": "deps/v8/src/compilation-info.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompilation-info.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompilation-info.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompilation-info.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "1adfd090cd8d8cd391022c47ad808623a8efb379",
            "filename": "deps/v8/src/compiler-dispatcher/compiler-dispatcher.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Fcompiler-dispatcher.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Fcompiler-dispatcher.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Fcompiler-dispatcher.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "e2f8ee0f3946c9188759988911c498c83dc8791d",
            "filename": "deps/v8/src/compiler.cc",
            "status": "modified",
            "additions": 99,
            "deletions": 42,
            "changes": 141,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "b84134c14eea7c6eacebd625f2bd9f45cf0e1cc2",
            "filename": "deps/v8/src/compiler.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "2e9052e0c38f51ef5964efeb284bc4a8d82b46e6",
            "filename": "deps/v8/src/compiler/OWNERS",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2FOWNERS",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2FOWNERS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2FOWNERS?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "13d6801c32387383e020fb29ef29a46f06e97f2d",
            "filename": "deps/v8/src/compiler/access-builder.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a2ce1f800b033cca05b47119bebe1349d6e99be7",
            "filename": "deps/v8/src/compiler/access-builder.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a238cf29d46250f6454a6f66a280d1b7657ec296",
            "filename": "deps/v8/src/compiler/arm/code-generator-arm.cc",
            "status": "modified",
            "additions": 116,
            "deletions": 209,
            "changes": 325,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Fcode-generator-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Fcode-generator-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Fcode-generator-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a7cf80450ae13d7186d87165c9d722145ec59bc4",
            "filename": "deps/v8/src/compiler/arm/instruction-codes-arm.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-codes-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-codes-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-codes-arm.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a592515179ed35787b089afb8ae6ed99fd60dc2c",
            "filename": "deps/v8/src/compiler/arm/instruction-scheduler-arm.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-scheduler-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-scheduler-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-scheduler-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "f94d114d07ebc3a582722e222c329dbbefbcd60f",
            "filename": "deps/v8/src/compiler/arm/instruction-selector-arm.cc",
            "status": "modified",
            "additions": 60,
            "deletions": 121,
            "changes": 181,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-selector-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-selector-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-selector-arm.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "147d85a171c7678424d77f0029448f3cafb98d11",
            "filename": "deps/v8/src/compiler/arm64/code-generator-arm64.cc",
            "status": "modified",
            "additions": 87,
            "deletions": 338,
            "changes": 425,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Fcode-generator-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Fcode-generator-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Fcode-generator-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "820b55a99d0db0859dcab78f5d74eae3bf032fe3",
            "filename": "deps/v8/src/compiler/arm64/instruction-codes-arm64.h",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-codes-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-codes-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-codes-arm64.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c2b0a4e386afcccef29cf0fecd05673882ccd3e0",
            "filename": "deps/v8/src/compiler/arm64/instruction-scheduler-arm64.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 24,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-scheduler-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-scheduler-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-scheduler-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "d6082c9f0a19f145d4b73e4651f0c1505d5d9cfc",
            "filename": "deps/v8/src/compiler/arm64/instruction-selector-arm64.cc",
            "status": "modified",
            "additions": 108,
            "deletions": 155,
            "changes": 263,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-selector-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-selector-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-selector-arm64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "53c3435b554085d154ebe0c934ce810cb07ec2d0",
            "filename": "deps/v8/src/compiler/branch-elimination.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fbranch-elimination.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fbranch-elimination.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fbranch-elimination.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "54a924fce4baf3653852150219fed86a75d9461a",
            "filename": "deps/v8/src/compiler/bytecode-graph-builder.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 16,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "91b857298ca1d502be6a88206ac3702cfbbfafb1",
            "filename": "deps/v8/src/compiler/bytecode-graph-builder.h",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "330b19fac3ddbb57ad0d31b47c02871054259958",
            "filename": "deps/v8/src/compiler/c-linkage.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fc-linkage.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fc-linkage.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fc-linkage.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "071f8952db6679de8138c426212c728c0da420fe",
            "filename": "deps/v8/src/compiler/code-assembler.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "9f0d463dc1a83f01e60c521425fe5b9498cb04db",
            "filename": "deps/v8/src/compiler/code-assembler.h",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "0fb38e5933cd3fabe5248923734e4d8795528ca0",
            "filename": "deps/v8/src/compiler/code-generator.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 8,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-generator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-generator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-generator.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "d9bc5c8173fbd937dc411cb3d8be6aa0d1110226",
            "filename": "deps/v8/src/compiler/common-operator-reducer.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator-reducer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator-reducer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator-reducer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "54af052d5607ba187cd227f6e96f190cf877ba43",
            "filename": "deps/v8/src/compiler/common-operator.cc",
            "status": "modified",
            "additions": 66,
            "deletions": 31,
            "changes": 97,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "0e0614dcedc305179fd2d599307e368a1750de59",
            "filename": "deps/v8/src/compiler/common-operator.h",
            "status": "modified",
            "additions": 15,
            "deletions": 7,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "523d37fe29dd80dc1f63092fcf8c290fde91509b",
            "filename": "deps/v8/src/compiler/dead-code-elimination.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 15,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fdead-code-elimination.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fdead-code-elimination.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fdead-code-elimination.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "217d58ef319d486728c9466b18e11cd9f1902c5c",
            "filename": "deps/v8/src/compiler/dead-code-elimination.h",
            "status": "modified",
            "additions": 21,
            "deletions": 9,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fdead-code-elimination.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fdead-code-elimination.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fdead-code-elimination.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a47941e28dca861aff76887b6721cb908ac73f97",
            "filename": "deps/v8/src/compiler/effect-control-linearizer.cc",
            "status": "modified",
            "additions": 368,
            "deletions": 142,
            "changes": 510,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "47b1586d6d9327f74dc30a2100b941a0d2957dca",
            "filename": "deps/v8/src/compiler/effect-control-linearizer.h",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "16a9d78fafa82ea6e3d3ee58c9d0b912ea4d14cd",
            "filename": "deps/v8/src/compiler/escape-analysis-reducer.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 14,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis-reducer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis-reducer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis-reducer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "29290d3a0a7ecf5c1dfa3032ac496c44b615ac7e",
            "filename": "deps/v8/src/compiler/escape-analysis-reducer.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis-reducer.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis-reducer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis-reducer.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "4b773136a929a3c2fb1623aa4baff1e9afc84f02",
            "filename": "deps/v8/src/compiler/escape-analysis.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 7,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "0b6d7ac1934c62109aba117f8479ac120653c2cc",
            "filename": "deps/v8/src/compiler/frame.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fframe.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fframe.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fframe.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "f5c36dba171968afc3a71e461d4a25ff33b79250",
            "filename": "deps/v8/src/compiler/frame.h",
            "status": "modified",
            "additions": 34,
            "deletions": 15,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fframe.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fframe.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fframe.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "4542a736856044a13f0abf21d18b41f7fa566b6f",
            "filename": "deps/v8/src/compiler/gap-resolver.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fgap-resolver.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fgap-resolver.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgap-resolver.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a0b2e0ff0a6669e5fd3bf14be0d075beaf2b3fbd",
            "filename": "deps/v8/src/compiler/graph-assembler.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 11,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "9ae74d0df57256f4c7d85af423dbf5b74b315c3c",
            "filename": "deps/v8/src/compiler/graph-assembler.h",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "edabae0b8a324dd40ab183e45bc71cab1241a4a1",
            "filename": "deps/v8/src/compiler/graph-trimmer.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-trimmer.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-trimmer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-trimmer.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "47ded6a30caa7e95d4c0ee875b2867071e594369",
            "filename": "deps/v8/src/compiler/ia32/code-generator-ia32.cc",
            "status": "modified",
            "additions": 294,
            "deletions": 467,
            "changes": 761,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Fcode-generator-ia32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Fcode-generator-ia32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Fcode-generator-ia32.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a17d9f06ceaeb9615215dcd88732e5106363a0f1",
            "filename": "deps/v8/src/compiler/ia32/instruction-codes-ia32.h",
            "status": "modified",
            "additions": 42,
            "deletions": 1,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-codes-ia32.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-codes-ia32.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-codes-ia32.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "db43c1ed1c3cf137322761dcc78ba7716cd1961b",
            "filename": "deps/v8/src/compiler/ia32/instruction-scheduler-ia32.cc",
            "status": "modified",
            "additions": 41,
            "deletions": 12,
            "changes": 53,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-scheduler-ia32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-scheduler-ia32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-scheduler-ia32.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "d8bf250ec6c4f26bfec65d09d69e83f318948318",
            "filename": "deps/v8/src/compiler/ia32/instruction-selector-ia32.cc",
            "status": "modified",
            "additions": 129,
            "deletions": 187,
            "changes": 316,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-selector-ia32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-selector-ia32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-selector-ia32.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "df3078d7394bcd7b3dff8cff8b29ac065ff9f629",
            "filename": "deps/v8/src/compiler/instruction-codes.h",
            "status": "modified",
            "additions": 0,
            "deletions": 14,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-codes.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-codes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-codes.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "f7afaab69763aa83506eea268433f4890dcad47d",
            "filename": "deps/v8/src/compiler/instruction-scheduler.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 30,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-scheduler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-scheduler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-scheduler.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "7c7a2708c5192653143eaf0706760e8ae95e8e83",
            "filename": "deps/v8/src/compiler/instruction-selector-impl.h",
            "status": "modified",
            "additions": 27,
            "deletions": 2,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector-impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector-impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector-impl.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c94b42b4583f8d17ae8ea638393ee79dc4999586",
            "filename": "deps/v8/src/compiler/instruction-selector.cc",
            "status": "modified",
            "additions": 85,
            "deletions": 263,
            "changes": 348,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "75c41c165f109613102729f23046df06dcbe8c86",
            "filename": "deps/v8/src/compiler/instruction-selector.h",
            "status": "modified",
            "additions": 18,
            "deletions": 13,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "f335177b9581fff0d403ee5c274f55e923d49b1c",
            "filename": "deps/v8/src/compiler/instruction.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "7772f18ad9cbc595da5119ef50fa5a991c4dfc19",
            "filename": "deps/v8/src/compiler/instruction.h",
            "status": "modified",
            "additions": 10,
            "deletions": 4,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "940f0904b370656012a5a4c78cc8c2948229395e",
            "filename": "deps/v8/src/compiler/int64-lowering.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fint64-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fint64-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fint64-lowering.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "7ff2bf6d5ec606da2f5ec7e6983a7fb455cd1ab6",
            "filename": "deps/v8/src/compiler/js-builtin-reducer.cc",
            "status": "modified",
            "additions": 80,
            "deletions": 662,
            "changes": 742,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-builtin-reducer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-builtin-reducer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-builtin-reducer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "b3c44c7a0fecc9688f604506fff2e2611c5a0d47",
            "filename": "deps/v8/src/compiler/js-builtin-reducer.h",
            "status": "modified",
            "additions": 3,
            "deletions": 8,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-builtin-reducer.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-builtin-reducer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-builtin-reducer.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "1f8e7a2cefe49c5e83d26132e2067adbdc6260ce",
            "filename": "deps/v8/src/compiler/js-call-reducer.cc",
            "status": "modified",
            "additions": 2187,
            "deletions": 362,
            "changes": 2549,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "b2656b6be8e7417285c004b39aad4c2c784b4791",
            "filename": "deps/v8/src/compiler/js-call-reducer.h",
            "status": "modified",
            "additions": 26,
            "deletions": 3,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "d3b9ee4e70a1205ffaa743578756107fcfbdce82",
            "filename": "deps/v8/src/compiler/js-create-lowering.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 7,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-create-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-create-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-create-lowering.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c09dcbc1b3d54d592794fccb417d5034d1d253bc",
            "filename": "deps/v8/src/compiler/js-generic-lowering.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 20,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-generic-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-generic-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-generic-lowering.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "cb3c62011784f1e4c782c5bb6959d6e17e072c56",
            "filename": "deps/v8/src/compiler/js-graph.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "f5b4bdc181ca143677a4d4aaadcb9a9a726a4fc0",
            "filename": "deps/v8/src/compiler/js-graph.h",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c9909dcb75fe304ff243adf168a4c0dfa962bab5",
            "filename": "deps/v8/src/compiler/js-inlining-heuristic.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "f4f24f41b43ed9c0aa2993c1be5cc2047ae5d0b6",
            "filename": "deps/v8/src/compiler/js-inlining-heuristic.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "dc1ec521f229f43e986f2c19b3c6ec30ca34e87e",
            "filename": "deps/v8/src/compiler/js-intrinsic-lowering.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-intrinsic-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-intrinsic-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-intrinsic-lowering.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "b2f8c567e2d3f16b0d44f3be2e8081dbda65b13e",
            "filename": "deps/v8/src/compiler/js-native-context-specialization.cc",
            "status": "modified",
            "additions": 54,
            "deletions": 49,
            "changes": 103,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-native-context-specialization.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-native-context-specialization.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-native-context-specialization.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "0ddf859cff0c5adf5eec063197af4f574febd30c",
            "filename": "deps/v8/src/compiler/js-operator.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 28,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "3875234d5aa934dcb02baf70664e76cffaa1a727",
            "filename": "deps/v8/src/compiler/js-operator.h",
            "status": "modified",
            "additions": 16,
            "deletions": 32,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "0ec63600a2df16de0dc957234d7bcdc63433a5d0",
            "filename": "deps/v8/src/compiler/js-type-hint-lowering.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-type-hint-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-type-hint-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-type-hint-lowering.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c265caf9f0812986d5ad9dc8ba3e80dbddaf5047",
            "filename": "deps/v8/src/compiler/js-typed-lowering.cc",
            "status": "modified",
            "additions": 66,
            "deletions": 55,
            "changes": 121,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "d72303f495599ede8716e5761f8ece89593a042e",
            "filename": "deps/v8/src/compiler/js-typed-lowering.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "5df50e64f5b4f23d5e557b0e0e1f646e732270ff",
            "filename": "deps/v8/src/compiler/linkage.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 16,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "ade1d6902fb4459ccf2fbf4ddc46b63c0b841728",
            "filename": "deps/v8/src/compiler/linkage.h",
            "status": "modified",
            "additions": 16,
            "deletions": 11,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "7888f5a21e3442e097dba37a2e91a8bba54fb975",
            "filename": "deps/v8/src/compiler/load-elimination.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fload-elimination.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fload-elimination.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fload-elimination.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "d6b88b13f5a73ba76c07f851a2dd4d861f2c068f",
            "filename": "deps/v8/src/compiler/loop-analysis.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-analysis.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-analysis.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-analysis.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "ae5b0dfbaca42b8017c72288eef531abbd50809c",
            "filename": "deps/v8/src/compiler/loop-peeling.cc",
            "status": "modified",
            "additions": 46,
            "deletions": 49,
            "changes": 95,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-peeling.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-peeling.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-peeling.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "cd08900dcd7fa077894b1f3e7d8f1b18a2c16b84",
            "filename": "deps/v8/src/compiler/loop-peeling.h",
            "status": "modified",
            "additions": 23,
            "deletions": 8,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-peeling.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-peeling.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-peeling.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "1e93de51248f71c2215a83de8698923e91735df0",
            "filename": "deps/v8/src/compiler/loop-variable-optimizer.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 13,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-variable-optimizer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-variable-optimizer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-variable-optimizer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "9eec61407010e06179e54da932197a1c02d0383f",
            "filename": "deps/v8/src/compiler/loop-variable-optimizer.h",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-variable-optimizer.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-variable-optimizer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-variable-optimizer.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "43f1518461835b3d4b72ce4d7245a237afe6319c",
            "filename": "deps/v8/src/compiler/machine-graph-verifier.cc",
            "status": "modified",
            "additions": 24,
            "deletions": 19,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-graph-verifier.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-graph-verifier.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-graph-verifier.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "97c83b1b827f56e1cde972a59957fc3e9d17bf17",
            "filename": "deps/v8/src/compiler/machine-operator-reducer.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 14,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator-reducer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator-reducer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator-reducer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "66178308be79d5cca51bf4b70c460585ff14456b",
            "filename": "deps/v8/src/compiler/machine-operator.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 59,
            "changes": 84,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "10b4b15701eb3a6af0ee0c5688a1dfade588865b",
            "filename": "deps/v8/src/compiler/machine-operator.h",
            "status": "modified",
            "additions": 5,
            "deletions": 17,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "596204e2145537977053744268e2bac59a8aacdd",
            "filename": "deps/v8/src/compiler/memory-optimizer.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmemory-optimizer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmemory-optimizer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmemory-optimizer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "3b57081c9ec14a9dcf7ccbbd0803909b5e02547d",
            "filename": "deps/v8/src/compiler/mips/code-generator-mips.cc",
            "status": "modified",
            "additions": 58,
            "deletions": 170,
            "changes": 228,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Fcode-generator-mips.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Fcode-generator-mips.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Fcode-generator-mips.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "dd789d0196d2ebf4cf40ea8996c6558887de48f1",
            "filename": "deps/v8/src/compiler/mips/instruction-codes-mips.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-codes-mips.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-codes-mips.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-codes-mips.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "35b8a2396d503a85a51e69a12b37f7044d320930",
            "filename": "deps/v8/src/compiler/mips/instruction-selector-mips.cc",
            "status": "modified",
            "additions": 51,
            "deletions": 118,
            "changes": 169,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-selector-mips.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-selector-mips.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-selector-mips.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "d4463008c8fe83ff3e583cac5bbc5e1789fc1fbb",
            "filename": "deps/v8/src/compiler/mips64/code-generator-mips64.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 200,
            "changes": 245,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Fcode-generator-mips64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Fcode-generator-mips64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Fcode-generator-mips64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "3058812bec7dff84bc6a1b511df402a4329b532d",
            "filename": "deps/v8/src/compiler/mips64/instruction-codes-mips64.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-codes-mips64.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-codes-mips64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-codes-mips64.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "38f077c4e616aff52b93ed4807f2e26cbaee3c8b",
            "filename": "deps/v8/src/compiler/mips64/instruction-selector-mips64.cc",
            "status": "modified",
            "additions": 41,
            "deletions": 149,
            "changes": 190,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-selector-mips64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-selector-mips64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-selector-mips64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "22004337ebfffd46661e9701e9c20d36e863785b",
            "filename": "deps/v8/src/compiler/node-properties.cc",
            "status": "modified",
            "additions": 33,
            "deletions": 5,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "abc6622c837d659cc1822a411b23004782e5dd67",
            "filename": "deps/v8/src/compiler/node-properties.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "ec6c720af2a1f9a92143be23d3625c79c6bd2f0c",
            "filename": "deps/v8/src/compiler/opcodes.h",
            "status": "modified",
            "additions": 26,
            "deletions": 20,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fopcodes.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fopcodes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fopcodes.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "581965563354e10ce9a82a9bb7e113a7b7989a8f",
            "filename": "deps/v8/src/compiler/operation-typer.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "282cb0c7509ce5252860a23f000a538ed0e92432",
            "filename": "deps/v8/src/compiler/operation-typer.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "b4567ab04f614d537a7b6968be6282389877e985",
            "filename": "deps/v8/src/compiler/pipeline.cc",
            "status": "modified",
            "additions": 57,
            "deletions": 39,
            "changes": 96,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "b5b6b5f1422e1ff5b0e0bd7247c8c2aba0d0f2a6",
            "filename": "deps/v8/src/compiler/pipeline.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "7fc537784c0c284d07735993721e5c0d20e606ba",
            "filename": "deps/v8/src/compiler/ppc/code-generator-ppc.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 291,
            "changes": 302,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fppc%2Fcode-generator-ppc.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fppc%2Fcode-generator-ppc.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fppc%2Fcode-generator-ppc.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "fced5565dfab41750588211dfd8ad8dbde30a1cf",
            "filename": "deps/v8/src/compiler/ppc/instruction-selector-ppc.cc",
            "status": "modified",
            "additions": 200,
            "deletions": 107,
            "changes": 307,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fppc%2Finstruction-selector-ppc.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fppc%2Finstruction-selector-ppc.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fppc%2Finstruction-selector-ppc.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "bead0618f69b3c82ee480fd1ddc6620a69f21fc3",
            "filename": "deps/v8/src/compiler/property-access-builder.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fproperty-access-builder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fproperty-access-builder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fproperty-access-builder.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "ed67c06cc76afd34f408f895e5ec7da9c02f7e2e",
            "filename": "deps/v8/src/compiler/raw-machine-assembler.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 4,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fraw-machine-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fraw-machine-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fraw-machine-assembler.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "1cc56b3379446f6d640edb613a8f7fb44fd269a9",
            "filename": "deps/v8/src/compiler/raw-machine-assembler.h",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fraw-machine-assembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fraw-machine-assembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fraw-machine-assembler.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "eedf946fb6999d6c3904c86897e47a15ff55d6ac",
            "filename": "deps/v8/src/compiler/redundancy-elimination.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 7,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fredundancy-elimination.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fredundancy-elimination.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fredundancy-elimination.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "f8a5a9c504efeede166b6998891281a3dae51c8a",
            "filename": "deps/v8/src/compiler/representation-change.cc",
            "status": "modified",
            "additions": 41,
            "deletions": 26,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Frepresentation-change.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Frepresentation-change.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Frepresentation-change.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "b23a3dac5b00d33ee496eaa7633c86db25a254ea",
            "filename": "deps/v8/src/compiler/representation-change.h",
            "status": "modified",
            "additions": 16,
            "deletions": 7,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Frepresentation-change.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Frepresentation-change.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Frepresentation-change.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c0d3146be1e84c7473f2f9657fdf66ce8130d682",
            "filename": "deps/v8/src/compiler/s390/code-generator-s390.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 196,
            "changes": 212,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fs390%2Fcode-generator-s390.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fs390%2Fcode-generator-s390.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fs390%2Fcode-generator-s390.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "457c5a1d827504b46b376716cbb2d416fa233d9b",
            "filename": "deps/v8/src/compiler/s390/instruction-selector-s390.cc",
            "status": "modified",
            "additions": 210,
            "deletions": 111,
            "changes": 321,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fs390%2Finstruction-selector-s390.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fs390%2Finstruction-selector-s390.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fs390%2Finstruction-selector-s390.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "423d757a4fc836cde043e386ee17cdb7e1df11f8",
            "filename": "deps/v8/src/compiler/simd-scalar-lowering.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimd-scalar-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimd-scalar-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimd-scalar-lowering.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "6e6c011fc1e94c946b981b47ab3d0025b3d02201",
            "filename": "deps/v8/src/compiler/simplified-lowering.cc",
            "status": "modified",
            "additions": 62,
            "deletions": 73,
            "changes": 135,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-lowering.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a78d885e6e1f1b1bf9847eeaa9f316cb4ab52c98",
            "filename": "deps/v8/src/compiler/simplified-lowering.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-lowering.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-lowering.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-lowering.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "9978bae122212346f009a6cfdc056aa0d38b18c4",
            "filename": "deps/v8/src/compiler/simplified-operator.cc",
            "status": "modified",
            "additions": 244,
            "deletions": 71,
            "changes": 315,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-operator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-operator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-operator.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "10961cf452e5a1d76605bb130ac7c62bbae0d59c",
            "filename": "deps/v8/src/compiler/simplified-operator.h",
            "status": "modified",
            "additions": 146,
            "deletions": 32,
            "changes": 178,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-operator.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-operator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fsimplified-operator.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "26c47e0cb599e3c712966075936d0cefe606070c",
            "filename": "deps/v8/src/compiler/state-values-utils.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fstate-values-utils.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fstate-values-utils.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fstate-values-utils.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "672acb203d96d8b3cd2f66df4a1b8c0f941de4fb",
            "filename": "deps/v8/src/compiler/store-store-elimination.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fstore-store-elimination.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fstore-store-elimination.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fstore-store-elimination.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "428688abdea2215937d97e2ef6fc13075dd1f9da",
            "filename": "deps/v8/src/compiler/type-cache.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Ftype-cache.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Ftype-cache.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Ftype-cache.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "12c9a194b88d01b999186f3923dfce854c3ba0a8",
            "filename": "deps/v8/src/compiler/typer.cc",
            "status": "modified",
            "additions": 71,
            "deletions": 69,
            "changes": 140,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Ftyper.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Ftyper.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Ftyper.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a3e90d579ab7e91d34306e1ac09d091d7f309f12",
            "filename": "deps/v8/src/compiler/types.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Ftypes.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Ftypes.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Ftypes.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c4c371dab36780bdb2cef1f46c8f94407b41b22c",
            "filename": "deps/v8/src/compiler/types.h",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Ftypes.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Ftypes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Ftypes.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a66a73f5d3c5a3157212aaf802a2da9ef0b07886",
            "filename": "deps/v8/src/compiler/verifier.cc",
            "status": "modified",
            "additions": 51,
            "deletions": 8,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fverifier.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fverifier.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fverifier.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "9bbf5f3a3f75819b080a39dd4bd707ddbdb980b9",
            "filename": "deps/v8/src/compiler/wasm-compiler.cc",
            "status": "modified",
            "additions": 414,
            "deletions": 279,
            "changes": 693,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fwasm-compiler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fwasm-compiler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fwasm-compiler.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "22a2e1071e7bae284e5d28036a98defe968b606d",
            "filename": "deps/v8/src/compiler/wasm-compiler.h",
            "status": "modified",
            "additions": 90,
            "deletions": 31,
            "changes": 121,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fwasm-compiler.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fwasm-compiler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fwasm-compiler.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "e7bb3c164a4e44b89f52f22e04ce5cd97b231821",
            "filename": "deps/v8/src/compiler/wasm-linkage.cc",
            "status": "modified",
            "additions": 65,
            "deletions": 58,
            "changes": 123,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fwasm-linkage.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fwasm-linkage.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fwasm-linkage.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "bc92f9707c20a7241454be7ea6c22fa7c80a7611",
            "filename": "deps/v8/src/compiler/x64/code-generator-x64.cc",
            "status": "modified",
            "additions": 173,
            "deletions": 306,
            "changes": 479,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Fcode-generator-x64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Fcode-generator-x64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Fcode-generator-x64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "6d9bc6f820f63218f892350b4512d004acbc8f25",
            "filename": "deps/v8/src/compiler/x64/instruction-codes-x64.h",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Finstruction-codes-x64.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Finstruction-codes-x64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Finstruction-codes-x64.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c16fee586161af5146bc7e2511c9c51f88befa0c",
            "filename": "deps/v8/src/compiler/x64/instruction-scheduler-x64.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 14,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Finstruction-scheduler-x64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Finstruction-scheduler-x64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Finstruction-scheduler-x64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a0f14c687c825b171cd3dfee1ad738abe8a95f67",
            "filename": "deps/v8/src/compiler/x64/instruction-selector-x64.cc",
            "status": "modified",
            "additions": 78,
            "deletions": 139,
            "changes": 217,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Finstruction-selector-x64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Finstruction-selector-x64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fx64%2Finstruction-selector-x64.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "22e3606e98ada2e7c6ec6bf7c4de8c682296f6d9",
            "filename": "deps/v8/src/contexts-inl.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcontexts-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcontexts-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcontexts-inl.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "04c4b4899d57b9b94a0d44e01a07278517181097",
            "filename": "deps/v8/src/contexts.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcontexts.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcontexts.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcontexts.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c1bca7557ee723962ba6ef33b30a6bad8e8bec53",
            "filename": "deps/v8/src/contexts.h",
            "status": "modified",
            "additions": 9,
            "deletions": 10,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcontexts.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcontexts.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcontexts.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c5ea1b8366e99aa2387ef3c691f8adb3bded84ee",
            "filename": "deps/v8/src/conversions.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fconversions.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fconversions.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fconversions.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "abde3a1af5295dcc06f39a0598c99c2602cf3922",
            "filename": "deps/v8/src/counters-inl.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcounters-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcounters-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcounters-inl.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "e41fa276a8ca589ca07cdcbb0b86f3f21f05af9b",
            "filename": "deps/v8/src/counters.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 70,
            "changes": 99,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcounters.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcounters.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcounters.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "b3c6f8c8ffbab5f4013dba3d879da45f7241f055",
            "filename": "deps/v8/src/counters.h",
            "status": "modified",
            "additions": 77,
            "deletions": 83,
            "changes": 160,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcounters.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fcounters.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcounters.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "3aae30799fc9a72f0e9905a11cf322936fe6af1c",
            "filename": "deps/v8/src/d8-posix.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fd8-posix.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fd8-posix.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fd8-posix.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "32f129821a85ee07e4ae38bac1bcba820fbb1211",
            "filename": "deps/v8/src/d8.cc",
            "status": "modified",
            "additions": 243,
            "deletions": 198,
            "changes": 441,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fd8.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fd8.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fd8.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "8fc6eab046718b24016b3382d8f68568f097d6bc",
            "filename": "deps/v8/src/d8.h",
            "status": "modified",
            "additions": 37,
            "deletions": 14,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fd8.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fd8.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fd8.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "3eae96aa1164b766420c6e593c91239ee568b0aa",
            "filename": "deps/v8/src/debug/debug-coverage.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 4,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-coverage.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-coverage.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-coverage.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "33bc81e5f74120fdadfa256e3dca3026629ceab6",
            "filename": "deps/v8/src/debug/debug-evaluate.cc",
            "status": "modified",
            "additions": 26,
            "deletions": 12,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-evaluate.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-evaluate.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-evaluate.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "6b4f8c23f6a95eaa46cdc38f75b9f44bd8d26e39",
            "filename": "deps/v8/src/debug/debug-frames.h",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-frames.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-frames.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-frames.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "6288c11b94f296559fafa7c3539cac075aba1c41",
            "filename": "deps/v8/src/debug/debug-type-profile.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-type-profile.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-type-profile.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug-type-profile.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "c087a0868c5b28a51bd5ba03f5846711fe38fb88",
            "filename": "deps/v8/src/debug/debug.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a2b22d58d49521406493d0515eeda1a7d098b406",
            "filename": "deps/v8/src/debug/liveedit.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fliveedit.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fliveedit.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fliveedit.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "15d5e64258106b2f3512e0ae2a31a439684ff7fb",
            "filename": "deps/v8/src/debug/mirrors.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fmirrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdebug%2Fmirrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fmirrors.js?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "3fabf555be1dbb3be81aed3b3cf1fd0b84257152",
            "filename": "deps/v8/src/deoptimize-reason.h",
            "status": "modified",
            "additions": 6,
            "deletions": 34,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdeoptimize-reason.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdeoptimize-reason.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdeoptimize-reason.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "362bd12cb6611c4cd496bfbe6351db73aea2fdaa",
            "filename": "deps/v8/src/deoptimizer.cc",
            "status": "modified",
            "additions": 619,
            "deletions": 575,
            "changes": 1194,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdeoptimizer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdeoptimizer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdeoptimizer.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "e72878654d5afb5378a9dd3a6714a0802fdd5ba2",
            "filename": "deps/v8/src/deoptimizer.h",
            "status": "modified",
            "additions": 87,
            "deletions": 23,
            "changes": 110,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdeoptimizer.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdeoptimizer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdeoptimizer.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "a26517b432fe1154d985e985136898921ef72490",
            "filename": "deps/v8/src/disassembler.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 12,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdisassembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdisassembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdisassembler.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "51ed0bf196ceccae3f41fc3c04cbe4dc533a0b2a",
            "filename": "deps/v8/src/disassembler.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdisassembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fdisassembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdisassembler.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "f0e413cf33edbab0833069ce8cef86b3c93de901",
            "filename": "deps/v8/src/eh-frame.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Feh-frame.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Feh-frame.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Feh-frame.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "b03f9340f30f69d2bdc9385f9de19d4a9e694456",
            "filename": "deps/v8/src/elements-kind.h",
            "status": "modified",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Felements-kind.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Felements-kind.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Felements-kind.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "499af83078bbdfa635afdf41d4fff625615e8c01",
            "filename": "deps/v8/src/elements.cc",
            "status": "modified",
            "additions": 90,
            "deletions": 32,
            "changes": 122,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Felements.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Felements.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Felements.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "de5aa0d878b1a8abad1595de27e6bd4aadd881f3",
            "filename": "deps/v8/src/elements.h",
            "status": "modified",
            "additions": 11,
            "deletions": 8,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Felements.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Felements.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Felements.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "edd329f5da03f9fe9d213b2b294f49876c04d5ad",
            "filename": "deps/v8/src/execution.cc",
            "status": "modified",
            "additions": 41,
            "deletions": 24,
            "changes": 65,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fexecution.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fexecution.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fexecution.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "7dd920a446ff62311306c21bca6c147b8ab4e157",
            "filename": "deps/v8/src/execution.h",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fexecution.h",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fexecution.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fexecution.h?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "aa9d5c4364ce2ad56ad6dbe9bcf4965138a7132f",
            "filename": "deps/v8/src/extensions/statistics-extension.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fextensions%2Fstatistics-extension.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fextensions%2Fstatistics-extension.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fextensions%2Fstatistics-extension.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        },
        {
            "sha": "52157b5034f54218ef924650cf572a6742732950",
            "filename": "deps/v8/src/external-reference-table.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fexternal-reference-table.cc",
            "raw_url": "https://github.com/nodejs/node/raw/88786fecff336342a56e6f2e7ff3b286be716e47/deps%2Fv8%2Fsrc%2Fexternal-reference-table.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fexternal-reference-table.cc?ref=88786fecff336342a56e6f2e7ff3b286be716e47"
        }
    ],
    "stats": {
        "total": 114481,
        "additions": 71104,
        "deletions": 43377
    }
}