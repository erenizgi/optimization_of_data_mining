{
    "author": "tniessen",
    "message": "crypto: add support for OCB mode for AEAD\n\nPR-URL: https://github.com/nodejs/node/pull/21447\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1",
    "files": [
        {
            "sha": "a0fbb30bcd271318032692b5f18ec0c4205104d7",
            "filename": "doc/api/crypto.md",
            "status": "modified",
            "additions": 27,
            "deletions": 14,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1/doc%2Fapi%2Fcrypto.md",
            "raw_url": "https://github.com/nodejs/node/raw/b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1/doc%2Fapi%2Fcrypto.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fcrypto.md?ref=b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1",
            "patch": "@@ -249,11 +249,11 @@ added: v1.0.0\n   - `plaintextLength` {number}\n * Returns: {Cipher} for method chaining.\n \n-When using an authenticated encryption mode (only `GCM` and `CCM` are currently\n-supported), the `cipher.setAAD()` method sets the value used for the\n+When using an authenticated encryption mode (`GCM`, `CCM` and `OCB` are\n+currently supported), the `cipher.setAAD()` method sets the value used for the\n _additional authenticated data_ (AAD) input parameter.\n \n-The `options` argument is optional for `GCM`. When using `CCM`, the\n+The `options` argument is optional for `GCM` and `OCB`. When using `CCM`, the\n `plaintextLength` option must be specified and its value must match the length\n of the plaintext in bytes. See [CCM mode][].\n \n@@ -263,8 +263,8 @@ The `cipher.setAAD()` method must be called before [`cipher.update()`][].\n <!-- YAML\n added: v1.0.0\n -->\n-* Returns: {Buffer} When using an authenticated encryption mode (only `GCM` and\n-  `CCM` are currently supported), the `cipher.getAuthTag()` method returns a\n+* Returns: {Buffer} When using an authenticated encryption mode (`GCM`, `CCM`\n+  and `OCB` are currently supported), the `cipher.getAuthTag()` method returns a\n   [`Buffer`][] containing the _authentication tag_ that has been computed from\n   the given data.\n \n@@ -412,8 +412,8 @@ changes:\n   - `plaintextLength` {number}\n * Returns: {Decipher} for method chaining.\n \n-When using an authenticated encryption mode (only `GCM` and `CCM` are currently\n-supported), the `decipher.setAAD()` method sets the value used for the\n+When using an authenticated encryption mode (`GCM`, `CCM` and `OCB` are\n+currently supported), the `decipher.setAAD()` method sets the value used for the\n _additional authenticated data_ (AAD) input parameter.\n \n The `options` argument is optional for `GCM`. When using `CCM`, the\n@@ -436,8 +436,8 @@ changes:\n * `buffer` {Buffer | TypedArray | DataView}\n * Returns: {Decipher} for method chaining.\n \n-When using an authenticated encryption mode (only `GCM` and `CCM` are currently\n-supported), the `decipher.setAuthTag()` method is used to pass in the\n+When using an authenticated encryption mode (`GCM`, `CCM` and `OCB` are\n+currently supported), the `decipher.setAuthTag()` method is used to pass in the\n received _authentication tag_. If no tag is provided, or if the cipher text\n has been tampered with, [`decipher.final()`][] will throw, indicating that the\n cipher text should be discarded due to failed authentication. If the tag length\n@@ -1321,6 +1321,9 @@ This property is deprecated. Please use `crypto.setFips()` and\n added: v0.1.94\n deprecated: v10.0.0\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/21447\n+    description: Ciphers in OCB mode are now supported.\n   - version: v10.2.0\n     pr-url: https://github.com/nodejs/node/pull/20235\n     description: The `authTagLength` option can now be used to produce shorter\n@@ -1338,7 +1341,7 @@ Creates and returns a `Cipher` object that uses the given `algorithm` and\n `password`.\n \n The `options` argument controls stream behavior and is optional except when a\n-cipher in CCM mode is used (e.g. `'aes-128-ccm'`). In that case, the\n+cipher in CCM or OCB mode is used (e.g. `'aes-128-ccm'`). In that case, the\n `authTagLength` option is required and specifies the length of the\n authentication tag in bytes, see [CCM mode][]. In GCM mode, the `authTagLength`\n option is not required but can be used to set the length of the authentication\n@@ -1373,6 +1376,9 @@ Adversaries][] for details.\n <!-- YAML\n added: v0.1.94\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/21447\n+    description: Ciphers in OCB mode are now supported.\n   - version: v10.2.0\n     pr-url: https://github.com/nodejs/node/pull/20235\n     description: The `authTagLength` option can now be used to produce shorter\n@@ -1392,7 +1398,7 @@ Creates and returns a `Cipher` object, with the given `algorithm`, `key` and\n initialization vector (`iv`).\n \n The `options` argument controls stream behavior and is optional except when a\n-cipher in CCM mode is used (e.g. `'aes-128-ccm'`). In that case, the\n+cipher in CCM or OCB mode is used (e.g. `'aes-128-ccm'`). In that case, the\n `authTagLength` option is required and specifies the length of the\n authentication tag in bytes, see [CCM mode][]. In GCM mode, the `authTagLength`\n option is not required but can be used to set the length of the authentication\n@@ -1419,6 +1425,10 @@ of time what a given IV will be.\n <!-- YAML\n added: v0.1.94\n deprecated: v10.0.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/21447\n+    description: Ciphers in OCB mode are now supported.\n -->\n \n > Stability: 0 - Deprecated: Use [`crypto.createDecipheriv()`][] instead.\n@@ -1432,7 +1442,7 @@ Creates and returns a `Decipher` object that uses the given `algorithm` and\n `password` (key).\n \n The `options` argument controls stream behavior and is optional except when a\n-cipher in CCM mode is used (e.g. `'aes-128-ccm'`). In that case, the\n+cipher in CCM or OCB mode is used (e.g. `'aes-128-ccm'`). In that case, the\n `authTagLength` option is required and specifies the length of the\n authentication tag in bytes, see [CCM mode][].\n \n@@ -1452,6 +1462,9 @@ to create the `Decipher` object.\n <!-- YAML\n added: v0.1.94\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/21447\n+    description: Ciphers in OCB mode are now supported.\n   - version: v10.2.0\n     pr-url: https://github.com/nodejs/node/pull/20039\n     description: The `authTagLength` option can now be used to restrict accepted\n@@ -1471,7 +1484,7 @@ Creates and returns a `Decipher` object that uses the given `algorithm`, `key`\n and initialization vector (`iv`).\n \n The `options` argument controls stream behavior and is optional except when a\n-cipher in CCM mode is used (e.g. `'aes-128-ccm'`). In that case, the\n+cipher in CCM or OCB mode is used (e.g. `'aes-128-ccm'`). In that case, the\n `authTagLength` option is required and specifies the length of the\n authentication tag in bytes, see [CCM mode][]. In GCM mode, the `authTagLength`\n option is not required but can be used to restrict accepted authentication tags\n@@ -2321,7 +2334,7 @@ See the reference for other recommendations and details.\n \n ### CCM mode\n \n-CCM is one of the two supported [AEAD algorithms][]. Applications which use this\n+CCM is one of the supported [AEAD algorithms][]. Applications which use this\n mode must adhere to certain restrictions when using the cipher API:\n \n - The authentication tag length must be specified during cipher creation by"
        },
        {
            "sha": "00c1785f4c7e005500f9836608a3f35279c2d677",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 19,
            "changes": 50,
            "blob_url": "https://github.com/nodejs/node/blob/b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1",
            "patch": "@@ -2683,6 +2683,11 @@ void CipherBase::Init(const FunctionCallbackInfo<Value>& args) {\n   cipher->Init(*cipher_type, key_buf, key_buf_len, auth_tag_len);\n }\n \n+static bool IsSupportedAuthenticatedMode(int mode) {\n+  return mode == EVP_CIPH_CCM_MODE ||\n+         mode == EVP_CIPH_GCM_MODE ||\n+         mode == EVP_CIPH_OCB_MODE;\n+}\n \n void CipherBase::InitIv(const char* cipher_type,\n                         const char* key,\n@@ -2700,8 +2705,7 @@ void CipherBase::InitIv(const char* cipher_type,\n \n   const int expected_iv_len = EVP_CIPHER_iv_length(cipher);\n   const int mode = EVP_CIPHER_mode(cipher);\n-  const bool is_gcm_mode = (EVP_CIPH_GCM_MODE == mode);\n-  const bool is_ccm_mode = (EVP_CIPH_CCM_MODE == mode);\n+  const bool is_authenticated_mode = IsSupportedAuthenticatedMode(mode);\n   const bool has_iv = iv_len >= 0;\n \n   // Throw if no IV was passed and the cipher requires an IV\n@@ -2712,7 +2716,7 @@ void CipherBase::InitIv(const char* cipher_type,\n   }\n \n   // Throw if an IV was passed which does not match the cipher's fixed IV length\n-  if (!is_gcm_mode && !is_ccm_mode && has_iv && iv_len != expected_iv_len) {\n+  if (!is_authenticated_mode && has_iv && iv_len != expected_iv_len) {\n     return env()->ThrowError(\"Invalid IV length\");\n   }\n \n@@ -2728,7 +2732,7 @@ void CipherBase::InitIv(const char* cipher_type,\n                             \"Failed to initialize cipher\");\n   }\n \n-  if (IsAuthenticatedMode()) {\n+  if (is_authenticated_mode) {\n     CHECK(has_iv);\n     if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))\n       return;\n@@ -2803,7 +2807,7 @@ bool CipherBase::InitAuthenticated(const char* cipher_type, int iv_len,\n   }\n \n   const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n-  if (mode == EVP_CIPH_CCM_MODE) {\n+  if (mode == EVP_CIPH_CCM_MODE || mode == EVP_CIPH_OCB_MODE) {\n     if (auth_tag_len == kNoAuthTagLength) {\n       char msg[128];\n       snprintf(msg, sizeof(msg), \"authTagLength required for %s\", cipher_type);\n@@ -2813,25 +2817,29 @@ bool CipherBase::InitAuthenticated(const char* cipher_type, int iv_len,\n \n #ifdef NODE_FIPS_MODE\n     // TODO(tniessen) Support CCM decryption in FIPS mode\n-    if (kind_ == kDecipher && FIPS_mode()) {\n+    if (mode == EVP_CIPH_CCM_MODE && kind_ == kDecipher && FIPS_mode()) {\n       env()->ThrowError(\"CCM decryption not supported in FIPS mode\");\n       return false;\n     }\n #endif\n \n-    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_CCM_SET_TAG, auth_tag_len,\n+    // Tell OpenSSL about the desired length.\n+    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_SET_TAG, auth_tag_len,\n                              nullptr)) {\n       env()->ThrowError(\"Invalid authentication tag length\");\n       return false;\n     }\n \n+    // Remember the given authentication tag length for later.\n     auth_tag_len_ = auth_tag_len;\n \n-    // Restrict the message length to min(INT_MAX, 2^(8*(15-iv_len))-1) bytes.\n-    CHECK(iv_len >= 7 && iv_len <= 13);\n-    max_message_size_ = INT_MAX;\n-    if (iv_len == 12) max_message_size_ = 16777215;\n-    if (iv_len == 13) max_message_size_ = 65535;\n+    if (mode == EVP_CIPH_CCM_MODE) {\n+      // Restrict the message length to min(INT_MAX, 2^(8*(15-iv_len))-1) bytes.\n+      CHECK(iv_len >= 7 && iv_len <= 13);\n+      max_message_size_ = INT_MAX;\n+      if (iv_len == 12) max_message_size_ = 16777215;\n+      if (iv_len == 13) max_message_size_ = 65535;\n+    }\n   } else {\n     CHECK_EQ(mode, EVP_CIPH_GCM_MODE);\n \n@@ -2870,7 +2878,7 @@ bool CipherBase::IsAuthenticatedMode() const {\n   // Check if this cipher operates in an AEAD mode that we support.\n   CHECK(ctx_);\n   const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n-  return mode == EVP_CIPH_GCM_MODE || mode == EVP_CIPH_CCM_MODE;\n+  return IsSupportedAuthenticatedMode(mode);\n }\n \n \n@@ -2903,16 +2911,18 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n     return args.GetReturnValue().Set(false);\n   }\n \n-  // Restrict GCM tag lengths according to NIST 800-38d, page 9.\n   unsigned int tag_len = Buffer::Length(args[0]);\n   const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());\n   bool is_valid;\n   if (mode == EVP_CIPH_GCM_MODE) {\n+    // Restrict GCM tag lengths according to NIST 800-38d, page 9.\n     is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||\n                 cipher->auth_tag_len_ == tag_len) &&\n                IsValidGCMTagLength(tag_len);\n   } else {\n-    CHECK_EQ(mode, EVP_CIPH_CCM_MODE);\n+    // At this point, the tag length is already known and must match the\n+    // length of the given authentication tag.\n+    CHECK(mode == EVP_CIPH_CCM_MODE || mode == EVP_CIPH_OCB_MODE);\n     CHECK_NE(cipher->auth_tag_len_, kNoAuthTagLength);\n     is_valid = cipher->auth_tag_len_ == tag_len;\n   }\n@@ -3008,7 +3018,7 @@ CipherBase::UpdateResult CipherBase::Update(const char* data,\n   if (kind_ == kDecipher && IsAuthenticatedMode() && auth_tag_len_ > 0 &&\n       auth_tag_len_ != kNoAuthTagLength && !auth_tag_set_) {\n     CHECK(EVP_CIPHER_CTX_ctrl(ctx_.get(),\n-                              EVP_CTRL_GCM_SET_TAG,\n+                              EVP_CTRL_AEAD_SET_TAG,\n                               auth_tag_len_,\n                               reinterpret_cast<unsigned char*>(auth_tag_)));\n     auth_tag_set_ = true;\n@@ -3121,10 +3131,12 @@ bool CipherBase::Final(unsigned char** out, int* out_len) {\n \n     if (ok && kind_ == kCipher && IsAuthenticatedMode()) {\n       // In GCM mode, the authentication tag length can be specified in advance,\n-      // but defaults to 16 bytes when encrypting. In CCM mode, it must always\n-      // be given by the user.\n-      if (mode == EVP_CIPH_GCM_MODE && auth_tag_len_ == kNoAuthTagLength)\n+      // but defaults to 16 bytes when encrypting. In CCM and OCB mode, it must\n+      // always be given by the user.\n+      if (auth_tag_len_ == kNoAuthTagLength) {\n+        CHECK(mode == EVP_CIPH_GCM_MODE);\n         auth_tag_len_ = sizeof(auth_tag_);\n+      }\n       CHECK_EQ(1, EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,\n                       auth_tag_len_,\n                       reinterpret_cast<unsigned char*>(auth_tag_)));"
        },
        {
            "sha": "f7e108dcdda6d4d3fc77d0a4cc8e9cf10782cbf3",
            "filename": "test/parallel/test-crypto-authenticated.js",
            "status": "modified",
            "additions": 232,
            "deletions": 20,
            "changes": 252,
            "blob_url": "https://github.com/nodejs/node/blob/b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1/test%2Fparallel%2Ftest-crypto-authenticated.js",
            "raw_url": "https://github.com/nodejs/node/raw/b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1/test%2Fparallel%2Ftest-crypto-authenticated.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-authenticated.js?ref=b3f459e6cf0076915cfd0e9ea130e3ceaa4448d1",
            "patch": "@@ -499,6 +499,207 @@ const TEST_CASES = [\n     tag: '65a6002b2cdfe9f00027f839332ca6fc',\n     tampered: false\n   },\n+\n+  // OCB test cases from RFC7253\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221100',\n+    plain: '',\n+    ct: '',\n+    tag: '785407bfffc8ad9edcc5520ac9111ee6'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221101',\n+    plain: '0001020304050607',\n+    plainIsHex: true,\n+    aad: '0001020304050607',\n+    ct: '6820b3657b6f615a',\n+    tag: '5725bda0d3b4eb3a257c9af1f8f03009'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221102',\n+    plain: '',\n+    aad: '0001020304050607',\n+    ct: '',\n+    tag: '81017f8203f081277152fade694a0a00'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221103',\n+    plain: '0001020304050607',\n+    plainIsHex: true,\n+    ct: '45dd69f8f5aae724',\n+    tag: '14054cd1f35d82760b2cd00d2f99bfa9'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221104',\n+    plain: '000102030405060708090a0b0c0d0e0f',\n+    plainIsHex: true,\n+    aad: '000102030405060708090a0b0c0d0e0f',\n+    ct: '571d535b60b277188be5147170a9a22c',\n+    tag: '3ad7a4ff3835b8c5701c1ccec8fc3358'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221105',\n+    plain: '',\n+    aad: '000102030405060708090a0b0c0d0e0f',\n+    ct: '',\n+    tag: '8cf761b6902ef764462ad86498ca6b97'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221106',\n+    plain: '000102030405060708090a0b0c0d0e0f',\n+    plainIsHex: true,\n+    ct: '5ce88ec2e0692706a915c00aeb8b2396',\n+    tag: 'f40e1c743f52436bdf06d8fa1eca343d'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221107',\n+    plain: '000102030405060708090a0b0c0d0e0f1011121314151617',\n+    plainIsHex: true,\n+    aad: '000102030405060708090a0b0c0d0e0f1011121314151617',\n+    ct: '1ca2207308c87c010756104d8840ce1952f09673a448a122',\n+    tag: 'c92c62241051f57356d7f3c90bb0e07f'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221108',\n+    plain: '',\n+    aad: '000102030405060708090a0b0c0d0e0f1011121314151617',\n+    ct: '',\n+    tag: '6dc225a071fc1b9f7c69f93b0f1e10de'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa99887766554433221109',\n+    plain: '000102030405060708090a0b0c0d0e0f1011121314151617',\n+    plainIsHex: true,\n+    ct: '221bd0de7fa6fe993eccd769460a0af2d6cded0c395b1c3c',\n+    tag: 'e725f32494b9f914d85c0b1eb38357ff'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa9988776655443322110a',\n+    plain: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f',\n+    plainIsHex: true,\n+    aad: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f',\n+    ct: 'bd6f6c496201c69296c11efd138a467abd3c707924b964deaffc40319af5a485',\n+    tag: '40fbba186c5553c68ad9f592a79a4240'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa9988776655443322110b',\n+    plain: '',\n+    aad: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f',\n+    ct: '',\n+    tag: 'fe80690bee8a485d11f32965bc9d2a32'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa9988776655443322110c',\n+    plain: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f',\n+    plainIsHex: true,\n+    ct: '2942bfc773bda23cabc6acfd9bfd5835bd300f0973792ef46040c53f1432bcdf',\n+    tag: 'b5e1dde3bc18a5f840b52e653444d5df'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa9988776655443322110d',\n+    plain: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f' +\n+           '2021222324252627',\n+    plainIsHex: true,\n+    aad: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20' +\n+         '21222324252627',\n+    ct: 'd5ca91748410c1751ff8a2f618255b68a0a12e093ff454606e59f9c1d0ddc54b65e8' +\n+        '628e568bad7a',\n+    tag: 'ed07ba06a4a69483a7035490c5769e60'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa9988776655443322110e',\n+    plain: '',\n+    plainIsHex: true,\n+    aad: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20' +\n+         '21222324252627',\n+    ct: '',\n+    tag: 'c5cd9d1850c141e358649994ee701b68'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '000102030405060708090a0b0c0d0e0f',\n+    iv: 'bbaa9988776655443322110f',\n+    plain: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f' +\n+           '2021222324252627',\n+    plainIsHex: true,\n+    ct: '4412923493c57d5de0d700f753cce0d1d2d95060122e9f15a5ddbfc5787e50b5cc55' +\n+        'ee507bcb084e',\n+    tag: '479ad363ac366b95a98ca5f3000b1479'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '0f0e0d0c0b0a09080706050403020100',\n+    iv: 'bbaa9988776655443322110d',\n+    plain: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f' +\n+           '2021222324252627',\n+    plainIsHex: true,\n+    aad: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20' +\n+         '21222324252627',\n+    ct: '1792a4e31e0755fb03e31b22116e6c2ddf9efd6e33d536f1a0124b0a55bae884ed93' +\n+        '481529c76b6a',\n+    tag: 'd0c515f4d1cdd4fdac4f02aa'\n+  },\n+\n+  {\n+    algo: 'aes-128-ocb',\n+    key: '0f0e0d0c0b0a09080706050403020100',\n+    iv: 'bbaa9988776655443322110d',\n+    plain: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f' +\n+           '2021222324252627',\n+    plainIsHex: true,\n+    aad: '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20' +\n+         '21222324252627',\n+    ct: '1792a4e31e0755fb03e31b22116e6c2ddf9efd6e33d536f1a0124b0a55bae884ed93' +\n+        '481529c76b6a',\n+    tag: 'd0c515f4d1cdd4fdac4f02ab',\n+    tampered: true\n+  }\n ];\n \n const errMessages = {\n@@ -554,9 +755,10 @@ for (const test of TEST_CASES) {\n   }\n \n   const isCCM = /^aes-(128|192|256)-ccm$/.test(test.algo);\n+  const isOCB = /^aes-(128|192|256)-ocb$/.test(test.algo);\n \n   let options;\n-  if (isCCM)\n+  if (isCCM || isOCB)\n     options = { authTagLength: test.tag.length / 2 };\n \n   const inputEncoding = test.plainIsHex ? 'hex' : 'ascii';\n@@ -881,30 +1083,40 @@ for (const test of TEST_CASES) {\n   }\n }\n \n-// Test that create(De|C)ipher(iv)? throws if the mode is CCM and no\n+// Test that create(De|C)ipher(iv)? throws if the mode is CCM or OCB and no\n // authentication tag has been specified.\n {\n-  assert.throws(() => {\n-    crypto.createCipheriv('aes-256-ccm',\n-                          'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n-                          'qkuZpJWCewa6S');\n-  }, /^Error: authTagLength required for aes-256-ccm$/);\n-\n-  // CCM decryption and create(De|C)ipher are unsupported in FIPS mode.\n-  if (!common.hasFipsCrypto) {\n+  for (const mode of ['ccm', 'ocb']) {\n     assert.throws(() => {\n-      crypto.createDecipheriv('aes-256-ccm',\n-                              'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n-                              'qkuZpJWCewa6S');\n-    }, /^Error: authTagLength required for aes-256-ccm$/);\n+      crypto.createCipheriv(`aes-256-${mode}`,\n+                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                            'qkuZpJWCewa6S');\n+    }, {\n+      message: `authTagLength required for aes-256-${mode}`\n+    });\n \n-    assert.throws(() => {\n-      crypto.createCipher('aes-256-ccm', 'very bad password');\n-    }, /^Error: authTagLength required for aes-256-ccm$/);\n+    // CCM decryption and create(De|C)ipher are unsupported in FIPS mode.\n+    if (!common.hasFipsCrypto) {\n+      assert.throws(() => {\n+        crypto.createDecipheriv(`aes-256-${mode}`,\n+                                'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                                'qkuZpJWCewa6S');\n+      }, {\n+        message: `authTagLength required for aes-256-${mode}`\n+      });\n \n-    assert.throws(() => {\n-      crypto.createDecipher('aes-256-ccm', 'very bad password');\n-    }, /^Error: authTagLength required for aes-256-ccm$/);\n+      assert.throws(() => {\n+        crypto.createCipher(`aes-256-${mode}`, 'very bad password');\n+      }, {\n+        message: `authTagLength required for aes-256-${mode}`\n+      });\n+\n+      assert.throws(() => {\n+        crypto.createDecipher(`aes-256-${mode}`, 'very bad password');\n+      }, {\n+        message: `authTagLength required for aes-256-${mode}`\n+      });\n+    }\n   }\n }\n "
        }
    ],
    "stats": {
        "total": 343,
        "additions": 290,
        "deletions": 53
    }
}