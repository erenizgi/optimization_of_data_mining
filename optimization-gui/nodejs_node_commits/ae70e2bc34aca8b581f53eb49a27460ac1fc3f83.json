{
    "author": "addaleax",
    "message": "src: general C++ cleanup in node_url.cc\n\n- Merge `domain` and `opaque` storage in URL parser:\n\n  This just simplifies the code a bit, having multiple fields\n  in an union with the same type is usually just overhead.\n\n- Add move variant of `URLHost::ToString()`:\n\n  This helps avoid unnecessary string copy operations, especially\n  since we control the lifetime of `URLHost` objects pretty well.\n\n- Use const refs in node_url.cc where appropriate\n\n- Remove or reduce overly generous `.reserve()` calls:\n\n  These would otherwise keep a lot of unused memory lying around.\n\n- Return return values instead of unnecessary pointer arguments\n\n- Use more common/expressive variable names\n\n- Avoid macro use, reduce number of unnecessary JS strings:\n\n  Thereâ€™s no reason for `GET`, `GET_AND_SET` and `UTF8STRING` to be\n  macros. Also, `GET` would previously create a JS string instance\n  for each single call, even though the strings it was called\n  with were compile-time constants.\n\n- Avoid unnecessary JS casts when the type of a value is known\n\n- Avoid (commonly unnecessary) copy for whitespace stripping\n\nPR-URL: https://github.com/nodejs/node/pull/19598\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "ae70e2bc34aca8b581f53eb49a27460ac1fc3f83",
    "files": [
        {
            "sha": "a688b069242160383de33cd6f2317fdda1274d90",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/ae70e2bc34aca8b581f53eb49a27460ac1fc3f83/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/ae70e2bc34aca8b581f53eb49a27460ac1fc3f83/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=ae70e2bc34aca8b581f53eb49a27460ac1fc3f83",
            "patch": "@@ -165,11 +165,13 @@ struct PackageConfig {\n   V(fingerprint_string, \"fingerprint\")                                        \\\n   V(fingerprint256_string, \"fingerprint256\")                                  \\\n   V(flags_string, \"flags\")                                                    \\\n+  V(fragment_string, \"fragment\")                                              \\\n   V(get_data_clone_error_string, \"_getDataCloneError\")                        \\\n   V(get_shared_array_buffer_id_string, \"_getSharedArrayBufferId\")             \\\n   V(gid_string, \"gid\")                                                        \\\n   V(handle_string, \"handle\")                                                  \\\n   V(homedir_string, \"homedir\")                                                \\\n+  V(host_string, \"host\")                                                      \\\n   V(hostmaster_string, \"hostmaster\")                                          \\\n   V(ignore_string, \"ignore\")                                                  \\\n   V(infoaccess_string, \"infoAccess\")                                          \\\n@@ -226,6 +228,7 @@ struct PackageConfig {\n   V(order_string, \"order\")                                                    \\\n   V(owner_string, \"owner\")                                                    \\\n   V(parse_error_string, \"Parse Error\")                                        \\\n+  V(password_string, \"password\")                                              \\\n   V(path_string, \"path\")                                                      \\\n   V(pending_handle_string, \"pendingHandle\")                                   \\\n   V(pbkdf2_error_string, \"PBKDF2 Error\")                                      \\\n@@ -239,6 +242,7 @@ struct PackageConfig {\n   V(produce_cached_data_string, \"produceCachedData\")                          \\\n   V(promise_string, \"promise\")                                                \\\n   V(pubkey_string, \"pubkey\")                                                  \\\n+  V(query_string, \"query\")                                                    \\\n   V(raw_string, \"raw\")                                                        \\\n   V(read_host_object_string, \"_readHostObject\")                               \\\n   V(readable_string, \"readable\")                                              \\\n@@ -247,6 +251,7 @@ struct PackageConfig {\n   V(rename_string, \"rename\")                                                  \\\n   V(replacement_string, \"replacement\")                                        \\\n   V(retry_string, \"retry\")                                                    \\\n+  V(scheme_string, \"scheme\")                                                  \\\n   V(serial_string, \"serial\")                                                  \\\n   V(scopeid_string, \"scopeid\")                                                \\\n   V(serial_number_string, \"serialNumber\")                                     \\"
        },
        {
            "sha": "09199afb141e3f7dea1cab79b23ce87ef9f2078a",
            "filename": "src/node_url.cc",
            "status": "modified",
            "additions": 187,
            "deletions": 151,
            "changes": 338,
            "blob_url": "https://github.com/nodejs/node/blob/ae70e2bc34aca8b581f53eb49a27460ac1fc3f83/src%2Fnode_url.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ae70e2bc34aca8b581f53eb49a27460ac1fc3f83/src%2Fnode_url.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_url.cc?ref=ae70e2bc34aca8b581f53eb49a27460ac1fc3f83",
            "patch": "@@ -15,6 +15,7 @@ using v8::Context;\n using v8::Function;\n using v8::FunctionCallbackInfo;\n using v8::HandleScope;\n+using v8::Int32;\n using v8::Integer;\n using v8::Isolate;\n using v8::Local;\n@@ -26,23 +27,12 @@ using v8::TryCatch;\n using v8::Undefined;\n using v8::Value;\n \n-#define GET(env, obj, name)                                                   \\\n-  obj->Get(env->context(),                                                    \\\n-           OneByteString(env->isolate(), name)).ToLocalChecked()\n-\n-#define GET_AND_SET(env, obj, name, data, flag)                               \\\n-  {                                                                           \\\n-    Local<Value> val = GET(env, obj, #name);                                  \\\n-    if (val->IsString()) {                                                    \\\n-      Utf8Value value(env->isolate(), val.As<String>());                      \\\n-      data->name = *value;                                                    \\\n-      data->flags |= flag;                                                    \\\n-    }                                                                         \\\n-  }\n-\n-#define UTF8STRING(isolate, str)                                              \\\n-  String::NewFromUtf8(isolate, str.c_str(), v8::NewStringType::kNormal)       \\\n-    .ToLocalChecked()\n+inline Local<String> Utf8String(Isolate* isolate, const std::string& str) {\n+  return String::NewFromUtf8(isolate,\n+                             str.data(),\n+                             v8::NewStringType::kNormal,\n+                             str.length()).ToLocalChecked();\n+}\n \n namespace url {\n \n@@ -69,6 +59,8 @@ class URLHost {\n \n   inline bool ParsingFailed() const { return type_ == HostType::H_FAILED; }\n   std::string ToString() const;\n+  // Like ToString(), but avoids a copy in exchange for invalidating `*this`.\n+  std::string ToStringMove();\n \n  private:\n   enum class HostType {\n@@ -80,10 +72,9 @@ class URLHost {\n   };\n \n   union Value {\n-    std::string domain;\n+    std::string domain_or_opaque;\n     uint32_t ipv4;\n     uint16_t ipv6[8];\n-    std::string opaque;\n \n     ~Value() {}\n     Value() : ipv4(0) {}\n@@ -95,9 +86,12 @@ class URLHost {\n   inline void Reset() {\n     using string = std::string;\n     switch (type_) {\n-      case HostType::H_DOMAIN: value_.domain.~string(); break;\n-      case HostType::H_OPAQUE: value_.opaque.~string(); break;\n-      default: break;\n+      case HostType::H_DOMAIN:\n+      case HostType::H_OPAQUE:\n+        value_.domain_or_opaque.~string();\n+        break;\n+      default:\n+        break;\n     }\n     type_ = HostType::H_FAILED;\n   }\n@@ -113,13 +107,13 @@ class URLHost {\n   inline void SetOpaque(std::string&& string) {\n     Reset();\n     type_ = HostType::H_OPAQUE;\n-    new(&value_.opaque) std::string(std::move(string));\n+    new(&value_.domain_or_opaque) std::string(std::move(string));\n   }\n \n   inline void SetDomain(std::string&& string) {\n     Reset();\n     type_ = HostType::H_DOMAIN;\n-    new(&value_.domain) std::string(std::move(string));\n+    new(&value_.domain_or_opaque) std::string(std::move(string));\n   }\n };\n \n@@ -136,7 +130,8 @@ URLHost::~URLHost() {\n   XX(ARG_PORT)                                                                \\\n   XX(ARG_PATH)                                                                \\\n   XX(ARG_QUERY)                                                               \\\n-  XX(ARG_FRAGMENT)\n+  XX(ARG_FRAGMENT)                                                            \\\n+  XX(ARG_COUNT)  // This one has to be last.\n \n #define ERR_ARGS(XX)                                                          \\\n   XX(ERR_ARG_FLAGS)                                                           \\\n@@ -665,7 +660,7 @@ inline std::string PercentDecode(const char* input, size_t len) {\n   XX(\"ws:\", 80)                                                               \\\n   XX(\"wss:\", 443)\n \n-inline bool IsSpecial(std::string scheme) {\n+inline bool IsSpecial(const std::string& scheme) {\n #define XX(name, _) if (scheme == name) return true;\n   SPECIALS(XX);\n #undef XX\n@@ -684,7 +679,7 @@ inline bool StartsWithWindowsDriveLetter(const char* p, const char* end) {\n       p[2] == '#');\n }\n \n-inline int NormalizePort(std::string scheme, int p) {\n+inline int NormalizePort(const std::string& scheme, int p) {\n #define XX(name, port) if (scheme == name && p == port) return -1;\n   SPECIALS(XX);\n #undef XX\n@@ -930,7 +925,7 @@ void URLHost::ParseIPv4Host(const char* input, size_t length, bool* is_ipv4) {\n void URLHost::ParseOpaqueHost(const char* input, size_t length) {\n   CHECK_EQ(type_, HostType::H_FAILED);\n   std::string output;\n-  output.reserve(length * 3);\n+  output.reserve(length);\n   for (size_t i = 0; i < length; i++) {\n     const char ch = input[i];\n     if (ch != '%' && IsForbiddenHostCodePoint(ch)) {\n@@ -1022,14 +1017,27 @@ inline T* FindLongestZeroSequence(T* values, size_t len) {\n   return result;\n }\n \n+std::string URLHost::ToStringMove() {\n+  std::string return_value;\n+  switch (type_) {\n+    case HostType::H_DOMAIN:\n+    case HostType::H_OPAQUE:\n+      return_value = std::move(value_.domain_or_opaque);\n+      break;\n+    default:\n+      return_value = ToString();\n+      break;\n+  }\n+  Reset();\n+  return return_value;\n+}\n+\n std::string URLHost::ToString() const {\n   std::string dest;\n   switch (type_) {\n     case HostType::H_DOMAIN:\n-      return value_.domain;\n-      break;\n     case HostType::H_OPAQUE:\n-      return value_.opaque;\n+      return value_.domain_or_opaque;\n       break;\n     case HostType::H_IPV4: {\n       dest.reserve(15);\n@@ -1089,103 +1097,125 @@ bool ParseHost(const std::string& input,\n   host.ParseHost(input.c_str(), input.length(), is_special, unicode);\n   if (host.ParsingFailed())\n     return false;\n-  *output = host.ToString();\n+  *output = host.ToStringMove();\n   return true;\n }\n \n-inline void Copy(Environment* env,\n-                 Local<Array> ary,\n-                 std::vector<std::string>* vec) {\n-  const int32_t len = ary->Length();\n+inline std::vector<std::string> FromJSStringArray(Environment* env,\n+                                                  Local<Array> array) {\n+  std::vector<std::string> vec;\n+  const int32_t len = array->Length();\n   if (len == 0)\n-    return;  // nothing to copy\n-  vec->reserve(len);\n+    return vec;  // nothing to copy\n+  vec.reserve(len);\n   for (int32_t n = 0; n < len; n++) {\n-    Local<Value> val = ary->Get(env->context(), n).ToLocalChecked();\n+    Local<Value> val = array->Get(env->context(), n).ToLocalChecked();\n     if (val->IsString()) {\n       Utf8Value value(env->isolate(), val.As<String>());\n-      vec->push_back(std::string(*value, value.length()));\n+      vec.emplace_back(*value, value.length());\n     }\n   }\n+  return vec;\n }\n \n-inline Local<Array> Copy(Environment* env,\n-                         const std::vector<std::string>& vec) {\n+inline Local<Array> ToJSStringArray(Environment* env,\n+                                    const std::vector<std::string>& vec) {\n   Isolate* isolate = env->isolate();\n-  Local<Array> ary = Array::New(isolate, vec.size());\n+  Local<Array> array = Array::New(isolate, vec.size());\n   for (size_t n = 0; n < vec.size(); n++)\n-    ary->Set(env->context(), n, UTF8STRING(isolate, vec[n])).FromJust();\n-  return ary;\n+    array->Set(env->context(), n, Utf8String(isolate, vec[n])).FromJust();\n+  return array;\n }\n \n-inline void HarvestBase(Environment* env,\n-                        struct url_data* base,\n-                        Local<Object> base_obj) {\n+inline url_data HarvestBase(Environment* env, Local<Object> base_obj) {\n+  url_data base;\n   Local<Context> context = env->context();\n-  Local<Value> flags = GET(env, base_obj, \"flags\");\n+  Local<Value> flags =\n+      base_obj->Get(env->context(), env->flags_string()).ToLocalChecked();\n   if (flags->IsInt32())\n-    base->flags = flags->Int32Value(context).FromJust();\n-\n-  Local<Value> scheme = GET(env, base_obj, \"scheme\");\n-  base->scheme = Utf8Value(env->isolate(), scheme).out();\n-\n-  GET_AND_SET(env, base_obj, username, base, URL_FLAGS_HAS_USERNAME);\n-  GET_AND_SET(env, base_obj, password, base, URL_FLAGS_HAS_PASSWORD);\n-  GET_AND_SET(env, base_obj, host, base, URL_FLAGS_HAS_HOST);\n-  GET_AND_SET(env, base_obj, query, base, URL_FLAGS_HAS_QUERY);\n-  GET_AND_SET(env, base_obj, fragment, base, URL_FLAGS_HAS_FRAGMENT);\n-  Local<Value> port = GET(env, base_obj, \"port\");\n+    base.flags = flags->Int32Value(context).FromJust();\n+\n+  Local<Value> scheme =\n+      base_obj->Get(env->context(), env->scheme_string()).ToLocalChecked();\n+  base.scheme = Utf8Value(env->isolate(), scheme).out();\n+\n+  auto GetStr = [&](std::string url_data::* member,\n+                    int flag,\n+                    Local<String> name) {\n+    Local<Value> value = base_obj->Get(env->context(), name).ToLocalChecked();\n+    if (value->IsString()) {\n+      Utf8Value utf8value(env->isolate(), value.As<String>());\n+      (base.*member).assign(*utf8value, utf8value.length());\n+      base.flags |= flag;\n+    }\n+  };\n+  GetStr(&url_data::username, URL_FLAGS_HAS_USERNAME, env->username_string());\n+  GetStr(&url_data::password, URL_FLAGS_HAS_PASSWORD, env->password_string());\n+  GetStr(&url_data::host, URL_FLAGS_HAS_HOST, env->host_string());\n+  GetStr(&url_data::query, URL_FLAGS_HAS_QUERY, env->query_string());\n+  GetStr(&url_data::fragment, URL_FLAGS_HAS_FRAGMENT, env->fragment_string());\n+\n+  Local<Value> port =\n+      base_obj->Get(env->context(), env->port_string()).ToLocalChecked();\n   if (port->IsInt32())\n-    base->port = port->Int32Value(context).FromJust();\n-  Local<Value> path = GET(env, base_obj, \"path\");\n+    base.port = port.As<Int32>()->Value();\n+\n+  Local<Value>\n+      path = base_obj->Get(env->context(), env->path_string()).ToLocalChecked();\n   if (path->IsArray()) {\n-    base->flags |= URL_FLAGS_HAS_PATH;\n-    Copy(env, path.As<Array>(), &(base->path));\n+    base.flags |= URL_FLAGS_HAS_PATH;\n+    base.path = FromJSStringArray(env, path.As<Array>());\n   }\n+  return base;\n }\n \n-inline void HarvestContext(Environment* env,\n-                           struct url_data* context,\n-                           Local<Object> context_obj) {\n-  Local<Value> flags = GET(env, context_obj, \"flags\");\n+inline url_data HarvestContext(Environment* env, Local<Object> context_obj) {\n+  url_data context;\n+  Local<Value> flags =\n+      context_obj->Get(env->context(), env->flags_string()).ToLocalChecked();\n   if (flags->IsInt32()) {\n-    int32_t _flags = flags->Int32Value(env->context()).FromJust();\n-    if (_flags & URL_FLAGS_SPECIAL)\n-      context->flags |= URL_FLAGS_SPECIAL;\n-    if (_flags & URL_FLAGS_CANNOT_BE_BASE)\n-      context->flags |= URL_FLAGS_CANNOT_BE_BASE;\n-    if (_flags & URL_FLAGS_HAS_USERNAME)\n-      context->flags |= URL_FLAGS_HAS_USERNAME;\n-    if (_flags & URL_FLAGS_HAS_PASSWORD)\n-      context->flags |= URL_FLAGS_HAS_PASSWORD;\n-    if (_flags & URL_FLAGS_HAS_HOST)\n-      context->flags |= URL_FLAGS_HAS_HOST;\n+    static const int32_t copy_flags_mask =\n+        URL_FLAGS_SPECIAL |\n+        URL_FLAGS_CANNOT_BE_BASE |\n+        URL_FLAGS_HAS_USERNAME |\n+        URL_FLAGS_HAS_PASSWORD |\n+        URL_FLAGS_HAS_HOST;\n+    context.flags |= flags.As<Int32>()->Value() & copy_flags_mask;\n   }\n-  Local<Value> scheme = GET(env, context_obj, \"scheme\");\n+  Local<Value> scheme =\n+      context_obj->Get(env->context(), env->scheme_string()).ToLocalChecked();\n   if (scheme->IsString()) {\n     Utf8Value value(env->isolate(), scheme);\n-    context->scheme.assign(*value, value.length());\n+    context.scheme.assign(*value, value.length());\n   }\n-  Local<Value> port = GET(env, context_obj, \"port\");\n+  Local<Value> port =\n+      context_obj->Get(env->context(), env->port_string()).ToLocalChecked();\n   if (port->IsInt32())\n-    context->port = port->Int32Value(env->context()).FromJust();\n-  if (context->flags & URL_FLAGS_HAS_USERNAME) {\n-    Local<Value> username = GET(env, context_obj, \"username\");\n+    context.port = port.As<Int32>()->Value();\n+  if (context.flags & URL_FLAGS_HAS_USERNAME) {\n+    Local<Value> username =\n+        context_obj->Get(env->context(),\n+                         env->username_string()).ToLocalChecked();\n     CHECK(username->IsString());\n     Utf8Value value(env->isolate(), username);\n-    context->username.assign(*value, value.length());\n+    context.username.assign(*value, value.length());\n   }\n-  if (context->flags & URL_FLAGS_HAS_PASSWORD) {\n-    Local<Value> password = GET(env, context_obj, \"password\");\n+  if (context.flags & URL_FLAGS_HAS_PASSWORD) {\n+    Local<Value> password =\n+        context_obj->Get(env->context(),\n+                         env->password_string()).ToLocalChecked();\n     CHECK(password->IsString());\n     Utf8Value value(env->isolate(), password);\n-    context->password.assign(*value, value.length());\n+    context.password.assign(*value, value.length());\n   }\n-  Local<Value> host = GET(env, context_obj, \"host\");\n+  Local<Value> host =\n+      context_obj->Get(env->context(),\n+                       env->host_string()).ToLocalChecked();\n   if (host->IsString()) {\n     Utf8Value value(env->isolate(), host);\n-    context->host.assign(*value, value.length());\n+    context.host.assign(*value, value.length());\n   }\n+  return context;\n }\n \n // Single dot segment can be \".\", \"%2e\", or \"%2E\"\n@@ -1267,30 +1297,37 @@ void URL::Parse(const char* input,\n     len = end - p;\n   }\n \n+  // The spec says we should strip out any ASCII tabs or newlines.\n+  // In those cases, we create another std::string instance with the filtered\n+  // contents, but in the general case we avoid the overhead.\n   std::string whitespace_stripped;\n-  whitespace_stripped.reserve(len);\n-  for (const char* ptr = p; ptr < end; ptr++)\n+  for (const char* ptr = p; ptr < end; ptr++) {\n     if (!IsASCIITabOrNewline(*ptr))\n-      whitespace_stripped += *ptr;\n+      continue;\n+    // Hit tab or newline. Allocate storage, copy what we have until now,\n+    // and then iterate and filter all similar characters out.\n+    whitespace_stripped.reserve(len - 1);\n+    whitespace_stripped.assign(p, ptr - p);\n+    // 'ptr + 1' skips the current char, which we know to be tab or newline.\n+    for (ptr = ptr + 1; ptr < end; ptr++) {\n+      if (!IsASCIITabOrNewline(*ptr))\n+        whitespace_stripped += *ptr;\n+    }\n \n-  input = whitespace_stripped.c_str();\n-  len = whitespace_stripped.size();\n-  p = input;\n-  end = input + len;\n+    // Update variables like they should have looked like if the string\n+    // had been stripped of whitespace to begin with.\n+    input = whitespace_stripped.c_str();\n+    len = whitespace_stripped.size();\n+    p = input;\n+    end = input + len;\n+    break;\n+  }\n \n-  bool atflag = false;\n-  bool sbflag = false;\n-  bool uflag = false;\n+  bool atflag = false;  // Set when @ has been seen.\n+  bool square_bracket_flag = false;  // Set inside of [...]\n+  bool password_token_seen_flag = false;  // Set after a : after an username.\n \n   std::string buffer;\n-  url->scheme.reserve(len);\n-  url->username.reserve(len);\n-  url->password.reserve(len);\n-  url->host.reserve(len);\n-  url->path.reserve(len);\n-  url->query.reserve(len);\n-  url->fragment.reserve(len);\n-  buffer.reserve(len);\n \n   // Set the initial parse state.\n   const bool has_state_override = state_override != kUnknownState;\n@@ -1347,7 +1384,7 @@ void URL::Parse(const char* input,\n             // as it can be done before even entering C++ binding.\n           }\n \n-          url->scheme = buffer;\n+          url->scheme = std::move(buffer);\n           url->port = NormalizePort(url->scheme, url->port);\n           if (new_is_special) {\n             url->flags |= URL_FLAGS_SPECIAL;\n@@ -1373,7 +1410,7 @@ void URL::Parse(const char* input,\n           } else {\n             url->flags |= URL_FLAGS_CANNOT_BE_BASE;\n             url->flags |= URL_FLAGS_HAS_PATH;\n-            url->path.push_back(\"\");\n+            url->path.emplace_back(\"\");\n             state = kCannotBeBase;\n           }\n         } else if (!has_state_override) {\n@@ -1602,12 +1639,12 @@ void URL::Parse(const char* input,\n             const char bch = buffer[n];\n             if (bch == ':') {\n               url->flags |= URL_FLAGS_HAS_PASSWORD;\n-              if (!uflag) {\n-                uflag = true;\n+              if (!password_token_seen_flag) {\n+                password_token_seen_flag = true;\n                 continue;\n               }\n             }\n-            if (uflag) {\n+            if (password_token_seen_flag) {\n               AppendOrEscape(&url->password, bch, USERINFO_ENCODE_SET);\n             } else {\n               AppendOrEscape(&url->username, bch, USERINFO_ENCODE_SET);\n@@ -1635,7 +1672,7 @@ void URL::Parse(const char* input,\n         if (has_state_override && url->scheme == \"file:\") {\n           state = kFileHost;\n           continue;\n-        } else if (ch == ':' && !sbflag) {\n+        } else if (ch == ':' && !square_bracket_flag) {\n           if (buffer.size() == 0) {\n             url->flags |= URL_FLAGS_FAILED;\n             return;\n@@ -1679,9 +1716,9 @@ void URL::Parse(const char* input,\n           }\n         } else {\n           if (ch == '[')\n-            sbflag = true;\n+            square_bracket_flag = true;\n           if (ch == ']')\n-            sbflag = false;\n+            square_bracket_flag = false;\n           buffer += ch;\n         }\n         break;\n@@ -1888,12 +1925,12 @@ void URL::Parse(const char* input,\n             ShortenUrlPath(url);\n             if (ch != '/' && !special_back_slash) {\n               url->flags |= URL_FLAGS_HAS_PATH;\n-              url->path.push_back(\"\");\n+              url->path.emplace_back(\"\");\n             }\n           } else if (IsSingleDotSegment(buffer) &&\n                      ch != '/' && !special_back_slash) {\n             url->flags |= URL_FLAGS_HAS_PATH;\n-            url->path.push_back(\"\");\n+            url->path.emplace_back(\"\");\n           } else if (!IsSingleDotSegment(buffer)) {\n             if (url->scheme == \"file:\" &&\n                 url->path.empty() &&\n@@ -1907,8 +1944,7 @@ void URL::Parse(const char* input,\n               buffer[1] = ':';\n             }\n             url->flags |= URL_FLAGS_HAS_PATH;\n-            std::string segment(buffer.c_str(), buffer.size());\n-            url->path.push_back(segment);\n+            url->path.emplace_back(std::move(buffer));\n           }\n           buffer.clear();\n           if (url->scheme == \"file:\" &&\n@@ -1947,7 +1983,7 @@ void URL::Parse(const char* input,\n       case kQuery:\n         if (ch == kEOL || (!has_state_override && ch == '#')) {\n           url->flags |= URL_FLAGS_HAS_QUERY;\n-          url->query = buffer;\n+          url->query = std::move(buffer);\n           buffer.clear();\n           if (ch == '#')\n             state = kFragment;\n@@ -1959,7 +1995,7 @@ void URL::Parse(const char* input,\n         switch (ch) {\n           case kEOL:\n             url->flags |= URL_FLAGS_HAS_FRAGMENT;\n-            url->fragment = buffer;\n+            url->fragment = std::move(buffer);\n             break;\n           case 0:\n             break;\n@@ -1977,25 +2013,25 @@ void URL::Parse(const char* input,\n }  // NOLINT(readability/fn_size)\n \n static inline void SetArgs(Environment* env,\n-                           Local<Value> argv[],\n-                           const struct url_data* url) {\n+                           Local<Value> argv[ARG_COUNT],\n+                           const struct url_data& url) {\n   Isolate* isolate = env->isolate();\n-  argv[ARG_FLAGS] = Integer::NewFromUnsigned(isolate, url->flags);\n-  argv[ARG_PROTOCOL] = OneByteString(isolate, url->scheme.c_str());\n-  if (url->flags & URL_FLAGS_HAS_USERNAME)\n-    argv[ARG_USERNAME] = UTF8STRING(isolate, url->username);\n-  if (url->flags & URL_FLAGS_HAS_PASSWORD)\n-    argv[ARG_PASSWORD] = UTF8STRING(isolate, url->password);\n-  if (url->flags & URL_FLAGS_HAS_HOST)\n-    argv[ARG_HOST] = UTF8STRING(isolate, url->host);\n-  if (url->flags & URL_FLAGS_HAS_QUERY)\n-    argv[ARG_QUERY] = UTF8STRING(isolate, url->query);\n-  if (url->flags & URL_FLAGS_HAS_FRAGMENT)\n-    argv[ARG_FRAGMENT] = UTF8STRING(isolate, url->fragment);\n-  if (url->port > -1)\n-    argv[ARG_PORT] = Integer::New(isolate, url->port);\n-  if (url->flags & URL_FLAGS_HAS_PATH)\n-    argv[ARG_PATH] = Copy(env, url->path);\n+  argv[ARG_FLAGS] = Integer::NewFromUnsigned(isolate, url.flags);\n+  argv[ARG_PROTOCOL] = OneByteString(isolate, url.scheme.c_str());\n+  if (url.flags & URL_FLAGS_HAS_USERNAME)\n+    argv[ARG_USERNAME] = Utf8String(isolate, url.username);\n+  if (url.flags & URL_FLAGS_HAS_PASSWORD)\n+    argv[ARG_PASSWORD] = Utf8String(isolate, url.password);\n+  if (url.flags & URL_FLAGS_HAS_HOST)\n+    argv[ARG_HOST] = Utf8String(isolate, url.host);\n+  if (url.flags & URL_FLAGS_HAS_QUERY)\n+    argv[ARG_QUERY] = Utf8String(isolate, url.query);\n+  if (url.flags & URL_FLAGS_HAS_FRAGMENT)\n+    argv[ARG_FRAGMENT] = Utf8String(isolate, url.fragment);\n+  if (url.port > -1)\n+    argv[ARG_PORT] = Integer::New(isolate, url.port);\n+  if (url.flags & URL_FLAGS_HAS_PATH)\n+    argv[ARG_PATH] = ToJSStringArray(env, url.path);\n }\n \n static void Parse(Environment* env,\n@@ -2015,12 +2051,12 @@ static void Parse(Environment* env,\n   const bool has_context = context_obj->IsObject();\n   const bool has_base = base_obj->IsObject();\n \n-  struct url_data base;\n-  struct url_data url;\n+  url_data base;\n+  url_data url;\n   if (has_context)\n-    HarvestContext(env, &url, context_obj.As<Object>());\n+    url = HarvestContext(env, context_obj.As<Object>());\n   if (has_base)\n-    HarvestBase(env, &base, base_obj.As<Object>());\n+    base = HarvestBase(env, base_obj.As<Object>());\n \n   URL::Parse(input, len, state_override, &url, has_context, &base, has_base);\n   if ((url.flags & URL_FLAGS_INVALID_PARSE_STATE) ||\n@@ -2032,7 +2068,7 @@ static void Parse(Environment* env,\n   const Local<Value> undef = Undefined(isolate);\n   const Local<Value> null = Null(isolate);\n   if (!(url.flags & URL_FLAGS_FAILED)) {\n-    Local<Value> argv[9] = {\n+    Local<Value> argv[] = {\n       undef,\n       undef,\n       undef,\n@@ -2043,7 +2079,7 @@ static void Parse(Environment* env,\n       null,  // query defaults to null\n       null,  // fragment defaults to null\n     };\n-    SetArgs(env, argv, &url);\n+    SetArgs(env, argv, url);\n     cb->Call(context, recv, arraysize(argv), argv).FromMaybe(Local<Value>());\n   } else if (error_cb->IsFunction()) {\n     Local<Value> argv[2] = { undef, undef };\n@@ -2152,7 +2188,7 @@ static void DomainToASCII(const FunctionCallbackInfo<Value>& args) {\n     args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"\"));\n     return;\n   }\n-  std::string out = host.ToString();\n+  std::string out = host.ToStringMove();\n   args.GetReturnValue().Set(\n       String::NewFromUtf8(env->isolate(),\n                           out.c_str(),\n@@ -2172,7 +2208,7 @@ static void DomainToUnicode(const FunctionCallbackInfo<Value>& args) {\n     args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"\"));\n     return;\n   }\n-  std::string out = host.ToString();\n+  std::string out = host.ToStringMove();\n   args.GetReturnValue().Set(\n       String::NewFromUtf8(env->isolate(),\n                           out.c_str(),\n@@ -2255,7 +2291,7 @@ const Local<Value> URL::ToObject(Environment* env) const {\n   if (context_.flags & URL_FLAGS_FAILED)\n     return Local<Value>();\n \n-  Local<Value> argv[9] = {\n+  Local<Value> argv[] = {\n     undef,\n     undef,\n     undef,\n@@ -2266,7 +2302,7 @@ const Local<Value> URL::ToObject(Environment* env) const {\n     null,  // query defaults to null\n     null,  // fragment defaults to null\n   };\n-  SetArgs(env, argv, &context_);\n+  SetArgs(env, argv, context_);\n \n   MaybeLocal<Value> ret;\n   {"
        }
    ],
    "stats": {
        "total": 343,
        "additions": 192,
        "deletions": 151
    }
}