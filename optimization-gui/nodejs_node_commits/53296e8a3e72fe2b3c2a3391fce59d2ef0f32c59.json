{
    "author": "unknown",
    "message": "n-api: guard against cond null dereference\n\nA condition variable is only created by the thread-safe function if the\nqueue size is set to something larger than zero. This adds null-checks\naround the condition variable and tests for the case where the queue\nsize is zero.\n\nFixes: https://github.com/nodejs/help/issues/1387\nPR-URL: https://github.com/nodejs/node/pull/21871\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>",
    "sha": "53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59",
    "files": [
        {
            "sha": "c0ea0a0204816625b014fa635d598db4cf46968e",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59",
            "patch": "@@ -3782,7 +3782,7 @@ class TsFn: public node::AsyncResource {\n     if (thread_count == 0 || mode == napi_tsfn_abort) {\n       if (!is_closing) {\n         is_closing = (mode == napi_tsfn_abort);\n-        if (is_closing) {\n+        if (is_closing && max_queue_size > 0) {\n           cond->Signal(lock);\n         }\n         if (uv_async_send(&async) != 0) {\n@@ -3872,7 +3872,9 @@ class TsFn: public node::AsyncResource {\n         if (size == 0) {\n           if (thread_count == 0) {\n             is_closing = true;\n-            cond->Signal(lock);\n+            if (max_queue_size > 0) {\n+              cond->Signal(lock);\n+            }\n             CloseHandlesAndMaybeDelete();\n           } else {\n             if (uv_idle_stop(&idle) != 0) {\n@@ -3939,7 +3941,9 @@ class TsFn: public node::AsyncResource {\n     if (set_closing) {\n       node::Mutex::ScopedLock lock(this->mutex);\n       is_closing = true;\n-      cond->Signal(lock);\n+      if (max_queue_size > 0) {\n+        cond->Signal(lock);\n+      }\n     }\n     if (handles_closing) {\n       return;"
        },
        {
            "sha": "354012a288b3ca3762e8dfa11619f0379e9c830e",
            "filename": "test/addons-napi/test_threadsafe_function/binding.c",
            "status": "modified",
            "additions": 34,
            "deletions": 5,
            "changes": 39,
            "blob_url": "https://github.com/nodejs/node/blob/53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59/test%2Faddons-napi%2Ftest_threadsafe_function%2Fbinding.c",
            "raw_url": "https://github.com/nodejs/node/raw/53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59/test%2Faddons-napi%2Ftest_threadsafe_function%2Fbinding.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2Ftest_threadsafe_function%2Fbinding.c?ref=53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59",
            "patch": "@@ -9,6 +9,7 @@\n #include \"../common.h\"\n \n #define ARRAY_LENGTH 10\n+#define MAX_QUEUE_SIZE 2\n \n static uv_thread_t uv_threads[2];\n static napi_threadsafe_function ts_fn;\n@@ -18,6 +19,7 @@ typedef struct {\n   napi_threadsafe_function_release_mode abort;\n   bool start_secondary;\n   napi_ref js_finalize_cb;\n+  uint32_t max_queue_size;\n } ts_fn_hint;\n \n static ts_fn_hint ts_info;\n@@ -71,6 +73,12 @@ static void data_source_thread(void* data) {\n   for (index = ARRAY_LENGTH - 1; index > -1 && !queue_was_closing; index--) {\n     status = napi_call_threadsafe_function(ts_fn, &ints[index],\n         ts_fn_info->block_on_full);\n+    if (ts_fn_info->max_queue_size == 0) {\n+      // Let's make this thread really busy for 200 ms to give the main thread a\n+      // chance to abort.\n+      uint64_t start = uv_hrtime();\n+      for (; uv_hrtime() - start < 200000000;);\n+    }\n     switch (status) {\n       case napi_queue_full:\n         queue_was_full = true;\n@@ -167,8 +175,8 @@ static napi_value StartThreadInternal(napi_env env,\n                                       napi_callback_info info,\n                                       napi_threadsafe_function_call_js cb,\n                                       bool block_on_full) {\n-  size_t argc = 3;\n-  napi_value argv[3];\n+  size_t argc = 4;\n+  napi_value argv[4];\n \n   ts_info.block_on_full =\n       (block_on_full ? napi_tsfn_blocking : napi_tsfn_nonblocking);\n@@ -178,8 +186,18 @@ static napi_value StartThreadInternal(napi_env env,\n   napi_value async_name;\n   NAPI_CALL(env, napi_create_string_utf8(env, \"N-API Thread-safe Function Test\",\n       NAPI_AUTO_LENGTH, &async_name));\n-  NAPI_CALL(env, napi_create_threadsafe_function(env, argv[0], NULL, async_name,\n-      2, 2, uv_threads, join_the_threads, &ts_info, cb, &ts_fn));\n+  NAPI_CALL(env, napi_get_value_uint32(env, argv[3], &ts_info.max_queue_size));\n+  NAPI_CALL(env, napi_create_threadsafe_function(env,\n+                                                 argv[0],\n+                                                 NULL,\n+                                                 async_name,\n+                                                 ts_info.max_queue_size,\n+                                                 2,\n+                                                 uv_threads,\n+                                                 join_the_threads,\n+                                                 &ts_info,\n+                                                 cb,\n+                                                 &ts_fn));\n   bool abort;\n   NAPI_CALL(env, napi_get_value_bool(env, argv[1], &abort));\n   ts_info.abort = abort ? napi_tsfn_abort : napi_tsfn_release;\n@@ -224,8 +242,9 @@ static napi_value Init(napi_env env, napi_value exports) {\n   for (index = 0; index < ARRAY_LENGTH; index++) {\n     ints[index] = index;\n   }\n-  napi_value js_array_length;\n+  napi_value js_array_length, js_max_queue_size;\n   napi_create_uint32(env, ARRAY_LENGTH, &js_array_length);\n+  napi_create_uint32(env, MAX_QUEUE_SIZE, &js_max_queue_size);\n \n   napi_property_descriptor properties[] = {\n     {\n@@ -238,6 +257,16 @@ static napi_value Init(napi_env env, napi_value exports) {\n       napi_enumerable,\n       NULL\n     },\n+    {\n+      \"MAX_QUEUE_SIZE\",\n+      NULL,\n+      NULL,\n+      NULL,\n+      NULL,\n+      js_max_queue_size,\n+      napi_enumerable,\n+      NULL\n+    },\n     DECLARE_NAPI_PROPERTY(\"StartThread\", StartThread),\n     DECLARE_NAPI_PROPERTY(\"StartThreadNoNative\", StartThreadNoNative),\n     DECLARE_NAPI_PROPERTY(\"StartThreadNonblocking\", StartThreadNonblocking),"
        },
        {
            "sha": "cfd00285308f5df370fd74c6afcaaa0cf668e916",
            "filename": "test/addons-napi/test_threadsafe_function/test.js",
            "status": "modified",
            "additions": 63,
            "deletions": 21,
            "changes": 84,
            "blob_url": "https://github.com/nodejs/node/blob/53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59/test%2Faddons-napi%2Ftest_threadsafe_function%2Ftest.js",
            "raw_url": "https://github.com/nodejs/node/raw/53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59/test%2Faddons-napi%2Ftest_threadsafe_function%2Ftest.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2Ftest_threadsafe_function%2Ftest.js?ref=53296e8a3e72fe2b3c2a3391fce59d2ef0f32c59",
            "patch": "@@ -23,7 +23,7 @@ if (process.argv[2] === 'child') {\n     if (callCount === 2) {\n       binding.Unref();\n     }\n-  }, false /* abort */, true /* launchSecondary */);\n+  }, false /* abort */, true /* launchSecondary */, +process.argv[3]);\n \n   // Release the thread-safe function from the main thread so that it may be\n   // torn down via the environment cleanup handler.\n@@ -35,6 +35,7 @@ function testWithJSMarshaller({\n   threadStarter,\n   quitAfter,\n   abort,\n+  maxQueueSize,\n   launchSecondary }) {\n   return new Promise((resolve) => {\n     const array = [];\n@@ -47,7 +48,7 @@ function testWithJSMarshaller({\n           }), !!abort);\n         });\n       }\n-    }, !!abort, !!launchSecondary);\n+    }, !!abort, !!launchSecondary, maxQueueSize);\n     if (threadStarter === 'StartThreadNonblocking') {\n       // Let's make this thread really busy for a short while to ensure that\n       // the queue fills and the thread receives a napi_queue_full.\n@@ -57,6 +58,24 @@ function testWithJSMarshaller({\n   });\n }\n \n+function testUnref(queueSize) {\n+  return new Promise((resolve, reject) => {\n+    let output = '';\n+    const child = fork(__filename, ['child', queueSize], {\n+      stdio: [process.stdin, 'pipe', process.stderr, 'ipc']\n+    });\n+    child.on('close', (code) => {\n+      if (code === 0) {\n+        resolve(output.match(/\\S+/g));\n+      } else {\n+        reject(new Error('Child process died with code ' + code));\n+      }\n+    });\n+    child.stdout.on('data', (data) => (output += data.toString()));\n+  })\n+  .then((result) => assert.strictEqual(result.indexOf(0), -1));\n+}\n+\n new Promise(function testWithoutJSMarshaller(resolve) {\n   let callCount = 0;\n   binding.StartThreadNoNative(function testCallback() {\n@@ -71,13 +90,23 @@ new Promise(function testWithoutJSMarshaller(resolve) {\n         }), false);\n       });\n     }\n-  }, false /* abort */, false /* launchSecondary */);\n+  }, false /* abort */, false /* launchSecondary */, binding.MAX_QUEUE_SIZE);\n })\n \n // Start the thread in blocking mode, and assert that all values are passed.\n // Quit after it's done.\n .then(() => testWithJSMarshaller({\n   threadStarter: 'StartThread',\n+  maxQueueSize: binding.MAX_QUEUE_SIZE,\n+  quitAfter: binding.ARRAY_LENGTH\n+}))\n+.then((result) => assert.deepStrictEqual(result, expectedArray))\n+\n+// Start the thread in blocking mode with an infinite queue, and assert that all\n+// values are passed. Quit after it's done.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThread',\n+  maxQueueSize: 0,\n   quitAfter: binding.ARRAY_LENGTH\n }))\n .then((result) => assert.deepStrictEqual(result, expectedArray))\n@@ -86,6 +115,7 @@ new Promise(function testWithoutJSMarshaller(resolve) {\n // Quit after it's done.\n .then(() => testWithJSMarshaller({\n   threadStarter: 'StartThreadNonblocking',\n+  maxQueueSize: binding.MAX_QUEUE_SIZE,\n   quitAfter: binding.ARRAY_LENGTH\n }))\n .then((result) => assert.deepStrictEqual(result, expectedArray))\n@@ -94,6 +124,16 @@ new Promise(function testWithoutJSMarshaller(resolve) {\n // Quit early, but let the thread finish.\n .then(() => testWithJSMarshaller({\n   threadStarter: 'StartThread',\n+  maxQueueSize: binding.MAX_QUEUE_SIZE,\n+  quitAfter: 1\n+}))\n+.then((result) => assert.deepStrictEqual(result, expectedArray))\n+\n+// Start the thread in blocking mode with an infinite queue, and assert that all\n+// values are passed. Quit early, but let the thread finish.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThread',\n+  maxQueueSize: 0,\n   quitAfter: 1\n }))\n .then((result) => assert.deepStrictEqual(result, expectedArray))\n@@ -102,6 +142,7 @@ new Promise(function testWithoutJSMarshaller(resolve) {\n // Quit early, but let the thread finish.\n .then(() => testWithJSMarshaller({\n   threadStarter: 'StartThreadNonblocking',\n+  maxQueueSize: binding.MAX_QUEUE_SIZE,\n   quitAfter: 1\n }))\n .then((result) => assert.deepStrictEqual(result, expectedArray))\n@@ -112,6 +153,7 @@ new Promise(function testWithoutJSMarshaller(resolve) {\n .then(() => testWithJSMarshaller({\n   threadStarter: 'StartThread',\n   quitAfter: 1,\n+  maxQueueSize: binding.MAX_QUEUE_SIZE,\n   launchSecondary: true\n }))\n .then((result) => assert.deepStrictEqual(result, expectedArray))\n@@ -122,15 +164,27 @@ new Promise(function testWithoutJSMarshaller(resolve) {\n .then(() => testWithJSMarshaller({\n   threadStarter: 'StartThreadNonblocking',\n   quitAfter: 1,\n+  maxQueueSize: binding.MAX_QUEUE_SIZE,\n   launchSecondary: true\n }))\n .then((result) => assert.deepStrictEqual(result, expectedArray))\n \n // Start the thread in blocking mode, and assert that it could not finish.\n-// Quit early and aborting.\n+// Quit early by aborting.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThread',\n+  quitAfter: 1,\n+  maxQueueSize: binding.MAX_QUEUE_SIZE,\n+  abort: true\n+}))\n+.then((result) => assert.strictEqual(result.indexOf(0), -1))\n+\n+// Start the thread in blocking mode with an infinite queue, and assert that it\n+// could not finish. Quit early by aborting.\n .then(() => testWithJSMarshaller({\n   threadStarter: 'StartThread',\n   quitAfter: 1,\n+  maxQueueSize: 0,\n   abort: true\n }))\n .then((result) => assert.strictEqual(result.indexOf(0), -1))\n@@ -140,25 +194,13 @@ new Promise(function testWithoutJSMarshaller(resolve) {\n .then(() => testWithJSMarshaller({\n   threadStarter: 'StartThreadNonblocking',\n   quitAfter: 1,\n+  maxQueueSize: binding.MAX_QUEUE_SIZE,\n   abort: true\n }))\n .then((result) => assert.strictEqual(result.indexOf(0), -1))\n \n // Start a child process to test rapid teardown\n-.then(() => {\n-  return new Promise((resolve, reject) => {\n-    let output = '';\n-    const child = fork(__filename, ['child'], {\n-      stdio: [process.stdin, 'pipe', process.stderr, 'ipc']\n-    });\n-    child.on('close', (code) => {\n-      if (code === 0) {\n-        resolve(output.match(/\\S+/g));\n-      } else {\n-        reject(new Error('Child process died with code ' + code));\n-      }\n-    });\n-    child.stdout.on('data', (data) => (output += data.toString()));\n-  });\n-})\n-.then((result) => assert.strictEqual(result.indexOf(0), -1));\n+.then(() => testUnref(binding.MAX_QUEUE_SIZE))\n+\n+// Start a child process with an infinite queue to test rapid teardown\n+.then(() => testUnref(0));"
        }
    ],
    "stats": {
        "total": 133,
        "additions": 104,
        "deletions": 29
    }
}