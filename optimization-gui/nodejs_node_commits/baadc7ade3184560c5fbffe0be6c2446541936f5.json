{
    "author": "jasnell",
    "message": "src: add node_process.cc\n\nBegin moving `process` object function definitions out of\n`node.cc` ... continuing the process of making `node.cc`\nsmaller and easier to maintain.\n\nPR-URL: https://github.com/nodejs/node/pull/21105\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Evan Lucas <evanlucas@me.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "baadc7ade3184560c5fbffe0be6c2446541936f5",
    "files": [
        {
            "sha": "301a0e20a1aeed2a32b013e20599978b1459b55d",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/baadc7ade3184560c5fbffe0be6c2446541936f5/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/baadc7ade3184560c5fbffe0be6c2446541936f5/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=baadc7ade3184560c5fbffe0be6c2446541936f5",
            "patch": "@@ -345,6 +345,7 @@\n         'src/node_platform.cc',\n         'src/node_perf.cc',\n         'src/node_postmortem_metadata.cc',\n+        'src/node_process.cc',\n         'src/node_serdes.cc',\n         'src/node_trace_events.cc',\n         'src/node_types.cc',"
        },
        {
            "sha": "e5ed352786b56e4e3314a109d94294221a201b3f",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 544,
            "changes": 553,
            "blob_url": "https://github.com/nodejs/node/blob/baadc7ade3184560c5fbffe0be6c2446541936f5/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/baadc7ade3184560c5fbffe0be6c2446541936f5/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=baadc7ade3184560c5fbffe0be6c2446541936f5",
            "patch": "@@ -137,11 +137,9 @@ using v8::Boolean;\n using v8::Context;\n using v8::EscapableHandleScope;\n using v8::Exception;\n-using v8::Float64Array;\n using v8::Function;\n using v8::FunctionCallbackInfo;\n using v8::HandleScope;\n-using v8::HeapStatistics;\n using v8::Integer;\n using v8::Isolate;\n using v8::Just;\n@@ -163,8 +161,6 @@ using v8::ScriptOrigin;\n using v8::SealHandleScope;\n using v8::String;\n using v8::TryCatch;\n-using v8::Uint32;\n-using v8::Uint32Array;\n using v8::Undefined;\n using v8::V8;\n using v8::Value;\n@@ -282,7 +278,7 @@ bool v8_initialized = false;\n bool linux_at_secure = false;\n \n // process-relative uptime base, initialized at start-up\n-static double prog_start_time;\n+double prog_start_time;\n \n static Mutex node_isolate_mutex;\n static v8::Isolate* node_isolate;\n@@ -385,7 +381,7 @@ static struct {\n static const unsigned kMaxSignal = 32;\n #endif\n \n-static void PrintErrorString(const char* format, ...) {\n+void PrintErrorString(const char* format, ...) {\n   va_list ap;\n   va_start(ap, format);\n #ifdef _WIN32\n@@ -1102,395 +1098,6 @@ NO_RETURN void Assert(const char* const (*args)[4]) {\n }\n \n \n-static void Abort(const FunctionCallbackInfo<Value>& args) {\n-  Abort();\n-}\n-\n-\n-void Chdir(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  CHECK(env->is_main_thread());\n-\n-  CHECK_EQ(args.Length(), 1);\n-  CHECK(args[0]->IsString());\n-  node::Utf8Value path(args.GetIsolate(), args[0]);\n-  int err = uv_chdir(*path);\n-  if (err) {\n-    return env->ThrowUVException(err, \"chdir\", nullptr, *path, nullptr);\n-  }\n-}\n-\n-\n-static void Cwd(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-#ifdef _WIN32\n-  /* MAX_PATH is in characters, not bytes. Make sure we have enough headroom. */\n-  char buf[MAX_PATH * 4];\n-#else\n-  char buf[PATH_MAX];\n-#endif\n-\n-  size_t cwd_len = sizeof(buf);\n-  int err = uv_cwd(buf, &cwd_len);\n-  if (err) {\n-    return env->ThrowUVException(err, \"uv_cwd\");\n-  }\n-\n-  Local<String> cwd = String::NewFromUtf8(env->isolate(),\n-                                          buf,\n-                                          String::kNormalString,\n-                                          cwd_len);\n-  args.GetReturnValue().Set(cwd);\n-}\n-\n-\n-void Umask(const FunctionCallbackInfo<Value>& args) {\n-  uint32_t old;\n-\n-  CHECK_EQ(args.Length(), 1);\n-  CHECK(args[0]->IsUndefined() || args[0]->IsUint32());\n-\n-  if (args[0]->IsUndefined()) {\n-    old = umask(0);\n-    umask(static_cast<mode_t>(old));\n-  } else {\n-    int oct = args[0].As<Uint32>()->Value();\n-    old = umask(static_cast<mode_t>(oct));\n-  }\n-\n-  args.GetReturnValue().Set(old);\n-}\n-\n-\n-#if defined(__POSIX__) && !defined(__ANDROID__) && !defined(__CloudABI__)\n-\n-static const uid_t uid_not_found = static_cast<uid_t>(-1);\n-static const gid_t gid_not_found = static_cast<gid_t>(-1);\n-\n-\n-static uid_t uid_by_name(const char* name) {\n-  struct passwd pwd;\n-  struct passwd* pp;\n-  char buf[8192];\n-\n-  errno = 0;\n-  pp = nullptr;\n-\n-  if (getpwnam_r(name, &pwd, buf, sizeof(buf), &pp) == 0 && pp != nullptr) {\n-    return pp->pw_uid;\n-  }\n-\n-  return uid_not_found;\n-}\n-\n-\n-static char* name_by_uid(uid_t uid) {\n-  struct passwd pwd;\n-  struct passwd* pp;\n-  char buf[8192];\n-  int rc;\n-\n-  errno = 0;\n-  pp = nullptr;\n-\n-  if ((rc = getpwuid_r(uid, &pwd, buf, sizeof(buf), &pp)) == 0 &&\n-      pp != nullptr) {\n-    return strdup(pp->pw_name);\n-  }\n-\n-  if (rc == 0) {\n-    errno = ENOENT;\n-  }\n-\n-  return nullptr;\n-}\n-\n-\n-static gid_t gid_by_name(const char* name) {\n-  struct group pwd;\n-  struct group* pp;\n-  char buf[8192];\n-\n-  errno = 0;\n-  pp = nullptr;\n-\n-  if (getgrnam_r(name, &pwd, buf, sizeof(buf), &pp) == 0 && pp != nullptr) {\n-    return pp->gr_gid;\n-  }\n-\n-  return gid_not_found;\n-}\n-\n-\n-#if 0  // For future use.\n-static const char* name_by_gid(gid_t gid) {\n-  struct group pwd;\n-  struct group* pp;\n-  char buf[8192];\n-  int rc;\n-\n-  errno = 0;\n-  pp = nullptr;\n-\n-  if ((rc = getgrgid_r(gid, &pwd, buf, sizeof(buf), &pp)) == 0 &&\n-      pp != nullptr) {\n-    return strdup(pp->gr_name);\n-  }\n-\n-  if (rc == 0) {\n-    errno = ENOENT;\n-  }\n-\n-  return nullptr;\n-}\n-#endif\n-\n-\n-static uid_t uid_by_name(Isolate* isolate, Local<Value> value) {\n-  if (value->IsUint32()) {\n-    return static_cast<uid_t>(value->Uint32Value());\n-  } else {\n-    node::Utf8Value name(isolate, value);\n-    return uid_by_name(*name);\n-  }\n-}\n-\n-\n-static gid_t gid_by_name(Isolate* isolate, Local<Value> value) {\n-  if (value->IsUint32()) {\n-    return static_cast<gid_t>(value->Uint32Value());\n-  } else {\n-    node::Utf8Value name(isolate, value);\n-    return gid_by_name(*name);\n-  }\n-}\n-\n-static void GetUid(const FunctionCallbackInfo<Value>& args) {\n-  // uid_t is an uint32_t on all supported platforms.\n-  args.GetReturnValue().Set(static_cast<uint32_t>(getuid()));\n-}\n-\n-\n-static void GetGid(const FunctionCallbackInfo<Value>& args) {\n-  // gid_t is an uint32_t on all supported platforms.\n-  args.GetReturnValue().Set(static_cast<uint32_t>(getgid()));\n-}\n-\n-\n-static void GetEUid(const FunctionCallbackInfo<Value>& args) {\n-  // uid_t is an uint32_t on all supported platforms.\n-  args.GetReturnValue().Set(static_cast<uint32_t>(geteuid()));\n-}\n-\n-\n-static void GetEGid(const FunctionCallbackInfo<Value>& args) {\n-  // gid_t is an uint32_t on all supported platforms.\n-  args.GetReturnValue().Set(static_cast<uint32_t>(getegid()));\n-}\n-\n-\n-void SetGid(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  CHECK(env->is_main_thread());\n-\n-  CHECK_EQ(args.Length(), 1);\n-  CHECK(args[0]->IsUint32() || args[0]->IsString());\n-\n-  gid_t gid = gid_by_name(env->isolate(), args[0]);\n-\n-  if (gid == gid_not_found) {\n-    // Tells JS to throw ERR_INVALID_CREDENTIAL\n-    args.GetReturnValue().Set(1);\n-  } else if (setgid(gid)) {\n-    env->ThrowErrnoException(errno, \"setgid\");\n-  } else {\n-    args.GetReturnValue().Set(0);\n-  }\n-}\n-\n-\n-void SetEGid(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  CHECK(env->is_main_thread());\n-\n-  CHECK_EQ(args.Length(), 1);\n-  CHECK(args[0]->IsUint32() || args[0]->IsString());\n-\n-  gid_t gid = gid_by_name(env->isolate(), args[0]);\n-\n-  if (gid == gid_not_found) {\n-    // Tells JS to throw ERR_INVALID_CREDENTIAL\n-    args.GetReturnValue().Set(1);\n-  } else if (setegid(gid)) {\n-    env->ThrowErrnoException(errno, \"setegid\");\n-  } else {\n-    args.GetReturnValue().Set(0);\n-  }\n-}\n-\n-\n-void SetUid(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  CHECK(env->is_main_thread());\n-\n-  CHECK_EQ(args.Length(), 1);\n-  CHECK(args[0]->IsUint32() || args[0]->IsString());\n-\n-  uid_t uid = uid_by_name(env->isolate(), args[0]);\n-\n-  if (uid == uid_not_found) {\n-    // Tells JS to throw ERR_INVALID_CREDENTIAL\n-    args.GetReturnValue().Set(1);\n-  } else if (setuid(uid)) {\n-    env->ThrowErrnoException(errno, \"setuid\");\n-  } else {\n-    args.GetReturnValue().Set(0);\n-  }\n-}\n-\n-\n-void SetEUid(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  CHECK(env->is_main_thread());\n-\n-  CHECK_EQ(args.Length(), 1);\n-  CHECK(args[0]->IsUint32() || args[0]->IsString());\n-\n-  uid_t uid = uid_by_name(env->isolate(), args[0]);\n-\n-  if (uid == uid_not_found) {\n-    // Tells JS to throw ERR_INVALID_CREDENTIAL\n-    args.GetReturnValue().Set(1);\n-  } else if (seteuid(uid)) {\n-    env->ThrowErrnoException(errno, \"seteuid\");\n-  } else {\n-    args.GetReturnValue().Set(0);\n-  }\n-}\n-\n-\n-static void GetGroups(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  int ngroups = getgroups(0, nullptr);\n-\n-  if (ngroups == -1) {\n-    return env->ThrowErrnoException(errno, \"getgroups\");\n-  }\n-\n-  gid_t* groups = new gid_t[ngroups];\n-\n-  ngroups = getgroups(ngroups, groups);\n-\n-  if (ngroups == -1) {\n-    delete[] groups;\n-    return env->ThrowErrnoException(errno, \"getgroups\");\n-  }\n-\n-  Local<Array> groups_list = Array::New(env->isolate(), ngroups);\n-  bool seen_egid = false;\n-  gid_t egid = getegid();\n-\n-  for (int i = 0; i < ngroups; i++) {\n-    groups_list->Set(i, Integer::New(env->isolate(), groups[i]));\n-    if (groups[i] == egid)\n-      seen_egid = true;\n-  }\n-\n-  delete[] groups;\n-\n-  if (seen_egid == false) {\n-    groups_list->Set(ngroups, Integer::New(env->isolate(), egid));\n-  }\n-\n-  args.GetReturnValue().Set(groups_list);\n-}\n-\n-\n-void SetGroups(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  CHECK_EQ(args.Length(), 1);\n-  CHECK(args[0]->IsArray());\n-\n-  Local<Array> groups_list = args[0].As<Array>();\n-  size_t size = groups_list->Length();\n-  gid_t* groups = new gid_t[size];\n-\n-  for (size_t i = 0; i < size; i++) {\n-    gid_t gid = gid_by_name(env->isolate(), groups_list->Get(i));\n-\n-    if (gid == gid_not_found) {\n-      delete[] groups;\n-      // Tells JS to throw ERR_INVALID_CREDENTIAL\n-      args.GetReturnValue().Set(static_cast<uint32_t>(i + 1));\n-      return;\n-    }\n-\n-    groups[i] = gid;\n-  }\n-\n-  int rc = setgroups(size, groups);\n-  delete[] groups;\n-\n-  if (rc == -1) {\n-    return env->ThrowErrnoException(errno, \"setgroups\");\n-  }\n-\n-  args.GetReturnValue().Set(0);\n-}\n-\n-\n-void InitGroups(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  CHECK_EQ(args.Length(), 2);\n-  CHECK(args[0]->IsUint32() || args[0]->IsString());\n-  CHECK(args[1]->IsUint32() || args[1]->IsString());\n-\n-  node::Utf8Value arg0(env->isolate(), args[0]);\n-  gid_t extra_group;\n-  bool must_free;\n-  char* user;\n-\n-  if (args[0]->IsUint32()) {\n-    user = name_by_uid(args[0]->Uint32Value());\n-    must_free = true;\n-  } else {\n-    user = *arg0;\n-    must_free = false;\n-  }\n-\n-  if (user == nullptr) {\n-    // Tells JS to throw ERR_INVALID_CREDENTIAL\n-    return args.GetReturnValue().Set(1);\n-  }\n-\n-  extra_group = gid_by_name(env->isolate(), args[1]);\n-\n-  if (extra_group == gid_not_found) {\n-    if (must_free)\n-      free(user);\n-    // Tells JS to throw ERR_INVALID_CREDENTIAL\n-    return args.GetReturnValue().Set(2);\n-  }\n-\n-  int rc = initgroups(user, extra_group);\n-\n-  if (must_free) {\n-    free(user);\n-  }\n-\n-  if (rc) {\n-    return env->ThrowErrnoException(errno, \"initgroups\");\n-  }\n-\n-  args.GetReturnValue().Set(0);\n-}\n-\n-#endif  // __POSIX__ && !defined(__ANDROID__) && !defined(__CloudABI__)\n-\n-\n static void WaitForInspectorDisconnect(Environment* env) {\n #if HAVE_INSPECTOR\n   if (env->inspector_agent()->HasConnectedSessions()) {\n@@ -1519,113 +1126,6 @@ static void Exit(const FunctionCallbackInfo<Value>& args) {\n   env->Exit(args[0]->Int32Value());\n }\n \n-\n-static void Uptime(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  double uptime;\n-\n-  uv_update_time(env->event_loop());\n-  uptime = uv_now(env->event_loop()) - prog_start_time;\n-\n-  args.GetReturnValue().Set(Number::New(env->isolate(), uptime / 1000));\n-}\n-\n-\n-void MemoryUsage(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  size_t rss;\n-  int err = uv_resident_set_memory(&rss);\n-  if (err) {\n-    return env->ThrowUVException(err, \"uv_resident_set_memory\");\n-  }\n-\n-  Isolate* isolate = env->isolate();\n-  // V8 memory usage\n-  HeapStatistics v8_heap_stats;\n-  isolate->GetHeapStatistics(&v8_heap_stats);\n-\n-  // Get the double array pointer from the Float64Array argument.\n-  CHECK(args[0]->IsFloat64Array());\n-  Local<Float64Array> array = args[0].As<Float64Array>();\n-  CHECK_EQ(array->Length(), 4);\n-  Local<ArrayBuffer> ab = array->Buffer();\n-  double* fields = static_cast<double*>(ab->GetContents().Data());\n-\n-  fields[0] = rss;\n-  fields[1] = v8_heap_stats.total_heap_size();\n-  fields[2] = v8_heap_stats.used_heap_size();\n-  fields[3] = isolate->AdjustAmountOfExternalAllocatedMemory(0);\n-}\n-\n-\n-static void Kill(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  if (args.Length() != 2) {\n-    return env->ThrowError(\"Bad argument.\");\n-  }\n-\n-  int pid = args[0]->Int32Value();\n-  int sig = args[1]->Int32Value();\n-  int err = uv_kill(pid, sig);\n-  args.GetReturnValue().Set(err);\n-}\n-\n-// used in Hrtime() below\n-#define NANOS_PER_SEC 1000000000\n-\n-// Hrtime exposes libuv's uv_hrtime() high-resolution timer.\n-// The value returned by uv_hrtime() is a 64-bit int representing nanoseconds,\n-// so this function instead fills in an Uint32Array with 3 entries,\n-// to avoid any integer overflow possibility.\n-// The first two entries contain the second part of the value\n-// broken into the upper/lower 32 bits to be converted back in JS,\n-// because there is no Uint64Array in JS.\n-// The third entry contains the remaining nanosecond part of the value.\n-void Hrtime(const FunctionCallbackInfo<Value>& args) {\n-  uint64_t t = uv_hrtime();\n-\n-  Local<ArrayBuffer> ab = args[0].As<Uint32Array>()->Buffer();\n-  uint32_t* fields = static_cast<uint32_t*>(ab->GetContents().Data());\n-\n-  fields[0] = (t / NANOS_PER_SEC) >> 32;\n-  fields[1] = (t / NANOS_PER_SEC) & 0xffffffff;\n-  fields[2] = t % NANOS_PER_SEC;\n-}\n-\n-// Microseconds in a second, as a float, used in CPUUsage() below\n-#define MICROS_PER_SEC 1e6\n-\n-// CPUUsage use libuv's uv_getrusage() this-process resource usage accessor,\n-// to access ru_utime (user CPU time used) and ru_stime (system CPU time used),\n-// which are uv_timeval_t structs (long tv_sec, long tv_usec).\n-// Returns those values as Float64 microseconds in the elements of the array\n-// passed to the function.\n-void CPUUsage(const FunctionCallbackInfo<Value>& args) {\n-  uv_rusage_t rusage;\n-\n-  // Call libuv to get the values we'll return.\n-  int err = uv_getrusage(&rusage);\n-  if (err) {\n-    // On error, return the strerror version of the error code.\n-    Local<String> errmsg = OneByteString(args.GetIsolate(), uv_strerror(err));\n-    args.GetReturnValue().Set(errmsg);\n-    return;\n-  }\n-\n-  // Get the double array pointer from the Float64Array argument.\n-  CHECK(args[0]->IsFloat64Array());\n-  Local<Float64Array> array = args[0].As<Float64Array>();\n-  CHECK_EQ(array->Length(), 2);\n-  Local<ArrayBuffer> ab = array->Buffer();\n-  double* fields = static_cast<double*>(ab->GetContents().Data());\n-\n-  // Set the Float64Array elements to be user / system values in microseconds.\n-  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;\n-  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;\n-}\n-\n extern \"C\" void node_module_register(void* m) {\n   struct node_module* mp = reinterpret_cast<struct node_module*>(m);\n \n@@ -2412,18 +1912,6 @@ static void DebugEnd(const FunctionCallbackInfo<Value>& args);\n \n namespace {\n \n-void StartProfilerIdleNotifier(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  env->StartProfilerIdleNotifier();\n-}\n-\n-\n-void StopProfilerIdleNotifier(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  env->StopProfilerIdleNotifier();\n-}\n-\n-\n #define READONLY_PROPERTY(obj, str, var)                                      \\\n   do {                                                                        \\\n     obj->DefineOwnProperty(env->context(),                                    \\\n@@ -2748,6 +2236,8 @@ void SetupProcessObject(Environment* env,\n \n   // define various internal methods\n   if (env->is_main_thread()) {\n+    env->SetMethod(process, \"_debugProcess\", DebugProcess);\n+    env->SetMethod(process, \"_debugEnd\", DebugEnd);\n     env->SetMethod(process,\n                    \"_startProfilerIdleNotifier\",\n                    StartProfilerIdleNotifier);\n@@ -2758,11 +2248,14 @@ void SetupProcessObject(Environment* env,\n     env->SetMethod(process, \"chdir\", Chdir);\n     env->SetMethod(process, \"umask\", Umask);\n   }\n-\n   env->SetMethod(process, \"_getActiveRequests\", GetActiveRequests);\n   env->SetMethod(process, \"_getActiveHandles\", GetActiveHandles);\n-  env->SetMethod(process, \"reallyExit\", Exit);\n+  env->SetMethod(process, \"_kill\", Kill);\n+\n   env->SetMethod(process, \"cwd\", Cwd);\n+  env->SetMethod(process, \"dlopen\", DLOpen);\n+  env->SetMethod(process, \"reallyExit\", Exit);\n+  env->SetMethod(process, \"uptime\", Uptime);\n \n #if defined(__POSIX__) && !defined(__ANDROID__) && !defined(__CloudABI__)\n   env->SetMethod(process, \"getuid\", GetUid);\n@@ -2771,21 +2264,6 @@ void SetupProcessObject(Environment* env,\n   env->SetMethod(process, \"getegid\", GetEGid);\n   env->SetMethod(process, \"getgroups\", GetGroups);\n #endif  // __POSIX__ && !defined(__ANDROID__) && !defined(__CloudABI__)\n-\n-  env->SetMethod(process, \"_kill\", Kill);\n-  env->SetMethod(process, \"dlopen\", DLOpen);\n-\n-  if (env->is_main_thread()) {\n-    env->SetMethod(process, \"_debugProcess\", DebugProcess);\n-    env->SetMethod(process, \"_debugEnd\", DebugEnd);\n-  }\n-\n-  env->SetMethod(process, \"hrtime\", Hrtime);\n-\n-  env->SetMethod(process, \"cpuUsage\", CPUUsage);\n-\n-  env->SetMethod(process, \"uptime\", Uptime);\n-  env->SetMethod(process, \"memoryUsage\", MemoryUsage);\n }\n \n \n@@ -2806,19 +2284,6 @@ void SignalExit(int signo) {\n }\n \n \n-// Most of the time, it's best to use `console.error` to write\n-// to the process.stderr stream.  However, in some cases, such as\n-// when debugging the stream.Writable class or the process.nextTick\n-// function, it is useful to bypass JavaScript entirely.\n-void RawDebug(const FunctionCallbackInfo<Value>& args) {\n-  CHECK(args.Length() == 1 && args[0]->IsString() &&\n-        \"must be called with a single string\");\n-  node::Utf8Value message(args.GetIsolate(), args[0]);\n-  PrintErrorString(\"%s\\n\", *message);\n-  fflush(stderr);\n-}\n-\n-\n static MaybeLocal<Function> GetBootstrapper(\n     Environment* env,\n     Local<String> source,"
        },
        {
            "sha": "9468770dbe75a95473b2fcd1bde1229dd69e10b8",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/baadc7ade3184560c5fbffe0be6c2446541936f5/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/baadc7ade3184560c5fbffe0be6c2446541936f5/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=baadc7ade3184560c5fbffe0be6c2446541936f5",
            "patch": "@@ -897,12 +897,21 @@ static inline const char* errno_string(int errorno) {\n \n // Functions defined in node.cc that are exposed via the bootstrapper object\n \n+extern double prog_start_time;\n+void PrintErrorString(const char* format, ...);\n+\n+void Abort(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Chdir(const v8::FunctionCallbackInfo<v8::Value>& args);\n void CPUUsage(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void Cwd(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Hrtime(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void Kill(const v8::FunctionCallbackInfo<v8::Value>& args);\n void MemoryUsage(const v8::FunctionCallbackInfo<v8::Value>& args);\n void RawDebug(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void StartProfilerIdleNotifier(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void StopProfilerIdleNotifier(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Umask(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void Uptime(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n #if defined(__POSIX__) && !defined(__ANDROID__) && !defined(__CloudABI__)\n void SetGid(const v8::FunctionCallbackInfo<v8::Value>& args);\n@@ -911,6 +920,11 @@ void SetUid(const v8::FunctionCallbackInfo<v8::Value>& args);\n void SetEUid(const v8::FunctionCallbackInfo<v8::Value>& args);\n void SetGroups(const v8::FunctionCallbackInfo<v8::Value>& args);\n void InitGroups(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void GetUid(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void GetGid(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void GetEUid(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void GetEGid(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void GetGroups(const v8::FunctionCallbackInfo<v8::Value>& args);\n #endif  // __POSIX__ && !defined(__ANDROID__) && !defined(__CloudABI__)\n \n }  // namespace node"
        },
        {
            "sha": "3a7c12ec453c963cc3731754dc4b16009bee511d",
            "filename": "src/node_process.cc",
            "status": "added",
            "additions": 544,
            "deletions": 0,
            "changes": 544,
            "blob_url": "https://github.com/nodejs/node/blob/baadc7ade3184560c5fbffe0be6c2446541936f5/src%2Fnode_process.cc",
            "raw_url": "https://github.com/nodejs/node/raw/baadc7ade3184560c5fbffe0be6c2446541936f5/src%2Fnode_process.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_process.cc?ref=baadc7ade3184560c5fbffe0be6c2446541936f5",
            "patch": "@@ -0,0 +1,544 @@\n+#include \"node.h\"\n+#include \"node_internals.h\"\n+#include \"env.h\"\n+#include \"env-inl.h\"\n+#include \"util.h\"\n+#include \"util-inl.h\"\n+#include \"uv.h\"\n+#include \"v8.h\"\n+\n+#include <limits.h>  // PATH_MAX\n+#include <stdio.h>\n+\n+#if defined(_MSC_VER)\n+#include <direct.h>\n+#include <io.h>\n+#define umask _umask\n+typedef int mode_t;\n+#else\n+#include <pthread.h>\n+#include <sys/resource.h>  // getrlimit, setrlimit\n+#include <termios.h>  // tcgetattr, tcsetattr\n+#include <unistd.h>  // setuid, getuid\n+#endif\n+\n+#if defined(__POSIX__) && !defined(__ANDROID__) && !defined(__CloudABI__)\n+#include <pwd.h>  // getpwnam()\n+#include <grp.h>  // getgrnam()\n+#endif\n+\n+namespace node {\n+\n+using v8::Array;\n+using v8::ArrayBuffer;\n+using v8::Float64Array;\n+using v8::FunctionCallbackInfo;\n+using v8::HeapStatistics;\n+using v8::Integer;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Number;\n+using v8::String;\n+using v8::Uint32;\n+using v8::Uint32Array;\n+using v8::Value;\n+\n+// Microseconds in a second, as a float, used in CPUUsage() below\n+#define MICROS_PER_SEC 1e6\n+// used in Hrtime() below\n+#define NANOS_PER_SEC 1000000000\n+\n+void Abort(const FunctionCallbackInfo<Value>& args) {\n+  Abort();\n+}\n+\n+void Chdir(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n+\n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsString());\n+  Utf8Value path(env->isolate(), args[0]);\n+  int err = uv_chdir(*path);\n+  if (err)\n+    return env->ThrowUVException(err, \"chdir\", nullptr, *path, nullptr);\n+}\n+\n+// CPUUsage use libuv's uv_getrusage() this-process resource usage accessor,\n+// to access ru_utime (user CPU time used) and ru_stime (system CPU time used),\n+// which are uv_timeval_t structs (long tv_sec, long tv_usec).\n+// Returns those values as Float64 microseconds in the elements of the array\n+// passed to the function.\n+void CPUUsage(const FunctionCallbackInfo<Value>& args) {\n+  uv_rusage_t rusage;\n+\n+  // Call libuv to get the values we'll return.\n+  int err = uv_getrusage(&rusage);\n+  if (err) {\n+    // On error, return the strerror version of the error code.\n+    Local<String> errmsg = OneByteString(args.GetIsolate(), uv_strerror(err));\n+    return args.GetReturnValue().Set(errmsg);\n+  }\n+\n+  // Get the double array pointer from the Float64Array argument.\n+  CHECK(args[0]->IsFloat64Array());\n+  Local<Float64Array> array = args[0].As<Float64Array>();\n+  CHECK_EQ(array->Length(), 2);\n+  Local<ArrayBuffer> ab = array->Buffer();\n+  double* fields = static_cast<double*>(ab->GetContents().Data());\n+\n+  // Set the Float64Array elements to be user / system values in microseconds.\n+  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;\n+  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;\n+}\n+\n+void Cwd(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+#ifdef _WIN32\n+  /* MAX_PATH is in characters, not bytes. Make sure we have enough headroom. */\n+  char buf[MAX_PATH * 4];\n+#else\n+  char buf[PATH_MAX];\n+#endif\n+\n+  size_t cwd_len = sizeof(buf);\n+  int err = uv_cwd(buf, &cwd_len);\n+  if (err)\n+    return env->ThrowUVException(err, \"uv_cwd\");\n+\n+  Local<String> cwd = String::NewFromUtf8(env->isolate(),\n+                                          buf,\n+                                          String::kNormalString,\n+                                          cwd_len);\n+  args.GetReturnValue().Set(cwd);\n+}\n+\n+// Hrtime exposes libuv's uv_hrtime() high-resolution timer.\n+// The value returned by uv_hrtime() is a 64-bit int representing nanoseconds,\n+// so this function instead fills in an Uint32Array with 3 entries,\n+// to avoid any integer overflow possibility.\n+// The first two entries contain the second part of the value\n+// broken into the upper/lower 32 bits to be converted back in JS,\n+// because there is no Uint64Array in JS.\n+// The third entry contains the remaining nanosecond part of the value.\n+void Hrtime(const FunctionCallbackInfo<Value>& args) {\n+  uint64_t t = uv_hrtime();\n+\n+  Local<ArrayBuffer> ab = args[0].As<Uint32Array>()->Buffer();\n+  uint32_t* fields = static_cast<uint32_t*>(ab->GetContents().Data());\n+\n+  fields[0] = (t / NANOS_PER_SEC) >> 32;\n+  fields[1] = (t / NANOS_PER_SEC) & 0xffffffff;\n+  fields[2] = t % NANOS_PER_SEC;\n+}\n+\n+void Kill(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  if (args.Length() != 2)\n+    return env->ThrowError(\"Bad argument.\");\n+\n+  int pid = args[0]->Int32Value();\n+  int sig = args[1]->Int32Value();\n+  int err = uv_kill(pid, sig);\n+  args.GetReturnValue().Set(err);\n+}\n+\n+\n+void MemoryUsage(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  size_t rss;\n+  int err = uv_resident_set_memory(&rss);\n+  if (err)\n+    return env->ThrowUVException(err, \"uv_resident_set_memory\");\n+\n+  Isolate* isolate = env->isolate();\n+  // V8 memory usage\n+  HeapStatistics v8_heap_stats;\n+  isolate->GetHeapStatistics(&v8_heap_stats);\n+\n+  // Get the double array pointer from the Float64Array argument.\n+  CHECK(args[0]->IsFloat64Array());\n+  Local<Float64Array> array = args[0].As<Float64Array>();\n+  CHECK_EQ(array->Length(), 4);\n+  Local<ArrayBuffer> ab = array->Buffer();\n+  double* fields = static_cast<double*>(ab->GetContents().Data());\n+\n+  fields[0] = rss;\n+  fields[1] = v8_heap_stats.total_heap_size();\n+  fields[2] = v8_heap_stats.used_heap_size();\n+  fields[3] = isolate->AdjustAmountOfExternalAllocatedMemory(0);\n+}\n+\n+// Most of the time, it's best to use `console.error` to write\n+// to the process.stderr stream.  However, in some cases, such as\n+// when debugging the stream.Writable class or the process.nextTick\n+// function, it is useful to bypass JavaScript entirely.\n+void RawDebug(const FunctionCallbackInfo<Value>& args) {\n+  CHECK(args.Length() == 1 && args[0]->IsString() &&\n+        \"must be called with a single string\");\n+  Utf8Value message(args.GetIsolate(), args[0]);\n+  PrintErrorString(\"%s\\n\", *message);\n+  fflush(stderr);\n+}\n+\n+void StartProfilerIdleNotifier(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  env->StartProfilerIdleNotifier();\n+}\n+\n+\n+void StopProfilerIdleNotifier(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  env->StopProfilerIdleNotifier();\n+}\n+\n+void Umask(const FunctionCallbackInfo<Value>& args) {\n+  uint32_t old;\n+\n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsUndefined() || args[0]->IsUint32());\n+\n+  if (args[0]->IsUndefined()) {\n+    old = umask(0);\n+    umask(static_cast<mode_t>(old));\n+  } else {\n+    int oct = args[0].As<Uint32>()->Value();\n+    old = umask(static_cast<mode_t>(oct));\n+  }\n+\n+  args.GetReturnValue().Set(old);\n+}\n+\n+void Uptime(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  double uptime;\n+\n+  uv_update_time(env->event_loop());\n+  uptime = uv_now(env->event_loop()) - prog_start_time;\n+\n+  args.GetReturnValue().Set(Number::New(env->isolate(), uptime / 1000));\n+}\n+\n+\n+#if defined(__POSIX__) && !defined(__ANDROID__) && !defined(__CloudABI__)\n+\n+static const uid_t uid_not_found = static_cast<uid_t>(-1);\n+static const gid_t gid_not_found = static_cast<gid_t>(-1);\n+\n+\n+static uid_t uid_by_name(const char* name) {\n+  struct passwd pwd;\n+  struct passwd* pp;\n+  char buf[8192];\n+\n+  errno = 0;\n+  pp = nullptr;\n+\n+  if (getpwnam_r(name, &pwd, buf, sizeof(buf), &pp) == 0 && pp != nullptr)\n+    return pp->pw_uid;\n+\n+  return uid_not_found;\n+}\n+\n+\n+static char* name_by_uid(uid_t uid) {\n+  struct passwd pwd;\n+  struct passwd* pp;\n+  char buf[8192];\n+  int rc;\n+\n+  errno = 0;\n+  pp = nullptr;\n+\n+  if ((rc = getpwuid_r(uid, &pwd, buf, sizeof(buf), &pp)) == 0 &&\n+      pp != nullptr) {\n+    return strdup(pp->pw_name);\n+  }\n+\n+  if (rc == 0)\n+    errno = ENOENT;\n+\n+  return nullptr;\n+}\n+\n+\n+static gid_t gid_by_name(const char* name) {\n+  struct group pwd;\n+  struct group* pp;\n+  char buf[8192];\n+\n+  errno = 0;\n+  pp = nullptr;\n+\n+  if (getgrnam_r(name, &pwd, buf, sizeof(buf), &pp) == 0 && pp != nullptr)\n+    return pp->gr_gid;\n+\n+  return gid_not_found;\n+}\n+\n+\n+#if 0  // For future use.\n+static const char* name_by_gid(gid_t gid) {\n+  struct group pwd;\n+  struct group* pp;\n+  char buf[8192];\n+  int rc;\n+\n+  errno = 0;\n+  pp = nullptr;\n+\n+  if ((rc = getgrgid_r(gid, &pwd, buf, sizeof(buf), &pp)) == 0 &&\n+      pp != nullptr) {\n+    return strdup(pp->gr_name);\n+  }\n+\n+  if (rc == 0)\n+    errno = ENOENT;\n+\n+  return nullptr;\n+}\n+#endif\n+\n+\n+static uid_t uid_by_name(Isolate* isolate, Local<Value> value) {\n+  if (value->IsUint32()) {\n+    return static_cast<uid_t>(value->Uint32Value());\n+  } else {\n+    Utf8Value name(isolate, value);\n+    return uid_by_name(*name);\n+  }\n+}\n+\n+\n+static gid_t gid_by_name(Isolate* isolate, Local<Value> value) {\n+  if (value->IsUint32()) {\n+    return static_cast<gid_t>(value->Uint32Value());\n+  } else {\n+    Utf8Value name(isolate, value);\n+    return gid_by_name(*name);\n+  }\n+}\n+\n+void GetUid(const FunctionCallbackInfo<Value>& args) {\n+  // uid_t is an uint32_t on all supported platforms.\n+  args.GetReturnValue().Set(static_cast<uint32_t>(getuid()));\n+}\n+\n+\n+void GetGid(const FunctionCallbackInfo<Value>& args) {\n+  // gid_t is an uint32_t on all supported platforms.\n+  args.GetReturnValue().Set(static_cast<uint32_t>(getgid()));\n+}\n+\n+\n+void GetEUid(const FunctionCallbackInfo<Value>& args) {\n+  // uid_t is an uint32_t on all supported platforms.\n+  args.GetReturnValue().Set(static_cast<uint32_t>(geteuid()));\n+}\n+\n+\n+void GetEGid(const FunctionCallbackInfo<Value>& args) {\n+  // gid_t is an uint32_t on all supported platforms.\n+  args.GetReturnValue().Set(static_cast<uint32_t>(getegid()));\n+}\n+\n+\n+void SetGid(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n+\n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsUint32() || args[0]->IsString());\n+\n+  gid_t gid = gid_by_name(env->isolate(), args[0]);\n+\n+  if (gid == gid_not_found) {\n+    // Tells JS to throw ERR_INVALID_CREDENTIAL\n+    args.GetReturnValue().Set(1);\n+  } else if (setgid(gid)) {\n+    env->ThrowErrnoException(errno, \"setgid\");\n+  } else {\n+    args.GetReturnValue().Set(0);\n+  }\n+}\n+\n+\n+void SetEGid(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n+\n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsUint32() || args[0]->IsString());\n+\n+  gid_t gid = gid_by_name(env->isolate(), args[0]);\n+\n+  if (gid == gid_not_found) {\n+    // Tells JS to throw ERR_INVALID_CREDENTIAL\n+    args.GetReturnValue().Set(1);\n+  } else if (setegid(gid)) {\n+    env->ThrowErrnoException(errno, \"setegid\");\n+  } else {\n+    args.GetReturnValue().Set(0);\n+  }\n+}\n+\n+\n+void SetUid(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n+\n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsUint32() || args[0]->IsString());\n+\n+  uid_t uid = uid_by_name(env->isolate(), args[0]);\n+\n+  if (uid == uid_not_found) {\n+    // Tells JS to throw ERR_INVALID_CREDENTIAL\n+    args.GetReturnValue().Set(1);\n+  } else if (setuid(uid)) {\n+    env->ThrowErrnoException(errno, \"setuid\");\n+  } else {\n+    args.GetReturnValue().Set(0);\n+  }\n+}\n+\n+\n+void SetEUid(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  CHECK(env->is_main_thread());\n+\n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsUint32() || args[0]->IsString());\n+\n+  uid_t uid = uid_by_name(env->isolate(), args[0]);\n+\n+  if (uid == uid_not_found) {\n+    // Tells JS to throw ERR_INVALID_CREDENTIAL\n+    args.GetReturnValue().Set(1);\n+  } else if (seteuid(uid)) {\n+    env->ThrowErrnoException(errno, \"seteuid\");\n+  } else {\n+    args.GetReturnValue().Set(0);\n+  }\n+}\n+\n+\n+void GetGroups(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  int ngroups = getgroups(0, nullptr);\n+\n+  if (ngroups == -1)\n+    return env->ThrowErrnoException(errno, \"getgroups\");\n+\n+  gid_t* groups = new gid_t[ngroups];\n+\n+  ngroups = getgroups(ngroups, groups);\n+\n+  if (ngroups == -1) {\n+    delete[] groups;\n+    return env->ThrowErrnoException(errno, \"getgroups\");\n+  }\n+\n+  Local<Array> groups_list = Array::New(env->isolate(), ngroups);\n+  bool seen_egid = false;\n+  gid_t egid = getegid();\n+\n+  for (int i = 0; i < ngroups; i++) {\n+    groups_list->Set(i, Integer::New(env->isolate(), groups[i]));\n+    if (groups[i] == egid)\n+      seen_egid = true;\n+  }\n+\n+  delete[] groups;\n+\n+  if (seen_egid == false)\n+    groups_list->Set(ngroups, Integer::New(env->isolate(), egid));\n+\n+  args.GetReturnValue().Set(groups_list);\n+}\n+\n+\n+void SetGroups(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsArray());\n+\n+  Local<Array> groups_list = args[0].As<Array>();\n+  size_t size = groups_list->Length();\n+  gid_t* groups = new gid_t[size];\n+\n+  for (size_t i = 0; i < size; i++) {\n+    gid_t gid = gid_by_name(env->isolate(), groups_list->Get(i));\n+\n+    if (gid == gid_not_found) {\n+      delete[] groups;\n+      // Tells JS to throw ERR_INVALID_CREDENTIAL\n+      args.GetReturnValue().Set(static_cast<uint32_t>(i + 1));\n+      return;\n+    }\n+\n+    groups[i] = gid;\n+  }\n+\n+  int rc = setgroups(size, groups);\n+  delete[] groups;\n+\n+  if (rc == -1)\n+    return env->ThrowErrnoException(errno, \"setgroups\");\n+\n+  args.GetReturnValue().Set(0);\n+}\n+\n+\n+void InitGroups(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  CHECK_EQ(args.Length(), 2);\n+  CHECK(args[0]->IsUint32() || args[0]->IsString());\n+  CHECK(args[1]->IsUint32() || args[1]->IsString());\n+\n+  Utf8Value arg0(env->isolate(), args[0]);\n+  gid_t extra_group;\n+  bool must_free;\n+  char* user;\n+\n+  if (args[0]->IsUint32()) {\n+    user = name_by_uid(args[0]->Uint32Value());\n+    must_free = true;\n+  } else {\n+    user = *arg0;\n+    must_free = false;\n+  }\n+\n+  if (user == nullptr) {\n+    // Tells JS to throw ERR_INVALID_CREDENTIAL\n+    return args.GetReturnValue().Set(1);\n+  }\n+\n+  extra_group = gid_by_name(env->isolate(), args[1]);\n+\n+  if (extra_group == gid_not_found) {\n+    if (must_free)\n+      free(user);\n+    // Tells JS to throw ERR_INVALID_CREDENTIAL\n+    return args.GetReturnValue().Set(2);\n+  }\n+\n+  int rc = initgroups(user, extra_group);\n+\n+  if (must_free)\n+    free(user);\n+\n+  if (rc)\n+    return env->ThrowErrnoException(errno, \"initgroups\");\n+\n+  args.GetReturnValue().Set(0);\n+}\n+\n+#endif  // __POSIX__ && !defined(__ANDROID__) && !defined(__CloudABI__)\n+\n+}  // namespace node"
        }
    ],
    "stats": {
        "total": 1112,
        "additions": 568,
        "deletions": 544
    }
}