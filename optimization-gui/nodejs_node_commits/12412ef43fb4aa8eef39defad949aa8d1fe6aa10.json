{
    "author": "joyeecheung",
    "message": "fs: fix potential segfault in async calls\n\nWhen the async uv_fs_* call errors out synchronously in AsyncDestCall,\nthe after callbacks (e.g. AfterNoArgs) would delete the req_wrap\nin FSReqAfterScope, and AsyncDestCall would set those req_wrap to\nnullptr afterwards. But when it returns to the top-layer bindings,\nthe bindings all call `req_wrap->SetReturnValue()` again without\nchecking if `req_wrap` is nullptr, causing a segfault.\n\nThis has not been caught in any of the tests because we usually do a\nlot of argument checking in the JS layer before invoking the uv_fs_*\nfunctions, so it's rare to get a synchronous error from them.\n\nCurrently we never need the binding to return the wrap to JS layer,\nso we can just call `req_wrap->SetReturnValue()` to return undefined\nfor normal FSReqWrap and the promise for FSReqPromise in AsyncDestCall\ninstead of doing this in the top-level bindings.\n\nPR-URL: https://github.com/nodejs/node/pull/18811\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>",
    "sha": "12412ef43fb4aa8eef39defad949aa8d1fe6aa10",
    "files": [
        {
            "sha": "c9c7570779bcbe398d5ffa6b408ef271eb6af316",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 34,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/12412ef43fb4aa8eef39defad949aa8d1fe6aa10/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/12412ef43fb4aa8eef39defad949aa8d1fe6aa10/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=12412ef43fb4aa8eef39defad949aa8d1fe6aa10",
            "patch": "@@ -516,6 +516,7 @@ class fs_req_wrap {\n   DISALLOW_COPY_AND_ASSIGN(fs_req_wrap);\n };\n \n+// Returns nullptr if the operation fails from the start.\n template <typename Func, typename... Args>\n inline FSReqBase* AsyncDestCall(Environment* env,\n     FSReqBase* req_wrap,\n@@ -530,16 +531,16 @@ inline FSReqBase* AsyncDestCall(Environment* env,\n     uv_fs_t* uv_req = req_wrap->req();\n     uv_req->result = err;\n     uv_req->path = nullptr;\n-    after(uv_req);\n+    after(uv_req);  // after may delete req_wrap if there is an error\n     req_wrap = nullptr;\n+  } else {\n+    req_wrap->SetReturnValue(args);\n   }\n \n-  if (req_wrap != nullptr) {\n-    args.GetReturnValue().Set(req_wrap->persistent());\n-  }\n   return req_wrap;\n }\n \n+// Returns nullptr if the operation fails from the start.\n template <typename Func, typename... Args>\n inline FSReqBase* AsyncCall(Environment* env,\n     FSReqBase* req_wrap,\n@@ -618,7 +619,6 @@ void Access(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {  // access(path, mode, req)\n     AsyncCall(env, req_wrap, args, \"access\", UTF8, AfterNoArgs,\n               uv_fs_access, *path, mode);\n-    req_wrap->SetReturnValue(args);\n   } else {  // access(path, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n     fs_req_wrap req_wrap;\n@@ -640,7 +640,6 @@ void Close(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {  // close(fd, req)\n     AsyncCall(env, req_wrap, args, \"close\", UTF8, AfterNoArgs,\n               uv_fs_close, fd);\n-    req_wrap->SetReturnValue(args);\n   } else {  // close(fd, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req_wrap;\n@@ -749,7 +748,6 @@ static void Stat(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {  // stat(path, req)\n     AsyncCall(env, req_wrap, args, \"stat\", UTF8, AfterStat,\n               uv_fs_stat, *path);\n-    req_wrap->SetReturnValue(args);\n   } else {  // stat(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req_wrap;\n@@ -774,7 +772,6 @@ static void LStat(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {  // lstat(path, req)\n     AsyncCall(env, req_wrap, args, \"lstat\", UTF8, AfterStat,\n               uv_fs_lstat, *path);\n-    req_wrap->SetReturnValue(args);\n   } else {  // lstat(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req_wrap;\n@@ -799,7 +796,6 @@ static void FStat(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {  // fstat(fd, req)\n     AsyncCall(env, req_wrap, args, \"fstat\", UTF8, AfterStat,\n               uv_fs_fstat, fd);\n-    req_wrap->SetReturnValue(args);\n   } else {  // fstat(fd, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req_wrap;\n@@ -853,7 +849,6 @@ static void Link(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {  // link(src, dest, req)\n     AsyncDestCall(env, req_wrap, args, \"link\", *dest, dest.length(), UTF8,\n                   AfterNoArgs, uv_fs_link, *src, *dest);\n-    req_wrap->SetReturnValue(args);\n   } else {  // link(src, dest)\n     CHECK_EQ(argc, 4);\n     fs_req_wrap req;\n@@ -877,7 +872,6 @@ static void ReadLink(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {  // readlink(path, encoding, req)\n     AsyncCall(env, req_wrap, args, \"readlink\", encoding, AfterStringPtr,\n               uv_fs_readlink, *path);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     CHECK_EQ(argc, 4);\n     fs_req_wrap req;\n@@ -918,7 +912,6 @@ static void Rename(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncDestCall(env, req_wrap, args, \"rename\", *new_path, new_path.length(),\n                   UTF8, AfterNoArgs, uv_fs_rename, *old_path, *new_path);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     CHECK_EQ(argc, 4);\n     fs_req_wrap req;\n@@ -942,7 +935,6 @@ static void FTruncate(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"ftruncate\", UTF8, AfterNoArgs,\n               uv_fs_ftruncate, fd, len);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     CHECK_EQ(argc, 4);\n     fs_req_wrap req;\n@@ -963,7 +955,6 @@ static void Fdatasync(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"fdatasync\", UTF8, AfterNoArgs,\n               uv_fs_fdatasync, fd);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req;\n@@ -984,7 +975,6 @@ static void Fsync(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"fsync\", UTF8, AfterNoArgs,\n               uv_fs_fsync, fd);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req;\n@@ -1005,7 +995,6 @@ static void Unlink(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"unlink\", UTF8, AfterNoArgs,\n               uv_fs_unlink, *path);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req;\n@@ -1025,7 +1014,6 @@ static void RMDir(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"rmdir\", UTF8, AfterNoArgs,\n               uv_fs_rmdir, *path);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(rmdir, *path, *path)\n   }\n@@ -1046,7 +1034,6 @@ static void MKDir(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"mkdir\", UTF8, AfterNoArgs,\n               uv_fs_mkdir, *path, mode);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(mkdir, *path, *path, mode)\n   }\n@@ -1064,7 +1051,6 @@ static void RealPath(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"realpath\", encoding, AfterStringPtr,\n               uv_fs_realpath, *path);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(realpath, *path, *path);\n     const char* link_path = static_cast<const char*>(SYNC_REQ.ptr);\n@@ -1096,7 +1082,6 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"scandir\", encoding, AfterScanDir,\n               uv_fs_scandir, *path, 0 /*flags*/);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(scandir, *path, *path, 0 /*flags*/)\n \n@@ -1167,7 +1152,6 @@ static void Open(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"open\", UTF8, AfterInteger,\n               uv_fs_open, *path, flags, mode);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(open, *path, *path, flags, mode)\n     args.GetReturnValue().Set(SYNC_RESULT);\n@@ -1192,7 +1176,6 @@ static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"open\", UTF8, AfterOpenFileHandle,\n               uv_fs_open, *path, flags, mode);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(open, *path, *path, flags, mode)\n     HandleScope scope(env->isolate());\n@@ -1217,7 +1200,6 @@ static void CopyFile(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"copyfile\", UTF8, AfterNoArgs,\n               uv_fs_copyfile, *src, *dest, flags);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_DEST_CALL(copyfile, *src, *dest, *src, *dest, flags)\n   }\n@@ -1260,7 +1242,7 @@ static void WriteBuffer(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"write\", UTF8, AfterInteger,\n               uv_fs_write, fd, &uvbuf, 1, pos);\n-    return req_wrap->SetReturnValue(args);\n+    return;\n   }\n \n   SYNC_CALL(write, nullptr, fd, &uvbuf, 1, pos)\n@@ -1297,7 +1279,7 @@ static void WriteBuffers(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"write\", UTF8, AfterInteger,\n               uv_fs_write, fd, *iovs, iovs.length(), pos);\n-    return req_wrap->SetReturnValue(args);\n+    return;\n   }\n \n   SYNC_CALL(write, nullptr, fd, *iovs, iovs.length(), pos)\n@@ -1365,7 +1347,6 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"write\", UTF8, AfterInteger,\n               uv_fs_write, fd, &uvbuf, 1, pos);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(write, nullptr, fd, &uvbuf, 1, pos)\n     return args.GetReturnValue().Set(SYNC_RESULT);\n@@ -1420,7 +1401,6 @@ static void Read(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"read\", UTF8, AfterInteger,\n               uv_fs_read, fd, &uvbuf, 1, pos);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(read, 0, fd, &uvbuf, 1, pos)\n     args.GetReturnValue().Set(SYNC_RESULT);\n@@ -1446,7 +1426,6 @@ static void Chmod(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"chmod\", UTF8, AfterNoArgs,\n               uv_fs_chmod, *path, mode);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(chmod, *path, *path, mode);\n   }\n@@ -1469,7 +1448,6 @@ static void FChmod(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"fchmod\", UTF8, AfterNoArgs,\n               uv_fs_fchmod, fd, mode);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(fchmod, 0, fd, mode);\n   }\n@@ -1497,7 +1475,6 @@ static void Chown(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"chown\", UTF8, AfterNoArgs,\n               uv_fs_chown, *path, uid, gid);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(chown, *path, *path, uid, gid);\n   }\n@@ -1522,7 +1499,6 @@ static void FChown(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"fchown\", UTF8, AfterNoArgs,\n               uv_fs_fchown, fd, uid, gid);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(fchown, 0, fd, uid, gid);\n   }\n@@ -1546,7 +1522,6 @@ static void UTimes(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"utime\", UTF8, AfterNoArgs,\n               uv_fs_utime, *path, atime, mtime);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(utime, *path, *path, atime, mtime);\n   }\n@@ -1567,7 +1542,6 @@ static void FUTimes(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"futime\", UTF8, AfterNoArgs,\n               uv_fs_futime, fd, atime, mtime);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(futime, 0, fd, atime, mtime);\n   }\n@@ -1587,7 +1561,6 @@ static void Mkdtemp(const FunctionCallbackInfo<Value>& args) {\n   if (req_wrap != nullptr) {\n     AsyncCall(env, req_wrap, args, \"mkdtemp\", encoding, AfterStringPath,\n               uv_fs_mkdtemp, *tmpl);\n-    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(mkdtemp, *tmpl, *tmpl);\n     const char* path = static_cast<const char*>(SYNC_REQ.path);"
        }
    ],
    "stats": {
        "total": 41,
        "additions": 7,
        "deletions": 34
    }
}