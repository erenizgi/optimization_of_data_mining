{
    "author": "danbev",
    "message": "src: refactor GetPeerCertificate\n\nPR-URL: https://github.com/nodejs/node/pull/19087\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "e46d0bc8fcdcd392eeddaa80da583d0432b7a4b8",
    "files": [
        {
            "sha": "bc9b925dbe226f90d2f0d6ed6356571a7abf3131",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 100,
            "deletions": 72,
            "changes": 172,
            "blob_url": "https://github.com/nodejs/node/blob/e46d0bc8fcdcd392eeddaa80da583d0432b7a4b8/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/e46d0bc8fcdcd392eeddaa80da583d0432b7a4b8/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=e46d0bc8fcdcd392eeddaa80da583d0432b7a4b8",
            "patch": "@@ -1988,7 +1988,89 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n }\n \n \n-// TODO(indutny): Split it into multiple smaller functions\n+static Local<Object> AddIssuerChainToObject(X509** cert,\n+                                            Local<Object> object,\n+                                            STACK_OF(X509)* const peer_certs,\n+                                            Environment* const env) {\n+  Local<Context> context = env->isolate()->GetCurrentContext();\n+  *cert = sk_X509_delete(peer_certs, 0);\n+  for (;;) {\n+    int i;\n+    for (i = 0; i < sk_X509_num(peer_certs); i++) {\n+      X509* ca = sk_X509_value(peer_certs, i);\n+      if (X509_check_issued(ca, *cert) != X509_V_OK)\n+        continue;\n+\n+      Local<Object> ca_info = X509ToObject(env, ca);\n+      object->Set(context, env->issuercert_string(), ca_info).FromJust();\n+      object = ca_info;\n+\n+      // NOTE: Intentionally freeing cert that is not used anymore.\n+      X509_free(*cert);\n+\n+      // Delete cert and continue aggregating issuers.\n+      *cert = sk_X509_delete(peer_certs, i);\n+      break;\n+    }\n+\n+    // Issuer not found, break out of the loop.\n+    if (i == sk_X509_num(peer_certs))\n+      break;\n+  }\n+  sk_X509_pop_free(peer_certs, X509_free);\n+  return object;\n+}\n+\n+\n+static bool CloneSSLCerts(X509** cert,\n+                          const STACK_OF(X509)* const ssl_certs,\n+                          STACK_OF(X509)** peer_certs) {\n+  *peer_certs = sk_X509_new(nullptr);\n+  bool result = true;\n+  if (*cert != nullptr)\n+    sk_X509_push(*peer_certs, *cert);\n+  for (int i = 0; i < sk_X509_num(ssl_certs); i++) {\n+    *cert = X509_dup(sk_X509_value(ssl_certs, i));\n+    if (*cert == nullptr) {\n+      result = false;\n+      break;\n+    }\n+    if (!sk_X509_push(*peer_certs, *cert)) {\n+      result = false;\n+      break;\n+    }\n+  }\n+  if (!result) {\n+    sk_X509_pop_free(*peer_certs, X509_free);\n+  }\n+  return result;\n+}\n+\n+\n+static Local<Object> GetLastIssuedCert(X509** cert,\n+                                       const SSL* const ssl,\n+                                       Local<Object> issuer_chain,\n+                                       Environment* const env) {\n+  Local<Context> context = env->isolate()->GetCurrentContext();\n+  while (X509_check_issued(*cert, *cert) != X509_V_OK) {\n+    X509* ca;\n+    if (SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl), *cert, &ca) <= 0)\n+      break;\n+\n+    Local<Object> ca_info = X509ToObject(env, ca);\n+    issuer_chain->Set(context, env->issuercert_string(), ca_info).FromJust();\n+    issuer_chain = ca_info;\n+\n+    // NOTE: Intentionally freeing cert that is not used anymore.\n+    X509_free(*cert);\n+\n+    // Delete cert and continue aggregating issuers.\n+    *cert = ca;\n+  }\n+  return issuer_chain;\n+}\n+\n+\n template <class Base>\n void SSLWrap<Base>::GetPeerCertificate(\n     const FunctionCallbackInfo<Value>& args) {\n@@ -2000,97 +2082,43 @@ void SSLWrap<Base>::GetPeerCertificate(\n   ClearErrorOnReturn clear_error_on_return;\n \n   Local<Object> result;\n-  Local<Object> info;\n+  // Used to build the issuer certificate chain.\n+  Local<Object> issuer_chain;\n \n   // NOTE: This is because of the odd OpenSSL behavior. On client `cert_chain`\n-  // contains the `peer_certificate`, but on server it doesn't\n+  // contains the `peer_certificate`, but on server it doesn't.\n   X509* cert = w->is_server() ? SSL_get_peer_certificate(w->ssl_) : nullptr;\n   STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(w->ssl_);\n   STACK_OF(X509)* peer_certs = nullptr;\n-  if (cert == nullptr && ssl_certs == nullptr)\n+  if (cert == nullptr && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))\n     goto done;\n \n-  if (cert == nullptr && sk_X509_num(ssl_certs) == 0)\n-    goto done;\n-\n-  // Short result requested\n+  // Short result requested.\n   if (args.Length() < 1 || !args[0]->IsTrue()) {\n     result = X509ToObject(env,\n                           cert == nullptr ? sk_X509_value(ssl_certs, 0) : cert);\n     goto done;\n   }\n \n-  // Clone `ssl_certs`, because we are going to destruct it\n-  peer_certs = sk_X509_new(nullptr);\n-  if (cert != nullptr)\n-    sk_X509_push(peer_certs, cert);\n-  for (int i = 0; i < sk_X509_num(ssl_certs); i++) {\n-    cert = X509_dup(sk_X509_value(ssl_certs, i));\n-    if (cert == nullptr)\n-      goto done;\n-    if (!sk_X509_push(peer_certs, cert))\n-      goto done;\n-  }\n-\n-  // First and main certificate\n-  cert = sk_X509_value(peer_certs, 0);\n-  result = X509ToObject(env, cert);\n-  info = result;\n-\n-  // Put issuer inside the object\n-  cert = sk_X509_delete(peer_certs, 0);\n-  while (sk_X509_num(peer_certs) > 0) {\n-    int i;\n-    for (i = 0; i < sk_X509_num(peer_certs); i++) {\n-      X509* ca = sk_X509_value(peer_certs, i);\n-      if (X509_check_issued(ca, cert) != X509_V_OK)\n-        continue;\n-\n-      Local<Object> ca_info = X509ToObject(env, ca);\n-      info->Set(context, env->issuercert_string(), ca_info).FromJust();\n-      info = ca_info;\n-\n-      // NOTE: Intentionally freeing cert that is not used anymore\n-      X509_free(cert);\n-\n-      // Delete cert and continue aggregating issuers\n-      cert = sk_X509_delete(peer_certs, i);\n-      break;\n-    }\n-\n-    // Issuer not found, break out of the loop\n-    if (i == sk_X509_num(peer_certs))\n-      break;\n-  }\n-\n-  // Last certificate should be self-signed\n-  while (X509_check_issued(cert, cert) != X509_V_OK) {\n-    X509* ca;\n-    if (SSL_CTX_get_issuer(SSL_get_SSL_CTX(w->ssl_), cert, &ca) <= 0)\n-      break;\n-\n-    Local<Object> ca_info = X509ToObject(env, ca);\n-    info->Set(context, env->issuercert_string(), ca_info).FromJust();\n-    info = ca_info;\n+  if (CloneSSLCerts(&cert, ssl_certs, &peer_certs)) {\n+    // First and main certificate.\n+    cert = sk_X509_value(peer_certs, 0);\n+    result = X509ToObject(env, cert);\n \n-    // NOTE: Intentionally freeing cert that is not used anymore\n-    X509_free(cert);\n+    issuer_chain = AddIssuerChainToObject(&cert, result, peer_certs, env);\n+    issuer_chain = GetLastIssuedCert(&cert, w->ssl_, issuer_chain, env);\n+    // Last certificate should be self-signed.\n+    if (X509_check_issued(cert, cert) == X509_V_OK)\n+      issuer_chain->Set(env->context(),\n+                        env->issuercert_string(),\n+                        issuer_chain).FromJust();\n \n-    // Delete cert and continue aggregating issuers\n-    cert = ca;\n+    CHECK_NE(cert, nullptr);\n   }\n \n-  // Self-issued certificate\n-  if (X509_check_issued(cert, cert) == X509_V_OK)\n-    info->Set(context, env->issuercert_string(), info).FromJust();\n-\n-  CHECK_NE(cert, nullptr);\n-\n  done:\n   if (cert != nullptr)\n     X509_free(cert);\n-  if (peer_certs != nullptr)\n-    sk_X509_pop_free(peer_certs, X509_free);\n   if (result.IsEmpty())\n     result = Object::New(env->isolate());\n   args.GetReturnValue().Set(result);"
        }
    ],
    "stats": {
        "total": 172,
        "additions": 100,
        "deletions": 72
    }
}