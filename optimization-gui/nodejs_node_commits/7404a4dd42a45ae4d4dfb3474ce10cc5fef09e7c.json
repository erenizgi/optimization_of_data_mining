{
    "author": "unknown",
    "message": "inspector: tie objects lifetime to the thread they belong to\n\nPR-URL: https://github.com/nodejs/node/pull/22242\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Aleksei Koziatinskii <ak239spb@gmail.com>",
    "sha": "7404a4dd42a45ae4d4dfb3474ce10cc5fef09e7c",
    "files": [
        {
            "sha": "d8ee737ce2fce01f4331edc4d2658298a087aaf9",
            "filename": "src/inspector/main_thread_interface.cc",
            "status": "modified",
            "additions": 123,
            "deletions": 62,
            "changes": 185,
            "blob_url": "https://github.com/nodejs/node/blob/7404a4dd42a45ae4d4dfb3474ce10cc5fef09e7c/src%2Finspector%2Fmain_thread_interface.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7404a4dd42a45ae4d4dfb3474ce10cc5fef09e7c/src%2Finspector%2Fmain_thread_interface.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fmain_thread_interface.cc?ref=7404a4dd42a45ae4d4dfb3474ce10cc5fef09e7c",
            "patch": "@@ -3,6 +3,7 @@\n #include \"node_mutex.h\"\n #include \"v8-inspector.h\"\n \n+#include <functional>\n #include <unicode/unistr.h>\n \n namespace node {\n@@ -13,56 +14,72 @@ using v8_inspector::StringView;\n using v8_inspector::StringBuffer;\n \n template <typename T>\n-class DeleteRequest : public Request {\n+class DeletableWrapper : public Deletable {\n  public:\n-  explicit DeleteRequest(T* object) : object_(object) {}\n-  void Call() override {\n-    delete object_;\n+  explicit DeletableWrapper(std::unique_ptr<T> object)\n+                        : object_(std::move(object)) {}\n+  ~DeletableWrapper() override = default;\n+\n+  static T* get(MainThreadInterface* thread, int id) {\n+    return\n+        static_cast<DeletableWrapper<T>*>(thread->GetObject(id))->object_.get();\n   }\n \n  private:\n-  T* object_;\n+  std::unique_ptr<T> object_;\n };\n \n-template <typename Target, typename Arg>\n-class SingleArgumentFunctionCall : public Request {\n- public:\n-  using Fn = void (Target::*)(Arg);\n+template <typename T>\n+std::unique_ptr<Deletable> WrapInDeletable(std::unique_ptr<T> object) {\n+  return std::unique_ptr<DeletableWrapper<T>>(\n+      new DeletableWrapper<T>(std::move(object)));\n+}\n \n-  SingleArgumentFunctionCall(Target* target, Fn fn, Arg argument)\n-                             : target_(target),\n-                               fn_(fn),\n-                               arg_(std::move(argument)) {}\n+template <typename Factory>\n+class CreateObjectRequest : public Request {\n+ public:\n+  CreateObjectRequest(int object_id, Factory factory)\n+                      : object_id_(object_id), factory_(std::move(factory)) {}\n \n-  void Call() override {\n-    Apply(target_, fn_, std::move(arg_));\n+  void Call(MainThreadInterface* thread) {\n+    thread->AddObject(object_id_, WrapInDeletable(factory_(thread)));\n   }\n \n  private:\n-  template <typename Element>\n-  void Apply(Element* target, Fn fn, Arg arg) {\n-    (target->*fn)(std::move(arg));\n+  int object_id_;\n+  Factory factory_;\n+};\n+\n+template <typename Factory>\n+std::unique_ptr<Request> NewCreateRequest(int object_id, Factory factory) {\n+  return std::unique_ptr<Request>(\n+      new CreateObjectRequest<Factory>(object_id, std::move(factory)));\n+}\n+\n+class DeleteRequest : public Request {\n+ public:\n+  explicit DeleteRequest(int object_id) : object_id_(object_id) {}\n+\n+  void Call(MainThreadInterface* thread) override {\n+    thread->RemoveObject(object_id_);\n   }\n \n-  Target* target_;\n-  Fn fn_;\n-  Arg arg_;\n+ private:\n+  int object_id_;\n };\n \n-class PostMessageRequest : public Request {\n+template <typename Target, typename Fn>\n+class CallRequest : public Request {\n  public:\n-  PostMessageRequest(InspectorSessionDelegate* delegate,\n-                     StringView message)\n-                     : delegate_(delegate),\n-                       message_(StringBuffer::create(message)) {}\n+  CallRequest(int id, Fn fn) : id_(id), fn_(std::move(fn)) {}\n \n-  void Call() override {\n-    delegate_->SendMessageToFrontend(message_->string());\n+  void Call(MainThreadInterface* thread) override {\n+    fn_(DeletableWrapper<Target>::get(thread, id_));\n   }\n \n  private:\n-  InspectorSessionDelegate* delegate_;\n-  std::unique_ptr<StringBuffer> message_;\n+  int id_;\n+  Fn fn_;\n };\n \n class DispatchMessagesTask : public v8::Task {\n@@ -88,45 +105,63 @@ void DisposePairCallback(uv_handle_t* ref) {\n template <typename T>\n class AnotherThreadObjectReference {\n  public:\n-  // We create it on whatever thread, just make sure it gets disposed on the\n-  // proper thread.\n-  AnotherThreadObjectReference(std::shared_ptr<MainThreadHandle> thread,\n-                               T* object)\n-                               : thread_(thread), object_(object) {\n+  AnotherThreadObjectReference(\n+      std::shared_ptr<MainThreadHandle> thread, int object_id)\n+      : thread_(thread), object_id_(object_id) {}\n+\n+  template <typename Factory>\n+  AnotherThreadObjectReference(\n+      std::shared_ptr<MainThreadHandle> thread, Factory factory)\n+      : AnotherThreadObjectReference(thread, thread->newObjectId()) {\n+    thread_->Post(NewCreateRequest(object_id_, std::move(factory)));\n   }\n   AnotherThreadObjectReference(AnotherThreadObjectReference&) = delete;\n \n   ~AnotherThreadObjectReference() {\n     // Disappearing thread may cause a memory leak\n-    CHECK(thread_->Post(\n-        std::unique_ptr<DeleteRequest<T>>(new DeleteRequest<T>(object_))));\n-    object_ = nullptr;\n+    thread_->Post(\n+        std::unique_ptr<DeleteRequest>(new DeleteRequest(object_id_)));\n   }\n \n-  template <typename Fn, typename Arg>\n-  void Post(Fn fn, Arg argument) const {\n-    using R = SingleArgumentFunctionCall<T, Arg>;\n-    thread_->Post(std::unique_ptr<R>(new R(object_, fn, std::move(argument))));\n+  template <typename Fn>\n+  void Call(Fn fn) const {\n+    using Request = CallRequest<T, Fn>;\n+    thread_->Post(std::unique_ptr<Request>(\n+        new Request(object_id_, std::move(fn))));\n   }\n \n-  T* get() const {\n-    return object_;\n+  template <typename Arg>\n+  void Call(void (T::*fn)(Arg), Arg argument) const {\n+    Call(std::bind(Apply<Arg>, std::placeholders::_1, fn, std::move(argument)));\n   }\n \n  private:\n+  // This has to use non-const reference to support std::bind with non-copyable\n+  // types\n+  template <typename Argument>\n+  static void Apply(T* target, void (T::*fn)(Argument),\n+    /* NOLINT (runtime/references) */ Argument& argument) {\n+    (target->*fn)(std::move(argument));\n+  }\n+\n   std::shared_ptr<MainThreadHandle> thread_;\n-  T* object_;\n+  const int object_id_;\n };\n \n class MainThreadSessionState {\n  public:\n-  MainThreadSessionState(\n-      std::shared_ptr<MainThreadHandle> thread,\n-      bool prevent_shutdown) : thread_(thread),\n-                               prevent_shutdown_(prevent_shutdown) {}\n+  MainThreadSessionState(MainThreadInterface* thread, bool prevent_shutdown)\n+                         : thread_(thread),\n+                           prevent_shutdown_(prevent_shutdown) {}\n+\n+  static std::unique_ptr<MainThreadSessionState> Create(\n+      MainThreadInterface* thread, bool prevent_shutdown) {\n+    return std::unique_ptr<MainThreadSessionState>(\n+        new MainThreadSessionState(thread, prevent_shutdown));\n+  }\n \n   void Connect(std::unique_ptr<InspectorSessionDelegate> delegate) {\n-    Agent* agent = thread_->GetInspectorAgent();\n+    Agent* agent = thread_->inspector_agent();\n     if (agent != nullptr)\n       session_ = agent->Connect(std::move(delegate), prevent_shutdown_);\n   }\n@@ -136,7 +171,7 @@ class MainThreadSessionState {\n   }\n \n  private:\n-  std::shared_ptr<MainThreadHandle> thread_;\n+  MainThreadInterface* thread_;\n   bool prevent_shutdown_;\n   std::unique_ptr<InspectorSession> session_;\n };\n@@ -148,12 +183,14 @@ class CrossThreadInspectorSession : public InspectorSession {\n       std::shared_ptr<MainThreadHandle> thread,\n       std::unique_ptr<InspectorSessionDelegate> delegate,\n       bool prevent_shutdown)\n-      : state_(thread, new MainThreadSessionState(thread, prevent_shutdown)) {\n-    state_.Post(&MainThreadSessionState::Connect, std::move(delegate));\n+      : state_(thread, std::bind(MainThreadSessionState::Create,\n+                                 std::placeholders::_1,\n+                                 prevent_shutdown)) {\n+    state_.Call(&MainThreadSessionState::Connect, std::move(delegate));\n   }\n \n   void Dispatch(const StringView& message) override {\n-    state_.Post(&MainThreadSessionState::Dispatch,\n+    state_.Call(&MainThreadSessionState::Dispatch,\n                 StringBuffer::create(message));\n   }\n \n@@ -163,13 +200,15 @@ class CrossThreadInspectorSession : public InspectorSession {\n \n class ThreadSafeDelegate : public InspectorSessionDelegate {\n  public:\n-  ThreadSafeDelegate(std::shared_ptr<MainThreadHandle> thread,\n-                     std::unique_ptr<InspectorSessionDelegate> delegate)\n-                     : thread_(thread), delegate_(thread, delegate.release()) {}\n+  ThreadSafeDelegate(std::shared_ptr<MainThreadHandle> thread, int object_id)\n+                     : thread_(thread), delegate_(thread, object_id) {}\n \n   void SendMessageToFrontend(const v8_inspector::StringView& message) override {\n-    thread_->Post(std::unique_ptr<Request>(\n-        new PostMessageRequest(delegate_.get(), message)));\n+    delegate_.Call(\n+        [m = StringBuffer::create(message)]\n+        (InspectorSessionDelegate* delegate) {\n+      delegate->SendMessageToFrontend(m->string());\n+    });\n   }\n \n  private:\n@@ -252,7 +291,7 @@ void MainThreadInterface::DispatchMessages() {\n       MessageQueue::value_type task;\n       std::swap(dispatching_message_queue_.front(), task);\n       dispatching_message_queue_.pop_front();\n-      task->Call();\n+      task->Call(this);\n     }\n   } while (had_messages);\n   dispatching_messages_ = false;\n@@ -264,6 +303,26 @@ std::shared_ptr<MainThreadHandle> MainThreadInterface::GetHandle() {\n   return handle_;\n }\n \n+void MainThreadInterface::AddObject(int id,\n+                                    std::unique_ptr<Deletable> object) {\n+  CHECK_NE(nullptr, object);\n+  managed_objects_[id] = std::move(object);\n+}\n+\n+void MainThreadInterface::RemoveObject(int id) {\n+  CHECK_EQ(1, managed_objects_.erase(id));\n+}\n+\n+Deletable* MainThreadInterface::GetObject(int id) {\n+  auto iterator = managed_objects_.find(id);\n+  // This would mean the object is requested after it was disposed, which is\n+  // a coding error.\n+  CHECK_NE(managed_objects_.end(), iterator);\n+  Deletable* pointer = iterator->second.get();\n+  CHECK_NE(nullptr, pointer);\n+  return pointer;\n+}\n+\n std::unique_ptr<StringBuffer> Utf8ToStringView(const std::string& message) {\n   icu::UnicodeString utf16 = icu::UnicodeString::fromUTF8(\n       icu::StringPiece(message.data(), message.length()));\n@@ -303,10 +362,12 @@ Agent* MainThreadHandle::GetInspectorAgent() {\n }\n \n std::unique_ptr<InspectorSessionDelegate>\n-MainThreadHandle::MakeThreadSafeDelegate(\n+MainThreadHandle::MakeDelegateThreadSafe(\n     std::unique_ptr<InspectorSessionDelegate> delegate) {\n+  int id = newObjectId();\n+  main_thread_->AddObject(id, WrapInDeletable(std::move(delegate)));\n   return std::unique_ptr<InspectorSessionDelegate>(\n-      new ThreadSafeDelegate(shared_from_this(), std::move(delegate)));\n+      new ThreadSafeDelegate(shared_from_this(), id));\n }\n \n bool MainThreadHandle::Expired() {"
        },
        {
            "sha": "db79db43821a89d5f876aaa43212faab13dcc72f",
            "filename": "src/inspector/main_thread_interface.h",
            "status": "modified",
            "additions": 20,
            "deletions": 5,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/7404a4dd42a45ae4d4dfb3474ce10cc5fef09e7c/src%2Finspector%2Fmain_thread_interface.h",
            "raw_url": "https://github.com/nodejs/node/raw/7404a4dd42a45ae4d4dfb3474ce10cc5fef09e7c/src%2Finspector%2Fmain_thread_interface.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fmain_thread_interface.h?ref=7404a4dd42a45ae4d4dfb3474ce10cc5fef09e7c",
            "patch": "@@ -9,10 +9,10 @@\n #include \"inspector_agent.h\"\n #include \"node_mutex.h\"\n \n+#include <atomic>\n #include <deque>\n #include <memory>\n #include <unordered_map>\n-#include <unordered_set>\n \n namespace v8_inspector {\n class StringBuffer;\n@@ -21,31 +21,41 @@ class StringView;\n \n namespace node {\n namespace inspector {\n+class MainThreadInterface;\n+\n class Request {\n  public:\n-  virtual void Call() = 0;\n+  virtual void Call(MainThreadInterface*) = 0;\n   virtual ~Request() {}\n };\n \n+class Deletable {\n+ public:\n+  virtual ~Deletable() {}\n+};\n+\n std::unique_ptr<v8_inspector::StringBuffer> Utf8ToStringView(\n     const std::string& message);\n \n using MessageQueue = std::deque<std::unique_ptr<Request>>;\n-class MainThreadInterface;\n \n class MainThreadHandle : public std::enable_shared_from_this<MainThreadHandle> {\n  public:\n   explicit MainThreadHandle(MainThreadInterface* main_thread)\n-                            : main_thread_(main_thread) {}\n+                            : main_thread_(main_thread) {\n+  }\n   ~MainThreadHandle() {\n     CHECK_NULL(main_thread_);  // main_thread_ should have called Reset\n   }\n   std::unique_ptr<InspectorSession> Connect(\n       std::unique_ptr<InspectorSessionDelegate> delegate,\n       bool prevent_shutdown);\n+  int newObjectId() {\n+    return ++next_object_id_;\n+  }\n   bool Post(std::unique_ptr<Request> request);\n   Agent* GetInspectorAgent();\n-  std::unique_ptr<InspectorSessionDelegate> MakeThreadSafeDelegate(\n+  std::unique_ptr<InspectorSessionDelegate> MakeDelegateThreadSafe(\n       std::unique_ptr<InspectorSessionDelegate> delegate);\n   bool Expired();\n \n@@ -55,6 +65,7 @@ class MainThreadHandle : public std::enable_shared_from_this<MainThreadHandle> {\n   MainThreadInterface* main_thread_;\n   Mutex block_lock_;\n   int next_session_id_ = 0;\n+  std::atomic_int next_object_id_ = {1};\n \n   friend class MainThreadInterface;\n };\n@@ -72,6 +83,9 @@ class MainThreadInterface {\n   Agent* inspector_agent() {\n     return agent_;\n   }\n+  void AddObject(int handle, std::unique_ptr<Deletable> object);\n+  Deletable* GetObject(int id);\n+  void RemoveObject(int handle);\n \n  private:\n   using AsyncAndInterface = std::pair<uv_async_t, MainThreadInterface*>;\n@@ -92,6 +106,7 @@ class MainThreadInterface {\n   v8::Platform* const platform_;\n   DeleteFnPtr<AsyncAndInterface, CloseAsync> main_thread_request_;\n   std::shared_ptr<MainThreadHandle> handle_;\n+  std::unordered_map<int, std::unique_ptr<Deletable>> managed_objects_;\n };\n \n }  // namespace inspector"
        }
    ],
    "stats": {
        "total": 210,
        "additions": 143,
        "deletions": 67
    }
}