{
    "author": "BridgeAR",
    "message": "util: improve inspect performance\n\nThis significantly improves the inspection performance for all array\ntypes. From now on only the visible elements cause work instead of\nhaving to process all array keys no matter how many entries are\nvisible.\n\nThis also moves some code out of the main function to reduce the\noverall function complexity.\n\nPR-URL: https://github.com/nodejs/node/pull/22503\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342",
    "files": [
        {
            "sha": "35bd9ec46f5b6f80e0be1f59c02470bc354c93a0",
            "filename": "lib/util.js",
            "status": "modified",
            "additions": 222,
            "deletions": 241,
            "changes": 463,
            "blob_url": "https://github.com/nodejs/node/blob/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/lib%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/lib%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Futil.js?ref=12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342",
            "patch": "@@ -33,11 +33,16 @@ const { isBuffer } = require('buffer').Buffer;\n \n const { internalBinding } = require('internal/bootstrap/loaders');\n const {\n+  getOwnNonIndexProperties,\n   getPromiseDetails,\n   getProxyDetails,\n   kPending,\n   kRejected,\n-  previewEntries\n+  previewEntries,\n+  propertyFilter: {\n+    ALL_PROPERTIES,\n+    ONLY_ENUMERABLE\n+  }\n } = internalBinding('util');\n \n const types = internalBinding('types');\n@@ -46,6 +51,7 @@ const {\n   isAnyArrayBuffer,\n   isArrayBuffer,\n   isArgumentsObject,\n+  isBoxedPrimitive,\n   isDataView,\n   isExternal,\n   isMap,\n@@ -61,7 +67,6 @@ const {\n   isStringObject,\n   isNumberObject,\n   isBooleanObject,\n-  isSymbolObject,\n   isBigIntObject,\n   isUint8Array,\n   isUint8ClampedArray,\n@@ -97,6 +102,10 @@ const inspectDefaultOptions = Object.seal({\n   compact: true\n });\n \n+const kObjectType = 0;\n+const kArrayType = 1;\n+const kArrayExtrasType = 2;\n+\n const ReflectApply = Reflect.apply;\n \n // This function is borrowed from the function with the same name on V8 Extras'\n@@ -122,6 +131,7 @@ const stringValueOf = uncurryThis(String.prototype.valueOf);\n const setValues = uncurryThis(Set.prototype.values);\n const mapEntries = uncurryThis(Map.prototype.entries);\n const dateGetTime = uncurryThis(Date.prototype.getTime);\n+const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n \n let CIRCULAR_ERROR_MESSAGE;\n let internalDeepEqual;\n@@ -475,10 +485,15 @@ function stylizeWithColor(str, styleType) {\n   return str;\n }\n \n-function stylizeNoColor(str, styleType) {\n+function stylizeNoColor(str) {\n   return str;\n }\n \n+// Return a new empty array to push in the results of the default formatter.\n+function getEmptyFormatArray() {\n+  return [];\n+}\n+\n function getConstructorName(obj) {\n   while (obj) {\n     const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n@@ -511,6 +526,56 @@ function getPrefix(constructor, tag, fallback) {\n   return '';\n }\n \n+const getBoxedValue = formatPrimitive.bind(null, stylizeNoColor);\n+\n+// Look up the keys of the object.\n+function getKeys(value, showHidden) {\n+  let keys;\n+  const symbols = Object.getOwnPropertySymbols(value);\n+  if (showHidden) {\n+    keys = Object.getOwnPropertyNames(value);\n+    if (symbols.length !== 0)\n+      keys.push(...symbols);\n+  } else {\n+    // This might throw if `value` is a Module Namespace Object from an\n+    // unevaluated module, but we don't want to perform the actual type\n+    // check because it's expensive.\n+    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n+    // and modify this logic as needed.\n+    try {\n+      keys = Object.keys(value);\n+    } catch (err) {\n+      if (types.isNativeError(err) &&\n+          err.name === 'ReferenceError' &&\n+          types.isModuleNamespaceObject(value)) {\n+        keys = Object.getOwnPropertyNames(value);\n+      } else {\n+        throw err;\n+      }\n+    }\n+    if (symbols.length !== 0) {\n+      keys.push(...symbols.filter((key) => propertyIsEnumerable(value, key)));\n+    }\n+  }\n+  return keys;\n+}\n+\n+function formatProxy(ctx, proxy, recurseTimes) {\n+  if (recurseTimes != null) {\n+    if (recurseTimes < 0)\n+      return ctx.stylize('Proxy [Array]', 'special');\n+    recurseTimes -= 1;\n+  }\n+  ctx.indentationLvl += 2;\n+  const res = [\n+    formatValue(ctx, proxy[0], recurseTimes),\n+    formatValue(ctx, proxy[1], recurseTimes)\n+  ];\n+  ctx.indentationLvl -= 2;\n+  const str = reduceToSingleString(ctx, res, '', ['[', ']']);\n+  return `Proxy ${str}`;\n+}\n+\n function findTypedConstructor(value) {\n   for (const [check, clazz] of [\n     [isUint8Array, Uint8Array],\n@@ -531,8 +596,6 @@ function findTypedConstructor(value) {\n   }\n }\n \n-const getBoxedValue = formatPrimitive.bind(null, stylizeNoColor);\n-\n function noPrototypeIterator(ctx, value, recurseTimes) {\n   let newVal;\n   // TODO: Create a Subclass in case there's no prototype and show\n@@ -571,19 +634,7 @@ function formatValue(ctx, value, recurseTimes) {\n   if (ctx.showProxy) {\n     const proxy = getProxyDetails(value);\n     if (proxy !== undefined) {\n-      if (recurseTimes != null) {\n-        if (recurseTimes < 0)\n-          return ctx.stylize('Proxy [Array]', 'special');\n-        recurseTimes -= 1;\n-      }\n-      ctx.indentationLvl += 2;\n-      const res = [\n-        formatValue(ctx, proxy[0], recurseTimes),\n-        formatValue(ctx, proxy[1], recurseTimes)\n-      ];\n-      ctx.indentationLvl -= 2;\n-      const str = reduceToSingleString(ctx, res, '', ['[', ']']);\n-      return `Proxy ${str}`;\n+      return formatProxy(ctx, proxy, recurseTimes);\n     }\n   }\n \n@@ -614,113 +665,101 @@ function formatValue(ctx, value, recurseTimes) {\n   if (ctx.seen.indexOf(value) !== -1)\n     return ctx.stylize('[Circular]', 'special');\n \n-  let keys;\n-  let symbols = Object.getOwnPropertySymbols(value);\n-\n-  // Look up the keys of the object.\n-  if (ctx.showHidden) {\n-    keys = Object.getOwnPropertyNames(value);\n-  } else {\n-    // This might throw if `value` is a Module Namespace Object from an\n-    // unevaluated module, but we don't want to perform the actual type\n-    // check because it's expensive.\n-    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n-    // and modify this logic as needed.\n-    try {\n-      keys = Object.keys(value);\n-    } catch (err) {\n-      if (types.isNativeError(err) &&\n-          err.name === 'ReferenceError' &&\n-          types.isModuleNamespaceObject(value)) {\n-        keys = Object.getOwnPropertyNames(value);\n-      } else {\n-        throw err;\n-      }\n-    }\n-\n-    if (symbols.length !== 0)\n-      symbols = symbols.filter((key) => propertyIsEnumerable(value, key));\n-  }\n+  return formatRaw(ctx, value, recurseTimes);\n+}\n \n-  const keyLength = keys.length + symbols.length;\n+function formatRaw(ctx, value, recurseTimes) {\n+  let keys;\n \n   const constructor = getConstructorName(value);\n   let tag = value[Symbol.toStringTag];\n   if (typeof tag !== 'string')\n     tag = '';\n   let base = '';\n-  let formatter = formatObject;\n+  let formatter = getEmptyFormatArray;\n   let braces;\n   let noIterator = true;\n-  let extra;\n   let i = 0;\n+  let skip = false;\n+  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n+\n+  let extrasType = kObjectType;\n \n   // Iterators and the rest are split to reduce checks\n   if (value[Symbol.iterator]) {\n     noIterator = false;\n     if (Array.isArray(value)) {\n+      keys = getOwnNonIndexProperties(value, filter);\n       // Only set the constructor for non ordinary (\"Array [...]\") arrays.\n       const prefix = getPrefix(constructor, tag);\n       braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];\n-      if (value.length === 0 && keyLength === 0)\n+      if (value.length === 0 && keys.length === 0)\n         return `${braces[0]}]`;\n+      extrasType = kArrayExtrasType;\n       formatter = formatArray;\n     } else if (isSet(value)) {\n+      keys = getKeys(value, ctx.showHidden);\n       const prefix = getPrefix(constructor, tag);\n-      if (value.size === 0 && keyLength === 0)\n+      if (value.size === 0 && keys.length === 0)\n         return `${prefix}{}`;\n       braces = [`${prefix}{`, '}'];\n       formatter = formatSet;\n     } else if (isMap(value)) {\n+      keys = getKeys(value, ctx.showHidden);\n       const prefix = getPrefix(constructor, tag);\n-      if (value.size === 0 && keyLength === 0)\n+      if (value.size === 0 && keys.length === 0)\n         return `${prefix}{}`;\n       braces = [`${prefix}{`, '}'];\n       formatter = formatMap;\n     } else if (isTypedArray(value)) {\n+      keys = getOwnNonIndexProperties(value, filter);\n       braces = [`${getPrefix(constructor, tag)}[`, ']'];\n-      if (value.length === 0 && keyLength === 0 && !ctx.showHidden)\n+      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n         return `${braces[0]}]`;\n       formatter = formatTypedArray;\n+      extrasType = kArrayExtrasType;\n     } else if (isMapIterator(value)) {\n+      keys = getKeys(value, ctx.showHidden);\n       braces = [`[${tag}] {`, '}'];\n       formatter = formatMapIterator;\n     } else if (isSetIterator(value)) {\n+      keys = getKeys(value, ctx.showHidden);\n       braces = [`[${tag}] {`, '}'];\n       formatter = formatSetIterator;\n     } else {\n       noIterator = true;\n     }\n   }\n   if (noIterator) {\n+    keys = getKeys(value, ctx.showHidden);\n     braces = ['{', '}'];\n     if (constructor === 'Object') {\n       if (isArgumentsObject(value)) {\n-        if (keyLength === 0)\n+        if (keys.length === 0)\n           return '[Arguments] {}';\n         braces[0] = '[Arguments] {';\n       } else if (tag !== '') {\n         braces[0] = `${getPrefix(constructor, tag)}{`;\n-        if (keyLength === 0) {\n+        if (keys.length === 0) {\n           return `${braces[0]}}`;\n         }\n-      } else if (keyLength === 0) {\n+      } else if (keys.length === 0) {\n         return '{}';\n       }\n     } else if (typeof value === 'function') {\n       const type = constructor || tag || 'Function';\n       const name = `${type}${value.name ? `: ${value.name}` : ''}`;\n-      if (keyLength === 0)\n+      if (keys.length === 0)\n         return ctx.stylize(`[${name}]`, 'special');\n       base = `[${name}]`;\n     } else if (isRegExp(value)) {\n       // Make RegExps say that they are RegExps\n-      if (keyLength === 0 || recurseTimes < 0)\n+      if (keys.length === 0 || recurseTimes < 0)\n         return ctx.stylize(regExpToString(value), 'regexp');\n       base = `${regExpToString(value)}`;\n     } else if (isDate(value)) {\n       // Make dates with properties first say the date\n-      if (keyLength === 0) {\n+      if (keys.length === 0) {\n         if (Number.isNaN(dateGetTime(value)))\n           return ctx.stylize(String(value), 'date');\n         return ctx.stylize(dateToISOString(value), 'date');\n@@ -739,22 +778,22 @@ function formatValue(ctx, value, recurseTimes) {\n         const indentation = ' '.repeat(ctx.indentationLvl);\n         base = formatError(value).replace(/\\n/g, `\\n${indentation}`);\n       }\n-      if (keyLength === 0)\n+      if (keys.length === 0)\n         return base;\n \n       if (ctx.compact === false && stackStart !== -1) {\n         braces[0] += `${base.slice(stackStart)}`;\n         base = `[${base.slice(0, stackStart)}]`;\n       }\n     } else if (isAnyArrayBuffer(value)) {\n-      // Fast path for ArrayBuffer and SharedArrayBuffer.\n-      // Can't do the same for DataView because it has a non-primitive\n-      // .buffer property that we need to recurse for.\n       let prefix = getPrefix(constructor, tag);\n       if (prefix === '') {\n         prefix = isArrayBuffer(value) ? 'ArrayBuffer ' : 'SharedArrayBuffer ';\n       }\n-      if (keyLength === 0)\n+      // Fast path for ArrayBuffer and SharedArrayBuffer.\n+      // Can't do the same for DataView because it has a non-primitive\n+      // .buffer property that we need to recurse for.\n+      if (keys.length === 0)\n         return prefix +\n               `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n       braces[0] = `${prefix}{`;\n@@ -768,50 +807,42 @@ function formatValue(ctx, value, recurseTimes) {\n       formatter = formatPromise;\n     } else if (isWeakSet(value)) {\n       braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;\n-      if (ctx.showHidden) {\n-        formatter = formatWeakSet;\n-      } else {\n-        extra = ctx.stylize('<items unknown>', 'special');\n-      }\n+      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n     } else if (isWeakMap(value)) {\n       braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;\n-      if (ctx.showHidden) {\n-        formatter = formatWeakMap;\n-      } else {\n-        extra = ctx.stylize('<items unknown>', 'special');\n-      }\n+      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n     } else if (types.isModuleNamespaceObject(value)) {\n       braces[0] = `[${tag}] {`;\n       formatter = formatNamespaceObject;\n-    } else if (isNumberObject(value)) {\n-      base = `[Number: ${getBoxedValue(numberValueOf(value))}]`;\n-      if (keyLength === 0)\n-        return ctx.stylize(base, 'number');\n-    } else if (isBooleanObject(value)) {\n-      base = `[Boolean: ${getBoxedValue(booleanValueOf(value))}]`;\n-      if (keyLength === 0)\n-        return ctx.stylize(base, 'boolean');\n-    } else if (isBigIntObject(value)) {\n-      base = `[BigInt: ${getBoxedValue(bigIntValueOf(value))}]`;\n-      if (keyLength === 0)\n-        return ctx.stylize(base, 'bigint');\n-    } else if (isSymbolObject(value)) {\n-      base = `[Symbol: ${getBoxedValue(symbolValueOf(value))}]`;\n-      if (keyLength === 0)\n-        return ctx.stylize(base, 'symbol');\n-    } else if (isStringObject(value)) {\n-      const raw = stringValueOf(value);\n-      base = `[String: ${getBoxedValue(raw, ctx)}]`;\n-      if (keyLength === raw.length)\n-        return ctx.stylize(base, 'string');\n-      // For boxed Strings, we have to remove the 0-n indexed entries,\n-      // since they just noisy up the output and are redundant\n-      // Make boxed primitive Strings look like such\n-      keys = keys.slice(value.length);\n-      braces = ['{', '}'];\n-    // The input prototype got manipulated. Special handle these.\n-    // We have to rebuild the information so we are able to display everything.\n+      skip = true;\n+    } else if (isBoxedPrimitive(value)) {\n+      let type;\n+      if (isNumberObject(value)) {\n+        base = `[Number: ${getBoxedValue(numberValueOf(value))}]`;\n+        type = 'number';\n+      } else if (isStringObject(value)) {\n+        base = `[String: ${getBoxedValue(stringValueOf(value), ctx)}]`;\n+        type = 'string';\n+        // For boxed Strings, we have to remove the 0-n indexed entries,\n+        // since they just noisy up the output and are redundant\n+        // Make boxed primitive Strings look like such\n+        keys = keys.slice(value.length);\n+      } else if (isBooleanObject(value)) {\n+        base = `[Boolean: ${getBoxedValue(booleanValueOf(value))}]`;\n+        type = 'boolean';\n+      } else if (isBigIntObject(value)) {\n+        base = `[BigInt: ${getBoxedValue(bigIntValueOf(value))}]`;\n+        type = 'bigint';\n+      } else {\n+        base = `[Symbol: ${getBoxedValue(symbolValueOf(value))}]`;\n+        type = 'symbol';\n+      }\n+      if (keys.length === 0) {\n+        return ctx.stylize(base, type);\n+      }\n     } else {\n+      // The input prototype got manipulated. Special handle these. We have to\n+      // rebuild the information so we are able to display everything.\n       const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);\n       if (specialIterator) {\n         return specialIterator;\n@@ -823,7 +854,7 @@ function formatValue(ctx, value, recurseTimes) {\n         braces = [`[${tag || 'Set Iterator'}] {`, '}'];\n         formatter = formatSetIterator;\n       // Handle other regular objects again.\n-      } else if (keyLength === 0) {\n+      } else if (keys.length === 0) {\n         if (isExternal(value))\n           return ctx.stylize('[External]', 'special');\n         return `${getPrefix(constructor, tag)}{}`;\n@@ -841,36 +872,34 @@ function formatValue(ctx, value, recurseTimes) {\n \n   ctx.seen.push(value);\n   let output;\n-  // This corresponds to a depth of at least 333 and likely 500.\n-  if (ctx.indentationLvl < 1000) {\n+  try {\n     output = formatter(ctx, value, recurseTimes, keys);\n-  } else {\n-    try {\n-      output = formatter(ctx, value, recurseTimes, keys);\n-    } catch (err) {\n-      if (errors.isStackOverflowError(err)) {\n-        ctx.seen.pop();\n-        return ctx.stylize(\n-          `[${constructor || tag || 'Object'}: Inspection interrupted ` +\n-            'prematurely. Maximum call stack size exceeded.]',\n-          'special'\n-        );\n+    if (skip === false) {\n+      for (i = 0; i < keys.length; i++) {\n+        output.push(\n+          formatProperty(ctx, value, recurseTimes, keys[i], extrasType));\n       }\n-      throw err;\n     }\n+  } catch (err) {\n+    return handleMaxCallStackSize(ctx, err, constructor, tag);\n   }\n-  if (extra !== undefined)\n-    output.unshift(extra);\n-\n-  for (i = 0; i < symbols.length; i++) {\n-    output.push(formatProperty(ctx, value, recurseTimes, symbols[i], 0));\n-  }\n-\n   ctx.seen.pop();\n \n   return reduceToSingleString(ctx, output, base, braces);\n }\n \n+function handleMaxCallStackSize(ctx, err, constructor, tag) {\n+  if (errors.isStackOverflowError(err)) {\n+    ctx.seen.pop();\n+    return ctx.stylize(\n+      `[${constructor || tag || 'Object'}: Inspection interrupted ` +\n+        'prematurely. Maximum call stack size exceeded.]',\n+      'special'\n+    );\n+  }\n+  throw err;\n+}\n+\n function formatNumber(fn, value) {\n   // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.\n   if (Object.is(value, -0))\n@@ -935,20 +964,13 @@ function formatError(value) {\n   return value.stack || errorToString(value);\n }\n \n-function formatObject(ctx, value, recurseTimes, keys) {\n-  const len = keys.length;\n-  const output = new Array(len);\n-  for (var i = 0; i < len; i++)\n-    output[i] = formatProperty(ctx, value, recurseTimes, keys[i], 0);\n-  return output;\n-}\n-\n function formatNamespaceObject(ctx, value, recurseTimes, keys) {\n   const len = keys.length;\n   const output = new Array(len);\n   for (var i = 0; i < len; i++) {\n     try {\n-      output[i] = formatProperty(ctx, value, recurseTimes, keys[i], 0);\n+      output[i] = formatProperty(ctx, value, recurseTimes, keys[i],\n+                                 kObjectType);\n     } catch (err) {\n       if (!(types.isNativeError(err) && err.name === 'ReferenceError')) {\n         throw err;\n@@ -957,7 +979,7 @@ function formatNamespaceObject(ctx, value, recurseTimes, keys) {\n       // line breaks are always correct. Otherwise it is very difficult to keep\n       // this aligned, even though this is a hacky way of dealing with this.\n       const tmp = { [keys[i]]: '' };\n-      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], 0);\n+      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);\n       const pos = output[i].lastIndexOf(' ');\n       // We have to find the last whitespace and have to replace that value as\n       // it will be visualized as a regular string.\n@@ -969,91 +991,67 @@ function formatNamespaceObject(ctx, value, recurseTimes, keys) {\n }\n \n // The array is sparse and/or has extra keys\n-function formatSpecialArray(ctx, value, recurseTimes, keys, maxLength, valLen) {\n-  const output = [];\n-  const keyLen = keys.length;\n-  let i = 0;\n-  for (const key of keys) {\n-    if (output.length === maxLength)\n-      break;\n-    const index = +key;\n+function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {\n+  const keys = Object.keys(value);\n+  let index = i;\n+  for (; i < keys.length && output.length < maxLength; i++) {\n+    const key = keys[i];\n+    const tmp = +key;\n     // Arrays can only have up to 2^32 - 1 entries\n-    if (index > 2 ** 32 - 2)\n+    if (tmp > 2 ** 32 - 2) {\n       break;\n-    if (`${i}` !== key) {\n-      if (!numberRegExp.test(key))\n+    }\n+    if (`${index}` !== key) {\n+      if (!numberRegExp.test(key)) {\n         break;\n-      const emptyItems = index - i;\n+      }\n+      const emptyItems = tmp - index;\n       const ending = emptyItems > 1 ? 's' : '';\n       const message = `<${emptyItems} empty item${ending}>`;\n       output.push(ctx.stylize(message, 'undefined'));\n-      i = index;\n-      if (output.length === maxLength)\n+      index = tmp;\n+      if (output.length === maxLength) {\n         break;\n+      }\n     }\n-    output.push(formatProperty(ctx, value, recurseTimes, key, 1));\n-    i++;\n-  }\n-  if (i < valLen && output.length !== maxLength) {\n-    const len = valLen - i;\n-    const ending = len > 1 ? 's' : '';\n-    const message = `<${len} empty item${ending}>`;\n-    output.push(ctx.stylize(message, 'undefined'));\n-    i = valLen;\n-    if (keyLen === 0)\n-      return output;\n-  }\n-  const remaining = valLen - i;\n-  if (remaining > 0) {\n-    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n-  }\n-  if (ctx.showHidden && keys[keyLen - 1] === 'length') {\n-    // No extra keys\n-    output.push(formatProperty(ctx, value, recurseTimes, 'length', 2));\n-  } else if (valLen === 0 ||\n-    keyLen > valLen && keys[valLen - 1] === `${valLen - 1}`) {\n-    // The array is not sparse\n-    for (i = valLen; i < keyLen; i++)\n-      output.push(formatProperty(ctx, value, recurseTimes, keys[i], 2));\n-  } else if (keys[keyLen - 1] !== `${valLen - 1}`) {\n-    const extra = [];\n-    // Only handle special keys\n-    let key;\n-    for (i = keys.length - 1; i >= 0; i--) {\n-      key = keys[i];\n-      if (numberRegExp.test(key) && +key < 2 ** 32 - 1)\n-        break;\n-      extra.push(formatProperty(ctx, value, recurseTimes, key, 2));\n+    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));\n+    index++;\n+  }\n+  const remaining = value.length - index;\n+  if (output.length !== maxLength) {\n+    if (remaining > 0) {\n+      const ending = remaining > 1 ? 's' : '';\n+      const message = `<${remaining} empty item${ending}>`;\n+      output.push(ctx.stylize(message, 'undefined'));\n     }\n-    for (i = extra.length - 1; i >= 0; i--)\n-      output.push(extra[i]);\n+  } else if (remaining > 0) {\n+    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n   }\n   return output;\n }\n \n-function formatArray(ctx, value, recurseTimes, keys) {\n-  const len = Math.min(Math.max(0, ctx.maxArrayLength), value.length);\n-  const hidden = ctx.showHidden ? 1 : 0;\n+function formatArray(ctx, value, recurseTimes) {\n   const valLen = value.length;\n-  const keyLen = keys.length - hidden;\n-  if (keyLen !== valLen || keys[keyLen - 1] !== `${valLen - 1}`)\n-    return formatSpecialArray(ctx, value, recurseTimes, keys, len, valLen);\n+  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);\n \n   const remaining = valLen - len;\n-  const output = new Array(len + (remaining > 0 ? 1 : 0) + hidden);\n-  for (var i = 0; i < len; i++)\n-    output[i] = formatProperty(ctx, value, recurseTimes, keys[i], 1);\n+  const output = [];\n+  for (var i = 0; i < len; i++) {\n+    // Special handle sparse arrays.\n+    if (!hasOwnProperty(value, i)) {\n+      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);\n+    }\n+    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));\n+  }\n   if (remaining > 0)\n-    output[i++] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n-  if (ctx.showHidden === true)\n-    output[i] = formatProperty(ctx, value, recurseTimes, 'length', 2);\n+    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n   return output;\n }\n \n-function formatTypedArray(ctx, value, recurseTimes, keys) {\n+function formatTypedArray(ctx, value, recurseTimes) {\n   const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);\n   const remaining = value.length - maxLength;\n-  const output = new Array(maxLength + (remaining > 0 ? 1 : 0));\n+  const output = new Array(maxLength);\n   const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n     formatNumber :\n     formatBigInt;\n@@ -1076,52 +1074,39 @@ function formatTypedArray(ctx, value, recurseTimes, keys) {\n     }\n     ctx.indentationLvl -= 2;\n   }\n-  // TypedArrays cannot have holes. Therefore it is safe to assume that all\n-  // extra keys are indexed after value.length.\n-  for (i = value.length; i < keys.length; i++) {\n-    output.push(formatProperty(ctx, value, recurseTimes, keys[i], 2));\n-  }\n   return output;\n }\n \n-function formatSet(ctx, value, recurseTimes, keys) {\n-  const output = new Array(value.size + keys.length + (ctx.showHidden ? 1 : 0));\n-  let i = 0;\n+function formatSet(ctx, value, recurseTimes) {\n+  const output = [];\n   ctx.indentationLvl += 2;\n   for (const v of value) {\n-    output[i++] = formatValue(ctx, v, recurseTimes);\n+    output.push(formatValue(ctx, v, recurseTimes));\n   }\n   ctx.indentationLvl -= 2;\n   // With `showHidden`, `length` will display as a hidden property for\n   // arrays. For consistency's sake, do the same for `size`, even though this\n   // property isn't selected by Object.getOwnPropertyNames().\n   if (ctx.showHidden)\n-    output[i++] = `[size]: ${ctx.stylize(`${value.size}`, 'number')}`;\n-  for (var n = 0; n < keys.length; n++) {\n-    output[i++] = formatProperty(ctx, value, recurseTimes, keys[n], 0);\n-  }\n+    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);\n   return output;\n }\n \n-function formatMap(ctx, value, recurseTimes, keys) {\n-  const output = new Array(value.size + keys.length + (ctx.showHidden ? 1 : 0));\n-  let i = 0;\n+function formatMap(ctx, value, recurseTimes) {\n+  const output = [];\n   ctx.indentationLvl += 2;\n   for (const [k, v] of value) {\n-    output[i++] = `${formatValue(ctx, k, recurseTimes)} => ` +\n-                  formatValue(ctx, v, recurseTimes);\n+    output.push(`${formatValue(ctx, k, recurseTimes)} => ` +\n+                formatValue(ctx, v, recurseTimes));\n   }\n   ctx.indentationLvl -= 2;\n   // See comment in formatSet\n   if (ctx.showHidden)\n-    output[i++] = `[size]: ${ctx.stylize(`${value.size}`, 'number')}`;\n-  for (var n = 0; n < keys.length; n++) {\n-    output[i++] = formatProperty(ctx, value, recurseTimes, keys[n], 0);\n-  }\n+    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);\n   return output;\n }\n \n-function formatSetIterInner(ctx, value, recurseTimes, keys, entries, state) {\n+function formatSetIterInner(ctx, recurseTimes, entries, state) {\n   const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n   const maxLength = Math.min(maxArrayLength, entries.length);\n   let output = new Array(maxLength);\n@@ -1139,12 +1124,10 @@ function formatSetIterInner(ctx, value, recurseTimes, keys, entries, state) {\n   if (remaining > 0) {\n     output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n   }\n-  for (i = 0; i < keys.length; i++)\n-    output.push(formatProperty(ctx, value, recurseTimes, keys[i], 0));\n   return output;\n }\n \n-function formatMapIterInner(ctx, value, recurseTimes, keys, entries, state) {\n+function formatMapIterInner(ctx, recurseTimes, entries, state) {\n   const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n   // Entries exist as [key1, val1, key2, val2, ...]\n   const len = entries.length / 2;\n@@ -1175,37 +1158,38 @@ function formatMapIterInner(ctx, value, recurseTimes, keys, entries, state) {\n   if (remaining > 0) {\n     output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n   }\n-  for (i = 0; i < keys.length; i++)\n-    output.push(formatProperty(ctx, value, recurseTimes, keys[i], 0));\n   return output;\n }\n \n-function formatWeakSet(ctx, value, recurseTimes, keys) {\n+function formatWeakCollection(ctx) {\n+  return [ctx.stylize('<items unknown>', 'special')];\n+}\n+\n+function formatWeakSet(ctx, value, recurseTimes) {\n   const entries = previewEntries(value);\n-  return formatSetIterInner(ctx, value, recurseTimes, keys, entries, kWeak);\n+  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);\n }\n \n-function formatWeakMap(ctx, value, recurseTimes, keys) {\n+function formatWeakMap(ctx, value, recurseTimes) {\n   const entries = previewEntries(value);\n-  return formatMapIterInner(ctx, value, recurseTimes, keys, entries, kWeak);\n+  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);\n }\n \n-function formatSetIterator(ctx, value, recurseTimes, keys) {\n+function formatSetIterator(ctx, value, recurseTimes) {\n   const entries = previewEntries(value);\n-  return formatSetIterInner(ctx, value, recurseTimes, keys, entries, kIterator);\n+  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n }\n \n-function formatMapIterator(ctx, value, recurseTimes, keys) {\n+function formatMapIterator(ctx, value, recurseTimes) {\n   const [entries, isKeyValue] = previewEntries(value, true);\n   if (isKeyValue) {\n-    return formatMapIterInner(\n-      ctx, value, recurseTimes, keys, entries, kMapEntries);\n+    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);\n   }\n \n-  return formatSetIterInner(ctx, value, recurseTimes, keys, entries, kIterator);\n+  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n }\n \n-function formatPromise(ctx, value, recurseTimes, keys) {\n+function formatPromise(ctx, value, recurseTimes) {\n   let output;\n   const [state, result] = getPromiseDetails(value);\n   if (state === kPending) {\n@@ -1222,19 +1206,16 @@ function formatPromise(ctx, value, recurseTimes, keys) {\n         str\n     ];\n   }\n-  for (var n = 0; n < keys.length; n++) {\n-    output.push(formatProperty(ctx, value, recurseTimes, keys[n], 0));\n-  }\n   return output;\n }\n \n-function formatProperty(ctx, value, recurseTimes, key, array) {\n+function formatProperty(ctx, value, recurseTimes, key, type) {\n   let name, str;\n   let extra = ' ';\n   const desc = Object.getOwnPropertyDescriptor(value, key) ||\n     { value: value[key], enumerable: true };\n   if (desc.value !== undefined) {\n-    const diff = array !== 0 || ctx.compact === false ? 2 : 3;\n+    const diff = (type !== kObjectType || ctx.compact === false) ? 2 : 3;\n     ctx.indentationLvl += diff;\n     str = formatValue(ctx, desc.value, recurseTimes);\n     if (diff === 3) {\n@@ -1255,7 +1236,7 @@ function formatProperty(ctx, value, recurseTimes, key, array) {\n   } else {\n     str = ctx.stylize('undefined', 'undefined');\n   }\n-  if (array === 1) {\n+  if (type === kArrayType) {\n     return str;\n   }\n   if (typeof key === 'symbol') {"
        },
        {
            "sha": "0994f262996cf5d8d17aa26322f9a9d61edda7f4",
            "filename": "test/parallel/test-util-inspect.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/test%2Fparallel%2Ftest-util-inspect.js",
            "raw_url": "https://github.com/nodejs/node/raw/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/test%2Fparallel%2Ftest-util-inspect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-util-inspect.js?ref=12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342",
            "patch": "@@ -872,7 +872,7 @@ if (typeof Symbol !== 'undefined') {\n   const set = new Set(['foo']);\n   set.bar = 42;\n   assert.strictEqual(\n-    util.inspect(set, true),\n+    util.inspect(set, { showHidden: true }),\n     \"Set { 'foo', [size]: 1, bar: 42 }\"\n   );\n }"
        }
    ],
    "stats": {
        "total": 465,
        "additions": 223,
        "deletions": 242
    }
}