{
    "author": "tniessen",
    "message": "crypto: add key object API\n\nThis commit makes multiple important changes:\n\n1. A new key object API is introduced. The KeyObject class itself is\n   not exposed to users, instead, several new APIs can be used to\n   construct key objects: createSecretKey, createPrivateKey and\n   createPublicKey. The new API also allows to convert between\n   different key formats, and even though the API itself is not\n   compatible to the WebCrypto standard in any way, it makes\n   interoperability much simpler.\n\n2. Key objects can be used instead of the raw key material in all\n   relevant crypto APIs.\n\n3. The handling of asymmetric keys has been unified and greatly\n   improved. Node.js now fully supports both PEM-encoded and\n   DER-encoded public and private keys.\n\n4. Conversions between buffers and strings have been moved to native\n   code for sensitive data such as symmetric keys due to security\n   considerations such as zeroing temporary buffers.\n\n5. For compatibility with older versions of the crypto API, this\n   change allows to specify Buffers and strings as the \"passphrase\"\n   option when reading or writing an encoded key. Note that this\n   can result in unexpected behavior if the password contains a\n   null byte.\n\nPR-URL: https://github.com/nodejs/node/pull/24234\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "823d86c47ce15fba8875fcebd412593b02aab362",
    "files": [
        {
            "sha": "017eb91e67882f08a7cd9ecaa4df3f8583d95a37",
            "filename": "doc/api/crypto.md",
            "status": "modified",
            "additions": 218,
            "deletions": 60,
            "changes": 278,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/doc%2Fapi%2Fcrypto.md",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/doc%2Fapi%2Fcrypto.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fcrypto.md?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -1101,6 +1101,81 @@ encoding of `'utf8'` is enforced. If `data` is a [`Buffer`][], `TypedArray`, or\n \n This can be called many times with new data as it is streamed.\n \n+## Class: KeyObject\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Node.js uses an internal `KeyObject` class which should not be accessed\n+directly. Instead, factory functions exist to create instances of this class\n+in a secure manner, see [`crypto.createSecretKey()`][],\n+[`crypto.createPublicKey()`][] and [`crypto.createPrivateKey()`][]. A\n+`KeyObject` can represent a symmetric or asymmetric key, and each kind of key\n+exposes different functions.\n+\n+Most applications should consider using the new `KeyObject` API instead of\n+passing keys as strings or `Buffer`s due to improved security features.\n+\n+### keyObject.asymmetricKeyType\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* {string}\n+\n+For asymmetric keys, this property represents the type of the embedded key\n+(`'rsa'`, `'dsa'` or `'ec'`). This property is `undefined` for symmetric keys.\n+\n+### keyObject.export([options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `options`: {Object}\n+* Returns: {string | Buffer}\n+\n+For symmetric keys, this function allocates a `Buffer` containing the key\n+material and ignores any options.\n+\n+For asymmetric keys, the `options` parameter is used to determine the export\n+format.\n+\n+For public keys, the following encoding options can be used:\n+\n+* `type`: {string} Must be one of `'pkcs1'` (RSA only) or `'spki'`.\n+* `format`: {string} Must be `'pem'` or `'der'`.\n+\n+For private keys, the following encoding options can be used:\n+\n+* `type`: {string} Must be one of `'pkcs1'` (RSA only), `'pkcs8'` or\n+  `'sec1'` (EC only).\n+* `format`: {string} Must be `'pem'` or `'der'`.\n+* `cipher`: {string} If specified, the private key will be encrypted with\n+   the given `cipher` and `passphrase` using PKCS#5 v2.0 password based\n+   encryption.\n+* `passphrase`: {string | Buffer} The passphrase to use for encryption, see\n+  `cipher`.\n+\n+When PEM encoding was selected, the result will be a string, otherwise it will\n+be a buffer containing the data encoded as DER.\n+\n+### keyObject.symmetricSize\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* {number}\n+\n+For secret keys, this property represents the size of the key in bytes. This\n+property is `undefined` for asymmetric keys.\n+\n+### keyObject.type\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* {string}\n+\n+Depending on the type of this `KeyObject`, this property is either\n+`'secret'` for secret (symmetric) keys, `'public'` for public (asymmetric) keys\n+or `'private'` for private (asymmetric) keys.\n+\n ## Class: Sign\n <!-- YAML\n added: v0.1.92\n@@ -1169,13 +1244,14 @@ console.log(sign.sign(privateKey, 'hex'));\n <!-- YAML\n added: v0.1.92\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: This function now supports key objects.\n   - version: v8.0.0\n     pr-url: https://github.com/nodejs/node/pull/11705\n     description: Support for RSASSA-PSS and additional options was added.\n -->\n-* `privateKey` {string | Object}\n-  - `key` {string}\n-  - `passphrase` {string}\n+* `privateKey` {Object | string | Buffer | KeyObject}\n   - `padding` {integer}\n   - `saltLength` {integer}\n * `outputEncoding` {string} The [encoding][] of the return value.\n@@ -1184,12 +1260,10 @@ changes:\n Calculates the signature on all the data passed through using either\n [`sign.update()`][] or [`sign.write()`][stream-writable-write].\n \n-The `privateKey` argument can be an object or a string. If `privateKey` is a\n-string, it is treated as a raw key with no passphrase. If `privateKey` is an\n-object, it must contain one or more of the following properties:\n+If `privateKey` is not a [`KeyObject`][], this function behaves as if\n+`privateKey` had been passed to [`crypto.createPrivateKey()`][]. If it is an\n+object, the following additional properties can be passed:\n \n-* `key`: {string} - PEM encoded private key (required)\n-* `passphrase`: {string} - passphrase for the private key\n * `padding`: {integer} - Optional padding value for RSA, one of the following:\n   * `crypto.constants.RSA_PKCS1_PADDING` (default)\n   * `crypto.constants.RSA_PKCS1_PSS_PADDING`\n@@ -1299,18 +1373,20 @@ changes:\n     pr-url: https://github.com/nodejs/node/pull/11705\n     description: Support for RSASSA-PSS and additional options was added.\n -->\n-* `object` {string | Object}\n+* `object` {Object | string | Buffer | KeyObject}\n+  - `padding` {integer}\n+  - `saltLength` {integer}\n * `signature` {string | Buffer | TypedArray | DataView}\n * `signatureEncoding` {string} The [encoding][] of the `signature` string.\n * Returns: {boolean} `true` or `false` depending on the validity of the\n   signature for the data and public key.\n \n Verifies the provided data using the given `object` and `signature`.\n-The `object` argument can be either a string containing a PEM encoded object,\n-which can be an RSA public key, a DSA public key, or an X.509 certificate,\n-or an object with one or more of the following properties:\n \n-* `key`: {string} - PEM encoded public key (required)\n+If `object` is not a [`KeyObject`][], this function behaves as if\n+`object` had been passed to [`crypto.createPublicKey()`][]. If it is an\n+object, the following additional properties can be passed:\n+\n * `padding`: {integer} - Optional padding value for RSA, one of the following:\n   * `crypto.constants.RSA_PKCS1_PADDING` (default)\n   * `crypto.constants.RSA_PKCS1_PSS_PADDING`\n@@ -1436,6 +1512,9 @@ Adversaries][] for details.\n <!-- YAML\n added: v0.1.94\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: The `key` argument can now be a `KeyObject`.\n   - version: v11.2.0\n     pr-url: https://github.com/nodejs/node/pull/24081\n     description: The cipher `chacha20-poly1305` is now supported.\n@@ -1452,7 +1531,7 @@ changes:\n                  need an initialization vector.\n -->\n * `algorithm` {string}\n-* `key` {string | Buffer | TypedArray | DataView}\n+* `key` {string | Buffer | TypedArray | DataView | KeyObject}\n * `iv` {string | Buffer | TypedArray | DataView}\n * `options` {Object} [`stream.transform` options][]\n * Returns: {Cipher}\n@@ -1474,7 +1553,8 @@ display the available cipher algorithms.\n \n The `key` is the raw key used by the `algorithm` and `iv` is an\n [initialization vector][]. Both arguments must be `'utf8'` encoded strings,\n-[Buffers][`Buffer`], `TypedArray`, or `DataView`s. If the cipher does not need\n+[Buffers][`Buffer`], `TypedArray`, or `DataView`s. The `key` may optionally be\n+a [`KeyObject`][] of type `secret`. If the cipher does not need\n an initialization vector, `iv` may be `null`.\n \n Initialization vectors should be unpredictable and unique; ideally, they will be\n@@ -1525,6 +1605,9 @@ to create the `Decipher` object.\n <!-- YAML\n added: v0.1.94\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: The `key` argument can now be a `KeyObject`.\n   - version: v11.2.0\n     pr-url: https://github.com/nodejs/node/pull/24081\n     description: The cipher `chacha20-poly1305` is now supported.\n@@ -1563,7 +1646,8 @@ display the available cipher algorithms.\n \n The `key` is the raw key used by the `algorithm` and `iv` is an\n [initialization vector][]. Both arguments must be `'utf8'` encoded strings,\n-[Buffers][`Buffer`], `TypedArray`, or `DataView`s. If the cipher does not need\n+[Buffers][`Buffer`], `TypedArray`, or `DataView`s. The `key` may optionally be\n+a [`KeyObject`][] of type `secret`. If the cipher does not need\n an initialization vector, `iv` may be `null`.\n \n Initialization vectors should be unpredictable and unique; ideally, they will be\n@@ -1674,9 +1758,13 @@ input.on('readable', () => {\n ### crypto.createHmac(algorithm, key[, options])\n <!-- YAML\n added: v0.1.94\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: The `key` argument can now be a `KeyObject`.\n -->\n * `algorithm` {string}\n-* `key` {string | Buffer | TypedArray | DataView}\n+* `key` {string | Buffer | TypedArray | DataView | KeyObject}\n * `options` {Object} [`stream.transform` options][]\n * Returns: {Hmac}\n \n@@ -1689,7 +1777,8 @@ On recent releases of OpenSSL, `openssl list -digest-algorithms`\n (`openssl list-message-digest-algorithms` for older versions of OpenSSL) will\n display the available digest algorithms.\n \n-The `key` is the HMAC key used to generate the cryptographic HMAC hash.\n+The `key` is the HMAC key used to generate the cryptographic HMAC hash. If it is\n+a [`KeyObject`][], its type must be `secret`.\n \n Example: generating the sha256 HMAC of a file\n \n@@ -1711,6 +1800,47 @@ input.on('readable', () => {\n });\n ```\n \n+### crypto.createPrivateKey(key)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `key` {Object | string | Buffer}\n+  - `key`: {string | Buffer} The key material, either in PEM or DER format.\n+  - `format`: {string} Must be `'pem'` or `'der'`. **Default:** `'pem'`.\n+  - `type`: {string} Must be `'pkcs1'`, `'pkcs8'` or `'sec1'`. This option is\n+     required only if the `format` is `'der'` and ignored if it is `'pem'`.\n+  - `passphrase`: {string | Buffer} The passphrase to use for decryption.\n+* Returns: {KeyObject}\n+\n+Creates and returns a new key object containing a private key. If `key` is a\n+string or `Buffer`, `format` is assumed to be `'pem'`; otherwise, `key`\n+must be an object with the properties described above.\n+\n+### crypto.createPublicKey(key)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `key` {Object | string | Buffer}\n+  - `key`: {string | Buffer}\n+  - `format`: {string} Must be `'pem'` or `'der'`. **Default:** `'pem'`.\n+  - `type`: {string} Must be `'pkcs1'` or `'spki'`. This option is required\n+    only if the `format` is `'der'`.\n+* Returns: {KeyObject}\n+\n+Creates and returns a new key object containing a public key. If `key` is a\n+string or `Buffer`, `format` is assumed to be `'pem'`; otherwise, `key`\n+must be an object with the properties described above.\n+\n+### crypto.createSecretKey(key)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `key` {Buffer}\n+* Returns: {KeyObject}\n+\n+Creates and returns a new key object containing a secret key for symmetric\n+encryption or `Hmac`.\n+\n ### crypto.createSign(algorithm[, options])\n <!-- YAML\n added: v0.1.92\n@@ -1740,34 +1870,34 @@ signing algorithms. Optional `options` argument controls the\n ### crypto.generateKeyPair(type, options, callback)\n <!-- YAML\n added: v10.12.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: The `generateKeyPair` and `generateKeyPairSync` functions now\n+                 produce key objects if no encoding was specified.\n -->\n * `type`: {string} Must be `'rsa'`, `'dsa'` or `'ec'`.\n * `options`: {Object}\n   - `modulusLength`: {number} Key size in bits (RSA, DSA).\n   - `publicExponent`: {number} Public exponent (RSA). **Default:** `0x10001`.\n   - `divisorLength`: {number} Size of `q` in bits (DSA).\n   - `namedCurve`: {string} Name of the curve to use (EC).\n-  - `publicKeyEncoding`: {Object}\n-    - `type`: {string} Must be one of `'pkcs1'` (RSA only) or `'spki'`.\n-    - `format`: {string} Must be `'pem'` or `'der'`.\n-  - `privateKeyEncoding`: {Object}\n-    - `type`: {string} Must be one of `'pkcs1'` (RSA only), `'pkcs8'` or\n-      `'sec1'` (EC only).\n-    - `format`: {string} Must be `'pem'` or `'der'`.\n-    - `cipher`: {string} If specified, the private key will be encrypted with\n-      the given `cipher` and `passphrase` using PKCS#5 v2.0 password based\n-      encryption.\n-    - `passphrase`: {string} The passphrase to use for encryption, see `cipher`.\n+  - `publicKeyEncoding`: {Object} See [`keyObject.export()`][].\n+  - `privateKeyEncoding`: {Object} See [`keyObject.export()`][].\n * `callback`: {Function}\n   - `err`: {Error}\n-  - `publicKey`: {string|Buffer}\n-  - `privateKey`: {string|Buffer}\n+  - `publicKey`: {string | Buffer | KeyObject}\n+  - `privateKey`: {string | Buffer | KeyObject}\n \n Generates a new asymmetric key pair of the given `type`. Only RSA, DSA and EC\n are currently supported.\n \n+If a `publicKeyEncoding` or `privateKeyEncoding` was specified, this function\n+behaves as if [`keyObject.export()`][] had been called on its result. Otherwise,\n+the respective part of the key is returned as a [`KeyObject`].\n+\n It is recommended to encode public keys as `'spki'` and private keys as\n-`'pkcs8'` with encryption:\n+`'pkcs8'` with encryption for long-term storage:\n \n ```js\n const { generateKeyPair } = require('crypto');\n@@ -1789,18 +1919,19 @@ generateKeyPair('rsa', {\n ```\n \n On completion, `callback` will be called with `err` set to `undefined` and\n-`publicKey` / `privateKey` representing the generated key pair. When PEM\n-encoding was selected, the result will be a string, otherwise it will be a\n-buffer containing the data encoded as DER. Note that Node.js itself does not\n-accept DER, it is supported for interoperability with other libraries such as\n-WebCrypto only.\n+`publicKey` / `privateKey` representing the generated key pair.\n \n If this method is invoked as its [`util.promisify()`][]ed version, it returns\n a `Promise` for an `Object` with `publicKey` and `privateKey` properties.\n \n ### crypto.generateKeyPairSync(type, options)\n <!-- YAML\n added: v10.12.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: The `generateKeyPair` and `generateKeyPairSync` functions now\n+                 produce key objects if no encoding was specified.\n -->\n * `type`: {string} Must be `'rsa'`, `'dsa'` or `'ec'`.\n * `options`: {Object}\n@@ -1818,10 +1949,11 @@ added: v10.12.0\n     - `cipher`: {string} If specified, the private key will be encrypted with\n       the given `cipher` and `passphrase` using PKCS#5 v2.0 password based\n       encryption.\n-    - `passphrase`: {string} The passphrase to use for encryption, see `cipher`.\n+    - `passphrase`: {string | Buffer} The passphrase to use for encryption, see\n+      `cipher`.\n * Returns: {Object}\n-  - `publicKey`: {string|Buffer}\n-  - `privateKey`: {string|Buffer}\n+  - `publicKey`: {string | Buffer | KeyObject}\n+  - `privateKey`: {string | Buffer | KeyObject}\n \n Generates a new asymmetric key pair of the given `type`. Only RSA, DSA and EC\n are currently supported.\n@@ -2062,10 +2194,12 @@ An array of supported digest functions can be retrieved using\n ### crypto.privateDecrypt(privateKey, buffer)\n <!-- YAML\n added: v0.11.14\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: This function now supports key objects.\n -->\n-* `privateKey` {Object | string}\n-  - `key` {string} A PEM encoded private key.\n-  - `passphrase` {string} An optional passphrase for the private key.\n+* `privateKey` {Object | string | Buffer | KeyObject}\n   - `padding` {crypto.constants} An optional padding value defined in\n     `crypto.constants`, which may be: `crypto.constants.RSA_NO_PADDING`,\n     `crypto.constants.RSA_PKCS1_PADDING`, or\n@@ -2076,16 +2210,22 @@ added: v0.11.14\n Decrypts `buffer` with `privateKey`. `buffer` was previously encrypted using\n the corresponding public key, for example using [`crypto.publicEncrypt()`][].\n \n-`privateKey` can be an object or a string. If `privateKey` is a string, it is\n-treated as the key with no passphrase and will use `RSA_PKCS1_OAEP_PADDING`.\n+If `privateKey` is not a [`KeyObject`][], this function behaves as if\n+`privateKey` had been passed to [`crypto.createPrivateKey()`][]. If it is an\n+object, the `padding` property can be passed. Otherwise, this function uses\n+`RSA_PKCS1_OAEP_PADDING`.\n \n ### crypto.privateEncrypt(privateKey, buffer)\n <!-- YAML\n added: v1.1.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: This function now supports key objects.\n -->\n-* `privateKey` {Object | string}\n-  - `key` {string} A PEM encoded private key.\n-  - `passphrase` {string} An optional passphrase for the private key.\n+* `privateKey` {Object | string | Buffer | KeyObject}\n+  - `key` {string | Buffer | KeyObject} A PEM encoded private key.\n+  - `passphrase` {string | Buffer} An optional passphrase for the private key.\n   - `padding` {crypto.constants} An optional padding value defined in\n     `crypto.constants`, which may be: `crypto.constants.RSA_NO_PADDING` or\n     `crypto.constants.RSA_PKCS1_PADDING`.\n@@ -2095,16 +2235,21 @@ added: v1.1.0\n Encrypts `buffer` with `privateKey`. The returned data can be decrypted using\n the corresponding public key, for example using [`crypto.publicDecrypt()`][].\n \n-`privateKey` can be an object or a string. If `privateKey` is a string, it is\n-treated as the key with no passphrase and will use `RSA_PKCS1_PADDING`.\n+If `privateKey` is not a [`KeyObject`][], this function behaves as if\n+`privateKey` had been passed to [`crypto.createPrivateKey()`][]. If it is an\n+object, the `padding` property can be passed. Otherwise, this function uses\n+`RSA_PKCS1_PADDING`.\n \n ### crypto.publicDecrypt(key, buffer)\n <!-- YAML\n added: v1.1.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: This function now supports key objects.\n -->\n-* `key` {Object | string}\n-  - `key` {string} A PEM encoded public or private key.\n-  - `passphrase` {string} An optional passphrase for the private key.\n+* `key` {Object | string | Buffer | KeyObject}\n+  - `passphrase` {string | Buffer} An optional passphrase for the private key.\n   - `padding` {crypto.constants} An optional padding value defined in\n     `crypto.constants`, which may be: `crypto.constants.RSA_NO_PADDING` or\n     `crypto.constants.RSA_PKCS1_PADDING`.\n@@ -2114,19 +2259,25 @@ added: v1.1.0\n Decrypts `buffer` with `key`.`buffer` was previously encrypted using\n the corresponding private key, for example using [`crypto.privateEncrypt()`][].\n \n-`key` can be an object or a string. If `key` is a string, it is treated as\n-the key with no passphrase and will use `RSA_PKCS1_PADDING`.\n+If `key` is not a [`KeyObject`][], this function behaves as if\n+`key` had been passed to [`crypto.createPublicKey()`][]. If it is an\n+object, the `padding` property can be passed. Otherwise, this function uses\n+`RSA_PKCS1_PADDING`.\n \n Because RSA public keys can be derived from private keys, a private key may\n be passed instead of a public key.\n \n ### crypto.publicEncrypt(key, buffer)\n <!-- YAML\n added: v0.11.14\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24234\n+    description: This function now supports key objects.\n -->\n-* `key` {Object | string}\n-  - `key` {string} A PEM encoded public or private key.\n-  - `passphrase` {string} An optional passphrase for the private key.\n+* `key` {Object | string | Buffer | KeyObject}\n+  - `key` {string | Buffer | KeyObject} A PEM encoded public or private key.\n+  - `passphrase` {string | Buffer} An optional passphrase for the private key.\n   - `padding` {crypto.constants} An optional padding value defined in\n     `crypto.constants`, which may be: `crypto.constants.RSA_NO_PADDING`,\n     `crypto.constants.RSA_PKCS1_PADDING`, or\n@@ -2138,8 +2289,10 @@ Encrypts the content of `buffer` with `key` and returns a new\n [`Buffer`][] with encrypted content. The returned data can be decrypted using\n the corresponding private key, for example using [`crypto.privateDecrypt()`][].\n \n-`key` can be an object or a string. If `key` is a string, it is treated as\n-the key with no passphrase and will use `RSA_PKCS1_OAEP_PADDING`.\n+If `key` is not a [`KeyObject`][], this function behaves as if\n+`key` had been passed to [`crypto.createPublicKey()`][]. If it is an\n+object, the `padding` property can be passed. Otherwise, this function uses\n+`RSA_PKCS1_OAEP_PADDING`.\n \n Because RSA public keys can be derived from private keys, a private key may\n be passed instead of a public key.\n@@ -2917,6 +3070,7 @@ the `crypto`, `tls`, and `https` modules and are generally specific to OpenSSL.\n \n [`Buffer`]: buffer.html\n [`EVP_BytesToKey`]: https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html\n+[`KeyObject`]: #crypto_class_keyobject\n [`UV_THREADPOOL_SIZE`]: cli.html#cli_uv_threadpool_size_size\n [`cipher.final()`]: #crypto_cipher_final_outputencoding\n [`cipher.update()`]: #crypto_cipher_update_data_inputencoding_outputencoding\n@@ -2928,6 +3082,9 @@ the `crypto`, `tls`, and `https` modules and are generally specific to OpenSSL.\n [`crypto.createECDH()`]: #crypto_crypto_createecdh_curvename\n [`crypto.createHash()`]: #crypto_crypto_createhash_algorithm_options\n [`crypto.createHmac()`]: #crypto_crypto_createhmac_algorithm_key_options\n+[`crypto.createPrivateKey()`]: #crypto_crypto_createprivatekey_key\n+[`crypto.createPublicKey()`]: #crypto_crypto_createpublickey_key\n+[`crypto.createSecretKey()`]: #crypto_crypto_createsecretkey_key\n [`crypto.createSign()`]: #crypto_crypto_createsign_algorithm_options\n [`crypto.createVerify()`]: #crypto_crypto_createverify_algorithm_options\n [`crypto.getCurves()`]: #crypto_crypto_getcurves\n@@ -2949,6 +3106,7 @@ the `crypto`, `tls`, and `https` modules and are generally specific to OpenSSL.\n [`hash.update()`]: #crypto_hash_update_data_inputencoding\n [`hmac.digest()`]: #crypto_hmac_digest_encoding\n [`hmac.update()`]: #crypto_hmac_update_data_inputencoding\n+[`keyObject.export()`]: #crypto_keyobject_export_options\n [`sign.sign()`]: #crypto_sign_sign_privatekey_outputencoding\n [`sign.update()`]: #crypto_sign_update_data_inputencoding\n [`stream.Writable` options]: stream.html#stream_constructor_new_stream_writable_options"
        },
        {
            "sha": "b2a24e3b53ace5ec7d92fc60ba21ce95adcf0d25",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -763,6 +763,11 @@ The selected public or private key encoding is incompatible with other options.\n \n An invalid [crypto digest algorithm][] was specified.\n \n+<a id=\"ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE\"></a>\n+### ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE\n+\n+The given crypto key object's type is invalid for the attempted operation.\n+\n <a id=\"ERR_CRYPTO_INVALID_STATE\"></a>\n ### ERR_CRYPTO_INVALID_STATE\n "
        },
        {
            "sha": "a0062a3d530f62457dd0a51ee98b5e679adbfce9",
            "filename": "lib/crypto.js",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Fcrypto.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Fcrypto.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fcrypto.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -59,6 +59,11 @@ const {\n   generateKeyPair,\n   generateKeyPairSync\n } = require('internal/crypto/keygen');\n+const {\n+  createSecretKey,\n+  createPublicKey,\n+  createPrivateKey\n+} = require('internal/crypto/keys');\n const {\n   DiffieHellman,\n   DiffieHellmanGroup,\n@@ -149,6 +154,9 @@ module.exports = exports = {\n   createECDH,\n   createHash,\n   createHmac,\n+  createPrivateKey,\n+  createPublicKey,\n+  createSecretKey,\n   createSign,\n   createVerify,\n   getCiphers,"
        },
        {
            "sha": "0e8e5c4cf8baf9b70801deb92ba73c2e287d6f97",
            "filename": "lib/internal/crypto/cipher.js",
            "status": "modified",
            "additions": 20,
            "deletions": 13,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fcipher.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fcipher.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fcipher.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -12,6 +12,11 @@ const {\n } = require('internal/errors').codes;\n const { validateString } = require('internal/validators');\n \n+const {\n+  preparePrivateKey,\n+  preparePublicOrPrivateKey,\n+  prepareSecretKey\n+} = require('internal/crypto/keys');\n const {\n   getDefaultEncoding,\n   kHandle,\n@@ -37,19 +42,25 @@ const { deprecate, normalizeEncoding } = require('internal/util');\n // Lazy loaded for startup performance.\n let StringDecoder;\n \n-function rsaFunctionFor(method, defaultPadding) {\n+function rsaFunctionFor(method, defaultPadding, keyType) {\n   return (options, buffer) => {\n-    const key = options.key || options;\n+    const { format, type, data, passphrase } =\n+      keyType === 'private' ?\n+        preparePrivateKey(options) :\n+        preparePublicOrPrivateKey(options);\n     const padding = options.padding || defaultPadding;\n-    const passphrase = options.passphrase || null;\n-    return method(toBuf(key), buffer, padding, passphrase);\n+    return method(data, format, type, passphrase, buffer, padding);\n   };\n }\n \n-const publicEncrypt = rsaFunctionFor(_publicEncrypt, RSA_PKCS1_OAEP_PADDING);\n-const publicDecrypt = rsaFunctionFor(_publicDecrypt, RSA_PKCS1_PADDING);\n-const privateEncrypt = rsaFunctionFor(_privateEncrypt, RSA_PKCS1_PADDING);\n-const privateDecrypt = rsaFunctionFor(_privateDecrypt, RSA_PKCS1_OAEP_PADDING);\n+const publicEncrypt = rsaFunctionFor(_publicEncrypt, RSA_PKCS1_OAEP_PADDING,\n+                                     'public');\n+const publicDecrypt = rsaFunctionFor(_publicDecrypt, RSA_PKCS1_PADDING,\n+                                     'private');\n+const privateEncrypt = rsaFunctionFor(_privateEncrypt, RSA_PKCS1_PADDING,\n+                                      'private');\n+const privateDecrypt = rsaFunctionFor(_privateDecrypt, RSA_PKCS1_OAEP_PADDING,\n+                                      'public');\n \n function getDecoder(decoder, encoding) {\n   encoding = normalizeEncoding(encoding);\n@@ -104,11 +115,7 @@ function createCipher(cipher, password, options, decipher) {\n \n function createCipherWithIV(cipher, key, options, decipher, iv) {\n   validateString(cipher, 'cipher');\n-  key = toBuf(key);\n-  if (!isArrayBufferView(key)) {\n-    throw invalidArrayBufferView('key', key);\n-  }\n-\n+  key = prepareSecretKey(key);\n   iv = toBuf(iv);\n   if (iv !== null && !isArrayBufferView(iv)) {\n     throw invalidArrayBufferView('iv', iv);"
        },
        {
            "sha": "713ded3d1815a036d620dc9587167bc438bdea88",
            "filename": "lib/internal/crypto/hash.js",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fhash.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fhash.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fhash.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -12,6 +12,10 @@ const {\n   toBuf\n } = require('internal/crypto/util');\n \n+const {\n+  prepareSecretKey\n+} = require('internal/crypto/keys');\n+\n const { Buffer } = require('buffer');\n \n const {\n@@ -88,10 +92,7 @@ function Hmac(hmac, key, options) {\n   if (!(this instanceof Hmac))\n     return new Hmac(hmac, key, options);\n   validateString(hmac, 'hmac');\n-  if (typeof key !== 'string' && !isArrayBufferView(key)) {\n-    throw new ERR_INVALID_ARG_TYPE('key',\n-                                   ['string', 'TypedArray', 'DataView'], key);\n-  }\n+  key = prepareSecretKey(key);\n   this[kHandle] = new _Hmac();\n   this[kHandle].init(hmac, toBuf(key));\n   this[kState] = {"
        },
        {
            "sha": "7c0c4110439860eef838e3d1695504ff1bd031e6",
            "filename": "lib/internal/crypto/keygen.js",
            "status": "modified",
            "additions": 46,
            "deletions": 89,
            "changes": 135,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fkeygen.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fkeygen.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fkeygen.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -6,24 +6,32 @@ const {\n   generateKeyPairDSA,\n   generateKeyPairEC,\n   OPENSSL_EC_NAMED_CURVE,\n-  OPENSSL_EC_EXPLICIT_CURVE,\n-  PK_ENCODING_PKCS1,\n-  PK_ENCODING_PKCS8,\n-  PK_ENCODING_SPKI,\n-  PK_ENCODING_SEC1,\n-  PK_FORMAT_DER,\n-  PK_FORMAT_PEM\n+  OPENSSL_EC_EXPLICIT_CURVE\n } = internalBinding('crypto');\n+const {\n+  parsePublicKeyEncoding,\n+  parsePrivateKeyEncoding,\n+\n+  PublicKeyObject,\n+  PrivateKeyObject\n+} = require('internal/crypto/keys');\n const { customPromisifyArgs } = require('internal/util');\n const { isUint32, validateString } = require('internal/validators');\n const {\n-  ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS,\n   ERR_INVALID_ARG_TYPE,\n   ERR_INVALID_ARG_VALUE,\n   ERR_INVALID_CALLBACK,\n   ERR_INVALID_OPT_VALUE\n } = require('internal/errors').codes;\n \n+const { isArrayBufferView } = require('internal/util/types');\n+\n+function wrapKey(key, ctor) {\n+  if (typeof key === 'string' || isArrayBufferView(key))\n+    return key;\n+  return new ctor(key);\n+}\n+\n function generateKeyPair(type, options, callback) {\n   if (typeof options === 'function') {\n     callback = options;\n@@ -38,6 +46,9 @@ function generateKeyPair(type, options, callback) {\n   const wrap = new AsyncWrap(Providers.KEYPAIRGENREQUEST);\n   wrap.ondone = (ex, pubkey, privkey) => {\n     if (ex) return callback.call(wrap, ex);\n+    // If no encoding was chosen, return key objects instead.\n+    pubkey = wrapKey(pubkey, PublicKeyObject);\n+    privkey = wrapKey(privkey, PrivateKeyObject);\n     callback.call(wrap, null, pubkey, privkey);\n   };\n \n@@ -69,86 +80,32 @@ function handleError(impl, wrap) {\n function parseKeyEncoding(keyType, options) {\n   const { publicKeyEncoding, privateKeyEncoding } = options;\n \n-  if (publicKeyEncoding == null || typeof publicKeyEncoding !== 'object')\n-    throw new ERR_INVALID_OPT_VALUE('publicKeyEncoding', publicKeyEncoding);\n-\n-  const { format: strPublicFormat, type: strPublicType } = publicKeyEncoding;\n-\n-  let publicType;\n-  if (strPublicType === 'pkcs1') {\n-    if (keyType !== 'rsa') {\n-      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n-        strPublicType, 'can only be used for RSA keys');\n-    }\n-    publicType = PK_ENCODING_PKCS1;\n-  } else if (strPublicType === 'spki') {\n-    publicType = PK_ENCODING_SPKI;\n+  let publicFormat, publicType;\n+  if (publicKeyEncoding == null) {\n+    publicFormat = publicType = undefined;\n+  } else if (typeof publicKeyEncoding === 'object') {\n+    ({\n+      format: publicFormat,\n+      type: publicType\n+    } = parsePublicKeyEncoding(publicKeyEncoding, keyType,\n+                               'publicKeyEncoding'));\n   } else {\n-    throw new ERR_INVALID_OPT_VALUE('publicKeyEncoding.type', strPublicType);\n+    throw new ERR_INVALID_OPT_VALUE('publicKeyEncoding', publicKeyEncoding);\n   }\n \n-  let publicFormat;\n-  if (strPublicFormat === 'der') {\n-    publicFormat = PK_FORMAT_DER;\n-  } else if (strPublicFormat === 'pem') {\n-    publicFormat = PK_FORMAT_PEM;\n+  let privateFormat, privateType, cipher, passphrase;\n+  if (privateKeyEncoding == null) {\n+    privateFormat = privateType = undefined;\n+  } else if (typeof privateKeyEncoding === 'object') {\n+    ({\n+      format: privateFormat,\n+      type: privateType,\n+      cipher,\n+      passphrase\n+    } = parsePrivateKeyEncoding(privateKeyEncoding, keyType,\n+                                'privateKeyEncoding'));\n   } else {\n-    throw new ERR_INVALID_OPT_VALUE('publicKeyEncoding.format',\n-                                    strPublicFormat);\n-  }\n-\n-  if (privateKeyEncoding == null || typeof privateKeyEncoding !== 'object')\n     throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding', privateKeyEncoding);\n-\n-  const {\n-    cipher,\n-    passphrase,\n-    format: strPrivateFormat,\n-    type: strPrivateType\n-  } = privateKeyEncoding;\n-\n-  let privateType;\n-  if (strPrivateType === 'pkcs1') {\n-    if (keyType !== 'rsa') {\n-      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n-        strPrivateType, 'can only be used for RSA keys');\n-    }\n-    privateType = PK_ENCODING_PKCS1;\n-  } else if (strPrivateType === 'pkcs8') {\n-    privateType = PK_ENCODING_PKCS8;\n-  } else if (strPrivateType === 'sec1') {\n-    if (keyType !== 'ec') {\n-      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n-        strPrivateType, 'can only be used for EC keys');\n-    }\n-    privateType = PK_ENCODING_SEC1;\n-  } else {\n-    throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding.type', strPrivateType);\n-  }\n-\n-  let privateFormat;\n-  if (strPrivateFormat === 'der') {\n-    privateFormat = PK_FORMAT_DER;\n-  } else if (strPrivateFormat === 'pem') {\n-    privateFormat = PK_FORMAT_PEM;\n-  } else {\n-    throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding.format',\n-                                    strPrivateFormat);\n-  }\n-\n-  if (cipher != null) {\n-    if (typeof cipher !== 'string')\n-      throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding.cipher', cipher);\n-    if (privateFormat === PK_FORMAT_DER &&\n-        (privateType === PK_ENCODING_PKCS1 ||\n-         privateType === PK_ENCODING_SEC1)) {\n-      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n-        strPrivateType, 'does not support encryption');\n-    }\n-    if (typeof passphrase !== 'string') {\n-      throw new ERR_INVALID_OPT_VALUE('privateKeyEncoding.passphrase',\n-                                      passphrase);\n-    }\n   }\n \n   return {\n@@ -181,8 +138,8 @@ function check(type, options, callback) {\n         }\n \n         impl = (wrap) => generateKeyPairRSA(modulusLength, publicExponent,\n-                                            publicType, publicFormat,\n-                                            privateType, privateFormat,\n+                                            publicFormat, publicType,\n+                                            privateFormat, privateType,\n                                             cipher, passphrase, wrap);\n       }\n       break;\n@@ -200,8 +157,8 @@ function check(type, options, callback) {\n         }\n \n         impl = (wrap) => generateKeyPairDSA(modulusLength, divisorLength,\n-                                            publicType, publicFormat,\n-                                            privateType, privateFormat,\n+                                            publicFormat, publicType,\n+                                            privateFormat, privateType,\n                                             cipher, passphrase, wrap);\n       }\n       break;\n@@ -219,8 +176,8 @@ function check(type, options, callback) {\n           throw new ERR_INVALID_OPT_VALUE('paramEncoding', paramEncoding);\n \n         impl = (wrap) => generateKeyPairEC(namedCurve, paramEncoding,\n-                                           publicType, publicFormat,\n-                                           privateType, privateFormat,\n+                                           publicFormat, publicType,\n+                                           privateFormat, privateType,\n                                            cipher, passphrase, wrap);\n       }\n       break;"
        },
        {
            "sha": "ad828350806f3ab94483e10c625fc1071d5308b4",
            "filename": "lib/internal/crypto/keys.js",
            "status": "added",
            "additions": 337,
            "deletions": 0,
            "changes": 337,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fkeys.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fkeys.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fkeys.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -0,0 +1,337 @@\n+'use strict';\n+\n+const {\n+  KeyObject: KeyObjectHandle,\n+  kKeyTypeSecret,\n+  kKeyTypePublic,\n+  kKeyTypePrivate,\n+  kKeyFormatPEM,\n+  kKeyFormatDER,\n+  kKeyEncodingPKCS1,\n+  kKeyEncodingPKCS8,\n+  kKeyEncodingSPKI,\n+  kKeyEncodingSEC1\n+} = internalBinding('crypto');\n+const {\n+  ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS,\n+  ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE,\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_INVALID_ARG_VALUE,\n+  ERR_INVALID_OPT_VALUE,\n+  ERR_OUT_OF_RANGE\n+} = require('internal/errors').codes;\n+const { kHandle } = require('internal/crypto/util');\n+\n+const { isArrayBufferView } = require('internal/util/types');\n+\n+const kKeyType = Symbol('kKeyType');\n+\n+const encodingNames = [];\n+for (const m of [[kKeyEncodingPKCS1, 'pkcs1'], [kKeyEncodingPKCS8, 'pkcs8'],\n+                 [kKeyEncodingSPKI, 'spki'], [kKeyEncodingSEC1, 'sec1']])\n+  encodingNames[m[0]] = m[1];\n+\n+class KeyObject {\n+  constructor(type, handle) {\n+    if (type !== 'secret' && type !== 'public' && type !== 'private')\n+      throw new ERR_INVALID_ARG_VALUE('type', type);\n+    if (typeof handle !== 'object')\n+      throw new ERR_INVALID_ARG_TYPE('handle', 'string', handle);\n+\n+    this[kKeyType] = type;\n+\n+    Object.defineProperty(this, kHandle, {\n+      value: handle,\n+      enumerable: false,\n+      configurable: false,\n+      writable: false\n+    });\n+  }\n+\n+  get type() {\n+    return this[kKeyType];\n+  }\n+}\n+\n+class SecretKeyObject extends KeyObject {\n+  constructor(handle) {\n+    super('secret', handle);\n+  }\n+\n+  get symmetricKeySize() {\n+    return this[kHandle].getSymmetricKeySize();\n+  }\n+\n+  export() {\n+    return this[kHandle].export();\n+  }\n+}\n+\n+const kAsymmetricKeyType = Symbol('kAsymmetricKeyType');\n+\n+class AsymmetricKeyObject extends KeyObject {\n+  get asymmetricKeyType() {\n+    return this[kAsymmetricKeyType] ||\n+           (this[kAsymmetricKeyType] = this[kHandle].getAsymmetricKeyType());\n+  }\n+}\n+\n+class PublicKeyObject extends AsymmetricKeyObject {\n+  constructor(handle) {\n+    super('public', handle);\n+  }\n+\n+  export(encoding) {\n+    const {\n+      format,\n+      type\n+    } = parsePublicKeyEncoding(encoding, this.asymmetricKeyType);\n+    return this[kHandle].export(format, type);\n+  }\n+}\n+\n+class PrivateKeyObject extends AsymmetricKeyObject {\n+  constructor(handle) {\n+    super('private', handle);\n+  }\n+\n+  export(encoding) {\n+    const {\n+      format,\n+      type,\n+      cipher,\n+      passphrase\n+    } = parsePrivateKeyEncoding(encoding, this.asymmetricKeyType);\n+    return this[kHandle].export(format, type, cipher, passphrase);\n+  }\n+}\n+\n+function parseKeyFormat(formatStr, defaultFormat, optionName) {\n+  if (formatStr === undefined && defaultFormat !== undefined)\n+    return defaultFormat;\n+  else if (formatStr === 'pem')\n+    return kKeyFormatPEM;\n+  else if (formatStr === 'der')\n+    return kKeyFormatDER;\n+  throw new ERR_INVALID_OPT_VALUE(optionName, formatStr);\n+}\n+\n+function parseKeyType(typeStr, required, keyType, isPublic, optionName) {\n+  if (typeStr === undefined && !required) {\n+    return undefined;\n+  } else if (typeStr === 'pkcs1') {\n+    if (keyType !== undefined && keyType !== 'rsa') {\n+      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n+        typeStr, 'can only be used for RSA keys');\n+    }\n+    return kKeyEncodingPKCS1;\n+  } else if (typeStr === 'spki' && isPublic !== false) {\n+    return kKeyEncodingSPKI;\n+  } else if (typeStr === 'pkcs8' && isPublic !== true) {\n+    return kKeyEncodingPKCS8;\n+  } else if (typeStr === 'sec1' && isPublic !== true) {\n+    if (keyType !== undefined && keyType !== 'ec') {\n+      throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n+        typeStr, 'can only be used for EC keys');\n+    }\n+    return kKeyEncodingSEC1;\n+  }\n+\n+  throw new ERR_INVALID_OPT_VALUE(optionName, typeStr);\n+}\n+\n+function option(name, objName) {\n+  return objName === undefined ? name : `${objName}.${name}`;\n+}\n+\n+function parseKeyFormatAndType(enc, keyType, isPublic, objName) {\n+  const { format: formatStr, type: typeStr } = enc;\n+\n+  const isInput = keyType === undefined;\n+  const format = parseKeyFormat(formatStr,\n+                                isInput ? kKeyFormatPEM : undefined,\n+                                option('format', objName));\n+\n+  const type = parseKeyType(typeStr,\n+                            !isInput || format === kKeyFormatDER,\n+                            keyType,\n+                            isPublic,\n+                            option('type', objName));\n+\n+  return { format, type };\n+}\n+\n+function isStringOrBuffer(val) {\n+  return typeof val === 'string' || isArrayBufferView(val);\n+}\n+\n+function parseKeyEncoding(enc, keyType, isPublic, objName) {\n+  const isInput = keyType === undefined;\n+\n+  const {\n+    format,\n+    type\n+  } = parseKeyFormatAndType(enc, keyType, isPublic, objName);\n+\n+  let cipher, passphrase;\n+  if (isPublic !== true) {\n+    ({ cipher, passphrase } = enc);\n+\n+    if (!isInput && cipher != null) {\n+      if (typeof cipher !== 'string')\n+        throw new ERR_INVALID_OPT_VALUE(option('cipher', objName), cipher);\n+      if (format === kKeyFormatDER &&\n+          (type === kKeyEncodingPKCS1 ||\n+           type === kKeyEncodingSEC1)) {\n+        throw new ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS(\n+          encodingNames[type], 'does not support encryption');\n+      }\n+    }\n+\n+    if ((isInput && passphrase !== undefined &&\n+         !isStringOrBuffer(passphrase)) ||\n+        (!isInput && cipher != null && !isStringOrBuffer(passphrase))) {\n+      throw new ERR_INVALID_OPT_VALUE(option('passphrase', objName),\n+                                      passphrase);\n+    }\n+  }\n+\n+  return { format, type, cipher, passphrase };\n+}\n+\n+// Parses the public key encoding based on an object. keyType must be undefined\n+// when this is used to parse an input encoding and must be a valid key type if\n+// used to parse an output encoding.\n+function parsePublicKeyEncoding(enc, keyType, objName) {\n+  return parseKeyFormatAndType(enc, keyType, true, objName);\n+}\n+\n+// Parses the private key encoding based on an object. keyType must be undefined\n+// when this is used to parse an input encoding and must be a valid key type if\n+// used to parse an output encoding.\n+function parsePrivateKeyEncoding(enc, keyType, objName) {\n+  return parseKeyEncoding(enc, keyType, false, objName);\n+}\n+\n+function getKeyObjectHandle(key, isPublic, allowKeyObject) {\n+  if (!allowKeyObject) {\n+    return new ERR_INVALID_ARG_TYPE(\n+      'key',\n+      ['string', 'Buffer', 'TypedArray', 'DataView'],\n+      key\n+    );\n+  }\n+  if (isPublic != null) {\n+    const expectedType = isPublic ? 'public' : 'private';\n+    if (key.type !== expectedType)\n+      throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, expectedType);\n+  }\n+  return key[kHandle];\n+}\n+\n+function prepareAsymmetricKey(key, isPublic, allowKeyObject = true) {\n+  if (isKeyObject(key)) {\n+    // Best case: A key object, as simple as that.\n+    return { data: getKeyObjectHandle(key, isPublic, allowKeyObject) };\n+  } else if (typeof key === 'string' || isArrayBufferView(key)) {\n+    // Expect PEM by default, mostly for backward compatibility.\n+    return { format: kKeyFormatPEM, data: key };\n+  } else if (typeof key === 'object') {\n+    const data = key.key;\n+    // The 'key' property can be a KeyObject as well to allow specifying\n+    // additional options such as padding along with the key.\n+    if (isKeyObject(data))\n+      return { data: getKeyObjectHandle(data, isPublic, allowKeyObject) };\n+    // Either PEM or DER using PKCS#1 or SPKI.\n+    if (!isStringOrBuffer(data)) {\n+      throw new ERR_INVALID_ARG_TYPE(\n+        'key',\n+        ['string', 'Buffer', 'TypedArray', 'DataView',\n+         ...(allowKeyObject ? ['KeyObject'] : [])],\n+        key);\n+    }\n+    return { data, ...parseKeyEncoding(key, undefined, isPublic) };\n+  } else {\n+    throw new ERR_INVALID_ARG_TYPE(\n+      'key',\n+      ['string', 'Buffer', 'TypedArray', 'DataView',\n+       ...(allowKeyObject ? ['KeyObject'] : [])],\n+      key\n+    );\n+  }\n+}\n+\n+function preparePublicKey(key, allowKeyObject) {\n+  return prepareAsymmetricKey(key, true, allowKeyObject);\n+}\n+\n+function preparePrivateKey(key, allowKeyObject) {\n+  return prepareAsymmetricKey(key, false, allowKeyObject);\n+}\n+\n+function preparePublicOrPrivateKey(key, allowKeyObject) {\n+  return prepareAsymmetricKey(key, undefined, allowKeyObject);\n+}\n+\n+function prepareSecretKey(key, bufferOnly = false) {\n+  if (!isArrayBufferView(key) && (bufferOnly || typeof key !== 'string')) {\n+    if (isKeyObject(key) && !bufferOnly) {\n+      if (key.type !== 'secret')\n+        throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, 'secret');\n+      return key[kHandle];\n+    } else {\n+      throw new ERR_INVALID_ARG_TYPE(\n+        'key',\n+        ['Buffer', 'TypedArray', 'DataView',\n+         ...(bufferOnly ? [] : ['string', 'KeyObject'])],\n+        key);\n+    }\n+  }\n+  return key;\n+}\n+\n+function createSecretKey(key) {\n+  key = prepareSecretKey(key, true);\n+  if (key.byteLength === 0)\n+    throw new ERR_OUT_OF_RANGE('key.byteLength', '> 0', key.byteLength);\n+  const handle = new KeyObjectHandle(kKeyTypeSecret);\n+  handle.init(key);\n+  return new SecretKeyObject(handle);\n+}\n+\n+function createPublicKey(key) {\n+  const { format, type, data } = preparePublicKey(key, false);\n+  const handle = new KeyObjectHandle(kKeyTypePublic);\n+  handle.init(data, format, type);\n+  return new PublicKeyObject(handle);\n+}\n+\n+function createPrivateKey(key) {\n+  const { format, type, data, passphrase } = preparePrivateKey(key, false);\n+  const handle = new KeyObjectHandle(kKeyTypePrivate);\n+  handle.init(data, format, type, passphrase);\n+  return new PrivateKeyObject(handle);\n+}\n+\n+function isKeyObject(key) {\n+  return key instanceof KeyObject;\n+}\n+\n+module.exports = {\n+  // Public API.\n+  createSecretKey,\n+  createPublicKey,\n+  createPrivateKey,\n+\n+  // These are designed for internal use only and should not be exposed.\n+  parsePublicKeyEncoding,\n+  parsePrivateKeyEncoding,\n+  preparePublicKey,\n+  preparePrivateKey,\n+  preparePublicOrPrivateKey,\n+  prepareSecretKey,\n+  SecretKeyObject,\n+  PublicKeyObject,\n+  PrivateKeyObject,\n+  isKeyObject\n+};"
        },
        {
            "sha": "32f7c37ec271f9b39261ccbafb2264e78b93c75d",
            "filename": "lib/internal/crypto/sig.js",
            "status": "modified",
            "additions": 18,
            "deletions": 13,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fsig.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Fcrypto%2Fsig.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fsig.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -17,6 +17,10 @@ const {\n   toBuf,\n   validateArrayBufferView,\n } = require('internal/crypto/util');\n+const {\n+  preparePrivateKey,\n+  preparePublicKey\n+} = require('internal/crypto/keys');\n const { Writable } = require('stream');\n \n function Sign(algorithm, options) {\n@@ -71,21 +75,18 @@ Sign.prototype.sign = function sign(options, encoding) {\n   if (!options)\n     throw new ERR_CRYPTO_SIGN_KEY_REQUIRED();\n \n-  var key = options.key || options;\n-  var passphrase = options.passphrase || null;\n+  const { data, format, type, passphrase } = preparePrivateKey(options, true);\n \n   // Options specific to RSA\n-  var rsaPadding = getPadding(options);\n-\n-  var pssSaltLength = getSaltLength(options);\n+  const rsaPadding = getPadding(options);\n+  const pssSaltLength = getSaltLength(options);\n \n-  key = validateArrayBufferView(key, 'key');\n-\n-  var ret = this[kHandle].sign(key, passphrase, rsaPadding, pssSaltLength);\n+  const ret = this[kHandle].sign(data, format, type, passphrase, rsaPadding,\n+                                 pssSaltLength);\n \n   encoding = encoding || getDefaultEncoding();\n   if (encoding && encoding !== 'buffer')\n-    ret = ret.toString(encoding);\n+    return ret.toString(encoding);\n \n   return ret;\n };\n@@ -108,20 +109,24 @@ Verify.prototype._write = Sign.prototype._write;\n Verify.prototype.update = Sign.prototype.update;\n \n Verify.prototype.verify = function verify(options, signature, sigEncoding) {\n-  var key = options.key || options;\n+  const {\n+    data,\n+    format,\n+    type\n+  } = preparePublicKey(options, true);\n+\n   sigEncoding = sigEncoding || getDefaultEncoding();\n \n   // Options specific to RSA\n   var rsaPadding = getPadding(options);\n \n   var pssSaltLength = getSaltLength(options);\n \n-  key = validateArrayBufferView(key, 'key');\n-\n   signature = validateArrayBufferView(toBuf(signature, sigEncoding),\n                                       'signature');\n \n-  return this[kHandle].verify(key, signature, rsaPadding, pssSaltLength);\n+  return this[kHandle].verify(data, format, type, signature,\n+                              rsaPadding, pssSaltLength);\n };\n \n legacyNativeHandle(Verify);"
        },
        {
            "sha": "8be692ef5777dbe914dd75cc70dde331b678384f",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -573,6 +573,8 @@ E('ERR_CRYPTO_HASH_UPDATE_FAILED', 'Hash update failed', Error);\n E('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS', 'The selected key encoding %s %s.',\n   Error);\n E('ERR_CRYPTO_INVALID_DIGEST', 'Invalid digest: %s', TypeError);\n+E('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE',\n+  'Invalid key object type %s, expected %s.', TypeError);\n E('ERR_CRYPTO_INVALID_STATE', 'Invalid state for operation %s', Error);\n E('ERR_CRYPTO_PBKDF2_ERROR', 'PBKDF2 error', Error);\n E('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER', 'Invalid scrypt parameter', Error);"
        },
        {
            "sha": "8c42ef446e70b6296f7210f41574168eeb6d55f1",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -102,6 +102,7 @@\n       'lib/internal/crypto/diffiehellman.js',\n       'lib/internal/crypto/hash.js',\n       'lib/internal/crypto/keygen.js',\n+      'lib/internal/crypto/keys.js',\n       'lib/internal/crypto/pbkdf2.js',\n       'lib/internal/crypto/random.js',\n       'lib/internal/crypto/scrypt.js',"
        },
        {
            "sha": "3b7625977343c1209019e0058a13857b97aa18c2",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -142,6 +142,9 @@ constexpr size_t kFsStatsBufferLength = kFsStatsFieldsNumber * 2;\n   V(code_string, \"code\")                                                       \\\n   V(config_string, \"config\")                                                   \\\n   V(constants_string, \"constants\")                                             \\\n+  V(crypto_dsa_string, \"dsa\")                                                  \\\n+  V(crypto_ec_string, \"ec\")                                                    \\\n+  V(crypto_rsa_string, \"rsa\")                                                  \\\n   V(cwd_string, \"cwd\")                                                         \\\n   V(dest_string, \"dest\")                                                       \\\n   V(destroyed_string, \"destroyed\")                                             \\\n@@ -324,6 +327,7 @@ constexpr size_t kFsStatsBufferLength = kFsStatsFieldsNumber * 2;\n   V(async_wrap_object_ctor_template, v8::FunctionTemplate)                     \\\n   V(buffer_prototype_object, v8::Object)                                       \\\n   V(context, v8::Context)                                                      \\\n+  V(crypto_key_object_constructor, v8::Function)                               \\\n   V(domain_callback, v8::Function)                                             \\\n   V(domexception_function, v8::Function)                                       \\\n   V(fd_constructor_template, v8::ObjectTemplate)                               \\"
        },
        {
            "sha": "b6b8063ccb4eab6a4a4a5dbc665d107d61516790",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 927,
            "deletions": 365,
            "changes": 1292,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -73,6 +73,7 @@ using v8::DontDelete;\n using v8::EscapableHandleScope;\n using v8::Exception;\n using v8::External;\n+using v8::Function;\n using v8::FunctionCallback;\n using v8::FunctionCallbackInfo;\n using v8::FunctionTemplate;\n@@ -2695,6 +2696,837 @@ static bool IsSupportedAuthenticatedMode(const EVP_CIPHER_CTX* ctx) {\n   return IsSupportedAuthenticatedMode(cipher);\n }\n \n+template <typename T>\n+static T* MallocOpenSSL(size_t count) {\n+  void* mem = OPENSSL_malloc(MultiplyWithOverflowCheck(count, sizeof(T)));\n+  CHECK_NOT_NULL(mem);\n+  return static_cast<T*>(mem);\n+}\n+\n+enum class ParsePublicKeyResult {\n+  kParsePublicOk,\n+  kParsePublicNotRecognized,\n+  kParsePublicFailed\n+};\n+\n+static ParsePublicKeyResult TryParsePublicKey(\n+    EVPKeyPointer* pkey,\n+    const BIOPointer& bp,\n+    const char* name,\n+    // NOLINTNEXTLINE(runtime/int)\n+    std::function<EVP_PKEY*(const unsigned char** p, long l)> parse) {\n+  unsigned char* der_data;\n+  long der_len;  // NOLINT(runtime/int)\n+\n+  // This skips surrounding data and decodes PEM to DER.\n+  {\n+    MarkPopErrorOnReturn mark_pop_error_on_return;\n+    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,\n+                           bp.get(), nullptr, nullptr) != 1)\n+      return ParsePublicKeyResult::kParsePublicNotRecognized;\n+  }\n+\n+  // OpenSSL might modify the pointer, so we need to make a copy before parsing.\n+  const unsigned char* p = der_data;\n+  pkey->reset(parse(&p, der_len));\n+  OPENSSL_clear_free(der_data, der_len);\n+\n+  return *pkey ? ParsePublicKeyResult::kParsePublicOk :\n+                 ParsePublicKeyResult::kParsePublicFailed;\n+}\n+\n+static ParsePublicKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,\n+                                              const char* key_pem,\n+                                              int key_pem_len,\n+                                              bool allow_certificate) {\n+  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n+  if (!bp)\n+    return ParsePublicKeyResult::kParsePublicFailed;\n+\n+  ParsePublicKeyResult ret;\n+\n+  // Try PKCS#8 first.\n+  ret = TryParsePublicKey(pkey, bp, \"PUBLIC KEY\",\n+      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n+        return d2i_PUBKEY(nullptr, p, l);\n+      });\n+  if (ret != ParsePublicKeyResult::kParsePublicNotRecognized)\n+    return ret;\n+\n+  // Maybe it is PKCS#1.\n+  CHECK(BIO_reset(bp.get()));\n+  ret = TryParsePublicKey(pkey, bp, \"RSA PUBLIC KEY\",\n+      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n+        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);\n+      });\n+  if (ret != ParsePublicKeyResult::kParsePublicNotRecognized ||\n+      !allow_certificate)\n+    return ret;\n+\n+  // X.509 fallback.\n+  CHECK(BIO_reset(bp.get()));\n+  return TryParsePublicKey(pkey, bp, \"CERTIFICATE\",\n+      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n+        X509Pointer x509(d2i_X509(nullptr, p, l));\n+        return x509 ? X509_get_pubkey(x509.get()) : nullptr;\n+      });\n+}\n+\n+static bool ParsePublicKey(EVPKeyPointer* pkey,\n+                           const PublicKeyEncodingConfig& config,\n+                           const char* key,\n+                           size_t key_len,\n+                           bool allow_certificate) {\n+  if (config.format_ == kKeyFormatPEM) {\n+    ParsePublicKeyResult r =\n+        ParsePublicKeyPEM(pkey, key, key_len, allow_certificate);\n+    return r == ParsePublicKeyResult::kParsePublicOk;\n+  } else {\n+    CHECK_EQ(config.format_, kKeyFormatDER);\n+    const unsigned char* p = reinterpret_cast<const unsigned char*>(key);\n+    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {\n+      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));\n+      return pkey;\n+    } else {\n+      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);\n+      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));\n+      return pkey;\n+    }\n+  }\n+}\n+\n+static inline Local<Value> BIOToStringOrBuffer(Environment* env,\n+                                               BIO* bio,\n+                                               PKFormatType format) {\n+  BUF_MEM* bptr;\n+  BIO_get_mem_ptr(bio, &bptr);\n+  if (format == kKeyFormatPEM) {\n+    // PEM is an ASCII format, so we will return it as a string.\n+    return String::NewFromUtf8(env->isolate(), bptr->data,\n+                               NewStringType::kNormal,\n+                               bptr->length).ToLocalChecked();\n+  } else {\n+    CHECK_EQ(format, kKeyFormatDER);\n+    // DER is binary, return it as a buffer.\n+    return Buffer::Copy(env, bptr->data, bptr->length).ToLocalChecked();\n+  }\n+}\n+\n+static bool WritePublicKeyInner(EVP_PKEY* pkey,\n+                                const BIOPointer& bio,\n+                                const PublicKeyEncodingConfig& config) {\n+  if (config.type_.ToChecked() == kKeyEncodingPKCS1) {\n+    // PKCS#1 is only valid for RSA keys.\n+    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);\n+    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));\n+    if (config.format_ == kKeyFormatPEM) {\n+      // Encode PKCS#1 as PEM.\n+      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;\n+    } else {\n+      // Encode PKCS#1 as DER.\n+      CHECK_EQ(config.format_, kKeyFormatDER);\n+      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;\n+    }\n+  } else {\n+    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);\n+    if (config.format_ == kKeyFormatPEM) {\n+      // Encode SPKI as PEM.\n+      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;\n+    } else {\n+      // Encode SPKI as DER.\n+      CHECK_EQ(config.format_, kKeyFormatDER);\n+      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;\n+    }\n+  }\n+}\n+\n+static MaybeLocal<Value> WritePublicKey(Environment* env,\n+                                        EVP_PKEY* pkey,\n+                                        const PublicKeyEncodingConfig& config) {\n+  BIOPointer bio(BIO_new(BIO_s_mem()));\n+  CHECK(bio);\n+\n+  if (!WritePublicKeyInner(pkey, bio, config)) {\n+    ThrowCryptoError(env, ERR_get_error(), \"Failed to encode public key\");\n+    return MaybeLocal<Value>();\n+  }\n+  return BIOToStringOrBuffer(env, bio.get(), config.format_);\n+}\n+\n+static EVPKeyPointer ParsePrivateKey(const PrivateKeyEncodingConfig& config,\n+                                     const char* key,\n+                                     size_t key_len) {\n+  EVPKeyPointer pkey;\n+\n+  if (config.format_ == kKeyFormatPEM) {\n+    BIOPointer bio(BIO_new_mem_buf(key, key_len));\n+    CHECK(bio);\n+\n+    char* pass = const_cast<char*>(config.passphrase_.get());\n+    pkey.reset(PEM_read_bio_PrivateKey(bio.get(),\n+                                       nullptr,\n+                                       PasswordCallback,\n+                                       pass));\n+  } else {\n+    CHECK_EQ(config.format_, kKeyFormatDER);\n+\n+    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {\n+      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);\n+      pkey.reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));\n+    } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {\n+      BIOPointer bio(BIO_new_mem_buf(key, key_len));\n+      CHECK(bio);\n+      char* pass = const_cast<char*>(config.passphrase_.get());\n+      pkey.reset(d2i_PKCS8PrivateKey_bio(bio.get(),\n+                                         nullptr,\n+                                         PasswordCallback,\n+                                         pass));\n+    } else {\n+      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSEC1);\n+      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);\n+      pkey.reset(d2i_PrivateKey(EVP_PKEY_EC, nullptr, &p, key_len));\n+    }\n+  }\n+\n+  // OpenSSL can fail to parse the key but still return a non-null pointer.\n+  if (ERR_peek_error() != 0)\n+    pkey.reset();\n+\n+  return pkey;\n+}\n+\n+ByteSource::ByteSource(ByteSource&& other)\n+      : data_(other.data_),\n+        allocated_data_(other.allocated_data_),\n+        size_(other.size_) {\n+  other.allocated_data_ = nullptr;\n+}\n+\n+ByteSource::~ByteSource() {\n+  OPENSSL_clear_free(allocated_data_, size_);\n+}\n+\n+ByteSource& ByteSource::operator=(ByteSource&& other) {\n+  if (&other != this) {\n+    OPENSSL_clear_free(allocated_data_, size_);\n+    data_ = other.data_;\n+    allocated_data_ = other.allocated_data_;\n+    other.allocated_data_ = nullptr;\n+    size_ = other.size_;\n+  }\n+  return *this;\n+}\n+\n+const char* ByteSource::get() const {\n+  return data_;\n+}\n+\n+size_t ByteSource::size() const {\n+  return size_;\n+}\n+\n+ByteSource ByteSource::FromStringOrBuffer(Environment* env,\n+                                          Local<Value> value) {\n+  return Buffer::HasInstance(value) ? FromBuffer(value)\n+                                    : FromString(env, value.As<String>());\n+}\n+\n+ByteSource ByteSource::FromString(Environment* env, Local<String> str,\n+                                  bool ntc) {\n+  CHECK(str->IsString());\n+  size_t size = str->Utf8Length(env->isolate());\n+  size_t alloc_size = ntc ? size + 1 : size;\n+  char* data = MallocOpenSSL<char>(alloc_size);\n+  int opts = String::NO_OPTIONS;\n+  if (!ntc) opts |= String::NO_NULL_TERMINATION;\n+  str->WriteUtf8(env->isolate(), data, alloc_size, nullptr, opts);\n+  return Allocated(data, size);\n+}\n+\n+ByteSource ByteSource::FromBuffer(Local<Value> buffer, bool ntc) {\n+  size_t size = Buffer::Length(buffer);\n+  if (ntc) {\n+    char* data = MallocOpenSSL<char>(size + 1);\n+    memcpy(data, Buffer::Data(buffer), size);\n+    data[size] = 0;\n+    return Allocated(data, size);\n+  }\n+  return Foreign(Buffer::Data(buffer), size);\n+}\n+\n+ByteSource ByteSource::NullTerminatedCopy(Environment* env,\n+                                          Local<Value> value) {\n+  return Buffer::HasInstance(value) ? FromBuffer(value, true)\n+                                    : FromString(env, value.As<String>(), true);\n+}\n+\n+ByteSource ByteSource::FromSymmetricKeyObject(Local<Value> handle) {\n+  CHECK(handle->IsObject());\n+  KeyObject* key = Unwrap<KeyObject>(handle.As<Object>());\n+  CHECK(key);\n+  return Foreign(key->GetSymmetricKey(), key->GetSymmetricKeySize());\n+}\n+\n+ByteSource::ByteSource(const char* data, char* allocated_data, size_t size)\n+      : data_(data),\n+        allocated_data_(allocated_data),\n+        size_(size) {}\n+\n+ByteSource ByteSource::Allocated(char* data, size_t size) {\n+  return ByteSource(data, data, size);\n+}\n+\n+ByteSource ByteSource::Foreign(const char* data, size_t size) {\n+  return ByteSource(data, nullptr, size);\n+}\n+\n+enum KeyEncodingContext {\n+  kKeyContextInput,\n+  kKeyContextExport,\n+  kKeyContextGenerate\n+};\n+\n+static void GetKeyFormatAndTypeFromJs(\n+    AsymmetricKeyEncodingConfig* config,\n+    const FunctionCallbackInfo<Value>& args,\n+    unsigned int* offset,\n+    KeyEncodingContext context) {\n+  // During key pair generation, it is possible not to specify a key encoding,\n+  // which will lead to a key object being returned.\n+  if (args[*offset]->IsUndefined()) {\n+    CHECK_EQ(context, kKeyContextGenerate);\n+    CHECK(args[*offset + 1]->IsUndefined());\n+    config->output_key_object_ = true;\n+  } else {\n+    config->output_key_object_ = false;\n+\n+    CHECK(args[*offset]->IsInt32());\n+    config->format_ = static_cast<PKFormatType>(\n+        args[*offset].As<Int32>()->Value());\n+\n+    if (args[*offset + 1]->IsInt32()) {\n+      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(\n+          args[*offset + 1].As<Int32>()->Value()));\n+    } else {\n+      CHECK(context == kKeyContextInput && config->format_ == kKeyFormatPEM);\n+      CHECK(args[*offset + 1]->IsNullOrUndefined());\n+      config->type_ = Nothing<PKEncodingType>();\n+    }\n+  }\n+\n+  *offset += 2;\n+}\n+\n+static PublicKeyEncodingConfig GetPublicKeyEncodingFromJs(\n+    const FunctionCallbackInfo<Value>& args,\n+    unsigned int* offset,\n+    KeyEncodingContext context) {\n+  PublicKeyEncodingConfig result;\n+  GetKeyFormatAndTypeFromJs(&result, args, offset, context);\n+  return result;\n+}\n+\n+static ManagedEVPPKey GetPublicKeyFromJs(\n+    const FunctionCallbackInfo<Value>& args,\n+    unsigned int* offset,\n+    bool allow_key_object,\n+    bool allow_certificate) {\n+  if (args[*offset]->IsString() || Buffer::HasInstance(args[*offset])) {\n+    Environment* env = Environment::GetCurrent(args);\n+    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);\n+    PublicKeyEncodingConfig config =\n+        GetPublicKeyEncodingFromJs(args, offset, kKeyContextInput);\n+    EVPKeyPointer pkey;\n+    ParsePublicKey(&pkey, config, key.get(), key.size(), allow_certificate);\n+    if (!pkey)\n+      ThrowCryptoError(env, ERR_get_error(), \"Failed to read public key\");\n+    return ManagedEVPPKey(pkey.release());\n+  } else {\n+    CHECK(args[*offset]->IsObject() && allow_key_object);\n+    KeyObject* key;\n+    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());\n+    CHECK_EQ(key->GetKeyType(), kKeyTypePublic);\n+    (*offset) += 3;\n+    return key->GetAsymmetricKey();\n+  }\n+}\n+\n+static NonCopyableMaybe<PrivateKeyEncodingConfig> GetPrivateKeyEncodingFromJs(\n+    const FunctionCallbackInfo<Value>& args,\n+    unsigned int* offset,\n+    KeyEncodingContext context) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  PrivateKeyEncodingConfig result;\n+  GetKeyFormatAndTypeFromJs(&result, args, offset, context);\n+\n+  if (result.output_key_object_) {\n+    if (context != kKeyContextInput)\n+      (*offset)++;\n+  } else {\n+    bool needs_passphrase = false;\n+    if (context != kKeyContextInput) {\n+      if (args[*offset]->IsString()) {\n+        String::Utf8Value cipher_name(env->isolate(),\n+                                      args[*offset].As<String>());\n+        result.cipher_ = EVP_get_cipherbyname(*cipher_name);\n+        if (result.cipher_ == nullptr) {\n+          env->ThrowError(\"Unknown cipher\");\n+          return NonCopyableMaybe<PrivateKeyEncodingConfig>();\n+        }\n+        needs_passphrase = true;\n+      } else {\n+        CHECK(args[*offset]->IsNullOrUndefined());\n+        result.cipher_ = nullptr;\n+      }\n+      (*offset)++;\n+    }\n+\n+    if (args[*offset]->IsString() || Buffer::HasInstance(args[*offset])) {\n+      CHECK_IMPLIES(context != kKeyContextInput, result.cipher_ != nullptr);\n+\n+      result.passphrase_ = ByteSource::NullTerminatedCopy(env, args[*offset]);\n+    } else {\n+      CHECK(args[*offset]->IsNullOrUndefined() && !needs_passphrase);\n+    }\n+  }\n+\n+  (*offset)++;\n+  return NonCopyableMaybe<PrivateKeyEncodingConfig>(std::move(result));\n+}\n+\n+static ManagedEVPPKey GetPrivateKeyFromJs(\n+    const FunctionCallbackInfo<Value>& args,\n+    unsigned int* offset,\n+    bool allow_key_object) {\n+  if (args[*offset]->IsString() || Buffer::HasInstance(args[*offset])) {\n+    Environment* env = Environment::GetCurrent(args);\n+    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);\n+    NonCopyableMaybe<PrivateKeyEncodingConfig> config =\n+        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);\n+    if (config.IsEmpty())\n+      return ManagedEVPPKey();\n+    EVPKeyPointer pkey =\n+        ParsePrivateKey(config.Release(), key.get(), key.size());\n+    if (!pkey)\n+      ThrowCryptoError(env, ERR_get_error(), \"Failed to read private key\");\n+    return ManagedEVPPKey(pkey.release());\n+  } else {\n+    CHECK(args[*offset]->IsObject() && allow_key_object);\n+    KeyObject* key;\n+    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());\n+    CHECK_EQ(key->GetKeyType(), kKeyTypePrivate);\n+    (*offset) += 4;\n+    return key->GetAsymmetricKey();\n+  }\n+}\n+\n+static bool IsRSAPrivateKey(const unsigned char* data, size_t size) {\n+  // Both RSAPrivateKey and RSAPublicKey structures start with a SEQUENCE.\n+  if (size >= 2 && data[0] == 0x30) {\n+    size_t offset;\n+    if (data[1] & 0x80) {\n+      // Long form.\n+      size_t n_bytes = data[1] & ~0x80;\n+      if (n_bytes + 2 > size || n_bytes > sizeof(size_t))\n+        return false;\n+      size_t i, length = 0;\n+      for (i = 0; i < n_bytes; i++)\n+        length = (length << 8) | data[i + 2];\n+      offset = 2 + n_bytes;\n+      size = std::min(size, length + 2);\n+    } else {\n+      // Short form.\n+      offset = 2;\n+      size = std::min<size_t>(size, data[1] + 2);\n+    }\n+\n+    // An RSAPrivateKey sequence always starts with a single-byte integer whose\n+    // value is either 0 or 1, whereas an RSAPublicKey starts with the modulus\n+    // (which is the product of two primes and therefore at least 4), so we can\n+    // decide the type of the structure based on the first three bytes of the\n+    // sequence.\n+    return size - offset >= 3 &&\n+           data[offset] == 2 &&\n+           data[offset + 1] == 1 &&\n+           !(data[offset + 2] & 0xfe);\n+  }\n+\n+  return false;\n+}\n+\n+static ManagedEVPPKey GetPublicOrPrivateKeyFromJs(\n+    const FunctionCallbackInfo<Value>& args,\n+    unsigned int* offset,\n+    bool allow_key_object,\n+    bool allow_certificate) {\n+  if (args[*offset]->IsString() || Buffer::HasInstance(args[*offset])) {\n+    Environment* env = Environment::GetCurrent(args);\n+    ByteSource data = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);\n+    NonCopyableMaybe<PrivateKeyEncodingConfig> config_ =\n+        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);\n+    if (config_.IsEmpty())\n+      return ManagedEVPPKey();\n+    PrivateKeyEncodingConfig config = config_.Release();\n+    EVPKeyPointer pkey;\n+    if (config.format_ == kKeyFormatPEM) {\n+      // For PEM, we can easily determine whether it is a public or private key\n+      // by looking for the respective PEM tags.\n+      ParsePublicKeyResult ret = ParsePublicKeyPEM(&pkey, data.get(),\n+                                                   data.size(),\n+                                                   allow_certificate);\n+      if (ret == ParsePublicKeyResult::kParsePublicNotRecognized) {\n+        pkey = ParsePrivateKey(config, data.get(), data.size());\n+      }\n+    } else {\n+      // For DER, the type determines how to parse it. SPKI, PKCS#8 and SEC1 are\n+      // easy, but PKCS#1 can be a public key or a private key.\n+      bool is_public;\n+      switch (config.type_.ToChecked()) {\n+        case kKeyEncodingPKCS1:\n+          is_public = !IsRSAPrivateKey(\n+              reinterpret_cast<const unsigned char*>(data.get()), data.size());\n+          break;\n+        case kKeyEncodingSPKI:\n+          is_public = true;\n+          break;\n+        case kKeyEncodingPKCS8:\n+        case kKeyEncodingSEC1:\n+          is_public = false;\n+          break;\n+        default:\n+          CHECK(!\"Invalid key encoding type\");\n+      }\n+\n+      if (is_public) {\n+        ParsePublicKey(&pkey, config, data.get(), data.size(),\n+                       allow_certificate);\n+      } else {\n+        pkey = ParsePrivateKey(config, data.get(), data.size());\n+      }\n+    }\n+    if (!pkey)\n+      ThrowCryptoError(env, ERR_get_error(), \"Failed to read asymmetric key\");\n+    return ManagedEVPPKey(pkey.release());\n+  } else {\n+    CHECK(args[*offset]->IsObject() && allow_key_object);\n+    KeyObject* key = Unwrap<KeyObject>(args[*offset].As<Object>());\n+    CHECK(key);\n+    CHECK_NE(key->GetKeyType(), kKeyTypeSecret);\n+    (*offset) += 4;\n+    return key->GetAsymmetricKey();\n+  }\n+}\n+\n+static MaybeLocal<Value> WritePrivateKey(\n+    Environment* env,\n+    EVP_PKEY* pkey,\n+    const PrivateKeyEncodingConfig& config) {\n+  BIOPointer bio(BIO_new(BIO_s_mem()));\n+  CHECK(bio);\n+\n+  bool err;\n+\n+  if (config.type_.ToChecked() == kKeyEncodingPKCS1) {\n+    // PKCS#1 is only permitted for RSA keys.\n+    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);\n+\n+    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));\n+    if (config.format_ == kKeyFormatPEM) {\n+      // Encode PKCS#1 as PEM.\n+      const char* pass = config.passphrase_.get();\n+      err = PEM_write_bio_RSAPrivateKey(\n+                bio.get(), rsa.get(),\n+                config.cipher_,\n+                reinterpret_cast<unsigned char*>(const_cast<char*>(pass)),\n+                config.passphrase_.size(),\n+                nullptr, nullptr) != 1;\n+    } else {\n+      // Encode PKCS#1 as DER. This does not permit encryption.\n+      CHECK_EQ(config.format_, kKeyFormatDER);\n+      CHECK_NULL(config.cipher_);\n+      err = i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1;\n+    }\n+  } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {\n+    if (config.format_ == kKeyFormatPEM) {\n+      // Encode PKCS#8 as PEM.\n+      err = PEM_write_bio_PKCS8PrivateKey(\n+                bio.get(), pkey,\n+                config.cipher_,\n+                const_cast<char*>(config.passphrase_.get()),\n+                config.passphrase_.size(),\n+                nullptr, nullptr) != 1;\n+    } else {\n+      // Encode PKCS#8 as DER.\n+      CHECK_EQ(config.format_, kKeyFormatDER);\n+      err = i2d_PKCS8PrivateKey_bio(\n+                bio.get(), pkey,\n+                config.cipher_,\n+                const_cast<char*>(config.passphrase_.get()),\n+                config.passphrase_.size(),\n+                nullptr, nullptr) != 1;\n+    }\n+  } else {\n+    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSEC1);\n+\n+    // SEC1 is only permitted for EC keys.\n+    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_EC);\n+\n+    ECKeyPointer ec_key(EVP_PKEY_get1_EC_KEY(pkey));\n+    if (config.format_ == kKeyFormatPEM) {\n+      // Encode SEC1 as PEM.\n+      const char* pass = config.passphrase_.get();\n+      err = PEM_write_bio_ECPrivateKey(\n+                bio.get(), ec_key.get(),\n+                config.cipher_,\n+                reinterpret_cast<unsigned char*>(const_cast<char*>(pass)),\n+                config.passphrase_.size(),\n+                nullptr, nullptr) != 1;\n+    } else {\n+      // Encode SEC1 as DER. This does not permit encryption.\n+      CHECK_EQ(config.format_, kKeyFormatDER);\n+      CHECK_NULL(config.cipher_);\n+      err = i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1;\n+    }\n+  }\n+\n+  if (err) {\n+    ThrowCryptoError(env, ERR_get_error(), \"Failed to encode private key\");\n+    return MaybeLocal<Value>();\n+  }\n+  return BIOToStringOrBuffer(env, bio.get(), config.format_);\n+}\n+\n+ManagedEVPPKey::ManagedEVPPKey() : pkey_(nullptr) {}\n+\n+ManagedEVPPKey::ManagedEVPPKey(EVP_PKEY* pkey) : pkey_(pkey) {}\n+\n+ManagedEVPPKey::ManagedEVPPKey(const ManagedEVPPKey& key) : pkey_(nullptr) {\n+  *this = key;\n+}\n+\n+ManagedEVPPKey::ManagedEVPPKey(ManagedEVPPKey&& key) {\n+  *this = key;\n+}\n+\n+ManagedEVPPKey::~ManagedEVPPKey() {\n+  EVP_PKEY_free(pkey_);\n+}\n+\n+ManagedEVPPKey& ManagedEVPPKey::operator=(const ManagedEVPPKey& key) {\n+  EVP_PKEY_free(pkey_);\n+  pkey_ = key.pkey_;\n+  EVP_PKEY_up_ref(pkey_);\n+  return *this;\n+}\n+\n+ManagedEVPPKey& ManagedEVPPKey::operator=(ManagedEVPPKey&& key) {\n+  EVP_PKEY_free(pkey_);\n+  pkey_ = key.pkey_;\n+  key.pkey_ = nullptr;\n+  return *this;\n+}\n+\n+ManagedEVPPKey::operator bool() const {\n+  return pkey_ != nullptr;\n+}\n+\n+EVP_PKEY* ManagedEVPPKey::get() const {\n+  return pkey_;\n+}\n+\n+Local<Function> KeyObject::Initialize(Environment* env, Local<Object> target) {\n+  Local<FunctionTemplate> t = env->NewFunctionTemplate(New);\n+  t->InstanceTemplate()->SetInternalFieldCount(1);\n+\n+  env->SetProtoMethod(t, \"init\", Init);\n+  env->SetProtoMethodNoSideEffect(t, \"getSymmetricKeySize\",\n+                                  GetSymmetricKeySize);\n+  env->SetProtoMethodNoSideEffect(t, \"getAsymmetricKeyType\",\n+                                  GetAsymmetricKeyType);\n+  env->SetProtoMethod(t, \"export\", Export);\n+\n+  target->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"KeyObject\"),\n+              t->GetFunction(env->context()).ToLocalChecked());\n+\n+  return t->GetFunction();\n+}\n+\n+Local<Object> KeyObject::Create(Environment* env,\n+                                KeyType key_type,\n+                                const ManagedEVPPKey& pkey) {\n+  CHECK_NE(key_type, kKeyTypeSecret);\n+  Local<Value> type = Integer::New(env->isolate(), key_type);\n+  Local<Object> obj =\n+      env->crypto_key_object_constructor()->NewInstance(env->context(),\n+                                                        1, &type)\n+      .ToLocalChecked();\n+  KeyObject* key = Unwrap<KeyObject>(obj);\n+  CHECK(key);\n+  if (key_type == kKeyTypePublic)\n+    key->InitPublic(pkey);\n+  else\n+    key->InitPrivate(pkey);\n+  return obj;\n+}\n+\n+ManagedEVPPKey KeyObject::GetAsymmetricKey() const {\n+  CHECK_NE(key_type_, kKeyTypeSecret);\n+  return this->asymmetric_key_;\n+}\n+\n+const char* KeyObject::GetSymmetricKey() const {\n+  CHECK_EQ(key_type_, kKeyTypeSecret);\n+  return this->symmetric_key_.get();\n+}\n+\n+size_t KeyObject::GetSymmetricKeySize() const {\n+  CHECK_EQ(key_type_, kKeyTypeSecret);\n+  return this->symmetric_key_len_;\n+}\n+\n+void KeyObject::New(const FunctionCallbackInfo<Value>& args) {\n+  CHECK(args.IsConstructCall());\n+  CHECK(args[0]->IsInt32());\n+  KeyType key_type = static_cast<KeyType>(args[0].As<Uint32>()->Value());\n+  Environment* env = Environment::GetCurrent(args);\n+  new KeyObject(env, args.This(), key_type);\n+}\n+\n+KeyType KeyObject::GetKeyType() const {\n+  return this->key_type_;\n+}\n+\n+void KeyObject::Init(const FunctionCallbackInfo<Value>& args) {\n+  KeyObject* key;\n+  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());\n+\n+  unsigned int offset;\n+  ManagedEVPPKey pkey;\n+\n+  switch (key->key_type_) {\n+  case kKeyTypeSecret:\n+    CHECK_EQ(args.Length(), 1);\n+    key->InitSecret(Buffer::Data(args[0]), Buffer::Length(args[0]));\n+    break;\n+  case kKeyTypePublic:\n+    CHECK_EQ(args.Length(), 3);\n+\n+    offset = 0;\n+    pkey = GetPublicKeyFromJs(args, &offset, false, false);\n+    if (!pkey)\n+      return;\n+    key->InitPublic(pkey);\n+    break;\n+  case kKeyTypePrivate:\n+    CHECK_EQ(args.Length(), 4);\n+\n+    offset = 0;\n+    pkey = GetPrivateKeyFromJs(args, &offset, false);\n+    if (!pkey)\n+      return;\n+    key->InitPrivate(pkey);\n+    break;\n+  default:\n+    CHECK(false);\n+  }\n+}\n+\n+void KeyObject::InitSecret(const char* key, size_t key_len) {\n+  CHECK_EQ(this->key_type_, kKeyTypeSecret);\n+\n+  char* mem = MallocOpenSSL<char>(key_len);\n+  memcpy(mem, key, key_len);\n+  this->symmetric_key_ = std::unique_ptr<char, std::function<void(char*)>>(mem,\n+      [key_len](char* p) {\n+        OPENSSL_clear_free(p, key_len);\n+      });\n+  this->symmetric_key_len_ = key_len;\n+}\n+\n+void KeyObject::InitPublic(const ManagedEVPPKey& pkey) {\n+  CHECK_EQ(this->key_type_, kKeyTypePublic);\n+  CHECK(pkey);\n+  this->asymmetric_key_ = pkey;\n+}\n+\n+void KeyObject::InitPrivate(const ManagedEVPPKey& pkey) {\n+  CHECK_EQ(this->key_type_, kKeyTypePrivate);\n+  CHECK(pkey);\n+  this->asymmetric_key_ = pkey;\n+}\n+\n+Local<String> KeyObject::GetAsymmetricKeyType() const {\n+  CHECK_NE(this->key_type_, kKeyTypeSecret);\n+  switch (EVP_PKEY_id(this->asymmetric_key_.get())) {\n+  case EVP_PKEY_RSA:\n+    return env()->crypto_rsa_string();\n+  case EVP_PKEY_DSA:\n+    return env()->crypto_dsa_string();\n+  case EVP_PKEY_EC:\n+    return env()->crypto_ec_string();\n+  default:\n+    CHECK(false);\n+  }\n+}\n+\n+void KeyObject::GetAsymmetricKeyType(const FunctionCallbackInfo<Value>& args) {\n+  KeyObject* key;\n+  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());\n+\n+  args.GetReturnValue().Set(key->GetAsymmetricKeyType());\n+}\n+\n+void KeyObject::GetSymmetricKeySize(const FunctionCallbackInfo<Value>& args) {\n+  KeyObject* key;\n+  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());\n+  args.GetReturnValue().Set(static_cast<uint32_t>(key->GetSymmetricKeySize()));\n+}\n+\n+void KeyObject::Export(const v8::FunctionCallbackInfo<v8::Value>& args) {\n+  KeyObject* key;\n+  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());\n+\n+  MaybeLocal<Value> result;\n+  if (key->key_type_ == kKeyTypeSecret) {\n+    result = key->ExportSecretKey();\n+  } else if (key->key_type_ == kKeyTypePublic) {\n+    unsigned int offset = 0;\n+    PublicKeyEncodingConfig config =\n+        GetPublicKeyEncodingFromJs(args, &offset, kKeyContextExport);\n+    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));\n+    result = key->ExportPublicKey(config);\n+  } else {\n+    CHECK_EQ(key->key_type_, kKeyTypePrivate);\n+    unsigned int offset = 0;\n+    NonCopyableMaybe<PrivateKeyEncodingConfig> config =\n+        GetPrivateKeyEncodingFromJs(args, &offset, kKeyContextExport);\n+    if (config.IsEmpty())\n+      return;\n+    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));\n+    result = key->ExportPrivateKey(config.Release());\n+  }\n+\n+  if (!result.IsEmpty())\n+    args.GetReturnValue().Set(result.ToLocalChecked());\n+}\n+\n+Local<Value> KeyObject::ExportSecretKey() const {\n+  return Buffer::Copy(env(), symmetric_key_.get(), symmetric_key_len_)\n+      .ToLocalChecked();\n+}\n+\n+MaybeLocal<Value> KeyObject::ExportPublicKey(\n+    const PublicKeyEncodingConfig& config) const {\n+  return WritePublicKey(env(), asymmetric_key_.get(), config);\n+}\n+\n+MaybeLocal<Value> KeyObject::ExportPrivateKey(\n+    const PrivateKeyEncodingConfig& config) const {\n+  return WritePrivateKey(env(), asymmetric_key_.get(), config);\n+}\n+\n+\n void CipherBase::Initialize(Environment* env, Local<Object> target) {\n   Local<FunctionTemplate> t = env->NewFunctionTemplate(New);\n \n@@ -2864,6 +3696,15 @@ void CipherBase::InitIv(const char* cipher_type,\n }\n \n \n+static ByteSource GetSecretKeyBytes(Environment* env, Local<Value> value) {\n+  // A key can be passed as a string, buffer or KeyObject with type 'secret'.\n+  // If it is a string, we need to convert it to a buffer. We are not doing that\n+  // in JS to avoid creating an unprotected copy on the heap.\n+  return value->IsString() || Buffer::HasInstance(value) ?\n+           ByteSource::FromStringOrBuffer(env, value) :\n+           ByteSource::FromSymmetricKeyObject(value);\n+}\n+\n void CipherBase::InitIv(const FunctionCallbackInfo<Value>& args) {\n   CipherBase* cipher;\n   ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());\n@@ -2872,9 +3713,8 @@ void CipherBase::InitIv(const FunctionCallbackInfo<Value>& args) {\n   CHECK_GE(args.Length(), 4);\n \n   const node::Utf8Value cipher_type(env->isolate(), args[0]);\n-  ssize_t key_len = Buffer::Length(args[1]);\n-  const unsigned char* key_buf = reinterpret_cast<unsigned char*>(\n-      Buffer::Data(args[1]));\n+  const ByteSource key = GetSecretKeyBytes(env, args[1]);\n+\n   ssize_t iv_len;\n   const unsigned char* iv_buf;\n   if (args[2]->IsNull()) {\n@@ -2895,7 +3735,12 @@ void CipherBase::InitIv(const FunctionCallbackInfo<Value>& args) {\n     auth_tag_len = kNoAuthTagLength;\n   }\n \n-  cipher->InitIv(*cipher_type, key_buf, key_len, iv_buf, iv_len, auth_tag_len);\n+  cipher->InitIv(*cipher_type,\n+                 reinterpret_cast<const unsigned char*>(key.get()),\n+                 key.size(),\n+                 iv_buf,\n+                 iv_len,\n+                 auth_tag_len);\n }\n \n \n@@ -3351,9 +4196,8 @@ void Hmac::HmacInit(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = hmac->env();\n \n   const node::Utf8Value hash_type(env->isolate(), args[0]);\n-  const char* buffer_data = Buffer::Data(args[1]);\n-  size_t buffer_length = Buffer::Length(args[1]);\n-  hmac->HmacInit(*hash_type, buffer_data, buffer_length);\n+  ByteSource key = GetSecretKeyBytes(env, args[1]);\n+  hmac->HmacInit(*hash_type, key.get(), key.size());\n }\n \n \n@@ -3602,7 +4446,7 @@ void SignBase::CheckThrow(SignBase::Error error) {\n   }\n }\n \n-static bool ApplyRSAOptions(const EVPKeyPointer& pkey,\n+static bool ApplyRSAOptions(const ManagedEVPPKey& pkey,\n                             EVP_PKEY_CTX* pkctx,\n                             int padding,\n                             int salt_len) {\n@@ -3664,7 +4508,7 @@ void Sign::SignUpdate(const FunctionCallbackInfo<Value>& args) {\n }\n \n static MallocedBuffer<unsigned char> Node_SignFinal(EVPMDPointer&& mdctx,\n-                                                    const EVPKeyPointer& pkey,\n+                                                    const ManagedEVPPKey& pkey,\n                                                     int padding,\n                                                     int pss_salt_len) {\n   unsigned char m[EVP_MAX_MD_SIZE];\n@@ -3693,31 +4537,14 @@ static MallocedBuffer<unsigned char> Node_SignFinal(EVPMDPointer&& mdctx,\n }\n \n Sign::SignResult Sign::SignFinal(\n-    const char* key_pem,\n-    int key_pem_len,\n-    const char* passphrase,\n+    const ManagedEVPPKey& pkey,\n     int padding,\n     int salt_len) {\n   if (!mdctx_)\n     return SignResult(kSignNotInitialised);\n \n   EVPMDPointer mdctx = std::move(mdctx_);\n \n-  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n-  if (!bp)\n-    return SignResult(kSignPrivateKey);\n-\n-  EVPKeyPointer pkey(PEM_read_bio_PrivateKey(bp.get(),\n-                                             nullptr,\n-                                             PasswordCallback,\n-                                             const_cast<char*>(passphrase)));\n-\n-  // Errors might be injected into OpenSSL's error stack\n-  // without `pkey` being set to nullptr;\n-  // cf. the test of `test_bad_rsa_privkey.pem` for an example.\n-  if (!pkey || 0 != ERR_peek_error())\n-    return SignResult(kSignPrivateKey);\n-\n #ifdef NODE_FIPS_MODE\n   /* Validate DSA2 parameters from FIPS 186-4 */\n   if (FIPS_mode() && EVP_PKEY_DSA == pkey->type) {\n@@ -3753,25 +4580,21 @@ void Sign::SignFinal(const FunctionCallbackInfo<Value>& args) {\n   Sign* sign;\n   ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());\n \n-  unsigned int len = args.Length();\n-\n-  node::Utf8Value passphrase(env->isolate(), args[1]);\n-\n-  size_t buf_len = Buffer::Length(args[0]);\n-  char* buf = Buffer::Data(args[0]);\n+  unsigned int offset = 0;\n+  ManagedEVPPKey key = GetPrivateKeyFromJs(args, &offset, true);\n+  if (!key)\n+    return;\n \n-  CHECK(args[2]->IsInt32());\n-  int padding = args[2].As<Int32>()->Value();\n+  CHECK(args[offset]->IsInt32());\n+  int padding = args[offset].As<Int32>()->Value();\n \n-  CHECK(args[3]->IsInt32());\n-  int salt_len = args[3].As<Int32>()->Value();\n+  CHECK(args[offset + 1]->IsInt32());\n+  int salt_len = args[offset + 1].As<Int32>()->Value();\n \n   ClearErrorOnReturn clear_error_on_return;\n \n   SignResult ret = sign->SignFinal(\n-      buf,\n-      buf_len,\n-      len >= 2 && !args[1]->IsNull() ? *passphrase : nullptr,\n+      key,\n       padding,\n       salt_len);\n \n@@ -3787,72 +4610,6 @@ void Sign::SignFinal(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(rc);\n }\n \n-enum ParsePublicKeyResult {\n-  kParsePublicOk,\n-  kParsePublicNotRecognized,\n-  kParsePublicFailed\n-};\n-\n-static ParsePublicKeyResult TryParsePublicKey(\n-    EVPKeyPointer* pkey,\n-    const BIOPointer& bp,\n-    const char* name,\n-    // NOLINTNEXTLINE(runtime/int)\n-    std::function<EVP_PKEY*(const unsigned char** p, long l)> parse) {\n-  unsigned char* der_data;\n-  long der_len;  // NOLINT(runtime/int)\n-\n-  // This skips surrounding data and decodes PEM to DER.\n-  {\n-    MarkPopErrorOnReturn mark_pop_error_on_return;\n-    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,\n-                           bp.get(), nullptr, nullptr) != 1)\n-      return kParsePublicNotRecognized;\n-  }\n-\n-  // OpenSSL might modify the pointer, so we need to make a copy before parsing.\n-  const unsigned char* p = der_data;\n-  pkey->reset(parse(&p, der_len));\n-  OPENSSL_clear_free(der_data, der_len);\n-\n-  return *pkey ? kParsePublicOk : kParsePublicFailed;\n-}\n-\n-static ParsePublicKeyResult ParsePublicKey(EVPKeyPointer* pkey,\n-                                           const char* key_pem,\n-                                           int key_pem_len) {\n-  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n-  if (!bp)\n-    return kParsePublicFailed;\n-\n-  ParsePublicKeyResult ret;\n-\n-  // Try PKCS#8 first.\n-  ret = TryParsePublicKey(pkey, bp, \"PUBLIC KEY\",\n-      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n-        return d2i_PUBKEY(nullptr, p, l);\n-      });\n-  if (ret != kParsePublicNotRecognized)\n-    return ret;\n-\n-  // Maybe it is PKCS#1.\n-  CHECK(BIO_reset(bp.get()));\n-  ret = TryParsePublicKey(pkey, bp, \"RSA PUBLIC KEY\",\n-      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n-        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);\n-      });\n-  if (ret != kParsePublicNotRecognized)\n-    return ret;\n-\n-  // X.509 fallback.\n-  CHECK(BIO_reset(bp.get()));\n-  return TryParsePublicKey(pkey, bp, \"CERTIFICATE\",\n-      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n-        X509Pointer x509(d2i_X509(nullptr, p, l));\n-        return x509 ? X509_get_pubkey(x509.get()) : nullptr;\n-      });\n-}\n-\n void Verify::Initialize(Environment* env, Local<Object> target) {\n   Local<FunctionTemplate> t = env->NewFunctionTemplate(New);\n \n@@ -3896,8 +4653,7 @@ void Verify::VerifyUpdate(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-SignBase::Error Verify::VerifyFinal(const char* key_pem,\n-                                    int key_pem_len,\n+SignBase::Error Verify::VerifyFinal(const ManagedEVPPKey& pkey,\n                                     const char* sig,\n                                     int siglen,\n                                     int padding,\n@@ -3906,15 +4662,11 @@ SignBase::Error Verify::VerifyFinal(const char* key_pem,\n   if (!mdctx_)\n     return kSignNotInitialised;\n \n-  EVPKeyPointer pkey;\n   unsigned char m[EVP_MAX_MD_SIZE];\n   unsigned int m_len;\n   *verify_result = false;\n   EVPMDPointer mdctx = std::move(mdctx_);\n \n-  if (ParsePublicKey(&pkey, key_pem, key_pem_len) != kParsePublicOk)\n-    return kSignPublicKey;\n-\n   if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))\n     return kSignPublicKey;\n \n@@ -3942,20 +4694,20 @@ void Verify::VerifyFinal(const FunctionCallbackInfo<Value>& args) {\n   Verify* verify;\n   ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());\n \n-  char* kbuf = Buffer::Data(args[0]);\n-  ssize_t klen = Buffer::Length(args[0]);\n+  unsigned int offset = 0;\n+  ManagedEVPPKey pkey = GetPublicKeyFromJs(args, &offset, true, true);\n \n-  char* hbuf = Buffer::Data(args[1]);\n-  ssize_t hlen = Buffer::Length(args[1]);\n+  char* hbuf = Buffer::Data(args[offset]);\n+  ssize_t hlen = Buffer::Length(args[offset]);\n \n-  CHECK(args[2]->IsInt32());\n-  int padding = args[2].As<Int32>()->Value();\n+  CHECK(args[offset + 1]->IsInt32());\n+  int padding = args[offset + 1].As<Int32>()->Value();\n \n-  CHECK(args[3]->IsInt32());\n-  int salt_len = args[3].As<Int32>()->Value();\n+  CHECK(args[offset + 2]->IsInt32());\n+  int salt_len = args[offset + 2].As<Int32>()->Value();\n \n   bool verify_result;\n-  Error err = verify->VerifyFinal(kbuf, klen, hbuf, hlen, padding, salt_len,\n+  Error err = verify->VerifyFinal(pkey, hbuf, hlen, padding, salt_len,\n                                   &verify_result);\n   if (err != kSignOk)\n     return verify->CheckThrow(err);\n@@ -3966,36 +4718,12 @@ void Verify::VerifyFinal(const FunctionCallbackInfo<Value>& args) {\n template <PublicKeyCipher::Operation operation,\n           PublicKeyCipher::EVP_PKEY_cipher_init_t EVP_PKEY_cipher_init,\n           PublicKeyCipher::EVP_PKEY_cipher_t EVP_PKEY_cipher>\n-bool PublicKeyCipher::Cipher(const char* key_pem,\n-                             int key_pem_len,\n-                             const char* passphrase,\n+bool PublicKeyCipher::Cipher(const ManagedEVPPKey& pkey,\n                              int padding,\n                              const unsigned char* data,\n                              int len,\n                              unsigned char** out,\n                              size_t* out_len) {\n-  EVPKeyPointer pkey;\n-\n-  // Check if this is a PKCS#8 or RSA public key before trying as X.509 and\n-  // private key.\n-  if (operation == kPublic) {\n-    ParsePublicKeyResult pkeyres = ParsePublicKey(&pkey, key_pem, key_pem_len);\n-    if (pkeyres == kParsePublicFailed)\n-      return false;\n-  }\n-  if (!pkey) {\n-    // Private key fallback.\n-    BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n-    if (!bp)\n-      return false;\n-    pkey.reset(PEM_read_bio_PrivateKey(bp.get(),\n-                                       nullptr,\n-                                       PasswordCallback,\n-                                       const_cast<char*>(passphrase)));\n-    if (!pkey)\n-      return false;\n-  }\n-\n   EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));\n   if (!ctx)\n     return false;\n@@ -4022,28 +4750,25 @@ template <PublicKeyCipher::Operation operation,\n void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Key\");\n-  char* kbuf = Buffer::Data(args[0]);\n-  ssize_t klen = Buffer::Length(args[0]);\n+  unsigned int offset = 0;\n+  ManagedEVPPKey pkey = GetPublicOrPrivateKeyFromJs(args, &offset, true, true);\n+  if (!pkey)\n+    return;\n \n-  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], \"Data\");\n-  char* buf = Buffer::Data(args[1]);\n-  ssize_t len = Buffer::Length(args[1]);\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[offset], \"Data\");\n+  char* buf = Buffer::Data(args[offset]);\n+  ssize_t len = Buffer::Length(args[offset]);\n \n   uint32_t padding;\n-  if (!args[2]->Uint32Value(env->context()).To(&padding)) return;\n-\n-  String::Utf8Value passphrase(args.GetIsolate(), args[3]);\n+  if (!args[offset + 1]->Uint32Value(env->context()).To(&padding)) return;\n \n   unsigned char* out_value = nullptr;\n   size_t out_len = 0;\n \n   ClearErrorOnReturn clear_error_on_return;\n \n   bool r = Cipher<operation, EVP_PKEY_cipher_init, EVP_PKEY_cipher>(\n-      kbuf,\n-      klen,\n-      args.Length() >= 4 && !args[3]->IsNull() ? *passphrase : nullptr,\n+      pkey,\n       padding,\n       reinterpret_cast<const unsigned char*>(buf),\n       len,\n@@ -5048,46 +5773,17 @@ class ECKeyPairGenerationConfig : public KeyPairGenerationConfig {\n   const int param_encoding_;\n };\n \n-enum PKEncodingType {\n-  // RSAPublicKey / RSAPrivateKey according to PKCS#1.\n-  PK_ENCODING_PKCS1,\n-  // PrivateKeyInfo or EncryptedPrivateKeyInfo according to PKCS#8.\n-  PK_ENCODING_PKCS8,\n-  // SubjectPublicKeyInfo according to X.509.\n-  PK_ENCODING_SPKI,\n-  // ECPrivateKey according to SEC1.\n-  PK_ENCODING_SEC1\n-};\n-\n-enum PKFormatType {\n-  PK_FORMAT_DER,\n-  PK_FORMAT_PEM\n-};\n-\n-struct KeyPairEncodingConfig {\n-  PKEncodingType type_;\n-  PKFormatType format_;\n-};\n-\n-typedef KeyPairEncodingConfig PublicKeyEncodingConfig;\n-\n-struct PrivateKeyEncodingConfig : public KeyPairEncodingConfig {\n-  const EVP_CIPHER* cipher_;\n-  // This char* will be passed to OPENSSL_clear_free.\n-  std::shared_ptr<char> passphrase_;\n-  unsigned int passphrase_length_;\n-};\n-\n class GenerateKeyPairJob : public CryptoJob {\n  public:\n   GenerateKeyPairJob(Environment* env,\n                      std::unique_ptr<KeyPairGenerationConfig> config,\n                      PublicKeyEncodingConfig public_key_encoding,\n-                     PrivateKeyEncodingConfig private_key_encoding)\n+                     PrivateKeyEncodingConfig&& private_key_encoding)\n     : CryptoJob(env),\n     config_(std::move(config)),\n     public_key_encoding_(public_key_encoding),\n-    private_key_encoding_(private_key_encoding),\n+    private_key_encoding_(std::forward<PrivateKeyEncodingConfig>(\n+        private_key_encoding)),\n     pkey_(nullptr) {}\n \n   inline void DoThreadPoolWork() override {\n@@ -5116,7 +5812,7 @@ class GenerateKeyPairJob : public CryptoJob {\n     EVP_PKEY* pkey = nullptr;\n     if (EVP_PKEY_keygen(ctx.get(), &pkey) != 1)\n       return false;\n-    pkey_.reset(pkey);\n+    pkey_ = ManagedEVPPKey(pkey);\n     return true;\n   }\n \n@@ -5143,197 +5839,59 @@ class GenerateKeyPairJob : public CryptoJob {\n   }\n \n   inline bool EncodeKeys(Local<Value>* pubkey, Local<Value>* privkey) {\n-    EVP_PKEY* pkey = pkey_.get();\n-    BIOPointer bio(BIO_new(BIO_s_mem()));\n-    CHECK(bio);\n-\n     // Encode the public key.\n-    if (public_key_encoding_.type_ == PK_ENCODING_PKCS1) {\n-      // PKCS#1 is only valid for RSA keys.\n-      CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);\n-      RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));\n-      if (public_key_encoding_.format_ == PK_FORMAT_PEM) {\n-        // Encode PKCS#1 as PEM.\n-        if (PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) != 1)\n-          return false;\n-      } else {\n-        // Encode PKCS#1 as DER.\n-        CHECK_EQ(public_key_encoding_.format_, PK_FORMAT_DER);\n-        if (i2d_RSAPublicKey_bio(bio.get(), rsa.get()) != 1)\n-          return false;\n-      }\n+    if (public_key_encoding_.output_key_object_) {\n+      // Note that this has the downside of containing sensitive data of the\n+      // private key.\n+      *pubkey = KeyObject::Create(env, kKeyTypePublic, pkey_);\n     } else {\n-      CHECK_EQ(public_key_encoding_.type_, PK_ENCODING_SPKI);\n-      if (public_key_encoding_.format_ == PK_FORMAT_PEM) {\n-        // Encode SPKI as PEM.\n-        if (PEM_write_bio_PUBKEY(bio.get(), pkey) != 1)\n-          return false;\n-      } else {\n-        // Encode SPKI as DER.\n-        CHECK_EQ(public_key_encoding_.format_, PK_FORMAT_DER);\n-        if (i2d_PUBKEY_bio(bio.get(), pkey) != 1)\n-          return false;\n-      }\n+      MaybeLocal<Value> maybe_pubkey =\n+          WritePublicKey(env, pkey_.get(), public_key_encoding_);\n+      if (maybe_pubkey.IsEmpty())\n+        return false;\n+      *pubkey = maybe_pubkey.ToLocalChecked();\n     }\n \n-    // Convert the contents of the BIO to a JavaScript object.\n-    BIOToStringOrBuffer(bio.get(), public_key_encoding_.format_, pubkey);\n-    USE(BIO_reset(bio.get()));\n-\n-    // Now do the same for the private key (which is a bit more difficult).\n-    if (private_key_encoding_.type_ == PK_ENCODING_PKCS1) {\n-      // PKCS#1 is only permitted for RSA keys.\n-      CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);\n-\n-      RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));\n-      if (private_key_encoding_.format_ == PK_FORMAT_PEM) {\n-        // Encode PKCS#1 as PEM.\n-        char* pass = private_key_encoding_.passphrase_.get();\n-        if (PEM_write_bio_RSAPrivateKey(\n-                bio.get(), rsa.get(),\n-                private_key_encoding_.cipher_,\n-                reinterpret_cast<unsigned char*>(pass),\n-                private_key_encoding_.passphrase_length_,\n-                nullptr, nullptr) != 1)\n-          return false;\n-      } else {\n-        // Encode PKCS#1 as DER. This does not permit encryption.\n-        CHECK_EQ(private_key_encoding_.format_, PK_FORMAT_DER);\n-        CHECK_NULL(private_key_encoding_.cipher_);\n-        if (i2d_RSAPrivateKey_bio(bio.get(), rsa.get()) != 1)\n-          return false;\n-      }\n-    } else if (private_key_encoding_.type_ == PK_ENCODING_PKCS8) {\n-      if (private_key_encoding_.format_ == PK_FORMAT_PEM) {\n-        // Encode PKCS#8 as PEM.\n-        if (PEM_write_bio_PKCS8PrivateKey(\n-                bio.get(), pkey,\n-                private_key_encoding_.cipher_,\n-                private_key_encoding_.passphrase_.get(),\n-                private_key_encoding_.passphrase_length_,\n-                nullptr, nullptr) != 1)\n-          return false;\n-      } else {\n-        // Encode PKCS#8 as DER.\n-        CHECK_EQ(private_key_encoding_.format_, PK_FORMAT_DER);\n-        if (i2d_PKCS8PrivateKey_bio(\n-                bio.get(), pkey,\n-                private_key_encoding_.cipher_,\n-                private_key_encoding_.passphrase_.get(),\n-                private_key_encoding_.passphrase_length_,\n-                nullptr, nullptr) != 1)\n-          return false;\n-      }\n+    // Now do the same for the private key.\n+    if (private_key_encoding_.output_key_object_) {\n+      *privkey = KeyObject::Create(env, kKeyTypePrivate, pkey_);\n     } else {\n-      CHECK_EQ(private_key_encoding_.type_, PK_ENCODING_SEC1);\n-\n-      // SEC1 is only permitted for EC keys.\n-      CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_EC);\n-\n-      ECKeyPointer ec_key(EVP_PKEY_get1_EC_KEY(pkey));\n-      if (private_key_encoding_.format_ == PK_FORMAT_PEM) {\n-        // Encode SEC1 as PEM.\n-        char* pass = private_key_encoding_.passphrase_.get();\n-        if (PEM_write_bio_ECPrivateKey(\n-                bio.get(), ec_key.get(),\n-                private_key_encoding_.cipher_,\n-                reinterpret_cast<unsigned char*>(pass),\n-                private_key_encoding_.passphrase_length_,\n-                nullptr, nullptr) != 1)\n-          return false;\n-      } else {\n-        // Encode SEC1 as DER. This does not permit encryption.\n-        CHECK_EQ(private_key_encoding_.format_, PK_FORMAT_DER);\n-        CHECK_NULL(private_key_encoding_.cipher_);\n-        if (i2d_ECPrivateKey_bio(bio.get(), ec_key.get()) != 1)\n-          return false;\n-      }\n+      MaybeLocal<Value> maybe_privkey =\n+          WritePrivateKey(env, pkey_.get(), private_key_encoding_);\n+      if (maybe_privkey.IsEmpty())\n+        return false;\n+      *privkey = maybe_privkey.ToLocalChecked();\n     }\n \n-    BIOToStringOrBuffer(bio.get(), private_key_encoding_.format_, privkey);\n     return true;\n   }\n \n-  inline void BIOToStringOrBuffer(BIO* bio, PKFormatType format,\n-                                  Local<Value>* out) const {\n-    BUF_MEM* bptr;\n-    BIO_get_mem_ptr(bio, &bptr);\n-    if (format == PK_FORMAT_PEM) {\n-      // PEM is an ASCII format, so we will return it as a string.\n-      *out = String::NewFromUtf8(env->isolate(), bptr->data,\n-                                 NewStringType::kNormal,\n-                                 bptr->length).ToLocalChecked();\n-    } else {\n-      CHECK_EQ(format, PK_FORMAT_DER);\n-      // DER is binary, return it as a buffer.\n-      *out = Buffer::Copy(env, bptr->data, bptr->length).ToLocalChecked();\n-    }\n-  }\n-\n  private:\n   CryptoErrorVector errors_;\n   std::unique_ptr<KeyPairGenerationConfig> config_;\n   PublicKeyEncodingConfig public_key_encoding_;\n   PrivateKeyEncodingConfig private_key_encoding_;\n-  EVPKeyPointer pkey_;\n+  ManagedEVPPKey pkey_;\n };\n \n void GenerateKeyPair(const FunctionCallbackInfo<Value>& args,\n-                     unsigned int n_opts,\n+                     unsigned int offset,\n                      std::unique_ptr<KeyPairGenerationConfig> config) {\n   Environment* env = Environment::GetCurrent(args);\n-  PublicKeyEncodingConfig public_key_encoding;\n-  PrivateKeyEncodingConfig private_key_encoding;\n-\n-  // Public key encoding: type (int) + pem (bool)\n-  CHECK(args[n_opts]->IsInt32());\n-  public_key_encoding.type_ = static_cast<PKEncodingType>(\n-      args[n_opts].As<Int32>()->Value());\n-  CHECK(args[n_opts + 1]->IsInt32());\n-  public_key_encoding.format_ = static_cast<PKFormatType>(\n-      args[n_opts + 1].As<Int32>()->Value());\n-\n-  // Private key encoding: type (int) + pem (bool) + cipher (optional, string) +\n-  //                       passphrase (optional, string)\n-  CHECK(args[n_opts + 2]->IsInt32());\n-  private_key_encoding.type_ = static_cast<PKEncodingType>(\n-      args[n_opts + 2].As<Int32>()->Value());\n-  CHECK(args[n_opts + 1]->IsInt32());\n-  private_key_encoding.format_ = static_cast<PKFormatType>(\n-      args[n_opts + 3].As<Int32>()->Value());\n-  if (args[n_opts + 4]->IsString()) {\n-    String::Utf8Value cipher_name(env->isolate(),\n-                                  args[n_opts + 4].As<String>());\n-    private_key_encoding.cipher_ = EVP_get_cipherbyname(*cipher_name);\n-    if (private_key_encoding.cipher_ == nullptr)\n-      return env->ThrowError(\"Unknown cipher\");\n-\n-    // We need to take ownership of the string and want to avoid creating an\n-    // unnecessary copy in memory, that's why we are not using String::Utf8Value\n-    // here.\n-    CHECK(args[n_opts + 5]->IsString());\n-    Local<String> passphrase = args[n_opts + 5].As<String>();\n-    int len = passphrase->Utf8Length(env->isolate());\n-    private_key_encoding.passphrase_length_ = len;\n-    void* mem = OPENSSL_malloc(private_key_encoding.passphrase_length_ + 1);\n-    CHECK_NOT_NULL(mem);\n-    private_key_encoding.passphrase_.reset(static_cast<char*>(mem),\n-        [len](char* p) {\n-          OPENSSL_clear_free(p, len);\n-        });\n-    passphrase->WriteUtf8(env->isolate(),\n-                          private_key_encoding.passphrase_.get());\n-  } else {\n-    CHECK(args[n_opts + 5]->IsNullOrUndefined());\n-    private_key_encoding.cipher_ = nullptr;\n-    private_key_encoding.passphrase_length_ = 0;\n-  }\n+\n+  PublicKeyEncodingConfig public_key_encoding =\n+      GetPublicKeyEncodingFromJs(args, &offset, kKeyContextGenerate);\n+  NonCopyableMaybe<PrivateKeyEncodingConfig> private_key_encoding =\n+      GetPrivateKeyEncodingFromJs(args, &offset, kKeyContextGenerate);\n+\n+  if (private_key_encoding.IsEmpty())\n+    return;\n \n   std::unique_ptr<GenerateKeyPairJob> job(\n       new GenerateKeyPairJob(env, std::move(config), public_key_encoding,\n-                             private_key_encoding));\n-  if (args[n_opts + 6]->IsObject())\n-    return GenerateKeyPairJob::Run(std::move(job), args[n_opts + 6]);\n+                             private_key_encoding.Release()));\n+  if (args[offset]->IsObject())\n+    return GenerateKeyPairJob::Run(std::move(job), args[offset]);\n   env->PrintSyncTrace();\n   job->DoThreadPoolWork();\n   Local<Value> err, pubkey, privkey;\n@@ -5778,6 +6336,7 @@ void Initialize(Local<Object> target,\n \n   Environment* env = Environment::GetCurrent(context);\n   SecureContext::Initialize(env, target);\n+  env->set_crypto_key_object_constructor(KeyObject::Initialize(env, target));\n   CipherBase::Initialize(env, target);\n   DiffieHellman::Initialize(env, target);\n   ECDH::Initialize(env, target);\n@@ -5809,12 +6368,15 @@ void Initialize(Local<Object> target,\n   env->SetMethod(target, \"generateKeyPairEC\", GenerateKeyPairEC);\n   NODE_DEFINE_CONSTANT(target, OPENSSL_EC_NAMED_CURVE);\n   NODE_DEFINE_CONSTANT(target, OPENSSL_EC_EXPLICIT_CURVE);\n-  NODE_DEFINE_CONSTANT(target, PK_ENCODING_PKCS1);\n-  NODE_DEFINE_CONSTANT(target, PK_ENCODING_PKCS8);\n-  NODE_DEFINE_CONSTANT(target, PK_ENCODING_SPKI);\n-  NODE_DEFINE_CONSTANT(target, PK_ENCODING_SEC1);\n-  NODE_DEFINE_CONSTANT(target, PK_FORMAT_DER);\n-  NODE_DEFINE_CONSTANT(target, PK_FORMAT_PEM);\n+  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1);\n+  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8);\n+  NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI);\n+  NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1);\n+  NODE_DEFINE_CONSTANT(target, kKeyFormatDER);\n+  NODE_DEFINE_CONSTANT(target, kKeyFormatPEM);\n+  NODE_DEFINE_CONSTANT(target, kKeyTypeSecret);\n+  NODE_DEFINE_CONSTANT(target, kKeyTypePublic);\n+  NODE_DEFINE_CONSTANT(target, kKeyTypePrivate);\n   env->SetMethod(target, \"randomBytes\", RandomBytes);\n   env->SetMethodNoSideEffect(target, \"timingSafeEqual\", TimingSafeEqual);\n   env->SetMethodNoSideEffect(target, \"getSSLCiphers\", GetSSLCiphers);"
        },
        {
            "sha": "1b950846a7240cc960d0d8060f839ad71c8a489b",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 160,
            "deletions": 8,
            "changes": 168,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -340,6 +340,163 @@ class SSLWrap {\n   friend class SecureContext;\n };\n \n+// A helper class representing a read-only byte array. When deallocated, its\n+// contents are zeroed.\n+class ByteSource {\n+ public:\n+  ByteSource() = default;\n+  ByteSource(ByteSource&& other);\n+  ~ByteSource();\n+\n+  ByteSource& operator=(ByteSource&& other);\n+\n+  const char* get() const;\n+  size_t size() const;\n+\n+  static ByteSource FromStringOrBuffer(Environment* env,\n+                                       v8::Local<v8::Value> value);\n+\n+  static ByteSource FromString(Environment* env,\n+                               v8::Local<v8::String> str,\n+                               bool ntc = false);\n+\n+  static ByteSource FromBuffer(v8::Local<v8::Value> buffer,\n+                               bool ntc = false);\n+\n+  static ByteSource NullTerminatedCopy(Environment* env,\n+                                       v8::Local<v8::Value> value);\n+\n+  static ByteSource FromSymmetricKeyObject(v8::Local<v8::Value> handle);\n+\n+ private:\n+  const char* data_ = nullptr;\n+  char* allocated_data_ = nullptr;\n+  size_t size_ = 0;\n+\n+  ByteSource(const char* data, char* allocated_data, size_t size);\n+\n+  static ByteSource Allocated(char* data, size_t size);\n+  static ByteSource Foreign(const char* data, size_t size);\n+\n+  DISALLOW_COPY_AND_ASSIGN(ByteSource);\n+};\n+\n+enum PKEncodingType {\n+  // RSAPublicKey / RSAPrivateKey according to PKCS#1.\n+  kKeyEncodingPKCS1,\n+  // PrivateKeyInfo or EncryptedPrivateKeyInfo according to PKCS#8.\n+  kKeyEncodingPKCS8,\n+  // SubjectPublicKeyInfo according to X.509.\n+  kKeyEncodingSPKI,\n+  // ECPrivateKey according to SEC1.\n+  kKeyEncodingSEC1\n+};\n+\n+enum PKFormatType {\n+  kKeyFormatDER,\n+  kKeyFormatPEM\n+};\n+\n+struct AsymmetricKeyEncodingConfig {\n+  bool output_key_object_;\n+  PKFormatType format_;\n+  v8::Maybe<PKEncodingType> type_ = v8::Nothing<PKEncodingType>();\n+};\n+\n+typedef AsymmetricKeyEncodingConfig PublicKeyEncodingConfig;\n+\n+struct PrivateKeyEncodingConfig : public AsymmetricKeyEncodingConfig {\n+  const EVP_CIPHER* cipher_;\n+  ByteSource passphrase_;\n+};\n+\n+enum KeyType {\n+  kKeyTypeSecret,\n+  kKeyTypePublic,\n+  kKeyTypePrivate\n+};\n+\n+// This uses the built-in reference counter of OpenSSL to manage an EVP_PKEY\n+// which is slightly more efficient than using a shared pointer and easier to\n+// use.\n+class ManagedEVPPKey {\n+ public:\n+  ManagedEVPPKey();\n+  explicit ManagedEVPPKey(EVP_PKEY* pkey);\n+  ManagedEVPPKey(const ManagedEVPPKey& key);\n+  ManagedEVPPKey(ManagedEVPPKey&& key);\n+  ~ManagedEVPPKey();\n+\n+  ManagedEVPPKey& operator=(const ManagedEVPPKey& key);\n+  ManagedEVPPKey& operator=(ManagedEVPPKey&& key);\n+\n+  operator bool() const;\n+  EVP_PKEY* get() const;\n+\n+ private:\n+  EVP_PKEY* pkey_;\n+};\n+\n+class KeyObject : public BaseObject {\n+ public:\n+  static v8::Local<v8::Function> Initialize(Environment* env,\n+                                            v8::Local<v8::Object> target);\n+\n+  static v8::Local<v8::Object> Create(Environment* env,\n+                                      KeyType type,\n+                                      const ManagedEVPPKey& pkey);\n+\n+  // TODO(tniessen): track the memory used by OpenSSL types\n+  SET_NO_MEMORY_INFO()\n+  SET_MEMORY_INFO_NAME(KeyObject)\n+  SET_SELF_SIZE(KeyObject)\n+\n+  KeyType GetKeyType() const;\n+\n+  // These functions allow unprotected access to the raw key material and should\n+  // only be used to implement cryptograohic operations requiring the key.\n+  ManagedEVPPKey GetAsymmetricKey() const;\n+  const char* GetSymmetricKey() const;\n+  size_t GetSymmetricKeySize() const;\n+\n+ protected:\n+  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n+  static void Init(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  void InitSecret(const char* key, size_t key_len);\n+  void InitPublic(const ManagedEVPPKey& pkey);\n+  void InitPrivate(const ManagedEVPPKey& pkey);\n+\n+  static void GetAsymmetricKeyType(\n+      const v8::FunctionCallbackInfo<v8::Value>& args);\n+  v8::Local<v8::String> GetAsymmetricKeyType() const;\n+\n+  static void GetSymmetricKeySize(\n+      const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n+  static void Export(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  v8::Local<v8::Value> ExportSecretKey() const;\n+  v8::MaybeLocal<v8::Value> ExportPublicKey(\n+      const PublicKeyEncodingConfig& config) const;\n+  v8::MaybeLocal<v8::Value> ExportPrivateKey(\n+      const PrivateKeyEncodingConfig& config) const;\n+\n+  KeyObject(Environment* env,\n+            v8::Local<v8::Object> wrap,\n+            KeyType key_type)\n+      : BaseObject(env, wrap),\n+        key_type_(key_type),\n+        symmetric_key_(nullptr, nullptr) {\n+    MakeWeak();\n+  }\n+\n+ private:\n+  const KeyType key_type_;\n+  std::unique_ptr<char, std::function<void(char*)>> symmetric_key_;\n+  unsigned int symmetric_key_len_;\n+  ManagedEVPPKey asymmetric_key_;\n+};\n+\n class CipherBase : public BaseObject {\n  public:\n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n@@ -528,9 +685,7 @@ class Sign : public SignBase {\n   };\n \n   SignResult SignFinal(\n-      const char* key_pem,\n-      int key_pem_len,\n-      const char* passphrase,\n+      const ManagedEVPPKey& pkey,\n       int padding,\n       int saltlen);\n \n@@ -549,8 +704,7 @@ class Verify : public SignBase {\n  public:\n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n \n-  Error VerifyFinal(const char* key_pem,\n-                    int key_pem_len,\n+  Error VerifyFinal(const ManagedEVPPKey& key,\n                     const char* sig,\n                     int siglen,\n                     int padding,\n@@ -583,9 +737,7 @@ class PublicKeyCipher {\n   template <Operation operation,\n             EVP_PKEY_cipher_init_t EVP_PKEY_cipher_init,\n             EVP_PKEY_cipher_t EVP_PKEY_cipher>\n-  static bool Cipher(const char* key_pem,\n-                     int key_pem_len,\n-                     const char* passphrase,\n+  static bool Cipher(const ManagedEVPPKey& pkey,\n                      int padding,\n                      const unsigned char* data,\n                      int len,"
        },
        {
            "sha": "36a2ec9e3a62704ceb06b03bbd1a7cff68b5449f",
            "filename": "src/util.h",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/src%2Futil.h",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/src%2Futil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.h?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -473,6 +473,29 @@ struct MallocedBuffer {\n   MallocedBuffer& operator=(const MallocedBuffer&) = delete;\n };\n \n+template <typename T>\n+class NonCopyableMaybe {\n+ public:\n+  NonCopyableMaybe() : empty_(true) {}\n+  explicit NonCopyableMaybe(T&& value)\n+      : empty_(false),\n+        value_(std::move(value)) {}\n+\n+  bool IsEmpty() const {\n+    return empty_;\n+  }\n+\n+  T&& Release() {\n+    CHECK_EQ(empty_, false);\n+    empty_ = true;\n+    return std::move(value_);\n+  }\n+\n+ private:\n+  bool empty_;\n+  T value_;\n+};\n+\n // Test whether some value can be called with ().\n template <typename T, typename = void>\n struct is_callable : std::is_function<T> { };"
        },
        {
            "sha": "e4c7fced584c5ffcaa42ad62c1e3f427b252a487",
            "filename": "test/parallel/test-crypto-cipheriv-decipheriv.js",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-cipheriv-decipheriv.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-cipheriv-decipheriv.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-cipheriv-decipheriv.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -101,8 +101,8 @@ function testCipher3(key, iv) {\n     {\n       code: 'ERR_INVALID_ARG_TYPE',\n       type: TypeError,\n-      message: 'The \"key\" argument must be one of type string, Buffer, ' +\n-               'TypedArray, or DataView. Received type object'\n+      message: 'The \"key\" argument must be one of type Buffer, TypedArray, ' +\n+               'DataView, string, or KeyObject. Received type object'\n     });\n \n   common.expectsError(\n@@ -138,8 +138,8 @@ function testCipher3(key, iv) {\n     {\n       code: 'ERR_INVALID_ARG_TYPE',\n       type: TypeError,\n-      message: 'The \"key\" argument must be one of type string, Buffer, ' +\n-               'TypedArray, or DataView. Received type object'\n+      message: 'The \"key\" argument must be one of type Buffer, TypedArray, ' +\n+               'DataView, string, or KeyObject. Received type object'\n     });\n \n   common.expectsError("
        },
        {
            "sha": "9e0e364a4fa3957af3f2ddaa41eaa3d697f9a5f6",
            "filename": "test/parallel/test-crypto-hmac.js",
            "status": "modified",
            "additions": 37,
            "deletions": 51,
            "changes": 88,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-hmac.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-hmac.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-hmac.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -36,20 +36,37 @@ common.expectsError(\n   {\n     code: 'ERR_INVALID_ARG_TYPE',\n     type: TypeError,\n-    message: 'The \"key\" argument must be one of type string, TypedArray, or ' +\n-             'DataView. Received type object'\n+    message: 'The \"key\" argument must be one of type Buffer, TypedArray, ' +\n+             'DataView, string, or KeyObject. Received type object'\n   });\n \n+function testHmac(algo, key, data, expected) {\n+  // FIPS does not support MD5.\n+  if (common.hasFipsCrypto && algo === 'md5')\n+    return;\n+\n+  if (!Array.isArray(data))\n+    data = [data];\n+\n+  // If the key is a Buffer, test Hmac with a key object as well.\n+  const keyWrappers = [\n+    (key) => key,\n+    ...(typeof key === 'string' ? [] : [crypto.createSecretKey])\n+  ];\n+\n+  for (const keyWrapper of keyWrappers) {\n+    const hmac = crypto.createHmac(algo, keyWrapper(key));\n+    for (const chunk of data)\n+      hmac.update(chunk);\n+    const actual = hmac.digest('hex');\n+    assert.strictEqual(actual, expected);\n+  }\n+}\n+\n {\n-  // Test HMAC\n-  const actual = crypto.createHmac('sha1', 'Node')\n-    .update('some data')\n-    .update('to hmac')\n-    .digest('hex');\n-  const expected = '19fd6e1ba73d9ed2224dd5094a71babe85d9a892';\n-  assert.strictEqual(actual,\n-                     expected,\n-                     `Test HMAC: ${actual} must be ${expected}`);\n+  // Test HMAC with multiple updates.\n+  testHmac('sha1', 'Node', ['some data', 'to hmac'],\n+           '19fd6e1ba73d9ed2224dd5094a71babe85d9a892');\n }\n \n // Test HMAC (Wikipedia Test Cases)\n@@ -96,24 +113,11 @@ const wikipedia = [\n   },\n ];\n \n-for (let i = 0, l = wikipedia.length; i < l; i++) {\n-  for (const hash in wikipedia[i].hmac) {\n-    // FIPS does not support MD5.\n-    if (common.hasFipsCrypto && hash === 'md5')\n-      continue;\n-    const expected = wikipedia[i].hmac[hash];\n-    const actual = crypto.createHmac(hash, wikipedia[i].key)\n-                         .update(wikipedia[i].data)\n-                         .digest('hex');\n-    assert.strictEqual(\n-      actual,\n-      expected,\n-      `Test HMAC-${hash} wikipedia case ${i + 1}: ${actual} must be ${expected}`\n-    );\n-  }\n+for (const { key, data, hmac } of wikipedia) {\n+  for (const hash in hmac)\n+    testHmac(hash, key, data, hmac[hash]);\n }\n \n-\n // Test HMAC-SHA-* (rfc 4231 Test Cases)\n const rfc4231 = [\n   {\n@@ -342,6 +346,10 @@ const rfc2202_md5 = [\n     hmac: '6f630fad67cda0ee1fb1f562db3aa53e'\n   }\n ];\n+\n+for (const { key, data, hmac } of rfc2202_md5)\n+  testHmac('md5', key, data, hmac);\n+\n const rfc2202_sha1 = [\n   {\n     key: Buffer.from('0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b', 'hex'),\n@@ -397,30 +405,8 @@ const rfc2202_sha1 = [\n   }\n ];\n \n-if (!common.hasFipsCrypto) {\n-  for (let i = 0, l = rfc2202_md5.length; i < l; i++) {\n-    const actual = crypto.createHmac('md5', rfc2202_md5[i].key)\n-      .update(rfc2202_md5[i].data)\n-      .digest('hex');\n-    const expected = rfc2202_md5[i].hmac;\n-    assert.strictEqual(\n-      actual,\n-      expected,\n-      `Test HMAC-MD5 rfc 2202 case ${i + 1}: ${actual} must be ${expected}`\n-    );\n-  }\n-}\n-for (let i = 0, l = rfc2202_sha1.length; i < l; i++) {\n-  const actual = crypto.createHmac('sha1', rfc2202_sha1[i].key)\n-    .update(rfc2202_sha1[i].data)\n-    .digest('hex');\n-  const expected = rfc2202_sha1[i].hmac;\n-  assert.strictEqual(\n-    actual,\n-    expected,\n-    `Test HMAC-SHA1 rfc 2202 case ${i + 1}: ${actual} must be ${expected}`\n-  );\n-}\n+for (const { key, data, hmac } of rfc2202_sha1)\n+  testHmac('sha1', key, data, hmac);\n \n common.expectsError(\n   () => crypto.createHmac('sha256', 'w00t').digest('ucs2'),"
        },
        {
            "sha": "dddbd5f2703d93e051f96dab8d6740500aab53e8",
            "filename": "test/parallel/test-crypto-key-objects.js",
            "status": "added",
            "additions": 107,
            "deletions": 0,
            "changes": 107,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-key-objects.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-key-objects.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-key-objects.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -0,0 +1,107 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+\n+const assert = require('assert');\n+const {\n+  createCipheriv,\n+  createDecipheriv,\n+  createSecretKey,\n+  createPublicKey,\n+  createPrivateKey,\n+  randomBytes,\n+  publicEncrypt,\n+  privateDecrypt\n+} = require('crypto');\n+\n+const fixtures = require('../common/fixtures');\n+\n+const publicPem = fixtures.readSync('test_rsa_pubkey.pem', 'ascii');\n+const privatePem = fixtures.readSync('test_rsa_privkey.pem', 'ascii');\n+\n+{\n+  // Attempting to create an empty key should throw.\n+  common.expectsError(() => {\n+    createSecretKey(Buffer.alloc(0));\n+  }, {\n+    type: RangeError,\n+    code: 'ERR_OUT_OF_RANGE',\n+    message: 'The value of \"key.byteLength\" is out of range. ' +\n+             'It must be > 0. Received 0'\n+  });\n+}\n+\n+{\n+  const keybuf = randomBytes(32);\n+  const key = createSecretKey(keybuf);\n+  assert.strictEqual(key.type, 'secret');\n+  assert.strictEqual(key.symmetricKeySize, 32);\n+  assert.strictEqual(key.asymmetricKeyType, undefined);\n+\n+  const exportedKey = key.export();\n+  assert(keybuf.equals(exportedKey));\n+\n+  const plaintext = Buffer.from('Hello world', 'utf8');\n+\n+  const cipher = createCipheriv('aes-256-ecb', key, null);\n+  const ciphertext = Buffer.concat([\n+    cipher.update(plaintext), cipher.final()\n+  ]);\n+\n+  const decipher = createDecipheriv('aes-256-ecb', key, null);\n+  const deciphered = Buffer.concat([\n+    decipher.update(ciphertext), decipher.final()\n+  ]);\n+\n+  assert(plaintext.equals(deciphered));\n+}\n+\n+{\n+  const publicKey = createPublicKey(publicPem);\n+  assert.strictEqual(publicKey.type, 'public');\n+  assert.strictEqual(publicKey.asymmetricKeyType, 'rsa');\n+  assert.strictEqual(publicKey.symmetricKeySize, undefined);\n+\n+  const privateKey = createPrivateKey(privatePem);\n+  assert.strictEqual(privateKey.type, 'private');\n+  assert.strictEqual(privateKey.asymmetricKeyType, 'rsa');\n+  assert.strictEqual(privateKey.symmetricKeySize, undefined);\n+\n+  const publicDER = publicKey.export({\n+    format: 'der',\n+    type: 'pkcs1'\n+  });\n+\n+  const privateDER = privateKey.export({\n+    format: 'der',\n+    type: 'pkcs1'\n+  });\n+\n+  assert(Buffer.isBuffer(publicDER));\n+  assert(Buffer.isBuffer(privateDER));\n+\n+  const plaintext = Buffer.from('Hello world', 'utf8');\n+  const ciphertexts = [\n+    publicEncrypt(publicKey, plaintext),\n+    publicEncrypt({ key: publicKey }, plaintext),\n+    // Test distinguishing PKCS#1 public and private keys based on the\n+    // DER-encoded data only.\n+    publicEncrypt({ format: 'der', type: 'pkcs1', key: publicDER }, plaintext),\n+    publicEncrypt({ format: 'der', type: 'pkcs1', key: privateDER }, plaintext)\n+  ];\n+\n+  const decryptionKeys = [\n+    privateKey,\n+    { format: 'pem', key: privatePem },\n+    { format: 'der', type: 'pkcs1', key: privateDER }\n+  ];\n+\n+  for (const ciphertext of ciphertexts) {\n+    for (const key of decryptionKeys) {\n+      const deciphered = privateDecrypt(key, ciphertext);\n+      assert(plaintext.equals(deciphered));\n+    }\n+  }\n+}"
        },
        {
            "sha": "43319c38599ebf832ef9e5450bf3f68d28686c92",
            "filename": "test/parallel/test-crypto-keygen.js",
            "status": "modified",
            "additions": 73,
            "deletions": 44,
            "changes": 117,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-keygen.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-keygen.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-keygen.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -65,23 +65,6 @@ const pkcs8EncExp = getRegExpForPEM('ENCRYPTED PRIVATE KEY');\n const sec1Exp = getRegExpForPEM('EC PRIVATE KEY');\n const sec1EncExp = (cipher) => getRegExpForPEM('EC PRIVATE KEY', cipher);\n \n-// Since our own APIs only accept PEM, not DER, we need to convert DER to PEM\n-// for testing.\n-function convertDERToPEM(label, der) {\n-  const base64 = der.toString('base64');\n-  const lines = [];\n-  let i = 0;\n-  while (i < base64.length) {\n-    const n = Math.min(base64.length - i, 64);\n-    lines.push(base64.substr(i, n));\n-    i += n;\n-  }\n-  const body = lines.join('\\n');\n-  const r = `-----BEGIN ${label}-----\\n${body}\\n-----END ${label}-----\\n`;\n-  assert(getRegExpForPEM(label).test(r));\n-  return r;\n-}\n-\n {\n   // To make the test faster, we will only test sync key generation once and\n   // with a relatively small key.\n@@ -113,31 +96,31 @@ function convertDERToPEM(label, der) {\n }\n \n {\n+  const publicKeyEncoding = {\n+    type: 'pkcs1',\n+    format: 'der'\n+  };\n+\n   // Test async RSA key generation.\n   generateKeyPair('rsa', {\n     publicExponent: 0x10001,\n     modulusLength: 512,\n-    publicKeyEncoding: {\n-      type: 'pkcs1',\n-      format: 'der'\n-    },\n+    publicKeyEncoding,\n     privateKeyEncoding: {\n       type: 'pkcs1',\n       format: 'pem'\n     }\n   }, common.mustCall((err, publicKeyDER, privateKey) => {\n     assert.ifError(err);\n \n-    // The public key is encoded as DER (which is binary) instead of PEM. We\n-    // will still need to convert it to PEM for testing.\n     assert(Buffer.isBuffer(publicKeyDER));\n-    const publicKey = convertDERToPEM('RSA PUBLIC KEY', publicKeyDER);\n-    assertApproximateSize(publicKey, 180);\n+    assertApproximateSize(publicKeyDER, 74);\n \n     assert.strictEqual(typeof privateKey, 'string');\n     assert(pkcs1PrivExp.test(privateKey));\n     assertApproximateSize(privateKey, 512);\n \n+    const publicKey = { key: publicKeyDER, ...publicKeyEncoding };\n     testEncryptDecrypt(publicKey, privateKey);\n     testSignVerify(publicKey, privateKey);\n   }));\n@@ -146,10 +129,7 @@ function convertDERToPEM(label, der) {\n   generateKeyPair('rsa', {\n     publicExponent: 0x10001,\n     modulusLength: 512,\n-    publicKeyEncoding: {\n-      type: 'pkcs1',\n-      format: 'der'\n-    },\n+    publicKeyEncoding,\n     privateKeyEncoding: {\n       type: 'pkcs1',\n       format: 'pem',\n@@ -159,16 +139,14 @@ function convertDERToPEM(label, der) {\n   }, common.mustCall((err, publicKeyDER, privateKey) => {\n     assert.ifError(err);\n \n-    // The public key is encoded as DER (which is binary) instead of PEM. We\n-    // will still need to convert it to PEM for testing.\n     assert(Buffer.isBuffer(publicKeyDER));\n-    const publicKey = convertDERToPEM('RSA PUBLIC KEY', publicKeyDER);\n-    assertApproximateSize(publicKey, 180);\n+    assertApproximateSize(publicKeyDER, 74);\n \n     assert.strictEqual(typeof privateKey, 'string');\n     assert(pkcs1EncExp('AES-256-CBC').test(privateKey));\n \n     // Since the private key is encrypted, signing shouldn't work anymore.\n+    const publicKey = { key: publicKeyDER, ...publicKeyEncoding };\n     assert.throws(() => {\n       testSignVerify(publicKey, privateKey);\n     }, /bad decrypt|asn1 encoding routines/);\n@@ -180,6 +158,11 @@ function convertDERToPEM(label, der) {\n }\n \n {\n+  const privateKeyEncoding = {\n+    type: 'pkcs8',\n+    format: 'der'\n+  };\n+\n   // Test async DSA key generation.\n   generateKeyPair('dsa', {\n     modulusLength: 512,\n@@ -189,10 +172,9 @@ function convertDERToPEM(label, der) {\n       format: 'pem'\n     },\n     privateKeyEncoding: {\n-      type: 'pkcs8',\n-      format: 'der',\n       cipher: 'aes-128-cbc',\n-      passphrase: 'secret'\n+      passphrase: 'secret',\n+      ...privateKeyEncoding\n     }\n   }, common.mustCall((err, publicKey, privateKeyDER) => {\n     assert.ifError(err);\n@@ -201,19 +183,22 @@ function convertDERToPEM(label, der) {\n     assert(spkiExp.test(publicKey));\n     // The private key is DER-encoded.\n     assert(Buffer.isBuffer(privateKeyDER));\n-    const privateKey = convertDERToPEM('ENCRYPTED PRIVATE KEY', privateKeyDER);\n \n     assertApproximateSize(publicKey, 440);\n-    assertApproximateSize(privateKey, 512);\n+    assertApproximateSize(privateKeyDER, 336);\n \n     // Since the private key is encrypted, signing shouldn't work anymore.\n     assert.throws(() => {\n-      testSignVerify(publicKey, privateKey);\n+      testSignVerify(publicKey, {\n+        key: privateKeyDER,\n+        ...privateKeyEncoding\n+      });\n     }, /bad decrypt|asn1 encoding routines/);\n \n     // Signing should work with the correct password.\n     testSignVerify(publicKey, {\n-      key: privateKey,\n+      key: privateKeyDER,\n+      ...privateKeyEncoding,\n       passphrase: 'secret'\n     });\n   }));\n@@ -369,8 +354,52 @@ function convertDERToPEM(label, der) {\n }\n \n {\n-  // Missing / invalid publicKeyEncoding.\n-  for (const enc of [undefined, null, 0, 'a', true]) {\n+  // If no publicKeyEncoding is specified, a key object should be returned.\n+  generateKeyPair('rsa', {\n+    modulusLength: 1024,\n+    privateKeyEncoding: {\n+      type: 'pkcs1',\n+      format: 'pem'\n+    }\n+  }, common.mustCall((err, publicKey, privateKey) => {\n+    assert.ifError(err);\n+\n+    assert.strictEqual(typeof publicKey, 'object');\n+    assert.strictEqual(publicKey.type, 'public');\n+    assert.strictEqual(publicKey.asymmetricKeyType, 'rsa');\n+\n+    // The private key should still be a string.\n+    assert.strictEqual(typeof privateKey, 'string');\n+\n+    testEncryptDecrypt(publicKey, privateKey);\n+    testSignVerify(publicKey, privateKey);\n+  }));\n+\n+  // If no privateKeyEncoding is specified, a key object should be returned.\n+  generateKeyPair('rsa', {\n+    modulusLength: 1024,\n+    publicKeyEncoding: {\n+      type: 'pkcs1',\n+      format: 'pem'\n+    }\n+  }, common.mustCall((err, publicKey, privateKey) => {\n+    assert.ifError(err);\n+\n+    // The public key should still be a string.\n+    assert.strictEqual(typeof publicKey, 'string');\n+\n+    assert.strictEqual(typeof privateKey, 'object');\n+    assert.strictEqual(privateKey.type, 'private');\n+    assert.strictEqual(privateKey.asymmetricKeyType, 'rsa');\n+\n+    testEncryptDecrypt(publicKey, privateKey);\n+    testSignVerify(publicKey, privateKey);\n+  }));\n+}\n+\n+{\n+  // Invalid publicKeyEncoding.\n+  for (const enc of [0, 'a', true]) {\n     common.expectsError(() => generateKeyPairSync('rsa', {\n       modulusLength: 4096,\n       publicKeyEncoding: enc,\n@@ -425,8 +454,8 @@ function convertDERToPEM(label, der) {\n     });\n   }\n \n-  // Missing / invalid privateKeyEncoding.\n-  for (const enc of [undefined, null, 0, 'a', true]) {\n+  // Invalid privateKeyEncoding.\n+  for (const enc of [0, 'a', true]) {\n     common.expectsError(() => generateKeyPairSync('rsa', {\n       modulusLength: 4096,\n       publicKeyEncoding: {"
        },
        {
            "sha": "348fd15b74d495692d6102741336fd3ef2f9eed5",
            "filename": "test/parallel/test-crypto-rsa-dsa.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-rsa-dsa.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-rsa-dsa.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-rsa-dsa.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -100,7 +100,7 @@ const decryptError =\n   assert.throws(() => {\n     crypto.publicDecrypt({\n       key: rsaKeyPemEncrypted,\n-      passphrase: [].concat.apply([], Buffer.from('password'))\n+      passphrase: Buffer.from('wrong')\n     }, encryptedBuffer);\n   }, decryptError);\n }"
        },
        {
            "sha": "0499b3091ca5a95f5c8deaf5c6ecf43796a9d2a2",
            "filename": "test/parallel/test-crypto-sign-verify.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-sign-verify.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/test%2Fparallel%2Ftest-crypto-sign-verify.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-sign-verify.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -352,7 +352,7 @@ common.expectsError(\n       code: 'ERR_INVALID_ARG_TYPE',\n       name: 'TypeError [ERR_INVALID_ARG_TYPE]',\n       message: 'The \"key\" argument must be one of type string, Buffer, ' +\n-               `TypedArray, or DataView. Received type ${type}`\n+               `TypedArray, DataView, or KeyObject. Received type ${type}`\n     };\n \n     assert.throws(() => sign.sign(input), errObj);"
        },
        {
            "sha": "e3588856209e28f270cbbef77532589b72218371",
            "filename": "tools/doc/type-parser.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/823d86c47ce15fba8875fcebd412593b02aab362/tools%2Fdoc%2Ftype-parser.js",
            "raw_url": "https://github.com/nodejs/node/raw/823d86c47ce15fba8875fcebd412593b02aab362/tools%2Fdoc%2Ftype-parser.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Ftype-parser.js?ref=823d86c47ce15fba8875fcebd412593b02aab362",
            "patch": "@@ -50,6 +50,7 @@ const customTypesMap = {\n   'ECDH': 'crypto.html#crypto_class_ecdh',\n   'Hash': 'crypto.html#crypto_class_hash',\n   'Hmac': 'crypto.html#crypto_class_hmac',\n+  'KeyObject': 'crypto.html#crypto_class_keyobject',\n   'Sign': 'crypto.html#crypto_class_sign',\n   'Verify': 'crypto.html#crypto_class_verify',\n   'crypto.constants': 'crypto.html#crypto_crypto_constants_1',"
        }
    ],
    "stats": {
        "total": 2651,
        "additions": 1998,
        "deletions": 653
    }
}