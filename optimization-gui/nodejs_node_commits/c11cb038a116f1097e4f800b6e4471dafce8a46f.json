{
    "author": "apapirovski",
    "message": "timers: async track unref timers\n\nWhen async hooks integration for Timers was introduced, it was\nnot included in the code for unref'd or subsequently ref'd\ntimers which means those timers only have Timerwrap hooks.\n\nPR-URL: https://github.com/nodejs/node/pull/18579\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "c11cb038a116f1097e4f800b6e4471dafce8a46f",
    "files": [
        {
            "sha": "954c73f602640202ec8e8ce664a44068698a96dc",
            "filename": "lib/timers.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/c11cb038a116f1097e4f800b6e4471dafce8a46f/lib%2Ftimers.js",
            "raw_url": "https://github.com/nodejs/node/raw/c11cb038a116f1097e4f800b6e4471dafce8a46f/lib%2Ftimers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ftimers.js?ref=c11cb038a116f1097e4f800b6e4471dafce8a46f",
            "patch": "@@ -289,15 +289,15 @@ TimerWrap.prototype[kOnTimeout] = function listOnTimeout(now) {\n \n // An optimization so that the try/finally only de-optimizes (since at least v8\n // 4.7) what is in this smaller function.\n-function tryOnTimeout(timer) {\n+function tryOnTimeout(timer, start) {\n   timer._called = true;\n   const timerAsyncId = (typeof timer[async_id_symbol] === 'number') ?\n     timer[async_id_symbol] : null;\n   var threw = true;\n   if (timerAsyncId !== null)\n     emitBefore(timerAsyncId, timer[trigger_async_id_symbol]);\n   try {\n-    ontimeout(timer);\n+    ontimeout(timer, start);\n     threw = false;\n   } finally {\n     if (timerAsyncId !== null) {\n@@ -520,7 +520,7 @@ function unrefdHandle(now) {\n   try {\n     // Don't attempt to call the callback if it is not a function.\n     if (typeof this.owner._onTimeout === 'function') {\n-      ontimeout(this.owner, now);\n+      tryOnTimeout(this.owner, now);\n     }\n   } finally {\n     // Make sure we clean up if the callback is no longer a function"
        },
        {
            "sha": "8f1d3222ddf662ca5ac2f707c355c94d4f1225af",
            "filename": "test/async-hooks/test-timers.setTimeout.js",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/nodejs/node/blob/c11cb038a116f1097e4f800b6e4471dafce8a46f/test%2Fasync-hooks%2Ftest-timers.setTimeout.js",
            "raw_url": "https://github.com/nodejs/node/raw/c11cb038a116f1097e4f800b6e4471dafce8a46f/test%2Fasync-hooks%2Ftest-timers.setTimeout.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fasync-hooks%2Ftest-timers.setTimeout.js?ref=c11cb038a116f1097e4f800b6e4471dafce8a46f",
            "patch": "@@ -0,0 +1,61 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const tick = require('./tick');\n+const initHooks = require('./init-hooks');\n+const { checkInvocations } = require('./hook-checks');\n+const TIMEOUT = common.platformTimeout(100);\n+\n+const hooks = initHooks();\n+hooks.enable();\n+\n+// install first timeout\n+setTimeout(common.mustCall(ontimeout), TIMEOUT);\n+const as = hooks.activitiesOfTypes('Timeout');\n+assert.strictEqual(as.length, 1);\n+const t1 = as[0];\n+assert.strictEqual(t1.type, 'Timeout');\n+assert.strictEqual(typeof t1.uid, 'number');\n+assert.strictEqual(typeof t1.triggerAsyncId, 'number');\n+checkInvocations(t1, { init: 1 }, 't1: when first timer installed');\n+\n+let timer;\n+let t2;\n+function ontimeout() {\n+  checkInvocations(t1, { init: 1, before: 1 }, 't1: when first timer fired');\n+\n+  setTimeout(onSecondTimeout, TIMEOUT).unref();\n+  const as = hooks.activitiesOfTypes('Timeout');\n+  t2 = as[1];\n+  assert.strictEqual(as.length, 2);\n+  checkInvocations(t1, { init: 1, before: 1 },\n+                   't1: when second timer installed');\n+  checkInvocations(t2, { init: 1 },\n+                   't2: when second timer installed');\n+\n+  timer = setTimeout(common.mustNotCall(), 2 ** 31 - 1);\n+}\n+\n+function onSecondTimeout() {\n+  const as = hooks.activitiesOfTypes('Timeout');\n+  assert.strictEqual(as.length, 3);\n+  checkInvocations(t1, { init: 1, before: 1, after: 1 },\n+                   't1: when second timer fired');\n+  checkInvocations(t2, { init: 1, before: 1 },\n+                   't2: when second timer fired');\n+  clearTimeout(timer);\n+  tick(2);\n+}\n+\n+process.on('exit', onexit);\n+\n+function onexit() {\n+  hooks.disable();\n+  hooks.sanityCheck('Timeout');\n+\n+  checkInvocations(t1, { init: 1, before: 1, after: 1, destroy: 1 },\n+                   't1: when process exits');\n+  checkInvocations(t2, { init: 1, before: 1, after: 1, destroy: 1 },\n+                   't2: when process exits');\n+}"
        }
    ],
    "stats": {
        "total": 67,
        "additions": 64,
        "deletions": 3
    }
}