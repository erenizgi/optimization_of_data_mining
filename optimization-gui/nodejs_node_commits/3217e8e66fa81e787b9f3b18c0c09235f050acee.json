{
    "author": "addaleax",
    "message": "src: re-add `Realloc()` shrink after reading stream data\n\nThis would otherwise keep a lot of unused memory lying around,\nand in particular add up to a page per chunk of memory overhead\nfor network reads, potentially opening a DoS vector if the resulting\n`Buffer` objects are kept around indefinitely (e.g. stored in a list\nand not concatenated until the socket finishes).\n\nThis fixes CVE-2018-7164.\n\nRefs: https://github.com/nodejs-private/security/issues/186\nRefs: https://github.com/nodejs/node/commit/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea\nPR-URL: https://github.com/nodejs-private/node-private/pull/128\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>\nReviewed-By: Evan Lucas <evanlucas@me.com>",
    "sha": "3217e8e66fa81e787b9f3b18c0c09235f050acee",
    "files": [
        {
            "sha": "bb46ea1febbca0d008a0f02c16cee9b3e26a296b",
            "filename": "src/stream_base.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/3217e8e66fa81e787b9f3b18c0c09235f050acee/src%2Fstream_base.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3217e8e66fa81e787b9f3b18c0c09235f050acee/src%2Fstream_base.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.cc?ref=3217e8e66fa81e787b9f3b18c0c09235f050acee",
            "patch": "@@ -374,8 +374,9 @@ void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n   }\n \n   CHECK_LE(static_cast<size_t>(nread), buf.len);\n+  char* base = Realloc(buf.base, nread);\n \n-  Local<Object> obj = Buffer::New(env, buf.base, nread).ToLocalChecked();\n+  Local<Object> obj = Buffer::New(env, base, nread).ToLocalChecked();\n   stream->CallJSOnreadMethod(nread, obj);\n }\n "
        },
        {
            "sha": "8f766e8c7a4106f320b604f24a6a82b636ff3ba2",
            "filename": "test/sequential/test-net-bytes-per-incoming-chunk-overhead.js",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/3217e8e66fa81e787b9f3b18c0c09235f050acee/test%2Fsequential%2Ftest-net-bytes-per-incoming-chunk-overhead.js",
            "raw_url": "https://github.com/nodejs/node/raw/3217e8e66fa81e787b9f3b18c0c09235f050acee/test%2Fsequential%2Ftest-net-bytes-per-incoming-chunk-overhead.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-net-bytes-per-incoming-chunk-overhead.js?ref=3217e8e66fa81e787b9f3b18c0c09235f050acee",
            "patch": "@@ -0,0 +1,41 @@\n+// Flags: --expose-gc\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const net = require('net');\n+\n+// Tests that, when receiving small chunks, we do not keep the full length\n+// of the original allocation for the libuv read call in memory.\n+\n+let client;\n+let baseRSS;\n+const receivedChunks = [];\n+const N = 250000;\n+\n+const server = net.createServer(common.mustCall((socket) => {\n+  baseRSS = process.memoryUsage().rss;\n+\n+  socket.setNoDelay(true);\n+  socket.on('data', (chunk) => {\n+    receivedChunks.push(chunk);\n+    if (receivedChunks.length < N) {\n+      client.write('a');\n+    } else {\n+      client.end();\n+      server.close();\n+    }\n+  });\n+})).listen(0, common.mustCall(() => {\n+  client = net.connect(server.address().port);\n+  client.setNoDelay(true);\n+  client.write('hello!');\n+}));\n+\n+process.on('exit', () => {\n+  global.gc();\n+  const bytesPerChunk =\n+    (process.memoryUsage().rss - baseRSS) / receivedChunks.length;\n+  // We should always have less than one page (usually ~ 4 kB) per chunk.\n+  assert(bytesPerChunk < 512, `measured ${bytesPerChunk} bytes per chunk`);\n+});"
        }
    ],
    "stats": {
        "total": 44,
        "additions": 43,
        "deletions": 1
    }
}