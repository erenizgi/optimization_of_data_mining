{
    "author": "rvagg",
    "message": "deps: float 0c27d793 from openssl (ECDSA blinding)\n\nPending OpenSSL 1.1.0i release.\n\nRefs: https://www.nccgroup.trust/us/our-research/technical-advisory-return-of-the-hidden-number-problem/\nPR-URL: https://github.com/nodejs/node/pull/21345\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Shigeki Ohtsu <ohtsu@ohtsu.org>\nReviewed-By: James M Snell <jasnell@gmail.com>\nUpstream: https://github.com/openssl/openssl/commit/0c27d793\n\nOriginal commit message:\n    Add blinding to an ECDSA signature\n\n    Keegan Ryan (NCC Group) has demonstrated a side channel attack on an\n    ECDSA signature operation. During signing the signer calculates:\n\n    s:= k^-1 * (m + r * priv_key) mod order\n\n    The addition operation above provides a sufficient signal for a\n    flush+reload attack to derive the private key given sufficient signature\n    operations.\n\n    As a mitigation (based on a suggestion from Keegan) we add blinding to\n    the operation so that:\n\n    s := k^-1 * blind^-1 (blind * m + blind * r * priv_key) mod order\n\n    Since this attack is a localhost side channel only no CVE is assigned.\n\n    Reviewed-by: Rich Salz <rsalz@openssl.org>",
    "sha": "831821bcf50e722072b0aeac93aacd2c09caae57",
    "files": [
        {
            "sha": "449be0e92a601bddc1a9616f899d4b4daaf32ce3",
            "filename": "deps/openssl/openssl/crypto/ec/ecdsa_ossl.c",
            "status": "modified",
            "additions": 63,
            "deletions": 7,
            "changes": 70,
            "blob_url": "https://github.com/nodejs/node/blob/831821bcf50e722072b0aeac93aacd2c09caae57/deps%2Fopenssl%2Fopenssl%2Fcrypto%2Fec%2Fecdsa_ossl.c",
            "raw_url": "https://github.com/nodejs/node/raw/831821bcf50e722072b0aeac93aacd2c09caae57/deps%2Fopenssl%2Fopenssl%2Fcrypto%2Fec%2Fecdsa_ossl.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Fcrypto%2Fec%2Fecdsa_ossl.c?ref=831821bcf50e722072b0aeac93aacd2c09caae57",
            "patch": "@@ -210,7 +210,8 @@ ECDSA_SIG *ossl_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,\n                                EC_KEY *eckey)\n {\n     int ok = 0, i;\n-    BIGNUM *kinv = NULL, *s, *m = NULL, *tmp = NULL;\n+    BIGNUM *kinv = NULL, *s, *m = NULL, *tmp = NULL, *blind = NULL;\n+    BIGNUM *blindm = NULL;\n     const BIGNUM *order, *ckinv;\n     BN_CTX *ctx = NULL;\n     const EC_GROUP *group;\n@@ -243,8 +244,18 @@ ECDSA_SIG *ossl_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,\n     }\n     s = ret->s;\n \n-    if ((ctx = BN_CTX_new()) == NULL ||\n-        (tmp = BN_new()) == NULL || (m = BN_new()) == NULL) {\n+    ctx = BN_CTX_secure_new();\n+    if (ctx == NULL) {\n+        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n+        goto err;\n+    }\n+\n+    BN_CTX_start(ctx);\n+    tmp = BN_CTX_get(ctx);\n+    m = BN_CTX_get(ctx);\n+    blind = BN_CTX_get(ctx);\n+    blindm = BN_CTX_get(ctx);\n+    if (blindm == NULL) {\n         ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n         goto err;\n     }\n@@ -284,18 +295,64 @@ ECDSA_SIG *ossl_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,\n             }\n         }\n \n-        if (!BN_mod_mul(tmp, priv_key, ret->r, order, ctx)) {\n+        /*\n+         * The normal signature calculation is:\n+         *\n+         *   s := k^-1 * (m + r * priv_key) mod order\n+         *\n+         * We will blind this to protect against side channel attacks\n+         *\n+         *   s := k^-1 * blind^-1 * (blind * m + blind * r * priv_key) mod order\n+         */\n+\n+        /* Generate a blinding value */\n+        do {\n+            if (!BN_rand(blind, BN_num_bits(order) - 1, BN_RAND_TOP_ANY,\n+                         BN_RAND_BOTTOM_ANY))\n+                goto err;\n+        } while (BN_is_zero(blind));\n+        BN_set_flags(blind, BN_FLG_CONSTTIME);\n+        BN_set_flags(blindm, BN_FLG_CONSTTIME);\n+        BN_set_flags(tmp, BN_FLG_CONSTTIME);\n+\n+        /* tmp := blind * priv_key * r mod order */\n+        if (!BN_mod_mul(tmp, blind, priv_key, order, ctx)) {\n             ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n             goto err;\n         }\n-        if (!BN_mod_add_quick(s, tmp, m, order)) {\n+        if (!BN_mod_mul(tmp, tmp, ret->r, order, ctx)) {\n             ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n             goto err;\n         }\n+\n+        /* blindm := blind * m mod order */\n+        if (!BN_mod_mul(blindm, blind, m, order, ctx)) {\n+            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n+            goto err;\n+        }\n+\n+        /* s : = (blind * priv_key * r) + (blind * m) mod order */\n+        if (!BN_mod_add_quick(s, tmp, blindm, order)) {\n+            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n+            goto err;\n+        }\n+\n+        /* s:= s * blind^-1 mod order */\n+        if (BN_mod_inverse(blind, blind, order, ctx) == NULL) {\n+            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n+            goto err;\n+        }\n+        if (!BN_mod_mul(s, s, blind, order, ctx)) {\n+            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n+            goto err;\n+        }\n+\n+        /* s := s * k^-1 mod order */\n         if (!BN_mod_mul(s, s, ckinv, order, ctx)) {\n             ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n             goto err;\n         }\n+\n         if (BN_is_zero(s)) {\n             /*\n              * if kinv and r have been supplied by the caller don't to\n@@ -317,9 +374,8 @@ ECDSA_SIG *ossl_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,\n         ECDSA_SIG_free(ret);\n         ret = NULL;\n     }\n+    BN_CTX_end(ctx);\n     BN_CTX_free(ctx);\n-    BN_clear_free(m);\n-    BN_clear_free(tmp);\n     BN_clear_free(kinv);\n     return ret;\n }"
        }
    ],
    "stats": {
        "total": 70,
        "additions": 63,
        "deletions": 7
    }
}