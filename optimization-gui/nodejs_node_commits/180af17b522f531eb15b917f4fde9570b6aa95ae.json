{
    "author": "addaleax",
    "message": "string_decoder: reimplement in C++\n\nImplement string decoder in C++. The perks are a decent speed boost\n(for decoding, whereas creation show some performance degradation),\nthat this can now be used more easily to add native decoding support\nto C++ streams and (arguably) more readable variable names.\n\nPR-URL: https://github.com/nodejs/node/pull/18537\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "180af17b522f531eb15b917f4fde9570b6aa95ae",
    "files": [
        {
            "sha": "d955a663307de9a4f903d12522fc7cb992b33f29",
            "filename": "lib/string_decoder.js",
            "status": "modified",
            "additions": 47,
            "deletions": 238,
            "changes": 285,
            "blob_url": "https://github.com/nodejs/node/blob/180af17b522f531eb15b917f4fde9570b6aa95ae/lib%2Fstring_decoder.js",
            "raw_url": "https://github.com/nodejs/node/raw/180af17b522f531eb15b917f4fde9570b6aa95ae/lib%2Fstring_decoder.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fstring_decoder.js?ref=180af17b522f531eb15b917f4fde9570b6aa95ae",
            "patch": "@@ -22,10 +22,23 @@\n 'use strict';\n \n const { Buffer } = require('buffer');\n+const {\n+  kIncompleteCharactersStart,\n+  kIncompleteCharactersEnd,\n+  kMissingBytes,\n+  kBufferedBytes,\n+  kEncodingField,\n+  kSize,\n+  decode,\n+  flush,\n+  encodings\n+} = internalBinding('string_decoder');\n const internalUtil = require('internal/util');\n const errors = require('internal/errors');\n const isEncoding = Buffer[internalUtil.kIsEncodingSymbol];\n \n+const kNativeDecoder = Symbol('kNativeDecoder');\n+\n // Do not cache `Buffer.isEncoding` when checking encoding names as some\n // modules monkey-patch it to support additional encodings\n function normalizeEncoding(enc) {\n@@ -36,258 +49,54 @@ function normalizeEncoding(enc) {\n   return nenc || enc;\n }\n \n+const encodingsMap = {};\n+for (var i = 0; i < encodings.length; ++i)\n+  encodingsMap[encodings[i]] = i;\n+\n // StringDecoder provides an interface for efficiently splitting a series of\n // buffers into a series of JS strings without breaking apart multi-byte\n // characters.\n-exports.StringDecoder = StringDecoder;\n-function StringDecoder(encoding) {\n-  this.encoding = normalizeEncoding(encoding);\n-  var nb;\n-  switch (this.encoding) {\n-    case 'utf16le':\n-      this.text = utf16Text;\n-      this.end = utf16End;\n-      nb = 4;\n-      break;\n-    case 'utf8':\n-      this.fillLast = utf8FillLast;\n-      nb = 4;\n-      break;\n-    case 'base64':\n-      this.text = base64Text;\n-      this.end = base64End;\n-      nb = 3;\n-      break;\n-    default:\n-      this.write = simpleWrite;\n-      this.end = simpleEnd;\n-      return;\n-  }\n-  this.lastNeed = 0;\n-  this.lastTotal = 0;\n-  this.lastChar = Buffer.allocUnsafe(nb);\n-}\n-\n-StringDecoder.prototype.write = function(buf) {\n-  if (buf.length === 0)\n-    return '';\n-  var r;\n-  var i;\n-  if (this.lastNeed) {\n-    r = this.fillLast(buf);\n-    if (r === undefined)\n-      return '';\n-    i = this.lastNeed;\n-    this.lastNeed = 0;\n-  } else {\n-    i = 0;\n-  }\n-  if (i < buf.length)\n-    return (r ? r + this.text(buf, i) : this.text(buf, i));\n-  return r || '';\n-};\n-\n-StringDecoder.prototype.end = utf8End;\n-\n-// Returns only complete characters in a Buffer\n-StringDecoder.prototype.text = utf8Text;\n-\n-// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n-StringDecoder.prototype.fillLast = function(buf) {\n-  if (this.lastNeed <= buf.length) {\n-    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n-    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n-  }\n-  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n-  this.lastNeed -= buf.length;\n-};\n-\n-// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n-// continuation byte. If an invalid byte is detected, -2 is returned.\n-function utf8CheckByte(byte) {\n-  if (byte <= 0x7F)\n-    return 0;\n-  else if (byte >> 5 === 0x06)\n-    return 2;\n-  else if (byte >> 4 === 0x0E)\n-    return 3;\n-  else if (byte >> 3 === 0x1E)\n-    return 4;\n-  return (byte >> 6 === 0x02 ? -1 : -2);\n-}\n-\n-// Checks at most 3 bytes at the end of a Buffer in order to detect an\n-// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n-// needed to complete the UTF-8 character (if applicable) are returned.\n-function utf8CheckIncomplete(self, buf, i) {\n-  var j = buf.length - 1;\n-  if (j < i)\n-    return 0;\n-  var nb = utf8CheckByte(buf[j]);\n-  if (nb >= 0) {\n-    if (nb > 0)\n-      self.lastNeed = nb - 1;\n-    return nb;\n-  }\n-  if (--j < i || nb === -2)\n-    return 0;\n-  nb = utf8CheckByte(buf[j]);\n-  if (nb >= 0) {\n-    if (nb > 0)\n-      self.lastNeed = nb - 2;\n-    return nb;\n-  }\n-  if (--j < i || nb === -2)\n-    return 0;\n-  nb = utf8CheckByte(buf[j]);\n-  if (nb >= 0) {\n-    if (nb > 0) {\n-      if (nb === 2)\n-        nb = 0;\n-      else\n-        self.lastNeed = nb - 3;\n-    }\n-    return nb;\n-  }\n-  return 0;\n-}\n-\n-// Validates as many continuation bytes for a multi-byte UTF-8 character as\n-// needed or are available. If we see a non-continuation byte where we expect\n-// one, we \"replace\" the validated continuation bytes we've seen so far with\n-// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n-// behavior. The continuation byte check is included three times in the case\n-// where all of the continuation bytes for a character exist in the same buffer.\n-// It is also done this way as a slight performance increase instead of using a\n-// loop.\n-function utf8CheckExtraBytes(self, buf, p) {\n-  if ((buf[0] & 0xC0) !== 0x80) {\n-    self.lastNeed = 0;\n-    return '\\ufffd';\n-  }\n-  if (self.lastNeed > 1 && buf.length > 1) {\n-    if ((buf[1] & 0xC0) !== 0x80) {\n-      self.lastNeed = 1;\n-      return '\\ufffd';\n-    }\n-    if (self.lastNeed > 2 && buf.length > 2) {\n-      if ((buf[2] & 0xC0) !== 0x80) {\n-        self.lastNeed = 2;\n-        return '\\ufffd';\n-      }\n-    }\n+class StringDecoder {\n+  constructor(encoding) {\n+    this.encoding = normalizeEncoding(encoding);\n+    this[kNativeDecoder] = Buffer.alloc(kSize);\n+    this[kNativeDecoder][kEncodingField] = encodingsMap[this.encoding];\n   }\n-}\n \n-// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n-function utf8FillLast(buf) {\n-  const p = this.lastTotal - this.lastNeed;\n-  var r = utf8CheckExtraBytes(this, buf, p);\n-  if (r !== undefined)\n-    return r;\n-  if (this.lastNeed <= buf.length) {\n-    buf.copy(this.lastChar, p, 0, this.lastNeed);\n-    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n+  write(buf) {\n+    if (typeof buf === 'string')\n+      return buf;\n+    if (!ArrayBuffer.isView(buf))\n+      throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'buf',\n+                                 ['Buffer', 'Uint8Array', 'ArrayBufferView']);\n+    return decode(this[kNativeDecoder], buf);\n   }\n-  buf.copy(this.lastChar, p, 0, buf.length);\n-  this.lastNeed -= buf.length;\n-}\n \n-// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n-// partial character, the character's bytes are buffered until the required\n-// number of bytes are available.\n-function utf8Text(buf, i) {\n-  const total = utf8CheckIncomplete(this, buf, i);\n-  if (!this.lastNeed)\n-    return buf.toString('utf8', i);\n-  this.lastTotal = total;\n-  const end = buf.length - (total - this.lastNeed);\n-  buf.copy(this.lastChar, 0, end);\n-  return buf.toString('utf8', i, end);\n-}\n-\n-// For UTF-8, a replacement character is added when ending on a partial\n-// character.\n-function utf8End(buf) {\n-  const r = (buf && buf.length ? this.write(buf) : '');\n-  if (this.lastNeed) {\n-    this.lastNeed = 0;\n-    this.lastTotal = 0;\n-    return r + '\\ufffd';\n+  end(buf) {\n+    let ret = '';\n+    if (buf !== undefined)\n+      ret = this.write(buf);\n+    if (this[kNativeDecoder][kBufferedBytes] > 0)\n+      ret += flush(this[kNativeDecoder]);\n+    return ret;\n   }\n-  return r;\n-}\n \n-// UTF-16LE typically needs two bytes per character, but even if we have an even\n-// number of bytes available, we need to check if we end on a leading/high\n-// surrogate. In that case, we need to wait for the next two bytes in order to\n-// decode the last character properly.\n-function utf16Text(buf, i) {\n-  if ((buf.length - i) % 2 === 0) {\n-    const r = buf.toString('utf16le', i);\n-    if (r) {\n-      const c = r.charCodeAt(r.length - 1);\n-      if (c >= 0xD800 && c <= 0xDBFF) {\n-        this.lastNeed = 2;\n-        this.lastTotal = 4;\n-        this.lastChar[0] = buf[buf.length - 2];\n-        this.lastChar[1] = buf[buf.length - 1];\n-        return r.slice(0, -1);\n-      }\n-    }\n-    return r;\n-  }\n-  this.lastNeed = 1;\n-  this.lastTotal = 2;\n-  this.lastChar[0] = buf[buf.length - 1];\n-  return buf.toString('utf16le', i, buf.length - 1);\n-}\n+  /* Everything below this line is undocumented legacy stuff. */\n \n-// For UTF-16LE we do not explicitly append special replacement characters if we\n-// end on a partial character, we simply let v8 handle that.\n-function utf16End(buf) {\n-  const r = (buf && buf.length ? this.write(buf) : '');\n-  if (this.lastNeed) {\n-    const end = this.lastTotal - this.lastNeed;\n-    this.lastNeed = 0;\n-    this.lastTotal = 0;\n-    return r + this.lastChar.toString('utf16le', 0, end);\n+  text(buf, offset) {\n+    this[kNativeDecoder][kMissingBytes] = 0;\n+    this[kNativeDecoder][kBufferedBytes] = 0;\n+    return this.write(buf.slice(offset));\n   }\n-  return r;\n-}\n \n-function base64Text(buf, i) {\n-  const n = (buf.length - i) % 3;\n-  if (n === 0)\n-    return buf.toString('base64', i);\n-  this.lastNeed = 3 - n;\n-  this.lastTotal = 3;\n-  if (n === 1) {\n-    this.lastChar[0] = buf[buf.length - 1];\n-  } else {\n-    this.lastChar[0] = buf[buf.length - 2];\n-    this.lastChar[1] = buf[buf.length - 1];\n+  get lastTotal() {\n+    return this[kNativeDecoder][kBufferedBytes] + this.lastNeed;\n   }\n-  return buf.toString('base64', i, buf.length - n);\n-}\n-\n \n-function base64End(buf) {\n-  const r = (buf && buf.length ? this.write(buf) : '');\n-  if (this.lastNeed) {\n-    const end = 3 - this.lastNeed;\n-    this.lastNeed = 0;\n-    this.lastTotal = 0;\n-    return r + this.lastChar.toString('base64', 0, end);\n+  get lastChar() {\n+    return this[kNativeDecoder].subarray(kIncompleteCharactersStart,\n+                                         kIncompleteCharactersEnd);\n   }\n-  return r;\n }\n \n-// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n-function simpleWrite(buf) {\n-  return buf.toString(this.encoding);\n-}\n-\n-function simpleEnd(buf) {\n-  return (buf && buf.length ? this.write(buf) : '');\n-}\n+exports.StringDecoder = StringDecoder;"
        },
        {
            "sha": "e2b17cd2b5fae6f7f686a4051f017852fd453e8e",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/180af17b522f531eb15b917f4fde9570b6aa95ae/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/180af17b522f531eb15b917f4fde9570b6aa95ae/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=180af17b522f531eb15b917f4fde9570b6aa95ae",
            "patch": "@@ -326,6 +326,7 @@\n         'src/signal_wrap.cc',\n         'src/spawn_sync.cc',\n         'src/string_bytes.cc',\n+        'src/string_decoder.cc',\n         'src/string_search.cc',\n         'src/stream_base.cc',\n         'src/stream_wrap.cc',\n@@ -379,6 +380,8 @@\n         'src/req_wrap.h',\n         'src/req_wrap-inl.h',\n         'src/string_bytes.h',\n+        'src/string_decoder.h',\n+        'src/string_decoder-inl.h',\n         'src/stream_base.h',\n         'src/stream_base-inl.h',\n         'src/stream_wrap.h',\n@@ -989,6 +992,7 @@\n         '<(obj_path)<(obj_separator)node_url.<(obj_suffix)',\n         '<(obj_path)<(obj_separator)util.<(obj_suffix)',\n         '<(obj_path)<(obj_separator)string_bytes.<(obj_suffix)',\n+        '<(obj_path)<(obj_separator)string_decoder.<(obj_suffix)',\n         '<(obj_path)<(obj_separator)string_search.<(obj_suffix)',\n         '<(obj_path)<(obj_separator)stream_base.<(obj_suffix)',\n         '<(obj_path)<(obj_separator)node_constants.<(obj_suffix)',"
        },
        {
            "sha": "094fcc2d839d5fdaf1cbfe61885041773bbadb67",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/180af17b522f531eb15b917f4fde9570b6aa95ae/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/180af17b522f531eb15b917f4fde9570b6aa95ae/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=180af17b522f531eb15b917f4fde9570b6aa95ae",
            "patch": "@@ -120,6 +120,7 @@ struct sockaddr;\n     V(signal_wrap)                                                            \\\n     V(spawn_sync)                                                             \\\n     V(stream_wrap)                                                            \\\n+    V(string_decoder)                                                         \\\n     V(tcp_wrap)                                                               \\\n     V(timer_wrap)                                                             \\\n     V(trace_events)                                                           \\"
        },
        {
            "sha": "8a04211906f7592c29cc8e0628959e6fefb91762",
            "filename": "src/string_decoder-inl.h",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/180af17b522f531eb15b917f4fde9570b6aa95ae/src%2Fstring_decoder-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/180af17b522f531eb15b917f4fde9570b6aa95ae/src%2Fstring_decoder-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_decoder-inl.h?ref=180af17b522f531eb15b917f4fde9570b6aa95ae",
            "patch": "@@ -0,0 +1,38 @@\n+#ifndef SRC_STRING_DECODER_INL_H_\n+#define SRC_STRING_DECODER_INL_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"string_decoder.h\"\n+#include \"util.h\"\n+\n+namespace node {\n+\n+void StringDecoder::SetEncoding(enum encoding encoding) {\n+  state_[kBufferedBytes] = 0;\n+  state_[kMissingBytes] = 0;\n+  state_[kEncodingField] = encoding;\n+}\n+\n+enum encoding StringDecoder::Encoding() const {\n+  return static_cast<enum encoding>(state_[kEncodingField]);\n+}\n+\n+unsigned StringDecoder::BufferedBytes() const {\n+  return state_[kBufferedBytes];\n+}\n+\n+unsigned StringDecoder::MissingBytes() const {\n+  return state_[kMissingBytes];\n+}\n+\n+char* StringDecoder::IncompleteCharacterBuffer() {\n+  return reinterpret_cast<char*>(state_ + kIncompleteCharactersStart);\n+}\n+\n+\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#endif   // SRC_STRING_DECODER_INL_H_"
        },
        {
            "sha": "ad1bace918c6788eed002f1221d5d03d8257edc7",
            "filename": "src/string_decoder.cc",
            "status": "added",
            "additions": 334,
            "deletions": 0,
            "changes": 334,
            "blob_url": "https://github.com/nodejs/node/blob/180af17b522f531eb15b917f4fde9570b6aa95ae/src%2Fstring_decoder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/180af17b522f531eb15b917f4fde9570b6aa95ae/src%2Fstring_decoder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_decoder.cc?ref=180af17b522f531eb15b917f4fde9570b6aa95ae",
            "patch": "@@ -0,0 +1,334 @@\n+#include \"string_decoder-inl.h\"\n+#include \"string_bytes.h\"\n+#include \"node_internals.h\"\n+#include \"node_buffer.h\"\n+\n+using v8::Array;\n+using v8::Context;\n+using v8::FunctionCallbackInfo;\n+using v8::Integer;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::Object;\n+using v8::String;\n+using v8::Value;\n+\n+namespace node {\n+\n+namespace {\n+\n+MaybeLocal<String> MakeString(Isolate* isolate,\n+                              const char* data,\n+                              size_t length,\n+                              enum encoding encoding) {\n+  Local<Value> error;\n+  MaybeLocal<Value> ret;\n+  if (encoding == UTF8) {\n+    return String::NewFromUtf8(\n+        isolate,\n+        data,\n+        v8::NewStringType::kNormal,\n+        length);\n+  } else if (encoding == UCS2) {\n+#ifdef DEBUG\n+    CHECK_EQ(reinterpret_cast<uintptr_t>(data) % 2, 0);\n+    CHECK_EQ(length % 2, 0);\n+#endif\n+    ret = StringBytes::Encode(\n+        isolate,\n+        reinterpret_cast<const uint16_t*>(data),\n+        length / 2,\n+        &error);\n+  } else {\n+    ret = StringBytes::Encode(\n+        isolate,\n+        data,\n+        length,\n+        encoding,\n+        &error);\n+  }\n+\n+  if (ret.IsEmpty()) {\n+    CHECK(!error.IsEmpty());\n+    isolate->ThrowException(error);\n+  }\n+\n+#ifdef DEBUG\n+  CHECK(ret.IsEmpty() || ret.ToLocalChecked()->IsString());\n+#endif\n+  return ret.FromMaybe(Local<Value>()).As<String>();\n+}\n+\n+}  // anonymous namespace\n+\n+\n+MaybeLocal<String> StringDecoder::DecodeData(Isolate* isolate,\n+                                             const char* data,\n+                                             size_t* nread_ptr) {\n+  Local<String> prepend, body;\n+\n+  size_t nread = *nread_ptr;\n+\n+  if (Encoding() == UTF8 || Encoding() == UCS2 || Encoding() == BASE64) {\n+    // See if we want bytes to finish a character from the previous\n+    // chunk; if so, copy the new bytes to the missing bytes buffer\n+    // and create a small string from it that is to be prepended to the\n+    // main body.\n+    if (MissingBytes() > 0) {\n+      // There are never more bytes missing than the pre-calculated maximum.\n+      CHECK_LE(MissingBytes() + BufferedBytes(),\n+               kIncompleteCharactersEnd);\n+      if (Encoding() == UTF8) {\n+        // For UTF-8, we need special treatment to align with the V8 decoder:\n+        // If an incomplete character is found at a chunk boundary, we turn\n+        // that character into a single invalid one.\n+        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {\n+          if ((data[i] & 0xC0) != 0x80) {\n+            // This byte is not a continuation byte even though it should have\n+            // been one.\n+            // Act as if there was a 1-byte incomplete character, which does\n+            // not make sense but works here because we know it's invalid.\n+            state_[kMissingBytes] = 0;\n+            state_[kBufferedBytes] = 1;\n+            data += i;\n+            nread -= i;\n+            break;\n+          }\n+        }\n+      }\n+\n+      size_t found_bytes =\n+          std::min(nread, static_cast<size_t>(MissingBytes()));\n+      memcpy(IncompleteCharacterBuffer() + BufferedBytes(),\n+             data,\n+             found_bytes);\n+      // Adjust the two buffers.\n+      data += found_bytes;\n+      nread -= found_bytes;\n+\n+      state_[kMissingBytes] -= found_bytes;\n+      state_[kBufferedBytes] += found_bytes;\n+\n+      if (LIKELY(MissingBytes() == 0)) {\n+        // If no more bytes are missing, create a small string that we\n+        // will later prepend.\n+        if (!MakeString(isolate,\n+                        IncompleteCharacterBuffer(),\n+                        BufferedBytes(),\n+                        Encoding()).ToLocal(&prepend)) {\n+          return MaybeLocal<String>();\n+        }\n+\n+        *nread_ptr += BufferedBytes();\n+        // No more buffered bytes.\n+        state_[kBufferedBytes] = 0;\n+      }\n+    }\n+\n+    // It could be that trying to finish the previous chunk already\n+    // consumed all data that we received in this chunk.\n+    if (UNLIKELY(nread == 0)) {\n+      body = !prepend.IsEmpty() ? prepend : String::Empty(isolate);\n+      prepend = Local<String>();\n+    } else {\n+#ifdef DEBUG\n+      // If not, that means is no character left to finish at this point.\n+      CHECK_EQ(MissingBytes(), 0);\n+      CHECK_EQ(BufferedBytes(), 0);\n+#endif\n+\n+      // See whether there is a character that we may have to cut off and\n+      // finish when receiving the next chunk.\n+      if (Encoding() == UTF8 && data[nread - 1] & 0x80) {\n+        // This is UTF-8 encoded data and we ended on a non-ASCII UTF-8 byte.\n+        // This means we'll need to figure out where the character to which\n+        // the byte belongs begins.\n+        for (size_t i = nread - 1; ; --i) {\n+#ifdef DEBUG\n+          CHECK_LT(i, nread);\n+#endif\n+          state_[kBufferedBytes]++;\n+          if ((data[i] & 0xC0) == 0x80) {\n+            // This byte does not start a character (a \"trailing\" byte).\n+            if (state_[kBufferedBytes] >= 4 || i == 0) {\n+              // We either have more then 4 trailing bytes (which means\n+              // the current character would not be inside the range for\n+              // valid Unicode, and in particular cannot be represented\n+              // through JavaScript's UTF-16-based approach to strings), or the\n+              // current buffer does not contain the start of an UTF-8 character\n+              // at all. Either way, this is invalid UTF8 and we can just\n+              // let the engine's decoder handle it.\n+              state_[kBufferedBytes] = 0;\n+              break;\n+            }\n+          } else {\n+            // Found the first byte of a UTF-8 character. By looking at the\n+            // upper bits we can tell how long the character *should* be.\n+            if ((data[i] & 0xE0) == 0xC0) {\n+              state_[kMissingBytes] = 2;\n+            } else if ((data[i] & 0xF0) == 0xE0) {\n+              state_[kMissingBytes] = 3;\n+            } else if ((data[i] & 0xF8) == 0xF0) {\n+              state_[kMissingBytes] = 4;\n+            } else {\n+              // This lead byte would indicate a character outside of the\n+              // representable range.\n+              state_[kBufferedBytes] = 0;\n+              break;\n+            }\n+\n+            if (BufferedBytes() >= MissingBytes()) {\n+              // Received more or exactly as many trailing bytes than the lead\n+              // character would indicate. In the \"==\" case, we have valid\n+              // data and don't need to slice anything off;\n+              // in the \">\" case, this is invalid UTF-8 anyway.\n+              state_[kMissingBytes] = 0;\n+              state_[kBufferedBytes] = 0;\n+            }\n+\n+            state_[kMissingBytes] -= state_[kBufferedBytes];\n+            break;\n+          }\n+        }\n+      } else if (Encoding() == UCS2) {\n+        if ((nread % 2) == 1) {\n+          // We got half a codepoint, and need the second byte of it.\n+          state_[kBufferedBytes] = 1;\n+          state_[kMissingBytes] = 1;\n+        } else if ((data[nread - 1] & 0xFC) == 0xD8) {\n+          // Half a split UTF-16 character.\n+          state_[kBufferedBytes] = 2;\n+          state_[kMissingBytes] = 2;\n+        }\n+      } else if (Encoding() == BASE64) {\n+        state_[kBufferedBytes] = nread % 3;\n+        if (state_[kBufferedBytes] > 0)\n+          state_[kMissingBytes] = 3 - BufferedBytes();\n+      }\n+\n+      if (BufferedBytes() > 0) {\n+        // Copy the requested number of buffered bytes from the end of the\n+        // input into the incomplete character buffer.\n+        nread -= BufferedBytes();\n+        *nread_ptr -= BufferedBytes();\n+        memcpy(IncompleteCharacterBuffer(), data + nread, BufferedBytes());\n+      }\n+\n+      if (nread > 0) {\n+        if (!MakeString(isolate, data, nread, Encoding()).ToLocal(&body))\n+          return MaybeLocal<String>();\n+      } else {\n+        body = String::Empty(isolate);\n+      }\n+    }\n+\n+    if (prepend.IsEmpty()) {\n+      return body;\n+    } else {\n+      return String::Concat(prepend, body);\n+    }\n+  } else {\n+    CHECK(Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1);\n+    return MakeString(isolate, data, nread, Encoding());\n+  }\n+}\n+\n+MaybeLocal<String> StringDecoder::FlushData(Isolate* isolate) {\n+  if (Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1) {\n+    CHECK_EQ(MissingBytes(), 0);\n+    CHECK_EQ(BufferedBytes(), 0);\n+  }\n+\n+  if (Encoding() == UCS2 && BufferedBytes() % 2 == 1) {\n+    // Ignore a single trailing byte, like the JS decoder does.\n+    state_[kMissingBytes]--;\n+    state_[kBufferedBytes]--;\n+  }\n+\n+  if (BufferedBytes() == 0)\n+    return String::Empty(isolate);\n+\n+  MaybeLocal<String> ret =\n+      MakeString(isolate,\n+                 IncompleteCharacterBuffer(),\n+                 BufferedBytes(),\n+                 Encoding());\n+\n+  state_[kMissingBytes] = 0;\n+  state_[kBufferedBytes] = 0;\n+\n+  return ret;\n+}\n+\n+namespace {\n+\n+void DecodeData(const FunctionCallbackInfo<Value>& args) {\n+  StringDecoder* decoder =\n+      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));\n+  CHECK_NE(decoder, nullptr);\n+  size_t nread = Buffer::Length(args[1]);\n+  MaybeLocal<String> ret =\n+      decoder->DecodeData(args.GetIsolate(), Buffer::Data(args[1]), &nread);\n+  if (!ret.IsEmpty())\n+    args.GetReturnValue().Set(ret.ToLocalChecked());\n+}\n+\n+void FlushData(const FunctionCallbackInfo<Value>& args) {\n+  StringDecoder* decoder =\n+      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));\n+  CHECK_NE(decoder, nullptr);\n+  MaybeLocal<String> ret = decoder->FlushData(args.GetIsolate());\n+  if (!ret.IsEmpty())\n+    args.GetReturnValue().Set(ret.ToLocalChecked());\n+}\n+\n+void InitializeStringDecoder(Local<Object> target,\n+                             Local<Value> unused,\n+                             Local<Context> context) {\n+  Environment* env = Environment::GetCurrent(context);\n+  Isolate* isolate = env->isolate();\n+\n+#define SET_DECODER_CONSTANT(name)                                            \\\n+  target->Set(context,                                                        \\\n+              FIXED_ONE_BYTE_STRING(isolate, #name),                          \\\n+              Integer::New(isolate, StringDecoder::name)).FromJust()\n+\n+  SET_DECODER_CONSTANT(kIncompleteCharactersStart);\n+  SET_DECODER_CONSTANT(kIncompleteCharactersEnd);\n+  SET_DECODER_CONSTANT(kMissingBytes);\n+  SET_DECODER_CONSTANT(kBufferedBytes);\n+  SET_DECODER_CONSTANT(kEncodingField);\n+  SET_DECODER_CONSTANT(kNumFields);\n+\n+  Local<Array> encodings = Array::New(isolate);\n+#define ADD_TO_ENCODINGS_ARRAY(cname, jsname)                                 \\\n+  encodings->Set(context,                                                     \\\n+                 static_cast<int32_t>(cname),                                 \\\n+                 FIXED_ONE_BYTE_STRING(isolate, jsname)).FromJust()\n+  ADD_TO_ENCODINGS_ARRAY(ASCII, \"ascii\");\n+  ADD_TO_ENCODINGS_ARRAY(UTF8, \"utf8\");\n+  ADD_TO_ENCODINGS_ARRAY(BASE64, \"base64\");\n+  ADD_TO_ENCODINGS_ARRAY(UCS2, \"utf16le\");\n+  ADD_TO_ENCODINGS_ARRAY(HEX, \"hex\");\n+  ADD_TO_ENCODINGS_ARRAY(BUFFER, \"buffer\");\n+  ADD_TO_ENCODINGS_ARRAY(LATIN1, \"latin1\");\n+\n+  target->Set(context,\n+              FIXED_ONE_BYTE_STRING(isolate, \"encodings\"),\n+              encodings).FromJust();\n+\n+  target->Set(context,\n+              FIXED_ONE_BYTE_STRING(isolate, \"kSize\"),\n+              Integer::New(isolate, sizeof(StringDecoder))).FromJust();\n+\n+  env->SetMethod(target, \"decode\", DecodeData);\n+  env->SetMethod(target, \"flush\", FlushData);\n+}\n+\n+}  // anonymous namespace\n+\n+}  // namespace node\n+\n+NODE_MODULE_CONTEXT_AWARE_INTERNAL(string_decoder,\n+                                   node::InitializeStringDecoder)"
        },
        {
            "sha": "9059eeaa9d2eb7c1a301a8ec3accd832a1dac284",
            "filename": "src/string_decoder.h",
            "status": "added",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/nodejs/node/blob/180af17b522f531eb15b917f4fde9570b6aa95ae/src%2Fstring_decoder.h",
            "raw_url": "https://github.com/nodejs/node/raw/180af17b522f531eb15b917f4fde9570b6aa95ae/src%2Fstring_decoder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_decoder.h?ref=180af17b522f531eb15b917f4fde9570b6aa95ae",
            "patch": "@@ -0,0 +1,50 @@\n+#ifndef SRC_STRING_DECODER_H_\n+#define SRC_STRING_DECODER_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"node.h\"\n+\n+namespace node {\n+\n+class StringDecoder {\n+ public:\n+  StringDecoder() { state_[kEncodingField] = BUFFER; }\n+  inline void SetEncoding(enum encoding encoding);\n+  inline enum encoding Encoding() const;\n+\n+  inline char* IncompleteCharacterBuffer();\n+  inline unsigned MissingBytes() const;\n+  inline unsigned BufferedBytes() const;\n+\n+  // Decode a string from the specified encoding.\n+  // The value pointed to by `nread` will be modified to reflect that\n+  // less data may have been read because it ended on an incomplete character\n+  // and more data may have been read because a previously incomplete character\n+  // was finished.\n+  v8::MaybeLocal<v8::String> DecodeData(v8::Isolate* isolate,\n+                                        const char* data,\n+                                        size_t* nread);\n+  // Flush an incomplete character. For character encodings like UTF8 this\n+  // means printing replacement characters, buf for e.g. Base64 the returned\n+  // string contains more data.\n+  v8::MaybeLocal<v8::String> FlushData(v8::Isolate* isolate);\n+\n+  enum Fields {\n+    kIncompleteCharactersStart = 0,\n+    kIncompleteCharactersEnd = 4,\n+    kMissingBytes = 4,\n+    kBufferedBytes = 5,\n+    kEncodingField = 6,\n+    kNumFields = 7\n+  };\n+\n+ private:\n+  uint8_t state_[kNumFields] = {};\n+};\n+\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#endif   // SRC_STRING_DECODER_H_"
        },
        {
            "sha": "21a0b6c3e385391a62144e876b0866342df35282",
            "filename": "test/parallel/test-string-decoder.js",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/180af17b522f531eb15b917f4fde9570b6aa95ae/test%2Fparallel%2Ftest-string-decoder.js",
            "raw_url": "https://github.com/nodejs/node/raw/180af17b522f531eb15b917f4fde9570b6aa95ae/test%2Fparallel%2Ftest-string-decoder.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-string-decoder.js?ref=180af17b522f531eb15b917f4fde9570b6aa95ae",
            "patch": "@@ -128,6 +128,10 @@ assert.strictEqual(decoder.write(Buffer.from('3DD8', 'hex')), '');\n assert.strictEqual(decoder.write(Buffer.from('4D', 'hex')), '');\n assert.strictEqual(decoder.end(), '\\ud83d');\n \n+decoder = new StringDecoder('utf16le');\n+assert.strictEqual(decoder.write(Buffer.from('3DD84D', 'hex')), '\\ud83d');\n+assert.strictEqual(decoder.end(), '');\n+\n common.expectsError(\n   () => new StringDecoder(1),\n   {"
        }
    ],
    "stats": {
        "total": 716,
        "additions": 478,
        "deletions": 238
    }
}