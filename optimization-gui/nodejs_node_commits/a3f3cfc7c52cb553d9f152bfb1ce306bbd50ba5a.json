{
    "author": "Hackzzila",
    "message": "deps: add brotli\n\nCo-authored-by: Anna Henningsen <anna@addaleax.net>\n\nPR-URL: https://github.com/nodejs/node/pull/24938\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Jan Krems <jan.krems@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Myles Borins <myles.borins@gmail.com>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
    "files": [
        {
            "sha": "33b7cdd2dbaeddce1e35aa1a13f63d71154dc42f",
            "filename": "deps/brotli/LICENSE",
            "status": "added",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2FLICENSE",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2FLICENSE",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2FLICENSE?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,19 @@\n+Copyright (c) 2009, 2010, 2013-2016 by the Brotli Authors.\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE."
        },
        {
            "sha": "dba8321786f35345b7b127aaa1fc2eccaae2f7f5",
            "filename": "deps/brotli/brotli.gyp",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fbrotli.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fbrotli.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fbrotli.gyp?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,63 @@\n+{\n+  'targets': [\n+    {\n+      'target_name': 'brotli',\n+      'type': 'static_library',\n+      'include_dirs': ['c/include'],\n+      'conditions': [\n+        ['OS==\"linux\"', {\n+          'defines': [\n+            'OS_LINUX'\n+          ]\n+        }],\n+        ['OS==\"freebsd\"', {\n+          'defines': [\n+            'OS_FREEBSD'\n+          ]\n+        }],\n+        ['OS==\"mac\"', {\n+          'defines': [\n+            'OS_MACOSX'\n+          ]\n+        }],\n+      ],\n+      'direct_dependent_settings': {\n+        'include_dirs': [ 'c/include' ]\n+      },\n+      'libraries': [\n+        '-lm',\n+      ],\n+      'sources': [\n+        # Common\n+        'c/common/dictionary.c',\n+        'c/common/transform.c',\n+\n+        # Decoder\n+        'c/dec/bit_reader.c',\n+        'c/dec/decode.c',\n+        'c/dec/huffman.c',\n+        'c/dec/state.c',\n+\n+        # Encoder\n+        'c/enc/backward_references.c',\n+        'c/enc/backward_references_hq.c',\n+        'c/enc/bit_cost.c',\n+        'c/enc/block_splitter.c',\n+        'c/enc/brotli_bit_stream.c',\n+        'c/enc/cluster.c',\n+        'c/enc/compress_fragment.c',\n+        'c/enc/compress_fragment_two_pass.c',\n+        'c/enc/dictionary_hash.c',\n+        'c/enc/encode.c',\n+        'c/enc/encoder_dict.c',\n+        'c/enc/entropy_encode.c',\n+        'c/enc/histogram.c',\n+        'c/enc/literal_cost.c',\n+        'c/enc/memory.c',\n+        'c/enc/metablock.c',\n+        'c/enc/static_dict.c',\n+        'c/enc/utf8_util.c'\n+      ]\n+    }\n+  ]\n+}"
        },
        {
            "sha": "d1b88d12af3874793cf0d89765da26c7ddb76679",
            "filename": "deps/brotli/c/common/constants.h",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fconstants.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fconstants.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Fconstants.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,64 @@\n+/* Copyright 2016 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+#ifndef BROTLI_COMMON_CONSTANTS_H_\n+#define BROTLI_COMMON_CONSTANTS_H_\n+\n+/* Specification: 7.3. Encoding of the context map */\n+#define BROTLI_CONTEXT_MAP_MAX_RLE 16\n+\n+/* Specification: 2. Compressed representation overview */\n+#define BROTLI_MAX_NUMBER_OF_BLOCK_TYPES 256\n+\n+/* Specification: 3.3. Alphabet sizes: insert-and-copy length */\n+#define BROTLI_NUM_LITERAL_SYMBOLS 256\n+#define BROTLI_NUM_COMMAND_SYMBOLS 704\n+#define BROTLI_NUM_BLOCK_LEN_SYMBOLS 26\n+#define BROTLI_MAX_CONTEXT_MAP_SYMBOLS (BROTLI_MAX_NUMBER_OF_BLOCK_TYPES + \\\n+                                        BROTLI_CONTEXT_MAP_MAX_RLE)\n+#define BROTLI_MAX_BLOCK_TYPE_SYMBOLS (BROTLI_MAX_NUMBER_OF_BLOCK_TYPES + 2)\n+\n+/* Specification: 3.5. Complex prefix codes */\n+#define BROTLI_REPEAT_PREVIOUS_CODE_LENGTH 16\n+#define BROTLI_REPEAT_ZERO_CODE_LENGTH 17\n+#define BROTLI_CODE_LENGTH_CODES (BROTLI_REPEAT_ZERO_CODE_LENGTH + 1)\n+/* \"code length of 8 is repeated\" */\n+#define BROTLI_INITIAL_REPEATED_CODE_LENGTH 8\n+\n+/* \"Large Window Brotli\" */\n+#define BROTLI_LARGE_MAX_DISTANCE_BITS 62U\n+#define BROTLI_LARGE_MIN_WBITS 10\n+#define BROTLI_LARGE_MAX_WBITS 30\n+\n+/* Specification: 4. Encoding of distances */\n+#define BROTLI_NUM_DISTANCE_SHORT_CODES 16\n+#define BROTLI_MAX_NPOSTFIX 3\n+#define BROTLI_MAX_NDIRECT 120\n+#define BROTLI_MAX_DISTANCE_BITS 24U\n+#define BROTLI_DISTANCE_ALPHABET_SIZE(NPOSTFIX, NDIRECT, MAXNBITS) ( \\\n+    BROTLI_NUM_DISTANCE_SHORT_CODES + (NDIRECT) +                    \\\n+    ((MAXNBITS) << ((NPOSTFIX) + 1)))\n+/* BROTLI_NUM_DISTANCE_SYMBOLS == 1128 */\n+#define BROTLI_NUM_DISTANCE_SYMBOLS \\\n+    BROTLI_DISTANCE_ALPHABET_SIZE(  \\\n+        BROTLI_MAX_NDIRECT, BROTLI_MAX_NPOSTFIX, BROTLI_LARGE_MAX_DISTANCE_BITS)\n+#define BROTLI_MAX_DISTANCE 0x3FFFFFC\n+#define BROTLI_MAX_ALLOWED_DISTANCE 0x7FFFFFFC\n+\n+/* 7.1. Context modes and context ID lookup for literals */\n+/* \"context IDs for literals are in the range of 0..63\" */\n+#define BROTLI_LITERAL_CONTEXT_BITS 6\n+\n+/* 7.2. Context ID for distances */\n+#define BROTLI_DISTANCE_CONTEXT_BITS 2\n+\n+/* 9.1. Format of the Stream Header */\n+/* Number of slack bytes for window size. Don't confuse\n+   with BROTLI_NUM_DISTANCE_SHORT_CODES. */\n+#define BROTLI_WINDOW_GAP 16\n+#define BROTLI_MAX_BACKWARD_LIMIT(W) (((size_t)1 << (W)) - BROTLI_WINDOW_GAP)\n+\n+#endif  /* BROTLI_COMMON_CONSTANTS_H_ */"
        },
        {
            "sha": "24b3eb48f533390a1b1fa8330fb8176df50c718e",
            "filename": "deps/brotli/c/common/context.h",
            "status": "added",
            "additions": 261,
            "deletions": 0,
            "changes": 261,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fcontext.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fcontext.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Fcontext.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,261 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Lookup table to map the previous two bytes to a context id.\n+\n+  There are four different context modeling modes defined here:\n+    CONTEXT_LSB6: context id is the least significant 6 bits of the last byte,\n+    CONTEXT_MSB6: context id is the most significant 6 bits of the last byte,\n+    CONTEXT_UTF8: second-order context model tuned for UTF8-encoded text,\n+    CONTEXT_SIGNED: second-order context model tuned for signed integers.\n+\n+  If |p1| and |p2| are the previous two bytes, and |mode| is current context\n+  mode, we calculate the context as:\n+\n+    context = ContextLut(mode)[p1] | ContextLut(mode)[p2 + 256].\n+\n+  For CONTEXT_UTF8 mode, if the previous two bytes are ASCII characters\n+  (i.e. < 128), this will be equivalent to\n+\n+    context = 4 * context1(p1) + context2(p2),\n+\n+  where context1 is based on the previous byte in the following way:\n+\n+    0  : non-ASCII control\n+    1  : \\t, \\n, \\r\n+    2  : space\n+    3  : other punctuation\n+    4  : \" '\n+    5  : %\n+    6  : ( < [ {\n+    7  : ) > ] }\n+    8  : , ; :\n+    9  : .\n+    10 : =\n+    11 : number\n+    12 : upper-case vowel\n+    13 : upper-case consonant\n+    14 : lower-case vowel\n+    15 : lower-case consonant\n+\n+  and context2 is based on the second last byte:\n+\n+    0 : control, space\n+    1 : punctuation\n+    2 : upper-case letter, number\n+    3 : lower-case letter\n+\n+  If the last byte is ASCII, and the second last byte is not (in a valid UTF8\n+  stream it will be a continuation byte, value between 128 and 191), the\n+  context is the same as if the second last byte was an ASCII control or space.\n+\n+  If the last byte is a UTF8 lead byte (value >= 192), then the next byte will\n+  be a continuation byte and the context id is 2 or 3 depending on the LSB of\n+  the last byte and to a lesser extent on the second last byte if it is ASCII.\n+\n+  If the last byte is a UTF8 continuation byte, the second last byte can be:\n+    - continuation byte: the next byte is probably ASCII or lead byte (assuming\n+      4-byte UTF8 characters are rare) and the context id is 0 or 1.\n+    - lead byte (192 - 207): next byte is ASCII or lead byte, context is 0 or 1\n+    - lead byte (208 - 255): next byte is continuation byte, context is 2 or 3\n+\n+  The possible value combinations of the previous two bytes, the range of\n+  context ids and the type of the next byte is summarized in the table below:\n+\n+  |--------\\-----------------------------------------------------------------|\n+  |         \\                         Last byte                              |\n+  | Second   \\---------------------------------------------------------------|\n+  | last byte \\    ASCII            |   cont. byte        |   lead byte      |\n+  |            \\   (0-127)          |   (128-191)         |   (192-)         |\n+  |=============|===================|=====================|==================|\n+  |  ASCII      | next: ASCII/lead  |  not valid          |  next: cont.     |\n+  |  (0-127)    | context: 4 - 63   |                     |  context: 2 - 3  |\n+  |-------------|-------------------|---------------------|------------------|\n+  |  cont. byte | next: ASCII/lead  |  next: ASCII/lead   |  next: cont.     |\n+  |  (128-191)  | context: 4 - 63   |  context: 0 - 1     |  context: 2 - 3  |\n+  |-------------|-------------------|---------------------|------------------|\n+  |  lead byte  | not valid         |  next: ASCII/lead   |  not valid       |\n+  |  (192-207)  |                   |  context: 0 - 1     |                  |\n+  |-------------|-------------------|---------------------|------------------|\n+  |  lead byte  | not valid         |  next: cont.        |  not valid       |\n+  |  (208-)     |                   |  context: 2 - 3     |                  |\n+  |-------------|-------------------|---------------------|------------------|\n+*/\n+\n+#ifndef BROTLI_COMMON_CONTEXT_H_\n+#define BROTLI_COMMON_CONTEXT_H_\n+\n+#include <brotli/types.h>\n+\n+typedef enum ContextType {\n+  CONTEXT_LSB6 = 0,\n+  CONTEXT_MSB6 = 1,\n+  CONTEXT_UTF8 = 2,\n+  CONTEXT_SIGNED = 3\n+} ContextType;\n+\n+/* Common context lookup table for all context modes. */\n+static const uint8_t kContextLookup[2048] = {\n+  /* CONTEXT_LSB6, last byte. */\n+   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n+   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n+   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n+   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n+\n+  /* CONTEXT_LSB6, second last byte, */\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+  /* CONTEXT_MSB6, last byte. */\n+   0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,\n+   4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,\n+   8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11,\n+  12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15,\n+  16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,\n+  20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,\n+  24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27,\n+  28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31,\n+  32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35,\n+  36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39,\n+  40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43,\n+  44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47,\n+  48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51,\n+  52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55,\n+  56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59,\n+  60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63,\n+\n+  /* CONTEXT_MSB6, second last byte, */\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\n+  /* CONTEXT_UTF8, last byte. */\n+  /* ASCII range. */\n+   0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  4,  0,  0,  4,  0,  0,\n+   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36, 12,\n+  44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32, 24, 40, 28, 12,\n+  12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48,\n+  52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12,\n+  12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56,\n+  60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12,  0,\n+  /* UTF8 continuation byte range. */\n+  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n+  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n+  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n+  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n+  /* UTF8 lead byte range. */\n+  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n+  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n+  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n+  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n+\n+  /* CONTEXT_UTF8 second last byte. */\n+  /* ASCII range. */\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,\n+  1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1,\n+  1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0,\n+  /* UTF8 continuation byte range. */\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  /* UTF8 lead byte range. */\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+\n+  /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */\n+   0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n+  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n+  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n+  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n+  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n+  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n+  48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 56,\n+\n+  /* CONTEXT_SIGNED, second last byte. */\n+  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n+  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n+  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,\n+};\n+\n+typedef const uint8_t* ContextLut;\n+\n+/* typeof(MODE) == ContextType; returns ContextLut */\n+#define BROTLI_CONTEXT_LUT(MODE) (&kContextLookup[(MODE) << 9])\n+\n+/* typeof(LUT) == ContextLut */\n+#define BROTLI_CONTEXT(P1, P2, LUT) ((LUT)[P1] | ((LUT) + 256)[P2])\n+\n+#endif  /* BROTLI_COMMON_CONTEXT_H_ */"
        },
        {
            "sha": "a585c0e292eba19e594ef95f5c4fb38fcb1f7a84",
            "filename": "deps/brotli/c/common/dictionary.bin",
            "status": "added",
            "additions": 432,
            "deletions": 0,
            "changes": 432,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.bin",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.bin",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.bin?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "6a55d420a8186fd40b050a2226ef870a73783a55",
            "filename": "deps/brotli/c/common/dictionary.bin.br",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.bin.br",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.bin.br",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.bin.br?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "64822a381bbfd700f792fcc7269518d122a56958",
            "filename": "deps/brotli/c/common/dictionary.c",
            "status": "added",
            "additions": 5905,
            "deletions": 0,
            "changes": 5905,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "b1c6f7f580e9c507262dea33536ca44cf2174140",
            "filename": "deps/brotli/c/common/dictionary.h",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Fdictionary.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,64 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Collection of static dictionary words. */\n+\n+#ifndef BROTLI_COMMON_DICTIONARY_H_\n+#define BROTLI_COMMON_DICTIONARY_H_\n+\n+#include <brotli/port.h>\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+typedef struct BrotliDictionary {\n+  /**\n+   * Number of bits to encode index of dictionary word in a bucket.\n+   *\n+   * Specification: Appendix A. Static Dictionary Data\n+   *\n+   * Words in a dictionary are bucketed by length.\n+   * @c 0 means that there are no words of a given length.\n+   * Dictionary consists of words with length of [4..24] bytes.\n+   * Values at [0..3] and [25..31] indices should not be addressed.\n+   */\n+  uint8_t size_bits_by_length[32];\n+\n+  /* assert(offset[i + 1] == offset[i] + (bits[i] ? (i << bits[i]) : 0)) */\n+  uint32_t offsets_by_length[32];\n+\n+  /* assert(data_size == offsets_by_length[31]) */\n+  size_t data_size;\n+\n+  /* Data array is not bound, and should obey to size_bits_by_length values.\n+     Specified size matches default (RFC 7932) dictionary. Its size is\n+     defined by data_size */\n+  const uint8_t* data;\n+} BrotliDictionary;\n+\n+BROTLI_COMMON_API const BrotliDictionary* BrotliGetDictionary(void);\n+\n+/**\n+ * Sets dictionary data.\n+ *\n+ * When dictionary data is already set / present, this method is no-op.\n+ *\n+ * Dictionary data MUST be provided before BrotliGetDictionary is invoked.\n+ * This method is used ONLY in multi-client environment (e.g. C + Java),\n+ * to reduce storage by sharing single dictionary between implementations.\n+ */\n+BROTLI_COMMON_API void BrotliSetDictionaryData(const uint8_t* data);\n+\n+#define BROTLI_MIN_DICTIONARY_WORD_LENGTH 4\n+#define BROTLI_MAX_DICTIONARY_WORD_LENGTH 24\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_COMMON_DICTIONARY_H_ */"
        },
        {
            "sha": "84c448c4cf8c44479bfa00eab7826c86c25a5fc2",
            "filename": "deps/brotli/c/common/platform.h",
            "status": "added",
            "additions": 568,
            "deletions": 0,
            "changes": 568,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fplatform.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fplatform.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Fplatform.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,568 @@\n+/* Copyright 2016 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Macros for compiler / platform specific features and build options.\n+\n+   Build options are:\n+    * BROTLI_BUILD_32_BIT disables 64-bit optimizations\n+    * BROTLI_BUILD_64_BIT forces to use 64-bit optimizations\n+    * BROTLI_BUILD_BIG_ENDIAN forces to use big-endian optimizations\n+    * BROTLI_BUILD_ENDIAN_NEUTRAL disables endian-aware optimizations\n+    * BROTLI_BUILD_LITTLE_ENDIAN forces to use little-endian optimizations\n+    * BROTLI_BUILD_PORTABLE disables dangerous optimizations, like unaligned\n+      read and overlapping memcpy; this reduces decompression speed by 5%\n+    * BROTLI_BUILD_NO_RBIT disables \"rbit\" optimization for ARM CPUs\n+    * BROTLI_DEBUG dumps file name and line number when decoder detects stream\n+      or memory error\n+    * BROTLI_ENABLE_LOG enables asserts and dumps various state information\n+*/\n+\n+#ifndef BROTLI_COMMON_PLATFORM_H_\n+#define BROTLI_COMMON_PLATFORM_H_\n+\n+#include <string.h>  /* memcpy */\n+#include <stdlib.h>  /* malloc, free */\n+\n+#include <brotli/port.h>\n+#include <brotli/types.h>\n+\n+#if defined(OS_LINUX) || defined(OS_CYGWIN)\n+#include <endian.h>\n+#elif defined(OS_FREEBSD)\n+#include <machine/endian.h>\n+#elif defined(OS_MACOSX)\n+#include <machine/endian.h>\n+/* Let's try and follow the Linux convention */\n+#define BROTLI_X_BYTE_ORDER BYTE_ORDER\n+#define BROTLI_X_LITTLE_ENDIAN LITTLE_ENDIAN\n+#define BROTLI_X_BIG_ENDIAN BIG_ENDIAN\n+#endif\n+\n+#if defined(BROTLI_ENABLE_LOG) || defined(BROTLI_DEBUG)\n+#include <assert.h>\n+#include <stdio.h>\n+#endif\n+\n+/* The following macros were borrowed from https://github.com/nemequ/hedley\n+ * with permission of original author - Evan Nemerson <evan@nemerson.com> */\n+\n+/* >>> >>> >>> hedley macros */\n+\n+/* Define \"BROTLI_PREDICT_TRUE\" and \"BROTLI_PREDICT_FALSE\" macros for capable\n+   compilers.\n+\n+To apply compiler hint, enclose the branching condition into macros, like this:\n+\n+  if (BROTLI_PREDICT_TRUE(zero == 0)) {\n+    // main execution path\n+  } else {\n+    // compiler should place this code outside of main execution path\n+  }\n+\n+OR:\n+\n+  if (BROTLI_PREDICT_FALSE(something_rare_or_unexpected_happens)) {\n+    // compiler should place this code outside of main execution path\n+  }\n+\n+*/\n+#if BROTLI_GNUC_HAS_BUILTIN(__builtin_expect, 3, 0, 0) || \\\n+    BROTLI_INTEL_VERSION_CHECK(16, 0, 0) ||               \\\n+    BROTLI_SUNPRO_VERSION_CHECK(5, 15, 0) ||              \\\n+    BROTLI_ARM_VERSION_CHECK(4, 1, 0) ||                  \\\n+    BROTLI_IBM_VERSION_CHECK(10, 1, 0) ||                 \\\n+    BROTLI_TI_VERSION_CHECK(7, 3, 0) ||                   \\\n+    BROTLI_TINYC_VERSION_CHECK(0, 9, 27)\n+#define BROTLI_PREDICT_TRUE(x) (__builtin_expect(!!(x), 1))\n+#define BROTLI_PREDICT_FALSE(x) (__builtin_expect(x, 0))\n+#else\n+#define BROTLI_PREDICT_FALSE(x) (x)\n+#define BROTLI_PREDICT_TRUE(x) (x)\n+#endif\n+\n+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \\\n+    !defined(__cplusplus)\n+#define BROTLI_RESTRICT restrict\n+#elif BROTLI_GNUC_VERSION_CHECK(3, 1, 0) ||                         \\\n+    BROTLI_MSVC_VERSION_CHECK(14, 0, 0) ||                          \\\n+    BROTLI_INTEL_VERSION_CHECK(16, 0, 0) ||                         \\\n+    BROTLI_ARM_VERSION_CHECK(4, 1, 0) ||                            \\\n+    BROTLI_IBM_VERSION_CHECK(10, 1, 0) ||                           \\\n+    BROTLI_PGI_VERSION_CHECK(17, 10, 0) ||                          \\\n+    BROTLI_TI_VERSION_CHECK(8, 0, 0) ||                             \\\n+    BROTLI_IAR_VERSION_CHECK(8, 0, 0) ||                            \\\n+    (BROTLI_SUNPRO_VERSION_CHECK(5, 14, 0) && defined(__cplusplus))\n+#define BROTLI_RESTRICT __restrict\n+#elif BROTLI_SUNPRO_VERSION_CHECK(5, 3, 0) && !defined(__cplusplus)\n+#define BROTLI_RESTRICT _Restrict\n+#else\n+#define BROTLI_RESTRICT\n+#endif\n+\n+#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \\\n+    (defined(__cplusplus) && (__cplusplus >= 199711L))\n+#define BROTLI_MAYBE_INLINE inline\n+#elif defined(__GNUC_STDC_INLINE__) || defined(__GNUC_GNU_INLINE__) || \\\n+    BROTLI_ARM_VERSION_CHECK(6, 2, 0)\n+#define BROTLI_MAYBE_INLINE __inline__\n+#elif BROTLI_MSVC_VERSION_CHECK(12, 0, 0) || \\\n+    BROTLI_ARM_VERSION_CHECK(4, 1, 0) || BROTLI_TI_VERSION_CHECK(8, 0, 0)\n+#define BROTLI_MAYBE_INLINE __inline\n+#else\n+#define BROTLI_MAYBE_INLINE\n+#endif\n+\n+#if BROTLI_GNUC_HAS_ATTRIBUTE(always_inline, 4, 0, 0) ||                       \\\n+    BROTLI_INTEL_VERSION_CHECK(16, 0, 0) ||                                    \\\n+    BROTLI_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                   \\\n+    BROTLI_ARM_VERSION_CHECK(4, 1, 0) ||                                       \\\n+    BROTLI_IBM_VERSION_CHECK(10, 1, 0) ||                                      \\\n+    BROTLI_TI_VERSION_CHECK(8, 0, 0) ||                                        \\\n+    (BROTLI_TI_VERSION_CHECK(7, 3, 0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))\n+#define BROTLI_INLINE BROTLI_MAYBE_INLINE __attribute__((__always_inline__))\n+#elif BROTLI_MSVC_VERSION_CHECK(12, 0, 0)\n+#define BROTLI_INLINE BROTLI_MAYBE_INLINE __forceinline\n+#elif BROTLI_TI_VERSION_CHECK(7, 0, 0) && defined(__cplusplus)\n+#define BROTLI_INLINE BROTLI_MAYBE_INLINE _Pragma(\"FUNC_ALWAYS_INLINE;\")\n+#elif BROTLI_IAR_VERSION_CHECK(8, 0, 0)\n+#define BROTLI_INLINE BROTLI_MAYBE_INLINE _Pragma(\"inline=forced\")\n+#else\n+#define BROTLI_INLINE BROTLI_MAYBE_INLINE\n+#endif\n+\n+#if BROTLI_GNUC_HAS_ATTRIBUTE(noinline, 4, 0, 0) ||                            \\\n+    BROTLI_INTEL_VERSION_CHECK(16, 0, 0) ||                                    \\\n+    BROTLI_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                   \\\n+    BROTLI_ARM_VERSION_CHECK(4, 1, 0) ||                                       \\\n+    BROTLI_IBM_VERSION_CHECK(10, 1, 0) ||                                      \\\n+    BROTLI_TI_VERSION_CHECK(8, 0, 0) ||                                        \\\n+    (BROTLI_TI_VERSION_CHECK(7, 3, 0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__))\n+#define BROTLI_NOINLINE __attribute__((__noinline__))\n+#elif BROTLI_MSVC_VERSION_CHECK(13, 10, 0)\n+#define BROTLI_NOINLINE __declspec(noinline)\n+#elif BROTLI_PGI_VERSION_CHECK(10, 2, 0)\n+#define BROTLI_NOINLINE _Pragma(\"noinline\")\n+#elif BROTLI_TI_VERSION_CHECK(6, 0, 0) && defined(__cplusplus)\n+#define BROTLI_NOINLINE _Pragma(\"FUNC_CANNOT_INLINE;\")\n+#elif BROTLI_IAR_VERSION_CHECK(8, 0, 0)\n+#define BROTLI_NOINLINE _Pragma(\"inline=never\")\n+#else\n+#define BROTLI_NOINLINE\n+#endif\n+\n+/* BROTLI_INTERNAL could be defined to override visibility, e.g. for tests. */\n+#if !defined(BROTLI_INTERNAL)\n+#if defined(_WIN32) || defined(__CYGWIN__)\n+#define BROTLI_INTERNAL\n+#elif BROTLI_GNUC_VERSION_CHECK(3, 3, 0) ||                         \\\n+    BROTLI_TI_VERSION_CHECK(8, 0, 0) ||                             \\\n+    BROTLI_INTEL_VERSION_CHECK(16, 0, 0) ||                         \\\n+    BROTLI_ARM_VERSION_CHECK(4, 1, 0) ||                            \\\n+    BROTLI_IBM_VERSION_CHECK(13, 1, 0) ||                           \\\n+    BROTLI_SUNPRO_VERSION_CHECK(5, 11, 0) ||                        \\\n+    (BROTLI_TI_VERSION_CHECK(7, 3, 0) &&                            \\\n+     defined(__TI_GNU_ATTRIBUTE_SUPPORT__) && defined(__TI_EABI__))\n+#define BROTLI_INTERNAL __attribute__ ((visibility (\"hidden\")))\n+#else\n+#define BROTLI_INTERNAL\n+#endif\n+#endif\n+\n+/* <<< <<< <<< end of hedley macros. */\n+\n+#if BROTLI_GNUC_HAS_ATTRIBUTE(unused, 2, 7, 0) || \\\n+    BROTLI_INTEL_VERSION_CHECK(16, 0, 0)\n+#define BROTLI_UNUSED_FUNCTION static BROTLI_INLINE __attribute__ ((unused))\n+#else\n+#define BROTLI_UNUSED_FUNCTION static BROTLI_INLINE\n+#endif\n+\n+#if BROTLI_GNUC_HAS_ATTRIBUTE(aligned, 2, 7, 0)\n+#define BROTLI_ALIGNED(N) __attribute__((aligned(N)))\n+#else\n+#define BROTLI_ALIGNED(N)\n+#endif\n+\n+#if (defined(__ARM_ARCH) && (__ARM_ARCH == 7)) || \\\n+    (defined(M_ARM) && (M_ARM == 7))\n+#define BROTLI_TARGET_ARMV7\n+#endif  /* ARMv7 */\n+\n+#if (defined(__ARM_ARCH) && (__ARM_ARCH == 8)) || \\\n+    defined(__aarch64__) || defined(__ARM64_ARCH_8__)\n+#define BROTLI_TARGET_ARMV8_ANY\n+\n+#if defined(__ARM_32BIT_STATE)\n+#define BROTLI_TARGET_ARMV8_32\n+#elif defined(__ARM_64BIT_STATE)\n+#define BROTLI_TARGET_ARMV8_64\n+#endif\n+\n+#endif  /* ARMv8 */\n+\n+#if defined(__ARM_NEON__) || defined(__ARM_NEON)\n+#define BROTLI_TARGET_NEON\n+#endif\n+\n+#if defined(__i386) || defined(_M_IX86)\n+#define BROTLI_TARGET_X86\n+#endif\n+\n+#if defined(__x86_64__) || defined(_M_X64)\n+#define BROTLI_TARGET_X64\n+#endif\n+\n+#if defined(__PPC64__)\n+#define BROTLI_TARGET_POWERPC64\n+#endif\n+\n+#if defined(__riscv) && defined(__riscv_xlen) && __riscv_xlen == 64\n+#define BROTLI_TARGET_RISCV64\n+#endif\n+\n+#if defined(BROTLI_BUILD_64_BIT)\n+#define BROTLI_64_BITS 1\n+#elif defined(BROTLI_BUILD_32_BIT)\n+#define BROTLI_64_BITS 0\n+#elif defined(BROTLI_TARGET_X64) || defined(BROTLI_TARGET_ARMV8_64) || \\\n+    defined(BROTLI_TARGET_POWERPC64) || defined(BROTLI_TARGET_RISCV64)\n+#define BROTLI_64_BITS 1\n+#else\n+#define BROTLI_64_BITS 0\n+#endif\n+\n+#if (BROTLI_64_BITS)\n+#define brotli_reg_t uint64_t\n+#else\n+#define brotli_reg_t uint32_t\n+#endif\n+\n+#if defined(BROTLI_BUILD_BIG_ENDIAN)\n+#define BROTLI_BIG_ENDIAN 1\n+#elif defined(BROTLI_BUILD_LITTLE_ENDIAN)\n+#define BROTLI_LITTLE_ENDIAN 1\n+#elif defined(BROTLI_BUILD_ENDIAN_NEUTRAL)\n+/* Just break elif chain. */\n+#elif defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)\n+#define BROTLI_LITTLE_ENDIAN 1\n+#elif defined(_WIN32) || defined(BROTLI_TARGET_X64)\n+/* Win32 & x64 can currently always be assumed to be little endian */\n+#define BROTLI_LITTLE_ENDIAN 1\n+#elif defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)\n+#define BROTLI_BIG_ENDIAN 1\n+#elif defined(BROTLI_X_BYTE_ORDER)\n+#if BROTLI_X_BYTE_ORDER == BROTLI_X_LITTLE_ENDIAN\n+#define BROTLI_LITTLE_ENDIAN 1\n+#elif BROTLI_X_BYTE_ORDER == BROTLI_X_BIG_ENDIAN\n+#define BROTLI_BIG_ENDIAN 1\n+#endif\n+#endif  /* BROTLI_X_BYTE_ORDER */\n+\n+#if !defined(BROTLI_LITTLE_ENDIAN)\n+#define BROTLI_LITTLE_ENDIAN 0\n+#endif\n+\n+#if !defined(BROTLI_BIG_ENDIAN)\n+#define BROTLI_BIG_ENDIAN 0\n+#endif\n+\n+#if defined(BROTLI_X_BYTE_ORDER)\n+#undef BROTLI_X_BYTE_ORDER\n+#undef BROTLI_X_LITTLE_ENDIAN\n+#undef BROTLI_X_BIG_ENDIAN\n+#endif\n+\n+#if defined(BROTLI_BUILD_PORTABLE)\n+#define BROTLI_ALIGNED_READ (!!1)\n+#elif defined(BROTLI_TARGET_X86) || defined(BROTLI_TARGET_X64) || \\\n+    defined(BROTLI_TARGET_ARMV7) || defined(BROTLI_TARGET_ARMV8_ANY) || \\\n+    defined(BROTLI_TARGET_RISCV64)\n+/* Allow unaligned read only for white-listed CPUs. */\n+#define BROTLI_ALIGNED_READ (!!0)\n+#else\n+#define BROTLI_ALIGNED_READ (!!1)\n+#endif\n+\n+#if BROTLI_ALIGNED_READ\n+/* Portable unaligned memory access: read / write values via memcpy. */\n+static BROTLI_INLINE uint16_t BrotliUnalignedRead16(const void* p) {\n+  uint16_t t;\n+  memcpy(&t, p, sizeof t);\n+  return t;\n+}\n+static BROTLI_INLINE uint32_t BrotliUnalignedRead32(const void* p) {\n+  uint32_t t;\n+  memcpy(&t, p, sizeof t);\n+  return t;\n+}\n+static BROTLI_INLINE uint64_t BrotliUnalignedRead64(const void* p) {\n+  uint64_t t;\n+  memcpy(&t, p, sizeof t);\n+  return t;\n+}\n+static BROTLI_INLINE void BrotliUnalignedWrite64(void* p, uint64_t v) {\n+  memcpy(p, &v, sizeof v);\n+}\n+#else  /* BROTLI_ALIGNED_READ */\n+/* Unaligned memory access is allowed: just cast pointer to requested type. */\n+#if defined(ADDRESS_SANITIZER) || defined(THREAD_SANITIZER) || \\\n+    defined(MEMORY_SANITIZER)\n+/* Consider we have an unaligned load/store of 4 bytes from address 0x...05.\n+   AddressSanitizer will treat it as a 3-byte access to the range 05:07 and\n+   will miss a bug if 08 is the first unaddressable byte.\n+   ThreadSanitizer will also treat this as a 3-byte access to 05:07 and will\n+   miss a race between this access and some other accesses to 08.\n+   MemorySanitizer will correctly propagate the shadow on unaligned stores\n+   and correctly report bugs on unaligned loads, but it may not properly\n+   update and report the origin of the uninitialized memory.\n+   For all three tools, replacing an unaligned access with a tool-specific\n+   callback solves the problem. */\n+#if defined(__cplusplus)\n+extern \"C\" {\n+#endif  /* __cplusplus */\n+  uint16_t __sanitizer_unaligned_load16(const void* p);\n+  uint32_t __sanitizer_unaligned_load32(const void* p);\n+  uint64_t __sanitizer_unaligned_load64(const void* p);\n+  void __sanitizer_unaligned_store64(void* p, uint64_t v);\n+#if defined(__cplusplus)\n+}  /* extern \"C\" */\n+#endif  /* __cplusplus */\n+#define BrotliUnalignedRead16 __sanitizer_unaligned_load16\n+#define BrotliUnalignedRead32 __sanitizer_unaligned_load32\n+#define BrotliUnalignedRead64 __sanitizer_unaligned_load64\n+#define BrotliUnalignedWrite64 __sanitizer_unaligned_store64\n+#else\n+static BROTLI_INLINE uint16_t BrotliUnalignedRead16(const void* p) {\n+  return *(const uint16_t*)p;\n+}\n+static BROTLI_INLINE uint32_t BrotliUnalignedRead32(const void* p) {\n+  return *(const uint32_t*)p;\n+}\n+#if (BROTLI_64_BITS)\n+static BROTLI_INLINE uint64_t BrotliUnalignedRead64(const void* p) {\n+  return *(const uint64_t*)p;\n+}\n+static BROTLI_INLINE void BrotliUnalignedWrite64(void* p, uint64_t v) {\n+  *(uint64_t*)p = v;\n+}\n+#else  /* BROTLI_64_BITS */\n+/* Avoid emitting LDRD / STRD, which require properly aligned address. */\n+/* If __attribute__(aligned) is available, use that. Otherwise, memcpy. */\n+\n+#if BROTLI_GNUC_HAS_ATTRIBUTE(aligned, 2, 7, 0)\n+typedef BROTLI_ALIGNED(1) uint64_t brotli_unaligned_uint64_t;\n+\n+static BROTLI_INLINE uint64_t BrotliUnalignedRead64(const void* p) {\n+  return (uint64_t) ((brotli_unaligned_uint64_t*) p)[0];\n+}\n+static BROTLI_INLINE void BrotliUnalignedWrite64(void* p, uint64_t v) {\n+  brotli_unaligned_uint64_t* dwords = (brotli_unaligned_uint64_t*) p;\n+  dwords[0] = (brotli_unaligned_uint64_t) v;\n+}\n+#else /* BROTLI_GNUC_HAS_ATTRIBUTE(aligned, 2, 7, 0) */\n+static BROTLI_INLINE uint64_t BrotliUnalignedRead64(const void* p) {\n+  uint64_t v;\n+  memcpy(&v, p, sizeof(uint64_t));\n+  return v;\n+}\n+\n+static BROTLI_INLINE void BrotliUnalignedWrite64(void* p, uint64_t v) {\n+  memcpy(p, &v, sizeof(uint64_t));\n+}\n+#endif  /* BROTLI_GNUC_HAS_ATTRIBUTE(aligned, 2, 7, 0) */\n+#endif  /* BROTLI_64_BITS */\n+#endif  /* ASAN / TSAN / MSAN */\n+#endif  /* BROTLI_ALIGNED_READ */\n+\n+#if BROTLI_LITTLE_ENDIAN\n+/* Straight endianness. Just read / write values. */\n+#define BROTLI_UNALIGNED_LOAD16LE BrotliUnalignedRead16\n+#define BROTLI_UNALIGNED_LOAD32LE BrotliUnalignedRead32\n+#define BROTLI_UNALIGNED_LOAD64LE BrotliUnalignedRead64\n+#define BROTLI_UNALIGNED_STORE64LE BrotliUnalignedWrite64\n+#elif BROTLI_BIG_ENDIAN  /* BROTLI_LITTLE_ENDIAN */\n+/* Explain compiler to byte-swap values. */\n+#define BROTLI_BSWAP16_(V) ((uint16_t)( \\\n+  (((V) & 0xFFU) << 8) | \\\n+  (((V) >> 8) & 0xFFU)))\n+static BROTLI_INLINE uint16_t BROTLI_UNALIGNED_LOAD16LE(const void* p) {\n+  uint16_t value = BrotliUnalignedRead16(p);\n+  return BROTLI_BSWAP16_(value);\n+}\n+#define BROTLI_BSWAP32_(V) ( \\\n+  (((V) & 0xFFU) << 24) | (((V) & 0xFF00U) << 8) | \\\n+  (((V) >> 8) & 0xFF00U) | (((V) >> 24) & 0xFFU))\n+static BROTLI_INLINE uint32_t BROTLI_UNALIGNED_LOAD32LE(const void* p) {\n+  uint32_t value = BrotliUnalignedRead32(p);\n+  return BROTLI_BSWAP32_(value);\n+}\n+#define BROTLI_BSWAP64_(V) ( \\\n+  (((V) & 0xFFU) << 56) | (((V) & 0xFF00U) << 40) | \\\n+  (((V) & 0xFF0000U) << 24) | (((V) & 0xFF000000U) << 8) | \\\n+  (((V) >> 8) & 0xFF000000U) | (((V) >> 24) & 0xFF0000U) | \\\n+  (((V) >> 40) & 0xFF00U) | (((V) >> 56) & 0xFFU))\n+static BROTLI_INLINE uint64_t BROTLI_UNALIGNED_LOAD64LE(const void* p) {\n+  uint64_t value = BrotliUnalignedRead64(p);\n+  return BROTLI_BSWAP64_(value);\n+}\n+static BROTLI_INLINE void BROTLI_UNALIGNED_STORE64LE(void* p, uint64_t v) {\n+  uint64_t value = BROTLI_BSWAP64_(v);\n+  BrotliUnalignedWrite64(p, value);\n+}\n+#else  /* BROTLI_LITTLE_ENDIAN */\n+/* Read / store values byte-wise; hopefully compiler will understand. */\n+static BROTLI_INLINE uint16_t BROTLI_UNALIGNED_LOAD16LE(const void* p) {\n+  const uint8_t* in = (const uint8_t*)p;\n+  return (uint16_t)(in[0] | (in[1] << 8));\n+}\n+static BROTLI_INLINE uint32_t BROTLI_UNALIGNED_LOAD32LE(const void* p) {\n+  const uint8_t* in = (const uint8_t*)p;\n+  uint32_t value = (uint32_t)(in[0]);\n+  value |= (uint32_t)(in[1]) << 8;\n+  value |= (uint32_t)(in[2]) << 16;\n+  value |= (uint32_t)(in[3]) << 24;\n+  return value;\n+}\n+static BROTLI_INLINE uint64_t BROTLI_UNALIGNED_LOAD64LE(const void* p) {\n+  const uint8_t* in = (const uint8_t*)p;\n+  uint64_t value = (uint64_t)(in[0]);\n+  value |= (uint64_t)(in[1]) << 8;\n+  value |= (uint64_t)(in[2]) << 16;\n+  value |= (uint64_t)(in[3]) << 24;\n+  value |= (uint64_t)(in[4]) << 32;\n+  value |= (uint64_t)(in[5]) << 40;\n+  value |= (uint64_t)(in[6]) << 48;\n+  value |= (uint64_t)(in[7]) << 56;\n+  return value;\n+}\n+static BROTLI_INLINE void BROTLI_UNALIGNED_STORE64LE(void* p, uint64_t v) {\n+  uint8_t* out = (uint8_t*)p;\n+  out[0] = (uint8_t)v;\n+  out[1] = (uint8_t)(v >> 8);\n+  out[2] = (uint8_t)(v >> 16);\n+  out[3] = (uint8_t)(v >> 24);\n+  out[4] = (uint8_t)(v >> 32);\n+  out[5] = (uint8_t)(v >> 40);\n+  out[6] = (uint8_t)(v >> 48);\n+  out[7] = (uint8_t)(v >> 56);\n+}\n+#endif  /* BROTLI_LITTLE_ENDIAN */\n+\n+/* BROTLI_IS_CONSTANT macros returns true for compile-time constants. */\n+#if BROTLI_GNUC_HAS_BUILTIN(__builtin_constant_p, 3, 0, 1) || \\\n+    BROTLI_INTEL_VERSION_CHECK(16, 0, 0)\n+#define BROTLI_IS_CONSTANT(x) (!!__builtin_constant_p(x))\n+#else\n+#define BROTLI_IS_CONSTANT(x) (!!0)\n+#endif\n+\n+#if defined(BROTLI_TARGET_ARMV7) || defined(BROTLI_TARGET_ARMV8_ANY)\n+#define BROTLI_HAS_UBFX (!!1)\n+#else\n+#define BROTLI_HAS_UBFX (!!0)\n+#endif\n+\n+#if defined(BROTLI_ENABLE_LOG)\n+#define BROTLI_DCHECK(x) assert(x)\n+#define BROTLI_LOG(x) printf x\n+#else\n+#define BROTLI_DCHECK(x)\n+#define BROTLI_LOG(x)\n+#endif\n+\n+#if defined(BROTLI_DEBUG) || defined(BROTLI_ENABLE_LOG)\n+static BROTLI_INLINE void BrotliDump(const char* f, int l, const char* fn) {\n+  fprintf(stderr, \"%s:%d (%s)\\n\", f, l, fn);\n+  fflush(stderr);\n+}\n+#define BROTLI_DUMP() BrotliDump(__FILE__, __LINE__, __FUNCTION__)\n+#else\n+#define BROTLI_DUMP() (void)(0)\n+#endif\n+\n+/* TODO: add appropriate icc/sunpro/arm/ibm/ti checks. */\n+#if (BROTLI_GNUC_VERSION_CHECK(3, 0, 0) || defined(__llvm__)) && \\\n+    !defined(BROTLI_BUILD_NO_RBIT)\n+#if defined(BROTLI_TARGET_ARMV7) || defined(BROTLI_TARGET_ARMV8_ANY)\n+/* TODO: detect ARMv6T2 and enable this code for it. */\n+static BROTLI_INLINE brotli_reg_t BrotliRBit(brotli_reg_t input) {\n+  brotli_reg_t output;\n+  __asm__(\"rbit %0, %1\\n\" : \"=r\"(output) : \"r\"(input));\n+  return output;\n+}\n+#define BROTLI_RBIT(x) BrotliRBit(x)\n+#endif  /* armv7 / armv8 */\n+#endif  /* gcc || clang */\n+#if !defined(BROTLI_RBIT)\n+static BROTLI_INLINE void BrotliRBit(void) { /* Should break build if used. */ }\n+#endif  /* BROTLI_RBIT */\n+\n+#define BROTLI_REPEAT(N, X) {     \\\n+  if ((N & 1) != 0) {X;}          \\\n+  if ((N & 2) != 0) {X; X;}       \\\n+  if ((N & 4) != 0) {X; X; X; X;} \\\n+}\n+\n+#define BROTLI_UNUSED(X) (void)(X)\n+\n+#define BROTLI_MIN_MAX(T)                                                      \\\n+  static BROTLI_INLINE T brotli_min_ ## T (T a, T b) { return a < b ? a : b; } \\\n+  static BROTLI_INLINE T brotli_max_ ## T (T a, T b) { return a > b ? a : b; }\n+BROTLI_MIN_MAX(double) BROTLI_MIN_MAX(float) BROTLI_MIN_MAX(int)\n+BROTLI_MIN_MAX(size_t) BROTLI_MIN_MAX(uint32_t) BROTLI_MIN_MAX(uint8_t)\n+#undef BROTLI_MIN_MAX\n+#define BROTLI_MIN(T, A, B) (brotli_min_ ## T((A), (B)))\n+#define BROTLI_MAX(T, A, B) (brotli_max_ ## T((A), (B)))\n+\n+#define BROTLI_SWAP(T, A, I, J) { \\\n+  T __brotli_swap_tmp = (A)[(I)]; \\\n+  (A)[(I)] = (A)[(J)];            \\\n+  (A)[(J)] = __brotli_swap_tmp;   \\\n+}\n+\n+/* Default brotli_alloc_func */\n+static void* BrotliDefaultAllocFunc(void* opaque, size_t size) {\n+  BROTLI_UNUSED(opaque);\n+  return malloc(size);\n+}\n+\n+/* Default brotli_free_func */\n+static void BrotliDefaultFreeFunc(void* opaque, void* address) {\n+  BROTLI_UNUSED(opaque);\n+  free(address);\n+}\n+\n+BROTLI_UNUSED_FUNCTION void BrotliSuppressUnusedFunctions(void) {\n+  BROTLI_UNUSED(&BrotliSuppressUnusedFunctions);\n+  BROTLI_UNUSED(&BrotliUnalignedRead16);\n+  BROTLI_UNUSED(&BrotliUnalignedRead32);\n+  BROTLI_UNUSED(&BrotliUnalignedRead64);\n+  BROTLI_UNUSED(&BrotliUnalignedWrite64);\n+  BROTLI_UNUSED(&BROTLI_UNALIGNED_LOAD16LE);\n+  BROTLI_UNUSED(&BROTLI_UNALIGNED_LOAD32LE);\n+  BROTLI_UNUSED(&BROTLI_UNALIGNED_LOAD64LE);\n+  BROTLI_UNUSED(&BROTLI_UNALIGNED_STORE64LE);\n+  BROTLI_UNUSED(&BrotliRBit);\n+  BROTLI_UNUSED(&brotli_min_double);\n+  BROTLI_UNUSED(&brotli_max_double);\n+  BROTLI_UNUSED(&brotli_min_float);\n+  BROTLI_UNUSED(&brotli_max_float);\n+  BROTLI_UNUSED(&brotli_min_int);\n+  BROTLI_UNUSED(&brotli_max_int);\n+  BROTLI_UNUSED(&brotli_min_size_t);\n+  BROTLI_UNUSED(&brotli_max_size_t);\n+  BROTLI_UNUSED(&brotli_min_uint32_t);\n+  BROTLI_UNUSED(&brotli_max_uint32_t);\n+  BROTLI_UNUSED(&brotli_min_uint8_t);\n+  BROTLI_UNUSED(&brotli_max_uint8_t);\n+  BROTLI_UNUSED(&BrotliDefaultAllocFunc);\n+  BROTLI_UNUSED(&BrotliDefaultFreeFunc);\n+#if defined(BROTLI_DEBUG) || defined(BROTLI_ENABLE_LOG)\n+  BROTLI_UNUSED(&BrotliDump);\n+#endif\n+}\n+\n+#endif  /* BROTLI_COMMON_PLATFORM_H_ */"
        },
        {
            "sha": "426e635fd3d0332679c6d85a85808c6cb06a8e76",
            "filename": "deps/brotli/c/common/transform.c",
            "status": "added",
            "additions": 235,
            "deletions": 0,
            "changes": 235,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Ftransform.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Ftransform.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Ftransform.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,235 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+#include \"./transform.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* RFC 7932 transforms string data */\n+static const char kPrefixSuffix[217] =\n+      \"\\1 \\2, \\10 of the \\4 of \\2s \\1.\\5 and \\4 \"\n+/* 0x  _0 _2  __5        _E    _3  _6 _8     _E */\n+      \"in \\1\\\"\\4 to \\2\\\">\\1\\n\\2. \\1]\\5 for \\3 a \\6 \"\n+/* 2x     _3_ _5    _A_  _D_ _F  _2 _4     _A   _E */\n+      \"that \\1\\'\\6 with \\6 from \\4 by \\1(\\6. T\"\n+/* 4x       _5_ _7      _E      _5    _A _C */\n+      \"he \\4 on \\4 as \\4 is \\4ing \\2\\n\\t\\1:\\3ed \"\n+/* 6x     _3    _8    _D    _2    _7_ _ _A _C */\n+      \"\\2=\\\"\\4 at \\3ly \\1,\\2=\\'\\5.com/\\7. This \\5\"\n+/* 8x  _0 _ _3    _8   _C _E _ _1     _7       _F */\n+      \" not \\3er \\3al \\4ful \\4ive \\5less \\4es\"\n+/* Ax       _5   _9   _D    _2    _7     _D */\n+      \"t \\4ize \\2\\xc2\\xa0\\4ous \\5 the \\2e \\0\";\n+/* Cx    _2    _7___ ___ _A    _F     _5  _8 */\n+\n+static const uint16_t kPrefixSuffixMap[50] = {\n+  0x00, 0x02, 0x05, 0x0E, 0x13, 0x16, 0x18, 0x1E, 0x23, 0x25,\n+  0x2A, 0x2D, 0x2F, 0x32, 0x34, 0x3A, 0x3E, 0x45, 0x47, 0x4E,\n+  0x55, 0x5A, 0x5C, 0x63, 0x68, 0x6D, 0x72, 0x77, 0x7A, 0x7C,\n+  0x80, 0x83, 0x88, 0x8C, 0x8E, 0x91, 0x97, 0x9F, 0xA5, 0xA9,\n+  0xAD, 0xB2, 0xB7, 0xBD, 0xC2, 0xC7, 0xCA, 0xCF, 0xD5, 0xD8\n+};\n+\n+/* RFC 7932 transforms */\n+static const uint8_t kTransformsData[] = {\n+  49, BROTLI_TRANSFORM_IDENTITY, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 0,\n+   0, BROTLI_TRANSFORM_IDENTITY, 0,\n+  49, BROTLI_TRANSFORM_OMIT_FIRST_1, 49,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 0,\n+  49, BROTLI_TRANSFORM_IDENTITY, 47,\n+   0, BROTLI_TRANSFORM_IDENTITY, 49,\n+   4, BROTLI_TRANSFORM_IDENTITY, 0,\n+  49, BROTLI_TRANSFORM_IDENTITY, 3,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 6,\n+  49, BROTLI_TRANSFORM_OMIT_FIRST_2, 49,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_1, 49,\n+   1, BROTLI_TRANSFORM_IDENTITY, 0,\n+  49, BROTLI_TRANSFORM_IDENTITY, 1,\n+   0, BROTLI_TRANSFORM_UPPERCASE_FIRST, 0,\n+  49, BROTLI_TRANSFORM_IDENTITY, 7,\n+  49, BROTLI_TRANSFORM_IDENTITY, 9,\n+  48, BROTLI_TRANSFORM_IDENTITY, 0,\n+  49, BROTLI_TRANSFORM_IDENTITY, 8,\n+  49, BROTLI_TRANSFORM_IDENTITY, 5,\n+  49, BROTLI_TRANSFORM_IDENTITY, 10,\n+  49, BROTLI_TRANSFORM_IDENTITY, 11,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_3, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 13,\n+  49, BROTLI_TRANSFORM_IDENTITY, 14,\n+  49, BROTLI_TRANSFORM_OMIT_FIRST_3, 49,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_2, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 15,\n+  49, BROTLI_TRANSFORM_IDENTITY, 16,\n+   0, BROTLI_TRANSFORM_UPPERCASE_FIRST, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 12,\n+   5, BROTLI_TRANSFORM_IDENTITY, 49,\n+   0, BROTLI_TRANSFORM_IDENTITY, 1,\n+  49, BROTLI_TRANSFORM_OMIT_FIRST_4, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 18,\n+  49, BROTLI_TRANSFORM_IDENTITY, 17,\n+  49, BROTLI_TRANSFORM_IDENTITY, 19,\n+  49, BROTLI_TRANSFORM_IDENTITY, 20,\n+  49, BROTLI_TRANSFORM_OMIT_FIRST_5, 49,\n+  49, BROTLI_TRANSFORM_OMIT_FIRST_6, 49,\n+  47, BROTLI_TRANSFORM_IDENTITY, 49,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_4, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 22,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 23,\n+  49, BROTLI_TRANSFORM_IDENTITY, 24,\n+  49, BROTLI_TRANSFORM_IDENTITY, 25,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_7, 49,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_1, 26,\n+  49, BROTLI_TRANSFORM_IDENTITY, 27,\n+  49, BROTLI_TRANSFORM_IDENTITY, 28,\n+   0, BROTLI_TRANSFORM_IDENTITY, 12,\n+  49, BROTLI_TRANSFORM_IDENTITY, 29,\n+  49, BROTLI_TRANSFORM_OMIT_FIRST_9, 49,\n+  49, BROTLI_TRANSFORM_OMIT_FIRST_7, 49,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_6, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 21,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 1,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_8, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 31,\n+  49, BROTLI_TRANSFORM_IDENTITY, 32,\n+  47, BROTLI_TRANSFORM_IDENTITY, 3,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_5, 49,\n+  49, BROTLI_TRANSFORM_OMIT_LAST_9, 49,\n+   0, BROTLI_TRANSFORM_UPPERCASE_FIRST, 1,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 8,\n+   5, BROTLI_TRANSFORM_IDENTITY, 21,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 0,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 10,\n+  49, BROTLI_TRANSFORM_IDENTITY, 30,\n+   0, BROTLI_TRANSFORM_IDENTITY, 5,\n+  35, BROTLI_TRANSFORM_IDENTITY, 49,\n+  47, BROTLI_TRANSFORM_IDENTITY, 2,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 17,\n+  49, BROTLI_TRANSFORM_IDENTITY, 36,\n+  49, BROTLI_TRANSFORM_IDENTITY, 33,\n+   5, BROTLI_TRANSFORM_IDENTITY, 0,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 21,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 5,\n+  49, BROTLI_TRANSFORM_IDENTITY, 37,\n+   0, BROTLI_TRANSFORM_IDENTITY, 30,\n+  49, BROTLI_TRANSFORM_IDENTITY, 38,\n+   0, BROTLI_TRANSFORM_UPPERCASE_ALL, 0,\n+  49, BROTLI_TRANSFORM_IDENTITY, 39,\n+   0, BROTLI_TRANSFORM_UPPERCASE_ALL, 49,\n+  49, BROTLI_TRANSFORM_IDENTITY, 34,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 8,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 12,\n+   0, BROTLI_TRANSFORM_IDENTITY, 21,\n+  49, BROTLI_TRANSFORM_IDENTITY, 40,\n+   0, BROTLI_TRANSFORM_UPPERCASE_FIRST, 12,\n+  49, BROTLI_TRANSFORM_IDENTITY, 41,\n+  49, BROTLI_TRANSFORM_IDENTITY, 42,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 17,\n+  49, BROTLI_TRANSFORM_IDENTITY, 43,\n+   0, BROTLI_TRANSFORM_UPPERCASE_FIRST, 5,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 10,\n+   0, BROTLI_TRANSFORM_IDENTITY, 34,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 33,\n+  49, BROTLI_TRANSFORM_IDENTITY, 44,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 5,\n+  45, BROTLI_TRANSFORM_IDENTITY, 49,\n+   0, BROTLI_TRANSFORM_IDENTITY, 33,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 30,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 30,\n+  49, BROTLI_TRANSFORM_IDENTITY, 46,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 1,\n+  49, BROTLI_TRANSFORM_UPPERCASE_FIRST, 34,\n+   0, BROTLI_TRANSFORM_UPPERCASE_FIRST, 33,\n+   0, BROTLI_TRANSFORM_UPPERCASE_ALL, 30,\n+   0, BROTLI_TRANSFORM_UPPERCASE_ALL, 1,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 33,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 21,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 12,\n+   0, BROTLI_TRANSFORM_UPPERCASE_ALL, 5,\n+  49, BROTLI_TRANSFORM_UPPERCASE_ALL, 34,\n+   0, BROTLI_TRANSFORM_UPPERCASE_ALL, 12,\n+   0, BROTLI_TRANSFORM_UPPERCASE_FIRST, 30,\n+   0, BROTLI_TRANSFORM_UPPERCASE_ALL, 34,\n+   0, BROTLI_TRANSFORM_UPPERCASE_FIRST, 34,\n+};\n+\n+static BrotliTransforms kBrotliTransforms = {\n+  sizeof(kPrefixSuffix),\n+  (const uint8_t*)kPrefixSuffix,\n+  kPrefixSuffixMap,\n+  sizeof(kTransformsData) / (3 * sizeof(kTransformsData[0])),\n+  kTransformsData,\n+  {0, 12, 27, 23, 42, 63, 56, 48, 59, 64}\n+};\n+\n+const BrotliTransforms* BrotliGetTransforms(void) {\n+  return &kBrotliTransforms;\n+}\n+\n+static int ToUpperCase(uint8_t* p) {\n+  if (p[0] < 0xC0) {\n+    if (p[0] >= 'a' && p[0] <= 'z') {\n+      p[0] ^= 32;\n+    }\n+    return 1;\n+  }\n+  /* An overly simplified uppercasing model for UTF-8. */\n+  if (p[0] < 0xE0) {\n+    p[1] ^= 32;\n+    return 2;\n+  }\n+  /* An arbitrary transform for three byte characters. */\n+  p[2] ^= 5;\n+  return 3;\n+}\n+\n+int BrotliTransformDictionaryWord(uint8_t* dst, const uint8_t* word, int len,\n+    const BrotliTransforms* transforms, int transform_idx) {\n+  int idx = 0;\n+  const uint8_t* prefix = BROTLI_TRANSFORM_PREFIX(transforms, transform_idx);\n+  uint8_t type = BROTLI_TRANSFORM_TYPE(transforms, transform_idx);\n+  const uint8_t* suffix = BROTLI_TRANSFORM_SUFFIX(transforms, transform_idx);\n+  {\n+    int prefix_len = *prefix++;\n+    while (prefix_len--) { dst[idx++] = *prefix++; }\n+  }\n+  {\n+    const int t = type;\n+    int i = 0;\n+    if (t <= BROTLI_TRANSFORM_OMIT_LAST_9) {\n+      len -= t;\n+    } else if (t >= BROTLI_TRANSFORM_OMIT_FIRST_1\n+        && t <= BROTLI_TRANSFORM_OMIT_FIRST_9) {\n+      int skip = t - (BROTLI_TRANSFORM_OMIT_FIRST_1 - 1);\n+      word += skip;\n+      len -= skip;\n+    }\n+    while (i < len) { dst[idx++] = word[i++]; }\n+    if (t == BROTLI_TRANSFORM_UPPERCASE_FIRST) {\n+      ToUpperCase(&dst[idx - len]);\n+    } else if (t == BROTLI_TRANSFORM_UPPERCASE_ALL) {\n+      uint8_t* uppercase = &dst[idx - len];\n+      while (len > 0) {\n+        int step = ToUpperCase(uppercase);\n+        uppercase += step;\n+        len -= step;\n+      }\n+    }\n+  }\n+  {\n+    int suffix_len = *suffix++;\n+    while (suffix_len--) { dst[idx++] = *suffix++; }\n+    return idx;\n+  }\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "456c12db9b2bcf219aa8ca36eb4115275bb601f7",
            "filename": "deps/brotli/c/common/transform.h",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Ftransform.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Ftransform.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Ftransform.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,80 @@\n+/* transforms is a part of ABI, but not API.\n+\n+   It means that there are some functions that are supposed to be in \"common\"\n+   library, but header itself is not placed into include/brotli. This way,\n+   aforementioned functions will be available only to brotli internals.\n+ */\n+\n+#ifndef BROTLI_COMMON_TRANSFORM_H_\n+#define BROTLI_COMMON_TRANSFORM_H_\n+\n+#include <brotli/port.h>\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+enum BrotliWordTransformType {\n+  BROTLI_TRANSFORM_IDENTITY = 0,\n+  BROTLI_TRANSFORM_OMIT_LAST_1 = 1,\n+  BROTLI_TRANSFORM_OMIT_LAST_2 = 2,\n+  BROTLI_TRANSFORM_OMIT_LAST_3 = 3,\n+  BROTLI_TRANSFORM_OMIT_LAST_4 = 4,\n+  BROTLI_TRANSFORM_OMIT_LAST_5 = 5,\n+  BROTLI_TRANSFORM_OMIT_LAST_6 = 6,\n+  BROTLI_TRANSFORM_OMIT_LAST_7 = 7,\n+  BROTLI_TRANSFORM_OMIT_LAST_8 = 8,\n+  BROTLI_TRANSFORM_OMIT_LAST_9 = 9,\n+  BROTLI_TRANSFORM_UPPERCASE_FIRST = 10,\n+  BROTLI_TRANSFORM_UPPERCASE_ALL = 11,\n+  BROTLI_TRANSFORM_OMIT_FIRST_1 = 12,\n+  BROTLI_TRANSFORM_OMIT_FIRST_2 = 13,\n+  BROTLI_TRANSFORM_OMIT_FIRST_3 = 14,\n+  BROTLI_TRANSFORM_OMIT_FIRST_4 = 15,\n+  BROTLI_TRANSFORM_OMIT_FIRST_5 = 16,\n+  BROTLI_TRANSFORM_OMIT_FIRST_6 = 17,\n+  BROTLI_TRANSFORM_OMIT_FIRST_7 = 18,\n+  BROTLI_TRANSFORM_OMIT_FIRST_8 = 19,\n+  BROTLI_TRANSFORM_OMIT_FIRST_9 = 20,\n+  BROTLI_NUM_TRANSFORM_TYPES  /* Counts transforms, not a transform itself. */\n+};\n+\n+#define BROTLI_TRANSFORMS_MAX_CUT_OFF BROTLI_TRANSFORM_OMIT_LAST_9\n+\n+typedef struct BrotliTransforms {\n+  uint16_t prefix_suffix_size;\n+  /* Last character must be null, so prefix_suffix_size must be at least 1. */\n+  const uint8_t* prefix_suffix;\n+  const uint16_t* prefix_suffix_map;\n+  uint32_t num_transforms;\n+  /* Each entry is a [prefix_id, transform, suffix_id] triplet. */\n+  const uint8_t* transforms;\n+  /* Indices of transforms like [\"\", BROTLI_TRANSFORM_OMIT_LAST_#, \"\"].\n+     0-th element corresponds to [\"\", BROTLI_TRANSFORM_IDENTITY, \"\"].\n+     -1, if cut-off transform does not exist. */\n+  int16_t cutOffTransforms[BROTLI_TRANSFORMS_MAX_CUT_OFF + 1];\n+} BrotliTransforms;\n+\n+/* T is BrotliTransforms*; result is uint8_t. */\n+#define BROTLI_TRANSFORM_PREFIX_ID(T, I) ((T)->transforms[((I) * 3) + 0])\n+#define BROTLI_TRANSFORM_TYPE(T, I)      ((T)->transforms[((I) * 3) + 1])\n+#define BROTLI_TRANSFORM_SUFFIX_ID(T, I) ((T)->transforms[((I) * 3) + 2])\n+\n+/* T is BrotliTransforms*; result is const uint8_t*. */\n+#define BROTLI_TRANSFORM_PREFIX(T, I) (&(T)->prefix_suffix[ \\\n+    (T)->prefix_suffix_map[BROTLI_TRANSFORM_PREFIX_ID(T, I)]])\n+#define BROTLI_TRANSFORM_SUFFIX(T, I) (&(T)->prefix_suffix[ \\\n+    (T)->prefix_suffix_map[BROTLI_TRANSFORM_SUFFIX_ID(T, I)]])\n+\n+BROTLI_COMMON_API const BrotliTransforms* BrotliGetTransforms(void);\n+\n+BROTLI_COMMON_API int BrotliTransformDictionaryWord(\n+    uint8_t* dst, const uint8_t* word, int len,\n+    const BrotliTransforms* transforms, int transform_idx);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_COMMON_TRANSFORM_H_ */"
        },
        {
            "sha": "0d0d0c79676809a293fc03a592c2eccc11ad8651",
            "filename": "deps/brotli/c/common/version.h",
            "status": "added",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fversion.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fcommon%2Fversion.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fcommon%2Fversion.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,26 @@\n+/* Copyright 2016 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Version definition. */\n+\n+#ifndef BROTLI_COMMON_VERSION_H_\n+#define BROTLI_COMMON_VERSION_H_\n+\n+/* This macro should only be used when library is compiled together with client.\n+   If library is dynamically linked, use BrotliDecoderVersion and\n+   BrotliEncoderVersion methods. */\n+\n+/* Semantic version, calculated as (MAJOR << 24) | (MINOR << 12) | PATCH */\n+#define BROTLI_VERSION 0x1000007\n+\n+/* This macro is used by build system to produce Libtool-friendly soname. See\n+   https://www.gnu.org/software/libtool/manual/html_node/Libtool-versioning.html\n+ */\n+\n+/* ABI version, calculated as (CURRENT << 24) | (REVISION << 12) | AGE */\n+#define BROTLI_ABI_VERSION 0x1007000\n+\n+#endif  /* BROTLI_COMMON_VERSION_H_ */"
        },
        {
            "sha": "722fd906dd43427d9bc2fe91f7ad545063d342a9",
            "filename": "deps/brotli/c/dec/bit_reader.c",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fbit_reader.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fbit_reader.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fdec%2Fbit_reader.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,48 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Bit reading helpers */\n+\n+#include \"./bit_reader.h\"\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+void BrotliInitBitReader(BrotliBitReader* const br) {\n+  br->val_ = 0;\n+  br->bit_pos_ = sizeof(br->val_) << 3;\n+}\n+\n+BROTLI_BOOL BrotliWarmupBitReader(BrotliBitReader* const br) {\n+  size_t aligned_read_mask = (sizeof(br->val_) >> 1) - 1;\n+  /* Fixing alignment after unaligned BrotliFillWindow would result accumulator\n+     overflow. If unalignment is caused by BrotliSafeReadBits, then there is\n+     enough space in accumulator to fix alignment. */\n+  if (!BROTLI_ALIGNED_READ) {\n+    aligned_read_mask = 0;\n+  }\n+  if (BrotliGetAvailableBits(br) == 0) {\n+    if (!BrotliPullByte(br)) {\n+      return BROTLI_FALSE;\n+    }\n+  }\n+\n+  while ((((size_t)br->next_in) & aligned_read_mask) != 0) {\n+    if (!BrotliPullByte(br)) {\n+      /* If we consumed all the input, we don't care about the alignment. */\n+      return BROTLI_TRUE;\n+    }\n+  }\n+  return BROTLI_TRUE;\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "c06e91419f28f0435887683d2c93667d7249eca8",
            "filename": "deps/brotli/c/dec/bit_reader.h",
            "status": "added",
            "additions": 309,
            "deletions": 0,
            "changes": 309,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fbit_reader.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fbit_reader.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fdec%2Fbit_reader.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,309 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Bit reading helpers */\n+\n+#ifndef BROTLI_DEC_BIT_READER_H_\n+#define BROTLI_DEC_BIT_READER_H_\n+\n+#include <string.h>  /* memcpy */\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define BROTLI_SHORT_FILL_BIT_WINDOW_READ (sizeof(brotli_reg_t) >> 1)\n+\n+static const uint32_t kBitMask[33] = {  0x00000000,\n+    0x00000001, 0x00000003, 0x00000007, 0x0000000F,\n+    0x0000001F, 0x0000003F, 0x0000007F, 0x000000FF,\n+    0x000001FF, 0x000003FF, 0x000007FF, 0x00000FFF,\n+    0x00001FFF, 0x00003FFF, 0x00007FFF, 0x0000FFFF,\n+    0x0001FFFF, 0x0003FFFF, 0x0007FFFF, 0x000FFFFF,\n+    0x001FFFFF, 0x003FFFFF, 0x007FFFFF, 0x00FFFFFF,\n+    0x01FFFFFF, 0x03FFFFFF, 0x07FFFFFF, 0x0FFFFFFF,\n+    0x1FFFFFFF, 0x3FFFFFFF, 0x7FFFFFFF, 0xFFFFFFFF\n+};\n+\n+static BROTLI_INLINE uint32_t BitMask(uint32_t n) {\n+  if (BROTLI_IS_CONSTANT(n) || BROTLI_HAS_UBFX) {\n+    /* Masking with this expression turns to a single\n+       \"Unsigned Bit Field Extract\" UBFX instruction on ARM. */\n+    return ~((0xFFFFFFFFu) << n);\n+  } else {\n+    return kBitMask[n];\n+  }\n+}\n+\n+typedef struct {\n+  brotli_reg_t val_;       /* pre-fetched bits */\n+  uint32_t bit_pos_;       /* current bit-reading position in val_ */\n+  const uint8_t* next_in;  /* the byte we're reading from */\n+  size_t avail_in;\n+} BrotliBitReader;\n+\n+typedef struct {\n+  brotli_reg_t val_;\n+  uint32_t bit_pos_;\n+  const uint8_t* next_in;\n+  size_t avail_in;\n+} BrotliBitReaderState;\n+\n+/* Initializes the BrotliBitReader fields. */\n+BROTLI_INTERNAL void BrotliInitBitReader(BrotliBitReader* const br);\n+\n+/* Ensures that accumulator is not empty.\n+   May consume up to sizeof(brotli_reg_t) - 1 bytes of input.\n+   Returns BROTLI_FALSE if data is required but there is no input available.\n+   For BROTLI_ALIGNED_READ this function also prepares bit reader for aligned\n+   reading. */\n+BROTLI_INTERNAL BROTLI_BOOL BrotliWarmupBitReader(BrotliBitReader* const br);\n+\n+static BROTLI_INLINE void BrotliBitReaderSaveState(\n+    BrotliBitReader* const from, BrotliBitReaderState* to) {\n+  to->val_ = from->val_;\n+  to->bit_pos_ = from->bit_pos_;\n+  to->next_in = from->next_in;\n+  to->avail_in = from->avail_in;\n+}\n+\n+static BROTLI_INLINE void BrotliBitReaderRestoreState(\n+    BrotliBitReader* const to, BrotliBitReaderState* from) {\n+  to->val_ = from->val_;\n+  to->bit_pos_ = from->bit_pos_;\n+  to->next_in = from->next_in;\n+  to->avail_in = from->avail_in;\n+}\n+\n+static BROTLI_INLINE uint32_t BrotliGetAvailableBits(\n+    const BrotliBitReader* br) {\n+  return (BROTLI_64_BITS ? 64 : 32) - br->bit_pos_;\n+}\n+\n+/* Returns amount of unread bytes the bit reader still has buffered from the\n+   BrotliInput, including whole bytes in br->val_. */\n+static BROTLI_INLINE size_t BrotliGetRemainingBytes(BrotliBitReader* br) {\n+  return br->avail_in + (BrotliGetAvailableBits(br) >> 3);\n+}\n+\n+/* Checks if there is at least |num| bytes left in the input ring-buffer\n+   (excluding the bits remaining in br->val_). */\n+static BROTLI_INLINE BROTLI_BOOL BrotliCheckInputAmount(\n+    BrotliBitReader* const br, size_t num) {\n+  return TO_BROTLI_BOOL(br->avail_in >= num);\n+}\n+\n+/* Guarantees that there are at least |n_bits| + 1 bits in accumulator.\n+   Precondition: accumulator contains at least 1 bit.\n+   |n_bits| should be in the range [1..24] for regular build. For portable\n+   non-64-bit little-endian build only 16 bits are safe to request. */\n+static BROTLI_INLINE void BrotliFillBitWindow(\n+    BrotliBitReader* const br, uint32_t n_bits) {\n+#if (BROTLI_64_BITS)\n+  if (!BROTLI_ALIGNED_READ && BROTLI_IS_CONSTANT(n_bits) && (n_bits <= 8)) {\n+    if (br->bit_pos_ >= 56) {\n+      br->val_ >>= 56;\n+      br->bit_pos_ ^= 56;  /* here same as -= 56 because of the if condition */\n+      br->val_ |= BROTLI_UNALIGNED_LOAD64LE(br->next_in) << 8;\n+      br->avail_in -= 7;\n+      br->next_in += 7;\n+    }\n+  } else if (\n+      !BROTLI_ALIGNED_READ && BROTLI_IS_CONSTANT(n_bits) && (n_bits <= 16)) {\n+    if (br->bit_pos_ >= 48) {\n+      br->val_ >>= 48;\n+      br->bit_pos_ ^= 48;  /* here same as -= 48 because of the if condition */\n+      br->val_ |= BROTLI_UNALIGNED_LOAD64LE(br->next_in) << 16;\n+      br->avail_in -= 6;\n+      br->next_in += 6;\n+    }\n+  } else {\n+    if (br->bit_pos_ >= 32) {\n+      br->val_ >>= 32;\n+      br->bit_pos_ ^= 32;  /* here same as -= 32 because of the if condition */\n+      br->val_ |= ((uint64_t)BROTLI_UNALIGNED_LOAD32LE(br->next_in)) << 32;\n+      br->avail_in -= BROTLI_SHORT_FILL_BIT_WINDOW_READ;\n+      br->next_in += BROTLI_SHORT_FILL_BIT_WINDOW_READ;\n+    }\n+  }\n+#else\n+  if (!BROTLI_ALIGNED_READ && BROTLI_IS_CONSTANT(n_bits) && (n_bits <= 8)) {\n+    if (br->bit_pos_ >= 24) {\n+      br->val_ >>= 24;\n+      br->bit_pos_ ^= 24;  /* here same as -= 24 because of the if condition */\n+      br->val_ |= BROTLI_UNALIGNED_LOAD32LE(br->next_in) << 8;\n+      br->avail_in -= 3;\n+      br->next_in += 3;\n+    }\n+  } else {\n+    if (br->bit_pos_ >= 16) {\n+      br->val_ >>= 16;\n+      br->bit_pos_ ^= 16;  /* here same as -= 16 because of the if condition */\n+      br->val_ |= ((uint32_t)BROTLI_UNALIGNED_LOAD16LE(br->next_in)) << 16;\n+      br->avail_in -= BROTLI_SHORT_FILL_BIT_WINDOW_READ;\n+      br->next_in += BROTLI_SHORT_FILL_BIT_WINDOW_READ;\n+    }\n+  }\n+#endif\n+}\n+\n+/* Mostly like BrotliFillBitWindow, but guarantees only 16 bits and reads no\n+   more than BROTLI_SHORT_FILL_BIT_WINDOW_READ bytes of input. */\n+static BROTLI_INLINE void BrotliFillBitWindow16(BrotliBitReader* const br) {\n+  BrotliFillBitWindow(br, 17);\n+}\n+\n+/* Tries to pull one byte of input to accumulator.\n+   Returns BROTLI_FALSE if there is no input available. */\n+static BROTLI_INLINE BROTLI_BOOL BrotliPullByte(BrotliBitReader* const br) {\n+  if (br->avail_in == 0) {\n+    return BROTLI_FALSE;\n+  }\n+  br->val_ >>= 8;\n+#if (BROTLI_64_BITS)\n+  br->val_ |= ((uint64_t)*br->next_in) << 56;\n+#else\n+  br->val_ |= ((uint32_t)*br->next_in) << 24;\n+#endif\n+  br->bit_pos_ -= 8;\n+  --br->avail_in;\n+  ++br->next_in;\n+  return BROTLI_TRUE;\n+}\n+\n+/* Returns currently available bits.\n+   The number of valid bits could be calculated by BrotliGetAvailableBits. */\n+static BROTLI_INLINE brotli_reg_t BrotliGetBitsUnmasked(\n+    BrotliBitReader* const br) {\n+  return br->val_ >> br->bit_pos_;\n+}\n+\n+/* Like BrotliGetBits, but does not mask the result.\n+   The result contains at least 16 valid bits. */\n+static BROTLI_INLINE uint32_t BrotliGet16BitsUnmasked(\n+    BrotliBitReader* const br) {\n+  BrotliFillBitWindow(br, 16);\n+  return (uint32_t)BrotliGetBitsUnmasked(br);\n+}\n+\n+/* Returns the specified number of bits from |br| without advancing bit\n+   position. */\n+static BROTLI_INLINE uint32_t BrotliGetBits(\n+    BrotliBitReader* const br, uint32_t n_bits) {\n+  BrotliFillBitWindow(br, n_bits);\n+  return (uint32_t)BrotliGetBitsUnmasked(br) & BitMask(n_bits);\n+}\n+\n+/* Tries to peek the specified amount of bits. Returns BROTLI_FALSE, if there\n+   is not enough input. */\n+static BROTLI_INLINE BROTLI_BOOL BrotliSafeGetBits(\n+    BrotliBitReader* const br, uint32_t n_bits, uint32_t* val) {\n+  while (BrotliGetAvailableBits(br) < n_bits) {\n+    if (!BrotliPullByte(br)) {\n+      return BROTLI_FALSE;\n+    }\n+  }\n+  *val = (uint32_t)BrotliGetBitsUnmasked(br) & BitMask(n_bits);\n+  return BROTLI_TRUE;\n+}\n+\n+/* Advances the bit pos by |n_bits|. */\n+static BROTLI_INLINE void BrotliDropBits(\n+    BrotliBitReader* const br, uint32_t n_bits) {\n+  br->bit_pos_ += n_bits;\n+}\n+\n+static BROTLI_INLINE void BrotliBitReaderUnload(BrotliBitReader* br) {\n+  uint32_t unused_bytes = BrotliGetAvailableBits(br) >> 3;\n+  uint32_t unused_bits = unused_bytes << 3;\n+  br->avail_in += unused_bytes;\n+  br->next_in -= unused_bytes;\n+  if (unused_bits == sizeof(br->val_) << 3) {\n+    br->val_ = 0;\n+  } else {\n+    br->val_ <<= unused_bits;\n+  }\n+  br->bit_pos_ += unused_bits;\n+}\n+\n+/* Reads the specified number of bits from |br| and advances the bit pos.\n+   Precondition: accumulator MUST contain at least |n_bits|. */\n+static BROTLI_INLINE void BrotliTakeBits(\n+  BrotliBitReader* const br, uint32_t n_bits, uint32_t* val) {\n+  *val = (uint32_t)BrotliGetBitsUnmasked(br) & BitMask(n_bits);\n+  BROTLI_LOG((\"[BrotliReadBits]  %d %d %d val: %6x\\n\",\n+      (int)br->avail_in, (int)br->bit_pos_, (int)n_bits, (int)*val));\n+  BrotliDropBits(br, n_bits);\n+}\n+\n+/* Reads the specified number of bits from |br| and advances the bit pos.\n+   Assumes that there is enough input to perform BrotliFillBitWindow. */\n+static BROTLI_INLINE uint32_t BrotliReadBits(\n+    BrotliBitReader* const br, uint32_t n_bits) {\n+  if (BROTLI_64_BITS || (n_bits <= 16)) {\n+    uint32_t val;\n+    BrotliFillBitWindow(br, n_bits);\n+    BrotliTakeBits(br, n_bits, &val);\n+    return val;\n+  } else {\n+    uint32_t low_val;\n+    uint32_t high_val;\n+    BrotliFillBitWindow(br, 16);\n+    BrotliTakeBits(br, 16, &low_val);\n+    BrotliFillBitWindow(br, 8);\n+    BrotliTakeBits(br, n_bits - 16, &high_val);\n+    return low_val | (high_val << 16);\n+  }\n+}\n+\n+/* Tries to read the specified amount of bits. Returns BROTLI_FALSE, if there\n+   is not enough input. |n_bits| MUST be positive. */\n+static BROTLI_INLINE BROTLI_BOOL BrotliSafeReadBits(\n+    BrotliBitReader* const br, uint32_t n_bits, uint32_t* val) {\n+  while (BrotliGetAvailableBits(br) < n_bits) {\n+    if (!BrotliPullByte(br)) {\n+      return BROTLI_FALSE;\n+    }\n+  }\n+  BrotliTakeBits(br, n_bits, val);\n+  return BROTLI_TRUE;\n+}\n+\n+/* Advances the bit reader position to the next byte boundary and verifies\n+   that any skipped bits are set to zero. */\n+static BROTLI_INLINE BROTLI_BOOL BrotliJumpToByteBoundary(BrotliBitReader* br) {\n+  uint32_t pad_bits_count = BrotliGetAvailableBits(br) & 0x7;\n+  uint32_t pad_bits = 0;\n+  if (pad_bits_count != 0) {\n+    BrotliTakeBits(br, pad_bits_count, &pad_bits);\n+  }\n+  return TO_BROTLI_BOOL(pad_bits == 0);\n+}\n+\n+/* Copies remaining input bytes stored in the bit reader to the output. Value\n+   |num| may not be larger than BrotliGetRemainingBytes. The bit reader must be\n+   warmed up again after this. */\n+static BROTLI_INLINE void BrotliCopyBytes(uint8_t* dest,\n+                                          BrotliBitReader* br, size_t num) {\n+  while (BrotliGetAvailableBits(br) >= 8 && num > 0) {\n+    *dest = (uint8_t)BrotliGetBitsUnmasked(br);\n+    BrotliDropBits(br, 8);\n+    ++dest;\n+    --num;\n+  }\n+  memcpy(dest, br->next_in, num);\n+  br->avail_in -= num;\n+  br->next_in += num;\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_DEC_BIT_READER_H_ */"
        },
        {
            "sha": "08bd76ca16e2a8d6a45ec48a18c95c5fa118561f",
            "filename": "deps/brotli/c/dec/decode.c",
            "status": "added",
            "additions": 2506,
            "deletions": 0,
            "changes": 2506,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fdecode.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fdecode.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fdec%2Fdecode.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,2506 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+#include <brotli/decode.h>\n+\n+#include <stdlib.h>  /* free, malloc */\n+#include <string.h>  /* memcpy, memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/context.h\"\n+#include \"../common/dictionary.h\"\n+#include \"../common/platform.h\"\n+#include \"../common/transform.h\"\n+#include \"../common/version.h\"\n+#include \"./bit_reader.h\"\n+#include \"./huffman.h\"\n+#include \"./prefix.h\"\n+#include \"./state.h\"\n+\n+#if defined(BROTLI_TARGET_NEON)\n+#include <arm_neon.h>\n+#endif\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define BROTLI_FAILURE(CODE) (BROTLI_DUMP(), CODE)\n+\n+#define BROTLI_LOG_UINT(name)                                       \\\n+  BROTLI_LOG((\"[%s] %s = %lu\\n\", __func__, #name, (unsigned long)(name)))\n+#define BROTLI_LOG_ARRAY_INDEX(array_name, idx)                     \\\n+  BROTLI_LOG((\"[%s] %s[%lu] = %lu\\n\", __func__, #array_name,        \\\n+         (unsigned long)(idx), (unsigned long)array_name[idx]))\n+\n+#define HUFFMAN_TABLE_BITS 8U\n+#define HUFFMAN_TABLE_MASK 0xFF\n+\n+/* We need the slack region for the following reasons:\n+    - doing up to two 16-byte copies for fast backward copying\n+    - inserting transformed dictionary word (5 prefix + 24 base + 8 suffix) */\n+static const uint32_t kRingBufferWriteAheadSlack = 42;\n+\n+static const uint8_t kCodeLengthCodeOrder[BROTLI_CODE_LENGTH_CODES] = {\n+  1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n+};\n+\n+/* Static prefix code for the complex code length code lengths. */\n+static const uint8_t kCodeLengthPrefixLength[16] = {\n+  2, 2, 2, 3, 2, 2, 2, 4, 2, 2, 2, 3, 2, 2, 2, 4,\n+};\n+\n+static const uint8_t kCodeLengthPrefixValue[16] = {\n+  0, 4, 3, 2, 0, 4, 3, 1, 0, 4, 3, 2, 0, 4, 3, 5,\n+};\n+\n+BROTLI_BOOL BrotliDecoderSetParameter(\n+    BrotliDecoderState* state, BrotliDecoderParameter p, uint32_t value) {\n+  if (state->state != BROTLI_STATE_UNINITED) return BROTLI_FALSE;\n+  switch (p) {\n+    case BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION:\n+      state->canny_ringbuffer_allocation = !!value ? 0 : 1;\n+      return BROTLI_TRUE;\n+\n+    case BROTLI_DECODER_PARAM_LARGE_WINDOW:\n+      state->large_window = TO_BROTLI_BOOL(!!value);\n+      return BROTLI_TRUE;\n+\n+    default: return BROTLI_FALSE;\n+  }\n+}\n+\n+BrotliDecoderState* BrotliDecoderCreateInstance(\n+    brotli_alloc_func alloc_func, brotli_free_func free_func, void* opaque) {\n+  BrotliDecoderState* state = 0;\n+  if (!alloc_func && !free_func) {\n+    state = (BrotliDecoderState*)malloc(sizeof(BrotliDecoderState));\n+  } else if (alloc_func && free_func) {\n+    state = (BrotliDecoderState*)alloc_func(opaque, sizeof(BrotliDecoderState));\n+  }\n+  if (state == 0) {\n+    BROTLI_DUMP();\n+    return 0;\n+  }\n+  if (!BrotliDecoderStateInit(state, alloc_func, free_func, opaque)) {\n+    BROTLI_DUMP();\n+    if (!alloc_func && !free_func) {\n+      free(state);\n+    } else if (alloc_func && free_func) {\n+      free_func(opaque, state);\n+    }\n+    return 0;\n+  }\n+  return state;\n+}\n+\n+/* Deinitializes and frees BrotliDecoderState instance. */\n+void BrotliDecoderDestroyInstance(BrotliDecoderState* state) {\n+  if (!state) {\n+    return;\n+  } else {\n+    brotli_free_func free_func = state->free_func;\n+    void* opaque = state->memory_manager_opaque;\n+    BrotliDecoderStateCleanup(state);\n+    free_func(opaque, state);\n+  }\n+}\n+\n+/* Saves error code and converts it to BrotliDecoderResult. */\n+static BROTLI_NOINLINE BrotliDecoderResult SaveErrorCode(\n+    BrotliDecoderState* s, BrotliDecoderErrorCode e) {\n+  s->error_code = (int)e;\n+  switch (e) {\n+    case BROTLI_DECODER_SUCCESS:\n+      return BROTLI_DECODER_RESULT_SUCCESS;\n+\n+    case BROTLI_DECODER_NEEDS_MORE_INPUT:\n+      return BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT;\n+\n+    case BROTLI_DECODER_NEEDS_MORE_OUTPUT:\n+      return BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT;\n+\n+    default:\n+      return BROTLI_DECODER_RESULT_ERROR;\n+  }\n+}\n+\n+/* Decodes WBITS by reading 1 - 7 bits, or 0x11 for \"Large Window Brotli\".\n+   Precondition: bit-reader accumulator has at least 8 bits. */\n+static BrotliDecoderErrorCode DecodeWindowBits(BrotliDecoderState* s,\n+                                               BrotliBitReader* br) {\n+  uint32_t n;\n+  BROTLI_BOOL large_window = s->large_window;\n+  s->large_window = BROTLI_FALSE;\n+  BrotliTakeBits(br, 1, &n);\n+  if (n == 0) {\n+    s->window_bits = 16;\n+    return BROTLI_DECODER_SUCCESS;\n+  }\n+  BrotliTakeBits(br, 3, &n);\n+  if (n != 0) {\n+    s->window_bits = 17 + n;\n+    return BROTLI_DECODER_SUCCESS;\n+  }\n+  BrotliTakeBits(br, 3, &n);\n+  if (n == 1) {\n+    if (large_window) {\n+      BrotliTakeBits(br, 1, &n);\n+      if (n == 1) {\n+        return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS);\n+      }\n+      s->large_window = BROTLI_TRUE;\n+      return BROTLI_DECODER_SUCCESS;\n+    } else {\n+      return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS);\n+    }\n+  }\n+  if (n != 0) {\n+    s->window_bits = 8 + n;\n+    return BROTLI_DECODER_SUCCESS;\n+  }\n+  s->window_bits = 17;\n+  return BROTLI_DECODER_SUCCESS;\n+}\n+\n+static BROTLI_INLINE void memmove16(uint8_t* dst, uint8_t* src) {\n+#if defined(BROTLI_TARGET_NEON)\n+  vst1q_u8(dst, vld1q_u8(src));\n+#else\n+  uint32_t buffer[4];\n+  memcpy(buffer, src, 16);\n+  memcpy(dst, buffer, 16);\n+#endif\n+}\n+\n+/* Decodes a number in the range [0..255], by reading 1 - 11 bits. */\n+static BROTLI_NOINLINE BrotliDecoderErrorCode DecodeVarLenUint8(\n+    BrotliDecoderState* s, BrotliBitReader* br, uint32_t* value) {\n+  uint32_t bits;\n+  switch (s->substate_decode_uint8) {\n+    case BROTLI_STATE_DECODE_UINT8_NONE:\n+      if (BROTLI_PREDICT_FALSE(!BrotliSafeReadBits(br, 1, &bits))) {\n+        return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+      }\n+      if (bits == 0) {\n+        *value = 0;\n+        return BROTLI_DECODER_SUCCESS;\n+      }\n+    /* Fall through. */\n+\n+    case BROTLI_STATE_DECODE_UINT8_SHORT:\n+      if (BROTLI_PREDICT_FALSE(!BrotliSafeReadBits(br, 3, &bits))) {\n+        s->substate_decode_uint8 = BROTLI_STATE_DECODE_UINT8_SHORT;\n+        return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+      }\n+      if (bits == 0) {\n+        *value = 1;\n+        s->substate_decode_uint8 = BROTLI_STATE_DECODE_UINT8_NONE;\n+        return BROTLI_DECODER_SUCCESS;\n+      }\n+      /* Use output value as a temporary storage. It MUST be persisted. */\n+      *value = bits;\n+    /* Fall through. */\n+\n+    case BROTLI_STATE_DECODE_UINT8_LONG:\n+      if (BROTLI_PREDICT_FALSE(!BrotliSafeReadBits(br, *value, &bits))) {\n+        s->substate_decode_uint8 = BROTLI_STATE_DECODE_UINT8_LONG;\n+        return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+      }\n+      *value = (1U << *value) + bits;\n+      s->substate_decode_uint8 = BROTLI_STATE_DECODE_UINT8_NONE;\n+      return BROTLI_DECODER_SUCCESS;\n+\n+    default:\n+      return\n+          BROTLI_FAILURE(BROTLI_DECODER_ERROR_UNREACHABLE);\n+  }\n+}\n+\n+/* Decodes a metablock length and flags by reading 2 - 31 bits. */\n+static BrotliDecoderErrorCode BROTLI_NOINLINE DecodeMetaBlockLength(\n+    BrotliDecoderState* s, BrotliBitReader* br) {\n+  uint32_t bits;\n+  int i;\n+  for (;;) {\n+    switch (s->substate_metablock_header) {\n+      case BROTLI_STATE_METABLOCK_HEADER_NONE:\n+        if (!BrotliSafeReadBits(br, 1, &bits)) {\n+          return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        }\n+        s->is_last_metablock = bits ? 1 : 0;\n+        s->meta_block_remaining_len = 0;\n+        s->is_uncompressed = 0;\n+        s->is_metadata = 0;\n+        if (!s->is_last_metablock) {\n+          s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NIBBLES;\n+          break;\n+        }\n+        s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_EMPTY;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_METABLOCK_HEADER_EMPTY:\n+        if (!BrotliSafeReadBits(br, 1, &bits)) {\n+          return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        }\n+        if (bits) {\n+          s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NONE;\n+          return BROTLI_DECODER_SUCCESS;\n+        }\n+        s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NIBBLES;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_METABLOCK_HEADER_NIBBLES:\n+        if (!BrotliSafeReadBits(br, 2, &bits)) {\n+          return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        }\n+        s->size_nibbles = (uint8_t)(bits + 4);\n+        s->loop_counter = 0;\n+        if (bits == 3) {\n+          s->is_metadata = 1;\n+          s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_RESERVED;\n+          break;\n+        }\n+        s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_SIZE;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_METABLOCK_HEADER_SIZE:\n+        i = s->loop_counter;\n+        for (; i < (int)s->size_nibbles; ++i) {\n+          if (!BrotliSafeReadBits(br, 4, &bits)) {\n+            s->loop_counter = i;\n+            return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          }\n+          if (i + 1 == s->size_nibbles && s->size_nibbles > 4 && bits == 0) {\n+            return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE);\n+          }\n+          s->meta_block_remaining_len |= (int)(bits << (i * 4));\n+        }\n+        s->substate_metablock_header =\n+            BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED:\n+        if (!s->is_last_metablock) {\n+          if (!BrotliSafeReadBits(br, 1, &bits)) {\n+            return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          }\n+          s->is_uncompressed = bits ? 1 : 0;\n+        }\n+        ++s->meta_block_remaining_len;\n+        s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NONE;\n+        return BROTLI_DECODER_SUCCESS;\n+\n+      case BROTLI_STATE_METABLOCK_HEADER_RESERVED:\n+        if (!BrotliSafeReadBits(br, 1, &bits)) {\n+          return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        }\n+        if (bits != 0) {\n+          return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_RESERVED);\n+        }\n+        s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_BYTES;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_METABLOCK_HEADER_BYTES:\n+        if (!BrotliSafeReadBits(br, 2, &bits)) {\n+          return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        }\n+        if (bits == 0) {\n+          s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NONE;\n+          return BROTLI_DECODER_SUCCESS;\n+        }\n+        s->size_nibbles = (uint8_t)bits;\n+        s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_METADATA;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_METABLOCK_HEADER_METADATA:\n+        i = s->loop_counter;\n+        for (; i < (int)s->size_nibbles; ++i) {\n+          if (!BrotliSafeReadBits(br, 8, &bits)) {\n+            s->loop_counter = i;\n+            return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          }\n+          if (i + 1 == s->size_nibbles && s->size_nibbles > 1 && bits == 0) {\n+            return BROTLI_FAILURE(\n+                BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE);\n+          }\n+          s->meta_block_remaining_len |= (int)(bits << (i * 8));\n+        }\n+        ++s->meta_block_remaining_len;\n+        s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NONE;\n+        return BROTLI_DECODER_SUCCESS;\n+\n+      default:\n+        return\n+            BROTLI_FAILURE(BROTLI_DECODER_ERROR_UNREACHABLE);\n+    }\n+  }\n+}\n+\n+/* Decodes the Huffman code.\n+   This method doesn't read data from the bit reader, BUT drops the amount of\n+   bits that correspond to the decoded symbol.\n+   bits MUST contain at least 15 (BROTLI_HUFFMAN_MAX_CODE_LENGTH) valid bits. */\n+static BROTLI_INLINE uint32_t DecodeSymbol(uint32_t bits,\n+                                           const HuffmanCode* table,\n+                                           BrotliBitReader* br) {\n+  BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(table);\n+  BROTLI_HC_ADJUST_TABLE_INDEX(table, bits & HUFFMAN_TABLE_MASK);\n+  if (BROTLI_HC_FAST_LOAD_BITS(table) > HUFFMAN_TABLE_BITS) {\n+    uint32_t nbits = BROTLI_HC_FAST_LOAD_BITS(table) - HUFFMAN_TABLE_BITS;\n+    BrotliDropBits(br, HUFFMAN_TABLE_BITS);\n+    BROTLI_HC_ADJUST_TABLE_INDEX(table,\n+        BROTLI_HC_FAST_LOAD_VALUE(table) +\n+        ((bits >> HUFFMAN_TABLE_BITS) & BitMask(nbits)));\n+  }\n+  BrotliDropBits(br, BROTLI_HC_FAST_LOAD_BITS(table));\n+  return BROTLI_HC_FAST_LOAD_VALUE(table);\n+}\n+\n+/* Reads and decodes the next Huffman code from bit-stream.\n+   This method peeks 16 bits of input and drops 0 - 15 of them. */\n+static BROTLI_INLINE uint32_t ReadSymbol(const HuffmanCode* table,\n+                                         BrotliBitReader* br) {\n+  return DecodeSymbol(BrotliGet16BitsUnmasked(br), table, br);\n+}\n+\n+/* Same as DecodeSymbol, but it is known that there is less than 15 bits of\n+   input are currently available. */\n+static BROTLI_NOINLINE BROTLI_BOOL SafeDecodeSymbol(\n+    const HuffmanCode* table, BrotliBitReader* br, uint32_t* result) {\n+  uint32_t val;\n+  uint32_t available_bits = BrotliGetAvailableBits(br);\n+  BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(table);\n+  if (available_bits == 0) {\n+    if (BROTLI_HC_FAST_LOAD_BITS(table) == 0) {\n+      *result = BROTLI_HC_FAST_LOAD_VALUE(table);\n+      return BROTLI_TRUE;\n+    }\n+    return BROTLI_FALSE;  /* No valid bits at all. */\n+  }\n+  val = (uint32_t)BrotliGetBitsUnmasked(br);\n+  BROTLI_HC_ADJUST_TABLE_INDEX(table, val & HUFFMAN_TABLE_MASK);\n+  if (BROTLI_HC_FAST_LOAD_BITS(table) <= HUFFMAN_TABLE_BITS) {\n+    if (BROTLI_HC_FAST_LOAD_BITS(table) <= available_bits) {\n+      BrotliDropBits(br, BROTLI_HC_FAST_LOAD_BITS(table));\n+      *result = BROTLI_HC_FAST_LOAD_VALUE(table);\n+      return BROTLI_TRUE;\n+    } else {\n+      return BROTLI_FALSE;  /* Not enough bits for the first level. */\n+    }\n+  }\n+  if (available_bits <= HUFFMAN_TABLE_BITS) {\n+    return BROTLI_FALSE;  /* Not enough bits to move to the second level. */\n+  }\n+\n+  /* Speculatively drop HUFFMAN_TABLE_BITS. */\n+  val = (val & BitMask(BROTLI_HC_FAST_LOAD_BITS(table))) >> HUFFMAN_TABLE_BITS;\n+  available_bits -= HUFFMAN_TABLE_BITS;\n+  BROTLI_HC_ADJUST_TABLE_INDEX(table, BROTLI_HC_FAST_LOAD_VALUE(table) + val);\n+  if (available_bits < BROTLI_HC_FAST_LOAD_BITS(table)) {\n+    return BROTLI_FALSE;  /* Not enough bits for the second level. */\n+  }\n+\n+  BrotliDropBits(br, HUFFMAN_TABLE_BITS + BROTLI_HC_FAST_LOAD_BITS(table));\n+  *result = BROTLI_HC_FAST_LOAD_VALUE(table);\n+  return BROTLI_TRUE;\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL SafeReadSymbol(\n+    const HuffmanCode* table, BrotliBitReader* br, uint32_t* result) {\n+  uint32_t val;\n+  if (BROTLI_PREDICT_TRUE(BrotliSafeGetBits(br, 15, &val))) {\n+    *result = DecodeSymbol(val, table, br);\n+    return BROTLI_TRUE;\n+  }\n+  return SafeDecodeSymbol(table, br, result);\n+}\n+\n+/* Makes a look-up in first level Huffman table. Peeks 8 bits. */\n+static BROTLI_INLINE void PreloadSymbol(int safe,\n+                                        const HuffmanCode* table,\n+                                        BrotliBitReader* br,\n+                                        uint32_t* bits,\n+                                        uint32_t* value) {\n+  if (safe) {\n+    return;\n+  }\n+  BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(table);\n+  BROTLI_HC_ADJUST_TABLE_INDEX(table, BrotliGetBits(br, HUFFMAN_TABLE_BITS));\n+  *bits = BROTLI_HC_FAST_LOAD_BITS(table);\n+  *value = BROTLI_HC_FAST_LOAD_VALUE(table);\n+}\n+\n+/* Decodes the next Huffman code using data prepared by PreloadSymbol.\n+   Reads 0 - 15 bits. Also peeks 8 following bits. */\n+static BROTLI_INLINE uint32_t ReadPreloadedSymbol(const HuffmanCode* table,\n+                                                  BrotliBitReader* br,\n+                                                  uint32_t* bits,\n+                                                  uint32_t* value) {\n+  uint32_t result = *value;\n+  if (BROTLI_PREDICT_FALSE(*bits > HUFFMAN_TABLE_BITS)) {\n+    uint32_t val = BrotliGet16BitsUnmasked(br);\n+    const HuffmanCode* ext = table + (val & HUFFMAN_TABLE_MASK) + *value;\n+    uint32_t mask = BitMask((*bits - HUFFMAN_TABLE_BITS));\n+    BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(ext);\n+    BrotliDropBits(br, HUFFMAN_TABLE_BITS);\n+    BROTLI_HC_ADJUST_TABLE_INDEX(ext, (val >> HUFFMAN_TABLE_BITS) & mask);\n+    BrotliDropBits(br, BROTLI_HC_FAST_LOAD_BITS(ext));\n+    result = BROTLI_HC_FAST_LOAD_VALUE(ext);\n+  } else {\n+    BrotliDropBits(br, *bits);\n+  }\n+  PreloadSymbol(0, table, br, bits, value);\n+  return result;\n+}\n+\n+static BROTLI_INLINE uint32_t Log2Floor(uint32_t x) {\n+  uint32_t result = 0;\n+  while (x) {\n+    x >>= 1;\n+    ++result;\n+  }\n+  return result;\n+}\n+\n+/* Reads (s->symbol + 1) symbols.\n+   Totally 1..4 symbols are read, 1..11 bits each.\n+   The list of symbols MUST NOT contain duplicates. */\n+static BrotliDecoderErrorCode ReadSimpleHuffmanSymbols(\n+    uint32_t alphabet_size, uint32_t max_symbol, BrotliDecoderState* s) {\n+  /* max_bits == 1..11; symbol == 0..3; 1..44 bits will be read. */\n+  BrotliBitReader* br = &s->br;\n+  uint32_t max_bits = Log2Floor(alphabet_size - 1);\n+  uint32_t i = s->sub_loop_counter;\n+  uint32_t num_symbols = s->symbol;\n+  while (i <= num_symbols) {\n+    uint32_t v;\n+    if (BROTLI_PREDICT_FALSE(!BrotliSafeReadBits(br, max_bits, &v))) {\n+      s->sub_loop_counter = i;\n+      s->substate_huffman = BROTLI_STATE_HUFFMAN_SIMPLE_READ;\n+      return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+    }\n+    if (v >= max_symbol) {\n+      return\n+          BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET);\n+    }\n+    s->symbols_lists_array[i] = (uint16_t)v;\n+    BROTLI_LOG_UINT(s->symbols_lists_array[i]);\n+    ++i;\n+  }\n+\n+  for (i = 0; i < num_symbols; ++i) {\n+    uint32_t k = i + 1;\n+    for (; k <= num_symbols; ++k) {\n+      if (s->symbols_lists_array[i] == s->symbols_lists_array[k]) {\n+        return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME);\n+      }\n+    }\n+  }\n+\n+  return BROTLI_DECODER_SUCCESS;\n+}\n+\n+/* Process single decoded symbol code length:\n+    A) reset the repeat variable\n+    B) remember code length (if it is not 0)\n+    C) extend corresponding index-chain\n+    D) reduce the Huffman space\n+    E) update the histogram */\n+static BROTLI_INLINE void ProcessSingleCodeLength(uint32_t code_len,\n+    uint32_t* symbol, uint32_t* repeat, uint32_t* space,\n+    uint32_t* prev_code_len, uint16_t* symbol_lists,\n+    uint16_t* code_length_histo, int* next_symbol) {\n+  *repeat = 0;\n+  if (code_len != 0) {  /* code_len == 1..15 */\n+    symbol_lists[next_symbol[code_len]] = (uint16_t)(*symbol);\n+    next_symbol[code_len] = (int)(*symbol);\n+    *prev_code_len = code_len;\n+    *space -= 32768U >> code_len;\n+    code_length_histo[code_len]++;\n+    BROTLI_LOG((\"[ReadHuffmanCode] code_length[%d] = %d\\n\",\n+        (int)*symbol, (int)code_len));\n+  }\n+  (*symbol)++;\n+}\n+\n+/* Process repeated symbol code length.\n+    A) Check if it is the extension of previous repeat sequence; if the decoded\n+       value is not BROTLI_REPEAT_PREVIOUS_CODE_LENGTH, then it is a new\n+       symbol-skip\n+    B) Update repeat variable\n+    C) Check if operation is feasible (fits alphabet)\n+    D) For each symbol do the same operations as in ProcessSingleCodeLength\n+\n+   PRECONDITION: code_len == BROTLI_REPEAT_PREVIOUS_CODE_LENGTH or\n+                 code_len == BROTLI_REPEAT_ZERO_CODE_LENGTH */\n+static BROTLI_INLINE void ProcessRepeatedCodeLength(uint32_t code_len,\n+    uint32_t repeat_delta, uint32_t alphabet_size, uint32_t* symbol,\n+    uint32_t* repeat, uint32_t* space, uint32_t* prev_code_len,\n+    uint32_t* repeat_code_len, uint16_t* symbol_lists,\n+    uint16_t* code_length_histo, int* next_symbol) {\n+  uint32_t old_repeat;\n+  uint32_t extra_bits = 3;  /* for BROTLI_REPEAT_ZERO_CODE_LENGTH */\n+  uint32_t new_len = 0;  /* for BROTLI_REPEAT_ZERO_CODE_LENGTH */\n+  if (code_len == BROTLI_REPEAT_PREVIOUS_CODE_LENGTH) {\n+    new_len = *prev_code_len;\n+    extra_bits = 2;\n+  }\n+  if (*repeat_code_len != new_len) {\n+    *repeat = 0;\n+    *repeat_code_len = new_len;\n+  }\n+  old_repeat = *repeat;\n+  if (*repeat > 0) {\n+    *repeat -= 2;\n+    *repeat <<= extra_bits;\n+  }\n+  *repeat += repeat_delta + 3U;\n+  repeat_delta = *repeat - old_repeat;\n+  if (*symbol + repeat_delta > alphabet_size) {\n+    BROTLI_DUMP();\n+    *symbol = alphabet_size;\n+    *space = 0xFFFFF;\n+    return;\n+  }\n+  BROTLI_LOG((\"[ReadHuffmanCode] code_length[%d..%d] = %d\\n\",\n+      (int)*symbol, (int)(*symbol + repeat_delta - 1), (int)*repeat_code_len));\n+  if (*repeat_code_len != 0) {\n+    unsigned last = *symbol + repeat_delta;\n+    int next = next_symbol[*repeat_code_len];\n+    do {\n+      symbol_lists[next] = (uint16_t)*symbol;\n+      next = (int)*symbol;\n+    } while (++(*symbol) != last);\n+    next_symbol[*repeat_code_len] = next;\n+    *space -= repeat_delta << (15 - *repeat_code_len);\n+    code_length_histo[*repeat_code_len] =\n+        (uint16_t)(code_length_histo[*repeat_code_len] + repeat_delta);\n+  } else {\n+    *symbol += repeat_delta;\n+  }\n+}\n+\n+/* Reads and decodes symbol codelengths. */\n+static BrotliDecoderErrorCode ReadSymbolCodeLengths(\n+    uint32_t alphabet_size, BrotliDecoderState* s) {\n+  BrotliBitReader* br = &s->br;\n+  uint32_t symbol = s->symbol;\n+  uint32_t repeat = s->repeat;\n+  uint32_t space = s->space;\n+  uint32_t prev_code_len = s->prev_code_len;\n+  uint32_t repeat_code_len = s->repeat_code_len;\n+  uint16_t* symbol_lists = s->symbol_lists;\n+  uint16_t* code_length_histo = s->code_length_histo;\n+  int* next_symbol = s->next_symbol;\n+  if (!BrotliWarmupBitReader(br)) {\n+    return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+  }\n+  while (symbol < alphabet_size && space > 0) {\n+    const HuffmanCode* p = s->table;\n+    uint32_t code_len;\n+    BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(p);\n+    if (!BrotliCheckInputAmount(br, BROTLI_SHORT_FILL_BIT_WINDOW_READ)) {\n+      s->symbol = symbol;\n+      s->repeat = repeat;\n+      s->prev_code_len = prev_code_len;\n+      s->repeat_code_len = repeat_code_len;\n+      s->space = space;\n+      return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+    }\n+    BrotliFillBitWindow16(br);\n+    BROTLI_HC_ADJUST_TABLE_INDEX(p, BrotliGetBitsUnmasked(br) &\n+        BitMask(BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH));\n+    BrotliDropBits(br, BROTLI_HC_FAST_LOAD_BITS(p));  /* Use 1..5 bits. */\n+    code_len = BROTLI_HC_FAST_LOAD_VALUE(p);  /* code_len == 0..17 */\n+    if (code_len < BROTLI_REPEAT_PREVIOUS_CODE_LENGTH) {\n+      ProcessSingleCodeLength(code_len, &symbol, &repeat, &space,\n+          &prev_code_len, symbol_lists, code_length_histo, next_symbol);\n+    } else {  /* code_len == 16..17, extra_bits == 2..3 */\n+      uint32_t extra_bits =\n+          (code_len == BROTLI_REPEAT_PREVIOUS_CODE_LENGTH) ? 2 : 3;\n+      uint32_t repeat_delta =\n+          (uint32_t)BrotliGetBitsUnmasked(br) & BitMask(extra_bits);\n+      BrotliDropBits(br, extra_bits);\n+      ProcessRepeatedCodeLength(code_len, repeat_delta, alphabet_size,\n+          &symbol, &repeat, &space, &prev_code_len, &repeat_code_len,\n+          symbol_lists, code_length_histo, next_symbol);\n+    }\n+  }\n+  s->space = space;\n+  return BROTLI_DECODER_SUCCESS;\n+}\n+\n+static BrotliDecoderErrorCode SafeReadSymbolCodeLengths(\n+    uint32_t alphabet_size, BrotliDecoderState* s) {\n+  BrotliBitReader* br = &s->br;\n+  BROTLI_BOOL get_byte = BROTLI_FALSE;\n+  while (s->symbol < alphabet_size && s->space > 0) {\n+    const HuffmanCode* p = s->table;\n+    uint32_t code_len;\n+    uint32_t available_bits;\n+    uint32_t bits = 0;\n+    BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(p);\n+    if (get_byte && !BrotliPullByte(br)) return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+    get_byte = BROTLI_FALSE;\n+    available_bits = BrotliGetAvailableBits(br);\n+    if (available_bits != 0) {\n+      bits = (uint32_t)BrotliGetBitsUnmasked(br);\n+    }\n+    BROTLI_HC_ADJUST_TABLE_INDEX(p,\n+        bits & BitMask(BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH));\n+    if (BROTLI_HC_FAST_LOAD_BITS(p) > available_bits) {\n+      get_byte = BROTLI_TRUE;\n+      continue;\n+    }\n+    code_len = BROTLI_HC_FAST_LOAD_VALUE(p);  /* code_len == 0..17 */\n+    if (code_len < BROTLI_REPEAT_PREVIOUS_CODE_LENGTH) {\n+      BrotliDropBits(br, BROTLI_HC_FAST_LOAD_BITS(p));\n+      ProcessSingleCodeLength(code_len, &s->symbol, &s->repeat, &s->space,\n+          &s->prev_code_len, s->symbol_lists, s->code_length_histo,\n+          s->next_symbol);\n+    } else {  /* code_len == 16..17, extra_bits == 2..3 */\n+      uint32_t extra_bits = code_len - 14U;\n+      uint32_t repeat_delta = (bits >> BROTLI_HC_FAST_LOAD_BITS(p)) &\n+          BitMask(extra_bits);\n+      if (available_bits < BROTLI_HC_FAST_LOAD_BITS(p) + extra_bits) {\n+        get_byte = BROTLI_TRUE;\n+        continue;\n+      }\n+      BrotliDropBits(br, BROTLI_HC_FAST_LOAD_BITS(p) + extra_bits);\n+      ProcessRepeatedCodeLength(code_len, repeat_delta, alphabet_size,\n+          &s->symbol, &s->repeat, &s->space, &s->prev_code_len,\n+          &s->repeat_code_len, s->symbol_lists, s->code_length_histo,\n+          s->next_symbol);\n+    }\n+  }\n+  return BROTLI_DECODER_SUCCESS;\n+}\n+\n+/* Reads and decodes 15..18 codes using static prefix code.\n+   Each code is 2..4 bits long. In total 30..72 bits are used. */\n+static BrotliDecoderErrorCode ReadCodeLengthCodeLengths(BrotliDecoderState* s) {\n+  BrotliBitReader* br = &s->br;\n+  uint32_t num_codes = s->repeat;\n+  unsigned space = s->space;\n+  uint32_t i = s->sub_loop_counter;\n+  for (; i < BROTLI_CODE_LENGTH_CODES; ++i) {\n+    const uint8_t code_len_idx = kCodeLengthCodeOrder[i];\n+    uint32_t ix;\n+    uint32_t v;\n+    if (BROTLI_PREDICT_FALSE(!BrotliSafeGetBits(br, 4, &ix))) {\n+      uint32_t available_bits = BrotliGetAvailableBits(br);\n+      if (available_bits != 0) {\n+        ix = BrotliGetBitsUnmasked(br) & 0xF;\n+      } else {\n+        ix = 0;\n+      }\n+      if (kCodeLengthPrefixLength[ix] > available_bits) {\n+        s->sub_loop_counter = i;\n+        s->repeat = num_codes;\n+        s->space = space;\n+        s->substate_huffman = BROTLI_STATE_HUFFMAN_COMPLEX;\n+        return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+      }\n+    }\n+    v = kCodeLengthPrefixValue[ix];\n+    BrotliDropBits(br, kCodeLengthPrefixLength[ix]);\n+    s->code_length_code_lengths[code_len_idx] = (uint8_t)v;\n+    BROTLI_LOG_ARRAY_INDEX(s->code_length_code_lengths, code_len_idx);\n+    if (v != 0) {\n+      space = space - (32U >> v);\n+      ++num_codes;\n+      ++s->code_length_histo[v];\n+      if (space - 1U >= 32U) {\n+        /* space is 0 or wrapped around. */\n+        break;\n+      }\n+    }\n+  }\n+  if (!(num_codes == 1 || space == 0)) {\n+    return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_CL_SPACE);\n+  }\n+  return BROTLI_DECODER_SUCCESS;\n+}\n+\n+/* Decodes the Huffman tables.\n+   There are 2 scenarios:\n+    A) Huffman code contains only few symbols (1..4). Those symbols are read\n+       directly; their code lengths are defined by the number of symbols.\n+       For this scenario 4 - 49 bits will be read.\n+\n+    B) 2-phase decoding:\n+    B.1) Small Huffman table is decoded; it is specified with code lengths\n+         encoded with predefined entropy code. 32 - 74 bits are used.\n+    B.2) Decoded table is used to decode code lengths of symbols in resulting\n+         Huffman table. In worst case 3520 bits are read. */\n+static BrotliDecoderErrorCode ReadHuffmanCode(uint32_t alphabet_size,\n+                                              uint32_t max_symbol,\n+                                              HuffmanCode* table,\n+                                              uint32_t* opt_table_size,\n+                                              BrotliDecoderState* s) {\n+  BrotliBitReader* br = &s->br;\n+  /* Unnecessary masking, but might be good for safety. */\n+  alphabet_size &= 0x7FF;\n+  /* State machine. */\n+  for (;;) {\n+    switch (s->substate_huffman) {\n+      case BROTLI_STATE_HUFFMAN_NONE:\n+        if (!BrotliSafeReadBits(br, 2, &s->sub_loop_counter)) {\n+          return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        }\n+        BROTLI_LOG_UINT(s->sub_loop_counter);\n+        /* The value is used as follows:\n+           1 for simple code;\n+           0 for no skipping, 2 skips 2 code lengths, 3 skips 3 code lengths */\n+        if (s->sub_loop_counter != 1) {\n+          s->space = 32;\n+          s->repeat = 0;  /* num_codes */\n+          memset(&s->code_length_histo[0], 0, sizeof(s->code_length_histo[0]) *\n+              (BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH + 1));\n+          memset(&s->code_length_code_lengths[0], 0,\n+              sizeof(s->code_length_code_lengths));\n+          s->substate_huffman = BROTLI_STATE_HUFFMAN_COMPLEX;\n+          continue;\n+        }\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_HUFFMAN_SIMPLE_SIZE:\n+        /* Read symbols, codes & code lengths directly. */\n+        if (!BrotliSafeReadBits(br, 2, &s->symbol)) {  /* num_symbols */\n+          s->substate_huffman = BROTLI_STATE_HUFFMAN_SIMPLE_SIZE;\n+          return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        }\n+        s->sub_loop_counter = 0;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_HUFFMAN_SIMPLE_READ: {\n+        BrotliDecoderErrorCode result =\n+            ReadSimpleHuffmanSymbols(alphabet_size, max_symbol, s);\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          return result;\n+        }\n+      }\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_HUFFMAN_SIMPLE_BUILD: {\n+        uint32_t table_size;\n+        if (s->symbol == 3) {\n+          uint32_t bits;\n+          if (!BrotliSafeReadBits(br, 1, &bits)) {\n+            s->substate_huffman = BROTLI_STATE_HUFFMAN_SIMPLE_BUILD;\n+            return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          }\n+          s->symbol += bits;\n+        }\n+        BROTLI_LOG_UINT(s->symbol);\n+        table_size = BrotliBuildSimpleHuffmanTable(\n+            table, HUFFMAN_TABLE_BITS, s->symbols_lists_array, s->symbol);\n+        if (opt_table_size) {\n+          *opt_table_size = table_size;\n+        }\n+        s->substate_huffman = BROTLI_STATE_HUFFMAN_NONE;\n+        return BROTLI_DECODER_SUCCESS;\n+      }\n+\n+      /* Decode Huffman-coded code lengths. */\n+      case BROTLI_STATE_HUFFMAN_COMPLEX: {\n+        uint32_t i;\n+        BrotliDecoderErrorCode result = ReadCodeLengthCodeLengths(s);\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          return result;\n+        }\n+        BrotliBuildCodeLengthsHuffmanTable(s->table,\n+                                           s->code_length_code_lengths,\n+                                           s->code_length_histo);\n+        memset(&s->code_length_histo[0], 0, sizeof(s->code_length_histo));\n+        for (i = 0; i <= BROTLI_HUFFMAN_MAX_CODE_LENGTH; ++i) {\n+          s->next_symbol[i] = (int)i - (BROTLI_HUFFMAN_MAX_CODE_LENGTH + 1);\n+          s->symbol_lists[s->next_symbol[i]] = 0xFFFF;\n+        }\n+\n+        s->symbol = 0;\n+        s->prev_code_len = BROTLI_INITIAL_REPEATED_CODE_LENGTH;\n+        s->repeat = 0;\n+        s->repeat_code_len = 0;\n+        s->space = 32768;\n+        s->substate_huffman = BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLS;\n+      }\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLS: {\n+        uint32_t table_size;\n+        BrotliDecoderErrorCode result = ReadSymbolCodeLengths(max_symbol, s);\n+        if (result == BROTLI_DECODER_NEEDS_MORE_INPUT) {\n+          result = SafeReadSymbolCodeLengths(max_symbol, s);\n+        }\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          return result;\n+        }\n+\n+        if (s->space != 0) {\n+          BROTLI_LOG((\"[ReadHuffmanCode] space = %d\\n\", (int)s->space));\n+          return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE);\n+        }\n+        table_size = BrotliBuildHuffmanTable(\n+            table, HUFFMAN_TABLE_BITS, s->symbol_lists, s->code_length_histo);\n+        if (opt_table_size) {\n+          *opt_table_size = table_size;\n+        }\n+        s->substate_huffman = BROTLI_STATE_HUFFMAN_NONE;\n+        return BROTLI_DECODER_SUCCESS;\n+      }\n+\n+      default:\n+        return\n+            BROTLI_FAILURE(BROTLI_DECODER_ERROR_UNREACHABLE);\n+    }\n+  }\n+}\n+\n+/* Decodes a block length by reading 3..39 bits. */\n+static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,\n+                                              BrotliBitReader* br) {\n+  uint32_t code;\n+  uint32_t nbits;\n+  code = ReadSymbol(table, br);\n+  nbits = kBlockLengthPrefixCode[code].nbits;  /* nbits == 2..24 */\n+  return kBlockLengthPrefixCode[code].offset + BrotliReadBits(br, nbits);\n+}\n+\n+/* WARNING: if state is not BROTLI_STATE_READ_BLOCK_LENGTH_NONE, then\n+   reading can't be continued with ReadBlockLength. */\n+static BROTLI_INLINE BROTLI_BOOL SafeReadBlockLength(\n+    BrotliDecoderState* s, uint32_t* result, const HuffmanCode* table,\n+    BrotliBitReader* br) {\n+  uint32_t index;\n+  if (s->substate_read_block_length == BROTLI_STATE_READ_BLOCK_LENGTH_NONE) {\n+    if (!SafeReadSymbol(table, br, &index)) {\n+      return BROTLI_FALSE;\n+    }\n+  } else {\n+    index = s->block_length_index;\n+  }\n+  {\n+    uint32_t bits;\n+    uint32_t nbits = kBlockLengthPrefixCode[index].nbits;  /* nbits == 2..24 */\n+    if (!BrotliSafeReadBits(br, nbits, &bits)) {\n+      s->block_length_index = index;\n+      s->substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_SUFFIX;\n+      return BROTLI_FALSE;\n+    }\n+    *result = kBlockLengthPrefixCode[index].offset + bits;\n+    s->substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_NONE;\n+    return BROTLI_TRUE;\n+  }\n+}\n+\n+/* Transform:\n+    1) initialize list L with values 0, 1,... 255\n+    2) For each input element X:\n+    2.1) let Y = L[X]\n+    2.2) remove X-th element from L\n+    2.3) prepend Y to L\n+    2.4) append Y to output\n+\n+   In most cases max(Y) <= 7, so most of L remains intact.\n+   To reduce the cost of initialization, we reuse L, remember the upper bound\n+   of Y values, and reinitialize only first elements in L.\n+\n+   Most of input values are 0 and 1. To reduce number of branches, we replace\n+   inner for loop with do-while. */\n+static BROTLI_NOINLINE void InverseMoveToFrontTransform(\n+    uint8_t* v, uint32_t v_len, BrotliDecoderState* state) {\n+  /* Reinitialize elements that could have been changed. */\n+  uint32_t i = 1;\n+  uint32_t upper_bound = state->mtf_upper_bound;\n+  uint32_t* mtf = &state->mtf[1];  /* Make mtf[-1] addressable. */\n+  uint8_t* mtf_u8 = (uint8_t*)mtf;\n+  /* Load endian-aware constant. */\n+  const uint8_t b0123[4] = {0, 1, 2, 3};\n+  uint32_t pattern;\n+  memcpy(&pattern, &b0123, 4);\n+\n+  /* Initialize list using 4 consequent values pattern. */\n+  mtf[0] = pattern;\n+  do {\n+    pattern += 0x04040404;  /* Advance all 4 values by 4. */\n+    mtf[i] = pattern;\n+    i++;\n+  } while (i <= upper_bound);\n+\n+  /* Transform the input. */\n+  upper_bound = 0;\n+  for (i = 0; i < v_len; ++i) {\n+    int index = v[i];\n+    uint8_t value = mtf_u8[index];\n+    upper_bound |= v[i];\n+    v[i] = value;\n+    mtf_u8[-1] = value;\n+    do {\n+      index--;\n+      mtf_u8[index + 1] = mtf_u8[index];\n+    } while (index >= 0);\n+  }\n+  /* Remember amount of elements to be reinitialized. */\n+  state->mtf_upper_bound = upper_bound >> 2;\n+}\n+\n+/* Decodes a series of Huffman table using ReadHuffmanCode function. */\n+static BrotliDecoderErrorCode HuffmanTreeGroupDecode(\n+    HuffmanTreeGroup* group, BrotliDecoderState* s) {\n+  if (s->substate_tree_group != BROTLI_STATE_TREE_GROUP_LOOP) {\n+    s->next = group->codes;\n+    s->htree_index = 0;\n+    s->substate_tree_group = BROTLI_STATE_TREE_GROUP_LOOP;\n+  }\n+  while (s->htree_index < group->num_htrees) {\n+    uint32_t table_size;\n+    BrotliDecoderErrorCode result =\n+        ReadHuffmanCode(group->alphabet_size, group->max_symbol,\n+                        s->next, &table_size, s);\n+    if (result != BROTLI_DECODER_SUCCESS) return result;\n+    group->htrees[s->htree_index] = s->next;\n+    s->next += table_size;\n+    ++s->htree_index;\n+  }\n+  s->substate_tree_group = BROTLI_STATE_TREE_GROUP_NONE;\n+  return BROTLI_DECODER_SUCCESS;\n+}\n+\n+/* Decodes a context map.\n+   Decoding is done in 4 phases:\n+    1) Read auxiliary information (6..16 bits) and allocate memory.\n+       In case of trivial context map, decoding is finished at this phase.\n+    2) Decode Huffman table using ReadHuffmanCode function.\n+       This table will be used for reading context map items.\n+    3) Read context map items; \"0\" values could be run-length encoded.\n+    4) Optionally, apply InverseMoveToFront transform to the resulting map. */\n+static BrotliDecoderErrorCode DecodeContextMap(uint32_t context_map_size,\n+                                               uint32_t* num_htrees,\n+                                               uint8_t** context_map_arg,\n+                                               BrotliDecoderState* s) {\n+  BrotliBitReader* br = &s->br;\n+  BrotliDecoderErrorCode result = BROTLI_DECODER_SUCCESS;\n+\n+  switch ((int)s->substate_context_map) {\n+    case BROTLI_STATE_CONTEXT_MAP_NONE:\n+      result = DecodeVarLenUint8(s, br, num_htrees);\n+      if (result != BROTLI_DECODER_SUCCESS) {\n+        return result;\n+      }\n+      (*num_htrees)++;\n+      s->context_index = 0;\n+      BROTLI_LOG_UINT(context_map_size);\n+      BROTLI_LOG_UINT(*num_htrees);\n+      *context_map_arg =\n+          (uint8_t*)BROTLI_DECODER_ALLOC(s, (size_t)context_map_size);\n+      if (*context_map_arg == 0) {\n+        return BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP);\n+      }\n+      if (*num_htrees <= 1) {\n+        memset(*context_map_arg, 0, (size_t)context_map_size);\n+        return BROTLI_DECODER_SUCCESS;\n+      }\n+      s->substate_context_map = BROTLI_STATE_CONTEXT_MAP_READ_PREFIX;\n+    /* Fall through. */\n+\n+    case BROTLI_STATE_CONTEXT_MAP_READ_PREFIX: {\n+      uint32_t bits;\n+      /* In next stage ReadHuffmanCode uses at least 4 bits, so it is safe\n+         to peek 4 bits ahead. */\n+      if (!BrotliSafeGetBits(br, 5, &bits)) {\n+        return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+      }\n+      if ((bits & 1) != 0) { /* Use RLE for zeros. */\n+        s->max_run_length_prefix = (bits >> 1) + 1;\n+        BrotliDropBits(br, 5);\n+      } else {\n+        s->max_run_length_prefix = 0;\n+        BrotliDropBits(br, 1);\n+      }\n+      BROTLI_LOG_UINT(s->max_run_length_prefix);\n+      s->substate_context_map = BROTLI_STATE_CONTEXT_MAP_HUFFMAN;\n+    }\n+    /* Fall through. */\n+\n+    case BROTLI_STATE_CONTEXT_MAP_HUFFMAN: {\n+      uint32_t alphabet_size = *num_htrees + s->max_run_length_prefix;\n+      result = ReadHuffmanCode(alphabet_size, alphabet_size,\n+                               s->context_map_table, NULL, s);\n+      if (result != BROTLI_DECODER_SUCCESS) return result;\n+      s->code = 0xFFFF;\n+      s->substate_context_map = BROTLI_STATE_CONTEXT_MAP_DECODE;\n+    }\n+    /* Fall through. */\n+\n+    case BROTLI_STATE_CONTEXT_MAP_DECODE: {\n+      uint32_t context_index = s->context_index;\n+      uint32_t max_run_length_prefix = s->max_run_length_prefix;\n+      uint8_t* context_map = *context_map_arg;\n+      uint32_t code = s->code;\n+      BROTLI_BOOL skip_preamble = (code != 0xFFFF);\n+      while (context_index < context_map_size || skip_preamble) {\n+        if (!skip_preamble) {\n+          if (!SafeReadSymbol(s->context_map_table, br, &code)) {\n+            s->code = 0xFFFF;\n+            s->context_index = context_index;\n+            return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          }\n+          BROTLI_LOG_UINT(code);\n+\n+          if (code == 0) {\n+            context_map[context_index++] = 0;\n+            continue;\n+          }\n+          if (code > max_run_length_prefix) {\n+            context_map[context_index++] =\n+                (uint8_t)(code - max_run_length_prefix);\n+            continue;\n+          }\n+        } else {\n+          skip_preamble = BROTLI_FALSE;\n+        }\n+        /* RLE sub-stage. */\n+        {\n+          uint32_t reps;\n+          if (!BrotliSafeReadBits(br, code, &reps)) {\n+            s->code = code;\n+            s->context_index = context_index;\n+            return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          }\n+          reps += 1U << code;\n+          BROTLI_LOG_UINT(reps);\n+          if (context_index + reps > context_map_size) {\n+            return\n+                BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT);\n+          }\n+          do {\n+            context_map[context_index++] = 0;\n+          } while (--reps);\n+        }\n+      }\n+    }\n+    /* Fall through. */\n+\n+    case BROTLI_STATE_CONTEXT_MAP_TRANSFORM: {\n+      uint32_t bits;\n+      if (!BrotliSafeReadBits(br, 1, &bits)) {\n+        s->substate_context_map = BROTLI_STATE_CONTEXT_MAP_TRANSFORM;\n+        return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+      }\n+      if (bits != 0) {\n+        InverseMoveToFrontTransform(*context_map_arg, context_map_size, s);\n+      }\n+      s->substate_context_map = BROTLI_STATE_CONTEXT_MAP_NONE;\n+      return BROTLI_DECODER_SUCCESS;\n+    }\n+\n+    default:\n+      return\n+          BROTLI_FAILURE(BROTLI_DECODER_ERROR_UNREACHABLE);\n+  }\n+}\n+\n+/* Decodes a command or literal and updates block type ring-buffer.\n+   Reads 3..54 bits. */\n+static BROTLI_INLINE BROTLI_BOOL DecodeBlockTypeAndLength(\n+    int safe, BrotliDecoderState* s, int tree_type) {\n+  uint32_t max_block_type = s->num_block_types[tree_type];\n+  const HuffmanCode* type_tree = &s->block_type_trees[\n+      tree_type * BROTLI_HUFFMAN_MAX_SIZE_258];\n+  const HuffmanCode* len_tree = &s->block_len_trees[\n+      tree_type * BROTLI_HUFFMAN_MAX_SIZE_26];\n+  BrotliBitReader* br = &s->br;\n+  uint32_t* ringbuffer = &s->block_type_rb[tree_type * 2];\n+  uint32_t block_type;\n+  if (max_block_type <= 1) {\n+    return BROTLI_FALSE;\n+  }\n+\n+  /* Read 0..15 + 3..39 bits. */\n+  if (!safe) {\n+    block_type = ReadSymbol(type_tree, br);\n+    s->block_length[tree_type] = ReadBlockLength(len_tree, br);\n+  } else {\n+    BrotliBitReaderState memento;\n+    BrotliBitReaderSaveState(br, &memento);\n+    if (!SafeReadSymbol(type_tree, br, &block_type)) return BROTLI_FALSE;\n+    if (!SafeReadBlockLength(s, &s->block_length[tree_type], len_tree, br)) {\n+      s->substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_NONE;\n+      BrotliBitReaderRestoreState(br, &memento);\n+      return BROTLI_FALSE;\n+    }\n+  }\n+\n+  if (block_type == 1) {\n+    block_type = ringbuffer[1] + 1;\n+  } else if (block_type == 0) {\n+    block_type = ringbuffer[0];\n+  } else {\n+    block_type -= 2;\n+  }\n+  if (block_type >= max_block_type) {\n+    block_type -= max_block_type;\n+  }\n+  ringbuffer[0] = ringbuffer[1];\n+  ringbuffer[1] = block_type;\n+  return BROTLI_TRUE;\n+}\n+\n+static BROTLI_INLINE void DetectTrivialLiteralBlockTypes(\n+    BrotliDecoderState* s) {\n+  size_t i;\n+  for (i = 0; i < 8; ++i) s->trivial_literal_contexts[i] = 0;\n+  for (i = 0; i < s->num_block_types[0]; i++) {\n+    size_t offset = i << BROTLI_LITERAL_CONTEXT_BITS;\n+    size_t error = 0;\n+    size_t sample = s->context_map[offset];\n+    size_t j;\n+    for (j = 0; j < (1u << BROTLI_LITERAL_CONTEXT_BITS);) {\n+      BROTLI_REPEAT(4, error |= s->context_map[offset + j++] ^ sample;)\n+    }\n+    if (error == 0) {\n+      s->trivial_literal_contexts[i >> 5] |= 1u << (i & 31);\n+    }\n+  }\n+}\n+\n+static BROTLI_INLINE void PrepareLiteralDecoding(BrotliDecoderState* s) {\n+  uint8_t context_mode;\n+  size_t trivial;\n+  uint32_t block_type = s->block_type_rb[1];\n+  uint32_t context_offset = block_type << BROTLI_LITERAL_CONTEXT_BITS;\n+  s->context_map_slice = s->context_map + context_offset;\n+  trivial = s->trivial_literal_contexts[block_type >> 5];\n+  s->trivial_literal_context = (trivial >> (block_type & 31)) & 1;\n+  s->literal_htree = s->literal_hgroup.htrees[s->context_map_slice[0]];\n+  context_mode = s->context_modes[block_type] & 3;\n+  s->context_lookup = BROTLI_CONTEXT_LUT(context_mode);\n+}\n+\n+/* Decodes the block type and updates the state for literal context.\n+   Reads 3..54 bits. */\n+static BROTLI_INLINE BROTLI_BOOL DecodeLiteralBlockSwitchInternal(\n+    int safe, BrotliDecoderState* s) {\n+  if (!DecodeBlockTypeAndLength(safe, s, 0)) {\n+    return BROTLI_FALSE;\n+  }\n+  PrepareLiteralDecoding(s);\n+  return BROTLI_TRUE;\n+}\n+\n+static void BROTLI_NOINLINE DecodeLiteralBlockSwitch(BrotliDecoderState* s) {\n+  DecodeLiteralBlockSwitchInternal(0, s);\n+}\n+\n+static BROTLI_BOOL BROTLI_NOINLINE SafeDecodeLiteralBlockSwitch(\n+    BrotliDecoderState* s) {\n+  return DecodeLiteralBlockSwitchInternal(1, s);\n+}\n+\n+/* Block switch for insert/copy length.\n+   Reads 3..54 bits. */\n+static BROTLI_INLINE BROTLI_BOOL DecodeCommandBlockSwitchInternal(\n+    int safe, BrotliDecoderState* s) {\n+  if (!DecodeBlockTypeAndLength(safe, s, 1)) {\n+    return BROTLI_FALSE;\n+  }\n+  s->htree_command = s->insert_copy_hgroup.htrees[s->block_type_rb[3]];\n+  return BROTLI_TRUE;\n+}\n+\n+static void BROTLI_NOINLINE DecodeCommandBlockSwitch(BrotliDecoderState* s) {\n+  DecodeCommandBlockSwitchInternal(0, s);\n+}\n+\n+static BROTLI_BOOL BROTLI_NOINLINE SafeDecodeCommandBlockSwitch(\n+    BrotliDecoderState* s) {\n+  return DecodeCommandBlockSwitchInternal(1, s);\n+}\n+\n+/* Block switch for distance codes.\n+   Reads 3..54 bits. */\n+static BROTLI_INLINE BROTLI_BOOL DecodeDistanceBlockSwitchInternal(\n+    int safe, BrotliDecoderState* s) {\n+  if (!DecodeBlockTypeAndLength(safe, s, 2)) {\n+    return BROTLI_FALSE;\n+  }\n+  s->dist_context_map_slice = s->dist_context_map +\n+      (s->block_type_rb[5] << BROTLI_DISTANCE_CONTEXT_BITS);\n+  s->dist_htree_index = s->dist_context_map_slice[s->distance_context];\n+  return BROTLI_TRUE;\n+}\n+\n+static void BROTLI_NOINLINE DecodeDistanceBlockSwitch(BrotliDecoderState* s) {\n+  DecodeDistanceBlockSwitchInternal(0, s);\n+}\n+\n+static BROTLI_BOOL BROTLI_NOINLINE SafeDecodeDistanceBlockSwitch(\n+    BrotliDecoderState* s) {\n+  return DecodeDistanceBlockSwitchInternal(1, s);\n+}\n+\n+static size_t UnwrittenBytes(const BrotliDecoderState* s, BROTLI_BOOL wrap) {\n+  size_t pos = wrap && s->pos > s->ringbuffer_size ?\n+      (size_t)s->ringbuffer_size : (size_t)(s->pos);\n+  size_t partial_pos_rb = (s->rb_roundtrips * (size_t)s->ringbuffer_size) + pos;\n+  return partial_pos_rb - s->partial_pos_out;\n+}\n+\n+/* Dumps output.\n+   Returns BROTLI_DECODER_NEEDS_MORE_OUTPUT only if there is more output to push\n+   and either ring-buffer is as big as window size, or |force| is true. */\n+static BrotliDecoderErrorCode BROTLI_NOINLINE WriteRingBuffer(\n+    BrotliDecoderState* s, size_t* available_out, uint8_t** next_out,\n+    size_t* total_out, BROTLI_BOOL force) {\n+  uint8_t* start =\n+      s->ringbuffer + (s->partial_pos_out & (size_t)s->ringbuffer_mask);\n+  size_t to_write = UnwrittenBytes(s, BROTLI_TRUE);\n+  size_t num_written = *available_out;\n+  if (num_written > to_write) {\n+    num_written = to_write;\n+  }\n+  if (s->meta_block_remaining_len < 0) {\n+    return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1);\n+  }\n+  if (next_out && !*next_out) {\n+    *next_out = start;\n+  } else {\n+    if (next_out) {\n+      memcpy(*next_out, start, num_written);\n+      *next_out += num_written;\n+    }\n+  }\n+  *available_out -= num_written;\n+  BROTLI_LOG_UINT(to_write);\n+  BROTLI_LOG_UINT(num_written);\n+  s->partial_pos_out += num_written;\n+  if (total_out) {\n+    *total_out = s->partial_pos_out;\n+  }\n+  if (num_written < to_write) {\n+    if (s->ringbuffer_size == (1 << s->window_bits) || force) {\n+      return BROTLI_DECODER_NEEDS_MORE_OUTPUT;\n+    } else {\n+      return BROTLI_DECODER_SUCCESS;\n+    }\n+  }\n+  /* Wrap ring buffer only if it has reached its maximal size. */\n+  if (s->ringbuffer_size == (1 << s->window_bits) &&\n+      s->pos >= s->ringbuffer_size) {\n+    s->pos -= s->ringbuffer_size;\n+    s->rb_roundtrips++;\n+    s->should_wrap_ringbuffer = (size_t)s->pos != 0 ? 1 : 0;\n+  }\n+  return BROTLI_DECODER_SUCCESS;\n+}\n+\n+static void BROTLI_NOINLINE WrapRingBuffer(BrotliDecoderState* s) {\n+  if (s->should_wrap_ringbuffer) {\n+    memcpy(s->ringbuffer, s->ringbuffer_end, (size_t)s->pos);\n+    s->should_wrap_ringbuffer = 0;\n+  }\n+}\n+\n+/* Allocates ring-buffer.\n+\n+   s->ringbuffer_size MUST be updated by BrotliCalculateRingBufferSize before\n+   this function is called.\n+\n+   Last two bytes of ring-buffer are initialized to 0, so context calculation\n+   could be done uniformly for the first two and all other positions. */\n+static BROTLI_BOOL BROTLI_NOINLINE BrotliEnsureRingBuffer(\n+    BrotliDecoderState* s) {\n+  uint8_t* old_ringbuffer = s->ringbuffer;\n+  if (s->ringbuffer_size == s->new_ringbuffer_size) {\n+    return BROTLI_TRUE;\n+  }\n+\n+  s->ringbuffer = (uint8_t*)BROTLI_DECODER_ALLOC(s,\n+      (size_t)(s->new_ringbuffer_size) + kRingBufferWriteAheadSlack);\n+  if (s->ringbuffer == 0) {\n+    /* Restore previous value. */\n+    s->ringbuffer = old_ringbuffer;\n+    return BROTLI_FALSE;\n+  }\n+  s->ringbuffer[s->new_ringbuffer_size - 2] = 0;\n+  s->ringbuffer[s->new_ringbuffer_size - 1] = 0;\n+\n+  if (!!old_ringbuffer) {\n+    memcpy(s->ringbuffer, old_ringbuffer, (size_t)s->pos);\n+    BROTLI_DECODER_FREE(s, old_ringbuffer);\n+  }\n+\n+  s->ringbuffer_size = s->new_ringbuffer_size;\n+  s->ringbuffer_mask = s->new_ringbuffer_size - 1;\n+  s->ringbuffer_end = s->ringbuffer + s->ringbuffer_size;\n+\n+  return BROTLI_TRUE;\n+}\n+\n+static BrotliDecoderErrorCode BROTLI_NOINLINE CopyUncompressedBlockToOutput(\n+    size_t* available_out, uint8_t** next_out, size_t* total_out,\n+    BrotliDecoderState* s) {\n+  /* TODO: avoid allocation for single uncompressed block. */\n+  if (!BrotliEnsureRingBuffer(s)) {\n+    return BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1);\n+  }\n+\n+  /* State machine */\n+  for (;;) {\n+    switch (s->substate_uncompressed) {\n+      case BROTLI_STATE_UNCOMPRESSED_NONE: {\n+        int nbytes = (int)BrotliGetRemainingBytes(&s->br);\n+        if (nbytes > s->meta_block_remaining_len) {\n+          nbytes = s->meta_block_remaining_len;\n+        }\n+        if (s->pos + nbytes > s->ringbuffer_size) {\n+          nbytes = s->ringbuffer_size - s->pos;\n+        }\n+        /* Copy remaining bytes from s->br.buf_ to ring-buffer. */\n+        BrotliCopyBytes(&s->ringbuffer[s->pos], &s->br, (size_t)nbytes);\n+        s->pos += nbytes;\n+        s->meta_block_remaining_len -= nbytes;\n+        if (s->pos < 1 << s->window_bits) {\n+          if (s->meta_block_remaining_len == 0) {\n+            return BROTLI_DECODER_SUCCESS;\n+          }\n+          return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        }\n+        s->substate_uncompressed = BROTLI_STATE_UNCOMPRESSED_WRITE;\n+      }\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_UNCOMPRESSED_WRITE: {\n+        BrotliDecoderErrorCode result;\n+        result = WriteRingBuffer(\n+            s, available_out, next_out, total_out, BROTLI_FALSE);\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          return result;\n+        }\n+        if (s->ringbuffer_size == 1 << s->window_bits) {\n+          s->max_distance = s->max_backward_distance;\n+        }\n+        s->substate_uncompressed = BROTLI_STATE_UNCOMPRESSED_NONE;\n+        break;\n+      }\n+    }\n+  }\n+  BROTLI_DCHECK(0);  /* Unreachable */\n+}\n+\n+/* Calculates the smallest feasible ring buffer.\n+\n+   If we know the data size is small, do not allocate more ring buffer\n+   size than needed to reduce memory usage.\n+\n+   When this method is called, metablock size and flags MUST be decoded. */\n+static void BROTLI_NOINLINE BrotliCalculateRingBufferSize(\n+    BrotliDecoderState* s) {\n+  int window_size = 1 << s->window_bits;\n+  int new_ringbuffer_size = window_size;\n+  /* We need at least 2 bytes of ring buffer size to get the last two\n+     bytes for context from there */\n+  int min_size = s->ringbuffer_size ? s->ringbuffer_size : 1024;\n+  int output_size;\n+\n+  /* If maximum is already reached, no further extension is retired. */\n+  if (s->ringbuffer_size == window_size) {\n+    return;\n+  }\n+\n+  /* Metadata blocks does not touch ring buffer. */\n+  if (s->is_metadata) {\n+    return;\n+  }\n+\n+  if (!s->ringbuffer) {\n+    output_size = 0;\n+  } else {\n+    output_size = s->pos;\n+  }\n+  output_size += s->meta_block_remaining_len;\n+  min_size = min_size < output_size ? output_size : min_size;\n+\n+  if (!!s->canny_ringbuffer_allocation) {\n+    /* Reduce ring buffer size to save memory when server is unscrupulous.\n+       In worst case memory usage might be 1.5x bigger for a short period of\n+       ring buffer reallocation. */\n+    while ((new_ringbuffer_size >> 1) >= min_size) {\n+      new_ringbuffer_size >>= 1;\n+    }\n+  }\n+\n+  s->new_ringbuffer_size = new_ringbuffer_size;\n+}\n+\n+/* Reads 1..256 2-bit context modes. */\n+static BrotliDecoderErrorCode ReadContextModes(BrotliDecoderState* s) {\n+  BrotliBitReader* br = &s->br;\n+  int i = s->loop_counter;\n+\n+  while (i < (int)s->num_block_types[0]) {\n+    uint32_t bits;\n+    if (!BrotliSafeReadBits(br, 2, &bits)) {\n+      s->loop_counter = i;\n+      return BROTLI_DECODER_NEEDS_MORE_INPUT;\n+    }\n+    s->context_modes[i] = (uint8_t)bits;\n+    BROTLI_LOG_ARRAY_INDEX(s->context_modes, i);\n+    i++;\n+  }\n+  return BROTLI_DECODER_SUCCESS;\n+}\n+\n+static BROTLI_INLINE void TakeDistanceFromRingBuffer(BrotliDecoderState* s) {\n+  if (s->distance_code == 0) {\n+    --s->dist_rb_idx;\n+    s->distance_code = s->dist_rb[s->dist_rb_idx & 3];\n+    /* Compensate double distance-ring-buffer roll for dictionary items. */\n+    s->distance_context = 1;\n+  } else {\n+    int distance_code = s->distance_code << 1;\n+    /* kDistanceShortCodeIndexOffset has 2-bit values from LSB:\n+        3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2 */\n+    const uint32_t kDistanceShortCodeIndexOffset = 0xAAAFFF1B;\n+    /* kDistanceShortCodeValueOffset has 2-bit values from LSB:\n+       -0, 0,-0, 0,-1, 1,-2, 2,-3, 3,-1, 1,-2, 2,-3, 3 */\n+    const uint32_t kDistanceShortCodeValueOffset = 0xFA5FA500;\n+    int v = (s->dist_rb_idx +\n+        (int)(kDistanceShortCodeIndexOffset >> distance_code)) & 0x3;\n+    s->distance_code = s->dist_rb[v];\n+    v = (int)(kDistanceShortCodeValueOffset >> distance_code) & 0x3;\n+    if ((distance_code & 0x3) != 0) {\n+      s->distance_code += v;\n+    } else {\n+      s->distance_code -= v;\n+      if (s->distance_code <= 0) {\n+        /* A huge distance will cause a BROTLI_FAILURE() soon.\n+           This is a little faster than failing here. */\n+        s->distance_code = 0x7FFFFFFF;\n+      }\n+    }\n+  }\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL SafeReadBits(\n+    BrotliBitReader* const br, uint32_t n_bits, uint32_t* val) {\n+  if (n_bits != 0) {\n+    return BrotliSafeReadBits(br, n_bits, val);\n+  } else {\n+    *val = 0;\n+    return BROTLI_TRUE;\n+  }\n+}\n+\n+/* Precondition: s->distance_code < 0. */\n+static BROTLI_INLINE BROTLI_BOOL ReadDistanceInternal(\n+    int safe, BrotliDecoderState* s, BrotliBitReader* br) {\n+  int distval;\n+  BrotliBitReaderState memento;\n+  HuffmanCode* distance_tree = s->distance_hgroup.htrees[s->dist_htree_index];\n+  if (!safe) {\n+    s->distance_code = (int)ReadSymbol(distance_tree, br);\n+  } else {\n+    uint32_t code;\n+    BrotliBitReaderSaveState(br, &memento);\n+    if (!SafeReadSymbol(distance_tree, br, &code)) {\n+      return BROTLI_FALSE;\n+    }\n+    s->distance_code = (int)code;\n+  }\n+  /* Convert the distance code to the actual distance by possibly\n+     looking up past distances from the s->ringbuffer. */\n+  s->distance_context = 0;\n+  if ((s->distance_code & ~0xF) == 0) {\n+    TakeDistanceFromRingBuffer(s);\n+    --s->block_length[2];\n+    return BROTLI_TRUE;\n+  }\n+  distval = s->distance_code - (int)s->num_direct_distance_codes;\n+  if (distval >= 0) {\n+    uint32_t nbits;\n+    int postfix;\n+    int offset;\n+    if (!safe && (s->distance_postfix_bits == 0)) {\n+      nbits = ((uint32_t)distval >> 1) + 1;\n+      offset = ((2 + (distval & 1)) << nbits) - 4;\n+      s->distance_code = (int)s->num_direct_distance_codes + offset +\n+                         (int)BrotliReadBits(br, nbits);\n+    } else {\n+      /* This branch also works well when s->distance_postfix_bits == 0. */\n+      uint32_t bits;\n+      postfix = distval & s->distance_postfix_mask;\n+      distval >>= s->distance_postfix_bits;\n+      nbits = ((uint32_t)distval >> 1) + 1;\n+      if (safe) {\n+        if (!SafeReadBits(br, nbits, &bits)) {\n+          s->distance_code = -1;  /* Restore precondition. */\n+          BrotliBitReaderRestoreState(br, &memento);\n+          return BROTLI_FALSE;\n+        }\n+      } else {\n+        bits = BrotliReadBits(br, nbits);\n+      }\n+      offset = ((2 + (distval & 1)) << nbits) - 4;\n+      s->distance_code = (int)s->num_direct_distance_codes +\n+          ((offset + (int)bits) << s->distance_postfix_bits) + postfix;\n+    }\n+  }\n+  s->distance_code = s->distance_code - BROTLI_NUM_DISTANCE_SHORT_CODES + 1;\n+  --s->block_length[2];\n+  return BROTLI_TRUE;\n+}\n+\n+static BROTLI_INLINE void ReadDistance(\n+    BrotliDecoderState* s, BrotliBitReader* br) {\n+  ReadDistanceInternal(0, s, br);\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL SafeReadDistance(\n+    BrotliDecoderState* s, BrotliBitReader* br) {\n+  return ReadDistanceInternal(1, s, br);\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL ReadCommandInternal(\n+    int safe, BrotliDecoderState* s, BrotliBitReader* br, int* insert_length) {\n+  uint32_t cmd_code;\n+  uint32_t insert_len_extra = 0;\n+  uint32_t copy_length;\n+  CmdLutElement v;\n+  BrotliBitReaderState memento;\n+  if (!safe) {\n+    cmd_code = ReadSymbol(s->htree_command, br);\n+  } else {\n+    BrotliBitReaderSaveState(br, &memento);\n+    if (!SafeReadSymbol(s->htree_command, br, &cmd_code)) {\n+      return BROTLI_FALSE;\n+    }\n+  }\n+  v = kCmdLut[cmd_code];\n+  s->distance_code = v.distance_code;\n+  s->distance_context = v.context;\n+  s->dist_htree_index = s->dist_context_map_slice[s->distance_context];\n+  *insert_length = v.insert_len_offset;\n+  if (!safe) {\n+    if (BROTLI_PREDICT_FALSE(v.insert_len_extra_bits != 0)) {\n+      insert_len_extra = BrotliReadBits(br, v.insert_len_extra_bits);\n+    }\n+    copy_length = BrotliReadBits(br, v.copy_len_extra_bits);\n+  } else {\n+    if (!SafeReadBits(br, v.insert_len_extra_bits, &insert_len_extra) ||\n+        !SafeReadBits(br, v.copy_len_extra_bits, &copy_length)) {\n+      BrotliBitReaderRestoreState(br, &memento);\n+      return BROTLI_FALSE;\n+    }\n+  }\n+  s->copy_length = (int)copy_length + v.copy_len_offset;\n+  --s->block_length[1];\n+  *insert_length += (int)insert_len_extra;\n+  return BROTLI_TRUE;\n+}\n+\n+static BROTLI_INLINE void ReadCommand(\n+    BrotliDecoderState* s, BrotliBitReader* br, int* insert_length) {\n+  ReadCommandInternal(0, s, br, insert_length);\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL SafeReadCommand(\n+    BrotliDecoderState* s, BrotliBitReader* br, int* insert_length) {\n+  return ReadCommandInternal(1, s, br, insert_length);\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL CheckInputAmount(\n+    int safe, BrotliBitReader* const br, size_t num) {\n+  if (safe) {\n+    return BROTLI_TRUE;\n+  }\n+  return BrotliCheckInputAmount(br, num);\n+}\n+\n+#define BROTLI_SAFE(METHOD)                       \\\n+  {                                               \\\n+    if (safe) {                                   \\\n+      if (!Safe##METHOD) {                        \\\n+        result = BROTLI_DECODER_NEEDS_MORE_INPUT; \\\n+        goto saveStateAndReturn;                  \\\n+      }                                           \\\n+    } else {                                      \\\n+      METHOD;                                     \\\n+    }                                             \\\n+  }\n+\n+static BROTLI_INLINE BrotliDecoderErrorCode ProcessCommandsInternal(\n+    int safe, BrotliDecoderState* s) {\n+  int pos = s->pos;\n+  int i = s->loop_counter;\n+  BrotliDecoderErrorCode result = BROTLI_DECODER_SUCCESS;\n+  BrotliBitReader* br = &s->br;\n+\n+  if (!CheckInputAmount(safe, br, 28)) {\n+    result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+    goto saveStateAndReturn;\n+  }\n+  if (!safe) {\n+    BROTLI_UNUSED(BrotliWarmupBitReader(br));\n+  }\n+\n+  /* Jump into state machine. */\n+  if (s->state == BROTLI_STATE_COMMAND_BEGIN) {\n+    goto CommandBegin;\n+  } else if (s->state == BROTLI_STATE_COMMAND_INNER) {\n+    goto CommandInner;\n+  } else if (s->state == BROTLI_STATE_COMMAND_POST_DECODE_LITERALS) {\n+    goto CommandPostDecodeLiterals;\n+  } else if (s->state == BROTLI_STATE_COMMAND_POST_WRAP_COPY) {\n+    goto CommandPostWrapCopy;\n+  } else {\n+    return BROTLI_FAILURE(BROTLI_DECODER_ERROR_UNREACHABLE);\n+  }\n+\n+CommandBegin:\n+  if (safe) {\n+    s->state = BROTLI_STATE_COMMAND_BEGIN;\n+  }\n+  if (!CheckInputAmount(safe, br, 28)) {  /* 156 bits + 7 bytes */\n+    s->state = BROTLI_STATE_COMMAND_BEGIN;\n+    result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+    goto saveStateAndReturn;\n+  }\n+  if (BROTLI_PREDICT_FALSE(s->block_length[1] == 0)) {\n+    BROTLI_SAFE(DecodeCommandBlockSwitch(s));\n+    goto CommandBegin;\n+  }\n+  /* Read the insert/copy length in the command. */\n+  BROTLI_SAFE(ReadCommand(s, br, &i));\n+  BROTLI_LOG((\"[ProcessCommandsInternal] pos = %d insert = %d copy = %d\\n\",\n+              pos, i, s->copy_length));\n+  if (i == 0) {\n+    goto CommandPostDecodeLiterals;\n+  }\n+  s->meta_block_remaining_len -= i;\n+\n+CommandInner:\n+  if (safe) {\n+    s->state = BROTLI_STATE_COMMAND_INNER;\n+  }\n+  /* Read the literals in the command. */\n+  if (s->trivial_literal_context) {\n+    uint32_t bits;\n+    uint32_t value;\n+    PreloadSymbol(safe, s->literal_htree, br, &bits, &value);\n+    do {\n+      if (!CheckInputAmount(safe, br, 28)) {  /* 162 bits + 7 bytes */\n+        s->state = BROTLI_STATE_COMMAND_INNER;\n+        result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        goto saveStateAndReturn;\n+      }\n+      if (BROTLI_PREDICT_FALSE(s->block_length[0] == 0)) {\n+        BROTLI_SAFE(DecodeLiteralBlockSwitch(s));\n+        PreloadSymbol(safe, s->literal_htree, br, &bits, &value);\n+        if (!s->trivial_literal_context) goto CommandInner;\n+      }\n+      if (!safe) {\n+        s->ringbuffer[pos] =\n+            (uint8_t)ReadPreloadedSymbol(s->literal_htree, br, &bits, &value);\n+      } else {\n+        uint32_t literal;\n+        if (!SafeReadSymbol(s->literal_htree, br, &literal)) {\n+          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          goto saveStateAndReturn;\n+        }\n+        s->ringbuffer[pos] = (uint8_t)literal;\n+      }\n+      --s->block_length[0];\n+      BROTLI_LOG_ARRAY_INDEX(s->ringbuffer, pos);\n+      ++pos;\n+      if (BROTLI_PREDICT_FALSE(pos == s->ringbuffer_size)) {\n+        s->state = BROTLI_STATE_COMMAND_INNER_WRITE;\n+        --i;\n+        goto saveStateAndReturn;\n+      }\n+    } while (--i != 0);\n+  } else {\n+    uint8_t p1 = s->ringbuffer[(pos - 1) & s->ringbuffer_mask];\n+    uint8_t p2 = s->ringbuffer[(pos - 2) & s->ringbuffer_mask];\n+    do {\n+      const HuffmanCode* hc;\n+      uint8_t context;\n+      if (!CheckInputAmount(safe, br, 28)) {  /* 162 bits + 7 bytes */\n+        s->state = BROTLI_STATE_COMMAND_INNER;\n+        result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+        goto saveStateAndReturn;\n+      }\n+      if (BROTLI_PREDICT_FALSE(s->block_length[0] == 0)) {\n+        BROTLI_SAFE(DecodeLiteralBlockSwitch(s));\n+        if (s->trivial_literal_context) goto CommandInner;\n+      }\n+      context = BROTLI_CONTEXT(p1, p2, s->context_lookup);\n+      BROTLI_LOG_UINT(context);\n+      hc = s->literal_hgroup.htrees[s->context_map_slice[context]];\n+      p2 = p1;\n+      if (!safe) {\n+        p1 = (uint8_t)ReadSymbol(hc, br);\n+      } else {\n+        uint32_t literal;\n+        if (!SafeReadSymbol(hc, br, &literal)) {\n+          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          goto saveStateAndReturn;\n+        }\n+        p1 = (uint8_t)literal;\n+      }\n+      s->ringbuffer[pos] = p1;\n+      --s->block_length[0];\n+      BROTLI_LOG_UINT(s->context_map_slice[context]);\n+      BROTLI_LOG_ARRAY_INDEX(s->ringbuffer, pos & s->ringbuffer_mask);\n+      ++pos;\n+      if (BROTLI_PREDICT_FALSE(pos == s->ringbuffer_size)) {\n+        s->state = BROTLI_STATE_COMMAND_INNER_WRITE;\n+        --i;\n+        goto saveStateAndReturn;\n+      }\n+    } while (--i != 0);\n+  }\n+  BROTLI_LOG_UINT(s->meta_block_remaining_len);\n+  if (BROTLI_PREDICT_FALSE(s->meta_block_remaining_len <= 0)) {\n+    s->state = BROTLI_STATE_METABLOCK_DONE;\n+    goto saveStateAndReturn;\n+  }\n+\n+CommandPostDecodeLiterals:\n+  if (safe) {\n+    s->state = BROTLI_STATE_COMMAND_POST_DECODE_LITERALS;\n+  }\n+  if (s->distance_code >= 0) {\n+    /* Implicit distance case. */\n+    s->distance_context = s->distance_code ? 0 : 1;\n+    --s->dist_rb_idx;\n+    s->distance_code = s->dist_rb[s->dist_rb_idx & 3];\n+  } else {\n+    /* Read distance code in the command, unless it was implicitly zero. */\n+    if (BROTLI_PREDICT_FALSE(s->block_length[2] == 0)) {\n+      BROTLI_SAFE(DecodeDistanceBlockSwitch(s));\n+    }\n+    BROTLI_SAFE(ReadDistance(s, br));\n+  }\n+  BROTLI_LOG((\"[ProcessCommandsInternal] pos = %d distance = %d\\n\",\n+              pos, s->distance_code));\n+  if (s->max_distance != s->max_backward_distance) {\n+    s->max_distance =\n+        (pos < s->max_backward_distance) ? pos : s->max_backward_distance;\n+  }\n+  i = s->copy_length;\n+  /* Apply copy of LZ77 back-reference, or static dictionary reference if\n+     the distance is larger than the max LZ77 distance */\n+  if (s->distance_code > s->max_distance) {\n+    /* The maximum allowed distance is BROTLI_MAX_ALLOWED_DISTANCE = 0x7FFFFFFC.\n+       With this choice, no signed overflow can occur after decoding\n+       a special distance code (e.g., after adding 3 to the last distance). */\n+    if (s->distance_code > BROTLI_MAX_ALLOWED_DISTANCE) {\n+      BROTLI_LOG((\"Invalid backward reference. pos: %d distance: %d \"\n+          \"len: %d bytes left: %d\\n\",\n+          pos, s->distance_code, i, s->meta_block_remaining_len));\n+      return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_DISTANCE);\n+    }\n+    if (i >= BROTLI_MIN_DICTIONARY_WORD_LENGTH &&\n+        i <= BROTLI_MAX_DICTIONARY_WORD_LENGTH) {\n+      int address = s->distance_code - s->max_distance - 1;\n+      const BrotliDictionary* words = s->dictionary;\n+      const BrotliTransforms* transforms = s->transforms;\n+      int offset = (int)s->dictionary->offsets_by_length[i];\n+      uint32_t shift = s->dictionary->size_bits_by_length[i];\n+\n+      int mask = (int)BitMask(shift);\n+      int word_idx = address & mask;\n+      int transform_idx = address >> shift;\n+      /* Compensate double distance-ring-buffer roll. */\n+      s->dist_rb_idx += s->distance_context;\n+      offset += word_idx * i;\n+      if (BROTLI_PREDICT_FALSE(!words->data)) {\n+        return BROTLI_FAILURE(BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET);\n+      }\n+      if (transform_idx < (int)transforms->num_transforms) {\n+        const uint8_t* word = &words->data[offset];\n+        int len = i;\n+        if (transform_idx == transforms->cutOffTransforms[0]) {\n+          memcpy(&s->ringbuffer[pos], word, (size_t)len);\n+          BROTLI_LOG((\"[ProcessCommandsInternal] dictionary word: [%.*s]\\n\",\n+                      len, word));\n+        } else {\n+          len = BrotliTransformDictionaryWord(&s->ringbuffer[pos], word, len,\n+              transforms, transform_idx);\n+          BROTLI_LOG((\"[ProcessCommandsInternal] dictionary word: [%.*s],\"\n+                      \" transform_idx = %d, transformed: [%.*s]\\n\",\n+                      i, word, transform_idx, len, &s->ringbuffer[pos]));\n+        }\n+        pos += len;\n+        s->meta_block_remaining_len -= len;\n+        if (pos >= s->ringbuffer_size) {\n+          s->state = BROTLI_STATE_COMMAND_POST_WRITE_1;\n+          goto saveStateAndReturn;\n+        }\n+      } else {\n+        BROTLI_LOG((\"Invalid backward reference. pos: %d distance: %d \"\n+            \"len: %d bytes left: %d\\n\",\n+            pos, s->distance_code, i, s->meta_block_remaining_len));\n+        return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_TRANSFORM);\n+      }\n+    } else {\n+      BROTLI_LOG((\"Invalid backward reference. pos: %d distance: %d \"\n+          \"len: %d bytes left: %d\\n\",\n+          pos, s->distance_code, i, s->meta_block_remaining_len));\n+      return BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_DICTIONARY);\n+    }\n+  } else {\n+    int src_start = (pos - s->distance_code) & s->ringbuffer_mask;\n+    uint8_t* copy_dst = &s->ringbuffer[pos];\n+    uint8_t* copy_src = &s->ringbuffer[src_start];\n+    int dst_end = pos + i;\n+    int src_end = src_start + i;\n+    /* Update the recent distances cache. */\n+    s->dist_rb[s->dist_rb_idx & 3] = s->distance_code;\n+    ++s->dist_rb_idx;\n+    s->meta_block_remaining_len -= i;\n+    /* There are 32+ bytes of slack in the ring-buffer allocation.\n+       Also, we have 16 short codes, that make these 16 bytes irrelevant\n+       in the ring-buffer. Let's copy over them as a first guess. */\n+    memmove16(copy_dst, copy_src);\n+    if (src_end > pos && dst_end > src_start) {\n+      /* Regions intersect. */\n+      goto CommandPostWrapCopy;\n+    }\n+    if (dst_end >= s->ringbuffer_size || src_end >= s->ringbuffer_size) {\n+      /* At least one region wraps. */\n+      goto CommandPostWrapCopy;\n+    }\n+    pos += i;\n+    if (i > 16) {\n+      if (i > 32) {\n+        memcpy(copy_dst + 16, copy_src + 16, (size_t)(i - 16));\n+      } else {\n+        /* This branch covers about 45% cases.\n+           Fixed size short copy allows more compiler optimizations. */\n+        memmove16(copy_dst + 16, copy_src + 16);\n+      }\n+    }\n+  }\n+  BROTLI_LOG_UINT(s->meta_block_remaining_len);\n+  if (s->meta_block_remaining_len <= 0) {\n+    /* Next metablock, if any. */\n+    s->state = BROTLI_STATE_METABLOCK_DONE;\n+    goto saveStateAndReturn;\n+  } else {\n+    goto CommandBegin;\n+  }\n+CommandPostWrapCopy:\n+  {\n+    int wrap_guard = s->ringbuffer_size - pos;\n+    while (--i >= 0) {\n+      s->ringbuffer[pos] =\n+          s->ringbuffer[(pos - s->distance_code) & s->ringbuffer_mask];\n+      ++pos;\n+      if (BROTLI_PREDICT_FALSE(--wrap_guard == 0)) {\n+        s->state = BROTLI_STATE_COMMAND_POST_WRITE_2;\n+        goto saveStateAndReturn;\n+      }\n+    }\n+  }\n+  if (s->meta_block_remaining_len <= 0) {\n+    /* Next metablock, if any. */\n+    s->state = BROTLI_STATE_METABLOCK_DONE;\n+    goto saveStateAndReturn;\n+  } else {\n+    goto CommandBegin;\n+  }\n+\n+saveStateAndReturn:\n+  s->pos = pos;\n+  s->loop_counter = i;\n+  return result;\n+}\n+\n+#undef BROTLI_SAFE\n+\n+static BROTLI_NOINLINE BrotliDecoderErrorCode ProcessCommands(\n+    BrotliDecoderState* s) {\n+  return ProcessCommandsInternal(0, s);\n+}\n+\n+static BROTLI_NOINLINE BrotliDecoderErrorCode SafeProcessCommands(\n+    BrotliDecoderState* s) {\n+  return ProcessCommandsInternal(1, s);\n+}\n+\n+/* Returns the maximum number of distance symbols which can only represent\n+   distances not exceeding BROTLI_MAX_ALLOWED_DISTANCE. */\n+static uint32_t BrotliMaxDistanceSymbol(uint32_t ndirect, uint32_t npostfix) {\n+  static const uint32_t bound[BROTLI_MAX_NPOSTFIX + 1] = {0, 4, 12, 28};\n+  static const uint32_t diff[BROTLI_MAX_NPOSTFIX + 1] = {73, 126, 228, 424};\n+  uint32_t postfix = 1U << npostfix;\n+  if (ndirect < bound[npostfix]) {\n+    return ndirect + diff[npostfix] + postfix;\n+  } else if (ndirect > bound[npostfix] + postfix) {\n+    return ndirect + diff[npostfix];\n+  } else {\n+    return bound[npostfix] + diff[npostfix] + postfix;\n+  }\n+}\n+\n+BrotliDecoderResult BrotliDecoderDecompress(\n+    size_t encoded_size, const uint8_t* encoded_buffer, size_t* decoded_size,\n+    uint8_t* decoded_buffer) {\n+  BrotliDecoderState s;\n+  BrotliDecoderResult result;\n+  size_t total_out = 0;\n+  size_t available_in = encoded_size;\n+  const uint8_t* next_in = encoded_buffer;\n+  size_t available_out = *decoded_size;\n+  uint8_t* next_out = decoded_buffer;\n+  if (!BrotliDecoderStateInit(&s, 0, 0, 0)) {\n+    return BROTLI_DECODER_RESULT_ERROR;\n+  }\n+  result = BrotliDecoderDecompressStream(\n+      &s, &available_in, &next_in, &available_out, &next_out, &total_out);\n+  *decoded_size = total_out;\n+  BrotliDecoderStateCleanup(&s);\n+  if (result != BROTLI_DECODER_RESULT_SUCCESS) {\n+    result = BROTLI_DECODER_RESULT_ERROR;\n+  }\n+  return result;\n+}\n+\n+/* Invariant: input stream is never overconsumed:\n+    - invalid input implies that the whole stream is invalid -> any amount of\n+      input could be read and discarded\n+    - when result is \"needs more input\", then at least one more byte is REQUIRED\n+      to complete decoding; all input data MUST be consumed by decoder, so\n+      client could swap the input buffer\n+    - when result is \"needs more output\" decoder MUST ensure that it doesn't\n+      hold more than 7 bits in bit reader; this saves client from swapping input\n+      buffer ahead of time\n+    - when result is \"success\" decoder MUST return all unused data back to input\n+      buffer; this is possible because the invariant is held on enter */\n+BrotliDecoderResult BrotliDecoderDecompressStream(\n+    BrotliDecoderState* s, size_t* available_in, const uint8_t** next_in,\n+    size_t* available_out, uint8_t** next_out, size_t* total_out) {\n+  BrotliDecoderErrorCode result = BROTLI_DECODER_SUCCESS;\n+  BrotliBitReader* br = &s->br;\n+  /* Ensure that |total_out| is set, even if no data will ever be pushed out. */\n+  if (total_out) {\n+    *total_out = s->partial_pos_out;\n+  }\n+  /* Do not try to process further in a case of unrecoverable error. */\n+  if ((int)s->error_code < 0) {\n+    return BROTLI_DECODER_RESULT_ERROR;\n+  }\n+  if (*available_out && (!next_out || !*next_out)) {\n+    return SaveErrorCode(\n+        s, BROTLI_FAILURE(BROTLI_DECODER_ERROR_INVALID_ARGUMENTS));\n+  }\n+  if (!*available_out) next_out = 0;\n+  if (s->buffer_length == 0) {  /* Just connect bit reader to input stream. */\n+    br->avail_in = *available_in;\n+    br->next_in = *next_in;\n+  } else {\n+    /* At least one byte of input is required. More than one byte of input may\n+       be required to complete the transaction -> reading more data must be\n+       done in a loop -> do it in a main loop. */\n+    result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+    br->next_in = &s->buffer.u8[0];\n+  }\n+  /* State machine */\n+  for (;;) {\n+    if (result != BROTLI_DECODER_SUCCESS) {\n+      /* Error, needs more input/output. */\n+      if (result == BROTLI_DECODER_NEEDS_MORE_INPUT) {\n+        if (s->ringbuffer != 0) {  /* Pro-actively push output. */\n+          BrotliDecoderErrorCode intermediate_result = WriteRingBuffer(s,\n+              available_out, next_out, total_out, BROTLI_TRUE);\n+          /* WriteRingBuffer checks s->meta_block_remaining_len validity. */\n+          if ((int)intermediate_result < 0) {\n+            result = intermediate_result;\n+            break;\n+          }\n+        }\n+        if (s->buffer_length != 0) {  /* Used with internal buffer. */\n+          if (br->avail_in == 0) {\n+            /* Successfully finished read transaction.\n+               Accumulator contains less than 8 bits, because internal buffer\n+               is expanded byte-by-byte until it is enough to complete read. */\n+            s->buffer_length = 0;\n+            /* Switch to input stream and restart. */\n+            result = BROTLI_DECODER_SUCCESS;\n+            br->avail_in = *available_in;\n+            br->next_in = *next_in;\n+            continue;\n+          } else if (*available_in != 0) {\n+            /* Not enough data in buffer, but can take one more byte from\n+               input stream. */\n+            result = BROTLI_DECODER_SUCCESS;\n+            s->buffer.u8[s->buffer_length] = **next_in;\n+            s->buffer_length++;\n+            br->avail_in = s->buffer_length;\n+            (*next_in)++;\n+            (*available_in)--;\n+            /* Retry with more data in buffer. */\n+            continue;\n+          }\n+          /* Can't finish reading and no more input. */\n+          break;\n+        } else {  /* Input stream doesn't contain enough input. */\n+          /* Copy tail to internal buffer and return. */\n+          *next_in = br->next_in;\n+          *available_in = br->avail_in;\n+          while (*available_in) {\n+            s->buffer.u8[s->buffer_length] = **next_in;\n+            s->buffer_length++;\n+            (*next_in)++;\n+            (*available_in)--;\n+          }\n+          break;\n+        }\n+        /* Unreachable. */\n+      }\n+\n+      /* Fail or needs more output. */\n+\n+      if (s->buffer_length != 0) {\n+        /* Just consumed the buffered input and produced some output. Otherwise\n+           it would result in \"needs more input\". Reset internal buffer. */\n+        s->buffer_length = 0;\n+      } else {\n+        /* Using input stream in last iteration. When decoder switches to input\n+           stream it has less than 8 bits in accumulator, so it is safe to\n+           return unused accumulator bits there. */\n+        BrotliBitReaderUnload(br);\n+        *available_in = br->avail_in;\n+        *next_in = br->next_in;\n+      }\n+      break;\n+    }\n+    switch (s->state) {\n+      case BROTLI_STATE_UNINITED:\n+        /* Prepare to the first read. */\n+        if (!BrotliWarmupBitReader(br)) {\n+          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          break;\n+        }\n+        /* Decode window size. */\n+        result = DecodeWindowBits(s, br);  /* Reads 1..8 bits. */\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          break;\n+        }\n+        if (s->large_window) {\n+          s->state = BROTLI_STATE_LARGE_WINDOW_BITS;\n+          break;\n+        }\n+        s->state = BROTLI_STATE_INITIALIZE;\n+        break;\n+\n+      case BROTLI_STATE_LARGE_WINDOW_BITS:\n+        if (!BrotliSafeReadBits(br, 6, &s->window_bits)) {\n+          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          break;\n+        }\n+        if (s->window_bits < BROTLI_LARGE_MIN_WBITS ||\n+            s->window_bits > BROTLI_LARGE_MAX_WBITS) {\n+          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS);\n+          break;\n+        }\n+        s->state = BROTLI_STATE_INITIALIZE;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_INITIALIZE:\n+        BROTLI_LOG_UINT(s->window_bits);\n+        /* Maximum distance, see section 9.1. of the spec. */\n+        s->max_backward_distance = (1 << s->window_bits) - BROTLI_WINDOW_GAP;\n+\n+        /* Allocate memory for both block_type_trees and block_len_trees. */\n+        s->block_type_trees = (HuffmanCode*)BROTLI_DECODER_ALLOC(s,\n+            sizeof(HuffmanCode) * 3 *\n+                (BROTLI_HUFFMAN_MAX_SIZE_258 + BROTLI_HUFFMAN_MAX_SIZE_26));\n+        if (s->block_type_trees == 0) {\n+          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES);\n+          break;\n+        }\n+        s->block_len_trees =\n+            s->block_type_trees + 3 * BROTLI_HUFFMAN_MAX_SIZE_258;\n+\n+        s->state = BROTLI_STATE_METABLOCK_BEGIN;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_METABLOCK_BEGIN:\n+        BrotliDecoderStateMetablockBegin(s);\n+        BROTLI_LOG_UINT(s->pos);\n+        s->state = BROTLI_STATE_METABLOCK_HEADER;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_METABLOCK_HEADER:\n+        result = DecodeMetaBlockLength(s, br);  /* Reads 2 - 31 bits. */\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          break;\n+        }\n+        BROTLI_LOG_UINT(s->is_last_metablock);\n+        BROTLI_LOG_UINT(s->meta_block_remaining_len);\n+        BROTLI_LOG_UINT(s->is_metadata);\n+        BROTLI_LOG_UINT(s->is_uncompressed);\n+        if (s->is_metadata || s->is_uncompressed) {\n+          if (!BrotliJumpToByteBoundary(br)) {\n+            result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_PADDING_1);\n+            break;\n+          }\n+        }\n+        if (s->is_metadata) {\n+          s->state = BROTLI_STATE_METADATA;\n+          break;\n+        }\n+        if (s->meta_block_remaining_len == 0) {\n+          s->state = BROTLI_STATE_METABLOCK_DONE;\n+          break;\n+        }\n+        BrotliCalculateRingBufferSize(s);\n+        if (s->is_uncompressed) {\n+          s->state = BROTLI_STATE_UNCOMPRESSED;\n+          break;\n+        }\n+        s->loop_counter = 0;\n+        s->state = BROTLI_STATE_HUFFMAN_CODE_0;\n+        break;\n+\n+      case BROTLI_STATE_UNCOMPRESSED: {\n+        result = CopyUncompressedBlockToOutput(\n+            available_out, next_out, total_out, s);\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          break;\n+        }\n+        s->state = BROTLI_STATE_METABLOCK_DONE;\n+        break;\n+      }\n+\n+      case BROTLI_STATE_METADATA:\n+        for (; s->meta_block_remaining_len > 0; --s->meta_block_remaining_len) {\n+          uint32_t bits;\n+          /* Read one byte and ignore it. */\n+          if (!BrotliSafeReadBits(br, 8, &bits)) {\n+            result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+            break;\n+          }\n+        }\n+        if (result == BROTLI_DECODER_SUCCESS) {\n+          s->state = BROTLI_STATE_METABLOCK_DONE;\n+        }\n+        break;\n+\n+      case BROTLI_STATE_HUFFMAN_CODE_0:\n+        if (s->loop_counter >= 3) {\n+          s->state = BROTLI_STATE_METABLOCK_HEADER_2;\n+          break;\n+        }\n+        /* Reads 1..11 bits. */\n+        result = DecodeVarLenUint8(s, br, &s->num_block_types[s->loop_counter]);\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          break;\n+        }\n+        s->num_block_types[s->loop_counter]++;\n+        BROTLI_LOG_UINT(s->num_block_types[s->loop_counter]);\n+        if (s->num_block_types[s->loop_counter] < 2) {\n+          s->loop_counter++;\n+          break;\n+        }\n+        s->state = BROTLI_STATE_HUFFMAN_CODE_1;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_HUFFMAN_CODE_1: {\n+        uint32_t alphabet_size = s->num_block_types[s->loop_counter] + 2;\n+        int tree_offset = s->loop_counter * BROTLI_HUFFMAN_MAX_SIZE_258;\n+        result = ReadHuffmanCode(alphabet_size, alphabet_size,\n+            &s->block_type_trees[tree_offset], NULL, s);\n+        if (result != BROTLI_DECODER_SUCCESS) break;\n+        s->state = BROTLI_STATE_HUFFMAN_CODE_2;\n+      }\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_HUFFMAN_CODE_2: {\n+        uint32_t alphabet_size = BROTLI_NUM_BLOCK_LEN_SYMBOLS;\n+        int tree_offset = s->loop_counter * BROTLI_HUFFMAN_MAX_SIZE_26;\n+        result = ReadHuffmanCode(alphabet_size, alphabet_size,\n+            &s->block_len_trees[tree_offset], NULL, s);\n+        if (result != BROTLI_DECODER_SUCCESS) break;\n+        s->state = BROTLI_STATE_HUFFMAN_CODE_3;\n+      }\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_HUFFMAN_CODE_3: {\n+        int tree_offset = s->loop_counter * BROTLI_HUFFMAN_MAX_SIZE_26;\n+        if (!SafeReadBlockLength(s, &s->block_length[s->loop_counter],\n+            &s->block_len_trees[tree_offset], br)) {\n+          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          break;\n+        }\n+        BROTLI_LOG_UINT(s->block_length[s->loop_counter]);\n+        s->loop_counter++;\n+        s->state = BROTLI_STATE_HUFFMAN_CODE_0;\n+        break;\n+      }\n+\n+      case BROTLI_STATE_METABLOCK_HEADER_2: {\n+        uint32_t bits;\n+        if (!BrotliSafeReadBits(br, 6, &bits)) {\n+          result = BROTLI_DECODER_NEEDS_MORE_INPUT;\n+          break;\n+        }\n+        s->distance_postfix_bits = bits & BitMask(2);\n+        bits >>= 2;\n+        s->num_direct_distance_codes = BROTLI_NUM_DISTANCE_SHORT_CODES +\n+            (bits << s->distance_postfix_bits);\n+        BROTLI_LOG_UINT(s->num_direct_distance_codes);\n+        BROTLI_LOG_UINT(s->distance_postfix_bits);\n+        s->distance_postfix_mask = (int)BitMask(s->distance_postfix_bits);\n+        s->context_modes =\n+            (uint8_t*)BROTLI_DECODER_ALLOC(s, (size_t)s->num_block_types[0]);\n+        if (s->context_modes == 0) {\n+          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES);\n+          break;\n+        }\n+        s->loop_counter = 0;\n+        s->state = BROTLI_STATE_CONTEXT_MODES;\n+      }\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_CONTEXT_MODES:\n+        result = ReadContextModes(s);\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          break;\n+        }\n+        s->state = BROTLI_STATE_CONTEXT_MAP_1;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_CONTEXT_MAP_1:\n+        result = DecodeContextMap(\n+            s->num_block_types[0] << BROTLI_LITERAL_CONTEXT_BITS,\n+            &s->num_literal_htrees, &s->context_map, s);\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          break;\n+        }\n+        DetectTrivialLiteralBlockTypes(s);\n+        s->state = BROTLI_STATE_CONTEXT_MAP_2;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_CONTEXT_MAP_2: {\n+        uint32_t num_direct_codes =\n+            s->num_direct_distance_codes - BROTLI_NUM_DISTANCE_SHORT_CODES;\n+        uint32_t num_distance_codes = BROTLI_DISTANCE_ALPHABET_SIZE(\n+            s->distance_postfix_bits, num_direct_codes,\n+            (s->large_window ? BROTLI_LARGE_MAX_DISTANCE_BITS :\n+                               BROTLI_MAX_DISTANCE_BITS));\n+        uint32_t max_distance_symbol = (s->large_window ?\n+            BrotliMaxDistanceSymbol(\n+                num_direct_codes, s->distance_postfix_bits) :\n+            num_distance_codes);\n+        BROTLI_BOOL allocation_success = BROTLI_TRUE;\n+        result = DecodeContextMap(\n+            s->num_block_types[2] << BROTLI_DISTANCE_CONTEXT_BITS,\n+            &s->num_dist_htrees, &s->dist_context_map, s);\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          break;\n+        }\n+        allocation_success &= BrotliDecoderHuffmanTreeGroupInit(\n+            s, &s->literal_hgroup, BROTLI_NUM_LITERAL_SYMBOLS,\n+            BROTLI_NUM_LITERAL_SYMBOLS, s->num_literal_htrees);\n+        allocation_success &= BrotliDecoderHuffmanTreeGroupInit(\n+            s, &s->insert_copy_hgroup, BROTLI_NUM_COMMAND_SYMBOLS,\n+            BROTLI_NUM_COMMAND_SYMBOLS, s->num_block_types[1]);\n+        allocation_success &= BrotliDecoderHuffmanTreeGroupInit(\n+            s, &s->distance_hgroup, num_distance_codes,\n+            max_distance_symbol, s->num_dist_htrees);\n+        if (!allocation_success) {\n+          return SaveErrorCode(s,\n+              BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS));\n+        }\n+        s->loop_counter = 0;\n+        s->state = BROTLI_STATE_TREE_GROUP;\n+      }\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_TREE_GROUP: {\n+        HuffmanTreeGroup* hgroup = NULL;\n+        switch (s->loop_counter) {\n+          case 0: hgroup = &s->literal_hgroup; break;\n+          case 1: hgroup = &s->insert_copy_hgroup; break;\n+          case 2: hgroup = &s->distance_hgroup; break;\n+          default: return SaveErrorCode(s, BROTLI_FAILURE(\n+              BROTLI_DECODER_ERROR_UNREACHABLE));\n+        }\n+        result = HuffmanTreeGroupDecode(hgroup, s);\n+        if (result != BROTLI_DECODER_SUCCESS) break;\n+        s->loop_counter++;\n+        if (s->loop_counter >= 3) {\n+          PrepareLiteralDecoding(s);\n+          s->dist_context_map_slice = s->dist_context_map;\n+          s->htree_command = s->insert_copy_hgroup.htrees[0];\n+          if (!BrotliEnsureRingBuffer(s)) {\n+            result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2);\n+            break;\n+          }\n+          s->state = BROTLI_STATE_COMMAND_BEGIN;\n+        }\n+        break;\n+      }\n+\n+      case BROTLI_STATE_COMMAND_BEGIN:\n+      /* Fall through. */\n+      case BROTLI_STATE_COMMAND_INNER:\n+      /* Fall through. */\n+      case BROTLI_STATE_COMMAND_POST_DECODE_LITERALS:\n+      /* Fall through. */\n+      case BROTLI_STATE_COMMAND_POST_WRAP_COPY:\n+        result = ProcessCommands(s);\n+        if (result == BROTLI_DECODER_NEEDS_MORE_INPUT) {\n+          result = SafeProcessCommands(s);\n+        }\n+        break;\n+\n+      case BROTLI_STATE_COMMAND_INNER_WRITE:\n+      /* Fall through. */\n+      case BROTLI_STATE_COMMAND_POST_WRITE_1:\n+      /* Fall through. */\n+      case BROTLI_STATE_COMMAND_POST_WRITE_2:\n+        result = WriteRingBuffer(\n+            s, available_out, next_out, total_out, BROTLI_FALSE);\n+        if (result != BROTLI_DECODER_SUCCESS) {\n+          break;\n+        }\n+        WrapRingBuffer(s);\n+        if (s->ringbuffer_size == 1 << s->window_bits) {\n+          s->max_distance = s->max_backward_distance;\n+        }\n+        if (s->state == BROTLI_STATE_COMMAND_POST_WRITE_1) {\n+          if (s->meta_block_remaining_len == 0) {\n+            /* Next metablock, if any. */\n+            s->state = BROTLI_STATE_METABLOCK_DONE;\n+          } else {\n+            s->state = BROTLI_STATE_COMMAND_BEGIN;\n+          }\n+          break;\n+        } else if (s->state == BROTLI_STATE_COMMAND_POST_WRITE_2) {\n+          s->state = BROTLI_STATE_COMMAND_POST_WRAP_COPY;\n+        } else {  /* BROTLI_STATE_COMMAND_INNER_WRITE */\n+          if (s->loop_counter == 0) {\n+            if (s->meta_block_remaining_len == 0) {\n+              s->state = BROTLI_STATE_METABLOCK_DONE;\n+            } else {\n+              s->state = BROTLI_STATE_COMMAND_POST_DECODE_LITERALS;\n+            }\n+            break;\n+          }\n+          s->state = BROTLI_STATE_COMMAND_INNER;\n+        }\n+        break;\n+\n+      case BROTLI_STATE_METABLOCK_DONE:\n+        if (s->meta_block_remaining_len < 0) {\n+          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2);\n+          break;\n+        }\n+        BrotliDecoderStateCleanupAfterMetablock(s);\n+        if (!s->is_last_metablock) {\n+          s->state = BROTLI_STATE_METABLOCK_BEGIN;\n+          break;\n+        }\n+        if (!BrotliJumpToByteBoundary(br)) {\n+          result = BROTLI_FAILURE(BROTLI_DECODER_ERROR_FORMAT_PADDING_2);\n+          break;\n+        }\n+        if (s->buffer_length == 0) {\n+          BrotliBitReaderUnload(br);\n+          *available_in = br->avail_in;\n+          *next_in = br->next_in;\n+        }\n+        s->state = BROTLI_STATE_DONE;\n+      /* Fall through. */\n+\n+      case BROTLI_STATE_DONE:\n+        if (s->ringbuffer != 0) {\n+          result = WriteRingBuffer(\n+              s, available_out, next_out, total_out, BROTLI_TRUE);\n+          if (result != BROTLI_DECODER_SUCCESS) {\n+            break;\n+          }\n+        }\n+        return SaveErrorCode(s, result);\n+    }\n+  }\n+  return SaveErrorCode(s, result);\n+}\n+\n+BROTLI_BOOL BrotliDecoderHasMoreOutput(const BrotliDecoderState* s) {\n+  /* After unrecoverable error remaining output is considered nonsensical. */\n+  if ((int)s->error_code < 0) {\n+    return BROTLI_FALSE;\n+  }\n+  return TO_BROTLI_BOOL(\n+      s->ringbuffer != 0 && UnwrittenBytes(s, BROTLI_FALSE) != 0);\n+}\n+\n+const uint8_t* BrotliDecoderTakeOutput(BrotliDecoderState* s, size_t* size) {\n+  uint8_t* result = 0;\n+  size_t available_out = *size ? *size : 1u << 24;\n+  size_t requested_out = available_out;\n+  BrotliDecoderErrorCode status;\n+  if ((s->ringbuffer == 0) || ((int)s->error_code < 0)) {\n+    *size = 0;\n+    return 0;\n+  }\n+  WrapRingBuffer(s);\n+  status = WriteRingBuffer(s, &available_out, &result, 0, BROTLI_TRUE);\n+  /* Either WriteRingBuffer returns those \"success\" codes... */\n+  if (status == BROTLI_DECODER_SUCCESS ||\n+      status == BROTLI_DECODER_NEEDS_MORE_OUTPUT) {\n+    *size = requested_out - available_out;\n+  } else {\n+    /* ... or stream is broken. Normally this should be caught by\n+       BrotliDecoderDecompressStream, this is just a safeguard. */\n+    if ((int)status < 0) SaveErrorCode(s, status);\n+    *size = 0;\n+    result = 0;\n+  }\n+  return result;\n+}\n+\n+BROTLI_BOOL BrotliDecoderIsUsed(const BrotliDecoderState* s) {\n+  return TO_BROTLI_BOOL(s->state != BROTLI_STATE_UNINITED ||\n+      BrotliGetAvailableBits(&s->br) != 0);\n+}\n+\n+BROTLI_BOOL BrotliDecoderIsFinished(const BrotliDecoderState* s) {\n+  return TO_BROTLI_BOOL(s->state == BROTLI_STATE_DONE) &&\n+      !BrotliDecoderHasMoreOutput(s);\n+}\n+\n+BrotliDecoderErrorCode BrotliDecoderGetErrorCode(const BrotliDecoderState* s) {\n+  return (BrotliDecoderErrorCode)s->error_code;\n+}\n+\n+const char* BrotliDecoderErrorString(BrotliDecoderErrorCode c) {\n+  switch (c) {\n+#define BROTLI_ERROR_CODE_CASE_(PREFIX, NAME, CODE) \\\n+    case BROTLI_DECODER ## PREFIX ## NAME: return #NAME;\n+#define BROTLI_NOTHING_\n+    BROTLI_DECODER_ERROR_CODES_LIST(BROTLI_ERROR_CODE_CASE_, BROTLI_NOTHING_)\n+#undef BROTLI_ERROR_CODE_CASE_\n+#undef BROTLI_NOTHING_\n+    default: return \"INVALID\";\n+  }\n+}\n+\n+uint32_t BrotliDecoderVersion() {\n+  return BROTLI_VERSION;\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "30c40d33f20fe6a41a2896421d063fd72ab43f71",
            "filename": "deps/brotli/c/dec/huffman.c",
            "status": "added",
            "additions": 339,
            "deletions": 0,
            "changes": 339,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fhuffman.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fhuffman.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fdec%2Fhuffman.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,339 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Utilities for building Huffman decoding tables. */\n+\n+#include \"./huffman.h\"\n+\n+#include <string.h>  /* memcpy, memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define BROTLI_REVERSE_BITS_MAX 8\n+\n+#if defined(BROTLI_RBIT)\n+#define BROTLI_REVERSE_BITS_BASE \\\n+  ((sizeof(brotli_reg_t) << 3) - BROTLI_REVERSE_BITS_MAX)\n+#else\n+#define BROTLI_REVERSE_BITS_BASE 0\n+static uint8_t kReverseBits[1 << BROTLI_REVERSE_BITS_MAX] = {\n+  0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,\n+  0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,\n+  0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,\n+  0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,\n+  0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,\n+  0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,\n+  0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,\n+  0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,\n+  0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,\n+  0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,\n+  0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,\n+  0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,\n+  0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,\n+  0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,\n+  0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,\n+  0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,\n+  0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,\n+  0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,\n+  0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,\n+  0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,\n+  0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,\n+  0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,\n+  0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,\n+  0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,\n+  0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,\n+  0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,\n+  0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,\n+  0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,\n+  0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,\n+  0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,\n+  0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,\n+  0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF\n+};\n+#endif  /* BROTLI_RBIT */\n+\n+#define BROTLI_REVERSE_BITS_LOWEST \\\n+  ((brotli_reg_t)1 << (BROTLI_REVERSE_BITS_MAX - 1 + BROTLI_REVERSE_BITS_BASE))\n+\n+/* Returns reverse(num >> BROTLI_REVERSE_BITS_BASE, BROTLI_REVERSE_BITS_MAX),\n+   where reverse(value, len) is the bit-wise reversal of the len least\n+   significant bits of value. */\n+static BROTLI_INLINE brotli_reg_t BrotliReverseBits(brotli_reg_t num) {\n+#if defined(BROTLI_RBIT)\n+  return BROTLI_RBIT(num);\n+#else\n+  return kReverseBits[num];\n+#endif\n+}\n+\n+/* Stores code in table[0], table[step], table[2*step], ..., table[end] */\n+/* Assumes that end is an integer multiple of step */\n+static BROTLI_INLINE void ReplicateValue(HuffmanCode* table,\n+                                         int step, int end,\n+                                         HuffmanCode code) {\n+  do {\n+    end -= step;\n+    table[end] = code;\n+  } while (end > 0);\n+}\n+\n+/* Returns the table width of the next 2nd level table. |count| is the histogram\n+   of bit lengths for the remaining symbols, |len| is the code length of the\n+   next processed symbol. */\n+static BROTLI_INLINE int NextTableBitSize(const uint16_t* const count,\n+                                          int len, int root_bits) {\n+  int left = 1 << (len - root_bits);\n+  while (len < BROTLI_HUFFMAN_MAX_CODE_LENGTH) {\n+    left -= count[len];\n+    if (left <= 0) break;\n+    ++len;\n+    left <<= 1;\n+  }\n+  return len - root_bits;\n+}\n+\n+void BrotliBuildCodeLengthsHuffmanTable(HuffmanCode* table,\n+                                        const uint8_t* const code_lengths,\n+                                        uint16_t* count) {\n+  HuffmanCode code;       /* current table entry */\n+  int symbol;             /* symbol index in original or sorted table */\n+  brotli_reg_t key;       /* prefix code */\n+  brotli_reg_t key_step;  /* prefix code addend */\n+  int step;               /* step size to replicate values in current table */\n+  int table_size;         /* size of current table */\n+  int sorted[BROTLI_CODE_LENGTH_CODES];  /* symbols sorted by code length */\n+  /* offsets in sorted table for each length */\n+  int offset[BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH + 1];\n+  int bits;\n+  int bits_count;\n+  BROTLI_DCHECK(BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH <=\n+                BROTLI_REVERSE_BITS_MAX);\n+\n+  /* Generate offsets into sorted symbol table by code length. */\n+  symbol = -1;\n+  bits = 1;\n+  BROTLI_REPEAT(BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH, {\n+    symbol += count[bits];\n+    offset[bits] = symbol;\n+    bits++;\n+  });\n+  /* Symbols with code length 0 are placed after all other symbols. */\n+  offset[0] = BROTLI_CODE_LENGTH_CODES - 1;\n+\n+  /* Sort symbols by length, by symbol order within each length. */\n+  symbol = BROTLI_CODE_LENGTH_CODES;\n+  do {\n+    BROTLI_REPEAT(6, {\n+      symbol--;\n+      sorted[offset[code_lengths[symbol]]--] = symbol;\n+    });\n+  } while (symbol != 0);\n+\n+  table_size = 1 << BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH;\n+\n+  /* Special case: all symbols but one have 0 code length. */\n+  if (offset[0] == 0) {\n+    code = ConstructHuffmanCode(0, (uint16_t)sorted[0]);\n+    for (key = 0; key < (brotli_reg_t)table_size; ++key) {\n+      table[key] = code;\n+    }\n+    return;\n+  }\n+\n+  /* Fill in table. */\n+  key = 0;\n+  key_step = BROTLI_REVERSE_BITS_LOWEST;\n+  symbol = 0;\n+  bits = 1;\n+  step = 2;\n+  do {\n+    for (bits_count = count[bits]; bits_count != 0; --bits_count) {\n+      code = ConstructHuffmanCode((uint8_t)bits, (uint16_t)sorted[symbol++]);\n+      ReplicateValue(&table[BrotliReverseBits(key)], step, table_size, code);\n+      key += key_step;\n+    }\n+    step <<= 1;\n+    key_step >>= 1;\n+  } while (++bits <= BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH);\n+}\n+\n+uint32_t BrotliBuildHuffmanTable(HuffmanCode* root_table,\n+                                 int root_bits,\n+                                 const uint16_t* const symbol_lists,\n+                                 uint16_t* count) {\n+  HuffmanCode code;       /* current table entry */\n+  HuffmanCode* table;     /* next available space in table */\n+  int len;                /* current code length */\n+  int symbol;             /* symbol index in original or sorted table */\n+  brotli_reg_t key;       /* prefix code */\n+  brotli_reg_t key_step;  /* prefix code addend */\n+  brotli_reg_t sub_key;   /* 2nd level table prefix code */\n+  brotli_reg_t sub_key_step;  /* 2nd level table prefix code addend */\n+  int step;               /* step size to replicate values in current table */\n+  int table_bits;         /* key length of current table */\n+  int table_size;         /* size of current table */\n+  int total_size;         /* sum of root table size and 2nd level table sizes */\n+  int max_length = -1;\n+  int bits;\n+  int bits_count;\n+\n+  BROTLI_DCHECK(root_bits <= BROTLI_REVERSE_BITS_MAX);\n+  BROTLI_DCHECK(BROTLI_HUFFMAN_MAX_CODE_LENGTH - root_bits <=\n+                BROTLI_REVERSE_BITS_MAX);\n+\n+  while (symbol_lists[max_length] == 0xFFFF) max_length--;\n+  max_length += BROTLI_HUFFMAN_MAX_CODE_LENGTH + 1;\n+\n+  table = root_table;\n+  table_bits = root_bits;\n+  table_size = 1 << table_bits;\n+  total_size = table_size;\n+\n+  /* Fill in the root table. Reduce the table size to if possible,\n+     and create the repetitions by memcpy. */\n+  if (table_bits > max_length) {\n+    table_bits = max_length;\n+    table_size = 1 << table_bits;\n+  }\n+  key = 0;\n+  key_step = BROTLI_REVERSE_BITS_LOWEST;\n+  bits = 1;\n+  step = 2;\n+  do {\n+    symbol = bits - (BROTLI_HUFFMAN_MAX_CODE_LENGTH + 1);\n+    for (bits_count = count[bits]; bits_count != 0; --bits_count) {\n+      symbol = symbol_lists[symbol];\n+      code = ConstructHuffmanCode((uint8_t)bits, (uint16_t)symbol);\n+      ReplicateValue(&table[BrotliReverseBits(key)], step, table_size, code);\n+      key += key_step;\n+    }\n+    step <<= 1;\n+    key_step >>= 1;\n+  } while (++bits <= table_bits);\n+\n+  /* If root_bits != table_bits then replicate to fill the remaining slots. */\n+  while (total_size != table_size) {\n+    memcpy(&table[table_size], &table[0],\n+           (size_t)table_size * sizeof(table[0]));\n+    table_size <<= 1;\n+  }\n+\n+  /* Fill in 2nd level tables and add pointers to root table. */\n+  key_step = BROTLI_REVERSE_BITS_LOWEST >> (root_bits - 1);\n+  sub_key = (BROTLI_REVERSE_BITS_LOWEST << 1);\n+  sub_key_step = BROTLI_REVERSE_BITS_LOWEST;\n+  for (len = root_bits + 1, step = 2; len <= max_length; ++len) {\n+    symbol = len - (BROTLI_HUFFMAN_MAX_CODE_LENGTH + 1);\n+    for (; count[len] != 0; --count[len]) {\n+      if (sub_key == (BROTLI_REVERSE_BITS_LOWEST << 1U)) {\n+        table += table_size;\n+        table_bits = NextTableBitSize(count, len, root_bits);\n+        table_size = 1 << table_bits;\n+        total_size += table_size;\n+        sub_key = BrotliReverseBits(key);\n+        key += key_step;\n+        root_table[sub_key] = ConstructHuffmanCode(\n+            (uint8_t)(table_bits + root_bits),\n+            (uint16_t)(((size_t)(table - root_table)) - sub_key));\n+        sub_key = 0;\n+      }\n+      symbol = symbol_lists[symbol];\n+      code = ConstructHuffmanCode((uint8_t)(len - root_bits), (uint16_t)symbol);\n+      ReplicateValue(\n+          &table[BrotliReverseBits(sub_key)], step, table_size, code);\n+      sub_key += sub_key_step;\n+    }\n+    step <<= 1;\n+    sub_key_step >>= 1;\n+  }\n+  return (uint32_t)total_size;\n+}\n+\n+uint32_t BrotliBuildSimpleHuffmanTable(HuffmanCode* table,\n+                                       int root_bits,\n+                                       uint16_t* val,\n+                                       uint32_t num_symbols) {\n+  uint32_t table_size = 1;\n+  const uint32_t goal_size = 1U << root_bits;\n+  switch (num_symbols) {\n+    case 0:\n+      table[0] = ConstructHuffmanCode(0, val[0]);\n+      break;\n+    case 1:\n+      if (val[1] > val[0]) {\n+        table[0] = ConstructHuffmanCode(1, val[0]);\n+        table[1] = ConstructHuffmanCode(1, val[1]);\n+      } else {\n+        table[0] = ConstructHuffmanCode(1, val[1]);\n+        table[1] = ConstructHuffmanCode(1, val[0]);\n+      }\n+      table_size = 2;\n+      break;\n+    case 2:\n+      table[0] = ConstructHuffmanCode(1, val[0]);\n+      table[2] = ConstructHuffmanCode(1, val[0]);\n+      if (val[2] > val[1]) {\n+        table[1] = ConstructHuffmanCode(2, val[1]);\n+        table[3] = ConstructHuffmanCode(2, val[2]);\n+      } else {\n+        table[1] = ConstructHuffmanCode(2, val[2]);\n+        table[3] = ConstructHuffmanCode(2, val[1]);\n+      }\n+      table_size = 4;\n+      break;\n+    case 3: {\n+      int i, k;\n+      for (i = 0; i < 3; ++i) {\n+        for (k = i + 1; k < 4; ++k) {\n+          if (val[k] < val[i]) {\n+            uint16_t t = val[k];\n+            val[k] = val[i];\n+            val[i] = t;\n+          }\n+        }\n+      }\n+      table[0] = ConstructHuffmanCode(2, val[0]);\n+      table[2] = ConstructHuffmanCode(2, val[1]);\n+      table[1] = ConstructHuffmanCode(2, val[2]);\n+      table[3] = ConstructHuffmanCode(2, val[3]);\n+      table_size = 4;\n+      break;\n+    }\n+    case 4: {\n+      if (val[3] < val[2]) {\n+        uint16_t t = val[3];\n+        val[3] = val[2];\n+        val[2] = t;\n+      }\n+      table[0] = ConstructHuffmanCode(1, val[0]);\n+      table[1] = ConstructHuffmanCode(2, val[1]);\n+      table[2] = ConstructHuffmanCode(1, val[0]);\n+      table[3] = ConstructHuffmanCode(3, val[2]);\n+      table[4] = ConstructHuffmanCode(1, val[0]);\n+      table[5] = ConstructHuffmanCode(2, val[1]);\n+      table[6] = ConstructHuffmanCode(1, val[0]);\n+      table[7] = ConstructHuffmanCode(3, val[3]);\n+      table_size = 8;\n+      break;\n+    }\n+  }\n+  while (table_size != goal_size) {\n+    memcpy(&table[table_size], &table[0],\n+           (size_t)table_size * sizeof(table[0]));\n+    table_size <<= 1;\n+  }\n+  return goal_size;\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "b9f0716c160498c051f09c0f69716f3f9e4a9c21",
            "filename": "deps/brotli/c/dec/huffman.h",
            "status": "added",
            "additions": 127,
            "deletions": 0,
            "changes": 127,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fhuffman.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fhuffman.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fdec%2Fhuffman.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,127 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Utilities for building Huffman decoding tables. */\n+\n+#ifndef BROTLI_DEC_HUFFMAN_H_\n+#define BROTLI_DEC_HUFFMAN_H_\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define BROTLI_HUFFMAN_MAX_CODE_LENGTH 15\n+\n+/* Maximum possible Huffman table size for an alphabet size of (index * 32),\n+   max code length 15 and root table bits 8. */\n+static const uint16_t kMaxHuffmanTableSize[] = {\n+  256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758, 790, 822,\n+  854, 886, 920, 952, 984, 1016, 1048, 1080, 1112, 1144, 1176, 1208, 1240, 1272,\n+  1304, 1336, 1368, 1400, 1432, 1464, 1496, 1528};\n+/* BROTLI_NUM_BLOCK_LEN_SYMBOLS == 26 */\n+#define BROTLI_HUFFMAN_MAX_SIZE_26 396\n+/* BROTLI_MAX_BLOCK_TYPE_SYMBOLS == 258 */\n+#define BROTLI_HUFFMAN_MAX_SIZE_258 632\n+/* BROTLI_MAX_CONTEXT_MAP_SYMBOLS == 272 */\n+#define BROTLI_HUFFMAN_MAX_SIZE_272 646\n+\n+#define BROTLI_HUFFMAN_MAX_CODE_LENGTH_CODE_LENGTH 5\n+\n+#if ((defined(BROTLI_TARGET_ARMV7) || defined(BROTLI_TARGET_ARMV8_32)) && \\\n+  BROTLI_GNUC_HAS_ATTRIBUTE(aligned, 2, 7, 0))\n+#define BROTLI_HUFFMAN_CODE_FAST_LOAD\n+#endif\n+\n+#if !defined(BROTLI_HUFFMAN_CODE_FAST_LOAD)\n+/* Do not create this struct directly - use the ConstructHuffmanCode\n+ * constructor below! */\n+typedef struct {\n+  uint8_t bits;    /* number of bits used for this symbol */\n+  uint16_t value;  /* symbol value or table offset */\n+} HuffmanCode;\n+\n+static BROTLI_INLINE HuffmanCode ConstructHuffmanCode(const uint8_t bits,\n+    const uint16_t value) {\n+  HuffmanCode h;\n+  h.bits = bits;\n+  h.value = value;\n+  return h;\n+}\n+\n+/* Please use the following macros to optimize HuffmanCode accesses in hot\n+ * paths.\n+ *\n+ * For example, assuming |table| contains a HuffmanCode pointer:\n+ *\n+ *   BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(table);\n+ *   BROTLI_HC_ADJUST_TABLE_INDEX(table, index_into_table);\n+ *   *bits = BROTLI_HC_GET_BITS(table);\n+ *   *value = BROTLI_HC_GET_VALUE(table);\n+ *   BROTLI_HC_ADJUST_TABLE_INDEX(table, offset);\n+ *   *bits2 = BROTLI_HC_GET_BITS(table);\n+ *   *value2 = BROTLI_HC_GET_VALUE(table);\n+ *\n+ */\n+\n+#define BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(H)\n+#define BROTLI_HC_ADJUST_TABLE_INDEX(H, V) H += (V)\n+\n+/* These must be given a HuffmanCode pointer! */\n+#define BROTLI_HC_FAST_LOAD_BITS(H) (H->bits)\n+#define BROTLI_HC_FAST_LOAD_VALUE(H) (H->value)\n+\n+#else /* BROTLI_HUFFMAN_CODE_FAST_LOAD */\n+\n+typedef BROTLI_ALIGNED(4) uint32_t HuffmanCode;\n+\n+static BROTLI_INLINE HuffmanCode ConstructHuffmanCode(const uint8_t bits,\n+    const uint16_t value) {\n+  return ((value & 0xFFFF) << 16) | (bits & 0xFF);\n+}\n+\n+#define BROTLI_HC_MARK_TABLE_FOR_FAST_LOAD(H) uint32_t __fastload_##H = (*H)\n+#define BROTLI_HC_ADJUST_TABLE_INDEX(H, V) H += (V); __fastload_##H = (*H)\n+\n+/* These must be given a HuffmanCode pointer! */\n+#define BROTLI_HC_FAST_LOAD_BITS(H) ((__fastload_##H) & 0xFF)\n+#define BROTLI_HC_FAST_LOAD_VALUE(H) ((__fastload_##H) >> 16)\n+#endif /* BROTLI_HUFFMAN_CODE_FAST_LOAD */\n+\n+/* Builds Huffman lookup table assuming code lengths are in symbol order. */\n+BROTLI_INTERNAL void BrotliBuildCodeLengthsHuffmanTable(HuffmanCode* root_table,\n+    const uint8_t* const code_lengths, uint16_t* count);\n+\n+/* Builds Huffman lookup table assuming code lengths are in symbol order.\n+   Returns size of resulting table. */\n+BROTLI_INTERNAL uint32_t BrotliBuildHuffmanTable(HuffmanCode* root_table,\n+    int root_bits, const uint16_t* const symbol_lists, uint16_t* count_arg);\n+\n+/* Builds a simple Huffman table. The |num_symbols| parameter is to be\n+   interpreted as follows: 0 means 1 symbol, 1 means 2 symbols,\n+   2 means 3 symbols, 3 means 4 symbols with lengths [2, 2, 2, 2],\n+   4 means 4 symbols with lengths [1, 2, 3, 3]. */\n+BROTLI_INTERNAL uint32_t BrotliBuildSimpleHuffmanTable(HuffmanCode* table,\n+    int root_bits, uint16_t* symbols, uint32_t num_symbols);\n+\n+/* Contains a collection of Huffman trees with the same alphabet size. */\n+/* max_symbol is needed due to simple codes since log2(alphabet_size) could be\n+   greater than log2(max_symbol). */\n+typedef struct {\n+  HuffmanCode** htrees;\n+  HuffmanCode* codes;\n+  uint16_t alphabet_size;\n+  uint16_t max_symbol;\n+  uint16_t num_htrees;\n+} HuffmanTreeGroup;\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_DEC_HUFFMAN_H_ */"
        },
        {
            "sha": "3ea062d84a2ed6ba28cd9113e4dea56e0c775598",
            "filename": "deps/brotli/c/dec/prefix.h",
            "status": "added",
            "additions": 750,
            "deletions": 0,
            "changes": 750,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fprefix.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fprefix.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fdec%2Fprefix.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,750 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Lookup tables to map prefix codes to value ranges. This is used during\n+   decoding of the block lengths, literal insertion lengths and copy lengths. */\n+\n+#ifndef BROTLI_DEC_PREFIX_H_\n+#define BROTLI_DEC_PREFIX_H_\n+\n+#include \"../common/constants.h\"\n+#include <brotli/types.h>\n+\n+/* Represents the range of values belonging to a prefix code:\n+   [offset, offset + 2^nbits) */\n+struct PrefixCodeRange {\n+  uint16_t offset;\n+  uint8_t nbits;\n+};\n+\n+static const struct PrefixCodeRange\n+    kBlockLengthPrefixCode[BROTLI_NUM_BLOCK_LEN_SYMBOLS] = {\n+  {   1,  2}, {    5,  2}, {  9,   2}, {  13,  2},\n+  {  17,  3}, {   25,  3}, {  33,  3}, {  41,  3},\n+  {  49,  4}, {   65,  4}, {  81,  4}, {  97,  4},\n+  { 113,  5}, {  145,  5}, { 177,  5}, { 209,  5},\n+  { 241,  6}, {  305,  6}, { 369,  7}, { 497,  8},\n+  { 753,  9}, { 1265, 10}, {2289, 11}, {4337, 12},\n+  {8433, 13}, {16625, 24}\n+};\n+\n+typedef struct CmdLutElement {\n+  uint8_t insert_len_extra_bits;\n+  uint8_t copy_len_extra_bits;\n+  int8_t distance_code;\n+  uint8_t context;\n+  uint16_t insert_len_offset;\n+  uint16_t copy_len_offset;\n+} CmdLutElement;\n+\n+static const CmdLutElement kCmdLut[BROTLI_NUM_COMMAND_SYMBOLS] = {\n+  { 0x00, 0x00, 0, 0x00, 0x0000, 0x0002 },\n+  { 0x00, 0x00, 0, 0x01, 0x0000, 0x0003 },\n+  { 0x00, 0x00, 0, 0x02, 0x0000, 0x0004 },\n+  { 0x00, 0x00, 0, 0x03, 0x0000, 0x0005 },\n+  { 0x00, 0x00, 0, 0x03, 0x0000, 0x0006 },\n+  { 0x00, 0x00, 0, 0x03, 0x0000, 0x0007 },\n+  { 0x00, 0x00, 0, 0x03, 0x0000, 0x0008 },\n+  { 0x00, 0x00, 0, 0x03, 0x0000, 0x0009 },\n+  { 0x00, 0x00, 0, 0x00, 0x0001, 0x0002 },\n+  { 0x00, 0x00, 0, 0x01, 0x0001, 0x0003 },\n+  { 0x00, 0x00, 0, 0x02, 0x0001, 0x0004 },\n+  { 0x00, 0x00, 0, 0x03, 0x0001, 0x0005 },\n+  { 0x00, 0x00, 0, 0x03, 0x0001, 0x0006 },\n+  { 0x00, 0x00, 0, 0x03, 0x0001, 0x0007 },\n+  { 0x00, 0x00, 0, 0x03, 0x0001, 0x0008 },\n+  { 0x00, 0x00, 0, 0x03, 0x0001, 0x0009 },\n+  { 0x00, 0x00, 0, 0x00, 0x0002, 0x0002 },\n+  { 0x00, 0x00, 0, 0x01, 0x0002, 0x0003 },\n+  { 0x00, 0x00, 0, 0x02, 0x0002, 0x0004 },\n+  { 0x00, 0x00, 0, 0x03, 0x0002, 0x0005 },\n+  { 0x00, 0x00, 0, 0x03, 0x0002, 0x0006 },\n+  { 0x00, 0x00, 0, 0x03, 0x0002, 0x0007 },\n+  { 0x00, 0x00, 0, 0x03, 0x0002, 0x0008 },\n+  { 0x00, 0x00, 0, 0x03, 0x0002, 0x0009 },\n+  { 0x00, 0x00, 0, 0x00, 0x0003, 0x0002 },\n+  { 0x00, 0x00, 0, 0x01, 0x0003, 0x0003 },\n+  { 0x00, 0x00, 0, 0x02, 0x0003, 0x0004 },\n+  { 0x00, 0x00, 0, 0x03, 0x0003, 0x0005 },\n+  { 0x00, 0x00, 0, 0x03, 0x0003, 0x0006 },\n+  { 0x00, 0x00, 0, 0x03, 0x0003, 0x0007 },\n+  { 0x00, 0x00, 0, 0x03, 0x0003, 0x0008 },\n+  { 0x00, 0x00, 0, 0x03, 0x0003, 0x0009 },\n+  { 0x00, 0x00, 0, 0x00, 0x0004, 0x0002 },\n+  { 0x00, 0x00, 0, 0x01, 0x0004, 0x0003 },\n+  { 0x00, 0x00, 0, 0x02, 0x0004, 0x0004 },\n+  { 0x00, 0x00, 0, 0x03, 0x0004, 0x0005 },\n+  { 0x00, 0x00, 0, 0x03, 0x0004, 0x0006 },\n+  { 0x00, 0x00, 0, 0x03, 0x0004, 0x0007 },\n+  { 0x00, 0x00, 0, 0x03, 0x0004, 0x0008 },\n+  { 0x00, 0x00, 0, 0x03, 0x0004, 0x0009 },\n+  { 0x00, 0x00, 0, 0x00, 0x0005, 0x0002 },\n+  { 0x00, 0x00, 0, 0x01, 0x0005, 0x0003 },\n+  { 0x00, 0x00, 0, 0x02, 0x0005, 0x0004 },\n+  { 0x00, 0x00, 0, 0x03, 0x0005, 0x0005 },\n+  { 0x00, 0x00, 0, 0x03, 0x0005, 0x0006 },\n+  { 0x00, 0x00, 0, 0x03, 0x0005, 0x0007 },\n+  { 0x00, 0x00, 0, 0x03, 0x0005, 0x0008 },\n+  { 0x00, 0x00, 0, 0x03, 0x0005, 0x0009 },\n+  { 0x01, 0x00, 0, 0x00, 0x0006, 0x0002 },\n+  { 0x01, 0x00, 0, 0x01, 0x0006, 0x0003 },\n+  { 0x01, 0x00, 0, 0x02, 0x0006, 0x0004 },\n+  { 0x01, 0x00, 0, 0x03, 0x0006, 0x0005 },\n+  { 0x01, 0x00, 0, 0x03, 0x0006, 0x0006 },\n+  { 0x01, 0x00, 0, 0x03, 0x0006, 0x0007 },\n+  { 0x01, 0x00, 0, 0x03, 0x0006, 0x0008 },\n+  { 0x01, 0x00, 0, 0x03, 0x0006, 0x0009 },\n+  { 0x01, 0x00, 0, 0x00, 0x0008, 0x0002 },\n+  { 0x01, 0x00, 0, 0x01, 0x0008, 0x0003 },\n+  { 0x01, 0x00, 0, 0x02, 0x0008, 0x0004 },\n+  { 0x01, 0x00, 0, 0x03, 0x0008, 0x0005 },\n+  { 0x01, 0x00, 0, 0x03, 0x0008, 0x0006 },\n+  { 0x01, 0x00, 0, 0x03, 0x0008, 0x0007 },\n+  { 0x01, 0x00, 0, 0x03, 0x0008, 0x0008 },\n+  { 0x01, 0x00, 0, 0x03, 0x0008, 0x0009 },\n+  { 0x00, 0x01, 0, 0x03, 0x0000, 0x000a },\n+  { 0x00, 0x01, 0, 0x03, 0x0000, 0x000c },\n+  { 0x00, 0x02, 0, 0x03, 0x0000, 0x000e },\n+  { 0x00, 0x02, 0, 0x03, 0x0000, 0x0012 },\n+  { 0x00, 0x03, 0, 0x03, 0x0000, 0x0016 },\n+  { 0x00, 0x03, 0, 0x03, 0x0000, 0x001e },\n+  { 0x00, 0x04, 0, 0x03, 0x0000, 0x0026 },\n+  { 0x00, 0x04, 0, 0x03, 0x0000, 0x0036 },\n+  { 0x00, 0x01, 0, 0x03, 0x0001, 0x000a },\n+  { 0x00, 0x01, 0, 0x03, 0x0001, 0x000c },\n+  { 0x00, 0x02, 0, 0x03, 0x0001, 0x000e },\n+  { 0x00, 0x02, 0, 0x03, 0x0001, 0x0012 },\n+  { 0x00, 0x03, 0, 0x03, 0x0001, 0x0016 },\n+  { 0x00, 0x03, 0, 0x03, 0x0001, 0x001e },\n+  { 0x00, 0x04, 0, 0x03, 0x0001, 0x0026 },\n+  { 0x00, 0x04, 0, 0x03, 0x0001, 0x0036 },\n+  { 0x00, 0x01, 0, 0x03, 0x0002, 0x000a },\n+  { 0x00, 0x01, 0, 0x03, 0x0002, 0x000c },\n+  { 0x00, 0x02, 0, 0x03, 0x0002, 0x000e },\n+  { 0x00, 0x02, 0, 0x03, 0x0002, 0x0012 },\n+  { 0x00, 0x03, 0, 0x03, 0x0002, 0x0016 },\n+  { 0x00, 0x03, 0, 0x03, 0x0002, 0x001e },\n+  { 0x00, 0x04, 0, 0x03, 0x0002, 0x0026 },\n+  { 0x00, 0x04, 0, 0x03, 0x0002, 0x0036 },\n+  { 0x00, 0x01, 0, 0x03, 0x0003, 0x000a },\n+  { 0x00, 0x01, 0, 0x03, 0x0003, 0x000c },\n+  { 0x00, 0x02, 0, 0x03, 0x0003, 0x000e },\n+  { 0x00, 0x02, 0, 0x03, 0x0003, 0x0012 },\n+  { 0x00, 0x03, 0, 0x03, 0x0003, 0x0016 },\n+  { 0x00, 0x03, 0, 0x03, 0x0003, 0x001e },\n+  { 0x00, 0x04, 0, 0x03, 0x0003, 0x0026 },\n+  { 0x00, 0x04, 0, 0x03, 0x0003, 0x0036 },\n+  { 0x00, 0x01, 0, 0x03, 0x0004, 0x000a },\n+  { 0x00, 0x01, 0, 0x03, 0x0004, 0x000c },\n+  { 0x00, 0x02, 0, 0x03, 0x0004, 0x000e },\n+  { 0x00, 0x02, 0, 0x03, 0x0004, 0x0012 },\n+  { 0x00, 0x03, 0, 0x03, 0x0004, 0x0016 },\n+  { 0x00, 0x03, 0, 0x03, 0x0004, 0x001e },\n+  { 0x00, 0x04, 0, 0x03, 0x0004, 0x0026 },\n+  { 0x00, 0x04, 0, 0x03, 0x0004, 0x0036 },\n+  { 0x00, 0x01, 0, 0x03, 0x0005, 0x000a },\n+  { 0x00, 0x01, 0, 0x03, 0x0005, 0x000c },\n+  { 0x00, 0x02, 0, 0x03, 0x0005, 0x000e },\n+  { 0x00, 0x02, 0, 0x03, 0x0005, 0x0012 },\n+  { 0x00, 0x03, 0, 0x03, 0x0005, 0x0016 },\n+  { 0x00, 0x03, 0, 0x03, 0x0005, 0x001e },\n+  { 0x00, 0x04, 0, 0x03, 0x0005, 0x0026 },\n+  { 0x00, 0x04, 0, 0x03, 0x0005, 0x0036 },\n+  { 0x01, 0x01, 0, 0x03, 0x0006, 0x000a },\n+  { 0x01, 0x01, 0, 0x03, 0x0006, 0x000c },\n+  { 0x01, 0x02, 0, 0x03, 0x0006, 0x000e },\n+  { 0x01, 0x02, 0, 0x03, 0x0006, 0x0012 },\n+  { 0x01, 0x03, 0, 0x03, 0x0006, 0x0016 },\n+  { 0x01, 0x03, 0, 0x03, 0x0006, 0x001e },\n+  { 0x01, 0x04, 0, 0x03, 0x0006, 0x0026 },\n+  { 0x01, 0x04, 0, 0x03, 0x0006, 0x0036 },\n+  { 0x01, 0x01, 0, 0x03, 0x0008, 0x000a },\n+  { 0x01, 0x01, 0, 0x03, 0x0008, 0x000c },\n+  { 0x01, 0x02, 0, 0x03, 0x0008, 0x000e },\n+  { 0x01, 0x02, 0, 0x03, 0x0008, 0x0012 },\n+  { 0x01, 0x03, 0, 0x03, 0x0008, 0x0016 },\n+  { 0x01, 0x03, 0, 0x03, 0x0008, 0x001e },\n+  { 0x01, 0x04, 0, 0x03, 0x0008, 0x0026 },\n+  { 0x01, 0x04, 0, 0x03, 0x0008, 0x0036 },\n+  { 0x00, 0x00, -1, 0x00, 0x0000, 0x0002 },\n+  { 0x00, 0x00, -1, 0x01, 0x0000, 0x0003 },\n+  { 0x00, 0x00, -1, 0x02, 0x0000, 0x0004 },\n+  { 0x00, 0x00, -1, 0x03, 0x0000, 0x0005 },\n+  { 0x00, 0x00, -1, 0x03, 0x0000, 0x0006 },\n+  { 0x00, 0x00, -1, 0x03, 0x0000, 0x0007 },\n+  { 0x00, 0x00, -1, 0x03, 0x0000, 0x0008 },\n+  { 0x00, 0x00, -1, 0x03, 0x0000, 0x0009 },\n+  { 0x00, 0x00, -1, 0x00, 0x0001, 0x0002 },\n+  { 0x00, 0x00, -1, 0x01, 0x0001, 0x0003 },\n+  { 0x00, 0x00, -1, 0x02, 0x0001, 0x0004 },\n+  { 0x00, 0x00, -1, 0x03, 0x0001, 0x0005 },\n+  { 0x00, 0x00, -1, 0x03, 0x0001, 0x0006 },\n+  { 0x00, 0x00, -1, 0x03, 0x0001, 0x0007 },\n+  { 0x00, 0x00, -1, 0x03, 0x0001, 0x0008 },\n+  { 0x00, 0x00, -1, 0x03, 0x0001, 0x0009 },\n+  { 0x00, 0x00, -1, 0x00, 0x0002, 0x0002 },\n+  { 0x00, 0x00, -1, 0x01, 0x0002, 0x0003 },\n+  { 0x00, 0x00, -1, 0x02, 0x0002, 0x0004 },\n+  { 0x00, 0x00, -1, 0x03, 0x0002, 0x0005 },\n+  { 0x00, 0x00, -1, 0x03, 0x0002, 0x0006 },\n+  { 0x00, 0x00, -1, 0x03, 0x0002, 0x0007 },\n+  { 0x00, 0x00, -1, 0x03, 0x0002, 0x0008 },\n+  { 0x00, 0x00, -1, 0x03, 0x0002, 0x0009 },\n+  { 0x00, 0x00, -1, 0x00, 0x0003, 0x0002 },\n+  { 0x00, 0x00, -1, 0x01, 0x0003, 0x0003 },\n+  { 0x00, 0x00, -1, 0x02, 0x0003, 0x0004 },\n+  { 0x00, 0x00, -1, 0x03, 0x0003, 0x0005 },\n+  { 0x00, 0x00, -1, 0x03, 0x0003, 0x0006 },\n+  { 0x00, 0x00, -1, 0x03, 0x0003, 0x0007 },\n+  { 0x00, 0x00, -1, 0x03, 0x0003, 0x0008 },\n+  { 0x00, 0x00, -1, 0x03, 0x0003, 0x0009 },\n+  { 0x00, 0x00, -1, 0x00, 0x0004, 0x0002 },\n+  { 0x00, 0x00, -1, 0x01, 0x0004, 0x0003 },\n+  { 0x00, 0x00, -1, 0x02, 0x0004, 0x0004 },\n+  { 0x00, 0x00, -1, 0x03, 0x0004, 0x0005 },\n+  { 0x00, 0x00, -1, 0x03, 0x0004, 0x0006 },\n+  { 0x00, 0x00, -1, 0x03, 0x0004, 0x0007 },\n+  { 0x00, 0x00, -1, 0x03, 0x0004, 0x0008 },\n+  { 0x00, 0x00, -1, 0x03, 0x0004, 0x0009 },\n+  { 0x00, 0x00, -1, 0x00, 0x0005, 0x0002 },\n+  { 0x00, 0x00, -1, 0x01, 0x0005, 0x0003 },\n+  { 0x00, 0x00, -1, 0x02, 0x0005, 0x0004 },\n+  { 0x00, 0x00, -1, 0x03, 0x0005, 0x0005 },\n+  { 0x00, 0x00, -1, 0x03, 0x0005, 0x0006 },\n+  { 0x00, 0x00, -1, 0x03, 0x0005, 0x0007 },\n+  { 0x00, 0x00, -1, 0x03, 0x0005, 0x0008 },\n+  { 0x00, 0x00, -1, 0x03, 0x0005, 0x0009 },\n+  { 0x01, 0x00, -1, 0x00, 0x0006, 0x0002 },\n+  { 0x01, 0x00, -1, 0x01, 0x0006, 0x0003 },\n+  { 0x01, 0x00, -1, 0x02, 0x0006, 0x0004 },\n+  { 0x01, 0x00, -1, 0x03, 0x0006, 0x0005 },\n+  { 0x01, 0x00, -1, 0x03, 0x0006, 0x0006 },\n+  { 0x01, 0x00, -1, 0x03, 0x0006, 0x0007 },\n+  { 0x01, 0x00, -1, 0x03, 0x0006, 0x0008 },\n+  { 0x01, 0x00, -1, 0x03, 0x0006, 0x0009 },\n+  { 0x01, 0x00, -1, 0x00, 0x0008, 0x0002 },\n+  { 0x01, 0x00, -1, 0x01, 0x0008, 0x0003 },\n+  { 0x01, 0x00, -1, 0x02, 0x0008, 0x0004 },\n+  { 0x01, 0x00, -1, 0x03, 0x0008, 0x0005 },\n+  { 0x01, 0x00, -1, 0x03, 0x0008, 0x0006 },\n+  { 0x01, 0x00, -1, 0x03, 0x0008, 0x0007 },\n+  { 0x01, 0x00, -1, 0x03, 0x0008, 0x0008 },\n+  { 0x01, 0x00, -1, 0x03, 0x0008, 0x0009 },\n+  { 0x00, 0x01, -1, 0x03, 0x0000, 0x000a },\n+  { 0x00, 0x01, -1, 0x03, 0x0000, 0x000c },\n+  { 0x00, 0x02, -1, 0x03, 0x0000, 0x000e },\n+  { 0x00, 0x02, -1, 0x03, 0x0000, 0x0012 },\n+  { 0x00, 0x03, -1, 0x03, 0x0000, 0x0016 },\n+  { 0x00, 0x03, -1, 0x03, 0x0000, 0x001e },\n+  { 0x00, 0x04, -1, 0x03, 0x0000, 0x0026 },\n+  { 0x00, 0x04, -1, 0x03, 0x0000, 0x0036 },\n+  { 0x00, 0x01, -1, 0x03, 0x0001, 0x000a },\n+  { 0x00, 0x01, -1, 0x03, 0x0001, 0x000c },\n+  { 0x00, 0x02, -1, 0x03, 0x0001, 0x000e },\n+  { 0x00, 0x02, -1, 0x03, 0x0001, 0x0012 },\n+  { 0x00, 0x03, -1, 0x03, 0x0001, 0x0016 },\n+  { 0x00, 0x03, -1, 0x03, 0x0001, 0x001e },\n+  { 0x00, 0x04, -1, 0x03, 0x0001, 0x0026 },\n+  { 0x00, 0x04, -1, 0x03, 0x0001, 0x0036 },\n+  { 0x00, 0x01, -1, 0x03, 0x0002, 0x000a },\n+  { 0x00, 0x01, -1, 0x03, 0x0002, 0x000c },\n+  { 0x00, 0x02, -1, 0x03, 0x0002, 0x000e },\n+  { 0x00, 0x02, -1, 0x03, 0x0002, 0x0012 },\n+  { 0x00, 0x03, -1, 0x03, 0x0002, 0x0016 },\n+  { 0x00, 0x03, -1, 0x03, 0x0002, 0x001e },\n+  { 0x00, 0x04, -1, 0x03, 0x0002, 0x0026 },\n+  { 0x00, 0x04, -1, 0x03, 0x0002, 0x0036 },\n+  { 0x00, 0x01, -1, 0x03, 0x0003, 0x000a },\n+  { 0x00, 0x01, -1, 0x03, 0x0003, 0x000c },\n+  { 0x00, 0x02, -1, 0x03, 0x0003, 0x000e },\n+  { 0x00, 0x02, -1, 0x03, 0x0003, 0x0012 },\n+  { 0x00, 0x03, -1, 0x03, 0x0003, 0x0016 },\n+  { 0x00, 0x03, -1, 0x03, 0x0003, 0x001e },\n+  { 0x00, 0x04, -1, 0x03, 0x0003, 0x0026 },\n+  { 0x00, 0x04, -1, 0x03, 0x0003, 0x0036 },\n+  { 0x00, 0x01, -1, 0x03, 0x0004, 0x000a },\n+  { 0x00, 0x01, -1, 0x03, 0x0004, 0x000c },\n+  { 0x00, 0x02, -1, 0x03, 0x0004, 0x000e },\n+  { 0x00, 0x02, -1, 0x03, 0x0004, 0x0012 },\n+  { 0x00, 0x03, -1, 0x03, 0x0004, 0x0016 },\n+  { 0x00, 0x03, -1, 0x03, 0x0004, 0x001e },\n+  { 0x00, 0x04, -1, 0x03, 0x0004, 0x0026 },\n+  { 0x00, 0x04, -1, 0x03, 0x0004, 0x0036 },\n+  { 0x00, 0x01, -1, 0x03, 0x0005, 0x000a },\n+  { 0x00, 0x01, -1, 0x03, 0x0005, 0x000c },\n+  { 0x00, 0x02, -1, 0x03, 0x0005, 0x000e },\n+  { 0x00, 0x02, -1, 0x03, 0x0005, 0x0012 },\n+  { 0x00, 0x03, -1, 0x03, 0x0005, 0x0016 },\n+  { 0x00, 0x03, -1, 0x03, 0x0005, 0x001e },\n+  { 0x00, 0x04, -1, 0x03, 0x0005, 0x0026 },\n+  { 0x00, 0x04, -1, 0x03, 0x0005, 0x0036 },\n+  { 0x01, 0x01, -1, 0x03, 0x0006, 0x000a },\n+  { 0x01, 0x01, -1, 0x03, 0x0006, 0x000c },\n+  { 0x01, 0x02, -1, 0x03, 0x0006, 0x000e },\n+  { 0x01, 0x02, -1, 0x03, 0x0006, 0x0012 },\n+  { 0x01, 0x03, -1, 0x03, 0x0006, 0x0016 },\n+  { 0x01, 0x03, -1, 0x03, 0x0006, 0x001e },\n+  { 0x01, 0x04, -1, 0x03, 0x0006, 0x0026 },\n+  { 0x01, 0x04, -1, 0x03, 0x0006, 0x0036 },\n+  { 0x01, 0x01, -1, 0x03, 0x0008, 0x000a },\n+  { 0x01, 0x01, -1, 0x03, 0x0008, 0x000c },\n+  { 0x01, 0x02, -1, 0x03, 0x0008, 0x000e },\n+  { 0x01, 0x02, -1, 0x03, 0x0008, 0x0012 },\n+  { 0x01, 0x03, -1, 0x03, 0x0008, 0x0016 },\n+  { 0x01, 0x03, -1, 0x03, 0x0008, 0x001e },\n+  { 0x01, 0x04, -1, 0x03, 0x0008, 0x0026 },\n+  { 0x01, 0x04, -1, 0x03, 0x0008, 0x0036 },\n+  { 0x02, 0x00, -1, 0x00, 0x000a, 0x0002 },\n+  { 0x02, 0x00, -1, 0x01, 0x000a, 0x0003 },\n+  { 0x02, 0x00, -1, 0x02, 0x000a, 0x0004 },\n+  { 0x02, 0x00, -1, 0x03, 0x000a, 0x0005 },\n+  { 0x02, 0x00, -1, 0x03, 0x000a, 0x0006 },\n+  { 0x02, 0x00, -1, 0x03, 0x000a, 0x0007 },\n+  { 0x02, 0x00, -1, 0x03, 0x000a, 0x0008 },\n+  { 0x02, 0x00, -1, 0x03, 0x000a, 0x0009 },\n+  { 0x02, 0x00, -1, 0x00, 0x000e, 0x0002 },\n+  { 0x02, 0x00, -1, 0x01, 0x000e, 0x0003 },\n+  { 0x02, 0x00, -1, 0x02, 0x000e, 0x0004 },\n+  { 0x02, 0x00, -1, 0x03, 0x000e, 0x0005 },\n+  { 0x02, 0x00, -1, 0x03, 0x000e, 0x0006 },\n+  { 0x02, 0x00, -1, 0x03, 0x000e, 0x0007 },\n+  { 0x02, 0x00, -1, 0x03, 0x000e, 0x0008 },\n+  { 0x02, 0x00, -1, 0x03, 0x000e, 0x0009 },\n+  { 0x03, 0x00, -1, 0x00, 0x0012, 0x0002 },\n+  { 0x03, 0x00, -1, 0x01, 0x0012, 0x0003 },\n+  { 0x03, 0x00, -1, 0x02, 0x0012, 0x0004 },\n+  { 0x03, 0x00, -1, 0x03, 0x0012, 0x0005 },\n+  { 0x03, 0x00, -1, 0x03, 0x0012, 0x0006 },\n+  { 0x03, 0x00, -1, 0x03, 0x0012, 0x0007 },\n+  { 0x03, 0x00, -1, 0x03, 0x0012, 0x0008 },\n+  { 0x03, 0x00, -1, 0x03, 0x0012, 0x0009 },\n+  { 0x03, 0x00, -1, 0x00, 0x001a, 0x0002 },\n+  { 0x03, 0x00, -1, 0x01, 0x001a, 0x0003 },\n+  { 0x03, 0x00, -1, 0x02, 0x001a, 0x0004 },\n+  { 0x03, 0x00, -1, 0x03, 0x001a, 0x0005 },\n+  { 0x03, 0x00, -1, 0x03, 0x001a, 0x0006 },\n+  { 0x03, 0x00, -1, 0x03, 0x001a, 0x0007 },\n+  { 0x03, 0x00, -1, 0x03, 0x001a, 0x0008 },\n+  { 0x03, 0x00, -1, 0x03, 0x001a, 0x0009 },\n+  { 0x04, 0x00, -1, 0x00, 0x0022, 0x0002 },\n+  { 0x04, 0x00, -1, 0x01, 0x0022, 0x0003 },\n+  { 0x04, 0x00, -1, 0x02, 0x0022, 0x0004 },\n+  { 0x04, 0x00, -1, 0x03, 0x0022, 0x0005 },\n+  { 0x04, 0x00, -1, 0x03, 0x0022, 0x0006 },\n+  { 0x04, 0x00, -1, 0x03, 0x0022, 0x0007 },\n+  { 0x04, 0x00, -1, 0x03, 0x0022, 0x0008 },\n+  { 0x04, 0x00, -1, 0x03, 0x0022, 0x0009 },\n+  { 0x04, 0x00, -1, 0x00, 0x0032, 0x0002 },\n+  { 0x04, 0x00, -1, 0x01, 0x0032, 0x0003 },\n+  { 0x04, 0x00, -1, 0x02, 0x0032, 0x0004 },\n+  { 0x04, 0x00, -1, 0x03, 0x0032, 0x0005 },\n+  { 0x04, 0x00, -1, 0x03, 0x0032, 0x0006 },\n+  { 0x04, 0x00, -1, 0x03, 0x0032, 0x0007 },\n+  { 0x04, 0x00, -1, 0x03, 0x0032, 0x0008 },\n+  { 0x04, 0x00, -1, 0x03, 0x0032, 0x0009 },\n+  { 0x05, 0x00, -1, 0x00, 0x0042, 0x0002 },\n+  { 0x05, 0x00, -1, 0x01, 0x0042, 0x0003 },\n+  { 0x05, 0x00, -1, 0x02, 0x0042, 0x0004 },\n+  { 0x05, 0x00, -1, 0x03, 0x0042, 0x0005 },\n+  { 0x05, 0x00, -1, 0x03, 0x0042, 0x0006 },\n+  { 0x05, 0x00, -1, 0x03, 0x0042, 0x0007 },\n+  { 0x05, 0x00, -1, 0x03, 0x0042, 0x0008 },\n+  { 0x05, 0x00, -1, 0x03, 0x0042, 0x0009 },\n+  { 0x05, 0x00, -1, 0x00, 0x0062, 0x0002 },\n+  { 0x05, 0x00, -1, 0x01, 0x0062, 0x0003 },\n+  { 0x05, 0x00, -1, 0x02, 0x0062, 0x0004 },\n+  { 0x05, 0x00, -1, 0x03, 0x0062, 0x0005 },\n+  { 0x05, 0x00, -1, 0x03, 0x0062, 0x0006 },\n+  { 0x05, 0x00, -1, 0x03, 0x0062, 0x0007 },\n+  { 0x05, 0x00, -1, 0x03, 0x0062, 0x0008 },\n+  { 0x05, 0x00, -1, 0x03, 0x0062, 0x0009 },\n+  { 0x02, 0x01, -1, 0x03, 0x000a, 0x000a },\n+  { 0x02, 0x01, -1, 0x03, 0x000a, 0x000c },\n+  { 0x02, 0x02, -1, 0x03, 0x000a, 0x000e },\n+  { 0x02, 0x02, -1, 0x03, 0x000a, 0x0012 },\n+  { 0x02, 0x03, -1, 0x03, 0x000a, 0x0016 },\n+  { 0x02, 0x03, -1, 0x03, 0x000a, 0x001e },\n+  { 0x02, 0x04, -1, 0x03, 0x000a, 0x0026 },\n+  { 0x02, 0x04, -1, 0x03, 0x000a, 0x0036 },\n+  { 0x02, 0x01, -1, 0x03, 0x000e, 0x000a },\n+  { 0x02, 0x01, -1, 0x03, 0x000e, 0x000c },\n+  { 0x02, 0x02, -1, 0x03, 0x000e, 0x000e },\n+  { 0x02, 0x02, -1, 0x03, 0x000e, 0x0012 },\n+  { 0x02, 0x03, -1, 0x03, 0x000e, 0x0016 },\n+  { 0x02, 0x03, -1, 0x03, 0x000e, 0x001e },\n+  { 0x02, 0x04, -1, 0x03, 0x000e, 0x0026 },\n+  { 0x02, 0x04, -1, 0x03, 0x000e, 0x0036 },\n+  { 0x03, 0x01, -1, 0x03, 0x0012, 0x000a },\n+  { 0x03, 0x01, -1, 0x03, 0x0012, 0x000c },\n+  { 0x03, 0x02, -1, 0x03, 0x0012, 0x000e },\n+  { 0x03, 0x02, -1, 0x03, 0x0012, 0x0012 },\n+  { 0x03, 0x03, -1, 0x03, 0x0012, 0x0016 },\n+  { 0x03, 0x03, -1, 0x03, 0x0012, 0x001e },\n+  { 0x03, 0x04, -1, 0x03, 0x0012, 0x0026 },\n+  { 0x03, 0x04, -1, 0x03, 0x0012, 0x0036 },\n+  { 0x03, 0x01, -1, 0x03, 0x001a, 0x000a },\n+  { 0x03, 0x01, -1, 0x03, 0x001a, 0x000c },\n+  { 0x03, 0x02, -1, 0x03, 0x001a, 0x000e },\n+  { 0x03, 0x02, -1, 0x03, 0x001a, 0x0012 },\n+  { 0x03, 0x03, -1, 0x03, 0x001a, 0x0016 },\n+  { 0x03, 0x03, -1, 0x03, 0x001a, 0x001e },\n+  { 0x03, 0x04, -1, 0x03, 0x001a, 0x0026 },\n+  { 0x03, 0x04, -1, 0x03, 0x001a, 0x0036 },\n+  { 0x04, 0x01, -1, 0x03, 0x0022, 0x000a },\n+  { 0x04, 0x01, -1, 0x03, 0x0022, 0x000c },\n+  { 0x04, 0x02, -1, 0x03, 0x0022, 0x000e },\n+  { 0x04, 0x02, -1, 0x03, 0x0022, 0x0012 },\n+  { 0x04, 0x03, -1, 0x03, 0x0022, 0x0016 },\n+  { 0x04, 0x03, -1, 0x03, 0x0022, 0x001e },\n+  { 0x04, 0x04, -1, 0x03, 0x0022, 0x0026 },\n+  { 0x04, 0x04, -1, 0x03, 0x0022, 0x0036 },\n+  { 0x04, 0x01, -1, 0x03, 0x0032, 0x000a },\n+  { 0x04, 0x01, -1, 0x03, 0x0032, 0x000c },\n+  { 0x04, 0x02, -1, 0x03, 0x0032, 0x000e },\n+  { 0x04, 0x02, -1, 0x03, 0x0032, 0x0012 },\n+  { 0x04, 0x03, -1, 0x03, 0x0032, 0x0016 },\n+  { 0x04, 0x03, -1, 0x03, 0x0032, 0x001e },\n+  { 0x04, 0x04, -1, 0x03, 0x0032, 0x0026 },\n+  { 0x04, 0x04, -1, 0x03, 0x0032, 0x0036 },\n+  { 0x05, 0x01, -1, 0x03, 0x0042, 0x000a },\n+  { 0x05, 0x01, -1, 0x03, 0x0042, 0x000c },\n+  { 0x05, 0x02, -1, 0x03, 0x0042, 0x000e },\n+  { 0x05, 0x02, -1, 0x03, 0x0042, 0x0012 },\n+  { 0x05, 0x03, -1, 0x03, 0x0042, 0x0016 },\n+  { 0x05, 0x03, -1, 0x03, 0x0042, 0x001e },\n+  { 0x05, 0x04, -1, 0x03, 0x0042, 0x0026 },\n+  { 0x05, 0x04, -1, 0x03, 0x0042, 0x0036 },\n+  { 0x05, 0x01, -1, 0x03, 0x0062, 0x000a },\n+  { 0x05, 0x01, -1, 0x03, 0x0062, 0x000c },\n+  { 0x05, 0x02, -1, 0x03, 0x0062, 0x000e },\n+  { 0x05, 0x02, -1, 0x03, 0x0062, 0x0012 },\n+  { 0x05, 0x03, -1, 0x03, 0x0062, 0x0016 },\n+  { 0x05, 0x03, -1, 0x03, 0x0062, 0x001e },\n+  { 0x05, 0x04, -1, 0x03, 0x0062, 0x0026 },\n+  { 0x05, 0x04, -1, 0x03, 0x0062, 0x0036 },\n+  { 0x00, 0x05, -1, 0x03, 0x0000, 0x0046 },\n+  { 0x00, 0x05, -1, 0x03, 0x0000, 0x0066 },\n+  { 0x00, 0x06, -1, 0x03, 0x0000, 0x0086 },\n+  { 0x00, 0x07, -1, 0x03, 0x0000, 0x00c6 },\n+  { 0x00, 0x08, -1, 0x03, 0x0000, 0x0146 },\n+  { 0x00, 0x09, -1, 0x03, 0x0000, 0x0246 },\n+  { 0x00, 0x0a, -1, 0x03, 0x0000, 0x0446 },\n+  { 0x00, 0x18, -1, 0x03, 0x0000, 0x0846 },\n+  { 0x00, 0x05, -1, 0x03, 0x0001, 0x0046 },\n+  { 0x00, 0x05, -1, 0x03, 0x0001, 0x0066 },\n+  { 0x00, 0x06, -1, 0x03, 0x0001, 0x0086 },\n+  { 0x00, 0x07, -1, 0x03, 0x0001, 0x00c6 },\n+  { 0x00, 0x08, -1, 0x03, 0x0001, 0x0146 },\n+  { 0x00, 0x09, -1, 0x03, 0x0001, 0x0246 },\n+  { 0x00, 0x0a, -1, 0x03, 0x0001, 0x0446 },\n+  { 0x00, 0x18, -1, 0x03, 0x0001, 0x0846 },\n+  { 0x00, 0x05, -1, 0x03, 0x0002, 0x0046 },\n+  { 0x00, 0x05, -1, 0x03, 0x0002, 0x0066 },\n+  { 0x00, 0x06, -1, 0x03, 0x0002, 0x0086 },\n+  { 0x00, 0x07, -1, 0x03, 0x0002, 0x00c6 },\n+  { 0x00, 0x08, -1, 0x03, 0x0002, 0x0146 },\n+  { 0x00, 0x09, -1, 0x03, 0x0002, 0x0246 },\n+  { 0x00, 0x0a, -1, 0x03, 0x0002, 0x0446 },\n+  { 0x00, 0x18, -1, 0x03, 0x0002, 0x0846 },\n+  { 0x00, 0x05, -1, 0x03, 0x0003, 0x0046 },\n+  { 0x00, 0x05, -1, 0x03, 0x0003, 0x0066 },\n+  { 0x00, 0x06, -1, 0x03, 0x0003, 0x0086 },\n+  { 0x00, 0x07, -1, 0x03, 0x0003, 0x00c6 },\n+  { 0x00, 0x08, -1, 0x03, 0x0003, 0x0146 },\n+  { 0x00, 0x09, -1, 0x03, 0x0003, 0x0246 },\n+  { 0x00, 0x0a, -1, 0x03, 0x0003, 0x0446 },\n+  { 0x00, 0x18, -1, 0x03, 0x0003, 0x0846 },\n+  { 0x00, 0x05, -1, 0x03, 0x0004, 0x0046 },\n+  { 0x00, 0x05, -1, 0x03, 0x0004, 0x0066 },\n+  { 0x00, 0x06, -1, 0x03, 0x0004, 0x0086 },\n+  { 0x00, 0x07, -1, 0x03, 0x0004, 0x00c6 },\n+  { 0x00, 0x08, -1, 0x03, 0x0004, 0x0146 },\n+  { 0x00, 0x09, -1, 0x03, 0x0004, 0x0246 },\n+  { 0x00, 0x0a, -1, 0x03, 0x0004, 0x0446 },\n+  { 0x00, 0x18, -1, 0x03, 0x0004, 0x0846 },\n+  { 0x00, 0x05, -1, 0x03, 0x0005, 0x0046 },\n+  { 0x00, 0x05, -1, 0x03, 0x0005, 0x0066 },\n+  { 0x00, 0x06, -1, 0x03, 0x0005, 0x0086 },\n+  { 0x00, 0x07, -1, 0x03, 0x0005, 0x00c6 },\n+  { 0x00, 0x08, -1, 0x03, 0x0005, 0x0146 },\n+  { 0x00, 0x09, -1, 0x03, 0x0005, 0x0246 },\n+  { 0x00, 0x0a, -1, 0x03, 0x0005, 0x0446 },\n+  { 0x00, 0x18, -1, 0x03, 0x0005, 0x0846 },\n+  { 0x01, 0x05, -1, 0x03, 0x0006, 0x0046 },\n+  { 0x01, 0x05, -1, 0x03, 0x0006, 0x0066 },\n+  { 0x01, 0x06, -1, 0x03, 0x0006, 0x0086 },\n+  { 0x01, 0x07, -1, 0x03, 0x0006, 0x00c6 },\n+  { 0x01, 0x08, -1, 0x03, 0x0006, 0x0146 },\n+  { 0x01, 0x09, -1, 0x03, 0x0006, 0x0246 },\n+  { 0x01, 0x0a, -1, 0x03, 0x0006, 0x0446 },\n+  { 0x01, 0x18, -1, 0x03, 0x0006, 0x0846 },\n+  { 0x01, 0x05, -1, 0x03, 0x0008, 0x0046 },\n+  { 0x01, 0x05, -1, 0x03, 0x0008, 0x0066 },\n+  { 0x01, 0x06, -1, 0x03, 0x0008, 0x0086 },\n+  { 0x01, 0x07, -1, 0x03, 0x0008, 0x00c6 },\n+  { 0x01, 0x08, -1, 0x03, 0x0008, 0x0146 },\n+  { 0x01, 0x09, -1, 0x03, 0x0008, 0x0246 },\n+  { 0x01, 0x0a, -1, 0x03, 0x0008, 0x0446 },\n+  { 0x01, 0x18, -1, 0x03, 0x0008, 0x0846 },\n+  { 0x06, 0x00, -1, 0x00, 0x0082, 0x0002 },\n+  { 0x06, 0x00, -1, 0x01, 0x0082, 0x0003 },\n+  { 0x06, 0x00, -1, 0x02, 0x0082, 0x0004 },\n+  { 0x06, 0x00, -1, 0x03, 0x0082, 0x0005 },\n+  { 0x06, 0x00, -1, 0x03, 0x0082, 0x0006 },\n+  { 0x06, 0x00, -1, 0x03, 0x0082, 0x0007 },\n+  { 0x06, 0x00, -1, 0x03, 0x0082, 0x0008 },\n+  { 0x06, 0x00, -1, 0x03, 0x0082, 0x0009 },\n+  { 0x07, 0x00, -1, 0x00, 0x00c2, 0x0002 },\n+  { 0x07, 0x00, -1, 0x01, 0x00c2, 0x0003 },\n+  { 0x07, 0x00, -1, 0x02, 0x00c2, 0x0004 },\n+  { 0x07, 0x00, -1, 0x03, 0x00c2, 0x0005 },\n+  { 0x07, 0x00, -1, 0x03, 0x00c2, 0x0006 },\n+  { 0x07, 0x00, -1, 0x03, 0x00c2, 0x0007 },\n+  { 0x07, 0x00, -1, 0x03, 0x00c2, 0x0008 },\n+  { 0x07, 0x00, -1, 0x03, 0x00c2, 0x0009 },\n+  { 0x08, 0x00, -1, 0x00, 0x0142, 0x0002 },\n+  { 0x08, 0x00, -1, 0x01, 0x0142, 0x0003 },\n+  { 0x08, 0x00, -1, 0x02, 0x0142, 0x0004 },\n+  { 0x08, 0x00, -1, 0x03, 0x0142, 0x0005 },\n+  { 0x08, 0x00, -1, 0x03, 0x0142, 0x0006 },\n+  { 0x08, 0x00, -1, 0x03, 0x0142, 0x0007 },\n+  { 0x08, 0x00, -1, 0x03, 0x0142, 0x0008 },\n+  { 0x08, 0x00, -1, 0x03, 0x0142, 0x0009 },\n+  { 0x09, 0x00, -1, 0x00, 0x0242, 0x0002 },\n+  { 0x09, 0x00, -1, 0x01, 0x0242, 0x0003 },\n+  { 0x09, 0x00, -1, 0x02, 0x0242, 0x0004 },\n+  { 0x09, 0x00, -1, 0x03, 0x0242, 0x0005 },\n+  { 0x09, 0x00, -1, 0x03, 0x0242, 0x0006 },\n+  { 0x09, 0x00, -1, 0x03, 0x0242, 0x0007 },\n+  { 0x09, 0x00, -1, 0x03, 0x0242, 0x0008 },\n+  { 0x09, 0x00, -1, 0x03, 0x0242, 0x0009 },\n+  { 0x0a, 0x00, -1, 0x00, 0x0442, 0x0002 },\n+  { 0x0a, 0x00, -1, 0x01, 0x0442, 0x0003 },\n+  { 0x0a, 0x00, -1, 0x02, 0x0442, 0x0004 },\n+  { 0x0a, 0x00, -1, 0x03, 0x0442, 0x0005 },\n+  { 0x0a, 0x00, -1, 0x03, 0x0442, 0x0006 },\n+  { 0x0a, 0x00, -1, 0x03, 0x0442, 0x0007 },\n+  { 0x0a, 0x00, -1, 0x03, 0x0442, 0x0008 },\n+  { 0x0a, 0x00, -1, 0x03, 0x0442, 0x0009 },\n+  { 0x0c, 0x00, -1, 0x00, 0x0842, 0x0002 },\n+  { 0x0c, 0x00, -1, 0x01, 0x0842, 0x0003 },\n+  { 0x0c, 0x00, -1, 0x02, 0x0842, 0x0004 },\n+  { 0x0c, 0x00, -1, 0x03, 0x0842, 0x0005 },\n+  { 0x0c, 0x00, -1, 0x03, 0x0842, 0x0006 },\n+  { 0x0c, 0x00, -1, 0x03, 0x0842, 0x0007 },\n+  { 0x0c, 0x00, -1, 0x03, 0x0842, 0x0008 },\n+  { 0x0c, 0x00, -1, 0x03, 0x0842, 0x0009 },\n+  { 0x0e, 0x00, -1, 0x00, 0x1842, 0x0002 },\n+  { 0x0e, 0x00, -1, 0x01, 0x1842, 0x0003 },\n+  { 0x0e, 0x00, -1, 0x02, 0x1842, 0x0004 },\n+  { 0x0e, 0x00, -1, 0x03, 0x1842, 0x0005 },\n+  { 0x0e, 0x00, -1, 0x03, 0x1842, 0x0006 },\n+  { 0x0e, 0x00, -1, 0x03, 0x1842, 0x0007 },\n+  { 0x0e, 0x00, -1, 0x03, 0x1842, 0x0008 },\n+  { 0x0e, 0x00, -1, 0x03, 0x1842, 0x0009 },\n+  { 0x18, 0x00, -1, 0x00, 0x5842, 0x0002 },\n+  { 0x18, 0x00, -1, 0x01, 0x5842, 0x0003 },\n+  { 0x18, 0x00, -1, 0x02, 0x5842, 0x0004 },\n+  { 0x18, 0x00, -1, 0x03, 0x5842, 0x0005 },\n+  { 0x18, 0x00, -1, 0x03, 0x5842, 0x0006 },\n+  { 0x18, 0x00, -1, 0x03, 0x5842, 0x0007 },\n+  { 0x18, 0x00, -1, 0x03, 0x5842, 0x0008 },\n+  { 0x18, 0x00, -1, 0x03, 0x5842, 0x0009 },\n+  { 0x02, 0x05, -1, 0x03, 0x000a, 0x0046 },\n+  { 0x02, 0x05, -1, 0x03, 0x000a, 0x0066 },\n+  { 0x02, 0x06, -1, 0x03, 0x000a, 0x0086 },\n+  { 0x02, 0x07, -1, 0x03, 0x000a, 0x00c6 },\n+  { 0x02, 0x08, -1, 0x03, 0x000a, 0x0146 },\n+  { 0x02, 0x09, -1, 0x03, 0x000a, 0x0246 },\n+  { 0x02, 0x0a, -1, 0x03, 0x000a, 0x0446 },\n+  { 0x02, 0x18, -1, 0x03, 0x000a, 0x0846 },\n+  { 0x02, 0x05, -1, 0x03, 0x000e, 0x0046 },\n+  { 0x02, 0x05, -1, 0x03, 0x000e, 0x0066 },\n+  { 0x02, 0x06, -1, 0x03, 0x000e, 0x0086 },\n+  { 0x02, 0x07, -1, 0x03, 0x000e, 0x00c6 },\n+  { 0x02, 0x08, -1, 0x03, 0x000e, 0x0146 },\n+  { 0x02, 0x09, -1, 0x03, 0x000e, 0x0246 },\n+  { 0x02, 0x0a, -1, 0x03, 0x000e, 0x0446 },\n+  { 0x02, 0x18, -1, 0x03, 0x000e, 0x0846 },\n+  { 0x03, 0x05, -1, 0x03, 0x0012, 0x0046 },\n+  { 0x03, 0x05, -1, 0x03, 0x0012, 0x0066 },\n+  { 0x03, 0x06, -1, 0x03, 0x0012, 0x0086 },\n+  { 0x03, 0x07, -1, 0x03, 0x0012, 0x00c6 },\n+  { 0x03, 0x08, -1, 0x03, 0x0012, 0x0146 },\n+  { 0x03, 0x09, -1, 0x03, 0x0012, 0x0246 },\n+  { 0x03, 0x0a, -1, 0x03, 0x0012, 0x0446 },\n+  { 0x03, 0x18, -1, 0x03, 0x0012, 0x0846 },\n+  { 0x03, 0x05, -1, 0x03, 0x001a, 0x0046 },\n+  { 0x03, 0x05, -1, 0x03, 0x001a, 0x0066 },\n+  { 0x03, 0x06, -1, 0x03, 0x001a, 0x0086 },\n+  { 0x03, 0x07, -1, 0x03, 0x001a, 0x00c6 },\n+  { 0x03, 0x08, -1, 0x03, 0x001a, 0x0146 },\n+  { 0x03, 0x09, -1, 0x03, 0x001a, 0x0246 },\n+  { 0x03, 0x0a, -1, 0x03, 0x001a, 0x0446 },\n+  { 0x03, 0x18, -1, 0x03, 0x001a, 0x0846 },\n+  { 0x04, 0x05, -1, 0x03, 0x0022, 0x0046 },\n+  { 0x04, 0x05, -1, 0x03, 0x0022, 0x0066 },\n+  { 0x04, 0x06, -1, 0x03, 0x0022, 0x0086 },\n+  { 0x04, 0x07, -1, 0x03, 0x0022, 0x00c6 },\n+  { 0x04, 0x08, -1, 0x03, 0x0022, 0x0146 },\n+  { 0x04, 0x09, -1, 0x03, 0x0022, 0x0246 },\n+  { 0x04, 0x0a, -1, 0x03, 0x0022, 0x0446 },\n+  { 0x04, 0x18, -1, 0x03, 0x0022, 0x0846 },\n+  { 0x04, 0x05, -1, 0x03, 0x0032, 0x0046 },\n+  { 0x04, 0x05, -1, 0x03, 0x0032, 0x0066 },\n+  { 0x04, 0x06, -1, 0x03, 0x0032, 0x0086 },\n+  { 0x04, 0x07, -1, 0x03, 0x0032, 0x00c6 },\n+  { 0x04, 0x08, -1, 0x03, 0x0032, 0x0146 },\n+  { 0x04, 0x09, -1, 0x03, 0x0032, 0x0246 },\n+  { 0x04, 0x0a, -1, 0x03, 0x0032, 0x0446 },\n+  { 0x04, 0x18, -1, 0x03, 0x0032, 0x0846 },\n+  { 0x05, 0x05, -1, 0x03, 0x0042, 0x0046 },\n+  { 0x05, 0x05, -1, 0x03, 0x0042, 0x0066 },\n+  { 0x05, 0x06, -1, 0x03, 0x0042, 0x0086 },\n+  { 0x05, 0x07, -1, 0x03, 0x0042, 0x00c6 },\n+  { 0x05, 0x08, -1, 0x03, 0x0042, 0x0146 },\n+  { 0x05, 0x09, -1, 0x03, 0x0042, 0x0246 },\n+  { 0x05, 0x0a, -1, 0x03, 0x0042, 0x0446 },\n+  { 0x05, 0x18, -1, 0x03, 0x0042, 0x0846 },\n+  { 0x05, 0x05, -1, 0x03, 0x0062, 0x0046 },\n+  { 0x05, 0x05, -1, 0x03, 0x0062, 0x0066 },\n+  { 0x05, 0x06, -1, 0x03, 0x0062, 0x0086 },\n+  { 0x05, 0x07, -1, 0x03, 0x0062, 0x00c6 },\n+  { 0x05, 0x08, -1, 0x03, 0x0062, 0x0146 },\n+  { 0x05, 0x09, -1, 0x03, 0x0062, 0x0246 },\n+  { 0x05, 0x0a, -1, 0x03, 0x0062, 0x0446 },\n+  { 0x05, 0x18, -1, 0x03, 0x0062, 0x0846 },\n+  { 0x06, 0x01, -1, 0x03, 0x0082, 0x000a },\n+  { 0x06, 0x01, -1, 0x03, 0x0082, 0x000c },\n+  { 0x06, 0x02, -1, 0x03, 0x0082, 0x000e },\n+  { 0x06, 0x02, -1, 0x03, 0x0082, 0x0012 },\n+  { 0x06, 0x03, -1, 0x03, 0x0082, 0x0016 },\n+  { 0x06, 0x03, -1, 0x03, 0x0082, 0x001e },\n+  { 0x06, 0x04, -1, 0x03, 0x0082, 0x0026 },\n+  { 0x06, 0x04, -1, 0x03, 0x0082, 0x0036 },\n+  { 0x07, 0x01, -1, 0x03, 0x00c2, 0x000a },\n+  { 0x07, 0x01, -1, 0x03, 0x00c2, 0x000c },\n+  { 0x07, 0x02, -1, 0x03, 0x00c2, 0x000e },\n+  { 0x07, 0x02, -1, 0x03, 0x00c2, 0x0012 },\n+  { 0x07, 0x03, -1, 0x03, 0x00c2, 0x0016 },\n+  { 0x07, 0x03, -1, 0x03, 0x00c2, 0x001e },\n+  { 0x07, 0x04, -1, 0x03, 0x00c2, 0x0026 },\n+  { 0x07, 0x04, -1, 0x03, 0x00c2, 0x0036 },\n+  { 0x08, 0x01, -1, 0x03, 0x0142, 0x000a },\n+  { 0x08, 0x01, -1, 0x03, 0x0142, 0x000c },\n+  { 0x08, 0x02, -1, 0x03, 0x0142, 0x000e },\n+  { 0x08, 0x02, -1, 0x03, 0x0142, 0x0012 },\n+  { 0x08, 0x03, -1, 0x03, 0x0142, 0x0016 },\n+  { 0x08, 0x03, -1, 0x03, 0x0142, 0x001e },\n+  { 0x08, 0x04, -1, 0x03, 0x0142, 0x0026 },\n+  { 0x08, 0x04, -1, 0x03, 0x0142, 0x0036 },\n+  { 0x09, 0x01, -1, 0x03, 0x0242, 0x000a },\n+  { 0x09, 0x01, -1, 0x03, 0x0242, 0x000c },\n+  { 0x09, 0x02, -1, 0x03, 0x0242, 0x000e },\n+  { 0x09, 0x02, -1, 0x03, 0x0242, 0x0012 },\n+  { 0x09, 0x03, -1, 0x03, 0x0242, 0x0016 },\n+  { 0x09, 0x03, -1, 0x03, 0x0242, 0x001e },\n+  { 0x09, 0x04, -1, 0x03, 0x0242, 0x0026 },\n+  { 0x09, 0x04, -1, 0x03, 0x0242, 0x0036 },\n+  { 0x0a, 0x01, -1, 0x03, 0x0442, 0x000a },\n+  { 0x0a, 0x01, -1, 0x03, 0x0442, 0x000c },\n+  { 0x0a, 0x02, -1, 0x03, 0x0442, 0x000e },\n+  { 0x0a, 0x02, -1, 0x03, 0x0442, 0x0012 },\n+  { 0x0a, 0x03, -1, 0x03, 0x0442, 0x0016 },\n+  { 0x0a, 0x03, -1, 0x03, 0x0442, 0x001e },\n+  { 0x0a, 0x04, -1, 0x03, 0x0442, 0x0026 },\n+  { 0x0a, 0x04, -1, 0x03, 0x0442, 0x0036 },\n+  { 0x0c, 0x01, -1, 0x03, 0x0842, 0x000a },\n+  { 0x0c, 0x01, -1, 0x03, 0x0842, 0x000c },\n+  { 0x0c, 0x02, -1, 0x03, 0x0842, 0x000e },\n+  { 0x0c, 0x02, -1, 0x03, 0x0842, 0x0012 },\n+  { 0x0c, 0x03, -1, 0x03, 0x0842, 0x0016 },\n+  { 0x0c, 0x03, -1, 0x03, 0x0842, 0x001e },\n+  { 0x0c, 0x04, -1, 0x03, 0x0842, 0x0026 },\n+  { 0x0c, 0x04, -1, 0x03, 0x0842, 0x0036 },\n+  { 0x0e, 0x01, -1, 0x03, 0x1842, 0x000a },\n+  { 0x0e, 0x01, -1, 0x03, 0x1842, 0x000c },\n+  { 0x0e, 0x02, -1, 0x03, 0x1842, 0x000e },\n+  { 0x0e, 0x02, -1, 0x03, 0x1842, 0x0012 },\n+  { 0x0e, 0x03, -1, 0x03, 0x1842, 0x0016 },\n+  { 0x0e, 0x03, -1, 0x03, 0x1842, 0x001e },\n+  { 0x0e, 0x04, -1, 0x03, 0x1842, 0x0026 },\n+  { 0x0e, 0x04, -1, 0x03, 0x1842, 0x0036 },\n+  { 0x18, 0x01, -1, 0x03, 0x5842, 0x000a },\n+  { 0x18, 0x01, -1, 0x03, 0x5842, 0x000c },\n+  { 0x18, 0x02, -1, 0x03, 0x5842, 0x000e },\n+  { 0x18, 0x02, -1, 0x03, 0x5842, 0x0012 },\n+  { 0x18, 0x03, -1, 0x03, 0x5842, 0x0016 },\n+  { 0x18, 0x03, -1, 0x03, 0x5842, 0x001e },\n+  { 0x18, 0x04, -1, 0x03, 0x5842, 0x0026 },\n+  { 0x18, 0x04, -1, 0x03, 0x5842, 0x0036 },\n+  { 0x06, 0x05, -1, 0x03, 0x0082, 0x0046 },\n+  { 0x06, 0x05, -1, 0x03, 0x0082, 0x0066 },\n+  { 0x06, 0x06, -1, 0x03, 0x0082, 0x0086 },\n+  { 0x06, 0x07, -1, 0x03, 0x0082, 0x00c6 },\n+  { 0x06, 0x08, -1, 0x03, 0x0082, 0x0146 },\n+  { 0x06, 0x09, -1, 0x03, 0x0082, 0x0246 },\n+  { 0x06, 0x0a, -1, 0x03, 0x0082, 0x0446 },\n+  { 0x06, 0x18, -1, 0x03, 0x0082, 0x0846 },\n+  { 0x07, 0x05, -1, 0x03, 0x00c2, 0x0046 },\n+  { 0x07, 0x05, -1, 0x03, 0x00c2, 0x0066 },\n+  { 0x07, 0x06, -1, 0x03, 0x00c2, 0x0086 },\n+  { 0x07, 0x07, -1, 0x03, 0x00c2, 0x00c6 },\n+  { 0x07, 0x08, -1, 0x03, 0x00c2, 0x0146 },\n+  { 0x07, 0x09, -1, 0x03, 0x00c2, 0x0246 },\n+  { 0x07, 0x0a, -1, 0x03, 0x00c2, 0x0446 },\n+  { 0x07, 0x18, -1, 0x03, 0x00c2, 0x0846 },\n+  { 0x08, 0x05, -1, 0x03, 0x0142, 0x0046 },\n+  { 0x08, 0x05, -1, 0x03, 0x0142, 0x0066 },\n+  { 0x08, 0x06, -1, 0x03, 0x0142, 0x0086 },\n+  { 0x08, 0x07, -1, 0x03, 0x0142, 0x00c6 },\n+  { 0x08, 0x08, -1, 0x03, 0x0142, 0x0146 },\n+  { 0x08, 0x09, -1, 0x03, 0x0142, 0x0246 },\n+  { 0x08, 0x0a, -1, 0x03, 0x0142, 0x0446 },\n+  { 0x08, 0x18, -1, 0x03, 0x0142, 0x0846 },\n+  { 0x09, 0x05, -1, 0x03, 0x0242, 0x0046 },\n+  { 0x09, 0x05, -1, 0x03, 0x0242, 0x0066 },\n+  { 0x09, 0x06, -1, 0x03, 0x0242, 0x0086 },\n+  { 0x09, 0x07, -1, 0x03, 0x0242, 0x00c6 },\n+  { 0x09, 0x08, -1, 0x03, 0x0242, 0x0146 },\n+  { 0x09, 0x09, -1, 0x03, 0x0242, 0x0246 },\n+  { 0x09, 0x0a, -1, 0x03, 0x0242, 0x0446 },\n+  { 0x09, 0x18, -1, 0x03, 0x0242, 0x0846 },\n+  { 0x0a, 0x05, -1, 0x03, 0x0442, 0x0046 },\n+  { 0x0a, 0x05, -1, 0x03, 0x0442, 0x0066 },\n+  { 0x0a, 0x06, -1, 0x03, 0x0442, 0x0086 },\n+  { 0x0a, 0x07, -1, 0x03, 0x0442, 0x00c6 },\n+  { 0x0a, 0x08, -1, 0x03, 0x0442, 0x0146 },\n+  { 0x0a, 0x09, -1, 0x03, 0x0442, 0x0246 },\n+  { 0x0a, 0x0a, -1, 0x03, 0x0442, 0x0446 },\n+  { 0x0a, 0x18, -1, 0x03, 0x0442, 0x0846 },\n+  { 0x0c, 0x05, -1, 0x03, 0x0842, 0x0046 },\n+  { 0x0c, 0x05, -1, 0x03, 0x0842, 0x0066 },\n+  { 0x0c, 0x06, -1, 0x03, 0x0842, 0x0086 },\n+  { 0x0c, 0x07, -1, 0x03, 0x0842, 0x00c6 },\n+  { 0x0c, 0x08, -1, 0x03, 0x0842, 0x0146 },\n+  { 0x0c, 0x09, -1, 0x03, 0x0842, 0x0246 },\n+  { 0x0c, 0x0a, -1, 0x03, 0x0842, 0x0446 },\n+  { 0x0c, 0x18, -1, 0x03, 0x0842, 0x0846 },\n+  { 0x0e, 0x05, -1, 0x03, 0x1842, 0x0046 },\n+  { 0x0e, 0x05, -1, 0x03, 0x1842, 0x0066 },\n+  { 0x0e, 0x06, -1, 0x03, 0x1842, 0x0086 },\n+  { 0x0e, 0x07, -1, 0x03, 0x1842, 0x00c6 },\n+  { 0x0e, 0x08, -1, 0x03, 0x1842, 0x0146 },\n+  { 0x0e, 0x09, -1, 0x03, 0x1842, 0x0246 },\n+  { 0x0e, 0x0a, -1, 0x03, 0x1842, 0x0446 },\n+  { 0x0e, 0x18, -1, 0x03, 0x1842, 0x0846 },\n+  { 0x18, 0x05, -1, 0x03, 0x5842, 0x0046 },\n+  { 0x18, 0x05, -1, 0x03, 0x5842, 0x0066 },\n+  { 0x18, 0x06, -1, 0x03, 0x5842, 0x0086 },\n+  { 0x18, 0x07, -1, 0x03, 0x5842, 0x00c6 },\n+  { 0x18, 0x08, -1, 0x03, 0x5842, 0x0146 },\n+  { 0x18, 0x09, -1, 0x03, 0x5842, 0x0246 },\n+  { 0x18, 0x0a, -1, 0x03, 0x5842, 0x0446 },\n+  { 0x18, 0x18, -1, 0x03, 0x5842, 0x0846 },\n+};\n+\n+#endif  /* BROTLI_DEC_PREFIX_H_ */"
        },
        {
            "sha": "e0b37c2dcd03050985e25e47f1b3abf9ebb4ec73",
            "filename": "deps/brotli/c/dec/state.c",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fstate.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fstate.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fdec%2Fstate.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,164 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+#include \"./state.h\"\n+\n+#include <stdlib.h>  /* free, malloc */\n+\n+#include <brotli/types.h>\n+#include \"./huffman.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+BROTLI_BOOL BrotliDecoderStateInit(BrotliDecoderState* s,\n+    brotli_alloc_func alloc_func, brotli_free_func free_func, void* opaque) {\n+  if (!alloc_func) {\n+    s->alloc_func = BrotliDefaultAllocFunc;\n+    s->free_func = BrotliDefaultFreeFunc;\n+    s->memory_manager_opaque = 0;\n+  } else {\n+    s->alloc_func = alloc_func;\n+    s->free_func = free_func;\n+    s->memory_manager_opaque = opaque;\n+  }\n+\n+  s->error_code = 0; /* BROTLI_DECODER_NO_ERROR */\n+\n+  BrotliInitBitReader(&s->br);\n+  s->state = BROTLI_STATE_UNINITED;\n+  s->large_window = 0;\n+  s->substate_metablock_header = BROTLI_STATE_METABLOCK_HEADER_NONE;\n+  s->substate_tree_group = BROTLI_STATE_TREE_GROUP_NONE;\n+  s->substate_context_map = BROTLI_STATE_CONTEXT_MAP_NONE;\n+  s->substate_uncompressed = BROTLI_STATE_UNCOMPRESSED_NONE;\n+  s->substate_huffman = BROTLI_STATE_HUFFMAN_NONE;\n+  s->substate_decode_uint8 = BROTLI_STATE_DECODE_UINT8_NONE;\n+  s->substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_NONE;\n+\n+  s->buffer_length = 0;\n+  s->loop_counter = 0;\n+  s->pos = 0;\n+  s->rb_roundtrips = 0;\n+  s->partial_pos_out = 0;\n+\n+  s->block_type_trees = NULL;\n+  s->block_len_trees = NULL;\n+  s->ringbuffer = NULL;\n+  s->ringbuffer_size = 0;\n+  s->new_ringbuffer_size = 0;\n+  s->ringbuffer_mask = 0;\n+\n+  s->context_map = NULL;\n+  s->context_modes = NULL;\n+  s->dist_context_map = NULL;\n+  s->context_map_slice = NULL;\n+  s->dist_context_map_slice = NULL;\n+\n+  s->sub_loop_counter = 0;\n+\n+  s->literal_hgroup.codes = NULL;\n+  s->literal_hgroup.htrees = NULL;\n+  s->insert_copy_hgroup.codes = NULL;\n+  s->insert_copy_hgroup.htrees = NULL;\n+  s->distance_hgroup.codes = NULL;\n+  s->distance_hgroup.htrees = NULL;\n+\n+  s->is_last_metablock = 0;\n+  s->is_uncompressed = 0;\n+  s->is_metadata = 0;\n+  s->should_wrap_ringbuffer = 0;\n+  s->canny_ringbuffer_allocation = 1;\n+\n+  s->window_bits = 0;\n+  s->max_distance = 0;\n+  s->dist_rb[0] = 16;\n+  s->dist_rb[1] = 15;\n+  s->dist_rb[2] = 11;\n+  s->dist_rb[3] = 4;\n+  s->dist_rb_idx = 0;\n+  s->block_type_trees = NULL;\n+  s->block_len_trees = NULL;\n+\n+  /* Make small negative indexes addressable. */\n+  s->symbol_lists = &s->symbols_lists_array[BROTLI_HUFFMAN_MAX_CODE_LENGTH + 1];\n+\n+  s->mtf_upper_bound = 63;\n+\n+  s->dictionary = BrotliGetDictionary();\n+  s->transforms = BrotliGetTransforms();\n+\n+  return BROTLI_TRUE;\n+}\n+\n+void BrotliDecoderStateMetablockBegin(BrotliDecoderState* s) {\n+  s->meta_block_remaining_len = 0;\n+  s->block_length[0] = 1U << 24;\n+  s->block_length[1] = 1U << 24;\n+  s->block_length[2] = 1U << 24;\n+  s->num_block_types[0] = 1;\n+  s->num_block_types[1] = 1;\n+  s->num_block_types[2] = 1;\n+  s->block_type_rb[0] = 1;\n+  s->block_type_rb[1] = 0;\n+  s->block_type_rb[2] = 1;\n+  s->block_type_rb[3] = 0;\n+  s->block_type_rb[4] = 1;\n+  s->block_type_rb[5] = 0;\n+  s->context_map = NULL;\n+  s->context_modes = NULL;\n+  s->dist_context_map = NULL;\n+  s->context_map_slice = NULL;\n+  s->literal_htree = NULL;\n+  s->dist_context_map_slice = NULL;\n+  s->dist_htree_index = 0;\n+  s->context_lookup = NULL;\n+  s->literal_hgroup.codes = NULL;\n+  s->literal_hgroup.htrees = NULL;\n+  s->insert_copy_hgroup.codes = NULL;\n+  s->insert_copy_hgroup.htrees = NULL;\n+  s->distance_hgroup.codes = NULL;\n+  s->distance_hgroup.htrees = NULL;\n+}\n+\n+void BrotliDecoderStateCleanupAfterMetablock(BrotliDecoderState* s) {\n+  BROTLI_DECODER_FREE(s, s->context_modes);\n+  BROTLI_DECODER_FREE(s, s->context_map);\n+  BROTLI_DECODER_FREE(s, s->dist_context_map);\n+  BROTLI_DECODER_FREE(s, s->literal_hgroup.htrees);\n+  BROTLI_DECODER_FREE(s, s->insert_copy_hgroup.htrees);\n+  BROTLI_DECODER_FREE(s, s->distance_hgroup.htrees);\n+}\n+\n+void BrotliDecoderStateCleanup(BrotliDecoderState* s) {\n+  BrotliDecoderStateCleanupAfterMetablock(s);\n+\n+  BROTLI_DECODER_FREE(s, s->ringbuffer);\n+  BROTLI_DECODER_FREE(s, s->block_type_trees);\n+}\n+\n+BROTLI_BOOL BrotliDecoderHuffmanTreeGroupInit(BrotliDecoderState* s,\n+    HuffmanTreeGroup* group, uint32_t alphabet_size, uint32_t max_symbol,\n+    uint32_t ntrees) {\n+  /* Pack two allocations into one */\n+  const size_t max_table_size = kMaxHuffmanTableSize[(alphabet_size + 31) >> 5];\n+  const size_t code_size = sizeof(HuffmanCode) * ntrees * max_table_size;\n+  const size_t htree_size = sizeof(HuffmanCode*) * ntrees;\n+  /* Pointer alignment is, hopefully, wider than sizeof(HuffmanCode). */\n+  HuffmanCode** p = (HuffmanCode**)BROTLI_DECODER_ALLOC(s,\n+      code_size + htree_size);\n+  group->alphabet_size = (uint16_t)alphabet_size;\n+  group->max_symbol = (uint16_t)max_symbol;\n+  group->num_htrees = (uint16_t)ntrees;\n+  group->htrees = p;\n+  group->codes = (HuffmanCode*)(&p[ntrees]);\n+  return !!p;\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "d28b63920ef4531c4df9479c3d6c19564cfe89d0",
            "filename": "deps/brotli/c/dec/state.h",
            "status": "added",
            "additions": 258,
            "deletions": 0,
            "changes": 258,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fstate.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fdec%2Fstate.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fdec%2Fstate.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,258 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Brotli state for partial streaming decoding. */\n+\n+#ifndef BROTLI_DEC_STATE_H_\n+#define BROTLI_DEC_STATE_H_\n+\n+#include \"../common/constants.h\"\n+#include \"../common/dictionary.h\"\n+#include \"../common/platform.h\"\n+#include \"../common/transform.h\"\n+#include <brotli/types.h>\n+#include \"./bit_reader.h\"\n+#include \"./huffman.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+typedef enum {\n+  BROTLI_STATE_UNINITED,\n+  BROTLI_STATE_LARGE_WINDOW_BITS,\n+  BROTLI_STATE_INITIALIZE,\n+  BROTLI_STATE_METABLOCK_BEGIN,\n+  BROTLI_STATE_METABLOCK_HEADER,\n+  BROTLI_STATE_METABLOCK_HEADER_2,\n+  BROTLI_STATE_CONTEXT_MODES,\n+  BROTLI_STATE_COMMAND_BEGIN,\n+  BROTLI_STATE_COMMAND_INNER,\n+  BROTLI_STATE_COMMAND_POST_DECODE_LITERALS,\n+  BROTLI_STATE_COMMAND_POST_WRAP_COPY,\n+  BROTLI_STATE_UNCOMPRESSED,\n+  BROTLI_STATE_METADATA,\n+  BROTLI_STATE_COMMAND_INNER_WRITE,\n+  BROTLI_STATE_METABLOCK_DONE,\n+  BROTLI_STATE_COMMAND_POST_WRITE_1,\n+  BROTLI_STATE_COMMAND_POST_WRITE_2,\n+  BROTLI_STATE_HUFFMAN_CODE_0,\n+  BROTLI_STATE_HUFFMAN_CODE_1,\n+  BROTLI_STATE_HUFFMAN_CODE_2,\n+  BROTLI_STATE_HUFFMAN_CODE_3,\n+  BROTLI_STATE_CONTEXT_MAP_1,\n+  BROTLI_STATE_CONTEXT_MAP_2,\n+  BROTLI_STATE_TREE_GROUP,\n+  BROTLI_STATE_DONE\n+} BrotliRunningState;\n+\n+typedef enum {\n+  BROTLI_STATE_METABLOCK_HEADER_NONE,\n+  BROTLI_STATE_METABLOCK_HEADER_EMPTY,\n+  BROTLI_STATE_METABLOCK_HEADER_NIBBLES,\n+  BROTLI_STATE_METABLOCK_HEADER_SIZE,\n+  BROTLI_STATE_METABLOCK_HEADER_UNCOMPRESSED,\n+  BROTLI_STATE_METABLOCK_HEADER_RESERVED,\n+  BROTLI_STATE_METABLOCK_HEADER_BYTES,\n+  BROTLI_STATE_METABLOCK_HEADER_METADATA\n+} BrotliRunningMetablockHeaderState;\n+\n+typedef enum {\n+  BROTLI_STATE_UNCOMPRESSED_NONE,\n+  BROTLI_STATE_UNCOMPRESSED_WRITE\n+} BrotliRunningUncompressedState;\n+\n+typedef enum {\n+  BROTLI_STATE_TREE_GROUP_NONE,\n+  BROTLI_STATE_TREE_GROUP_LOOP\n+} BrotliRunningTreeGroupState;\n+\n+typedef enum {\n+  BROTLI_STATE_CONTEXT_MAP_NONE,\n+  BROTLI_STATE_CONTEXT_MAP_READ_PREFIX,\n+  BROTLI_STATE_CONTEXT_MAP_HUFFMAN,\n+  BROTLI_STATE_CONTEXT_MAP_DECODE,\n+  BROTLI_STATE_CONTEXT_MAP_TRANSFORM\n+} BrotliRunningContextMapState;\n+\n+typedef enum {\n+  BROTLI_STATE_HUFFMAN_NONE,\n+  BROTLI_STATE_HUFFMAN_SIMPLE_SIZE,\n+  BROTLI_STATE_HUFFMAN_SIMPLE_READ,\n+  BROTLI_STATE_HUFFMAN_SIMPLE_BUILD,\n+  BROTLI_STATE_HUFFMAN_COMPLEX,\n+  BROTLI_STATE_HUFFMAN_LENGTH_SYMBOLS\n+} BrotliRunningHuffmanState;\n+\n+typedef enum {\n+  BROTLI_STATE_DECODE_UINT8_NONE,\n+  BROTLI_STATE_DECODE_UINT8_SHORT,\n+  BROTLI_STATE_DECODE_UINT8_LONG\n+} BrotliRunningDecodeUint8State;\n+\n+typedef enum {\n+  BROTLI_STATE_READ_BLOCK_LENGTH_NONE,\n+  BROTLI_STATE_READ_BLOCK_LENGTH_SUFFIX\n+} BrotliRunningReadBlockLengthState;\n+\n+struct BrotliDecoderStateStruct {\n+  BrotliRunningState state;\n+\n+  /* This counter is reused for several disjoint loops. */\n+  int loop_counter;\n+\n+  BrotliBitReader br;\n+\n+  brotli_alloc_func alloc_func;\n+  brotli_free_func free_func;\n+  void* memory_manager_opaque;\n+\n+  /* Temporary storage for remaining input. */\n+  union {\n+    uint64_t u64;\n+    uint8_t u8[8];\n+  } buffer;\n+  uint32_t buffer_length;\n+\n+  int pos;\n+  int max_backward_distance;\n+  int max_distance;\n+  int ringbuffer_size;\n+  int ringbuffer_mask;\n+  int dist_rb_idx;\n+  int dist_rb[4];\n+  int error_code;\n+  uint32_t sub_loop_counter;\n+  uint8_t* ringbuffer;\n+  uint8_t* ringbuffer_end;\n+  HuffmanCode* htree_command;\n+  const uint8_t* context_lookup;\n+  uint8_t* context_map_slice;\n+  uint8_t* dist_context_map_slice;\n+\n+  /* This ring buffer holds a few past copy distances that will be used by\n+     some special distance codes. */\n+  HuffmanTreeGroup literal_hgroup;\n+  HuffmanTreeGroup insert_copy_hgroup;\n+  HuffmanTreeGroup distance_hgroup;\n+  HuffmanCode* block_type_trees;\n+  HuffmanCode* block_len_trees;\n+  /* This is true if the literal context map histogram type always matches the\n+     block type. It is then not needed to keep the context (faster decoding). */\n+  int trivial_literal_context;\n+  /* Distance context is actual after command is decoded and before distance is\n+     computed. After distance computation it is used as a temporary variable. */\n+  int distance_context;\n+  int meta_block_remaining_len;\n+  uint32_t block_length_index;\n+  uint32_t block_length[3];\n+  uint32_t num_block_types[3];\n+  uint32_t block_type_rb[6];\n+  uint32_t distance_postfix_bits;\n+  uint32_t num_direct_distance_codes;\n+  int distance_postfix_mask;\n+  uint32_t num_dist_htrees;\n+  uint8_t* dist_context_map;\n+  HuffmanCode* literal_htree;\n+  uint8_t dist_htree_index;\n+  uint32_t repeat_code_len;\n+  uint32_t prev_code_len;\n+\n+  int copy_length;\n+  int distance_code;\n+\n+  /* For partial write operations. */\n+  size_t rb_roundtrips;  /* how many times we went around the ring-buffer */\n+  size_t partial_pos_out;  /* how much output to the user in total */\n+\n+  /* For ReadHuffmanCode. */\n+  uint32_t symbol;\n+  uint32_t repeat;\n+  uint32_t space;\n+\n+  HuffmanCode table[32];\n+  /* List of heads of symbol chains. */\n+  uint16_t* symbol_lists;\n+  /* Storage from symbol_lists. */\n+  uint16_t symbols_lists_array[BROTLI_HUFFMAN_MAX_CODE_LENGTH + 1 +\n+                               BROTLI_NUM_COMMAND_SYMBOLS];\n+  /* Tails of symbol chains. */\n+  int next_symbol[32];\n+  uint8_t code_length_code_lengths[BROTLI_CODE_LENGTH_CODES];\n+  /* Population counts for the code lengths. */\n+  uint16_t code_length_histo[16];\n+\n+  /* For HuffmanTreeGroupDecode. */\n+  int htree_index;\n+  HuffmanCode* next;\n+\n+  /* For DecodeContextMap. */\n+  uint32_t context_index;\n+  uint32_t max_run_length_prefix;\n+  uint32_t code;\n+  HuffmanCode context_map_table[BROTLI_HUFFMAN_MAX_SIZE_272];\n+\n+  /* For InverseMoveToFrontTransform. */\n+  uint32_t mtf_upper_bound;\n+  uint32_t mtf[64 + 1];\n+\n+  /* Less used attributes are at the end of this struct. */\n+\n+  /* States inside function calls. */\n+  BrotliRunningMetablockHeaderState substate_metablock_header;\n+  BrotliRunningTreeGroupState substate_tree_group;\n+  BrotliRunningContextMapState substate_context_map;\n+  BrotliRunningUncompressedState substate_uncompressed;\n+  BrotliRunningHuffmanState substate_huffman;\n+  BrotliRunningDecodeUint8State substate_decode_uint8;\n+  BrotliRunningReadBlockLengthState substate_read_block_length;\n+\n+  unsigned int is_last_metablock : 1;\n+  unsigned int is_uncompressed : 1;\n+  unsigned int is_metadata : 1;\n+  unsigned int should_wrap_ringbuffer : 1;\n+  unsigned int canny_ringbuffer_allocation : 1;\n+  unsigned int large_window : 1;\n+  unsigned int size_nibbles : 8;\n+  uint32_t window_bits;\n+\n+  int new_ringbuffer_size;\n+\n+  uint32_t num_literal_htrees;\n+  uint8_t* context_map;\n+  uint8_t* context_modes;\n+\n+  const BrotliDictionary* dictionary;\n+  const BrotliTransforms* transforms;\n+\n+  uint32_t trivial_literal_contexts[8];  /* 256 bits */\n+};\n+\n+typedef struct BrotliDecoderStateStruct BrotliDecoderStateInternal;\n+#define BrotliDecoderState BrotliDecoderStateInternal\n+\n+BROTLI_INTERNAL BROTLI_BOOL BrotliDecoderStateInit(BrotliDecoderState* s,\n+    brotli_alloc_func alloc_func, brotli_free_func free_func, void* opaque);\n+BROTLI_INTERNAL void BrotliDecoderStateCleanup(BrotliDecoderState* s);\n+BROTLI_INTERNAL void BrotliDecoderStateMetablockBegin(BrotliDecoderState* s);\n+BROTLI_INTERNAL void BrotliDecoderStateCleanupAfterMetablock(\n+    BrotliDecoderState* s);\n+BROTLI_INTERNAL BROTLI_BOOL BrotliDecoderHuffmanTreeGroupInit(\n+    BrotliDecoderState* s, HuffmanTreeGroup* group, uint32_t alphabet_size,\n+    uint32_t max_symbol, uint32_t ntrees);\n+\n+#define BROTLI_DECODER_ALLOC(S, L) S->alloc_func(S->memory_manager_opaque, L)\n+\n+#define BROTLI_DECODER_FREE(S, X) {          \\\n+  S->free_func(S->memory_manager_opaque, X); \\\n+  X = NULL;                                  \\\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_DEC_STATE_H_ */"
        },
        {
            "sha": "cd023d9b41ce2400854e51fda2a823d8e50a3b1f",
            "filename": "deps/brotli/c/enc/backward_references.c",
            "status": "added",
            "additions": 144,
            "deletions": 0,
            "changes": 144,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,144 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Function to find backward reference copies. */\n+\n+#include \"./backward_references.h\"\n+\n+#include \"../common/constants.h\"\n+#include \"../common/dictionary.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./command.h\"\n+#include \"./dictionary_hash.h\"\n+#include \"./memory.h\"\n+#include \"./quality.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+static BROTLI_INLINE size_t ComputeDistanceCode(size_t distance,\n+                                                size_t max_distance,\n+                                                const int* dist_cache) {\n+  if (distance <= max_distance) {\n+    size_t distance_plus_3 = distance + 3;\n+    size_t offset0 = distance_plus_3 - (size_t)dist_cache[0];\n+    size_t offset1 = distance_plus_3 - (size_t)dist_cache[1];\n+    if (distance == (size_t)dist_cache[0]) {\n+      return 0;\n+    } else if (distance == (size_t)dist_cache[1]) {\n+      return 1;\n+    } else if (offset0 < 7) {\n+      return (0x9750468 >> (4 * offset0)) & 0xF;\n+    } else if (offset1 < 7) {\n+      return (0xFDB1ACE >> (4 * offset1)) & 0xF;\n+    } else if (distance == (size_t)dist_cache[2]) {\n+      return 2;\n+    } else if (distance == (size_t)dist_cache[3]) {\n+      return 3;\n+    }\n+  }\n+  return distance + BROTLI_NUM_DISTANCE_SHORT_CODES - 1;\n+}\n+\n+#define EXPAND_CAT(a, b) CAT(a, b)\n+#define CAT(a, b) a ## b\n+#define FN(X) EXPAND_CAT(X, HASHER())\n+#define EXPORT_FN(X) EXPAND_CAT(X, EXPAND_CAT(PREFIX(), HASHER()))\n+\n+#define PREFIX() N\n+\n+#define HASHER() H2\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H3\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H4\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H5\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H6\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H40\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H41\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H42\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H54\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H35\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H55\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#define HASHER() H65\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./backward_references_inc.h\"\n+#undef HASHER\n+\n+#undef PREFIX\n+\n+#undef EXPORT_FN\n+#undef FN\n+#undef CAT\n+#undef EXPAND_CAT\n+\n+void BrotliCreateBackwardReferences(\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ringbuffer_mask, const BrotliEncoderParams* params,\n+    HasherHandle hasher, int* dist_cache, size_t* last_insert_len,\n+    Command* commands, size_t* num_commands, size_t* num_literals) {\n+  switch (params->hasher.type) {\n+#define CASE_(N)                                                  \\\n+    case N:                                                       \\\n+      CreateBackwardReferencesNH ## N(                            \\\n+          num_bytes, position, ringbuffer,                        \\\n+          ringbuffer_mask, params, hasher, dist_cache,            \\\n+          last_insert_len, commands, num_commands, num_literals); \\\n+      return;\n+    FOR_GENERIC_HASHERS(CASE_)\n+#undef CASE_\n+    default:\n+      break;\n+  }\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "3a4146647c4748417d5c3ae532d9b3ffb5f55086",
            "filename": "deps/brotli/c/enc/backward_references.h",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,38 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Function to find backward reference copies. */\n+\n+#ifndef BROTLI_ENC_BACKWARD_REFERENCES_H_\n+#define BROTLI_ENC_BACKWARD_REFERENCES_H_\n+\n+#include \"../common/constants.h\"\n+#include \"../common/dictionary.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./command.h\"\n+#include \"./hash.h\"\n+#include \"./quality.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* \"commands\" points to the next output command to write to, \"*num_commands\" is\n+   initially the total amount of commands output by previous\n+   CreateBackwardReferences calls, and must be incremented by the amount written\n+   by this call. */\n+BROTLI_INTERNAL void BrotliCreateBackwardReferences(\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ringbuffer_mask, const BrotliEncoderParams* params,\n+    HasherHandle hasher, int* dist_cache, size_t* last_insert_len,\n+    Command* commands, size_t* num_commands, size_t* num_literals);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_BACKWARD_REFERENCES_H_ */"
        },
        {
            "sha": "96b0e708de4bcd7a49ddea42be2ea654601a7183",
            "filename": "deps/brotli/c/enc/backward_references_hq.c",
            "status": "added",
            "additions": 825,
            "deletions": 0,
            "changes": 825,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references_hq.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references_hq.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references_hq.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,825 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Function to find backward reference copies. */\n+\n+#include \"./backward_references_hq.h\"\n+\n+#include <string.h>  /* memcpy, memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./command.h\"\n+#include \"./fast_log.h\"\n+#include \"./find_match_length.h\"\n+#include \"./literal_cost.h\"\n+#include \"./memory.h\"\n+#include \"./params.h\"\n+#include \"./prefix.h\"\n+#include \"./quality.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define BROTLI_MAX_EFFECTIVE_DISTANCE_ALPHABET_SIZE 544\n+\n+static const float kInfinity = 1.7e38f;  /* ~= 2 ^ 127 */\n+\n+static const uint32_t kDistanceCacheIndex[] = {\n+  0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\n+};\n+static const int kDistanceCacheOffset[] = {\n+  0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3\n+};\n+\n+void BrotliInitZopfliNodes(ZopfliNode* array, size_t length) {\n+  ZopfliNode stub;\n+  size_t i;\n+  stub.length = 1;\n+  stub.distance = 0;\n+  stub.dcode_insert_length = 0;\n+  stub.u.cost = kInfinity;\n+  for (i = 0; i < length; ++i) array[i] = stub;\n+}\n+\n+static BROTLI_INLINE uint32_t ZopfliNodeCopyLength(const ZopfliNode* self) {\n+  return self->length & 0x1FFFFFF;\n+}\n+\n+static BROTLI_INLINE uint32_t ZopfliNodeLengthCode(const ZopfliNode* self) {\n+  const uint32_t modifier = self->length >> 25;\n+  return ZopfliNodeCopyLength(self) + 9u - modifier;\n+}\n+\n+static BROTLI_INLINE uint32_t ZopfliNodeCopyDistance(const ZopfliNode* self) {\n+  return self->distance;\n+}\n+\n+static BROTLI_INLINE uint32_t ZopfliNodeDistanceCode(const ZopfliNode* self) {\n+  const uint32_t short_code = self->dcode_insert_length >> 27;\n+  return short_code == 0 ?\n+      ZopfliNodeCopyDistance(self) + BROTLI_NUM_DISTANCE_SHORT_CODES - 1 :\n+      short_code - 1;\n+}\n+\n+static BROTLI_INLINE uint32_t ZopfliNodeCommandLength(const ZopfliNode* self) {\n+  return ZopfliNodeCopyLength(self) + (self->dcode_insert_length & 0x7FFFFFF);\n+}\n+\n+/* Histogram based cost model for zopflification. */\n+typedef struct ZopfliCostModel {\n+  /* The insert and copy length symbols. */\n+  float cost_cmd_[BROTLI_NUM_COMMAND_SYMBOLS];\n+  float* cost_dist_;\n+  uint32_t distance_histogram_size;\n+  /* Cumulative costs of literals per position in the stream. */\n+  float* literal_costs_;\n+  float min_cost_cmd_;\n+  size_t num_bytes_;\n+} ZopfliCostModel;\n+\n+static void InitZopfliCostModel(\n+    MemoryManager* m, ZopfliCostModel* self, const BrotliDistanceParams* dist,\n+    size_t num_bytes) {\n+  uint32_t distance_histogram_size = dist->alphabet_size;\n+  if (distance_histogram_size > BROTLI_MAX_EFFECTIVE_DISTANCE_ALPHABET_SIZE) {\n+    distance_histogram_size = BROTLI_MAX_EFFECTIVE_DISTANCE_ALPHABET_SIZE;\n+  }\n+  self->num_bytes_ = num_bytes;\n+  self->literal_costs_ = BROTLI_ALLOC(m, float, num_bytes + 2);\n+  self->cost_dist_ = BROTLI_ALLOC(m, float, dist->alphabet_size);\n+  self->distance_histogram_size = distance_histogram_size;\n+  if (BROTLI_IS_OOM(m)) return;\n+}\n+\n+static void CleanupZopfliCostModel(MemoryManager* m, ZopfliCostModel* self) {\n+  BROTLI_FREE(m, self->literal_costs_);\n+  BROTLI_FREE(m, self->cost_dist_);\n+}\n+\n+static void SetCost(const uint32_t* histogram, size_t histogram_size,\n+                    BROTLI_BOOL literal_histogram, float* cost) {\n+  size_t sum = 0;\n+  size_t missing_symbol_sum;\n+  float log2sum;\n+  float missing_symbol_cost;\n+  size_t i;\n+  for (i = 0; i < histogram_size; i++) {\n+    sum += histogram[i];\n+  }\n+  log2sum = (float)FastLog2(sum);\n+  missing_symbol_sum = sum;\n+  if (!literal_histogram) {\n+    for (i = 0; i < histogram_size; i++) {\n+      if (histogram[i] == 0) missing_symbol_sum++;\n+    }\n+  }\n+  missing_symbol_cost = (float)FastLog2(missing_symbol_sum) + 2;\n+  for (i = 0; i < histogram_size; i++) {\n+    if (histogram[i] == 0) {\n+      cost[i] = missing_symbol_cost;\n+      continue;\n+    }\n+\n+    /* Shannon bits for this symbol. */\n+    cost[i] = log2sum - (float)FastLog2(histogram[i]);\n+\n+    /* Cannot be coded with less than 1 bit */\n+    if (cost[i] < 1) cost[i] = 1;\n+  }\n+}\n+\n+static void ZopfliCostModelSetFromCommands(ZopfliCostModel* self,\n+                                           size_t position,\n+                                           const uint8_t* ringbuffer,\n+                                           size_t ringbuffer_mask,\n+                                           const Command* commands,\n+                                           size_t num_commands,\n+                                           size_t last_insert_len) {\n+  uint32_t histogram_literal[BROTLI_NUM_LITERAL_SYMBOLS];\n+  uint32_t histogram_cmd[BROTLI_NUM_COMMAND_SYMBOLS];\n+  uint32_t histogram_dist[BROTLI_MAX_EFFECTIVE_DISTANCE_ALPHABET_SIZE];\n+  float cost_literal[BROTLI_NUM_LITERAL_SYMBOLS];\n+  size_t pos = position - last_insert_len;\n+  float min_cost_cmd = kInfinity;\n+  size_t i;\n+  float* cost_cmd = self->cost_cmd_;\n+\n+  memset(histogram_literal, 0, sizeof(histogram_literal));\n+  memset(histogram_cmd, 0, sizeof(histogram_cmd));\n+  memset(histogram_dist, 0, sizeof(histogram_dist));\n+\n+  for (i = 0; i < num_commands; i++) {\n+    size_t inslength = commands[i].insert_len_;\n+    size_t copylength = CommandCopyLen(&commands[i]);\n+    size_t distcode = commands[i].dist_prefix_ & 0x3FF;\n+    size_t cmdcode = commands[i].cmd_prefix_;\n+    size_t j;\n+\n+    histogram_cmd[cmdcode]++;\n+    if (cmdcode >= 128) histogram_dist[distcode]++;\n+\n+    for (j = 0; j < inslength; j++) {\n+      histogram_literal[ringbuffer[(pos + j) & ringbuffer_mask]]++;\n+    }\n+\n+    pos += inslength + copylength;\n+  }\n+\n+  SetCost(histogram_literal, BROTLI_NUM_LITERAL_SYMBOLS, BROTLI_TRUE,\n+          cost_literal);\n+  SetCost(histogram_cmd, BROTLI_NUM_COMMAND_SYMBOLS, BROTLI_FALSE,\n+          cost_cmd);\n+  SetCost(histogram_dist, self->distance_histogram_size, BROTLI_FALSE,\n+          self->cost_dist_);\n+\n+  for (i = 0; i < BROTLI_NUM_COMMAND_SYMBOLS; ++i) {\n+    min_cost_cmd = BROTLI_MIN(float, min_cost_cmd, cost_cmd[i]);\n+  }\n+  self->min_cost_cmd_ = min_cost_cmd;\n+\n+  {\n+    float* literal_costs = self->literal_costs_;\n+    float literal_carry = 0.0;\n+    size_t num_bytes = self->num_bytes_;\n+    literal_costs[0] = 0.0;\n+    for (i = 0; i < num_bytes; ++i) {\n+      literal_carry +=\n+          cost_literal[ringbuffer[(position + i) & ringbuffer_mask]];\n+      literal_costs[i + 1] = literal_costs[i] + literal_carry;\n+      literal_carry -= literal_costs[i + 1] - literal_costs[i];\n+    }\n+  }\n+}\n+\n+static void ZopfliCostModelSetFromLiteralCosts(ZopfliCostModel* self,\n+                                               size_t position,\n+                                               const uint8_t* ringbuffer,\n+                                               size_t ringbuffer_mask) {\n+  float* literal_costs = self->literal_costs_;\n+  float literal_carry = 0.0;\n+  float* cost_dist = self->cost_dist_;\n+  float* cost_cmd = self->cost_cmd_;\n+  size_t num_bytes = self->num_bytes_;\n+  size_t i;\n+  BrotliEstimateBitCostsForLiterals(position, num_bytes, ringbuffer_mask,\n+                                    ringbuffer, &literal_costs[1]);\n+  literal_costs[0] = 0.0;\n+  for (i = 0; i < num_bytes; ++i) {\n+    literal_carry += literal_costs[i + 1];\n+    literal_costs[i + 1] = literal_costs[i] + literal_carry;\n+    literal_carry -= literal_costs[i + 1] - literal_costs[i];\n+  }\n+  for (i = 0; i < BROTLI_NUM_COMMAND_SYMBOLS; ++i) {\n+    cost_cmd[i] = (float)FastLog2(11 + (uint32_t)i);\n+  }\n+  for (i = 0; i < self->distance_histogram_size; ++i) {\n+    cost_dist[i] = (float)FastLog2(20 + (uint32_t)i);\n+  }\n+  self->min_cost_cmd_ = (float)FastLog2(11);\n+}\n+\n+static BROTLI_INLINE float ZopfliCostModelGetCommandCost(\n+    const ZopfliCostModel* self, uint16_t cmdcode) {\n+  return self->cost_cmd_[cmdcode];\n+}\n+\n+static BROTLI_INLINE float ZopfliCostModelGetDistanceCost(\n+    const ZopfliCostModel* self, size_t distcode) {\n+  return self->cost_dist_[distcode];\n+}\n+\n+static BROTLI_INLINE float ZopfliCostModelGetLiteralCosts(\n+    const ZopfliCostModel* self, size_t from, size_t to) {\n+  return self->literal_costs_[to] - self->literal_costs_[from];\n+}\n+\n+static BROTLI_INLINE float ZopfliCostModelGetMinCostCmd(\n+    const ZopfliCostModel* self) {\n+  return self->min_cost_cmd_;\n+}\n+\n+/* REQUIRES: len >= 2, start_pos <= pos */\n+/* REQUIRES: cost < kInfinity, nodes[start_pos].cost < kInfinity */\n+/* Maintains the \"ZopfliNode array invariant\". */\n+static BROTLI_INLINE void UpdateZopfliNode(ZopfliNode* nodes, size_t pos,\n+    size_t start_pos, size_t len, size_t len_code, size_t dist,\n+    size_t short_code, float cost) {\n+  ZopfliNode* next = &nodes[pos + len];\n+  next->length = (uint32_t)(len | ((len + 9u - len_code) << 25));\n+  next->distance = (uint32_t)dist;\n+  next->dcode_insert_length = (uint32_t)(\n+      (short_code << 27) | (pos - start_pos));\n+  next->u.cost = cost;\n+}\n+\n+typedef struct PosData {\n+  size_t pos;\n+  int distance_cache[4];\n+  float costdiff;\n+  float cost;\n+} PosData;\n+\n+/* Maintains the smallest 8 cost difference together with their positions */\n+typedef struct StartPosQueue {\n+  PosData q_[8];\n+  size_t idx_;\n+} StartPosQueue;\n+\n+static BROTLI_INLINE void InitStartPosQueue(StartPosQueue* self) {\n+  self->idx_ = 0;\n+}\n+\n+static size_t StartPosQueueSize(const StartPosQueue* self) {\n+  return BROTLI_MIN(size_t, self->idx_, 8);\n+}\n+\n+static void StartPosQueuePush(StartPosQueue* self, const PosData* posdata) {\n+  size_t offset = ~(self->idx_++) & 7;\n+  size_t len = StartPosQueueSize(self);\n+  size_t i;\n+  PosData* q = self->q_;\n+  q[offset] = *posdata;\n+  /* Restore the sorted order. In the list of |len| items at most |len - 1|\n+     adjacent element comparisons / swaps are required. */\n+  for (i = 1; i < len; ++i) {\n+    if (q[offset & 7].costdiff > q[(offset + 1) & 7].costdiff) {\n+      BROTLI_SWAP(PosData, q, offset & 7, (offset + 1) & 7);\n+    }\n+    ++offset;\n+  }\n+}\n+\n+static const PosData* StartPosQueueAt(const StartPosQueue* self, size_t k) {\n+  return &self->q_[(k - self->idx_) & 7];\n+}\n+\n+/* Returns the minimum possible copy length that can improve the cost of any */\n+/* future position. */\n+static size_t ComputeMinimumCopyLength(const float start_cost,\n+                                       const ZopfliNode* nodes,\n+                                       const size_t num_bytes,\n+                                       const size_t pos) {\n+  /* Compute the minimum possible cost of reaching any future position. */\n+  float min_cost = start_cost;\n+  size_t len = 2;\n+  size_t next_len_bucket = 4;\n+  size_t next_len_offset = 10;\n+  while (pos + len <= num_bytes && nodes[pos + len].u.cost <= min_cost) {\n+    /* We already reached (pos + len) with no more cost than the minimum\n+       possible cost of reaching anything from this pos, so there is no point in\n+       looking for lengths <= len. */\n+    ++len;\n+    if (len == next_len_offset) {\n+      /* We reached the next copy length code bucket, so we add one more\n+         extra bit to the minimum cost. */\n+      min_cost += 1.0f;\n+      next_len_offset += next_len_bucket;\n+      next_len_bucket *= 2;\n+    }\n+  }\n+  return len;\n+}\n+\n+/* REQUIRES: nodes[pos].cost < kInfinity\n+   REQUIRES: nodes[0..pos] satisfies that \"ZopfliNode array invariant\". */\n+static uint32_t ComputeDistanceShortcut(const size_t block_start,\n+                                        const size_t pos,\n+                                        const size_t max_backward_limit,\n+                                        const size_t gap,\n+                                        const ZopfliNode* nodes) {\n+  const size_t clen = ZopfliNodeCopyLength(&nodes[pos]);\n+  const size_t ilen = nodes[pos].dcode_insert_length & 0x7FFFFFF;\n+  const size_t dist = ZopfliNodeCopyDistance(&nodes[pos]);\n+  /* Since |block_start + pos| is the end position of the command, the copy part\n+     starts from |block_start + pos - clen|. Distances that are greater than\n+     this or greater than |max_backward_limit| + |gap| are static dictionary\n+     references, and do not update the last distances.\n+     Also distance code 0 (last distance) does not update the last distances. */\n+  if (pos == 0) {\n+    return 0;\n+  } else if (dist + clen <= block_start + pos + gap &&\n+             dist <= max_backward_limit + gap &&\n+             ZopfliNodeDistanceCode(&nodes[pos]) > 0) {\n+    return (uint32_t)pos;\n+  } else {\n+    return nodes[pos - clen - ilen].u.shortcut;\n+  }\n+}\n+\n+/* Fills in dist_cache[0..3] with the last four distances (as defined by\n+   Section 4. of the Spec) that would be used at (block_start + pos) if we\n+   used the shortest path of commands from block_start, computed from\n+   nodes[0..pos]. The last four distances at block_start are in\n+   starting_dist_cache[0..3].\n+   REQUIRES: nodes[pos].cost < kInfinity\n+   REQUIRES: nodes[0..pos] satisfies that \"ZopfliNode array invariant\". */\n+static void ComputeDistanceCache(const size_t pos,\n+                                 const int* starting_dist_cache,\n+                                 const ZopfliNode* nodes,\n+                                 int* dist_cache) {\n+  int idx = 0;\n+  size_t p = nodes[pos].u.shortcut;\n+  while (idx < 4 && p > 0) {\n+    const size_t ilen = nodes[p].dcode_insert_length & 0x7FFFFFF;\n+    const size_t clen = ZopfliNodeCopyLength(&nodes[p]);\n+    const size_t dist = ZopfliNodeCopyDistance(&nodes[p]);\n+    dist_cache[idx++] = (int)dist;\n+    /* Because of prerequisite, p >= clen + ilen >= 2. */\n+    p = nodes[p - clen - ilen].u.shortcut;\n+  }\n+  for (; idx < 4; ++idx) {\n+    dist_cache[idx] = *starting_dist_cache++;\n+  }\n+}\n+\n+/* Maintains \"ZopfliNode array invariant\" and pushes node to the queue, if it\n+   is eligible. */\n+static void EvaluateNode(\n+    const size_t block_start, const size_t pos, const size_t max_backward_limit,\n+    const size_t gap, const int* starting_dist_cache,\n+    const ZopfliCostModel* model, StartPosQueue* queue, ZopfliNode* nodes) {\n+  /* Save cost, because ComputeDistanceCache invalidates it. */\n+  float node_cost = nodes[pos].u.cost;\n+  nodes[pos].u.shortcut = ComputeDistanceShortcut(\n+      block_start, pos, max_backward_limit, gap, nodes);\n+  if (node_cost <= ZopfliCostModelGetLiteralCosts(model, 0, pos)) {\n+    PosData posdata;\n+    posdata.pos = pos;\n+    posdata.cost = node_cost;\n+    posdata.costdiff = node_cost -\n+        ZopfliCostModelGetLiteralCosts(model, 0, pos);\n+    ComputeDistanceCache(\n+        pos, starting_dist_cache, nodes, posdata.distance_cache);\n+    StartPosQueuePush(queue, &posdata);\n+  }\n+}\n+\n+/* Returns longest copy length. */\n+static size_t UpdateNodes(\n+    const size_t num_bytes, const size_t block_start, const size_t pos,\n+    const uint8_t* ringbuffer, const size_t ringbuffer_mask,\n+    const BrotliEncoderParams* params, const size_t max_backward_limit,\n+    const int* starting_dist_cache, const size_t num_matches,\n+    const BackwardMatch* matches, const ZopfliCostModel* model,\n+    StartPosQueue* queue, ZopfliNode* nodes) {\n+  const size_t cur_ix = block_start + pos;\n+  const size_t cur_ix_masked = cur_ix & ringbuffer_mask;\n+  const size_t max_distance = BROTLI_MIN(size_t, cur_ix, max_backward_limit);\n+  const size_t max_len = num_bytes - pos;\n+  const size_t max_zopfli_len = MaxZopfliLen(params);\n+  const size_t max_iters = MaxZopfliCandidates(params);\n+  size_t min_len;\n+  size_t result = 0;\n+  size_t k;\n+  size_t gap = 0;\n+\n+  EvaluateNode(block_start, pos, max_backward_limit, gap, starting_dist_cache,\n+      model, queue, nodes);\n+\n+  {\n+    const PosData* posdata = StartPosQueueAt(queue, 0);\n+    float min_cost = (posdata->cost + ZopfliCostModelGetMinCostCmd(model) +\n+        ZopfliCostModelGetLiteralCosts(model, posdata->pos, pos));\n+    min_len = ComputeMinimumCopyLength(min_cost, nodes, num_bytes, pos);\n+  }\n+\n+  /* Go over the command starting positions in order of increasing cost\n+     difference. */\n+  for (k = 0; k < max_iters && k < StartPosQueueSize(queue); ++k) {\n+    const PosData* posdata = StartPosQueueAt(queue, k);\n+    const size_t start = posdata->pos;\n+    const uint16_t inscode = GetInsertLengthCode(pos - start);\n+    const float start_costdiff = posdata->costdiff;\n+    const float base_cost = start_costdiff + (float)GetInsertExtra(inscode) +\n+        ZopfliCostModelGetLiteralCosts(model, 0, pos);\n+\n+    /* Look for last distance matches using the distance cache from this\n+       starting position. */\n+    size_t best_len = min_len - 1;\n+    size_t j = 0;\n+    for (; j < BROTLI_NUM_DISTANCE_SHORT_CODES && best_len < max_len; ++j) {\n+      const size_t idx = kDistanceCacheIndex[j];\n+      const size_t backward =\n+          (size_t)(posdata->distance_cache[idx] + kDistanceCacheOffset[j]);\n+      size_t prev_ix = cur_ix - backward;\n+      size_t len = 0;\n+      uint8_t continuation = ringbuffer[cur_ix_masked + best_len];\n+      if (cur_ix_masked + best_len > ringbuffer_mask) {\n+        break;\n+      }\n+      if (BROTLI_PREDICT_FALSE(backward > max_distance + gap)) {\n+        /* Word dictionary -> ignore. */\n+        continue;\n+      }\n+      if (backward <= max_distance) {\n+        /* Regular backward reference. */\n+        if (prev_ix >= cur_ix) {\n+          continue;\n+        }\n+\n+        prev_ix &= ringbuffer_mask;\n+        if (prev_ix + best_len > ringbuffer_mask ||\n+            continuation != ringbuffer[prev_ix + best_len]) {\n+          continue;\n+        }\n+        len = FindMatchLengthWithLimit(&ringbuffer[prev_ix],\n+                                       &ringbuffer[cur_ix_masked],\n+                                       max_len);\n+      } else {\n+        continue;\n+      }\n+      {\n+        const float dist_cost = base_cost +\n+            ZopfliCostModelGetDistanceCost(model, j);\n+        size_t l;\n+        for (l = best_len + 1; l <= len; ++l) {\n+          const uint16_t copycode = GetCopyLengthCode(l);\n+          const uint16_t cmdcode =\n+              CombineLengthCodes(inscode, copycode, j == 0);\n+          const float cost = (cmdcode < 128 ? base_cost : dist_cost) +\n+              (float)GetCopyExtra(copycode) +\n+              ZopfliCostModelGetCommandCost(model, cmdcode);\n+          if (cost < nodes[pos + l].u.cost) {\n+            UpdateZopfliNode(nodes, pos, start, l, l, backward, j + 1, cost);\n+            result = BROTLI_MAX(size_t, result, l);\n+          }\n+          best_len = l;\n+        }\n+      }\n+    }\n+\n+    /* At higher iterations look only for new last distance matches, since\n+       looking only for new command start positions with the same distances\n+       does not help much. */\n+    if (k >= 2) continue;\n+\n+    {\n+      /* Loop through all possible copy lengths at this position. */\n+      size_t len = min_len;\n+      for (j = 0; j < num_matches; ++j) {\n+        BackwardMatch match = matches[j];\n+        size_t dist = match.distance;\n+        BROTLI_BOOL is_dictionary_match =\n+            TO_BROTLI_BOOL(dist > max_distance + gap);\n+        /* We already tried all possible last distance matches, so we can use\n+           normal distance code here. */\n+        size_t dist_code = dist + BROTLI_NUM_DISTANCE_SHORT_CODES - 1;\n+        uint16_t dist_symbol;\n+        uint32_t distextra;\n+        uint32_t distnumextra;\n+        float dist_cost;\n+        size_t max_match_len;\n+        PrefixEncodeCopyDistance(\n+            dist_code, params->dist.num_direct_distance_codes,\n+            params->dist.distance_postfix_bits, &dist_symbol, &distextra);\n+        distnumextra = dist_symbol >> 10;\n+        dist_cost = base_cost + (float)distnumextra +\n+            ZopfliCostModelGetDistanceCost(model, dist_symbol & 0x3FF);\n+\n+        /* Try all copy lengths up until the maximum copy length corresponding\n+           to this distance. If the distance refers to the static dictionary, or\n+           the maximum length is long enough, try only one maximum length. */\n+        max_match_len = BackwardMatchLength(&match);\n+        if (len < max_match_len &&\n+            (is_dictionary_match || max_match_len > max_zopfli_len)) {\n+          len = max_match_len;\n+        }\n+        for (; len <= max_match_len; ++len) {\n+          const size_t len_code =\n+              is_dictionary_match ? BackwardMatchLengthCode(&match) : len;\n+          const uint16_t copycode = GetCopyLengthCode(len_code);\n+          const uint16_t cmdcode = CombineLengthCodes(inscode, copycode, 0);\n+          const float cost = dist_cost + (float)GetCopyExtra(copycode) +\n+              ZopfliCostModelGetCommandCost(model, cmdcode);\n+          if (cost < nodes[pos + len].u.cost) {\n+            UpdateZopfliNode(nodes, pos, start, len, len_code, dist, 0, cost);\n+            result = BROTLI_MAX(size_t, result, len);\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+static size_t ComputeShortestPathFromNodes(size_t num_bytes,\n+    ZopfliNode* nodes) {\n+  size_t index = num_bytes;\n+  size_t num_commands = 0;\n+  while ((nodes[index].dcode_insert_length & 0x7FFFFFF) == 0 &&\n+      nodes[index].length == 1) --index;\n+  nodes[index].u.next = BROTLI_UINT32_MAX;\n+  while (index != 0) {\n+    size_t len = ZopfliNodeCommandLength(&nodes[index]);\n+    index -= len;\n+    nodes[index].u.next = (uint32_t)len;\n+    num_commands++;\n+  }\n+  return num_commands;\n+}\n+\n+/* REQUIRES: nodes != NULL and len(nodes) >= num_bytes + 1 */\n+void BrotliZopfliCreateCommands(const size_t num_bytes,\n+    const size_t block_start, const ZopfliNode* nodes, int* dist_cache,\n+    size_t* last_insert_len, const BrotliEncoderParams* params,\n+    Command* commands, size_t* num_literals) {\n+  const size_t max_backward_limit = BROTLI_MAX_BACKWARD_LIMIT(params->lgwin);\n+  size_t pos = 0;\n+  uint32_t offset = nodes[0].u.next;\n+  size_t i;\n+  size_t gap = 0;\n+  for (i = 0; offset != BROTLI_UINT32_MAX; i++) {\n+    const ZopfliNode* next = &nodes[pos + offset];\n+    size_t copy_length = ZopfliNodeCopyLength(next);\n+    size_t insert_length = next->dcode_insert_length & 0x7FFFFFF;\n+    pos += insert_length;\n+    offset = next->u.next;\n+    if (i == 0) {\n+      insert_length += *last_insert_len;\n+      *last_insert_len = 0;\n+    }\n+    {\n+      size_t distance = ZopfliNodeCopyDistance(next);\n+      size_t len_code = ZopfliNodeLengthCode(next);\n+      size_t max_distance =\n+          BROTLI_MIN(size_t, block_start + pos, max_backward_limit);\n+      BROTLI_BOOL is_dictionary = TO_BROTLI_BOOL(distance > max_distance + gap);\n+      size_t dist_code = ZopfliNodeDistanceCode(next);\n+      InitCommand(&commands[i], &params->dist, insert_length,\n+          copy_length, (int)len_code - (int)copy_length, dist_code);\n+\n+      if (!is_dictionary && dist_code > 0) {\n+        dist_cache[3] = dist_cache[2];\n+        dist_cache[2] = dist_cache[1];\n+        dist_cache[1] = dist_cache[0];\n+        dist_cache[0] = (int)distance;\n+      }\n+    }\n+\n+    *num_literals += insert_length;\n+    pos += copy_length;\n+  }\n+  *last_insert_len += num_bytes - pos;\n+}\n+\n+static size_t ZopfliIterate(size_t num_bytes, size_t position,\n+    const uint8_t* ringbuffer, size_t ringbuffer_mask,\n+    const BrotliEncoderParams* params, const size_t gap, const int* dist_cache,\n+    const ZopfliCostModel* model, const uint32_t* num_matches,\n+    const BackwardMatch* matches, ZopfliNode* nodes) {\n+  const size_t max_backward_limit = BROTLI_MAX_BACKWARD_LIMIT(params->lgwin);\n+  const size_t max_zopfli_len = MaxZopfliLen(params);\n+  StartPosQueue queue;\n+  size_t cur_match_pos = 0;\n+  size_t i;\n+  nodes[0].length = 0;\n+  nodes[0].u.cost = 0;\n+  InitStartPosQueue(&queue);\n+  for (i = 0; i + 3 < num_bytes; i++) {\n+    size_t skip = UpdateNodes(num_bytes, position, i, ringbuffer,\n+        ringbuffer_mask, params, max_backward_limit, dist_cache,\n+        num_matches[i], &matches[cur_match_pos], model, &queue, nodes);\n+    if (skip < BROTLI_LONG_COPY_QUICK_STEP) skip = 0;\n+    cur_match_pos += num_matches[i];\n+    if (num_matches[i] == 1 &&\n+        BackwardMatchLength(&matches[cur_match_pos - 1]) > max_zopfli_len) {\n+      skip = BROTLI_MAX(size_t,\n+          BackwardMatchLength(&matches[cur_match_pos - 1]), skip);\n+    }\n+    if (skip > 1) {\n+      skip--;\n+      while (skip) {\n+        i++;\n+        if (i + 3 >= num_bytes) break;\n+        EvaluateNode(position, i, max_backward_limit, gap,\n+            dist_cache, model, &queue, nodes);\n+        cur_match_pos += num_matches[i];\n+        skip--;\n+      }\n+    }\n+  }\n+  return ComputeShortestPathFromNodes(num_bytes, nodes);\n+}\n+\n+/* REQUIRES: nodes != NULL and len(nodes) >= num_bytes + 1 */\n+size_t BrotliZopfliComputeShortestPath(MemoryManager* m, size_t num_bytes,\n+    size_t position, const uint8_t* ringbuffer, size_t ringbuffer_mask,\n+    const BrotliEncoderParams* params,\n+    const int* dist_cache, HasherHandle hasher, ZopfliNode* nodes) {\n+  const size_t max_backward_limit = BROTLI_MAX_BACKWARD_LIMIT(params->lgwin);\n+  const size_t max_zopfli_len = MaxZopfliLen(params);\n+  ZopfliCostModel model;\n+  StartPosQueue queue;\n+  BackwardMatch matches[2 * (MAX_NUM_MATCHES_H10 + 64)];\n+  const size_t store_end = num_bytes >= StoreLookaheadH10() ?\n+      position + num_bytes - StoreLookaheadH10() + 1 : position;\n+  size_t i;\n+  size_t gap = 0;\n+  size_t lz_matches_offset = 0;\n+  nodes[0].length = 0;\n+  nodes[0].u.cost = 0;\n+  InitZopfliCostModel(m, &model, &params->dist, num_bytes);\n+  if (BROTLI_IS_OOM(m)) return 0;\n+  ZopfliCostModelSetFromLiteralCosts(\n+      &model, position, ringbuffer, ringbuffer_mask);\n+  InitStartPosQueue(&queue);\n+  for (i = 0; i + HashTypeLengthH10() - 1 < num_bytes; i++) {\n+    const size_t pos = position + i;\n+    const size_t max_distance = BROTLI_MIN(size_t, pos, max_backward_limit);\n+    size_t skip;\n+    size_t num_matches;\n+    num_matches = FindAllMatchesH10(hasher,\n+        &params->dictionary,\n+        ringbuffer, ringbuffer_mask, pos, num_bytes - i, max_distance,\n+        gap, params, &matches[lz_matches_offset]);\n+    if (num_matches > 0 &&\n+        BackwardMatchLength(&matches[num_matches - 1]) > max_zopfli_len) {\n+      matches[0] = matches[num_matches - 1];\n+      num_matches = 1;\n+    }\n+    skip = UpdateNodes(num_bytes, position, i, ringbuffer, ringbuffer_mask,\n+        params, max_backward_limit, dist_cache, num_matches, matches, &model,\n+        &queue, nodes);\n+    if (skip < BROTLI_LONG_COPY_QUICK_STEP) skip = 0;\n+    if (num_matches == 1 && BackwardMatchLength(&matches[0]) > max_zopfli_len) {\n+      skip = BROTLI_MAX(size_t, BackwardMatchLength(&matches[0]), skip);\n+    }\n+    if (skip > 1) {\n+      /* Add the tail of the copy to the hasher. */\n+      StoreRangeH10(hasher, ringbuffer, ringbuffer_mask, pos + 1, BROTLI_MIN(\n+          size_t, pos + skip, store_end));\n+      skip--;\n+      while (skip) {\n+        i++;\n+        if (i + HashTypeLengthH10() - 1 >= num_bytes) break;\n+        EvaluateNode(position, i, max_backward_limit, gap,\n+            dist_cache, &model, &queue, nodes);\n+        skip--;\n+      }\n+    }\n+  }\n+  CleanupZopfliCostModel(m, &model);\n+  return ComputeShortestPathFromNodes(num_bytes, nodes);\n+}\n+\n+void BrotliCreateZopfliBackwardReferences(MemoryManager* m, size_t num_bytes,\n+    size_t position, const uint8_t* ringbuffer, size_t ringbuffer_mask,\n+    const BrotliEncoderParams* params,\n+    HasherHandle hasher, int* dist_cache, size_t* last_insert_len,\n+    Command* commands, size_t* num_commands, size_t* num_literals) {\n+  ZopfliNode* nodes;\n+  nodes = BROTLI_ALLOC(m, ZopfliNode, num_bytes + 1);\n+  if (BROTLI_IS_OOM(m)) return;\n+  BrotliInitZopfliNodes(nodes, num_bytes + 1);\n+  *num_commands += BrotliZopfliComputeShortestPath(m, num_bytes,\n+      position, ringbuffer, ringbuffer_mask, params,\n+      dist_cache, hasher, nodes);\n+  if (BROTLI_IS_OOM(m)) return;\n+  BrotliZopfliCreateCommands(num_bytes, position, nodes, dist_cache,\n+      last_insert_len, params, commands, num_literals);\n+  BROTLI_FREE(m, nodes);\n+}\n+\n+void BrotliCreateHqZopfliBackwardReferences(MemoryManager* m, size_t num_bytes,\n+    size_t position, const uint8_t* ringbuffer, size_t ringbuffer_mask,\n+    const BrotliEncoderParams* params,\n+    HasherHandle hasher, int* dist_cache, size_t* last_insert_len,\n+    Command* commands, size_t* num_commands, size_t* num_literals) {\n+  const size_t max_backward_limit = BROTLI_MAX_BACKWARD_LIMIT(params->lgwin);\n+  uint32_t* num_matches = BROTLI_ALLOC(m, uint32_t, num_bytes);\n+  size_t matches_size = 4 * num_bytes;\n+  const size_t store_end = num_bytes >= StoreLookaheadH10() ?\n+      position + num_bytes - StoreLookaheadH10() + 1 : position;\n+  size_t cur_match_pos = 0;\n+  size_t i;\n+  size_t orig_num_literals;\n+  size_t orig_last_insert_len;\n+  int orig_dist_cache[4];\n+  size_t orig_num_commands;\n+  ZopfliCostModel model;\n+  ZopfliNode* nodes;\n+  BackwardMatch* matches = BROTLI_ALLOC(m, BackwardMatch, matches_size);\n+  size_t gap = 0;\n+  size_t shadow_matches = 0;\n+  if (BROTLI_IS_OOM(m)) return;\n+  for (i = 0; i + HashTypeLengthH10() - 1 < num_bytes; ++i) {\n+    const size_t pos = position + i;\n+    size_t max_distance = BROTLI_MIN(size_t, pos, max_backward_limit);\n+    size_t max_length = num_bytes - i;\n+    size_t num_found_matches;\n+    size_t cur_match_end;\n+    size_t j;\n+    /* Ensure that we have enough free slots. */\n+    BROTLI_ENSURE_CAPACITY(m, BackwardMatch, matches, matches_size,\n+        cur_match_pos + MAX_NUM_MATCHES_H10 + shadow_matches);\n+    if (BROTLI_IS_OOM(m)) return;\n+    num_found_matches = FindAllMatchesH10(hasher,\n+        &params->dictionary,\n+        ringbuffer, ringbuffer_mask, pos, max_length,\n+        max_distance, gap, params,\n+        &matches[cur_match_pos + shadow_matches]);\n+    cur_match_end = cur_match_pos + num_found_matches;\n+    for (j = cur_match_pos; j + 1 < cur_match_end; ++j) {\n+      BROTLI_DCHECK(BackwardMatchLength(&matches[j]) <=\n+          BackwardMatchLength(&matches[j + 1]));\n+    }\n+    num_matches[i] = (uint32_t)num_found_matches;\n+    if (num_found_matches > 0) {\n+      const size_t match_len = BackwardMatchLength(&matches[cur_match_end - 1]);\n+      if (match_len > MAX_ZOPFLI_LEN_QUALITY_11) {\n+        const size_t skip = match_len - 1;\n+        matches[cur_match_pos++] = matches[cur_match_end - 1];\n+        num_matches[i] = 1;\n+        /* Add the tail of the copy to the hasher. */\n+        StoreRangeH10(hasher, ringbuffer, ringbuffer_mask, pos + 1,\n+                      BROTLI_MIN(size_t, pos + match_len, store_end));\n+        memset(&num_matches[i + 1], 0, skip * sizeof(num_matches[0]));\n+        i += skip;\n+      } else {\n+        cur_match_pos = cur_match_end;\n+      }\n+    }\n+  }\n+  orig_num_literals = *num_literals;\n+  orig_last_insert_len = *last_insert_len;\n+  memcpy(orig_dist_cache, dist_cache, 4 * sizeof(dist_cache[0]));\n+  orig_num_commands = *num_commands;\n+  nodes = BROTLI_ALLOC(m, ZopfliNode, num_bytes + 1);\n+  if (BROTLI_IS_OOM(m)) return;\n+  InitZopfliCostModel(m, &model, &params->dist, num_bytes);\n+  if (BROTLI_IS_OOM(m)) return;\n+  for (i = 0; i < 2; i++) {\n+    BrotliInitZopfliNodes(nodes, num_bytes + 1);\n+    if (i == 0) {\n+      ZopfliCostModelSetFromLiteralCosts(\n+          &model, position, ringbuffer, ringbuffer_mask);\n+    } else {\n+      ZopfliCostModelSetFromCommands(&model, position, ringbuffer,\n+          ringbuffer_mask, commands, *num_commands - orig_num_commands,\n+          orig_last_insert_len);\n+    }\n+    *num_commands = orig_num_commands;\n+    *num_literals = orig_num_literals;\n+    *last_insert_len = orig_last_insert_len;\n+    memcpy(dist_cache, orig_dist_cache, 4 * sizeof(dist_cache[0]));\n+    *num_commands += ZopfliIterate(num_bytes, position, ringbuffer,\n+        ringbuffer_mask, params, gap, dist_cache, &model, num_matches, matches,\n+        nodes);\n+    BrotliZopfliCreateCommands(num_bytes, position, nodes, dist_cache,\n+        last_insert_len, params, commands, num_literals);\n+  }\n+  CleanupZopfliCostModel(m, &model);\n+  BROTLI_FREE(m, nodes);\n+  BROTLI_FREE(m, matches);\n+  BROTLI_FREE(m, num_matches);\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "1e4275d403f96fcd2c111d3db6bdad12813d1c9d",
            "filename": "deps/brotli/c/enc/backward_references_hq.h",
            "status": "added",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references_hq.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references_hq.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references_hq.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,92 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Function to find backward reference copies. */\n+\n+#ifndef BROTLI_ENC_BACKWARD_REFERENCES_HQ_H_\n+#define BROTLI_ENC_BACKWARD_REFERENCES_HQ_H_\n+\n+#include \"../common/constants.h\"\n+#include \"../common/dictionary.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./command.h\"\n+#include \"./hash.h\"\n+#include \"./memory.h\"\n+#include \"./quality.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+BROTLI_INTERNAL void BrotliCreateZopfliBackwardReferences(MemoryManager* m,\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ringbuffer_mask, const BrotliEncoderParams* params,\n+    HasherHandle hasher, int* dist_cache, size_t* last_insert_len,\n+    Command* commands, size_t* num_commands, size_t* num_literals);\n+\n+BROTLI_INTERNAL void BrotliCreateHqZopfliBackwardReferences(MemoryManager* m,\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ringbuffer_mask, const BrotliEncoderParams* params,\n+    HasherHandle hasher, int* dist_cache, size_t* last_insert_len,\n+    Command* commands, size_t* num_commands, size_t* num_literals);\n+\n+typedef struct ZopfliNode {\n+  /* Best length to get up to this byte (not including this byte itself)\n+     highest 7 bit is used to reconstruct the length code. */\n+  uint32_t length;\n+  /* Distance associated with the length. */\n+  uint32_t distance;\n+  /* Number of literal inserts before this copy; highest 5 bits contain\n+     distance short code + 1 (or zero if no short code). */\n+  uint32_t dcode_insert_length;\n+\n+  /* This union holds information used by dynamic-programming. During forward\n+     pass |cost| it used to store the goal function. When node is processed its\n+     |cost| is invalidated in favor of |shortcut|. On path back-tracing pass\n+     |next| is assigned the offset to next node on the path. */\n+  union {\n+    /* Smallest cost to get to this byte from the beginning, as found so far. */\n+    float cost;\n+    /* Offset to the next node on the path. Equals to command_length() of the\n+       next node on the path. For last node equals to BROTLI_UINT32_MAX */\n+    uint32_t next;\n+    /* Node position that provides next distance for distance cache. */\n+    uint32_t shortcut;\n+  } u;\n+} ZopfliNode;\n+\n+BROTLI_INTERNAL void BrotliInitZopfliNodes(ZopfliNode* array, size_t length);\n+\n+/* Computes the shortest path of commands from position to at most\n+   position + num_bytes.\n+\n+   On return, path->size() is the number of commands found and path[i] is the\n+   length of the i-th command (copy length plus insert length).\n+   Note that the sum of the lengths of all commands can be less than num_bytes.\n+\n+   On return, the nodes[0..num_bytes] array will have the following\n+   \"ZopfliNode array invariant\":\n+   For each i in [1..num_bytes], if nodes[i].cost < kInfinity, then\n+     (1) nodes[i].copy_length() >= 2\n+     (2) nodes[i].command_length() <= i and\n+     (3) nodes[i - nodes[i].command_length()].cost < kInfinity */\n+BROTLI_INTERNAL size_t BrotliZopfliComputeShortestPath(\n+    MemoryManager* m, size_t num_bytes,\n+    size_t position, const uint8_t* ringbuffer, size_t ringbuffer_mask,\n+    const BrotliEncoderParams* params,\n+    const int* dist_cache, HasherHandle hasher, ZopfliNode* nodes);\n+\n+BROTLI_INTERNAL void BrotliZopfliCreateCommands(\n+    const size_t num_bytes, const size_t block_start, const ZopfliNode* nodes,\n+    int* dist_cache, size_t* last_insert_len, const BrotliEncoderParams* params,\n+    Command* commands, size_t* num_literals);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_BACKWARD_REFERENCES_HQ_H_ */"
        },
        {
            "sha": "c18cdb00cb9b07e2b31932a2c01e7ecc84e94bf2",
            "filename": "deps/brotli/c/enc/backward_references_inc.h",
            "status": "added",
            "additions": 153,
            "deletions": 0,
            "changes": 153,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbackward_references_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,153 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: EXPORT_FN, FN */\n+\n+static BROTLI_NOINLINE void EXPORT_FN(CreateBackwardReferences)(\n+    size_t num_bytes, size_t position,\n+    const uint8_t* ringbuffer, size_t ringbuffer_mask,\n+    const BrotliEncoderParams* params,\n+    HasherHandle hasher, int* dist_cache, size_t* last_insert_len,\n+    Command* commands, size_t* num_commands, size_t* num_literals) {\n+  /* Set maximum distance, see section 9.1. of the spec. */\n+  const size_t max_backward_limit = BROTLI_MAX_BACKWARD_LIMIT(params->lgwin);\n+\n+  const Command* const orig_commands = commands;\n+  size_t insert_length = *last_insert_len;\n+  const size_t pos_end = position + num_bytes;\n+  const size_t store_end = num_bytes >= FN(StoreLookahead)() ?\n+      position + num_bytes - FN(StoreLookahead)() + 1 : position;\n+\n+  /* For speed up heuristics for random data. */\n+  const size_t random_heuristics_window_size =\n+      LiteralSpreeLengthForSparseSearch(params);\n+  size_t apply_random_heuristics = position + random_heuristics_window_size;\n+  const size_t gap = 0;\n+\n+  /* Minimum score to accept a backward reference. */\n+  const score_t kMinScore = BROTLI_SCORE_BASE + 100;\n+\n+  FN(PrepareDistanceCache)(hasher, dist_cache);\n+\n+  while (position + FN(HashTypeLength)() < pos_end) {\n+    size_t max_length = pos_end - position;\n+    size_t max_distance = BROTLI_MIN(size_t, position, max_backward_limit);\n+    HasherSearchResult sr;\n+    sr.len = 0;\n+    sr.len_code_delta = 0;\n+    sr.distance = 0;\n+    sr.score = kMinScore;\n+    FN(FindLongestMatch)(hasher, &params->dictionary,\n+        ringbuffer, ringbuffer_mask, dist_cache, position, max_length,\n+        max_distance, gap, params->dist.max_distance, &sr);\n+    if (sr.score > kMinScore) {\n+      /* Found a match. Let's look for something even better ahead. */\n+      int delayed_backward_references_in_row = 0;\n+      --max_length;\n+      for (;; --max_length) {\n+        const score_t cost_diff_lazy = 175;\n+        HasherSearchResult sr2;\n+        sr2.len = params->quality < MIN_QUALITY_FOR_EXTENSIVE_REFERENCE_SEARCH ?\n+            BROTLI_MIN(size_t, sr.len - 1, max_length) : 0;\n+        sr2.len_code_delta = 0;\n+        sr2.distance = 0;\n+        sr2.score = kMinScore;\n+        max_distance = BROTLI_MIN(size_t, position + 1, max_backward_limit);\n+        FN(FindLongestMatch)(hasher,\n+            &params->dictionary,\n+            ringbuffer, ringbuffer_mask, dist_cache, position + 1, max_length,\n+            max_distance, gap, params->dist.max_distance, &sr2);\n+        if (sr2.score >= sr.score + cost_diff_lazy) {\n+          /* Ok, let's just write one byte for now and start a match from the\n+             next byte. */\n+          ++position;\n+          ++insert_length;\n+          sr = sr2;\n+          if (++delayed_backward_references_in_row < 4 &&\n+              position + FN(HashTypeLength)() < pos_end) {\n+            continue;\n+          }\n+        }\n+        break;\n+      }\n+      apply_random_heuristics =\n+          position + 2 * sr.len + random_heuristics_window_size;\n+      max_distance = BROTLI_MIN(size_t, position, max_backward_limit);\n+      {\n+        /* The first 16 codes are special short-codes,\n+           and the minimum offset is 1. */\n+        size_t distance_code = ComputeDistanceCode(\n+            sr.distance, max_distance + gap, dist_cache);\n+        if ((sr.distance <= (max_distance + gap)) && distance_code > 0) {\n+          dist_cache[3] = dist_cache[2];\n+          dist_cache[2] = dist_cache[1];\n+          dist_cache[1] = dist_cache[0];\n+          dist_cache[0] = (int)sr.distance;\n+          FN(PrepareDistanceCache)(hasher, dist_cache);\n+        }\n+        InitCommand(commands++, &params->dist, insert_length,\n+            sr.len, sr.len_code_delta, distance_code);\n+      }\n+      *num_literals += insert_length;\n+      insert_length = 0;\n+      /* Put the hash keys into the table, if there are enough bytes left.\n+         Depending on the hasher implementation, it can push all positions\n+         in the given range or only a subset of them.\n+         Avoid hash poisoning with RLE data. */\n+      {\n+        size_t range_start = position + 2;\n+        size_t range_end = BROTLI_MIN(size_t, position + sr.len, store_end);\n+        if (sr.distance < (sr.len >> 2)) {\n+          range_start = BROTLI_MIN(size_t, range_end, BROTLI_MAX(size_t,\n+              range_start, position + sr.len - (sr.distance << 2)));\n+        }\n+        FN(StoreRange)(hasher, ringbuffer, ringbuffer_mask, range_start,\n+                       range_end);\n+      }\n+      position += sr.len;\n+    } else {\n+      ++insert_length;\n+      ++position;\n+      /* If we have not seen matches for a long time, we can skip some\n+         match lookups. Unsuccessful match lookups are very very expensive\n+         and this kind of a heuristic speeds up compression quite\n+         a lot. */\n+      if (position > apply_random_heuristics) {\n+        /* Going through uncompressible data, jump. */\n+        if (position >\n+            apply_random_heuristics + 4 * random_heuristics_window_size) {\n+          /* It is quite a long time since we saw a copy, so we assume\n+             that this data is not compressible, and store hashes less\n+             often. Hashes of non compressible data are less likely to\n+             turn out to be useful in the future, too, so we store less of\n+             them to not to flood out the hash table of good compressible\n+             data. */\n+          const size_t kMargin =\n+              BROTLI_MAX(size_t, FN(StoreLookahead)() - 1, 4);\n+          size_t pos_jump =\n+              BROTLI_MIN(size_t, position + 16, pos_end - kMargin);\n+          for (; position < pos_jump; position += 4) {\n+            FN(Store)(hasher, ringbuffer, ringbuffer_mask, position);\n+            insert_length += 4;\n+          }\n+        } else {\n+          const size_t kMargin =\n+              BROTLI_MAX(size_t, FN(StoreLookahead)() - 1, 2);\n+          size_t pos_jump =\n+              BROTLI_MIN(size_t, position + 8, pos_end - kMargin);\n+          for (; position < pos_jump; position += 2) {\n+            FN(Store)(hasher, ringbuffer, ringbuffer_mask, position);\n+            insert_length += 2;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  insert_length += pos_end - position;\n+  *last_insert_len = insert_length;\n+  *num_commands += (size_t)(commands - orig_commands);\n+}"
        },
        {
            "sha": "1f3f7ad5c90486797e235bb7279b8b6ffb159511",
            "filename": "deps/brotli/c/enc/bit_cost.c",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbit_cost.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbit_cost.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbit_cost.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,35 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Functions to estimate the bit cost of Huffman trees. */\n+\n+#include \"./bit_cost.h\"\n+\n+#include \"../common/constants.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./fast_log.h\"\n+#include \"./histogram.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define FN(X) X ## Literal\n+#include \"./bit_cost_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#define FN(X) X ## Command\n+#include \"./bit_cost_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#define FN(X) X ## Distance\n+#include \"./bit_cost_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "6586469e62ff9df422a50ce9e4c9005c10bf680d",
            "filename": "deps/brotli/c/enc/bit_cost.h",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbit_cost.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbit_cost.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbit_cost.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,63 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Functions to estimate the bit cost of Huffman trees. */\n+\n+#ifndef BROTLI_ENC_BIT_COST_H_\n+#define BROTLI_ENC_BIT_COST_H_\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./fast_log.h\"\n+#include \"./histogram.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+static BROTLI_INLINE double ShannonEntropy(\n+    const uint32_t* population, size_t size, size_t* total) {\n+  size_t sum = 0;\n+  double retval = 0;\n+  const uint32_t* population_end = population + size;\n+  size_t p;\n+  if (size & 1) {\n+    goto odd_number_of_elements_left;\n+  }\n+  while (population < population_end) {\n+    p = *population++;\n+    sum += p;\n+    retval -= (double)p * FastLog2(p);\n+ odd_number_of_elements_left:\n+    p = *population++;\n+    sum += p;\n+    retval -= (double)p * FastLog2(p);\n+  }\n+  if (sum) retval += (double)sum * FastLog2(sum);\n+  *total = sum;\n+  return retval;\n+}\n+\n+static BROTLI_INLINE double BitsEntropy(\n+    const uint32_t* population, size_t size) {\n+  size_t sum;\n+  double retval = ShannonEntropy(population, size, &sum);\n+  if (retval < sum) {\n+    /* At least one bit per literal is needed. */\n+    retval = (double)sum;\n+  }\n+  return retval;\n+}\n+\n+BROTLI_INTERNAL double BrotliPopulationCostLiteral(const HistogramLiteral*);\n+BROTLI_INTERNAL double BrotliPopulationCostCommand(const HistogramCommand*);\n+BROTLI_INTERNAL double BrotliPopulationCostDistance(const HistogramDistance*);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_BIT_COST_H_ */"
        },
        {
            "sha": "453c22604209327a8691e995a12b74a81d603754",
            "filename": "deps/brotli/c/enc/bit_cost_inc.h",
            "status": "added",
            "additions": 127,
            "deletions": 0,
            "changes": 127,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbit_cost_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbit_cost_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbit_cost_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,127 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN */\n+\n+#define HistogramType FN(Histogram)\n+\n+double FN(BrotliPopulationCost)(const HistogramType* histogram) {\n+  static const double kOneSymbolHistogramCost = 12;\n+  static const double kTwoSymbolHistogramCost = 20;\n+  static const double kThreeSymbolHistogramCost = 28;\n+  static const double kFourSymbolHistogramCost = 37;\n+  const size_t data_size = FN(HistogramDataSize)();\n+  int count = 0;\n+  size_t s[5];\n+  double bits = 0.0;\n+  size_t i;\n+  if (histogram->total_count_ == 0) {\n+    return kOneSymbolHistogramCost;\n+  }\n+  for (i = 0; i < data_size; ++i) {\n+    if (histogram->data_[i] > 0) {\n+      s[count] = i;\n+      ++count;\n+      if (count > 4) break;\n+    }\n+  }\n+  if (count == 1) {\n+    return kOneSymbolHistogramCost;\n+  }\n+  if (count == 2) {\n+    return (kTwoSymbolHistogramCost + (double)histogram->total_count_);\n+  }\n+  if (count == 3) {\n+    const uint32_t histo0 = histogram->data_[s[0]];\n+    const uint32_t histo1 = histogram->data_[s[1]];\n+    const uint32_t histo2 = histogram->data_[s[2]];\n+    const uint32_t histomax =\n+        BROTLI_MAX(uint32_t, histo0, BROTLI_MAX(uint32_t, histo1, histo2));\n+    return (kThreeSymbolHistogramCost +\n+            2 * (histo0 + histo1 + histo2) - histomax);\n+  }\n+  if (count == 4) {\n+    uint32_t histo[4];\n+    uint32_t h23;\n+    uint32_t histomax;\n+    for (i = 0; i < 4; ++i) {\n+      histo[i] = histogram->data_[s[i]];\n+    }\n+    /* Sort */\n+    for (i = 0; i < 4; ++i) {\n+      size_t j;\n+      for (j = i + 1; j < 4; ++j) {\n+        if (histo[j] > histo[i]) {\n+          BROTLI_SWAP(uint32_t, histo, j, i);\n+        }\n+      }\n+    }\n+    h23 = histo[2] + histo[3];\n+    histomax = BROTLI_MAX(uint32_t, h23, histo[0]);\n+    return (kFourSymbolHistogramCost +\n+            3 * h23 + 2 * (histo[0] + histo[1]) - histomax);\n+  }\n+\n+  {\n+    /* In this loop we compute the entropy of the histogram and simultaneously\n+       build a simplified histogram of the code length codes where we use the\n+       zero repeat code 17, but we don't use the non-zero repeat code 16. */\n+    size_t max_depth = 1;\n+    uint32_t depth_histo[BROTLI_CODE_LENGTH_CODES] = { 0 };\n+    const double log2total = FastLog2(histogram->total_count_);\n+    for (i = 0; i < data_size;) {\n+      if (histogram->data_[i] > 0) {\n+        /* Compute -log2(P(symbol)) = -log2(count(symbol)/total_count) =\n+                                    = log2(total_count) - log2(count(symbol)) */\n+        double log2p = log2total - FastLog2(histogram->data_[i]);\n+        /* Approximate the bit depth by round(-log2(P(symbol))) */\n+        size_t depth = (size_t)(log2p + 0.5);\n+        bits += histogram->data_[i] * log2p;\n+        if (depth > 15) {\n+          depth = 15;\n+        }\n+        if (depth > max_depth) {\n+          max_depth = depth;\n+        }\n+        ++depth_histo[depth];\n+        ++i;\n+      } else {\n+        /* Compute the run length of zeros and add the appropriate number of 0\n+           and 17 code length codes to the code length code histogram. */\n+        uint32_t reps = 1;\n+        size_t k;\n+        for (k = i + 1; k < data_size && histogram->data_[k] == 0; ++k) {\n+          ++reps;\n+        }\n+        i += reps;\n+        if (i == data_size) {\n+          /* Don't add any cost for the last zero run, since these are encoded\n+             only implicitly. */\n+          break;\n+        }\n+        if (reps < 3) {\n+          depth_histo[0] += reps;\n+        } else {\n+          reps -= 2;\n+          while (reps > 0) {\n+            ++depth_histo[BROTLI_REPEAT_ZERO_CODE_LENGTH];\n+            /* Add the 3 extra bits for the 17 code length code. */\n+            bits += 3;\n+            reps >>= 3;\n+          }\n+        }\n+      }\n+    }\n+    /* Add the estimated encoding cost of the code length code histogram. */\n+    bits += (double)(18 + 2 * max_depth);\n+    /* Add the entropy of the code length code histogram. */\n+    bits += BitsEntropy(depth_histo, BROTLI_CODE_LENGTH_CODES);\n+  }\n+  return bits;\n+}\n+\n+#undef HistogramType"
        },
        {
            "sha": "8cbd5eac67b2a23579358464b74dab9c6e7e5363",
            "filename": "deps/brotli/c/enc/block_encoder_inc.h",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fblock_encoder_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fblock_encoder_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fblock_encoder_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,34 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2014 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN */\n+\n+#define HistogramType FN(Histogram)\n+\n+/* Creates entropy codes for all block types and stores them to the bit\n+   stream. */\n+static void FN(BuildAndStoreEntropyCodes)(MemoryManager* m, BlockEncoder* self,\n+    const HistogramType* histograms, const size_t histograms_size,\n+    const size_t alphabet_size, HuffmanTree* tree,\n+    size_t* storage_ix, uint8_t* storage) {\n+  const size_t table_size = histograms_size * self->histogram_length_;\n+  self->depths_ = BROTLI_ALLOC(m, uint8_t, table_size);\n+  self->bits_ = BROTLI_ALLOC(m, uint16_t, table_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  {\n+    size_t i;\n+    for (i = 0; i < histograms_size; ++i) {\n+      size_t ix = i * self->histogram_length_;\n+      BuildAndStoreHuffmanTree(&histograms[i].data_[0], self->histogram_length_,\n+          alphabet_size, tree, &self->depths_[ix], &self->bits_[ix],\n+          storage_ix, storage);\n+    }\n+  }\n+}\n+\n+#undef HistogramType"
        },
        {
            "sha": "d308eca59d300b5df5eccc1d2776f2af116c8a68",
            "filename": "deps/brotli/c/enc/block_splitter.c",
            "status": "added",
            "additions": 194,
            "deletions": 0,
            "changes": 194,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fblock_splitter.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fblock_splitter.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fblock_splitter.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,194 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Block split point selection utilities. */\n+\n+#include \"./block_splitter.h\"\n+\n+#include <string.h>  /* memcpy, memset */\n+\n+#include \"../common/platform.h\"\n+#include \"./bit_cost.h\"\n+#include \"./cluster.h\"\n+#include \"./command.h\"\n+#include \"./fast_log.h\"\n+#include \"./histogram.h\"\n+#include \"./memory.h\"\n+#include \"./quality.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+static const size_t kMaxLiteralHistograms = 100;\n+static const size_t kMaxCommandHistograms = 50;\n+static const double kLiteralBlockSwitchCost = 28.1;\n+static const double kCommandBlockSwitchCost = 13.5;\n+static const double kDistanceBlockSwitchCost = 14.6;\n+static const size_t kLiteralStrideLength = 70;\n+static const size_t kCommandStrideLength = 40;\n+static const size_t kSymbolsPerLiteralHistogram = 544;\n+static const size_t kSymbolsPerCommandHistogram = 530;\n+static const size_t kSymbolsPerDistanceHistogram = 544;\n+static const size_t kMinLengthForBlockSplitting = 128;\n+static const size_t kIterMulForRefining = 2;\n+static const size_t kMinItersForRefining = 100;\n+\n+static size_t CountLiterals(const Command* cmds, const size_t num_commands) {\n+  /* Count how many we have. */\n+  size_t total_length = 0;\n+  size_t i;\n+  for (i = 0; i < num_commands; ++i) {\n+    total_length += cmds[i].insert_len_;\n+  }\n+  return total_length;\n+}\n+\n+static void CopyLiteralsToByteArray(const Command* cmds,\n+                                    const size_t num_commands,\n+                                    const uint8_t* data,\n+                                    const size_t offset,\n+                                    const size_t mask,\n+                                    uint8_t* literals) {\n+  size_t pos = 0;\n+  size_t from_pos = offset & mask;\n+  size_t i;\n+  for (i = 0; i < num_commands; ++i) {\n+    size_t insert_len = cmds[i].insert_len_;\n+    if (from_pos + insert_len > mask) {\n+      size_t head_size = mask + 1 - from_pos;\n+      memcpy(literals + pos, data + from_pos, head_size);\n+      from_pos = 0;\n+      pos += head_size;\n+      insert_len -= head_size;\n+    }\n+    if (insert_len > 0) {\n+      memcpy(literals + pos, data + from_pos, insert_len);\n+      pos += insert_len;\n+    }\n+    from_pos = (from_pos + insert_len + CommandCopyLen(&cmds[i])) & mask;\n+  }\n+}\n+\n+static BROTLI_INLINE uint32_t MyRand(uint32_t* seed) {\n+  /* Initial seed should be 7. In this case, loop length is (1 << 29). */\n+  *seed *= 16807U;\n+  return *seed;\n+}\n+\n+static BROTLI_INLINE double BitCost(size_t count) {\n+  return count == 0 ? -2.0 : FastLog2(count);\n+}\n+\n+#define HISTOGRAMS_PER_BATCH 64\n+#define CLUSTERS_PER_BATCH 16\n+\n+#define FN(X) X ## Literal\n+#define DataType uint8_t\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./block_splitter_inc.h\"\n+#undef DataType\n+#undef FN\n+\n+#define FN(X) X ## Command\n+#define DataType uint16_t\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./block_splitter_inc.h\"\n+#undef FN\n+\n+#define FN(X) X ## Distance\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./block_splitter_inc.h\"\n+#undef DataType\n+#undef FN\n+\n+void BrotliInitBlockSplit(BlockSplit* self) {\n+  self->num_types = 0;\n+  self->num_blocks = 0;\n+  self->types = 0;\n+  self->lengths = 0;\n+  self->types_alloc_size = 0;\n+  self->lengths_alloc_size = 0;\n+}\n+\n+void BrotliDestroyBlockSplit(MemoryManager* m, BlockSplit* self) {\n+  BROTLI_FREE(m, self->types);\n+  BROTLI_FREE(m, self->lengths);\n+}\n+\n+void BrotliSplitBlock(MemoryManager* m,\n+                      const Command* cmds,\n+                      const size_t num_commands,\n+                      const uint8_t* data,\n+                      const size_t pos,\n+                      const size_t mask,\n+                      const BrotliEncoderParams* params,\n+                      BlockSplit* literal_split,\n+                      BlockSplit* insert_and_copy_split,\n+                      BlockSplit* dist_split) {\n+  {\n+    size_t literals_count = CountLiterals(cmds, num_commands);\n+    uint8_t* literals = BROTLI_ALLOC(m, uint8_t, literals_count);\n+    if (BROTLI_IS_OOM(m)) return;\n+    /* Create a continuous array of literals. */\n+    CopyLiteralsToByteArray(cmds, num_commands, data, pos, mask, literals);\n+    /* Create the block split on the array of literals.\n+       Literal histograms have alphabet size 256. */\n+    SplitByteVectorLiteral(\n+        m, literals, literals_count,\n+        kSymbolsPerLiteralHistogram, kMaxLiteralHistograms,\n+        kLiteralStrideLength, kLiteralBlockSwitchCost, params,\n+        literal_split);\n+    if (BROTLI_IS_OOM(m)) return;\n+    BROTLI_FREE(m, literals);\n+  }\n+\n+  {\n+    /* Compute prefix codes for commands. */\n+    uint16_t* insert_and_copy_codes = BROTLI_ALLOC(m, uint16_t, num_commands);\n+    size_t i;\n+    if (BROTLI_IS_OOM(m)) return;\n+    for (i = 0; i < num_commands; ++i) {\n+      insert_and_copy_codes[i] = cmds[i].cmd_prefix_;\n+    }\n+    /* Create the block split on the array of command prefixes. */\n+    SplitByteVectorCommand(\n+        m, insert_and_copy_codes, num_commands,\n+        kSymbolsPerCommandHistogram, kMaxCommandHistograms,\n+        kCommandStrideLength, kCommandBlockSwitchCost, params,\n+        insert_and_copy_split);\n+    if (BROTLI_IS_OOM(m)) return;\n+    /* TODO: reuse for distances? */\n+    BROTLI_FREE(m, insert_and_copy_codes);\n+  }\n+\n+  {\n+    /* Create a continuous array of distance prefixes. */\n+    uint16_t* distance_prefixes = BROTLI_ALLOC(m, uint16_t, num_commands);\n+    size_t j = 0;\n+    size_t i;\n+    if (BROTLI_IS_OOM(m)) return;\n+    for (i = 0; i < num_commands; ++i) {\n+      const Command* cmd = &cmds[i];\n+      if (CommandCopyLen(cmd) && cmd->cmd_prefix_ >= 128) {\n+        distance_prefixes[j++] = cmd->dist_prefix_ & 0x3FF;\n+      }\n+    }\n+    /* Create the block split on the array of distance prefixes. */\n+    SplitByteVectorDistance(\n+        m, distance_prefixes, j,\n+        kSymbolsPerDistanceHistogram, kMaxCommandHistograms,\n+        kCommandStrideLength, kDistanceBlockSwitchCost, params,\n+        dist_split);\n+    if (BROTLI_IS_OOM(m)) return;\n+    BROTLI_FREE(m, distance_prefixes);\n+  }\n+}\n+\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "a5e006c4b3053c8d528057a9b6456d3589537a46",
            "filename": "deps/brotli/c/enc/block_splitter.h",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fblock_splitter.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fblock_splitter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fblock_splitter.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,51 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Block split point selection utilities. */\n+\n+#ifndef BROTLI_ENC_BLOCK_SPLITTER_H_\n+#define BROTLI_ENC_BLOCK_SPLITTER_H_\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./command.h\"\n+#include \"./memory.h\"\n+#include \"./quality.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+typedef struct BlockSplit {\n+  size_t num_types;  /* Amount of distinct types */\n+  size_t num_blocks;  /* Amount of values in types and length */\n+  uint8_t* types;\n+  uint32_t* lengths;\n+\n+  size_t types_alloc_size;\n+  size_t lengths_alloc_size;\n+} BlockSplit;\n+\n+BROTLI_INTERNAL void BrotliInitBlockSplit(BlockSplit* self);\n+BROTLI_INTERNAL void BrotliDestroyBlockSplit(MemoryManager* m,\n+                                             BlockSplit* self);\n+\n+BROTLI_INTERNAL void BrotliSplitBlock(MemoryManager* m,\n+                                      const Command* cmds,\n+                                      const size_t num_commands,\n+                                      const uint8_t* data,\n+                                      const size_t offset,\n+                                      const size_t mask,\n+                                      const BrotliEncoderParams* params,\n+                                      BlockSplit* literal_split,\n+                                      BlockSplit* insert_and_copy_split,\n+                                      BlockSplit* dist_split);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_BLOCK_SPLITTER_H_ */"
        },
        {
            "sha": "023712b84d3e42767ce74a8d87c1fa7f4e54330b",
            "filename": "deps/brotli/c/enc/block_splitter_inc.h",
            "status": "added",
            "additions": 431,
            "deletions": 0,
            "changes": 431,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fblock_splitter_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fblock_splitter_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fblock_splitter_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,431 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN, DataType */\n+\n+#define HistogramType FN(Histogram)\n+\n+static void FN(InitialEntropyCodes)(const DataType* data, size_t length,\n+                                    size_t stride,\n+                                    size_t num_histograms,\n+                                    HistogramType* histograms) {\n+  uint32_t seed = 7;\n+  size_t block_length = length / num_histograms;\n+  size_t i;\n+  FN(ClearHistograms)(histograms, num_histograms);\n+  for (i = 0; i < num_histograms; ++i) {\n+    size_t pos = length * i / num_histograms;\n+    if (i != 0) {\n+      pos += MyRand(&seed) % block_length;\n+    }\n+    if (pos + stride >= length) {\n+      pos = length - stride - 1;\n+    }\n+    FN(HistogramAddVector)(&histograms[i], data + pos, stride);\n+  }\n+}\n+\n+static void FN(RandomSample)(uint32_t* seed,\n+                             const DataType* data,\n+                             size_t length,\n+                             size_t stride,\n+                             HistogramType* sample) {\n+  size_t pos = 0;\n+  if (stride >= length) {\n+    stride = length;\n+  } else {\n+    pos = MyRand(seed) % (length - stride + 1);\n+  }\n+  FN(HistogramAddVector)(sample, data + pos, stride);\n+}\n+\n+static void FN(RefineEntropyCodes)(const DataType* data, size_t length,\n+                                   size_t stride,\n+                                   size_t num_histograms,\n+                                   HistogramType* histograms) {\n+  size_t iters =\n+      kIterMulForRefining * length / stride + kMinItersForRefining;\n+  uint32_t seed = 7;\n+  size_t iter;\n+  iters = ((iters + num_histograms - 1) / num_histograms) * num_histograms;\n+  for (iter = 0; iter < iters; ++iter) {\n+    HistogramType sample;\n+    FN(HistogramClear)(&sample);\n+    FN(RandomSample)(&seed, data, length, stride, &sample);\n+    FN(HistogramAddHistogram)(&histograms[iter % num_histograms], &sample);\n+  }\n+}\n+\n+/* Assigns a block id from the range [0, num_histograms) to each data element\n+   in data[0..length) and fills in block_id[0..length) with the assigned values.\n+   Returns the number of blocks, i.e. one plus the number of block switches. */\n+static size_t FN(FindBlocks)(const DataType* data, const size_t length,\n+                             const double block_switch_bitcost,\n+                             const size_t num_histograms,\n+                             const HistogramType* histograms,\n+                             double* insert_cost,\n+                             double* cost,\n+                             uint8_t* switch_signal,\n+                             uint8_t* block_id) {\n+  const size_t data_size = FN(HistogramDataSize)();\n+  const size_t bitmaplen = (num_histograms + 7) >> 3;\n+  size_t num_blocks = 1;\n+  size_t i;\n+  size_t j;\n+  BROTLI_DCHECK(num_histograms <= 256);\n+  if (num_histograms <= 1) {\n+    for (i = 0; i < length; ++i) {\n+      block_id[i] = 0;\n+    }\n+    return 1;\n+  }\n+  memset(insert_cost, 0, sizeof(insert_cost[0]) * data_size * num_histograms);\n+  for (i = 0; i < num_histograms; ++i) {\n+    insert_cost[i] = FastLog2((uint32_t)histograms[i].total_count_);\n+  }\n+  for (i = data_size; i != 0;) {\n+    --i;\n+    for (j = 0; j < num_histograms; ++j) {\n+      insert_cost[i * num_histograms + j] =\n+          insert_cost[j] - BitCost(histograms[j].data_[i]);\n+    }\n+  }\n+  memset(cost, 0, sizeof(cost[0]) * num_histograms);\n+  memset(switch_signal, 0, sizeof(switch_signal[0]) * length * bitmaplen);\n+  /* After each iteration of this loop, cost[k] will contain the difference\n+     between the minimum cost of arriving at the current byte position using\n+     entropy code k, and the minimum cost of arriving at the current byte\n+     position. This difference is capped at the block switch cost, and if it\n+     reaches block switch cost, it means that when we trace back from the last\n+     position, we need to switch here. */\n+  for (i = 0; i < length; ++i) {\n+    const size_t byte_ix = i;\n+    size_t ix = byte_ix * bitmaplen;\n+    size_t insert_cost_ix = data[byte_ix] * num_histograms;\n+    double min_cost = 1e99;\n+    double block_switch_cost = block_switch_bitcost;\n+    size_t k;\n+    for (k = 0; k < num_histograms; ++k) {\n+      /* We are coding the symbol in data[byte_ix] with entropy code k. */\n+      cost[k] += insert_cost[insert_cost_ix + k];\n+      if (cost[k] < min_cost) {\n+        min_cost = cost[k];\n+        block_id[byte_ix] = (uint8_t)k;\n+      }\n+    }\n+    /* More blocks for the beginning. */\n+    if (byte_ix < 2000) {\n+      block_switch_cost *= 0.77 + 0.07 * (double)byte_ix / 2000;\n+    }\n+    for (k = 0; k < num_histograms; ++k) {\n+      cost[k] -= min_cost;\n+      if (cost[k] >= block_switch_cost) {\n+        const uint8_t mask = (uint8_t)(1u << (k & 7));\n+        cost[k] = block_switch_cost;\n+        BROTLI_DCHECK((k >> 3) < bitmaplen);\n+        switch_signal[ix + (k >> 3)] |= mask;\n+      }\n+    }\n+  }\n+  {  /* Trace back from the last position and switch at the marked places. */\n+    size_t byte_ix = length - 1;\n+    size_t ix = byte_ix * bitmaplen;\n+    uint8_t cur_id = block_id[byte_ix];\n+    while (byte_ix > 0) {\n+      const uint8_t mask = (uint8_t)(1u << (cur_id & 7));\n+      BROTLI_DCHECK(((size_t)cur_id >> 3) < bitmaplen);\n+      --byte_ix;\n+      ix -= bitmaplen;\n+      if (switch_signal[ix + (cur_id >> 3)] & mask) {\n+        if (cur_id != block_id[byte_ix]) {\n+          cur_id = block_id[byte_ix];\n+          ++num_blocks;\n+        }\n+      }\n+      block_id[byte_ix] = cur_id;\n+    }\n+  }\n+  return num_blocks;\n+}\n+\n+static size_t FN(RemapBlockIds)(uint8_t* block_ids, const size_t length,\n+                                uint16_t* new_id, const size_t num_histograms) {\n+  static const uint16_t kInvalidId = 256;\n+  uint16_t next_id = 0;\n+  size_t i;\n+  for (i = 0; i < num_histograms; ++i) {\n+    new_id[i] = kInvalidId;\n+  }\n+  for (i = 0; i < length; ++i) {\n+    BROTLI_DCHECK(block_ids[i] < num_histograms);\n+    if (new_id[block_ids[i]] == kInvalidId) {\n+      new_id[block_ids[i]] = next_id++;\n+    }\n+  }\n+  for (i = 0; i < length; ++i) {\n+    block_ids[i] = (uint8_t)new_id[block_ids[i]];\n+    BROTLI_DCHECK(block_ids[i] < num_histograms);\n+  }\n+  BROTLI_DCHECK(next_id <= num_histograms);\n+  return next_id;\n+}\n+\n+static void FN(BuildBlockHistograms)(const DataType* data, const size_t length,\n+                                     const uint8_t* block_ids,\n+                                     const size_t num_histograms,\n+                                     HistogramType* histograms) {\n+  size_t i;\n+  FN(ClearHistograms)(histograms, num_histograms);\n+  for (i = 0; i < length; ++i) {\n+    FN(HistogramAdd)(&histograms[block_ids[i]], data[i]);\n+  }\n+}\n+\n+static void FN(ClusterBlocks)(MemoryManager* m,\n+                              const DataType* data, const size_t length,\n+                              const size_t num_blocks,\n+                              uint8_t* block_ids,\n+                              BlockSplit* split) {\n+  uint32_t* histogram_symbols = BROTLI_ALLOC(m, uint32_t, num_blocks);\n+  uint32_t* block_lengths = BROTLI_ALLOC(m, uint32_t, num_blocks);\n+  const size_t expected_num_clusters = CLUSTERS_PER_BATCH *\n+      (num_blocks + HISTOGRAMS_PER_BATCH - 1) / HISTOGRAMS_PER_BATCH;\n+  size_t all_histograms_size = 0;\n+  size_t all_histograms_capacity = expected_num_clusters;\n+  HistogramType* all_histograms =\n+      BROTLI_ALLOC(m, HistogramType, all_histograms_capacity);\n+  size_t cluster_size_size = 0;\n+  size_t cluster_size_capacity = expected_num_clusters;\n+  uint32_t* cluster_size = BROTLI_ALLOC(m, uint32_t, cluster_size_capacity);\n+  size_t num_clusters = 0;\n+  HistogramType* histograms = BROTLI_ALLOC(m, HistogramType,\n+      BROTLI_MIN(size_t, num_blocks, HISTOGRAMS_PER_BATCH));\n+  size_t max_num_pairs =\n+      HISTOGRAMS_PER_BATCH * HISTOGRAMS_PER_BATCH / 2;\n+  size_t pairs_capacity = max_num_pairs + 1;\n+  HistogramPair* pairs = BROTLI_ALLOC(m, HistogramPair, pairs_capacity);\n+  size_t pos = 0;\n+  uint32_t* clusters;\n+  size_t num_final_clusters;\n+  static const uint32_t kInvalidIndex = BROTLI_UINT32_MAX;\n+  uint32_t* new_index;\n+  size_t i;\n+  uint32_t sizes[HISTOGRAMS_PER_BATCH] = { 0 };\n+  uint32_t new_clusters[HISTOGRAMS_PER_BATCH] = { 0 };\n+  uint32_t symbols[HISTOGRAMS_PER_BATCH] = { 0 };\n+  uint32_t remap[HISTOGRAMS_PER_BATCH] = { 0 };\n+\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  memset(block_lengths, 0, num_blocks * sizeof(uint32_t));\n+\n+  {\n+    size_t block_idx = 0;\n+    for (i = 0; i < length; ++i) {\n+      BROTLI_DCHECK(block_idx < num_blocks);\n+      ++block_lengths[block_idx];\n+      if (i + 1 == length || block_ids[i] != block_ids[i + 1]) {\n+        ++block_idx;\n+      }\n+    }\n+    BROTLI_DCHECK(block_idx == num_blocks);\n+  }\n+\n+  for (i = 0; i < num_blocks; i += HISTOGRAMS_PER_BATCH) {\n+    const size_t num_to_combine =\n+        BROTLI_MIN(size_t, num_blocks - i, HISTOGRAMS_PER_BATCH);\n+    size_t num_new_clusters;\n+    size_t j;\n+    for (j = 0; j < num_to_combine; ++j) {\n+      size_t k;\n+      FN(HistogramClear)(&histograms[j]);\n+      for (k = 0; k < block_lengths[i + j]; ++k) {\n+        FN(HistogramAdd)(&histograms[j], data[pos++]);\n+      }\n+      histograms[j].bit_cost_ = FN(BrotliPopulationCost)(&histograms[j]);\n+      new_clusters[j] = (uint32_t)j;\n+      symbols[j] = (uint32_t)j;\n+      sizes[j] = 1;\n+    }\n+    num_new_clusters = FN(BrotliHistogramCombine)(\n+        histograms, sizes, symbols, new_clusters, pairs, num_to_combine,\n+        num_to_combine, HISTOGRAMS_PER_BATCH, max_num_pairs);\n+    BROTLI_ENSURE_CAPACITY(m, HistogramType, all_histograms,\n+        all_histograms_capacity, all_histograms_size + num_new_clusters);\n+    BROTLI_ENSURE_CAPACITY(m, uint32_t, cluster_size,\n+        cluster_size_capacity, cluster_size_size + num_new_clusters);\n+    if (BROTLI_IS_OOM(m)) return;\n+    for (j = 0; j < num_new_clusters; ++j) {\n+      all_histograms[all_histograms_size++] = histograms[new_clusters[j]];\n+      cluster_size[cluster_size_size++] = sizes[new_clusters[j]];\n+      remap[new_clusters[j]] = (uint32_t)j;\n+    }\n+    for (j = 0; j < num_to_combine; ++j) {\n+      histogram_symbols[i + j] = (uint32_t)num_clusters + remap[symbols[j]];\n+    }\n+    num_clusters += num_new_clusters;\n+    BROTLI_DCHECK(num_clusters == cluster_size_size);\n+    BROTLI_DCHECK(num_clusters == all_histograms_size);\n+  }\n+  BROTLI_FREE(m, histograms);\n+\n+  max_num_pairs =\n+      BROTLI_MIN(size_t, 64 * num_clusters, (num_clusters / 2) * num_clusters);\n+  if (pairs_capacity < max_num_pairs + 1) {\n+    BROTLI_FREE(m, pairs);\n+    pairs = BROTLI_ALLOC(m, HistogramPair, max_num_pairs + 1);\n+    if (BROTLI_IS_OOM(m)) return;\n+  }\n+\n+  clusters = BROTLI_ALLOC(m, uint32_t, num_clusters);\n+  if (BROTLI_IS_OOM(m)) return;\n+  for (i = 0; i < num_clusters; ++i) {\n+    clusters[i] = (uint32_t)i;\n+  }\n+  num_final_clusters = FN(BrotliHistogramCombine)(\n+      all_histograms, cluster_size, histogram_symbols, clusters, pairs,\n+      num_clusters, num_blocks, BROTLI_MAX_NUMBER_OF_BLOCK_TYPES,\n+      max_num_pairs);\n+  BROTLI_FREE(m, pairs);\n+  BROTLI_FREE(m, cluster_size);\n+\n+  new_index = BROTLI_ALLOC(m, uint32_t, num_clusters);\n+  if (BROTLI_IS_OOM(m)) return;\n+  for (i = 0; i < num_clusters; ++i) new_index[i] = kInvalidIndex;\n+  pos = 0;\n+  {\n+    uint32_t next_index = 0;\n+    for (i = 0; i < num_blocks; ++i) {\n+      HistogramType histo;\n+      size_t j;\n+      uint32_t best_out;\n+      double best_bits;\n+      FN(HistogramClear)(&histo);\n+      for (j = 0; j < block_lengths[i]; ++j) {\n+        FN(HistogramAdd)(&histo, data[pos++]);\n+      }\n+      best_out = (i == 0) ? histogram_symbols[0] : histogram_symbols[i - 1];\n+      best_bits =\n+          FN(BrotliHistogramBitCostDistance)(&histo, &all_histograms[best_out]);\n+      for (j = 0; j < num_final_clusters; ++j) {\n+        const double cur_bits = FN(BrotliHistogramBitCostDistance)(\n+            &histo, &all_histograms[clusters[j]]);\n+        if (cur_bits < best_bits) {\n+          best_bits = cur_bits;\n+          best_out = clusters[j];\n+        }\n+      }\n+      histogram_symbols[i] = best_out;\n+      if (new_index[best_out] == kInvalidIndex) {\n+        new_index[best_out] = next_index++;\n+      }\n+    }\n+  }\n+  BROTLI_FREE(m, clusters);\n+  BROTLI_FREE(m, all_histograms);\n+  BROTLI_ENSURE_CAPACITY(\n+      m, uint8_t, split->types, split->types_alloc_size, num_blocks);\n+  BROTLI_ENSURE_CAPACITY(\n+      m, uint32_t, split->lengths, split->lengths_alloc_size, num_blocks);\n+  if (BROTLI_IS_OOM(m)) return;\n+  {\n+    uint32_t cur_length = 0;\n+    size_t block_idx = 0;\n+    uint8_t max_type = 0;\n+    for (i = 0; i < num_blocks; ++i) {\n+      cur_length += block_lengths[i];\n+      if (i + 1 == num_blocks ||\n+          histogram_symbols[i] != histogram_symbols[i + 1]) {\n+        const uint8_t id = (uint8_t)new_index[histogram_symbols[i]];\n+        split->types[block_idx] = id;\n+        split->lengths[block_idx] = cur_length;\n+        max_type = BROTLI_MAX(uint8_t, max_type, id);\n+        cur_length = 0;\n+        ++block_idx;\n+      }\n+    }\n+    split->num_blocks = block_idx;\n+    split->num_types = (size_t)max_type + 1;\n+  }\n+  BROTLI_FREE(m, new_index);\n+  BROTLI_FREE(m, block_lengths);\n+  BROTLI_FREE(m, histogram_symbols);\n+}\n+\n+static void FN(SplitByteVector)(MemoryManager* m,\n+                                const DataType* data, const size_t length,\n+                                const size_t literals_per_histogram,\n+                                const size_t max_histograms,\n+                                const size_t sampling_stride_length,\n+                                const double block_switch_cost,\n+                                const BrotliEncoderParams* params,\n+                                BlockSplit* split) {\n+  const size_t data_size = FN(HistogramDataSize)();\n+  size_t num_histograms = length / literals_per_histogram + 1;\n+  HistogramType* histograms;\n+  if (num_histograms > max_histograms) {\n+    num_histograms = max_histograms;\n+  }\n+  if (length == 0) {\n+    split->num_types = 1;\n+    return;\n+  } else if (length < kMinLengthForBlockSplitting) {\n+    BROTLI_ENSURE_CAPACITY(m, uint8_t,\n+        split->types, split->types_alloc_size, split->num_blocks + 1);\n+    BROTLI_ENSURE_CAPACITY(m, uint32_t,\n+        split->lengths, split->lengths_alloc_size, split->num_blocks + 1);\n+    if (BROTLI_IS_OOM(m)) return;\n+    split->num_types = 1;\n+    split->types[split->num_blocks] = 0;\n+    split->lengths[split->num_blocks] = (uint32_t)length;\n+    split->num_blocks++;\n+    return;\n+  }\n+  histograms = BROTLI_ALLOC(m, HistogramType, num_histograms);\n+  if (BROTLI_IS_OOM(m)) return;\n+  /* Find good entropy codes. */\n+  FN(InitialEntropyCodes)(data, length,\n+                          sampling_stride_length,\n+                          num_histograms, histograms);\n+  FN(RefineEntropyCodes)(data, length,\n+                         sampling_stride_length,\n+                         num_histograms, histograms);\n+  {\n+    /* Find a good path through literals with the good entropy codes. */\n+    uint8_t* block_ids = BROTLI_ALLOC(m, uint8_t, length);\n+    size_t num_blocks = 0;\n+    const size_t bitmaplen = (num_histograms + 7) >> 3;\n+    double* insert_cost = BROTLI_ALLOC(m, double, data_size * num_histograms);\n+    double* cost = BROTLI_ALLOC(m, double, num_histograms);\n+    uint8_t* switch_signal = BROTLI_ALLOC(m, uint8_t, length * bitmaplen);\n+    uint16_t* new_id = BROTLI_ALLOC(m, uint16_t, num_histograms);\n+    const size_t iters = params->quality < HQ_ZOPFLIFICATION_QUALITY ? 3 : 10;\n+    size_t i;\n+    if (BROTLI_IS_OOM(m)) return;\n+    for (i = 0; i < iters; ++i) {\n+      num_blocks = FN(FindBlocks)(data, length,\n+                                  block_switch_cost,\n+                                  num_histograms, histograms,\n+                                  insert_cost, cost, switch_signal,\n+                                  block_ids);\n+      num_histograms = FN(RemapBlockIds)(block_ids, length,\n+                                         new_id, num_histograms);\n+      FN(BuildBlockHistograms)(data, length, block_ids,\n+                               num_histograms, histograms);\n+    }\n+    BROTLI_FREE(m, insert_cost);\n+    BROTLI_FREE(m, cost);\n+    BROTLI_FREE(m, switch_signal);\n+    BROTLI_FREE(m, new_id);\n+    BROTLI_FREE(m, histograms);\n+    FN(ClusterBlocks)(m, data, length, num_blocks, block_ids, split);\n+    if (BROTLI_IS_OOM(m)) return;\n+    BROTLI_FREE(m, block_ids);\n+  }\n+}\n+\n+#undef HistogramType"
        },
        {
            "sha": "aaf2dad7dbdcc5e4cd078b76b60483f7e070356f",
            "filename": "deps/brotli/c/enc/brotli_bit_stream.c",
            "status": "added",
            "additions": 1331,
            "deletions": 0,
            "changes": 1331,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbrotli_bit_stream.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbrotli_bit_stream.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbrotli_bit_stream.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,1331 @@\n+/* Copyright 2014 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Brotli bit stream functions to support the low level format. There are no\n+   compression algorithms here, just the right ordering of bits to match the\n+   specs. */\n+\n+#include \"./brotli_bit_stream.h\"\n+\n+#include <string.h>  /* memcpy, memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/context.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./entropy_encode.h\"\n+#include \"./entropy_encode_static.h\"\n+#include \"./fast_log.h\"\n+#include \"./histogram.h\"\n+#include \"./memory.h\"\n+#include \"./write_bits.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define MAX_HUFFMAN_TREE_SIZE (2 * BROTLI_NUM_COMMAND_SYMBOLS + 1)\n+/* The maximum size of Huffman dictionary for distances assuming that\n+   NPOSTFIX = 0 and NDIRECT = 0. */\n+#define MAX_SIMPLE_DISTANCE_ALPHABET_SIZE \\\n+  BROTLI_DISTANCE_ALPHABET_SIZE(0, 0, BROTLI_LARGE_MAX_DISTANCE_BITS)\n+/* MAX_SIMPLE_DISTANCE_ALPHABET_SIZE == 140 */\n+\n+/* Represents the range of values belonging to a prefix code:\n+   [offset, offset + 2^nbits) */\n+typedef struct PrefixCodeRange {\n+  uint32_t offset;\n+  uint32_t nbits;\n+} PrefixCodeRange;\n+\n+static const PrefixCodeRange\n+    kBlockLengthPrefixCode[BROTLI_NUM_BLOCK_LEN_SYMBOLS] = {\n+  { 1, 2}, { 5, 2}, { 9, 2}, {13, 2}, {17, 3}, { 25, 3}, { 33, 3},\n+  {41, 3}, {49, 4}, {65, 4}, {81, 4}, {97, 4}, {113, 5}, {145, 5},\n+  {177, 5}, { 209,  5}, { 241,  6}, { 305,  6}, { 369,  7}, {  497,  8},\n+  {753, 9}, {1265, 10}, {2289, 11}, {4337, 12}, {8433, 13}, {16625, 24}\n+};\n+\n+static BROTLI_INLINE uint32_t BlockLengthPrefixCode(uint32_t len) {\n+  uint32_t code = (len >= 177) ? (len >= 753 ? 20 : 14) : (len >= 41 ? 7 : 0);\n+  while (code < (BROTLI_NUM_BLOCK_LEN_SYMBOLS - 1) &&\n+      len >= kBlockLengthPrefixCode[code + 1].offset) ++code;\n+  return code;\n+}\n+\n+static BROTLI_INLINE void GetBlockLengthPrefixCode(uint32_t len, size_t* code,\n+    uint32_t* n_extra, uint32_t* extra) {\n+  *code = BlockLengthPrefixCode(len);\n+  *n_extra = kBlockLengthPrefixCode[*code].nbits;\n+  *extra = len - kBlockLengthPrefixCode[*code].offset;\n+}\n+\n+typedef struct BlockTypeCodeCalculator {\n+  size_t last_type;\n+  size_t second_last_type;\n+} BlockTypeCodeCalculator;\n+\n+static void InitBlockTypeCodeCalculator(BlockTypeCodeCalculator* self) {\n+  self->last_type = 1;\n+  self->second_last_type = 0;\n+}\n+\n+static BROTLI_INLINE size_t NextBlockTypeCode(\n+    BlockTypeCodeCalculator* calculator, uint8_t type) {\n+  size_t type_code = (type == calculator->last_type + 1) ? 1u :\n+      (type == calculator->second_last_type) ? 0u : type + 2u;\n+  calculator->second_last_type = calculator->last_type;\n+  calculator->last_type = type;\n+  return type_code;\n+}\n+\n+/* |nibblesbits| represents the 2 bits to encode MNIBBLES (0-3)\n+   REQUIRES: length > 0\n+   REQUIRES: length <= (1 << 24) */\n+static void BrotliEncodeMlen(size_t length, uint64_t* bits,\n+                             size_t* numbits, uint64_t* nibblesbits) {\n+  size_t lg = (length == 1) ? 1 : Log2FloorNonZero((uint32_t)(length - 1)) + 1;\n+  size_t mnibbles = (lg < 16 ? 16 : (lg + 3)) / 4;\n+  BROTLI_DCHECK(length > 0);\n+  BROTLI_DCHECK(length <= (1 << 24));\n+  BROTLI_DCHECK(lg <= 24);\n+  *nibblesbits = mnibbles - 4;\n+  *numbits = mnibbles * 4;\n+  *bits = length - 1;\n+}\n+\n+static BROTLI_INLINE void StoreCommandExtra(\n+    const Command* cmd, size_t* storage_ix, uint8_t* storage) {\n+  uint32_t copylen_code = CommandCopyLenCode(cmd);\n+  uint16_t inscode = GetInsertLengthCode(cmd->insert_len_);\n+  uint16_t copycode = GetCopyLengthCode(copylen_code);\n+  uint32_t insnumextra = GetInsertExtra(inscode);\n+  uint64_t insextraval = cmd->insert_len_ - GetInsertBase(inscode);\n+  uint64_t copyextraval = copylen_code - GetCopyBase(copycode);\n+  uint64_t bits = (copyextraval << insnumextra) | insextraval;\n+  BrotliWriteBits(\n+      insnumextra + GetCopyExtra(copycode), bits, storage_ix, storage);\n+}\n+\n+/* Data structure that stores almost everything that is needed to encode each\n+   block switch command. */\n+typedef struct BlockSplitCode {\n+  BlockTypeCodeCalculator type_code_calculator;\n+  uint8_t type_depths[BROTLI_MAX_BLOCK_TYPE_SYMBOLS];\n+  uint16_t type_bits[BROTLI_MAX_BLOCK_TYPE_SYMBOLS];\n+  uint8_t length_depths[BROTLI_NUM_BLOCK_LEN_SYMBOLS];\n+  uint16_t length_bits[BROTLI_NUM_BLOCK_LEN_SYMBOLS];\n+} BlockSplitCode;\n+\n+/* Stores a number between 0 and 255. */\n+static void StoreVarLenUint8(size_t n, size_t* storage_ix, uint8_t* storage) {\n+  if (n == 0) {\n+    BrotliWriteBits(1, 0, storage_ix, storage);\n+  } else {\n+    size_t nbits = Log2FloorNonZero(n);\n+    BrotliWriteBits(1, 1, storage_ix, storage);\n+    BrotliWriteBits(3, nbits, storage_ix, storage);\n+    BrotliWriteBits(nbits, n - ((size_t)1 << nbits), storage_ix, storage);\n+  }\n+}\n+\n+/* Stores the compressed meta-block header.\n+   REQUIRES: length > 0\n+   REQUIRES: length <= (1 << 24) */\n+static void StoreCompressedMetaBlockHeader(BROTLI_BOOL is_final_block,\n+                                           size_t length,\n+                                           size_t* storage_ix,\n+                                           uint8_t* storage) {\n+  uint64_t lenbits;\n+  size_t nlenbits;\n+  uint64_t nibblesbits;\n+\n+  /* Write ISLAST bit. */\n+  BrotliWriteBits(1, (uint64_t)is_final_block, storage_ix, storage);\n+  /* Write ISEMPTY bit. */\n+  if (is_final_block) {\n+    BrotliWriteBits(1, 0, storage_ix, storage);\n+  }\n+\n+  BrotliEncodeMlen(length, &lenbits, &nlenbits, &nibblesbits);\n+  BrotliWriteBits(2, nibblesbits, storage_ix, storage);\n+  BrotliWriteBits(nlenbits, lenbits, storage_ix, storage);\n+\n+  if (!is_final_block) {\n+    /* Write ISUNCOMPRESSED bit. */\n+    BrotliWriteBits(1, 0, storage_ix, storage);\n+  }\n+}\n+\n+/* Stores the uncompressed meta-block header.\n+   REQUIRES: length > 0\n+   REQUIRES: length <= (1 << 24) */\n+static void BrotliStoreUncompressedMetaBlockHeader(size_t length,\n+                                                   size_t* storage_ix,\n+                                                   uint8_t* storage) {\n+  uint64_t lenbits;\n+  size_t nlenbits;\n+  uint64_t nibblesbits;\n+\n+  /* Write ISLAST bit.\n+     Uncompressed block cannot be the last one, so set to 0. */\n+  BrotliWriteBits(1, 0, storage_ix, storage);\n+  BrotliEncodeMlen(length, &lenbits, &nlenbits, &nibblesbits);\n+  BrotliWriteBits(2, nibblesbits, storage_ix, storage);\n+  BrotliWriteBits(nlenbits, lenbits, storage_ix, storage);\n+  /* Write ISUNCOMPRESSED bit. */\n+  BrotliWriteBits(1, 1, storage_ix, storage);\n+}\n+\n+static void BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask(\n+    const int num_codes, const uint8_t* code_length_bitdepth,\n+    size_t* storage_ix, uint8_t* storage) {\n+  static const uint8_t kStorageOrder[BROTLI_CODE_LENGTH_CODES] = {\n+    1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15\n+  };\n+  /* The bit lengths of the Huffman code over the code length alphabet\n+     are compressed with the following static Huffman code:\n+       Symbol   Code\n+       ------   ----\n+       0          00\n+       1        1110\n+       2         110\n+       3          01\n+       4          10\n+       5        1111 */\n+  static const uint8_t kHuffmanBitLengthHuffmanCodeSymbols[6] = {\n+     0, 7, 3, 2, 1, 15\n+  };\n+  static const uint8_t kHuffmanBitLengthHuffmanCodeBitLengths[6] = {\n+    2, 4, 3, 2, 2, 4\n+  };\n+\n+  size_t skip_some = 0;  /* skips none. */\n+\n+  /* Throw away trailing zeros: */\n+  size_t codes_to_store = BROTLI_CODE_LENGTH_CODES;\n+  if (num_codes > 1) {\n+    for (; codes_to_store > 0; --codes_to_store) {\n+      if (code_length_bitdepth[kStorageOrder[codes_to_store - 1]] != 0) {\n+        break;\n+      }\n+    }\n+  }\n+  if (code_length_bitdepth[kStorageOrder[0]] == 0 &&\n+      code_length_bitdepth[kStorageOrder[1]] == 0) {\n+    skip_some = 2;  /* skips two. */\n+    if (code_length_bitdepth[kStorageOrder[2]] == 0) {\n+      skip_some = 3;  /* skips three. */\n+    }\n+  }\n+  BrotliWriteBits(2, skip_some, storage_ix, storage);\n+  {\n+    size_t i;\n+    for (i = skip_some; i < codes_to_store; ++i) {\n+      size_t l = code_length_bitdepth[kStorageOrder[i]];\n+      BrotliWriteBits(kHuffmanBitLengthHuffmanCodeBitLengths[l],\n+          kHuffmanBitLengthHuffmanCodeSymbols[l], storage_ix, storage);\n+    }\n+  }\n+}\n+\n+static void BrotliStoreHuffmanTreeToBitMask(\n+    const size_t huffman_tree_size, const uint8_t* huffman_tree,\n+    const uint8_t* huffman_tree_extra_bits, const uint8_t* code_length_bitdepth,\n+    const uint16_t* code_length_bitdepth_symbols,\n+    size_t* BROTLI_RESTRICT storage_ix, uint8_t* BROTLI_RESTRICT storage) {\n+  size_t i;\n+  for (i = 0; i < huffman_tree_size; ++i) {\n+    size_t ix = huffman_tree[i];\n+    BrotliWriteBits(code_length_bitdepth[ix], code_length_bitdepth_symbols[ix],\n+                    storage_ix, storage);\n+    /* Extra bits */\n+    switch (ix) {\n+      case BROTLI_REPEAT_PREVIOUS_CODE_LENGTH:\n+        BrotliWriteBits(2, huffman_tree_extra_bits[i], storage_ix, storage);\n+        break;\n+      case BROTLI_REPEAT_ZERO_CODE_LENGTH:\n+        BrotliWriteBits(3, huffman_tree_extra_bits[i], storage_ix, storage);\n+        break;\n+    }\n+  }\n+}\n+\n+static void StoreSimpleHuffmanTree(const uint8_t* depths,\n+                                   size_t symbols[4],\n+                                   size_t num_symbols,\n+                                   size_t max_bits,\n+                                   size_t* storage_ix, uint8_t* storage) {\n+  /* value of 1 indicates a simple Huffman code */\n+  BrotliWriteBits(2, 1, storage_ix, storage);\n+  BrotliWriteBits(2, num_symbols - 1, storage_ix, storage);  /* NSYM - 1 */\n+\n+  {\n+    /* Sort */\n+    size_t i;\n+    for (i = 0; i < num_symbols; i++) {\n+      size_t j;\n+      for (j = i + 1; j < num_symbols; j++) {\n+        if (depths[symbols[j]] < depths[symbols[i]]) {\n+          BROTLI_SWAP(size_t, symbols, j, i);\n+        }\n+      }\n+    }\n+  }\n+\n+  if (num_symbols == 2) {\n+    BrotliWriteBits(max_bits, symbols[0], storage_ix, storage);\n+    BrotliWriteBits(max_bits, symbols[1], storage_ix, storage);\n+  } else if (num_symbols == 3) {\n+    BrotliWriteBits(max_bits, symbols[0], storage_ix, storage);\n+    BrotliWriteBits(max_bits, symbols[1], storage_ix, storage);\n+    BrotliWriteBits(max_bits, symbols[2], storage_ix, storage);\n+  } else {\n+    BrotliWriteBits(max_bits, symbols[0], storage_ix, storage);\n+    BrotliWriteBits(max_bits, symbols[1], storage_ix, storage);\n+    BrotliWriteBits(max_bits, symbols[2], storage_ix, storage);\n+    BrotliWriteBits(max_bits, symbols[3], storage_ix, storage);\n+    /* tree-select */\n+    BrotliWriteBits(1, depths[symbols[0]] == 1 ? 1 : 0, storage_ix, storage);\n+  }\n+}\n+\n+/* num = alphabet size\n+   depths = symbol depths */\n+void BrotliStoreHuffmanTree(const uint8_t* depths, size_t num,\n+                            HuffmanTree* tree,\n+                            size_t* storage_ix, uint8_t* storage) {\n+  /* Write the Huffman tree into the brotli-representation.\n+     The command alphabet is the largest, so this allocation will fit all\n+     alphabets. */\n+  uint8_t huffman_tree[BROTLI_NUM_COMMAND_SYMBOLS];\n+  uint8_t huffman_tree_extra_bits[BROTLI_NUM_COMMAND_SYMBOLS];\n+  size_t huffman_tree_size = 0;\n+  uint8_t code_length_bitdepth[BROTLI_CODE_LENGTH_CODES] = { 0 };\n+  uint16_t code_length_bitdepth_symbols[BROTLI_CODE_LENGTH_CODES];\n+  uint32_t huffman_tree_histogram[BROTLI_CODE_LENGTH_CODES] = { 0 };\n+  size_t i;\n+  int num_codes = 0;\n+  size_t code = 0;\n+\n+  BROTLI_DCHECK(num <= BROTLI_NUM_COMMAND_SYMBOLS);\n+\n+  BrotliWriteHuffmanTree(depths, num, &huffman_tree_size, huffman_tree,\n+                         huffman_tree_extra_bits);\n+\n+  /* Calculate the statistics of the Huffman tree in brotli-representation. */\n+  for (i = 0; i < huffman_tree_size; ++i) {\n+    ++huffman_tree_histogram[huffman_tree[i]];\n+  }\n+\n+  for (i = 0; i < BROTLI_CODE_LENGTH_CODES; ++i) {\n+    if (huffman_tree_histogram[i]) {\n+      if (num_codes == 0) {\n+        code = i;\n+        num_codes = 1;\n+      } else if (num_codes == 1) {\n+        num_codes = 2;\n+        break;\n+      }\n+    }\n+  }\n+\n+  /* Calculate another Huffman tree to use for compressing both the\n+     earlier Huffman tree with. */\n+  BrotliCreateHuffmanTree(huffman_tree_histogram, BROTLI_CODE_LENGTH_CODES,\n+                          5, tree, code_length_bitdepth);\n+  BrotliConvertBitDepthsToSymbols(code_length_bitdepth,\n+                                  BROTLI_CODE_LENGTH_CODES,\n+                                  code_length_bitdepth_symbols);\n+\n+  /* Now, we have all the data, let's start storing it */\n+  BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask(num_codes, code_length_bitdepth,\n+                                               storage_ix, storage);\n+\n+  if (num_codes == 1) {\n+    code_length_bitdepth[code] = 0;\n+  }\n+\n+  /* Store the real Huffman tree now. */\n+  BrotliStoreHuffmanTreeToBitMask(huffman_tree_size,\n+                                  huffman_tree,\n+                                  huffman_tree_extra_bits,\n+                                  code_length_bitdepth,\n+                                  code_length_bitdepth_symbols,\n+                                  storage_ix, storage);\n+}\n+\n+/* Builds a Huffman tree from histogram[0:length] into depth[0:length] and\n+   bits[0:length] and stores the encoded tree to the bit stream. */\n+static void BuildAndStoreHuffmanTree(const uint32_t* histogram,\n+                                     const size_t histogram_length,\n+                                     const size_t alphabet_size,\n+                                     HuffmanTree* tree,\n+                                     uint8_t* depth,\n+                                     uint16_t* bits,\n+                                     size_t* storage_ix,\n+                                     uint8_t* storage) {\n+  size_t count = 0;\n+  size_t s4[4] = { 0 };\n+  size_t i;\n+  size_t max_bits = 0;\n+  for (i = 0; i < histogram_length; i++) {\n+    if (histogram[i]) {\n+      if (count < 4) {\n+        s4[count] = i;\n+      } else if (count > 4) {\n+        break;\n+      }\n+      count++;\n+    }\n+  }\n+\n+  {\n+    size_t max_bits_counter = alphabet_size - 1;\n+    while (max_bits_counter) {\n+      max_bits_counter >>= 1;\n+      ++max_bits;\n+    }\n+  }\n+\n+  if (count <= 1) {\n+    BrotliWriteBits(4, 1, storage_ix, storage);\n+    BrotliWriteBits(max_bits, s4[0], storage_ix, storage);\n+    depth[s4[0]] = 0;\n+    bits[s4[0]] = 0;\n+    return;\n+  }\n+\n+  memset(depth, 0, histogram_length * sizeof(depth[0]));\n+  BrotliCreateHuffmanTree(histogram, histogram_length, 15, tree, depth);\n+  BrotliConvertBitDepthsToSymbols(depth, histogram_length, bits);\n+\n+  if (count <= 4) {\n+    StoreSimpleHuffmanTree(depth, s4, count, max_bits, storage_ix, storage);\n+  } else {\n+    BrotliStoreHuffmanTree(depth, histogram_length, tree, storage_ix, storage);\n+  }\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL SortHuffmanTree(\n+    const HuffmanTree* v0, const HuffmanTree* v1) {\n+  return TO_BROTLI_BOOL(v0->total_count_ < v1->total_count_);\n+}\n+\n+void BrotliBuildAndStoreHuffmanTreeFast(MemoryManager* m,\n+                                        const uint32_t* histogram,\n+                                        const size_t histogram_total,\n+                                        const size_t max_bits,\n+                                        uint8_t* depth, uint16_t* bits,\n+                                        size_t* storage_ix,\n+                                        uint8_t* storage) {\n+  size_t count = 0;\n+  size_t symbols[4] = { 0 };\n+  size_t length = 0;\n+  size_t total = histogram_total;\n+  while (total != 0) {\n+    if (histogram[length]) {\n+      if (count < 4) {\n+        symbols[count] = length;\n+      }\n+      ++count;\n+      total -= histogram[length];\n+    }\n+    ++length;\n+  }\n+\n+  if (count <= 1) {\n+    BrotliWriteBits(4, 1, storage_ix, storage);\n+    BrotliWriteBits(max_bits, symbols[0], storage_ix, storage);\n+    depth[symbols[0]] = 0;\n+    bits[symbols[0]] = 0;\n+    return;\n+  }\n+\n+  memset(depth, 0, length * sizeof(depth[0]));\n+  {\n+    const size_t max_tree_size = 2 * length + 1;\n+    HuffmanTree* tree = BROTLI_ALLOC(m, HuffmanTree, max_tree_size);\n+    uint32_t count_limit;\n+    if (BROTLI_IS_OOM(m)) return;\n+    for (count_limit = 1; ; count_limit *= 2) {\n+      HuffmanTree* node = tree;\n+      size_t l;\n+      for (l = length; l != 0;) {\n+        --l;\n+        if (histogram[l]) {\n+          if (BROTLI_PREDICT_TRUE(histogram[l] >= count_limit)) {\n+            InitHuffmanTree(node, histogram[l], -1, (int16_t)l);\n+          } else {\n+            InitHuffmanTree(node, count_limit, -1, (int16_t)l);\n+          }\n+          ++node;\n+        }\n+      }\n+      {\n+        const int n = (int)(node - tree);\n+        HuffmanTree sentinel;\n+        int i = 0;      /* Points to the next leaf node. */\n+        int j = n + 1;  /* Points to the next non-leaf node. */\n+        int k;\n+\n+        SortHuffmanTreeItems(tree, (size_t)n, SortHuffmanTree);\n+        /* The nodes are:\n+           [0, n): the sorted leaf nodes that we start with.\n+           [n]: we add a sentinel here.\n+           [n + 1, 2n): new parent nodes are added here, starting from\n+                        (n+1). These are naturally in ascending order.\n+           [2n]: we add a sentinel at the end as well.\n+           There will be (2n+1) elements at the end. */\n+        InitHuffmanTree(&sentinel, BROTLI_UINT32_MAX, -1, -1);\n+        *node++ = sentinel;\n+        *node++ = sentinel;\n+\n+        for (k = n - 1; k > 0; --k) {\n+          int left, right;\n+          if (tree[i].total_count_ <= tree[j].total_count_) {\n+            left = i;\n+            ++i;\n+          } else {\n+            left = j;\n+            ++j;\n+          }\n+          if (tree[i].total_count_ <= tree[j].total_count_) {\n+            right = i;\n+            ++i;\n+          } else {\n+            right = j;\n+            ++j;\n+          }\n+          /* The sentinel node becomes the parent node. */\n+          node[-1].total_count_ =\n+              tree[left].total_count_ + tree[right].total_count_;\n+          node[-1].index_left_ = (int16_t)left;\n+          node[-1].index_right_or_value_ = (int16_t)right;\n+          /* Add back the last sentinel node. */\n+          *node++ = sentinel;\n+        }\n+        if (BrotliSetDepth(2 * n - 1, tree, depth, 14)) {\n+          /* We need to pack the Huffman tree in 14 bits. If this was not\n+             successful, add fake entities to the lowest values and retry. */\n+          break;\n+        }\n+      }\n+    }\n+    BROTLI_FREE(m, tree);\n+  }\n+  BrotliConvertBitDepthsToSymbols(depth, length, bits);\n+  if (count <= 4) {\n+    size_t i;\n+    /* value of 1 indicates a simple Huffman code */\n+    BrotliWriteBits(2, 1, storage_ix, storage);\n+    BrotliWriteBits(2, count - 1, storage_ix, storage);  /* NSYM - 1 */\n+\n+    /* Sort */\n+    for (i = 0; i < count; i++) {\n+      size_t j;\n+      for (j = i + 1; j < count; j++) {\n+        if (depth[symbols[j]] < depth[symbols[i]]) {\n+          BROTLI_SWAP(size_t, symbols, j, i);\n+        }\n+      }\n+    }\n+\n+    if (count == 2) {\n+      BrotliWriteBits(max_bits, symbols[0], storage_ix, storage);\n+      BrotliWriteBits(max_bits, symbols[1], storage_ix, storage);\n+    } else if (count == 3) {\n+      BrotliWriteBits(max_bits, symbols[0], storage_ix, storage);\n+      BrotliWriteBits(max_bits, symbols[1], storage_ix, storage);\n+      BrotliWriteBits(max_bits, symbols[2], storage_ix, storage);\n+    } else {\n+      BrotliWriteBits(max_bits, symbols[0], storage_ix, storage);\n+      BrotliWriteBits(max_bits, symbols[1], storage_ix, storage);\n+      BrotliWriteBits(max_bits, symbols[2], storage_ix, storage);\n+      BrotliWriteBits(max_bits, symbols[3], storage_ix, storage);\n+      /* tree-select */\n+      BrotliWriteBits(1, depth[symbols[0]] == 1 ? 1 : 0, storage_ix, storage);\n+    }\n+  } else {\n+    uint8_t previous_value = 8;\n+    size_t i;\n+    /* Complex Huffman Tree */\n+    StoreStaticCodeLengthCode(storage_ix, storage);\n+\n+    /* Actual RLE coding. */\n+    for (i = 0; i < length;) {\n+      const uint8_t value = depth[i];\n+      size_t reps = 1;\n+      size_t k;\n+      for (k = i + 1; k < length && depth[k] == value; ++k) {\n+        ++reps;\n+      }\n+      i += reps;\n+      if (value == 0) {\n+        BrotliWriteBits(kZeroRepsDepth[reps], kZeroRepsBits[reps],\n+                        storage_ix, storage);\n+      } else {\n+        if (previous_value != value) {\n+          BrotliWriteBits(kCodeLengthDepth[value], kCodeLengthBits[value],\n+                          storage_ix, storage);\n+          --reps;\n+        }\n+        if (reps < 3) {\n+          while (reps != 0) {\n+            reps--;\n+            BrotliWriteBits(kCodeLengthDepth[value], kCodeLengthBits[value],\n+                            storage_ix, storage);\n+          }\n+        } else {\n+          reps -= 3;\n+          BrotliWriteBits(kNonZeroRepsDepth[reps], kNonZeroRepsBits[reps],\n+                          storage_ix, storage);\n+        }\n+        previous_value = value;\n+      }\n+    }\n+  }\n+}\n+\n+static size_t IndexOf(const uint8_t* v, size_t v_size, uint8_t value) {\n+  size_t i = 0;\n+  for (; i < v_size; ++i) {\n+    if (v[i] == value) return i;\n+  }\n+  return i;\n+}\n+\n+static void MoveToFront(uint8_t* v, size_t index) {\n+  uint8_t value = v[index];\n+  size_t i;\n+  for (i = index; i != 0; --i) {\n+    v[i] = v[i - 1];\n+  }\n+  v[0] = value;\n+}\n+\n+static void MoveToFrontTransform(const uint32_t* BROTLI_RESTRICT v_in,\n+                                 const size_t v_size,\n+                                 uint32_t* v_out) {\n+  size_t i;\n+  uint8_t mtf[256];\n+  uint32_t max_value;\n+  if (v_size == 0) {\n+    return;\n+  }\n+  max_value = v_in[0];\n+  for (i = 1; i < v_size; ++i) {\n+    if (v_in[i] > max_value) max_value = v_in[i];\n+  }\n+  BROTLI_DCHECK(max_value < 256u);\n+  for (i = 0; i <= max_value; ++i) {\n+    mtf[i] = (uint8_t)i;\n+  }\n+  {\n+    size_t mtf_size = max_value + 1;\n+    for (i = 0; i < v_size; ++i) {\n+      size_t index = IndexOf(mtf, mtf_size, (uint8_t)v_in[i]);\n+      BROTLI_DCHECK(index < mtf_size);\n+      v_out[i] = (uint32_t)index;\n+      MoveToFront(mtf, index);\n+    }\n+  }\n+}\n+\n+/* Finds runs of zeros in v[0..in_size) and replaces them with a prefix code of\n+   the run length plus extra bits (lower 9 bits is the prefix code and the rest\n+   are the extra bits). Non-zero values in v[] are shifted by\n+   *max_length_prefix. Will not create prefix codes bigger than the initial\n+   value of *max_run_length_prefix. The prefix code of run length L is simply\n+   Log2Floor(L) and the number of extra bits is the same as the prefix code. */\n+static void RunLengthCodeZeros(const size_t in_size,\n+    uint32_t* BROTLI_RESTRICT v, size_t* BROTLI_RESTRICT out_size,\n+    uint32_t* BROTLI_RESTRICT max_run_length_prefix) {\n+  uint32_t max_reps = 0;\n+  size_t i;\n+  uint32_t max_prefix;\n+  for (i = 0; i < in_size;) {\n+    uint32_t reps = 0;\n+    for (; i < in_size && v[i] != 0; ++i) ;\n+    for (; i < in_size && v[i] == 0; ++i) {\n+      ++reps;\n+    }\n+    max_reps = BROTLI_MAX(uint32_t, reps, max_reps);\n+  }\n+  max_prefix = max_reps > 0 ? Log2FloorNonZero(max_reps) : 0;\n+  max_prefix = BROTLI_MIN(uint32_t, max_prefix, *max_run_length_prefix);\n+  *max_run_length_prefix = max_prefix;\n+  *out_size = 0;\n+  for (i = 0; i < in_size;) {\n+    BROTLI_DCHECK(*out_size <= i);\n+    if (v[i] != 0) {\n+      v[*out_size] = v[i] + *max_run_length_prefix;\n+      ++i;\n+      ++(*out_size);\n+    } else {\n+      uint32_t reps = 1;\n+      size_t k;\n+      for (k = i + 1; k < in_size && v[k] == 0; ++k) {\n+        ++reps;\n+      }\n+      i += reps;\n+      while (reps != 0) {\n+        if (reps < (2u << max_prefix)) {\n+          uint32_t run_length_prefix = Log2FloorNonZero(reps);\n+          const uint32_t extra_bits = reps - (1u << run_length_prefix);\n+          v[*out_size] = run_length_prefix + (extra_bits << 9);\n+          ++(*out_size);\n+          break;\n+        } else {\n+          const uint32_t extra_bits = (1u << max_prefix) - 1u;\n+          v[*out_size] = max_prefix + (extra_bits << 9);\n+          reps -= (2u << max_prefix) - 1u;\n+          ++(*out_size);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+#define SYMBOL_BITS 9\n+\n+static void EncodeContextMap(MemoryManager* m,\n+                             const uint32_t* context_map,\n+                             size_t context_map_size,\n+                             size_t num_clusters,\n+                             HuffmanTree* tree,\n+                             size_t* storage_ix, uint8_t* storage) {\n+  size_t i;\n+  uint32_t* rle_symbols;\n+  uint32_t max_run_length_prefix = 6;\n+  size_t num_rle_symbols = 0;\n+  uint32_t histogram[BROTLI_MAX_CONTEXT_MAP_SYMBOLS];\n+  static const uint32_t kSymbolMask = (1u << SYMBOL_BITS) - 1u;\n+  uint8_t depths[BROTLI_MAX_CONTEXT_MAP_SYMBOLS];\n+  uint16_t bits[BROTLI_MAX_CONTEXT_MAP_SYMBOLS];\n+\n+  StoreVarLenUint8(num_clusters - 1, storage_ix, storage);\n+\n+  if (num_clusters == 1) {\n+    return;\n+  }\n+\n+  rle_symbols = BROTLI_ALLOC(m, uint32_t, context_map_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+  MoveToFrontTransform(context_map, context_map_size, rle_symbols);\n+  RunLengthCodeZeros(context_map_size, rle_symbols,\n+                     &num_rle_symbols, &max_run_length_prefix);\n+  memset(histogram, 0, sizeof(histogram));\n+  for (i = 0; i < num_rle_symbols; ++i) {\n+    ++histogram[rle_symbols[i] & kSymbolMask];\n+  }\n+  {\n+    BROTLI_BOOL use_rle = TO_BROTLI_BOOL(max_run_length_prefix > 0);\n+    BrotliWriteBits(1, (uint64_t)use_rle, storage_ix, storage);\n+    if (use_rle) {\n+      BrotliWriteBits(4, max_run_length_prefix - 1, storage_ix, storage);\n+    }\n+  }\n+  BuildAndStoreHuffmanTree(histogram, num_clusters + max_run_length_prefix,\n+                           num_clusters + max_run_length_prefix,\n+                           tree, depths, bits, storage_ix, storage);\n+  for (i = 0; i < num_rle_symbols; ++i) {\n+    const uint32_t rle_symbol = rle_symbols[i] & kSymbolMask;\n+    const uint32_t extra_bits_val = rle_symbols[i] >> SYMBOL_BITS;\n+    BrotliWriteBits(depths[rle_symbol], bits[rle_symbol], storage_ix, storage);\n+    if (rle_symbol > 0 && rle_symbol <= max_run_length_prefix) {\n+      BrotliWriteBits(rle_symbol, extra_bits_val, storage_ix, storage);\n+    }\n+  }\n+  BrotliWriteBits(1, 1, storage_ix, storage);  /* use move-to-front */\n+  BROTLI_FREE(m, rle_symbols);\n+}\n+\n+/* Stores the block switch command with index block_ix to the bit stream. */\n+static BROTLI_INLINE void StoreBlockSwitch(BlockSplitCode* code,\n+                                           const uint32_t block_len,\n+                                           const uint8_t block_type,\n+                                           BROTLI_BOOL is_first_block,\n+                                           size_t* storage_ix,\n+                                           uint8_t* storage) {\n+  size_t typecode = NextBlockTypeCode(&code->type_code_calculator, block_type);\n+  size_t lencode;\n+  uint32_t len_nextra;\n+  uint32_t len_extra;\n+  if (!is_first_block) {\n+    BrotliWriteBits(code->type_depths[typecode], code->type_bits[typecode],\n+                    storage_ix, storage);\n+  }\n+  GetBlockLengthPrefixCode(block_len, &lencode, &len_nextra, &len_extra);\n+\n+  BrotliWriteBits(code->length_depths[lencode], code->length_bits[lencode],\n+                  storage_ix, storage);\n+  BrotliWriteBits(len_nextra, len_extra, storage_ix, storage);\n+}\n+\n+/* Builds a BlockSplitCode data structure from the block split given by the\n+   vector of block types and block lengths and stores it to the bit stream. */\n+static void BuildAndStoreBlockSplitCode(const uint8_t* types,\n+                                        const uint32_t* lengths,\n+                                        const size_t num_blocks,\n+                                        const size_t num_types,\n+                                        HuffmanTree* tree,\n+                                        BlockSplitCode* code,\n+                                        size_t* storage_ix,\n+                                        uint8_t* storage) {\n+  uint32_t type_histo[BROTLI_MAX_BLOCK_TYPE_SYMBOLS];\n+  uint32_t length_histo[BROTLI_NUM_BLOCK_LEN_SYMBOLS];\n+  size_t i;\n+  BlockTypeCodeCalculator type_code_calculator;\n+  memset(type_histo, 0, (num_types + 2) * sizeof(type_histo[0]));\n+  memset(length_histo, 0, sizeof(length_histo));\n+  InitBlockTypeCodeCalculator(&type_code_calculator);\n+  for (i = 0; i < num_blocks; ++i) {\n+    size_t type_code = NextBlockTypeCode(&type_code_calculator, types[i]);\n+    if (i != 0) ++type_histo[type_code];\n+    ++length_histo[BlockLengthPrefixCode(lengths[i])];\n+  }\n+  StoreVarLenUint8(num_types - 1, storage_ix, storage);\n+  if (num_types > 1) {  /* TODO: else? could StoreBlockSwitch occur? */\n+    BuildAndStoreHuffmanTree(&type_histo[0], num_types + 2, num_types + 2, tree,\n+                             &code->type_depths[0], &code->type_bits[0],\n+                             storage_ix, storage);\n+    BuildAndStoreHuffmanTree(&length_histo[0], BROTLI_NUM_BLOCK_LEN_SYMBOLS,\n+                             BROTLI_NUM_BLOCK_LEN_SYMBOLS,\n+                             tree, &code->length_depths[0],\n+                             &code->length_bits[0], storage_ix, storage);\n+    StoreBlockSwitch(code, lengths[0], types[0], 1, storage_ix, storage);\n+  }\n+}\n+\n+/* Stores a context map where the histogram type is always the block type. */\n+static void StoreTrivialContextMap(size_t num_types,\n+                                   size_t context_bits,\n+                                   HuffmanTree* tree,\n+                                   size_t* storage_ix,\n+                                   uint8_t* storage) {\n+  StoreVarLenUint8(num_types - 1, storage_ix, storage);\n+  if (num_types > 1) {\n+    size_t repeat_code = context_bits - 1u;\n+    size_t repeat_bits = (1u << repeat_code) - 1u;\n+    size_t alphabet_size = num_types + repeat_code;\n+    uint32_t histogram[BROTLI_MAX_CONTEXT_MAP_SYMBOLS];\n+    uint8_t depths[BROTLI_MAX_CONTEXT_MAP_SYMBOLS];\n+    uint16_t bits[BROTLI_MAX_CONTEXT_MAP_SYMBOLS];\n+    size_t i;\n+    memset(histogram, 0, alphabet_size * sizeof(histogram[0]));\n+    /* Write RLEMAX. */\n+    BrotliWriteBits(1, 1, storage_ix, storage);\n+    BrotliWriteBits(4, repeat_code - 1, storage_ix, storage);\n+    histogram[repeat_code] = (uint32_t)num_types;\n+    histogram[0] = 1;\n+    for (i = context_bits; i < alphabet_size; ++i) {\n+      histogram[i] = 1;\n+    }\n+    BuildAndStoreHuffmanTree(histogram, alphabet_size, alphabet_size,\n+                             tree, depths, bits, storage_ix, storage);\n+    for (i = 0; i < num_types; ++i) {\n+      size_t code = (i == 0 ? 0 : i + context_bits - 1);\n+      BrotliWriteBits(depths[code], bits[code], storage_ix, storage);\n+      BrotliWriteBits(\n+          depths[repeat_code], bits[repeat_code], storage_ix, storage);\n+      BrotliWriteBits(repeat_code, repeat_bits, storage_ix, storage);\n+    }\n+    /* Write IMTF (inverse-move-to-front) bit. */\n+    BrotliWriteBits(1, 1, storage_ix, storage);\n+  }\n+}\n+\n+/* Manages the encoding of one block category (literal, command or distance). */\n+typedef struct BlockEncoder {\n+  size_t histogram_length_;\n+  size_t num_block_types_;\n+  const uint8_t* block_types_;  /* Not owned. */\n+  const uint32_t* block_lengths_;  /* Not owned. */\n+  size_t num_blocks_;\n+  BlockSplitCode block_split_code_;\n+  size_t block_ix_;\n+  size_t block_len_;\n+  size_t entropy_ix_;\n+  uint8_t* depths_;\n+  uint16_t* bits_;\n+} BlockEncoder;\n+\n+static void InitBlockEncoder(BlockEncoder* self, size_t histogram_length,\n+    size_t num_block_types, const uint8_t* block_types,\n+    const uint32_t* block_lengths, const size_t num_blocks) {\n+  self->histogram_length_ = histogram_length;\n+  self->num_block_types_ = num_block_types;\n+  self->block_types_ = block_types;\n+  self->block_lengths_ = block_lengths;\n+  self->num_blocks_ = num_blocks;\n+  InitBlockTypeCodeCalculator(&self->block_split_code_.type_code_calculator);\n+  self->block_ix_ = 0;\n+  self->block_len_ = num_blocks == 0 ? 0 : block_lengths[0];\n+  self->entropy_ix_ = 0;\n+  self->depths_ = 0;\n+  self->bits_ = 0;\n+}\n+\n+static void CleanupBlockEncoder(MemoryManager* m, BlockEncoder* self) {\n+  BROTLI_FREE(m, self->depths_);\n+  BROTLI_FREE(m, self->bits_);\n+}\n+\n+/* Creates entropy codes of block lengths and block types and stores them\n+   to the bit stream. */\n+static void BuildAndStoreBlockSwitchEntropyCodes(BlockEncoder* self,\n+    HuffmanTree* tree, size_t* storage_ix, uint8_t* storage) {\n+  BuildAndStoreBlockSplitCode(self->block_types_, self->block_lengths_,\n+      self->num_blocks_, self->num_block_types_, tree, &self->block_split_code_,\n+      storage_ix, storage);\n+}\n+\n+/* Stores the next symbol with the entropy code of the current block type.\n+   Updates the block type and block length at block boundaries. */\n+static void StoreSymbol(BlockEncoder* self, size_t symbol, size_t* storage_ix,\n+    uint8_t* storage) {\n+  if (self->block_len_ == 0) {\n+    size_t block_ix = ++self->block_ix_;\n+    uint32_t block_len = self->block_lengths_[block_ix];\n+    uint8_t block_type = self->block_types_[block_ix];\n+    self->block_len_ = block_len;\n+    self->entropy_ix_ = block_type * self->histogram_length_;\n+    StoreBlockSwitch(&self->block_split_code_, block_len, block_type, 0,\n+        storage_ix, storage);\n+  }\n+  --self->block_len_;\n+  {\n+    size_t ix = self->entropy_ix_ + symbol;\n+    BrotliWriteBits(self->depths_[ix], self->bits_[ix], storage_ix, storage);\n+  }\n+}\n+\n+/* Stores the next symbol with the entropy code of the current block type and\n+   context value.\n+   Updates the block type and block length at block boundaries. */\n+static void StoreSymbolWithContext(BlockEncoder* self, size_t symbol,\n+    size_t context, const uint32_t* context_map, size_t* storage_ix,\n+    uint8_t* storage, const size_t context_bits) {\n+  if (self->block_len_ == 0) {\n+    size_t block_ix = ++self->block_ix_;\n+    uint32_t block_len = self->block_lengths_[block_ix];\n+    uint8_t block_type = self->block_types_[block_ix];\n+    self->block_len_ = block_len;\n+    self->entropy_ix_ = (size_t)block_type << context_bits;\n+    StoreBlockSwitch(&self->block_split_code_, block_len, block_type, 0,\n+        storage_ix, storage);\n+  }\n+  --self->block_len_;\n+  {\n+    size_t histo_ix = context_map[self->entropy_ix_ + context];\n+    size_t ix = histo_ix * self->histogram_length_ + symbol;\n+    BrotliWriteBits(self->depths_[ix], self->bits_[ix], storage_ix, storage);\n+  }\n+}\n+\n+#define FN(X) X ## Literal\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./block_encoder_inc.h\"\n+#undef FN\n+\n+#define FN(X) X ## Command\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./block_encoder_inc.h\"\n+#undef FN\n+\n+#define FN(X) X ## Distance\n+/* NOLINTNEXTLINE(build/include) */\n+#include \"./block_encoder_inc.h\"\n+#undef FN\n+\n+static void JumpToByteBoundary(size_t* storage_ix, uint8_t* storage) {\n+  *storage_ix = (*storage_ix + 7u) & ~7u;\n+  storage[*storage_ix >> 3] = 0;\n+}\n+\n+void BrotliStoreMetaBlock(MemoryManager* m,\n+    const uint8_t* input, size_t start_pos, size_t length, size_t mask,\n+    uint8_t prev_byte, uint8_t prev_byte2, BROTLI_BOOL is_last,\n+    const BrotliEncoderParams* params, ContextType literal_context_mode,\n+    const Command* commands, size_t n_commands, const MetaBlockSplit* mb,\n+    size_t* storage_ix, uint8_t* storage) {\n+\n+  size_t pos = start_pos;\n+  size_t i;\n+  uint32_t num_distance_symbols = params->dist.alphabet_size;\n+  uint32_t num_effective_distance_symbols = num_distance_symbols;\n+  HuffmanTree* tree;\n+  ContextLut literal_context_lut = BROTLI_CONTEXT_LUT(literal_context_mode);\n+  BlockEncoder literal_enc;\n+  BlockEncoder command_enc;\n+  BlockEncoder distance_enc;\n+  const BrotliDistanceParams* dist = &params->dist;\n+  if (params->large_window &&\n+      num_effective_distance_symbols > BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS) {\n+    num_effective_distance_symbols = BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS;\n+  }\n+\n+  StoreCompressedMetaBlockHeader(is_last, length, storage_ix, storage);\n+\n+  tree = BROTLI_ALLOC(m, HuffmanTree, MAX_HUFFMAN_TREE_SIZE);\n+  if (BROTLI_IS_OOM(m)) return;\n+  InitBlockEncoder(&literal_enc, BROTLI_NUM_LITERAL_SYMBOLS,\n+      mb->literal_split.num_types, mb->literal_split.types,\n+      mb->literal_split.lengths, mb->literal_split.num_blocks);\n+  InitBlockEncoder(&command_enc, BROTLI_NUM_COMMAND_SYMBOLS,\n+      mb->command_split.num_types, mb->command_split.types,\n+      mb->command_split.lengths, mb->command_split.num_blocks);\n+  InitBlockEncoder(&distance_enc, num_effective_distance_symbols,\n+      mb->distance_split.num_types, mb->distance_split.types,\n+      mb->distance_split.lengths, mb->distance_split.num_blocks);\n+\n+  BuildAndStoreBlockSwitchEntropyCodes(&literal_enc, tree, storage_ix, storage);\n+  BuildAndStoreBlockSwitchEntropyCodes(&command_enc, tree, storage_ix, storage);\n+  BuildAndStoreBlockSwitchEntropyCodes(\n+      &distance_enc, tree, storage_ix, storage);\n+\n+  BrotliWriteBits(2, dist->distance_postfix_bits, storage_ix, storage);\n+  BrotliWriteBits(\n+      4, dist->num_direct_distance_codes >> dist->distance_postfix_bits,\n+      storage_ix, storage);\n+  for (i = 0; i < mb->literal_split.num_types; ++i) {\n+    BrotliWriteBits(2, literal_context_mode, storage_ix, storage);\n+  }\n+\n+  if (mb->literal_context_map_size == 0) {\n+    StoreTrivialContextMap(mb->literal_histograms_size,\n+        BROTLI_LITERAL_CONTEXT_BITS, tree, storage_ix, storage);\n+  } else {\n+    EncodeContextMap(m,\n+        mb->literal_context_map, mb->literal_context_map_size,\n+        mb->literal_histograms_size, tree, storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+  }\n+\n+  if (mb->distance_context_map_size == 0) {\n+    StoreTrivialContextMap(mb->distance_histograms_size,\n+        BROTLI_DISTANCE_CONTEXT_BITS, tree, storage_ix, storage);\n+  } else {\n+    EncodeContextMap(m,\n+        mb->distance_context_map, mb->distance_context_map_size,\n+        mb->distance_histograms_size, tree, storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+  }\n+\n+  BuildAndStoreEntropyCodesLiteral(m, &literal_enc, mb->literal_histograms,\n+      mb->literal_histograms_size, BROTLI_NUM_LITERAL_SYMBOLS, tree,\n+      storage_ix, storage);\n+  if (BROTLI_IS_OOM(m)) return;\n+  BuildAndStoreEntropyCodesCommand(m, &command_enc, mb->command_histograms,\n+      mb->command_histograms_size, BROTLI_NUM_COMMAND_SYMBOLS, tree,\n+      storage_ix, storage);\n+  if (BROTLI_IS_OOM(m)) return;\n+  BuildAndStoreEntropyCodesDistance(m, &distance_enc, mb->distance_histograms,\n+      mb->distance_histograms_size, num_distance_symbols, tree,\n+      storage_ix, storage);\n+  if (BROTLI_IS_OOM(m)) return;\n+  BROTLI_FREE(m, tree);\n+\n+  for (i = 0; i < n_commands; ++i) {\n+    const Command cmd = commands[i];\n+    size_t cmd_code = cmd.cmd_prefix_;\n+    StoreSymbol(&command_enc, cmd_code, storage_ix, storage);\n+    StoreCommandExtra(&cmd, storage_ix, storage);\n+    if (mb->literal_context_map_size == 0) {\n+      size_t j;\n+      for (j = cmd.insert_len_; j != 0; --j) {\n+        StoreSymbol(&literal_enc, input[pos & mask], storage_ix, storage);\n+        ++pos;\n+      }\n+    } else {\n+      size_t j;\n+      for (j = cmd.insert_len_; j != 0; --j) {\n+        size_t context =\n+            BROTLI_CONTEXT(prev_byte, prev_byte2, literal_context_lut);\n+        uint8_t literal = input[pos & mask];\n+        StoreSymbolWithContext(&literal_enc, literal, context,\n+            mb->literal_context_map, storage_ix, storage,\n+            BROTLI_LITERAL_CONTEXT_BITS);\n+        prev_byte2 = prev_byte;\n+        prev_byte = literal;\n+        ++pos;\n+      }\n+    }\n+    pos += CommandCopyLen(&cmd);\n+    if (CommandCopyLen(&cmd)) {\n+      prev_byte2 = input[(pos - 2) & mask];\n+      prev_byte = input[(pos - 1) & mask];\n+      if (cmd.cmd_prefix_ >= 128) {\n+        size_t dist_code = cmd.dist_prefix_ & 0x3FF;\n+        uint32_t distnumextra = cmd.dist_prefix_ >> 10;\n+        uint64_t distextra = cmd.dist_extra_;\n+        if (mb->distance_context_map_size == 0) {\n+          StoreSymbol(&distance_enc, dist_code, storage_ix, storage);\n+        } else {\n+          size_t context = CommandDistanceContext(&cmd);\n+          StoreSymbolWithContext(&distance_enc, dist_code, context,\n+              mb->distance_context_map, storage_ix, storage,\n+              BROTLI_DISTANCE_CONTEXT_BITS);\n+        }\n+        BrotliWriteBits(distnumextra, distextra, storage_ix, storage);\n+      }\n+    }\n+  }\n+  CleanupBlockEncoder(m, &distance_enc);\n+  CleanupBlockEncoder(m, &command_enc);\n+  CleanupBlockEncoder(m, &literal_enc);\n+  if (is_last) {\n+    JumpToByteBoundary(storage_ix, storage);\n+  }\n+}\n+\n+static void BuildHistograms(const uint8_t* input,\n+                            size_t start_pos,\n+                            size_t mask,\n+                            const Command* commands,\n+                            size_t n_commands,\n+                            HistogramLiteral* lit_histo,\n+                            HistogramCommand* cmd_histo,\n+                            HistogramDistance* dist_histo) {\n+  size_t pos = start_pos;\n+  size_t i;\n+  for (i = 0; i < n_commands; ++i) {\n+    const Command cmd = commands[i];\n+    size_t j;\n+    HistogramAddCommand(cmd_histo, cmd.cmd_prefix_);\n+    for (j = cmd.insert_len_; j != 0; --j) {\n+      HistogramAddLiteral(lit_histo, input[pos & mask]);\n+      ++pos;\n+    }\n+    pos += CommandCopyLen(&cmd);\n+    if (CommandCopyLen(&cmd) && cmd.cmd_prefix_ >= 128) {\n+      HistogramAddDistance(dist_histo, cmd.dist_prefix_ & 0x3FF);\n+    }\n+  }\n+}\n+\n+static void StoreDataWithHuffmanCodes(const uint8_t* input,\n+                                      size_t start_pos,\n+                                      size_t mask,\n+                                      const Command* commands,\n+                                      size_t n_commands,\n+                                      const uint8_t* lit_depth,\n+                                      const uint16_t* lit_bits,\n+                                      const uint8_t* cmd_depth,\n+                                      const uint16_t* cmd_bits,\n+                                      const uint8_t* dist_depth,\n+                                      const uint16_t* dist_bits,\n+                                      size_t* storage_ix,\n+                                      uint8_t* storage) {\n+  size_t pos = start_pos;\n+  size_t i;\n+  for (i = 0; i < n_commands; ++i) {\n+    const Command cmd = commands[i];\n+    const size_t cmd_code = cmd.cmd_prefix_;\n+    size_t j;\n+    BrotliWriteBits(\n+        cmd_depth[cmd_code], cmd_bits[cmd_code], storage_ix, storage);\n+    StoreCommandExtra(&cmd, storage_ix, storage);\n+    for (j = cmd.insert_len_; j != 0; --j) {\n+      const uint8_t literal = input[pos & mask];\n+      BrotliWriteBits(\n+          lit_depth[literal], lit_bits[literal], storage_ix, storage);\n+      ++pos;\n+    }\n+    pos += CommandCopyLen(&cmd);\n+    if (CommandCopyLen(&cmd) && cmd.cmd_prefix_ >= 128) {\n+      const size_t dist_code = cmd.dist_prefix_ & 0x3FF;\n+      const uint32_t distnumextra = cmd.dist_prefix_ >> 10;\n+      const uint32_t distextra = cmd.dist_extra_;\n+      BrotliWriteBits(dist_depth[dist_code], dist_bits[dist_code],\n+                      storage_ix, storage);\n+      BrotliWriteBits(distnumextra, distextra, storage_ix, storage);\n+    }\n+  }\n+}\n+\n+void BrotliStoreMetaBlockTrivial(MemoryManager* m,\n+    const uint8_t* input, size_t start_pos, size_t length, size_t mask,\n+    BROTLI_BOOL is_last, const BrotliEncoderParams* params,\n+    const Command* commands, size_t n_commands,\n+    size_t* storage_ix, uint8_t* storage) {\n+  HistogramLiteral lit_histo;\n+  HistogramCommand cmd_histo;\n+  HistogramDistance dist_histo;\n+  uint8_t lit_depth[BROTLI_NUM_LITERAL_SYMBOLS];\n+  uint16_t lit_bits[BROTLI_NUM_LITERAL_SYMBOLS];\n+  uint8_t cmd_depth[BROTLI_NUM_COMMAND_SYMBOLS];\n+  uint16_t cmd_bits[BROTLI_NUM_COMMAND_SYMBOLS];\n+  uint8_t dist_depth[MAX_SIMPLE_DISTANCE_ALPHABET_SIZE];\n+  uint16_t dist_bits[MAX_SIMPLE_DISTANCE_ALPHABET_SIZE];\n+  HuffmanTree* tree;\n+  uint32_t num_distance_symbols = params->dist.alphabet_size;\n+\n+  StoreCompressedMetaBlockHeader(is_last, length, storage_ix, storage);\n+\n+  HistogramClearLiteral(&lit_histo);\n+  HistogramClearCommand(&cmd_histo);\n+  HistogramClearDistance(&dist_histo);\n+\n+  BuildHistograms(input, start_pos, mask, commands, n_commands,\n+                  &lit_histo, &cmd_histo, &dist_histo);\n+\n+  BrotliWriteBits(13, 0, storage_ix, storage);\n+\n+  tree = BROTLI_ALLOC(m, HuffmanTree, MAX_HUFFMAN_TREE_SIZE);\n+  if (BROTLI_IS_OOM(m)) return;\n+  BuildAndStoreHuffmanTree(lit_histo.data_, BROTLI_NUM_LITERAL_SYMBOLS,\n+                           BROTLI_NUM_LITERAL_SYMBOLS, tree,\n+                           lit_depth, lit_bits,\n+                           storage_ix, storage);\n+  BuildAndStoreHuffmanTree(cmd_histo.data_, BROTLI_NUM_COMMAND_SYMBOLS,\n+                           BROTLI_NUM_COMMAND_SYMBOLS, tree,\n+                           cmd_depth, cmd_bits,\n+                           storage_ix, storage);\n+  BuildAndStoreHuffmanTree(dist_histo.data_, MAX_SIMPLE_DISTANCE_ALPHABET_SIZE,\n+                           num_distance_symbols, tree,\n+                           dist_depth, dist_bits,\n+                           storage_ix, storage);\n+  BROTLI_FREE(m, tree);\n+  StoreDataWithHuffmanCodes(input, start_pos, mask, commands,\n+                            n_commands, lit_depth, lit_bits,\n+                            cmd_depth, cmd_bits,\n+                            dist_depth, dist_bits,\n+                            storage_ix, storage);\n+  if (is_last) {\n+    JumpToByteBoundary(storage_ix, storage);\n+  }\n+}\n+\n+void BrotliStoreMetaBlockFast(MemoryManager* m,\n+    const uint8_t* input, size_t start_pos, size_t length, size_t mask,\n+    BROTLI_BOOL is_last, const BrotliEncoderParams* params,\n+    const Command* commands, size_t n_commands,\n+    size_t* storage_ix, uint8_t* storage) {\n+  uint32_t num_distance_symbols = params->dist.alphabet_size;\n+  uint32_t distance_alphabet_bits =\n+      Log2FloorNonZero(num_distance_symbols - 1) + 1;\n+\n+  StoreCompressedMetaBlockHeader(is_last, length, storage_ix, storage);\n+\n+  BrotliWriteBits(13, 0, storage_ix, storage);\n+\n+  if (n_commands <= 128) {\n+    uint32_t histogram[BROTLI_NUM_LITERAL_SYMBOLS] = { 0 };\n+    size_t pos = start_pos;\n+    size_t num_literals = 0;\n+    size_t i;\n+    uint8_t lit_depth[BROTLI_NUM_LITERAL_SYMBOLS];\n+    uint16_t lit_bits[BROTLI_NUM_LITERAL_SYMBOLS];\n+    for (i = 0; i < n_commands; ++i) {\n+      const Command cmd = commands[i];\n+      size_t j;\n+      for (j = cmd.insert_len_; j != 0; --j) {\n+        ++histogram[input[pos & mask]];\n+        ++pos;\n+      }\n+      num_literals += cmd.insert_len_;\n+      pos += CommandCopyLen(&cmd);\n+    }\n+    BrotliBuildAndStoreHuffmanTreeFast(m, histogram, num_literals,\n+                                       /* max_bits = */ 8,\n+                                       lit_depth, lit_bits,\n+                                       storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+    StoreStaticCommandHuffmanTree(storage_ix, storage);\n+    StoreStaticDistanceHuffmanTree(storage_ix, storage);\n+    StoreDataWithHuffmanCodes(input, start_pos, mask, commands,\n+                              n_commands, lit_depth, lit_bits,\n+                              kStaticCommandCodeDepth,\n+                              kStaticCommandCodeBits,\n+                              kStaticDistanceCodeDepth,\n+                              kStaticDistanceCodeBits,\n+                              storage_ix, storage);\n+  } else {\n+    HistogramLiteral lit_histo;\n+    HistogramCommand cmd_histo;\n+    HistogramDistance dist_histo;\n+    uint8_t lit_depth[BROTLI_NUM_LITERAL_SYMBOLS];\n+    uint16_t lit_bits[BROTLI_NUM_LITERAL_SYMBOLS];\n+    uint8_t cmd_depth[BROTLI_NUM_COMMAND_SYMBOLS];\n+    uint16_t cmd_bits[BROTLI_NUM_COMMAND_SYMBOLS];\n+    uint8_t dist_depth[MAX_SIMPLE_DISTANCE_ALPHABET_SIZE];\n+    uint16_t dist_bits[MAX_SIMPLE_DISTANCE_ALPHABET_SIZE];\n+    HistogramClearLiteral(&lit_histo);\n+    HistogramClearCommand(&cmd_histo);\n+    HistogramClearDistance(&dist_histo);\n+    BuildHistograms(input, start_pos, mask, commands, n_commands,\n+                    &lit_histo, &cmd_histo, &dist_histo);\n+    BrotliBuildAndStoreHuffmanTreeFast(m, lit_histo.data_,\n+                                       lit_histo.total_count_,\n+                                       /* max_bits = */ 8,\n+                                       lit_depth, lit_bits,\n+                                       storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+    BrotliBuildAndStoreHuffmanTreeFast(m, cmd_histo.data_,\n+                                       cmd_histo.total_count_,\n+                                       /* max_bits = */ 10,\n+                                       cmd_depth, cmd_bits,\n+                                       storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+    BrotliBuildAndStoreHuffmanTreeFast(m, dist_histo.data_,\n+                                       dist_histo.total_count_,\n+                                       /* max_bits = */\n+                                       distance_alphabet_bits,\n+                                       dist_depth, dist_bits,\n+                                       storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+    StoreDataWithHuffmanCodes(input, start_pos, mask, commands,\n+                              n_commands, lit_depth, lit_bits,\n+                              cmd_depth, cmd_bits,\n+                              dist_depth, dist_bits,\n+                              storage_ix, storage);\n+  }\n+\n+  if (is_last) {\n+    JumpToByteBoundary(storage_ix, storage);\n+  }\n+}\n+\n+/* This is for storing uncompressed blocks (simple raw storage of\n+   bytes-as-bytes). */\n+void BrotliStoreUncompressedMetaBlock(BROTLI_BOOL is_final_block,\n+                                      const uint8_t* BROTLI_RESTRICT input,\n+                                      size_t position, size_t mask,\n+                                      size_t len,\n+                                      size_t* BROTLI_RESTRICT storage_ix,\n+                                      uint8_t* BROTLI_RESTRICT storage) {\n+  size_t masked_pos = position & mask;\n+  BrotliStoreUncompressedMetaBlockHeader(len, storage_ix, storage);\n+  JumpToByteBoundary(storage_ix, storage);\n+\n+  if (masked_pos + len > mask + 1) {\n+    size_t len1 = mask + 1 - masked_pos;\n+    memcpy(&storage[*storage_ix >> 3], &input[masked_pos], len1);\n+    *storage_ix += len1 << 3;\n+    len -= len1;\n+    masked_pos = 0;\n+  }\n+  memcpy(&storage[*storage_ix >> 3], &input[masked_pos], len);\n+  *storage_ix += len << 3;\n+\n+  /* We need to clear the next 4 bytes to continue to be\n+     compatible with BrotliWriteBits. */\n+  BrotliWriteBitsPrepareStorage(*storage_ix, storage);\n+\n+  /* Since the uncompressed block itself may not be the final block, add an\n+     empty one after this. */\n+  if (is_final_block) {\n+    BrotliWriteBits(1, 1, storage_ix, storage);  /* islast */\n+    BrotliWriteBits(1, 1, storage_ix, storage);  /* isempty */\n+    JumpToByteBoundary(storage_ix, storage);\n+  }\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "2ed703bf7994b01f57bb300582b95811d3a07059",
            "filename": "deps/brotli/c/enc/brotli_bit_stream.h",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbrotli_bit_stream.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fbrotli_bit_stream.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fbrotli_bit_stream.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,84 @@\n+/* Copyright 2014 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Functions to convert brotli-related data structures into the\n+   brotli bit stream. The functions here operate under\n+   assumption that there is enough space in the storage, i.e., there are\n+   no out-of-range checks anywhere.\n+\n+   These functions do bit addressing into a byte array. The byte array\n+   is called \"storage\" and the index to the bit is called storage_ix\n+   in function arguments. */\n+\n+#ifndef BROTLI_ENC_BROTLI_BIT_STREAM_H_\n+#define BROTLI_ENC_BROTLI_BIT_STREAM_H_\n+\n+#include \"../common/context.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./command.h\"\n+#include \"./entropy_encode.h\"\n+#include \"./memory.h\"\n+#include \"./metablock.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* All Store functions here will use a storage_ix, which is always the bit\n+   position for the current storage. */\n+\n+BROTLI_INTERNAL void BrotliStoreHuffmanTree(const uint8_t* depths, size_t num,\n+    HuffmanTree* tree, size_t* storage_ix, uint8_t* storage);\n+\n+BROTLI_INTERNAL void BrotliBuildAndStoreHuffmanTreeFast(\n+    MemoryManager* m, const uint32_t* histogram, const size_t histogram_total,\n+    const size_t max_bits, uint8_t* depth, uint16_t* bits, size_t* storage_ix,\n+    uint8_t* storage);\n+\n+/* REQUIRES: length > 0 */\n+/* REQUIRES: length <= (1 << 24) */\n+BROTLI_INTERNAL void BrotliStoreMetaBlock(MemoryManager* m,\n+    const uint8_t* input, size_t start_pos, size_t length, size_t mask,\n+    uint8_t prev_byte, uint8_t prev_byte2, BROTLI_BOOL is_last,\n+    const BrotliEncoderParams* params, ContextType literal_context_mode,\n+    const Command* commands, size_t n_commands, const MetaBlockSplit* mb,\n+    size_t* storage_ix, uint8_t* storage);\n+\n+/* Stores the meta-block without doing any block splitting, just collects\n+   one histogram per block category and uses that for entropy coding.\n+   REQUIRES: length > 0\n+   REQUIRES: length <= (1 << 24) */\n+BROTLI_INTERNAL void BrotliStoreMetaBlockTrivial(MemoryManager* m,\n+    const uint8_t* input, size_t start_pos, size_t length, size_t mask,\n+    BROTLI_BOOL is_last, const BrotliEncoderParams* params,\n+    const Command* commands, size_t n_commands,\n+    size_t* storage_ix, uint8_t* storage);\n+\n+/* Same as above, but uses static prefix codes for histograms with a only a few\n+   symbols, and uses static code length prefix codes for all other histograms.\n+   REQUIRES: length > 0\n+   REQUIRES: length <= (1 << 24) */\n+BROTLI_INTERNAL void BrotliStoreMetaBlockFast(MemoryManager* m,\n+    const uint8_t* input, size_t start_pos, size_t length, size_t mask,\n+    BROTLI_BOOL is_last, const BrotliEncoderParams* params,\n+    const Command* commands, size_t n_commands,\n+    size_t* storage_ix, uint8_t* storage);\n+\n+/* This is for storing uncompressed blocks (simple raw storage of\n+   bytes-as-bytes).\n+   REQUIRES: length > 0\n+   REQUIRES: length <= (1 << 24) */\n+BROTLI_INTERNAL void BrotliStoreUncompressedMetaBlock(\n+    BROTLI_BOOL is_final_block, const uint8_t* BROTLI_RESTRICT input,\n+    size_t position, size_t mask, size_t len,\n+    size_t* BROTLI_RESTRICT storage_ix, uint8_t* BROTLI_RESTRICT storage);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_BROTLI_BIT_STREAM_H_ */"
        },
        {
            "sha": "a20dfd385ffa2c5cedb70b8f1cdd222c87671279",
            "filename": "deps/brotli/c/enc/cluster.c",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcluster.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcluster.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fcluster.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,56 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Functions for clustering similar histograms together. */\n+\n+#include \"./cluster.h\"\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./bit_cost.h\"  /* BrotliPopulationCost */\n+#include \"./fast_log.h\"\n+#include \"./histogram.h\"\n+#include \"./memory.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+static BROTLI_INLINE BROTLI_BOOL HistogramPairIsLess(\n+    const HistogramPair* p1, const HistogramPair* p2) {\n+  if (p1->cost_diff != p2->cost_diff) {\n+    return TO_BROTLI_BOOL(p1->cost_diff > p2->cost_diff);\n+  }\n+  return TO_BROTLI_BOOL((p1->idx2 - p1->idx1) > (p2->idx2 - p2->idx1));\n+}\n+\n+/* Returns entropy reduction of the context map when we combine two clusters. */\n+static BROTLI_INLINE double ClusterCostDiff(size_t size_a, size_t size_b) {\n+  size_t size_c = size_a + size_b;\n+  return (double)size_a * FastLog2(size_a) +\n+    (double)size_b * FastLog2(size_b) -\n+    (double)size_c * FastLog2(size_c);\n+}\n+\n+#define CODE(X) X\n+\n+#define FN(X) X ## Literal\n+#include \"./cluster_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#define FN(X) X ## Command\n+#include \"./cluster_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#define FN(X) X ## Distance\n+#include \"./cluster_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#undef CODE\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "bb26124d24d634e71dc7fe6b9ebf7be04f61bc06",
            "filename": "deps/brotli/c/enc/cluster.h",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcluster.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcluster.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fcluster.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,48 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Functions for clustering similar histograms together. */\n+\n+#ifndef BROTLI_ENC_CLUSTER_H_\n+#define BROTLI_ENC_CLUSTER_H_\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./histogram.h\"\n+#include \"./memory.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+typedef struct HistogramPair {\n+  uint32_t idx1;\n+  uint32_t idx2;\n+  double cost_combo;\n+  double cost_diff;\n+} HistogramPair;\n+\n+#define CODE(X) /* Declaration */;\n+\n+#define FN(X) X ## Literal\n+#include \"./cluster_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#define FN(X) X ## Command\n+#include \"./cluster_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#define FN(X) X ## Distance\n+#include \"./cluster_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#undef CODE\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_CLUSTER_H_ */"
        },
        {
            "sha": "22ecb3cca809df8d8bbe8dcd5eb631d1ed9b3fc0",
            "filename": "deps/brotli/c/enc/cluster_inc.h",
            "status": "added",
            "additions": 317,
            "deletions": 0,
            "changes": 317,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcluster_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcluster_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fcluster_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,317 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN, CODE */\n+\n+#define HistogramType FN(Histogram)\n+\n+/* Computes the bit cost reduction by combining out[idx1] and out[idx2] and if\n+   it is below a threshold, stores the pair (idx1, idx2) in the *pairs queue. */\n+BROTLI_INTERNAL void FN(BrotliCompareAndPushToQueue)(\n+    const HistogramType* out, const uint32_t* cluster_size, uint32_t idx1,\n+    uint32_t idx2, size_t max_num_pairs, HistogramPair* pairs,\n+    size_t* num_pairs) CODE({\n+  BROTLI_BOOL is_good_pair = BROTLI_FALSE;\n+  HistogramPair p;\n+  p.idx1 = p.idx2 = 0;\n+  p.cost_diff = p.cost_combo = 0;\n+  if (idx1 == idx2) {\n+    return;\n+  }\n+  if (idx2 < idx1) {\n+    uint32_t t = idx2;\n+    idx2 = idx1;\n+    idx1 = t;\n+  }\n+  p.idx1 = idx1;\n+  p.idx2 = idx2;\n+  p.cost_diff = 0.5 * ClusterCostDiff(cluster_size[idx1], cluster_size[idx2]);\n+  p.cost_diff -= out[idx1].bit_cost_;\n+  p.cost_diff -= out[idx2].bit_cost_;\n+\n+  if (out[idx1].total_count_ == 0) {\n+    p.cost_combo = out[idx2].bit_cost_;\n+    is_good_pair = BROTLI_TRUE;\n+  } else if (out[idx2].total_count_ == 0) {\n+    p.cost_combo = out[idx1].bit_cost_;\n+    is_good_pair = BROTLI_TRUE;\n+  } else {\n+    double threshold = *num_pairs == 0 ? 1e99 :\n+        BROTLI_MAX(double, 0.0, pairs[0].cost_diff);\n+    HistogramType combo = out[idx1];\n+    double cost_combo;\n+    FN(HistogramAddHistogram)(&combo, &out[idx2]);\n+    cost_combo = FN(BrotliPopulationCost)(&combo);\n+    if (cost_combo < threshold - p.cost_diff) {\n+      p.cost_combo = cost_combo;\n+      is_good_pair = BROTLI_TRUE;\n+    }\n+  }\n+  if (is_good_pair) {\n+    p.cost_diff += p.cost_combo;\n+    if (*num_pairs > 0 && HistogramPairIsLess(&pairs[0], &p)) {\n+      /* Replace the top of the queue if needed. */\n+      if (*num_pairs < max_num_pairs) {\n+        pairs[*num_pairs] = pairs[0];\n+        ++(*num_pairs);\n+      }\n+      pairs[0] = p;\n+    } else if (*num_pairs < max_num_pairs) {\n+      pairs[*num_pairs] = p;\n+      ++(*num_pairs);\n+    }\n+  }\n+})\n+\n+BROTLI_INTERNAL size_t FN(BrotliHistogramCombine)(HistogramType* out,\n+                                                  uint32_t* cluster_size,\n+                                                  uint32_t* symbols,\n+                                                  uint32_t* clusters,\n+                                                  HistogramPair* pairs,\n+                                                  size_t num_clusters,\n+                                                  size_t symbols_size,\n+                                                  size_t max_clusters,\n+                                                  size_t max_num_pairs) CODE({\n+  double cost_diff_threshold = 0.0;\n+  size_t min_cluster_size = 1;\n+  size_t num_pairs = 0;\n+\n+  {\n+    /* We maintain a vector of histogram pairs, with the property that the pair\n+       with the maximum bit cost reduction is the first. */\n+    size_t idx1;\n+    for (idx1 = 0; idx1 < num_clusters; ++idx1) {\n+      size_t idx2;\n+      for (idx2 = idx1 + 1; idx2 < num_clusters; ++idx2) {\n+        FN(BrotliCompareAndPushToQueue)(out, cluster_size, clusters[idx1],\n+            clusters[idx2], max_num_pairs, &pairs[0], &num_pairs);\n+      }\n+    }\n+  }\n+\n+  while (num_clusters > min_cluster_size) {\n+    uint32_t best_idx1;\n+    uint32_t best_idx2;\n+    size_t i;\n+    if (pairs[0].cost_diff >= cost_diff_threshold) {\n+      cost_diff_threshold = 1e99;\n+      min_cluster_size = max_clusters;\n+      continue;\n+    }\n+    /* Take the best pair from the top of heap. */\n+    best_idx1 = pairs[0].idx1;\n+    best_idx2 = pairs[0].idx2;\n+    FN(HistogramAddHistogram)(&out[best_idx1], &out[best_idx2]);\n+    out[best_idx1].bit_cost_ = pairs[0].cost_combo;\n+    cluster_size[best_idx1] += cluster_size[best_idx2];\n+    for (i = 0; i < symbols_size; ++i) {\n+      if (symbols[i] == best_idx2) {\n+        symbols[i] = best_idx1;\n+      }\n+    }\n+    for (i = 0; i < num_clusters; ++i) {\n+      if (clusters[i] == best_idx2) {\n+        memmove(&clusters[i], &clusters[i + 1],\n+                (num_clusters - i - 1) * sizeof(clusters[0]));\n+        break;\n+      }\n+    }\n+    --num_clusters;\n+    {\n+      /* Remove pairs intersecting the just combined best pair. */\n+      size_t copy_to_idx = 0;\n+      for (i = 0; i < num_pairs; ++i) {\n+        HistogramPair* p = &pairs[i];\n+        if (p->idx1 == best_idx1 || p->idx2 == best_idx1 ||\n+            p->idx1 == best_idx2 || p->idx2 == best_idx2) {\n+          /* Remove invalid pair from the queue. */\n+          continue;\n+        }\n+        if (HistogramPairIsLess(&pairs[0], p)) {\n+          /* Replace the top of the queue if needed. */\n+          HistogramPair front = pairs[0];\n+          pairs[0] = *p;\n+          pairs[copy_to_idx] = front;\n+        } else {\n+          pairs[copy_to_idx] = *p;\n+        }\n+        ++copy_to_idx;\n+      }\n+      num_pairs = copy_to_idx;\n+    }\n+\n+    /* Push new pairs formed with the combined histogram to the heap. */\n+    for (i = 0; i < num_clusters; ++i) {\n+      FN(BrotliCompareAndPushToQueue)(out, cluster_size, best_idx1, clusters[i],\n+                                      max_num_pairs, &pairs[0], &num_pairs);\n+    }\n+  }\n+  return num_clusters;\n+})\n+\n+/* What is the bit cost of moving histogram from cur_symbol to candidate. */\n+BROTLI_INTERNAL double FN(BrotliHistogramBitCostDistance)(\n+    const HistogramType* histogram, const HistogramType* candidate) CODE({\n+  if (histogram->total_count_ == 0) {\n+    return 0.0;\n+  } else {\n+    HistogramType tmp = *histogram;\n+    FN(HistogramAddHistogram)(&tmp, candidate);\n+    return FN(BrotliPopulationCost)(&tmp) - candidate->bit_cost_;\n+  }\n+})\n+\n+/* Find the best 'out' histogram for each of the 'in' histograms.\n+   When called, clusters[0..num_clusters) contains the unique values from\n+   symbols[0..in_size), but this property is not preserved in this function.\n+   Note: we assume that out[]->bit_cost_ is already up-to-date. */\n+BROTLI_INTERNAL void FN(BrotliHistogramRemap)(const HistogramType* in,\n+    size_t in_size, const uint32_t* clusters, size_t num_clusters,\n+    HistogramType* out, uint32_t* symbols) CODE({\n+  size_t i;\n+  for (i = 0; i < in_size; ++i) {\n+    uint32_t best_out = i == 0 ? symbols[0] : symbols[i - 1];\n+    double best_bits =\n+        FN(BrotliHistogramBitCostDistance)(&in[i], &out[best_out]);\n+    size_t j;\n+    for (j = 0; j < num_clusters; ++j) {\n+      const double cur_bits =\n+          FN(BrotliHistogramBitCostDistance)(&in[i], &out[clusters[j]]);\n+      if (cur_bits < best_bits) {\n+        best_bits = cur_bits;\n+        best_out = clusters[j];\n+      }\n+    }\n+    symbols[i] = best_out;\n+  }\n+\n+  /* Recompute each out based on raw and symbols. */\n+  for (i = 0; i < num_clusters; ++i) {\n+    FN(HistogramClear)(&out[clusters[i]]);\n+  }\n+  for (i = 0; i < in_size; ++i) {\n+    FN(HistogramAddHistogram)(&out[symbols[i]], &in[i]);\n+  }\n+})\n+\n+/* Reorders elements of the out[0..length) array and changes values in\n+   symbols[0..length) array in the following way:\n+     * when called, symbols[] contains indexes into out[], and has N unique\n+       values (possibly N < length)\n+     * on return, symbols'[i] = f(symbols[i]) and\n+                  out'[symbols'[i]] = out[symbols[i]], for each 0 <= i < length,\n+       where f is a bijection between the range of symbols[] and [0..N), and\n+       the first occurrences of values in symbols'[i] come in consecutive\n+       increasing order.\n+   Returns N, the number of unique values in symbols[]. */\n+BROTLI_INTERNAL size_t FN(BrotliHistogramReindex)(MemoryManager* m,\n+    HistogramType* out, uint32_t* symbols, size_t length) CODE({\n+  static const uint32_t kInvalidIndex = BROTLI_UINT32_MAX;\n+  uint32_t* new_index = BROTLI_ALLOC(m, uint32_t, length);\n+  uint32_t next_index;\n+  HistogramType* tmp;\n+  size_t i;\n+  if (BROTLI_IS_OOM(m)) return 0;\n+  for (i = 0; i < length; ++i) {\n+      new_index[i] = kInvalidIndex;\n+  }\n+  next_index = 0;\n+  for (i = 0; i < length; ++i) {\n+    if (new_index[symbols[i]] == kInvalidIndex) {\n+      new_index[symbols[i]] = next_index;\n+      ++next_index;\n+    }\n+  }\n+  /* TODO: by using idea of \"cycle-sort\" we can avoid allocation of\n+     tmp and reduce the number of copying by the factor of 2. */\n+  tmp = BROTLI_ALLOC(m, HistogramType, next_index);\n+  if (BROTLI_IS_OOM(m)) return 0;\n+  next_index = 0;\n+  for (i = 0; i < length; ++i) {\n+    if (new_index[symbols[i]] == next_index) {\n+      tmp[next_index] = out[symbols[i]];\n+      ++next_index;\n+    }\n+    symbols[i] = new_index[symbols[i]];\n+  }\n+  BROTLI_FREE(m, new_index);\n+  for (i = 0; i < next_index; ++i) {\n+    out[i] = tmp[i];\n+  }\n+  BROTLI_FREE(m, tmp);\n+  return next_index;\n+})\n+\n+BROTLI_INTERNAL void FN(BrotliClusterHistograms)(\n+    MemoryManager* m, const HistogramType* in, const size_t in_size,\n+    size_t max_histograms, HistogramType* out, size_t* out_size,\n+    uint32_t* histogram_symbols) CODE({\n+  uint32_t* cluster_size = BROTLI_ALLOC(m, uint32_t, in_size);\n+  uint32_t* clusters = BROTLI_ALLOC(m, uint32_t, in_size);\n+  size_t num_clusters = 0;\n+  const size_t max_input_histograms = 64;\n+  size_t pairs_capacity = max_input_histograms * max_input_histograms / 2;\n+  /* For the first pass of clustering, we allow all pairs. */\n+  HistogramPair* pairs = BROTLI_ALLOC(m, HistogramPair, pairs_capacity + 1);\n+  size_t i;\n+\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  for (i = 0; i < in_size; ++i) {\n+    cluster_size[i] = 1;\n+  }\n+\n+  for (i = 0; i < in_size; ++i) {\n+    out[i] = in[i];\n+    out[i].bit_cost_ = FN(BrotliPopulationCost)(&in[i]);\n+    histogram_symbols[i] = (uint32_t)i;\n+  }\n+\n+  for (i = 0; i < in_size; i += max_input_histograms) {\n+    size_t num_to_combine =\n+        BROTLI_MIN(size_t, in_size - i, max_input_histograms);\n+    size_t num_new_clusters;\n+    size_t j;\n+    for (j = 0; j < num_to_combine; ++j) {\n+      clusters[num_clusters + j] = (uint32_t)(i + j);\n+    }\n+    num_new_clusters =\n+        FN(BrotliHistogramCombine)(out, cluster_size,\n+                                   &histogram_symbols[i],\n+                                   &clusters[num_clusters], pairs,\n+                                   num_to_combine, num_to_combine,\n+                                   max_histograms, pairs_capacity);\n+    num_clusters += num_new_clusters;\n+  }\n+\n+  {\n+    /* For the second pass, we limit the total number of histogram pairs.\n+       After this limit is reached, we only keep searching for the best pair. */\n+    size_t max_num_pairs = BROTLI_MIN(size_t,\n+        64 * num_clusters, (num_clusters / 2) * num_clusters);\n+    BROTLI_ENSURE_CAPACITY(\n+        m, HistogramPair, pairs, pairs_capacity, max_num_pairs + 1);\n+    if (BROTLI_IS_OOM(m)) return;\n+\n+    /* Collapse similar histograms. */\n+    num_clusters = FN(BrotliHistogramCombine)(out, cluster_size,\n+                                              histogram_symbols, clusters,\n+                                              pairs, num_clusters, in_size,\n+                                              max_histograms, max_num_pairs);\n+  }\n+  BROTLI_FREE(m, pairs);\n+  BROTLI_FREE(m, cluster_size);\n+  /* Find the optimal map from original histograms to the final ones. */\n+  FN(BrotliHistogramRemap)(in, in_size, clusters, num_clusters,\n+                           out, histogram_symbols);\n+  BROTLI_FREE(m, clusters);\n+  /* Convert the context map to a canonical form. */\n+  *out_size = FN(BrotliHistogramReindex)(m, out, histogram_symbols, in_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+})\n+\n+#undef HistogramType"
        },
        {
            "sha": "1aac85689be6c77b73968ac074dcf38ab7a62f41",
            "filename": "deps/brotli/c/enc/command.h",
            "status": "added",
            "additions": 190,
            "deletions": 0,
            "changes": 190,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcommand.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcommand.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fcommand.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,190 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* This class models a sequence of literals and a backward reference copy. */\n+\n+#ifndef BROTLI_ENC_COMMAND_H_\n+#define BROTLI_ENC_COMMAND_H_\n+\n+#include \"../common/constants.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./fast_log.h\"\n+#include \"./params.h\"\n+#include \"./prefix.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+static uint32_t kInsBase[] =   { 0, 1, 2, 3, 4, 5, 6, 8, 10, 14, 18, 26, 34, 50,\n+    66, 98, 130, 194, 322, 578, 1090, 2114, 6210, 22594 };\n+static uint32_t kInsExtra[] =  { 0, 0, 0, 0, 0, 0, 1, 1,  2,  2,  3,  3,  4,  4,\n+    5,   5,   6,   7,   8,   9,   10,   12,   14,    24 };\n+static uint32_t kCopyBase[] =  { 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 18, 22, 30,\n+    38, 54,  70, 102, 134, 198, 326,   582, 1094,  2118 };\n+static uint32_t kCopyExtra[] = { 0, 0, 0, 0, 0, 0, 0, 0,  1,  1,  2,  2,  3,  3,\n+     4,  4,   5,   5,   6,   7,   8,     9,   10,    24 };\n+\n+static BROTLI_INLINE uint16_t GetInsertLengthCode(size_t insertlen) {\n+  if (insertlen < 6) {\n+    return (uint16_t)insertlen;\n+  } else if (insertlen < 130) {\n+    uint32_t nbits = Log2FloorNonZero(insertlen - 2) - 1u;\n+    return (uint16_t)((nbits << 1) + ((insertlen - 2) >> nbits) + 2);\n+  } else if (insertlen < 2114) {\n+    return (uint16_t)(Log2FloorNonZero(insertlen - 66) + 10);\n+  } else if (insertlen < 6210) {\n+    return 21u;\n+  } else if (insertlen < 22594) {\n+    return 22u;\n+  } else {\n+    return 23u;\n+  }\n+}\n+\n+static BROTLI_INLINE uint16_t GetCopyLengthCode(size_t copylen) {\n+  if (copylen < 10) {\n+    return (uint16_t)(copylen - 2);\n+  } else if (copylen < 134) {\n+    uint32_t nbits = Log2FloorNonZero(copylen - 6) - 1u;\n+    return (uint16_t)((nbits << 1) + ((copylen - 6) >> nbits) + 4);\n+  } else if (copylen < 2118) {\n+    return (uint16_t)(Log2FloorNonZero(copylen - 70) + 12);\n+  } else {\n+    return 23u;\n+  }\n+}\n+\n+static BROTLI_INLINE uint16_t CombineLengthCodes(\n+    uint16_t inscode, uint16_t copycode, BROTLI_BOOL use_last_distance) {\n+  uint16_t bits64 =\n+      (uint16_t)((copycode & 0x7u) | ((inscode & 0x7u) << 3u));\n+  if (use_last_distance && inscode < 8u && copycode < 16u) {\n+    return (copycode < 8u) ? bits64 : (bits64 | 64u);\n+  } else {\n+    /* Specification: 5 Encoding of ... (last table) */\n+    /* offset = 2 * index, where index is in range [0..8] */\n+    uint32_t offset = 2u * ((copycode >> 3u) + 3u * (inscode >> 3u));\n+    /* All values in specification are K * 64,\n+       where   K = [2, 3, 6, 4, 5, 8, 7, 9, 10],\n+           i + 1 = [1, 2, 3, 4, 5, 6, 7, 8,  9],\n+       K - i - 1 = [1, 1, 3, 0, 0, 2, 0, 1,  2] = D.\n+       All values in D require only 2 bits to encode.\n+       Magic constant is shifted 6 bits left, to avoid final multiplication. */\n+    offset = (offset << 5u) + 0x40u + ((0x520D40u >> offset) & 0xC0u);\n+    return (uint16_t)(offset | bits64);\n+  }\n+}\n+\n+static BROTLI_INLINE void GetLengthCode(size_t insertlen, size_t copylen,\n+                                        BROTLI_BOOL use_last_distance,\n+                                        uint16_t* code) {\n+  uint16_t inscode = GetInsertLengthCode(insertlen);\n+  uint16_t copycode = GetCopyLengthCode(copylen);\n+  *code = CombineLengthCodes(inscode, copycode, use_last_distance);\n+}\n+\n+static BROTLI_INLINE uint32_t GetInsertBase(uint16_t inscode) {\n+  return kInsBase[inscode];\n+}\n+\n+static BROTLI_INLINE uint32_t GetInsertExtra(uint16_t inscode) {\n+  return kInsExtra[inscode];\n+}\n+\n+static BROTLI_INLINE uint32_t GetCopyBase(uint16_t copycode) {\n+  return kCopyBase[copycode];\n+}\n+\n+static BROTLI_INLINE uint32_t GetCopyExtra(uint16_t copycode) {\n+  return kCopyExtra[copycode];\n+}\n+\n+typedef struct Command {\n+  uint32_t insert_len_;\n+  /* Stores copy_len in low 25 bits and copy_code - copy_len in high 7 bit. */\n+  uint32_t copy_len_;\n+  /* Stores distance extra bits. */\n+  uint32_t dist_extra_;\n+  uint16_t cmd_prefix_;\n+  /* Stores distance code in low 10 bits\n+     and number of extra bits in high 6 bits. */\n+  uint16_t dist_prefix_;\n+} Command;\n+\n+/* distance_code is e.g. 0 for same-as-last short code, or 16 for offset 1. */\n+static BROTLI_INLINE void InitCommand(Command* self,\n+    const BrotliDistanceParams* dist, size_t insertlen,\n+    size_t copylen, int copylen_code_delta, size_t distance_code) {\n+  /* Don't rely on signed int representation, use honest casts. */\n+  uint32_t delta = (uint8_t)((int8_t)copylen_code_delta);\n+  self->insert_len_ = (uint32_t)insertlen;\n+  self->copy_len_ = (uint32_t)(copylen | (delta << 25));\n+  /* The distance prefix and extra bits are stored in this Command as if\n+     npostfix and ndirect were 0, they are only recomputed later after the\n+     clustering if needed. */\n+  PrefixEncodeCopyDistance(\n+      distance_code, dist->num_direct_distance_codes,\n+      dist->distance_postfix_bits, &self->dist_prefix_, &self->dist_extra_);\n+  GetLengthCode(\n+      insertlen, (size_t)((int)copylen + copylen_code_delta),\n+      TO_BROTLI_BOOL((self->dist_prefix_ & 0x3FF) == 0), &self->cmd_prefix_);\n+}\n+\n+static BROTLI_INLINE void InitInsertCommand(Command* self, size_t insertlen) {\n+  self->insert_len_ = (uint32_t)insertlen;\n+  self->copy_len_ = 4 << 25;\n+  self->dist_extra_ = 0;\n+  self->dist_prefix_ = BROTLI_NUM_DISTANCE_SHORT_CODES;\n+  GetLengthCode(insertlen, 4, BROTLI_FALSE, &self->cmd_prefix_);\n+}\n+\n+static BROTLI_INLINE uint32_t CommandRestoreDistanceCode(\n+    const Command* self, const BrotliDistanceParams* dist) {\n+  if ((self->dist_prefix_ & 0x3FFu) <\n+      BROTLI_NUM_DISTANCE_SHORT_CODES + dist->num_direct_distance_codes) {\n+    return self->dist_prefix_ & 0x3FFu;\n+  } else {\n+    uint32_t dcode = self->dist_prefix_ & 0x3FFu;\n+    uint32_t nbits = self->dist_prefix_ >> 10;\n+    uint32_t extra = self->dist_extra_;\n+    uint32_t postfix_mask = (1U << dist->distance_postfix_bits) - 1U;\n+    uint32_t hcode = (dcode - dist->num_direct_distance_codes -\n+        BROTLI_NUM_DISTANCE_SHORT_CODES) >>\n+        dist->distance_postfix_bits;\n+    uint32_t lcode = (dcode - dist->num_direct_distance_codes -\n+        BROTLI_NUM_DISTANCE_SHORT_CODES) & postfix_mask;\n+    uint32_t offset = ((2U + (hcode & 1U)) << nbits) - 4U;\n+    return ((offset + extra) << dist->distance_postfix_bits) + lcode +\n+        dist->num_direct_distance_codes + BROTLI_NUM_DISTANCE_SHORT_CODES;\n+  }\n+}\n+\n+static BROTLI_INLINE uint32_t CommandDistanceContext(const Command* self) {\n+  uint32_t r = self->cmd_prefix_ >> 6;\n+  uint32_t c = self->cmd_prefix_ & 7;\n+  if ((r == 0 || r == 2 || r == 4 || r == 7) && (c <= 2)) {\n+    return c;\n+  }\n+  return 3;\n+}\n+\n+static BROTLI_INLINE uint32_t CommandCopyLen(const Command* self) {\n+  return self->copy_len_ & 0x1FFFFFF;\n+}\n+\n+static BROTLI_INLINE uint32_t CommandCopyLenCode(const Command* self) {\n+  uint32_t modifier = self->copy_len_ >> 25;\n+  int32_t delta = (int8_t)((uint8_t)(modifier | ((modifier & 0x40) << 1)));\n+  return (uint32_t)((int32_t)(self->copy_len_ & 0x1FFFFFF) + delta);\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_COMMAND_H_ */"
        },
        {
            "sha": "9e50b2098a0b7e42ea2026995e385494f117bbd5",
            "filename": "deps/brotli/c/enc/compress_fragment.c",
            "status": "added",
            "additions": 790,
            "deletions": 0,
            "changes": 790,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,790 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Function for fast encoding of an input fragment, independently from the input\n+   history. This function uses one-pass processing: when we find a backward\n+   match, we immediately emit the corresponding command and literal codes to\n+   the bit stream.\n+\n+   Adapted from the CompressFragment() function in\n+   https://github.com/google/snappy/blob/master/snappy.cc */\n+\n+#include \"./compress_fragment.h\"\n+\n+#include <string.h>  /* memcmp, memcpy, memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./brotli_bit_stream.h\"\n+#include \"./entropy_encode.h\"\n+#include \"./fast_log.h\"\n+#include \"./find_match_length.h\"\n+#include \"./memory.h\"\n+#include \"./write_bits.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define MAX_DISTANCE (long)BROTLI_MAX_BACKWARD_LIMIT(18)\n+\n+/* kHashMul32 multiplier has these properties:\n+   * The multiplier must be odd. Otherwise we may lose the highest bit.\n+   * No long streaks of ones or zeros.\n+   * There is no effort to ensure that it is a prime, the oddity is enough\n+     for this use.\n+   * The number has been tuned heuristically against compression benchmarks. */\n+static const uint32_t kHashMul32 = 0x1E35A7BD;\n+\n+static BROTLI_INLINE uint32_t Hash(const uint8_t* p, size_t shift) {\n+  const uint64_t h = (BROTLI_UNALIGNED_LOAD64LE(p) << 24) * kHashMul32;\n+  return (uint32_t)(h >> shift);\n+}\n+\n+static BROTLI_INLINE uint32_t HashBytesAtOffset(\n+    uint64_t v, int offset, size_t shift) {\n+  BROTLI_DCHECK(offset >= 0);\n+  BROTLI_DCHECK(offset <= 3);\n+  {\n+    const uint64_t h = ((v >> (8 * offset)) << 24) * kHashMul32;\n+    return (uint32_t)(h >> shift);\n+  }\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL IsMatch(const uint8_t* p1, const uint8_t* p2) {\n+  return TO_BROTLI_BOOL(\n+      BrotliUnalignedRead32(p1) == BrotliUnalignedRead32(p2) &&\n+      p1[4] == p2[4]);\n+}\n+\n+/* Builds a literal prefix code into \"depths\" and \"bits\" based on the statistics\n+   of the \"input\" string and stores it into the bit stream.\n+   Note that the prefix code here is built from the pre-LZ77 input, therefore\n+   we can only approximate the statistics of the actual literal stream.\n+   Moreover, for long inputs we build a histogram from a sample of the input\n+   and thus have to assign a non-zero depth for each literal.\n+   Returns estimated compression ratio millibytes/char for encoding given input\n+   with generated code. */\n+static size_t BuildAndStoreLiteralPrefixCode(MemoryManager* m,\n+                                             const uint8_t* input,\n+                                             const size_t input_size,\n+                                             uint8_t depths[256],\n+                                             uint16_t bits[256],\n+                                             size_t* storage_ix,\n+                                             uint8_t* storage) {\n+  uint32_t histogram[256] = { 0 };\n+  size_t histogram_total;\n+  size_t i;\n+  if (input_size < (1 << 15)) {\n+    for (i = 0; i < input_size; ++i) {\n+      ++histogram[input[i]];\n+    }\n+    histogram_total = input_size;\n+    for (i = 0; i < 256; ++i) {\n+      /* We weigh the first 11 samples with weight 3 to account for the\n+         balancing effect of the LZ77 phase on the histogram. */\n+      const uint32_t adjust = 2 * BROTLI_MIN(uint32_t, histogram[i], 11u);\n+      histogram[i] += adjust;\n+      histogram_total += adjust;\n+    }\n+  } else {\n+    static const size_t kSampleRate = 29;\n+    for (i = 0; i < input_size; i += kSampleRate) {\n+      ++histogram[input[i]];\n+    }\n+    histogram_total = (input_size + kSampleRate - 1) / kSampleRate;\n+    for (i = 0; i < 256; ++i) {\n+      /* We add 1 to each population count to avoid 0 bit depths (since this is\n+         only a sample and we don't know if the symbol appears or not), and we\n+         weigh the first 11 samples with weight 3 to account for the balancing\n+         effect of the LZ77 phase on the histogram (more frequent symbols are\n+         more likely to be in backward references instead as literals). */\n+      const uint32_t adjust = 1 + 2 * BROTLI_MIN(uint32_t, histogram[i], 11u);\n+      histogram[i] += adjust;\n+      histogram_total += adjust;\n+    }\n+  }\n+  BrotliBuildAndStoreHuffmanTreeFast(m, histogram, histogram_total,\n+                                     /* max_bits = */ 8,\n+                                     depths, bits, storage_ix, storage);\n+  if (BROTLI_IS_OOM(m)) return 0;\n+  {\n+    size_t literal_ratio = 0;\n+    for (i = 0; i < 256; ++i) {\n+      if (histogram[i]) literal_ratio += histogram[i] * depths[i];\n+    }\n+    /* Estimated encoding ratio, millibytes per symbol. */\n+    return (literal_ratio * 125) / histogram_total;\n+  }\n+}\n+\n+/* Builds a command and distance prefix code (each 64 symbols) into \"depth\" and\n+   \"bits\" based on \"histogram\" and stores it into the bit stream. */\n+static void BuildAndStoreCommandPrefixCode(const uint32_t histogram[128],\n+    uint8_t depth[128], uint16_t bits[128], size_t* storage_ix,\n+    uint8_t* storage) {\n+  /* Tree size for building a tree over 64 symbols is 2 * 64 + 1. */\n+  HuffmanTree tree[129];\n+  uint8_t cmd_depth[BROTLI_NUM_COMMAND_SYMBOLS] = { 0 };\n+  uint16_t cmd_bits[64];\n+\n+  BrotliCreateHuffmanTree(histogram, 64, 15, tree, depth);\n+  BrotliCreateHuffmanTree(&histogram[64], 64, 14, tree, &depth[64]);\n+  /* We have to jump through a few hoops here in order to compute\n+     the command bits because the symbols are in a different order than in\n+     the full alphabet. This looks complicated, but having the symbols\n+     in this order in the command bits saves a few branches in the Emit*\n+     functions. */\n+  memcpy(cmd_depth, depth, 24);\n+  memcpy(cmd_depth + 24, depth + 40, 8);\n+  memcpy(cmd_depth + 32, depth + 24, 8);\n+  memcpy(cmd_depth + 40, depth + 48, 8);\n+  memcpy(cmd_depth + 48, depth + 32, 8);\n+  memcpy(cmd_depth + 56, depth + 56, 8);\n+  BrotliConvertBitDepthsToSymbols(cmd_depth, 64, cmd_bits);\n+  memcpy(bits, cmd_bits, 48);\n+  memcpy(bits + 24, cmd_bits + 32, 16);\n+  memcpy(bits + 32, cmd_bits + 48, 16);\n+  memcpy(bits + 40, cmd_bits + 24, 16);\n+  memcpy(bits + 48, cmd_bits + 40, 16);\n+  memcpy(bits + 56, cmd_bits + 56, 16);\n+  BrotliConvertBitDepthsToSymbols(&depth[64], 64, &bits[64]);\n+  {\n+    /* Create the bit length array for the full command alphabet. */\n+    size_t i;\n+    memset(cmd_depth, 0, 64);  /* only 64 first values were used */\n+    memcpy(cmd_depth, depth, 8);\n+    memcpy(cmd_depth + 64, depth + 8, 8);\n+    memcpy(cmd_depth + 128, depth + 16, 8);\n+    memcpy(cmd_depth + 192, depth + 24, 8);\n+    memcpy(cmd_depth + 384, depth + 32, 8);\n+    for (i = 0; i < 8; ++i) {\n+      cmd_depth[128 + 8 * i] = depth[40 + i];\n+      cmd_depth[256 + 8 * i] = depth[48 + i];\n+      cmd_depth[448 + 8 * i] = depth[56 + i];\n+    }\n+    BrotliStoreHuffmanTree(\n+        cmd_depth, BROTLI_NUM_COMMAND_SYMBOLS, tree, storage_ix, storage);\n+  }\n+  BrotliStoreHuffmanTree(&depth[64], 64, tree, storage_ix, storage);\n+}\n+\n+/* REQUIRES: insertlen < 6210 */\n+static BROTLI_INLINE void EmitInsertLen(size_t insertlen,\n+                                        const uint8_t depth[128],\n+                                        const uint16_t bits[128],\n+                                        uint32_t histo[128],\n+                                        size_t* storage_ix,\n+                                        uint8_t* storage) {\n+  if (insertlen < 6) {\n+    const size_t code = insertlen + 40;\n+    BrotliWriteBits(depth[code], bits[code], storage_ix, storage);\n+    ++histo[code];\n+  } else if (insertlen < 130) {\n+    const size_t tail = insertlen - 2;\n+    const uint32_t nbits = Log2FloorNonZero(tail) - 1u;\n+    const size_t prefix = tail >> nbits;\n+    const size_t inscode = (nbits << 1) + prefix + 42;\n+    BrotliWriteBits(depth[inscode], bits[inscode], storage_ix, storage);\n+    BrotliWriteBits(nbits, tail - (prefix << nbits), storage_ix, storage);\n+    ++histo[inscode];\n+  } else if (insertlen < 2114) {\n+    const size_t tail = insertlen - 66;\n+    const uint32_t nbits = Log2FloorNonZero(tail);\n+    const size_t code = nbits + 50;\n+    BrotliWriteBits(depth[code], bits[code], storage_ix, storage);\n+    BrotliWriteBits(nbits, tail - ((size_t)1 << nbits), storage_ix, storage);\n+    ++histo[code];\n+  } else {\n+    BrotliWriteBits(depth[61], bits[61], storage_ix, storage);\n+    BrotliWriteBits(12, insertlen - 2114, storage_ix, storage);\n+    ++histo[61];\n+  }\n+}\n+\n+static BROTLI_INLINE void EmitLongInsertLen(size_t insertlen,\n+                                            const uint8_t depth[128],\n+                                            const uint16_t bits[128],\n+                                            uint32_t histo[128],\n+                                            size_t* storage_ix,\n+                                            uint8_t* storage) {\n+  if (insertlen < 22594) {\n+    BrotliWriteBits(depth[62], bits[62], storage_ix, storage);\n+    BrotliWriteBits(14, insertlen - 6210, storage_ix, storage);\n+    ++histo[62];\n+  } else {\n+    BrotliWriteBits(depth[63], bits[63], storage_ix, storage);\n+    BrotliWriteBits(24, insertlen - 22594, storage_ix, storage);\n+    ++histo[63];\n+  }\n+}\n+\n+static BROTLI_INLINE void EmitCopyLen(size_t copylen,\n+                                      const uint8_t depth[128],\n+                                      const uint16_t bits[128],\n+                                      uint32_t histo[128],\n+                                      size_t* storage_ix,\n+                                      uint8_t* storage) {\n+  if (copylen < 10) {\n+    BrotliWriteBits(\n+        depth[copylen + 14], bits[copylen + 14], storage_ix, storage);\n+    ++histo[copylen + 14];\n+  } else if (copylen < 134) {\n+    const size_t tail = copylen - 6;\n+    const uint32_t nbits = Log2FloorNonZero(tail) - 1u;\n+    const size_t prefix = tail >> nbits;\n+    const size_t code = (nbits << 1) + prefix + 20;\n+    BrotliWriteBits(depth[code], bits[code], storage_ix, storage);\n+    BrotliWriteBits(nbits, tail - (prefix << nbits), storage_ix, storage);\n+    ++histo[code];\n+  } else if (copylen < 2118) {\n+    const size_t tail = copylen - 70;\n+    const uint32_t nbits = Log2FloorNonZero(tail);\n+    const size_t code = nbits + 28;\n+    BrotliWriteBits(depth[code], bits[code], storage_ix, storage);\n+    BrotliWriteBits(nbits, tail - ((size_t)1 << nbits), storage_ix, storage);\n+    ++histo[code];\n+  } else {\n+    BrotliWriteBits(depth[39], bits[39], storage_ix, storage);\n+    BrotliWriteBits(24, copylen - 2118, storage_ix, storage);\n+    ++histo[39];\n+  }\n+}\n+\n+static BROTLI_INLINE void EmitCopyLenLastDistance(size_t copylen,\n+                                                  const uint8_t depth[128],\n+                                                  const uint16_t bits[128],\n+                                                  uint32_t histo[128],\n+                                                  size_t* storage_ix,\n+                                                  uint8_t* storage) {\n+  if (copylen < 12) {\n+    BrotliWriteBits(depth[copylen - 4], bits[copylen - 4], storage_ix, storage);\n+    ++histo[copylen - 4];\n+  } else if (copylen < 72) {\n+    const size_t tail = copylen - 8;\n+    const uint32_t nbits = Log2FloorNonZero(tail) - 1;\n+    const size_t prefix = tail >> nbits;\n+    const size_t code = (nbits << 1) + prefix + 4;\n+    BrotliWriteBits(depth[code], bits[code], storage_ix, storage);\n+    BrotliWriteBits(nbits, tail - (prefix << nbits), storage_ix, storage);\n+    ++histo[code];\n+  } else if (copylen < 136) {\n+    const size_t tail = copylen - 8;\n+    const size_t code = (tail >> 5) + 30;\n+    BrotliWriteBits(depth[code], bits[code], storage_ix, storage);\n+    BrotliWriteBits(5, tail & 31, storage_ix, storage);\n+    BrotliWriteBits(depth[64], bits[64], storage_ix, storage);\n+    ++histo[code];\n+    ++histo[64];\n+  } else if (copylen < 2120) {\n+    const size_t tail = copylen - 72;\n+    const uint32_t nbits = Log2FloorNonZero(tail);\n+    const size_t code = nbits + 28;\n+    BrotliWriteBits(depth[code], bits[code], storage_ix, storage);\n+    BrotliWriteBits(nbits, tail - ((size_t)1 << nbits), storage_ix, storage);\n+    BrotliWriteBits(depth[64], bits[64], storage_ix, storage);\n+    ++histo[code];\n+    ++histo[64];\n+  } else {\n+    BrotliWriteBits(depth[39], bits[39], storage_ix, storage);\n+    BrotliWriteBits(24, copylen - 2120, storage_ix, storage);\n+    BrotliWriteBits(depth[64], bits[64], storage_ix, storage);\n+    ++histo[39];\n+    ++histo[64];\n+  }\n+}\n+\n+static BROTLI_INLINE void EmitDistance(size_t distance,\n+                                       const uint8_t depth[128],\n+                                       const uint16_t bits[128],\n+                                       uint32_t histo[128],\n+                                       size_t* storage_ix, uint8_t* storage) {\n+  const size_t d = distance + 3;\n+  const uint32_t nbits = Log2FloorNonZero(d) - 1u;\n+  const size_t prefix = (d >> nbits) & 1;\n+  const size_t offset = (2 + prefix) << nbits;\n+  const size_t distcode = 2 * (nbits - 1) + prefix + 80;\n+  BrotliWriteBits(depth[distcode], bits[distcode], storage_ix, storage);\n+  BrotliWriteBits(nbits, d - offset, storage_ix, storage);\n+  ++histo[distcode];\n+}\n+\n+static BROTLI_INLINE void EmitLiterals(const uint8_t* input, const size_t len,\n+                                       const uint8_t depth[256],\n+                                       const uint16_t bits[256],\n+                                       size_t* storage_ix, uint8_t* storage) {\n+  size_t j;\n+  for (j = 0; j < len; j++) {\n+    const uint8_t lit = input[j];\n+    BrotliWriteBits(depth[lit], bits[lit], storage_ix, storage);\n+  }\n+}\n+\n+/* REQUIRES: len <= 1 << 24. */\n+static void BrotliStoreMetaBlockHeader(\n+    size_t len, BROTLI_BOOL is_uncompressed, size_t* storage_ix,\n+    uint8_t* storage) {\n+  size_t nibbles = 6;\n+  /* ISLAST */\n+  BrotliWriteBits(1, 0, storage_ix, storage);\n+  if (len <= (1U << 16)) {\n+    nibbles = 4;\n+  } else if (len <= (1U << 20)) {\n+    nibbles = 5;\n+  }\n+  BrotliWriteBits(2, nibbles - 4, storage_ix, storage);\n+  BrotliWriteBits(nibbles * 4, len - 1, storage_ix, storage);\n+  /* ISUNCOMPRESSED */\n+  BrotliWriteBits(1, (uint64_t)is_uncompressed, storage_ix, storage);\n+}\n+\n+static void UpdateBits(size_t n_bits, uint32_t bits, size_t pos,\n+    uint8_t* array) {\n+  while (n_bits > 0) {\n+    size_t byte_pos = pos >> 3;\n+    size_t n_unchanged_bits = pos & 7;\n+    size_t n_changed_bits = BROTLI_MIN(size_t, n_bits, 8 - n_unchanged_bits);\n+    size_t total_bits = n_unchanged_bits + n_changed_bits;\n+    uint32_t mask =\n+        (~((1u << total_bits) - 1u)) | ((1u << n_unchanged_bits) - 1u);\n+    uint32_t unchanged_bits = array[byte_pos] & mask;\n+    uint32_t changed_bits = bits & ((1u << n_changed_bits) - 1u);\n+    array[byte_pos] =\n+        (uint8_t)((changed_bits << n_unchanged_bits) | unchanged_bits);\n+    n_bits -= n_changed_bits;\n+    bits >>= n_changed_bits;\n+    pos += n_changed_bits;\n+  }\n+}\n+\n+static void RewindBitPosition(const size_t new_storage_ix,\n+                              size_t* storage_ix, uint8_t* storage) {\n+  const size_t bitpos = new_storage_ix & 7;\n+  const size_t mask = (1u << bitpos) - 1;\n+  storage[new_storage_ix >> 3] &= (uint8_t)mask;\n+  *storage_ix = new_storage_ix;\n+}\n+\n+static BROTLI_BOOL ShouldMergeBlock(\n+    const uint8_t* data, size_t len, const uint8_t* depths) {\n+  size_t histo[256] = { 0 };\n+  static const size_t kSampleRate = 43;\n+  size_t i;\n+  for (i = 0; i < len; i += kSampleRate) {\n+    ++histo[data[i]];\n+  }\n+  {\n+    const size_t total = (len + kSampleRate - 1) / kSampleRate;\n+    double r = (FastLog2(total) + 0.5) * (double)total + 200;\n+    for (i = 0; i < 256; ++i) {\n+      r -= (double)histo[i] * (depths[i] + FastLog2(histo[i]));\n+    }\n+    return TO_BROTLI_BOOL(r >= 0.0);\n+  }\n+}\n+\n+/* Acceptable loss for uncompressible speedup is 2% */\n+#define MIN_RATIO 980\n+\n+static BROTLI_INLINE BROTLI_BOOL ShouldUseUncompressedMode(\n+    const uint8_t* metablock_start, const uint8_t* next_emit,\n+    const size_t insertlen, const size_t literal_ratio) {\n+  const size_t compressed = (size_t)(next_emit - metablock_start);\n+  if (compressed * 50 > insertlen) {\n+    return BROTLI_FALSE;\n+  } else {\n+    return TO_BROTLI_BOOL(literal_ratio > MIN_RATIO);\n+  }\n+}\n+\n+static void EmitUncompressedMetaBlock(const uint8_t* begin, const uint8_t* end,\n+                                      const size_t storage_ix_start,\n+                                      size_t* storage_ix, uint8_t* storage) {\n+  const size_t len = (size_t)(end - begin);\n+  RewindBitPosition(storage_ix_start, storage_ix, storage);\n+  BrotliStoreMetaBlockHeader(len, 1, storage_ix, storage);\n+  *storage_ix = (*storage_ix + 7u) & ~7u;\n+  memcpy(&storage[*storage_ix >> 3], begin, len);\n+  *storage_ix += len << 3;\n+  storage[*storage_ix >> 3] = 0;\n+}\n+\n+static uint32_t kCmdHistoSeed[128] = {\n+  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 0, 0, 0, 0,\n+};\n+\n+static BROTLI_INLINE void BrotliCompressFragmentFastImpl(\n+    MemoryManager* m, const uint8_t* input, size_t input_size,\n+    BROTLI_BOOL is_last, int* table, size_t table_bits, uint8_t cmd_depth[128],\n+    uint16_t cmd_bits[128], size_t* cmd_code_numbits, uint8_t* cmd_code,\n+    size_t* storage_ix, uint8_t* storage) {\n+  uint32_t cmd_histo[128];\n+  const uint8_t* ip_end;\n+\n+  /* \"next_emit\" is a pointer to the first byte that is not covered by a\n+     previous copy. Bytes between \"next_emit\" and the start of the next copy or\n+     the end of the input will be emitted as literal bytes. */\n+  const uint8_t* next_emit = input;\n+  /* Save the start of the first block for position and distance computations.\n+  */\n+  const uint8_t* base_ip = input;\n+\n+  static const size_t kFirstBlockSize = 3 << 15;\n+  static const size_t kMergeBlockSize = 1 << 16;\n+\n+  const size_t kInputMarginBytes = BROTLI_WINDOW_GAP;\n+  const size_t kMinMatchLen = 5;\n+\n+  const uint8_t* metablock_start = input;\n+  size_t block_size = BROTLI_MIN(size_t, input_size, kFirstBlockSize);\n+  size_t total_block_size = block_size;\n+  /* Save the bit position of the MLEN field of the meta-block header, so that\n+     we can update it later if we decide to extend this meta-block. */\n+  size_t mlen_storage_ix = *storage_ix + 3;\n+\n+  uint8_t lit_depth[256];\n+  uint16_t lit_bits[256];\n+\n+  size_t literal_ratio;\n+\n+  const uint8_t* ip;\n+  int last_distance;\n+\n+  const size_t shift = 64u - table_bits;\n+\n+  BrotliStoreMetaBlockHeader(block_size, 0, storage_ix, storage);\n+  /* No block splits, no contexts. */\n+  BrotliWriteBits(13, 0, storage_ix, storage);\n+\n+  literal_ratio = BuildAndStoreLiteralPrefixCode(\n+      m, input, block_size, lit_depth, lit_bits, storage_ix, storage);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  {\n+    /* Store the pre-compressed command and distance prefix codes. */\n+    size_t i;\n+    for (i = 0; i + 7 < *cmd_code_numbits; i += 8) {\n+      BrotliWriteBits(8, cmd_code[i >> 3], storage_ix, storage);\n+    }\n+  }\n+  BrotliWriteBits(*cmd_code_numbits & 7, cmd_code[*cmd_code_numbits >> 3],\n+                  storage_ix, storage);\n+\n+ emit_commands:\n+  /* Initialize the command and distance histograms. We will gather\n+     statistics of command and distance codes during the processing\n+     of this block and use it to update the command and distance\n+     prefix codes for the next block. */\n+  memcpy(cmd_histo, kCmdHistoSeed, sizeof(kCmdHistoSeed));\n+\n+  /* \"ip\" is the input pointer. */\n+  ip = input;\n+  last_distance = -1;\n+  ip_end = input + block_size;\n+\n+  if (BROTLI_PREDICT_TRUE(block_size >= kInputMarginBytes)) {\n+    /* For the last block, we need to keep a 16 bytes margin so that we can be\n+       sure that all distances are at most window size - 16.\n+       For all other blocks, we only need to keep a margin of 5 bytes so that\n+       we don't go over the block size with a copy. */\n+    const size_t len_limit = BROTLI_MIN(size_t, block_size - kMinMatchLen,\n+                                        input_size - kInputMarginBytes);\n+    const uint8_t* ip_limit = input + len_limit;\n+\n+    uint32_t next_hash;\n+    for (next_hash = Hash(++ip, shift); ; ) {\n+      /* Step 1: Scan forward in the input looking for a 5-byte-long match.\n+         If we get close to exhausting the input then goto emit_remainder.\n+\n+         Heuristic match skipping: If 32 bytes are scanned with no matches\n+         found, start looking only at every other byte. If 32 more bytes are\n+         scanned, look at every third byte, etc.. When a match is found,\n+         immediately go back to looking at every byte. This is a small loss\n+         (~5% performance, ~0.1% density) for compressible data due to more\n+         bookkeeping, but for non-compressible data (such as JPEG) it's a huge\n+         win since the compressor quickly \"realizes\" the data is incompressible\n+         and doesn't bother looking for matches everywhere.\n+\n+         The \"skip\" variable keeps track of how many bytes there are since the\n+         last match; dividing it by 32 (i.e. right-shifting by five) gives the\n+         number of bytes to move ahead for each iteration. */\n+      uint32_t skip = 32;\n+\n+      const uint8_t* next_ip = ip;\n+      const uint8_t* candidate;\n+      BROTLI_DCHECK(next_emit < ip);\n+trawl:\n+      do {\n+        uint32_t hash = next_hash;\n+        uint32_t bytes_between_hash_lookups = skip++ >> 5;\n+        BROTLI_DCHECK(hash == Hash(next_ip, shift));\n+        ip = next_ip;\n+        next_ip = ip + bytes_between_hash_lookups;\n+        if (BROTLI_PREDICT_FALSE(next_ip > ip_limit)) {\n+          goto emit_remainder;\n+        }\n+        next_hash = Hash(next_ip, shift);\n+        candidate = ip - last_distance;\n+        if (IsMatch(ip, candidate)) {\n+          if (BROTLI_PREDICT_TRUE(candidate < ip)) {\n+            table[hash] = (int)(ip - base_ip);\n+            break;\n+          }\n+        }\n+        candidate = base_ip + table[hash];\n+        BROTLI_DCHECK(candidate >= base_ip);\n+        BROTLI_DCHECK(candidate < ip);\n+\n+        table[hash] = (int)(ip - base_ip);\n+      } while (BROTLI_PREDICT_TRUE(!IsMatch(ip, candidate)));\n+\n+      /* Check copy distance. If candidate is not feasible, continue search.\n+         Checking is done outside of hot loop to reduce overhead. */\n+      if (ip - candidate > MAX_DISTANCE) goto trawl;\n+\n+      /* Step 2: Emit the found match together with the literal bytes from\n+         \"next_emit\" to the bit stream, and then see if we can find a next match\n+         immediately afterwards. Repeat until we find no match for the input\n+         without emitting some literal bytes. */\n+\n+      {\n+        /* We have a 5-byte match at ip, and we need to emit bytes in\n+           [next_emit, ip). */\n+        const uint8_t* base = ip;\n+        size_t matched = 5 + FindMatchLengthWithLimit(\n+            candidate + 5, ip + 5, (size_t)(ip_end - ip) - 5);\n+        int distance = (int)(base - candidate);  /* > 0 */\n+        size_t insert = (size_t)(base - next_emit);\n+        ip += matched;\n+        BROTLI_DCHECK(0 == memcmp(base, candidate, matched));\n+        if (BROTLI_PREDICT_TRUE(insert < 6210)) {\n+          EmitInsertLen(insert, cmd_depth, cmd_bits, cmd_histo,\n+                        storage_ix, storage);\n+        } else if (ShouldUseUncompressedMode(metablock_start, next_emit, insert,\n+                                             literal_ratio)) {\n+          EmitUncompressedMetaBlock(metablock_start, base, mlen_storage_ix - 3,\n+                                    storage_ix, storage);\n+          input_size -= (size_t)(base - input);\n+          input = base;\n+          next_emit = input;\n+          goto next_block;\n+        } else {\n+          EmitLongInsertLen(insert, cmd_depth, cmd_bits, cmd_histo,\n+                            storage_ix, storage);\n+        }\n+        EmitLiterals(next_emit, insert, lit_depth, lit_bits,\n+                     storage_ix, storage);\n+        if (distance == last_distance) {\n+          BrotliWriteBits(cmd_depth[64], cmd_bits[64], storage_ix, storage);\n+          ++cmd_histo[64];\n+        } else {\n+          EmitDistance((size_t)distance, cmd_depth, cmd_bits,\n+                       cmd_histo, storage_ix, storage);\n+          last_distance = distance;\n+        }\n+        EmitCopyLenLastDistance(matched, cmd_depth, cmd_bits, cmd_histo,\n+                                storage_ix, storage);\n+\n+        next_emit = ip;\n+        if (BROTLI_PREDICT_FALSE(ip >= ip_limit)) {\n+          goto emit_remainder;\n+        }\n+        /* We could immediately start working at ip now, but to improve\n+           compression we first update \"table\" with the hashes of some positions\n+           within the last copy. */\n+        {\n+          uint64_t input_bytes = BROTLI_UNALIGNED_LOAD64LE(ip - 3);\n+          uint32_t prev_hash = HashBytesAtOffset(input_bytes, 0, shift);\n+          uint32_t cur_hash = HashBytesAtOffset(input_bytes, 3, shift);\n+          table[prev_hash] = (int)(ip - base_ip - 3);\n+          prev_hash = HashBytesAtOffset(input_bytes, 1, shift);\n+          table[prev_hash] = (int)(ip - base_ip - 2);\n+          prev_hash = HashBytesAtOffset(input_bytes, 2, shift);\n+          table[prev_hash] = (int)(ip - base_ip - 1);\n+\n+          candidate = base_ip + table[cur_hash];\n+          table[cur_hash] = (int)(ip - base_ip);\n+        }\n+      }\n+\n+      while (IsMatch(ip, candidate)) {\n+        /* We have a 5-byte match at ip, and no need to emit any literal bytes\n+           prior to ip. */\n+        const uint8_t* base = ip;\n+        size_t matched = 5 + FindMatchLengthWithLimit(\n+            candidate + 5, ip + 5, (size_t)(ip_end - ip) - 5);\n+        if (ip - candidate > MAX_DISTANCE) break;\n+        ip += matched;\n+        last_distance = (int)(base - candidate);  /* > 0 */\n+        BROTLI_DCHECK(0 == memcmp(base, candidate, matched));\n+        EmitCopyLen(matched, cmd_depth, cmd_bits, cmd_histo,\n+                    storage_ix, storage);\n+        EmitDistance((size_t)last_distance, cmd_depth, cmd_bits,\n+                     cmd_histo, storage_ix, storage);\n+\n+        next_emit = ip;\n+        if (BROTLI_PREDICT_FALSE(ip >= ip_limit)) {\n+          goto emit_remainder;\n+        }\n+        /* We could immediately start working at ip now, but to improve\n+           compression we first update \"table\" with the hashes of some positions\n+           within the last copy. */\n+        {\n+          uint64_t input_bytes = BROTLI_UNALIGNED_LOAD64LE(ip - 3);\n+          uint32_t prev_hash = HashBytesAtOffset(input_bytes, 0, shift);\n+          uint32_t cur_hash = HashBytesAtOffset(input_bytes, 3, shift);\n+          table[prev_hash] = (int)(ip - base_ip - 3);\n+          prev_hash = HashBytesAtOffset(input_bytes, 1, shift);\n+          table[prev_hash] = (int)(ip - base_ip - 2);\n+          prev_hash = HashBytesAtOffset(input_bytes, 2, shift);\n+          table[prev_hash] = (int)(ip - base_ip - 1);\n+\n+          candidate = base_ip + table[cur_hash];\n+          table[cur_hash] = (int)(ip - base_ip);\n+        }\n+      }\n+\n+      next_hash = Hash(++ip, shift);\n+    }\n+  }\n+\n+ emit_remainder:\n+  BROTLI_DCHECK(next_emit <= ip_end);\n+  input += block_size;\n+  input_size -= block_size;\n+  block_size = BROTLI_MIN(size_t, input_size, kMergeBlockSize);\n+\n+  /* Decide if we want to continue this meta-block instead of emitting the\n+     last insert-only command. */\n+  if (input_size > 0 &&\n+      total_block_size + block_size <= (1 << 20) &&\n+      ShouldMergeBlock(input, block_size, lit_depth)) {\n+    BROTLI_DCHECK(total_block_size > (1 << 16));\n+    /* Update the size of the current meta-block and continue emitting commands.\n+       We can do this because the current size and the new size both have 5\n+       nibbles. */\n+    total_block_size += block_size;\n+    UpdateBits(20, (uint32_t)(total_block_size - 1), mlen_storage_ix, storage);\n+    goto emit_commands;\n+  }\n+\n+  /* Emit the remaining bytes as literals. */\n+  if (next_emit < ip_end) {\n+    const size_t insert = (size_t)(ip_end - next_emit);\n+    if (BROTLI_PREDICT_TRUE(insert < 6210)) {\n+      EmitInsertLen(insert, cmd_depth, cmd_bits, cmd_histo,\n+                    storage_ix, storage);\n+      EmitLiterals(next_emit, insert, lit_depth, lit_bits, storage_ix, storage);\n+    } else if (ShouldUseUncompressedMode(metablock_start, next_emit, insert,\n+                                         literal_ratio)) {\n+      EmitUncompressedMetaBlock(metablock_start, ip_end, mlen_storage_ix - 3,\n+                                storage_ix, storage);\n+    } else {\n+      EmitLongInsertLen(insert, cmd_depth, cmd_bits, cmd_histo,\n+                        storage_ix, storage);\n+      EmitLiterals(next_emit, insert, lit_depth, lit_bits,\n+                   storage_ix, storage);\n+    }\n+  }\n+  next_emit = ip_end;\n+\n+next_block:\n+  /* If we have more data, write a new meta-block header and prefix codes and\n+     then continue emitting commands. */\n+  if (input_size > 0) {\n+    metablock_start = input;\n+    block_size = BROTLI_MIN(size_t, input_size, kFirstBlockSize);\n+    total_block_size = block_size;\n+    /* Save the bit position of the MLEN field of the meta-block header, so that\n+       we can update it later if we decide to extend this meta-block. */\n+    mlen_storage_ix = *storage_ix + 3;\n+    BrotliStoreMetaBlockHeader(block_size, 0, storage_ix, storage);\n+    /* No block splits, no contexts. */\n+    BrotliWriteBits(13, 0, storage_ix, storage);\n+    literal_ratio = BuildAndStoreLiteralPrefixCode(\n+        m, input, block_size, lit_depth, lit_bits, storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+    BuildAndStoreCommandPrefixCode(cmd_histo, cmd_depth, cmd_bits,\n+                                   storage_ix, storage);\n+    goto emit_commands;\n+  }\n+\n+  if (!is_last) {\n+    /* If this is not the last block, update the command and distance prefix\n+       codes for the next block and store the compressed forms. */\n+    cmd_code[0] = 0;\n+    *cmd_code_numbits = 0;\n+    BuildAndStoreCommandPrefixCode(cmd_histo, cmd_depth, cmd_bits,\n+                                   cmd_code_numbits, cmd_code);\n+  }\n+}\n+\n+#define FOR_TABLE_BITS_(X) X(9) X(11) X(13) X(15)\n+\n+#define BAKE_METHOD_PARAM_(B) \\\n+static BROTLI_NOINLINE void BrotliCompressFragmentFastImpl ## B(             \\\n+    MemoryManager* m, const uint8_t* input, size_t input_size,               \\\n+    BROTLI_BOOL is_last, int* table, uint8_t cmd_depth[128],                 \\\n+    uint16_t cmd_bits[128], size_t* cmd_code_numbits, uint8_t* cmd_code,     \\\n+    size_t* storage_ix, uint8_t* storage) {                                  \\\n+  BrotliCompressFragmentFastImpl(m, input, input_size, is_last, table, B,    \\\n+      cmd_depth, cmd_bits, cmd_code_numbits, cmd_code, storage_ix, storage); \\\n+}\n+FOR_TABLE_BITS_(BAKE_METHOD_PARAM_)\n+#undef BAKE_METHOD_PARAM_\n+\n+void BrotliCompressFragmentFast(\n+    MemoryManager* m, const uint8_t* input, size_t input_size,\n+    BROTLI_BOOL is_last, int* table, size_t table_size, uint8_t cmd_depth[128],\n+    uint16_t cmd_bits[128], size_t* cmd_code_numbits, uint8_t* cmd_code,\n+    size_t* storage_ix, uint8_t* storage) {\n+  const size_t initial_storage_ix = *storage_ix;\n+  const size_t table_bits = Log2FloorNonZero(table_size);\n+\n+  if (input_size == 0) {\n+    BROTLI_DCHECK(is_last);\n+    BrotliWriteBits(1, 1, storage_ix, storage);  /* islast */\n+    BrotliWriteBits(1, 1, storage_ix, storage);  /* isempty */\n+    *storage_ix = (*storage_ix + 7u) & ~7u;\n+    return;\n+  }\n+\n+  switch (table_bits) {\n+#define CASE_(B)                                                     \\\n+    case B:                                                          \\\n+      BrotliCompressFragmentFastImpl ## B(                           \\\n+          m, input, input_size, is_last, table, cmd_depth, cmd_bits, \\\n+          cmd_code_numbits, cmd_code, storage_ix, storage);          \\\n+      break;\n+    FOR_TABLE_BITS_(CASE_)\n+#undef CASE_\n+    default: BROTLI_DCHECK(0); break;\n+  }\n+\n+  /* If output is larger than single uncompressed block, rewrite it. */\n+  if (*storage_ix - initial_storage_ix > 31 + (input_size << 3)) {\n+    EmitUncompressedMetaBlock(input, input + input_size, initial_storage_ix,\n+                              storage_ix, storage);\n+  }\n+\n+  if (is_last) {\n+    BrotliWriteBits(1, 1, storage_ix, storage);  /* islast */\n+    BrotliWriteBits(1, 1, storage_ix, storage);  /* isempty */\n+    *storage_ix = (*storage_ix + 7u) & ~7u;\n+  }\n+}\n+\n+#undef FOR_TABLE_BITS_\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "80007f5dcad6cc9767299d24cb37674b460cf035",
            "filename": "deps/brotli/c/enc/compress_fragment.h",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,61 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Function for fast encoding of an input fragment, independently from the input\n+   history. This function uses one-pass processing: when we find a backward\n+   match, we immediately emit the corresponding command and literal codes to\n+   the bit stream. */\n+\n+#ifndef BROTLI_ENC_COMPRESS_FRAGMENT_H_\n+#define BROTLI_ENC_COMPRESS_FRAGMENT_H_\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./memory.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* Compresses \"input\" string to the \"*storage\" buffer as one or more complete\n+   meta-blocks, and updates the \"*storage_ix\" bit position.\n+\n+   If \"is_last\" is 1, emits an additional empty last meta-block.\n+\n+   \"cmd_depth\" and \"cmd_bits\" contain the command and distance prefix codes\n+   (see comment in encode.h) used for the encoding of this input fragment.\n+   If \"is_last\" is 0, they are updated to reflect the statistics\n+   of this input fragment, to be used for the encoding of the next fragment.\n+\n+   \"*cmd_code_numbits\" is the number of bits of the compressed representation\n+   of the command and distance prefix codes, and \"cmd_code\" is an array of\n+   at least \"(*cmd_code_numbits + 7) >> 3\" size that contains the compressed\n+   command and distance prefix codes. If \"is_last\" is 0, these are also\n+   updated to represent the updated \"cmd_depth\" and \"cmd_bits\".\n+\n+   REQUIRES: \"input_size\" is greater than zero, or \"is_last\" is 1.\n+   REQUIRES: \"input_size\" is less or equal to maximal metablock size (1 << 24).\n+   REQUIRES: All elements in \"table[0..table_size-1]\" are initialized to zero.\n+   REQUIRES: \"table_size\" is an odd (9, 11, 13, 15) power of two\n+   OUTPUT: maximal copy distance <= |input_size|\n+   OUTPUT: maximal copy distance <= BROTLI_MAX_BACKWARD_LIMIT(18) */\n+BROTLI_INTERNAL void BrotliCompressFragmentFast(MemoryManager* m,\n+                                                const uint8_t* input,\n+                                                size_t input_size,\n+                                                BROTLI_BOOL is_last,\n+                                                int* table, size_t table_size,\n+                                                uint8_t cmd_depth[128],\n+                                                uint16_t cmd_bits[128],\n+                                                size_t* cmd_code_numbits,\n+                                                uint8_t* cmd_code,\n+                                                size_t* storage_ix,\n+                                                uint8_t* storage);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_COMPRESS_FRAGMENT_H_ */"
        },
        {
            "sha": "f8a560638439573eeea2a06ef6b43c6a2b2c3585",
            "filename": "deps/brotli/c/enc/compress_fragment_two_pass.c",
            "status": "added",
            "additions": 645,
            "deletions": 0,
            "changes": 645,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment_two_pass.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment_two_pass.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment_two_pass.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,645 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Function for fast encoding of an input fragment, independently from the input\n+   history. This function uses two-pass processing: in the first pass we save\n+   the found backward matches and literal bytes into a buffer, and in the\n+   second pass we emit them into the bit stream using prefix codes built based\n+   on the actual command and literal byte histograms. */\n+\n+#include \"./compress_fragment_two_pass.h\"\n+\n+#include <string.h>  /* memcmp, memcpy, memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./bit_cost.h\"\n+#include \"./brotli_bit_stream.h\"\n+#include \"./entropy_encode.h\"\n+#include \"./fast_log.h\"\n+#include \"./find_match_length.h\"\n+#include \"./memory.h\"\n+#include \"./write_bits.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define MAX_DISTANCE (long)BROTLI_MAX_BACKWARD_LIMIT(18)\n+\n+/* kHashMul32 multiplier has these properties:\n+   * The multiplier must be odd. Otherwise we may lose the highest bit.\n+   * No long streaks of ones or zeros.\n+   * There is no effort to ensure that it is a prime, the oddity is enough\n+     for this use.\n+   * The number has been tuned heuristically against compression benchmarks. */\n+static const uint32_t kHashMul32 = 0x1E35A7BD;\n+\n+static BROTLI_INLINE uint32_t Hash(const uint8_t* p,\n+    size_t shift, size_t length) {\n+  const uint64_t h =\n+      (BROTLI_UNALIGNED_LOAD64LE(p) << ((8 - length) * 8)) * kHashMul32;\n+  return (uint32_t)(h >> shift);\n+}\n+\n+static BROTLI_INLINE uint32_t HashBytesAtOffset(uint64_t v, size_t offset,\n+    size_t shift, size_t length) {\n+  BROTLI_DCHECK(offset <= 8 - length);\n+  {\n+    const uint64_t h = ((v >> (8 * offset)) << ((8 - length) * 8)) * kHashMul32;\n+    return (uint32_t)(h >> shift);\n+  }\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL IsMatch(const uint8_t* p1, const uint8_t* p2,\n+    size_t length) {\n+  if (BrotliUnalignedRead32(p1) == BrotliUnalignedRead32(p2)) {\n+    if (length == 4) return BROTLI_TRUE;\n+    return TO_BROTLI_BOOL(p1[4] == p2[4] && p1[5] == p2[5]);\n+  }\n+  return BROTLI_FALSE;\n+}\n+\n+/* Builds a command and distance prefix code (each 64 symbols) into \"depth\" and\n+   \"bits\" based on \"histogram\" and stores it into the bit stream. */\n+static void BuildAndStoreCommandPrefixCode(\n+    const uint32_t histogram[128],\n+    uint8_t depth[128], uint16_t bits[128],\n+    size_t* storage_ix, uint8_t* storage) {\n+  /* Tree size for building a tree over 64 symbols is 2 * 64 + 1. */\n+  HuffmanTree tree[129];\n+  uint8_t cmd_depth[BROTLI_NUM_COMMAND_SYMBOLS] = { 0 };\n+  uint16_t cmd_bits[64];\n+  BrotliCreateHuffmanTree(histogram, 64, 15, tree, depth);\n+  BrotliCreateHuffmanTree(&histogram[64], 64, 14, tree, &depth[64]);\n+  /* We have to jump through a few hoops here in order to compute\n+     the command bits because the symbols are in a different order than in\n+     the full alphabet. This looks complicated, but having the symbols\n+     in this order in the command bits saves a few branches in the Emit*\n+     functions. */\n+  memcpy(cmd_depth, depth + 24, 24);\n+  memcpy(cmd_depth + 24, depth, 8);\n+  memcpy(cmd_depth + 32, depth + 48, 8);\n+  memcpy(cmd_depth + 40, depth + 8, 8);\n+  memcpy(cmd_depth + 48, depth + 56, 8);\n+  memcpy(cmd_depth + 56, depth + 16, 8);\n+  BrotliConvertBitDepthsToSymbols(cmd_depth, 64, cmd_bits);\n+  memcpy(bits, cmd_bits + 24, 16);\n+  memcpy(bits + 8, cmd_bits + 40, 16);\n+  memcpy(bits + 16, cmd_bits + 56, 16);\n+  memcpy(bits + 24, cmd_bits, 48);\n+  memcpy(bits + 48, cmd_bits + 32, 16);\n+  memcpy(bits + 56, cmd_bits + 48, 16);\n+  BrotliConvertBitDepthsToSymbols(&depth[64], 64, &bits[64]);\n+  {\n+    /* Create the bit length array for the full command alphabet. */\n+    size_t i;\n+    memset(cmd_depth, 0, 64);  /* only 64 first values were used */\n+    memcpy(cmd_depth, depth + 24, 8);\n+    memcpy(cmd_depth + 64, depth + 32, 8);\n+    memcpy(cmd_depth + 128, depth + 40, 8);\n+    memcpy(cmd_depth + 192, depth + 48, 8);\n+    memcpy(cmd_depth + 384, depth + 56, 8);\n+    for (i = 0; i < 8; ++i) {\n+      cmd_depth[128 + 8 * i] = depth[i];\n+      cmd_depth[256 + 8 * i] = depth[8 + i];\n+      cmd_depth[448 + 8 * i] = depth[16 + i];\n+    }\n+    BrotliStoreHuffmanTree(\n+        cmd_depth, BROTLI_NUM_COMMAND_SYMBOLS, tree, storage_ix, storage);\n+  }\n+  BrotliStoreHuffmanTree(&depth[64], 64, tree, storage_ix, storage);\n+}\n+\n+static BROTLI_INLINE void EmitInsertLen(\n+    uint32_t insertlen, uint32_t** commands) {\n+  if (insertlen < 6) {\n+    **commands = insertlen;\n+  } else if (insertlen < 130) {\n+    const uint32_t tail = insertlen - 2;\n+    const uint32_t nbits = Log2FloorNonZero(tail) - 1u;\n+    const uint32_t prefix = tail >> nbits;\n+    const uint32_t inscode = (nbits << 1) + prefix + 2;\n+    const uint32_t extra = tail - (prefix << nbits);\n+    **commands = inscode | (extra << 8);\n+  } else if (insertlen < 2114) {\n+    const uint32_t tail = insertlen - 66;\n+    const uint32_t nbits = Log2FloorNonZero(tail);\n+    const uint32_t code = nbits + 10;\n+    const uint32_t extra = tail - (1u << nbits);\n+    **commands = code | (extra << 8);\n+  } else if (insertlen < 6210) {\n+    const uint32_t extra = insertlen - 2114;\n+    **commands = 21 | (extra << 8);\n+  } else if (insertlen < 22594) {\n+    const uint32_t extra = insertlen - 6210;\n+    **commands = 22 | (extra << 8);\n+  } else {\n+    const uint32_t extra = insertlen - 22594;\n+    **commands = 23 | (extra << 8);\n+  }\n+  ++(*commands);\n+}\n+\n+static BROTLI_INLINE void EmitCopyLen(size_t copylen, uint32_t** commands) {\n+  if (copylen < 10) {\n+    **commands = (uint32_t)(copylen + 38);\n+  } else if (copylen < 134) {\n+    const size_t tail = copylen - 6;\n+    const size_t nbits = Log2FloorNonZero(tail) - 1;\n+    const size_t prefix = tail >> nbits;\n+    const size_t code = (nbits << 1) + prefix + 44;\n+    const size_t extra = tail - (prefix << nbits);\n+    **commands = (uint32_t)(code | (extra << 8));\n+  } else if (copylen < 2118) {\n+    const size_t tail = copylen - 70;\n+    const size_t nbits = Log2FloorNonZero(tail);\n+    const size_t code = nbits + 52;\n+    const size_t extra = tail - ((size_t)1 << nbits);\n+    **commands = (uint32_t)(code | (extra << 8));\n+  } else {\n+    const size_t extra = copylen - 2118;\n+    **commands = (uint32_t)(63 | (extra << 8));\n+  }\n+  ++(*commands);\n+}\n+\n+static BROTLI_INLINE void EmitCopyLenLastDistance(\n+    size_t copylen, uint32_t** commands) {\n+  if (copylen < 12) {\n+    **commands = (uint32_t)(copylen + 20);\n+    ++(*commands);\n+  } else if (copylen < 72) {\n+    const size_t tail = copylen - 8;\n+    const size_t nbits = Log2FloorNonZero(tail) - 1;\n+    const size_t prefix = tail >> nbits;\n+    const size_t code = (nbits << 1) + prefix + 28;\n+    const size_t extra = tail - (prefix << nbits);\n+    **commands = (uint32_t)(code | (extra << 8));\n+    ++(*commands);\n+  } else if (copylen < 136) {\n+    const size_t tail = copylen - 8;\n+    const size_t code = (tail >> 5) + 54;\n+    const size_t extra = tail & 31;\n+    **commands = (uint32_t)(code | (extra << 8));\n+    ++(*commands);\n+    **commands = 64;\n+    ++(*commands);\n+  } else if (copylen < 2120) {\n+    const size_t tail = copylen - 72;\n+    const size_t nbits = Log2FloorNonZero(tail);\n+    const size_t code = nbits + 52;\n+    const size_t extra = tail - ((size_t)1 << nbits);\n+    **commands = (uint32_t)(code | (extra << 8));\n+    ++(*commands);\n+    **commands = 64;\n+    ++(*commands);\n+  } else {\n+    const size_t extra = copylen - 2120;\n+    **commands = (uint32_t)(63 | (extra << 8));\n+    ++(*commands);\n+    **commands = 64;\n+    ++(*commands);\n+  }\n+}\n+\n+static BROTLI_INLINE void EmitDistance(uint32_t distance, uint32_t** commands) {\n+  uint32_t d = distance + 3;\n+  uint32_t nbits = Log2FloorNonZero(d) - 1;\n+  const uint32_t prefix = (d >> nbits) & 1;\n+  const uint32_t offset = (2 + prefix) << nbits;\n+  const uint32_t distcode = 2 * (nbits - 1) + prefix + 80;\n+  uint32_t extra = d - offset;\n+  **commands = distcode | (extra << 8);\n+  ++(*commands);\n+}\n+\n+/* REQUIRES: len <= 1 << 24. */\n+static void BrotliStoreMetaBlockHeader(\n+    size_t len, BROTLI_BOOL is_uncompressed, size_t* storage_ix,\n+    uint8_t* storage) {\n+  size_t nibbles = 6;\n+  /* ISLAST */\n+  BrotliWriteBits(1, 0, storage_ix, storage);\n+  if (len <= (1U << 16)) {\n+    nibbles = 4;\n+  } else if (len <= (1U << 20)) {\n+    nibbles = 5;\n+  }\n+  BrotliWriteBits(2, nibbles - 4, storage_ix, storage);\n+  BrotliWriteBits(nibbles * 4, len - 1, storage_ix, storage);\n+  /* ISUNCOMPRESSED */\n+  BrotliWriteBits(1, (uint64_t)is_uncompressed, storage_ix, storage);\n+}\n+\n+static BROTLI_INLINE void CreateCommands(const uint8_t* input,\n+    size_t block_size, size_t input_size, const uint8_t* base_ip, int* table,\n+    size_t table_bits, size_t min_match,\n+    uint8_t** literals, uint32_t** commands) {\n+  /* \"ip\" is the input pointer. */\n+  const uint8_t* ip = input;\n+  const size_t shift = 64u - table_bits;\n+  const uint8_t* ip_end = input + block_size;\n+  /* \"next_emit\" is a pointer to the first byte that is not covered by a\n+     previous copy. Bytes between \"next_emit\" and the start of the next copy or\n+     the end of the input will be emitted as literal bytes. */\n+  const uint8_t* next_emit = input;\n+\n+  int last_distance = -1;\n+  const size_t kInputMarginBytes = BROTLI_WINDOW_GAP;\n+\n+  if (BROTLI_PREDICT_TRUE(block_size >= kInputMarginBytes)) {\n+    /* For the last block, we need to keep a 16 bytes margin so that we can be\n+       sure that all distances are at most window size - 16.\n+       For all other blocks, we only need to keep a margin of 5 bytes so that\n+       we don't go over the block size with a copy. */\n+    const size_t len_limit = BROTLI_MIN(size_t, block_size - min_match,\n+                                        input_size - kInputMarginBytes);\n+    const uint8_t* ip_limit = input + len_limit;\n+\n+    uint32_t next_hash;\n+    for (next_hash = Hash(++ip, shift, min_match); ; ) {\n+      /* Step 1: Scan forward in the input looking for a 6-byte-long match.\n+         If we get close to exhausting the input then goto emit_remainder.\n+\n+         Heuristic match skipping: If 32 bytes are scanned with no matches\n+         found, start looking only at every other byte. If 32 more bytes are\n+         scanned, look at every third byte, etc.. When a match is found,\n+         immediately go back to looking at every byte. This is a small loss\n+         (~5% performance, ~0.1% density) for compressible data due to more\n+         bookkeeping, but for non-compressible data (such as JPEG) it's a huge\n+         win since the compressor quickly \"realizes\" the data is incompressible\n+         and doesn't bother looking for matches everywhere.\n+\n+         The \"skip\" variable keeps track of how many bytes there are since the\n+         last match; dividing it by 32 (ie. right-shifting by five) gives the\n+         number of bytes to move ahead for each iteration. */\n+      uint32_t skip = 32;\n+\n+      const uint8_t* next_ip = ip;\n+      const uint8_t* candidate;\n+\n+      BROTLI_DCHECK(next_emit < ip);\n+trawl:\n+      do {\n+        uint32_t hash = next_hash;\n+        uint32_t bytes_between_hash_lookups = skip++ >> 5;\n+        ip = next_ip;\n+        BROTLI_DCHECK(hash == Hash(ip, shift, min_match));\n+        next_ip = ip + bytes_between_hash_lookups;\n+        if (BROTLI_PREDICT_FALSE(next_ip > ip_limit)) {\n+          goto emit_remainder;\n+        }\n+        next_hash = Hash(next_ip, shift, min_match);\n+        candidate = ip - last_distance;\n+        if (IsMatch(ip, candidate, min_match)) {\n+          if (BROTLI_PREDICT_TRUE(candidate < ip)) {\n+            table[hash] = (int)(ip - base_ip);\n+            break;\n+          }\n+        }\n+        candidate = base_ip + table[hash];\n+        BROTLI_DCHECK(candidate >= base_ip);\n+        BROTLI_DCHECK(candidate < ip);\n+\n+        table[hash] = (int)(ip - base_ip);\n+      } while (BROTLI_PREDICT_TRUE(!IsMatch(ip, candidate, min_match)));\n+\n+      /* Check copy distance. If candidate is not feasible, continue search.\n+         Checking is done outside of hot loop to reduce overhead. */\n+      if (ip - candidate > MAX_DISTANCE) goto trawl;\n+\n+      /* Step 2: Emit the found match together with the literal bytes from\n+         \"next_emit\", and then see if we can find a next match immediately\n+         afterwards. Repeat until we find no match for the input\n+         without emitting some literal bytes. */\n+\n+      {\n+        /* We have a 6-byte match at ip, and we need to emit bytes in\n+           [next_emit, ip). */\n+        const uint8_t* base = ip;\n+        size_t matched = min_match + FindMatchLengthWithLimit(\n+            candidate + min_match, ip + min_match,\n+            (size_t)(ip_end - ip) - min_match);\n+        int distance = (int)(base - candidate);  /* > 0 */\n+        int insert = (int)(base - next_emit);\n+        ip += matched;\n+        BROTLI_DCHECK(0 == memcmp(base, candidate, matched));\n+        EmitInsertLen((uint32_t)insert, commands);\n+        memcpy(*literals, next_emit, (size_t)insert);\n+        *literals += insert;\n+        if (distance == last_distance) {\n+          **commands = 64;\n+          ++(*commands);\n+        } else {\n+          EmitDistance((uint32_t)distance, commands);\n+          last_distance = distance;\n+        }\n+        EmitCopyLenLastDistance(matched, commands);\n+\n+        next_emit = ip;\n+        if (BROTLI_PREDICT_FALSE(ip >= ip_limit)) {\n+          goto emit_remainder;\n+        }\n+        {\n+          /* We could immediately start working at ip now, but to improve\n+             compression we first update \"table\" with the hashes of some\n+             positions within the last copy. */\n+          uint64_t input_bytes;\n+          uint32_t cur_hash;\n+          uint32_t prev_hash;\n+          if (min_match == 4) {\n+            input_bytes = BROTLI_UNALIGNED_LOAD64LE(ip - 3);\n+            cur_hash = HashBytesAtOffset(input_bytes, 3, shift, min_match);\n+            prev_hash = HashBytesAtOffset(input_bytes, 0, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 3);\n+            prev_hash = HashBytesAtOffset(input_bytes, 1, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 2);\n+            prev_hash = HashBytesAtOffset(input_bytes, 0, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 1);\n+          } else {\n+            input_bytes = BROTLI_UNALIGNED_LOAD64LE(ip - 5);\n+            prev_hash = HashBytesAtOffset(input_bytes, 0, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 5);\n+            prev_hash = HashBytesAtOffset(input_bytes, 1, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 4);\n+            prev_hash = HashBytesAtOffset(input_bytes, 2, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 3);\n+            input_bytes = BROTLI_UNALIGNED_LOAD64LE(ip - 2);\n+            cur_hash = HashBytesAtOffset(input_bytes, 2, shift, min_match);\n+            prev_hash = HashBytesAtOffset(input_bytes, 0, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 2);\n+            prev_hash = HashBytesAtOffset(input_bytes, 1, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 1);\n+          }\n+\n+          candidate = base_ip + table[cur_hash];\n+          table[cur_hash] = (int)(ip - base_ip);\n+        }\n+      }\n+\n+      while (ip - candidate <= MAX_DISTANCE &&\n+          IsMatch(ip, candidate, min_match)) {\n+        /* We have a 6-byte match at ip, and no need to emit any\n+           literal bytes prior to ip. */\n+        const uint8_t* base = ip;\n+        size_t matched = min_match + FindMatchLengthWithLimit(\n+            candidate + min_match, ip + min_match,\n+            (size_t)(ip_end - ip) - min_match);\n+        ip += matched;\n+        last_distance = (int)(base - candidate);  /* > 0 */\n+        BROTLI_DCHECK(0 == memcmp(base, candidate, matched));\n+        EmitCopyLen(matched, commands);\n+        EmitDistance((uint32_t)last_distance, commands);\n+\n+        next_emit = ip;\n+        if (BROTLI_PREDICT_FALSE(ip >= ip_limit)) {\n+          goto emit_remainder;\n+        }\n+        {\n+          /* We could immediately start working at ip now, but to improve\n+             compression we first update \"table\" with the hashes of some\n+             positions within the last copy. */\n+          uint64_t input_bytes;\n+          uint32_t cur_hash;\n+          uint32_t prev_hash;\n+          if (min_match == 4) {\n+            input_bytes = BROTLI_UNALIGNED_LOAD64LE(ip - 3);\n+            cur_hash = HashBytesAtOffset(input_bytes, 3, shift, min_match);\n+            prev_hash = HashBytesAtOffset(input_bytes, 0, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 3);\n+            prev_hash = HashBytesAtOffset(input_bytes, 1, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 2);\n+            prev_hash = HashBytesAtOffset(input_bytes, 2, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 1);\n+          } else {\n+            input_bytes = BROTLI_UNALIGNED_LOAD64LE(ip - 5);\n+            prev_hash = HashBytesAtOffset(input_bytes, 0, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 5);\n+            prev_hash = HashBytesAtOffset(input_bytes, 1, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 4);\n+            prev_hash = HashBytesAtOffset(input_bytes, 2, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 3);\n+            input_bytes = BROTLI_UNALIGNED_LOAD64LE(ip - 2);\n+            cur_hash = HashBytesAtOffset(input_bytes, 2, shift, min_match);\n+            prev_hash = HashBytesAtOffset(input_bytes, 0, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 2);\n+            prev_hash = HashBytesAtOffset(input_bytes, 1, shift, min_match);\n+            table[prev_hash] = (int)(ip - base_ip - 1);\n+          }\n+\n+          candidate = base_ip + table[cur_hash];\n+          table[cur_hash] = (int)(ip - base_ip);\n+        }\n+      }\n+\n+      next_hash = Hash(++ip, shift, min_match);\n+    }\n+  }\n+\n+emit_remainder:\n+  BROTLI_DCHECK(next_emit <= ip_end);\n+  /* Emit the remaining bytes as literals. */\n+  if (next_emit < ip_end) {\n+    const uint32_t insert = (uint32_t)(ip_end - next_emit);\n+    EmitInsertLen(insert, commands);\n+    memcpy(*literals, next_emit, insert);\n+    *literals += insert;\n+  }\n+}\n+\n+static void StoreCommands(MemoryManager* m,\n+                          const uint8_t* literals, const size_t num_literals,\n+                          const uint32_t* commands, const size_t num_commands,\n+                          size_t* storage_ix, uint8_t* storage) {\n+  static const uint32_t kNumExtraBits[128] = {\n+    0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 12, 14, 24,\n+    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4,\n+    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 24,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8,\n+    9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16,\n+    17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24,\n+  };\n+  static const uint32_t kInsertOffset[24] = {\n+    0, 1, 2, 3, 4, 5, 6, 8, 10, 14, 18, 26, 34, 50, 66, 98, 130, 194, 322, 578,\n+    1090, 2114, 6210, 22594,\n+  };\n+\n+  uint8_t lit_depths[256];\n+  uint16_t lit_bits[256];\n+  uint32_t lit_histo[256] = { 0 };\n+  uint8_t cmd_depths[128] = { 0 };\n+  uint16_t cmd_bits[128] = { 0 };\n+  uint32_t cmd_histo[128] = { 0 };\n+  size_t i;\n+  for (i = 0; i < num_literals; ++i) {\n+    ++lit_histo[literals[i]];\n+  }\n+  BrotliBuildAndStoreHuffmanTreeFast(m, lit_histo, num_literals,\n+                                     /* max_bits = */ 8,\n+                                     lit_depths, lit_bits,\n+                                     storage_ix, storage);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  for (i = 0; i < num_commands; ++i) {\n+    const uint32_t code = commands[i] & 0xFF;\n+    BROTLI_DCHECK(code < 128);\n+    ++cmd_histo[code];\n+  }\n+  cmd_histo[1] += 1;\n+  cmd_histo[2] += 1;\n+  cmd_histo[64] += 1;\n+  cmd_histo[84] += 1;\n+  BuildAndStoreCommandPrefixCode(cmd_histo, cmd_depths, cmd_bits,\n+                                 storage_ix, storage);\n+\n+  for (i = 0; i < num_commands; ++i) {\n+    const uint32_t cmd = commands[i];\n+    const uint32_t code = cmd & 0xFF;\n+    const uint32_t extra = cmd >> 8;\n+    BROTLI_DCHECK(code < 128);\n+    BrotliWriteBits(cmd_depths[code], cmd_bits[code], storage_ix, storage);\n+    BrotliWriteBits(kNumExtraBits[code], extra, storage_ix, storage);\n+    if (code < 24) {\n+      const uint32_t insert = kInsertOffset[code] + extra;\n+      uint32_t j;\n+      for (j = 0; j < insert; ++j) {\n+        const uint8_t lit = *literals;\n+        BrotliWriteBits(lit_depths[lit], lit_bits[lit], storage_ix, storage);\n+        ++literals;\n+      }\n+    }\n+  }\n+}\n+\n+/* Acceptable loss for uncompressible speedup is 2% */\n+#define MIN_RATIO 0.98\n+#define SAMPLE_RATE 43\n+\n+static BROTLI_BOOL ShouldCompress(\n+    const uint8_t* input, size_t input_size, size_t num_literals) {\n+  double corpus_size = (double)input_size;\n+  if (num_literals < MIN_RATIO * corpus_size) {\n+    return BROTLI_TRUE;\n+  } else {\n+    uint32_t literal_histo[256] = { 0 };\n+    const double max_total_bit_cost = corpus_size * 8 * MIN_RATIO / SAMPLE_RATE;\n+    size_t i;\n+    for (i = 0; i < input_size; i += SAMPLE_RATE) {\n+      ++literal_histo[input[i]];\n+    }\n+    return TO_BROTLI_BOOL(BitsEntropy(literal_histo, 256) < max_total_bit_cost);\n+  }\n+}\n+\n+static void RewindBitPosition(const size_t new_storage_ix,\n+                              size_t* storage_ix, uint8_t* storage) {\n+  const size_t bitpos = new_storage_ix & 7;\n+  const size_t mask = (1u << bitpos) - 1;\n+  storage[new_storage_ix >> 3] &= (uint8_t)mask;\n+  *storage_ix = new_storage_ix;\n+}\n+\n+static void EmitUncompressedMetaBlock(const uint8_t* input, size_t input_size,\n+                                      size_t* storage_ix, uint8_t* storage) {\n+  BrotliStoreMetaBlockHeader(input_size, 1, storage_ix, storage);\n+  *storage_ix = (*storage_ix + 7u) & ~7u;\n+  memcpy(&storage[*storage_ix >> 3], input, input_size);\n+  *storage_ix += input_size << 3;\n+  storage[*storage_ix >> 3] = 0;\n+}\n+\n+static BROTLI_INLINE void BrotliCompressFragmentTwoPassImpl(\n+    MemoryManager* m, const uint8_t* input, size_t input_size,\n+    BROTLI_BOOL is_last, uint32_t* command_buf, uint8_t* literal_buf,\n+    int* table, size_t table_bits, size_t min_match,\n+    size_t* storage_ix, uint8_t* storage) {\n+  /* Save the start of the first block for position and distance computations.\n+  */\n+  const uint8_t* base_ip = input;\n+  BROTLI_UNUSED(is_last);\n+\n+  while (input_size > 0) {\n+    size_t block_size =\n+        BROTLI_MIN(size_t, input_size, kCompressFragmentTwoPassBlockSize);\n+    uint32_t* commands = command_buf;\n+    uint8_t* literals = literal_buf;\n+    size_t num_literals;\n+    CreateCommands(input, block_size, input_size, base_ip, table,\n+                   table_bits, min_match, &literals, &commands);\n+    num_literals = (size_t)(literals - literal_buf);\n+    if (ShouldCompress(input, block_size, num_literals)) {\n+      const size_t num_commands = (size_t)(commands - command_buf);\n+      BrotliStoreMetaBlockHeader(block_size, 0, storage_ix, storage);\n+      /* No block splits, no contexts. */\n+      BrotliWriteBits(13, 0, storage_ix, storage);\n+      StoreCommands(m, literal_buf, num_literals, command_buf, num_commands,\n+                    storage_ix, storage);\n+      if (BROTLI_IS_OOM(m)) return;\n+    } else {\n+      /* Since we did not find many backward references and the entropy of\n+         the data is close to 8 bits, we can simply emit an uncompressed block.\n+         This makes compression speed of uncompressible data about 3x faster. */\n+      EmitUncompressedMetaBlock(input, block_size, storage_ix, storage);\n+    }\n+    input += block_size;\n+    input_size -= block_size;\n+  }\n+}\n+\n+#define FOR_TABLE_BITS_(X) \\\n+  X(8) X(9) X(10) X(11) X(12) X(13) X(14) X(15) X(16) X(17)\n+\n+#define BAKE_METHOD_PARAM_(B)                                                  \\\n+static BROTLI_NOINLINE void BrotliCompressFragmentTwoPassImpl ## B(            \\\n+    MemoryManager* m, const uint8_t* input, size_t input_size,                 \\\n+    BROTLI_BOOL is_last, uint32_t* command_buf, uint8_t* literal_buf,          \\\n+    int* table, size_t* storage_ix, uint8_t* storage) {                        \\\n+  size_t min_match = (B <= 15) ? 4 : 6;                                        \\\n+  BrotliCompressFragmentTwoPassImpl(m, input, input_size, is_last, command_buf,\\\n+      literal_buf, table, B, min_match, storage_ix, storage);                  \\\n+}\n+FOR_TABLE_BITS_(BAKE_METHOD_PARAM_)\n+#undef BAKE_METHOD_PARAM_\n+\n+void BrotliCompressFragmentTwoPass(\n+    MemoryManager* m, const uint8_t* input, size_t input_size,\n+    BROTLI_BOOL is_last, uint32_t* command_buf, uint8_t* literal_buf,\n+    int* table, size_t table_size, size_t* storage_ix, uint8_t* storage) {\n+  const size_t initial_storage_ix = *storage_ix;\n+  const size_t table_bits = Log2FloorNonZero(table_size);\n+  switch (table_bits) {\n+#define CASE_(B)                                      \\\n+    case B:                                           \\\n+      BrotliCompressFragmentTwoPassImpl ## B(         \\\n+          m, input, input_size, is_last, command_buf, \\\n+          literal_buf, table, storage_ix, storage);   \\\n+      break;\n+    FOR_TABLE_BITS_(CASE_)\n+#undef CASE_\n+    default: BROTLI_DCHECK(0); break;\n+  }\n+\n+  /* If output is larger than single uncompressed block, rewrite it. */\n+  if (*storage_ix - initial_storage_ix > 31 + (input_size << 3)) {\n+    RewindBitPosition(initial_storage_ix, storage_ix, storage);\n+    EmitUncompressedMetaBlock(input, input_size, storage_ix, storage);\n+  }\n+\n+  if (is_last) {\n+    BrotliWriteBits(1, 1, storage_ix, storage);  /* islast */\n+    BrotliWriteBits(1, 1, storage_ix, storage);  /* isempty */\n+    *storage_ix = (*storage_ix + 7u) & ~7u;\n+  }\n+}\n+\n+#undef FOR_TABLE_BITS_\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "928677df4260a6decc4fcd3905b03e8cc131d6a2",
            "filename": "deps/brotli/c/enc/compress_fragment_two_pass.h",
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment_two_pass.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment_two_pass.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fcompress_fragment_two_pass.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,54 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Function for fast encoding of an input fragment, independently from the input\n+   history. This function uses two-pass processing: in the first pass we save\n+   the found backward matches and literal bytes into a buffer, and in the\n+   second pass we emit them into the bit stream using prefix codes built based\n+   on the actual command and literal byte histograms. */\n+\n+#ifndef BROTLI_ENC_COMPRESS_FRAGMENT_TWO_PASS_H_\n+#define BROTLI_ENC_COMPRESS_FRAGMENT_TWO_PASS_H_\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./memory.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+static const size_t kCompressFragmentTwoPassBlockSize = 1 << 17;\n+\n+/* Compresses \"input\" string to the \"*storage\" buffer as one or more complete\n+   meta-blocks, and updates the \"*storage_ix\" bit position.\n+\n+   If \"is_last\" is 1, emits an additional empty last meta-block.\n+\n+   REQUIRES: \"input_size\" is greater than zero, or \"is_last\" is 1.\n+   REQUIRES: \"input_size\" is less or equal to maximal metablock size (1 << 24).\n+   REQUIRES: \"command_buf\" and \"literal_buf\" point to at least\n+              kCompressFragmentTwoPassBlockSize long arrays.\n+   REQUIRES: All elements in \"table[0..table_size-1]\" are initialized to zero.\n+   REQUIRES: \"table_size\" is a power of two\n+   OUTPUT: maximal copy distance <= |input_size|\n+   OUTPUT: maximal copy distance <= BROTLI_MAX_BACKWARD_LIMIT(18) */\n+BROTLI_INTERNAL void BrotliCompressFragmentTwoPass(MemoryManager* m,\n+                                                   const uint8_t* input,\n+                                                   size_t input_size,\n+                                                   BROTLI_BOOL is_last,\n+                                                   uint32_t* command_buf,\n+                                                   uint8_t* literal_buf,\n+                                                   int* table,\n+                                                   size_t table_size,\n+                                                   size_t* storage_ix,\n+                                                   uint8_t* storage);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_COMPRESS_FRAGMENT_TWO_PASS_H_ */"
        },
        {
            "sha": "3677d7ddb4ee4f4d816a5bfc5e28ea0d2b0cc222",
            "filename": "deps/brotli/c/enc/dictionary_hash.c",
            "status": "added",
            "additions": 1120,
            "deletions": 0,
            "changes": 1120,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fdictionary_hash.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fdictionary_hash.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fdictionary_hash.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,1120 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Hash table on the 4-byte prefixes of static dictionary words. */\n+\n+#include \"../common/platform.h\"\n+#include \"./dictionary_hash.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+BROTLI_INTERNAL const uint16_t kStaticDictionaryHash[32768] = {\n+32072,0,0,0,0,0,0,0,0,21860,0,0,0,0,0,0,0,40486,0,0,0,0,0,45798,0,0,0,0,0,0,1292\n+,0,0,0,0,4964,278,23717,0,19972,0,0,0,0,0,0,0,0,0,0,0,0,2126,16102,0,0,0,14437,0\n+,0,0,0,0,0,0,26727,2253,0,0,17252,0,0,0,0,0,0,0,0,0,3622,0,0,0,0,22984,0,0,0,0,0\n+,0,16647,0,34247,0,0,0,0,0,48486,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2511,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19532,0,0,24004,0,0,0,9828,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30853,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,31974,0,0,0,0,0,0,0,0,20650,2404,0,20773,1677,9031,0,6404,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51879,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6761,7206\n+,0,0,21992,22983,0,0,3529,0,1864,0,0,0,0,0,0,11046,0,0,9641,0,0,0,6507,0,0,36934\n+,21576,62375,0,0,0,0,0,0,0,0,0,8294,0,0,0,0,0,0,0,40807,0,0,0,39398,8136,0,0,0,0\n+,0,0,0,8875,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7941,0,0,25609,0,0,0,936,\n+3716,3213,15687,0,0,0,0,0,52519,0,17381,0,0,0,0,1320,5797,0,21029,0,0,6472,807,0\n+,0,0,0,0,0,0,0,0,0,13545,0,0,0,3624,0,0,0,29674,30820,0,31237,0,6596,0,0,0,0,0,0\n+,0,0,0,64070,0,0,0,0,0,0,0,0,0,0,0,22278,0,37446,0,0,0,0,7240,423,0,24612,21705,\n+17636,0,0,0,0,0,0,1833,0,0,0,328,6021,0,0,0,19974,0,0,0,0,0,0,0,0,0,62119,4178,0\n+,0,0,0,12100,8617,0,0,16900,0,36678,0,0,0,35366,0,51718,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,20998,0,62086,0,0,0,0,0,5542,0,0,0,0,0,0,0,0,0,0,0,14629,10952,25927,0,0,0\n+,0,19849,0,0,0,0,0,0,0,30952,3046,14314,12998,0,0,0,15268,0,40582,30216,62118,0,\n+0,0,20132,0,0,0,0,0,12005,0,0,0,52358,0,0,0,0,24778,0,44,33095,0,0,0,0,0,26372,0\n+,0,0,0,0,3781,0,0,17928,9479,0,0,0,0,0,0,0,0,32297,28613,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,47174,11723,0,0,0,0,0,0,0,0,0,2536,55143,0,0,6410,0,0,0,0,0,0,0,0,56294,11914\n+,0,529,0,30184,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8261,0,0,28808,58854,22633,\n+965,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64135,0,0,331,3684,0,1605,0,0,0,0,0,0,\n+0,0,0,0,16650,37,0,23622,3144,15429,0,0,0,0,0,0,0,0,0,0,22443,69,0,0,0,0,0,0,0,0\n+,17832,0,0,0,0,0,0,0,0,0,11113,0,0,0,0,18309,0,0,0,0,0,0,0,0,0,26630,0,0,25512,\n+25895,0,0,0,0,0,0,0,0,0,0,0,16901,0,0,0,27558,0,0,9418,0,0,0,3508,0,0,0,0,0,0,0,\n+0,37990,9289,8517,0,0,0,0,1578,1604,23944,0,0,14916,12781,0,0,0,0,0,0,0,12105,0,\n+16617,0,0,0,0,0,0,0,0,0,0,0,0,21348,11240,28870,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,5772,0,0,27812,0,0,0,0,0,0,0,8324,0,0,0,0,0,0,0,0,0,0,16748,1157,0,0,18794,\n+16324,25898,935,8333,0,0,0,0,0,0,0,0,18246,0,18086,0,46854,0,0,0,0,0,0,339,0,0,\n+25188,12780,12166,6409,0,0,0,0,16516,0,27012,28395,0,0,0,0,0,0,0,1420,0,0,0,9768\n+,52967,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25163,324,0,0,0,0,0,0,0,0,0,64998,0,0,0,0,0,\n+21893,0,0,0,0,0,47366,0,0,0,870,0,0,0,12646,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,26020,16360,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1809,0,0,0,6601,15878,0,0,0,0,0,\n+29092,0,28516,0,0,0,0,0,0,0,0,0,21988,0,0,0,42950,0,0,0,0,0,0,0,0,0,0,5133,1318,\n+0,0,0,0,0,0,0,0,0,0,0,54982,24904,0,0,0,0,0,0,0,0,0,0,51526,0,0,0,0,0,3685,0,0,0\n+,0,10062,9412,0,0,0,31460,5708,6181,0,0,0,0,0,0,0,0,0,5575,0,0,0,0,0,0,0,0,0,0,\n+27144,57478,0,0,0,0,0,0,7084,0,21993,53126,0,0,0,0,8397,0,0,5733,0,0,0,0,0,2116,\n+0,24742,0,11271,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1133,0,4873,0,0,38310,0,0,0,0,0,\n+0,0,0,0,0,0,0,17932,0,0,18053,0,0,0,25510,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17798,0,\n+26214,0,0,0,0,0,0,0,0,23016,17415,20392,164,0,0,0,0,0,0,0,0,0,0,0,3239,0,46119,0\n+,0,0,28580,0,0,0,0,0,0,0,0,0,7621,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,41478,0,0,31016,\n+55334,10056,1924,0,0,0,0,0,36614,0,36711,0,0,0,0,0,0,0,0,0,0,13994,59303,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,26501,0,5639,0,0,0,0,0,0,13897,1253,0,0,0,0,0,5095,0,0,0,\n+28869,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8646,0,0,0,0,25641,17796,0,0,0,0,0,0,0,\n+13316,620,6309,11819,0,0,0,0,0,0,0,0,0,904,1095,0,24229,0,0,28744,49703,0,23077,\n+0,0,0,0,32392,0,0,0,0,35271,0,28740,5866,0,0,0,0,0,0,0,4361,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7917,8869,0,0,0,13924,0,0,0,0,\n+0,41958,0,0,0,0,0,0,6766,13989,0,0,0,903,0,0,24010,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,64390,0,22468,0,25861,0,0,0,0,23656,5317,0,0,0,0,0,0,23017,5445,16009\n+,0,0,0,0,0,0,0,0,48006,10473,0,0,14404,0,0,0,42183,0,0,0,51270,0,0,10602,24132,0\n+,0,0,0,0,43782,0,0,17834,0,0,0,25576,27205,0,0,0,0,0,0,0,0,29066,0,0,0,0,0,626,\n+1988,14700,0,0,0,0,0,0,0,0,0,0,0,0,57670,0,0,0,0,0,0,0,0,0,44710,0,0,0,0,3848,\n+7623,0,0,0,0,0,0,0,0,0,0,0,42374,0,0,0,0,0,0,0,0,19272,6436,0,0,5256,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,19685,0,0,0,0,0,0,0,0,0,0,0,0,0,39783,0,0,0,0,30984,0,0,0,0,0,0\n+,28230,0,0,0,29028,10538,3205,0,0,0,0,0,0,0,0,0,0,0,5636,840,295,0,0,8488,8198,0\n+,0,0,0,0,0,0,0,0,20580,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4074,19526,0,0,0,0,\n+31144,64038,0,0,0,0,0,0,16716,0,0,0,0,0,0,0,0,0,0,0,17706,0,0,0,0,0,0,50630,0,\n+50503,0,0,0,0,0,0,0,0,0,0,0,25446,0,0,0,13831,0,0,0,0,0,0,2696,4039,0,0,0,0,\n+25288,0,12076,2054,0,48934,0,0,0,0,16969,59431,17259,35335,0,0,0,0,0,0,0,0,0,0,0\n+,0,31275,0,0,0,1097,0,0,0,0,0,0,0,0,0,0,0,776,839,0,0,29386,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,5864,12134,0,0,0,0,0,0,0,25349,0,0,0,0,0,0,0,0,0,61447\n+,0,0,0,0,0,0,0,0,0,24678,0,0,0,63335,0,28836,8142,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4494,0,0,0,0,0,14088,1188,0,16260,0,0,0,\n+16421,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,276,0,0,17060,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24076,29445,0,33543,0,4901,0\n+,0,12522,0,0,62471,0,0,0,0,0,0,0,0,0,0,4046,0,0,0,0,20486,0,15460,2217,51719,0,0\n+,0,0,0,23495,0,0,0,0,0,0,15370,0,15849,0,15113,0,0,0,0,0,0,0,0,27972,7337,0,0,0,\n+0,30342,0,0,0,0,0,0,0,0,32299,23940,0,17766,0,0,0,0,0,0,6184,0,20904,0,0,0,0,0,0\n+,0,0,0,0,31492,0,0,0,5509,0,0,0,0,0,0,0,0,2669,50182,0,0,12299,0,0,0,0,0,0,0,\n+5257,28167,0,0,0,0,0,0,0,0,0,0,0,11750,3890,0,0,26500,0,0,0,0,0,0,0,49318,0,0,0,\n+0,0,0,0,10981,0,0,0,0,0,0,0,0,17961,1831,0,0,0,0,0,0,0,29638,0,0,0,0,26473,0,\n+6216,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,711,0,0,0,0,0,0,0,0,0,0,28683,39975\n+,0,0,0,0,0,51654,0,0,0,27527,0,0,0,0,0,0,0,0,30859,3268,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28772,0,18212,0,0,0,0,25448,65446,0,0,0,0,\n+0,0,3337,1670,0,0,0,0,0,19332,0,0,0,0,24936,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1043,0\n+,0,0,0,15814,0,21670,0,0,0,0,0,0,0,16263,0,0,0,0,0,0,0,0,0,32454,0,30630,0,0,\n+20170,9926,0,0,0,18247,0,0,14376,0,2056,17191,0,0,0,0,0,0,0,7812,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,22474,52806,1588,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10825,0,\n+0,0,0,40934,0,0,0,0,0,0,0,28677,0,0,5714,0,0,0,0,0,0,0,0,0,0,0,0,0,25865,22246,0\n+,0,0,0,17256,35751,0,0,0,0,0,0,0,0,8236,0,32108,0,0,0,43,14342,0,16517,0,0,30732\n+,0,4012,133,0,40583,971,23942,0,0,27275,0,0,0,204,0,0,27140,7564,44327,27592,\n+57958,0,0,0,0,22344,25701,0,0,0,0,0,0,0,19524,31755,0,0,28102,0,59111,0,0,0,0,0,\n+0,0,12261,0,44934,0,0,0,0,31560,0,11114,0,0,0,0,0,0,0,0,0,0,0,18953,18311,0,\n+45159,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2059,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+19399,0,0,0,0,0,0,0,0,0,0,0,0,0,58534,0,0,0,0,0,0,0,0,0,0,0,0,22411,23943,0,0,0,\n+0,0,0,11690,0,0,4069,0,0,2668,6342,0,0,0,0,0,0,27658,1766,0,0,0,0,23240,56070,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,34119,0,24453,0,0,0,0,21867,0,17610,9894,0,0,27976,38790\n+,0,0,0,43654,0,31559,12202,23142,0,0,0,50343,0,0,0,0,0,32806,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,49895,0,0,0,0,15786,4263,0,0,0,0,4746,3814,0,0,0,0,0,0,17192,\n+453,17323,0,20328,4036,0,0,0,15844,0,0,0,0,27561,31940,32296,0,0,0,0,0,0,0,11499\n+,11782,0,0,0,0,9738,50471,0,0,0,0,0,35430,0,0,0,0,0,29734,0,0,0,36551,0,0,0,0,\n+9257,5606,0,13829,0,7015,0,0,0,0,0,25127,0,0,19051,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+2572,0,0,0,0,0,0,29797,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42342,0,0,0,0,9293,\n+0,17896,56038,4077,0,0,0,29899,37351,0,30823,0,8326,0,0,0,18342,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18569,54054,0,0,0,0,0,0,0,0,0,37254,0,0,31433,\n+61510,0,2022,0,0,0,0,0,25381,0,0,0,0,0,0,0,0,0,0,0,0,0,2149,25289,0,0,0,0,0,0,0,\n+0,0,0,12516,14185,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8676,0,0,0,0,0\n+,0,0,0,0,0,0,36486,0,0,0,0,10889,9607,0,28711,0,0,0,0,0,0,0,0,0,0,28490,0,0,0,0,\n+26181,10283,1701,0,0,0,0,0,0,0,0,0,14980,0,7783,0,27846,0,0,0,56486,3892,0,0,0,\n+5770,16583,0,26309,13422,20292,0,0,0,0,0,0,0,0,0,28742,0,0,0,0,14536,1158,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25801,0,0,0,0,0,0,0,0,0,0,0,0,42438,0,3332,0,0\n+,0,0,0,0,0,0,0,8327,0,0,0,0,0,0,0,0,0,0,0,0,17353,1447,0,0,8427,48518,1359,0,0,0\n+,0,0,14986,0,32168,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9230,2791,0,0,0,0,0,0,0,0,\n+16073,31623,4269,0,0,0,0,0,0,4519,0,0,27912,58950,0,0,0,0,0,0,0,0,8361,19812,0,0\n+,0,0,6056,7877,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21701,0,0,0,0,0,0,0,0,0,0,0\n+,0,9128,1125,0,16548,0,0,0,0,0,0,0,0,0,0,17292,6854,21352,0,2380,0,0,4007,0,0,0,\n+0,0,24357,4202,0,0,0,0,0,0,0,0,0,0,0,0,0,10664,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,42823,3022,0,0,0,0,0,0,0,0,0,0,0,0,14373,0,20677,3304,2759,20522,64903,0,\n+0,0,38,0,0,0,0,0,0,0,0,0,0,0,27814,2802,8870,3758,1255,0,0,0,0,0,0,0,0,30027,\n+9510,0,0,0,0,17864,14855,0,0,0,0,0,0,0,0,0,0,23404,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+51462,0,0,0,0,0,0,0,45734,0,0,23467,32327,0,0,10826,52999,0,0,0,33222,31336,\n+64326,0,0,0,0,0,0,0,32166,0,0,3891,0,0,0,7017,645,0,0,0,0,0,0,27915,46087,0,0,0,\n+21863,0,34246,0,0,16715,0,0,0,0,14052,21416,0,0,0,0,0,0,0,0,39846,0,0,0,0,0,\n+38982,0,0,17512,7460,0,0,0,0,0,0,0,0,0,15428,0,0,0,0,0,0,0,28356,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,25445,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11879,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,19911,0,20007,0,0,0,10855,943,0,0,10821,0,0,0,0,4170,0,0,0,0,0,0,\n+0,0,0,9836,0,0,0,0,0,0,0,0,0,0,65415,0,0,0,0,0,0,0,0,9865,24646,0,0,0,0,0,40519,\n+0,0,0,0,0,0,0,0,0,12804,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22091,23655,0,0,0,0,0,0,\n+0,31686,0,0,0,58599,0,0,0,0,0,0,0,0,0,0,0,0,0,19620,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+24421,0,28100,0,0,0,31268,0,3204,0,0,0,0,0,0,0,0,0,14822,0,0,0,0,19947,10182,0,0\n+,9480,14821,4398,0,0,14532,0,0,0,48871,1873,0,0,0,0,0,0,0,589,1541,0,0,0,0,0,\n+23333,0,0,0,14149,0,0,0,0,1296,14374,0,27300,0,0,0,0,0,0,7276,0,0,0,0,0,0,47718,\n+0,0,0,0,0,0,0,0,0,0,5164,1765,0,14405,0,37574,1994,0,6636,0,0,0,0,0,0,0,0,27815,\n+0,0,0,0,2568,6820,0,0,0,0,0,0,0,0,0,0,11336,26247,0,0,23912,0,0,0,30536,0,0,\n+34342,0,17799,0,0,0,22149,0,6118,0,25732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,26600,5190,0,0,1142,0,0,0,0,0,0,0,0,39527,0,0,0,0,0,39494,0,0,0,0,0,0,0\n+,0,0,0,3085,0,0,0,0,0,0,0,4786,0,0,0,28873,6532,0,0,26664,0,9193,11719,0,0,0,0,0\n+,0,31752,64646,0,0,0,0,0,0,0,0,0,0,0,11397,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25094,0\n+,0,18153,20167,0,0,0,17254,0,0,878,0,0,0,0,0,0,0,0,0,0,24166,0,0,0,0,0,0,0,0,0,0\n+,0,0,26059,0,0,0,0,0,0,0,0,0,0,0,0,0,31592,0,0,8167,24362,6212,0,34758,0,0,0,0,0\n+,0,32520,0,0,44679,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17989,8681,29222,0,0,0,\n+0,0,0,0,0,10251,4902,1452,15207,0,0,0,0,0,0,0,22822,0,10469,0,0,0,0,0,0,19337,\n+17670,107,11494,0,0,0,0,27305,2565,0,0,0,0,0,0,0,64518,200,28389,0,0,0,0,31208,0\n+,30762,0,0,0,0,0,29321,60518,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3209,3237,\n+12490,22663,0,0,0,18789,31464,16391,0,0,0,0,0,0,0,0,0,0,0,20646,0,0,0,27238,0,0,\n+0,0,0,15940,4488,6951,0,0,0,46342,0,0,0,0,0,0,0,0,0,28965,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,20584,3367,0,25350,0,0,0,0,0,0,0,0,0,0,0,0,1814,0,0,0,0,0,0,0,0,0,0,17125,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,55943,0,0,0,0,0,24133,0,0,0,0,0,0,0,0,0,0,0,0,2929\n+,0,0,50086,0,2918,25356,30052,115,11846,0,0,0,0,3056,0,0,0,0,17639,239,19815,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36806,0,0,0,0,0,0,0,0,0,0,0,0,0,21479,0,0,0,0,0,\n+28420,11786,4772,0,0,3368,36295,0,31463,0,0,14665,996,0,20582,0,0,0,9988,0,23685\n+,0,0,0,52551,0,0,0,0,0,0,0,7556,0,0,0,0,0,0,0,1895,2186,0,0,0,0,0,27755,25447,0,\n+0,0,0,31052,63270,0,0,0,0,0,0,0,36742,0,24804,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,31048,0,0,0,0,0,0,0,0,0,21290,2276,0,0,0,0,26475,0,0,0,0,0,0,0,0,0\n+,0,15332,0,0,0,0,0,0,0,0,3176,19431,0,0,0,0,0,0,0,62726,0,0,0,25380,0,0,27883,\n+1316,0,0,7724,3015,0,0,0,0,6697,0,0,47910,0,0,0,0,0,0,0,0,0,3141,0,0,0,14820,0,0\n+,0,0,9326,0,0,0,0,0,0,0,0,0,0,31493,0,0,0,0,0,6566,0,0,0,0,0,0,6569,1348,0,25638\n+,0,0,0,0,0,20324,0,0,17067,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11876,0,41030,0,0,0,26405\n+,0,0,0,0,0,0,0,0,0,11431,28137,14950,0,10151,0,0,0,0,0,0,0,29574,0,0,0,0,27176,\n+57446,0,0,0,0,28650,57574,1387,0,0,0,0,0,0,0,0,0,0,58247,0,0,0,0,0,0,0,16805,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3526,0,15781,0,5572,13352,0,0,0,0,0,18665\n+,23463,0,0,0,0,0,0,15405,6885,0,0,0,0,15272,0,0,0,0,0,0,0,0,9861,0,0,0,0,0,0,0,0\n+,9512,4037,0,0,11563,49639,0,0,0,0,0,0,27880,57830,0,0,0,0,0,41831,0,21924,0,0,0\n+,0,0,0,0,25509,0,27462,0,18085,0,0,0,0,0,0,0,0,0,0,0,0,13898,8068,26441,0,0,0,0,\n+0,0,25316,0,0,0,0,16298,7397,5706,19239,0,0,0,0,0,0,0,0,1392,50919,0,0,0,0,0,\n+53863,0,0,0,0,1451,0,0,0,0,0,0,0,0,0,0,35847,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,17801,15813,0,12740,0,0,0,32967,0,0,0,0,0,0,5389,0,0,0,0,0,0,0,0,0,0,31143,0,\n+20548,0,0,0,0,0,0,0,0,0,51686,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+12109,19015,0,34983,0,21732,3600,0,0,0,0,47750,17288,43975,22857,47559,0,0,0,0,\n+26408,48358,0,0,0,0,0,0,0,0,0,0,0,0,0,30470,0,0,23560,4581,0,22404,0,49286,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,49831,0,0,0,27525,31691,7,0,0,25835,0,0,0,0,0,\n+4201,16485,0,20676,0,0,0,0,3753,23303,16264,3878,0,0,0,0,0,0,11434,0,0,0,0,0,0,\n+7589,0,0,0,0,0,0,0,0,0,57095,0,0,0,0,0,0,0,0,0,0,0,22820,11146,49158,0,23623,0,0\n+,0,0,0,0,0,13893,0,0,0,0,0,0,11722,60071,1258,0,0,0,0,0,0,18564,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,27945,0,0,0,0,5479,0,20006,17608,3431,10988,30180,0,0,0,0,0,0,0,\n+24581,14,0,0,0,0,0,0,25572,0,0,0,28612,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53543,0\n+,0,0,0,0,0,0,0,0,0,0,33670,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8710,0,14116,0,0,116,\n+292,0,0,0,37831,0,43078,0,0,0,0,0,0,0,0,21832,0,0,32134,783,0,0,30982,0,0,0,68,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5932,0,0,0,18505,\n+15175,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3630,16965,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,17797,0,0,0,0,0,0,520,42150,0,0,3122,0,0,0,22506,0,0,0,0,0,0,0,0,28550,0,\n+0,0,50278,0,0,13641,5958,0,35238,0,0,0,0,0,0,0,0,29993,18724,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,20619,9319,0,0,0,0,23977,0,5193,0,0,12196,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,24390,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20105,677,0,0,0,0\n+,0,0,0,0,29419,0,0,0,0,0,0,0,0,0,20266,0,0,0,0,10631,0,0,0,0,0,0,0,0,0,47655,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26628,12744,0,20648,0,0,0,432,0,0\n+,0,0,0,0,0,0,0,0,646,0,25604,0,0,0,0,0,0,0,0,0,0,0,0,0,63782,0,0,0,0,24616,0,0,0\n+,21291,0,0,0,0,0,0,0,0,0,0,45638,0,0,0,0,1931,0,0,0,20521,59975,0,20614,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,56231,0,0,0,0,0,29991,0,52871,0,20934,0,0,0,0,0,0,0,16871,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,7237,0,0,0,0,0,47558,0,0,0,0,0,0,0,0,0,0,0,10406,0,0,0\n+,0,0,0,0,43046,0,0,2930,0,12936,0,0,0,0,0,0,0,0,0,0,0,0,31141,0,0,0,0,0,0,0,\n+37639,0,17572,0,0,0,0,0,0,0,0,0,0,31240,0,0,0,0,0,688,0,0,0,0,0,1648,0,0,0,0,\n+10055,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,6345,199,0,34982,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,56839,0,0,0,0,0,48902,0,13412,0,0,0,0,0,0,0,0,2441,4420,0\n+,0,0,0,20428,933,0,0,0,0,0,0,0,45383,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,54726,0,0,0,0,0,0,0,0,0,0,0,0,17036,741,0,0,0,0,0,0,0,27589,0,0,30282\n+,18950,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2248,0,0,0,0,0,0,0,0,0,25993,0,0,0,\n+2443,0,0,31622,0,14150,0,0,0,28679,0,0,0,0,0,0,15464,0,0,0,0,54694,0,0,0,0,0,0,\n+3827,0,0,0,3756,0,9897,0,0,0,0,0,19082,31239,0,0,0,0,0,0,0,0,0,0,0,24580,0,0,0,0\n+,0,0,0,0,0,16580,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27625,0,0,0,784,4647,32652,0,0,\n+63494,0,0,0,0,0,0,0,21062,0,0,0,0,0,0,0,0,0,0,3404,58470,0,32325,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,18634,2789,0,0,0,0,0,0,0,8548,0,0,0,22501,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,15881,0,0,0,0,35879,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7978,17956,0,0,0,\n+0,0,0,0,24324,0,0,4937,0,0,0,8168,0,13420,10340,0,0,0,0,0,11780,0,0,0,0,0,0,0,0,\n+0,0,16712,0,0,0,0,0,0,0,17640,17991,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,2953,0,0,0,0,0,0,0,9100,16806,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30667,0,0,\n+19013,0,0,0,0,0,0,205,15334,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1969,0,0,0,0,0,0,0,26248\n+,52518,0,49798,0,0,0,0,0,0,0,9668,0,0,0,0,0,4742,0,0,21641,0,0,0,0,0,0,53574,0,0\n+,0,0,0,0,5707,0,0,0,0,0,0,0,3018,12454,0,0,0,0,2920,262,0,0,0,0,0,0,0,0,0,0,3593\n+,0,0,0,0,0,0,0,0,0,0,23910,0,0,0,0,0,0,0,55879,0,0,0,0,0,775,0,43270,5066,48967,\n+0,0,22986,4165,8971,44838,0,0,0,0,0,62279,272,0,0,0,0,51430,0,0,0,0,0,0,28234,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13349,0,0,0,51111,20265,13861,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,585,7494,0,0,0,0,0,0,0,0,21768,62407,0,0,0,0,7979,166,0,\n+0,0,0,0,0,0,0,0,38918,0,56742,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16296,5767,0,0,0,0,0,0\n+,0,32068,0,0,0,0,0,0,0,0,0,0,0,0,0,29796,0,0,0,0,0,0,0,0,23916,30183,0,58791,0,0\n+,0,0,0,0,0,20518,0,0,0,0,8969,0,0,0,183,0,0,0,0,0,2314,17445,0,0,0,0,0,0,0,0,0,\n+23748,0,0,8139,4839,27914,0,0,0,0,0,0,0,0,0,0,0,0,29478,0,0,16552,26663,0,53767,\n+0,0,13960,8039,18696,0,0,0,0,0,0,0,0,0,0,0,782,16005,0,0,0,0,0,0,0,0,6258,56806,\n+16456,12455,0,0,0,0,0,0,0,23780,0,0,0,0,0,0,9355,0,0,0,7273,41063,24780,57766,0,\n+0,0,0,0,0,0,0,0,0,3820,2597,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29225,61126,0,0,0,58439,\n+15691,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,37190,22408,967,0,0,0,\n+23078,26858,0,0,0,19753,0,0,0,0,0,0,0,0,0,5416,13702,0,0,0,0,0,52742,20394,38567\n+,0,0,0,51079,0,0,136,8516,0,0,0,0,0,0,0,0,0,0,0,27588,0,0,0,0,0,0,0,0,0,0,531,0,\n+0,0,0,0,0,0,0,0,8936,5031,12520,19334,0,0,22827,30247,28074,31140,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,27497,18148,20104,59079,0,0,0,0,0,0,0,0,0,24389,0,0,6125,0,0,0,0,\n+9541,0,0,24553,29095,0,0,0,0,0,0,0,25444,0,0,9643,0,0,63047,0,0,0,0,0,0,0,0,0,\n+39558,0,0,0,0,0,0,20620,11815,499,0,5128,2278,0,0,0,0,0,46310,0,0,0,0,0,0,0,0,\n+23530,40166,2440,0,0,0,0,0,0,0,0,0,0,15174,0,0,0,0,0,0,0,0,0,0,26922,0,0,0,0,0,0\n+,0,0,0,0,26758,0,0,0,0,0,51911,0,0,23532,0,0,0,0,51238,25737,44486,12622,0,0,0,0\n+,0,0,3078,0,9253,0,0,1128,22023,0,0,0,21350,0,16420,0,0,0,0,0,0,0,65094,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22532,0,48774,0,34503,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,9797,0,0,0,0,0,0,0,13797,0,38279,0,0,1738,0,489,46343,0,45382,0,0,0,0,0,0,\n+0,0,0,29030,0,0,0,0,0,0,6220,56550,0,0,0,0,0,26885,0,28806,0,0,0,0,0,0,0,0,0,0,0\n+,45958,0,0,0,0,20553,49927,0,0,0,0,0,0,3019,12358,0,0,0,0,0,0,0,0,0,0,26571,\n+13319,0,0,653,23399,0,0,0,0,0,0,0,0,22316,0,0,21188,0,0,0,0,0,0,0,0,0,27556,0,0,\n+0,0,0,0,0,27878,21483,27653,0,29701,237,0,10632,0,0,0,0,33766,0,0,0,0,0,0,31563,\n+0,0,0,0,0,1416,2439,0,0,0,0,0,0,0,0,0,0,9611,0,0,0,0,0,0,0,5611,16581,26601,\n+35462,0,0,0,26756,0,59271,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26984,57734,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,7882,0,0,0,19528,6469,0,0,1161,0,0,0,7688,20935,425,0,\n+0,0,0,0,0,0,0,12519,0,12902,0,0,0,0,0,0,0,0,0,0,2411,0,11725,26086,0,0,20201,0,0\n+,0,0,0,0,0,0,11045,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30471,0,0,0,0,0,0,0,0,0,0,0,\n+21541,1141,21190,0,9188,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,1093,0,0,0,0,0,0,0,0,\n+4842,0,13672,0,0,12230,0,0,0,10532,0,0,8937,0,0,0,0,0,0,0,0,0,0,28996,0,0,11720,\n+26982,0,46182,0,43911,31754,0,1160,3940,0,20772,0,0,0,0,0,24549,0,32582,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,31845,0,0,0,0,0,0,0,2310,11788,0,0,43047,0,0,0,18853,0\n+,0,0,0,0,0,0,0,0,63622,0,0,7048,17318,0,0,0,21957,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,1039,6279,0,0,0,0,0,0,0,0,0,0,0,0,0,12197,0,0,0,0,0,0,0,0,0,\n+46470,0,0,24,19719,0,0,0,0,0,0,0,0,0,39335,0,0,0,0,0,0,0,0,0,0,21353,3846,0,0,0,\n+0,0,0,0,36679,0,0,0,0,0,0,0,0,0,0,0,11268,0,0,0,0,0,9382,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,29926,0,33606,0,4708,2828,0,0,29543,0,0,0,0,0,29893,0,0,0,0,0,0,0,0,3663,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10920,7111,0,0,0,0,0,0,0,0,0,0\n+,9384,0,0,0,0,0,0,0,0,0,0,0,0,20388,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,37094,0,0,0,\n+27110,0,0,0,0,0,0,21865,0,27753,30214,0,0,0,0,0,57895,0,0,0,0,0,0,0,0,0,0,12648,\n+5446,0,0,0,0,0,0,0,0,0,0,19784,17124,0,52007,0,0,0,0,0,0,0,0,758,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,24900,0,0,0,0,0,1476,0,65031,0,0,1205,46663,0,30023,11625,\n+1094,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10058,0,0,0,0,0,0,28455,0,0,0,0,0,0,0,0,0,0,0,\n+14788,0,0,0,0,16808,0,0,742,0,0,0,0,0,0,0,0,0,0,0,21636,0,0,0,0,0,0,0,0,0,0,0,0,\n+15944,23207,0,0,0,0,247,0,0,0,0,24743,0,0,0,5252,0,0,0,0,0,0,0,0,29961,18660,\n+21099,46791,0,7045,0,0,0,0,25707,0,0,17412,3828,0,0,0,0,0,0,0,0,0,0,0,5803,5637,\n+0,38151,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,60103,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,853,0,0,0,0,0,0,30215,0,0,0,0,0,0,0,8741,0,0,0,0,0,27366,0,0,0,0,171,\n+4070,0,0,0,0,0,0,0,0,24073,7366,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2184,5189,0,\n+20932,1545,4996,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7684,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6313,0,0,0,0,0,0,0,30826,0,0,0,0,0,0,\n+0,0,0,0,27463,0,0,0,0,0,0,0,0,0,0,21640,63303,0,0,3275,31111,0,0,0,0,0,0,0,11556\n+,0,14756,0,0,0,15108,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23914,28966,0,0,0,4965,0,0,0,0,\n+0,0,0,0,0,0,10216,5223,0,0,0,0,0,0,0,0,0,27142,0,0,1173,20198,0,0,0,0,0,56614,0,\n+0,0,0,0,4612,0,0,0,0,0,0,0,0,0,0,11822,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17769,7910,\n+0,0,31880,0,0,6055,0,0,0,0,0,0,0,0,0,0,8970,0,0,0,0,0,0,0,0,0,0,0,16840,23879,0,\n+0,11051,0,0,0,32552,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20842,13701,0,0,0,37191,7373,\n+10471,17482,25348,0,0,0,38502,0,0,0,0,0,0,0,0,0,21509,6058,0,0,0,0,0,0,3173,0,0,\n+0,9543,0,0,0,0,0,0,17768,12708,0,0,0,0,0,37030,0,0,0,0,0,0,0,0,0,0,12748,48743,0\n+,11718,0,0,25194,0,0,0,9033,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5028,0,30118,0,0,0,0,0,\n+42759,0,0,3720,0,0,0,0,0,0,25190,0,0,0,0,0,0,0,0,0,0,5450,5125,0,58086,0,0,0,0,0\n+,27716,0,0,0,0,0,0,0,0,0,22052,0,0,0,0,26249,0,15947,3460,0,0,0,35814,0,0,0,7813\n+,19500,32167,0,18597,0,0,0,0,0,28644,0,0,0,60743,0,0,0,0,0,29636,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,17220,15885,9414,9642,0,0,0,593,0,0,24228,0,0,0,0,0,40422,0,26244,0,\n+23109,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64902,0,0,0,0,3979,60007,0,0,0,28199\n+,0,0,0,43142,0,0,0,0,0,0,0,29158,0,30532,0,0,0,0,13256,0,0,0,0,16549,0,0,0,0,0,\n+26116,0,0,0,0,0,0,0,0,22825,0,0,0,0,0,0,0,1065,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,18985,4805,0,0,0,0,0,17702,0,0,0,0,0,0,0,0,0,0,3468,0,0,0,0,13447,0,0,0\n+,0,0,0,0,0,0,0,0,56871,0,0,1776,15780,0,0,2603,0,10280,31366,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,11592,3591,0,2372,0,0,0,0,0,0,0,20004,0,0,0,0,0,0,12072,518,0,0,1960,\n+8999,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7178,32999,0,0,0,0,0,0,1641,0,0,0,0,0,0,0,6764,\n+9893,490,4005,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25258,5541,0,14053,306,20743,0,0,\n+9422,0,0,0,0,0,0,0,11977,260,0,35175,0,0,0,0,0,0,0,18405,0,0,0,16582,0,0,0,22470\n+,0,0,0,0,0,0,2792,0,0,0,14026,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14858,3909,0,0,0\n+,57671,0,0,0,0,0,0,15979,0,0,0,2794,15239,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26884,\n+9070,0,0,0,0,51846,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19499,37127,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,19205,10350,11910,0,0,0,0,15083,23108,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,169,0,0,0,0,0,0,0,0,0,0,0,15274,41735,0,56774,0,0,2825,0,14025,\n+389,0,0,0,0,0,0,0,0,21482,31910,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20456,710,0,0,25032,\n+21797,0,0,0,0,0,0,0,0,0,0,32427,21252,0,30150,0,43174,0,0,0,0,0,0,0,0,0,0,0,0,\n+11403,0,0,1029,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6892,9252,0,63206,\n+3496,14406,0,0,0,0,0,0,0,0,0,0,22568,0,0,21253,0,0,0,0,0,0,0,39623,0,0,10189,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,30729,59910,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3305,0,0,0,0,0,0,\n+0,0,0,7660,24871,0,838,0,0,0,0,0,0,0,0,0,0,0,0,12013,13252,0,551,0,0,0,43207,0,\n+30567,0,0,0,0,0,0,0,0,28394,30724,0,0,0,0,0,0,0,0,0,0,22665,22725,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,29414,0,0,0,0,16074,8966,245,1445,0,0,0,0,24872,0,0,0,0,\n+13124,0,35527,0,0,0,0,0,0,13259,10917,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+25191,0,0,0,13956,0,0,0,0,0,0,0,54631,19625,12070,3083,0,0,0,0,14436,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,21766,0,15463,29322,0,0,0,0,0,0,29990,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,23653,0,0,0,0,0,0,0,0,2643,0,0,21223,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,4114,0,0,0,0,0,0,0,0,34790,0,0,0,0,0,0,0,16103,0,0,0,0,0,0,297,3620,3338,\n+10372,0,14727,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29924,22473,13895,\n+15529,32455,30378,13540,0,28807,0,0,0,0,0,0,0,64582,18380,0,0,0,0,0,0,0,0,0,0,0,\n+0,38598,0,0,0,0,0,0,0,0,1236,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32710,0,0,0,0,4590,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64935,0,0,0,0,0,0,0,0,0,0,0,0,16744,0,0,\n+0,0,0,0,20005,0,0,13608,1191,0,0,0,62183,0,0,0,0,0,24484,0,0,0,0,0,0,0,0,0,0,\n+17643,0,0,0,0,0,0,0,0,0,0,0,0,5380,0,0,32328,0,0,63814,0,0,0,2919,0,0,0,0,17034,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,60295,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,7690,486,0,0,0,39270,0,49094,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12555,0,0,0,0,0,0,0,0\n+,0,0,0,0,20967,17993,12647,0,0,0,16036,32616,0,0,0,0,16294,8555,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35174,0,0,0,0,0,0,30346,0,0,0,0,0,0,0,\n+14797,3652,0,0,8268,12934,0,54950,0,0,0,0,2632,33959,0,23175,0,0,0,0,0,36262,0,0\n+,0,0,0,0,32684,26918,0,32676,0,0,0,0,0,0,0,0,0,0,15625,11943,1206,0,0,0,0,18052,\n+0,0,0,0,0,16422,0,0,0,26404,0,0,28777,0,0,24902,0,0,408,45351,0,35719,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,3658,17446,0,165,0,0,0,0,0,0,0,6151,0,0,24424,0,0,0,0,0,0,0,\n+24170,24293,0,0,0,0,0,0,0,0,0,11847,0,39591,0,0,0,0,0,0,9549,2788,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1010,0,0,0,0,0,0,26055,31724,0,24233,\n+1828,0,0,0,0,0,0,0,0,0,17284,0,0,0,0,19464,0,0,0,0,0,0,0,0,32452,0,0,0,28871,0,0\n+,0,0,17704,53383,0,0,0,0,0,0,0,0,0,17892,1938,0,0,0,0,0,16362,0,0,21605,0,0,5003\n+,0,0,0,0,0,0,22693,0,22342,0,0,0,55846,0,0,0,0,0,0,0,0,0,22853,0,0,0,0,0,0,0,0,\n+6600,263,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24836,0,0,0,0,0,0,0,0,0,\n+40711,0,0,0,0,0,33894,0,0,0,0,0,0,13000,0,0,0,0,0,0,0,0,0,0,30308,0,0,0,0,0,0,\n+5386,0,0,0,0,0,0,27844,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17740,0,0,0,0\n+,25093,29064,0,0,0,0,0,0,0,12680,11462,0,0,0,0,0,0,0,0,84,7303,0,0,0,0,0,0,0,0,0\n+,0,0,27044,457,0,22924,58246,19016,0,2606,45703,0,5157,0,25028,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,2065,0,0,0,0,0,31946,0,0,0,0,0,0,0,0,0,0,0,0,33382,0,\n+47878,0,0,0,0,0,0,0,0,25004,0,0,0,0,0,0,0,26153,35654,0,58055,30668,0,0,0,0,\n+25988,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4456,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,7560,20583,0,0,0,0,0,0,0,0,0,37510,0,0,0,0,0,0,0,0,0,42822,0,0,0,0,0,0,0,0,\n+0,0,0,1733,0,0,0,8196,0,0,11241,0,30572,60326,0,15013,0,0,0,40646,0,23812,0,\n+10022,0,0,0,0,0,0,0,0,12874,31015,0,0,0,0,0,0,1608,0,0,0,0,18308,0,0,0,0,27114,0\n+,0,0,0,0,0,0,7944,1382,0,11813,0,0,0,0,0,0,0,0,0,0,0,0,0,24517,0,11621,0,0,0,0,0\n+,0,0,0,0,0,0,21702,0,0,13100,8262,2644,7973,0,0,0,0,0,0,0,0,0,0,0,0,1033,12581,0\n+,25221,0,0,0,40998,16301,62983,0,0,0,0,1263,9318,0,0,0,18854,0,0,1741,33895,0,0,\n+0,0,0,0,26377,0,0,0,0,0,0,0,0,0,0,32165,0,51143,0,0,0,0,0,29412,0,0,0,0,0,0,0,0,\n+1674,4230,0,0,0,0,0,10502,0,0,0,0,5545,0,0,0,0,0,2099,45158,0,0,0,0,0,0,0,0,0,0,\n+14157,0,26955,0,0,0,0,0,0,0,0,0,17096,0,0,0,0,0,0,0,0,0,0,0,0,0,27050,6726,0,0,0\n+,0,0,0,0,0,28554,0,0,7142,0,0,0,0,16936,0,0,0,25833,0,4399,6980,0,46214,0,0,0,0,\n+0,10630,21164,0,0,0,0,0,0,0,2446,48551,0,0,0,0,0,0,0,0,0,0,0,13381,0,0,0,0,0,0,0\n+,0,15400,12135,0,0,0,0,0,4774,586,0,0,0,0,0,0,0,0,23751,9736,4548,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25577,29607,6250,1637,0,0,0,0,\n+22024,0,0,0,0,22308,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,37414,24044,0,0,0,14474,29735,\n+0,7077,0,45990,0,0,0,0,30568,40039,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+6150,0,4228,0,0,0,0,0,27687,0,0,0,0,0,0,0,24548,21513,1350,0,0,0,33607,0,0,0,0,0\n+,0,0,0,11784,1414,0,0,0,0,0,0,0,18244,940,0,0,0,0,0,0,7270,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,16709,0,0,0,0,0,0,0,48935,0,0,0,0,0,0,23660,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,53350,0,0,0,0,0,0,4236,16358,0,4422,6665,32644,0,0,744,18084,0,11014,0,0,0,0,0,\n+29508,0,0,0,0,0,0,0,7686,0,0,13289,5478,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,12872,0,0,24134,1005,22916,0,31429,23400,0,0,0,0,0,0,0,28424,0,0,0,\n+25706,27109,0,0,26345,0,0,0,0,0,0,25126,0,0,88,0,0,0,0,0,0,0,17032,0,0,21799,0,0\n+,10060,0,12296,21892,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20777,14311,0,58182,\n+32232,0,10282,0,2121,11527,0,0,0,12325,0,0,0,0,0,0,0,28804,2344,8133,0,0,0,0,\n+21864,62695,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2771,0,0,\n+23204,0,0,0,0,0,6278,0,0,0,0,0,26597,0,0,0,0,23144,0,0,0,0,0,31816,20070,0,0,0,0\n+,0,0,0,0,0,0,24456,2118,0,0,0,0,6570,1156,0,0,0,0,0,0,0,30406,0,0,0,28388,3572,0\n+,0,26599,12426,5286,0,0,0,0,0,4967,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24970,24167,0,0,0\n+,0,28745,4678,0,0,0,0,0,0,0,1444,236,0,0,0,0,0,0,0,0,19428,0,0,0,0,0,0,2092,0,0,\n+0,0,0,0,0,0,0,2827,0,0,0,0,0,19881,19204,0,11749,0,0,0,0,0,0,0,17958,0,17894,0,\n+18726,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9190,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,21510,5033,0,0,0,0,22855,0,0,0,0,0,14598,0,29605,0,0,0,0,0,0,0,0,\n+617,0,0,0,0,47142,0,0,0,0,0,0,0,0,0,0,3627,0,0,0,0,0,0,0,0,0,0,0,0,0,2225,14823,\n+0,0,2637,6182,78,15078,0,0,0,0,20264,0,0,0,0,0,0,36743,4140,44551,17352,25703,0,\n+0,0,0,0,0,0,0,0,0,0,0,14024,0,0,0,0,0,0,28004,0,0,0,0,0,7588,0,0,0,0,0,0,0,2087,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18028,0,0,0,300,14212,0,0,1386,40327,0,0,0,0\n+,0,0,31082,0,0,22374,0,0,0,0,0,35718,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+26532,7756,0,0,18982,0,0,0,0,0,0,0,0,6440,1159,7180,0,0,0,0,0,0,45766,0,57798,0,\n+16740,0,0,6802,60454,0,0,0,26470,0,0,0,0,0,65382,4362,7750,0,0,0,0,0,0,9096,4743\n+,334,0,0,0,0,0,0,39974,0,0,0,25828,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3027,0,0,\n+0,15816,0,0,0,0,0,0,0,0,48327,0,0,0,0,0,0,0,0,0,0,16168,41799,0,0,24458,8581,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12292,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,54503,0,0,0,0,5097,30852,18664,0,0,0,0,0,0,16484,0,0,27337,0,0,0,\n+0,0,0,0,0,0,0,0,0,35942,0,0,0,0,0,0,0,4356,0,0,0,0,0,57030,0,0,1417,41191,0,0,0,\n+0,0,23429,0,0,0,0,10024,21735,0,0,10126,0,0,0,0,19046,0,0,0,0,0,0,24105,4710,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4394,0,0,0,0,13253,0,56391,0,0,0,0,0,0,0,0,0,0,\n+0,19174,0,0,0,0,0,0,0,0,0,55974,0,0,0,52070,0,15620,0,0,0,0,0,2660,0,0,0,0,21644\n+,0,0,52455,0,0,0,0,0,0,0,0,0,8902,0,0,0,0,0,0,3116,0,464,34726,0,0,0,0,0,0,25003\n+,12423,0,27172,1896,7335,0,0,0,0,0,35686,0,0,0,0,3472,0,0,0,0,22406,0,0,0,0,0,0,\n+0,0,0,45254,0,0,0,0,0,0,0,0,0,0,0,0,0,21124,23594,33127,0,0,0,0,0,0,16684,22087,\n+0,0,0,0,0,0,0,0,0,0,0,0,8714,0,0,0,0,0,0,0,0,0,0,55814,0,0,0,0,0,0,4109,23460,0,\n+0,8874,0,0,0,0,0,0,0,0,0,147,0,0,0,0,0,0,0,0,0,0,0,0,0,29960,63398,1302,0,0,0,0,\n+0,0,0,0,24806,0,0,0,0,0,0,0,0,0,9799,0,0,0,0,0,0,0,31333,0,0,0,0,0,19557,0,0,0,0\n+,0,5701,0,0,0,63014,0,0,0,0,0,0,0,21254,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12484,0,0,\n+0,48326,0,0,0,0,0,0,0,0,0,0,0,15783,0,0,1202,0,0,0,0,23174,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,3086,49191,0,0,5387,15141,0,0,0,3365,0,0,0,0,20076,14021,\n+0,0,0,0,0,0,0,0,0,0,376,40198,0,0,0,52039,0,24932,0,0,0,0,808,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,9860,0,0,0,0,0,23719,0,21476,0,0,0,0,20776,4807,0,0,3177,16678,0,0,110\n+,10853,0,0,0,17382,0,0,0,0,0,0,0,0,0,43462,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,7500,4966,0,0,0,0,0,0,0,52102,0,24516,0,0,0,0,0,0,0,0,0,0,0,0,0,26535,0,0\n+,0,46247,0,0,0,15557,0,0,0,0,76,52327,0,0,0,0,17866,0,0,0,0,0,0,0,0,0,0,46758,0,\n+0,0,0,0,19173,0,0,0,0,0,0,0,0,0,44038,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2985,0\n+,0,0,0,0,0,14310,0,0,2125,45831,0,0,0,0,0,0,9838,0,13227,19492,0,0,0,29764,0,0,0\n+,0,686,30053,0,0,0,0,0,30789,139,20837,0,0,0,0,502,18533,0,0,0,0,0,19111,0,0,0,0\n+,0,31396,0,0,0,17444,0,0,0,0,0,0,0,49862,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25610,550,0\n+,0,561,0,29034,0,0,0,3528,0,0,0,1715,14661,18,63463,0,0,0,0,0,0,0,0,0,0,14186,0,\n+0,0,0,0,0,0,0,0,0,0,29578,59014,0,39430,0,0,0,0,2250,16612,0,31780,0,0,0,0,0,0,\n+462,16967,0,29029,0,0,0,0,0,23462,0,0,0,0,0,0,0,0,1768,0,6025,16998,1804,0,0,\n+54182,0,0,0,0,0,0,0,0,14124,0,6154,29702,0,0,0,0,0,7716,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,48807,0,8292,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16389,5933,0,\n+14857,51303,0,0,0,0,0,0,0,0,0,0,0,35623,9097,23047,0,0,23112,0,0,0,0,0,438,0,0,0\n+,0,0,0,0,151,9254,1390,0,0,0,0,0,0,54215,0,0,0,0,6187,0,0,0,0,13095,0,0,0,0,0,0,\n+0,0,0,0,0,0,9866,0,0,59622,0,0,0,0,0,0,0,0,0,25286,0,0,23848,32069,0,0,0,0,0,0,0\n+,0,0,9255,2187,15270,437,0,0,0,0,0,0,0,0,0,0,19493,0,0,0,0,0,0,0,0,0,0,0,11748,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16902,0,0,0,0,0,0,0,0,0,22212,1865,17543,0,\n+0,0,0,0,0,21996,0,0,0,0,55975,0,0,0,0,0,0,0,0,32138,21156,0,0,0,0,0,0,14249,0,0,\n+0,2388,0,0,0,0,6823,0,0,0,0,0,0,0,0,0,0,0,0,0,26694,0,0,6059,53511,0,0,0,0,0,0,0\n+,49542,6159,0,0,0,0,0,0,0,0,0,0,0,0,0,1036,24036,0,2501,0,0,0,0,0,0,17419,51271,\n+3377,15142,0,0,0,0,0,0,5007,62374,0,56935,0,0,0,0,0,0,0,0,0,0,0,24422,0,0,0,0,0,\n+0,0,0,942,0,0,0,0,0,0,0,0,0,0,28263,0,0,0,0,0,0,0,15622,0,19749,0,0,1611,0,22219\n+,48583,25129,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17476,0,0,0,0,0,0,0,0,0,0,\n+721,0,0,0,0,32518,0,0,0,18469,0,0,0,0,0,0,5896,29927,3657,23046,0,0,3214,0,0,0,0\n+,0,0,0,0,0,112,0,0,0,0,0,3048,455,0,31012,0,0,0,0,0,0,0,23270,0,32677,0,0,0,0,0,\n+38086,0,0,0,0,0,0,0,0,0,0,0,0,0,4900,0,0,0,0,0,0,0,0,0,25541,0,18788,0,0,22248,\n+1351,0,61734,4524,30629,0,14887,242,29063,0,0,14408,4741,0,0,0,37318,0,0,0,0,0,0\n+,0,0,0,0,0,0,8106,0,32107,0,0,0,0,0,0,0,0,0,0,0,1481,0,0,28132,0,25798,0,59783,0\n+,0,0,0,0,59078,0,0,0,23366,0,0,0,0,0,0,0,30887,0,0,0,0,16200,0,0,0,335,0,0,0,714\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,30730,9478,0,0,0,0,0,0,0,0,0,0,0,18790,0,0,0,0,663,0,\n+0,0,1034,31431,0,0,0,0,0,0,0,0,0,0,30120,0,0,0,0,13925,0,0,0,0,0,0,2280,13414,0,\n+0,0,0,0,0,22028,23687,3017,11047,0,0,21738,18630,0,0,0,0,0,0,0,30246,0,0,0,0,0,0\n+,0,0,0,0,0,0,17257,0,21896,63783,0,0,0,21094,0,18662,0,25700,0,22533,0,0,0,0,0,\n+6341,5800,11111,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15399,\n+12970,6501,0,0,3179,26438,0,0,0,0,0,0,0,15750,0,13062,0,0,0,0,0,0,0,0,0,0,142,0,\n+0,0,0,21284,11177,4391,0,0,0,0,19595,40647,0,0,0,0,0,11877,0,0,0,26439,0,0,0,0,\n+695,49126,27467,11972,0,0,0,0,0,0,9961,0,0,0,31722,62982,0,0,0,0,15817,52710,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24614,0,0,0,0,0,20550,0,0,5034,3942,0,0,0,\n+45927,0,0,0,0,0,0,0,0,0,0,2548,0,0,0,0,0,0,45606,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,3405,12582,15563,54087,0,0,0,0,0,0,0,0,0,0,0,0,24202,5893,0,0,0,\n+44230,0,0,0,5605,0,47782,0,32230,0,0,0,0,0,0,0,0,0,0,0,7014,0,0,0,0,16488,3175,0\n+,27237,0,0,0,0,0,40902,0,0,0,0,0,0,0,32004,31434,0,24392,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,29130,58214,0,0,0,0,0,0,29002,0,0,0,0,0,0,0,0,0,0,55366,0,0,0,0,0,0,0\n+,0,0,0,0,37926,0,0,0,0,0,0,0,0,1290,0,0,0,4713,0,0,0,0,0,0,0,0,0,0,0,0,0,20812,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1803,966,0,17700,0,0,654,19109,0,51655,0,0,0,0,0,\n+10470,1584,0,0,0,0,0,0,0,2506,0,0,25159,4303,0,0,0,395,15879,0,0,0,0,0,0,0,0,0,0\n+,1352,6535,0,19652,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4722,7909,0,0,0,0\n+,30152,0,0,64742,0,0,0,0,0,0,2153,9125,0,0,279,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,41894,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,1328,17030,0,0,0,0,0,0,0,54151,0,0,0,0,1775,54535,0,0,0,0,31624,0,0,0,\n+7150,0,0,0,0,0,0,0,1840,35943,0,0,0,0,0,56455,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+64486,0,0,0,51174,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4134\n+,0,0,0,0,0,0,0,0,0,0,0,17092,0,0,0,0,0,0,0,0,0,0,0,0,12,16134,19883,39943,10281,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44711,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+14125,2407,0,0,0,0,0,0,0,0,0,0,26921,0,0,0,0,0,22188,0,20810,10053,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29220,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28170,0,15208,0,0\n+,32517,5736,19271,3562,10534,0,0,0,59655,0,0,0,0,27084,60422,0,0,24969,0,0,0,\n+2636,0,0,0,0,26277,0,0,0,0,0,0,0,0,0,0,0,30596,3594,0,0,0,8362,14565,0,0,0,0,0,0\n+,10793,12326,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5906,59686,0,0,23081,517,0,15556,0,0,0,\n+8486,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19877\n+,0,0,0,0,0,0,0,0,7497,0,0,26085,0,0,23784,63591,6568,6310,0,0,0,0,0,0,0,0,0,\n+10054,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7018,14470,18858,0,5641,10660,0,0,0,0,0,0,0,\n+35526,1515,0,0,0,0,0,0,0,0,0,0,0,27656,0,0,9606,0,39590,0,0,0,0,0,0,0,0,0,0,0,\n+53926,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,232,4327,12649,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,20199,0,0,0,0,0,0,26730,0,0,0,19400,14695,0,31334,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19589,0,0,0,0,0,0,0,0,5064,11908,0,27333,0,\n+0,0,0,0,0,0,47751,0,0,0,26662,0,0,0,0,0,0,0,55655,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,6245,0,0,0,0,0,0,0,0,23368,63911,0,0,0,0,0,0,0,0,1974,0,0,0,0,0,0,0,\n+8520,24037,0,0,0,0,0,0,0,26279,0,0,0,22886,0,0,0,27782,0,30694,0,0,0,0,0,0,0,0,0\n+,0,0,33703,0,0,0,30405,0,34598,0,51047,0,0,0,0,1908,0,0,0,0,0,0,0,0,0,0,1511,\n+21897,0,0,0,0,0,0,51398,0,24870,0,32647,0,0,0,35015,0,0,0,0,0,0,0,11204,0,0,0,0,\n+0,0,7758,57991,0,0,0,30949,0,0,22,15140,9162,0,0,0,0,0,0,25540,20136,7108,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16427,10789,9805,0,0,0,0,0,0,0,0,0,4680,0,0,52679,\n+0,0,0,0,0,14884,0,0,0,16804,0,0,0,0,0,0,9578,5287,0,0,0,0,0,0,0,34054,0,0,0,0,0,\n+19076,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7627,55719,0,39463,14446,58374,0,0,0,0,23465,\n+15845,0,0,0,0,0,38534,0,0,0,17893,10922,0,7176,678,0,0,0,0,0,0,0,0,3113,46279,0,\n+0,0,0,0,0,0,23334,0,0,18088,23268,0,62342,0,0,0,16613,0,0,0,0,0,0,0,0,0,38182,0,\n+0,0,0,0,0,25292,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10344,71,6446,0,0,1893,0,0,\n+1106,0,28680,30756,0,41126,0,0,1492,0,15341,0,0,0,0,17575,0,21220,0,0,0,0,0,\n+25060,2088,21828,0,0,0,0,0,358,0,0,0,0,0,16708,0,0,0,1668,0,0,0,0,0,12260,0,0,0,\n+0,0,0,0,0,4078,0,0,0,0,0,12713,6215,0,0,20329,0,0,0,0,0,0,0,0,0,0,31204,0,0,0,0,\n+0,0,0,0,0,0,3732,0,1646,0,0,27460,0,34406,17128,14341,0,0,0,0,0,19527,0,0,0,0,0,\n+0,0,0,0,0,6120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8551,21546,10212,3020,\n+2951,0,17638,0,0,6985,44999,2218,8197,0,0,30472,63366,0,26660,0,0,0,0,0,0,0,0,0,\n+0,0,0,1265,0,0,0,0,0,0,0,2610,0,0,0,11278,20295,0,0,0,0,0,19780,0,0,0,0,0,0,2353\n+,10852,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5421,24292,0,0,0,0,0,0,0,0,0,0,0,0,0,34407,0,\n+0,0,0,0,0,15432,20774,0,0,0,0,0,0,0,0,12360,10757,0,0,0,33126,0,0,0,0,0,0,0,0,0,\n+0,0,29573,0,2343,0,0,0,0,0,63079,0,0,0,0,0,0,0,0,0,43015,0,16038,0,0,0,0,0,0,0,0\n+,1480,25573,0,0,0,0,0,0,0,8839,0,0,0,0,0,0,0,24645,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+5063,0,0,0,0,0,45830,0,0,0,0,0,0,0,0,0,0,823,0,0,64039,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,15300,0,0,0,0,0,0,2924,46759,6760,19268,0,0,0,0,0,0,0,0,0,34182,0,0,3977,18149,\n+0,0,0,32199,0,0,0,0,0,0,0,0,0,23524,25994,0,0,10343,0,0,0,9733,0,0,0,0,0,0,0,0,0\n+,4740,0,0,0,0,0,0,0,0,0,16741,0,0,4626,23367,0,0,31400,0,0,3557,0,0,4234,0,0,0,0\n+,0,0,28486,0,0,0,0,0,14213,0,57191,0,0,0,0,0,0,0,0,0,0,240,0,0,0,0,65318,29832,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29989,0,31846,0,0,8170,0,0,4421,27626,30884,0\n+,0,20204,0,0,0,0,44614,534,20868,0,0,0,0,0,0,0,0,0,0,0,0,0,28710,0,10277,0,0,0,0\n+,0,29511,0,19813,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27020,0,0,0,0,0,0,53094\n+,0,35207,0,0,0,37542,0,61766,8584,8037,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12488\n+,22757,0,0,0,0,0,0,0,0,0,0,0,0,0,23814,0,0,0,0,0,0,0,0,0,19973,0,0,0,63943,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36006,0,0,0,19012,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,8580,0,0,0,0,0,0,0,18021,0,0,0,0,0,0,0,0,80,1254,0,0,0,42630,0,0,0,0,0,\n+0,0,16262,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2124,25479,0,0,0,0,16873,0,0,0,0,3142,\n+0,0,18443,0,0,0,0,0,3917,0,8841,1190,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,20645,0,0,0,0,0,0,0,0,0,0,0,9284,0,0,24394,41351,0,0,0,42087,0,62566,0,0,0,0,\n+0,0,0,0,0,0,6728,4199,0,0,0,0,25515,0,1231,0,374,15623,0,29956,0,14118,0,0,0,0,0\n+,19047,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31718,0,0,0,0,0,0,0,0,0,0,0,20900,0,16743,0\n+,0,0,28902,0,0,0,0,0,0,0,0,0,0,0,0,2578,0,0,0,0,0,0,0,0,0,13838,0,0,10052,0,0,0,\n+0,7432,43783,17097,0,0,0,0,0,873,0,0,0,398,0,0,0,0,0,0,0,0,0,8459,23559,0,53030,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35750,0,4071,0,0,0,38662,0,41414,0,0,0,0,11656,0,0\n+,0,0,0,4011,42695,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25353,0,0,0,0,0,0,0,27177,22372,0,\n+0,0,0,0,30980,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46278,3976,12711\n+,0,0,0,0,0,0,0,0,0,0,0,20517,0,0,0,0,0,0,0,0,0,0,0,0,4072,11078,0,0,16553,2405,0\n+,0,0,0,0,0,0,0,2670,0,0,0,0,0,0,32998,0,0,0,0,0,0,0,47046,0,30533,0,0,11050,9734\n+,13129,0,0,0,0,23494,0,0,0,0,0,58310,0,0,0,57543,0,0,0,0,0,0,0,0,0,0,0,0,0,454,0\n+,0,0,0,0,0,5163,59687,2220,0,0,0,0,0,0,29510,0,0,0,0,0,0,0,0,0,0,0,17316,0,20069\n+,0,0,0,0,0,0,0,0,0,5319,0,0,0,0,0,0,0,0,0,27174,0,0,0,0,0,0,0,22949,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,19208,0,0,0,0,0,0,20933,0,0,6026,8742,0,0,0,17380,0,13127,2797,0\n+,0,30116,0,0,5963,8004,0,57126,0,0,0,0,0,42854,14792,30759,0,24964,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,16933,0,0,0,0,0,0,15176,40839,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+788,30341,0,0,0,0,21036,24102,0,0,0,0,30123,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+22597,31531,26789,0,59559,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9352,29863,0,0,0,0,0,0,0,0\n+,0,24551,0,0,0,0,0,0,0,20516,0,0,0,39462,3665,0,28265,0,8778,64262,0,57414,9132,\n+0,0,18276,0,0,0,0,0,0,0,0,0,0,26344,30725,524,19751,0,13796,0,0,0,0,0,0,0,0,0,0,\n+18155,0,12841,0,74,24998,13579,1061,0,64199,0,0,8776,0,0,60231,0,25412,0,0,0,\n+59143,0,0,0,0,0,0,14344,1510,0,0,0,38374,0,0,0,0,0,0,0,0,13353,0,0,0,0,0,0,0,0,0\n+,0,9446,0,0,0,0,0,0,0,32613,0,0,0,0,0,0,0,0,0,0,0,0,0,19844,0,0,0,0,14859,0,0,0,\n+0,6662,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14154,0,29770,0,0,0,0,0,\n+16520,2182,0,0,0,0,0,36102,3340,0,0,0,0,0,0,0,0,25189,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,15720,0,0,0,0,0,0,22758,0,0,304,0,3243,14117,0,0,0,0,0,0,0,0,0,0,5130,\n+12679,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21733,10441,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,36103,0,0,0,0,0,23590,0,57479,0,0,0,0,0,0,0,0,0,0,0,0,10824,\n+18372,0,0,0,0,0,35078,15722,12967,0,0,0,0,0,34599,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+53639,0,38630,0,0,0,0,0,0,31017,11333,0,0,0,0,19144,0,9513,0,0,0,0,0,0,0,0,56711\n+,24042,0,1197,0,0,58502,0,0,0,0,0,0,0,0,0,8230,6121,18628,0,0,0,0,0,0,25290,0,0,\n+0,0,0,1514,0,0,0,0,0,0,0,14378,9798,32363,0,0,0,0,0,9577,0,0,0,0,0,0,26788,0,0,0\n+,0,0,0,330,10533,0,0,0,0,0,42246,0,0,0,0,0,0,5074,21028,0,38119,0,0,0,0,0,0,248,\n+0,31176,62054,0,53287,0,0,0,0,271,0,0,0,0,0,0,0,0,0,0,0,0,0,9224,2117,0,0,0,0,\n+15818,5607,0,52582,0,0,0,0,0,0,0,0,18248,24005,23018,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+427,0,0,39910,0,0,7080,11399,0,0,0,0,0,0,0,0,0,0,22220,57894,0,0,0,0,0,0,0,13156\n+,0,1413,1007,0,0,0,0,21415,0,21543,0,0,0,0,0,0,0,0,0,41702,22538,9573,0,0,0,8806\n+,0,0,6920,56359,0,0,0,0,0,0,0,0,0,0,0,42215,0,0,13708,0,0,0,0,0,0,0,0,0,0,16453,\n+0,0,0,0,0,0,1582,1764,3282,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11653,0,0,0,0,12139,0,\n+29482,31076,1673,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40262,0,0,0,33862,0\n+,0,0,0,0,20996,0,0,0,0,0,4615,0,0,0,0,0,0,0,0,0,0,0,43943,333,19367,0,0,0,0,0,0,\n+0,26821,0,32389,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4936,11687,0,0,0,0,0,0,0,0,0,10885,0\n+,0,0,0,0,25926,0,0,0,0,0,0,15851,0,0,0,0,0,0,0,0,0,8360,0,17130,7942,0,11460,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,18150,14248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+22310,0,0,0,42758,0,0,0,0,0,0,0,0,29354,5574,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,31109,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11236,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,9156,0,0,1801,14023,0,0,0,0,0,62406,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+23620,0,0,0,0,0,0,0,0,0,0,31018,65510,0,0,0,0,0,0,0,26182,0,0,0,0,0,0,0,27717,0,\n+0,0,0,0,0,0,46950,0,0,0,0,0,0,0,0,0,0,0,0,0,31108,0,11366,0,0,0,3717,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8552,6054,3339,0,0,0,0,51622,0,\n+0,0,0,0,0,0,3718,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28358,0,2756,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,1462,0,0,27622,0,0,0,0,0,0,0,62502,14410,56743,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,12206,0,0,0,0,0,0,0,0,0,0,0,0,36550,0,38054,0,0,0,\n+21221,0,0,0,0,0,0,0,27077,0,0,16906,0,12587,12101,0,0,0,0,0,0,10414,28775,21769,\n+60167,0,56646,0,0,0,0,0,20740,0,0,0,0,0,0,5931,5351,0,65478,0,0,0,0,0,0,7977,\n+52647,0,4868,0,0,0,55463,0,0,0,0,0,32197,0,0,0,0,0,13445,0,0,0,26631,0,0,0,0,0,\n+11237,0,0,0,0,209,1285,0,0,1928,0,0,0,0,43334,23849,23172,0,0,0,0,0,0,0,0,24712,\n+62439,8811,3463,20457,0,0,0,0,0,0,0,0,0,16008,56263,0,0,0,0,0,0,0,0,0,0,0,60358,\n+22761,6565,0,0,30888,27686,0,0,0,17093,0,0,0,0,22121,0,0,0,7593,14182,0,28103,0,\n+0,0,0,0,45126,0,0,0,0,0,0,0,0,0,0,0,0,0,31844,0,0,0,0,0,0,0,0,0,0,0,0,0,18500,0,\n+0,0,0,28202,0,0,0,0,0,0,0,0,26308,0,29541,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+29572,0,0,0,21285,0,0,0,0,0,60839,0,0,0,0,0,30407,15949,2981,0,0,0,46439,0,0,0,0\n+,0,23911,26505,25222,12811,5895,0,6343,0,0,0,0,0,0,0,0,0,0,0,31815,0,0,0,0,0,0,0\n+,0,19688,10245,0,0,0,31301,26985,28964,0,0,0,0,0,0,0,0,27208,31172,0,0,0,0,216,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16292,0,0,0,0,0,8743,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,6438,0,0,0,33319,0,0,0,33286,0,0,0,0,0,0,0,0,0,22181,7499,24774,0,\n+10756,0,44775,724,0,25768,25669,24873,5349,25257,0,0,54566,0,0,0,0,0,0,0,0,0,0,0\n+,327,439,357,0,0,6536,8452,0,0,1802,0,0,61350,0,15045,0,0,0,0,0,0,0,0,0,0,0,\n+38343,0,0,0,0,0,0,0,0,0,0,32491,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+22885,0,0,32073,0,0,0,9546,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27748,0,0,23176,0,0,0\n+,0,0,0,0,0,0,0,0,0,24583,0,0,0,0,0,34118,0,0,0,0,2158,0,5586,30340,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,24452,0,0,0,0,2409,4390,0,24196,0,0,0,0,0,0,32264,26948,20587,0,0,0\n+,2155,0,0,0,0,0,0,0,0,0,0,0,4328,26276,0,0,0,0,0,0,0,0,23564,0,12458,11367,0,0,\n+25162,0,0,0,0,0,0,65414,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32966,0,0,0,\n+34662,0,0,0,0,0,39238,0,0,0,0,11400,10214,266,12452,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,15173,0,0,0,13668,0,13222,0,23364,0,0,0,0,0,11941,0,0,0,0,0,0,0,0,0,\n+25575,0,0,0,57383,0,0,0,10308,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,2865,9287,75,0,0,0,0,0,0,0,0,0,0,21508,22380,59526,0,0,0,23589,0,0,0,51590\n+,0,0,0,0,0,0,0,0,0,0,0,4645,3980,28295,0,0,0,0,0,12388,0,0,0,0,0,0,0,0,0,0,0,\n+21734,0,17607,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,41767,0,0,0,0,0,0,0,18436,0,0,0,0,0,\n+0,0,21958,0,19430,0,0,1204,0,0,0,0,0,0,0,0,0,3240,55239,0,0,0,0,0,30660,0,0,0,\n+28901,0,0,0,0,4716,0,0,0,0,0,0,0,0,0,0,0,11754,0,0,0,0,22086,0,22564,8749,0,0,\n+28391,0,0,0,0,0,0,0,0,0,0,0,2886,0,0,0,0,0,0,0,29062,0,0,0,0,0,0,0,40358,0,0,\n+15916,39526,0,13735,0,0,0,0,28938,0,407,4006,0,0,0,26916,0,0,0,0,0,27526,30280,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24586,0,24649,5126,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8684,0,0,0,0,0,0,0,23019,0,22377,18599,0\n+,0,0,0,0,0,0,0,0,0,27593,9735,0,20196,0,0,0,0,28168,48423,0,0,0,0,0,31399,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,13892,0,0,0,0,0,17606,0,0,15242,29767,26378,17701,0,0,\n+14472,0,4840,0,0,0,0,0,0,24708,0,9349,4330,0,0,0,0,0,0,0,16137,0,0,34854,0,0,0,0\n+,0,0,0,0,0,0,0,25063,0,0,0,0,0,0,6603,12583,0,0,0,0,0,0,0,0,7433,29188,0,0,0,0,0\n+,31270,0,0,22920,3143,0,0,0,0,0,23461,0,0,0,0,0,0,0,0,618,0,0,0,0,21381,0,11524,\n+0,0,0,0,0,0,21004,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,23239,0,0,0,0,0,0,0,0,0,0,0,\n+0,2313,0,0,40614,0,0,14825,0,0,0,0,0,0,46535,0,41190,7853,0,31656,0,0,0,0,0,0,0,\n+0,0,3433,5255,0,0,0,0,0,0,0,33958,0,0,0,0,72,15493,0,0,0,0,0,0,0,36070,0,0,0,0,0\n+,0,0,14724,0,0,0,0,0,29828,0,0,0,0,0,0,0,18822,20008,0,0,0,0,2438,2952,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,3342,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24420,0,19908,0,0,0,8101,0,\n+17479,0,0,3530,0,8202,29319,0,0,1132,6789,0,0,23881,0,0,0,4810,0,0,46918,0,0,0,\n+41574,0,0,0,0,0,0,0,0,0,48582,0,0,0,0,0,0,0,0,0,0,0,0,0,39334,0,0,0,26117,0,0,0,\n+0,0,0,5100,0,0,0,0,0,23496,27813,4045,54918,0,0,0,0,0,0,6473,7428,0,0,0,0,6792,0\n+,0,0,0,0,3560,32103,0,0,0,0,0,0,0,0,0,0,0,54790,0,0,6926,0,0,0,0,16518,0,0,0,0,0\n+,20806,0,0,0,0,1841,3174,0,0,0,0,9612,18374,0,0,0,0,32744,0,0,9671,0,59879,0,\n+23300,8073,0,0,14758,0,0,0,10342,0,0,0,0,0,0,24808,14759,0,0,0,0,0,0,5515,0,0,\n+14852,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2354,23271,0,32740,0,0,0,0,0,0,0,0\n+,0,0,18472,0,0,0,0,0,0,0,0,33190,0,0,0,0,0,0,0,0,8972,21669,0,0,0,0,0,0,0,0,0,0,\n+0,25574,0,0,0,0,5096,0,14283,55367,0,0,0,0,0,0,0,0,0,12644,0,0,0,0,4651,0,0,0,0,\n+0,0,0,661,0,0,13638,19466,0,0,0,0,0,31273,0,8010,0,0,0,0,0,3211,0,0,0,0,63430,0,\n+0,0,0,0,15237,0,0,0,0,0,0,19018,2437,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14312,0\n+,0,0,0,16836,0,0,471,35975,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,6023,0,0,0,0,0,0,0,0,11593,9639,0,0,0,55783,0,5700,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27908,0,26598,0,0,6667,6470,0,0,0,0,0,0,0,\n+62534,0,0,0,0,16522,27911,0,0,10025,7172,0,0,779,0,360,17477,0,0,0,61991,7752,\n+7717,1494,0,0,0,26569,40742,0,0,0,0,0,0,0,26406,10474,32196,0,0,0,0,0,50567,\n+16521,11716,0,0,0,0,0,55558,0,0,0,0,0,0,0,0,0,0,0,61926,0,26436,0,0,0,0,4459,\n+10598,0,0,0,0,0,0,0,0,0,0,0,9223,0,29318,0,0,0,0,0,60423,0,0,0,0,0,0,0,47078,0,\n+50246,0,12612,0,0,0,0,0,0,0,61799,0,55015,0,21060,7309,0,0,0,0,0,11976,0,0,0,0,\n+23527,0,0,0,0,0,0,10347,15942,0,34023,0,0,0,0,4969,0,0,0,0,0,0,0,0,28997,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36454,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+3466,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19716,\n+28872,0,0,0,0,0,22152,0,0,0,0,0,0,26342,0,0,0,9764,0,0,0,0,0,0,0,21798,0,0,0,0,\n+13,6853,32136,0,0,0,0,0,0,0,750,0,0,54502,0,0,0,0,0,0,0,0,0,46183,0,0,625,22854,\n+0,0,0,0,2061,23588,0,0,11049,56262,0,0,18538,1509,0,0,17258,4453,0,0,0,0,12429,0\n+,0,0,0,8102,0,0,0,0,0,0,8074,0,23852,0,0,0,0,0,0,0,0,0,0,0,16136,3428,0,27876,0,\n+0,0,7332,0,0,0,0,0,28900,0,0,2284,0,0,17573,201,1508,0,0,0,0,0,0,0,0,0,31365,\n+27688,22565,0,0,0,5159,0,0,0,0,4584,42599,0,0,0,44422,1068,23173,0,0,0,613,0,0,0\n+,12645,0,0,0,0,0,27076,6732,0,0,0,3913,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,22244,29992,15911,0,0,0,0,0,22982,0,0,0,0,0,0,0,50598,0,0\n+,0,0,0,0,5161,1574,0,0,0,0,0,0,0,0,0,19108,0,0,0,35014,0,0,0,25956,29067,0,0,0,0\n+,0,0,0,0,0,0,47079,0,0,0,0,0,0,0,0,0,0,1356,61927,0,0,0,64455,2122,64231,0,0,\n+18763,0,0,0,0,0,0,0,0,0,907,34471,0,0,0,39078,0,0,1995,0,0,0,0,0,0,0,0,0,0,56518\n+,0,0,0,0,0,0,0,0,0,0,0,0,822,0,15978,44423,0,0,3112,325,0,0,0,0,0,15397,0,0,0,0,\n+0,0,0,0,0,0,1193,4294,4968,15559,0,46150,0,0,0,0,0,18917,0,0,0,0,0,0,9928,37543,\n+0,0,0,0,13097,36999,0,0,0,15430,0,0,8424,29639,0,0,0,0,0,0,0,0,0,0,0,0,0,25734,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,40487,0,13284,0,11141,0,0,0,32388,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5298,57702,0,0,0,0,0,0,0,13060,0,0,0,0,0,0,\n+8233,42278,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36422,0,0,0,7972,0,0,0,\n+18437,0,0,0,0,7406,0,0,0,9225,0,0,0,0,0,0,0,0,0,13865,47591,18220,53703,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2796,0,0,0,0,0,24940,17223,0,0,0\n+,13221,0,0,0,0,0,0,0,0,0,0,15848,0,0,0,0,0,6122,1735,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,16968,18151,0,0,0,0,0,47494,0,0,0,0,0,0,26089,19494,0,0,0,0,0,15494,0,0\n+,0,0,0,0,0,0,0,0,28809,0,0,0,0,42727,0,55174,0,0,0,0,0,0,0,0,0,0,0,20485,0,0,0,0\n+,0,0,0,0,0,0,0,58598,0,0,0,0,0,0,0,0,0,0,0,0,0,15172,0,0,0,0,0,0,0,0,0,35302,0,\n+48135,20972,33094,0,0,0,0,0,9765,0,0,0,0,0,0,0,0,0,39559,0,0,13736,6950,0,0,0,0,\n+23658,8903,0,0,0,0,0,0,0,22662,0,0,0,0,0,58886,7468,0,0,0,0,0,0,0,0,64550,0,0,0,\n+0,0,47622,0,0,0,50886,0,0,0,0,0,57606,912,0,0,0,0,0,0,0,0,0,1449,0,1169,0,718,\n+46151,12104,0,0,0,0,0,0,48230,0,0,0,0,0,0,0,0,0,0,1259,0,0,33734,23208,62567,0,\n+65158,0,0,0,0,0,0,0,0,0,0,28684,59878,0,0,0,0,0,0,0,0,0,0,25769,0,0,0,0,65479,0,\n+0,0,0,555,22789,0,19748,1769,10246,8680,0,0,0,0,0,0,0,0,0,14250,0,5899,3303,0,0,\n+0,0,0,0,0,0,21097,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21638,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,10795,0,0,0,16204,0,0,0,0,0,26986,2469,0,14660,0,0,0,0,0,45447,\n+12234,3494,4555,10566,0,0,0,0,0,0,0,0,0,0,0,0,2801,0,0,0,15755,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,39654,0,0,0,0,0,0,6763,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+33574,0,10279,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63527,0,0,3912,0,0,7492,0,0,0,35142,\n+0,0,0,0,0,0,17576,8103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16713,4198,0,0,4782,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,16228,0,0,0,0,25961,20166,0,0,0,10980,0,0,0,0,0,14340,\n+18922,14567,0,44199,0,0,0,0,0,0,0,18406,0,0,0,0,0,37606,0,0,0,0,0,0,0,0,0,20902,\n+0,0,0,56358,0,38342,0,0,0,0,9514,36071,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21700,0,0,\n+5266,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1134,0,1453,0,0,0,0,0,3882,0,0,0,\n+0,0,0,0,0,4004,0,0,0,51910,0,0,0,0,0,23076,4648,0,0,0,31051,25351,0,0,0,22884,0,\n+0,0,0,0,63975,0,0,2376,16997,0,0,2096,0,0,0,3373,7046,0,0,0,0,0,0,0,30726,0,0,0,\n+0,20,0,13707,614,0,0,12840,3079,0,0,0,0,0,51046,3729,0,32680,0,0,0,0,0,24008,\n+62759,0,0,4745,0,0,0,0,0,0,0,0,0,0,0,0,0,2414,0,0,44262,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,24937,0,0,0,0,0,0,0,0,19140,0,13575,0,0,0,0,0,0,0,39110,0,0,0,28036,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,4261,0,0,0,0,5992,0,264,0,0,0,0,0,0,0,13739,0,21928,0,\n+0,0,0,0,0,0,0,0,0,0,4232,15110,0,0,0,0,0,0,0,0,0,30022,0,0,27977,0,0,0,0,0,24776\n+,0,0,0,0,0,2962,0,0,0,0,0,0,26564,22441,0,0,0,0,0,13640,11205,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,19305,1894,0,0,0,0,0,0,0,0,0,0,9389,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14119,\n+5224,135,0,0,0,0,0,0,0,0,0,25796,0,0,0,0,0,0,7470,0,0,0,0,63815,0,55654,0,0,\n+12584,0,1524,33223,0,0,0,9895,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11624,\n+0,0,0,5614,0,0,0,0,0,0,0,21320,0,0,53607,0,51206,0,0,0,25863,0,0,0,0,0,0,0,0,0,0\n+,0,8964,1740,0,0,0,0,0,0,0,0,13476,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7975,0,\n+0,3306,8134,0,8389,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25766,0,0,0,0,0,0,0,0,0,\n+52166,0,0,0,0,0,0,0,0,0,0,0,0,0,21477,31112,31652,0,0,0,0,0,0,0,28452,0,0,0,\n+44231,0,0,0,0,0,0,0,24805,0,0,0,0,0,0,0,0,0,0,12428,6471,0,0,0,0,525,17926,0,0,0\n+,26919,0,0,18120,0,0,0,30024,0,0,0,0,0,0,0,0,0,0,29189,0,0,0,43559,0,0,0,0,0,0,\n+19787,7557,0,59334,0,0,10184,6085,0,44039,0,0,0,0,0,0,0,11175,0,0,0,0,30440,\n+63110,0,0,0,0,0,0,11017,0,0,0,0,0,0,0,0,27204,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,29126,0,0,0,0,0,0,0,0,0,0,0,0,0,0,622,0,5226,2727,0,15588,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4650,0,2675,0,0,32420,0,0,0,61511,0,0,\n+5419,17829,2123,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38183,2640,0,11274,14533,1842,0,0,\n+42663,12681,3430,0,11845,0,0,0,0,0,0,0,0,0,6533,0,0,0,0,0,54598,0,0,0,0,0,0,0,0,\n+0,0,0,0,12616,38535,0,0,0,0,0,32229,0,0,0,54279,0,48614,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,31401,0,0,0,0,34310,0,0,0,22788,0,52134,0,0,0,0,0,0,0,23302,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,40678,0,0,0,51463,535,0,0,0,0,15525,0,0,0,0,0,0,4904,869,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63718,0,0,0,0,0,0,0,0,1678,0,692,0,0,0,\n+0,0,0,0,0,0,26216,0,0,0,0,0,29355,0,0,0,0,25095,0,0,0,0,4335,0,0,0,0,0,14538,0,0\n+,0,0,0,0,0,0,0,27273,55014,0,0,0,0,0,27271,0,0,0,0,0,30468,0,0,0,0,18186,0,0,0,0\n+,0,14345,0,0,0,2152,0,0,0,0,0,0,0,0,0,0,0,0,0,0,58438,21034,0,23339,21318,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,21412,0,0,0,0,0,0,0,12869,0,0,4875,0,0,0,0,29191,0,0,0,0\n+,0,0,1640,10247,0,14244,0,0,0,0,9867,0,0,0,0,0,12363,0,0,7653,0,0,4168,2663,0,\n+4580,0,11143,0,0,0,0,0,0,0,30662,0,0,0,0,0,6724,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,13764,0,0,0,0,0,0,0,0,0,0,0,0,234,6821,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,25639,0,0,0,0,0,0,0,0,0,29958,0,3461,0,0,0,0,0,0,0,0,0,28324,\n+18795,7013,12746,11655,0,37287,0,0,10953,7718,9705,0,0,0,0,0,0,0,0,0,0,46534,0,0\n+,0,0,0,0,0,0,0,0,8137,17988,0,25156,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,41415,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15784,6918,0,0,0,0,7019,10919,0,0,0,\n+0,0,0,0,0,0,0,4171,55495,4940,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22440,19333,0,0,\n+28136,0,6249,21317,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53414,0,0,0,57318,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39303,0,0,0,0,0,19940,0,0,0,0,0,0,0,25543,0,0,0\n+,0,0,0,0,0,0,0,0,0,2698,3911,0,0,0,26790,0,0,0,0,0,0,32424,0,0,18470,0,0,0,14726\n+,29834,0,0,0,0,0,0,0,0,0,0,0,1000,4197,0,0,0,19366,0,0,0,39878,0,0,0,0,2185,8901\n+,5288,9829,25000,0,0,0,0,0,0,1062,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35622,0,\n+0,23048,62503,6506,0,0,0,0,0,0,0,13609,10438,0,0,0,0,0,0,0,0,0,0,7723,42119,0,0,\n+0,0,0,13317,0,0,0,41606,0,27111,0,0,21194,11461,0,0,0,0,26856,58342,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,20940,48710,0,0,0,0,0,0,5227,0,0,0,0,0,10061,31300,0,0,0,19236,0\n+,0,0,0,0,30277,13896,0,0,0,12876,13159,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,428,\n+46951,13134,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15462,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,21668,0,0,0,0,0,0,0,0,0,0,0,0,2249,0,0,0,0,44967,0,0,0,0\n+,0,0,3465,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24868,0,0,0,0,0,23909,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,2190,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16164,0,\n+10437,0,0,5263,20102,20938,0,0,0,1192,1030,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,21385,4870,0,0,0,0,0,0,0,0,0,0,0,18596,0,0,0,0,1422,4038,2858,0,0,0,0,0,0,0,0\n+,48998,0,0,0,0,0,0,0,0,6508,37350,0,0,0,0,0,0,0,0,17001,39431,0,0,0,0,0,30182,0,\n+21445,7403,28164,0,51750,0,0,0,62631,0,0,0,0,0,0,0,31206,0,0,0,0,0,0,0,0,0,0,0,\n+7751,0,0,0,0,0,0,0,0,0,13477,0,0,456,26693,0,0,0,0,0,0,0,0,0,0,0,0,14890,0,0,0,0\n+,0,26697,22022,13225,27364,0,0,0,18884,0,0,0,0,0,0,0,0,3659,0,0,0,0,0,0,0,0,0,0,\n+0,1448,5413,0,0,0,0,0,0,0,0,0,0,0,6340,0,0,18091,18725,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,22118,0,0,0,18981,0,0,0,0,0,0,0,0,0,29223,3724,0,0,0,0,43526,0,0,0,25668,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21545,9862,0,22692,32201,60646,0,7300,0,0,\n+0,58887,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19460,0,0,0,0,0,0,0,0,0,50342,0,\n+65255,4360,17286,0,0,0,0,0,0,0,28708,0,0,30025,60102,0,0,0,0,0,0,0,0,0,47014,0,\n+31973,0,9572,0,0,0,0,0,0,0,18501,0,0,0,0,0,14597,0,0,0,53735,5228,22183,0,0,0,0,\n+0,0,1554,24164,0,0,0,0,0,0,0,0,0,0,0,0,10827,0,0,0,0,34918,0,0,0,0,22252,0,0,\n+46855,0,0,0,0,0,31207,0,0,10733,0,0,63334,0,0,0,0,8616,50119,20169,12678,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,58087,20298,5,0,0,30920,0,0,0,0,0,0,0,296,13190,0\n+,30663,0,0,18536,12228,0,6788,0,0,0,0,30890,21796,0,0,526,0,0,0,0,0,0,0,0,0,0,0,\n+0,20965,0,0,0,0,2161,0,0,0,0,0,0,24038,0,0,0,0,13544,7398,0,0,32522,9605,0,0,0,0\n+,3208,7590,0,0,0,43846,0,0,0,38663,0,0,0,0,0,39014,4142,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,6373,0,0,13676,0,0,0,0,30374,21288,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22791,0,0,0,0,0,37958,0,0,0,0,0,0,0,0,0,0,9452,\n+9990,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4841,0,0,0,0,18820,152,0,0,0,0,0,13260,3334,0,0\n+,24234,8422,0,17957,0,0,0,10244,0,0,0,0,0,0,0,0,0,0,0,7204,0,0,0,0,1201,26151,0,\n+31173,0,0,0,0,0,0,0,0,0,0,0,0,0,64838,4203,7525,521,0,18888,37031,0,0,0,0,0,0,0,\n+0,7082,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4490,12487,0,0,0,0,0,0,0,36615,0,0,\n+0,14854,0,0,0,0,0,0,0,0,0,0,0,0,6539,13029,9704,38983,0,0,0,0,168,10405,0,0,0,0,\n+394,25607,0,57063,0,0,0,0,0,0,0,0,0,0,16141,19878,0,0,0,0,0,0,0,0,0,29446,0,\n+12036,0,0,0,0,0,6982,18572,0,24584,14535,0,0,0,0,0,0,0,0,0,0,16,0,21642,0,0,0,0,\n+0,0,5254,0,0,0,0,0,0,0,0,1622,0,0,0,0,0,0,0,0,0,0,0,0,0,3853,9126,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,7241,10982,0,0,0,0,0,0,0,0,0,0,0,0,0,0,950,0,0,57990,0,0,277,0\n+,0,0,694,36007,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42470,0,0,0,0,18409,\n+51142,0,0,0,0,0,0,0,0,0,28646,0,0,0,30693,0,0,0,0,0,56295,5544,0,0,0,0,8518,8366\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,45670,0,0,\n+9608,33062,0,0,0,0,0,0,0,0,0,0,0,18694,0,0,0,0,1672,23493,0,0,6955,7655,0,36134,\n+0,0,0,0,0,0,0,0,23432,647,0,0,0,0,0,0,0,0,0,0,0,13382,0,0,0,19621,0,0,0,0,0,0,0,\n+0,0,20228,0,0,2728,31495,0,0,0,0,29096,22213,235,35495,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,5348,0,0,0,0,8968,1989,0,0,1066,0,0,11492,5965,31367,0,0,0,0,0,0,0,0,0,0,0,\n+18727,0,0,0,6757,0,0,10765,4646,0,36166,0,27943,0,0,26888,8420,0,0,0,0,0,0,0,0,0\n+,29316,0,0,0,0,0,0,0,0,0,0,4975,0,0,0,14762,3111,0,0,0,0,0,43399,0,0,0,0,0,0,0,\n+18980,0,0,0,0,0,44550,0,0,0,0,4051,0,0,0,0,37734,0,0,0,0,0,5188,0,0,0,0,0,24486,\n+0,5989,0,41159,0,0,0,0,0,0,0,0,0,20326,0,0,747,6884,0,0,0,41798,0,0,3117,22919,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21032,0,0,0,0,0,0,0,0,9574,0,0,0,0,0,0,\n+4302,0,0,0,0,0,0,0,0,0,0,0,21068,34630,0,0,0,0,0,64071,0,0,0,0,0,0,26667,7943,0,\n+0,0,0,0,52934,0,0,17002,0,0,0,0,0,0,20294,0,0,0,0,0,0,0,0,0,27301,18347,7974,0,0\n+,0,0,0,0,0,0,16874,0,0,0,0,45414,0,0,0,0,0,0,648,1575,0,0,0,31749,0,0,0,23301,0,\n+0,0,0,0,0,0,0,0,0,0,0,15912,50535,0,0,0,0,1993,8582,0,0,0,0,0,0,0,38438,0,0,0,0,\n+0,0,0,0,0,0,0,0,15850,6183,0,0,0,0,3402,0,0,27494,0,0,749,0,0,0,0,0,0,0,26025,\n+29606,0,0,7144,19622,30504,0,0,0,0,0,0,0,0,21316,0,0,0,0,0,0,0,0,0,21444,0,0,\n+1289,6919,0,0,0,0,0,0,8299,0,0,0,14090,35655,0,0,0,0,0,0,0,0,2377,15206,0,0,6028\n+,4452,0,25508,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50310,0,0,0,0,1269,0,0,0,0,0,0,0,0,0\n+,0,0,0,51014,0,0,0,0,0,0,0,9286,0,7429,0,0,28393,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,16680,452,0,0,0,0,0,23718,0,0,0,31750,0,0,0,0,0,0,0,0,3568,0,0,13604,0,0,\n+0,0,0,25255,0,0,0,50982,0,56582,0,0,7467,0,0,0,0,30181,0,0,0,0,0,0,0,30564,7208,\n+7845,0,0,0,0,0,0,7726,0,0,0,0,62182,0,0,0,41094,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,22695,0,0,0,0,0,0,17736,0,0,0,0,0,0,0,0,50054,0,0,0,14180,0,0,0,0,\n+0,0,8974,0,0,0,0,0,0,0,0,23332,0,0,0,11140,0,0,0,0,0,0,0,24262,27145,9540,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,26537,45510,6062,3879,0,0,20233,25991,0,0,17803,0,0,0,0,0,\n+13962,5508,16971,27013,7437,31494,0,0,0,0,0,0,0,0,0,0,4714,0,0,0,0,0,0,0,0,17189\n+,0,0,0,0,0,27492,0,0,26953,0,0,0,0,0,0,0,0,0,0,41319,0,0,0,0,0,0,0,0,0,0,0,47430\n+,19596,12549,0,0,0,8390,1006,0,0,0,0,0,0,0,0,0,0,24100,17577,4,0,0,0,0,0,22277,0\n+,0,0,0,0,0,0,26692,0,0,0,0,0,24676,0,0,0,0,0,0,0,0,0,0,0,0,0,29477,0,0,0,21573,0\n+,0,0,0,0,0,0,0,0,0,9864,14214,0,0,0,0,0,0,25771,5766,0,0,8909,8679,0,0,6861,\n+16166,0,38887,0,0,0,0,0,0,12392,8678,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+52646,1354,2950,0,14692,0,0,10572,49830,0,0,0,0,0,0,0,0,3626,582,0,0,0,55750,0,0\n+,0,30885,0,0,0,0,0,0,0,0,0,0,0,0,0,5830,0,0,2090,0,0,0,0,0,0,0,0,0,0,0,0,31142,0\n+,0,0,0,0,10503,0,0,18825,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+57158,0,0,30792,63526,0,0,0,9863,16267,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,18824,0,0,0,0,0,0,19653,25388,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9292,0,0,0,0,0,0,0,0,0,0,36358,0,0,0,0,0,0,0,0,\n+0,0,25480,23015,0,0,10440,6725,0,0,0,22436,24265,15109,0,0,0,62311,8906,34534,0,\n+0,0,0,0,0,15913,1319,0,0,20296,1477,30760,0,25928,16772,0,0,1069,0,0,0,0,0,0,0,0\n+,0,0,0,0,17029,0,31909,0,0,0,0,0,0,0,0,0,0,0,41638,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,41542,0,21478,0,0,0,9796,0,0,0,0,0,0,0,0,0,0,22187,58343,0,0,0,24295,0,\n+0,0,0,0,61831,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2833,5829,0,0,0,62855,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,16676,0,0,0,0,0,0,13577,27431,0,0,0,0,21480,10501,0,16932,\n+0,0,0,0,0,22918,0,48294,2574,2150,0,0,0,0,1897,4518,0,0,0,0,0,0,25064,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,47942,0,0,0,0,10990,13767,\n+25705,37863,21672,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43430,1712,0,0,0,0,\n+18886,0,0,0,0,0,0,0,0,0,0,0,0,0,10535,0,0,0,0,0,0,0,15012,0,0,0,0,0,0,0,0,0,0,\n+14734,0,0,55782,0,0,30824,10886,0,0,0,0,0,51302,0,0,8012,0,0,0,0,0,20680,6981,0,\n+57415,11,0,0,18277,0,14564,0,0,0,32390,0,0,0,0,0,0,0,0,0,0,0,0,19113,5158,0,\n+11172,0,16774,0,0,0,0,0,0,0,0,0,0,0,0,10315,13830,0,0,0,0,0,0,10410,7141,0,0,0,0\n+,0,18116,0,0,0,44615,15403,13958,0,1540,14632,19525,24201,19781,0,0,0,24165,0,\n+38951,0,0,0,0,0,6308,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17416,15749,3438,13255,0,0,0,0,\n+0,0,0,0,0,0,0,32228,0,0,0,0,176,0,0,50566,0,0,0,0,0,0,0,0,0,0,0,0,0,21540,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,58982,0,0,0,0,0,0,0,0,0,5284,0,0,0,0,0,0,25897,28326,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15945,0,0,0,9804,293,0,0,0,0,0,0,0,13988,23082,4677\n+,0,0,0,0,0,0,0,0,0,0,0,5670,0,0,0,0,0,0,0,44070,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,6405,0,30692,0,0,0,61702,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,45926,0,15398,0,0,0,0,0,0,4554,2692,0,0,0,0,0,32485,0,0,0,10084,0,0,0,0,0,0,\n+24297,0,0,0,0,0,0,0,0,22790,0,0,0,55110,0,0,0,0,0,0,0,0,0,0,0,0,7112,0,31530,\n+45255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40743,17226,22599,0,\n+0,0,0,0,0,0,0,3695,0,0,0,0,0,0,0,0,0,0,56999,0,0,0,0,0,13799,3114,21287,1353,\n+7591,0,0,0,8455,0,0,6824,0,0,0,0,0,0,0,14569,0,0,0,29000,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,19979,0,18376,0,0,0,0,0,0,0,0,0,0,0,0,11332,0,0,0,49863,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,2191,7527,23148,58022,0,0,0,30631,0,26565,0,0,0,0,0,0,0,0,0,0,0,0,754\n+,0,0,15877,0,0,0,0,0,0,0,17510,7657,2821,0,0,0,0,0,0,0,0,0,41927,0,0,0,0,0,0,0,0\n+,2569,34439,0,0,3790,0,0,0,15339,8775,0,0,0,0,0,0,0,0,0,0,0,15908,0,0,21419,8359\n+,0,0,0,0,424,0,0,0,0,0,0,25318,8008,20551,0,0,0,45735,30058,30372,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,26180,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,31432,10567,0,0,0,0,\n+17450,0,0,0,0,0,0,30310,0,38022,0,0,0,0,0,28932,0,0,0,0,0,43910,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,22180,12075,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22247,0,0,22826,\n+12359,0,0,0,0,4105,50407,0,0,0,0,0,0,13581,28583,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,28936,0,0,0,0,0,17673,10310,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,905,57862,\n+1580,0,0,0,0,58630,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13479,0,0,\n+14153,13286,0,0,9259,0,0,0,0,0,6606,3524,0,0,0,0,0,6567,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,631,49255,0,0,0,0,0,42886,0,38215,0,0,0,0,0,0,0,0,17580,\n+0,0,0,0,0,0,0,0,55046,0,0,0,0,0,0,0,0,0,10213,0,0,0,0,3604,37767,0,0,0,0,0,0,0,0\n+,0,0,0,30950,0,0,0,0,0,0,0,0,0,62087,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23528,0\n+,0,0,0,0,0,0,0,0,28715,4229,0,0,0,0,0,0,0,0,0,0,1226,26820,0,0,0,12133,6984,261,\n+21130,32548,0,0,0,0,0,0,3565,12390,20713,28071,0,0,1706,25287,0,0,0,0,0,0,0,0,\n+14670,0,0,0,0,0,0,30534,0,0,0,12615,0,43750,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28228,\n+0,0,0,0,0,0,0,45095,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1224,3975,10954,6375,0,0,0,0\n+,0,0,0,0,0,0,23180,20100,0,0,0,0,25736,8519,0,0,0,0,0,6663,0,2534,0,0,0,0,0,0,0,\n+0,23720,0,0,0,0,0,0,0,0,0,0,19398,0,47814,26281,49702,0,0,4332,12965,0,0,5704,\n+3206,0,0,0,0,0,0,0,0,0,0,0,0,0,15396,0,0,0,44102,0,0,0,0,0,0,0,0,0,0,0,0,0,25317\n+,1064,39271,27433,0,14952,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14308,0,0,0,0,0,0,2763\n+,4100,0,0,0,0,0,0,18792,0,0,0,22154,32583,0,6244,0,0,0,0,0,0,0,49478,0,0,0,0,0,0\n+,0,0,0,0,0,21894,0,0,11048,0,0,0,0,0,0,11685,0,53862,0,0,15114,0,13870,0,0,0,0,0\n+,0,0,919,0,0,0,31916,0,22570,101,0,0,0,0,0,0,0,0,0,7333,0,0,0,0,3272,0,0,0,0,\n+27718,32712,0,0,0,0,0,0,0,0,0,1782,0,3688,0,0,0,0,29862,0,0,0,0,0,0,0,22469,0,0,\n+0,0,0,0,0,55302,850,15492,0,0,0,5927,19786,13350,0,25702,0,0,0,0,0,0,0,0,0,0,0,\n+40390,0,0,0,0,0,0,0,0,0,0,0,0,0,20260,0,0,0,0,0,0,0,0,0,0,0,0,0,15335,8394,0,0,0\n+,0,0,0,26566,0,0,0,0,843,2245,0,0,0,0,0,0,0,0,6959,0,20488,1638,0,0,11533,50759,\n+0,0,0,0,0,20871,0,0,0,0,0,24519,0,0,0,0,9544,23591,0,0,0,0,0,0,0,0,0,0,20969,\n+7109,29001,0,0,32422,31720,64294,0,0,0,0,16106,0,0,0,6930,4933,0,0,0,22917,0,\n+27015,0,0,0,0,19880,8070,0,0,0,0,23945,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+3310,0,87,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18439,0,0,0,20742,0,0,0,10597,0,0,0,0,0,0,\n+0,0,0,0,0,0,20236,0,0,0,16584,3429,0,0,0,0,0,0,0,0,27241,0,0,0,0,16132,0,0,0,0,0\n+,0,0,0,0,0,0,0,244,28261,0,0,0,0,0,0,0,29509,0,0,0,0,0,0,0,0,2921,31781,0,0,0,0,\n+0,0,6408,4196,344,0,0,0,0,0,0,0,0,0,0,0,0,0,11689,45863,0,0,0,0,906,3301,0,0,\n+25544,32421,0,0,0,0,0,0,0,0,1260,61607,0,27302,0,0,8682,16614,0,0,0,0,10830,0,0,\n+9604,15049,13413,0,0,0,0,0,0,26761,0,0,0,0,0,0,61990,0,0,0,0,0,12580,0,0,11432,0\n+,0,0,0,0,22507,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12389,0,0,0,0,0,0,\n+2408,22661,14507,43239,0,9700,0,0,24714,0,0,0,0,0,0,0,0,23972,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,34086,0,0,22955,7238,0,0,0,0,0,28485,13806,20038,0,0,0,0,22602,0,0,0,\n+1645,22340,0,0,0,0,0,0,0,0,0,0,0,26502,0,0,554,0,0,0,0,61735,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,2694,0,0,0,0,0,0,0,0,0,0,0,0,0,0,883,27879,15948,0,3242,57382,0,0\n+,0,0,0,0,13930,0,0,0,0,0,30922,0,4137,52615,0,0,0,0,0,0,0,0,0,0,0,0,0,31911,\n+16072,0,0,0,0,0,0,0,0,0,0,0,0,26340,0,61671,0,0,0,0,3145,56199,0,0,0,0,0,0,0,0,0\n+,0,0,0,280,0,5131,33479,0,15751,0,0,0,0,0,0,4136,1446,0,0,0,0,0,0,11304,17863,0,\n+0,0,0,0,25125,0,0,0,36646,6057,0,0,0,855,11301,0,0,0,0,0,64774,0,0,0,19397,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,1040,27367,0,0,0,0,0,0,0,0,0,0,0,0,0,64358,0,0,178,\n+132,0,0,14763,24455,0,0,0,46374,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46246,0,0,0,37382,\n+0,0,0,7462,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8166,0,0,6921,0,0,0,9163,0,0,0,119,\n+0,0,0,23146,17156,0,0,0,0,0,9127,0,0,0,17927,0,0,0,0,0,22084,0,0,0,0,0,39879,0,0\n+,2035,0,1067,0,0,0,0,0,16652,59591,0,0,0,0,0,0,0,0,0,0,0,0,20171,0,0,0,0,17733,0\n+,0,0,0,0,32037,0,0,0,0,0,14277,0,0,0,0,0,0,0,42022,0,0,26793,20358,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,8907,0,0,0,0,0,0,0,0,27780,0,0,0,0,32330,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,39399,0,9732,0,16199,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,854,0,2984,45063,25418,26980,22539,0,9133,3653,15528,28743,4649,0,616,\n+65127,0,0,0,61863,0,0,0,0,0,0,0,55303,0,0,0,0,0,0,0,0,23880,0,0,0,0,0,0,0,31848,\n+62854,0,0,0,0,0,0,0,0,0,0,0,49606,0,27974,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,32580,0,0,0,26052,4043,0,0,40454,0,0,26056,30565,0,0,0,0,0,0,0,31398,0,0,0,0\n+,0,0,0,0,29288,1797,0,0,3220,0,0,0,0,0,0,0,0,0,20427,0,0,0,0,23621,0,0,0,0,0,0,0\n+,0,0,24261,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35591,0,0,6862,0,0,0,4265,0,6285,\n+5383,0,0,0,0,0,36870,0,39847,0,0,17224,5414,27882,58118,0,0,13224,4262,0,0,0,\n+31302,0,0,1388,2982,11881,0,0,0,0,0,0,16837,809,0,24140,10724,0,0,0,0,5835,0,0,0\n+,0,0,0,0,0,0,0,0,1256,19237,0,0,0,0,0,0,0,5796,11848,0,0,52870,11464,0,0,0,0,0,0\n+,0,0,0,5645,9158,0,25223,0,0,0,0,0,39142,24968,8135,32104,28678,0,0,0,46311,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23820,0,0,0,0,0,4050,0,1323,25220,0,0,0,20133,0,\n+0,0,0,0,0,0,0,0,0,0,9381,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,13444,1198,60806,0,0,0,0,17356,50247,30632,0,0,0,0,0,0,0,11944,\n+999,0,0,0,0,4010,10404,0,0,0,0,0,0,10346,0,0,49510,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+38919,0,0,0,0,0,0,6351,60966,20137,487,0,0,0,0,0,0,655,2406,17387,43303,0,0,0,\n+17063,0,0,213,0,0,0,0,0,0,17221,0,0,0,0,0,0,0,0,0,0,0,10820,0,0,0,0,369,6,0,0,\n+9098,21093,0,31653,0,0,0,0,0,0,0,0,0,27143,0,0,16234,0,0,0,0,0,0,0,0,6020,31723,\n+28293,0,0,0,0,1936,30695,0,0,0,0,0,52902,0,0,29512,10791,0,20420,0,0,16010,0,0,0\n+,0,0,0,0,0,0,0,0,5324,0,0,0,0,0,0,0,0,0,0,0,0,13383,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,24328,0,0,0,0,0,0,40870,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,24648,0,0,0,0,0,0,0,7786,2852,0,0,0,0,0,0,0,0,0,44678,0,17925,0,0,105,53062,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18762,0,0,40679,0,0,0,16165,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,20390,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,62310,1322,\n+14247,0,0,0,0,0,0,0,0,1832,6052,0,0,11882,0,0,0,0,17668,0,28262,0,29542,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28007,0,0,0,57223,\n+1585,0,0,0,0,0,0,0,0,0,0,0,21162,0,0,62247,0,0,0,0,0,25414,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,36326,0,0,0,23845,0,0,0,0,0,0,0,2693,0,0,0,0,0,0,0,\n+13125,0,31236,0,0,0,0,0,22502,0,0,0,0,0,0,5994,10309,0,0,0,7269,0,0,0,0,17929,0,\n+1011,44647,0,0,0,0,0,14919,0,0,0,0,20586,5350,0,0,0,45702,0,13189,0,0,0,0,0,0,0,\n+0,0,35782,17992,0,0,0,0,0,8203,0,0,0,0,0,0,56678,0,0,0,0,0,38087,4233,0,2127,0,0\n+,0,0,0,0,0,0,0,0,10148,0,0,0,2021,0,0,0,0,0,0,0,47206,0,0,0,0,0,0,0,9220,0,0,0,0\n+,19465,0,0,0,0,0,0,0,0,39206,0,38055,0,0,0,0,0,0,0,46982,0,0,0,0,0,22054,3850,0,\n+0,0,0,0,0,0,55,0,10542,0,0,0,0,7239,0,0,0,0,0,59367,0,0,14761,0,0,0,0,43079,0,0,\n+0,0,0,2726,0,0,9582,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,37478,0,\n+0,0,31364,0,0,0,0,0,0,0,0,20393,8933,0,0,0,0,0,9380,0,0,0,0,16905,549,0,0,0,0,\n+182,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1558,0,0,0,0,0,0,0,19242,0\n+,0,0,0,0,0,24933,0,6276,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,42310,23595,\n+24068,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13191,6158,2567,0,0,268,47047,0,0,0,0,0,0,0,\n+0,0,27940,0,0,0,0,0,26726,0,0,0,0,8200,1222,31562,0,0,0,0,0,0,0,0,0,2922,8231,\n+8904,29157,0,0,0,0,0,0,0,0,23976,4836,0,0,0,0,0,0,0,0,0,0,0,0,31658,0,0,31685,0,\n+0,2889,6213,0,0,0,0,0,13605,0,0,0,0,0,24772,0,0,0,0,0,0,0,0,0,0,20684,26468,\n+24075,0,0,0,21193,0,715,679,0,0,0,0,0,0,3050,7654,0,0,0,13798,0,0,0,0,15,27973,0\n+,0,8491,2086,0,0,0,43206,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,60391,0,0,0,0,0,0\n+,0,25892,0,22276,0,34374,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20165,0,0,25672,0\n+,0,0,1811,24839,0,31044,0,0,25513,0,0,0,0,0,12810,0,0,62438,0,0,1325,0,364,3782,\n+0,0,0,0,0,0,0,0,8042,19687,0,0,0,33415,0,0,0,0,0,0,0,0,0,0,0,7205,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,11844,0,0,0,0,3341,1543,6698,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,29766,0,0,0,0,0,0,0,0,0,0,0,41158,0,24294,0,3844,12329,\n+0,0,0,13738,0,0,0,0,0,0,0,0,26245,0,0,0,0,0,0,6378,0,343,4838,0,0,0,24358,11688,\n+0,0,0,0,0,0,0,0,0,1489,34759,0,0,0,0,363,51974,1878,11013,0,0,32265,59782,0,0,0,\n+28421,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22756,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14089,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,29257,61222,0,30661,0,28327,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+27108,8843,0,9673,2084,0,0,0,16327,0,48455,0,0,0,0,0,0,4876,9316,0,0,0,0,0,0,0,0\n+,0,0,0,0,9035,18852,0,0,0,0,0,0,0,0,0,0,0,0,0,4164,0,0,14827,1349,0,0,0,0,0,\n+11909,0,0,0,0,0,0,0,0,0,21765,0,0,0,0,0,0,0,0,31272,63910,0,0,0,25924,0,0,0,0,0,\n+0,0,0,0,44487,0,0,0,20612,0,0,27754,31428,0,0,0,0,0,0,0,17287,0,3943,0,0,0,63302\n+,0,0,0,0,25256,19942,0,55142,0,39046,0,0,0,0,0,0,0,15367,0,0,0,0,0,0,0,0,0,0,0,\n+28422,0,0,0,0,0,0,0,0,0,0,0,0,9576,63847,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,25226,5734,0,0,0,0,0,0,13801,4997,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,43942,1270,2566,6284,0,0,16230,0,0,0,20678,0,0,0,0,0,38855,0,0,0,0,\n+29643,0,0,0,41,3655,0,0,0,0,0,14276,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,15686,0,0,0,15718,0,50694,0,0,16232,8007,0,0,0,5060,\n+329,11591,51,0,0,0,0,0,0,0,0,0,13065,7302,27530,15366,0,24934,0,0,0,17828,0,0,\n+4552,6311,0,0,0,0,0,0,0,0,0,0,0,47686,368,12103,10122,33830,0,0,599,18534,9579,\n+49479,0,5668,0,0,0,0,0,0,0,0,0,13157,0,0,0,0,23274,14055,0,0,0,0,0,48903,0,0,0,0\n+,0,0,1871,0,15434,0,0,0,16174,62470,0,0,0,0,0,0,0,0,0,0,0,7749,0,0,0,0,0,0,0,\n+30501,0,0,0,0,25675,0,0,0,0,0,0,0,0,0,0,9285,0,0,25323,1669,0,0,0,0,0,0,0,0,0,0,\n+0,3588,0,0,0,0,0,32902,0,0,4426,0,0,0,0,57959,0,0,0,0,0,0,29898,58278,0,0,0,0,\n+11880,1220,0,0,0,41479,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23141,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,42566,0,0,0,0,0,0,0,40167,9484,3493,0,0,0,0,0,21126,0,0,0,0,8649,18918,0,0,\n+0,0,0,0,0,34886,2601,0,0,0,0,12518,0,0,0,0,7976,10311,0,0,0,0,0,0,0,45190,0,0,0,\n+0,0,0,0,0,0,0,16842,20229,0,0,0,0,0,0,7528,4614,0,0,0,0,0,30086,0,0,0,1671,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,9896,6277,0,0,0,0,0,61191,0,41287,0,21956,0,0,20010,0,0,0\n+,0,0,0,0,0,0,0,0,13195,0,0,0,0,1381,0,0,0,0,365,30951,24268,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,7044,0,0,0,0,0,0,0,0,0,0,27944,359,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,28487,0,0,77,0,0,0,0,0,0,0,0,56775,12586,8421,0,0,0,0,0,0,26185,14599,0,0,\n+8040,5702,12585,3109,0,0,0,0,0,21574,5388,0,0,0,0,0,0,0,5106,52454,0,0,0,0,0,0,0\n+,0,1907,29895,0,6116,0,0,0,0,11081,5285,0,28069,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4104\n+,0,0,0,0,0,0,41511,0,0,0,0,0,0,5262,0,0,0,503,4231,7720,34343,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7304,10374,1718,0,0,29127,0,0,0,0,0,0,0,0,23497,\n+22567,6952,2340,0,0,0,0,0,0,0,0,20360,12453,0,45094,0,0,0,0,0,28582,0,0,0,0,680,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,23084,0,0,0,30696,0,0,0,0,45862,0,0,0,0,0,0,0,0,0,0,0,\n+0,5580,6053,0,0,0,0,0,0,0,0,0,0,712,70,0,0,26091,11335,0,0,0,0,13612,0,13160,\n+1926,435,51559,0,0,0,0,0,0,0,0,0,0,0,0,0,47302,19083,0,0,12742,0,1607,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,6155,37095,0,0,0,0,0,18948,7146,0,0,0,0,0,0,0,7848,\n+2055,0,0,0,0,8910,0,19336,0,0,48070,8490,0,0,0,0,0,0,0,9932,56423,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,4133,0,0,0,0,0,0,0,0,0,43398,0,0,0,0,0,0,0,0,16173,0,0,0,0,0\n+,0,0,32011,0,0,30918,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26854,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,20389,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18889,0,0,0,0,8965,0,0,0,44358,0,0,0,8997,0\n+,34055,0,0,0,0,0,29350,0,0,501,17767,0,0,32457,60262,0,0,0,30886,0,0,3757,1063,0\n+,0,0,25637,0,0,0,0,0,28068,0,26374,0,0,0,0,0,0,0,0,0,0,0,11684,0,0,0,0,0,0,24779\n+,229,0,13766,0,0,7402,11525,0,0,0,0,0,0,0,0,26313,23686,0,0,29736,47527,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27268,0,0,0,0,553,0,0,0,0,0,0,32038,0,0,0,0,1135,\n+26596,0,0,12300,14631,0,0,0,43238,0,871,0,0,31496,0,8457,17669,0,12836,0,0,0,\n+22726,0,38758,0,0,375,6564,0,0,0,0,0,0,0,0,0,0,0,0,170,18535,0,22948,0,0,32360,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,25764,0,0,0,0,0,0,0,0,0,0,0,15652,0,0,0,32774,0,0,0,0\n+,0,0,0,0,0,28551,0,0,0,0,0,0,0,0,0,0,0,0,15145,0,0,0,21100,27654,0,0,0,0,0,0,\n+4874,26215,0,1639,0,0,0,0,0,0,0,0,0,0,4169,0,0,0,0,0,7336,0,0,0,0,21572,0,0,0,0,\n+0,0,0,0,0,24644,1675,2533,0,0,0,53318,0,13094,0,0,0,0,0,0,0,6246,0,22020,0,0,0,0\n+,0,0,0,0,0,0,0,28453,5576,5124,0,0,0,0,0,0,0,0,0,0,0,0,0,27910,0,29382,18216,\n+8583,0,0,0,39174,0,43558,0,0,0,0,0,0,0,0,0,11973,0,0,0,0,0,23397,0,0,0,0,6091,0,\n+0,0,0,0,0,0,6474,16197,14217,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,26728,0,567,48839,0,0,0,0,0,15271,0,0,31818,43974,2450,0,0,0,0,0,0,0,\n+11368,9191,0,44454,0,0,0,0,0,0,14568,12293,0,0,0,8453,0,0,0,0,0,0,0,0,0,0,0,0,\n+32040,0,0,0,0,0,0,0,0,0,0,0,0,902,0,0,0,27236,5612,11495,0,0,0,0,0,0,0,0,9194,\n+23684,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27430,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+26217,44870,0,0,0,0,0,0,5581,7173,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+52775,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20968,18340,0,0,0,0,0,0,0,0,4107,11239\n+,0,0,0,0,0,0,0,0,0,0,0,29381,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21990,0,0,0,0\n+,0,0,0,0,0,48806,0,0,0,32292,0,0,0,0,0,0,0,10884,0,0,0,0,0,0,0,0,0,0,27562,0,\n+5643,0,0,0,0,0,0,0,0,0,3089,31525,0,19684,0,0,0,0,0,0,0,61415,0,0,0,0,0,36198,0,\n+0,0,0,0,0,0,7908,0,0,0,0,872,743,0,0,0,0,0,0,0,0,1229,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,32484,0,0,0,0,0,34822,0,0,0,0,0,50726,0,0,0,0,7274,0,0,0,15304,\n+11526,0,0,0,3047,0,0,0,0,0,0,22376,0,0,0,846,0,0,0,0,35815,0,0,0,23652,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,23721,2148,0,0,0,0,0,0,14856,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,1358,0,3082,0,0,0,848,10949,0,0,0,0,0,0,6504,0,0,14372,0,0,0,0,0,0\n+,0,0,0,0,8201,9958,0,0,0,0,0,0,24266,0,0,0,0,0,0,0,0,26469,0,0,0,0,18604,2053,0,\n+33511,0,0,0,0,0,9222,0,0,0,0,0,44006,0,0,0,0,0,0,0,0,0,0,0,41895,0,0,0,0,0,0,0,0\n+,12044,390,0,0,0,0,0,4935,0,48646,0,56102,3052,16070,0,0,0,0,0,0,0,8612,9320,\n+38311,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,500,0,0,0,0,42918,0,\n+32550,0,0,0,0,0,0,0,0,27434,57926,17064,0,0,46502,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,26760,6756,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,624,0,5000,0,0,0,0,32293,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,26246,0,0,0,0,0,0,0,0,23,7301,0,0,0,36199,0,40838,0,0,0,\n+0,0,0,0,0,0,0,0,0,27178,57350,0,0,12457,9317,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16810,0,0,0,14510,0,0,0,0,21319,0,0,0,13508,17,\n+11365,0,0,0,0,5291,0,8329,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27685,0,0,0,0,0,0,0,\n+52006,0,0,0,7493,0,44263,0,0,0,0,0,0,0,0,9800,0,0,0,25676,61478,0,0,0,0,0,0,5773\n+,0,0,0,0,41991,26057,0,0,0,0,0,0,0,0,0,0,22629,0,0,0,47783,362,1959,23468,0,0,0,\n+10921,0,0,0,3150,0,0,0,0,0,0,0,0,0,0,0,32456,0,0,0,0,0,0,0,4559,3270,0,0,983,0,0\n+,26343,0,33446,0,0,0,61767,0,48390,0,0,0,0,0,0,0,2790,0,39782,7849,0,0,0,0,0,0,0\n+,1544,2183,0,0,0,0,0,0,0,0,4040,2471,20009,30020,0,0,11242,0,0,0,5578,53382,0,\n+22631,0,0,0,0,0,0,0,0,0,0,0,12901,0,0,0,0,0,0,0,0,0,0,0,0,215,0,0,9030,0,0,0,0,0\n+,0,265,1412,0,0,11626,3687,0,0,0,0,0,0,0,0,0,0,0,0,17449,24359,0,0,26729,40134,0\n+,0,0,0,29768,61958,0,0,0,0,0,0,0,0,20908,0,0,0,0,0,11016,0,0,47462,21547,5926,0,\n+0,14728,2983,24104,15301,0,0,0,0,0,32645,0,0,0,0,0,0,0,3300,0,0,0,15972,0,0,0,0,\n+0,0,6634,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3076,0,30983,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,106,0,0,0,0,12775,0,0,0,0,7177,18022,0,0,0,0,0,22534,0,0,0,0,0,0,0,0,0,0,0,\n+49894,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27560,0,0,0,0,30278,10668,23877,0,\n+0,0,0,0,0,0,29124,0,0,0,0,0,0,0,0,0,0,0,0,0,20870,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,44582,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48454,0,0,0,0,6442,0,16330,22951,0,0\n+,16904,0,0,0,0,644,0,0,0,40038,0,0,0,37222,0,0,0,9830,0,0,0,0,0,34919,0,0,0,0,0,\n+0,0,0,0,0,0,13733,0,0,0,28196,0,0,0,0,0,19876,0,0,0,0,0,0,0,23558,0,11142,0,\n+27781,0,0,0,0,13864,0,0,0,24682,47847,0,0,0,0,6890,0,0,0,0,0,3981,0,0,0,0,0,0,0,\n+0,0,0,0,1772,0,0,0,0,0,0,0,3603,1991,0,27396,8652,0,18312,0,0,0,0,30054,0,0,0,0,\n+0,0,0,11270,0,0,0,0,0,0,0,0,0,20708,0,0,0,0,338,0,0,0,0,0,0,0,7050,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,14862,0,0,3492,0,0,0,55878,0,0,0,16486,0,0,0,18119,0,0,0,0,0,0,2154\n+,1284,0,0,23113,31751,0,0,29547,0,0,0,0,0,0,36647,0,0,0,0,0,0,0,0,0,0,0,18183,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,7913,0,0,0,0,20644,0,0,10508,0,0,0,0,0,0,0,0,0,0,0,0,\n+43622,0,0,0,0,0,40966,0,0,0,0,0,0,0,0,0,0,246,901,11529,5191,0,0,0,0,0,0,0,0,0,0\n+,0,24454,0,0,26665,27590,0,27397,0,0,0,0,0,0,23562,2949,0,0,30344,62214,0,47334,\n+2026,18885,0,0,0,48678,0,0,0,22694,0,0,1972,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,15465,0,0,0,0,38822,0,0,0,0,945,32708,0,54791,0,14918,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,23396,0,0,0,0,0,0,5486,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7722,0,0,\n+0,0,0,0,0,0,0,0,0,30856,64166,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35206,0,0,0,30535,0,\n+0,0,0,0,0,0,0,0,62663,0,0,1096,17574,31820,0,0,14375,4402,27207,0,0,21448,4676,0\n+,0,0,0,16585,5094,0,0,0,0,0,0,0,0,4845,0,0,32870,0,0,0,0,0,0,0,0,0,0,31466,0,0,0\n+,0,31783,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4522,16039,0,0,0,0,0,0,0,0,\n+0,14469,0,0,0,0,0,0,0,0,0,0,7464,4773,0,0,0,0,0,0,0,0,18636,0,0,0,25640,0,0,0,0,\n+0,0,2244,0,0,11818,0,1168,0,0,0,0,0,0,0,6540,23079,13770,7719,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,58150,528,\n+34502,32682,0,0,12997,0,0,0,0,0,2214,0,0,0,0,0,58567,0,0,0,26375,0,0,0,0,0,0,0,0\n+,0,26437,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26121,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,32005,22952,59047,0,13543,0,0,0,0,0,0,0,0,16328,0,0,33542,0,0,0,19782,0,0,0,\n+16644,0,0,0,0,31688,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10276,0,0,0,\n+0,0,0,0,36327,0,0,29480,0,0,0,777,12709,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27398,0,0,\n+0,4455,9037,31397,0,9221,0,0,0,60487,20840,1796,0,0,0,0,0,0,0,0,8364,0,0,0,0,0,0\n+,0,0,0,0,0,19752,44902,0,38566,0,0,18027,0,0,0,0,0,0,0,0,10662,0,0,0,0,0,11812,0\n+,0,0,0,0,0,0,0,0,19910,0,0,0,45030,0,0,0,0,0,0,0,0,0,0,0,0,19978,5127,0,11620,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,19817,0,5579,9350,0,0,21002,19718,0,0,0,21926,0,0,0,0,0,0,0,0,0,0,0,0,0,20711,\n+0,0,0,20197,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40550,0,0,0,57510,0,0,0,53895,\n+0,0,15017,0,17000,39367,2347,0,0,0,0,0,0,0,0,0,8588,0,0,0,0,0,3273,17862,3498,\n+2085,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19048,0,0,0,0,0,11978,58631,0,0,0,0\n+,0,0,523,0,12969,198,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28197,0,47846,0,0,0,0,0,0\n+,0,0,0,4549,0,0,0,0,0,0,0,0,0,0,687,14917,748,8229,0,0,0,0,0,0,2476,12935,0,0,0,\n+0,0,0,22792,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27528,59142,0,0,20876,20134,0,0,0,\n+0,440,12068,0,58951,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48038,0,0,0,60999,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,15716,7498,5476,0,0,0,0,20202,37959,0,0,0,0,0,0,0,0,0,0,0,0,\n+29801,0,5451,0,0,0,0,0,0,0,0,0,0,50790,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24485,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13573,0,0,22856,0,0,0,0,21927,0,0,0,0,0\n+,0,9130,0,0,0,0,0,0,13732,0,0,0,0,0,0,0,0,0,0,2282,583,0,0,0,0,0,0,0,0,0,0,3726,\n+26503,0,0,0,0,0,0,9258,0,0,0,0,0,0,0,0,21604,0,0,0,45574,0,0,0,0,0,20710,0,0,0,\n+42694,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1163,6694,0,0,0,0,0,0,0,10948,0,0,0,29700,0,0,\n+0,0,0,58823,3796,27399,20939,10180,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+19,29287,28649,14534,0,0,16428,45607,0,0,0,0,0,0,25322,0,4908,0,0,0,0,0,0,25476,\n+29097,14246,11053,0,0,0,0,0,0,0,0,18502,0,0,0,44390,0,0,0,17765,0,0,0,0,0,0,\n+24520,0,0,0,0,0,0,0,0,0,0,17319,0,0,0,0,0,0,0,0,0,0,0,0,0,28166,0,0,0,0,0,48198,\n+0,0,31467,0,24585,0,0,0,0,18692,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23596,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,7236,968,13637,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+3763,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14791,0,0,0,12324,0,12741,0,0,0\n+,0,0,0,0,0,0,11108,0,0,0,0,4009,40295,20616,4357,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+15015,0,0,0,0,0,43751,0,0,0,0,0,0,0,0,0,0,0,23013,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+45542,0,0,0,0,0,0,0,0,0,23974,0,0,0,0,17480,20647,0,0,0,0,0,0,8876,0,0,40806,0,0\n+,0,0,0,0,0,14502,17160,17764,0,0,31594,35431,0,0,2890,0,0,0,0,0,0,0,0,27524,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8228,0,56583,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,34278,0,0,0,0,0,0,0,0,0,0,0,0,0,2662,0,26724,0,0,0,0,0,0,0,64198,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22281,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3049,\n+54983,0,0,0,0,0,0,0,837,0,17604,0,0,0,0,0,28838,0,0,0,0,0,0,26312,0,0,3910,0,0,0\n+,25830,0,0,0,0,0,8391,0,19845,19240,1092,0,0,5449,0,0,0,0,17188,0,0,0,0,0,0,0,0,\n+0,10629,0,0,6671,61094,5832,8358,0,0,0,55078,0,0,0,0,0,29860,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,51494,0,28647,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,25989,0,0,30153,61318\n+,0,0,0,0,0,0,0,24903,0,0,0,4388,0,42054,0,0,0,0,0,0,0,53158,0,0,0,0,0,0,0,50918,\n+0,0,0,0,0,0,26251,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5929,2853,0,37126,\n+7372,197,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2027,934,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,55686,0,0,5672,5447,0,62758,0,0,0,0,0,0,0,0,0,0,0,0,2923,0,556,1415,\n+0,0,0,0,0,0,0,0,0,8645,0,9477,0,0,0,0,0,0,0,48742,0,0,0,0,0,0,0,0,0,0,24235,228,\n+0,0,0,0,0,0,0,0,0,0,16970,18823,0,0,0,0,0,0,0,0,0,25158,0,0,0,0,0,18567,20072,\n+2823,14313,1830,0,0,0,0,0,0,0,0,27048,23526,0,0,0,0,0,997,492,0,14730,16677,396,\n+13574,0,0,0,41671,0,0,0,0,0,0,0,19045,0,0,0,421,17545,3110,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,47111,14475,56551,0,0,0,0,0,0,0,0,0,0,3697,0,0,0,0,0,0,49382,0,35559,0,\n+0,0,0,40,0,11496,15621,0,8550,0,0,0,63462,0,0,0,0,0,0,0,36966,0,50406,0,46022,\n+1001,0,0,12069,3249,0,0,0,0,0,0,0,0,0,0,0,0,0,15241,0,0,0,0,0,0,0,0,64743,0,0,0,\n+0,0,58759,0,0,0,0,1136,26981,0,0,0,0,0,0,0,17732,0,0,0,17157,20011,6629,0,43879,\n+0,0,0,13572,25128,10759,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28676,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,875,24007,0,0,0,0,7628,0,0,0,0,0,12268,0,0,0,0,0,0,0,0,19300\n+,23210,356,0,0,0,0,0,0,0,0,0,15236,0,0,0,0,0,49670,0,0,0,0,0,0,0,21764,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,13931,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,45799,0,0,436,3589,\n+0,0,11402,0,0,0,0,0,0,0,0,0,0,62822,0,0,0,39814,588,0,0,0,0,0,0,27750,0,0,0,0,0,\n+0,1609,22660,2346,18951,0,16068,0,0,0,0,0,0,5162,11110,0,0,0,0,15048,1060,0,7879\n+,18280,326,0,14886,19656,0,7594,0,0,0,0,0,781,581,0,16198,0,0,0,0,0,0,1078,9892,\n+0,0,0,0,0,0,0,0,0,0,4489,0,0,0,0,33798,0,0,0,54534,0,0,0,0,0,0,0,33158,0,0,0,0,0\n+,0,0,0,0,42086,13834,2757,8456,16773,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3434,0,0,0,\n+0,0,3946,29668,0,0,30634,36775,0,0,0,0,0,24901,0,16069,6280,0,0,0,0,41990,0,0,0,\n+0,0,0,0,27365,0,0,0,0,0,0,0,0,0,0,1450,44807,0,0,0,32100,0,0,0,0,0,35110,0,0,0,0\n+,0,0,0,0,17448,19591,0,0,0,0,0,0,0,0,0,0,0,0,1739,0,0,0,0,5511,0,0,0,32934,0,0,0\n+,0,0,0,0,0,0,18180,0,0,0,23428,19754,0,0,31174,3021,31655,23464,0,0,0,0,0,0,\n+57255,0,0,21292,64487,0,0,0,0,0,0,25802,9189,0,0,0,0,0,49254,0,0,0,0,0,0,0,0,0,0\n+,5837,50023,0,0,0,0,0,0,0,0,0,15495,0,0,0,0,0,51942,0,0,0,0,0,0,0,0,28104,58662,\n+0,50214,0,0,0,0,0,0,0,0,2988,0,22888,31812,0,0,0,0,0,2020,0,18916,0,0,0,0,0,0,0,\n+23973,0,0,0,0,17516,11717,0,0,0,55911,0,0,0,0,0,0,0,2855,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,46822,0,24710,28586,0,0,0,1556,0,0,30117,0,0,22090,57127,3403,14087,0\n+,0,0,0,0,0,0,0,0,0,1041,0,10633,6916,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27269,0,0,13322,18055,0,29380,0,56454,0,0,120\n+,0,0,8773,0,0,0,0,16040,0,0,0,0,0,0,0,27242,23781,0,1572,0,28134,0,0,1512,0,0,0,\n+0,0,0,27684,0,38470,0,0,0,0,0,0,1513,8709,0,0,0,0,0,0,0,0,0,0,0,46566,0,0,0,0,\n+28521,61159,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24356,0,0,0,0,0,0,0,0,0,13028,0,\n+5863,0,0,15693,0,0,0,0,0,0,0,1131,23398,0,0,0,0,0,0,0,26212,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,18404,0,0,0,0,1457,26183,0,0,2475,7110,0,0,0,0,27180,60166,0,0,0,20262,0,\n+41862,0,0,0,0,0,0,0,0,0,0,2762,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26148,0,0,0,0,0,0,0,0\n+,0,28229,0,0,0,29254,0,0,0,0,0,0,0,0,0,0,27690,0,0,13636,12776,1862,0,0,0,0,0,0,\n+17225,3271,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28039,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,4457,18117,0,2023,402,0,0,0,0,0,0,0,0,0,0,0,0,0,104,3654,0,0,\n+0,0,0,0,0,0,18440,0,0,0,0,0,0,0,0,29861,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,22150,0,0,0,0,0,0,0,0,0,0,0,0,24074,0,0,0,0,0,0,0,0,12004,0,32358,\n+0,0,3081,0,0,0,0,0,0,0,0,0,4749,0,0,0,0,0,0,0,0,0,0,0,10792,1799,21322,0,7880,\n+12613,0,0,0,0,0,0,0,0,13993,0,0,0,16202,0,0,0,0,32102,0,37223,0,10500,0,0,0,0,0,\n+0,0,0,32008,0,0,0,0,0,23816,3236,0,0,0,0,0,23237,0,0,5642,0,4684,294,0,0,0,0,0,0\n+,0,0,0,0,0,0,0,0,0,0,0,0,0,26852,0,0,0,0,0,0,7148,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,7890,61798,939,0,0,56679,0,0,0,0,0,27078,202,5029,0,0,0,0,0,\n+0,0,0,0,28005,0,0,15273,24741,5676,20452,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,55910,0,0\n+,0,0,5069,27942,0,21092,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12517,0,0,0,0,0,0,\n+0,0,0,0,0,0,21384,28260,0,2502,20108,0,0,0,0,0,0,0,0,0,0,0,0,46726,0,30790,0,0,0\n+,0,0,14725,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1099,6372,0,0,0,12422,15182,0,8683,0,\n+10665,19462,0,0,0,0,0,0,1590,0,31628,0,22632,19750,0,0,0,0,0,0,0,24198,0,0,0,0,0\n+,50662,0,0,0,0,0,0,0,0,0,0,9131,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11015,0,0,0,0,0,0,0,\n+0,16490,54695,0,0,0,0,0,0,0,0,12937,0,0,0,0,16004,0,0,0,0,0,0,0,0,0,2181,6923,0,\n+0,0,0,0,0,0,15624,11302,0,0,5673,7559,0,0,14668,15684,0,0,0,0,0,0,24204,48134,0,\n+24230,0,55527,0,0,3464,19141,0,0,0,0};\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "b3bb9599f43b336d60b1efd10e63c3b88934cf19",
            "filename": "deps/brotli/c/enc/dictionary_hash.h",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fdictionary_hash.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fdictionary_hash.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fdictionary_hash.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,24 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Hash table on the 4-byte prefixes of static dictionary words. */\n+\n+#ifndef BROTLI_ENC_DICTIONARY_HASH_H_\n+#define BROTLI_ENC_DICTIONARY_HASH_H_\n+\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+extern const uint16_t kStaticDictionaryHash[32768];\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_DICTIONARY_HASH_H_ */"
        },
        {
            "sha": "141e70aa2a31344fd4cd047548a7ae9ed9833c89",
            "filename": "deps/brotli/c/enc/encode.c",
            "status": "added",
            "additions": 1862,
            "deletions": 0,
            "changes": 1862,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fencode.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fencode.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fencode.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,1862 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Implementation of Brotli compressor. */\n+\n+#include <brotli/encode.h>\n+\n+#include <stdlib.h>  /* free, malloc */\n+#include <string.h>  /* memcpy, memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/context.h\"\n+#include \"../common/platform.h\"\n+#include \"../common/version.h\"\n+#include \"./backward_references.h\"\n+#include \"./backward_references_hq.h\"\n+#include \"./bit_cost.h\"\n+#include \"./brotli_bit_stream.h\"\n+#include \"./compress_fragment.h\"\n+#include \"./compress_fragment_two_pass.h\"\n+#include \"./encoder_dict.h\"\n+#include \"./entropy_encode.h\"\n+#include \"./fast_log.h\"\n+#include \"./hash.h\"\n+#include \"./histogram.h\"\n+#include \"./memory.h\"\n+#include \"./metablock.h\"\n+#include \"./prefix.h\"\n+#include \"./quality.h\"\n+#include \"./ringbuffer.h\"\n+#include \"./utf8_util.h\"\n+#include \"./write_bits.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define COPY_ARRAY(dst, src) memcpy(dst, src, sizeof(src));\n+\n+typedef enum BrotliEncoderStreamState {\n+  /* Default state. */\n+  BROTLI_STREAM_PROCESSING = 0,\n+  /* Intermediate state; after next block is emitted, byte-padding should be\n+     performed before getting back to default state. */\n+  BROTLI_STREAM_FLUSH_REQUESTED = 1,\n+  /* Last metablock was produced; no more input is acceptable. */\n+  BROTLI_STREAM_FINISHED = 2,\n+  /* Flushing compressed block and writing meta-data block header. */\n+  BROTLI_STREAM_METADATA_HEAD = 3,\n+  /* Writing metadata block body. */\n+  BROTLI_STREAM_METADATA_BODY = 4\n+} BrotliEncoderStreamState;\n+\n+typedef struct BrotliEncoderStateStruct {\n+  BrotliEncoderParams params;\n+\n+  MemoryManager memory_manager_;\n+\n+  HasherHandle hasher_;\n+  uint64_t input_pos_;\n+  RingBuffer ringbuffer_;\n+  size_t cmd_alloc_size_;\n+  Command* commands_;\n+  size_t num_commands_;\n+  size_t num_literals_;\n+  size_t last_insert_len_;\n+  uint64_t last_flush_pos_;\n+  uint64_t last_processed_pos_;\n+  int dist_cache_[BROTLI_NUM_DISTANCE_SHORT_CODES];\n+  int saved_dist_cache_[4];\n+  uint16_t last_bytes_;\n+  uint8_t last_bytes_bits_;\n+  uint8_t prev_byte_;\n+  uint8_t prev_byte2_;\n+  size_t storage_size_;\n+  uint8_t* storage_;\n+  /* Hash table for FAST_ONE_PASS_COMPRESSION_QUALITY mode. */\n+  int small_table_[1 << 10];  /* 4KiB */\n+  int* large_table_;          /* Allocated only when needed */\n+  size_t large_table_size_;\n+  /* Command and distance prefix codes (each 64 symbols, stored back-to-back)\n+     used for the next block in FAST_ONE_PASS_COMPRESSION_QUALITY. The command\n+     prefix code is over a smaller alphabet with the following 64 symbols:\n+        0 - 15: insert length code 0, copy length code 0 - 15, same distance\n+       16 - 39: insert length code 0, copy length code 0 - 23\n+       40 - 63: insert length code 0 - 23, copy length code 0\n+     Note that symbols 16 and 40 represent the same code in the full alphabet,\n+     but we do not use either of them in FAST_ONE_PASS_COMPRESSION_QUALITY. */\n+  uint8_t cmd_depths_[128];\n+  uint16_t cmd_bits_[128];\n+  /* The compressed form of the command and distance prefix codes for the next\n+     block in FAST_ONE_PASS_COMPRESSION_QUALITY. */\n+  uint8_t cmd_code_[512];\n+  size_t cmd_code_numbits_;\n+  /* Command and literal buffers for FAST_TWO_PASS_COMPRESSION_QUALITY. */\n+  uint32_t* command_buf_;\n+  uint8_t* literal_buf_;\n+\n+  uint8_t* next_out_;\n+  size_t available_out_;\n+  size_t total_out_;\n+  /* Temporary buffer for padding flush bits or metadata block header / body. */\n+  union {\n+    uint64_t u64[2];\n+    uint8_t u8[16];\n+  } tiny_buf_;\n+  uint32_t remaining_metadata_bytes_;\n+  BrotliEncoderStreamState stream_state_;\n+\n+  BROTLI_BOOL is_last_block_emitted_;\n+  BROTLI_BOOL is_initialized_;\n+} BrotliEncoderStateStruct;\n+\n+static BROTLI_BOOL EnsureInitialized(BrotliEncoderState* s);\n+\n+static size_t InputBlockSize(BrotliEncoderState* s) {\n+  return (size_t)1 << s->params.lgblock;\n+}\n+\n+static uint64_t UnprocessedInputSize(BrotliEncoderState* s) {\n+  return s->input_pos_ - s->last_processed_pos_;\n+}\n+\n+static size_t RemainingInputBlockSize(BrotliEncoderState* s) {\n+  const uint64_t delta = UnprocessedInputSize(s);\n+  size_t block_size = InputBlockSize(s);\n+  if (delta >= block_size) return 0;\n+  return block_size - (size_t)delta;\n+}\n+\n+BROTLI_BOOL BrotliEncoderSetParameter(\n+    BrotliEncoderState* state, BrotliEncoderParameter p, uint32_t value) {\n+  /* Changing parameters on the fly is not implemented yet. */\n+  if (state->is_initialized_) return BROTLI_FALSE;\n+  /* TODO: Validate/clamp parameters here. */\n+  switch (p) {\n+    case BROTLI_PARAM_MODE:\n+      state->params.mode = (BrotliEncoderMode)value;\n+      return BROTLI_TRUE;\n+\n+    case BROTLI_PARAM_QUALITY:\n+      state->params.quality = (int)value;\n+      return BROTLI_TRUE;\n+\n+    case BROTLI_PARAM_LGWIN:\n+      state->params.lgwin = (int)value;\n+      return BROTLI_TRUE;\n+\n+    case BROTLI_PARAM_LGBLOCK:\n+      state->params.lgblock = (int)value;\n+      return BROTLI_TRUE;\n+\n+    case BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING:\n+      if ((value != 0) && (value != 1)) return BROTLI_FALSE;\n+      state->params.disable_literal_context_modeling = TO_BROTLI_BOOL(!!value);\n+      return BROTLI_TRUE;\n+\n+    case BROTLI_PARAM_SIZE_HINT:\n+      state->params.size_hint = value;\n+      return BROTLI_TRUE;\n+\n+    case BROTLI_PARAM_LARGE_WINDOW:\n+      state->params.large_window = TO_BROTLI_BOOL(!!value);\n+      return BROTLI_TRUE;\n+\n+    case BROTLI_PARAM_NPOSTFIX:\n+      state->params.dist.distance_postfix_bits = value;\n+      return BROTLI_TRUE;\n+\n+    case BROTLI_PARAM_NDIRECT:\n+      state->params.dist.num_direct_distance_codes = value;\n+      return BROTLI_TRUE;\n+\n+    default: return BROTLI_FALSE;\n+  }\n+}\n+\n+/* Wraps 64-bit input position to 32-bit ring-buffer position preserving\n+   \"not-a-first-lap\" feature. */\n+static uint32_t WrapPosition(uint64_t position) {\n+  uint32_t result = (uint32_t)position;\n+  uint64_t gb = position >> 30;\n+  if (gb > 2) {\n+    /* Wrap every 2GiB; The first 3GB are continuous. */\n+    result = (result & ((1u << 30) - 1)) | ((uint32_t)((gb - 1) & 1) + 1) << 30;\n+  }\n+  return result;\n+}\n+\n+static uint8_t* GetBrotliStorage(BrotliEncoderState* s, size_t size) {\n+  MemoryManager* m = &s->memory_manager_;\n+  if (s->storage_size_ < size) {\n+    BROTLI_FREE(m, s->storage_);\n+    s->storage_ = BROTLI_ALLOC(m, uint8_t, size);\n+    if (BROTLI_IS_OOM(m)) return NULL;\n+    s->storage_size_ = size;\n+  }\n+  return s->storage_;\n+}\n+\n+static size_t HashTableSize(size_t max_table_size, size_t input_size) {\n+  size_t htsize = 256;\n+  while (htsize < max_table_size && htsize < input_size) {\n+    htsize <<= 1;\n+  }\n+  return htsize;\n+}\n+\n+static int* GetHashTable(BrotliEncoderState* s, int quality,\n+                         size_t input_size, size_t* table_size) {\n+  /* Use smaller hash table when input.size() is smaller, since we\n+     fill the table, incurring O(hash table size) overhead for\n+     compression, and if the input is short, we won't need that\n+     many hash table entries anyway. */\n+  MemoryManager* m = &s->memory_manager_;\n+  const size_t max_table_size = MaxHashTableSize(quality);\n+  size_t htsize = HashTableSize(max_table_size, input_size);\n+  int* table;\n+  BROTLI_DCHECK(max_table_size >= 256);\n+  if (quality == FAST_ONE_PASS_COMPRESSION_QUALITY) {\n+    /* Only odd shifts are supported by fast-one-pass. */\n+    if ((htsize & 0xAAAAA) == 0) {\n+      htsize <<= 1;\n+    }\n+  }\n+\n+  if (htsize <= sizeof(s->small_table_) / sizeof(s->small_table_[0])) {\n+    table = s->small_table_;\n+  } else {\n+    if (htsize > s->large_table_size_) {\n+      s->large_table_size_ = htsize;\n+      BROTLI_FREE(m, s->large_table_);\n+      s->large_table_ = BROTLI_ALLOC(m, int, htsize);\n+      if (BROTLI_IS_OOM(m)) return 0;\n+    }\n+    table = s->large_table_;\n+  }\n+\n+  *table_size = htsize;\n+  memset(table, 0, htsize * sizeof(*table));\n+  return table;\n+}\n+\n+static void EncodeWindowBits(int lgwin, BROTLI_BOOL large_window,\n+    uint16_t* last_bytes, uint8_t* last_bytes_bits) {\n+  if (large_window) {\n+    *last_bytes = (uint16_t)(((lgwin & 0x3F) << 8) | 0x11);\n+    *last_bytes_bits = 14;\n+  } else {\n+    if (lgwin == 16) {\n+      *last_bytes = 0;\n+      *last_bytes_bits = 1;\n+    } else if (lgwin == 17) {\n+      *last_bytes = 1;\n+      *last_bytes_bits = 7;\n+    } else if (lgwin > 17) {\n+      *last_bytes = (uint16_t)(((lgwin - 17) << 1) | 0x01);\n+      *last_bytes_bits = 4;\n+    } else {\n+      *last_bytes = (uint16_t)(((lgwin - 8) << 4) | 0x01);\n+      *last_bytes_bits = 7;\n+    }\n+  }\n+}\n+\n+/* Initializes the command and distance prefix codes for the first block. */\n+static void InitCommandPrefixCodes(uint8_t cmd_depths[128],\n+                                   uint16_t cmd_bits[128],\n+                                   uint8_t cmd_code[512],\n+                                   size_t* cmd_code_numbits) {\n+  static const uint8_t kDefaultCommandDepths[128] = {\n+    0, 4, 4, 5, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8,\n+    0, 0, 0, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7,\n+    7, 7, 10, 10, 10, 10, 10, 10, 0, 4, 4, 5, 5, 5, 6, 6,\n+    7, 8, 8, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n+    5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4,\n+    4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 7, 7, 7, 8, 10,\n+    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n+  };\n+  static const uint16_t kDefaultCommandBits[128] = {\n+    0,   0,   8,   9,   3,  35,   7,   71,\n+    39, 103,  23,  47, 175, 111, 239,   31,\n+    0,   0,   0,   4,  12,   2,  10,    6,\n+    13,  29,  11,  43,  27,  59,  87,   55,\n+    15,  79, 319, 831, 191, 703, 447,  959,\n+    0,  14,   1,  25,   5,  21,  19,   51,\n+    119, 159,  95, 223, 479, 991,  63,  575,\n+    127, 639, 383, 895, 255, 767, 511, 1023,\n+    14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    27, 59, 7, 39, 23, 55, 30, 1, 17, 9, 25, 5, 0, 8, 4, 12,\n+    2, 10, 6, 21, 13, 29, 3, 19, 11, 15, 47, 31, 95, 63, 127, 255,\n+    767, 2815, 1791, 3839, 511, 2559, 1535, 3583, 1023, 3071, 2047, 4095,\n+  };\n+  static const uint8_t kDefaultCommandCode[] = {\n+    0xff, 0x77, 0xd5, 0xbf, 0xe7, 0xde, 0xea, 0x9e, 0x51, 0x5d, 0xde, 0xc6,\n+    0x70, 0x57, 0xbc, 0x58, 0x58, 0x58, 0xd8, 0xd8, 0x58, 0xd5, 0xcb, 0x8c,\n+    0xea, 0xe0, 0xc3, 0x87, 0x1f, 0x83, 0xc1, 0x60, 0x1c, 0x67, 0xb2, 0xaa,\n+    0x06, 0x83, 0xc1, 0x60, 0x30, 0x18, 0xcc, 0xa1, 0xce, 0x88, 0x54, 0x94,\n+    0x46, 0xe1, 0xb0, 0xd0, 0x4e, 0xb2, 0xf7, 0x04, 0x00,\n+  };\n+  static const size_t kDefaultCommandCodeNumBits = 448;\n+  COPY_ARRAY(cmd_depths, kDefaultCommandDepths);\n+  COPY_ARRAY(cmd_bits, kDefaultCommandBits);\n+\n+  /* Initialize the pre-compressed form of the command and distance prefix\n+     codes. */\n+  COPY_ARRAY(cmd_code, kDefaultCommandCode);\n+  *cmd_code_numbits = kDefaultCommandCodeNumBits;\n+}\n+\n+/* Decide about the context map based on the ability of the prediction\n+   ability of the previous byte UTF8-prefix on the next byte. The\n+   prediction ability is calculated as Shannon entropy. Here we need\n+   Shannon entropy instead of 'BitsEntropy' since the prefix will be\n+   encoded with the remaining 6 bits of the following byte, and\n+   BitsEntropy will assume that symbol to be stored alone using Huffman\n+   coding. */\n+static void ChooseContextMap(int quality,\n+                             uint32_t* bigram_histo,\n+                             size_t* num_literal_contexts,\n+                             const uint32_t** literal_context_map) {\n+  static const uint32_t kStaticContextMapContinuation[64] = {\n+    1, 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  };\n+  static const uint32_t kStaticContextMapSimpleUTF8[64] = {\n+    0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+  };\n+\n+  uint32_t monogram_histo[3] = { 0 };\n+  uint32_t two_prefix_histo[6] = { 0 };\n+  size_t total;\n+  size_t i;\n+  size_t dummy;\n+  double entropy[4];\n+  for (i = 0; i < 9; ++i) {\n+    monogram_histo[i % 3] += bigram_histo[i];\n+    two_prefix_histo[i % 6] += bigram_histo[i];\n+  }\n+  entropy[1] = ShannonEntropy(monogram_histo, 3, &dummy);\n+  entropy[2] = (ShannonEntropy(two_prefix_histo, 3, &dummy) +\n+                ShannonEntropy(two_prefix_histo + 3, 3, &dummy));\n+  entropy[3] = 0;\n+  for (i = 0; i < 3; ++i) {\n+    entropy[3] += ShannonEntropy(bigram_histo + 3 * i, 3, &dummy);\n+  }\n+\n+  total = monogram_histo[0] + monogram_histo[1] + monogram_histo[2];\n+  BROTLI_DCHECK(total != 0);\n+  entropy[0] = 1.0 / (double)total;\n+  entropy[1] *= entropy[0];\n+  entropy[2] *= entropy[0];\n+  entropy[3] *= entropy[0];\n+\n+  if (quality < MIN_QUALITY_FOR_HQ_CONTEXT_MODELING) {\n+    /* 3 context models is a bit slower, don't use it at lower qualities. */\n+    entropy[3] = entropy[1] * 10;\n+  }\n+  /* If expected savings by symbol are less than 0.2 bits, skip the\n+     context modeling -- in exchange for faster decoding speed. */\n+  if (entropy[1] - entropy[2] < 0.2 &&\n+      entropy[1] - entropy[3] < 0.2) {\n+    *num_literal_contexts = 1;\n+  } else if (entropy[2] - entropy[3] < 0.02) {\n+    *num_literal_contexts = 2;\n+    *literal_context_map = kStaticContextMapSimpleUTF8;\n+  } else {\n+    *num_literal_contexts = 3;\n+    *literal_context_map = kStaticContextMapContinuation;\n+  }\n+}\n+\n+/* Decide if we want to use a more complex static context map containing 13\n+   context values, based on the entropy reduction of histograms over the\n+   first 5 bits of literals. */\n+static BROTLI_BOOL ShouldUseComplexStaticContextMap(const uint8_t* input,\n+    size_t start_pos, size_t length, size_t mask, int quality, size_t size_hint,\n+    size_t* num_literal_contexts, const uint32_t** literal_context_map) {\n+  static const uint32_t kStaticContextMapComplexUTF8[64] = {\n+    11, 11, 12, 12, /* 0 special */\n+    0, 0, 0, 0, /* 4 lf */\n+    1, 1, 9, 9, /* 8 space */\n+    2, 2, 2, 2, /* !, first after space/lf and after something else. */\n+    1, 1, 1, 1, /* \" */\n+    8, 3, 3, 3, /* % */\n+    1, 1, 1, 1, /* ({[ */\n+    2, 2, 2, 2, /* }]) */\n+    8, 4, 4, 4, /* :; */\n+    8, 7, 4, 4, /* . */\n+    8, 0, 0, 0, /* > */\n+    3, 3, 3, 3, /* [0..9] */\n+    5, 5, 10, 5, /* [A-Z] */\n+    5, 5, 10, 5,\n+    6, 6, 6, 6, /* [a-z] */\n+    6, 6, 6, 6,\n+  };\n+  BROTLI_UNUSED(quality);\n+  /* Try the more complex static context map only for long data. */\n+  if (size_hint < (1 << 20)) {\n+    return BROTLI_FALSE;\n+  } else {\n+    const size_t end_pos = start_pos + length;\n+    /* To make entropy calculations faster and to fit on the stack, we collect\n+       histograms over the 5 most significant bits of literals. One histogram\n+       without context and 13 additional histograms for each context value. */\n+    uint32_t combined_histo[32] = { 0 };\n+    uint32_t context_histo[13][32] = { { 0 } };\n+    uint32_t total = 0;\n+    double entropy[3];\n+    size_t dummy;\n+    size_t i;\n+    ContextLut utf8_lut = BROTLI_CONTEXT_LUT(CONTEXT_UTF8);\n+    for (; start_pos + 64 <= end_pos; start_pos += 4096) {\n+      const size_t stride_end_pos = start_pos + 64;\n+      uint8_t prev2 = input[start_pos & mask];\n+      uint8_t prev1 = input[(start_pos + 1) & mask];\n+      size_t pos;\n+      /* To make the analysis of the data faster we only examine 64 byte long\n+         strides at every 4kB intervals. */\n+      for (pos = start_pos + 2; pos < stride_end_pos; ++pos) {\n+        const uint8_t literal = input[pos & mask];\n+        const uint8_t context = (uint8_t)kStaticContextMapComplexUTF8[\n+            BROTLI_CONTEXT(prev1, prev2, utf8_lut)];\n+        ++total;\n+        ++combined_histo[literal >> 3];\n+        ++context_histo[context][literal >> 3];\n+        prev2 = prev1;\n+        prev1 = literal;\n+      }\n+    }\n+    entropy[1] = ShannonEntropy(combined_histo, 32, &dummy);\n+    entropy[2] = 0;\n+    for (i = 0; i < 13; ++i) {\n+      entropy[2] += ShannonEntropy(&context_histo[i][0], 32, &dummy);\n+    }\n+    entropy[0] = 1.0 / (double)total;\n+    entropy[1] *= entropy[0];\n+    entropy[2] *= entropy[0];\n+    /* The triggering heuristics below were tuned by compressing the individual\n+       files of the silesia corpus. If we skip this kind of context modeling\n+       for not very well compressible input (i.e. entropy using context modeling\n+       is 60% of maximal entropy) or if expected savings by symbol are less\n+       than 0.2 bits, then in every case when it triggers, the final compression\n+       ratio is improved. Note however that this heuristics might be too strict\n+       for some cases and could be tuned further. */\n+    if (entropy[2] > 3.0 || entropy[1] - entropy[2] < 0.2) {\n+      return BROTLI_FALSE;\n+    } else {\n+      *num_literal_contexts = 13;\n+      *literal_context_map = kStaticContextMapComplexUTF8;\n+      return BROTLI_TRUE;\n+    }\n+  }\n+}\n+\n+static void DecideOverLiteralContextModeling(const uint8_t* input,\n+    size_t start_pos, size_t length, size_t mask, int quality, size_t size_hint,\n+    size_t* num_literal_contexts, const uint32_t** literal_context_map) {\n+  if (quality < MIN_QUALITY_FOR_CONTEXT_MODELING || length < 64) {\n+    return;\n+  } else if (ShouldUseComplexStaticContextMap(\n+      input, start_pos, length, mask, quality, size_hint,\n+      num_literal_contexts, literal_context_map)) {\n+    /* Context map was already set, nothing else to do. */\n+  } else {\n+    /* Gather bi-gram data of the UTF8 byte prefixes. To make the analysis of\n+       UTF8 data faster we only examine 64 byte long strides at every 4kB\n+       intervals. */\n+    const size_t end_pos = start_pos + length;\n+    uint32_t bigram_prefix_histo[9] = { 0 };\n+    for (; start_pos + 64 <= end_pos; start_pos += 4096) {\n+      static const int lut[4] = { 0, 0, 1, 2 };\n+      const size_t stride_end_pos = start_pos + 64;\n+      int prev = lut[input[start_pos & mask] >> 6] * 3;\n+      size_t pos;\n+      for (pos = start_pos + 1; pos < stride_end_pos; ++pos) {\n+        const uint8_t literal = input[pos & mask];\n+        ++bigram_prefix_histo[prev + lut[literal >> 6]];\n+        prev = lut[literal >> 6] * 3;\n+      }\n+    }\n+    ChooseContextMap(quality, &bigram_prefix_histo[0], num_literal_contexts,\n+                     literal_context_map);\n+  }\n+}\n+\n+static BROTLI_BOOL ShouldCompress(\n+    const uint8_t* data, const size_t mask, const uint64_t last_flush_pos,\n+    const size_t bytes, const size_t num_literals, const size_t num_commands) {\n+  /* TODO: find more precise minimal block overhead. */\n+  if (bytes <= 2) return BROTLI_FALSE;\n+  if (num_commands < (bytes >> 8) + 2) {\n+    if (num_literals > 0.99 * (double)bytes) {\n+      uint32_t literal_histo[256] = { 0 };\n+      static const uint32_t kSampleRate = 13;\n+      static const double kMinEntropy = 7.92;\n+      const double bit_cost_threshold =\n+          (double)bytes * kMinEntropy / kSampleRate;\n+      size_t t = (bytes + kSampleRate - 1) / kSampleRate;\n+      uint32_t pos = (uint32_t)last_flush_pos;\n+      size_t i;\n+      for (i = 0; i < t; i++) {\n+        ++literal_histo[data[pos & mask]];\n+        pos += kSampleRate;\n+      }\n+      if (BitsEntropy(literal_histo, 256) > bit_cost_threshold) {\n+        return BROTLI_FALSE;\n+      }\n+    }\n+  }\n+  return BROTLI_TRUE;\n+}\n+\n+/* Chooses the literal context mode for a metablock */\n+static ContextType ChooseContextMode(const BrotliEncoderParams* params,\n+    const uint8_t* data, const size_t pos, const size_t mask,\n+    const size_t length) {\n+  /* We only do the computation for the option of something else than\n+     CONTEXT_UTF8 for the highest qualities */\n+  if (params->quality >= MIN_QUALITY_FOR_HQ_BLOCK_SPLITTING &&\n+      !BrotliIsMostlyUTF8(data, pos, mask, length, kMinUTF8Ratio)) {\n+    return CONTEXT_SIGNED;\n+  }\n+  return CONTEXT_UTF8;\n+}\n+\n+static void WriteMetaBlockInternal(MemoryManager* m,\n+                                   const uint8_t* data,\n+                                   const size_t mask,\n+                                   const uint64_t last_flush_pos,\n+                                   const size_t bytes,\n+                                   const BROTLI_BOOL is_last,\n+                                   ContextType literal_context_mode,\n+                                   const BrotliEncoderParams* params,\n+                                   const uint8_t prev_byte,\n+                                   const uint8_t prev_byte2,\n+                                   const size_t num_literals,\n+                                   const size_t num_commands,\n+                                   Command* commands,\n+                                   const int* saved_dist_cache,\n+                                   int* dist_cache,\n+                                   size_t* storage_ix,\n+                                   uint8_t* storage) {\n+  const uint32_t wrapped_last_flush_pos = WrapPosition(last_flush_pos);\n+  uint16_t last_bytes;\n+  uint8_t last_bytes_bits;\n+  ContextLut literal_context_lut = BROTLI_CONTEXT_LUT(literal_context_mode);\n+  BrotliEncoderParams block_params = *params;\n+\n+  if (bytes == 0) {\n+    /* Write the ISLAST and ISEMPTY bits. */\n+    BrotliWriteBits(2, 3, storage_ix, storage);\n+    *storage_ix = (*storage_ix + 7u) & ~7u;\n+    return;\n+  }\n+\n+  if (!ShouldCompress(data, mask, last_flush_pos, bytes,\n+                      num_literals, num_commands)) {\n+    /* Restore the distance cache, as its last update by\n+       CreateBackwardReferences is now unused. */\n+    memcpy(dist_cache, saved_dist_cache, 4 * sizeof(dist_cache[0]));\n+    BrotliStoreUncompressedMetaBlock(is_last, data,\n+                                     wrapped_last_flush_pos, mask, bytes,\n+                                     storage_ix, storage);\n+    return;\n+  }\n+\n+  BROTLI_DCHECK(*storage_ix <= 14);\n+  last_bytes = (uint16_t)((storage[1] << 8) | storage[0]);\n+  last_bytes_bits = (uint8_t)(*storage_ix);\n+  if (params->quality <= MAX_QUALITY_FOR_STATIC_ENTROPY_CODES) {\n+    BrotliStoreMetaBlockFast(m, data, wrapped_last_flush_pos,\n+                             bytes, mask, is_last, params,\n+                             commands, num_commands,\n+                             storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+  } else if (params->quality < MIN_QUALITY_FOR_BLOCK_SPLIT) {\n+    BrotliStoreMetaBlockTrivial(m, data, wrapped_last_flush_pos,\n+                                bytes, mask, is_last, params,\n+                                commands, num_commands,\n+                                storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+  } else {\n+    MetaBlockSplit mb;\n+    InitMetaBlockSplit(&mb);\n+    if (params->quality < MIN_QUALITY_FOR_HQ_BLOCK_SPLITTING) {\n+      size_t num_literal_contexts = 1;\n+      const uint32_t* literal_context_map = NULL;\n+      if (!params->disable_literal_context_modeling) {\n+        DecideOverLiteralContextModeling(\n+            data, wrapped_last_flush_pos, bytes, mask, params->quality,\n+            params->size_hint, &num_literal_contexts,\n+            &literal_context_map);\n+      }\n+      BrotliBuildMetaBlockGreedy(m, data, wrapped_last_flush_pos, mask,\n+          prev_byte, prev_byte2, literal_context_lut, num_literal_contexts,\n+          literal_context_map, commands, num_commands, &mb);\n+      if (BROTLI_IS_OOM(m)) return;\n+    } else {\n+      BrotliBuildMetaBlock(m, data, wrapped_last_flush_pos, mask, &block_params,\n+                           prev_byte, prev_byte2,\n+                           commands, num_commands,\n+                           literal_context_mode,\n+                           &mb);\n+      if (BROTLI_IS_OOM(m)) return;\n+    }\n+    if (params->quality >= MIN_QUALITY_FOR_OPTIMIZE_HISTOGRAMS) {\n+      /* The number of distance symbols effectively used for distance\n+         histograms. It might be less than distance alphabet size\n+         for \"Large Window Brotli\" (32-bit). */\n+      uint32_t num_effective_dist_codes = block_params.dist.alphabet_size;\n+      if (num_effective_dist_codes > BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS) {\n+        num_effective_dist_codes = BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS;\n+      }\n+      BrotliOptimizeHistograms(num_effective_dist_codes, &mb);\n+    }\n+    BrotliStoreMetaBlock(m, data, wrapped_last_flush_pos, bytes, mask,\n+                         prev_byte, prev_byte2,\n+                         is_last,\n+                         &block_params,\n+                         literal_context_mode,\n+                         commands, num_commands,\n+                         &mb,\n+                         storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return;\n+    DestroyMetaBlockSplit(m, &mb);\n+  }\n+  if (bytes + 4 < (*storage_ix >> 3)) {\n+    /* Restore the distance cache and last byte. */\n+    memcpy(dist_cache, saved_dist_cache, 4 * sizeof(dist_cache[0]));\n+    storage[0] = (uint8_t)last_bytes;\n+    storage[1] = (uint8_t)(last_bytes >> 8);\n+    *storage_ix = last_bytes_bits;\n+    BrotliStoreUncompressedMetaBlock(is_last, data,\n+                                     wrapped_last_flush_pos, mask,\n+                                     bytes, storage_ix, storage);\n+  }\n+}\n+\n+static void ChooseDistanceParams(BrotliEncoderParams* params) {\n+  uint32_t distance_postfix_bits = 0;\n+  uint32_t num_direct_distance_codes = 0;\n+\n+  if (params->quality >= MIN_QUALITY_FOR_NONZERO_DISTANCE_PARAMS) {\n+    uint32_t ndirect_msb;\n+    if (params->mode == BROTLI_MODE_FONT) {\n+      distance_postfix_bits = 1;\n+      num_direct_distance_codes = 12;\n+    } else {\n+      distance_postfix_bits = params->dist.distance_postfix_bits;\n+      num_direct_distance_codes = params->dist.num_direct_distance_codes;\n+    }\n+    ndirect_msb = (num_direct_distance_codes >> distance_postfix_bits) & 0x0F;\n+    if (distance_postfix_bits > BROTLI_MAX_NPOSTFIX ||\n+        num_direct_distance_codes > BROTLI_MAX_NDIRECT ||\n+        (ndirect_msb << distance_postfix_bits) != num_direct_distance_codes) {\n+      distance_postfix_bits = 0;\n+      num_direct_distance_codes = 0;\n+    }\n+  }\n+\n+  BrotliInitDistanceParams(\n+      params, distance_postfix_bits, num_direct_distance_codes);\n+}\n+\n+static BROTLI_BOOL EnsureInitialized(BrotliEncoderState* s) {\n+  if (BROTLI_IS_OOM(&s->memory_manager_)) return BROTLI_FALSE;\n+  if (s->is_initialized_) return BROTLI_TRUE;\n+\n+  s->last_bytes_bits_ = 0;\n+  s->last_bytes_ = 0;\n+  s->remaining_metadata_bytes_ = BROTLI_UINT32_MAX;\n+\n+  SanitizeParams(&s->params);\n+  s->params.lgblock = ComputeLgBlock(&s->params);\n+  ChooseDistanceParams(&s->params);\n+\n+  RingBufferSetup(&s->params, &s->ringbuffer_);\n+\n+  /* Initialize last byte with stream header. */\n+  {\n+    int lgwin = s->params.lgwin;\n+    if (s->params.quality == FAST_ONE_PASS_COMPRESSION_QUALITY ||\n+        s->params.quality == FAST_TWO_PASS_COMPRESSION_QUALITY) {\n+      lgwin = BROTLI_MAX(int, lgwin, 18);\n+    }\n+    EncodeWindowBits(lgwin, s->params.large_window,\n+                     &s->last_bytes_, &s->last_bytes_bits_);\n+  }\n+\n+  if (s->params.quality == FAST_ONE_PASS_COMPRESSION_QUALITY) {\n+    InitCommandPrefixCodes(s->cmd_depths_, s->cmd_bits_,\n+                           s->cmd_code_, &s->cmd_code_numbits_);\n+  }\n+\n+  s->is_initialized_ = BROTLI_TRUE;\n+  return BROTLI_TRUE;\n+}\n+\n+static void BrotliEncoderInitParams(BrotliEncoderParams* params) {\n+  params->mode = BROTLI_DEFAULT_MODE;\n+  params->large_window = BROTLI_FALSE;\n+  params->quality = BROTLI_DEFAULT_QUALITY;\n+  params->lgwin = BROTLI_DEFAULT_WINDOW;\n+  params->lgblock = 0;\n+  params->size_hint = 0;\n+  params->disable_literal_context_modeling = BROTLI_FALSE;\n+  BrotliInitEncoderDictionary(&params->dictionary);\n+  params->dist.distance_postfix_bits = 0;\n+  params->dist.num_direct_distance_codes = 0;\n+  params->dist.alphabet_size =\n+      BROTLI_DISTANCE_ALPHABET_SIZE(0, 0, BROTLI_MAX_DISTANCE_BITS);\n+  params->dist.max_distance = BROTLI_MAX_DISTANCE;\n+}\n+\n+static void BrotliEncoderInitState(BrotliEncoderState* s) {\n+  BrotliEncoderInitParams(&s->params);\n+  s->input_pos_ = 0;\n+  s->num_commands_ = 0;\n+  s->num_literals_ = 0;\n+  s->last_insert_len_ = 0;\n+  s->last_flush_pos_ = 0;\n+  s->last_processed_pos_ = 0;\n+  s->prev_byte_ = 0;\n+  s->prev_byte2_ = 0;\n+  s->storage_size_ = 0;\n+  s->storage_ = 0;\n+  s->hasher_ = NULL;\n+  s->large_table_ = NULL;\n+  s->large_table_size_ = 0;\n+  s->cmd_code_numbits_ = 0;\n+  s->command_buf_ = NULL;\n+  s->literal_buf_ = NULL;\n+  s->next_out_ = NULL;\n+  s->available_out_ = 0;\n+  s->total_out_ = 0;\n+  s->stream_state_ = BROTLI_STREAM_PROCESSING;\n+  s->is_last_block_emitted_ = BROTLI_FALSE;\n+  s->is_initialized_ = BROTLI_FALSE;\n+\n+  RingBufferInit(&s->ringbuffer_);\n+\n+  s->commands_ = 0;\n+  s->cmd_alloc_size_ = 0;\n+\n+  /* Initialize distance cache. */\n+  s->dist_cache_[0] = 4;\n+  s->dist_cache_[1] = 11;\n+  s->dist_cache_[2] = 15;\n+  s->dist_cache_[3] = 16;\n+  /* Save the state of the distance cache in case we need to restore it for\n+     emitting an uncompressed block. */\n+  memcpy(s->saved_dist_cache_, s->dist_cache_, sizeof(s->saved_dist_cache_));\n+}\n+\n+BrotliEncoderState* BrotliEncoderCreateInstance(\n+    brotli_alloc_func alloc_func, brotli_free_func free_func, void* opaque) {\n+  BrotliEncoderState* state = 0;\n+  if (!alloc_func && !free_func) {\n+    state = (BrotliEncoderState*)malloc(sizeof(BrotliEncoderState));\n+  } else if (alloc_func && free_func) {\n+    state = (BrotliEncoderState*)alloc_func(opaque, sizeof(BrotliEncoderState));\n+  }\n+  if (state == 0) {\n+    /* BROTLI_DUMP(); */\n+    return 0;\n+  }\n+  BrotliInitMemoryManager(\n+      &state->memory_manager_, alloc_func, free_func, opaque);\n+  BrotliEncoderInitState(state);\n+  return state;\n+}\n+\n+static void BrotliEncoderCleanupState(BrotliEncoderState* s) {\n+  MemoryManager* m = &s->memory_manager_;\n+  if (BROTLI_IS_OOM(m)) {\n+    BrotliWipeOutMemoryManager(m);\n+    return;\n+  }\n+  BROTLI_FREE(m, s->storage_);\n+  BROTLI_FREE(m, s->commands_);\n+  RingBufferFree(m, &s->ringbuffer_);\n+  DestroyHasher(m, &s->hasher_);\n+  BROTLI_FREE(m, s->large_table_);\n+  BROTLI_FREE(m, s->command_buf_);\n+  BROTLI_FREE(m, s->literal_buf_);\n+}\n+\n+/* Deinitializes and frees BrotliEncoderState instance. */\n+void BrotliEncoderDestroyInstance(BrotliEncoderState* state) {\n+  if (!state) {\n+    return;\n+  } else {\n+    MemoryManager* m = &state->memory_manager_;\n+    brotli_free_func free_func = m->free_func;\n+    void* opaque = m->opaque;\n+    BrotliEncoderCleanupState(state);\n+    free_func(opaque, state);\n+  }\n+}\n+\n+/*\n+   Copies the given input data to the internal ring buffer of the compressor.\n+   No processing of the data occurs at this time and this function can be\n+   called multiple times before calling WriteBrotliData() to process the\n+   accumulated input. At most input_block_size() bytes of input data can be\n+   copied to the ring buffer, otherwise the next WriteBrotliData() will fail.\n+ */\n+static void CopyInputToRingBuffer(BrotliEncoderState* s,\n+                                  const size_t input_size,\n+                                  const uint8_t* input_buffer) {\n+  RingBuffer* ringbuffer_ = &s->ringbuffer_;\n+  MemoryManager* m = &s->memory_manager_;\n+  RingBufferWrite(m, input_buffer, input_size, ringbuffer_);\n+  if (BROTLI_IS_OOM(m)) return;\n+  s->input_pos_ += input_size;\n+\n+  /* TL;DR: If needed, initialize 7 more bytes in the ring buffer to make the\n+     hashing not depend on uninitialized data. This makes compression\n+     deterministic and it prevents uninitialized memory warnings in Valgrind.\n+     Even without erasing, the output would be valid (but nondeterministic).\n+\n+     Background information: The compressor stores short (at most 8 bytes)\n+     substrings of the input already read in a hash table, and detects\n+     repetitions by looking up such substrings in the hash table. If it\n+     can find a substring, it checks whether the substring is really there\n+     in the ring buffer (or it's just a hash collision). Should the hash\n+     table become corrupt, this check makes sure that the output is\n+     still valid, albeit the compression ratio would be bad.\n+\n+     The compressor populates the hash table from the ring buffer as it's\n+     reading new bytes from the input. However, at the last few indexes of\n+     the ring buffer, there are not enough bytes to build full-length\n+     substrings from. Since the hash table always contains full-length\n+     substrings, we erase with dummy zeros here to make sure that those\n+     substrings will contain zeros at the end instead of uninitialized\n+     data.\n+\n+     Please note that erasing is not necessary (because the\n+     memory region is already initialized since he ring buffer\n+     has a `tail' that holds a copy of the beginning,) so we\n+     skip erasing if we have already gone around at least once in\n+     the ring buffer.\n+\n+     Only clear during the first round of ring-buffer writes. On\n+     subsequent rounds data in the ring-buffer would be affected. */\n+  if (ringbuffer_->pos_ <= ringbuffer_->mask_) {\n+    /* This is the first time when the ring buffer is being written.\n+       We clear 7 bytes just after the bytes that have been copied from\n+       the input buffer.\n+\n+       The ring-buffer has a \"tail\" that holds a copy of the beginning,\n+       but only once the ring buffer has been fully written once, i.e.,\n+       pos <= mask. For the first time, we need to write values\n+       in this tail (where index may be larger than mask), so that\n+       we have exactly defined behavior and don't read uninitialized\n+       memory. Due to performance reasons, hashing reads data using a\n+       LOAD64, which can go 7 bytes beyond the bytes written in the\n+       ring-buffer. */\n+    memset(ringbuffer_->buffer_ + ringbuffer_->pos_, 0, 7);\n+  }\n+}\n+\n+/* Marks all input as processed.\n+   Returns true if position wrapping occurs. */\n+static BROTLI_BOOL UpdateLastProcessedPos(BrotliEncoderState* s) {\n+  uint32_t wrapped_last_processed_pos = WrapPosition(s->last_processed_pos_);\n+  uint32_t wrapped_input_pos = WrapPosition(s->input_pos_);\n+  s->last_processed_pos_ = s->input_pos_;\n+  return TO_BROTLI_BOOL(wrapped_input_pos < wrapped_last_processed_pos);\n+}\n+\n+static void ExtendLastCommand(BrotliEncoderState* s, uint32_t* bytes,\n+                              uint32_t* wrapped_last_processed_pos) {\n+  Command* last_command = &s->commands_[s->num_commands_ - 1];\n+  const uint8_t* data = s->ringbuffer_.buffer_;\n+  const uint32_t mask = s->ringbuffer_.mask_;\n+  uint64_t max_backward_distance =\n+      (((uint64_t)1) << s->params.lgwin) - BROTLI_WINDOW_GAP;\n+  uint64_t last_copy_len = last_command->copy_len_ & 0x1FFFFFF;\n+  uint64_t last_processed_pos = s->last_processed_pos_ - last_copy_len;\n+  uint64_t max_distance = last_processed_pos < max_backward_distance ?\n+      last_processed_pos : max_backward_distance;\n+  uint64_t cmd_dist = (uint64_t)s->dist_cache_[0];\n+  uint32_t distance_code = CommandRestoreDistanceCode(last_command,\n+                                                      &s->params.dist);\n+  if (distance_code < BROTLI_NUM_DISTANCE_SHORT_CODES ||\n+      distance_code - (BROTLI_NUM_DISTANCE_SHORT_CODES - 1) == cmd_dist) {\n+    if (cmd_dist <= max_distance) {\n+      while (*bytes != 0 && data[*wrapped_last_processed_pos & mask] ==\n+             data[(*wrapped_last_processed_pos - cmd_dist) & mask]) {\n+        last_command->copy_len_++;\n+        (*bytes)--;\n+        (*wrapped_last_processed_pos)++;\n+      }\n+    }\n+    /* The copy length is at most the metablock size, and thus expressible. */\n+    GetLengthCode(last_command->insert_len_,\n+                  (size_t)((int)(last_command->copy_len_ & 0x1FFFFFF) +\n+                           (int)(last_command->copy_len_ >> 25)),\n+                  TO_BROTLI_BOOL((last_command->dist_prefix_ & 0x3FF) == 0),\n+                  &last_command->cmd_prefix_);\n+  }\n+}\n+\n+/*\n+   Processes the accumulated input data and sets |*out_size| to the length of\n+   the new output meta-block, or to zero if no new output meta-block has been\n+   created (in this case the processed input data is buffered internally).\n+   If |*out_size| is positive, |*output| points to the start of the output\n+   data. If |is_last| or |force_flush| is BROTLI_TRUE, an output meta-block is\n+   always created. However, until |is_last| is BROTLI_TRUE encoder may retain up\n+   to 7 bits of the last byte of output. To force encoder to dump the remaining\n+   bits use WriteMetadata() to append an empty meta-data block.\n+   Returns BROTLI_FALSE if the size of the input data is larger than\n+   input_block_size().\n+ */\n+static BROTLI_BOOL EncodeData(\n+    BrotliEncoderState* s, const BROTLI_BOOL is_last,\n+    const BROTLI_BOOL force_flush, size_t* out_size, uint8_t** output) {\n+  const uint64_t delta = UnprocessedInputSize(s);\n+  uint32_t bytes = (uint32_t)delta;\n+  uint32_t wrapped_last_processed_pos = WrapPosition(s->last_processed_pos_);\n+  uint8_t* data;\n+  uint32_t mask;\n+  MemoryManager* m = &s->memory_manager_;\n+  ContextType literal_context_mode;\n+\n+  data = s->ringbuffer_.buffer_;\n+  mask = s->ringbuffer_.mask_;\n+\n+  /* Adding more blocks after \"last\" block is forbidden. */\n+  if (s->is_last_block_emitted_) return BROTLI_FALSE;\n+  if (is_last) s->is_last_block_emitted_ = BROTLI_TRUE;\n+\n+  if (delta > InputBlockSize(s)) {\n+    return BROTLI_FALSE;\n+  }\n+  if (s->params.quality == FAST_TWO_PASS_COMPRESSION_QUALITY &&\n+      !s->command_buf_) {\n+    s->command_buf_ =\n+        BROTLI_ALLOC(m, uint32_t, kCompressFragmentTwoPassBlockSize);\n+    s->literal_buf_ =\n+        BROTLI_ALLOC(m, uint8_t, kCompressFragmentTwoPassBlockSize);\n+    if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+  }\n+\n+  if (s->params.quality == FAST_ONE_PASS_COMPRESSION_QUALITY ||\n+      s->params.quality == FAST_TWO_PASS_COMPRESSION_QUALITY) {\n+    uint8_t* storage;\n+    size_t storage_ix = s->last_bytes_bits_;\n+    size_t table_size;\n+    int* table;\n+\n+    if (delta == 0 && !is_last) {\n+      /* We have no new input data and we don't have to finish the stream, so\n+         nothing to do. */\n+      *out_size = 0;\n+      return BROTLI_TRUE;\n+    }\n+    storage = GetBrotliStorage(s, 2 * bytes + 503);\n+    if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+    storage[0] = (uint8_t)s->last_bytes_;\n+    storage[1] = (uint8_t)(s->last_bytes_ >> 8);\n+    table = GetHashTable(s, s->params.quality, bytes, &table_size);\n+    if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+    if (s->params.quality == FAST_ONE_PASS_COMPRESSION_QUALITY) {\n+      BrotliCompressFragmentFast(\n+          m, &data[wrapped_last_processed_pos & mask],\n+          bytes, is_last,\n+          table, table_size,\n+          s->cmd_depths_, s->cmd_bits_,\n+          &s->cmd_code_numbits_, s->cmd_code_,\n+          &storage_ix, storage);\n+      if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+    } else {\n+      BrotliCompressFragmentTwoPass(\n+          m, &data[wrapped_last_processed_pos & mask],\n+          bytes, is_last,\n+          s->command_buf_, s->literal_buf_,\n+          table, table_size,\n+          &storage_ix, storage);\n+      if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+    }\n+    s->last_bytes_ = (uint16_t)(storage[storage_ix >> 3]);\n+    s->last_bytes_bits_ = storage_ix & 7u;\n+    UpdateLastProcessedPos(s);\n+    *output = &storage[0];\n+    *out_size = storage_ix >> 3;\n+    return BROTLI_TRUE;\n+  }\n+\n+  {\n+    /* Theoretical max number of commands is 1 per 2 bytes. */\n+    size_t newsize = s->num_commands_ + bytes / 2 + 1;\n+    if (newsize > s->cmd_alloc_size_) {\n+      Command* new_commands;\n+      /* Reserve a bit more memory to allow merging with a next block\n+         without reallocation: that would impact speed. */\n+      newsize += (bytes / 4) + 16;\n+      s->cmd_alloc_size_ = newsize;\n+      new_commands = BROTLI_ALLOC(m, Command, newsize);\n+      if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+      if (s->commands_) {\n+        memcpy(new_commands, s->commands_, sizeof(Command) * s->num_commands_);\n+        BROTLI_FREE(m, s->commands_);\n+      }\n+      s->commands_ = new_commands;\n+    }\n+  }\n+\n+  InitOrStitchToPreviousBlock(m, &s->hasher_, data, mask, &s->params,\n+      wrapped_last_processed_pos, bytes, is_last);\n+\n+  literal_context_mode = ChooseContextMode(\n+      &s->params, data, WrapPosition(s->last_flush_pos_),\n+      mask, (size_t)(s->input_pos_ - s->last_flush_pos_));\n+\n+  if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+\n+  if (s->num_commands_ && s->last_insert_len_ == 0) {\n+    ExtendLastCommand(s, &bytes, &wrapped_last_processed_pos);\n+  }\n+\n+  if (s->params.quality == ZOPFLIFICATION_QUALITY) {\n+    BROTLI_DCHECK(s->params.hasher.type == 10);\n+    BrotliCreateZopfliBackwardReferences(m, bytes, wrapped_last_processed_pos,\n+        data, mask, &s->params, s->hasher_, s->dist_cache_,\n+        &s->last_insert_len_, &s->commands_[s->num_commands_],\n+        &s->num_commands_, &s->num_literals_);\n+    if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+  } else if (s->params.quality == HQ_ZOPFLIFICATION_QUALITY) {\n+    BROTLI_DCHECK(s->params.hasher.type == 10);\n+    BrotliCreateHqZopfliBackwardReferences(m, bytes, wrapped_last_processed_pos,\n+        data, mask, &s->params, s->hasher_, s->dist_cache_,\n+        &s->last_insert_len_, &s->commands_[s->num_commands_],\n+        &s->num_commands_, &s->num_literals_);\n+    if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+  } else {\n+    BrotliCreateBackwardReferences(bytes, wrapped_last_processed_pos,\n+        data, mask, &s->params, s->hasher_, s->dist_cache_,\n+        &s->last_insert_len_, &s->commands_[s->num_commands_],\n+        &s->num_commands_, &s->num_literals_);\n+  }\n+\n+  {\n+    const size_t max_length = MaxMetablockSize(&s->params);\n+    const size_t max_literals = max_length / 8;\n+    const size_t max_commands = max_length / 8;\n+    const size_t processed_bytes = (size_t)(s->input_pos_ - s->last_flush_pos_);\n+    /* If maximal possible additional block doesn't fit metablock, flush now. */\n+    /* TODO: Postpone decision until next block arrives? */\n+    const BROTLI_BOOL next_input_fits_metablock = TO_BROTLI_BOOL(\n+        processed_bytes + InputBlockSize(s) <= max_length);\n+    /* If block splitting is not used, then flush as soon as there is some\n+       amount of commands / literals produced. */\n+    const BROTLI_BOOL should_flush = TO_BROTLI_BOOL(\n+        s->params.quality < MIN_QUALITY_FOR_BLOCK_SPLIT &&\n+        s->num_literals_ + s->num_commands_ >= MAX_NUM_DELAYED_SYMBOLS);\n+    if (!is_last && !force_flush && !should_flush &&\n+        next_input_fits_metablock &&\n+        s->num_literals_ < max_literals &&\n+        s->num_commands_ < max_commands) {\n+      /* Merge with next input block. Everything will happen later. */\n+      if (UpdateLastProcessedPos(s)) {\n+        HasherReset(s->hasher_);\n+      }\n+      *out_size = 0;\n+      return BROTLI_TRUE;\n+    }\n+  }\n+\n+  /* Create the last insert-only command. */\n+  if (s->last_insert_len_ > 0) {\n+    InitInsertCommand(&s->commands_[s->num_commands_++], s->last_insert_len_);\n+    s->num_literals_ += s->last_insert_len_;\n+    s->last_insert_len_ = 0;\n+  }\n+\n+  if (!is_last && s->input_pos_ == s->last_flush_pos_) {\n+    /* We have no new input data and we don't have to finish the stream, so\n+       nothing to do. */\n+    *out_size = 0;\n+    return BROTLI_TRUE;\n+  }\n+  BROTLI_DCHECK(s->input_pos_ >= s->last_flush_pos_);\n+  BROTLI_DCHECK(s->input_pos_ > s->last_flush_pos_ || is_last);\n+  BROTLI_DCHECK(s->input_pos_ - s->last_flush_pos_ <= 1u << 24);\n+  {\n+    const uint32_t metablock_size =\n+        (uint32_t)(s->input_pos_ - s->last_flush_pos_);\n+    uint8_t* storage = GetBrotliStorage(s, 2 * metablock_size + 503);\n+    size_t storage_ix = s->last_bytes_bits_;\n+    if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+    storage[0] = (uint8_t)s->last_bytes_;\n+    storage[1] = (uint8_t)(s->last_bytes_ >> 8);\n+    WriteMetaBlockInternal(\n+        m, data, mask, s->last_flush_pos_, metablock_size, is_last,\n+        literal_context_mode, &s->params, s->prev_byte_, s->prev_byte2_,\n+        s->num_literals_, s->num_commands_, s->commands_, s->saved_dist_cache_,\n+        s->dist_cache_, &storage_ix, storage);\n+    if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+    s->last_bytes_ = (uint16_t)(storage[storage_ix >> 3]);\n+    s->last_bytes_bits_ = storage_ix & 7u;\n+    s->last_flush_pos_ = s->input_pos_;\n+    if (UpdateLastProcessedPos(s)) {\n+      HasherReset(s->hasher_);\n+    }\n+    if (s->last_flush_pos_ > 0) {\n+      s->prev_byte_ = data[((uint32_t)s->last_flush_pos_ - 1) & mask];\n+    }\n+    if (s->last_flush_pos_ > 1) {\n+      s->prev_byte2_ = data[(uint32_t)(s->last_flush_pos_ - 2) & mask];\n+    }\n+    s->num_commands_ = 0;\n+    s->num_literals_ = 0;\n+    /* Save the state of the distance cache in case we need to restore it for\n+       emitting an uncompressed block. */\n+    memcpy(s->saved_dist_cache_, s->dist_cache_, sizeof(s->saved_dist_cache_));\n+    *output = &storage[0];\n+    *out_size = storage_ix >> 3;\n+    return BROTLI_TRUE;\n+  }\n+}\n+\n+/* Dumps remaining output bits and metadata header to |header|.\n+   Returns number of produced bytes.\n+   REQUIRED: |header| should be 8-byte aligned and at least 16 bytes long.\n+   REQUIRED: |block_size| <= (1 << 24). */\n+static size_t WriteMetadataHeader(\n+    BrotliEncoderState* s, const size_t block_size, uint8_t* header) {\n+  size_t storage_ix;\n+  storage_ix = s->last_bytes_bits_;\n+  header[0] = (uint8_t)s->last_bytes_;\n+  header[1] = (uint8_t)(s->last_bytes_ >> 8);\n+  s->last_bytes_ = 0;\n+  s->last_bytes_bits_ = 0;\n+\n+  BrotliWriteBits(1, 0, &storage_ix, header);\n+  BrotliWriteBits(2, 3, &storage_ix, header);\n+  BrotliWriteBits(1, 0, &storage_ix, header);\n+  if (block_size == 0) {\n+    BrotliWriteBits(2, 0, &storage_ix, header);\n+  } else {\n+    uint32_t nbits = (block_size == 1) ? 0 :\n+        (Log2FloorNonZero((uint32_t)block_size - 1) + 1);\n+    uint32_t nbytes = (nbits + 7) / 8;\n+    BrotliWriteBits(2, nbytes, &storage_ix, header);\n+    BrotliWriteBits(8 * nbytes, block_size - 1, &storage_ix, header);\n+  }\n+  return (storage_ix + 7u) >> 3;\n+}\n+\n+static BROTLI_BOOL BrotliCompressBufferQuality10(\n+    int lgwin, size_t input_size, const uint8_t* input_buffer,\n+    size_t* encoded_size, uint8_t* encoded_buffer) {\n+  MemoryManager memory_manager;\n+  MemoryManager* m = &memory_manager;\n+\n+  const size_t mask = BROTLI_SIZE_MAX >> 1;\n+  int dist_cache[4] = { 4, 11, 15, 16 };\n+  int saved_dist_cache[4] = { 4, 11, 15, 16 };\n+  BROTLI_BOOL ok = BROTLI_TRUE;\n+  const size_t max_out_size = *encoded_size;\n+  size_t total_out_size = 0;\n+  uint16_t last_bytes;\n+  uint8_t last_bytes_bits;\n+  HasherHandle hasher = NULL;\n+\n+  const size_t hasher_eff_size = BROTLI_MIN(size_t,\n+      input_size, BROTLI_MAX_BACKWARD_LIMIT(lgwin) + BROTLI_WINDOW_GAP);\n+\n+  BrotliEncoderParams params;\n+\n+  const int lgmetablock = BROTLI_MIN(int, 24, lgwin + 1);\n+  size_t max_block_size;\n+  const size_t max_metablock_size = (size_t)1 << lgmetablock;\n+  const size_t max_literals_per_metablock = max_metablock_size / 8;\n+  const size_t max_commands_per_metablock = max_metablock_size / 8;\n+  size_t metablock_start = 0;\n+  uint8_t prev_byte = 0;\n+  uint8_t prev_byte2 = 0;\n+\n+  BrotliEncoderInitParams(&params);\n+  params.quality = 10;\n+  params.lgwin = lgwin;\n+  if (lgwin > BROTLI_MAX_WINDOW_BITS) {\n+    params.large_window = BROTLI_TRUE;\n+  }\n+  SanitizeParams(&params);\n+  params.lgblock = ComputeLgBlock(&params);\n+  ChooseDistanceParams(&params);\n+  max_block_size = (size_t)1 << params.lgblock;\n+\n+  BrotliInitMemoryManager(m, 0, 0, 0);\n+\n+  BROTLI_DCHECK(input_size <= mask + 1);\n+  EncodeWindowBits(lgwin, params.large_window, &last_bytes, &last_bytes_bits);\n+  InitOrStitchToPreviousBlock(m, &hasher, input_buffer, mask, &params,\n+      0, hasher_eff_size, BROTLI_TRUE);\n+  if (BROTLI_IS_OOM(m)) goto oom;\n+\n+  while (ok && metablock_start < input_size) {\n+    const size_t metablock_end =\n+        BROTLI_MIN(size_t, input_size, metablock_start + max_metablock_size);\n+    const size_t expected_num_commands =\n+        (metablock_end - metablock_start) / 12 + 16;\n+    Command* commands = 0;\n+    size_t num_commands = 0;\n+    size_t last_insert_len = 0;\n+    size_t num_literals = 0;\n+    size_t metablock_size = 0;\n+    size_t cmd_alloc_size = 0;\n+    BROTLI_BOOL is_last;\n+    uint8_t* storage;\n+    size_t storage_ix;\n+\n+    ContextType literal_context_mode = ChooseContextMode(&params,\n+        input_buffer, metablock_start, mask, metablock_end - metablock_start);\n+\n+    size_t block_start;\n+    for (block_start = metablock_start; block_start < metablock_end; ) {\n+      size_t block_size =\n+          BROTLI_MIN(size_t, metablock_end - block_start, max_block_size);\n+      ZopfliNode* nodes = BROTLI_ALLOC(m, ZopfliNode, block_size + 1);\n+      size_t path_size;\n+      size_t new_cmd_alloc_size;\n+      if (BROTLI_IS_OOM(m)) goto oom;\n+      BrotliInitZopfliNodes(nodes, block_size + 1);\n+      StitchToPreviousBlockH10(hasher, block_size, block_start,\n+                               input_buffer, mask);\n+      path_size = BrotliZopfliComputeShortestPath(m, block_size, block_start,\n+          input_buffer, mask, &params, dist_cache, hasher,\n+          nodes);\n+      if (BROTLI_IS_OOM(m)) goto oom;\n+      /* We allocate a command buffer in the first iteration of this loop that\n+         will be likely big enough for the whole metablock, so that for most\n+         inputs we will not have to reallocate in later iterations. We do the\n+         allocation here and not before the loop, because if the input is small,\n+         this will be allocated after the Zopfli cost model is freed, so this\n+         will not increase peak memory usage.\n+         TODO: If the first allocation is too small, increase command\n+         buffer size exponentially. */\n+      new_cmd_alloc_size = BROTLI_MAX(size_t, expected_num_commands,\n+                                      num_commands + path_size + 1);\n+      if (cmd_alloc_size != new_cmd_alloc_size) {\n+        Command* new_commands = BROTLI_ALLOC(m, Command, new_cmd_alloc_size);\n+        if (BROTLI_IS_OOM(m)) goto oom;\n+        cmd_alloc_size = new_cmd_alloc_size;\n+        if (commands) {\n+          memcpy(new_commands, commands, sizeof(Command) * num_commands);\n+          BROTLI_FREE(m, commands);\n+        }\n+        commands = new_commands;\n+      }\n+      BrotliZopfliCreateCommands(block_size, block_start, &nodes[0], dist_cache,\n+          &last_insert_len, &params, &commands[num_commands], &num_literals);\n+      num_commands += path_size;\n+      block_start += block_size;\n+      metablock_size += block_size;\n+      BROTLI_FREE(m, nodes);\n+      if (num_literals > max_literals_per_metablock ||\n+          num_commands > max_commands_per_metablock) {\n+        break;\n+      }\n+    }\n+\n+    if (last_insert_len > 0) {\n+      InitInsertCommand(&commands[num_commands++], last_insert_len);\n+      num_literals += last_insert_len;\n+    }\n+\n+    is_last = TO_BROTLI_BOOL(metablock_start + metablock_size == input_size);\n+    storage = NULL;\n+    storage_ix = last_bytes_bits;\n+\n+    if (metablock_size == 0) {\n+      /* Write the ISLAST and ISEMPTY bits. */\n+      storage = BROTLI_ALLOC(m, uint8_t, 16);\n+      if (BROTLI_IS_OOM(m)) goto oom;\n+      storage[0] = (uint8_t)last_bytes;\n+      storage[1] = (uint8_t)(last_bytes >> 8);\n+      BrotliWriteBits(2, 3, &storage_ix, storage);\n+      storage_ix = (storage_ix + 7u) & ~7u;\n+    } else if (!ShouldCompress(input_buffer, mask, metablock_start,\n+                               metablock_size, num_literals, num_commands)) {\n+      /* Restore the distance cache, as its last update by\n+         CreateBackwardReferences is now unused. */\n+      memcpy(dist_cache, saved_dist_cache, 4 * sizeof(dist_cache[0]));\n+      storage = BROTLI_ALLOC(m, uint8_t, metablock_size + 16);\n+      if (BROTLI_IS_OOM(m)) goto oom;\n+      storage[0] = (uint8_t)last_bytes;\n+      storage[1] = (uint8_t)(last_bytes >> 8);\n+      BrotliStoreUncompressedMetaBlock(is_last, input_buffer,\n+                                       metablock_start, mask, metablock_size,\n+                                       &storage_ix, storage);\n+    } else {\n+      MetaBlockSplit mb;\n+      BrotliEncoderParams block_params = params;\n+      InitMetaBlockSplit(&mb);\n+      BrotliBuildMetaBlock(m, input_buffer, metablock_start, mask,\n+                           &block_params,\n+                           prev_byte, prev_byte2,\n+                           commands, num_commands,\n+                           literal_context_mode,\n+                           &mb);\n+      if (BROTLI_IS_OOM(m)) goto oom;\n+      {\n+        /* The number of distance symbols effectively used for distance\n+           histograms. It might be less than distance alphabet size\n+           for \"Large Window Brotli\" (32-bit). */\n+        uint32_t num_effective_dist_codes = block_params.dist.alphabet_size;\n+        if (num_effective_dist_codes > BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS) {\n+          num_effective_dist_codes = BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS;\n+        }\n+        BrotliOptimizeHistograms(num_effective_dist_codes, &mb);\n+      }\n+      storage = BROTLI_ALLOC(m, uint8_t, 2 * metablock_size + 503);\n+      if (BROTLI_IS_OOM(m)) goto oom;\n+      storage[0] = (uint8_t)last_bytes;\n+      storage[1] = (uint8_t)(last_bytes >> 8);\n+      BrotliStoreMetaBlock(m, input_buffer, metablock_start, metablock_size,\n+                           mask, prev_byte, prev_byte2,\n+                           is_last,\n+                           &block_params,\n+                           literal_context_mode,\n+                           commands, num_commands,\n+                           &mb,\n+                           &storage_ix, storage);\n+      if (BROTLI_IS_OOM(m)) goto oom;\n+      if (metablock_size + 4 < (storage_ix >> 3)) {\n+        /* Restore the distance cache and last byte. */\n+        memcpy(dist_cache, saved_dist_cache, 4 * sizeof(dist_cache[0]));\n+        storage[0] = (uint8_t)last_bytes;\n+        storage[1] = (uint8_t)(last_bytes >> 8);\n+        storage_ix = last_bytes_bits;\n+        BrotliStoreUncompressedMetaBlock(is_last, input_buffer,\n+                                         metablock_start, mask,\n+                                         metablock_size, &storage_ix, storage);\n+      }\n+      DestroyMetaBlockSplit(m, &mb);\n+    }\n+    last_bytes = (uint16_t)(storage[storage_ix >> 3]);\n+    last_bytes_bits = storage_ix & 7u;\n+    metablock_start += metablock_size;\n+    if (metablock_start < input_size) {\n+      prev_byte = input_buffer[metablock_start - 1];\n+      prev_byte2 = input_buffer[metablock_start - 2];\n+    }\n+    /* Save the state of the distance cache in case we need to restore it for\n+       emitting an uncompressed block. */\n+    memcpy(saved_dist_cache, dist_cache, 4 * sizeof(dist_cache[0]));\n+\n+    {\n+      const size_t out_size = storage_ix >> 3;\n+      total_out_size += out_size;\n+      if (total_out_size <= max_out_size) {\n+        memcpy(encoded_buffer, storage, out_size);\n+        encoded_buffer += out_size;\n+      } else {\n+        ok = BROTLI_FALSE;\n+      }\n+    }\n+    BROTLI_FREE(m, storage);\n+    BROTLI_FREE(m, commands);\n+  }\n+\n+  *encoded_size = total_out_size;\n+  DestroyHasher(m, &hasher);\n+  return ok;\n+\n+oom:\n+  BrotliWipeOutMemoryManager(m);\n+  return BROTLI_FALSE;\n+}\n+\n+size_t BrotliEncoderMaxCompressedSize(size_t input_size) {\n+  /* [window bits / empty metadata] + N * [uncompressed] + [last empty] */\n+  size_t num_large_blocks = input_size >> 14;\n+  size_t overhead = 2 + (4 * num_large_blocks) + 3 + 1;\n+  size_t result = input_size + overhead;\n+  if (input_size == 0) return 2;\n+  return (result < input_size) ? 0 : result;\n+}\n+\n+/* Wraps data to uncompressed brotli stream with minimal window size.\n+   |output| should point at region with at least BrotliEncoderMaxCompressedSize\n+   addressable bytes.\n+   Returns the length of stream. */\n+static size_t MakeUncompressedStream(\n+    const uint8_t* input, size_t input_size, uint8_t* output) {\n+  size_t size = input_size;\n+  size_t result = 0;\n+  size_t offset = 0;\n+  if (input_size == 0) {\n+    output[0] = 6;\n+    return 1;\n+  }\n+  output[result++] = 0x21;  /* window bits = 10, is_last = false */\n+  output[result++] = 0x03;  /* empty metadata, padding */\n+  while (size > 0) {\n+    uint32_t nibbles = 0;\n+    uint32_t chunk_size;\n+    uint32_t bits;\n+    chunk_size = (size > (1u << 24)) ? (1u << 24) : (uint32_t)size;\n+    if (chunk_size > (1u << 16)) nibbles = (chunk_size > (1u << 20)) ? 2 : 1;\n+    bits =\n+        (nibbles << 1) | ((chunk_size - 1) << 3) | (1u << (19 + 4 * nibbles));\n+    output[result++] = (uint8_t)bits;\n+    output[result++] = (uint8_t)(bits >> 8);\n+    output[result++] = (uint8_t)(bits >> 16);\n+    if (nibbles == 2) output[result++] = (uint8_t)(bits >> 24);\n+    memcpy(&output[result], &input[offset], chunk_size);\n+    result += chunk_size;\n+    offset += chunk_size;\n+    size -= chunk_size;\n+  }\n+  output[result++] = 3;\n+  return result;\n+}\n+\n+BROTLI_BOOL BrotliEncoderCompress(\n+    int quality, int lgwin, BrotliEncoderMode mode, size_t input_size,\n+    const uint8_t* input_buffer, size_t* encoded_size,\n+    uint8_t* encoded_buffer) {\n+  BrotliEncoderState* s;\n+  size_t out_size = *encoded_size;\n+  const uint8_t* input_start = input_buffer;\n+  uint8_t* output_start = encoded_buffer;\n+  size_t max_out_size = BrotliEncoderMaxCompressedSize(input_size);\n+  if (out_size == 0) {\n+    /* Output buffer needs at least one byte. */\n+    return BROTLI_FALSE;\n+  }\n+  if (input_size == 0) {\n+    /* Handle the special case of empty input. */\n+    *encoded_size = 1;\n+    *encoded_buffer = 6;\n+    return BROTLI_TRUE;\n+  }\n+  if (quality == 10) {\n+    /* TODO: Implement this direct path for all quality levels. */\n+    const int lg_win = BROTLI_MIN(int, BROTLI_LARGE_MAX_WINDOW_BITS,\n+                                       BROTLI_MAX(int, 16, lgwin));\n+    int ok = BrotliCompressBufferQuality10(lg_win, input_size, input_buffer,\n+                                           encoded_size, encoded_buffer);\n+    if (!ok || (max_out_size && *encoded_size > max_out_size)) {\n+      goto fallback;\n+    }\n+    return BROTLI_TRUE;\n+  }\n+\n+  s = BrotliEncoderCreateInstance(0, 0, 0);\n+  if (!s) {\n+    return BROTLI_FALSE;\n+  } else {\n+    size_t available_in = input_size;\n+    const uint8_t* next_in = input_buffer;\n+    size_t available_out = *encoded_size;\n+    uint8_t* next_out = encoded_buffer;\n+    size_t total_out = 0;\n+    BROTLI_BOOL result = BROTLI_FALSE;\n+    BrotliEncoderSetParameter(s, BROTLI_PARAM_QUALITY, (uint32_t)quality);\n+    BrotliEncoderSetParameter(s, BROTLI_PARAM_LGWIN, (uint32_t)lgwin);\n+    BrotliEncoderSetParameter(s, BROTLI_PARAM_MODE, (uint32_t)mode);\n+    BrotliEncoderSetParameter(s, BROTLI_PARAM_SIZE_HINT, (uint32_t)input_size);\n+    if (lgwin > BROTLI_MAX_WINDOW_BITS) {\n+      BrotliEncoderSetParameter(s, BROTLI_PARAM_LARGE_WINDOW, BROTLI_TRUE);\n+    }\n+    result = BrotliEncoderCompressStream(s, BROTLI_OPERATION_FINISH,\n+        &available_in, &next_in, &available_out, &next_out, &total_out);\n+    if (!BrotliEncoderIsFinished(s)) result = 0;\n+    *encoded_size = total_out;\n+    BrotliEncoderDestroyInstance(s);\n+    if (!result || (max_out_size && *encoded_size > max_out_size)) {\n+      goto fallback;\n+    }\n+    return BROTLI_TRUE;\n+  }\n+fallback:\n+  *encoded_size = 0;\n+  if (!max_out_size) return BROTLI_FALSE;\n+  if (out_size >= max_out_size) {\n+    *encoded_size =\n+        MakeUncompressedStream(input_start, input_size, output_start);\n+    return BROTLI_TRUE;\n+  }\n+  return BROTLI_FALSE;\n+}\n+\n+static void InjectBytePaddingBlock(BrotliEncoderState* s) {\n+  uint32_t seal = s->last_bytes_;\n+  size_t seal_bits = s->last_bytes_bits_;\n+  uint8_t* destination;\n+  s->last_bytes_ = 0;\n+  s->last_bytes_bits_ = 0;\n+  /* is_last = 0, data_nibbles = 11, reserved = 0, meta_nibbles = 00 */\n+  seal |= 0x6u << seal_bits;\n+  seal_bits += 6;\n+  /* If we have already created storage, then append to it.\n+     Storage is valid until next block is being compressed. */\n+  if (s->next_out_) {\n+    destination = s->next_out_ + s->available_out_;\n+  } else {\n+    destination = s->tiny_buf_.u8;\n+    s->next_out_ = destination;\n+  }\n+  destination[0] = (uint8_t)seal;\n+  if (seal_bits > 8) destination[1] = (uint8_t)(seal >> 8);\n+  if (seal_bits > 16) destination[2] = (uint8_t)(seal >> 16);\n+  s->available_out_ += (seal_bits + 7) >> 3;\n+}\n+\n+/* Injects padding bits or pushes compressed data to output.\n+   Returns false if nothing is done. */\n+static BROTLI_BOOL InjectFlushOrPushOutput(BrotliEncoderState* s,\n+    size_t* available_out, uint8_t** next_out, size_t* total_out) {\n+  if (s->stream_state_ == BROTLI_STREAM_FLUSH_REQUESTED &&\n+      s->last_bytes_bits_ != 0) {\n+    InjectBytePaddingBlock(s);\n+    return BROTLI_TRUE;\n+  }\n+\n+  if (s->available_out_ != 0 && *available_out != 0) {\n+    size_t copy_output_size =\n+        BROTLI_MIN(size_t, s->available_out_, *available_out);\n+    memcpy(*next_out, s->next_out_, copy_output_size);\n+    *next_out += copy_output_size;\n+    *available_out -= copy_output_size;\n+    s->next_out_ += copy_output_size;\n+    s->available_out_ -= copy_output_size;\n+    s->total_out_ += copy_output_size;\n+    if (total_out) *total_out = s->total_out_;\n+    return BROTLI_TRUE;\n+  }\n+\n+  return BROTLI_FALSE;\n+}\n+\n+static void CheckFlushComplete(BrotliEncoderState* s) {\n+  if (s->stream_state_ == BROTLI_STREAM_FLUSH_REQUESTED &&\n+      s->available_out_ == 0) {\n+    s->stream_state_ = BROTLI_STREAM_PROCESSING;\n+    s->next_out_ = 0;\n+  }\n+}\n+\n+static BROTLI_BOOL BrotliEncoderCompressStreamFast(\n+    BrotliEncoderState* s, BrotliEncoderOperation op, size_t* available_in,\n+    const uint8_t** next_in, size_t* available_out, uint8_t** next_out,\n+    size_t* total_out) {\n+  const size_t block_size_limit = (size_t)1 << s->params.lgwin;\n+  const size_t buf_size = BROTLI_MIN(size_t, kCompressFragmentTwoPassBlockSize,\n+      BROTLI_MIN(size_t, *available_in, block_size_limit));\n+  uint32_t* tmp_command_buf = NULL;\n+  uint32_t* command_buf = NULL;\n+  uint8_t* tmp_literal_buf = NULL;\n+  uint8_t* literal_buf = NULL;\n+  MemoryManager* m = &s->memory_manager_;\n+  if (s->params.quality != FAST_ONE_PASS_COMPRESSION_QUALITY &&\n+      s->params.quality != FAST_TWO_PASS_COMPRESSION_QUALITY) {\n+    return BROTLI_FALSE;\n+  }\n+  if (s->params.quality == FAST_TWO_PASS_COMPRESSION_QUALITY) {\n+    if (!s->command_buf_ && buf_size == kCompressFragmentTwoPassBlockSize) {\n+      s->command_buf_ =\n+          BROTLI_ALLOC(m, uint32_t, kCompressFragmentTwoPassBlockSize);\n+      s->literal_buf_ =\n+          BROTLI_ALLOC(m, uint8_t, kCompressFragmentTwoPassBlockSize);\n+      if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+    }\n+    if (s->command_buf_) {\n+      command_buf = s->command_buf_;\n+      literal_buf = s->literal_buf_;\n+    } else {\n+      tmp_command_buf = BROTLI_ALLOC(m, uint32_t, buf_size);\n+      tmp_literal_buf = BROTLI_ALLOC(m, uint8_t, buf_size);\n+      if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+      command_buf = tmp_command_buf;\n+      literal_buf = tmp_literal_buf;\n+    }\n+  }\n+\n+  while (BROTLI_TRUE) {\n+    if (InjectFlushOrPushOutput(s, available_out, next_out, total_out)) {\n+      continue;\n+    }\n+\n+    /* Compress block only when internal output buffer is empty, stream is not\n+       finished, there is no pending flush request, and there is either\n+       additional input or pending operation. */\n+    if (s->available_out_ == 0 &&\n+        s->stream_state_ == BROTLI_STREAM_PROCESSING &&\n+        (*available_in != 0 || op != BROTLI_OPERATION_PROCESS)) {\n+      size_t block_size = BROTLI_MIN(size_t, block_size_limit, *available_in);\n+      BROTLI_BOOL is_last =\n+          (*available_in == block_size) && (op == BROTLI_OPERATION_FINISH);\n+      BROTLI_BOOL force_flush =\n+          (*available_in == block_size) && (op == BROTLI_OPERATION_FLUSH);\n+      size_t max_out_size = 2 * block_size + 503;\n+      BROTLI_BOOL inplace = BROTLI_TRUE;\n+      uint8_t* storage = NULL;\n+      size_t storage_ix = s->last_bytes_bits_;\n+      size_t table_size;\n+      int* table;\n+\n+      if (force_flush && block_size == 0) {\n+        s->stream_state_ = BROTLI_STREAM_FLUSH_REQUESTED;\n+        continue;\n+      }\n+      if (max_out_size <= *available_out) {\n+        storage = *next_out;\n+      } else {\n+        inplace = BROTLI_FALSE;\n+        storage = GetBrotliStorage(s, max_out_size);\n+        if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+      }\n+      storage[0] = (uint8_t)s->last_bytes_;\n+      storage[1] = (uint8_t)(s->last_bytes_ >> 8);\n+      table = GetHashTable(s, s->params.quality, block_size, &table_size);\n+      if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+\n+      if (s->params.quality == FAST_ONE_PASS_COMPRESSION_QUALITY) {\n+        BrotliCompressFragmentFast(m, *next_in, block_size, is_last, table,\n+            table_size, s->cmd_depths_, s->cmd_bits_, &s->cmd_code_numbits_,\n+            s->cmd_code_, &storage_ix, storage);\n+        if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+      } else {\n+        BrotliCompressFragmentTwoPass(m, *next_in, block_size, is_last,\n+            command_buf, literal_buf, table, table_size,\n+            &storage_ix, storage);\n+        if (BROTLI_IS_OOM(m)) return BROTLI_FALSE;\n+      }\n+      *next_in += block_size;\n+      *available_in -= block_size;\n+      if (inplace) {\n+        size_t out_bytes = storage_ix >> 3;\n+        BROTLI_DCHECK(out_bytes <= *available_out);\n+        BROTLI_DCHECK((storage_ix & 7) == 0 || out_bytes < *available_out);\n+        *next_out += out_bytes;\n+        *available_out -= out_bytes;\n+        s->total_out_ += out_bytes;\n+        if (total_out) *total_out = s->total_out_;\n+      } else {\n+        size_t out_bytes = storage_ix >> 3;\n+        s->next_out_ = storage;\n+        s->available_out_ = out_bytes;\n+      }\n+      s->last_bytes_ = (uint16_t)(storage[storage_ix >> 3]);\n+      s->last_bytes_bits_ = storage_ix & 7u;\n+\n+      if (force_flush) s->stream_state_ = BROTLI_STREAM_FLUSH_REQUESTED;\n+      if (is_last) s->stream_state_ = BROTLI_STREAM_FINISHED;\n+      continue;\n+    }\n+    break;\n+  }\n+  BROTLI_FREE(m, tmp_command_buf);\n+  BROTLI_FREE(m, tmp_literal_buf);\n+  CheckFlushComplete(s);\n+  return BROTLI_TRUE;\n+}\n+\n+static BROTLI_BOOL ProcessMetadata(\n+    BrotliEncoderState* s, size_t* available_in, const uint8_t** next_in,\n+    size_t* available_out, uint8_t** next_out, size_t* total_out) {\n+  if (*available_in > (1u << 24)) return BROTLI_FALSE;\n+  /* Switch to metadata block workflow, if required. */\n+  if (s->stream_state_ == BROTLI_STREAM_PROCESSING) {\n+    s->remaining_metadata_bytes_ = (uint32_t)*available_in;\n+    s->stream_state_ = BROTLI_STREAM_METADATA_HEAD;\n+  }\n+  if (s->stream_state_ != BROTLI_STREAM_METADATA_HEAD &&\n+      s->stream_state_ != BROTLI_STREAM_METADATA_BODY) {\n+    return BROTLI_FALSE;\n+  }\n+\n+  while (BROTLI_TRUE) {\n+    if (InjectFlushOrPushOutput(s, available_out, next_out, total_out)) {\n+      continue;\n+    }\n+    if (s->available_out_ != 0) break;\n+\n+    if (s->input_pos_ != s->last_flush_pos_) {\n+      BROTLI_BOOL result = EncodeData(s, BROTLI_FALSE, BROTLI_TRUE,\n+          &s->available_out_, &s->next_out_);\n+      if (!result) return BROTLI_FALSE;\n+      continue;\n+    }\n+\n+    if (s->stream_state_ == BROTLI_STREAM_METADATA_HEAD) {\n+      s->next_out_ = s->tiny_buf_.u8;\n+      s->available_out_ =\n+          WriteMetadataHeader(s, s->remaining_metadata_bytes_, s->next_out_);\n+      s->stream_state_ = BROTLI_STREAM_METADATA_BODY;\n+      continue;\n+    } else {\n+      /* Exit workflow only when there is no more input and no more output.\n+         Otherwise client may continue producing empty metadata blocks. */\n+      if (s->remaining_metadata_bytes_ == 0) {\n+        s->remaining_metadata_bytes_ = BROTLI_UINT32_MAX;\n+        s->stream_state_ = BROTLI_STREAM_PROCESSING;\n+        break;\n+      }\n+      if (*available_out) {\n+        /* Directly copy input to output. */\n+        uint32_t copy = (uint32_t)BROTLI_MIN(\n+            size_t, s->remaining_metadata_bytes_, *available_out);\n+        memcpy(*next_out, *next_in, copy);\n+        *next_in += copy;\n+        *available_in -= copy;\n+        s->remaining_metadata_bytes_ -= copy;\n+        *next_out += copy;\n+        *available_out -= copy;\n+      } else {\n+        /* This guarantees progress in \"TakeOutput\" workflow. */\n+        uint32_t copy = BROTLI_MIN(uint32_t, s->remaining_metadata_bytes_, 16);\n+        s->next_out_ = s->tiny_buf_.u8;\n+        memcpy(s->next_out_, *next_in, copy);\n+        *next_in += copy;\n+        *available_in -= copy;\n+        s->remaining_metadata_bytes_ -= copy;\n+        s->available_out_ = copy;\n+      }\n+      continue;\n+    }\n+  }\n+\n+  return BROTLI_TRUE;\n+}\n+\n+static void UpdateSizeHint(BrotliEncoderState* s, size_t available_in) {\n+  if (s->params.size_hint == 0) {\n+    uint64_t delta = UnprocessedInputSize(s);\n+    uint64_t tail = available_in;\n+    uint32_t limit = 1u << 30;\n+    uint32_t total;\n+    if ((delta >= limit) || (tail >= limit) || ((delta + tail) >= limit)) {\n+      total = limit;\n+    } else {\n+      total = (uint32_t)(delta + tail);\n+    }\n+    s->params.size_hint = total;\n+  }\n+}\n+\n+BROTLI_BOOL BrotliEncoderCompressStream(\n+    BrotliEncoderState* s, BrotliEncoderOperation op, size_t* available_in,\n+    const uint8_t** next_in, size_t* available_out,uint8_t** next_out,\n+    size_t* total_out) {\n+  if (!EnsureInitialized(s)) return BROTLI_FALSE;\n+\n+  /* Unfinished metadata block; check requirements. */\n+  if (s->remaining_metadata_bytes_ != BROTLI_UINT32_MAX) {\n+    if (*available_in != s->remaining_metadata_bytes_) return BROTLI_FALSE;\n+    if (op != BROTLI_OPERATION_EMIT_METADATA) return BROTLI_FALSE;\n+  }\n+\n+  if (op == BROTLI_OPERATION_EMIT_METADATA) {\n+    UpdateSizeHint(s, 0);  /* First data metablock might be emitted here. */\n+    return ProcessMetadata(\n+        s, available_in, next_in, available_out, next_out, total_out);\n+  }\n+\n+  if (s->stream_state_ == BROTLI_STREAM_METADATA_HEAD ||\n+      s->stream_state_ == BROTLI_STREAM_METADATA_BODY) {\n+    return BROTLI_FALSE;\n+  }\n+\n+  if (s->stream_state_ != BROTLI_STREAM_PROCESSING && *available_in != 0) {\n+    return BROTLI_FALSE;\n+  }\n+  if (s->params.quality == FAST_ONE_PASS_COMPRESSION_QUALITY ||\n+      s->params.quality == FAST_TWO_PASS_COMPRESSION_QUALITY) {\n+    return BrotliEncoderCompressStreamFast(s, op, available_in, next_in,\n+        available_out, next_out, total_out);\n+  }\n+  while (BROTLI_TRUE) {\n+    size_t remaining_block_size = RemainingInputBlockSize(s);\n+\n+    if (remaining_block_size != 0 && *available_in != 0) {\n+      size_t copy_input_size =\n+          BROTLI_MIN(size_t, remaining_block_size, *available_in);\n+      CopyInputToRingBuffer(s, copy_input_size, *next_in);\n+      *next_in += copy_input_size;\n+      *available_in -= copy_input_size;\n+      continue;\n+    }\n+\n+    if (InjectFlushOrPushOutput(s, available_out, next_out, total_out)) {\n+      continue;\n+    }\n+\n+    /* Compress data only when internal output buffer is empty, stream is not\n+       finished and there is no pending flush request. */\n+    if (s->available_out_ == 0 &&\n+        s->stream_state_ == BROTLI_STREAM_PROCESSING) {\n+      if (remaining_block_size == 0 || op != BROTLI_OPERATION_PROCESS) {\n+        BROTLI_BOOL is_last = TO_BROTLI_BOOL(\n+            (*available_in == 0) && op == BROTLI_OPERATION_FINISH);\n+        BROTLI_BOOL force_flush = TO_BROTLI_BOOL(\n+            (*available_in == 0) && op == BROTLI_OPERATION_FLUSH);\n+        BROTLI_BOOL result;\n+        UpdateSizeHint(s, *available_in);\n+        result = EncodeData(s, is_last, force_flush,\n+            &s->available_out_, &s->next_out_);\n+        if (!result) return BROTLI_FALSE;\n+        if (force_flush) s->stream_state_ = BROTLI_STREAM_FLUSH_REQUESTED;\n+        if (is_last) s->stream_state_ = BROTLI_STREAM_FINISHED;\n+        continue;\n+      }\n+    }\n+    break;\n+  }\n+  CheckFlushComplete(s);\n+  return BROTLI_TRUE;\n+}\n+\n+BROTLI_BOOL BrotliEncoderIsFinished(BrotliEncoderState* s) {\n+  return TO_BROTLI_BOOL(s->stream_state_ == BROTLI_STREAM_FINISHED &&\n+      !BrotliEncoderHasMoreOutput(s));\n+}\n+\n+BROTLI_BOOL BrotliEncoderHasMoreOutput(BrotliEncoderState* s) {\n+  return TO_BROTLI_BOOL(s->available_out_ != 0);\n+}\n+\n+const uint8_t* BrotliEncoderTakeOutput(BrotliEncoderState* s, size_t* size) {\n+  size_t consumed_size = s->available_out_;\n+  uint8_t* result = s->next_out_;\n+  if (*size) {\n+    consumed_size = BROTLI_MIN(size_t, *size, s->available_out_);\n+  }\n+  if (consumed_size) {\n+    s->next_out_ += consumed_size;\n+    s->available_out_ -= consumed_size;\n+    s->total_out_ += consumed_size;\n+    CheckFlushComplete(s);\n+    *size = consumed_size;\n+  } else {\n+    *size = 0;\n+    result = 0;\n+  }\n+  return result;\n+}\n+\n+uint32_t BrotliEncoderVersion(void) {\n+  return BROTLI_VERSION;\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "8b2f6ad4a4753df745e686b81ac5c4dbc3ba8217",
            "filename": "deps/brotli/c/enc/encoder_dict.c",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fencoder_dict.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fencoder_dict.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fencoder_dict.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,32 @@\n+/* Copyright 2017 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+#include \"./encoder_dict.h\"\n+\n+#include \"../common/dictionary.h\"\n+#include \"../common/transform.h\"\n+#include \"./dictionary_hash.h\"\n+#include \"./hash.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+void BrotliInitEncoderDictionary(BrotliEncoderDictionary* dict) {\n+  dict->words = BrotliGetDictionary();\n+\n+  dict->hash_table = kStaticDictionaryHash;\n+  dict->buckets = kStaticDictionaryBuckets;\n+  dict->dict_words = kStaticDictionaryWords;\n+\n+  dict->cutoffTransformsCount = kCutoffTransformsCount;\n+  dict->cutoffTransforms = kCutoffTransforms;\n+\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "3cb6b0ac152b4ce02329dda1b6e1c51b185df12e",
            "filename": "deps/brotli/c/enc/encoder_dict.h",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fencoder_dict.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fencoder_dict.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fencoder_dict.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,41 @@\n+/* Copyright 2017 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+#ifndef BROTLI_ENC_ENCODER_DICT_H_\n+#define BROTLI_ENC_ENCODER_DICT_H_\n+\n+#include \"../common/dictionary.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./static_dict_lut.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* Dictionary data (words and transforms) for 1 possible context */\n+typedef struct BrotliEncoderDictionary {\n+  const BrotliDictionary* words;\n+\n+  /* cut off for fast encoder */\n+  uint32_t cutoffTransformsCount;\n+  uint64_t cutoffTransforms;\n+\n+  /* from dictionary_hash.h, for fast encoder */\n+  const uint16_t* hash_table;\n+\n+  /* from static_dict_lut.h, for slow encoder */\n+  const uint16_t* buckets;\n+  const DictWord* dict_words;\n+} BrotliEncoderDictionary;\n+\n+BROTLI_INTERNAL void BrotliInitEncoderDictionary(BrotliEncoderDictionary* dict);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_ENCODER_DICT_H_ */"
        },
        {
            "sha": "97f9dfb82aa6efd8b6118af79e9679a8c63feac6",
            "filename": "deps/brotli/c/enc/entropy_encode.c",
            "status": "added",
            "additions": 501,
            "deletions": 0,
            "changes": 501,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fentropy_encode.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fentropy_encode.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fentropy_encode.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,501 @@\n+/* Copyright 2010 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Entropy encoding (Huffman) utilities. */\n+\n+#include \"./entropy_encode.h\"\n+\n+#include <string.h>  /* memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+BROTLI_BOOL BrotliSetDepth(\n+    int p0, HuffmanTree* pool, uint8_t* depth, int max_depth) {\n+  int stack[16];\n+  int level = 0;\n+  int p = p0;\n+  BROTLI_DCHECK(max_depth <= 15);\n+  stack[0] = -1;\n+  while (BROTLI_TRUE) {\n+    if (pool[p].index_left_ >= 0) {\n+      level++;\n+      if (level > max_depth) return BROTLI_FALSE;\n+      stack[level] = pool[p].index_right_or_value_;\n+      p = pool[p].index_left_;\n+      continue;\n+    } else {\n+      depth[pool[p].index_right_or_value_] = (uint8_t)level;\n+    }\n+    while (level >= 0 && stack[level] == -1) level--;\n+    if (level < 0) return BROTLI_TRUE;\n+    p = stack[level];\n+    stack[level] = -1;\n+  }\n+}\n+\n+/* Sort the root nodes, least popular first. */\n+static BROTLI_INLINE BROTLI_BOOL SortHuffmanTree(\n+    const HuffmanTree* v0, const HuffmanTree* v1) {\n+  if (v0->total_count_ != v1->total_count_) {\n+    return TO_BROTLI_BOOL(v0->total_count_ < v1->total_count_);\n+  }\n+  return TO_BROTLI_BOOL(v0->index_right_or_value_ > v1->index_right_or_value_);\n+}\n+\n+/* This function will create a Huffman tree.\n+\n+   The catch here is that the tree cannot be arbitrarily deep.\n+   Brotli specifies a maximum depth of 15 bits for \"code trees\"\n+   and 7 bits for \"code length code trees.\"\n+\n+   count_limit is the value that is to be faked as the minimum value\n+   and this minimum value is raised until the tree matches the\n+   maximum length requirement.\n+\n+   This algorithm is not of excellent performance for very long data blocks,\n+   especially when population counts are longer than 2**tree_limit, but\n+   we are not planning to use this with extremely long blocks.\n+\n+   See http://en.wikipedia.org/wiki/Huffman_coding */\n+void BrotliCreateHuffmanTree(const uint32_t* data,\n+                             const size_t length,\n+                             const int tree_limit,\n+                             HuffmanTree* tree,\n+                             uint8_t* depth) {\n+  uint32_t count_limit;\n+  HuffmanTree sentinel;\n+  InitHuffmanTree(&sentinel, BROTLI_UINT32_MAX, -1, -1);\n+  /* For block sizes below 64 kB, we never need to do a second iteration\n+     of this loop. Probably all of our block sizes will be smaller than\n+     that, so this loop is mostly of academic interest. If we actually\n+     would need this, we would be better off with the Katajainen algorithm. */\n+  for (count_limit = 1; ; count_limit *= 2) {\n+    size_t n = 0;\n+    size_t i;\n+    size_t j;\n+    size_t k;\n+    for (i = length; i != 0;) {\n+      --i;\n+      if (data[i]) {\n+        const uint32_t count = BROTLI_MAX(uint32_t, data[i], count_limit);\n+        InitHuffmanTree(&tree[n++], count, -1, (int16_t)i);\n+      }\n+    }\n+\n+    if (n == 1) {\n+      depth[tree[0].index_right_or_value_] = 1;  /* Only one element. */\n+      break;\n+    }\n+\n+    SortHuffmanTreeItems(tree, n, SortHuffmanTree);\n+\n+    /* The nodes are:\n+       [0, n): the sorted leaf nodes that we start with.\n+       [n]: we add a sentinel here.\n+       [n + 1, 2n): new parent nodes are added here, starting from\n+                    (n+1). These are naturally in ascending order.\n+       [2n]: we add a sentinel at the end as well.\n+       There will be (2n+1) elements at the end. */\n+    tree[n] = sentinel;\n+    tree[n + 1] = sentinel;\n+\n+    i = 0;      /* Points to the next leaf node. */\n+    j = n + 1;  /* Points to the next non-leaf node. */\n+    for (k = n - 1; k != 0; --k) {\n+      size_t left, right;\n+      if (tree[i].total_count_ <= tree[j].total_count_) {\n+        left = i;\n+        ++i;\n+      } else {\n+        left = j;\n+        ++j;\n+      }\n+      if (tree[i].total_count_ <= tree[j].total_count_) {\n+        right = i;\n+        ++i;\n+      } else {\n+        right = j;\n+        ++j;\n+      }\n+\n+      {\n+        /* The sentinel node becomes the parent node. */\n+        size_t j_end = 2 * n - k;\n+        tree[j_end].total_count_ =\n+            tree[left].total_count_ + tree[right].total_count_;\n+        tree[j_end].index_left_ = (int16_t)left;\n+        tree[j_end].index_right_or_value_ = (int16_t)right;\n+\n+        /* Add back the last sentinel node. */\n+        tree[j_end + 1] = sentinel;\n+      }\n+    }\n+    if (BrotliSetDepth((int)(2 * n - 1), &tree[0], depth, tree_limit)) {\n+      /* We need to pack the Huffman tree in tree_limit bits. If this was not\n+         successful, add fake entities to the lowest values and retry. */\n+      break;\n+    }\n+  }\n+}\n+\n+static void Reverse(uint8_t* v, size_t start, size_t end) {\n+  --end;\n+  while (start < end) {\n+    uint8_t tmp = v[start];\n+    v[start] = v[end];\n+    v[end] = tmp;\n+    ++start;\n+    --end;\n+  }\n+}\n+\n+static void BrotliWriteHuffmanTreeRepetitions(\n+    const uint8_t previous_value,\n+    const uint8_t value,\n+    size_t repetitions,\n+    size_t* tree_size,\n+    uint8_t* tree,\n+    uint8_t* extra_bits_data) {\n+  BROTLI_DCHECK(repetitions > 0);\n+  if (previous_value != value) {\n+    tree[*tree_size] = value;\n+    extra_bits_data[*tree_size] = 0;\n+    ++(*tree_size);\n+    --repetitions;\n+  }\n+  if (repetitions == 7) {\n+    tree[*tree_size] = value;\n+    extra_bits_data[*tree_size] = 0;\n+    ++(*tree_size);\n+    --repetitions;\n+  }\n+  if (repetitions < 3) {\n+    size_t i;\n+    for (i = 0; i < repetitions; ++i) {\n+      tree[*tree_size] = value;\n+      extra_bits_data[*tree_size] = 0;\n+      ++(*tree_size);\n+    }\n+  } else {\n+    size_t start = *tree_size;\n+    repetitions -= 3;\n+    while (BROTLI_TRUE) {\n+      tree[*tree_size] = BROTLI_REPEAT_PREVIOUS_CODE_LENGTH;\n+      extra_bits_data[*tree_size] = repetitions & 0x3;\n+      ++(*tree_size);\n+      repetitions >>= 2;\n+      if (repetitions == 0) {\n+        break;\n+      }\n+      --repetitions;\n+    }\n+    Reverse(tree, start, *tree_size);\n+    Reverse(extra_bits_data, start, *tree_size);\n+  }\n+}\n+\n+static void BrotliWriteHuffmanTreeRepetitionsZeros(\n+    size_t repetitions,\n+    size_t* tree_size,\n+    uint8_t* tree,\n+    uint8_t* extra_bits_data) {\n+  if (repetitions == 11) {\n+    tree[*tree_size] = 0;\n+    extra_bits_data[*tree_size] = 0;\n+    ++(*tree_size);\n+    --repetitions;\n+  }\n+  if (repetitions < 3) {\n+    size_t i;\n+    for (i = 0; i < repetitions; ++i) {\n+      tree[*tree_size] = 0;\n+      extra_bits_data[*tree_size] = 0;\n+      ++(*tree_size);\n+    }\n+  } else {\n+    size_t start = *tree_size;\n+    repetitions -= 3;\n+    while (BROTLI_TRUE) {\n+      tree[*tree_size] = BROTLI_REPEAT_ZERO_CODE_LENGTH;\n+      extra_bits_data[*tree_size] = repetitions & 0x7;\n+      ++(*tree_size);\n+      repetitions >>= 3;\n+      if (repetitions == 0) {\n+        break;\n+      }\n+      --repetitions;\n+    }\n+    Reverse(tree, start, *tree_size);\n+    Reverse(extra_bits_data, start, *tree_size);\n+  }\n+}\n+\n+void BrotliOptimizeHuffmanCountsForRle(size_t length, uint32_t* counts,\n+                                       uint8_t* good_for_rle) {\n+  size_t nonzero_count = 0;\n+  size_t stride;\n+  size_t limit;\n+  size_t sum;\n+  const size_t streak_limit = 1240;\n+  /* Let's make the Huffman code more compatible with RLE encoding. */\n+  size_t i;\n+  for (i = 0; i < length; i++) {\n+    if (counts[i]) {\n+      ++nonzero_count;\n+    }\n+  }\n+  if (nonzero_count < 16) {\n+    return;\n+  }\n+  while (length != 0 && counts[length - 1] == 0) {\n+    --length;\n+  }\n+  if (length == 0) {\n+    return;  /* All zeros. */\n+  }\n+  /* Now counts[0..length - 1] does not have trailing zeros. */\n+  {\n+    size_t nonzeros = 0;\n+    uint32_t smallest_nonzero = 1 << 30;\n+    for (i = 0; i < length; ++i) {\n+      if (counts[i] != 0) {\n+        ++nonzeros;\n+        if (smallest_nonzero > counts[i]) {\n+          smallest_nonzero = counts[i];\n+        }\n+      }\n+    }\n+    if (nonzeros < 5) {\n+      /* Small histogram will model it well. */\n+      return;\n+    }\n+    if (smallest_nonzero < 4) {\n+      size_t zeros = length - nonzeros;\n+      if (zeros < 6) {\n+        for (i = 1; i < length - 1; ++i) {\n+          if (counts[i - 1] != 0 && counts[i] == 0 && counts[i + 1] != 0) {\n+            counts[i] = 1;\n+          }\n+        }\n+      }\n+    }\n+    if (nonzeros < 28) {\n+      return;\n+    }\n+  }\n+  /* 2) Let's mark all population counts that already can be encoded\n+     with an RLE code. */\n+  memset(good_for_rle, 0, length);\n+  {\n+    /* Let's not spoil any of the existing good RLE codes.\n+       Mark any seq of 0's that is longer as 5 as a good_for_rle.\n+       Mark any seq of non-0's that is longer as 7 as a good_for_rle. */\n+    uint32_t symbol = counts[0];\n+    size_t step = 0;\n+    for (i = 0; i <= length; ++i) {\n+      if (i == length || counts[i] != symbol) {\n+        if ((symbol == 0 && step >= 5) ||\n+            (symbol != 0 && step >= 7)) {\n+          size_t k;\n+          for (k = 0; k < step; ++k) {\n+            good_for_rle[i - k - 1] = 1;\n+          }\n+        }\n+        step = 1;\n+        if (i != length) {\n+          symbol = counts[i];\n+        }\n+      } else {\n+        ++step;\n+      }\n+    }\n+  }\n+  /* 3) Let's replace those population counts that lead to more RLE codes.\n+     Math here is in 24.8 fixed point representation. */\n+  stride = 0;\n+  limit = 256 * (counts[0] + counts[1] + counts[2]) / 3 + 420;\n+  sum = 0;\n+  for (i = 0; i <= length; ++i) {\n+    if (i == length || good_for_rle[i] ||\n+        (i != 0 && good_for_rle[i - 1]) ||\n+        (256 * counts[i] - limit + streak_limit) >= 2 * streak_limit) {\n+      if (stride >= 4 || (stride >= 3 && sum == 0)) {\n+        size_t k;\n+        /* The stride must end, collapse what we have, if we have enough (4). */\n+        size_t count = (sum + stride / 2) / stride;\n+        if (count == 0) {\n+          count = 1;\n+        }\n+        if (sum == 0) {\n+          /* Don't make an all zeros stride to be upgraded to ones. */\n+          count = 0;\n+        }\n+        for (k = 0; k < stride; ++k) {\n+          /* We don't want to change value at counts[i],\n+             that is already belonging to the next stride. Thus - 1. */\n+          counts[i - k - 1] = (uint32_t)count;\n+        }\n+      }\n+      stride = 0;\n+      sum = 0;\n+      if (i < length - 2) {\n+        /* All interesting strides have a count of at least 4, */\n+        /* at least when non-zeros. */\n+        limit = 256 * (counts[i] + counts[i + 1] + counts[i + 2]) / 3 + 420;\n+      } else if (i < length) {\n+        limit = 256 * counts[i];\n+      } else {\n+        limit = 0;\n+      }\n+    }\n+    ++stride;\n+    if (i != length) {\n+      sum += counts[i];\n+      if (stride >= 4) {\n+        limit = (256 * sum + stride / 2) / stride;\n+      }\n+      if (stride == 4) {\n+        limit += 120;\n+      }\n+    }\n+  }\n+}\n+\n+static void DecideOverRleUse(const uint8_t* depth, const size_t length,\n+                             BROTLI_BOOL* use_rle_for_non_zero,\n+                             BROTLI_BOOL* use_rle_for_zero) {\n+  size_t total_reps_zero = 0;\n+  size_t total_reps_non_zero = 0;\n+  size_t count_reps_zero = 1;\n+  size_t count_reps_non_zero = 1;\n+  size_t i;\n+  for (i = 0; i < length;) {\n+    const uint8_t value = depth[i];\n+    size_t reps = 1;\n+    size_t k;\n+    for (k = i + 1; k < length && depth[k] == value; ++k) {\n+      ++reps;\n+    }\n+    if (reps >= 3 && value == 0) {\n+      total_reps_zero += reps;\n+      ++count_reps_zero;\n+    }\n+    if (reps >= 4 && value != 0) {\n+      total_reps_non_zero += reps;\n+      ++count_reps_non_zero;\n+    }\n+    i += reps;\n+  }\n+  *use_rle_for_non_zero =\n+      TO_BROTLI_BOOL(total_reps_non_zero > count_reps_non_zero * 2);\n+  *use_rle_for_zero = TO_BROTLI_BOOL(total_reps_zero > count_reps_zero * 2);\n+}\n+\n+void BrotliWriteHuffmanTree(const uint8_t* depth,\n+                            size_t length,\n+                            size_t* tree_size,\n+                            uint8_t* tree,\n+                            uint8_t* extra_bits_data) {\n+  uint8_t previous_value = BROTLI_INITIAL_REPEATED_CODE_LENGTH;\n+  size_t i;\n+  BROTLI_BOOL use_rle_for_non_zero = BROTLI_FALSE;\n+  BROTLI_BOOL use_rle_for_zero = BROTLI_FALSE;\n+\n+  /* Throw away trailing zeros. */\n+  size_t new_length = length;\n+  for (i = 0; i < length; ++i) {\n+    if (depth[length - i - 1] == 0) {\n+      --new_length;\n+    } else {\n+      break;\n+    }\n+  }\n+\n+  /* First gather statistics on if it is a good idea to do RLE. */\n+  if (length > 50) {\n+    /* Find RLE coding for longer codes.\n+       Shorter codes seem not to benefit from RLE. */\n+    DecideOverRleUse(depth, new_length,\n+                     &use_rle_for_non_zero, &use_rle_for_zero);\n+  }\n+\n+  /* Actual RLE coding. */\n+  for (i = 0; i < new_length;) {\n+    const uint8_t value = depth[i];\n+    size_t reps = 1;\n+    if ((value != 0 && use_rle_for_non_zero) ||\n+        (value == 0 && use_rle_for_zero)) {\n+      size_t k;\n+      for (k = i + 1; k < new_length && depth[k] == value; ++k) {\n+        ++reps;\n+      }\n+    }\n+    if (value == 0) {\n+      BrotliWriteHuffmanTreeRepetitionsZeros(\n+          reps, tree_size, tree, extra_bits_data);\n+    } else {\n+      BrotliWriteHuffmanTreeRepetitions(previous_value,\n+                                        value, reps, tree_size,\n+                                        tree, extra_bits_data);\n+      previous_value = value;\n+    }\n+    i += reps;\n+  }\n+}\n+\n+static uint16_t BrotliReverseBits(size_t num_bits, uint16_t bits) {\n+  static const size_t kLut[16] = {  /* Pre-reversed 4-bit values. */\n+    0x00, 0x08, 0x04, 0x0C, 0x02, 0x0A, 0x06, 0x0E,\n+    0x01, 0x09, 0x05, 0x0D, 0x03, 0x0B, 0x07, 0x0F\n+  };\n+  size_t retval = kLut[bits & 0x0F];\n+  size_t i;\n+  for (i = 4; i < num_bits; i += 4) {\n+    retval <<= 4;\n+    bits = (uint16_t)(bits >> 4);\n+    retval |= kLut[bits & 0x0F];\n+  }\n+  retval >>= ((0 - num_bits) & 0x03);\n+  return (uint16_t)retval;\n+}\n+\n+/* 0..15 are values for bits */\n+#define MAX_HUFFMAN_BITS 16\n+\n+void BrotliConvertBitDepthsToSymbols(const uint8_t* depth,\n+                                     size_t len,\n+                                     uint16_t* bits) {\n+  /* In Brotli, all bit depths are [1..15]\n+     0 bit depth means that the symbol does not exist. */\n+  uint16_t bl_count[MAX_HUFFMAN_BITS] = { 0 };\n+  uint16_t next_code[MAX_HUFFMAN_BITS];\n+  size_t i;\n+  int code = 0;\n+  for (i = 0; i < len; ++i) {\n+    ++bl_count[depth[i]];\n+  }\n+  bl_count[0] = 0;\n+  next_code[0] = 0;\n+  for (i = 1; i < MAX_HUFFMAN_BITS; ++i) {\n+    code = (code + bl_count[i - 1]) << 1;\n+    next_code[i] = (uint16_t)code;\n+  }\n+  for (i = 0; i < len; ++i) {\n+    if (depth[i]) {\n+      bits[i] = BrotliReverseBits(depth[i], next_code[depth[i]]++);\n+    }\n+  }\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "f23d9c379d06136da60ceeb40fa0762e38554d32",
            "filename": "deps/brotli/c/enc/entropy_encode.h",
            "status": "added",
            "additions": 122,
            "deletions": 0,
            "changes": 122,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fentropy_encode.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fentropy_encode.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fentropy_encode.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,122 @@\n+/* Copyright 2010 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Entropy encoding (Huffman) utilities. */\n+\n+#ifndef BROTLI_ENC_ENTROPY_ENCODE_H_\n+#define BROTLI_ENC_ENTROPY_ENCODE_H_\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* A node of a Huffman tree. */\n+typedef struct HuffmanTree {\n+  uint32_t total_count_;\n+  int16_t index_left_;\n+  int16_t index_right_or_value_;\n+} HuffmanTree;\n+\n+static BROTLI_INLINE void InitHuffmanTree(HuffmanTree* self, uint32_t count,\n+    int16_t left, int16_t right) {\n+  self->total_count_ = count;\n+  self->index_left_ = left;\n+  self->index_right_or_value_ = right;\n+}\n+\n+/* Returns 1 is assignment of depths succeeded, otherwise 0. */\n+BROTLI_INTERNAL BROTLI_BOOL BrotliSetDepth(\n+    int p, HuffmanTree* pool, uint8_t* depth, int max_depth);\n+\n+/* This function will create a Huffman tree.\n+\n+   The (data,length) contains the population counts.\n+   The tree_limit is the maximum bit depth of the Huffman codes.\n+\n+   The depth contains the tree, i.e., how many bits are used for\n+   the symbol.\n+\n+   The actual Huffman tree is constructed in the tree[] array, which has to\n+   be at least 2 * length + 1 long.\n+\n+   See http://en.wikipedia.org/wiki/Huffman_coding */\n+BROTLI_INTERNAL void BrotliCreateHuffmanTree(const uint32_t* data,\n+                                             const size_t length,\n+                                             const int tree_limit,\n+                                             HuffmanTree* tree,\n+                                             uint8_t* depth);\n+\n+/* Change the population counts in a way that the consequent\n+   Huffman tree compression, especially its RLE-part will be more\n+   likely to compress this data more efficiently.\n+\n+   length contains the size of the histogram.\n+   counts contains the population counts.\n+   good_for_rle is a buffer of at least length size */\n+BROTLI_INTERNAL void BrotliOptimizeHuffmanCountsForRle(\n+    size_t length, uint32_t* counts, uint8_t* good_for_rle);\n+\n+/* Write a Huffman tree from bit depths into the bit-stream representation\n+   of a Huffman tree. The generated Huffman tree is to be compressed once\n+   more using a Huffman tree */\n+BROTLI_INTERNAL void BrotliWriteHuffmanTree(const uint8_t* depth,\n+                                            size_t num,\n+                                            size_t* tree_size,\n+                                            uint8_t* tree,\n+                                            uint8_t* extra_bits_data);\n+\n+/* Get the actual bit values for a tree of bit depths. */\n+BROTLI_INTERNAL void BrotliConvertBitDepthsToSymbols(const uint8_t* depth,\n+                                                     size_t len,\n+                                                     uint16_t* bits);\n+\n+/* Input size optimized Shell sort. */\n+typedef BROTLI_BOOL (*HuffmanTreeComparator)(\n+    const HuffmanTree*, const HuffmanTree*);\n+static BROTLI_INLINE void SortHuffmanTreeItems(HuffmanTree* items,\n+    const size_t n, HuffmanTreeComparator comparator) {\n+  static const size_t gaps[] = {132, 57, 23, 10, 4, 1};\n+  if (n < 13) {\n+    /* Insertion sort. */\n+    size_t i;\n+    for (i = 1; i < n; ++i) {\n+      HuffmanTree tmp = items[i];\n+      size_t k = i;\n+      size_t j = i - 1;\n+      while (comparator(&tmp, &items[j])) {\n+        items[k] = items[j];\n+        k = j;\n+        if (!j--) break;\n+      }\n+      items[k] = tmp;\n+    }\n+    return;\n+  } else {\n+    /* Shell sort. */\n+    int g = n < 57 ? 2 : 0;\n+    for (; g < 6; ++g) {\n+      size_t gap = gaps[g];\n+      size_t i;\n+      for (i = gap; i < n; ++i) {\n+        size_t j = i;\n+        HuffmanTree tmp = items[i];\n+        for (; j >= gap && comparator(&tmp, &items[j - gap]); j -= gap) {\n+          items[j] = items[j - gap];\n+        }\n+        items[j] = tmp;\n+      }\n+    }\n+  }\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_ENTROPY_ENCODE_H_ */"
        },
        {
            "sha": "62b99a954c590cf67ddfe190e880520a9294b867",
            "filename": "deps/brotli/c/enc/entropy_encode_static.h",
            "status": "added",
            "additions": 539,
            "deletions": 0,
            "changes": 539,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fentropy_encode_static.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fentropy_encode_static.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fentropy_encode_static.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,539 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Static entropy codes used for faster meta-block encoding. */\n+\n+#ifndef BROTLI_ENC_ENTROPY_ENCODE_STATIC_H_\n+#define BROTLI_ENC_ENTROPY_ENCODE_STATIC_H_\n+\n+#include \"../common/constants.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./write_bits.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+static const uint8_t kCodeLengthDepth[18] = {\n+  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 0, 4, 4,\n+};\n+\n+static const uint8_t kStaticCommandCodeDepth[BROTLI_NUM_COMMAND_SYMBOLS] = {\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+};\n+\n+static const uint8_t kStaticDistanceCodeDepth[64] = {\n+  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n+};\n+\n+static const uint32_t kCodeLengthBits[18] = {\n+  0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 15, 31, 0, 11, 7,\n+};\n+\n+static BROTLI_INLINE void StoreStaticCodeLengthCode(\n+    size_t* storage_ix, uint8_t* storage) {\n+  BrotliWriteBits(\n+      40, BROTLI_MAKE_UINT64_T(0x0000FFu, 0x55555554u), storage_ix, storage);\n+}\n+\n+static const uint64_t kZeroRepsBits[BROTLI_NUM_COMMAND_SYMBOLS] = {\n+  0x00000000, 0x00000000, 0x00000000, 0x00000007, 0x00000017, 0x00000027,\n+  0x00000037, 0x00000047, 0x00000057, 0x00000067, 0x00000077, 0x00000770,\n+  0x00000b87, 0x00001387, 0x00001b87, 0x00002387, 0x00002b87, 0x00003387,\n+  0x00003b87, 0x00000397, 0x00000b97, 0x00001397, 0x00001b97, 0x00002397,\n+  0x00002b97, 0x00003397, 0x00003b97, 0x000003a7, 0x00000ba7, 0x000013a7,\n+  0x00001ba7, 0x000023a7, 0x00002ba7, 0x000033a7, 0x00003ba7, 0x000003b7,\n+  0x00000bb7, 0x000013b7, 0x00001bb7, 0x000023b7, 0x00002bb7, 0x000033b7,\n+  0x00003bb7, 0x000003c7, 0x00000bc7, 0x000013c7, 0x00001bc7, 0x000023c7,\n+  0x00002bc7, 0x000033c7, 0x00003bc7, 0x000003d7, 0x00000bd7, 0x000013d7,\n+  0x00001bd7, 0x000023d7, 0x00002bd7, 0x000033d7, 0x00003bd7, 0x000003e7,\n+  0x00000be7, 0x000013e7, 0x00001be7, 0x000023e7, 0x00002be7, 0x000033e7,\n+  0x00003be7, 0x000003f7, 0x00000bf7, 0x000013f7, 0x00001bf7, 0x000023f7,\n+  0x00002bf7, 0x000033f7, 0x00003bf7, 0x0001c387, 0x0005c387, 0x0009c387,\n+  0x000dc387, 0x0011c387, 0x0015c387, 0x0019c387, 0x001dc387, 0x0001cb87,\n+  0x0005cb87, 0x0009cb87, 0x000dcb87, 0x0011cb87, 0x0015cb87, 0x0019cb87,\n+  0x001dcb87, 0x0001d387, 0x0005d387, 0x0009d387, 0x000dd387, 0x0011d387,\n+  0x0015d387, 0x0019d387, 0x001dd387, 0x0001db87, 0x0005db87, 0x0009db87,\n+  0x000ddb87, 0x0011db87, 0x0015db87, 0x0019db87, 0x001ddb87, 0x0001e387,\n+  0x0005e387, 0x0009e387, 0x000de387, 0x0011e387, 0x0015e387, 0x0019e387,\n+  0x001de387, 0x0001eb87, 0x0005eb87, 0x0009eb87, 0x000deb87, 0x0011eb87,\n+  0x0015eb87, 0x0019eb87, 0x001deb87, 0x0001f387, 0x0005f387, 0x0009f387,\n+  0x000df387, 0x0011f387, 0x0015f387, 0x0019f387, 0x001df387, 0x0001fb87,\n+  0x0005fb87, 0x0009fb87, 0x000dfb87, 0x0011fb87, 0x0015fb87, 0x0019fb87,\n+  0x001dfb87, 0x0001c397, 0x0005c397, 0x0009c397, 0x000dc397, 0x0011c397,\n+  0x0015c397, 0x0019c397, 0x001dc397, 0x0001cb97, 0x0005cb97, 0x0009cb97,\n+  0x000dcb97, 0x0011cb97, 0x0015cb97, 0x0019cb97, 0x001dcb97, 0x0001d397,\n+  0x0005d397, 0x0009d397, 0x000dd397, 0x0011d397, 0x0015d397, 0x0019d397,\n+  0x001dd397, 0x0001db97, 0x0005db97, 0x0009db97, 0x000ddb97, 0x0011db97,\n+  0x0015db97, 0x0019db97, 0x001ddb97, 0x0001e397, 0x0005e397, 0x0009e397,\n+  0x000de397, 0x0011e397, 0x0015e397, 0x0019e397, 0x001de397, 0x0001eb97,\n+  0x0005eb97, 0x0009eb97, 0x000deb97, 0x0011eb97, 0x0015eb97, 0x0019eb97,\n+  0x001deb97, 0x0001f397, 0x0005f397, 0x0009f397, 0x000df397, 0x0011f397,\n+  0x0015f397, 0x0019f397, 0x001df397, 0x0001fb97, 0x0005fb97, 0x0009fb97,\n+  0x000dfb97, 0x0011fb97, 0x0015fb97, 0x0019fb97, 0x001dfb97, 0x0001c3a7,\n+  0x0005c3a7, 0x0009c3a7, 0x000dc3a7, 0x0011c3a7, 0x0015c3a7, 0x0019c3a7,\n+  0x001dc3a7, 0x0001cba7, 0x0005cba7, 0x0009cba7, 0x000dcba7, 0x0011cba7,\n+  0x0015cba7, 0x0019cba7, 0x001dcba7, 0x0001d3a7, 0x0005d3a7, 0x0009d3a7,\n+  0x000dd3a7, 0x0011d3a7, 0x0015d3a7, 0x0019d3a7, 0x001dd3a7, 0x0001dba7,\n+  0x0005dba7, 0x0009dba7, 0x000ddba7, 0x0011dba7, 0x0015dba7, 0x0019dba7,\n+  0x001ddba7, 0x0001e3a7, 0x0005e3a7, 0x0009e3a7, 0x000de3a7, 0x0011e3a7,\n+  0x0015e3a7, 0x0019e3a7, 0x001de3a7, 0x0001eba7, 0x0005eba7, 0x0009eba7,\n+  0x000deba7, 0x0011eba7, 0x0015eba7, 0x0019eba7, 0x001deba7, 0x0001f3a7,\n+  0x0005f3a7, 0x0009f3a7, 0x000df3a7, 0x0011f3a7, 0x0015f3a7, 0x0019f3a7,\n+  0x001df3a7, 0x0001fba7, 0x0005fba7, 0x0009fba7, 0x000dfba7, 0x0011fba7,\n+  0x0015fba7, 0x0019fba7, 0x001dfba7, 0x0001c3b7, 0x0005c3b7, 0x0009c3b7,\n+  0x000dc3b7, 0x0011c3b7, 0x0015c3b7, 0x0019c3b7, 0x001dc3b7, 0x0001cbb7,\n+  0x0005cbb7, 0x0009cbb7, 0x000dcbb7, 0x0011cbb7, 0x0015cbb7, 0x0019cbb7,\n+  0x001dcbb7, 0x0001d3b7, 0x0005d3b7, 0x0009d3b7, 0x000dd3b7, 0x0011d3b7,\n+  0x0015d3b7, 0x0019d3b7, 0x001dd3b7, 0x0001dbb7, 0x0005dbb7, 0x0009dbb7,\n+  0x000ddbb7, 0x0011dbb7, 0x0015dbb7, 0x0019dbb7, 0x001ddbb7, 0x0001e3b7,\n+  0x0005e3b7, 0x0009e3b7, 0x000de3b7, 0x0011e3b7, 0x0015e3b7, 0x0019e3b7,\n+  0x001de3b7, 0x0001ebb7, 0x0005ebb7, 0x0009ebb7, 0x000debb7, 0x0011ebb7,\n+  0x0015ebb7, 0x0019ebb7, 0x001debb7, 0x0001f3b7, 0x0005f3b7, 0x0009f3b7,\n+  0x000df3b7, 0x0011f3b7, 0x0015f3b7, 0x0019f3b7, 0x001df3b7, 0x0001fbb7,\n+  0x0005fbb7, 0x0009fbb7, 0x000dfbb7, 0x0011fbb7, 0x0015fbb7, 0x0019fbb7,\n+  0x001dfbb7, 0x0001c3c7, 0x0005c3c7, 0x0009c3c7, 0x000dc3c7, 0x0011c3c7,\n+  0x0015c3c7, 0x0019c3c7, 0x001dc3c7, 0x0001cbc7, 0x0005cbc7, 0x0009cbc7,\n+  0x000dcbc7, 0x0011cbc7, 0x0015cbc7, 0x0019cbc7, 0x001dcbc7, 0x0001d3c7,\n+  0x0005d3c7, 0x0009d3c7, 0x000dd3c7, 0x0011d3c7, 0x0015d3c7, 0x0019d3c7,\n+  0x001dd3c7, 0x0001dbc7, 0x0005dbc7, 0x0009dbc7, 0x000ddbc7, 0x0011dbc7,\n+  0x0015dbc7, 0x0019dbc7, 0x001ddbc7, 0x0001e3c7, 0x0005e3c7, 0x0009e3c7,\n+  0x000de3c7, 0x0011e3c7, 0x0015e3c7, 0x0019e3c7, 0x001de3c7, 0x0001ebc7,\n+  0x0005ebc7, 0x0009ebc7, 0x000debc7, 0x0011ebc7, 0x0015ebc7, 0x0019ebc7,\n+  0x001debc7, 0x0001f3c7, 0x0005f3c7, 0x0009f3c7, 0x000df3c7, 0x0011f3c7,\n+  0x0015f3c7, 0x0019f3c7, 0x001df3c7, 0x0001fbc7, 0x0005fbc7, 0x0009fbc7,\n+  0x000dfbc7, 0x0011fbc7, 0x0015fbc7, 0x0019fbc7, 0x001dfbc7, 0x0001c3d7,\n+  0x0005c3d7, 0x0009c3d7, 0x000dc3d7, 0x0011c3d7, 0x0015c3d7, 0x0019c3d7,\n+  0x001dc3d7, 0x0001cbd7, 0x0005cbd7, 0x0009cbd7, 0x000dcbd7, 0x0011cbd7,\n+  0x0015cbd7, 0x0019cbd7, 0x001dcbd7, 0x0001d3d7, 0x0005d3d7, 0x0009d3d7,\n+  0x000dd3d7, 0x0011d3d7, 0x0015d3d7, 0x0019d3d7, 0x001dd3d7, 0x0001dbd7,\n+  0x0005dbd7, 0x0009dbd7, 0x000ddbd7, 0x0011dbd7, 0x0015dbd7, 0x0019dbd7,\n+  0x001ddbd7, 0x0001e3d7, 0x0005e3d7, 0x0009e3d7, 0x000de3d7, 0x0011e3d7,\n+  0x0015e3d7, 0x0019e3d7, 0x001de3d7, 0x0001ebd7, 0x0005ebd7, 0x0009ebd7,\n+  0x000debd7, 0x0011ebd7, 0x0015ebd7, 0x0019ebd7, 0x001debd7, 0x0001f3d7,\n+  0x0005f3d7, 0x0009f3d7, 0x000df3d7, 0x0011f3d7, 0x0015f3d7, 0x0019f3d7,\n+  0x001df3d7, 0x0001fbd7, 0x0005fbd7, 0x0009fbd7, 0x000dfbd7, 0x0011fbd7,\n+  0x0015fbd7, 0x0019fbd7, 0x001dfbd7, 0x0001c3e7, 0x0005c3e7, 0x0009c3e7,\n+  0x000dc3e7, 0x0011c3e7, 0x0015c3e7, 0x0019c3e7, 0x001dc3e7, 0x0001cbe7,\n+  0x0005cbe7, 0x0009cbe7, 0x000dcbe7, 0x0011cbe7, 0x0015cbe7, 0x0019cbe7,\n+  0x001dcbe7, 0x0001d3e7, 0x0005d3e7, 0x0009d3e7, 0x000dd3e7, 0x0011d3e7,\n+  0x0015d3e7, 0x0019d3e7, 0x001dd3e7, 0x0001dbe7, 0x0005dbe7, 0x0009dbe7,\n+  0x000ddbe7, 0x0011dbe7, 0x0015dbe7, 0x0019dbe7, 0x001ddbe7, 0x0001e3e7,\n+  0x0005e3e7, 0x0009e3e7, 0x000de3e7, 0x0011e3e7, 0x0015e3e7, 0x0019e3e7,\n+  0x001de3e7, 0x0001ebe7, 0x0005ebe7, 0x0009ebe7, 0x000debe7, 0x0011ebe7,\n+  0x0015ebe7, 0x0019ebe7, 0x001debe7, 0x0001f3e7, 0x0005f3e7, 0x0009f3e7,\n+  0x000df3e7, 0x0011f3e7, 0x0015f3e7, 0x0019f3e7, 0x001df3e7, 0x0001fbe7,\n+  0x0005fbe7, 0x0009fbe7, 0x000dfbe7, 0x0011fbe7, 0x0015fbe7, 0x0019fbe7,\n+  0x001dfbe7, 0x0001c3f7, 0x0005c3f7, 0x0009c3f7, 0x000dc3f7, 0x0011c3f7,\n+  0x0015c3f7, 0x0019c3f7, 0x001dc3f7, 0x0001cbf7, 0x0005cbf7, 0x0009cbf7,\n+  0x000dcbf7, 0x0011cbf7, 0x0015cbf7, 0x0019cbf7, 0x001dcbf7, 0x0001d3f7,\n+  0x0005d3f7, 0x0009d3f7, 0x000dd3f7, 0x0011d3f7, 0x0015d3f7, 0x0019d3f7,\n+  0x001dd3f7, 0x0001dbf7, 0x0005dbf7, 0x0009dbf7, 0x000ddbf7, 0x0011dbf7,\n+  0x0015dbf7, 0x0019dbf7, 0x001ddbf7, 0x0001e3f7, 0x0005e3f7, 0x0009e3f7,\n+  0x000de3f7, 0x0011e3f7, 0x0015e3f7, 0x0019e3f7, 0x001de3f7, 0x0001ebf7,\n+  0x0005ebf7, 0x0009ebf7, 0x000debf7, 0x0011ebf7, 0x0015ebf7, 0x0019ebf7,\n+  0x001debf7, 0x0001f3f7, 0x0005f3f7, 0x0009f3f7, 0x000df3f7, 0x0011f3f7,\n+  0x0015f3f7, 0x0019f3f7, 0x001df3f7, 0x0001fbf7, 0x0005fbf7, 0x0009fbf7,\n+  0x000dfbf7, 0x0011fbf7, 0x0015fbf7, 0x0019fbf7, 0x001dfbf7, 0x00e1c387,\n+  0x02e1c387, 0x04e1c387, 0x06e1c387, 0x08e1c387, 0x0ae1c387, 0x0ce1c387,\n+  0x0ee1c387, 0x00e5c387, 0x02e5c387, 0x04e5c387, 0x06e5c387, 0x08e5c387,\n+  0x0ae5c387, 0x0ce5c387, 0x0ee5c387, 0x00e9c387, 0x02e9c387, 0x04e9c387,\n+  0x06e9c387, 0x08e9c387, 0x0ae9c387, 0x0ce9c387, 0x0ee9c387, 0x00edc387,\n+  0x02edc387, 0x04edc387, 0x06edc387, 0x08edc387, 0x0aedc387, 0x0cedc387,\n+  0x0eedc387, 0x00f1c387, 0x02f1c387, 0x04f1c387, 0x06f1c387, 0x08f1c387,\n+  0x0af1c387, 0x0cf1c387, 0x0ef1c387, 0x00f5c387, 0x02f5c387, 0x04f5c387,\n+  0x06f5c387, 0x08f5c387, 0x0af5c387, 0x0cf5c387, 0x0ef5c387, 0x00f9c387,\n+  0x02f9c387, 0x04f9c387, 0x06f9c387, 0x08f9c387, 0x0af9c387, 0x0cf9c387,\n+  0x0ef9c387, 0x00fdc387, 0x02fdc387, 0x04fdc387, 0x06fdc387, 0x08fdc387,\n+  0x0afdc387, 0x0cfdc387, 0x0efdc387, 0x00e1cb87, 0x02e1cb87, 0x04e1cb87,\n+  0x06e1cb87, 0x08e1cb87, 0x0ae1cb87, 0x0ce1cb87, 0x0ee1cb87, 0x00e5cb87,\n+  0x02e5cb87, 0x04e5cb87, 0x06e5cb87, 0x08e5cb87, 0x0ae5cb87, 0x0ce5cb87,\n+  0x0ee5cb87, 0x00e9cb87, 0x02e9cb87, 0x04e9cb87, 0x06e9cb87, 0x08e9cb87,\n+  0x0ae9cb87, 0x0ce9cb87, 0x0ee9cb87, 0x00edcb87, 0x02edcb87, 0x04edcb87,\n+  0x06edcb87, 0x08edcb87, 0x0aedcb87, 0x0cedcb87, 0x0eedcb87, 0x00f1cb87,\n+  0x02f1cb87, 0x04f1cb87, 0x06f1cb87, 0x08f1cb87, 0x0af1cb87, 0x0cf1cb87,\n+  0x0ef1cb87, 0x00f5cb87, 0x02f5cb87, 0x04f5cb87, 0x06f5cb87, 0x08f5cb87,\n+  0x0af5cb87, 0x0cf5cb87, 0x0ef5cb87, 0x00f9cb87, 0x02f9cb87, 0x04f9cb87,\n+  0x06f9cb87, 0x08f9cb87,\n+};\n+\n+static const uint32_t kZeroRepsDepth[BROTLI_NUM_COMMAND_SYMBOLS] = {\n+   0,  4,  8,  7,  7,  7,  7,  7,  7,  7,  7, 11, 14, 14, 14, 14,\n+  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n+  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n+  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n+  14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 28, 28, 28, 28, 28,\n+  28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+  28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+  28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+  28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+  28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+  28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+  28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n+};\n+\n+static const uint64_t kNonZeroRepsBits[BROTLI_NUM_COMMAND_SYMBOLS] = {\n+  0x0000000b, 0x0000001b, 0x0000002b, 0x0000003b, 0x000002cb, 0x000006cb,\n+  0x00000acb, 0x00000ecb, 0x000002db, 0x000006db, 0x00000adb, 0x00000edb,\n+  0x000002eb, 0x000006eb, 0x00000aeb, 0x00000eeb, 0x000002fb, 0x000006fb,\n+  0x00000afb, 0x00000efb, 0x0000b2cb, 0x0001b2cb, 0x0002b2cb, 0x0003b2cb,\n+  0x0000b6cb, 0x0001b6cb, 0x0002b6cb, 0x0003b6cb, 0x0000bacb, 0x0001bacb,\n+  0x0002bacb, 0x0003bacb, 0x0000becb, 0x0001becb, 0x0002becb, 0x0003becb,\n+  0x0000b2db, 0x0001b2db, 0x0002b2db, 0x0003b2db, 0x0000b6db, 0x0001b6db,\n+  0x0002b6db, 0x0003b6db, 0x0000badb, 0x0001badb, 0x0002badb, 0x0003badb,\n+  0x0000bedb, 0x0001bedb, 0x0002bedb, 0x0003bedb, 0x0000b2eb, 0x0001b2eb,\n+  0x0002b2eb, 0x0003b2eb, 0x0000b6eb, 0x0001b6eb, 0x0002b6eb, 0x0003b6eb,\n+  0x0000baeb, 0x0001baeb, 0x0002baeb, 0x0003baeb, 0x0000beeb, 0x0001beeb,\n+  0x0002beeb, 0x0003beeb, 0x0000b2fb, 0x0001b2fb, 0x0002b2fb, 0x0003b2fb,\n+  0x0000b6fb, 0x0001b6fb, 0x0002b6fb, 0x0003b6fb, 0x0000bafb, 0x0001bafb,\n+  0x0002bafb, 0x0003bafb, 0x0000befb, 0x0001befb, 0x0002befb, 0x0003befb,\n+  0x002cb2cb, 0x006cb2cb, 0x00acb2cb, 0x00ecb2cb, 0x002db2cb, 0x006db2cb,\n+  0x00adb2cb, 0x00edb2cb, 0x002eb2cb, 0x006eb2cb, 0x00aeb2cb, 0x00eeb2cb,\n+  0x002fb2cb, 0x006fb2cb, 0x00afb2cb, 0x00efb2cb, 0x002cb6cb, 0x006cb6cb,\n+  0x00acb6cb, 0x00ecb6cb, 0x002db6cb, 0x006db6cb, 0x00adb6cb, 0x00edb6cb,\n+  0x002eb6cb, 0x006eb6cb, 0x00aeb6cb, 0x00eeb6cb, 0x002fb6cb, 0x006fb6cb,\n+  0x00afb6cb, 0x00efb6cb, 0x002cbacb, 0x006cbacb, 0x00acbacb, 0x00ecbacb,\n+  0x002dbacb, 0x006dbacb, 0x00adbacb, 0x00edbacb, 0x002ebacb, 0x006ebacb,\n+  0x00aebacb, 0x00eebacb, 0x002fbacb, 0x006fbacb, 0x00afbacb, 0x00efbacb,\n+  0x002cbecb, 0x006cbecb, 0x00acbecb, 0x00ecbecb, 0x002dbecb, 0x006dbecb,\n+  0x00adbecb, 0x00edbecb, 0x002ebecb, 0x006ebecb, 0x00aebecb, 0x00eebecb,\n+  0x002fbecb, 0x006fbecb, 0x00afbecb, 0x00efbecb, 0x002cb2db, 0x006cb2db,\n+  0x00acb2db, 0x00ecb2db, 0x002db2db, 0x006db2db, 0x00adb2db, 0x00edb2db,\n+  0x002eb2db, 0x006eb2db, 0x00aeb2db, 0x00eeb2db, 0x002fb2db, 0x006fb2db,\n+  0x00afb2db, 0x00efb2db, 0x002cb6db, 0x006cb6db, 0x00acb6db, 0x00ecb6db,\n+  0x002db6db, 0x006db6db, 0x00adb6db, 0x00edb6db, 0x002eb6db, 0x006eb6db,\n+  0x00aeb6db, 0x00eeb6db, 0x002fb6db, 0x006fb6db, 0x00afb6db, 0x00efb6db,\n+  0x002cbadb, 0x006cbadb, 0x00acbadb, 0x00ecbadb, 0x002dbadb, 0x006dbadb,\n+  0x00adbadb, 0x00edbadb, 0x002ebadb, 0x006ebadb, 0x00aebadb, 0x00eebadb,\n+  0x002fbadb, 0x006fbadb, 0x00afbadb, 0x00efbadb, 0x002cbedb, 0x006cbedb,\n+  0x00acbedb, 0x00ecbedb, 0x002dbedb, 0x006dbedb, 0x00adbedb, 0x00edbedb,\n+  0x002ebedb, 0x006ebedb, 0x00aebedb, 0x00eebedb, 0x002fbedb, 0x006fbedb,\n+  0x00afbedb, 0x00efbedb, 0x002cb2eb, 0x006cb2eb, 0x00acb2eb, 0x00ecb2eb,\n+  0x002db2eb, 0x006db2eb, 0x00adb2eb, 0x00edb2eb, 0x002eb2eb, 0x006eb2eb,\n+  0x00aeb2eb, 0x00eeb2eb, 0x002fb2eb, 0x006fb2eb, 0x00afb2eb, 0x00efb2eb,\n+  0x002cb6eb, 0x006cb6eb, 0x00acb6eb, 0x00ecb6eb, 0x002db6eb, 0x006db6eb,\n+  0x00adb6eb, 0x00edb6eb, 0x002eb6eb, 0x006eb6eb, 0x00aeb6eb, 0x00eeb6eb,\n+  0x002fb6eb, 0x006fb6eb, 0x00afb6eb, 0x00efb6eb, 0x002cbaeb, 0x006cbaeb,\n+  0x00acbaeb, 0x00ecbaeb, 0x002dbaeb, 0x006dbaeb, 0x00adbaeb, 0x00edbaeb,\n+  0x002ebaeb, 0x006ebaeb, 0x00aebaeb, 0x00eebaeb, 0x002fbaeb, 0x006fbaeb,\n+  0x00afbaeb, 0x00efbaeb, 0x002cbeeb, 0x006cbeeb, 0x00acbeeb, 0x00ecbeeb,\n+  0x002dbeeb, 0x006dbeeb, 0x00adbeeb, 0x00edbeeb, 0x002ebeeb, 0x006ebeeb,\n+  0x00aebeeb, 0x00eebeeb, 0x002fbeeb, 0x006fbeeb, 0x00afbeeb, 0x00efbeeb,\n+  0x002cb2fb, 0x006cb2fb, 0x00acb2fb, 0x00ecb2fb, 0x002db2fb, 0x006db2fb,\n+  0x00adb2fb, 0x00edb2fb, 0x002eb2fb, 0x006eb2fb, 0x00aeb2fb, 0x00eeb2fb,\n+  0x002fb2fb, 0x006fb2fb, 0x00afb2fb, 0x00efb2fb, 0x002cb6fb, 0x006cb6fb,\n+  0x00acb6fb, 0x00ecb6fb, 0x002db6fb, 0x006db6fb, 0x00adb6fb, 0x00edb6fb,\n+  0x002eb6fb, 0x006eb6fb, 0x00aeb6fb, 0x00eeb6fb, 0x002fb6fb, 0x006fb6fb,\n+  0x00afb6fb, 0x00efb6fb, 0x002cbafb, 0x006cbafb, 0x00acbafb, 0x00ecbafb,\n+  0x002dbafb, 0x006dbafb, 0x00adbafb, 0x00edbafb, 0x002ebafb, 0x006ebafb,\n+  0x00aebafb, 0x00eebafb, 0x002fbafb, 0x006fbafb, 0x00afbafb, 0x00efbafb,\n+  0x002cbefb, 0x006cbefb, 0x00acbefb, 0x00ecbefb, 0x002dbefb, 0x006dbefb,\n+  0x00adbefb, 0x00edbefb, 0x002ebefb, 0x006ebefb, 0x00aebefb, 0x00eebefb,\n+  0x002fbefb, 0x006fbefb, 0x00afbefb, 0x00efbefb, 0x0b2cb2cb, 0x1b2cb2cb,\n+  0x2b2cb2cb, 0x3b2cb2cb, 0x0b6cb2cb, 0x1b6cb2cb, 0x2b6cb2cb, 0x3b6cb2cb,\n+  0x0bacb2cb, 0x1bacb2cb, 0x2bacb2cb, 0x3bacb2cb, 0x0becb2cb, 0x1becb2cb,\n+  0x2becb2cb, 0x3becb2cb, 0x0b2db2cb, 0x1b2db2cb, 0x2b2db2cb, 0x3b2db2cb,\n+  0x0b6db2cb, 0x1b6db2cb, 0x2b6db2cb, 0x3b6db2cb, 0x0badb2cb, 0x1badb2cb,\n+  0x2badb2cb, 0x3badb2cb, 0x0bedb2cb, 0x1bedb2cb, 0x2bedb2cb, 0x3bedb2cb,\n+  0x0b2eb2cb, 0x1b2eb2cb, 0x2b2eb2cb, 0x3b2eb2cb, 0x0b6eb2cb, 0x1b6eb2cb,\n+  0x2b6eb2cb, 0x3b6eb2cb, 0x0baeb2cb, 0x1baeb2cb, 0x2baeb2cb, 0x3baeb2cb,\n+  0x0beeb2cb, 0x1beeb2cb, 0x2beeb2cb, 0x3beeb2cb, 0x0b2fb2cb, 0x1b2fb2cb,\n+  0x2b2fb2cb, 0x3b2fb2cb, 0x0b6fb2cb, 0x1b6fb2cb, 0x2b6fb2cb, 0x3b6fb2cb,\n+  0x0bafb2cb, 0x1bafb2cb, 0x2bafb2cb, 0x3bafb2cb, 0x0befb2cb, 0x1befb2cb,\n+  0x2befb2cb, 0x3befb2cb, 0x0b2cb6cb, 0x1b2cb6cb, 0x2b2cb6cb, 0x3b2cb6cb,\n+  0x0b6cb6cb, 0x1b6cb6cb, 0x2b6cb6cb, 0x3b6cb6cb, 0x0bacb6cb, 0x1bacb6cb,\n+  0x2bacb6cb, 0x3bacb6cb, 0x0becb6cb, 0x1becb6cb, 0x2becb6cb, 0x3becb6cb,\n+  0x0b2db6cb, 0x1b2db6cb, 0x2b2db6cb, 0x3b2db6cb, 0x0b6db6cb, 0x1b6db6cb,\n+  0x2b6db6cb, 0x3b6db6cb, 0x0badb6cb, 0x1badb6cb, 0x2badb6cb, 0x3badb6cb,\n+  0x0bedb6cb, 0x1bedb6cb, 0x2bedb6cb, 0x3bedb6cb, 0x0b2eb6cb, 0x1b2eb6cb,\n+  0x2b2eb6cb, 0x3b2eb6cb, 0x0b6eb6cb, 0x1b6eb6cb, 0x2b6eb6cb, 0x3b6eb6cb,\n+  0x0baeb6cb, 0x1baeb6cb, 0x2baeb6cb, 0x3baeb6cb, 0x0beeb6cb, 0x1beeb6cb,\n+  0x2beeb6cb, 0x3beeb6cb, 0x0b2fb6cb, 0x1b2fb6cb, 0x2b2fb6cb, 0x3b2fb6cb,\n+  0x0b6fb6cb, 0x1b6fb6cb, 0x2b6fb6cb, 0x3b6fb6cb, 0x0bafb6cb, 0x1bafb6cb,\n+  0x2bafb6cb, 0x3bafb6cb, 0x0befb6cb, 0x1befb6cb, 0x2befb6cb, 0x3befb6cb,\n+  0x0b2cbacb, 0x1b2cbacb, 0x2b2cbacb, 0x3b2cbacb, 0x0b6cbacb, 0x1b6cbacb,\n+  0x2b6cbacb, 0x3b6cbacb, 0x0bacbacb, 0x1bacbacb, 0x2bacbacb, 0x3bacbacb,\n+  0x0becbacb, 0x1becbacb, 0x2becbacb, 0x3becbacb, 0x0b2dbacb, 0x1b2dbacb,\n+  0x2b2dbacb, 0x3b2dbacb, 0x0b6dbacb, 0x1b6dbacb, 0x2b6dbacb, 0x3b6dbacb,\n+  0x0badbacb, 0x1badbacb, 0x2badbacb, 0x3badbacb, 0x0bedbacb, 0x1bedbacb,\n+  0x2bedbacb, 0x3bedbacb, 0x0b2ebacb, 0x1b2ebacb, 0x2b2ebacb, 0x3b2ebacb,\n+  0x0b6ebacb, 0x1b6ebacb, 0x2b6ebacb, 0x3b6ebacb, 0x0baebacb, 0x1baebacb,\n+  0x2baebacb, 0x3baebacb, 0x0beebacb, 0x1beebacb, 0x2beebacb, 0x3beebacb,\n+  0x0b2fbacb, 0x1b2fbacb, 0x2b2fbacb, 0x3b2fbacb, 0x0b6fbacb, 0x1b6fbacb,\n+  0x2b6fbacb, 0x3b6fbacb, 0x0bafbacb, 0x1bafbacb, 0x2bafbacb, 0x3bafbacb,\n+  0x0befbacb, 0x1befbacb, 0x2befbacb, 0x3befbacb, 0x0b2cbecb, 0x1b2cbecb,\n+  0x2b2cbecb, 0x3b2cbecb, 0x0b6cbecb, 0x1b6cbecb, 0x2b6cbecb, 0x3b6cbecb,\n+  0x0bacbecb, 0x1bacbecb, 0x2bacbecb, 0x3bacbecb, 0x0becbecb, 0x1becbecb,\n+  0x2becbecb, 0x3becbecb, 0x0b2dbecb, 0x1b2dbecb, 0x2b2dbecb, 0x3b2dbecb,\n+  0x0b6dbecb, 0x1b6dbecb, 0x2b6dbecb, 0x3b6dbecb, 0x0badbecb, 0x1badbecb,\n+  0x2badbecb, 0x3badbecb, 0x0bedbecb, 0x1bedbecb, 0x2bedbecb, 0x3bedbecb,\n+  0x0b2ebecb, 0x1b2ebecb, 0x2b2ebecb, 0x3b2ebecb, 0x0b6ebecb, 0x1b6ebecb,\n+  0x2b6ebecb, 0x3b6ebecb, 0x0baebecb, 0x1baebecb, 0x2baebecb, 0x3baebecb,\n+  0x0beebecb, 0x1beebecb, 0x2beebecb, 0x3beebecb, 0x0b2fbecb, 0x1b2fbecb,\n+  0x2b2fbecb, 0x3b2fbecb, 0x0b6fbecb, 0x1b6fbecb, 0x2b6fbecb, 0x3b6fbecb,\n+  0x0bafbecb, 0x1bafbecb, 0x2bafbecb, 0x3bafbecb, 0x0befbecb, 0x1befbecb,\n+  0x2befbecb, 0x3befbecb, 0x0b2cb2db, 0x1b2cb2db, 0x2b2cb2db, 0x3b2cb2db,\n+  0x0b6cb2db, 0x1b6cb2db, 0x2b6cb2db, 0x3b6cb2db, 0x0bacb2db, 0x1bacb2db,\n+  0x2bacb2db, 0x3bacb2db, 0x0becb2db, 0x1becb2db, 0x2becb2db, 0x3becb2db,\n+  0x0b2db2db, 0x1b2db2db, 0x2b2db2db, 0x3b2db2db, 0x0b6db2db, 0x1b6db2db,\n+  0x2b6db2db, 0x3b6db2db, 0x0badb2db, 0x1badb2db, 0x2badb2db, 0x3badb2db,\n+  0x0bedb2db, 0x1bedb2db, 0x2bedb2db, 0x3bedb2db, 0x0b2eb2db, 0x1b2eb2db,\n+  0x2b2eb2db, 0x3b2eb2db, 0x0b6eb2db, 0x1b6eb2db, 0x2b6eb2db, 0x3b6eb2db,\n+  0x0baeb2db, 0x1baeb2db, 0x2baeb2db, 0x3baeb2db, 0x0beeb2db, 0x1beeb2db,\n+  0x2beeb2db, 0x3beeb2db, 0x0b2fb2db, 0x1b2fb2db, 0x2b2fb2db, 0x3b2fb2db,\n+  0x0b6fb2db, 0x1b6fb2db, 0x2b6fb2db, 0x3b6fb2db, 0x0bafb2db, 0x1bafb2db,\n+  0x2bafb2db, 0x3bafb2db, 0x0befb2db, 0x1befb2db, 0x2befb2db, 0x3befb2db,\n+  0x0b2cb6db, 0x1b2cb6db, 0x2b2cb6db, 0x3b2cb6db, 0x0b6cb6db, 0x1b6cb6db,\n+  0x2b6cb6db, 0x3b6cb6db, 0x0bacb6db, 0x1bacb6db, 0x2bacb6db, 0x3bacb6db,\n+  0x0becb6db, 0x1becb6db, 0x2becb6db, 0x3becb6db, 0x0b2db6db, 0x1b2db6db,\n+  0x2b2db6db, 0x3b2db6db, 0x0b6db6db, 0x1b6db6db, 0x2b6db6db, 0x3b6db6db,\n+  0x0badb6db, 0x1badb6db, 0x2badb6db, 0x3badb6db, 0x0bedb6db, 0x1bedb6db,\n+  0x2bedb6db, 0x3bedb6db, 0x0b2eb6db, 0x1b2eb6db, 0x2b2eb6db, 0x3b2eb6db,\n+  0x0b6eb6db, 0x1b6eb6db, 0x2b6eb6db, 0x3b6eb6db, 0x0baeb6db, 0x1baeb6db,\n+  0x2baeb6db, 0x3baeb6db,\n+};\n+\n+static const uint32_t kNonZeroRepsDepth[BROTLI_NUM_COMMAND_SYMBOLS] = {\n+   6,  6,  6,  6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n+  12, 12, 12, 12, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n+  18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n+  18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n+  18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n+  18, 18, 18, 18, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+  24, 24, 24, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+  30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+};\n+\n+static const uint16_t kStaticCommandCodeBits[BROTLI_NUM_COMMAND_SYMBOLS] = {\n+    0,  256,  128,  384,   64,  320,  192,  448,\n+   32,  288,  160,  416,   96,  352,  224,  480,\n+   16,  272,  144,  400,   80,  336,  208,  464,\n+   48,  304,  176,  432,  112,  368,  240,  496,\n+    8,  264,  136,  392,   72,  328,  200,  456,\n+   40,  296,  168,  424,  104,  360,  232,  488,\n+   24,  280,  152,  408,   88,  344,  216,  472,\n+   56,  312,  184,  440,  120,  376,  248,  504,\n+    4,  260,  132,  388,   68,  324,  196,  452,\n+   36,  292,  164,  420,  100,  356,  228,  484,\n+   20,  276,  148,  404,   84,  340,  212,  468,\n+   52,  308,  180,  436,  116,  372,  244,  500,\n+   12,  268,  140,  396,   76,  332,  204,  460,\n+   44,  300,  172,  428,  108,  364,  236,  492,\n+   28,  284,  156,  412,   92,  348,  220,  476,\n+   60,  316,  188,  444,  124,  380,  252,  508,\n+    2,  258,  130,  386,   66,  322,  194,  450,\n+   34,  290,  162,  418,   98,  354,  226,  482,\n+   18,  274,  146,  402,   82,  338,  210,  466,\n+   50,  306,  178,  434,  114,  370,  242,  498,\n+   10,  266,  138,  394,   74,  330,  202,  458,\n+   42,  298,  170,  426,  106,  362,  234,  490,\n+   26,  282,  154,  410,   90,  346,  218,  474,\n+   58,  314,  186,  442,  122,  378,  250,  506,\n+    6,  262,  134,  390,   70,  326,  198,  454,\n+   38,  294,  166,  422,  102,  358,  230,  486,\n+   22,  278,  150,  406,   86,  342,  214,  470,\n+   54,  310,  182,  438,  118,  374,  246,  502,\n+   14,  270,  142,  398,   78,  334,  206,  462,\n+   46,  302,  174,  430,  110,  366,  238,  494,\n+   30,  286,  158,  414,   94,  350,  222,  478,\n+   62,  318,  190,  446,  126,  382,  254,  510,\n+    1,  257,  129,  385,   65,  321,  193,  449,\n+   33,  289,  161,  417,   97,  353,  225,  481,\n+   17,  273,  145,  401,   81,  337,  209,  465,\n+   49,  305,  177,  433,  113,  369,  241,  497,\n+    9,  265,  137,  393,   73,  329,  201,  457,\n+   41,  297,  169,  425,  105,  361,  233,  489,\n+   25,  281,  153,  409,   89,  345,  217,  473,\n+   57,  313,  185,  441,  121,  377,  249,  505,\n+    5,  261,  133,  389,   69,  325,  197,  453,\n+   37,  293,  165,  421,  101,  357,  229,  485,\n+   21,  277,  149,  405,   85,  341,  213,  469,\n+   53,  309,  181,  437,  117,  373,  245,  501,\n+   13,  269,  141,  397,   77,  333,  205,  461,\n+   45,  301,  173,  429,  109,  365,  237,  493,\n+   29,  285,  157,  413,   93,  349,  221,  477,\n+   61,  317,  189,  445,  125,  381,  253,  509,\n+    3,  259,  131,  387,   67,  323,  195,  451,\n+   35,  291,  163,  419,   99,  355,  227,  483,\n+   19,  275,  147,  403,   83,  339,  211,  467,\n+   51,  307,  179,  435,  115,  371,  243,  499,\n+   11,  267,  139,  395,   75,  331,  203,  459,\n+   43,  299,  171,  427,  107,  363,  235,  491,\n+   27,  283,  155,  411,   91,  347,  219,  475,\n+   59,  315,  187,  443,  123,  379,  251,  507,\n+    7, 1031,  519, 1543,  263, 1287,  775, 1799,\n+  135, 1159,  647, 1671,  391, 1415,  903, 1927,\n+   71, 1095,  583, 1607,  327, 1351,  839, 1863,\n+  199, 1223,  711, 1735,  455, 1479,  967, 1991,\n+   39, 1063,  551, 1575,  295, 1319,  807, 1831,\n+  167, 1191,  679, 1703,  423, 1447,  935, 1959,\n+  103, 1127,  615, 1639,  359, 1383,  871, 1895,\n+  231, 1255,  743, 1767,  487, 1511,  999, 2023,\n+   23, 1047,  535, 1559,  279, 1303,  791, 1815,\n+  151, 1175,  663, 1687,  407, 1431,  919, 1943,\n+   87, 1111,  599, 1623,  343, 1367,  855, 1879,\n+  215, 1239,  727, 1751,  471, 1495,  983, 2007,\n+   55, 1079,  567, 1591,  311, 1335,  823, 1847,\n+  183, 1207,  695, 1719,  439, 1463,  951, 1975,\n+  119, 1143,  631, 1655,  375, 1399,  887, 1911,\n+  247, 1271,  759, 1783,  503, 1527, 1015, 2039,\n+   15, 1039,  527, 1551,  271, 1295,  783, 1807,\n+  143, 1167,  655, 1679,  399, 1423,  911, 1935,\n+   79, 1103,  591, 1615,  335, 1359,  847, 1871,\n+  207, 1231,  719, 1743,  463, 1487,  975, 1999,\n+   47, 1071,  559, 1583,  303, 1327,  815, 1839,\n+  175, 1199,  687, 1711,  431, 1455,  943, 1967,\n+  111, 1135,  623, 1647,  367, 1391,  879, 1903,\n+  239, 1263,  751, 1775,  495, 1519, 1007, 2031,\n+   31, 1055,  543, 1567,  287, 1311,  799, 1823,\n+  159, 1183,  671, 1695,  415, 1439,  927, 1951,\n+   95, 1119,  607, 1631,  351, 1375,  863, 1887,\n+  223, 1247,  735, 1759,  479, 1503,  991, 2015,\n+   63, 1087,  575, 1599,  319, 1343,  831, 1855,\n+  191, 1215,  703, 1727,  447, 1471,  959, 1983,\n+  127, 1151,  639, 1663,  383, 1407,  895, 1919,\n+  255, 1279,  767, 1791,  511, 1535, 1023, 2047,\n+};\n+\n+static BROTLI_INLINE void StoreStaticCommandHuffmanTree(\n+    size_t* storage_ix, uint8_t* storage) {\n+  BrotliWriteBits(\n+      56, BROTLI_MAKE_UINT64_T(0x926244U, 0x16307003U), storage_ix, storage);\n+  BrotliWriteBits(3, 0x00000000U, storage_ix, storage);\n+}\n+\n+static const uint16_t kStaticDistanceCodeBits[64] = {\n+   0, 32, 16, 48,  8, 40, 24, 56,  4, 36, 20, 52, 12, 44, 28, 60,\n+   2, 34, 18, 50, 10, 42, 26, 58,  6, 38, 22, 54, 14, 46, 30, 62,\n+   1, 33, 17, 49,  9, 41, 25, 57,  5, 37, 21, 53, 13, 45, 29, 61,\n+   3, 35, 19, 51, 11, 43, 27, 59,  7, 39, 23, 55, 15, 47, 31, 63,\n+};\n+\n+static BROTLI_INLINE void StoreStaticDistanceHuffmanTree(\n+    size_t* storage_ix, uint8_t* storage) {\n+  BrotliWriteBits(28, 0x0369DC03u, storage_ix, storage);\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_ENTROPY_ENCODE_STATIC_H_ */"
        },
        {
            "sha": "cade1235adeb7a50c8ad1189e7ba3fbd154b23ed",
            "filename": "deps/brotli/c/enc/fast_log.h",
            "status": "added",
            "additions": 147,
            "deletions": 0,
            "changes": 147,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Ffast_log.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Ffast_log.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Ffast_log.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,147 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Utilities for fast computation of logarithms. */\n+\n+#ifndef BROTLI_ENC_FAST_LOG_H_\n+#define BROTLI_ENC_FAST_LOG_H_\n+\n+#include <math.h>\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+static BROTLI_INLINE uint32_t Log2FloorNonZero(size_t n) {\n+  /* TODO: generalize and move to platform.h */\n+#if BROTLI_GNUC_HAS_BUILTIN(__builtin_clz, 3, 4, 0) || \\\n+    BROTLI_INTEL_VERSION_CHECK(16, 0, 0)\n+  return 31u ^ (uint32_t)__builtin_clz((uint32_t)n);\n+#else\n+  uint32_t result = 0;\n+  while (n >>= 1) result++;\n+  return result;\n+#endif\n+}\n+\n+/* A lookup table for small values of log2(int) to be used in entropy\n+   computation.\n+\n+   \", \".join([\"%.16ff\" % x for x in [0.0]+[log2(x) for x in range(1, 256)]]) */\n+static const float kLog2Table[] = {\n+  0.0000000000000000f, 0.0000000000000000f, 1.0000000000000000f,\n+  1.5849625007211563f, 2.0000000000000000f, 2.3219280948873622f,\n+  2.5849625007211561f, 2.8073549220576042f, 3.0000000000000000f,\n+  3.1699250014423126f, 3.3219280948873626f, 3.4594316186372978f,\n+  3.5849625007211565f, 3.7004397181410922f, 3.8073549220576037f,\n+  3.9068905956085187f, 4.0000000000000000f, 4.0874628412503400f,\n+  4.1699250014423122f, 4.2479275134435852f, 4.3219280948873626f,\n+  4.3923174227787607f, 4.4594316186372973f, 4.5235619560570131f,\n+  4.5849625007211570f, 4.6438561897747244f, 4.7004397181410926f,\n+  4.7548875021634691f, 4.8073549220576037f, 4.8579809951275728f,\n+  4.9068905956085187f, 4.9541963103868758f, 5.0000000000000000f,\n+  5.0443941193584534f, 5.0874628412503400f, 5.1292830169449664f,\n+  5.1699250014423122f, 5.2094533656289501f, 5.2479275134435852f,\n+  5.2854022188622487f, 5.3219280948873626f, 5.3575520046180838f,\n+  5.3923174227787607f, 5.4262647547020979f, 5.4594316186372973f,\n+  5.4918530963296748f, 5.5235619560570131f, 5.5545888516776376f,\n+  5.5849625007211570f, 5.6147098441152083f, 5.6438561897747244f,\n+  5.6724253419714961f, 5.7004397181410926f, 5.7279204545631996f,\n+  5.7548875021634691f, 5.7813597135246599f, 5.8073549220576046f,\n+  5.8328900141647422f, 5.8579809951275719f, 5.8826430493618416f,\n+  5.9068905956085187f, 5.9307373375628867f, 5.9541963103868758f,\n+  5.9772799234999168f, 6.0000000000000000f, 6.0223678130284544f,\n+  6.0443941193584534f, 6.0660891904577721f, 6.0874628412503400f,\n+  6.1085244567781700f, 6.1292830169449672f, 6.1497471195046822f,\n+  6.1699250014423122f, 6.1898245588800176f, 6.2094533656289510f,\n+  6.2288186904958804f, 6.2479275134435861f, 6.2667865406949019f,\n+  6.2854022188622487f, 6.3037807481771031f, 6.3219280948873617f,\n+  6.3398500028846252f, 6.3575520046180847f, 6.3750394313469254f,\n+  6.3923174227787598f, 6.4093909361377026f, 6.4262647547020979f,\n+  6.4429434958487288f, 6.4594316186372982f, 6.4757334309663976f,\n+  6.4918530963296748f, 6.5077946401986964f, 6.5235619560570131f,\n+  6.5391588111080319f, 6.5545888516776376f, 6.5698556083309478f,\n+  6.5849625007211561f, 6.5999128421871278f, 6.6147098441152092f,\n+  6.6293566200796095f, 6.6438561897747253f, 6.6582114827517955f,\n+  6.6724253419714952f, 6.6865005271832185f, 6.7004397181410917f,\n+  6.7142455176661224f, 6.7279204545631988f, 6.7414669864011465f,\n+  6.7548875021634691f, 6.7681843247769260f, 6.7813597135246599f,\n+  6.7944158663501062f, 6.8073549220576037f, 6.8201789624151887f,\n+  6.8328900141647422f, 6.8454900509443757f, 6.8579809951275719f,\n+  6.8703647195834048f, 6.8826430493618416f, 6.8948177633079437f,\n+  6.9068905956085187f, 6.9188632372745955f, 6.9307373375628867f,\n+  6.9425145053392399f, 6.9541963103868758f, 6.9657842846620879f,\n+  6.9772799234999168f, 6.9886846867721664f, 7.0000000000000000f,\n+  7.0112272554232540f, 7.0223678130284544f, 7.0334230015374501f,\n+  7.0443941193584534f, 7.0552824355011898f, 7.0660891904577721f,\n+  7.0768155970508317f, 7.0874628412503400f, 7.0980320829605272f,\n+  7.1085244567781700f, 7.1189410727235076f, 7.1292830169449664f,\n+  7.1395513523987937f, 7.1497471195046822f, 7.1598713367783891f,\n+  7.1699250014423130f, 7.1799090900149345f, 7.1898245588800176f,\n+  7.1996723448363644f, 7.2094533656289492f, 7.2191685204621621f,\n+  7.2288186904958804f, 7.2384047393250794f, 7.2479275134435861f,\n+  7.2573878426926521f, 7.2667865406949019f, 7.2761244052742384f,\n+  7.2854022188622487f, 7.2946207488916270f, 7.3037807481771031f,\n+  7.3128829552843557f, 7.3219280948873617f, 7.3309168781146177f,\n+  7.3398500028846243f, 7.3487281542310781f, 7.3575520046180847f,\n+  7.3663222142458151f, 7.3750394313469254f, 7.3837042924740528f,\n+  7.3923174227787607f, 7.4008794362821844f, 7.4093909361377026f,\n+  7.4178525148858991f, 7.4262647547020979f, 7.4346282276367255f,\n+  7.4429434958487288f, 7.4512111118323299f, 7.4594316186372973f,\n+  7.4676055500829976f, 7.4757334309663976f, 7.4838157772642564f,\n+  7.4918530963296748f, 7.4998458870832057f, 7.5077946401986964f,\n+  7.5156998382840436f, 7.5235619560570131f, 7.5313814605163119f,\n+  7.5391588111080319f, 7.5468944598876373f, 7.5545888516776376f,\n+  7.5622424242210728f, 7.5698556083309478f, 7.5774288280357487f,\n+  7.5849625007211561f, 7.5924570372680806f, 7.5999128421871278f,\n+  7.6073303137496113f, 7.6147098441152075f, 7.6220518194563764f,\n+  7.6293566200796095f, 7.6366246205436488f, 7.6438561897747244f,\n+  7.6510516911789290f, 7.6582114827517955f, 7.6653359171851765f,\n+  7.6724253419714952f, 7.6794800995054464f, 7.6865005271832185f,\n+  7.6934869574993252f, 7.7004397181410926f, 7.7073591320808825f,\n+  7.7142455176661224f, 7.7210991887071856f, 7.7279204545631996f,\n+  7.7347096202258392f, 7.7414669864011465f, 7.7481928495894596f,\n+  7.7548875021634691f, 7.7615512324444795f, 7.7681843247769260f,\n+  7.7747870596011737f, 7.7813597135246608f, 7.7879025593914317f,\n+  7.7944158663501062f, 7.8008998999203047f, 7.8073549220576037f,\n+  7.8137811912170374f, 7.8201789624151887f, 7.8265484872909159f,\n+  7.8328900141647422f, 7.8392037880969445f, 7.8454900509443757f,\n+  7.8517490414160571f, 7.8579809951275719f, 7.8641861446542798f,\n+  7.8703647195834048f, 7.8765169465650002f, 7.8826430493618425f,\n+  7.8887432488982601f, 7.8948177633079446f, 7.9008668079807496f,\n+  7.9068905956085187f, 7.9128893362299619f, 7.9188632372745955f,\n+  7.9248125036057813f, 7.9307373375628867f, 7.9366379390025719f,\n+  7.9425145053392399f, 7.9483672315846778f, 7.9541963103868758f,\n+  7.9600019320680806f, 7.9657842846620870f, 7.9715435539507720f,\n+  7.9772799234999168f, 7.9829935746943104f, 7.9886846867721664f,\n+  7.9943534368588578f\n+};\n+\n+#define LOG_2_INV 1.4426950408889634\n+\n+/* Faster logarithm for small integers, with the property of log2(0) == 0. */\n+static BROTLI_INLINE double FastLog2(size_t v) {\n+  if (v < sizeof(kLog2Table) / sizeof(kLog2Table[0])) {\n+    return kLog2Table[v];\n+  }\n+#if (defined(_MSC_VER) && _MSC_VER <= 1700) || \\\n+    (defined(__ANDROID_API__) && __ANDROID_API__ < 18)\n+  /* Visual Studio 2012 and Android API levels < 18 do not have the log2()\n+   * function defined, so we use log() and a multiplication instead. */\n+  return log((double)v) * LOG_2_INV;\n+#else\n+  return log2((double)v);\n+#endif\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_FAST_LOG_H_ */"
        },
        {
            "sha": "bc428cffdaf17cd98bdf4a20c76ea62c684c447c",
            "filename": "deps/brotli/c/enc/find_match_length.h",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Ffind_match_length.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Ffind_match_length.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Ffind_match_length.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,80 @@\n+/* Copyright 2010 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Function to find maximal matching prefixes of strings. */\n+\n+#ifndef BROTLI_ENC_FIND_MATCH_LENGTH_H_\n+#define BROTLI_ENC_FIND_MATCH_LENGTH_H_\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* Separate implementation for little-endian 64-bit targets, for speed. */\n+#if defined(__GNUC__) && defined(_LP64) && defined(BROTLI_LITTLE_ENDIAN)\n+\n+static BROTLI_INLINE size_t FindMatchLengthWithLimit(const uint8_t* s1,\n+                                                     const uint8_t* s2,\n+                                                     size_t limit) {\n+  size_t matched = 0;\n+  size_t limit2 = (limit >> 3) + 1;  /* + 1 is for pre-decrement in while */\n+  while (BROTLI_PREDICT_TRUE(--limit2)) {\n+    if (BROTLI_PREDICT_FALSE(BROTLI_UNALIGNED_LOAD64LE(s2) ==\n+                      BROTLI_UNALIGNED_LOAD64LE(s1 + matched))) {\n+      s2 += 8;\n+      matched += 8;\n+    } else {\n+      uint64_t x = BROTLI_UNALIGNED_LOAD64LE(s2) ^\n+          BROTLI_UNALIGNED_LOAD64LE(s1 + matched);\n+      size_t matching_bits = (size_t)__builtin_ctzll(x);\n+      matched += matching_bits >> 3;\n+      return matched;\n+    }\n+  }\n+  limit = (limit & 7) + 1;  /* + 1 is for pre-decrement in while */\n+  while (--limit) {\n+    if (BROTLI_PREDICT_TRUE(s1[matched] == *s2)) {\n+      ++s2;\n+      ++matched;\n+    } else {\n+      return matched;\n+    }\n+  }\n+  return matched;\n+}\n+#else\n+static BROTLI_INLINE size_t FindMatchLengthWithLimit(const uint8_t* s1,\n+                                                     const uint8_t* s2,\n+                                                     size_t limit) {\n+  size_t matched = 0;\n+  const uint8_t* s2_limit = s2 + limit;\n+  const uint8_t* s2_ptr = s2;\n+  /* Find out how long the match is. We loop over the data 32 bits at a\n+     time until we find a 32-bit block that doesn't match; then we find\n+     the first non-matching bit and use that to calculate the total\n+     length of the match. */\n+  while (s2_ptr <= s2_limit - 4 &&\n+         BrotliUnalignedRead32(s2_ptr) ==\n+         BrotliUnalignedRead32(s1 + matched)) {\n+    s2_ptr += 4;\n+    matched += 4;\n+  }\n+  while ((s2_ptr < s2_limit) && (s1[matched] == *s2_ptr)) {\n+    ++s2_ptr;\n+    ++matched;\n+  }\n+  return matched;\n+}\n+#endif\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_FIND_MATCH_LENGTH_H_ */"
        },
        {
            "sha": "8c5a7bb5ad5d55c6dd10fb5eed445db473bdf265",
            "filename": "deps/brotli/c/enc/hash.h",
            "status": "added",
            "additions": 498,
            "deletions": 0,
            "changes": 498,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhash.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,498 @@\n+/* Copyright 2010 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* A (forgetful) hash table to the data seen by the compressor, to\n+   help create backward references to previous data. */\n+\n+#ifndef BROTLI_ENC_HASH_H_\n+#define BROTLI_ENC_HASH_H_\n+\n+#include <string.h>  /* memcmp, memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/dictionary.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./encoder_dict.h\"\n+#include \"./fast_log.h\"\n+#include \"./find_match_length.h\"\n+#include \"./memory.h\"\n+#include \"./quality.h\"\n+#include \"./static_dict.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* Pointer to hasher data.\n+ *\n+ * Excluding initialization and destruction, hasher can be passed as\n+ * HasherHandle by value.\n+ *\n+ * Typically hasher data consists of 3 sections:\n+ * * HasherCommon structure\n+ * * private structured hasher data, depending on hasher type\n+ * * private dynamic hasher data, depending on hasher type and parameters\n+ *\n+ * Using \"define\" instead of \"typedef\", because on MSVC __restrict does not work\n+ * on typedef pointer types. */\n+#define HasherHandle uint8_t*\n+\n+typedef struct {\n+  BrotliHasherParams params;\n+\n+  /* False if hasher needs to be \"prepared\" before use. */\n+  BROTLI_BOOL is_prepared_;\n+\n+  size_t dict_num_lookups;\n+  size_t dict_num_matches;\n+} HasherCommon;\n+\n+static BROTLI_INLINE HasherCommon* GetHasherCommon(HasherHandle handle) {\n+  return (HasherCommon*)handle;\n+}\n+\n+#define score_t size_t\n+\n+static const uint32_t kCutoffTransformsCount = 10;\n+/*   0,  12,   27,    23,    42,    63,    56,    48,    59,    64 */\n+/* 0+0, 4+8, 8+19, 12+11, 16+26, 20+43, 24+32, 28+20, 32+27, 36+28 */\n+static const uint64_t kCutoffTransforms =\n+    BROTLI_MAKE_UINT64_T(0x071B520A, 0xDA2D3200);\n+\n+typedef struct HasherSearchResult {\n+  size_t len;\n+  size_t distance;\n+  score_t score;\n+  int len_code_delta; /* == len_code - len */\n+} HasherSearchResult;\n+\n+/* kHashMul32 multiplier has these properties:\n+   * The multiplier must be odd. Otherwise we may lose the highest bit.\n+   * No long streaks of ones or zeros.\n+   * There is no effort to ensure that it is a prime, the oddity is enough\n+     for this use.\n+   * The number has been tuned heuristically against compression benchmarks. */\n+static const uint32_t kHashMul32 = 0x1E35A7BD;\n+static const uint64_t kHashMul64 = BROTLI_MAKE_UINT64_T(0x1E35A7BD, 0x1E35A7BD);\n+static const uint64_t kHashMul64Long =\n+    BROTLI_MAKE_UINT64_T(0x1FE35A7Bu, 0xD3579BD3u);\n+\n+static BROTLI_INLINE uint32_t Hash14(const uint8_t* data) {\n+  uint32_t h = BROTLI_UNALIGNED_LOAD32LE(data) * kHashMul32;\n+  /* The higher bits contain more mixture from the multiplication,\n+     so we take our results from there. */\n+  return h >> (32 - 14);\n+}\n+\n+static BROTLI_INLINE void PrepareDistanceCache(\n+    int* BROTLI_RESTRICT distance_cache, const int num_distances) {\n+  if (num_distances > 4) {\n+    int last_distance = distance_cache[0];\n+    distance_cache[4] = last_distance - 1;\n+    distance_cache[5] = last_distance + 1;\n+    distance_cache[6] = last_distance - 2;\n+    distance_cache[7] = last_distance + 2;\n+    distance_cache[8] = last_distance - 3;\n+    distance_cache[9] = last_distance + 3;\n+    if (num_distances > 10) {\n+      int next_last_distance = distance_cache[1];\n+      distance_cache[10] = next_last_distance - 1;\n+      distance_cache[11] = next_last_distance + 1;\n+      distance_cache[12] = next_last_distance - 2;\n+      distance_cache[13] = next_last_distance + 2;\n+      distance_cache[14] = next_last_distance - 3;\n+      distance_cache[15] = next_last_distance + 3;\n+    }\n+  }\n+}\n+\n+#define BROTLI_LITERAL_BYTE_SCORE 135\n+#define BROTLI_DISTANCE_BIT_PENALTY 30\n+/* Score must be positive after applying maximal penalty. */\n+#define BROTLI_SCORE_BASE (BROTLI_DISTANCE_BIT_PENALTY * 8 * sizeof(size_t))\n+\n+/* Usually, we always choose the longest backward reference. This function\n+   allows for the exception of that rule.\n+\n+   If we choose a backward reference that is further away, it will\n+   usually be coded with more bits. We approximate this by assuming\n+   log2(distance). If the distance can be expressed in terms of the\n+   last four distances, we use some heuristic constants to estimate\n+   the bits cost. For the first up to four literals we use the bit\n+   cost of the literals from the literal cost model, after that we\n+   use the average bit cost of the cost model.\n+\n+   This function is used to sometimes discard a longer backward reference\n+   when it is not much longer and the bit cost for encoding it is more\n+   than the saved literals.\n+\n+   backward_reference_offset MUST be positive. */\n+static BROTLI_INLINE score_t BackwardReferenceScore(\n+    size_t copy_length, size_t backward_reference_offset) {\n+  return BROTLI_SCORE_BASE + BROTLI_LITERAL_BYTE_SCORE * (score_t)copy_length -\n+      BROTLI_DISTANCE_BIT_PENALTY * Log2FloorNonZero(backward_reference_offset);\n+}\n+\n+static BROTLI_INLINE score_t BackwardReferenceScoreUsingLastDistance(\n+    size_t copy_length) {\n+  return BROTLI_LITERAL_BYTE_SCORE * (score_t)copy_length +\n+      BROTLI_SCORE_BASE + 15;\n+}\n+\n+static BROTLI_INLINE score_t BackwardReferencePenaltyUsingLastDistance(\n+    size_t distance_short_code) {\n+  return (score_t)39 + ((0x1CA10 >> (distance_short_code & 0xE)) & 0xE);\n+}\n+\n+static BROTLI_INLINE BROTLI_BOOL TestStaticDictionaryItem(\n+    const BrotliEncoderDictionary* dictionary, size_t item,\n+    const uint8_t* data, size_t max_length, size_t max_backward,\n+    size_t max_distance, HasherSearchResult* out) {\n+  size_t len;\n+  size_t word_idx;\n+  size_t offset;\n+  size_t matchlen;\n+  size_t backward;\n+  score_t score;\n+  len = item & 0x1F;\n+  word_idx = item >> 5;\n+  offset = dictionary->words->offsets_by_length[len] + len * word_idx;\n+  if (len > max_length) {\n+    return BROTLI_FALSE;\n+  }\n+\n+  matchlen =\n+      FindMatchLengthWithLimit(data, &dictionary->words->data[offset], len);\n+  if (matchlen + dictionary->cutoffTransformsCount <= len || matchlen == 0) {\n+    return BROTLI_FALSE;\n+  }\n+  {\n+    size_t cut = len - matchlen;\n+    size_t transform_id = (cut << 2) +\n+        (size_t)((dictionary->cutoffTransforms >> (cut * 6)) & 0x3F);\n+    backward = max_backward + 1 + word_idx +\n+        (transform_id << dictionary->words->size_bits_by_length[len]);\n+  }\n+  if (backward > max_distance) {\n+    return BROTLI_FALSE;\n+  }\n+  score = BackwardReferenceScore(matchlen, backward);\n+  if (score < out->score) {\n+    return BROTLI_FALSE;\n+  }\n+  out->len = matchlen;\n+  out->len_code_delta = (int)len - (int)matchlen;\n+  out->distance = backward;\n+  out->score = score;\n+  return BROTLI_TRUE;\n+}\n+\n+static BROTLI_INLINE void SearchInStaticDictionary(\n+    const BrotliEncoderDictionary* dictionary,\n+    HasherHandle handle, const uint8_t* data, size_t max_length,\n+    size_t max_backward, size_t max_distance,\n+    HasherSearchResult* out, BROTLI_BOOL shallow) {\n+  size_t key;\n+  size_t i;\n+  HasherCommon* self = GetHasherCommon(handle);\n+  if (self->dict_num_matches < (self->dict_num_lookups >> 7)) {\n+    return;\n+  }\n+  key = Hash14(data) << 1;\n+  for (i = 0; i < (shallow ? 1u : 2u); ++i, ++key) {\n+    size_t item = dictionary->hash_table[key];\n+    self->dict_num_lookups++;\n+    if (item != 0) {\n+      BROTLI_BOOL item_matches = TestStaticDictionaryItem(\n+          dictionary, item, data,\n+          max_length, max_backward, max_distance, out);\n+      if (item_matches) {\n+        self->dict_num_matches++;\n+      }\n+    }\n+  }\n+}\n+\n+typedef struct BackwardMatch {\n+  uint32_t distance;\n+  uint32_t length_and_code;\n+} BackwardMatch;\n+\n+static BROTLI_INLINE void InitBackwardMatch(BackwardMatch* self,\n+    size_t dist, size_t len) {\n+  self->distance = (uint32_t)dist;\n+  self->length_and_code = (uint32_t)(len << 5);\n+}\n+\n+static BROTLI_INLINE void InitDictionaryBackwardMatch(BackwardMatch* self,\n+    size_t dist, size_t len, size_t len_code) {\n+  self->distance = (uint32_t)dist;\n+  self->length_and_code =\n+      (uint32_t)((len << 5) | (len == len_code ? 0 : len_code));\n+}\n+\n+static BROTLI_INLINE size_t BackwardMatchLength(const BackwardMatch* self) {\n+  return self->length_and_code >> 5;\n+}\n+\n+static BROTLI_INLINE size_t BackwardMatchLengthCode(const BackwardMatch* self) {\n+  size_t code = self->length_and_code & 31;\n+  return code ? code : BackwardMatchLength(self);\n+}\n+\n+#define EXPAND_CAT(a, b) CAT(a, b)\n+#define CAT(a, b) a ## b\n+#define FN(X) EXPAND_CAT(X, HASHER())\n+\n+#define HASHER() H10\n+#define BUCKET_BITS 17\n+#define MAX_TREE_SEARCH_DEPTH 64\n+#define MAX_TREE_COMP_LENGTH 128\n+#include \"./hash_to_binary_tree_inc.h\"  /* NOLINT(build/include) */\n+#undef MAX_TREE_SEARCH_DEPTH\n+#undef MAX_TREE_COMP_LENGTH\n+#undef BUCKET_BITS\n+#undef HASHER\n+/* MAX_NUM_MATCHES == 64 + MAX_TREE_SEARCH_DEPTH */\n+#define MAX_NUM_MATCHES_H10 128\n+\n+/* For BUCKET_SWEEP == 1, enabling the dictionary lookup makes compression\n+   a little faster (0.5% - 1%) and it compresses 0.15% better on small text\n+   and HTML inputs. */\n+\n+#define HASHER() H2\n+#define BUCKET_BITS 16\n+#define BUCKET_SWEEP 1\n+#define HASH_LEN 5\n+#define USE_DICTIONARY 1\n+#include \"./hash_longest_match_quickly_inc.h\"  /* NOLINT(build/include) */\n+#undef BUCKET_SWEEP\n+#undef USE_DICTIONARY\n+#undef HASHER\n+\n+#define HASHER() H3\n+#define BUCKET_SWEEP 2\n+#define USE_DICTIONARY 0\n+#include \"./hash_longest_match_quickly_inc.h\"  /* NOLINT(build/include) */\n+#undef USE_DICTIONARY\n+#undef BUCKET_SWEEP\n+#undef BUCKET_BITS\n+#undef HASHER\n+\n+#define HASHER() H4\n+#define BUCKET_BITS 17\n+#define BUCKET_SWEEP 4\n+#define USE_DICTIONARY 1\n+#include \"./hash_longest_match_quickly_inc.h\"  /* NOLINT(build/include) */\n+#undef USE_DICTIONARY\n+#undef HASH_LEN\n+#undef BUCKET_SWEEP\n+#undef BUCKET_BITS\n+#undef HASHER\n+\n+#define HASHER() H5\n+#include \"./hash_longest_match_inc.h\"  /* NOLINT(build/include) */\n+#undef HASHER\n+\n+#define HASHER() H6\n+#include \"./hash_longest_match64_inc.h\"  /* NOLINT(build/include) */\n+#undef HASHER\n+\n+#define BUCKET_BITS 15\n+\n+#define NUM_LAST_DISTANCES_TO_CHECK 4\n+#define NUM_BANKS 1\n+#define BANK_BITS 16\n+#define HASHER() H40\n+#include \"./hash_forgetful_chain_inc.h\"  /* NOLINT(build/include) */\n+#undef HASHER\n+#undef NUM_LAST_DISTANCES_TO_CHECK\n+\n+#define NUM_LAST_DISTANCES_TO_CHECK 10\n+#define HASHER() H41\n+#include \"./hash_forgetful_chain_inc.h\"  /* NOLINT(build/include) */\n+#undef HASHER\n+#undef NUM_LAST_DISTANCES_TO_CHECK\n+#undef NUM_BANKS\n+#undef BANK_BITS\n+\n+#define NUM_LAST_DISTANCES_TO_CHECK 16\n+#define NUM_BANKS 512\n+#define BANK_BITS 9\n+#define HASHER() H42\n+#include \"./hash_forgetful_chain_inc.h\"  /* NOLINT(build/include) */\n+#undef HASHER\n+#undef NUM_LAST_DISTANCES_TO_CHECK\n+#undef NUM_BANKS\n+#undef BANK_BITS\n+\n+#undef BUCKET_BITS\n+\n+#define HASHER() H54\n+#define BUCKET_BITS 20\n+#define BUCKET_SWEEP 4\n+#define HASH_LEN 7\n+#define USE_DICTIONARY 0\n+#include \"./hash_longest_match_quickly_inc.h\"  /* NOLINT(build/include) */\n+#undef USE_DICTIONARY\n+#undef HASH_LEN\n+#undef BUCKET_SWEEP\n+#undef BUCKET_BITS\n+#undef HASHER\n+\n+/* fast large window hashers */\n+\n+#define HASHER() HROLLING_FAST\n+#define CHUNKLEN 32\n+#define JUMP 4\n+#define NUMBUCKETS 16777216\n+#define MASK ((NUMBUCKETS * 64) - 1)\n+#include \"./hash_rolling_inc.h\"  /* NOLINT(build/include) */\n+#undef JUMP\n+#undef HASHER\n+\n+\n+#define HASHER() HROLLING\n+#define JUMP 1\n+#include \"./hash_rolling_inc.h\"  /* NOLINT(build/include) */\n+#undef MASK\n+#undef NUMBUCKETS\n+#undef JUMP\n+#undef CHUNKLEN\n+#undef HASHER\n+\n+#define HASHER() H35\n+#define HASHER_A H3\n+#define HASHER_B HROLLING_FAST\n+#include \"./hash_composite_inc.h\"  /* NOLINT(build/include) */\n+#undef HASHER_A\n+#undef HASHER_B\n+#undef HASHER\n+\n+#define HASHER() H55\n+#define HASHER_A H54\n+#define HASHER_B HROLLING_FAST\n+#include \"./hash_composite_inc.h\"  /* NOLINT(build/include) */\n+#undef HASHER_A\n+#undef HASHER_B\n+#undef HASHER\n+\n+#define HASHER() H65\n+#define HASHER_A H6\n+#define HASHER_B HROLLING\n+#include \"./hash_composite_inc.h\"  /* NOLINT(build/include) */\n+#undef HASHER_A\n+#undef HASHER_B\n+#undef HASHER\n+\n+#undef FN\n+#undef CAT\n+#undef EXPAND_CAT\n+\n+#define FOR_GENERIC_HASHERS(H) H(2) H(3) H(4) H(5) H(6) H(40) H(41) H(42) H(54)\\\n+                               H(35) H(55) H(65)\n+#define FOR_ALL_HASHERS(H) FOR_GENERIC_HASHERS(H) H(10)\n+\n+static BROTLI_INLINE void DestroyHasher(\n+    MemoryManager* m, HasherHandle* handle) {\n+  if (*handle == NULL) return;\n+  BROTLI_FREE(m, *handle);\n+}\n+\n+static BROTLI_INLINE void HasherReset(HasherHandle handle) {\n+  if (handle == NULL) return;\n+  GetHasherCommon(handle)->is_prepared_ = BROTLI_FALSE;\n+}\n+\n+static BROTLI_INLINE size_t HasherSize(const BrotliEncoderParams* params,\n+    BROTLI_BOOL one_shot, const size_t input_size) {\n+  size_t result = sizeof(HasherCommon);\n+  switch (params->hasher.type) {\n+#define SIZE_(N)                                                         \\\n+    case N:                                                              \\\n+      result += HashMemAllocInBytesH ## N(params, one_shot, input_size); \\\n+      break;\n+    FOR_ALL_HASHERS(SIZE_)\n+#undef SIZE_\n+    default:\n+      break;\n+  }\n+  return result;\n+}\n+\n+static BROTLI_INLINE void HasherSetup(MemoryManager* m, HasherHandle* handle,\n+    BrotliEncoderParams* params, const uint8_t* data, size_t position,\n+    size_t input_size, BROTLI_BOOL is_last) {\n+  HasherHandle self = NULL;\n+  HasherCommon* common = NULL;\n+  BROTLI_BOOL one_shot = (position == 0 && is_last);\n+  if (*handle == NULL) {\n+    size_t alloc_size;\n+    ChooseHasher(params, &params->hasher);\n+    alloc_size = HasherSize(params, one_shot, input_size);\n+    self = BROTLI_ALLOC(m, uint8_t, alloc_size);\n+    if (BROTLI_IS_OOM(m)) return;\n+    *handle = self;\n+    common = GetHasherCommon(self);\n+    common->params = params->hasher;\n+    switch (common->params.type) {\n+#define INITIALIZE_(N)                     \\\n+      case N:                              \\\n+        InitializeH ## N(*handle, params); \\\n+        break;\n+      FOR_ALL_HASHERS(INITIALIZE_);\n+#undef INITIALIZE_\n+      default:\n+        break;\n+    }\n+    HasherReset(*handle);\n+  }\n+\n+  self = *handle;\n+  common = GetHasherCommon(self);\n+  if (!common->is_prepared_) {\n+    switch (common->params.type) {\n+#define PREPARE_(N)                                      \\\n+      case N:                                            \\\n+        PrepareH ## N(self, one_shot, input_size, data); \\\n+        break;\n+      FOR_ALL_HASHERS(PREPARE_)\n+#undef PREPARE_\n+      default: break;\n+    }\n+    if (position == 0) {\n+        common->dict_num_lookups = 0;\n+        common->dict_num_matches = 0;\n+    }\n+    common->is_prepared_ = BROTLI_TRUE;\n+  }\n+}\n+\n+static BROTLI_INLINE void InitOrStitchToPreviousBlock(\n+    MemoryManager* m, HasherHandle* handle, const uint8_t* data, size_t mask,\n+    BrotliEncoderParams* params, size_t position, size_t input_size,\n+    BROTLI_BOOL is_last) {\n+  HasherHandle self;\n+  HasherSetup(m, handle, params, data, position, input_size, is_last);\n+  if (BROTLI_IS_OOM(m)) return;\n+  self = *handle;\n+  switch (GetHasherCommon(self)->params.type) {\n+#define INIT_(N)                                                           \\\n+    case N:                                                                \\\n+      StitchToPreviousBlockH ## N(self, input_size, position, data, mask); \\\n+    break;\n+    FOR_ALL_HASHERS(INIT_)\n+#undef INIT_\n+    default: break;\n+  }\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_HASH_H_ */"
        },
        {
            "sha": "b266aa2f8da470785c66014d743f9094cc434518",
            "filename": "deps/brotli/c/enc/hash_composite_inc.h",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_composite_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_composite_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhash_composite_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,136 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2018 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN, HASHER_A, HASHER_B */\n+\n+/* Composite hasher: This hasher allows to combine two other hashers, HASHER_A\n+   and HASHER_B. */\n+\n+#define HashComposite HASHER()\n+\n+#define FN_A(X) EXPAND_CAT(X, HASHER_A)\n+#define FN_B(X) EXPAND_CAT(X, HASHER_B)\n+\n+static BROTLI_INLINE size_t FN(HashTypeLength)(void) {\n+  size_t a =  FN_A(HashTypeLength)();\n+  size_t b =  FN_B(HashTypeLength)();\n+  return a > b ? a : b;\n+}\n+\n+static BROTLI_INLINE size_t FN(StoreLookahead)(void) {\n+  size_t a =  FN_A(StoreLookahead)();\n+  size_t b =  FN_B(StoreLookahead)();\n+  return a > b ? a : b;\n+}\n+\n+typedef struct HashComposite {\n+  HasherHandle ha;\n+  HasherHandle hb;\n+  const BrotliEncoderParams* params;\n+} HashComposite;\n+\n+static BROTLI_INLINE HashComposite* FN(Self)(HasherHandle handle) {\n+  return (HashComposite*)&(GetHasherCommon(handle)[1]);\n+}\n+\n+static void FN(Initialize)(\n+    HasherHandle handle, const BrotliEncoderParams* params) {\n+  HashComposite* self = FN(Self)(handle);\n+  self->ha = 0;\n+  self->hb = 0;\n+  self->params = params;\n+  /* TODO: Initialize of the hashers is defered to Prepare (and params\n+     remembered here) because we don't get the one_shot and input_size params\n+     here that are needed to know the memory size of them. Instead provide\n+     those params to all hashers FN(Initialize) */\n+}\n+\n+static void FN(Prepare)(HasherHandle handle, BROTLI_BOOL one_shot,\n+    size_t input_size, const uint8_t* data) {\n+  HashComposite* self = FN(Self)(handle);\n+  if (!self->ha) {\n+    HasherCommon* common_a;\n+    HasherCommon* common_b;\n+\n+    self->ha = handle + sizeof(HasherCommon) + sizeof(HashComposite);\n+    common_a = (HasherCommon*)self->ha;\n+    common_a->params = self->params->hasher;\n+    common_a->is_prepared_ = BROTLI_FALSE;\n+    common_a->dict_num_lookups = 0;\n+    common_a->dict_num_matches = 0;\n+    FN_A(Initialize)(self->ha, self->params);\n+\n+    self->hb = self->ha + sizeof(HasherCommon) + FN_A(HashMemAllocInBytes)(\n+        self->params, one_shot, input_size);\n+    common_b = (HasherCommon*)self->hb;\n+    common_b->params = self->params->hasher;\n+    common_b->is_prepared_ = BROTLI_FALSE;\n+    common_b->dict_num_lookups = 0;\n+    common_b->dict_num_matches = 0;\n+    FN_B(Initialize)(self->hb, self->params);\n+  }\n+  FN_A(Prepare)(self->ha, one_shot, input_size, data);\n+  FN_B(Prepare)(self->hb, one_shot, input_size, data);\n+}\n+\n+static BROTLI_INLINE size_t FN(HashMemAllocInBytes)(\n+    const BrotliEncoderParams* params, BROTLI_BOOL one_shot,\n+    size_t input_size) {\n+  return sizeof(HashComposite) + 2 * sizeof(HasherCommon) +\n+      FN_A(HashMemAllocInBytes)(params, one_shot, input_size) +\n+      FN_B(HashMemAllocInBytes)(params, one_shot, input_size);\n+}\n+\n+static BROTLI_INLINE void FN(Store)(HasherHandle BROTLI_RESTRICT handle,\n+    const uint8_t* BROTLI_RESTRICT data, const size_t mask, const size_t ix) {\n+  HashComposite* self = FN(Self)(handle);\n+  FN_A(Store)(self->ha, data, mask, ix);\n+  FN_B(Store)(self->hb, data, mask, ix);\n+}\n+\n+static BROTLI_INLINE void FN(StoreRange)(HasherHandle handle,\n+    const uint8_t* data, const size_t mask, const size_t ix_start,\n+    const size_t ix_end) {\n+  HashComposite* self = FN(Self)(handle);\n+  FN_A(StoreRange)(self->ha, data, mask, ix_start, ix_end);\n+  FN_B(StoreRange)(self->hb, data, mask, ix_start, ix_end);\n+}\n+\n+static BROTLI_INLINE void FN(StitchToPreviousBlock)(HasherHandle handle,\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ring_buffer_mask) {\n+  HashComposite* self = FN(Self)(handle);\n+  FN_A(StitchToPreviousBlock)(self->ha, num_bytes, position, ringbuffer,\n+      ring_buffer_mask);\n+  FN_B(StitchToPreviousBlock)(self->hb, num_bytes, position, ringbuffer,\n+      ring_buffer_mask);\n+}\n+\n+static BROTLI_INLINE void FN(PrepareDistanceCache)(\n+    HasherHandle handle, int* BROTLI_RESTRICT distance_cache) {\n+  HashComposite* self = FN(Self)(handle);\n+  FN_A(PrepareDistanceCache)(self->ha, distance_cache);\n+  FN_B(PrepareDistanceCache)(self->hb, distance_cache);\n+}\n+\n+static BROTLI_INLINE void FN(FindLongestMatch)(HasherHandle handle,\n+    const BrotliEncoderDictionary* dictionary,\n+    const uint8_t* BROTLI_RESTRICT data, const size_t ring_buffer_mask,\n+    const int* BROTLI_RESTRICT distance_cache, const size_t cur_ix,\n+    const size_t max_length, const size_t max_backward,\n+    const size_t gap, const size_t max_distance,\n+    HasherSearchResult* BROTLI_RESTRICT out) {\n+  HashComposite* self = FN(Self)(handle);\n+  FN_A(FindLongestMatch)(self->ha, dictionary, data, ring_buffer_mask,\n+      distance_cache, cur_ix, max_length, max_backward, gap,\n+      max_distance, out);\n+  FN_B(FindLongestMatch)(self->hb, dictionary, data, ring_buffer_mask,\n+      distance_cache, cur_ix, max_length, max_backward, gap,\n+      max_distance, out);\n+}\n+\n+#undef HashComposite"
        },
        {
            "sha": "41cb3ff03ac5fc4bc7d420b24aa68246d1bcb0ed",
            "filename": "deps/brotli/c/enc/hash_forgetful_chain_inc.h",
            "status": "added",
            "additions": 254,
            "deletions": 0,
            "changes": 254,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_forgetful_chain_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_forgetful_chain_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhash_forgetful_chain_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,254 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2016 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN, BUCKET_BITS, NUM_BANKS, BANK_BITS,\n+                        NUM_LAST_DISTANCES_TO_CHECK */\n+\n+/* A (forgetful) hash table to the data seen by the compressor, to\n+   help create backward references to previous data.\n+\n+   Hashes are stored in chains which are bucketed to groups. Group of chains\n+   share a storage \"bank\". When more than \"bank size\" chain nodes are added,\n+   oldest nodes are replaced; this way several chains may share a tail. */\n+\n+#define HashForgetfulChain HASHER()\n+\n+#define BANK_SIZE (1 << BANK_BITS)\n+\n+/* Number of hash buckets. */\n+#define BUCKET_SIZE (1 << BUCKET_BITS)\n+\n+#define CAPPED_CHAINS 0\n+\n+static BROTLI_INLINE size_t FN(HashTypeLength)(void) { return 4; }\n+static BROTLI_INLINE size_t FN(StoreLookahead)(void) { return 4; }\n+\n+/* HashBytes is the function that chooses the bucket to place the address in.*/\n+static BROTLI_INLINE size_t FN(HashBytes)(const uint8_t* data) {\n+  const uint32_t h = BROTLI_UNALIGNED_LOAD32LE(data) * kHashMul32;\n+  /* The higher bits contain more mixture from the multiplication,\n+     so we take our results from there. */\n+  return h >> (32 - BUCKET_BITS);\n+}\n+\n+typedef struct FN(Slot) {\n+  uint16_t delta;\n+  uint16_t next;\n+} FN(Slot);\n+\n+typedef struct FN(Bank) {\n+  FN(Slot) slots[BANK_SIZE];\n+} FN(Bank);\n+\n+typedef struct HashForgetfulChain {\n+  uint32_t addr[BUCKET_SIZE];\n+  uint16_t head[BUCKET_SIZE];\n+  /* Truncated hash used for quick rejection of \"distance cache\" candidates. */\n+  uint8_t tiny_hash[65536];\n+  FN(Bank) banks[NUM_BANKS];\n+  uint16_t free_slot_idx[NUM_BANKS];\n+  size_t max_hops;\n+} HashForgetfulChain;\n+\n+static BROTLI_INLINE HashForgetfulChain* FN(Self)(HasherHandle handle) {\n+  return (HashForgetfulChain*)&(GetHasherCommon(handle)[1]);\n+}\n+\n+static void FN(Initialize)(\n+    HasherHandle handle, const BrotliEncoderParams* params) {\n+  FN(Self)(handle)->max_hops =\n+      (params->quality > 6 ? 7u : 8u) << (params->quality - 4);\n+}\n+\n+static void FN(Prepare)(HasherHandle handle, BROTLI_BOOL one_shot,\n+    size_t input_size, const uint8_t* data) {\n+  HashForgetfulChain* self = FN(Self)(handle);\n+  /* Partial preparation is 100 times slower (per socket). */\n+  size_t partial_prepare_threshold = BUCKET_SIZE >> 6;\n+  if (one_shot && input_size <= partial_prepare_threshold) {\n+    size_t i;\n+    for (i = 0; i < input_size; ++i) {\n+      size_t bucket = FN(HashBytes)(&data[i]);\n+      /* See InitEmpty comment. */\n+      self->addr[bucket] = 0xCCCCCCCC;\n+      self->head[bucket] = 0xCCCC;\n+    }\n+  } else {\n+    /* Fill |addr| array with 0xCCCCCCCC value. Because of wrapping, position\n+       processed by hasher never reaches 3GB + 64M; this makes all new chains\n+       to be terminated after the first node. */\n+    memset(self->addr, 0xCC, sizeof(self->addr));\n+    memset(self->head, 0, sizeof(self->head));\n+  }\n+  memset(self->tiny_hash, 0, sizeof(self->tiny_hash));\n+  memset(self->free_slot_idx, 0, sizeof(self->free_slot_idx));\n+}\n+\n+static BROTLI_INLINE size_t FN(HashMemAllocInBytes)(\n+    const BrotliEncoderParams* params, BROTLI_BOOL one_shot,\n+    size_t input_size) {\n+  BROTLI_UNUSED(params);\n+  BROTLI_UNUSED(one_shot);\n+  BROTLI_UNUSED(input_size);\n+  return sizeof(HashForgetfulChain);\n+}\n+\n+/* Look at 4 bytes at &data[ix & mask]. Compute a hash from these, and prepend\n+   node to corresponding chain; also update tiny_hash for current position. */\n+static BROTLI_INLINE void FN(Store)(HasherHandle BROTLI_RESTRICT handle,\n+    const uint8_t* BROTLI_RESTRICT data, const size_t mask, const size_t ix) {\n+  HashForgetfulChain* self = FN(Self)(handle);\n+  const size_t key = FN(HashBytes)(&data[ix & mask]);\n+  const size_t bank = key & (NUM_BANKS - 1);\n+  const size_t idx = self->free_slot_idx[bank]++ & (BANK_SIZE - 1);\n+  size_t delta = ix - self->addr[key];\n+  self->tiny_hash[(uint16_t)ix] = (uint8_t)key;\n+  if (delta > 0xFFFF) delta = CAPPED_CHAINS ? 0 : 0xFFFF;\n+  self->banks[bank].slots[idx].delta = (uint16_t)delta;\n+  self->banks[bank].slots[idx].next = self->head[key];\n+  self->addr[key] = (uint32_t)ix;\n+  self->head[key] = (uint16_t)idx;\n+}\n+\n+static BROTLI_INLINE void FN(StoreRange)(HasherHandle handle,\n+    const uint8_t* data, const size_t mask, const size_t ix_start,\n+    const size_t ix_end) {\n+  size_t i;\n+  for (i = ix_start; i < ix_end; ++i) {\n+    FN(Store)(handle, data, mask, i);\n+  }\n+}\n+\n+static BROTLI_INLINE void FN(StitchToPreviousBlock)(HasherHandle handle,\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ring_buffer_mask) {\n+  if (num_bytes >= FN(HashTypeLength)() - 1 && position >= 3) {\n+    /* Prepare the hashes for three last bytes of the last write.\n+       These could not be calculated before, since they require knowledge\n+       of both the previous and the current block. */\n+    FN(Store)(handle, ringbuffer, ring_buffer_mask, position - 3);\n+    FN(Store)(handle, ringbuffer, ring_buffer_mask, position - 2);\n+    FN(Store)(handle, ringbuffer, ring_buffer_mask, position - 1);\n+  }\n+}\n+\n+static BROTLI_INLINE void FN(PrepareDistanceCache)(\n+    HasherHandle handle, int* BROTLI_RESTRICT distance_cache) {\n+  BROTLI_UNUSED(handle);\n+  PrepareDistanceCache(distance_cache, NUM_LAST_DISTANCES_TO_CHECK);\n+}\n+\n+/* Find a longest backward match of &data[cur_ix] up to the length of\n+   max_length and stores the position cur_ix in the hash table.\n+\n+   REQUIRES: FN(PrepareDistanceCache) must be invoked for current distance cache\n+             values; if this method is invoked repeatedly with the same distance\n+             cache values, it is enough to invoke FN(PrepareDistanceCache) once.\n+\n+   Does not look for matches longer than max_length.\n+   Does not look for matches further away than max_backward.\n+   Writes the best match into |out|.\n+   |out|->score is updated only if a better match is found. */\n+static BROTLI_INLINE void FN(FindLongestMatch)(HasherHandle handle,\n+    const BrotliEncoderDictionary* dictionary,\n+    const uint8_t* BROTLI_RESTRICT data, const size_t ring_buffer_mask,\n+    const int* BROTLI_RESTRICT distance_cache,\n+    const size_t cur_ix, const size_t max_length, const size_t max_backward,\n+    const size_t gap, const size_t max_distance,\n+    HasherSearchResult* BROTLI_RESTRICT out) {\n+  HashForgetfulChain* self = FN(Self)(handle);\n+  const size_t cur_ix_masked = cur_ix & ring_buffer_mask;\n+  /* Don't accept a short copy from far away. */\n+  score_t min_score = out->score;\n+  score_t best_score = out->score;\n+  size_t best_len = out->len;\n+  size_t i;\n+  const size_t key = FN(HashBytes)(&data[cur_ix_masked]);\n+  const uint8_t tiny_hash = (uint8_t)(key);\n+  out->len = 0;\n+  out->len_code_delta = 0;\n+  /* Try last distance first. */\n+  for (i = 0; i < NUM_LAST_DISTANCES_TO_CHECK; ++i) {\n+    const size_t backward = (size_t)distance_cache[i];\n+    size_t prev_ix = (cur_ix - backward);\n+    /* For distance code 0 we want to consider 2-byte matches. */\n+    if (i > 0 && self->tiny_hash[(uint16_t)prev_ix] != tiny_hash) continue;\n+    if (prev_ix >= cur_ix || backward > max_backward) {\n+      continue;\n+    }\n+    prev_ix &= ring_buffer_mask;\n+    {\n+      const size_t len = FindMatchLengthWithLimit(&data[prev_ix],\n+                                                  &data[cur_ix_masked],\n+                                                  max_length);\n+      if (len >= 2) {\n+        score_t score = BackwardReferenceScoreUsingLastDistance(len);\n+        if (best_score < score) {\n+          if (i != 0) score -= BackwardReferencePenaltyUsingLastDistance(i);\n+          if (best_score < score) {\n+            best_score = score;\n+            best_len = len;\n+            out->len = best_len;\n+            out->distance = backward;\n+            out->score = best_score;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  {\n+    const size_t bank = key & (NUM_BANKS - 1);\n+    size_t backward = 0;\n+    size_t hops = self->max_hops;\n+    size_t delta = cur_ix - self->addr[key];\n+    size_t slot = self->head[key];\n+    while (hops--) {\n+      size_t prev_ix;\n+      size_t last = slot;\n+      backward += delta;\n+      if (backward > max_backward || (CAPPED_CHAINS && !delta)) break;\n+      prev_ix = (cur_ix - backward) & ring_buffer_mask;\n+      slot = self->banks[bank].slots[last].next;\n+      delta = self->banks[bank].slots[last].delta;\n+      if (cur_ix_masked + best_len > ring_buffer_mask ||\n+          prev_ix + best_len > ring_buffer_mask ||\n+          data[cur_ix_masked + best_len] != data[prev_ix + best_len]) {\n+        continue;\n+      }\n+      {\n+        const size_t len = FindMatchLengthWithLimit(&data[prev_ix],\n+                                                    &data[cur_ix_masked],\n+                                                    max_length);\n+        if (len >= 4) {\n+          /* Comparing for >= 3 does not change the semantics, but just saves\n+             for a few unnecessary binary logarithms in backward reference\n+             score, since we are not interested in such short matches. */\n+          score_t score = BackwardReferenceScore(len, backward);\n+          if (best_score < score) {\n+            best_score = score;\n+            best_len = len;\n+            out->len = best_len;\n+            out->distance = backward;\n+            out->score = best_score;\n+          }\n+        }\n+      }\n+    }\n+    FN(Store)(handle, data, ring_buffer_mask, cur_ix);\n+  }\n+  if (out->score == min_score) {\n+    SearchInStaticDictionary(dictionary,\n+        handle, &data[cur_ix_masked], max_length, max_backward + gap,\n+        max_distance, out, BROTLI_FALSE);\n+  }\n+}\n+\n+#undef BANK_SIZE\n+#undef BUCKET_SIZE\n+#undef CAPPED_CHAINS\n+\n+#undef HashForgetfulChain"
        },
        {
            "sha": "cb953a644fcae7704e78966089f2a9b98a8bb67c",
            "filename": "deps/brotli/c/enc/hash_longest_match64_inc.h",
            "status": "added",
            "additions": 267,
            "deletions": 0,
            "changes": 267,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_longest_match64_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_longest_match64_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhash_longest_match64_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,267 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2010 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN */\n+\n+/* A (forgetful) hash table to the data seen by the compressor, to\n+   help create backward references to previous data.\n+\n+   This is a hash map of fixed size (bucket_size_) to a ring buffer of\n+   fixed size (block_size_). The ring buffer contains the last block_size_\n+   index positions of the given hash key in the compressed data. */\n+\n+#define HashLongestMatch HASHER()\n+\n+static BROTLI_INLINE size_t FN(HashTypeLength)(void) { return 8; }\n+static BROTLI_INLINE size_t FN(StoreLookahead)(void) { return 8; }\n+\n+/* HashBytes is the function that chooses the bucket to place the address in. */\n+static BROTLI_INLINE uint32_t FN(HashBytes)(const uint8_t* data,\n+                                            const uint64_t mask,\n+                                            const int shift) {\n+  const uint64_t h = (BROTLI_UNALIGNED_LOAD64LE(data) & mask) * kHashMul64Long;\n+  /* The higher bits contain more mixture from the multiplication,\n+     so we take our results from there. */\n+  return (uint32_t)(h >> shift);\n+}\n+\n+typedef struct HashLongestMatch {\n+  /* Number of hash buckets. */\n+  size_t bucket_size_;\n+  /* Only block_size_ newest backward references are kept,\n+     and the older are forgotten. */\n+  size_t block_size_;\n+  /* Left-shift for computing hash bucket index from hash value. */\n+  int hash_shift_;\n+  /* Mask for selecting the next 4-8 bytes of input */\n+  uint64_t hash_mask_;\n+  /* Mask for accessing entries in a block (in a ring-buffer manner). */\n+  uint32_t block_mask_;\n+\n+  /* --- Dynamic size members --- */\n+\n+  /* Number of entries in a particular bucket. */\n+  /* uint16_t num[bucket_size]; */\n+\n+  /* Buckets containing block_size_ of backward references. */\n+  /* uint32_t* buckets[bucket_size * block_size]; */\n+} HashLongestMatch;\n+\n+static BROTLI_INLINE HashLongestMatch* FN(Self)(HasherHandle handle) {\n+  return (HashLongestMatch*)&(GetHasherCommon(handle)[1]);\n+}\n+\n+static BROTLI_INLINE uint16_t* FN(Num)(HashLongestMatch* self) {\n+  return (uint16_t*)(&self[1]);\n+}\n+\n+static BROTLI_INLINE uint32_t* FN(Buckets)(HashLongestMatch* self) {\n+  return (uint32_t*)(&FN(Num)(self)[self->bucket_size_]);\n+}\n+\n+static void FN(Initialize)(\n+    HasherHandle handle, const BrotliEncoderParams* params) {\n+  HasherCommon* common = GetHasherCommon(handle);\n+  HashLongestMatch* self = FN(Self)(handle);\n+  BROTLI_UNUSED(params);\n+  self->hash_shift_ = 64 - common->params.bucket_bits;\n+  self->hash_mask_ = (~((uint64_t)0U)) >> (64 - 8 * common->params.hash_len);\n+  self->bucket_size_ = (size_t)1 << common->params.bucket_bits;\n+  self->block_size_ = (size_t)1 << common->params.block_bits;\n+  self->block_mask_ = (uint32_t)(self->block_size_ - 1);\n+}\n+\n+static void FN(Prepare)(HasherHandle handle, BROTLI_BOOL one_shot,\n+    size_t input_size, const uint8_t* data) {\n+  HashLongestMatch* self = FN(Self)(handle);\n+  uint16_t* num = FN(Num)(self);\n+  /* Partial preparation is 100 times slower (per socket). */\n+  size_t partial_prepare_threshold = self->bucket_size_ >> 6;\n+  if (one_shot && input_size <= partial_prepare_threshold) {\n+    size_t i;\n+    for (i = 0; i < input_size; ++i) {\n+      const uint32_t key = FN(HashBytes)(&data[i], self->hash_mask_,\n+                                         self->hash_shift_);\n+      num[key] = 0;\n+    }\n+  } else {\n+    memset(num, 0, self->bucket_size_ * sizeof(num[0]));\n+  }\n+}\n+\n+static BROTLI_INLINE size_t FN(HashMemAllocInBytes)(\n+    const BrotliEncoderParams* params, BROTLI_BOOL one_shot,\n+    size_t input_size) {\n+  size_t bucket_size = (size_t)1 << params->hasher.bucket_bits;\n+  size_t block_size = (size_t)1 << params->hasher.block_bits;\n+  BROTLI_UNUSED(one_shot);\n+  BROTLI_UNUSED(input_size);\n+  return sizeof(HashLongestMatch) + bucket_size * (2 + 4 * block_size);\n+}\n+\n+/* Look at 4 bytes at &data[ix & mask].\n+   Compute a hash from these, and store the value of ix at that position. */\n+static BROTLI_INLINE void FN(Store)(HasherHandle handle, const uint8_t* data,\n+    const size_t mask, const size_t ix) {\n+  HashLongestMatch* self = FN(Self)(handle);\n+  uint16_t* num = FN(Num)(self);\n+  const uint32_t key = FN(HashBytes)(&data[ix & mask], self->hash_mask_,\n+                                     self->hash_shift_);\n+  const size_t minor_ix = num[key] & self->block_mask_;\n+  const size_t offset =\n+      minor_ix + (key << GetHasherCommon(handle)->params.block_bits);\n+  FN(Buckets)(self)[offset] = (uint32_t)ix;\n+  ++num[key];\n+}\n+\n+static BROTLI_INLINE void FN(StoreRange)(HasherHandle handle,\n+    const uint8_t* data, const size_t mask, const size_t ix_start,\n+    const size_t ix_end) {\n+  size_t i;\n+  for (i = ix_start; i < ix_end; ++i) {\n+    FN(Store)(handle, data, mask, i);\n+  }\n+}\n+\n+static BROTLI_INLINE void FN(StitchToPreviousBlock)(HasherHandle handle,\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ringbuffer_mask) {\n+  if (num_bytes >= FN(HashTypeLength)() - 1 && position >= 3) {\n+    /* Prepare the hashes for three last bytes of the last write.\n+       These could not be calculated before, since they require knowledge\n+       of both the previous and the current block. */\n+    FN(Store)(handle, ringbuffer, ringbuffer_mask, position - 3);\n+    FN(Store)(handle, ringbuffer, ringbuffer_mask, position - 2);\n+    FN(Store)(handle, ringbuffer, ringbuffer_mask, position - 1);\n+  }\n+}\n+\n+static BROTLI_INLINE void FN(PrepareDistanceCache)(\n+    HasherHandle handle, int* BROTLI_RESTRICT distance_cache) {\n+  PrepareDistanceCache(distance_cache,\n+      GetHasherCommon(handle)->params.num_last_distances_to_check);\n+}\n+\n+/* Find a longest backward match of &data[cur_ix] up to the length of\n+   max_length and stores the position cur_ix in the hash table.\n+\n+   REQUIRES: FN(PrepareDistanceCache) must be invoked for current distance cache\n+             values; if this method is invoked repeatedly with the same distance\n+             cache values, it is enough to invoke FN(PrepareDistanceCache) once.\n+\n+   Does not look for matches longer than max_length.\n+   Does not look for matches further away than max_backward.\n+   Writes the best match into |out|.\n+   |out|->score is updated only if a better match is found. */\n+static BROTLI_INLINE void FN(FindLongestMatch)(HasherHandle handle,\n+    const BrotliEncoderDictionary* dictionary,\n+    const uint8_t* BROTLI_RESTRICT data, const size_t ring_buffer_mask,\n+    const int* BROTLI_RESTRICT distance_cache, const size_t cur_ix,\n+    const size_t max_length, const size_t max_backward,\n+    const size_t gap, const size_t max_distance,\n+    HasherSearchResult* BROTLI_RESTRICT out) {\n+  HasherCommon* common = GetHasherCommon(handle);\n+  HashLongestMatch* self = FN(Self)(handle);\n+  uint16_t* num = FN(Num)(self);\n+  uint32_t* buckets = FN(Buckets)(self);\n+  const size_t cur_ix_masked = cur_ix & ring_buffer_mask;\n+  /* Don't accept a short copy from far away. */\n+  score_t min_score = out->score;\n+  score_t best_score = out->score;\n+  size_t best_len = out->len;\n+  size_t i;\n+  out->len = 0;\n+  out->len_code_delta = 0;\n+  /* Try last distance first. */\n+  for (i = 0; i < (size_t)common->params.num_last_distances_to_check; ++i) {\n+    const size_t backward = (size_t)distance_cache[i];\n+    size_t prev_ix = (size_t)(cur_ix - backward);\n+    if (prev_ix >= cur_ix) {\n+      continue;\n+    }\n+    if (BROTLI_PREDICT_FALSE(backward > max_backward)) {\n+      continue;\n+    }\n+    prev_ix &= ring_buffer_mask;\n+\n+    if (cur_ix_masked + best_len > ring_buffer_mask ||\n+        prev_ix + best_len > ring_buffer_mask ||\n+        data[cur_ix_masked + best_len] != data[prev_ix + best_len]) {\n+      continue;\n+    }\n+    {\n+      const size_t len = FindMatchLengthWithLimit(&data[prev_ix],\n+                                                  &data[cur_ix_masked],\n+                                                  max_length);\n+      if (len >= 3 || (len == 2 && i < 2)) {\n+        /* Comparing for >= 2 does not change the semantics, but just saves for\n+           a few unnecessary binary logarithms in backward reference score,\n+           since we are not interested in such short matches. */\n+        score_t score = BackwardReferenceScoreUsingLastDistance(len);\n+        if (best_score < score) {\n+          if (i != 0) score -= BackwardReferencePenaltyUsingLastDistance(i);\n+          if (best_score < score) {\n+            best_score = score;\n+            best_len = len;\n+            out->len = best_len;\n+            out->distance = backward;\n+            out->score = best_score;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  {\n+    const uint32_t key = FN(HashBytes)(\n+        &data[cur_ix_masked], self->hash_mask_, self->hash_shift_);\n+    uint32_t* BROTLI_RESTRICT bucket =\n+        &buckets[key << common->params.block_bits];\n+    const size_t down =\n+        (num[key] > self->block_size_) ?\n+        (num[key] - self->block_size_) : 0u;\n+    for (i = num[key]; i > down;) {\n+      size_t prev_ix = bucket[--i & self->block_mask_];\n+      const size_t backward = cur_ix - prev_ix;\n+      if (BROTLI_PREDICT_FALSE(backward > max_backward)) {\n+        break;\n+      }\n+      prev_ix &= ring_buffer_mask;\n+      if (cur_ix_masked + best_len > ring_buffer_mask ||\n+          prev_ix + best_len > ring_buffer_mask ||\n+          data[cur_ix_masked + best_len] != data[prev_ix + best_len]) {\n+        continue;\n+      }\n+      {\n+        const size_t len = FindMatchLengthWithLimit(&data[prev_ix],\n+                                                    &data[cur_ix_masked],\n+                                                    max_length);\n+        if (len >= 4) {\n+          /* Comparing for >= 3 does not change the semantics, but just saves\n+             for a few unnecessary binary logarithms in backward reference\n+             score, since we are not interested in such short matches. */\n+          score_t score = BackwardReferenceScore(len, backward);\n+          if (best_score < score) {\n+            best_score = score;\n+            best_len = len;\n+            out->len = best_len;\n+            out->distance = backward;\n+            out->score = best_score;\n+          }\n+        }\n+      }\n+    }\n+    bucket[num[key] & self->block_mask_] = (uint32_t)cur_ix;\n+    ++num[key];\n+  }\n+  if (min_score == out->score) {\n+    SearchInStaticDictionary(dictionary,\n+        handle, &data[cur_ix_masked], max_length, max_backward + gap,\n+        max_distance, out, BROTLI_FALSE);\n+  }\n+}\n+\n+#undef HashLongestMatch"
        },
        {
            "sha": "457f5a9ed2e2217eb416f6037068ecdfc7b10b77",
            "filename": "deps/brotli/c/enc/hash_longest_match_inc.h",
            "status": "added",
            "additions": 259,
            "deletions": 0,
            "changes": 259,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_longest_match_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_longest_match_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhash_longest_match_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,259 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2010 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN */\n+\n+/* A (forgetful) hash table to the data seen by the compressor, to\n+   help create backward references to previous data.\n+\n+   This is a hash map of fixed size (bucket_size_) to a ring buffer of\n+   fixed size (block_size_). The ring buffer contains the last block_size_\n+   index positions of the given hash key in the compressed data. */\n+\n+#define HashLongestMatch HASHER()\n+\n+static BROTLI_INLINE size_t FN(HashTypeLength)(void) { return 4; }\n+static BROTLI_INLINE size_t FN(StoreLookahead)(void) { return 4; }\n+\n+/* HashBytes is the function that chooses the bucket to place the address in. */\n+static uint32_t FN(HashBytes)(const uint8_t* data, const int shift) {\n+  uint32_t h = BROTLI_UNALIGNED_LOAD32LE(data) * kHashMul32;\n+  /* The higher bits contain more mixture from the multiplication,\n+     so we take our results from there. */\n+  return (uint32_t)(h >> shift);\n+}\n+\n+typedef struct HashLongestMatch {\n+  /* Number of hash buckets. */\n+  size_t bucket_size_;\n+  /* Only block_size_ newest backward references are kept,\n+     and the older are forgotten. */\n+  size_t block_size_;\n+  /* Left-shift for computing hash bucket index from hash value. */\n+  int hash_shift_;\n+  /* Mask for accessing entries in a block (in a ring-buffer manner). */\n+  uint32_t block_mask_;\n+\n+  /* --- Dynamic size members --- */\n+\n+  /* Number of entries in a particular bucket. */\n+  /* uint16_t num[bucket_size]; */\n+\n+  /* Buckets containing block_size_ of backward references. */\n+  /* uint32_t* buckets[bucket_size * block_size]; */\n+} HashLongestMatch;\n+\n+static BROTLI_INLINE HashLongestMatch* FN(Self)(HasherHandle handle) {\n+  return (HashLongestMatch*)&(GetHasherCommon(handle)[1]);\n+}\n+\n+static BROTLI_INLINE uint16_t* FN(Num)(HashLongestMatch* self) {\n+  return (uint16_t*)(&self[1]);\n+}\n+\n+static BROTLI_INLINE uint32_t* FN(Buckets)(HashLongestMatch* self) {\n+  return (uint32_t*)(&FN(Num)(self)[self->bucket_size_]);\n+}\n+\n+static void FN(Initialize)(\n+    HasherHandle handle, const BrotliEncoderParams* params) {\n+  HasherCommon* common = GetHasherCommon(handle);\n+  HashLongestMatch* self = FN(Self)(handle);\n+  BROTLI_UNUSED(params);\n+  self->hash_shift_ = 32 - common->params.bucket_bits;\n+  self->bucket_size_ = (size_t)1 << common->params.bucket_bits;\n+  self->block_size_ = (size_t)1 << common->params.block_bits;\n+  self->block_mask_ = (uint32_t)(self->block_size_ - 1);\n+}\n+\n+static void FN(Prepare)(HasherHandle handle, BROTLI_BOOL one_shot,\n+    size_t input_size, const uint8_t* data) {\n+  HashLongestMatch* self = FN(Self)(handle);\n+  uint16_t* num = FN(Num)(self);\n+  /* Partial preparation is 100 times slower (per socket). */\n+  size_t partial_prepare_threshold = self->bucket_size_ >> 6;\n+  if (one_shot && input_size <= partial_prepare_threshold) {\n+    size_t i;\n+    for (i = 0; i < input_size; ++i) {\n+      const uint32_t key = FN(HashBytes)(&data[i], self->hash_shift_);\n+      num[key] = 0;\n+    }\n+  } else {\n+    memset(num, 0, self->bucket_size_ * sizeof(num[0]));\n+  }\n+}\n+\n+static BROTLI_INLINE size_t FN(HashMemAllocInBytes)(\n+    const BrotliEncoderParams* params, BROTLI_BOOL one_shot,\n+    size_t input_size) {\n+  size_t bucket_size = (size_t)1 << params->hasher.bucket_bits;\n+  size_t block_size = (size_t)1 << params->hasher.block_bits;\n+  BROTLI_UNUSED(one_shot);\n+  BROTLI_UNUSED(input_size);\n+  return sizeof(HashLongestMatch) + bucket_size * (2 + 4 * block_size);\n+}\n+\n+/* Look at 4 bytes at &data[ix & mask].\n+   Compute a hash from these, and store the value of ix at that position. */\n+static BROTLI_INLINE void FN(Store)(HasherHandle handle, const uint8_t* data,\n+    const size_t mask, const size_t ix) {\n+  HashLongestMatch* self = FN(Self)(handle);\n+  uint16_t* num = FN(Num)(self);\n+  const uint32_t key = FN(HashBytes)(&data[ix & mask], self->hash_shift_);\n+  const size_t minor_ix = num[key] & self->block_mask_;\n+  const size_t offset =\n+      minor_ix + (key << GetHasherCommon(handle)->params.block_bits);\n+  FN(Buckets)(self)[offset] = (uint32_t)ix;\n+  ++num[key];\n+}\n+\n+static BROTLI_INLINE void FN(StoreRange)(HasherHandle handle,\n+    const uint8_t* data, const size_t mask, const size_t ix_start,\n+    const size_t ix_end) {\n+  size_t i;\n+  for (i = ix_start; i < ix_end; ++i) {\n+    FN(Store)(handle, data, mask, i);\n+  }\n+}\n+\n+static BROTLI_INLINE void FN(StitchToPreviousBlock)(HasherHandle handle,\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ringbuffer_mask) {\n+  if (num_bytes >= FN(HashTypeLength)() - 1 && position >= 3) {\n+    /* Prepare the hashes for three last bytes of the last write.\n+       These could not be calculated before, since they require knowledge\n+       of both the previous and the current block. */\n+    FN(Store)(handle, ringbuffer, ringbuffer_mask, position - 3);\n+    FN(Store)(handle, ringbuffer, ringbuffer_mask, position - 2);\n+    FN(Store)(handle, ringbuffer, ringbuffer_mask, position - 1);\n+  }\n+}\n+\n+static BROTLI_INLINE void FN(PrepareDistanceCache)(\n+    HasherHandle handle, int* BROTLI_RESTRICT distance_cache) {\n+  PrepareDistanceCache(distance_cache,\n+      GetHasherCommon(handle)->params.num_last_distances_to_check);\n+}\n+\n+/* Find a longest backward match of &data[cur_ix] up to the length of\n+   max_length and stores the position cur_ix in the hash table.\n+\n+   REQUIRES: FN(PrepareDistanceCache) must be invoked for current distance cache\n+             values; if this method is invoked repeatedly with the same distance\n+             cache values, it is enough to invoke FN(PrepareDistanceCache) once.\n+\n+   Does not look for matches longer than max_length.\n+   Does not look for matches further away than max_backward.\n+   Writes the best match into |out|.\n+   |out|->score is updated only if a better match is found. */\n+static BROTLI_INLINE void FN(FindLongestMatch)(HasherHandle handle,\n+    const BrotliEncoderDictionary* dictionary,\n+    const uint8_t* BROTLI_RESTRICT data, const size_t ring_buffer_mask,\n+    const int* BROTLI_RESTRICT distance_cache, const size_t cur_ix,\n+    const size_t max_length, const size_t max_backward,\n+    const size_t gap, const size_t max_distance,\n+    HasherSearchResult* BROTLI_RESTRICT out) {\n+  HasherCommon* common = GetHasherCommon(handle);\n+  HashLongestMatch* self = FN(Self)(handle);\n+  uint16_t* num = FN(Num)(self);\n+  uint32_t* buckets = FN(Buckets)(self);\n+  const size_t cur_ix_masked = cur_ix & ring_buffer_mask;\n+  /* Don't accept a short copy from far away. */\n+  score_t min_score = out->score;\n+  score_t best_score = out->score;\n+  size_t best_len = out->len;\n+  size_t i;\n+  out->len = 0;\n+  out->len_code_delta = 0;\n+  /* Try last distance first. */\n+  for (i = 0; i < (size_t)common->params.num_last_distances_to_check; ++i) {\n+    const size_t backward = (size_t)distance_cache[i];\n+    size_t prev_ix = (size_t)(cur_ix - backward);\n+    if (prev_ix >= cur_ix) {\n+      continue;\n+    }\n+    if (BROTLI_PREDICT_FALSE(backward > max_backward)) {\n+      continue;\n+    }\n+    prev_ix &= ring_buffer_mask;\n+\n+    if (cur_ix_masked + best_len > ring_buffer_mask ||\n+        prev_ix + best_len > ring_buffer_mask ||\n+        data[cur_ix_masked + best_len] != data[prev_ix + best_len]) {\n+      continue;\n+    }\n+    {\n+      const size_t len = FindMatchLengthWithLimit(&data[prev_ix],\n+                                                  &data[cur_ix_masked],\n+                                                  max_length);\n+      if (len >= 3 || (len == 2 && i < 2)) {\n+        /* Comparing for >= 2 does not change the semantics, but just saves for\n+           a few unnecessary binary logarithms in backward reference score,\n+           since we are not interested in such short matches. */\n+        score_t score = BackwardReferenceScoreUsingLastDistance(len);\n+        if (best_score < score) {\n+          if (i != 0) score -= BackwardReferencePenaltyUsingLastDistance(i);\n+          if (best_score < score) {\n+            best_score = score;\n+            best_len = len;\n+            out->len = best_len;\n+            out->distance = backward;\n+            out->score = best_score;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  {\n+    const uint32_t key =\n+        FN(HashBytes)(&data[cur_ix_masked], self->hash_shift_);\n+    uint32_t* BROTLI_RESTRICT bucket =\n+        &buckets[key << common->params.block_bits];\n+    const size_t down =\n+        (num[key] > self->block_size_) ? (num[key] - self->block_size_) : 0u;\n+    for (i = num[key]; i > down;) {\n+      size_t prev_ix = bucket[--i & self->block_mask_];\n+      const size_t backward = cur_ix - prev_ix;\n+      if (BROTLI_PREDICT_FALSE(backward > max_backward)) {\n+        break;\n+      }\n+      prev_ix &= ring_buffer_mask;\n+      if (cur_ix_masked + best_len > ring_buffer_mask ||\n+          prev_ix + best_len > ring_buffer_mask ||\n+          data[cur_ix_masked + best_len] != data[prev_ix + best_len]) {\n+        continue;\n+      }\n+      {\n+        const size_t len = FindMatchLengthWithLimit(&data[prev_ix],\n+                                                    &data[cur_ix_masked],\n+                                                    max_length);\n+        if (len >= 4) {\n+          /* Comparing for >= 3 does not change the semantics, but just saves\n+             for a few unnecessary binary logarithms in backward reference\n+             score, since we are not interested in such short matches. */\n+          score_t score = BackwardReferenceScore(len, backward);\n+          if (best_score < score) {\n+            best_score = score;\n+            best_len = len;\n+            out->len = best_len;\n+            out->distance = backward;\n+            out->score = best_score;\n+          }\n+        }\n+      }\n+    }\n+    bucket[num[key] & self->block_mask_] = (uint32_t)cur_ix;\n+    ++num[key];\n+  }\n+  if (min_score == out->score) {\n+    SearchInStaticDictionary(dictionary,\n+        handle, &data[cur_ix_masked], max_length, max_backward + gap,\n+        max_distance, out, BROTLI_FALSE);\n+  }\n+}\n+\n+#undef HashLongestMatch"
        },
        {
            "sha": "a7b9639febffdf6c5234f6669a3318755c5f623e",
            "filename": "deps/brotli/c/enc/hash_longest_match_quickly_inc.h",
            "status": "added",
            "additions": 235,
            "deletions": 0,
            "changes": 235,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_longest_match_quickly_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_longest_match_quickly_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhash_longest_match_quickly_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,235 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2010 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN, BUCKET_BITS, BUCKET_SWEEP, HASH_LEN,\n+                        USE_DICTIONARY\n+ */\n+\n+#define HashLongestMatchQuickly HASHER()\n+\n+#define BUCKET_SIZE (1 << BUCKET_BITS)\n+\n+#define HASH_MAP_SIZE (4 << BUCKET_BITS)\n+\n+static BROTLI_INLINE size_t FN(HashTypeLength)(void) { return 8; }\n+static BROTLI_INLINE size_t FN(StoreLookahead)(void) { return 8; }\n+\n+/* HashBytes is the function that chooses the bucket to place\n+   the address in. The HashLongestMatch and HashLongestMatchQuickly\n+   classes have separate, different implementations of hashing. */\n+static uint32_t FN(HashBytes)(const uint8_t* data) {\n+  const uint64_t h = ((BROTLI_UNALIGNED_LOAD64LE(data) << (64 - 8 * HASH_LEN)) *\n+                      kHashMul64);\n+  /* The higher bits contain more mixture from the multiplication,\n+     so we take our results from there. */\n+  return (uint32_t)(h >> (64 - BUCKET_BITS));\n+}\n+\n+/* A (forgetful) hash table to the data seen by the compressor, to\n+   help create backward references to previous data.\n+\n+   This is a hash map of fixed size (BUCKET_SIZE). Starting from the\n+   given index, BUCKET_SWEEP buckets are used to store values of a key. */\n+typedef struct HashLongestMatchQuickly {\n+  uint32_t buckets_[BUCKET_SIZE + BUCKET_SWEEP];\n+} HashLongestMatchQuickly;\n+\n+static BROTLI_INLINE HashLongestMatchQuickly* FN(Self)(HasherHandle handle) {\n+  return (HashLongestMatchQuickly*)&(GetHasherCommon(handle)[1]);\n+}\n+\n+static void FN(Initialize)(\n+    HasherHandle handle, const BrotliEncoderParams* params) {\n+  BROTLI_UNUSED(handle);\n+  BROTLI_UNUSED(params);\n+}\n+\n+static void FN(Prepare)(HasherHandle handle, BROTLI_BOOL one_shot,\n+    size_t input_size, const uint8_t* data) {\n+  HashLongestMatchQuickly* self = FN(Self)(handle);\n+  /* Partial preparation is 100 times slower (per socket). */\n+  size_t partial_prepare_threshold = HASH_MAP_SIZE >> 7;\n+  if (one_shot && input_size <= partial_prepare_threshold) {\n+    size_t i;\n+    for (i = 0; i < input_size; ++i) {\n+      const uint32_t key = FN(HashBytes)(&data[i]);\n+      memset(&self->buckets_[key], 0, BUCKET_SWEEP * sizeof(self->buckets_[0]));\n+    }\n+  } else {\n+    /* It is not strictly necessary to fill this buffer here, but\n+       not filling will make the results of the compression stochastic\n+       (but correct). This is because random data would cause the\n+       system to find accidentally good backward references here and there. */\n+    memset(&self->buckets_[0], 0, sizeof(self->buckets_));\n+  }\n+}\n+\n+static BROTLI_INLINE size_t FN(HashMemAllocInBytes)(\n+    const BrotliEncoderParams* params, BROTLI_BOOL one_shot,\n+    size_t input_size) {\n+  BROTLI_UNUSED(params);\n+  BROTLI_UNUSED(one_shot);\n+  BROTLI_UNUSED(input_size);\n+  return sizeof(HashLongestMatchQuickly);\n+}\n+\n+/* Look at 5 bytes at &data[ix & mask].\n+   Compute a hash from these, and store the value somewhere within\n+   [ix .. ix+3]. */\n+static BROTLI_INLINE void FN(Store)(HasherHandle handle,\n+    const uint8_t* data, const size_t mask, const size_t ix) {\n+  const uint32_t key = FN(HashBytes)(&data[ix & mask]);\n+  /* Wiggle the value with the bucket sweep range. */\n+  const uint32_t off = (ix >> 3) % BUCKET_SWEEP;\n+  FN(Self)(handle)->buckets_[key + off] = (uint32_t)ix;\n+}\n+\n+static BROTLI_INLINE void FN(StoreRange)(HasherHandle handle,\n+    const uint8_t* data, const size_t mask, const size_t ix_start,\n+    const size_t ix_end) {\n+  size_t i;\n+  for (i = ix_start; i < ix_end; ++i) {\n+    FN(Store)(handle, data, mask, i);\n+  }\n+}\n+\n+static BROTLI_INLINE void FN(StitchToPreviousBlock)(\n+    HasherHandle handle, size_t num_bytes, size_t position,\n+    const uint8_t* ringbuffer, size_t ringbuffer_mask) {\n+  if (num_bytes >= FN(HashTypeLength)() - 1 && position >= 3) {\n+    /* Prepare the hashes for three last bytes of the last write.\n+       These could not be calculated before, since they require knowledge\n+       of both the previous and the current block. */\n+    FN(Store)(handle, ringbuffer, ringbuffer_mask, position - 3);\n+    FN(Store)(handle, ringbuffer, ringbuffer_mask, position - 2);\n+    FN(Store)(handle, ringbuffer, ringbuffer_mask, position - 1);\n+  }\n+}\n+\n+static BROTLI_INLINE void FN(PrepareDistanceCache)(\n+    HasherHandle handle, int* BROTLI_RESTRICT distance_cache) {\n+  BROTLI_UNUSED(handle);\n+  BROTLI_UNUSED(distance_cache);\n+}\n+\n+/* Find a longest backward match of &data[cur_ix & ring_buffer_mask]\n+   up to the length of max_length and stores the position cur_ix in the\n+   hash table.\n+\n+   Does not look for matches longer than max_length.\n+   Does not look for matches further away than max_backward.\n+   Writes the best match into |out|.\n+   |out|->score is updated only if a better match is found. */\n+static BROTLI_INLINE void FN(FindLongestMatch)(\n+    HasherHandle handle, const BrotliEncoderDictionary* dictionary,\n+    const uint8_t* BROTLI_RESTRICT data,\n+    const size_t ring_buffer_mask, const int* BROTLI_RESTRICT distance_cache,\n+    const size_t cur_ix, const size_t max_length, const size_t max_backward,\n+    const size_t gap, const size_t max_distance,\n+    HasherSearchResult* BROTLI_RESTRICT out) {\n+  HashLongestMatchQuickly* self = FN(Self)(handle);\n+  const size_t best_len_in = out->len;\n+  const size_t cur_ix_masked = cur_ix & ring_buffer_mask;\n+  const uint32_t key = FN(HashBytes)(&data[cur_ix_masked]);\n+  int compare_char = data[cur_ix_masked + best_len_in];\n+  score_t min_score = out->score;\n+  score_t best_score = out->score;\n+  size_t best_len = best_len_in;\n+  size_t cached_backward = (size_t)distance_cache[0];\n+  size_t prev_ix = cur_ix - cached_backward;\n+  out->len_code_delta = 0;\n+  if (prev_ix < cur_ix) {\n+    prev_ix &= (uint32_t)ring_buffer_mask;\n+    if (compare_char == data[prev_ix + best_len]) {\n+      size_t len = FindMatchLengthWithLimit(&data[prev_ix],\n+                                            &data[cur_ix_masked],\n+                                            max_length);\n+      if (len >= 4) {\n+        const score_t score = BackwardReferenceScoreUsingLastDistance(len);\n+        if (best_score < score) {\n+          best_score = score;\n+          best_len = len;\n+          out->len = len;\n+          out->distance = cached_backward;\n+          out->score = best_score;\n+          compare_char = data[cur_ix_masked + best_len];\n+          if (BUCKET_SWEEP == 1) {\n+            self->buckets_[key] = (uint32_t)cur_ix;\n+            return;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  if (BUCKET_SWEEP == 1) {\n+    size_t backward;\n+    size_t len;\n+    /* Only one to look for, don't bother to prepare for a loop. */\n+    prev_ix = self->buckets_[key];\n+    self->buckets_[key] = (uint32_t)cur_ix;\n+    backward = cur_ix - prev_ix;\n+    prev_ix &= (uint32_t)ring_buffer_mask;\n+    if (compare_char != data[prev_ix + best_len_in]) {\n+      return;\n+    }\n+    if (BROTLI_PREDICT_FALSE(backward == 0 || backward > max_backward)) {\n+      return;\n+    }\n+    len = FindMatchLengthWithLimit(&data[prev_ix],\n+                                   &data[cur_ix_masked],\n+                                   max_length);\n+    if (len >= 4) {\n+      const score_t score = BackwardReferenceScore(len, backward);\n+      if (best_score < score) {\n+        out->len = len;\n+        out->distance = backward;\n+        out->score = score;\n+        return;\n+      }\n+    }\n+  } else {\n+    uint32_t* bucket = self->buckets_ + key;\n+    int i;\n+    prev_ix = *bucket++;\n+    for (i = 0; i < BUCKET_SWEEP; ++i, prev_ix = *bucket++) {\n+      const size_t backward = cur_ix - prev_ix;\n+      size_t len;\n+      prev_ix &= (uint32_t)ring_buffer_mask;\n+      if (compare_char != data[prev_ix + best_len]) {\n+        continue;\n+      }\n+      if (BROTLI_PREDICT_FALSE(backward == 0 || backward > max_backward)) {\n+        continue;\n+      }\n+      len = FindMatchLengthWithLimit(&data[prev_ix],\n+                                     &data[cur_ix_masked],\n+                                     max_length);\n+      if (len >= 4) {\n+        const score_t score = BackwardReferenceScore(len, backward);\n+        if (best_score < score) {\n+          best_score = score;\n+          best_len = len;\n+          out->len = best_len;\n+          out->distance = backward;\n+          out->score = score;\n+          compare_char = data[cur_ix_masked + best_len];\n+        }\n+      }\n+    }\n+  }\n+  if (USE_DICTIONARY && min_score == out->score) {\n+    SearchInStaticDictionary(dictionary,\n+        handle, &data[cur_ix_masked], max_length, max_backward + gap,\n+        max_distance, out, BROTLI_TRUE);\n+  }\n+  self->buckets_[key + ((cur_ix >> 3) % BUCKET_SWEEP)] = (uint32_t)cur_ix;\n+}\n+\n+#undef HASH_MAP_SIZE\n+#undef BUCKET_SIZE\n+\n+#undef HashLongestMatchQuickly"
        },
        {
            "sha": "17f8a408e246e8fa5d38014a8f15e036b97b1e12",
            "filename": "deps/brotli/c/enc/hash_rolling_inc.h",
            "status": "added",
            "additions": 216,
            "deletions": 0,
            "changes": 216,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_rolling_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_rolling_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhash_rolling_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,216 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2018 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN, JUMP, NUMBUCKETS, MASK, CHUNKLEN */\n+/* NUMBUCKETS / (MASK + 1) = probability of storing and using hash code. */\n+/* JUMP = skip bytes for speedup */\n+\n+/* Rolling hash for long distance long string matches. Stores one position\n+   per bucket, bucket key is computed over a long region. */\n+\n+#define HashRolling HASHER()\n+\n+static const uint32_t FN(kRollingHashMul32) = 69069;\n+static const uint32_t FN(kInvalidPos) = 0xffffffff;\n+\n+/* This hasher uses a longer forward length, but returning a higher value here\n+   will hurt compression by the main hasher when combined with a composite\n+   hasher. The hasher tests for forward itself instead. */\n+static BROTLI_INLINE size_t FN(HashTypeLength)(void) { return 4; }\n+static BROTLI_INLINE size_t FN(StoreLookahead)(void) { return 4; }\n+\n+/* Computes a code from a single byte. A lookup table of 256 values could be\n+   used, but simply adding 1 works about as good. */\n+static uint32_t FN(HashByte)(uint8_t byte) {\n+  return (uint32_t)byte + 1u;\n+}\n+\n+static uint32_t FN(HashRollingFunctionInitial)(uint32_t state, uint8_t add,\n+                                               uint32_t factor) {\n+  return (uint32_t)(factor * state + FN(HashByte)(add));\n+}\n+\n+static uint32_t FN(HashRollingFunction)(uint32_t state, uint8_t add,\n+                                        uint8_t rem, uint32_t factor,\n+                                        uint32_t factor_remove) {\n+  return (uint32_t)(factor * state +\n+      FN(HashByte)(add) - factor_remove * FN(HashByte)(rem));\n+}\n+\n+typedef struct HashRolling {\n+  uint32_t state;\n+  uint32_t* table;\n+  size_t next_ix;\n+\n+  uint32_t chunk_len;\n+  uint32_t factor;\n+  uint32_t factor_remove;\n+} HashRolling;\n+\n+static BROTLI_INLINE HashRolling* FN(Self)(HasherHandle handle) {\n+  return (HashRolling*)&(GetHasherCommon(handle)[1]);\n+}\n+\n+static void FN(Initialize)(\n+    HasherHandle handle, const BrotliEncoderParams* params) {\n+  HashRolling* self = FN(Self)(handle);\n+  size_t i;\n+  self->state = 0;\n+  self->next_ix = 0;\n+\n+  self->factor = FN(kRollingHashMul32);\n+\n+  /* Compute the factor of the oldest byte to remove: factor**steps modulo\n+     0xffffffff (the multiplications rely on 32-bit overflow) */\n+  self->factor_remove = 1;\n+  for (i = 0; i < CHUNKLEN; i += JUMP) {\n+    self->factor_remove *= self->factor;\n+  }\n+\n+  self->table = (uint32_t*)((HasherHandle)self + sizeof(HashRolling));\n+  for (i = 0; i < NUMBUCKETS; i++) {\n+    self->table[i] = FN(kInvalidPos);\n+  }\n+\n+  BROTLI_UNUSED(params);\n+}\n+\n+static void FN(Prepare)(HasherHandle handle, BROTLI_BOOL one_shot,\n+    size_t input_size, const uint8_t* data) {\n+  HashRolling* self = FN(Self)(handle);\n+  size_t i;\n+  /* Too small size, cannot use this hasher. */\n+  if (input_size < CHUNKLEN) return;\n+  self->state = 0;\n+  for (i = 0; i < CHUNKLEN; i += JUMP) {\n+    self->state = FN(HashRollingFunctionInitial)(\n+        self->state, data[i], self->factor);\n+  }\n+  BROTLI_UNUSED(one_shot);\n+}\n+\n+static BROTLI_INLINE size_t FN(HashMemAllocInBytes)(\n+    const BrotliEncoderParams* params, BROTLI_BOOL one_shot,\n+    size_t input_size) {\n+  return sizeof(HashRolling) + NUMBUCKETS * sizeof(uint32_t);\n+  BROTLI_UNUSED(params);\n+  BROTLI_UNUSED(one_shot);\n+  BROTLI_UNUSED(input_size);\n+}\n+\n+static BROTLI_INLINE void FN(Store)(HasherHandle BROTLI_RESTRICT handle,\n+    const uint8_t* BROTLI_RESTRICT data, const size_t mask, const size_t ix) {\n+  BROTLI_UNUSED(handle);\n+  BROTLI_UNUSED(data);\n+  BROTLI_UNUSED(mask);\n+  BROTLI_UNUSED(ix);\n+}\n+\n+static BROTLI_INLINE void FN(StoreRange)(HasherHandle handle,\n+    const uint8_t* data, const size_t mask, const size_t ix_start,\n+    const size_t ix_end) {\n+  BROTLI_UNUSED(handle);\n+  BROTLI_UNUSED(data);\n+  BROTLI_UNUSED(mask);\n+  BROTLI_UNUSED(ix_start);\n+  BROTLI_UNUSED(ix_end);\n+}\n+\n+static BROTLI_INLINE void FN(StitchToPreviousBlock)(HasherHandle handle,\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ring_buffer_mask) {\n+  /* In this case we must re-initialize the hasher from scratch from the\n+     current position. */\n+  HashRolling* self = FN(Self)(handle);\n+  size_t position_masked;\n+  size_t available = num_bytes;\n+  if ((position & (JUMP - 1)) != 0) {\n+    size_t diff = JUMP - (position & (JUMP - 1));\n+    available = (diff > available) ? 0 : (available - diff);\n+    position += diff;\n+  }\n+  position_masked = position & ring_buffer_mask;\n+  /* wrapping around ringbuffer not handled. */\n+  if (available > ring_buffer_mask - position_masked) {\n+    available = ring_buffer_mask - position_masked;\n+  }\n+\n+  FN(Prepare)(handle, BROTLI_FALSE, available,\n+      ringbuffer + (position & ring_buffer_mask));\n+  self->next_ix = position;\n+  BROTLI_UNUSED(num_bytes);\n+}\n+\n+static BROTLI_INLINE void FN(PrepareDistanceCache)(\n+    HasherHandle handle, int* BROTLI_RESTRICT distance_cache) {\n+  BROTLI_UNUSED(handle);\n+  BROTLI_UNUSED(distance_cache);\n+}\n+\n+static BROTLI_INLINE void FN(FindLongestMatch)(HasherHandle handle,\n+    const BrotliEncoderDictionary* dictionary,\n+    const uint8_t* BROTLI_RESTRICT data, const size_t ring_buffer_mask,\n+    const int* BROTLI_RESTRICT distance_cache, const size_t cur_ix,\n+    const size_t max_length, const size_t max_backward,\n+    const size_t gap, const size_t max_distance,\n+    HasherSearchResult* BROTLI_RESTRICT out) {\n+  HashRolling* self = FN(Self)(handle);\n+  const size_t cur_ix_masked = cur_ix & ring_buffer_mask;\n+  size_t pos = self->next_ix;\n+\n+  if ((cur_ix & (JUMP - 1)) != 0) return;\n+\n+  /* Not enough lookahead */\n+  if (max_length < CHUNKLEN) return;\n+\n+  for (pos = self->next_ix; pos <= cur_ix; pos += JUMP) {\n+    uint32_t code = self->state & MASK;\n+\n+    uint8_t rem = data[pos & ring_buffer_mask];\n+    uint8_t add = data[(pos + CHUNKLEN) & ring_buffer_mask];\n+    size_t found_ix = FN(kInvalidPos);\n+\n+    self->state = FN(HashRollingFunction)(\n+        self->state, add, rem, self->factor, self->factor_remove);\n+\n+    if (code < NUMBUCKETS) {\n+      found_ix = self->table[code];\n+      self->table[code] = (uint32_t)pos;\n+      if (pos == cur_ix && found_ix != FN(kInvalidPos)) {\n+        /* The cast to 32-bit makes backward distances up to 4GB work even\n+           if cur_ix is above 4GB, despite using 32-bit values in the table. */\n+        size_t backward = (uint32_t)(cur_ix - found_ix);\n+        if (backward <= max_backward) {\n+          const size_t found_ix_masked = found_ix & ring_buffer_mask;\n+          const size_t len = FindMatchLengthWithLimit(&data[found_ix_masked],\n+                                                      &data[cur_ix_masked],\n+                                                      max_length);\n+          if (len >= 4 && len > out->len) {\n+            score_t score = BackwardReferenceScore(len, backward);\n+            if (score > out->score) {\n+              out->len = len;\n+              out->distance = backward;\n+              out->score = score;\n+              out->len_code_delta = 0;\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  self->next_ix = cur_ix + JUMP;\n+\n+  /* NOTE: this hasher does not search in the dictionary. It is used as\n+     backup-hasher, the main hasher already searches in it. */\n+  BROTLI_UNUSED(dictionary);\n+  BROTLI_UNUSED(distance_cache);\n+  BROTLI_UNUSED(gap);\n+  BROTLI_UNUSED(max_distance);\n+}\n+\n+#undef HashRolling"
        },
        {
            "sha": "7fb0356f5560e2a2bfa997c745b320ea58104375",
            "filename": "deps/brotli/c/enc/hash_to_binary_tree_inc.h",
            "status": "added",
            "additions": 328,
            "deletions": 0,
            "changes": 328,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_to_binary_tree_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhash_to_binary_tree_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhash_to_binary_tree_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,328 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2016 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: FN, BUCKET_BITS, MAX_TREE_COMP_LENGTH,\n+                        MAX_TREE_SEARCH_DEPTH */\n+\n+/* A (forgetful) hash table where each hash bucket contains a binary tree of\n+   sequences whose first 4 bytes share the same hash code.\n+   Each sequence is MAX_TREE_COMP_LENGTH long and is identified by its starting\n+   position in the input data. The binary tree is sorted by the lexicographic\n+   order of the sequences, and it is also a max-heap with respect to the\n+   starting positions. */\n+\n+#define HashToBinaryTree HASHER()\n+\n+#define BUCKET_SIZE (1 << BUCKET_BITS)\n+\n+static BROTLI_INLINE size_t FN(HashTypeLength)(void) { return 4; }\n+static BROTLI_INLINE size_t FN(StoreLookahead)(void) {\n+  return MAX_TREE_COMP_LENGTH;\n+}\n+\n+static uint32_t FN(HashBytes)(const uint8_t* data) {\n+  uint32_t h = BROTLI_UNALIGNED_LOAD32LE(data) * kHashMul32;\n+  /* The higher bits contain more mixture from the multiplication,\n+     so we take our results from there. */\n+  return h >> (32 - BUCKET_BITS);\n+}\n+\n+typedef struct HashToBinaryTree {\n+  /* The window size minus 1 */\n+  size_t window_mask_;\n+\n+  /* Hash table that maps the 4-byte hashes of the sequence to the last\n+     position where this hash was found, which is the root of the binary\n+     tree of sequences that share this hash bucket. */\n+  uint32_t buckets_[BUCKET_SIZE];\n+\n+  /* A position used to mark a non-existent sequence, i.e. a tree is empty if\n+     its root is at invalid_pos_ and a node is a leaf if both its children\n+     are at invalid_pos_. */\n+  uint32_t invalid_pos_;\n+\n+  /* --- Dynamic size members --- */\n+\n+  /* The union of the binary trees of each hash bucket. The root of the tree\n+     corresponding to a hash is a sequence starting at buckets_[hash] and\n+     the left and right children of a sequence starting at pos are\n+     forest_[2 * pos] and forest_[2 * pos + 1]. */\n+  /* uint32_t forest[2 * num_nodes] */\n+} HashToBinaryTree;\n+\n+static BROTLI_INLINE HashToBinaryTree* FN(Self)(HasherHandle handle) {\n+  return (HashToBinaryTree*)&(GetHasherCommon(handle)[1]);\n+}\n+\n+static BROTLI_INLINE uint32_t* FN(Forest)(HashToBinaryTree* self) {\n+  return (uint32_t*)(&self[1]);\n+}\n+\n+static void FN(Initialize)(\n+    HasherHandle handle, const BrotliEncoderParams* params) {\n+  HashToBinaryTree* self = FN(Self)(handle);\n+  self->window_mask_ = (1u << params->lgwin) - 1u;\n+  self->invalid_pos_ = (uint32_t)(0 - self->window_mask_);\n+}\n+\n+static void FN(Prepare)(HasherHandle handle, BROTLI_BOOL one_shot,\n+    size_t input_size, const uint8_t* data) {\n+  HashToBinaryTree* self = FN(Self)(handle);\n+  uint32_t invalid_pos = self->invalid_pos_;\n+  uint32_t i;\n+  BROTLI_UNUSED(data);\n+  BROTLI_UNUSED(one_shot);\n+  BROTLI_UNUSED(input_size);\n+  for (i = 0; i < BUCKET_SIZE; i++) {\n+    self->buckets_[i] = invalid_pos;\n+  }\n+}\n+\n+static BROTLI_INLINE size_t FN(HashMemAllocInBytes)(\n+    const BrotliEncoderParams* params, BROTLI_BOOL one_shot,\n+    size_t input_size) {\n+  size_t num_nodes = (size_t)1 << params->lgwin;\n+  if (one_shot && input_size < num_nodes) {\n+    num_nodes = input_size;\n+  }\n+  return sizeof(HashToBinaryTree) + 2 * sizeof(uint32_t) * num_nodes;\n+}\n+\n+static BROTLI_INLINE size_t FN(LeftChildIndex)(HashToBinaryTree* self,\n+    const size_t pos) {\n+  return 2 * (pos & self->window_mask_);\n+}\n+\n+static BROTLI_INLINE size_t FN(RightChildIndex)(HashToBinaryTree* self,\n+    const size_t pos) {\n+  return 2 * (pos & self->window_mask_) + 1;\n+}\n+\n+/* Stores the hash of the next 4 bytes and in a single tree-traversal, the\n+   hash bucket's binary tree is searched for matches and is re-rooted at the\n+   current position.\n+\n+   If less than MAX_TREE_COMP_LENGTH data is available, the hash bucket of the\n+   current position is searched for matches, but the state of the hash table\n+   is not changed, since we can not know the final sorting order of the\n+   current (incomplete) sequence.\n+\n+   This function must be called with increasing cur_ix positions. */\n+static BROTLI_INLINE BackwardMatch* FN(StoreAndFindMatches)(\n+    HashToBinaryTree* self, const uint8_t* const BROTLI_RESTRICT data,\n+    const size_t cur_ix, const size_t ring_buffer_mask, const size_t max_length,\n+    const size_t max_backward, size_t* const BROTLI_RESTRICT best_len,\n+    BackwardMatch* BROTLI_RESTRICT matches) {\n+  const size_t cur_ix_masked = cur_ix & ring_buffer_mask;\n+  const size_t max_comp_len =\n+      BROTLI_MIN(size_t, max_length, MAX_TREE_COMP_LENGTH);\n+  const BROTLI_BOOL should_reroot_tree =\n+      TO_BROTLI_BOOL(max_length >= MAX_TREE_COMP_LENGTH);\n+  const uint32_t key = FN(HashBytes)(&data[cur_ix_masked]);\n+  uint32_t* forest = FN(Forest)(self);\n+  size_t prev_ix = self->buckets_[key];\n+  /* The forest index of the rightmost node of the left subtree of the new\n+     root, updated as we traverse and re-root the tree of the hash bucket. */\n+  size_t node_left = FN(LeftChildIndex)(self, cur_ix);\n+  /* The forest index of the leftmost node of the right subtree of the new\n+     root, updated as we traverse and re-root the tree of the hash bucket. */\n+  size_t node_right = FN(RightChildIndex)(self, cur_ix);\n+  /* The match length of the rightmost node of the left subtree of the new\n+     root, updated as we traverse and re-root the tree of the hash bucket. */\n+  size_t best_len_left = 0;\n+  /* The match length of the leftmost node of the right subtree of the new\n+     root, updated as we traverse and re-root the tree of the hash bucket. */\n+  size_t best_len_right = 0;\n+  size_t depth_remaining;\n+  if (should_reroot_tree) {\n+    self->buckets_[key] = (uint32_t)cur_ix;\n+  }\n+  for (depth_remaining = MAX_TREE_SEARCH_DEPTH; ; --depth_remaining) {\n+    const size_t backward = cur_ix - prev_ix;\n+    const size_t prev_ix_masked = prev_ix & ring_buffer_mask;\n+    if (backward == 0 || backward > max_backward || depth_remaining == 0) {\n+      if (should_reroot_tree) {\n+        forest[node_left] = self->invalid_pos_;\n+        forest[node_right] = self->invalid_pos_;\n+      }\n+      break;\n+    }\n+    {\n+      const size_t cur_len = BROTLI_MIN(size_t, best_len_left, best_len_right);\n+      size_t len;\n+      BROTLI_DCHECK(cur_len <= MAX_TREE_COMP_LENGTH);\n+      len = cur_len +\n+          FindMatchLengthWithLimit(&data[cur_ix_masked + cur_len],\n+                                   &data[prev_ix_masked + cur_len],\n+                                   max_length - cur_len);\n+      BROTLI_DCHECK(\n+          0 == memcmp(&data[cur_ix_masked], &data[prev_ix_masked], len));\n+      if (matches && len > *best_len) {\n+        *best_len = len;\n+        InitBackwardMatch(matches++, backward, len);\n+      }\n+      if (len >= max_comp_len) {\n+        if (should_reroot_tree) {\n+          forest[node_left] = forest[FN(LeftChildIndex)(self, prev_ix)];\n+          forest[node_right] = forest[FN(RightChildIndex)(self, prev_ix)];\n+        }\n+        break;\n+      }\n+      if (data[cur_ix_masked + len] > data[prev_ix_masked + len]) {\n+        best_len_left = len;\n+        if (should_reroot_tree) {\n+          forest[node_left] = (uint32_t)prev_ix;\n+        }\n+        node_left = FN(RightChildIndex)(self, prev_ix);\n+        prev_ix = forest[node_left];\n+      } else {\n+        best_len_right = len;\n+        if (should_reroot_tree) {\n+          forest[node_right] = (uint32_t)prev_ix;\n+        }\n+        node_right = FN(LeftChildIndex)(self, prev_ix);\n+        prev_ix = forest[node_right];\n+      }\n+    }\n+  }\n+  return matches;\n+}\n+\n+/* Finds all backward matches of &data[cur_ix & ring_buffer_mask] up to the\n+   length of max_length and stores the position cur_ix in the hash table.\n+\n+   Sets *num_matches to the number of matches found, and stores the found\n+   matches in matches[0] to matches[*num_matches - 1]. The matches will be\n+   sorted by strictly increasing length and (non-strictly) increasing\n+   distance. */\n+static BROTLI_INLINE size_t FN(FindAllMatches)(HasherHandle handle,\n+    const BrotliEncoderDictionary* dictionary, const uint8_t* data,\n+    const size_t ring_buffer_mask, const size_t cur_ix,\n+    const size_t max_length, const size_t max_backward,\n+    const size_t gap, const BrotliEncoderParams* params,\n+    BackwardMatch* matches) {\n+  BackwardMatch* const orig_matches = matches;\n+  const size_t cur_ix_masked = cur_ix & ring_buffer_mask;\n+  size_t best_len = 1;\n+  const size_t short_match_max_backward =\n+      params->quality != HQ_ZOPFLIFICATION_QUALITY ? 16 : 64;\n+  size_t stop = cur_ix - short_match_max_backward;\n+  uint32_t dict_matches[BROTLI_MAX_STATIC_DICTIONARY_MATCH_LEN + 1];\n+  size_t i;\n+  if (cur_ix < short_match_max_backward) { stop = 0; }\n+  for (i = cur_ix - 1; i > stop && best_len <= 2; --i) {\n+    size_t prev_ix = i;\n+    const size_t backward = cur_ix - prev_ix;\n+    if (BROTLI_PREDICT_FALSE(backward > max_backward)) {\n+      break;\n+    }\n+    prev_ix &= ring_buffer_mask;\n+    if (data[cur_ix_masked] != data[prev_ix] ||\n+        data[cur_ix_masked + 1] != data[prev_ix + 1]) {\n+      continue;\n+    }\n+    {\n+      const size_t len =\n+          FindMatchLengthWithLimit(&data[prev_ix], &data[cur_ix_masked],\n+                                   max_length);\n+      if (len > best_len) {\n+        best_len = len;\n+        InitBackwardMatch(matches++, backward, len);\n+      }\n+    }\n+  }\n+  if (best_len < max_length) {\n+    matches = FN(StoreAndFindMatches)(FN(Self)(handle), data, cur_ix,\n+        ring_buffer_mask, max_length, max_backward, &best_len, matches);\n+  }\n+  for (i = 0; i <= BROTLI_MAX_STATIC_DICTIONARY_MATCH_LEN; ++i) {\n+    dict_matches[i] = kInvalidMatch;\n+  }\n+  {\n+    size_t minlen = BROTLI_MAX(size_t, 4, best_len + 1);\n+    if (BrotliFindAllStaticDictionaryMatches(dictionary,\n+        &data[cur_ix_masked], minlen, max_length, &dict_matches[0])) {\n+      size_t maxlen = BROTLI_MIN(\n+          size_t, BROTLI_MAX_STATIC_DICTIONARY_MATCH_LEN, max_length);\n+      size_t l;\n+      for (l = minlen; l <= maxlen; ++l) {\n+        uint32_t dict_id = dict_matches[l];\n+        if (dict_id < kInvalidMatch) {\n+          size_t distance = max_backward + gap + (dict_id >> 5) + 1;\n+          if (distance <= params->dist.max_distance) {\n+            InitDictionaryBackwardMatch(matches++, distance, l, dict_id & 31);\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return (size_t)(matches - orig_matches);\n+}\n+\n+/* Stores the hash of the next 4 bytes and re-roots the binary tree at the\n+   current sequence, without returning any matches.\n+   REQUIRES: ix + MAX_TREE_COMP_LENGTH <= end-of-current-block */\n+static BROTLI_INLINE void FN(Store)(HasherHandle handle, const uint8_t* data,\n+    const size_t mask, const size_t ix) {\n+  HashToBinaryTree* self = FN(Self)(handle);\n+  /* Maximum distance is window size - 16, see section 9.1. of the spec. */\n+  const size_t max_backward = self->window_mask_ - BROTLI_WINDOW_GAP + 1;\n+  FN(StoreAndFindMatches)(self, data, ix, mask, MAX_TREE_COMP_LENGTH,\n+      max_backward, NULL, NULL);\n+}\n+\n+static BROTLI_INLINE void FN(StoreRange)(HasherHandle handle,\n+    const uint8_t* data, const size_t mask, const size_t ix_start,\n+    const size_t ix_end) {\n+  size_t i = ix_start;\n+  size_t j = ix_start;\n+  if (ix_start + 63 <= ix_end) {\n+    i = ix_end - 63;\n+  }\n+  if (ix_start + 512 <= i) {\n+    for (; j < i; j += 8) {\n+      FN(Store)(handle, data, mask, j);\n+    }\n+  }\n+  for (; i < ix_end; ++i) {\n+    FN(Store)(handle, data, mask, i);\n+  }\n+}\n+\n+static BROTLI_INLINE void FN(StitchToPreviousBlock)(HasherHandle handle,\n+    size_t num_bytes, size_t position, const uint8_t* ringbuffer,\n+    size_t ringbuffer_mask) {\n+  HashToBinaryTree* self = FN(Self)(handle);\n+  if (num_bytes >= FN(HashTypeLength)() - 1 &&\n+      position >= MAX_TREE_COMP_LENGTH) {\n+    /* Store the last `MAX_TREE_COMP_LENGTH - 1` positions in the hasher.\n+       These could not be calculated before, since they require knowledge\n+       of both the previous and the current block. */\n+    const size_t i_start = position - MAX_TREE_COMP_LENGTH + 1;\n+    const size_t i_end = BROTLI_MIN(size_t, position, i_start + num_bytes);\n+    size_t i;\n+    for (i = i_start; i < i_end; ++i) {\n+      /* Maximum distance is window size - 16, see section 9.1. of the spec.\n+         Furthermore, we have to make sure that we don't look further back\n+         from the start of the next block than the window size, otherwise we\n+         could access already overwritten areas of the ring-buffer. */\n+      const size_t max_backward =\n+          self->window_mask_ - BROTLI_MAX(size_t,\n+                                          BROTLI_WINDOW_GAP - 1,\n+                                          position - i);\n+      /* We know that i + MAX_TREE_COMP_LENGTH <= position + num_bytes, i.e. the\n+         end of the current block and that we have at least\n+         MAX_TREE_COMP_LENGTH tail in the ring-buffer. */\n+      FN(StoreAndFindMatches)(self, ringbuffer, i, ringbuffer_mask,\n+          MAX_TREE_COMP_LENGTH, max_backward, NULL, NULL);\n+    }\n+  }\n+}\n+\n+#undef BUCKET_SIZE\n+\n+#undef HashToBinaryTree"
        },
        {
            "sha": "6da2ff6bb432729630e68377199009f853305713",
            "filename": "deps/brotli/c/enc/histogram.c",
            "status": "added",
            "additions": 100,
            "deletions": 0,
            "changes": 100,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhistogram.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhistogram.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhistogram.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,100 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Build per-context histograms of literals, commands and distance codes. */\n+\n+#include \"./histogram.h\"\n+\n+#include \"../common/context.h\"\n+#include \"./block_splitter.h\"\n+#include \"./command.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+typedef struct BlockSplitIterator {\n+  const BlockSplit* split_;  /* Not owned. */\n+  size_t idx_;\n+  size_t type_;\n+  size_t length_;\n+} BlockSplitIterator;\n+\n+static void InitBlockSplitIterator(BlockSplitIterator* self,\n+    const BlockSplit* split) {\n+  self->split_ = split;\n+  self->idx_ = 0;\n+  self->type_ = 0;\n+  self->length_ = split->lengths ? split->lengths[0] : 0;\n+}\n+\n+static void BlockSplitIteratorNext(BlockSplitIterator* self) {\n+  if (self->length_ == 0) {\n+    ++self->idx_;\n+    self->type_ = self->split_->types[self->idx_];\n+    self->length_ = self->split_->lengths[self->idx_];\n+  }\n+  --self->length_;\n+}\n+\n+void BrotliBuildHistogramsWithContext(\n+    const Command* cmds, const size_t num_commands,\n+    const BlockSplit* literal_split, const BlockSplit* insert_and_copy_split,\n+    const BlockSplit* dist_split, const uint8_t* ringbuffer, size_t start_pos,\n+    size_t mask, uint8_t prev_byte, uint8_t prev_byte2,\n+    const ContextType* context_modes, HistogramLiteral* literal_histograms,\n+    HistogramCommand* insert_and_copy_histograms,\n+    HistogramDistance* copy_dist_histograms) {\n+  size_t pos = start_pos;\n+  BlockSplitIterator literal_it;\n+  BlockSplitIterator insert_and_copy_it;\n+  BlockSplitIterator dist_it;\n+  size_t i;\n+\n+  InitBlockSplitIterator(&literal_it, literal_split);\n+  InitBlockSplitIterator(&insert_and_copy_it, insert_and_copy_split);\n+  InitBlockSplitIterator(&dist_it, dist_split);\n+  for (i = 0; i < num_commands; ++i) {\n+    const Command* cmd = &cmds[i];\n+    size_t j;\n+    BlockSplitIteratorNext(&insert_and_copy_it);\n+    HistogramAddCommand(&insert_and_copy_histograms[insert_and_copy_it.type_],\n+        cmd->cmd_prefix_);\n+    /* TODO: unwrap iterator blocks. */\n+    for (j = cmd->insert_len_; j != 0; --j) {\n+      size_t context;\n+      BlockSplitIteratorNext(&literal_it);\n+      context = literal_it.type_;\n+      if (context_modes) {\n+        ContextLut lut = BROTLI_CONTEXT_LUT(context_modes[context]);\n+        context = (context << BROTLI_LITERAL_CONTEXT_BITS) +\n+            BROTLI_CONTEXT(prev_byte, prev_byte2, lut);\n+      }\n+      HistogramAddLiteral(&literal_histograms[context],\n+          ringbuffer[pos & mask]);\n+      prev_byte2 = prev_byte;\n+      prev_byte = ringbuffer[pos & mask];\n+      ++pos;\n+    }\n+    pos += CommandCopyLen(cmd);\n+    if (CommandCopyLen(cmd)) {\n+      prev_byte2 = ringbuffer[(pos - 2) & mask];\n+      prev_byte = ringbuffer[(pos - 1) & mask];\n+      if (cmd->cmd_prefix_ >= 128) {\n+        size_t context;\n+        BlockSplitIteratorNext(&dist_it);\n+        context = (dist_it.type_ << BROTLI_DISTANCE_CONTEXT_BITS) +\n+            CommandDistanceContext(cmd);\n+        HistogramAddDistance(&copy_dist_histograms[context],\n+            cmd->dist_prefix_ & 0x3FF);\n+      }\n+    }\n+  }\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "42af3c3f9d10f568c2ce5129a07114fe2d67192c",
            "filename": "deps/brotli/c/enc/histogram.h",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhistogram.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhistogram.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhistogram.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,63 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Models the histograms of literals, commands and distance codes. */\n+\n+#ifndef BROTLI_ENC_HISTOGRAM_H_\n+#define BROTLI_ENC_HISTOGRAM_H_\n+\n+#include <string.h>  /* memset */\n+\n+#include \"../common/constants.h\"\n+#include \"../common/context.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./block_splitter.h\"\n+#include \"./command.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* The distance symbols effectively used by \"Large Window Brotli\" (32-bit). */\n+#define BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS 544\n+\n+#define FN(X) X ## Literal\n+#define DATA_SIZE BROTLI_NUM_LITERAL_SYMBOLS\n+#define DataType uint8_t\n+#include \"./histogram_inc.h\"  /* NOLINT(build/include) */\n+#undef DataType\n+#undef DATA_SIZE\n+#undef FN\n+\n+#define FN(X) X ## Command\n+#define DataType uint16_t\n+#define DATA_SIZE BROTLI_NUM_COMMAND_SYMBOLS\n+#include \"./histogram_inc.h\"  /* NOLINT(build/include) */\n+#undef DATA_SIZE\n+#undef FN\n+\n+#define FN(X) X ## Distance\n+#define DATA_SIZE BROTLI_NUM_HISTOGRAM_DISTANCE_SYMBOLS\n+#include \"./histogram_inc.h\"  /* NOLINT(build/include) */\n+#undef DataType\n+#undef DATA_SIZE\n+#undef FN\n+\n+BROTLI_INTERNAL void BrotliBuildHistogramsWithContext(\n+    const Command* cmds, const size_t num_commands,\n+    const BlockSplit* literal_split, const BlockSplit* insert_and_copy_split,\n+    const BlockSplit* dist_split, const uint8_t* ringbuffer, size_t pos,\n+    size_t mask, uint8_t prev_byte, uint8_t prev_byte2,\n+    const ContextType* context_modes, HistogramLiteral* literal_histograms,\n+    HistogramCommand* insert_and_copy_histograms,\n+    HistogramDistance* copy_dist_histograms);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_HISTOGRAM_H_ */"
        },
        {
            "sha": "50eaf7468dab47f264eee6ccd5016066c14bb84b",
            "filename": "deps/brotli/c/enc/histogram_inc.h",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhistogram_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fhistogram_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fhistogram_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,51 @@\n+/* NOLINT(build/header_guard) */\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* template parameters: Histogram, DATA_SIZE, DataType */\n+\n+/* A simple container for histograms of data in blocks. */\n+\n+typedef struct FN(Histogram) {\n+  uint32_t data_[DATA_SIZE];\n+  size_t total_count_;\n+  double bit_cost_;\n+} FN(Histogram);\n+\n+static BROTLI_INLINE void FN(HistogramClear)(FN(Histogram)* self) {\n+  memset(self->data_, 0, sizeof(self->data_));\n+  self->total_count_ = 0;\n+  self->bit_cost_ = HUGE_VAL;\n+}\n+\n+static BROTLI_INLINE void FN(ClearHistograms)(\n+    FN(Histogram)* array, size_t length) {\n+  size_t i;\n+  for (i = 0; i < length; ++i) FN(HistogramClear)(array + i);\n+}\n+\n+static BROTLI_INLINE void FN(HistogramAdd)(FN(Histogram)* self, size_t val) {\n+  ++self->data_[val];\n+  ++self->total_count_;\n+}\n+\n+static BROTLI_INLINE void FN(HistogramAddVector)(FN(Histogram)* self,\n+    const DataType* p, size_t n) {\n+  self->total_count_ += n;\n+  n += 1;\n+  while (--n) ++self->data_[*p++];\n+}\n+\n+static BROTLI_INLINE void FN(HistogramAddHistogram)(FN(Histogram)* self,\n+    const FN(Histogram)* v) {\n+  size_t i;\n+  self->total_count_ += v->total_count_;\n+  for (i = 0; i < DATA_SIZE; ++i) {\n+    self->data_[i] += v->data_[i];\n+  }\n+}\n+\n+static BROTLI_INLINE size_t FN(HistogramDataSize)(void) { return DATA_SIZE; }"
        },
        {
            "sha": "c231100e3418290c481b3af6fbea0acd564dcbb7",
            "filename": "deps/brotli/c/enc/literal_cost.c",
            "status": "added",
            "additions": 175,
            "deletions": 0,
            "changes": 175,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fliteral_cost.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fliteral_cost.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fliteral_cost.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,175 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Literal cost model to allow backward reference replacement to be efficient.\n+*/\n+\n+#include \"./literal_cost.h\"\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./fast_log.h\"\n+#include \"./utf8_util.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+static size_t UTF8Position(size_t last, size_t c, size_t clamp) {\n+  if (c < 128) {\n+    return 0;  /* Next one is the 'Byte 1' again. */\n+  } else if (c >= 192) {  /* Next one is the 'Byte 2' of utf-8 encoding. */\n+    return BROTLI_MIN(size_t, 1, clamp);\n+  } else {\n+    /* Let's decide over the last byte if this ends the sequence. */\n+    if (last < 0xE0) {\n+      return 0;  /* Completed two or three byte coding. */\n+    } else {  /* Next one is the 'Byte 3' of utf-8 encoding. */\n+      return BROTLI_MIN(size_t, 2, clamp);\n+    }\n+  }\n+}\n+\n+static size_t DecideMultiByteStatsLevel(size_t pos, size_t len, size_t mask,\n+                                        const uint8_t* data) {\n+  size_t counts[3] = { 0 };\n+  size_t max_utf8 = 1;  /* should be 2, but 1 compresses better. */\n+  size_t last_c = 0;\n+  size_t i;\n+  for (i = 0; i < len; ++i) {\n+    size_t c = data[(pos + i) & mask];\n+    ++counts[UTF8Position(last_c, c, 2)];\n+    last_c = c;\n+  }\n+  if (counts[2] < 500) {\n+    max_utf8 = 1;\n+  }\n+  if (counts[1] + counts[2] < 25) {\n+    max_utf8 = 0;\n+  }\n+  return max_utf8;\n+}\n+\n+static void EstimateBitCostsForLiteralsUTF8(size_t pos, size_t len, size_t mask,\n+                                            const uint8_t* data, float* cost) {\n+  /* max_utf8 is 0 (normal ASCII single byte modeling),\n+     1 (for 2-byte UTF-8 modeling), or 2 (for 3-byte UTF-8 modeling). */\n+  const size_t max_utf8 = DecideMultiByteStatsLevel(pos, len, mask, data);\n+  size_t histogram[3][256] = { { 0 } };\n+  size_t window_half = 495;\n+  size_t in_window = BROTLI_MIN(size_t, window_half, len);\n+  size_t in_window_utf8[3] = { 0 };\n+\n+  size_t i;\n+  {  /* Bootstrap histograms. */\n+    size_t last_c = 0;\n+    size_t utf8_pos = 0;\n+    for (i = 0; i < in_window; ++i) {\n+      size_t c = data[(pos + i) & mask];\n+      ++histogram[utf8_pos][c];\n+      ++in_window_utf8[utf8_pos];\n+      utf8_pos = UTF8Position(last_c, c, max_utf8);\n+      last_c = c;\n+    }\n+  }\n+\n+  /* Compute bit costs with sliding window. */\n+  for (i = 0; i < len; ++i) {\n+    if (i >= window_half) {\n+      /* Remove a byte in the past. */\n+      size_t c =\n+          i < window_half + 1 ? 0 : data[(pos + i - window_half - 1) & mask];\n+      size_t last_c =\n+          i < window_half + 2 ? 0 : data[(pos + i - window_half - 2) & mask];\n+      size_t utf8_pos2 = UTF8Position(last_c, c, max_utf8);\n+      --histogram[utf8_pos2][data[(pos + i - window_half) & mask]];\n+      --in_window_utf8[utf8_pos2];\n+    }\n+    if (i + window_half < len) {\n+      /* Add a byte in the future. */\n+      size_t c = data[(pos + i + window_half - 1) & mask];\n+      size_t last_c = data[(pos + i + window_half - 2) & mask];\n+      size_t utf8_pos2 = UTF8Position(last_c, c, max_utf8);\n+      ++histogram[utf8_pos2][data[(pos + i + window_half) & mask]];\n+      ++in_window_utf8[utf8_pos2];\n+    }\n+    {\n+      size_t c = i < 1 ? 0 : data[(pos + i - 1) & mask];\n+      size_t last_c = i < 2 ? 0 : data[(pos + i - 2) & mask];\n+      size_t utf8_pos = UTF8Position(last_c, c, max_utf8);\n+      size_t masked_pos = (pos + i) & mask;\n+      size_t histo = histogram[utf8_pos][data[masked_pos]];\n+      double lit_cost;\n+      if (histo == 0) {\n+        histo = 1;\n+      }\n+      lit_cost = FastLog2(in_window_utf8[utf8_pos]) - FastLog2(histo);\n+      lit_cost += 0.02905;\n+      if (lit_cost < 1.0) {\n+        lit_cost *= 0.5;\n+        lit_cost += 0.5;\n+      }\n+      /* Make the first bytes more expensive -- seems to help, not sure why.\n+         Perhaps because the entropy source is changing its properties\n+         rapidly in the beginning of the file, perhaps because the beginning\n+         of the data is a statistical \"anomaly\". */\n+      if (i < 2000) {\n+        lit_cost += 0.7 - ((double)(2000 - i) / 2000.0 * 0.35);\n+      }\n+      cost[i] = (float)lit_cost;\n+    }\n+  }\n+}\n+\n+void BrotliEstimateBitCostsForLiterals(size_t pos, size_t len, size_t mask,\n+                                       const uint8_t* data, float* cost) {\n+  if (BrotliIsMostlyUTF8(data, pos, mask, len, kMinUTF8Ratio)) {\n+    EstimateBitCostsForLiteralsUTF8(pos, len, mask, data, cost);\n+    return;\n+  } else {\n+    size_t histogram[256] = { 0 };\n+    size_t window_half = 2000;\n+    size_t in_window = BROTLI_MIN(size_t, window_half, len);\n+\n+    /* Bootstrap histogram. */\n+    size_t i;\n+    for (i = 0; i < in_window; ++i) {\n+      ++histogram[data[(pos + i) & mask]];\n+    }\n+\n+    /* Compute bit costs with sliding window. */\n+    for (i = 0; i < len; ++i) {\n+      size_t histo;\n+      if (i >= window_half) {\n+        /* Remove a byte in the past. */\n+        --histogram[data[(pos + i - window_half) & mask]];\n+        --in_window;\n+      }\n+      if (i + window_half < len) {\n+        /* Add a byte in the future. */\n+        ++histogram[data[(pos + i + window_half) & mask]];\n+        ++in_window;\n+      }\n+      histo = histogram[data[(pos + i) & mask]];\n+      if (histo == 0) {\n+        histo = 1;\n+      }\n+      {\n+        double lit_cost = FastLog2(in_window) - FastLog2(histo);\n+        lit_cost += 0.029;\n+        if (lit_cost < 1.0) {\n+          lit_cost *= 0.5;\n+          lit_cost += 0.5;\n+        }\n+        cost[i] = (float)lit_cost;\n+      }\n+    }\n+  }\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "8f53f39d3f2e8edb944f80c2b1cb841564efe498",
            "filename": "deps/brotli/c/enc/literal_cost.h",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fliteral_cost.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fliteral_cost.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fliteral_cost.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,30 @@\n+/* Copyright 2013 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Literal cost model to allow backward reference replacement to be efficient.\n+*/\n+\n+#ifndef BROTLI_ENC_LITERAL_COST_H_\n+#define BROTLI_ENC_LITERAL_COST_H_\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+/* Estimates how many bits the literals in the interval [pos, pos + len) in the\n+   ring-buffer (data, mask) will take entropy coded and writes these estimates\n+   to the cost[0..len) array. */\n+BROTLI_INTERNAL void BrotliEstimateBitCostsForLiterals(\n+    size_t pos, size_t len, size_t mask, const uint8_t* data, float* cost);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_LITERAL_COST_H_ */"
        },
        {
            "sha": "f6ed7e3cb750d5da2dac9db5b332a3224e649e0a",
            "filename": "deps/brotli/c/enc/memory.c",
            "status": "added",
            "additions": 170,
            "deletions": 0,
            "changes": 170,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmemory.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmemory.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fmemory.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,170 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Algorithms for distributing the literals and commands of a metablock between\n+   block types and contexts. */\n+\n+#include \"./memory.h\"\n+\n+#include <stdlib.h>  /* exit, free, malloc */\n+#include <string.h>  /* memcpy */\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#define MAX_PERM_ALLOCATED 128\n+#define MAX_NEW_ALLOCATED 64\n+#define MAX_NEW_FREED 64\n+\n+#define PERM_ALLOCATED_OFFSET 0\n+#define NEW_ALLOCATED_OFFSET MAX_PERM_ALLOCATED\n+#define NEW_FREED_OFFSET (MAX_PERM_ALLOCATED + MAX_NEW_ALLOCATED)\n+\n+void BrotliInitMemoryManager(\n+    MemoryManager* m, brotli_alloc_func alloc_func, brotli_free_func free_func,\n+    void* opaque) {\n+  if (!alloc_func) {\n+    m->alloc_func = BrotliDefaultAllocFunc;\n+    m->free_func = BrotliDefaultFreeFunc;\n+    m->opaque = 0;\n+  } else {\n+    m->alloc_func = alloc_func;\n+    m->free_func = free_func;\n+    m->opaque = opaque;\n+  }\n+#if !defined(BROTLI_ENCODER_EXIT_ON_OOM)\n+  m->is_oom = BROTLI_FALSE;\n+  m->perm_allocated = 0;\n+  m->new_allocated = 0;\n+  m->new_freed = 0;\n+#endif  /* BROTLI_ENCODER_EXIT_ON_OOM */\n+}\n+\n+#if defined(BROTLI_ENCODER_EXIT_ON_OOM)\n+\n+void* BrotliAllocate(MemoryManager* m, size_t n) {\n+  void* result = m->alloc_func(m->opaque, n);\n+  if (!result) exit(EXIT_FAILURE);\n+  return result;\n+}\n+\n+void BrotliFree(MemoryManager* m, void* p) {\n+  m->free_func(m->opaque, p);\n+}\n+\n+void BrotliWipeOutMemoryManager(MemoryManager* m) {\n+  BROTLI_UNUSED(m);\n+}\n+\n+#else  /* BROTLI_ENCODER_EXIT_ON_OOM */\n+\n+static void SortPointers(void** items, const size_t n) {\n+  /* Shell sort. */\n+  static const size_t gaps[] = {23, 10, 4, 1};\n+  int g = 0;\n+  for (; g < 4; ++g) {\n+    size_t gap = gaps[g];\n+    size_t i;\n+    for (i = gap; i < n; ++i) {\n+      size_t j = i;\n+      void* tmp = items[i];\n+      for (; j >= gap && tmp < items[j - gap]; j -= gap) {\n+        items[j] = items[j - gap];\n+      }\n+      items[j] = tmp;\n+    }\n+  }\n+}\n+\n+static size_t Annihilate(void** a, size_t a_len, void** b, size_t b_len) {\n+  size_t a_read_index = 0;\n+  size_t b_read_index = 0;\n+  size_t a_write_index = 0;\n+  size_t b_write_index = 0;\n+  size_t annihilated = 0;\n+  while (a_read_index < a_len && b_read_index < b_len) {\n+    if (a[a_read_index] == b[b_read_index]) {\n+      a_read_index++;\n+      b_read_index++;\n+      annihilated++;\n+    } else if (a[a_read_index] < b[b_read_index]) {\n+      a[a_write_index++] = a[a_read_index++];\n+    } else {\n+      b[b_write_index++] = b[b_read_index++];\n+    }\n+  }\n+  while (a_read_index < a_len) a[a_write_index++] = a[a_read_index++];\n+  while (b_read_index < b_len) b[b_write_index++] = b[b_read_index++];\n+  return annihilated;\n+}\n+\n+static void CollectGarbagePointers(MemoryManager* m) {\n+  size_t annihilated;\n+  SortPointers(m->pointers + NEW_ALLOCATED_OFFSET, m->new_allocated);\n+  SortPointers(m->pointers + NEW_FREED_OFFSET, m->new_freed);\n+  annihilated = Annihilate(\n+      m->pointers + NEW_ALLOCATED_OFFSET, m->new_allocated,\n+      m->pointers + NEW_FREED_OFFSET, m->new_freed);\n+  m->new_allocated -= annihilated;\n+  m->new_freed -= annihilated;\n+\n+  if (m->new_freed != 0) {\n+    annihilated = Annihilate(\n+        m->pointers + PERM_ALLOCATED_OFFSET, m->perm_allocated,\n+        m->pointers + NEW_FREED_OFFSET, m->new_freed);\n+    m->perm_allocated -= annihilated;\n+    m->new_freed -= annihilated;\n+    BROTLI_DCHECK(m->new_freed == 0);\n+  }\n+\n+  if (m->new_allocated != 0) {\n+    BROTLI_DCHECK(m->perm_allocated + m->new_allocated <= MAX_PERM_ALLOCATED);\n+    memcpy(m->pointers + PERM_ALLOCATED_OFFSET + m->perm_allocated,\n+           m->pointers + NEW_ALLOCATED_OFFSET,\n+           sizeof(void*) * m->new_allocated);\n+    m->perm_allocated += m->new_allocated;\n+    m->new_allocated = 0;\n+    SortPointers(m->pointers + PERM_ALLOCATED_OFFSET, m->perm_allocated);\n+  }\n+}\n+\n+void* BrotliAllocate(MemoryManager* m, size_t n) {\n+  void* result = m->alloc_func(m->opaque, n);\n+  if (!result) {\n+    m->is_oom = BROTLI_TRUE;\n+    return NULL;\n+  }\n+  if (m->new_allocated == MAX_NEW_ALLOCATED) CollectGarbagePointers(m);\n+  m->pointers[NEW_ALLOCATED_OFFSET + (m->new_allocated++)] = result;\n+  return result;\n+}\n+\n+void BrotliFree(MemoryManager* m, void* p) {\n+  if (!p) return;\n+  m->free_func(m->opaque, p);\n+  if (m->new_freed == MAX_NEW_FREED) CollectGarbagePointers(m);\n+  m->pointers[NEW_FREED_OFFSET + (m->new_freed++)] = p;\n+}\n+\n+void BrotliWipeOutMemoryManager(MemoryManager* m) {\n+  size_t i;\n+  CollectGarbagePointers(m);\n+  /* Now all unfreed pointers are in perm-allocated list. */\n+  for (i = 0; i < m->perm_allocated; ++i) {\n+    m->free_func(m->opaque, m->pointers[PERM_ALLOCATED_OFFSET + i]);\n+  }\n+  m->perm_allocated = 0;\n+}\n+\n+#endif  /* BROTLI_ENCODER_EXIT_ON_OOM */\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "ab928d019be8d960b6c80c9222402e98be0b0e9e",
            "filename": "deps/brotli/c/enc/memory.h",
            "status": "added",
            "additions": 102,
            "deletions": 0,
            "changes": 102,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmemory.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmemory.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fmemory.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,102 @@\n+/* Copyright 2016 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Macros for memory management. */\n+\n+#ifndef BROTLI_ENC_MEMORY_H_\n+#define BROTLI_ENC_MEMORY_H_\n+\n+#include <string.h>  /* memcpy */\n+\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+#if !defined(BROTLI_ENCODER_CLEANUP_ON_OOM) && \\\n+    !defined(BROTLI_ENCODER_EXIT_ON_OOM)\n+#define BROTLI_ENCODER_EXIT_ON_OOM\n+#endif\n+\n+typedef struct MemoryManager {\n+  brotli_alloc_func alloc_func;\n+  brotli_free_func free_func;\n+  void* opaque;\n+#if !defined(BROTLI_ENCODER_EXIT_ON_OOM)\n+  BROTLI_BOOL is_oom;\n+  size_t perm_allocated;\n+  size_t new_allocated;\n+  size_t new_freed;\n+  void* pointers[256];\n+#endif  /* BROTLI_ENCODER_EXIT_ON_OOM */\n+} MemoryManager;\n+\n+BROTLI_INTERNAL void BrotliInitMemoryManager(\n+    MemoryManager* m, brotli_alloc_func alloc_func, brotli_free_func free_func,\n+    void* opaque);\n+\n+BROTLI_INTERNAL void* BrotliAllocate(MemoryManager* m, size_t n);\n+#define BROTLI_ALLOC(M, T, N)                               \\\n+  ((N) > 0 ? ((T*)BrotliAllocate((M), (N) * sizeof(T))) : NULL)\n+\n+BROTLI_INTERNAL void BrotliFree(MemoryManager* m, void* p);\n+#define BROTLI_FREE(M, P) { \\\n+  BrotliFree((M), (P));     \\\n+  P = NULL;                 \\\n+}\n+\n+#if defined(BROTLI_ENCODER_EXIT_ON_OOM)\n+#define BROTLI_IS_OOM(M) (!!0)\n+#else  /* BROTLI_ENCODER_EXIT_ON_OOM */\n+#define BROTLI_IS_OOM(M) (!!(M)->is_oom)\n+#endif  /* BROTLI_ENCODER_EXIT_ON_OOM */\n+\n+BROTLI_INTERNAL void BrotliWipeOutMemoryManager(MemoryManager* m);\n+\n+/*\n+Dynamically grows array capacity to at least the requested size\n+M: MemoryManager\n+T: data type\n+A: array\n+C: capacity\n+R: requested size\n+*/\n+#define BROTLI_ENSURE_CAPACITY(M, T, A, C, R) {  \\\n+  if (C < (R)) {                                 \\\n+    size_t _new_size = (C == 0) ? (R) : C;       \\\n+    T* new_array;                                \\\n+    while (_new_size < (R)) _new_size *= 2;      \\\n+    new_array = BROTLI_ALLOC((M), T, _new_size); \\\n+    if (!BROTLI_IS_OOM(M) && C != 0)             \\\n+      memcpy(new_array, A, C * sizeof(T));       \\\n+    BROTLI_FREE((M), A);                         \\\n+    A = new_array;                               \\\n+    C = _new_size;                               \\\n+  }                                              \\\n+}\n+\n+/*\n+Appends value and dynamically grows array capacity when needed\n+M: MemoryManager\n+T: data type\n+A: array\n+C: array capacity\n+S: array size\n+V: value to append\n+*/\n+#define BROTLI_ENSURE_CAPACITY_APPEND(M, T, A, C, S, V) { \\\n+  (S)++;                                                  \\\n+  BROTLI_ENSURE_CAPACITY(M, T, A, C, S);                  \\\n+  A[(S) - 1] = (V);                                       \\\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_MEMORY_H_ */"
        },
        {
            "sha": "4e80044f3186ccad6e7c32036d3e59778f135df1",
            "filename": "deps/brotli/c/enc/metablock.c",
            "status": "added",
            "additions": 667,
            "deletions": 0,
            "changes": 667,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmetablock.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmetablock.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fmetablock.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,667 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Algorithms for distributing the literals and commands of a metablock between\n+   block types and contexts. */\n+\n+#include \"./metablock.h\"\n+\n+#include \"../common/constants.h\"\n+#include \"../common/context.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./bit_cost.h\"\n+#include \"./block_splitter.h\"\n+#include \"./cluster.h\"\n+#include \"./entropy_encode.h\"\n+#include \"./histogram.h\"\n+#include \"./memory.h\"\n+#include \"./quality.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+void BrotliInitDistanceParams(BrotliEncoderParams* params,\n+    uint32_t npostfix, uint32_t ndirect) {\n+  BrotliDistanceParams* dist_params = &params->dist;\n+  uint32_t alphabet_size, max_distance;\n+\n+  dist_params->distance_postfix_bits = npostfix;\n+  dist_params->num_direct_distance_codes = ndirect;\n+\n+  alphabet_size = BROTLI_DISTANCE_ALPHABET_SIZE(\n+      npostfix, ndirect, BROTLI_MAX_DISTANCE_BITS);\n+  max_distance = ndirect + (1U << (BROTLI_MAX_DISTANCE_BITS + npostfix + 2)) -\n+      (1U << (npostfix + 2));\n+\n+  if (params->large_window) {\n+    static const uint32_t bound[BROTLI_MAX_NPOSTFIX + 1] = {0, 4, 12, 28};\n+    uint32_t postfix = 1U << npostfix;\n+    alphabet_size = BROTLI_DISTANCE_ALPHABET_SIZE(\n+        npostfix, ndirect, BROTLI_LARGE_MAX_DISTANCE_BITS);\n+    /* The maximum distance is set so that no distance symbol used can encode\n+       a distance larger than BROTLI_MAX_ALLOWED_DISTANCE with all\n+       its extra bits set. */\n+    if (ndirect < bound[npostfix]) {\n+      max_distance = BROTLI_MAX_ALLOWED_DISTANCE - (bound[npostfix] - ndirect);\n+    } else if (ndirect >= bound[npostfix] + postfix) {\n+      max_distance = (3U << 29) - 4 + (ndirect - bound[npostfix]);\n+    } else {\n+      max_distance = BROTLI_MAX_ALLOWED_DISTANCE;\n+    }\n+  }\n+\n+  dist_params->alphabet_size = alphabet_size;\n+  dist_params->max_distance = max_distance;\n+}\n+\n+static void RecomputeDistancePrefixes(Command* cmds,\n+                                      size_t num_commands,\n+                                      const BrotliDistanceParams* orig_params,\n+                                      const BrotliDistanceParams* new_params) {\n+  size_t i;\n+\n+  if (orig_params->distance_postfix_bits == new_params->distance_postfix_bits &&\n+      orig_params->num_direct_distance_codes ==\n+      new_params->num_direct_distance_codes) {\n+    return;\n+  }\n+\n+  for (i = 0; i < num_commands; ++i) {\n+    Command* cmd = &cmds[i];\n+    if (CommandCopyLen(cmd) && cmd->cmd_prefix_ >= 128) {\n+      PrefixEncodeCopyDistance(CommandRestoreDistanceCode(cmd, orig_params),\n+                               new_params->num_direct_distance_codes,\n+                               new_params->distance_postfix_bits,\n+                               &cmd->dist_prefix_,\n+                               &cmd->dist_extra_);\n+    }\n+  }\n+}\n+\n+static BROTLI_BOOL ComputeDistanceCost(const Command* cmds,\n+                                       size_t num_commands,\n+                                       const BrotliDistanceParams* orig_params,\n+                                       const BrotliDistanceParams* new_params,\n+                                       double* cost) {\n+  size_t i;\n+  BROTLI_BOOL equal_params = BROTLI_FALSE;\n+  uint16_t dist_prefix;\n+  uint32_t dist_extra;\n+  double extra_bits = 0.0;\n+  HistogramDistance histo;\n+  HistogramClearDistance(&histo);\n+\n+  if (orig_params->distance_postfix_bits == new_params->distance_postfix_bits &&\n+      orig_params->num_direct_distance_codes ==\n+      new_params->num_direct_distance_codes) {\n+    equal_params = BROTLI_TRUE;\n+  }\n+\n+  for (i = 0; i < num_commands; i++) {\n+    const Command* cmd = &cmds[i];\n+    if (CommandCopyLen(cmd) && cmd->cmd_prefix_ >= 128) {\n+      if (equal_params) {\n+        dist_prefix = cmd->dist_prefix_;\n+      } else {\n+        uint32_t distance = CommandRestoreDistanceCode(cmd, orig_params);\n+        if (distance > new_params->max_distance) {\n+          return BROTLI_FALSE;\n+        }\n+        PrefixEncodeCopyDistance(distance,\n+                                 new_params->num_direct_distance_codes,\n+                                 new_params->distance_postfix_bits,\n+                                 &dist_prefix,\n+                                 &dist_extra);\n+      }\n+      HistogramAddDistance(&histo, dist_prefix & 0x3FF);\n+      extra_bits += dist_prefix >> 10;\n+    }\n+  }\n+\n+  *cost = BrotliPopulationCostDistance(&histo) + extra_bits;\n+  return BROTLI_TRUE;\n+}\n+\n+void BrotliBuildMetaBlock(MemoryManager* m,\n+                          const uint8_t* ringbuffer,\n+                          const size_t pos,\n+                          const size_t mask,\n+                          BrotliEncoderParams* params,\n+                          uint8_t prev_byte,\n+                          uint8_t prev_byte2,\n+                          Command* cmds,\n+                          size_t num_commands,\n+                          ContextType literal_context_mode,\n+                          MetaBlockSplit* mb) {\n+  /* Histogram ids need to fit in one byte. */\n+  static const size_t kMaxNumberOfHistograms = 256;\n+  HistogramDistance* distance_histograms;\n+  HistogramLiteral* literal_histograms;\n+  ContextType* literal_context_modes = NULL;\n+  size_t literal_histograms_size;\n+  size_t distance_histograms_size;\n+  size_t i;\n+  size_t literal_context_multiplier = 1;\n+  uint32_t npostfix;\n+  uint32_t ndirect_msb = 0;\n+  BROTLI_BOOL check_orig = BROTLI_TRUE;\n+  double best_dist_cost = 1e99;\n+  BrotliEncoderParams orig_params = *params;\n+  BrotliEncoderParams new_params = *params;\n+\n+  for (npostfix = 0; npostfix <= BROTLI_MAX_NPOSTFIX; npostfix++) {\n+    for (; ndirect_msb < 16; ndirect_msb++) {\n+      uint32_t ndirect = ndirect_msb << npostfix;\n+      BROTLI_BOOL skip;\n+      double dist_cost;\n+      BrotliInitDistanceParams(&new_params, npostfix, ndirect);\n+      if (npostfix == orig_params.dist.distance_postfix_bits &&\n+          ndirect == orig_params.dist.num_direct_distance_codes) {\n+        check_orig = BROTLI_FALSE;\n+      }\n+      skip = !ComputeDistanceCost(\n+          cmds, num_commands,\n+          &orig_params.dist, &new_params.dist, &dist_cost);\n+      if (skip || (dist_cost > best_dist_cost)) {\n+        break;\n+      }\n+      best_dist_cost = dist_cost;\n+      params->dist = new_params.dist;\n+    }\n+    if (ndirect_msb > 0) ndirect_msb--;\n+    ndirect_msb /= 2;\n+  }\n+  if (check_orig) {\n+    double dist_cost;\n+    ComputeDistanceCost(cmds, num_commands,\n+                        &orig_params.dist, &orig_params.dist, &dist_cost);\n+    if (dist_cost < best_dist_cost) {\n+      /* NB: currently unused; uncomment when more param tuning is added. */\n+      /* best_dist_cost = dist_cost; */\n+      params->dist = orig_params.dist;\n+    }\n+  }\n+  RecomputeDistancePrefixes(cmds, num_commands,\n+                            &orig_params.dist, &params->dist);\n+\n+  BrotliSplitBlock(m, cmds, num_commands,\n+                   ringbuffer, pos, mask, params,\n+                   &mb->literal_split,\n+                   &mb->command_split,\n+                   &mb->distance_split);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  if (!params->disable_literal_context_modeling) {\n+    literal_context_multiplier = 1 << BROTLI_LITERAL_CONTEXT_BITS;\n+    literal_context_modes =\n+        BROTLI_ALLOC(m, ContextType, mb->literal_split.num_types);\n+    if (BROTLI_IS_OOM(m)) return;\n+    for (i = 0; i < mb->literal_split.num_types; ++i) {\n+      literal_context_modes[i] = literal_context_mode;\n+    }\n+  }\n+\n+  literal_histograms_size =\n+      mb->literal_split.num_types * literal_context_multiplier;\n+  literal_histograms =\n+      BROTLI_ALLOC(m, HistogramLiteral, literal_histograms_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+  ClearHistogramsLiteral(literal_histograms, literal_histograms_size);\n+\n+  distance_histograms_size =\n+      mb->distance_split.num_types << BROTLI_DISTANCE_CONTEXT_BITS;\n+  distance_histograms =\n+      BROTLI_ALLOC(m, HistogramDistance, distance_histograms_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+  ClearHistogramsDistance(distance_histograms, distance_histograms_size);\n+\n+  BROTLI_DCHECK(mb->command_histograms == 0);\n+  mb->command_histograms_size = mb->command_split.num_types;\n+  mb->command_histograms =\n+      BROTLI_ALLOC(m, HistogramCommand, mb->command_histograms_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+  ClearHistogramsCommand(mb->command_histograms, mb->command_histograms_size);\n+\n+  BrotliBuildHistogramsWithContext(cmds, num_commands,\n+      &mb->literal_split, &mb->command_split, &mb->distance_split,\n+      ringbuffer, pos, mask, prev_byte, prev_byte2, literal_context_modes,\n+      literal_histograms, mb->command_histograms, distance_histograms);\n+  BROTLI_FREE(m, literal_context_modes);\n+\n+  BROTLI_DCHECK(mb->literal_context_map == 0);\n+  mb->literal_context_map_size =\n+      mb->literal_split.num_types << BROTLI_LITERAL_CONTEXT_BITS;\n+  mb->literal_context_map =\n+      BROTLI_ALLOC(m, uint32_t, mb->literal_context_map_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  BROTLI_DCHECK(mb->literal_histograms == 0);\n+  mb->literal_histograms_size = mb->literal_context_map_size;\n+  mb->literal_histograms =\n+      BROTLI_ALLOC(m, HistogramLiteral, mb->literal_histograms_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  BrotliClusterHistogramsLiteral(m, literal_histograms, literal_histograms_size,\n+      kMaxNumberOfHistograms, mb->literal_histograms,\n+      &mb->literal_histograms_size, mb->literal_context_map);\n+  if (BROTLI_IS_OOM(m)) return;\n+  BROTLI_FREE(m, literal_histograms);\n+\n+  if (params->disable_literal_context_modeling) {\n+    /* Distribute assignment to all contexts. */\n+    for (i = mb->literal_split.num_types; i != 0;) {\n+      size_t j = 0;\n+      i--;\n+      for (; j < (1 << BROTLI_LITERAL_CONTEXT_BITS); j++) {\n+        mb->literal_context_map[(i << BROTLI_LITERAL_CONTEXT_BITS) + j] =\n+            mb->literal_context_map[i];\n+      }\n+    }\n+  }\n+\n+  BROTLI_DCHECK(mb->distance_context_map == 0);\n+  mb->distance_context_map_size =\n+      mb->distance_split.num_types << BROTLI_DISTANCE_CONTEXT_BITS;\n+  mb->distance_context_map =\n+      BROTLI_ALLOC(m, uint32_t, mb->distance_context_map_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  BROTLI_DCHECK(mb->distance_histograms == 0);\n+  mb->distance_histograms_size = mb->distance_context_map_size;\n+  mb->distance_histograms =\n+      BROTLI_ALLOC(m, HistogramDistance, mb->distance_histograms_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  BrotliClusterHistogramsDistance(m, distance_histograms,\n+                                  mb->distance_context_map_size,\n+                                  kMaxNumberOfHistograms,\n+                                  mb->distance_histograms,\n+                                  &mb->distance_histograms_size,\n+                                  mb->distance_context_map);\n+  if (BROTLI_IS_OOM(m)) return;\n+  BROTLI_FREE(m, distance_histograms);\n+}\n+\n+#define FN(X) X ## Literal\n+#include \"./metablock_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#define FN(X) X ## Command\n+#include \"./metablock_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#define FN(X) X ## Distance\n+#include \"./metablock_inc.h\"  /* NOLINT(build/include) */\n+#undef FN\n+\n+#define BROTLI_MAX_STATIC_CONTEXTS 13\n+\n+/* Greedy block splitter for one block category (literal, command or distance).\n+   Gathers histograms for all context buckets. */\n+typedef struct ContextBlockSplitter {\n+  /* Alphabet size of particular block category. */\n+  size_t alphabet_size_;\n+  size_t num_contexts_;\n+  size_t max_block_types_;\n+  /* We collect at least this many symbols for each block. */\n+  size_t min_block_size_;\n+  /* We merge histograms A and B if\n+       entropy(A+B) < entropy(A) + entropy(B) + split_threshold_,\n+     where A is the current histogram and B is the histogram of the last or the\n+     second last block type. */\n+  double split_threshold_;\n+\n+  size_t num_blocks_;\n+  BlockSplit* split_;  /* not owned */\n+  HistogramLiteral* histograms_;  /* not owned */\n+  size_t* histograms_size_;  /* not owned */\n+\n+  /* The number of symbols that we want to collect before deciding on whether\n+     or not to merge the block with a previous one or emit a new block. */\n+  size_t target_block_size_;\n+  /* The number of symbols in the current histogram. */\n+  size_t block_size_;\n+  /* Offset of the current histogram. */\n+  size_t curr_histogram_ix_;\n+  /* Offset of the histograms of the previous two block types. */\n+  size_t last_histogram_ix_[2];\n+  /* Entropy of the previous two block types. */\n+  double last_entropy_[2 * BROTLI_MAX_STATIC_CONTEXTS];\n+  /* The number of times we merged the current block with the last one. */\n+  size_t merge_last_count_;\n+} ContextBlockSplitter;\n+\n+static void InitContextBlockSplitter(\n+    MemoryManager* m, ContextBlockSplitter* self, size_t alphabet_size,\n+    size_t num_contexts, size_t min_block_size, double split_threshold,\n+    size_t num_symbols, BlockSplit* split, HistogramLiteral** histograms,\n+    size_t* histograms_size) {\n+  size_t max_num_blocks = num_symbols / min_block_size + 1;\n+  size_t max_num_types;\n+  BROTLI_DCHECK(num_contexts <= BROTLI_MAX_STATIC_CONTEXTS);\n+\n+  self->alphabet_size_ = alphabet_size;\n+  self->num_contexts_ = num_contexts;\n+  self->max_block_types_ = BROTLI_MAX_NUMBER_OF_BLOCK_TYPES / num_contexts;\n+  self->min_block_size_ = min_block_size;\n+  self->split_threshold_ = split_threshold;\n+  self->num_blocks_ = 0;\n+  self->split_ = split;\n+  self->histograms_size_ = histograms_size;\n+  self->target_block_size_ = min_block_size;\n+  self->block_size_ = 0;\n+  self->curr_histogram_ix_ = 0;\n+  self->merge_last_count_ = 0;\n+\n+  /* We have to allocate one more histogram than the maximum number of block\n+     types for the current histogram when the meta-block is too big. */\n+  max_num_types =\n+      BROTLI_MIN(size_t, max_num_blocks, self->max_block_types_ + 1);\n+  BROTLI_ENSURE_CAPACITY(m, uint8_t,\n+      split->types, split->types_alloc_size, max_num_blocks);\n+  BROTLI_ENSURE_CAPACITY(m, uint32_t,\n+      split->lengths, split->lengths_alloc_size, max_num_blocks);\n+  if (BROTLI_IS_OOM(m)) return;\n+  split->num_blocks = max_num_blocks;\n+  if (BROTLI_IS_OOM(m)) return;\n+  BROTLI_DCHECK(*histograms == 0);\n+  *histograms_size = max_num_types * num_contexts;\n+  *histograms = BROTLI_ALLOC(m, HistogramLiteral, *histograms_size);\n+  self->histograms_ = *histograms;\n+  if (BROTLI_IS_OOM(m)) return;\n+  /* Clear only current histogram. */\n+  ClearHistogramsLiteral(&self->histograms_[0], num_contexts);\n+  self->last_histogram_ix_[0] = self->last_histogram_ix_[1] = 0;\n+}\n+\n+/* Does either of three things:\n+     (1) emits the current block with a new block type;\n+     (2) emits the current block with the type of the second last block;\n+     (3) merges the current block with the last block. */\n+static void ContextBlockSplitterFinishBlock(\n+    ContextBlockSplitter* self, MemoryManager* m, BROTLI_BOOL is_final) {\n+  BlockSplit* split = self->split_;\n+  const size_t num_contexts = self->num_contexts_;\n+  double* last_entropy = self->last_entropy_;\n+  HistogramLiteral* histograms = self->histograms_;\n+\n+  if (self->block_size_ < self->min_block_size_) {\n+    self->block_size_ = self->min_block_size_;\n+  }\n+  if (self->num_blocks_ == 0) {\n+    size_t i;\n+    /* Create first block. */\n+    split->lengths[0] = (uint32_t)self->block_size_;\n+    split->types[0] = 0;\n+\n+    for (i = 0; i < num_contexts; ++i) {\n+      last_entropy[i] =\n+          BitsEntropy(histograms[i].data_, self->alphabet_size_);\n+      last_entropy[num_contexts + i] = last_entropy[i];\n+    }\n+    ++self->num_blocks_;\n+    ++split->num_types;\n+    self->curr_histogram_ix_ += num_contexts;\n+    if (self->curr_histogram_ix_ < *self->histograms_size_) {\n+      ClearHistogramsLiteral(\n+          &self->histograms_[self->curr_histogram_ix_], self->num_contexts_);\n+    }\n+    self->block_size_ = 0;\n+  } else if (self->block_size_ > 0) {\n+    /* Try merging the set of histograms for the current block type with the\n+       respective set of histograms for the last and second last block types.\n+       Decide over the split based on the total reduction of entropy across\n+       all contexts. */\n+    double entropy[BROTLI_MAX_STATIC_CONTEXTS];\n+    HistogramLiteral* combined_histo =\n+        BROTLI_ALLOC(m, HistogramLiteral, 2 * num_contexts);\n+    double combined_entropy[2 * BROTLI_MAX_STATIC_CONTEXTS];\n+    double diff[2] = { 0.0 };\n+    size_t i;\n+    if (BROTLI_IS_OOM(m)) return;\n+    for (i = 0; i < num_contexts; ++i) {\n+      size_t curr_histo_ix = self->curr_histogram_ix_ + i;\n+      size_t j;\n+      entropy[i] = BitsEntropy(histograms[curr_histo_ix].data_,\n+                               self->alphabet_size_);\n+      for (j = 0; j < 2; ++j) {\n+        size_t jx = j * num_contexts + i;\n+        size_t last_histogram_ix = self->last_histogram_ix_[j] + i;\n+        combined_histo[jx] = histograms[curr_histo_ix];\n+        HistogramAddHistogramLiteral(&combined_histo[jx],\n+            &histograms[last_histogram_ix]);\n+        combined_entropy[jx] = BitsEntropy(\n+            &combined_histo[jx].data_[0], self->alphabet_size_);\n+        diff[j] += combined_entropy[jx] - entropy[i] - last_entropy[jx];\n+      }\n+    }\n+\n+    if (split->num_types < self->max_block_types_ &&\n+        diff[0] > self->split_threshold_ &&\n+        diff[1] > self->split_threshold_) {\n+      /* Create new block. */\n+      split->lengths[self->num_blocks_] = (uint32_t)self->block_size_;\n+      split->types[self->num_blocks_] = (uint8_t)split->num_types;\n+      self->last_histogram_ix_[1] = self->last_histogram_ix_[0];\n+      self->last_histogram_ix_[0] = split->num_types * num_contexts;\n+      for (i = 0; i < num_contexts; ++i) {\n+        last_entropy[num_contexts + i] = last_entropy[i];\n+        last_entropy[i] = entropy[i];\n+      }\n+      ++self->num_blocks_;\n+      ++split->num_types;\n+      self->curr_histogram_ix_ += num_contexts;\n+      if (self->curr_histogram_ix_ < *self->histograms_size_) {\n+        ClearHistogramsLiteral(\n+            &self->histograms_[self->curr_histogram_ix_], self->num_contexts_);\n+      }\n+      self->block_size_ = 0;\n+      self->merge_last_count_ = 0;\n+      self->target_block_size_ = self->min_block_size_;\n+    } else if (diff[1] < diff[0] - 20.0) {\n+      /* Combine this block with second last block. */\n+      split->lengths[self->num_blocks_] = (uint32_t)self->block_size_;\n+      split->types[self->num_blocks_] = split->types[self->num_blocks_ - 2];\n+      BROTLI_SWAP(size_t, self->last_histogram_ix_, 0, 1);\n+      for (i = 0; i < num_contexts; ++i) {\n+        histograms[self->last_histogram_ix_[0] + i] =\n+            combined_histo[num_contexts + i];\n+        last_entropy[num_contexts + i] = last_entropy[i];\n+        last_entropy[i] = combined_entropy[num_contexts + i];\n+        HistogramClearLiteral(&histograms[self->curr_histogram_ix_ + i]);\n+      }\n+      ++self->num_blocks_;\n+      self->block_size_ = 0;\n+      self->merge_last_count_ = 0;\n+      self->target_block_size_ = self->min_block_size_;\n+    } else {\n+      /* Combine this block with last block. */\n+      split->lengths[self->num_blocks_ - 1] += (uint32_t)self->block_size_;\n+      for (i = 0; i < num_contexts; ++i) {\n+        histograms[self->last_histogram_ix_[0] + i] = combined_histo[i];\n+        last_entropy[i] = combined_entropy[i];\n+        if (split->num_types == 1) {\n+          last_entropy[num_contexts + i] = last_entropy[i];\n+        }\n+        HistogramClearLiteral(&histograms[self->curr_histogram_ix_ + i]);\n+      }\n+      self->block_size_ = 0;\n+      if (++self->merge_last_count_ > 1) {\n+        self->target_block_size_ += self->min_block_size_;\n+      }\n+    }\n+    BROTLI_FREE(m, combined_histo);\n+  }\n+  if (is_final) {\n+    *self->histograms_size_ = split->num_types * num_contexts;\n+    split->num_blocks = self->num_blocks_;\n+  }\n+}\n+\n+/* Adds the next symbol to the current block type and context. When the\n+   current block reaches the target size, decides on merging the block. */\n+static void ContextBlockSplitterAddSymbol(\n+    ContextBlockSplitter* self, MemoryManager* m,\n+    size_t symbol, size_t context) {\n+  HistogramAddLiteral(&self->histograms_[self->curr_histogram_ix_ + context],\n+      symbol);\n+  ++self->block_size_;\n+  if (self->block_size_ == self->target_block_size_) {\n+    ContextBlockSplitterFinishBlock(self, m, /* is_final = */ BROTLI_FALSE);\n+    if (BROTLI_IS_OOM(m)) return;\n+  }\n+}\n+\n+static void MapStaticContexts(MemoryManager* m,\n+                              size_t num_contexts,\n+                              const uint32_t* static_context_map,\n+                              MetaBlockSplit* mb) {\n+  size_t i;\n+  BROTLI_DCHECK(mb->literal_context_map == 0);\n+  mb->literal_context_map_size =\n+      mb->literal_split.num_types << BROTLI_LITERAL_CONTEXT_BITS;\n+  mb->literal_context_map =\n+      BROTLI_ALLOC(m, uint32_t, mb->literal_context_map_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  for (i = 0; i < mb->literal_split.num_types; ++i) {\n+    uint32_t offset = (uint32_t)(i * num_contexts);\n+    size_t j;\n+    for (j = 0; j < (1u << BROTLI_LITERAL_CONTEXT_BITS); ++j) {\n+      mb->literal_context_map[(i << BROTLI_LITERAL_CONTEXT_BITS) + j] =\n+          offset + static_context_map[j];\n+    }\n+  }\n+}\n+\n+static BROTLI_INLINE void BrotliBuildMetaBlockGreedyInternal(\n+    MemoryManager* m, const uint8_t* ringbuffer, size_t pos, size_t mask,\n+    uint8_t prev_byte, uint8_t prev_byte2, ContextLut literal_context_lut,\n+    const size_t num_contexts, const uint32_t* static_context_map,\n+    const Command* commands, size_t n_commands, MetaBlockSplit* mb) {\n+  union {\n+    BlockSplitterLiteral plain;\n+    ContextBlockSplitter ctx;\n+  } lit_blocks;\n+  BlockSplitterCommand cmd_blocks;\n+  BlockSplitterDistance dist_blocks;\n+  size_t num_literals = 0;\n+  size_t i;\n+  for (i = 0; i < n_commands; ++i) {\n+    num_literals += commands[i].insert_len_;\n+  }\n+\n+  if (num_contexts == 1) {\n+    InitBlockSplitterLiteral(m, &lit_blocks.plain, 256, 512, 400.0,\n+        num_literals, &mb->literal_split, &mb->literal_histograms,\n+        &mb->literal_histograms_size);\n+  } else {\n+    InitContextBlockSplitter(m, &lit_blocks.ctx, 256, num_contexts, 512, 400.0,\n+        num_literals, &mb->literal_split, &mb->literal_histograms,\n+        &mb->literal_histograms_size);\n+  }\n+  if (BROTLI_IS_OOM(m)) return;\n+  InitBlockSplitterCommand(m, &cmd_blocks, BROTLI_NUM_COMMAND_SYMBOLS, 1024,\n+      500.0, n_commands, &mb->command_split, &mb->command_histograms,\n+      &mb->command_histograms_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+  InitBlockSplitterDistance(m, &dist_blocks, 64, 512, 100.0, n_commands,\n+      &mb->distance_split, &mb->distance_histograms,\n+      &mb->distance_histograms_size);\n+  if (BROTLI_IS_OOM(m)) return;\n+\n+  for (i = 0; i < n_commands; ++i) {\n+    const Command cmd = commands[i];\n+    size_t j;\n+    BlockSplitterAddSymbolCommand(&cmd_blocks, cmd.cmd_prefix_);\n+    for (j = cmd.insert_len_; j != 0; --j) {\n+      uint8_t literal = ringbuffer[pos & mask];\n+      if (num_contexts == 1) {\n+        BlockSplitterAddSymbolLiteral(&lit_blocks.plain, literal);\n+      } else {\n+        size_t context =\n+            BROTLI_CONTEXT(prev_byte, prev_byte2, literal_context_lut);\n+        ContextBlockSplitterAddSymbol(&lit_blocks.ctx, m, literal,\n+                                      static_context_map[context]);\n+        if (BROTLI_IS_OOM(m)) return;\n+      }\n+      prev_byte2 = prev_byte;\n+      prev_byte = literal;\n+      ++pos;\n+    }\n+    pos += CommandCopyLen(&cmd);\n+    if (CommandCopyLen(&cmd)) {\n+      prev_byte2 = ringbuffer[(pos - 2) & mask];\n+      prev_byte = ringbuffer[(pos - 1) & mask];\n+      if (cmd.cmd_prefix_ >= 128) {\n+        BlockSplitterAddSymbolDistance(&dist_blocks, cmd.dist_prefix_ & 0x3FF);\n+      }\n+    }\n+  }\n+\n+  if (num_contexts == 1) {\n+    BlockSplitterFinishBlockLiteral(\n+        &lit_blocks.plain, /* is_final = */ BROTLI_TRUE);\n+  } else {\n+    ContextBlockSplitterFinishBlock(\n+        &lit_blocks.ctx, m, /* is_final = */ BROTLI_TRUE);\n+    if (BROTLI_IS_OOM(m)) return;\n+  }\n+  BlockSplitterFinishBlockCommand(&cmd_blocks, /* is_final = */ BROTLI_TRUE);\n+  BlockSplitterFinishBlockDistance(&dist_blocks, /* is_final = */ BROTLI_TRUE);\n+\n+  if (num_contexts > 1) {\n+    MapStaticContexts(m, num_contexts, static_context_map, mb);\n+  }\n+}\n+\n+void BrotliBuildMetaBlockGreedy(MemoryManager* m,\n+                                const uint8_t* ringbuffer,\n+                                size_t pos,\n+                                size_t mask,\n+                                uint8_t prev_byte,\n+                                uint8_t prev_byte2,\n+                                ContextLut literal_context_lut,\n+                                size_t num_contexts,\n+                                const uint32_t* static_context_map,\n+                                const Command* commands,\n+                                size_t n_commands,\n+                                MetaBlockSplit* mb) {\n+  if (num_contexts == 1) {\n+    BrotliBuildMetaBlockGreedyInternal(m, ringbuffer, pos, mask, prev_byte,\n+        prev_byte2, literal_context_lut, 1, NULL, commands, n_commands, mb);\n+  } else {\n+    BrotliBuildMetaBlockGreedyInternal(m, ringbuffer, pos, mask, prev_byte,\n+        prev_byte2, literal_context_lut, num_contexts, static_context_map,\n+        commands, n_commands, mb);\n+  }\n+}\n+\n+void BrotliOptimizeHistograms(uint32_t num_distance_codes,\n+                              MetaBlockSplit* mb) {\n+  uint8_t good_for_rle[BROTLI_NUM_COMMAND_SYMBOLS];\n+  size_t i;\n+  for (i = 0; i < mb->literal_histograms_size; ++i) {\n+    BrotliOptimizeHuffmanCountsForRle(256, mb->literal_histograms[i].data_,\n+                                      good_for_rle);\n+  }\n+  for (i = 0; i < mb->command_histograms_size; ++i) {\n+    BrotliOptimizeHuffmanCountsForRle(BROTLI_NUM_COMMAND_SYMBOLS,\n+                                      mb->command_histograms[i].data_,\n+                                      good_for_rle);\n+  }\n+  for (i = 0; i < mb->distance_histograms_size; ++i) {\n+    BrotliOptimizeHuffmanCountsForRle(num_distance_codes,\n+                                      mb->distance_histograms[i].data_,\n+                                      good_for_rle);\n+  }\n+}\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif"
        },
        {
            "sha": "334a79a443c57dda25ba00c2f42619f1545173cc",
            "filename": "deps/brotli/c/enc/metablock.h",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmetablock.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmetablock.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fmetablock.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a",
            "patch": "@@ -0,0 +1,105 @@\n+/* Copyright 2015 Google Inc. All Rights Reserved.\n+\n+   Distributed under MIT license.\n+   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n+*/\n+\n+/* Algorithms for distributing the literals and commands of a metablock between\n+   block types and contexts. */\n+\n+#ifndef BROTLI_ENC_METABLOCK_H_\n+#define BROTLI_ENC_METABLOCK_H_\n+\n+#include \"../common/context.h\"\n+#include \"../common/platform.h\"\n+#include <brotli/types.h>\n+#include \"./block_splitter.h\"\n+#include \"./command.h\"\n+#include \"./histogram.h\"\n+#include \"./memory.h\"\n+#include \"./quality.h\"\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+extern \"C\" {\n+#endif\n+\n+typedef struct MetaBlockSplit {\n+  BlockSplit literal_split;\n+  BlockSplit command_split;\n+  BlockSplit distance_split;\n+  uint32_t* literal_context_map;\n+  size_t literal_context_map_size;\n+  uint32_t* distance_context_map;\n+  size_t distance_context_map_size;\n+  HistogramLiteral* literal_histograms;\n+  size_t literal_histograms_size;\n+  HistogramCommand* command_histograms;\n+  size_t command_histograms_size;\n+  HistogramDistance* distance_histograms;\n+  size_t distance_histograms_size;\n+} MetaBlockSplit;\n+\n+static BROTLI_INLINE void InitMetaBlockSplit(MetaBlockSplit* mb) {\n+  BrotliInitBlockSplit(&mb->literal_split);\n+  BrotliInitBlockSplit(&mb->command_split);\n+  BrotliInitBlockSplit(&mb->distance_split);\n+  mb->literal_context_map = 0;\n+  mb->literal_context_map_size = 0;\n+  mb->distance_context_map = 0;\n+  mb->distance_context_map_size = 0;\n+  mb->literal_histograms = 0;\n+  mb->literal_histograms_size = 0;\n+  mb->command_histograms = 0;\n+  mb->command_histograms_size = 0;\n+  mb->distance_histograms = 0;\n+  mb->distance_histograms_size = 0;\n+}\n+\n+static BROTLI_INLINE void DestroyMetaBlockSplit(\n+    MemoryManager* m, MetaBlockSplit* mb) {\n+  BrotliDestroyBlockSplit(m, &mb->literal_split);\n+  BrotliDestroyBlockSplit(m, &mb->command_split);\n+  BrotliDestroyBlockSplit(m, &mb->distance_split);\n+  BROTLI_FREE(m, mb->literal_context_map);\n+  BROTLI_FREE(m, mb->distance_context_map);\n+  BROTLI_FREE(m, mb->literal_histograms);\n+  BROTLI_FREE(m, mb->command_histograms);\n+  BROTLI_FREE(m, mb->distance_histograms);\n+}\n+\n+/* Uses the slow shortest-path block splitter and does context clustering.\n+   The distance parameters are dynamically selected based on the commands\n+   which get recomputed under the new distance parameters. The new distance\n+   parameters are stored into *params. */\n+BROTLI_INTERNAL void BrotliBuildMetaBlock(MemoryManager* m,\n+                                          const uint8_t* ringbuffer,\n+                                          const size_t pos,\n+                                          const size_t mask,\n+                                          BrotliEncoderParams* params,\n+                                          uint8_t prev_byte,\n+                                          uint8_t prev_byte2,\n+                                          Command* cmds,\n+                                          size_t num_commands,\n+                                          ContextType literal_context_mode,\n+                                          MetaBlockSplit* mb);\n+\n+/* Uses a fast greedy block splitter that tries to merge current block with the\n+   last or the second last block and uses a static context clustering which\n+   is the same for all block types. */\n+BROTLI_INTERNAL void BrotliBuildMetaBlockGreedy(\n+    MemoryManager* m, const uint8_t* ringbuffer, size_t pos, size_t mask,\n+    uint8_t prev_byte, uint8_t prev_byte2, ContextLut literal_context_lut,\n+    size_t num_contexts, const uint32_t* static_context_map,\n+    const Command* commands, size_t n_commands, MetaBlockSplit* mb);\n+\n+BROTLI_INTERNAL void BrotliOptimizeHistograms(uint32_t num_distance_codes,\n+                                              MetaBlockSplit* mb);\n+\n+BROTLI_INTERNAL void BrotliInitDistanceParams(BrotliEncoderParams* params,\n+    uint32_t npostfix, uint32_t ndirect);\n+\n+#if defined(__cplusplus) || defined(c_plusplus)\n+}  /* extern \"C\" */\n+#endif\n+\n+#endif  /* BROTLI_ENC_METABLOCK_H_ */"
        },
        {
            "sha": "dcc9d3c4a642c529509bffdfd30d5f4bc4820a8a",
            "filename": "deps/brotli/c/enc/metablock_inc.h",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmetablock_inc.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fmetablock_inc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fmetablock_inc.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "6ecf1d3f995d2f58a7766faf27169ee44ae64fa0",
            "filename": "deps/brotli/c/enc/params.h",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fparams.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fparams.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fparams.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "fd359a478d4a14cae9f361804ba8e15b5c1b3f40",
            "filename": "deps/brotli/c/enc/prefix.h",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fprefix.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fprefix.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fprefix.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "5f4d0345037d2b31b60e2b036be7f539da7ed58f",
            "filename": "deps/brotli/c/enc/quality.h",
            "status": "added",
            "additions": 165,
            "deletions": 0,
            "changes": 165,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fquality.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fquality.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fquality.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "86079a89d35b9abfedd33a42dd34b964fb930ce7",
            "filename": "deps/brotli/c/enc/ringbuffer.h",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fringbuffer.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fringbuffer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fringbuffer.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "7299ab7203b340afde0bb276afac01fb8de1b657",
            "filename": "deps/brotli/c/enc/static_dict.c",
            "status": "added",
            "additions": 486,
            "deletions": 0,
            "changes": 486,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fstatic_dict.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fstatic_dict.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fstatic_dict.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "6b5d4eb0c989067ed8995f9523311792b0a3a551",
            "filename": "deps/brotli/c/enc/static_dict.h",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fstatic_dict.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fstatic_dict.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fstatic_dict.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "e299cda6d82b0ce456227e73a5ee269533da9085",
            "filename": "deps/brotli/c/enc/static_dict_lut.h",
            "status": "added",
            "additions": 5864,
            "deletions": 0,
            "changes": 5864,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fstatic_dict_lut.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fstatic_dict_lut.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fstatic_dict_lut.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "04a7805161b87db8fe7cf0c8ab92702c95e13e20",
            "filename": "deps/brotli/c/enc/utf8_util.c",
            "status": "added",
            "additions": 85,
            "deletions": 0,
            "changes": 85,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Futf8_util.c",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Futf8_util.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Futf8_util.c?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "8fda80c220395806cf5768165b40f42b34279a9d",
            "filename": "deps/brotli/c/enc/utf8_util.h",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Futf8_util.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Futf8_util.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Futf8_util.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "36515a6893f8cb813a37fce8a811cce70098e0c0",
            "filename": "deps/brotli/c/enc/write_bits.h",
            "status": "added",
            "additions": 85,
            "deletions": 0,
            "changes": 85,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fwrite_bits.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Fenc%2Fwrite_bits.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Fenc%2Fwrite_bits.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "0f5c8f9d111701c66b483f844b310d74af11c20c",
            "filename": "deps/brotli/c/include/brotli/decode.h",
            "status": "added",
            "additions": 344,
            "deletions": 0,
            "changes": 344,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Fdecode.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Fdecode.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Fdecode.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "0ced7e55be77458f96e5aad04b26c8c67a13e6d2",
            "filename": "deps/brotli/c/include/brotli/encode.h",
            "status": "added",
            "additions": 427,
            "deletions": 0,
            "changes": 427,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Fencode.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Fencode.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Fencode.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "20dc2314d8021b6eee18a5d6b4ea11560f0ecfb1",
            "filename": "deps/brotli/c/include/brotli/port.h",
            "status": "added",
            "additions": 274,
            "deletions": 0,
            "changes": 274,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Fport.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Fport.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Fport.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        },
        {
            "sha": "eff1a3cd07aefe5020035ef491dd42b75de48a2e",
            "filename": "deps/brotli/c/include/brotli/types.h",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Ftypes.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Ftypes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fbrotli%2Fc%2Finclude%2Fbrotli%2Ftypes.h?ref=a3f3cfc7c52cb553d9f152bfb1ce306bbd50ba5a"
        }
    ],
    "stats": {
        "total": 34434,
        "additions": 34434,
        "deletions": 0
    }
}