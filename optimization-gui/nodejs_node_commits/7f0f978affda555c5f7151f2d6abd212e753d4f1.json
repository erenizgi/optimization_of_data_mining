{
    "author": "jasnell",
    "message": "fs: refactor fs module\n\nPR-URL: https://github.com/nodejs/node/pull/20764\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "7f0f978affda555c5f7151f2d6abd212e753d4f1",
    "files": [
        {
            "sha": "221f79ae0bcdd5314593166bc47ee1fd68a23562",
            "filename": "lib/fs.js",
            "status": "modified",
            "additions": 430,
            "deletions": 952,
            "changes": 1382,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Ffs.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Ffs.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ffs.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -36,29 +36,22 @@ const {\n   W_OK,\n   X_OK,\n   O_WRONLY,\n-  O_SYMLINK,\n-  UV_FS_COPYFILE_EXCL,\n-  UV_FS_COPYFILE_FICLONE,\n-  UV_FS_COPYFILE_FICLONE_FORCE\n+  O_SYMLINK\n } = constants;\n-const util = require('util');\n+\n+const { _extend } = require('util');\n const pathModule = require('path');\n const { isUint8Array } = require('internal/util/types');\n-\n const binding = process.binding('fs');\n-const fs = exports;\n const { Buffer, kMaxLength } = require('buffer');\n const errors = require('internal/errors');\n const {\n   ERR_FS_FILE_TOO_LARGE,\n   ERR_INVALID_ARG_TYPE,\n-  ERR_INVALID_CALLBACK,\n-  ERR_OUT_OF_RANGE\n+  ERR_INVALID_CALLBACK\n } = errors.codes;\n-const { Readable, Writable } = require('stream');\n-const EventEmitter = require('events');\n-const { FSReqWrap, statValues, kFsStatsFieldsLength } = binding;\n-const { FSEvent } = process.binding('fs_event_wrap');\n+\n+const { FSReqWrap, statValues } = binding;\n const internalFS = require('internal/fs/utils');\n const { getPathFromURL } = require('internal/url');\n const internalUtil = require('internal/util');\n@@ -89,44 +82,24 @@ const {\n   validateUint32\n } = require('internal/validators');\n \n-// Lazy loaded\n-let promises;\n-\n let promisesWarn = true;\n+let truncateWarn = true;\n+let fs;\n \n-Object.defineProperty(fs, 'promises', {\n-  configurable: true,\n-  enumerable: false,\n-  get() {\n-    if (promisesWarn) {\n-      promises = require('internal/fs/promises');\n-      promisesWarn = false;\n-      process.emitWarning('The fs.promises API is experimental',\n-                          'ExperimentalWarning');\n-    }\n-    return promises;\n-  }\n-});\n-\n-Object.defineProperty(exports, 'constants', {\n-  configurable: false,\n-  enumerable: true,\n-  value: constants\n-});\n-\n-let assert_ = null;\n-function lazyAssert() {\n-  if (assert_ === null) {\n-    assert_ = require('assert');\n-  }\n-  return assert_;\n-}\n+// Lazy loaded\n+let promises;\n+let watchers;\n+let ReadFileContext;\n+let ReadStream;\n+let WriteStream;\n \n-const kMinPoolSpace = 128;\n+// These have to be separate because of how graceful-fs happens to do it's\n+// monkeypatching.\n+let FileReadStream;\n+let FileWriteStream;\n \n const isWindows = process.platform === 'win32';\n \n-let truncateWarn = true;\n \n function showTruncateDeprecation() {\n   if (truncateWarn) {\n@@ -188,23 +161,13 @@ function makeStatsCallback(cb) {\n \n const isFd = isUint32;\n \n-fs.Stats = Stats;\n-\n function isFileType(stats, fileType) {\n   // Use stats array directly to avoid creating an fs.Stats instance just for\n   // our internal use.\n   return (stats[1/* mode */] & S_IFMT) === fileType;\n }\n \n-// Don't allow mode to accidentally be overwritten.\n-Object.defineProperties(fs, {\n-  F_OK: { enumerable: true, value: F_OK || 0 },\n-  R_OK: { enumerable: true, value: R_OK || 0 },\n-  W_OK: { enumerable: true, value: W_OK || 0 },\n-  X_OK: { enumerable: true, value: X_OK || 0 },\n-});\n-\n-fs.access = function(path, mode, callback) {\n+function access(path, mode, callback) {\n   if (typeof mode === 'function') {\n     callback = mode;\n     mode = F_OK;\n@@ -214,12 +177,12 @@ fs.access = function(path, mode, callback) {\n   validatePath(path);\n \n   mode = mode | 0;\n-  var req = new FSReqWrap();\n+  const req = new FSReqWrap();\n   req.oncomplete = makeCallback(callback);\n   binding.access(pathModule.toNamespacedPath(path), mode, req);\n-};\n+}\n \n-fs.accessSync = function(path, mode) {\n+function accessSync(path, mode) {\n   path = getPathFromURL(path);\n   validatePath(path);\n \n@@ -231,9 +194,9 @@ fs.accessSync = function(path, mode) {\n   const ctx = { path };\n   binding.access(pathModule.toNamespacedPath(path), mode, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.exists = function(path, callback) {\n+function exists(path, callback) {\n   maybeCallback(callback);\n \n   function suppressedCallback(err) {\n@@ -245,9 +208,9 @@ fs.exists = function(path, callback) {\n   } catch (err) {\n     return callback(false);\n   }\n-};\n+}\n \n-Object.defineProperty(fs.exists, internalUtil.promisify.custom, {\n+Object.defineProperty(exists, internalUtil.promisify.custom, {\n   value: (path) => {\n     const { createPromise, promiseResolve } = process.binding('util');\n     const promise = createPromise();\n@@ -262,93 +225,17 @@ Object.defineProperty(fs.exists, internalUtil.promisify.custom, {\n // fs.existsSync(), would only get a false in return, so we cannot signal\n // validation errors to users properly out of compatibility concerns.\n // TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n-fs.existsSync = function(path) {\n+function existsSync(path) {\n   try {\n     fs.accessSync(path, F_OK);\n     return true;\n   } catch (e) {\n     return false;\n   }\n-};\n-\n-fs.readFile = function(path, options, callback) {\n-  callback = maybeCallback(callback || options);\n-  options = getOptions(options, { flag: 'r' });\n-  var context = new ReadFileContext(callback, options.encoding);\n-  context.isUserFd = isFd(path); // file descriptor ownership\n-  var req = new FSReqWrap();\n-  req.context = context;\n-  req.oncomplete = readFileAfterOpen;\n-\n-  if (context.isUserFd) {\n-    process.nextTick(function tick() {\n-      req.oncomplete(null, path);\n-    });\n-    return;\n-  }\n-\n-  path = getPathFromURL(path);\n-  validatePath(path);\n-  binding.open(pathModule.toNamespacedPath(path),\n-               stringToFlags(options.flag || 'r'),\n-               0o666,\n-               req);\n-};\n-\n-const kReadFileBufferLength = 8 * 1024;\n-\n-function ReadFileContext(callback, encoding) {\n-  this.fd = undefined;\n-  this.isUserFd = undefined;\n-  this.size = undefined;\n-  this.callback = callback;\n-  this.buffers = null;\n-  this.buffer = null;\n-  this.pos = 0;\n-  this.encoding = encoding;\n-  this.err = null;\n-}\n-\n-ReadFileContext.prototype.read = function() {\n-  var buffer;\n-  var offset;\n-  var length;\n-\n-  if (this.size === 0) {\n-    buffer = this.buffer = Buffer.allocUnsafeSlow(kReadFileBufferLength);\n-    offset = 0;\n-    length = kReadFileBufferLength;\n-  } else {\n-    buffer = this.buffer;\n-    offset = this.pos;\n-    length = Math.min(kReadFileBufferLength, this.size - this.pos);\n-  }\n-\n-  var req = new FSReqWrap();\n-  req.oncomplete = readFileAfterRead;\n-  req.context = this;\n-\n-  binding.read(this.fd, buffer, offset, length, -1, req);\n-};\n-\n-ReadFileContext.prototype.close = function(err) {\n-  var req = new FSReqWrap();\n-  req.oncomplete = readFileAfterClose;\n-  req.context = this;\n-  this.err = err;\n-\n-  if (this.isUserFd) {\n-    process.nextTick(function tick() {\n-      req.oncomplete(null);\n-    });\n-    return;\n-  }\n-\n-  binding.close(this.fd, req);\n-};\n+}\n \n function readFileAfterOpen(err, fd) {\n-  var context = this.context;\n+  const context = this.context;\n \n   if (err) {\n     context.callback(err);\n@@ -357,23 +244,19 @@ function readFileAfterOpen(err, fd) {\n \n   context.fd = fd;\n \n-  var req = new FSReqWrap();\n+  const req = new FSReqWrap();\n   req.oncomplete = readFileAfterStat;\n   req.context = context;\n   binding.fstat(fd, req);\n }\n \n function readFileAfterStat(err, stats) {\n-  var context = this.context;\n+  const context = this.context;\n \n   if (err)\n     return context.close(err);\n \n-  var size;\n-  if (isFileType(stats, S_IFREG))\n-    size = context.size = stats[8];\n-  else\n-    size = context.size = 0;\n+  const size = context.size = isFileType(stats, S_IFREG) ? stats[8] : 0;\n \n   if (size === 0) {\n     context.buffers = [];\n@@ -394,52 +277,31 @@ function readFileAfterStat(err, stats) {\n   context.read();\n }\n \n-function readFileAfterRead(err, bytesRead) {\n-  var context = this.context;\n-\n-  if (err)\n-    return context.close(err);\n-\n-  if (bytesRead === 0)\n-    return context.close();\n-\n-  context.pos += bytesRead;\n-\n-  if (context.size !== 0) {\n-    if (context.pos === context.size)\n-      context.close();\n-    else\n-      context.read();\n-  } else {\n-    // unknown size, just read until we don't get bytes.\n-    context.buffers.push(context.buffer.slice(0, bytesRead));\n-    context.read();\n-  }\n-}\n-\n-function readFileAfterClose(err) {\n-  var context = this.context;\n-  var buffer = null;\n-  var callback = context.callback;\n+function readFile(path, options, callback) {\n+  callback = maybeCallback(callback || options);\n+  options = getOptions(options, { flag: 'r' });\n+  if (!ReadFileContext)\n+    ReadFileContext = require('internal/fs/read_file_context');\n+  const context = new ReadFileContext(callback, options.encoding);\n+  context.isUserFd = isFd(path); // file descriptor ownership\n \n-  if (context.err || err)\n-    return callback(context.err || err);\n+  const req = new FSReqWrap();\n+  req.context = context;\n+  req.oncomplete = readFileAfterOpen;\n \n-  try {\n-    if (context.size === 0)\n-      buffer = Buffer.concat(context.buffers, context.pos);\n-    else if (context.pos < context.size)\n-      buffer = context.buffer.slice(0, context.pos);\n-    else\n-      buffer = context.buffer;\n-\n-    if (context.encoding)\n-      buffer = buffer.toString(context.encoding);\n-  } catch (err) {\n-    return callback(err);\n+  if (context.isUserFd) {\n+    process.nextTick(function tick() {\n+      req.oncomplete(null, path);\n+    });\n+    return;\n   }\n \n-  callback(null, buffer);\n+  path = getPathFromURL(path);\n+  validatePath(path);\n+  binding.open(pathModule.toNamespacedPath(path),\n+               stringToFlags(options.flag || 'r'),\n+               0o666,\n+               req);\n }\n \n function tryStatSync(fd, isUserFd) {\n@@ -453,8 +315,8 @@ function tryStatSync(fd, isUserFd) {\n }\n \n function tryCreateBuffer(size, fd, isUserFd) {\n-  var threw = true;\n-  var buffer;\n+  let threw = true;\n+  let buffer;\n   try {\n     if (size > kMaxLength) {\n       throw new ERR_FS_FILE_TOO_LARGE(size);\n@@ -468,8 +330,8 @@ function tryCreateBuffer(size, fd, isUserFd) {\n }\n \n function tryReadSync(fd, isUserFd, buffer, pos, len) {\n-  var threw = true;\n-  var bytesRead;\n+  let threw = true;\n+  let bytesRead;\n   try {\n     bytesRead = fs.readSync(fd, buffer, pos, len);\n     threw = false;\n@@ -479,28 +341,24 @@ function tryReadSync(fd, isUserFd, buffer, pos, len) {\n   return bytesRead;\n }\n \n-fs.readFileSync = function(path, options) {\n+function readFileSync(path, options) {\n   options = getOptions(options, { flag: 'r' });\n-  var isUserFd = isFd(path); // file descriptor ownership\n-  var fd = isUserFd ? path : fs.openSync(path, options.flag || 'r', 0o666);\n+  const isUserFd = isFd(path); // file descriptor ownership\n+  const fd = isUserFd ? path : fs.openSync(path, options.flag || 'r', 0o666);\n \n   const stats = tryStatSync(fd, isUserFd);\n-  var size;\n-  if (isFileType(stats, S_IFREG))\n-    size = stats[8];\n-  else\n-    size = 0;\n-  var pos = 0;\n-  var buffer; // single buffer with file data\n-  var buffers; // list for when size is unknown\n+  const size = isFileType(stats, S_IFREG) ? stats[8] : 0;\n+  let pos = 0;\n+  let buffer; // single buffer with file data\n+  let buffers; // list for when size is unknown\n \n   if (size === 0) {\n     buffers = [];\n   } else {\n     buffer = tryCreateBuffer(size, fd, isUserFd);\n   }\n \n-  var bytesRead;\n+  let bytesRead;\n \n   if (size !== 0) {\n     do {\n@@ -532,24 +390,24 @@ fs.readFileSync = function(path, options) {\n \n   if (options.encoding) buffer = buffer.toString(options.encoding);\n   return buffer;\n-};\n+}\n \n-fs.close = function(fd, callback) {\n+function close(fd, callback) {\n   validateUint32(fd, 'fd');\n   const req = new FSReqWrap();\n   req.oncomplete = makeCallback(callback);\n   binding.close(fd, req);\n-};\n+}\n \n-fs.closeSync = function(fd) {\n+function closeSync(fd) {\n   validateUint32(fd, 'fd');\n \n   const ctx = {};\n   binding.close(fd, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.open = function(path, flags, mode, callback) {\n+function open(path, flags, mode, callback) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const flagsNumber = stringToFlags(flags);\n@@ -568,9 +426,10 @@ fs.open = function(path, flags, mode, callback) {\n                flagsNumber,\n                mode,\n                req);\n-};\n+}\n+\n \n-fs.openSync = function(path, flags, mode) {\n+function openSync(path, flags, mode) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const flagsNumber = stringToFlags(flags);\n@@ -582,9 +441,9 @@ fs.openSync = function(path, flags, mode) {\n                               undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return result;\n-};\n+}\n \n-fs.read = function(fd, buffer, offset, length, position, callback) {\n+function read(fd, buffer, offset, length, position, callback) {\n   validateUint32(fd, 'fd');\n   validateBuffer(buffer);\n \n@@ -611,12 +470,12 @@ fs.read = function(fd, buffer, offset, length, position, callback) {\n   req.oncomplete = wrapper;\n \n   binding.read(fd, buffer, offset, length, position, req);\n-};\n+}\n \n-Object.defineProperty(fs.read, internalUtil.customPromisifyArgs,\n+Object.defineProperty(read, internalUtil.customPromisifyArgs,\n                       { value: ['bytesRead', 'buffer'], enumerable: false });\n \n-fs.readSync = function(fd, buffer, offset, length, position) {\n+function readSync(fd, buffer, offset, length, position) {\n   validateUint32(fd, 'fd');\n   validateBuffer(buffer);\n \n@@ -637,13 +496,13 @@ fs.readSync = function(fd, buffer, offset, length, position) {\n                               undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return result;\n-};\n+}\n \n // usage:\n //  fs.write(fd, buffer[, offset[, length[, position]]], callback);\n // OR\n //  fs.write(fd, string[, position[, encoding]], callback);\n-fs.write = function(fd, buffer, offset, length, position, callback) {\n+function write(fd, buffer, offset, length, position, callback) {\n   function wrapper(err, written) {\n     // Retain a reference to buffer so that it can't be GC'ed too soon.\n     callback(err, written || 0, buffer);\n@@ -679,16 +538,16 @@ fs.write = function(fd, buffer, offset, length, position, callback) {\n   }\n   callback = maybeCallback(position);\n   return binding.writeString(fd, buffer, offset, length, req);\n-};\n+}\n \n-Object.defineProperty(fs.write, internalUtil.customPromisifyArgs,\n+Object.defineProperty(write, internalUtil.customPromisifyArgs,\n                       { value: ['bytesWritten', 'buffer'], enumerable: false });\n \n // usage:\n //  fs.writeSync(fd, buffer[, offset[, length[, position]]]);\n // OR\n //  fs.writeSync(fd, string[, position[, encoding]]);\n-fs.writeSync = function(fd, buffer, offset, length, position) {\n+function writeSync(fd, buffer, offset, length, position) {\n   validateUint32(fd, 'fd');\n   const ctx = {};\n   let result;\n@@ -712,9 +571,9 @@ fs.writeSync = function(fd, buffer, offset, length, position) {\n   }\n   handleErrorFromBinding(ctx);\n   return result;\n-};\n+}\n \n-fs.rename = function(oldPath, newPath, callback) {\n+function rename(oldPath, newPath, callback) {\n   callback = makeCallback(callback);\n   oldPath = getPathFromURL(oldPath);\n   validatePath(oldPath, 'oldPath');\n@@ -725,9 +584,9 @@ fs.rename = function(oldPath, newPath, callback) {\n   binding.rename(pathModule.toNamespacedPath(oldPath),\n                  pathModule.toNamespacedPath(newPath),\n                  req);\n-};\n+}\n \n-fs.renameSync = function(oldPath, newPath) {\n+function renameSync(oldPath, newPath) {\n   oldPath = getPathFromURL(oldPath);\n   validatePath(oldPath, 'oldPath');\n   newPath = getPathFromURL(newPath);\n@@ -736,9 +595,9 @@ fs.renameSync = function(oldPath, newPath) {\n   binding.rename(pathModule.toNamespacedPath(oldPath),\n                  pathModule.toNamespacedPath(newPath), undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.truncate = function(path, len, callback) {\n+function truncate(path, len, callback) {\n   if (typeof path === 'number') {\n     showTruncateDeprecation();\n     return fs.ftruncate(path, len, callback);\n@@ -753,17 +612,17 @@ fs.truncate = function(path, len, callback) {\n   callback = maybeCallback(callback);\n   fs.open(path, 'r+', function(er, fd) {\n     if (er) return callback(er);\n-    var req = new FSReqWrap();\n+    const req = new FSReqWrap();\n     req.oncomplete = function oncomplete(er) {\n       fs.close(fd, function(er2) {\n         callback(er || er2);\n       });\n     };\n     binding.ftruncate(fd, len, req);\n   });\n-};\n+}\n \n-fs.truncateSync = function(path, len) {\n+function truncateSync(path, len) {\n   if (typeof path === 'number') {\n     // legacy\n     showTruncateDeprecation();\n@@ -773,18 +632,18 @@ fs.truncateSync = function(path, len) {\n     len = 0;\n   }\n   // allow error to be thrown, but still close fd.\n-  var fd = fs.openSync(path, 'r+');\n-  var ret;\n+  const fd = fs.openSync(path, 'r+');\n+  let ret;\n \n   try {\n     ret = fs.ftruncateSync(fd, len);\n   } finally {\n     fs.closeSync(fd);\n   }\n   return ret;\n-};\n+}\n \n-fs.ftruncate = function(fd, len = 0, callback) {\n+function ftruncate(fd, len = 0, callback) {\n   if (typeof len === 'function') {\n     callback = len;\n     len = 0;\n@@ -799,63 +658,63 @@ fs.ftruncate = function(fd, len = 0, callback) {\n   const req = new FSReqWrap();\n   req.oncomplete = makeCallback(callback);\n   binding.ftruncate(fd, len, req);\n-};\n+}\n \n-fs.ftruncateSync = function(fd, len = 0) {\n+function ftruncateSync(fd, len = 0) {\n   validateUint32(fd, 'fd');\n   validateInt32(len, 'len');\n   len = Math.max(0, len);\n   const ctx = {};\n   binding.ftruncate(fd, len, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.rmdir = function(path, callback) {\n+function rmdir(path, callback) {\n   callback = makeCallback(callback);\n   path = getPathFromURL(path);\n   validatePath(path);\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.rmdir(pathModule.toNamespacedPath(path), req);\n-};\n+}\n \n-fs.rmdirSync = function(path) {\n+function rmdirSync(path) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   binding.rmdir(pathModule.toNamespacedPath(path), undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.fdatasync = function(fd, callback) {\n+function fdatasync(fd, callback) {\n   validateUint32(fd, 'fd');\n   const req = new FSReqWrap();\n   req.oncomplete = makeCallback(callback);\n   binding.fdatasync(fd, req);\n-};\n+}\n \n-fs.fdatasyncSync = function(fd) {\n+function fdatasyncSync(fd) {\n   validateUint32(fd, 'fd');\n   const ctx = {};\n   binding.fdatasync(fd, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.fsync = function(fd, callback) {\n+function fsync(fd, callback) {\n   validateUint32(fd, 'fd');\n   const req = new FSReqWrap();\n   req.oncomplete = makeCallback(callback);\n   binding.fsync(fd, req);\n-};\n+}\n \n-fs.fsyncSync = function(fd) {\n+function fsyncSync(fd) {\n   validateUint32(fd, 'fd');\n   const ctx = {};\n   binding.fsync(fd, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.mkdir = function(path, mode, callback) {\n+function mkdir(path, mode, callback) {\n   path = getPathFromURL(path);\n   validatePath(path);\n \n@@ -870,18 +729,18 @@ fs.mkdir = function(path, mode, callback) {\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.mkdir(pathModule.toNamespacedPath(path), mode, req);\n-};\n+}\n \n-fs.mkdirSync = function(path, mode) {\n+function mkdirSync(path, mode) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   mode = validateAndMaskMode(mode, 'mode', 0o777);\n   const ctx = { path };\n   binding.mkdir(pathModule.toNamespacedPath(path), mode, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.readdir = function(path, options, callback) {\n+function readdir(path, options, callback) {\n   callback = makeCallback(typeof options === 'function' ? options : callback);\n   options = getOptions(options, {});\n   path = getPathFromURL(path);\n@@ -890,9 +749,9 @@ fs.readdir = function(path, options, callback) {\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.readdir(pathModule.toNamespacedPath(path), options.encoding, req);\n-};\n+}\n \n-fs.readdirSync = function(path, options) {\n+function readdirSync(path, options) {\n   options = getOptions(options, {});\n   path = getPathFromURL(path);\n   validatePath(path);\n@@ -901,72 +760,72 @@ fs.readdirSync = function(path, options) {\n                                  options.encoding, undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return result;\n-};\n+}\n \n-fs.fstat = function(fd, callback) {\n+function fstat(fd, callback) {\n   validateUint32(fd, 'fd');\n   const req = new FSReqWrap();\n   req.oncomplete = makeStatsCallback(callback);\n   binding.fstat(fd, req);\n-};\n+}\n \n-fs.lstat = function(path, callback) {\n+function lstat(path, callback) {\n   callback = makeStatsCallback(callback);\n   path = getPathFromURL(path);\n   validatePath(path);\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.lstat(pathModule.toNamespacedPath(path), req);\n-};\n+}\n \n-fs.stat = function(path, callback) {\n+function stat(path, callback) {\n   callback = makeStatsCallback(callback);\n   path = getPathFromURL(path);\n   validatePath(path);\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.stat(pathModule.toNamespacedPath(path), req);\n-};\n+}\n \n-fs.fstatSync = function(fd) {\n+function fstatSync(fd) {\n   validateUint32(fd, 'fd');\n   const ctx = { fd };\n   const stats = binding.fstat(fd, undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return getStatsFromBinding(stats);\n-};\n+}\n \n-fs.lstatSync = function(path) {\n+function lstatSync(path) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   const stats = binding.lstat(pathModule.toNamespacedPath(path),\n                               undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return getStatsFromBinding(stats);\n-};\n+}\n \n-fs.statSync = function(path) {\n+function statSync(path) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   const stats = binding.stat(pathModule.toNamespacedPath(path),\n                              undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return getStatsFromBinding(stats);\n-};\n+}\n \n-fs.readlink = function(path, options, callback) {\n+function readlink(path, options, callback) {\n   callback = makeCallback(typeof options === 'function' ? options : callback);\n   options = getOptions(options, {});\n   path = getPathFromURL(path);\n   validatePath(path, 'oldPath');\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.readlink(pathModule.toNamespacedPath(path), options.encoding, req);\n-};\n+}\n \n-fs.readlinkSync = function(path, options) {\n+function readlinkSync(path, options) {\n   options = getOptions(options, {});\n   path = getPathFromURL(path);\n   validatePath(path, 'oldPath');\n@@ -975,11 +834,11 @@ fs.readlinkSync = function(path, options) {\n                                   options.encoding, undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return result;\n-};\n+}\n \n-fs.symlink = function(target, path, type_, callback_) {\n-  var type = (typeof type_ === 'string' ? type_ : null);\n-  var callback = makeCallback(arguments[arguments.length - 1]);\n+function symlink(target, path, type_, callback_) {\n+  const type = (typeof type_ === 'string' ? type_ : null);\n+  const callback = makeCallback(arguments[arguments.length - 1]);\n \n   target = getPathFromURL(target);\n   path = getPathFromURL(path);\n@@ -992,9 +851,9 @@ fs.symlink = function(target, path, type_, callback_) {\n \n   binding.symlink(preprocessSymlinkDestination(target, type, path),\n                   pathModule.toNamespacedPath(path), flags, req);\n-};\n+}\n \n-fs.symlinkSync = function(target, path, type) {\n+function symlinkSync(target, path, type) {\n   type = (typeof type === 'string' ? type : null);\n   target = getPathFromURL(target);\n   path = getPathFromURL(path);\n@@ -1007,9 +866,9 @@ fs.symlinkSync = function(target, path, type) {\n                   pathModule.toNamespacedPath(path), flags, undefined, ctx);\n \n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.link = function(existingPath, newPath, callback) {\n+function link(existingPath, newPath, callback) {\n   callback = makeCallback(callback);\n \n   existingPath = getPathFromURL(existingPath);\n@@ -1023,9 +882,9 @@ fs.link = function(existingPath, newPath, callback) {\n   binding.link(pathModule.toNamespacedPath(existingPath),\n                pathModule.toNamespacedPath(newPath),\n                req);\n-};\n+}\n \n-fs.linkSync = function(existingPath, newPath) {\n+function linkSync(existingPath, newPath) {\n   existingPath = getPathFromURL(existingPath);\n   newPath = getPathFromURL(newPath);\n   validatePath(existingPath, 'existingPath');\n@@ -1037,78 +896,76 @@ fs.linkSync = function(existingPath, newPath) {\n                               undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return result;\n-};\n+}\n \n-fs.unlink = function(path, callback) {\n+function unlink(path, callback) {\n   callback = makeCallback(callback);\n   path = getPathFromURL(path);\n   validatePath(path);\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.unlink(pathModule.toNamespacedPath(path), req);\n-};\n+}\n \n-fs.unlinkSync = function(path) {\n+function unlinkSync(path) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   binding.unlink(pathModule.toNamespacedPath(path), undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.fchmod = function(fd, mode, callback) {\n+function fchmod(fd, mode, callback) {\n   validateInt32(fd, 'fd', 0);\n   mode = validateAndMaskMode(mode, 'mode');\n   callback = makeCallback(callback);\n \n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.fchmod(fd, mode, req);\n-};\n+}\n \n-fs.fchmodSync = function(fd, mode) {\n+function fchmodSync(fd, mode) {\n   validateInt32(fd, 'fd', 0);\n   mode = validateAndMaskMode(mode, 'mode');\n   const ctx = {};\n   binding.fchmod(fd, mode, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-if (O_SYMLINK !== undefined) {\n-  fs.lchmod = function(path, mode, callback) {\n-    callback = maybeCallback(callback);\n-    fs.open(path, O_WRONLY | O_SYMLINK, function(err, fd) {\n-      if (err) {\n-        callback(err);\n-        return;\n-      }\n-      // Prefer to return the chmod error, if one occurs,\n-      // but still try to close, and report closing errors if they occur.\n-      fs.fchmod(fd, mode, function(err) {\n-        fs.close(fd, function(err2) {\n-          callback(err || err2);\n-        });\n+function lchmod(path, mode, callback) {\n+  callback = maybeCallback(callback);\n+  fs.open(path, O_WRONLY | O_SYMLINK, function(err, fd) {\n+    if (err) {\n+      callback(err);\n+      return;\n+    }\n+    // Prefer to return the chmod error, if one occurs,\n+    // but still try to close, and report closing errors if they occur.\n+    fs.fchmod(fd, mode, function(err) {\n+      fs.close(fd, function(err2) {\n+        callback(err || err2);\n       });\n     });\n-  };\n+  });\n+}\n \n-  fs.lchmodSync = function(path, mode) {\n-    const fd = fs.openSync(path, O_WRONLY | O_SYMLINK);\n+function lchmodSync(path, mode) {\n+  const fd = fs.openSync(path, O_WRONLY | O_SYMLINK);\n \n-    // Prefer to return the chmod error, if one occurs,\n-    // but still try to close, and report closing errors if they occur.\n-    let ret;\n-    try {\n-      ret = fs.fchmodSync(fd, mode);\n-    } finally {\n-      fs.closeSync(fd);\n-    }\n-    return ret;\n-  };\n+  // Prefer to return the chmod error, if one occurs,\n+  // but still try to close, and report closing errors if they occur.\n+  let ret;\n+  try {\n+    ret = fs.fchmodSync(fd, mode);\n+  } finally {\n+    fs.closeSync(fd);\n+  }\n+  return ret;\n }\n \n \n-fs.chmod = function(path, mode, callback) {\n+function chmod(path, mode, callback) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   mode = validateAndMaskMode(mode, 'mode');\n@@ -1117,69 +974,67 @@ fs.chmod = function(path, mode, callback) {\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.chmod(pathModule.toNamespacedPath(path), mode, req);\n-};\n+}\n \n-fs.chmodSync = function(path, mode) {\n+function chmodSync(path, mode) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   mode = validateAndMaskMode(mode, 'mode');\n \n   const ctx = { path };\n   binding.chmod(pathModule.toNamespacedPath(path), mode, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-if (O_SYMLINK !== undefined) {\n-  fs.lchown = function(path, uid, gid, callback) {\n-    callback = maybeCallback(callback);\n-    fs.open(path, O_WRONLY | O_SYMLINK, function(err, fd) {\n-      if (err) {\n-        callback(err);\n-        return;\n-      }\n-      // Prefer to return the chown error, if one occurs,\n-      // but still try to close, and report closing errors if they occur.\n-      fs.fchown(fd, uid, gid, function(err) {\n-        fs.close(fd, function(err2) {\n-          callback(err || err2);\n-        });\n+function lchown(path, uid, gid, callback) {\n+  callback = maybeCallback(callback);\n+  fs.open(path, O_WRONLY | O_SYMLINK, function(err, fd) {\n+    if (err) {\n+      callback(err);\n+      return;\n+    }\n+    // Prefer to return the chown error, if one occurs,\n+    // but still try to close, and report closing errors if they occur.\n+    fs.fchown(fd, uid, gid, function(err) {\n+      fs.close(fd, function(err2) {\n+        callback(err || err2);\n       });\n     });\n-  };\n+  });\n+}\n \n-  fs.lchownSync = function(path, uid, gid) {\n-    const fd = fs.openSync(path, O_WRONLY | O_SYMLINK);\n-    let ret;\n-    try {\n-      ret = fs.fchownSync(fd, uid, gid);\n-    } finally {\n-      fs.closeSync(fd);\n-    }\n-    return ret;\n-  };\n+function lchownSync(path, uid, gid) {\n+  const fd = fs.openSync(path, O_WRONLY | O_SYMLINK);\n+  let ret;\n+  try {\n+    ret = fs.fchownSync(fd, uid, gid);\n+  } finally {\n+    fs.closeSync(fd);\n+  }\n+  return ret;\n }\n \n-fs.fchown = function(fd, uid, gid, callback) {\n+function fchown(fd, uid, gid, callback) {\n   validateUint32(fd, 'fd');\n   validateUint32(uid, 'uid');\n   validateUint32(gid, 'gid');\n \n   const req = new FSReqWrap();\n   req.oncomplete = makeCallback(callback);\n   binding.fchown(fd, uid, gid, req);\n-};\n+}\n \n-fs.fchownSync = function(fd, uid, gid) {\n+function fchownSync(fd, uid, gid) {\n   validateUint32(fd, 'fd');\n   validateUint32(uid, 'uid');\n   validateUint32(gid, 'gid');\n \n   const ctx = {};\n   binding.fchown(fd, uid, gid, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.chown = function(path, uid, gid, callback) {\n+function chown(path, uid, gid, callback) {\n   callback = makeCallback(callback);\n   path = getPathFromURL(path);\n   validatePath(path);\n@@ -1189,22 +1044,19 @@ fs.chown = function(path, uid, gid, callback) {\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.chown(pathModule.toNamespacedPath(path), uid, gid, req);\n-};\n+}\n \n-fs.chownSync = function(path, uid, gid) {\n+function chownSync(path, uid, gid) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   validateUint32(uid, 'uid');\n   validateUint32(gid, 'gid');\n   const ctx = { path };\n   binding.chown(pathModule.toNamespacedPath(path), uid, gid, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n-\n-// exported for unit tests, not for public consumption\n-fs._toUnixTimestamp = toUnixTimestamp;\n+}\n \n-fs.utimes = function(path, atime, mtime, callback) {\n+function utimes(path, atime, mtime, callback) {\n   callback = makeCallback(callback);\n   path = getPathFromURL(path);\n   validatePath(path);\n@@ -1215,35 +1067,35 @@ fs.utimes = function(path, atime, mtime, callback) {\n                  toUnixTimestamp(atime),\n                  toUnixTimestamp(mtime),\n                  req);\n-};\n+}\n \n-fs.utimesSync = function(path, atime, mtime) {\n+function utimesSync(path, atime, mtime) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   binding.utimes(pathModule.toNamespacedPath(path),\n                  toUnixTimestamp(atime), toUnixTimestamp(mtime),\n                  undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n-fs.futimes = function(fd, atime, mtime, callback) {\n+function futimes(fd, atime, mtime, callback) {\n   validateUint32(fd, 'fd');\n   atime = toUnixTimestamp(atime, 'atime');\n   mtime = toUnixTimestamp(mtime, 'mtime');\n   const req = new FSReqWrap();\n   req.oncomplete = makeCallback(callback);\n   binding.futimes(fd, atime, mtime, req);\n-};\n+}\n \n-fs.futimesSync = function(fd, atime, mtime) {\n+function futimesSync(fd, atime, mtime) {\n   validateUint32(fd, 'fd');\n   atime = toUnixTimestamp(atime, 'atime');\n   mtime = toUnixTimestamp(mtime, 'mtime');\n   const ctx = {};\n   binding.futimes(fd, atime, mtime, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n+}\n \n function writeAll(fd, isUserFd, buffer, offset, length, position, callback) {\n   // write(fd, buffer, offset, length, position, callback)\n@@ -1273,7 +1125,7 @@ function writeAll(fd, isUserFd, buffer, offset, length, position, callback) {\n   });\n }\n \n-fs.writeFile = function(path, data, options, callback) {\n+function writeFile(path, data, options, callback) {\n   callback = maybeCallback(callback || options);\n   options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n   const flag = options.flag || 'w';\n@@ -1292,30 +1144,30 @@ fs.writeFile = function(path, data, options, callback) {\n   });\n \n   function writeFd(fd, isUserFd) {\n-    var buffer = isUint8Array(data) ?\n+    const buffer = isUint8Array(data) ?\n       data : Buffer.from('' + data, options.encoding || 'utf8');\n-    var position = /a/.test(flag) ? null : 0;\n+    const position = /a/.test(flag) ? null : 0;\n \n     writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);\n   }\n-};\n+}\n \n-fs.writeFileSync = function(path, data, options) {\n+function writeFileSync(path, data, options) {\n   options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n   const flag = options.flag || 'w';\n \n-  var isUserFd = isFd(path); // file descriptor ownership\n-  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\n+  const isUserFd = isFd(path); // file descriptor ownership\n+  const fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\n \n   if (!isUint8Array(data)) {\n     data = Buffer.from('' + data, options.encoding || 'utf8');\n   }\n-  var offset = 0;\n-  var length = data.length;\n-  var position = /a/.test(flag) ? null : 0;\n+  let offset = 0;\n+  let length = data.length;\n+  let position = /a/.test(flag) ? null : 0;\n   try {\n     while (length > 0) {\n-      var written = fs.writeSync(fd, data, offset, length, position);\n+      const written = fs.writeSync(fd, data, offset, length, position);\n       offset += written;\n       length -= written;\n       if (position !== null) {\n@@ -1325,9 +1177,9 @@ fs.writeFileSync = function(path, data, options) {\n   } finally {\n     if (!isUserFd) fs.closeSync(fd);\n   }\n-};\n+}\n \n-fs.appendFile = function(path, data, options, callback) {\n+function appendFile(path, data, options, callback) {\n   callback = maybeCallback(callback || options);\n   options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n \n@@ -1339,9 +1191,9 @@ fs.appendFile = function(path, data, options, callback) {\n     options.flag = 'a';\n \n   fs.writeFile(path, data, options, callback);\n-};\n+}\n \n-fs.appendFileSync = function(path, data, options) {\n+function appendFileSync(path, data, options) {\n   options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n \n   // Don't make changes directly on options object\n@@ -1352,84 +1204,9 @@ fs.appendFileSync = function(path, data, options) {\n     options.flag = 'a';\n \n   fs.writeFileSync(path, data, options);\n-};\n-\n-function FSWatcher() {\n-  EventEmitter.call(this);\n-\n-  var self = this;\n-  this._handle = new FSEvent();\n-  this._handle.owner = this;\n-\n-  this._handle.onchange = function(status, eventType, filename) {\n-    // TODO(joyeecheung): we may check self._handle.initialized here\n-    // and return if that is false. This allows us to avoid firing the event\n-    // after the handle is closed, and to fire both UV_RENAME and UV_CHANGE\n-    // if they are set by libuv at the same time.\n-    if (status < 0) {\n-      self._handle.close();\n-      const error = errors.uvException({\n-        errno: status,\n-        syscall: 'watch',\n-        path: filename\n-      });\n-      error.filename = filename;\n-      self.emit('error', error);\n-    } else {\n-      self.emit('change', eventType, filename);\n-    }\n-  };\n-}\n-util.inherits(FSWatcher, EventEmitter);\n-\n-// FIXME(joyeecheung): this method is not documented.\n-// At the moment if filename is undefined, we\n-// 1. Throw an Error if it's the first time .start() is called\n-// 2. Return silently if .start() has already been called\n-//    on a valid filename and the wrap has been initialized\n-// This method is a noop if the watcher has already been started.\n-FSWatcher.prototype.start = function(filename,\n-                                     persistent,\n-                                     recursive,\n-                                     encoding) {\n-  lazyAssert()(this._handle instanceof FSEvent, 'handle must be a FSEvent');\n-  if (this._handle.initialized) {\n-    return;\n-  }\n-\n-  filename = getPathFromURL(filename);\n-  validatePath(filename, 'filename');\n-\n-  const err = this._handle.start(pathModule.toNamespacedPath(filename),\n-                                 persistent,\n-                                 recursive,\n-                                 encoding);\n-  if (err) {\n-    const error = errors.uvException({\n-      errno: err,\n-      syscall: 'watch',\n-      path: filename\n-    });\n-    error.filename = filename;\n-    throw error;\n-  }\n-};\n-\n-// This method is a noop if the watcher has not been started.\n-FSWatcher.prototype.close = function() {\n-  lazyAssert()(this._handle instanceof FSEvent, 'handle must be a FSEvent');\n-  if (!this._handle.initialized) {\n-    return;\n-  }\n-  this._handle.close();\n-  process.nextTick(emitCloseNT, this);\n-};\n-\n-function emitCloseNT(self) {\n-  self.emit('close');\n }\n \n-fs.watch = function(filename, options, listener) {\n+function watch(filename, options, listener) {\n   if (typeof options === 'function') {\n     listener = options;\n   }\n@@ -1441,7 +1218,9 @@ fs.watch = function(filename, options, listener) {\n   if (options.persistent === undefined) options.persistent = true;\n   if (options.recursive === undefined) options.recursive = false;\n \n-  const watcher = new FSWatcher();\n+  if (!watchers)\n+    watchers = require('internal/fs/watchers');\n+  const watcher = new watchers.FSWatcher();\n   watcher.start(filename,\n                 options.persistent,\n                 options.recursive,\n@@ -1452,94 +1231,18 @@ fs.watch = function(filename, options, listener) {\n   }\n \n   return watcher;\n-};\n-\n-\n-// Stat Change Watchers\n-\n-function emitStop(self) {\n-  self.emit('stop');\n-}\n-\n-function StatWatcher() {\n-  EventEmitter.call(this);\n-\n-  var self = this;\n-  this._handle = new binding.StatWatcher();\n-\n-  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n-  // the sake of backwards compatibility\n-  var oldStatus = -1;\n-\n-  this._handle.onchange = function(newStatus, stats) {\n-    if (oldStatus === -1 &&\n-        newStatus === -1 &&\n-        stats[2/* new nlink */] === stats[16/* old nlink */]) return;\n-\n-    oldStatus = newStatus;\n-    self.emit('change', getStatsFromBinding(stats),\n-              getStatsFromBinding(stats, kFsStatsFieldsLength));\n-  };\n-\n-  this._handle.onstop = function() {\n-    process.nextTick(emitStop, self);\n-  };\n }\n-util.inherits(StatWatcher, EventEmitter);\n-\n-\n-// FIXME(joyeecheung): this method is not documented.\n-// At the moment if filename is undefined, we\n-// 1. Throw an Error if it's the first time .start() is called\n-// 2. Return silently if .start() has already been called\n-//    on a valid filename and the wrap has been initialized\n-// This method is a noop if the watcher has already been started.\n-StatWatcher.prototype.start = function(filename, persistent, interval) {\n-  lazyAssert()(this._handle instanceof binding.StatWatcher,\n-               'handle must be a StatWatcher');\n-  if (this._handle.isActive) {\n-    return;\n-  }\n-\n-  filename = getPathFromURL(filename);\n-  validatePath(filename, 'filename');\n-  validateUint32(interval, 'interval');\n-  const err = this._handle.start(pathModule.toNamespacedPath(filename),\n-                                 persistent, interval);\n-  if (err) {\n-    const error = errors.uvException({\n-      errno: err,\n-      syscall: 'watch',\n-      path: filename\n-    });\n-    error.filename = filename;\n-    throw error;\n-  }\n-};\n-\n-// FIXME(joyeecheung): this method is not documented while there is\n-// another documented fs.unwatchFile(). The counterpart in\n-// FSWatcher is .close()\n-// This method is a noop if the watcher has not been started.\n-StatWatcher.prototype.stop = function() {\n-  lazyAssert()(this._handle instanceof binding.StatWatcher,\n-               'handle must be a StatWatcher');\n-  if (!this._handle.isActive) {\n-    return;\n-  }\n-  this._handle.stop();\n-};\n \n \n const statWatchers = new Map();\n \n-fs.watchFile = function(filename, options, listener) {\n+function watchFile(filename, options, listener) {\n   filename = getPathFromURL(filename);\n   validatePath(filename);\n   filename = pathModule.resolve(filename);\n-  var stat;\n+  let stat;\n \n-  var defaults = {\n+  const defaults = {\n     // Poll interval in milliseconds. 5007 is what libev used to use. It's\n     // a little on the slow side but let's stick with it for now to keep\n     // behavioral changes to a minimum.\n@@ -1548,7 +1251,7 @@ fs.watchFile = function(filename, options, listener) {\n   };\n \n   if (options !== null && typeof options === 'object') {\n-    options = util._extend(defaults, options);\n+    options = _extend(defaults, options);\n   } else {\n     listener = options;\n     options = defaults;\n@@ -1561,20 +1264,22 @@ fs.watchFile = function(filename, options, listener) {\n   stat = statWatchers.get(filename);\n \n   if (stat === undefined) {\n-    stat = new StatWatcher();\n+    if (!watchers)\n+      watchers = require('internal/fs/watchers');\n+    stat = new watchers.StatWatcher();\n     stat.start(filename, options.persistent, options.interval);\n     statWatchers.set(filename, stat);\n   }\n \n   stat.addListener('change', listener);\n   return stat;\n-};\n+}\n \n-fs.unwatchFile = function(filename, listener) {\n+function unwatchFile(filename, listener) {\n   filename = getPathFromURL(filename);\n   validatePath(filename);\n   filename = pathModule.resolve(filename);\n-  var stat = statWatchers.get(filename);\n+  const stat = statWatchers.get(filename);\n \n   if (stat === undefined) return;\n \n@@ -1588,10 +1293,10 @@ fs.unwatchFile = function(filename, listener) {\n     stat.stop();\n     statWatchers.delete(filename);\n   }\n-};\n+}\n \n \n-var splitRoot;\n+let splitRoot;\n if (isWindows) {\n   // Regex to find the device root on Windows (e.g. 'c:\\\\'), including trailing\n   // slash.\n@@ -1621,7 +1326,7 @@ function encodeRealpathResult(result, options) {\n }\n \n // Finds the next portion of a (partial) path, up to the next path delimiter\n-var nextPart;\n+let nextPart;\n if (isWindows) {\n   nextPart = function nextPart(p, i) {\n     for (; i < p.length; ++i) {\n@@ -1638,7 +1343,7 @@ if (isWindows) {\n }\n \n const emptyObj = Object.create(null);\n-fs.realpathSync = function realpathSync(p, options) {\n+function realpathSync(p, options) {\n   if (!options)\n     options = emptyObj;\n   else\n@@ -1661,13 +1366,13 @@ fs.realpathSync = function realpathSync(p, options) {\n   const original = p;\n \n   // current character position in p\n-  var pos;\n+  let pos;\n   // the partial path so far, including a trailing slash if any\n-  var current;\n+  let current;\n   // the partial path without a trailing slash (except when pointing at a root)\n-  var base;\n+  let base;\n   // the partial path scanned in the previous round, with slash\n-  var previous;\n+  let previous;\n \n   // Skip over roots\n   current = base = splitRoot(p);\n@@ -1686,10 +1391,10 @@ fs.realpathSync = function realpathSync(p, options) {\n   // NB: p.length changes.\n   while (pos < p.length) {\n     // find the next part\n-    var result = nextPart(p, pos);\n+    const result = nextPart(p, pos);\n     previous = current;\n     if (result === -1) {\n-      var last = p.slice(pos);\n+      const last = p.slice(pos);\n       current += last;\n       base = previous + last;\n       pos = p.length;\n@@ -1708,15 +1413,15 @@ fs.realpathSync = function realpathSync(p, options) {\n       continue;\n     }\n \n-    var resolvedLink;\n-    var maybeCachedResolved = cache && cache.get(base);\n+    let resolvedLink;\n+    const maybeCachedResolved = cache && cache.get(base);\n     if (maybeCachedResolved) {\n       resolvedLink = maybeCachedResolved;\n     } else {\n       // Use stats array directly to avoid creating an fs.Stats instance just\n       // for our internal use.\n \n-      var baseLong = pathModule.toNamespacedPath(base);\n+      const baseLong = pathModule.toNamespacedPath(base);\n       const ctx = { path: base };\n       const stats = binding.lstat(baseLong, undefined, ctx);\n       handleErrorFromBinding(ctx);\n@@ -1729,11 +1434,11 @@ fs.realpathSync = function realpathSync(p, options) {\n \n       // read the link if it wasn't read before\n       // dev/ino always return 0 on windows, so skip the check.\n-      var linkTarget = null;\n-      var id;\n+      let linkTarget = null;\n+      let id;\n       if (!isWindows) {\n-        var dev = stats[0].toString(32);\n-        var ino = stats[7].toString(32);\n+        const dev = stats[0].toString(32);\n+        const ino = stats[7].toString(32);\n         id = `${dev}:${ino}`;\n         if (seenLinks[id]) {\n           linkTarget = seenLinks[id];\n@@ -1770,10 +1475,10 @@ fs.realpathSync = function realpathSync(p, options) {\n \n   if (cache) cache.set(original, p);\n   return encodeRealpathResult(p, options);\n-};\n+}\n \n \n-fs.realpathSync.native = function(path, options) {\n+realpathSync.native = function(path, options) {\n   options = getOptions(options, {});\n   path = getPathFromURL(path);\n   validatePath(path);\n@@ -1784,7 +1489,7 @@ fs.realpathSync.native = function(path, options) {\n };\n \n \n-fs.realpath = function realpath(p, options, callback) {\n+function realpath(p, options, callback) {\n   callback = maybeCallback(typeof options === 'function' ? options : callback);\n   if (!options)\n     options = emptyObj;\n@@ -1801,13 +1506,13 @@ fs.realpath = function realpath(p, options, callback) {\n   const knownHard = Object.create(null);\n \n   // current character position in p\n-  var pos;\n+  let pos;\n   // the partial path so far, including a trailing slash if any\n-  var current;\n+  let current;\n   // the partial path without a trailing slash (except when pointing at a root)\n-  var base;\n+  let base;\n   // the partial path scanned in the previous round, with slash\n-  var previous;\n+  let previous;\n \n   current = base = splitRoot(p);\n   pos = current.length;\n@@ -1832,10 +1537,10 @@ fs.realpath = function realpath(p, options, callback) {\n     }\n \n     // find the next part\n-    var result = nextPart(p, pos);\n+    const result = nextPart(p, pos);\n     previous = current;\n     if (result === -1) {\n-      var last = p.slice(pos);\n+      const last = p.slice(pos);\n       current += last;\n       base = previous + last;\n       pos = p.length;\n@@ -1871,8 +1576,8 @@ fs.realpath = function realpath(p, options, callback) {\n     // dev/ino always return 0 on windows, so skip the check.\n     let id;\n     if (!isWindows) {\n-      var dev = stats.dev.toString(32);\n-      var ino = stats.ino.toString(32);\n+      const dev = stats.dev.toString(32);\n+      const ino = stats.ino.toString(32);\n       id = `${dev}:${ino}`;\n       if (seenLinks[id]) {\n         return gotTarget(null, seenLinks[id], base);\n@@ -1891,8 +1596,7 @@ fs.realpath = function realpath(p, options, callback) {\n   function gotTarget(err, target, base) {\n     if (err) return callback(err);\n \n-    var resolvedLink = pathModule.resolve(previous, target);\n-    gotResolvedLink(resolvedLink);\n+    gotResolvedLink(pathModule.resolve(previous, target));\n   }\n \n   function gotResolvedLink(resolvedLink) {\n@@ -1912,10 +1616,10 @@ fs.realpath = function realpath(p, options, callback) {\n       process.nextTick(LOOP);\n     }\n   }\n-};\n+}\n \n \n-fs.realpath.native = function(path, options, callback) {\n+realpath.native = function(path, options, callback) {\n   callback = makeCallback(callback || options);\n   options = getOptions(options, {});\n   path = getPathFromURL(path);\n@@ -1925,20 +1629,20 @@ fs.realpath.native = function(path, options, callback) {\n   return binding.realpath(path, options.encoding, req);\n };\n \n-fs.mkdtemp = function(prefix, options, callback) {\n+function mkdtemp(prefix, options, callback) {\n   callback = makeCallback(typeof options === 'function' ? options : callback);\n   options = getOptions(options, {});\n   if (!prefix || typeof prefix !== 'string') {\n     throw new ERR_INVALID_ARG_TYPE('prefix', 'string', prefix);\n   }\n   nullCheck(prefix, 'prefix');\n-  var req = new FSReqWrap();\n+  const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.mkdtemp(`${prefix}XXXXXX`, options.encoding, req);\n-};\n+}\n \n \n-fs.mkdtempSync = function(prefix, options) {\n+function mkdtempSync(prefix, options) {\n   options = getOptions(options, {});\n   if (!prefix || typeof prefix !== 'string') {\n     throw new ERR_INVALID_ARG_TYPE('prefix', 'string', prefix);\n@@ -1950,24 +1654,10 @@ fs.mkdtempSync = function(prefix, options) {\n                                  undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return result;\n-};\n-\n-\n-// Define copyFile() flags.\n-Object.defineProperties(fs.constants, {\n-  COPYFILE_EXCL: { enumerable: true, value: UV_FS_COPYFILE_EXCL },\n-  COPYFILE_FICLONE: {\n-    enumerable: true,\n-    value: UV_FS_COPYFILE_FICLONE\n-  },\n-  COPYFILE_FICLONE_FORCE: {\n-    enumerable: true,\n-    value: UV_FS_COPYFILE_FICLONE_FORCE\n-  }\n-});\n+}\n \n \n-fs.copyFile = function(src, dest, flags, callback) {\n+function copyFile(src, dest, flags, callback) {\n   if (typeof flags === 'function') {\n     callback = flags;\n     flags = 0;\n@@ -1986,10 +1676,10 @@ fs.copyFile = function(src, dest, flags, callback) {\n   const req = new FSReqWrap();\n   req.oncomplete = makeCallback(callback);\n   binding.copyFile(src, dest, flags, req);\n-};\n+}\n \n \n-fs.copyFileSync = function(src, dest, flags) {\n+function copyFileSync(src, dest, flags) {\n   src = getPathFromURL(src);\n   dest = getPathFromURL(dest);\n   validatePath(src, 'src');\n@@ -2002,379 +1692,167 @@ fs.copyFileSync = function(src, dest, flags) {\n   flags = flags | 0;\n   binding.copyFile(src, dest, flags, undefined, ctx);\n   handleErrorFromBinding(ctx);\n-};\n-\n-\n-var pool;\n-\n-function allocNewPool(poolSize) {\n-  pool = Buffer.allocUnsafe(poolSize);\n-  pool.used = 0;\n }\n \n-\n-fs.createReadStream = function(path, options) {\n-  return new ReadStream(path, options);\n-};\n-\n-util.inherits(ReadStream, Readable);\n-fs.ReadStream = ReadStream;\n-\n-function ReadStream(path, options) {\n-  if (!(this instanceof ReadStream))\n-    return new ReadStream(path, options);\n-\n-  // a little bit bigger buffer and water marks by default\n-  options = copyObject(getOptions(options, {}));\n-  if (options.highWaterMark === undefined)\n-    options.highWaterMark = 64 * 1024;\n-\n-  // for backwards compat do not emit close on destroy.\n-  options.emitClose = false;\n-\n-  Readable.call(this, options);\n-\n-  // path will be ignored when fd is specified, so it can be falsy\n-  this.path = getPathFromURL(path);\n-  this.fd = options.fd === undefined ? null : options.fd;\n-  this.flags = options.flags === undefined ? 'r' : options.flags;\n-  this.mode = options.mode === undefined ? 0o666 : options.mode;\n-\n-  this.start = options.start;\n-  this.end = options.end;\n-  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n-  this.pos = undefined;\n-  this.bytesRead = 0;\n-  this.closed = false;\n-\n-  if (this.start !== undefined) {\n-    if (!Number.isSafeInteger(this.start)) {\n-      if (typeof this.start !== 'number')\n-        throw new ERR_INVALID_ARG_TYPE('start', 'number', this.start);\n-      if (!Number.isInteger(this.start))\n-        throw new ERR_OUT_OF_RANGE('start', 'an integer', this.start);\n-      throw new ERR_OUT_OF_RANGE(\n-        'start',\n-        '>= 0 and <= 2 ** 53 - 1',\n-        this.start\n-      );\n-    }\n-    if (this.start < 0) {\n-      throw new ERR_OUT_OF_RANGE(\n-        'start',\n-        '>= 0 and <= 2 ** 53 - 1',\n-        this.start\n-      );\n-    }\n-\n-    this.pos = this.start;\n-  }\n-\n-  if (this.end === undefined) {\n-    this.end = Infinity;\n-  } else if (this.end !== Infinity) {\n-    if (!Number.isSafeInteger(this.end)) {\n-      if (typeof this.end !== 'number')\n-        throw new ERR_INVALID_ARG_TYPE('end', 'number', this.end);\n-      if (!Number.isInteger(this.end))\n-        throw new ERR_OUT_OF_RANGE('end', 'an integer', this.end);\n-      throw new ERR_OUT_OF_RANGE('end', '>= 0 and <= 2 ** 53 - 1', this.end);\n-    }\n-\n-    if (this.end < 0) {\n-      throw new ERR_OUT_OF_RANGE('end', '>= 0 and <= 2 ** 53 - 1', this.end);\n-    }\n-\n-    if (this.start !== undefined && this.start > this.end) {\n-      throw new ERR_OUT_OF_RANGE(\n-        'start',\n-        `<= \"end\" (here: ${this.end})`,\n-        this.start\n-      );\n-    }\n+function lazyLoadStreams() {\n+  if (!ReadStream) {\n+    ({ ReadStream, WriteStream } = require('internal/fs/streams'));\n+    [ FileReadStream, FileWriteStream ] = [ ReadStream, WriteStream ];\n   }\n-\n-  if (typeof this.fd !== 'number')\n-    this.open();\n-\n-  this.on('end', function() {\n-    if (this.autoClose) {\n-      this.destroy();\n-    }\n-  });\n }\n \n-fs.FileReadStream = fs.ReadStream; // support the legacy name\n-\n-ReadStream.prototype.open = function() {\n-  var self = this;\n-  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n-    if (er) {\n-      if (self.autoClose) {\n-        self.destroy();\n-      }\n-      self.emit('error', er);\n-      return;\n-    }\n-\n-    self.fd = fd;\n-    self.emit('open', fd);\n-    self.emit('ready');\n-    // start the flow of data.\n-    self.read();\n-  });\n-};\n-\n-ReadStream.prototype._read = function(n) {\n-  if (typeof this.fd !== 'number') {\n-    return this.once('open', function() {\n-      this._read(n);\n-    });\n-  }\n-\n-  if (this.destroyed)\n-    return;\n-\n-  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n-    // discard the old pool.\n-    allocNewPool(this.readableHighWaterMark);\n-  }\n-\n-  // Grab another reference to the pool in the case that while we're\n-  // in the thread pool another read() finishes up the pool, and\n-  // allocates a new one.\n-  var thisPool = pool;\n-  var toRead = Math.min(pool.length - pool.used, n);\n-  var start = pool.used;\n-\n-  if (this.pos !== undefined)\n-    toRead = Math.min(this.end - this.pos + 1, toRead);\n-  else\n-    toRead = Math.min(this.end - this.bytesRead + 1, toRead);\n-\n-  // already read everything we were supposed to read!\n-  // treat as EOF.\n-  if (toRead <= 0)\n-    return this.push(null);\n-\n-  // the actual read.\n-  fs.read(this.fd, pool, pool.used, toRead, this.pos, (er, bytesRead) => {\n-    if (er) {\n-      if (this.autoClose) {\n-        this.destroy();\n-      }\n-      this.emit('error', er);\n-    } else {\n-      var b = null;\n-      if (bytesRead > 0) {\n-        this.bytesRead += bytesRead;\n-        b = thisPool.slice(start, start + bytesRead);\n-      }\n-\n-      this.push(b);\n-    }\n-  });\n-\n-  // move the pool positions, and internal position for reading.\n-  if (this.pos !== undefined)\n-    this.pos += toRead;\n-  pool.used += toRead;\n-};\n-\n-ReadStream.prototype._destroy = function(err, cb) {\n-  const isOpen = typeof this.fd !== 'number';\n-  if (isOpen) {\n-    this.once('open', closeFsStream.bind(null, this, cb, err));\n-    return;\n-  }\n-\n-  closeFsStream(this, cb, err);\n-  this.fd = null;\n-};\n-\n-function closeFsStream(stream, cb, err) {\n-  fs.close(stream.fd, (er) => {\n-    er = er || err;\n-    cb(er);\n-    stream.closed = true;\n-    if (!er)\n-      stream.emit('close');\n-  });\n+function createReadStream(path, options) {\n+  lazyLoadStreams();\n+  return new ReadStream(path, options);\n }\n \n-ReadStream.prototype.close = function(cb) {\n-  this.destroy(null, cb);\n-};\n-\n-fs.createWriteStream = function(path, options) {\n+function createWriteStream(path, options) {\n+  lazyLoadStreams();\n   return new WriteStream(path, options);\n-};\n-\n-util.inherits(WriteStream, Writable);\n-fs.WriteStream = WriteStream;\n-function WriteStream(path, options) {\n-  if (!(this instanceof WriteStream))\n-    return new WriteStream(path, options);\n-\n-  options = copyObject(getOptions(options, {}));\n-\n-  // for backwards compat do not emit close on destroy.\n-  options.emitClose = false;\n-\n-  Writable.call(this, options);\n-\n-  // path will be ignored when fd is specified, so it can be falsy\n-  this.path = getPathFromURL(path);\n-  this.fd = options.fd === undefined ? null : options.fd;\n-  this.flags = options.flags === undefined ? 'w' : options.flags;\n-  this.mode = options.mode === undefined ? 0o666 : options.mode;\n-\n-  this.start = options.start;\n-  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;\n-  this.pos = undefined;\n-  this.bytesWritten = 0;\n-  this.closed = false;\n-\n-  if (this.start !== undefined) {\n-    if (typeof this.start !== 'number') {\n-      throw new ERR_INVALID_ARG_TYPE('start', 'number', this.start);\n-    }\n-    if (this.start < 0) {\n-      const errVal = `{start: ${this.start}}`;\n-      throw new ERR_OUT_OF_RANGE('start', '>= 0', errVal);\n-    }\n-\n-    this.pos = this.start;\n-  }\n-\n-  if (options.encoding)\n-    this.setDefaultEncoding(options.encoding);\n-\n-  if (typeof this.fd !== 'number')\n-    this.open();\n }\n \n-fs.FileWriteStream = fs.WriteStream; // support the legacy name\n-\n-WriteStream.prototype._final = function(callback) {\n-  if (this.autoClose) {\n-    this.destroy();\n-  }\n-\n-  callback();\n-};\n-\n-WriteStream.prototype.open = function() {\n-  fs.open(this.path, this.flags, this.mode, (er, fd) => {\n-    if (er) {\n-      if (this.autoClose) {\n-        this.destroy();\n-      }\n-      this.emit('error', er);\n-      return;\n-    }\n-\n-    this.fd = fd;\n-    this.emit('open', fd);\n-    this.emit('ready');\n-  });\n-};\n-\n-\n-WriteStream.prototype._write = function(data, encoding, cb) {\n-  if (!(data instanceof Buffer)) {\n-    const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);\n-    return this.emit('error', err);\n-  }\n-\n-  if (typeof this.fd !== 'number') {\n-    return this.once('open', function() {\n-      this._write(data, encoding, cb);\n-    });\n-  }\n-\n-  fs.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {\n-    if (er) {\n-      if (this.autoClose) {\n-        this.destroy();\n-      }\n-      return cb(er);\n-    }\n-    this.bytesWritten += bytes;\n-    cb();\n-  });\n-\n-  if (this.pos !== undefined)\n-    this.pos += data.length;\n-};\n \n+module.exports = fs = {\n+  appendFile,\n+  appendFileSync,\n+  access,\n+  accessSync,\n+  chown,\n+  chownSync,\n+  chmod,\n+  chmodSync,\n+  close,\n+  closeSync,\n+  copyFile,\n+  copyFileSync,\n+  createReadStream,\n+  createWriteStream,\n+  exists,\n+  existsSync,\n+  fchown,\n+  fchownSync,\n+  fchmod,\n+  fchmodSync,\n+  fdatasync,\n+  fdatasyncSync,\n+  fstat,\n+  fstatSync,\n+  fsync,\n+  fsyncSync,\n+  ftruncate,\n+  ftruncateSync,\n+  futimes,\n+  futimesSync,\n+  lchown: constants.O_SYMLINK !== undefined ? lchown : undefined,\n+  lchownSync: constants.O_SYMLINK !== undefined ? lchownSync : undefined,\n+  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined,\n+  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined,\n+  link,\n+  linkSync,\n+  lstat,\n+  lstatSync,\n+  mkdir,\n+  mkdirSync,\n+  mkdtemp,\n+  mkdtempSync,\n+  open,\n+  openSync,\n+  readdir,\n+  readdirSync,\n+  read,\n+  readSync,\n+  readFile,\n+  readFileSync,\n+  readlink,\n+  readlinkSync,\n+  realpath,\n+  realpathSync,\n+  rename,\n+  renameSync,\n+  rmdir,\n+  rmdirSync,\n+  stat,\n+  statSync,\n+  symlink,\n+  symlinkSync,\n+  truncate,\n+  truncateSync,\n+  unwatchFile,\n+  unlink,\n+  unlinkSync,\n+  utimes,\n+  utimesSync,\n+  watch,\n+  watchFile,\n+  writeFile,\n+  writeFileSync,\n+  write,\n+  writeSync,\n+  Stats,\n \n-function writev(fd, chunks, position, callback) {\n-  function wrapper(err, written) {\n-    // Retain a reference to chunks so that they can't be GC'ed too soon.\n-    callback(err, written || 0, chunks);\n-  }\n+  get ReadStream() {\n+    lazyLoadStreams();\n+    return ReadStream;\n+  },\n \n-  const req = new FSReqWrap();\n-  req.oncomplete = wrapper;\n-  binding.writeBuffers(fd, chunks, position, req);\n-}\n+  set ReadStream(val) {\n+    ReadStream = val;\n+  },\n \n+  get WriteStream() {\n+    lazyLoadStreams();\n+    return WriteStream;\n+  },\n \n-WriteStream.prototype._writev = function(data, cb) {\n-  if (typeof this.fd !== 'number') {\n-    return this.once('open', function() {\n-      this._writev(data, cb);\n-    });\n-  }\n+  set WriteStream(val) {\n+    WriteStream = val;\n+  },\n \n-  const self = this;\n-  const len = data.length;\n-  const chunks = new Array(len);\n-  var size = 0;\n+  // Legacy names... these have to be separate because of how graceful-fs\n+  // (and possibly other) modules monkey patch the values.\n+  get FileReadStream() {\n+    lazyLoadStreams();\n+    return FileReadStream;\n+  },\n \n-  for (var i = 0; i < len; i++) {\n-    var chunk = data[i].chunk;\n+  set FileReadStream(val) {\n+    FileReadStream = val;\n+  },\n \n-    chunks[i] = chunk;\n-    size += chunk.length;\n-  }\n+  get FileWriteStream() {\n+    lazyLoadStreams();\n+    return FileWriteStream;\n+  },\n \n-  writev(this.fd, chunks, this.pos, function(er, bytes) {\n-    if (er) {\n-      self.destroy();\n-      return cb(er);\n-    }\n-    self.bytesWritten += bytes;\n-    cb();\n-  });\n+  set FileWriteStream(val) {\n+    FileWriteStream = val;\n+  },\n \n-  if (this.pos !== undefined)\n-    this.pos += size;\n+  // For tests\n+  _toUnixTimestamp: toUnixTimestamp\n };\n \n-\n-WriteStream.prototype._destroy = ReadStream.prototype._destroy;\n-WriteStream.prototype.close = function(cb) {\n-  if (cb) {\n-    if (this.closed) {\n-      process.nextTick(cb);\n-      return;\n-    } else {\n-      this.on('close', cb);\n+Object.defineProperties(fs, {\n+  F_OK: { enumerable: true, value: F_OK || 0 },\n+  R_OK: { enumerable: true, value: R_OK || 0 },\n+  W_OK: { enumerable: true, value: W_OK || 0 },\n+  X_OK: { enumerable: true, value: X_OK || 0 },\n+  constants: {\n+    configurable: false,\n+    enumerable: true,\n+    value: constants\n+  },\n+  promises: {\n+    configurable: true,\n+    enumerable: false,\n+    get() {\n+      if (promisesWarn) {\n+        promises = require('internal/fs/promises');\n+        promisesWarn = false;\n+        process.emitWarning('The fs.promises API is experimental',\n+                            'ExperimentalWarning');\n+      }\n+      return promises;\n     }\n   }\n-\n-  // If we are not autoClosing, we should call\n-  // destroy on 'finish'.\n-  if (!this.autoClose) {\n-    this.on('finish', this.destroy.bind(this));\n-  }\n-\n-  // we use end() instead of destroy() because of\n-  // https://github.com/nodejs/node/issues/2006\n-  this.end();\n-};\n-\n-// There is no shutdown() for files.\n-WriteStream.prototype.destroySoon = WriteStream.prototype.end;\n+});"
        },
        {
            "sha": "b3e81a5db168abe02ae2191a5e6a6d411e38335a",
            "filename": "lib/internal/fs/read_file_context.js",
            "status": "added",
            "additions": 108,
            "deletions": 0,
            "changes": 108,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Fread_file_context.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Fread_file_context.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fread_file_context.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -0,0 +1,108 @@\n+'use strict';\n+\n+const { Buffer } = require('buffer');\n+const { FSReqWrap, close, read } = process.binding('fs');\n+\n+const kReadFileBufferLength = 8 * 1024;\n+\n+function readFileAfterRead(err, bytesRead) {\n+  const context = this.context;\n+\n+  if (err)\n+    return context.close(err);\n+\n+  if (bytesRead === 0)\n+    return context.close();\n+\n+  context.pos += bytesRead;\n+\n+  if (context.size !== 0) {\n+    if (context.pos === context.size)\n+      context.close();\n+    else\n+      context.read();\n+  } else {\n+    // unknown size, just read until we don't get bytes.\n+    context.buffers.push(context.buffer.slice(0, bytesRead));\n+    context.read();\n+  }\n+}\n+\n+function readFileAfterClose(err) {\n+  const context = this.context;\n+  const callback = context.callback;\n+  let buffer = null;\n+\n+  if (context.err || err)\n+    return callback(context.err || err);\n+\n+  try {\n+    if (context.size === 0)\n+      buffer = Buffer.concat(context.buffers, context.pos);\n+    else if (context.pos < context.size)\n+      buffer = context.buffer.slice(0, context.pos);\n+    else\n+      buffer = context.buffer;\n+\n+    if (context.encoding)\n+      buffer = buffer.toString(context.encoding);\n+  } catch (err) {\n+    return callback(err);\n+  }\n+\n+  callback(null, buffer);\n+}\n+\n+class ReadFileContext {\n+  constructor(callback, encoding) {\n+    this.fd = undefined;\n+    this.isUserFd = undefined;\n+    this.size = undefined;\n+    this.callback = callback;\n+    this.buffers = null;\n+    this.buffer = null;\n+    this.pos = 0;\n+    this.encoding = encoding;\n+    this.err = null;\n+  }\n+\n+  read() {\n+    let buffer;\n+    let offset;\n+    let length;\n+\n+    if (this.size === 0) {\n+      buffer = this.buffer = Buffer.allocUnsafeSlow(kReadFileBufferLength);\n+      offset = 0;\n+      length = kReadFileBufferLength;\n+    } else {\n+      buffer = this.buffer;\n+      offset = this.pos;\n+      length = Math.min(kReadFileBufferLength, this.size - this.pos);\n+    }\n+\n+    const req = new FSReqWrap();\n+    req.oncomplete = readFileAfterRead;\n+    req.context = this;\n+\n+    read(this.fd, buffer, offset, length, -1, req);\n+  }\n+\n+  close(err) {\n+    const req = new FSReqWrap();\n+    req.oncomplete = readFileAfterClose;\n+    req.context = this;\n+    this.err = err;\n+\n+    if (this.isUserFd) {\n+      process.nextTick(function tick() {\n+        req.oncomplete(null);\n+      });\n+      return;\n+    }\n+\n+    close(this.fd, req);\n+  }\n+}\n+\n+module.exports = ReadFileContext;"
        },
        {
            "sha": "f527b1de4b84a4c1cf91107cd06776e06136eb3a",
            "filename": "lib/internal/fs/streams.js",
            "status": "added",
            "additions": 383,
            "deletions": 0,
            "changes": 383,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Fstreams.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Fstreams.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fstreams.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -0,0 +1,383 @@\n+'use strict';\n+\n+const {\n+  FSReqWrap,\n+  writeBuffers\n+} = process.binding('fs');\n+const {\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_OUT_OF_RANGE\n+} = require('internal/errors').codes;\n+const fs = require('fs');\n+const { Buffer } = require('buffer');\n+const {\n+  copyObject,\n+  getOptions,\n+} = require('internal/fs/utils');\n+const { Readable, Writable } = require('stream');\n+const { getPathFromURL } = require('internal/url');\n+const util = require('util');\n+\n+const kMinPoolSpace = 128;\n+\n+let pool;\n+\n+function allocNewPool(poolSize) {\n+  pool = Buffer.allocUnsafe(poolSize);\n+  pool.used = 0;\n+}\n+\n+function ReadStream(path, options) {\n+  if (!(this instanceof ReadStream))\n+    return new ReadStream(path, options);\n+\n+  // a little bit bigger buffer and water marks by default\n+  options = copyObject(getOptions(options, {}));\n+  if (options.highWaterMark === undefined)\n+    options.highWaterMark = 64 * 1024;\n+\n+  // for backwards compat do not emit close on destroy.\n+  options.emitClose = false;\n+\n+  Readable.call(this, options);\n+\n+  // path will be ignored when fd is specified, so it can be falsy\n+  this.path = getPathFromURL(path);\n+  this.fd = options.fd === undefined ? null : options.fd;\n+  this.flags = options.flags === undefined ? 'r' : options.flags;\n+  this.mode = options.mode === undefined ? 0o666 : options.mode;\n+\n+  this.start = options.start;\n+  this.end = options.end;\n+  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n+  this.pos = undefined;\n+  this.bytesRead = 0;\n+  this.closed = false;\n+\n+  if (this.start !== undefined) {\n+    if (!Number.isSafeInteger(this.start)) {\n+      if (typeof this.start !== 'number')\n+        throw new ERR_INVALID_ARG_TYPE('start', 'number', this.start);\n+      if (!Number.isInteger(this.start))\n+        throw new ERR_OUT_OF_RANGE('start', 'an integer', this.start);\n+      throw new ERR_OUT_OF_RANGE(\n+        'start',\n+        '>= 0 and <= 2 ** 53 - 1',\n+        this.start\n+      );\n+    }\n+    if (this.start < 0) {\n+      throw new ERR_OUT_OF_RANGE(\n+        'start',\n+        '>= 0 and <= 2 ** 53 - 1',\n+        this.start\n+      );\n+    }\n+\n+    this.pos = this.start;\n+  }\n+\n+  if (this.end === undefined) {\n+    this.end = Infinity;\n+  } else if (this.end !== Infinity) {\n+    if (!Number.isSafeInteger(this.end)) {\n+      if (typeof this.end !== 'number')\n+        throw new ERR_INVALID_ARG_TYPE('end', 'number', this.end);\n+      if (!Number.isInteger(this.end))\n+        throw new ERR_OUT_OF_RANGE('end', 'an integer', this.end);\n+      throw new ERR_OUT_OF_RANGE('end', '>= 0 and <= 2 ** 53 - 1', this.end);\n+    }\n+\n+    if (this.end < 0) {\n+      throw new ERR_OUT_OF_RANGE('end', '>= 0 and <= 2 ** 53 - 1', this.end);\n+    }\n+\n+    if (this.start !== undefined && this.start > this.end) {\n+      throw new ERR_OUT_OF_RANGE(\n+        'start',\n+        `<= \"end\" (here: ${this.end})`,\n+        this.start\n+      );\n+    }\n+  }\n+\n+  if (typeof this.fd !== 'number')\n+    this.open();\n+\n+  this.on('end', function() {\n+    if (this.autoClose) {\n+      this.destroy();\n+    }\n+  });\n+}\n+util.inherits(ReadStream, Readable);\n+\n+ReadStream.prototype.open = function() {\n+  fs.open(this.path, this.flags, this.mode, (er, fd) => {\n+    if (er) {\n+      if (this.autoClose) {\n+        this.destroy();\n+      }\n+      this.emit('error', er);\n+      return;\n+    }\n+\n+    this.fd = fd;\n+    this.emit('open', fd);\n+    this.emit('ready');\n+    // start the flow of data.\n+    this.read();\n+  });\n+};\n+\n+ReadStream.prototype._read = function(n) {\n+  if (typeof this.fd !== 'number') {\n+    return this.once('open', function() {\n+      this._read(n);\n+    });\n+  }\n+\n+  if (this.destroyed)\n+    return;\n+\n+  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n+    // discard the old pool.\n+    allocNewPool(this.readableHighWaterMark);\n+  }\n+\n+  // Grab another reference to the pool in the case that while we're\n+  // in the thread pool another read() finishes up the pool, and\n+  // allocates a new one.\n+  const thisPool = pool;\n+  let toRead = Math.min(pool.length - pool.used, n);\n+  const start = pool.used;\n+\n+  if (this.pos !== undefined)\n+    toRead = Math.min(this.end - this.pos + 1, toRead);\n+  else\n+    toRead = Math.min(this.end - this.bytesRead + 1, toRead);\n+\n+  // already read everything we were supposed to read!\n+  // treat as EOF.\n+  if (toRead <= 0)\n+    return this.push(null);\n+\n+  // the actual read.\n+  fs.read(this.fd, pool, pool.used, toRead, this.pos, (er, bytesRead) => {\n+    if (er) {\n+      if (this.autoClose) {\n+        this.destroy();\n+      }\n+      this.emit('error', er);\n+    } else {\n+      let b = null;\n+      if (bytesRead > 0) {\n+        this.bytesRead += bytesRead;\n+        b = thisPool.slice(start, start + bytesRead);\n+      }\n+\n+      this.push(b);\n+    }\n+  });\n+\n+  // move the pool positions, and internal position for reading.\n+  if (this.pos !== undefined)\n+    this.pos += toRead;\n+  pool.used += toRead;\n+};\n+\n+ReadStream.prototype._destroy = function(err, cb) {\n+  const isOpen = typeof this.fd !== 'number';\n+  if (isOpen) {\n+    this.once('open', closeFsStream.bind(null, this, cb, err));\n+    return;\n+  }\n+\n+  closeFsStream(this, cb, err);\n+  this.fd = null;\n+};\n+\n+function closeFsStream(stream, cb, err) {\n+  fs.close(stream.fd, (er) => {\n+    er = er || err;\n+    cb(er);\n+    stream.closed = true;\n+    if (!er)\n+      stream.emit('close');\n+  });\n+}\n+\n+ReadStream.prototype.close = function(cb) {\n+  this.destroy(null, cb);\n+};\n+\n+function WriteStream(path, options) {\n+  if (!(this instanceof WriteStream))\n+    return new WriteStream(path, options);\n+\n+  options = copyObject(getOptions(options, {}));\n+\n+  // for backwards compat do not emit close on destroy.\n+  options.emitClose = false;\n+\n+  Writable.call(this, options);\n+\n+  // path will be ignored when fd is specified, so it can be falsy\n+  this.path = getPathFromURL(path);\n+  this.fd = options.fd === undefined ? null : options.fd;\n+  this.flags = options.flags === undefined ? 'w' : options.flags;\n+  this.mode = options.mode === undefined ? 0o666 : options.mode;\n+\n+  this.start = options.start;\n+  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;\n+  this.pos = undefined;\n+  this.bytesWritten = 0;\n+  this.closed = false;\n+\n+  if (this.start !== undefined) {\n+    if (typeof this.start !== 'number') {\n+      throw new ERR_INVALID_ARG_TYPE('start', 'number', this.start);\n+    }\n+    if (this.start < 0) {\n+      const errVal = `{start: ${this.start}}`;\n+      throw new ERR_OUT_OF_RANGE('start', '>= 0', errVal);\n+    }\n+\n+    this.pos = this.start;\n+  }\n+\n+  if (options.encoding)\n+    this.setDefaultEncoding(options.encoding);\n+\n+  if (typeof this.fd !== 'number')\n+    this.open();\n+}\n+util.inherits(WriteStream, Writable);\n+\n+WriteStream.prototype._final = function(callback) {\n+  if (this.autoClose) {\n+    this.destroy();\n+  }\n+\n+  callback();\n+};\n+\n+WriteStream.prototype.open = function() {\n+  fs.open(this.path, this.flags, this.mode, (er, fd) => {\n+    if (er) {\n+      if (this.autoClose) {\n+        this.destroy();\n+      }\n+      this.emit('error', er);\n+      return;\n+    }\n+\n+    this.fd = fd;\n+    this.emit('open', fd);\n+    this.emit('ready');\n+  });\n+};\n+\n+\n+WriteStream.prototype._write = function(data, encoding, cb) {\n+  if (!(data instanceof Buffer)) {\n+    const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);\n+    return this.emit('error', err);\n+  }\n+\n+  if (typeof this.fd !== 'number') {\n+    return this.once('open', function() {\n+      this._write(data, encoding, cb);\n+    });\n+  }\n+\n+  fs.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {\n+    if (er) {\n+      if (this.autoClose) {\n+        this.destroy();\n+      }\n+      return cb(er);\n+    }\n+    this.bytesWritten += bytes;\n+    cb();\n+  });\n+\n+  if (this.pos !== undefined)\n+    this.pos += data.length;\n+};\n+\n+\n+function writev(fd, chunks, position, callback) {\n+  function wrapper(err, written) {\n+    // Retain a reference to chunks so that they can't be GC'ed too soon.\n+    callback(err, written || 0, chunks);\n+  }\n+\n+  const req = new FSReqWrap();\n+  req.oncomplete = wrapper;\n+  writeBuffers(fd, chunks, position, req);\n+}\n+\n+\n+WriteStream.prototype._writev = function(data, cb) {\n+  if (typeof this.fd !== 'number') {\n+    return this.once('open', function() {\n+      this._writev(data, cb);\n+    });\n+  }\n+\n+  const self = this;\n+  const len = data.length;\n+  const chunks = new Array(len);\n+  let size = 0;\n+\n+  for (var i = 0; i < len; i++) {\n+    const chunk = data[i].chunk;\n+\n+    chunks[i] = chunk;\n+    size += chunk.length;\n+  }\n+\n+  writev(this.fd, chunks, this.pos, function(er, bytes) {\n+    if (er) {\n+      self.destroy();\n+      return cb(er);\n+    }\n+    self.bytesWritten += bytes;\n+    cb();\n+  });\n+\n+  if (this.pos !== undefined)\n+    this.pos += size;\n+};\n+\n+\n+WriteStream.prototype._destroy = ReadStream.prototype._destroy;\n+WriteStream.prototype.close = function(cb) {\n+  if (cb) {\n+    if (this.closed) {\n+      process.nextTick(cb);\n+      return;\n+    } else {\n+      this.on('close', cb);\n+    }\n+  }\n+\n+  // If we are not autoClosing, we should call\n+  // destroy on 'finish'.\n+  if (!this.autoClose) {\n+    this.on('finish', this.destroy.bind(this));\n+  }\n+\n+  // we use end() instead of destroy() because of\n+  // https://github.com/nodejs/node/issues/2006\n+  this.end();\n+};\n+\n+// There is no shutdown() for files.\n+WriteStream.prototype.destroySoon = WriteStream.prototype.end;\n+\n+module.exports = {\n+  ReadStream,\n+  WriteStream\n+};"
        },
        {
            "sha": "b365474663d8c2023267ff0503a9b02aae77f642",
            "filename": "lib/internal/fs/sync_write_stream.js",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Fsync_write_stream.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Fsync_write_stream.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fsync_write_stream.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -0,0 +1,45 @@\n+'use strict';\n+\n+const { Writable } = require('stream');\n+const { inherits } = require('util');\n+const { closeSync, writeSync } = require('fs');\n+\n+function SyncWriteStream(fd, options) {\n+  Writable.call(this);\n+\n+  options = options || {};\n+\n+  this.fd = fd;\n+  this.readable = false;\n+  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n+\n+  this.on('end', () => this._destroy());\n+}\n+\n+inherits(SyncWriteStream, Writable);\n+\n+SyncWriteStream.prototype._write = function(chunk, encoding, cb) {\n+  writeSync(this.fd, chunk, 0, chunk.length);\n+  cb();\n+  return true;\n+};\n+\n+SyncWriteStream.prototype._destroy = function() {\n+  if (this.fd === null) // already destroy()ed\n+    return;\n+\n+  if (this.autoClose)\n+    closeSync(this.fd);\n+\n+  this.fd = null;\n+  return true;\n+};\n+\n+SyncWriteStream.prototype.destroySoon =\n+SyncWriteStream.prototype.destroy = function() {\n+  this._destroy();\n+  this.emit('close');\n+  return true;\n+};\n+\n+module.exports = SyncWriteStream;"
        },
        {
            "sha": "a8c64e2b04d56b25f9cde0d1177ea9880ea9887d",
            "filename": "lib/internal/fs/utils.js",
            "status": "modified",
            "additions": 0,
            "deletions": 42,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Futils.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Futils.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Futils.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -1,7 +1,6 @@\n 'use strict';\n \n const { Buffer, kMaxLength } = require('buffer');\n-const { Writable } = require('stream');\n const {\n   ERR_FS_INVALID_SYMLINK_TYPE,\n   ERR_INVALID_ARG_TYPE,\n@@ -11,7 +10,6 @@ const {\n   ERR_OUT_OF_RANGE\n } = require('internal/errors').codes;\n const { isUint8Array } = require('internal/util/types');\n-const fs = require('fs');\n const pathModule = require('path');\n const util = require('util');\n \n@@ -256,45 +254,6 @@ function stringToSymlinkType(type) {\n   return flags;\n }\n \n-// Temporary hack for process.stdout and process.stderr when piped to files.\n-function SyncWriteStream(fd, options) {\n-  Writable.call(this);\n-\n-  options = options || {};\n-\n-  this.fd = fd;\n-  this.readable = false;\n-  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n-\n-  this.on('end', () => this._destroy());\n-}\n-\n-util.inherits(SyncWriteStream, Writable);\n-\n-SyncWriteStream.prototype._write = function(chunk, encoding, cb) {\n-  fs.writeSync(this.fd, chunk, 0, chunk.length);\n-  cb();\n-  return true;\n-};\n-\n-SyncWriteStream.prototype._destroy = function() {\n-  if (this.fd === null) // already destroy()ed\n-    return;\n-\n-  if (this.autoClose)\n-    fs.closeSync(this.fd);\n-\n-  this.fd = null;\n-  return true;\n-};\n-\n-SyncWriteStream.prototype.destroySoon =\n-SyncWriteStream.prototype.destroy = function() {\n-  this._destroy();\n-  this.emit('close');\n-  return true;\n-};\n-\n // converts Date or number to a fractional UNIX timestamp\n function toUnixTimestamp(time, name = 'time') {\n   // eslint-disable-next-line eqeqeq\n@@ -383,7 +342,6 @@ module.exports = {\n   stringToFlags,\n   stringToSymlinkType,\n   Stats,\n-  SyncWriteStream,\n   toUnixTimestamp,\n   validateBuffer,\n   validateOffsetLengthRead,"
        },
        {
            "sha": "685d5be5e4db3f3eaccc19736818e8d55406050f",
            "filename": "lib/internal/fs/watchers.js",
            "status": "added",
            "additions": 168,
            "deletions": 0,
            "changes": 168,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Fwatchers.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Ffs%2Fwatchers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fwatchers.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -0,0 +1,168 @@\n+'use strict';\n+\n+const errors = require('internal/errors');\n+const {\n+  kFsStatsFieldsLength,\n+  StatWatcher: _StatWatcher\n+} = process.binding('fs');\n+const { FSEvent } = process.binding('fs_event_wrap');\n+const { EventEmitter } = require('events');\n+const {\n+  getStatsFromBinding,\n+  validatePath\n+} = require('internal/fs/utils');\n+const { toNamespacedPath } = require('path');\n+const { validateUint32 } = require('internal/validators');\n+const { getPathFromURL } = require('internal/url');\n+const util = require('util');\n+const assert = require('assert');\n+\n+function emitStop(self) {\n+  self.emit('stop');\n+}\n+\n+function StatWatcher() {\n+  EventEmitter.call(this);\n+\n+  this._handle = new _StatWatcher();\n+\n+  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n+  // the sake of backwards compatibility\n+  let oldStatus = -1;\n+\n+  this._handle.onchange = (newStatus, stats) => {\n+    if (oldStatus === -1 &&\n+        newStatus === -1 &&\n+        stats[2/* new nlink */] === stats[16/* old nlink */]) return;\n+\n+    oldStatus = newStatus;\n+    this.emit('change', getStatsFromBinding(stats),\n+              getStatsFromBinding(stats, kFsStatsFieldsLength));\n+  };\n+\n+  this._handle.onstop = () => {\n+    process.nextTick(emitStop, this);\n+  };\n+}\n+util.inherits(StatWatcher, EventEmitter);\n+\n+\n+// FIXME(joyeecheung): this method is not documented.\n+// At the moment if filename is undefined, we\n+// 1. Throw an Error if it's the first time .start() is called\n+// 2. Return silently if .start() has already been called\n+//    on a valid filename and the wrap has been initialized\n+// This method is a noop if the watcher has already been started.\n+StatWatcher.prototype.start = function(filename, persistent, interval) {\n+  assert(this._handle instanceof _StatWatcher, 'handle must be a StatWatcher');\n+  if (this._handle.isActive) {\n+    return;\n+  }\n+\n+  filename = getPathFromURL(filename);\n+  validatePath(filename, 'filename');\n+  validateUint32(interval, 'interval');\n+  const err = this._handle.start(toNamespacedPath(filename),\n+                                 persistent, interval);\n+  if (err) {\n+    const error = errors.uvException({\n+      errno: err,\n+      syscall: 'watch',\n+      path: filename\n+    });\n+    error.filename = filename;\n+    throw error;\n+  }\n+};\n+\n+// FIXME(joyeecheung): this method is not documented while there is\n+// another documented fs.unwatchFile(). The counterpart in\n+// FSWatcher is .close()\n+// This method is a noop if the watcher has not been started.\n+StatWatcher.prototype.stop = function() {\n+  assert(this._handle instanceof _StatWatcher, 'handle must be a StatWatcher');\n+  if (!this._handle.isActive) {\n+    return;\n+  }\n+  this._handle.stop();\n+};\n+\n+\n+function FSWatcher() {\n+  EventEmitter.call(this);\n+\n+  this._handle = new FSEvent();\n+  this._handle.owner = this;\n+\n+  this._handle.onchange = (status, eventType, filename) => {\n+    // TODO(joyeecheung): we may check self._handle.initialized here\n+    // and return if that is false. This allows us to avoid firing the event\n+    // after the handle is closed, and to fire both UV_RENAME and UV_CHANGE\n+    // if they are set by libuv at the same time.\n+    if (status < 0) {\n+      this._handle.close();\n+      const error = errors.uvException({\n+        errno: status,\n+        syscall: 'watch',\n+        path: filename\n+      });\n+      error.filename = filename;\n+      this.emit('error', error);\n+    } else {\n+      this.emit('change', eventType, filename);\n+    }\n+  };\n+}\n+util.inherits(FSWatcher, EventEmitter);\n+\n+// FIXME(joyeecheung): this method is not documented.\n+// At the moment if filename is undefined, we\n+// 1. Throw an Error if it's the first time .start() is called\n+// 2. Return silently if .start() has already been called\n+//    on a valid filename and the wrap has been initialized\n+// This method is a noop if the watcher has already been started.\n+FSWatcher.prototype.start = function(filename,\n+                                     persistent,\n+                                     recursive,\n+                                     encoding) {\n+  assert(this._handle instanceof FSEvent, 'handle must be a FSEvent');\n+  if (this._handle.initialized) {\n+    return;\n+  }\n+\n+  filename = getPathFromURL(filename);\n+  validatePath(filename, 'filename');\n+\n+  const err = this._handle.start(toNamespacedPath(filename),\n+                                 persistent,\n+                                 recursive,\n+                                 encoding);\n+  if (err) {\n+    const error = errors.uvException({\n+      errno: err,\n+      syscall: 'watch',\n+      path: filename\n+    });\n+    error.filename = filename;\n+    throw error;\n+  }\n+};\n+\n+// This method is a noop if the watcher has not been started.\n+FSWatcher.prototype.close = function() {\n+  assert(this._handle instanceof FSEvent, 'handle must be a FSEvent');\n+  if (!this._handle.initialized) {\n+    return;\n+  }\n+  this._handle.close();\n+  process.nextTick(emitCloseNT, this);\n+};\n+\n+function emitCloseNT(self) {\n+  self.emit('close');\n+}\n+\n+module.exports = {\n+  FSWatcher,\n+  StatWatcher\n+};"
        },
        {
            "sha": "eaba4dfca13a47d032a8f6f65ed261e656701e55",
            "filename": "lib/internal/process/stdio.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Fprocess%2Fstdio.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/lib%2Finternal%2Fprocess%2Fstdio.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fstdio.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -167,8 +167,8 @@ function createWritableStdioStream(fd) {\n       break;\n \n     case 'FILE':\n-      var fs = require('internal/fs/utils');\n-      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n+      const SyncWriteStream = require('internal/fs/sync_write_stream');\n+      stream = new SyncWriteStream(fd, { autoClose: false });\n       stream._type = 'fs';\n       break;\n "
        },
        {
            "sha": "bf768c1995cd20d0627814ec84c70a623360483a",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -104,7 +104,11 @@\n       'lib/internal/fixed_queue.js',\n       'lib/internal/freelist.js',\n       'lib/internal/fs/promises.js',\n+      'lib/internal/fs/read_file_context.js',\n+      'lib/internal/fs/streams.js',\n+      'lib/internal/fs/sync_write_stream.js',\n       'lib/internal/fs/utils.js',\n+      'lib/internal/fs/watchers.js',\n       'lib/internal/http.js',\n       'lib/internal/inspector_async_hook.js',\n       'lib/internal/linkedlist.js',"
        },
        {
            "sha": "c1e39244b359b49f31b941a50b4f03dc5918fcd0",
            "filename": "src/node_constants.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 3,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/src%2Fnode_constants.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/src%2Fnode_constants.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_constants.cc?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -1162,6 +1162,27 @@ void DefineSystemConstants(Local<Object> target) {\n #ifdef X_OK\n   NODE_DEFINE_CONSTANT(target, X_OK);\n #endif\n+\n+#ifdef UV_FS_COPYFILE_EXCL\n+# define COPYFILE_EXCL UV_FS_COPYFILE_EXCL\n+  NODE_DEFINE_CONSTANT(target, UV_FS_COPYFILE_EXCL);\n+  NODE_DEFINE_CONSTANT(target, COPYFILE_EXCL);\n+# undef COPYFILE_EXCL\n+#endif\n+\n+#ifdef UV_FS_COPYFILE_FICLONE\n+# define COPYFILE_FICLONE UV_FS_COPYFILE_FICLONE\n+  NODE_DEFINE_CONSTANT(target, UV_FS_COPYFILE_FICLONE);\n+  NODE_DEFINE_CONSTANT(target, COPYFILE_FICLONE);\n+# undef COPYFILE_FICLONE\n+#endif\n+\n+#ifdef UV_FS_COPYFILE_FICLONE_FORCE\n+# define COPYFILE_FICLONE_FORCE UV_FS_COPYFILE_FICLONE_FORCE\n+  NODE_DEFINE_CONSTANT(target, UV_FS_COPYFILE_FICLONE_FORCE);\n+  NODE_DEFINE_CONSTANT(target, COPYFILE_FICLONE_FORCE);\n+# undef COPYFILE_FICLONE_FORCE\n+#endif\n }\n \n void DefineCryptoConstants(Local<Object> target) {\n@@ -1305,9 +1326,6 @@ void DefineConstants(v8::Isolate* isolate, Local<Object> target) {\n \n   // Define libuv constants.\n   NODE_DEFINE_CONSTANT(os_constants, UV_UDP_REUSEADDR);\n-  NODE_DEFINE_CONSTANT(fs_constants, UV_FS_COPYFILE_EXCL);\n-  NODE_DEFINE_CONSTANT(fs_constants, UV_FS_COPYFILE_FICLONE);\n-  NODE_DEFINE_CONSTANT(fs_constants, UV_FS_COPYFILE_FICLONE_FORCE);\n \n   os_constants->Set(OneByteString(isolate, \"dlopen\"), dlopen_constants);\n   os_constants->Set(OneByteString(isolate, \"errno\"), err_constants);"
        },
        {
            "sha": "49c29e073818e8df9e7eda8273246dbe59572325",
            "filename": "test/parallel/test-internal-fs-syncwritestream.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/test%2Fparallel%2Ftest-internal-fs-syncwritestream.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/test%2Fparallel%2Ftest-internal-fs-syncwritestream.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-internal-fs-syncwritestream.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -5,7 +5,7 @@ const common = require('../common');\n const assert = require('assert');\n const fs = require('fs');\n const path = require('path');\n-const SyncWriteStream = require('internal/fs/utils').SyncWriteStream;\n+const SyncWriteStream = require('internal/fs/sync_write_stream');\n \n const tmpdir = require('../common/tmpdir');\n tmpdir.refresh();"
        },
        {
            "sha": "79b313195bc94762875a3cce819f8529c260672a",
            "filename": "test/parallel/test-repl-underscore.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/test%2Fparallel%2Ftest-repl-underscore.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/test%2Fparallel%2Ftest-repl-underscore.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-repl-underscore.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -178,7 +178,7 @@ function testError() {\n \n       // The sync error, with individual property echoes\n       /Error: ENOENT: no such file or directory, scandir '.*nonexistent.*'/,\n-      /fs\\.readdirSync/,\n+      /Object\\.readdirSync/,\n       \"'ENOENT'\",\n       \"'scandir'\",\n "
        },
        {
            "sha": "3dfe622963a0e249c3d27defb22a30483473093f",
            "filename": "test/parallel/test-sync-io-option.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/7f0f978affda555c5f7151f2d6abd212e753d4f1/test%2Fparallel%2Ftest-sync-io-option.js",
            "raw_url": "https://github.com/nodejs/node/raw/7f0f978affda555c5f7151f2d6abd212e753d4f1/test%2Fparallel%2Ftest-sync-io-option.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-sync-io-option.js?ref=7f0f978affda555c5f7151f2d6abd212e753d4f1",
            "patch": "@@ -20,7 +20,7 @@ if (process.argv[2] === 'child') {\n     execFile(process.execPath, args, function(err, stdout, stderr) {\n       assert.strictEqual(err, null);\n       assert.strictEqual(stdout, '');\n-      if (/WARNING[\\s\\S]*fs\\.readFileSync/.test(stderr))\n+      if (/WARNING[\\s\\S]*readFileSync/.test(stderr))\n         cntr++;\n       if (args[0] === '--trace-sync-io') {\n         assert.strictEqual(cntr, 1);"
        }
    ],
    "stats": {
        "total": 2166,
        "additions": 1164,
        "deletions": 1002
    }
}