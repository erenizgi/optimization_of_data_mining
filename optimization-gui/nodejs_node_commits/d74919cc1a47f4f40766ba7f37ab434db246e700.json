{
    "author": "Trott",
    "message": "doc: improve Buffer() text\n\nRewording, punctuation, consistent sentence structure and italics, wrap\nsection at 80 characters.\n\nPR-URL: https://github.com/nodejs/node/pull/19567\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Gibson Fahnestock <gibfahn@gmail.com>",
    "sha": "d74919cc1a47f4f40766ba7f37ab434db246e700",
    "files": [
        {
            "sha": "bcde11de66314b03994722878b9a1d405b3ddbd1",
            "filename": "doc/api/buffer.md",
            "status": "modified",
            "additions": 24,
            "deletions": 24,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/d74919cc1a47f4f40766ba7f37ab434db246e700/doc%2Fapi%2Fbuffer.md",
            "raw_url": "https://github.com/nodejs/node/raw/d74919cc1a47f4f40766ba7f37ab434db246e700/doc%2Fapi%2Fbuffer.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fbuffer.md?ref=d74919cc1a47f4f40766ba7f37ab434db246e700",
            "patch": "@@ -52,53 +52,53 @@ In versions of Node.js prior to 6.0.0, `Buffer` instances were created using the\n `Buffer` constructor function, which allocates the returned `Buffer`\n differently based on what arguments are provided:\n \n-* Passing a number as the first argument to `Buffer()` (e.g. `new Buffer(10)`),\n+* Passing a number as the first argument to `Buffer()` (e.g. `new Buffer(10)`)\n   allocates a new `Buffer` object of the specified size. Prior to Node.js 8.0.0,\n   the memory allocated for such `Buffer` instances is *not* initialized and\n   *can contain sensitive data*. Such `Buffer` instances *must* be subsequently\n   initialized by using either [`buf.fill(0)`][`buf.fill()`] or by writing to the\n-  `Buffer` completely. While this behavior is *intentional* to improve\n-  performance, development experience has demonstrated that a more explicit\n-  distinction is required between creating a fast-but-uninitialized `Buffer`\n-  versus creating a slower-but-safer `Buffer`. Starting in Node.js 8.0.0,\n-  `Buffer(num)` and `new Buffer(num)` will return a `Buffer` with initialized\n-  memory.\n+  entire `Buffer`. While this behavior is *intentional* to improve performance,\n+  development experience has demonstrated that a more explicit distinction is\n+  required between creating a fast-but-uninitialized `Buffer` versus creating a\n+  slower-but-safer `Buffer`. Starting in Node.js 8.0.0,  `Buffer(num)` and\n+  `new Buffer(num)` will return a `Buffer` with initialized memory.\n * Passing a string, array, or `Buffer` as the first argument copies the\n   passed object's data into the `Buffer`.\n * Passing an [`ArrayBuffer`] or a [`SharedArrayBuffer`] returns a `Buffer` that\n   shares allocated memory with the given array buffer.\n \n Because the behavior of `new Buffer()` is different depending on the type of the\n-first argument, security and reliability issues can be inadvertantly introduced\n-into applications when argument validation or `Buffer` initialization are not\n+first argument, security and reliability issues can be inadvertently introduced\n+into applications when argument validation or `Buffer` initialization is not\n performed.\n \n-To make the creation of `Buffer` instances more reliable and less error prone,\n+To make the creation of `Buffer` instances more reliable and less error-prone,\n the various forms of the `new Buffer()` constructor have been **deprecated**\n and replaced by separate `Buffer.from()`, [`Buffer.alloc()`], and\n [`Buffer.allocUnsafe()`] methods.\n \n *Developers should migrate all existing uses of the `new Buffer()` constructors\n to one of these new APIs.*\n \n-* [`Buffer.from(array)`] returns a new `Buffer` containing a *copy* of the provided\n-  octets.\n+* [`Buffer.from(array)`] returns a new `Buffer` that *contains a copy* of the\n+  provided octets.\n * [`Buffer.from(arrayBuffer[, byteOffset [, length]])`][`Buffer.from(arrayBuffer)`]\n-  returns a new `Buffer` that *shares* the same allocated memory as the given\n+  returns a new `Buffer` that *shares the same allocated memory* as the given\n   [`ArrayBuffer`].\n-* [`Buffer.from(buffer)`] returns a new `Buffer` containing a *copy* of the\n+* [`Buffer.from(buffer)`] returns a new `Buffer` that *contains a copy* of the\n   contents of the given `Buffer`.\n-* [`Buffer.from(string[, encoding])`][`Buffer.from(string)`] returns a new `Buffer`\n-  containing a *copy* of the provided string.\n-* [`Buffer.alloc(size[, fill[, encoding]])`][`Buffer.alloc()`] returns a \"filled\"\n-  `Buffer` instance of the specified size. This method can be significantly\n-  slower than [`Buffer.allocUnsafe(size)`][`Buffer.allocUnsafe()`] but ensures\n-  that newly created `Buffer` instances never contain old and potentially\n-  sensitive data.\n+* [`Buffer.from(string[, encoding])`][`Buffer.from(string)`] returns a new\n+  `Buffer` that *contains a copy* of the provided string.\n+* [`Buffer.alloc(size[, fill[, encoding]])`][`Buffer.alloc()`] returns a new\n+  initialized `Buffer` of the specified size. This method is slower than\n+  [`Buffer.allocUnsafe(size)`][`Buffer.allocUnsafe()`] but guarantees that newly\n+  created `Buffer` instances never contain old data that is potentially\n+  sensitive.\n * [`Buffer.allocUnsafe(size)`][`Buffer.allocUnsafe()`] and\n   [`Buffer.allocUnsafeSlow(size)`][`Buffer.allocUnsafeSlow()`] each return a\n-  new `Buffer` of the specified `size` whose content *must* be initialized\n-  using either [`buf.fill(0)`][`buf.fill()`] or written to completely.\n+  new uninitialized `Buffer` of the specified `size`. Because the `Buffer` is\n+  uninitialized, the allocated segment of memory might contain old data that is\n+  potentially sensitive.\n \n `Buffer` instances returned by [`Buffer.allocUnsafe()`] *may* be allocated off\n a shared internal memory pool if `size` is less than or equal to half\n@@ -117,7 +117,7 @@ force all newly allocated `Buffer` instances created using either\n this flag *changes the default behavior* of these methods and *can have a significant\n impact* on performance. Use of the `--zero-fill-buffers` option is recommended\n only when necessary to enforce that newly allocated `Buffer` instances cannot\n-contain potentially sensitive data.\n+contain old data that is potentially sensitive.\n \n ```txt\n $ node --zero-fill-buffers"
        }
    ],
    "stats": {
        "total": 48,
        "additions": 24,
        "deletions": 24
    }
}