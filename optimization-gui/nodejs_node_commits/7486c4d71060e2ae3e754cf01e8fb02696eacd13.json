{
    "author": "cjihrig",
    "message": "dns: add promisified dns module\n\nPR-URL: https://github.com/nodejs/node/pull/21264\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>",
    "sha": "7486c4d71060e2ae3e754cf01e8fb02696eacd13",
    "files": [
        {
            "sha": "624bcc279d24797c8c061cdb4965f239db925e1c",
            "filename": "doc/api/dns.md",
            "status": "modified",
            "additions": 466,
            "deletions": 0,
            "changes": 466,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/doc%2Fapi%2Fdns.md",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/doc%2Fapi%2Fdns.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fdns.md?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -568,6 +568,456 @@ An error will be thrown if an invalid address is provided.\n The `dns.setServers()` method must not be called while a DNS query is in\n progress.\n \n+## DNS Promises API\n+\n+> Stability: 1 - Experimental\n+\n+The `dns.promises` API provides an alternative set of asynchronous DNS methods\n+that return `Promise` objects rather than using callbacks. The API is accessible\n+via `require('dns').promises`.\n+\n+### Class: dnsPromises.Resolver\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+An independent resolver for DNS requests.\n+\n+Note that creating a new resolver uses the default server settings. Setting\n+the servers used for a resolver using\n+[`resolver.setServers()`][`dnsPromises.setServers()`] does not affect\n+other resolvers:\n+\n+```js\n+const { Resolver } = require('dns').promises;\n+const resolver = new Resolver();\n+resolver.setServers(['4.4.4.4']);\n+\n+// This request will use the server at 4.4.4.4, independent of global settings.\n+resolver.resolve4('example.org').then((addresses) => {\n+  // ...\n+});\n+\n+// Alternatively, the same code can be written using async-await style.\n+(async function() {\n+  const addresses = await resolver.resolve4('example.org');\n+})();\n+```\n+\n+The following methods from the `dnsPromises` API are available:\n+\n+* [`resolver.getServers()`][`dnsPromises.getServers()`]\n+* [`resolver.setServers()`][`dnsPromises.setServers()`]\n+* [`resolver.resolve()`][`dnsPromises.resolve()`]\n+* [`resolver.resolve4()`][`dnsPromises.resolve4()`]\n+* [`resolver.resolve6()`][`dnsPromises.resolve6()`]\n+* [`resolver.resolveAny()`][`dnsPromises.resolveAny()`]\n+* [`resolver.resolveCname()`][`dnsPromises.resolveCname()`]\n+* [`resolver.resolveMx()`][`dnsPromises.resolveMx()`]\n+* [`resolver.resolveNaptr()`][`dnsPromises.resolveNaptr()`]\n+* [`resolver.resolveNs()`][`dnsPromises.resolveNs()`]\n+* [`resolver.resolvePtr()`][`dnsPromises.resolvePtr()`]\n+* [`resolver.resolveSoa()`][`dnsPromises.resolveSoa()`]\n+* [`resolver.resolveSrv()`][`dnsPromises.resolveSrv()`]\n+* [`resolver.resolveTxt()`][`dnsPromises.resolveTxt()`]\n+* [`resolver.reverse()`][`dnsPromises.reverse()`]\n+\n+#### resolver.cancel()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Cancel all outstanding DNS queries made by this resolver. The corresponding\n+`Promise`s will be rejected with an error with code `ECANCELLED`.\n+\n+### dnsPromises.getServers()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {string[]}\n+\n+Returns an array of IP address strings, formatted according to [rfc5952][],\n+that are currently configured for DNS resolution. A string will include a port\n+section if a custom port is used.\n+\n+<!-- eslint-disable semi-->\n+```js\n+[\n+  '4.4.4.4',\n+  '2001:4860:4860::8888',\n+  '4.4.4.4:1053',\n+  '[2001:4860:4860::8888]:1053'\n+]\n+```\n+\n+### dnsPromises.lookup(hostname[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+- `options` {integer | Object}\n+  - `family` {integer} The record family. Must be `4` or `6`. IPv4\n+    and IPv6 addresses are both returned by default.\n+  - `hints` {number} One or more [supported `getaddrinfo` flags][]. Multiple\n+    flags may be passed by bitwise `OR`ing their values.\n+  - `all` {boolean} When `true`, the `Promise` is resolved with all addresses in\n+    an array. Otherwise, returns a single address. **Default:** `false`.\n+  - `verbatim` {boolean} When `true`, the `Promise` is resolved with IPv4 and\n+    IPv6 addresses in the order the DNS resolver returned them. When `false`,\n+    IPv4 addresses are placed before IPv6 addresses.\n+    **Default:** currently `false` (addresses are reordered) but this is\n+    expected to change in the not too distant future.\n+    New code should use `{ verbatim: true }`.\n+\n+Resolves a hostname (e.g. `'nodejs.org'`) into the first found A (IPv4) or\n+AAAA (IPv6) record. All `option` properties are optional. If `options` is an\n+integer, then it must be `4` or `6` â€“ if `options` is not provided, then IPv4\n+and IPv6 addresses are both returned if found.\n+\n+With the `all` option set to `true`, the `Promise` is resolved with `addresses`\n+being an array of objects with the properties `address` and `family`.\n+\n+On error, the `Promise` is rejected with an [`Error`][] object, where `err.code`\n+is the error code.\n+Keep in mind that `err.code` will be set to `'ENOENT'` not only when\n+the hostname does not exist but also when the lookup fails in other ways\n+such as no available file descriptors.\n+\n+[`dnsPromises.lookup()`][] does not necessarily have anything to do with the DNS\n+protocol. The implementation uses an operating system facility that can\n+associate names with addresses, and vice versa. This implementation can have\n+subtle but important consequences on the behavior of any Node.js program. Please\n+take some time to consult the [Implementation considerations section][] before\n+using `dnsPromises.lookup()`.\n+\n+Example usage:\n+\n+```js\n+const dns = require('dns');\n+const dnsPromises = dns.promises;\n+const options = {\n+  family: 6,\n+  hints: dns.ADDRCONFIG | dns.V4MAPPED,\n+};\n+\n+dnsPromises.lookup('example.com', options).then((result) => {\n+  console.log('address: %j family: IPv%s', result.address, result.family);\n+  // address: \"2606:2800:220:1:248:1893:25c8:1946\" family: IPv6\n+});\n+\n+// When options.all is true, the result will be an Array.\n+options.all = true;\n+dnsPromises.lookup('example.com', options).then((result) => {\n+  console.log('addresses: %j', result);\n+  // addresses: [{\"address\":\"2606:2800:220:1:248:1893:25c8:1946\",\"family\":6}]\n+});\n+```\n+\n+### dnsPromises.lookupService(address, port)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `address` {string}\n+- `port` {number}\n+\n+Resolves the given `address` and `port` into a hostname and service using\n+the operating system's underlying `getnameinfo` implementation.\n+\n+If `address` is not a valid IP address, a `TypeError` will be thrown.\n+The `port` will be coerced to a number. If it is not a legal port, a `TypeError`\n+will be thrown.\n+\n+On error, the `Promise` is rejected with an [`Error`][] object, where `err.code`\n+is the error code.\n+\n+```js\n+const dnsPromises = require('dns').promises;\n+dnsPromises.lookupService('127.0.0.1', 22).then((result) => {\n+  console.log(result.hostname, result.service);\n+  // Prints: localhost ssh\n+});\n+```\n+\n+### dnsPromises.resolve(hostname[, rrtype])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string} Hostname to resolve.\n+- `rrtype` {string} Resource record type. **Default:** `'A'`.\n+\n+Uses the DNS protocol to resolve a hostname (e.g. `'nodejs.org'`) into an array\n+of the resource records. When successful, the `Promise` is resolved with an\n+array of resource records. The type and structure of individual results vary\n+based on `rrtype`:\n+\n+|  `rrtype` | `records` contains             | Result type | Shorthand method         |\n+|-----------|--------------------------------|-------------|--------------------------|\n+| `'A'`     | IPv4 addresses (default)       | {string}    | [`dnsPromises.resolve4()`][]     |\n+| `'AAAA'`  | IPv6 addresses                 | {string}    | [`dnsPromises.resolve6()`][]     |\n+| `'CNAME'` | canonical name records         | {string}    | [`dnsPromises.resolveCname()`][] |\n+| `'MX'`    | mail exchange records          | {Object}    | [`dnsPromises.resolveMx()`][]    |\n+| `'NAPTR'` | name authority pointer records | {Object}    | [`dnsPromises.resolveNaptr()`][] |\n+| `'NS'`    | name server records            | {string}    | [`dnsPromises.resolveNs()`][]    |\n+| `'PTR'`   | pointer records                | {string}    | [`dnsPromises.resolvePtr()`][]   |\n+| `'SOA'`   | start of authority records     | {Object}    | [`dnsPromises.resolveSoa()`][]   |\n+| `'SRV'`   | service records                | {Object}    | [`dnsPromises.resolveSrv()`][]   |\n+| `'TXT'`   | text records                   | {string[]}  | [`dnsPromises.resolveTxt()`][]   |\n+| `'ANY'`   | any records                    | {Object}    | [`dnsPromises.resolveAny()`][]   |\n+\n+On error, the `Promise` is rejected with an [`Error`][] object, where `err.code`\n+is one of the [DNS error codes](#dns_error_codes).\n+\n+### dnsPromises.resolve4(hostname[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string} Hostname to resolve.\n+- `options` {Object}\n+  - `ttl` {boolean} Retrieve the Time-To-Live value (TTL) of each record.\n+    When `true`, the `Promise` is resolved with an array of\n+    `{ address: '1.2.3.4', ttl: 60 }` objects rather than an array of strings,\n+    with the TTL expressed in seconds.\n+\n+Uses the DNS protocol to resolve IPv4 addresses (`A` records) for the\n+`hostname`. On success, the `Promise` is resolved with an array of IPv4\n+addresses (e.g. `['74.125.79.104', '74.125.79.105', '74.125.79.106']`).\n+\n+### dnsPromises.resolve6(hostname[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string} Hostname to resolve.\n+- `options` {Object}\n+  - `ttl` {boolean} Retrieve the Time-To-Live value (TTL) of each record.\n+    When `true`, the `Promise` is resolved with an array of\n+    `{ address: '0:1:2:3:4:5:6:7', ttl: 60 }` objects rather than an array of\n+    strings, with the TTL expressed in seconds.\n+\n+Uses the DNS protocol to resolve IPv6 addresses (`AAAA` records) for the\n+`hostname`. On success, the `Promise` is resolved with an array of IPv6\n+addresses.\n+\n+### dnsPromises.resolveCname(hostname)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+\n+Uses the DNS protocol to resolve `CNAME` records for the `hostname`. On success,\n+the `Promise` is resolved with an array of canonical name records available for\n+the `hostname` (e.g. `['bar.example.com']`).\n+\n+### dnsPromises.resolveMx(hostname)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+\n+Uses the DNS protocol to resolve mail exchange records (`MX` records) for the\n+`hostname`. On success, the `Promise` is resolved with an array of objects\n+containing both a `priority` and `exchange` property (e.g.\n+`[{priority: 10, exchange: 'mx.example.com'}, ...]`).\n+\n+### dnsPromises.resolveNaptr(hostname)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+\n+Uses the DNS protocol to resolve regular expression based records (`NAPTR`\n+records) for the `hostname`. On success, the `Promise` is resolved with an array\n+of objects with the following properties:\n+\n+* `flags`\n+* `service`\n+* `regexp`\n+* `replacement`\n+* `order`\n+* `preference`\n+\n+<!-- eslint-skip -->\n+```js\n+{\n+  flags: 's',\n+  service: 'SIP+D2U',\n+  regexp: '',\n+  replacement: '_sip._udp.example.com',\n+  order: 30,\n+  preference: 100\n+}\n+```\n+\n+### dnsPromises.resolveNs(hostname)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+\n+Uses the DNS protocol to resolve name server records (`NS` records) for the\n+`hostname`. On success, the `Promise` is resolved with an array of name server\n+records available for `hostname` (e.g.\n+`['ns1.example.com', 'ns2.example.com']`).\n+\n+### dnsPromises.resolvePtr(hostname)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+\n+Uses the DNS protocol to resolve pointer records (`PTR` records) for the\n+`hostname`. On success, the `Promise` is resolved with an array of strings\n+containing the reply records.\n+\n+### dnsPromises.resolveSoa(hostname)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+\n+Uses the DNS protocol to resolve a start of authority record (`SOA` record) for\n+the `hostname`. On success, the `Promise` is resolved with an object with the\n+following properties:\n+\n+* `nsname`\n+* `hostmaster`\n+* `serial`\n+* `refresh`\n+* `retry`\n+* `expire`\n+* `minttl`\n+\n+<!-- eslint-skip -->\n+```js\n+{\n+  nsname: 'ns.example.com',\n+  hostmaster: 'root.example.com',\n+  serial: 2013101809,\n+  refresh: 10000,\n+  retry: 2400,\n+  expire: 604800,\n+  minttl: 3600\n+}\n+```\n+\n+### dnsPromises.resolveSrv(hostname)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+\n+Uses the DNS protocol to resolve service records (`SRV` records) for the\n+`hostname`. On success, the `Promise` is resolved with an array of objects with\n+the following properties:\n+\n+* `priority`\n+* `weight`\n+* `port`\n+* `name`\n+\n+<!-- eslint-skip -->\n+```js\n+{\n+  priority: 10,\n+  weight: 5,\n+  port: 21223,\n+  name: 'service.example.com'\n+}\n+```\n+\n+### dnsPromises.resolveTxt(hostname)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+\n+Uses the DNS protocol to resolve text queries (`TXT` records) for the\n+`hostname`. On success, the `Promise` is resolved with a two-dimensional array\n+of the text records available for `hostname` (e.g.\n+`[ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]`). Each sub-array contains TXT chunks of\n+one record. Depending on the use case, these could be either joined together or\n+treated separately.\n+\n+### dnsPromises.resolveAny(hostname)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `hostname` {string}\n+\n+Uses the DNS protocol to resolve all records (also known as `ANY` or `*` query).\n+On success, the `Promise` is resolved with an array containing various types of\n+records. Each object has a property `type` that indicates the type of the\n+current record. And depending on the `type`, additional properties will be\n+present on the object:\n+\n+| Type | Properties |\n+|------|------------|\n+| `'A'` | `address`/`ttl` |\n+| `'AAAA'` | `address`/`ttl` |\n+| `'CNAME'` | `value` |\n+| `'MX'` | Refer to [`dnsPromises.resolveMx()`][] |\n+| `'NAPTR'` | Refer to [`dnsPromises.resolveNaptr()`][] |\n+| `'NS'` | `value` |\n+| `'PTR'` | `value` |\n+| `'SOA'` | Refer to [`dnsPromises.resolveSoa()`][] |\n+| `'SRV'` | Refer to [`dnsPromises.resolveSrv()`][] |\n+| `'TXT'` | This type of record contains an array property called `entries` which refers to [`dnsPromises.resolveTxt()`][], e.g. `{ entries: ['...'], type: 'TXT' }` |\n+\n+Here is an example of the result object:\n+\n+<!-- eslint-disable semi -->\n+```js\n+[ { type: 'A', address: '127.0.0.1', ttl: 299 },\n+  { type: 'CNAME', value: 'example.com' },\n+  { type: 'MX', exchange: 'alt4.aspmx.l.example.com', priority: 50 },\n+  { type: 'NS', value: 'ns1.example.com' },\n+  { type: 'TXT', entries: [ 'v=spf1 include:_spf.example.com ~all' ] },\n+  { type: 'SOA',\n+    nsname: 'ns1.example.com',\n+    hostmaster: 'admin.example.com',\n+    serial: 156696742,\n+    refresh: 900,\n+    retry: 900,\n+    expire: 1800,\n+    minttl: 60 } ]\n+```\n+\n+### dnsPromises.reverse(ip)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `ip` {string}\n+\n+Performs a reverse DNS query that resolves an IPv4 or IPv6 address to an\n+array of hostnames.\n+\n+On error, the `Promise` is rejected with an [`Error`][] object, where `err.code`\n+is one of the [DNS error codes](#dns_error_codes).\n+\n+### dnsPromises.setServers(servers)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `servers` {string[]} array of [rfc5952][] formatted addresses\n+\n+Sets the IP address and port of servers to be used when performing DNS\n+resolution. The `servers` argument is an array of [rfc5952][] formatted\n+addresses. If the port is the IANA default DNS port (53) it can be omitted.\n+\n+```js\n+dnsPromises.setServers([\n+  '4.4.4.4',\n+  '[2001:4860:4860::8888]',\n+  '4.4.4.4:1053',\n+  '[2001:4860:4860::8888]:1053'\n+]);\n+```\n+\n+An error will be thrown if an invalid address is provided.\n+\n+The `dnsPromises.setServers()` method must not be called while a DNS query is in\n+progress.\n+\n ## Error codes\n \n Each DNS query can return one of the following error codes:\n@@ -659,6 +1109,22 @@ uses. For instance, _they do not use the configuration from `/etc/hosts`_.\n [`dns.resolveTxt()`]: #dns_dns_resolvetxt_hostname_callback\n [`dns.reverse()`]: #dns_dns_reverse_ip_callback\n [`dns.setServers()`]: #dns_dns_setservers_servers\n+[`dnsPromises.getServers()`]: #dns_dnspromises_getservers\n+[`dnsPromises.lookup()`]: #dns_dnspromises_lookup_hostname_options\n+[`dnsPromises.resolve()`]: #dns_dnspromises_resolve_hostname_rrtype\n+[`dnsPromises.resolve4()`]: #dns_dnspromises_resolve4_hostname_options\n+[`dnsPromises.resolve6()`]: #dns_dnspromises_resolve6_hostname_options\n+[`dnsPromises.resolveAny()`]: #dns_dnspromises_resolveany_hostname\n+[`dnsPromises.resolveCname()`]: #dns_dnspromises_resolvecname_hostname\n+[`dnsPromises.resolveMx()`]: #dns_dnspromises_resolvemx_hostname\n+[`dnsPromises.resolveNaptr()`]: #dns_dnspromises_resolvenaptr_hostname\n+[`dnsPromises.resolveNs()`]: #dns_dnspromises_resolvens_hostname\n+[`dnsPromises.resolvePtr()`]: #dns_dnspromises_resolveptr_hostname\n+[`dnsPromises.resolveSoa()`]: #dns_dnspromises_resolvesoa_hostname\n+[`dnsPromises.resolveSrv()`]: #dns_dnspromises_resolvesrv_hostname\n+[`dnsPromises.resolveTxt()`]: #dns_dnspromises_resolvetxt_hostname\n+[`dnsPromises.reverse()`]: #dns_dnspromises_reverse_ip\n+[`dnsPromises.setServers()`]: #dns_dnspromises_setservers_servers\n [`socket.connect()`]: net.html#net_socket_connect_options_connectlistener\n [`util.promisify()`]: util.html#util_util_promisify_original\n [DNS error codes]: #dns_error_codes"
        },
        {
            "sha": "195a0189504bc93f09c439208b129eb00df8dc11",
            "filename": "lib/dns.js",
            "status": "modified",
            "additions": 35,
            "deletions": 114,
            "changes": 149,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/lib%2Fdns.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/lib%2Fdns.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fdns.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -26,10 +26,15 @@ const { isIP, isIPv4, isLegalPort } = require('internal/net');\n const { customPromisifyArgs } = require('internal/util');\n const errors = require('internal/errors');\n const {\n-  ERR_DNS_SET_SERVERS_FAILED,\n+  bindDefaultResolver,\n+  getDefaultResolver,\n+  setDefaultResolver,\n+  Resolver,\n+  validateHints\n+} = require('internal/dns/utils');\n+const {\n   ERR_INVALID_ARG_TYPE,\n   ERR_INVALID_CALLBACK,\n-  ERR_INVALID_IP_ADDRESS,\n   ERR_INVALID_OPT_VALUE,\n   ERR_MISSING_ARGS,\n   ERR_SOCKET_BAD_PORT\n@@ -39,12 +44,13 @@ const {\n   GetAddrInfoReqWrap,\n   GetNameInfoReqWrap,\n   QueryReqWrap,\n-  ChannelWrap,\n } = cares;\n \n-const IANA_DNS_PORT = 53;\n const dnsException = errors.dnsException;\n \n+let promisesWarn = true;\n+let promises; // Lazy loaded\n+\n function onlookup(err, addresses) {\n   if (err) {\n     return this.callback(dnsException(err, 'getaddrinfo', this.hostname));\n@@ -97,12 +103,7 @@ function lookup(hostname, options, callback) {\n     all = options.all === true;\n     verbatim = options.verbatim === true;\n \n-    if (hints !== 0 &&\n-        hints !== cares.AI_ADDRCONFIG &&\n-        hints !== cares.AI_V4MAPPED &&\n-        hints !== (cares.AI_ADDRCONFIG | cares.AI_V4MAPPED)) {\n-      throw new ERR_INVALID_OPT_VALUE('hints', hints);\n-    }\n+    validateHints(hints);\n   } else {\n     family = options >>> 0;\n   }\n@@ -197,17 +198,6 @@ function onresolve(err, result, ttls) {\n     this.callback(null, result);\n }\n \n-// Resolver instances correspond 1:1 to c-ares channels.\n-class Resolver {\n-  constructor() {\n-    this._handle = new ChannelWrap();\n-  }\n-\n-  cancel() {\n-    this._handle.cancel();\n-  }\n-}\n-\n function resolver(bindingName) {\n   function query(name, /* options, */ callback) {\n     var options;\n@@ -270,101 +260,15 @@ function resolve(hostname, rrtype, callback) {\n   }\n }\n \n-\n-Resolver.prototype.getServers = getServers;\n-function getServers() {\n-  const ret = this._handle.getServers();\n-  return ret.map((val) => {\n-    if (!val[1] || val[1] === IANA_DNS_PORT) return val[0];\n-\n-    const host = isIP(val[0]) === 6 ? `[${val[0]}]` : val[0];\n-    return `${host}:${val[1]}`;\n-  });\n-}\n-\n-\n-Resolver.prototype.setServers = setServers;\n-function setServers(servers) {\n-  // cache the original servers because in the event of an error setting the\n-  // servers cares won't have any servers available for resolution\n-  const orig = this._handle.getServers();\n-  const newSet = [];\n-  const IPv6RE = /^\\[([^[\\]]*)\\]/;\n-  const addrSplitRE = /(^.+?)(?::(\\d+))?$/;\n-\n-  servers.forEach((serv) => {\n-    var ipVersion = isIP(serv);\n-    if (ipVersion !== 0)\n-      return newSet.push([ipVersion, serv, IANA_DNS_PORT]);\n-\n-    const match = serv.match(IPv6RE);\n-    // we have an IPv6 in brackets\n-    if (match) {\n-      ipVersion = isIP(match[1]);\n-      if (ipVersion !== 0) {\n-        const port =\n-          parseInt(serv.replace(addrSplitRE, '$2')) ||\n-          IANA_DNS_PORT;\n-        return newSet.push([ipVersion, match[1], port]);\n-      }\n-    }\n-\n-    // addr::port\n-    const addrSplitMatch = serv.match(addrSplitRE);\n-    if (addrSplitMatch) {\n-      const hostIP = addrSplitMatch[1];\n-      const port = addrSplitMatch[2] || IANA_DNS_PORT;\n-\n-      ipVersion = isIP(hostIP);\n-      if (ipVersion !== 0) {\n-        return newSet.push([ipVersion, hostIP, parseInt(port)]);\n-      }\n-    }\n-\n-    throw new ERR_INVALID_IP_ADDRESS(serv);\n-  });\n-\n-  const errorNumber = this._handle.setServers(newSet);\n-\n-  if (errorNumber !== 0) {\n-    // reset the servers to the old servers, because ares probably unset them\n-    this._handle.setServers(orig.join(','));\n-\n-    var err = cares.strerror(errorNumber);\n-    throw new ERR_DNS_SET_SERVERS_FAILED(err, servers);\n-  }\n-}\n-\n-let defaultResolver = new Resolver();\n-\n-const resolverKeys = [\n-  'getServers',\n-  'resolve',\n-  'resolveAny',\n-  'resolve4',\n-  'resolve6',\n-  'resolveCname',\n-  'resolveMx',\n-  'resolveNs',\n-  'resolveTxt',\n-  'resolveSrv',\n-  'resolvePtr',\n-  'resolveNaptr',\n-  'resolveSoa',\n-  'reverse'\n-];\n-\n-function setExportsFunctions() {\n-  resolverKeys.forEach((key) => {\n-    module.exports[key] = defaultResolver[key].bind(defaultResolver);\n-  });\n-}\n-\n function defaultResolverSetServers(servers) {\n   const resolver = new Resolver();\n+\n   resolver.setServers(servers);\n-  defaultResolver = resolver;\n-  setExportsFunctions();\n+  setDefaultResolver(resolver);\n+  bindDefaultResolver(module.exports, Resolver.prototype);\n+\n+  if (promises !== undefined)\n+    bindDefaultResolver(promises, promises.Resolver.prototype);\n }\n \n module.exports = {\n@@ -405,4 +309,21 @@ module.exports = {\n   CANCELLED: 'ECANCELLED'\n };\n \n-setExportsFunctions();\n+bindDefaultResolver(module.exports, getDefaultResolver());\n+\n+Object.defineProperties(module.exports, {\n+  promises: {\n+    configurable: true,\n+    enumerable: false,\n+    get() {\n+      if (promisesWarn) {\n+        promises = require('internal/dns/promises');\n+        promises.setServers = defaultResolverSetServers;\n+        promisesWarn = false;\n+        process.emitWarning('The dns.promises API is experimental',\n+                            'ExperimentalWarning');\n+      }\n+      return promises;\n+    }\n+  }\n+});"
        },
        {
            "sha": "45e6c5ec64d541a0def52a6b2e5108bccd0de6a6",
            "filename": "lib/internal/dns/promises.js",
            "status": "added",
            "additions": 249,
            "deletions": 0,
            "changes": 249,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/lib%2Finternal%2Fdns%2Fpromises.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/lib%2Finternal%2Fdns%2Fpromises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fdns%2Fpromises.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -0,0 +1,249 @@\n+'use strict';\n+const {\n+  bindDefaultResolver,\n+  Resolver: CallbackResolver,\n+  validateHints\n+} = require('internal/dns/utils');\n+const { codes, dnsException } = require('internal/errors');\n+const { isIP, isIPv4, isLegalPort } = require('internal/net');\n+const {\n+  getaddrinfo,\n+  getnameinfo,\n+  ChannelWrap,\n+  GetAddrInfoReqWrap,\n+  GetNameInfoReqWrap,\n+  QueryReqWrap\n+} = process.binding('cares_wrap');\n+const {\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_INVALID_OPT_VALUE,\n+  ERR_MISSING_ARGS,\n+  ERR_SOCKET_BAD_PORT\n+} = codes;\n+\n+\n+function onlookup(err, addresses) {\n+  if (err) {\n+    this.reject(dnsException(err, 'getaddrinfo', this.hostname));\n+    return;\n+  }\n+\n+  const family = this.family ? this.family : isIPv4(addresses[0]) ? 4 : 6;\n+  this.resolve({ address: addresses[0], family });\n+}\n+\n+function onlookupall(err, addresses) {\n+  if (err) {\n+    this.reject(dnsException(err, 'getaddrinfo', this.hostname));\n+    return;\n+  }\n+\n+  const family = this.family;\n+\n+  for (var i = 0; i < addresses.length; i++) {\n+    const address = addresses[i];\n+\n+    addresses[i] = {\n+      address,\n+      family: family ? family : isIPv4(addresses[i]) ? 4 : 6\n+    };\n+  }\n+\n+  this.resolve(addresses);\n+}\n+\n+function createLookupPromise(family, hostname, all, hints, verbatim) {\n+  return new Promise((resolve, reject) => {\n+    if (!hostname) {\n+      if (all)\n+        resolve([]);\n+      else\n+        resolve({ address: null, family: family === 6 ? 6 : 4 });\n+\n+      return;\n+    }\n+\n+    const matchedFamily = isIP(hostname);\n+\n+    if (matchedFamily !== 0) {\n+      const result = { address: hostname, family: matchedFamily };\n+      if (all)\n+        resolve([result]);\n+      else\n+        resolve(result);\n+\n+      return;\n+    }\n+\n+    const req = new GetAddrInfoReqWrap();\n+\n+    req.family = family;\n+    req.hostname = hostname;\n+    req.oncomplete = all ? onlookupall : onlookup;\n+    req.resolve = resolve;\n+    req.reject = reject;\n+\n+    const err = getaddrinfo(req, hostname, family, hints, verbatim);\n+\n+    if (err) {\n+      reject(dnsException(err, 'getaddrinfo', hostname));\n+    }\n+  });\n+}\n+\n+function lookup(hostname, options) {\n+  var hints = 0;\n+  var family = -1;\n+  var all = false;\n+  var verbatim = false;\n+\n+  // Parse arguments\n+  if (hostname && typeof hostname !== 'string') {\n+    throw new ERR_INVALID_ARG_TYPE('hostname', ['string', 'falsy'], hostname);\n+  } else if (options !== null && typeof options === 'object') {\n+    hints = options.hints >>> 0;\n+    family = options.family >>> 0;\n+    all = options.all === true;\n+    verbatim = options.verbatim === true;\n+\n+    validateHints(hints);\n+  } else {\n+    family = options >>> 0;\n+  }\n+\n+  if (family !== 0 && family !== 4 && family !== 6)\n+    throw new ERR_INVALID_OPT_VALUE('family', family);\n+\n+  return createLookupPromise(family, hostname, all, hints, verbatim);\n+}\n+\n+\n+function onlookupservice(err, hostname, service) {\n+  if (err) {\n+    this.reject(dnsException(err, 'getnameinfo', this.host));\n+    return;\n+  }\n+\n+  this.resolve({ hostname, service });\n+}\n+\n+function createLookupServicePromise(host, port) {\n+  return new Promise((resolve, reject) => {\n+    const req = new GetNameInfoReqWrap();\n+\n+    req.host = host;\n+    req.port = port;\n+    req.oncomplete = onlookupservice;\n+    req.resolve = resolve;\n+    req.reject = reject;\n+\n+    const err = getnameinfo(req, host, port);\n+\n+    if (err)\n+      reject(dnsException(err, 'getnameinfo', host));\n+  });\n+}\n+\n+function lookupService(host, port) {\n+  if (arguments.length !== 2)\n+    throw new ERR_MISSING_ARGS('host', 'port');\n+\n+  if (isIP(host) === 0)\n+    throw new ERR_INVALID_OPT_VALUE('host', host);\n+\n+  if (!isLegalPort(port))\n+    throw new ERR_SOCKET_BAD_PORT(port);\n+\n+  return createLookupServicePromise(host, +port);\n+}\n+\n+\n+function onresolve(err, result, ttls) {\n+  if (err) {\n+    this.reject(dnsException(err, this.bindingName, this.hostname));\n+    return;\n+  }\n+\n+  if (ttls && this.ttl)\n+    result = result.map((address, index) => ({ address, ttl: ttls[index] }));\n+\n+  this.resolve(result);\n+}\n+\n+function createResolverPromise(resolver, bindingName, hostname, ttl) {\n+  return new Promise((resolve, reject) => {\n+    const req = new QueryReqWrap();\n+\n+    req.bindingName = bindingName;\n+    req.hostname = hostname;\n+    req.oncomplete = onresolve;\n+    req.resolve = resolve;\n+    req.reject = reject;\n+    req.ttl = ttl;\n+\n+    const err = resolver._handle[bindingName](req, hostname);\n+\n+    if (err)\n+      reject(dnsException(err, bindingName, hostname));\n+  });\n+}\n+\n+function resolver(bindingName) {\n+  function query(name, options) {\n+    if (typeof name !== 'string') {\n+      throw new ERR_INVALID_ARG_TYPE('name', 'string', name);\n+    }\n+\n+    const ttl = !!(options && options.ttl);\n+    return createResolverPromise(this, bindingName, name, ttl);\n+  }\n+\n+  Object.defineProperty(query, 'name', { value: bindingName });\n+  return query;\n+}\n+\n+\n+const resolveMap = Object.create(null);\n+\n+// Resolver instances correspond 1:1 to c-ares channels.\n+class Resolver {\n+  constructor() {\n+    this._handle = new ChannelWrap();\n+  }\n+}\n+\n+Resolver.prototype.cancel = CallbackResolver.prototype.cancel;\n+Resolver.prototype.getServers = CallbackResolver.prototype.getServers;\n+Resolver.prototype.setServers = CallbackResolver.prototype.setServers;\n+Resolver.prototype.resolveAny = resolveMap.ANY = resolver('queryAny');\n+Resolver.prototype.resolve4 = resolveMap.A = resolver('queryA');\n+Resolver.prototype.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\n+Resolver.prototype.resolveCname = resolveMap.CNAME = resolver('queryCname');\n+Resolver.prototype.resolveMx = resolveMap.MX = resolver('queryMx');\n+Resolver.prototype.resolveNs = resolveMap.NS = resolver('queryNs');\n+Resolver.prototype.resolveTxt = resolveMap.TXT = resolver('queryTxt');\n+Resolver.prototype.resolveSrv = resolveMap.SRV = resolver('querySrv');\n+Resolver.prototype.resolvePtr = resolveMap.PTR = resolver('queryPtr');\n+Resolver.prototype.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\n+Resolver.prototype.resolveSoa = resolveMap.SOA = resolver('querySoa');\n+Resolver.prototype.reverse = resolver('getHostByAddr');\n+Resolver.prototype.resolve = function resolve(hostname, rrtype) {\n+  var resolver;\n+\n+  if (typeof rrtype === 'string') {\n+    resolver = resolveMap[rrtype];\n+\n+    if (typeof resolver !== 'function')\n+      throw new ERR_INVALID_OPT_VALUE('rrtype', rrtype);\n+  } else if (rrtype === undefined) {\n+    resolver = resolveMap.A;\n+  } else {\n+    throw new ERR_INVALID_ARG_TYPE('rrtype', 'string', rrtype);\n+  }\n+\n+  return resolver.call(this, hostname);\n+};\n+\n+\n+module.exports = { lookup, lookupService, Resolver };\n+bindDefaultResolver(module.exports, Resolver.prototype);"
        },
        {
            "sha": "43b65418848f859ed1e728a7d744416625b47820",
            "filename": "lib/internal/dns/utils.js",
            "status": "added",
            "additions": 141,
            "deletions": 0,
            "changes": 141,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/lib%2Finternal%2Fdns%2Futils.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/lib%2Finternal%2Fdns%2Futils.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fdns%2Futils.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -0,0 +1,141 @@\n+'use strict';\n+const errors = require('internal/errors');\n+const { isIP } = require('internal/net');\n+const {\n+  ChannelWrap,\n+  strerror,\n+  AI_ADDRCONFIG,\n+  AI_V4MAPPED\n+} = process.binding('cares_wrap');\n+const IANA_DNS_PORT = 53;\n+const IPv6RE = /^\\[([^[\\]]*)\\]/;\n+const addrSplitRE = /(^.+?)(?::(\\d+))?$/;\n+const {\n+  ERR_DNS_SET_SERVERS_FAILED,\n+  ERR_INVALID_IP_ADDRESS,\n+  ERR_INVALID_OPT_VALUE\n+} = errors.codes;\n+\n+// Resolver instances correspond 1:1 to c-ares channels.\n+class Resolver {\n+  constructor() {\n+    this._handle = new ChannelWrap();\n+  }\n+\n+  cancel() {\n+    this._handle.cancel();\n+  }\n+\n+  getServers() {\n+    return this._handle.getServers().map((val) => {\n+      if (!val[1] || val[1] === IANA_DNS_PORT)\n+        return val[0];\n+\n+      const host = isIP(val[0]) === 6 ? `[${val[0]}]` : val[0];\n+      return `${host}:${val[1]}`;\n+    });\n+  }\n+\n+  setServers(servers) {\n+    // Cache the original servers because in the event of an error while\n+    // setting the servers, c-ares won't have any servers available for\n+    // resolution.\n+    const orig = this._handle.getServers();\n+    const newSet = [];\n+\n+    servers.forEach((serv) => {\n+      var ipVersion = isIP(serv);\n+\n+      if (ipVersion !== 0)\n+        return newSet.push([ipVersion, serv, IANA_DNS_PORT]);\n+\n+      const match = serv.match(IPv6RE);\n+\n+      // Check for an IPv6 in brackets.\n+      if (match) {\n+        ipVersion = isIP(match[1]);\n+\n+        if (ipVersion !== 0) {\n+          const port =\n+            parseInt(serv.replace(addrSplitRE, '$2')) ||\n+            IANA_DNS_PORT;\n+          return newSet.push([ipVersion, match[1], port]);\n+        }\n+      }\n+\n+      // addr::port\n+      const addrSplitMatch = serv.match(addrSplitRE);\n+\n+      if (addrSplitMatch) {\n+        const hostIP = addrSplitMatch[1];\n+        const port = addrSplitMatch[2] || IANA_DNS_PORT;\n+\n+        ipVersion = isIP(hostIP);\n+\n+        if (ipVersion !== 0) {\n+          return newSet.push([ipVersion, hostIP, parseInt(port)]);\n+        }\n+      }\n+\n+      throw new ERR_INVALID_IP_ADDRESS(serv);\n+    });\n+\n+    const errorNumber = this._handle.setServers(newSet);\n+\n+    if (errorNumber !== 0) {\n+      // Reset the servers to the old servers, because ares probably unset them.\n+      this._handle.setServers(orig.join(','));\n+      const err = strerror(errorNumber);\n+      throw new ERR_DNS_SET_SERVERS_FAILED(err, servers);\n+    }\n+  }\n+}\n+\n+let defaultResolver = new Resolver();\n+const resolverKeys = [\n+  'getServers',\n+  'resolve',\n+  'resolveAny',\n+  'resolve4',\n+  'resolve6',\n+  'resolveCname',\n+  'resolveMx',\n+  'resolveNs',\n+  'resolveTxt',\n+  'resolveSrv',\n+  'resolvePtr',\n+  'resolveNaptr',\n+  'resolveSoa',\n+  'reverse'\n+];\n+\n+function getDefaultResolver() {\n+  return defaultResolver;\n+}\n+\n+function setDefaultResolver(resolver) {\n+  defaultResolver = resolver;\n+}\n+\n+function bindDefaultResolver(target, source) {\n+  resolverKeys.forEach((key) => {\n+    target[key] = source[key].bind(defaultResolver);\n+  });\n+}\n+\n+function validateHints(hints) {\n+  if (hints !== 0 &&\n+      hints !== AI_ADDRCONFIG &&\n+      hints !== AI_V4MAPPED &&\n+      hints !== (AI_ADDRCONFIG | AI_V4MAPPED)) {\n+    throw new ERR_INVALID_OPT_VALUE('hints', hints);\n+  }\n+}\n+\n+module.exports = {\n+  bindDefaultResolver,\n+  getDefaultResolver,\n+  setDefaultResolver,\n+  validateHints,\n+  Resolver\n+};"
        },
        {
            "sha": "b176e5f4540fa29a64c364ab083e0973963edb06",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -101,6 +101,8 @@\n       'lib/internal/crypto/sig.js',\n       'lib/internal/crypto/util.js',\n       'lib/internal/constants.js',\n+      'lib/internal/dns/promises.js',\n+      'lib/internal/dns/utils.js',\n       'lib/internal/encoding.js',\n       'lib/internal/errors.js',\n       'lib/internal/error-serdes.js',"
        },
        {
            "sha": "be5fc4b1addefc6706305a7242463ed3384d6f5b",
            "filename": "test/internet/test-dns-any.js",
            "status": "modified",
            "additions": 54,
            "deletions": 49,
            "changes": 103,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns-any.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns-any.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Finternet%2Ftest-dns-any.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -9,6 +9,9 @@ const net = require('net');\n let running = false;\n const queue = [];\n \n+common.crashOnUnhandledRejection();\n+\n+const dnsPromises = dns.promises;\n const isIPv4 = net.isIPv4;\n const isIPv6 = net.isIPv6;\n \n@@ -101,93 +104,95 @@ function TEST(f) {\n   }\n }\n \n-TEST(function test_google(done) {\n+function processResult(res) {\n+  assert.ok(Array.isArray(res));\n+  assert.ok(res.length > 0);\n+\n+  const types = {};\n+  res.forEach((obj) => {\n+    types[obj.type] = true;\n+    checkers[`check${obj.type}`](obj);\n+  });\n+\n+  return types;\n+}\n+\n+TEST(async function test_google(done) {\n+  function validateResult(res) {\n+    const types = processResult(res);\n+    assert.ok(\n+      types.A && types.AAAA && types.MX &&\n+      types.NS && types.TXT && types.SOA);\n+  }\n+\n+  validateResult(await dnsPromises.resolve('google.com', 'ANY'));\n+\n   const req = dns.resolve(\n     'google.com',\n     'ANY',\n     common.mustCall(function(err, ret) {\n       assert.ifError(err);\n-      assert.ok(Array.isArray(ret));\n-      assert.ok(ret.length > 0);\n-\n-      /* current google.com has A / AAAA / MX / NS / TXT and SOA records */\n-      const types = {};\n-      ret.forEach((obj) => {\n-        types[obj.type] = true;\n-        checkers[`check${obj.type}`](obj);\n-      });\n-      assert.ok(\n-        types.A && types.AAAA && types.MX &&\n-        types.NS && types.TXT && types.SOA);\n-\n+      validateResult(ret);\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_sip2sip_for_naptr(done) {\n+TEST(async function test_sip2sip_for_naptr(done) {\n+  function validateResult(res) {\n+    const types = processResult(res);\n+    assert.ok(types.A && types.NS && types.NAPTR && types.SOA);\n+  }\n+\n+  validateResult(await dnsPromises.resolve('sip2sip.info', 'ANY'));\n+\n   const req = dns.resolve(\n     'sip2sip.info',\n     'ANY',\n     common.mustCall(function(err, ret) {\n       assert.ifError(err);\n-      assert.ok(Array.isArray(ret));\n-      assert.ok(ret.length > 0);\n-\n-      /* current sip2sip.info has A / NS / NAPTR and SOA records */\n-      const types = {};\n-      ret.forEach((obj) => {\n-        types[obj.type] = true;\n-        checkers[`check${obj.type}`](obj);\n-      });\n-      assert.ok(types.A && types.NS && types.NAPTR && types.SOA);\n-\n+      validateResult(ret);\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_google_for_cname_and_srv(done) {\n+TEST(async function test_google_for_cname_and_srv(done) {\n+  function validateResult(res) {\n+    const types = processResult(res);\n+    assert.ok(types.SRV);\n+  }\n+\n+  validateResult(await dnsPromises.resolve('_jabber._tcp.google.com', 'ANY'));\n+\n   const req = dns.resolve(\n     '_jabber._tcp.google.com',\n     'ANY',\n     common.mustCall(function(err, ret) {\n       assert.ifError(err);\n-      assert.ok(Array.isArray(ret));\n-      assert.ok(ret.length > 0);\n-\n-      const types = {};\n-      ret.forEach((obj) => {\n-        types[obj.type] = true;\n-        checkers[`check${obj.type}`](obj);\n-      });\n-      assert.ok(types.SRV);\n-\n+      validateResult(ret);\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_ptr(done) {\n+TEST(async function test_ptr(done) {\n+  function validateResult(res) {\n+    const types = processResult(res);\n+    assert.ok(types.PTR);\n+  }\n+\n+  validateResult(await dnsPromises.resolve('8.8.8.8.in-addr.arpa', 'ANY'));\n+\n   const req = dns.resolve(\n     '8.8.8.8.in-addr.arpa',\n     'ANY',\n     common.mustCall(function(err, ret) {\n       assert.ifError(err);\n-      assert.ok(Array.isArray(ret));\n-      assert.ok(ret.length > 0);\n-\n-      /* current 8.8.8.8.in-addr.arpa has PTR record */\n-      const types = {};\n-      ret.forEach((obj) => {\n-        types[obj.type] = true;\n-        checkers[`check${obj.type}`](obj);\n-      });\n-      assert.ok(types.PTR);\n-\n+      validateResult(ret);\n       done();\n     }));\n "
        },
        {
            "sha": "837d45f2ad4128bfd3a32b80f439c6989ac90d55",
            "filename": "test/internet/test-dns-ipv4.js",
            "status": "modified",
            "additions": 110,
            "deletions": 55,
            "changes": 165,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns-ipv4.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns-ipv4.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Finternet%2Ftest-dns-ipv4.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -9,6 +9,7 @@ const isIPv4 = net.isIPv4;\n \n common.crashOnUnhandledRejection();\n \n+const dnsPromises = dns.promises;\n let running = false;\n const queue = [];\n \n@@ -38,154 +39,208 @@ function checkWrap(req) {\n   assert.ok(typeof req === 'object');\n }\n \n-TEST(function test_resolve4(done) {\n+TEST(async function test_resolve4(done) {\n+  function validateResult(res) {\n+    assert.ok(res.length > 0);\n+\n+    for (let i = 0; i < res.length; i++) {\n+      assert.ok(isIPv4(res[i]));\n+    }\n+  }\n+\n+  validateResult(await dnsPromises.resolve4(addresses.INET4_HOST));\n+\n   const req = dns.resolve4(\n     addresses.INET4_HOST,\n     common.mustCall((err, ips) => {\n       assert.ifError(err);\n-\n-      assert.ok(ips.length > 0);\n-\n-      for (let i = 0; i < ips.length; i++) {\n-        assert.ok(isIPv4(ips[i]));\n-      }\n-\n+      validateResult(ips);\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_reverse_ipv4(done) {\n+TEST(async function test_reverse_ipv4(done) {\n+  function validateResult(res) {\n+    assert.ok(res.length > 0);\n+\n+    for (let i = 0; i < res.length; i++) {\n+      assert.ok(res[i]);\n+      assert.ok(typeof res[i] === 'string');\n+    }\n+  }\n+\n+  validateResult(await dnsPromises.reverse(addresses.INET4_IP));\n+\n   const req = dns.reverse(\n     addresses.INET4_IP,\n     common.mustCall((err, domains) => {\n       assert.ifError(err);\n-\n-      assert.ok(domains.length > 0);\n-\n-      for (let i = 0; i < domains.length; i++) {\n-        assert.ok(domains[i]);\n-        assert.ok(typeof domains[i] === 'string');\n-      }\n-\n+      validateResult(domains);\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookup_ipv4_explicit(done) {\n+TEST(async function test_lookup_ipv4_explicit(done) {\n+  function validateResult(res) {\n+    assert.ok(net.isIPv4(res.address));\n+    assert.strictEqual(res.family, 4);\n+  }\n+\n+  validateResult(await dnsPromises.lookup(addresses.INET4_HOST, 4));\n+\n   const req = dns.lookup(\n     addresses.INET4_HOST, 4,\n     common.mustCall((err, ip, family) => {\n       assert.ifError(err);\n-      assert.ok(net.isIPv4(ip));\n-      assert.strictEqual(family, 4);\n-\n+      validateResult({ address: ip, family });\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookup_ipv4_implicit(done) {\n+TEST(async function test_lookup_ipv4_implicit(done) {\n+  function validateResult(res) {\n+    assert.ok(net.isIPv4(res.address));\n+    assert.strictEqual(res.family, 4);\n+  }\n+\n+  validateResult(await dnsPromises.lookup(addresses.INET4_HOST));\n+\n   const req = dns.lookup(\n     addresses.INET4_HOST,\n     common.mustCall((err, ip, family) => {\n       assert.ifError(err);\n-      assert.ok(net.isIPv4(ip));\n-      assert.strictEqual(family, 4);\n-\n+      validateResult({ address: ip, family });\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookup_ipv4_explicit_object(done) {\n+TEST(async function test_lookup_ipv4_explicit_object(done) {\n+  function validateResult(res) {\n+    assert.ok(net.isIPv4(res.address));\n+    assert.strictEqual(res.family, 4);\n+  }\n+\n+  validateResult(await dnsPromises.lookup(addresses.INET4_HOST, { family: 4 }));\n+\n   const req = dns.lookup(addresses.INET4_HOST, {\n     family: 4\n   }, common.mustCall((err, ip, family) => {\n     assert.ifError(err);\n-    assert.ok(net.isIPv4(ip));\n-    assert.strictEqual(family, 4);\n-\n+    validateResult({ address: ip, family });\n     done();\n   }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookup_ipv4_hint_addrconfig(done) {\n+TEST(async function test_lookup_ipv4_hint_addrconfig(done) {\n+  function validateResult(res) {\n+    assert.ok(net.isIPv4(res.address));\n+    assert.strictEqual(res.family, 4);\n+  }\n+\n+  validateResult(await dnsPromises.lookup(addresses.INET4_HOST, {\n+    hints: dns.ADDRCONFIG\n+  }));\n+\n   const req = dns.lookup(addresses.INET4_HOST, {\n     hints: dns.ADDRCONFIG\n   }, common.mustCall((err, ip, family) => {\n     assert.ifError(err);\n-    assert.ok(net.isIPv4(ip));\n-    assert.strictEqual(family, 4);\n-\n+    validateResult({ address: ip, family });\n     done();\n   }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookup_ip_ipv4(done) {\n+TEST(async function test_lookup_ip_ipv4(done) {\n+  function validateResult(res) {\n+    assert.strictEqual(res.address, '127.0.0.1');\n+    assert.strictEqual(res.family, 4);\n+  }\n+\n+  validateResult(await dnsPromises.lookup('127.0.0.1'));\n+\n   const req = dns.lookup('127.0.0.1',\n                          common.mustCall((err, ip, family) => {\n                            assert.ifError(err);\n-                           assert.strictEqual(ip, '127.0.0.1');\n-                           assert.strictEqual(family, 4);\n-\n+                           validateResult({ address: ip, family });\n                            done();\n                          }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookup_localhost_ipv4(done) {\n+TEST(async function test_lookup_localhost_ipv4(done) {\n+  function validateResult(res) {\n+    assert.strictEqual(res.address, '127.0.0.1');\n+    assert.strictEqual(res.family, 4);\n+  }\n+\n+  validateResult(await dnsPromises.lookup('localhost', 4));\n+\n   const req = dns.lookup('localhost', 4,\n                          common.mustCall((err, ip, family) => {\n                            assert.ifError(err);\n-                           assert.strictEqual(ip, '127.0.0.1');\n-                           assert.strictEqual(family, 4);\n-\n+                           validateResult({ address: ip, family });\n                            done();\n                          }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookup_all_ipv4(done) {\n+TEST(async function test_lookup_all_ipv4(done) {\n+  function validateResult(res) {\n+    assert.ok(Array.isArray(res));\n+    assert.ok(res.length > 0);\n+\n+    res.forEach((ip) => {\n+      assert.ok(isIPv4(ip.address));\n+      assert.strictEqual(ip.family, 4);\n+    });\n+  }\n+\n+  validateResult(await dnsPromises.lookup(addresses.INET4_HOST, {\n+    all: true,\n+    family: 4\n+  }));\n+\n   const req = dns.lookup(\n     addresses.INET4_HOST,\n     { all: true, family: 4 },\n     common.mustCall((err, ips) => {\n       assert.ifError(err);\n-      assert.ok(Array.isArray(ips));\n-      assert.ok(ips.length > 0);\n-\n-      ips.forEach((ip) => {\n-        assert.ok(isIPv4(ip.address));\n-        assert.strictEqual(ip.family, 4);\n-      });\n-\n+      validateResult(ips);\n       done();\n     })\n   );\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookupservice_ip_ipv4(done) {\n+TEST(async function test_lookupservice_ip_ipv4(done) {\n+  function validateResult(res) {\n+    assert.strictEqual(typeof res.hostname, 'string');\n+    assert(res.hostname);\n+    assert(['http', 'www', '80'].includes(res.service));\n+  }\n+\n+  validateResult(await dnsPromises.lookupService('127.0.0.1', 80));\n+\n   const req = dns.lookupService(\n     '127.0.0.1', 80,\n-    common.mustCall((err, host, service) => {\n+    common.mustCall((err, hostname, service) => {\n       assert.ifError(err);\n-      assert.strictEqual(typeof host, 'string');\n-      assert(host);\n-      assert(['http', 'www', '80'].includes(service));\n+      validateResult({ hostname, service });\n       done();\n     })\n   );"
        },
        {
            "sha": "283b182390ae72f3e8c9303762464925d8be175a",
            "filename": "test/internet/test-dns-ipv6.js",
            "status": "modified",
            "additions": 72,
            "deletions": 36,
            "changes": 108,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns-ipv6.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns-ipv6.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Finternet%2Ftest-dns-ipv6.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -4,9 +4,12 @@ const { addresses } = require('../common/internet');\n if (!common.hasIPv6)\n   common.skip('this test, no IPv6 support');\n \n+common.crashOnUnhandledRejection();\n+\n const assert = require('assert');\n const dns = require('dns');\n const net = require('net');\n+const dnsPromises = dns.promises;\n const isIPv6 = net.isIPv6;\n \n let running = false;\n@@ -38,49 +41,64 @@ function checkWrap(req) {\n   assert.ok(typeof req === 'object');\n }\n \n-TEST(function test_resolve6(done) {\n+TEST(async function test_resolve6(done) {\n+  function validateResult(res) {\n+    assert.ok(res.length > 0);\n+\n+    for (let i = 0; i < res.length; i++) {\n+      assert.ok(isIPv6(res[i]));\n+    }\n+  }\n+\n+  validateResult(await dnsPromises.resolve6(addresses.INET6_HOST));\n+\n   const req = dns.resolve6(\n     addresses.INET6_HOST,\n     common.mustCall((err, ips) => {\n       assert.ifError(err);\n-\n-      assert.ok(ips.length > 0);\n-\n-      for (let i = 0; i < ips.length; i++)\n-        assert.ok(isIPv6(ips[i]));\n-\n+      validateResult(ips);\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_reverse_ipv6(done) {\n+TEST(async function test_reverse_ipv6(done) {\n+  function validateResult(res) {\n+    assert.ok(res.length > 0);\n+\n+    for (let i = 0; i < res.length; i++) {\n+      assert.ok(typeof res[i] === 'string');\n+    }\n+  }\n+\n+  validateResult(await dnsPromises.reverse(addresses.INET6_IP));\n+\n   const req = dns.reverse(\n     addresses.INET6_IP,\n     common.mustCall((err, domains) => {\n       assert.ifError(err);\n-\n-      assert.ok(domains.length > 0);\n-\n-      for (let i = 0; i < domains.length; i++)\n-        assert.ok(typeof domains[i] === 'string');\n-\n+      validateResult(domains);\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookup_ipv6_explicit(done) {\n+TEST(async function test_lookup_ipv6_explicit(done) {\n+  function validateResult(res) {\n+    assert.ok(isIPv6(res.address));\n+    assert.strictEqual(res.family, 6);\n+  }\n+\n+  validateResult(await dnsPromises.lookup(addresses.INET6_HOST, 6));\n+\n   const req = dns.lookup(\n     addresses.INET6_HOST,\n     6,\n     common.mustCall((err, ip, family) => {\n       assert.ifError(err);\n-      assert.ok(isIPv6(ip));\n-      assert.strictEqual(family, 6);\n-\n+      validateResult({ address: ip, family });\n       done();\n     }));\n \n@@ -101,14 +119,19 @@ TEST(function test_lookup_ipv6_implicit(done) {\n });\n */\n \n-TEST(function test_lookup_ipv6_explicit_object(done) {\n+TEST(async function test_lookup_ipv6_explicit_object(done) {\n+  function validateResult(res) {\n+    assert.ok(isIPv6(res.address));\n+    assert.strictEqual(res.family, 6);\n+  }\n+\n+  validateResult(await dnsPromises.lookup(addresses.INET6_HOST, { family: 6 }));\n+\n   const req = dns.lookup(addresses.INET6_HOST, {\n     family: 6\n   }, common.mustCall((err, ip, family) => {\n     assert.ifError(err);\n-    assert.ok(isIPv6(ip));\n-    assert.strictEqual(family, 6);\n-\n+    validateResult({ address: ip, family });\n     done();\n   }));\n \n@@ -143,35 +166,48 @@ TEST(function test_lookup_ipv6_hint(done) {\n   checkWrap(req);\n });\n \n-TEST(function test_lookup_ip_ipv6(done) {\n+TEST(async function test_lookup_ip_ipv6(done) {\n+  function validateResult(res) {\n+    assert.ok(isIPv6(res.address));\n+    assert.strictEqual(res.family, 6);\n+  }\n+\n+  validateResult(await dnsPromises.lookup('::1'));\n+\n   const req = dns.lookup(\n     '::1',\n     common.mustCall((err, ip, family) => {\n       assert.ifError(err);\n-      assert.ok(isIPv6(ip));\n-      assert.strictEqual(family, 6);\n-\n+      validateResult({ address: ip, family });\n       done();\n     }));\n \n   checkWrap(req);\n });\n \n-TEST(function test_lookup_all_ipv6(done) {\n+TEST(async function test_lookup_all_ipv6(done) {\n+  function validateResult(res) {\n+    assert.ok(Array.isArray(res));\n+    assert.ok(res.length > 0);\n+\n+    res.forEach((ip) => {\n+      assert.ok(isIPv6(ip.address),\n+                `Invalid IPv6: ${ip.address.toString()}`);\n+      assert.strictEqual(ip.family, 6);\n+    });\n+  }\n+\n+  validateResult(await dnsPromises.lookup(addresses.INET6_HOST, {\n+    all: true,\n+    family: 6\n+  }));\n+\n   const req = dns.lookup(\n     addresses.INET6_HOST,\n     { all: true, family: 6 },\n     common.mustCall((err, ips) => {\n       assert.ifError(err);\n-      assert.ok(Array.isArray(ips));\n-      assert.ok(ips.length > 0);\n-\n-      ips.forEach((ip) => {\n-        assert.ok(isIPv6(ip.address),\n-                  `Invalid IPv6: ${ip.address.toString()}`);\n-        assert.strictEqual(ip.family, 6);\n-      });\n-\n+      validateResult(ips);\n       done();\n     })\n   );"
        },
        {
            "sha": "b572c6bb7fb4210d8d24f329729e55437bf3189a",
            "filename": "test/internet/test-dns-txt-sigsegv.js",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns-txt-sigsegv.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns-txt-sigsegv.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Finternet%2Ftest-dns-txt-sigsegv.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -1,7 +1,15 @@\n 'use strict';\n-require('../common');\n+const common = require('../common');\n const assert = require('assert');\n const dns = require('dns');\n+const dnsPromises = dns.promises;\n+\n+common.crashOnUnhandledRejection();\n+\n+(async function() {\n+  const result = await dnsPromises.resolveTxt('www.microsoft.com');\n+  assert.strictEqual(result.length, 0);\n+})();\n \n dns.resolveTxt('www.microsoft.com', function(err, records) {\n   assert.strictEqual(err, null);"
        },
        {
            "sha": "593d621e82f5b1186f4a1c21f458eb3a6bcd7589",
            "filename": "test/internet/test-dns.js",
            "status": "modified",
            "additions": 190,
            "deletions": 68,
            "changes": 258,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Finternet%2Ftest-dns.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Finternet%2Ftest-dns.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -28,6 +28,7 @@ const net = require('net');\n const isIPv4 = net.isIPv4;\n const isIPv6 = net.isIPv6;\n const util = require('util');\n+const dnsPromises = dns.promises;\n \n common.crashOnUnhandledRejection();\n \n@@ -68,17 +69,18 @@ function checkWrap(req) {\n \n \n TEST(function test_reverse_bogus(done) {\n+  dnsPromises.reverse('bogus ip')\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: 'EINVAL' }));\n+\n   assert.throws(() => {\n     dns.reverse('bogus ip', common.mustNotCall());\n   }, /^Error: getHostByAddr EINVAL bogus ip$/);\n   done();\n });\n \n-TEST(function test_resolve4_ttl(done) {\n-  const req = dns.resolve4(addresses.INET4_HOST, {\n-    ttl: true\n-  }, function(err, result) {\n-    assert.ifError(err);\n+TEST(async function test_resolve4_ttl(done) {\n+  function validateResult(result) {\n     assert.ok(result.length > 0);\n \n     for (let i = 0; i < result.length; i++) {\n@@ -90,18 +92,25 @@ TEST(function test_resolve4_ttl(done) {\n       assert.ok(item.ttl > 0);\n       assert.ok(isIPv4(item.address));\n     }\n+  }\n+\n+  validateResult(await dnsPromises.resolve4(addresses.INET4_HOST, {\n+    ttl: true\n+  }));\n \n+  const req = dns.resolve4(addresses.INET4_HOST, {\n+    ttl: true\n+  }, function(err, result) {\n+    assert.ifError(err);\n+    validateResult(result);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n-TEST(function test_resolve6_ttl(done) {\n-  const req = dns.resolve6(addresses.INET6_HOST, {\n-    ttl: true\n-  }, function(err, result) {\n-    assert.ifError(err);\n+TEST(async function test_resolve6_ttl(done) {\n+  function validateResult(result) {\n     assert.ok(result.length > 0);\n \n     for (let i = 0; i < result.length; i++) {\n@@ -113,36 +122,53 @@ TEST(function test_resolve6_ttl(done) {\n       assert.ok(item.ttl > 0);\n       assert.ok(isIPv6(item.address));\n     }\n+  }\n+\n+  validateResult(await dnsPromises.resolve6(addresses.INET6_HOST, {\n+    ttl: true\n+  }));\n \n+  const req = dns.resolve6(addresses.INET6_HOST, {\n+    ttl: true\n+  }, function(err, result) {\n+    assert.ifError(err);\n+    validateResult(result);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n-TEST(function test_resolveMx(done) {\n-  const req = dns.resolveMx(addresses.MX_HOST, function(err, result) {\n-    assert.ifError(err);\n+TEST(async function test_resolveMx(done) {\n+  function validateResult(result) {\n     assert.ok(result.length > 0);\n \n     for (let i = 0; i < result.length; i++) {\n       const item = result[i];\n       assert.ok(item);\n       assert.strictEqual(typeof item, 'object');\n-\n       assert.ok(item.exchange);\n       assert.strictEqual(typeof item.exchange, 'string');\n-\n       assert.strictEqual(typeof item.priority, 'number');\n     }\n+  }\n \n+  validateResult(await dnsPromises.resolveMx(addresses.MX_HOST));\n+\n+  const req = dns.resolveMx(addresses.MX_HOST, function(err, result) {\n+    assert.ifError(err);\n+    validateResult(result);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n TEST(function test_resolveMx_failure(done) {\n+  dnsPromises.resolveMx(addresses.INVALID_HOST)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: 'ENOTFOUND' }));\n+\n   const req = dns.resolveMx(addresses.INVALID_HOST, function(err, result) {\n     assert.ok(err instanceof Error);\n     assert.strictEqual(err.errno, 'ENOTFOUND');\n@@ -155,24 +181,34 @@ TEST(function test_resolveMx_failure(done) {\n   checkWrap(req);\n });\n \n-TEST(function test_resolveNs(done) {\n-  const req = dns.resolveNs(addresses.NS_HOST, function(err, names) {\n-    assert.ifError(err);\n-    assert.ok(names.length > 0);\n+TEST(async function test_resolveNs(done) {\n+  function validateResult(result) {\n+    assert.ok(result.length > 0);\n \n-    for (let i = 0; i < names.length; i++) {\n-      const name = names[i];\n-      assert.ok(name);\n-      assert.strictEqual(typeof name, 'string');\n+    for (let i = 0; i < result.length; i++) {\n+      const item = result[i];\n+\n+      assert.ok(item);\n+      assert.strictEqual(typeof item, 'string');\n     }\n+  }\n \n+  validateResult(await dnsPromises.resolveNs(addresses.NS_HOST));\n+\n+  const req = dns.resolveNs(addresses.NS_HOST, function(err, names) {\n+    assert.ifError(err);\n+    validateResult(names);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n TEST(function test_resolveNs_failure(done) {\n+  dnsPromises.resolveNs(addresses.INVALID_HOST)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: 'ENOTFOUND' }));\n+\n   const req = dns.resolveNs(addresses.INVALID_HOST, function(err, result) {\n     assert.ok(err instanceof Error);\n     assert.strictEqual(err.errno, 'ENOTFOUND');\n@@ -185,9 +221,8 @@ TEST(function test_resolveNs_failure(done) {\n   checkWrap(req);\n });\n \n-TEST(function test_resolveSrv(done) {\n-  const req = dns.resolveSrv(addresses.SRV_HOST, function(err, result) {\n-    assert.ifError(err);\n+TEST(async function test_resolveSrv(done) {\n+  function validateResult(result) {\n     assert.ok(result.length > 0);\n \n     for (let i = 0; i < result.length; i++) {\n@@ -202,14 +237,24 @@ TEST(function test_resolveSrv(done) {\n       assert.strictEqual(typeof item.priority, 'number');\n       assert.strictEqual(typeof item.weight, 'number');\n     }\n+  }\n \n+  validateResult(await dnsPromises.resolveSrv(addresses.SRV_HOST));\n+\n+  const req = dns.resolveSrv(addresses.SRV_HOST, function(err, result) {\n+    assert.ifError(err);\n+    validateResult(result);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n TEST(function test_resolveSrv_failure(done) {\n+  dnsPromises.resolveSrv(addresses.INVALID_HOST)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: 'ENOTFOUND' }));\n+\n   const req = dns.resolveSrv(addresses.INVALID_HOST, function(err, result) {\n     assert.ok(err instanceof Error);\n     assert.strictEqual(err.errno, 'ENOTFOUND');\n@@ -222,24 +267,33 @@ TEST(function test_resolveSrv_failure(done) {\n   checkWrap(req);\n });\n \n-TEST(function test_resolvePtr(done) {\n-  const req = dns.resolvePtr(addresses.PTR_HOST, function(err, result) {\n-    assert.ifError(err);\n+TEST(async function test_resolvePtr(done) {\n+  function validateResult(result) {\n     assert.ok(result.length > 0);\n \n     for (let i = 0; i < result.length; i++) {\n       const item = result[i];\n       assert.ok(item);\n       assert.strictEqual(typeof item, 'string');\n     }\n+  }\n+\n+  validateResult(await dnsPromises.resolvePtr(addresses.PTR_HOST));\n \n+  const req = dns.resolvePtr(addresses.PTR_HOST, function(err, result) {\n+    assert.ifError(err);\n+    validateResult(result);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n TEST(function test_resolvePtr_failure(done) {\n+  dnsPromises.resolvePtr(addresses.INVALID_HOST)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: 'ENOTFOUND' }));\n+\n   const req = dns.resolvePtr(addresses.INVALID_HOST, function(err, result) {\n     assert.ok(err instanceof Error);\n     assert.strictEqual(err.errno, 'ENOTFOUND');\n@@ -252,31 +306,39 @@ TEST(function test_resolvePtr_failure(done) {\n   checkWrap(req);\n });\n \n-TEST(function test_resolveNaptr(done) {\n-  const req = dns.resolveNaptr(addresses.NAPTR_HOST, function(err, result) {\n-    assert.ifError(err);\n+TEST(async function test_resolveNaptr(done) {\n+  function validateResult(result) {\n     assert.ok(result.length > 0);\n \n     for (let i = 0; i < result.length; i++) {\n       const item = result[i];\n       assert.ok(item);\n       assert.strictEqual(typeof item, 'object');\n-\n       assert.strictEqual(typeof item.flags, 'string');\n       assert.strictEqual(typeof item.service, 'string');\n       assert.strictEqual(typeof item.regexp, 'string');\n       assert.strictEqual(typeof item.replacement, 'string');\n       assert.strictEqual(typeof item.order, 'number');\n       assert.strictEqual(typeof item.preference, 'number');\n     }\n+  }\n \n+  validateResult(await dnsPromises.resolveNaptr(addresses.NAPTR_HOST));\n+\n+  const req = dns.resolveNaptr(addresses.NAPTR_HOST, function(err, result) {\n+    assert.ifError(err);\n+    validateResult(result);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n TEST(function test_resolveNaptr_failure(done) {\n+  dnsPromises.resolveNaptr(addresses.INVALID_HOST)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: 'ENOTFOUND' }));\n+\n   const req = dns.resolveNaptr(addresses.INVALID_HOST, function(err, result) {\n     assert.ok(err instanceof Error);\n     assert.strictEqual(err.errno, 'ENOTFOUND');\n@@ -289,40 +351,42 @@ TEST(function test_resolveNaptr_failure(done) {\n   checkWrap(req);\n });\n \n-TEST(function test_resolveSoa(done) {\n-  const req = dns.resolveSoa(addresses.SOA_HOST, function(err, result) {\n-    assert.ifError(err);\n+TEST(async function test_resolveSoa(done) {\n+  function validateResult(result) {\n     assert.ok(result);\n     assert.strictEqual(typeof result, 'object');\n-\n     assert.strictEqual(typeof result.nsname, 'string');\n     assert.ok(result.nsname.length > 0);\n-\n     assert.strictEqual(typeof result.hostmaster, 'string');\n     assert.ok(result.hostmaster.length > 0);\n-\n     assert.strictEqual(typeof result.serial, 'number');\n     assert.ok((result.serial > 0) && (result.serial < 4294967295));\n-\n     assert.strictEqual(typeof result.refresh, 'number');\n     assert.ok((result.refresh > 0) && (result.refresh < 2147483647));\n-\n     assert.strictEqual(typeof result.retry, 'number');\n     assert.ok((result.retry > 0) && (result.retry < 2147483647));\n-\n     assert.strictEqual(typeof result.expire, 'number');\n     assert.ok((result.expire > 0) && (result.expire < 2147483647));\n-\n     assert.strictEqual(typeof result.minttl, 'number');\n     assert.ok((result.minttl >= 0) && (result.minttl < 2147483647));\n+  }\n \n+  validateResult(await dnsPromises.resolveSoa(addresses.SOA_HOST));\n+\n+  const req = dns.resolveSoa(addresses.SOA_HOST, function(err, result) {\n+    assert.ifError(err);\n+    validateResult(result);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n TEST(function test_resolveSoa_failure(done) {\n+  dnsPromises.resolveSoa(addresses.INVALID_HOST)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: 'ENOTFOUND' }));\n+\n   const req = dns.resolveSoa(addresses.INVALID_HOST, function(err, result) {\n     assert.ok(err instanceof Error);\n     assert.strictEqual(err.errno, 'ENOTFOUND');\n@@ -335,24 +399,33 @@ TEST(function test_resolveSoa_failure(done) {\n   checkWrap(req);\n });\n \n-TEST(function test_resolveCname(done) {\n-  const req = dns.resolveCname(addresses.CNAME_HOST, function(err, names) {\n-    assert.ifError(err);\n-    assert.ok(names.length > 0);\n+TEST(async function test_resolveCname(done) {\n+  function validateResult(result) {\n+    assert.ok(result.length > 0);\n \n-    for (let i = 0; i < names.length; i++) {\n-      const name = names[i];\n+    for (let i = 0; i < result.length; i++) {\n+      const name = result[i];\n       assert.ok(name);\n       assert.strictEqual(typeof name, 'string');\n     }\n+  }\n+\n+  validateResult(await dnsPromises.resolveCname(addresses.CNAME_HOST));\n \n+  const req = dns.resolveCname(addresses.CNAME_HOST, function(err, names) {\n+    assert.ifError(err);\n+    validateResult(names);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n TEST(function test_resolveCname_failure(done) {\n+  dnsPromises.resolveCname(addresses.INVALID_HOST)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: 'ENOTFOUND' }));\n+\n   const req = dns.resolveCname(addresses.INVALID_HOST, function(err, result) {\n     assert.ok(err instanceof Error);\n     assert.strictEqual(err.errno, 'ENOTFOUND');\n@@ -366,19 +439,29 @@ TEST(function test_resolveCname_failure(done) {\n });\n \n \n-TEST(function test_resolveTxt(done) {\n+TEST(async function test_resolveTxt(done) {\n+  function validateResult(result) {\n+    assert.ok(Array.isArray(result[0]));\n+    assert.strictEqual(result.length, 1);\n+    assert(result[0][0].startsWith('v=spf1'));\n+  }\n+\n+  validateResult(await dnsPromises.resolveTxt(addresses.TXT_HOST));\n+\n   const req = dns.resolveTxt(addresses.TXT_HOST, function(err, records) {\n     assert.ifError(err);\n-    assert.strictEqual(records.length, 1);\n-    assert.ok(util.isArray(records[0]));\n-    assert(records[0][0].startsWith('v=spf1'));\n+    validateResult(records);\n     done();\n   });\n \n   checkWrap(req);\n });\n \n TEST(function test_resolveTxt_failure(done) {\n+  dnsPromises.resolveTxt(addresses.INVALID_HOST)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: 'ENOTFOUND' }));\n+\n   const req = dns.resolveTxt(addresses.INVALID_HOST, function(err, result) {\n     assert.ok(err instanceof Error);\n     assert.strictEqual(err.errno, 'ENOTFOUND');\n@@ -393,6 +476,10 @@ TEST(function test_resolveTxt_failure(done) {\n \n \n TEST(function test_lookup_failure(done) {\n+  dnsPromises.lookup(addresses.INVALID_HOST, 4)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ errno: dns.NOTFOUND }));\n+\n   const req = dns.lookup(addresses.INVALID_HOST, 4, (err, ip, family) => {\n     assert.ok(err instanceof Error);\n     assert.strictEqual(err.errno, dns.NOTFOUND);\n@@ -407,17 +494,23 @@ TEST(function test_lookup_failure(done) {\n });\n \n \n-TEST(function test_lookup_ip_all(done) {\n+TEST(async function test_lookup_ip_all(done) {\n+  function validateResult(result) {\n+    assert.ok(Array.isArray(result));\n+    assert.ok(result.length > 0);\n+    assert.strictEqual(result[0].address, '127.0.0.1');\n+    assert.strictEqual(result[0].family, 4);\n+  }\n+\n+  validateResult(await dnsPromises.lookup('127.0.0.1', { all: true }));\n+\n   const req = dns.lookup(\n     '127.0.0.1',\n     { all: true },\n     function(err, ips, family) {\n       assert.ifError(err);\n-      assert.ok(Array.isArray(ips));\n-      assert.ok(ips.length > 0);\n-      assert.strictEqual(ips[0].address, '127.0.0.1');\n-      assert.strictEqual(ips[0].family, 4);\n-\n+      assert.strictEqual(family, undefined);\n+      validateResult(ips);\n       done();\n     }\n   );\n@@ -452,7 +545,9 @@ TEST(function test_lookup_ip_promise(done) {\n });\n \n \n-TEST(function test_lookup_null_all(done) {\n+TEST(async function test_lookup_null_all(done) {\n+  assert.deepStrictEqual(await dnsPromises.lookup(null, { all: true }), []);\n+\n   const req = dns.lookup(null, { all: true }, function(err, ips, family) {\n     assert.ifError(err);\n     assert.ok(Array.isArray(ips));\n@@ -465,23 +560,28 @@ TEST(function test_lookup_null_all(done) {\n });\n \n \n-TEST(function test_lookup_all_mixed(done) {\n-  const req = dns.lookup(addresses.INET_HOST, {\n-    all: true\n-  }, function(err, ips) {\n-    assert.ifError(err);\n-    assert.ok(Array.isArray(ips));\n-    assert.ok(ips.length > 0);\n+TEST(async function test_lookup_all_mixed(done) {\n+  function validateResult(result) {\n+    assert.ok(Array.isArray(result));\n+    assert.ok(result.length > 0);\n \n-    ips.forEach(function(ip) {\n+    result.forEach(function(ip) {\n       if (isIPv4(ip.address))\n         assert.strictEqual(ip.family, 4);\n       else if (isIPv6(ip.address))\n         assert.strictEqual(ip.family, 6);\n       else\n         assert.fail('unexpected IP address');\n     });\n+  }\n+\n+  validateResult(await dnsPromises.lookup(addresses.INET_HOST, { all: true }));\n \n+  const req = dns.lookup(addresses.INET_HOST, {\n+    all: true\n+  }, function(err, ips) {\n+    assert.ifError(err);\n+    validateResult(ips);\n     done();\n   });\n \n@@ -490,6 +590,10 @@ TEST(function test_lookup_all_mixed(done) {\n \n \n TEST(function test_lookupservice_invalid(done) {\n+  dnsPromises.lookupService('1.2.3.4', 80)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({ code: 'ENOTFOUND' }));\n+\n   const req = dns.lookupService('1.2.3.4', 80, function(err, host, service) {\n     assert(err instanceof Error);\n     assert.strictEqual(err.code, 'ENOTFOUND');\n@@ -503,6 +607,13 @@ TEST(function test_lookupservice_invalid(done) {\n \n \n TEST(function test_reverse_failure(done) {\n+  dnsPromises.reverse('203.0.113.0')\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({\n+      code: 'ENOTFOUND',\n+      hostname: '203.0.113.0'\n+    }));\n+\n   // 203.0.113.0/24 are addresses reserved for (RFC) documentation use only\n   const req = dns.reverse('203.0.113.0', function(err) {\n     assert(err instanceof Error);\n@@ -518,6 +629,13 @@ TEST(function test_reverse_failure(done) {\n \n \n TEST(function test_lookup_failure(done) {\n+  dnsPromises.lookup(addresses.INVALID_HOST)\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({\n+      code: 'ENOTFOUND',\n+      hostname: addresses.INVALID_HOST\n+    }));\n+\n   const req = dns.lookup(addresses.INVALID_HOST, (err) => {\n     assert(err instanceof Error);\n     assert.strictEqual(err.code, 'ENOTFOUND');  // Silly error code...\n@@ -584,3 +702,7 @@ dns.lookup(addresses.INET6_HOST, 6, common.mustCall());\n dns.lookup(addresses.INET_HOST, {}, common.mustCall());\n dns.lookupService('0.0.0.0', '0', common.mustCall());\n dns.lookupService('0.0.0.0', 0, common.mustCall());\n+(async function() {\n+  await dnsPromises.lookup(addresses.INET6_HOST, 6);\n+  await dnsPromises.lookup(addresses.INET_HOST, {});\n+})();"
        },
        {
            "sha": "59ae40b2b825683f0248183d38950142e66fa61f",
            "filename": "test/parallel/test-c-ares.js",
            "status": "modified",
            "additions": 31,
            "deletions": 5,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-c-ares.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-c-ares.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-c-ares.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -23,8 +23,26 @@\n const common = require('../common');\n const assert = require('assert');\n \n+common.crashOnUnhandledRejection();\n+\n const dns = require('dns');\n+const dnsPromises = dns.promises;\n+\n+(async function() {\n+  let res;\n+\n+  res = await dnsPromises.lookup(null);\n+  assert.strictEqual(res.address, null);\n+  assert.strictEqual(res.family, 4);\n+\n+  res = await dnsPromises.lookup('127.0.0.1');\n+  assert.strictEqual(res.address, '127.0.0.1');\n+  assert.strictEqual(res.family, 4);\n \n+  res = await dnsPromises.lookup('::1');\n+  assert.strictEqual(res.address, '::1');\n+  assert.strictEqual(res.family, 6);\n+})();\n \n // Try resolution without callback\n \n@@ -52,14 +70,18 @@ dns.lookup('::1', common.mustCall((error, result, addressType) => {\n   // Try calling resolve with an unsupported type that's an object key\n   'toString'\n ].forEach((val) => {\n+  const err = {\n+    code: 'ERR_INVALID_OPT_VALUE',\n+    type: TypeError,\n+    message: `The value \"${val}\" is invalid for option \"rrtype\"`\n+  };\n+\n   common.expectsError(\n     () => dns.resolve('www.google.com', val),\n-    {\n-      code: 'ERR_INVALID_OPT_VALUE',\n-      type: TypeError,\n-      message: `The value \"${val}\" is invalid for option \"rrtype\"`\n-    }\n+    err\n   );\n+\n+  common.expectsError(() => dnsPromises.resolve('www.google.com', val), err);\n });\n \n // Windows doesn't usually have an entry for localhost 127.0.0.1 in\n@@ -70,4 +92,8 @@ if (!common.isWindows) {\n     assert.ifError(error);\n     assert.ok(Array.isArray(domains));\n   }));\n+\n+  (async function() {\n+    assert.ok(Array.isArray(await dnsPromises.reverse('127.0.0.1')));\n+  })();\n }"
        },
        {
            "sha": "5ee3bc7051e521a663b2ad24ff4f6f8f9e024b3b",
            "filename": "test/parallel/test-dns-lookup.js",
            "status": "modified",
            "additions": 66,
            "deletions": 23,
            "changes": 89,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns-lookup.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns-lookup.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dns-lookup.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -3,17 +3,23 @@ const common = require('../common');\n const assert = require('assert');\n const cares = process.binding('cares_wrap');\n const dns = require('dns');\n+const dnsPromises = dns.promises;\n+\n+common.crashOnUnhandledRejection();\n \n // Stub `getaddrinfo` to *always* error.\n cares.getaddrinfo = () => process.binding('uv').UV_ENOENT;\n \n-common.expectsError(() => {\n-  dns.lookup(1, {});\n-}, {\n-  code: 'ERR_INVALID_ARG_TYPE',\n-  type: TypeError,\n-  message: /^The \"hostname\" argument must be one of type string or falsy/\n-});\n+{\n+  const err = {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: /^The \"hostname\" argument must be one of type string or falsy/\n+  };\n+\n+  common.expectsError(() => dns.lookup(1, {}), err);\n+  common.expectsError(() => dnsPromises.lookup(1, {}), err);\n+}\n \n common.expectsError(() => {\n   dns.lookup(false, 'cb');\n@@ -29,29 +35,66 @@ common.expectsError(() => {\n   type: TypeError\n });\n \n-common.expectsError(() => {\n-  dns.lookup(false, {\n+{\n+  const err = {\n+    code: 'ERR_INVALID_OPT_VALUE',\n+    type: TypeError,\n+    message: 'The value \"100\" is invalid for option \"hints\"'\n+  };\n+  const options = {\n     hints: 100,\n     family: 0,\n     all: false\n-  }, common.mustNotCall());\n-}, {\n-  code: 'ERR_INVALID_OPT_VALUE',\n-  type: TypeError,\n-  message: 'The value \"100\" is invalid for option \"hints\"'\n-});\n+  };\n \n-common.expectsError(() => {\n-  dns.lookup(false, {\n+  common.expectsError(() => { dnsPromises.lookup(false, options); }, err);\n+  common.expectsError(() => {\n+    dns.lookup(false, options, common.mustNotCall());\n+  }, err);\n+}\n+\n+{\n+  const err = {\n+    code: 'ERR_INVALID_OPT_VALUE',\n+    type: TypeError,\n+    message: 'The value \"20\" is invalid for option \"family\"'\n+  };\n+  const options = {\n     hints: 0,\n     family: 20,\n     all: false\n-  }, common.mustNotCall());\n-}, {\n-  code: 'ERR_INVALID_OPT_VALUE',\n-  type: TypeError,\n-  message: 'The value \"20\" is invalid for option \"family\"'\n-});\n+  };\n+\n+  common.expectsError(() => { dnsPromises.lookup(false, options); }, err);\n+  common.expectsError(() => {\n+    dns.lookup(false, options, common.mustNotCall());\n+  }, err);\n+}\n+\n+(async function() {\n+  let res;\n+\n+  res = await dnsPromises.lookup(false, {\n+    hints: 0,\n+    family: 0,\n+    all: true\n+  });\n+  assert.deepStrictEqual(res, []);\n+\n+  res = await dnsPromises.lookup('127.0.0.1', {\n+    hints: 0,\n+    family: 4,\n+    all: true\n+  });\n+  assert.deepStrictEqual(res, [{ address: '127.0.0.1', family: 4 }]);\n+\n+  res = await dnsPromises.lookup('127.0.0.1', {\n+    hints: 0,\n+    family: 4,\n+    all: false\n+  });\n+  assert.deepStrictEqual(res, { address: '127.0.0.1', family: 4 });\n+})();\n \n dns.lookup(false, {\n   hints: 0,"
        },
        {
            "sha": "d48d9385b84b90785143ab7ca32008b117a68265",
            "filename": "test/parallel/test-dns-resolveany-bad-ancount.js",
            "status": "modified",
            "additions": 13,
            "deletions": 2,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns-resolveany-bad-ancount.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns-resolveany-bad-ancount.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dns-resolveany-bad-ancount.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -4,6 +4,9 @@ const dnstools = require('../common/dns');\n const dns = require('dns');\n const assert = require('assert');\n const dgram = require('dgram');\n+const dnsPromises = dns.promises;\n+\n+common.crashOnUnhandledRejection();\n \n const server = dgram.createSocket('udp4');\n \n@@ -20,12 +23,20 @@ server.on('message', common.mustCall((msg, { address, port }) => {\n   // Overwrite the # of answers with 2, which is incorrect.\n   buf.writeUInt16LE(2, 6);\n   server.send(buf, port, address);\n-}));\n+}, 2));\n \n-server.bind(0, common.mustCall(() => {\n+server.bind(0, common.mustCall(async () => {\n   const address = server.address();\n   dns.setServers([`127.0.0.1:${address.port}`]);\n \n+  dnsPromises.resolveAny('example.org')\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({\n+      code: 'EBADRESP',\n+      syscall: 'queryAny',\n+      hostname: 'example.org'\n+    }));\n+\n   dns.resolveAny('example.org', common.mustCall((err) => {\n     assert.strictEqual(err.code, 'EBADRESP');\n     assert.strictEqual(err.syscall, 'queryAny');"
        },
        {
            "sha": "f9a6399cef52d04af666579b36277b67431fcd0b",
            "filename": "test/parallel/test-dns-resolveany.js",
            "status": "modified",
            "additions": 15,
            "deletions": 6,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns-resolveany.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns-resolveany.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dns-resolveany.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -4,6 +4,9 @@ const dnstools = require('../common/dns');\n const dns = require('dns');\n const assert = require('assert');\n const dgram = require('dgram');\n+const dnsPromises = dns.promises;\n+\n+common.crashOnUnhandledRejection();\n \n const answers = [\n   { type: 'A', address: '1.2.3.4', ttl: 123 },\n@@ -36,18 +39,24 @@ server.on('message', common.mustCall((msg, { address, port }) => {\n     questions: parsed.questions,\n     answers: answers.map((answer) => Object.assign({ domain }, answer)),\n   }), port, address);\n-}));\n+}, 2));\n \n-server.bind(0, common.mustCall(() => {\n+server.bind(0, common.mustCall(async () => {\n   const address = server.address();\n   dns.setServers([`127.0.0.1:${address.port}`]);\n \n+  validateResults(await dnsPromises.resolveAny('example.org'));\n+\n   dns.resolveAny('example.org', common.mustCall((err, res) => {\n     assert.ifError(err);\n-    // Compare copies with ttl removed, c-ares fiddles with that value.\n-    assert.deepStrictEqual(\n-      res.map((r) => Object.assign({}, r, { ttl: null })),\n-      answers.map((r) => Object.assign({}, r, { ttl: null })));\n+    validateResults(res);\n     server.close();\n   }));\n }));\n+\n+function validateResults(res) {\n+  // Compare copies with ttl removed, c-ares fiddles with that value.\n+  assert.deepStrictEqual(\n+    res.map((r) => Object.assign({}, r, { ttl: null })),\n+    answers.map((r) => Object.assign({}, r, { ttl: null })));\n+}"
        },
        {
            "sha": "ec57bba61487421afa481276efefd435da0107c3",
            "filename": "test/parallel/test-dns-resolvens-typeerror.js",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns-resolvens-typeerror.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns-resolvens-typeerror.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dns-resolvens-typeerror.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -27,7 +27,18 @@ const common = require('../common');\n // Issue https://github.com/nodejs/node-v0.x-archive/issues/7070\n \n const dns = require('dns');\n+const dnsPromises = dns.promises;\n \n+common.crashOnUnhandledRejection();\n+\n+common.expectsError(\n+  () => dnsPromises.resolveNs([]), // bad name\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+    message: /^The \"name\" argument must be of type string/\n+  }\n+);\n common.expectsError(\n   () => dns.resolveNs([]), // bad name\n   {"
        },
        {
            "sha": "9acf18994e6fe7f5f88e9e31283cf252cf535a5d",
            "filename": "test/parallel/test-dns.js",
            "status": "modified",
            "additions": 87,
            "deletions": 47,
            "changes": 134,
            "blob_url": "https://github.com/nodejs/node/blob/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns.js",
            "raw_url": "https://github.com/nodejs/node/raw/7486c4d71060e2ae3e754cf01e8fb02696eacd13/test%2Fparallel%2Ftest-dns.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dns.js?ref=7486c4d71060e2ae3e754cf01e8fb02696eacd13",
            "patch": "@@ -24,6 +24,9 @@ const common = require('../common');\n const assert = require('assert');\n \n const dns = require('dns');\n+const dnsPromises = dns.promises;\n+\n+common.crashOnUnhandledRejection();\n \n const existing = dns.getServers();\n assert(existing.length > 0);\n@@ -149,7 +152,7 @@ common.expectsError(() => {\n     code: 'ERR_INVALID_ARG_TYPE',\n     type: TypeError,\n     message: /^The \"hostname\" argument must be one of type string or falsy/\n-  }, 5);\n+  }, 10);\n \n   assert.throws(() => dns.lookup({}, common.mustNotCall()), errorReg);\n \n@@ -161,6 +164,12 @@ common.expectsError(() => {\n \n   assert.throws(() => dns.lookup(common.mustNotCall(), common.mustNotCall()),\n                 errorReg);\n+\n+  assert.throws(() => dnsPromises.lookup({}), errorReg);\n+  assert.throws(() => dnsPromises.lookup([]), errorReg);\n+  assert.throws(() => dnsPromises.lookup(true), errorReg);\n+  assert.throws(() => dnsPromises.lookup(1), errorReg);\n+  assert.throws(() => dnsPromises.lookup(common.mustNotCall()), errorReg);\n }\n \n // dns.lookup should accept falsey values\n@@ -171,30 +180,37 @@ common.expectsError(() => {\n     assert.strictEqual(family, 4);\n   };\n \n-  dns.lookup('', common.mustCall(checkCallback));\n-  dns.lookup(null, common.mustCall(checkCallback));\n-  dns.lookup(undefined, common.mustCall(checkCallback));\n-  dns.lookup(0, common.mustCall(checkCallback));\n-  dns.lookup(NaN, common.mustCall(checkCallback));\n+  ['', null, undefined, 0, NaN].forEach(async (value) => {\n+    const res = await dnsPromises.lookup(value);\n+    assert.deepStrictEqual(res, { address: null, family: 4 });\n+    dns.lookup(value, common.mustCall(checkCallback));\n+  });\n }\n \n-/*\n- * Make sure that dns.lookup throws if hints does not represent a valid flag.\n- * (dns.V4MAPPED | dns.ADDRCONFIG) + 1 is invalid because:\n- * - it's different from dns.V4MAPPED and dns.ADDRCONFIG.\n- * - it's different from them bitwise ored.\n- * - it's different from 0.\n- * - it's an odd number different than 1, and thus is invalid, because\n- * flags are either === 1 or even.\n- */\n-common.expectsError(() => {\n-  dns.lookup('nodejs.org', { hints: (dns.V4MAPPED | dns.ADDRCONFIG) + 1 },\n-             common.mustNotCall());\n-}, {\n-  code: 'ERR_INVALID_OPT_VALUE',\n-  type: TypeError,\n-  message: /The value \"\\d+\" is invalid for option \"hints\"/\n-});\n+{\n+  /*\n+  * Make sure that dns.lookup throws if hints does not represent a valid flag.\n+  * (dns.V4MAPPED | dns.ADDRCONFIG) + 1 is invalid because:\n+  * - it's different from dns.V4MAPPED and dns.ADDRCONFIG.\n+  * - it's different from them bitwise ored.\n+  * - it's different from 0.\n+  * - it's an odd number different than 1, and thus is invalid, because\n+  * flags are either === 1 or even.\n+  */\n+  const hints = (dns.V4MAPPED | dns.ADDRCONFIG) + 1;\n+  const err = {\n+    code: 'ERR_INVALID_OPT_VALUE',\n+    type: TypeError,\n+    message: /The value \"\\d+\" is invalid for option \"hints\"/\n+  };\n+\n+  common.expectsError(() => {\n+    dnsPromises.lookup('nodejs.org', { hints });\n+  }, err);\n+  common.expectsError(() => {\n+    dns.lookup('nodejs.org', { hints }, common.mustNotCall());\n+  }, err);\n+}\n \n common.expectsError(() => dns.lookup('nodejs.org'), {\n   code: 'ERR_INVALID_CALLBACK',\n@@ -219,33 +235,57 @@ dns.lookup('', {\n   hints: dns.ADDRCONFIG | dns.V4MAPPED\n }, common.mustCall());\n \n-common.expectsError(() => dns.lookupService('0.0.0.0'), {\n-  code: 'ERR_MISSING_ARGS',\n-  type: TypeError,\n-  message: 'The \"host\", \"port\", and \"callback\" arguments must be specified'\n-});\n+(async function() {\n+  await dnsPromises.lookup('', { family: 4, hints: 0 });\n+  await dnsPromises.lookup('', { family: 6, hints: dns.ADDRCONFIG });\n+  await dnsPromises.lookup('', { hints: dns.V4MAPPED });\n+  await dnsPromises.lookup('', { hints: dns.ADDRCONFIG | dns.V4MAPPED });\n+})();\n \n-const invalidHost = 'fasdfdsaf';\n-common.expectsError(() => {\n-  dns.lookupService(invalidHost, 0, common.mustNotCall());\n-}, {\n-  code: 'ERR_INVALID_OPT_VALUE',\n-  type: TypeError,\n-  message: `The value \"${invalidHost}\" is invalid for option \"host\"`\n-});\n+{\n+  const err = {\n+    code: 'ERR_MISSING_ARGS',\n+    type: TypeError,\n+    message: 'The \"host\", \"port\", and \"callback\" arguments must be specified'\n+  };\n+\n+  common.expectsError(() => dns.lookupService('0.0.0.0'), err);\n+  err.message = 'The \"host\" and \"port\" arguments must be specified';\n+  common.expectsError(() => dnsPromises.lookupService('0.0.0.0'), err);\n+}\n+\n+{\n+  const invalidHost = 'fasdfdsaf';\n+  const err = {\n+    code: 'ERR_INVALID_OPT_VALUE',\n+    type: TypeError,\n+    message: `The value \"${invalidHost}\" is invalid for option \"host\"`\n+  };\n+\n+  common.expectsError(() => {\n+    dnsPromises.lookupService(invalidHost, 0);\n+  }, err);\n+\n+  common.expectsError(() => {\n+    dns.lookupService(invalidHost, 0, common.mustNotCall());\n+  }, err);\n+}\n \n const portErr = (port) => {\n-  common.expectsError(\n-    () => {\n-      dns.lookupService('0.0.0.0', port, common.mustNotCall());\n-    },\n-    {\n-      code: 'ERR_SOCKET_BAD_PORT',\n-      message:\n-        `Port should be > 0 and < 65536. Received ${port}.`,\n-      type: RangeError\n-    }\n-  );\n+  const err = {\n+    code: 'ERR_SOCKET_BAD_PORT',\n+    message:\n+      `Port should be > 0 and < 65536. Received ${port}.`,\n+    type: RangeError\n+  };\n+\n+  common.expectsError(() => {\n+    dnsPromises.lookupService('0.0.0.0', port);\n+  }, err);\n+\n+  common.expectsError(() => {\n+    dns.lookupService('0.0.0.0', port, common.mustNotCall());\n+  }, err);\n };\n portErr(null);\n portErr(undefined);"
        }
    ],
    "stats": {
        "total": 1957,
        "additions": 1551,
        "deletions": 406
    }
}