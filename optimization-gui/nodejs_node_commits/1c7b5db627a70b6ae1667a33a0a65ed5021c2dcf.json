{
    "author": "ZYSzys",
    "message": "test: add test for fs.lchmod\n\nPR-URL: https://github.com/nodejs/node/pull/25439\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Masashi Hirano <shisama07@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "1c7b5db627a70b6ae1667a33a0a65ed5021c2dcf",
    "files": [
        {
            "sha": "3238790152b70ea6a1b01926df1ea78f625eed12",
            "filename": "test/parallel/test-fs-lchmod.js",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/1c7b5db627a70b6ae1667a33a0a65ed5021c2dcf/test%2Fparallel%2Ftest-fs-lchmod.js",
            "raw_url": "https://github.com/nodejs/node/raw/1c7b5db627a70b6ae1667a33a0a65ed5021c2dcf/test%2Fparallel%2Ftest-fs-lchmod.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-lchmod.js?ref=1c7b5db627a70b6ae1667a33a0a65ed5021c2dcf",
            "patch": "@@ -0,0 +1,67 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const util = require('util');\n+const fs = require('fs');\n+const { promises } = fs;\n+const f = __filename;\n+\n+// This test ensures that input for lchmod is valid, testing for valid\n+// inputs for path, mode and callback\n+\n+if (!common.isOSX) {\n+  common.skip('lchmod is only available on macOS');\n+}\n+\n+// Check callback\n+assert.throws(() => fs.lchmod(f), { code: 'ERR_INVALID_CALLBACK' });\n+assert.throws(() => fs.lchmod(), { code: 'ERR_INVALID_CALLBACK' });\n+assert.throws(() => fs.lchmod(f, {}), { code: 'ERR_INVALID_CALLBACK' });\n+\n+// Check path\n+[false, 1, {}, [], null, undefined].forEach((i) => {\n+  common.expectsError(\n+    () => fs.lchmod(i, 0o777, common.mustNotCall()),\n+    {\n+      code: 'ERR_INVALID_ARG_TYPE',\n+      type: TypeError\n+    }\n+  );\n+  common.expectsError(\n+    () => fs.lchmodSync(i),\n+    {\n+      code: 'ERR_INVALID_ARG_TYPE',\n+      type: TypeError\n+    }\n+  );\n+});\n+\n+// Check mode\n+[false, null, undefined, {}, [], '', '123x'].forEach((input) => {\n+  const errObj = {\n+    code: 'ERR_INVALID_ARG_VALUE',\n+    name: 'TypeError [ERR_INVALID_ARG_VALUE]',\n+    message: 'The argument \\'mode\\' must be a 32-bit unsigned integer or an ' +\n+             `octal string. Received ${util.inspect(input)}`\n+  };\n+\n+  promises.lchmod(f, input, () => {})\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError(errObj));\n+  assert.throws(() => fs.lchmodSync(f, input), errObj);\n+});\n+\n+[-1, 2 ** 32].forEach((input) => {\n+  const errObj = {\n+    code: 'ERR_OUT_OF_RANGE',\n+    name: 'RangeError [ERR_OUT_OF_RANGE]',\n+    message: 'The value of \"mode\" is out of range. It must be >= 0 && < ' +\n+             `4294967296. Received ${input}`\n+  };\n+\n+  promises.lchmod(f, input, () => {})\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError(errObj));\n+  assert.throws(() => fs.lchmodSync(f, input), errObj);\n+});"
        }
    ],
    "stats": {
        "total": 67,
        "additions": 67,
        "deletions": 0
    }
}