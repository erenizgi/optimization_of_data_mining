{
    "author": "kodemill",
    "message": "stream: inline needMoreData function\n\nInline the needMoreData function since it has only one call place.\nUpdate the related comment.\nAdd a test for the edge case where HWM=0 and state.length=0.\nAdd a test for ReadableStream.read(n) method's edge case where\nn, HWM and state.length are all zero.\nThis proves that there is no easy way to simplify the check at\nhttps://github.com/nodejs/node/blob/master/lib/_stream_readable.js#L440\n\nFixes: https://github.com/nodejs/node/issues/19893\nRefs: https://github.com/nodejs/node/pull/19896\n\nPR-URL: https://github.com/nodejs/node/pull/21009\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Lance Ball <lball@redhat.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>",
    "sha": "1c07ebfd97bf4d10a6c9220f12eb476c174ab3b0",
    "files": [
        {
            "sha": "31b129facd3a3848e1718b2cfcfaa2656d75f549",
            "filename": "lib/_stream_readable.js",
            "status": "modified",
            "additions": 5,
            "deletions": 14,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/1c07ebfd97bf4d10a6c9220f12eb476c174ab3b0/lib%2F_stream_readable.js",
            "raw_url": "https://github.com/nodejs/node/raw/1c07ebfd97bf4d10a6c9220f12eb476c174ab3b0/lib%2F_stream_readable.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_stream_readable.js?ref=1c07ebfd97bf4d10a6c9220f12eb476c174ab3b0",
            "patch": "@@ -270,7 +270,11 @@ function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n     }\n   }\n \n-  return needMoreData(state);\n+  // We can push more data if we are below the highWaterMark.\n+  // Also, if we have no data yet, we can stand some more bytes.\n+  // This is to work around cases where hwm=0, such as the repl.\n+  return !state.ended &&\n+    (state.length < state.highWaterMark || state.length === 0);\n }\n \n function addChunk(stream, state, chunk, addToFront) {\n@@ -304,19 +308,6 @@ function chunkInvalid(state, chunk) {\n }\n \n \n-// We can push more data if we are below the highWaterMark.\n-// Also, if we have no data yet, we can stand some\n-// more bytes.  This is to work around cases where hwm=0,\n-// such as the repl.  Also, if the push() triggered a\n-// readable event, and the user called read(largeNumber) such that\n-// needReadable was set, then we ought to push more, so that another\n-// 'readable' event will be triggered.\n-function needMoreData(state) {\n-  return !state.ended &&\n-         (state.length < state.highWaterMark ||\n-          state.length === 0);\n-}\n-\n Readable.prototype.isPaused = function() {\n   return this._readableState.flowing === false;\n };"
        },
        {
            "sha": "4dd9694a464272eaa0b01fa9ad5ad3488a9bc57e",
            "filename": "test/parallel/test-streams-highwatermark.js",
            "status": "modified",
            "additions": 50,
            "deletions": 23,
            "changes": 73,
            "blob_url": "https://github.com/nodejs/node/blob/1c07ebfd97bf4d10a6c9220f12eb476c174ab3b0/test%2Fparallel%2Ftest-streams-highwatermark.js",
            "raw_url": "https://github.com/nodejs/node/raw/1c07ebfd97bf4d10a6c9220f12eb476c174ab3b0/test%2Fparallel%2Ftest-streams-highwatermark.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-streams-highwatermark.js?ref=1c07ebfd97bf4d10a6c9220f12eb476c174ab3b0",
            "patch": "@@ -1,31 +1,58 @@\n 'use strict';\n const common = require('../common');\n \n-// This test ensures that the stream implementation correctly handles values\n-// for highWaterMark which exceed the range of signed 32 bit integers and\n-// rejects invalid values.\n-\n const assert = require('assert');\n const stream = require('stream');\n \n-// This number exceeds the range of 32 bit integer arithmetic but should still\n-// be handled correctly.\n-const ovfl = Number.MAX_SAFE_INTEGER;\n-\n-const readable = stream.Readable({ highWaterMark: ovfl });\n-assert.strictEqual(readable._readableState.highWaterMark, ovfl);\n-\n-const writable = stream.Writable({ highWaterMark: ovfl });\n-assert.strictEqual(writable._writableState.highWaterMark, ovfl);\n-\n-for (const invalidHwm of [true, false, '5', {}, -5, NaN]) {\n-  for (const type of [stream.Readable, stream.Writable]) {\n-    common.expectsError(() => {\n-      type({ highWaterMark: invalidHwm });\n-    }, {\n-      type: TypeError,\n-      code: 'ERR_INVALID_OPT_VALUE',\n-      message: `The value \"${invalidHwm}\" is invalid for option \"highWaterMark\"`\n-    });\n+{\n+  // This test ensures that the stream implementation correctly handles values\n+  // for highWaterMark which exceed the range of signed 32 bit integers and\n+  // rejects invalid values.\n+\n+  // This number exceeds the range of 32 bit integer arithmetic but should still\n+  // be handled correctly.\n+  const ovfl = Number.MAX_SAFE_INTEGER;\n+\n+  const readable = stream.Readable({ highWaterMark: ovfl });\n+  assert.strictEqual(readable._readableState.highWaterMark, ovfl);\n+\n+  const writable = stream.Writable({ highWaterMark: ovfl });\n+  assert.strictEqual(writable._writableState.highWaterMark, ovfl);\n+\n+  for (const invalidHwm of [true, false, '5', {}, -5, NaN]) {\n+    for (const type of [stream.Readable, stream.Writable]) {\n+      common.expectsError(() => {\n+        type({ highWaterMark: invalidHwm });\n+      }, {\n+        type: TypeError,\n+        code: 'ERR_INVALID_OPT_VALUE',\n+        message:\n+          `The value \"${invalidHwm}\" is invalid for option \"highWaterMark\"`\n+      });\n+    }\n+  }\n+}\n+\n+{\n+  // This test ensures that the push method's implementation\n+  // correctly handles the edge case where the highWaterMark and\n+  // the state.length are both zero\n+\n+  const readable = stream.Readable({ highWaterMark: 0 });\n+\n+  for (let i = 0; i < 3; i++) {\n+    const needMoreData = readable.push();\n+    assert.strictEqual(needMoreData, true);\n   }\n }\n+\n+{\n+  // This test ensures that the read(n) method's implementation\n+  // correctly handles the edge case where the highWaterMark, state.length\n+  // and n are all zero\n+\n+  const readable = stream.Readable({ highWaterMark: 0 });\n+\n+  readable._read = common.mustCall();\n+  readable.read(0);\n+}"
        }
    ],
    "stats": {
        "total": 92,
        "additions": 55,
        "deletions": 37
    }
}