{
    "author": "davidben",
    "message": "crypto: fix malloc mixing in X509ToObject\n\nEC_KEY_key2buf returns an OPENSSL_malloc'd pointer so it shouldn't be\npassed into Buffer::New, which expect a libc malloc'd pointer. Instead,\nfactor out the ECDH::GetPublicKey code which uses EC_POINT_point2oct.\n\nThis preserves the existing behavior where encoding failures are\nsilently ignored, but it is probably safe to CHECK fail them instead.\n\nPR-URL: https://github.com/nodejs/node/pull/25717\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "ebda39a2a9e2b3136154e00a7a40e48b1d130850",
    "files": [
        {
            "sha": "7e2c68315bd1fe0c183614f1b9c190feff1b1c4d",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 42,
            "changes": 72,
            "blob_url": "https://github.com/nodejs/node/blob/ebda39a2a9e2b3136154e00a7a40e48b1d130850/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ebda39a2a9e2b3136154e00a7a40e48b1d130850/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=ebda39a2a9e2b3136154e00a7a40e48b1d130850",
            "patch": "@@ -1640,6 +1640,24 @@ static void AddFingerprintDigest(const unsigned char* md,\n   }\n }\n \n+static MaybeLocal<Object> ECPointToBuffer(Environment* env,\n+                                          const EC_GROUP* group,\n+                                          const EC_POINT* point,\n+                                          point_conversion_form_t form) {\n+  size_t len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);\n+  if (len == 0) {\n+    env->ThrowError(\"Failed to get public key length\");\n+    return MaybeLocal<Object>();\n+  }\n+  MallocedBuffer<unsigned char> buf(len);\n+  len = EC_POINT_point2oct(group, point, form, buf.data, buf.size, nullptr);\n+  if (len == 0) {\n+    env->ThrowError(\"Failed to get public key\");\n+    return MaybeLocal<Object>();\n+  }\n+  return Buffer::New(env, buf.release(), len);\n+}\n+\n static Local<Object> X509ToObject(Environment* env, X509* cert) {\n   EscapableHandleScope scope(env->isolate());\n   Local<Context> context = env->context();\n@@ -1756,16 +1774,12 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n       }\n     }\n \n-    unsigned char* pub = nullptr;\n-    size_t publen = EC_KEY_key2buf(ec.get(), EC_KEY_get_conv_form(ec.get()),\n-                                   &pub, nullptr);\n-    if (publen > 0) {\n-      Local<Object> buf = Buffer::New(env, pub, publen).ToLocalChecked();\n-      // Ownership of pub pointer accepted by Buffer.\n-      pub = nullptr;\n+    const EC_POINT* pubkey = EC_KEY_get0_public_key(ec.get());\n+    if (pubkey != nullptr) {\n+      Local<Object> buf =\n+          ECPointToBuffer(env, group, pubkey, EC_KEY_get_conv_form(ec.get()))\n+              .ToLocalChecked();\n       info->Set(context, env->pubkey_string(), buf).FromJust();\n-    } else {\n-      CHECK_NULL(pub);\n     }\n \n     const int nid = EC_GROUP_get_curve_name(group);\n@@ -5265,26 +5279,14 @@ void ECDH::GetPublicKey(const FunctionCallbackInfo<Value>& args) {\n   if (pub == nullptr)\n     return env->ThrowError(\"Failed to get ECDH public key\");\n \n-  int size;\n   CHECK(args[0]->IsUint32());\n   uint32_t val = args[0].As<Uint32>()->Value();\n   point_conversion_form_t form = static_cast<point_conversion_form_t>(val);\n \n-  size = EC_POINT_point2oct(ecdh->group_, pub, form, nullptr, 0, nullptr);\n-  if (size == 0)\n-    return env->ThrowError(\"Failed to get public key length\");\n-\n-  unsigned char* out = node::Malloc<unsigned char>(size);\n-\n-  int r = EC_POINT_point2oct(ecdh->group_, pub, form, out, size, nullptr);\n-  if (r != size) {\n-    free(out);\n-    return env->ThrowError(\"Failed to get public key\");\n-  }\n-\n-  Local<Object> buf =\n-      Buffer::New(env, reinterpret_cast<char*>(out), size).ToLocalChecked();\n-  args.GetReturnValue().Set(buf);\n+  MaybeLocal<Object> buf =\n+      ECPointToBuffer(env, EC_KEY_get0_group(ecdh->key_.get()), pub, form);\n+  if (buf.IsEmpty()) return;\n+  args.GetReturnValue().Set(buf.ToLocalChecked());\n }\n \n \n@@ -6172,23 +6174,9 @@ void ConvertKey(const FunctionCallbackInfo<Value>& args) {\n   uint32_t val = args[2].As<Uint32>()->Value();\n   point_conversion_form_t form = static_cast<point_conversion_form_t>(val);\n \n-  int size = EC_POINT_point2oct(\n-      group.get(), pub.get(), form, nullptr, 0, nullptr);\n-\n-  if (size == 0)\n-    return env->ThrowError(\"Failed to get public key length\");\n-\n-  unsigned char* out = node::Malloc<unsigned char>(size);\n-\n-  int r = EC_POINT_point2oct(group.get(), pub.get(), form, out, size, nullptr);\n-  if (r != size) {\n-    free(out);\n-    return env->ThrowError(\"Failed to get public key\");\n-  }\n-\n-  Local<Object> buf =\n-      Buffer::New(env, reinterpret_cast<char*>(out), size).ToLocalChecked();\n-  args.GetReturnValue().Set(buf);\n+  MaybeLocal<Object> buf = ECPointToBuffer(env, group.get(), pub.get(), form);\n+  if (buf.IsEmpty()) return;\n+  args.GetReturnValue().Set(buf.ToLocalChecked());\n }\n \n "
        }
    ],
    "stats": {
        "total": 72,
        "additions": 30,
        "deletions": 42
    }
}