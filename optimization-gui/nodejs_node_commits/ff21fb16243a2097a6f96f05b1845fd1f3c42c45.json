{
    "author": "danbev",
    "message": "crypto: use non-deprecated v8::Object::Set\n\nThis commit updates node_crypto to use the non-deprecated Set functions\nthat return a v8::Maybe<bool>.\n\nPR-URL: https://github.com/nodejs/node/pull/17482\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "ff21fb16243a2097a6f96f05b1845fd1f3c42c45",
    "files": [
        {
            "sha": "1f185dd715802c792ee75f01eea9aa664a3d4932",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 86,
            "deletions": 55,
            "changes": 141,
            "blob_url": "https://github.com/nodejs/node/blob/ff21fb16243a2097a6f96f05b1845fd1f3c42c45/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ff21fb16243a2097a6f96f05b1845fd1f3c42c45/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=ff21fb16243a2097a6f96f05b1845fd1f3c42c45",
            "patch": "@@ -1724,26 +1724,31 @@ void SSLWrap<Base>::OnClientHello(void* arg,\n   Base* w = static_cast<Base*>(arg);\n   Environment* env = w->ssl_env();\n   HandleScope handle_scope(env->isolate());\n-  Context::Scope context_scope(env->context());\n+  Local<Context> context = env->context();\n+  Context::Scope context_scope(context);\n \n   Local<Object> hello_obj = Object::New(env->isolate());\n   Local<Object> buff = Buffer::Copy(\n       env,\n       reinterpret_cast<const char*>(hello.session_id()),\n       hello.session_size()).ToLocalChecked();\n-  hello_obj->Set(env->session_id_string(), buff);\n+  hello_obj->Set(context, env->session_id_string(), buff).FromJust();\n   if (hello.servername() == nullptr) {\n-    hello_obj->Set(env->servername_string(), String::Empty(env->isolate()));\n+    hello_obj->Set(context,\n+                   env->servername_string(),\n+                   String::Empty(env->isolate())).FromJust();\n   } else {\n     Local<String> servername = OneByteString(env->isolate(),\n                                              hello.servername(),\n                                              hello.servername_size());\n-    hello_obj->Set(env->servername_string(), servername);\n+    hello_obj->Set(context, env->servername_string(), servername).FromJust();\n   }\n-  hello_obj->Set(env->tls_ticket_string(),\n-                 Boolean::New(env->isolate(), hello.has_ticket()));\n-  hello_obj->Set(env->ocsp_request_string(),\n-                 Boolean::New(env->isolate(), hello.ocsp_request()));\n+  hello_obj->Set(context,\n+                 env->tls_ticket_string(),\n+                 Boolean::New(env->isolate(), hello.has_ticket())).FromJust();\n+  hello_obj->Set(context,\n+                 env->ocsp_request_string(),\n+                 Boolean::New(env->isolate(), hello.ocsp_request())).FromJust();\n \n   Local<Value> argv[] = { hello_obj };\n   w->MakeCallback(env->onclienthello_string(), arraysize(argv), argv);\n@@ -1788,7 +1793,7 @@ static bool SafeX509ExtPrint(BIO* out, X509_EXTENSION* ext) {\n \n static Local<Object> X509ToObject(Environment* env, X509* cert) {\n   EscapableHandleScope scope(env->isolate());\n-\n+  Local<Context> context = env->context();\n   Local<Object> info = Object::New(env->isolate());\n \n   BIO* bio = BIO_new(BIO_s_mem());\n@@ -1798,18 +1803,20 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n                          0,\n                          X509_NAME_FLAGS) > 0) {\n     BIO_get_mem_ptr(bio, &mem);\n-    info->Set(env->subject_string(),\n+    info->Set(context, env->subject_string(),\n               String::NewFromUtf8(env->isolate(), mem->data,\n-                                  String::kNormalString, mem->length));\n+                                  String::kNormalString,\n+                                  mem->length)).FromJust();\n   }\n   USE(BIO_reset(bio));\n \n   X509_NAME* issuer_name = X509_get_issuer_name(cert);\n   if (X509_NAME_print_ex(bio, issuer_name, 0, X509_NAME_FLAGS) > 0) {\n     BIO_get_mem_ptr(bio, &mem);\n-    info->Set(env->issuer_string(),\n+    info->Set(context, env->issuer_string(),\n               String::NewFromUtf8(env->isolate(), mem->data,\n-                                  String::kNormalString, mem->length));\n+                                  String::kNormalString,\n+                                  mem->length)).FromJust();\n   }\n   USE(BIO_reset(bio));\n \n@@ -1834,9 +1841,10 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n     }\n \n     BIO_get_mem_ptr(bio, &mem);\n-    info->Set(keys[i],\n+    info->Set(context, keys[i],\n               String::NewFromUtf8(env->isolate(), mem->data,\n-                                  String::kNormalString, mem->length));\n+                                  String::kNormalString,\n+                                  mem->length)).FromJust();\n \n     USE(BIO_reset(bio));\n   }\n@@ -1852,9 +1860,10 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n     RSA_get0_key(rsa, &n, &e, nullptr);\n     BN_print(bio, n);\n     BIO_get_mem_ptr(bio, &mem);\n-    info->Set(env->modulus_string(),\n+    info->Set(context, env->modulus_string(),\n               String::NewFromUtf8(env->isolate(), mem->data,\n-                                  String::kNormalString, mem->length));\n+                                  String::kNormalString,\n+                                  mem->length)).FromJust();\n     USE(BIO_reset(bio));\n \n     uint64_t exponent_word = static_cast<uint64_t>(BN_get_word(e));\n@@ -1866,9 +1875,10 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n       BIO_printf(bio, \"0x%x%08x\", hi, lo);\n     }\n     BIO_get_mem_ptr(bio, &mem);\n-    info->Set(env->exponent_string(),\n+    info->Set(context, env->exponent_string(),\n               String::NewFromUtf8(env->isolate(), mem->data,\n-                                  String::kNormalString, mem->length));\n+                                  String::kNormalString,\n+                                  mem->length)).FromJust();\n     USE(BIO_reset(bio));\n   }\n \n@@ -1883,16 +1893,18 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n \n   ASN1_TIME_print(bio, X509_get_notBefore(cert));\n   BIO_get_mem_ptr(bio, &mem);\n-  info->Set(env->valid_from_string(),\n+  info->Set(context, env->valid_from_string(),\n             String::NewFromUtf8(env->isolate(), mem->data,\n-                                String::kNormalString, mem->length));\n+                                String::kNormalString,\n+                                mem->length)).FromJust();\n   USE(BIO_reset(bio));\n \n   ASN1_TIME_print(bio, X509_get_notAfter(cert));\n   BIO_get_mem_ptr(bio, &mem);\n-  info->Set(env->valid_to_string(),\n+  info->Set(context, env->valid_to_string(),\n             String::NewFromUtf8(env->isolate(), mem->data,\n-                                String::kNormalString, mem->length));\n+                                String::kNormalString,\n+                                mem->length)).FromJust();\n   BIO_free_all(bio);\n \n   unsigned int md_size, i;\n@@ -1913,8 +1925,8 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n       fingerprint[0] = '\\0';\n     }\n \n-    info->Set(env->fingerprint_string(),\n-              OneByteString(env->isolate(), fingerprint));\n+    info->Set(context, env->fingerprint_string(),\n+              OneByteString(env->isolate(), fingerprint)).FromJust();\n   }\n \n   STACK_OF(ASN1_OBJECT)* eku = static_cast<STACK_OF(ASN1_OBJECT)*>(\n@@ -1926,18 +1938,20 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n     int j = 0;\n     for (int i = 0; i < sk_ASN1_OBJECT_num(eku); i++) {\n       if (OBJ_obj2txt(buf, sizeof(buf), sk_ASN1_OBJECT_value(eku, i), 1) >= 0)\n-        ext_key_usage->Set(j++, OneByteString(env->isolate(), buf));\n+        ext_key_usage->Set(context,\n+                           j++,\n+                           OneByteString(env->isolate(), buf)).FromJust();\n     }\n \n     sk_ASN1_OBJECT_pop_free(eku, ASN1_OBJECT_free);\n-    info->Set(env->ext_key_usage_string(), ext_key_usage);\n+    info->Set(context, env->ext_key_usage_string(), ext_key_usage).FromJust();\n   }\n \n   if (ASN1_INTEGER* serial_number = X509_get_serialNumber(cert)) {\n     if (BIGNUM* bn = ASN1_INTEGER_to_BN(serial_number, nullptr)) {\n       if (char* buf = BN_bn2hex(bn)) {\n-        info->Set(env->serial_number_string(),\n-                  OneByteString(env->isolate(), buf));\n+        info->Set(context, env->serial_number_string(),\n+                  OneByteString(env->isolate(), buf)).FromJust();\n         OPENSSL_free(buf);\n       }\n       BN_free(bn);\n@@ -1950,7 +1964,7 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n   unsigned char* serialized = reinterpret_cast<unsigned char*>(\n       Buffer::Data(buff));\n   i2d_X509(cert, &serialized);\n-  info->Set(env->raw_string(), buff);\n+  info->Set(context, env->raw_string(), buff).FromJust();\n \n   return scope.Escape(info);\n }\n@@ -1963,6 +1977,7 @@ void SSLWrap<Base>::GetPeerCertificate(\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n   Environment* env = w->ssl_env();\n+  Local<Context> context = env->context();\n \n   ClearErrorOnReturn clear_error_on_return;\n \n@@ -2014,7 +2029,7 @@ void SSLWrap<Base>::GetPeerCertificate(\n         continue;\n \n       Local<Object> ca_info = X509ToObject(env, ca);\n-      info->Set(env->issuercert_string(), ca_info);\n+      info->Set(context, env->issuercert_string(), ca_info).FromJust();\n       info = ca_info;\n \n       // NOTE: Intentionally freeing cert that is not used anymore\n@@ -2037,7 +2052,7 @@ void SSLWrap<Base>::GetPeerCertificate(\n       break;\n \n     Local<Object> ca_info = X509ToObject(env, ca);\n-    info->Set(env->issuercert_string(), ca_info);\n+    info->Set(context, env->issuercert_string(), ca_info).FromJust();\n     info = ca_info;\n \n     // NOTE: Intentionally freeing cert that is not used anymore\n@@ -2049,7 +2064,7 @@ void SSLWrap<Base>::GetPeerCertificate(\n \n   // Self-issued certificate\n   if (X509_check_issued(cert, cert) == X509_V_OK)\n-    info->Set(env->issuercert_string(), info);\n+    info->Set(context, env->issuercert_string(), info).FromJust();\n \n   CHECK_NE(cert, nullptr);\n \n@@ -2245,6 +2260,7 @@ void SSLWrap<Base>::GetEphemeralKeyInfo(\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n   Environment* env = Environment::GetCurrent(args);\n+  Local<Context> context = env->context();\n \n   CHECK_NE(w->ssl_, nullptr);\n \n@@ -2259,22 +2275,24 @@ void SSLWrap<Base>::GetEphemeralKeyInfo(\n   if (SSL_get_server_tmp_key(w->ssl_, &key)) {\n     switch (EVP_PKEY_id(key)) {\n       case EVP_PKEY_DH:\n-        info->Set(env->type_string(),\n-                  FIXED_ONE_BYTE_STRING(env->isolate(), \"DH\"));\n-        info->Set(env->size_string(),\n-                  Integer::New(env->isolate(), EVP_PKEY_bits(key)));\n+        info->Set(context, env->type_string(),\n+                  FIXED_ONE_BYTE_STRING(env->isolate(), \"DH\")).FromJust();\n+        info->Set(context, env->size_string(),\n+                  Integer::New(env->isolate(), EVP_PKEY_bits(key))).FromJust();\n         break;\n       case EVP_PKEY_EC:\n         {\n           EC_KEY* ec = EVP_PKEY_get1_EC_KEY(key);\n           int nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));\n           EC_KEY_free(ec);\n-          info->Set(env->type_string(),\n-                    FIXED_ONE_BYTE_STRING(env->isolate(), \"ECDH\"));\n-          info->Set(env->name_string(),\n-                    OneByteString(args.GetIsolate(), OBJ_nid2sn(nid)));\n-          info->Set(env->size_string(),\n-                    Integer::New(env->isolate(), EVP_PKEY_bits(key)));\n+          info->Set(context, env->type_string(),\n+                    FIXED_ONE_BYTE_STRING(env->isolate(), \"ECDH\")).FromJust();\n+          info->Set(context, env->name_string(),\n+                    OneByteString(args.GetIsolate(),\n+                                  OBJ_nid2sn(nid))).FromJust();\n+          info->Set(context, env->size_string(),\n+                    Integer::New(env->isolate(),\n+                                 EVP_PKEY_bits(key))).FromJust();\n         }\n     }\n     EVP_PKEY_free(key);\n@@ -2367,7 +2385,8 @@ void SSLWrap<Base>::VerifyError(const FunctionCallbackInfo<Value>& args) {\n   Local<String> reason_string = OneByteString(isolate, reason);\n   Local<Value> exception_value = Exception::Error(reason_string);\n   Local<Object> exception_object = exception_value->ToObject(isolate);\n-  exception_object->Set(w->env()->code_string(), OneByteString(isolate, code));\n+  exception_object->Set(w->env()->context(), w->env()->code_string(),\n+                        OneByteString(isolate, code)).FromJust();\n   args.GetReturnValue().Set(exception_object);\n }\n \n@@ -2377,16 +2396,18 @@ void SSLWrap<Base>::GetCurrentCipher(const FunctionCallbackInfo<Value>& args) {\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n   Environment* env = w->ssl_env();\n+  Local<Context> context = env->context();\n \n   const SSL_CIPHER* c = SSL_get_current_cipher(w->ssl_);\n   if (c == nullptr)\n     return;\n \n   Local<Object> info = Object::New(env->isolate());\n   const char* cipher_name = SSL_CIPHER_get_name(c);\n-  info->Set(env->name_string(), OneByteString(args.GetIsolate(), cipher_name));\n-  info->Set(env->version_string(),\n-            OneByteString(args.GetIsolate(), \"TLSv1/SSLv3\"));\n+  info->Set(context, env->name_string(),\n+            OneByteString(args.GetIsolate(), cipher_name)).FromJust();\n+  info->Set(context, env->version_string(),\n+            OneByteString(args.GetIsolate(), \"TLSv1/SSLv3\")).FromJust();\n   args.GetReturnValue().Set(info);\n }\n \n@@ -2695,27 +2716,31 @@ int SSLWrap<Base>::SSLCertCallback(SSL* s, void* arg) {\n     return -1;\n \n   Environment* env = w->env();\n+  Local<Context> context = env->context();\n   HandleScope handle_scope(env->isolate());\n-  Context::Scope context_scope(env->context());\n+  Context::Scope context_scope(context);\n   w->cert_cb_running_ = true;\n \n   Local<Object> info = Object::New(env->isolate());\n \n   const char* servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);\n   if (servername == nullptr) {\n-    info->Set(env->servername_string(), String::Empty(env->isolate()));\n+    info->Set(context,\n+              env->servername_string(),\n+              String::Empty(env->isolate())).FromJust();\n   } else {\n     Local<String> str = OneByteString(env->isolate(), servername,\n                                       strlen(servername));\n-    info->Set(env->servername_string(), str);\n+    info->Set(context, env->servername_string(), str).FromJust();\n   }\n \n   bool ocsp = false;\n #ifdef NODE__HAVE_TLSEXT_STATUS_CB\n   ocsp = SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp;\n #endif\n \n-  info->Set(env->ocsp_request_string(), Boolean::New(env->isolate(), ocsp));\n+  info->Set(context, env->ocsp_request_string(),\n+            Boolean::New(env->isolate(), ocsp)).FromJust();\n \n   Local<Value> argv[] = { info };\n   w->MakeCallback(env->oncertcb_string(), arraysize(argv), argv);\n@@ -4997,7 +5022,7 @@ void PBKDF2(const FunctionCallbackInfo<Value>& args) {\n                         keylen));\n \n   if (args[5]->IsFunction()) {\n-    obj->Set(env->ondone_string(), args[5]);\n+    obj->Set(env->context(), env->ondone_string(), args[5]).FromJust();\n \n     uv_queue_work(env->event_loop(),\n                   req.release()->work_req(),\n@@ -5185,7 +5210,7 @@ void RandomBytes(const FunctionCallbackInfo<Value>& args) {\n                              RandomBytesRequest::FREE_DATA));\n \n   if (args[1]->IsFunction()) {\n-    obj->Set(env->ondone_string(), args[1]);\n+    obj->Set(env->context(), env->ondone_string(), args[1]).FromJust();\n \n     uv_queue_work(env->event_loop(),\n                   req.release()->work_req(),\n@@ -5254,7 +5279,10 @@ void GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {\n \n   for (int i = 0; i < sk_SSL_CIPHER_num(ciphers); ++i) {\n     const SSL_CIPHER* cipher = sk_SSL_CIPHER_value(ciphers, i);\n-    arr->Set(i, OneByteString(args.GetIsolate(), SSL_CIPHER_get_name(cipher)));\n+    arr->Set(env->context(),\n+             i,\n+             OneByteString(args.GetIsolate(),\n+                           SSL_CIPHER_get_name(cipher))).FromJust();\n   }\n \n   SSL_free(ssl);\n@@ -5317,7 +5345,10 @@ void GetCurves(const FunctionCallbackInfo<Value>& args) {\n \n     if (EC_get_builtin_curves(curves, num_curves)) {\n       for (size_t i = 0; i < num_curves; i++) {\n-        arr->Set(i, OneByteString(env->isolate(), OBJ_nid2sn(curves[i].nid)));\n+        arr->Set(env->context(),\n+                 i,\n+                 OneByteString(env->isolate(),\n+                               OBJ_nid2sn(curves[i].nid))).FromJust();\n       }\n     }\n "
        }
    ],
    "stats": {
        "total": 141,
        "additions": 86,
        "deletions": 55
    }
}