{
    "author": "tniessen",
    "message": "crypto: deduplicate public key parsing\n\nPR-URL: https://github.com/nodejs/node/pull/22553\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "83f319cb3b4a422a5e8def1f7489a97de68267c1",
    "files": [
        {
            "sha": "4a81918e9451c98e29977956b927cf7bce68f68a",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 51,
            "deletions": 54,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/83f319cb3b4a422a5e8def1f7489a97de68267c1/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/83f319cb3b4a422a5e8def1f7489a97de68267c1/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=83f319cb3b4a422a5e8def1f7489a97de68267c1",
            "patch": "@@ -3648,6 +3648,45 @@ void Sign::SignFinal(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(rc);\n }\n \n+enum ParsePublicKeyResult {\n+  kParsePublicOk,\n+  kParsePublicNotRecognized,\n+  kParsePublicFailed\n+};\n+\n+static ParsePublicKeyResult ParsePublicKey(EVPKeyPointer* pkey,\n+                                           const char* key_pem,\n+                                           int key_pem_len) {\n+  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n+  if (!bp)\n+    return kParsePublicFailed;\n+\n+  // Check if this is a PKCS#8 or RSA public key before trying as X.509.\n+  if (strncmp(key_pem, PUBLIC_KEY_PFX, PUBLIC_KEY_PFX_LEN) == 0) {\n+    pkey->reset(\n+        PEM_read_bio_PUBKEY(bp.get(), nullptr, NoPasswordCallback, nullptr));\n+  } else if (strncmp(key_pem, PUBRSA_KEY_PFX, PUBRSA_KEY_PFX_LEN) == 0) {\n+    RSAPointer rsa(PEM_read_bio_RSAPublicKey(\n+        bp.get(), nullptr, PasswordCallback, nullptr));\n+    if (rsa) {\n+      pkey->reset(EVP_PKEY_new());\n+      if (*pkey)\n+        EVP_PKEY_set1_RSA(pkey->get(), rsa.get());\n+    }\n+  } else if (strncmp(key_pem, CERTIFICATE_PFX, CERTIFICATE_PFX_LEN) == 0) {\n+    // X.509 fallback\n+    X509Pointer x509(PEM_read_bio_X509(\n+        bp.get(), nullptr, NoPasswordCallback, nullptr));\n+    if (!x509)\n+      return kParsePublicFailed;\n+\n+    pkey->reset(X509_get_pubkey(x509.get()));\n+  } else {\n+    return kParsePublicNotRecognized;\n+  }\n+\n+  return *pkey ? kParsePublicOk : kParsePublicFailed;\n+}\n \n void Verify::Initialize(Environment* env, v8::Local<Object> target) {\n   Local<FunctionTemplate> t = env->NewFunctionTemplate(New);\n@@ -3708,34 +3747,7 @@ SignBase::Error Verify::VerifyFinal(const char* key_pem,\n   *verify_result = false;\n   EVPMDPointer mdctx = std::move(mdctx_);\n \n-  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n-  if (!bp)\n-    return kSignPublicKey;\n-\n-  // Check if this is a PKCS#8 or RSA public key before trying as X.509.\n-  // Split this out into a separate function once we have more than one\n-  // consumer of public keys.\n-  if (strncmp(key_pem, PUBLIC_KEY_PFX, PUBLIC_KEY_PFX_LEN) == 0) {\n-    pkey.reset(\n-        PEM_read_bio_PUBKEY(bp.get(), nullptr, NoPasswordCallback, nullptr));\n-  } else if (strncmp(key_pem, PUBRSA_KEY_PFX, PUBRSA_KEY_PFX_LEN) == 0) {\n-    RSAPointer rsa(PEM_read_bio_RSAPublicKey(\n-        bp.get(), nullptr, PasswordCallback, nullptr));\n-    if (rsa) {\n-      pkey.reset(EVP_PKEY_new());\n-      if (pkey)\n-        EVP_PKEY_set1_RSA(pkey.get(), rsa.get());\n-    }\n-  } else {\n-    // X.509 fallback\n-    X509Pointer x509(PEM_read_bio_X509(\n-        bp.get(), nullptr, NoPasswordCallback, nullptr));\n-    if (!x509)\n-      return kSignPublicKey;\n-\n-    pkey.reset(X509_get_pubkey(x509.get()));\n-  }\n-  if (!pkey)\n+  if (ParsePublicKey(&pkey, key_pem, key_pem_len) != kParsePublicOk)\n     return kSignPublicKey;\n \n   if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))\n@@ -3805,40 +3817,25 @@ bool PublicKeyCipher::Cipher(const char* key_pem,\n                              size_t* out_len) {\n   EVPKeyPointer pkey;\n \n-  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n-  if (!bp)\n-    return false;\n-\n   // Check if this is a PKCS#8 or RSA public key before trying as X.509 and\n   // private key.\n-  if (operation == kPublic &&\n-      strncmp(key_pem, PUBLIC_KEY_PFX, PUBLIC_KEY_PFX_LEN) == 0) {\n-    pkey.reset(PEM_read_bio_PUBKEY(bp.get(), nullptr, nullptr, nullptr));\n-  } else if (operation == kPublic &&\n-             strncmp(key_pem, PUBRSA_KEY_PFX, PUBRSA_KEY_PFX_LEN) == 0) {\n-    RSAPointer rsa(\n-        PEM_read_bio_RSAPublicKey(bp.get(), nullptr, nullptr, nullptr));\n-    if (rsa) {\n-      pkey.reset(EVP_PKEY_new());\n-      if (pkey)\n-        EVP_PKEY_set1_RSA(pkey.get(), rsa.get());\n-    }\n-  } else if (operation == kPublic &&\n-             strncmp(key_pem, CERTIFICATE_PFX, CERTIFICATE_PFX_LEN) == 0) {\n-    X509Pointer x509(\n-        PEM_read_bio_X509(bp.get(), nullptr, NoPasswordCallback, nullptr));\n-    if (!x509)\n+  if (operation == kPublic) {\n+    ParsePublicKeyResult pkeyres = ParsePublicKey(&pkey, key_pem, key_pem_len);\n+    if (pkeyres == kParsePublicFailed)\n+      return false;\n+  }\n+  if (!pkey) {\n+    // Private key fallback.\n+    BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n+    if (!bp)\n       return false;\n-\n-    pkey.reset(X509_get_pubkey(x509.get()));\n-  } else {\n     pkey.reset(PEM_read_bio_PrivateKey(bp.get(),\n                                        nullptr,\n                                        PasswordCallback,\n                                        const_cast<char*>(passphrase)));\n+    if (!pkey)\n+      return false;\n   }\n-  if (!pkey)\n-    return false;\n \n   EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));\n   if (!ctx)"
        }
    ],
    "stats": {
        "total": 105,
        "additions": 51,
        "deletions": 54
    }
}