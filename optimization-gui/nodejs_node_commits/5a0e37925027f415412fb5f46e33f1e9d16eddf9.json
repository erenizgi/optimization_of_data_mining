{
    "author": "BridgeAR",
    "message": "errors: move functions to error code\n\nThis makes sure the functions are actually directly beneath the\nspecification of an error code.\nThat way it is not necessary to jump around when looking at the\nfunctionality.\n\nPR-URL: https://github.com/nodejs/node/pull/20486\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>",
    "sha": "5a0e37925027f415412fb5f46e33f1e9d16eddf9",
    "files": [
        {
            "sha": "89c0139f8b6fdef1839d33bd6df93d81bbcfb6ce",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 92,
            "deletions": 97,
            "changes": 189,
            "blob_url": "https://github.com/nodejs/node/blob/5a0e37925027f415412fb5f46e33f1e9d16eddf9/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/5a0e37925027f415412fb5f46e33f1e9d16eddf9/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=5a0e37925027f415412fb5f46e33f1e9d16eddf9",
            "patch": "@@ -407,6 +407,26 @@ function isStackOverflowError(err) {\n          err.message === maxStack_ErrorMessage;\n }\n \n+function oneOf(expected, thing) {\n+  assert(typeof thing === 'string', '`thing` has to be of type string');\n+  if (Array.isArray(expected)) {\n+    const len = expected.length;\n+    assert(len > 0,\n+           'At least one expected value needs to be specified');\n+    expected = expected.map((i) => String(i));\n+    if (len > 2) {\n+      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +\n+             expected[len - 1];\n+    } else if (len === 2) {\n+      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n+    } else {\n+      return `of ${thing} ${expected[0]}`;\n+    }\n+  } else {\n+    return `of ${thing} ${String(expected)}`;\n+  }\n+}\n+\n module.exports = {\n   dnsException,\n   errnoException,\n@@ -441,7 +461,15 @@ E('ERR_ARG_NOT_ITERABLE', '%s must be iterable', TypeError);\n E('ERR_ASSERTION', '%s', Error);\n E('ERR_ASYNC_CALLBACK', '%s must be a function', TypeError);\n E('ERR_ASYNC_TYPE', 'Invalid name for async \"type\": %s', TypeError);\n-E('ERR_BUFFER_OUT_OF_BOUNDS', bufferOutOfBounds, RangeError);\n+E('ERR_BUFFER_OUT_OF_BOUNDS',\n+  // Using a default argument here is important so the argument is not counted\n+  // towards `Function#length`.\n+  (name = undefined) => {\n+    if (name) {\n+      return `\"${name}\" is outside of buffer bounds`;\n+    }\n+    return 'Attempt to write outside buffer bounds';\n+  }, RangeError);\n E('ERR_BUFFER_TOO_LARGE',\n   `Cannot create a Buffer larger than 0x${kMaxLength.toString(16)} bytes`,\n   RangeError);\n@@ -579,7 +607,32 @@ E('ERR_INSPECTOR_CLOSED', 'Session was closed', Error);\n E('ERR_INSPECTOR_NOT_AVAILABLE', 'Inspector is not available', Error);\n E('ERR_INSPECTOR_NOT_CONNECTED', 'Session is not connected', Error);\n E('ERR_INVALID_ADDRESS_FAMILY', 'Invalid address family: %s', RangeError);\n-E('ERR_INVALID_ARG_TYPE', invalidArgType, TypeError);\n+E('ERR_INVALID_ARG_TYPE',\n+  (name, expected, actual) => {\n+    assert(typeof name === 'string', \"'name' must be a string\");\n+\n+    // determiner: 'must be' or 'must not be'\n+    let determiner;\n+    if (typeof expected === 'string' && expected.startsWith('not ')) {\n+      determiner = 'must not be';\n+      expected = expected.replace(/^not /, '');\n+    } else {\n+      determiner = 'must be';\n+    }\n+\n+    let msg;\n+    if (name.endsWith(' argument')) {\n+      // For cases like 'first argument'\n+      msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n+    } else {\n+      const type = name.includes('.') ? 'property' : 'argument';\n+      msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n+    }\n+\n+    // TODO(BridgeAR): Improve the output by showing `null` and similar.\n+    msg += `. Received type ${typeof actual}`;\n+    return msg;\n+  }, TypeError);\n E('ERR_INVALID_ARG_VALUE', (name, value, reason = 'is invalid') => {\n   let inspected = util.inspect(value);\n   if (inspected.length > 128) {\n@@ -591,7 +644,16 @@ E('ERR_INVALID_ASYNC_ID', 'Invalid %s value: %s', RangeError);\n E('ERR_INVALID_BUFFER_SIZE',\n   'Buffer size must be a multiple of %s', RangeError);\n E('ERR_INVALID_CALLBACK', 'Callback must be a function', TypeError);\n-E('ERR_INVALID_CHAR', invalidChar, TypeError);\n+E('ERR_INVALID_CHAR',\n+  // Using a default argument here is important so the argument is not counted\n+  // towards `Function#length`.\n+  (name, field = undefined) => {\n+    let msg = `Invalid character in ${name}`;\n+    if (field !== undefined) {\n+      msg += ` [\"${field}\"]`;\n+    }\n+    return msg;\n+  }, TypeError);\n E('ERR_INVALID_CURSOR_POS',\n   'Cannot set cursor row without setting its column', TypeError);\n E('ERR_INVALID_FD',\n@@ -640,7 +702,26 @@ E('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected', Error);\n E('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe', Error);\n E('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks', Error);\n E('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error);\n-E('ERR_MISSING_ARGS', missingArgs, TypeError);\n+E('ERR_MISSING_ARGS',\n+  (...args) => {\n+    assert(args.length > 0, 'At least one arg needs to be specified');\n+    let msg = 'The ';\n+    const len = args.length;\n+    args = args.map((a) => `\"${a}\"`);\n+    switch (len) {\n+      case 1:\n+        msg += `${args[0]} argument`;\n+        break;\n+      case 2:\n+        msg += `${args[0]} and ${args[1]} arguments`;\n+        break;\n+      default:\n+        msg += args.slice(0, len - 1).join(', ');\n+        msg += `, and ${args[len - 1]} arguments`;\n+        break;\n+    }\n+    return `${msg} must be specified`;\n+  }, TypeError);\n E('ERR_MISSING_MODULE', 'Cannot find module %s', Error);\n E('ERR_MODULE_RESOLUTION_LEGACY',\n   '%s not found by import in %s.' +\n@@ -661,7 +742,13 @@ E('ERR_NO_CRYPTO',\n E('ERR_NO_ICU',\n   '%s is not supported on Node.js compiled without ICU', TypeError);\n E('ERR_NO_LONGER_SUPPORTED', '%s is no longer supported', Error);\n-E('ERR_OUT_OF_RANGE', outOfRange, RangeError);\n+E('ERR_OUT_OF_RANGE',\n+  (name, range, value) => {\n+    let msg = `The value of \"${name}\" is out of range.`;\n+    if (range !== undefined) msg += ` It must be ${range}.`;\n+    msg += ` Received ${value}`;\n+    return msg;\n+  }, RangeError);\n E('ERR_REQUIRE_ESM', 'Must use import to load ES Module: %s', Error);\n E('ERR_SCRIPT_EXECUTION_INTERRUPTED',\n   'Script execution was interrupted by `SIGINT`', Error);\n@@ -758,95 +845,3 @@ E('ERR_VM_MODULE_NOT_MODULE',\n   'Provided module is not an instance of Module', Error);\n E('ERR_VM_MODULE_STATUS', 'Module status %s', Error);\n E('ERR_ZLIB_INITIALIZATION_FAILED', 'Initialization failed', Error);\n-\n-function invalidArgType(name, expected, actual) {\n-  assert(typeof name === 'string', \"'name' must be a string\");\n-\n-  // determiner: 'must be' or 'must not be'\n-  let determiner;\n-  if (typeof expected === 'string' && expected.startsWith('not ')) {\n-    determiner = 'must not be';\n-    expected = expected.replace(/^not /, '');\n-  } else {\n-    determiner = 'must be';\n-  }\n-\n-  let msg;\n-  if (name.endsWith(' argument')) {\n-    // For cases like 'first argument'\n-    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n-  } else {\n-    const type = name.includes('.') ? 'property' : 'argument';\n-    msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n-  }\n-\n-  // TODO(BridgeAR): Improve the output by showing `null` and similar.\n-  msg += `. Received type ${typeof actual}`;\n-  return msg;\n-}\n-\n-function missingArgs(...args) {\n-  assert(args.length > 0, 'At least one arg needs to be specified');\n-  let msg = 'The ';\n-  const len = args.length;\n-  args = args.map((a) => `\"${a}\"`);\n-  switch (len) {\n-    case 1:\n-      msg += `${args[0]} argument`;\n-      break;\n-    case 2:\n-      msg += `${args[0]} and ${args[1]} arguments`;\n-      break;\n-    default:\n-      msg += args.slice(0, len - 1).join(', ');\n-      msg += `, and ${args[len - 1]} arguments`;\n-      break;\n-  }\n-  return `${msg} must be specified`;\n-}\n-\n-function oneOf(expected, thing) {\n-  assert(typeof thing === 'string', '`thing` has to be of type string');\n-  if (Array.isArray(expected)) {\n-    const len = expected.length;\n-    assert(len > 0,\n-           'At least one expected value needs to be specified');\n-    expected = expected.map((i) => String(i));\n-    if (len > 2) {\n-      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +\n-             expected[len - 1];\n-    } else if (len === 2) {\n-      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n-    } else {\n-      return `of ${thing} ${expected[0]}`;\n-    }\n-  } else {\n-    return `of ${thing} ${String(expected)}`;\n-  }\n-}\n-\n-// Using a default argument here is important so the argument is not counted\n-// towards `Function#length`.\n-function bufferOutOfBounds(name = undefined) {\n-  if (name) {\n-    return `\"${name}\" is outside of buffer bounds`;\n-  }\n-  return 'Attempt to write outside buffer bounds';\n-}\n-\n-// Using a default argument here is important so the argument is not counted\n-// towards `Function#length`.\n-function invalidChar(name, field = undefined) {\n-  let msg = `Invalid character in ${name}`;\n-  if (field !== undefined) {\n-    msg += ` [\"${field}\"]`;\n-  }\n-  return msg;\n-}\n-\n-function outOfRange(name, range, value) {\n-  let msg = `The value of \"${name}\" is out of range.`;\n-  if (range !== undefined) msg += ` It must be ${range}.`;\n-  msg += ` Received ${value}`;\n-  return msg;\n-}"
        }
    ],
    "stats": {
        "total": 189,
        "additions": 92,
        "deletions": 97
    }
}