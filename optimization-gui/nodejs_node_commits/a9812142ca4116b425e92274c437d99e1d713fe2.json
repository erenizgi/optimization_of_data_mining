{
    "author": "BridgeAR",
    "message": "deps: patch V8 to 7.1.302.33\n\nPR-URL: https://github.com/nodejs/node/pull/25101\nRefs: https://github.com/v8/v8/compare/7.1.302.28...7.1.302.33\nFixes: https://github.com/nodejs/node/issues/25089\nReviewed-By: Richard Lau <riclau@uk.ibm.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>\nReviewed-By: Yang Guo <yangguo@chromium.org>",
    "sha": "a9812142ca4116b425e92274c437d99e1d713fe2",
    "files": [
        {
            "sha": "a87c01e49d0fe7dcaf0fc2c816c566d8b295e4bb",
            "filename": "deps/v8/DEPS",
            "status": "modified",
            "additions": 22,
            "deletions": 3,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2FDEPS",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2FDEPS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FDEPS?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -9,6 +9,9 @@ vars = {\n   'download_jsfunfuzz': False,\n   'download_mips_toolchain': False,\n   'check_v8_header_includes': False,\n+\n+  # luci-go CIPD package version.\n+  'luci_go': 'git_revision:fdf05508e8a66c773a41521e0243c9d11b9a2a1c',\n }\n \n deps = {\n@@ -51,7 +54,7 @@ deps = {\n   'v8/third_party/markupsafe':\n     Var('chromium_url') + '/chromium/src/third_party/markupsafe.git' + '@' + '8f45f5cfa0009d2a70589bcda0349b8cb2b72783',\n   'v8/tools/swarming_client':\n-    Var('chromium_url') + '/infra/luci/client-py.git' + '@' + '486c9b53c4d54dd4b95bb6ce0e31160e600dfc11',\n+    Var('chromium_url') + '/infra/luci/client-py.git' + '@' + '0e3e1c4dc4e79f25a5b58fcbc135dc93183c0c54',\n   'v8/test/benchmarks/data':\n     Var('chromium_url') + '/v8/deps/third_party/benchmarks.git' + '@' + '05d7188267b4560491ff9155c5ee13e207ecd65f',\n   'v8/test/mozilla/data':\n@@ -82,8 +85,24 @@ deps = {\n   },\n   'v8/tools/clang':\n     Var('chromium_url') + '/chromium/src/tools/clang.git' + '@' + '7792d28b069af6dd3a86d1ba83b7f5c4ede605dc',\n-  'v8/tools/luci-go':\n-    Var('chromium_url') + '/chromium/src/tools/luci-go.git' + '@' + '445d7c4b6a4f10e188edb395b132e3996b127691',\n+  'v8/tools/luci-go': {\n+      'packages': [\n+        {\n+          'package': 'infra/tools/luci/isolate/${{platform}}',\n+          'version': Var('luci_go'),\n+        },\n+        {\n+          'package': 'infra/tools/luci/isolated/${{platform}}',\n+          'version': Var('luci_go'),\n+        },\n+        {\n+          'package': 'infra/tools/luci/swarming/${{platform}}',\n+          'version': Var('luci_go'),\n+        },\n+      ],\n+      'condition': 'host_cpu != \"s390\"',\n+      'dep_type': 'cipd',\n+  },\n   'v8/test/wasm-js':\n     Var('chromium_url') + '/external/github.com/WebAssembly/spec.git' + '@' + 'db9cd40808a90ecc5f4a23e88fb375c8f60b8d52',\n }"
        },
        {
            "sha": "114e57c58eaf7dca502b3e0ea119097671a152bd",
            "filename": "deps/v8/include/v8-version.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Finclude%2Fv8-version.h",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Finclude%2Fv8-version.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8-version.h?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -11,7 +11,7 @@\n #define V8_MAJOR_VERSION 7\n #define V8_MINOR_VERSION 1\n #define V8_BUILD_NUMBER 302\n-#define V8_PATCH_LEVEL 28\n+#define V8_PATCH_LEVEL 33\n \n // Use 1 for candidates and 0 otherwise.\n // (Boolean macro values are not supported by all preprocessors.)"
        },
        {
            "sha": "5746f4cdf6714a10878f1dc0b89560cd0bbdc5e5",
            "filename": "deps/v8/src/builtins/array-splice.tq",
            "status": "modified",
            "additions": 62,
            "deletions": 41,
            "changes": 103,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray-splice.tq",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray-splice.tq",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray-splice.tq?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -9,8 +9,12 @@ module array {\n   // zero-length input FixedArray is handled here.\n   macro Extract<FixedArrayType: type>(\n       elements: FixedArrayBase, first: Smi, count: Smi,\n-      capacity: Smi): FixedArrayType {\n-    return UnsafeCast<FixedArrayType>(\n+      capacity: Smi): FixedArrayType;\n+\n+  Extract<FixedArray>(\n+      elements: FixedArrayBase, first: Smi, count: Smi,\n+      capacity: Smi): FixedArray {\n+    return UnsafeCast<FixedArray>(\n         ExtractFixedArray(elements, first, count, capacity));\n   }\n \n@@ -24,63 +28,80 @@ module array {\n         ExtractFixedArray(elements, first, count, capacity));\n   }\n \n+  macro DoMoveElements<FixedArrayType: type>(\n+      elements: FixedArrayType, dstIndex: Smi, srcIndex: Smi,\n+      count: Smi): void {\n+    TorqueMoveElements(\n+        elements, Convert<intptr>(dstIndex), Convert<intptr>(srcIndex),\n+        Convert<intptr>(count));\n+  }\n+\n+  macro StoreHoles<FixedArrayType: type>(\n+      elements: FixedArrayType, holeStartIndex: Smi, holeEndIndex: Smi): void {\n+    for (let i: Smi = holeStartIndex; i < holeEndIndex; i++) {\n+      StoreArrayHole(elements, i);\n+    }\n+  }\n+\n+  macro DoCopyElements<FixedArrayType: type>(\n+      dstElements: FixedArrayType, dstIndex: Smi, srcElements: FixedArrayType,\n+      srcIndex: Smi, count: Smi): void {\n+    TorqueCopyElements(\n+        dstElements, Convert<intptr>(dstIndex), srcElements,\n+        Convert<intptr>(srcIndex), Convert<intptr>(count));\n+  }\n+\n   macro FastSplice<FixedArrayType: type, ElementType: type>(\n       args: constexpr Arguments, a: JSArray, length: Smi, newLength: Smi,\n       lengthDelta: Smi, actualStart: Smi, insertCount: Smi,\n       actualDeleteCount: Smi): void\n       labels Bailout {\n-    const elements: FixedArrayBase = a.elements;\n-    const elementsMap: Map = elements.map;\n-\n-    // If the spliced array is larger then the\n-    // source array, then allocate a new FixedArrayType to hold the result.\n-    let newElements: FixedArrayBase = elements;\n-    if (elementsMap == kCOWMap || lengthDelta > 0) {\n-      newElements =\n-          Extract<FixedArrayType>(elements, 0, actualStart, newLength);\n-      if (elementsMap == kCOWMap) {\n-        newElements.map = elementsMap;\n+    // Make sure elements are writable.\n+    EnsureWriteableFastElements(a);\n+\n+    if (insertCount != actualDeleteCount) {\n+      const elements: FixedArrayBase = a.elements;\n+      const dstIndex: Smi = actualStart + insertCount;\n+      const srcIndex: Smi = actualStart + actualDeleteCount;\n+      const count: Smi = length - actualDeleteCount - actualStart;\n+      if (insertCount < actualDeleteCount) {\n+        // Shrink.\n+        DoMoveElements<FixedArrayType>(\n+            UnsafeCast<FixedArrayType>(elements), dstIndex, srcIndex, count);\n+        StoreHoles<FixedArrayType>(\n+            UnsafeCast<FixedArrayType>(elements), newLength, length);\n+      } else if (insertCount > actualDeleteCount) {\n+        // If the backing store is big enough, then moving elements is enough.\n+        if (newLength <= elements.length) {\n+          DoMoveElements<FixedArrayType>(\n+              UnsafeCast<FixedArrayType>(elements), dstIndex, srcIndex, count);\n+        } else {\n+          // Grow.\n+          let capacity: Smi = CalculateNewElementsCapacity(newLength);\n+          const newElements: FixedArrayType =\n+              Extract<FixedArrayType>(elements, 0, actualStart, capacity);\n+          a.elements = newElements;\n+          if (elements.length > 0) {\n+            DoCopyElements<FixedArrayType>(\n+                newElements, dstIndex, UnsafeCast<FixedArrayType>(elements),\n+                srcIndex, count);\n+          }\n+        }\n       }\n-      a.elements = newElements;\n     }\n \n-    // Copy over inserted elements.\n+    // Copy arguments.\n     let k: Smi = actualStart;\n     if (insertCount > 0) {\n       const typedNewElements: FixedArrayType =\n-          UnsafeCast<FixedArrayType>(newElements);\n+          UnsafeCast<FixedArrayType>(a.elements);\n       for (let e: Object of args [2: ]) {\n         // The argument elements were already validated to be an appropriate\n         // {ElementType} to store in {FixedArrayType}.\n         typedNewElements[k++] = UnsafeCast<ElementType>(e);\n       }\n     }\n \n-    // Copy over elements after deleted elements.\n-    let count: Smi = length - actualStart - actualDeleteCount;\n-    while (count > 0) {\n-      const typedElements: FixedArrayType =\n-          UnsafeCast<FixedArrayType>(elements);\n-      const typedNewElements: FixedArrayType =\n-          UnsafeCast<FixedArrayType>(newElements);\n-      CopyArrayElement(typedElements, typedNewElements, k - lengthDelta, k);\n-      k++;\n-      count--;\n-    }\n-\n-    // Fill rest of spliced FixedArray with the hole, but only if the\n-    // destination FixedArray is the original array's, since otherwise the array\n-    // is pre-filled with holes.\n-    if (elements == newElements) {\n-      const typedNewElements: FixedArrayType =\n-          UnsafeCast<FixedArrayType>(newElements);\n-      const limit: Smi = elements.length;\n-      while (k < limit) {\n-        StoreArrayHole(typedNewElements, k);\n-        k++;\n-      }\n-    }\n-\n     // Update the array's length after all the FixedArray shuffling is done.\n     a.length = newLength;\n   }"
        },
        {
            "sha": "3f5029834db820544b66f8c22dffa68fbef25dab",
            "filename": "deps/v8/src/builtins/base.tq",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbase.tq",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbase.tq",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbase.tq?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -844,6 +844,8 @@ macro AllowNonNumberElements(kind: ElementsKind): ElementsKind {\n extern macro AllocateZeroedFixedArray(intptr): FixedArray;\n extern macro AllocateZeroedFixedDoubleArray(intptr): FixedDoubleArray;\n \n+extern macro CalculateNewElementsCapacity(Smi): Smi;\n+\n extern macro CopyFixedArrayElements(\n     constexpr ElementsKind, FixedArray, constexpr ElementsKind, FixedArray,\n     intptr, intptr, intptr): void;\n@@ -879,6 +881,36 @@ extern macro ExtractFixedArray(\n \n extern builtin ExtractFastJSArray(Context, JSArray, Smi, Smi): JSArray;\n \n+extern macro MoveElements(\n+    constexpr ElementsKind, FixedArrayBase, intptr, intptr, intptr): void;\n+macro TorqueMoveElements(\n+    elements: FixedArray, dstIndex: intptr, srcIndex: intptr,\n+    count: intptr): void {\n+  MoveElements(HOLEY_ELEMENTS, elements, dstIndex, srcIndex, count);\n+}\n+macro TorqueMoveElements(\n+    elements: FixedDoubleArray, dstIndex: intptr, srcIndex: intptr,\n+    count: intptr): void {\n+  MoveElements(HOLEY_DOUBLE_ELEMENTS, elements, dstIndex, srcIndex, count);\n+}\n+\n+extern macro CopyElements(\n+    constexpr ElementsKind, FixedArrayBase, intptr, FixedArrayBase, intptr,\n+    intptr): void;\n+macro TorqueCopyElements(\n+    dstElements: FixedArray, dstIndex: intptr, srcElements: FixedArray,\n+    srcIndex: intptr, count: intptr): void {\n+  CopyElements(\n+      HOLEY_ELEMENTS, dstElements, dstIndex, srcElements, srcIndex, count);\n+}\n+macro TorqueCopyElements(\n+    dstElements: FixedDoubleArray, dstIndex: intptr,\n+    srcElements: FixedDoubleArray, srcIndex: intptr, count: intptr): void {\n+  CopyElements(\n+      HOLEY_DOUBLE_ELEMENTS, dstElements, dstIndex, srcElements, srcIndex,\n+      count);\n+}\n+\n macro LoadElementNoHole<T: type>(a: JSArray, index: Smi): Object\n     labels IfHole;\n "
        },
        {
            "sha": "1474e3d97de0189afa27e7d91aa07d1134206e0d",
            "filename": "deps/v8/src/code-stub-assembler.cc",
            "status": "modified",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -4543,6 +4543,179 @@ void CodeStubAssembler::FillFixedDoubleArrayWithZero(\n                  backing_store, IntPtrConstant(0), byte_length);\n }\n \n+void CodeStubAssembler::JumpIfPointersFromHereAreInteresting(\n+    TNode<Object> object, Label* interesting) {\n+  Label finished(this);\n+  TNode<IntPtrT> object_word = BitcastTaggedToWord(object);\n+  TNode<IntPtrT> object_page = PageFromAddress(object_word);\n+  TNode<IntPtrT> page_flags = UncheckedCast<IntPtrT>(Load(\n+      MachineType::IntPtr(), object_page, IntPtrConstant(Page::kFlagsOffset)));\n+  Branch(\n+      WordEqual(WordAnd(page_flags,\n+                        IntPtrConstant(\n+                            MemoryChunk::kPointersFromHereAreInterestingMask)),\n+                IntPtrConstant(0)),\n+      &finished, interesting);\n+  BIND(&finished);\n+}\n+\n+void CodeStubAssembler::MoveElements(ElementsKind kind,\n+                                     TNode<FixedArrayBase> elements,\n+                                     TNode<IntPtrT> dst_index,\n+                                     TNode<IntPtrT> src_index,\n+                                     TNode<IntPtrT> length) {\n+  Label finished(this);\n+  Label needs_barrier(this);\n+  const bool needs_barrier_check = IsObjectElementsKind(kind);\n+\n+  DCHECK(IsFastElementsKind(kind));\n+  CSA_ASSERT(this, IsFixedArrayWithKind(elements, kind));\n+  CSA_ASSERT(this,\n+             IntPtrLessThanOrEqual(IntPtrAdd(dst_index, length),\n+                                   LoadAndUntagFixedArrayBaseLength(elements)));\n+  CSA_ASSERT(this,\n+             IntPtrLessThanOrEqual(IntPtrAdd(src_index, length),\n+                                   LoadAndUntagFixedArrayBaseLength(elements)));\n+\n+  // The write barrier can be ignored if {elements} is in new space, or if\n+  // we have a SMI or double ElementsKind.\n+  if (needs_barrier_check) {\n+    JumpIfPointersFromHereAreInteresting(elements, &needs_barrier);\n+  }\n+\n+  const TNode<IntPtrT> source_byte_length =\n+      IntPtrMul(length, IntPtrConstant(ElementsKindToByteSize(kind)));\n+  static const int32_t fa_base_data_offset =\n+      FixedArrayBase::kHeaderSize - kHeapObjectTag;\n+  TNode<IntPtrT> elements_intptr = BitcastTaggedToWord(elements);\n+  TNode<IntPtrT> target_data_ptr =\n+      IntPtrAdd(elements_intptr,\n+                ElementOffsetFromIndex(dst_index, kind, INTPTR_PARAMETERS,\n+                                       fa_base_data_offset));\n+  TNode<IntPtrT> source_data_ptr =\n+      IntPtrAdd(elements_intptr,\n+                ElementOffsetFromIndex(src_index, kind, INTPTR_PARAMETERS,\n+                                       fa_base_data_offset));\n+  TNode<ExternalReference> memmove =\n+      ExternalConstant(ExternalReference::libc_memmove_function());\n+  CallCFunction3(MachineType::Pointer(), MachineType::Pointer(),\n+                 MachineType::Pointer(), MachineType::UintPtr(), memmove,\n+                 target_data_ptr, source_data_ptr, source_byte_length);\n+\n+  if (needs_barrier_check) {\n+    Goto(&finished);\n+\n+    BIND(&needs_barrier);\n+    {\n+      const TNode<IntPtrT> begin = src_index;\n+      const TNode<IntPtrT> end = IntPtrAdd(begin, length);\n+\n+      // If dst_index is less than src_index, then walk forward.\n+      const TNode<IntPtrT> delta =\n+          IntPtrMul(IntPtrSub(dst_index, begin),\n+                    IntPtrConstant(ElementsKindToByteSize(kind)));\n+      auto loop_body = [&](Node* array, Node* offset) {\n+        Node* const element = Load(MachineType::AnyTagged(), array, offset);\n+        Node* const delta_offset = IntPtrAdd(offset, delta);\n+        Store(array, delta_offset, element);\n+      };\n+\n+      Label iterate_forward(this);\n+      Label iterate_backward(this);\n+      Branch(IntPtrLessThan(delta, IntPtrConstant(0)), &iterate_forward,\n+             &iterate_backward);\n+      BIND(&iterate_forward);\n+      {\n+        // Make a loop for the stores.\n+        BuildFastFixedArrayForEach(elements, kind, begin, end, loop_body,\n+                                   INTPTR_PARAMETERS,\n+                                   ForEachDirection::kForward);\n+        Goto(&finished);\n+      }\n+\n+      BIND(&iterate_backward);\n+      {\n+        BuildFastFixedArrayForEach(elements, kind, begin, end, loop_body,\n+                                   INTPTR_PARAMETERS,\n+                                   ForEachDirection::kReverse);\n+        Goto(&finished);\n+      }\n+    }\n+    BIND(&finished);\n+  }\n+}\n+\n+void CodeStubAssembler::CopyElements(ElementsKind kind,\n+                                     TNode<FixedArrayBase> dst_elements,\n+                                     TNode<IntPtrT> dst_index,\n+                                     TNode<FixedArrayBase> src_elements,\n+                                     TNode<IntPtrT> src_index,\n+                                     TNode<IntPtrT> length) {\n+  Label finished(this);\n+  Label needs_barrier(this);\n+  const bool needs_barrier_check = IsObjectElementsKind(kind);\n+\n+  DCHECK(IsFastElementsKind(kind));\n+  CSA_ASSERT(this, IsFixedArrayWithKind(dst_elements, kind));\n+  CSA_ASSERT(this, IsFixedArrayWithKind(src_elements, kind));\n+  CSA_ASSERT(this, IntPtrLessThanOrEqual(\n+                       IntPtrAdd(dst_index, length),\n+                       LoadAndUntagFixedArrayBaseLength(dst_elements)));\n+  CSA_ASSERT(this, IntPtrLessThanOrEqual(\n+                       IntPtrAdd(src_index, length),\n+                       LoadAndUntagFixedArrayBaseLength(src_elements)));\n+  CSA_ASSERT(this, WordNotEqual(dst_elements, src_elements));\n+\n+  // The write barrier can be ignored if {dst_elements} is in new space, or if\n+  // we have a SMI or double ElementsKind.\n+  if (needs_barrier_check) {\n+    JumpIfPointersFromHereAreInteresting(dst_elements, &needs_barrier);\n+  }\n+\n+  TNode<IntPtrT> source_byte_length =\n+      IntPtrMul(length, IntPtrConstant(ElementsKindToByteSize(kind)));\n+  static const int32_t fa_base_data_offset =\n+      FixedArrayBase::kHeaderSize - kHeapObjectTag;\n+  TNode<IntPtrT> src_offset_start = ElementOffsetFromIndex(\n+      src_index, kind, INTPTR_PARAMETERS, fa_base_data_offset);\n+  TNode<IntPtrT> dst_offset_start = ElementOffsetFromIndex(\n+      dst_index, kind, INTPTR_PARAMETERS, fa_base_data_offset);\n+  TNode<IntPtrT> src_elements_intptr = BitcastTaggedToWord(src_elements);\n+  TNode<IntPtrT> source_data_ptr =\n+      IntPtrAdd(src_elements_intptr, src_offset_start);\n+  TNode<IntPtrT> dst_elements_intptr = BitcastTaggedToWord(dst_elements);\n+  TNode<IntPtrT> dst_data_ptr =\n+      IntPtrAdd(dst_elements_intptr, dst_offset_start);\n+  TNode<ExternalReference> memcpy =\n+      ExternalConstant(ExternalReference::libc_memcpy_function());\n+  CallCFunction3(MachineType::Pointer(), MachineType::Pointer(),\n+                 MachineType::Pointer(), MachineType::UintPtr(), memcpy,\n+                 dst_data_ptr, source_data_ptr, source_byte_length);\n+\n+  if (needs_barrier_check) {\n+    Goto(&finished);\n+\n+    BIND(&needs_barrier);\n+    {\n+      const TNode<IntPtrT> begin = src_index;\n+      const TNode<IntPtrT> end = IntPtrAdd(begin, length);\n+      const TNode<IntPtrT> delta =\n+          IntPtrMul(IntPtrSub(dst_index, src_index),\n+                    IntPtrConstant(ElementsKindToByteSize(kind)));\n+      BuildFastFixedArrayForEach(\n+          src_elements, kind, begin, end,\n+          [&](Node* array, Node* offset) {\n+            Node* const element = Load(MachineType::AnyTagged(), array, offset);\n+            Node* const delta_offset = IntPtrAdd(offset, delta);\n+            Store(dst_elements, delta_offset, element);\n+          },\n+          INTPTR_PARAMETERS, ForEachDirection::kForward);\n+      Goto(&finished);\n+    }\n+    BIND(&finished);\n+  }\n+}\n+\n void CodeStubAssembler::CopyFixedArrayElements(\n     ElementsKind from_kind, Node* from_array, ElementsKind to_kind,\n     Node* to_array, Node* first_element, Node* element_count, Node* capacity,"
        },
        {
            "sha": "8bd39369b791a3f2c61f744f96ffd0e7a89d8ac7",
            "filename": "deps/v8/src/code-stub-assembler.h",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.h?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -1567,6 +1567,25 @@ class V8_EXPORT_PRIVATE CodeStubAssembler : public compiler::CodeAssembler {\n                            SMI_PARAMETERS);\n   }\n \n+  void JumpIfPointersFromHereAreInteresting(TNode<Object> object,\n+                                            Label* interesting);\n+\n+  // Efficiently copy elements within a single array. The regions\n+  // [src_index, src_index + length) and [dst_index, dst_index + length)\n+  // can be overlapping.\n+  void MoveElements(ElementsKind kind, TNode<FixedArrayBase> elements,\n+                    TNode<IntPtrT> dst_index, TNode<IntPtrT> src_index,\n+                    TNode<IntPtrT> length);\n+\n+  // Efficiently copy elements from one array to another. The ElementsKind\n+  // needs to be the same. Copy from src_elements at\n+  // [src_index, src_index + length) to dst_elements at\n+  // [dst_index, dst_index + length).\n+  void CopyElements(ElementsKind kind, TNode<FixedArrayBase> dst_elements,\n+                    TNode<IntPtrT> dst_index,\n+                    TNode<FixedArrayBase> src_elements,\n+                    TNode<IntPtrT> src_index, TNode<IntPtrT> length);\n+\n   TNode<FixedArray> HeapObjectToFixedArray(TNode<HeapObject> base,\n                                            Label* cast_fail);\n \n@@ -1740,6 +1759,10 @@ class V8_EXPORT_PRIVATE CodeStubAssembler : public compiler::CodeAssembler {\n   Node* CalculateNewElementsCapacity(Node* old_capacity,\n                                      ParameterMode mode = INTPTR_PARAMETERS);\n \n+  TNode<Smi> CalculateNewElementsCapacity(TNode<Smi> old_capacity) {\n+    return CAST(CalculateNewElementsCapacity(old_capacity, SMI_PARAMETERS));\n+  }\n+\n   // Tries to grow the |elements| array of given |object| to store the |key|\n   // or bails out if the growing gap is too big. Returns new elements.\n   Node* TryGrowElementsCapacity(Node* object, Node* elements, ElementsKind kind,"
        },
        {
            "sha": "b141cad773603148f8e25fcefdf46bae51437c0c",
            "filename": "deps/v8/src/compiler/representation-change.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fcompiler%2Frepresentation-change.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Fsrc%2Fcompiler%2Frepresentation-change.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Frepresentation-change.cc?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -586,7 +586,7 @@ Node* RepresentationChanger::GetFloat32RepresentationFor(\n   } else if (output_rep == MachineRepresentation::kFloat64) {\n     op = machine()->TruncateFloat64ToFloat32();\n   } else if (output_rep == MachineRepresentation::kWord64) {\n-    if (output_type.Is(Type::Signed32())) {\n+    if (output_type.Is(cache_.kSafeInteger)) {\n       // int64 -> float64 -> float32\n       op = machine()->ChangeInt64ToFloat64();\n       node = jsgraph()->graph()->NewNode(op, node);"
        },
        {
            "sha": "6f63ac6c9b025fa2e1c09cd455599eb109e1e759",
            "filename": "deps/v8/test/mjsunit/regress/regress-895691.js",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftest%2Fmjsunit%2Fregress%2Fregress-895691.js",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftest%2Fmjsunit%2Fregress%2Fregress-895691.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fmjsunit%2Fregress%2Fregress-895691.js?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+// Flags: --allow-natives-syntax\n+\n+const n = 2**32;\n+const x = new Float32Array();\n+\n+function f() {\n+  for (var i = 96; i < 100; i += 4) {\n+    x[i] = i + n;\n+  }\n+}\n+\n+f();\n+%OptimizeFunctionOnNextCall(f);\n+f();"
        },
        {
            "sha": "3841a861c8396a0e30c395fc44ffc33aa66a0b35",
            "filename": "deps/v8/tools/__init__.py",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftools%2F__init__.py",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftools%2F__init__.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftools%2F__init__.py?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -0,0 +1,4 @@\n+#!/usr/bin/env python\n+# Copyright 2018 the V8 project authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style license that can be\n+# found in the LICENSE file."
        },
        {
            "sha": "3841a861c8396a0e30c395fc44ffc33aa66a0b35",
            "filename": "deps/v8/tools/unittests/__init__.py",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftools%2Funittests%2F__init__.py",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftools%2Funittests%2F__init__.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftools%2Funittests%2F__init__.py?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -0,0 +1,4 @@\n+#!/usr/bin/env python\n+# Copyright 2018 the V8 project authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style license that can be\n+# found in the LICENSE file."
        },
        {
            "sha": "2c66d1891b8ff86a5ae02f887856fe8543f9981e",
            "filename": "deps/v8/tools/unittests/v8_presubmit_test.py",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftools%2Funittests%2Fv8_presubmit_test.py",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftools%2Funittests%2Fv8_presubmit_test.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftools%2Funittests%2Fv8_presubmit_test.py?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -0,0 +1,91 @@\n+#!/usr/bin/env python\n+# Copyright 2018 the V8 project authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style license that can be\n+# found in the LICENSE file.\n+\n+import os\n+import sys\n+import tempfile\n+import unittest\n+\n+# Configuring the path for the v8_presubmit module\n+TOOLS_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n+sys.path.append(TOOLS_ROOT)\n+\n+from v8_presubmit import FileContentsCache, CacheableSourceFileProcessor\n+\n+\n+class FakeCachedProcessor(CacheableSourceFileProcessor):\n+  def __init__(self, cache_file_path):\n+    super(FakeCachedProcessor, self).__init__(\n+      use_cache=True, cache_file_path=cache_file_path, file_type='.test')\n+  def GetProcessorWorker(self):\n+    return object\n+  def GetProcessorScript(self):\n+    return \"echo\", []\n+  def DetectUnformattedFiles(_, cmd, worker, files):\n+    raise NotImplementedError\n+\n+class FileContentsCacheTest(unittest.TestCase):\n+  def setUp(self):\n+    _, self.cache_file_path = tempfile.mkstemp()\n+    cache = FileContentsCache(self.cache_file_path)\n+    cache.Load()\n+\n+    def generate_file():\n+      _, file_name = tempfile.mkstemp()\n+      with open(file_name, \"w\") as f:\n+        f.write(file_name)\n+\n+      return file_name\n+\n+    self.target_files = [generate_file() for _ in range(2)]\n+    unchanged_files = cache.FilterUnchangedFiles(self.target_files)\n+    self.assertEqual(len(unchanged_files), 2)\n+    cache.Save()\n+\n+  def tearDown(self):\n+    for file in [self.cache_file_path] + self.target_files:\n+      os.remove(file)\n+\n+  def testCachesFiles(self):\n+    cache = FileContentsCache(self.cache_file_path)\n+    cache.Load()\n+\n+    changed_files = cache.FilterUnchangedFiles(self.target_files)\n+    self.assertListEqual(changed_files, [])\n+\n+    modified_file = self.target_files[0]\n+    with open(modified_file, \"w\") as f:\n+      f.write(\"modification\")\n+\n+    changed_files = cache.FilterUnchangedFiles(self.target_files)\n+    self.assertListEqual(changed_files, [modified_file])\n+\n+  def testCacheableSourceFileProcessor(self):\n+    class CachedProcessor(FakeCachedProcessor):\n+      def DetectFilesToChange(_, files):\n+        self.assertListEqual(files, [])\n+        return []\n+\n+    cached_processor = CachedProcessor(cache_file_path=self.cache_file_path)\n+    cached_processor.ProcessFiles(self.target_files)\n+\n+  def testCacheableSourceFileProcessorWithModifications(self):\n+    modified_file = self.target_files[0]\n+    with open(modified_file, \"w\") as f:\n+      f.write(\"modification\")\n+\n+    class CachedProcessor(FakeCachedProcessor):\n+      def DetectFilesToChange(_, files):\n+        self.assertListEqual(files, [modified_file])\n+        return []\n+\n+    cached_processor = CachedProcessor(\n+      cache_file_path=self.cache_file_path,\n+    )\n+    cached_processor.ProcessFiles(self.target_files)\n+\n+\n+if __name__ == '__main__':\n+  unittest.main()"
        },
        {
            "sha": "22d6bf5389c6dfed738a4eef9ba387f62eec9d82",
            "filename": "deps/v8/tools/v8_presubmit.py",
            "status": "modified",
            "additions": 113,
            "deletions": 81,
            "changes": 194,
            "blob_url": "https://github.com/nodejs/node/blob/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftools%2Fv8_presubmit.py",
            "raw_url": "https://github.com/nodejs/node/raw/a9812142ca4116b425e92274c437d99e1d713fe2/deps%2Fv8%2Ftools%2Fv8_presubmit.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftools%2Fv8_presubmit.py?ref=a9812142ca4116b425e92274c437d99e1d713fe2",
            "patch": "@@ -228,17 +228,98 @@ def FindFilesIn(self, path):\n     return result\n \n \n-class CppLintProcessor(SourceFileProcessor):\n+class CacheableSourceFileProcessor(SourceFileProcessor):\n+  \"\"\"Utility class that allows caching ProcessFiles() method calls.\n+\n+  In order to use it, create a ProcessFilesWithoutCaching method that returns\n+  the files requiring intervention after processing the source files.\n+  \"\"\"\n+\n+  def __init__(self, use_cache, cache_file_path, file_type):\n+    self.use_cache = use_cache\n+    self.cache_file_path = cache_file_path\n+    self.file_type = file_type\n+\n+  def GetProcessorWorker(self):\n+    \"\"\"Expected to return the worker function to run the formatter.\"\"\"\n+    raise NotImplementedError\n+\n+  def GetProcessorScript(self):\n+    \"\"\"Expected to return a tuple\n+    (path to the format processor script, list of arguments).\"\"\"\n+    raise NotImplementedError\n+\n+  def GetProcessorCommand(self):\n+    format_processor, options = self.GetProcessorScript()\n+    if not format_processor:\n+      print('Could not find the formatter for % files' % self.file_type)\n+      sys.exit(1)\n+\n+    command = [sys.executable, format_processor]\n+    command.extend(options)\n+\n+    return command\n+\n+  def ProcessFiles(self, files):\n+    if self.use_cache:\n+      cache = FileContentsCache(self.cache_file_path)\n+      cache.Load()\n+      files = cache.FilterUnchangedFiles(files)\n+\n+    if len(files) == 0:\n+      print 'No changes in %s files detected. Skipping check' % self.file_type\n+      return True\n+\n+    files_requiring_changes = self.DetectFilesToChange(files)\n+    print (\n+      'Total %s files found that require formatting: %d' %\n+      (self.file_type, len(files_requiring_changes)))\n+    if self.use_cache:\n+      for file in files_requiring_changes:\n+        cache.RemoveFile(file)\n+\n+      cache.Save()\n+\n+    return files_requiring_changes == []\n+\n+  def DetectFilesToChange(self, files):\n+    command = self.GetProcessorCommand()\n+    worker = self.GetProcessorWorker()\n+\n+    commands = [command + [file] for file in files]\n+    count = multiprocessing.cpu_count()\n+    pool = multiprocessing.Pool(count)\n+    try:\n+      results = pool.map_async(worker, commands).get(timeout=240)\n+    except KeyboardInterrupt:\n+      print \"\\nCaught KeyboardInterrupt, terminating workers.\"\n+      pool.terminate()\n+      pool.join()\n+      sys.exit(1)\n+\n+    unformatted_files = []\n+    for index, errors in enumerate(results):\n+      if errors > 0:\n+        unformatted_files.append(files[index])\n+\n+    return unformatted_files\n+\n+\n+class CppLintProcessor(CacheableSourceFileProcessor):\n   \"\"\"\n   Lint files to check that they follow the google code style.\n   \"\"\"\n \n+  def __init__(self, use_cache=True):\n+    super(CppLintProcessor, self).__init__(\n+      use_cache=use_cache, cache_file_path='.cpplint-cache', file_type='C/C++')\n+\n   def IsRelevant(self, name):\n     return name.endswith('.cc') or name.endswith('.h')\n \n   def IgnoreDir(self, name):\n     return (super(CppLintProcessor, self).IgnoreDir(name)\n-              or (name == 'third_party'))\n+            or (name == 'third_party'))\n \n   IGNORE_LINT = ['export-template.h', 'flag-definitions.h']\n \n@@ -251,55 +332,30 @@ def GetPathsToSearch(self):\n     test_dirs = ['cctest', 'common', 'fuzzer', 'inspector', 'unittests']\n     return dirs + [join('test', dir) for dir in test_dirs]\n \n-  def GetCpplintScript(self, prio_path):\n-    for path in [prio_path] + os.environ[\"PATH\"].split(os.pathsep):\n+  def GetProcessorWorker(self):\n+    return CppLintWorker\n+\n+  def GetProcessorScript(self):\n+    filters = ','.join([n for n in LINT_RULES])\n+    arguments = ['--filter', filters]\n+    for path in [TOOLS_PATH] + os.environ[\"PATH\"].split(os.pathsep):\n       path = path.strip('\"')\n-      cpplint = os.path.join(path, \"cpplint.py\")\n+      cpplint = os.path.join(path, 'cpplint.py')\n       if os.path.isfile(cpplint):\n-        return cpplint\n-\n-    return None\n-\n-  def ProcessFiles(self, files):\n-    good_files_cache = FileContentsCache('.cpplint-cache')\n-    good_files_cache.Load()\n-    files = good_files_cache.FilterUnchangedFiles(files)\n-    if len(files) == 0:\n-      print 'No changes in C/C++ files detected. Skipping cpplint check.'\n-      return True\n-\n-    filters = \",\".join([n for n in LINT_RULES])\n-    cpplint = self.GetCpplintScript(TOOLS_PATH)\n-    if cpplint is None:\n-      print('Could not find cpplint.py. Make sure '\n-            'depot_tools is installed and in the path.')\n-      sys.exit(1)\n-\n-    command = [sys.executable, cpplint, '--filter', filters]\n-\n-    commands = [command + [file] for file in files]\n-    count = multiprocessing.cpu_count()\n-    pool = multiprocessing.Pool(count)\n-    try:\n-      results = pool.map_async(CppLintWorker, commands).get(999999)\n-    except KeyboardInterrupt:\n-      print \"\\nCaught KeyboardInterrupt, terminating workers.\"\n-      sys.exit(1)\n+        return cpplint, arguments\n \n-    for i in range(len(files)):\n-      if results[i] > 0:\n-        good_files_cache.RemoveFile(files[i])\n+    return None, arguments\n \n-    total_errors = sum(results)\n-    print \"Total C/C++ files found that require formatting: %d\" % total_errors\n-    good_files_cache.Save()\n-    return total_errors == 0\n \n-class TorqueFormatProcessor(SourceFileProcessor):\n+class TorqueFormatProcessor(CacheableSourceFileProcessor):\n   \"\"\"\n   Check .tq files to verify they follow the Torque style guide.\n   \"\"\"\n \n+  def __init__(self, use_cache=True):\n+    super(TorqueFormatProcessor, self).__init__(\n+      use_cache=use_cache, cache_file_path='.torquelint-cache', file_type='Torque')\n+\n   def IsRelevant(self, name):\n     return name.endswith('.tq')\n \n@@ -308,47 +364,17 @@ def GetPathsToSearch(self):\n     test_dirs = ['torque']\n     return dirs + [join('test', dir) for dir in test_dirs]\n \n-  def GetTorquelintScript(self):\n+  def GetProcessorWorker(self):\n+    return TorqueLintWorker\n+\n+  def GetProcessorScript(self):\n     torque_tools = os.path.join(TOOLS_PATH, \"torque\")\n     torque_path = os.path.join(torque_tools, \"format-torque.py\")\n-\n+    arguments = ['-l']\n     if os.path.isfile(torque_path):\n-      return torque_path\n-\n-    return None\n-\n-  def ProcessFiles(self, files):\n-    good_files_cache = FileContentsCache('.torquelint-cache')\n-    good_files_cache.Load()\n-    files = good_files_cache.FilterUnchangedFiles(files)\n-    if len(files) == 0:\n-      print 'No changes in Torque files detected. Skipping Torque lint check.'\n-      return True\n-\n-    torquelint = self.GetTorquelintScript()\n-    if torquelint is None:\n-      print('Could not find format-torque.')\n-      sys.exit(1)\n-\n-    command = [sys.executable, torquelint, '-l']\n-\n-    commands = [command + [file] for file in files]\n-    count = multiprocessing.cpu_count()\n-    pool = multiprocessing.Pool(count)\n-    try:\n-      results = pool.map_async(TorqueLintWorker, commands).get()\n-    except KeyboardInterrupt:\n-      print \"\\nCaught KeyboardInterrupt, terminating workers.\"\n-      sys.exit(1)\n-\n-    for i in range(len(files)):\n-      if results[i] > 0:\n-        good_files_cache.RemoveFile(files[i])\n+      return torque_path, arguments\n \n-    total_errors = sum(results)\n-    print \"Total Torque files requiring formatting: %d\" % total_errors\n-    good_files_cache.Save()\n-    return total_errors == 0\n+    return None, arguments\n \n COPYRIGHT_HEADER_PATTERN = re.compile(\n     r'Copyright [\\d-]*20[0-1][0-9] the V8 project authors. All rights reserved.')\n@@ -639,13 +665,17 @@ def PyTests(workspace):\n     print 'Running ' + script\n     result &= subprocess.call(\n         [sys.executable, script], stdout=subprocess.PIPE) == 0\n+\n   return result\n \n \n def GetOptions():\n   result = optparse.OptionParser()\n   result.add_option('--no-lint', help=\"Do not run cpplint\", default=False,\n                     action=\"store_true\")\n+  result.add_option('--no-linter-cache', help=\"Do not cache linter results\", default=False,\n+                    action=\"store_true\")\n+\n   return result\n \n \n@@ -656,11 +686,13 @@ def Main():\n   success = True\n   print \"Running checkdeps...\"\n   success &= CheckDeps(workspace)\n+  use_linter_cache = not options.no_linter_cache\n   if not options.no_lint:\n     print \"Running C++ lint check...\"\n-    success &= CppLintProcessor().RunOnPath(workspace)\n+    success &= CppLintProcessor(use_cache=use_linter_cache).RunOnPath(workspace)\n+\n   print \"Running Torque formatting check...\"\n-  success &= TorqueFormatProcessor().RunOnPath(workspace)\n+  success &= TorqueFormatProcessor(use_cache=use_linter_cache).RunOnPath(workspace)\n   print \"Running copyright header, trailing whitespaces and \" \\\n         \"two empty lines between declarations check...\"\n   success &= SourceProcessor().RunOnPath(workspace)"
        }
    ],
    "stats": {
        "total": 671,
        "additions": 544,
        "deletions": 127
    }
}