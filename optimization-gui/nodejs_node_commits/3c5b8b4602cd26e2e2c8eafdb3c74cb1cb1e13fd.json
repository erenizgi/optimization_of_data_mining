{
    "author": "Trott",
    "message": "test: refactor child-process-fork-net\n\nSplit test-child-process-fork-net into\ntest-child-process-fork-net-server and\ntest-child-process-fork-net-socket. Rename\ntest-child-process-fork-net2.js to test-child-process-fork-net.js.\n\nRefs: https://github.com/nodejs/node/pull/21012\n\nPR-URL: https://github.com/nodejs/node/pull/21095\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>",
    "sha": "3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd",
    "files": [
        {
            "sha": "acc0c95b6a953ba8a7d8b0dac0b2000ccea212cc",
            "filename": "test/parallel/parallel.status",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd/test%2Fparallel%2Fparallel.status",
            "raw_url": "https://github.com/nodejs/node/raw/3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd/test%2Fparallel%2Fparallel.status",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Fparallel.status?ref=3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd",
            "patch": "@@ -9,7 +9,7 @@ prefix parallel\n test-postmortem-metadata: PASS,FLAKY\n \n [$system==win32]\n-test-child-process-fork-net: PASS,FLAKY\n+test-child-process-fork-net-socket: PASS,FLAKY\n \n [$system==linux]\n "
        },
        {
            "sha": "340b3075f9622a22b2103f045f3b52ccfac98dc9",
            "filename": "test/parallel/test-child-process-fork-net-server.js",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/nodejs/node/blob/3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd/test%2Fparallel%2Ftest-child-process-fork-net-server.js",
            "raw_url": "https://github.com/nodejs/node/raw/3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd/test%2Fparallel%2Ftest-child-process-fork-net-server.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-child-process-fork-net-server.js?ref=3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd",
            "patch": "@@ -0,0 +1,145 @@\n+// Copyright Joyent, Inc. and other Node contributors.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a\n+// copy of this software and associated documentation files (the\n+// \"Software\"), to deal in the Software without restriction, including\n+// without limitation the rights to use, copy, modify, merge, publish,\n+// distribute, sublicense, and/or sell copies of the Software, and to permit\n+// persons to whom the Software is furnished to do so, subject to the\n+// following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included\n+// in all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+// USE OR OTHER DEALINGS IN THE SOFTWARE.\n+\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const fork = require('child_process').fork;\n+const net = require('net');\n+\n+function ProgressTracker(missing, callback) {\n+  this.missing = missing;\n+  this.callback = callback;\n+}\n+ProgressTracker.prototype.done = function() {\n+  this.missing -= 1;\n+  this.check();\n+};\n+ProgressTracker.prototype.check = function() {\n+  if (this.missing === 0) this.callback();\n+};\n+\n+if (process.argv[2] === 'child') {\n+\n+  let serverScope;\n+\n+  process.on('message', function onServer(msg, server) {\n+    if (msg.what !== 'server') return;\n+    process.removeListener('message', onServer);\n+\n+    serverScope = server;\n+\n+    server.on('connection', function(socket) {\n+      console.log('CHILD: got connection');\n+      process.send({ what: 'connection' });\n+      socket.destroy();\n+    });\n+\n+    // Start making connection from parent.\n+    console.log('CHILD: server listening');\n+    process.send({ what: 'listening' });\n+  });\n+\n+  process.on('message', function onClose(msg) {\n+    if (msg.what !== 'close') return;\n+    process.removeListener('message', onClose);\n+\n+    serverScope.on('close', function() {\n+      process.send({ what: 'close' });\n+    });\n+    serverScope.close();\n+  });\n+\n+  process.send({ what: 'ready' });\n+} else {\n+\n+  const child = fork(process.argv[1], ['child']);\n+\n+  child.on('exit', common.mustCall(function(code, signal) {\n+    const message = `CHILD: died with ${code}, ${signal}`;\n+    assert.strictEqual(code, 0, message);\n+  }));\n+\n+  // Send net.Server to child and test by connecting.\n+  function testServer(callback) {\n+\n+    // Destroy server execute callback when done.\n+    const progress = new ProgressTracker(2, function() {\n+      server.on('close', function() {\n+        console.log('PARENT: server closed');\n+        child.send({ what: 'close' });\n+      });\n+      server.close();\n+    });\n+\n+    // We expect 4 connections and close events.\n+    const connections = new ProgressTracker(4, progress.done.bind(progress));\n+    const closed = new ProgressTracker(4, progress.done.bind(progress));\n+\n+    // Create server and send it to child.\n+    const server = net.createServer();\n+    server.on('connection', function(socket) {\n+      console.log('PARENT: got connection');\n+      socket.destroy();\n+      connections.done();\n+    });\n+    server.on('listening', function() {\n+      console.log('PARENT: server listening');\n+      child.send({ what: 'server' }, server);\n+    });\n+    server.listen(0);\n+\n+    // Handle client messages.\n+    function messageHandlers(msg) {\n+\n+      if (msg.what === 'listening') {\n+        // Make connections.\n+        let socket;\n+        for (let i = 0; i < 4; i++) {\n+          socket = net.connect(server.address().port, function() {\n+            console.log('CLIENT: connected');\n+          });\n+          socket.on('close', function() {\n+            closed.done();\n+            console.log('CLIENT: closed');\n+          });\n+        }\n+\n+      } else if (msg.what === 'connection') {\n+        // child got connection\n+        connections.done();\n+      } else if (msg.what === 'close') {\n+        child.removeListener('message', messageHandlers);\n+        callback();\n+      }\n+    }\n+\n+    child.on('message', messageHandlers);\n+  }\n+\n+  // Create server and send it to child.\n+  child.on('message', function onReady(msg) {\n+    if (msg.what !== 'ready') return;\n+    child.removeListener('message', onReady);\n+\n+    testServer(common.mustCall());\n+  });\n+}"
        },
        {
            "sha": "8e3d9ee16e2e56c15a5e7b2f496d0e5ae3fb9cfe",
            "filename": "test/parallel/test-child-process-fork-net-socket.js",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/nodejs/node/blob/3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd/test%2Fparallel%2Ftest-child-process-fork-net-socket.js",
            "raw_url": "https://github.com/nodejs/node/raw/3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd/test%2Fparallel%2Ftest-child-process-fork-net-socket.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-child-process-fork-net-socket.js?ref=3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd",
            "patch": "@@ -0,0 +1,87 @@\n+// Copyright Joyent, Inc. and other Node contributors.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a\n+// copy of this software and associated documentation files (the\n+// \"Software\"), to deal in the Software without restriction, including\n+// without limitation the rights to use, copy, modify, merge, publish,\n+// distribute, sublicense, and/or sell copies of the Software, and to permit\n+// persons to whom the Software is furnished to do so, subject to the\n+// following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included\n+// in all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+// USE OR OTHER DEALINGS IN THE SOFTWARE.\n+\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const fork = require('child_process').fork;\n+const net = require('net');\n+\n+if (process.argv[2] === 'child') {\n+\n+  process.on('message', function onSocket(msg, socket) {\n+    if (msg.what !== 'socket') return;\n+    process.removeListener('message', onSocket);\n+    socket.end('echo');\n+    console.log('CHILD: got socket');\n+  });\n+\n+  process.send({ what: 'ready' });\n+} else {\n+\n+  const child = fork(process.argv[1], ['child']);\n+\n+  child.on('exit', common.mustCall(function(code, signal) {\n+    const message = `CHILD: died with ${code}, ${signal}`;\n+    assert.strictEqual(code, 0, message);\n+  }));\n+\n+  // Send net.Socket to child.\n+  function testSocket(callback) {\n+\n+    // Create a new server and connect to it,\n+    // but the socket will be handled by the child.\n+    const server = net.createServer();\n+    server.on('connection', function(socket) {\n+      socket.on('close', function() {\n+        console.log('CLIENT: socket closed');\n+      });\n+      child.send({ what: 'socket' }, socket);\n+    });\n+    server.on('close', function() {\n+      console.log('PARENT: server closed');\n+      callback();\n+    });\n+\n+    server.listen(0, function() {\n+      console.log('testSocket, listening');\n+      const connect = net.connect(server.address().port);\n+      let store = '';\n+      connect.on('data', function(chunk) {\n+        store += chunk;\n+        console.log('CLIENT: got data');\n+      });\n+      connect.on('close', function() {\n+        console.log('CLIENT: closed');\n+        assert.strictEqual(store, 'echo');\n+        server.close();\n+      });\n+    });\n+  }\n+\n+  // Create socket and send it to child.\n+  child.on('message', function onReady(msg) {\n+    if (msg.what !== 'ready') return;\n+    child.removeListener('message', onReady);\n+\n+    testSocket(common.mustCall());\n+  });\n+}"
        },
        {
            "sha": "babde351d3f05a5f5c58af4525417e5eb4a1d311",
            "filename": "test/parallel/test-child-process-fork-net.js",
            "status": "modified",
            "additions": 105,
            "deletions": 146,
            "changes": 251,
            "blob_url": "https://github.com/nodejs/node/blob/3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd/test%2Fparallel%2Ftest-child-process-fork-net.js",
            "raw_url": "https://github.com/nodejs/node/raw/3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd/test%2Fparallel%2Ftest-child-process-fork-net.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-child-process-fork-net.js?ref=3c5b8b4602cd26e2e2c8eafdb3c74cb1cb1e13fd",
            "patch": "@@ -24,182 +24,141 @@ const common = require('../common');\n const assert = require('assert');\n const fork = require('child_process').fork;\n const net = require('net');\n-\n-function ProgressTracker(missing, callback) {\n-  this.missing = missing;\n-  this.callback = callback;\n-}\n-ProgressTracker.prototype.done = function() {\n-  this.missing -= 1;\n-  this.check();\n-};\n-ProgressTracker.prototype.check = function() {\n-  if (this.missing === 0) this.callback();\n-};\n+const count = 12;\n \n if (process.argv[2] === 'child') {\n+  const needEnd = [];\n+  const id = process.argv[3];\n+\n+  process.on('message', function(m, socket) {\n+    if (!socket) return;\n \n-  let serverScope;\n+    console.error(`[${id}] got socket ${m}`);\n \n-  process.on('message', function onServer(msg, server) {\n-    if (msg.what !== 'server') return;\n-    process.removeListener('message', onServer);\n+    // will call .end('end') or .write('write');\n+    socket[m](m);\n \n-    serverScope = server;\n+    socket.resume();\n \n-    server.on('connection', function(socket) {\n-      console.log('CHILD: got connection');\n-      process.send({ what: 'connection' });\n-      socket.destroy();\n+    socket.on('data', function() {\n+      console.error(`[${id}] socket.data ${m}`);\n     });\n \n-    // Start making connection from parent.\n-    console.log('CHILD: server listening');\n-    process.send({ what: 'listening' });\n-  });\n+    socket.on('end', function() {\n+      console.error(`[${id}] socket.end ${m}`);\n+    });\n \n-  process.on('message', function onClose(msg) {\n-    if (msg.what !== 'close') return;\n-    process.removeListener('message', onClose);\n+    // store the unfinished socket\n+    if (m === 'write') {\n+      needEnd.push(socket);\n+    }\n \n-    serverScope.on('close', function() {\n-      process.send({ what: 'close' });\n+    socket.on('close', function(had_error) {\n+      console.error(`[${id}] socket.close ${had_error} ${m}`);\n     });\n-    serverScope.close();\n-  });\n \n-  process.on('message', function onSocket(msg, socket) {\n-    if (msg.what !== 'socket') return;\n-    process.removeListener('message', onSocket);\n-    socket.end('echo');\n-    console.log('CHILD: got socket');\n+    socket.on('finish', function() {\n+      console.error(`[${id}] socket finished ${m}`);\n+    });\n   });\n \n-  process.send({ what: 'ready' });\n-} else {\n+  process.on('message', function(m) {\n+    if (m !== 'close') return;\n+    console.error(`[${id}] got close message`);\n+    needEnd.forEach(function(endMe, i) {\n+      console.error(`[${id}] ending ${i}/${needEnd.length}`);\n+      endMe.end('end');\n+    });\n+  });\n \n-  const child = fork(process.argv[1], ['child']);\n+  process.on('disconnect', function() {\n+    console.error(`[${id}] process disconnect, ending`);\n+    needEnd.forEach(function(endMe, i) {\n+      console.error(`[${id}] ending ${i}/${needEnd.length}`);\n+      endMe.end('end');\n+    });\n+  });\n \n-  child.on('exit', common.mustCall(function(code, signal) {\n-    const message = `CHILD: died with ${code}, ${signal}`;\n-    assert.strictEqual(code, 0, message);\n-  }));\n+} else {\n \n-  // Send net.Server to child and test by connecting.\n-  function testServer(callback) {\n+  const child1 = fork(process.argv[1], ['child', '1']);\n+  const child2 = fork(process.argv[1], ['child', '2']);\n+  const child3 = fork(process.argv[1], ['child', '3']);\n+\n+  const server = net.createServer();\n+\n+  let connected = 0;\n+  let closed = 0;\n+  server.on('connection', function(socket) {\n+    switch (connected % 6) {\n+      case 0:\n+        child1.send('end', socket); break;\n+      case 1:\n+        child1.send('write', socket); break;\n+      case 2:\n+        child2.send('end', socket); break;\n+      case 3:\n+        child2.send('write', socket); break;\n+      case 4:\n+        child3.send('end', socket); break;\n+      case 5:\n+        child3.send('write', socket); break;\n+    }\n+    connected += 1;\n \n-    // Destroy server execute callback when done.\n-    const progress = new ProgressTracker(2, function() {\n-      server.on('close', function() {\n-        console.log('PARENT: server closed');\n-        child.send({ what: 'close' });\n-      });\n-      server.close();\n+    socket.once('close', function() {\n+      console.log(`[m] socket closed, total ${++closed}`);\n     });\n \n-    // We expect 4 connections and close events.\n-    const connections = new ProgressTracker(4, progress.done.bind(progress));\n-    const closed = new ProgressTracker(4, progress.done.bind(progress));\n-\n-    // Create server and send it to child.\n-    const server = net.createServer();\n-    server.on('connection', function(socket) {\n-      console.log('PARENT: got connection');\n-      socket.destroy();\n-      connections.done();\n-    });\n-    server.on('listening', function() {\n-      console.log('PARENT: server listening');\n-      child.send({ what: 'server' }, server);\n-    });\n-    server.listen(0);\n-\n-    // Handle client messages.\n-    function messageHandlers(msg) {\n-\n-      if (msg.what === 'listening') {\n-        // Make connections.\n-        let socket;\n-        for (let i = 0; i < 4; i++) {\n-          socket = net.connect(server.address().port, function() {\n-            console.log('CLIENT: connected');\n-          });\n-          socket.on('close', function() {\n-            closed.done();\n-            console.log('CLIENT: closed');\n-          });\n-        }\n-\n-      } else if (msg.what === 'connection') {\n-        // child got connection\n-        connections.done();\n-      } else if (msg.what === 'close') {\n-        child.removeListener('message', messageHandlers);\n-        callback();\n-      }\n+    if (connected === count) {\n+      closeServer();\n     }\n+  });\n \n-    child.on('message', messageHandlers);\n-  }\n-\n-  // Send net.Socket to child.\n-  function testSocket(callback) {\n+  let disconnected = 0;\n+  server.on('listening', function() {\n \n-    // Create a new server and connect to it,\n-    // but the socket will be handled by the child.\n-    const server = net.createServer();\n-    server.on('connection', function(socket) {\n-      socket.on('close', function() {\n-        console.log('CLIENT: socket closed');\n+    let j = count;\n+    while (j--) {\n+      const client = net.connect(this.address().port, '127.0.0.1');\n+      client.on('error', function() {\n+        // This can happen if we kill the child too early.\n+        // The client should still get a close event afterwards.\n+        console.error('[m] CLIENT: error event');\n       });\n-      child.send({ what: 'socket' }, socket);\n-    });\n-    server.on('close', function() {\n-      console.log('PARENT: server closed');\n-      callback();\n-    });\n-    // Don't listen on the same port, because SmartOS sometimes says\n-    // that the server's fd is closed, but it still cannot listen\n-    // on the same port again.\n-    //\n-    // An isolated test for this would be lovely, but for now, this\n-    // will have to do.\n-    server.listen(0, function() {\n-      console.log('testSocket, listening');\n-      const connect = net.connect(server.address().port);\n-      let store = '';\n-      connect.on('data', function(chunk) {\n-        store += chunk;\n-        console.log('CLIENT: got data');\n-      });\n-      connect.on('close', function() {\n-        console.log('CLIENT: closed');\n-        assert.strictEqual(store, 'echo');\n-        server.close();\n+      client.on('close', function() {\n+        console.error('[m] CLIENT: close event');\n+        disconnected += 1;\n       });\n-    });\n-  }\n+      client.resume();\n+    }\n+  });\n \n-  // Create server and send it to child.\n-  let serverSuccess = false;\n-  let socketSuccess = false;\n-  child.on('message', function onReady(msg) {\n-    if (msg.what !== 'ready') return;\n-    child.removeListener('message', onReady);\n+  let closeEmitted = false;\n+  server.on('close', common.mustCall(function() {\n+    closeEmitted = true;\n \n-    testServer(function() {\n-      serverSuccess = true;\n+    child1.kill();\n+    child2.kill();\n+    child3.kill();\n+  }));\n \n-      testSocket(function() {\n-        socketSuccess = true;\n-      });\n-    });\n+  server.listen(0, '127.0.0.1');\n \n-  });\n+  function closeServer() {\n+    server.close();\n+\n+    setTimeout(function() {\n+      assert(!closeEmitted);\n+      child1.send('close');\n+      child2.send('close');\n+      child3.disconnect();\n+    }, 200);\n+  }\n \n   process.on('exit', function() {\n-    assert.ok(serverSuccess);\n-    assert.ok(socketSuccess);\n+    assert.strictEqual(server._workers.length, 0);\n+    assert.strictEqual(disconnected, count);\n+    assert.strictEqual(connected, count);\n   });\n-\n }"
        },
        {
            "sha": "babde351d3f05a5f5c58af4525417e5eb4a1d311",
            "filename": "test/parallel/test-child-process-fork-net2.js",
            "status": "removed",
            "additions": 0,
            "deletions": 164,
            "changes": 164,
            "blob_url": "https://github.com/nodejs/node/blob/5aa47bd26bc4beb011d87da35c93170b36381002/test%2Fparallel%2Ftest-child-process-fork-net2.js",
            "raw_url": "https://github.com/nodejs/node/raw/5aa47bd26bc4beb011d87da35c93170b36381002/test%2Fparallel%2Ftest-child-process-fork-net2.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-child-process-fork-net2.js?ref=5aa47bd26bc4beb011d87da35c93170b36381002",
            "patch": "@@ -1,164 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-'use strict';\n-const common = require('../common');\n-const assert = require('assert');\n-const fork = require('child_process').fork;\n-const net = require('net');\n-const count = 12;\n-\n-if (process.argv[2] === 'child') {\n-  const needEnd = [];\n-  const id = process.argv[3];\n-\n-  process.on('message', function(m, socket) {\n-    if (!socket) return;\n-\n-    console.error(`[${id}] got socket ${m}`);\n-\n-    // will call .end('end') or .write('write');\n-    socket[m](m);\n-\n-    socket.resume();\n-\n-    socket.on('data', function() {\n-      console.error(`[${id}] socket.data ${m}`);\n-    });\n-\n-    socket.on('end', function() {\n-      console.error(`[${id}] socket.end ${m}`);\n-    });\n-\n-    // store the unfinished socket\n-    if (m === 'write') {\n-      needEnd.push(socket);\n-    }\n-\n-    socket.on('close', function(had_error) {\n-      console.error(`[${id}] socket.close ${had_error} ${m}`);\n-    });\n-\n-    socket.on('finish', function() {\n-      console.error(`[${id}] socket finished ${m}`);\n-    });\n-  });\n-\n-  process.on('message', function(m) {\n-    if (m !== 'close') return;\n-    console.error(`[${id}] got close message`);\n-    needEnd.forEach(function(endMe, i) {\n-      console.error(`[${id}] ending ${i}/${needEnd.length}`);\n-      endMe.end('end');\n-    });\n-  });\n-\n-  process.on('disconnect', function() {\n-    console.error(`[${id}] process disconnect, ending`);\n-    needEnd.forEach(function(endMe, i) {\n-      console.error(`[${id}] ending ${i}/${needEnd.length}`);\n-      endMe.end('end');\n-    });\n-  });\n-\n-} else {\n-\n-  const child1 = fork(process.argv[1], ['child', '1']);\n-  const child2 = fork(process.argv[1], ['child', '2']);\n-  const child3 = fork(process.argv[1], ['child', '3']);\n-\n-  const server = net.createServer();\n-\n-  let connected = 0;\n-  let closed = 0;\n-  server.on('connection', function(socket) {\n-    switch (connected % 6) {\n-      case 0:\n-        child1.send('end', socket); break;\n-      case 1:\n-        child1.send('write', socket); break;\n-      case 2:\n-        child2.send('end', socket); break;\n-      case 3:\n-        child2.send('write', socket); break;\n-      case 4:\n-        child3.send('end', socket); break;\n-      case 5:\n-        child3.send('write', socket); break;\n-    }\n-    connected += 1;\n-\n-    socket.once('close', function() {\n-      console.log(`[m] socket closed, total ${++closed}`);\n-    });\n-\n-    if (connected === count) {\n-      closeServer();\n-    }\n-  });\n-\n-  let disconnected = 0;\n-  server.on('listening', function() {\n-\n-    let j = count;\n-    while (j--) {\n-      const client = net.connect(this.address().port, '127.0.0.1');\n-      client.on('error', function() {\n-        // This can happen if we kill the child too early.\n-        // The client should still get a close event afterwards.\n-        console.error('[m] CLIENT: error event');\n-      });\n-      client.on('close', function() {\n-        console.error('[m] CLIENT: close event');\n-        disconnected += 1;\n-      });\n-      client.resume();\n-    }\n-  });\n-\n-  let closeEmitted = false;\n-  server.on('close', common.mustCall(function() {\n-    closeEmitted = true;\n-\n-    child1.kill();\n-    child2.kill();\n-    child3.kill();\n-  }));\n-\n-  server.listen(0, '127.0.0.1');\n-\n-  function closeServer() {\n-    server.close();\n-\n-    setTimeout(function() {\n-      assert(!closeEmitted);\n-      child1.send('close');\n-      child2.send('close');\n-      child3.disconnect();\n-    }, 200);\n-  }\n-\n-  process.on('exit', function() {\n-    assert.strictEqual(server._workers.length, 0);\n-    assert.strictEqual(disconnected, count);\n-    assert.strictEqual(connected, count);\n-  });\n-}"
        }
    ],
    "stats": {
        "total": 649,
        "additions": 338,
        "deletions": 311
    }
}