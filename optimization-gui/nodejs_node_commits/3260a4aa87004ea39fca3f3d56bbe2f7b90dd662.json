{
    "author": "addaleax",
    "message": "report: remove `internalBinding('config').hasReport`\n\nThe `setup()` method is only called when the `--experimental-report`\noption is set. `getOptionValue()` returns `undefined` when\nthe flag is not defined, so the extra check inside of `setup()` is\nredundant.\n\nPR-URL: https://github.com/nodejs/node/pull/25610\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>",
    "sha": "3260a4aa87004ea39fca3f3d56bbe2f7b90dd662",
    "files": [
        {
            "sha": "9b66526ce3dc919061250efa5ef2f0732ed61124",
            "filename": "lib/internal/process/report.js",
            "status": "modified",
            "additions": 132,
            "deletions": 133,
            "changes": 265,
            "blob_url": "https://github.com/nodejs/node/blob/3260a4aa87004ea39fca3f3d56bbe2f7b90dd662/lib%2Finternal%2Fprocess%2Freport.js",
            "raw_url": "https://github.com/nodejs/node/raw/3260a4aa87004ea39fca3f3d56bbe2f7b90dd662/lib%2Finternal%2Fprocess%2Freport.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Freport.js?ref=3260a4aa87004ea39fca3f3d56bbe2f7b90dd662",
            "patch": "@@ -11,153 +11,152 @@ exports.setup = function() {\n   const REPORTFILENAME = 3;\n   const REPORTPATH = 4;\n   const REPORTVERBOSE = 5;\n-  if (internalBinding('config').hasReport) {\n-    // If report is enabled, extract the binding and\n-    // wrap the APIs with thin layers, with some error checks.\n-    // user options can come in from CLI / ENV / API.\n-    // CLI and ENV is intercepted in C++ and the API call here (JS).\n-    // So sync up with both sides as appropriate - initially from\n-    // C++ to JS and from JS to C++ whenever the API is called.\n-    // Some events are controlled purely from JS (signal | exception)\n-    // and some from C++ (fatalerror) so this sync-up is essential for\n-    // correct behavior and alignment with the supplied tunables.\n-    const nr = internalBinding('report');\n \n-    // Keep it un-exposed; lest programs play with it\n-    // leaving us with a lot of unwanted sanity checks.\n-    let config = {\n-      events: [],\n-      signal: 'SIGUSR2',\n-      filename: '',\n-      path: '',\n-      verbose: false\n-    };\n-    const report = {\n-      setDiagnosticReportOptions(options) {\n-        emitExperimentalWarning('report');\n-        // Reuse the null and undefined checks. Save\n-        // space when dealing with large number of arguments.\n-        const list = parseOptions(options);\n+  // If report is enabled, extract the binding and\n+  // wrap the APIs with thin layers, with some error checks.\n+  // user options can come in from CLI / ENV / API.\n+  // CLI and ENV is intercepted in C++ and the API call here (JS).\n+  // So sync up with both sides as appropriate - initially from\n+  // C++ to JS and from JS to C++ whenever the API is called.\n+  // Some events are controlled purely from JS (signal | exception)\n+  // and some from C++ (fatalerror) so this sync-up is essential for\n+  // correct behavior and alignment with the supplied tunables.\n+  const nr = internalBinding('report');\n \n-        // Flush the stale entries from report, as\n-        // we are refreshing it, items that the users did not\n-        // touch may be hanging around stale otherwise.\n-        config = {};\n+  // Keep it un-exposed; lest programs play with it\n+  // leaving us with a lot of unwanted sanity checks.\n+  let config = {\n+    events: [],\n+    signal: 'SIGUSR2',\n+    filename: '',\n+    path: '',\n+    verbose: false\n+  };\n+  const report = {\n+    setDiagnosticReportOptions(options) {\n+      emitExperimentalWarning('report');\n+      // Reuse the null and undefined checks. Save\n+      // space when dealing with large number of arguments.\n+      const list = parseOptions(options);\n \n-        // The parseOption method returns an array that include\n-        // the indices at which valid params are present.\n-        list.forEach((i) => {\n-          switch (i) {\n-            case REPORTEVENTS:\n-              if (Array.isArray(options.events))\n-                config.events = options.events;\n-              else\n-                throw new ERR_INVALID_ARG_TYPE('events',\n-                                               'Array',\n-                                               options.events);\n-              break;\n-            case REPORTSIGNAL:\n-              if (typeof options.signal !== 'string') {\n-                throw new ERR_INVALID_ARG_TYPE('signal',\n-                                               'String',\n-                                               options.signal);\n-              }\n-              process.removeListener(config.signal, handleSignal);\n-              if (config.events.includes('signal'))\n-                process.on(options.signal, handleSignal);\n-              config.signal = options.signal;\n-              break;\n-            case REPORTFILENAME:\n-              if (typeof options.filename !== 'string') {\n-                throw new ERR_INVALID_ARG_TYPE('filename',\n-                                               'String',\n-                                               options.filename);\n-              }\n-              config.filename = options.filename;\n-              break;\n-            case REPORTPATH:\n-              if (typeof options.path !== 'string')\n-                throw new ERR_INVALID_ARG_TYPE('path', 'String', options.path);\n-              config.path = options.path;\n-              break;\n-            case REPORTVERBOSE:\n-              if (typeof options.verbose !== 'string' &&\n-                  typeof options.verbose !== 'boolean') {\n-                throw new ERR_INVALID_ARG_TYPE('verbose',\n-                                               'Booelan | String' +\n-                                               ' (true|false|yes|no)',\n-                                               options.verbose);\n-              }\n-              config.verbose = options.verbose;\n-              break;\n-          }\n-        });\n-        // Upload this new config to C++ land\n-        nr.syncConfig(config, true);\n-      },\n+      // Flush the stale entries from report, as\n+      // we are refreshing it, items that the users did not\n+      // touch may be hanging around stale otherwise.\n+      config = {};\n+\n+      // The parseOption method returns an array that include\n+      // the indices at which valid params are present.\n+      list.forEach((i) => {\n+        switch (i) {\n+          case REPORTEVENTS:\n+            if (Array.isArray(options.events))\n+              config.events = options.events;\n+            else\n+              throw new ERR_INVALID_ARG_TYPE('events',\n+                                             'Array',\n+                                             options.events);\n+            break;\n+          case REPORTSIGNAL:\n+            if (typeof options.signal !== 'string') {\n+              throw new ERR_INVALID_ARG_TYPE('signal',\n+                                             'String',\n+                                             options.signal);\n+            }\n+            process.removeListener(config.signal, handleSignal);\n+            if (config.events.includes('signal'))\n+              process.on(options.signal, handleSignal);\n+            config.signal = options.signal;\n+            break;\n+          case REPORTFILENAME:\n+            if (typeof options.filename !== 'string') {\n+              throw new ERR_INVALID_ARG_TYPE('filename',\n+                                             'String',\n+                                             options.filename);\n+            }\n+            config.filename = options.filename;\n+            break;\n+          case REPORTPATH:\n+            if (typeof options.path !== 'string')\n+              throw new ERR_INVALID_ARG_TYPE('path', 'String', options.path);\n+            config.path = options.path;\n+            break;\n+          case REPORTVERBOSE:\n+            if (typeof options.verbose !== 'string' &&\n+                typeof options.verbose !== 'boolean') {\n+              throw new ERR_INVALID_ARG_TYPE('verbose',\n+                                             'Booelan | String' +\n+                                             ' (true|false|yes|no)',\n+                                             options.verbose);\n+            }\n+            config.verbose = options.verbose;\n+            break;\n+        }\n+      });\n+      // Upload this new config to C++ land\n+      nr.syncConfig(config, true);\n+    },\n \n \n-      triggerReport(file, err) {\n-        emitExperimentalWarning('report');\n-        if (err == null) {\n-          if (file == null) {\n-            return nr.triggerReport(new ERR_SYNTHETIC(\n-              'JavaScript Callstack').stack);\n-          }\n-          if (typeof file !== 'string')\n-            throw new ERR_INVALID_ARG_TYPE('file', 'String', file);\n-          return nr.triggerReport(file, new ERR_SYNTHETIC(\n+    triggerReport(file, err) {\n+      emitExperimentalWarning('report');\n+      if (err == null) {\n+        if (file == null) {\n+          return nr.triggerReport(new ERR_SYNTHETIC(\n             'JavaScript Callstack').stack);\n         }\n-        if (typeof err !== 'object')\n-          throw new ERR_INVALID_ARG_TYPE('err', 'Object', err);\n-        if (file == null)\n-          return nr.triggerReport(err.stack);\n         if (typeof file !== 'string')\n           throw new ERR_INVALID_ARG_TYPE('file', 'String', file);\n-        return nr.triggerReport(file, err.stack);\n-      },\n-      getReport(err) {\n-        emitExperimentalWarning('report');\n-        if (err == null) {\n-          return nr.getReport(new ERR_SYNTHETIC('JavaScript Callstack').stack);\n-        } else if (typeof err !== 'object') {\n-          throw new ERR_INVALID_ARG_TYPE('err', 'Objct', err);\n-        } else {\n-          return nr.getReport(err.stack);\n-        }\n+        return nr.triggerReport(file, new ERR_SYNTHETIC(\n+          'JavaScript Callstack').stack);\n       }\n-    };\n+      if (typeof err !== 'object')\n+        throw new ERR_INVALID_ARG_TYPE('err', 'Object', err);\n+      if (file == null)\n+        return nr.triggerReport(err.stack);\n+      if (typeof file !== 'string')\n+        throw new ERR_INVALID_ARG_TYPE('file', 'String', file);\n+      return nr.triggerReport(file, err.stack);\n+    },\n+    getReport(err) {\n+      emitExperimentalWarning('report');\n+      if (err == null) {\n+        return nr.getReport(new ERR_SYNTHETIC('JavaScript Callstack').stack);\n+      } else if (typeof err !== 'object') {\n+        throw new ERR_INVALID_ARG_TYPE('err', 'Objct', err);\n+      } else {\n+        return nr.getReport(err.stack);\n+      }\n+    }\n+  };\n \n-    // Download the CLI / ENV config into JS land.\n-    nr.syncConfig(config, false);\n+  // Download the CLI / ENV config into JS land.\n+  nr.syncConfig(config, false);\n \n-    function handleSignal(signo) {\n-      if (typeof signo !== 'string')\n-        signo = config.signal;\n-      nr.onUserSignal(signo);\n-    }\n+  function handleSignal(signo) {\n+    if (typeof signo !== 'string')\n+      signo = config.signal;\n+    nr.onUserSignal(signo);\n+  }\n \n-    if (config.events.includes('signal')) {\n-      process.on(config.signal, handleSignal);\n-    }\n+  if (config.events.includes('signal')) {\n+    process.on(config.signal, handleSignal);\n+  }\n \n-    function parseOptions(obj) {\n-      const list = [];\n-      if (obj == null)\n-        return list;\n-      if (obj.events != null)\n-        list.push(REPORTEVENTS);\n-      if (obj.signal != null)\n-        list.push(REPORTSIGNAL);\n-      if (obj.filename != null)\n-        list.push(REPORTFILENAME);\n-      if (obj.path != null)\n-        list.push(REPORTPATH);\n-      if (obj.verbose != null)\n-        list.push(REPORTVERBOSE);\n+  function parseOptions(obj) {\n+    const list = [];\n+    if (obj == null)\n       return list;\n-    }\n-    process.report = report;\n+    if (obj.events != null)\n+      list.push(REPORTEVENTS);\n+    if (obj.signal != null)\n+      list.push(REPORTSIGNAL);\n+    if (obj.filename != null)\n+      list.push(REPORTFILENAME);\n+    if (obj.path != null)\n+      list.push(REPORTPATH);\n+    if (obj.verbose != null)\n+      list.push(REPORTVERBOSE);\n+    return list;\n   }\n+  process.report = report;\n };"
        },
        {
            "sha": "65ad48f349eebdb3c9f998a5a63d45950aca83a9",
            "filename": "src/node_config.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/3260a4aa87004ea39fca3f3d56bbe2f7b90dd662/src%2Fnode_config.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3260a4aa87004ea39fca3f3d56bbe2f7b90dd662/src%2Fnode_config.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_config.cc?ref=3260a4aa87004ea39fca3f3d56bbe2f7b90dd662",
            "patch": "@@ -69,10 +69,6 @@ static void Initialize(Local<Object> target,\n \n #endif  // NODE_HAVE_I18N_SUPPORT\n \n-#if defined(NODE_REPORT)\n-  READONLY_TRUE_PROPERTY(target, \"hasReport\");\n-#endif  //  NODE_REPORT\n-\n   if (env->abort_on_uncaught_exception())\n     READONLY_TRUE_PROPERTY(target, \"shouldAbortOnUncaughtException\");\n "
        }
    ],
    "stats": {
        "total": 269,
        "additions": 132,
        "deletions": 137
    }
}