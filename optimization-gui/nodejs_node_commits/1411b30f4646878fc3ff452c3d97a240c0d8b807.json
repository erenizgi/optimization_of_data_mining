{
    "author": "BridgeAR",
    "message": "buffer: move c++ float functions to js\n\nThis ports the Buffer#write(Double|Float)(B|L)E functions to JS.\nThis fixes a security issue concerning type confusion and fixes\nanother possible crash in combination with `noAssert`.\nIn addition to that it will also significantly improve the write\nperformance.\n\nFixes: https://github.com/nodejs/node/issues/12179\nFixes: https://github.com/nodejs/node/issues/8724\n\nPR-URL: https://github.com/nodejs/node/pull/18395\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "1411b30f4646878fc3ff452c3d97a240c0d8b807",
    "files": [
        {
            "sha": "f36bd76acdcc2e20211341a284e4884808a61434",
            "filename": "lib/buffer.js",
            "status": "modified",
            "additions": 74,
            "deletions": 34,
            "changes": 108,
            "blob_url": "https://github.com/nodejs/node/blob/1411b30f4646878fc3ff452c3d97a240c0d8b807/lib%2Fbuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/1411b30f4646878fc3ff452c3d97a240c0d8b807/lib%2Fbuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fbuffer.js?ref=1411b30f4646878fc3ff452c3d97a240c0d8b807",
            "patch": "@@ -34,10 +34,6 @@ const {\n   swap16: _swap16,\n   swap32: _swap32,\n   swap64: _swap64,\n-  writeDoubleBE: _writeDoubleBE,\n-  writeDoubleLE: _writeDoubleLE,\n-  writeFloatBE: _writeFloatBE,\n-  writeFloatLE: _writeFloatLE,\n   kMaxLength,\n   kStringMaxLength\n } = process.binding('buffer');\n@@ -85,6 +81,12 @@ const constants = Object.defineProperties({}, {\n   }\n });\n \n+// Temporary buffers to convert numbers.\n+const float32Array = new Float32Array(1);\n+const uInt8Float32Array = new Uint8Array(float32Array.buffer);\n+const float64Array = new Float64Array(1);\n+const uInt8Float64Array = new Uint8Array(float64Array.buffer);\n+\n Buffer.poolSize = 8 * 1024;\n var poolSize, poolOffset, allocPool;\n \n@@ -1297,12 +1299,16 @@ Buffer.prototype.readFloatLE = function(offset, noAssert) {\n   return toFloat(this.readUInt32LE(offset, noAssert));\n };\n \n+function checkOOB(buffer, offset, ext) {\n+  if (offset + ext > buffer.length)\n+    throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n+}\n+\n \n function checkInt(buffer, value, offset, ext, max, min) {\n   if (value > max || value < min)\n     throw new errors.RangeError('ERR_INVALID_OPT_VALUE', 'value', value);\n-  if (offset + ext > buffer.length)\n-    throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n+  checkOOB(buffer, offset, ext);\n }\n \n \n@@ -1520,49 +1526,83 @@ Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n   return offset + 4;\n };\n \n-\n-Buffer.prototype.writeFloatLE = function writeFloatLE(val, offset, noAssert) {\n+function writeDoubleForwards(val, offset, noAssert) {\n   val = +val;\n   offset = offset >>> 0;\n   if (!noAssert)\n-    _writeFloatLE(this, val, offset);\n-  else\n-    _writeFloatLE(this, val, offset, true);\n-  return offset + 4;\n-};\n-\n+    checkOOB(this, offset, 8);\n+\n+  float64Array[0] = val;\n+  this[offset++] = uInt8Float64Array[0];\n+  this[offset++] = uInt8Float64Array[1];\n+  this[offset++] = uInt8Float64Array[2];\n+  this[offset++] = uInt8Float64Array[3];\n+  this[offset++] = uInt8Float64Array[4];\n+  this[offset++] = uInt8Float64Array[5];\n+  this[offset++] = uInt8Float64Array[6];\n+  this[offset++] = uInt8Float64Array[7];\n+  return offset;\n+}\n \n-Buffer.prototype.writeFloatBE = function writeFloatBE(val, offset, noAssert) {\n+function writeDoubleBackwards(val, offset, noAssert) {\n   val = +val;\n   offset = offset >>> 0;\n   if (!noAssert)\n-    _writeFloatBE(this, val, offset);\n-  else\n-    _writeFloatBE(this, val, offset, true);\n-  return offset + 4;\n-};\n-\n+    checkOOB(this, offset, 8);\n+\n+  float64Array[0] = val;\n+  this[offset++] = uInt8Float64Array[7];\n+  this[offset++] = uInt8Float64Array[6];\n+  this[offset++] = uInt8Float64Array[5];\n+  this[offset++] = uInt8Float64Array[4];\n+  this[offset++] = uInt8Float64Array[3];\n+  this[offset++] = uInt8Float64Array[2];\n+  this[offset++] = uInt8Float64Array[1];\n+  this[offset++] = uInt8Float64Array[0];\n+  return offset;\n+}\n \n-Buffer.prototype.writeDoubleLE = function writeDoubleLE(val, offset, noAssert) {\n+function writeFloatForwards(val, offset, noAssert) {\n   val = +val;\n   offset = offset >>> 0;\n   if (!noAssert)\n-    _writeDoubleLE(this, val, offset);\n-  else\n-    _writeDoubleLE(this, val, offset, true);\n-  return offset + 8;\n-};\n-\n+    checkOOB(this, offset, 4);\n+\n+  float32Array[0] = val;\n+  this[offset++] = uInt8Float32Array[0];\n+  this[offset++] = uInt8Float32Array[1];\n+  this[offset++] = uInt8Float32Array[2];\n+  this[offset++] = uInt8Float32Array[3];\n+  return offset;\n+}\n \n-Buffer.prototype.writeDoubleBE = function writeDoubleBE(val, offset, noAssert) {\n+function writeFloatBackwards(val, offset, noAssert) {\n   val = +val;\n   offset = offset >>> 0;\n   if (!noAssert)\n-    _writeDoubleBE(this, val, offset);\n-  else\n-    _writeDoubleBE(this, val, offset, true);\n-  return offset + 8;\n-};\n+    checkOOB(this, offset, 4);\n+\n+  float32Array[0] = val;\n+  this[offset++] = uInt8Float32Array[3];\n+  this[offset++] = uInt8Float32Array[2];\n+  this[offset++] = uInt8Float32Array[1];\n+  this[offset++] = uInt8Float32Array[0];\n+  return offset;\n+}\n+\n+// Check endianness.\n+float32Array[0] = -1;\n+if (uInt8Float32Array[3] === 0) { // Big endian.\n+  Buffer.prototype.writeFloatLE = writeFloatBackwards;\n+  Buffer.prototype.writeFloatBE = writeFloatForwards;\n+  Buffer.prototype.writeDoubleLE = writeDoubleBackwards;\n+  Buffer.prototype.writeDoubleBE = writeDoubleForwards;\n+} else { // Small endian.\n+  Buffer.prototype.writeFloatLE = writeFloatForwards;\n+  Buffer.prototype.writeFloatBE = writeFloatBackwards;\n+  Buffer.prototype.writeDoubleLE = writeDoubleForwards;\n+  Buffer.prototype.writeDoubleBE = writeDoubleBackwards;\n+}\n \n function swap(b, n, m) {\n   const i = b[n];"
        },
        {
            "sha": "c25fe11b5a4c6ad0ed675283f6c31f674cbce90c",
            "filename": "src/node_buffer.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 95,
            "changes": 97,
            "blob_url": "https://github.com/nodejs/node/blob/1411b30f4646878fc3ff452c3d97a240c0d8b807/src%2Fnode_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1411b30f4646878fc3ff452c3d97a240c0d8b807/src%2Fnode_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.cc?ref=1411b30f4646878fc3ff452c3d97a240c0d8b807",
            "patch": "@@ -163,8 +163,7 @@ void CallbackInfo::WeakCallback(Isolate* isolate) {\n // Parse index for external array data.\n inline MUST_USE_RESULT bool ParseArrayIndex(Local<Value> arg,\n                                             size_t def,\n-                                            size_t* ret,\n-                                            size_t needed = 0) {\n+                                            size_t* ret) {\n   if (arg->IsUndefined()) {\n     *ret = def;\n     return true;\n@@ -178,7 +177,7 @@ inline MUST_USE_RESULT bool ParseArrayIndex(Local<Value> arg,\n   // Check that the result fits in a size_t.\n   const uint64_t kSizeMax = static_cast<uint64_t>(static_cast<size_t>(-1));\n   // coverity[pointless_expression]\n-  if (static_cast<uint64_t>(tmp_i) > kSizeMax - needed)\n+  if (static_cast<uint64_t>(tmp_i) > kSizeMax)\n     return false;\n \n   *ret = static_cast<size_t>(tmp_i);\n@@ -686,93 +685,6 @@ void StringWrite(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(written);\n }\n \n-\n-static inline void Swizzle(char* start, unsigned int len) {\n-  char* end = start + len - 1;\n-  while (start < end) {\n-    char tmp = *start;\n-    *start++ = *end;\n-    *end-- = tmp;\n-  }\n-}\n-\n-\n-template <typename T, enum Endianness endianness>\n-void WriteFloatGeneric(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  bool should_assert = args.Length() < 4;\n-\n-  if (should_assert) {\n-    THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);\n-  }\n-\n-  Local<ArrayBufferView> ts_obj = args[0].As<ArrayBufferView>();\n-  ArrayBuffer::Contents ts_obj_c = ts_obj->Buffer()->GetContents();\n-  const size_t ts_obj_offset = ts_obj->ByteOffset();\n-  const size_t ts_obj_length = ts_obj->ByteLength();\n-  char* const ts_obj_data =\n-      static_cast<char*>(ts_obj_c.Data()) + ts_obj_offset;\n-  if (ts_obj_length > 0)\n-    CHECK_NE(ts_obj_data, nullptr);\n-\n-  T val = args[1]->NumberValue(env->context()).FromMaybe(0);\n-\n-  size_t memcpy_num = sizeof(T);\n-  size_t offset;\n-\n-  // If the offset is negative or larger than the size of the ArrayBuffer,\n-  // throw an error (if needed) and return directly.\n-  if (!ParseArrayIndex(args[2], 0, &offset, memcpy_num) ||\n-      offset >= ts_obj_length) {\n-    if (should_assert)\n-      THROW_AND_RETURN_IF_OOB(false);\n-    return;\n-  }\n-\n-  // If the offset is too large for the entire value, but small enough to fit\n-  // part of the value, throw an error and return only if should_assert is\n-  // true. Otherwise, write the part of the value that fits.\n-  if (offset + memcpy_num > ts_obj_length) {\n-    if (should_assert)\n-      THROW_AND_RETURN_IF_OOB(false);\n-    else\n-      memcpy_num = ts_obj_length - offset;\n-  }\n-\n-  union NoAlias {\n-    T val;\n-    char bytes[sizeof(T)];\n-  };\n-\n-  union NoAlias na = { val };\n-  char* ptr = static_cast<char*>(ts_obj_data) + offset;\n-  if (endianness != GetEndianness())\n-    Swizzle(na.bytes, sizeof(na.bytes));\n-  memcpy(ptr, na.bytes, memcpy_num);\n-}\n-\n-\n-void WriteFloatLE(const FunctionCallbackInfo<Value>& args) {\n-  WriteFloatGeneric<float, kLittleEndian>(args);\n-}\n-\n-\n-void WriteFloatBE(const FunctionCallbackInfo<Value>& args) {\n-  WriteFloatGeneric<float, kBigEndian>(args);\n-}\n-\n-\n-void WriteDoubleLE(const FunctionCallbackInfo<Value>& args) {\n-  WriteFloatGeneric<double, kLittleEndian>(args);\n-}\n-\n-\n-void WriteDoubleBE(const FunctionCallbackInfo<Value>& args) {\n-  WriteFloatGeneric<double, kBigEndian>(args);\n-}\n-\n-\n void ByteLengthUtf8(const FunctionCallbackInfo<Value> &args) {\n   CHECK(args[0]->IsString());\n \n@@ -1211,11 +1123,6 @@ void Initialize(Local<Object> target,\n   env->SetMethod(target, \"indexOfNumber\", IndexOfNumber);\n   env->SetMethod(target, \"indexOfString\", IndexOfString);\n \n-  env->SetMethod(target, \"writeDoubleBE\", WriteDoubleBE);\n-  env->SetMethod(target, \"writeDoubleLE\", WriteDoubleLE);\n-  env->SetMethod(target, \"writeFloatBE\", WriteFloatBE);\n-  env->SetMethod(target, \"writeFloatLE\", WriteFloatLE);\n-\n   env->SetMethod(target, \"swap16\", Swap16);\n   env->SetMethod(target, \"swap32\", Swap32);\n   env->SetMethod(target, \"swap64\", Swap64);"
        },
        {
            "sha": "a521e01129a09442a79762c222149f89b0f36be2",
            "filename": "test/parallel/test-buffer-write-noassert.js",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/1411b30f4646878fc3ff452c3d97a240c0d8b807/test%2Fparallel%2Ftest-buffer-write-noassert.js",
            "raw_url": "https://github.com/nodejs/node/raw/1411b30f4646878fc3ff452c3d97a240c0d8b807/test%2Fparallel%2Ftest-buffer-write-noassert.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-write-noassert.js?ref=1411b30f4646878fc3ff452c3d97a240c0d8b807",
            "patch": "@@ -16,13 +16,6 @@ function write(funx, args, result, res) {\n   writeInvalidOffset(-1);\n   writeInvalidOffset(9);\n \n-  if (!/Int/.test(funx)) {\n-    assert.throws(\n-      () => Buffer.alloc(9)[funx].apply(new Map(), args),\n-      /^TypeError: argument should be a Buffer$/\n-    );\n-  }\n-\n   {\n     const buf2 = Buffer.alloc(9);\n     assert.strictEqual(buf2[funx](...args, true), result);"
        }
    ],
    "stats": {
        "total": 212,
        "additions": 76,
        "deletions": 136
    }
}