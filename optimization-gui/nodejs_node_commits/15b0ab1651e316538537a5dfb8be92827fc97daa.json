{
    "author": "addaleax",
    "message": "src: add debug check for inspector uv_async_t\n\nAdd a check to make sure start_io_thread_async is not\naccidentally re-used or used when uninitialized.\n(This is a bit of an odd check imo, but it helped me figure\nout a real issue and it might do so again, soâ€¦ why not?)\n\nPR-URL: https://github.com/nodejs/node/pull/25777\nReviewed-By: Eugene Ostroukhov <eostroukhov@google.com>\nReviewed-By: Minwoo Jung <minwoo@nodesource.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "15b0ab1651e316538537a5dfb8be92827fc97daa",
    "files": [
        {
            "sha": "fb85a54408e19cff437c0361957bf74146af7dbd",
            "filename": "src/inspector_agent.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/15b0ab1651e316538537a5dfb8be92827fc97daa/src%2Finspector_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/15b0ab1651e316538537a5dfb8be92827fc97daa/src%2Finspector_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.cc?ref=15b0ab1651e316538537a5dfb8be92827fc97daa",
            "patch": "@@ -51,6 +51,9 @@ using v8_inspector::V8InspectorClient;\n \n static uv_sem_t start_io_thread_semaphore;\n static uv_async_t start_io_thread_async;\n+// This is just an additional check to make sure start_io_thread_async\n+// is not accidentally re-used or used when uninitialized.\n+static std::atomic_bool start_io_thread_async_initialized { false };\n \n class StartIoTask : public Task {\n  public:\n@@ -88,6 +91,7 @@ static void StartIoThreadWakeup(int signo) {\n inline void* StartIoThreadMain(void* unused) {\n   for (;;) {\n     uv_sem_wait(&start_io_thread_semaphore);\n+    CHECK(start_io_thread_async_initialized);\n     Agent* agent = static_cast<Agent*>(start_io_thread_async.data);\n     if (agent != nullptr)\n       agent->RequestIoThreadStart();\n@@ -141,6 +145,7 @@ static int StartDebugSignalHandler() {\n \n #ifdef _WIN32\n DWORD WINAPI StartIoThreadProc(void* arg) {\n+  CHECK(start_io_thread_async_initialized);\n   Agent* agent = static_cast<Agent*>(start_io_thread_async.data);\n   if (agent != nullptr)\n     agent->RequestIoThreadStart();\n@@ -664,6 +669,7 @@ Agent::Agent(Environment* env)\n \n Agent::~Agent() {\n   if (start_io_thread_async.data == this) {\n+    CHECK(start_io_thread_async_initialized.exchange(false));\n     start_io_thread_async.data = nullptr;\n     // This is global, will never get freed\n     uv_close(reinterpret_cast<uv_handle_t*>(&start_io_thread_async), nullptr);\n@@ -681,6 +687,7 @@ bool Agent::Start(const std::string& path,\n \n   client_ = std::make_shared<NodeInspectorClient>(parent_env_, is_main);\n   if (parent_env_->is_main_thread()) {\n+    CHECK_EQ(start_io_thread_async_initialized.exchange(true), false);\n     CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),\n                               &start_io_thread_async,\n                               StartIoThreadAsyncCallback));\n@@ -847,13 +854,15 @@ void Agent::RequestIoThreadStart() {\n   // We need to attempt to interrupt V8 flow (in case Node is running\n   // continuous JS code) and to wake up libuv thread (in case Node is waiting\n   // for IO events)\n+  CHECK(start_io_thread_async_initialized);\n   uv_async_send(&start_io_thread_async);\n   Isolate* isolate = parent_env_->isolate();\n   v8::Platform* platform = parent_env_->isolate_data()->platform();\n   std::shared_ptr<TaskRunner> taskrunner =\n     platform->GetForegroundTaskRunner(isolate);\n   taskrunner->PostTask(std::make_unique<StartIoTask>(this));\n   isolate->RequestInterrupt(StartIoInterrupt, this);\n+  CHECK(start_io_thread_async_initialized);\n   uv_async_send(&start_io_thread_async);\n }\n "
        }
    ],
    "stats": {
        "total": 9,
        "additions": 9,
        "deletions": 0
    }
}