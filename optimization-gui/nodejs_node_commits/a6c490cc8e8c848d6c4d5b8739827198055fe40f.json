{
    "author": "BridgeAR",
    "message": "buffer: remove double ln\n\nPR-URL: https://github.com/nodejs/node/pull/18395\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "a6c490cc8e8c848d6c4d5b8739827198055fe40f",
    "files": [
        {
            "sha": "220437f25d7534f89c420792d7a5c9cade244b9a",
            "filename": "lib/buffer.js",
            "status": "modified",
            "additions": 0,
            "deletions": 64,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/a6c490cc8e8c848d6c4d5b8739827198055fe40f/lib%2Fbuffer.js",
            "raw_url": "https://github.com/nodejs/node/raw/a6c490cc8e8c848d6c4d5b8739827198055fe40f/lib%2Fbuffer.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fbuffer.js?ref=a6c490cc8e8c848d6c4d5b8739827198055fe40f",
            "patch": "@@ -90,7 +90,6 @@ const uInt8Float64Array = new Uint8Array(float64Array.buffer);\n Buffer.poolSize = 8 * 1024;\n var poolSize, poolOffset, allocPool;\n \n-\n setupBufferJS(Buffer.prototype, bindingObj);\n \n // |zeroFill| can be undefined when running inside an isolate where we\n@@ -117,7 +116,6 @@ function createPool() {\n }\n createPool();\n \n-\n function alignPool() {\n   // Ensure aligned slices\n   if (poolOffset & 0x7) {\n@@ -294,7 +292,6 @@ function SlowBuffer(length) {\n Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);\n Object.setPrototypeOf(SlowBuffer, Uint8Array);\n \n-\n function allocate(size) {\n   if (size <= 0) {\n     return new FastBuffer();\n@@ -311,7 +308,6 @@ function allocate(size) {\n   }\n }\n \n-\n function fromString(string, encoding) {\n   var length;\n   if (typeof encoding !== 'string' || encoding.length === 0) {\n@@ -405,14 +401,12 @@ function fromObject(obj) {\n   }\n }\n \n-\n // Static methods\n \n Buffer.isBuffer = function isBuffer(b) {\n   return b instanceof Buffer;\n };\n \n-\n Buffer.compare = function compare(a, b) {\n   if (!isUint8Array(a) || !isUint8Array(b)) {\n     throw new errors.TypeError(\n@@ -427,7 +421,6 @@ Buffer.compare = function compare(a, b) {\n   return _compare(a, b);\n };\n \n-\n Buffer.isEncoding = function isEncoding(encoding) {\n   return typeof encoding === 'string' && encoding.length !== 0 &&\n          normalizeEncoding(encoding) !== undefined;\n@@ -477,7 +470,6 @@ Buffer.concat = function concat(list, length) {\n   return buffer;\n };\n \n-\n function base64ByteLength(str, bytes) {\n   // Handle padding\n   if (str.charCodeAt(bytes - 1) === 0x3D)\n@@ -489,7 +481,6 @@ function base64ByteLength(str, bytes) {\n   return (bytes * 3) >>> 2;\n }\n \n-\n function byteLength(string, encoding) {\n   if (typeof string !== 'string') {\n     if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n@@ -553,7 +544,6 @@ function byteLength(string, encoding) {\n \n Buffer.byteLength = byteLength;\n \n-\n // For backwards compatibility.\n Object.defineProperty(Buffer.prototype, 'parent', {\n   enumerable: true,\n@@ -572,7 +562,6 @@ Object.defineProperty(Buffer.prototype, 'offset', {\n   }\n });\n \n-\n function stringSlice(buf, encoding, start, end) {\n   if (encoding === undefined) return buf.utf8Slice(start, end);\n   encoding += '';\n@@ -618,7 +607,6 @@ function stringSlice(buf, encoding, start, end) {\n   throw new errors.TypeError('ERR_UNKNOWN_ENCODING', encoding);\n }\n \n-\n Buffer.prototype.copy =\n   function copy(target, targetStart, sourceStart, sourceEnd) {\n     return _copy(this, target, targetStart, sourceStart, sourceEnd);\n@@ -655,7 +643,6 @@ Buffer.prototype.toString = function toString(encoding, start, end) {\n   return stringSlice(this, encoding, start, end);\n };\n \n-\n Buffer.prototype.equals = function equals(b) {\n   if (!isUint8Array(b)) {\n     throw new errors.TypeError(\n@@ -669,7 +656,6 @@ Buffer.prototype.equals = function equals(b) {\n   return _compare(this, b) === 0;\n };\n \n-\n // Override how buffers are presented by util.inspect().\n Buffer.prototype[customInspectSymbol] = function inspect() {\n   var str = '';\n@@ -731,7 +717,6 @@ Buffer.prototype.compare = function compare(target,\n   return compareOffset(this, target, start, thisStart, end, thisEnd);\n };\n \n-\n // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n //\n@@ -775,7 +760,6 @@ function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n   );\n }\n \n-\n function slowIndexOf(buffer, val, byteOffset, encoding, dir) {\n   var loweredCase = false;\n   for (;;) {\n@@ -807,22 +791,18 @@ function slowIndexOf(buffer, val, byteOffset, encoding, dir) {\n   }\n }\n \n-\n Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n   return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n };\n \n-\n Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n   return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n };\n \n-\n Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n   return this.indexOf(val, byteOffset, encoding) !== -1;\n };\n \n-\n // Usage:\n //    buffer.fill(number[, offset[, end]])\n //    buffer.fill(buffer[, offset[, end]])\n@@ -898,7 +878,6 @@ function _fill(buf, val, start, end, encoding) {\n   return buf;\n }\n \n-\n Buffer.prototype.write = function write(string, offset, length, encoding) {\n   // Buffer#write(string);\n   if (offset === undefined) {\n@@ -983,7 +962,6 @@ Buffer.prototype.write = function write(string, offset, length, encoding) {\n   throw new errors.TypeError('ERR_UNKNOWN_ENCODING', encoding);\n };\n \n-\n Buffer.prototype.toJSON = function toJSON() {\n   if (this.length > 0) {\n     const data = new Array(this.length);\n@@ -995,7 +973,6 @@ Buffer.prototype.toJSON = function toJSON() {\n   }\n };\n \n-\n function adjustOffset(offset, length) {\n   // Use Math.trunc() to convert offset to an integer value that can be larger\n   // than an Int32. Hence, don't use offset | 0 or similar techniques.\n@@ -1013,7 +990,6 @@ function adjustOffset(offset, length) {\n   return Number.isNaN(offset) ? 0 : length;\n }\n \n-\n Buffer.prototype.slice = function slice(start, end) {\n   const srcLength = this.length;\n   start = adjustOffset(start, srcLength);\n@@ -1022,7 +998,6 @@ Buffer.prototype.slice = function slice(start, end) {\n   return new FastBuffer(this.buffer, this.byteOffset + start, newLength);\n };\n \n-\n function checkOffset(offset, ext, length) {\n   if (offset + ext > length)\n     throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n@@ -1036,7 +1011,6 @@ function checkByteLength(byteLength) {\n   }\n }\n \n-\n Buffer.prototype.readUIntLE =\n   function readUIntLE(offset, byteLength, noAssert) {\n     offset = offset >>> 0;\n@@ -1055,7 +1029,6 @@ Buffer.prototype.readUIntLE =\n     return val;\n   };\n \n-\n Buffer.prototype.readUIntBE =\n   function readUIntBE(offset, byteLength, noAssert) {\n     offset = offset >>> 0;\n@@ -1073,31 +1046,27 @@ Buffer.prototype.readUIntBE =\n     return val;\n   };\n \n-\n Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n     checkOffset(offset, 1, this.length);\n   return this[offset];\n };\n \n-\n Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n     checkOffset(offset, 2, this.length);\n   return this[offset] | (this[offset + 1] << 8);\n };\n \n-\n Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n     checkOffset(offset, 2, this.length);\n   return (this[offset] << 8) | this[offset + 1];\n };\n \n-\n Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n@@ -1109,7 +1078,6 @@ Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n       (this[offset + 3] * 0x1000000);\n };\n \n-\n Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n@@ -1121,7 +1089,6 @@ Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n       this[offset + 3]);\n };\n \n-\n Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n   offset = offset >>> 0;\n   byteLength = byteLength >>> 0;\n@@ -1144,7 +1111,6 @@ Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n   return val;\n };\n \n-\n Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n   offset = offset >>> 0;\n   byteLength = byteLength >>> 0;\n@@ -1167,7 +1133,6 @@ Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n   return val;\n };\n \n-\n Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n@@ -1176,7 +1141,6 @@ Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n   return !(val & 0x80) ? val : (0xff - val + 1) * -1;\n };\n \n-\n Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n@@ -1185,7 +1149,6 @@ Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n   return (val & 0x8000) ? val | 0xFFFF0000 : val;\n };\n \n-\n Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n@@ -1194,7 +1157,6 @@ Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n   return (val & 0x8000) ? val | 0xFFFF0000 : val;\n };\n \n-\n Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n@@ -1206,7 +1168,6 @@ Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n       (this[offset + 3] << 24);\n };\n \n-\n Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n   offset = offset >>> 0;\n   if (!noAssert)\n@@ -1218,7 +1179,6 @@ Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n       (this[offset + 3]);\n };\n \n-\n // For the casual reader who has not at the current time memorized the\n // IEEE-754 standard in full detail: floating point numbers consist of\n // a fraction, an exponent and a sign bit: 23+8+1 bits for single precision\n@@ -1241,7 +1201,6 @@ Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n // precision that is not stored but is reconstructed by adding one after\n // multiplying the fraction with the result of 2**-bits_in_fraction.\n \n-\n function toDouble(x0, x1) {\n   const frac = x0 + 0x100000000 * (x1 & 0xFFFFF);\n   const expt = (x1 >>> 20) & 2047;\n@@ -1256,7 +1215,6 @@ function toDouble(x0, x1) {\n   return sign * 2 ** (expt - 1023) * (1 + frac * 2 ** -52);\n }\n \n-\n function toFloat(x) {\n   const frac = x & 0x7FFFFF;\n   const expt = (x >>> 23) & 255;\n@@ -1271,29 +1229,25 @@ function toFloat(x) {\n   return sign * 2 ** (expt - 127) * (1 + frac * 2 ** -23);\n }\n \n-\n Buffer.prototype.readDoubleBE = function(offset, noAssert) {\n   offset = offset >>> 0;\n   const x1 = this.readUInt32BE(offset + 0, noAssert);\n   const x0 = this.readUInt32BE(offset + 4, noAssert);\n   return toDouble(x0, x1);\n };\n \n-\n Buffer.prototype.readDoubleLE = function(offset, noAssert) {\n   offset = offset >>> 0;\n   const x0 = this.readUInt32LE(offset + 0, noAssert);\n   const x1 = this.readUInt32LE(offset + 4, noAssert);\n   return toDouble(x0, x1);\n };\n \n-\n Buffer.prototype.readFloatBE = function(offset, noAssert) {\n   offset = offset >>> 0;\n   return toFloat(this.readUInt32BE(offset, noAssert));\n };\n \n-\n Buffer.prototype.readFloatLE = function(offset, noAssert) {\n   offset = offset >>> 0;\n   return toFloat(this.readUInt32LE(offset, noAssert));\n@@ -1304,14 +1258,12 @@ function checkOOB(buffer, offset, ext) {\n     throw new errors.RangeError('ERR_INDEX_OUT_OF_RANGE');\n }\n \n-\n function checkInt(buffer, value, offset, ext, max, min) {\n   if (value > max || value < min)\n     throw new errors.RangeError('ERR_INVALID_OPT_VALUE', 'value', value);\n   checkOOB(buffer, offset, ext);\n }\n \n-\n Buffer.prototype.writeUIntLE =\n   function writeUIntLE(value, offset, byteLength, noAssert) {\n     value = +value;\n@@ -1331,7 +1283,6 @@ Buffer.prototype.writeUIntLE =\n     return offset + byteLength;\n   };\n \n-\n Buffer.prototype.writeUIntBE =\n   function writeUIntBE(value, offset, byteLength, noAssert) {\n     value = +value;\n@@ -1351,7 +1302,6 @@ Buffer.prototype.writeUIntBE =\n     return offset + byteLength;\n   };\n \n-\n Buffer.prototype.writeUInt8 =\n   function writeUInt8(value, offset, noAssert) {\n     value = +value;\n@@ -1362,7 +1312,6 @@ Buffer.prototype.writeUInt8 =\n     return offset + 1;\n   };\n \n-\n Buffer.prototype.writeUInt16LE =\n   function writeUInt16LE(value, offset, noAssert) {\n     value = +value;\n@@ -1374,7 +1323,6 @@ Buffer.prototype.writeUInt16LE =\n     return offset + 2;\n   };\n \n-\n Buffer.prototype.writeUInt16BE =\n   function writeUInt16BE(value, offset, noAssert) {\n     value = +value;\n@@ -1386,7 +1334,6 @@ Buffer.prototype.writeUInt16BE =\n     return offset + 2;\n   };\n \n-\n Buffer.prototype.writeUInt32LE =\n   function writeUInt32LE(value, offset, noAssert) {\n     value = +value;\n@@ -1400,7 +1347,6 @@ Buffer.prototype.writeUInt32LE =\n     return offset + 4;\n   };\n \n-\n Buffer.prototype.writeUInt32BE =\n   function writeUInt32BE(value, offset, noAssert) {\n     value = +value;\n@@ -1414,7 +1360,6 @@ Buffer.prototype.writeUInt32BE =\n     return offset + 4;\n   };\n \n-\n Buffer.prototype.writeIntLE =\n   function writeIntLE(value, offset, byteLength, noAssert) {\n     value = +value;\n@@ -1441,7 +1386,6 @@ Buffer.prototype.writeIntLE =\n     return offset + byteLength;\n   };\n \n-\n Buffer.prototype.writeIntBE =\n   function writeIntBE(value, offset, byteLength, noAssert) {\n     value = +value;\n@@ -1468,7 +1412,6 @@ Buffer.prototype.writeIntBE =\n     return offset + byteLength;\n   };\n \n-\n Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n   value = +value;\n   offset = offset >>> 0;\n@@ -1478,7 +1421,6 @@ Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n   return offset + 1;\n };\n \n-\n Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n   value = +value;\n   offset = offset >>> 0;\n@@ -1489,7 +1431,6 @@ Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n   return offset + 2;\n };\n \n-\n Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n   value = +value;\n   offset = offset >>> 0;\n@@ -1500,7 +1441,6 @@ Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n   return offset + 2;\n };\n \n-\n Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n   value = +value;\n   offset = offset >>> 0;\n@@ -1513,7 +1453,6 @@ Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n   return offset + 4;\n };\n \n-\n Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n   value = +value;\n   offset = offset >>> 0;\n@@ -1610,7 +1549,6 @@ function swap(b, n, m) {\n   b[m] = i;\n }\n \n-\n Buffer.prototype.swap16 = function swap16() {\n   // For Buffer.length < 128, it's generally faster to\n   // do the swap in javascript. For larger buffers,\n@@ -1626,7 +1564,6 @@ Buffer.prototype.swap16 = function swap16() {\n   return _swap16(this);\n };\n \n-\n Buffer.prototype.swap32 = function swap32() {\n   // For Buffer.length < 192, it's generally faster to\n   // do the swap in javascript. For larger buffers,\n@@ -1644,7 +1581,6 @@ Buffer.prototype.swap32 = function swap32() {\n   return _swap32(this);\n };\n \n-\n Buffer.prototype.swap64 = function swap64() {\n   // For Buffer.length < 192, it's generally faster to\n   // do the swap in javascript. For larger buffers,"
        }
    ],
    "stats": {
        "total": 64,
        "additions": 0,
        "deletions": 64
    }
}