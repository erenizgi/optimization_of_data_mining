{
    "author": "srl295",
    "message": "deps: icu 63.1 bump (CLDR 34)\n\n- Full release notes: http://site.icu-project.org/download/63\n\nFixes: https://github.com/nodejs/node/issues/22344\n\nPR-URL: https://github.com/nodejs/node/pull/23715\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>",
    "sha": "6786ff4d3688512d8b717ec24188818ac5493d0b",
    "files": [
        {
            "sha": "2ff8a36061cfad23e8be59869c65300c2da520fe",
            "filename": "deps/icu-small/README-SMALL-ICU.txt",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2FREADME-SMALL-ICU.txt",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2FREADME-SMALL-ICU.txt",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2FREADME-SMALL-ICU.txt?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1,8 +1,8 @@\n Small ICU sources - auto generated by shrink-icu-src.py\n \n This directory contains the ICU subset used by --with-intl=small-icu (the default)\n-It is a strict subset of ICU 62 source files with the following exception(s):\n-* deps/icu-small/source/data/in/icudt62l.dat : Reduced-size data file\n+It is a strict subset of ICU 63 source files with the following exception(s):\n+* deps/icu-small/source/data/in/icudt63l.dat : Reduced-size data file\n \n \n To rebuild this directory, see ../../tools/icu/README.md"
        },
        {
            "sha": "bc79f5e5a63be1cacf4b142acde01bd39bba633e",
            "filename": "deps/icu-small/source/common/bmpset.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fbmpset.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fbmpset.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbmpset.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -241,13 +241,13 @@ void BMPSet::overrideIllegal() {\n             bmpBlockBits[i]|=bits;\n         }\n \n-        mask=~(0x10001<<0xd);   // Lead byte 0xED.\n+        mask= static_cast<uint32_t>(~(0x10001<<0xd));   // Lead byte 0xED.\n         bits=1<<0xd;\n         for(i=32; i<64; ++i) {  // Second half of 4k block.\n             bmpBlockBits[i]=(bmpBlockBits[i]&mask)|bits;\n         }\n     } else {\n-        mask=~(0x10001<<0xd);   // Lead byte 0xED.\n+        mask= static_cast<uint32_t>(~(0x10001<<0xd));   // Lead byte 0xED.\n         for(i=32; i<64; ++i) {  // Second half of 4k block.\n             bmpBlockBits[i]&=mask;\n         }"
        },
        {
            "sha": "c64a845f87538e65ab4f5c67035f1c0f559b8c00",
            "filename": "deps/icu-small/source/common/bytesinkutil.cpp",
            "status": "modified",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -11,6 +11,7 @@\n #include \"unicode/utf8.h\"\n #include \"unicode/utf16.h\"\n #include \"bytesinkutil.h\"\n+#include \"charstr.h\"\n #include \"cmemory.h\"\n #include \"uassert.h\"\n \n@@ -120,4 +121,41 @@ ByteSinkUtil::appendUnchanged(const uint8_t *s, const uint8_t *limit,\n     return TRUE;\n }\n \n+CharStringByteSink::CharStringByteSink(CharString* dest) : dest_(*dest) {\n+}\n+\n+CharStringByteSink::~CharStringByteSink() = default;\n+\n+void\n+CharStringByteSink::Append(const char* bytes, int32_t n) {\n+    UErrorCode status = U_ZERO_ERROR;\n+    dest_.append(bytes, n, status);\n+    // Any errors are silently ignored.\n+}\n+\n+char*\n+CharStringByteSink::GetAppendBuffer(int32_t min_capacity,\n+                                    int32_t desired_capacity_hint,\n+                                    char* scratch,\n+                                    int32_t scratch_capacity,\n+                                    int32_t* result_capacity) {\n+    if (min_capacity < 1 || scratch_capacity < min_capacity) {\n+        *result_capacity = 0;\n+        return nullptr;\n+    }\n+\n+    UErrorCode status = U_ZERO_ERROR;\n+    char* result = dest_.getAppendBuffer(\n+            min_capacity,\n+            desired_capacity_hint,\n+            *result_capacity,\n+            status);\n+    if (U_SUCCESS(status)) {\n+        return result;\n+    }\n+\n+    *result_capacity = scratch_capacity;\n+    return scratch;\n+}\n+\n U_NAMESPACE_END"
        },
        {
            "sha": "69e4cbcd26393268582899ab09f292fdebc8005b",
            "filename": "deps/icu-small/source/common/bytesinkutil.h",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytesinkutil.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -13,6 +13,7 @@\n U_NAMESPACE_BEGIN\n \n class ByteSink;\n+class CharString;\n class Edits;\n \n class U_COMMON_API ByteSinkUtil {\n@@ -58,4 +59,25 @@ class U_COMMON_API ByteSinkUtil {\n                                         ByteSink &sink, uint32_t options, Edits *edits);\n };\n \n+class CharStringByteSink : public ByteSink {\n+public:\n+    CharStringByteSink(CharString* dest);\n+    ~CharStringByteSink() override;\n+\n+    CharStringByteSink() = delete;\n+    CharStringByteSink(const CharStringByteSink&) = delete;\n+    CharStringByteSink& operator=(const CharStringByteSink&) = delete;\n+\n+    void Append(const char* bytes, int32_t n) override;\n+\n+    char* GetAppendBuffer(int32_t min_capacity,\n+                          int32_t desired_capacity_hint,\n+                          char* scratch,\n+                          int32_t scratch_capacity,\n+                          int32_t* result_capacity) override;\n+\n+private:\n+    CharString& dest_;\n+};\n+\n U_NAMESPACE_END"
        },
        {
            "sha": "ec1ab7d8f5080e5af15799fa8636d3ab98b0ec73",
            "filename": "deps/icu-small/source/common/bytestriebuilder.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytestriebuilder.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytestriebuilder.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fbytestriebuilder.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -339,7 +339,8 @@ BytesTrieBuilder::indexOfElementWithNextUnit(int32_t i, int32_t byteIndex, UChar\n \n BytesTrieBuilder::BTLinearMatchNode::BTLinearMatchNode(const char *bytes, int32_t len, Node *nextNode)\n         : LinearMatchNode(len, nextNode), s(bytes) {\n-    hash=hash*37+ustr_hashCharsN(bytes, len);\n+    hash=static_cast<int32_t>(\n+        static_cast<uint32_t>(hash)*37u + static_cast<uint32_t>(ustr_hashCharsN(bytes, len)));\n }\n \n UBool"
        },
        {
            "sha": "3aff85b3f1193ef8a9ffd20349df171b3a554886",
            "filename": "deps/icu-small/source/common/characterproperties.cpp",
            "status": "added",
            "additions": 336,
            "deletions": 0,
            "changes": 336,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fcharacterproperties.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fcharacterproperties.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fcharacterproperties.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,336 @@\n+// Â© 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+// characterproperties.cpp\n+// created: 2018sep03 Markus W. Scherer\n+\n+#include \"unicode/utypes.h\"\n+#include \"unicode/localpointer.h\"\n+#include \"unicode/uchar.h\"\n+#include \"unicode/ucpmap.h\"\n+#include \"unicode/ucptrie.h\"\n+#include \"unicode/umutablecptrie.h\"\n+#include \"unicode/uniset.h\"\n+#include \"unicode/uscript.h\"\n+#include \"unicode/uset.h\"\n+#include \"cmemory.h\"\n+#include \"mutex.h\"\n+#include \"normalizer2impl.h\"\n+#include \"uassert.h\"\n+#include \"ubidi_props.h\"\n+#include \"ucase.h\"\n+#include \"ucln_cmn.h\"\n+#include \"umutex.h\"\n+#include \"uprops.h\"\n+\n+using icu::UInitOnce;\n+using icu::UnicodeSet;\n+\n+namespace {\n+\n+UBool U_CALLCONV characterproperties_cleanup();\n+\n+struct Inclusion {\n+    UnicodeSet  *fSet;\n+    UInitOnce    fInitOnce;\n+};\n+Inclusion gInclusions[UPROPS_SRC_COUNT]; // cached getInclusions()\n+\n+UnicodeSet *sets[UCHAR_BINARY_LIMIT] = {};\n+\n+UCPMap *maps[UCHAR_INT_LIMIT - UCHAR_INT_START] = {};\n+\n+UMutex cpMutex = U_MUTEX_INITIALIZER;\n+\n+//----------------------------------------------------------------\n+// Inclusions list\n+//----------------------------------------------------------------\n+\n+// USetAdder implementation\n+// Does not use uset.h to reduce code dependencies\n+void U_CALLCONV\n+_set_add(USet *set, UChar32 c) {\n+    ((UnicodeSet *)set)->add(c);\n+}\n+\n+void U_CALLCONV\n+_set_addRange(USet *set, UChar32 start, UChar32 end) {\n+    ((UnicodeSet *)set)->add(start, end);\n+}\n+\n+void U_CALLCONV\n+_set_addString(USet *set, const UChar *str, int32_t length) {\n+    ((UnicodeSet *)set)->add(icu::UnicodeString((UBool)(length<0), str, length));\n+}\n+\n+UBool U_CALLCONV characterproperties_cleanup() {\n+    for (Inclusion &in: gInclusions) {\n+        delete in.fSet;\n+        in.fSet = nullptr;\n+        in.fInitOnce.reset();\n+    }\n+    for (int32_t i = 0; i < UPRV_LENGTHOF(sets); ++i) {\n+        delete sets[i];\n+        sets[i] = nullptr;\n+    }\n+    for (int32_t i = 0; i < UPRV_LENGTHOF(maps); ++i) {\n+        ucptrie_close(reinterpret_cast<UCPTrie *>(maps[i]));\n+        maps[i] = nullptr;\n+    }\n+    return TRUE;\n+}\n+\n+}  // namespace\n+\n+U_NAMESPACE_BEGIN\n+\n+/*\n+Reduce excessive reallocation, and make it easier to detect initialization problems.\n+Usually you don't see smaller sets than this for Unicode 5.0.\n+*/\n+constexpr int32_t DEFAULT_INCLUSION_CAPACITY = 3072;\n+\n+void U_CALLCONV CharacterProperties::initInclusion(UPropertySource src, UErrorCode &errorCode) {\n+    // This function is invoked only via umtx_initOnce().\n+    // This function is a friend of class UnicodeSet.\n+\n+    U_ASSERT(0 <= src && src < UPROPS_SRC_COUNT);\n+    if (src == UPROPS_SRC_NONE) {\n+        errorCode = U_INTERNAL_PROGRAM_ERROR;\n+        return;\n+    }\n+    UnicodeSet * &incl = gInclusions[src].fSet;\n+    U_ASSERT(incl == nullptr);\n+\n+    incl = new UnicodeSet();\n+    if (incl == nullptr) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return;\n+    }\n+    USetAdder sa = {\n+        (USet *)incl,\n+        _set_add,\n+        _set_addRange,\n+        _set_addString,\n+        nullptr, // don't need remove()\n+        nullptr // don't need removeRange()\n+    };\n+\n+    incl->ensureCapacity(DEFAULT_INCLUSION_CAPACITY, errorCode);\n+    switch(src) {\n+    case UPROPS_SRC_CHAR:\n+        uchar_addPropertyStarts(&sa, &errorCode);\n+        break;\n+    case UPROPS_SRC_PROPSVEC:\n+        upropsvec_addPropertyStarts(&sa, &errorCode);\n+        break;\n+    case UPROPS_SRC_CHAR_AND_PROPSVEC:\n+        uchar_addPropertyStarts(&sa, &errorCode);\n+        upropsvec_addPropertyStarts(&sa, &errorCode);\n+        break;\n+#if !UCONFIG_NO_NORMALIZATION\n+    case UPROPS_SRC_CASE_AND_NORM: {\n+        const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(errorCode);\n+        if(U_SUCCESS(errorCode)) {\n+            impl->addPropertyStarts(&sa, errorCode);\n+        }\n+        ucase_addPropertyStarts(&sa, &errorCode);\n+        break;\n+    }\n+    case UPROPS_SRC_NFC: {\n+        const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(errorCode);\n+        if(U_SUCCESS(errorCode)) {\n+            impl->addPropertyStarts(&sa, errorCode);\n+        }\n+        break;\n+    }\n+    case UPROPS_SRC_NFKC: {\n+        const Normalizer2Impl *impl=Normalizer2Factory::getNFKCImpl(errorCode);\n+        if(U_SUCCESS(errorCode)) {\n+            impl->addPropertyStarts(&sa, errorCode);\n+        }\n+        break;\n+    }\n+    case UPROPS_SRC_NFKC_CF: {\n+        const Normalizer2Impl *impl=Normalizer2Factory::getNFKC_CFImpl(errorCode);\n+        if(U_SUCCESS(errorCode)) {\n+            impl->addPropertyStarts(&sa, errorCode);\n+        }\n+        break;\n+    }\n+    case UPROPS_SRC_NFC_CANON_ITER: {\n+        const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(errorCode);\n+        if(U_SUCCESS(errorCode)) {\n+            impl->addCanonIterPropertyStarts(&sa, errorCode);\n+        }\n+        break;\n+    }\n+#endif\n+    case UPROPS_SRC_CASE:\n+        ucase_addPropertyStarts(&sa, &errorCode);\n+        break;\n+    case UPROPS_SRC_BIDI:\n+        ubidi_addPropertyStarts(&sa, &errorCode);\n+        break;\n+    case UPROPS_SRC_INPC:\n+    case UPROPS_SRC_INSC:\n+    case UPROPS_SRC_VO:\n+        uprops_addPropertyStarts((UPropertySource)src, &sa, &errorCode);\n+        break;\n+    default:\n+        errorCode = U_INTERNAL_PROGRAM_ERROR;\n+        break;\n+    }\n+\n+    if (U_FAILURE(errorCode)) {\n+        delete incl;\n+        incl = nullptr;\n+        return;\n+    }\n+    // Compact for caching\n+    incl->compact();\n+    ucln_common_registerCleanup(UCLN_COMMON_CHARACTERPROPERTIES, characterproperties_cleanup);\n+}\n+\n+const UnicodeSet *getInclusionsForSource(UPropertySource src, UErrorCode &errorCode) {\n+    if (U_FAILURE(errorCode)) { return nullptr; }\n+    if (src < 0 || UPROPS_SRC_COUNT <= src) {\n+        errorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return nullptr;\n+    }\n+    Inclusion &i = gInclusions[src];\n+    umtx_initOnce(i.fInitOnce, &CharacterProperties::initInclusion, src, errorCode);\n+    return i.fSet;\n+}\n+\n+const UnicodeSet *CharacterProperties::getInclusionsForProperty(\n+        UProperty prop, UErrorCode &errorCode) {\n+    if (U_FAILURE(errorCode)) { return nullptr; }\n+    UPropertySource src = uprops_getSource(prop);\n+    return getInclusionsForSource(src, errorCode);\n+}\n+\n+U_NAMESPACE_END\n+\n+namespace {\n+\n+UnicodeSet *makeSet(UProperty property, UErrorCode &errorCode) {\n+    if (U_FAILURE(errorCode)) { return nullptr; }\n+    icu::LocalPointer<UnicodeSet> set(new UnicodeSet());\n+    if (set.isNull()) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return nullptr;\n+    }\n+    const UnicodeSet *inclusions =\n+        icu::CharacterProperties::getInclusionsForProperty(property, errorCode);\n+    if (U_FAILURE(errorCode)) { return nullptr; }\n+    int32_t numRanges = inclusions->getRangeCount();\n+    UChar32 startHasProperty = -1;\n+\n+    for (int32_t i = 0; i < numRanges; ++i) {\n+        UChar32 rangeEnd = inclusions->getRangeEnd(i);\n+        for (UChar32 c = inclusions->getRangeStart(i); c <= rangeEnd; ++c) {\n+            // TODO: Get a UCharacterProperty.BinaryProperty to avoid the property dispatch.\n+            if (u_hasBinaryProperty(c, property)) {\n+                if (startHasProperty < 0) {\n+                    // Transition from false to true.\n+                    startHasProperty = c;\n+                }\n+            } else if (startHasProperty >= 0) {\n+                // Transition from true to false.\n+                set->add(startHasProperty, c - 1);\n+                startHasProperty = -1;\n+            }\n+        }\n+    }\n+    if (startHasProperty >= 0) {\n+        set->add(startHasProperty, 0x10FFFF);\n+    }\n+    set->freeze();\n+    return set.orphan();\n+}\n+\n+UCPMap *makeMap(UProperty property, UErrorCode &errorCode) {\n+    if (U_FAILURE(errorCode)) { return nullptr; }\n+    uint32_t nullValue = property == UCHAR_SCRIPT ? USCRIPT_UNKNOWN : 0;\n+    icu::LocalUMutableCPTriePointer mutableTrie(\n+        umutablecptrie_open(nullValue, nullValue, &errorCode));\n+    const UnicodeSet *inclusions =\n+        icu::CharacterProperties::getInclusionsForProperty(property, errorCode);\n+    if (U_FAILURE(errorCode)) { return nullptr; }\n+    int32_t numRanges = inclusions->getRangeCount();\n+    UChar32 start = 0;\n+    uint32_t value = nullValue;\n+\n+    for (int32_t i = 0; i < numRanges; ++i) {\n+        UChar32 rangeEnd = inclusions->getRangeEnd(i);\n+        for (UChar32 c = inclusions->getRangeStart(i); c <= rangeEnd; ++c) {\n+            // TODO: Get a UCharacterProperty.IntProperty to avoid the property dispatch.\n+            uint32_t nextValue = u_getIntPropertyValue(c, property);\n+            if (value != nextValue) {\n+                if (value != nullValue) {\n+                    umutablecptrie_setRange(mutableTrie.getAlias(), start, c - 1, value, &errorCode);\n+                }\n+                start = c;\n+                value = nextValue;\n+            }\n+        }\n+    }\n+    if (value != 0) {\n+        umutablecptrie_setRange(mutableTrie.getAlias(), start, 0x10FFFF, value, &errorCode);\n+    }\n+\n+    UCPTrieType type;\n+    if (property == UCHAR_BIDI_CLASS || property == UCHAR_GENERAL_CATEGORY) {\n+        type = UCPTRIE_TYPE_FAST;\n+    } else {\n+        type = UCPTRIE_TYPE_SMALL;\n+    }\n+    UCPTrieValueWidth valueWidth;\n+    // TODO: UCharacterProperty.IntProperty\n+    int32_t max = u_getIntPropertyMaxValue(property);\n+    if (max <= 0xff) {\n+        valueWidth = UCPTRIE_VALUE_BITS_8;\n+    } else if (max <= 0xffff) {\n+        valueWidth = UCPTRIE_VALUE_BITS_16;\n+    } else {\n+        valueWidth = UCPTRIE_VALUE_BITS_32;\n+    }\n+    return reinterpret_cast<UCPMap *>(\n+        umutablecptrie_buildImmutable(mutableTrie.getAlias(), type, valueWidth, &errorCode));\n+}\n+\n+}  // namespace\n+\n+U_NAMESPACE_USE\n+\n+U_CAPI const USet * U_EXPORT2\n+u_getBinaryPropertySet(UProperty property, UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) { return nullptr; }\n+    if (property < 0 || UCHAR_BINARY_LIMIT <= property) {\n+        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return nullptr;\n+    }\n+    Mutex m(&cpMutex);\n+    UnicodeSet *set = sets[property];\n+    if (set == nullptr) {\n+        sets[property] = set = makeSet(property, *pErrorCode);\n+    }\n+    if (U_FAILURE(*pErrorCode)) { return nullptr; }\n+    return set->toUSet();\n+}\n+\n+U_CAPI const UCPMap * U_EXPORT2\n+u_getIntPropertyMap(UProperty property, UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) { return nullptr; }\n+    if (property < UCHAR_INT_START || UCHAR_INT_LIMIT <= property) {\n+        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return nullptr;\n+    }\n+    Mutex m(&cpMutex);\n+    UCPMap *map = maps[property - UCHAR_INT_START];\n+    if (map == nullptr) {\n+        maps[property - UCHAR_INT_START] = map = makeMap(property, *pErrorCode);\n+    }\n+    return map;\n+}"
        },
        {
            "sha": "852cc539457760546b4dfaf122edff0187e1cc88",
            "filename": "deps/icu-small/source/common/charstr.cpp",
            "status": "modified",
            "additions": 10,
            "deletions": 4,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fcharstr.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fcharstr.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fcharstr.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -79,7 +79,7 @@ CharString &CharString::append(const char *s, int32_t sLength, UErrorCode &error\n         return *this;\n     }\n     if(sLength<0) {\n-        sLength=uprv_strlen(s);\n+        sLength= static_cast<int32_t>(uprv_strlen(s));\n     }\n     if(sLength>0) {\n         if(s==(buffer.getAlias()+len)) {\n@@ -126,15 +126,21 @@ char *CharString::getAppendBuffer(int32_t minCapacity,\n }\n \n CharString &CharString::appendInvariantChars(const UnicodeString &s, UErrorCode &errorCode) {\n+    return appendInvariantChars(s.getBuffer(), s.length(), errorCode);\n+}\n+\n+CharString &CharString::appendInvariantChars(const UChar* uchars, int32_t ucharsLen, UErrorCode &errorCode) {\n     if(U_FAILURE(errorCode)) {\n         return *this;\n     }\n-    if (!uprv_isInvariantUnicodeString(s)) {\n+    if (!uprv_isInvariantUString(uchars, ucharsLen)) {\n         errorCode = U_INVARIANT_CONVERSION_ERROR;\n         return *this;\n     }\n-    if(ensureCapacity(len+s.length()+1, 0, errorCode)) {\n-        len+=s.extract(0, 0x7fffffff, buffer.getAlias()+len, buffer.getCapacity()-len, US_INV);\n+    if(ensureCapacity(len+ucharsLen+1, 0, errorCode)) {\n+        u_UCharsToChars(uchars, buffer.getAlias()+len, ucharsLen);\n+        len += ucharsLen;\n+        buffer[len] = 0;\n     }\n     return *this;\n }"
        },
        {
            "sha": "1a97e01988f991b869773488a5f9c5cd0734b880",
            "filename": "deps/icu-small/source/common/charstr.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fcharstr.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fcharstr.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fcharstr.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -123,6 +123,7 @@ class U_COMMON_API CharString : public UMemory {\n                           UErrorCode &errorCode);\n \n     CharString &appendInvariantChars(const UnicodeString &s, UErrorCode &errorCode);\n+    CharString &appendInvariantChars(const UChar* uchars, int32_t ucharsLen, UErrorCode& errorCode);\n \n     /**\n      * Appends a filename/path part, e.g., a directory name."
        },
        {
            "sha": "a6dd209d80b2f3a3200f8addf4fc42d520768204",
            "filename": "deps/icu-small/source/common/cmemory.h",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fcmemory.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fcmemory.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fcmemory.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -172,7 +172,7 @@ class LocalMemory : public LocalPointerBase<T> {\n      * @return *this\n      */\n     LocalMemory<T> &moveFrom(LocalMemory<T> &src) U_NOEXCEPT {\n-        delete[] LocalPointerBase<T>::ptr;\n+        uprv_free(LocalPointerBase<T>::ptr);\n         LocalPointerBase<T>::ptr=src.ptr;\n         src.ptr=NULL;\n         return *this;\n@@ -279,6 +279,10 @@ inline T *LocalMemory<T>::allocateInsteadAndCopy(int32_t newCapacity, int32_t le\n  *\n  * Unlike LocalMemory and LocalArray, this class never adopts\n  * (takes ownership of) another array.\n+ *\n+ * WARNING: MaybeStackArray only works with primitive (plain-old data) types.\n+ * It does NOT know how to call a destructor! If you work with classes with\n+ * destructors, consider LocalArray in localpointer.h.\n  */\n template<typename T, int32_t stackCapacity>\n class MaybeStackArray {"
        },
        {
            "sha": "0e4d0850fac9124e3838b435a290d3a16f639448",
            "filename": "deps/icu-small/source/common/dictbe.cpp",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fdictbe.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fdictbe.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fdictbe.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -325,9 +325,9 @@ ThaiBreakEngine::divideUpDictionaryRange( UText *text,\n                         // two characters after uc were not 0x0E4C THANTHAKHAT before\n                         // checking the dictionary. That is just a performance filter,\n                         // but it's not clear it's faster than checking the trie.\n-                        int32_t candidates = words[(wordsFound + 1) % THAI_LOOKAHEAD].candidates(text, fDictionary, rangeEnd);\n+                        int32_t num_candidates = words[(wordsFound + 1) % THAI_LOOKAHEAD].candidates(text, fDictionary, rangeEnd);\n                         utext_setNativeIndex(text, current + cuWordLength + chars);\n-                        if (candidates > 0) {\n+                        if (num_candidates > 0) {\n                             break;\n                         }\n                     }\n@@ -555,9 +555,9 @@ LaoBreakEngine::divideUpDictionaryRange( UText *text,\n                     if (fEndWordSet.contains(pc) && fBeginWordSet.contains(uc)) {\n                         // Maybe. See if it's in the dictionary.\n                         // TODO: this looks iffy; compare with old code.\n-                        int32_t candidates = words[(wordsFound + 1) % LAO_LOOKAHEAD].candidates(text, fDictionary, rangeEnd);\n+                        int32_t num_candidates = words[(wordsFound + 1) % LAO_LOOKAHEAD].candidates(text, fDictionary, rangeEnd);\n                         utext_setNativeIndex(text, current + cuWordLength + chars);\n-                        if (candidates > 0) {\n+                        if (num_candidates > 0) {\n                             break;\n                         }\n                     }\n@@ -748,9 +748,9 @@ BurmeseBreakEngine::divideUpDictionaryRange( UText *text,\n                     if (fEndWordSet.contains(pc) && fBeginWordSet.contains(uc)) {\n                         // Maybe. See if it's in the dictionary.\n                         // TODO: this looks iffy; compare with old code.\n-                        int32_t candidates = words[(wordsFound + 1) % BURMESE_LOOKAHEAD].candidates(text, fDictionary, rangeEnd);\n+                        int32_t num_candidates = words[(wordsFound + 1) % BURMESE_LOOKAHEAD].candidates(text, fDictionary, rangeEnd);\n                         utext_setNativeIndex(text, current + cuWordLength + chars);\n-                        if (candidates > 0) {\n+                        if (num_candidates > 0) {\n                             break;\n                         }\n                     }\n@@ -953,9 +953,9 @@ KhmerBreakEngine::divideUpDictionaryRange( UText *text,\n                     uc = utext_current32(text);\n                     if (fEndWordSet.contains(pc) && fBeginWordSet.contains(uc)) {\n                         // Maybe. See if it's in the dictionary.\n-                        int32_t candidates = words[(wordsFound + 1) % KHMER_LOOKAHEAD].candidates(text, fDictionary, rangeEnd);\n+                        int32_t num_candidates = words[(wordsFound + 1) % KHMER_LOOKAHEAD].candidates(text, fDictionary, rangeEnd);\n                         utext_setNativeIndex(text, current+cuWordLength+chars);\n-                        if (candidates > 0) {\n+                        if (num_candidates > 0) {\n                             break;\n                         }\n                     }"
        },
        {
            "sha": "00a8d601a1cc80fbfcc46b7e1c677803e41511b8",
            "filename": "deps/icu-small/source/common/edits.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fedits.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fedits.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fedits.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -276,7 +276,7 @@ Edits &Edits::mergeAndAppend(const Edits &ab, const Edits &bc, UErrorCode &error\n         // ab deletions meet bc insertions at the same intermediate-string index.\n         // Some users expect the bc insertions to come first, so we fetch from bc first.\n         if (bc_bLength == 0) {\n-            if (bcHasNext && (bcHasNext = bcIter.next(errorCode))) {\n+            if (bcHasNext && (bcHasNext = bcIter.next(errorCode)) != 0) {\n                 bc_bLength = bcIter.oldLength();\n                 cLength = bcIter.newLength();\n                 if (bc_bLength == 0) {\n@@ -293,7 +293,7 @@ Edits &Edits::mergeAndAppend(const Edits &ab, const Edits &bc, UErrorCode &error\n             // else see if the other iterator is done, too.\n         }\n         if (ab_bLength == 0) {\n-            if (abHasNext && (abHasNext = abIter.next(errorCode))) {\n+            if (abHasNext && (abHasNext = abIter.next(errorCode)) != 0) {\n                 aLength = abIter.oldLength();\n                 ab_bLength = abIter.newLength();\n                 if (ab_bLength == 0) {"
        },
        {
            "sha": "82cb325b723311bb0515713e1b56201f3fa4e395",
            "filename": "deps/icu-small/source/common/loadednormalizer2impl.cpp",
            "status": "modified",
            "additions": 71,
            "deletions": 12,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Floadednormalizer2impl.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Floadednormalizer2impl.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Floadednormalizer2impl.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -18,6 +18,7 @@\n #include \"unicode/udata.h\"\n #include \"unicode/localpointer.h\"\n #include \"unicode/normalizer2.h\"\n+#include \"unicode/ucptrie.h\"\n #include \"unicode/unistr.h\"\n #include \"unicode/unorm.h\"\n #include \"cstring.h\"\n@@ -42,12 +43,12 @@ class LoadedNormalizer2Impl : public Normalizer2Impl {\n     isAcceptable(void *context, const char *type, const char *name, const UDataInfo *pInfo);\n \n     UDataMemory *memory;\n-    UTrie2 *ownedTrie;\n+    UCPTrie *ownedTrie;\n };\n \n LoadedNormalizer2Impl::~LoadedNormalizer2Impl() {\n     udata_close(memory);\n-    utrie2_close(ownedTrie);\n+    ucptrie_close(ownedTrie);\n }\n \n UBool U_CALLCONV\n@@ -62,7 +63,7 @@ LoadedNormalizer2Impl::isAcceptable(void * /*context*/,\n         pInfo->dataFormat[1]==0x72 &&\n         pInfo->dataFormat[2]==0x6d &&\n         pInfo->dataFormat[3]==0x32 &&\n-        pInfo->formatVersion[0]==3\n+        pInfo->formatVersion[0]==4\n     ) {\n         // Normalizer2Impl *me=(Normalizer2Impl *)context;\n         // uprv_memcpy(me->dataVersion, pInfo->dataVersion, 4);\n@@ -91,9 +92,9 @@ LoadedNormalizer2Impl::load(const char *packageName, const char *name, UErrorCod\n \n     int32_t offset=inIndexes[IX_NORM_TRIE_OFFSET];\n     int32_t nextOffset=inIndexes[IX_EXTRA_DATA_OFFSET];\n-    ownedTrie=utrie2_openFromSerialized(UTRIE2_16_VALUE_BITS,\n-                                        inBytes+offset, nextOffset-offset, NULL,\n-                                        &errorCode);\n+    ownedTrie=ucptrie_openFromBinary(UCPTRIE_TYPE_FAST, UCPTRIE_VALUE_BITS_16,\n+                                     inBytes+offset, nextOffset-offset, NULL,\n+                                     &errorCode);\n     if(U_FAILURE(errorCode)) {\n         return;\n     }\n@@ -131,15 +132,26 @@ U_CDECL_BEGIN\n static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup();\n U_CDECL_END\n \n-static Norm2AllModes *nfkcSingleton;\n-static Norm2AllModes *nfkc_cfSingleton;\n-static UHashtable    *cache=NULL;\n+#if !NORM2_HARDCODE_NFC_DATA\n+static Norm2AllModes *nfcSingleton;\n+static icu::UInitOnce nfcInitOnce = U_INITONCE_INITIALIZER;\n+#endif\n \n+static Norm2AllModes *nfkcSingleton;\n static icu::UInitOnce nfkcInitOnce = U_INITONCE_INITIALIZER;\n+\n+static Norm2AllModes *nfkc_cfSingleton;\n static icu::UInitOnce nfkc_cfInitOnce = U_INITONCE_INITIALIZER;\n \n+static UHashtable    *cache=NULL;\n+\n // UInitOnce singleton initialization function\n static void U_CALLCONV initSingletons(const char *what, UErrorCode &errorCode) {\n+#if !NORM2_HARDCODE_NFC_DATA\n+    if (uprv_strcmp(what, \"nfc\") == 0) {\n+        nfcSingleton    = Norm2AllModes::createInstance(NULL, \"nfc\", errorCode);\n+    } else\n+#endif\n     if (uprv_strcmp(what, \"nfkc\") == 0) {\n         nfkcSingleton    = Norm2AllModes::createInstance(NULL, \"nfkc\", errorCode);\n     } else if (uprv_strcmp(what, \"nfkc_cf\") == 0) {\n@@ -157,19 +169,36 @@ static void U_CALLCONV deleteNorm2AllModes(void *allModes) {\n }\n \n static UBool U_CALLCONV uprv_loaded_normalizer2_cleanup() {\n+#if !NORM2_HARDCODE_NFC_DATA\n+    delete nfcSingleton;\n+    nfcSingleton = NULL;\n+    nfcInitOnce.reset();\n+#endif\n+\n     delete nfkcSingleton;\n     nfkcSingleton = NULL;\n+    nfkcInitOnce.reset();\n+\n     delete nfkc_cfSingleton;\n     nfkc_cfSingleton = NULL;\n+    nfkc_cfInitOnce.reset();\n+\n     uhash_close(cache);\n     cache=NULL;\n-    nfkcInitOnce.reset();\n-    nfkc_cfInitOnce.reset();\n     return TRUE;\n }\n \n U_CDECL_END\n \n+#if !NORM2_HARDCODE_NFC_DATA\n+const Norm2AllModes *\n+Norm2AllModes::getNFCInstance(UErrorCode &errorCode) {\n+    if(U_FAILURE(errorCode)) { return NULL; }\n+    umtx_initOnce(nfcInitOnce, &initSingletons, \"nfc\", errorCode);\n+    return nfcSingleton;\n+}\n+#endif\n+\n const Norm2AllModes *\n Norm2AllModes::getNFKCInstance(UErrorCode &errorCode) {\n     if(U_FAILURE(errorCode)) { return NULL; }\n@@ -184,6 +213,36 @@ Norm2AllModes::getNFKC_CFInstance(UErrorCode &errorCode) {\n     return nfkc_cfSingleton;\n }\n \n+#if !NORM2_HARDCODE_NFC_DATA\n+const Normalizer2 *\n+Normalizer2::getNFCInstance(UErrorCode &errorCode) {\n+    const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);\n+    return allModes!=NULL ? &allModes->comp : NULL;\n+}\n+\n+const Normalizer2 *\n+Normalizer2::getNFDInstance(UErrorCode &errorCode) {\n+    const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);\n+    return allModes!=NULL ? &allModes->decomp : NULL;\n+}\n+\n+const Normalizer2 *Normalizer2Factory::getFCDInstance(UErrorCode &errorCode) {\n+    const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);\n+    return allModes!=NULL ? &allModes->fcd : NULL;\n+}\n+\n+const Normalizer2 *Normalizer2Factory::getFCCInstance(UErrorCode &errorCode) {\n+    const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);\n+    return allModes!=NULL ? &allModes->fcc : NULL;\n+}\n+\n+const Normalizer2Impl *\n+Normalizer2Factory::getNFCImpl(UErrorCode &errorCode) {\n+    const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);\n+    return allModes!=NULL ? allModes->impl : NULL;\n+}\n+#endif\n+\n const Normalizer2 *\n Normalizer2::getNFKCInstance(UErrorCode &errorCode) {\n     const Norm2AllModes *allModes=Norm2AllModes::getNFKCInstance(errorCode);\n@@ -247,7 +306,7 @@ Normalizer2::getInstance(const char *packageName,\n                 }\n                 void *temp=uhash_get(cache, name);\n                 if(temp==NULL) {\n-                    int32_t keyLength=uprv_strlen(name)+1;\n+                    int32_t keyLength= static_cast<int32_t>(uprv_strlen(name)+1);\n                     char *nameCopy=(char *)uprv_malloc(keyLength);\n                     if(nameCopy==NULL) {\n                         errorCode=U_MEMORY_ALLOCATION_ERROR;"
        },
        {
            "sha": "2d9389e910a2ab93c3de2b5d2acfe99d71fedf2c",
            "filename": "deps/icu-small/source/common/locdspnm.cpp",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Flocdspnm.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Flocdspnm.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Flocdspnm.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -45,9 +45,9 @@ static int32_t ncat(char *buffer, uint32_t buflen, ...) {\n   }\n \n   va_start(args, buflen);\n-  while ((str = va_arg(args, char *))) {\n+  while ((str = va_arg(args, char *)) != 0) {\n     char c;\n-    while (p != e && (c = *str++)) {\n+    while (p != e && (c = *str++) != 0) {\n       *p++ = c;\n     }\n   }\n@@ -98,7 +98,7 @@ ICUDataTable::ICUDataTable(const char* path, const Locale& locale)\n     : path(NULL), locale(Locale::getRoot())\n {\n   if (path) {\n-    int32_t len = uprv_strlen(path);\n+    int32_t len = static_cast<int32_t>(uprv_strlen(path));\n     this->path = (const char*) uprv_malloc(len + 1);\n     if (this->path) {\n       uprv_strcpy((char *)this->path, path);\n@@ -560,21 +560,21 @@ LocaleDisplayNamesImpl::adjustForUsageAndContext(CapContextUsage usage,\n }\n \n UnicodeString&\n-LocaleDisplayNamesImpl::localeDisplayName(const Locale& locale,\n+LocaleDisplayNamesImpl::localeDisplayName(const Locale& loc,\n                                           UnicodeString& result) const {\n-  if (locale.isBogus()) {\n+  if (loc.isBogus()) {\n     result.setToBogus();\n     return result;\n   }\n   UnicodeString resultName;\n \n-  const char* lang = locale.getLanguage();\n+  const char* lang = loc.getLanguage();\n   if (uprv_strlen(lang) == 0) {\n     lang = \"root\";\n   }\n-  const char* script = locale.getScript();\n-  const char* country = locale.getCountry();\n-  const char* variant = locale.getVariant();\n+  const char* script = loc.getScript();\n+  const char* country = loc.getCountry();\n+  const char* variant = loc.getVariant();\n \n   UBool hasScript = uprv_strlen(script) > 0;\n   UBool hasCountry = uprv_strlen(country) > 0;\n@@ -630,14 +630,14 @@ LocaleDisplayNamesImpl::localeDisplayName(const Locale& locale,\n   resultRemainder.findAndReplace(formatOpenParen, formatReplaceOpenParen);\n   resultRemainder.findAndReplace(formatCloseParen, formatReplaceCloseParen);\n \n-  LocalPointer<StringEnumeration> e(locale.createKeywords(status));\n+  LocalPointer<StringEnumeration> e(loc.createKeywords(status));\n   if (e.isValid() && U_SUCCESS(status)) {\n     UnicodeString temp2;\n     char value[ULOC_KEYWORD_AND_VALUES_CAPACITY]; // sigh, no ULOC_VALUE_CAPACITY\n     const char* key;\n     while ((key = e->next((int32_t *)0, status)) != NULL) {\n       value[0] = 0;\n-      locale.getKeywordValue(key, value, ULOC_KEYWORD_AND_VALUES_CAPACITY, status);\n+      loc.getKeywordValue(key, value, ULOC_KEYWORD_AND_VALUES_CAPACITY, status);\n       if (U_FAILURE(status) || status == U_STRING_NOT_TERMINATED_WARNING) {\n         return result;\n       }"
        },
        {
            "sha": "e0dcc8a88ec0ec97829a33551044ca7d04be486b",
            "filename": "deps/icu-small/source/common/locid.cpp",
            "status": "modified",
            "additions": 526,
            "deletions": 27,
            "changes": 553,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Flocid.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Flocid.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Flocid.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -31,9 +31,12 @@\n ******************************************************************************\n */\n \n+#include <utility>\n \n+#include \"unicode/bytestream.h\"\n #include \"unicode/locid.h\"\n #include \"unicode/strenum.h\"\n+#include \"unicode/stringpiece.h\"\n #include \"unicode/uloc.h\"\n #include \"putilimp.h\"\n #include \"mutex.h\"\n@@ -43,9 +46,11 @@\n #include \"cstring.h\"\n #include \"uassert.h\"\n #include \"uhash.h\"\n+#include \"ulocimp.h\"\n #include \"ucln_cmn.h\"\n #include \"ustr_imp.h\"\n #include \"charstr.h\"\n+#include \"bytesinkutil.h\"\n \n U_CDECL_BEGIN\n static UBool U_CALLCONV locale_cleanup(void);\n@@ -424,49 +429,70 @@ Locale::Locale(const Locale &other)\n     *this = other;\n }\n \n-Locale &Locale::operator=(const Locale &other)\n-{\n+Locale::Locale(Locale&& other) U_NOEXCEPT\n+    : UObject(other), fullName(fullNameBuffer), baseName(fullName) {\n+  *this = std::move(other);\n+}\n+\n+Locale& Locale::operator=(const Locale& other) {\n     if (this == &other) {\n         return *this;\n     }\n \n-    /* Free our current storage */\n-    if (baseName != fullName) {\n-        uprv_free(baseName);\n+    setToBogus();\n+\n+    if (other.fullName == other.fullNameBuffer) {\n+        uprv_strcpy(fullNameBuffer, other.fullNameBuffer);\n+    } else if (other.fullName == nullptr) {\n+        fullName = nullptr;\n+    } else {\n+        fullName = uprv_strdup(other.fullName);\n+        if (fullName == nullptr) return *this;\n     }\n-    baseName = NULL;\n-    if(fullName != fullNameBuffer) {\n-        uprv_free(fullName);\n-        fullName = fullNameBuffer;\n+\n+    if (other.baseName == other.fullName) {\n+        baseName = fullName;\n+    } else if (other.baseName != nullptr) {\n+        baseName = uprv_strdup(other.baseName);\n+        if (baseName == nullptr) return *this;\n     }\n \n-    /* Allocate the full name if necessary */\n-    if(other.fullName != other.fullNameBuffer) {\n-        fullName = (char *)uprv_malloc(sizeof(char)*(uprv_strlen(other.fullName)+1));\n-        if (fullName == NULL) {\n-            return *this;\n-        }\n+    uprv_strcpy(language, other.language);\n+    uprv_strcpy(script, other.script);\n+    uprv_strcpy(country, other.country);\n+\n+    variantBegin = other.variantBegin;\n+    fIsBogus = other.fIsBogus;\n+\n+    return *this;\n+}\n+\n+Locale& Locale::operator=(Locale&& other) U_NOEXCEPT {\n+    if (baseName != fullName) uprv_free(baseName);\n+    if (fullName != fullNameBuffer) uprv_free(fullName);\n+\n+    if (other.fullName == other.fullNameBuffer) {\n+        uprv_strcpy(fullNameBuffer, other.fullNameBuffer);\n+        fullName = fullNameBuffer;\n+    } else {\n+        fullName = other.fullName;\n     }\n-    /* Copy the full name */\n-    uprv_strcpy(fullName, other.fullName);\n \n-    /* Copy the baseName if it differs from fullName. */\n     if (other.baseName == other.fullName) {\n         baseName = fullName;\n     } else {\n-        if (other.baseName) {\n-            baseName = uprv_strdup(other.baseName);\n-        }\n+        baseName = other.baseName;\n     }\n \n-    /* Copy the language and country fields */\n     uprv_strcpy(language, other.language);\n     uprv_strcpy(script, other.script);\n     uprv_strcpy(country, other.country);\n \n-    /* The variantBegin is an offset, just copy it */\n     variantBegin = other.variantBegin;\n     fIsBogus = other.fIsBogus;\n+\n+    other.baseName = other.fullName = other.fullNameBuffer;\n+\n     return *this;\n }\n \n@@ -545,7 +571,7 @@ Locale& Locale::init(const char* localeID, UBool canonicalize)\n         /* after uloc_getName/canonicalize() we know that only '_' are separators */\n         separator = field[0] = fullName;\n         fieldIdx = 1;\n-        while ((separator = uprv_strchr(field[fieldIdx-1], SEP_CHAR)) && fieldIdx < UPRV_LENGTHOF(field)-1) {\n+        while ((separator = uprv_strchr(field[fieldIdx-1], SEP_CHAR)) != 0 && fieldIdx < UPRV_LENGTHOF(field)-1) {\n             field[fieldIdx] = separator + 1;\n             fieldLen[fieldIdx-1] = (int32_t)(separator - field[fieldIdx-1]);\n             fieldIdx++;\n@@ -652,7 +678,7 @@ Locale::initBaseName(UErrorCode &status) {\n int32_t\n Locale::hashCode() const\n {\n-    return ustr_hashCharsN(fullName, uprv_strlen(fullName));\n+    return ustr_hashCharsN(fullName, static_cast<int32_t>(uprv_strlen(fullName)));\n }\n \n void\n@@ -704,6 +730,276 @@ Locale::setDefault( const   Locale&     newLocale,\n     locale_set_default_internal(localeID, status);\n }\n \n+void\n+Locale::addLikelySubtags(UErrorCode& status) {\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    // The maximized locale ID string is often longer, but there is no good\n+    // heuristic to estimate just how much longer. Leave that to CharString.\n+    CharString maximizedLocaleID;\n+    int32_t maximizedLocaleIDCapacity = static_cast<int32_t>(uprv_strlen(fullName));\n+\n+    char* buffer;\n+    int32_t reslen;\n+\n+    for (;;) {\n+        buffer = maximizedLocaleID.getAppendBuffer(\n+                /*minCapacity=*/maximizedLocaleIDCapacity,\n+                /*desiredCapacityHint=*/maximizedLocaleIDCapacity,\n+                maximizedLocaleIDCapacity,\n+                status);\n+\n+        if (U_FAILURE(status)) {\n+            return;\n+        }\n+\n+        reslen = uloc_addLikelySubtags(\n+                fullName,\n+                buffer,\n+                maximizedLocaleIDCapacity,\n+                &status);\n+\n+        if (status != U_BUFFER_OVERFLOW_ERROR) {\n+            break;\n+        }\n+\n+        maximizedLocaleIDCapacity = reslen;\n+        status = U_ZERO_ERROR;\n+    }\n+\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    maximizedLocaleID.append(buffer, reslen, status);\n+    if (status == U_STRING_NOT_TERMINATED_WARNING) {\n+        status = U_ZERO_ERROR;  // Terminators provided by CharString.\n+    }\n+\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    init(maximizedLocaleID.data(), /*canonicalize=*/FALSE);\n+    if (isBogus()) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+    }\n+}\n+\n+void\n+Locale::minimizeSubtags(UErrorCode& status) {\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    // Except for a few edge cases (like the empty string, that is minimized to\n+    // \"en__POSIX\"), minimized locale ID strings will be either the same length\n+    // or shorter than their input.\n+    CharString minimizedLocaleID;\n+    int32_t minimizedLocaleIDCapacity = static_cast<int32_t>(uprv_strlen(fullName));\n+\n+    char* buffer;\n+    int32_t reslen;\n+\n+    for (;;) {\n+        buffer = minimizedLocaleID.getAppendBuffer(\n+                /*minCapacity=*/minimizedLocaleIDCapacity,\n+                /*desiredCapacityHint=*/minimizedLocaleIDCapacity,\n+                minimizedLocaleIDCapacity,\n+                status);\n+\n+        if (U_FAILURE(status)) {\n+            return;\n+        }\n+\n+        reslen = uloc_minimizeSubtags(\n+                fullName,\n+                buffer,\n+                minimizedLocaleIDCapacity,\n+                &status);\n+\n+        if (status != U_BUFFER_OVERFLOW_ERROR) {\n+            break;\n+        }\n+\n+        // Because of the internal minimal buffer size of CharString, I can't\n+        // think of any input data for which this could possibly ever happen.\n+        // Maybe it would be better replaced with an assertion instead?\n+        minimizedLocaleIDCapacity = reslen;\n+        status = U_ZERO_ERROR;\n+    }\n+\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    minimizedLocaleID.append(buffer, reslen, status);\n+    if (status == U_STRING_NOT_TERMINATED_WARNING) {\n+        status = U_ZERO_ERROR;  // Terminators provided by CharString.\n+    }\n+\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    init(minimizedLocaleID.data(), /*canonicalize=*/FALSE);\n+    if (isBogus()) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+    }\n+}\n+\n+Locale U_EXPORT2\n+Locale::forLanguageTag(StringPiece tag, UErrorCode& status)\n+{\n+    Locale result(Locale::eBOGUS);\n+\n+    if (U_FAILURE(status)) {\n+        return result;\n+    }\n+\n+    // If a BCP-47 language tag is passed as the language parameter to the\n+    // normal Locale constructor, it will actually fall back to invoking\n+    // uloc_forLanguageTag() to parse it if it somehow is able to detect that\n+    // the string actually is BCP-47. This works well for things like strings\n+    // using BCP-47 extensions, but it does not at all work for things like\n+    // BCP-47 grandfathered tags (eg. \"en-GB-oed\") which are possible to also\n+    // interpret as ICU locale IDs and because of that won't trigger the BCP-47\n+    // parsing. Therefore the code here explicitly calls uloc_forLanguageTag()\n+    // and then Locale::init(), instead of just calling the normal constructor.\n+\n+    // All simple language tags will have the exact same length as ICU locale\n+    // ID strings as they have as BCP-47 strings (like \"en_US\" for \"en-US\").\n+    CharString localeID;\n+    int32_t resultCapacity = tag.size();\n+\n+    char* buffer;\n+    int32_t parsedLength, reslen;\n+\n+    for (;;) {\n+        buffer = localeID.getAppendBuffer(\n+                /*minCapacity=*/resultCapacity,\n+                /*desiredCapacityHint=*/resultCapacity,\n+                resultCapacity,\n+                status);\n+\n+        if (U_FAILURE(status)) {\n+            return result;\n+        }\n+\n+        reslen = ulocimp_forLanguageTag(\n+                tag.data(),\n+                tag.length(),\n+                buffer,\n+                resultCapacity,\n+                &parsedLength,\n+                &status);\n+\n+        if (status != U_BUFFER_OVERFLOW_ERROR) {\n+            break;\n+        }\n+\n+        // For all BCP-47 language tags that use extensions, the corresponding\n+        // ICU locale ID will be longer but uloc_forLanguageTag() does compute\n+        // the exact length needed so this memory reallocation will be done at\n+        // most once.\n+        resultCapacity = reslen;\n+        status = U_ZERO_ERROR;\n+    }\n+\n+    if (U_FAILURE(status)) {\n+        return result;\n+    }\n+\n+    if (parsedLength != tag.size()) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return result;\n+    }\n+\n+    localeID.append(buffer, reslen, status);\n+    if (status == U_STRING_NOT_TERMINATED_WARNING) {\n+        status = U_ZERO_ERROR;  // Terminators provided by CharString.\n+    }\n+\n+    if (U_FAILURE(status)) {\n+        return result;\n+    }\n+\n+    result.init(localeID.data(), /*canonicalize=*/FALSE);\n+    if (result.isBogus()) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+    }\n+    return result;\n+}\n+\n+void\n+Locale::toLanguageTag(ByteSink& sink, UErrorCode& status) const\n+{\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    if (fIsBogus) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+\n+    // All simple language tags will have the exact same length as BCP-47\n+    // strings as they have as ICU locale IDs (like \"en-US\" for \"en_US\").\n+    LocalMemory<char> scratch;\n+    int32_t scratch_capacity = static_cast<int32_t>(uprv_strlen(fullName));\n+\n+    if (scratch_capacity == 0) {\n+        scratch_capacity = 3;  // \"und\"\n+    }\n+\n+    char* buffer;\n+    int32_t result_capacity, reslen;\n+\n+    for (;;) {\n+        if (scratch.allocateInsteadAndReset(scratch_capacity) == nullptr) {\n+            status = U_MEMORY_ALLOCATION_ERROR;\n+            return;\n+        }\n+\n+        buffer = sink.GetAppendBuffer(\n+                /*min_capacity=*/scratch_capacity,\n+                /*desired_capacity_hint=*/scratch_capacity,\n+                scratch.getAlias(),\n+                scratch_capacity,\n+                &result_capacity);\n+\n+        reslen = uloc_toLanguageTag(\n+                fullName,\n+                buffer,\n+                result_capacity,\n+                /*strict=*/FALSE,\n+                &status);\n+\n+        if (status != U_BUFFER_OVERFLOW_ERROR) {\n+            break;\n+        }\n+\n+        // For some very few edge cases a language tag will be longer as a\n+        // BCP-47 string than it is as an ICU locale ID. Most notoriously \"C\"\n+        // expands to the BCP-47 tag \"en-US-u-va-posix\", 16 times longer, and\n+        // it'll take several calls to uloc_toLanguageTag() to figure that out.\n+        // https://unicode-org.atlassian.net/browse/ICU-20132\n+        scratch_capacity = reslen;\n+        status = U_ZERO_ERROR;\n+    }\n+\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    sink.Append(buffer, reslen);\n+    if (status == U_STRING_NOT_TERMINATED_WARNING) {\n+        status = U_ZERO_ERROR;  // Terminators not used.\n+    }\n+}\n+\n Locale U_EXPORT2\n Locale::createFromName (const char *name)\n {\n@@ -1010,20 +1306,84 @@ KeywordEnumeration::~KeywordEnumeration() {\n     uprv_free(keywords);\n }\n \n+// A wrapper around KeywordEnumeration that calls uloc_toUnicodeLocaleKey() in\n+// the next() method for each keyword before returning it.\n+class UnicodeKeywordEnumeration : public KeywordEnumeration {\n+public:\n+    using KeywordEnumeration::KeywordEnumeration;\n+    virtual ~UnicodeKeywordEnumeration();\n+\n+    virtual const char* next(int32_t* resultLength, UErrorCode& status) {\n+        const char* legacy_key = KeywordEnumeration::next(nullptr, status);\n+        if (U_SUCCESS(status) && legacy_key != nullptr) {\n+            const char* key = uloc_toUnicodeLocaleKey(legacy_key);\n+            if (key == nullptr) {\n+                status = U_ILLEGAL_ARGUMENT_ERROR;\n+            } else {\n+                if (resultLength != nullptr) {\n+                    *resultLength = static_cast<int32_t>(uprv_strlen(key));\n+                }\n+                return key;\n+            }\n+        }\n+        if (resultLength != nullptr) *resultLength = 0;\n+        return nullptr;\n+    }\n+};\n+\n+// Out-of-line virtual destructor to serve as the \"key function\".\n+UnicodeKeywordEnumeration::~UnicodeKeywordEnumeration() = default;\n+\n StringEnumeration *\n Locale::createKeywords(UErrorCode &status) const\n {\n     char keywords[256];\n-    int32_t keywordCapacity = 256;\n+    int32_t keywordCapacity = sizeof keywords;\n     StringEnumeration *result = NULL;\n \n+    if (U_FAILURE(status)) {\n+        return result;\n+    }\n+\n     const char* variantStart = uprv_strchr(fullName, '@');\n     const char* assignment = uprv_strchr(fullName, '=');\n     if(variantStart) {\n         if(assignment > variantStart) {\n             int32_t keyLen = locale_getKeywords(variantStart+1, '@', keywords, keywordCapacity, NULL, 0, NULL, FALSE, &status);\n-            if(keyLen) {\n+            if(U_SUCCESS(status) && keyLen) {\n                 result = new KeywordEnumeration(keywords, keyLen, 0, status);\n+                if (!result) {\n+                    status = U_MEMORY_ALLOCATION_ERROR;\n+                }\n+            }\n+        } else {\n+            status = U_INVALID_FORMAT_ERROR;\n+        }\n+    }\n+    return result;\n+}\n+\n+StringEnumeration *\n+Locale::createUnicodeKeywords(UErrorCode &status) const\n+{\n+    char keywords[256];\n+    int32_t keywordCapacity = sizeof keywords;\n+    StringEnumeration *result = NULL;\n+\n+    if (U_FAILURE(status)) {\n+        return result;\n+    }\n+\n+    const char* variantStart = uprv_strchr(fullName, '@');\n+    const char* assignment = uprv_strchr(fullName, '=');\n+    if(variantStart) {\n+        if(assignment > variantStart) {\n+            int32_t keyLen = locale_getKeywords(variantStart+1, '@', keywords, keywordCapacity, NULL, 0, NULL, FALSE, &status);\n+            if(U_SUCCESS(status) && keyLen) {\n+                result = new UnicodeKeywordEnumeration(keywords, keyLen, 0, status);\n+                if (!result) {\n+                    status = U_MEMORY_ALLOCATION_ERROR;\n+                }\n             }\n         } else {\n             status = U_INVALID_FORMAT_ERROR;\n@@ -1038,6 +1398,105 @@ Locale::getKeywordValue(const char* keywordName, char *buffer, int32_t bufLen, U\n     return uloc_getKeywordValue(fullName, keywordName, buffer, bufLen, &status);\n }\n \n+void\n+Locale::getKeywordValue(StringPiece keywordName, ByteSink& sink, UErrorCode& status) const {\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    if (fIsBogus) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+\n+    // TODO: Remove the need for a const char* to a NUL terminated buffer.\n+    const CharString keywordName_nul(keywordName, status);\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    LocalMemory<char> scratch;\n+    int32_t scratch_capacity = 16;  // Arbitrarily chosen default size.\n+\n+    char* buffer;\n+    int32_t result_capacity, reslen;\n+\n+    for (;;) {\n+        if (scratch.allocateInsteadAndReset(scratch_capacity) == nullptr) {\n+            status = U_MEMORY_ALLOCATION_ERROR;\n+            return;\n+        }\n+\n+        buffer = sink.GetAppendBuffer(\n+                /*min_capacity=*/scratch_capacity,\n+                /*desired_capacity_hint=*/scratch_capacity,\n+                scratch.getAlias(),\n+                scratch_capacity,\n+                &result_capacity);\n+\n+        reslen = uloc_getKeywordValue(\n+                fullName,\n+                keywordName_nul.data(),\n+                buffer,\n+                result_capacity,\n+                &status);\n+\n+        if (status != U_BUFFER_OVERFLOW_ERROR) {\n+            break;\n+        }\n+\n+        scratch_capacity = reslen;\n+        status = U_ZERO_ERROR;\n+    }\n+\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    sink.Append(buffer, reslen);\n+    if (status == U_STRING_NOT_TERMINATED_WARNING) {\n+        status = U_ZERO_ERROR;  // Terminators not used.\n+    }\n+}\n+\n+void\n+Locale::getUnicodeKeywordValue(StringPiece keywordName,\n+                               ByteSink& sink,\n+                               UErrorCode& status) const {\n+    // TODO: Remove the need for a const char* to a NUL terminated buffer.\n+    const CharString keywordName_nul(keywordName, status);\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    const char* legacy_key = uloc_toLegacyKey(keywordName_nul.data());\n+\n+    if (legacy_key == nullptr) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+\n+    CharString legacy_value;\n+    {\n+        CharStringByteSink sink(&legacy_value);\n+        getKeywordValue(legacy_key, sink, status);\n+    }\n+\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    const char* unicode_value = uloc_toUnicodeLocaleType(\n+            keywordName_nul.data(), legacy_value.data());\n+\n+    if (unicode_value == nullptr) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+\n+    sink.Append(unicode_value, static_cast<int32_t>(uprv_strlen(unicode_value)));\n+}\n+\n void\n Locale::setKeywordValue(const char* keywordName, const char* keywordValue, UErrorCode &status)\n {\n@@ -1048,6 +1507,46 @@ Locale::setKeywordValue(const char* keywordName, const char* keywordValue, UErro\n     }\n }\n \n+void\n+Locale::setKeywordValue(StringPiece keywordName,\n+                        StringPiece keywordValue,\n+                        UErrorCode& status) {\n+    // TODO: Remove the need for a const char* to a NUL terminated buffer.\n+    const CharString keywordName_nul(keywordName, status);\n+    const CharString keywordValue_nul(keywordValue, status);\n+    setKeywordValue(keywordName_nul.data(), keywordValue_nul.data(), status);\n+}\n+\n+void\n+Locale::setUnicodeKeywordValue(StringPiece keywordName,\n+                               StringPiece keywordValue,\n+                               UErrorCode& status) {\n+    // TODO: Remove the need for a const char* to a NUL terminated buffer.\n+    const CharString keywordName_nul(keywordName, status);\n+    const CharString keywordValue_nul(keywordValue, status);\n+\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+\n+    const char* legacy_key = uloc_toLegacyKey(keywordName_nul.data());\n+\n+    if (legacy_key == nullptr) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+\n+    const char* legacy_value =\n+        uloc_toLegacyType(keywordName_nul.data(), keywordValue_nul.data());\n+\n+    if (legacy_value == nullptr) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+\n+    setKeywordValue(legacy_key, legacy_value, status);\n+}\n+\n const char *\n Locale::getBaseName() const {\n     return baseName;"
        },
        {
            "sha": "5223397bbcc10a0596d0da3864b907df1e9f3614",
            "filename": "deps/icu-small/source/common/mutex.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fmutex.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fmutex.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fmutex.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -35,7 +35,7 @@ U_NAMESPACE_BEGIN\n \n // For example:\n //\n-// UMutex myMutex;\n+// UMutex myMutex = U_MUTEX_INITIALIZER;\n //\n // void Function(int arg1, int arg2)\n // {"
        },
        {
            "sha": "82a68097385285723be3f20b9d6daf95da139a94",
            "filename": "deps/icu-small/source/common/norm2_nfc_data.h",
            "status": "modified",
            "additions": 549,
            "deletions": 579,
            "changes": 1128,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fnorm2_nfc_data.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fnorm2_nfc_data.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fnorm2_nfc_data.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -11,258 +11,197 @@\n \n #ifdef INCLUDED_FROM_NORMALIZER2_CPP\n \n-static const UVersionInfo norm2_nfc_data_formatVersion={3,0,0,0};\n+static const UVersionInfo norm2_nfc_data_formatVersion={4,0,0,0};\n static const UVersionInfo norm2_nfc_data_dataVersion={0xb,0,0,0};\n \n static const int32_t norm2_nfc_data_indexes[Normalizer2Impl::IX_COUNT]={\n-0x50,0x4e50,0x8aa8,0x8ba8,0x8ba8,0x8ba8,0x8ba8,0x8ba8,0xc0,0x300,0xadc,0x29d0,0x3c56,0xfc00,0x1282,0x3b8c,\n+0x50,0x4ab0,0x8708,0x8808,0x8808,0x8808,0x8808,0x8808,0xc0,0x300,0xadc,0x29d0,0x3c56,0xfc00,0x1282,0x3b8c,\n 0x3c24,0x3c56,0x300,0\n };\n \n-static const uint16_t norm2_nfc_data_trieIndex[9976]={\n-0x2aa,0x2b2,0x2ba,0x2c2,0x2d0,0x2d8,0x2e0,0x2e8,0x2f0,0x2f8,0x300,0x308,0x310,0x318,0x31e,0x326,\n-0x32e,0x336,0x2c9,0x2d1,0x33b,0x343,0x2c9,0x2d1,0x34b,0x353,0x35b,0x363,0x36b,0x373,0x37b,0x383,\n-0x38b,0x393,0x39b,0x3a3,0x3ab,0x3b3,0x3bb,0x3c3,0x2c9,0x2d1,0x2c9,0x2d1,0x3ca,0x3d2,0x3da,0x3e2,\n-0x3e6,0x3ee,0x3f4,0x3fc,0x2c9,0x2d1,0x404,0x40c,0x410,0x418,0x420,0x428,0x2c9,0x2d1,0x426,0x42e,\n-0x436,0x43d,0x441,0x2c9,0x2c9,0x2c9,0x448,0x450,0x2c9,0x458,0x460,0x2c9,0x2c9,0x468,0x470,0x478,\n-0x2c9,0x480,0x488,0x2c9,0x2c9,0x490,0x498,0x2c9,0x2c9,0x468,0x49f,0x2c9,0x4a7,0x4ad,0x4b5,0x2c9,\n-0x2c9,0x2c9,0x4bc,0x2c9,0x2c9,0x4c2,0x4ca,0x2c9,0x2c9,0x4d0,0x4d8,0x2c9,0x2c9,0x2c9,0x4de,0x2c9,\n-0x2c9,0x4e6,0x4ed,0x2c9,0x2c9,0x4f0,0x4f7,0x2c9,0x4fa,0x501,0x509,0x511,0x519,0x521,0x528,0x2c9,\n-0x2c9,0x52f,0x2c9,0x2c9,0x536,0x2c9,0x2c9,0x2c9,0x96d,0x2c9,0x2c9,0x975,0x2c9,0x97b,0x983,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x53a,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x542,0x542,0x2c9,0x2c9,0x2c9,0x2c9,0x548,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x550,0x2c9,0x2c9,0x2c9,0x553,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x55a,0x2c9,0x2c9,0x562,0x2c9,0x56a,0x2c9,0x2c9,0x572,0x577,0x57f,0x585,0x2c9,0x58b,0x2c9,0x592,\n-0x2c9,0x597,0x2c9,0x2c9,0x2c9,0x2c9,0x59d,0x5a5,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x5ad,0x5b2,\n-0x5ba,0x5c2,0x5ca,0x5d2,0x5da,0x5e2,0x5ea,0x5f2,0x5fa,0x602,0x60a,0x612,0x61a,0x622,0x62a,0x632,\n-0x63a,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x63e,0x646,0x2c9,0x64d,0x2c9,0x2c9,0x651,0x658,0x65d,0x2c9,\n-0x665,0x66d,0x675,0x67d,0x685,0x68d,0x2c9,0x695,0x2c9,0x69b,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x69e,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x6a6,0x2c9,0x2c9,0x2c9,0x6ab,0x2c9,0x2c9,0x2c9,0x6b3,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x6bb,0x6c2,0x6ca,0x6d2,0x6da,0x6e2,0x6ea,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x6f2,0x6fa,0x2c9,0x2c9,0x702,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x709,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x710,0x718,0x2c9,0x71e,0x722,0x2c9,0x2c9,0x598,0x72a,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x72e,0x736,0x739,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x498,\n-0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,\n-0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,\n-0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,\n-0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,\n-0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,\n-0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,\n-0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,\n-0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,\n-0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,\n-0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,\n-0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,\n-0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,\n-0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,\n-0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,\n-0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,\n-0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,\n-0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,\n-0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,\n-0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,\n-0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,\n-0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,\n-0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x99f,0x98b,0x98c,0x98d,0x98e,0x98f,0x990,0x997,0x2c9,0x2c9,\n-0x9a7,0x9ae,0x2aa,0x9b5,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,\n-0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,0x2aa,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x741,0x749,0x751,0x759,0x761,0x769,0x771,0x779,\n-0x781,0x789,0x791,0x799,0x7a1,0x7a9,0x7b1,0x2c9,0x7b8,0x7c0,0x7c8,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x7d0,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0xb28,0xb28,0xb40,0xb80,0xbc0,0xc00,0xc40,0xc78,0xcb8,0xb24,0xcec,0xb24,0xd2c,0xd6c,0xdac,0xdec,\n-0xe2c,0xe6c,0xeac,0xeec,0xb24,0xb24,0xf28,0xf68,0xf98,0xfd0,0xb24,0x1010,0x1040,0x1080,0xb24,0x1098,\n-0x880,0x8b0,0x8ee,0x92d,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x95a,0x188,0x188,\n-0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x976,0x188,0x188,0x9ac,0x188,0x9ec,0xa26,0x188,0x188,\n-0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,\n-0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0x188,0xa66,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x7d4,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x7dc,0x2c9,0x2c9,0x2c9,0x7df,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x7e6,0x7ea,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x7f2,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x7f9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x800,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x709,0x6ab,0x805,0x80d,0x2c9,0x2c9,0x815,0x81c,0x2c9,0x598,0x2c9,0x2c9,0x824,0x2c9,0x2c9,0x827,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x82d,0x2c9,0x830,0x838,0x83f,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x847,0x2c9,0x2c9,0x84f,0x857,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x85c,0x864,0x2c9,0x2c9,0x6ab,\n-0x2c9,0x2c9,0x2c9,0x867,0x2c9,0x2c9,0x2c9,0x86d,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x870,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x542,0x86e,\n-0x2c9,0x877,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x6ab,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x87f,0x2c9,0x882,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x888,0x2c9,0x88e,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x894,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x89c,0x8a4,0x8ac,0x8b2,0x8ba,0x2c9,0x2c9,0x2c9,0x8c2,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x8ca,0x8d2,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x8d6,0x2c9,0x2c9,0x2c9,\n-0x8dd,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x8e5,0x8ed,0x8f5,0x8fd,0x905,0x90d,0x915,0x91d,0x925,0x92d,\n-0x935,0x93d,0x945,0x94d,0x955,0x95d,0x965,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,\n-0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2c9,0x2a9,0x2a9,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,4,8,0xc,1,1,0x10,0x50,0x5c,0x70,0x88,0xcc,0xd0,\n-0xec,0x108,0x144,0x148,0x15c,0x174,0x180,0x1a4,0x1e4,1,0x1ec,0x20c,0x228,0x244,0x290,0x298,\n-0x2b0,0x2b8,0x2dc,1,1,1,1,1,1,0x2f4,0x334,0x340,0x354,0x36c,0x3b0,0x3b4,\n-0x3d0,0x3f0,0x428,0x430,0x444,0x45c,0x468,0x48c,0x4cc,1,0x4d4,0x4f4,0x510,0x530,0x57c,0x584,\n-0x5a0,0x5a8,0x5d0,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0x5e8,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0x1284,0x128a,0xade,0x1290,0xaf4,0xafe,0x5f4,0xb08,0x1296,0x129c,0xb12,0x12a2,0x12a8,0x12ae,0x12b4,0xb28,\n-1,0x12ba,0x12c0,0x12c6,0xb32,0xb48,0xb5a,1,0x5fc,0x12cc,0x12d2,0x12d8,0xb64,0x12de,1,1,\n-0x12e4,0x12ea,0xb7a,0x12f0,0xb90,0xb9a,0x600,0xba4,0x12f6,0x12fc,0xbae,0x1302,0x1308,0x130e,0x1314,0xbc4,\n-1,0x131a,0x1320,0x1326,0xbce,0xbe4,0xbf6,1,0x608,0x132c,0x1332,0x1338,0xc00,0x133e,1,0x1344,\n-0x134a,0x1350,0xc16,0xc2c,0x1357,0x135d,0x1362,0x1368,0x136e,0x1374,0x137a,0x1380,0x1386,0x138c,0x1392,0x1398,\n-1,1,0xc42,0xc50,0x139e,0x13a4,0x13aa,0x13b0,0x13b7,0x13bd,0x13c2,0x13c8,0x13ce,0x13d4,0x13da,0x13e0,\n-0x13e6,0x13ec,0x13f3,0x13f9,0x13fe,0x1404,1,1,0x140a,0x1410,0x1416,0x141c,0x1422,0x1428,0x142f,0x1435,\n-0x143a,1,1,1,0x1441,0x1447,0x144d,0x1453,1,0x1458,0x145e,0x1465,0x146b,0x1470,0x1476,1,\n-1,1,1,0x147c,0x1482,0x1489,0x148f,0x1494,0x149a,1,1,1,0xc5e,0xc6c,0x14a0,0x14a6,\n-0x14ac,0x14b2,1,1,0x14b8,0x14be,0x14c5,0x14cb,0x14d0,0x14d6,0xc7a,0xc84,0x14dc,0x14e2,0x14e9,0x14ef,\n-0xc8e,0xc98,0x14f5,0x14fb,0x1500,0x1506,1,1,0xca2,0xcac,0xcb6,0xcc0,0x150c,0x1512,0x1518,0x151e,\n-0x1524,0x152a,0x1531,0x1537,0x153c,0x1542,0x1548,0x154e,0x1554,0x155a,0x1560,0x1566,0x156c,0x1572,0x1578,0x60c,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0xcca,0xce4,1,1,1,1,1,1,1,1,1,1,1,1,1,0xcfe,\n-0xd18,1,1,1,1,1,1,0x610,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,0x157e,0x1584,0x158a,0x1590,0x1596,0x159c,0x15a2,0x15a8,0x15b0,0x15ba,0x15c4,\n-0x15ce,0x15d8,0x15e2,0x15ec,0x15f6,1,0x1600,0x160a,0x1614,0x161e,0x1627,0x162d,1,1,0x1632,0x1638,\n-0x163e,0x1644,0xd32,0xd3c,0x164d,0x1657,0x165f,0x1665,0x166b,1,1,1,0x1670,0x1676,1,1,\n-0x167c,0x1682,0x168a,0x1694,0x169d,0x16a3,0x16a9,0x16af,0x16b4,0x16ba,0x16c0,0x16c6,0x16cc,0x16d2,0x16d8,0x16de,\n-0x16e4,0x16ea,0x16f0,0x16f6,0x16fc,0x1702,0x1708,0x170e,0x1714,0x171a,0x1720,0x1726,0x172c,0x1732,0x1738,0x173e,\n-0x1744,0x174a,0x1750,0x1756,1,1,0x175c,0x1762,1,1,1,1,1,1,0xd46,0xd50,\n-0xd5a,0xd64,0x176a,0x1774,0x177e,0x1788,0xd6e,0xd78,0x1792,0x179c,0x17a4,0x17aa,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x614,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0xfdcc,0xfdcc,0xfdcc,0xfdcc,\n-0xfdcc,0xffcc,0xfdcc,0xfdcc,0xfdcc,0xfdcc,0xfdcc,0xfdcc,0xfdcc,0xffcc,0xffcc,0xfdcc,0xffcc,0xfdcc,0xffcc,0xfdcc,\n-0xfdcc,0xffd0,0xffb8,0xffb8,0xffb8,0xffb8,0xffd0,0xfdb0,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xff94,0xff94,0xfdb8,\n-0xfdb8,0xfdb8,0xfdb8,0xfd94,0xfd94,0xffb8,0xffb8,0xffb8,0xffb8,0xfdb8,0xfdb8,0xffb8,0xfdb8,0xfdb8,0xffb8,0xffb8,\n-0xfe02,0xfe02,0xfe02,0xfe02,0xfc02,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,0xffcc,0xffcc,0x3c26,0x3c2c,0xfdcc,0x3c32,\n-0x3c38,0xfde0,0xffcc,0xffb8,0xffb8,0xffb8,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,1,0xffcc,0xffcc,0xffcc,0xffb8,\n-0xffb8,0xffb8,0xffb8,0xffcc,0xffd0,0xffb8,0xffb8,0xffcc,0xffd2,0xffd4,0xffd4,0xffd2,0xffd4,0xffd4,0xffd2,0xffcc,\n-0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,\n-0x29d1,1,1,1,1,1,1,1,1,1,0x29d5,1,1,1,1,1,\n-1,0x17b1,0x17b7,0x29d9,0x17bd,0x17c3,0x17c9,1,0x17cf,1,0x17d5,0x17db,0x17e3,0x618,1,1,\n-1,0x634,1,0x644,1,0x658,1,1,1,1,1,0x674,1,0x684,1,1,\n-1,0x688,1,1,1,0x6a0,0x17eb,0x17f1,0xd82,0x17f7,0xd8c,0x17fd,0x1805,0x6b4,1,1,\n-1,0x6d4,1,0x6e4,1,0x6fc,1,1,1,1,1,0x71c,1,0x72c,1,1,\n-1,0x734,1,1,1,0x754,0xd96,0xda8,0x180d,0x1813,0xdba,1,1,1,0x76c,0x1819,\n-0x181f,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0x1825,0x182b,1,0x1831,\n-1,1,0x774,0x1837,1,1,1,1,0x183d,0x1843,0x1849,1,0x778,1,1,0x780,\n-1,0x784,0x790,0x798,0x79c,0x184f,0x7ac,1,1,1,0x7b0,1,1,1,1,0x7b4,\n-1,1,1,0x7c4,1,1,1,0x7c8,1,0x7cc,1,1,0x7d0,1,1,0x7d8,\n-1,0x7dc,0x7e8,0x7f0,0x7f4,0x1855,0x804,1,1,1,0x808,1,1,1,1,0x80c,\n-1,1,1,0x81c,1,1,1,0x820,1,0x824,1,1,0x185b,0x1861,1,0x1867,\n-1,1,0x828,0x186d,1,1,1,1,0x1873,0x1879,0x187f,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0x82c,0x830,0x1885,0x188b,1,1,1,1,1,1,1,1,1,1,1,0xffcc,\n-0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,0x1891,0x1897,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0x189d,0x18a3,0x18a9,0x18af,\n-1,1,0x18b5,0x18bb,0x834,0x838,0x18c1,0x18c7,0x18cd,0x18d3,0x18d9,0x18df,1,1,0x18e5,0x18eb,\n-0x18f1,0x18f7,0x18fd,0x1903,0x83c,0x840,0x1909,0x190f,0x1915,0x191b,0x1921,0x1927,0x192d,0x1933,0x1939,0x193f,\n-0x1945,0x194b,1,1,0x1951,0x1957,1,1,1,1,1,1,1,1,1,1,\n+static const uint16_t norm2_nfc_data_trieIndex[1690]={\n+0,0x40,0x7b,0xbb,0xfb,0x13a,0x17a,0x1b2,0x1f2,0x226,0x254,0x226,0x294,0x2d4,0x313,0x353,\n+0x393,0x3d2,0x40f,0x44e,0x226,0x226,0x488,0x4c8,0x4f8,0x530,0x226,0x570,0x59f,0x5de,0x226,0x5f3,\n+0x631,0x65f,0x226,0x68c,0x6cc,0x709,0x729,0x768,0x7a7,0x7e4,0x803,0x840,0x729,0x879,0x8a7,0x8e6,\n+0x226,0x920,0x937,0x977,0x98e,0x9cd,0x226,0xa03,0xa23,0xa5e,0xa6a,0xaa4,0xacc,0xb09,0xb49,0xb83,\n+0xb9e,0x226,0xbd9,0x226,0xc19,0xc38,0xc6e,0xcab,0x226,0x226,0x226,0x226,0x226,0xcce,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0xcfa,0x226,0x226,0xd2f,\n+0x226,0x226,0xd4d,0x226,0xd77,0x226,0x226,0x226,0xdb3,0xdd3,0xe13,0x226,0xe51,0xe91,0xec5,0xef1,\n+0x808,0x226,0x226,0xf25,0x226,0x226,0x226,0xf65,0xfa5,0xfe5,0x1025,0x1065,0x10a5,0x10e5,0x1125,0x1165,\n+0x11a5,0x226,0x226,0x11d5,0x1206,0x226,0x1236,0x1269,0x12a6,0x12e5,0x1325,0x135b,0x1389,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x13b4,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0xcbc,0x226,0x13d1,0x226,0x1411,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x1451,0x148b,0x14c9,0x1509,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1548,0x1586,0x15a6,0x226,0x226,0x226,0x226,\n+0x15e0,0x226,0x226,0x161c,0x164e,0x167c,0x80c,0x168f,0x226,0x226,0x169f,0x16df,0x226,0x226,0x226,0x13e3,\n+0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,\n+0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,\n+0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,\n+0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,\n+0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,\n+0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,\n+0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,\n+0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,\n+0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,\n+0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,\n+0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x1733,0x171f,0x1727,0x172f,0x1737,0x1723,0x172b,0x176b,0x226,\n+0x17ab,0x17e6,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x1826,0x1866,0x18a6,0x18e6,0x1926,0x1966,0x19a6,0x19e6,0x1a09,0x1a49,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1a69,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x61f,0x62e,0x644,0x663,0x678,0x678,0x678,0x67c,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0xbd9,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x54f,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x40c,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1a9c,0x226,0x226,0x1aac,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0xdc5,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1abc,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1ac6,0x54f,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x7eb,0x226,0x226,0x9ba,0x226,0x1ad6,\n+0x1ae3,0x1aef,0x226,0x226,0x226,0x226,0x414,0x226,0x1afa,0x1b0a,0x226,0x226,0x226,0x7e0,0x226,0x226,\n+0x226,0x226,0x1b1a,0x226,0x226,0x226,0x1b25,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x1b2c,0x226,0x226,0x226,0x226,0x1b37,0x1b46,0x8f6,0x1b54,0x412,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x1b62,0x798,0x226,0x226,0x226,0x226,0x226,0x1b72,0x1b81,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x8d6,0x1b89,0x1b99,0x226,0x226,0x226,0x9ba,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1ba3,0x226,0x226,0x226,0x226,0x226,0x226,0x7e6,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1ba0,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x7ed,0x7ea,0x226,0x226,0x226,0x226,0x7e8,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x9ba,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0xbd3,0x226,0x226,0x226,0x226,0x7ea,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1bb3,0x226,0x226,0x226,\n+0xebe,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1bb8,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x1bc7,0x1bd7,0x1be5,0x1bf2,0x226,0x1bfe,0x1c0c,0x1c1c,0x226,0x226,0x226,0x226,\n+0xce9,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1c2c,0x1c34,0x1c42,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1c52,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x1c5e,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x1c6e,\n+0x1c7e,0x1c8e,0x1c9e,0x1cae,0x1cbe,0x1cce,0x1cde,0x1cee,0x1cfe,0x1d0e,0x1d1e,0x1d2e,0x1d3e,0x1d4e,0x1d5e,0x1d6e,\n+0x1d7e,0x1d8e,0x1d9e,0x1dae,0x1dbe,0x1dce,0x1dde,0x1dee,0x1dfe,0x1e0e,0x1e1e,0x1e2e,0x1e3e,0x1e4e,0x1e5e,0x1e6e,\n+0x1e7e,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,\n+0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x226,0x408,\n+0x428,0xc4,0xc4,0xc4,0x448,0x457,0x46a,0x486,0x4a3,0x4bf,0x4dc,0x4f9,0x516,0x533,0xc4,0xc4,\n+0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,\n+0xc4,0xc4,0xc4,0x54d,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,\n+0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,\n+0xc4,0xc4,0x564,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0x56f,0x58c,0xc4,0xc4,0xc4,\n+0xc4,0xc4,0xc4,0x5ac,0xc4,0xc4,0xc4,0x5bf,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,\n+0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,\n+0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0x5df,0x5ff\n+};\n+\n+static const uint16_t norm2_nfc_data_trieData[7822]={\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,4,8,0xc,1,\n+1,0x10,0x50,0x5c,0x70,0x88,0xcc,0xd0,0xec,0x108,0x144,0x148,0x15c,0x174,0x180,0x1a4,\n+0x1e4,1,0x1ec,0x20c,0x228,0x244,0x290,0x298,0x2b0,0x2b8,0x2dc,1,1,1,1,1,\n+1,0x2f4,0x334,0x340,0x354,0x36c,0x3b0,0x3b4,0x3d0,0x3f0,0x428,0x430,0x444,0x45c,0x468,0x48c,\n+0x4cc,1,0x4d4,0x4f4,0x510,0x530,0x57c,0x584,0x5a0,0x5a8,0x5d0,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,0x5e8,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,0x1284,0x128a,0xade,0x1290,0xaf4,\n+0xafe,0x5f4,0xb08,0x1296,0x129c,0xb12,0x12a2,0x12a8,0x12ae,0x12b4,0xb28,1,0x12ba,0x12c0,0x12c6,0xb32,\n+0xb48,0xb5a,1,0x5fc,0x12cc,0x12d2,0x12d8,0xb64,0x12de,1,1,0x12e4,0x12ea,0xb7a,0x12f0,0xb90,\n+0xb9a,0x600,0xba4,0x12f6,0x12fc,0xbae,0x1302,0x1308,0x130e,0x1314,0xbc4,1,0x131a,0x1320,0x1326,0xbce,\n+0xbe4,0xbf6,1,0x608,0x132c,0x1332,0x1338,0xc00,0x133e,1,0x1344,0x134a,0x1350,0xc16,0xc2c,0x1357,\n+0x135d,0x1362,0x1368,0x136e,0x1374,0x137a,0x1380,0x1386,0x138c,0x1392,0x1398,1,1,0xc42,0xc50,0x139e,\n+0x13a4,0x13aa,0x13b0,0x13b7,0x13bd,0x13c2,0x13c8,0x13ce,0x13d4,0x13da,0x13e0,0x13e6,0x13ec,0x13f3,0x13f9,0x13fe,\n+0x1404,1,1,0x140a,0x1410,0x1416,0x141c,0x1422,0x1428,0x142f,0x1435,0x143a,1,1,1,0x1441,\n+0x1447,0x144d,0x1453,1,0x1458,0x145e,0x1465,0x146b,0x1470,0x1476,1,1,1,0x147c,0x1482,0x1489,\n+0x148f,0x1494,0x149a,1,1,1,0xc5e,0xc6c,0x14a0,0x14a6,0x14ac,0x14b2,1,1,0x14b8,0x14be,\n+0x14c5,0x14cb,0x14d0,0x14d6,0xc7a,0xc84,0x14dc,0x14e2,0x14e9,0x14ef,0xc8e,0xc98,0x14f5,0x14fb,0x1500,0x1506,\n+1,1,0xca2,0xcac,0xcb6,0xcc0,0x150c,0x1512,0x1518,0x151e,0x1524,0x152a,0x1531,0x1537,0x153c,0x1542,\n+0x1548,0x154e,0x1554,0x155a,0x1560,0x1566,0x156c,0x1572,0x1578,0x60c,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,0xcca,0xce4,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0xcfe,0xd18,1,1,1,1,1,\n+1,0x610,1,1,1,1,1,1,1,1,1,1,1,1,1,0x157e,\n+0x1584,0x158a,0x1590,0x1596,0x159c,0x15a2,0x15a8,0x15b0,0x15ba,0x15c4,0x15ce,0x15d8,0x15e2,0x15ec,0x15f6,1,\n+0x1600,0x160a,0x1614,0x161e,0x1627,0x162d,1,1,0x1632,0x1638,0x163e,0x1644,0xd32,0xd3c,0x164d,0x1657,\n+0x165f,0x1665,0x166b,1,1,1,0x1670,0x1676,1,1,0x167c,0x1682,0x168a,0x1694,0x169d,0x16a3,\n+0x16a9,0x16af,0x16b4,0x16ba,0x16c0,0x16c6,0x16cc,0x16d2,0x16d8,0x16de,0x16e4,0x16ea,0x16f0,0x16f6,0x16fc,0x1702,\n+0x1708,0x170e,0x1714,0x171a,0x1720,0x1726,0x172c,0x1732,0x1738,0x173e,0x1744,0x174a,0x1750,0x1756,1,1,\n+0x175c,0x1762,1,1,1,1,1,1,0xd46,0xd50,0xd5a,0xd64,0x176a,0x1774,0x177e,0x1788,\n+0xd6e,0xd78,0x1792,0x179c,0x17a4,0x17aa,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0x614,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,0xfdcc,0xfdcc,0xfdcc,0xfdcc,0xfdcc,0xffcc,0xfdcc,0xfdcc,0xfdcc,0xfdcc,0xfdcc,0xfdcc,\n+0xfdcc,0xffcc,0xffcc,0xfdcc,0xffcc,0xfdcc,0xffcc,0xfdcc,0xfdcc,0xffd0,0xffb8,0xffb8,0xffb8,0xffb8,0xffd0,0xfdb0,\n+0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xff94,0xff94,0xfdb8,0xfdb8,0xfdb8,0xfdb8,0xfd94,0xfd94,0xffb8,0xffb8,0xffb8,\n+0xffb8,0xfdb8,0xfdb8,0xffb8,0xfdb8,0xfdb8,0xffb8,0xffb8,0xfe02,0xfe02,0xfe02,0xfe02,0xfc02,0xffb8,0xffb8,0xffb8,\n+0xffb8,0xffcc,0xffcc,0xffcc,0x3c26,0x3c2c,0xfdcc,0x3c32,0x3c38,0xfde0,0xffcc,0xffb8,0xffb8,0xffb8,0xffcc,0xffcc,\n+0xffcc,0xffb8,0xffb8,1,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,0xffd0,0xffb8,0xffb8,0xffcc,\n+0xffd2,0xffd4,0xffd4,0xffd2,0xffd4,0xffd4,0xffd2,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n+0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,0x29d1,1,1,1,1,1,1,1,\n+1,1,0x29d5,1,1,1,1,1,0x17b1,0x17b7,0x29d9,0x17bd,0x17c3,0x17c9,1,0x17cf,\n+1,0x17d5,0x17db,0x17e3,0x618,1,1,1,0x634,1,0x644,1,0x658,1,1,1,\n+1,1,0x674,1,0x684,1,1,1,0x688,1,1,1,0x6a0,0x17eb,0x17f1,0xd82,\n+0x17f7,0xd8c,0x17fd,0x1805,0x6b4,1,1,1,0x6d4,1,0x6e4,1,0x6fc,1,1,1,\n+1,1,0x71c,1,0x72c,1,1,1,0x734,1,1,1,0x754,0xd96,0xda8,0x180d,\n+0x1813,0xdba,1,1,1,0x76c,0x1819,0x181f,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,0x1825,0x182b,1,0x1831,1,1,0x774,0x1837,1,1,1,1,0x183d,\n+0x1843,0x1849,1,0x778,1,1,0x780,1,0x784,0x790,0x798,0x79c,0x184f,0x7ac,1,1,\n+1,0x7b0,1,1,1,1,0x7b4,1,1,1,0x7c4,1,1,1,0x7c8,1,\n+0x7cc,1,1,0x7d0,1,1,0x7d8,1,0x7dc,0x7e8,0x7f0,0x7f4,0x1855,0x804,1,1,\n+1,0x808,1,1,1,0x80c,1,1,1,0x81c,1,1,1,0x820,1,0x824,\n+1,1,0x185b,0x1861,1,0x1867,1,1,0x828,0x186d,1,1,1,1,0x1873,0x1879,\n+0x187f,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0x82c,0x830,0x1885,0x188b,1,1,1,1,1,1,\n+1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x1891,\n+0x1897,1,1,1,1,1,1,1,1,1,1,1,1,1,0x189d,0x18a3,\n+0x18a9,0x18af,1,1,0x18b5,0x18bb,0x834,0x838,0x18c1,0x18c7,0x18cd,0x18d3,0x18d9,0x18df,1,1,\n+0x18e5,0x18eb,0x18f1,0x18f7,0x18fd,0x1903,0x83c,0x840,0x1909,0x190f,0x1915,0x191b,0x1921,0x1927,0x192d,0x1933,\n+0x1939,0x193f,0x1945,0x194b,1,1,0x1951,0x1957,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,0xffb8,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffcc,\n 0xffcc,0xffcc,0xffbc,0xffb8,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,\n 0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffbc,0xffc8,0xffcc,0xfe14,0xfe16,0xfe18,0xfe1a,0xfe1c,0xfe1e,0xfe20,0xfe22,\n@@ -281,369 +220,415 @@ static const uint16_t norm2_nfc_data_trieIndex[9976]={\n 1,1,0x85c,0x1987,1,0x860,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,0xffcc,\n 0xffcc,0xffcc,0xffcc,0xffb8,0xffcc,1,1,0xffcc,0xffcc,1,0xffb8,0xffcc,0xffcc,0xffb8,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,0xfe48,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+0xfe48,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,\n+0xffb8,0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffb8,0xffb8,0xffb8,0xffcc,0xffb8,0xffb8,0xffcc,0xffb8,0xffcc,0xffcc,\n+0xffb8,0xffcc,0xffb8,0xffcc,0xffb8,0xffcc,0xffb8,0xffcc,0xffcc,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0xffcc,0xffb8,0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffb8,0xffb8,0xffb8,0xffcc,0xffb8,0xffb8,0xffcc,0xffb8,0xffcc,\n-0xffcc,0xffcc,0xffb8,0xffcc,0xffb8,0xffcc,0xffb8,0xffcc,0xffb8,0xffcc,0xffcc,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,0xffcc,\n+0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffcc,1,1,1,1,1,1,1,1,1,\n+0xffb8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,0xffcc,0xffcc,\n+0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,0xffb8,0xffb8,0xffb8,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffcc,1,1,1,1,\n-1,1,1,1,1,0xffb8,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,0xffcc,\n-0xffcc,0xffcc,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,0xffcc,\n-0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,0xffb8,0xffb8,0xffb8,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,0xffb8,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n-0xffcc,0xffcc,1,0xffb8,0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,0xffb8,\n-0xfe36,0xfe38,0xfe3a,0xffcc,0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffb8,0xffb8,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n-1,1,1,1,1,1,1,1,0x864,0x198d,1,1,1,1,1,1,\n-0x868,0x1993,1,0x86c,0x1999,1,1,1,1,1,1,1,0xfc0e,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,1,1,\n-1,0xffcc,0xffb8,0xffcc,0xffcc,1,1,1,0x29dc,0x29e2,0x29e8,0x29ee,0x29f4,0x29fa,0x2a00,0x2a06,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xffb8,\n+0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,0xffb8,\n+0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,0xffb8,0xfe36,0xfe38,0xfe3a,0xffcc,\n+0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffb8,0xffb8,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0xfe0e,1,0xfc00,1,\n-1,1,1,1,1,1,1,0x870,1,1,1,0x199f,0x19a5,0xfe12,1,1,\n-1,1,1,1,1,1,1,0xfc00,1,1,1,1,0x2a0c,0x2a12,1,0x2a18,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,1,\n+1,1,1,1,0x864,0x198d,1,1,1,1,1,1,0x868,0x1993,1,0x86c,\n+0x1999,1,1,1,1,1,1,1,0xfc0e,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0xfe12,1,1,1,0xffcc,0xffb8,0xffcc,0xffcc,1,1,\n+1,0x29dc,0x29e2,0x29e8,0x29ee,0x29f4,0x29fa,0x2a00,0x2a06,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,0x2a1e,1,1,0x2a24,1,1,1,1,1,0xfe0e,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,1,1,\n-1,1,1,1,1,1,1,1,1,0x2a2a,0x2a30,0x2a36,1,1,0x2a3c,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0xfe0e,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,0xfe0e,1,0xfc00,1,1,1,1,1,1,1,0x870,\n+1,1,1,0x199f,0x19a5,0xfe12,1,1,1,1,1,1,1,1,1,0xfc00,\n+1,1,1,1,0x2a0c,0x2a12,1,0x2a18,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0xffcc,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,0x2a1e,1,1,0x2a24,1,1,\n+1,1,1,0xfe0e,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,0xfe12,1,1,1,1,1,1,1,1,1,1,1,0x2a2a,0x2a30,0x2a36,\n+1,1,0x2a3c,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe0e,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,0x878,0x19ab,1,1,0x19b1,0x19b7,0xfe12,1,1,1,1,1,1,\n-1,1,0xfc00,0xfc00,1,1,1,1,0x2a42,0x2a48,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x884,1,\n-0x19bd,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,0xfc00,1,1,1,1,1,1,1,0x888,0x890,1,1,0x19c3,0x19c9,\n-0x19cf,0xfe12,1,1,1,1,1,1,1,1,1,0xfc00,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+0x878,0x19ab,1,1,0x19b1,0x19b7,0xfe12,1,1,1,1,1,1,1,1,0xfc00,\n+0xfc00,1,1,1,1,0x2a42,0x2a48,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0x884,1,0x19bd,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,0xfc00,1,1,1,1,1,1,0x888,0x890,1,1,\n+0x19c3,0x19c9,0x19cf,0xfe12,1,1,1,1,1,1,1,1,1,0xfc00,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,0x894,1,0x19d5,1,1,1,1,0xfe12,1,1,\n 1,1,1,1,1,0xfea8,0xfcb6,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,0xfe0e,1,1,0x898,0x19db,1,0xfc00,1,1,1,0x89c,0x19e1,\n-0x19e7,1,0xdc4,0x19ef,1,0xfe12,1,1,1,1,1,1,1,0xfc00,0xfc00,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,0xfe12,0xfe12,1,0xfc00,1,\n-1,1,1,1,1,1,0x8a8,0x8b0,1,1,0x19f7,0x19fd,0x1a03,0xfe12,1,1,\n-1,1,1,1,1,1,1,0xfc00,1,1,1,1,1,1,1,1,\n-1,1,0xfc12,1,1,1,1,0xfc00,1,1,1,1,1,1,1,1,\n-1,0x8b4,0x1a09,1,0xdce,0x1a11,0x1a19,0xfc00,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0xfece,0xfece,0xfe12,1,1,1,1,1,1,1,1,1,0xfed6,0xfed6,0xfed6,0xfed6,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xfeec,0xfeec,1,1,1,1,1,1,\n-1,1,1,1,0xfef4,0xfef4,0xfef4,0xfef4,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0xffb8,0xffb8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,0xffb8,1,0xffb8,1,0xffb0,1,1,\n-1,1,1,1,1,1,1,0x2a4f,1,1,1,1,1,1,1,1,\n-1,0x2a55,1,1,1,1,0x2a5b,1,1,1,1,0x2a61,1,1,1,1,\n-0x2a67,1,1,1,1,1,1,1,1,1,1,1,1,0x2a6d,1,1,\n-1,1,1,1,1,0xff02,0xff04,0x3c40,0xff08,0x3c48,0x2a72,1,0x2a78,1,0xff04,0xff04,\n-0xff04,0xff04,1,1,0xff04,0x3c50,0xffcc,0xffcc,0xfe12,1,0xffcc,0xffcc,1,1,1,1,\n-1,1,1,1,1,1,1,0x2a7f,1,1,1,1,1,1,1,1,\n-1,0x2a85,1,1,1,1,0x2a8b,1,1,1,1,0x2a91,1,1,1,1,\n-0x2a97,1,1,1,1,1,1,1,1,1,1,1,1,0x2a9d,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,0xfe0e,1,1,0x898,0x19db,1,0xfc00,1,1,1,0x89c,0x19e1,0x19e7,\n+1,0xdc4,0x19ef,1,0xfe12,1,1,1,1,1,1,1,0xfc00,0xfc00,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0xfe12,0xfe12,1,0xfc00,1,1,1,\n+1,1,1,0x8a8,0x8b0,1,1,0x19f7,0x19fd,0x1a03,0xfe12,1,1,1,1,1,\n+1,1,1,1,0xfc00,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,0xfc12,1,1,\n+1,1,0xfc00,1,1,1,1,1,1,1,1,1,0x8b4,0x1a09,1,0xdce,\n+0x1a11,0x1a19,0xfc00,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,0xfece,0xfece,0xfe12,1,1,\n+1,1,1,1,1,1,0xfed6,0xfed6,0xfed6,0xfed6,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,0xfeec,0xfeec,1,1,1,1,1,1,1,1,0xfef4,0xfef4,0xfef4,0xfef4,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,0xffb8,0xffb8,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,0xffb8,1,0xffb8,1,0xffb0,1,1,1,1,1,1,0x2a4f,1,1,1,\n+1,1,1,1,1,1,0x2a55,1,1,1,1,0x2a5b,1,1,1,1,\n+0x2a61,1,1,1,1,0x2a67,1,1,1,1,1,1,1,1,1,1,\n+1,1,0x2a6d,1,1,1,1,1,1,1,0xff02,0xff04,0x3c40,0xff08,0x3c48,0x2a72,\n+1,0x2a78,1,0xff04,0xff04,0xff04,0xff04,1,1,0xff04,0x3c50,0xffcc,0xffcc,0xfe12,1,0xffcc,\n+0xffcc,1,1,1,1,1,1,1,1,1,1,1,0x2a7f,1,1,1,\n+1,1,1,1,1,1,0x2a85,1,1,1,1,0x2a8b,1,1,1,1,\n+0x2a91,1,1,1,1,0x2a97,1,1,1,1,1,1,1,1,1,1,\n+1,1,0x2a9d,1,1,1,1,1,1,0xffb8,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,0x8c0,0x1a1f,1,1,1,1,1,1,1,0xfc00,1,1,1,\n+1,1,1,1,1,0xfe0e,1,0xfe12,0xfe12,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,0xffb8,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,0x8c0,0x1a1f,1,1,1,1,1,1,1,0xfc00,1,1,1,1,1,\n-1,1,1,0xfe0e,1,0xfe12,0xfe12,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,0xffb8,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,1,1,1,\n+1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,\n+2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,0xfe12,1,1,1,1,1,1,1,1,1,1,0xffcc,1,1,\n-1,1,1,1,1,1,1,1,1,0xffc8,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,0xffbc,0xffcc,0xffb8,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,\n-0xffb8,1,1,1,1,1,1,1,0xfe12,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,\n-0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,0xffb8,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,0xffb8,\n-0xffb8,0xffb8,0xffb8,0xffcc,0xffcc,0xffb8,1,1,1,1,1,1,1,0x8c4,0x1a25,0x8c8,\n-0x1a2b,0x8cc,0x1a31,0x8d0,0x1a37,0x8d4,0x1a3d,1,1,0x8d8,0x1a43,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0xfe0e,0xfc00,1,1,1,1,0x8dc,0x1a49,0x8e0,0x1a4f,0x8e4,0x8e8,0x1a55,0x1a5b,0x8ec,0x1a61,\n-0xfe12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,\n-0xffb8,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,0xfe12,0xfe12,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe0e,1,\n-1,1,1,1,1,1,1,1,1,1,0xfe12,0xfe12,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,\n+0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,0xfe0e,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,0xffcc,0xffcc,0xffcc,1,0xfe02,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,0xffcc,\n-0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,1,0xfe02,0xfe02,0xfe02,0xfe02,0xfe02,0xfe02,0xfe02,1,1,1,\n-1,0xffb8,1,1,1,1,1,1,0xffcc,1,1,1,0xffcc,0xffcc,1,1,\n-1,1,1,1,0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffcc,\n-0xffcc,0xffd4,0xffac,0xffb8,0xff94,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n-0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffd0,0xffc8,\n-0xffc8,0xffb8,1,0xffcc,0xffd2,0xffb8,0xffcc,0xffb8,0x1a66,0x1a6c,0x1a72,0x1a78,0x1a7f,0x1a85,0x1a8b,0x1a91,\n-0x1a99,0x1aa3,0x1aaa,0x1ab0,0x1ab6,0x1abc,0x1ac2,0x1ac8,0x1acf,0x1ad5,0x1ada,0x1ae0,0x1ae8,0x1af2,0x1afc,0x1b06,\n-0x1b0e,0x1b14,0x1b1a,0x1b20,0x1b29,0x1b33,0x1b3b,0x1b41,0x1b46,0x1b4c,0x1b52,0x1b58,0x1b5e,0x1b64,0x1b6a,0x1b70,\n-0x1b77,0x1b7d,0x1b82,0x1b88,0x1b8e,0x1b94,0x1b9c,0x1ba6,0x1bae,0x1bb4,0x1bba,0x1bc0,0x1bc6,0x1bcc,0xdd8,0xde2,\n-0x1bd4,0x1bde,0x1be6,0x1bec,0x1bf2,0x1bf8,0x1bfe,0x1c04,0x1c0a,0x1c10,0x1c17,0x1c1d,0x1c22,0x1c28,0x1c2e,0x1c34,\n-0x1c3a,0x1c40,0x1c46,0x1c4c,0x1c54,0x1c5e,0x1c68,0x1c72,0x1c7c,0x1c86,0x1c90,0x1c9a,0x1ca3,0x1ca9,0x1caf,0x1cb5,\n-0x1cba,0x1cc0,0xdec,0xdf6,0x1cc8,0x1cd2,0x1cda,0x1ce0,0x1ce6,0x1cec,0xe00,0xe0a,0x1cf4,0x1cfe,0x1d08,0x1d12,\n-0x1d1c,0x1d26,0x1d2e,0x1d34,0x1d3a,0x1d40,0x1d46,0x1d4c,0x1d52,0x1d58,0x1d5e,0x1d64,0x1d6a,0x1d70,0x1d76,0x1d7c,\n-0x1d84,0x1d8e,0x1d98,0x1da2,0x1daa,0x1db0,0x1db7,0x1dbd,0x1dc2,0x1dc8,0x1dce,0x1dd4,0x1dda,0x1de0,0x1de6,0x1dec,\n-0x1df3,0x1df9,0x1dff,0x1e05,0x1e0b,0x1e11,0x1e16,0x1e1c,0x1e22,0x1e28,0x1e2f,0x1e35,0x1e3b,0x1e41,0x1e46,0x1e4c,\n-0x1e52,0x1e58,1,0x1e5f,1,1,1,1,0xe14,0xe22,0x1e64,0x1e6a,0x1e72,0x1e7c,0x1e86,0x1e90,\n-0x1e9a,0x1ea4,0x1eae,0x1eb8,0x1ec2,0x1ecc,0x1ed6,0x1ee0,0x1eea,0x1ef4,0x1efe,0x1f08,0x1f12,0x1f1c,0x1f26,0x1f30,\n-0xe30,0xe3a,0x1f38,0x1f3e,0x1f44,0x1f4a,0x1f52,0x1f5c,0x1f66,0x1f70,0x1f7a,0x1f84,0x1f8e,0x1f98,0x1fa2,0x1fac,\n-0x1fb4,0x1fba,0x1fc0,0x1fc6,0xe44,0xe4e,0x1fcc,0x1fd2,0x1fda,0x1fe4,0x1fee,0x1ff8,0x2002,0x200c,0x2016,0x2020,\n-0x202a,0x2034,0x203e,0x2048,0x2052,0x205c,0x2066,0x2070,0x207a,0x2084,0x208e,0x2098,0x20a0,0x20a6,0x20ac,0x20b2,\n-0x20ba,0x20c4,0x20ce,0x20d8,0x20e2,0x20ec,0x20f6,0x2100,0x210a,0x2114,0x211c,0x2122,0x2129,0x212f,0x2134,0x213a,\n-0x2140,0x2146,1,1,1,1,1,1,0xe58,0xe6e,0xe86,0xe94,0xea2,0xeb0,0xebe,0xecc,\n-0xed8,0xeee,0xf06,0xf14,0xf22,0xf30,0xf3e,0xf4c,0xf58,0xf66,0x214f,0x2159,0x2163,0x216d,1,1,\n-0xf74,0xf82,0x2177,0x2181,0x218b,0x2195,1,1,0xf90,0xfa6,0xfbe,0xfcc,0xfda,0xfe8,0xff6,0x1004,\n-0x1010,0x1026,0x103e,0x104c,0x105a,0x1068,0x1076,0x1084,0x1090,0x10a2,0x219f,0x21a9,0x21b3,0x21bd,0x21c7,0x21d1,\n-0x10b4,0x10c6,0x21db,0x21e5,0x21ef,0x21f9,0x2203,0x220d,0x10d8,0x10e6,0x2217,0x2221,0x222b,0x2235,1,1,\n-0x10f4,0x1102,0x223f,0x2249,0x2253,0x225d,1,1,0x1110,0x1122,0x2267,0x2271,0x227b,0x2285,0x228f,0x2299,\n-1,0x1134,1,0x22a3,1,0x22ad,1,0x22b7,0x1146,0x115c,0x1174,0x1182,0x1190,0x119e,0x11ac,0x11ba,\n-0x11c6,0x11dc,0x11f4,0x1202,0x1210,0x121e,0x122c,0x123a,0x1246,0x3b8e,0x22bf,0x3b96,0x1250,0x3b9e,0x22c5,0x3ba6,\n-0x22cb,0x3bae,0x22d1,0x3bb6,0x125a,0x3bbe,1,1,0x22d8,0x22e2,0x22f1,0x2301,0x2311,0x2321,0x2331,0x2341,\n-0x234c,0x2356,0x2365,0x2375,0x2385,0x2395,0x23a5,0x23b5,0x23c0,0x23ca,0x23d9,0x23e9,0x23f9,0x2409,0x2419,0x2429,\n-0x2434,0x243e,0x244d,0x245d,0x246d,0x247d,0x248d,0x249d,0x24a8,0x24b2,0x24c1,0x24d1,0x24e1,0x24f1,0x2501,0x2511,\n-0x251c,0x2526,0x2535,0x2545,0x2555,0x2565,0x2575,0x2585,0x258f,0x2595,0x259d,0x25a4,0x25ad,1,0x1264,0x25b7,\n-0x25bf,0x25c5,0x25cb,0x3bc6,0x25d0,1,0x2aa2,0x8f0,1,0x25d7,0x25df,0x25e6,0x25ef,1,0x126e,0x25f9,\n-0x2601,0x3bce,0x2607,0x3bd6,0x260c,0x2613,0x2619,0x261f,0x2625,0x262b,0x2633,0x3be0,1,1,0x263b,0x2643,\n-0x264b,0x2651,0x2657,0x3bea,1,0x265d,0x2663,0x2669,0x266f,0x2675,0x267d,0x3bf4,0x2685,0x268b,0x2691,0x2699,\n-0x26a1,0x26a7,0x26ad,0x3bfe,0x26b3,0x26b9,0x3c06,0x2aa7,1,1,0x26c1,0x26c8,0x26d1,1,0x1278,0x26db,\n-0x26e3,0x3c0e,0x26e9,0x3c16,0x26ee,0x2aab,0x8fc,1,0xfa09,0xfa09,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xfe02,0xfe02,0xffcc,0xffcc,0xffcc,0xffcc,\n-0xfe02,0xfe02,0xfe02,0xffcc,0xffcc,1,1,1,1,0xffcc,1,1,1,0xfe02,0xfe02,0xffcc,\n-0xffb8,0xffcc,0xfe02,0xfe02,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,0x2aae,1,1,1,0x2ab2,0x3c1e,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,0x908,1,0x90c,1,0x910,1,1,1,1,1,0x26f5,0x26fb,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x2701,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,0x2707,0x270d,0x2713,0x914,1,0x918,1,0x91c,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,0x920,0x2719,1,1,1,0x924,0x271f,1,0x928,\n-0x2725,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,0x92c,0x272b,0x930,0x2731,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0x934,1,1,1,1,0x2737,1,0x938,0x273d,0x93c,1,0x2743,0x940,0x2749,1,1,\n-1,0x944,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,0x274f,0x948,0x2755,1,0x94c,0x950,1,1,1,1,1,1,\n-1,0x275b,0x2761,0x2767,0x276d,0x2773,0x954,0x958,0x2779,0x277f,0x95c,0x960,0x2785,0x278b,0x964,0x968,\n-0x96c,0x970,1,1,0x2791,0x2797,0x974,0x978,0x279d,0x27a3,0x97c,0x980,0x27a9,0x27af,1,1,\n-1,1,1,1,1,0x984,0x988,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,0x98c,1,1,1,1,1,0x990,0x994,1,0x998,\n-0x27b5,0x27bb,0x27c1,0x27c7,1,1,0x99c,0x9a0,0x9a4,0x9a8,1,1,1,1,1,1,\n-1,1,1,1,0x27cd,0x27d3,0x27d9,0x27df,1,1,1,1,1,1,0x27e5,0x27eb,\n-0x27f1,0x27f7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,0x2ab7,0x2abb,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,0x2abf,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,0xfe12,0xffcc,0xffcc,0xffcc,0xffcc,\n-0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n-0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,\n-1,1,1,1,1,1,0xffb4,0xffc8,0xffd0,0xffbc,0xffc0,0xffc0,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x9ac,1,\n-1,1,1,0x9b0,0x27fd,0x9b4,0x2803,0x9b8,0x2809,0x9bc,0x280f,0x9c0,0x2815,0x9c4,0x281b,0x9c8,\n-0x2821,0x9cc,0x2827,0x9d0,0x282d,0x9d4,0x2833,0x9d8,0x2839,0x9dc,0x283f,1,0x9e0,0x2845,0x9e4,0x284b,\n-0x9e8,0x2851,1,1,1,1,1,0x9ec,0x2857,0x285d,0x9f4,0x2863,0x2869,0x9fc,0x286f,0x2875,\n-0xa04,0x287b,0x2881,0xa0c,0x2887,0x288d,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0x2893,1,1,1,\n-1,0xfc10,0xfc10,1,1,0xa14,0x2899,1,1,1,1,1,1,1,0xa18,1,\n-1,1,1,0xa1c,0x289f,0xa20,0x28a5,0xa24,0x28ab,0xa28,0x28b1,0xa2c,0x28b7,0xa30,0x28bd,0xa34,\n-0x28c3,0xa38,0x28c9,0xa3c,0x28cf,0xa40,0x28d5,0xa44,0x28db,0xa48,0x28e1,1,0xa4c,0x28e7,0xa50,0x28ed,\n-0xa54,0x28f3,1,1,1,1,1,0xa58,0x28f9,0x28ff,0xa60,0x2905,0x290b,0xa68,0x2911,0x2917,\n-0xa70,0x291d,0x2923,0xa78,0x2929,0x292f,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,0xa80,0xa84,0xa88,0xa8c,1,0x2935,1,1,0x293b,\n-0x2941,0x2947,0x294d,1,1,0xa90,0x2953,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,0xffcc,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,\n-0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,0xffcc,0xffcc,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xffcc,0xffcc,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,0xfe12,1,1,1,1,1,\n+1,1,1,1,1,1,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,\n+0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,0xfe12,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n-0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,0xffb8,0xffb8,0xffb8,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,0xfe12,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xfe12,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xffcc,1,0xffcc,0xffcc,0xffb8,1,1,0xffcc,\n-0xffcc,1,1,1,1,1,0xffcc,0xffcc,1,0xffcc,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,0xfe12,1,1,1,1,1,\n-1,1,1,1,0x2ac5,0x2ac9,0x2acd,0x2ad1,0x2ad5,0x2ad9,0x2add,0x2ae1,0x2ae1,0x2ae5,0x2ae9,0x2aed,\n-0x2af1,0x2af5,0x2af9,0x2afd,0x2b01,0x2b05,0x2b09,0x2b0d,0x2b11,0x2b15,0x2b19,0x2b1d,0x2b21,0x2b25,0x2b29,0x2b2d,\n-0x2b31,0x2b35,0x2b39,0x2b3d,0x2b41,0x2b45,0x2b49,0x2b4d,0x2b51,0x2b55,0x2b59,0x2b5d,0x2b61,0x2b65,0x2b69,0x2b6d,\n-0x2b71,0x2b75,0x2b79,0x2b7d,0x2b81,0x2b85,0x2b89,0x2b8d,0x2b91,0x2b95,0x2b99,0x2b9d,0x2ba1,0x2ba5,0x2ba9,0x2bad,\n-0x2bb1,0x2bb5,0x2bb9,0x2bbd,0x2bc1,0x2bc5,0x2bc9,0x2bcd,0x2bd1,0x2bd5,0x2bd9,0x2bdd,0x2be1,0x2be5,0x2be9,0x2bed,\n-0x2bf1,0x2bf5,0x2bf9,0x2bfd,0x2c01,0x2c05,0x2c09,0x2c0d,0x2c11,0x2c15,0x2c19,0x2c1d,0x2c21,0x2c25,0x2c29,0x2c2d,\n-0x2b11,0x2c31,0x2c35,0x2c39,0x2c3d,0x2c41,0x2c45,0x2c49,0x2c4d,0x2c51,0x2c55,0x2c59,0x2c5d,0x2c61,0x2c65,0x2c69,\n-0x2c6d,0x2c71,0x2c75,0x2c79,0x2c7d,0x2c81,0x2c85,0x2c89,0x2c8d,0x2c91,0x2c95,0x2c99,0x2c9d,0x2ca1,0x2ca5,0x2ca9,\n-0x2cad,0x2cb1,0x2cb5,0x2cb9,0x2cbd,0x2cc1,0x2cc5,0x2cc9,0x2ccd,0x2cd1,0x2cd5,0x2cd9,0x2cdd,0x2ce1,0x2ce5,0x2ce9,\n-0x2ced,0x2cf1,0x2cf5,0x2cf9,0x2cfd,0x2d01,0x2d05,0x2d09,0x2d0d,0x2d11,0x2d15,0x2d19,0x2d1d,0x2d21,0x2d25,0x2d29,\n-0x2d2d,0x2d31,0x2d35,0x2d39,0x2d3d,0x2c79,0x2d41,0x2d45,0x2d49,0x2d4d,0x2d51,0x2d55,0x2d59,0x2d5d,0x2c39,0x2d61,\n-0x2d65,0x2d69,0x2d6d,0x2d71,0x2d75,0x2d79,0x2d7d,0x2d81,0x2d85,0x2d89,0x2d8d,0x2d91,0x2d95,0x2d99,0x2d9d,0x2da1,\n-0x2da5,0x2da9,0x2dad,0x2b11,0x2db1,0x2db5,0x2db9,0x2dbd,0x2dc1,0x2dc5,0x2dc9,0x2dcd,0x2dd1,0x2dd5,0x2dd9,0x2ddd,\n-0x2de1,0x2de5,0x2de9,0x2ded,0x2df1,0x2df5,0x2df9,0x2dfd,0x2e01,0x2e05,0x2e09,0x2e0d,0x2e11,0x2e15,0x2e19,0x2c41,\n-0x2e1d,0x2e21,0x2e25,0x2e29,0x2e2d,0x2e31,0x2e35,0x2e39,0x2e3d,0x2e41,0x2e45,0x2e49,0x2e4d,0x2e51,0x2e55,0x2e59,\n-0x2e5d,0x2e61,0x2e65,0x2e69,0x2e6d,0x2e71,0x2e75,0x2e79,0x2e7d,0x2e81,0x2e85,0x2e89,0x2e8d,0x2e91,0x2e95,0x2e99,\n-0x2e9d,0x2ea1,0x2ea5,0x2ea9,0x2ead,0x2eb1,0x2eb5,0x2eb9,0x2ebd,0x2ec1,0x2ec5,0x2ec9,0x2ecd,0x2ed1,0x2ed5,0x2ed9,\n-0x2edd,0x2ee1,1,1,0x2ee5,1,0x2ee9,1,1,0x2eed,0x2ef1,0x2ef5,0x2ef9,0x2efd,0x2f01,0x2f05,\n-0x2f09,0x2f0d,0x2f11,1,0x2f15,1,0x2f19,1,1,0x2f1d,0x2f21,1,1,1,0x2f25,0x2f29,\n-0x2f2d,0x2f31,0x2f35,0x2f39,0x2f3d,0x2f41,0x2f45,0x2f49,0x2f4d,0x2f51,0x2f55,0x2f59,0x2f5d,0x2f61,0x2f65,0x2f69,\n-0x2f6d,0x2f71,0x2f75,0x2f79,0x2f7d,0x2f81,0x2f85,0x2f89,0x2f8d,0x2f91,0x2f95,0x2f99,0x2f9d,0x2fa1,0x2fa5,0x2fa9,\n-0x2fad,0x2fb1,0x2fb5,0x2fb9,0x2fbd,0x2fc1,0x2fc5,0x2fc9,0x2fcd,0x2fd1,0x2fd5,0x2d15,0x2fd9,0x2fdd,0x2fe1,0x2fe5,\n-0x2fe9,0x2fed,0x2fed,0x2ff1,0x2ff5,0x2ff9,0x2ffd,0x3001,0x3005,0x3009,0x300d,0x2f1d,0x3011,0x3015,0x3019,0x301d,\n-0x3021,0x3027,1,1,0x302b,0x302f,0x3033,0x3037,0x303b,0x303f,0x3043,0x3047,0x2f55,0x304b,0x304f,0x3053,\n-0x2ee5,0x3057,0x305b,0x305f,0x3063,0x3067,0x306b,0x306f,0x3073,0x3077,0x307b,0x307f,0x3083,0x2f79,0x3087,0x2f7d,\n-0x308b,0x308f,0x3093,0x3097,0x309b,0x2ee9,0x2b65,0x309f,0x30a3,0x30a7,0x2c7d,0x2dd9,0x30ab,0x30af,0x2f99,0x30b3,\n-0x2f9d,0x30b7,0x30bb,0x30bf,0x2ef1,0x30c3,0x30c7,0x30cb,0x30cf,0x30d3,0x2ef5,0x30d7,0x30db,0x30df,0x30e3,0x30e7,\n-0x30eb,0x2fd5,0x30ef,0x30f3,0x2d15,0x30f7,0x2fe5,0x30fb,0x30ff,0x3103,0x3107,0x310b,0x2ff9,0x310f,0x2f19,0x3113,\n-0x2ffd,0x2c31,0x3117,0x3001,0x311b,0x3009,0x311f,0x3123,0x3127,0x312b,0x312f,0x3011,0x2f09,0x3133,0x3015,0x3137,\n-0x3019,0x313b,0x2ae1,0x313f,0x3145,0x314b,0x3151,0x3155,0x3159,0x315d,0x3163,0x3169,0x316f,0x3173,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,0x3176,0xfe34,0x317c,\n-1,1,1,1,1,1,1,1,1,1,0x3182,0x3188,0x3190,0x319a,0x31a2,0x31a8,\n-0x31ae,0x31b4,0x31ba,0x31c0,0x31c6,0x31cc,0x31d2,1,0x31d8,0x31de,0x31e4,0x31ea,0x31f0,1,0x31f6,1,\n-0x31fc,0x3202,1,0x3208,0x320e,1,0x3214,0x321a,0x3220,0x3226,0x322c,0x3232,0x3238,0x323e,0x3244,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,0xffcc,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,0xffb8,1,1,\n-0xffb8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,0xffb8,1,0xffcc,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0xffcc,0xfe02,0xffb8,1,1,1,1,0xfe12,1,1,1,1,1,0xffcc,0xffb8,1,\n+1,0xfe12,1,1,1,1,1,1,1,1,1,1,0xffcc,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,0xffb8,0xffb8,0xffcc,0xffcc,0xffcc,0xffb8,0xffcc,0xffb8,0xffb8,0xffb8,\n-0xffb8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,0xa94,0x2959,0xa9a,\n-0x2963,1,1,1,1,1,1,1,1,0xaa0,1,1,1,1,1,0x296d,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,0xfc0e,1,\n-1,1,1,1,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0xffc8,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,0xfc00,1,1,1,1,1,1,0x2977,0x2981,\n-1,0xaa6,0xaac,0xfe12,0xfe12,1,1,1,1,1,1,1,1,1,1,1,\n-0xfe12,1,1,1,1,1,1,1,1,1,0xfe0e,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,0xfe12,0xfe0e,1,1,1,1,1,1,1,1,1,1,0xfe0e,0xfe12,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,0xfe0e,0xfe0e,1,0xfc00,1,\n-1,1,1,1,1,1,1,0xab2,1,1,1,0x298b,0x2995,0xfe12,1,1,\n-1,1,1,1,1,1,1,0xfc00,1,1,1,1,1,1,1,1,\n-1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,\n-0xffcc,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,1,\n-1,1,0xfe0e,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,0xffcc,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0xfc00,1,1,1,\n-1,1,1,1,1,0xabe,0xfc00,0x299f,0x29a9,0xfc00,0x29b3,1,1,1,0xfe12,0xfe0e,\n+0xffbc,0xffcc,0xffb8,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,0xffcc,0xffb8,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfc00,\n-1,1,1,1,1,1,1,1,0xad0,0xad6,0x29bd,0x29c7,1,1,1,0xfe12,\n-0xfe0e,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,0xfe12,0xfe0e,1,1,1,1,1,1,1,1,1,1,1,0xfe12,\n+1,1,1,0xfe12,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n+1,1,0xffb8,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,0xfe12,0xfe0e,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,0xfe12,1,1,1,1,1,1,1,1,0xfe0e,1,\n-0xfe12,0xfe12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,\n+1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,0xffcc,\n+0xffb8,1,1,1,1,1,0x8c4,0x1a25,0x8c8,0x1a2b,0x8cc,0x1a31,0x8d0,0x1a37,0x8d4,0x1a3d,\n+1,1,0x8d8,0x1a43,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,0xfe0e,0xfc00,1,1,1,1,0x8dc,0x1a49,0x8e0,0x1a4f,0x8e4,\n+0x8e8,0x1a55,0x1a5b,0x8ec,0x1a61,0xfe12,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-0xfe02,0xfe02,0xfe02,0xfe02,0xfe02,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,0xffb8,0xffcc,0xffcc,\n+0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,\n+0xfe12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe02,1,\n+1,1,1,1,1,1,1,0xfe0e,1,1,1,1,1,1,1,1,\n+1,1,1,0xfe12,0xfe12,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,0xffcc,0xffcc,0xffcc,1,0xfe02,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,\n+0xffcc,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,1,0xfe02,0xfe02,0xfe02,0xfe02,0xfe02,0xfe02,0xfe02,1,1,\n+1,1,0xffb8,1,1,1,1,1,1,0xffcc,1,1,1,0xffcc,0xffcc,1,\n+1,1,1,1,1,0xffcc,0xffcc,0xffb8,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,\n+0xffcc,0xffcc,0xffd4,0xffac,0xffb8,0xff94,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n+0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n+0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffd0,0xffc8,0xffc8,0xffb8,1,\n+0xffcc,0xffd2,0xffb8,0xffcc,0xffb8,0x1a66,0x1a6c,0x1a72,0x1a78,0x1a7f,0x1a85,0x1a8b,0x1a91,0x1a99,0x1aa3,0x1aaa,\n+0x1ab0,0x1ab6,0x1abc,0x1ac2,0x1ac8,0x1acf,0x1ad5,0x1ada,0x1ae0,0x1ae8,0x1af2,0x1afc,0x1b06,0x1b0e,0x1b14,0x1b1a,\n+0x1b20,0x1b29,0x1b33,0x1b3b,0x1b41,0x1b46,0x1b4c,0x1b52,0x1b58,0x1b5e,0x1b64,0x1b6a,0x1b70,0x1b77,0x1b7d,0x1b82,\n+0x1b88,0x1b8e,0x1b94,0x1b9c,0x1ba6,0x1bae,0x1bb4,0x1bba,0x1bc0,0x1bc6,0x1bcc,0xdd8,0xde2,0x1bd4,0x1bde,0x1be6,\n+0x1bec,0x1bf2,0x1bf8,0x1bfe,0x1c04,0x1c0a,0x1c10,0x1c17,0x1c1d,0x1c22,0x1c28,0x1c2e,0x1c34,0x1c3a,0x1c40,0x1c46,\n+0x1c4c,0x1c54,0x1c5e,0x1c68,0x1c72,0x1c7c,0x1c86,0x1c90,0x1c9a,0x1ca3,0x1ca9,0x1caf,0x1cb5,0x1cba,0x1cc0,0xdec,\n+0xdf6,0x1cc8,0x1cd2,0x1cda,0x1ce0,0x1ce6,0x1cec,0xe00,0xe0a,0x1cf4,0x1cfe,0x1d08,0x1d12,0x1d1c,0x1d26,0x1d2e,\n+0x1d34,0x1d3a,0x1d40,0x1d46,0x1d4c,0x1d52,0x1d58,0x1d5e,0x1d64,0x1d6a,0x1d70,0x1d76,0x1d7c,0x1d84,0x1d8e,0x1d98,\n+0x1da2,0x1daa,0x1db0,0x1db7,0x1dbd,0x1dc2,0x1dc8,0x1dce,0x1dd4,0x1dda,0x1de0,0x1de6,0x1dec,0x1df3,0x1df9,0x1dff,\n+0x1e05,0x1e0b,0x1e11,0x1e16,0x1e1c,0x1e22,0x1e28,0x1e2f,0x1e35,0x1e3b,0x1e41,0x1e46,0x1e4c,0x1e52,0x1e58,1,\n+0x1e5f,1,1,1,1,0xe14,0xe22,0x1e64,0x1e6a,0x1e72,0x1e7c,0x1e86,0x1e90,0x1e9a,0x1ea4,0x1eae,\n+0x1eb8,0x1ec2,0x1ecc,0x1ed6,0x1ee0,0x1eea,0x1ef4,0x1efe,0x1f08,0x1f12,0x1f1c,0x1f26,0x1f30,0xe30,0xe3a,0x1f38,\n+0x1f3e,0x1f44,0x1f4a,0x1f52,0x1f5c,0x1f66,0x1f70,0x1f7a,0x1f84,0x1f8e,0x1f98,0x1fa2,0x1fac,0x1fb4,0x1fba,0x1fc0,\n+0x1fc6,0xe44,0xe4e,0x1fcc,0x1fd2,0x1fda,0x1fe4,0x1fee,0x1ff8,0x2002,0x200c,0x2016,0x2020,0x202a,0x2034,0x203e,\n+0x2048,0x2052,0x205c,0x2066,0x2070,0x207a,0x2084,0x208e,0x2098,0x20a0,0x20a6,0x20ac,0x20b2,0x20ba,0x20c4,0x20ce,\n+0x20d8,0x20e2,0x20ec,0x20f6,0x2100,0x210a,0x2114,0x211c,0x2122,0x2129,0x212f,0x2134,0x213a,0x2140,0x2146,1,\n+1,1,1,1,1,0xe58,0xe6e,0xe86,0xe94,0xea2,0xeb0,0xebe,0xecc,0xed8,0xeee,0xf06,\n+0xf14,0xf22,0xf30,0xf3e,0xf4c,0xf58,0xf66,0x214f,0x2159,0x2163,0x216d,1,1,0xf74,0xf82,0x2177,\n+0x2181,0x218b,0x2195,1,1,0xf90,0xfa6,0xfbe,0xfcc,0xfda,0xfe8,0xff6,0x1004,0x1010,0x1026,0x103e,\n+0x104c,0x105a,0x1068,0x1076,0x1084,0x1090,0x10a2,0x219f,0x21a9,0x21b3,0x21bd,0x21c7,0x21d1,0x10b4,0x10c6,0x21db,\n+0x21e5,0x21ef,0x21f9,0x2203,0x220d,0x10d8,0x10e6,0x2217,0x2221,0x222b,0x2235,1,1,0x10f4,0x1102,0x223f,\n+0x2249,0x2253,0x225d,1,1,0x1110,0x1122,0x2267,0x2271,0x227b,0x2285,0x228f,0x2299,1,0x1134,1,\n+0x22a3,1,0x22ad,1,0x22b7,0x1146,0x115c,0x1174,0x1182,0x1190,0x119e,0x11ac,0x11ba,0x11c6,0x11dc,0x11f4,\n+0x1202,0x1210,0x121e,0x122c,0x123a,0x1246,0x3b8e,0x22bf,0x3b96,0x1250,0x3b9e,0x22c5,0x3ba6,0x22cb,0x3bae,0x22d1,\n+0x3bb6,0x125a,0x3bbe,1,1,0x22d8,0x22e2,0x22f1,0x2301,0x2311,0x2321,0x2331,0x2341,0x234c,0x2356,0x2365,\n+0x2375,0x2385,0x2395,0x23a5,0x23b5,0x23c0,0x23ca,0x23d9,0x23e9,0x23f9,0x2409,0x2419,0x2429,0x2434,0x243e,0x244d,\n+0x245d,0x246d,0x247d,0x248d,0x249d,0x24a8,0x24b2,0x24c1,0x24d1,0x24e1,0x24f1,0x2501,0x2511,0x251c,0x2526,0x2535,\n+0x2545,0x2555,0x2565,0x2575,0x2585,0x258f,0x2595,0x259d,0x25a4,0x25ad,1,0x1264,0x25b7,0x25bf,0x25c5,0x25cb,\n+0x3bc6,0x25d0,1,0x2aa2,0x8f0,1,0x25d7,0x25df,0x25e6,0x25ef,1,0x126e,0x25f9,0x2601,0x3bce,0x2607,\n+0x3bd6,0x260c,0x2613,0x2619,0x261f,0x2625,0x262b,0x2633,0x3be0,1,1,0x263b,0x2643,0x264b,0x2651,0x2657,\n+0x3bea,1,0x265d,0x2663,0x2669,0x266f,0x2675,0x267d,0x3bf4,0x2685,0x268b,0x2691,0x2699,0x26a1,0x26a7,0x26ad,\n+0x3bfe,0x26b3,0x26b9,0x3c06,0x2aa7,1,1,0x26c1,0x26c8,0x26d1,1,0x1278,0x26db,0x26e3,0x3c0e,0x26e9,\n+0x3c16,0x26ee,0x2aab,0x8fc,1,0xfa09,0xfa09,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,0xffcc,0xffcc,0xfe02,0xfe02,0xffcc,0xffcc,0xffcc,0xffcc,0xfe02,0xfe02,0xfe02,\n+0xffcc,0xffcc,1,1,1,1,0xffcc,1,1,1,0xfe02,0xfe02,0xffcc,0xffb8,0xffcc,0xfe02,\n+0xfe02,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,0x2aae,1,1,1,\n+0x2ab2,0x3c1e,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0x908,1,0x90c,1,0x910,1,1,1,1,1,\n+0x26f5,0x26fb,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,0x2701,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0x2707,0x270d,0x2713,0x914,1,0x918,1,0x91c,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0x920,0x2719,1,1,1,0x924,0x271f,\n+1,0x928,0x2725,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0x92c,0x272b,0x930,0x2731,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,0x934,1,1,1,0x2737,1,0x938,0x273d,0x93c,1,0x2743,0x940,0x2749,1,\n+1,1,0x944,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,0x274f,0x948,0x2755,1,0x94c,0x950,1,1,1,1,1,\n+1,1,0x275b,0x2761,0x2767,0x276d,0x2773,0x954,0x958,0x2779,0x277f,0x95c,0x960,0x2785,0x278b,0x964,\n+0x968,0x96c,0x970,1,1,0x2791,0x2797,0x974,0x978,0x279d,0x27a3,0x97c,0x980,0x27a9,0x27af,1,\n+1,1,1,1,1,1,0x984,0x988,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,0x98c,1,1,1,1,1,0x990,0x994,1,\n+0x998,0x27b5,0x27bb,0x27c1,0x27c7,1,1,0x99c,0x9a0,0x9a4,0x9a8,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,0x27cd,0x27d3,0x27d9,0x27df,1,\n+1,1,1,1,1,0x27e5,0x27eb,0x27f1,0x27f7,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,0x2ab7,0x2abb,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+0x2abf,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,0x324a,0x3254,\n-0x3268,0x3280,0x3298,0x32b0,0x32c8,0xffb0,0xffb0,0xfe02,0xfe02,0xfe02,1,1,1,0xffc4,0xffb0,0xffb0,\n-0xffb0,0xffb0,0xffb0,1,1,1,1,1,1,1,1,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,\n-0xffb8,0xffb8,0xffb8,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,0x32d6,0x32e0,0x32f4,0x330c,0x3324,0x333c,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,1,1,1,\n+0xfe12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,\n+1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n 0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n-0xffcc,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,1,0xffcc,0xffcc,\n-0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,1,\n-1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xfe0e,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,0x334b,0x334f,0x3353,0x3357,0x335d,0x2f3d,0x3361,0x3365,0x3369,0x336d,0x2f41,0x3371,\n-0x3375,0x3379,0x2f45,0x337f,0x3383,0x3387,0x338b,0x3391,0x3395,0x3399,0x339d,0x33a3,0x33a7,0x33ab,0x33af,0x302f,\n-0x33b3,0x33b9,0x33bd,0x33c1,0x33c5,0x33c9,0x33cd,0x33d1,0x33d5,0x3043,0x2f49,0x2f4d,0x3047,0x33d9,0x33dd,0x2c49,\n-0x33e1,0x2f51,0x33e5,0x33e9,0x33ed,0x33f1,0x33f1,0x33f1,0x33f5,0x33fb,0x33ff,0x3403,0x3407,0x340d,0x3411,0x3415,\n-0x3419,0x341d,0x3421,0x3425,0x3429,0x342d,0x3431,0x3435,0x3439,0x343d,0x343d,0x304f,0x3441,0x3445,0x3449,0x344d,\n-0x2f59,0x3451,0x3455,0x3459,0x2ead,0x345d,0x3461,0x3465,0x3469,0x346d,0x3471,0x3475,0x3479,0x347d,0x3483,0x3487,\n-0x348b,0x348f,0x3493,0x3497,0x349b,0x34a1,0x34a7,0x34ab,0x34af,0x34b3,0x34b7,0x34bb,0x34bf,0x34c3,0x34c7,0x34c7,\n-0x34cb,0x34d1,0x34d5,0x2c39,0x34d9,0x34dd,0x34e3,0x34e7,0x34eb,0x34ef,0x34f3,0x34f7,0x2f6d,0x34fb,0x34ff,0x3503,\n-0x3509,0x350d,0x3513,0x3517,0x351b,0x351f,0x3523,0x3527,0x352b,0x352f,0x3533,0x3537,0x353b,0x353f,0x3545,0x3549,\n-0x354d,0x3551,0x2b61,0x3555,0x355b,0x355f,0x355f,0x3565,0x3569,0x3569,0x356d,0x3571,0x3577,0x357d,0x3581,0x3585,\n-0x3589,0x358d,0x3591,0x3595,0x3599,0x359d,0x35a1,0x2f71,0x35a5,0x35ab,0x35af,0x35b3,0x307f,0x35b3,0x35b7,0x2f79,\n-0x35bb,0x35bf,0x35c3,0x35c7,0x2f7d,0x2af5,0x35cb,0x35cf,0x35d3,0x35d7,0x35db,0x35df,0x35e3,0x35e9,0x35ed,0x35f1,\n-0x35f5,0x35f9,0x35fd,0x3603,0x3607,0x360b,0x360f,0x3613,0x3617,0x361b,0x361f,0x3623,0x2f81,0x3627,0x362b,0x3631,\n-0x3635,0x3639,0x363d,0x2f89,0x3641,0x3645,0x3649,0x364d,0x3651,0x3655,0x3659,0x365d,0x2b65,0x309f,0x3661,0x3665,\n-0x3669,0x366d,0x3673,0x3677,0x367b,0x367f,0x2f8d,0x3683,0x3689,0x368d,0x3691,0x3151,0x3695,0x3699,0x369d,0x36a1,\n-0x36a5,0x36ab,0x36af,0x36b3,0x36b7,0x36bd,0x36c1,0x36c5,0x36c9,0x2c7d,0x36cd,0x36d1,0x36d7,0x36dd,0x36e3,0x36e7,\n-0x36ed,0x36f1,0x36f5,0x36f9,0x36fd,0x2f91,0x2dd9,0x3701,0x3705,0x3709,0x370d,0x3713,0x3717,0x371b,0x371f,0x30af,\n-0x3723,0x3727,0x372d,0x3731,0x3735,0x373b,0x3741,0x3745,0x30b3,0x3749,0x374d,0x3751,0x3755,0x3759,0x375d,0x3761,\n-0x3767,0x376b,0x3771,0x3775,0x377b,0x30bb,0x377f,0x3783,0x3789,0x378d,0x3791,0x3797,0x379d,0x37a1,0x37a5,0x37a9,\n-0x37ad,0x37ad,0x37b1,0x37b5,0x30c3,0x37b9,0x37bd,0x37c1,0x37c5,0x37c9,0x37cf,0x37d3,0x2c45,0x37d9,0x37df,0x37e3,\n-0x37e9,0x37ef,0x37f5,0x37f9,0x30db,0x37fd,0x3803,0x3809,0x380f,0x3815,0x3819,0x3819,0x30df,0x3159,0x381d,0x3821,\n-0x3825,0x3829,0x382f,0x2bad,0x30e7,0x3833,0x3837,0x2fbd,0x383d,0x3843,0x2f05,0x3849,0x384d,0x2fcd,0x3851,0x3855,\n-0x3859,0x385f,0x385f,0x3865,0x3869,0x386d,0x3873,0x3877,0x387b,0x387f,0x3885,0x3889,0x388d,0x3891,0x3895,0x3899,\n-0x389f,0x38a3,0x38a7,0x38ab,0x38af,0x38b3,0x38b7,0x38bd,0x38c3,0x38c7,0x38cd,0x38d1,0x38d7,0x38db,0x2fe5,0x38df,\n-0x38e5,0x38eb,0x38ef,0x38f5,0x38f9,0x38ff,0x3903,0x3907,0x390b,0x390f,0x3913,0x3917,0x391d,0x3923,0x3929,0x3565,\n-0x392f,0x3933,0x3937,0x393b,0x393f,0x3943,0x3947,0x394b,0x394f,0x3953,0x3957,0x395b,0x2c8d,0x3961,0x3965,0x3969,\n-0x396d,0x3971,0x3975,0x2ff1,0x3979,0x397d,0x3981,0x3985,0x3989,0x398f,0x3995,0x399b,0x399f,0x39a3,0x39a7,0x39ab,\n-0x39b1,0x39b5,0x39bb,0x39bf,0x39c3,0x39c9,0x39cf,0x39d3,0x2b99,0x39d7,0x39db,0x39df,0x39e3,0x39e7,0x39eb,0x3103,\n-0x39ef,0x39f3,0x39f7,0x39fb,0x39ff,0x3a03,0x3a07,0x3a0b,0x3a0f,0x3a13,0x3a19,0x3a1d,0x3a21,0x3a25,0x3a29,0x3a2d,\n-0x3a33,0x3a39,0x3a3d,0x3a41,0x3117,0x311b,0x3a45,0x3a49,0x3a4f,0x3a53,0x3a57,0x3a5b,0x3a5f,0x3a65,0x3a6b,0x3a6f,\n-0x3a73,0x3a77,0x3a7d,0x311f,0x3a81,0x3a87,0x3a8d,0x3a91,0x3a95,0x3a99,0x3a9f,0x3aa3,0x3aa7,0x3aab,0x3aaf,0x3ab3,\n-0x3ab7,0x3abb,0x3ac1,0x3ac5,0x3ac9,0x3acd,0x3ad3,0x3ad7,0x3adb,0x3adf,0x3ae3,0x3ae9,0x3aef,0x3af3,0x3af7,0x3afb,\n-0x3b01,0x3b05,0x3137,0x3137,0x3b0b,0x3b0f,0x3b15,0x3b19,0x3b1d,0x3b21,0x3b25,0x3b29,0x3b2d,0x3b31,0x313b,0x3b37,\n-0x3b3b,0x3b3f,0x3b43,0x3b47,0x3b4b,0x3b51,0x3b55,0x3b5b,0x3b61,0x3b67,0x3b6b,0x3b6f,0x3b73,0x3b77,0x3b7b,0x3b7f,\n-0x3b83,0x3b87,1,1,2,2,2,2,2,2,2,2,2,2,2,2,\n-2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,\n-0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,1,1,1,1,1,1,\n-1,1,1,1,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,\n-0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,0xfe00,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0xadc,0x1283,0x1283,0x1283,\n-0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,\n-0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0xadc,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,\n-0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,\n+0xffcc,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,0xffb4,0xffc8,0xffd0,0xffbc,0xffc0,\n+0xffc0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,0x9ac,1,1,1,1,0x9b0,0x27fd,0x9b4,0x2803,0x9b8,0x2809,0x9bc,0x280f,0x9c0,0x2815,\n+0x9c4,0x281b,0x9c8,0x2821,0x9cc,0x2827,0x9d0,0x282d,0x9d4,0x2833,0x9d8,0x2839,0x9dc,0x283f,1,0x9e0,\n+0x2845,0x9e4,0x284b,0x9e8,0x2851,1,1,1,1,1,0x9ec,0x2857,0x285d,0x9f4,0x2863,0x2869,\n+0x9fc,0x286f,0x2875,0xa04,0x287b,0x2881,0xa0c,0x2887,0x288d,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,0x2893,1,1,\n+1,1,0xfc10,0xfc10,1,1,0xa14,0x2899,1,1,1,1,1,1,1,0xa18,\n+1,1,1,1,0xa1c,0x289f,0xa20,0x28a5,0xa24,0x28ab,0xa28,0x28b1,0xa2c,0x28b7,0xa30,0x28bd,\n+0xa34,0x28c3,0xa38,0x28c9,0xa3c,0x28cf,0xa40,0x28d5,0xa44,0x28db,0xa48,0x28e1,1,0xa4c,0x28e7,0xa50,\n+0x28ed,0xa54,0x28f3,1,1,1,1,1,0xa58,0x28f9,0x28ff,0xa60,0x2905,0x290b,0xa68,0x2911,\n+0x2917,0xa70,0x291d,0x2923,0xa78,0x2929,0x292f,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,0xa80,0xa84,0xa88,0xa8c,1,0x2935,1,1,\n+0x293b,0x2941,0x2947,0x294d,1,1,0xa90,0x2953,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,0xffcc,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,\n+0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,0xffcc,0xffcc,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0xffcc,0xffcc,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0xfe12,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,0x1283,0x1283,0x1283,0x1283,\n-0xadc,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,\n-0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x3c54,1,0x3c54,0x3c54,\n-0x3c54,0x3c54,0x3c54,0x3c54,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,0x3c54,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,0x3c54,1,1,1,1,0x3c54,1,1,1,\n-0x3c54,1,0x3c54,1,1,1,1,1,1,1,1,1,1,1,1,1,\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,0x3b87,1,1,1,1,1\n+0xfe12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,\n+0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0xffb8,0xffb8,0xffb8,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xfe12,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,\n+1,0xffcc,0xffcc,0xffb8,1,1,0xffcc,0xffcc,1,1,1,1,1,0xffcc,0xffcc,1,\n+0xffcc,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,0xfe12,1,1,1,1,1,1,1,1,1,0xadc,\n+0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,\n+0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0xadc,0x1283,0x1283,0x1283,0x1283,\n+0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,\n+0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0xadc,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,\n+0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,\n+0x1283,0x1283,0x1283,0xadc,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,\n+0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,0x1283,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,0x3c56,1,0x3c56,0x3c56,0x3c56,\n+0x3c56,0x3c56,0x3c56,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,0x3c56,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,0x3c56,1,1,1,1,0x3c56,\n+1,1,1,0x3c56,1,0x3c56,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,0x3b87,1,0x2ac5,0x2ac9,0x2acd,0x2ad1,0x2ad5,0x2ad9,0x2add,0x2ae1,0x2ae1,0x2ae5,\n+0x2ae9,0x2aed,0x2af1,0x2af5,0x2af9,0x2afd,0x2b01,0x2b05,0x2b09,0x2b0d,0x2b11,0x2b15,0x2b19,0x2b1d,0x2b21,0x2b25,\n+0x2b29,0x2b2d,0x2b31,0x2b35,0x2b39,0x2b3d,0x2b41,0x2b45,0x2b49,0x2b4d,0x2b51,0x2b55,0x2b59,0x2b5d,0x2b61,0x2b65,\n+0x2b69,0x2b6d,0x2b71,0x2b75,0x2b79,0x2b7d,0x2b81,0x2b85,0x2b89,0x2b8d,0x2b91,0x2b95,0x2b99,0x2b9d,0x2ba1,0x2ba5,\n+0x2ba9,0x2bad,0x2bb1,0x2bb5,0x2bb9,0x2bbd,0x2bc1,0x2bc5,0x2bc9,0x2bcd,0x2bd1,0x2bd5,0x2bd9,0x2bdd,0x2be1,0x2be5,\n+0x2be9,0x2bed,0x2bf1,0x2bf5,0x2bf9,0x2bfd,0x2c01,0x2c05,0x2c09,0x2c0d,0x2c11,0x2c15,0x2c19,0x2c1d,0x2c21,0x2c25,\n+0x2c29,0x2c2d,0x2b11,0x2c31,0x2c35,0x2c39,0x2c3d,0x2c41,0x2c45,0x2c49,0x2c4d,0x2c51,0x2c55,0x2c59,0x2c5d,0x2c61,\n+0x2c65,0x2c69,0x2c6d,0x2c71,0x2c75,0x2c79,0x2c7d,0x2c81,0x2c85,0x2c89,0x2c8d,0x2c91,0x2c95,0x2c99,0x2c9d,0x2ca1,\n+0x2ca5,0x2ca9,0x2cad,0x2cb1,0x2cb5,0x2cb9,0x2cbd,0x2cc1,0x2cc5,0x2cc9,0x2ccd,0x2cd1,0x2cd5,0x2cd9,0x2cdd,0x2ce1,\n+0x2ce5,0x2ce9,0x2ced,0x2cf1,0x2cf5,0x2cf9,0x2cfd,0x2d01,0x2d05,0x2d09,0x2d0d,0x2d11,0x2d15,0x2d19,0x2d1d,0x2d21,\n+0x2d25,0x2d29,0x2d2d,0x2d31,0x2d35,0x2d39,0x2d3d,0x2c79,0x2d41,0x2d45,0x2d49,0x2d4d,0x2d51,0x2d55,0x2d59,0x2d5d,\n+0x2c39,0x2d61,0x2d65,0x2d69,0x2d6d,0x2d71,0x2d75,0x2d79,0x2d7d,0x2d81,0x2d85,0x2d89,0x2d8d,0x2d91,0x2d95,0x2d99,\n+0x2d9d,0x2da1,0x2da5,0x2da9,0x2dad,0x2b11,0x2db1,0x2db5,0x2db9,0x2dbd,0x2dc1,0x2dc5,0x2dc9,0x2dcd,0x2dd1,0x2dd5,\n+0x2dd9,0x2ddd,0x2de1,0x2de5,0x2de9,0x2ded,0x2df1,0x2df5,0x2df9,0x2dfd,0x2e01,0x2e05,0x2e09,0x2e0d,0x2e11,0x2e15,\n+0x2e19,0x2c41,0x2e1d,0x2e21,0x2e25,0x2e29,0x2e2d,0x2e31,0x2e35,0x2e39,0x2e3d,0x2e41,0x2e45,0x2e49,0x2e4d,0x2e51,\n+0x2e55,0x2e59,0x2e5d,0x2e61,0x2e65,0x2e69,0x2e6d,0x2e71,0x2e75,0x2e79,0x2e7d,0x2e81,0x2e85,0x2e89,0x2e8d,0x2e91,\n+0x2e95,0x2e99,0x2e9d,0x2ea1,0x2ea5,0x2ea9,0x2ead,0x2eb1,0x2eb5,0x2eb9,0x2ebd,0x2ec1,0x2ec5,0x2ec9,0x2ecd,0x2ed1,\n+0x2ed5,0x2ed9,0x2edd,0x2ee1,1,1,0x2ee5,1,0x2ee9,1,1,0x2eed,0x2ef1,0x2ef5,0x2ef9,0x2efd,\n+0x2f01,0x2f05,0x2f09,0x2f0d,0x2f11,1,0x2f15,1,0x2f19,1,1,0x2f1d,0x2f21,1,1,1,\n+0x2f25,0x2f29,0x2f2d,0x2f31,0x2f35,0x2f39,0x2f3d,0x2f41,0x2f45,0x2f49,0x2f4d,0x2f51,0x2f55,0x2f59,0x2f5d,0x2f61,\n+0x2f65,0x2f69,0x2f6d,0x2f71,0x2f75,0x2f79,0x2f7d,0x2f81,0x2f85,0x2f89,0x2f8d,0x2f91,0x2f95,0x2f99,0x2f9d,0x2fa1,\n+0x2fa5,0x2fa9,0x2fad,0x2fb1,0x2fb5,0x2fb9,0x2fbd,0x2fc1,0x2fc5,0x2fc9,0x2fcd,0x2fd1,0x2fd5,0x2d15,0x2fd9,0x2fdd,\n+0x2fe1,0x2fe5,0x2fe9,0x2fed,0x2fed,0x2ff1,0x2ff5,0x2ff9,0x2ffd,0x3001,0x3005,0x3009,0x300d,0x2f1d,0x3011,0x3015,\n+0x3019,0x301d,0x3021,0x3027,1,1,0x302b,0x302f,0x3033,0x3037,0x303b,0x303f,0x3043,0x3047,0x2f55,0x304b,\n+0x304f,0x3053,0x2ee5,0x3057,0x305b,0x305f,0x3063,0x3067,0x306b,0x306f,0x3073,0x3077,0x307b,0x307f,0x3083,0x2f79,\n+0x3087,0x2f7d,0x308b,0x308f,0x3093,0x3097,0x309b,0x2ee9,0x2b65,0x309f,0x30a3,0x30a7,0x2c7d,0x2dd9,0x30ab,0x30af,\n+0x2f99,0x30b3,0x2f9d,0x30b7,0x30bb,0x30bf,0x2ef1,0x30c3,0x30c7,0x30cb,0x30cf,0x30d3,0x2ef5,0x30d7,0x30db,0x30df,\n+0x30e3,0x30e7,0x30eb,0x2fd5,0x30ef,0x30f3,0x2d15,0x30f7,0x2fe5,0x30fb,0x30ff,0x3103,0x3107,0x310b,0x2ff9,0x310f,\n+0x2f19,0x3113,0x2ffd,0x2c31,0x3117,0x3001,0x311b,0x3009,0x311f,0x3123,0x3127,0x312b,0x312f,0x3011,0x2f09,0x3133,\n+0x3015,0x3137,0x3019,0x313b,0x2ae1,0x313f,0x3145,0x314b,0x3151,0x3155,0x3159,0x315d,0x3163,0x3169,0x316f,0x3173,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0x3176,0xfe34,0x317c,1,1,1,1,1,1,1,\n+1,1,1,0x3182,0x3188,0x3190,0x319a,0x31a2,0x31a8,0x31ae,0x31b4,0x31ba,0x31c0,0x31c6,0x31cc,0x31d2,\n+1,0x31d8,0x31de,0x31e4,0x31ea,0x31f0,1,0x31f6,1,0x31fc,0x3202,1,0x3208,0x320e,1,0x3214,\n+0x321a,0x3220,0x3226,0x322c,0x3232,0x3238,0x323e,0x3244,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n+0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffcc,0xffcc,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0xffb8,1,0xffcc,1,1,1,1,\n+1,1,1,1,0xffcc,0xfe02,0xffb8,1,1,1,1,0xfe12,1,1,1,1,\n+0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,1,1,1,1,0xffb8,0xffb8,0xffcc,0xffcc,\n+0xffcc,0xffb8,0xffcc,0xffb8,0xffb8,0xffb8,1,1,1,1,1,1,1,1,1,0xa94,\n+0x2959,0xa9a,0x2963,1,1,1,1,1,0xaa0,1,1,1,1,1,0x296d,1,\n+1,1,1,1,1,1,1,1,0xfe12,0xfc0e,1,1,1,1,1,1,\n+1,0xfc00,1,1,1,1,1,1,0x2977,0x2981,1,0xaa6,0xaac,0xfe12,0xfe12,1,\n+1,1,1,1,1,1,1,1,1,1,0xfe12,1,1,1,1,1,\n+1,1,1,1,0xfe0e,1,1,1,1,1,0xfe12,0xfe0e,1,1,1,1,\n+1,1,1,1,1,0xfe0e,0xfe12,1,1,1,1,1,1,1,1,1,\n+1,1,0xfe0e,0xfe0e,1,0xfc00,1,1,1,1,1,1,1,0xab2,1,1,\n+1,0x298b,0x2995,0xfe12,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,\n+0xffcc,1,1,1,0xfe12,1,1,1,0xfe0e,1,1,1,1,1,1,1,\n+1,1,0xfc00,1,1,1,1,1,1,1,1,0xabe,0xfc00,0x299f,0x29a9,0xfc00,\n+0x29b3,1,1,0xfe12,0xfe0e,1,1,1,1,1,1,1,1,1,1,1,\n+1,0xad0,0xad6,0x29bd,0x29c7,1,1,1,0xfe12,0xfe0e,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,0xfe12,0xfe0e,1,1,1,1,1,\n+1,1,1,0xfe02,0xfe02,0xfe02,0xfe02,0xfe02,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0xfe02,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,0x324a,0x3254,0x3268,0x3280,0x3298,0x32b0,0x32c8,0xffb0,0xffb0,0xfe02,0xfe02,\n+0xfe02,1,1,1,0xffc4,0xffb0,0xffb0,0xffb0,1,1,1,1,1,1,1,1,\n+0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffb8,0xffb8,1,1,\n+1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,1,\n+1,1,1,1,1,1,1,0x32d6,0x32e0,0x32f4,0x330c,0x3324,0x333c,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,0xffcc,0xffcc,0xffcc,0xffcc,\n+0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,0xffcc,\n+0xffcc,0xffcc,0xffcc,0xffcc,1,0xffcc,0xffcc,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,1,1,1,\n+1,1,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,0xffb8,1,1,1,1,1,1,1,\n+1,1,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xffcc,0xfe0e,1,1,1,1,1,0x334b,0x334f,\n+0x3353,0x3357,0x335d,0x2f3d,0x3361,0x3365,0x3369,0x336d,0x2f41,0x3371,0x3375,0x3379,0x2f45,0x337f,0x3383,0x3387,\n+0x338b,0x3391,0x3395,0x3399,0x339d,0x33a3,0x33a7,0x33ab,0x33af,0x302f,0x33b3,0x33b9,0x33bd,0x33c1,0x33c5,0x33c9,\n+0x33cd,0x33d1,0x33d5,0x3043,0x2f49,0x2f4d,0x3047,0x33d9,0x33dd,0x2c49,0x33e1,0x2f51,0x33e5,0x33e9,0x33ed,0x33f1,\n+0x33f1,0x33f1,0x33f5,0x33fb,0x33ff,0x3403,0x3407,0x340d,0x3411,0x3415,0x3419,0x341d,0x3421,0x3425,0x3429,0x342d,\n+0x3431,0x3435,0x3439,0x343d,0x343d,0x304f,0x3441,0x3445,0x3449,0x344d,0x2f59,0x3451,0x3455,0x3459,0x2ead,0x345d,\n+0x3461,0x3465,0x3469,0x346d,0x3471,0x3475,0x3479,0x347d,0x3483,0x3487,0x348b,0x348f,0x3493,0x3497,0x349b,0x34a1,\n+0x34a7,0x34ab,0x34af,0x34b3,0x34b7,0x34bb,0x34bf,0x34c3,0x34c7,0x34c7,0x34cb,0x34d1,0x34d5,0x2c39,0x34d9,0x34dd,\n+0x34e3,0x34e7,0x34eb,0x34ef,0x34f3,0x34f7,0x2f6d,0x34fb,0x34ff,0x3503,0x3509,0x350d,0x3513,0x3517,0x351b,0x351f,\n+0x3523,0x3527,0x352b,0x352f,0x3533,0x3537,0x353b,0x353f,0x3545,0x3549,0x354d,0x3551,0x2b61,0x3555,0x355b,0x355f,\n+0x355f,0x3565,0x3569,0x3569,0x356d,0x3571,0x3577,0x357d,0x3581,0x3585,0x3589,0x358d,0x3591,0x3595,0x3599,0x359d,\n+0x35a1,0x2f71,0x35a5,0x35ab,0x35af,0x35b3,0x307f,0x35b3,0x35b7,0x2f79,0x35bb,0x35bf,0x35c3,0x35c7,0x2f7d,0x2af5,\n+0x35cb,0x35cf,0x35d3,0x35d7,0x35db,0x35df,0x35e3,0x35e9,0x35ed,0x35f1,0x35f5,0x35f9,0x35fd,0x3603,0x3607,0x360b,\n+0x360f,0x3613,0x3617,0x361b,0x361f,0x3623,0x2f81,0x3627,0x362b,0x3631,0x3635,0x3639,0x363d,0x2f89,0x3641,0x3645,\n+0x3649,0x364d,0x3651,0x3655,0x3659,0x365d,0x2b65,0x309f,0x3661,0x3665,0x3669,0x366d,0x3673,0x3677,0x367b,0x367f,\n+0x2f8d,0x3683,0x3689,0x368d,0x3691,0x3151,0x3695,0x3699,0x369d,0x36a1,0x36a5,0x36ab,0x36af,0x36b3,0x36b7,0x36bd,\n+0x36c1,0x36c5,0x36c9,0x2c7d,0x36cd,0x36d1,0x36d7,0x36dd,0x36e3,0x36e7,0x36ed,0x36f1,0x36f5,0x36f9,0x36fd,0x2f91,\n+0x2dd9,0x3701,0x3705,0x3709,0x370d,0x3713,0x3717,0x371b,0x371f,0x30af,0x3723,0x3727,0x372d,0x3731,0x3735,0x373b,\n+0x3741,0x3745,0x30b3,0x3749,0x374d,0x3751,0x3755,0x3759,0x375d,0x3761,0x3767,0x376b,0x3771,0x3775,0x377b,0x30bb,\n+0x377f,0x3783,0x3789,0x378d,0x3791,0x3797,0x379d,0x37a1,0x37a5,0x37a9,0x37ad,0x37ad,0x37b1,0x37b5,0x30c3,0x37b9,\n+0x37bd,0x37c1,0x37c5,0x37c9,0x37cf,0x37d3,0x2c45,0x37d9,0x37df,0x37e3,0x37e9,0x37ef,0x37f5,0x37f9,0x30db,0x37fd,\n+0x3803,0x3809,0x380f,0x3815,0x3819,0x3819,0x30df,0x3159,0x381d,0x3821,0x3825,0x3829,0x382f,0x2bad,0x30e7,0x3833,\n+0x3837,0x2fbd,0x383d,0x3843,0x2f05,0x3849,0x384d,0x2fcd,0x3851,0x3855,0x3859,0x385f,0x385f,0x3865,0x3869,0x386d,\n+0x3873,0x3877,0x387b,0x387f,0x3885,0x3889,0x388d,0x3891,0x3895,0x3899,0x389f,0x38a3,0x38a7,0x38ab,0x38af,0x38b3,\n+0x38b7,0x38bd,0x38c3,0x38c7,0x38cd,0x38d1,0x38d7,0x38db,0x2fe5,0x38df,0x38e5,0x38eb,0x38ef,0x38f5,0x38f9,0x38ff,\n+0x3903,0x3907,0x390b,0x390f,0x3913,0x3917,0x391d,0x3923,0x3929,0x3565,0x392f,0x3933,0x3937,0x393b,0x393f,0x3943,\n+0x3947,0x394b,0x394f,0x3953,0x3957,0x395b,0x2c8d,0x3961,0x3965,0x3969,0x396d,0x3971,0x3975,0x2ff1,0x3979,0x397d,\n+0x3981,0x3985,0x3989,0x398f,0x3995,0x399b,0x399f,0x39a3,0x39a7,0x39ab,0x39b1,0x39b5,0x39bb,0x39bf,0x39c3,0x39c9,\n+0x39cf,0x39d3,0x2b99,0x39d7,0x39db,0x39df,0x39e3,0x39e7,0x39eb,0x3103,0x39ef,0x39f3,0x39f7,0x39fb,0x39ff,0x3a03,\n+0x3a07,0x3a0b,0x3a0f,0x3a13,0x3a19,0x3a1d,0x3a21,0x3a25,0x3a29,0x3a2d,0x3a33,0x3a39,0x3a3d,0x3a41,0x3117,0x311b,\n+0x3a45,0x3a49,0x3a4f,0x3a53,0x3a57,0x3a5b,0x3a5f,0x3a65,0x3a6b,0x3a6f,0x3a73,0x3a77,0x3a7d,0x311f,0x3a81,0x3a87,\n+0x3a8d,0x3a91,0x3a95,0x3a99,0x3a9f,0x3aa3,0x3aa7,0x3aab,0x3aaf,0x3ab3,0x3ab7,0x3abb,0x3ac1,0x3ac5,0x3ac9,0x3acd,\n+0x3ad3,0x3ad7,0x3adb,0x3adf,0x3ae3,0x3ae9,0x3aef,0x3af3,0x3af7,0x3afb,0x3b01,0x3b05,0x3137,0x3137,0x3b0b,0x3b0f,\n+0x3b15,0x3b19,0x3b1d,0x3b21,0x3b25,0x3b29,0x3b2d,0x3b31,0x313b,0x3b37,0x3b3b,0x3b3f,0x3b43,0x3b47,0x3b4b,0x3b51,\n+0x3b55,0x3b5b,0x3b61,0x3b67,0x3b6b,0x3b6f,0x3b73,0x3b77,0x3b7b,0x3b7f,0x3b83,0x3b87,1,1\n+};\n+\n+static const UCPTrie norm2_nfc_data_trie={\n+    norm2_nfc_data_trieIndex,\n+    { norm2_nfc_data_trieData },\n+    1690, 7822,\n+    0x2fc00, 0x30,\n+    0, 0,\n+    0, 0,\n+    0xc4, 0x226,\n+    0x1,\n };\n \n static const uint16_t norm2_nfc_data_extraData[7724]={\n@@ -1151,19 +1136,4 @@ static const uint8_t norm2_nfc_data_smallFCD[256]={\n 0,0,0,0,0,0,0,0,0,0,0,7,0,0,2,0\n };\n \n-static const UTrie2 norm2_nfc_data_trie={\n-    norm2_nfc_data_trieIndex,\n-    norm2_nfc_data_trieIndex+2728,\n-    NULL,\n-    2728,\n-    7248,\n-    0x188,\n-    0xb24,\n-    0x1,\n-    0x1,\n-    0x30000,\n-    0x26f4,\n-    NULL, 0, FALSE, FALSE, 0, NULL\n-};\n-\n #endif  // INCLUDED_FROM_NORMALIZER2_CPP"
        },
        {
            "sha": "ca5d3aba1a18742a3aa05d3c5124f9241005f5d2",
            "filename": "deps/icu-small/source/common/normalizer2.cpp",
            "status": "modified",
            "additions": 48,
            "deletions": 42,
            "changes": 90,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fnormalizer2.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fnormalizer2.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fnormalizer2.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -34,9 +34,11 @@\n \n using icu::Normalizer2Impl;\n \n+#if NORM2_HARDCODE_NFC_DATA\n // NFC/NFD data machine-generated by gennorm2 --csource\n #define INCLUDED_FROM_NORMALIZER2_CPP\n #include \"norm2_nfc_data.h\"\n+#endif\n \n U_NAMESPACE_BEGIN\n \n@@ -176,6 +178,36 @@ FCDNormalizer2::~FCDNormalizer2() {}\n \n // instance cache ---------------------------------------------------------- ***\n \n+U_CDECL_BEGIN\n+static UBool U_CALLCONV uprv_normalizer2_cleanup();\n+U_CDECL_END\n+\n+static Normalizer2   *noopSingleton;\n+static icu::UInitOnce noopInitOnce = U_INITONCE_INITIALIZER;\n+\n+static void U_CALLCONV initNoopSingleton(UErrorCode &errorCode) {\n+    if(U_FAILURE(errorCode)) {\n+        return;\n+    }\n+    noopSingleton=new NoopNormalizer2;\n+    if(noopSingleton==NULL) {\n+        errorCode=U_MEMORY_ALLOCATION_ERROR;\n+        return;\n+    }\n+    ucln_common_registerCleanup(UCLN_COMMON_NORMALIZER2, uprv_normalizer2_cleanup);\n+}\n+\n+const Normalizer2 *Normalizer2Factory::getNoopInstance(UErrorCode &errorCode) {\n+    if(U_FAILURE(errorCode)) { return NULL; }\n+    umtx_initOnce(noopInitOnce, &initNoopSingleton, errorCode);\n+    return noopSingleton;\n+}\n+\n+const Normalizer2Impl *\n+Normalizer2Factory::getImpl(const Normalizer2 *norm2) {\n+    return &((Normalizer2WithImpl *)norm2)->impl;\n+}\n+\n Norm2AllModes::~Norm2AllModes() {\n     delete impl;\n }\n@@ -195,6 +227,7 @@ Norm2AllModes::createInstance(Normalizer2Impl *impl, UErrorCode &errorCode) {\n     return allModes;\n }\n \n+#if NORM2_HARDCODE_NFC_DATA\n Norm2AllModes *\n Norm2AllModes::createNFCInstance(UErrorCode &errorCode) {\n     if(U_FAILURE(errorCode)) {\n@@ -210,48 +243,15 @@ Norm2AllModes::createNFCInstance(UErrorCode &errorCode) {\n     return createInstance(impl, errorCode);\n }\n \n-U_CDECL_BEGIN\n-static UBool U_CALLCONV uprv_normalizer2_cleanup();\n-U_CDECL_END\n-\n static Norm2AllModes *nfcSingleton;\n-static Normalizer2   *noopSingleton;\n \n static icu::UInitOnce nfcInitOnce = U_INITONCE_INITIALIZER;\n-static icu::UInitOnce noopInitOnce = U_INITONCE_INITIALIZER;\n \n-// UInitOnce singleton initialization functions\n static void U_CALLCONV initNFCSingleton(UErrorCode &errorCode) {\n     nfcSingleton=Norm2AllModes::createNFCInstance(errorCode);\n     ucln_common_registerCleanup(UCLN_COMMON_NORMALIZER2, uprv_normalizer2_cleanup);\n }\n \n-static void U_CALLCONV initNoopSingleton(UErrorCode &errorCode) {\n-    if(U_FAILURE(errorCode)) {\n-        return;\n-    }\n-    noopSingleton=new NoopNormalizer2;\n-    if(noopSingleton==NULL) {\n-        errorCode=U_MEMORY_ALLOCATION_ERROR;\n-        return;\n-    }\n-    ucln_common_registerCleanup(UCLN_COMMON_NORMALIZER2, uprv_normalizer2_cleanup);\n-}\n-\n-U_CDECL_BEGIN\n-\n-static UBool U_CALLCONV uprv_normalizer2_cleanup() {\n-    delete nfcSingleton;\n-    nfcSingleton = NULL;\n-    delete noopSingleton;\n-    noopSingleton = NULL;\n-    nfcInitOnce.reset();\n-    noopInitOnce.reset();\n-    return TRUE;\n-}\n-\n-U_CDECL_END\n-\n const Norm2AllModes *\n Norm2AllModes::getNFCInstance(UErrorCode &errorCode) {\n     if(U_FAILURE(errorCode)) { return NULL; }\n@@ -281,23 +281,29 @@ const Normalizer2 *Normalizer2Factory::getFCCInstance(UErrorCode &errorCode) {\n     return allModes!=NULL ? &allModes->fcc : NULL;\n }\n \n-const Normalizer2 *Normalizer2Factory::getNoopInstance(UErrorCode &errorCode) {\n-    if(U_FAILURE(errorCode)) { return NULL; }\n-    umtx_initOnce(noopInitOnce, &initNoopSingleton, errorCode);\n-    return noopSingleton;\n-}\n-\n const Normalizer2Impl *\n Normalizer2Factory::getNFCImpl(UErrorCode &errorCode) {\n     const Norm2AllModes *allModes=Norm2AllModes::getNFCInstance(errorCode);\n     return allModes!=NULL ? allModes->impl : NULL;\n }\n+#endif  // NORM2_HARDCODE_NFC_DATA\n \n-const Normalizer2Impl *\n-Normalizer2Factory::getImpl(const Normalizer2 *norm2) {\n-    return &((Normalizer2WithImpl *)norm2)->impl;\n+U_CDECL_BEGIN\n+\n+static UBool U_CALLCONV uprv_normalizer2_cleanup() {\n+    delete noopSingleton;\n+    noopSingleton = NULL;\n+    noopInitOnce.reset();\n+#if NORM2_HARDCODE_NFC_DATA\n+    delete nfcSingleton;\n+    nfcSingleton = NULL;\n+    nfcInitOnce.reset();\n+#endif\n+    return TRUE;\n }\n \n+U_CDECL_END\n+\n U_NAMESPACE_END\n \n // C API ------------------------------------------------------------------- ***"
        },
        {
            "sha": "e7ae646c41ae6d6192bce599a9c036d71f1d7f17",
            "filename": "deps/icu-small/source/common/normalizer2impl.cpp",
            "status": "modified",
            "additions": 201,
            "deletions": 233,
            "changes": 434,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fnormalizer2impl.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fnormalizer2impl.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fnormalizer2impl.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -16,6 +16,8 @@\n *   created by: Markus W. Scherer\n */\n \n+// #define UCPTRIE_DEBUG\n+\n #include \"unicode/utypes.h\"\n \n #if !UCONFIG_NO_NORMALIZATION\n@@ -24,7 +26,9 @@\n #include \"unicode/edits.h\"\n #include \"unicode/normalizer2.h\"\n #include \"unicode/stringoptions.h\"\n+#include \"unicode/ucptrie.h\"\n #include \"unicode/udata.h\"\n+#include \"unicode/umutablecptrie.h\"\n #include \"unicode/ustring.h\"\n #include \"unicode/utf16.h\"\n #include \"unicode/utf8.h\"\n@@ -34,8 +38,8 @@\n #include \"normalizer2impl.h\"\n #include \"putilimp.h\"\n #include \"uassert.h\"\n+#include \"ucptrie_impl.h\"\n #include \"uset_imp.h\"\n-#include \"utrie2.h\"\n #include \"uvector.h\"\n \n U_NAMESPACE_BEGIN\n@@ -62,7 +66,7 @@ inline uint8_t leadByteForCP(UChar32 c) {\n  * Returns the code point from one single well-formed UTF-8 byte sequence\n  * between cpStart and cpLimit.\n  *\n- * UTrie2 UTF-8 macros do not assemble whole code points (for efficiency).\n+ * Trie UTF-8 macros do not assemble whole code points (for efficiency).\n  * When we do need the code point, we call this function.\n  * We should not need it for normalization-inert data (norm16==0).\n  * Illegal sequences yield the error value norm16==0 just like real normalization-inert code points.\n@@ -122,7 +126,7 @@ int32_t getJamoTMinusBase(const uint8_t *src, const uint8_t *limit) {\n             }\n         } else if (src[1] == 0x87) {\n             uint8_t t = src[2];\n-            if ((int8_t)t <= (int8_t)0x82) {\n+            if ((int8_t)t <= (int8_t)0x82u) {\n                 return t - (0xa7 - 0x40);\n             }\n         }\n@@ -253,7 +257,7 @@ UBool ReorderingBuffer::appendSupplementary(UChar32 c, uint8_t cc, UErrorCode &e\n     return TRUE;\n }\n \n-UBool ReorderingBuffer::append(const UChar *s, int32_t length,\n+UBool ReorderingBuffer::append(const UChar *s, int32_t length, UBool isNFD,\n                                uint8_t leadCC, uint8_t trailCC,\n                                UErrorCode &errorCode) {\n     if(length==0) {\n@@ -280,8 +284,11 @@ UBool ReorderingBuffer::append(const UChar *s, int32_t length,\n         while(i<length) {\n             U16_NEXT(s, i, length, c);\n             if(i<length) {\n-                // s must be in NFD, otherwise we need to use getCC().\n-                leadCC=Normalizer2Impl::getCCFromYesOrMaybe(impl.getNorm16(c));\n+                if (isNFD) {\n+                    leadCC = Normalizer2Impl::getCCFromYesOrMaybe(impl.getRawNorm16(c));\n+                } else {\n+                    leadCC = impl.getCC(impl.getNorm16(c));\n+                }\n             } else {\n                 leadCC=trailCC;\n             }\n@@ -411,7 +418,8 @@ struct CanonIterData : public UMemory {\n     CanonIterData(UErrorCode &errorCode);\n     ~CanonIterData();\n     void addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &errorCode);\n-    UTrie2 *trie;\n+    UMutableCPTrie *mutableTrie;\n+    UCPTrie *trie;\n     UVector canonStartSets;  // contains UnicodeSet *\n };\n \n@@ -420,22 +428,22 @@ Normalizer2Impl::~Normalizer2Impl() {\n }\n \n void\n-Normalizer2Impl::init(const int32_t *inIndexes, const UTrie2 *inTrie,\n+Normalizer2Impl::init(const int32_t *inIndexes, const UCPTrie *inTrie,\n                       const uint16_t *inExtraData, const uint8_t *inSmallFCD) {\n-    minDecompNoCP=inIndexes[IX_MIN_DECOMP_NO_CP];\n-    minCompNoMaybeCP=inIndexes[IX_MIN_COMP_NO_MAYBE_CP];\n-    minLcccCP=inIndexes[IX_MIN_LCCC_CP];\n-\n-    minYesNo=inIndexes[IX_MIN_YES_NO];\n-    minYesNoMappingsOnly=inIndexes[IX_MIN_YES_NO_MAPPINGS_ONLY];\n-    minNoNo=inIndexes[IX_MIN_NO_NO];\n-    minNoNoCompBoundaryBefore=inIndexes[IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE];\n-    minNoNoCompNoMaybeCC=inIndexes[IX_MIN_NO_NO_COMP_NO_MAYBE_CC];\n-    minNoNoEmpty=inIndexes[IX_MIN_NO_NO_EMPTY];\n-    limitNoNo=inIndexes[IX_LIMIT_NO_NO];\n-    minMaybeYes=inIndexes[IX_MIN_MAYBE_YES];\n-    U_ASSERT((minMaybeYes&7)==0);  // 8-aligned for noNoDelta bit fields\n-    centerNoNoDelta=(minMaybeYes>>DELTA_SHIFT)-MAX_DELTA-1;\n+    minDecompNoCP = static_cast<UChar>(inIndexes[IX_MIN_DECOMP_NO_CP]);\n+    minCompNoMaybeCP = static_cast<UChar>(inIndexes[IX_MIN_COMP_NO_MAYBE_CP]);\n+    minLcccCP = static_cast<UChar>(inIndexes[IX_MIN_LCCC_CP]);\n+\n+    minYesNo = static_cast<uint16_t>(inIndexes[IX_MIN_YES_NO]);\n+    minYesNoMappingsOnly = static_cast<uint16_t>(inIndexes[IX_MIN_YES_NO_MAPPINGS_ONLY]);\n+    minNoNo = static_cast<uint16_t>(inIndexes[IX_MIN_NO_NO]);\n+    minNoNoCompBoundaryBefore = static_cast<uint16_t>(inIndexes[IX_MIN_NO_NO_COMP_BOUNDARY_BEFORE]);\n+    minNoNoCompNoMaybeCC = static_cast<uint16_t>(inIndexes[IX_MIN_NO_NO_COMP_NO_MAYBE_CC]);\n+    minNoNoEmpty = static_cast<uint16_t>(inIndexes[IX_MIN_NO_NO_EMPTY]);\n+    limitNoNo = static_cast<uint16_t>(inIndexes[IX_LIMIT_NO_NO]);\n+    minMaybeYes = static_cast<uint16_t>(inIndexes[IX_MIN_MAYBE_YES]);\n+    U_ASSERT((minMaybeYes & 7) == 0);  // 8-aligned for noNoDelta bit fields\n+    centerNoNoDelta = (minMaybeYes >> DELTA_SHIFT) - MAX_DELTA - 1;\n \n     normTrie=inTrie;\n \n@@ -445,75 +453,8 @@ Normalizer2Impl::init(const int32_t *inIndexes, const UTrie2 *inTrie,\n     smallFCD=inSmallFCD;\n }\n \n-class LcccContext {\n-public:\n-    LcccContext(const Normalizer2Impl &ni, UnicodeSet &s) : impl(ni), set(s) {}\n-\n-    void handleRange(UChar32 start, UChar32 end, uint16_t norm16) {\n-        if (norm16 > Normalizer2Impl::MIN_NORMAL_MAYBE_YES &&\n-                norm16 != Normalizer2Impl::JAMO_VT) {\n-            set.add(start, end);\n-        } else if (impl.minNoNoCompNoMaybeCC <= norm16 && norm16 < impl.limitNoNo) {\n-            uint16_t fcd16=impl.getFCD16(start);\n-            if(fcd16>0xff) { set.add(start, end); }\n-        }\n-    }\n-\n-private:\n-    const Normalizer2Impl &impl;\n-    UnicodeSet &set;\n-};\n-\n-namespace {\n-\n-struct PropertyStartsContext {\n-    PropertyStartsContext(const Normalizer2Impl &ni, const USetAdder *adder)\n-            : impl(ni), sa(adder) {}\n-\n-    const Normalizer2Impl &impl;\n-    const USetAdder *sa;\n-};\n-\n-}  // namespace\n-\n U_CDECL_BEGIN\n \n-static UBool U_CALLCONV\n-enumLcccRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {\n-    ((LcccContext *)context)->handleRange(start, end, (uint16_t)value);\n-    return TRUE;\n-}\n-\n-static UBool U_CALLCONV\n-enumNorm16PropertyStartsRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {\n-    /* add the start code point to the USet */\n-    const PropertyStartsContext *ctx=(const PropertyStartsContext *)context;\n-    const USetAdder *sa=ctx->sa;\n-    sa->add(sa->set, start);\n-    if (start != end && ctx->impl.isAlgorithmicNoNo((uint16_t)value) &&\n-            (value & Normalizer2Impl::DELTA_TCCC_MASK) > Normalizer2Impl::DELTA_TCCC_1) {\n-        // Range of code points with same-norm16-value algorithmic decompositions.\n-        // They might have different non-zero FCD16 values.\n-        uint16_t prevFCD16=ctx->impl.getFCD16(start);\n-        while(++start<=end) {\n-            uint16_t fcd16=ctx->impl.getFCD16(start);\n-            if(fcd16!=prevFCD16) {\n-                sa->add(sa->set, start);\n-                prevFCD16=fcd16;\n-            }\n-        }\n-    }\n-    return TRUE;\n-}\n-\n-static UBool U_CALLCONV\n-enumPropertyStartsRange(const void *context, UChar32 start, UChar32 /*end*/, uint32_t /*value*/) {\n-    /* add the start code point to the USet */\n-    const USetAdder *sa=(const USetAdder *)context;\n-    sa->add(sa->set, start);\n-    return TRUE;\n-}\n-\n static uint32_t U_CALLCONV\n segmentStarterMapper(const void * /*context*/, uint32_t value) {\n     return value&CANON_NOT_SEGMENT_STARTER;\n@@ -523,15 +464,44 @@ U_CDECL_END\n \n void\n Normalizer2Impl::addLcccChars(UnicodeSet &set) const {\n-    LcccContext context(*this, set);\n-    utrie2_enum(normTrie, NULL, enumLcccRange, &context);\n+    UChar32 start = 0, end;\n+    uint32_t norm16;\n+    while ((end = ucptrie_getRange(normTrie, start, UCPMAP_RANGE_FIXED_LEAD_SURROGATES, INERT,\n+                                   nullptr, nullptr, &norm16)) >= 0) {\n+        if (norm16 > Normalizer2Impl::MIN_NORMAL_MAYBE_YES &&\n+                norm16 != Normalizer2Impl::JAMO_VT) {\n+            set.add(start, end);\n+        } else if (minNoNoCompNoMaybeCC <= norm16 && norm16 < limitNoNo) {\n+            uint16_t fcd16 = getFCD16(start);\n+            if (fcd16 > 0xff) { set.add(start, end); }\n+        }\n+        start = end + 1;\n+    }\n }\n \n void\n Normalizer2Impl::addPropertyStarts(const USetAdder *sa, UErrorCode & /*errorCode*/) const {\n-    /* add the start code point of each same-value range of each trie */\n-    PropertyStartsContext context(*this, sa);\n-    utrie2_enum(normTrie, NULL, enumNorm16PropertyStartsRange, &context);\n+    // Add the start code point of each same-value range of the trie.\n+    UChar32 start = 0, end;\n+    uint32_t value;\n+    while ((end = ucptrie_getRange(normTrie, start, UCPMAP_RANGE_FIXED_LEAD_SURROGATES, INERT,\n+                                   nullptr, nullptr, &value)) >= 0) {\n+        sa->add(sa->set, start);\n+        if (start != end && isAlgorithmicNoNo((uint16_t)value) &&\n+                (value & Normalizer2Impl::DELTA_TCCC_MASK) > Normalizer2Impl::DELTA_TCCC_1) {\n+            // Range of code points with same-norm16-value algorithmic decompositions.\n+            // They might have different non-zero FCD16 values.\n+            uint16_t prevFCD16 = getFCD16(start);\n+            while (++start <= end) {\n+                uint16_t fcd16 = getFCD16(start);\n+                if (fcd16 != prevFCD16) {\n+                    sa->add(sa->set, start);\n+                    prevFCD16 = fcd16;\n+                }\n+            }\n+        }\n+        start = end + 1;\n+    }\n \n     /* add Hangul LV syllables and LV+1 because of skippables */\n     for(UChar c=Hangul::HANGUL_BASE; c<Hangul::HANGUL_LIMIT; c+=Hangul::JAMO_T_COUNT) {\n@@ -543,10 +513,15 @@ Normalizer2Impl::addPropertyStarts(const USetAdder *sa, UErrorCode & /*errorCode\n \n void\n Normalizer2Impl::addCanonIterPropertyStarts(const USetAdder *sa, UErrorCode &errorCode) const {\n-    /* add the start code point of each same-value range of the canonical iterator data trie */\n-    if(ensureCanonIterData(errorCode)) {\n-        // currently only used for the SEGMENT_STARTER property\n-        utrie2_enum(fCanonIterData->trie, segmentStarterMapper, enumPropertyStartsRange, sa);\n+    // Add the start code point of each same-value range of the canonical iterator data trie.\n+    if (!ensureCanonIterData(errorCode)) { return; }\n+    // Currently only used for the SEGMENT_STARTER property.\n+    UChar32 start = 0, end;\n+    uint32_t value;\n+    while ((end = ucptrie_getRange(fCanonIterData->trie, start, UCPMAP_RANGE_NORMAL, 0,\n+                                   segmentStarterMapper, nullptr, &value)) >= 0) {\n+        sa->add(sa->set, start);\n+        start = end + 1;\n     }\n }\n \n@@ -633,27 +608,23 @@ Normalizer2Impl::decompose(const UChar *src, const UChar *limit,\n         // count code units below the minimum or with irrelevant data for the quick check\n         for(prevSrc=src; src!=limit;) {\n             if( (c=*src)<minNoCP ||\n-                isMostDecompYesAndZeroCC(norm16=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(normTrie, c))\n+                isMostDecompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))\n             ) {\n                 ++src;\n-            } else if(!U16_IS_SURROGATE(c)) {\n+            } else if(!U16_IS_LEAD(c)) {\n                 break;\n             } else {\n                 UChar c2;\n-                if(U16_IS_SURROGATE_LEAD(c)) {\n-                    if((src+1)!=limit && U16_IS_TRAIL(c2=src[1])) {\n-                        c=U16_GET_SUPPLEMENTARY(c, c2);\n-                    }\n-                } else /* trail surrogate */ {\n-                    if(prevSrc<src && U16_IS_LEAD(c2=*(src-1))) {\n-                        --src;\n-                        c=U16_GET_SUPPLEMENTARY(c2, c);\n+                if((src+1)!=limit && U16_IS_TRAIL(c2=src[1])) {\n+                    c=U16_GET_SUPPLEMENTARY(c, c2);\n+                    norm16=UCPTRIE_FAST_SUPP_GET(normTrie, UCPTRIE_16, c);\n+                    if(isMostDecompYesAndZeroCC(norm16)) {\n+                        src+=2;\n+                    } else {\n+                        break;\n                     }\n-                }\n-                if(isMostDecompYesAndZeroCC(norm16=getNorm16(c))) {\n-                    src+=U16_LENGTH(c);\n                 } else {\n-                    break;\n+                    ++src;  // unpaired lead surrogate: inert\n                 }\n             }\n         }\n@@ -713,7 +684,7 @@ Normalizer2Impl::decomposeShort(const UChar *src, const UChar *limit,\n         const UChar *prevSrc = src;\n         UChar32 c;\n         uint16_t norm16;\n-        UTRIE2_U16_NEXT16(normTrie, src, limit, c, norm16);\n+        UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, src, limit, c, norm16);\n         if (stopAtCompBoundary && norm16HasCompBoundaryBefore(norm16)) {\n             return prevSrc;\n         }\n@@ -737,7 +708,7 @@ UBool Normalizer2Impl::decompose(UChar32 c, uint16_t norm16,\n         }\n         // Maps to an isCompYesAndZeroCC.\n         c=mapAlgorithmic(c, norm16);\n-        norm16=getNorm16(c);\n+        norm16=getRawNorm16(c);\n     }\n     if (norm16 < minYesNo) {\n         // c does not decompose\n@@ -758,7 +729,7 @@ UBool Normalizer2Impl::decompose(UChar32 c, uint16_t norm16,\n     } else {\n         leadCC=0;\n     }\n-    return buffer.append((const UChar *)mapping+1, length, leadCC, trailCC, errorCode);\n+    return buffer.append((const UChar *)mapping+1, length, TRUE, leadCC, trailCC, errorCode);\n }\n \n const uint8_t *\n@@ -771,7 +742,7 @@ Normalizer2Impl::decomposeShort(const uint8_t *src, const uint8_t *limit,\n     while (src < limit) {\n         const uint8_t *prevSrc = src;\n         uint16_t norm16;\n-        UTRIE2_U8_NEXT16(normTrie, src, limit, norm16);\n+        UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);\n         // Get the decomposition and the lead and trail cc's.\n         UChar32 c = U_SENTINEL;\n         if (norm16 >= limitNoNo) {\n@@ -789,7 +760,7 @@ Normalizer2Impl::decomposeShort(const uint8_t *src, const uint8_t *limit,\n             }\n             c = codePointFromValidUTF8(prevSrc, src);\n             c = mapAlgorithmic(c, norm16);\n-            norm16 = getNorm16(c);\n+            norm16 = getRawNorm16(c);\n         } else if (stopAtCompBoundary && norm16 < minNoNoCompNoMaybeCC) {\n             return prevSrc;\n         }\n@@ -828,7 +799,7 @@ Normalizer2Impl::decomposeShort(const uint8_t *src, const uint8_t *limit,\n             } else {\n                 leadCC = 0;\n             }\n-            if (!buffer.append((const char16_t *)mapping+1, length, leadCC, trailCC, errorCode)) {\n+            if (!buffer.append((const char16_t *)mapping+1, length, TRUE, leadCC, trailCC, errorCode)) {\n                 return nullptr;\n             }\n         }\n@@ -854,7 +825,7 @@ Normalizer2Impl::getDecomposition(UChar32 c, UChar buffer[4], int32_t &length) c\n         length=0;\n         U16_APPEND_UNSAFE(buffer, length, c);\n         // The mapping might decompose further.\n-        norm16 = getNorm16(c);\n+        norm16 = getRawNorm16(c);\n     }\n     if (norm16 < minYesNo) {\n         return decomp;\n@@ -926,19 +897,30 @@ void Normalizer2Impl::decomposeAndAppend(const UChar *src, const UChar *limit,\n         return;\n     }\n     // Just merge the strings at the boundary.\n-    ForwardUTrie2StringIterator iter(normTrie, src, limit);\n-    uint8_t firstCC, prevCC, cc;\n-    firstCC=prevCC=cc=getCC(iter.next16());\n-    while(cc!=0) {\n-        prevCC=cc;\n-        cc=getCC(iter.next16());\n-    };\n+    bool isFirst = true;\n+    uint8_t firstCC = 0, prevCC = 0, cc;\n+    const UChar *p = src;\n+    while (p != limit) {\n+        const UChar *codePointStart = p;\n+        UChar32 c;\n+        uint16_t norm16;\n+        UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);\n+        if ((cc = getCC(norm16)) == 0) {\n+            p = codePointStart;\n+            break;\n+        }\n+        if (isFirst) {\n+            firstCC = cc;\n+            isFirst = false;\n+        }\n+        prevCC = cc;\n+    }\n     if(limit==NULL) {  // appendZeroCC() needs limit!=NULL\n-        limit=u_strchr(iter.codePointStart, 0);\n+        limit=u_strchr(p, 0);\n     }\n \n-    if (buffer.append(src, (int32_t)(iter.codePointStart-src), firstCC, prevCC, errorCode)) {\n-        buffer.appendZeroCC(iter.codePointStart, limit, errorCode);\n+    if (buffer.append(src, (int32_t)(p - src), FALSE, firstCC, prevCC, errorCode)) {\n+        buffer.appendZeroCC(p, limit, errorCode);\n     }\n }\n \n@@ -1085,7 +1067,7 @@ void Normalizer2Impl::addComposites(const uint16_t *list, UnicodeSet &set) const\n         }\n         UChar32 composite=compositeAndFwd>>1;\n         if((compositeAndFwd&1)!=0) {\n-            addComposites(getCompositionsListForComposite(getNorm16(composite)), set);\n+            addComposites(getCompositionsListForComposite(getRawNorm16(composite)), set);\n         }\n         set.add(composite);\n     } while((firstUnit&COMP_1_LAST_TUPLE)==0);\n@@ -1124,7 +1106,7 @@ void Normalizer2Impl::recompose(ReorderingBuffer &buffer, int32_t recomposeStart\n     prevCC=0;\n \n     for(;;) {\n-        UTRIE2_U16_NEXT16(normTrie, p, limit, c, norm16);\n+        UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);\n         cc=getCCFromYesOrMaybe(norm16);\n         if( // this character combines backward and\n             isMaybe(norm16) &&\n@@ -1229,7 +1211,7 @@ void Normalizer2Impl::recompose(ReorderingBuffer &buffer, int32_t recomposeStart\n                 // Is the composite a starter that combines forward?\n                 if(compositeAndFwd&1) {\n                     compositionsList=\n-                        getCompositionsListForComposite(getNorm16(composite));\n+                        getCompositionsListForComposite(getRawNorm16(composite));\n                 } else {\n                     compositionsList=NULL;\n                 }\n@@ -1268,7 +1250,7 @@ void Normalizer2Impl::recompose(ReorderingBuffer &buffer, int32_t recomposeStart\n \n UChar32\n Normalizer2Impl::composePair(UChar32 a, UChar32 b) const {\n-    uint16_t norm16=getNorm16(a);  // maps an out-of-range 'a' to inert norm16=0\n+    uint16_t norm16=getNorm16(a);  // maps an out-of-range 'a' to inert norm16\n     const uint16_t *list;\n     if(isInert(norm16)) {\n         return U_SENTINEL;\n@@ -1359,29 +1341,23 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,\n                 return TRUE;\n             }\n             if( (c=*src)<minNoMaybeCP ||\n-                isCompYesAndZeroCC(norm16=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(normTrie, c))\n+                isCompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))\n             ) {\n                 ++src;\n             } else {\n                 prevSrc = src++;\n-                if(!U16_IS_SURROGATE(c)) {\n+                if(!U16_IS_LEAD(c)) {\n                     break;\n                 } else {\n                     UChar c2;\n-                    if(U16_IS_SURROGATE_LEAD(c)) {\n-                        if(src!=limit && U16_IS_TRAIL(c2=*src)) {\n-                            ++src;\n-                            c=U16_GET_SUPPLEMENTARY(c, c2);\n-                        }\n-                    } else /* trail surrogate */ {\n-                        if(prevBoundary<prevSrc && U16_IS_LEAD(c2=*(prevSrc-1))) {\n-                            --prevSrc;\n-                            c=U16_GET_SUPPLEMENTARY(c2, c);\n+                    if(src!=limit && U16_IS_TRAIL(c2=*src)) {\n+                        ++src;\n+                        c=U16_GET_SUPPLEMENTARY(c, c2);\n+                        norm16=UCPTRIE_FAST_SUPP_GET(normTrie, UCPTRIE_16, c);\n+                        if(!isCompYesAndZeroCC(norm16)) {\n+                            break;\n                         }\n                     }\n-                    if(!isCompYesAndZeroCC(norm16=getNorm16(c))) {\n-                        break;\n-                    }\n                 }\n             }\n         }\n@@ -1529,7 +1505,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,\n                     }\n                     uint8_t prevCC = cc;\n                     nextSrc = src;\n-                    UTRIE2_U16_NEXT16(normTrie, nextSrc, limit, c, n16);\n+                    UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, nextSrc, limit, c, n16);\n                     if (n16 >= MIN_YES_YES_WITH_CC) {\n                         cc = getCCFromNormalYesOrMaybe(n16);\n                         if (prevCC > cc) {\n@@ -1559,7 +1535,7 @@ Normalizer2Impl::compose(const UChar *src, const UChar *limit,\n         // decompose and recompose.\n         if (prevBoundary != prevSrc && !norm16HasCompBoundaryBefore(norm16)) {\n             const UChar *p = prevSrc;\n-            UTRIE2_U16_PREV16(normTrie, prevBoundary, p, c, norm16);\n+            UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, prevBoundary, p, c, norm16);\n             if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {\n                 prevSrc = p;\n             }\n@@ -1626,29 +1602,23 @@ Normalizer2Impl::composeQuickCheck(const UChar *src, const UChar *limit,\n                 return src;\n             }\n             if( (c=*src)<minNoMaybeCP ||\n-                isCompYesAndZeroCC(norm16=UTRIE2_GET16_FROM_U16_SINGLE_LEAD(normTrie, c))\n+                isCompYesAndZeroCC(norm16=UCPTRIE_FAST_BMP_GET(normTrie, UCPTRIE_16, c))\n             ) {\n                 ++src;\n             } else {\n                 prevSrc = src++;\n-                if(!U16_IS_SURROGATE(c)) {\n+                if(!U16_IS_LEAD(c)) {\n                     break;\n                 } else {\n                     UChar c2;\n-                    if(U16_IS_SURROGATE_LEAD(c)) {\n-                        if(src!=limit && U16_IS_TRAIL(c2=*src)) {\n-                            ++src;\n-                            c=U16_GET_SUPPLEMENTARY(c, c2);\n-                        }\n-                    } else /* trail surrogate */ {\n-                        if(prevBoundary<prevSrc && U16_IS_LEAD(c2=*(prevSrc-1))) {\n-                            --prevSrc;\n-                            c=U16_GET_SUPPLEMENTARY(c2, c);\n+                    if(src!=limit && U16_IS_TRAIL(c2=*src)) {\n+                        ++src;\n+                        c=U16_GET_SUPPLEMENTARY(c, c2);\n+                        norm16=UCPTRIE_FAST_SUPP_GET(normTrie, UCPTRIE_16, c);\n+                        if(!isCompYesAndZeroCC(norm16)) {\n+                            break;\n                         }\n                     }\n-                    if(!isCompYesAndZeroCC(norm16=getNorm16(c))) {\n-                        break;\n-                    }\n                 }\n             }\n         }\n@@ -1665,7 +1635,7 @@ Normalizer2Impl::composeQuickCheck(const UChar *src, const UChar *limit,\n             } else {\n                 const UChar *p = prevSrc;\n                 uint16_t n16;\n-                UTRIE2_U16_PREV16(normTrie, prevBoundary, p, c, n16);\n+                UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, prevBoundary, p, c, n16);\n                 if (norm16HasCompBoundaryAfter(n16, onlyContiguous)) {\n                     prevBoundary = prevSrc;\n                 } else {\n@@ -1699,7 +1669,7 @@ Normalizer2Impl::composeQuickCheck(const UChar *src, const UChar *limit,\n                     }\n                     uint8_t prevCC = cc;\n                     nextSrc = src;\n-                    UTRIE2_U16_NEXT16(normTrie, nextSrc, limit, c, norm16);\n+                    UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, nextSrc, limit, c, norm16);\n                     if (isMaybeOrNonZeroCC(norm16)) {\n                         cc = getCCFromYesOrMaybe(norm16);\n                         if (!(prevCC <= cc || cc == 0)) {\n@@ -1786,7 +1756,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,\n                 ++src;\n             } else {\n                 prevSrc = src;\n-                UTRIE2_U8_NEXT16(normTrie, src, limit, norm16);\n+                UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);\n                 if (!isCompYesAndZeroCC(norm16)) {\n                     break;\n                 }\n@@ -1945,7 +1915,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,\n                     }\n                     uint8_t prevCC = cc;\n                     nextSrc = src;\n-                    UTRIE2_U8_NEXT16(normTrie, nextSrc, limit, n16);\n+                    UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, nextSrc, limit, n16);\n                     if (n16 >= MIN_YES_YES_WITH_CC) {\n                         cc = getCCFromNormalYesOrMaybe(n16);\n                         if (prevCC > cc) {\n@@ -1975,7 +1945,7 @@ Normalizer2Impl::composeUTF8(uint32_t options, UBool onlyContiguous,\n         // decompose and recompose.\n         if (prevBoundary != prevSrc && !norm16HasCompBoundaryBefore(norm16)) {\n             const uint8_t *p = prevSrc;\n-            UTRIE2_U8_PREV16(normTrie, prevBoundary, p, norm16);\n+            UCPTRIE_FAST_U8_PREV(normTrie, UCPTRIE_16, prevBoundary, p, norm16);\n             if (!norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {\n                 prevSrc = p;\n             }\n@@ -2023,7 +1993,7 @@ UBool Normalizer2Impl::hasCompBoundaryBefore(const UChar *src, const UChar *limi\n     }\n     UChar32 c;\n     uint16_t norm16;\n-    UTRIE2_U16_NEXT16(normTrie, src, limit, c, norm16);\n+    UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, src, limit, c, norm16);\n     return norm16HasCompBoundaryBefore(norm16);\n }\n \n@@ -2032,7 +2002,7 @@ UBool Normalizer2Impl::hasCompBoundaryBefore(const uint8_t *src, const uint8_t *\n         return TRUE;\n     }\n     uint16_t norm16;\n-    UTRIE2_U8_NEXT16(normTrie, src, limit, norm16);\n+    UCPTRIE_FAST_U8_NEXT(normTrie, UCPTRIE_16, src, limit, norm16);\n     return norm16HasCompBoundaryBefore(norm16);\n }\n \n@@ -2043,7 +2013,7 @@ UBool Normalizer2Impl::hasCompBoundaryAfter(const UChar *start, const UChar *p,\n     }\n     UChar32 c;\n     uint16_t norm16;\n-    UTRIE2_U16_PREV16(normTrie, start, p, c, norm16);\n+    UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, start, p, c, norm16);\n     return norm16HasCompBoundaryAfter(norm16, onlyContiguous);\n }\n \n@@ -2053,36 +2023,42 @@ UBool Normalizer2Impl::hasCompBoundaryAfter(const uint8_t *start, const uint8_t\n         return TRUE;\n     }\n     uint16_t norm16;\n-    UTRIE2_U8_PREV16(normTrie, start, p, norm16);\n+    UCPTRIE_FAST_U8_PREV(normTrie, UCPTRIE_16, start, p, norm16);\n     return norm16HasCompBoundaryAfter(norm16, onlyContiguous);\n }\n \n const UChar *Normalizer2Impl::findPreviousCompBoundary(const UChar *start, const UChar *p,\n                                                        UBool onlyContiguous) const {\n-    BackwardUTrie2StringIterator iter(normTrie, start, p);\n-    for(;;) {\n-        uint16_t norm16=iter.previous16();\n+    while (p != start) {\n+        const UChar *codePointLimit = p;\n+        UChar32 c;\n+        uint16_t norm16;\n+        UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, start, p, c, norm16);\n         if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {\n-            return iter.codePointLimit;\n+            return codePointLimit;\n         }\n-        if (hasCompBoundaryBefore(iter.codePoint, norm16)) {\n-            return iter.codePointStart;\n+        if (hasCompBoundaryBefore(c, norm16)) {\n+            return p;\n         }\n     }\n+    return p;\n }\n \n const UChar *Normalizer2Impl::findNextCompBoundary(const UChar *p, const UChar *limit,\n                                                    UBool onlyContiguous) const {\n-    ForwardUTrie2StringIterator iter(normTrie, p, limit);\n-    for(;;) {\n-        uint16_t norm16=iter.next16();\n-        if (hasCompBoundaryBefore(iter.codePoint, norm16)) {\n-            return iter.codePointStart;\n+    while (p != limit) {\n+        const UChar *codePointStart = p;\n+        UChar32 c;\n+        uint16_t norm16;\n+        UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);\n+        if (hasCompBoundaryBefore(c, norm16)) {\n+            return codePointStart;\n         }\n         if (norm16HasCompBoundaryAfter(norm16, onlyContiguous)) {\n-            return iter.codePointLimit;\n+            return p;\n         }\n     }\n+    return p;\n }\n \n uint8_t Normalizer2Impl::getPreviousTrailCC(const UChar *start, const UChar *p) const {\n@@ -2130,7 +2106,7 @@ uint16_t Normalizer2Impl::getFCD16FromNormData(UChar32 c) const {\n             }\n             // Maps to an isCompYesAndZeroCC.\n             c=mapAlgorithmic(c, norm16);\n-            norm16=getNorm16(c);\n+            norm16=getRawNorm16(c);\n         }\n     }\n     if(norm16<=minYesNo || isHangulLVT(norm16)) {\n@@ -2195,17 +2171,10 @@ Normalizer2Impl::makeFCD(const UChar *src, const UChar *limit,\n                 prevFCD16=0;\n                 ++src;\n             } else {\n-                if(U16_IS_SURROGATE(c)) {\n+                if(U16_IS_LEAD(c)) {\n                     UChar c2;\n-                    if(U16_IS_SURROGATE_LEAD(c)) {\n-                        if((src+1)!=limit && U16_IS_TRAIL(c2=src[1])) {\n-                            c=U16_GET_SUPPLEMENTARY(c, c2);\n-                        }\n-                    } else /* trail surrogate */ {\n-                        if(prevSrc<src && U16_IS_LEAD(c2=*(src-1))) {\n-                            --src;\n-                            c=U16_GET_SUPPLEMENTARY(c2, c);\n-                        }\n+                    if((src+1)!=limit && U16_IS_TRAIL(c2=src[1])) {\n+                        c=U16_GET_SUPPLEMENTARY(c, c2);\n                     }\n                 }\n                 if((fcd16=getFCD16FromNormData(c))<=0xff) {\n@@ -2336,7 +2305,7 @@ const UChar *Normalizer2Impl::findPreviousFCDBoundary(const UChar *start, const\n         const UChar *codePointLimit = p;\n         UChar32 c;\n         uint16_t norm16;\n-        UTRIE2_U16_PREV16(normTrie, start, p, c, norm16);\n+        UCPTRIE_FAST_U16_PREV(normTrie, UCPTRIE_16, start, p, c, norm16);\n         if (c < minDecompNoCP || norm16HasDecompBoundaryAfter(norm16)) {\n             return codePointLimit;\n         }\n@@ -2352,7 +2321,7 @@ const UChar *Normalizer2Impl::findNextFCDBoundary(const UChar *p, const UChar *l\n         const UChar *codePointStart=p;\n         UChar32 c;\n         uint16_t norm16;\n-        UTRIE2_U16_NEXT16(normTrie, p, limit, c, norm16);\n+        UCPTRIE_FAST_U16_NEXT(normTrie, UCPTRIE_16, p, limit, c, norm16);\n         if (c < minLcccCP || norm16HasDecompBoundaryBefore(norm16)) {\n             return codePointStart;\n         }\n@@ -2366,19 +2335,20 @@ const UChar *Normalizer2Impl::findNextFCDBoundary(const UChar *p, const UChar *l\n // CanonicalIterator data -------------------------------------------------- ***\n \n CanonIterData::CanonIterData(UErrorCode &errorCode) :\n-        trie(utrie2_open(0, 0, &errorCode)),\n+        mutableTrie(umutablecptrie_open(0, 0, &errorCode)), trie(nullptr),\n         canonStartSets(uprv_deleteUObject, NULL, errorCode) {}\n \n CanonIterData::~CanonIterData() {\n-    utrie2_close(trie);\n+    umutablecptrie_close(mutableTrie);\n+    ucptrie_close(trie);\n }\n \n void CanonIterData::addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode &errorCode) {\n-    uint32_t canonValue=utrie2_get32(trie, decompLead);\n+    uint32_t canonValue = umutablecptrie_get(mutableTrie, decompLead);\n     if((canonValue&(CANON_HAS_SET|CANON_VALUE_MASK))==0 && origin!=0) {\n         // origin is the first character whose decomposition starts with\n         // the character for which we are setting the value.\n-        utrie2_set32(trie, decompLead, canonValue|origin, &errorCode);\n+        umutablecptrie_set(mutableTrie, decompLead, canonValue|origin, &errorCode);\n     } else {\n         // origin is not the first character, or it is U+0000.\n         UnicodeSet *set;\n@@ -2390,7 +2360,7 @@ void CanonIterData::addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode\n             }\n             UChar32 firstOrigin=(UChar32)(canonValue&CANON_VALUE_MASK);\n             canonValue=(canonValue&~CANON_VALUE_MASK)|CANON_HAS_SET|(uint32_t)canonStartSets.size();\n-            utrie2_set32(trie, decompLead, canonValue, &errorCode);\n+            umutablecptrie_set(mutableTrie, decompLead, canonValue, &errorCode);\n             canonStartSets.addElement(set, errorCode);\n             if(firstOrigin!=0) {\n                 set->add(firstOrigin);\n@@ -2406,7 +2376,6 @@ void CanonIterData::addToStartSet(UChar32 origin, UChar32 decompLead, UErrorCode\n class InitCanonIterData {\n public:\n     static void doInit(Normalizer2Impl *impl, UErrorCode &errorCode);\n-    static void handleRange(Normalizer2Impl *impl, UChar32 start, UChar32 end, uint16_t value, UErrorCode &errorCode);\n };\n \n U_CDECL_BEGIN\n@@ -2417,18 +2386,6 @@ initCanonIterData(Normalizer2Impl *impl, UErrorCode &errorCode) {\n     InitCanonIterData::doInit(impl, errorCode);\n }\n \n-// Call Normalizer2Impl::makeCanonIterDataFromNorm16() for a range of same-norm16 characters.\n-//     context: the Normalizer2Impl\n-static UBool U_CALLCONV\n-enumCIDRangeHandler(const void *context, UChar32 start, UChar32 end, uint32_t value) {\n-    UErrorCode errorCode = U_ZERO_ERROR;\n-    if (value != Normalizer2Impl::INERT) {\n-        Normalizer2Impl *impl = (Normalizer2Impl *)context;\n-        InitCanonIterData::handleRange(impl, start, end, (uint16_t)value, errorCode);\n-    }\n-    return U_SUCCESS(errorCode);\n-}\n-\n U_CDECL_END\n \n void InitCanonIterData::doInit(Normalizer2Impl *impl, UErrorCode &errorCode) {\n@@ -2438,20 +2395,31 @@ void InitCanonIterData::doInit(Normalizer2Impl *impl, UErrorCode &errorCode) {\n         errorCode=U_MEMORY_ALLOCATION_ERROR;\n     }\n     if (U_SUCCESS(errorCode)) {\n-        utrie2_enum(impl->normTrie, NULL, enumCIDRangeHandler, impl);\n-        utrie2_freeze(impl->fCanonIterData->trie, UTRIE2_32_VALUE_BITS, &errorCode);\n+        UChar32 start = 0, end;\n+        uint32_t value;\n+        while ((end = ucptrie_getRange(impl->normTrie, start,\n+                                       UCPMAP_RANGE_FIXED_LEAD_SURROGATES, Normalizer2Impl::INERT,\n+                                       nullptr, nullptr, &value)) >= 0) {\n+            // Call Normalizer2Impl::makeCanonIterDataFromNorm16() for a range of same-norm16 characters.\n+            if (value != Normalizer2Impl::INERT) {\n+                impl->makeCanonIterDataFromNorm16(start, end, value, *impl->fCanonIterData, errorCode);\n+            }\n+            start = end + 1;\n+        }\n+#ifdef UCPTRIE_DEBUG\n+        umutablecptrie_setName(impl->fCanonIterData->mutableTrie, \"CanonIterData\");\n+#endif\n+        impl->fCanonIterData->trie = umutablecptrie_buildImmutable(\n+            impl->fCanonIterData->mutableTrie, UCPTRIE_TYPE_SMALL, UCPTRIE_VALUE_BITS_32, &errorCode);\n+        umutablecptrie_close(impl->fCanonIterData->mutableTrie);\n+        impl->fCanonIterData->mutableTrie = nullptr;\n     }\n     if (U_FAILURE(errorCode)) {\n         delete impl->fCanonIterData;\n         impl->fCanonIterData = NULL;\n     }\n }\n \n-void InitCanonIterData::handleRange(\n-        Normalizer2Impl *impl, UChar32 start, UChar32 end, uint16_t value, UErrorCode &errorCode) {\n-    impl->makeCanonIterDataFromNorm16(start, end, value, *impl->fCanonIterData, errorCode);\n-}\n-\n void Normalizer2Impl::makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, const uint16_t norm16,\n                                                   CanonIterData &newData,\n                                                   UErrorCode &errorCode) const {\n@@ -2465,7 +2433,7 @@ void Normalizer2Impl::makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, co\n         return;\n     }\n     for(UChar32 c=start; c<=end; ++c) {\n-        uint32_t oldValue=utrie2_get32(newData.trie, c);\n+        uint32_t oldValue = umutablecptrie_get(newData.mutableTrie, c);\n         uint32_t newValue=oldValue;\n         if(isMaybeOrNonZeroCC(norm16)) {\n             // not a segment starter if it occurs in a decomposition or has cc!=0\n@@ -2483,7 +2451,7 @@ void Normalizer2Impl::makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, co\n             if (isDecompNoAlgorithmic(norm16_2)) {\n                 // Maps to an isCompYesAndZeroCC.\n                 c2 = mapAlgorithmic(c2, norm16_2);\n-                norm16_2 = getNorm16(c2);\n+                norm16_2 = getRawNorm16(c2);\n                 // No compatibility mappings for the CanonicalIterator.\n                 U_ASSERT(!(isHangulLV(norm16_2) || isHangulLVT(norm16_2)));\n             }\n@@ -2510,10 +2478,10 @@ void Normalizer2Impl::makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, co\n                     if(norm16_2>=minNoNo) {\n                         while(i<length) {\n                             U16_NEXT_UNSAFE(mapping, i, c2);\n-                            uint32_t c2Value=utrie2_get32(newData.trie, c2);\n+                            uint32_t c2Value = umutablecptrie_get(newData.mutableTrie, c2);\n                             if((c2Value&CANON_NOT_SEGMENT_STARTER)==0) {\n-                                utrie2_set32(newData.trie, c2, c2Value|CANON_NOT_SEGMENT_STARTER,\n-                                             &errorCode);\n+                                umutablecptrie_set(newData.mutableTrie, c2,\n+                                                   c2Value|CANON_NOT_SEGMENT_STARTER, &errorCode);\n                             }\n                         }\n                     }\n@@ -2524,7 +2492,7 @@ void Normalizer2Impl::makeCanonIterDataFromNorm16(UChar32 start, UChar32 end, co\n             }\n         }\n         if(newValue!=oldValue) {\n-            utrie2_set32(newData.trie, c, newValue, &errorCode);\n+            umutablecptrie_set(newData.mutableTrie, c, newValue, &errorCode);\n         }\n     }\n }\n@@ -2537,7 +2505,7 @@ UBool Normalizer2Impl::ensureCanonIterData(UErrorCode &errorCode) const {\n }\n \n int32_t Normalizer2Impl::getCanonValue(UChar32 c) const {\n-    return (int32_t)utrie2_get32(fCanonIterData->trie, c);\n+    return (int32_t)ucptrie_get(fCanonIterData->trie, c);\n }\n \n const UnicodeSet &Normalizer2Impl::getCanonStartSet(int32_t n) const {\n@@ -2561,7 +2529,7 @@ UBool Normalizer2Impl::getCanonStartSet(UChar32 c, UnicodeSet &set) const {\n         set.add(value);\n     }\n     if((canonValue&CANON_HAS_COMPOSITIONS)!=0) {\n-        uint16_t norm16=getNorm16(c);\n+        uint16_t norm16=getRawNorm16(c);\n         if(norm16==JAMO_L) {\n             UChar32 syllable=\n                 (UChar32)(Hangul::HANGUL_BASE+(c-Hangul::JAMO_L_BASE)*Hangul::JAMO_VT_COUNT);\n@@ -2608,7 +2576,7 @@ unorm2_swap(const UDataSwapper *ds,\n         pInfo->dataFormat[1]==0x72 &&\n         pInfo->dataFormat[2]==0x6d &&\n         pInfo->dataFormat[3]==0x32 &&\n-        (1<=formatVersion0 && formatVersion0<=3)\n+        (1<=formatVersion0 && formatVersion0<=4)\n     )) {\n         udata_printError(ds, \"unorm2_swap(): data format %02x.%02x.%02x.%02x (format version %02x) is not recognized as Normalizer2 data\\n\",\n                          pInfo->dataFormat[0], pInfo->dataFormat[1],\n@@ -2669,9 +2637,9 @@ unorm2_swap(const UDataSwapper *ds,\n         ds->swapArray32(ds, inBytes, nextOffset-offset, outBytes, pErrorCode);\n         offset=nextOffset;\n \n-        /* swap the UTrie2 */\n+        /* swap the trie */\n         nextOffset=indexes[Normalizer2Impl::IX_EXTRA_DATA_OFFSET];\n-        utrie2_swap(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);\n+        utrie_swapAnyVersion(ds, inBytes+offset, nextOffset-offset, outBytes+offset, pErrorCode);\n         offset=nextOffset;\n \n         /* swap the uint16_t extraData[] */"
        },
        {
            "sha": "2e6aff308819c51bbf249f504cf467066026a8ce",
            "filename": "deps/icu-small/source/common/normalizer2impl.h",
            "status": "modified",
            "additions": 35,
            "deletions": 9,
            "changes": 44,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fnormalizer2impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fnormalizer2impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fnormalizer2impl.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -24,12 +24,20 @@\n #if !UCONFIG_NO_NORMALIZATION\n \n #include \"unicode/normalizer2.h\"\n+#include \"unicode/ucptrie.h\"\n #include \"unicode/unistr.h\"\n #include \"unicode/unorm.h\"\n+#include \"unicode/utf.h\"\n #include \"unicode/utf16.h\"\n #include \"mutex.h\"\n+#include \"udataswp.h\"\n #include \"uset_imp.h\"\n-#include \"utrie2.h\"\n+\n+// When the nfc.nrm data is *not* hardcoded into the common library\n+// (with this constant set to 0),\n+// then it needs to be built into the data package:\n+// Add nfc.nrm to icu4c/source/data/Makefile.in DAT_FILES_SHORT\n+#define NORM2_HARDCODE_NFC_DATA 1\n \n U_NAMESPACE_BEGIN\n \n@@ -118,7 +126,7 @@ class U_COMMON_API Hangul {\n             buffer[0]=(UChar)(JAMO_L_BASE+c/JAMO_V_COUNT);\n             buffer[1]=(UChar)(JAMO_V_BASE+c%JAMO_V_COUNT);\n         } else {\n-            buffer[0]=orig-c2;  // LV syllable\n+            buffer[0]=(UChar)(orig-c2);  // LV syllable\n             buffer[1]=(UChar)(JAMO_T_BASE+c2);\n         }\n     }\n@@ -158,8 +166,7 @@ class U_COMMON_API ReorderingBuffer : public UMemory {\n             appendBMP((UChar)c, cc, errorCode) :\n             appendSupplementary(c, cc, errorCode);\n     }\n-    // s must be in NFD, otherwise change the implementation.\n-    UBool append(const UChar *s, int32_t length,\n+    UBool append(const UChar *s, int32_t length, UBool isNFD,\n                  uint8_t leadCC, uint8_t trailCC,\n                  UErrorCode &errorCode);\n     UBool appendBMP(UChar c, uint8_t cc, UErrorCode &errorCode) {\n@@ -243,7 +250,7 @@ class U_COMMON_API Normalizer2Impl : public UObject {\n     }\n     virtual ~Normalizer2Impl();\n \n-    void init(const int32_t *inIndexes, const UTrie2 *inTrie,\n+    void init(const int32_t *inIndexes, const UCPTrie *inTrie,\n               const uint16_t *inExtraData, const uint8_t *inSmallFCD);\n \n     void addLcccChars(UnicodeSet &set) const;\n@@ -254,7 +261,12 @@ class U_COMMON_API Normalizer2Impl : public UObject {\n \n     UBool ensureCanonIterData(UErrorCode &errorCode) const;\n \n-    uint16_t getNorm16(UChar32 c) const { return UTRIE2_GET16(normTrie, c); }\n+    // The trie stores values for lead surrogate code *units*.\n+    // Surrogate code *points* are inert.\n+    uint16_t getNorm16(UChar32 c) const {\n+        return U_IS_LEAD(c) ? INERT : UCPTRIE_FAST_GET(normTrie, UCPTRIE_16, c);\n+    }\n+    uint16_t getRawNorm16(UChar32 c) const { return UCPTRIE_FAST_GET(normTrie, UCPTRIE_16, c); }\n \n     UNormalizationCheckResult getCompQuickCheck(uint16_t norm16) const {\n         if(norm16<minNoNo || MIN_YES_YES_WITH_CC<=norm16) {\n@@ -704,7 +716,7 @@ class U_COMMON_API Normalizer2Impl : public UObject {\n     uint16_t centerNoNoDelta;\n     uint16_t minMaybeYes;\n \n-    const UTrie2 *normTrie;\n+    const UCPTrie *normTrie;\n     const uint16_t *maybeYesCompositions;\n     const uint16_t *extraData;  // mappings and/or compositions for yesYes, yesNo & noNo characters\n     const uint8_t *smallFCD;  // [0x100] one bit per 32 BMP code points, set if any FCD!=0\n@@ -764,7 +776,7 @@ unorm_getFCD16(UChar32 c);\n \n /**\n  * Format of Normalizer2 .nrm data files.\n- * Format version 3.0.\n+ * Format version 4.0.\n  *\n  * Normalizer2 .nrm data files provide data for the Unicode Normalization algorithms.\n  * ICU ships with data files for standard Unicode Normalization Forms\n@@ -818,7 +830,7 @@ unorm_getFCD16(UChar32 c);\n  *          minMaybeYes=indexes[IX_MIN_MAYBE_YES];\n  *      See the normTrie description below and the design doc for details.\n  *\n- * UTrie2 normTrie; -- see utrie2_impl.h and utrie2.h\n+ * UCPTrie normTrie; -- see ucptrie_impl.h and ucptrie.h, same as Java CodePointTrie\n  *\n  *      The trie holds the main normalization data. Each code point is mapped to a 16-bit value.\n  *      Rather than using independent bits in the value (which would require more than 16 bits),\n@@ -946,6 +958,20 @@ unorm_getFCD16(UChar32 c);\n  *   which is artificially assigned \"worst case\" values lccc=1 and tccc=255.\n  *\n  * - A mapping to an empty string has explicit lccc=1 and tccc=255 values.\n+ *\n+ * Changes from format version 3 to format version 4 (ICU 63) ------------------\n+ *\n+ * Switched from UTrie2 to UCPTrie/CodePointTrie.\n+ *\n+ * The new trie no longer stores different values for surrogate code *units* vs.\n+ * surrogate code *points*.\n+ * Lead surrogates still have values for optimized UTF-16 string processing.\n+ * When looking up code point properties, the code now checks for lead surrogates and\n+ * treats them as inert.\n+ *\n+ * gennorm2 now has to reject mappings for surrogate code points.\n+ * UTS #46 maps unpaired surrogates to U+FFFD in code rather than via its\n+ * custom normalization data file.\n  */\n \n #endif  /* !UCONFIG_NO_NORMALIZATION */"
        },
        {
            "sha": "15a3301e47df6f180ca086536c2b94d233ad9b7f",
            "filename": "deps/icu-small/source/common/propname_data.h",
            "status": "modified",
            "additions": 1059,
            "deletions": 947,
            "changes": 2006,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fpropname_data.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fpropname_data.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fpropname_data.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "b1193d7c6b8827ab2c4673dd28b92107f99af523",
            "filename": "deps/icu-small/source/common/putil.cpp",
            "status": "modified",
            "additions": 66,
            "deletions": 121,
            "changes": 187,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fputil.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fputil.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fputil.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -102,9 +102,8 @@\n #   define NOMCX\n #   include <windows.h>\n #   include \"unicode/uloc.h\"\n-#if U_PLATFORM_HAS_WINUWP_API == 0\n #   include \"wintz.h\"\n-#else // U_PLATFORM_HAS_WINUWP_API\n+#if U_PLATFORM_HAS_WINUWP_API\n typedef PVOID LPMSG; // TODO: figure out how to get rid of this typedef\n #include <Windows.Globalization.h>\n #include <windows.system.userprofile.h>\n@@ -1062,53 +1061,13 @@ uprv_tzname_clear_cache()\n #endif\n }\n \n-// With the Universal Windows Platform we can just ask Windows for the name\n-#if U_PLATFORM_HAS_WINUWP_API\n-U_CAPI const char* U_EXPORT2\n-uprv_getWindowsTimeZone()\n-{\n-    // Get default Windows timezone.\n-    ComPtr<IInspectable> calendar;\n-    HRESULT hr = RoActivateInstance(\n-        HStringReference(RuntimeClass_Windows_Globalization_Calendar).Get(),\n-        &calendar);\n-    if (SUCCEEDED(hr))\n-    {\n-        ComPtr<ABI::Windows::Globalization::ITimeZoneOnCalendar> timezone;\n-        hr = calendar.As(&timezone);\n-        if (SUCCEEDED(hr))\n-        {\n-            HString timezoneString;\n-            hr = timezone->GetTimeZone(timezoneString.GetAddressOf());\n-            if (SUCCEEDED(hr))\n-            {\n-                int32_t length = static_cast<int32_t>(wcslen(timezoneString.GetRawBuffer(NULL)));\n-                char* asciiId = (char*)uprv_calloc(length + 1, sizeof(char));\n-                if (asciiId != nullptr)\n-                {\n-                    u_UCharsToChars((UChar*)timezoneString.GetRawBuffer(NULL), asciiId, length);\n-                    return asciiId;\n-                }\n-            }\n-        }\n-    }\n-\n-    // Failed\n-    return nullptr;\n-}\n-#endif\n-\n U_CAPI const char* U_EXPORT2\n uprv_tzname(int n)\n {\n     (void)n; // Avoid unreferenced parameter warning.\n     const char *tzid = NULL;\n #if U_PLATFORM_USES_ONLY_WIN32_API\n-#if U_PLATFORM_HAS_WINUWP_API > 0\n-    tzid = uprv_getWindowsTimeZone();\n-#else\n     tzid = uprv_detectWindowsTimeZone();\n-#endif\n \n     if (tzid != NULL) {\n         return tzid;\n@@ -1366,6 +1325,43 @@ uprv_pathIsAbsolute(const char *path)\n # endif\n #endif\n \n+#if U_PLATFORM_HAS_WINUWP_API != 0\n+// Helper function to get the ICU Data Directory under the Windows directory location.\n+static BOOL U_CALLCONV getIcuDataDirectoryUnderWindowsDirectory(char* directoryBuffer, UINT bufferLength)\n+{\n+#if defined(ICU_DATA_DIR_WINDOWS)\n+    wchar_t windowsPath[MAX_PATH];\n+    char windowsPathUtf8[MAX_PATH];\n+\n+    UINT length = GetSystemWindowsDirectoryW(windowsPath, UPRV_LENGTHOF(windowsPath));\n+    if ((length > 0) && (length < (UPRV_LENGTHOF(windowsPath) - 1))) {\n+        // Convert UTF-16 to a UTF-8 string.\n+        UErrorCode status = U_ZERO_ERROR;\n+        int32_t windowsPathUtf8Len = 0;\n+        u_strToUTF8(windowsPathUtf8, static_cast<int32_t>(UPRV_LENGTHOF(windowsPathUtf8)),\n+            &windowsPathUtf8Len, reinterpret_cast<const UChar*>(windowsPath), -1, &status);\n+\n+        if (U_SUCCESS(status) && (status != U_STRING_NOT_TERMINATED_WARNING) &&\n+            (windowsPathUtf8Len < (UPRV_LENGTHOF(windowsPathUtf8) - 1))) {\n+            // Ensure it always has a separator, so we can append the ICU data path.\n+            if (windowsPathUtf8[windowsPathUtf8Len - 1] != U_FILE_SEP_CHAR) {\n+                windowsPathUtf8[windowsPathUtf8Len++] = U_FILE_SEP_CHAR;\n+                windowsPathUtf8[windowsPathUtf8Len] = '\\0';\n+            }\n+            // Check if the concatenated string will fit.\n+            if ((windowsPathUtf8Len + UPRV_LENGTHOF(ICU_DATA_DIR_WINDOWS)) < bufferLength) {\n+                uprv_strcpy(directoryBuffer, windowsPathUtf8);\n+                uprv_strcat(directoryBuffer, ICU_DATA_DIR_WINDOWS);\n+                return TRUE;\n+            }\n+        }\n+    }\n+#endif\n+\n+    return FALSE;\n+}\n+#endif\n+\n static void U_CALLCONV dataDirectoryInitFn() {\n     /* If we already have the directory, then return immediately. Will happen if user called\n      * u_setDataDirectory().\n@@ -1425,24 +1421,10 @@ static void U_CALLCONV dataDirectoryInitFn() {\n     }\n #endif\n \n-#if defined(ICU_DATA_DIR_WINDOWS) && U_PLATFORM_HAS_WINUWP_API != 0\n-    // Use data from the %windir%\\globalization\\icu directory\n-    // This is only available if ICU is built as a system component\n+#if U_PLATFORM_HAS_WINUWP_API != 0  && defined(ICU_DATA_DIR_WINDOWS)\n     char datadir_path_buffer[MAX_PATH];\n-    UINT length = GetWindowsDirectoryA(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer));\n-    if (length > 0 && length < (UPRV_LENGTHOF(datadir_path_buffer) - sizeof(ICU_DATA_DIR_WINDOWS) - 1))\n-    {\n-        if (datadir_path_buffer[length - 1] != '\\\\')\n-        {\n-            datadir_path_buffer[length++] = '\\\\';\n-            datadir_path_buffer[length] = '\\0';\n-        }\n-\n-        if ((length + 1 + sizeof(ICU_DATA_DIR_WINDOWS)) < UPRV_LENGTHOF(datadir_path_buffer))\n-        {\n-            uprv_strcat(datadir_path_buffer, ICU_DATA_DIR_WINDOWS);\n-            path = datadir_path_buffer;\n-        }\n+    if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {\n+        path = datadir_path_buffer;\n     }\n #endif\n \n@@ -1491,20 +1473,30 @@ static void U_CALLCONV TimeZoneDataDirInitFn(UErrorCode &status) {\n         status = U_MEMORY_ALLOCATION_ERROR;\n         return;\n     }\n-#if U_PLATFORM_HAS_WINUWP_API == 0\n-    const char *dir = getenv(\"ICU_TIMEZONE_FILES_DIR\");\n-#else\n-    // TODO: UWP does not support alternate timezone data directories at this time\n+\n     const char *dir = \"\";\n+\n+#if U_PLATFORM_HAS_WINUWP_API != 0\n+    // The UWP version does not support the environment variable setting, but can possibly pick them up from the Windows directory.\n+    char datadir_path_buffer[MAX_PATH];\n+    if (getIcuDataDirectoryUnderWindowsDirectory(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer))) {\n+        dir = datadir_path_buffer;\n+    }\n+#else\n+    dir = getenv(\"ICU_TIMEZONE_FILES_DIR\");\n #endif // U_PLATFORM_HAS_WINUWP_API\n+\n #if defined(U_TIMEZONE_FILES_DIR)\n     if (dir == NULL) {\n+        // Build time configuration setting.\n         dir = TO_STRING(U_TIMEZONE_FILES_DIR);\n     }\n #endif\n+\n     if (dir == NULL) {\n         dir = \"\";\n     }\n+\n     setTimeZoneFilesDir(dir, status);\n }\n \n@@ -1676,7 +1668,8 @@ The leftmost codepage (.xxx) wins.\n     /* Note that we scan the *uncorrected* ID. */\n     if ((p = uprv_strrchr(posixID, '@')) != NULL) {\n         if (correctedPOSIXLocale == NULL) {\n-            correctedPOSIXLocale = static_cast<char *>(uprv_malloc(uprv_strlen(posixID)+1));\n+            /* new locale can be 1 char longer than old one if @ -> __ */\n+            correctedPOSIXLocale = static_cast<char *>(uprv_malloc(uprv_strlen(posixID)+2));\n             /* Exit on memory allocation error. */\n             if (correctedPOSIXLocale == NULL) {\n                 return NULL;\n@@ -1693,7 +1686,7 @@ The leftmost codepage (.xxx) wins.\n         }\n \n         if (uprv_strchr(correctedPOSIXLocale,'_') == NULL) {\n-            uprv_strcat(correctedPOSIXLocale, \"__\"); /* aa@b -> aa__b */\n+            uprv_strcat(correctedPOSIXLocale, \"__\"); /* aa@b -> aa__b (note this can make the new locale 1 char longer) */\n         }\n         else {\n             uprv_strcat(correctedPOSIXLocale, \"_\"); /* aa_CC@b -> aa_CC_b */\n@@ -1747,70 +1740,22 @@ The leftmost codepage (.xxx) wins.\n #elif U_PLATFORM_USES_ONLY_WIN32_API\n #define POSIX_LOCALE_CAPACITY 64\n     UErrorCode status = U_ZERO_ERROR;\n-    char *correctedPOSIXLocale = 0;\n+    char *correctedPOSIXLocale = nullptr;\n \n     // If we have already figured this out just use the cached value\n-    if (gCorrectedPOSIXLocale != NULL) {\n+    if (gCorrectedPOSIXLocale != nullptr) {\n         return gCorrectedPOSIXLocale;\n     }\n \n     // No cached value, need to determine the current value\n-    static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH];\n-#if U_PLATFORM_HAS_WINUWP_API == 0\n-    // If not a Universal Windows App, we'll need user default language.\n-    // Vista and above should use Locale Names instead of LCIDs\n-    int length = GetUserDefaultLocaleName(windowsLocale, UPRV_LENGTHOF(windowsLocale));\n-#else\n-    // In a UWP app, we want the top language that the application and user agreed upon\n-    ComPtr<ABI::Windows::Foundation::Collections::IVectorView<HSTRING>> languageList;\n-\n-    ComPtr<ABI::Windows::Globalization::IApplicationLanguagesStatics> applicationLanguagesStatics;\n-    HRESULT hr = GetActivationFactory(\n-        HStringReference(RuntimeClass_Windows_Globalization_ApplicationLanguages).Get(),\n-        &applicationLanguagesStatics);\n-    if (SUCCEEDED(hr))\n-    {\n-        hr = applicationLanguagesStatics->get_Languages(&languageList);\n-    }\n+    static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH] = {};\n+    int length = GetLocaleInfoEx(LOCALE_NAME_USER_DEFAULT, LOCALE_SNAME, windowsLocale, LOCALE_NAME_MAX_LENGTH);\n \n-    if (FAILED(hr))\n-    {\n-        // If there is no application context, then use the top language from the user language profile\n-        ComPtr<ABI::Windows::System::UserProfile::IGlobalizationPreferencesStatics> globalizationPreferencesStatics;\n-        hr = GetActivationFactory(\n-            HStringReference(RuntimeClass_Windows_System_UserProfile_GlobalizationPreferences).Get(),\n-            &globalizationPreferencesStatics);\n-        if (SUCCEEDED(hr))\n-        {\n-            hr = globalizationPreferencesStatics->get_Languages(&languageList);\n-        }\n-    }\n-\n-    // We have a list of languages, ICU knows one, so use the top one for our locale\n-    HString topLanguage;\n-    if (SUCCEEDED(hr))\n-    {\n-        hr = languageList->GetAt(0, topLanguage.GetAddressOf());\n-    }\n-\n-    if (FAILED(hr))\n-    {\n-        // Unexpected, use en-US by default\n-        if (gCorrectedPOSIXLocale == NULL) {\n-            gCorrectedPOSIXLocale = \"en_US\";\n-        }\n-\n-        return gCorrectedPOSIXLocale;\n-    }\n-\n-    // ResolveLocaleName will get a likely subtags form consistent with Windows behavior.\n-    int length = ResolveLocaleName(topLanguage.GetRawBuffer(NULL), windowsLocale, UPRV_LENGTHOF(windowsLocale));\n-#endif\n-    // Now we should have a Windows locale name that needs converted to the POSIX style,\n-    if (length > 0)\n+    // Now we should have a Windows locale name that needs converted to the POSIX style.\n+    if (length > 0) // If length is 0, then the GetLocaleInfoEx failed.\n     {\n         // First we need to go from UTF-16 to char (and also convert from _ to - while we're at it.)\n-        char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH];\n+        char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH] = {};\n \n         int32_t i;\n         for (i = 0; i < UPRV_LENGTHOF(modifiedWindowsLocale); i++)\n@@ -1858,7 +1803,7 @@ The leftmost codepage (.xxx) wins.\n     }\n \n     // If unable to find a locale we can agree upon, use en-US by default\n-    if (gCorrectedPOSIXLocale == NULL) {\n+    if (gCorrectedPOSIXLocale == nullptr) {\n         gCorrectedPOSIXLocale = \"en_US\";\n     }\n     return gCorrectedPOSIXLocale;"
        },
        {
            "sha": "f744746b1f0feb1c5557bdfa7938479c6b7c4cdf",
            "filename": "deps/icu-small/source/common/putilimp.h",
            "status": "modified",
            "additions": 50,
            "deletions": 19,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fputilimp.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fputilimp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fputilimp.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -94,7 +94,7 @@ typedef size_t uintptr_t;\n #   define U_NL_LANGINFO_CODESET CODESET\n #endif\n \n-#ifdef U_TZSET\n+#if defined(U_TZSET) || defined(U_HAVE_TZSET)\n     /* Use the predefined value. */\n #elif U_PLATFORM_USES_ONLY_WIN32_API\n     // UWP doesn't support tzset or environment variables for tz\n@@ -132,7 +132,7 @@ typedef size_t uintptr_t;\n #   define U_TIMEZONE timezone\n #endif\n \n-#ifdef U_TZNAME\n+#if defined(U_TZNAME) || defined(U_HAVE_TZNAME)\n     /* Use the predefined value. */\n #elif U_PLATFORM_USES_ONLY_WIN32_API\n     /* not usable on all windows platforms */\n@@ -204,30 +204,18 @@ typedef size_t uintptr_t;\n \n /**\n  * \\def U_HAVE_STD_ATOMICS\n- * Defines whether the standard C++11 <atomic> is available.\n- * ICU will use this when available,\n- * otherwise will fall back to compiler or platform specific alternatives.\n+ * Defines whether to use the standard C++11 <atomic> functions\n+ * If false, ICU will fall back to compiler or platform specific alternatives.\n+ * Note: support for these fall back options for atomics will be removed in a future version\n+ *       of ICU, and the use of C++ 11 atomics will be required.\n  * @internal\n  */\n #ifdef U_HAVE_STD_ATOMICS\n     /* Use the predefined value. */\n-#elif U_CPLUSPLUS_VERSION < 11\n-    /* Not C++11, disable use of atomics */\n-#   define U_HAVE_STD_ATOMICS 0\n-#elif __clang__ && __clang_major__==3 && __clang_minor__<=1\n-    /* Clang 3.1, has atomic variable initializer bug. */\n-#   define U_HAVE_STD_ATOMICS 0\n #else\n-    /* U_HAVE_ATOMIC is typically set by an autoconf test of #include <atomic>  */\n-    /*   Can be set manually, or left undefined, on platforms without autoconf. */\n-#   if defined(U_HAVE_ATOMIC) &&  U_HAVE_ATOMIC\n-#      define U_HAVE_STD_ATOMICS 1\n-#   else\n-#      define U_HAVE_STD_ATOMICS 0\n-#   endif\n+#    define U_HAVE_STD_ATOMICS 1\n #endif\n \n-\n /**\n  *  \\def U_HAVE_CLANG_ATOMICS\n  *  Defines whether Clang c11 style built-in atomics are available.\n@@ -586,6 +574,49 @@ U_INTERNAL void * U_EXPORT2 uprv_maximumPtr(void *base);\n #  endif\n #endif\n \n+\n+#ifdef __cplusplus\n+/**\n+ * Pin a buffer capacity such that doing pointer arithmetic\n+ * on the destination pointer and capacity cannot overflow.\n+ *\n+ * The pinned capacity must fulfill the following conditions (for positive capacities):\n+ *   - dest + capacity is a valid pointer according to the machine arcitecture (AS/400, 64-bit, etc.)\n+ *   - (dest + capacity) >= dest\n+ *   - The size (in bytes) of T[capacity] does not exceed 0x7fffffff\n+ *\n+ * @param dest the destination buffer pointer.\n+ * @param capacity the requested buffer capacity, in units of type T.\n+ * @return the pinned capacity.\n+ * @internal\n+ */\n+template <typename T>\n+inline int32_t pinCapacity(T *dest, int32_t capacity) {\n+    if (capacity <= 0) { return capacity; }\n+\n+    uintptr_t destInt = (uintptr_t)dest;\n+    uintptr_t maxInt;\n+\n+#  if U_PLATFORM == U_PF_OS390 && !defined(_LP64)\n+    // We have 31-bit pointers.\n+    maxInt = 0x7fffffff;\n+#  elif U_PLATFORM == U_PF_OS400\n+    maxInt = (uintptr_t)uprv_maximumPtr((void *)dest);\n+#  else\n+    maxInt = destInt + 0x7fffffffu;\n+    if (maxInt < destInt) {\n+        // Less than 2GB to the end of the address space.\n+        // Pin to that to prevent address overflow.\n+        maxInt = (uintptr_t)-1;\n+    }\n+#  endif\n+\n+    uintptr_t maxBytes = maxInt - destInt;  // max. 2GB\n+    int32_t maxCapacity = (int32_t)(maxBytes / sizeof(T));\n+    return capacity <= maxCapacity ? capacity : maxCapacity;\n+}\n+#endif   // __cplusplus\n+\n /*  Dynamic Library Functions */\n \n typedef void (UVoidFunction)(void);"
        },
        {
            "sha": "cb3766506f4082e655648ce321fcc7006f8144b9",
            "filename": "deps/icu-small/source/common/rbbi.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -18,6 +18,8 @@\n \n #if !UCONFIG_NO_BREAK_ITERATION\n \n+#include <cinttypes>\n+\n #include \"unicode/rbbi.h\"\n #include \"unicode/schriter.h\"\n #include \"unicode/uchriter.h\"\n@@ -628,7 +630,7 @@ int32_t RuleBasedBreakIterator::preceding(int32_t offset) {\n     // or on a trail byte if the input is UTF-8.\n \n     utext_setNativeIndex(&fText, offset);\n-    int32_t adjustedOffset = utext_getNativeIndex(&fText);\n+    int32_t adjustedOffset = static_cast<int32_t>(utext_getNativeIndex(&fText));\n \n     UErrorCode status = U_ZERO_ERROR;\n     fBreakCache->preceding(adjustedOffset, status);\n@@ -655,7 +657,7 @@ UBool RuleBasedBreakIterator::isBoundary(int32_t offset) {\n     // But we still need the side effect of leaving iteration at the following boundary.\n \n     utext_setNativeIndex(&fText, offset);\n-    int32_t adjustedOffset = utext_getNativeIndex(&fText);\n+    int32_t adjustedOffset = static_cast<int32_t>(utext_getNativeIndex(&fText));\n \n     bool result = false;\n     UErrorCode status = U_ZERO_ERROR;\n@@ -848,7 +850,7 @@ int32_t RuleBasedBreakIterator::handleNext() {\n \n        #ifdef RBBI_DEBUG\n             if (gTrace) {\n-                RBBIDebugPrintf(\"             %4ld   \", utext_getNativeIndex(&fText));\n+                RBBIDebugPrintf(\"             %4\" PRId64 \"   \", utext_getNativeIndex(&fText));\n                 if (0x20<=c && c<0x7f) {\n                     RBBIDebugPrintf(\"\\\"%c\\\"  \", c);\n                 } else {"
        },
        {
            "sha": "519c61049894e65c854f0514a2b64296eee262b6",
            "filename": "deps/icu-small/source/common/rbbi_cache.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi_cache.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi_cache.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbi_cache.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -603,7 +603,7 @@ void RuleBasedBreakIterator::BreakCache::addFollowing(int32_t position, int32_t\n         fStartBufIdx = modChunkSize(fStartBufIdx + 6);    // TODO: experiment. Probably revert to 1.\n     }\n     fBoundaries[nextIdx] = position;\n-    fStatuses[nextIdx] = ruleStatusIdx;\n+    fStatuses[nextIdx] = static_cast<uint16_t>(ruleStatusIdx);\n     fEndBufIdx = nextIdx;\n     if (update == UpdateCachePosition) {\n         // Set current position to the newly added boundary.\n@@ -631,7 +631,7 @@ bool RuleBasedBreakIterator::BreakCache::addPreceding(int32_t position, int32_t\n         fEndBufIdx = modChunkSize(fEndBufIdx - 1);\n     }\n     fBoundaries[nextIdx] = position;\n-    fStatuses[nextIdx] = ruleStatusIdx;\n+    fStatuses[nextIdx] = static_cast<uint16_t>(ruleStatusIdx);\n     fStartBufIdx = nextIdx;\n     if (update == UpdateCachePosition) {\n         fBufIdx = nextIdx;"
        },
        {
            "sha": "5f5661af94776de61c4fa47310b12e1fca26bf01",
            "filename": "deps/icu-small/source/common/rbbirb.cpp",
            "status": "modified",
            "additions": 17,
            "deletions": 10,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbirb.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbirb.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbirb.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -303,17 +303,24 @@ RBBIDataHeader *RBBIRuleBuilder::build(UErrorCode &status) {\n }\n \n void RBBIRuleBuilder::optimizeTables() {\n+    bool didSomething;\n+    do {\n+        didSomething = false;\n+\n+        // Begin looking for duplicates with char class 3.\n+        // Classes 0, 1 and 2 are special; they are unused, {bof} and {eof} respectively,\n+        // and should not have other categories merged into them.\n+        IntPair duplPair = {3, 0};\n+        while (fForwardTable->findDuplCharClassFrom(&duplPair)) {\n+            fSetBuilder->mergeCategories(duplPair);\n+            fForwardTable->removeColumn(duplPair.second);\n+            didSomething = true;\n+        }\n \n-    // Begin looking for duplicates with char class 3.\n-    // Classes 0, 1 and 2 are special; they are unused, {bof} and {eof} respectively,\n-    // and should not have other categories merged into them.\n-    IntPair duplPair = {3, 0};\n-\n-    while (fForwardTable->findDuplCharClassFrom(&duplPair)) {\n-        fSetBuilder->mergeCategories(duplPair);\n-        fForwardTable->removeColumn(duplPair.second);\n-    }\n-    fForwardTable->removeDuplicateStates();\n+        while (fForwardTable->removeDuplicateStates() > 0) {\n+            didSomething = true;\n+        }\n+    } while (didSomething);\n }\n \n U_NAMESPACE_END"
        },
        {
            "sha": "170c212e13fd1f1c1114a7d461a6c4b378a58cd3",
            "filename": "deps/icu-small/source/common/rbbiscan.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbiscan.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbiscan.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbiscan.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -380,7 +380,7 @@ UBool RBBIRuleScanner::doParseActions(int32_t action)\n             // with the current rule expression (on the Node Stack)\n             //  with the resulting OR expression going to *destRules\n             //\n-            RBBINode  *thisRule    = fNodeStack[fNodeStackPtr];\n+                       thisRule    = fNodeStack[fNodeStackPtr];\n             RBBINode  *prevRules   = *destRules;\n             RBBINode  *orNode      = pushNewNode(RBBINode::opOr);\n             if (U_FAILURE(*fRB->fStatus)) {"
        },
        {
            "sha": "e6ae2dc654a88c4ebc485135f54584c1538b1b79",
            "filename": "deps/icu-small/source/common/rbbitblb.cpp",
            "status": "modified",
            "additions": 23,
            "deletions": 18,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -428,8 +428,8 @@ void RBBITableBuilder::calcChainedFollowPos(RBBINode *tree) {\n     addRuleRootNodes(&ruleRootNodes, tree);\n \n     UVector matchStartNodes(*fStatus);\n-    for (int i=0; i<ruleRootNodes.size(); ++i) {\n-        RBBINode *node = static_cast<RBBINode *>(ruleRootNodes.elementAt(i));\n+    for (int j=0; j<ruleRootNodes.size(); ++j) {\n+        RBBINode *node = static_cast<RBBINode *>(ruleRootNodes.elementAt(j));\n         if (node->fChainIn) {\n             setAdd(&matchStartNodes, node->fFirstPosSet);\n         }\n@@ -1082,21 +1082,22 @@ bool RBBITableBuilder::findDuplCharClassFrom(IntPair *categories) {\n     int32_t numStates = fDStates->size();\n     int32_t numCols = fRB->fSetBuilder->getNumCharCategories();\n \n-    uint16_t table_base;\n-    uint16_t table_dupl;\n     for (; categories->first < numCols-1; categories->first++) {\n         for (categories->second=categories->first+1; categories->second < numCols; categories->second++) {\n-             for (int32_t state=0; state<numStates; state++) {\n-                 RBBIStateDescriptor *sd = (RBBIStateDescriptor *)fDStates->elementAt(state);\n-                 table_base = (uint16_t)sd->fDtran->elementAti(categories->first);\n-                 table_dupl = (uint16_t)sd->fDtran->elementAti(categories->second);\n-                 if (table_base != table_dupl) {\n-                     break;\n-                 }\n-             }\n-             if (table_base == table_dupl) {\n-                 return true;\n-             }\n+            // Initialized to different values to prevent returning true if numStates = 0 (implies no duplicates).\n+            uint16_t table_base = 0;\n+            uint16_t table_dupl = 1;\n+            for (int32_t state=0; state<numStates; state++) {\n+                RBBIStateDescriptor *sd = (RBBIStateDescriptor *)fDStates->elementAt(state);\n+                table_base = (uint16_t)sd->fDtran->elementAti(categories->first);\n+                table_dupl = (uint16_t)sd->fDtran->elementAti(categories->second);\n+                if (table_base != table_dupl) {\n+                    break;\n+                }\n+            }\n+            if (table_base == table_dupl) {\n+                return true;\n+            }\n         }\n     }\n     return false;\n@@ -1236,7 +1237,7 @@ void RBBITableBuilder::removeSafeState(IntPair duplStates) {\n             } else if (existingVal > duplState) {\n                 newVal = existingVal - 1;\n             }\n-            sd->setCharAt(col, newVal);\n+            sd->setCharAt(col, static_cast<char16_t>(newVal));\n         }\n     }\n }\n@@ -1245,12 +1246,16 @@ void RBBITableBuilder::removeSafeState(IntPair duplStates) {\n /*\n  * RemoveDuplicateStates\n  */\n-void RBBITableBuilder::removeDuplicateStates() {\n+int32_t RBBITableBuilder::removeDuplicateStates() {\n     IntPair dupls = {3, 0};\n+    int32_t numStatesRemoved = 0;\n+\n     while (findDuplicateState(&dupls)) {\n         // printf(\"Removing duplicate states (%d, %d)\\n\", dupls.first, dupls.second);\n         removeState(dupls);\n+        ++numStatesRemoved;\n     }\n+    return numStatesRemoved;\n }\n \n \n@@ -1411,7 +1416,7 @@ void RBBITableBuilder::buildSafeReverseTable(UErrorCode &status) {\n     UnicodeString &startState = *static_cast<UnicodeString *>(fSafeTable->elementAt(1));\n     for (int32_t charClass=0; charClass < numCharClasses; ++charClass) {\n         // Note: +2 for the start & stop state.\n-        startState.setCharAt(charClass, charClass+2);\n+        startState.setCharAt(charClass, static_cast<char16_t>(charClass+2));\n     }\n \n     // Initially make every other state table row look like the start state row,"
        },
        {
            "sha": "bc6077bb4da3dc6dcc206464d62280fb806555b3",
            "filename": "deps/icu-small/source/common/rbbitblb.h",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Frbbitblb.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -15,6 +15,9 @@\n #define RBBITBLB_H\n \n #include \"unicode/utypes.h\"\n+\n+#if !UCONFIG_NO_BREAK_ITERATION\n+\n #include \"unicode/uobject.h\"\n #include \"unicode/rbbi.h\"\n #include \"rbbirb.h\"\n@@ -66,8 +69,11 @@ class RBBITableBuilder : public UMemory {\n      */\n     void     removeColumn(int32_t column);\n \n-    /** Check for, and remove dupicate states (table rows). */\n-    void     removeDuplicateStates();\n+    /**\n+     * Check for, and remove dupicate states (table rows).\n+     * @return the number of states removed.\n+     */\n+    int32_t  removeDuplicateStates();\n \n     /** Build the safe reverse table from the already-constructed forward table. */\n     void     buildSafeReverseTable(UErrorCode &status);\n@@ -204,4 +210,7 @@ class RBBIStateDescriptor : public UMemory {\n \n \n U_NAMESPACE_END\n+\n+#endif /* #if !UCONFIG_NO_BREAK_ITERATION */\n+\n #endif"
        },
        {
            "sha": "2fb35bd1a5994fa461d769de3644a7810da5c8d3",
            "filename": "deps/icu-small/source/common/serv.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fserv.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fserv.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fserv.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -702,9 +702,9 @@ ICUService::getDisplayName(const UnicodeString& id, UnicodeString& result, const\n             }\n \n             // fallback\n-            UErrorCode status = U_ZERO_ERROR;\n+            status = U_ZERO_ERROR;\n             ICUServiceKey* fallbackKey = createKey(&id, status);\n-            while (fallbackKey->fallback()) {\n+            while (fallbackKey != NULL && fallbackKey->fallback()) {\n                 UnicodeString us;\n                 fallbackKey->currentID(us);\n                 f = (ICUServiceFactory*)map->get(us);"
        },
        {
            "sha": "878594c7ffa772dba2ccfcec4340c27903a4e8b5",
            "filename": "deps/icu-small/source/common/sharedobject.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fsharedobject.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fsharedobject.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fsharedobject.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -104,7 +104,7 @@ class U_COMMON_API SharedObject : public UObject {\n     /**\n      * Deletes this object if it has no references.\n      * Available for non-cached SharedObjects only. Ownership of cached objects\n-     * is with the UnifiedCache, which is soley responsible for eviction and deletion.\n+     * is with the UnifiedCache, which is solely responsible for eviction and deletion.\n      */\n     void deleteIfZeroRefCount() const;\n "
        },
        {
            "sha": "5d598a0e33b6d46be0f650539d4c4dccde0e63de",
            "filename": "deps/icu-small/source/common/static_unicode_sets.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fstatic_unicode_sets.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fstatic_unicode_sets.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fstatic_unicode_sets.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -27,6 +27,7 @@ UnicodeSet* gUnicodeSets[COUNT] = {};\n \n // Save the empty instance in static memory to have well-defined behavior if a\n // regular UnicodeSet cannot be allocated.\n+alignas(UnicodeSet)\n char gEmptyUnicodeSet[sizeof(UnicodeSet)];\n \n // Whether the gEmptyUnicodeSet is initialized and ready to use."
        },
        {
            "sha": "6f9cc2e5c22b55f8f0dba8b1354707e438a3cad1",
            "filename": "deps/icu-small/source/common/stringtriebuilder.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fstringtriebuilder.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fstringtriebuilder.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fstringtriebuilder.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -373,7 +373,7 @@ StringTrieBuilder::registerFinalValue(int32_t value, UErrorCode &errorCode) {\n     return newNode;\n }\n \n-UBool\n+int32_t\n StringTrieBuilder::hashNode(const void *node) {\n     return ((const Node *)node)->hashCode();\n }"
        },
        {
            "sha": "4b65d491859bfaa9616300d0b49b8f8b8c3f08e1",
            "filename": "deps/icu-small/source/common/ubidi.cpp",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fubidi.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -624,7 +624,7 @@ getDirProps(UBiDi *pBiDi) {\n         pBiDi->paras[pBiDi->paraCount-1].level=1;\n     }\n     if(isDefaultLevel) {\n-        pBiDi->paraLevel=pBiDi->paras[0].level;\n+        pBiDi->paraLevel=static_cast<UBiDiLevel>(pBiDi->paras[0].level);\n     }\n     /* The following is needed to resolve the text direction for default level\n        paragraphs containing no strong character */\n@@ -825,28 +825,28 @@ bracketProcessClosing(BracketData *bd, int32_t openIdx, int32_t position) {\n        N0c1. */\n \n     if((direction==0 && pOpening->flags&FOUND_L) ||\n-       (direction==1 && pOpening->flags&FOUND_R)) { /* N0b */\n-        newProp=direction;\n+       (direction==1 && pOpening->flags&FOUND_R)) {                         /* N0b */\n+        newProp=static_cast<DirProp>(direction);\n     }\n-    else if(pOpening->flags&(FOUND_L|FOUND_R)) {    /* N0c */\n+    else if(pOpening->flags&(FOUND_L|FOUND_R)) {                            /* N0c */\n         /* it is stable if there is no containing pair or in\n            conditions too complicated and not worth checking */\n         stable=(openIdx==pLastIsoRun->start);\n         if(direction!=pOpening->contextDir)\n-            newProp=pOpening->contextDir;           /* N0c1 */\n+            newProp= static_cast<DirProp>(pOpening->contextDir);           /* N0c1 */\n         else\n-            newProp=direction;                      /* N0c2 */\n+            newProp= static_cast<DirProp>(direction);                      /* N0c2 */\n     } else {\n         /* forget this and any brackets nested within this pair */\n-        pLastIsoRun->limit=openIdx;\n-        return ON;                                  /* N0d */\n+        pLastIsoRun->limit= static_cast<uint16_t>(openIdx);\n+        return ON;                                                          /* N0d */\n     }\n     bd->pBiDi->dirProps[pOpening->position]=newProp;\n     bd->pBiDi->dirProps[position]=newProp;\n     /* Update nested N0c pairs that may be affected */\n     fixN0c(bd, openIdx, pOpening->position, newProp);\n     if(stable) {\n-        pLastIsoRun->limit=openIdx; /* forget any brackets nested within this pair */\n+        pLastIsoRun->limit= static_cast<uint16_t>(openIdx); /* forget any brackets nested within this pair */\n         /* remove lower located synonyms if any */\n         while(pLastIsoRun->limit>pLastIsoRun->start &&\n               bd->openings[pLastIsoRun->limit-1].position==pOpening->position)\n@@ -918,7 +918,7 @@ bracketProcessChar(BracketData *bd, int32_t position) {\n            bracket or it is a case of N0d */\n         /* Now see if it is an opening bracket */\n         if(c)\n-            match=u_getBidiPairedBracket(c);    /* get the matching char */\n+            match= static_cast<UChar>(u_getBidiPairedBracket(c));    /* get the matching char */\n         else\n             match=0;\n         if(match!=c &&                  /* has a matching char */\n@@ -948,7 +948,7 @@ bracketProcessChar(BracketData *bd, int32_t position) {\n         pLastIsoRun->contextPos=position;\n     }\n     else if(dirProp<=R || dirProp==AL) {\n-        newProp=DIR_FROM_STRONG(dirProp);\n+        newProp= static_cast<DirProp>(DIR_FROM_STRONG(dirProp));\n         pLastIsoRun->lastBase=dirProp;\n         pLastIsoRun->lastStrong=dirProp;\n         pLastIsoRun->contextDir=(UBiDiDirection)newProp;\n@@ -1101,7 +1101,7 @@ resolveExplicitLevels(UBiDi *pBiDi, UErrorCode *pErrorCode) {\n             else\n                 start=pBiDi->paras[paraIndex-1].limit;\n             limit=pBiDi->paras[paraIndex].limit;\n-            level=pBiDi->paras[paraIndex].level;\n+            level= static_cast<UBiDiLevel>(pBiDi->paras[paraIndex].level);\n             for(i=start; i<limit; i++)\n                 levels[i]=level;\n         }\n@@ -1119,7 +1119,7 @@ resolveExplicitLevels(UBiDi *pBiDi, UErrorCode *pErrorCode) {\n             else\n                 start=pBiDi->paras[paraIndex-1].limit;\n             limit=pBiDi->paras[paraIndex].limit;\n-            level=pBiDi->paras[paraIndex].level;\n+            level= static_cast<UBiDiLevel>(pBiDi->paras[paraIndex].level);\n             for(i=start; i<limit; i++) {\n                 levels[i]=level;\n                 dirProp=dirProps[i];\n@@ -2827,7 +2827,7 @@ ubidi_setPara(UBiDi *pBiDi, const UChar *text, int32_t length,\n         DirProp dirProp;\n         for(i=0; i<pBiDi->paraCount; i++) {\n             last=(pBiDi->paras[i].limit)-1;\n-            level=pBiDi->paras[i].level;\n+            level= static_cast<UBiDiLevel>(pBiDi->paras[i].level);\n             if(level==0)\n                 continue;           /* LTR paragraph */\n             start= i==0 ? 0 : pBiDi->paras[i-1].limit;"
        },
        {
            "sha": "394df6092d21b1f2ffac5f546df58cec8e450518",
            "filename": "deps/icu-small/source/common/ubiditransform.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fubiditransform.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fubiditransform.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fubiditransform.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -146,7 +146,7 @@ static UBool\n action_reorder(UBiDiTransform *pTransform, UErrorCode *pErrorCode)\n {\n     ubidi_writeReordered(pTransform->pBidi, pTransform->dest, pTransform->destSize,\n-            pTransform->reorderingOptions, pErrorCode);\n+            static_cast<uint16_t>(pTransform->reorderingOptions), pErrorCode);\n \n     *pTransform->pDestLength = pTransform->srcLength;\n     pTransform->reorderingOptions = UBIDI_REORDER_DEFAULT;\n@@ -393,9 +393,9 @@ resolveBaseDirection(const UChar *text, uint32_t length,\n     switch (*pInLevel) {\n         case UBIDI_DEFAULT_LTR:\n         case UBIDI_DEFAULT_RTL: {\n-            UBiDiLevel level = ubidi_getBaseDirection(text, length);\n-            *pInLevel = level != UBIDI_NEUTRAL ? level\n-                    : *pInLevel == UBIDI_DEFAULT_RTL ? RTL : LTR;\n+            UBiDiLevel level = static_cast<UBiDiLevel>(ubidi_getBaseDirection(text, length));\n+            *pInLevel = static_cast<UBiDiLevel>(level != UBIDI_NEUTRAL) ? level\n+                    : *pInLevel == UBIDI_DEFAULT_RTL ? static_cast<UBiDiLevel>(RTL) : static_cast<UBiDiLevel>(LTR);\n             break;\n         }\n         default:"
        },
        {
            "sha": "50c8d20c1fce736b02f47bc03d05b522ee5be3b0",
            "filename": "deps/icu-small/source/common/ucase.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucase.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucase.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucase.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -270,6 +270,7 @@ ucase_addCaseClosure(UChar32 c, const USetAdder *sa) {\n             }\n         }\n         if(HAS_SLOT(excWord, UCASE_EXC_DELTA)) {\n+            pe=pe0;\n             int32_t delta;\n             GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);\n             sa->add(sa->set, (excWord&UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta);\n@@ -1167,7 +1168,7 @@ ucase_toFullLower(UChar32 c,\n \n         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) && UCASE_IS_UPPER_OR_TITLE(props)) {\n             int32_t delta;\n-            GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);\n+            GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe2, delta);\n             return (excWord&UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;\n         }\n         if(HAS_SLOT(excWord, UCASE_EXC_LOWER)) {\n@@ -1261,7 +1262,7 @@ toUpperOrTitle(UChar32 c,\n \n         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) && UCASE_GET_TYPE(props)==UCASE_LOWER) {\n             int32_t delta;\n-            GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);\n+            GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe2, delta);\n             return (excWord&UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;\n         }\n         if(!upperNotTitle && HAS_SLOT(excWord, UCASE_EXC_TITLE)) {\n@@ -1469,7 +1470,7 @@ ucase_toFullFolding(UChar32 c,\n         }\n         if(HAS_SLOT(excWord, UCASE_EXC_DELTA) && UCASE_IS_UPPER_OR_TITLE(props)) {\n             int32_t delta;\n-            GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe, delta);\n+            GET_SLOT_VALUE(excWord, UCASE_EXC_DELTA, pe2, delta);\n             return (excWord&UCASE_EXC_DELTA_IS_NEGATIVE)==0 ? c+delta : c-delta;\n         }\n         if(HAS_SLOT(excWord, UCASE_EXC_FOLD)) {"
        },
        {
            "sha": "0ca911b47d9875a7dcabadd0dad6b6d8ab611fcd",
            "filename": "deps/icu-small/source/common/ucln_cmn.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucln_cmn.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucln_cmn.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucln_cmn.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -45,14 +45,14 @@ typedef enum ECleanupCommonType {\n     UCLN_COMMON_CURRENCY,\n     UCLN_COMMON_LOADED_NORMALIZER2,\n     UCLN_COMMON_NORMALIZER2,\n+    UCLN_COMMON_CHARACTERPROPERTIES,\n     UCLN_COMMON_USET,\n     UCLN_COMMON_UNAMES,\n     UCLN_COMMON_UPROPS,\n     UCLN_COMMON_UCNV,\n     UCLN_COMMON_UCNV_IO,\n     UCLN_COMMON_UDATA,\n     UCLN_COMMON_PUTIL,\n-    UCLN_COMMON_LIST_FORMATTER,\n     UCLN_COMMON_UINIT,\n \n     /*"
        },
        {
            "sha": "abf302eaddb7a80b5545265adbc5d7e69c9422ef",
            "filename": "deps/icu-small/source/common/ucnv.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 10,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1743,13 +1743,9 @@ ucnv_fromUChars(UConverter *cnv,\n     }\n     if(srcLength>0) {\n         srcLimit=src+srcLength;\n+        destCapacity=pinCapacity(dest, destCapacity);\n         destLimit=dest+destCapacity;\n \n-        /* pin the destination limit to U_MAX_PTR; NULL check is for OS/400 */\n-        if(destLimit<dest || (destLimit==NULL && dest!=NULL)) {\n-            destLimit=(char *)U_MAX_PTR(dest);\n-        }\n-\n         /* perform the conversion */\n         ucnv_fromUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, TRUE, pErrorCode);\n         destLength=(int32_t)(dest-originalDest);\n@@ -1803,13 +1799,9 @@ ucnv_toUChars(UConverter *cnv,\n     }\n     if(srcLength>0) {\n         srcLimit=src+srcLength;\n+        destCapacity=pinCapacity(dest, destCapacity);\n         destLimit=dest+destCapacity;\n \n-        /* pin the destination limit to U_MAX_PTR; NULL check is for OS/400 */\n-        if(destLimit<dest || (destLimit==NULL && dest!=NULL)) {\n-            destLimit=(UChar *)U_MAX_PTR(dest);\n-        }\n-\n         /* perform the conversion */\n         ucnv_toUnicode(cnv, &dest, destLimit, &src, srcLimit, 0, TRUE, pErrorCode);\n         destLength=(int32_t)(dest-originalDest);"
        },
        {
            "sha": "4a35ff85e10fa0e479c4ac9fa7fc0be5534b657e",
            "filename": "deps/icu-small/source/common/ucnv2022.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv2022.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv2022.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv2022.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -2772,7 +2772,7 @@ UConverter_toUnicode_ISO_2022_KR_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,\n                         /* report a pair of illegal bytes if the second byte is not a DBCS starter */\n                         ++mySource;\n                         /* add another bit so that the code below writes 2 bytes in case of error */\n-                        mySourceChar = 0x10000 | (mySourceChar << 8) | trailByte;\n+                        mySourceChar = static_cast<UChar>(0x10000 | (mySourceChar << 8) | trailByte);\n                     }\n                 } else {\n                     args->converter->toUBytes[0] = (uint8_t)mySourceChar;\n@@ -3304,7 +3304,7 @@ UConverter_toUnicode_ISO_2022_CN_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,\n                     myData->isEmptySegment = FALSE;\t/* we are handling it, reset to avoid future spurious errors */\n                     *err = U_ILLEGAL_ESCAPE_SEQUENCE;\n                     args->converter->toUCallbackReason = UCNV_IRREGULAR;\n-                    args->converter->toUBytes[0] = mySourceChar;\n+                    args->converter->toUBytes[0] = static_cast<uint8_t>(mySourceChar);\n                     args->converter->toULength = 1;\n                     args->target = myTarget;\n                     args->source = mySource;"
        },
        {
            "sha": "b40e1b2c970e51c1aea820550cef1eaa21cc9ae9",
            "filename": "deps/icu-small/source/common/ucnv_ct.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_ct.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_ct.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_ct.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -180,7 +180,7 @@ _CompoundTextgetName(const UConverter* cnv);\n \n \n static int32_t findNextEsc(const char *source, const char *sourceLimit) {\n-    int32_t length = sourceLimit - source;\n+    int32_t length = static_cast<int32_t>(sourceLimit - source);\n     int32_t i;\n     for (i = 1; i < length; i++) {\n         if (*(source + i) == 0x1B) {"
        },
        {
            "sha": "6c1b87d3c939c697de30b52c41203503f67d7d60",
            "filename": "deps/icu-small/source/common/ucnv_u16.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u16.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u16.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u16.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -71,7 +71,7 @@ _UTF16BEFromUnicodeWithOffsets(UConverterFromUnicodeArgs *pArgs,\n \n     /* write the BOM if necessary */\n     if(cnv->fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {\n-        static const char bom[]={ (char)0xfe, (char)0xff };\n+        static const char bom[]={ (char)0xfeu, (char)0xffu };\n         ucnv_fromUWriteBytes(cnv,\n                              bom, 2,\n                              &pArgs->target, pArgs->targetLimit,\n@@ -672,7 +672,7 @@ _UTF16LEFromUnicodeWithOffsets(UConverterFromUnicodeArgs *pArgs,\n \n     /* write the BOM if necessary */\n     if(cnv->fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {\n-        static const char bom[]={ (char)0xff, (char)0xfe };\n+        static const char bom[]={ (char)0xffu, (char)0xfeu };\n         ucnv_fromUWriteBytes(cnv,\n                              bom, 2,\n                              &pArgs->target, pArgs->targetLimit,"
        },
        {
            "sha": "13444a3afd97f172623aaded4adda04face4d852",
            "filename": "deps/icu-small/source/common/ucnv_u32.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u32.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u32.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u32.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -228,7 +228,7 @@ T_UConverter_fromUnicode_UTF32_BE(UConverterFromUnicodeArgs * args,\n \n     /* write the BOM if necessary */\n     if(args->converter->fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {\n-        static const char bom[]={ 0, 0, (char)0xfe, (char)0xff };\n+        static const char bom[]={ 0, 0, (char)0xfeu, (char)0xffu };\n         ucnv_fromUWriteBytes(args->converter,\n                              bom, 4,\n                              &args->target, args->targetLimit,\n@@ -331,7 +331,7 @@ T_UConverter_fromUnicode_UTF32_BE_OFFSET_LOGIC(UConverterFromUnicodeArgs * args,\n \n     /* write the BOM if necessary */\n     if(args->converter->fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {\n-        static const char bom[]={ 0, 0, (char)0xfe, (char)0xff };\n+        static const char bom[]={ 0, 0, (char)0xfeu, (char)0xffu };\n         ucnv_fromUWriteBytes(args->converter,\n                              bom, 4,\n                              &args->target, args->targetLimit,\n@@ -706,7 +706,7 @@ T_UConverter_fromUnicode_UTF32_LE(UConverterFromUnicodeArgs * args,\n \n     /* write the BOM if necessary */\n     if(args->converter->fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {\n-        static const char bom[]={ (char)0xff, (char)0xfe, 0, 0 };\n+        static const char bom[]={ (char)0xffu, (char)0xfeu, 0, 0 };\n         ucnv_fromUWriteBytes(args->converter,\n                              bom, 4,\n                              &args->target, args->targetLimit,\n@@ -817,7 +817,7 @@ T_UConverter_fromUnicode_UTF32_LE_OFFSET_LOGIC(UConverterFromUnicodeArgs * args,\n \n     /* write the BOM if necessary */\n     if(args->converter->fromUnicodeStatus==UCNV_NEED_TO_WRITE_BOM) {\n-        static const char bom[]={ (char)0xff, (char)0xfe, 0, 0 };\n+        static const char bom[]={ (char)0xffu, (char)0xfeu, 0, 0 };\n         ucnv_fromUWriteBytes(args->converter,\n                              bom, 4,\n                              &args->target, args->targetLimit,\n@@ -1043,7 +1043,7 @@ _UTF32Open(UConverter *cnv,\n     _UTF32Reset(cnv, UCNV_RESET_BOTH);\n }\n \n-static const char utf32BOM[8]={ 0, 0, (char)0xfe, (char)0xff,    (char)0xff, (char)0xfe, 0, 0 };\n+static const char utf32BOM[8]={ 0, 0, (char)0xfeu, (char)0xffu, (char)0xffu, (char)0xfeu, 0, 0 };\n \n static void U_CALLCONV\n _UTF32ToUnicodeWithOffsets(UConverterToUnicodeArgs *pArgs,\n@@ -1071,7 +1071,7 @@ _UTF32ToUnicodeWithOffsets(UConverterToUnicodeArgs *pArgs,\n             b=*source;\n             if(b==0) {\n                 state=1; /* could be 00 00 FE FF */\n-            } else if(b==(char)0xff) {\n+            } else if(b==(char)0xffu) {\n                 state=5; /* could be FF FE 00 00 */\n             } else {\n                 state=8; /* default to UTF-32BE */"
        },
        {
            "sha": "878d67304c7d89d7c3de4a2d504092754bbc7ddb",
            "filename": "deps/icu-small/source/common/ucnv_u8.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u8.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u8.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnv_u8.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -108,7 +108,7 @@ static void  U_CALLCONV ucnv_toUnicode_UTF8 (UConverterToUnicodeArgs * args,\n                 if (mySource < sourceLimit)\n                 {\n                     toUBytes[i] = (char) (ch2 = *mySource);\n-                    if (!icu::UTF8::isValidTrail(ch, ch2, i, inBytes) &&\n+                    if (!icu::UTF8::isValidTrail(ch, static_cast<uint8_t>(ch2), i, inBytes) &&\n                             !(isCESU8 && i == 1 && ch == 0xed && U8_IS_TRAIL(ch2)))\n                     {\n                         break; /* i < inBytes */\n@@ -225,7 +225,7 @@ static void  U_CALLCONV ucnv_toUnicode_UTF8_OFFSETS_LOGIC (UConverterToUnicodeAr\n                 if (mySource < sourceLimit)\n                 {\n                     toUBytes[i] = (char) (ch2 = *mySource);\n-                    if (!icu::UTF8::isValidTrail(ch, ch2, i, inBytes) &&\n+                    if (!icu::UTF8::isValidTrail(ch, static_cast<uint8_t>(ch2), i, inBytes) &&\n                             !(isCESU8 && i == 1 && ch == 0xed && U8_IS_TRAIL(ch2)))\n                     {\n                         break; /* i < inBytes */"
        },
        {
            "sha": "31595374696d8cbcc14da2f4f5d68ba448254953",
            "filename": "deps/icu-small/source/common/ucnvhz.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvhz.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvhz.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvhz.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -199,7 +199,7 @@ UConverter_toUnicode_HZ_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,\n                         *err = U_ILLEGAL_ESCAPE_SEQUENCE;\n                         args->converter->toUCallbackReason = UCNV_IRREGULAR;\n                         args->converter->toUBytes[0] = UCNV_TILDE;\n-                        args->converter->toUBytes[1] = mySourceChar;\n+                        args->converter->toUBytes[1] = static_cast<uint8_t>(mySourceChar);\n                         args->converter->toULength = 2;\n                         args->target = myTarget;\n                         args->source = mySource;\n@@ -229,7 +229,7 @@ UConverter_toUnicode_HZ_OFFSETS_LOGIC(UConverterToUnicodeArgs *args,\n                         --mySource;\n                     } else {\n                         /* Include the current byte in the illegal sequence. */\n-                        args->converter->toUBytes[1] = mySourceChar;\n+                        args->converter->toUBytes[1] = static_cast<uint8_t>(mySourceChar);\n                         args->converter->toULength = 2;\n                     }\n                     args->target = myTarget;"
        },
        {
            "sha": "e1248a7bd3603563f6956a7ecdfab9cfdf667645",
            "filename": "deps/icu-small/source/common/ucnvmbcs.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvmbcs.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvmbcs.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvmbcs.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -4164,8 +4164,8 @@ ucnv_MBCSFromUnicodeWithOffsets(UConverterFromUnicodeArgs *pArgs,\n     nextSourceIndex=0;\n \n     /* Get the SI/SO character for the converter */\n-    siLength = getSISOBytes(SI, cnv->options, siBytes);\n-    soLength = getSISOBytes(SO, cnv->options, soBytes);\n+    siLength = static_cast<uint8_t>(getSISOBytes(SI, cnv->options, siBytes));\n+    soLength = static_cast<uint8_t>(getSISOBytes(SO, cnv->options, soBytes));\n \n     /* conversion loop */\n     /*"
        },
        {
            "sha": "6ccee1ae61fd70a4e9de2058061a45bae66488e6",
            "filename": "deps/icu-small/source/common/ucnvsel.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvsel.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvsel.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucnvsel.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -41,6 +41,7 @@\n #include \"propsvec.h\"\n #include \"uassert.h\"\n #include \"ucmndata.h\"\n+#include \"udataswp.h\"\n #include \"uenumimp.h\"\n #include \"cmemory.h\"\n #include \"cstring.h\"\n@@ -72,7 +73,7 @@ static void generateSelectorData(UConverterSelector* result,\n   // set errorValue to all-ones\n   for (int32_t col = 0; col < columns; col++) {\n     upvec_setValue(upvec, UPVEC_ERROR_VALUE_CP, UPVEC_ERROR_VALUE_CP,\n-                   col, ~0, ~0, status);\n+                   col, static_cast<uint32_t>(~0), static_cast<uint32_t>(~0), status);\n   }\n \n   for (int32_t i = 0; i < result->encodingsCount; ++i) {\n@@ -109,7 +110,7 @@ static void generateSelectorData(UConverterSelector* result,\n         // this will be reached for the converters that fill the set with\n         // strings. Those should be ignored by our system\n       } else {\n-        upvec_setValue(upvec, start_char, end_char, column, ~0, mask,\n+        upvec_setValue(upvec, start_char, end_char, column, static_cast<uint32_t>(~0), mask,\n                        status);\n       }\n     }\n@@ -130,7 +131,7 @@ static void generateSelectorData(UConverterSelector* result,\n       uset_getItem(excludedCodePoints, j, &start_char, &end_char, NULL, 0,\n                    status);\n       for (int32_t col = 0; col < columns; col++) {\n-        upvec_setValue(upvec, start_char, end_char, col, ~0, ~0,\n+        upvec_setValue(upvec, start_char, end_char, col, static_cast<uint32_t>(~0), static_cast<uint32_t>(~0),\n                       status);\n       }\n     }\n@@ -684,7 +685,7 @@ static int16_t countOnes(uint32_t* mask, int32_t len) {\n       ent &= ent - 1; // clear the least significant bit set\n     }\n   }\n-  return totalOnes;\n+  return static_cast<int16_t>(totalOnes);\n }\n \n "
        },
        {
            "sha": "97b5c4aff50c88df08c18b3089ac393f15a6aa62",
            "filename": "deps/icu-small/source/common/ucol_swp.cpp",
            "status": "modified",
            "additions": 0,
            "deletions": 75,
            "changes": 75,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucol_swp.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucol_swp.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucol_swp.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -28,81 +28,6 @@\n \n /* swapping ----------------------------------------------------------------- */\n \n-/*\n- * This performs data swapping for a folded trie (see utrie.c for details).\n- */\n-\n-U_CAPI int32_t U_EXPORT2\n-utrie_swap(const UDataSwapper *ds,\n-           const void *inData, int32_t length, void *outData,\n-           UErrorCode *pErrorCode) {\n-    const UTrieHeader *inTrie;\n-    UTrieHeader trie;\n-    int32_t size;\n-    UBool dataIs32;\n-\n-    if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {\n-        return 0;\n-    }\n-    if(ds==NULL || inData==NULL || (length>=0 && outData==NULL)) {\n-        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;\n-        return 0;\n-    }\n-\n-    /* setup and swapping */\n-    if(length>=0 && (uint32_t)length<sizeof(UTrieHeader)) {\n-        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n-        return 0;\n-    }\n-\n-    inTrie=(const UTrieHeader *)inData;\n-    trie.signature=ds->readUInt32(inTrie->signature);\n-    trie.options=ds->readUInt32(inTrie->options);\n-    trie.indexLength=udata_readInt32(ds, inTrie->indexLength);\n-    trie.dataLength=udata_readInt32(ds, inTrie->dataLength);\n-\n-    if( trie.signature!=0x54726965 ||\n-        (trie.options&UTRIE_OPTIONS_SHIFT_MASK)!=UTRIE_SHIFT ||\n-        ((trie.options>>UTRIE_OPTIONS_INDEX_SHIFT)&UTRIE_OPTIONS_SHIFT_MASK)!=UTRIE_INDEX_SHIFT ||\n-        trie.indexLength<UTRIE_BMP_INDEX_LENGTH ||\n-        (trie.indexLength&(UTRIE_SURROGATE_BLOCK_COUNT-1))!=0 ||\n-        trie.dataLength<UTRIE_DATA_BLOCK_LENGTH ||\n-        (trie.dataLength&(UTRIE_DATA_GRANULARITY-1))!=0 ||\n-        ((trie.options&UTRIE_OPTIONS_LATIN1_IS_LINEAR)!=0 && trie.dataLength<(UTRIE_DATA_BLOCK_LENGTH+0x100))\n-    ) {\n-        *pErrorCode=U_INVALID_FORMAT_ERROR; /* not a UTrie */\n-        return 0;\n-    }\n-\n-    dataIs32=(UBool)((trie.options&UTRIE_OPTIONS_DATA_IS_32_BIT)!=0);\n-    size=sizeof(UTrieHeader)+trie.indexLength*2+trie.dataLength*(dataIs32?4:2);\n-\n-    if(length>=0) {\n-        UTrieHeader *outTrie;\n-\n-        if(length<size) {\n-            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n-            return 0;\n-        }\n-\n-        outTrie=(UTrieHeader *)outData;\n-\n-        /* swap the header */\n-        ds->swapArray32(ds, inTrie, sizeof(UTrieHeader), outTrie, pErrorCode);\n-\n-        /* swap the index and the data */\n-        if(dataIs32) {\n-            ds->swapArray16(ds, inTrie+1, trie.indexLength*2, outTrie+1, pErrorCode);\n-            ds->swapArray32(ds, (const uint16_t *)(inTrie+1)+trie.indexLength, trie.dataLength*4,\n-                                     (uint16_t *)(outTrie+1)+trie.indexLength, pErrorCode);\n-        } else {\n-            ds->swapArray16(ds, inTrie+1, (trie.indexLength+trie.dataLength)*2, outTrie+1, pErrorCode);\n-        }\n-    }\n-\n-    return size;\n-}\n-\n #if !UCONFIG_NO_COLLATION\n \n U_CAPI UBool U_EXPORT2"
        },
        {
            "sha": "13496ad56c5e586de497233a3a5b3b6eb2b71240",
            "filename": "deps/icu-small/source/common/ucptrie.cpp",
            "status": "added",
            "additions": 590,
            "deletions": 0,
            "changes": 590,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucptrie.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucptrie.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucptrie.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,590 @@\n+// Â© 2017 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+// ucptrie.cpp (modified from utrie2.cpp)\n+// created: 2017dec29 Markus W. Scherer\n+\n+// #define UCPTRIE_DEBUG\n+#ifdef UCPTRIE_DEBUG\n+#   include <stdio.h>\n+#endif\n+\n+#include \"unicode/utypes.h\"\n+#include \"unicode/ucptrie.h\"\n+#include \"unicode/utf.h\"\n+#include \"unicode/utf8.h\"\n+#include \"unicode/utf16.h\"\n+#include \"cmemory.h\"\n+#include \"uassert.h\"\n+#include \"ucptrie_impl.h\"\n+\n+U_CAPI UCPTrie * U_EXPORT2\n+ucptrie_openFromBinary(UCPTrieType type, UCPTrieValueWidth valueWidth,\n+                       const void *data, int32_t length, int32_t *pActualLength,\n+                       UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) {\n+        return nullptr;\n+    }\n+\n+    if (length <= 0 || (U_POINTER_MASK_LSB(data, 3) != 0) ||\n+            type < UCPTRIE_TYPE_ANY || UCPTRIE_TYPE_SMALL < type ||\n+            valueWidth < UCPTRIE_VALUE_BITS_ANY || UCPTRIE_VALUE_BITS_8 < valueWidth) {\n+        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return nullptr;\n+    }\n+\n+    // Enough data for a trie header?\n+    if (length < (int32_t)sizeof(UCPTrieHeader)) {\n+        *pErrorCode = U_INVALID_FORMAT_ERROR;\n+        return nullptr;\n+    }\n+\n+    // Check the signature.\n+    const UCPTrieHeader *header = (const UCPTrieHeader *)data;\n+    if (header->signature != UCPTRIE_SIG) {\n+        *pErrorCode = U_INVALID_FORMAT_ERROR;\n+        return nullptr;\n+    }\n+\n+    int32_t options = header->options;\n+    int32_t typeInt = (options >> 6) & 3;\n+    int32_t valueWidthInt = options & UCPTRIE_OPTIONS_VALUE_BITS_MASK;\n+    if (typeInt > UCPTRIE_TYPE_SMALL || valueWidthInt > UCPTRIE_VALUE_BITS_8 ||\n+            (options & UCPTRIE_OPTIONS_RESERVED_MASK) != 0) {\n+        *pErrorCode = U_INVALID_FORMAT_ERROR;\n+        return nullptr;\n+    }\n+    UCPTrieType actualType = (UCPTrieType)typeInt;\n+    UCPTrieValueWidth actualValueWidth = (UCPTrieValueWidth)valueWidthInt;\n+    if (type < 0) {\n+        type = actualType;\n+    }\n+    if (valueWidth < 0) {\n+        valueWidth = actualValueWidth;\n+    }\n+    if (type != actualType || valueWidth != actualValueWidth) {\n+        *pErrorCode = U_INVALID_FORMAT_ERROR;\n+        return nullptr;\n+    }\n+\n+    // Get the length values and offsets.\n+    UCPTrie tempTrie;\n+    uprv_memset(&tempTrie, 0, sizeof(tempTrie));\n+    tempTrie.indexLength = header->indexLength;\n+    tempTrie.dataLength =\n+        ((options & UCPTRIE_OPTIONS_DATA_LENGTH_MASK) << 4) | header->dataLength;\n+    tempTrie.index3NullOffset = header->index3NullOffset;\n+    tempTrie.dataNullOffset =\n+        ((options & UCPTRIE_OPTIONS_DATA_NULL_OFFSET_MASK) << 8) | header->dataNullOffset;\n+\n+    tempTrie.highStart = header->shiftedHighStart << UCPTRIE_SHIFT_2;\n+    tempTrie.shifted12HighStart = (tempTrie.highStart + 0xfff) >> 12;\n+    tempTrie.type = type;\n+    tempTrie.valueWidth = valueWidth;\n+\n+    // Calculate the actual length.\n+    int32_t actualLength = (int32_t)sizeof(UCPTrieHeader) + tempTrie.indexLength * 2;\n+    if (valueWidth == UCPTRIE_VALUE_BITS_16) {\n+        actualLength += tempTrie.dataLength * 2;\n+    } else if (valueWidth == UCPTRIE_VALUE_BITS_32) {\n+        actualLength += tempTrie.dataLength * 4;\n+    } else {\n+        actualLength += tempTrie.dataLength;\n+    }\n+    if (length < actualLength) {\n+        *pErrorCode = U_INVALID_FORMAT_ERROR;  // Not enough bytes.\n+        return nullptr;\n+    }\n+\n+    // Allocate the trie.\n+    UCPTrie *trie = (UCPTrie *)uprv_malloc(sizeof(UCPTrie));\n+    if (trie == nullptr) {\n+        *pErrorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return nullptr;\n+    }\n+    uprv_memcpy(trie, &tempTrie, sizeof(tempTrie));\n+#ifdef UCPTRIE_DEBUG\n+    trie->name = \"fromSerialized\";\n+#endif\n+\n+    // Set the pointers to its index and data arrays.\n+    const uint16_t *p16 = (const uint16_t *)(header + 1);\n+    trie->index = p16;\n+    p16 += trie->indexLength;\n+\n+    // Get the data.\n+    int32_t nullValueOffset = trie->dataNullOffset;\n+    if (nullValueOffset >= trie->dataLength) {\n+        nullValueOffset = trie->dataLength - UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET;\n+    }\n+    switch (valueWidth) {\n+    case UCPTRIE_VALUE_BITS_16:\n+        trie->data.ptr16 = p16;\n+        trie->nullValue = trie->data.ptr16[nullValueOffset];\n+        break;\n+    case UCPTRIE_VALUE_BITS_32:\n+        trie->data.ptr32 = (const uint32_t *)p16;\n+        trie->nullValue = trie->data.ptr32[nullValueOffset];\n+        break;\n+    case UCPTRIE_VALUE_BITS_8:\n+        trie->data.ptr8 = (const uint8_t *)p16;\n+        trie->nullValue = trie->data.ptr8[nullValueOffset];\n+        break;\n+    default:\n+        // Unreachable because valueWidth was checked above.\n+        *pErrorCode = U_INVALID_FORMAT_ERROR;\n+        return nullptr;\n+    }\n+\n+    if (pActualLength != nullptr) {\n+        *pActualLength = actualLength;\n+    }\n+    return trie;\n+}\n+\n+U_CAPI void U_EXPORT2\n+ucptrie_close(UCPTrie *trie) {\n+    uprv_free(trie);\n+}\n+\n+U_CAPI UCPTrieType U_EXPORT2\n+ucptrie_getType(const UCPTrie *trie) {\n+    return (UCPTrieType)trie->type;\n+}\n+\n+U_CAPI UCPTrieValueWidth U_EXPORT2\n+ucptrie_getValueWidth(const UCPTrie *trie) {\n+    return (UCPTrieValueWidth)trie->valueWidth;\n+}\n+\n+U_CAPI int32_t U_EXPORT2\n+ucptrie_internalSmallIndex(const UCPTrie *trie, UChar32 c) {\n+    int32_t i1 = c >> UCPTRIE_SHIFT_1;\n+    if (trie->type == UCPTRIE_TYPE_FAST) {\n+        U_ASSERT(0xffff < c && c < trie->highStart);\n+        i1 += UCPTRIE_BMP_INDEX_LENGTH - UCPTRIE_OMITTED_BMP_INDEX_1_LENGTH;\n+    } else {\n+        U_ASSERT((uint32_t)c < (uint32_t)trie->highStart && trie->highStart > UCPTRIE_SMALL_LIMIT);\n+        i1 += UCPTRIE_SMALL_INDEX_LENGTH;\n+    }\n+    int32_t i3Block = trie->index[\n+        (int32_t)trie->index[i1] + ((c >> UCPTRIE_SHIFT_2) & UCPTRIE_INDEX_2_MASK)];\n+    int32_t i3 = (c >> UCPTRIE_SHIFT_3) & UCPTRIE_INDEX_3_MASK;\n+    int32_t dataBlock;\n+    if ((i3Block & 0x8000) == 0) {\n+        // 16-bit indexes\n+        dataBlock = trie->index[i3Block + i3];\n+    } else {\n+        // 18-bit indexes stored in groups of 9 entries per 8 indexes.\n+        i3Block = (i3Block & 0x7fff) + (i3 & ~7) + (i3 >> 3);\n+        i3 &= 7;\n+        dataBlock = ((int32_t)trie->index[i3Block++] << (2 + (2 * i3))) & 0x30000;\n+        dataBlock |= trie->index[i3Block + i3];\n+    }\n+    return dataBlock + (c & UCPTRIE_SMALL_DATA_MASK);\n+}\n+\n+U_CAPI int32_t U_EXPORT2\n+ucptrie_internalSmallU8Index(const UCPTrie *trie, int32_t lt1, uint8_t t2, uint8_t t3) {\n+    UChar32 c = (lt1 << 12) | (t2 << 6) | t3;\n+    if (c >= trie->highStart) {\n+        // Possible because the UTF-8 macro compares with shifted12HighStart which may be higher.\n+        return trie->dataLength - UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET;\n+    }\n+    return ucptrie_internalSmallIndex(trie, c);\n+}\n+\n+U_CAPI int32_t U_EXPORT2\n+ucptrie_internalU8PrevIndex(const UCPTrie *trie, UChar32 c,\n+                            const uint8_t *start, const uint8_t *src) {\n+    int32_t i, length;\n+    // Support 64-bit pointers by avoiding cast of arbitrary difference.\n+    if ((src - start) <= 7) {\n+        i = length = (int32_t)(src - start);\n+    } else {\n+        i = length = 7;\n+        start = src - 7;\n+    }\n+    c = utf8_prevCharSafeBody(start, 0, &i, c, -1);\n+    i = length - i;  // Number of bytes read backward from src.\n+    int32_t idx = _UCPTRIE_CP_INDEX(trie, 0xffff, c);\n+    return (idx << 3) | i;\n+}\n+\n+namespace {\n+\n+inline uint32_t getValue(UCPTrieData data, UCPTrieValueWidth valueWidth, int32_t dataIndex) {\n+    switch (valueWidth) {\n+    case UCPTRIE_VALUE_BITS_16:\n+        return data.ptr16[dataIndex];\n+    case UCPTRIE_VALUE_BITS_32:\n+        return data.ptr32[dataIndex];\n+    case UCPTRIE_VALUE_BITS_8:\n+        return data.ptr8[dataIndex];\n+    default:\n+        // Unreachable if the trie is properly initialized.\n+        return 0xffffffff;\n+    }\n+}\n+\n+}  // namespace\n+\n+U_CAPI uint32_t U_EXPORT2\n+ucptrie_get(const UCPTrie *trie, UChar32 c) {\n+    int32_t dataIndex;\n+    if ((uint32_t)c <= 0x7f) {\n+        // linear ASCII\n+        dataIndex = c;\n+    } else {\n+        UChar32 fastMax = trie->type == UCPTRIE_TYPE_FAST ? 0xffff : UCPTRIE_SMALL_MAX;\n+        dataIndex = _UCPTRIE_CP_INDEX(trie, fastMax, c);\n+    }\n+    return getValue(trie->data, (UCPTrieValueWidth)trie->valueWidth, dataIndex);\n+}\n+\n+namespace {\n+\n+constexpr int32_t MAX_UNICODE = 0x10ffff;\n+\n+inline uint32_t maybeFilterValue(uint32_t value, uint32_t trieNullValue, uint32_t nullValue,\n+                                 UCPMapValueFilter *filter, const void *context) {\n+    if (value == trieNullValue) {\n+        value = nullValue;\n+    } else if (filter != nullptr) {\n+        value = filter(context, value);\n+    }\n+    return value;\n+}\n+\n+UChar32 getRange(const void *t, UChar32 start,\n+                 UCPMapValueFilter *filter, const void *context, uint32_t *pValue) {\n+    if ((uint32_t)start > MAX_UNICODE) {\n+        return U_SENTINEL;\n+    }\n+    const UCPTrie *trie = reinterpret_cast<const UCPTrie *>(t);\n+    UCPTrieValueWidth valueWidth = (UCPTrieValueWidth)trie->valueWidth;\n+    if (start >= trie->highStart) {\n+        if (pValue != nullptr) {\n+            int32_t di = trie->dataLength - UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET;\n+            uint32_t value = getValue(trie->data, valueWidth, di);\n+            if (filter != nullptr) { value = filter(context, value); }\n+            *pValue = value;\n+        }\n+        return MAX_UNICODE;\n+    }\n+\n+    uint32_t nullValue = trie->nullValue;\n+    if (filter != nullptr) { nullValue = filter(context, nullValue); }\n+    const uint16_t *index = trie->index;\n+\n+    int32_t prevI3Block = -1;\n+    int32_t prevBlock = -1;\n+    UChar32 c = start;\n+    uint32_t value;\n+    bool haveValue = false;\n+    do {\n+        int32_t i3Block;\n+        int32_t i3;\n+        int32_t i3BlockLength;\n+        int32_t dataBlockLength;\n+        if (c <= 0xffff && (trie->type == UCPTRIE_TYPE_FAST || c <= UCPTRIE_SMALL_MAX)) {\n+            i3Block = 0;\n+            i3 = c >> UCPTRIE_FAST_SHIFT;\n+            i3BlockLength = trie->type == UCPTRIE_TYPE_FAST ?\n+                UCPTRIE_BMP_INDEX_LENGTH : UCPTRIE_SMALL_INDEX_LENGTH;\n+            dataBlockLength = UCPTRIE_FAST_DATA_BLOCK_LENGTH;\n+        } else {\n+            // Use the multi-stage index.\n+            int32_t i1 = c >> UCPTRIE_SHIFT_1;\n+            if (trie->type == UCPTRIE_TYPE_FAST) {\n+                U_ASSERT(0xffff < c && c < trie->highStart);\n+                i1 += UCPTRIE_BMP_INDEX_LENGTH - UCPTRIE_OMITTED_BMP_INDEX_1_LENGTH;\n+            } else {\n+                U_ASSERT(c < trie->highStart && trie->highStart > UCPTRIE_SMALL_LIMIT);\n+                i1 += UCPTRIE_SMALL_INDEX_LENGTH;\n+            }\n+            i3Block = trie->index[\n+                (int32_t)trie->index[i1] + ((c >> UCPTRIE_SHIFT_2) & UCPTRIE_INDEX_2_MASK)];\n+            if (i3Block == prevI3Block && (c - start) >= UCPTRIE_CP_PER_INDEX_2_ENTRY) {\n+                // The index-3 block is the same as the previous one, and filled with value.\n+                U_ASSERT((c & (UCPTRIE_CP_PER_INDEX_2_ENTRY - 1)) == 0);\n+                c += UCPTRIE_CP_PER_INDEX_2_ENTRY;\n+                continue;\n+            }\n+            prevI3Block = i3Block;\n+            if (i3Block == trie->index3NullOffset) {\n+                // This is the index-3 null block.\n+                if (haveValue) {\n+                    if (nullValue != value) {\n+                        return c - 1;\n+                    }\n+                } else {\n+                    value = nullValue;\n+                    if (pValue != nullptr) { *pValue = nullValue; }\n+                    haveValue = true;\n+                }\n+                prevBlock = trie->dataNullOffset;\n+                c = (c + UCPTRIE_CP_PER_INDEX_2_ENTRY) & ~(UCPTRIE_CP_PER_INDEX_2_ENTRY - 1);\n+                continue;\n+            }\n+            i3 = (c >> UCPTRIE_SHIFT_3) & UCPTRIE_INDEX_3_MASK;\n+            i3BlockLength = UCPTRIE_INDEX_3_BLOCK_LENGTH;\n+            dataBlockLength = UCPTRIE_SMALL_DATA_BLOCK_LENGTH;\n+        }\n+        // Enumerate data blocks for one index-3 block.\n+        do {\n+            int32_t block;\n+            if ((i3Block & 0x8000) == 0) {\n+                block = index[i3Block + i3];\n+            } else {\n+                // 18-bit indexes stored in groups of 9 entries per 8 indexes.\n+                int32_t group = (i3Block & 0x7fff) + (i3 & ~7) + (i3 >> 3);\n+                int32_t gi = i3 & 7;\n+                block = ((int32_t)index[group++] << (2 + (2 * gi))) & 0x30000;\n+                block |= index[group + gi];\n+            }\n+            if (block == prevBlock && (c - start) >= dataBlockLength) {\n+                // The block is the same as the previous one, and filled with value.\n+                U_ASSERT((c & (dataBlockLength - 1)) == 0);\n+                c += dataBlockLength;\n+            } else {\n+                int32_t dataMask = dataBlockLength - 1;\n+                prevBlock = block;\n+                if (block == trie->dataNullOffset) {\n+                    // This is the data null block.\n+                    if (haveValue) {\n+                        if (nullValue != value) {\n+                            return c - 1;\n+                        }\n+                    } else {\n+                        value = nullValue;\n+                        if (pValue != nullptr) { *pValue = nullValue; }\n+                        haveValue = true;\n+                    }\n+                    c = (c + dataBlockLength) & ~dataMask;\n+                } else {\n+                    int32_t di = block + (c & dataMask);\n+                    uint32_t value2 = getValue(trie->data, valueWidth, di);\n+                    value2 = maybeFilterValue(value2, trie->nullValue, nullValue,\n+                                              filter, context);\n+                    if (haveValue) {\n+                        if (value2 != value) {\n+                            return c - 1;\n+                        }\n+                    } else {\n+                        value = value2;\n+                        if (pValue != nullptr) { *pValue = value; }\n+                        haveValue = true;\n+                    }\n+                    while ((++c & dataMask) != 0) {\n+                        if (maybeFilterValue(getValue(trie->data, valueWidth, ++di),\n+                                             trie->nullValue, nullValue,\n+                                             filter, context) != value) {\n+                            return c - 1;\n+                        }\n+                    }\n+                }\n+            }\n+        } while (++i3 < i3BlockLength);\n+    } while (c < trie->highStart);\n+    U_ASSERT(haveValue);\n+    int32_t di = trie->dataLength - UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET;\n+    uint32_t highValue = getValue(trie->data, valueWidth, di);\n+    if (maybeFilterValue(highValue, trie->nullValue, nullValue,\n+                         filter, context) != value) {\n+        return c - 1;\n+    } else {\n+        return MAX_UNICODE;\n+    }\n+}\n+\n+}  // namespace\n+\n+U_CFUNC UChar32\n+ucptrie_internalGetRange(UCPTrieGetRange *getRange,\n+                         const void *trie, UChar32 start,\n+                         UCPMapRangeOption option, uint32_t surrogateValue,\n+                         UCPMapValueFilter *filter, const void *context, uint32_t *pValue) {\n+    if (option == UCPMAP_RANGE_NORMAL) {\n+        return getRange(trie, start, filter, context, pValue);\n+    }\n+    uint32_t value;\n+    if (pValue == nullptr) {\n+        // We need to examine the range value even if the caller does not want it.\n+        pValue = &value;\n+    }\n+    UChar32 surrEnd = option == UCPMAP_RANGE_FIXED_ALL_SURROGATES ? 0xdfff : 0xdbff;\n+    UChar32 end = getRange(trie, start, filter, context, pValue);\n+    if (end < 0xd7ff || start > surrEnd) {\n+        return end;\n+    }\n+    // The range overlaps with surrogates, or ends just before the first one.\n+    if (*pValue == surrogateValue) {\n+        if (end >= surrEnd) {\n+            // Surrogates followed by a non-surrogateValue range,\n+            // or surrogates are part of a larger surrogateValue range.\n+            return end;\n+        }\n+    } else {\n+        if (start <= 0xd7ff) {\n+            return 0xd7ff;  // Non-surrogateValue range ends before surrogateValue surrogates.\n+        }\n+        // Start is a surrogate with a non-surrogateValue code *unit* value.\n+        // Return a surrogateValue code *point* range.\n+        *pValue = surrogateValue;\n+        if (end > surrEnd) {\n+            return surrEnd;  // Surrogate range ends before non-surrogateValue rest of range.\n+        }\n+    }\n+    // See if the surrogateValue surrogate range can be merged with\n+    // an immediately following range.\n+    uint32_t value2;\n+    UChar32 end2 = getRange(trie, surrEnd + 1, filter, context, &value2);\n+    if (value2 == surrogateValue) {\n+        return end2;\n+    }\n+    return surrEnd;\n+}\n+\n+U_CAPI UChar32 U_EXPORT2\n+ucptrie_getRange(const UCPTrie *trie, UChar32 start,\n+                 UCPMapRangeOption option, uint32_t surrogateValue,\n+                 UCPMapValueFilter *filter, const void *context, uint32_t *pValue) {\n+    return ucptrie_internalGetRange(getRange, trie, start,\n+                                    option, surrogateValue,\n+                                    filter, context, pValue);\n+}\n+\n+U_CAPI int32_t U_EXPORT2\n+ucptrie_toBinary(const UCPTrie *trie,\n+                 void *data, int32_t capacity,\n+                 UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) {\n+        return 0;\n+    }\n+\n+    UCPTrieType type = (UCPTrieType)trie->type;\n+    UCPTrieValueWidth valueWidth = (UCPTrieValueWidth)trie->valueWidth;\n+    if (type < UCPTRIE_TYPE_FAST || UCPTRIE_TYPE_SMALL < type ||\n+            valueWidth < UCPTRIE_VALUE_BITS_16 || UCPTRIE_VALUE_BITS_8 < valueWidth ||\n+            capacity < 0 ||\n+            (capacity > 0 && (data == nullptr || (U_POINTER_MASK_LSB(data, 3) != 0)))) {\n+        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return 0;\n+    }\n+\n+    int32_t length = (int32_t)sizeof(UCPTrieHeader) + trie->indexLength * 2;\n+    switch (valueWidth) {\n+    case UCPTRIE_VALUE_BITS_16:\n+        length += trie->dataLength * 2;\n+        break;\n+    case UCPTRIE_VALUE_BITS_32:\n+        length += trie->dataLength * 4;\n+        break;\n+    case UCPTRIE_VALUE_BITS_8:\n+        length += trie->dataLength;\n+        break;\n+    default:\n+        // unreachable\n+        break;\n+    }\n+    if (capacity < length) {\n+        *pErrorCode = U_BUFFER_OVERFLOW_ERROR;\n+        return length;\n+    }\n+\n+    char *bytes = (char *)data;\n+    UCPTrieHeader *header = (UCPTrieHeader *)bytes;\n+    header->signature = UCPTRIE_SIG;  // \"Tri3\"\n+    header->options = (uint16_t)(\n+        ((trie->dataLength & 0xf0000) >> 4) |\n+        ((trie->dataNullOffset & 0xf0000) >> 8) |\n+        (trie->type << 6) |\n+        valueWidth);\n+    header->indexLength = (uint16_t)trie->indexLength;\n+    header->dataLength = (uint16_t)trie->dataLength;\n+    header->index3NullOffset = trie->index3NullOffset;\n+    header->dataNullOffset = (uint16_t)trie->dataNullOffset;\n+    header->shiftedHighStart = trie->highStart >> UCPTRIE_SHIFT_2;\n+    bytes += sizeof(UCPTrieHeader);\n+\n+    uprv_memcpy(bytes, trie->index, trie->indexLength * 2);\n+    bytes += trie->indexLength * 2;\n+\n+    switch (valueWidth) {\n+    case UCPTRIE_VALUE_BITS_16:\n+        uprv_memcpy(bytes, trie->data.ptr16, trie->dataLength * 2);\n+        break;\n+    case UCPTRIE_VALUE_BITS_32:\n+        uprv_memcpy(bytes, trie->data.ptr32, trie->dataLength * 4);\n+        break;\n+    case UCPTRIE_VALUE_BITS_8:\n+        uprv_memcpy(bytes, trie->data.ptr8, trie->dataLength);\n+        break;\n+    default:\n+        // unreachable\n+        break;\n+    }\n+    return length;\n+}\n+\n+namespace {\n+\n+#ifdef UCPTRIE_DEBUG\n+long countNull(const UCPTrie *trie) {\n+    uint32_t nullValue=trie->nullValue;\n+    int32_t length=trie->dataLength;\n+    long count=0;\n+    switch (trie->valueWidth) {\n+    case UCPTRIE_VALUE_BITS_16:\n+        for(int32_t i=0; i<length; ++i) {\n+            if(trie->data.ptr16[i]==nullValue) { ++count; }\n+        }\n+        break;\n+    case UCPTRIE_VALUE_BITS_32:\n+        for(int32_t i=0; i<length; ++i) {\n+            if(trie->data.ptr32[i]==nullValue) { ++count; }\n+        }\n+        break;\n+    case UCPTRIE_VALUE_BITS_8:\n+        for(int32_t i=0; i<length; ++i) {\n+            if(trie->data.ptr8[i]==nullValue) { ++count; }\n+        }\n+        break;\n+    default:\n+        // unreachable\n+        break;\n+    }\n+    return count;\n+}\n+\n+U_CFUNC void\n+ucptrie_printLengths(const UCPTrie *trie, const char *which) {\n+    long indexLength=trie->indexLength;\n+    long dataLength=(long)trie->dataLength;\n+    long totalLength=(long)sizeof(UCPTrieHeader)+indexLength*2+\n+            dataLength*(trie->valueWidth==UCPTRIE_VALUE_BITS_16 ? 2 :\n+                        trie->valueWidth==UCPTRIE_VALUE_BITS_32 ? 4 : 1);\n+    printf(\"**UCPTrieLengths(%s %s)** index:%6ld  data:%6ld  countNull:%6ld  serialized:%6ld\\n\",\n+           which, trie->name, indexLength, dataLength, countNull(trie), totalLength);\n+}\n+#endif\n+\n+}  // namespace\n+\n+// UCPMap ----\n+// Initially, this is the same as UCPTrie. This may well change.\n+\n+U_CAPI uint32_t U_EXPORT2\n+ucpmap_get(const UCPMap *map, UChar32 c) {\n+    return ucptrie_get(reinterpret_cast<const UCPTrie *>(map), c);\n+}\n+\n+U_CAPI UChar32 U_EXPORT2\n+ucpmap_getRange(const UCPMap *map, UChar32 start,\n+                UCPMapRangeOption option, uint32_t surrogateValue,\n+                UCPMapValueFilter *filter, const void *context, uint32_t *pValue) {\n+    return ucptrie_getRange(reinterpret_cast<const UCPTrie *>(map), start,\n+                            option, surrogateValue,\n+                            filter, context, pValue);\n+}"
        },
        {
            "sha": "1fe6a18ac5319e97ea2e3ff11342b5ca4d7ee2ed",
            "filename": "deps/icu-small/source/common/ucptrie_impl.h",
            "status": "added",
            "additions": 289,
            "deletions": 0,
            "changes": 289,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucptrie_impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucptrie_impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucptrie_impl.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,289 @@\n+// Â© 2017 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+// ucptrie_impl.h (modified from utrie2_impl.h)\n+// created: 2017dec29 Markus W. Scherer\n+\n+#ifndef __UCPTRIE_IMPL_H__\n+#define __UCPTRIE_IMPL_H__\n+\n+#include \"unicode/ucptrie.h\"\n+#ifdef UCPTRIE_DEBUG\n+#include \"unicode/umutablecptrie.h\"\n+#endif\n+\n+// UCPTrie signature values, in platform endianness and opposite endianness.\n+// The UCPTrie signature ASCII byte values spell \"Tri3\".\n+#define UCPTRIE_SIG     0x54726933\n+#define UCPTRIE_OE_SIG  0x33697254\n+\n+/**\n+ * Header data for the binary, memory-mappable representation of a UCPTrie/CodePointTrie.\n+ * @internal\n+ */\n+struct UCPTrieHeader {\n+    /** \"Tri3\" in big-endian US-ASCII (0x54726933) */\n+    uint32_t signature;\n+\n+    /**\n+     * Options bit field:\n+     * Bits 15..12: Data length bits 19..16.\n+     * Bits 11..8: Data null block offset bits 19..16.\n+     * Bits 7..6: UCPTrieType\n+     * Bits 5..3: Reserved (0).\n+     * Bits 2..0: UCPTrieValueWidth\n+     */\n+    uint16_t options;\n+\n+    /** Total length of the index tables. */\n+    uint16_t indexLength;\n+\n+    /** Data length bits 15..0. */\n+    uint16_t dataLength;\n+\n+    /** Index-3 null block offset, 0x7fff or 0xffff if none. */\n+    uint16_t index3NullOffset;\n+\n+    /** Data null block offset bits 15..0, 0xfffff if none. */\n+    uint16_t dataNullOffset;\n+\n+    /**\n+     * First code point of the single-value range ending with U+10ffff,\n+     * rounded up and then shifted right by UCPTRIE_SHIFT_2.\n+     */\n+    uint16_t shiftedHighStart;\n+};\n+\n+/**\n+ * Constants for use with UCPTrieHeader.options.\n+ * @internal\n+ */\n+enum {\n+    UCPTRIE_OPTIONS_DATA_LENGTH_MASK = 0xf000,\n+    UCPTRIE_OPTIONS_DATA_NULL_OFFSET_MASK = 0xf00,\n+    UCPTRIE_OPTIONS_RESERVED_MASK = 0x38,\n+    UCPTRIE_OPTIONS_VALUE_BITS_MASK = 7,\n+    /**\n+     * Value for index3NullOffset which indicates that there is no index-3 null block.\n+     * Bit 15 is unused for this value because this bit is used if the index-3 contains\n+     * 18-bit indexes.\n+     */\n+    UCPTRIE_NO_INDEX3_NULL_OFFSET = 0x7fff,\n+    UCPTRIE_NO_DATA_NULL_OFFSET = 0xfffff\n+};\n+\n+// Internal constants.\n+enum {\n+    /** The length of the BMP index table. 1024=0x400 */\n+    UCPTRIE_BMP_INDEX_LENGTH = 0x10000 >> UCPTRIE_FAST_SHIFT,\n+\n+    UCPTRIE_SMALL_LIMIT = 0x1000,\n+    UCPTRIE_SMALL_INDEX_LENGTH = UCPTRIE_SMALL_LIMIT >> UCPTRIE_FAST_SHIFT,\n+\n+    /** Shift size for getting the index-3 table offset. */\n+    UCPTRIE_SHIFT_3 = 4,\n+\n+    /** Shift size for getting the index-2 table offset. */\n+    UCPTRIE_SHIFT_2 = 5 + UCPTRIE_SHIFT_3,\n+\n+    /** Shift size for getting the index-1 table offset. */\n+    UCPTRIE_SHIFT_1 = 5 + UCPTRIE_SHIFT_2,\n+\n+    /**\n+     * Difference between two shift sizes,\n+     * for getting an index-2 offset from an index-3 offset. 5=9-4\n+     */\n+    UCPTRIE_SHIFT_2_3 = UCPTRIE_SHIFT_2 - UCPTRIE_SHIFT_3,\n+\n+    /**\n+     * Difference between two shift sizes,\n+     * for getting an index-1 offset from an index-2 offset. 5=14-9\n+     */\n+    UCPTRIE_SHIFT_1_2 = UCPTRIE_SHIFT_1 - UCPTRIE_SHIFT_2,\n+\n+    /**\n+     * Number of index-1 entries for the BMP. (4)\n+     * This part of the index-1 table is omitted from the serialized form.\n+     */\n+    UCPTRIE_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UCPTRIE_SHIFT_1,\n+\n+    /** Number of entries in an index-2 block. 32=0x20 */\n+    UCPTRIE_INDEX_2_BLOCK_LENGTH = 1 << UCPTRIE_SHIFT_1_2,\n+\n+    /** Mask for getting the lower bits for the in-index-2-block offset. */\n+    UCPTRIE_INDEX_2_MASK = UCPTRIE_INDEX_2_BLOCK_LENGTH - 1,\n+\n+    /** Number of code points per index-2 table entry. 512=0x200 */\n+    UCPTRIE_CP_PER_INDEX_2_ENTRY = 1 << UCPTRIE_SHIFT_2,\n+\n+    /** Number of entries in an index-3 block. 32=0x20 */\n+    UCPTRIE_INDEX_3_BLOCK_LENGTH = 1 << UCPTRIE_SHIFT_2_3,\n+\n+    /** Mask for getting the lower bits for the in-index-3-block offset. */\n+    UCPTRIE_INDEX_3_MASK = UCPTRIE_INDEX_3_BLOCK_LENGTH - 1,\n+\n+    /** Number of entries in a small data block. 16=0x10 */\n+    UCPTRIE_SMALL_DATA_BLOCK_LENGTH = 1 << UCPTRIE_SHIFT_3,\n+\n+    /** Mask for getting the lower bits for the in-small-data-block offset. */\n+    UCPTRIE_SMALL_DATA_MASK = UCPTRIE_SMALL_DATA_BLOCK_LENGTH - 1\n+};\n+\n+typedef UChar32\n+UCPTrieGetRange(const void *trie, UChar32 start,\n+                UCPMapValueFilter *filter, const void *context, uint32_t *pValue);\n+\n+U_CFUNC UChar32\n+ucptrie_internalGetRange(UCPTrieGetRange *getRange,\n+                         const void *trie, UChar32 start,\n+                         UCPMapRangeOption option, uint32_t surrogateValue,\n+                         UCPMapValueFilter *filter, const void *context, uint32_t *pValue);\n+\n+#ifdef UCPTRIE_DEBUG\n+U_CFUNC void\n+ucptrie_printLengths(const UCPTrie *trie, const char *which);\n+\n+U_CFUNC void umutablecptrie_setName(UMutableCPTrie *builder, const char *name);\n+#endif\n+\n+/*\n+ * Format of the binary, memory-mappable representation of a UCPTrie/CodePointTrie.\n+ * For overview information see http://site.icu-project.org/design/struct/utrie\n+ *\n+ * The binary trie data should be 32-bit-aligned.\n+ * The overall layout is:\n+ *\n+ * UCPTrieHeader header; -- 16 bytes, see struct definition above\n+ * uint16_t index[header.indexLength];\n+ * uintXY_t data[header.dataLength];\n+ *\n+ * The trie data array is an array of uint16_t, uint32_t, or uint8_t,\n+ * specified via the UCPTrieValueWidth when building the trie.\n+ * The data array is 32-bit-aligned for uint32_t, otherwise 16-bit-aligned.\n+ * The overall length of the trie data is a multiple of 4 bytes.\n+ * (Padding is added at the end of the index array and/or near the end of the data array as needed.)\n+ *\n+ * The length of the data array (dataLength) is stored as an integer split across two fields\n+ * of the header struct (high bits in header.options).\n+ *\n+ * The trie type can be \"fast\" or \"small\" which determines the index structure,\n+ * specified via the UCPTrieType when building the trie.\n+ *\n+ * The type and valueWidth are stored in the header.options.\n+ * There are reserved type and valueWidth values, and reserved header.options bits.\n+ * They could be used in future format extensions.\n+ * Code reading the trie structure must fail with an error when unknown values or options are set.\n+ *\n+ * Values for ASCII character (U+0000..U+007F) can always be found at the start of the data array.\n+ *\n+ * Values for code points below a type-specific fast-indexing limit are found via two-stage lookup.\n+ * For a \"fast\" trie, the limit is the BMP/supplementary boundary at U+10000.\n+ * For a \"small\" trie, the limit is UCPTRIE_SMALL_MAX+1=U+1000.\n+ *\n+ * All code points in the range highStart..U+10FFFF map to a single highValue\n+ * which is stored at the second-to-last position of the data array.\n+ * (See UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET.)\n+ * The highStart value is header.shiftedHighStart<<UCPTRIE_SHIFT_2.\n+ * (UCPTRIE_SHIFT_2=9)\n+ *\n+ * Values for code points fast_limit..highStart-1 are found via four-stage lookup.\n+ * The data block size is smaller for this range than for the fast range.\n+ * This together with more index stages with small blocks makes this range\n+ * more easily compactable.\n+ *\n+ * There is also a trie error value stored at the last position of the data array.\n+ * (See UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET.)\n+ * It is intended to be returned for inputs that are not Unicode code points\n+ * (outside U+0000..U+10FFFF), or in string processing for ill-formed input\n+ * (unpaired surrogate in UTF-16, ill-formed UTF-8 subsequence).\n+ *\n+ * For a \"fast\" trie:\n+ *\n+ * The index array starts with the BMP index table for BMP code point lookup.\n+ * Its length is 1024=0x400.\n+ *\n+ * The supplementary index-1 table follows the BMP index table.\n+ * Variable length, for code points up to highStart-1.\n+ * Maximum length 64=0x40=0x100000>>UCPTRIE_SHIFT_1.\n+ * (For 0x100000 supplementary code points U+10000..U+10ffff.)\n+ *\n+ * After this index-1 table follow the variable-length index-3 and index-2 tables.\n+ *\n+ * The supplementary index tables are omitted completely\n+ * if there is only BMP data (highStart<=U+10000).\n+ *\n+ * For a \"small\" trie:\n+ *\n+ * The index array starts with a fast-index table for lookup of code points U+0000..U+0FFF.\n+ *\n+ * The \"supplementary\" index tables are always stored.\n+ * The index-1 table starts from U+0000, its maximum length is 68=0x44=0x110000>>UCPTRIE_SHIFT_1.\n+ *\n+ * For both trie types:\n+ *\n+ * The last index-2 block may be a partial block, storing indexes only for code points\n+ * below highStart.\n+ *\n+ * Lookup for ASCII code point c:\n+ *\n+ * Linear access from the start of the data array.\n+ *\n+ * value = data[c];\n+ *\n+ * Lookup for fast-range code point c:\n+ *\n+ * Shift the code point right by UCPTRIE_FAST_SHIFT=6 bits,\n+ * fetch the index array value at that offset,\n+ * add the lower code point bits, index into the data array.\n+ *\n+ * value = data[index[c>>6] + (c&0x3f)];\n+ *\n+ * (This works for ASCII as well.)\n+ *\n+ * Lookup for small-range code point c below highStart:\n+ *\n+ * Split the code point into four bit fields using several sets of shifts & masks\n+ * to read consecutive values from the index-1, index-2, index-3 and data tables.\n+ *\n+ * If all of the data block offsets in an index-3 block fit within 16 bits (up to 0xffff),\n+ * then the data block offsets are stored directly as uint16_t.\n+ *\n+ * Otherwise (this is very unusual but possible), the index-2 entry for the index-3 block\n+ * has bit 15 (0x8000) set, and each set of 8 index-3 entries is preceded by\n+ * an additional uint16_t word. Data block offsets are 18 bits wide, with the top 2 bits stored\n+ * in the additional word.\n+ *\n+ * See ucptrie_internalSmallIndex() for details.\n+ *\n+ * (In a \"small\" trie, this works for ASCII and below-fast_limit code points as well.)\n+ *\n+ * Compaction:\n+ *\n+ * Multiple code point ranges (\"blocks\") that are aligned on certain boundaries\n+ * (determined by the shifting/bit fields of code points) and\n+ * map to the same data values normally share a single subsequence of the data array.\n+ * Data blocks can also overlap partially.\n+ * (Depending on the builder code finding duplicate and overlapping blocks.)\n+ *\n+ * Iteration over same-value ranges:\n+ *\n+ * Range iteration (ucptrie_getRange()) walks the structure from a start code point\n+ * until some code point is found that maps to a different value;\n+ * the end of the returned range is just before that.\n+ *\n+ * The header.dataNullOffset (split across two header fields, high bits in header.options)\n+ * is the offset of a widely shared data block filled with one single value.\n+ * It helps quickly skip over large ranges of data with that value.\n+ * The builder must ensure that if the start of any data block (fast or small)\n+ * matches the dataNullOffset, then the whole block must be filled with the null value.\n+ * Special care must be taken if there is no fast null data block\n+ * but a small one, which is shorter, and it matches the *start* of some fast data block.\n+ *\n+ * Similarly, the header.index3NullOffset is the index-array offset of an index-3 block\n+ * where all index entries point to the dataNullOffset.\n+ * If there is no such data or index-3 block, then these offsets are set to\n+ * values that cannot be reached (data offset out of range/reserved index offset),\n+ * normally UCPTRIE_NO_DATA_NULL_OFFSET or UCPTRIE_NO_INDEX3_NULL_OFFSET respectively.\n+ */\n+\n+#endif"
        },
        {
            "sha": "5c9bbef70097e75b4ef25a147895fcc6319ef660",
            "filename": "deps/icu-small/source/common/ucurr.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucurr.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fucurr.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fucurr.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1077,11 +1077,11 @@ collectCurrencyNames(const char* locale,\n         }\n \n         // currency plurals\n-        UErrorCode ec3 = U_ZERO_ERROR;\n-        UResourceBundle* curr_p = ures_getByKey(rb, CURRENCYPLURALS, NULL, &ec3);\n+        UErrorCode ec5 = U_ZERO_ERROR;\n+        UResourceBundle* curr_p = ures_getByKey(rb, CURRENCYPLURALS, NULL, &ec5);\n         n = ures_getSize(curr_p);\n         for (int32_t i=0; i<n; ++i) {\n-            UResourceBundle* names = ures_getByIndex(curr_p, i, NULL, &ec3);\n+            UResourceBundle* names = ures_getByIndex(curr_p, i, NULL, &ec5);\n             iso = (char*)ures_getKey(names);\n             // Using hash to remove duplicated ISO codes in fallback chain.\n             if (localeLevel == 0) {\n@@ -1099,7 +1099,7 @@ collectCurrencyNames(const char* locale,\n             for (int32_t j = 0; j < num; ++j) {\n                 // TODO: remove duplicates between singular name and\n                 // currency long name?\n-                s = ures_getStringByIndex(names, j, &len, &ec3);\n+                s = ures_getStringByIndex(names, j, &len, &ec5);\n                 (*currencyNames)[*total_currency_name_count].IsoCode = iso;\n                 UChar* upperName = toUpperCase(s, len, locale);\n                 (*currencyNames)[*total_currency_name_count].currencyName = upperName;\n@@ -1449,7 +1449,7 @@ getCacheEntry(const char* locale, UErrorCode& ec) {\n     umtx_lock(&gCurrencyCacheMutex);\n     // in order to handle racing correctly,\n     // not putting 'search' in a separate function.\n-    int8_t  found = -1;\n+    int8_t found = -1;\n     for (int8_t i = 0; i < CURRENCY_NAME_CACHE_NUM; ++i) {\n         if (currCache[i]!= NULL &&\n             uprv_strcmp(locale, currCache[i]->locale) == 0) {\n@@ -1469,7 +1469,6 @@ getCacheEntry(const char* locale, UErrorCode& ec) {\n         }\n         umtx_lock(&gCurrencyCacheMutex);\n         // check again.\n-        int8_t  found = -1;\n         for (int8_t i = 0; i < CURRENCY_NAME_CACHE_NUM; ++i) {\n             if (currCache[i]!= NULL &&\n                 uprv_strcmp(locale, currCache[i]->locale) == 0) {"
        },
        {
            "sha": "99efbc97eed737531355d317eaddc5e35c212fd6",
            "filename": "deps/icu-small/source/common/udata.cpp",
            "status": "modified",
            "additions": 35,
            "deletions": 18,
            "changes": 53,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fudata.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fudata.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fudata.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -418,7 +418,8 @@ class UDataPathIterator\n     const char *path;                              /* working path (u_icudata_Dir) */\n     const char *nextPath;                          /* path following this one */\n     const char *basename;                          /* item's basename (icudt22e_mt.res)*/\n-    const char *suffix;                            /* item suffix (can be null) */\n+\n+    StringPiece suffix;                            /* item suffix (can be null) */\n \n     uint32_t    basenameLen;                       /* length of basename */\n \n@@ -432,13 +433,15 @@ class UDataPathIterator\n };\n \n /**\n- * @param iter  The iterator to be initialized. Its current state does not matter.\n- * @param path  The full pathname to be iterated over.  If NULL, defaults to U_ICUDATA_NAME\n- * @param pkg   Package which is being searched for, ex \"icudt28l\".  Will ignore leave directories such as /icudt28l\n- * @param item  Item to be searched for.  Can include full path, such as /a/b/foo.dat\n- * @param suffix  Optional item suffix, if not-null (ex. \".dat\") then 'path' can contain 'item' explicitly.\n- *               Ex:   'stuff.dat' would be found in '/a/foo:/tmp/stuff.dat:/bar/baz' as item #2.\n- *                     '/blarg/stuff.dat' would also be found.\n+ * @param iter    The iterator to be initialized. Its current state does not matter.\n+ * @param inPath  The full pathname to be iterated over.  If NULL, defaults to U_ICUDATA_NAME\n+ * @param pkg     Package which is being searched for, ex \"icudt28l\".  Will ignore leaf directories such as /icudt28l\n+ * @param item    Item to be searched for.  Can include full path, such as /a/b/foo.dat\n+ * @param inSuffix  Optional item suffix, if not-null (ex. \".dat\") then 'path' can contain 'item' explicitly.\n+ *             Ex:   'stuff.dat' would be found in '/a/foo:/tmp/stuff.dat:/bar/baz' as item #2.\n+ *                   '/blarg/stuff.dat' would also be found.\n+ *  Note: inSuffix may also be the 'item' being searched for as well, (ex: \"ibm-5348_P100-1997.cnv\"), in which case\n+ *        the 'item' parameter is often the same as pkg. (Though sometimes might have a tree part as well, ex: \"icudt62l-curr\").\n  */\n UDataPathIterator::UDataPathIterator(const char *inPath, const char *pkg,\n                                      const char *item, const char *inSuffix, UBool doCheckLastFour,\n@@ -566,7 +569,7 @@ const char *UDataPathIterator::next(UErrorCode *pErrorCode)\n \n         if(checkLastFour == TRUE &&\n            (pathLen>=4) &&\n-           uprv_strncmp(pathBuffer.data() +(pathLen-4), suffix, 4)==0 && /* suffix matches */\n+           uprv_strncmp(pathBuffer.data() +(pathLen-4), suffix.data(), 4)==0 && /* suffix matches */\n            uprv_strncmp(findBasename(pathBuffer.data()), basename, basenameLen)==0  && /* base matches */\n            uprv_strlen(pathBasename)==(basenameLen+4)) { /* base+suffix = full len */\n \n@@ -602,8 +605,13 @@ const char *UDataPathIterator::next(UErrorCode *pErrorCode)\n             /* + basename */\n             pathBuffer.append(packageStub.data()+1, packageStub.length()-1, *pErrorCode);\n \n-            if(*suffix)  /* tack on suffix */\n+            if (!suffix.empty())  /* tack on suffix */\n             {\n+                if (suffix.length() > 4) {\n+                    // If the suffix is actually an item (\"ibm-5348_P100-1997.cnv\") and not an extension (\".res\")\n+                    // then we need to ensure that the path ends with a separator.\n+                    pathBuffer.ensureEndsWithFileSeparator(*pErrorCode);\n+                }\n                 pathBuffer.append(suffix, *pErrorCode);\n             }\n         }\n@@ -751,16 +759,19 @@ openCommonData(const char *path,          /*  Path from OpenChoice?          */\n \n     UDataPathIterator iter(u_getDataDirectory(), inBasename, path, \".dat\", TRUE, pErrorCode);\n \n-    while((UDataMemory_isLoaded(&tData)==FALSE) && (pathBuffer = iter.next(pErrorCode)) != NULL)\n+    while ((UDataMemory_isLoaded(&tData)==FALSE) && (pathBuffer = iter.next(pErrorCode)) != NULL)\n     {\n #ifdef UDATA_DEBUG\n         fprintf(stderr, \"ocd: trying path %s - \", pathBuffer);\n #endif\n-        uprv_mapFile(&tData, pathBuffer);\n+        uprv_mapFile(&tData, pathBuffer, pErrorCode);\n #ifdef UDATA_DEBUG\n         fprintf(stderr, \"%s\\n\", UDataMemory_isLoaded(&tData)?\"LOADED\":\"not loaded\");\n #endif\n     }\n+    if (U_FAILURE(*pErrorCode)) {\n+        return NULL;\n+    }\n \n #if defined(OS390_STUBDATA) && defined(OS390BATCH)\n     if (!UDataMemory_isLoaded(&tData)) {\n@@ -769,7 +780,7 @@ openCommonData(const char *path,          /*  Path from OpenChoice?          */\n         uprv_strncpy(ourPathBuffer, path, 1019);\n         ourPathBuffer[1019]=0;\n         uprv_strcat(ourPathBuffer, \".dat\");\n-        uprv_mapFile(&tData, ourPathBuffer);\n+        uprv_mapFile(&tData, ourPathBuffer, pErrorCode);\n     }\n #endif\n \n@@ -860,7 +871,7 @@ static UBool extendICUData(UErrorCode *pErr)\n     umtx_unlock(&extendICUDataMutex);\n #endif\n     return didUpdate;               /* Return true if ICUData pointer was updated.   */\n-                                    /*   (Could potentialy have been done by another thread racing */\n+                                    /*   (Could potentially have been done by another thread racing */\n                                     /*   us through here, but that's fine, we still return true    */\n                                     /*   so that current thread will also examine extended data.   */\n }\n@@ -986,12 +997,12 @@ static UDataMemory *doLoadFromIndividualFiles(const char *pkgName,\n     /* init path iterator for individual files */\n     UDataPathIterator iter(dataPath, pkgName, path, tocEntryPathSuffix, FALSE, pErrorCode);\n \n-    while((pathBuffer = iter.next(pErrorCode)) != NULL)\n+    while ((pathBuffer = iter.next(pErrorCode)) != NULL)\n     {\n #ifdef UDATA_DEBUG\n         fprintf(stderr, \"UDATA: trying individual file %s\\n\", pathBuffer);\n #endif\n-        if(uprv_mapFile(&dataMemory, pathBuffer))\n+        if (uprv_mapFile(&dataMemory, pathBuffer, pErrorCode))\n         {\n             pEntryData = checkDataItem(dataMemory.pHeader, isAcceptable, context, type, name, subErrorCode, pErrorCode);\n             if (pEntryData != NULL) {\n@@ -1007,7 +1018,7 @@ static UDataMemory *doLoadFromIndividualFiles(const char *pkgName,\n                 return pEntryData;\n             }\n \n-            /* the data is not acceptable, or some error occured.  Either way, unmap the memory */\n+            /* the data is not acceptable, or some error occurred.  Either way, unmap the memory */\n             udata_close(&dataMemory);\n \n             /* If we had a nasty error, bail out completely.  */\n@@ -1076,6 +1087,11 @@ static UDataMemory *doLoadFromCommonData(UBool isICUData, const char * /*pkgName\n                 }\n             }\n         }\n+        // If we failed due to being out-of-memory, then stop early and report the error.\n+        if (*subErrorCode == U_MEMORY_ALLOCATION_ERROR) {\n+            *pErrorCode = *subErrorCode;\n+            return NULL;\n+        }\n         /* Data wasn't found.  If we were looking for an ICUData item and there is\n          * more data available, load it and try again,\n          * otherwise break out of this loop. */\n@@ -1252,7 +1268,8 @@ doOpenChoice(const char *path, const char *type, const char *name,\n         tocEntryName.append(\".\", *pErrorCode).append(type, *pErrorCode);\n         tocEntryPath.append(\".\", *pErrorCode).append(type, *pErrorCode);\n     }\n-    tocEntryPathSuffix = tocEntryPath.data()+tocEntrySuffixIndex; /* suffix starts here */\n+    // The +1 is for the U_FILE_SEP_CHAR that is always appended above.\n+    tocEntryPathSuffix = tocEntryPath.data() + tocEntrySuffixIndex + 1; /* suffix starts here */\n \n #ifdef UDATA_DEBUG\n     fprintf(stderr, \" tocEntryName = %s\\n\", tocEntryName.data());"
        },
        {
            "sha": "5e7b043c4c934c995715852f3dab70ec14f2dd10",
            "filename": "deps/icu-small/source/common/udataswp.h",
            "status": "modified",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fudataswp.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fudataswp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fudataswp.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -333,6 +333,43 @@ uprv_compareInvEbcdic(const UDataSwapper *ds,\n #   error Unknown charset family!\n #endif\n \n+// utrie_swap.cpp -----------------------------------------------------------***\n+\n+/**\n+ * Swaps a serialized UTrie.\n+ * @internal\n+ */\n+U_CAPI int32_t U_EXPORT2\n+utrie_swap(const UDataSwapper *ds,\n+           const void *inData, int32_t length, void *outData,\n+           UErrorCode *pErrorCode);\n+\n+/**\n+ * Swaps a serialized UTrie2.\n+ * @internal\n+ */\n+U_CAPI int32_t U_EXPORT2\n+utrie2_swap(const UDataSwapper *ds,\n+            const void *inData, int32_t length, void *outData,\n+            UErrorCode *pErrorCode);\n+\n+/**\n+ * Swaps a serialized UCPTrie.\n+ * @internal\n+ */\n+U_CAPI int32_t U_EXPORT2\n+ucptrie_swap(const UDataSwapper *ds,\n+             const void *inData, int32_t length, void *outData,\n+             UErrorCode *pErrorCode);\n+\n+/**\n+ * Swaps a serialized UTrie, UTrie2, or UCPTrie.\n+ * @internal\n+ */\n+U_CAPI int32_t U_EXPORT2\n+utrie_swapAnyVersion(const UDataSwapper *ds,\n+                     const void *inData, int32_t length, void *outData,\n+                     UErrorCode *pErrorCode);\n \n /* material... -------------------------------------------------------------- */\n "
        },
        {
            "sha": "239997d05d7e38b0abcdc51f66e67c06531fea42",
            "filename": "deps/icu-small/source/common/uhash.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuhash.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuhash.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fuhash.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -218,7 +218,7 @@ _uhash_allocate(UHashtable *hash,\n \n     U_ASSERT(primeIndex >= 0 && primeIndex < PRIMES_LENGTH);\n \n-    hash->primeIndex = primeIndex;\n+    hash->primeIndex = static_cast<int8_t>(primeIndex);\n     hash->length = PRIMES[primeIndex];\n \n     p = hash->elements = (UHashElement*)\n@@ -860,13 +860,13 @@ uhash_hashUChars(const UHashTok key) {\n U_CAPI int32_t U_EXPORT2\n uhash_hashChars(const UHashTok key) {\n     const char *s = (const char *)key.pointer;\n-    return s == NULL ? 0 : static_cast<int32_t>(ustr_hashCharsN(s, uprv_strlen(s)));\n+    return s == NULL ? 0 : static_cast<int32_t>(ustr_hashCharsN(s, static_cast<int32_t>(uprv_strlen(s))));\n }\n \n U_CAPI int32_t U_EXPORT2\n uhash_hashIChars(const UHashTok key) {\n     const char *s = (const char *)key.pointer;\n-    return s == NULL ? 0 : ustr_hashICharsN(s, uprv_strlen(s));\n+    return s == NULL ? 0 : ustr_hashICharsN(s, static_cast<int32_t>(uprv_strlen(s)));\n }\n \n U_CAPI UBool U_EXPORT2"
        },
        {
            "sha": "56dddfa8fde9bbb84e2bd9bbb94b7304b72dbbc9",
            "filename": "deps/icu-small/source/common/uinvchar.h",
            "status": "modified",
            "additions": 0,
            "deletions": 16,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuinvchar.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuinvchar.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fuinvchar.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -53,22 +53,6 @@ uprv_isInvariantString(const char *s, int32_t length);\n U_INTERNAL UBool U_EXPORT2\n uprv_isInvariantUString(const UChar *s, int32_t length);\n \n-#ifdef __cplusplus\n-\n-/**\n- * Check if a UnicodeString only contains invariant characters.\n- * See utypes.h for details.\n- *\n- * @param s Input string.\n- * @return TRUE if s contains only invariant characters.\n- */\n-U_INTERNAL inline UBool U_EXPORT2\n-uprv_isInvariantUnicodeString(const icu::UnicodeString &s) {\n-    return uprv_isInvariantUString(icu::toUCharPtr(s.getBuffer()), s.length());\n-}\n-\n-#endif  /* __cplusplus */\n-\n /**\n  * \\def U_UPPER_ORDINAL\n  * Get the ordinal number of an uppercase invariant character"
        },
        {
            "sha": "f42d15fc830afd28d92159db2c0036cb7fbde306",
            "filename": "deps/icu-small/source/common/ulayout_props_data.h",
            "status": "added",
            "additions": 722,
            "deletions": 0,
            "changes": 722,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fulayout_props_data.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fulayout_props_data.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fulayout_props_data.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,722 @@\n+// Â© 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+//\n+// file name: ulayout_props_data.h\n+//\n+// machine-generated by: icu/tools/unicode/c/genprops/layoutpropsbuilder.cpp\n+\n+\n+#ifdef INCLUDED_FROM_UPROPS_CPP\n+\n+static const int32_t maxInPCValue = 14;\n+\n+static const uint16_t inpc_trieIndex[765]={\n+0,0x40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0x80,0xc0,0xff,0x13f,0x17e,0x1be,0x17e,0x1fe,0x23e,0x27e,0x2bc,0x2fc,\n+0x33c,0x37b,0x23e,0x3bb,0x3fb,0x439,0x477,0x4ad,0x4e1,0x521,0x531,0x571,0x599,0x5d9,0x619,0x656,\n+0x2b7,0x2c6,0x2d2,0x2c6,0x2ed,0,0x10,0x20,0x30,0x40,0x50,0x60,0x70,0,0x10,0x20,\n+0x30,0,0x10,0x20,0x30,0,0x10,0x20,0x30,0,0x10,0x20,0x30,0,0x10,0x20,\n+0x30,0,0x10,0x20,0x30,0,0x10,0x20,0x30,0,0x10,0x20,0x30,0x80,0x90,0xa0,\n+0xb0,0xc0,0xd0,0xe0,0xf0,0xff,0x10f,0x11f,0x12f,0x13f,0x14f,0x15f,0x16f,0x17e,0x18e,0x19e,\n+0x1ae,0x1be,0x1ce,0x1de,0x1ee,0x17e,0x18e,0x19e,0x1ae,0x1fe,0x20e,0x21e,0x22e,0x23e,0x24e,0x25e,\n+0x26e,0x27e,0x28e,0x29e,0x2ae,0x2bc,0x2cc,0x2dc,0x2ec,0x2fc,0x30c,0x31c,0x32c,0x33c,0x34c,0x35c,\n+0x36c,0x37b,0x38b,0x39b,0x3ab,0x23e,0x24e,0x25e,0x26e,0x3bb,0x3cb,0x3db,0x3eb,0x3fb,0x40b,0x41b,\n+0x42b,0x439,0x449,0x459,0x469,0x477,0x487,0x497,0x4a7,0x4ad,0x4bd,0x4cd,0x4dd,0x4e1,0x4f1,0x501,\n+0x511,0x521,0x531,0x541,0x551,0x531,0x541,0x551,0x561,0x571,0x581,0x591,0x5a1,0x599,0x5a9,0x5b9,\n+0x5c9,0x5d9,0x5e9,0x5f9,0x609,0x619,0x629,0x639,0x649,0x656,0x666,0x676,0x686,0,0,0x68b,\n+0x69a,0,0x6a9,0x6b8,0x6c7,0x6d5,0x6e5,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0x6f3,0,0x6f3,\n+0,0x701,0,0x701,0,0,0,0x70b,0x71b,0x729,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0x739,0x749,0,0,\n+0,0,0,0,0,0x759,0x768,0,0,0,0x772,0,0,0,0x77e,0x78d,\n+0x79b,0,0,0,0,0,0,0,0,0x7ab,0,0,0x7b7,0x7c7,0,0x7cc,\n+0x52c,0x81,0,0x7dc,0,0,0,0x7ea,0x3fb,0,0,0x7fa,0x807,0,0,0,\n+0,0,0,0,0,0,0x817,0x827,0x835,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0x2b3,0x83f,0,0x84c,0,0,0,0,\n+0,0x101,0,0,0x858,0x864,0,0x874,0x882,0,0,0x892,0,0x8a0,0x3fb,0,\n+0,0x80,0,0,0x8b0,0x8c0,0,0x2b9,0,0,0x8c7,0x8d6,0x8e3,0,0,0x8f1,\n+0,0,0,0x901,0x2bd,0,0x911,0x151,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0x921,0,0x930,0,0,0x940,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0x950,0,0,0x958,0x966,0,0,0,\n+0x81,0,0,0x976,0,0,0,0,0x52d,0,0x981,0x991,0x3cb,0,0,0x659,\n+0x81,0,0,0x99e,0x9ae,0,0,0,0x9bb,0x9cb,0,0,0,0,0,0,\n+0,0,0,0x71,0x9db,0,0xff,0,0,0x9e6,0x9f6,0x14f,0xa04,0x52b,0,0,\n+0,0,0,0,0,0,0x99c,0xa14,0x16f,0,0,0,0,0,0xa24,0xa33,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0x2eb,0xa43,0xe3,\n+0x214,0,0,0,0xa53,0x2be,0,0,0,0,0,0xa63,0xa73,0,0,0,\n+0,0,0xa7b,0xa8b,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0xa97,0xaa6,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0xab5,\n+0,0,0xac2,0,0xad1,0,0,0xadd,0xae7,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x2eb,\n+0xaf7,0,0,0,0,0,0xb07,0xb0f,0xb1e,0,0,0,0,0,0,0,\n+0xb2d,0xb3c,0,0,0,0xb44,0xb54,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0xb61,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0x45,0x4d,0x4d,0x4d,0x5d,0x7d,0x9d,0xbd,0xdd,\n+2,2,0xec,0x10a,0x129,0x149,2,2,2,2,2,2,2,2,2,2,\n+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n+2,2,2,2,2,2,0x169,0x188,2,2,2,2,2,2,2,2,\n+2,2,0x1a8,2,2,0x1c8,0x1e6,0x203,0x221,0x23f,0x25f,0x27d,0x297\n+};\n+\n+static const uint8_t inpc_trieData[2930]={\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+8,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,8,7,1,0,7,4,\n+7,1,1,1,1,8,8,8,8,7,7,7,7,1,4,7,\n+0,8,1,8,8,8,1,1,0,0,0,0,0,0,0,0,\n+0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,1,0,7,4,7,\n+1,1,1,1,0,0,4,4,0,0,5,5,1,0,0,0,\n+0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,\n+0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,8,\n+8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,1,0,7,4,7,1,\n+1,0,0,0,0,8,8,0,0,8,8,1,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,\n+0,0,0,1,0,0,0,0,0,0,0,0,0,0,7,1,\n+1,1,1,8,0,8,8,0xd,0,7,7,1,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,8,8,8,8,8,8,0,8,\n+7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,1,0,7,8,7,1,\n+1,1,1,0,0,4,0xb,0,0,5,0xc,1,0,0,0,0,\n+0,0,0,0,8,0xd,0,0,0,0,0,0,0,0,0,0,\n+1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,7,7,8,7,7,0,\n+0,0,4,4,4,0,5,5,5,8,0,0,0,0,0,0,\n+0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,8,7,7,7,\n+8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,8,8,7,7,7,7,\n+0,8,8,9,0,8,8,8,8,0,0,0,0,0,0,0,\n+8,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0xd,7,7,7,7,\n+0,8,0xd,0xd,0,0xd,0xd,8,8,0,0,0,0,0,0,0,\n+7,7,0,0,0,0,0,0,0,0,0,0,0,1,1,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,8,8,7,7,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,8,8,0,7,7,7,1,1,0,4,\n+4,4,0,5,5,5,8,0,0,0,0,0,0,0,0,0,\n+7,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,7,7,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,8,0,0,0,0,7,7,7,8,\n+8,1,0,1,0,7,4,0xb,4,5,0xc,5,7,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,\n+7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,7,8,7,7,8,8,8,8,1,1,1,0,0,0,0,\n+0,0xe,0xe,0xe,0xe,0xe,7,0,8,8,8,8,8,8,8,8,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,7,8,7,7,8,8,8,8,1,1,0,8,1,0,0,\n+0,0xe,0xe,0xe,0xe,0xe,0,0,0,8,8,8,8,8,8,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,\n+1,0,8,0,0,0,0,7,4,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,1,8,9,1,1,9,\n+9,9,9,8,8,8,8,8,7,8,9,8,8,1,0,8,\n+8,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,\n+1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,7,7,8,8,1,4,8,8,8,8,\n+8,1,7,0,8,7,0,1,1,0,0,0,0,0,0,7,\n+7,1,1,0,0,0,0,1,1,0,7,7,7,0,0,7,\n+7,7,7,7,7,7,0,0,8,8,8,8,0,0,0,0,\n+0,0,0,0,0,0,0,1,7,4,8,8,7,7,7,7,\n+7,7,1,0,7,0,0,0,0,0,0,0,0,0,0,7,\n+7,7,8,0,0,8,1,1,0,0,0,0,0,0,0,0,\n+0,0,0,8,1,0,0,0,0,0,0,0,0,0,0,0,\n+0,7,8,8,8,8,1,1,1,0xb,0xc,5,4,4,4,5,\n+5,8,7,7,8,8,8,8,8,8,8,0,8,0,0,0,\n+0,0,0,0,0,0,8,0,0,8,8,1,7,7,0xd,0xd,\n+8,8,7,7,7,0,0,0,0,7,7,1,7,7,7,7,\n+7,7,1,8,1,0,0,0,0,7,7,7,7,7,0xe,0xe,\n+0xe,7,7,0xe,7,7,7,7,7,0,0,0,0,0,0,0,\n+7,7,0,0,0,0,0,0,0,8,1,4,7,8,0,0,\n+0,0,0,4,1,7,8,8,8,1,1,1,1,0,7,8,\n+7,7,8,8,8,8,1,1,8,1,7,4,4,4,8,8,\n+8,8,8,8,8,8,8,8,0,0,1,8,8,8,8,7,\n+0,0,0,0,0,0,0,0,0,0,0,8,7,8,8,1,\n+1,1,3,9,0xa,4,4,5,5,8,0xd,7,0,0,0,0,\n+0,0,0,0,0,0,0,8,1,8,8,8,0,7,1,1,\n+8,1,4,7,8,8,7,0,1,1,0,0,0,0,0,0,\n+8,7,8,8,7,7,7,8,7,8,0,0,0,0,7,7,\n+7,4,4,0xb,7,7,1,8,8,8,8,4,4,8,1,0,\n+0,0,0,0,0,0,0,8,8,8,0,6,1,1,1,1,\n+1,8,8,1,1,1,1,8,7,6,6,6,6,6,6,6,\n+0,0,0,0,1,0,0,0,0,8,0,0,7,0,0,0,\n+0,0,0,0,0,8,0,0,0,0,8,0,0,0,0,7,\n+7,1,8,7,0,0,0,0,0,0,0,0,7,7,7,7,\n+7,7,7,7,7,7,7,7,1,8,0,0,0,0,0,0,\n+0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,\n+8,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,8,0,0,0,0,0,0,0,0,0,0,0,1,1,1,\n+0,0,0,0,0,0,0,1,1,1,8,1,1,1,1,8,\n+0,0,0,8,7,7,8,8,1,1,4,4,8,7,7,2,\n+3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+8,8,8,8,1,8,4,8,1,7,4,1,1,0,0,0,\n+0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,8,\n+7,0,0,0,0,0,0,0,0,0,0,0,7,8,7,0,\n+0,8,7,8,8,1,0xe,0xe,8,8,0xe,7,0xe,0xe,7,8,\n+8,0,0,0,0,0,0,0,0,0,0,0,4,1,8,4,\n+7,0,0,0,7,7,8,7,7,1,7,7,0,7,1,0,\n+0,6,1,1,0,8,6,0,0,0,0,0,1,1,1,8,\n+0,0,0,0,0,0,0,0,8,1,1,0,0,0,0,0,\n+7,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+8,8,8,8,1,1,1,1,8,8,8,8,8,0,0,0,\n+0,0,0,0,0,0,7,4,7,1,1,8,8,7,7,1,\n+1,0,0,0,0,0,0,0,8,8,8,1,1,4,8,9,\n+9,8,1,1,0,8,0,0,0,0,0,0,0,0,0,0,\n+0,7,4,7,1,1,1,1,1,1,8,8,8,0xd,7,0,\n+0,0,0,0,0,0,0,1,0,8,1,0,0,0,0,0,\n+0,0,0,0,0,0,0,7,7,7,1,8,8,0xd,0xd,8,\n+7,8,8,0,0,0,0,0,0,8,0,7,4,7,1,1,\n+8,8,8,8,1,1,0,0,0,0,0,0,0,0,0,0,\n+0,1,1,0,7,7,8,7,7,7,7,0,0,4,4,0,\n+0,5,5,7,0,0,7,7,0,0,8,8,8,8,8,8,\n+8,0,0,0,7,7,1,8,8,7,1,0,0,0,0,0,\n+0,0,0,0,7,4,7,1,1,1,1,1,1,4,8,0xb,\n+5,7,5,8,7,1,1,0,0,0,0,0,0,0,0,0,\n+0,0,0,4,7,1,1,1,1,0,0,4,0xb,5,0xc,8,\n+8,7,1,7,7,7,1,1,1,1,1,1,8,8,7,7,\n+8,7,1,0,0,0,0,0,0,0,0,0,0,0,8,7,\n+8,4,7,1,1,8,8,8,8,7,1,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,1,0,8,7,7,8,8,1,\n+1,4,8,1,8,8,8,0,0,0,0,0,0,0,0,0,\n+0,0,0,7,4,7,1,1,1,8,8,8,8,8,7,1,\n+1,0,0,0,0,0,8,1,1,8,8,8,8,8,8,1,\n+0,0,0,0,0,1,1,8,8,8,8,7,0,1,1,1,\n+1,0,8,1,1,8,8,8,7,7,1,1,1,0,0,0,\n+0,0,0,0,0,0,0,1,1,1,1,1,1,8,7,8,\n+0,0,0,0,0,0,0,8,8,1,1,1,1,1,0,8,\n+8,8,8,8,8,7,1,0,0,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,0,7,1,1,1,1,1,1,4,\n+1,8,7,8,8,0,0,0,0,0,0,0,0,0,8,8,\n+8,8,8,1,0,0,0,8,0,8,8,0,8,8,1,8,\n+1,0,0,1,0,0,0,0,0,0,0,0,0,0,7,7,\n+7,7,7,0,8,8,0,7,7,8,7,0,0,0,0,0,\n+0,0,0,0,8,1,4,7,0,0,0,0,0,0,0,0,\n+0,0\n+};\n+\n+static const UCPTrie inpc_trie={\n+    inpc_trieIndex,\n+    { inpc_trieData },\n+    765, 2930,\n+    0x12000, 0x12,\n+    1, 2,\n+    0, 0,\n+    0x2, 0x0,\n+    0x0,\n+};\n+\n+static const int32_t maxInSCValue = 35;\n+\n+static const uint16_t insc_trieIndex[834]={\n+0,0x40,0x60,0x94,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0xd4,0x112,0x152,0x190,0x1cf,0x20d,0x24c,0x28a,0x2ca,0x308,0x346,0x384,\n+0x3c4,0x402,0x441,0x47f,0x4bf,0x4fd,0x53d,0x57d,0x5bc,0x5fc,0x63b,0x67b,0x69b,0x6db,0x71b,0x758,\n+0x2f8,0x30b,0x317,0x30b,0x332,0,0x10,0x20,0x30,0x40,0x50,0x60,0x70,0x60,0x70,0x80,\n+0x90,0x94,0xa4,0xb4,0xc4,0x40,0x50,0x60,0x70,0x40,0x50,0x60,0x70,0x40,0x50,0x60,\n+0x70,0x40,0x50,0x60,0x70,0x40,0x50,0x60,0x70,0x40,0x50,0x60,0x70,0x40,0x50,0x60,\n+0x70,0x40,0x50,0x60,0x70,0xd4,0xe4,0xf4,0x104,0x112,0x122,0x132,0x142,0x152,0x162,0x172,\n+0x182,0x190,0x1a0,0x1b0,0x1c0,0x1cf,0x1df,0x1ef,0x1ff,0x20d,0x21d,0x22d,0x23d,0x24c,0x25c,0x26c,\n+0x27c,0x28a,0x29a,0x2aa,0x2ba,0x2ca,0x2da,0x2ea,0x2fa,0x308,0x318,0x328,0x338,0x346,0x356,0x366,\n+0x376,0x384,0x394,0x3a4,0x3b4,0x3c4,0x3d4,0x3e4,0x3f4,0x402,0x412,0x422,0x432,0x441,0x451,0x461,\n+0x471,0x47f,0x48f,0x49f,0x4af,0x4bf,0x4cf,0x4df,0x4ef,0x4fd,0x50d,0x51d,0x52d,0x53d,0x54d,0x55d,\n+0x56d,0x57d,0x58d,0x59d,0x5ad,0x5bc,0x5cc,0x5dc,0x5ec,0x5fc,0x60c,0x61c,0x62c,0x63b,0x64b,0x65b,\n+0x66b,0x67b,0x68b,0x69b,0x6ab,0x69b,0x6ab,0x6bb,0x6cb,0x6db,0x6eb,0x6fb,0x70b,0x71b,0x72b,0x73b,\n+0x74b,0x758,0x768,0x778,0x788,0xe9,0xe9,0x798,0x7a3,0x7b3,0x7c3,0x7d2,0x7e1,0x7ef,0x7ff,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x80f,0x81d,0xe6,0x81d,0xe6,0x82d,0x80f,0x83d,0xe9,0xe9,0x84d,\n+0x859,0x863,0x872,0x30,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x882,0x16c,0x892,0x8a2,0x22d,0xe9,0x8b2,0x8c2,0xe9,0xe9,0x374,0x8d2,\n+0x8e1,0x30,0x40,0x40,0xe9,0x8f1,0xe9,0xe9,0x901,0x90e,0x91e,0x92a,0x30,0x30,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x93a,0xe6,0xe9,0x94a,0x956,0x30,0x40,0x40,0x966,0xe9,0x975,0x985,\n+0xe9,0xe9,0x995,0x9a5,0xe9,0xe9,0x9b5,0x9c2,0x9d2,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x9e2,0x9f0,0x9fe,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0xa08,0xa14,0xa24,0x40,0x40,0x40,0x40,0x40,0x75a,0xa32,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x74,0x40,0x40,0x40,0xa42,0xe9,0xa4f,\n+0x40,0xe9,0xa5f,0xa6d,0xa7c,0xd6,0xe7,0xe9,0xa8c,0xa98,0x30,0xaa8,0xab6,0xac6,0xe9,0xad4,\n+0xe9,0xae4,0xaf3,0x40,0x40,0xb03,0xe9,0xe9,0xb12,0x297,0x30,0xb22,0xb32,0xe3,0xe9,0x889,\n+0xb42,0xb52,0x30,0xe9,0xb61,0xe9,0xe9,0xe9,0xb71,0xb81,0x40,0xb91,0xba1,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xbb1,0xbc1,0xbce,0x30,0xbde,0xbee,0xe9,\n+0xbf8,0x31,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xc08,0xe6,0xe9,\n+0x88a,0xc18,0xc26,0xc30,0xc40,0xc50,0xe9,0xe9,0xc60,0x40,0x40,0x40,0x40,0xc70,0xe9,0x88b,\n+0xc80,0xc90,0xca0,0xe9,0xcad,0xd5,0xe8,0xe9,0xcbd,0xccd,0x30,0x6ba,0x35,0xe1,0x3eb,0x886,\n+0xcdd,0x40,0x40,0x40,0x40,0xced,0x16d,0xcfc,0xdf,0xe9,0xd0c,0xd1c,0x30,0xd2c,0x162,0x172,\n+0xd3c,0x308,0xd4c,0xd5c,0x9ed,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xdb,0xe9,0xe9,\n+0xd6c,0xd7a,0xd8a,0x40,0x40,0xd99,0xe9,0xe9,0x91f,0xda9,0x30,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0xdb,0xe9,0xff,0xdb9,0xdc9,0xdd1,0x40,0x40,0xdb,0xe9,0xe9,\n+0xde1,0xdf1,0x30,0x40,0x40,0xdf,0xe9,0xe01,0xe0e,0x30,0x40,0x40,0x40,0xe9,0xe1e,0xe2e,\n+0xe3e,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xdf,0xe9,0x886,\n+0xe4e,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xe5e,0xe9,0xe9,\n+0xe6b,0xe7b,0xe8b,0xe9,0xe9,0xe97,0xea1,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xeb1,0xe9,0xff,\n+0xec1,0xed1,0x6bb,0xee1,0x555,0xe9,0xeef,0x72b,0xeff,0x40,0x40,0x40,0x40,0xf0f,0xe9,0xe9,\n+0xf1e,0xf2e,0x30,0xf3e,0xe9,0xf4a,0xf57,0x30,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0xe9,0xf67,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,\n+0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x45,0x55,0x55,0x55,0x65,0x85,0xa5,0xc5,\n+0xe5,4,4,0xf5,0x114,0x134,0x154,4,0x174,4,0x17d,4,4,4,4,4,\n+4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n+4,4,4,4,4,4,4,4,4,4,4,0x19d,0x1bd,4,4,4,\n+4,4,4,4,4,4,4,0x1dd,4,4,0x1fd,0x21d,0x23d,0x25d,0x27d,0x29d,\n+0x2bd,0x2d8\n+};\n+\n+static const uint8_t insc_trieData[3960]={\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0xc,0,0,\n+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0xc,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0x1c,0x1c,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0xc,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,2,2,2,0x20,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,\n+0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x22,0x22,\n+0x17,1,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1f,\n+0x22,0x22,0,4,4,0,0,0x22,0x22,0x22,5,5,5,5,5,5,\n+5,5,0x23,0x23,0x22,0x22,0,0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,\n+0x18,0x18,0,0,0x23,0x23,0x23,0x23,0x23,0x23,5,5,5,5,5,5,\n+5,5,0xc,2,2,0x20,0,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0,\n+0,0x23,0x23,0,0,0x23,0x23,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,\n+5,5,5,0,5,0,0,0,5,5,5,5,0,0,0x17,1,\n+0x22,0x22,0x22,0x22,0x22,0,0,0x22,0x22,0,0,0x22,0x22,0x1f,6,0,\n+0,0,0,0,0,0,0,0x22,0,0,0,0,5,5,0,5,\n+0x23,0x23,0x22,0x22,0,0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,\n+5,5,0,0,0,0,0,0,0,0,0,0,2,0,0x1c,0,\n+2,2,0x20,0,0x23,0x23,0x23,0x23,0x23,0x23,0,0,0,0,0x23,0x23,\n+0,0,0x23,0x23,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,\n+0,5,5,0,5,5,0,5,5,0,0,0x17,0,0x22,0x22,0x22,\n+0,0,0,0,0x22,0x22,0,0,0x22,0x22,0x1f,0,0,0,4,0,\n+0,0,0,0,0,0,5,5,5,5,0,5,0,0,0,0,\n+0,0,0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,2,0x12,0xc,\n+0xc,0,0xb,0,0,0,0,0,0,0,0,0,0,2,2,0x20,\n+0,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0,0x23,0x23,0x23,0,0x23,\n+0x23,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,0,5,5,5,5,5,5,5,0,5,5,\n+0,5,5,5,5,5,0,0,0x17,1,0x22,0x22,0x22,0x22,0x22,0x22,\n+0,0x22,0x22,0x22,0,0x22,0x22,0x1f,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0x23,0x23,0x22,0x22,0,0,\n+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,0,0,0,0,0,\n+0,0,0,5,4,4,4,0x17,0x17,0x17,0,2,2,0x20,0,0x23,\n+0x23,0x23,0x23,0x23,0x23,0x23,0x23,0,0,0x23,0x23,0,0,0x23,0x23,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,0,5,5,5,5,5,5,5,0,5,5,0,5,\n+5,5,5,5,0,0,0x17,1,0x22,0x22,0x22,0x22,0x22,0,0,0x22,\n+0x22,0,0,0x22,0x22,0x1f,0,0,0,0,0,0,0,0,0x22,0x22,\n+0,0,0,0,5,5,0,5,0x23,0x23,0x22,0x22,0,0,0x18,0x18,\n+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,5,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,2,0x15,0,0x23,0x23,0x23,0x23,0x23,\n+0x23,0,0,0,0x23,0x23,0x23,0,0x23,0x23,0x23,5,0,0,0,5,\n+5,0,5,0,5,5,0,0,0,5,5,0,0,0,5,5,\n+5,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,\n+0,0,0,0,0x22,0x22,0x22,0,0,0,0x22,0x22,0x22,0,0x22,0x22,\n+0x22,0x1f,0,0,0,0,0,0,0,0,0,0x22,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0x18,0x18,0x18,0x18,0x18,0x18,\n+0x18,0x18,0x18,0x18,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,2,2,2,0x20,2,0x23,0x23,0x23,0x23,0x23,0x23,0x23,\n+0x23,0,0x23,0x23,0x23,0,0x23,0x23,0x23,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,\n+0,1,0x22,0x22,0x22,0x22,0x22,0,0x22,0x22,0x22,0,0x22,0x22,0x22,0x1f,\n+0,0,0,0,0,0,0,0x22,0x22,0,5,5,5,0,0,0,\n+0,0,0x23,0x23,0x22,0x22,0,0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,\n+0x18,0x18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,2,2,0x20,0,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0,0x23,\n+0x23,0x23,0,0x23,0x23,0x23,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,\n+5,5,5,5,5,0,5,5,5,5,5,0,0,0x17,1,0x22,\n+0x22,0x22,0x22,0x22,0,0x22,0x22,0x22,0,0x22,0x22,0x22,0x1f,0,0,0,\n+0,0,0,0,0x22,0x22,0,0,0,0,0,0,0,5,0,0x23,\n+0x23,0x22,0x22,0,0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,\n+0x11,0x11,0,0,0,0,0,0,0,0,0,0,0,0,0,2,\n+2,2,0x20,0,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0,0x23,0x23,0x23,\n+0,0x23,0x23,0x23,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,0x1a,0x1a,1,0x22,0x22,0x22,\n+0x22,0x22,0,0x22,0x22,0x22,0,0x22,0x22,0x22,0x1f,0xd,0,0,0,0,\n+0,6,6,6,0x22,0,0,0,0,0,0,0,0x23,0x23,0x23,0x22,\n+0x22,0,0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,0,0,\n+0,0,0,0,0,0,0,6,6,6,6,6,6,0,0,2,\n+0x20,0,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,\n+0x23,0x23,0x23,0x23,0,0,0,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,\n+5,5,5,5,5,5,5,5,5,0,5,0,0,5,5,5,\n+5,5,5,5,0,0,0,0x1f,0,0,0,0,0x22,0x22,0x22,0x22,\n+0x22,0x22,0,0x22,0,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0,0,0,\n+0,0,0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,0,0x22,\n+0x22,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,0,0x22,0x22,0x22,0x22,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x1a,0,0,0,0,0,0x22,0x22,0x22,0x22,\n+0x22,0x22,0,0x22,0x1e,0x1e,0x1e,0x1e,0xa,2,0x1a,0,0x18,0x18,0x18,0x18,\n+0x18,0x18,0x18,0x18,0x18,0x18,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,5,5,0,5,\n+0,0,5,5,0,5,0,0,5,0,0,0,0,0,0,5,\n+5,5,5,0,5,5,5,5,5,5,5,0,5,5,5,0,\n+5,0,5,0,0,5,5,0,5,5,0,0x22,0x22,0x22,0x22,0x22,\n+0x22,0x22,0x22,0x22,0x22,0,0x22,0xb,0xb,0,0,0x22,0x22,0x22,0x22,0x22,\n+0,0,0,0x1e,0x1e,0x1e,0x1e,0,2,0,0,0x18,0x18,0x18,0x18,0x18,\n+0x18,0x18,0x18,0x18,0x18,0,0,5,5,5,5,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0x18,0x18,0x18,0x18,0x18,\n+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,\n+0x1c,0,0x1c,0,0x17,0,0,0,0,0,0,5,5,5,5,5,\n+5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,5,5,5,5,5,5,0,0,0,0,0x22,0x22,0x22,0x22,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,2,0x20,0x22,0x22,2,2,0x1a,\n+1,0,0,8,8,8,8,8,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,\n+0xf,0xf,0xf,0,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,\n+0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,\n+0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0,0,0,0,0,0,0x1c,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,5,0x23,0x23,0x23,0x23,0x23,0x23,0x23,\n+0x23,0x23,0x23,0x22,0x22,0x22,0x22,0x22,0x22,2,0x1e,0x20,0x13,0x1a,0xb,0xb,\n+0xb,0xb,5,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,0xc,0,\n+0,0xc,0,5,5,0x23,0x23,0x23,0x23,0x22,0x22,0x22,0x22,5,5,5,\n+5,0xb,0xb,5,0x22,0x1e,0x1e,5,5,0x22,0x22,0x1e,0x1e,0x1e,0x1e,0x1e,\n+5,5,0x22,0x22,0x22,0x22,5,5,5,5,5,5,5,5,5,5,\n+5,0xb,0x22,0x22,0x22,0x22,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,5,0x1e,0x18,\n+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1e,0x1e,0x22,0x22,0,0,0x23,\n+0x23,0x23,5,5,5,5,5,5,5,5,5,5,0,5,5,0x22,\n+0x22,0x1a,0,0,0,0,0,0,0,0,0,0,0,5,5,0x22,\n+0x22,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0x22,\n+0x22,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,\n+0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0,0,0x22,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,2,0x20,0x22,0x1b,0x1b,0x1c,0x10,\n+0xa,0x1c,0x1c,0x1a,0x13,0x1c,0,0,0,0,0,0,0,0,1,0x1c,\n+0,0,0xc,5,5,5,5,5,5,5,5,5,5,5,5,5,\n+5,5,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0xf,0xf,0xf,0,0,\n+0,0,7,7,2,7,7,7,7,7,7,7,0x22,0x1c,0,0,\n+0,0,5,5,5,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,\n+0,0,0x1d,0x1d,0x1d,0x1d,0x1d,0,0,0,0,0,0,0,0,0,\n+0,0,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,\n+0x22,0x22,7,7,7,7,7,7,7,0x1e,0x1e,0,0,0,0,0,\n+0,5,5,5,5,5,5,5,0x22,0x22,0x22,0x22,0x22,0,0,0,\n+0,5,5,5,5,5,5,5,5,5,5,5,5,5,0x23,0x23,\n+0x23,5,5,0xb,0xb,0xf,7,7,9,0xf,0xf,0xf,0xf,0,0x13,0x22,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,2,0x1e,\n+0x1e,0x1e,0x1e,0x1e,0x1a,0x1c,0x1c,0,0,0x1c,2,2,2,0x10,0x20,0x23,\n+0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,5,5,5,5,0x17,0x22,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1f,5,5,5,5,5,\n+5,5,0,0,0,0,2,0x10,0x20,0x23,0x23,0x23,0x23,0x23,0x23,0x23,\n+5,5,5,5,5,5,0xf,0xf,0xf,0x22,0x22,0x22,0x22,0x22,0x22,0x1a,\n+0x13,0xf,0xf,5,5,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,1,\n+5,5,5,7,7,5,5,5,5,0x23,0x23,0x17,0x22,0x22,0x22,0x22,\n+0x22,0x22,0x22,0x22,0x22,7,7,0x1a,0x1a,0,0,0,0,0,0,0,\n+0,0,0,0,0,5,5,5,5,0xf,0xf,0x22,0x22,0x22,0x22,0x22,\n+0x22,0x22,7,7,7,7,2,2,0x1c,0x17,0,0,0,0,0,0,\n+0,0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,0,0,5,\n+5,5,4,4,4,0,4,4,4,4,4,4,4,4,4,4,\n+4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0x20,0x20,4,0x11,0x11,4,4,4,0,0,0,0,0,0,0,0,\n+0,0,0,0x1c,0,0,0,0,0,0,0,0,0,0,0,0,\n+0x16,0x14,0,0,0xc,0xc,0xc,0xc,0xc,0,0,0,0,0,0,0,\n+0,0,0,0,0x1c,0x1c,0x1c,0,0,0,0,0,0,0,0,0,\n+0,0,0x23,0x23,0,0x23,0x23,0x23,0x1a,5,5,5,5,2,5,5,\n+5,5,0x22,0x22,0x22,0x22,0x22,0,0,0,0,0,0,0,0,5,\n+5,5,5,5,5,5,5,5,5,5,5,5,5,0x21,0x21,5,\n+5,5,5,0x21,0xf,0xf,5,5,5,5,5,5,5,0xf,5,2,\n+0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,\n+0xb,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1f,2,0,0,\n+0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4,\n+4,4,4,4,4,4,4,4,2,2,0,0,0,0,0,0,\n+0,0,0,0,0x23,0x22,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,\n+5,5,5,5,5,5,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x1e,\n+0x1e,0x1e,0,0,5,5,5,5,5,5,5,0x22,0x22,0x22,0x22,0x22,\n+0x22,0x22,0x22,7,7,7,0x1a,0,0,0,0,0,0,0,0,0,\n+0,0,0,2,2,0x10,0x20,0x23,0x23,0x23,0x23,0x23,5,5,5,0x23,\n+0x23,0x23,5,5,5,0x17,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0xf,\n+0xb,0xb,5,5,5,5,5,0x22,0,5,5,5,5,5,5,5,\n+5,5,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,5,5,5,5,\n+5,0,0x22,0x22,0x22,0xb,0xb,0xb,0xb,0,0,0,0,0,0,0,\n+0,0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n+0,0,5,5,5,0xc,0xc,0xc,0,0,0,5,0x1e,0x1e,0x1e,5,\n+5,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,\n+0x1e,0x1d,0x1e,0x1d,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0x23,0x23,5,5,5,5,5,5,5,5,5,0x22,0x22,0x22,0x22,\n+0x22,0,0,0,0,0,0x20,0x13,0,0,0,0,0,0,0,0,\n+0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0x23,\n+0x23,5,0x23,5,5,5,5,5,5,5,5,5,7,7,7,7,\n+7,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0,0x1e,0x1a,0,0,5,0x22,\n+0x22,0x22,0,0x22,0x22,0,0,0,0,0,0x22,0x22,2,0x20,5,5,\n+5,5,0,5,5,5,0,5,5,5,5,5,5,5,0,0,\n+0x17,0x17,0x17,0,0,0,0,0x13,2,2,0x20,0x11,0x11,0x23,0x23,0x23,\n+0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x22,0x22,0x22,0x22,0x22,0x22,0x1f,0,\n+0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,\n+3,3,3,3,3,3,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x19,\n+2,2,0x20,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,5,5,5,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1f,0x17,0,0,0,0,0,\n+2,2,0x20,0x23,0x23,0x23,0x23,5,5,5,5,5,5,5,5,5,\n+0x22,0x22,0x22,0x13,0x1a,0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,\n+0,0,0,0,5,0x22,0x22,0,0,0,0,0,0,0,0,0,\n+0x21,0x21,0x21,0x21,0x21,5,5,5,5,5,5,5,5,5,5,5,\n+0x17,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1f,1,0xe,\n+0xe,0,0,0,0,0,0x1c,0x17,0x22,0x22,0,0,0,0x22,0x22,0x22,\n+0x22,2,0x1f,0x17,0x12,0,0,0,0,0,0,4,0,0x23,0x23,0x23,\n+0x23,5,5,5,0,5,0,5,5,5,5,0,5,5,5,5,\n+5,5,5,5,5,0,0,0,0,0,0,0,5,5,5,5,\n+5,5,5,5,5,5,5,5,5,5,5,2,0x22,0x22,0x22,0x22,\n+0x22,0x22,0x22,0x22,0x22,0x17,0x1a,0,0,0,0,0,2,2,2,0x20,\n+0,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0,0,0x23,5,0,5,5,\n+0,5,5,5,5,5,0,0x17,0x17,1,0x22,0x22,0,0,0,0,\n+0,0,0,0x22,0,0,0,0,0,0,2,2,0x23,0x23,0x22,0x22,\n+0,0,4,4,4,4,4,4,4,0,0,0,5,5,5,5,\n+5,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1f,2,2,0x20,\n+0x17,1,0,0,0,0,0,0,0,0,0x18,0x18,0x18,0x18,0x18,0x18,\n+0x18,0x18,0x18,0x18,0,0,0,0,0x1c,0,0x23,0x23,0x23,0x23,0x23,0x23,\n+0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,5,2,0x20,0x1f,0x17,1,0,0,\n+0,0,0,0,0,0,0,0,0,0x22,0x22,0x22,0x22,0x22,0x22,0,\n+0,0x22,0x22,0x22,0x22,2,2,0x20,0x1f,0x17,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0x23,0x23,0x23,0x23,0x22,0x22,0,\n+0,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,2,0x20,\n+0x1f,0x22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,5,5,5,5,5,5,5,5,5,5,5,2,0x20,0x22,0x22,\n+0x22,0x22,0x22,0x22,0x1f,0x17,0,0,0,0,0,0,0,0,5,5,\n+5,5,5,5,5,5,5,5,5,0,0,0xb,0xb,0xb,0x22,0x22,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x1a,0,0,0,0,0x18,0x18,\n+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,0,0,0,0x22,0x22,\n+0x22,0x22,0x22,0x22,0x22,2,0x20,0x1f,0x17,0,0,0,0,0,0x23,0x22,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,5,5,5,5,5,0x1c,0x1a,\n+2,2,2,2,0x20,0xe,0xb,0xb,0xb,0xb,0xc,0,0,0,0,0,\n+0xc,0,0x13,0,0,0,0,0,0,0,0,0x23,0x22,0x22,0x22,0x22,\n+0x22,0x22,0x22,0x22,0x22,0x22,0x22,5,5,5,5,0,0,0xe,0xe,0xe,\n+0xe,7,7,7,7,7,7,2,0x20,0x12,0x13,0,0,0,1,0,\n+0,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0,0x23,0x23,0x23,0x23,5,\n+5,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0,0x22,0x22,0x22,0x22,2,2,0x20,\n+0x1f,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0,0,\n+0,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0xf,0x22,\n+0x22,0x22,0x22,0x22,2,2,0,0,0,0,0,0,0,0,0,0x23,\n+0x23,0x23,0x23,0x23,0x23,0x23,0,0x23,0x23,0,0x23,5,5,5,5,0x22,\n+0x22,0x22,0x22,0x22,0x22,0,0,0,0x22,0,0x22,0x22,0,0x22,2,0x20,\n+0x17,0x22,0x1a,0x13,0xd,0xb,0,0,0,0,0,0,0,0,0x23,0x23,\n+0x23,0x23,0x23,0x23,0,0x23,0x23,0,0x23,0x23,5,5,5,5,5,5,\n+5,5,5,5,0x22,0x22,0x22,0x22,0x22,0,0x22,0x22,2,0x20,0x13,0,\n+0,0,0,0,0,0,0,5,5,0xc,0x22,0x22,0x22,0x22,0,0,\n+0,0,0,0,0,0,0,0\n+};\n+\n+static const UCPTrie insc_trie={\n+    insc_trieIndex,\n+    { insc_trieData },\n+    834, 3960,\n+    0x12000, 0x12,\n+    1, 2,\n+    0, 0,\n+    0x4, 0x40,\n+    0x0,\n+};\n+\n+static const int32_t maxVoValue = 3;\n+\n+static const uint16_t vo_trieIndex[1100]={\n+0,0x40,0x59,0x98,0,0,0,0,0,0,0,0xd0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0x33b,0x355,0x363,0x379,0x399,0x3b7,0x3d2,0x3ec,0x355,0x355,0x355,0x40c,0x355,0x355,0x355,0x40c,\n+0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,\n+0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,\n+0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x42c,0x355,0x355,0x355,0x40c,\n+0x355,0x355,0x355,0x40c,0,0x10,0x20,0x30,0x40,0x50,0x60,0x70,0x59,0x69,0x79,0x89,\n+0x98,0xa8,0xb8,0xc8,0,0x10,0x20,0x30,0,0x10,0x20,0x30,0,0x10,0x20,0x30,\n+0,0x10,0x20,0x30,0xd0,0xe0,0xf0,0x100,0,0x10,0x20,0x30,0,0x10,0x20,0x30,\n+0,0x10,0x20,0x30,0,0x10,0x20,0x30,0,0x10,0x20,0x30,0,0x10,0x20,0x30,\n+0,0x10,0x20,0x30,0,0x10,0x20,0x30,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x10f,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0x110,0x110,0x110,0x110,0x110,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0xa9,0x96,0x11e,0x12c,0xae,0xaa,0,0,0,0,0,\n+0,0x103,0x13c,0,0x14c,0x158,0x166,0x10b,0x175,0x110,0x110,0x110,0x184,0,0,0,\n+0,0,0,0,0x72,0,0xf6,0,0,0,0,0,0,0,0,0,\n+0,0,0,0x190,0x110,0x198,0,0,0,0,0x103,0x110,0x115,0,0xec,0x1a8,\n+0x1b6,0x10e,0x110,0x110,0x1c6,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0,0,0,0,0,0,0,0,0,0,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x116,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x118,0x10a,0x110,0x1d2,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0x10e,0x110,0,0,\n+0x116,0,0,0,0,0,0x108,0x110,0x1e2,0x114,0x110,0,0,0,0,0,\n+0,0,0,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x1f1,0x1ff,0x110,0x20e,0x21d,\n+0x110,0x22a,0x110,0x237,0x246,0x256,0x110,0x22a,0x110,0x237,0x261,0x110,0x110,0x26e,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x27e,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x27e,0x27e,0x27e,0x27e,0x27e,\n+0x286,0x110,0x28e,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0x110,0x110,0,0,0,0,0,\n+0,0,0,0x110,0,0x110,0x117,0x29b,0x2aa,0,0,0,0,0,0,0,\n+0,0,0x2ba,0x2c9,0x110,0x2d9,0x110,0x2e9,0x2f8,0,0,0,0,0,0,0,\n+0x308,0x318,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0x110,0x110,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0,0,0,\n+0,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0,0,0,0,0,0,0,0,0x328,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,\n+0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x110,0x112,0x84,0x98,0xa8,0xa8,0xa8,\n+0xa8,0xa8,0xa8,0xc8,0xc,0xe8,0x100,0x115,0xc,0xc,0xc,0x134,0x153,0x172,0x191,0xc,\n+0x1ab,0xc,0x1cb,0x1eb,0x20b,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,\n+0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,\n+0x223,0x223,0x223,0x223,0x223,0xfb,0xc,0x243,0xc,0x223,0x223,0x223,0x223,0x223,0x223,0x223,\n+0x223,0x223,0x223,0x223,0x223,0xc,0xc,0xc,0xc,0x223,0x223,0x223,0x223,0x223,0x223,0x223,\n+0x223,0x223,0x223,0x223,0x223,0x223,0xf8,0xc,0x262,0xc,0xc,0xc,0xc,0x282,0xc,0xc,\n+0xc,0xc,0xc,0x29c,0xc,0xc,0xfd,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,\n+0xc,0x223,0x223,0x2b9,0xc,0xc,0xc,0xc,0xc,0x223,0x100,0xc,0xc,0xc,0xc,0xc,\n+0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x2bc,0x223,\n+0x223,0x223,0x223,0x223,0x223,0x223,0x223,0xf8,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,\n+0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x2da,0xf8,0xc,0xc,0xc,0xc,\n+0xc,0xc,0xc,0xc,0x223,0x2fa,0xc,0xc,0x223,0xfd,0xc,0xc,0xc,0xc,0xc,0xc,\n+0xc,0xc,0xc,0xc,0x223,0x31a,0x223,0x223,0xc8,0x2b5,0xc,0xc,0x223,0x223,0x223,0x223,\n+0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,\n+0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x223,0x31b,0xc,0xc,0xc,0xc,\n+0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,\n+0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc\n+};\n+\n+static const uint8_t vo_trieData[828]={\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+3,0,3,0,0,0,0,3,0,0,3,0,0,0,0,0,\n+0,0,0,0,0,3,3,3,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,3,3,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\n+0,0,0,0,0,0,0,0,0,3,3,0,0,0,3,0,\n+0,0,0,3,3,3,0,0,0,0,0,0,3,0,3,3,\n+3,0,0,0,0,0,0,0,0,0,0,0,3,3,0,3,\n+3,3,3,3,3,3,0,0,0,0,0,3,3,0,3,3,\n+0,0,0,0,0,0,3,3,3,3,0,3,0,3,0,3,\n+0,0,0,0,3,0,0,0,0,0,3,3,3,3,3,3,\n+0,3,3,0,3,3,3,3,3,3,3,3,3,3,0,0,\n+3,3,3,3,3,3,3,3,0,0,0,0,3,3,3,3,\n+3,1,1,3,0,0,0,0,3,3,3,3,3,3,3,3,\n+3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,\n+3,3,0,0,0,0,3,3,3,0,3,3,3,3,3,3,\n+3,3,3,3,3,3,0,0,0,0,0,0,0,0,0,0,\n+0,0,3,3,0,3,3,3,3,3,3,3,3,3,3,3,\n+3,3,2,2,3,3,3,3,3,1,1,1,1,1,1,1,\n+1,3,3,1,1,1,1,1,1,1,1,1,1,1,1,3,\n+3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,\n+2,3,2,3,2,3,2,3,3,3,3,3,3,2,3,3,\n+3,3,3,3,3,3,3,3,3,3,2,3,2,3,2,3,\n+3,3,3,3,3,2,3,3,3,3,3,2,2,3,3,3,\n+3,2,2,3,3,3,1,2,3,2,3,2,3,2,3,2,\n+3,3,3,3,3,3,2,2,3,3,3,3,3,1,3,3,\n+3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,2,\n+2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,\n+3,3,3,3,3,3,3,3,3,2,2,2,2,2,3,3,\n+3,3,3,0,1,1,1,1,1,1,3,3,3,0,0,0,\n+0,3,3,3,3,3,3,3,3,3,0,2,3,3,3,3,\n+3,3,1,1,3,3,2,0,2,3,3,3,3,3,3,3,\n+3,3,3,1,1,0,0,0,2,3,3,3,3,3,3,3,\n+3,3,3,3,1,3,1,3,1,3,3,3,3,3,3,3,\n+3,3,3,3,1,1,1,1,1,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,3,3,3,1,3,3,3,3,\n+0,0,0,0,0,0,0,0,3,3,3,3,3,3,3,3,\n+3,0,0,0,3,3,0,0,2,2,3,3,3,3,3,3,\n+3,3,3,3,3,3,3,3,0,0,0,0\n+};\n+\n+static const UCPTrie vo_trie={\n+    vo_trieIndex,\n+    { vo_trieData },\n+    1100, 828,\n+    0x110000, 0x110,\n+    1, 2,\n+    0, 0,\n+    0xc, 0x0,\n+    0x0,\n+};\n+\n+#endif  // INCLUDED_FROM_UPROPS_CPP"
        },
        {
            "sha": "81b6e0f68ab88be97d59dcec345e8d612ebd45e4",
            "filename": "deps/icu-small/source/common/uloc.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuloc.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuloc.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fuloc.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -798,7 +798,7 @@ _getKeywords(const char *localeID,\n             }\n             keywordsLen += keywordList[i].keywordLen + 1;\n             if(valuesToo) {\n-                if(keywordsLen + keywordList[i].valueLen < keywordCapacity) {\n+                if(keywordsLen + keywordList[i].valueLen <= keywordCapacity) {\n                     uprv_strncpy(keywords+keywordsLen, keywordList[i].valueStart, keywordList[i].valueLen);\n                 }\n                 keywordsLen += keywordList[i].valueLen;\n@@ -1133,7 +1133,7 @@ uloc_setKeywordValue(const char* keywordName,\n             keyValuePrefix = ';'; /* for any subsequent key-value pair */\n             updatedKeysAndValues.append(localeKeywordNameBuffer, keyValueLen, *status);\n             updatedKeysAndValues.append('=', *status);\n-            updatedKeysAndValues.append(nextEqualsign, keyValueTail-nextEqualsign, *status);\n+            updatedKeysAndValues.append(nextEqualsign, static_cast<int32_t>(keyValueTail-nextEqualsign), *status);\n         }\n         if (!nextSeparator && keywordValueLen > 0 && !handledInputKeyAndValue) {\n             /* append new entry at the end, it sorts later than existing entries */\n@@ -1500,7 +1500,7 @@ _deleteVariant(char* variants, int32_t variantsLen,\n         }\n         if (uprv_strncmp(variants, toDelete, toDeleteLen) == 0 &&\n             (variantsLen == toDeleteLen ||\n-             (flag=(variants[toDeleteLen] == '_'))))\n+             (flag=(variants[toDeleteLen] == '_')) != 0))\n         {\n             int32_t d = toDeleteLen + (flag?1:0);\n             variantsLen -= d;\n@@ -2412,7 +2412,7 @@ uloc_acceptLanguageFromHTTP(char *result, int32_t resultAvailable, UAcceptResult\n         /* eat spaces prior to semi */\n         for(t=(paramEnd-1);(paramEnd>s)&&isspace(*t);t--)\n             ;\n-        int32_t slen = ((t+1)-s);\n+        int32_t slen = static_cast<int32_t>(((t+1)-s));\n         if(slen > ULOC_FULLNAME_CAPACITY) {\n           *status = U_BUFFER_OVERFLOW_ERROR;\n           return -1; // too big"
        },
        {
            "sha": "17ad91da01586dafb6f7320b6e89e6b07790029b",
            "filename": "deps/icu-small/source/common/uloc_keytype.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuloc_keytype.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuloc_keytype.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fuloc_keytype.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -228,7 +228,7 @@ initFromResourceBundle(UErrorCode& sts) {\n                     // a timezone key uses a colon instead of a slash in the resource.\n                     // e.g. America:Los_Angeles\n                     if (uprv_strchr(legacyTypeId, ':') != NULL) {\n-                        int32_t legacyTypeIdLen = uprv_strlen(legacyTypeId);\n+                        int32_t legacyTypeIdLen = static_cast<int32_t>(uprv_strlen(legacyTypeId));\n                         char* legacyTypeIdBuf = (char*)uprv_malloc(legacyTypeIdLen + 1);\n                         if (legacyTypeIdBuf == NULL) {\n                             sts = U_MEMORY_ALLOCATION_ERROR;\n@@ -320,7 +320,7 @@ initFromResourceBundle(UErrorCode& sts) {\n                             if (isTZ) {\n                                 // replace colon with slash if necessary\n                                 if (uprv_strchr(from, ':') != NULL) {\n-                                    int32_t fromLen = uprv_strlen(from);\n+                                    int32_t fromLen = static_cast<int32_t>(uprv_strlen(from));\n                                     char* fromBuf = (char*)uprv_malloc(fromLen + 1);\n                                     if (fromBuf == NULL) {\n                                         sts = U_MEMORY_ALLOCATION_ERROR;\n@@ -472,7 +472,6 @@ isSpecialTypeRgKeyValue(const char* val) {\n         p++;\n     }\n     return (subtagLen == 6);\n-    return TRUE;\n }\n \n U_CFUNC const char*"
        },
        {
            "sha": "8120331c4b91ff9ab2e3906e045678d444f1af6f",
            "filename": "deps/icu-small/source/common/uloc_tag.cpp",
            "status": "modified",
            "additions": 422,
            "deletions": 68,
            "changes": 490,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuloc_tag.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuloc_tag.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fuloc_tag.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -12,11 +12,13 @@\n #include \"unicode/putil.h\"\n #include \"unicode/uloc.h\"\n #include \"ustr_imp.h\"\n+#include \"charstr.h\"\n #include \"cmemory.h\"\n #include \"cstring.h\"\n #include \"putilimp.h\"\n #include \"uinvchar.h\"\n #include \"ulocimp.h\"\n+#include \"uvector.h\"\n #include \"uassert.h\"\n \n \n@@ -77,19 +79,34 @@ static const char LOCALE_TYPE_YES[] = \"yes\";\n \n #define LANG_UND_LEN 3\n \n+/*\n+ Updated on 2018-09-12 from\n+ https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .\n+\n+ This table has 2 parts. The parts for Grandfathered tags is generated by the\n+ following scripts from the IANA language tag registry.\n+\n+ curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\\\n+ egrep -A 7 'Type: grandfathered' | \\\n+ egrep 'Tag|Prefe' | grep -B1 'Preferred' | grep -v '^--' | \\\n+ awk -n '/Tag/ {printf(\"    \\\"%s\\\", \", $2);} /Preferred/ {printf(\"\\\"%s\\\",\\n\", $2);}' |\\\n+ tr 'A-Z' 'a-z'\n+\n+\n+ The 2nd part is made of five ICU-specific entries. They're kept for\n+ the backward compatibility for now, even though there are no preferred\n+ values. They may have to be removed for the strict BCP 47 compliance.\n+\n+*/\n static const char* const GRANDFATHERED[] = {\n /*  grandfathered   preferred */\n     \"art-lojban\",   \"jbo\",\n-    \"cel-gaulish\",  \"xtg-x-cel-gaulish\",\n-    \"en-GB-oed\",    \"en-GB-x-oed\",\n+    \"en-gb-oed\",    \"en-gb-oxendict\",\n     \"i-ami\",        \"ami\",\n     \"i-bnn\",        \"bnn\",\n-    \"i-default\",    \"en-x-i-default\",\n-    \"i-enochian\",   \"und-x-i-enochian\",\n     \"i-hak\",        \"hak\",\n     \"i-klingon\",    \"tlh\",\n     \"i-lux\",        \"lb\",\n-    \"i-mingo\",      \"see-x-i-mingo\",\n     \"i-navajo\",     \"nv\",\n     \"i-pwn\",        \"pwn\",\n     \"i-tao\",        \"tao\",\n@@ -102,17 +119,175 @@ static const char* const GRANDFATHERED[] = {\n     \"sgn-ch-de\",    \"sgg\",\n     \"zh-guoyu\",     \"cmn\",\n     \"zh-hakka\",     \"hak\",\n-    \"zh-min\",       \"nan-x-zh-min\",\n     \"zh-min-nan\",   \"nan\",\n     \"zh-xiang\",     \"hsn\",\n-    NULL,           NULL\n+\n+    // Grandfathered tags with no preferred value in the IANA\n+    // registry. Kept for now for the backward compatibility\n+    // because ICU has mapped them this way.\n+    \"cel-gaulish\",  \"xtg-x-cel-gaulish\",\n+    \"i-default\",    \"en-x-i-default\",\n+    \"i-enochian\",   \"und-x-i-enochian\",\n+    \"i-mingo\",      \"see-x-i-mingo\",\n+    \"zh-min\",       \"nan-x-zh-min\",\n };\n \n+/*\n+ Updated on 2018-09-12 from\n+ https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .\n+\n+ The table lists redundant tags with preferred value in the IANA languate tag registry.\n+ It's generated with the following command:\n+\n+ curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry |\\\n+ grep 'Type: redundant' -A 5 | egrep '^(Tag:|Prefer)' | grep -B1 'Preferred' | \\\n+ awk -n '/Tag/ {printf(\"    \\\"%s\\\",       \", $2);} /Preferred/ {printf(\"\\\"%s\\\",\\n\", $2);}' | \\\n+ tr 'A-Z' 'a-z'\n+\n+ In addition, ja-latn-hepburn-heploc is mapped to ja-latn-alalc97 because\n+ a variant tag 'hepburn-heploc' has the preferred subtag, 'alaic97'.\n+*/\n+\n+static const char* const REDUNDANT[] = {\n+//  redundant       preferred\n+    \"sgn-br\",       \"bzs\",\n+    \"sgn-co\",       \"csn\",\n+    \"sgn-de\",       \"gsg\",\n+    \"sgn-dk\",       \"dsl\",\n+    \"sgn-es\",       \"ssp\",\n+    \"sgn-fr\",       \"fsl\",\n+    \"sgn-gb\",       \"bfi\",\n+    \"sgn-gr\",       \"gss\",\n+    \"sgn-ie\",       \"isg\",\n+    \"sgn-it\",       \"ise\",\n+    \"sgn-jp\",       \"jsl\",\n+    \"sgn-mx\",       \"mfs\",\n+    \"sgn-ni\",       \"ncs\",\n+    \"sgn-nl\",       \"dse\",\n+    \"sgn-no\",       \"nsl\",\n+    \"sgn-pt\",       \"psr\",\n+    \"sgn-se\",       \"swl\",\n+    \"sgn-us\",       \"ase\",\n+    \"sgn-za\",       \"sfs\",\n+    \"zh-cmn\",       \"cmn\",\n+    \"zh-cmn-hans\",  \"cmn-hans\",\n+    \"zh-cmn-hant\",  \"cmn-hant\",\n+    \"zh-gan\",       \"gan\",\n+    \"zh-wuu\",       \"wuu\",\n+    \"zh-yue\",       \"yue\",\n+\n+    // variant tag with preferred value\n+    \"ja-latn-hepburn-heploc\", \"ja-latn-alalc97\",\n+};\n+\n+/*\n+  Updated on 2018-09-12 from\n+  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry .\n+\n+  grep 'Type: language' -A 7 language-subtag-registry  | egrep 'Subtag|Prefe' | \\\n+  grep -B1 'Preferred' | grep -v '^--' | \\\n+  awk -n '/Subtag/ {printf(\"    \\\"%s\\\",       \", $2);} /Preferred/ {printf(\"\\\"%s\\\",\\n\", $2);}'\n+\n+  Make sure that 2-letter language subtags come before 3-letter subtags.\n+*/\n static const char DEPRECATEDLANGS[][4] = {\n /*  deprecated  new */\n+    \"in\",       \"id\",\n     \"iw\",       \"he\",\n     \"ji\",       \"yi\",\n-    \"in\",       \"id\"\n+    \"jw\",       \"jv\",\n+    \"mo\",       \"ro\",\n+    \"aam\",       \"aas\",\n+    \"adp\",       \"dz\",\n+    \"aue\",       \"ktz\",\n+    \"ayx\",       \"nun\",\n+    \"bgm\",       \"bcg\",\n+    \"bjd\",       \"drl\",\n+    \"ccq\",       \"rki\",\n+    \"cjr\",       \"mom\",\n+    \"cka\",       \"cmr\",\n+    \"cmk\",       \"xch\",\n+    \"coy\",       \"pij\",\n+    \"cqu\",       \"quh\",\n+    \"drh\",       \"khk\",\n+    \"drw\",       \"prs\",\n+    \"gav\",       \"dev\",\n+    \"gfx\",       \"vaj\",\n+    \"ggn\",       \"gvr\",\n+    \"gti\",       \"nyc\",\n+    \"guv\",       \"duz\",\n+    \"hrr\",       \"jal\",\n+    \"ibi\",       \"opa\",\n+    \"ilw\",       \"gal\",\n+    \"jeg\",       \"oyb\",\n+    \"kgc\",       \"tdf\",\n+    \"kgh\",       \"kml\",\n+    \"koj\",       \"kwv\",\n+    \"krm\",       \"bmf\",\n+    \"ktr\",       \"dtp\",\n+    \"kvs\",       \"gdj\",\n+    \"kwq\",       \"yam\",\n+    \"kxe\",       \"tvd\",\n+    \"kzj\",       \"dtp\",\n+    \"kzt\",       \"dtp\",\n+    \"lii\",       \"raq\",\n+    \"lmm\",       \"rmx\",\n+    \"meg\",       \"cir\",\n+    \"mst\",       \"mry\",\n+    \"mwj\",       \"vaj\",\n+    \"myt\",       \"mry\",\n+    \"nad\",       \"xny\",\n+    \"ncp\",       \"kdz\",\n+    \"nnx\",       \"ngv\",\n+    \"nts\",       \"pij\",\n+    \"oun\",       \"vaj\",\n+    \"pcr\",       \"adx\",\n+    \"pmc\",       \"huw\",\n+    \"pmu\",       \"phr\",\n+    \"ppa\",       \"bfy\",\n+    \"ppr\",       \"lcq\",\n+    \"pry\",       \"prt\",\n+    \"puz\",       \"pub\",\n+    \"sca\",       \"hle\",\n+    \"skk\",       \"oyb\",\n+    \"tdu\",       \"dtp\",\n+    \"thc\",       \"tpo\",\n+    \"thx\",       \"oyb\",\n+    \"tie\",       \"ras\",\n+    \"tkk\",       \"twm\",\n+    \"tlw\",       \"weo\",\n+    \"tmp\",       \"tyj\",\n+    \"tne\",       \"kak\",\n+    \"tnf\",       \"prs\",\n+    \"tsf\",       \"taj\",\n+    \"uok\",       \"ema\",\n+    \"xba\",       \"cax\",\n+    \"xia\",       \"acn\",\n+    \"xkh\",       \"waw\",\n+    \"xsj\",       \"suj\",\n+    \"ybd\",       \"rki\",\n+    \"yma\",       \"lrr\",\n+    \"ymt\",       \"mtm\",\n+    \"yos\",       \"zom\",\n+    \"yuu\",       \"yug\",\n+};\n+\n+/*\n+  Updated on 2018-04-24 from\n+\n+  curl  https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry | \\\n+  grep 'Type: region' -A 7 | egrep 'Subtag|Prefe' | \\\n+  grep -B1 'Preferred' | \\\n+  awk -n '/Subtag/ {printf(\"    \\\"%s\\\",       \", $2);} /Preferred/ {printf(\"\\\"%s\\\",\\n\", $2);}'\n+*/\n+static const char DEPRECATEDREGIONS[][3] = {\n+/*  deprecated  new */\n+    \"BU\",       \"MM\",\n+    \"DD\",       \"DE\",\n+    \"FX\",       \"FR\",\n+    \"TP\",       \"TL\",\n+    \"YD\",       \"YE\",\n+    \"ZR\",       \"CD\",\n };\n \n /*\n@@ -172,6 +347,46 @@ static const char*\n ultag_getGrandfathered(const ULanguageTag* langtag);\n #endif\n \n+namespace {\n+\n+// Helper class to memory manage CharString objects.\n+// Only ever stack-allocated, does not need to inherit UMemory.\n+class CharStringPool {\n+public:\n+    CharStringPool() : status(U_ZERO_ERROR), pool(&deleter, nullptr, status) {}\n+    ~CharStringPool() = default;\n+\n+    CharStringPool(const CharStringPool&) = delete;\n+    CharStringPool& operator=(const CharStringPool&) = delete;\n+\n+    icu::CharString* create() {\n+        if (U_FAILURE(status)) {\n+            return nullptr;\n+        }\n+        icu::CharString* const obj = new icu::CharString;\n+        if (obj == nullptr) {\n+            status = U_MEMORY_ALLOCATION_ERROR;\n+            return nullptr;\n+        }\n+        pool.addElement(obj, status);\n+        if (U_FAILURE(status)) {\n+            delete obj;\n+            return nullptr;\n+        }\n+        return obj;\n+    }\n+\n+private:\n+    static void U_CALLCONV deleter(void* obj) {\n+        delete static_cast<icu::CharString*>(obj);\n+    }\n+\n+    UErrorCode status;\n+    icu::UVector pool;\n+};\n+\n+}  // namespace\n+\n /*\n * -------------------------------------------------\n *\n@@ -675,6 +890,11 @@ _appendLanguageToLanguageTag(const char* localeID, char* appendAt, int32_t capac\n     } else {\n         /* resolve deprecated */\n         for (i = 0; i < UPRV_LENGTHOF(DEPRECATEDLANGS); i += 2) {\n+            // 2-letter deprecated subtags are listede before 3-letter\n+            // ones in DEPRECATEDLANGS[]. Get out of loop on coming\n+            // across the 1st 3-letter subtag, if the input is a 2-letter code.\n+            // to avoid continuing to try when there's no match.\n+            if (uprv_strlen(buf) < uprv_strlen(DEPRECATEDLANGS[i])) break;\n             if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDLANGS[i]) == 0) {\n                 uprv_strcpy(buf, DEPRECATEDLANGS[i + 1]);\n                 len = (int32_t)uprv_strlen(buf);\n@@ -721,7 +941,6 @@ _appendScriptToLanguageTag(const char* localeID, char* appendAt, int32_t capacit\n                 *(appendAt + reslen) = SEP;\n             }\n             reslen++;\n-\n             if (reslen < capacity) {\n                 uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));\n             }\n@@ -763,6 +982,14 @@ _appendRegionToLanguageTag(const char* localeID, char* appendAt, int32_t capacit\n                 *(appendAt + reslen) = SEP;\n             }\n             reslen++;\n+           /* resolve deprecated */\n+            for (int i = 0; i < UPRV_LENGTHOF(DEPRECATEDREGIONS); i += 2) {\n+                if (uprv_compareInvCharsAsAscii(buf, DEPRECATEDREGIONS[i]) == 0) {\n+                    uprv_strcpy(buf, DEPRECATEDREGIONS[i + 1]);\n+                    len = (int32_t)uprv_strlen(buf);\n+                    break;\n+                }\n+            }\n \n             if (reslen < capacity) {\n                 uprv_memcpy(appendAt + reslen, buf, uprv_min(len, capacity - reslen));\n@@ -900,7 +1127,6 @@ _appendVariantsToLanguageTag(const char* localeID, char* appendAt, int32_t capac\n \n static int32_t\n _appendKeywordsToLanguageTag(const char* localeID, char* appendAt, int32_t capacity, UBool strict, UBool hadPosix, UErrorCode* status) {\n-    char buf[ULOC_KEYWORD_AND_VALUES_CAPACITY];\n     char attrBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY] = { 0 };\n     int32_t attrBufLength = 0;\n     UEnumeration *keywordEnum = NULL;\n@@ -920,22 +1146,48 @@ _appendKeywordsToLanguageTag(const char* localeID, char* appendAt, int32_t capac\n         AttributeListEntry *firstAttr = NULL;\n         AttributeListEntry *attr;\n         char *attrValue;\n-        char extBuf[ULOC_KEYWORD_AND_VALUES_CAPACITY];\n-        char *pExtBuf = extBuf;\n-        int32_t extBufCapacity = sizeof(extBuf);\n+        CharStringPool extBufPool;\n         const char *bcpKey=nullptr, *bcpValue=nullptr;\n         UErrorCode tmpStatus = U_ZERO_ERROR;\n         int32_t keylen;\n         UBool isBcpUExt;\n \n         while (TRUE) {\n+            icu::CharString buf;\n             key = uenum_next(keywordEnum, NULL, status);\n             if (key == NULL) {\n                 break;\n             }\n-            len = uloc_getKeywordValue(localeID, key, buf, sizeof(buf), &tmpStatus);\n-            /* buf must be null-terminated */\n-            if (U_FAILURE(tmpStatus) || tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {\n+            char* buffer;\n+            int32_t resultCapacity = ULOC_KEYWORD_AND_VALUES_CAPACITY;\n+\n+            for (;;) {\n+                buffer = buf.getAppendBuffer(\n+                        /*minCapacity=*/resultCapacity,\n+                        /*desiredCapacityHint=*/resultCapacity,\n+                        resultCapacity,\n+                        tmpStatus);\n+\n+                if (U_FAILURE(tmpStatus)) {\n+                    break;\n+                }\n+\n+                len = uloc_getKeywordValue(\n+                        localeID, key, buffer, resultCapacity, &tmpStatus);\n+\n+                if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {\n+                    break;\n+                }\n+\n+                resultCapacity = len;\n+                tmpStatus = U_ZERO_ERROR;\n+            }\n+\n+            if (U_FAILURE(tmpStatus)) {\n+                if (tmpStatus == U_MEMORY_ALLOCATION_ERROR) {\n+                    *status = U_MEMORY_ALLOCATION_ERROR;\n+                    break;\n+                }\n                 if (strict) {\n                     *status = U_ILLEGAL_ARGUMENT_ERROR;\n                     break;\n@@ -945,6 +1197,11 @@ _appendKeywordsToLanguageTag(const char* localeID, char* appendAt, int32_t capac\n                 continue;\n             }\n \n+            buf.append(buffer, len, tmpStatus);\n+            if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {\n+                tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.\n+            }\n+\n             keylen = (int32_t)uprv_strlen(key);\n             isBcpUExt = (keylen > 1);\n \n@@ -1007,49 +1264,60 @@ _appendKeywordsToLanguageTag(const char* localeID, char* appendAt, int32_t capac\n                 }\n \n                 /* we've checked buf is null-terminated above */\n-                bcpValue = uloc_toUnicodeLocaleType(key, buf);\n+                bcpValue = uloc_toUnicodeLocaleType(key, buf.data());\n                 if (bcpValue == NULL) {\n                     if (strict) {\n                         *status = U_ILLEGAL_ARGUMENT_ERROR;\n                         break;\n                     }\n                     continue;\n                 }\n-                if (bcpValue == buf) {\n+                if (bcpValue == buf.data()) {\n                     /*\n                     When uloc_toUnicodeLocaleType(key, buf) returns the\n                     input value as is, the value is well-formed, but has\n                     no known mapping. This implementation normalizes the\n-                    the value to lower case\n+                    value to lower case\n                     */\n+                    icu::CharString* extBuf = extBufPool.create();\n+                    if (extBuf == nullptr) {\n+                        *status = U_MEMORY_ALLOCATION_ERROR;\n+                        break;\n+                    }\n                     int32_t bcpValueLen = static_cast<int32_t>(uprv_strlen(bcpValue));\n-                    if (bcpValueLen < extBufCapacity) {\n-                        uprv_strcpy(pExtBuf, bcpValue);\n-                        T_CString_toLowerCase(pExtBuf);\n+                    int32_t resultCapacity;\n+                    char* pExtBuf = extBuf->getAppendBuffer(\n+                            /*minCapacity=*/bcpValueLen,\n+                            /*desiredCapacityHint=*/bcpValueLen,\n+                            resultCapacity,\n+                            tmpStatus);\n+                    if (U_FAILURE(tmpStatus)) {\n+                        *status = tmpStatus;\n+                        break;\n+                    }\n \n-                        bcpValue = pExtBuf;\n+                    uprv_strcpy(pExtBuf, bcpValue);\n+                    T_CString_toLowerCase(pExtBuf);\n \n-                        pExtBuf += (bcpValueLen + 1);\n-                        extBufCapacity -= (bcpValueLen + 1);\n-                    } else {\n-                        if (strict) {\n-                            *status = U_ILLEGAL_ARGUMENT_ERROR;\n-                            break;\n-                        }\n-                        continue;\n+                    extBuf->append(pExtBuf, bcpValueLen, tmpStatus);\n+                    if (U_FAILURE(tmpStatus)) {\n+                        *status = tmpStatus;\n+                        break;\n                     }\n+\n+                    bcpValue = extBuf->data();\n                 }\n             } else {\n                 if (*key == PRIVATEUSE) {\n-                    if (!_isPrivateuseValueSubtags(buf, len)) {\n+                    if (!_isPrivateuseValueSubtags(buf.data(), len)) {\n                         if (strict) {\n                             *status = U_ILLEGAL_ARGUMENT_ERROR;\n                             break;\n                         }\n                         continue;\n                     }\n                 } else {\n-                    if (!_isExtensionSingleton(key, keylen) || !_isExtensionSubtags(buf, len)) {\n+                    if (!_isExtensionSingleton(key, keylen) || !_isExtensionSubtags(buf.data(), len)) {\n                         if (strict) {\n                             *status = U_ILLEGAL_ARGUMENT_ERROR;\n                             break;\n@@ -1058,20 +1326,17 @@ _appendKeywordsToLanguageTag(const char* localeID, char* appendAt, int32_t capac\n                     }\n                 }\n                 bcpKey = key;\n-                if ((len + 1) < extBufCapacity) {\n-                    uprv_memcpy(pExtBuf, buf, len);\n-                    bcpValue = pExtBuf;\n-\n-                    pExtBuf += len;\n-\n-                    *pExtBuf = 0;\n-                    pExtBuf++;\n-\n-                    extBufCapacity -= (len + 1);\n-                } else {\n-                    *status = U_ILLEGAL_ARGUMENT_ERROR;\n+                icu::CharString* extBuf = extBufPool.create();\n+                if (extBuf == nullptr) {\n+                    *status = U_MEMORY_ALLOCATION_ERROR;\n                     break;\n                 }\n+                extBuf->append(buf.data(), len, tmpStatus);\n+                if (U_FAILURE(tmpStatus)) {\n+                    *status = tmpStatus;\n+                    break;\n+                }\n+                bcpValue = extBuf->data();\n             }\n \n             /* create ExtensionListEntry */\n@@ -1242,6 +1507,7 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT\n             attrBufIdx += (len + 1);\n         } else {\n             *status = U_ILLEGAL_ARGUMENT_ERROR;\n+            uprv_free(attr);\n             goto cleanup;\n         }\n \n@@ -1460,9 +1726,9 @@ _appendLDMLExtensionAsKeywords(const char* ldmlext, ExtensionListEntry** appendT\n                     kwd->value = pType;\n \n                     if (!_addExtensionToList(&kwdFirst, kwd, FALSE)) {\n-                        *status = U_ILLEGAL_ARGUMENT_ERROR;\n+                        // duplicate keyword is allowed, Only the first\n+                        // is honored.\n                         uprv_free(kwd);\n-                        goto cleanup;\n                     }\n                 }\n \n@@ -1836,7 +2102,7 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta\n     }\n \n     /* check if the tag is grandfathered */\n-    for (i = 0; GRANDFATHERED[i] != NULL; i += 2) {\n+    for (i = 0; i < UPRV_LENGTHOF(GRANDFATHERED); i += 2) {\n         if (uprv_stricmp(GRANDFATHERED[i], tagBuf) == 0) {\n             int32_t newTagLength;\n \n@@ -1858,6 +2124,37 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta\n         }\n     }\n \n+    size_t parsedLenDelta = 0;\n+    if (grandfatheredLen == 0) {\n+        for (i = 0; i < UPRV_LENGTHOF(REDUNDANT); i += 2) {\n+            const char* redundantTag = REDUNDANT[i];\n+            size_t redundantTagLen = uprv_strlen(redundantTag);\n+            // The preferred tag for a redundant tag is always shorter than redundant\n+            // tag. A redundant tag may or may not be followed by other subtags.\n+            // (i.e. \"zh-yue\" or \"zh-yue-u-co-pinyin\").\n+            if (uprv_strnicmp(redundantTag, tagBuf, static_cast<uint32_t>(redundantTagLen)) == 0) {\n+                const char* redundantTagEnd = tagBuf + redundantTagLen;\n+                if (*redundantTagEnd  == '\\0' || *redundantTagEnd == SEP) {\n+                    const char* preferredTag = REDUNDANT[i + 1];\n+                    size_t preferredTagLen = uprv_strlen(preferredTag);\n+                    uprv_strncpy(t->buf, preferredTag, preferredTagLen);\n+                    if (*redundantTagEnd == SEP) {\n+                        uprv_memmove(tagBuf + preferredTagLen,\n+                                     redundantTagEnd,\n+                                     tagLen - redundantTagLen + 1);\n+                    } else {\n+                        tagBuf[preferredTagLen] = '\\0';\n+                    }\n+                    // parsedLen should be the length of the input\n+                    // before redundantTag is replaced by preferredTag.\n+                    // Save the delta to add it back later.\n+                    parsedLenDelta = redundantTagLen - preferredTagLen;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n     /*\n      * langtag      =   language\n      *                  [\"-\" script]\n@@ -1898,10 +2195,13 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta\n         if (next & LANG) {\n             if (_isLanguageSubtag(pSubtag, subtagLen)) {\n                 *pSep = 0;  /* terminate */\n+                // TODO: move deprecated language code handling here.\n                 t->language = T_CString_toLowerCase(pSubtag);\n \n                 pLastGoodPosition = pSep;\n-                next = EXTL | SCRT | REGN | VART | EXTS | PRIV;\n+                next = SCRT | REGN | VART | EXTS | PRIV;\n+                if (subtagLen <= 3)\n+                  next |= EXTL;\n                 continue;\n             }\n         }\n@@ -1942,6 +2242,7 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta\n         if (next & REGN) {\n             if (_isRegionSubtag(pSubtag, subtagLen)) {\n                 *pSep = 0;\n+                // TODO: move deprecated region code handling here.\n                 t->region = T_CString_toUpperCase(pSubtag);\n \n                 pLastGoodPosition = pSep;\n@@ -2035,7 +2336,7 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta\n             }\n         }\n         if (next & PRIV) {\n-            if (uprv_tolower(*pSubtag) == PRIVATEUSE) {\n+            if (uprv_tolower(*pSubtag) == PRIVATEUSE && subtagLen == 1) {\n                 char *pPrivuseVal;\n \n                 if (pExtension != NULL) {\n@@ -2138,7 +2439,8 @@ ultag_parse(const char* tag, int32_t tagLen, int32_t* parsedLen, UErrorCode* sta\n     }\n \n     if (parsedLen != NULL) {\n-        *parsedLen = (grandfatheredLen > 0) ? grandfatheredLen : (int32_t)(pLastGoodPosition - t->buf);\n+        *parsedLen = (grandfatheredLen > 0) ? grandfatheredLen :\n+            (int32_t)(pLastGoodPosition - t->buf + parsedLenDelta);\n     }\n \n     return t;\n@@ -2335,31 +2637,66 @@ uloc_toLanguageTag(const char* localeID,\n                    int32_t langtagCapacity,\n                    UBool strict,\n                    UErrorCode* status) {\n-    /* char canonical[ULOC_FULLNAME_CAPACITY]; */ /* See #6822 */\n-    char canonical[256];\n-    int32_t reslen = 0;\n+    icu::CharString canonical;\n+    int32_t reslen;\n     UErrorCode tmpStatus = U_ZERO_ERROR;\n     UBool hadPosix = FALSE;\n     const char* pKeywordStart;\n \n     /* Note: uloc_canonicalize returns \"en_US_POSIX\" for input locale ID \"\".  See #6835 */\n-    canonical[0] = 0;\n-    if (uprv_strlen(localeID) > 0) {\n-        uloc_canonicalize(localeID, canonical, sizeof(canonical), &tmpStatus);\n-        if (tmpStatus != U_ZERO_ERROR) {\n+    int32_t resultCapacity = static_cast<int32_t>(uprv_strlen(localeID));\n+    if (resultCapacity > 0) {\n+        char* buffer;\n+\n+        for (;;) {\n+            buffer = canonical.getAppendBuffer(\n+                    /*minCapacity=*/resultCapacity,\n+                    /*desiredCapacityHint=*/resultCapacity,\n+                    resultCapacity,\n+                    tmpStatus);\n+\n+            if (U_FAILURE(tmpStatus)) {\n+                *status = tmpStatus;\n+                return 0;\n+            }\n+\n+            reslen =\n+                uloc_canonicalize(localeID, buffer, resultCapacity, &tmpStatus);\n+\n+            if (tmpStatus != U_BUFFER_OVERFLOW_ERROR) {\n+                break;\n+            }\n+\n+            resultCapacity = reslen;\n+            tmpStatus = U_ZERO_ERROR;\n+        }\n+\n+        if (U_FAILURE(tmpStatus)) {\n             *status = U_ILLEGAL_ARGUMENT_ERROR;\n             return 0;\n         }\n+\n+        canonical.append(buffer, reslen, tmpStatus);\n+        if (tmpStatus == U_STRING_NOT_TERMINATED_WARNING) {\n+            tmpStatus = U_ZERO_ERROR;  // Terminators provided by CharString.\n+        }\n+\n+        if (U_FAILURE(tmpStatus)) {\n+            *status = tmpStatus;\n+            return 0;\n+        }\n     }\n \n+    reslen = 0;\n+\n     /* For handling special case - private use only tag */\n-    pKeywordStart = locale_getKeywordsStart(canonical);\n-    if (pKeywordStart == canonical) {\n+    pKeywordStart = locale_getKeywordsStart(canonical.data());\n+    if (pKeywordStart == canonical.data()) {\n         UEnumeration *kwdEnum;\n         int kwdCnt = 0;\n         UBool done = FALSE;\n \n-        kwdEnum = uloc_openKeywords((const char*)canonical, &tmpStatus);\n+        kwdEnum = uloc_openKeywords(canonical.data(), &tmpStatus);\n         if (kwdEnum != NULL) {\n             kwdCnt = uenum_count(kwdEnum, &tmpStatus);\n             if (kwdCnt == 1) {\n@@ -2397,12 +2734,12 @@ uloc_toLanguageTag(const char* localeID,\n         }\n     }\n \n-    reslen += _appendLanguageToLanguageTag(canonical, langtag, langtagCapacity, strict, status);\n-    reslen += _appendScriptToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, status);\n-    reslen += _appendRegionToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, status);\n-    reslen += _appendVariantsToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, &hadPosix, status);\n-    reslen += _appendKeywordsToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);\n-    reslen += _appendPrivateuseToLanguageTag(canonical, langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);\n+    reslen += _appendLanguageToLanguageTag(canonical.data(), langtag, langtagCapacity, strict, status);\n+    reslen += _appendScriptToLanguageTag(canonical.data(), langtag + reslen, langtagCapacity - reslen, strict, status);\n+    reslen += _appendRegionToLanguageTag(canonical.data(), langtag + reslen, langtagCapacity - reslen, strict, status);\n+    reslen += _appendVariantsToLanguageTag(canonical.data(), langtag + reslen, langtagCapacity - reslen, strict, &hadPosix, status);\n+    reslen += _appendKeywordsToLanguageTag(canonical.data(), langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);\n+    reslen += _appendPrivateuseToLanguageTag(canonical.data(), langtag + reslen, langtagCapacity - reslen, strict, hadPosix, status);\n \n     return reslen;\n }\n@@ -2414,14 +2751,31 @@ uloc_forLanguageTag(const char* langtag,\n                     int32_t localeIDCapacity,\n                     int32_t* parsedLength,\n                     UErrorCode* status) {\n+    return ulocimp_forLanguageTag(\n+            langtag,\n+            -1,\n+            localeID,\n+            localeIDCapacity,\n+            parsedLength,\n+            status);\n+}\n+\n+\n+U_CAPI int32_t U_EXPORT2\n+ulocimp_forLanguageTag(const char* langtag,\n+                       int32_t tagLen,\n+                       char* localeID,\n+                       int32_t localeIDCapacity,\n+                       int32_t* parsedLength,\n+                       UErrorCode* status) {\n     ULanguageTag *lt;\n     int32_t reslen = 0;\n     const char *subtag, *p;\n     int32_t len;\n     int32_t i, n;\n     UBool noRegion = TRUE;\n \n-    lt = ultag_parse(langtag, -1, parsedLength, status);\n+    lt = ultag_parse(langtag, tagLen, parsedLength, status);\n     if (U_FAILURE(*status)) {\n         return 0;\n     }"
        },
        {
            "sha": "6dd8e33e09c88ccc916a31d5f84f95682af7f23c",
            "filename": "deps/icu-small/source/common/ulocimp.h",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fulocimp.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fulocimp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fulocimp.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -61,6 +61,38 @@ ulocimp_getCountry(const char *localeID,\n                    char *country, int32_t countryCapacity,\n                    const char **pEnd);\n \n+/**\n+ * Returns a locale ID for the specified BCP47 language tag string.\n+ * If the specified language tag contains any ill-formed subtags,\n+ * the first such subtag and all following subtags are ignored.\n+ * <p>\n+ * This implements the 'Language-Tag' production of BCP47, and so\n+ * supports grandfathered (regular and irregular) as well as private\n+ * use language tags.  Private use tags are represented as 'x-whatever',\n+ * and grandfathered tags are converted to their canonical replacements\n+ * where they exist.  Note that a few grandfathered tags have no modern\n+ * replacement, these will be converted using the fallback described in\n+ * the first paragraph, so some information might be lost.\n+ * @param langtag   the input BCP47 language tag.\n+ * @param tagLen    the length of langtag, or -1 to call uprv_strlen().\n+ * @param localeID  the output buffer receiving a locale ID for the\n+ *                  specified BCP47 language tag.\n+ * @param localeIDCapacity  the size of the locale ID output buffer.\n+ * @param parsedLength  if not NULL, successfully parsed length\n+ *                      for the input language tag is set.\n+ * @param err       error information if receiving the locald ID\n+ *                  failed.\n+ * @return          the length of the locale ID.\n+ * @internal ICU 63\n+ */\n+U_CAPI int32_t U_EXPORT2\n+ulocimp_forLanguageTag(const char* langtag,\n+                       int32_t tagLen,\n+                       char* localeID,\n+                       int32_t localeIDCapacity,\n+                       int32_t* parsedLength,\n+                       UErrorCode* err);\n+\n /**\n  * Get the region to use for supplemental data lookup. Uses\n  * (1) any region specified by locale tag \"rg\"; if none then"
        },
        {
            "sha": "a32573bbf70c95ea54ddf39252cbc159e865d6ce",
            "filename": "deps/icu-small/source/common/umapfile.cpp",
            "status": "modified",
            "additions": 54,
            "deletions": 24,
            "changes": 78,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fumapfile.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fumapfile.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fumapfile.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -22,6 +22,7 @@\n #include \"uposixdefs.h\"\n \n #include \"unicode/putil.h\"\n+#include \"unicode/ustring.h\"\n #include \"udatamem.h\"\n #include \"umapfile.h\"\n \n@@ -64,7 +65,7 @@\n #       include \"unicode/udata.h\"\n #       define LIB_PREFIX \"lib\"\n #       define LIB_SUFFIX \".dll\"\n-        /* This is inconvienient until we figure out what to do with U_ICUDATA_NAME in utypes.h */\n+        /* This is inconvenient until we figure out what to do with U_ICUDATA_NAME in utypes.h */\n #       define U_ICUDATA_ENTRY_NAME \"icudt\" U_ICU_VERSION_SHORT U_LIB_SUFFIX_C_NAME_STRING \"_dat\"\n #   endif\n #elif MAP_IMPLEMENTATION==MAP_STDIO\n@@ -84,7 +85,10 @@\n  *----------------------------------------------------------------------------*/\n #if MAP_IMPLEMENTATION==MAP_NONE\n     U_CFUNC UBool\n-    uprv_mapFile(UDataMemory *pData, const char *path) {\n+    uprv_mapFile(UDataMemory *pData, const char *path, UErrorCode *status) {\n+        if (U_FAILURE(*status)) {\n+            return FALSE;\n+        }\n         UDataMemory_init(pData); /* Clear the output struct. */\n         return FALSE;            /* no file access */\n     }\n@@ -97,12 +101,17 @@\n     uprv_mapFile(\n          UDataMemory *pData,    /* Fill in with info on the result doing the mapping. */\n                                 /*   Output only; any original contents are cleared.  */\n-         const char *path       /* File path to be opened/mapped                      */\n+         const char *path,      /* File path to be opened/mapped.                     */\n+         UErrorCode *status     /* Error status, used to report out-of-memory errors. */\n          )\n     {\n         HANDLE map;\n         HANDLE file;\n \n+        if (U_FAILURE(*status)) {\n+            return FALSE;\n+        }\n+\n         UDataMemory_init(pData); /* Clear the output struct.        */\n \n         /* open the input file */\n@@ -111,28 +120,29 @@\n             OPEN_EXISTING,\n             FILE_ATTRIBUTE_NORMAL|FILE_FLAG_RANDOM_ACCESS, NULL);\n #else\n-        // First we need to go from char to UTF-16\n-        // u_UCharsToChars could work but it requires length.\n-        WCHAR utf16Path[MAX_PATH];\n-        int32_t i;\n-        for (i = 0; i < UPRV_LENGTHOF(utf16Path); i++)\n-        {\n-            utf16Path[i] = path[i];\n-            if (path[i] == '\\0')\n-            {\n-                break;\n-            }\n+        // Convert from UTF-8 string to UTF-16 string.\n+        wchar_t utf16Path[MAX_PATH];\n+        int32_t pathUtf16Len = 0;\n+        u_strFromUTF8(reinterpret_cast<UChar*>(utf16Path), static_cast<int32_t>(UPRV_LENGTHOF(utf16Path)), &pathUtf16Len, path, -1, status);\n+\n+        if (U_FAILURE(*status)) {\n+            return FALSE;\n         }\n-        if (i >= UPRV_LENGTHOF(utf16Path))\n-        {\n-            // Ran out of room, unlikely but be safe\n-            utf16Path[UPRV_LENGTHOF(utf16Path) - 1] = '\\0';\n+        if (*status == U_STRING_NOT_TERMINATED_WARNING) {\n+            // Report back an error instead of a warning.\n+            *status = U_BUFFER_OVERFLOW_ERROR;\n+            return FALSE;\n         }\n \n         // TODO: Is it worth setting extended parameters to specify random access?\n         file = CreateFile2(utf16Path, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, NULL);\n #endif\n-        if(file==INVALID_HANDLE_VALUE) {\n+        if (file == INVALID_HANDLE_VALUE) {\n+            // If we failed to open the file due to an out-of-memory error, then we want\n+            // to report that error back to the caller.\n+            if (HRESULT_FROM_WIN32(GetLastError()) == E_OUTOFMEMORY) {\n+                *status = U_MEMORY_ALLOCATION_ERROR;\n+            }\n             return FALSE;\n         }\n \n@@ -165,7 +175,12 @@\n         map = CreateFileMappingFromApp(file, NULL, PAGE_READONLY, 0, NULL);\n #endif\n         CloseHandle(file);\n-        if(map==NULL) {\n+        if (map == NULL) {\n+            // If we failed to create the mapping due to an out-of-memory error, then\n+            // we want to report that error back to the caller.\n+            if (HRESULT_FROM_WIN32(GetLastError()) == E_OUTOFMEMORY) {\n+                *status = U_MEMORY_ALLOCATION_ERROR;\n+            }\n             return FALSE;\n         }\n \n@@ -193,12 +208,16 @@\n \n #elif MAP_IMPLEMENTATION==MAP_POSIX\n     U_CFUNC UBool\n-    uprv_mapFile(UDataMemory *pData, const char *path) {\n+    uprv_mapFile(UDataMemory *pData, const char *path, UErrorCode *status) {\n         int fd;\n         int length;\n         struct stat mystat;\n         void *data;\n \n+        if (U_FAILURE(*status)) {\n+            return FALSE;\n+        }\n+\n         UDataMemory_init(pData); /* Clear the output struct.        */\n \n         /* determine the length of the file */\n@@ -221,6 +240,7 @@\n #endif\n         close(fd); /* no longer needed */\n         if(data==MAP_FAILED) {\n+            // Possibly check the errno value for ENOMEM, and report U_MEMORY_ALLOCATION_ERROR?\n             return FALSE;\n         }\n \n@@ -263,11 +283,15 @@\n     }\n \n     U_CFUNC UBool\n-    uprv_mapFile(UDataMemory *pData, const char *path) {\n+    uprv_mapFile(UDataMemory *pData, const char *path, UErrorCode *status) {\n         FILE *file;\n         int32_t fileLength;\n         void *p;\n \n+        if (U_FAILURE(*status)) {\n+            return FALSE;\n+        }\n+\n         UDataMemory_init(pData); /* Clear the output struct.        */\n         /* open the input file */\n         file=fopen(path, \"rb\");\n@@ -286,6 +310,7 @@\n         p=uprv_malloc(fileLength);\n         if(p==NULL) {\n             fclose(file);\n+            *status = U_MEMORY_ALLOCATION_ERROR;\n             return FALSE;\n         }\n \n@@ -351,7 +376,7 @@\n      *\n      *                    TODO:  This works the way ICU historically has, but the\n      *                           whole data fallback search path is so complicated that\n-     *                           proabably almost no one will ever really understand it,\n+     *                           probably almost no one will ever really understand it,\n      *                           the potential for confusion is large.  (It's not just\n      *                           this one function, but the whole scheme.)\n      *\n@@ -391,14 +416,18 @@\n \n #   define DATA_TYPE \"dat\"\n \n-    U_CFUNC UBool uprv_mapFile(UDataMemory *pData, const char *path) {\n+    U_CFUNC UBool uprv_mapFile(UDataMemory *pData, const char *path, UErrorCode *status) {\n         const char *inBasename;\n         char *basename;\n         char pathBuffer[1024];\n         const DataHeader *pHeader;\n         dllhandle *handle;\n         void *val=0;\n \n+        if (U_FAILURE(*status)) {\n+            return FALSE;\n+        }\n+\n         inBasename=uprv_strrchr(path, U_FILE_SEP_CHAR);\n         if(inBasename==NULL) {\n             inBasename = path;\n@@ -430,6 +459,7 @@\n             data=mmap(0, length, PROT_READ, MAP_PRIVATE, fd, 0);\n             close(fd); /* no longer needed */\n             if(data==MAP_FAILED) {\n+                // Possibly check the errorno value for ENOMEM, and report U_MEMORY_ALLOCATION_ERROR?\n                 return FALSE;\n             }\n             pData->map = (char *)data + length;"
        },
        {
            "sha": "92bd567a2a98952845eb489391092a6a64d9dfbc",
            "filename": "deps/icu-small/source/common/umapfile.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fumapfile.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fumapfile.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fumapfile.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -29,7 +29,7 @@\n #include \"unicode/udata.h\"\n #include \"putilimp.h\"\n \n-U_CFUNC UBool uprv_mapFile(UDataMemory *pdm, const char *path);\n+U_CFUNC UBool uprv_mapFile(UDataMemory *pdm, const char *path, UErrorCode *status);\n U_CFUNC void  uprv_unmapFile(UDataMemory *pData);\n \n /* MAP_NONE: no memory mapping, no file access at all */"
        },
        {
            "sha": "40af4b6c16a163a8ab7f777403d873ad9f38c4a7",
            "filename": "deps/icu-small/source/common/umutablecptrie.cpp",
            "status": "added",
            "additions": 1678,
            "deletions": 0,
            "changes": 1678,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fumutablecptrie.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fumutablecptrie.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fumutablecptrie.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,1678 @@\n+// Â© 2017 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+// umutablecptrie.cpp (inspired by utrie2_builder.cpp)\n+// created: 2017dec29 Markus W. Scherer\n+\n+// #define UCPTRIE_DEBUG\n+#ifdef UCPTRIE_DEBUG\n+#   include <stdio.h>\n+#endif\n+\n+#include \"unicode/utypes.h\"\n+#include \"unicode/ucptrie.h\"\n+#include \"unicode/umutablecptrie.h\"\n+#include \"unicode/uobject.h\"\n+#include \"unicode/utf16.h\"\n+#include \"cmemory.h\"\n+#include \"uassert.h\"\n+#include \"ucptrie_impl.h\"\n+\n+U_NAMESPACE_BEGIN\n+\n+namespace {\n+\n+constexpr int32_t MAX_UNICODE = 0x10ffff;\n+\n+constexpr int32_t UNICODE_LIMIT = 0x110000;\n+constexpr int32_t BMP_LIMIT = 0x10000;\n+constexpr int32_t ASCII_LIMIT = 0x80;\n+\n+constexpr int32_t I_LIMIT = UNICODE_LIMIT >> UCPTRIE_SHIFT_3;\n+constexpr int32_t BMP_I_LIMIT = BMP_LIMIT >> UCPTRIE_SHIFT_3;\n+constexpr int32_t ASCII_I_LIMIT = ASCII_LIMIT >> UCPTRIE_SHIFT_3;\n+\n+constexpr int32_t SMALL_DATA_BLOCKS_PER_BMP_BLOCK = (1 << (UCPTRIE_FAST_SHIFT - UCPTRIE_SHIFT_3));\n+\n+// Flag values for data blocks.\n+constexpr uint8_t ALL_SAME = 0;\n+constexpr uint8_t MIXED = 1;\n+constexpr uint8_t SAME_AS = 2;\n+\n+/** Start with allocation of 16k data entries. */\n+constexpr int32_t INITIAL_DATA_LENGTH = ((int32_t)1 << 14);\n+\n+/** Grow about 8x each time. */\n+constexpr int32_t MEDIUM_DATA_LENGTH = ((int32_t)1 << 17);\n+\n+/**\n+ * Maximum length of the build-time data array.\n+ * One entry per 0x110000 code points.\n+ */\n+constexpr int32_t MAX_DATA_LENGTH = UNICODE_LIMIT;\n+\n+// Flag values for index-3 blocks while compacting/building.\n+constexpr uint8_t I3_NULL = 0;\n+constexpr uint8_t I3_BMP = 1;\n+constexpr uint8_t I3_16 = 2;\n+constexpr uint8_t I3_18 = 3;\n+\n+constexpr int32_t INDEX_3_18BIT_BLOCK_LENGTH = UCPTRIE_INDEX_3_BLOCK_LENGTH + UCPTRIE_INDEX_3_BLOCK_LENGTH / 8;\n+\n+class AllSameBlocks;\n+\n+class MutableCodePointTrie : public UMemory {\n+public:\n+    MutableCodePointTrie(uint32_t initialValue, uint32_t errorValue, UErrorCode &errorCode);\n+    MutableCodePointTrie(const MutableCodePointTrie &other, UErrorCode &errorCode);\n+    MutableCodePointTrie(const MutableCodePointTrie &other) = delete;\n+    ~MutableCodePointTrie();\n+\n+    MutableCodePointTrie &operator=(const MutableCodePointTrie &other) = delete;\n+\n+    static MutableCodePointTrie *fromUCPMap(const UCPMap *map, UErrorCode &errorCode);\n+    static MutableCodePointTrie *fromUCPTrie(const UCPTrie *trie, UErrorCode &errorCode);\n+\n+    uint32_t get(UChar32 c) const;\n+    int32_t getRange(UChar32 start, UCPMapValueFilter *filter, const void *context,\n+                     uint32_t *pValue) const;\n+\n+    void set(UChar32 c, uint32_t value, UErrorCode &errorCode);\n+    void setRange(UChar32 start, UChar32 end, uint32_t value, UErrorCode &errorCode);\n+\n+    UCPTrie *build(UCPTrieType type, UCPTrieValueWidth valueWidth, UErrorCode &errorCode);\n+\n+private:\n+    void clear();\n+\n+    bool ensureHighStart(UChar32 c);\n+    int32_t allocDataBlock(int32_t blockLength);\n+    int32_t getDataBlock(int32_t i);\n+\n+    void maskValues(uint32_t mask);\n+    UChar32 findHighStart() const;\n+    int32_t compactWholeDataBlocks(int32_t fastILimit, AllSameBlocks &allSameBlocks);\n+    int32_t compactData(int32_t fastILimit, uint32_t *newData, int32_t dataNullIndex);\n+    int32_t compactIndex(int32_t fastILimit, UErrorCode &errorCode);\n+    int32_t compactTrie(int32_t fastILimit, UErrorCode &errorCode);\n+\n+    uint32_t *index = nullptr;\n+    int32_t indexCapacity = 0;\n+    int32_t index3NullOffset = -1;\n+    uint32_t *data = nullptr;\n+    int32_t dataCapacity = 0;\n+    int32_t dataLength = 0;\n+    int32_t dataNullOffset = -1;\n+\n+    uint32_t origInitialValue;\n+    uint32_t initialValue;\n+    uint32_t errorValue;\n+    UChar32 highStart;\n+    uint32_t highValue;\n+#ifdef UCPTRIE_DEBUG\n+public:\n+    const char *name;\n+#endif\n+private:\n+    /** Temporary array while building the final data. */\n+    uint16_t *index16 = nullptr;\n+    uint8_t flags[UNICODE_LIMIT >> UCPTRIE_SHIFT_3];\n+};\n+\n+MutableCodePointTrie::MutableCodePointTrie(uint32_t iniValue, uint32_t errValue, UErrorCode &errorCode) :\n+        origInitialValue(iniValue), initialValue(iniValue), errorValue(errValue),\n+        highStart(0), highValue(initialValue)\n+#ifdef UCPTRIE_DEBUG\n+        , name(\"open\")\n+#endif\n+        {\n+    if (U_FAILURE(errorCode)) { return; }\n+    index = (uint32_t *)uprv_malloc(BMP_I_LIMIT * 4);\n+    data = (uint32_t *)uprv_malloc(INITIAL_DATA_LENGTH * 4);\n+    if (index == nullptr || data == nullptr) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return;\n+    }\n+    indexCapacity = BMP_I_LIMIT;\n+    dataCapacity = INITIAL_DATA_LENGTH;\n+}\n+\n+MutableCodePointTrie::MutableCodePointTrie(const MutableCodePointTrie &other, UErrorCode &errorCode) :\n+        index3NullOffset(other.index3NullOffset),\n+        dataNullOffset(other.dataNullOffset),\n+        origInitialValue(other.origInitialValue), initialValue(other.initialValue),\n+        errorValue(other.errorValue),\n+        highStart(other.highStart), highValue(other.highValue)\n+#ifdef UCPTRIE_DEBUG\n+        , name(\"mutable clone\")\n+#endif\n+        {\n+    if (U_FAILURE(errorCode)) { return; }\n+    int32_t iCapacity = highStart <= BMP_LIMIT ? BMP_I_LIMIT : I_LIMIT;\n+    index = (uint32_t *)uprv_malloc(iCapacity * 4);\n+    data = (uint32_t *)uprv_malloc(other.dataCapacity * 4);\n+    if (index == nullptr || data == nullptr) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return;\n+    }\n+    indexCapacity = iCapacity;\n+    dataCapacity = other.dataCapacity;\n+\n+    int32_t iLimit = highStart >> UCPTRIE_SHIFT_3;\n+    uprv_memcpy(flags, other.flags, iLimit);\n+    uprv_memcpy(index, other.index, iLimit * 4);\n+    uprv_memcpy(data, other.data, (size_t)other.dataLength * 4);\n+    dataLength = other.dataLength;\n+    U_ASSERT(other.index16 == nullptr);\n+}\n+\n+MutableCodePointTrie::~MutableCodePointTrie() {\n+    uprv_free(index);\n+    uprv_free(data);\n+    uprv_free(index16);\n+}\n+\n+MutableCodePointTrie *MutableCodePointTrie::fromUCPMap(const UCPMap *map, UErrorCode &errorCode) {\n+    // Use the highValue as the initialValue to reduce the highStart.\n+    uint32_t errorValue = ucpmap_get(map, -1);\n+    uint32_t initialValue = ucpmap_get(map, 0x10ffff);\n+    LocalPointer<MutableCodePointTrie> mutableTrie(\n+        new MutableCodePointTrie(initialValue, errorValue, errorCode),\n+        errorCode);\n+    if (U_FAILURE(errorCode)) {\n+        return nullptr;\n+    }\n+    UChar32 start = 0, end;\n+    uint32_t value;\n+    while ((end = ucpmap_getRange(map, start, UCPMAP_RANGE_NORMAL, 0,\n+                                  nullptr, nullptr, &value)) >= 0) {\n+        if (value != initialValue) {\n+            if (start == end) {\n+                mutableTrie->set(start, value, errorCode);\n+            } else {\n+                mutableTrie->setRange(start, end, value, errorCode);\n+            }\n+        }\n+        start = end + 1;\n+    }\n+    if (U_SUCCESS(errorCode)) {\n+        return mutableTrie.orphan();\n+    } else {\n+        return nullptr;\n+    }\n+}\n+\n+MutableCodePointTrie *MutableCodePointTrie::fromUCPTrie(const UCPTrie *trie, UErrorCode &errorCode) {\n+    // Use the highValue as the initialValue to reduce the highStart.\n+    uint32_t errorValue;\n+    uint32_t initialValue;\n+    switch (trie->valueWidth) {\n+    case UCPTRIE_VALUE_BITS_16:\n+        errorValue = trie->data.ptr16[trie->dataLength - UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET];\n+        initialValue = trie->data.ptr16[trie->dataLength - UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET];\n+        break;\n+    case UCPTRIE_VALUE_BITS_32:\n+        errorValue = trie->data.ptr32[trie->dataLength - UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET];\n+        initialValue = trie->data.ptr32[trie->dataLength - UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET];\n+        break;\n+    case UCPTRIE_VALUE_BITS_8:\n+        errorValue = trie->data.ptr8[trie->dataLength - UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET];\n+        initialValue = trie->data.ptr8[trie->dataLength - UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET];\n+        break;\n+    default:\n+        // Unreachable if the trie is properly initialized.\n+        errorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return nullptr;\n+    }\n+    LocalPointer<MutableCodePointTrie> mutableTrie(\n+        new MutableCodePointTrie(initialValue, errorValue, errorCode),\n+        errorCode);\n+    if (U_FAILURE(errorCode)) {\n+        return nullptr;\n+    }\n+    UChar32 start = 0, end;\n+    uint32_t value;\n+    while ((end = ucptrie_getRange(trie, start, UCPMAP_RANGE_NORMAL, 0,\n+                                   nullptr, nullptr, &value)) >= 0) {\n+        if (value != initialValue) {\n+            if (start == end) {\n+                mutableTrie->set(start, value, errorCode);\n+            } else {\n+                mutableTrie->setRange(start, end, value, errorCode);\n+            }\n+        }\n+        start = end + 1;\n+    }\n+    if (U_SUCCESS(errorCode)) {\n+        return mutableTrie.orphan();\n+    } else {\n+        return nullptr;\n+    }\n+}\n+\n+void MutableCodePointTrie::clear() {\n+    index3NullOffset = dataNullOffset = -1;\n+    dataLength = 0;\n+    highValue = initialValue = origInitialValue;\n+    highStart = 0;\n+    uprv_free(index16);\n+    index16 = nullptr;\n+}\n+\n+uint32_t MutableCodePointTrie::get(UChar32 c) const {\n+    if ((uint32_t)c > MAX_UNICODE) {\n+        return errorValue;\n+    }\n+    if (c >= highStart) {\n+        return highValue;\n+    }\n+    int32_t i = c >> UCPTRIE_SHIFT_3;\n+    if (flags[i] == ALL_SAME) {\n+        return index[i];\n+    } else {\n+        return data[index[i] + (c & UCPTRIE_SMALL_DATA_MASK)];\n+    }\n+}\n+\n+inline uint32_t maybeFilterValue(uint32_t value, uint32_t initialValue, uint32_t nullValue,\n+                                 UCPMapValueFilter *filter, const void *context) {\n+    if (value == initialValue) {\n+        value = nullValue;\n+    } else if (filter != nullptr) {\n+        value = filter(context, value);\n+    }\n+    return value;\n+}\n+\n+UChar32 MutableCodePointTrie::getRange(\n+        UChar32 start, UCPMapValueFilter *filter, const void *context,\n+        uint32_t *pValue) const {\n+    if ((uint32_t)start > MAX_UNICODE) {\n+        return U_SENTINEL;\n+    }\n+    if (start >= highStart) {\n+        if (pValue != nullptr) {\n+            uint32_t value = highValue;\n+            if (filter != nullptr) { value = filter(context, value); }\n+            *pValue = value;\n+        }\n+        return MAX_UNICODE;\n+    }\n+    uint32_t nullValue = initialValue;\n+    if (filter != nullptr) { nullValue = filter(context, nullValue); }\n+    UChar32 c = start;\n+    uint32_t value;\n+    bool haveValue = false;\n+    int32_t i = c >> UCPTRIE_SHIFT_3;\n+    do {\n+        if (flags[i] == ALL_SAME) {\n+            uint32_t value2 = maybeFilterValue(index[i], initialValue, nullValue,\n+                                               filter, context);\n+            if (haveValue) {\n+                if (value2 != value) {\n+                    return c - 1;\n+                }\n+            } else {\n+                value = value2;\n+                if (pValue != nullptr) { *pValue = value; }\n+                haveValue = true;\n+            }\n+            c = (c + UCPTRIE_SMALL_DATA_BLOCK_LENGTH) & ~UCPTRIE_SMALL_DATA_MASK;\n+        } else /* MIXED */ {\n+            int32_t di = index[i] + (c & UCPTRIE_SMALL_DATA_MASK);\n+            uint32_t value2 = maybeFilterValue(data[di], initialValue, nullValue,\n+                                               filter, context);\n+            if (haveValue) {\n+                if (value2 != value) {\n+                    return c - 1;\n+                }\n+            } else {\n+                value = value2;\n+                if (pValue != nullptr) { *pValue = value; }\n+                haveValue = true;\n+            }\n+            while ((++c & UCPTRIE_SMALL_DATA_MASK) != 0) {\n+                if (maybeFilterValue(data[++di], initialValue, nullValue,\n+                                     filter, context) != value) {\n+                    return c - 1;\n+                }\n+            }\n+        }\n+        ++i;\n+    } while (c < highStart);\n+    U_ASSERT(haveValue);\n+    if (maybeFilterValue(highValue, initialValue, nullValue,\n+                         filter, context) != value) {\n+        return c - 1;\n+    } else {\n+        return MAX_UNICODE;\n+    }\n+}\n+\n+void\n+writeBlock(uint32_t *block, uint32_t value) {\n+    uint32_t *limit = block + UCPTRIE_SMALL_DATA_BLOCK_LENGTH;\n+    while (block < limit) {\n+        *block++ = value;\n+    }\n+}\n+\n+bool MutableCodePointTrie::ensureHighStart(UChar32 c) {\n+    if (c >= highStart) {\n+        // Round up to a UCPTRIE_CP_PER_INDEX_2_ENTRY boundary to simplify compaction.\n+        c = (c + UCPTRIE_CP_PER_INDEX_2_ENTRY) & ~(UCPTRIE_CP_PER_INDEX_2_ENTRY - 1);\n+        int32_t i = highStart >> UCPTRIE_SHIFT_3;\n+        int32_t iLimit = c >> UCPTRIE_SHIFT_3;\n+        if (iLimit > indexCapacity) {\n+            uint32_t *newIndex = (uint32_t *)uprv_malloc(I_LIMIT * 4);\n+            if (newIndex == nullptr) { return false; }\n+            uprv_memcpy(newIndex, index, i * 4);\n+            uprv_free(index);\n+            index = newIndex;\n+            indexCapacity = I_LIMIT;\n+        }\n+        do {\n+            flags[i] = ALL_SAME;\n+            index[i] = initialValue;\n+        } while(++i < iLimit);\n+        highStart = c;\n+    }\n+    return true;\n+}\n+\n+int32_t MutableCodePointTrie::allocDataBlock(int32_t blockLength) {\n+    int32_t newBlock = dataLength;\n+    int32_t newTop = newBlock + blockLength;\n+    if (newTop > dataCapacity) {\n+        int32_t capacity;\n+        if (dataCapacity < MEDIUM_DATA_LENGTH) {\n+            capacity = MEDIUM_DATA_LENGTH;\n+        } else if (dataCapacity < MAX_DATA_LENGTH) {\n+            capacity = MAX_DATA_LENGTH;\n+        } else {\n+            // Should never occur.\n+            // Either MAX_DATA_LENGTH is incorrect,\n+            // or the code writes more values than should be possible.\n+            return -1;\n+        }\n+        uint32_t *newData = (uint32_t *)uprv_malloc(capacity * 4);\n+        if (newData == nullptr) {\n+            return -1;\n+        }\n+        uprv_memcpy(newData, data, (size_t)dataLength * 4);\n+        uprv_free(data);\n+        data = newData;\n+        dataCapacity = capacity;\n+    }\n+    dataLength = newTop;\n+    return newBlock;\n+}\n+\n+/**\n+ * No error checking for illegal arguments.\n+ *\n+ * @return -1 if no new data block available (out of memory in data array)\n+ * @internal\n+ */\n+int32_t MutableCodePointTrie::getDataBlock(int32_t i) {\n+    if (flags[i] == MIXED) {\n+        return index[i];\n+    }\n+    if (i < BMP_I_LIMIT) {\n+        int32_t newBlock = allocDataBlock(UCPTRIE_FAST_DATA_BLOCK_LENGTH);\n+        if (newBlock < 0) { return newBlock; }\n+        int32_t iStart = i & ~(SMALL_DATA_BLOCKS_PER_BMP_BLOCK -1);\n+        int32_t iLimit = iStart + SMALL_DATA_BLOCKS_PER_BMP_BLOCK;\n+        do {\n+            U_ASSERT(flags[iStart] == ALL_SAME);\n+            writeBlock(data + newBlock, index[iStart]);\n+            flags[iStart] = MIXED;\n+            index[iStart++] = newBlock;\n+            newBlock += UCPTRIE_SMALL_DATA_BLOCK_LENGTH;\n+        } while (iStart < iLimit);\n+        return index[i];\n+    } else {\n+        int32_t newBlock = allocDataBlock(UCPTRIE_SMALL_DATA_BLOCK_LENGTH);\n+        if (newBlock < 0) { return newBlock; }\n+        writeBlock(data + newBlock, index[i]);\n+        flags[i] = MIXED;\n+        index[i] = newBlock;\n+        return newBlock;\n+    }\n+}\n+\n+void MutableCodePointTrie::set(UChar32 c, uint32_t value, UErrorCode &errorCode) {\n+    if (U_FAILURE(errorCode)) {\n+        return;\n+    }\n+    if ((uint32_t)c > MAX_UNICODE) {\n+        errorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+\n+    int32_t block;\n+    if (!ensureHighStart(c) || (block = getDataBlock(c >> UCPTRIE_SHIFT_3)) < 0) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return;\n+    }\n+\n+    data[block + (c & UCPTRIE_SMALL_DATA_MASK)] = value;\n+}\n+\n+void\n+fillBlock(uint32_t *block, UChar32 start, UChar32 limit, uint32_t value) {\n+    uint32_t *pLimit = block + limit;\n+    block += start;\n+    while (block < pLimit) {\n+        *block++ = value;\n+    }\n+}\n+\n+void MutableCodePointTrie::setRange(UChar32 start, UChar32 end, uint32_t value, UErrorCode &errorCode) {\n+    if (U_FAILURE(errorCode)) {\n+        return;\n+    }\n+    if ((uint32_t)start > MAX_UNICODE || (uint32_t)end > MAX_UNICODE || start > end) {\n+        errorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+    if (!ensureHighStart(end)) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return;\n+    }\n+\n+    UChar32 limit = end + 1;\n+    if (start & UCPTRIE_SMALL_DATA_MASK) {\n+        // Set partial block at [start..following block boundary[.\n+        int32_t block = getDataBlock(start >> UCPTRIE_SHIFT_3);\n+        if (block < 0) {\n+            errorCode = U_MEMORY_ALLOCATION_ERROR;\n+            return;\n+        }\n+\n+        UChar32 nextStart = (start + UCPTRIE_SMALL_DATA_MASK) & ~UCPTRIE_SMALL_DATA_MASK;\n+        if (nextStart <= limit) {\n+            fillBlock(data + block, start & UCPTRIE_SMALL_DATA_MASK, UCPTRIE_SMALL_DATA_BLOCK_LENGTH,\n+                      value);\n+            start = nextStart;\n+        } else {\n+            fillBlock(data + block, start & UCPTRIE_SMALL_DATA_MASK, limit & UCPTRIE_SMALL_DATA_MASK,\n+                      value);\n+            return;\n+        }\n+    }\n+\n+    // Number of positions in the last, partial block.\n+    int32_t rest = limit & UCPTRIE_SMALL_DATA_MASK;\n+\n+    // Round down limit to a block boundary.\n+    limit &= ~UCPTRIE_SMALL_DATA_MASK;\n+\n+    // Iterate over all-value blocks.\n+    while (start < limit) {\n+        int32_t i = start >> UCPTRIE_SHIFT_3;\n+        if (flags[i] == ALL_SAME) {\n+            index[i] = value;\n+        } else /* MIXED */ {\n+            fillBlock(data + index[i], 0, UCPTRIE_SMALL_DATA_BLOCK_LENGTH, value);\n+        }\n+        start += UCPTRIE_SMALL_DATA_BLOCK_LENGTH;\n+    }\n+\n+    if (rest > 0) {\n+        // Set partial block at [last block boundary..limit[.\n+        int32_t block = getDataBlock(start >> UCPTRIE_SHIFT_3);\n+        if (block < 0) {\n+            errorCode = U_MEMORY_ALLOCATION_ERROR;\n+            return;\n+        }\n+\n+        fillBlock(data + block, 0, rest, value);\n+    }\n+}\n+\n+/* compaction --------------------------------------------------------------- */\n+\n+void MutableCodePointTrie::maskValues(uint32_t mask) {\n+    initialValue &= mask;\n+    errorValue &= mask;\n+    highValue &= mask;\n+    int32_t iLimit = highStart >> UCPTRIE_SHIFT_3;\n+    for (int32_t i = 0; i < iLimit; ++i) {\n+        if (flags[i] == ALL_SAME) {\n+            index[i] &= mask;\n+        }\n+    }\n+    for (int32_t i = 0; i < dataLength; ++i) {\n+        data[i] &= mask;\n+    }\n+}\n+\n+inline bool\n+equalBlocks(const uint32_t *s, const uint32_t *t, int32_t length) {\n+    while (length > 0 && *s == *t) {\n+        ++s;\n+        ++t;\n+        --length;\n+    }\n+    return length == 0;\n+}\n+\n+inline bool\n+equalBlocks(const uint16_t *s, const uint32_t *t, int32_t length) {\n+    while (length > 0 && *s == *t) {\n+        ++s;\n+        ++t;\n+        --length;\n+    }\n+    return length == 0;\n+}\n+\n+inline bool\n+equalBlocks(const uint16_t *s, const uint16_t *t, int32_t length) {\n+    while (length > 0 && *s == *t) {\n+        ++s;\n+        ++t;\n+        --length;\n+    }\n+    return length == 0;\n+}\n+\n+bool allValuesSameAs(const uint32_t *p, int32_t length, uint32_t value) {\n+    const uint32_t *pLimit = p + length;\n+    while (p < pLimit && *p == value) { ++p; }\n+    return p == pLimit;\n+}\n+\n+/** Search for an identical block. */\n+int32_t findSameBlock(const uint32_t *p, int32_t pStart, int32_t length,\n+                      const uint32_t *q, int32_t qStart, int32_t blockLength) {\n+    // Ensure that we do not even partially get past length.\n+    length -= blockLength;\n+\n+    q += qStart;\n+    while (pStart <= length) {\n+        if (equalBlocks(p + pStart, q, blockLength)) {\n+            return pStart;\n+        }\n+        ++pStart;\n+    }\n+    return -1;\n+}\n+\n+int32_t findSameBlock(const uint16_t *p, int32_t pStart, int32_t length,\n+                      const uint32_t *q, int32_t qStart, int32_t blockLength) {\n+    // Ensure that we do not even partially get past length.\n+    length -= blockLength;\n+\n+    q += qStart;\n+    while (pStart <= length) {\n+        if (equalBlocks(p + pStart, q, blockLength)) {\n+            return pStart;\n+        }\n+        ++pStart;\n+    }\n+    return -1;\n+}\n+\n+int32_t findSameBlock(const uint16_t *p, int32_t pStart, int32_t length,\n+                      const uint16_t *q, int32_t qStart, int32_t blockLength) {\n+    // Ensure that we do not even partially get past length.\n+    length -= blockLength;\n+\n+    q += qStart;\n+    while (pStart <= length) {\n+        if (equalBlocks(p + pStart, q, blockLength)) {\n+            return pStart;\n+        }\n+        ++pStart;\n+    }\n+    return -1;\n+}\n+\n+int32_t findAllSameBlock(const uint32_t *p, int32_t start, int32_t limit,\n+                         uint32_t value, int32_t blockLength) {\n+    // Ensure that we do not even partially get past limit.\n+    limit -= blockLength;\n+\n+    for (int32_t block = start; block <= limit; ++block) {\n+        if (p[block] == value) {\n+            for (int32_t i = 1;; ++i) {\n+                if (i == blockLength) {\n+                    return block;\n+                }\n+                if (p[block + i] != value) {\n+                    block += i;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    return -1;\n+}\n+\n+/**\n+ * Look for maximum overlap of the beginning of the other block\n+ * with the previous, adjacent block.\n+ */\n+int32_t getOverlap(const uint32_t *p, int32_t length,\n+                   const uint32_t *q, int32_t qStart, int32_t blockLength) {\n+    int32_t overlap = blockLength - 1;\n+    U_ASSERT(overlap <= length);\n+    q += qStart;\n+    while (overlap > 0 && !equalBlocks(p + (length - overlap), q, overlap)) {\n+        --overlap;\n+    }\n+    return overlap;\n+}\n+\n+int32_t getOverlap(const uint16_t *p, int32_t length,\n+                   const uint32_t *q, int32_t qStart, int32_t blockLength) {\n+    int32_t overlap = blockLength - 1;\n+    U_ASSERT(overlap <= length);\n+    q += qStart;\n+    while (overlap > 0 && !equalBlocks(p + (length - overlap), q, overlap)) {\n+        --overlap;\n+    }\n+    return overlap;\n+}\n+\n+int32_t getOverlap(const uint16_t *p, int32_t length,\n+                   const uint16_t *q, int32_t qStart, int32_t blockLength) {\n+    int32_t overlap = blockLength - 1;\n+    U_ASSERT(overlap <= length);\n+    q += qStart;\n+    while (overlap > 0 && !equalBlocks(p + (length - overlap), q, overlap)) {\n+        --overlap;\n+    }\n+    return overlap;\n+}\n+\n+int32_t getAllSameOverlap(const uint32_t *p, int32_t length, uint32_t value,\n+                          int32_t blockLength) {\n+    int32_t min = length - (blockLength - 1);\n+    int32_t i = length;\n+    while (min < i && p[i - 1] == value) { --i; }\n+    return length - i;\n+}\n+\n+bool isStartOfSomeFastBlock(uint32_t dataOffset, const uint32_t index[], int32_t fastILimit) {\n+    for (int32_t i = 0; i < fastILimit; i += SMALL_DATA_BLOCKS_PER_BMP_BLOCK) {\n+        if (index[i] == dataOffset) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+/**\n+ * Finds the start of the last range in the trie by enumerating backward.\n+ * Indexes for code points higher than this will be omitted.\n+ */\n+UChar32 MutableCodePointTrie::findHighStart() const {\n+    int32_t i = highStart >> UCPTRIE_SHIFT_3;\n+    while (i > 0) {\n+        bool match;\n+        if (flags[--i] == ALL_SAME) {\n+            match = index[i] == highValue;\n+        } else /* MIXED */ {\n+            const uint32_t *p = data + index[i];\n+            for (int32_t j = 0;; ++j) {\n+                if (j == UCPTRIE_SMALL_DATA_BLOCK_LENGTH) {\n+                    match = true;\n+                    break;\n+                }\n+                if (p[j] != highValue) {\n+                    match = false;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!match) {\n+            return (i + 1) << UCPTRIE_SHIFT_3;\n+        }\n+    }\n+    return 0;\n+}\n+\n+class AllSameBlocks {\n+public:\n+    static constexpr int32_t NEW_UNIQUE = -1;\n+    static constexpr int32_t OVERFLOW = -2;\n+\n+    AllSameBlocks() : length(0), mostRecent(-1) {}\n+\n+    int32_t findOrAdd(int32_t index, int32_t count, uint32_t value) {\n+        if (mostRecent >= 0 && values[mostRecent] == value) {\n+            refCounts[mostRecent] += count;\n+            return indexes[mostRecent];\n+        }\n+        for (int32_t i = 0; i < length; ++i) {\n+            if (values[i] == value) {\n+                mostRecent = i;\n+                refCounts[i] += count;\n+                return indexes[i];\n+            }\n+        }\n+        if (length == CAPACITY) {\n+            return OVERFLOW;\n+        }\n+        mostRecent = length;\n+        indexes[length] = index;\n+        values[length] = value;\n+        refCounts[length++] = count;\n+        return NEW_UNIQUE;\n+    }\n+\n+    /** Replaces the block which has the lowest reference count. */\n+    void add(int32_t index, int32_t count, uint32_t value) {\n+        U_ASSERT(length == CAPACITY);\n+        int32_t least = -1;\n+        int32_t leastCount = I_LIMIT;\n+        for (int32_t i = 0; i < length; ++i) {\n+            U_ASSERT(values[i] != value);\n+            if (refCounts[i] < leastCount) {\n+                least = i;\n+                leastCount = refCounts[i];\n+            }\n+        }\n+        U_ASSERT(least >= 0);\n+        mostRecent = least;\n+        indexes[least] = index;\n+        values[least] = value;\n+        refCounts[least] = count;\n+    }\n+\n+    int32_t findMostUsed() const {\n+        if (length == 0) { return -1; }\n+        int32_t max = -1;\n+        int32_t maxCount = 0;\n+        for (int32_t i = 0; i < length; ++i) {\n+            if (refCounts[i] > maxCount) {\n+                max = i;\n+                maxCount = refCounts[i];\n+            }\n+        }\n+        return indexes[max];\n+    }\n+\n+private:\n+    static constexpr int32_t CAPACITY = 32;\n+\n+    int32_t length;\n+    int32_t mostRecent;\n+\n+    int32_t indexes[CAPACITY];\n+    uint32_t values[CAPACITY];\n+    int32_t refCounts[CAPACITY];\n+};\n+\n+int32_t MutableCodePointTrie::compactWholeDataBlocks(int32_t fastILimit, AllSameBlocks &allSameBlocks) {\n+#ifdef UCPTRIE_DEBUG\n+    bool overflow = false;\n+#endif\n+\n+    // ASCII data will be stored as a linear table, even if the following code\n+    // does not yet count it that way.\n+    int32_t newDataCapacity = ASCII_LIMIT;\n+    // Add room for a small data null block in case it would match the start of\n+    // a fast data block where dataNullOffset must not be set in that case.\n+    newDataCapacity += UCPTRIE_SMALL_DATA_BLOCK_LENGTH;\n+    // Add room for special values (errorValue, highValue) and padding.\n+    newDataCapacity += 4;\n+    int32_t iLimit = highStart >> UCPTRIE_SHIFT_3;\n+    int32_t blockLength = UCPTRIE_FAST_DATA_BLOCK_LENGTH;\n+    int32_t inc = SMALL_DATA_BLOCKS_PER_BMP_BLOCK;\n+    for (int32_t i = 0; i < iLimit; i += inc) {\n+        if (i == fastILimit) {\n+            blockLength = UCPTRIE_SMALL_DATA_BLOCK_LENGTH;\n+            inc = 1;\n+        }\n+        uint32_t value = index[i];\n+        if (flags[i] == MIXED) {\n+            // Really mixed?\n+            const uint32_t *p = data + value;\n+            value = *p;\n+            if (allValuesSameAs(p + 1, blockLength - 1, value)) {\n+                flags[i] = ALL_SAME;\n+                index[i] = value;\n+                // Fall through to ALL_SAME handling.\n+            } else {\n+                newDataCapacity += blockLength;\n+                continue;\n+            }\n+        } else {\n+            U_ASSERT(flags[i] == ALL_SAME);\n+            if (inc > 1) {\n+                // Do all of the fast-range data block's ALL_SAME parts have the same value?\n+                bool allSame = true;\n+                int32_t next_i = i + inc;\n+                for (int32_t j = i + 1; j < next_i; ++j) {\n+                    U_ASSERT(flags[j] == ALL_SAME);\n+                    if (index[j] != value) {\n+                        allSame = false;\n+                        break;\n+                    }\n+                }\n+                if (!allSame) {\n+                    // Turn it into a MIXED block.\n+                    if (getDataBlock(i) < 0) {\n+                        return -1;\n+                    }\n+                    newDataCapacity += blockLength;\n+                    continue;\n+                }\n+            }\n+        }\n+        // Is there another ALL_SAME block with the same value?\n+        int32_t other = allSameBlocks.findOrAdd(i, inc, value);\n+        if (other == AllSameBlocks::OVERFLOW) {\n+            // The fixed-size array overflowed. Slow check for a duplicate block.\n+#ifdef UCPTRIE_DEBUG\n+            if (!overflow) {\n+                puts(\"UCPTrie AllSameBlocks overflow\");\n+                overflow = true;\n+            }\n+#endif\n+            int32_t jInc = SMALL_DATA_BLOCKS_PER_BMP_BLOCK;\n+            for (int32_t j = 0;; j += jInc) {\n+                if (j == i) {\n+                    allSameBlocks.add(i, inc, value);\n+                    break;\n+                }\n+                if (j == fastILimit) {\n+                    jInc = 1;\n+                }\n+                if (flags[j] == ALL_SAME && index[j] == value) {\n+                    allSameBlocks.add(j, jInc + inc, value);\n+                    other = j;\n+                    break;\n+                    // We could keep counting blocks with the same value\n+                    // before we add the first one, which may improve compaction in rare cases,\n+                    // but it would make it slower.\n+                }\n+            }\n+        }\n+        if (other >= 0) {\n+            flags[i] = SAME_AS;\n+            index[i] = other;\n+        } else {\n+            // New unique same-value block.\n+            newDataCapacity += blockLength;\n+        }\n+    }\n+    return newDataCapacity;\n+}\n+\n+#ifdef UCPTRIE_DEBUG\n+#   define DEBUG_DO(expr) expr\n+#else\n+#   define DEBUG_DO(expr)\n+#endif\n+\n+#ifdef UCPTRIE_DEBUG\n+// Braille symbols: U+28xx = UTF-8 E2 A0 80..E2 A3 BF\n+int32_t appendValue(char s[], int32_t length, uint32_t value) {\n+    value ^= value >> 16;\n+    value ^= value >> 8;\n+    s[length] = 0xE2;\n+    s[length + 1] = (char)(0xA0 + ((value >> 6) & 3));\n+    s[length + 2] = (char)(0x80 + (value & 0x3F));\n+    return length + 3;\n+}\n+\n+void printBlock(const uint32_t *block, int32_t blockLength, uint32_t value,\n+                UChar32 start, int32_t overlap, uint32_t initialValue) {\n+    char s[UCPTRIE_FAST_DATA_BLOCK_LENGTH * 3 + 3];\n+    int32_t length = 0;\n+    int32_t i;\n+    for (i = 0; i < overlap; ++i) {\n+        length = appendValue(s, length, 0);  // Braille blank\n+    }\n+    s[length++] = '|';\n+    for (; i < blockLength; ++i) {\n+        if (block != nullptr) {\n+            value = block[i];\n+        }\n+        if (value == initialValue) {\n+            value = 0x40;  // Braille lower left dot\n+        }\n+        length = appendValue(s, length, value);\n+    }\n+    s[length] = 0;\n+    start += overlap;\n+    if (start <= 0xffff) {\n+        printf(\"    %04lX  %s|\\n\", (long)start, s);\n+    } else if (start <= 0xfffff) {\n+        printf(\"   %5lX  %s|\\n\", (long)start, s);\n+    } else {\n+        printf(\"  %6lX  %s|\\n\", (long)start, s);\n+    }\n+}\n+#endif\n+\n+/**\n+ * Compacts a build-time trie.\n+ *\n+ * The compaction\n+ * - removes blocks that are identical with earlier ones\n+ * - overlaps each new non-duplicate block as much as possible with the previously-written one\n+ * - works with fast-range data blocks whose length is a multiple of that of\n+ *   higher-code-point data blocks\n+ *\n+ * It does not try to find an optimal order of writing, deduplicating, and overlapping blocks.\n+ */\n+int32_t MutableCodePointTrie::compactData(int32_t fastILimit,\n+                                          uint32_t *newData, int32_t dataNullIndex) {\n+#ifdef UCPTRIE_DEBUG\n+    int32_t countSame=0, sumOverlaps=0;\n+    bool printData = dataLength == 29088 /* line.brk */ ||\n+        // dataLength == 30048 /* CanonIterData */ ||\n+        dataLength == 50400 /* zh.txt~stroke */;\n+#endif\n+\n+    // The linear ASCII data has been copied into newData already.\n+    int32_t newDataLength = 0;\n+    for (int32_t i = 0; newDataLength < ASCII_LIMIT;\n+            newDataLength += UCPTRIE_FAST_DATA_BLOCK_LENGTH, i += SMALL_DATA_BLOCKS_PER_BMP_BLOCK) {\n+        index[i] = newDataLength;\n+#ifdef UCPTRIE_DEBUG\n+        if (printData) {\n+            printBlock(newData + newDataLength, UCPTRIE_FAST_DATA_BLOCK_LENGTH, 0, newDataLength, 0, initialValue);\n+        }\n+#endif\n+    }\n+\n+    int32_t iLimit = highStart >> UCPTRIE_SHIFT_3;\n+    int32_t blockLength = UCPTRIE_FAST_DATA_BLOCK_LENGTH;\n+    int32_t inc = SMALL_DATA_BLOCKS_PER_BMP_BLOCK;\n+    int32_t fastLength = 0;\n+    for (int32_t i = ASCII_I_LIMIT; i < iLimit; i += inc) {\n+        if (i == fastILimit) {\n+            blockLength = UCPTRIE_SMALL_DATA_BLOCK_LENGTH;\n+            inc = 1;\n+            fastLength = newDataLength;\n+        }\n+        if (flags[i] == ALL_SAME) {\n+            uint32_t value = index[i];\n+            int32_t n;\n+            // Find an earlier part of the data array of length blockLength\n+            // that is filled with this value.\n+            // If we find a match, and the current block is the data null block,\n+            // and it is not a fast block but matches the start of a fast block,\n+            // then we need to continue looking.\n+            // This is because this small block is shorter than the fast block,\n+            // and not all of the rest of the fast block is filled with this value.\n+            // Otherwise trie.getRange() would detect that the fast block starts at\n+            // dataNullOffset and assume incorrectly that it is filled with the null value.\n+            for (int32_t start = 0;\n+                    (n = findAllSameBlock(newData, start, newDataLength,\n+                                value, blockLength)) >= 0 &&\n+                            i == dataNullIndex && i >= fastILimit && n < fastLength &&\n+                            isStartOfSomeFastBlock(n, index, fastILimit);\n+                    start = n + 1) {}\n+            if (n >= 0) {\n+                DEBUG_DO(++countSame);\n+                index[i] = n;\n+            } else {\n+                n = getAllSameOverlap(newData, newDataLength, value, blockLength);\n+                DEBUG_DO(sumOverlaps += n);\n+#ifdef UCPTRIE_DEBUG\n+                if (printData) {\n+                    printBlock(nullptr, blockLength, value, i << UCPTRIE_SHIFT_3, n, initialValue);\n+                }\n+#endif\n+                index[i] = newDataLength - n;\n+                while (n < blockLength) {\n+                    newData[newDataLength++] = value;\n+                    ++n;\n+                }\n+            }\n+        } else if (flags[i] == MIXED) {\n+            const uint32_t *block = data + index[i];\n+            int32_t n = findSameBlock(newData, 0, newDataLength, block, 0, blockLength);\n+            if (n >= 0) {\n+                DEBUG_DO(++countSame);\n+                index[i] = n;\n+            } else {\n+                n = getOverlap(newData, newDataLength, block, 0, blockLength);\n+                DEBUG_DO(sumOverlaps += n);\n+#ifdef UCPTRIE_DEBUG\n+                if (printData) {\n+                    printBlock(block, blockLength, 0, i << UCPTRIE_SHIFT_3, n, initialValue);\n+                }\n+#endif\n+                index[i] = newDataLength - n;\n+                while (n < blockLength) {\n+                    newData[newDataLength++] = block[n++];\n+                }\n+            }\n+        } else /* SAME_AS */ {\n+            uint32_t j = index[i];\n+            index[i] = index[j];\n+        }\n+    }\n+\n+#ifdef UCPTRIE_DEBUG\n+    /* we saved some space */\n+    printf(\"compacting UCPTrie: count of 32-bit data words %lu->%lu  countSame=%ld  sumOverlaps=%ld\\n\",\n+            (long)dataLength, (long)newDataLength, (long)countSame, (long)sumOverlaps);\n+#endif\n+    return newDataLength;\n+}\n+\n+int32_t MutableCodePointTrie::compactIndex(int32_t fastILimit, UErrorCode &errorCode) {\n+    int32_t fastIndexLength = fastILimit >> (UCPTRIE_FAST_SHIFT - UCPTRIE_SHIFT_3);\n+    if ((highStart >> UCPTRIE_FAST_SHIFT) <= fastIndexLength) {\n+        // Only the linear fast index, no multi-stage index tables.\n+        index3NullOffset = UCPTRIE_NO_INDEX3_NULL_OFFSET;\n+        return fastIndexLength;\n+    }\n+\n+    // Condense the fast index table.\n+    // Also, does it contain an index-3 block with all dataNullOffset?\n+    uint16_t fastIndex[UCPTRIE_BMP_INDEX_LENGTH];  // fastIndexLength\n+    int32_t i3FirstNull = -1;\n+    for (int32_t i = 0, j = 0; i < fastILimit; ++j) {\n+        uint32_t i3 = index[i];\n+        fastIndex[j] = (uint16_t)i3;\n+        if (i3 == (uint32_t)dataNullOffset) {\n+            if (i3FirstNull < 0) {\n+                i3FirstNull = j;\n+            } else if (index3NullOffset < 0 &&\n+                    (j - i3FirstNull + 1) == UCPTRIE_INDEX_3_BLOCK_LENGTH) {\n+                index3NullOffset = i3FirstNull;\n+            }\n+        } else {\n+            i3FirstNull = -1;\n+        }\n+        // Set the index entries that compactData() skipped.\n+        // Needed when the multi-stage index covers the fast index range as well.\n+        int32_t iNext = i + SMALL_DATA_BLOCKS_PER_BMP_BLOCK;\n+        while (++i < iNext) {\n+            i3 += UCPTRIE_SMALL_DATA_BLOCK_LENGTH;\n+            index[i] = i3;\n+        }\n+    }\n+\n+    // Examine index-3 blocks. For each determine one of:\n+    // - same as the index-3 null block\n+    // - same as a fast-index block\n+    // - 16-bit indexes\n+    // - 18-bit indexes\n+    // We store this in the first flags entry for the index-3 block.\n+    //\n+    // Also determine an upper limit for the index-3 table length.\n+    int32_t index3Capacity = 0;\n+    i3FirstNull = index3NullOffset;\n+    // If the fast index covers the whole BMP, then\n+    // the multi-stage index is only for supplementary code points.\n+    // Otherwise, the multi-stage index covers all of Unicode.\n+    int32_t iStart = fastILimit < BMP_I_LIMIT ? 0 : BMP_I_LIMIT;\n+    int32_t iLimit = highStart >> UCPTRIE_SHIFT_3;\n+    for (int32_t i = iStart; i < iLimit;) {\n+        int32_t j = i;\n+        int32_t jLimit = i + UCPTRIE_INDEX_3_BLOCK_LENGTH;\n+        uint32_t oredI3 = 0;\n+        bool isNull = true;\n+        do {\n+            uint32_t i3 = index[j];\n+            oredI3 |= i3;\n+            if (i3 != (uint32_t)dataNullOffset) {\n+                isNull = false;\n+            }\n+        } while (++j < jLimit);\n+        if (isNull) {\n+            flags[i] = I3_NULL;\n+            if (i3FirstNull < 0) {\n+                if (oredI3 <= 0xffff) {\n+                    index3Capacity += UCPTRIE_INDEX_3_BLOCK_LENGTH;\n+                } else {\n+                    index3Capacity += INDEX_3_18BIT_BLOCK_LENGTH;\n+                }\n+                i3FirstNull = 0;\n+            }\n+        } else {\n+            if (oredI3 <= 0xffff) {\n+                int32_t n = findSameBlock(fastIndex, 0, fastIndexLength,\n+                                          index, i, UCPTRIE_INDEX_3_BLOCK_LENGTH);\n+                if (n >= 0) {\n+                    flags[i] = I3_BMP;\n+                    index[i] = n;\n+                } else {\n+                    flags[i] = I3_16;\n+                    index3Capacity += UCPTRIE_INDEX_3_BLOCK_LENGTH;\n+                }\n+            } else {\n+                flags[i] = I3_18;\n+                index3Capacity += INDEX_3_18BIT_BLOCK_LENGTH;\n+            }\n+        }\n+        i = j;\n+    }\n+\n+    int32_t index2Capacity = (iLimit - iStart) >> UCPTRIE_SHIFT_2_3;\n+\n+    // Length of the index-1 table, rounded up.\n+    int32_t index1Length = (index2Capacity + UCPTRIE_INDEX_2_MASK) >> UCPTRIE_SHIFT_1_2;\n+\n+    // Index table: Fast index, index-1, index-3, index-2.\n+    // +1 for possible index table padding.\n+    int32_t index16Capacity = fastIndexLength + index1Length + index3Capacity + index2Capacity + 1;\n+    index16 = (uint16_t *)uprv_malloc(index16Capacity * 2);\n+    if (index16 == nullptr) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return 0;\n+    }\n+    uprv_memcpy(index16, fastIndex, fastIndexLength * 2);\n+\n+    // Compact the index-3 table and write an uncompacted version of the index-2 table.\n+    uint16_t index2[UNICODE_LIMIT >> UCPTRIE_SHIFT_2];  // index2Capacity\n+    int32_t i2Length = 0;\n+    i3FirstNull = index3NullOffset;\n+    int32_t index3Start = fastIndexLength + index1Length;\n+    int32_t indexLength = index3Start;\n+    for (int32_t i = iStart; i < iLimit; i += UCPTRIE_INDEX_3_BLOCK_LENGTH) {\n+        int32_t i3;\n+        uint8_t f = flags[i];\n+        if (f == I3_NULL && i3FirstNull < 0) {\n+            // First index-3 null block. Write & overlap it like a normal block, then remember it.\n+            f = dataNullOffset <= 0xffff ? I3_16 : I3_18;\n+            i3FirstNull = 0;\n+        }\n+        if (f == I3_NULL) {\n+            i3 = index3NullOffset;\n+        } else if (f == I3_BMP) {\n+            i3 = index[i];\n+        } else if (f == I3_16) {\n+            int32_t n = findSameBlock(index16, index3Start, indexLength,\n+                                      index, i, UCPTRIE_INDEX_3_BLOCK_LENGTH);\n+            if (n >= 0) {\n+                i3 = n;\n+            } else {\n+                if (indexLength == index3Start) {\n+                    // No overlap at the boundary between the index-1 and index-3 tables.\n+                    n = 0;\n+                } else {\n+                    n = getOverlap(index16, indexLength,\n+                                   index, i, UCPTRIE_INDEX_3_BLOCK_LENGTH);\n+                }\n+                i3 = indexLength - n;\n+                while (n < UCPTRIE_INDEX_3_BLOCK_LENGTH) {\n+                    index16[indexLength++] = index[i + n++];\n+                }\n+            }\n+        } else {\n+            U_ASSERT(f == I3_18);\n+            // Encode an index-3 block that contains one or more data indexes exceeding 16 bits.\n+            int32_t j = i;\n+            int32_t jLimit = i + UCPTRIE_INDEX_3_BLOCK_LENGTH;\n+            int32_t k = indexLength;\n+            do {\n+                ++k;\n+                uint32_t v = index[j++];\n+                uint32_t upperBits = (v & 0x30000) >> 2;\n+                index16[k++] = v;\n+                v = index[j++];\n+                upperBits |= (v & 0x30000) >> 4;\n+                index16[k++] = v;\n+                v = index[j++];\n+                upperBits |= (v & 0x30000) >> 6;\n+                index16[k++] = v;\n+                v = index[j++];\n+                upperBits |= (v & 0x30000) >> 8;\n+                index16[k++] = v;\n+                v = index[j++];\n+                upperBits |= (v & 0x30000) >> 10;\n+                index16[k++] = v;\n+                v = index[j++];\n+                upperBits |= (v & 0x30000) >> 12;\n+                index16[k++] = v;\n+                v = index[j++];\n+                upperBits |= (v & 0x30000) >> 14;\n+                index16[k++] = v;\n+                v = index[j++];\n+                upperBits |= (v & 0x30000) >> 16;\n+                index16[k++] = v;\n+                index16[k - 9] = upperBits;\n+            } while (j < jLimit);\n+            int32_t n = findSameBlock(index16, index3Start, indexLength,\n+                                      index16, indexLength, INDEX_3_18BIT_BLOCK_LENGTH);\n+            if (n >= 0) {\n+                i3 = n | 0x8000;\n+            } else {\n+                if (indexLength == index3Start) {\n+                    // No overlap at the boundary between the index-1 and index-3 tables.\n+                    n = 0;\n+                } else {\n+                    n = getOverlap(index16, indexLength,\n+                                   index16, indexLength, INDEX_3_18BIT_BLOCK_LENGTH);\n+                }\n+                i3 = (indexLength - n) | 0x8000;\n+                if (n > 0) {\n+                    int32_t start = indexLength;\n+                    while (n < INDEX_3_18BIT_BLOCK_LENGTH) {\n+                        index16[indexLength++] = index16[start + n++];\n+                    }\n+                } else {\n+                    indexLength += INDEX_3_18BIT_BLOCK_LENGTH;\n+                }\n+            }\n+        }\n+        if (index3NullOffset < 0 && i3FirstNull >= 0) {\n+            index3NullOffset = i3;\n+        }\n+        // Set the index-2 table entry.\n+        index2[i2Length++] = i3;\n+    }\n+    U_ASSERT(i2Length == index2Capacity);\n+    U_ASSERT(indexLength <= index3Start + index3Capacity);\n+\n+    if (index3NullOffset < 0) {\n+        index3NullOffset = UCPTRIE_NO_INDEX3_NULL_OFFSET;\n+    }\n+    if (indexLength >= (UCPTRIE_NO_INDEX3_NULL_OFFSET + UCPTRIE_INDEX_3_BLOCK_LENGTH)) {\n+        // The index-3 offsets exceed 15 bits, or\n+        // the last one cannot be distinguished from the no-null-block value.\n+        errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n+        return 0;\n+    }\n+\n+    // Compact the index-2 table and write the index-1 table.\n+    int32_t blockLength = UCPTRIE_INDEX_2_BLOCK_LENGTH;\n+    int32_t i1 = fastIndexLength;\n+    for (int32_t i = 0; i < i2Length; i += blockLength) {\n+        if ((i2Length - i) < blockLength) {\n+            // highStart is inside the last index-2 block. Shorten it.\n+            blockLength = i2Length - i;\n+        }\n+        int32_t i2;\n+        int32_t n = findSameBlock(index16, index3Start, indexLength,\n+                                  index2, i, blockLength);\n+        if (n >= 0) {\n+            i2 = n;\n+        } else {\n+            if (indexLength == index3Start) {\n+                // No overlap at the boundary between the index-1 and index-3/2 tables.\n+                n = 0;\n+            } else {\n+                n = getOverlap(index16, indexLength, index2, i, blockLength);\n+            }\n+            i2 = indexLength - n;\n+            while (n < blockLength) {\n+                index16[indexLength++] = index2[i + n++];\n+            }\n+        }\n+        // Set the index-1 table entry.\n+        index16[i1++] = i2;\n+    }\n+    U_ASSERT(i1 == index3Start);\n+    U_ASSERT(indexLength <= index16Capacity);\n+\n+#ifdef UCPTRIE_DEBUG\n+    /* we saved some space */\n+    printf(\"compacting UCPTrie: count of 16-bit index words %lu->%lu\\n\",\n+            (long)iLimit, (long)indexLength);\n+#endif\n+\n+    return indexLength;\n+}\n+\n+int32_t MutableCodePointTrie::compactTrie(int32_t fastILimit, UErrorCode &errorCode) {\n+    // Find the real highStart and round it up.\n+    U_ASSERT((highStart & (UCPTRIE_CP_PER_INDEX_2_ENTRY - 1)) == 0);\n+    highValue = get(MAX_UNICODE);\n+    int32_t realHighStart = findHighStart();\n+    realHighStart = (realHighStart + (UCPTRIE_CP_PER_INDEX_2_ENTRY - 1)) &\n+        ~(UCPTRIE_CP_PER_INDEX_2_ENTRY - 1);\n+    if (realHighStart == UNICODE_LIMIT) {\n+        highValue = initialValue;\n+    }\n+\n+#ifdef UCPTRIE_DEBUG\n+    printf(\"UCPTrie: highStart U+%06lx  highValue 0x%lx  initialValue 0x%lx\\n\",\n+            (long)realHighStart, (long)highValue, (long)initialValue);\n+#endif\n+\n+    // We always store indexes and data values for the fast range.\n+    // Pin highStart to the top of that range while building.\n+    UChar32 fastLimit = fastILimit << UCPTRIE_SHIFT_3;\n+    if (realHighStart < fastLimit) {\n+        for (int32_t i = (realHighStart >> UCPTRIE_SHIFT_3); i < fastILimit; ++i) {\n+            flags[i] = ALL_SAME;\n+            index[i] = highValue;\n+        }\n+        highStart = fastLimit;\n+    } else {\n+        highStart = realHighStart;\n+    }\n+\n+    uint32_t asciiData[ASCII_LIMIT];\n+    for (int32_t i = 0; i < ASCII_LIMIT; ++i) {\n+        asciiData[i] = get(i);\n+    }\n+\n+    // First we look for which data blocks have the same value repeated over the whole block,\n+    // deduplicate such blocks, find a good null data block (for faster enumeration),\n+    // and get an upper bound for the necessary data array length.\n+    AllSameBlocks allSameBlocks;\n+    int32_t newDataCapacity = compactWholeDataBlocks(fastILimit, allSameBlocks);\n+    if (newDataCapacity < 0) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return 0;\n+    }\n+    uint32_t *newData = (uint32_t *)uprv_malloc(newDataCapacity * 4);\n+    if (newData == nullptr) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        return 0;\n+    }\n+    uprv_memcpy(newData, asciiData, sizeof(asciiData));\n+\n+    int32_t dataNullIndex = allSameBlocks.findMostUsed();\n+    int32_t newDataLength = compactData(fastILimit, newData, dataNullIndex);\n+    U_ASSERT(newDataLength <= newDataCapacity);\n+    uprv_free(data);\n+    data = newData;\n+    dataCapacity = newDataCapacity;\n+    dataLength = newDataLength;\n+    if (dataLength > (0x3ffff + UCPTRIE_SMALL_DATA_BLOCK_LENGTH)) {\n+        // The offset of the last data block is too high to be stored in the index table.\n+        errorCode = U_INDEX_OUTOFBOUNDS_ERROR;\n+        return 0;\n+    }\n+\n+    if (dataNullIndex >= 0) {\n+        dataNullOffset = index[dataNullIndex];\n+#ifdef UCPTRIE_DEBUG\n+        if (data[dataNullOffset] != initialValue) {\n+            printf(\"UCPTrie initialValue %lx -> more common nullValue %lx\\n\",\n+                   (long)initialValue, (long)data[dataNullOffset]);\n+        }\n+#endif\n+        initialValue = data[dataNullOffset];\n+    } else {\n+        dataNullOffset = UCPTRIE_NO_DATA_NULL_OFFSET;\n+    }\n+\n+    int32_t indexLength = compactIndex(fastILimit, errorCode);\n+    highStart = realHighStart;\n+    return indexLength;\n+}\n+\n+UCPTrie *MutableCodePointTrie::build(UCPTrieType type, UCPTrieValueWidth valueWidth, UErrorCode &errorCode) {\n+    if (U_FAILURE(errorCode)) {\n+        return nullptr;\n+    }\n+    if (type < UCPTRIE_TYPE_FAST || UCPTRIE_TYPE_SMALL < type ||\n+            valueWidth < UCPTRIE_VALUE_BITS_16 || UCPTRIE_VALUE_BITS_8 < valueWidth) {\n+        errorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return nullptr;\n+    }\n+\n+    // The mutable trie always stores 32-bit values.\n+    // When we build a UCPTrie for a smaller value width, we first mask off unused bits\n+    // before compacting the data.\n+    switch (valueWidth) {\n+    case UCPTRIE_VALUE_BITS_32:\n+        break;\n+    case UCPTRIE_VALUE_BITS_16:\n+        maskValues(0xffff);\n+        break;\n+    case UCPTRIE_VALUE_BITS_8:\n+        maskValues(0xff);\n+        break;\n+    default:\n+        break;\n+    }\n+\n+    UChar32 fastLimit = type == UCPTRIE_TYPE_FAST ? BMP_LIMIT : UCPTRIE_SMALL_LIMIT;\n+    int32_t indexLength = compactTrie(fastLimit >> UCPTRIE_SHIFT_3, errorCode);\n+    if (U_FAILURE(errorCode)) {\n+        clear();\n+        return nullptr;\n+    }\n+\n+    // Ensure data table alignment: The index length must be even for uint32_t data.\n+    if (valueWidth == UCPTRIE_VALUE_BITS_32 && (indexLength & 1) != 0) {\n+        index16[indexLength++] = 0xffee;  // arbitrary value\n+    }\n+\n+    // Make the total trie structure length a multiple of 4 bytes by padding the data table,\n+    // and store special values as the last two data values.\n+    int32_t length = indexLength * 2;\n+    if (valueWidth == UCPTRIE_VALUE_BITS_16) {\n+        if (((indexLength ^ dataLength) & 1) != 0) {\n+            // padding\n+            data[dataLength++] = errorValue;\n+        }\n+        if (data[dataLength - 1] != errorValue || data[dataLength - 2] != highValue) {\n+            data[dataLength++] = highValue;\n+            data[dataLength++] = errorValue;\n+        }\n+        length += dataLength * 2;\n+    } else if (valueWidth == UCPTRIE_VALUE_BITS_32) {\n+        // 32-bit data words never need padding to a multiple of 4 bytes.\n+        if (data[dataLength - 1] != errorValue || data[dataLength - 2] != highValue) {\n+            if (data[dataLength - 1] != highValue) {\n+                data[dataLength++] = highValue;\n+            }\n+            data[dataLength++] = errorValue;\n+        }\n+        length += dataLength * 4;\n+    } else {\n+        int32_t and3 = (length + dataLength) & 3;\n+        if (and3 == 0 && data[dataLength - 1] == errorValue && data[dataLength - 2] == highValue) {\n+            // all set\n+        } else if(and3 == 3 && data[dataLength - 1] == highValue) {\n+            data[dataLength++] = errorValue;\n+        } else {\n+            while (and3 != 2) {\n+                data[dataLength++] = highValue;\n+                and3 = (and3 + 1) & 3;\n+            }\n+            data[dataLength++] = highValue;\n+            data[dataLength++] = errorValue;\n+        }\n+        length += dataLength;\n+    }\n+\n+    // Calculate the total length of the UCPTrie as a single memory block.\n+    length += sizeof(UCPTrie);\n+    U_ASSERT((length & 3) == 0);\n+\n+    uint8_t *bytes = (uint8_t *)uprv_malloc(length);\n+    if (bytes == nullptr) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+        clear();\n+        return nullptr;\n+    }\n+    UCPTrie *trie = reinterpret_cast<UCPTrie *>(bytes);\n+    uprv_memset(trie, 0, sizeof(UCPTrie));\n+    trie->indexLength = indexLength;\n+    trie->dataLength = dataLength;\n+\n+    trie->highStart = highStart;\n+    // Round up shifted12HighStart to a multiple of 0x1000 for easy testing from UTF-8 lead bytes.\n+    // Runtime code needs to then test for the real highStart as well.\n+    trie->shifted12HighStart = (highStart + 0xfff) >> 12;\n+    trie->type = type;\n+    trie->valueWidth = valueWidth;\n+\n+    trie->index3NullOffset = index3NullOffset;\n+    trie->dataNullOffset = dataNullOffset;\n+    trie->nullValue = initialValue;\n+\n+    bytes += sizeof(UCPTrie);\n+\n+    // Fill the index and data arrays.\n+    uint16_t *dest16 = (uint16_t *)bytes;\n+    trie->index = dest16;\n+\n+    if (highStart <= fastLimit) {\n+        // Condense only the fast index from the mutable-trie index.\n+        for (int32_t i = 0, j = 0; j < indexLength; i += SMALL_DATA_BLOCKS_PER_BMP_BLOCK, ++j) {\n+            *dest16++ = (uint16_t)index[i];  // dest16[j]\n+        }\n+    } else {\n+        uprv_memcpy(dest16, index16, indexLength * 2);\n+        dest16 += indexLength;\n+    }\n+    bytes += indexLength * 2;\n+\n+    // Write the data array.\n+    const uint32_t *p = data;\n+    switch (valueWidth) {\n+    case UCPTRIE_VALUE_BITS_16:\n+        // Write 16-bit data values.\n+        trie->data.ptr16 = dest16;\n+        for (int32_t i = dataLength; i > 0; --i) {\n+            *dest16++ = (uint16_t)*p++;\n+        }\n+        break;\n+    case UCPTRIE_VALUE_BITS_32:\n+        // Write 32-bit data values.\n+        trie->data.ptr32 = (uint32_t *)bytes;\n+        uprv_memcpy(bytes, p, (size_t)dataLength * 4);\n+        break;\n+    case UCPTRIE_VALUE_BITS_8:\n+        // Write 8-bit data values.\n+        trie->data.ptr8 = bytes;\n+        for (int32_t i = dataLength; i > 0; --i) {\n+            *bytes++ = (uint8_t)*p++;\n+        }\n+        break;\n+    default:\n+        // Will not occur, valueWidth checked at the beginning.\n+        break;\n+    }\n+\n+#ifdef UCPTRIE_DEBUG\n+    trie->name = name;\n+\n+    ucptrie_printLengths(trie, \"\");\n+#endif\n+\n+    clear();\n+    return trie;\n+}\n+\n+}  // namespace\n+\n+U_NAMESPACE_END\n+\n+U_NAMESPACE_USE\n+\n+U_CAPI UMutableCPTrie * U_EXPORT2\n+umutablecptrie_open(uint32_t initialValue, uint32_t errorValue, UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) {\n+        return nullptr;\n+    }\n+    LocalPointer<MutableCodePointTrie> trie(\n+        new MutableCodePointTrie(initialValue, errorValue, *pErrorCode), *pErrorCode);\n+    if (U_FAILURE(*pErrorCode)) {\n+        return nullptr;\n+    }\n+    return reinterpret_cast<UMutableCPTrie *>(trie.orphan());\n+}\n+\n+U_CAPI UMutableCPTrie * U_EXPORT2\n+umutablecptrie_clone(const UMutableCPTrie *other, UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) {\n+        return nullptr;\n+    }\n+    if (other == nullptr) {\n+        return nullptr;\n+    }\n+    LocalPointer<MutableCodePointTrie> clone(\n+        new MutableCodePointTrie(*reinterpret_cast<const MutableCodePointTrie *>(other), *pErrorCode), *pErrorCode);\n+    if (U_FAILURE(*pErrorCode)) {\n+        return nullptr;\n+    }\n+    return reinterpret_cast<UMutableCPTrie *>(clone.orphan());\n+}\n+\n+U_CAPI void U_EXPORT2\n+umutablecptrie_close(UMutableCPTrie *trie) {\n+    delete reinterpret_cast<MutableCodePointTrie *>(trie);\n+}\n+\n+U_CAPI UMutableCPTrie * U_EXPORT2\n+umutablecptrie_fromUCPMap(const UCPMap *map, UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) {\n+        return nullptr;\n+    }\n+    if (map == nullptr) {\n+        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return nullptr;\n+    }\n+    return reinterpret_cast<UMutableCPTrie *>(MutableCodePointTrie::fromUCPMap(map, *pErrorCode));\n+}\n+\n+U_CAPI UMutableCPTrie * U_EXPORT2\n+umutablecptrie_fromUCPTrie(const UCPTrie *trie, UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) {\n+        return nullptr;\n+    }\n+    if (trie == nullptr) {\n+        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return nullptr;\n+    }\n+    return reinterpret_cast<UMutableCPTrie *>(MutableCodePointTrie::fromUCPTrie(trie, *pErrorCode));\n+}\n+\n+U_CAPI uint32_t U_EXPORT2\n+umutablecptrie_get(const UMutableCPTrie *trie, UChar32 c) {\n+    return reinterpret_cast<const MutableCodePointTrie *>(trie)->get(c);\n+}\n+\n+namespace {\n+\n+UChar32 getRange(const void *trie, UChar32 start,\n+                 UCPMapValueFilter *filter, const void *context, uint32_t *pValue) {\n+    return reinterpret_cast<const MutableCodePointTrie *>(trie)->\n+        getRange(start, filter, context, pValue);\n+}\n+\n+}  // namespace\n+\n+U_CAPI UChar32 U_EXPORT2\n+umutablecptrie_getRange(const UMutableCPTrie *trie, UChar32 start,\n+                        UCPMapRangeOption option, uint32_t surrogateValue,\n+                        UCPMapValueFilter *filter, const void *context, uint32_t *pValue) {\n+    return ucptrie_internalGetRange(getRange, trie, start,\n+                                    option, surrogateValue,\n+                                    filter, context, pValue);\n+}\n+\n+U_CAPI void U_EXPORT2\n+umutablecptrie_set(UMutableCPTrie *trie, UChar32 c, uint32_t value, UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) {\n+        return;\n+    }\n+    reinterpret_cast<MutableCodePointTrie *>(trie)->set(c, value, *pErrorCode);\n+}\n+\n+U_CAPI void U_EXPORT2\n+umutablecptrie_setRange(UMutableCPTrie *trie, UChar32 start, UChar32 end,\n+                   uint32_t value, UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) {\n+        return;\n+    }\n+    reinterpret_cast<MutableCodePointTrie *>(trie)->setRange(start, end, value, *pErrorCode);\n+}\n+\n+/* Compact and internally serialize the trie. */\n+U_CAPI UCPTrie * U_EXPORT2\n+umutablecptrie_buildImmutable(UMutableCPTrie *trie, UCPTrieType type, UCPTrieValueWidth valueWidth,\n+                              UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) {\n+        return nullptr;\n+    }\n+    return reinterpret_cast<MutableCodePointTrie *>(trie)->build(type, valueWidth, *pErrorCode);\n+}\n+\n+#ifdef UCPTRIE_DEBUG\n+U_CFUNC void umutablecptrie_setName(UMutableCPTrie *trie, const char *name) {\n+    reinterpret_cast<MutableCodePointTrie *>(trie)->name = name;\n+}\n+#endif"
        },
        {
            "sha": "37e49871049b9393632639c6d8eab10c909e36be",
            "filename": "deps/icu-small/source/common/umutex.h",
            "status": "modified",
            "additions": 11,
            "deletions": 4,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fumutex.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fumutex.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fumutex.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -56,6 +56,13 @@ U_NAMESPACE_END\n \n U_NAMESPACE_BEGIN\n \n+// Export an explicit template instantiation of std::atomic<int32_t>.\n+// When building DLLs for Windows this is required as it is used as a data member of the exported SharedObject class.\n+// See digitlst.h, pluralaffix.h, datefmt.h, and others for similar examples.\n+#if U_PF_WINDOWS <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN\n+template struct U_COMMON_API std::atomic<int32_t>;\n+#endif\n+\n typedef std::atomic<int32_t> u_atomic_int32_t;\n #define ATOMIC_INT32_T_INITIALIZER(val) ATOMIC_VAR_INIT(val)\n \n@@ -205,7 +212,7 @@ umtx_atomic_dec(u_atomic_int32_t *p);\n \n U_NAMESPACE_END\n \n-#endif  /* Low Level Atomic Ops Platfrom Chain */\n+#endif  /* Low Level Atomic Ops Platform Chain */\n \n \n \n@@ -319,7 +326,7 @@ U_NAMESPACE_END\n  *************************************************************************************************/\n \n #if defined(U_USER_MUTEX_H)\n-// #inlcude \"U_USER_MUTEX_H\"\n+// #include \"U_USER_MUTEX_H\"\n #include U_MUTEX_XSTR(U_USER_MUTEX_H)\n \n #elif U_PLATFORM_USES_ONLY_WIN32_API\n@@ -389,7 +396,7 @@ struct UConditionVar {\n #else\n \n /*\n- *  Unknow platform type.\n+ *  Unknown platform type.\n  *      This is an error condition. ICU requires mutexes.\n  */\n \n@@ -401,7 +408,7 @@ struct UConditionVar {\n \n /**************************************************************************************\n  *\n- *  Mutex Implementation function declaratations.\n+ *  Mutex Implementation function declarations.\n  *     Declarations are platform neutral.\n  *     Implementations, in umutex.cpp, are platform specific.\n  *"
        },
        {
            "sha": "5f752b0d1725cb83978a5a9c1aaddae434b44fc7",
            "filename": "deps/icu-small/source/common/unames.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funames.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funames.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funames.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -466,7 +466,7 @@ static uint16_t getExtName(uint32_t code, char *buffer, uint16_t bufferLength) {\n         buffer[--i] = (v < 10 ? '0' + v : 'A' + v - 10);\n     }\n     buffer += ndigits;\n-    length += ndigits;\n+    length += static_cast<uint16_t>(ndigits);\n     WRITE_CHAR(buffer, bufferLength, length, '>');\n \n     return length;"
        },
        {
            "sha": "61d1e8aca651d7a70600ece1800bb95aaa88330c",
            "filename": "deps/icu-small/source/common/unicode/bytestream.h",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fbytestream.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fbytestream.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fbytestream.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -237,21 +237,19 @@ class StringByteSink : public ByteSink {\n    * @stable ICU 4.2\n    */\n   StringByteSink(StringClass* dest) : dest_(dest) { }\n-#ifndef U_HIDE_DRAFT_API\n   /**\n    * Constructs a ByteSink that reserves append capacity and will append bytes to the dest string.\n    *\n    * @param dest pointer to string object to append to\n    * @param initialAppendCapacity capacity beyond dest->length() to be reserve()d\n-   * @draft ICU 60\n+   * @stable ICU 60\n    */\n   StringByteSink(StringClass* dest, int32_t initialAppendCapacity) : dest_(dest) {\n     if (initialAppendCapacity > 0 &&\n         (uint32_t)initialAppendCapacity > (dest->capacity() - dest->length())) {\n       dest->reserve(dest->length() + initialAppendCapacity);\n     }\n   }\n-#endif  // U_HIDE_DRAFT_API\n   /**\n    * Append \"bytes[0,n-1]\" to this.\n    * @param data the pointer to the bytes"
        },
        {
            "sha": "477eb484d136b6972a731e11cebf3c91bc06761d",
            "filename": "deps/icu-small/source/common/unicode/casemap.h",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fcasemap.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fcasemap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fcasemap.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -194,7 +194,6 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n             char16_t *dest, int32_t destCapacity, Edits *edits,\n             UErrorCode &errorCode);\n \n-#ifndef U_HIDE_DRAFT_API\n     /**\n      * Lowercases a UTF-8 string and optionally records edits.\n      * Casing is locale-dependent and context-sensitive.\n@@ -214,7 +213,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *                  which must not indicate a failure before the function call.\n      *\n      * @see ucasemap_utf8ToLower\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     static void utf8ToLower(\n             const char *locale, uint32_t options,\n@@ -240,7 +239,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *                  which must not indicate a failure before the function call.\n      *\n      * @see ucasemap_utf8ToUpper\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     static void utf8ToUpper(\n             const char *locale, uint32_t options,\n@@ -280,7 +279,7 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *                  which must not indicate a failure before the function call.\n      *\n      * @see ucasemap_utf8ToTitle\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     static void utf8ToTitle(\n             const char *locale, uint32_t options, BreakIterator *iter,\n@@ -311,13 +310,12 @@ class U_COMMON_API CaseMap U_FINAL : public UMemory {\n      *                  which must not indicate a failure before the function call.\n      *\n      * @see ucasemap_utf8FoldCase\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     static void utf8Fold(\n             uint32_t options,\n             StringPiece src, ByteSink &sink, Edits *edits,\n             UErrorCode &errorCode);\n-#endif  // U_HIDE_DRAFT_API\n \n     /**\n      * Lowercases a UTF-8 string and optionally records edits."
        },
        {
            "sha": "a7c5f1a0c5ed56631808bcb37fb4e79b6a9806b2",
            "filename": "deps/icu-small/source/common/unicode/char16ptr.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fchar16ptr.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fchar16ptr.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fchar16ptr.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -28,6 +28,8 @@ U_NAMESPACE_BEGIN\n     // Use the predefined value.\n #elif (defined(__clang__) || defined(__GNUC__)) && U_PLATFORM != U_PF_BROWSER_NATIVE_CLIENT\n #   define U_ALIASING_BARRIER(ptr) asm volatile(\"\" : : \"rm\"(ptr) : \"memory\")\n+#elif defined(U_IN_DOXYGEN)\n+#   define U_ALIASING_BARRIER(ptr)\n #endif\n \n /**\n@@ -103,6 +105,7 @@ class U_COMMON_API Char16Ptr U_FINAL {\n #endif\n };\n \n+/// \\cond\n #ifdef U_ALIASING_BARRIER\n \n Char16Ptr::Char16Ptr(char16_t *p) : p_(p) {}\n@@ -134,6 +137,7 @@ Char16Ptr::~Char16Ptr() {}\n char16_t *Char16Ptr::get() const { return u_.cp; }\n \n #endif\n+/// \\endcond\n \n /**\n  * const char16_t * wrapper with implicit conversion from distinct but bit-compatible pointer types.\n@@ -209,6 +213,7 @@ class U_COMMON_API ConstChar16Ptr U_FINAL {\n #endif\n };\n \n+/// \\cond\n #ifdef U_ALIASING_BARRIER\n \n ConstChar16Ptr::ConstChar16Ptr(const char16_t *p) : p_(p) {}\n@@ -240,6 +245,7 @@ ConstChar16Ptr::~ConstChar16Ptr() {}\n const char16_t *ConstChar16Ptr::get() const { return u_.cp; }\n \n #endif\n+/// \\endcond\n \n /**\n  * Converts from const char16_t * to const UChar *."
        },
        {
            "sha": "243fa17b87917a94574959b96666e94d5f9033eb",
            "filename": "deps/icu-small/source/common/unicode/docmain.h",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fdocmain.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fdocmain.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fdocmain.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -88,6 +88,11 @@\n  *     <td>icu::UnicodeSet</td>\n  *   </tr>\n  *   <tr>\n+ *     <td>Maps from Unicode Code Points to Integer Values</td>\n+ *     <td>ucptrie.h, umutablecptrie.h</td>\n+ *     <td>C API</td>\n+ *   </tr>\n+ *   <tr>\n  *     <td>Maps from Strings to Integer Values</td>\n  *     <td>(no C API)</td>\n  *     <td>icu::BytesTrie, icu::UCharsTrie</td>\n@@ -208,9 +213,9 @@\n  *     <td>C API</td>\n  *   </tr>\n  *   <tr>\n- *     <td>Layout Engine/Complex Text Layout</td>\n- *     <td>loengine.h</td>\n- *     <td>icu::LayoutEngine,icu::ParagraphLayout</td>\n+ *     <td>Paragraph Layout / Complex Text Layout</td>\n+ *     <td>playout.h</td>\n+ *     <td>icu::ParagraphLayout</td>\n  *   </tr>\n  *   <tr>\n  *     <td>ICU I/O</td>"
        },
        {
            "sha": "79e98b0cc27ac6716913f10b9177b69dad03283b",
            "filename": "deps/icu-small/source/common/unicode/edits.h",
            "status": "modified",
            "additions": 23,
            "deletions": 29,
            "changes": 52,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fedits.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fedits.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fedits.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -24,8 +24,8 @@ class UnicodeString;\n  * in linear progression. Does not support moving/reordering of text.\n  *\n  * There are two types of edits: <em>change edits</em> and <em>no-change edits</em>. Add edits to\n- * instances of this class using {@link #addReplace(int, int)} (for change edits) and\n- * {@link #addUnchanged(int)} (for no-change edits). Change edits are retained with full granularity,\n+ * instances of this class using {@link #addReplace(int32_t, int32_t)} (for change edits) and\n+ * {@link #addUnchanged(int32_t)} (for no-change edits). Change edits are retained with full granularity,\n  * whereas adjacent no-change edits are always merged together. In no-change edits, there is a one-to-one\n  * mapping between code points in the source and destination strings.\n  *\n@@ -62,11 +62,11 @@ class UnicodeString;\n  * </ul>\n  *\n  * The \"fine changes\" and \"coarse changes\" iterators will step through only the change edits when their\n- * {@link Edits::Iterator#next()} methods are called. They are identical to the non-change iterators when\n- * their {@link Edits::Iterator#findSourceIndex(int)} or {@link Edits::Iterator#findDestinationIndex(int)}\n+ * `Edits::Iterator::next()` methods are called. They are identical to the non-change iterators when\n+ * their `Edits::Iterator::findSourceIndex()` or `Edits::Iterator::findDestinationIndex()`\n  * methods are used to walk through the string.\n  *\n- * For examples of how to use this class, see the test <code>TestCaseMapEditsIteratorDocs</code> in\n+ * For examples of how to use this class, see the test `TestCaseMapEditsIteratorDocs` in\n  * UCharacterCaseTest.java.\n  *\n  * An Edits object tracks a separate UErrorCode, but ICU string transformation functions\n@@ -86,7 +86,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n     /**\n      * Copy constructor.\n      * @param other source edits\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     Edits(const Edits &other) :\n             array(stackArray), capacity(STACK_CAPACITY), length(other.length),\n@@ -98,7 +98,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      * Move constructor, might leave src empty.\n      * This object will have the same contents that the source object had.\n      * @param src source edits\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     Edits(Edits &&src) U_NOEXCEPT :\n             array(stackArray), capacity(STACK_CAPACITY), length(src.length),\n@@ -117,7 +117,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      * Assignment operator.\n      * @param other source edits\n      * @return *this\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     Edits &operator=(const Edits &other);\n \n@@ -127,7 +127,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      * The behavior is undefined if *this and src are the same object.\n      * @param src source edits\n      * @return *this\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     Edits &operator=(Edits &&src) U_NOEXCEPT;\n \n@@ -173,13 +173,11 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      */\n     UBool hasChanges() const { return numChanges != 0; }\n \n-#ifndef U_HIDE_DRAFT_API\n     /**\n      * @return the number of change edits\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     int32_t numberOfChanges() const { return numChanges; }\n-#endif  // U_HIDE_DRAFT_API\n \n     /**\n      * Access to the list of edits.\n@@ -189,9 +187,9 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      * starts at {@link #sourceIndex()} and runs for {@link #oldLength()} chars; the destination string\n      * span starts at {@link #destinationIndex()} and runs for {@link #newLength()} chars.\n      *\n-     * The iterator can be moved between edits using the {@link #next()}, {@link #findSourceIndex(int)},\n-     * and {@link #findDestinationIndex(int)} methods. Calling any of these methods mutates the iterator\n-     * to make it point to the corresponding edit.\n+     * The iterator can be moved between edits using the `next()`, `findSourceIndex(int32_t, UErrorCode &)`,\n+     * and `findDestinationIndex(int32_t, UErrorCode &)` methods.\n+     * Calling any of these methods mutates the iterator to make it point to the corresponding edit.\n      *\n      * For more information, see the documentation for {@link Edits}.\n      *\n@@ -202,7 +200,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n     struct U_COMMON_API Iterator U_FINAL : public UMemory {\n         /**\n          * Default constructor, empty iterator.\n-         * @draft ICU 60\n+         * @stable ICU 60\n          */\n         Iterator() :\n                 array(nullptr), index(0), length(0),\n@@ -253,7 +251,6 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n             return findIndex(i, TRUE, errorCode) == 0;\n         }\n \n-#ifndef U_HIDE_DRAFT_API\n         /**\n          * Moves the iterator to the edit that contains the destination index.\n          * The destination index may be found in a no-change edit\n@@ -271,7 +268,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n          *                  or else the function returns immediately. Check for U_FAILURE()\n          *                  on output or use with function chaining. (See User Guide for details.)\n          * @return TRUE if the edit for the destination index was found\n-         * @draft ICU 60\n+         * @stable ICU 60\n          */\n         UBool findDestinationIndex(int32_t i, UErrorCode &errorCode) {\n             return findIndex(i, FALSE, errorCode) == 0;\n@@ -297,7 +294,7 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n          *                  or else the function returns immediately. Check for U_FAILURE()\n          *                  on output or use with function chaining. (See User Guide for details.)\n          * @return destination index; undefined if i is not 0..string length\n-         * @draft ICU 60\n+         * @stable ICU 60\n          */\n         int32_t destinationIndexFromSourceIndex(int32_t i, UErrorCode &errorCode);\n \n@@ -321,10 +318,9 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n          *                  or else the function returns immediately. Check for U_FAILURE()\n          *                  on output or use with function chaining. (See User Guide for details.)\n          * @return source index; undefined if i is not 0..string length\n-         * @draft ICU 60\n+         * @stable ICU 60\n          */\n         int32_t sourceIndexFromDestinationIndex(int32_t i, UErrorCode &errorCode);\n-#endif  // U_HIDE_DRAFT_API\n \n         /**\n          * Returns whether the edit currently represented by the iterator is a change edit.\n@@ -366,13 +362,13 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n         /**\n          * The start index of the current span in the replacement string; the span has length\n          * {@link #newLength}. Well-defined only if the current edit is a change edit.\n-         * <p>\n-         * The <em>replacement string</em> is the concatenation of all substrings of the destination\n+         *\n+         * The *replacement string* is the concatenation of all substrings of the destination\n          * string corresponding to change edits.\n-         * <p>\n+         *\n          * This method is intended to be used together with operations that write only replacement\n-         * characters (e.g., {@link CaseMap#omitUnchangedText()}). The source string can then be modified\n-         * in-place.\n+         * characters (e.g. operations specifying the \\ref U_OMIT_UNCHANGED_TEXT option).\n+         * The source string can then be modified in-place.\n          *\n          * @return the current index into the replacement-characters-only string,\n          *         not counting unchanged spans\n@@ -475,7 +471,6 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n         return Iterator(array, length, FALSE, FALSE);\n     }\n \n-#ifndef U_HIDE_DRAFT_API\n     /**\n      * Merges the two input Edits and appends the result to this object.\n      *\n@@ -501,10 +496,9 @@ class U_COMMON_API Edits U_FINAL : public UMemory {\n      *                  or else the function returns immediately. Check for U_FAILURE()\n      *                  on output or use with function chaining. (See User Guide for details.)\n      * @return *this, with the merged edits appended\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     Edits &mergeAndAppend(const Edits &ab, const Edits &bc, UErrorCode &errorCode);\n-#endif  // U_HIDE_DRAFT_API\n \n private:\n     void releaseArray() U_NOEXCEPT;"
        },
        {
            "sha": "82d633ed016b5ed98f42ad45f0d01da563731d43",
            "filename": "deps/icu-small/source/common/unicode/enumset.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fenumset.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fenumset.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fenumset.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -28,6 +28,7 @@ U_NAMESPACE_BEGIN\n  * enum bitset for boolean fields. Similar to Java EnumSet<>.\n  * Needs to range check. Used for private instance variables.\n  * @internal\n+ * \\cond\n  */\n template<typename T, uint32_t minValue, uint32_t limitValue>\n class EnumSet {\n@@ -60,6 +61,8 @@ class EnumSet {\n     uint32_t fBools;\n };\n \n+/** \\endcond */\n+\n U_NAMESPACE_END\n \n #endif /* U_SHOW_CPLUSPLUS_API */"
        },
        {
            "sha": "2444114e9a14bfd47f3b12f5ea2e91a75e63703e",
            "filename": "deps/icu-small/source/common/unicode/filteredbrk.h",
            "status": "modified",
            "additions": 3,
            "deletions": 7,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Ffilteredbrk.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Ffilteredbrk.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Ffilteredbrk.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -67,16 +67,14 @@ class U_COMMON_API FilteredBreakIteratorBuilder : public UObject {\n   static FilteredBreakIteratorBuilder *createInstance(UErrorCode &status);\n #endif  /* U_HIDE_DEPRECATED_API */\n \n-#ifndef U_HIDE_DRAFT_API\n   /**\n    * Construct an empty FilteredBreakIteratorBuilder.\n    * In this state, it will not suppress any segment boundaries.\n    * @param status The error code.\n    * @return the new builder\n-   * @draft ICU 60\n+   * @stable ICU 60\n    */\n   static FilteredBreakIteratorBuilder *createEmptyInstance(UErrorCode &status);\n-#endif  /* U_HIDE_DRAFT_API */\n \n   /**\n    * Suppress a certain string from being the end of a segment.\n@@ -95,7 +93,7 @@ class U_COMMON_API FilteredBreakIteratorBuilder : public UObject {\n    * This function does not create any new segment boundaries, but only serves to un-do\n    * the effect of earlier calls to suppressBreakAfter, or to un-do the effect of\n    * locale data which may be suppressing certain strings.\n-   * @param exception the exception to remove\n+   * @param string the exception to remove\n    * @param status error code\n    * @return returns TRUE if the string was present and now removed,\n    * FALSE if the call was a no-op because the string was not being suppressed.\n@@ -114,7 +112,6 @@ class U_COMMON_API FilteredBreakIteratorBuilder : public UObject {\n    */\n   virtual BreakIterator *build(BreakIterator* adoptBreakIterator, UErrorCode& status) = 0;\n \n-#ifndef U_HIDE_DRAFT_API\n   /**\n    * Wrap (adopt) an existing break iterator in a new filtered instance.\n    * The resulting BreakIterator is owned by the caller.\n@@ -126,12 +123,11 @@ class U_COMMON_API FilteredBreakIteratorBuilder : public UObject {\n    * @param adoptBreakIterator the break iterator to adopt\n    * @param status error code\n    * @return the new BreakIterator, owned by the caller.\n-   * @draft ICU 60\n+   * @stable ICU 60\n    */\n   inline BreakIterator *wrapIteratorWithFilter(BreakIterator* adoptBreakIterator, UErrorCode& status) {\n     return build(adoptBreakIterator, status);\n   }\n-#endif  /* U_HIDE_DRAFT_API */\n \n  protected:\n   /**"
        },
        {
            "sha": "827cbe94b61cf8dc7d442444a2d1c178574e0e4f",
            "filename": "deps/icu-small/source/common/unicode/icuplug.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Ficuplug.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Ficuplug.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Ficuplug.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -110,7 +110,7 @@\n #include \"unicode/utypes.h\"\n \n \n-#if UCONFIG_ENABLE_PLUGINS\n+#if UCONFIG_ENABLE_PLUGINS || defined(U_IN_DOXYGEN)\n \n \n "
        },
        {
            "sha": "415bced82299e3de297fc92f1c124d0caa03ec18",
            "filename": "deps/icu-small/source/common/unicode/locid.h",
            "status": "modified",
            "additions": 368,
            "deletions": 2,
            "changes": 370,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Flocid.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Flocid.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Flocid.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -31,6 +31,10 @@\n #ifndef LOCID_H\n #define LOCID_H\n \n+#include \"unicode/bytestream.h\"\n+#include \"unicode/localpointer.h\"\n+#include \"unicode/strenum.h\"\n+#include \"unicode/stringpiece.h\"\n #include \"unicode/utypes.h\"\n #include \"unicode/uobject.h\"\n #include \"unicode/putil.h\"\n@@ -280,6 +284,16 @@ class U_COMMON_API Locale : public UObject {\n      */\n     Locale(const    Locale& other);\n \n+#ifndef U_HIDE_DRAFT_API\n+    /**\n+     * Move constructor; might leave source in bogus state.\n+     * This locale will have the same contents that the source locale had.\n+     *\n+     * @param other The Locale object being moved in.\n+     * @draft ICU 63\n+     */\n+    Locale(Locale&& other) U_NOEXCEPT;\n+#endif  // U_HIDE_DRAFT_API\n \n     /**\n      * Destructor\n@@ -296,6 +310,19 @@ class U_COMMON_API Locale : public UObject {\n      */\n     Locale& operator=(const Locale& other);\n \n+#ifndef U_HIDE_DRAFT_API\n+    /**\n+     * Move assignment operator; might leave source in bogus state.\n+     * This locale will have the same contents that the source locale had.\n+     * The behavior is undefined if *this and the source are the same object.\n+     *\n+     * @param other The Locale object being moved in.\n+     * @return      *this\n+     * @draft ICU 63\n+     */\n+    Locale& operator=(Locale&& other) U_NOEXCEPT;\n+#endif  // U_HIDE_DRAFT_API\n+\n     /**\n      * Checks if two locale keys are the same.\n      *\n@@ -362,6 +389,55 @@ class U_COMMON_API Locale : public UObject {\n                                      UErrorCode&   success);\n #endif  /* U_HIDE_SYSTEM_API */\n \n+#ifndef U_HIDE_DRAFT_API\n+    /**\n+     * Returns a Locale for the specified BCP47 language tag string.\n+     * If the specified language tag contains any ill-formed subtags,\n+     * the first such subtag and all following subtags are ignored.\n+     * <p>\n+     * This implements the 'Language-Tag' production of BCP47, and so\n+     * supports grandfathered (regular and irregular) as well as private\n+     * use language tags.  Private use tags are represented as 'x-whatever',\n+     * and grandfathered tags are converted to their canonical replacements\n+     * where they exist.  Note that a few grandfathered tags have no modern\n+     * replacement, these will be converted using the fallback described in\n+     * the first paragraph, so some information might be lost.\n+     * @param tag     the input BCP47 language tag.\n+     * @param status  error information if creating the Locale failed.\n+     * @return        the Locale for the specified BCP47 language tag.\n+     * @draft ICU 63\n+     */\n+    static Locale U_EXPORT2 forLanguageTag(StringPiece tag, UErrorCode& status);\n+\n+    /**\n+     * Returns a well-formed language tag for this Locale.\n+     * <p>\n+     * <b>Note</b>: Any locale fields which do not satisfy the BCP47 syntax\n+     * requirement will be silently omitted from the result.\n+     *\n+     * If this function fails, partial output may have been written to the sink.\n+     *\n+     * @param sink    the output sink receiving the BCP47 language\n+     *                tag for this Locale.\n+     * @param status  error information if creating the language tag failed.\n+     * @draft ICU 63\n+     */\n+    void toLanguageTag(ByteSink& sink, UErrorCode& status) const;\n+\n+    /**\n+     * Returns a well-formed language tag for this Locale.\n+     * <p>\n+     * <b>Note</b>: Any locale fields which do not satisfy the BCP47 syntax\n+     * requirement will be silently omitted from the result.\n+     *\n+     * @param status  error information if creating the language tag failed.\n+     * @return        the BCP47 language tag for this Locale.\n+     * @draft ICU 63\n+     */\n+    template<typename StringClass>\n+    inline StringClass toLanguageTag(UErrorCode& status) const;\n+#endif  // U_HIDE_DRAFT_API\n+\n     /**\n      * Creates a locale which has had minimal canonicalization\n      * as per uloc_getName().\n@@ -432,20 +508,132 @@ class U_COMMON_API Locale : public UObject {\n      */\n     const char * getBaseName() const;\n \n+#ifndef U_HIDE_DRAFT_API\n+    /**\n+     * Add the likely subtags for this Locale, per the algorithm described\n+     * in the following CLDR technical report:\n+     *\n+     *   http://www.unicode.org/reports/tr35/#Likely_Subtags\n+     *\n+     * If this Locale is already in the maximal form, or not valid, or there is\n+     * no data available for maximization, the Locale will be unchanged.\n+     *\n+     * For example, \"und-Zzzz\" cannot be maximized, since there is no\n+     * reasonable maximization.\n+     *\n+     * Examples:\n+     *\n+     * \"en\" maximizes to \"en_Latn_US\"\n+     *\n+     * \"de\" maximizes to \"de_Latn_US\"\n+     *\n+     * \"sr\" maximizes to \"sr_Cyrl_RS\"\n+     *\n+     * \"sh\" maximizes to \"sr_Latn_RS\" (Note this will not reverse.)\n+     *\n+     * \"zh_Hani\" maximizes to \"zh_Hans_CN\" (Note this will not reverse.)\n+     *\n+     * @param status  error information if maximizing this Locale failed.\n+     *                If this Locale is not well-formed, the error code is\n+     *                U_ILLEGAL_ARGUMENT_ERROR.\n+     * @draft ICU 63\n+     */\n+    void addLikelySubtags(UErrorCode& status);\n+\n+    /**\n+     * Minimize the subtags for this Locale, per the algorithm described\n+     * in the following CLDR technical report:\n+     *\n+     *   http://www.unicode.org/reports/tr35/#Likely_Subtags\n+     *\n+     * If this Locale is already in the minimal form, or not valid, or there is\n+     * no data available for minimization, the Locale will be unchanged.\n+     *\n+     * Since the minimization algorithm relies on proper maximization, see the\n+     * comments for addLikelySubtags for reasons why there might not be any\n+     * data.\n+     *\n+     * Examples:\n+     *\n+     * \"en_Latn_US\" minimizes to \"en\"\n+     *\n+     * \"de_Latn_US\" minimizes to \"de\"\n+     *\n+     * \"sr_Cyrl_RS\" minimizes to \"sr\"\n+     *\n+     * \"zh_Hant_TW\" minimizes to \"zh_TW\" (The region is preferred to the\n+     * script, and minimizing to \"zh\" would imply \"zh_Hans_CN\".)\n+     *\n+     * @param status  error information if maximizing this Locale failed.\n+     *                If this Locale is not well-formed, the error code is\n+     *                U_ILLEGAL_ARGUMENT_ERROR.\n+     * @draft ICU 63\n+     */\n+    void minimizeSubtags(UErrorCode& status);\n+#endif  // U_HIDE_DRAFT_API\n \n     /**\n      * Gets the list of keywords for the specified locale.\n      *\n      * @param status the status code\n      * @return pointer to StringEnumeration class, or NULL if there are no keywords.\n      * Client must dispose of it by calling delete.\n+     * @see getKeywords\n      * @stable ICU 2.8\n      */\n     StringEnumeration * createKeywords(UErrorCode &status) const;\n \n+#ifndef U_HIDE_DRAFT_API\n+\n+    /**\n+     * Gets the list of Unicode keywords for the specified locale.\n+     *\n+     * @param status the status code\n+     * @return pointer to StringEnumeration class, or NULL if there are no keywords.\n+     * Client must dispose of it by calling delete.\n+     * @see getUnicodeKeywords\n+     * @draft ICU 63\n+     */\n+    StringEnumeration * createUnicodeKeywords(UErrorCode &status) const;\n+\n+    /**\n+     * Gets the set of keywords for this Locale.\n+     *\n+     * A wrapper to call createKeywords() and write the resulting\n+     * keywords as standard strings (or compatible objects) into any kind of\n+     * container that can be written to by an STL style output iterator.\n+     *\n+     * @param iterator  an STL style output iterator to write the keywords to.\n+     * @param status    error information if creating set of keywords failed.\n+     * @draft ICU 63\n+     */\n+    template<typename StringClass, typename OutputIterator>\n+    inline void getKeywords(OutputIterator iterator, UErrorCode& status) const;\n+\n+    /**\n+     * Gets the set of Unicode keywords for this Locale.\n+     *\n+     * A wrapper to call createUnicodeKeywords() and write the resulting\n+     * keywords as standard strings (or compatible objects) into any kind of\n+     * container that can be written to by an STL style output iterator.\n+     *\n+     * @param iterator  an STL style output iterator to write the keywords to.\n+     * @param status    error information if creating set of keywords failed.\n+     * @draft ICU 63\n+     */\n+    template<typename StringClass, typename OutputIterator>\n+    inline void getUnicodeKeywords(OutputIterator iterator, UErrorCode& status) const;\n+\n+#endif  // U_HIDE_DRAFT_API\n+\n     /**\n      * Gets the value for a keyword.\n      *\n+     * This uses legacy keyword=value pairs, like \"collation=phonebook\".\n+     *\n+     * ICU4C doesn't do automatic conversion between legacy and Unicode\n+     * keywords and values in getters and setters (as opposed to ICU4J).\n+     *\n      * @param keywordName name of the keyword for which we want the value. Case insensitive.\n      * @param buffer The buffer to receive the keyword value.\n      * @param bufferCapacity The capacity of receiving buffer\n@@ -456,12 +644,81 @@ class U_COMMON_API Locale : public UObject {\n      */\n     int32_t getKeywordValue(const char* keywordName, char *buffer, int32_t bufferCapacity, UErrorCode &status) const;\n \n+#ifndef U_HIDE_DRAFT_API\n+    /**\n+     * Gets the value for a keyword.\n+     *\n+     * This uses legacy keyword=value pairs, like \"collation=phonebook\".\n+     *\n+     * ICU4C doesn't do automatic conversion between legacy and Unicode\n+     * keywords and values in getters and setters (as opposed to ICU4J).\n+     *\n+     * @param keywordName  name of the keyword for which we want the value.\n+     * @param sink         the sink to receive the keyword value.\n+     * @param status       error information if getting the value failed.\n+     * @draft ICU 63\n+     */\n+    void getKeywordValue(StringPiece keywordName, ByteSink& sink, UErrorCode& status) const;\n+\n+    /**\n+     * Gets the value for a keyword.\n+     *\n+     * This uses legacy keyword=value pairs, like \"collation=phonebook\".\n+     *\n+     * ICU4C doesn't do automatic conversion between legacy and Unicode\n+     * keywords and values in getters and setters (as opposed to ICU4J).\n+     *\n+     * @param keywordName  name of the keyword for which we want the value.\n+     * @param status       error information if getting the value failed.\n+     * @return             the keyword value.\n+     * @draft ICU 63\n+     */\n+    template<typename StringClass>\n+    inline StringClass getKeywordValue(StringPiece keywordName, UErrorCode& status) const;\n+\n+    /**\n+     * Gets the Unicode value for a Unicode keyword.\n+     *\n+     * This uses Unicode key-value pairs, like \"co-phonebk\".\n+     *\n+     * ICU4C doesn't do automatic conversion between legacy and Unicode\n+     * keywords and values in getters and setters (as opposed to ICU4J).\n+     *\n+     * @param keywordName  name of the keyword for which we want the value.\n+     * @param sink         the sink to receive the keyword value.\n+     * @param status       error information if getting the value failed.\n+     * @draft ICU 63\n+     */\n+    void getUnicodeKeywordValue(StringPiece keywordName, ByteSink& sink, UErrorCode& status) const;\n+\n+    /**\n+     * Gets the Unicode value for a Unicode keyword.\n+     *\n+     * This uses Unicode key-value pairs, like \"co-phonebk\".\n+     *\n+     * ICU4C doesn't do automatic conversion between legacy and Unicode\n+     * keywords and values in getters and setters (as opposed to ICU4J).\n+     *\n+     * @param keywordName  name of the keyword for which we want the value.\n+     * @param status       error information if getting the value failed.\n+     * @return             the keyword value.\n+     * @draft ICU 63\n+     */\n+    template<typename StringClass>\n+    inline StringClass getUnicodeKeywordValue(StringPiece keywordName, UErrorCode& status) const;\n+#endif  // U_HIDE_DRAFT_API\n+\n     /**\n      * Sets or removes the value for a keyword.\n      *\n      * For removing all keywords, use getBaseName(),\n      * and construct a new Locale if it differs from getName().\n      *\n+     * This uses legacy keyword=value pairs, like \"collation=phonebook\".\n+     *\n+     * ICU4C doesn't do automatic conversion between legacy and Unicode\n+     * keywords and values in getters and setters (as opposed to ICU4J).\n+     *\n      * @param keywordName name of the keyword to be set. Case insensitive.\n      * @param keywordValue value of the keyword to be set. If 0-length or\n      *  NULL, will result in the keyword being removed. No error is given if\n@@ -472,6 +729,48 @@ class U_COMMON_API Locale : public UObject {\n      */\n     void setKeywordValue(const char* keywordName, const char* keywordValue, UErrorCode &status);\n \n+#ifndef U_HIDE_DRAFT_API\n+    /**\n+     * Sets or removes the value for a keyword.\n+     *\n+     * For removing all keywords, use getBaseName(),\n+     * and construct a new Locale if it differs from getName().\n+     *\n+     * This uses legacy keyword=value pairs, like \"collation=phonebook\".\n+     *\n+     * ICU4C doesn't do automatic conversion between legacy and Unicode\n+     * keywords and values in getters and setters (as opposed to ICU4J).\n+     *\n+     * @param keywordName name of the keyword to be set.\n+     * @param keywordValue value of the keyword to be set. If 0-length or\n+     *  NULL, will result in the keyword being removed. No error is given if\n+     *  that keyword does not exist.\n+     * @param status Returns any error information while performing this operation.\n+     * @draft ICU 63\n+     */\n+    void setKeywordValue(StringPiece keywordName, StringPiece keywordValue, UErrorCode& status);\n+\n+    /**\n+     * Sets or removes the Unicode value for a Unicode keyword.\n+     *\n+     * For removing all keywords, use getBaseName(),\n+     * and construct a new Locale if it differs from getName().\n+     *\n+     * This uses Unicode key-value pairs, like \"co-phonebk\".\n+     *\n+     * ICU4C doesn't do automatic conversion between legacy and Unicode\n+     * keywords and values in getters and setters (as opposed to ICU4J).\n+     *\n+     * @param keywordName name of the keyword to be set.\n+     * @param keywordValue value of the keyword to be set. If 0-length or\n+     *  NULL, will result in the keyword being removed. No error is given if\n+     *  that keyword does not exist.\n+     * @param status Returns any error information while performing this operation.\n+     * @draft ICU 63\n+     */\n+    void setUnicodeKeywordValue(StringPiece keywordName, StringPiece keywordValue, UErrorCode& status);\n+#endif  // U_HIDE_DRAFT_API\n+\n     /**\n      * returns the locale's three-letter language code, as specified\n      * in ISO draft standard ISO-639-2.\n@@ -759,12 +1058,12 @@ class U_COMMON_API Locale : public UObject {\n \n     /**\n      * A friend to allow the default locale to be set by either the C or C++ API.\n-     * @internal\n+     * @internal (private)\n      */\n     friend Locale *locale_set_default_internal(const char *, UErrorCode& status);\n \n     /**\n-     * @internal\n+     * @internal (private)\n      */\n     friend void U_CALLCONV locale_available_init();\n };\n@@ -775,6 +1074,17 @@ Locale::operator!=(const    Locale&     other) const\n     return !operator==(other);\n }\n \n+#ifndef U_HIDE_DRAFT_API\n+template<typename StringClass> inline StringClass\n+Locale::toLanguageTag(UErrorCode& status) const\n+{\n+    StringClass result;\n+    StringByteSink<StringClass> sink(&result);\n+    toLanguageTag(sink, status);\n+    return result;\n+}\n+#endif  // U_HIDE_DRAFT_API\n+\n inline const char *\n Locale::getCountry() const\n {\n@@ -805,6 +1115,62 @@ Locale::getName() const\n     return fullName;\n }\n \n+#ifndef U_HIDE_DRAFT_API\n+\n+template<typename StringClass, typename OutputIterator> inline void\n+Locale::getKeywords(OutputIterator iterator, UErrorCode& status) const\n+{\n+    LocalPointer<StringEnumeration> keys(createKeywords(status));\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+    for (;;) {\n+        int32_t resultLength;\n+        const char* buffer = keys->next(&resultLength, status);\n+        if (U_FAILURE(status) || buffer == nullptr) {\n+            return;\n+        }\n+        *iterator++ = StringClass(buffer, resultLength);\n+    }\n+}\n+\n+template<typename StringClass, typename OutputIterator> inline void\n+Locale::getUnicodeKeywords(OutputIterator iterator, UErrorCode& status) const\n+{\n+    LocalPointer<StringEnumeration> keys(createUnicodeKeywords(status));\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+    for (;;) {\n+        int32_t resultLength;\n+        const char* buffer = keys->next(&resultLength, status);\n+        if (U_FAILURE(status) || buffer == nullptr) {\n+            return;\n+        }\n+        *iterator++ = StringClass(buffer, resultLength);\n+    }\n+}\n+\n+template<typename StringClass> inline StringClass\n+Locale::getKeywordValue(StringPiece keywordName, UErrorCode& status) const\n+{\n+    StringClass result;\n+    StringByteSink<StringClass> sink(&result);\n+    getKeywordValue(keywordName, sink, status);\n+    return result;\n+}\n+\n+template<typename StringClass> inline StringClass\n+Locale::getUnicodeKeywordValue(StringPiece keywordName, UErrorCode& status) const\n+{\n+    StringClass result;\n+    StringByteSink<StringClass> sink(&result);\n+    getUnicodeKeywordValue(keywordName, sink, status);\n+    return result;\n+}\n+\n+#endif  // U_HIDE_DRAFT_API\n+\n inline UBool\n Locale::isBogus(void) const {\n     return fIsBogus;"
        },
        {
            "sha": "9f2a86551ca417dd8ab00a12189da062757b44ee",
            "filename": "deps/icu-small/source/common/unicode/messagepattern.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fmessagepattern.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fmessagepattern.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fmessagepattern.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -771,8 +771,8 @@ class U_COMMON_API MessagePattern : public UObject {\n          * @stable ICU 4.8\n          */\n         UMessagePatternArgType getArgType() const {\n-            UMessagePatternPartType type=getType();\n-            if(type==UMSGPAT_PART_TYPE_ARG_START || type==UMSGPAT_PART_TYPE_ARG_LIMIT) {\n+            UMessagePatternPartType msgType=getType();\n+            if(msgType ==UMSGPAT_PART_TYPE_ARG_START || msgType ==UMSGPAT_PART_TYPE_ARG_LIMIT) {\n                 return (UMessagePatternArgType)value;\n             } else {\n                 return UMSGPAT_ARG_TYPE_NONE;"
        },
        {
            "sha": "4caa0e31034b2db65f75b0b72ab8ec2d904f090f",
            "filename": "deps/icu-small/source/common/unicode/normalizer2.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fnormalizer2.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fnormalizer2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fnormalizer2.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -241,7 +241,7 @@ class U_COMMON_API Normalizer2 : public UObject {\n      *                  pass the U_SUCCESS() test, or else the function returns\n      *                  immediately. Check for U_FAILURE() on output or use with\n      *                  function chaining. (See User Guide for details.)\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     virtual void\n     normalizeUTF8(uint32_t options, StringPiece src, ByteSink &sink,\n@@ -391,7 +391,7 @@ class U_COMMON_API Normalizer2 : public UObject {\n      *                  immediately. Check for U_FAILURE() on output or use with\n      *                  function chaining. (See User Guide for details.)\n      * @return TRUE if s is normalized\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     virtual UBool\n     isNormalizedUTF8(StringPiece s, UErrorCode &errorCode) const;\n@@ -559,7 +559,7 @@ class U_COMMON_API FilteredNormalizer2 : public Normalizer2 {\n      *                  pass the U_SUCCESS() test, or else the function returns\n      *                  immediately. Check for U_FAILURE() on output or use with\n      *                  function chaining. (See User Guide for details.)\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     virtual void\n     normalizeUTF8(uint32_t options, StringPiece src, ByteSink &sink,\n@@ -686,7 +686,7 @@ class U_COMMON_API FilteredNormalizer2 : public Normalizer2 {\n      *                  immediately. Check for U_FAILURE() on output or use with\n      *                  function chaining. (See User Guide for details.)\n      * @return TRUE if s is normalized\n-     * @draft ICU 60\n+     * @stable ICU 60\n      */\n     virtual UBool\n     isNormalizedUTF8(StringPiece s, UErrorCode &errorCode) const U_OVERRIDE;"
        },
        {
            "sha": "ee0d8b7a0003036f8b4c138019b18ef4c7c9f99d",
            "filename": "deps/icu-small/source/common/unicode/platform.h",
            "status": "modified",
            "additions": 15,
            "deletions": 11,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fplatform.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fplatform.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fplatform.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -38,7 +38,7 @@\n  * and/or from other macros that are predefined by the compiler\n  * or defined in standard (POSIX or platform or compiler) headers.\n  *\n- * As a temporary workaround, you can add an explicit <code>#define</code> for some macros\n+ * As a temporary workaround, you can add an explicit \\#define for some macros\n  * before it is first tested, or add an equivalent -D macro definition\n  * to the compiler's command line.\n  *\n@@ -207,6 +207,9 @@\n #   define CYGWINMSVC\n #endif\n */\n+#ifdef U_IN_DOXYGEN\n+#   define CYGWINMSVC\n+#endif\n \n /**\n  * \\def U_PLATFORM_USES_ONLY_WIN32_API\n@@ -417,6 +420,9 @@\n #ifndef __has_cpp_attribute\n #    define __has_cpp_attribute(x) 0\n #endif\n+#ifndef __has_declspec_attribute\n+#    define __has_declspec_attribute(x) 0\n+#endif\n #ifndef __has_builtin\n #    define __has_builtin(x) 0\n #endif\n@@ -493,13 +499,8 @@ namespace std {\n  */\n #ifdef U_NOEXCEPT\n     /* Use the predefined value. */\n-#elif defined(_HAS_EXCEPTIONS) && !_HAS_EXCEPTIONS  /* Visual Studio */\n-#   define U_NOEXCEPT\n-#elif U_CPLUSPLUS_VERSION >= 11 || __has_feature(cxx_noexcept) || __has_extension(cxx_noexcept) \\\n-        || (defined(_MSC_VER) && _MSC_VER >= 1900)  /* Visual Studio 2015 */\n-#   define U_NOEXCEPT noexcept\n #else\n-#   define U_NOEXCEPT\n+#   define U_NOEXCEPT noexcept\n #endif\n \n /**\n@@ -519,6 +520,8 @@ namespace std {\n             (__has_feature(cxx_attributes) && __has_warning(\"-Wimplicit-fallthrough\"))\n #       define U_FALLTHROUGH [[clang::fallthrough]]\n #   endif\n+#elif defined(__GNUC__) && (__GNUC__ >= 7)\n+#   define U_FALLTHROUGH __attribute__((fallthrough))\n #endif\n \n #ifndef U_FALLTHROUGH\n@@ -763,7 +766,8 @@ namespace std {\n #elif U_HAVE_CHAR16_T \\\n     || (defined(__xlC__) && defined(__IBM_UTF_LITERAL) && U_SIZEOF_WCHAR_T != 2) \\\n     || (defined(__HP_aCC) && __HP_aCC >= 035000) \\\n-    || (defined(__HP_cc) && __HP_cc >= 111106)\n+    || (defined(__HP_cc) && __HP_cc >= 111106) \\\n+    || (defined(U_IN_DOXYGEN))\n #   define U_DECLARE_UTF16(string) u ## string\n #elif U_SIZEOF_WCHAR_T == 2 \\\n     && (U_CHARSET_FAMILY == 0 || (U_PF_OS390 <= U_PLATFORM && U_PLATFORM <= U_PF_OS400 && defined(__UCS2__)))\n@@ -782,15 +786,15 @@ namespace std {\n     /* Use the predefined value. */\n #elif defined(U_STATIC_IMPLEMENTATION)\n #   define U_EXPORT\n+#elif defined(_MSC_VER) || (__has_declspec_attribute(dllexport) && __has_declspec_attribute(dllimport))\n+#   define U_EXPORT __declspec(dllexport)\n #elif defined(__GNUC__)\n #   define U_EXPORT __attribute__((visibility(\"default\")))\n #elif (defined(__SUNPRO_CC) && __SUNPRO_CC >= 0x550) \\\n    || (defined(__SUNPRO_C) && __SUNPRO_C >= 0x550)\n #   define U_EXPORT __global\n /*#elif defined(__HP_aCC) || defined(__HP_cc)\n #   define U_EXPORT __declspec(dllexport)*/\n-#elif defined(_MSC_VER)\n-#   define U_EXPORT __declspec(dllexport)\n #else\n #   define U_EXPORT\n #endif\n@@ -806,7 +810,7 @@ namespace std {\n \n #ifdef U_IMPORT\n     /* Use the predefined value. */\n-#elif defined(_MSC_VER)\n+#elif defined(_MSC_VER) || (__has_declspec_attribute(dllexport) && __has_declspec_attribute(dllimport))\n     /* Windows needs to export/import data. */\n #   define U_IMPORT __declspec(dllimport)\n #else"
        },
        {
            "sha": "70324ffee3b9c4f1d2399e2c1dfb2c14df26e652",
            "filename": "deps/icu-small/source/common/unicode/ptypes.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fptypes.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fptypes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fptypes.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -83,6 +83,7 @@ typedef unsigned char uint8_t;\n \n #else /* neither U_HAVE_STDINT_H nor U_HAVE_INTTYPES_H */\n \n+/// \\cond\n #if ! U_HAVE_INT8_T\n typedef signed char int8_t;\n #endif\n@@ -122,6 +123,7 @@ typedef unsigned int uint32_t;\n     typedef unsigned long long uint64_t;\n #endif\n #endif\n+/// \\endcond\n \n #endif /* U_HAVE_STDINT_H / U_HAVE_INTTYPES_H */\n "
        },
        {
            "sha": "47abd554eaf0f174fb9db59ab60cd1b6bfb71499",
            "filename": "deps/icu-small/source/common/unicode/rbbi.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Frbbi.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Frbbi.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Frbbi.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -99,7 +99,7 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      * If present, UStack of LanguageBreakEngine objects that might handle\n      * dictionary characters. Searched from top to bottom to find an object to\n      * handle a given character.\n-     * @internal\n+     * @internal (private)\n      */\n     UStack              *fLanguageBreakEngines;\n \n@@ -108,14 +108,14 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      * If present, the special LanguageBreakEngine used for handling\n      * characters that are in the dictionary set, but not handled by any\n      * LangugageBreakEngine.\n-     * @internal\n+     * @internal (private)\n      */\n     UnhandledEngine     *fUnhandledBreakEngine;\n \n     /**\n      * Counter for the number of characters encountered with the \"dictionary\"\n      *   flag set.\n-     * @internal\n+     * @internal (private)\n      */\n     uint32_t            fDictionaryCharCount;\n \n@@ -150,7 +150,7 @@ class U_COMMON_API RuleBasedBreakIterator /*U_FINAL*/ : public BreakIterator {\n      *\n      *             The break iterator adopts the memory, and will\n      *             free it when done.\n-     * @internal\n+     * @internal (private)\n      */\n     RuleBasedBreakIterator(RBBIDataHeader* data, UErrorCode &status);\n "
        },
        {
            "sha": "7b9f70944f62db69997057f5f67912566cdde220",
            "filename": "deps/icu-small/source/common/unicode/stringoptions.h",
            "status": "modified",
            "additions": 5,
            "deletions": 13,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fstringoptions.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fstringoptions.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fstringoptions.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -39,8 +39,6 @@\n  */\n #define U_FOLD_CASE_EXCLUDE_SPECIAL_I 1\n \n-#ifndef U_HIDE_DRAFT_API\n-\n /**\n  * Titlecase the string as a whole rather than each word.\n  * (Titlecase only the character at index 0, possibly adjusted.)\n@@ -50,7 +48,7 @@\n  * including both an options bit and an explicit BreakIterator.\n  *\n  * @see U_TITLECASE_ADJUST_TO_CASED\n- * @draft ICU 60\n+ * @stable ICU 60\n  */\n #define U_TITLECASE_WHOLE_STRING 0x20\n \n@@ -63,12 +61,10 @@\n  * including both an options bit and an explicit BreakIterator.\n  *\n  * @see U_TITLECASE_ADJUST_TO_CASED\n- * @draft ICU 60\n+ * @stable ICU 60\n  */\n #define U_TITLECASE_SENTENCES 0x40\n \n-#endif  // U_HIDE_DRAFT_API\n-\n /**\n  * Do not lowercase non-initial parts of words when titlecasing.\n  * Option bit for titlecasing APIs that take an options bit set.\n@@ -112,8 +108,6 @@\n  */\n #define U_TITLECASE_NO_BREAK_ADJUSTMENT 0x200\n \n-#ifndef U_HIDE_DRAFT_API\n-\n /**\n  * Adjust each titlecasing BreakIterator index to the next cased character.\n  * (See the Unicode Standard, chapter 3, Default Case Conversion, R3 toTitlecase(X).)\n@@ -130,7 +124,7 @@\n  * It is an error to specify multiple titlecasing adjustment options together.\n  *\n  * @see U_TITLECASE_NO_BREAK_ADJUSTMENT\n- * @draft ICU 60\n+ * @stable ICU 60\n  */\n #define U_TITLECASE_ADJUST_TO_CASED 0x400\n \n@@ -141,7 +135,7 @@\n  * @see CaseMap\n  * @see Edits\n  * @see Normalizer2\n- * @draft ICU 60\n+ * @stable ICU 60\n  */\n #define U_EDITS_NO_RESET 0x2000\n \n@@ -153,12 +147,10 @@\n  * @see CaseMap\n  * @see Edits\n  * @see Normalizer2\n- * @draft ICU 60\n+ * @stable ICU 60\n  */\n #define U_OMIT_UNCHANGED_TEXT 0x4000\n \n-#endif  // U_HIDE_DRAFT_API\n-\n /**\n  * Option bit for u_strCaseCompare, u_strcasecmp, unorm_compare, etc:\n  * Compare strings in code point order instead of code unit order."
        },
        {
            "sha": "c27fbd67960d7096e8ceaacddcdf56b7901a9fca",
            "filename": "deps/icu-small/source/common/unicode/stringtriebuilder.h",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fstringtriebuilder.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fstringtriebuilder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fstringtriebuilder.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -26,8 +26,10 @@\n  */\n \n // Forward declaration.\n+/// \\cond\n struct UHashtable;\n typedef struct UHashtable UHashtable;\n+/// \\endcond\n \n /**\n  * Build options for BytesTrieBuilder and CharsTrieBuilder.\n@@ -64,7 +66,7 @@ class U_COMMON_API StringTrieBuilder : public UObject {\n public:\n #ifndef U_HIDE_INTERNAL_API\n     /** @internal */\n-    static UBool hashNode(const void *node);\n+    static int32_t hashNode(const void *node);\n     /** @internal */\n     static UBool equalNodes(const void *left, const void *right);\n #endif  /* U_HIDE_INTERNAL_API */\n@@ -188,7 +190,10 @@ class U_COMMON_API StringTrieBuilder : public UObject {\n \n     // Do not conditionalize the following with #ifndef U_HIDE_INTERNAL_API,\n     // it is needed for layout of other objects.\n-    /** @internal */\n+    /**\n+     * @internal\n+     * \\cond\n+     */\n     class Node : public UObject {\n     public:\n         Node(int32_t initialHash) : hash(initialHash), offset(0) {}\n@@ -391,7 +396,9 @@ class U_COMMON_API StringTrieBuilder : public UObject {\n         int32_t length;\n         Node *next;  // A branch sub-node.\n     };\n+\n #endif  /* U_HIDE_INTERNAL_API */\n+    /// \\endcond\n \n     /** @internal */\n     virtual Node *createLinearMatchNode(int32_t i, int32_t unitIndex, int32_t length,"
        },
        {
            "sha": "f4875c8801efd6c58963c266c9359f937a9ce9e5",
            "filename": "deps/icu-small/source/common/unicode/ubidi.h",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubidi.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubidi.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubidi.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -323,6 +323,10 @@\n  * these special values are designed that way. Also, the implementation\n  * assumes that UBIDI_MAX_EXPLICIT_LEVEL is odd.\n  *\n+ * Note: The numeric values of the related constants will not change:\n+ * They are tied to the use of 7-bit byte values (plus the override bit)\n+ * and of the UBiDiLevel=uint8_t data type in this API.\n+ *\n  * @see UBIDI_DEFAULT_LTR\n  * @see UBIDI_DEFAULT_RTL\n  * @see UBIDI_LEVEL_OVERRIDE\n@@ -386,6 +390,8 @@ typedef uint8_t UBiDiLevel;\n \n /**\n  * Maximum explicit embedding level.\n+ * Same as the max_depth value in the\n+ * <a href=\"http://www.unicode.org/reports/tr9/#BD2\">Unicode Bidirectional Algorithm</a>.\n  * (The maximum resolved level can be up to <code>UBIDI_MAX_EXPLICIT_LEVEL+1</code>).\n  * @stable ICU 2.0\n  */\n@@ -1996,7 +2002,7 @@ U_CDECL_BEGIN\n  *\n  * @return The directional property / Bidi class for the given code point\n  *         <code>c</code> if the default class has been overridden, or\n- *         <code>#U_BIDI_CLASS_DEFAULT=u_getIntPropertyMaxValue(UCHAR_BIDI_CLASS)+1</code>\n+ *         <code>u_getIntPropertyMaxValue(UCHAR_BIDI_CLASS)+1</code>\n  *         if the standard Bidi class value for <code>c</code> is to be used.\n  * @see ubidi_setClassCallback\n  * @see ubidi_getClassCallback\n@@ -2010,7 +2016,7 @@ U_CDECL_END\n /**\n  * Retrieve the Bidi class for a given code point.\n  * <p>If a <code>#UBiDiClassCallback</code> callback is defined and returns a\n- * value other than <code>#U_BIDI_CLASS_DEFAULT=u_getIntPropertyMaxValue(UCHAR_BIDI_CLASS)+1</code>,\n+ * value other than <code>u_getIntPropertyMaxValue(UCHAR_BIDI_CLASS)+1</code>,\n  * that value is used; otherwise the default class determination mechanism is invoked.</p>\n  *\n  * @param pBiDi is the paragraph <code>UBiDi</code> object."
        },
        {
            "sha": "5c08ed5df0fd90bd0a571cced3e28551dfc93334",
            "filename": "deps/icu-small/source/common/unicode/ubiditransform.h",
            "status": "modified",
            "additions": 29,
            "deletions": 24,
            "changes": 53,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubiditransform.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubiditransform.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fubiditransform.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -26,33 +26,38 @@\n /**\n  * \\file\n  * \\brief Bidi Transformations\n+ */\n+\n+/**\n+ * `UBiDiOrder` indicates the order of text.\n  *\n- * <code>UBiDiOrder</code> indicates the order of text.<p>\n  * This bidi transformation engine supports all possible combinations (4 in\n  * total) of input and output text order:\n- * <ul>\n- * <li><logical input, visual output>: unless the output direction is RTL, this\n- * corresponds to a normal operation of the Bidi algorithm as described in the\n- * Unicode Technical Report and implemented by <code>UBiDi</code> when the\n- * reordering mode is set to <code>UBIDI_REORDER_DEFAULT</code>. Visual RTL\n- * mode is not supported by <code>UBiDi</code> and is accomplished through\n- * reversing a visual LTR string,</li>\n- * <li><visual input, logical output>: unless the input direction is RTL, this\n- * corresponds to an \"inverse bidi algorithm\" in <code>UBiDi</code> with the\n- * reordering mode set to <code>UBIDI_REORDER_INVERSE_LIKE_DIRECT</code>.\n- * Visual RTL mode is not not supported by <code>UBiDi</code> and is\n- * accomplished through reversing a visual LTR string,</li>\n- * <li><logical input, logical output>: if the input and output base directions\n- * mismatch, this corresponds to the <code>UBiDi</code> implementation with the\n- * reordering mode set to <code>UBIDI_REORDER_RUNS_ONLY</code>; and if the\n- * input and output base directions are identical, the transformation engine\n- * will only handle character mirroring and Arabic shaping operations without\n- * reordering,</li>\n- * <li><visual input, visual output>: this reordering mode is not supported by\n- * the <code>UBiDi</code> engine; it implies character mirroring, Arabic\n- * shaping, and - if the input/output base directions mismatch -  string\n- * reverse operations.</li>\n- * </ul>\n+ *\n+ *   - <logical input, visual output>: unless the output direction is RTL, this\n+ *     corresponds to a normal operation of the Bidi algorithm as described in the\n+ *     Unicode Technical Report and implemented by `UBiDi` when the\n+ *     reordering mode is set to `UBIDI_REORDER_DEFAULT`. Visual RTL\n+ *     mode is not supported by `UBiDi` and is accomplished through\n+ *     reversing a visual LTR string,\n+ *\n+ *   - <visual input, logical output>: unless the input direction is RTL, this\n+ *     corresponds to an \"inverse bidi algorithm\" in `UBiDi` with the\n+ *     reordering mode set to `UBIDI_REORDER_INVERSE_LIKE_DIRECT`.\n+ *     Visual RTL mode is not not supported by `UBiDi` and is\n+ *     accomplished through reversing a visual LTR string,\n+ *\n+ *   - <logical input, logical output>: if the input and output base directions\n+ *     mismatch, this corresponds to the `UBiDi` implementation with the\n+ *     reordering mode set to `UBIDI_REORDER_RUNS_ONLY`; and if the\n+ *     input and output base directions are identical, the transformation engine\n+ *     will only handle character mirroring and Arabic shaping operations without\n+ *     reordering,\n+ *\n+ *   - <visual input, visual output>: this reordering mode is not supported by\n+ *     the `UBiDi` engine; it implies character mirroring, Arabic\n+ *     shaping, and - if the input/output base directions mismatch -  string\n+ *     reverse operations.\n  * @see ubidi_setInverse\n  * @see ubidi_setReorderingMode\n  * @see UBIDI_REORDER_DEFAULT"
        },
        {
            "sha": "9e180db53b665aa07b50f82fa5769773e32706ec",
            "filename": "deps/icu-small/source/common/unicode/uchar.h",
            "status": "modified",
            "additions": 254,
            "deletions": 1,
            "changes": 255,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuchar.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuchar.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuchar.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -27,6 +27,24 @@\n \n #include \"unicode/utypes.h\"\n #include \"unicode/stringoptions.h\"\n+#include \"unicode/ucpmap.h\"\n+\n+#if !defined(USET_DEFINED) && !defined(U_IN_DOXYGEN)\n+\n+#define USET_DEFINED\n+\n+/**\n+ * USet is the C API type corresponding to C++ class UnicodeSet.\n+ * It is forward-declared here to avoid including unicode/uset.h file if related\n+ * APIs are not used.\n+ *\n+ * @see ucnv_getUnicodeSet\n+ * @stable ICU 2.4\n+ */\n+typedef struct USet USet;\n+\n+#endif\n+\n \n U_CDECL_BEGIN\n \n@@ -61,6 +79,18 @@ U_CDECL_BEGIN\n  * \"About the Unicode Character Database\" (http://www.unicode.org/ucd/)\n  * and the ICU User Guide chapter on Properties (http://icu-project.org/userguide/properties.html).\n  *\n+ * Many properties are accessible via generic functions that take a UProperty selector.\n+ * - u_hasBinaryProperty() returns a binary value (TRUE/FALSE) per property and code point.\n+ * - u_getIntPropertyValue() returns an integer value per property and code point.\n+ *   For each supported enumerated or catalog property, there is\n+ *   an enum type for all of the property's values, and\n+ *   u_getIntPropertyValue() returns the numeric values of those constants.\n+ * - u_getBinaryPropertySet() returns a set for each ICU-supported binary property with\n+ *   all code points for which the property is true.\n+ * - u_getIntPropertyMap() returns a map for each\n+ *   ICU-supported enumerated/catalog/int-valued property which\n+ *   maps all Unicode code points to their values for that property.\n+ *\n  * Many functions are designed to match java.lang.Character functions.\n  * See the individual function documentation,\n  * and see the JDK 1.4 java.lang.Character documentation\n@@ -546,12 +576,34 @@ typedef enum UProperty {\n         (http://www.unicode.org/reports/tr9/)\n         Returns UBidiPairedBracketType values. @stable ICU 52 */\n     UCHAR_BIDI_PAIRED_BRACKET_TYPE=0x1015,\n+    /**\n+     * Enumerated property Indic_Positional_Category.\n+     * New in Unicode 6.0 as provisional property Indic_Matra_Category;\n+     * renamed and changed to informative in Unicode 8.0.\n+     * See http://www.unicode.org/reports/tr44/#IndicPositionalCategory.txt\n+     * @stable ICU 63\n+     */\n+    UCHAR_INDIC_POSITIONAL_CATEGORY=0x1016,\n+    /**\n+     * Enumerated property Indic_Syllabic_Category.\n+     * New in Unicode 6.0 as provisional; informative since Unicode 8.0.\n+     * See http://www.unicode.org/reports/tr44/#IndicSyllabicCategory.txt\n+     * @stable ICU 63\n+     */\n+    UCHAR_INDIC_SYLLABIC_CATEGORY=0x1017,\n+    /**\n+     * Enumerated property Vertical_Orientation.\n+     * Used for UAX #50 Unicode Vertical Text Layout (https://www.unicode.org/reports/tr50/).\n+     * New as a UCD property in Unicode 10.0.\n+     * @stable ICU 63\n+     */\n+    UCHAR_VERTICAL_ORIENTATION=0x1018,\n #ifndef U_HIDE_DEPRECATED_API\n     /**\n      * One more than the last constant for enumerated/integer Unicode properties.\n      * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.\n      */\n-    UCHAR_INT_LIMIT=0x1016,\n+    UCHAR_INT_LIMIT=0x1019,\n #endif  // U_HIDE_DEPRECATED_API\n \n     /** Bitmask property General_Category_Mask.\n@@ -2320,6 +2372,161 @@ typedef enum UHangulSyllableType {\n #endif  // U_HIDE_DEPRECATED_API\n } UHangulSyllableType;\n \n+/**\n+ * Indic Positional Category constants.\n+ *\n+ * @see UCHAR_INDIC_POSITIONAL_CATEGORY\n+ * @stable ICU 63\n+ */\n+typedef enum UIndicPositionalCategory {\n+    /*\n+     * Note: UIndicPositionalCategory constants are parsed by preparseucd.py.\n+     * It matches lines like\n+     *     U_INPC_<Unicode Indic_Positional_Category value name>\n+     */\n+\n+    /** @stable ICU 63 */\n+    U_INPC_NA,\n+    /** @stable ICU 63 */\n+    U_INPC_BOTTOM,\n+    /** @stable ICU 63 */\n+    U_INPC_BOTTOM_AND_LEFT,\n+    /** @stable ICU 63 */\n+    U_INPC_BOTTOM_AND_RIGHT,\n+    /** @stable ICU 63 */\n+    U_INPC_LEFT,\n+    /** @stable ICU 63 */\n+    U_INPC_LEFT_AND_RIGHT,\n+    /** @stable ICU 63 */\n+    U_INPC_OVERSTRUCK,\n+    /** @stable ICU 63 */\n+    U_INPC_RIGHT,\n+    /** @stable ICU 63 */\n+    U_INPC_TOP,\n+    /** @stable ICU 63 */\n+    U_INPC_TOP_AND_BOTTOM,\n+    /** @stable ICU 63 */\n+    U_INPC_TOP_AND_BOTTOM_AND_RIGHT,\n+    /** @stable ICU 63 */\n+    U_INPC_TOP_AND_LEFT,\n+    /** @stable ICU 63 */\n+    U_INPC_TOP_AND_LEFT_AND_RIGHT,\n+    /** @stable ICU 63 */\n+    U_INPC_TOP_AND_RIGHT,\n+    /** @stable ICU 63 */\n+    U_INPC_VISUAL_ORDER_LEFT,\n+} UIndicPositionalCategory;\n+\n+/**\n+ * Indic Syllabic Category constants.\n+ *\n+ * @see UCHAR_INDIC_SYLLABIC_CATEGORY\n+ * @stable ICU 63\n+ */\n+typedef enum UIndicSyllabicCategory {\n+    /*\n+     * Note: UIndicSyllabicCategory constants are parsed by preparseucd.py.\n+     * It matches lines like\n+     *     U_INSC_<Unicode Indic_Syllabic_Category value name>\n+     */\n+\n+    /** @stable ICU 63 */\n+    U_INSC_OTHER,\n+    /** @stable ICU 63 */\n+    U_INSC_AVAGRAHA,\n+    /** @stable ICU 63 */\n+    U_INSC_BINDU,\n+    /** @stable ICU 63 */\n+    U_INSC_BRAHMI_JOINING_NUMBER,\n+    /** @stable ICU 63 */\n+    U_INSC_CANTILLATION_MARK,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_DEAD,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_FINAL,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_HEAD_LETTER,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_INITIAL_POSTFIXED,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_KILLER,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_MEDIAL,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_PLACEHOLDER,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_PRECEDING_REPHA,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_PREFIXED,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_SUBJOINED,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_SUCCEEDING_REPHA,\n+    /** @stable ICU 63 */\n+    U_INSC_CONSONANT_WITH_STACKER,\n+    /** @stable ICU 63 */\n+    U_INSC_GEMINATION_MARK,\n+    /** @stable ICU 63 */\n+    U_INSC_INVISIBLE_STACKER,\n+    /** @stable ICU 63 */\n+    U_INSC_JOINER,\n+    /** @stable ICU 63 */\n+    U_INSC_MODIFYING_LETTER,\n+    /** @stable ICU 63 */\n+    U_INSC_NON_JOINER,\n+    /** @stable ICU 63 */\n+    U_INSC_NUKTA,\n+    /** @stable ICU 63 */\n+    U_INSC_NUMBER,\n+    /** @stable ICU 63 */\n+    U_INSC_NUMBER_JOINER,\n+    /** @stable ICU 63 */\n+    U_INSC_PURE_KILLER,\n+    /** @stable ICU 63 */\n+    U_INSC_REGISTER_SHIFTER,\n+    /** @stable ICU 63 */\n+    U_INSC_SYLLABLE_MODIFIER,\n+    /** @stable ICU 63 */\n+    U_INSC_TONE_LETTER,\n+    /** @stable ICU 63 */\n+    U_INSC_TONE_MARK,\n+    /** @stable ICU 63 */\n+    U_INSC_VIRAMA,\n+    /** @stable ICU 63 */\n+    U_INSC_VISARGA,\n+    /** @stable ICU 63 */\n+    U_INSC_VOWEL,\n+    /** @stable ICU 63 */\n+    U_INSC_VOWEL_DEPENDENT,\n+    /** @stable ICU 63 */\n+    U_INSC_VOWEL_INDEPENDENT,\n+} UIndicSyllabicCategory;\n+\n+/**\n+ * Vertical Orientation constants.\n+ *\n+ * @see UCHAR_VERTICAL_ORIENTATION\n+ * @stable ICU 63\n+ */\n+typedef enum UVerticalOrientation {\n+    /*\n+     * Note: UVerticalOrientation constants are parsed by preparseucd.py.\n+     * It matches lines like\n+     *     U_VO_<Unicode Vertical_Orientation value name>\n+     */\n+\n+    /** @stable ICU 63 */\n+    U_VO_ROTATED,\n+    /** @stable ICU 63 */\n+    U_VO_TRANSFORMED_ROTATED,\n+    /** @stable ICU 63 */\n+    U_VO_TRANSFORMED_UPRIGHT,\n+    /** @stable ICU 63 */\n+    U_VO_UPRIGHT,\n+} UVerticalOrientation;\n+\n /**\n  * Check a binary Unicode property for a code point.\n  *\n@@ -2342,13 +2549,36 @@ typedef enum UHangulSyllableType {\n  *         does not have data for the property at all, or not for this code point.\n  *\n  * @see UProperty\n+ * @see u_getBinaryPropertySet\n  * @see u_getIntPropertyValue\n  * @see u_getUnicodeVersion\n  * @stable ICU 2.1\n  */\n U_STABLE UBool U_EXPORT2\n u_hasBinaryProperty(UChar32 c, UProperty which);\n \n+#ifndef U_HIDE_DRAFT_API\n+\n+/**\n+ * Returns a frozen USet for a binary property.\n+ * The library retains ownership over the returned object.\n+ * Sets an error code if the property number is not one for a binary property.\n+ *\n+ * The returned set contains all code points for which the property is true.\n+ *\n+ * @param property UCHAR_BINARY_START..UCHAR_BINARY_LIMIT-1\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ * @return the property as a set\n+ * @see UProperty\n+ * @see u_hasBinaryProperty\n+ * @see Unicode::fromUSet\n+ * @draft ICU 63\n+ */\n+U_CAPI const USet * U_EXPORT2\n+u_getBinaryPropertySet(UProperty property, UErrorCode *pErrorCode);\n+\n+#endif  // U_HIDE_DRAFT_API\n+\n /**\n  * Check if a code point has the Alphabetic Unicode property.\n  * Same as u_hasBinaryProperty(c, UCHAR_ALPHABETIC).\n@@ -2449,6 +2679,7 @@ u_isUWhiteSpace(UChar32 c);\n  * @see u_hasBinaryProperty\n  * @see u_getIntPropertyMinValue\n  * @see u_getIntPropertyMaxValue\n+ * @see u_getIntPropertyMap\n  * @see u_getUnicodeVersion\n  * @stable ICU 2.2\n  */\n@@ -2505,6 +2736,28 @@ u_getIntPropertyMinValue(UProperty which);\n U_STABLE int32_t U_EXPORT2\n u_getIntPropertyMaxValue(UProperty which);\n \n+#ifndef U_HIDE_DRAFT_API\n+\n+/**\n+ * Returns an immutable UCPMap for an enumerated/catalog/int-valued property.\n+ * The library retains ownership over the returned object.\n+ * Sets an error code if the property number is not one for an \"int property\".\n+ *\n+ * The returned object maps all Unicode code points to their values for that property.\n+ * For documentation of the integer values see u_getIntPropertyValue().\n+ *\n+ * @param property UCHAR_INT_START..UCHAR_INT_LIMIT-1\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ * @return the property as a map\n+ * @see UProperty\n+ * @see u_getIntPropertyValue\n+ * @draft ICU 63\n+ */\n+U_CAPI const UCPMap * U_EXPORT2\n+u_getIntPropertyMap(UProperty property, UErrorCode *pErrorCode);\n+\n+#endif  // U_HIDE_DRAFT_API\n+\n /**\n  * Get the numeric value for a Unicode code point as defined in the\n  * Unicode Character Database."
        },
        {
            "sha": "ec7c5f350b497378298874dd869a837137964352",
            "filename": "deps/icu-small/source/common/unicode/ucnv.h",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucnv.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucnv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucnv.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -53,19 +53,18 @@\n #include \"unicode/uenum.h\"\n #include \"unicode/localpointer.h\"\n \n-#ifndef __USET_H__\n+#if !defined(USET_DEFINED) && !defined(U_IN_DOXYGEN)\n+\n+#define USET_DEFINED\n \n /**\n- * USet is the C API type for Unicode sets.\n- * It is forward-declared here to avoid including the header file if related\n+ * USet is the C API type corresponding to C++ class UnicodeSet.\n+ * It is forward-declared here to avoid including unicode/uset.h file if related\n  * conversion APIs are not used.\n- * See unicode/uset.h\n  *\n  * @see ucnv_getUnicodeSet\n- * @stable ICU 2.6\n+ * @stable ICU 2.4\n  */\n-struct USet;\n-/** @stable ICU 2.6 */\n typedef struct USet USet;\n \n #endif"
        },
        {
            "sha": "3a7d2db9aa07c8208b88e676cb14f06a058abf09",
            "filename": "deps/icu-small/source/common/unicode/uconfig.h",
            "status": "modified",
            "additions": 1,
            "deletions": 12,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuconfig.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuconfig.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuconfig.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -183,7 +183,7 @@\n  */\n #ifdef U_HAVE_LIB_SUFFIX\n     /* Use the predefined value. */\n-#elif defined(U_LIB_SUFFIX_C_NAME)\n+#elif defined(U_LIB_SUFFIX_C_NAME) || defined(U_IN_DOXYGEN)\n #   define U_HAVE_LIB_SUFFIX 1\n #endif\n \n@@ -431,17 +431,6 @@\n #   define UCONFIG_HAVE_PARSEALLINPUT 1\n #endif\n \n-\n-/**\n- * \\def UCONFIG_FORMAT_FASTPATHS_49\n- * This switch turns on other formatting fastpaths. Binary incompatible in object DecimalFormat and DecimalFormatSymbols\n- *\n- * @internal\n- */\n-#ifndef UCONFIG_FORMAT_FASTPATHS_49\n-#   define UCONFIG_FORMAT_FASTPATHS_49 1\n-#endif\n-\n /**\n  * \\def UCONFIG_NO_FILTERED_BREAK_ITERATION\n  * This switch turns off filtered break iteration code."
        },
        {
            "sha": "f2c42b6b7f4beedb256c5437b8072d16f645450c",
            "filename": "deps/icu-small/source/common/unicode/ucpmap.h",
            "status": "added",
            "additions": 162,
            "deletions": 0,
            "changes": 162,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucpmap.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucpmap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucpmap.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,162 @@\n+// Â© 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+// ucpmap.h\n+// created: 2018sep03 Markus W. Scherer\n+\n+#ifndef __UCPMAP_H__\n+#define __UCPMAP_H__\n+\n+#include \"unicode/utypes.h\"\n+\n+#ifndef U_HIDE_DRAFT_API\n+\n+U_CDECL_BEGIN\n+\n+/**\n+ * \\file\n+ *\n+ * This file defines an abstract map from Unicode code points to integer values.\n+ *\n+ * @see UCPMap\n+ * @see UCPTrie\n+ * @see UMutableCPTrie\n+ */\n+\n+/**\n+ * Abstract map from Unicode code points (U+0000..U+10FFFF) to integer values.\n+ *\n+ * @see UCPTrie\n+ * @see UMutableCPTrie\n+ * @draft ICU 63\n+ */\n+typedef struct UCPMap UCPMap;\n+\n+/**\n+ * Selectors for how ucpmap_getRange() etc. should report value ranges overlapping with surrogates.\n+ * Most users should use UCPMAP_RANGE_NORMAL.\n+ *\n+ * @see ucpmap_getRange\n+ * @see ucptrie_getRange\n+ * @see umutablecptrie_getRange\n+ * @draft ICU 63\n+ */\n+enum UCPMapRangeOption {\n+    /**\n+     * ucpmap_getRange() enumerates all same-value ranges as stored in the map.\n+     * Most users should use this option.\n+     * @draft ICU 63\n+     */\n+    UCPMAP_RANGE_NORMAL,\n+    /**\n+     * ucpmap_getRange() enumerates all same-value ranges as stored in the map,\n+     * except that lead surrogates (U+D800..U+DBFF) are treated as having the\n+     * surrogateValue, which is passed to getRange() as a separate parameter.\n+     * The surrogateValue is not transformed via filter().\n+     * See U_IS_LEAD(c).\n+     *\n+     * Most users should use UCPMAP_RANGE_NORMAL instead.\n+     *\n+     * This option is useful for maps that map surrogate code *units* to\n+     * special values optimized for UTF-16 string processing\n+     * or for special error behavior for unpaired surrogates,\n+     * but those values are not to be associated with the lead surrogate code *points*.\n+     * @draft ICU 63\n+     */\n+    UCPMAP_RANGE_FIXED_LEAD_SURROGATES,\n+    /**\n+     * ucpmap_getRange() enumerates all same-value ranges as stored in the map,\n+     * except that all surrogates (U+D800..U+DFFF) are treated as having the\n+     * surrogateValue, which is passed to getRange() as a separate parameter.\n+     * The surrogateValue is not transformed via filter().\n+     * See U_IS_SURROGATE(c).\n+     *\n+     * Most users should use UCPMAP_RANGE_NORMAL instead.\n+     *\n+     * This option is useful for maps that map surrogate code *units* to\n+     * special values optimized for UTF-16 string processing\n+     * or for special error behavior for unpaired surrogates,\n+     * but those values are not to be associated with the lead surrogate code *points*.\n+     * @draft ICU 63\n+     */\n+    UCPMAP_RANGE_FIXED_ALL_SURROGATES\n+};\n+#ifndef U_IN_DOXYGEN\n+typedef enum UCPMapRangeOption UCPMapRangeOption;\n+#endif\n+\n+/**\n+ * Returns the value for a code point as stored in the map, with range checking.\n+ * Returns an implementation-defined error value if c is not in the range 0..U+10FFFF.\n+ *\n+ * @param map the map\n+ * @param c the code point\n+ * @return the map value,\n+ *         or an implementation-defined error value if the code point is not in the range 0..U+10FFFF\n+ * @draft ICU 63\n+ */\n+U_CAPI uint32_t U_EXPORT2\n+ucpmap_get(const UCPMap *map, UChar32 c);\n+\n+/**\n+ * Callback function type: Modifies a map value.\n+ * Optionally called by ucpmap_getRange()/ucptrie_getRange()/umutablecptrie_getRange().\n+ * The modified value will be returned by the getRange function.\n+ *\n+ * Can be used to ignore some of the value bits,\n+ * make a filter for one of several values,\n+ * return a value index computed from the map value, etc.\n+ *\n+ * @param context an opaque pointer, as passed into the getRange function\n+ * @param value a value from the map\n+ * @return the modified value\n+ * @draft ICU 63\n+ */\n+typedef uint32_t U_CALLCONV\n+UCPMapValueFilter(const void *context, uint32_t value);\n+\n+/**\n+ * Returns the last code point such that all those from start to there have the same value.\n+ * Can be used to efficiently iterate over all same-value ranges in a map.\n+ * (This is normally faster than iterating over code points and get()ting each value,\n+ * but much slower than a data structure that stores ranges directly.)\n+ *\n+ * If the UCPMapValueFilter function pointer is not NULL, then\n+ * the value to be delivered is passed through that function, and the return value is the end\n+ * of the range where all values are modified to the same actual value.\n+ * The value is unchanged if that function pointer is NULL.\n+ *\n+ * Example:\n+ * \\code\n+ * UChar32 start = 0, end;\n+ * uint32_t value;\n+ * while ((end = ucpmap_getRange(map, start, UCPMAP_RANGE_NORMAL, 0,\n+ *                               NULL, NULL, &value)) >= 0) {\n+ *     // Work with the range start..end and its value.\n+ *     start = end + 1;\n+ * }\n+ * \\endcode\n+ *\n+ * @param map the map\n+ * @param start range start\n+ * @param option defines whether surrogates are treated normally,\n+ *               or as having the surrogateValue; usually UCPMAP_RANGE_NORMAL\n+ * @param surrogateValue value for surrogates; ignored if option==UCPMAP_RANGE_NORMAL\n+ * @param filter a pointer to a function that may modify the map data value,\n+ *     or NULL if the values from the map are to be used unmodified\n+ * @param context an opaque pointer that is passed on to the filter function\n+ * @param pValue if not NULL, receives the value that every code point start..end has;\n+ *     may have been modified by filter(context, map value)\n+ *     if that function pointer is not NULL\n+ * @return the range end code point, or -1 if start is not a valid code point\n+ * @draft ICU 63\n+ */\n+U_CAPI UChar32 U_EXPORT2\n+ucpmap_getRange(const UCPMap *map, UChar32 start,\n+                UCPMapRangeOption option, uint32_t surrogateValue,\n+                UCPMapValueFilter *filter, const void *context, uint32_t *pValue);\n+\n+U_CDECL_END\n+\n+#endif  // U_HIDE_DRAFT_API\n+#endif"
        },
        {
            "sha": "2718c984e431979f4aa6310ecad07f72e371e2e7",
            "filename": "deps/icu-small/source/common/unicode/ucptrie.h",
            "status": "added",
            "additions": 646,
            "deletions": 0,
            "changes": 646,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucptrie.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucptrie.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucptrie.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,646 @@\n+// Â© 2017 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+// ucptrie.h (modified from utrie2.h)\n+// created: 2017dec29 Markus W. Scherer\n+\n+#ifndef __UCPTRIE_H__\n+#define __UCPTRIE_H__\n+\n+#include \"unicode/utypes.h\"\n+\n+#ifndef U_HIDE_DRAFT_API\n+\n+#include \"unicode/localpointer.h\"\n+#include \"unicode/ucpmap.h\"\n+#include \"unicode/utf8.h\"\n+\n+U_CDECL_BEGIN\n+\n+/**\n+ * \\file\n+ *\n+ * This file defines an immutable Unicode code point trie.\n+ *\n+ * @see UCPTrie\n+ * @see UMutableCPTrie\n+ */\n+\n+#ifndef U_IN_DOXYGEN\n+/** @internal */\n+typedef union UCPTrieData {\n+    /** @internal */\n+    const void *ptr0;\n+    /** @internal */\n+    const uint16_t *ptr16;\n+    /** @internal */\n+    const uint32_t *ptr32;\n+    /** @internal */\n+    const uint8_t *ptr8;\n+} UCPTrieData;\n+#endif\n+\n+/**\n+ * Immutable Unicode code point trie structure.\n+ * Fast, reasonably compact, map from Unicode code points (U+0000..U+10FFFF) to integer values.\n+ * For details see http://site.icu-project.org/design/struct/utrie\n+ *\n+ * Do not access UCPTrie fields directly; use public functions and macros.\n+ * Functions are easy to use: They support all trie types and value widths.\n+ *\n+ * When performance is really important, macros provide faster access.\n+ * Most macros are specific to either \"fast\" or \"small\" tries, see UCPTrieType.\n+ * There are \"fast\" macros for special optimized use cases.\n+ *\n+ * The macros will return bogus values, or may crash, if used on the wrong type or value width.\n+ *\n+ * @see UMutableCPTrie\n+ * @draft ICU 63\n+ */\n+struct UCPTrie {\n+#ifndef U_IN_DOXYGEN\n+    /** @internal */\n+    const uint16_t *index;\n+    /** @internal */\n+    UCPTrieData data;\n+\n+    /** @internal */\n+    int32_t indexLength;\n+    /** @internal */\n+    int32_t dataLength;\n+    /** Start of the last range which ends at U+10FFFF. @internal */\n+    UChar32 highStart;\n+    /** highStart>>12 @internal */\n+    uint16_t shifted12HighStart;\n+\n+    /** @internal */\n+    int8_t type;  // UCPTrieType\n+    /** @internal */\n+    int8_t valueWidth;  // UCPTrieValueWidth\n+\n+    /** padding/reserved @internal */\n+    uint32_t reserved32;\n+    /** padding/reserved @internal */\n+    uint16_t reserved16;\n+\n+    /**\n+     * Internal index-3 null block offset.\n+     * Set to an impossibly high value (e.g., 0xffff) if there is no dedicated index-3 null block.\n+     * @internal\n+     */\n+    uint16_t index3NullOffset;\n+    /**\n+     * Internal data null block offset, not shifted.\n+     * Set to an impossibly high value (e.g., 0xfffff) if there is no dedicated data null block.\n+     * @internal\n+     */\n+    int32_t dataNullOffset;\n+    /** @internal */\n+    uint32_t nullValue;\n+\n+#ifdef UCPTRIE_DEBUG\n+    /** @internal */\n+    const char *name;\n+#endif\n+#endif\n+};\n+#ifndef U_IN_DOXYGEN\n+typedef struct UCPTrie UCPTrie;\n+#endif\n+\n+/**\n+ * Selectors for the type of a UCPTrie.\n+ * Different trade-offs for size vs. speed.\n+ *\n+ * @see umutablecptrie_buildImmutable\n+ * @see ucptrie_openFromBinary\n+ * @see ucptrie_getType\n+ * @draft ICU 63\n+ */\n+enum UCPTrieType {\n+    /**\n+     * For ucptrie_openFromBinary() to accept any type.\n+     * ucptrie_getType() will return the actual type.\n+     * @draft ICU 63\n+     */\n+    UCPTRIE_TYPE_ANY = -1,\n+    /**\n+     * Fast/simple/larger BMP data structure. Use functions and \"fast\" macros.\n+     * @draft ICU 63\n+     */\n+    UCPTRIE_TYPE_FAST,\n+    /**\n+     * Small/slower BMP data structure. Use functions and \"small\" macros.\n+     * @draft ICU 63\n+     */\n+    UCPTRIE_TYPE_SMALL\n+};\n+#ifndef U_IN_DOXYGEN\n+typedef enum UCPTrieType UCPTrieType;\n+#endif\n+\n+/**\n+ * Selectors for the number of bits in a UCPTrie data value.\n+ *\n+ * @see umutablecptrie_buildImmutable\n+ * @see ucptrie_openFromBinary\n+ * @see ucptrie_getValueWidth\n+ * @draft ICU 63\n+ */\n+enum UCPTrieValueWidth {\n+    /**\n+     * For ucptrie_openFromBinary() to accept any data value width.\n+     * ucptrie_getValueWidth() will return the actual data value width.\n+     * @draft ICU 63\n+     */\n+    UCPTRIE_VALUE_BITS_ANY = -1,\n+    /**\n+     * The trie stores 16 bits per data value.\n+     * It returns them as unsigned values 0..0xffff=65535.\n+     * @draft ICU 63\n+     */\n+    UCPTRIE_VALUE_BITS_16,\n+    /**\n+     * The trie stores 32 bits per data value.\n+     * @draft ICU 63\n+     */\n+    UCPTRIE_VALUE_BITS_32,\n+    /**\n+     * The trie stores 8 bits per data value.\n+     * It returns them as unsigned values 0..0xff=255.\n+     * @draft ICU 63\n+     */\n+    UCPTRIE_VALUE_BITS_8\n+};\n+#ifndef U_IN_DOXYGEN\n+typedef enum UCPTrieValueWidth UCPTrieValueWidth;\n+#endif\n+\n+/**\n+ * Opens a trie from its binary form, stored in 32-bit-aligned memory.\n+ * Inverse of ucptrie_toBinary().\n+ *\n+ * The memory must remain valid and unchanged as long as the trie is used.\n+ * You must ucptrie_close() the trie once you are done using it.\n+ *\n+ * @param type selects the trie type; results in an\n+ *             U_INVALID_FORMAT_ERROR if it does not match the binary data;\n+ *             use UCPTRIE_TYPE_ANY to accept any type\n+ * @param valueWidth selects the number of bits in a data value; results in an\n+ *                  U_INVALID_FORMAT_ERROR if it does not match the binary data;\n+ *                  use UCPTRIE_VALUE_BITS_ANY to accept any data value width\n+ * @param data a pointer to 32-bit-aligned memory containing the binary data of a UCPTrie\n+ * @param length the number of bytes available at data;\n+ *               can be more than necessary\n+ * @param pActualLength receives the actual number of bytes at data taken up by the trie data;\n+ *                      can be NULL\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ * @return the trie\n+ *\n+ * @see umutablecptrie_open\n+ * @see umutablecptrie_buildImmutable\n+ * @see ucptrie_toBinary\n+ * @draft ICU 63\n+ */\n+U_CAPI UCPTrie * U_EXPORT2\n+ucptrie_openFromBinary(UCPTrieType type, UCPTrieValueWidth valueWidth,\n+                       const void *data, int32_t length, int32_t *pActualLength,\n+                       UErrorCode *pErrorCode);\n+\n+/**\n+ * Closes a trie and releases associated memory.\n+ *\n+ * @param trie the trie\n+ * @draft ICU 63\n+ */\n+U_CAPI void U_EXPORT2\n+ucptrie_close(UCPTrie *trie);\n+\n+#if U_SHOW_CPLUSPLUS_API\n+\n+U_NAMESPACE_BEGIN\n+\n+/**\n+ * \\class LocalUCPTriePointer\n+ * \"Smart pointer\" class, closes a UCPTrie via ucptrie_close().\n+ * For most methods see the LocalPointerBase base class.\n+ *\n+ * @see LocalPointerBase\n+ * @see LocalPointer\n+ * @draft ICU 63\n+ */\n+U_DEFINE_LOCAL_OPEN_POINTER(LocalUCPTriePointer, UCPTrie, ucptrie_close);\n+\n+U_NAMESPACE_END\n+\n+#endif\n+\n+/**\n+ * Returns the trie type.\n+ *\n+ * @param trie the trie\n+ * @return the trie type\n+ * @see ucptrie_openFromBinary\n+ * @see UCPTRIE_TYPE_ANY\n+ * @draft ICU 63\n+ */\n+U_CAPI UCPTrieType U_EXPORT2\n+ucptrie_getType(const UCPTrie *trie);\n+\n+/**\n+ * Returns the number of bits in a trie data value.\n+ *\n+ * @param trie the trie\n+ * @return the number of bits in a trie data value\n+ * @see ucptrie_openFromBinary\n+ * @see UCPTRIE_VALUE_BITS_ANY\n+ * @draft ICU 63\n+ */\n+U_CAPI UCPTrieValueWidth U_EXPORT2\n+ucptrie_getValueWidth(const UCPTrie *trie);\n+\n+/**\n+ * Returns the value for a code point as stored in the trie, with range checking.\n+ * Returns the trie error value if c is not in the range 0..U+10FFFF.\n+ *\n+ * Easier to use than UCPTRIE_FAST_GET() and similar macros but slower.\n+ * Easier to use because, unlike the macros, this function works on all UCPTrie\n+ * objects, for all types and value widths.\n+ *\n+ * @param trie the trie\n+ * @param c the code point\n+ * @return the trie value,\n+ *         or the trie error value if the code point is not in the range 0..U+10FFFF\n+ * @draft ICU 63\n+ */\n+U_CAPI uint32_t U_EXPORT2\n+ucptrie_get(const UCPTrie *trie, UChar32 c);\n+\n+/**\n+ * Returns the last code point such that all those from start to there have the same value.\n+ * Can be used to efficiently iterate over all same-value ranges in a trie.\n+ * (This is normally faster than iterating over code points and get()ting each value,\n+ * but much slower than a data structure that stores ranges directly.)\n+ *\n+ * If the UCPMapValueFilter function pointer is not NULL, then\n+ * the value to be delivered is passed through that function, and the return value is the end\n+ * of the range where all values are modified to the same actual value.\n+ * The value is unchanged if that function pointer is NULL.\n+ *\n+ * Example:\n+ * \\code\n+ * UChar32 start = 0, end;\n+ * uint32_t value;\n+ * while ((end = ucptrie_getRange(trie, start, UCPMAP_RANGE_NORMAL, 0,\n+ *                                NULL, NULL, &value)) >= 0) {\n+ *     // Work with the range start..end and its value.\n+ *     start = end + 1;\n+ * }\n+ * \\endcode\n+ *\n+ * @param trie the trie\n+ * @param start range start\n+ * @param option defines whether surrogates are treated normally,\n+ *               or as having the surrogateValue; usually UCPMAP_RANGE_NORMAL\n+ * @param surrogateValue value for surrogates; ignored if option==UCPMAP_RANGE_NORMAL\n+ * @param filter a pointer to a function that may modify the trie data value,\n+ *     or NULL if the values from the trie are to be used unmodified\n+ * @param context an opaque pointer that is passed on to the filter function\n+ * @param pValue if not NULL, receives the value that every code point start..end has;\n+ *     may have been modified by filter(context, trie value)\n+ *     if that function pointer is not NULL\n+ * @return the range end code point, or -1 if start is not a valid code point\n+ * @draft ICU 63\n+ */\n+U_CAPI UChar32 U_EXPORT2\n+ucptrie_getRange(const UCPTrie *trie, UChar32 start,\n+                 UCPMapRangeOption option, uint32_t surrogateValue,\n+                 UCPMapValueFilter *filter, const void *context, uint32_t *pValue);\n+\n+/**\n+ * Writes a memory-mappable form of the trie into 32-bit aligned memory.\n+ * Inverse of ucptrie_openFromBinary().\n+ *\n+ * @param trie the trie\n+ * @param data a pointer to 32-bit-aligned memory to be filled with the trie data;\n+ *             can be NULL if capacity==0\n+ * @param capacity the number of bytes available at data, or 0 for pure preflighting\n+ * @param pErrorCode an in/out ICU UErrorCode;\n+ *                   U_BUFFER_OVERFLOW_ERROR if the capacity is too small\n+ * @return the number of bytes written or (if buffer overflow) needed for the trie\n+ *\n+ * @see ucptrie_openFromBinary()\n+ * @draft ICU 63\n+ */\n+U_CAPI int32_t U_EXPORT2\n+ucptrie_toBinary(const UCPTrie *trie, void *data, int32_t capacity, UErrorCode *pErrorCode);\n+\n+/**\n+ * Macro parameter value for a trie with 16-bit data values.\n+ * Use the name of this macro as a \"dataAccess\" parameter in other macros.\n+ * Do not use this macro in any other way.\n+ *\n+ * @see UCPTRIE_VALUE_BITS_16\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_16(trie, i) ((trie)->data.ptr16[i])\n+\n+/**\n+ * Macro parameter value for a trie with 32-bit data values.\n+ * Use the name of this macro as a \"dataAccess\" parameter in other macros.\n+ * Do not use this macro in any other way.\n+ *\n+ * @see UCPTRIE_VALUE_BITS_32\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_32(trie, i) ((trie)->data.ptr32[i])\n+\n+/**\n+ * Macro parameter value for a trie with 8-bit data values.\n+ * Use the name of this macro as a \"dataAccess\" parameter in other macros.\n+ * Do not use this macro in any other way.\n+ *\n+ * @see UCPTRIE_VALUE_BITS_8\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_8(trie, i) ((trie)->data.ptr8[i])\n+\n+/**\n+ * Returns a trie value for a code point, with range checking.\n+ * Returns the trie error value if c is not in the range 0..U+10FFFF.\n+ *\n+ * @param trie (const UCPTrie *, in) the trie; must have type UCPTRIE_TYPE_FAST\n+ * @param dataAccess UCPTRIE_16, UCPTRIE_32, or UCPTRIE_8 according to the trieâs value width\n+ * @param c (UChar32, in) the input code point\n+ * @return The code point's trie value.\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_FAST_GET(trie, dataAccess, c) dataAccess(trie, _UCPTRIE_CP_INDEX(trie, 0xffff, c))\n+\n+/**\n+ * Returns a 16-bit trie value for a code point, with range checking.\n+ * Returns the trie error value if c is not in the range U+0000..U+10FFFF.\n+ *\n+ * @param trie (const UCPTrie *, in) the trie; must have type UCPTRIE_TYPE_SMALL\n+ * @param dataAccess UCPTRIE_16, UCPTRIE_32, or UCPTRIE_8 according to the trieâs value width\n+ * @param c (UChar32, in) the input code point\n+ * @return The code point's trie value.\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_SMALL_GET(trie, dataAccess, c) \\\n+    dataAccess(trie, _UCPTRIE_CP_INDEX(trie, UCPTRIE_SMALL_MAX, c))\n+\n+/**\n+ * UTF-16: Reads the next code point (UChar32 c, out), post-increments src,\n+ * and gets a value from the trie.\n+ * Sets the trie error value if c is an unpaired surrogate.\n+ *\n+ * @param trie (const UCPTrie *, in) the trie; must have type UCPTRIE_TYPE_FAST\n+ * @param dataAccess UCPTRIE_16, UCPTRIE_32, or UCPTRIE_8 according to the trieâs value width\n+ * @param src (const UChar *, in/out) the source text pointer\n+ * @param limit (const UChar *, in) the limit pointer for the text, or NULL if NUL-terminated\n+ * @param c (UChar32, out) variable for the code point\n+ * @param result (out) variable for the trie lookup result\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_FAST_U16_NEXT(trie, dataAccess, src, limit, c, result) { \\\n+    (c) = *(src)++; \\\n+    int32_t __index; \\\n+    if (!U16_IS_SURROGATE(c)) { \\\n+        __index = _UCPTRIE_FAST_INDEX(trie, c); \\\n+    } else { \\\n+        uint16_t __c2; \\\n+        if (U16_IS_SURROGATE_LEAD(c) && (src) != (limit) && U16_IS_TRAIL(__c2 = *(src))) { \\\n+            ++(src); \\\n+            (c) = U16_GET_SUPPLEMENTARY((c), __c2); \\\n+            __index = _UCPTRIE_SMALL_INDEX(trie, c); \\\n+        } else { \\\n+            __index = (trie)->dataLength - UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET; \\\n+        } \\\n+    } \\\n+    (result) = dataAccess(trie, __index); \\\n+}\n+\n+/**\n+ * UTF-16: Reads the previous code point (UChar32 c, out), pre-decrements src,\n+ * and gets a value from the trie.\n+ * Sets the trie error value if c is an unpaired surrogate.\n+ *\n+ * @param trie (const UCPTrie *, in) the trie; must have type UCPTRIE_TYPE_FAST\n+ * @param dataAccess UCPTRIE_16, UCPTRIE_32, or UCPTRIE_8 according to the trieâs value width\n+ * @param start (const UChar *, in) the start pointer for the text\n+ * @param src (const UChar *, in/out) the source text pointer\n+ * @param c (UChar32, out) variable for the code point\n+ * @param result (out) variable for the trie lookup result\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_FAST_U16_PREV(trie, dataAccess, start, src, c, result) { \\\n+    (c) = *--(src); \\\n+    int32_t __index; \\\n+    if (!U16_IS_SURROGATE(c)) { \\\n+        __index = _UCPTRIE_FAST_INDEX(trie, c); \\\n+    } else { \\\n+        uint16_t __c2; \\\n+        if (U16_IS_SURROGATE_TRAIL(c) && (src) != (start) && U16_IS_LEAD(__c2 = *((src) - 1))) { \\\n+            --(src); \\\n+            (c) = U16_GET_SUPPLEMENTARY(__c2, (c)); \\\n+            __index = _UCPTRIE_SMALL_INDEX(trie, c); \\\n+        } else { \\\n+            __index = (trie)->dataLength - UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET; \\\n+        } \\\n+    } \\\n+    (result) = dataAccess(trie, __index); \\\n+}\n+\n+/**\n+ * UTF-8: Post-increments src and gets a value from the trie.\n+ * Sets the trie error value for an ill-formed byte sequence.\n+ *\n+ * Unlike UCPTRIE_FAST_U16_NEXT() this UTF-8 macro does not provide the code point\n+ * because it would be more work to do so and is often not needed.\n+ * If the trie value differs from the error value, then the byte sequence is well-formed,\n+ * and the code point can be assembled without revalidation.\n+ *\n+ * @param trie (const UCPTrie *, in) the trie; must have type UCPTRIE_TYPE_FAST\n+ * @param dataAccess UCPTRIE_16, UCPTRIE_32, or UCPTRIE_8 according to the trieâs value width\n+ * @param src (const char *, in/out) the source text pointer\n+ * @param limit (const char *, in) the limit pointer for the text (must not be NULL)\n+ * @param result (out) variable for the trie lookup result\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_FAST_U8_NEXT(trie, dataAccess, src, limit, result) { \\\n+    int32_t __lead = (uint8_t)*(src)++; \\\n+    if (!U8_IS_SINGLE(__lead)) { \\\n+        uint8_t __t1, __t2, __t3; \\\n+        if ((src) != (limit) && \\\n+            (__lead >= 0xe0 ? \\\n+                __lead < 0xf0 ?  /* U+0800..U+FFFF except surrogates */ \\\n+                    U8_LEAD3_T1_BITS[__lead &= 0xf] & (1 << ((__t1 = *(src)) >> 5)) && \\\n+                    ++(src) != (limit) && (__t2 = *(src) - 0x80) <= 0x3f && \\\n+                    (__lead = ((int32_t)(trie)->index[(__lead << 6) + (__t1 & 0x3f)]) + __t2, 1) \\\n+                :  /* U+10000..U+10FFFF */ \\\n+                    (__lead -= 0xf0) <= 4 && \\\n+                    U8_LEAD4_T1_BITS[(__t1 = *(src)) >> 4] & (1 << __lead) && \\\n+                    (__lead = (__lead << 6) | (__t1 & 0x3f), ++(src) != (limit)) && \\\n+                    (__t2 = *(src) - 0x80) <= 0x3f && \\\n+                    ++(src) != (limit) && (__t3 = *(src) - 0x80) <= 0x3f && \\\n+                    (__lead = __lead >= (trie)->shifted12HighStart ? \\\n+                        (trie)->dataLength - UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET : \\\n+                        ucptrie_internalSmallU8Index((trie), __lead, __t2, __t3), 1) \\\n+            :  /* U+0080..U+07FF */ \\\n+                __lead >= 0xc2 && (__t1 = *(src) - 0x80) <= 0x3f && \\\n+                (__lead = (int32_t)(trie)->index[__lead & 0x1f] + __t1, 1))) { \\\n+            ++(src); \\\n+        } else { \\\n+            __lead = (trie)->dataLength - UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET;  /* ill-formed*/ \\\n+        } \\\n+    } \\\n+    (result) = dataAccess(trie, __lead); \\\n+}\n+\n+/**\n+ * UTF-8: Pre-decrements src and gets a value from the trie.\n+ * Sets the trie error value for an ill-formed byte sequence.\n+ *\n+ * Unlike UCPTRIE_FAST_U16_PREV() this UTF-8 macro does not provide the code point\n+ * because it would be more work to do so and is often not needed.\n+ * If the trie value differs from the error value, then the byte sequence is well-formed,\n+ * and the code point can be assembled without revalidation.\n+ *\n+ * @param trie (const UCPTrie *, in) the trie; must have type UCPTRIE_TYPE_FAST\n+ * @param dataAccess UCPTRIE_16, UCPTRIE_32, or UCPTRIE_8 according to the trieâs value width\n+ * @param start (const char *, in) the start pointer for the text\n+ * @param src (const char *, in/out) the source text pointer\n+ * @param result (out) variable for the trie lookup result\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_FAST_U8_PREV(trie, dataAccess, start, src, result) { \\\n+    int32_t __index = (uint8_t)*--(src); \\\n+    if (!U8_IS_SINGLE(__index)) { \\\n+        __index = ucptrie_internalU8PrevIndex((trie), __index, (const uint8_t *)(start), \\\n+                                              (const uint8_t *)(src)); \\\n+        (src) -= __index & 7; \\\n+        __index >>= 3; \\\n+    } \\\n+    (result) = dataAccess(trie, __index); \\\n+}\n+\n+/**\n+ * Returns a trie value for an ASCII code point, without range checking.\n+ *\n+ * @param trie (const UCPTrie *, in) the trie (of either fast or small type)\n+ * @param dataAccess UCPTRIE_16, UCPTRIE_32, or UCPTRIE_8 according to the trieâs value width\n+ * @param c (UChar32, in) the input code point; must be U+0000..U+007F\n+ * @return The ASCII code point's trie value.\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_ASCII_GET(trie, dataAccess, c) dataAccess(trie, c)\n+\n+/**\n+ * Returns a trie value for a BMP code point (U+0000..U+FFFF), without range checking.\n+ * Can be used to look up a value for a UTF-16 code unit if other parts of\n+ * the string processing check for surrogates.\n+ *\n+ * @param trie (const UCPTrie *, in) the trie; must have type UCPTRIE_TYPE_FAST\n+ * @param dataAccess UCPTRIE_16, UCPTRIE_32, or UCPTRIE_8 according to the trieâs value width\n+ * @param c (UChar32, in) the input code point, must be U+0000..U+FFFF\n+ * @return The BMP code point's trie value.\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_FAST_BMP_GET(trie, dataAccess, c) dataAccess(trie, _UCPTRIE_FAST_INDEX(trie, c))\n+\n+/**\n+ * Returns a trie value for a supplementary code point (U+10000..U+10FFFF),\n+ * without range checking.\n+ *\n+ * @param trie (const UCPTrie *, in) the trie; must have type UCPTRIE_TYPE_FAST\n+ * @param dataAccess UCPTRIE_16, UCPTRIE_32, or UCPTRIE_8 according to the trieâs value width\n+ * @param c (UChar32, in) the input code point, must be U+10000..U+10FFFF\n+ * @return The supplementary code point's trie value.\n+ * @draft ICU 63\n+ */\n+#define UCPTRIE_FAST_SUPP_GET(trie, dataAccess, c) dataAccess(trie, _UCPTRIE_SMALL_INDEX(trie, c))\n+\n+/* Internal definitions ----------------------------------------------------- */\n+\n+#ifndef U_IN_DOXYGEN\n+\n+/**\n+ * Internal implementation constants.\n+ * These are needed for the API macros, but users should not use these directly.\n+ * @internal\n+ */\n+enum {\n+    /** @internal */\n+    UCPTRIE_FAST_SHIFT = 6,\n+\n+    /** Number of entries in a data block for code points below the fast limit. 64=0x40 @internal */\n+    UCPTRIE_FAST_DATA_BLOCK_LENGTH = 1 << UCPTRIE_FAST_SHIFT,\n+\n+    /** Mask for getting the lower bits for the in-fast-data-block offset. @internal */\n+    UCPTRIE_FAST_DATA_MASK = UCPTRIE_FAST_DATA_BLOCK_LENGTH - 1,\n+\n+    /** @internal */\n+    UCPTRIE_SMALL_MAX = 0xfff,\n+\n+    /**\n+     * Offset from dataLength (to be subtracted) for fetching the\n+     * value returned for out-of-range code points and ill-formed UTF-8/16.\n+     * @internal\n+     */\n+    UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET = 1,\n+    /**\n+     * Offset from dataLength (to be subtracted) for fetching the\n+     * value returned for code points highStart..U+10FFFF.\n+     * @internal\n+     */\n+    UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET = 2\n+};\n+\n+/* Internal functions and macros -------------------------------------------- */\n+// Do not conditionalize with #ifndef U_HIDE_INTERNAL_API, needed for public API\n+\n+/** @internal */\n+U_INTERNAL int32_t U_EXPORT2\n+ucptrie_internalSmallIndex(const UCPTrie *trie, UChar32 c);\n+\n+/** @internal */\n+U_INTERNAL int32_t U_EXPORT2\n+ucptrie_internalSmallU8Index(const UCPTrie *trie, int32_t lt1, uint8_t t2, uint8_t t3);\n+\n+/**\n+ * Internal function for part of the UCPTRIE_FAST_U8_PREVxx() macro implementations.\n+ * Do not call directly.\n+ * @internal\n+ */\n+U_INTERNAL int32_t U_EXPORT2\n+ucptrie_internalU8PrevIndex(const UCPTrie *trie, UChar32 c,\n+                            const uint8_t *start, const uint8_t *src);\n+\n+/** Internal trie getter for a code point below the fast limit. Returns the data index. @internal */\n+#define _UCPTRIE_FAST_INDEX(trie, c) \\\n+    ((int32_t)(trie)->index[(c) >> UCPTRIE_FAST_SHIFT] + ((c) & UCPTRIE_FAST_DATA_MASK))\n+\n+/** Internal trie getter for a code point at or above the fast limit. Returns the data index. @internal */\n+#define _UCPTRIE_SMALL_INDEX(trie, c) \\\n+    ((c) >= (trie)->highStart ? \\\n+        (trie)->dataLength - UCPTRIE_HIGH_VALUE_NEG_DATA_OFFSET : \\\n+        ucptrie_internalSmallIndex(trie, c))\n+\n+/**\n+ * Internal trie getter for a code point, with checking that c is in U+0000..10FFFF.\n+ * Returns the data index.\n+ * @internal\n+ */\n+#define _UCPTRIE_CP_INDEX(trie, fastMax, c) \\\n+    ((uint32_t)(c) <= (uint32_t)(fastMax) ? \\\n+        _UCPTRIE_FAST_INDEX(trie, c) : \\\n+        (uint32_t)(c) <= 0x10ffff ? \\\n+            _UCPTRIE_SMALL_INDEX(trie, c) : \\\n+            (trie)->dataLength - UCPTRIE_ERROR_VALUE_NEG_DATA_OFFSET)\n+\n+U_CDECL_END\n+\n+#endif  // U_IN_DOXYGEN\n+#endif  // U_HIDE_DRAFT_API\n+#endif"
        },
        {
            "sha": "1021adc83e7ee2bfcdf231a2961a049d6ce0d65b",
            "filename": "deps/icu-small/source/common/unicode/ucurr.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucurr.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucurr.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fucurr.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -60,6 +60,7 @@ enum UCurrencyUsage {\n     UCURR_USAGE_COUNT=2\n #endif  // U_HIDE_DEPRECATED_API\n };\n+/** Currency Usage used for Decimal Format */\n typedef enum UCurrencyUsage UCurrencyUsage;\n \n /**"
        },
        {
            "sha": "eb8ecdf88b6ec531d1cbba8cb54865141ab1bb2b",
            "filename": "deps/icu-small/source/common/unicode/uenum.h",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuenum.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuenum.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuenum.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -190,8 +190,6 @@ U_STABLE UEnumeration* U_EXPORT2\n uenum_openUCharStringsEnumeration(const UChar* const strings[], int32_t count,\n                                  UErrorCode* ec);\n \n-/* Note:  next function is not hidden as draft, as it is used internally (it was formerly an internal function). */\n-\n /**\n  * Given an array of const char* strings (invariant chars only), return a UEnumeration.  String pointers from 0..count-1 must not be null.\n  * Do not free or modify either the string array or the characters it points to until this object has been destroyed with uenum_close."
        },
        {
            "sha": "6d932cfcfb2ae4661fd4c7d077f897b777b028b9",
            "filename": "deps/icu-small/source/common/unicode/umachine.h",
            "status": "modified",
            "additions": 6,
            "deletions": 17,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fumachine.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fumachine.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fumachine.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -125,6 +125,9 @@\n  * May result in an error if it applied to something not an override.\n  * @internal\n  */\n+#ifndef U_OVERRIDE\n+#define U_OVERRIDE override\n+#endif\n \n /**\n  * \\def U_FINAL\n@@ -133,24 +136,10 @@\n  * May result in an error if subclasses attempt to override.\n  * @internal\n  */\n-\n-#if U_CPLUSPLUS_VERSION >= 11\n-/* C++11 */\n-#ifndef U_OVERRIDE\n-#define U_OVERRIDE override\n-#endif\n-#ifndef U_FINAL\n+#if !defined(U_FINAL) || defined(U_IN_DOXYGEN)\n #define U_FINAL final\n #endif\n-#else\n-/* not C++11 - define to nothing */\n-#ifndef U_OVERRIDE\n-#define U_OVERRIDE\n-#endif\n-#ifndef U_FINAL\n-#define U_FINAL\n-#endif\n-#endif\n+\n \n /*==========================================================================*/\n /* limits for int32_t etc., like in POSIX inttypes.h                        */\n@@ -318,7 +307,7 @@ typedef int8_t UBool;\n  * UChar is configurable by defining the macro UCHAR_TYPE\n  * on the preprocessor or compiler command line:\n  * -DUCHAR_TYPE=uint16_t or -DUCHAR_TYPE=wchar_t (if U_SIZEOF_WCHAR_T==2) etc.\n- * (The UCHAR_TYPE can also be #defined earlier in this file, for outside the ICU library code.)\n+ * (The UCHAR_TYPE can also be \\#defined earlier in this file, for outside the ICU library code.)\n  * This is for transitional use from application code that uses uint16_t or wchar_t for UTF-16.\n  *\n  * The default is UChar=char16_t."
        },
        {
            "sha": "e75191a4495209fb4f98278fd5ee353ae8f84bd5",
            "filename": "deps/icu-small/source/common/unicode/umutablecptrie.h",
            "status": "added",
            "additions": 241,
            "deletions": 0,
            "changes": 241,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fumutablecptrie.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fumutablecptrie.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fumutablecptrie.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,241 @@\n+// Â© 2017 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+// umutablecptrie.h (split out of ucptrie.h)\n+// created: 2018jan24 Markus W. Scherer\n+\n+#ifndef __UMUTABLECPTRIE_H__\n+#define __UMUTABLECPTRIE_H__\n+\n+#include \"unicode/utypes.h\"\n+\n+#ifndef U_HIDE_DRAFT_API\n+\n+#include \"unicode/localpointer.h\"\n+#include \"unicode/ucpmap.h\"\n+#include \"unicode/ucptrie.h\"\n+#include \"unicode/utf8.h\"\n+\n+U_CDECL_BEGIN\n+\n+/**\n+ * \\file\n+ *\n+ * This file defines a mutable Unicode code point trie.\n+ *\n+ * @see UCPTrie\n+ * @see UMutableCPTrie\n+ */\n+\n+/**\n+ * Mutable Unicode code point trie.\n+ * Fast map from Unicode code points (U+0000..U+10FFFF) to 32-bit integer values.\n+ * For details see http://site.icu-project.org/design/struct/utrie\n+ *\n+ * Setting values (especially ranges) and lookup is fast.\n+ * The mutable trie is only somewhat space-efficient.\n+ * It builds a compacted, immutable UCPTrie.\n+ *\n+ * This trie can be modified while iterating over its contents.\n+ * For example, it is possible to merge its values with those from another\n+ * set of ranges (e.g., another mutable or immutable trie):\n+ * Iterate over those source ranges; for each of them iterate over this trie;\n+ * add the source value into the value of each trie range.\n+ *\n+ * @see UCPTrie\n+ * @see umutablecptrie_buildImmutable\n+ * @draft ICU 63\n+ */\n+typedef struct UMutableCPTrie UMutableCPTrie;\n+\n+/**\n+ * Creates a mutable trie that initially maps each Unicode code point to the same value.\n+ * It uses 32-bit data values until umutablecptrie_buildImmutable() is called.\n+ * umutablecptrie_buildImmutable() takes a valueWidth parameter which\n+ * determines the number of bits in the data value in the resulting UCPTrie.\n+ * You must umutablecptrie_close() the trie once you are done using it.\n+ *\n+ * @param initialValue the initial value that is set for all code points\n+ * @param errorValue the value for out-of-range code points and ill-formed UTF-8/16\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ * @return the trie\n+ * @draft ICU 63\n+ */\n+U_CAPI UMutableCPTrie * U_EXPORT2\n+umutablecptrie_open(uint32_t initialValue, uint32_t errorValue, UErrorCode *pErrorCode);\n+\n+/**\n+ * Clones a mutable trie.\n+ * You must umutablecptrie_close() the clone once you are done using it.\n+ *\n+ * @param other the trie to clone\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ * @return the trie clone\n+ * @draft ICU 63\n+ */\n+U_CAPI UMutableCPTrie * U_EXPORT2\n+umutablecptrie_clone(const UMutableCPTrie *other, UErrorCode *pErrorCode);\n+\n+/**\n+ * Closes a mutable trie and releases associated memory.\n+ *\n+ * @param trie the trie\n+ * @draft ICU 63\n+ */\n+U_CAPI void U_EXPORT2\n+umutablecptrie_close(UMutableCPTrie *trie);\n+\n+#if U_SHOW_CPLUSPLUS_API\n+\n+U_NAMESPACE_BEGIN\n+\n+/**\n+ * \\class LocalUMutableCPTriePointer\n+ * \"Smart pointer\" class, closes a UMutableCPTrie via umutablecptrie_close().\n+ * For most methods see the LocalPointerBase base class.\n+ *\n+ * @see LocalPointerBase\n+ * @see LocalPointer\n+ * @draft ICU 63\n+ */\n+U_DEFINE_LOCAL_OPEN_POINTER(LocalUMutableCPTriePointer, UMutableCPTrie, umutablecptrie_close);\n+\n+U_NAMESPACE_END\n+\n+#endif\n+\n+/**\n+ * Creates a mutable trie with the same contents as the UCPMap.\n+ * You must umutablecptrie_close() the mutable trie once you are done using it.\n+ *\n+ * @param map the source map\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ * @return the mutable trie\n+ * @draft ICU 63\n+ */\n+U_CAPI UMutableCPTrie * U_EXPORT2\n+umutablecptrie_fromUCPMap(const UCPMap *map, UErrorCode *pErrorCode);\n+\n+/**\n+ * Creates a mutable trie with the same contents as the immutable one.\n+ * You must umutablecptrie_close() the mutable trie once you are done using it.\n+ *\n+ * @param trie the immutable trie\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ * @return the mutable trie\n+ * @draft ICU 63\n+ */\n+U_CAPI UMutableCPTrie * U_EXPORT2\n+umutablecptrie_fromUCPTrie(const UCPTrie *trie, UErrorCode *pErrorCode);\n+\n+/**\n+ * Returns the value for a code point as stored in the trie.\n+ *\n+ * @param trie the trie\n+ * @param c the code point\n+ * @return the value\n+ * @draft ICU 63\n+ */\n+U_CAPI uint32_t U_EXPORT2\n+umutablecptrie_get(const UMutableCPTrie *trie, UChar32 c);\n+\n+/**\n+ * Returns the last code point such that all those from start to there have the same value.\n+ * Can be used to efficiently iterate over all same-value ranges in a trie.\n+ * (This is normally faster than iterating over code points and get()ting each value,\n+ * but much slower than a data structure that stores ranges directly.)\n+ *\n+ * The trie can be modified between calls to this function.\n+ *\n+ * If the UCPMapValueFilter function pointer is not NULL, then\n+ * the value to be delivered is passed through that function, and the return value is the end\n+ * of the range where all values are modified to the same actual value.\n+ * The value is unchanged if that function pointer is NULL.\n+ *\n+ * See the same-signature ucptrie_getRange() for a code sample.\n+ *\n+ * @param trie the trie\n+ * @param start range start\n+ * @param option defines whether surrogates are treated normally,\n+ *               or as having the surrogateValue; usually UCPMAP_RANGE_NORMAL\n+ * @param surrogateValue value for surrogates; ignored if option==UCPMAP_RANGE_NORMAL\n+ * @param filter a pointer to a function that may modify the trie data value,\n+ *     or NULL if the values from the trie are to be used unmodified\n+ * @param context an opaque pointer that is passed on to the filter function\n+ * @param pValue if not NULL, receives the value that every code point start..end has;\n+ *     may have been modified by filter(context, trie value)\n+ *     if that function pointer is not NULL\n+ * @return the range end code point, or -1 if start is not a valid code point\n+ * @draft ICU 63\n+ */\n+U_CAPI UChar32 U_EXPORT2\n+umutablecptrie_getRange(const UMutableCPTrie *trie, UChar32 start,\n+                        UCPMapRangeOption option, uint32_t surrogateValue,\n+                        UCPMapValueFilter *filter, const void *context, uint32_t *pValue);\n+\n+/**\n+ * Sets a value for a code point.\n+ *\n+ * @param trie the trie\n+ * @param c the code point\n+ * @param value the value\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ * @draft ICU 63\n+ */\n+U_CAPI void U_EXPORT2\n+umutablecptrie_set(UMutableCPTrie *trie, UChar32 c, uint32_t value, UErrorCode *pErrorCode);\n+\n+/**\n+ * Sets a value for each code point [start..end].\n+ * Faster and more space-efficient than setting the value for each code point separately.\n+ *\n+ * @param trie the trie\n+ * @param start the first code point to get the value\n+ * @param end the last code point to get the value (inclusive)\n+ * @param value the value\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ * @draft ICU 63\n+ */\n+U_CAPI void U_EXPORT2\n+umutablecptrie_setRange(UMutableCPTrie *trie,\n+                        UChar32 start, UChar32 end,\n+                        uint32_t value, UErrorCode *pErrorCode);\n+\n+/**\n+ * Compacts the data and builds an immutable UCPTrie according to the parameters.\n+ * After this, the mutable trie will be empty.\n+ *\n+ * The mutable trie stores 32-bit values until buildImmutable() is called.\n+ * If values shorter than 32 bits are to be stored in the immutable trie,\n+ * then the upper bits are discarded.\n+ * For example, when the mutable trie contains values 0x81, -0x7f, and 0xa581,\n+ * and the value width is 8 bits, then each of these is stored as 0x81\n+ * and the immutable trie will return that as an unsigned value.\n+ * (Some implementations may want to make productive temporary use of the upper bits\n+ * until buildImmutable() discards them.)\n+ *\n+ * Not every possible set of mappings can be built into a UCPTrie,\n+ * because of limitations resulting from speed and space optimizations.\n+ * Every Unicode assigned character can be mapped to a unique value.\n+ * Typical data yields data structures far smaller than the limitations.\n+ *\n+ * It is possible to construct extremely unusual mappings that exceed the data structure limits.\n+ * In such a case this function will fail with a U_INDEX_OUTOFBOUNDS_ERROR.\n+ *\n+ * @param trie the trie trie\n+ * @param type selects the trie type\n+ * @param valueWidth selects the number of bits in a trie data value; if smaller than 32 bits,\n+ *                   then the values stored in the trie will be truncated first\n+ * @param pErrorCode an in/out ICU UErrorCode\n+ *\n+ * @see umutablecptrie_fromUCPTrie\n+ * @draft ICU 63\n+ */\n+U_CAPI UCPTrie * U_EXPORT2\n+umutablecptrie_buildImmutable(UMutableCPTrie *trie, UCPTrieType type, UCPTrieValueWidth valueWidth,\n+                              UErrorCode *pErrorCode);\n+\n+U_CDECL_END\n+\n+#endif  // U_HIDE_DRAFT_API\n+#endif"
        },
        {
            "sha": "2ab2695a8780d7879d746df5f491fd96578b0d7d",
            "filename": "deps/icu-small/source/common/unicode/uniset.h",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funiset.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funiset.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funiset.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -13,6 +13,7 @@\n #ifndef UNICODESET_H\n #define UNICODESET_H\n \n+#include \"unicode/ucpmap.h\"\n #include \"unicode/unifilt.h\"\n #include \"unicode/unistr.h\"\n #include \"unicode/uset.h\"\n@@ -25,9 +26,8 @@\n U_NAMESPACE_BEGIN\n \n // Forward Declarations.\n-void U_CALLCONV UnicodeSet_initInclusion(int32_t src, UErrorCode &status); /**< @internal */\n-\n class BMPSet;\n+class CharacterProperties;\n class ParsePosition;\n class RBBIRuleScanner;\n class SymbolTable;\n@@ -584,9 +584,8 @@ class U_COMMON_API UnicodeSet U_FINAL : public UnicodeFilter {\n     //----------------------------------------------------------------\n \n     /**\n-     * Make this object represent the range <code>start - end</code>.\n-     * If <code>end > start</code> then this object is set to an\n-     * an empty range.\n+     * Make this object represent the range `start - end`.\n+     * If `end > start` then this object is set to an empty range.\n      * A frozen set will not be modified.\n      *\n      * @param start first character in the set, inclusive\n@@ -1506,6 +1505,7 @@ class U_COMMON_API UnicodeSet U_FINAL : public UnicodeFilter {\n     //----------------------------------------------------------------\n \n     UnicodeSet(const UnicodeSet& o, UBool /* asThawed */);\n+    UnicodeSet& copyFrom(const UnicodeSet& o, UBool asThawed);\n \n     //----------------------------------------------------------------\n     // Implementation: Pattern parsing\n@@ -1614,7 +1614,7 @@ class U_COMMON_API UnicodeSet U_FINAL : public UnicodeFilter {\n                               UnicodeString& rebuiltPat,\n                               UErrorCode& ec);\n \n-    friend void U_CALLCONV UnicodeSet_initInclusion(int32_t src, UErrorCode &status);\n+    friend class CharacterProperties;\n     static const UnicodeSet* getInclusions(int32_t src, UErrorCode &status);\n \n     /**\n@@ -1634,9 +1634,15 @@ class U_COMMON_API UnicodeSet U_FINAL : public UnicodeFilter {\n      */\n     void applyFilter(Filter filter,\n                      void* context,\n-                     int32_t src,\n+                     const UnicodeSet* inclusions,\n                      UErrorCode &status);\n \n+#ifndef U_HIDE_DRAFT_API   // Skipped: ucpmap.h is draft only.\n+    void applyIntPropertyValue(const UCPMap *map,\n+                               UCPMapValueFilter *filter, const void *context,\n+                               UErrorCode &errorCode);\n+#endif  /* U_HIDE_DRAFT_API */\n+\n     /**\n      * Set the new pattern to cache.\n      */"
        },
        {
            "sha": "bf954b5f1d82321e0cdce7932b632413de54f865",
            "filename": "deps/icu-small/source/common/unicode/unistr.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funistr.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funistr.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Funistr.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -243,6 +243,9 @@ class UnicodeStringAppendable;  // unicode/appendable.h\n  * than other ICU APIs. In particular:\n  * - If indexes are out of bounds for a UnicodeString object\n  *   (<0 or >length()) then they are \"pinned\" to the nearest boundary.\n+ * - If the buffer passed to an insert/append/replace operation is owned by the\n+ *   target object, e.g., calling str.append(str), an extra copy may take place\n+ *   to ensure safety.\n  * - If primitive string pointer values (e.g., const char16_t * or char *)\n  *   for input strings are NULL, then those input string parameters are treated\n  *   as if they pointed to an empty string."
        },
        {
            "sha": "f7a7b6eddbc96bf2e3a7d40a600672f380778c18",
            "filename": "deps/icu-small/source/common/unicode/uobject.h",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuobject.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuobject.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuobject.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -27,7 +27,6 @@\n  */\n \n /**\n- * @{\n  * \\def U_NO_THROW\n  *         Define this to define the throw() specification so\n  *                 certain functions do not throw any exceptions\n@@ -44,8 +43,6 @@\n #define U_NO_THROW throw()\n #endif\n \n-/** @} */\n-\n /*===========================================================================*/\n /* UClassID-based RTTI */\n /*===========================================================================*/"
        },
        {
            "sha": "5812173e39cfd277c5cbdffbbeb5a065d2961c5f",
            "filename": "deps/icu-small/source/common/unicode/urename.h",
            "status": "modified",
            "additions": 37,
            "deletions": 5,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Furename.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Furename.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Furename.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -33,6 +33,9 @@\n \n #if !U_DISABLE_RENAMING\n \n+// Disable Renaming for Visual Studio's IntelliSense feature, so that 'Go-to-Definition' (F12) will work.\n+#if !(defined(_MSC_VER) && defined(__INTELLISENSE__))\n+\n /* We need the U_ICU_ENTRY_POINT_RENAME definition. There's a default one in unicode/uvernum.h we can use, but we will give\n    the platform a chance to define it first.\n    Normally (if utypes.h or umachine.h was included first) this will not be necessary as it will already be defined.\n@@ -107,6 +110,7 @@\n #define _UTF7Data U_ICU_ENTRY_POINT_RENAME(_UTF7Data)\n #define _UTF8Data U_ICU_ENTRY_POINT_RENAME(_UTF8Data)\n #define allowedHourFormatsCleanup U_ICU_ENTRY_POINT_RENAME(allowedHourFormatsCleanup)\n+#define checkImpl U_ICU_ENTRY_POINT_RENAME(checkImpl)\n #define cmemory_cleanup U_ICU_ENTRY_POINT_RENAME(cmemory_cleanup)\n #define dayPeriodRulesCleanup U_ICU_ENTRY_POINT_RENAME(dayPeriodRulesCleanup)\n #define deleteAllowedHourFormats U_ICU_ENTRY_POINT_RENAME(deleteAllowedHourFormats)\n@@ -253,12 +257,14 @@\n #define u_fstropen U_ICU_ENTRY_POINT_RENAME(u_fstropen)\n #define u_fungetc U_ICU_ENTRY_POINT_RENAME(u_fungetc)\n #define u_getBidiPairedBracket U_ICU_ENTRY_POINT_RENAME(u_getBidiPairedBracket)\n+#define u_getBinaryPropertySet U_ICU_ENTRY_POINT_RENAME(u_getBinaryPropertySet)\n #define u_getCombiningClass U_ICU_ENTRY_POINT_RENAME(u_getCombiningClass)\n #define u_getDataDirectory U_ICU_ENTRY_POINT_RENAME(u_getDataDirectory)\n #define u_getDataVersion U_ICU_ENTRY_POINT_RENAME(u_getDataVersion)\n #define u_getDefaultConverter U_ICU_ENTRY_POINT_RENAME(u_getDefaultConverter)\n #define u_getFC_NFKC_Closure U_ICU_ENTRY_POINT_RENAME(u_getFC_NFKC_Closure)\n #define u_getISOComment U_ICU_ENTRY_POINT_RENAME(u_getISOComment)\n+#define u_getIntPropertyMap U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyMap)\n #define u_getIntPropertyMaxValue U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyMaxValue)\n #define u_getIntPropertyMinValue U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyMinValue)\n #define u_getIntPropertyValue U_ICU_ENTRY_POINT_RENAME(u_getIntPropertyValue)\n@@ -763,6 +769,20 @@\n #define ucol_swap U_ICU_ENTRY_POINT_RENAME(ucol_swap)\n #define ucol_swapInverseUCA U_ICU_ENTRY_POINT_RENAME(ucol_swapInverseUCA)\n #define ucol_tertiaryOrder U_ICU_ENTRY_POINT_RENAME(ucol_tertiaryOrder)\n+#define ucpmap_get U_ICU_ENTRY_POINT_RENAME(ucpmap_get)\n+#define ucpmap_getRange U_ICU_ENTRY_POINT_RENAME(ucpmap_getRange)\n+#define ucptrie_close U_ICU_ENTRY_POINT_RENAME(ucptrie_close)\n+#define ucptrie_get U_ICU_ENTRY_POINT_RENAME(ucptrie_get)\n+#define ucptrie_getRange U_ICU_ENTRY_POINT_RENAME(ucptrie_getRange)\n+#define ucptrie_getType U_ICU_ENTRY_POINT_RENAME(ucptrie_getType)\n+#define ucptrie_getValueWidth U_ICU_ENTRY_POINT_RENAME(ucptrie_getValueWidth)\n+#define ucptrie_internalGetRange U_ICU_ENTRY_POINT_RENAME(ucptrie_internalGetRange)\n+#define ucptrie_internalSmallIndex U_ICU_ENTRY_POINT_RENAME(ucptrie_internalSmallIndex)\n+#define ucptrie_internalSmallU8Index U_ICU_ENTRY_POINT_RENAME(ucptrie_internalSmallU8Index)\n+#define ucptrie_internalU8PrevIndex U_ICU_ENTRY_POINT_RENAME(ucptrie_internalU8PrevIndex)\n+#define ucptrie_openFromBinary U_ICU_ENTRY_POINT_RENAME(ucptrie_openFromBinary)\n+#define ucptrie_swap U_ICU_ENTRY_POINT_RENAME(ucptrie_swap)\n+#define ucptrie_toBinary U_ICU_ENTRY_POINT_RENAME(ucptrie_toBinary)\n #define ucsdet_close U_ICU_ENTRY_POINT_RENAME(ucsdet_close)\n #define ucsdet_detect U_ICU_ENTRY_POINT_RENAME(ucsdet_detect)\n #define ucsdet_detectAll U_ICU_ENTRY_POINT_RENAME(ucsdet_detectAll)\n@@ -1079,6 +1099,7 @@\n #define ulocdata_getPaperSize U_ICU_ENTRY_POINT_RENAME(ulocdata_getPaperSize)\n #define ulocdata_open U_ICU_ENTRY_POINT_RENAME(ulocdata_open)\n #define ulocdata_setNoSubstitute U_ICU_ENTRY_POINT_RENAME(ulocdata_setNoSubstitute)\n+#define ulocimp_forLanguageTag U_ICU_ENTRY_POINT_RENAME(ulocimp_forLanguageTag)\n #define ulocimp_getCountry U_ICU_ENTRY_POINT_RENAME(ulocimp_getCountry)\n #define ulocimp_getLanguage U_ICU_ENTRY_POINT_RENAME(ulocimp_getLanguage)\n #define ulocimp_getRegionForSupplementalData U_ICU_ENTRY_POINT_RENAME(ulocimp_getRegionForSupplementalData)\n@@ -1106,6 +1127,16 @@\n #define umtx_condWait U_ICU_ENTRY_POINT_RENAME(umtx_condWait)\n #define umtx_lock U_ICU_ENTRY_POINT_RENAME(umtx_lock)\n #define umtx_unlock U_ICU_ENTRY_POINT_RENAME(umtx_unlock)\n+#define umutablecptrie_buildImmutable U_ICU_ENTRY_POINT_RENAME(umutablecptrie_buildImmutable)\n+#define umutablecptrie_clone U_ICU_ENTRY_POINT_RENAME(umutablecptrie_clone)\n+#define umutablecptrie_close U_ICU_ENTRY_POINT_RENAME(umutablecptrie_close)\n+#define umutablecptrie_fromUCPMap U_ICU_ENTRY_POINT_RENAME(umutablecptrie_fromUCPMap)\n+#define umutablecptrie_fromUCPTrie U_ICU_ENTRY_POINT_RENAME(umutablecptrie_fromUCPTrie)\n+#define umutablecptrie_get U_ICU_ENTRY_POINT_RENAME(umutablecptrie_get)\n+#define umutablecptrie_getRange U_ICU_ENTRY_POINT_RENAME(umutablecptrie_getRange)\n+#define umutablecptrie_open U_ICU_ENTRY_POINT_RENAME(umutablecptrie_open)\n+#define umutablecptrie_set U_ICU_ENTRY_POINT_RENAME(umutablecptrie_set)\n+#define umutablecptrie_setRange U_ICU_ENTRY_POINT_RENAME(umutablecptrie_setRange)\n #define uniset_getUnicode32Instance U_ICU_ENTRY_POINT_RENAME(uniset_getUnicode32Instance)\n #define unorm2_append U_ICU_ENTRY_POINT_RENAME(unorm2_append)\n #define unorm2_close U_ICU_ENTRY_POINT_RENAME(unorm2_close)\n@@ -1218,6 +1249,7 @@\n #define uplug_setPlugLevel U_ICU_ENTRY_POINT_RENAME(uplug_setPlugLevel)\n #define uplug_setPlugName U_ICU_ENTRY_POINT_RENAME(uplug_setPlugName)\n #define uplug_setPlugNoUnload U_ICU_ENTRY_POINT_RENAME(uplug_setPlugNoUnload)\n+#define uprops_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(uprops_addPropertyStarts)\n #define uprops_getSource U_ICU_ENTRY_POINT_RENAME(uprops_getSource)\n #define upropsvec_addPropertyStarts U_ICU_ENTRY_POINT_RENAME(upropsvec_addPropertyStarts)\n #define uprv_add32_overflow U_ICU_ENTRY_POINT_RENAME(uprv_add32_overflow)\n@@ -1236,6 +1268,7 @@\n #define uprv_convertToPosix U_ICU_ENTRY_POINT_RENAME(uprv_convertToPosix)\n #define uprv_copyAscii U_ICU_ENTRY_POINT_RENAME(uprv_copyAscii)\n #define uprv_copyEbcdic U_ICU_ENTRY_POINT_RENAME(uprv_copyEbcdic)\n+#define uprv_currencyLeads U_ICU_ENTRY_POINT_RENAME(uprv_currencyLeads)\n #define uprv_decContextClearStatus U_ICU_ENTRY_POINT_RENAME(uprv_decContextClearStatus)\n #define uprv_decContextDefault U_ICU_ENTRY_POINT_RENAME(uprv_decContextDefault)\n #define uprv_decContextGetRounding U_ICU_ENTRY_POINT_RENAME(uprv_decContextGetRounding)\n@@ -1329,7 +1362,6 @@\n #define uprv_fmod U_ICU_ENTRY_POINT_RENAME(uprv_fmod)\n #define uprv_free U_ICU_ENTRY_POINT_RENAME(uprv_free)\n #define uprv_getCharNameCharacters U_ICU_ENTRY_POINT_RENAME(uprv_getCharNameCharacters)\n-#define uprv_getDefaultCodepage U_ICU_ENTRY_POINT_RENAME(uprv_getDefaultCodepage)\n #define uprv_getDefaultLocaleID U_ICU_ENTRY_POINT_RENAME(uprv_getDefaultLocaleID)\n #define uprv_getInfinity U_ICU_ENTRY_POINT_RENAME(uprv_getInfinity)\n #define uprv_getMaxCharNameLength U_ICU_ENTRY_POINT_RENAME(uprv_getMaxCharNameLength)\n@@ -1754,7 +1786,6 @@\n #define utrie2_fromUTrie U_ICU_ENTRY_POINT_RENAME(utrie2_fromUTrie)\n #define utrie2_get32 U_ICU_ENTRY_POINT_RENAME(utrie2_get32)\n #define utrie2_get32FromLeadSurrogateCodeUnit U_ICU_ENTRY_POINT_RENAME(utrie2_get32FromLeadSurrogateCodeUnit)\n-#define utrie2_getVersion U_ICU_ENTRY_POINT_RENAME(utrie2_getVersion)\n #define utrie2_internalU8NextIndex U_ICU_ENTRY_POINT_RENAME(utrie2_internalU8NextIndex)\n #define utrie2_internalU8PrevIndex U_ICU_ENTRY_POINT_RENAME(utrie2_internalU8PrevIndex)\n #define utrie2_isFrozen U_ICU_ENTRY_POINT_RENAME(utrie2_isFrozen)\n@@ -1766,7 +1797,6 @@\n #define utrie2_set32ForLeadSurrogateCodeUnit U_ICU_ENTRY_POINT_RENAME(utrie2_set32ForLeadSurrogateCodeUnit)\n #define utrie2_setRange32 U_ICU_ENTRY_POINT_RENAME(utrie2_setRange32)\n #define utrie2_swap U_ICU_ENTRY_POINT_RENAME(utrie2_swap)\n-#define utrie2_swapAnyVersion U_ICU_ENTRY_POINT_RENAME(utrie2_swapAnyVersion)\n #define utrie_clone U_ICU_ENTRY_POINT_RENAME(utrie_clone)\n #define utrie_close U_ICU_ENTRY_POINT_RENAME(utrie_close)\n #define utrie_defaultGetFoldingOffset U_ICU_ENTRY_POINT_RENAME(utrie_defaultGetFoldingOffset)\n@@ -1778,6 +1808,7 @@\n #define utrie_set32 U_ICU_ENTRY_POINT_RENAME(utrie_set32)\n #define utrie_setRange32 U_ICU_ENTRY_POINT_RENAME(utrie_setRange32)\n #define utrie_swap U_ICU_ENTRY_POINT_RENAME(utrie_swap)\n+#define utrie_swapAnyVersion U_ICU_ENTRY_POINT_RENAME(utrie_swapAnyVersion)\n #define utrie_unserialize U_ICU_ENTRY_POINT_RENAME(utrie_unserialize)\n #define utrie_unserializeDummy U_ICU_ENTRY_POINT_RENAME(utrie_unserializeDummy)\n #define vzone_clone U_ICU_ENTRY_POINT_RENAME(vzone_clone)\n@@ -1827,6 +1858,7 @@\n #define ztrans_setTime U_ICU_ENTRY_POINT_RENAME(ztrans_setTime)\n #define ztrans_setTo U_ICU_ENTRY_POINT_RENAME(ztrans_setTo)\n \n-#endif\n+#endif /* !(defined(_MSC_VER) && defined(__INTELLISENSE__)) */\n+#endif /* U_DISABLE_RENAMING */\n+#endif /* URENAME_H */\n \n-#endif"
        },
        {
            "sha": "ef6bbb5c38f3fb8ecd635298dc3aed03326a626f",
            "filename": "deps/icu-small/source/common/unicode/uset.h",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuset.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuset.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuset.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -33,10 +33,14 @@\n #include \"unicode/uchar.h\"\n #include \"unicode/localpointer.h\"\n \n-#ifndef UCNV_H\n-struct USet;\n+#ifndef USET_DEFINED\n+\n+#ifndef U_IN_DOXYGEN\n+#define USET_DEFINED\n+#endif\n /**\n- * A UnicodeSet.  Use the uset_* API to manipulate.  Create with\n+ * USet is the C API type corresponding to C++ class UnicodeSet.\n+ * Use the uset_* API to manipulate.  Create with\n  * uset_open*, and destroy with uset_close.\n  * @stable ICU 2.4\n  */"
        },
        {
            "sha": "0d2274a0cabb513fee2b721f27f094586811659f",
            "filename": "deps/icu-small/source/common/unicode/ustring.h",
            "status": "modified",
            "additions": 18,
            "deletions": 21,
            "changes": 39,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fustring.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fustring.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fustring.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -895,34 +895,31 @@ u_memrchr32(const UChar *s, UChar32 c, int32_t count);\n  * parameters.\n  * The string parameter must be a C string literal.\n  * The length of the string, not including the terminating\n- * <code>NUL</code>, must be specified as a constant.\n+ * `NUL`, must be specified as a constant.\n  * The U_STRING_DECL macro should be invoked exactly once for one\n  * such string variable before it is used.\n  *\n  * Usage:\n- * <pre>\n- *    U_STRING_DECL(ustringVar1, \"Quick-Fox 2\", 11);\n- *    U_STRING_DECL(ustringVar2, \"jumps 5%\", 8);\n- *    static UBool didInit=FALSE;\n- *\n- *    int32_t function() {\n- *        if(!didInit) {\n- *            U_STRING_INIT(ustringVar1, \"Quick-Fox 2\", 11);\n- *            U_STRING_INIT(ustringVar2, \"jumps 5%\", 8);\n- *            didInit=TRUE;\n- *        }\n- *        return u_strcmp(ustringVar1, ustringVar2);\n- *    }\n- * </pre>\n- *\n- * Note that the macros will NOT consistently work if their argument is another <code>#define</code>.\n- *  The following will not work on all platforms, don't use it.\n- *\n- * <pre>\n+ *\n+ *     U_STRING_DECL(ustringVar1, \"Quick-Fox 2\", 11);\n+ *     U_STRING_DECL(ustringVar2, \"jumps 5%\", 8);\n+ *     static UBool didInit=FALSE;\n+ *\n+ *     int32_t function() {\n+ *         if(!didInit) {\n+ *             U_STRING_INIT(ustringVar1, \"Quick-Fox 2\", 11);\n+ *             U_STRING_INIT(ustringVar2, \"jumps 5%\", 8);\n+ *             didInit=TRUE;\n+ *         }\n+ *         return u_strcmp(ustringVar1, ustringVar2);\n+ *     }\n+ *\n+ * Note that the macros will NOT consistently work if their argument is another #`define`.\n+ * The following will not work on all platforms, don't use it.\n+ *\n  *     #define GLUCK \"Mr. Gluck\"\n  *     U_STRING_DECL(var, GLUCK, 9)\n  *     U_STRING_INIT(var, GLUCK, 9)\n- * </pre>\n  *\n  * Instead, use the string literal \"Mr. Gluck\"  as the argument to both macro\n  * calls."
        },
        {
            "sha": "0908b4f00e9bf1b067e141fc1a30ddf0e577f774",
            "filename": "deps/icu-small/source/common/unicode/utf16.h",
            "status": "modified",
            "additions": 3,
            "deletions": 15,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futf16.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futf16.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futf16.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -213,8 +213,6 @@\n     } \\\n }\n \n-#ifndef U_HIDE_DRAFT_API\n-\n /**\n  * Get a code point from a string at a random-access offset,\n  * without changing the offset.\n@@ -236,7 +234,7 @@\n  * @param length string length\n  * @param c output UChar32 variable\n  * @see U16_GET_UNSAFE\n- * @draft ICU 60\n+ * @stable ICU 60\n  */\n #define U16_GET_OR_FFFD(s, start, i, length, c) { \\\n     (c)=(s)[i]; \\\n@@ -258,8 +256,6 @@\n     } \\\n }\n \n-#endif  // U_HIDE_DRAFT_API\n-\n /* definitions with forward iteration --------------------------------------- */\n \n /**\n@@ -320,8 +316,6 @@\n     } \\\n }\n \n-#ifndef U_HIDE_DRAFT_API\n-\n /**\n  * Get a code point from a string at a code point boundary offset,\n  * and advance the offset to the next code point boundary.\n@@ -341,7 +335,7 @@\n  * @param length string length\n  * @param c output UChar32 variable\n  * @see U16_NEXT_UNSAFE\n- * @draft ICU 60\n+ * @stable ICU 60\n  */\n #define U16_NEXT_OR_FFFD(s, i, length, c) { \\\n     (c)=(s)[(i)++]; \\\n@@ -356,8 +350,6 @@\n     } \\\n }\n \n-#endif  // U_HIDE_DRAFT_API\n-\n /**\n  * Append a code point to a string, overwriting 1 or 2 code units.\n  * The offset points to the current end of the string contents\n@@ -585,8 +577,6 @@\n     } \\\n }\n \n-#ifndef U_HIDE_DRAFT_API\n-\n /**\n  * Move the string offset from one code point boundary to the previous one\n  * and get the code point between them.\n@@ -605,7 +595,7 @@\n  * @param i string offset, must be start<i\n  * @param c output UChar32 variable\n  * @see U16_PREV_UNSAFE\n- * @draft ICU 60\n+ * @stable ICU 60\n  */\n #define U16_PREV_OR_FFFD(s, start, i, c) { \\\n     (c)=(s)[--(i)]; \\\n@@ -620,8 +610,6 @@\n     } \\\n }\n \n-#endif  // U_HIDE_DRAFT_API\n-\n /**\n  * Move the string offset from one code point boundary to the previous one.\n  * (Pre-decrementing backward iteration.)"
        },
        {
            "sha": "f1814e06498da2ca8b46aca3eb7dcf5ee2e6678b",
            "filename": "deps/icu-small/source/common/unicode/utypes.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futypes.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futypes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Futypes.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -290,6 +290,11 @@ typedef double UDate;\n  * @stable ICU 3.4\n  */\n \n+#ifdef U_IN_DOXYGEN\n+// This definition is required when generating the API docs.\n+#define U_COMBINED_IMPLEMENTATION 1\n+#endif\n+\n #if defined(U_COMBINED_IMPLEMENTATION)\n #define U_DATA_API     U_EXPORT\n #define U_COMMON_API   U_EXPORT"
        },
        {
            "sha": "83d0b4ecd1c8a0d3f01b59102ce677457de82db8",
            "filename": "deps/icu-small/source/common/unicode/uvernum.h",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuvernum.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuvernum.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funicode%2Fuvernum.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -34,9 +34,11 @@\n   *  by running the UNIX makefile target 'update-windows-makefiles' in icu/source.\n   *\n   *\n+  * source/common/common_uwp.vcxproj\n   * source/common/common.vcxproj - update 'Output file name' on the link tab so\n   *                   that it contains the new major/minor combination\n   * source/i18n/i18n.vcxproj - same as for the common.vcxproj\n+  * source/i18n/i18n_uwp.vcxproj - same as for the common_uwp.vcxproj\n   * source/layoutex/layoutex.vcproj - same\n   * source/stubdata/stubdata.vcproj - same as for the common.vcxproj\n   * source/io/io.vcproj - same as for the common.vcxproj\n@@ -58,7 +60,7 @@\n  *  This value will change in the subsequent releases of ICU\n  *  @stable ICU 2.4\n  */\n-#define U_ICU_VERSION_MAJOR_NUM 62\n+#define U_ICU_VERSION_MAJOR_NUM 63\n \n /** The current ICU minor version as an integer.\n  *  This value will change in the subsequent releases of ICU\n@@ -84,7 +86,7 @@\n  *  This value will change in the subsequent releases of ICU\n  *  @stable ICU 2.6\n  */\n-#define U_ICU_VERSION_SUFFIX _62\n+#define U_ICU_VERSION_SUFFIX _63\n \n /**\n  * \\def U_DEF2_ICU_ENTRY_POINT_RENAME\n@@ -119,7 +121,7 @@\n  *  This value will change in the subsequent releases of ICU\n  *  @stable ICU 2.4\n  */\n-#define U_ICU_VERSION \"62.1\"\n+#define U_ICU_VERSION \"63.1\"\n \n /**\n  * The current ICU library major version number as a string, for library name suffixes.\n@@ -132,13 +134,13 @@\n  *\n  * @stable ICU 2.6\n  */\n-#define U_ICU_VERSION_SHORT \"62\"\n+#define U_ICU_VERSION_SHORT \"63\"\n \n #ifndef U_HIDE_INTERNAL_API\n /** Data version in ICU4C.\n  * @internal ICU 4.4 Internal Use Only\n  **/\n-#define U_ICU_DATA_VERSION \"62.1\"\n+#define U_ICU_DATA_VERSION \"63.1\"\n #endif  /* U_HIDE_INTERNAL_API */\n \n /*==========================================================================="
        },
        {
            "sha": "d33d8d2c01c0e510afdd5d53a9f7e53785a990a3",
            "filename": "deps/icu-small/source/common/unifiedcache.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funifiedcache.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funifiedcache.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funifiedcache.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -251,7 +251,7 @@ UBool UnifiedCache::_flush(UBool all) const {\n         if (all || _isEvictable(element)) {\n             const SharedObject *sharedObject =\n                     (const SharedObject *) element->value.pointer;\n-            U_ASSERT(sharedObject->cachePtr = this);\n+            U_ASSERT(sharedObject->cachePtr == this);\n             uhash_removeElement(fHashtable, element);\n             removeSoftRef(sharedObject);    // Deletes the sharedObject when softRefCount goes to zero.\n             result = TRUE;"
        },
        {
            "sha": "7d2e3cd619fc1d0f6b85044439af70d37d2ce968",
            "filename": "deps/icu-small/source/common/uniset.cpp",
            "status": "modified",
            "additions": 22,
            "deletions": 10,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -152,6 +152,7 @@ UnicodeSet::UnicodeSet() :\n     UErrorCode status = U_ZERO_ERROR;\n     allocateStrings(status);\n     if (U_FAILURE(status)) {\n+        setToBogus(); // If memory allocation failed, set to bogus state.\n         return;\n     }\n     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);\n@@ -179,6 +180,7 @@ UnicodeSet::UnicodeSet(UChar32 start, UChar32 end) :\n     UErrorCode status = U_ZERO_ERROR;\n     allocateStrings(status);\n     if (U_FAILURE(status)) {\n+        setToBogus(); // If memory allocation failed, set to bogus state.\n         return;\n     }\n     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);\n@@ -206,6 +208,7 @@ UnicodeSet::UnicodeSet(const UnicodeSet& o) :\n     UErrorCode status = U_ZERO_ERROR;\n     allocateStrings(status);\n     if (U_FAILURE(status)) {\n+        setToBogus(); // If memory allocation failed, set to bogus state.\n         return;\n     }\n     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);\n@@ -230,6 +233,7 @@ UnicodeSet::UnicodeSet(const UnicodeSet& o, UBool /* asThawed */) :\n     UErrorCode status = U_ZERO_ERROR;\n     allocateStrings(status);\n     if (U_FAILURE(status)) {\n+        setToBogus(); // If memory allocation failed, set to bogus state.\n         return;\n     }\n     list = (UChar32*) uprv_malloc(sizeof(UChar32) * capacity);\n@@ -272,6 +276,10 @@ UnicodeSet::~UnicodeSet() {\n  * Assigns this object to be a copy of another.\n  */\n UnicodeSet& UnicodeSet::operator=(const UnicodeSet& o) {\n+    return copyFrom(o, FALSE);\n+}\n+\n+UnicodeSet& UnicodeSet::copyFrom(const UnicodeSet& o, UBool asThawed) {\n     if (this == &o) {\n         return *this;\n     }\n@@ -285,11 +293,12 @@ UnicodeSet& UnicodeSet::operator=(const UnicodeSet& o) {\n     UErrorCode ec = U_ZERO_ERROR;\n     ensureCapacity(o.len, ec);\n     if (U_FAILURE(ec)) {\n-        return *this; // There is no way to report this error :-(\n+        // ensureCapacity will mark the UnicodeSet as Bogus if OOM failure happens.\n+        return *this;\n     }\n     len = o.len;\n     uprv_memcpy(list, o.list, (size_t)len*sizeof(UChar32));\n-    if (o.bmpSet == NULL) {\n+    if (o.bmpSet == NULL || asThawed) {\n         bmpSet = NULL;\n     } else {\n         bmpSet = new BMPSet(*o.bmpSet, list, len);\n@@ -304,7 +313,7 @@ UnicodeSet& UnicodeSet::operator=(const UnicodeSet& o) {\n         setToBogus();\n         return *this;\n     }\n-    if (o.stringSpan == NULL) {\n+    if (o.stringSpan == NULL || asThawed) {\n         stringSpan = NULL;\n     } else {\n         stringSpan = new UnicodeSetStringSpan(*o.stringSpan, *strings);\n@@ -359,12 +368,12 @@ UBool UnicodeSet::operator==(const UnicodeSet& o) const {\n  * @see Object#hashCode()\n  */\n int32_t UnicodeSet::hashCode(void) const {\n-    int32_t result = len;\n+    uint32_t result = static_cast<uint32_t>(len);\n     for (int32_t i = 0; i < len; ++i) {\n-        result *= 1000003;\n+        result *= 1000003u;\n         result += list[i];\n     }\n-    return result;\n+    return static_cast<int32_t>(result);\n }\n \n //----------------------------------------------------------------\n@@ -912,7 +921,8 @@ UnicodeSet& UnicodeSet::add(UChar32 c) {\n             UErrorCode status = U_ZERO_ERROR;\n             ensureCapacity(len+1, status);\n             if (U_FAILURE(status)) {\n-                return *this; // There is no way to report this error :-(\n+                // ensureCapacity will mark the object as Bogus if OOM failure happens.\n+                return *this;\n             }\n             list[len++] = UNICODESET_HIGH;\n         }\n@@ -957,7 +967,8 @@ UnicodeSet& UnicodeSet::add(UChar32 c) {\n         UErrorCode status = U_ZERO_ERROR;\n         ensureCapacity(len+2, status);\n         if (U_FAILURE(status)) {\n-            return *this; // There is no way to report this error :-(\n+            // ensureCapacity will mark the object as Bogus if OOM failure happens.\n+            return *this;\n         }\n \n         //for (int32_t k=len-1; k>=i; --k) {\n@@ -1654,12 +1665,13 @@ UBool UnicodeSet::allocateStrings(UErrorCode &status) {\n }\n \n void UnicodeSet::ensureCapacity(int32_t newLen, UErrorCode& ec) {\n-    if (newLen <= capacity)\n+    if (newLen <= capacity) {\n         return;\n+    }\n     UChar32* temp = (UChar32*) uprv_realloc(list, sizeof(UChar32) * (newLen + GROW_EXTRA));\n     if (temp == NULL) {\n         ec = U_MEMORY_ALLOCATION_ERROR;\n-        setToBogus();\n+        setToBogus(); // set the object to bogus state if an OOM failure occurred.\n         return;\n     }\n     list = temp;"
        },
        {
            "sha": "1312de209802b54afd05462c88a61bff3645ebce",
            "filename": "deps/icu-small/source/common/uniset_props.cpp",
            "status": "modified",
            "additions": 73,
            "deletions": 178,
            "changes": 251,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset_props.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset_props.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funiset_props.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -36,8 +36,6 @@\n #include \"uprops.h\"\n #include \"propname.h\"\n #include \"normalizer2impl.h\"\n-#include \"ucase.h\"\n-#include \"ubidi_props.h\"\n #include \"uinvchar.h\"\n #include \"uprops.h\"\n #include \"charstr.h\"\n@@ -98,47 +96,13 @@ static const char ASSIGNED[] = \"Assigned\"; // [:^Cn:]\n U_CDECL_BEGIN\n static UBool U_CALLCONV uset_cleanup();\n \n-struct Inclusion {\n-    UnicodeSet  *fSet;\n-    UInitOnce    fInitOnce;\n-};\n-static Inclusion gInclusions[UPROPS_SRC_COUNT]; // cached getInclusions()\n-\n static UnicodeSet *uni32Singleton;\n static icu::UInitOnce uni32InitOnce = U_INITONCE_INITIALIZER;\n \n-//----------------------------------------------------------------\n-// Inclusions list\n-//----------------------------------------------------------------\n-\n-// USetAdder implementation\n-// Does not use uset.h to reduce code dependencies\n-static void U_CALLCONV\n-_set_add(USet *set, UChar32 c) {\n-    ((UnicodeSet *)set)->add(c);\n-}\n-\n-static void U_CALLCONV\n-_set_addRange(USet *set, UChar32 start, UChar32 end) {\n-    ((UnicodeSet *)set)->add(start, end);\n-}\n-\n-static void U_CALLCONV\n-_set_addString(USet *set, const UChar *str, int32_t length) {\n-    ((UnicodeSet *)set)->add(UnicodeString((UBool)(length<0), str, length));\n-}\n-\n /**\n  * Cleanup function for UnicodeSet\n  */\n static UBool U_CALLCONV uset_cleanup(void) {\n-    for(int32_t i = UPROPS_SRC_NONE; i < UPROPS_SRC_COUNT; ++i) {\n-        Inclusion &in = gInclusions[i];\n-        delete in.fSet;\n-        in.fSet = NULL;\n-        in.fInitOnce.reset();\n-    }\n-\n     delete uni32Singleton;\n     uni32Singleton = NULL;\n     uni32InitOnce.reset();\n@@ -149,114 +113,6 @@ U_CDECL_END\n \n U_NAMESPACE_BEGIN\n \n-/*\n-Reduce excessive reallocation, and make it easier to detect initialization problems.\n-Usually you don't see smaller sets than this for Unicode 5.0.\n-*/\n-#define DEFAULT_INCLUSION_CAPACITY 3072\n-\n-void U_CALLCONV UnicodeSet_initInclusion(int32_t src, UErrorCode &status) {\n-    // This function is invoked only via umtx_initOnce().\n-    // This function is a friend of class UnicodeSet.\n-\n-    U_ASSERT(src >=0 && src<UPROPS_SRC_COUNT);\n-    UnicodeSet * &incl = gInclusions[src].fSet;\n-    U_ASSERT(incl == NULL);\n-\n-    incl = new UnicodeSet();\n-    if (incl == NULL) {\n-        status = U_MEMORY_ALLOCATION_ERROR;\n-        return;\n-    }\n-    USetAdder sa = {\n-        (USet *)incl,\n-        _set_add,\n-        _set_addRange,\n-        _set_addString,\n-        NULL, // don't need remove()\n-        NULL // don't need removeRange()\n-    };\n-\n-    incl->ensureCapacity(DEFAULT_INCLUSION_CAPACITY, status);\n-    switch(src) {\n-    case UPROPS_SRC_CHAR:\n-        uchar_addPropertyStarts(&sa, &status);\n-        break;\n-    case UPROPS_SRC_PROPSVEC:\n-        upropsvec_addPropertyStarts(&sa, &status);\n-        break;\n-    case UPROPS_SRC_CHAR_AND_PROPSVEC:\n-        uchar_addPropertyStarts(&sa, &status);\n-        upropsvec_addPropertyStarts(&sa, &status);\n-        break;\n-#if !UCONFIG_NO_NORMALIZATION\n-    case UPROPS_SRC_CASE_AND_NORM: {\n-        const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(status);\n-        if(U_SUCCESS(status)) {\n-            impl->addPropertyStarts(&sa, status);\n-        }\n-        ucase_addPropertyStarts(&sa, &status);\n-        break;\n-    }\n-    case UPROPS_SRC_NFC: {\n-        const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(status);\n-        if(U_SUCCESS(status)) {\n-            impl->addPropertyStarts(&sa, status);\n-        }\n-        break;\n-    }\n-    case UPROPS_SRC_NFKC: {\n-        const Normalizer2Impl *impl=Normalizer2Factory::getNFKCImpl(status);\n-        if(U_SUCCESS(status)) {\n-            impl->addPropertyStarts(&sa, status);\n-        }\n-        break;\n-    }\n-    case UPROPS_SRC_NFKC_CF: {\n-        const Normalizer2Impl *impl=Normalizer2Factory::getNFKC_CFImpl(status);\n-        if(U_SUCCESS(status)) {\n-            impl->addPropertyStarts(&sa, status);\n-        }\n-        break;\n-    }\n-    case UPROPS_SRC_NFC_CANON_ITER: {\n-        const Normalizer2Impl *impl=Normalizer2Factory::getNFCImpl(status);\n-        if(U_SUCCESS(status)) {\n-            impl->addCanonIterPropertyStarts(&sa, status);\n-        }\n-        break;\n-    }\n-#endif\n-    case UPROPS_SRC_CASE:\n-        ucase_addPropertyStarts(&sa, &status);\n-        break;\n-    case UPROPS_SRC_BIDI:\n-        ubidi_addPropertyStarts(&sa, &status);\n-        break;\n-    default:\n-        status = U_INTERNAL_PROGRAM_ERROR;\n-        break;\n-    }\n-\n-    if (U_FAILURE(status)) {\n-        delete incl;\n-        incl = NULL;\n-        return;\n-    }\n-    // Compact for caching\n-    incl->compact();\n-    ucln_common_registerCleanup(UCLN_COMMON_USET, uset_cleanup);\n-}\n-\n-\n-\n-const UnicodeSet* UnicodeSet::getInclusions(int32_t src, UErrorCode &status) {\n-    U_ASSERT(src >=0 && src<UPROPS_SRC_COUNT);\n-    Inclusion &i = gInclusions[src];\n-    umtx_initOnce(i.fInitOnce, &UnicodeSet_initInclusion, src, status);\n-    return i.fSet;\n-}\n-\n namespace {\n \n // Cache some sets for other services -------------------------------------- ***\n@@ -857,11 +713,6 @@ static UBool numericValueFilter(UChar32 ch, void* context) {\n     return u_getNumericValue(ch) == *(double*)context;\n }\n \n-static UBool generalCategoryMaskFilter(UChar32 ch, void* context) {\n-    int32_t value = *(int32_t*)context;\n-    return (U_GET_GC_MASK((UChar32) ch) & value) != 0;\n-}\n-\n static UBool versionFilter(UChar32 ch, void* context) {\n     static const UVersionInfo none = { 0, 0, 0, 0 };\n     UVersionInfo v;\n@@ -870,16 +721,6 @@ static UBool versionFilter(UChar32 ch, void* context) {\n     return uprv_memcmp(&v, &none, sizeof(v)) > 0 && uprv_memcmp(&v, version, sizeof(v)) <= 0;\n }\n \n-typedef struct {\n-    UProperty prop;\n-    int32_t value;\n-} IntPropertyContext;\n-\n-static UBool intPropertyFilter(UChar32 ch, void* context) {\n-    IntPropertyContext* c = (IntPropertyContext*)context;\n-    return u_getIntPropertyValue((UChar32) ch, c->prop) == c->value;\n-}\n-\n static UBool scriptExtensionsFilter(UChar32 ch, void* context) {\n     return uscript_hasScript(ch, *(UScriptCode*)context);\n }\n@@ -891,7 +732,7 @@ static UBool scriptExtensionsFilter(UChar32 ch, void* context) {\n  */\n void UnicodeSet::applyFilter(UnicodeSet::Filter filter,\n                              void* context,\n-                             int32_t src,\n+                             const UnicodeSet* inclusions,\n                              UErrorCode &status) {\n     if (U_FAILURE(status)) return;\n \n@@ -902,12 +743,8 @@ void UnicodeSet::applyFilter(UnicodeSet::Filter filter,\n     // To improve performance, use an inclusions set which\n     // encodes information about character ranges that are known\n     // to have identical properties.\n-    // getInclusions(src) contains exactly the first characters of\n-    // same-value ranges for the given properties \"source\".\n-    const UnicodeSet* inclusions = getInclusions(src, status);\n-    if (U_FAILURE(status)) {\n-        return;\n-    }\n+    // inclusions contains the first characters of\n+    // same-value ranges for the given property.\n \n     clear();\n \n@@ -944,6 +781,43 @@ void UnicodeSet::applyFilter(UnicodeSet::Filter filter,\n \n namespace {\n \n+/** Maps map values to 1 if the mask contains their value'th bit, all others to 0. */\n+uint32_t U_CALLCONV generalCategoryMaskFilter(const void *context, uint32_t value) {\n+    uint32_t mask = *(const uint32_t *)context;\n+    value = U_MASK(value) & mask;\n+    if (value != 0) { value = 1; }\n+    return value;\n+}\n+\n+/** Maps one map value to 1, all others to 0. */\n+uint32_t U_CALLCONV intValueFilter(const void *context, uint32_t value) {\n+    uint32_t v = *(const uint32_t *)context;\n+    return value == v ? 1 : 0;\n+}\n+\n+}  // namespace\n+\n+void UnicodeSet::applyIntPropertyValue(const UCPMap *map,\n+                                       UCPMapValueFilter *filter, const void *context,\n+                                       UErrorCode &errorCode) {\n+    if (U_FAILURE(errorCode)) { return; }\n+    clear();\n+    UChar32 start = 0, end;\n+    uint32_t value;\n+    while ((end = ucpmap_getRange(map, start, UCPMAP_RANGE_NORMAL, 0,\n+                                  filter, context, &value)) >= 0) {\n+        if (value != 0) {\n+            add(start, end);\n+        }\n+        start = end + 1;\n+    }\n+    if (isBogus()) {\n+        errorCode = U_MEMORY_ALLOCATION_ERROR;\n+    }\n+}\n+\n+namespace {\n+\n static UBool mungeCharName(char* dst, const char* src, int32_t dstCapacity) {\n     /* Note: we use ' ' in compiler code page */\n     int32_t j = 0;\n@@ -971,16 +845,35 @@ static UBool mungeCharName(char* dst, const char* src, int32_t dstCapacity) {\n \n UnicodeSet&\n UnicodeSet::applyIntPropertyValue(UProperty prop, int32_t value, UErrorCode& ec) {\n-    if (U_FAILURE(ec) || isFrozen()) return *this;\n-\n+    if (U_FAILURE(ec)) { return *this; }\n+    // All of the following check isFrozen() before modifying this set.\n     if (prop == UCHAR_GENERAL_CATEGORY_MASK) {\n-        applyFilter(generalCategoryMaskFilter, &value, UPROPS_SRC_CHAR, ec);\n+        const UCPMap *map = u_getIntPropertyMap(UCHAR_GENERAL_CATEGORY, &ec);\n+        applyIntPropertyValue(map, generalCategoryMaskFilter, &value, ec);\n     } else if (prop == UCHAR_SCRIPT_EXTENSIONS) {\n+        const UnicodeSet* inclusions = CharacterProperties::getInclusionsForProperty(prop, ec);\n         UScriptCode script = (UScriptCode)value;\n-        applyFilter(scriptExtensionsFilter, &script, UPROPS_SRC_PROPSVEC, ec);\n+        applyFilter(scriptExtensionsFilter, &script, inclusions, ec);\n+    } else if (0 <= prop && prop < UCHAR_BINARY_LIMIT) {\n+        if (value == 0 || value == 1) {\n+            const USet *set = u_getBinaryPropertySet(prop, &ec);\n+            if (U_FAILURE(ec)) { return *this; }\n+            copyFrom(*UnicodeSet::fromUSet(set), TRUE);\n+            if (value == 0) {\n+                complement();\n+            }\n+        } else {\n+            clear();\n+        }\n+    } else if (UCHAR_INT_START <= prop && prop < UCHAR_INT_LIMIT) {\n+        const UCPMap *map = u_getIntPropertyMap(prop, &ec);\n+        applyIntPropertyValue(map, intValueFilter, &value, ec);\n     } else {\n-        IntPropertyContext c = {prop, value};\n-        applyFilter(intPropertyFilter, &c, uprops_getSource(prop), ec);\n+        // This code used to always call getInclusions(property source)\n+        // which sets an error for an unsupported property.\n+        ec = U_ILLEGAL_ARGUMENT_ERROR;\n+        // Otherwise we would just clear() this set because\n+        // getIntPropertyValue(c, prop) returns 0 for all code points.\n     }\n     return *this;\n }\n@@ -1030,13 +923,13 @@ UnicodeSet::applyPropertyAlias(const UnicodeString& prop,\n                     p == UCHAR_TRAIL_CANONICAL_COMBINING_CLASS ||\n                     p == UCHAR_LEAD_CANONICAL_COMBINING_CLASS) {\n                     char* end;\n-                    double value = uprv_strtod(vname.data(), &end);\n+                    double val = uprv_strtod(vname.data(), &end);\n                     // Anything between 0 and 255 is valid even if unused.\n                     // Cast double->int only after range check.\n                     // We catch NaN here because comparing it with both 0 and 255 will be false\n                     // (as are all comparisons with NaN).\n-                    if (*end != 0 || !(0 <= value && value <= 255) ||\n-                            (v = (int32_t)value) != value) {\n+                    if (*end != 0 || !(0 <= val && val <= 255) ||\n+                            (v = (int32_t)val) != val) {\n                         // non-integral value or outside 0..255, or trailing junk\n                         FAIL(ec);\n                     }\n@@ -1052,11 +945,12 @@ UnicodeSet::applyPropertyAlias(const UnicodeString& prop,\n             case UCHAR_NUMERIC_VALUE:\n                 {\n                     char* end;\n-                    double value = uprv_strtod(vname.data(), &end);\n+                    double val = uprv_strtod(vname.data(), &end);\n                     if (*end != 0) {\n                         FAIL(ec);\n                     }\n-                    applyFilter(numericValueFilter, &value, UPROPS_SRC_CHAR, ec);\n+                    applyFilter(numericValueFilter, &val,\n+                                CharacterProperties::getInclusionsForProperty(p, ec), ec);\n                     return *this;\n                 }\n             case UCHAR_NAME:\n@@ -1085,7 +979,8 @@ UnicodeSet::applyPropertyAlias(const UnicodeString& prop,\n                     if (!mungeCharName(buf, vname.data(), sizeof(buf))) FAIL(ec);\n                     UVersionInfo version;\n                     u_versionFromString(version, buf);\n-                    applyFilter(versionFilter, &version, UPROPS_SRC_PROPSVEC, ec);\n+                    applyFilter(versionFilter, &version,\n+                                CharacterProperties::getInclusionsForProperty(p, ec), ec);\n                     return *this;\n                 }\n             case UCHAR_SCRIPT_EXTENSIONS:"
        },
        {
            "sha": "ff85734d615efa35a1ee76e21b7f96d6a39d893a",
            "filename": "deps/icu-small/source/common/unistr.cpp",
            "status": "modified",
            "additions": 47,
            "deletions": 12,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funistr.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Funistr.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Funistr.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1447,10 +1447,15 @@ UnicodeString::doReplace(int32_t start,\n   }\n \n   if(srcChars == 0) {\n-    srcStart = srcLength = 0;\n-  } else if(srcLength < 0) {\n-    // get the srcLength if necessary\n-    srcLength = u_strlen(srcChars + srcStart);\n+    srcLength = 0;\n+  } else {\n+    // Perform all remaining operations relative to srcChars + srcStart.\n+    // From this point forward, do not use srcStart.\n+    srcChars += srcStart;\n+    if (srcLength < 0) {\n+      // get the srcLength if necessary\n+      srcLength = u_strlen(srcChars);\n+    }\n   }\n \n   // pin the indices to legal values\n@@ -1465,17 +1470,28 @@ UnicodeString::doReplace(int32_t start,\n   }\n   newLength += srcLength;\n \n+  // Check for insertion into ourself\n+  const UChar *oldArray = getArrayStart();\n+  if (isBufferWritable() &&\n+      oldArray < srcChars + srcLength &&\n+      srcChars < oldArray + oldLength) {\n+    // Copy into a new UnicodeString and start over\n+    UnicodeString copy(srcChars, srcLength);\n+    if (copy.isBogus()) {\n+      setToBogus();\n+      return *this;\n+    }\n+    return doReplace(start, length, copy.getArrayStart(), 0, srcLength);\n+  }\n+\n   // cloneArrayIfNeeded(doCopyArray=FALSE) may change fArray but will not copy the current contents;\n   // therefore we need to keep the current fArray\n   UChar oldStackBuffer[US_STACKBUF_SIZE];\n-  UChar *oldArray;\n   if((fUnion.fFields.fLengthAndFlags&kUsingStackBuffer) && (newLength > US_STACKBUF_SIZE)) {\n     // copy the stack buffer contents because it will be overwritten with\n     // fUnion.fFields values\n-    u_memcpy(oldStackBuffer, fUnion.fStackFields.fBuffer, oldLength);\n+    u_memcpy(oldStackBuffer, oldArray, oldLength);\n     oldArray = oldStackBuffer;\n-  } else {\n-    oldArray = getArrayStart();\n   }\n \n   // clone our array and allocate a bigger array if needed\n@@ -1503,7 +1519,7 @@ UnicodeString::doReplace(int32_t start,\n   }\n \n   // now fill in the hole with the new string\n-  us_arrayCopy(srcChars, srcStart, newArray, start, srcLength);\n+  us_arrayCopy(srcChars, 0, newArray, start, srcLength);\n \n   setLength(newLength);\n \n@@ -1536,15 +1552,34 @@ UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLeng\n     return *this;\n   }\n \n+  // Perform all remaining operations relative to srcChars + srcStart.\n+  // From this point forward, do not use srcStart.\n+  srcChars += srcStart;\n+\n   if(srcLength < 0) {\n     // get the srcLength if necessary\n-    if((srcLength = u_strlen(srcChars + srcStart)) == 0) {\n+    if((srcLength = u_strlen(srcChars)) == 0) {\n       return *this;\n     }\n   }\n \n   int32_t oldLength = length();\n   int32_t newLength = oldLength + srcLength;\n+\n+  // Check for append onto ourself\n+  const UChar* oldArray = getArrayStart();\n+  if (isBufferWritable() &&\n+      oldArray < srcChars + srcLength &&\n+      srcChars < oldArray + oldLength) {\n+    // Copy into a new UnicodeString and start over\n+    UnicodeString copy(srcChars, srcLength);\n+    if (copy.isBogus()) {\n+      setToBogus();\n+      return *this;\n+    }\n+    return doAppend(copy.getArrayStart(), 0, srcLength);\n+  }\n+\n   // optimize append() onto a large-enough, owned string\n   if((newLength <= getCapacity() && isBufferWritable()) ||\n       cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n@@ -1556,8 +1591,8 @@ UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLeng\n     // or\n     //   str.appendString(buffer, length)\n     // or similar.\n-    if(srcChars + srcStart != newArray + oldLength) {\n-      us_arrayCopy(srcChars, srcStart, newArray, oldLength, srcLength);\n+    if(srcChars != newArray + oldLength) {\n+      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n     }\n     setLength(newLength);\n   }"
        },
        {
            "sha": "2421c15d2bd0b60babc4a01be327790f0a803dd3",
            "filename": "deps/icu-small/source/common/uprops.cpp",
            "status": "modified",
            "additions": 49,
            "deletions": 1,
            "changes": 50,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuprops.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuprops.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fuprops.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -25,6 +25,7 @@\n \n #include \"unicode/utypes.h\"\n #include \"unicode/uchar.h\"\n+#include \"unicode/ucptrie.h\"\n #include \"unicode/unorm2.h\"\n #include \"unicode/uscript.h\"\n #include \"unicode/ustring.h\"\n@@ -36,6 +37,10 @@\n #include \"ucase.h\"\n #include \"ustr_imp.h\"\n \n+// ulayout_props_data.h is machine-generated by genprops\n+#define INCLUDED_FROM_UPROPS_CPP\n+#include \"ulayout_props_data.h\"\n+\n U_NAMESPACE_USE\n \n /* general properties API functions ----------------------------------------- */\n@@ -56,7 +61,7 @@ static UBool defaultContains(const BinaryProperty &prop, UChar32 c, UProperty /*\n }\n \n static UBool caseBinaryPropertyContains(const BinaryProperty &/*prop*/, UChar32 c, UProperty which) {\n-    return ucase_hasBinaryProperty(c, which);\n+    return static_cast<UBool>(ucase_hasBinaryProperty(c, which));\n }\n \n static UBool isBidiControl(const BinaryProperty &/*prop*/, UChar32 c, UProperty /*which*/) {\n@@ -428,6 +433,18 @@ static int32_t getTrailCombiningClass(const IntProperty &/*prop*/, UChar32 c, UP\n }\n #endif\n \n+static int32_t getInPC(const IntProperty &, UChar32 c, UProperty) {\n+    return ucptrie_get(&inpc_trie, c);\n+}\n+\n+static int32_t getInSC(const IntProperty &, UChar32 c, UProperty) {\n+    return ucptrie_get(&insc_trie, c);\n+}\n+\n+static int32_t getVo(const IntProperty &, UChar32 c, UProperty) {\n+    return ucptrie_get(&vo_trie, c);\n+}\n+\n static const IntProperty intProps[UCHAR_INT_LIMIT-UCHAR_INT_START]={\n     /*\n      * column, mask and shift values for int-value properties from u_getUnicodeProperties().\n@@ -463,6 +480,9 @@ static const IntProperty intProps[UCHAR_INT_LIMIT-UCHAR_INT_START]={\n     { 2,                UPROPS_SB_MASK, UPROPS_SB_SHIFT,    defaultGetValue, defaultGetMaxValue },\n     { 2,                UPROPS_WB_MASK, UPROPS_WB_SHIFT,    defaultGetValue, defaultGetMaxValue },\n     { UPROPS_SRC_BIDI,  0, 0,                               getBiDiPairedBracketType, biDiGetMaxValue },\n+    { UPROPS_SRC_INPC,  0, maxInPCValue,                    getInPC, getMaxValueFromShift },\n+    { UPROPS_SRC_INSC,  0, maxInSCValue,                    getInSC, getMaxValueFromShift },\n+    { UPROPS_SRC_VO,    0, maxVoValue,                      getVo, getMaxValueFromShift },\n };\n \n U_CAPI int32_t U_EXPORT2\n@@ -564,6 +584,34 @@ uprops_getSource(UProperty which) {\n     }\n }\n \n+U_CFUNC void U_EXPORT2\n+uprops_addPropertyStarts(UPropertySource src, const USetAdder *sa, UErrorCode *pErrorCode) {\n+    if (U_FAILURE(*pErrorCode)) { return; }\n+    const UCPTrie *trie;\n+    switch (src) {\n+    case UPROPS_SRC_INPC:\n+        trie = &inpc_trie;\n+        break;\n+    case UPROPS_SRC_INSC:\n+        trie = &insc_trie;\n+        break;\n+    case UPROPS_SRC_VO:\n+        trie = &vo_trie;\n+        break;\n+    default:\n+        *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+\n+    // Add the start code point of each same-value range of the trie.\n+    UChar32 start = 0, end;\n+    while ((end = ucptrie_getRange(trie, start, UCPMAP_RANGE_NORMAL, 0,\n+                                   nullptr, nullptr, nullptr)) >= 0) {\n+        sa->add(sa->set, start);\n+        start = end + 1;\n+    }\n+}\n+\n #if !UCONFIG_NO_NORMALIZATION\n \n U_CAPI int32_t U_EXPORT2"
        },
        {
            "sha": "1a8e4e84f7445d2669193faaa2773b933f15d110",
            "filename": "deps/icu-small/source/common/uprops.h",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuprops.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fuprops.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fuprops.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -397,6 +397,10 @@ enum UPropertySource {\n     UPROPS_SRC_NFKC_CF,\n     /** From normalizer2impl.cpp/nfc.nrm canonical iterator data */\n     UPROPS_SRC_NFC_CANON_ITER,\n+    // Text layout properties.\n+    UPROPS_SRC_INPC,\n+    UPROPS_SRC_INSC,\n+    UPROPS_SRC_VO,\n     /** One more than the highest UPropertySource (UPROPS_SRC_) constant. */\n     UPROPS_SRC_COUNT\n };\n@@ -425,6 +429,9 @@ uchar_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode);\n U_CFUNC void U_EXPORT2\n upropsvec_addPropertyStarts(const USetAdder *sa, UErrorCode *pErrorCode);\n \n+U_CFUNC void U_EXPORT2\n+uprops_addPropertyStarts(UPropertySource src, const USetAdder *sa, UErrorCode *pErrorCode);\n+\n /**\n  * Return a set of characters for property enumeration.\n  * For each two consecutive characters (start, limit) in the set,\n@@ -452,6 +459,13 @@ U_NAMESPACE_BEGIN\n \n class UnicodeSet;\n \n+class CharacterProperties {\n+public:\n+    CharacterProperties() = delete;\n+    static void U_CALLCONV initInclusion(UPropertySource src, UErrorCode &errorCode);\n+    static const UnicodeSet *getInclusionsForProperty(UProperty prop, UErrorCode &errorCode);\n+};\n+\n // implemented in uniset_props.cpp\n U_CFUNC UnicodeSet *\n uniset_getUnicode32Instance(UErrorCode &errorCode);"
        },
        {
            "sha": "3da73421c0cfb7828af968fc36a258aa91ba72be",
            "filename": "deps/icu-small/source/common/uresbund.cpp",
            "status": "modified",
            "additions": 43,
            "deletions": 12,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Furesbund.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Furesbund.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Furesbund.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -368,6 +368,11 @@ static UResourceDataEntry *init_entry(const char *localeID, const char *path, UE\n         res_load(&(r->fData), r->fPath, r->fName, status);\n \n         if (U_FAILURE(*status)) {\n+            /* if we failed to load due to an out-of-memory error, exit early. */\n+            if (*status == U_MEMORY_ALLOCATION_ERROR) {\n+                uprv_free(r);\n+                return NULL;\n+            }\n             /* we have no such entry in dll, so it will always use fallback */\n             *status = U_USING_FALLBACK_WARNING;\n             r->fBogus = U_USING_FALLBACK_WARNING;\n@@ -537,6 +542,11 @@ loadParentsExceptRoot(UResourceDataEntry *&t1,\n         UErrorCode usrStatus = U_ZERO_ERROR;\n         if (usingUSRData) {  // This code inserts user override data into the inheritance chain.\n             u2 = init_entry(name, usrDataPath, &usrStatus);\n+            // If we failed due to out-of-memory, report that to the caller and exit early.\n+            if (usrStatus == U_MEMORY_ALLOCATION_ERROR) {\n+                *status = usrStatus;\n+                return FALSE;\n+            }\n         }\n \n         if (usingUSRData && U_SUCCESS(usrStatus) && u2->fBogus == U_ZERO_ERROR) {\n@@ -642,21 +652,32 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,\n         /* We're going to skip all the locales that do not have any data */\n         r = findFirstExisting(path, name, &isRoot, &hasChopped, &isDefault, &intStatus);\n \n+        // If we failed due to out-of-memory, report the failure and exit early.\n+        if (intStatus == U_MEMORY_ALLOCATION_ERROR) {\n+            *status = intStatus;\n+            goto finishUnlock;\n+        }\n+\n         if(r != NULL) { /* if there is one real locale, we can look for parents. */\n             t1 = r;\n             hasRealData = TRUE;\n             if ( usingUSRData ) {  /* This code inserts user override data into the inheritance chain */\n                 UErrorCode usrStatus = U_ZERO_ERROR;\n                 UResourceDataEntry *u1 = init_entry(t1->fName, usrDataPath, &usrStatus);\n-               if ( u1 != NULL ) {\n-                 if(u1->fBogus == U_ZERO_ERROR) {\n-                   u1->fParent = t1;\n-                   r = u1;\n-                 } else {\n-                   /* the USR override data wasn't found, set it to be deleted */\n-                   u1->fCountExisting = 0;\n-                 }\n-               }\n+                // If we failed due to out-of-memory, report the failure and exit early.\n+                if (intStatus == U_MEMORY_ALLOCATION_ERROR) {\n+                    *status = intStatus;\n+                    goto finishUnlock;\n+                }\n+                if ( u1 != NULL ) {\n+                    if(u1->fBogus == U_ZERO_ERROR) {\n+                        u1->fParent = t1;\n+                        r = u1;\n+                    } else {\n+                        /* the USR override data wasn't found, set it to be deleted */\n+                        u1->fCountExisting = 0;\n+                    }\n+                }\n             }\n             if (hasChopped && !isRoot) {\n                 if (!loadParentsExceptRoot(t1, name, UPRV_LENGTHOF(name), usingUSRData, usrDataPath, status)) {\n@@ -671,6 +692,11 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,\n             /* insert default locale */\n             uprv_strcpy(name, uloc_getDefault());\n             r = findFirstExisting(path, name, &isRoot, &hasChopped, &isDefault, &intStatus);\n+            // If we failed due to out-of-memory, report the failure and exit early.\n+            if (intStatus == U_MEMORY_ALLOCATION_ERROR) {\n+                *status = intStatus;\n+                goto finishUnlock;\n+            }\n             intStatus = U_USING_DEFAULT_WARNING;\n             if(r != NULL) { /* the default locale exists */\n                 t1 = r;\n@@ -690,6 +716,11 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,\n         if(r == NULL) {\n             uprv_strcpy(name, kRootLocaleName);\n             r = findFirstExisting(path, name, &isRoot, &hasChopped, &isDefault, &intStatus);\n+            // If we failed due to out-of-memory, report the failure and exit early.\n+            if (intStatus == U_MEMORY_ALLOCATION_ERROR) {\n+                *status = intStatus;\n+                goto finishUnlock;\n+            }\n             if(r != NULL) {\n                 t1 = r;\n                 intStatus = U_USING_DEFAULT_WARNING;\n@@ -2421,7 +2452,7 @@ ures_loc_nextLocale(UEnumeration* en,\n     UResourceBundle *k = NULL;\n     const char *result = NULL;\n     int32_t len = 0;\n-    if(ures_hasNext(res) && (k = ures_getNextResource(res, &ctx->curr, status))) {\n+    if(ures_hasNext(res) && (k = ures_getNextResource(res, &ctx->curr, status)) != 0) {\n         result = ures_getKey(k);\n         len = (int32_t)uprv_strlen(result);\n     }\n@@ -2843,7 +2874,7 @@ ures_getKeywordValues(const char *path, const char *keyword, UErrorCode *status)\n     valuesBuf[0]=0;\n     valuesBuf[1]=0;\n \n-    while((locale = uenum_next(locs, &locLen, status))) {\n+    while((locale = uenum_next(locs, &locLen, status)) != 0) {\n         UResourceBundle   *bund = NULL;\n         UResourceBundle   *subPtr = NULL;\n         UErrorCode subStatus = U_ZERO_ERROR; /* don't fail if a bundle is unopenable */\n@@ -2868,7 +2899,7 @@ ures_getKeywordValues(const char *path, const char *keyword, UErrorCode *status)\n             continue;\n         }\n \n-        while((subPtr = ures_getNextResource(&item,&subItem,&subStatus))\n+        while((subPtr = ures_getNextResource(&item,&subItem,&subStatus)) != 0\n             && U_SUCCESS(subStatus)) {\n             const char *k;\n             int32_t i;"
        },
        {
            "sha": "4e28ddccf63199a4dac23fb14dc73aba509b7f90",
            "filename": "deps/icu-small/source/common/uresdata.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Furesdata.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Furesdata.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Furesdata.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -475,7 +475,7 @@ U_NAMESPACE_BEGIN\n \n class ResourceDataValue : public ResourceValue {\n public:\n-    ResourceDataValue() : pResData(NULL), res(URES_NONE) {}\n+    ResourceDataValue() : pResData(NULL), res(static_cast<Resource>(URES_NONE)) {}\n     virtual ~ResourceDataValue();\n \n     void setData(const ResourceData *data) { pResData = data; }"
        },
        {
            "sha": "792de50bbcc736ce2ffbb35139a3682317400110",
            "filename": "deps/icu-small/source/common/ushape.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fushape.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fushape.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fushape.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1323,7 +1323,7 @@ shapeUnicode(UChar *dest, int32_t sourceLength,\n                         /* to ensure the array index is within the range */\n                         U_ASSERT(dest[i] >= 0x064Bu\n                             && dest[i]-0x064Bu < UPRV_LENGTHOF(IrrelevantPos));\n-                        dest[i] =  0xFE70 + IrrelevantPos[(dest[i] - 0x064B)] + Shape;\n+                        dest[i] =  0xFE70 + IrrelevantPos[(dest[i] - 0x064B)] + static_cast<UChar>(Shape);\n                     }\n                 }else if ((currLink & APRESENT) > 0) {\n                     dest[i] = (UChar)(0xFB50 + (currLink >> 8) + Shape);"
        },
        {
            "sha": "1e54e6cab59eb28d7826b1cda1cbb85b3c5a0392",
            "filename": "deps/icu-small/source/common/usprep.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fusprep.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fusprep.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fusprep.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -112,7 +112,9 @@ hashEntry(const UHashTok parm) {\n     UHashTok namekey, pathkey;\n     namekey.pointer = b->name;\n     pathkey.pointer = b->path;\n-    return uhash_hashChars(namekey)+37*uhash_hashChars(pathkey);\n+    uint32_t unsignedHash = static_cast<uint32_t>(uhash_hashChars(namekey)) +\n+            37u * static_cast<uint32_t>(uhash_hashChars(pathkey));\n+    return static_cast<int32_t>(unsignedHash);\n }\n \n /* compares two entries */\n@@ -351,9 +353,9 @@ usprep_getProfile(const char* path,\n         LocalMemory<char> keyName;\n         LocalMemory<char> keyPath;\n         if( key.allocateInsteadAndReset() == NULL ||\n-            keyName.allocateInsteadAndCopy(uprv_strlen(name)+1) == NULL ||\n+            keyName.allocateInsteadAndCopy(static_cast<int32_t>(uprv_strlen(name)+1)) == NULL ||\n             (path != NULL &&\n-             keyPath.allocateInsteadAndCopy(uprv_strlen(path)+1) == NULL)\n+             keyPath.allocateInsteadAndCopy(static_cast<int32_t>(uprv_strlen(path)+1)) == NULL)\n          ) {\n             *status = U_MEMORY_ALLOCATION_ERROR;\n             usprep_unload(newProfile.getAlias());\n@@ -726,7 +728,7 @@ usprep_prepare(   const UStringPrepProfile* profile,\n             ((result < _SPREP_TYPE_THRESHOLD) && (result & 0x01) /* first bit says it the code point is prohibited*/)\n            ){\n             *status = U_STRINGPREP_PROHIBITED_ERROR;\n-            uprv_syntaxError(b1, b2Index-U16_LENGTH(ch), b2Len, parseError);\n+            uprv_syntaxError(b2, b2Index-U16_LENGTH(ch), b2Len, parseError);\n             return 0;\n         }\n "
        },
        {
            "sha": "618e847c65d5a66c428bd9dac31d0559f3c8ce06",
            "filename": "deps/icu-small/source/common/ustrcase.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fustrcase.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fustrcase.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fustrcase.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -218,7 +218,7 @@ int32_t toLower(int32_t caseLocale, uint32_t options,\n     int32_t srcIndex = srcStart;\n     for (;;) {\n         // fast path for simple cases\n-        UChar lead;\n+        UChar lead = 0;\n         while (srcIndex < srcLimit) {\n             lead = src[srcIndex];\n             int32_t delta;\n@@ -238,7 +238,7 @@ int32_t toLower(int32_t caseLocale, uint32_t options,\n                     continue;\n                 }\n             }\n-            lead += delta;\n+            lead += static_cast<UChar>(delta);\n             destIndex = appendUnchanged(dest, destIndex, destCapacity,\n                                         src + prev, srcIndex - 1 - prev, options, edits);\n             if (destIndex >= 0) {\n@@ -313,7 +313,7 @@ int32_t toUpper(int32_t caseLocale, uint32_t options,\n     int32_t srcIndex = 0;\n     for (;;) {\n         // fast path for simple cases\n-        UChar lead;\n+        UChar lead = 0;\n         while (srcIndex < srcLength) {\n             lead = src[srcIndex];\n             int32_t delta;\n@@ -333,7 +333,7 @@ int32_t toUpper(int32_t caseLocale, uint32_t options,\n                     continue;\n                 }\n             }\n-            lead += delta;\n+            lead += static_cast<UChar>(delta);\n             destIndex = appendUnchanged(dest, destIndex, destCapacity,\n                                         src + prev, srcIndex - 1 - prev, options, edits);\n             if (destIndex >= 0) {\n@@ -1747,8 +1747,8 @@ static int32_t _cmpFold(\n     }\n \n     if(matchLen1) {\n-        *matchLen1=m1-org1;\n-        *matchLen2=m2-org2;\n+        *matchLen1=static_cast<int32_t>(m1-org1);\n+        *matchLen2=static_cast<int32_t>(m2-org2);\n     }\n     return cmpRes;\n }"
        },
        {
            "sha": "5e3a005626e6b895b7936048c3e1ab31ce1d7018",
            "filename": "deps/icu-small/source/common/utext.cpp",
            "status": "modified",
            "additions": 33,
            "deletions": 33,
            "changes": 66,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futext.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futext.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futext.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1196,9 +1196,9 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {\n         // Swap the UText buffers.\n         //  We want to fill what was previously the alternate buffer,\n         //  and make what was the current buffer be the new alternate.\n-        UTF8Buf *u8b = (UTF8Buf *)ut->q;\n+        UTF8Buf *u8b_swap = (UTF8Buf *)ut->q;\n         ut->q = ut->p;\n-        ut->p = u8b;\n+        ut->p = u8b_swap;\n \n         int32_t strLen = ut->b;\n         UBool   nulTerminated = FALSE;\n@@ -1207,9 +1207,9 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {\n             nulTerminated = TRUE;\n         }\n \n-        UChar   *buf = u8b->buf;\n-        uint8_t *mapToNative  = u8b->mapToNative;\n-        uint8_t *mapToUChars  = u8b->mapToUChars;\n+        UChar   *buf = u8b_swap->buf;\n+        uint8_t *mapToNative  = u8b_swap->mapToNative;\n+        uint8_t *mapToUChars  = u8b_swap->mapToUChars;\n         int32_t  destIx       = 0;\n         int32_t  srcIx        = ix;\n         UBool    seenNonAscii = FALSE;\n@@ -1230,7 +1230,7 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {\n                 // General case, handle everything.\n                 if (seenNonAscii == FALSE) {\n                     seenNonAscii = TRUE;\n-                    u8b->bufNILimit = destIx;\n+                    u8b_swap->bufNILimit = destIx;\n                 }\n \n                 int32_t  cIx      = srcIx;\n@@ -1263,22 +1263,22 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {\n         mapToUChars[srcIx - ix] = (uint8_t)destIx;\n \n         //  fill in Buffer descriptor\n-        u8b->bufNativeStart     = ix;\n-        u8b->bufNativeLimit     = srcIx;\n-        u8b->bufStartIdx        = 0;\n-        u8b->bufLimitIdx        = destIx;\n+        u8b_swap->bufNativeStart     = ix;\n+        u8b_swap->bufNativeLimit     = srcIx;\n+        u8b_swap->bufStartIdx        = 0;\n+        u8b_swap->bufLimitIdx        = destIx;\n         if (seenNonAscii == FALSE) {\n-            u8b->bufNILimit     = destIx;\n+            u8b_swap->bufNILimit     = destIx;\n         }\n-        u8b->toUCharsMapStart   = u8b->bufNativeStart;\n+        u8b_swap->toUCharsMapStart   = u8b_swap->bufNativeStart;\n \n         // Set UText chunk to refer to this buffer.\n         ut->chunkContents       = buf;\n         ut->chunkOffset         = 0;\n-        ut->chunkLength         = u8b->bufLimitIdx;\n-        ut->chunkNativeStart    = u8b->bufNativeStart;\n-        ut->chunkNativeLimit    = u8b->bufNativeLimit;\n-        ut->nativeIndexingLimit = u8b->bufNILimit;\n+        ut->chunkLength         = u8b_swap->bufLimitIdx;\n+        ut->chunkNativeStart    = u8b_swap->bufNativeStart;\n+        ut->chunkNativeLimit    = u8b_swap->bufNativeLimit;\n+        ut->nativeIndexingLimit = u8b_swap->bufNILimit;\n \n         // For zero terminated strings, keep track of the maximum point\n         //   scanned so far.\n@@ -1311,13 +1311,13 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {\n         // Swap the UText buffers.\n         //  We want to fill what was previously the alternate buffer,\n         //  and make what was the current buffer be the new alternate.\n-        UTF8Buf *u8b = (UTF8Buf *)ut->q;\n+        UTF8Buf *u8b_swap = (UTF8Buf *)ut->q;\n         ut->q = ut->p;\n-        ut->p = u8b;\n+        ut->p = u8b_swap;\n \n-        UChar   *buf = u8b->buf;\n-        uint8_t *mapToNative = u8b->mapToNative;\n-        uint8_t *mapToUChars = u8b->mapToUChars;\n+        UChar   *buf = u8b_swap->buf;\n+        uint8_t *mapToNative = u8b_swap->mapToNative;\n+        uint8_t *mapToUChars = u8b_swap->mapToUChars;\n         int32_t  toUCharsMapStart = ix - sizeof(UTF8Buf::mapToUChars) + 1;\n         // Note that toUCharsMapStart can be negative. Happens when the remaining\n         // text from current position to the beginning is less than the buffer size.\n@@ -1387,19 +1387,19 @@ utf8TextAccess(UText *ut, int64_t index, UBool forward) {\n                 bufNILimit = destIx;\n             }\n         }\n-        u8b->bufNativeStart     = srcIx;\n-        u8b->bufNativeLimit     = ix;\n-        u8b->bufStartIdx        = destIx;\n-        u8b->bufLimitIdx        = UTF8_TEXT_CHUNK_SIZE+2;\n-        u8b->bufNILimit         = bufNILimit - u8b->bufStartIdx;\n-        u8b->toUCharsMapStart   = toUCharsMapStart;\n-\n-        ut->chunkContents       = &buf[u8b->bufStartIdx];\n-        ut->chunkLength         = u8b->bufLimitIdx - u8b->bufStartIdx;\n+        u8b_swap->bufNativeStart     = srcIx;\n+        u8b_swap->bufNativeLimit     = ix;\n+        u8b_swap->bufStartIdx        = destIx;\n+        u8b_swap->bufLimitIdx        = UTF8_TEXT_CHUNK_SIZE+2;\n+        u8b_swap->bufNILimit         = bufNILimit - u8b_swap->bufStartIdx;\n+        u8b_swap->toUCharsMapStart   = toUCharsMapStart;\n+\n+        ut->chunkContents       = &buf[u8b_swap->bufStartIdx];\n+        ut->chunkLength         = u8b_swap->bufLimitIdx - u8b_swap->bufStartIdx;\n         ut->chunkOffset         = ut->chunkLength;\n-        ut->chunkNativeStart    = u8b->bufNativeStart;\n-        ut->chunkNativeLimit    = u8b->bufNativeLimit;\n-        ut->nativeIndexingLimit = u8b->bufNILimit;\n+        ut->chunkNativeStart    = u8b_swap->bufNativeStart;\n+        ut->chunkNativeLimit    = u8b_swap->bufNativeLimit;\n+        ut->nativeIndexingLimit = u8b_swap->bufNILimit;\n         return TRUE;\n     }\n "
        },
        {
            "sha": "3e2197eda6c2619b41e5501b1cd43946d1e454a2",
            "filename": "deps/icu-small/source/common/utrie.h",
            "status": "modified",
            "additions": 5,
            "deletions": 10,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -21,7 +21,6 @@\n \n #include \"unicode/utypes.h\"\n #include \"unicode/utf16.h\"\n-#include \"udataswp.h\"\n \n U_CDECL_BEGIN\n \n@@ -732,17 +731,13 @@ utrie_serialize(UNewTrie *trie, void *data, int32_t capacity,\n                 UBool reduceTo16Bits,\n                 UErrorCode *pErrorCode);\n \n-/**\n- * Swap a serialized UTrie.\n- * @internal\n- */\n-U_CAPI int32_t U_EXPORT2\n-utrie_swap(const UDataSwapper *ds,\n-           const void *inData, int32_t length, void *outData,\n-           UErrorCode *pErrorCode);\n-\n /* serialization ------------------------------------------------------------ */\n \n+// UTrie signature values, in platform endianness and opposite endianness.\n+// The UTrie signature ASCII byte values spell \"Trie\".\n+#define UTRIE_SIG       0x54726965\n+#define UTRIE_OE_SIG    0x65697254\n+\n /**\n  * Trie data structure in serialized form:\n  *"
        },
        {
            "sha": "24ef5782c90565c7567dac81e3758256bbdceeb5",
            "filename": "deps/icu-small/source/common/utrie2.cpp",
            "status": "modified",
            "additions": 14,
            "deletions": 118,
            "changes": 132,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -24,11 +24,10 @@\n *   This file contains only the runtime and enumeration code, for read-only access.\n *   See utrie2_builder.c for the builder code.\n */\n-#ifdef UTRIE2_DEBUG\n-#   include <stdio.h>\n-#endif\n-\n #include \"unicode/utypes.h\"\n+#ifdef UCPTRIE_DEBUG\n+#include \"unicode/umutablecptrie.h\"\n+#endif\n #include \"unicode/utf.h\"\n #include \"unicode/utf8.h\"\n #include \"unicode/utf16.h\"\n@@ -202,6 +201,9 @@ utrie2_openFromSerialized(UTrie2ValueBits valueBits,\n     trie->memory=(uint32_t *)data;\n     trie->length=actualLength;\n     trie->isMemoryOwned=FALSE;\n+#ifdef UTRIE2_DEBUG\n+    trie->name=\"fromSerialized\";\n+#endif\n \n     /* set the pointers to its index and data arrays */\n     p16=(const uint16_t *)(header+1);\n@@ -294,6 +296,9 @@ utrie2_openDummy(UTrie2ValueBits valueBits,\n     trie->errorValue=errorValue;\n     trie->highStart=0;\n     trie->highValueIndex=dataMove+UTRIE2_DATA_START_OFFSET;\n+#ifdef UTRIE2_DEBUG\n+    trie->name=\"dummy\";\n+#endif\n \n     /* set the header fields */\n     header=(UTrie2Header *)trie->memory;\n@@ -373,34 +378,15 @@ utrie2_close(UTrie2 *trie) {\n         }\n         if(trie->newTrie!=NULL) {\n             uprv_free(trie->newTrie->data);\n+#ifdef UCPTRIE_DEBUG\n+            umutablecptrie_close(trie->newTrie->t3);\n+#endif\n             uprv_free(trie->newTrie);\n         }\n         uprv_free(trie);\n     }\n }\n \n-U_CAPI int32_t U_EXPORT2\n-utrie2_getVersion(const void *data, int32_t length, UBool anyEndianOk) {\n-    uint32_t signature;\n-    if(length<16 || data==NULL || (U_POINTER_MASK_LSB(data, 3)!=0)) {\n-        return 0;\n-    }\n-    signature=*(const uint32_t *)data;\n-    if(signature==UTRIE2_SIG) {\n-        return 2;\n-    }\n-    if(anyEndianOk && signature==UTRIE2_OE_SIG) {\n-        return 2;\n-    }\n-    if(signature==UTRIE_SIG) {\n-        return 1;\n-    }\n-    if(anyEndianOk && signature==UTRIE_OE_SIG) {\n-        return 1;\n-    }\n-    return 0;\n-}\n-\n U_CAPI UBool U_EXPORT2\n utrie2_isFrozen(const UTrie2 *trie) {\n     return (UBool)(trie->newTrie==NULL);\n@@ -430,96 +416,6 @@ utrie2_serialize(const UTrie2 *trie,\n     return trie->length;\n }\n \n-U_CAPI int32_t U_EXPORT2\n-utrie2_swap(const UDataSwapper *ds,\n-            const void *inData, int32_t length, void *outData,\n-            UErrorCode *pErrorCode) {\n-    const UTrie2Header *inTrie;\n-    UTrie2Header trie;\n-    int32_t dataLength, size;\n-    UTrie2ValueBits valueBits;\n-\n-    if(U_FAILURE(*pErrorCode)) {\n-        return 0;\n-    }\n-    if(ds==NULL || inData==NULL || (length>=0 && outData==NULL)) {\n-        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;\n-        return 0;\n-    }\n-\n-    /* setup and swapping */\n-    if(length>=0 && length<(int32_t)sizeof(UTrie2Header)) {\n-        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n-        return 0;\n-    }\n-\n-    inTrie=(const UTrie2Header *)inData;\n-    trie.signature=ds->readUInt32(inTrie->signature);\n-    trie.options=ds->readUInt16(inTrie->options);\n-    trie.indexLength=ds->readUInt16(inTrie->indexLength);\n-    trie.shiftedDataLength=ds->readUInt16(inTrie->shiftedDataLength);\n-\n-    valueBits=(UTrie2ValueBits)(trie.options&UTRIE2_OPTIONS_VALUE_BITS_MASK);\n-    dataLength=(int32_t)trie.shiftedDataLength<<UTRIE2_INDEX_SHIFT;\n-\n-    if( trie.signature!=UTRIE2_SIG ||\n-        valueBits<0 || UTRIE2_COUNT_VALUE_BITS<=valueBits ||\n-        trie.indexLength<UTRIE2_INDEX_1_OFFSET ||\n-        dataLength<UTRIE2_DATA_START_OFFSET\n-    ) {\n-        *pErrorCode=U_INVALID_FORMAT_ERROR; /* not a UTrie */\n-        return 0;\n-    }\n-\n-    size=sizeof(UTrie2Header)+trie.indexLength*2;\n-    switch(valueBits) {\n-    case UTRIE2_16_VALUE_BITS:\n-        size+=dataLength*2;\n-        break;\n-    case UTRIE2_32_VALUE_BITS:\n-        size+=dataLength*4;\n-        break;\n-    default:\n-        *pErrorCode=U_INVALID_FORMAT_ERROR;\n-        return 0;\n-    }\n-\n-    if(length>=0) {\n-        UTrie2Header *outTrie;\n-\n-        if(length<size) {\n-            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n-            return 0;\n-        }\n-\n-        outTrie=(UTrie2Header *)outData;\n-\n-        /* swap the header */\n-        ds->swapArray32(ds, &inTrie->signature, 4, &outTrie->signature, pErrorCode);\n-        ds->swapArray16(ds, &inTrie->options, 12, &outTrie->options, pErrorCode);\n-\n-        /* swap the index and the data */\n-        switch(valueBits) {\n-        case UTRIE2_16_VALUE_BITS:\n-            ds->swapArray16(ds, inTrie+1, (trie.indexLength+dataLength)*2, outTrie+1, pErrorCode);\n-            break;\n-        case UTRIE2_32_VALUE_BITS:\n-            ds->swapArray16(ds, inTrie+1, trie.indexLength*2, outTrie+1, pErrorCode);\n-            ds->swapArray32(ds, (const uint16_t *)(inTrie+1)+trie.indexLength, dataLength*4,\n-                                     (uint16_t *)(outTrie+1)+trie.indexLength, pErrorCode);\n-            break;\n-        default:\n-            *pErrorCode=U_INVALID_FORMAT_ERROR;\n-            return 0;\n-        }\n-    }\n-\n-    return size;\n-}\n-\n-// utrie2_swapAnyVersion() should be defined here but lives in utrie2_builder.c\n-// to avoid a dependency from utrie2.cpp on utrie.c.\n-\n /* enumeration -------------------------------------------------------------- */\n \n #define MIN_VALUE(a, b) ((a)<(b) ? (a) : (b))\n@@ -746,7 +642,7 @@ uint16_t BackwardUTrie2StringIterator::previous16() {\n     codePointLimit=codePointStart;\n     if(start>=codePointStart) {\n         codePoint=U_SENTINEL;\n-        return trie->errorValue;\n+        return static_cast<uint16_t>(trie->errorValue);\n     }\n     uint16_t result;\n     UTRIE2_U16_PREV16(trie, start, codePointStart, codePoint, result);\n@@ -757,7 +653,7 @@ uint16_t ForwardUTrie2StringIterator::next16() {\n     codePointStart=codePointLimit;\n     if(codePointLimit==limit) {\n         codePoint=U_SENTINEL;\n-        return trie->errorValue;\n+        return static_cast<uint16_t>(trie->errorValue);\n     }\n     uint16_t result;\n     UTRIE2_U16_NEXT16(trie, codePointLimit, limit, codePoint, result);"
        },
        {
            "sha": "75028ee23ac1e96acbd5748dc6c99a4b8d589f4c",
            "filename": "deps/icu-small/source/common/utrie2.h",
            "status": "modified",
            "additions": 4,
            "deletions": 35,
            "changes": 39,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -22,7 +22,6 @@\n #include \"unicode/utypes.h\"\n #include \"unicode/utf8.h\"\n #include \"putilimp.h\"\n-#include \"udataswp.h\"\n \n U_CDECL_BEGIN\n \n@@ -330,40 +329,6 @@ utrie2_serialize(const UTrie2 *trie,\n \n /* Public UTrie2 API: miscellaneous functions ------------------------------- */\n \n-/**\n- * Get the UTrie version from 32-bit-aligned memory containing the serialized form\n- * of either a UTrie (version 1) or a UTrie2 (version 2).\n- *\n- * @param data a pointer to 32-bit-aligned memory containing the serialized form\n- *             of a UTrie, version 1 or 2\n- * @param length the number of bytes available at data;\n- *               can be more than necessary (see return value)\n- * @param anyEndianOk If FALSE, only platform-endian serialized forms are recognized.\n- *                    If TRUE, opposite-endian serialized forms are recognized as well.\n- * @return the UTrie version of the serialized form, or 0 if it is not\n- *         recognized as a serialized UTrie\n- */\n-U_CAPI int32_t U_EXPORT2\n-utrie2_getVersion(const void *data, int32_t length, UBool anyEndianOk);\n-\n-/**\n- * Swap a serialized UTrie2.\n- * @internal\n- */\n-U_CAPI int32_t U_EXPORT2\n-utrie2_swap(const UDataSwapper *ds,\n-            const void *inData, int32_t length, void *outData,\n-            UErrorCode *pErrorCode);\n-\n-/**\n- * Swap a serialized UTrie or UTrie2.\n- * @internal\n- */\n-U_CAPI int32_t U_EXPORT2\n-utrie2_swapAnyVersion(const UDataSwapper *ds,\n-                      const void *inData, int32_t length, void *outData,\n-                      UErrorCode *pErrorCode);\n-\n /**\n  * Build a UTrie2 (version 2) from a UTrie (version 1).\n  * Enumerates all values in the UTrie and builds a UTrie2 with the same values.\n@@ -709,6 +674,10 @@ struct UTrie2 {\n     UBool padding1;\n     int16_t padding2;\n     UNewTrie2 *newTrie;     /* builder object; NULL when frozen */\n+\n+#ifdef UTRIE2_DEBUG\n+    const char *name;\n+#endif\n };\n \n /**"
        },
        {
            "sha": "80e09c9c26b3e1c27c4eee5186cb71de88eb6688",
            "filename": "deps/icu-small/source/common/utrie2_builder.cpp",
            "status": "modified",
            "additions": 73,
            "deletions": 33,
            "changes": 106,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2_builder.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2_builder.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2_builder.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -24,16 +24,23 @@\n *   This file contains only the builder code.\n *   See utrie2.c for the runtime and enumeration code.\n */\n+// #define UTRIE2_DEBUG\n #ifdef UTRIE2_DEBUG\n #   include <stdio.h>\n #endif\n+// #define UCPTRIE_DEBUG\n \n #include \"unicode/utypes.h\"\n+#ifdef UCPTRIE_DEBUG\n+#include \"unicode/ucptrie.h\"\n+#include \"unicode/umutablecptrie.h\"\n+#include \"ucptrie_impl.h\"\n+#endif\n #include \"cmemory.h\"\n #include \"utrie2.h\"\n #include \"utrie2_impl.h\"\n \n-#include \"utrie.h\" /* for utrie2_fromUTrie() and utrie_swap() */\n+#include \"utrie.h\"  // for utrie2_fromUTrie()\n \n /* Implementation notes ----------------------------------------------------- */\n \n@@ -132,8 +139,14 @@ utrie2_open(uint32_t initialValue, uint32_t errorValue, UErrorCode *pErrorCode)\n     trie->errorValue=errorValue;\n     trie->highStart=0x110000;\n     trie->newTrie=newTrie;\n+#ifdef UTRIE2_DEBUG\n+    trie->name=\"open\";\n+#endif\n \n     newTrie->data=data;\n+#ifdef UCPTRIE_DEBUG\n+    newTrie->t3=umutablecptrie_open(initialValue, errorValue, pErrorCode);\n+#endif\n     newTrie->dataCapacity=UNEWTRIE2_INITIAL_DATA_LENGTH;\n     newTrie->initialValue=initialValue;\n     newTrie->errorValue=errorValue;\n@@ -246,6 +259,14 @@ cloneBuilder(const UNewTrie2 *other) {\n         uprv_free(trie);\n         return NULL;\n     }\n+#ifdef UCPTRIE_DEBUG\n+    if(other->t3==nullptr) {\n+        trie->t3=nullptr;\n+    } else {\n+        UErrorCode errorCode=U_ZERO_ERROR;\n+        trie->t3=umutablecptrie_clone(other->t3, &errorCode);\n+    }\n+#endif\n     trie->dataCapacity=other->dataCapacity;\n \n     /* clone data */\n@@ -343,6 +364,22 @@ copyEnumRange(const void *context, UChar32 start, UChar32 end, uint32_t value) {\n }\n \n #ifdef UTRIE2_DEBUG\n+static long countInitial(const UTrie2 *trie) {\n+    uint32_t initialValue=trie->initialValue;\n+    int32_t length=trie->dataLength;\n+    long count=0;\n+    if(trie->data16!=nullptr) {\n+        for(int32_t i=0; i<length; ++i) {\n+            if(trie->data16[i]==initialValue) { ++count; }\n+        }\n+    } else {\n+        for(int32_t i=0; i<length; ++i) {\n+            if(trie->data32[i]==initialValue) { ++count; }\n+        }\n+    }\n+    return count;\n+}\n+\n static void\n utrie_printLengths(const UTrie *trie) {\n     long indexLength=trie->indexLength;\n@@ -357,8 +394,8 @@ utrie2_printLengths(const UTrie2 *trie, const char *which) {\n     long indexLength=trie->indexLength;\n     long dataLength=(long)trie->dataLength;\n     long totalLength=(long)sizeof(UTrie2Header)+indexLength*2+dataLength*(trie->data32!=NULL ? 4 : 2);\n-    printf(\"**UTrie2Lengths(%s)** index:%6ld  data:%6ld  serialized:%6ld\\n\",\n-           which, indexLength, dataLength, totalLength);\n+    printf(\"**UTrie2Lengths(%s %s)** index:%6ld  data:%6ld  countInitial:%6ld  serialized:%6ld\\n\",\n+           which, trie->name, indexLength, dataLength, countInitial(trie), totalLength);\n }\n #endif\n \n@@ -622,6 +659,9 @@ set32(UNewTrie2 *trie,\n         *pErrorCode=U_NO_WRITE_PERMISSION;\n         return;\n     }\n+#ifdef UCPTRIE_DEBUG\n+    umutablecptrie_set(trie->t3, c, value, pErrorCode);\n+#endif\n \n     block=getDataBlock(trie, c, forLSCP);\n     if(block<0) {\n@@ -717,6 +757,9 @@ utrie2_setRange32(UTrie2 *trie,\n         *pErrorCode=U_NO_WRITE_PERMISSION;\n         return;\n     }\n+#ifdef UCPTRIE_DEBUG\n+    umutablecptrie_setRange(newTrie->t3, start, end, value, pErrorCode);\n+#endif\n     if(!overwrite && value==newTrie->initialValue) {\n         return; /* nothing to do */\n     }\n@@ -732,7 +775,7 @@ utrie2_setRange32(UTrie2 *trie,\n             return;\n         }\n \n-        nextStart=(start+UTRIE2_DATA_BLOCK_LENGTH)&~UTRIE2_DATA_MASK;\n+        nextStart=(start+UTRIE2_DATA_MASK)&~UTRIE2_DATA_MASK;\n         if(nextStart<=limit) {\n             fillBlock(newTrie->data+block, start&UTRIE2_DATA_MASK, UTRIE2_DATA_BLOCK_LENGTH,\n                       value, newTrie->initialValue, overwrite);\n@@ -983,6 +1026,10 @@ findHighStart(UNewTrie2 *trie, uint32_t highValue) {\n  */\n static void\n compactData(UNewTrie2 *trie) {\n+#ifdef UTRIE2_DEBUG\n+    int32_t countSame=0, sumOverlaps=0;\n+#endif\n+\n     int32_t start, newStart, movedStart;\n     int32_t blockLength, overlap;\n     int32_t i, mapIndex, blockCount;\n@@ -1023,6 +1070,9 @@ compactData(UNewTrie2 *trie) {\n         if( (movedStart=findSameDataBlock(trie->data, newStart, start, blockLength))\n              >=0\n         ) {\n+#ifdef UTRIE2_DEBUG\n+            ++countSame;\n+#endif\n             /* found an identical block, set the other block's index value for the current block */\n             for(i=blockCount, mapIndex=start>>UTRIE2_SHIFT_2; i>0; --i) {\n                 trie->map[mapIndex++]=movedStart;\n@@ -1042,6 +1092,9 @@ compactData(UNewTrie2 *trie) {\n             overlap>0 && !equal_uint32(trie->data+(newStart-overlap), trie->data+start, overlap);\n             overlap-=UTRIE2_DATA_GRANULARITY) {}\n \n+#ifdef UTRIE2_DEBUG\n+            sumOverlaps+=overlap;\n+#endif\n         if(overlap>0 || newStart<start) {\n             /* some overlap, or just move the whole block */\n             movedStart=newStart-overlap;\n@@ -1081,8 +1134,8 @@ compactData(UNewTrie2 *trie) {\n \n #ifdef UTRIE2_DEBUG\n     /* we saved some space */\n-    printf(\"compacting UTrie2: count of 32-bit data words %lu->%lu\\n\",\n-            (long)trie->dataLength, (long)newStart);\n+    printf(\"compacting UTrie2: count of 32-bit data words %lu->%lu  countSame=%ld  sumOverlaps=%ld\\n\",\n+            (long)trie->dataLength, (long)newStart, (long)countSame, (long)sumOverlaps);\n #endif\n \n     trie->dataLength=newStart;\n@@ -1163,7 +1216,7 @@ compactIndex2(UNewTrie2 *trie) {\n \n #ifdef UTRIE2_DEBUG\n     /* we saved some space */\n-    printf(\"compacting UTrie2: count of 16-bit index-2 words %lu->%lu\\n\",\n+    printf(\"compacting UTrie2: count of 16-bit index words %lu->%lu\\n\",\n             (long)trie->index2Length, (long)newStart);\n #endif\n \n@@ -1193,7 +1246,7 @@ compactTrie(UTrie2 *trie, UErrorCode *pErrorCode) {\n     trie->highStart=newTrie->highStart=highStart;\n \n #ifdef UTRIE2_DEBUG\n-    printf(\"UTrie2: highStart U+%04lx  highValue 0x%lx  initialValue 0x%lx\\n\",\n+    printf(\"UTrie2: highStart U+%06lx  highValue 0x%lx  initialValue 0x%lx\\n\",\n             (long)highStart, (long)highValue, (long)trie->initialValue);\n #endif\n \n@@ -1211,7 +1264,7 @@ compactTrie(UTrie2 *trie, UErrorCode *pErrorCode) {\n         compactIndex2(newTrie);\n #ifdef UTRIE2_DEBUG\n     } else {\n-        printf(\"UTrie2: highStart U+%04lx  count of 16-bit index-2 words %lu->%lu\\n\",\n+        printf(\"UTrie2: highStart U+%04lx  count of 16-bit index words %lu->%lu\\n\",\n                 (long)highStart, (long)trie->newTrie->index2Length, (long)UTRIE2_INDEX_1_OFFSET);\n #endif\n     }\n@@ -1334,7 +1387,7 @@ utrie2_freeze(UTrie2 *trie, UTrie2ValueBits valueBits, UErrorCode *pErrorCode) {\n     if(highStart<=0x10000) {\n         trie->index2NullOffset=0xffff;\n     } else {\n-        trie->index2NullOffset=UTRIE2_INDEX_2_OFFSET+newTrie->index2NullOffset;\n+        trie->index2NullOffset=static_cast<uint16_t>(UTRIE2_INDEX_2_OFFSET+newTrie->index2NullOffset);\n     }\n     trie->dataNullOffset=(uint16_t)(dataMove+newTrie->dataNullOffset);\n     trie->highValueIndex=dataMove+trie->dataLength-UTRIE2_DATA_GRANULARITY;\n@@ -1411,31 +1464,18 @@ utrie2_freeze(UTrie2 *trie, UTrie2ValueBits valueBits, UErrorCode *pErrorCode) {\n         return;\n     }\n \n+#ifdef UTRIE2_DEBUG\n+    utrie2_printLengths(trie, \"\");\n+#endif\n+\n+#ifdef UCPTRIE_DEBUG\n+    umutablecptrie_setName(newTrie->t3, trie->name);\n+    ucptrie_close(\n+        umutablecptrie_buildImmutable(\n+            newTrie->t3, UCPTRIE_TYPE_FAST, (UCPTrieValueWidth)valueBits, pErrorCode));\n+#endif\n     /* Delete the UNewTrie2. */\n     uprv_free(newTrie->data);\n     uprv_free(newTrie);\n     trie->newTrie=NULL;\n }\n-\n-/*\n- * This is here to avoid a dependency from utrie2.cpp on utrie.c.\n- * This file already depends on utrie.c.\n- * Otherwise, this should be in utrie2.cpp right after utrie2_swap().\n- */\n-U_CAPI int32_t U_EXPORT2\n-utrie2_swapAnyVersion(const UDataSwapper *ds,\n-                      const void *inData, int32_t length, void *outData,\n-                      UErrorCode *pErrorCode) {\n-    if(U_SUCCESS(*pErrorCode)) {\n-        switch(utrie2_getVersion(inData, length, TRUE)) {\n-        case 1:\n-            return utrie_swap(ds, inData, length, outData, pErrorCode);\n-        case 2:\n-            return utrie2_swap(ds, inData, length, outData, pErrorCode);\n-        default:\n-            *pErrorCode=U_INVALID_FORMAT_ERROR;\n-            return 0;\n-        }\n-    }\n-    return 0;\n-}"
        },
        {
            "sha": "2a14db3a6bdd1a5e55398830c581c85607469845",
            "filename": "deps/icu-small/source/common/utrie2_impl.h",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2_impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2_impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie2_impl.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -22,22 +22,20 @@\n #ifndef __UTRIE2_IMPL_H__\n #define __UTRIE2_IMPL_H__\n \n+#ifdef UCPTRIE_DEBUG\n+#include \"unicode/umutablecptrie.h\"\n+#endif\n #include \"utrie2.h\"\n \n /* Public UTrie2 API implementation ----------------------------------------- */\n \n /*\n- * These definitions are mostly needed by utrie2.c,\n+ * These definitions are mostly needed by utrie2.cpp,\n  * but also by utrie2_serialize() and utrie2_swap().\n  */\n \n-/*\n- * UTrie and UTrie2 signature values,\n- * in platform endianness and opposite endianness.\n- */\n-#define UTRIE_SIG       0x54726965\n-#define UTRIE_OE_SIG    0x65697254\n-\n+// UTrie2 signature values, in platform endianness and opposite endianness.\n+// The UTrie2 signature ASCII byte values spell \"Tri2\".\n #define UTRIE2_SIG      0x54726932\n #define UTRIE2_OE_SIG   0x32697254\n \n@@ -145,6 +143,9 @@ struct UNewTrie2 {\n     int32_t index1[UNEWTRIE2_INDEX_1_LENGTH];\n     int32_t index2[UNEWTRIE2_MAX_INDEX_2_LENGTH];\n     uint32_t *data;\n+#ifdef UCPTRIE_DEBUG\n+    UMutableCPTrie *t3;\n+#endif\n \n     uint32_t initialValue, errorValue;\n     int32_t index2Length, dataCapacity, dataLength;"
        },
        {
            "sha": "5abe7bd5d77e14731d4420401b7302ecdaa5245d",
            "filename": "deps/icu-small/source/common/utrie_swap.cpp",
            "status": "added",
            "additions": 344,
            "deletions": 0,
            "changes": 344,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie_swap.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie_swap.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futrie_swap.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,344 @@\n+// Â© 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+// utrie_swap.cpp\n+// created: 2018aug08 Markus W. Scherer\n+\n+#include \"unicode/utypes.h\"\n+#include \"cmemory.h\"\n+#include \"ucptrie_impl.h\"\n+#include \"udataswp.h\"\n+#include \"utrie.h\"\n+#include \"utrie2_impl.h\"\n+\n+// These functions for swapping different generations of ICU code point tries are here\n+// so that their implementation files need not depend on swapper code,\n+// need not depend on each other, and so that other swapper code\n+// need not depend on other trie code.\n+\n+namespace {\n+\n+constexpr int32_t ASCII_LIMIT = 0x80;\n+\n+}  // namespace\n+\n+U_CAPI int32_t U_EXPORT2\n+utrie_swap(const UDataSwapper *ds,\n+           const void *inData, int32_t length, void *outData,\n+           UErrorCode *pErrorCode) {\n+    const UTrieHeader *inTrie;\n+    UTrieHeader trie;\n+    int32_t size;\n+    UBool dataIs32;\n+\n+    if(pErrorCode==NULL || U_FAILURE(*pErrorCode)) {\n+        return 0;\n+    }\n+    if(ds==NULL || inData==NULL || (length>=0 && outData==NULL)) {\n+        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;\n+        return 0;\n+    }\n+\n+    /* setup and swapping */\n+    if(length>=0 && (uint32_t)length<sizeof(UTrieHeader)) {\n+        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n+        return 0;\n+    }\n+\n+    inTrie=(const UTrieHeader *)inData;\n+    trie.signature=ds->readUInt32(inTrie->signature);\n+    trie.options=ds->readUInt32(inTrie->options);\n+    trie.indexLength=udata_readInt32(ds, inTrie->indexLength);\n+    trie.dataLength=udata_readInt32(ds, inTrie->dataLength);\n+\n+    if( trie.signature!=0x54726965 ||\n+        (trie.options&UTRIE_OPTIONS_SHIFT_MASK)!=UTRIE_SHIFT ||\n+        ((trie.options>>UTRIE_OPTIONS_INDEX_SHIFT)&UTRIE_OPTIONS_SHIFT_MASK)!=UTRIE_INDEX_SHIFT ||\n+        trie.indexLength<UTRIE_BMP_INDEX_LENGTH ||\n+        (trie.indexLength&(UTRIE_SURROGATE_BLOCK_COUNT-1))!=0 ||\n+        trie.dataLength<UTRIE_DATA_BLOCK_LENGTH ||\n+        (trie.dataLength&(UTRIE_DATA_GRANULARITY-1))!=0 ||\n+        ((trie.options&UTRIE_OPTIONS_LATIN1_IS_LINEAR)!=0 && trie.dataLength<(UTRIE_DATA_BLOCK_LENGTH+0x100))\n+    ) {\n+        *pErrorCode=U_INVALID_FORMAT_ERROR; /* not a UTrie */\n+        return 0;\n+    }\n+\n+    dataIs32=(UBool)((trie.options&UTRIE_OPTIONS_DATA_IS_32_BIT)!=0);\n+    size=sizeof(UTrieHeader)+trie.indexLength*2+trie.dataLength*(dataIs32?4:2);\n+\n+    if(length>=0) {\n+        UTrieHeader *outTrie;\n+\n+        if(length<size) {\n+            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n+            return 0;\n+        }\n+\n+        outTrie=(UTrieHeader *)outData;\n+\n+        /* swap the header */\n+        ds->swapArray32(ds, inTrie, sizeof(UTrieHeader), outTrie, pErrorCode);\n+\n+        /* swap the index and the data */\n+        if(dataIs32) {\n+            ds->swapArray16(ds, inTrie+1, trie.indexLength*2, outTrie+1, pErrorCode);\n+            ds->swapArray32(ds, (const uint16_t *)(inTrie+1)+trie.indexLength, trie.dataLength*4,\n+                                     (uint16_t *)(outTrie+1)+trie.indexLength, pErrorCode);\n+        } else {\n+            ds->swapArray16(ds, inTrie+1, (trie.indexLength+trie.dataLength)*2, outTrie+1, pErrorCode);\n+        }\n+    }\n+\n+    return size;\n+}\n+\n+U_CAPI int32_t U_EXPORT2\n+utrie2_swap(const UDataSwapper *ds,\n+            const void *inData, int32_t length, void *outData,\n+            UErrorCode *pErrorCode) {\n+    const UTrie2Header *inTrie;\n+    UTrie2Header trie;\n+    int32_t dataLength, size;\n+    UTrie2ValueBits valueBits;\n+\n+    if(U_FAILURE(*pErrorCode)) {\n+        return 0;\n+    }\n+    if(ds==NULL || inData==NULL || (length>=0 && outData==NULL)) {\n+        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;\n+        return 0;\n+    }\n+\n+    /* setup and swapping */\n+    if(length>=0 && length<(int32_t)sizeof(UTrie2Header)) {\n+        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n+        return 0;\n+    }\n+\n+    inTrie=(const UTrie2Header *)inData;\n+    trie.signature=ds->readUInt32(inTrie->signature);\n+    trie.options=ds->readUInt16(inTrie->options);\n+    trie.indexLength=ds->readUInt16(inTrie->indexLength);\n+    trie.shiftedDataLength=ds->readUInt16(inTrie->shiftedDataLength);\n+\n+    valueBits=(UTrie2ValueBits)(trie.options&UTRIE2_OPTIONS_VALUE_BITS_MASK);\n+    dataLength=(int32_t)trie.shiftedDataLength<<UTRIE2_INDEX_SHIFT;\n+\n+    if( trie.signature!=UTRIE2_SIG ||\n+        valueBits<0 || UTRIE2_COUNT_VALUE_BITS<=valueBits ||\n+        trie.indexLength<UTRIE2_INDEX_1_OFFSET ||\n+        dataLength<UTRIE2_DATA_START_OFFSET\n+    ) {\n+        *pErrorCode=U_INVALID_FORMAT_ERROR; /* not a UTrie */\n+        return 0;\n+    }\n+\n+    size=sizeof(UTrie2Header)+trie.indexLength*2;\n+    switch(valueBits) {\n+    case UTRIE2_16_VALUE_BITS:\n+        size+=dataLength*2;\n+        break;\n+    case UTRIE2_32_VALUE_BITS:\n+        size+=dataLength*4;\n+        break;\n+    default:\n+        *pErrorCode=U_INVALID_FORMAT_ERROR;\n+        return 0;\n+    }\n+\n+    if(length>=0) {\n+        UTrie2Header *outTrie;\n+\n+        if(length<size) {\n+            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n+            return 0;\n+        }\n+\n+        outTrie=(UTrie2Header *)outData;\n+\n+        /* swap the header */\n+        ds->swapArray32(ds, &inTrie->signature, 4, &outTrie->signature, pErrorCode);\n+        ds->swapArray16(ds, &inTrie->options, 12, &outTrie->options, pErrorCode);\n+\n+        /* swap the index and the data */\n+        switch(valueBits) {\n+        case UTRIE2_16_VALUE_BITS:\n+            ds->swapArray16(ds, inTrie+1, (trie.indexLength+dataLength)*2, outTrie+1, pErrorCode);\n+            break;\n+        case UTRIE2_32_VALUE_BITS:\n+            ds->swapArray16(ds, inTrie+1, trie.indexLength*2, outTrie+1, pErrorCode);\n+            ds->swapArray32(ds, (const uint16_t *)(inTrie+1)+trie.indexLength, dataLength*4,\n+                                     (uint16_t *)(outTrie+1)+trie.indexLength, pErrorCode);\n+            break;\n+        default:\n+            *pErrorCode=U_INVALID_FORMAT_ERROR;\n+            return 0;\n+        }\n+    }\n+\n+    return size;\n+}\n+\n+U_CAPI int32_t U_EXPORT2\n+ucptrie_swap(const UDataSwapper *ds,\n+             const void *inData, int32_t length, void *outData,\n+             UErrorCode *pErrorCode) {\n+    const UCPTrieHeader *inTrie;\n+    UCPTrieHeader trie;\n+    int32_t dataLength, size;\n+    UCPTrieValueWidth valueWidth;\n+\n+    if(U_FAILURE(*pErrorCode)) {\n+        return 0;\n+    }\n+    if(ds==nullptr || inData==nullptr || (length>=0 && outData==nullptr)) {\n+        *pErrorCode=U_ILLEGAL_ARGUMENT_ERROR;\n+        return 0;\n+    }\n+\n+    /* setup and swapping */\n+    if(length>=0 && length<(int32_t)sizeof(UCPTrieHeader)) {\n+        *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n+        return 0;\n+    }\n+\n+    inTrie=(const UCPTrieHeader *)inData;\n+    trie.signature=ds->readUInt32(inTrie->signature);\n+    trie.options=ds->readUInt16(inTrie->options);\n+    trie.indexLength=ds->readUInt16(inTrie->indexLength);\n+    trie.dataLength = ds->readUInt16(inTrie->dataLength);\n+\n+    UCPTrieType type = (UCPTrieType)((trie.options >> 6) & 3);\n+    valueWidth = (UCPTrieValueWidth)(trie.options & UCPTRIE_OPTIONS_VALUE_BITS_MASK);\n+    dataLength = ((int32_t)(trie.options & UCPTRIE_OPTIONS_DATA_LENGTH_MASK) << 4) | trie.dataLength;\n+\n+    int32_t minIndexLength = type == UCPTRIE_TYPE_FAST ?\n+        UCPTRIE_BMP_INDEX_LENGTH : UCPTRIE_SMALL_INDEX_LENGTH;\n+    if( trie.signature!=UCPTRIE_SIG ||\n+        type > UCPTRIE_TYPE_SMALL ||\n+        (trie.options & UCPTRIE_OPTIONS_RESERVED_MASK) != 0 ||\n+        valueWidth > UCPTRIE_VALUE_BITS_8 ||\n+        trie.indexLength < minIndexLength ||\n+        dataLength < ASCII_LIMIT\n+    ) {\n+        *pErrorCode=U_INVALID_FORMAT_ERROR; /* not a UCPTrie */\n+        return 0;\n+    }\n+\n+    size=sizeof(UCPTrieHeader)+trie.indexLength*2;\n+    switch(valueWidth) {\n+    case UCPTRIE_VALUE_BITS_16:\n+        size+=dataLength*2;\n+        break;\n+    case UCPTRIE_VALUE_BITS_32:\n+        size+=dataLength*4;\n+        break;\n+    case UCPTRIE_VALUE_BITS_8:\n+        size+=dataLength;\n+        break;\n+    default:\n+        *pErrorCode=U_INVALID_FORMAT_ERROR;\n+        return 0;\n+    }\n+\n+    if(length>=0) {\n+        UCPTrieHeader *outTrie;\n+\n+        if(length<size) {\n+            *pErrorCode=U_INDEX_OUTOFBOUNDS_ERROR;\n+            return 0;\n+        }\n+\n+        outTrie=(UCPTrieHeader *)outData;\n+\n+        /* swap the header */\n+        ds->swapArray32(ds, &inTrie->signature, 4, &outTrie->signature, pErrorCode);\n+        ds->swapArray16(ds, &inTrie->options, 12, &outTrie->options, pErrorCode);\n+\n+        /* swap the index and the data */\n+        switch(valueWidth) {\n+        case UCPTRIE_VALUE_BITS_16:\n+            ds->swapArray16(ds, inTrie+1, (trie.indexLength+dataLength)*2, outTrie+1, pErrorCode);\n+            break;\n+        case UCPTRIE_VALUE_BITS_32:\n+            ds->swapArray16(ds, inTrie+1, trie.indexLength*2, outTrie+1, pErrorCode);\n+            ds->swapArray32(ds, (const uint16_t *)(inTrie+1)+trie.indexLength, dataLength*4,\n+                                     (uint16_t *)(outTrie+1)+trie.indexLength, pErrorCode);\n+            break;\n+        case UCPTRIE_VALUE_BITS_8:\n+            ds->swapArray16(ds, inTrie+1, trie.indexLength*2, outTrie+1, pErrorCode);\n+            if(inTrie!=outTrie) {\n+                uprv_memmove((outTrie+1)+trie.indexLength, (inTrie+1)+trie.indexLength, dataLength);\n+            }\n+            break;\n+        default:\n+            *pErrorCode=U_INVALID_FORMAT_ERROR;\n+            return 0;\n+        }\n+    }\n+\n+    return size;\n+}\n+\n+namespace {\n+\n+/**\n+ * Gets the trie version from 32-bit-aligned memory containing the serialized form\n+ * of a UTrie (version 1), a UTrie2 (version 2), or a UCPTrie (version 3).\n+ *\n+ * @param data a pointer to 32-bit-aligned memory containing the serialized form of a trie\n+ * @param length the number of bytes available at data;\n+ *               can be more than necessary (see return value)\n+ * @param anyEndianOk If FALSE, only platform-endian serialized forms are recognized.\n+ *                    If TRUE, opposite-endian serialized forms are recognized as well.\n+ * @return the trie version of the serialized form, or 0 if it is not\n+ *         recognized as a serialized trie\n+ */\n+int32_t\n+getVersion(const void *data, int32_t length, UBool anyEndianOk) {\n+    uint32_t signature;\n+    if(length<16 || data==nullptr || (U_POINTER_MASK_LSB(data, 3)!=0)) {\n+        return 0;\n+    }\n+    signature=*(const uint32_t *)data;\n+    if(signature==UCPTRIE_SIG) {\n+        return 3;\n+    }\n+    if(anyEndianOk && signature==UCPTRIE_OE_SIG) {\n+        return 3;\n+    }\n+    if(signature==UTRIE2_SIG) {\n+        return 2;\n+    }\n+    if(anyEndianOk && signature==UTRIE2_OE_SIG) {\n+        return 2;\n+    }\n+    if(signature==UTRIE_SIG) {\n+        return 1;\n+    }\n+    if(anyEndianOk && signature==UTRIE_OE_SIG) {\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+}  // namespace\n+\n+U_CAPI int32_t U_EXPORT2\n+utrie_swapAnyVersion(const UDataSwapper *ds,\n+                     const void *inData, int32_t length, void *outData,\n+                     UErrorCode *pErrorCode) {\n+    if(U_FAILURE(*pErrorCode)) { return 0; }\n+    switch(getVersion(inData, length, TRUE)) {\n+    case 1:\n+        return utrie_swap(ds, inData, length, outData, pErrorCode);\n+    case 2:\n+        return utrie2_swap(ds, inData, length, outData, pErrorCode);\n+    case 3:\n+        return ucptrie_swap(ds, inData, length, outData, pErrorCode);\n+    default:\n+        *pErrorCode=U_INVALID_FORMAT_ERROR;\n+        return 0;\n+    }\n+}"
        },
        {
            "sha": "b9e6cb023bb379964838caf16ff2285c54cfdbf1",
            "filename": "deps/icu-small/source/common/uts46.cpp",
            "status": "modified",
            "additions": 17,
            "deletions": 6,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futs46.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Futs46.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Futs46.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -557,23 +557,34 @@ UTS46::processUnicode(const UnicodeString &src,\n             destArray=dest.getBuffer();\n             destLength+=newLength-labelLength;\n             labelLimit=labelStart+=newLength+1;\n-        } else if(0xdf<=c && c<=0x200d && (c==0xdf || c==0x3c2 || c>=0x200c)) {\n+            continue;\n+        } else if(c<0xdf) {\n+            // pass\n+        } else if(c<=0x200d && (c==0xdf || c==0x3c2 || c>=0x200c)) {\n             info.isTransDiff=TRUE;\n             if(doMapDevChars) {\n                 destLength=mapDevChars(dest, labelStart, labelLimit, errorCode);\n                 if(U_FAILURE(errorCode)) {\n                     return dest;\n                 }\n                 destArray=dest.getBuffer();\n-                // Do not increment labelLimit in case c was removed.\n                 // All deviation characters have been mapped, no need to check for them again.\n                 doMapDevChars=FALSE;\n-            } else {\n-                ++labelLimit;\n+                // Do not increment labelLimit in case c was removed.\n+                continue;\n+            }\n+        } else if(U16_IS_SURROGATE(c)) {\n+            if(U16_IS_SURROGATE_LEAD(c) ?\n+                    (labelLimit+1)==destLength || !U16_IS_TRAIL(destArray[labelLimit+1]) :\n+                    labelLimit==labelStart || !U16_IS_LEAD(destArray[labelLimit-1])) {\n+                // Map an unpaired surrogate to U+FFFD before normalization so that when\n+                // that removes characters we do not turn two unpaired ones into a pair.\n+                info.labelErrors|=UIDNA_ERROR_DISALLOWED;\n+                dest.setCharAt(labelLimit, 0xfffd);\n+                destArray=dest.getBuffer();\n             }\n-        } else {\n-            ++labelLimit;\n         }\n+        ++labelLimit;\n     }\n     // Permit an empty label at the end (0<labelStart==labelLimit==destLength is ok)\n     // but not an empty label elsewhere nor a completely empty domain name."
        },
        {
            "sha": "764d99d06b30e70e7963e6d87c7a01af11af4bac",
            "filename": "deps/icu-small/source/common/wintz.cpp",
            "status": "modified",
            "additions": 59,
            "deletions": 329,
            "changes": 388,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fwintz.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fwintz.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fwintz.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -13,16 +13,15 @@\n \n #include \"unicode/utypes.h\"\n \n-// This file contains only desktop Windows behavior\n-// Windows UWP calls Windows::Globalization directly, so this isn't needed there.\n-#if U_PLATFORM_USES_ONLY_WIN32_API && (U_PLATFORM_HAS_WINUWP_API == 0)\n+#if U_PLATFORM_USES_ONLY_WIN32_API\n \n #include \"wintz.h\"\n #include \"cmemory.h\"\n #include \"cstring.h\"\n \n #include \"unicode/ures.h\"\n #include \"unicode/ustring.h\"\n+#include \"uresimp.h\"\n \n #ifndef WIN32_LEAN_AND_MEAN\n #   define WIN32_LEAN_AND_MEAN\n@@ -34,363 +33,94 @@\n #   define NOMCX\n #include <windows.h>\n \n-#define MAX_LENGTH_ID 40\n+U_NAMESPACE_BEGIN\n \n-/* The layout of the Tzi value in the registry */\n-typedef struct\n-{\n-    int32_t bias;\n-    int32_t standardBias;\n-    int32_t daylightBias;\n-    SYSTEMTIME standardDate;\n-    SYSTEMTIME daylightDate;\n-} TZI;\n-\n-/**\n- * Various registry keys and key fragments.\n- */\n-static const wchar_t CURRENT_ZONE_REGKEY[] = L\"SYSTEM\\\\CurrentControlSet\\\\Control\\\\TimeZoneInformation\\\\\";\n-static const char STANDARD_TIME_REGKEY[] = \" Standard Time\";\n-static const char TZI_REGKEY[] = \"TZI\";\n-static const char STD_REGKEY[] = \"Std\";\n+// The value of MAX_TIMEZONE_ID_LENGTH is 128, which is defined in DYNAMIC_TIME_ZONE_INFORMATION\n+#define MAX_TIMEZONE_ID_LENGTH 128\n \n /**\n- * The time zone root keys (under HKLM) for Win7+\n- */\n-static const char TZ_REGKEY[] = \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Time Zones\\\\\";\n-\n-static LONG openTZRegKey(HKEY *hkey, const char *winid)\n-{\n-    char subKeyName[110]; /* TODO: why 110?? */\n-    char *name;\n-    LONG result;\n-\n-    uprv_strcpy(subKeyName, TZ_REGKEY);\n-    name = &subKeyName[strlen(subKeyName)];\n-    uprv_strcat(subKeyName, winid);\n-\n-    result = RegOpenKeyExA(HKEY_LOCAL_MACHINE,\n-                            subKeyName,\n-                            0,\n-                            KEY_QUERY_VALUE,\n-                            hkey);\n-    return result;\n-}\n-\n-static LONG getTZI(const char *winid, TZI *tzi)\n-{\n-    DWORD cbData = sizeof(TZI);\n-    LONG result;\n-    HKEY hkey;\n-\n-    result = openTZRegKey(&hkey, winid);\n-\n-    if (result == ERROR_SUCCESS)\n-    {\n-        result = RegQueryValueExA(hkey,\n-                                    TZI_REGKEY,\n-                                    NULL,\n-                                    NULL,\n-                                    (LPBYTE)tzi,\n-                                    &cbData);\n-        RegCloseKey(hkey);\n-    }\n-\n-    return result;\n-}\n-\n-static LONG getSTDName(const char *winid, char *regStdName, int32_t length)\n-{\n-    DWORD cbData = length;\n-    LONG result;\n-    HKEY hkey;\n-\n-    result = openTZRegKey(&hkey, winid);\n-\n-    if (result == ERROR_SUCCESS)\n-    {\n-        result = RegQueryValueExA(hkey,\n-                                    STD_REGKEY,\n-                                    NULL,\n-                                    NULL,\n-                                    (LPBYTE)regStdName,\n-                                    &cbData);\n-        RegCloseKey(hkey);\n-    }\n-\n-    return result;\n-}\n-\n-static LONG getTZKeyName(char* tzKeyName, int32_t tzKeyNamelength)\n-{\n-    HKEY hkey;\n-    LONG result = FALSE;\n-    WCHAR timeZoneKeyNameData[128];\n-    DWORD timeZoneKeyNameLength = static_cast<DWORD>(sizeof(timeZoneKeyNameData));\n-\n-    if(ERROR_SUCCESS == RegOpenKeyExW(\n-        HKEY_LOCAL_MACHINE,\n-        CURRENT_ZONE_REGKEY,\n-        0,\n-        KEY_QUERY_VALUE,\n-        &hkey))\n-    {\n-        if (ERROR_SUCCESS == RegQueryValueExW(\n-             hkey,\n-             L\"TimeZoneKeyName\",\n-             NULL,\n-             NULL,\n-             (LPBYTE)timeZoneKeyNameData,\n-             &timeZoneKeyNameLength))\n-        {\n-            // Ensure null termination.\n-            timeZoneKeyNameData[UPRV_LENGTHOF(timeZoneKeyNameData) - 1] = L'\\0';\n-\n-            // Convert the UTF-16 string to UTF-8.\n-            UErrorCode status = U_ZERO_ERROR;\n-            u_strToUTF8(tzKeyName, tzKeyNamelength, NULL, reinterpret_cast<const UChar *>(timeZoneKeyNameData), -1, &status);\n-            if (U_ZERO_ERROR == status)\n-            {\n-                result = ERROR_SUCCESS;\n-            }\n-        }\n-        RegCloseKey(hkey);\n-    }\n-\n-    return result;\n-}\n-\n-/*\n-  This code attempts to detect the Windows time zone directly,\n-  as set in the Windows Date and Time control panel.  It attempts\n-  to work on versions greater than Windows Vista and on localized\n-  installs.  It works by directly interrogating the registry and\n-  comparing the data there with the data returned by the\n-  GetTimeZoneInformation API, along with some other strategies.  The\n-  registry contains time zone data under this key:\n-\n-    HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones\\\n-\n-  Under this key are several subkeys, one for each time zone.  For\n-  example these subkeys are named \"Pacific Standard Time\" on Vista+.\n-  There are some other wrinkles; see the code for\n-  details.  The subkey name is NOT LOCALIZED, allowing us to support\n-  localized installs.\n-\n-  Under the subkey are data values.  We care about:\n-\n-    Std   Standard time display name, localized\n-    TZI   Binary block of data\n-\n-  The TZI data is of particular interest.  It contains the offset, two\n-  more offsets for standard and daylight time, and the start and end\n-  rules.  This is the same data returned by the GetTimeZoneInformation\n-  API.  The API may modify the data on the way out, so we have to be\n-  careful, but essentially we do a binary comparison against the TZI\n-  blocks of various registry keys.  When we find a match, we know what\n-  time zone Windows is set to.  Since the registry key is not\n-  localized, we can then translate the key through a simple table\n-  lookup into the corresponding ICU time zone.\n-\n-  This strategy doesn't always work because there are zones which\n-  share an offset and rules, so more than one TZI block will match.\n-  For example, both Tokyo and Seoul are at GMT+9 with no DST rules;\n-  their TZI blocks are identical.  For these cases, we fall back to a\n-  name lookup.  We attempt to match the display name as stored in the\n-  registry for the current zone to the display name stored in the\n-  registry for various Windows zones.  By comparing the registry data\n-  directly we avoid conversion complications.\n-\n-  Author: Alan Liu\n-  Since: ICU 2.6\n-  Based on original code by Carl Brown <cbrown@xnetinc.com>\n+* Main Windows time zone detection function.\n+* Returns the Windows time zone converted to an ICU time zone as a heap-allocated buffer, or nullptr upon failure.\n+* Note: We use the Win32 API GetDynamicTimeZoneInformation to get the current time zone info.\n+* This API returns a non-localized time zone name, which we can then map to an ICU time zone name.\n */\n-\n-/**\n- * Main Windows time zone detection function.  Returns the Windows\n- * time zone, translated to an ICU time zone, or NULL upon failure.\n- */\n U_CFUNC const char* U_EXPORT2\n uprv_detectWindowsTimeZone()\n {\n     UErrorCode status = U_ZERO_ERROR;\n-    UResourceBundle* bundle = NULL;\n-    char* icuid = NULL;\n-    char apiStdName[MAX_LENGTH_ID];\n-    char regStdName[MAX_LENGTH_ID];\n-    char tmpid[MAX_LENGTH_ID];\n+    char* icuid = nullptr;\n+    char dynamicTZKeyName[MAX_TIMEZONE_ID_LENGTH];\n+    char tmpid[MAX_TIMEZONE_ID_LENGTH];\n     int32_t len;\n-    int id;\n+    int id = GEOID_NOT_AVAILABLE;\n     int errorCode;\n-    wchar_t ISOcodeW[3]; /* 2 letter iso code in UTF-16*/\n-    char  ISOcodeA[3]; /* 2 letter iso code in ansi */\n+    wchar_t ISOcodeW[3] = {}; /* 2 letter ISO code in UTF-16 */\n+    char ISOcode[3] = {}; /* 2 letter ISO code in UTF-8 */\n \n-    LONG result;\n-    TZI tziKey;\n-    TZI tziReg;\n-    TIME_ZONE_INFORMATION apiTZI;\n+    DYNAMIC_TIME_ZONE_INFORMATION dynamicTZI;\n+    uprv_memset(&dynamicTZI, 0, sizeof(dynamicTZI));\n+    uprv_memset(dynamicTZKeyName, 0, sizeof(dynamicTZKeyName));\n+    uprv_memset(tmpid, 0, sizeof(tmpid));\n \n-    BOOL tryPreVistaFallback;\n-    OSVERSIONINFO osVerInfo;\n+    /* Obtain TIME_ZONE_INFORMATION from the API and get the non-localized time zone name. */\n+    if (TIME_ZONE_ID_INVALID == GetDynamicTimeZoneInformation(&dynamicTZI)) {\n+        return nullptr;\n+    }\n \n-    /* Obtain TIME_ZONE_INFORMATION from the API, and then convert it\n-       to TZI.  We could also interrogate the registry directly; we do\n-       this below if needed. */\n-    uprv_memset(&apiTZI, 0, sizeof(apiTZI));\n-    uprv_memset(&tziKey, 0, sizeof(tziKey));\n-    uprv_memset(&tziReg, 0, sizeof(tziReg));\n-    GetTimeZoneInformation(&apiTZI);\n-    tziKey.bias = apiTZI.Bias;\n-    uprv_memcpy((char *)&tziKey.standardDate, (char*)&apiTZI.StandardDate,\n-           sizeof(apiTZI.StandardDate));\n-    uprv_memcpy((char *)&tziKey.daylightDate, (char*)&apiTZI.DaylightDate,\n-           sizeof(apiTZI.DaylightDate));\n+    id = GetUserGeoID(GEOCLASS_NATION);\n+    errorCode = GetGeoInfoW(id, GEO_ISO2, ISOcodeW, 3, 0);\n \n-    /* Convert the wchar_t* standard name to char* */\n-    uprv_memset(apiStdName, 0, sizeof(apiStdName));\n-    wcstombs(apiStdName, apiTZI.StandardName, MAX_LENGTH_ID);\n+    // convert from wchar_t* (UTF-16 on Windows) to char* (UTF-8).\n+    u_strToUTF8(ISOcode, UPRV_LENGTHOF(ISOcode), nullptr,\n+        reinterpret_cast<const UChar*>(ISOcodeW), UPRV_LENGTHOF(ISOcodeW), &status);\n \n-    tmpid[0] = 0;\n+    LocalUResourceBundlePointer bundle(ures_openDirect(nullptr, \"windowsZones\", &status));\n+    ures_getByKey(bundle.getAlias(), \"mapTimezones\", bundle.getAlias(), &status);\n \n-    id = GetUserGeoID(GEOCLASS_NATION);\n-    errorCode = GetGeoInfoW(id, GEO_ISO2, ISOcodeW, 3, 0);\n-    u_strToUTF8(ISOcodeA, 3, NULL, (const UChar *)ISOcodeW, 3, &status);\n+    // convert from wchar_t* (UTF-16 on Windows) to char* (UTF-8).\n+    u_strToUTF8(dynamicTZKeyName, UPRV_LENGTHOF(dynamicTZKeyName), nullptr,\n+        reinterpret_cast<const UChar*>(dynamicTZI.TimeZoneKeyName), UPRV_LENGTHOF(dynamicTZI.TimeZoneKeyName), &status);\n+\n+    if (U_FAILURE(status)) {\n+        return nullptr;\n+    }\n \n-    bundle = ures_openDirect(NULL, \"windowsZones\", &status);\n-    ures_getByKey(bundle, \"mapTimezones\", bundle, &status);\n+    if (dynamicTZI.TimeZoneKeyName[0] != 0) {\n+        UResourceBundle winTZ;\n+        ures_initStackObject(&winTZ);\n+        ures_getByKey(bundle.getAlias(), dynamicTZKeyName, &winTZ, &status);\n \n-    /*\n-        Windows Vista+ provides us with a \"TimeZoneKeyName\" that is not localized\n-        and can be used to directly map a name in our bundle. Try to use that first\n-        if we're on Vista or higher\n-    */\n-    uprv_memset(&osVerInfo, 0, sizeof(osVerInfo));\n-    osVerInfo.dwOSVersionInfoSize = sizeof(osVerInfo);\n-    tryPreVistaFallback = TRUE;\n-    result = getTZKeyName(regStdName, sizeof(regStdName));\n-    if(ERROR_SUCCESS == result)\n-    {\n-        UResourceBundle* winTZ = ures_getByKey(bundle, regStdName, NULL, &status);\n-        if(U_SUCCESS(status))\n-        {\n-            const UChar* icuTZ = NULL;\n-            if (errorCode != 0)\n-            {\n-                icuTZ = ures_getStringByKey(winTZ, ISOcodeA, &len, &status);\n+        if (U_SUCCESS(status)) {\n+            const UChar* icuTZ = nullptr;\n+            if (errorCode != 0) {\n+                icuTZ = ures_getStringByKey(&winTZ, ISOcode, &len, &status);\n             }\n-            if (errorCode==0 || icuTZ==NULL)\n-            {\n+            if (errorCode == 0 || icuTZ == nullptr) {\n                 /* fallback to default \"001\" and reset status */\n                 status = U_ZERO_ERROR;\n-                icuTZ = ures_getStringByKey(winTZ, \"001\", &len, &status);\n+                icuTZ = ures_getStringByKey(&winTZ, \"001\", &len, &status);\n             }\n \n-            if(U_SUCCESS(status))\n-            {\n-                int index=0;\n-                while (! (*icuTZ == '\\0' || *icuTZ ==' '))\n-                {\n-                    tmpid[index++]=(char)(*icuTZ++);  /* safe to assume 'char' is ASCII compatible on windows */\n-                }\n-                tmpid[index]='\\0';\n-                tryPreVistaFallback = FALSE;\n-            }\n-        }\n-        ures_close(winTZ);\n-    }\n+            if (U_SUCCESS(status)) {\n+                int index = 0;\n \n-    if(tryPreVistaFallback)\n-    {\n-        /* Note: We get the winid not from static tables but from resource bundle. */\n-        while (U_SUCCESS(status) && ures_hasNext(bundle))\n-        {\n-            UBool idFound = FALSE;\n-            const char* winid;\n-            UResourceBundle* winTZ = ures_getNextResource(bundle, NULL, &status);\n-            if (U_FAILURE(status))\n-            {\n-                break;\n-            }\n-            winid = ures_getKey(winTZ);\n-            result = getTZI(winid, &tziReg);\n-\n-            if (result == ERROR_SUCCESS)\n-            {\n-                /* Windows alters the DaylightBias in some situations.\n-                   Using the bias and the rules suffices, so overwrite\n-                   these unreliable fields. */\n-                tziKey.standardBias = tziReg.standardBias;\n-                tziKey.daylightBias = tziReg.daylightBias;\n-\n-                if (uprv_memcmp((char *)&tziKey, (char*)&tziReg, sizeof(tziKey)) == 0)\n-                {\n-                    const UChar* icuTZ = NULL;\n-                    if (errorCode != 0)\n-                    {\n-                        icuTZ = ures_getStringByKey(winTZ, ISOcodeA, &len, &status);\n-                    }\n-                    if (errorCode==0 || icuTZ==NULL)\n-                    {\n-                        /* fallback to default \"001\" and reset status */\n-                        status = U_ZERO_ERROR;\n-                        icuTZ = ures_getStringByKey(winTZ, \"001\", &len, &status);\n-                    }\n-\n-                    if (U_SUCCESS(status))\n-                    {\n-                        /* Get the standard name from the registry key to compare with\n-                           the one from Windows API call. */\n-                        uprv_memset(regStdName, 0, sizeof(regStdName));\n-                        result = getSTDName(winid, regStdName, sizeof(regStdName));\n-                        if (result == ERROR_SUCCESS)\n-                        {\n-                            if (uprv_strcmp(apiStdName, regStdName) == 0)\n-                            {\n-                                idFound = TRUE;\n-                            }\n-                        }\n-\n-                        /* tmpid buffer holds the ICU timezone ID corresponding to the timezone ID from Windows.\n-                         * If none is found, tmpid buffer will contain a fallback ID (i.e. the time zone ID matching\n-                         * the current time zone information)\n-                         */\n-                        if (idFound || tmpid[0] == 0)\n-                        {\n-                            /* if icuTZ has more than one city, take only the first (i.e. terminate icuTZ at first space) */\n-                            int index=0;\n-                            while (! (*icuTZ == '\\0' || *icuTZ ==' '))\n-                            {\n-                                tmpid[index++]=(char)(*icuTZ++);  /* safe to assume 'char' is ASCII compatible on windows */\n-                            }\n-                            tmpid[index]='\\0';\n-                        }\n-                    }\n+                while (!(*icuTZ == '\\0' || *icuTZ == ' ')) {\n+                    // time zone IDs only contain ASCII invariant characters.\n+                    tmpid[index++] = (char)(*icuTZ++);\n                 }\n-            }\n-            ures_close(winTZ);\n-            if (idFound)\n-            {\n-                break;\n+                tmpid[index] = '\\0';\n             }\n         }\n+        ures_close(&winTZ);\n     }\n \n-    /*\n-     * Copy the timezone ID to icuid to be returned.\n-     */\n-    if (tmpid[0] != 0)\n-    {\n-        len = uprv_strlen(tmpid);\n-        icuid = (char*)uprv_calloc(len + 1, sizeof(char));\n-        if (icuid != NULL)\n-        {\n-            uprv_strcpy(icuid, tmpid);\n-        }\n+    // Copy the timezone ID to icuid to be returned.\n+    if (tmpid[0] != 0) {\n+        icuid = uprv_strdup(tmpid);\n     }\n \n-    ures_close(bundle);\n-\n     return icuid;\n }\n \n-#endif /* U_PLATFORM_USES_ONLY_WIN32_API && (U_PLATFORM_HAS_WINUWP_API == 0) */\n+U_NAMESPACE_END\n+#endif /* U_PLATFORM_USES_ONLY_WIN32_API  */"
        },
        {
            "sha": "0625bb204b197cf9b236d2fd48f524186d7264c8",
            "filename": "deps/icu-small/source/common/wintz.h",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fwintz.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fcommon%2Fwintz.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fcommon%2Fwintz.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -16,9 +16,7 @@\n \n #include \"unicode/utypes.h\"\n \n-// This file contains only desktop windows behavior\n-// Windows UWP calls Windows::Globalization directly, so this isn't needed there.\n-#if U_PLATFORM_USES_ONLY_WIN32_API && (U_PLATFORM_HAS_WINUWP_API == 0)\n+#if U_PLATFORM_USES_ONLY_WIN32_API\n \n /**\n  * \\file\n@@ -33,6 +31,6 @@ U_CDECL_END\n U_CFUNC const char* U_EXPORT2\n uprv_detectWindowsTimeZone();\n \n-#endif /* U_PLATFORM_USES_ONLY_WIN32_API && (U_PLATFORM_HAS_WINUWP_API == 0) */\n+#endif /* U_PLATFORM_USES_ONLY_WIN32_API  */\n \n #endif /* __WINTZ */"
        },
        {
            "sha": "60f57612c0d0e32564ed40c84177cdddcea92062",
            "filename": "deps/icu-small/source/data/in/icudt63l.dat",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fdata%2Fin%2Ficudt63l.dat",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fdata%2Fin%2Ficudt63l.dat",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fdata%2Fin%2Ficudt63l.dat?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "previous_filename": "deps/icu-small/source/data/in/icudt62l.dat"
        },
        {
            "sha": "99f70114cbdb156747a42275f4dc56126d73128a",
            "filename": "deps/icu-small/source/i18n/alphaindex.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Falphaindex.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Falphaindex.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Falphaindex.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -511,8 +511,8 @@ BucketList *AlphabeticIndex::createBucketList(UErrorCode &errorCode) const {\n                                           ces, errorCode) &&\n                 current.charAt(current.length() - 1) != 0xFFFF /* !current.endsWith(\"\\uffff\") */) {\n             // \"AE-ligature\" or \"Sch\" etc.\n-            for (int32_t i = bucketList->size() - 2;; --i) {\n-                Bucket *singleBucket = getBucket(*bucketList, i);\n+            for (int32_t j = bucketList->size() - 2;; --j) {\n+                Bucket *singleBucket = getBucket(*bucketList, j);\n                 if (singleBucket->labelType_ != U_ALPHAINDEX_NORMAL) {\n                     // There is no single-character bucket since the last\n                     // underflow or inflow label.\n@@ -608,8 +608,8 @@ BucketList *AlphabeticIndex::createBucketList(UErrorCode &errorCode) const {\n     }\n     // Do not call publicBucketList->setDeleter():\n     // This vector shares its objects with the bucketList.\n-    for (int32_t i = 0; i < bucketList->size(); ++i) {\n-        bucket = getBucket(*bucketList, i);\n+    for (int32_t j = 0; j < bucketList->size(); ++j) {\n+        bucket = getBucket(*bucketList, j);\n         if (bucket->displayBucket_ == NULL) {\n             publicBucketList->addElement(bucket, errorCode);\n         }"
        },
        {
            "sha": "6e382b824b95b7cd6ba8932c3b18c2cee0756c19",
            "filename": "deps/icu-small/source/i18n/anytrans.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fanytrans.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fanytrans.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fanytrans.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -391,12 +391,12 @@ void AnyTransliterator::registerIDs() {\n                 UnicodeString id;\n                 TransliteratorIDParser::STVtoID(UnicodeString(TRUE, ANY, 3), target, variant, id);\n                 ec = U_ZERO_ERROR;\n-                AnyTransliterator* t = new AnyTransliterator(id, target, variant,\n+                AnyTransliterator* tl = new AnyTransliterator(id, target, variant,\n                                                              targetScript, ec);\n                 if (U_FAILURE(ec)) {\n-                    delete t;\n+                    delete tl;\n                 } else {\n-                    Transliterator::_registerInstance(t);\n+                    Transliterator::_registerInstance(tl);\n                     Transliterator::_registerSpecialInverse(target, UnicodeString(TRUE, NULL_ID, 4), FALSE);\n                 }\n             }"
        },
        {
            "sha": "24c2fb964e91a1b92036ca14d4e112155619f536",
            "filename": "deps/icu-small/source/i18n/calendar.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcalendar.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcalendar.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fcalendar.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -3797,7 +3797,7 @@ Calendar::setWeekData(const Locale& desiredLocale, const char *type, UErrorCode&\n         Locale max = Locale::createFromName(maxLocaleID);\n         useLocale = Locale(max.getLanguage(),max.getCountry());\n     } else {\n-        useLocale = Locale(desiredLocale);\n+        useLocale = desiredLocale;\n     }\n \n     /* The code here is somewhat of a hack, since week data and weekend data aren't really tied to"
        },
        {
            "sha": "2a614fac5dcfbc67994864da0c5d5b67a3df9eed",
            "filename": "deps/icu-small/source/i18n/coll.cpp",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcoll.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcoll.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fcoll.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -448,6 +448,13 @@ Collator* U_EXPORT2 Collator::createInstance(const Locale& desiredLocale,\n #endif\n     {\n         coll = makeInstance(desiredLocale, status);\n+        // Either returns NULL with U_FAILURE(status), or non-NULL with U_SUCCESS(status)\n+    }\n+    // The use of *coll in setAttributesFromKeywords can cause the NULL check to be\n+    // optimized out of the delete even though setAttributesFromKeywords returns\n+    // immediately if U_FAILURE(status), so we add a check here.\n+    if (U_FAILURE(status)) {\n+        return NULL;\n     }\n     setAttributesFromKeywords(desiredLocale, *coll, status);\n     if (U_FAILURE(status)) {\n@@ -986,8 +993,8 @@ Collator::internalCompareUTF8(const char *left, int32_t leftLength,\n         return UCOL_EQUAL;\n     }\n     return compareUTF8(\n-            StringPiece(left, (leftLength < 0) ? uprv_strlen(left) : leftLength),\n-            StringPiece(right, (rightLength < 0) ? uprv_strlen(right) : rightLength),\n+            StringPiece(left, (leftLength < 0) ? static_cast<int32_t>(uprv_strlen(left)) : leftLength),\n+            StringPiece(right, (rightLength < 0) ? static_cast<int32_t>(uprv_strlen(right)) : rightLength),\n             errorCode);\n }\n "
        },
        {
            "sha": "b5c322fb44679b5790f10176555ea628eec5e764",
            "filename": "deps/icu-small/source/i18n/collationkeys.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcollationkeys.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcollationkeys.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fcollationkeys.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -403,13 +403,13 @@ CollationKeys::writeSortKeyUpToQuaternary(CollationIterator &iter,\n                     uint8_t *secs = secondaries.data();\n                     int32_t last = secondaries.length() - 1;\n                     if(secSegmentStart < last) {\n-                        uint8_t *p = secs + secSegmentStart;\n-                        uint8_t *q = secs + last;\n+                        uint8_t *q = secs + secSegmentStart;\n+                        uint8_t *r = secs + last;\n                         do {\n-                            uint8_t b = *p;\n-                            *p++ = *q;\n-                            *q-- = b;\n-                        } while(p < q);\n+                            uint8_t b = *q;\n+                            *q++ = *r;\n+                            *r-- = b;\n+                        } while(q < r);\n                     }\n                     secondaries.appendByte(p == Collation::NO_CE_PRIMARY ?\n                         Collation::LEVEL_SEPARATOR_BYTE : Collation::MERGE_SEPARATOR_BYTE);"
        },
        {
            "sha": "46d626bb3f4ffe4b149cd34c86127fa49f2b68a3",
            "filename": "deps/icu-small/source/i18n/csrmbcs.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcsrmbcs.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcsrmbcs.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fcsrmbcs.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -166,7 +166,7 @@ int32_t CharsetRecog_mbcs::match_mbcs(InputText *det, const uint16_t commonChars\n                 doubleByteCharCount++;\n \n                 if (commonChars != 0) {\n-                    if (binarySearch(commonChars, commonCharsLen, iter.charValue) >= 0){\n+                    if (binarySearch(commonChars, commonCharsLen, static_cast<uint16_t>(iter.charValue)) >= 0){\n                         commonCharCount += 1;\n                     }\n                 }"
        },
        {
            "sha": "f5d27e28d8ebfa2a0bbf38bc7cddd5239eda6a2f",
            "filename": "deps/icu-small/source/i18n/currpinf.cpp",
            "status": "modified",
            "additions": 157,
            "deletions": 121,
            "changes": 278,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcurrpinf.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcurrpinf.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fcurrpinf.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -17,7 +17,6 @@\n #include <iostream>\n #endif\n \n-\n #include \"unicode/locid.h\"\n #include \"unicode/plurrule.h\"\n #include \"unicode/strenum.h\"\n@@ -30,7 +29,6 @@\n \n U_NAMESPACE_BEGIN\n \n-\n static const UChar gNumberPatternSeparator = 0x3B; // ;\n \n U_CDECL_BEGIN\n@@ -65,66 +63,86 @@ static const char gDecimalFormatTag[]=\"decimalFormat\";\n static const char gCurrUnitPtnTag[]=\"CurrencyUnitPatterns\";\n \n CurrencyPluralInfo::CurrencyPluralInfo(UErrorCode& status)\n-:   fPluralCountToCurrencyUnitPattern(NULL),\n-    fPluralRules(NULL),\n-    fLocale(NULL) {\n+:   fPluralCountToCurrencyUnitPattern(nullptr),\n+    fPluralRules(nullptr),\n+    fLocale(nullptr),\n+    fInternalStatus(U_ZERO_ERROR) {\n     initialize(Locale::getDefault(), status);\n }\n \n CurrencyPluralInfo::CurrencyPluralInfo(const Locale& locale, UErrorCode& status)\n-:   fPluralCountToCurrencyUnitPattern(NULL),\n-    fPluralRules(NULL),\n-    fLocale(NULL) {\n+:   fPluralCountToCurrencyUnitPattern(nullptr),\n+    fPluralRules(nullptr),\n+    fLocale(nullptr),\n+    fInternalStatus(U_ZERO_ERROR) {\n     initialize(locale, status);\n }\n \n CurrencyPluralInfo::CurrencyPluralInfo(const CurrencyPluralInfo& info)\n :   UObject(info),\n-    fPluralCountToCurrencyUnitPattern(NULL),\n-    fPluralRules(NULL),\n-    fLocale(NULL) {\n+    fPluralCountToCurrencyUnitPattern(nullptr),\n+    fPluralRules(nullptr),\n+    fLocale(nullptr),\n+    fInternalStatus(U_ZERO_ERROR) {\n     *this = info;\n }\n \n-\n CurrencyPluralInfo&\n CurrencyPluralInfo::operator=(const CurrencyPluralInfo& info) {\n     if (this == &info) {\n         return *this;\n     }\n \n+    fInternalStatus = info.fInternalStatus;\n+    if (U_FAILURE(fInternalStatus)) {\n+        // bail out early if the object we were copying from was already 'invalid'.\n+        return *this;\n+    }\n+\n     deleteHash(fPluralCountToCurrencyUnitPattern);\n-    UErrorCode status = U_ZERO_ERROR;\n-    fPluralCountToCurrencyUnitPattern = initHash(status);\n+    fPluralCountToCurrencyUnitPattern = initHash(fInternalStatus);\n     copyHash(info.fPluralCountToCurrencyUnitPattern,\n-             fPluralCountToCurrencyUnitPattern, status);\n-    if ( U_FAILURE(status) ) {\n+             fPluralCountToCurrencyUnitPattern, fInternalStatus);\n+    if ( U_FAILURE(fInternalStatus) ) {\n         return *this;\n     }\n \n     delete fPluralRules;\n+    fPluralRules = nullptr;\n     delete fLocale;\n-    if (info.fPluralRules) {\n+    fLocale = nullptr;\n+\n+    if (info.fPluralRules != nullptr) {\n         fPluralRules = info.fPluralRules->clone();\n-    } else {\n-        fPluralRules = NULL;\n+        if (fPluralRules == nullptr) {\n+            fInternalStatus = U_MEMORY_ALLOCATION_ERROR;\n+            return *this;\n+        }\n     }\n-    if (info.fLocale) {\n+    if (info.fLocale != nullptr) {\n         fLocale = info.fLocale->clone();\n-    } else {\n-        fLocale = NULL;\n+        if (fLocale == nullptr) {\n+            // Note: If clone had an error parameter, then we could check/set that instead.\n+            fInternalStatus = U_MEMORY_ALLOCATION_ERROR;\n+            return *this;\n+        }\n+        // If the other locale wasn't bogus, but our clone'd locale is bogus, then OOM happened\n+        // during the call to clone().\n+        if (!info.fLocale->isBogus() && fLocale->isBogus()) {\n+            fInternalStatus = U_MEMORY_ALLOCATION_ERROR;\n+            return *this;\n+        }\n     }\n     return *this;\n }\n \n-\n CurrencyPluralInfo::~CurrencyPluralInfo() {\n     deleteHash(fPluralCountToCurrencyUnitPattern);\n-    fPluralCountToCurrencyUnitPattern = NULL;\n+    fPluralCountToCurrencyUnitPattern = nullptr;\n     delete fPluralRules;\n     delete fLocale;\n-    fPluralRules = NULL;\n-    fLocale = NULL;\n+    fPluralRules = nullptr;\n+    fLocale = nullptr;\n }\n \n UBool\n@@ -148,7 +166,14 @@ CurrencyPluralInfo::operator==(const CurrencyPluralInfo& info) const {\n \n CurrencyPluralInfo*\n CurrencyPluralInfo::clone() const {\n-    return new CurrencyPluralInfo(*this);\n+    CurrencyPluralInfo* newObj = new CurrencyPluralInfo(*this);\n+    // Since clone doesn't have a 'status' parameter, the best we can do is return nullptr\n+    // if the new object was not full constructed properly (an error occurred).\n+    if (newObj != nullptr && U_FAILURE(newObj->fInternalStatus)) {\n+        delete newObj;\n+        newObj = nullptr;\n+    }\n+    return newObj;\n }\n \n const PluralRules*\n@@ -161,15 +186,15 @@ CurrencyPluralInfo::getCurrencyPluralPattern(const UnicodeString&  pluralCount,\n                                              UnicodeString& result) const {\n     const UnicodeString* currencyPluralPattern =\n         (UnicodeString*)fPluralCountToCurrencyUnitPattern->get(pluralCount);\n-    if (currencyPluralPattern == NULL) {\n+    if (currencyPluralPattern == nullptr) {\n         // fall back to \"other\"\n         if (pluralCount.compare(gPluralCountOther, 5)) {\n             currencyPluralPattern =\n                 (UnicodeString*)fPluralCountToCurrencyUnitPattern->get(UnicodeString(TRUE, gPluralCountOther, 5));\n         }\n-        if (currencyPluralPattern == NULL) {\n+        if (currencyPluralPattern == nullptr) {\n             // no currencyUnitPatterns defined,\n-            // fallback to predefined defult.\n+            // fallback to predefined default.\n             // This should never happen when ICU resource files are\n             // available, since currencyUnitPattern of \"other\" is always\n             // defined in root.\n@@ -190,14 +215,11 @@ void\n CurrencyPluralInfo::setPluralRules(const UnicodeString& ruleDescription,\n                                    UErrorCode& status) {\n     if (U_SUCCESS(status)) {\n-        if (fPluralRules) {\n-            delete fPluralRules;\n-        }\n+        delete fPluralRules;\n         fPluralRules = PluralRules::createRules(ruleDescription, status);\n     }\n }\n \n-\n void\n CurrencyPluralInfo::setCurrencyPluralPattern(const UnicodeString& pluralCount,\n                                              const UnicodeString& pattern,\n@@ -206,63 +228,77 @@ CurrencyPluralInfo::setCurrencyPluralPattern(const UnicodeString& pluralCount,\n         UnicodeString* oldValue = static_cast<UnicodeString*>(\n             fPluralCountToCurrencyUnitPattern->get(pluralCount));\n         delete oldValue;\n-        fPluralCountToCurrencyUnitPattern->put(pluralCount, new UnicodeString(pattern), status);\n+        LocalPointer<UnicodeString> p(new UnicodeString(pattern), status);\n+        if (U_SUCCESS(status)) {\n+            // the p object allocated above will be owned by fPluralCountToCurrencyUnitPattern\n+            // after the call to put(), even if the method returns failure.\n+            fPluralCountToCurrencyUnitPattern->put(pluralCount, p.orphan(), status);\n+        }\n     }\n }\n \n-\n void\n CurrencyPluralInfo::setLocale(const Locale& loc, UErrorCode& status) {\n     initialize(loc, status);\n }\n \n-\n void\n CurrencyPluralInfo::initialize(const Locale& loc, UErrorCode& status) {\n     if (U_FAILURE(status)) {\n         return;\n     }\n     delete fLocale;\n+    fLocale = nullptr;\n+    delete fPluralRules;\n+    fPluralRules = nullptr;\n+\n     fLocale = loc.clone();\n-    if (fPluralRules) {\n-        delete fPluralRules;\n+    if (fLocale == nullptr) {\n+        status = U_MEMORY_ALLOCATION_ERROR;\n+        return;\n+    }\n+    // If the locale passed in wasn't bogus, but our clone'd locale is bogus, then OOM happened\n+    // during the call to loc.clone().\n+    if (!loc.isBogus() && fLocale->isBogus()) {\n+        status = U_MEMORY_ALLOCATION_ERROR;\n+        return;\n     }\n     fPluralRules = PluralRules::forLocale(loc, status);\n     setupCurrencyPluralPattern(loc, status);\n }\n \n-\n void\n CurrencyPluralInfo::setupCurrencyPluralPattern(const Locale& loc, UErrorCode& status) {\n     if (U_FAILURE(status)) {\n         return;\n     }\n \n-    if (fPluralCountToCurrencyUnitPattern) {\n-        deleteHash(fPluralCountToCurrencyUnitPattern);\n-    }\n+    deleteHash(fPluralCountToCurrencyUnitPattern);\n     fPluralCountToCurrencyUnitPattern = initHash(status);\n     if (U_FAILURE(status)) {\n         return;\n     }\n \n-    NumberingSystem *ns = NumberingSystem::createInstance(loc,status);\n+    LocalPointer<NumberingSystem> ns(NumberingSystem::createInstance(loc, status), status);\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n     UErrorCode ec = U_ZERO_ERROR;\n-    UResourceBundle *rb = ures_open(NULL, loc.getName(), &ec);\n-    UResourceBundle *numElements = ures_getByKeyWithFallback(rb, gNumberElementsTag, NULL, &ec);\n-    rb = ures_getByKeyWithFallback(numElements, ns->getName(), rb, &ec);\n-    rb = ures_getByKeyWithFallback(rb, gPatternsTag, rb, &ec);\n+    LocalUResourceBundlePointer rb(ures_open(nullptr, loc.getName(), &ec));\n+    LocalUResourceBundlePointer numElements(ures_getByKeyWithFallback(rb.getAlias(), gNumberElementsTag, nullptr, &ec));\n+    ures_getByKeyWithFallback(numElements.getAlias(), ns->getName(), rb.getAlias(), &ec);\n+    ures_getByKeyWithFallback(rb.getAlias(), gPatternsTag, rb.getAlias(), &ec);\n     int32_t ptnLen;\n-    const UChar* numberStylePattern = ures_getStringByKeyWithFallback(rb, gDecimalFormatTag, &ptnLen, &ec);\n+    const UChar* numberStylePattern = ures_getStringByKeyWithFallback(rb.getAlias(), gDecimalFormatTag, &ptnLen, &ec);\n     // Fall back to \"latn\" if num sys specific pattern isn't there.\n-    if ( ec == U_MISSING_RESOURCE_ERROR && uprv_strcmp(ns->getName(),gLatnTag)) {\n+    if ( ec == U_MISSING_RESOURCE_ERROR && (uprv_strcmp(ns->getName(), gLatnTag) != 0)) {\n         ec = U_ZERO_ERROR;\n-        rb = ures_getByKeyWithFallback(numElements, gLatnTag, rb, &ec);\n-        rb = ures_getByKeyWithFallback(rb, gPatternsTag, rb, &ec);\n-        numberStylePattern = ures_getStringByKeyWithFallback(rb, gDecimalFormatTag, &ptnLen, &ec);\n+        ures_getByKeyWithFallback(numElements.getAlias(), gLatnTag, rb.getAlias(), &ec);\n+        ures_getByKeyWithFallback(rb.getAlias(), gPatternsTag, rb.getAlias(), &ec);\n+        numberStylePattern = ures_getStringByKeyWithFallback(rb.getAlias(), gDecimalFormatTag, &ptnLen, &ec);\n     }\n     int32_t numberStylePatternLen = ptnLen;\n-    const UChar* negNumberStylePattern = NULL;\n+    const UChar* negNumberStylePattern = nullptr;\n     int32_t negNumberStylePatternLen = 0;\n     // TODO: Java\n     // parse to check whether there is \";\" separator in the numberStylePattern\n@@ -279,127 +315,127 @@ CurrencyPluralInfo::setupCurrencyPluralPattern(const Locale& loc, UErrorCode& st\n         }\n     }\n \n-    ures_close(numElements);\n-    ures_close(rb);\n-    delete ns;\n-\n     if (U_FAILURE(ec)) {\n+        // If OOM occurred during the above code, then we want to report that back to the caller.\n+        if (ec == U_MEMORY_ALLOCATION_ERROR) {\n+            status = ec;\n+        }\n         return;\n     }\n \n-    UResourceBundle *currRb = ures_open(U_ICUDATA_CURR, loc.getName(), &ec);\n-    UResourceBundle *currencyRes = ures_getByKeyWithFallback(currRb, gCurrUnitPtnTag, NULL, &ec);\n+    LocalUResourceBundlePointer currRb(ures_open(U_ICUDATA_CURR, loc.getName(), &ec));\n+    LocalUResourceBundlePointer currencyRes(ures_getByKeyWithFallback(currRb.getAlias(), gCurrUnitPtnTag, nullptr, &ec));\n \n #ifdef CURRENCY_PLURAL_INFO_DEBUG\n     std::cout << \"in set up\\n\";\n #endif\n-    StringEnumeration* keywords = fPluralRules->getKeywords(ec);\n+    LocalPointer<StringEnumeration> keywords(fPluralRules->getKeywords(ec), ec);\n     if (U_SUCCESS(ec)) {\n         const char* pluralCount;\n-        while ((pluralCount = keywords->next(NULL, ec)) != NULL) {\n-            if ( U_SUCCESS(ec) ) {\n-                int32_t ptnLen;\n-                UErrorCode err = U_ZERO_ERROR;\n-                const UChar* patternChars = ures_getStringByKeyWithFallback(\n-                    currencyRes, pluralCount, &ptnLen, &err);\n-                if (U_SUCCESS(err) && ptnLen > 0) {\n-                    UnicodeString* pattern = new UnicodeString(patternChars, ptnLen);\n+        while (((pluralCount = keywords->next(nullptr, ec)) != nullptr) && U_SUCCESS(ec)) {\n+            int32_t ptnLength;\n+            UErrorCode err = U_ZERO_ERROR;\n+            const UChar* patternChars = ures_getStringByKeyWithFallback(currencyRes.getAlias(), pluralCount, &ptnLength, &err);\n+            if (err == U_MEMORY_ALLOCATION_ERROR || patternChars == nullptr) {\n+                ec = err;\n+                break;\n+            }\n+            if (U_SUCCESS(err) && ptnLength > 0) {\n+                UnicodeString* pattern = new UnicodeString(patternChars, ptnLength);\n+                if (pattern == nullptr) {\n+                    ec = U_MEMORY_ALLOCATION_ERROR;\n+                    break;\n+                }\n #ifdef CURRENCY_PLURAL_INFO_DEBUG\n-                    char result_1[1000];\n-                    pattern->extract(0, pattern->length(), result_1, \"UTF-8\");\n-                    std::cout << \"pluralCount: \" << pluralCount << \"; pattern: \" << result_1 << \"\\n\";\n+                char result_1[1000];\n+                pattern->extract(0, pattern->length(), result_1, \"UTF-8\");\n+                std::cout << \"pluralCount: \" << pluralCount << \"; pattern: \" << result_1 << \"\\n\";\n #endif\n-                    pattern->findAndReplace(UnicodeString(TRUE, gPart0, 3),\n-                      UnicodeString(numberStylePattern, numberStylePatternLen));\n-                    pattern->findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));\n-\n-                    if (hasSeparator) {\n-                        UnicodeString negPattern(patternChars, ptnLen);\n-                        negPattern.findAndReplace(UnicodeString(TRUE, gPart0, 3),\n-                          UnicodeString(negNumberStylePattern, negNumberStylePatternLen));\n-                        negPattern.findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));\n-                        pattern->append(gNumberPatternSeparator);\n-                        pattern->append(negPattern);\n-                    }\n+                pattern->findAndReplace(UnicodeString(TRUE, gPart0, 3),\n+                    UnicodeString(numberStylePattern, numberStylePatternLen));\n+                pattern->findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));\n+\n+                if (hasSeparator) {\n+                    UnicodeString negPattern(patternChars, ptnLength);\n+                    negPattern.findAndReplace(UnicodeString(TRUE, gPart0, 3),\n+                        UnicodeString(negNumberStylePattern, negNumberStylePatternLen));\n+                    negPattern.findAndReplace(UnicodeString(TRUE, gPart1, 3), UnicodeString(TRUE, gTripleCurrencySign, 3));\n+                    pattern->append(gNumberPatternSeparator);\n+                    pattern->append(negPattern);\n+                }\n #ifdef CURRENCY_PLURAL_INFO_DEBUG\n-                    pattern->extract(0, pattern->length(), result_1, \"UTF-8\");\n-                    std::cout << \"pluralCount: \" << pluralCount << \"; pattern: \" << result_1 << \"\\n\";\n+                pattern->extract(0, pattern->length(), result_1, \"UTF-8\");\n+                std::cout << \"pluralCount: \" << pluralCount << \"; pattern: \" << result_1 << \"\\n\";\n #endif\n-\n-                    fPluralCountToCurrencyUnitPattern->put(UnicodeString(pluralCount, -1, US_INV), pattern, status);\n-                }\n+                // the 'pattern' object allocated above will be owned by the fPluralCountToCurrencyUnitPattern after the call to\n+                // put(), even if the method returns failure.\n+                fPluralCountToCurrencyUnitPattern->put(UnicodeString(pluralCount, -1, US_INV), pattern, status);\n             }\n         }\n     }\n-    delete keywords;\n-    ures_close(currencyRes);\n-    ures_close(currRb);\n+    // If OOM occurred during the above code, then we want to report that back to the caller.\n+    if (ec == U_MEMORY_ALLOCATION_ERROR) {\n+        status = ec;\n+    }\n }\n \n-\n-\n void\n-CurrencyPluralInfo::deleteHash(Hashtable* hTable)\n-{\n-    if ( hTable == NULL ) {\n+CurrencyPluralInfo::deleteHash(Hashtable* hTable) {\n+    if ( hTable == nullptr ) {\n         return;\n     }\n     int32_t pos = UHASH_FIRST;\n-    const UHashElement* element = NULL;\n-    while ( (element = hTable->nextElement(pos)) != NULL ) {\n+    const UHashElement* element = nullptr;\n+    while ( (element = hTable->nextElement(pos)) != nullptr ) {\n         const UHashTok valueTok = element->value;\n         const UnicodeString* value = (UnicodeString*)valueTok.pointer;\n         delete value;\n     }\n     delete hTable;\n-    hTable = NULL;\n+    hTable = nullptr;\n }\n \n-\n Hashtable*\n CurrencyPluralInfo::initHash(UErrorCode& status) {\n-    if ( U_FAILURE(status) ) {\n-        return NULL;\n-    }\n-    Hashtable* hTable;\n-    if ( (hTable = new Hashtable(TRUE, status)) == NULL ) {\n-        status = U_MEMORY_ALLOCATION_ERROR;\n-        return NULL;\n+    if (U_FAILURE(status)) {\n+        return nullptr;\n     }\n-    if ( U_FAILURE(status) ) {\n-        delete hTable;\n-        return NULL;\n+    LocalPointer<Hashtable> hTable(new Hashtable(TRUE, status), status);\n+    if (U_FAILURE(status)) {\n+        return nullptr;\n     }\n     hTable->setValueComparator(ValueComparator);\n-    return hTable;\n+    return hTable.orphan();\n }\n \n-\n void\n CurrencyPluralInfo::copyHash(const Hashtable* source,\n                            Hashtable* target,\n                            UErrorCode& status) {\n-    if ( U_FAILURE(status) ) {\n+    if (U_FAILURE(status)) {\n         return;\n     }\n     int32_t pos = UHASH_FIRST;\n-    const UHashElement* element = NULL;\n-    if ( source ) {\n-        while ( (element = source->nextElement(pos)) != NULL ) {\n+    const UHashElement* element = nullptr;\n+    if (source) {\n+        while ( (element = source->nextElement(pos)) != nullptr ) {\n             const UHashTok keyTok = element->key;\n             const UnicodeString* key = (UnicodeString*)keyTok.pointer;\n             const UHashTok valueTok = element->value;\n             const UnicodeString* value = (UnicodeString*)valueTok.pointer;\n-            UnicodeString* copy = new UnicodeString(*value);\n-            target->put(UnicodeString(*key), copy, status);\n-            if ( U_FAILURE(status) ) {\n+            LocalPointer<UnicodeString> copy(new UnicodeString(*value), status);\n+            if (U_FAILURE(status)) {\n+                return;\n+            }\n+            // The HashTable owns the 'copy' object after the call to put().\n+            target->put(UnicodeString(*key), copy.orphan(), status);\n+            if (U_FAILURE(status)) {\n                 return;\n             }\n         }\n     }\n }\n \n-\n U_NAMESPACE_END\n \n #endif"
        },
        {
            "sha": "2ece508751bcec7692a8eb069693b0a26b4fe515",
            "filename": "deps/icu-small/source/i18n/currunit.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcurrunit.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fcurrunit.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fcurrunit.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -27,9 +27,14 @@ CurrencyUnit::CurrencyUnit(ConstChar16Ptr _isoCode, UErrorCode& ec) {\n     // The constructor always leaves the CurrencyUnit in a valid state (with a 3-character currency code).\n     // Note: in ICU4J Currency.getInstance(), we check string length for 3, but in ICU4C we allow a\n     // non-NUL-terminated string to be passed as an argument, so it is not possible to check length.\n+    // However, we allow a NUL-terminated empty string, which should have the same behavior as nullptr.\n+    // Consider NUL-terminated strings of length 1 or 2 as invalid.\n     const char16_t* isoCodeToUse;\n-    if (U_FAILURE(ec) || _isoCode == nullptr) {\n+    if (U_FAILURE(ec) || _isoCode == nullptr || _isoCode[0] == 0) {\n         isoCodeToUse = kDefaultCurrency;\n+    } else if (_isoCode[1] == 0 || _isoCode[2] == 0) {\n+        isoCodeToUse = kDefaultCurrency;\n+        ec = U_ILLEGAL_ARGUMENT_ERROR;\n     } else if (!uprv_isInvariantUString(_isoCode, 3)) {\n         // TODO: Perform a more strict ASCII check like in ICU4J isAlpha3Code?\n         isoCodeToUse = kDefaultCurrency;"
        },
        {
            "sha": "04113785f27308be1c28717bd28ee7a2c9bec80d",
            "filename": "deps/icu-small/source/i18n/dcfmtsym.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdcfmtsym.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdcfmtsym.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdcfmtsym.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -436,7 +436,7 @@ DecimalFormatSymbols::initialize(const Locale& loc, UErrorCode& status,\n     sink.resolveMissingMonetarySeparators(fSymbols);\n \n     // Resolve codePointZero\n-    UChar32 tempCodePointZero;\n+    UChar32 tempCodePointZero = -1;\n     for (int32_t i=0; i<=9; i++) {\n         const UnicodeString& stringDigit = getConstDigitSymbol(i);\n         if (stringDigit.countChar32() != 1) {"
        },
        {
            "sha": "edd8910d9d4fd69079a5fc725bb5b64866f993b7",
            "filename": "deps/icu-small/source/i18n/decimfmt.cpp",
            "status": "modified",
            "additions": 24,
            "deletions": 8,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdecimfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdecimfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdecimfmt.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1057,12 +1057,19 @@ UBool DecimalFormat::areSignificantDigitsUsed() const {\n \n void DecimalFormat::setSignificantDigitsUsed(UBool useSignificantDigits) {\n     // These are the default values from the old implementation.\n+    if (useSignificantDigits) {\n+        if (fields->properties->minimumSignificantDigits != -1 ||\n+            fields->properties->maximumSignificantDigits != -1) {\n+            return;\n+        }\n+    } else {\n+        if (fields->properties->minimumSignificantDigits == -1 &&\n+            fields->properties->maximumSignificantDigits == -1) {\n+            return;\n+        }\n+    }\n     int32_t minSig = useSignificantDigits ? 1 : -1;\n     int32_t maxSig = useSignificantDigits ? 6 : -1;\n-    if (fields->properties->minimumSignificantDigits == minSig &&\n-        fields->properties->maximumSignificantDigits == maxSig) {\n-        return;\n-    }\n     fields->properties->minimumSignificantDigits = minSig;\n     fields->properties->maximumSignificantDigits = maxSig;\n     touchNoError();\n@@ -1175,7 +1182,12 @@ void DecimalFormat::setPropertiesFromPattern(const UnicodeString& pattern, int32\n }\n \n const numparse::impl::NumberParserImpl* DecimalFormat::getParser(UErrorCode& status) const {\n-    if (U_FAILURE(status)) { return nullptr; }\n+    // TODO: Move this into umutex.h? (similar logic also in numrange_fluent.cpp)\n+    // See ICU-20146\n+\n+    if (U_FAILURE(status)) {\n+        return nullptr;\n+    }\n \n     // First try to get the pre-computed parser\n     auto* ptr = fields->atomicParser.load();\n@@ -1185,13 +1197,17 @@ const numparse::impl::NumberParserImpl* DecimalFormat::getParser(UErrorCode& sta\n \n     // Try computing the parser on our own\n     auto* temp = NumberParserImpl::createParserFromProperties(*fields->properties, *fields->symbols, false, status);\n+    if (U_FAILURE(status)) {\n+        return nullptr;\n+    }\n     if (temp == nullptr) {\n         status = U_MEMORY_ALLOCATION_ERROR;\n-        // although we may still dereference, call sites should be guarded\n+        return nullptr;\n     }\n \n-    // Note: ptr starts as nullptr; during compare_exchange, it is set to what is actually stored in the\n-    // atomic if another thread beat us to computing the parser object.\n+    // Note: ptr starts as nullptr; during compare_exchange,\n+    // it is set to what is actually stored in the atomic\n+    // if another thread beat us to computing the parser object.\n     auto* nonConstThis = const_cast<DecimalFormat*>(this);\n     if (!nonConstThis->fields->atomicParser.compare_exchange_strong(ptr, temp)) {\n         // Another thread beat us to computing the parser"
        },
        {
            "sha": "c9dfa045831d602e73a78380229bb5db2c2c557f",
            "filename": "deps/icu-small/source/i18n/dtfmtsym.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtfmtsym.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtfmtsym.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtfmtsym.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1311,7 +1311,7 @@ DateFormatSymbols::initZoneStringsArray(void) {\n         UDate now = Calendar::getNow();\n         UnicodeString tzDispName;\n \n-        while ((tzid = tzids->snext(status))) {\n+        while ((tzid = tzids->snext(status)) != 0) {\n             if (U_FAILURE(status)) {\n                 break;\n             }\n@@ -2224,8 +2224,8 @@ DateFormatSymbols::initializeData(const Locale& locale, const char *type, UError\n                             ++typeMapPtr;\n                         }\n                         if (typeMapPtr->usageTypeName != NULL && compResult == 0) {\n-                            fCapitalization[typeMapPtr->usageTypeEnumValue][0] = intVector[0];\n-                            fCapitalization[typeMapPtr->usageTypeEnumValue][1] = intVector[1];\n+                            fCapitalization[typeMapPtr->usageTypeEnumValue][0] = static_cast<UBool>(intVector[0]);\n+                            fCapitalization[typeMapPtr->usageTypeEnumValue][1] = static_cast<UBool>(intVector[1]);\n                         }\n                     }\n                 }"
        },
        {
            "sha": "d952cbf509dc406b60f969b4710ebb38239990a1",
            "filename": "deps/icu-small/source/i18n/dtitvfmt.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtitvfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtitvfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtitvfmt.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -877,8 +877,7 @@ DateIntervalFormat::getDateTimeSkeleton(const UnicodeString& skeleton,\n         if ( MCount < 3 ) {\n             normalizedDateSkeleton.append(CAP_M);\n         } else {\n-            int32_t i;\n-            for ( i = 0; i < MCount && i < MAX_M_COUNT; ++i ) {\n+            for ( int32_t j = 0; j < MCount && j < MAX_M_COUNT; ++j) {\n                  normalizedDateSkeleton.append(CAP_M);\n             }\n         }\n@@ -887,8 +886,7 @@ DateIntervalFormat::getDateTimeSkeleton(const UnicodeString& skeleton,\n         if ( ECount <= 3 ) {\n             normalizedDateSkeleton.append(CAP_E);\n         } else {\n-            int32_t i;\n-            for ( i = 0; i < ECount && i < MAX_E_COUNT; ++i ) {\n+            for ( int32_t j = 0; j < ECount && j < MAX_E_COUNT; ++j ) {\n                  normalizedDateSkeleton.append(CAP_E);\n             }\n         }"
        },
        {
            "sha": "a289fc79c8da0e628ec752cbfb1a339d6c9fd418",
            "filename": "deps/icu-small/source/i18n/dtitvinf.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtitvinf.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtitvinf.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtitvinf.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -594,7 +594,7 @@ DateIntervalInfo::getBestSkeleton(const UnicodeString& skeleton,\n     const UHashElement* elem = NULL;\n     while ( (elem = fIntervalPatterns->nextElement(pos)) != NULL ) {\n         const UHashTok keyTok = elem->key;\n-        UnicodeString* skeleton = (UnicodeString*)keyTok.pointer;\n+        UnicodeString* newSkeleton = (UnicodeString*)keyTok.pointer;\n #ifdef DTITVINF_DEBUG\n     skeleton->extract(0,  skeleton->length(), result, \"UTF-8\");\n     sprintf(mesg, \"available skeletons: skeleton: %s; \\n\", result);\n@@ -606,7 +606,7 @@ DateIntervalInfo::getBestSkeleton(const UnicodeString& skeleton,\n         for ( i = 0; i < fieldLength; ++i ) {\n             skeletonFieldWidth[i] = 0;\n         }\n-        parseSkeleton(*skeleton, skeletonFieldWidth);\n+        parseSkeleton(*newSkeleton, skeletonFieldWidth);\n         // calculate distance\n         int32_t distance = 0;\n         int8_t fieldDifference = 1;\n@@ -632,7 +632,7 @@ DateIntervalInfo::getBestSkeleton(const UnicodeString& skeleton,\n             }\n         }\n         if ( distance < bestDistance ) {\n-            bestSkeleton = skeleton;\n+            bestSkeleton = newSkeleton;\n             bestDistance = distance;\n             bestMatchDistanceInfo = fieldDifference;\n         }"
        },
        {
            "sha": "b44daf37bf5802c271d78b5bda698f86b8172014",
            "filename": "deps/icu-small/source/i18n/dtptngen.cpp",
            "status": "modified",
            "additions": 399,
            "deletions": 291,
            "changes": 690,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtptngen.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtptngen.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtptngen.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -18,6 +18,7 @@\n #include \"unicode/decimfmt.h\"\n #include \"unicode/dtfmtsym.h\"\n #include \"unicode/dtptngen.h\"\n+#include \"unicode/localpointer.h\"\n #include \"unicode/simpleformatter.h\"\n #include \"unicode/smpdtfmt.h\"\n #include \"unicode/udat.h\"\n@@ -88,17 +89,17 @@ static void ures_a_open(UResourceBundleAIterator *aiter, UResourceBundle *bund,\n     aiter->num = ures_getSize(aiter->bund);\n     aiter->cursor = 0;\n #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)\n-    aiter->entries = NULL;\n+    aiter->entries = nullptr;\n #else\n     aiter->entries = (UResAEntry*)uprv_malloc(sizeof(UResAEntry)*aiter->num);\n     for(int i=0;i<aiter->num;i++) {\n-        aiter->entries[i].item = ures_getByIndex(aiter->bund, i, NULL, status);\n+        aiter->entries[i].item = ures_getByIndex(aiter->bund, i, nullptr, status);\n         const char *akey = ures_getKey(aiter->entries[i].item);\n         int32_t len = uprv_strlen(akey)+1;\n         aiter->entries[i].key = (UChar*)uprv_malloc(len*sizeof(UChar));\n         u_charsToUChars(akey, aiter->entries[i].key, len);\n     }\n-    uprv_sortArray(aiter->entries, aiter->num, sizeof(UResAEntry), ures_a_codepointSort, NULL, TRUE, status);\n+    uprv_sortArray(aiter->entries, aiter->num, sizeof(UResAEntry), ures_a_codepointSort, nullptr, TRUE, status);\n #endif\n }\n \n@@ -115,7 +116,7 @@ static const UChar *ures_a_getNextString(UResourceBundleAIterator *aiter, int32_\n #if !defined(U_SORT_ASCII_BUNDLE_ITERATOR)\n     return ures_getNextString(aiter->bund, len, key, err);\n #else\n-    if(U_FAILURE(*err)) return NULL;\n+    if(U_FAILURE(*err)) return nullptr;\n     UResourceBundle *item = aiter->entries[aiter->cursor].item;\n     const UChar* ret = ures_getString(item, len, err);\n     *key = ures_getKey(item);\n@@ -302,49 +303,48 @@ DateTimePatternGenerator::createInstance(UErrorCode& status) {\n DateTimePatternGenerator* U_EXPORT2\n DateTimePatternGenerator::createInstance(const Locale& locale, UErrorCode& status) {\n     if (U_FAILURE(status)) {\n-        return NULL;\n+        return nullptr;\n     }\n     LocalPointer<DateTimePatternGenerator> result(\n             new DateTimePatternGenerator(locale, status), status);\n-    return U_SUCCESS(status) ? result.orphan() : NULL;\n+    return U_SUCCESS(status) ? result.orphan() : nullptr;\n }\n \n DateTimePatternGenerator*  U_EXPORT2\n DateTimePatternGenerator::createEmptyInstance(UErrorCode& status) {\n-    DateTimePatternGenerator *result = new DateTimePatternGenerator(status);\n-    if (result == NULL) {\n-        status = U_MEMORY_ALLOCATION_ERROR;\n-    }\n     if (U_FAILURE(status)) {\n-        delete result;\n-        result = NULL;\n+        return nullptr;\n     }\n-    return result;\n+    LocalPointer<DateTimePatternGenerator> result(\n+            new DateTimePatternGenerator(status), status);\n+    return U_SUCCESS(status) ? result.orphan() : nullptr;\n }\n \n DateTimePatternGenerator::DateTimePatternGenerator(UErrorCode &status) :\n-    skipMatcher(NULL),\n-    fAvailableFormatKeyHash(NULL)\n+    skipMatcher(nullptr),\n+    fAvailableFormatKeyHash(nullptr),\n+    internalErrorCode(U_ZERO_ERROR)\n {\n     fp = new FormatParser();\n     dtMatcher = new DateTimeMatcher();\n     distanceInfo = new DistanceInfo();\n     patternMap = new PatternMap();\n-    if (fp == NULL || dtMatcher == NULL || distanceInfo == NULL || patternMap == NULL) {\n-        status = U_MEMORY_ALLOCATION_ERROR;\n+    if (fp == nullptr || dtMatcher == nullptr || distanceInfo == nullptr || patternMap == nullptr) {\n+        internalErrorCode = status = U_MEMORY_ALLOCATION_ERROR;\n     }\n }\n \n DateTimePatternGenerator::DateTimePatternGenerator(const Locale& locale, UErrorCode &status) :\n-    skipMatcher(NULL),\n-    fAvailableFormatKeyHash(NULL)\n+    skipMatcher(nullptr),\n+    fAvailableFormatKeyHash(nullptr),\n+    internalErrorCode(U_ZERO_ERROR)\n {\n     fp = new FormatParser();\n     dtMatcher = new DateTimeMatcher();\n     distanceInfo = new DistanceInfo();\n     patternMap = new PatternMap();\n-    if (fp == NULL || dtMatcher == NULL || distanceInfo == NULL || patternMap == NULL) {\n-        status = U_MEMORY_ALLOCATION_ERROR;\n+    if (fp == nullptr || dtMatcher == nullptr || distanceInfo == nullptr || patternMap == nullptr) {\n+        internalErrorCode = status = U_MEMORY_ALLOCATION_ERROR;\n     }\n     else {\n         initData(locale, status);\n@@ -353,13 +353,17 @@ DateTimePatternGenerator::DateTimePatternGenerator(const Locale& locale, UErrorC\n \n DateTimePatternGenerator::DateTimePatternGenerator(const DateTimePatternGenerator& other) :\n     UObject(),\n-    skipMatcher(NULL),\n-    fAvailableFormatKeyHash(NULL)\n+    skipMatcher(nullptr),\n+    fAvailableFormatKeyHash(nullptr),\n+    internalErrorCode(U_ZERO_ERROR)\n {\n     fp = new FormatParser();\n     dtMatcher = new DateTimeMatcher();\n     distanceInfo = new DistanceInfo();\n     patternMap = new PatternMap();\n+    if (fp == nullptr || dtMatcher == nullptr || distanceInfo == nullptr || patternMap == nullptr) {\n+        internalErrorCode = U_MEMORY_ALLOCATION_ERROR;\n+    }\n     *this=other;\n }\n \n@@ -369,6 +373,7 @@ DateTimePatternGenerator::operator=(const DateTimePatternGenerator& other) {\n     if (&other == this) {\n         return *this;\n     }\n+    internalErrorCode = other.internalErrorCode;\n     pLocale = other.pLocale;\n     fDefaultHourFormatChar = other.fDefaultHourFormatChar;\n     *fp = *(other.fp);\n@@ -380,11 +385,16 @@ DateTimePatternGenerator::operator=(const DateTimePatternGenerator& other) {\n     dateTimeFormat.getTerminatedBuffer();\n     decimal.getTerminatedBuffer();\n     delete skipMatcher;\n-    if ( other.skipMatcher == NULL ) {\n-        skipMatcher = NULL;\n+    if ( other.skipMatcher == nullptr ) {\n+        skipMatcher = nullptr;\n     }\n     else {\n         skipMatcher = new DateTimeMatcher(*other.skipMatcher);\n+        if (skipMatcher == nullptr)\n+        {\n+            internalErrorCode = U_MEMORY_ALLOCATION_ERROR;\n+            return *this;\n+        }\n     }\n     for (int32_t i=0; i< UDATPG_FIELD_COUNT; ++i ) {\n         appendItemFormats[i] = other.appendItemFormats[i];\n@@ -394,9 +404,8 @@ DateTimePatternGenerator::operator=(const DateTimePatternGenerator& other) {\n             fieldDisplayNames[i][j].getTerminatedBuffer(); // NUL-terminate for the C API.\n         }\n     }\n-    UErrorCode status = U_ZERO_ERROR;\n-    patternMap->copyFrom(*other.patternMap, status);\n-    copyHashtable(other.fAvailableFormatKeyHash, status);\n+    patternMap->copyFrom(*other.patternMap, internalErrorCode);\n+    copyHashtable(other.fAvailableFormatKeyHash, internalErrorCode);\n     return *this;\n }\n \n@@ -431,21 +440,21 @@ DateTimePatternGenerator::operator!=(const DateTimePatternGenerator& other) cons\n }\n \n DateTimePatternGenerator::~DateTimePatternGenerator() {\n-    if (fAvailableFormatKeyHash!=NULL) {\n+    if (fAvailableFormatKeyHash!=nullptr) {\n         delete fAvailableFormatKeyHash;\n     }\n \n-    if (fp != NULL) delete fp;\n-    if (dtMatcher != NULL) delete dtMatcher;\n-    if (distanceInfo != NULL) delete distanceInfo;\n-    if (patternMap != NULL) delete patternMap;\n-    if (skipMatcher != NULL) delete skipMatcher;\n+    if (fp != nullptr) delete fp;\n+    if (dtMatcher != nullptr) delete dtMatcher;\n+    if (distanceInfo != nullptr) delete distanceInfo;\n+    if (patternMap != nullptr) delete patternMap;\n+    if (skipMatcher != nullptr) delete skipMatcher;\n }\n \n namespace {\n \n UInitOnce initOnce = U_INITONCE_INITIALIZER;\n-UHashtable *localeToAllowedHourFormatsMap = NULL;\n+UHashtable *localeToAllowedHourFormatsMap = nullptr;\n \n // Value deleter for hashmap.\n U_CFUNC void U_CALLCONV deleteAllowedHourFormats(void *ptr) {\n@@ -474,15 +483,17 @@ void\n DateTimePatternGenerator::initData(const Locale& locale, UErrorCode &status) {\n     //const char *baseLangName = locale.getBaseName(); // unused\n \n-    skipMatcher = NULL;\n-    fAvailableFormatKeyHash=NULL;\n+    skipMatcher = nullptr;\n+    fAvailableFormatKeyHash=nullptr;\n     addCanonicalItems(status);\n     addICUPatterns(locale, status);\n     addCLDRData(locale, status);\n     setDateTimeFromCalendar(locale, status);\n     setDecimalSymbols(locale, status);\n     umtx_initOnce(initOnce, loadAllowedHourFormatsData, status);\n     getAllowedHourFormats(locale, status);\n+    // If any of the above methods failed then the object is in an invalid state.\n+    internalErrorCode = status;\n } // DateTimePatternGenerator::initData\n \n namespace {\n@@ -505,7 +516,7 @@ struct AllowedHourFormatsSink : public ResourceSink {\n                     LocalMemory<int32_t> list;\n                     int32_t length;\n                     if (value.getType() == URES_STRING) {\n-                        if (list.allocateInsteadAndReset(2) == NULL) {\n+                        if (list.allocateInsteadAndReset(2) == nullptr) {\n                             errorCode = U_MEMORY_ALLOCATION_ERROR;\n                             return;\n                         }\n@@ -515,7 +526,7 @@ struct AllowedHourFormatsSink : public ResourceSink {\n                     else {\n                         ResourceArray allowedFormats = value.getArray(errorCode);\n                         length = allowedFormats.getSize();\n-                        if (list.allocateInsteadAndReset(length + 1) == NULL) {\n+                        if (list.allocateInsteadAndReset(length + 1) == nullptr) {\n                             errorCode = U_MEMORY_ALLOCATION_ERROR;\n                             return;\n                         }\n@@ -555,9 +566,14 @@ AllowedHourFormatsSink::~AllowedHourFormatsSink() {}\n U_CFUNC void U_CALLCONV DateTimePatternGenerator::loadAllowedHourFormatsData(UErrorCode &status) {\n     if (U_FAILURE(status)) { return; }\n     localeToAllowedHourFormatsMap = uhash_open(\n-        uhash_hashChars, uhash_compareChars, NULL, &status);\n+        uhash_hashChars, uhash_compareChars, nullptr, &status);\n+    if (U_FAILURE(status)) { return; }\n+\n     uhash_setValueDeleter(localeToAllowedHourFormatsMap, deleteAllowedHourFormats);\n-    LocalUResourceBundlePointer rb(ures_openDirect(NULL, \"supplementalData\", &status));\n+    ucln_i18n_registerCleanup(UCLN_I18N_ALLOWED_HOUR_FORMATS, allowedHourFormatsCleanup);\n+\n+    LocalUResourceBundlePointer rb(ures_openDirect(nullptr, \"supplementalData\", &status));\n+    if (U_FAILURE(status)) { return; }\n \n     AllowedHourFormatsSink sink;\n     // TODO: Currently in the enumeration each table allocates a new array.\n@@ -567,8 +583,6 @@ U_CFUNC void U_CALLCONV DateTimePatternGenerator::loadAllowedHourFormatsData(UEr\n     // vector (at index enum*2) for easy data sharing, copy sub-arrays into runtime\n     // object. Remember to clean up the vector, too.\n     ures_getAllItemsWithFallback(rb.getAlias(), \"timeData\", sink, status);\n-\n-    ucln_i18n_registerCleanup(UCLN_I18N_ALLOWED_HOUR_FORMATS, allowedHourFormatsCleanup);\n }\n \n void DateTimePatternGenerator::getAllowedHourFormats(const Locale &locale, UErrorCode &status) {\n@@ -589,17 +603,17 @@ void DateTimePatternGenerator::getAllowedHourFormats(const Locale &locale, UErro\n     const char *language = maxLocale.getLanguage();\n \n     CharString langCountry;\n-    langCountry.append(language, uprv_strlen(language), status);\n+    langCountry.append(language, static_cast<int32_t>(uprv_strlen(language)), status);\n     langCountry.append('_', status);\n-    langCountry.append(country, uprv_strlen(country), status);\n+    langCountry.append(country, static_cast<int32_t>(uprv_strlen(country)), status);\n \n     int32_t *allowedFormats;\n     allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, langCountry.data());\n-    if (allowedFormats == NULL) {\n+    if (allowedFormats == nullptr) {\n         allowedFormats = (int32_t *)uhash_get(localeToAllowedHourFormatsMap, const_cast<char *>(country));\n     }\n \n-    if (allowedFormats != NULL) {  // Lookup is successful\n+    if (allowedFormats != nullptr) {  // Lookup is successful\n         for (int32_t i = 0; i < UPRV_LENGTHOF(fAllowedHourFormats); ++i) {\n             fAllowedHourFormats[i] = allowedFormats[i];\n             if (allowedFormats[i] == ALLOWED_HOUR_FORMAT_UNKNOWN) {\n@@ -615,10 +629,10 @@ void DateTimePatternGenerator::getAllowedHourFormats(const Locale &locale, UErro\n UnicodeString\n DateTimePatternGenerator::getSkeleton(const UnicodeString& pattern, UErrorCode&\n /*status*/) {\n-    FormatParser fp;\n+    FormatParser fp2;\n     DateTimeMatcher matcher;\n     PtnSkeleton localSkeleton;\n-    matcher.set(pattern, &fp, localSkeleton);\n+    matcher.set(pattern, &fp2, localSkeleton);\n     return localSkeleton.getSkeleton();\n }\n \n@@ -634,10 +648,10 @@ DateTimePatternGenerator::staticGetSkeleton(\n \n UnicodeString\n DateTimePatternGenerator::getBaseSkeleton(const UnicodeString& pattern, UErrorCode& /*status*/) {\n-    FormatParser fp;\n+    FormatParser fp2;\n     DateTimeMatcher matcher;\n     PtnSkeleton localSkeleton;\n-    matcher.set(pattern, &fp, localSkeleton);\n+    matcher.set(pattern, &fp2, localSkeleton);\n     return localSkeleton.getBaseSkeleton();\n }\n \n@@ -663,7 +677,7 @@ DateTimePatternGenerator::addICUPatterns(const Locale& locale, UErrorCode& statu\n         DateFormat::EStyle style = (DateFormat::EStyle)i;\n         df = DateFormat::createDateInstance(style, locale);\n         SimpleDateFormat* sdf;\n-        if (df != NULL && (sdf = dynamic_cast<SimpleDateFormat*>(df)) != NULL) {\n+        if (df != nullptr && (sdf = dynamic_cast<SimpleDateFormat*>(df)) != nullptr) {\n             sdf->toPattern(dfPattern);\n             addPattern(dfPattern, FALSE, conflictingString, status);\n         }\n@@ -672,7 +686,7 @@ DateTimePatternGenerator::addICUPatterns(const Locale& locale, UErrorCode& statu\n         if (U_FAILURE(status)) { return; }\n \n         df = DateFormat::createTimeInstance(style, locale);\n-        if (df != NULL && (sdf = dynamic_cast<SimpleDateFormat*>(df)) != NULL) {\n+        if (df != nullptr && (sdf = dynamic_cast<SimpleDateFormat*>(df)) != nullptr) {\n             sdf->toPattern(dfPattern);\n             addPattern(dfPattern, FALSE, conflictingString, status);\n \n@@ -747,13 +761,14 @@ DateTimePatternGenerator::getCalendarTypeToUse(const Locale& locale, CharString&\n         ures_getFunctionalEquivalent(\n             localeWithCalendarKey,\n             ULOC_LOCALE_IDENTIFIER_CAPACITY,\n-            NULL,\n+            nullptr,\n             \"calendar\",\n             \"calendar\",\n             locale.getName(),\n-            NULL,\n+            nullptr,\n             FALSE,\n             &err);\n+        if (U_FAILURE(err)) { return; }\n         localeWithCalendarKey[ULOC_LOCALE_IDENTIFIER_CAPACITY-1] = 0; // ensure null termination\n         // now get the calendar key value from that locale\n         char calendarType[ULOC_KEYWORDS_CAPACITY];\n@@ -763,7 +778,8 @@ DateTimePatternGenerator::getCalendarTypeToUse(const Locale& locale, CharString&\n             calendarType,\n             ULOC_KEYWORDS_CAPACITY,\n             &err);\n-        if (U_SUCCESS(err) && calendarTypeLen < ULOC_KEYWORDS_CAPACITY) {\n+        if (U_FAILURE(err)) { return; }\n+        if (calendarTypeLen < ULOC_KEYWORDS_CAPACITY) {\n             destination.clear().append(calendarType, -1, err);\n             if (U_FAILURE(err)) { return; }\n         }\n@@ -774,15 +790,15 @@ DateTimePatternGenerator::getCalendarTypeToUse(const Locale& locale, CharString&\n void\n DateTimePatternGenerator::consumeShortTimePattern(const UnicodeString& shortTimePattern,\n         UErrorCode& status) {\n-\n+    if (U_FAILURE(status)) { return; }\n     // set fDefaultHourFormatChar to the hour format character from this pattern\n     int32_t tfIdx, tfLen = shortTimePattern.length();\n     UBool ignoreChars = FALSE;\n     for (tfIdx = 0; tfIdx < tfLen; tfIdx++) {\n         UChar tfChar = shortTimePattern.charAt(tfIdx);\n         if ( tfChar == SINGLE_QUOTE ) {\n             ignoreChars = !ignoreChars; // toggle (handle quoted literals & '' for single quote)\n-        } else if ( !ignoreChars && u_strchr(hourFormatChars, tfChar) != NULL ) {\n+        } else if ( !ignoreChars && u_strchr(hourFormatChars, tfChar) != nullptr ) {\n             fDefaultHourFormatChar = tfChar;\n             break;\n         }\n@@ -872,9 +888,9 @@ struct DateTimePatternGenerator::AppendItemNamesSink : public ResourceSink {\n                 valueStr.getTerminatedBuffer();\n             }\n             for (int32_t j = 1; j < UDATPG_WIDTH_COUNT; j++) {\n-                UnicodeString& valueStr = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)j);\n-                if (valueStr.isEmpty()) {\n-                    valueStr = dtpg.getFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)(j-1));\n+                UnicodeString& valueStr2 = dtpg.getMutableFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)j);\n+                if (valueStr2.isEmpty()) {\n+                    valueStr2 = dtpg.getFieldDisplayName((UDateTimePatternField)i, (UDateTimePGDisplayWidth)(j-1));\n                 }\n             }\n         }\n@@ -921,7 +937,7 @@ DateTimePatternGenerator::addCLDRData(const Locale& locale, UErrorCode& errorCod\n     UnicodeString rbPattern, value, field;\n     CharString path;\n \n-    LocalUResourceBundlePointer rb(ures_open(NULL, locale.getName(), &errorCode));\n+    LocalUResourceBundlePointer rb(ures_open(nullptr, locale.getName(), &errorCode));\n     if (U_FAILURE(errorCode)) { return; }\n \n     CharString calendarTypeToUse; // to be filled in with the type to use, if all goes well\n@@ -966,12 +982,13 @@ DateTimePatternGenerator::addCLDRData(const Locale& locale, UErrorCode& errorCod\n \n void\n DateTimePatternGenerator::initHashtable(UErrorCode& err) {\n-    if (fAvailableFormatKeyHash!=NULL) {\n+    if (U_FAILURE(err)) { return; }\n+    if (fAvailableFormatKeyHash!=nullptr) {\n         return;\n     }\n-    if ((fAvailableFormatKeyHash = new Hashtable(FALSE, err))==NULL) {\n-        err=U_MEMORY_ALLOCATION_ERROR;\n-        return;\n+    LocalPointer<Hashtable> hash(new Hashtable(FALSE, err), err);\n+    if (U_SUCCESS(err)) {\n+        fAvailableFormatKeyHash = hash.orphan();\n     }\n }\n \n@@ -1028,7 +1045,14 @@ DateTimePatternGenerator::getBestPattern(const UnicodeString& patternForm, UErro\n \n UnicodeString\n DateTimePatternGenerator::getBestPattern(const UnicodeString& patternForm, UDateTimePatternMatchOptions options, UErrorCode& status) {\n-    const UnicodeString *bestPattern=NULL;\n+    if (U_FAILURE(status)) {\n+        return UnicodeString();\n+    }\n+    if (U_FAILURE(internalErrorCode)) {\n+        status = internalErrorCode;\n+        return UnicodeString();\n+    }\n+    const UnicodeString *bestPattern = nullptr;\n     UnicodeString dtFormat;\n     UnicodeString resultPattern;\n     int32_t flags = kDTPGNoFlags;\n@@ -1044,16 +1068,23 @@ DateTimePatternGenerator::getBestPattern(const UnicodeString& patternForm, UDate\n \n     resultPattern.remove();\n     dtMatcher->set(patternFormMapped, fp);\n-    const PtnSkeleton* specifiedSkeleton=NULL;\n-    bestPattern=getBestRaw(*dtMatcher, -1, distanceInfo, &specifiedSkeleton);\n+    const PtnSkeleton* specifiedSkeleton = nullptr;\n+    bestPattern=getBestRaw(*dtMatcher, -1, distanceInfo, status, &specifiedSkeleton);\n+    if (U_FAILURE(status)) {\n+        return UnicodeString();\n+    }\n+\n     if ( distanceInfo->missingFieldMask==0 && distanceInfo->extraFieldMask==0 ) {\n         resultPattern = adjustFieldTypes(*bestPattern, specifiedSkeleton, flags, options);\n \n         return resultPattern;\n     }\n     int32_t neededFields = dtMatcher->getFieldMask();\n-    UnicodeString datePattern=getBestAppending(neededFields & dateMask, flags, options);\n-    UnicodeString timePattern=getBestAppending(neededFields & timeMask, flags, options);\n+    UnicodeString datePattern=getBestAppending(neededFields & dateMask, flags, status, options);\n+    UnicodeString timePattern=getBestAppending(neededFields & timeMask, flags, status, options);\n+    if (U_FAILURE(status)) {\n+        return UnicodeString();\n+    }\n     if (datePattern.length()==0) {\n         if (timePattern.length()==0) {\n             resultPattern.remove();\n@@ -1074,7 +1105,7 @@ DateTimePatternGenerator::getBestPattern(const UnicodeString& patternForm, UDate\n \n /*\n  * Map a skeleton that may have metacharacters jJC to one without, by replacing\n- * the metacharacters with locale-appropriate fields of of h/H/k/K and of a/b/B\n+ * the metacharacters with locale-appropriate fields of h/H/k/K and of a/b/B\n  * (depends on fDefaultHourFormatChar and fAllowedHourFormats being set, which in\n  * turn depends on initData having been run). This method also updates the flags\n  * as necessary. Returns the updated skeleton.\n@@ -1159,9 +1190,16 @@ UnicodeString\n DateTimePatternGenerator::replaceFieldTypes(const UnicodeString& pattern,\n                                             const UnicodeString& skeleton,\n                                             UDateTimePatternMatchOptions options,\n-                                            UErrorCode& /*status*/) {\n+                                            UErrorCode& status) {\n+    if (U_FAILURE(status)) {\n+        return UnicodeString();\n+    }\n+    if (U_FAILURE(internalErrorCode)) {\n+        status = internalErrorCode;\n+        return UnicodeString();\n+    }\n     dtMatcher->set(skeleton, fp);\n-    UnicodeString result = adjustFieldTypes(pattern, NULL, kDTPGNoFlags, options);\n+    UnicodeString result = adjustFieldTypes(pattern, nullptr, kDTPGNoFlags, options);\n     return result;\n }\n \n@@ -1204,20 +1242,24 @@ DateTimePatternGenerator::getDateTimeFormat() const {\n \n void\n DateTimePatternGenerator::setDateTimeFromCalendar(const Locale& locale, UErrorCode& status) {\n+    if (U_FAILURE(status)) { return; }\n+\n     const UChar *resStr;\n     int32_t resStrLen = 0;\n \n-    Calendar* fCalendar = Calendar::createInstance(locale, status);\n+    LocalPointer<Calendar> fCalendar(Calendar::createInstance(locale, status), status);\n     if (U_FAILURE(status)) { return; }\n \n-    LocalUResourceBundlePointer calData(ures_open(NULL, locale.getBaseName(), &status));\n+    LocalUResourceBundlePointer calData(ures_open(nullptr, locale.getBaseName(), &status));\n+    if (U_FAILURE(status)) { return; }\n     ures_getByKey(calData.getAlias(), DT_DateTimeCalendarTag, calData.getAlias(), &status);\n+    if (U_FAILURE(status)) { return; }\n \n     LocalUResourceBundlePointer dateTimePatterns;\n-    if (fCalendar != NULL && fCalendar->getType() != NULL && *fCalendar->getType() != '\\0'\n+    if (fCalendar->getType() != nullptr && *fCalendar->getType() != '\\0'\n             && uprv_strcmp(fCalendar->getType(), DT_DateTimeGregorianTag) != 0) {\n         dateTimePatterns.adoptInstead(ures_getByKeyWithFallback(calData.getAlias(), fCalendar->getType(),\n-                                                                NULL, &status));\n+                                                                nullptr, &status));\n         ures_getByKeyWithFallback(dateTimePatterns.getAlias(), DT_DateTimePatternsTag,\n                                   dateTimePatterns.getAlias(), &status);\n     }\n@@ -1238,8 +1280,6 @@ DateTimePatternGenerator::setDateTimeFromCalendar(const Locale& locale, UErrorCo\n     }\n     resStr = ures_getStringByIndex(dateTimePatterns.getAlias(), (int32_t)DateFormat::kDateTime, &resStrLen, &status);\n     setDateTimeFormat(UnicodeString(TRUE, resStr, resStrLen));\n-\n-    delete fCalendar;\n }\n \n void\n@@ -1259,7 +1299,12 @@ DateTimePatternGenerator::addPattern(\n     UnicodeString &conflictingPattern,\n     UErrorCode& status)\n {\n-    return addPatternWithSkeleton(pattern, NULL, override, conflictingPattern, status);\n+    if (U_FAILURE(internalErrorCode)) {\n+        status = internalErrorCode;\n+        return UDATPG_NO_CONFLICT;\n+    }\n+\n+    return addPatternWithSkeleton(pattern, nullptr, override, conflictingPattern, status);\n }\n \n // For DateTimePatternGenerator::addPatternWithSkeleton -\n@@ -1280,13 +1325,17 @@ DateTimePatternGenerator::addPatternWithSkeleton(\n     UnicodeString& conflictingPattern,\n     UErrorCode& status)\n {\n+    if (U_FAILURE(internalErrorCode)) {\n+        status = internalErrorCode;\n+        return UDATPG_NO_CONFLICT;\n+    }\n \n     UnicodeString basePattern;\n     PtnSkeleton   skeleton;\n     UDateTimePatternConflict conflictingStatus = UDATPG_NO_CONFLICT;\n \n     DateTimeMatcher matcher;\n-    if ( skeletonToUse == NULL ) {\n+    if ( skeletonToUse == nullptr ) {\n         matcher.set(pattern, fp, skeleton);\n         matcher.getBasePattern(basePattern);\n     } else {\n@@ -1302,7 +1351,7 @@ DateTimePatternGenerator::addPatternWithSkeleton(\n     // availableFormats items from root, which should not override any previous entry with the same base.\n     UBool entryHadSpecifiedSkeleton;\n     const UnicodeString *duplicatePattern = patternMap->getPatternFromBasePattern(basePattern, entryHadSpecifiedSkeleton);\n-    if (duplicatePattern != NULL && (!entryHadSpecifiedSkeleton || (skeletonToUse != NULL && !override))) {\n+    if (duplicatePattern != nullptr && (!entryHadSpecifiedSkeleton || (skeletonToUse != nullptr && !override))) {\n         conflictingStatus = UDATPG_BASE_CONFLICT;\n         conflictingPattern = *duplicatePattern;\n         if (!override) {\n@@ -1313,16 +1362,16 @@ DateTimePatternGenerator::addPatternWithSkeleton(\n     // items from CLDR data. In that case, we don't want an item from a parent locale to replace an item with\n     // same skeleton from the specified locale, so skip the current item if skeletonWasSpecified is true for\n     // the previously-specified conflicting item.\n-    const PtnSkeleton* entrySpecifiedSkeleton = NULL;\n+    const PtnSkeleton* entrySpecifiedSkeleton = nullptr;\n     duplicatePattern = patternMap->getPatternFromSkeleton(skeleton, &entrySpecifiedSkeleton);\n-    if (duplicatePattern != NULL ) {\n+    if (duplicatePattern != nullptr ) {\n         conflictingStatus = UDATPG_CONFLICT;\n         conflictingPattern = *duplicatePattern;\n-        if (!override || (skeletonToUse != NULL && entrySpecifiedSkeleton != NULL)) {\n+        if (!override || (skeletonToUse != nullptr && entrySpecifiedSkeleton != nullptr)) {\n             return conflictingStatus;\n         }\n     }\n-    patternMap->add(basePattern, skeleton, pattern, skeletonToUse != NULL, status);\n+    patternMap->add(basePattern, skeleton, pattern, skeletonToUse != nullptr, status);\n     if(U_FAILURE(status)) {\n         return conflictingStatus;\n     }\n@@ -1369,13 +1418,16 @@ const UnicodeString*\n DateTimePatternGenerator::getBestRaw(DateTimeMatcher& source,\n                                      int32_t includeMask,\n                                      DistanceInfo* missingFields,\n+                                     UErrorCode &status,\n                                      const PtnSkeleton** specifiedSkeletonPtr) {\n     int32_t bestDistance = 0x7fffffff;\n     DistanceInfo tempInfo;\n-    const UnicodeString *bestPattern=NULL;\n-    const PtnSkeleton* specifiedSkeleton=NULL;\n+    const UnicodeString *bestPattern=nullptr;\n+    const PtnSkeleton* specifiedSkeleton=nullptr;\n+\n+    PatternMapIterator it(status);\n+    if (U_FAILURE(status)) { return nullptr; }\n \n-    PatternMapIterator it;\n     for (it.set(*patternMap); it.hasNext(); ) {\n         DateTimeMatcher trial = it.next();\n         if (trial.equals(skipMatcher)) {\n@@ -1485,8 +1537,8 @@ DateTimePatternGenerator::adjustFieldTypes(const UnicodeString& pattern,\n                         c = fDefaultHourFormatChar;\n                     }\n                     field.remove();\n-                    for (int32_t i=adjFieldLen; i>0; --i) {\n-                        field+=c;\n+                    for (int32_t j=adjFieldLen; j>0; --j) {\n+                        field += c;\n                     }\n             }\n             newPattern+=field;\n@@ -1496,14 +1548,21 @@ DateTimePatternGenerator::adjustFieldTypes(const UnicodeString& pattern,\n }\n \n UnicodeString\n-DateTimePatternGenerator::getBestAppending(int32_t missingFields, int32_t flags, UDateTimePatternMatchOptions options) {\n+DateTimePatternGenerator::getBestAppending(int32_t missingFields, int32_t flags, UErrorCode &status, UDateTimePatternMatchOptions options) {\n+    if (U_FAILURE(status)) {\n+        return UnicodeString();\n+    }\n     UnicodeString  resultPattern, tempPattern;\n-    UErrorCode err=U_ZERO_ERROR;\n+    const UnicodeString* tempPatternPtr;\n     int32_t lastMissingFieldMask=0;\n     if (missingFields!=0) {\n         resultPattern=UnicodeString();\n-        const PtnSkeleton* specifiedSkeleton=NULL;\n-        tempPattern = *getBestRaw(*dtMatcher, missingFields, distanceInfo, &specifiedSkeleton);\n+        const PtnSkeleton* specifiedSkeleton=nullptr;\n+        tempPatternPtr = getBestRaw(*dtMatcher, missingFields, distanceInfo, status, &specifiedSkeleton);\n+        if (U_FAILURE(status)) {\n+            return UnicodeString();\n+        }\n+        tempPattern = *tempPatternPtr;\n         resultPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);\n         if ( distanceInfo->missingFieldMask==0 ) {\n             return resultPattern;\n@@ -1519,27 +1578,34 @@ DateTimePatternGenerator::getBestAppending(int32_t missingFields, int32_t flags,\n                 continue;\n             }\n             int32_t startingMask = distanceInfo->missingFieldMask;\n-            tempPattern = *getBestRaw(*dtMatcher, distanceInfo->missingFieldMask, distanceInfo, &specifiedSkeleton);\n+            tempPatternPtr = getBestRaw(*dtMatcher, distanceInfo->missingFieldMask, distanceInfo, status, &specifiedSkeleton);\n+            if (U_FAILURE(status)) {\n+                return UnicodeString();\n+            }\n+            tempPattern = *tempPatternPtr;\n             tempPattern = adjustFieldTypes(tempPattern, specifiedSkeleton, flags, options);\n             int32_t foundMask=startingMask& ~distanceInfo->missingFieldMask;\n             int32_t topField=getTopBitNumber(foundMask);\n-            UnicodeString appendName;\n-            getAppendName((UDateTimePatternField)topField, appendName);\n-            const UnicodeString *values[3] = {\n-                &resultPattern,\n-                &tempPattern,\n-                &appendName\n-            };\n-            SimpleFormatter(appendItemFormats[topField], 2, 3, err).\n-                    formatAndReplace(values, 3, resultPattern, NULL, 0, err);\n+\n+            if (appendItemFormats[topField].length() != 0) {\n+                UnicodeString appendName;\n+                getAppendName((UDateTimePatternField)topField, appendName);\n+                const UnicodeString *values[3] = {\n+                    &resultPattern,\n+                    &tempPattern,\n+                    &appendName\n+                };\n+                SimpleFormatter(appendItemFormats[topField], 2, 3, status).\n+                    formatAndReplace(values, 3, resultPattern, nullptr, 0, status);\n+            }\n             lastMissingFieldMask = distanceInfo->missingFieldMask;\n         }\n     }\n     return resultPattern;\n }\n \n int32_t\n-DateTimePatternGenerator::getTopBitNumber(int32_t foundMask) {\n+DateTimePatternGenerator::getTopBitNumber(int32_t foundMask) const {\n     if ( foundMask==0 ) {\n         return 0;\n     }\n@@ -1568,22 +1634,21 @@ DateTimePatternGenerator::isAvailableFormatSet(const UnicodeString &key) const {\n \n void\n DateTimePatternGenerator::copyHashtable(Hashtable *other, UErrorCode &status) {\n-\n-    if (other == NULL) {\n+    if (other == nullptr || U_FAILURE(status)) {\n         return;\n     }\n-    if (fAvailableFormatKeyHash != NULL) {\n+    if (fAvailableFormatKeyHash != nullptr) {\n         delete fAvailableFormatKeyHash;\n-        fAvailableFormatKeyHash = NULL;\n+        fAvailableFormatKeyHash = nullptr;\n     }\n     initHashtable(status);\n     if(U_FAILURE(status)){\n         return;\n     }\n     int32_t pos = UHASH_FIRST;\n-    const UHashElement* elem = NULL;\n+    const UHashElement* elem = nullptr;\n     // walk through the hash table and create a deep clone\n-    while((elem = other->nextElement(pos))!= NULL){\n+    while((elem = other->nextElement(pos))!= nullptr){\n         const UHashTok otherKeyTok = elem->key;\n         UnicodeString* otherKey = (UnicodeString*)otherKeyTok.pointer;\n         fAvailableFormatKeyHash->puti(*otherKey, 1, status);\n@@ -1595,8 +1660,17 @@ DateTimePatternGenerator::copyHashtable(Hashtable *other, UErrorCode &status) {\n \n StringEnumeration*\n DateTimePatternGenerator::getSkeletons(UErrorCode& status) const {\n-    StringEnumeration* skeletonEnumerator = new DTSkeletonEnumeration(*patternMap, DT_SKELETON, status);\n-    return skeletonEnumerator;\n+    if (U_FAILURE(status)) {\n+        return nullptr;\n+    }\n+    if (U_FAILURE(internalErrorCode)) {\n+        status = internalErrorCode;\n+        return nullptr;\n+    }\n+    LocalPointer<StringEnumeration> skeletonEnumerator(\n+        new DTSkeletonEnumeration(*patternMap, DT_SKELETON, status), status);\n+\n+    return U_SUCCESS(status) ? skeletonEnumerator.orphan() : nullptr;\n }\n \n const UnicodeString&\n@@ -1607,47 +1681,70 @@ DateTimePatternGenerator::getPatternForSkeleton(const UnicodeString& skeleton) c\n         return emptyString;\n     }\n     curElem = patternMap->getHeader(skeleton.charAt(0));\n-    while ( curElem != NULL ) {\n+    while ( curElem != nullptr ) {\n         if ( curElem->skeleton->getSkeleton()==skeleton ) {\n             return curElem->pattern;\n         }\n-        curElem=curElem->next;\n+        curElem = curElem->next.getAlias();\n     }\n     return emptyString;\n }\n \n StringEnumeration*\n DateTimePatternGenerator::getBaseSkeletons(UErrorCode& status) const {\n-    StringEnumeration* baseSkeletonEnumerator = new DTSkeletonEnumeration(*patternMap, DT_BASESKELETON, status);\n-    return baseSkeletonEnumerator;\n+    if (U_FAILURE(status)) {\n+        return nullptr;\n+    }\n+    if (U_FAILURE(internalErrorCode)) {\n+        status = internalErrorCode;\n+        return nullptr;\n+    }\n+    LocalPointer<StringEnumeration> baseSkeletonEnumerator(\n+        new DTSkeletonEnumeration(*patternMap, DT_BASESKELETON, status), status);\n+\n+    return U_SUCCESS(status) ? baseSkeletonEnumerator.orphan() : nullptr;\n }\n \n StringEnumeration*\n DateTimePatternGenerator::getRedundants(UErrorCode& status) {\n-    StringEnumeration* output = new DTRedundantEnumeration();\n+    if (U_FAILURE(status)) { return nullptr; }\n+    if (U_FAILURE(internalErrorCode)) {\n+        status = internalErrorCode;\n+        return nullptr;\n+    }\n+    LocalPointer<StringEnumeration> output(new DTRedundantEnumeration(), status);\n+    if (U_FAILURE(status)) { return nullptr; }\n     const UnicodeString *pattern;\n-    PatternMapIterator it;\n+    PatternMapIterator it(status);\n+    if (U_FAILURE(status)) { return nullptr; }\n+\n     for (it.set(*patternMap); it.hasNext(); ) {\n         DateTimeMatcher current = it.next();\n         pattern = patternMap->getPatternFromSkeleton(*(it.getSkeleton()));\n         if ( isCanonicalItem(*pattern) ) {\n             continue;\n         }\n-        if ( skipMatcher == NULL ) {\n+        if ( skipMatcher == nullptr ) {\n             skipMatcher = new DateTimeMatcher(current);\n+            if (skipMatcher == nullptr) {\n+                status = U_MEMORY_ALLOCATION_ERROR;\n+                return nullptr;\n+            }\n         }\n         else {\n             *skipMatcher = current;\n         }\n         UnicodeString trial = getBestPattern(current.getPattern(), status);\n+        if (U_FAILURE(status)) { return nullptr; }\n         if (trial == *pattern) {\n-            ((DTRedundantEnumeration *)output)->add(*pattern, status);\n+            ((DTRedundantEnumeration *)output.getAlias())->add(*pattern, status);\n+            if (U_FAILURE(status)) { return nullptr; }\n         }\n         if (current.equals(skipMatcher)) {\n             continue;\n         }\n     }\n-    return output;\n+    return output.orphan();\n }\n \n UBool\n@@ -1671,45 +1768,54 @@ DateTimePatternGenerator::clone() const {\n \n PatternMap::PatternMap() {\n    for (int32_t i=0; i < MAX_PATTERN_ENTRIES; ++i ) {\n-      boot[i]=NULL;\n+       boot[i] = nullptr;\n    }\n    isDupAllowed = TRUE;\n }\n \n void\n PatternMap::copyFrom(const PatternMap& other, UErrorCode& status) {\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n     this->isDupAllowed = other.isDupAllowed;\n-    for (int32_t bootIndex=0; bootIndex<MAX_PATTERN_ENTRIES; ++bootIndex ) {\n-        PtnElem *curElem, *otherElem, *prevElem=NULL;\n+    for (int32_t bootIndex = 0; bootIndex < MAX_PATTERN_ENTRIES; ++bootIndex) {\n+        PtnElem *curElem, *otherElem, *prevElem=nullptr;\n         otherElem = other.boot[bootIndex];\n-        while (otherElem!=NULL) {\n-            if ((curElem = new PtnElem(otherElem->basePattern, otherElem->pattern))==NULL) {\n-                // out of memory\n-                status = U_MEMORY_ALLOCATION_ERROR;\n-                return;\n+        while (otherElem != nullptr) {\n+            LocalPointer<PtnElem> newElem(new PtnElem(otherElem->basePattern, otherElem->pattern), status);\n+            if (U_FAILURE(status)) {\n+                return; // out of memory\n             }\n-            if ( this->boot[bootIndex]== NULL ) {\n-                this->boot[bootIndex] = curElem;\n+            newElem->skeleton.adoptInsteadAndCheckErrorCode(new PtnSkeleton(*(otherElem->skeleton)), status);\n+            if (U_FAILURE(status)) {\n+                return; // out of memory\n             }\n-            if ((curElem->skeleton=new PtnSkeleton(*(otherElem->skeleton))) == NULL ) {\n-                // out of memory\n-                status = U_MEMORY_ALLOCATION_ERROR;\n-                return;\n-            }\n-            curElem->skeletonWasSpecified = otherElem->skeletonWasSpecified;\n-            if (prevElem!=NULL) {\n-                prevElem->next=curElem;\n+            newElem->skeletonWasSpecified = otherElem->skeletonWasSpecified;\n+\n+            // Release ownership from the LocalPointer of the PtnElem object.\n+            // The PtnElem will now be owned by either the boot (for the first entry in the linked-list)\n+            // or owned by the previous PtnElem object in the linked-list.\n+            curElem = newElem.orphan();\n+\n+            if (this->boot[bootIndex] == nullptr) {\n+                this->boot[bootIndex] = curElem;\n+            } else {\n+                if (prevElem != nullptr) {\n+                    prevElem->next.adoptInstead(curElem);\n+                } else {\n+                    U_ASSERT(false);\n+                }\n             }\n-            curElem->next=NULL;\n             prevElem = curElem;\n-            otherElem = otherElem->next;\n+            otherElem = otherElem->next.getAlias();\n         }\n \n     }\n }\n \n PtnElem*\n-PatternMap::getHeader(UChar baseChar) {\n+PatternMap::getHeader(UChar baseChar) const {\n     PtnElem* curElem;\n \n     if ( (baseChar >= CAP_A) && (baseChar <= CAP_Z) ) {\n@@ -1720,17 +1826,17 @@ PatternMap::getHeader(UChar baseChar) {\n             curElem = boot[26+baseChar-LOW_A];\n         }\n         else {\n-            return NULL;\n+            return nullptr;\n         }\n     }\n     return curElem;\n }\n \n PatternMap::~PatternMap() {\n    for (int32_t i=0; i < MAX_PATTERN_ENTRIES; ++i ) {\n-       if (boot[i]!=NULL ) {\n+       if (boot[i] != nullptr ) {\n            delete boot[i];\n-           boot[i]=NULL;\n+           boot[i] = nullptr;\n        }\n    }\n }  // PatternMap destructor\n@@ -1759,39 +1865,45 @@ PatternMap::add(const UnicodeString& basePattern,\n          }\n     }\n \n-    if (baseElem == NULL) {\n-        if ((curElem = new PtnElem(basePattern, value)) == NULL ) {\n-            // out of memory\n-            status = U_MEMORY_ALLOCATION_ERROR;\n-            return;\n+    if (baseElem == nullptr) {\n+        LocalPointer<PtnElem> newElem(new PtnElem(basePattern, value), status);\n+        if (U_FAILURE(status)) {\n+            return; // out of memory\n         }\n+        newElem->skeleton.adoptInsteadAndCheckErrorCode(new PtnSkeleton(skeleton), status);\n+        if (U_FAILURE(status)) {\n+            return; // out of memory\n+        }\n+        newElem->skeletonWasSpecified = skeletonWasSpecified;\n         if (baseChar >= LOW_A) {\n-            boot[26 + (baseChar-LOW_A)] = curElem;\n+            boot[26 + (baseChar - LOW_A)] = newElem.orphan(); // the boot array now owns the PtnElem.\n         }\n         else {\n-            boot[baseChar-CAP_A] = curElem;\n+            boot[baseChar - CAP_A] = newElem.orphan(); // the boot array now owns the PtnElem.\n         }\n-        curElem->skeleton = new PtnSkeleton(skeleton);\n-        curElem->skeletonWasSpecified = skeletonWasSpecified;\n     }\n-    if ( baseElem != NULL ) {\n+    if ( baseElem != nullptr ) {\n         curElem = getDuplicateElem(basePattern, skeleton, baseElem);\n \n-        if (curElem == NULL) {\n+        if (curElem == nullptr) {\n             // add new element to the list.\n             curElem = baseElem;\n-            while( curElem -> next != NULL )\n+            while( curElem -> next != nullptr )\n             {\n-                curElem = curElem->next;\n+                curElem = curElem->next.getAlias();\n             }\n-            if ((curElem->next = new PtnElem(basePattern, value)) == NULL ) {\n-                // out of memory\n-                status = U_MEMORY_ALLOCATION_ERROR;\n-                return;\n+\n+            LocalPointer<PtnElem> newElem(new PtnElem(basePattern, value), status);\n+            if (U_FAILURE(status)) {\n+                return; // out of memory\n             }\n-            curElem=curElem->next;\n-            curElem->skeleton = new PtnSkeleton(skeleton);\n-            curElem->skeletonWasSpecified = skeletonWasSpecified;\n+            newElem->skeleton.adoptInsteadAndCheckErrorCode(new PtnSkeleton(skeleton), status);\n+            if (U_FAILURE(status)) {\n+                return; // out of memory\n+            }\n+            newElem->skeletonWasSpecified = skeletonWasSpecified;\n+            curElem->next.adoptInstead(newElem.orphan());\n+            curElem = curElem->next.getAlias();\n         }\n         else {\n             // Pattern exists in the list already.\n@@ -1809,22 +1921,22 @@ PatternMap::add(const UnicodeString& basePattern,\n \n // Find the pattern from the given basePattern string.\n const UnicodeString *\n-PatternMap::getPatternFromBasePattern(UnicodeString& basePattern, UBool& skeletonWasSpecified) { // key to search for\n+PatternMap::getPatternFromBasePattern(const UnicodeString& basePattern, UBool& skeletonWasSpecified) const { // key to search for\n    PtnElem *curElem;\n \n-   if ((curElem=getHeader(basePattern.charAt(0)))==NULL) {\n-       return NULL;  // no match\n+   if ((curElem=getHeader(basePattern.charAt(0)))==nullptr) {\n+       return nullptr;  // no match\n    }\n \n    do  {\n        if ( basePattern.compare(curElem->basePattern)==0 ) {\n           skeletonWasSpecified = curElem->skeletonWasSpecified;\n           return &(curElem->pattern);\n        }\n-       curElem=curElem->next;\n-   }while (curElem != NULL);\n+       curElem = curElem->next.getAlias();\n+   } while (curElem != nullptr);\n \n-   return NULL;\n+   return nullptr;\n }  // PatternMap::getFromBasePattern\n \n \n@@ -1835,69 +1947,69 @@ PatternMap::getPatternFromBasePattern(UnicodeString& basePattern, UBool& skeleto\n // optimum distance value in getBestRaw. When this is called from public getRedundants (specifiedSkeletonPtr is NULL),\n // for now it will continue to compare based on baseOriginal so as not to change the behavior unnecessarily.\n const UnicodeString *\n-PatternMap::getPatternFromSkeleton(PtnSkeleton& skeleton, const PtnSkeleton** specifiedSkeletonPtr) { // key to search for\n+PatternMap::getPatternFromSkeleton(const PtnSkeleton& skeleton, const PtnSkeleton** specifiedSkeletonPtr) const { // key to search for\n    PtnElem *curElem;\n \n    if (specifiedSkeletonPtr) {\n-       *specifiedSkeletonPtr = NULL;\n+       *specifiedSkeletonPtr = nullptr;\n    }\n \n    // find boot entry\n    UChar baseChar = skeleton.getFirstChar();\n-   if ((curElem=getHeader(baseChar))==NULL) {\n-       return NULL;  // no match\n+   if ((curElem=getHeader(baseChar))==nullptr) {\n+       return nullptr;  // no match\n    }\n \n    do  {\n        UBool equal;\n-       if (specifiedSkeletonPtr != NULL) { // called from DateTimePatternGenerator::getBestRaw or addPattern, use original\n+       if (specifiedSkeletonPtr != nullptr) { // called from DateTimePatternGenerator::getBestRaw or addPattern, use original\n            equal = curElem->skeleton->original == skeleton.original;\n        } else { // called from DateTimePatternGenerator::getRedundants, use baseOriginal\n            equal = curElem->skeleton->baseOriginal == skeleton.baseOriginal;\n        }\n        if (equal) {\n            if (specifiedSkeletonPtr && curElem->skeletonWasSpecified) {\n-               *specifiedSkeletonPtr = curElem->skeleton;\n+               *specifiedSkeletonPtr = curElem->skeleton.getAlias();\n            }\n            return &(curElem->pattern);\n        }\n-       curElem=curElem->next;\n-   }while (curElem != NULL);\n+       curElem = curElem->next.getAlias();\n+   } while (curElem != nullptr);\n \n-   return NULL;\n+   return nullptr;\n }\n \n UBool\n-PatternMap::equals(const PatternMap& other) {\n+PatternMap::equals(const PatternMap& other) const {\n     if ( this==&other ) {\n         return TRUE;\n     }\n-    for (int32_t bootIndex=0; bootIndex<MAX_PATTERN_ENTRIES; ++bootIndex ) {\n-        if ( boot[bootIndex]==other.boot[bootIndex] ) {\n+    for (int32_t bootIndex = 0; bootIndex < MAX_PATTERN_ENTRIES; ++bootIndex) {\n+        if (boot[bootIndex] == other.boot[bootIndex]) {\n             continue;\n         }\n-        if ( (boot[bootIndex]==NULL)||(other.boot[bootIndex]==NULL) ) {\n+        if ((boot[bootIndex] == nullptr) || (other.boot[bootIndex] == nullptr)) {\n             return FALSE;\n         }\n         PtnElem *otherElem = other.boot[bootIndex];\n         PtnElem *myElem = boot[bootIndex];\n-        while ((otherElem!=NULL) || (myElem!=NULL)) {\n+        while ((otherElem != nullptr) || (myElem != nullptr)) {\n             if ( myElem == otherElem ) {\n                 break;\n             }\n-            if ((otherElem==NULL) || (myElem==NULL)) {\n+            if ((otherElem == nullptr) || (myElem == nullptr)) {\n                 return FALSE;\n             }\n             if ( (myElem->basePattern != otherElem->basePattern) ||\n                  (myElem->pattern != otherElem->pattern) ) {\n                 return FALSE;\n             }\n-            if ((myElem->skeleton!=otherElem->skeleton)&&\n+            if ((myElem->skeleton.getAlias() != otherElem->skeleton.getAlias()) &&\n                 !myElem->skeleton->equals(*(otherElem->skeleton))) {\n                 return FALSE;\n             }\n-            myElem = myElem->next;\n-            otherElem=otherElem->next;\n+            myElem = myElem->next.getAlias();\n+            otherElem = otherElem->next.getAlias();\n         }\n     }\n     return TRUE;\n@@ -1909,33 +2021,33 @@ PtnElem*\n PatternMap::getDuplicateElem(\n             const UnicodeString &basePattern,\n             const PtnSkeleton &skeleton,\n-            PtnElem *baseElem)  {\n+            PtnElem *baseElem) {\n    PtnElem *curElem;\n \n-   if ( baseElem == (PtnElem *)NULL )  {\n-         return (PtnElem*)NULL;\n+   if ( baseElem == nullptr ) {\n+         return nullptr;\n    }\n    else {\n          curElem = baseElem;\n    }\n    do {\n      if ( basePattern.compare(curElem->basePattern)==0 ) {\n-        UBool isEqual=TRUE;\n-        for (int32_t i=0; i<UDATPG_FIELD_COUNT; ++i) {\n+         UBool isEqual = TRUE;\n+         for (int32_t i = 0; i < UDATPG_FIELD_COUNT; ++i) {\n             if (curElem->skeleton->type[i] != skeleton.type[i] ) {\n-                isEqual=FALSE;\n+                isEqual = FALSE;\n                 break;\n             }\n         }\n         if (isEqual) {\n             return curElem;\n         }\n      }\n-     curElem = curElem->next;\n-   } while( curElem != (PtnElem *)NULL );\n+     curElem = curElem->next.getAlias();\n+   } while( curElem != nullptr );\n \n    // end of the list\n-   return (PtnElem*)NULL;\n+   return nullptr;\n \n }  // PatternMap::getDuplicateElem\n \n@@ -1976,7 +2088,7 @@ DateTimeMatcher::set(const UnicodeString& pattern, FormatParser* fp, PtnSkeleton\n             continue;\n         }\n         int32_t canonicalIndex = fp->getCanonicalIndex(value);\n-        if (canonicalIndex < 0 ) {\n+        if (canonicalIndex < 0) {\n             continue;\n         }\n         const dtTypeElem *row = &dtTypes[canonicalIndex];\n@@ -1986,8 +2098,9 @@ DateTimeMatcher::set(const UnicodeString& pattern, FormatParser* fp, PtnSkeleton\n         int32_t repeatCount = row->minLen;\n         skeletonResult.baseOriginal.populate(field, repeatChar, repeatCount);\n         int16_t subField = row->type;\n-        if ( row->type > 0) {\n-            subField += value.length();\n+        if (row->type > 0) {\n+            U_ASSERT(value.length() < INT16_MAX);\n+            subField += static_cast<int16_t>(value.length());\n         }\n         skeletonResult.type[field] = subField;\n     }\n@@ -2031,8 +2144,8 @@ DateTimeMatcher::getPattern() {\n }\n \n int32_t\n-DateTimeMatcher::getDistance(const DateTimeMatcher& other, int32_t includeMask, DistanceInfo& distanceInfo) {\n-    int32_t result=0;\n+DateTimeMatcher::getDistance(const DateTimeMatcher& other, int32_t includeMask, DistanceInfo& distanceInfo) const {\n+    int32_t result = 0;\n     distanceInfo.clear();\n     for (int32_t i=0; i<UDATPG_FIELD_COUNT; ++i ) {\n         int32_t myType = (includeMask&(1<<i))==0 ? 0 : skeleton.type[i];\n@@ -2071,13 +2184,13 @@ DateTimeMatcher::copyFrom() {\n \n UBool\n DateTimeMatcher::equals(const DateTimeMatcher* other) const {\n-    if (other==NULL) { return FALSE; }\n+    if (other==nullptr) { return FALSE; }\n     return skeleton.original == other->skeleton.original;\n }\n \n int32_t\n-DateTimeMatcher::getFieldMask() {\n-    int32_t result=0;\n+DateTimeMatcher::getFieldMask() const {\n+    int32_t result = 0;\n \n     for (int32_t i=0; i<UDATPG_FIELD_COUNT; ++i) {\n         if (skeleton.type[i]!=0) {\n@@ -2094,7 +2207,7 @@ DateTimeMatcher::getSkeletonPtr() {\n \n FormatParser::FormatParser () {\n     status = START;\n-    itemNumber=0;\n+    itemNumber = 0;\n }\n \n \n@@ -2106,7 +2219,7 @@ FormatParser::~FormatParser () {\n // Note: the startPos may\n FormatParser::TokenStatus\n FormatParser::setTokens(const UnicodeString& pattern, int32_t startPos, int32_t *len) {\n-    int32_t  curLoc = startPos;\n+    int32_t curLoc = startPos;\n     if ( curLoc >= pattern.length()) {\n         return DONE;\n     }\n@@ -2132,10 +2245,10 @@ FormatParser::setTokens(const UnicodeString& pattern, int32_t startPos, int32_t\n \n void\n FormatParser::set(const UnicodeString& pattern) {\n-    int32_t startPos=0;\n-    TokenStatus result=START;\n-    int32_t len=0;\n-    itemNumber =0;\n+    int32_t startPos = 0;\n+    TokenStatus result = START;\n+    int32_t len = 0;\n+    itemNumber = 0;\n \n     do {\n         result = setTokens( pattern, startPos, &len );\n@@ -2186,14 +2299,14 @@ FormatParser::getCanonicalIndex(const UnicodeString& s, UBool strict) {\n \n UBool\n FormatParser::isQuoteLiteral(const UnicodeString& s) {\n-    return (UBool)(s.charAt(0)==SINGLE_QUOTE);\n+    return (UBool)(s.charAt(0) == SINGLE_QUOTE);\n }\n \n-// This function aussumes the current itemIndex points to the quote literal.\n+// This function assumes the current itemIndex points to the quote literal.\n // Please call isQuoteLiteral prior to this function.\n void\n FormatParser::getQuoteLiteral(UnicodeString& quote, int32_t *itemIndex) {\n-    int32_t i=*itemIndex;\n+    int32_t i = *itemIndex;\n \n     quote.remove();\n     if (items[i].charAt(0)==SINGLE_QUOTE) {\n@@ -2222,7 +2335,7 @@ FormatParser::getQuoteLiteral(UnicodeString& quote, int32_t *itemIndex) {\n }\n \n UBool\n-FormatParser::isPatternSeparator(UnicodeString& field) {\n+FormatParser::isPatternSeparator(const UnicodeString& field) const {\n     for (int32_t i=0; i<field.length(); ++i ) {\n         UChar c= field.charAt(i);\n         if ( (c==SINGLE_QUOTE) || (c==BACKSLASH) || (c==SPACE) || (c==COLON) ||\n@@ -2239,21 +2352,19 @@ FormatParser::isPatternSeparator(UnicodeString& field) {\n DistanceInfo::~DistanceInfo() {}\n \n void\n-DistanceInfo::setTo(DistanceInfo &other) {\n+DistanceInfo::setTo(const DistanceInfo& other) {\n     missingFieldMask = other.missingFieldMask;\n     extraFieldMask= other.extraFieldMask;\n }\n \n-PatternMapIterator::PatternMapIterator() {\n-    bootIndex = 0;\n-    nodePtr = NULL;\n-    patternMap=NULL;\n-    matcher= new DateTimeMatcher();\n+PatternMapIterator::PatternMapIterator(UErrorCode& status) :\n+    bootIndex(0), nodePtr(nullptr), matcher(nullptr), patternMap(nullptr)\n+{\n+    if (U_FAILURE(status)) { return; }\n+    matcher.adoptInsteadAndCheckErrorCode(new DateTimeMatcher(), status);\n }\n \n-\n PatternMapIterator::~PatternMapIterator() {\n-    delete matcher;\n }\n \n void\n@@ -2262,64 +2373,63 @@ PatternMapIterator::set(PatternMap& newPatternMap) {\n }\n \n PtnSkeleton*\n-PatternMapIterator::getSkeleton() {\n-    if ( nodePtr == NULL ) {\n-        return NULL;\n+PatternMapIterator::getSkeleton() const {\n+    if ( nodePtr == nullptr ) {\n+        return nullptr;\n     }\n     else {\n-        return nodePtr->skeleton;\n+        return nodePtr->skeleton.getAlias();\n     }\n }\n \n UBool\n-PatternMapIterator::hasNext() {\n-    int32_t headIndex=bootIndex;\n-    PtnElem *curPtr=nodePtr;\n+PatternMapIterator::hasNext() const {\n+    int32_t headIndex = bootIndex;\n+    PtnElem *curPtr = nodePtr;\n \n-    if (patternMap==NULL) {\n+    if (patternMap==nullptr) {\n         return FALSE;\n     }\n     while ( headIndex < MAX_PATTERN_ENTRIES ) {\n-        if ( curPtr != NULL ) {\n-            if ( curPtr->next != NULL ) {\n+        if ( curPtr != nullptr ) {\n+            if ( curPtr->next != nullptr ) {\n                 return TRUE;\n             }\n             else {\n                 headIndex++;\n-                curPtr=NULL;\n+                curPtr=nullptr;\n                 continue;\n             }\n         }\n         else {\n-            if ( patternMap->boot[headIndex] != NULL ) {\n+            if ( patternMap->boot[headIndex] != nullptr ) {\n                 return TRUE;\n             }\n             else {\n                 headIndex++;\n                 continue;\n             }\n         }\n-\n     }\n     return FALSE;\n }\n \n DateTimeMatcher&\n PatternMapIterator::next() {\n     while ( bootIndex < MAX_PATTERN_ENTRIES ) {\n-        if ( nodePtr != NULL ) {\n-            if ( nodePtr->next != NULL ) {\n-                nodePtr = nodePtr->next;\n+        if ( nodePtr != nullptr ) {\n+            if ( nodePtr->next != nullptr ) {\n+                nodePtr = nodePtr->next.getAlias();\n                 break;\n             }\n             else {\n                 bootIndex++;\n-                nodePtr=NULL;\n+                nodePtr=nullptr;\n                 continue;\n             }\n         }\n         else {\n-            if ( patternMap->boot[bootIndex] != NULL ) {\n+            if ( patternMap->boot[bootIndex] != nullptr ) {\n                 nodePtr = patternMap->boot[bootIndex];\n                 break;\n             }\n@@ -2329,7 +2439,7 @@ PatternMapIterator::next() {\n             }\n         }\n     }\n-    if (nodePtr!=NULL) {\n+    if (nodePtr!=nullptr) {\n         matcher->copyFrom(*nodePtr->skeleton);\n     }\n     else {\n@@ -2468,36 +2578,28 @@ PtnSkeleton::~PtnSkeleton() {\n }\n \n PtnElem::PtnElem(const UnicodeString &basePat, const UnicodeString &pat) :\n-basePattern(basePat),\n-skeleton(NULL),\n-pattern(pat),\n-next(NULL)\n+    basePattern(basePat), skeleton(nullptr), pattern(pat), next(nullptr)\n {\n }\n \n PtnElem::~PtnElem() {\n-\n-    if (next!=NULL) {\n-        delete next;\n-    }\n-    delete skeleton;\n }\n \n-DTSkeletonEnumeration::DTSkeletonEnumeration(PatternMap &patternMap, dtStrEnum type, UErrorCode& status) {\n+DTSkeletonEnumeration::DTSkeletonEnumeration(PatternMap& patternMap, dtStrEnum type, UErrorCode& status) : fSkeletons(nullptr) {\n     PtnElem  *curElem;\n     PtnSkeleton *curSkeleton;\n     UnicodeString s;\n     int32_t bootIndex;\n \n     pos=0;\n-    fSkeletons = new UVector(status);\n+    fSkeletons.adoptInsteadAndCheckErrorCode(new UVector(status), status);\n     if (U_FAILURE(status)) {\n-        delete fSkeletons;\n         return;\n     }\n+\n     for (bootIndex=0; bootIndex<MAX_PATTERN_ENTRIES; ++bootIndex ) {\n         curElem = patternMap.boot[bootIndex];\n-        while (curElem!=NULL) {\n+        while (curElem!=nullptr) {\n             switch(type) {\n                 case DT_BASESKELETON:\n                     s=curElem->basePattern;\n@@ -2506,32 +2608,36 @@ DTSkeletonEnumeration::DTSkeletonEnumeration(PatternMap &patternMap, dtStrEnum t\n                     s=curElem->pattern;\n                     break;\n                 case DT_SKELETON:\n-                    curSkeleton=curElem->skeleton;\n+                    curSkeleton=curElem->skeleton.getAlias();\n                     s=curSkeleton->getSkeleton();\n                     break;\n             }\n             if ( !isCanonicalItem(s) ) {\n-                fSkeletons->addElement(new UnicodeString(s), status);\n+                LocalPointer<UnicodeString> newElem(new UnicodeString(s), status);\n                 if (U_FAILURE(status)) {\n-                    delete fSkeletons;\n-                    fSkeletons = NULL;\n                     return;\n                 }\n+                fSkeletons->addElement(newElem.getAlias(), status);\n+                if (U_FAILURE(status)) {\n+                    fSkeletons.adoptInstead(nullptr);\n+                    return;\n+                }\n+                newElem.orphan(); // fSkeletons vector now owns the UnicodeString.\n             }\n-            curElem = curElem->next;\n+            curElem = curElem->next.getAlias();\n         }\n     }\n-    if ((bootIndex==MAX_PATTERN_ENTRIES) && (curElem!=NULL) ) {\n+    if ((bootIndex==MAX_PATTERN_ENTRIES) && (curElem!=nullptr) ) {\n         status = U_BUFFER_OVERFLOW_ERROR;\n     }\n }\n \n const UnicodeString*\n DTSkeletonEnumeration::snext(UErrorCode& status) {\n-    if (U_SUCCESS(status) && pos < fSkeletons->size()) {\n+    if (U_SUCCESS(status) && fSkeletons.isValid() && pos < fSkeletons->size()) {\n         return (const UnicodeString*)fSkeletons->elementAt(pos++);\n     }\n-    return NULL;\n+    return nullptr;\n }\n \n void\n@@ -2541,7 +2647,7 @@ DTSkeletonEnumeration::reset(UErrorCode& /*status*/) {\n \n int32_t\n DTSkeletonEnumeration::count(UErrorCode& /*status*/) const {\n-   return (fSkeletons==NULL) ? 0 : fSkeletons->size();\n+   return (fSkeletons.isNull()) ? 0 : fSkeletons->size();\n }\n \n UBool\n@@ -2559,44 +2665,45 @@ DTSkeletonEnumeration::isCanonicalItem(const UnicodeString& item) {\n \n DTSkeletonEnumeration::~DTSkeletonEnumeration() {\n     UnicodeString *s;\n-    for (int32_t i=0; i<fSkeletons->size(); ++i) {\n-        if ((s=(UnicodeString *)fSkeletons->elementAt(i))!=NULL) {\n-            delete s;\n+    if (fSkeletons.isValid()) {\n+        for (int32_t i = 0; i < fSkeletons->size(); ++i) {\n+            if ((s = (UnicodeString *)fSkeletons->elementAt(i)) != nullptr) {\n+                delete s;\n+            }\n         }\n     }\n-    delete fSkeletons;\n }\n \n-DTRedundantEnumeration::DTRedundantEnumeration() {\n-    pos=0;\n-    fPatterns = NULL;\n+DTRedundantEnumeration::DTRedundantEnumeration() : pos(0), fPatterns(nullptr) {\n }\n \n void\n DTRedundantEnumeration::add(const UnicodeString& pattern, UErrorCode& status) {\n-    if (U_FAILURE(status)) return;\n-    if (fPatterns == NULL)  {\n-        fPatterns = new UVector(status);\n+    if (U_FAILURE(status)) { return; }\n+    if (fPatterns.isNull())  {\n+        fPatterns.adoptInsteadAndCheckErrorCode(new UVector(status), status);\n         if (U_FAILURE(status)) {\n-            delete fPatterns;\n-            fPatterns = NULL;\n             return;\n        }\n     }\n-    fPatterns->addElement(new UnicodeString(pattern), status);\n+    LocalPointer<UnicodeString> newElem(new UnicodeString(pattern), status);\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+    fPatterns->addElement(newElem.getAlias(), status);\n     if (U_FAILURE(status)) {\n-        delete fPatterns;\n-        fPatterns = NULL;\n+        fPatterns.adoptInstead(nullptr);\n         return;\n     }\n+    newElem.orphan(); // fPatterns now owns the string.\n }\n \n const UnicodeString*\n DTRedundantEnumeration::snext(UErrorCode& status) {\n-    if (U_SUCCESS(status) && pos < fPatterns->size()) {\n+    if (U_SUCCESS(status) && fPatterns.isValid() && pos < fPatterns->size()) {\n         return (const UnicodeString*)fPatterns->elementAt(pos++);\n     }\n-    return NULL;\n+    return nullptr;\n }\n \n void\n@@ -2606,11 +2713,11 @@ DTRedundantEnumeration::reset(UErrorCode& /*status*/) {\n \n int32_t\n DTRedundantEnumeration::count(UErrorCode& /*status*/) const {\n-       return (fPatterns==NULL) ? 0 : fPatterns->size();\n+    return (fPatterns.isNull()) ? 0 : fPatterns->size();\n }\n \n UBool\n-DTRedundantEnumeration::isCanonicalItem(const UnicodeString& item) {\n+DTRedundantEnumeration::isCanonicalItem(const UnicodeString& item) const {\n     if ( item.length() != 1 ) {\n         return FALSE;\n     }\n@@ -2624,12 +2731,13 @@ DTRedundantEnumeration::isCanonicalItem(const UnicodeString& item) {\n \n DTRedundantEnumeration::~DTRedundantEnumeration() {\n     UnicodeString *s;\n-    for (int32_t i=0; i<fPatterns->size(); ++i) {\n-        if ((s=(UnicodeString *)fPatterns->elementAt(i))!=NULL) {\n-            delete s;\n+    if (fPatterns.isValid()) {\n+        for (int32_t i = 0; i < fPatterns->size(); ++i) {\n+            if ((s = (UnicodeString *)fPatterns->elementAt(i)) != nullptr) {\n+                delete s;\n+            }\n         }\n     }\n-    delete fPatterns;\n }\n \n U_NAMESPACE_END"
        },
        {
            "sha": "95219f0ba257f51484158e98f699572ea88de2cc",
            "filename": "deps/icu-small/source/i18n/dtptngen_impl.h",
            "status": "modified",
            "additions": 22,
            "deletions": 24,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtptngen_impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtptngen_impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fdtptngen_impl.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -116,7 +116,7 @@ typedef struct dtTypeElem {\n     int16_t                type;\n     int16_t                minLen;\n     int16_t                weight;\n-}dtTypeElem;\n+} dtTypeElem;\n \n // A compact storage mechanism for skeleton field strings.  Several dozen of these will be created\n // for a typical DateTimePatternGenerator instance.\n@@ -172,30 +172,28 @@ class PtnSkeleton : public UMemory {\n     virtual ~PtnSkeleton();\n };\n \n-\n class PtnElem : public UMemory {\n public:\n     UnicodeString basePattern;\n-    PtnSkeleton   *skeleton;\n+    LocalPointer<PtnSkeleton> skeleton;\n     UnicodeString pattern;\n     UBool         skeletonWasSpecified; // if specified in availableFormats, not derived\n-    PtnElem       *next;\n+    LocalPointer<PtnElem> next;\n \n     PtnElem(const UnicodeString &basePattern, const UnicodeString &pattern);\n     virtual ~PtnElem();\n-\n };\n \n class FormatParser : public UMemory {\n public:\n     UnicodeString items[MAX_DT_TOKEN];\n-    int32_t  itemNumber;\n+    int32_t itemNumber;\n \n     FormatParser();\n     virtual ~FormatParser();\n     void set(const UnicodeString& patternString);\n     void getQuoteLiteral(UnicodeString& quote, int32_t *itemIndex);\n-    UBool isPatternSeparator(UnicodeString& field);\n+    UBool isPatternSeparator(const UnicodeString& field) const;\n     static UBool isQuoteLiteral(const UnicodeString& s);\n     static int32_t getCanonicalIndex(const UnicodeString& s) { return getCanonicalIndex(s, TRUE); }\n     static int32_t getCanonicalIndex(const UnicodeString& s, UBool strict);\n@@ -206,7 +204,7 @@ class FormatParser : public UMemory {\n        ADD_TOKEN,\n        SYNTAX_ERROR,\n        DONE\n-   } ToeknStatus;\n+   } TokenStatus;\n \n    TokenStatus status;\n    virtual TokenStatus setTokens(const UnicodeString& pattern, int32_t startPos, int32_t *len);\n@@ -220,7 +218,7 @@ class DistanceInfo : public UMemory {\n     DistanceInfo() {}\n     virtual ~DistanceInfo();\n     void clear() { missingFieldMask = extraFieldMask = 0; }\n-    void setTo(DistanceInfo& other);\n+    void setTo(const DistanceInfo& other);\n     void addMissing(int32_t field) { missingFieldMask |= (1<<field); }\n     void addExtra(int32_t field) { extraFieldMask |= (1<<field); }\n };\n@@ -237,11 +235,11 @@ class DateTimeMatcher: public UMemory {\n     void copyFrom();\n     PtnSkeleton* getSkeletonPtr();\n     UBool equals(const DateTimeMatcher* other) const;\n-    int32_t getDistance(const DateTimeMatcher& other, int32_t includeMask, DistanceInfo& distanceInfo);\n+    int32_t getDistance(const DateTimeMatcher& other, int32_t includeMask, DistanceInfo& distanceInfo) const;\n     DateTimeMatcher();\n     DateTimeMatcher(const DateTimeMatcher& other);\n     virtual ~DateTimeMatcher();\n-    int32_t getFieldMask();\n+    int32_t getFieldMask() const;\n };\n \n class PatternMap : public UMemory {\n@@ -250,34 +248,34 @@ class PatternMap : public UMemory {\n     PatternMap();\n     virtual  ~PatternMap();\n     void  add(const UnicodeString& basePattern, const PtnSkeleton& skeleton, const UnicodeString& value, UBool skeletonWasSpecified, UErrorCode& status);\n-    const UnicodeString* getPatternFromBasePattern(UnicodeString& basePattern, UBool& skeletonWasSpecified);\n-    const UnicodeString* getPatternFromSkeleton(PtnSkeleton& skeleton, const PtnSkeleton** specifiedSkeletonPtr = 0);\n+    const UnicodeString* getPatternFromBasePattern(const UnicodeString& basePattern, UBool& skeletonWasSpecified) const;\n+    const UnicodeString* getPatternFromSkeleton(const PtnSkeleton& skeleton, const PtnSkeleton** specifiedSkeletonPtr = 0) const;\n     void copyFrom(const PatternMap& other, UErrorCode& status);\n-    PtnElem* getHeader(UChar baseChar);\n-    UBool equals(const PatternMap& other);\n+    PtnElem* getHeader(UChar baseChar) const;\n+    UBool equals(const PatternMap& other) const;\n private:\n     UBool isDupAllowed;\n-    PtnElem*  getDuplicateElem(const UnicodeString &basePattern, const PtnSkeleton& skeleton, PtnElem *baseElem);\n+    PtnElem*  getDuplicateElem(const UnicodeString& basePattern, const PtnSkeleton& skeleton, PtnElem *baseElem);\n }; // end  PatternMap\n \n class PatternMapIterator : public UMemory {\n public:\n-    PatternMapIterator();\n+    PatternMapIterator(UErrorCode &status);\n     virtual ~PatternMapIterator();\n     void set(PatternMap& patternMap);\n-    PtnSkeleton* getSkeleton();\n-    UBool hasNext();\n+    PtnSkeleton* getSkeleton() const;\n+    UBool hasNext() const;\n     DateTimeMatcher& next();\n private:\n     int32_t bootIndex;\n     PtnElem *nodePtr;\n-    DateTimeMatcher *matcher;\n+    LocalPointer<DateTimeMatcher> matcher;\n     PatternMap *patternMap;\n };\n \n class DTSkeletonEnumeration : public StringEnumeration {\n public:\n-    DTSkeletonEnumeration(PatternMap &patternMap, dtStrEnum type, UErrorCode& status);\n+    DTSkeletonEnumeration(PatternMap& patternMap, dtStrEnum type, UErrorCode& status);\n     virtual ~DTSkeletonEnumeration();\n     static UClassID U_EXPORT2 getStaticClassID(void);\n     virtual UClassID getDynamicClassID(void) const;\n@@ -287,7 +285,7 @@ class DTSkeletonEnumeration : public StringEnumeration {\n private:\n     int32_t pos;\n     UBool isCanonicalItem(const UnicodeString& item);\n-    UVector *fSkeletons;\n+    LocalPointer<UVector> fSkeletons;\n };\n \n class DTRedundantEnumeration : public StringEnumeration {\n@@ -302,8 +300,8 @@ class DTRedundantEnumeration : public StringEnumeration {\n     void add(const UnicodeString &pattern, UErrorCode& status);\n private:\n     int32_t pos;\n-    UBool isCanonicalItem(const UnicodeString& item);\n-    UVector *fPatterns;\n+    UBool isCanonicalItem(const UnicodeString& item) const;\n+    LocalPointer<UVector> fPatterns;\n };\n \n U_NAMESPACE_END"
        },
        {
            "sha": "669f84423046fd3b061c9b11298d115deae07fd1",
            "filename": "deps/icu-small/source/i18n/erarules.cpp",
            "status": "added",
            "additions": 307,
            "deletions": 0,
            "changes": 307,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ferarules.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ferarules.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Ferarules.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,307 @@\n+// Â© 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+#include \"unicode/utypes.h\"\n+\n+#if !UCONFIG_NO_FORMATTING\n+\n+#include <stdlib.h>\n+#include \"unicode/ucal.h\"\n+#include \"unicode/ures.h\"\n+#include \"unicode/ustring.h\"\n+#include \"cmemory.h\"\n+#include \"cstring.h\"\n+#include \"erarules.h\"\n+#include \"gregoimp.h\"\n+#include \"uassert.h\"\n+\n+U_NAMESPACE_BEGIN\n+\n+static const int32_t MAX_ENCODED_START_YEAR = 32767;\n+static const int32_t MIN_ENCODED_START_YEAR = -32768;\n+static const int32_t MIN_ENCODED_START = -2147483391;   // encodeDate(MIN_ENCODED_START_YEAR, 1, 1, ...);\n+\n+static const int32_t YEAR_MASK = 0xFFFF0000;\n+static const int32_t MONTH_MASK = 0x0000FF00;\n+static const int32_t DAY_MASK = 0x000000FF;\n+\n+static const int32_t MAX_INT32 = 0x7FFFFFFF;\n+static const int32_t MIN_INT32 = 0xFFFFFFFF;\n+\n+static const UChar VAL_FALSE[] = {0x66, 0x61, 0x6c, 0x73, 0x65};    // \"false\"\n+static const UChar VAL_FALSE_LEN = 5;\n+\n+static UBool isSet(int startDate) {\n+    return startDate != 0;\n+}\n+\n+static UBool isValidRuleStartDate(int32_t year, int32_t month, int32_t day) {\n+    return year >= MIN_ENCODED_START_YEAR && year <= MAX_ENCODED_START_YEAR\n+            && month >= 1 && month <= 12 && day >=1 && day <= 31;\n+}\n+\n+/**\n+ * Encode year/month/date to a single integer.\n+ * year is high 16 bits (-32768 to 32767), month is\n+ * next 8 bits and day of month is last 8 bits.\n+ *\n+ * @param year  year\n+ * @param month month (1-base)\n+ * @param day   day of month\n+ * @return  an encoded date.\n+ */\n+static int32_t encodeDate(int32_t year, int32_t month, int32_t day) {\n+    return year << 16 | month << 8 | day;\n+}\n+\n+static void decodeDate(int32_t encodedDate, int32_t (&fields)[3]) {\n+    if (encodedDate == MIN_ENCODED_START) {\n+        fields[0] = MIN_INT32;\n+        fields[1] = 1;\n+        fields[2] = 1;\n+    } else {\n+        fields[0] = (encodedDate & YEAR_MASK) >> 16;\n+        fields[1] = (encodedDate & MONTH_MASK) >> 8;\n+        fields[2] = encodedDate & DAY_MASK;\n+    }\n+}\n+\n+/**\n+ * Compare an encoded date with another date specified by year/month/day.\n+ * @param encoded   An encoded date\n+ * @param year      Year of another date\n+ * @param month     Month of another date\n+ * @param day       Day of another date\n+ * @return -1 when encoded date is earlier, 0 when two dates are same,\n+ *          and 1 when encoded date is later.\n+ */\n+static int32_t compareEncodedDateWithYMD(int encoded, int year, int month, int day) {\n+    if (year < MIN_ENCODED_START_YEAR) {\n+        if (encoded == MIN_ENCODED_START) {\n+            if (year > MIN_INT32 || month > 1 || day > 1) {\n+                return -1;\n+            }\n+            return 0;\n+        } else {\n+            return 1;\n+        }\n+    } else if (year > MAX_ENCODED_START_YEAR) {\n+        return -1;\n+    } else {\n+        int tmp = encodeDate(year, month, day);\n+        if (encoded < tmp) {\n+            return -1;\n+        } else if (encoded == tmp) {\n+            return 0;\n+        } else {\n+            return 1;\n+        }\n+    }\n+}\n+\n+EraRules::EraRules(LocalMemory<int32_t>& eraStartDates, int32_t numEras)\n+    : numEras(numEras) {\n+    startDates.moveFrom(eraStartDates);\n+    initCurrentEra();\n+}\n+\n+EraRules::~EraRules() {\n+}\n+\n+EraRules* EraRules::createInstance(const char *calType, UBool includeTentativeEra, UErrorCode& status) {\n+    if(U_FAILURE(status)) {\n+        return nullptr;\n+    }\n+    LocalUResourceBundlePointer rb(ures_openDirect(nullptr, \"supplementalData\", &status));\n+    ures_getByKey(rb.getAlias(), \"calendarData\", rb.getAlias(), &status);\n+    ures_getByKey(rb.getAlias(), calType, rb.getAlias(), &status);\n+    ures_getByKey(rb.getAlias(), \"eras\", rb.getAlias(), &status);\n+\n+    if (U_FAILURE(status)) {\n+        return nullptr;\n+    }\n+\n+    int32_t numEras = ures_getSize(rb.getAlias());\n+    int32_t firstTentativeIdx = MAX_INT32;\n+\n+    LocalMemory<int32_t> startDates(static_cast<int32_t *>(uprv_malloc(numEras * sizeof(int32_t))));\n+    if (startDates.isNull()) {\n+        status = U_MEMORY_ALLOCATION_ERROR;\n+        return nullptr;\n+    }\n+    uprv_memset(startDates.getAlias(), 0 , numEras * sizeof(int32_t));\n+\n+    while (ures_hasNext(rb.getAlias())) {\n+        LocalUResourceBundlePointer eraRuleRes(ures_getNextResource(rb.getAlias(), nullptr, &status));\n+        if (U_FAILURE(status)) {\n+            return nullptr;\n+        }\n+        const char *eraIdxStr = ures_getKey(eraRuleRes.getAlias());\n+        char *endp;\n+        int32_t eraIdx = (int32_t)strtol(eraIdxStr, &endp, 10);\n+        if ((size_t)(endp - eraIdxStr) != uprv_strlen(eraIdxStr)) {\n+            status = U_INVALID_FORMAT_ERROR;\n+            return nullptr;\n+        }\n+        if (eraIdx < 0 || eraIdx >= numEras) {\n+            status = U_INVALID_FORMAT_ERROR;\n+            return nullptr;\n+        }\n+        if (isSet(startDates[eraIdx])) {\n+            // start date of the index was already set\n+            status = U_INVALID_FORMAT_ERROR;\n+            return nullptr;\n+        }\n+\n+        UBool hasName = TRUE;\n+        UBool hasEnd = TRUE;\n+        int32_t len;\n+        while (ures_hasNext(eraRuleRes.getAlias())) {\n+            LocalUResourceBundlePointer res(ures_getNextResource(eraRuleRes.getAlias(), nullptr, &status));\n+            if (U_FAILURE(status)) {\n+                return nullptr;\n+            }\n+            const char *key = ures_getKey(res.getAlias());\n+            if (uprv_strcmp(key, \"start\") == 0) {\n+                const int32_t *fields = ures_getIntVector(res.getAlias(), &len, &status);\n+                if (U_FAILURE(status)) {\n+                    return nullptr;\n+                }\n+                if (len != 3 || !isValidRuleStartDate(fields[0], fields[1], fields[2])) {\n+                    status = U_INVALID_FORMAT_ERROR;\n+                    return nullptr;\n+                }\n+                startDates[eraIdx] = encodeDate(fields[0], fields[1], fields[2]);\n+            } else if (uprv_strcmp(key, \"named\") == 0) {\n+                const UChar *val = ures_getString(res.getAlias(), &len, &status);\n+                if (u_strncmp(val, VAL_FALSE, VAL_FALSE_LEN) == 0) {\n+                    hasName = FALSE;\n+                }\n+            } else if (uprv_strcmp(key, \"end\") == 0) {\n+                hasEnd = TRUE;\n+            }\n+        }\n+\n+        if (isSet(startDates[eraIdx])) {\n+            if (hasEnd) {\n+                // This implementation assumes either start or end is available, not both.\n+                // For now, just ignore the end rule.\n+            }\n+        } else {\n+            if (hasEnd) {\n+                if (eraIdx != 0) {\n+                    // This implementation does not support end only rule for eras other than\n+                    // the first one.\n+                    status = U_INVALID_FORMAT_ERROR;\n+                    return nullptr;\n+                }\n+                U_ASSERT(eraIdx == 0);\n+                startDates[eraIdx] = MIN_ENCODED_START;\n+            } else {\n+                status = U_INVALID_FORMAT_ERROR;\n+                return nullptr;\n+            }\n+        }\n+\n+        if (hasName) {\n+            if (eraIdx >= firstTentativeIdx) {\n+                status = U_INVALID_FORMAT_ERROR;\n+                return nullptr;\n+            }\n+        } else {\n+            if (eraIdx < firstTentativeIdx) {\n+                firstTentativeIdx = eraIdx;\n+            }\n+        }\n+    }\n+\n+    EraRules *result;\n+    if (firstTentativeIdx < MAX_INT32 && !includeTentativeEra) {\n+        result = new EraRules(startDates, firstTentativeIdx);\n+    } else {\n+        result = new EraRules(startDates, numEras);\n+    }\n+\n+    if (result == nullptr) {\n+        status = U_MEMORY_ALLOCATION_ERROR;\n+    }\n+    return result;\n+}\n+\n+void EraRules::getStartDate(int32_t eraIdx, int32_t (&fields)[3], UErrorCode& status) const {\n+    if(U_FAILURE(status)) {\n+        return;\n+    }\n+    if (eraIdx < 0 || eraIdx >= numEras) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return;\n+    }\n+    decodeDate(startDates[eraIdx], fields);\n+}\n+\n+int32_t EraRules::getStartYear(int32_t eraIdx, UErrorCode& status) const {\n+    int year = MAX_INT32;   // bogus value\n+    if(U_FAILURE(status)) {\n+        return year;\n+    }\n+    if (eraIdx < 0 || eraIdx >= numEras) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return year;\n+    }\n+    int fields[3];\n+    decodeDate(startDates[eraIdx], fields);\n+    year = fields[0];\n+\n+    return year;\n+}\n+\n+int32_t EraRules::getEraIndex(int32_t year, int32_t month, int32_t day, UErrorCode& status) const {\n+    if(U_FAILURE(status)) {\n+        return -1;\n+    }\n+\n+    if (month < 1 || month > 12 || day < 1 || day > 31) {\n+        status = U_ILLEGAL_ARGUMENT_ERROR;\n+        return -1;\n+    }\n+    int32_t high = numEras; // last index + 1\n+    int32_t low;\n+\n+    // Short circuit for recent years.  Most modern computations will\n+    // occur in the last few eras.\n+    if (compareEncodedDateWithYMD(startDates[getCurrentEraIndex()], year, month, day) <= 0) {\n+        low = getCurrentEraIndex();\n+    } else {\n+        low = 0;\n+    }\n+\n+    // Do binary search\n+    while (low < high - 1) {\n+        int i = (low + high) / 2;\n+        if (compareEncodedDateWithYMD(startDates[i], year, month, day) <= 0) {\n+            low = i;\n+        } else {\n+            high = i;\n+        }\n+    }\n+    return low;\n+}\n+\n+void EraRules::initCurrentEra() {\n+    UDate now = ucal_getNow();\n+    int year, month0, dom, dow, doy, mid;\n+    Grego::timeToFields(now, year, month0, dom, dow, doy, mid);\n+    int currentEncodedDate = encodeDate(year, month0 + 1 /* changes to 1-base */, dom);\n+    int eraIdx = numEras - 1;\n+    while (eraIdx > 0) {\n+        if (currentEncodedDate >= startDates[eraIdx]) {\n+            break;\n+        }\n+        eraIdx--;\n+    }\n+    // Note: current era could be before the first era.\n+    // In this case, this implementation returns the first era index (0).\n+    currentEra = eraIdx;}\n+\n+U_NAMESPACE_END\n+#endif /* #if !UCONFIG_NO_FORMATTING */"
        },
        {
            "sha": "4ed86408325ed77b356947da4494623b5b37b66b",
            "filename": "deps/icu-small/source/i18n/erarules.h",
            "status": "added",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ferarules.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ferarules.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Ferarules.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -0,0 +1,92 @@\n+// Â© 2018 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+\n+#ifndef ERARULES_H_\n+#define ERARULES_H_\n+\n+#include \"unicode/utypes.h\"\n+\n+#if !UCONFIG_NO_FORMATTING\n+\n+#include \"unicode/localpointer.h\"\n+#include \"unicode/uobject.h\"\n+#include \"cmemory.h\"\n+\n+U_NAMESPACE_BEGIN\n+\n+// Export an explicit template instantiation of LocalMemory used as a data member of EraRules.\n+// When building DLLs for Windows this is required even though no direct access leaks out of the i18n library.\n+// See digitlst.h, pluralaffix.h, datefmt.h, and others for similar examples.\n+#if U_PF_WINDOWS <= U_PLATFORM && U_PLATFORM <= U_PF_CYGWIN\n+// Ignore warning 4661 as LocalPointerBase does not use operator== or operator!=\n+#pragma warning(suppress: 4661)\n+template class U_I18N_API LocalPointerBase<int32_t>;\n+template class U_I18N_API LocalMemory<int32_t>;\n+#endif\n+\n+class U_I18N_API EraRules : public UMemory {\n+public:\n+    ~EraRules();\n+\n+    static EraRules* createInstance(const char *calType, UBool includeTentativeEra, UErrorCode& status);\n+\n+    /**\n+     * Gets number of effective eras\n+     * @return  number of effective eras\n+     */\n+    inline int32_t getNumberOfEras() const {\n+        return numEras;\n+    }\n+\n+    /**\n+     * Gets start date of an era\n+     * @param eraIdx    Era index\n+     * @param fields    Receives date fields. The result includes values of year, month,\n+     *                  day of month in this order. When an era has no start date, the result\n+     *                  will be January 1st in year whose value is minimum integer.\n+     * @param status    Receives status.\n+     */\n+    void getStartDate(int32_t eraIdx, int32_t (&fields)[3], UErrorCode& status) const;\n+\n+    /**\n+     * Gets start year of an era\n+     * @param eraIdx    Era index\n+     * @param status    Receives status.\n+     * @return The first year of an era. When a era has no start date, minimum int32\n+     *          value is returned.\n+     */\n+    int32_t getStartYear(int32_t eraIdx, UErrorCode& status) const;\n+\n+    /**\n+     * Returns era index for the specified year/month/day.\n+     * @param year  Year\n+     * @param month Month (1-base)\n+     * @param day   Day of month\n+     * @param status    Receives status\n+     * @return  era index (or 0, when the specified date is before the first era)\n+     */\n+    int32_t getEraIndex(int32_t year, int32_t month, int32_t day, UErrorCode& status) const;\n+\n+    /**\n+     * Gets the current era index. This is calculated only once for an instance of\n+     * EraRules.\n+     *\n+     * @return era index of current era (or 0, when current date is before the first era)\n+     */\n+    inline int32_t getCurrentEraIndex() const {\n+        return currentEra;\n+    }\n+\n+private:\n+    EraRules(LocalMemory<int32_t>& eraStartDates, int32_t numEra);\n+\n+    void initCurrentEra();\n+\n+    LocalMemory<int32_t> startDates;\n+    int32_t numEras;\n+    int32_t currentEra;\n+};\n+\n+U_NAMESPACE_END\n+#endif /* #if !UCONFIG_NO_FORMATTING */\n+#endif /* ERARULES_H_ */"
        },
        {
            "sha": "a6827e01e98b4b69c17b4b3e6fcfe15c4499be99",
            "filename": "deps/icu-small/source/i18n/fphdlimp.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ffphdlimp.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ffphdlimp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Ffphdlimp.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -10,9 +10,10 @@\n #ifndef FPHDLIMP_H\n #define FPHDLIMP_H\n \n+#include \"unicode/utypes.h\"\n+\n #if !UCONFIG_NO_FORMATTING\n \n-#include \"unicode/utypes.h\"\n #include \"unicode/fieldpos.h\"\n #include \"unicode/fpositer.h\"\n "
        },
        {
            "sha": "4db66758df1f1f7dd13f744d3df00a2b17d580a5",
            "filename": "deps/icu-small/source/i18n/gregocal.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fgregocal.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fgregocal.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fgregocal.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -541,8 +541,8 @@ int32_t GregorianCalendar::handleComputeMonthStart(int32_t eyear, int32_t month,\n     }\n \n     UBool isLeap = eyear%4 == 0;\n-    int32_t y = eyear-1;\n-    int32_t julianDay = 365*y + ClockMath::floorDivide(y, 4) + (kJan1_1JulianDay - 3);\n+    int64_t y = (int64_t)eyear-1;\n+    int64_t julianDay = 365*y + ClockMath::floorDivide(y, (int64_t)4) + (kJan1_1JulianDay - 3);\n \n     nonConstThis->fIsGregorian = (eyear >= fGregorianCutoverYear);\n #if defined (U_DEBUG_CAL)\n@@ -572,7 +572,7 @@ int32_t GregorianCalendar::handleComputeMonthStart(int32_t eyear, int32_t month,\n         julianDay += isLeap?kLeapNumDays[month]:kNumDays[month];\n     }\n \n-    return julianDay;\n+    return static_cast<int32_t>(julianDay);\n }\n \n int32_t GregorianCalendar::handleGetMonthLength(int32_t extendedYear, int32_t month)  const"
        },
        {
            "sha": "eb3844f8523eebb32444ba6306ef08b0e94f2a16",
            "filename": "deps/icu-small/source/i18n/gregoimp.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fgregoimp.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fgregoimp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fgregoimp.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -299,8 +299,8 @@ inline int32_t Grego::millisToJulianDay(double millis) {\n }\n \n inline int32_t Grego::gregorianShift(int32_t eyear) {\n-  int32_t y = eyear-1;\n-  int32_t gregShift = ClockMath::floorDivide(y, 400) - ClockMath::floorDivide(y, 100) + 2;\n+  int64_t y = (int64_t)eyear-1;\n+  int32_t gregShift = static_cast<int32_t>(ClockMath::floorDivide(y, (int64_t)400) - ClockMath::floorDivide(y, (int64_t)100) + 2);\n   return gregShift;\n }\n "
        },
        {
            "sha": "667b6f2d7a32c53ce891f9aedf8ffb5b2062942b",
            "filename": "deps/icu-small/source/i18n/indiancal.cpp",
            "status": "modified",
            "additions": 33,
            "deletions": 72,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Findiancal.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Findiancal.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Findiancal.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -347,100 +347,61 @@ IndianCalendar::inDaylightTime(UErrorCode& status) const\n     return (UBool)(U_SUCCESS(status) ? (internalGet(UCAL_DST_OFFSET) != 0) : FALSE);\n }\n \n-// default century\n-const UDate     IndianCalendar::fgSystemDefaultCentury          = DBL_MIN;\n-const int32_t   IndianCalendar::fgSystemDefaultCenturyYear      = -1;\n \n-UDate           IndianCalendar::fgSystemDefaultCenturyStart     = DBL_MIN;\n-int32_t         IndianCalendar::fgSystemDefaultCenturyStartYear = -1;\n+/**\n+ * The system maintains a static default century start date and Year.  They are\n+ * initialized the first time they are used.  Once the system default century date\n+ * and year are set, they do not change.\n+ */\n+static UDate           gSystemDefaultCenturyStart       = DBL_MIN;\n+static int32_t         gSystemDefaultCenturyStartYear   = -1;\n+static icu::UInitOnce  gSystemDefaultCenturyInit        = U_INITONCE_INITIALIZER;\n \n \n UBool IndianCalendar::haveDefaultCentury() const\n {\n     return TRUE;\n }\n \n-UDate IndianCalendar::defaultCenturyStart() const\n+static void U_CALLCONV\n+initializeSystemDefaultCentury()\n {\n-    return internalGetDefaultCenturyStart();\n-}\n+    // initialize systemDefaultCentury and systemDefaultCenturyYear based\n+    // on the current time.  They'll be set to 80 years before\n+    // the current time.\n+    UErrorCode status = U_ZERO_ERROR;\n \n-int32_t IndianCalendar::defaultCenturyStartYear() const\n-{\n-    return internalGetDefaultCenturyStartYear();\n-}\n+    IndianCalendar calendar ( Locale ( \"@calendar=Indian\" ), status);\n+    if ( U_SUCCESS ( status ) ) {\n+        calendar.setTime ( Calendar::getNow(), status );\n+        calendar.add ( UCAL_YEAR, -80, status );\n \n-UDate\n-IndianCalendar::internalGetDefaultCenturyStart() const\n-{\n-    // lazy-evaluate systemDefaultCenturyStart\n-    UBool needsUpdate;\n-    {\n-        Mutex m;\n-        needsUpdate = (fgSystemDefaultCenturyStart == fgSystemDefaultCentury);\n-    }\n+        UDate    newStart = calendar.getTime ( status );\n+        int32_t  newYear  = calendar.get ( UCAL_YEAR, status );\n \n-    if (needsUpdate) {\n-        initializeSystemDefaultCentury();\n+        gSystemDefaultCenturyStart = newStart;\n+        gSystemDefaultCenturyStartYear = newYear;\n     }\n+    // We have no recourse upon failure.\n+}\n \n-    // use defaultCenturyStart unless it's the flag value;\n-    // then use systemDefaultCenturyStart\n \n-    return fgSystemDefaultCenturyStart;\n+UDate\n+IndianCalendar::defaultCenturyStart() const\n+{\n+    // lazy-evaluate systemDefaultCenturyStart\n+    umtx_initOnce(gSystemDefaultCenturyInit, &initializeSystemDefaultCentury);\n+    return gSystemDefaultCenturyStart;\n }\n \n int32_t\n-IndianCalendar::internalGetDefaultCenturyStartYear() const\n+IndianCalendar::defaultCenturyStartYear() const\n {\n     // lazy-evaluate systemDefaultCenturyStartYear\n-    UBool needsUpdate;\n-    {\n-        Mutex m;\n-\n-        needsUpdate = (fgSystemDefaultCenturyStart == fgSystemDefaultCentury);\n-    }\n-\n-    if (needsUpdate) {\n-        initializeSystemDefaultCentury();\n-    }\n-\n-    // use defaultCenturyStart unless it's the flag value;\n-    // then use systemDefaultCenturyStartYear\n-\n-    return    fgSystemDefaultCenturyStartYear;\n+    umtx_initOnce(gSystemDefaultCenturyInit, &initializeSystemDefaultCentury);\n+    return    gSystemDefaultCenturyStartYear;\n }\n \n-void\n-IndianCalendar::initializeSystemDefaultCentury()\n-{\n-    // initialize systemDefaultCentury and systemDefaultCenturyYear based\n-    // on the current time.  They'll be set to 80 years before\n-    // the current time.\n-    // No point in locking as it should be idempotent.\n-    if (fgSystemDefaultCenturyStart == fgSystemDefaultCentury) {\n-        UErrorCode status = U_ZERO_ERROR;\n-\n-        IndianCalendar calendar(Locale(\"@calendar=Indian\"),status);\n-        if (U_SUCCESS(status)) {\n-            calendar.setTime(Calendar::getNow(), status);\n-            calendar.add(UCAL_YEAR, -80, status);\n-\n-            UDate    newStart = calendar.getTime(status);\n-            int32_t  newYear  = calendar.get(UCAL_YEAR, status);\n-\n-            {\n-                Mutex m;\n-\n-                fgSystemDefaultCenturyStart = newStart;\n-                fgSystemDefaultCenturyStartYear = newYear;\n-            }\n-        }\n-\n-        // We have no recourse upon failure unless we want to propagate the failure\n-        // out.\n-    }\n-}\n \n UOBJECT_DEFINE_RTTI_IMPLEMENTATION(IndianCalendar)\n "
        },
        {
            "sha": "ffd4ae8b8a40cd97a610388feaff5cde18e4d068",
            "filename": "deps/icu-small/source/i18n/indiancal.h",
            "status": "modified",
            "additions": 3,
            "deletions": 46,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Findiancal.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Findiancal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Findiancal.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -68,7 +68,7 @@ U_NAMESPACE_BEGIN\n  */\n \n \n-class IndianCalendar : public Calendar {\n+class U_I18N_API IndianCalendar : public Calendar {\n public:\n   /**\n    * Useful constants for IndianCalendar.\n@@ -274,10 +274,10 @@ class IndianCalendar : public Calendar {\n    * @return   The class ID for all objects of this class.\n    * @internal\n    */\n-  U_I18N_API static UClassID U_EXPORT2 getStaticClassID(void);\n+  static UClassID U_EXPORT2 getStaticClassID(void);\n \n   /**\n-   * return the calendar type, \"buddhist\".\n+   * return the calendar type, \"indian\".\n    *\n    * @return calendar type\n    * @internal\n@@ -320,49 +320,6 @@ class IndianCalendar : public Calendar {\n    * @internal\n    */\n   virtual int32_t defaultCenturyStartYear() const;\n-\n- private: // default century stuff.\n-  /**\n-   * The system maintains a static default century start date.  This is initialized\n-   * the first time it is used.  Before then, it is set to SYSTEM_DEFAULT_CENTURY to\n-   * indicate an uninitialized state.  Once the system default century date and year\n-   * are set, they do not change.\n-   */\n-  static UDate         fgSystemDefaultCenturyStart;\n-\n-  /**\n-   * See documentation for systemDefaultCenturyStart.\n-   */\n-  static int32_t          fgSystemDefaultCenturyStartYear;\n-\n-  /**\n-   * Default value that indicates the defaultCenturyStartYear is unitialized\n-   */\n-  static const int32_t    fgSystemDefaultCenturyYear;\n-\n-  /**\n-   * start of default century, as a date\n-   */\n-  static const UDate        fgSystemDefaultCentury;\n-\n-  /**\n-   * Returns the beginning date of the 100-year window that dates\n-   * with 2-digit years are considered to fall within.\n-   */\n-  UDate         internalGetDefaultCenturyStart(void) const;\n-\n-  /**\n-   * Returns the first year of the 100-year window that dates with\n-   * 2-digit years are considered to fall within.\n-   */\n-  int32_t          internalGetDefaultCenturyStartYear(void) const;\n-\n-  /**\n-   * Initializes the 100-year window that dates with 2-digit years\n-   * are considered to fall within so that its start date is 80 years\n-   * before the current time.\n-   */\n-  static void  initializeSystemDefaultCentury(void);\n };\n \n U_NAMESPACE_END"
        },
        {
            "sha": "056781617d6d9d10cfea0008a470b1ca05573944",
            "filename": "deps/icu-small/source/i18n/japancal.cpp",
            "status": "modified",
            "additions": 112,
            "deletions": 354,
            "changes": 466,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fjapancal.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fjapancal.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fjapancal.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -16,286 +16,88 @@\n #include \"unicode/utypes.h\"\n \n #if !UCONFIG_NO_FORMATTING\n-\n+#if U_PLATFORM_HAS_WINUWP_API == 0\n+#include <stdlib.h> // getenv() is not available in UWP env\n+#endif\n #include \"cmemory.h\"\n+#include \"erarules.h\"\n #include \"japancal.h\"\n #include \"unicode/gregocal.h\"\n #include \"umutex.h\"\n #include \"uassert.h\"\n-\n-//#define U_DEBUG_JCAL\n-\n-#ifdef U_DEBUG_JCAL\n-#include <stdio.h>\n-#endif\n+#include \"ucln_in.h\"\n+#include \"cstring.h\"\n+\n+static icu::EraRules * gJapaneseEraRules = nullptr;\n+static icu::UInitOnce gJapaneseEraRulesInitOnce = U_INITONCE_INITIALIZER;\n+static int32_t gCurrentEra = 0;\n+\n+U_CDECL_BEGIN\n+static UBool japanese_calendar_cleanup(void) {\n+    if (gJapaneseEraRules) {\n+        delete gJapaneseEraRules;\n+        gJapaneseEraRules = nullptr;\n+    }\n+    gCurrentEra = 0;\n+    gJapaneseEraRulesInitOnce.reset();\n+    return TRUE;\n+}\n+U_CDECL_END\n \n U_NAMESPACE_BEGIN\n \n UOBJECT_DEFINE_RTTI_IMPLEMENTATION(JapaneseCalendar)\n \n-//  Gregorian date of each emperor's ascension\n-//  Years are AD, months are 1-based.\n-static const struct {\n-    int16_t year;\n-    int8_t  month;\n-    int8_t  day;\n-} kEraInfo[] =  {\n-    //  Year  Month Day\n-    {   645,    6, 19 },   // Taika   0\n-    {   650,    2, 15 },   // Hakuchi 1\n-    {   672,    1,  1 },   // Hakuho  2\n-    {   686,    7, 20 },   // Shucho  3\n-    {   701,    3, 21 },   // Taiho   4\n-    {   704,    5, 10 },   // Keiun   5\n-    {   708,    1, 11 },   // Wado    6\n-    {   715,    9,  2 },   // Reiki   7\n-    {   717,   11, 17 },   // Yoro    8\n-    {   724,    2,  4 },   // Jinki   9\n-    {   729,    8,  5 },   // Tempyo  10\n-    {   749,    4, 14 },   // Tempyo-kampo 11\n-    {   749,    7,  2 },   // Tempyo-shoho 12\n-    {   757,    8, 18 },   // Tempyo-hoji  13\n-    {   765,    1,  7 },   // Tempho-jingo 14\n-    {   767,    8, 16 },   // Jingo-keiun  15\n-    {   770,   10,  1 },   // Hoki         16\n-    {   781,    1,  1 },   // Ten-o        17\n-    {   782,    8, 19 },   // Enryaku      18\n-    {   806,    5, 18 },   // Daido        19\n-    {   810,    9, 19 },   // Konin        20\n-    {   824,    1,  5 },   // Tencho\n-    {   834,    1,  3 },   // Showa\n-    {   848,    6, 13 },   // Kajo\n-    {   851,    4, 28 },   // Ninju\n-    {   854,   11, 30 },   // Saiko\n-    {   857,    2, 21 },   // Tennan\n-    {   859,    4, 15 },   // Jogan\n-    {   877,    4, 16 },   // Genkei\n-    {   885,    2, 21 },   // Ninna\n-    {   889,    4, 27 },   // Kampyo       30\n-    {   898,    4, 26 },   // Shotai\n-    {   901,    7, 15 },   // Engi\n-    {   923,    4, 11 },   // Encho\n-    {   931,    4, 26 },   // Shohei\n-    {   938,    5, 22 },   // Tengyo\n-    {   947,    4, 22 },   // Tenryaku\n-    {   957,   10, 27 },   // Tentoku\n-    {   961,    2, 16 },   // Owa\n-    {   964,    7, 10 },   // Koho\n-    {   968,    8, 13 },   // Anna        40\n-    {   970,    3, 25 },   // Tenroku\n-    {   973,   12, 20 },   // Ten-en\n-    {   976,    7, 13 },   // Jogen\n-    {   978,   11, 29 },   // Tengen\n-    {   983,    4, 15 },   // Eikan\n-    {   985,    4, 27 },   // Kanna\n-    {   987,    4,  5 },   // Ei-en\n-    {   989,    8,  8 },   // Eiso\n-    {   990,   11,  7 },   // Shoryaku\n-    {   995,    2, 22 },   // Chotoku      50\n-    {   999,    1, 13 },   // Choho\n-    {  1004,    7, 20 },   // Kanko\n-    {  1012,   12, 25 },   // Chowa\n-    {  1017,    4, 23 },   // Kannin\n-    {  1021,    2,  2 },   // Jian\n-    {  1024,    7, 13 },   // Manju\n-    {  1028,    7, 25 },   // Chogen\n-    {  1037,    4, 21 },   // Choryaku\n-    {  1040,   11, 10 },   // Chokyu\n-    {  1044,   11, 24 },   // Kantoku      60\n-    {  1046,    4, 14 },   // Eisho\n-    {  1053,    1, 11 },   // Tengi\n-    {  1058,    8, 29 },   // Kohei\n-    {  1065,    8,  2 },   // Jiryaku\n-    {  1069,    4, 13 },   // Enkyu\n-    {  1074,    8, 23 },   // Shoho\n-    {  1077,   11, 17 },   // Shoryaku\n-    {  1081,    2, 10 },   // Eiho\n-    {  1084,    2,  7 },   // Otoku\n-    {  1087,    4,  7 },   // Kanji       70\n-    {  1094,   12, 15 },   // Kaho\n-    {  1096,   12, 17 },   // Eicho\n-    {  1097,   11, 21 },   // Shotoku\n-    {  1099,    8, 28 },   // Kowa\n-    {  1104,    2, 10 },   // Choji\n-    {  1106,    4,  9 },   // Kasho\n-    {  1108,    8,  3 },   // Tennin\n-    {  1110,    7, 13 },   // Ten-ei\n-    {  1113,    7, 13 },   // Eikyu\n-    {  1118,    4,  3 },   // Gen-ei      80\n-    {  1120,    4, 10 },   // Hoan\n-    {  1124,    4,  3 },   // Tenji\n-    {  1126,    1, 22 },   // Daiji\n-    {  1131,    1, 29 },   // Tensho\n-    {  1132,    8, 11 },   // Chosho\n-    {  1135,    4, 27 },   // Hoen\n-    {  1141,    7, 10 },   // Eiji\n-    {  1142,    4, 28 },   // Koji\n-    {  1144,    2, 23 },   // Tenyo\n-    {  1145,    7, 22 },   // Kyuan      90\n-    {  1151,    1, 26 },   // Ninpei\n-    {  1154,   10, 28 },   // Kyuju\n-    {  1156,    4, 27 },   // Hogen\n-    {  1159,    4, 20 },   // Heiji\n-    {  1160,    1, 10 },   // Eiryaku\n-    {  1161,    9,  4 },   // Oho\n-    {  1163,    3, 29 },   // Chokan\n-    {  1165,    6,  5 },   // Eiman\n-    {  1166,    8, 27 },   // Nin-an\n-    {  1169,    4,  8 },   // Kao       100\n-    {  1171,    4, 21 },   // Shoan\n-    {  1175,    7, 28 },   // Angen\n-    {  1177,    8,  4 },   // Jisho\n-    {  1181,    7, 14 },   // Yowa\n-    {  1182,    5, 27 },   // Juei\n-    {  1184,    4, 16 },   // Genryuku\n-    {  1185,    8, 14 },   // Bunji\n-    {  1190,    4, 11 },   // Kenkyu\n-    {  1199,    4, 27 },   // Shoji\n-    {  1201,    2, 13 },   // Kennin     110\n-    {  1204,    2, 20 },   // Genkyu\n-    {  1206,    4, 27 },   // Ken-ei\n-    {  1207,   10, 25 },   // Shogen\n-    {  1211,    3,  9 },   // Kenryaku\n-    {  1213,   12,  6 },   // Kenpo\n-    {  1219,    4, 12 },   // Shokyu\n-    {  1222,    4, 13 },   // Joo\n-    {  1224,   11, 20 },   // Gennin\n-    {  1225,    4, 20 },   // Karoku\n-    {  1227,   12, 10 },   // Antei      120\n-    {  1229,    3,  5 },   // Kanki\n-    {  1232,    4,  2 },   // Joei\n-    {  1233,    4, 15 },   // Tempuku\n-    {  1234,   11,  5 },   // Bunryaku\n-    {  1235,    9, 19 },   // Katei\n-    {  1238,   11, 23 },   // Ryakunin\n-    {  1239,    2,  7 },   // En-o\n-    {  1240,    7, 16 },   // Ninji\n-    {  1243,    2, 26 },   // Kangen\n-    {  1247,    2, 28 },   // Hoji      130\n-    {  1249,    3, 18 },   // Kencho\n-    {  1256,   10,  5 },   // Kogen\n-    {  1257,    3, 14 },   // Shoka\n-    {  1259,    3, 26 },   // Shogen\n-    {  1260,    4, 13 },   // Bun-o\n-    {  1261,    2, 20 },   // Kocho\n-    {  1264,    2, 28 },   // Bun-ei\n-    {  1275,    4, 25 },   // Kenji\n-    {  1278,    2, 29 },   // Koan\n-    {  1288,    4, 28 },   // Shoo      140\n-    {  1293,    8, 55 },   // Einin\n-    {  1299,    4, 25 },   // Shoan\n-    {  1302,   11, 21 },   // Kengen\n-    {  1303,    8,  5 },   // Kagen\n-    {  1306,   12, 14 },   // Tokuji\n-    {  1308,   10,  9 },   // Enkei\n-    {  1311,    4, 28 },   // Ocho\n-    {  1312,    3, 20 },   // Showa\n-    {  1317,    2,  3 },   // Bunpo\n-    {  1319,    4, 28 },   // Geno      150\n-    {  1321,    2, 23 },   // Genkyo\n-    {  1324,   12,  9 },   // Shochu\n-    {  1326,    4, 26 },   // Kareki\n-    {  1329,    8, 29 },   // Gentoku\n-    {  1331,    8,  9 },   // Genko\n-    {  1334,    1, 29 },   // Kemmu\n-    {  1336,    2, 29 },   // Engen\n-    {  1340,    4, 28 },   // Kokoku\n-    {  1346,   12,  8 },   // Shohei\n-    {  1370,    7, 24 },   // Kentoku       160\n-    {  1372,    4,  1 },   // Bunch\\u0169\n-    {  1375,    5, 27 },   // Tenju\n-    {  1379,    3, 22 },   // Koryaku\n-    {  1381,    2, 10 },   // Kowa\n-    {  1384,    4, 28 },   // Gench\\u0169\n-    {  1384,    2, 27 },   // Meitoku\n-    {  1387,    8, 23 },   // Kakei\n-    {  1389,    2,  9 },   // Koo\n-    {  1390,    3, 26 },   // Meitoku\n-    {  1394,    7,  5 },   // Oei           170\n-    {  1428,    4, 27 },   // Shocho\n-    {  1429,    9,  5 },   // Eikyo\n-    {  1441,    2, 17 },   // Kakitsu\n-    {  1444,    2,  5 },   // Bun-an\n-    {  1449,    7, 28 },   // Hotoku\n-    {  1452,    7, 25 },   // Kyotoku\n-    {  1455,    7, 25 },   // Kosho\n-    {  1457,    9, 28 },   // Choroku\n-    {  1460,   12, 21 },   // Kansho\n-    {  1466,    2, 28 },   // Bunsho        180\n-    {  1467,    3,  3 },   // Onin\n-    {  1469,    4, 28 },   // Bunmei\n-    {  1487,    7, 29 },   // Chokyo\n-    {  1489,    8, 21 },   // Entoku\n-    {  1492,    7, 19 },   // Meio\n-    {  1501,    2, 29 },   // Bunki\n-    {  1504,    2, 30 },   // Eisho\n-    {  1521,    8, 23 },   // Taiei\n-    {  1528,    8, 20 },   // Kyoroku\n-    {  1532,    7, 29 },   // Tenmon       190\n-    {  1555,   10, 23 },   // Koji\n-    {  1558,    2, 28 },   // Eiroku\n-    {  1570,    4, 23 },   // Genki\n-    {  1573,    7, 28 },   // Tensho\n-    {  1592,   12,  8 },   // Bunroku\n-    {  1596,   10, 27 },   // Keicho\n-    {  1615,    7, 13 },   // Genwa\n-    {  1624,    2, 30 },   // Kan-ei\n-    {  1644,   12, 16 },   // Shoho\n-    {  1648,    2, 15 },   // Keian       200\n-    {  1652,    9, 18 },   // Shoo\n-    {  1655,    4, 13 },   // Meiryaku\n-    {  1658,    7, 23 },   // Manji\n-    {  1661,    4, 25 },   // Kanbun\n-    {  1673,    9, 21 },   // Enpo\n-    {  1681,    9, 29 },   // Tenwa\n-    {  1684,    2, 21 },   // Jokyo\n-    {  1688,    9, 30 },   // Genroku\n-    {  1704,    3, 13 },   // Hoei\n-    {  1711,    4, 25 },   // Shotoku      210\n-    {  1716,    6, 22 },   // Kyoho\n-    {  1736,    4, 28 },   // Genbun\n-    {  1741,    2, 27 },   // Kanpo\n-    {  1744,    2, 21 },   // Enkyo\n-    {  1748,    7, 12 },   // Kan-en\n-    {  1751,   10, 27 },   // Horyaku\n-    {  1764,    6,  2 },   // Meiwa\n-    {  1772,   11, 16 },   // An-ei\n-    {  1781,    4,  2 },   // Tenmei\n-    {  1789,    1, 25 },   // Kansei      220\n-    {  1801,    2,  5 },   // Kyowa\n-    {  1804,    2, 11 },   // Bunka\n-    {  1818,    4, 22 },   // Bunsei\n-    {  1830,   12, 10 },   // Tenpo\n-    {  1844,   12,  2 },   // Koka\n-    {  1848,    2, 28 },   // Kaei\n-    {  1854,   11, 27 },   // Ansei\n-    {  1860,    3, 18 },   // Man-en\n-    {  1861,    2, 19 },   // Bunkyu\n-    {  1864,    2, 20 },   // Genji        230\n-    {  1865,    4,  7 },   // Keio     231\n-    {  1868,    9,  8 },   // Meiji    232\n-    {  1912,    7, 30 },   // Taisho   233\n-    {  1926,   12, 25 },   // Showa    234\n-    {  1989,    1,  8 }   // Heisei    235\n-};\n-\n-#define kEraCount UPRV_LENGTHOF(kEraInfo)\n-\n-/**\n- * The current era, for reference.\n- */\n-static const int32_t kCurrentEra = (kEraCount-1);  // int32_t to match the calendar field type\n-\n static const int32_t kGregorianEpoch = 1970;    // used as the default value of EXTENDED_YEAR\n+static const char* TENTATIVE_ERA_VAR_NAME = \"ICU_ENABLE_TENTATIVE_ERA\";\n+\n+// Initialize global Japanese era data\n+static void U_CALLCONV initializeEras(UErrorCode &status) {\n+    // Although start date of next Japanese era is planned ahead, a name of\n+    // new era might not be available. This implementation allows tester to\n+    // check a new era without era names by settings below (in priority order).\n+    // By default, such tentative era is disabled.\n+\n+    // 1. Environment variable ICU_ENABLE_TENTATIVE_ERA=true or false\n+\n+    UBool includeTentativeEra = FALSE;\n+\n+#if U_PLATFORM_HAS_WINUWP_API == 1\n+    // UWP doesn't allow access to getenv(), but we can call GetEnvironmentVariableW to do the same thing.\n+    UChar varName[26] = {};\n+    u_charsToUChars(TENTATIVE_ERA_VAR_NAME, varName, static_cast<int32_t>(uprv_strlen(TENTATIVE_ERA_VAR_NAME)));\n+    WCHAR varValue[5] = {};\n+    DWORD ret = GetEnvironmentVariableW(reinterpret_cast<WCHAR*>(varName), varValue, UPRV_LENGTHOF(varValue));\n+    if ((ret == 4) && (_wcsicmp(varValue, L\"true\") == 0)) {\n+        includeTentativeEra = TRUE;\n+    }\n+#else\n+    char *envVarVal = getenv(TENTATIVE_ERA_VAR_NAME);\n+    if (envVarVal != NULL && uprv_stricmp(envVarVal, \"true\") == 0) {\n+        includeTentativeEra = TRUE;\n+    }\n+#endif\n+    gJapaneseEraRules = EraRules::createInstance(\"japanese\", includeTentativeEra, status);\n+    if (U_FAILURE(status)) {\n+        return;\n+    }\n+    gCurrentEra = gJapaneseEraRules->getCurrentEraIndex();\n+}\n+\n+static void init(UErrorCode &status) {\n+    umtx_initOnce(gJapaneseEraRulesInitOnce, &initializeEras, status);\n+    ucln_i18n_registerCleanup(UCLN_I18N_JAPANESE_CALENDAR, japanese_calendar_cleanup);\n+}\n \n /* Some platforms don't like to export constants, like old Palm OS and some z/OS configurations. */\n uint32_t JapaneseCalendar::getCurrentEra() {\n-    return kCurrentEra;\n+    return gCurrentEra;\n }\n \n JapaneseCalendar::JapaneseCalendar(const Locale& aLocale, UErrorCode& success)\n :   GregorianCalendar(aLocale, success)\n {\n+    init(success);\n     setTimeInMillis(getNow(), success); // Call this again now that the vtable is set up properly.\n }\n \n@@ -306,6 +108,9 @@ JapaneseCalendar::~JapaneseCalendar()\n JapaneseCalendar::JapaneseCalendar(const JapaneseCalendar& source)\n : GregorianCalendar(source)\n {\n+    UErrorCode status = U_ZERO_ERROR;\n+    init(status);\n+    U_ASSERT(U_SUCCESS(status));\n }\n \n JapaneseCalendar& JapaneseCalendar::operator= ( const JapaneseCalendar& right)\n@@ -332,10 +137,14 @@ int32_t JapaneseCalendar::getDefaultMonthInYear(int32_t eyear)\n     int32_t month = 0;\n \n     // Find out if we are at the edge of an era\n-\n-    if(eyear == kEraInfo[era].year) {\n+    int32_t eraStart[3] = { 0,0,0 };\n+    UErrorCode status = U_ZERO_ERROR;\n+    gJapaneseEraRules->getStartDate(era, eraStart, status);\n+    U_ASSERT(U_SUCCESS(status));\n+    if(eyear == eraStart[0]) {\n         // Yes, we're in the first year of this era.\n-        return kEraInfo[era].month-1;\n+        return eraStart[1]  // month\n+                -1;         // return 0-based month\n     }\n \n     return month;\n@@ -346,9 +155,13 @@ int32_t JapaneseCalendar::getDefaultDayInMonth(int32_t eyear, int32_t month)\n     int32_t era = internalGetEra();\n     int32_t day = 1;\n \n-    if(eyear == kEraInfo[era].year) {\n-        if(month == (kEraInfo[era].month-1)) {\n-            return kEraInfo[era].day;\n+    int32_t eraStart[3] = { 0,0,0 };\n+    UErrorCode status = U_ZERO_ERROR;\n+    gJapaneseEraRules->getStartDate(era, eraStart, status);\n+    U_ASSERT(U_SUCCESS(status));\n+    if(eyear == eraStart[0]) {\n+        if(month == eraStart[1] - 1) {\n+            return eraStart[2];\n         }\n     }\n \n@@ -358,7 +171,7 @@ int32_t JapaneseCalendar::getDefaultDayInMonth(int32_t eyear, int32_t month)\n \n int32_t JapaneseCalendar::internalGetEra() const\n {\n-    return internalGet(UCAL_ERA, kCurrentEra);\n+    return internalGet(UCAL_ERA, gCurrentEra);\n }\n \n int32_t JapaneseCalendar::handleGetExtendedYear()\n@@ -369,12 +182,18 @@ int32_t JapaneseCalendar::handleGetExtendedYear()\n \n     if (newerField(UCAL_EXTENDED_YEAR, UCAL_YEAR) == UCAL_EXTENDED_YEAR &&\n         newerField(UCAL_EXTENDED_YEAR, UCAL_ERA) == UCAL_EXTENDED_YEAR) {\n-            year = internalGet(UCAL_EXTENDED_YEAR, kGregorianEpoch);\n-        } else {\n-            // Subtract one because year starts at 1\n-            year = internalGet(UCAL_YEAR) + kEraInfo[internalGetEra()].year - 1;\n-        }\n-        return year;\n+        year = internalGet(UCAL_EXTENDED_YEAR, kGregorianEpoch);\n+    } else {\n+        UErrorCode status = U_ZERO_ERROR;\n+        int32_t eraStartYear = gJapaneseEraRules->getStartYear(internalGet(UCAL_ERA, gCurrentEra), status);\n+        U_ASSERT(U_SUCCESS(status));\n+\n+        // extended year is a gregorian year, where 1 = 1AD,  0 = 1BC, -1 = 2BC, etc\n+        year = internalGet(UCAL_YEAR, 1)    // pin to minimum of year 1 (first year)\n+            + eraStartYear                  // add gregorian starting year\n+            - 1;                            // Subtract one because year starts at 1\n+    }\n+    return year;\n }\n \n \n@@ -383,79 +202,10 @@ void JapaneseCalendar::handleComputeFields(int32_t julianDay, UErrorCode& status\n     //Calendar::timeToFields(theTime, quick, status);\n     GregorianCalendar::handleComputeFields(julianDay, status);\n     int32_t year = internalGet(UCAL_EXTENDED_YEAR); // Gregorian year\n+    int32_t eraIdx = gJapaneseEraRules->getEraIndex(year, internalGet(UCAL_MONTH) + 1, internalGet(UCAL_DAY_OF_MONTH), status);\n \n-    int32_t low = 0;\n-\n-    // Short circuit for recent years.  Most modern computations will\n-    // occur in the current era and won't require the binary search.\n-    // Note that if the year is == the current era year, then we use\n-    // the binary search to handle the month/dom comparison.\n-#ifdef U_DEBUG_JCAL\n-    fprintf(stderr, \"==  %d \\n\", year);\n-#endif\n-\n-    if (year > kEraInfo[kCurrentEra].year) {\n-        low = kCurrentEra;\n-#ifdef U_DEBUG_JCAL\n-        fprintf(stderr, \" low=%d (special)\\n\", low);\n-#endif\n-    } else {\n-        // Binary search\n-        int32_t high = kEraCount;\n-\n-#ifdef U_DEBUG_JCAL\n-        fprintf(stderr, \" high=%d\\n\", high);\n-#endif\n-        while (low < high - 1) {\n-            int32_t i = (low + high) / 2;\n-            int32_t diff = year - kEraInfo[i].year;\n-\n-#ifdef U_DEBUG_JCAL\n-            fprintf(stderr, \"  d=%d   low=%d, high=%d. Considering %d:M%d D%d Y%d. { we are ?:M%d D%d Y%d }\\n\",\n-                diff,low, high, i, kEraInfo[i].month-1, kEraInfo[i].day,  kEraInfo[i].year, internalGet(UCAL_MONTH), internalGet(UCAL_DATE),year);\n-#endif\n-\n-            // If years are the same, then compare the months, and if those\n-            // are the same, compare days of month.  In the ERAS array\n-            // months are 1-based for easier maintenance.\n-            if (diff == 0) {\n-                diff = internalGet(UCAL_MONTH) - (kEraInfo[i].month - 1);\n-#ifdef U_DEBUG_JCAL\n-                fprintf(stderr, \"diff now %d (M)  = %d - %d - 1\\n\", diff, internalGet(UCAL_MONTH), kEraInfo[i].month);\n-#endif\n-                if (diff == 0) {\n-                    diff = internalGet(UCAL_DATE) - kEraInfo[i].day;\n-#ifdef U_DEBUG_JCAL\n-                    fprintf(stderr, \"diff now %d (D)\\n\", diff);\n-#endif\n-                }\n-            }\n-            if (diff >= 0) {\n-                low = i;\n-            } else {\n-                high = i;\n-            }\n-#ifdef U_DEBUG_JCAL\n-            fprintf(stderr, \". low=%d, high=%d, i=%d, diff=%d.. %d\\n\", low, high, i, diff, year);\n-#endif\n-\n-        }\n-    }\n-\n-#ifdef U_DEBUG_JCAL\n-    fprintf(stderr, \"  low[era]=%d,.. %d\\n\", low, year);\n-#endif\n-    // Now we've found the last era that starts before this date, so\n-    // adjust the year to count from the start of that era.  Note that\n-    // all dates before the first era will fall into the first era by\n-    // the algorithm.\n-\n-    internalSet(UCAL_ERA, low);\n-    internalSet(UCAL_YEAR, year - kEraInfo[low].year + 1);\n-#ifdef U_DEBUG_JCAL\n-    fprintf(stderr, \"  Set ERA=%d, year=%d\\n\", low, year-kEraInfo[low].year+1);\n-#endif\n-\n+    internalSet(UCAL_ERA, eraIdx);\n+    internalSet(UCAL_YEAR, year - gJapaneseEraRules->getStartYear(eraIdx, status) + 1);\n }\n \n /*\n@@ -483,7 +233,7 @@ int32_t JapaneseCalendar::handleGetLimit(UCalendarDateFields field, ELimitType l\n         if (limitType == UCAL_LIMIT_MINIMUM || limitType == UCAL_LIMIT_GREATEST_MINIMUM) {\n             return 0;\n         }\n-        return kCurrentEra;\n+        return gCurrentEra;\n     case UCAL_YEAR:\n         {\n             switch (limitType) {\n@@ -494,7 +244,12 @@ int32_t JapaneseCalendar::handleGetLimit(UCalendarDateFields field, ELimitType l\n                 return 1;\n             case  UCAL_LIMIT_COUNT: //added to avoid warning\n             case UCAL_LIMIT_MAXIMUM:\n-                return GregorianCalendar::handleGetLimit(UCAL_YEAR, UCAL_LIMIT_MAXIMUM) - kEraInfo[kCurrentEra].year;\n+            {\n+                UErrorCode status = U_ZERO_ERROR;\n+                int32_t eraStartYear = gJapaneseEraRules->getStartYear(gCurrentEra, status);\n+                U_ASSERT(U_SUCCESS(status));\n+                return GregorianCalendar::handleGetLimit(UCAL_YEAR, UCAL_LIMIT_MAXIMUM) - eraStartYear;\n+            }\n             default:\n                 return 1;    // Error condition, invalid limitType\n             }\n@@ -510,15 +265,18 @@ int32_t JapaneseCalendar::getActualMaximum(UCalendarDateFields field, UErrorCode\n         if (U_FAILURE(status)) {\n             return 0; // error case... any value\n         }\n-        if (era == kCurrentEra) {\n+        if (era == gCurrentEra) {\n             // TODO: Investigate what value should be used here - revisit after 4.0.\n             return handleGetLimit(UCAL_YEAR, UCAL_LIMIT_MAXIMUM);\n         } else {\n-            int32_t nextEraYear = kEraInfo[era + 1].year;\n-            int32_t nextEraMonth = kEraInfo[era + 1].month;\n-            int32_t nextEraDate = kEraInfo[era + 1].day;\n-\n-            int32_t maxYear = nextEraYear - kEraInfo[era].year + 1; // 1-base\n+            int32_t nextEraStart[3] = { 0,0,0 };\n+            gJapaneseEraRules->getStartDate(era + 1, nextEraStart, status);\n+            int32_t nextEraYear = nextEraStart[0];\n+            int32_t nextEraMonth = nextEraStart[1]; // 1-base\n+            int32_t nextEraDate = nextEraStart[2];\n+\n+            int32_t eraStartYear = gJapaneseEraRules->getStartYear(era, status);\n+            int32_t maxYear = nextEraYear - eraStartYear + 1;   // 1-base\n             if (nextEraMonth == 1 && nextEraDate == 1) {\n                 // Subtract 1, because the next era starts at Jan 1\n                 maxYear--;"
        },
        {
            "sha": "67d2d7031526a240a4f7eddc310d11cbd3c7ed0c",
            "filename": "deps/icu-small/source/i18n/japancal.h",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fjapancal.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fjapancal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fjapancal.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -49,10 +49,18 @@ U_NAMESPACE_BEGIN\n  * July 30, 1912 (Taisho), December 25, 1926 (Showa), and January 7, 1989 (Heisei).  Constants\n  * for these eras, suitable for use in the <code>UCAL_ERA</code> field, are provided\n  * in this class.  Note that the <em>number</em> used for each era is more or\n- * less arbitrary.  Currently, the era starting in 1053 AD is era #0; however this\n- * may change in the future as we add more historical data.  Use the predefined\n- * constants rather than using actual, absolute numbers.\n+ * less arbitrary.  Currently, the era starting in 645 AD is era #0; however this\n+ * may change in the future.  Use the predefined constants rather than using actual,\n+ * absolute numbers.\n  * <p>\n+ * Since ICU4C 63, start date of each era is imported from CLDR. CLDR era data\n+ * may contain tentative era in near future with placeholder names. By default,\n+ * such era data is not enabled. ICU4C users who want to test the behavior of\n+ * the future era can enable this one of following settings (in the priority\n+ * order):\n+ * <ol>\n+ * <li>Environment variable <code>ICU_ENABLE_TENTATIVE_ERA=true</code>.</li>\n+ * </nl>\n  * @internal\n  */\n class JapaneseCalendar : public GregorianCalendar {"
        },
        {
            "sha": "d9195348529c577cdca9cd3df61cfd6a8b84210c",
            "filename": "deps/icu-small/source/i18n/listformatter.cpp",
            "status": "renamed",
            "additions": 125,
            "deletions": 29,
            "changes": 154,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Flistformatter.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Flistformatter.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Flistformatter.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -16,14 +16,19 @@\n *   created by: Umesh P. Nair\n */\n \n+#include \"cmemory.h\"\n+#include \"unicode/fpositer.h\"  // FieldPositionIterator\n #include \"unicode/listformatter.h\"\n #include \"unicode/simpleformatter.h\"\n+#include \"unicode/ulistformatter.h\"\n+#include \"fphdlimp.h\"\n #include \"mutex.h\"\n #include \"hash.h\"\n #include \"cstring.h\"\n+#include \"uarrsort.h\"\n #include \"ulocimp.h\"\n #include \"charstr.h\"\n-#include \"ucln_cmn.h\"\n+#include \"ucln_in.h\"\n #include \"uresimp.h\"\n #include \"resource.h\"\n \n@@ -61,14 +66,14 @@ ListFormatInternal(const ListFormatInternal &other) :\n \n \n \n-static Hashtable* listPatternHash = NULL;\n+static Hashtable* listPatternHash = nullptr;\n static UMutex listFormatterMutex = U_MUTEX_INITIALIZER;\n static const char STANDARD_STYLE[] = \"standard\";\n \n U_CDECL_BEGIN\n static UBool U_CALLCONV uprv_listformatter_cleanup() {\n     delete listPatternHash;\n-    listPatternHash = NULL;\n+    listPatternHash = nullptr;\n     return TRUE;\n }\n \n@@ -81,7 +86,7 @@ U_CDECL_END\n \n ListFormatter::ListFormatter(const ListFormatter& other) :\n         owned(other.owned), data(other.data) {\n-    if (other.owned != NULL) {\n+    if (other.owned != nullptr) {\n         owned = new ListFormatInternal(*other.owned);\n         data = owned;\n     }\n@@ -96,7 +101,7 @@ ListFormatter& ListFormatter::operator=(const ListFormatter& other) {\n         owned = new ListFormatInternal(*other.owned);\n         data = owned;\n     } else {\n-        owned = NULL;\n+        owned = nullptr;\n         data = other.data;\n     }\n     return *this;\n@@ -108,53 +113,53 @@ void ListFormatter::initializeHash(UErrorCode& errorCode) {\n     }\n \n     listPatternHash = new Hashtable();\n-    if (listPatternHash == NULL) {\n+    if (listPatternHash == nullptr) {\n         errorCode = U_MEMORY_ALLOCATION_ERROR;\n         return;\n     }\n \n     listPatternHash->setValueDeleter(uprv_deleteListFormatInternal);\n-    ucln_common_registerCleanup(UCLN_COMMON_LIST_FORMATTER, uprv_listformatter_cleanup);\n+    ucln_i18n_registerCleanup(UCLN_I18N_LIST_FORMATTER, uprv_listformatter_cleanup);\n \n }\n \n const ListFormatInternal* ListFormatter::getListFormatInternal(\n         const Locale& locale, const char *style, UErrorCode& errorCode) {\n     if (U_FAILURE(errorCode)) {\n-        return NULL;\n+        return nullptr;\n     }\n     CharString keyBuffer(locale.getName(), errorCode);\n     keyBuffer.append(':', errorCode).append(style, errorCode);\n     UnicodeString key(keyBuffer.data(), -1, US_INV);\n-    ListFormatInternal* result = NULL;\n+    ListFormatInternal* result = nullptr;\n     {\n         Mutex m(&listFormatterMutex);\n-        if (listPatternHash == NULL) {\n+        if (listPatternHash == nullptr) {\n             initializeHash(errorCode);\n             if (U_FAILURE(errorCode)) {\n-                return NULL;\n+                return nullptr;\n             }\n         }\n         result = static_cast<ListFormatInternal*>(listPatternHash->get(key));\n     }\n-    if (result != NULL) {\n+    if (result != nullptr) {\n         return result;\n     }\n     result = loadListFormatInternal(locale, style, errorCode);\n     if (U_FAILURE(errorCode)) {\n-        return NULL;\n+        return nullptr;\n     }\n \n     {\n         Mutex m(&listFormatterMutex);\n         ListFormatInternal* temp = static_cast<ListFormatInternal*>(listPatternHash->get(key));\n-        if (temp != NULL) {\n+        if (temp != nullptr) {\n             delete result;\n             result = temp;\n         } else {\n             listPatternHash->put(key, result, errorCode);\n             if (U_FAILURE(errorCode)) {\n-                return NULL;\n+                return nullptr;\n             }\n         }\n     }\n@@ -235,11 +240,11 @@ ListFormatter::ListPatternsSink::~ListPatternsSink() {}\n \n ListFormatInternal* ListFormatter::loadListFormatInternal(\n         const Locale& locale, const char * style, UErrorCode& errorCode) {\n-    UResourceBundle* rb = ures_open(NULL, locale.getName(), &errorCode);\n+    UResourceBundle* rb = ures_open(nullptr, locale.getName(), &errorCode);\n     rb = ures_getByKeyWithFallback(rb, \"listPattern\", rb, &errorCode);\n     if (U_FAILURE(errorCode)) {\n         ures_close(rb);\n-        return NULL;\n+        return nullptr;\n     }\n     ListFormatter::ListPatternsSink sink;\n     char currentStyle[kStyleLenMax+1];\n@@ -255,20 +260,20 @@ ListFormatInternal* ListFormatter::loadListFormatInternal(\n     }\n     ures_close(rb);\n     if (U_FAILURE(errorCode)) {\n-        return NULL;\n+        return nullptr;\n     }\n     if (sink.two.isEmpty() || sink.start.isEmpty() || sink.middle.isEmpty() || sink.end.isEmpty()) {\n         errorCode = U_MISSING_RESOURCE_ERROR;\n-        return NULL;\n+        return nullptr;\n     }\n     ListFormatInternal* result = new ListFormatInternal(sink.two, sink.start, sink.middle, sink.end, errorCode);\n-    if (result == NULL) {\n+    if (result == nullptr) {\n         errorCode = U_MEMORY_ALLOCATION_ERROR;\n-        return NULL;\n+        return nullptr;\n     }\n     if (U_FAILURE(errorCode)) {\n         delete result;\n-        return NULL;\n+        return nullptr;\n     }\n     return result;\n }\n@@ -283,15 +288,14 @@ ListFormatter* ListFormatter::createInstance(const Locale& locale, UErrorCode& e\n }\n \n ListFormatter* ListFormatter::createInstance(const Locale& locale, const char *style, UErrorCode& errorCode) {\n-    Locale tempLocale = locale;\n-    const ListFormatInternal* listFormatInternal = getListFormatInternal(tempLocale, style, errorCode);\n+    const ListFormatInternal* listFormatInternal = getListFormatInternal(locale, style, errorCode);\n     if (U_FAILURE(errorCode)) {\n-        return NULL;\n+        return nullptr;\n     }\n     ListFormatter* p = new ListFormatter(listFormatInternal);\n-    if (p == NULL) {\n+    if (p == nullptr) {\n         errorCode = U_MEMORY_ALLOCATION_ERROR;\n-        return NULL;\n+        return nullptr;\n     }\n     return p;\n }\n@@ -301,7 +305,7 @@ ListFormatter::ListFormatter(const ListFormatData& listFormatData, UErrorCode &e\n     data = owned;\n }\n \n-ListFormatter::ListFormatter(const ListFormatInternal* listFormatterInternal) : owned(NULL), data(listFormatterInternal) {\n+ListFormatter::ListFormatter(const ListFormatInternal* listFormatterInternal) : owned(nullptr), data(listFormatterInternal) {\n }\n \n ListFormatter::~ListFormatter() {\n@@ -323,6 +327,8 @@ static void joinStringsAndReplace(\n         UnicodeString &result,\n         UBool recordOffset,\n         int32_t &offset,\n+        int32_t *offsetFirst,\n+        int32_t *offsetSecond,\n         UErrorCode& errorCode) {\n     if (U_FAILURE(errorCode)) {\n         return;\n@@ -348,6 +354,8 @@ static void joinStringsAndReplace(\n     } else if (offset >= 0) {\n         offset += offsets[0];\n     }\n+    if (offsetFirst != nullptr) *offsetFirst = offsets[0];\n+    if (offsetSecond != nullptr) *offsetSecond = offsets[1];\n }\n \n UnicodeString& ListFormatter::format(\n@@ -359,18 +367,43 @@ UnicodeString& ListFormatter::format(\n     return format(items, nItems, appendTo, -1, offset, errorCode);\n }\n \n+#if !UCONFIG_NO_FORMATTING\n+UnicodeString& ListFormatter::format(\n+        const UnicodeString items[],\n+        int32_t nItems,\n+        UnicodeString & appendTo,\n+        FieldPositionIterator* posIter,\n+        UErrorCode& errorCode) const {\n+  int32_t offset;\n+  FieldPositionIteratorHandler handler(posIter, errorCode);\n+  return format_(items, nItems, appendTo, -1, offset, &handler, errorCode);\n+};\n+#endif\n+\n UnicodeString& ListFormatter::format(\n         const UnicodeString items[],\n         int32_t nItems,\n         UnicodeString& appendTo,\n         int32_t index,\n         int32_t &offset,\n         UErrorCode& errorCode) const {\n+  return format_(items, nItems, appendTo, index, offset, nullptr, errorCode);\n+}\n+\n+UnicodeString& ListFormatter::format_(\n+        const UnicodeString items[],\n+        int32_t nItems,\n+        UnicodeString& appendTo,\n+        int32_t index,\n+        int32_t &offset,\n+        FieldPositionHandler* handler,\n+        UErrorCode& errorCode) const {\n+#if !UCONFIG_NO_FORMATTING\n     offset = -1;\n     if (U_FAILURE(errorCode)) {\n         return appendTo;\n     }\n-    if (data == NULL) {\n+    if (data == nullptr) {\n         errorCode = U_INVALID_STATE_ERROR;\n         return appendTo;\n     }\n@@ -382,21 +415,39 @@ UnicodeString& ListFormatter::format(\n         if (index == 0) {\n             offset = appendTo.length();\n         }\n+        if (handler != nullptr) {\n+            handler->addAttribute(ULISTFMT_ELEMENT_FIELD,\n+                                  appendTo.length(),\n+                                  appendTo.length() + items[0].length());\n+        }\n         appendTo.append(items[0]);\n         return appendTo;\n     }\n     UnicodeString result(items[0]);\n     if (index == 0) {\n         offset = 0;\n     }\n+    int32_t offsetFirst;\n+    int32_t offsetSecond;\n+    int32_t prefixLength = 0;\n+    // for n items, there are 2 * (n + 1) boundary including 0 and the upper\n+    // edge.\n+    MaybeStackArray<int32_t, 10> offsets((handler != nullptr) ? 2 * (nItems + 1): 0);\n     joinStringsAndReplace(\n             nItems == 2 ? data->twoPattern : data->startPattern,\n             result,\n             items[1],\n             result,\n             index == 1,\n             offset,\n+            &offsetFirst,\n+            &offsetSecond,\n             errorCode);\n+    if (handler != nullptr) {\n+        offsets[0] = 0;\n+        prefixLength += offsetFirst;\n+        offsets[1] = offsetSecond - prefixLength;\n+    }\n     if (nItems > 2) {\n         for (int32_t i = 2; i < nItems - 1; ++i) {\n              joinStringsAndReplace(\n@@ -406,7 +457,13 @@ UnicodeString& ListFormatter::format(\n                      result,\n                      index == i,\n                      offset,\n+                     &offsetFirst,\n+                     &offsetSecond,\n                      errorCode);\n+            if (handler != nullptr) {\n+                prefixLength += offsetFirst;\n+                offsets[i] = offsetSecond - prefixLength;\n+            }\n         }\n         joinStringsAndReplace(\n                 data->endPattern,\n@@ -415,14 +472,53 @@ UnicodeString& ListFormatter::format(\n                 result,\n                 index == nItems - 1,\n                 offset,\n+                &offsetFirst,\n+                &offsetSecond,\n                 errorCode);\n+        if (handler != nullptr) {\n+            prefixLength += offsetFirst;\n+            offsets[nItems - 1] = offsetSecond - prefixLength;\n+        }\n+    }\n+    if (handler != nullptr) {\n+        // If there are already some data in appendTo, we need to adjust the index\n+        // by shifting that lenght while insert into handler.\n+        int32_t shift = appendTo.length() + prefixLength;\n+        // Output the ULISTFMT_ELEMENT_FIELD in the order of the input elements\n+        for (int32_t i = 0; i < nItems; ++i) {\n+            offsets[i + nItems] = offsets[i] + items[i].length() + shift;\n+            offsets[i] += shift;\n+            handler->addAttribute(\n+                ULISTFMT_ELEMENT_FIELD,  // id\n+                offsets[i],  // index\n+                offsets[i + nItems]);  // limit\n+        }\n+        // The locale pattern may reorder the items (such as in ur-IN locale),\n+        // so we cannot assume the array is in accendning order.\n+        // To handle the edging case, just insert the two ends into the array\n+        // and sort. Then we output ULISTFMT_LITERAL_FIELD if the indecies\n+        // between the even and odd position are not the same in the sorted array.\n+        offsets[2 * nItems] = shift - prefixLength;\n+        offsets[2 * nItems + 1] = result.length() + shift - prefixLength;\n+        uprv_sortArray(offsets.getAlias(), 2 * (nItems + 1), sizeof(int32_t),\n+               uprv_int32Comparator, nullptr,\n+               false, &errorCode);\n+        for (int32_t i = 0; i <= nItems; ++i) {\n+          if (offsets[i * 2] != offsets[i * 2 + 1]) {\n+            handler->addAttribute(\n+                ULISTFMT_LITERAL_FIELD,  // id\n+                offsets[i * 2],  // index\n+                offsets[i * 2 + 1]);  // limit\n+          }\n+        }\n     }\n     if (U_SUCCESS(errorCode)) {\n         if (offset >= 0) {\n             offset += appendTo.length();\n         }\n         appendTo += result;\n     }\n+#endif\n     return appendTo;\n }\n ",
            "previous_filename": "deps/icu-small/source/common/listformatter.cpp"
        },
        {
            "sha": "03974ff4b740487db63d98c00bde1c49ce4aff71",
            "filename": "deps/icu-small/source/i18n/measfmt.cpp",
            "status": "modified",
            "additions": 17,
            "deletions": 18,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasfmt.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -47,7 +47,7 @@ U_NAMESPACE_BEGIN\n \n static constexpr int32_t PER_UNIT_INDEX = StandardPlural::COUNT;\n static constexpr int32_t PATTERN_COUNT = PER_UNIT_INDEX + 1;\n-static constexpr int32_t MEAS_UNIT_COUNT = 138;  // see assertion in MeasureFormatCacheData constructor\n+static constexpr int32_t MEAS_UNIT_COUNT = 142;  // see assertion in MeasureFormatCacheData constructor\n static constexpr int32_t WIDTH_INDEX_COUNT = UMEASFMT_WIDTH_NARROW + 1;\n \n UOBJECT_DEFINE_RTTI_IMPLEMENTATION(MeasureFormat)\n@@ -618,7 +618,7 @@ MeasureFormat::MeasureFormat(\n         : cache(NULL),\n           numberFormat(NULL),\n           pluralRules(NULL),\n-          width(w),\n+          fWidth(w),\n           listFormatter(NULL) {\n     initMeasureFormat(locale, w, NULL, status);\n }\n@@ -631,7 +631,7 @@ MeasureFormat::MeasureFormat(\n         : cache(NULL),\n           numberFormat(NULL),\n           pluralRules(NULL),\n-          width(w),\n+          fWidth(w),\n           listFormatter(NULL) {\n     initMeasureFormat(locale, w, nfToAdopt, status);\n }\n@@ -641,7 +641,7 @@ MeasureFormat::MeasureFormat(const MeasureFormat &other) :\n         cache(other.cache),\n         numberFormat(other.numberFormat),\n         pluralRules(other.pluralRules),\n-        width(other.width),\n+        fWidth(other.fWidth),\n         listFormatter(NULL) {\n     cache->addRef();\n     numberFormat->addRef();\n@@ -659,7 +659,7 @@ MeasureFormat &MeasureFormat::operator=(const MeasureFormat &other) {\n     SharedObject::copyPtr(other.cache, cache);\n     SharedObject::copyPtr(other.numberFormat, numberFormat);\n     SharedObject::copyPtr(other.pluralRules, pluralRules);\n-    width = other.width;\n+    fWidth = other.fWidth;\n     delete listFormatter;\n     if (other.listFormatter != NULL) {\n         listFormatter = new ListFormatter(*other.listFormatter);\n@@ -673,7 +673,7 @@ MeasureFormat::MeasureFormat() :\n         cache(NULL),\n         numberFormat(NULL),\n         pluralRules(NULL),\n-        width(UMEASFMT_WIDTH_SHORT),\n+        fWidth(UMEASFMT_WIDTH_SHORT),\n         listFormatter(NULL) {\n }\n \n@@ -703,7 +703,7 @@ UBool MeasureFormat::operator==(const Format &other) const {\n     // don't have to check it here.\n \n     // differing widths aren't equivalent\n-    if (width != rhs.width) {\n+    if (fWidth != rhs.fWidth) {\n         return FALSE;\n     }\n     // Width the same check locales.\n@@ -805,7 +805,7 @@ UnicodeString &MeasureFormat::formatMeasures(\n     if (measureCount == 1) {\n         return formatMeasure(measures[0], **numberFormat, appendTo, pos, status);\n     }\n-    if (width == UMEASFMT_WIDTH_NUMERIC) {\n+    if (fWidth == UMEASFMT_WIDTH_NUMERIC) {\n         Formattable hms[3];\n         int32_t bitMap = toHMS(measures, measureCount, hms, status);\n         if (bitMap > 0) {\n@@ -839,7 +839,7 @@ UnicodeString &MeasureFormat::formatMeasures(\n }\n \n UnicodeString MeasureFormat::getUnitDisplayName(const MeasureUnit& unit, UErrorCode& /*status*/) const {\n-    UMeasureFormatWidth width = getRegularWidth(this->width);\n+    UMeasureFormatWidth width = getRegularWidth(fWidth);\n     const UChar* const* styleToDnam = cache->dnams[unit.getIndex()];\n     const UChar* dnam = styleToDnam[width];\n     if (dnam == NULL) {\n@@ -895,11 +895,11 @@ void MeasureFormat::initMeasureFormat(\n             return;\n         }\n     }\n-    width = w;\n+    fWidth = w;\n     delete listFormatter;\n     listFormatter = ListFormatter::createInstance(\n             locale,\n-            listStyles[getRegularWidth(width)],\n+            listStyles[getRegularWidth(fWidth)],\n             status);\n }\n \n@@ -922,7 +922,7 @@ UBool MeasureFormat::setMeasureFormatLocale(const Locale &locale, UErrorCode &st\n     if (U_FAILURE(status) || locale == getLocale(status)) {\n         return FALSE;\n     }\n-    initMeasureFormat(locale, width, NULL, status);\n+    initMeasureFormat(locale, fWidth, NULL, status);\n     return U_SUCCESS(status);\n }\n \n@@ -956,7 +956,7 @@ UnicodeString &MeasureFormat::formatMeasure(\n     if (isCurrency(amtUnit)) {\n         UChar isoCode[4];\n         u_charsToUChars(amtUnit.getSubtype(), isoCode, 4);\n-        return cache->getCurrencyFormat(width)->format(\n+        return cache->getCurrencyFormat(fWidth)->format(\n                 new CurrencyAmount(amtNumber, isoCode, status),\n                 appendTo,\n                 pos,\n@@ -965,7 +965,7 @@ UnicodeString &MeasureFormat::formatMeasure(\n     UnicodeString formattedNumber;\n     StandardPlural::Form pluralForm = QuantityFormatter::selectPlural(\n             amtNumber, nf, **pluralRules, formattedNumber, pos, status);\n-    const SimpleFormatter *formatter = getPluralFormatter(amtUnit, width, pluralForm, status);\n+    const SimpleFormatter *formatter = getPluralFormatter(amtUnit, fWidth, pluralForm, status);\n     return QuantityFormatter::format(*formatter, formattedNumber, appendTo, pos, status);\n }\n \n@@ -1016,7 +1016,6 @@ UnicodeString &MeasureFormat::formatNumeric(\n         return appendTo;\n         break;\n     }\n-    return appendTo;\n }\n \n static void appendRange(\n@@ -1173,7 +1172,7 @@ int32_t MeasureFormat::withPerUnitAndAppend(\n     if (U_FAILURE(status)) {\n         return offset;\n     }\n-    const SimpleFormatter *perUnitFormatter = getFormatterOrNull(perUnit, width, PER_UNIT_INDEX);\n+    const SimpleFormatter *perUnitFormatter = getFormatterOrNull(perUnit, fWidth, PER_UNIT_INDEX);\n     if (perUnitFormatter != NULL) {\n         const UnicodeString *params[] = {&formatted};\n         perUnitFormatter->formatAndAppend(\n@@ -1185,9 +1184,9 @@ int32_t MeasureFormat::withPerUnitAndAppend(\n                 status);\n         return offset;\n     }\n-    const SimpleFormatter *perFormatter = getPerFormatter(width, status);\n+    const SimpleFormatter *perFormatter = getPerFormatter(fWidth, status);\n     const SimpleFormatter *pattern =\n-            getPluralFormatter(perUnit, width, StandardPlural::ONE, status);\n+            getPluralFormatter(perUnit, fWidth, StandardPlural::ONE, status);\n     if (U_FAILURE(status)) {\n         return offset;\n     }"
        },
        {
            "sha": "f6059f8c6dc8083512543867ed2ae538224f14e9",
            "filename": "deps/icu-small/source/i18n/measunit.cpp",
            "status": "modified",
            "additions": 67,
            "deletions": 45,
            "changes": 112,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasunit.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasunit.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fmeasunit.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -39,47 +39,47 @@ static const int32_t gOffsets[] = {\n     2,\n     7,\n     16,\n-    20,\n-    24,\n-    321,\n-    331,\n-    342,\n-    346,\n-    352,\n-    356,\n-    376,\n-    377,\n-    388,\n-    391,\n-    397,\n+    22,\n+    26,\n+    325,\n+    336,\n+    347,\n+    351,\n+    357,\n+    361,\n+    381,\n+    382,\n+    393,\n+    396,\n     402,\n-    406,\n-    410,\n-    435\n+    408,\n+    412,\n+    416,\n+    441\n };\n \n static const int32_t gIndexes[] = {\n     0,\n     2,\n     7,\n     16,\n-    20,\n-    24,\n-    24,\n-    34,\n-    45,\n-    49,\n-    55,\n-    59,\n-    79,\n-    80,\n-    91,\n+    22,\n+    26,\n+    26,\n+    37,\n+    48,\n+    52,\n+    58,\n+    62,\n+    82,\n+    83,\n     94,\n-    100,\n-    105,\n+    97,\n+    103,\n     109,\n     113,\n-    138\n+    117,\n+    142\n };\n \n // Must be sorted alphabetically.\n@@ -128,6 +128,8 @@ static const char * const gSubTypes[] = {\n     \"milligram-per-deciliter\",\n     \"millimole-per-liter\",\n     \"part-per-million\",\n+    \"percent\",\n+    \"permille\",\n     \"liter-per-100kilometers\",\n     \"liter-per-kilometer\",\n     \"mile-per-gallon\",\n@@ -388,9 +390,11 @@ static const char * const gSubTypes[] = {\n     \"UYN\",\n     \"UYP\",\n     \"UYU\",\n+    \"UYW\",\n     \"UZS\",\n     \"VEB\",\n     \"VEF\",\n+    \"VES\",\n     \"VNC\",\n     \"VND\",\n     \"VUV\",\n@@ -437,6 +441,7 @@ static const char * const gSubTypes[] = {\n     \"kilobyte\",\n     \"megabit\",\n     \"megabyte\",\n+    \"petabyte\",\n     \"terabit\",\n     \"terabyte\",\n     \"century\",\n@@ -505,6 +510,7 @@ static const char * const gSubTypes[] = {\n     \"megawatt\",\n     \"milliwatt\",\n     \"watt\",\n+    \"atmosphere\",\n     \"hectopascal\",\n     \"inch-hg\",\n     \"millibar\",\n@@ -547,14 +553,14 @@ static const char * const gSubTypes[] = {\n \n // Must be sorted by first value and then second value.\n static int32_t unitPerUnitToSingleUnit[][4] = {\n-        {363, 333, 17, 0},\n-        {365, 339, 17, 2},\n-        {367, 333, 17, 3},\n-        {367, 424, 4, 2},\n-        {367, 425, 4, 3},\n-        {382, 422, 3, 1},\n-        {385, 11, 16, 4},\n-        {427, 363, 4, 1}\n+        {368, 338, 17, 0},\n+        {370, 344, 17, 2},\n+        {372, 338, 17, 3},\n+        {372, 430, 4, 2},\n+        {372, 431, 4, 3},\n+        {387, 428, 3, 1},\n+        {390, 11, 16, 5},\n+        {433, 368, 4, 1}\n };\n \n // Shortcuts to the base unit in order to make the default constructor fast\n@@ -641,6 +647,14 @@ MeasureUnit *MeasureUnit::createPartPerMillion(UErrorCode &status) {\n     return MeasureUnit::create(3, 3, status);\n }\n \n+MeasureUnit *MeasureUnit::createPercent(UErrorCode &status) {\n+    return MeasureUnit::create(3, 4, status);\n+}\n+\n+MeasureUnit *MeasureUnit::createPermille(UErrorCode &status) {\n+    return MeasureUnit::create(3, 5, status);\n+}\n+\n MeasureUnit *MeasureUnit::createLiterPer100Kilometers(UErrorCode &status) {\n     return MeasureUnit::create(4, 0, status);\n }\n@@ -689,14 +703,18 @@ MeasureUnit *MeasureUnit::createMegabyte(UErrorCode &status) {\n     return MeasureUnit::create(6, 7, status);\n }\n \n-MeasureUnit *MeasureUnit::createTerabit(UErrorCode &status) {\n+MeasureUnit *MeasureUnit::createPetabyte(UErrorCode &status) {\n     return MeasureUnit::create(6, 8, status);\n }\n \n-MeasureUnit *MeasureUnit::createTerabyte(UErrorCode &status) {\n+MeasureUnit *MeasureUnit::createTerabit(UErrorCode &status) {\n     return MeasureUnit::create(6, 9, status);\n }\n \n+MeasureUnit *MeasureUnit::createTerabyte(UErrorCode &status) {\n+    return MeasureUnit::create(6, 10, status);\n+}\n+\n MeasureUnit *MeasureUnit::createCentury(UErrorCode &status) {\n     return MeasureUnit::create(7, 0, status);\n }\n@@ -949,26 +967,30 @@ MeasureUnit *MeasureUnit::createWatt(UErrorCode &status) {\n     return MeasureUnit::create(15, 5, status);\n }\n \n-MeasureUnit *MeasureUnit::createHectopascal(UErrorCode &status) {\n+MeasureUnit *MeasureUnit::createAtmosphere(UErrorCode &status) {\n     return MeasureUnit::create(16, 0, status);\n }\n \n-MeasureUnit *MeasureUnit::createInchHg(UErrorCode &status) {\n+MeasureUnit *MeasureUnit::createHectopascal(UErrorCode &status) {\n     return MeasureUnit::create(16, 1, status);\n }\n \n-MeasureUnit *MeasureUnit::createMillibar(UErrorCode &status) {\n+MeasureUnit *MeasureUnit::createInchHg(UErrorCode &status) {\n     return MeasureUnit::create(16, 2, status);\n }\n \n-MeasureUnit *MeasureUnit::createMillimeterOfMercury(UErrorCode &status) {\n+MeasureUnit *MeasureUnit::createMillibar(UErrorCode &status) {\n     return MeasureUnit::create(16, 3, status);\n }\n \n-MeasureUnit *MeasureUnit::createPoundPerSquareInch(UErrorCode &status) {\n+MeasureUnit *MeasureUnit::createMillimeterOfMercury(UErrorCode &status) {\n     return MeasureUnit::create(16, 4, status);\n }\n \n+MeasureUnit *MeasureUnit::createPoundPerSquareInch(UErrorCode &status) {\n+    return MeasureUnit::create(16, 5, status);\n+}\n+\n MeasureUnit *MeasureUnit::createKilometerPerHour(UErrorCode &status) {\n     return MeasureUnit::create(17, 0, status);\n }"
        },
        {
            "sha": "8ff86a2cacf018116a8683ca264b4de9b2a76899",
            "filename": "deps/icu-small/source/i18n/msgfmt.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fmsgfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fmsgfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fmsgfmt.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1078,7 +1078,7 @@ void MessageFormat::format(int32_t msgStart, const void *plNumber,\n                 // that formats the number without subtracting the offset.\n                 appendTo.formatAndAppend(pluralNumber.formatter, *arg, success);\n             }\n-        } else if ((formatter = getCachedFormatter(i -2))) {\n+        } else if ((formatter = getCachedFormatter(i -2)) != 0) {\n             // Handles all ArgType.SIMPLE, and formatters from setFormat() and its siblings.\n             if (dynamic_cast<const ChoiceFormat*>(formatter) ||\n                 dynamic_cast<const PluralFormat*>(formatter) ||"
        },
        {
            "sha": "b5e7892d5e68cbfd877aa3441e583398c8772bc3",
            "filename": "deps/icu-small/source/i18n/nfrule.cpp",
            "status": "modified",
            "additions": 52,
            "deletions": 52,
            "changes": 104,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -39,14 +39,14 @@ NFRule::NFRule(const RuleBasedNumberFormat* _rbnf, const UnicodeString &_ruleTex\n   , radix(10)\n   , exponent(0)\n   , decimalPoint(0)\n-  , ruleText(_ruleText)\n+  , fRuleText(_ruleText)\n   , sub1(NULL)\n   , sub2(NULL)\n   , formatter(_rbnf)\n   , rulePatternFormat(NULL)\n {\n-    if (!ruleText.isEmpty()) {\n-        parseRuleDescriptor(ruleText, status);\n+    if (!fRuleText.isEmpty()) {\n+        parseRuleDescriptor(fRuleText, status);\n     }\n }\n \n@@ -122,7 +122,7 @@ NFRule::makeRules(UnicodeString& description,\n         status = U_MEMORY_ALLOCATION_ERROR;\n         return;\n     }\n-    description = rule1->ruleText;\n+    description = rule1->fRuleText;\n \n     // check the description to see whether there's text enclosed\n     // in brackets\n@@ -314,7 +314,7 @@ NFRule::parseRuleDescriptor(UnicodeString& description, UErrorCode& status)\n             if (c == gSlash) {\n                 val = 0;\n                 ++p;\n-                int64_t ll_10 = 10;\n+                ll_10 = 10;\n                 while (p < descriptorLength) {\n                     c = descriptor.charAt(p);\n                     if (c >= gZero && c <= gNine) {\n@@ -418,7 +418,7 @@ NFRule::extractSubstitutions(const NFRuleSet* ruleSet,\n     if (U_FAILURE(status)) {\n         return;\n     }\n-    this->ruleText = ruleText;\n+    fRuleText = ruleText;\n     sub1 = extractSubstitution(ruleSet, predecessor, status);\n     if (sub1 == NULL) {\n         // Small optimization. There is no need to create a redundant NullSubstitution.\n@@ -427,15 +427,15 @@ NFRule::extractSubstitutions(const NFRuleSet* ruleSet,\n     else {\n         sub2 = extractSubstitution(ruleSet, predecessor, status);\n     }\n-    int32_t pluralRuleStart = this->ruleText.indexOf(gDollarOpenParenthesis, -1, 0);\n-    int32_t pluralRuleEnd = (pluralRuleStart >= 0 ? this->ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) : -1);\n+    int32_t pluralRuleStart = fRuleText.indexOf(gDollarOpenParenthesis, -1, 0);\n+    int32_t pluralRuleEnd = (pluralRuleStart >= 0 ? fRuleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) : -1);\n     if (pluralRuleEnd >= 0) {\n-        int32_t endType = this->ruleText.indexOf(gComma, pluralRuleStart);\n+        int32_t endType = fRuleText.indexOf(gComma, pluralRuleStart);\n         if (endType < 0) {\n             status = U_PARSE_ERROR;\n             return;\n         }\n-        UnicodeString type(this->ruleText.tempSubString(pluralRuleStart + 2, endType - pluralRuleStart - 2));\n+        UnicodeString type(fRuleText.tempSubString(pluralRuleStart + 2, endType - pluralRuleStart - 2));\n         UPluralType pluralType;\n         if (type.startsWith(UNICODE_STRING_SIMPLE(\"cardinal\"))) {\n             pluralType = UPLURAL_TYPE_CARDINAL;\n@@ -448,7 +448,7 @@ NFRule::extractSubstitutions(const NFRuleSet* ruleSet,\n             return;\n         }\n         rulePatternFormat = formatter->createPluralFormat(pluralType,\n-                this->ruleText.tempSubString(endType + 1, pluralRuleEnd - endType - 1), status);\n+                fRuleText.tempSubString(endType + 1, pluralRuleEnd - endType - 1), status);\n     }\n }\n \n@@ -484,16 +484,16 @@ NFRule::extractSubstitution(const NFRuleSet* ruleSet,\n \n     // special-case the \">>>\" token, since searching for the > at the\n     // end will actually find the > in the middle\n-    if (ruleText.indexOf(gGreaterGreaterGreater, 3, 0) == subStart) {\n+    if (fRuleText.indexOf(gGreaterGreaterGreater, 3, 0) == subStart) {\n         subEnd = subStart + 2;\n \n         // otherwise the substitution token ends with the same character\n         // it began with\n     } else {\n-        UChar c = ruleText.charAt(subStart);\n-        subEnd = ruleText.indexOf(c, subStart + 1);\n+        UChar c = fRuleText.charAt(subStart);\n+        subEnd = fRuleText.indexOf(c, subStart + 1);\n         // special case for '<%foo<<'\n-        if (c == gLessThan && subEnd != -1 && subEnd < ruleText.length() - 1 && ruleText.charAt(subEnd+1) == c) {\n+        if (c == gLessThan && subEnd != -1 && subEnd < fRuleText.length() - 1 && fRuleText.charAt(subEnd+1) == c) {\n             // ordinals use \"=#,##0==%abbrev=\" as their rule.  Notice that the '==' in the middle\n             // occurs because of the juxtaposition of two different rules.  The check for '<' is a hack\n             // to get around this.  Having the duplicate at the front would cause problems with\n@@ -513,12 +513,12 @@ NFRule::extractSubstitution(const NFRuleSet* ruleSet,\n     // some text bounded by substitution token characters).  Use\n     // makeSubstitution() to create the right kind of substitution\n     UnicodeString subToken;\n-    subToken.setTo(ruleText, subStart, subEnd + 1 - subStart);\n+    subToken.setTo(fRuleText, subStart, subEnd + 1 - subStart);\n     result = NFSubstitution::makeSubstitution(subStart, this, predecessor, ruleSet,\n         this->formatter, subToken, status);\n \n     // remove the substitution from the rule text\n-    ruleText.removeBetween(subStart, subEnd+1);\n+    fRuleText.removeBetween(subStart, subEnd+1);\n \n     return result;\n }\n@@ -601,7 +601,7 @@ NFRule::indexOfAnyRulePrefix() const\n {\n     int result = -1;\n     for (int i = 0; RULE_PREFIXES[i]; i++) {\n-        int32_t pos = ruleText.indexOf(*RULE_PREFIXES[i]);\n+        int32_t pos = fRuleText.indexOf(*RULE_PREFIXES[i]);\n         if (pos != -1 && (result == -1 || pos < result)) {\n             result = pos;\n         }\n@@ -637,7 +637,7 @@ NFRule::operator==(const NFRule& rhs) const\n     return baseValue == rhs.baseValue\n         && radix == rhs.radix\n         && exponent == rhs.exponent\n-        && ruleText == rhs.ruleText\n+        && fRuleText == rhs.fRuleText\n         && util_equalSubstitutions(sub1, rhs.sub1)\n         && util_equalSubstitutions(sub2, rhs.sub2);\n }\n@@ -690,14 +690,14 @@ NFRule::_appendRuleText(UnicodeString& result) const\n     // if the rule text begins with a space, write an apostrophe\n     // (whitespace after the rule descriptor is ignored; the\n     // apostrophe is used to make the whitespace significant)\n-    if (ruleText.charAt(0) == gSpace && (sub1 == NULL || sub1->getPos() != 0)) {\n+    if (fRuleText.charAt(0) == gSpace && (sub1 == NULL || sub1->getPos() != 0)) {\n         result.append(gTick);\n     }\n \n     // now, write the rule's rule text, inserting appropriate\n     // substitution tokens in the appropriate places\n     UnicodeString ruleTextCopy;\n-    ruleTextCopy.setTo(ruleText);\n+    ruleTextCopy.setTo(fRuleText);\n \n     UnicodeString temp;\n     if (sub2 != NULL) {\n@@ -743,24 +743,24 @@ NFRule::doFormat(int64_t number, UnicodeString& toInsertInto, int32_t pos, int32\n     // into the right places in toInsertInto (notice we do the\n     // substitutions in reverse order so that the offsets don't get\n     // messed up)\n-    int32_t pluralRuleStart = ruleText.length();\n+    int32_t pluralRuleStart = fRuleText.length();\n     int32_t lengthOffset = 0;\n     if (!rulePatternFormat) {\n-        toInsertInto.insert(pos, ruleText);\n+        toInsertInto.insert(pos, fRuleText);\n     }\n     else {\n-        pluralRuleStart = ruleText.indexOf(gDollarOpenParenthesis, -1, 0);\n-        int pluralRuleEnd = ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);\n+        pluralRuleStart = fRuleText.indexOf(gDollarOpenParenthesis, -1, 0);\n+        int pluralRuleEnd = fRuleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);\n         int initialLength = toInsertInto.length();\n-        if (pluralRuleEnd < ruleText.length() - 1) {\n-            toInsertInto.insert(pos, ruleText.tempSubString(pluralRuleEnd + 2));\n+        if (pluralRuleEnd < fRuleText.length() - 1) {\n+            toInsertInto.insert(pos, fRuleText.tempSubString(pluralRuleEnd + 2));\n         }\n         toInsertInto.insert(pos,\n             rulePatternFormat->format((int32_t)(number/util64_pow(radix, exponent)), status));\n         if (pluralRuleStart > 0) {\n-            toInsertInto.insert(pos, ruleText.tempSubString(0, pluralRuleStart));\n+            toInsertInto.insert(pos, fRuleText.tempSubString(0, pluralRuleStart));\n         }\n-        lengthOffset = ruleText.length() - (toInsertInto.length() - initialLength);\n+        lengthOffset = fRuleText.length() - (toInsertInto.length() - initialLength);\n     }\n \n     if (sub2 != NULL) {\n@@ -789,17 +789,17 @@ NFRule::doFormat(double number, UnicodeString& toInsertInto, int32_t pos, int32_\n     // [again, we have two copies of this routine that do the same thing\n     // so that we don't sacrifice precision in a long by casting it\n     // to a double]\n-    int32_t pluralRuleStart = ruleText.length();\n+    int32_t pluralRuleStart = fRuleText.length();\n     int32_t lengthOffset = 0;\n     if (!rulePatternFormat) {\n-        toInsertInto.insert(pos, ruleText);\n+        toInsertInto.insert(pos, fRuleText);\n     }\n     else {\n-        pluralRuleStart = ruleText.indexOf(gDollarOpenParenthesis, -1, 0);\n-        int pluralRuleEnd = ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);\n+        pluralRuleStart = fRuleText.indexOf(gDollarOpenParenthesis, -1, 0);\n+        int pluralRuleEnd = fRuleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart);\n         int initialLength = toInsertInto.length();\n-        if (pluralRuleEnd < ruleText.length() - 1) {\n-            toInsertInto.insert(pos, ruleText.tempSubString(pluralRuleEnd + 2));\n+        if (pluralRuleEnd < fRuleText.length() - 1) {\n+            toInsertInto.insert(pos, fRuleText.tempSubString(pluralRuleEnd + 2));\n         }\n         double pluralVal = number;\n         if (0 <= pluralVal && pluralVal < 1) {\n@@ -812,9 +812,9 @@ NFRule::doFormat(double number, UnicodeString& toInsertInto, int32_t pos, int32_\n         }\n         toInsertInto.insert(pos, rulePatternFormat->format((int32_t)(pluralVal), status));\n         if (pluralRuleStart > 0) {\n-            toInsertInto.insert(pos, ruleText.tempSubString(0, pluralRuleStart));\n+            toInsertInto.insert(pos, fRuleText.tempSubString(0, pluralRuleStart));\n         }\n-        lengthOffset = ruleText.length() - (toInsertInto.length() - initialLength);\n+        lengthOffset = fRuleText.length() - (toInsertInto.length() - initialLength);\n     }\n \n     if (sub2 != NULL) {\n@@ -908,15 +908,15 @@ NFRule::doParse(const UnicodeString& text,\n     ParsePosition pp;\n     UnicodeString workText(text);\n \n-    int32_t sub1Pos = sub1 != NULL ? sub1->getPos() : ruleText.length();\n-    int32_t sub2Pos = sub2 != NULL ? sub2->getPos() : ruleText.length();\n+    int32_t sub1Pos = sub1 != NULL ? sub1->getPos() : fRuleText.length();\n+    int32_t sub2Pos = sub2 != NULL ? sub2->getPos() : fRuleText.length();\n \n     // check to see whether the text before the first substitution\n     // matches the text at the beginning of the string being\n     // parsed.  If it does, strip that off the front of workText;\n     // otherwise, dump out with a mismatch\n     UnicodeString prefix;\n-    prefix.setTo(ruleText, 0, sub1Pos);\n+    prefix.setTo(fRuleText, 0, sub1Pos);\n \n #ifdef RBNF_DEBUG\n     fprintf(stderr, \"doParse %p \", this);\n@@ -1000,7 +1000,7 @@ NFRule::doParse(const UnicodeString& text,\n         // the substitution, giving us a new partial parse result\n         pp.setIndex(0);\n \n-        temp.setTo(ruleText, sub1Pos, sub2Pos - sub1Pos);\n+        temp.setTo(fRuleText, sub1Pos, sub2Pos - sub1Pos);\n         double partialResult = matchToDelimiter(workText, start, tempBaseValue,\n             temp, pp, sub1,\n             nonNumericalExecutedRuleMask,\n@@ -1021,7 +1021,7 @@ NFRule::doParse(const UnicodeString& text,\n             // partial result with whatever it gets back from its\n             // substitution if there's a successful match, giving us\n             // a real result\n-            temp.setTo(ruleText, sub2Pos, ruleText.length() - sub2Pos);\n+            temp.setTo(fRuleText, sub2Pos, fRuleText.length() - sub2Pos);\n             partialResult = matchToDelimiter(workText2, 0, partialResult,\n                 temp, pp2, sub2,\n                 nonNumericalExecutedRuleMask,\n@@ -1039,18 +1039,18 @@ NFRule::doParse(const UnicodeString& text,\n             else {\n                 // commented out because ParsePosition doesn't have error index in 1.1.x\n                 // restored for ICU4C port\n-                int32_t temp = pp2.getErrorIndex() + sub1Pos + pp.getIndex();\n-                if (temp> parsePosition.getErrorIndex()) {\n-                    parsePosition.setErrorIndex(temp);\n+                int32_t i_temp = pp2.getErrorIndex() + sub1Pos + pp.getIndex();\n+                if (i_temp> parsePosition.getErrorIndex()) {\n+                    parsePosition.setErrorIndex(i_temp);\n                 }\n             }\n         }\n         else {\n             // commented out because ParsePosition doesn't have error index in 1.1.x\n             // restored for ICU4C port\n-            int32_t temp = sub1Pos + pp.getErrorIndex();\n-            if (temp > parsePosition.getErrorIndex()) {\n-                parsePosition.setErrorIndex(temp);\n+            int32_t i_temp = sub1Pos + pp.getErrorIndex();\n+            if (i_temp > parsePosition.getErrorIndex()) {\n+                parsePosition.setErrorIndex(i_temp);\n             }\n         }\n         // keep trying to match things until the outer matchToDelimiter()\n@@ -1483,11 +1483,11 @@ NFRule::findText(const UnicodeString& str,\n         rulePatternFormat->parseType(str, this, result, position);\n         int start = position.getBeginIndex();\n         if (start >= 0) {\n-            int32_t pluralRuleStart = ruleText.indexOf(gDollarOpenParenthesis, -1, 0);\n-            int32_t pluralRuleSuffix = ruleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) + 2;\n+            int32_t pluralRuleStart = fRuleText.indexOf(gDollarOpenParenthesis, -1, 0);\n+            int32_t pluralRuleSuffix = fRuleText.indexOf(gClosedParenthesisDollar, -1, pluralRuleStart) + 2;\n             int32_t matchLen = position.getEndIndex() - start;\n-            UnicodeString prefix(ruleText.tempSubString(0, pluralRuleStart));\n-            UnicodeString suffix(ruleText.tempSubString(pluralRuleSuffix));\n+            UnicodeString prefix(fRuleText.tempSubString(0, pluralRuleStart));\n+            UnicodeString suffix(fRuleText.tempSubString(pluralRuleSuffix));\n             if (str.compare(start - prefix.length(), prefix.length(), prefix, 0, prefix.length()) == 0\n                     && str.compare(start + matchLen, suffix.length(), suffix, 0, suffix.length()) == 0)\n             {"
        },
        {
            "sha": "2b030390ea7dcb9715c996e8434e8cbc5c455e14",
            "filename": "deps/icu-small/source/i18n/nfrule.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnfrule.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -109,7 +109,7 @@ class NFRule : public UMemory {\n     int32_t radix;\n     int16_t exponent;\n     UChar decimalPoint;\n-    UnicodeString ruleText;\n+    UnicodeString fRuleText;\n     NFSubstitution* sub1;\n     NFSubstitution* sub2;\n     const RuleBasedNumberFormat* formatter;"
        },
        {
            "sha": "10942c35f535df6bc8bd76b1e0212064fd43a869",
            "filename": "deps/icu-small/source/i18n/number_compact.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_compact.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_compact.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_compact.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -273,13 +273,13 @@ void CompactHandler::processQuantity(DecimalQuantity &quantity, MicroProps &micr\n     if (U_FAILURE(status)) { return; }\n \n     // Treat zero as if it had magnitude 0\n-    int magnitude;\n+    int32_t magnitude;\n     if (quantity.isZero()) {\n         magnitude = 0;\n         micros.rounder.apply(quantity, status);\n     } else {\n         // TODO: Revisit chooseMultiplierAndApply\n-        int multiplier = micros.rounder.chooseMultiplierAndApply(quantity, data, status);\n+        int32_t multiplier = micros.rounder.chooseMultiplierAndApply(quantity, data, status);\n         magnitude = quantity.isZero() ? 0 : quantity.getMagnitude();\n         magnitude -= multiplier;\n     }"
        },
        {
            "sha": "2c4182b1c6ecdac30056eafd8f5892235e31a2ad",
            "filename": "deps/icu-small/source/i18n/number_decimalquantity.cpp",
            "status": "modified",
            "additions": 25,
            "deletions": 2,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimalquantity.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimalquantity.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimalquantity.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -1154,8 +1154,31 @@ const char16_t* DecimalQuantity::checkHealth() const {\n }\n \n bool DecimalQuantity::operator==(const DecimalQuantity& other) const {\n-    // FIXME: Make a faster implementation.\n-    return toString() == other.toString();\n+    bool basicEquals =\n+            scale == other.scale\n+            && precision == other.precision\n+            && flags == other.flags\n+            && lOptPos == other.lOptPos\n+            && lReqPos == other.lReqPos\n+            && rReqPos == other.rReqPos\n+            && rOptPos == other.rOptPos\n+            && isApproximate == other.isApproximate;\n+    if (!basicEquals) {\n+        return false;\n+    }\n+\n+    if (precision == 0) {\n+        return true;\n+    } else if (isApproximate) {\n+        return origDouble == other.origDouble && origDelta == other.origDelta;\n+    } else {\n+        for (int m = getUpperDisplayMagnitude(); m >= getLowerDisplayMagnitude(); m--) {\n+            if (getDigit(m) != other.getDigit(m)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n }\n \n UnicodeString DecimalQuantity::toString() const {"
        },
        {
            "sha": "12fe7060e2d051286e95555dd19266bf7538f8c3",
            "filename": "deps/icu-small/source/i18n/number_decimfmtprops.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimfmtprops.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimfmtprops.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_decimfmtprops.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "patch": "@@ -15,6 +15,7 @@ using namespace icu::number::impl;\n \n namespace {\n \n+alignas(DecimalFormatProperties)\n char kRawDefaultProperties[sizeof(DecimalFormatProperties)];\n \n icu::UInitOnce gDefaultPropertiesInitOnce = U_INITONCE_INITIALIZER;"
        },
        {
            "sha": "a66e3bd0f23510f610a975dacc7f69f8ab59ac4b",
            "filename": "deps/icu-small/source/i18n/number_fluent.cpp",
            "status": "modified",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_fluent.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_fluent.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_fluent.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "60c18ee284e238176593207bacd824b34fec392b",
            "filename": "deps/icu-small/source/i18n/number_formatimpl.cpp",
            "status": "modified",
            "additions": 73,
            "deletions": 55,
            "changes": 128,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_formatimpl.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_formatimpl.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_formatimpl.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "fda38c92845f87cb3d6de62a7a1274fd9abb3c76",
            "filename": "deps/icu-small/source/i18n/number_formatimpl.h",
            "status": "modified",
            "additions": 26,
            "deletions": 26,
            "changes": 52,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_formatimpl.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_formatimpl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_formatimpl.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "da32cca99a38df0e97236503ddaf051e8ad76acc",
            "filename": "deps/icu-small/source/i18n/number_grouping.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_grouping.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_grouping.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_grouping.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "fd8e8d381a1d76167504dc3d3254b6630e9d5621",
            "filename": "deps/icu-small/source/i18n/number_longnames.cpp",
            "status": "modified",
            "additions": 35,
            "deletions": 17,
            "changes": 52,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "a71d0caadf125c8ce7db479cf52e995467a0ab6b",
            "filename": "deps/icu-small/source/i18n/number_longnames.h",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_longnames.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "2c9a8e5178f35e477b4e1bb169ed2f8d7bae5c71",
            "filename": "deps/icu-small/source/i18n/number_mapper.cpp",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_mapper.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_mapper.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_mapper.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "d92ec63b08da5881cf58ce90b99ac74633a752d4",
            "filename": "deps/icu-small/source/i18n/number_modifiers.cpp",
            "status": "modified",
            "additions": 164,
            "deletions": 14,
            "changes": 178,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "65ada937d033452ebe581795739770ac4d8eeb6b",
            "filename": "deps/icu-small/source/i18n/number_modifiers.h",
            "status": "modified",
            "additions": 112,
            "deletions": 43,
            "changes": 155,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_modifiers.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "ecb50dd9b820194d5854159b01ed71d77e4e50bb",
            "filename": "deps/icu-small/source/i18n/number_multiplier.cpp",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_multiplier.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_multiplier.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_multiplier.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "d8235dc601b559218ad2db70a5ae6fd0e18ca168",
            "filename": "deps/icu-small/source/i18n/number_multiplier.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_multiplier.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_multiplier.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_multiplier.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "31684d7208b6068583ae5747852af97762dc6c6d",
            "filename": "deps/icu-small/source/i18n/number_padding.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_padding.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_padding.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_padding.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "4c61a0d35bca828b3dcf9adc3e17970338b9f0f1",
            "filename": "deps/icu-small/source/i18n/number_patternmodifier.cpp",
            "status": "modified",
            "additions": 66,
            "deletions": 45,
            "changes": 111,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "ea80d6305e75b4444934f13733f91c27e9a79c75",
            "filename": "deps/icu-small/source/i18n/number_patternmodifier.h",
            "status": "modified",
            "additions": 22,
            "deletions": 16,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_patternmodifier.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "07c1ce9dac2c8954b764558b2e867de82fbe0eee",
            "filename": "deps/icu-small/source/i18n/number_scientific.cpp",
            "status": "modified",
            "additions": 27,
            "deletions": 7,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_scientific.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_scientific.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_scientific.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "e377bd941efaeb07ac7d9cdc00cd519cb443d3e5",
            "filename": "deps/icu-small/source/i18n/number_scientific.h",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_scientific.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_scientific.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_scientific.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "74ba33fbbc159fd1e44c6cb3af8d163190c00015",
            "filename": "deps/icu-small/source/i18n/number_stringbuilder.cpp",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "b14ad9ede2f90f47194344dfacd07a07f7a29fad",
            "filename": "deps/icu-small/source/i18n/number_stringbuilder.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_stringbuilder.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "00a6818869fdc22d898912d9d928f396d1e7f9a4",
            "filename": "deps/icu-small/source/i18n/number_types.h",
            "status": "modified",
            "additions": 55,
            "deletions": 3,
            "changes": 58,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_types.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_types.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumber_types.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "ef47e1e01b5ee6d7aa311a372f2dfaefdcecaa0c",
            "filename": "deps/icu-small/source/i18n/numfmt.cpp",
            "status": "modified",
            "additions": 27,
            "deletions": 23,
            "changes": 50,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumfmt.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "598ace56533c36ab8ee64934bc470d98b4e3414d",
            "filename": "deps/icu-small/source/i18n/numparse_currency.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumparse_currency.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumparse_currency.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumparse_currency.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "3192a3959389a790a6e0944542570724306b89a5",
            "filename": "deps/icu-small/source/i18n/numparse_impl.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumparse_impl.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumparse_impl.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumparse_impl.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "de38957440817cdcffdd5a952b8a38b3f1b5089c",
            "filename": "deps/icu-small/source/i18n/numparse_scientific.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumparse_scientific.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumparse_scientific.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumparse_scientific.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "12b006c8ad554062a50fc7ceb013ac852615fc27",
            "filename": "deps/icu-small/source/i18n/numrange_fluent.cpp",
            "status": "added",
            "additions": 472,
            "deletions": 0,
            "changes": 472,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumrange_fluent.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumrange_fluent.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumrange_fluent.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "21365bfc59bca358564b31fba3456f821466cb06",
            "filename": "deps/icu-small/source/i18n/numrange_impl.cpp",
            "status": "added",
            "additions": 486,
            "deletions": 0,
            "changes": 486,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumrange_impl.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumrange_impl.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumrange_impl.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "787fc656860d53c5593d0092c6b465dc8ad9276a",
            "filename": "deps/icu-small/source/i18n/numrange_impl.h",
            "status": "added",
            "additions": 114,
            "deletions": 0,
            "changes": 114,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumrange_impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumrange_impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumrange_impl.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "514fe05e5ae6def8e3e5888911b11767d4a21091",
            "filename": "deps/icu-small/source/i18n/numsys.cpp",
            "status": "modified",
            "additions": 86,
            "deletions": 58,
            "changes": 144,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumsys.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumsys.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumsys.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "733e102365369dbf4cdd9438fe766bebeeb3079d",
            "filename": "deps/icu-small/source/i18n/numsys_impl.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumsys_impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumsys_impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fnumsys_impl.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "c35005746625858c821090b89b9c2ecd66c76994",
            "filename": "deps/icu-small/source/i18n/olsontz.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Folsontz.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Folsontz.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Folsontz.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "3caa48a57bb700e09565fc6a7e3259065058185b",
            "filename": "deps/icu-small/source/i18n/plurrule.cpp",
            "status": "modified",
            "additions": 266,
            "deletions": 190,
            "changes": 456,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fplurrule.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fplurrule.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fplurrule.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "f23ae168569d66d0f5462db2350d2f017cb7276e",
            "filename": "deps/icu-small/source/i18n/plurrule_impl.h",
            "status": "modified",
            "additions": 28,
            "deletions": 24,
            "changes": 52,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fplurrule_impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fplurrule_impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fplurrule_impl.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "74707ccd22d2acd5738a31caf630fbba9b2593f2",
            "filename": "deps/icu-small/source/i18n/rbnf.cpp",
            "status": "modified",
            "additions": 99,
            "deletions": 84,
            "changes": 183,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frbnf.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frbnf.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Frbnf.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "a18452ab2ecb49b786397c0b215a223321b518a6",
            "filename": "deps/icu-small/source/i18n/rbt.h",
            "status": "modified",
            "additions": 3,
            "deletions": 255,
            "changes": 258,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frbt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frbt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Frbt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "e07cc8b63a408c1f72fb41be9b2a08e8b52d7719",
            "filename": "deps/icu-small/source/i18n/rbt_pars.cpp",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frbt_pars.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frbt_pars.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Frbt_pars.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "0c5fca6f67b3f9eb81bcbc404e5618f767daf36c",
            "filename": "deps/icu-small/source/i18n/regexcmp.cpp",
            "status": "modified",
            "additions": 181,
            "deletions": 180,
            "changes": 361,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fregexcmp.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fregexcmp.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fregexcmp.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "f182f61486e6d32276681dd4877d13e09ea9e6bf",
            "filename": "deps/icu-small/source/i18n/region.cpp",
            "status": "modified",
            "additions": 32,
            "deletions": 24,
            "changes": 56,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fregion.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fregion.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fregion.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "ae251ed20b46a372c89a667f2547b86a7d53234e",
            "filename": "deps/icu-small/source/i18n/reldatefmt.cpp",
            "status": "modified",
            "additions": 147,
            "deletions": 100,
            "changes": 247,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Freldatefmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Freldatefmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Freldatefmt.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "753672d905f16bcf27cf50266bb24d27c90b9d8e",
            "filename": "deps/icu-small/source/i18n/reldtfmt.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Freldtfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Freldtfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Freldtfmt.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "0403da11efda767efa3b0af1b6137b8f5fcbf757",
            "filename": "deps/icu-small/source/i18n/reldtfmt.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Freldtfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Freldtfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Freldtfmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "95fd0d2240af95f0a74c07177ceca1952857c309",
            "filename": "deps/icu-small/source/i18n/rematch.cpp",
            "status": "modified",
            "additions": 37,
            "deletions": 37,
            "changes": 74,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frematch.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frematch.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Frematch.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "b057b6bbd5a12f7e5dac84e28703d192e54da779",
            "filename": "deps/icu-small/source/i18n/rulebasedcollator.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frulebasedcollator.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Frulebasedcollator.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Frulebasedcollator.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "558d178e2f97cacb854f58d6cbbb68931ec480ca",
            "filename": "deps/icu-small/source/i18n/scriptset.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fscriptset.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fscriptset.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fscriptset.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "66a06ecae5476abd287892cf3310e1cf68f0f192",
            "filename": "deps/icu-small/source/i18n/shareddateformatsymbols.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fshareddateformatsymbols.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fshareddateformatsymbols.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fshareddateformatsymbols.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "2bc8e49625fe293e743fffd6e8a75fae8ea9b5ba",
            "filename": "deps/icu-small/source/i18n/smpdtfmt.cpp",
            "status": "modified",
            "additions": 33,
            "deletions": 33,
            "changes": 66,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fsmpdtfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fsmpdtfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fsmpdtfmt.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "dbf614469e831166c26cf64f230d43db462a2ae9",
            "filename": "deps/icu-small/source/i18n/timezone.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftimezone.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftimezone.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Ftimezone.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "4884773faf5ac3782776b365a3e3e832131cb805",
            "filename": "deps/icu-small/source/i18n/transreg.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftransreg.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftransreg.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Ftransreg.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "df4dec1febf60a791bc94bd1828931d3b4071f4d",
            "filename": "deps/icu-small/source/i18n/tzfmt.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftzfmt.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftzfmt.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Ftzfmt.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "5f5b7db30227cccdc928122302359d1f763fb2d1",
            "filename": "deps/icu-small/source/i18n/tzgnames.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftzgnames.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftzgnames.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Ftzgnames.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "5a79c22aacf8f970e421aac80c01edeee2e2b320",
            "filename": "deps/icu-small/source/i18n/tznames.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftznames.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftznames.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Ftznames.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "6a303ea4a0110f617a7c18f14d54583317e0562b",
            "filename": "deps/icu-small/source/i18n/tznames_impl.cpp",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftznames_impl.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Ftznames_impl.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Ftznames_impl.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "4c13b9ffcb539a32829572b22babf030409e5557",
            "filename": "deps/icu-small/source/i18n/ucln_in.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fucln_in.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fucln_in.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fucln_in.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "56ed5b3c19cacadb265808050c6f73c7ec255a74",
            "filename": "deps/icu-small/source/i18n/ucol_res.cpp",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fucol_res.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fucol_res.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fucol_res.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "b7d85cc179ef9a31107c461bc92d8a101c678a77",
            "filename": "deps/icu-small/source/i18n/udat.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fudat.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fudat.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fudat.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "c140c784b520cd554b193856c196d3194bf3ee86",
            "filename": "deps/icu-small/source/i18n/ulistformatter.cpp",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fulistformatter.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fulistformatter.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fulistformatter.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "previous_filename": "deps/icu-small/source/common/ulistformatter.cpp"
        },
        {
            "sha": "f651fee6fc4efa3ac8626f7aae68073b21003d02",
            "filename": "deps/icu-small/source/i18n/ulocdata.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fulocdata.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fulocdata.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fulocdata.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "4ebdf1cc56a1a8ea4e71f688de858e538f4ef1f6",
            "filename": "deps/icu-small/source/i18n/unicode/alphaindex.h",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Falphaindex.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Falphaindex.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Falphaindex.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "023cf053f254fb2e5b62e40b40a32387b270ca9f",
            "filename": "deps/icu-small/source/i18n/unicode/calendar.h",
            "status": "modified",
            "additions": 71,
            "deletions": 90,
            "changes": 161,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcalendar.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcalendar.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcalendar.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "653434f54ca664ed5c9ac5f9f8a0f0f6aca7a926",
            "filename": "deps/icu-small/source/i18n/unicode/coll.h",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcoll.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcoll.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcoll.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "9c1e9183f4657be2fd065db19b1045dd43e3220b",
            "filename": "deps/icu-small/source/i18n/unicode/compactdecimalformat.h",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcompactdecimalformat.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcompactdecimalformat.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcompactdecimalformat.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "80b046251323e9d9362076bee382c7a59bd411fd",
            "filename": "deps/icu-small/source/i18n/unicode/currpinf.h",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcurrpinf.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcurrpinf.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcurrpinf.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "48cadc10b704afb5215f49a8ea8c74e508dc4a0b",
            "filename": "deps/icu-small/source/i18n/unicode/currunit.h",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcurrunit.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcurrunit.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fcurrunit.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "13c63d937675eae425b9c64fdde226020708080b",
            "filename": "deps/icu-small/source/i18n/unicode/datefmt.h",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdatefmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdatefmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdatefmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "55e3d8a6b3b5ec8436d5f4f3488b493dfe481af5",
            "filename": "deps/icu-small/source/i18n/unicode/dcfmtsym.h",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdcfmtsym.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdcfmtsym.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdcfmtsym.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "b3a5cc0495f144742e612a905dc9eac8ae9f67a7",
            "filename": "deps/icu-small/source/i18n/unicode/decimfmt.h",
            "status": "modified",
            "additions": 38,
            "deletions": 31,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdecimfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdecimfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdecimfmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "26ccc64060f15afd215f039b3e22fc62c62adb81",
            "filename": "deps/icu-small/source/i18n/unicode/dtptngen.h",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdtptngen.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdtptngen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fdtptngen.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "a06c23dc3bd53258a09d98cc23807e3d65b71aec",
            "filename": "deps/icu-small/source/i18n/unicode/fmtable.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Ffmtable.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Ffmtable.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Ffmtable.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "b7c31cb554a6968731eacc01805769388f7e82a7",
            "filename": "deps/icu-small/source/i18n/unicode/gender.h",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fgender.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fgender.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fgender.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "5e36cf71cc54b738ca6c0f914f9d2c0b56fc9b4c",
            "filename": "deps/icu-small/source/i18n/unicode/listformatter.h",
            "status": "renamed",
            "additions": 34,
            "deletions": 2,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Flistformatter.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Flistformatter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Flistformatter.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "previous_filename": "deps/icu-small/source/common/unicode/listformatter.h"
        },
        {
            "sha": "bbdd2364bdd9979270fd974e949c9c9a52fe5b81",
            "filename": "deps/icu-small/source/i18n/unicode/measfmt.h",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasfmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "676fdeb9c8cd8aee7ae13a2e970861b323e18908",
            "filename": "deps/icu-small/source/i18n/unicode/measunit.h",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasunit.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasunit.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmeasunit.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "074d93354000ef28d1e69ba5cb928cf770b9618d",
            "filename": "deps/icu-small/source/i18n/unicode/msgfmt.h",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmsgfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmsgfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fmsgfmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "469949a2878eb4ee567871ff08a3960b6673f899",
            "filename": "deps/icu-small/source/i18n/unicode/numberformatter.h",
            "status": "modified",
            "additions": 87,
            "deletions": 32,
            "changes": 119,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumberformatter.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumberformatter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumberformatter.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "3e6248d934de6140ae188bad0cf52dfb6771c738",
            "filename": "deps/icu-small/source/i18n/unicode/numberrangeformatter.h",
            "status": "added",
            "additions": 866,
            "deletions": 0,
            "changes": 866,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumberrangeformatter.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumberrangeformatter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumberrangeformatter.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "871fbd93e15e2e8263f11f75e56ae153f51fe6f3",
            "filename": "deps/icu-small/source/i18n/unicode/numfmt.h",
            "status": "modified",
            "additions": 11,
            "deletions": 12,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fnumfmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "6b757c88419316416bb65c371f2eb9fd4e199558",
            "filename": "deps/icu-small/source/i18n/unicode/plurfmt.h",
            "status": "modified",
            "additions": 0,
            "deletions": 12,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fplurfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fplurfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fplurfmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "daeed52bee632e3118cad04315b5f6d543df6850",
            "filename": "deps/icu-small/source/i18n/unicode/plurrule.h",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fplurrule.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fplurrule.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fplurrule.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "f7cd85a322d1f52581133ed3f59a4b2e5e2a10e4",
            "filename": "deps/icu-small/source/i18n/unicode/rbnf.h",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Frbnf.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Frbnf.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Frbnf.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "ccd63901a5d1b1afce63a37f5ba613940b6e3075",
            "filename": "deps/icu-small/source/i18n/unicode/region.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fregion.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fregion.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fregion.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "dd8bc53d55f5009c547c2c7f4c758b15c484a8c0",
            "filename": "deps/icu-small/source/i18n/unicode/reldatefmt.h",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Freldatefmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Freldatefmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Freldatefmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "929c1b4675b407ccf923d5e5723b5f3e942c1872",
            "filename": "deps/icu-small/source/i18n/unicode/smpdtfmt.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fsmpdtfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fsmpdtfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fsmpdtfmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "6b4888145f1be51364b0500af25c080bad9f9c22",
            "filename": "deps/icu-small/source/i18n/unicode/translit.h",
            "status": "modified",
            "additions": 269,
            "deletions": 22,
            "changes": 291,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Ftranslit.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Ftranslit.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Ftranslit.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "d2aa768b8c8b34df47633a9d30d516c3b576cfdc",
            "filename": "deps/icu-small/source/i18n/unicode/tzfmt.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Ftzfmt.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Ftzfmt.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Ftzfmt.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "889a1ec51db52cc33bc530a076f48682e3cb1061",
            "filename": "deps/icu-small/source/i18n/unicode/ucal.h",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fucal.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fucal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fucal.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "f084ac61e614f3e799f81f2f0b0d1527e6217ab0",
            "filename": "deps/icu-small/source/i18n/unicode/ucol.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fucol.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fucol.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fucol.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "903f3dd5deebbe6d51339155108c349bbd10d5a1",
            "filename": "deps/icu-small/source/i18n/unicode/ugender.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fugender.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fugender.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fugender.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "242d7d216447624adcca5588f5e2c0ad95a28c74",
            "filename": "deps/icu-small/source/i18n/unicode/ulistformatter.h",
            "status": "renamed",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fulistformatter.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fulistformatter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fulistformatter.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b",
            "previous_filename": "deps/icu-small/source/common/unicode/ulistformatter.h"
        },
        {
            "sha": "d05b15cdeccafb6adec07cff673b4b8f1de21417",
            "filename": "deps/icu-small/source/i18n/unicode/unumberformatter.h",
            "status": "modified",
            "additions": 24,
            "deletions": 12,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Funumberformatter.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Funumberformatter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Funumberformatter.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "6b495ef00140f14c228570398e08cfce7badc760",
            "filename": "deps/icu-small/source/i18n/unicode/usearch.h",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fusearch.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fusearch.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fusearch.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "d15ba4b24235dcb0b727b28bc299aedc6034ded4",
            "filename": "deps/icu-small/source/i18n/unicode/uspoof.h",
            "status": "modified",
            "additions": 8,
            "deletions": 15,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fuspoof.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fuspoof.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Funicode%2Fuspoof.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "f504aec91bd7c35100f132547014c99b69ae2fd5",
            "filename": "deps/icu-small/source/i18n/uregex.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Furegex.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Furegex.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Furegex.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "0e4cca77a13ae08e66bf03b30be2723279287683",
            "filename": "deps/icu-small/source/i18n/usearch.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fusearch.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fusearch.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fusearch.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "7d6d0f76e34275386107272f658f3ca7821e90d1",
            "filename": "deps/icu-small/source/i18n/uspoof_impl.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fuspoof_impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fuspoof_impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fuspoof_impl.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "e39eada51b7f6116f7aad661d6e0a527965158d4",
            "filename": "deps/icu-small/source/i18n/vtzone.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fvtzone.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fvtzone.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fvtzone.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "b7139a807b3fb751be65d4431e7d626b17d03c2f",
            "filename": "deps/icu-small/source/i18n/zonemeta.cpp",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fzonemeta.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Fi18n%2Fzonemeta.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Fi18n%2Fzonemeta.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "1f6246d3cfbf46fe9b9be5c6820f3238c3cebe93",
            "filename": "deps/icu-small/source/tools/genrb/parse.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Fgenrb%2Fparse.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Fgenrb%2Fparse.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Fgenrb%2Fparse.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "0493347ebe519410f53cd5c82463ebfa6062dcd3",
            "filename": "deps/icu-small/source/tools/genrb/reslist.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Fgenrb%2Freslist.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Fgenrb%2Freslist.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Fgenrb%2Freslist.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "d7e5721c2d0fab6cded799bc752ddd68d2fe1938",
            "filename": "deps/icu-small/source/tools/pkgdata/pkgdata.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Fpkgdata%2Fpkgdata.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Fpkgdata%2Fpkgdata.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Fpkgdata%2Fpkgdata.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "a170c7b0f29e2eb50f9d4ae7380096deea0b87ca",
            "filename": "deps/icu-small/source/tools/toolutil/filestrm.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Ffilestrm.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Ffilestrm.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Ffilestrm.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "6e88c94b5200b5f6cee5d9819a74e4389a7a6869",
            "filename": "deps/icu-small/source/tools/toolutil/filetools.cpp",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Ffiletools.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Ffiletools.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Ffiletools.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "f4e428a37e7153f033c74a1a6f61db5b7093f303",
            "filename": "deps/icu-small/source/tools/toolutil/package.cpp",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fpackage.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fpackage.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fpackage.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "e8850cb98641680eeec41131278d4d96683842a4",
            "filename": "deps/icu-small/source/tools/toolutil/swapimpl.cpp",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fswapimpl.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fswapimpl.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fswapimpl.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "285f68a0ec66a1607c64003d8b266583b4f8f0fb",
            "filename": "deps/icu-small/source/tools/toolutil/udbgutil.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fudbgutil.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fudbgutil.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fudbgutil.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "22d8540881f45490182691f420dee04cd6e64d52",
            "filename": "deps/icu-small/source/tools/toolutil/unewdata.cpp",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Funewdata.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Funewdata.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Funewdata.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "1a1dd3964d34a2c762d353e3e6e48c6b945f1fc7",
            "filename": "deps/icu-small/source/tools/toolutil/writesrc.cpp",
            "status": "modified",
            "additions": 93,
            "deletions": 16,
            "changes": 109,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fwritesrc.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fwritesrc.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fwritesrc.cpp?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "35ba256793c03abd8c8e5412e9ae06e6417447a5",
            "filename": "deps/icu-small/source/tools/toolutil/writesrc.h",
            "status": "modified",
            "additions": 29,
            "deletions": 1,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fwritesrc.h",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fwritesrc.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Ficu-small%2Fsource%2Ftools%2Ftoolutil%2Fwritesrc.h?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        },
        {
            "sha": "ce0d89485ab31260312e68486e272a85daf485ec",
            "filename": "tools/icu/current_ver.dep",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/6786ff4d3688512d8b717ec24188818ac5493d0b/tools%2Ficu%2Fcurrent_ver.dep",
            "raw_url": "https://github.com/nodejs/node/raw/6786ff4d3688512d8b717ec24188818ac5493d0b/tools%2Ficu%2Fcurrent_ver.dep",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Ficu%2Fcurrent_ver.dep?ref=6786ff4d3688512d8b717ec24188818ac5493d0b"
        }
    ],
    "stats": {
        "total": 21891,
        "additions": 15760,
        "deletions": 6131
    }
}