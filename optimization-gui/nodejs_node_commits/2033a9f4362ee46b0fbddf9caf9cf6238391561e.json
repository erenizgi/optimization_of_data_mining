{
    "author": "TimothyGu",
    "message": "src: factor out some common vm functions\n\nPR-URL: https://github.com/nodejs/node/pull/17560\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>",
    "sha": "2033a9f4362ee46b0fbddf9caf9cf6238391561e",
    "files": [
        {
            "sha": "35b39d62e1fc77b371403160221d57a10d6b0afa",
            "filename": "src/node_contextify.cc",
            "status": "modified",
            "additions": 222,
            "deletions": 225,
            "changes": 447,
            "blob_url": "https://github.com/nodejs/node/blob/2033a9f4362ee46b0fbddf9caf9cf6238391561e/src%2Fnode_contextify.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2033a9f4362ee46b0fbddf9caf9cf6238391561e/src%2Fnode_contextify.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.cc?ref=2033a9f4362ee46b0fbddf9caf9cf6238391561e",
            "patch": "@@ -586,6 +586,227 @@ void ContextifyContext::IndexedPropertyDeleterCallback(\n   args.GetReturnValue().Set(false);\n }\n \n+Maybe<bool> GetBreakOnSigintArg(Environment* env,\n+                                Local<Value> options) {\n+  if (options->IsUndefined() || options->IsString()) {\n+    return Just(false);\n+  }\n+  if (!options->IsObject()) {\n+    env->ThrowTypeError(\"options must be an object\");\n+    return Nothing<bool>();\n+  }\n+\n+  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"breakOnSigint\");\n+  MaybeLocal<Value> maybe_value =\n+      options.As<Object>()->Get(env->context(), key);\n+  if (maybe_value.IsEmpty())\n+    return Nothing<bool>();\n+\n+  Local<Value> value = maybe_value.ToLocalChecked();\n+  return Just(value->IsTrue());\n+}\n+\n+Maybe<int64_t> GetTimeoutArg(Environment* env, Local<Value> options) {\n+  if (options->IsUndefined() || options->IsString()) {\n+    return Just<int64_t>(-1);\n+  }\n+  if (!options->IsObject()) {\n+    env->ThrowTypeError(\"options must be an object\");\n+    return Nothing<int64_t>();\n+  }\n+\n+  MaybeLocal<Value> maybe_value =\n+      options.As<Object>()->Get(env->context(), env->timeout_string());\n+  if (maybe_value.IsEmpty())\n+    return Nothing<int64_t>();\n+\n+  Local<Value> value = maybe_value.ToLocalChecked();\n+  if (value->IsUndefined()) {\n+    return Just<int64_t>(-1);\n+  }\n+\n+  Maybe<int64_t> timeout = value->IntegerValue(env->context());\n+\n+  if (timeout.IsJust() && timeout.ToChecked() <= 0) {\n+    env->ThrowRangeError(\"timeout must be a positive number\");\n+    return Nothing<int64_t>();\n+  }\n+\n+  return timeout;\n+}\n+\n+MaybeLocal<Integer> GetLineOffsetArg(Environment* env,\n+                                     Local<Value> options) {\n+  Local<Integer> defaultLineOffset = Integer::New(env->isolate(), 0);\n+\n+  if (!options->IsObject()) {\n+    return defaultLineOffset;\n+  }\n+\n+  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"lineOffset\");\n+  MaybeLocal<Value> maybe_value =\n+      options.As<Object>()->Get(env->context(), key);\n+  if (maybe_value.IsEmpty())\n+    return MaybeLocal<Integer>();\n+\n+  Local<Value> value = maybe_value.ToLocalChecked();\n+  if (value->IsUndefined())\n+    return defaultLineOffset;\n+\n+  return value->ToInteger(env->context());\n+}\n+\n+MaybeLocal<Integer> GetColumnOffsetArg(Environment* env,\n+                                       Local<Value> options) {\n+  Local<Integer> defaultColumnOffset = Integer::New(env->isolate(), 0);\n+\n+  if (!options->IsObject()) {\n+    return defaultColumnOffset;\n+  }\n+\n+  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"columnOffset\");\n+  MaybeLocal<Value> maybe_value =\n+    options.As<Object>()->Get(env->context(), key);\n+  if (maybe_value.IsEmpty())\n+    return MaybeLocal<Integer>();\n+\n+  Local<Value> value = maybe_value.ToLocalChecked();\n+  if (value->IsUndefined())\n+    return defaultColumnOffset;\n+\n+  return value->ToInteger(env->context());\n+}\n+\n+MaybeLocal<Context> GetContextArg(Environment* env,\n+                                  Local<Value> options) {\n+  if (!options->IsObject())\n+    return MaybeLocal<Context>();\n+\n+  MaybeLocal<Value> maybe_value =\n+      options.As<Object>()->Get(env->context(),\n+                                env->vm_parsing_context_symbol());\n+  Local<Value> value;\n+  if (!maybe_value.ToLocal(&value))\n+    return MaybeLocal<Context>();\n+\n+  if (!value->IsObject()) {\n+    if (!value->IsNullOrUndefined()) {\n+      env->ThrowTypeError(\n+          \"contextifiedSandbox argument must be an object.\");\n+    }\n+    return MaybeLocal<Context>();\n+  }\n+\n+  ContextifyContext* sandbox =\n+      ContextifyContext::ContextFromContextifiedSandbox(\n+          env, value.As<Object>());\n+  if (!sandbox) {\n+    env->ThrowTypeError(\n+        \"sandbox argument must have been converted to a context.\");\n+    return MaybeLocal<Context>();\n+  }\n+\n+  Local<Context> context = sandbox->context();\n+  if (context.IsEmpty())\n+    return MaybeLocal<Context>();\n+  return context;\n+}\n+\n+namespace {\n+\n+Maybe<bool> GetDisplayErrorsArg(Environment* env,\n+                                Local<Value> options) {\n+  if (options->IsUndefined() || options->IsString()) {\n+    return Just(true);\n+  }\n+  if (!options->IsObject()) {\n+    env->ThrowTypeError(\"options must be an object\");\n+    return Nothing<bool>();\n+  }\n+\n+  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"displayErrors\");\n+  MaybeLocal<Value> maybe_value =\n+      options.As<Object>()->Get(env->context(), key);\n+  if (maybe_value.IsEmpty())\n+    return Nothing<bool>();\n+\n+  Local<Value> value = maybe_value.ToLocalChecked();\n+  if (value->IsUndefined())\n+    return Just(true);\n+\n+  return value->BooleanValue(env->context());\n+}\n+\n+MaybeLocal<String> GetFilenameArg(Environment* env,\n+                                  Local<Value> options) {\n+  Local<String> defaultFilename =\n+      FIXED_ONE_BYTE_STRING(env->isolate(), \"evalmachine.<anonymous>\");\n+\n+  if (options->IsUndefined()) {\n+    return defaultFilename;\n+  }\n+  if (options->IsString()) {\n+    return options.As<String>();\n+  }\n+  if (!options->IsObject()) {\n+    env->ThrowTypeError(\"options must be an object\");\n+    return Local<String>();\n+  }\n+\n+  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"filename\");\n+  MaybeLocal<Value> maybe_value =\n+      options.As<Object>()->Get(env->context(), key);\n+  if (maybe_value.IsEmpty())\n+    return MaybeLocal<String>();\n+\n+  Local<Value> value = maybe_value.ToLocalChecked();\n+  if (value->IsUndefined())\n+    return defaultFilename;\n+  return value->ToString(env->context());\n+}\n+\n+MaybeLocal<Uint8Array> GetCachedData(Environment* env,\n+                                     Local<Value> options) {\n+  if (!options->IsObject()) {\n+    return MaybeLocal<Uint8Array>();\n+  }\n+\n+  MaybeLocal<Value> maybe_value =\n+      options.As<Object>()->Get(env->context(), env->cached_data_string());\n+  if (maybe_value.IsEmpty())\n+    return MaybeLocal<Uint8Array>();\n+\n+  Local<Value> value = maybe_value.ToLocalChecked();\n+  if (value->IsUndefined()) {\n+    return MaybeLocal<Uint8Array>();\n+  }\n+\n+  if (!value->IsUint8Array()) {\n+    env->ThrowTypeError(\"options.cachedData must be a Buffer instance\");\n+    return MaybeLocal<Uint8Array>();\n+  }\n+\n+  return value.As<Uint8Array>();\n+}\n+\n+Maybe<bool> GetProduceCachedData(Environment* env,\n+                                 Local<Value> options) {\n+  if (!options->IsObject()) {\n+    return Just(false);\n+  }\n+\n+  MaybeLocal<Value> maybe_value =\n+      options.As<Object>()->Get(env->context(),\n+                                env->produce_cached_data_string());\n+  if (maybe_value.IsEmpty())\n+    return Nothing<bool>();\n+\n+  Local<Value> value = maybe_value.ToLocalChecked();\n+  return Just(value->IsTrue());\n+}\n+\n+}  // anonymous namespace\n+\n class ContextifyScript : public BaseObject {\n  private:\n   Persistent<UnboundScript> script_;\n@@ -639,7 +860,7 @@ class ContextifyScript : public BaseObject {\n     MaybeLocal<Integer> columnOffset = GetColumnOffsetArg(env, options);\n     MaybeLocal<Uint8Array> cached_data_buf = GetCachedData(env, options);\n     Maybe<bool> maybe_produce_cached_data = GetProduceCachedData(env, options);\n-    MaybeLocal<Context> maybe_context = GetContext(env, options);\n+    MaybeLocal<Context> maybe_context = GetContextArg(env, options);\n     if (try_catch.HasCaught()) {\n       no_abort_scope.Close();\n       try_catch.ReThrow();\n@@ -831,230 +1052,6 @@ class ContextifyScript : public BaseObject {\n         True(env->isolate()));\n   }\n \n-  static Maybe<bool> GetBreakOnSigintArg(Environment* env,\n-                                         Local<Value> options) {\n-    if (options->IsUndefined() || options->IsString()) {\n-      return Just(false);\n-    }\n-    if (!options->IsObject()) {\n-      env->ThrowTypeError(\"options must be an object\");\n-      return Nothing<bool>();\n-    }\n-\n-    Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"breakOnSigint\");\n-    MaybeLocal<Value> maybe_value =\n-        options.As<Object>()->Get(env->context(), key);\n-    if (maybe_value.IsEmpty())\n-      return Nothing<bool>();\n-\n-    Local<Value> value = maybe_value.ToLocalChecked();\n-    return Just(value->IsTrue());\n-  }\n-\n-  static Maybe<int64_t> GetTimeoutArg(Environment* env, Local<Value> options) {\n-    if (options->IsUndefined() || options->IsString()) {\n-      return Just<int64_t>(-1);\n-    }\n-    if (!options->IsObject()) {\n-      env->ThrowTypeError(\"options must be an object\");\n-      return Nothing<int64_t>();\n-    }\n-\n-    MaybeLocal<Value> maybe_value =\n-        options.As<Object>()->Get(env->context(), env->timeout_string());\n-    if (maybe_value.IsEmpty())\n-      return Nothing<int64_t>();\n-\n-    Local<Value> value = maybe_value.ToLocalChecked();\n-    if (value->IsUndefined()) {\n-      return Just<int64_t>(-1);\n-    }\n-\n-    Maybe<int64_t> timeout = value->IntegerValue(env->context());\n-\n-    if (timeout.IsJust() && timeout.ToChecked() <= 0) {\n-      env->ThrowRangeError(\"timeout must be a positive number\");\n-      return Nothing<int64_t>();\n-    }\n-\n-    return timeout;\n-  }\n-\n-\n-  static Maybe<bool> GetDisplayErrorsArg(Environment* env,\n-                                         Local<Value> options) {\n-    if (options->IsUndefined() || options->IsString()) {\n-      return Just(true);\n-    }\n-    if (!options->IsObject()) {\n-      env->ThrowTypeError(\"options must be an object\");\n-      return Nothing<bool>();\n-    }\n-\n-    Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"displayErrors\");\n-    MaybeLocal<Value> maybe_value =\n-        options.As<Object>()->Get(env->context(), key);\n-    if (maybe_value.IsEmpty())\n-      return Nothing<bool>();\n-\n-    Local<Value> value = maybe_value.ToLocalChecked();\n-    if (value->IsUndefined())\n-      return Just(true);\n-\n-    return value->BooleanValue(env->context());\n-  }\n-\n-\n-  static MaybeLocal<String> GetFilenameArg(Environment* env,\n-                                           Local<Value> options) {\n-    Local<String> defaultFilename =\n-        FIXED_ONE_BYTE_STRING(env->isolate(), \"evalmachine.<anonymous>\");\n-\n-    if (options->IsUndefined()) {\n-      return defaultFilename;\n-    }\n-    if (options->IsString()) {\n-      return options.As<String>();\n-    }\n-    if (!options->IsObject()) {\n-      env->ThrowTypeError(\"options must be an object\");\n-      return Local<String>();\n-    }\n-\n-    Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"filename\");\n-    MaybeLocal<Value> maybe_value =\n-        options.As<Object>()->Get(env->context(), key);\n-    if (maybe_value.IsEmpty())\n-      return MaybeLocal<String>();\n-\n-    Local<Value> value = maybe_value.ToLocalChecked();\n-    if (value->IsUndefined())\n-      return defaultFilename;\n-    return value->ToString(env->context());\n-  }\n-\n-\n-  static MaybeLocal<Uint8Array> GetCachedData(Environment* env,\n-                                              Local<Value> options) {\n-    if (!options->IsObject()) {\n-      return MaybeLocal<Uint8Array>();\n-    }\n-\n-    MaybeLocal<Value> maybe_value =\n-        options.As<Object>()->Get(env->context(), env->cached_data_string());\n-    if (maybe_value.IsEmpty())\n-      return MaybeLocal<Uint8Array>();\n-\n-    Local<Value> value = maybe_value.ToLocalChecked();\n-    if (value->IsUndefined()) {\n-      return MaybeLocal<Uint8Array>();\n-    }\n-\n-    if (!value->IsUint8Array()) {\n-      env->ThrowTypeError(\"options.cachedData must be a Buffer instance\");\n-      return MaybeLocal<Uint8Array>();\n-    }\n-\n-    return value.As<Uint8Array>();\n-  }\n-\n-\n-  static Maybe<bool> GetProduceCachedData(Environment* env,\n-                                          Local<Value> options) {\n-    if (!options->IsObject()) {\n-      return Just(false);\n-    }\n-\n-    MaybeLocal<Value> maybe_value =\n-        options.As<Object>()->Get(env->context(),\n-                                  env->produce_cached_data_string());\n-    if (maybe_value.IsEmpty())\n-      return Nothing<bool>();\n-\n-    Local<Value> value = maybe_value.ToLocalChecked();\n-    return Just(value->IsTrue());\n-  }\n-\n-\n-  static MaybeLocal<Integer> GetLineOffsetArg(Environment* env,\n-                                              Local<Value> options) {\n-    Local<Integer> defaultLineOffset = Integer::New(env->isolate(), 0);\n-\n-    if (!options->IsObject()) {\n-      return defaultLineOffset;\n-    }\n-\n-    Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"lineOffset\");\n-    MaybeLocal<Value> maybe_value =\n-        options.As<Object>()->Get(env->context(), key);\n-    if (maybe_value.IsEmpty())\n-      return MaybeLocal<Integer>();\n-\n-    Local<Value> value = maybe_value.ToLocalChecked();\n-    if (value->IsUndefined())\n-      return defaultLineOffset;\n-\n-    return value->ToInteger(env->context());\n-  }\n-\n-\n-  static MaybeLocal<Integer> GetColumnOffsetArg(Environment* env,\n-                                                Local<Value> options) {\n-    Local<Integer> defaultColumnOffset = Integer::New(env->isolate(), 0);\n-\n-    if (!options->IsObject()) {\n-      return defaultColumnOffset;\n-    }\n-\n-    Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"columnOffset\");\n-    MaybeLocal<Value> maybe_value =\n-      options.As<Object>()->Get(env->context(), key);\n-    if (maybe_value.IsEmpty())\n-      return MaybeLocal<Integer>();\n-\n-    Local<Value> value = maybe_value.ToLocalChecked();\n-    if (value->IsUndefined())\n-      return defaultColumnOffset;\n-\n-    return value->ToInteger(env->context());\n-  }\n-\n-  static MaybeLocal<Context> GetContext(Environment* env,\n-                                        Local<Value> options) {\n-    if (!options->IsObject())\n-      return MaybeLocal<Context>();\n-\n-    MaybeLocal<Value> maybe_value =\n-        options.As<Object>()->Get(env->context(),\n-                                  env->vm_parsing_context_symbol());\n-    Local<Value> value;\n-    if (!maybe_value.ToLocal(&value))\n-      return MaybeLocal<Context>();\n-\n-    if (!value->IsObject()) {\n-      if (!value->IsNullOrUndefined()) {\n-        env->ThrowTypeError(\n-            \"contextifiedSandbox argument must be an object.\");\n-      }\n-      return MaybeLocal<Context>();\n-    }\n-\n-    ContextifyContext* sandbox =\n-        ContextifyContext::ContextFromContextifiedSandbox(\n-            env, value.As<Object>());\n-    if (!sandbox) {\n-      env->ThrowTypeError(\n-          \"sandbox argument must have been converted to a context.\");\n-      return MaybeLocal<Context>();\n-    }\n-\n-    Local<Context> context = sandbox->context();\n-    if (context.IsEmpty())\n-      return MaybeLocal<Context>();\n-    return context;\n-  }\n-\n-\n   static bool EvalMachine(Environment* env,\n                           const int64_t timeout,\n                           const bool display_errors,"
        },
        {
            "sha": "b2f32850ac1c437b23ec08dca165a3bbd43ac060",
            "filename": "src/node_contextify.h",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/2033a9f4362ee46b0fbddf9caf9cf6238391561e/src%2Fnode_contextify.h",
            "raw_url": "https://github.com/nodejs/node/raw/2033a9f4362ee46b0fbddf9caf9cf6238391561e/src%2Fnode_contextify.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.h?ref=2033a9f4362ee46b0fbddf9caf9cf6238391561e",
            "patch": "@@ -92,6 +92,17 @@ class ContextifyContext {\n       const v8::PropertyCallbackInfo<v8::Boolean>& args);\n };\n \n+v8::Maybe<bool> GetBreakOnSigintArg(\n+    Environment* env, v8::Local<v8::Value> options);\n+v8::Maybe<int64_t> GetTimeoutArg(\n+    Environment* env, v8::Local<v8::Value> options);\n+v8::MaybeLocal<v8::Integer> GetLineOffsetArg(\n+    Environment* env, v8::Local<v8::Value> options);\n+v8::MaybeLocal<v8::Integer> GetColumnOffsetArg(\n+    Environment* env, v8::Local<v8::Value> options);\n+v8::MaybeLocal<v8::Context> GetContextArg(\n+    Environment* env, v8::Local<v8::Value> options);\n+\n }  // namespace contextify\n }  // namespace node\n "
        }
    ],
    "stats": {
        "total": 458,
        "additions": 233,
        "deletions": 225
    }
}