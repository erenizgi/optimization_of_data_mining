{
    "author": "apapirovski",
    "message": "lib: expose FixedQueue internally and fix nextTick bug\n\nA bug was introduced together with the FixedQueue implementation for\nprocess.nextTick which meant that the queue wouldn't necessarily\nfully clear on each run through. Fix it and abstract the data\nstructure into an internal module that can later be used elsewhere.\n\nPR-URL: https://github.com/nodejs/node/pull/20468\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d",
    "files": [
        {
            "sha": "7571a8f67e36d27442a417289ab873f8c0306078",
            "filename": "lib/internal/fixed_queue.js",
            "status": "added",
            "additions": 113,
            "deletions": 0,
            "changes": 113,
            "blob_url": "https://github.com/nodejs/node/blob/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/lib%2Finternal%2Ffixed_queue.js",
            "raw_url": "https://github.com/nodejs/node/raw/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/lib%2Finternal%2Ffixed_queue.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffixed_queue.js?ref=9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d",
            "patch": "@@ -0,0 +1,113 @@\n+'use strict';\n+\n+// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\n+const kSize = 2048;\n+const kMask = kSize - 1;\n+\n+// The FixedQueue is implemented as a singly-linked list of fixed-size\n+// circular buffers. It looks something like this:\n+//\n+//  head                                                       tail\n+//    |                                                          |\n+//    v                                                          v\n+// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n+// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n+// +-----------+               +-----------+                  +-----------+\n+// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n+// |   item    |               |   item    |                  |  [empty]  |\n+// |   item    |               |   item    |                  |  [empty]  |\n+// |   item    |               |   item    |                  |  [empty]  |\n+// |   item    |               |   item    |       bottom --> |   item    |\n+// |   item    |               |   item    |                  |   item    |\n+// |    ...    |               |    ...    |                  |    ...    |\n+// |   item    |               |   item    |                  |   item    |\n+// |   item    |               |   item    |                  |   item    |\n+// |  [empty]  | <-- top       |   item    |                  |   item    |\n+// |  [empty]  |               |   item    |                  |   item    |\n+// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n+// +-----------+               +-----------+                  +-----------+\n+//\n+// Or, if there is only one circular buffer, it looks something\n+// like either of these:\n+//\n+//  head   tail                                 head   tail\n+//    |     |                                     |     |\n+//    v     v                                     v     v\n+// +-----------+                               +-----------+\n+// |  [null]   |                               |  [null]   |\n+// +-----------+                               +-----------+\n+// |  [empty]  |                               |   item    |\n+// |  [empty]  |                               |   item    |\n+// |   item    | <-- bottom            top --> |  [empty]  |\n+// |   item    |                               |  [empty]  |\n+// |  [empty]  | <-- top            bottom --> |   item    |\n+// |  [empty]  |                               |   item    |\n+// +-----------+                               +-----------+\n+//\n+// Adding a value means moving `top` forward by one, removing means\n+// moving `bottom` forward by one. After reaching the end, the queue\n+// wraps around.\n+//\n+// When `top === bottom` the current queue is empty and when\n+// `top + 1 === bottom` it's full. This wastes a single space of storage\n+// but allows much quicker checks.\n+\n+const FixedCircularBuffer = class FixedCircularBuffer {\n+  constructor() {\n+    this.bottom = 0;\n+    this.top = 0;\n+    this.list = new Array(kSize);\n+    this.next = null;\n+  }\n+\n+  isEmpty() {\n+    return this.top === this.bottom;\n+  }\n+\n+  isFull() {\n+    return ((this.top + 1) & kMask) === this.bottom;\n+  }\n+\n+  push(data) {\n+    this.list[this.top] = data;\n+    this.top = (this.top + 1) & kMask;\n+  }\n+\n+  shift() {\n+    const nextItem = this.list[this.bottom];\n+    if (nextItem === undefined)\n+      return null;\n+    this.list[this.bottom] = undefined;\n+    this.bottom = (this.bottom + 1) & kMask;\n+    return nextItem;\n+  }\n+};\n+\n+module.exports = class FixedQueue {\n+  constructor() {\n+    this.head = this.tail = new FixedCircularBuffer();\n+  }\n+\n+  isEmpty() {\n+    return this.head.isEmpty();\n+  }\n+\n+  push(data) {\n+    if (this.head.isFull()) {\n+      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n+      // and sets it as the new main queue.\n+      this.head = this.head.next = new FixedCircularBuffer();\n+    }\n+    this.head.push(data);\n+  }\n+\n+  shift() {\n+    const { tail } = this;\n+    const next = tail.shift();\n+    if (tail.isEmpty() && tail.next !== null) {\n+      // If there is another queue, it forms the new tail.\n+      this.tail = tail.next;\n+    }\n+    return next;\n+  }\n+};"
        },
        {
            "sha": "dbe0ce8cdbdacf2b7f61f9e74a0125499205626d",
            "filename": "lib/internal/process/next_tick.js",
            "status": "modified",
            "additions": 8,
            "deletions": 116,
            "changes": 124,
            "blob_url": "https://github.com/nodejs/node/blob/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/lib%2Finternal%2Fprocess%2Fnext_tick.js",
            "raw_url": "https://github.com/nodejs/node/raw/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/lib%2Finternal%2Fprocess%2Fnext_tick.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fnext_tick.js?ref=9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d",
            "patch": "@@ -16,6 +16,7 @@ function setupNextTick() {\n   } = require('internal/async_hooks');\n   const promises = require('internal/process/promises');\n   const { ERR_INVALID_CALLBACK } = require('internal/errors').codes;\n+  const FixedQueue = require('internal/fixed_queue');\n   const { emitPromiseRejectionWarnings } = promises;\n \n   // tickInfo is used so that the C++ code in src/node.cc can\n@@ -31,119 +32,7 @@ function setupNextTick() {\n   const kHasScheduled = 0;\n   const kHasPromiseRejections = 1;\n \n-  // Queue size for each tick array. Must be a power of two.\n-  const kQueueSize = 2048;\n-  const kQueueMask = kQueueSize - 1;\n-\n-  // The next tick queue is implemented as a singly-linked list of fixed-size\n-  // circular buffers. It looks something like this:\n-  //\n-  //  head                                                       tail\n-  //    |                                                          |\n-  //    v                                                          v\n-  // +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n-  // |  [null]   |        \\----- |   next    |         \\------- |   next    |\n-  // +-----------+               +-----------+                  +-----------+\n-  // |   tick    | <-- bottom    |   tick    | <-- bottom       |  [empty]  |\n-  // |   tick    |               |   tick    |                  |  [empty]  |\n-  // |   tick    |               |   tick    |                  |  [empty]  |\n-  // |   tick    |               |   tick    |                  |  [empty]  |\n-  // |   tick    |               |   tick    |       bottom --> |   tick    |\n-  // |   tick    |               |   tick    |                  |   tick    |\n-  // |    ...    |               |    ...    |                  |    ...    |\n-  // |   tick    |               |   tick    |                  |   tick    |\n-  // |   tick    |               |   tick    |                  |   tick    |\n-  // |  [empty]  | <-- top       |   tick    |                  |   tick    |\n-  // |  [empty]  |               |   tick    |                  |   tick    |\n-  // |  [empty]  |               |   tick    |                  |   tick    |\n-  // +-----------+               +-----------+ <-- top  top --> +-----------+\n-  //\n-  // Or, if there is only one fixed-size queue, it looks something\n-  // like either of these:\n-  //\n-  //  head   tail                                 head   tail\n-  //    |     |                                     |     |\n-  //    v     v                                     v     v\n-  // +-----------+                               +-----------+\n-  // |  [null]   |                               |  [null]   |\n-  // +-----------+                               +-----------+\n-  // |  [empty]  |                               |   tick    |\n-  // |  [empty]  |                               |   tick    |\n-  // |   tick    | <-- bottom            top --> |  [empty]  |\n-  // |   tick    |                               |  [empty]  |\n-  // |  [empty]  | <-- top            bottom --> |   tick    |\n-  // |  [empty]  |                               |   tick    |\n-  // +-----------+                               +-----------+\n-  //\n-  // Adding a value means moving `top` forward by one, removing means\n-  // moving `bottom` forward by one.\n-  //\n-  // We let `bottom` and `top` wrap around, so when `top` is conceptually\n-  // pointing to the end of the list, that means that the actual value is `0`.\n-  //\n-  // In particular, when `top === bottom`, this can mean *either* that the\n-  // current queue is empty or that it is full. We can differentiate by\n-  // checking whether an entry in the queue is empty (a.k.a. `=== undefined`).\n-\n-  class FixedQueue {\n-    constructor() {\n-      this.bottom = 0;\n-      this.top = 0;\n-      this.list = new Array(kQueueSize);\n-      this.next = null;\n-    }\n-\n-    push(data) {\n-      this.list[this.top] = data;\n-      this.top = (this.top + 1) & kQueueMask;\n-    }\n-\n-    shift() {\n-      const nextItem = this.list[this.bottom];\n-      if (nextItem === undefined)\n-        return null;\n-      this.list[this.bottom] = undefined;\n-      this.bottom = (this.bottom + 1) & kQueueMask;\n-      return nextItem;\n-    }\n-  }\n-\n-  var head = new FixedQueue();\n-  var tail = head;\n-\n-  function push(data) {\n-    if (head.bottom === head.top) {\n-      // Either empty or full:\n-      if (head.list[head.top] !== undefined) {\n-        // It's full: Creates a new queue, sets the old queue's `.next` to it,\n-        // and sets it as the new main queue.\n-        head = head.next = new FixedQueue();\n-      } else {\n-        // If the head is empty, that means that it was the only fixed-sized\n-        // queue in existence.\n-        DCHECK_EQ(head.next, null);\n-        // This is the first tick object in existence, so we need to inform\n-        // the C++ side that we do want to run `_tickCallback()`.\n-        tickInfo[kHasScheduled] = 1;\n-      }\n-    }\n-    head.push(data);\n-  }\n-\n-  function shift() {\n-    const next = tail.shift();\n-    if (tail.top === tail.bottom) { // -> .shift() emptied the current queue.\n-      if (tail.next !== null) {\n-        // If there is another queue, it forms the new tail.\n-        tail = tail.next;\n-      } else {\n-        // We've just run out of items. Let the native side know that it\n-        // doesn't need to bother calling into JS to run the queue.\n-        tickInfo[kHasScheduled] = 0;\n-      }\n-    }\n-    return next;\n-  }\n+  const queue = new FixedQueue();\n \n   process.nextTick = nextTick;\n   // Needs to be accessible from beyond this scope.\n@@ -152,7 +41,7 @@ function setupNextTick() {\n   function _tickCallback() {\n     let tock;\n     do {\n-      while (tock = shift()) {\n+      while (tock = queue.shift()) {\n         const asyncId = tock[async_id_symbol];\n         emitBefore(asyncId, tock[trigger_async_id_symbol]);\n         // emitDestroy() places the async_id_symbol into an asynchronous queue\n@@ -175,8 +64,9 @@ function setupNextTick() {\n \n         emitAfter(asyncId);\n       }\n+      tickInfo[kHasScheduled] = 0;\n       runMicrotasks();\n-    } while (head.top !== head.bottom || emitPromiseRejectionWarnings());\n+    } while (!queue.isEmpty() || emitPromiseRejectionWarnings());\n     tickInfo[kHasPromiseRejections] = 0;\n   }\n \n@@ -222,6 +112,8 @@ function setupNextTick() {\n           args[i - 1] = arguments[i];\n     }\n \n-    push(new TickObject(callback, args, getDefaultTriggerAsyncId()));\n+    if (queue.isEmpty())\n+      tickInfo[kHasScheduled] = 1;\n+    queue.push(new TickObject(callback, args, getDefaultTriggerAsyncId()));\n   }\n }"
        },
        {
            "sha": "3e513a4a71ceb8b33e85ed43d941db919a12e1c4",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d",
            "patch": "@@ -101,6 +101,7 @@\n       'lib/internal/constants.js',\n       'lib/internal/encoding.js',\n       'lib/internal/errors.js',\n+      'lib/internal/fixed_queue.js',\n       'lib/internal/freelist.js',\n       'lib/internal/fs.js',\n       'lib/internal/http.js',"
        },
        {
            "sha": "a50be1309a5ea8da4648fef27ed856b73745915b",
            "filename": "test/parallel/test-fixed-queue.js",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/test%2Fparallel%2Ftest-fixed-queue.js",
            "raw_url": "https://github.com/nodejs/node/raw/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/test%2Fparallel%2Ftest-fixed-queue.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fixed-queue.js?ref=9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d",
            "patch": "@@ -0,0 +1,34 @@\n+// Flags: --expose-internals\n+'use strict';\n+\n+require('../common');\n+\n+const assert = require('assert');\n+const FixedQueue = require('internal/fixed_queue');\n+\n+{\n+  const queue = new FixedQueue();\n+  assert.strictEqual(queue.head, queue.tail);\n+  assert(queue.isEmpty());\n+  queue.push('a');\n+  assert(!queue.isEmpty());\n+  assert.strictEqual(queue.shift(), 'a');\n+  assert.strictEqual(queue.shift(), null);\n+}\n+\n+{\n+  const queue = new FixedQueue();\n+  for (let i = 0; i < 2047; i++)\n+    queue.push('a');\n+  assert(queue.head.isFull());\n+  queue.push('a');\n+  assert(!queue.head.isFull());\n+\n+  assert.notStrictEqual(queue.head, queue.tail);\n+  for (let i = 0; i < 2047; i++)\n+    assert.strictEqual(queue.shift(), 'a');\n+  assert.strictEqual(queue.head, queue.tail);\n+  assert(!queue.isEmpty());\n+  assert.strictEqual(queue.shift(), 'a');\n+  assert(queue.isEmpty());\n+}"
        },
        {
            "sha": "1fe82d02b10907f2746b44d7d21a7312842f3daa",
            "filename": "test/parallel/test-next-tick-fixed-queue-regression.js",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/test%2Fparallel%2Ftest-next-tick-fixed-queue-regression.js",
            "raw_url": "https://github.com/nodejs/node/raw/9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d/test%2Fparallel%2Ftest-next-tick-fixed-queue-regression.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-next-tick-fixed-queue-regression.js?ref=9a3ae2fe9d6ddff6a0de81acb5e0a8c068c0c79d",
            "patch": "@@ -0,0 +1,18 @@\n+'use strict';\n+\n+const common = require('../common');\n+\n+// This tests a highly specific regression tied to the FixedQueue size, which\n+// was introduced in Node.js 9.7.0: https://github.com/nodejs/node/pull/18617\n+// More specifically, a nextTick list could potentially end up not fully\n+// clearing in one run through if exactly 2048 ticks were added after\n+// microtasks were executed within the nextTick loop.\n+\n+process.nextTick(() => {\n+  Promise.resolve(1).then(() => {\n+    for (let i = 0; i < 2047; i++)\n+      process.nextTick(common.mustCall());\n+    const immediate = setImmediate(common.mustNotCall());\n+    process.nextTick(common.mustCall(() => clearImmediate(immediate)));\n+  });\n+});"
        }
    ],
    "stats": {
        "total": 290,
        "additions": 174,
        "deletions": 116
    }
}