{
    "author": "jasnell",
    "message": "src: move getActiveResources/Handles to node_process.cc\n\nPR-URL: https://github.com/nodejs/node/pull/22758\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "efd4796fa905747985d6de215d5e64b4701cf347",
    "files": [
        {
            "sha": "ed4da64425ad18939e7d52ed6e9f5cce8161f545",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/efd4796fa905747985d6de215d5e64b4701cf347/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/efd4796fa905747985d6de215d5e64b4701cf347/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=efd4796fa905747985d6de215d5e64b4701cf347",
            "patch": "@@ -1040,61 +1040,6 @@ static MaybeLocal<Value> ExecuteString(Environment* env,\n }\n \n \n-static void GetActiveRequests(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  Local<Array> ary = Array::New(args.GetIsolate());\n-  Local<Context> ctx = env->context();\n-  Local<Function> fn = env->push_values_to_array_function();\n-  Local<Value> argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n-  size_t idx = 0;\n-\n-  for (auto w : *env->req_wrap_queue()) {\n-    if (w->persistent().IsEmpty())\n-      continue;\n-    argv[idx] = w->GetOwner();\n-    if (++idx >= arraysize(argv)) {\n-      fn->Call(ctx, ary, idx, argv).ToLocalChecked();\n-      idx = 0;\n-    }\n-  }\n-\n-  if (idx > 0) {\n-    fn->Call(ctx, ary, idx, argv).ToLocalChecked();\n-  }\n-\n-  args.GetReturnValue().Set(ary);\n-}\n-\n-\n-// Non-static, friend of HandleWrap. Could have been a HandleWrap method but\n-// implemented here for consistency with GetActiveRequests().\n-void GetActiveHandles(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  Local<Array> ary = Array::New(env->isolate());\n-  Local<Context> ctx = env->context();\n-  Local<Function> fn = env->push_values_to_array_function();\n-  Local<Value> argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n-  size_t idx = 0;\n-\n-  for (auto w : *env->handle_wrap_queue()) {\n-    if (!HandleWrap::HasRef(w))\n-      continue;\n-    argv[idx] = w->GetOwner();\n-    if (++idx >= arraysize(argv)) {\n-      fn->Call(ctx, ary, idx, argv).ToLocalChecked();\n-      idx = 0;\n-    }\n-  }\n-  if (idx > 0) {\n-    fn->Call(ctx, ary, idx, argv).ToLocalChecked();\n-  }\n-\n-  args.GetReturnValue().Set(ary);\n-}\n-\n-\n NO_RETURN void Abort() {\n   DumpBacktrace(stderr);\n   fflush(stderr);"
        },
        {
            "sha": "8ab79a12676276e6688cdd5a2101a4ad0172b5d7",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/efd4796fa905747985d6de215d5e64b4701cf347/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/efd4796fa905747985d6de215d5e64b4701cf347/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=efd4796fa905747985d6de215d5e64b4701cf347",
            "patch": "@@ -883,6 +883,8 @@ void Abort(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Chdir(const v8::FunctionCallbackInfo<v8::Value>& args);\n void CPUUsage(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Cwd(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void GetActiveHandles(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void GetActiveRequests(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Hrtime(const v8::FunctionCallbackInfo<v8::Value>& args);\n void HrtimeBigInt(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Kill(const v8::FunctionCallbackInfo<v8::Value>& args);"
        },
        {
            "sha": "19596f0cfd261d74cd8035b66bb8dbe4be67a815",
            "filename": "src/node_process.cc",
            "status": "modified",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/efd4796fa905747985d6de215d5e64b4701cf347/src%2Fnode_process.cc",
            "raw_url": "https://github.com/nodejs/node/raw/efd4796fa905747985d6de215d5e64b4701cf347/src%2Fnode_process.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_process.cc?ref=efd4796fa905747985d6de215d5e64b4701cf347",
            "patch": "@@ -1,5 +1,7 @@\n #include \"node.h\"\n #include \"node_internals.h\"\n+#include \"base_object.h\"\n+#include \"base_object-inl.h\"\n #include \"env-inl.h\"\n #include \"util-inl.h\"\n #include \"uv.h\"\n@@ -786,5 +788,58 @@ void GetParentProcessId(Local<Name> property,\n   info.GetReturnValue().Set(Integer::New(info.GetIsolate(), uv_os_getppid()));\n }\n \n+void GetActiveRequests(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  Local<Array> ary = Array::New(args.GetIsolate());\n+  Local<Context> ctx = env->context();\n+  Local<Function> fn = env->push_values_to_array_function();\n+  Local<Value> argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n+  size_t idx = 0;\n+\n+  for (auto w : *env->req_wrap_queue()) {\n+    if (w->persistent().IsEmpty())\n+      continue;\n+    argv[idx] = w->GetOwner();\n+    if (++idx >= arraysize(argv)) {\n+      fn->Call(ctx, ary, idx, argv).ToLocalChecked();\n+      idx = 0;\n+    }\n+  }\n+\n+  if (idx > 0) {\n+    fn->Call(ctx, ary, idx, argv).ToLocalChecked();\n+  }\n+\n+  args.GetReturnValue().Set(ary);\n+}\n+\n+\n+// Non-static, friend of HandleWrap. Could have been a HandleWrap method but\n+// implemented here for consistency with GetActiveRequests().\n+void GetActiveHandles(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  Local<Array> ary = Array::New(env->isolate());\n+  Local<Context> ctx = env->context();\n+  Local<Function> fn = env->push_values_to_array_function();\n+  Local<Value> argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n+  size_t idx = 0;\n+\n+  for (auto w : *env->handle_wrap_queue()) {\n+    if (!HandleWrap::HasRef(w))\n+      continue;\n+    argv[idx] = w->GetOwner();\n+    if (++idx >= arraysize(argv)) {\n+      fn->Call(ctx, ary, idx, argv).ToLocalChecked();\n+      idx = 0;\n+    }\n+  }\n+  if (idx > 0) {\n+    fn->Call(ctx, ary, idx, argv).ToLocalChecked();\n+  }\n+\n+  args.GetReturnValue().Set(ary);\n+}\n \n }  // namespace node"
        }
    ],
    "stats": {
        "total": 112,
        "additions": 57,
        "deletions": 55
    }
}