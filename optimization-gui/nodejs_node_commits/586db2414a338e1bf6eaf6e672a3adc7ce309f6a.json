{
    "author": "targos",
    "message": "deps: update V8 to 6.9.427.22\n\nPR-URL: https://github.com/nodejs/node/pull/21983\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
    "files": [
        {
            "sha": "7ef1e1b74b01e06e95cd70e855167e59137a4c45",
            "filename": "deps/v8/.gitattributes",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2F.gitattributes",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2F.gitattributes",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2F.gitattributes?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -1,2 +1,5 @@\n # Automatically normalize line endings (to LF) for all text-based files.\n-* text=auto\n+* text=auto eol=lf\n+# Do not modify line endings for binary files (which are sometimes auto\n+# detected as text files by git).\n+*.png binary"
        },
        {
            "sha": "b76fda4dc499ff75edec247c59bbdfe69ea8c864",
            "filename": "deps/v8/.gitignore",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2F.gitignore",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2F.gitignore",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2F.gitignore?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -105,5 +105,10 @@ turbo*.dot\n turbo*.json\n v8.ignition_dispatches_table.json\n /Default/\n+node_modules\n+tools/turbolizer/build\n+tools/turbolizer/.rpt2_cache\n+tools/turbolizer/deploy\n+\n !/third_party/jinja2\n !/third_party/markupsafe"
        },
        {
            "sha": "b9391a0d28499985ae6a5b93394c6d5afc9ea1cd",
            "filename": "deps/v8/AUTHORS",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FAUTHORS?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -32,7 +32,6 @@ Facebook, Inc. <*@fb.com>\n Facebook, Inc. <*@oculus.com>\n Vewd Software AS <*@vewd.com>\n Groupon <*@groupon.com>\n-Meteor Development Group <*@meteor.com>\n Cloudflare, Inc. <*@cloudflare.com>\n \n Aaron Bieber <deftly@gmail.com>\n@@ -50,7 +49,6 @@ Andrei Kashcha <anvaka@gmail.com>\n Anna Henningsen <anna@addaleax.net>\n Bangfu Tao <bangfu.tao@samsung.com>\n Ben Coe <ben@npmjs.com>\n-Ben Newman <ben@meteor.com>\n Ben Noordhuis <info@bnoordhuis.nl>\n Benjamin Tan <demoneaux@gmail.com>\n Bert Belder <bertbelder@gmail.com>\n@@ -75,6 +73,7 @@ Felix Geisendörfer <haimuiba@gmail.com>\n Filipe David Manana <fdmanana@gmail.com>\n Franziska Hinkelmann <franziska.hinkelmann@gmail.com>\n Geoffrey Garside <ggarside@gmail.com>\n+Gergely Nagy <ngg@ngg.hu>\n Gus Caplan <me@gus.host>\n Gwang Yoon Hwang <ryumiel@company100.net>\n Henrique Ferreiro <henrique.ferreiro@gmail.com>\n@@ -88,7 +87,6 @@ Jan de Mooij <jandemooij@gmail.com>\n Jan Krems <jan.krems@gmail.com>\n Jay Freeman <saurik@saurik.com>\n James Pike <g00gle@chilon.net>\n-James M Snell <jasnell@gmail.com>\n Jianghua Yang <jianghua.yjh@alibaba-inc.com>\n Joel Stanley <joel@jms.id.au>\n Johan Bergström <johan@bergstroem.nu>\n@@ -151,6 +149,8 @@ Taketoshi Aono <brn@b6n.ch>\n Teddy Katz <teddy.katz@gmail.com>\n Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\n Tobias Burnus <burnus@net-b.de>\n+Tobias Nießen <tniessen@tnie.de>\n+Ujjwal Sharma <usharma1998@gmail.com>\n Victor Costan <costan@gmail.com>\n Vlad Burlik <vladbph@gmail.com>\n Vladimir Krivosheev <develar@gmail.com>"
        },
        {
            "sha": "1e31acb2771e6e4137524ff4ae6a9e962092cd90",
            "filename": "deps/v8/BUILD.gn",
            "status": "modified",
            "additions": 108,
            "deletions": 29,
            "changes": 137,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FBUILD.gn",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FBUILD.gn",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FBUILD.gn?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -22,6 +22,13 @@ declare_args() {\n   # Print to stdout on Android.\n   v8_android_log_stdout = false\n \n+  # Dynamically set an additional dependency from v8/custom_deps.\n+  v8_custom_deps = \"\"\n+\n+  # Turns on deprecation warnings for HeapObject::GetIsolate,\n+  # HeapObject::GetHeap, Handle(T* obj) and handle(T* obj).\n+  v8_deprecate_get_isolate = false\n+\n   # Turns on all V8 debug features. Enables running V8 in a pseudo debug mode\n   # within a release Chrome.\n   v8_enable_debugging_features = is_debug\n@@ -70,12 +77,17 @@ declare_args() {\n \n   # Enable embedded builtins.\n   # TODO(jgruber,v8:6666): Support ia32 and maybe MSVC.\n-  # TODO(jgruber,v8:6666): Re-enable.\n-  v8_enable_embedded_builtins = false\n+  # TODO(jgruber,v8:6666): Enable for remaining architectures once performance\n+  #                        regressions are addressed.\n+  v8_enable_embedded_builtins =\n+      v8_use_snapshot && v8_current_cpu == \"x64\" && (!is_win || is_clang)\n \n   # Enable code-generation-time checking of types in the CodeStubAssembler.\n   v8_enable_verify_csa = false\n \n+  # Enable pointer compression (sets -dV8_COMPRESS_POINTERS).\n+  v8_enable_pointer_compression = false\n+\n   # Interpreted regexp engine exists as platform-independent alternative\n   # based where the regular expression is compiled to a bytecode.\n   v8_interpreted_regexp = false\n@@ -176,6 +188,9 @@ if (v8_check_microtasks_scopes_consistency == \"\") {\n       v8_enable_debugging_features || dcheck_always_on\n }\n \n+assert(!v8_enable_embedded_builtins || v8_use_snapshot,\n+       \"Embedded builtins only work with snapshots\")\n+\n # Specifies if the target build is a simulator build. Comparing target cpu\n # with v8 target cpu to not affect simulator builds for making cross-compile\n # snapshots.\n@@ -195,8 +210,10 @@ config(\"internal_config\") {\n     \"$target_gen_dir\",\n   ]\n \n+  defines = []\n+\n   if (is_component_build) {\n-    defines = [ \"BUILDING_V8_SHARED\" ]\n+    defines += [ \"BUILDING_V8_SHARED\" ]\n   }\n }\n \n@@ -286,6 +303,9 @@ config(\"features\") {\n   if (v8_enable_minor_mc) {\n     defines += [ \"ENABLE_MINOR_MC\" ]\n   }\n+  if (v8_enable_pointer_compression) {\n+    defines += [ \"V8_COMPRESS_POINTERS\" ]\n+  }\n   if (v8_enable_object_print) {\n     defines += [ \"OBJECT_PRINT\" ]\n   }\n@@ -320,6 +340,9 @@ config(\"features\") {\n   if (v8_imminent_deprecation_warnings) {\n     defines += [ \"V8_IMMINENT_DEPRECATION_WARNINGS\" ]\n   }\n+  if (v8_deprecate_get_isolate) {\n+    defines += [ \"DEPRECATE_GET_ISOLATE\" ]\n+  }\n   if (v8_enable_i18n_support) {\n     defines += [ \"V8_INTL_SUPPORT\" ]\n   }\n@@ -563,6 +586,10 @@ config(\"toolchain\") {\n         v8_current_cpu == \"mips64el\") {\n       cflags += [ \"-Wshorten-64-to-32\" ]\n     }\n+\n+    if (v8_deprecate_get_isolate) {\n+      cflags += [ \"-Wno-error=deprecated\" ]\n+    }\n   }\n \n   if (is_win) {\n@@ -636,9 +663,6 @@ action(\"js2c\") {\n     \"src/js/prologue.js\",\n     \"src/js/array.js\",\n     \"src/js/typedarray.js\",\n-    \"src/debug/mirrors.js\",\n-    \"src/debug/debug.js\",\n-    \"src/debug/liveedit.js\",\n   ]\n \n   outputs = [\n@@ -828,7 +852,6 @@ action(\"postmortem-metadata\") {\n     \"src/objects/js-regexp-string-iterator.h\",\n     \"src/objects/map.h\",\n     \"src/objects/map-inl.h\",\n-    \"src/objects/scope-info.h\",\n     \"src/objects/script.h\",\n     \"src/objects/script-inl.h\",\n     \"src/objects/shared-function-info.h\",\n@@ -848,14 +871,18 @@ action(\"postmortem-metadata\") {\n torque_files = [\n   \"src/builtins/base.tq\",\n   \"src/builtins/array.tq\",\n+  \"src/builtins/array-foreach.tq\",\n+  \"src/builtins/array-sort.tq\",\n   \"src/builtins/typed-array.tq\",\n+  \"src/builtins/data-view.tq\",\n   \"test/torque/test-torque.tq\",\n ]\n \n torque_modules = [\n   \"base\",\n   \"array\",\n   \"typed-array\",\n+  \"data-view\",\n   \"test\",\n ]\n \n@@ -906,7 +933,7 @@ action(\"run_torque\") {\n   }\n }\n \n-v8_source_set(\"torque_generated_core\") {\n+v8_header_set(\"torque_generated_core\") {\n   visibility = [ \":*\" ]  # Only targets in this file can depend on this.\n \n   deps = [\n@@ -927,6 +954,12 @@ v8_source_set(\"torque_generated_initializers\") {\n     \":run_torque\",\n   ]\n \n+  if (v8_enable_i18n_support) {\n+    public_deps = [\n+      \"//third_party/icu\",\n+    ]\n+  }\n+\n   sources = []\n   foreach(module, torque_modules) {\n     sources += [\n@@ -1036,6 +1069,11 @@ template(\"run_mksnapshot\") {\n         \"--no-turbo-rewrite-far-jumps\",\n         \"--no-turbo-verify-allocation\",\n       ]\n+\n+      if (v8_enable_debugging_features && v8_enable_slow_dchecks) {\n+        # mksnapshot only accepts this flag if ENABLE_SLOW_DCHECKS is defined.\n+        args += [ \"--no-enable-slow-asserts\" ]\n+      }\n     }\n   }\n }\n@@ -1178,6 +1216,8 @@ if (v8_use_snapshot && !v8_use_external_startup_data) {\n \n     if (v8_enable_embedded_builtins) {\n       sources += [ \"$target_gen_dir/embedded.cc\" ]\n+    } else {\n+      sources += [ \"src/snapshot/embedded-empty.cc\" ]\n     }\n \n     if (use_jumbo_build == true) {\n@@ -1234,6 +1274,8 @@ if (v8_use_snapshot && v8_use_external_startup_data) {\n           ]\n         }\n       }\n+    } else {\n+      sources += [ \"src/snapshot/embedded-empty.cc\" ]\n     }\n \n     configs = [ \":internal_config\" ]\n@@ -1271,6 +1313,7 @@ v8_source_set(\"v8_initializers\") {\n     \"src/builtins/builtins-constructor-gen.h\",\n     \"src/builtins/builtins-constructor.h\",\n     \"src/builtins/builtins-conversion-gen.cc\",\n+    \"src/builtins/builtins-data-view-gen.h\",\n     \"src/builtins/builtins-date-gen.cc\",\n     \"src/builtins/builtins-debug-gen.cc\",\n     \"src/builtins/builtins-function-gen.cc\",\n@@ -1283,6 +1326,8 @@ v8_source_set(\"v8_initializers\") {\n     \"src/builtins/builtins-intl-gen.cc\",\n     \"src/builtins/builtins-iterator-gen.cc\",\n     \"src/builtins/builtins-iterator-gen.h\",\n+    \"src/builtins/builtins-lazy-gen.cc\",\n+    \"src/builtins/builtins-lazy-gen.h\",\n     \"src/builtins/builtins-math-gen.cc\",\n     \"src/builtins/builtins-math-gen.h\",\n     \"src/builtins/builtins-number-gen.cc\",\n@@ -1394,6 +1439,11 @@ v8_source_set(\"v8_init\") {\n     ### gcmole(all) ###\n     \"src/setup-isolate-full.cc\",\n   ]\n+  if (v8_enable_i18n_support) {\n+    public_deps = [\n+      \"//third_party/icu\",\n+    ]\n+  }\n \n   configs = [ \":internal_config\" ]\n }\n@@ -1484,8 +1534,6 @@ v8_source_set(\"v8_base\") {\n     \"src/ast/ast-value-factory.h\",\n     \"src/ast/ast.cc\",\n     \"src/ast/ast.h\",\n-    \"src/ast/compile-time-value.cc\",\n-    \"src/ast/compile-time-value.h\",\n     \"src/ast/context-slot-cache.cc\",\n     \"src/ast/context-slot-cache.h\",\n     \"src/ast/modules.cc\",\n@@ -1540,7 +1588,6 @@ v8_source_set(\"v8_base\") {\n     \"src/builtins/builtins-sharedarraybuffer.cc\",\n     \"src/builtins/builtins-string.cc\",\n     \"src/builtins/builtins-symbol.cc\",\n-    \"src/builtins/builtins-trace.cc\",\n     \"src/builtins/builtins-typed-array.cc\",\n     \"src/builtins/builtins-utils.h\",\n     \"src/builtins/builtins.cc\",\n@@ -1566,13 +1613,12 @@ v8_source_set(\"v8_base\") {\n     \"src/code-stubs-utils.h\",\n     \"src/code-stubs.cc\",\n     \"src/code-stubs.h\",\n+    \"src/code-tracer.h\",\n     \"src/codegen.cc\",\n     \"src/codegen.h\",\n     \"src/collector.h\",\n     \"src/compilation-cache.cc\",\n     \"src/compilation-cache.h\",\n-    \"src/compilation-dependencies.cc\",\n-    \"src/compilation-dependencies.h\",\n     \"src/compilation-statistics.cc\",\n     \"src/compilation-statistics.h\",\n     \"src/compiler-dispatcher/compiler-dispatcher-job.cc\",\n@@ -1618,6 +1664,8 @@ v8_source_set(\"v8_base\") {\n     \"src/compiler/common-operator-reducer.h\",\n     \"src/compiler/common-operator.cc\",\n     \"src/compiler/common-operator.h\",\n+    \"src/compiler/compilation-dependencies.cc\",\n+    \"src/compiler/compilation-dependencies.h\",\n     \"src/compiler/compiler-source-position-table.cc\",\n     \"src/compiler/compiler-source-position-table.h\",\n     \"src/compiler/constant-folding-reducer.cc\",\n@@ -1674,6 +1722,8 @@ v8_source_set(\"v8_base\") {\n     \"src/compiler/js-generic-lowering.h\",\n     \"src/compiler/js-graph.cc\",\n     \"src/compiler/js-graph.h\",\n+    \"src/compiler/js-heap-broker.cc\",\n+    \"src/compiler/js-heap-broker.h\",\n     \"src/compiler/js-inlining-heuristic.cc\",\n     \"src/compiler/js-inlining-heuristic.h\",\n     \"src/compiler/js-inlining.cc\",\n@@ -1912,6 +1962,8 @@ v8_source_set(\"v8_base\") {\n     \"src/heap/gc-idle-time-handler.h\",\n     \"src/heap/gc-tracer.cc\",\n     \"src/heap/gc-tracer.h\",\n+    \"src/heap/heap-controller.cc\",\n+    \"src/heap/heap-controller.h\",\n     \"src/heap/heap-inl.h\",\n     \"src/heap/heap.cc\",\n     \"src/heap/heap.h\",\n@@ -2087,6 +2139,7 @@ v8_source_set(\"v8_base\") {\n     \"src/objects/frame-array.h\",\n     \"src/objects/hash-table-inl.h\",\n     \"src/objects/hash-table.h\",\n+    \"src/objects/intl-objects-inl.h\",\n     \"src/objects/intl-objects.cc\",\n     \"src/objects/intl-objects.h\",\n     \"src/objects/js-array-inl.h\",\n@@ -2102,6 +2155,9 @@ v8_source_set(\"v8_base\") {\n     \"src/objects/js-regexp-string-iterator-inl.h\",\n     \"src/objects/js-regexp-string-iterator.h\",\n     \"src/objects/js-regexp.h\",\n+    \"src/objects/js-relative-time-format-inl.h\",\n+    \"src/objects/js-relative-time-format.cc\",\n+    \"src/objects/js-relative-time-format.h\",\n     \"src/objects/literal-objects-inl.h\",\n     \"src/objects/literal-objects.cc\",\n     \"src/objects/literal-objects.h\",\n@@ -2127,6 +2183,8 @@ v8_source_set(\"v8_base\") {\n     \"src/objects/promise.h\",\n     \"src/objects/property-descriptor-object-inl.h\",\n     \"src/objects/property-descriptor-object.h\",\n+    \"src/objects/prototype-info-inl.h\",\n+    \"src/objects/prototype-info.h\",\n     \"src/objects/regexp-match-info.h\",\n     \"src/objects/scope-info.cc\",\n     \"src/objects/scope-info.h\",\n@@ -2159,7 +2217,6 @@ v8_source_set(\"v8_base\") {\n     \"src/parsing/parsing.cc\",\n     \"src/parsing/parsing.h\",\n     \"src/parsing/pattern-rewriter.cc\",\n-    \"src/parsing/preparse-data-format.h\",\n     \"src/parsing/preparse-data.cc\",\n     \"src/parsing/preparse-data.h\",\n     \"src/parsing/preparsed-scope-data.cc\",\n@@ -2235,6 +2292,8 @@ v8_source_set(\"v8_base\") {\n     \"src/register-configuration.cc\",\n     \"src/register-configuration.h\",\n     \"src/reglist.h\",\n+    \"src/roots-inl.h\",\n+    \"src/roots.h\",\n     \"src/runtime-profiler.cc\",\n     \"src/runtime-profiler.h\",\n     \"src/runtime/runtime-array.cc\",\n@@ -2245,7 +2304,6 @@ v8_source_set(\"v8_base\") {\n     \"src/runtime/runtime-compiler.cc\",\n     \"src/runtime/runtime-date.cc\",\n     \"src/runtime/runtime-debug.cc\",\n-    \"src/runtime/runtime-error.cc\",\n     \"src/runtime/runtime-forin.cc\",\n     \"src/runtime/runtime-function.cc\",\n     \"src/runtime/runtime-futex.cc\",\n@@ -2254,7 +2312,6 @@ v8_source_set(\"v8_base\") {\n     \"src/runtime/runtime-interpreter.cc\",\n     \"src/runtime/runtime-intl.cc\",\n     \"src/runtime/runtime-literals.cc\",\n-    \"src/runtime/runtime-liveedit.cc\",\n     \"src/runtime/runtime-maths.cc\",\n     \"src/runtime/runtime-module.cc\",\n     \"src/runtime/runtime-numbers.cc\",\n@@ -2306,6 +2363,7 @@ v8_source_set(\"v8_base\") {\n     \"src/snapshot/partial-deserializer.h\",\n     \"src/snapshot/partial-serializer.cc\",\n     \"src/snapshot/partial-serializer.h\",\n+    \"src/snapshot/references.h\",\n     \"src/snapshot/serializer-common.cc\",\n     \"src/snapshot/serializer-common.h\",\n     \"src/snapshot/serializer.cc\",\n@@ -2352,6 +2410,8 @@ v8_source_set(\"v8_base\") {\n     \"src/trap-handler/handler-shared.cc\",\n     \"src/trap-handler/trap-handler-internal.h\",\n     \"src/trap-handler/trap-handler.h\",\n+    \"src/turbo-assembler.cc\",\n+    \"src/turbo-assembler.h\",\n     \"src/type-hints.cc\",\n     \"src/type-hints.h\",\n     \"src/unicode-cache-inl.h\",\n@@ -2396,6 +2456,8 @@ v8_source_set(\"v8_base\") {\n     \"src/wasm/function-body-decoder.h\",\n     \"src/wasm/function-compiler.cc\",\n     \"src/wasm/function-compiler.h\",\n+    \"src/wasm/jump-table-assembler.cc\",\n+    \"src/wasm/jump-table-assembler.h\",\n     \"src/wasm/leb-helper.h\",\n     \"src/wasm/local-decl-encoder.cc\",\n     \"src/wasm/local-decl-encoder.h\",\n@@ -2412,8 +2474,6 @@ v8_source_set(\"v8_base\") {\n     \"src/wasm/value-type.h\",\n     \"src/wasm/wasm-code-manager.cc\",\n     \"src/wasm/wasm-code-manager.h\",\n-    \"src/wasm/wasm-code-specialization.cc\",\n-    \"src/wasm/wasm-code-specialization.h\",\n     \"src/wasm/wasm-constants.h\",\n     \"src/wasm/wasm-debug.cc\",\n     \"src/wasm/wasm-engine.cc\",\n@@ -2485,6 +2545,7 @@ v8_source_set(\"v8_base\") {\n       \"src/ia32/assembler-ia32.h\",\n       \"src/ia32/code-stubs-ia32.cc\",\n       \"src/ia32/codegen-ia32.cc\",\n+      \"src/ia32/constants-ia32.h\",\n       \"src/ia32/cpu-ia32.cc\",\n       \"src/ia32/deoptimizer-ia32.cc\",\n       \"src/ia32/disasm-ia32.cc\",\n@@ -2518,6 +2579,7 @@ v8_source_set(\"v8_base\") {\n       \"src/x64/assembler-x64.h\",\n       \"src/x64/code-stubs-x64.cc\",\n       \"src/x64/codegen-x64.cc\",\n+      \"src/x64/constants-x64.h\",\n       \"src/x64/cpu-x64.cc\",\n       \"src/x64/deoptimizer-x64.cc\",\n       \"src/x64/disasm-x64.cc\",\n@@ -2557,7 +2619,6 @@ v8_source_set(\"v8_base\") {\n       \"src/arm/frame-constants-arm.cc\",\n       \"src/arm/frame-constants-arm.h\",\n       \"src/arm/interface-descriptors-arm.cc\",\n-      \"src/arm/interface-descriptors-arm.h\",\n       \"src/arm/macro-assembler-arm.cc\",\n       \"src/arm/macro-assembler-arm.h\",\n       \"src/arm/simulator-arm.cc\",\n@@ -2598,7 +2659,6 @@ v8_source_set(\"v8_base\") {\n       \"src/arm64/instrument-arm64.cc\",\n       \"src/arm64/instrument-arm64.h\",\n       \"src/arm64/interface-descriptors-arm64.cc\",\n-      \"src/arm64/interface-descriptors-arm64.h\",\n       \"src/arm64/macro-assembler-arm64-inl.h\",\n       \"src/arm64/macro-assembler-arm64.cc\",\n       \"src/arm64/macro-assembler-arm64.h\",\n@@ -2768,11 +2828,15 @@ v8_source_set(\"v8_base\") {\n       \"src/char-predicates.cc\",\n       \"src/intl.cc\",\n       \"src/intl.h\",\n+      \"src/objects/intl-objects-inl.h\",\n       \"src/objects/intl-objects.cc\",\n       \"src/objects/intl-objects.h\",\n       \"src/objects/js-locale-inl.h\",\n       \"src/objects/js-locale.cc\",\n       \"src/objects/js-locale.h\",\n+      \"src/objects/js-relative-time-format-inl.h\",\n+      \"src/objects/js-relative-time-format.cc\",\n+      \"src/objects/js-relative-time-format.h\",\n       \"src/runtime/runtime-intl.cc\",\n     ]\n   }\n@@ -2816,6 +2880,7 @@ v8_component(\"v8_libbase\") {\n     \"src/base/ieee754.h\",\n     \"src/base/iterator.h\",\n     \"src/base/lazy-instance.h\",\n+    \"src/base/list.h\",\n     \"src/base/logging.cc\",\n     \"src/base/logging.h\",\n     \"src/base/macros.h\",\n@@ -2925,7 +2990,6 @@ v8_component(\"v8_libbase\") {\n       \"src/base/debug/stack_trace_fuchsia.cc\",\n       \"src/base/platform/platform-fuchsia.cc\",\n     ]\n-    public_deps += [ \"//third_party/fuchsia-sdk:launchpad\" ]\n   } else if (is_mac) {\n     sources += [\n       \"src/base/debug/stack_trace_posix.cc\",\n@@ -3029,6 +3093,10 @@ v8_source_set(\"fuzzer_support\") {\n     \":v8_libbase\",\n     \":v8_libplatform\",\n   ]\n+\n+  if (v8_enable_i18n_support) {\n+    public_deps += [ \"//third_party/icu\" ]\n+  }\n }\n \n ###############################################################################\n@@ -3047,7 +3115,6 @@ if (v8_monolithic) {\n       \":v8_libbase\",\n       \":v8_libplatform\",\n       \":v8_libsampler\",\n-      \"//build/config:exe_and_shlib_deps\",\n       \"//build/win:default_exe_manifest\",\n     ]\n \n@@ -3075,7 +3142,6 @@ if (v8_use_snapshot && current_toolchain == v8_snapshot_toolchain) {\n       \":v8_libbase\",\n       \":v8_libplatform\",\n       \":v8_nosnapshot\",\n-      \"//build/config:exe_and_shlib_deps\",\n       \"//build/win:default_exe_manifest\",\n     ]\n   }\n@@ -3129,7 +3195,6 @@ if (current_toolchain == v8_snapshot_toolchain) {\n     deps = [\n       \":v8_libbase\",\n       \"third_party/antlr4:antlr4\",\n-      \"//build/config:exe_and_shlib_deps\",\n       \"//build/win:default_exe_manifest\",\n     ]\n \n@@ -3170,6 +3235,11 @@ group(\"gn_all\") {\n     \"tools:gn_all\",\n   ]\n \n+  if (v8_custom_deps != \"\") {\n+    # Custom dependency from directory under v8/custom_deps.\n+    deps += [ v8_custom_deps ]\n+  }\n+\n   if (want_v8_shell) {\n     deps += [ \":v8_shell\" ]\n   }\n@@ -3285,6 +3355,8 @@ if (is_component_build) {\n v8_executable(\"d8\") {\n   sources = [\n     \"$target_gen_dir/d8-js.cc\",\n+    \"src/async-hooks-wrapper.cc\",\n+    \"src/async-hooks-wrapper.h\",\n     \"src/d8-console.cc\",\n     \"src/d8-console.h\",\n     \"src/d8.cc\",\n@@ -3303,7 +3375,6 @@ v8_executable(\"d8\") {\n     \":v8\",\n     \":v8_libbase\",\n     \":v8_libplatform\",\n-    \"//build/config:exe_and_shlib_deps\",\n     \"//build/win:default_exe_manifest\",\n   ]\n \n@@ -3340,7 +3411,6 @@ v8_executable(\"v8_hello_world\") {\n     \":v8\",\n     \":v8_libbase\",\n     \":v8_libplatform\",\n-    \"//build/config:exe_and_shlib_deps\",\n     \"//build/win:default_exe_manifest\",\n   ]\n }\n@@ -3361,7 +3431,6 @@ v8_executable(\"v8_sample_process\") {\n     \":v8\",\n     \":v8_libbase\",\n     \":v8_libplatform\",\n-    \"//build/config:exe_and_shlib_deps\",\n     \"//build/win:default_exe_manifest\",\n   ]\n }\n@@ -3383,7 +3452,6 @@ if (want_v8_shell) {\n       \":v8\",\n       \":v8_libbase\",\n       \":v8_libplatform\",\n-      \"//build/config:exe_and_shlib_deps\",\n       \"//build/win:default_exe_manifest\",\n     ]\n   }\n@@ -3395,7 +3463,6 @@ template(\"v8_fuzzer\") {\n   v8_executable(\"v8_simple_\" + name) {\n     deps = [\n       \":\" + name,\n-      \"//build/config:exe_and_shlib_deps\",\n       \"//build/win:default_exe_manifest\",\n     ]\n \n@@ -3508,6 +3575,12 @@ v8_source_set(\"wasm_module_runner\") {\n     \":torque_generated_core\",\n   ]\n \n+  if (v8_enable_i18n_support) {\n+    public_deps = [\n+      \"//third_party/icu\",\n+    ]\n+  }\n+\n   configs = [\n     \":external_config\",\n     \":internal_config_base\",\n@@ -3585,6 +3658,12 @@ v8_source_set(\"lib_wasm_fuzzer_common\") {\n     \":torque_generated_core\",\n   ]\n \n+  if (v8_enable_i18n_support) {\n+    public_deps = [\n+      \"//third_party/icu\",\n+    ]\n+  }\n+\n   configs = [\n     \":external_config\",\n     \":internal_config_base\","
        },
        {
            "sha": "fc7a93e2d9ddf495c35abcd80c9c856de637e8f3",
            "filename": "deps/v8/ChangeLog",
            "status": "modified",
            "additions": 2210,
            "deletions": 0,
            "changes": 2210,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FChangeLog",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FChangeLog",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FChangeLog?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -1,3 +1,2213 @@\n+2018-07-17: Version 6.9.427\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.426\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.425\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.424\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.423\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.422\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.421\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.420\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.419\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.418\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.417\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.416\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.415\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.414\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-17: Version 6.9.413\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.412\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.411\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.410\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.409\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.408\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.407\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.406\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.405\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.404\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.403\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.402\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-16: Version 6.9.401\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-15: Version 6.9.400\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-14: Version 6.9.399\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.398\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.397\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.396\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.395\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.394\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.393\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.392\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.391\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.390\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.389\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.388\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.387\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.386\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.385\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.384\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.383\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.382\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-13: Version 6.9.381\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.380\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.379\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.378\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.377\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.376\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.375\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.374\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.373\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.372\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.371\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.370\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.369\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.368\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.367\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.366\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.365\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.364\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.363\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.362\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.361\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.360\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.359\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.358\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.357\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.356\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-12: Version 6.9.355\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.354\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.353\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.352\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.351\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.350\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.349\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.348\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.347\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.346\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-11: Version 6.9.345\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.344\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.343\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.342\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.341\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.340\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.339\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.338\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.337\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.336\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.335\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.334\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.333\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-10: Version 6.9.332\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-09: Version 6.9.331\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-09: Version 6.9.330\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-09: Version 6.9.329\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-09: Version 6.9.328\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-09: Version 6.9.327\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-09: Version 6.9.326\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-09: Version 6.9.325\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-08: Version 6.9.324\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-07: Version 6.9.323\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-06: Version 6.9.322\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-06: Version 6.9.321\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-06: Version 6.9.320\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-06: Version 6.9.319\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-06: Version 6.9.318\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-06: Version 6.9.317\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-06: Version 6.9.316\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-05: Version 6.9.315\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-05: Version 6.9.314\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-05: Version 6.9.313\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-05: Version 6.9.312\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-05: Version 6.9.311\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-05: Version 6.9.310\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-05: Version 6.9.309\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-05: Version 6.9.308\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-04: Version 6.9.307\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-04: Version 6.9.306\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-04: Version 6.9.305\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-04: Version 6.9.304\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-04: Version 6.9.303\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-04: Version 6.9.302\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-04: Version 6.9.301\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-04: Version 6.9.300\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-04: Version 6.9.299\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.298\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.297\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.296\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.295\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.294\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.293\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.292\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.291\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.290\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.289\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.288\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.287\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.286\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.285\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.284\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.283\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.282\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.281\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.280\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-03: Version 6.9.279\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.278\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.277\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.276\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.275\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.274\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.273\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.272\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.271\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.270\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.269\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.268\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.267\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.266\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.265\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.264\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.263\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.262\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.261\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.260\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.259\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-02: Version 6.9.258\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-07-01: Version 6.9.257\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-30: Version 6.9.256\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.255\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.254\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.253\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.252\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.251\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.250\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.249\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.248\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.247\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-29: Version 6.9.246\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-28: Version 6.9.245\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-28: Version 6.9.244\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-28: Version 6.9.243\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.242\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.241\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.240\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.239\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.238\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.237\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.236\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.235\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.234\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.233\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.232\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.231\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-27: Version 6.9.230\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-26: Version 6.9.229\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-26: Version 6.9.228\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-26: Version 6.9.227\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-26: Version 6.9.226\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-26: Version 6.9.225\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-26: Version 6.9.224\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-26: Version 6.9.223\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-26: Version 6.9.222\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-26: Version 6.9.221\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.220\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.219\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.218\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.217\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.216\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.215\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.214\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.213\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.212\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.211\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.210\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-25: Version 6.9.209\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-24: Version 6.9.208\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-23: Version 6.9.207\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-23: Version 6.9.206\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-22: Version 6.9.205\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-22: Version 6.9.204\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-22: Version 6.9.203\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-22: Version 6.9.202\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-22: Version 6.9.201\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-22: Version 6.9.200\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-22: Version 6.9.199\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-22: Version 6.9.198\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-21: Version 6.9.197\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-21: Version 6.9.196\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-21: Version 6.9.195\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-21: Version 6.9.194\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-21: Version 6.9.193\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-21: Version 6.9.192\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-20: Version 6.9.191\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-20: Version 6.9.190\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-20: Version 6.9.189\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-20: Version 6.9.188\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-20: Version 6.9.187\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-20: Version 6.9.186\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-20: Version 6.9.185\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.184\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.183\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.182\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.181\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.180\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.179\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.178\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.177\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.176\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.175\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-19: Version 6.9.174\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.173\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.172\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.171\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.170\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.169\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.168\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.167\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.166\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.165\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.164\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.163\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.162\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.161\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.160\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.159\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.158\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-18: Version 6.9.157\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-14: Version 6.9.156\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-14: Version 6.9.155\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-14: Version 6.9.154\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-14: Version 6.9.153\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-14: Version 6.9.152\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-14: Version 6.9.151\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-14: Version 6.9.150\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.149\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.148\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.147\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.146\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.145\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.144\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.143\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.142\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.141\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.140\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.139\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.138\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.137\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.136\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.135\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.134\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.133\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.132\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.131\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.130\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.129\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.128\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.127\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.126\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-13: Version 6.9.125\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-12: Version 6.9.124\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-12: Version 6.9.123\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-12: Version 6.9.122\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-12: Version 6.9.121\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-12: Version 6.9.120\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.119\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.118\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.117\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.116\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.115\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.114\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.113\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.112\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.111\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.110\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.109\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-11: Version 6.9.108\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-08: Version 6.9.107\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-08: Version 6.9.106\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-08: Version 6.9.105\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-08: Version 6.9.104\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-08: Version 6.9.103\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-08: Version 6.9.102\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-07: Version 6.9.101\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-07: Version 6.9.100\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-07: Version 6.9.99\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-07: Version 6.9.98\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-07: Version 6.9.97\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-07: Version 6.9.96\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-07: Version 6.9.95\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-07: Version 6.9.94\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-07: Version 6.9.93\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.92\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.91\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.90\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.89\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.88\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.87\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.86\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.85\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.84\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-06: Version 6.9.83\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-05: Version 6.9.82\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-05: Version 6.9.81\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-05: Version 6.9.80\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-05: Version 6.9.79\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-05: Version 6.9.78\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-05: Version 6.9.77\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-05: Version 6.9.76\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-05: Version 6.9.75\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.74\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.73\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.72\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.71\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.70\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.69\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.68\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.67\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.66\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-04: Version 6.9.65\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-01: Version 6.9.64\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-01: Version 6.9.63\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-01: Version 6.9.62\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-01: Version 6.9.61\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-01: Version 6.9.60\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-01: Version 6.9.59\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-01: Version 6.9.58\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-06-01: Version 6.9.57\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-31: Version 6.9.56\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-31: Version 6.9.55\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-31: Version 6.9.54\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-31: Version 6.9.53\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-31: Version 6.9.52\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-31: Version 6.9.51\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-31: Version 6.9.50\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-31: Version 6.9.49\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-31: Version 6.9.48\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.47\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.46\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.45\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.44\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.43\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.42\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.41\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.40\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.39\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.38\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-30: Version 6.9.37\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.36\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.35\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.34\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.33\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.32\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.31\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.30\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.29\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.28\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.27\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.26\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.25\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.24\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.23\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.22\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.21\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.20\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.19\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.18\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.17\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.16\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.15\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.14\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-29: Version 6.9.13\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-28: Version 6.9.12\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-28: Version 6.9.11\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-28: Version 6.9.10\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-28: Version 6.9.9\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-28: Version 6.9.8\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-28: Version 6.9.7\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-28: Version 6.9.6\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-28: Version 6.9.5\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-28: Version 6.9.4\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-27: Version 6.9.3\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-26: Version 6.9.2\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-25: Version 6.9.1\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-24: Version 6.8.290\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-23: Version 6.8.289\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-23: Version 6.8.288\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-23: Version 6.8.287\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-23: Version 6.8.286\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-23: Version 6.8.285\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-23: Version 6.8.284\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-23: Version 6.8.283\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-23: Version 6.8.282\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-23: Version 6.8.281\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-22: Version 6.8.280\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-22: Version 6.8.279\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-22: Version 6.8.278\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-22: Version 6.8.277\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n+2018-05-22: Version 6.8.276\n+\n+        Performance and stability improvements on all platforms.\n+\n+\n 2018-05-22: Version 6.8.275\n \n         Performance and stability improvements on all platforms."
        },
        {
            "sha": "cb9a7fe536a398d700915789aa18328ca6c2f05a",
            "filename": "deps/v8/DEPS",
            "status": "modified",
            "additions": 16,
            "deletions": 14,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FDEPS",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FDEPS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FDEPS?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -12,61 +12,63 @@ vars = {\n \n deps = {\n   'v8/build':\n-    Var('chromium_url') + '/chromium/src/build.git' + '@' + 'b5df2518f091eea3d358f30757dec3e33db56156',\n+    Var('chromium_url') + '/chromium/src/build.git' + '@' + '7315579e388589b62236ad933f09afd1e838d234',\n   'v8/tools/gyp':\n     Var('chromium_url') + '/external/gyp.git' + '@' + 'd61a9397e668fa9843c4aa7da9e79460fe590bfb',\n   'v8/third_party/depot_tools':\n-    Var('chromium_url') + '/chromium/tools/depot_tools.git' + '@' + '083eb25f9acbe034db94a1bd5c1659125b6ebf98',\n+    Var('chromium_url') + '/chromium/tools/depot_tools.git' + '@' + 'fb734036f4b5ae6d5afc63cbfc41d3a5d1c29a82',\n   'v8/third_party/icu':\n-    Var('chromium_url') + '/chromium/deps/icu.git' + '@' + 'f61e46dbee9d539a32551493e3bcc1dea92f83ec',\n+    Var('chromium_url') + '/chromium/deps/icu.git' + '@' + 'a9a2bd3ee4f1d313651c5272252aaf2a3e7ed529',\n   'v8/third_party/instrumented_libraries':\n     Var('chromium_url') + '/chromium/src/third_party/instrumented_libraries.git' + '@' + '323cf32193caecbf074d1a0cb5b02b905f163e0f',\n   'v8/buildtools':\n-    Var('chromium_url') + '/chromium/buildtools.git' + '@' + '94288c26d2ffe3aec9848c147839afee597acefd',\n+    Var('chromium_url') + '/chromium/buildtools.git' + '@' + '0dd5c6f980d22be96b728155249df2da355989d9',\n   'v8/base/trace_event/common':\n     Var('chromium_url') + '/chromium/src/base/trace_event/common.git' + '@' + '211b3ed9d0481b4caddbee1322321b86a483ca1f',\n   'v8/third_party/android_ndk': {\n     'url': Var('chromium_url') + '/android_ndk.git' + '@' + '5cd86312e794bdf542a3685c6f10cbb96072990b',\n     'condition': 'checkout_android',\n   },\n   'v8/third_party/android_tools': {\n-    'url': Var('chromium_url') + '/android_tools.git' + '@' + 'c22a664c39af72dd8f89200220713dcad811300a',\n+    'url': Var('chromium_url') + '/android_tools.git' + '@' + '130499e25286f4d56acafa252fee09f3cc595c49',\n     'condition': 'checkout_android',\n   },\n   'v8/third_party/catapult': {\n-    'url': Var('chromium_url') + '/catapult.git' + '@' + '49edbd3a2b582cbab0a912cb1989062e9b8453ff',\n+    'url': Var('chromium_url') + '/catapult.git' + '@' + 'f5342c4cf3d3e85e43be84c22bdfd8ebff23ec70',\n     'condition': 'checkout_android',\n   },\n   'v8/third_party/colorama/src': {\n     'url': Var('chromium_url') + '/external/colorama.git' + '@' + '799604a1041e9b3bc5d2789ecbd7e8db2e18e6b8',\n     'condition': 'checkout_android',\n   },\n   'v8/third_party/fuchsia-sdk': {\n-    'url': Var('chromium_url') + '/chromium/src/third_party/fuchsia-sdk.git' + '@' + 'afac8ecd6300c9903009e6f233f61aae401aced6',\n+    'url': Var('chromium_url') + '/chromium/src/third_party/fuchsia-sdk.git' + '@' + '82277014aeccc89bae4d7a317813affa3f7de0ee',\n     'condition': 'checkout_fuchsia',\n   },\n   'v8/third_party/googletest/src':\n-    Var('chromium_url') + '/external/github.com/google/googletest.git' + '@' + '08d5b1f33af8c18785fb8ca02792b5fac81e248f',\n+    Var('chromium_url') + '/external/github.com/google/googletest.git' + '@' + 'ce468a17c434e4e79724396ee1b51d86bfc8a88b',\n   'v8/third_party/jinja2':\n-    Var('chromium_url') + '/chromium/src/third_party/jinja2.git' + '@' + '45571de473282bd1d8b63a8dfcb1fd268d0635d2',\n+    Var('chromium_url') + '/chromium/src/third_party/jinja2.git' + '@' + 'b41863e42637544c2941b574c7877d3e1f663e25',\n   'v8/third_party/markupsafe':\n     Var('chromium_url') + '/chromium/src/third_party/markupsafe.git' + '@' + '8f45f5cfa0009d2a70589bcda0349b8cb2b72783',\n+  'v8/third_party/proguard':\n+    Var('chromium_url') + '/chromium/src/third_party/proguard.git' + '@' + 'eba7a98d98735b2cc65c54d36baa5c9b46fe4f8e',\n   'v8/tools/swarming_client':\n-    Var('chromium_url') + '/infra/luci/client-py.git' + '@' + '833f5ebf894be1e3e6d13678d5de8479bf12ff28',\n+    Var('chromium_url') + '/infra/luci/client-py.git' + '@' + '9a518d097dca20b7b00ce3bdfc5d418ccc79893a',\n   'v8/test/benchmarks/data':\n     Var('chromium_url') + '/v8/deps/third_party/benchmarks.git' + '@' + '05d7188267b4560491ff9155c5ee13e207ecd65f',\n   'v8/test/mozilla/data':\n     Var('chromium_url') + '/v8/deps/third_party/mozilla-tests.git' + '@' + 'f6c578a10ea707b1a8ab0b88943fe5115ce2b9be',\n   'v8/test/test262/data':\n-    Var('chromium_url') + '/external/github.com/tc39/test262.git' + '@' + '0192e0d70e2295fb590f14865da42f0f9dfa64bd',\n+    Var('chromium_url') + '/external/github.com/tc39/test262.git' + '@' + 'a6c1d05ac4fed084fa047e4c52ab2a8c9c2a8aef',\n   'v8/test/test262/harness':\n     Var('chromium_url') + '/external/github.com/test262-utils/test262-harness-py.git' + '@' + '0f2acdd882c84cff43b9d60df7574a1901e2cdcd',\n   'v8/tools/clang':\n-    Var('chromium_url') + '/chromium/src/tools/clang.git' + '@' + 'c893c7eec4706f8c7fc244ee254b1dadd8f8d158',\n+    Var('chromium_url') + '/chromium/src/tools/clang.git' + '@' + 'c0b1d892b2bc1291eb287d716ca239c1b03fb215',\n   'v8/tools/luci-go':\n-    Var('chromium_url') + '/chromium/src/tools/luci-go.git' + '@' + 'ff0709d4283b1f233dcf0c9fec1672c6ecaed2f1',\n+    Var('chromium_url') + '/chromium/src/tools/luci-go.git' + '@' + 'abcd908f74fdb155cc8870f5cae48dff1ece7c3c',\n   'v8/test/wasm-js':\n-    Var('chromium_url') + '/external/github.com/WebAssembly/spec.git' + '@' + '27d63f22e72395248d314520b3ad5b1e0943fc10',\n+    Var('chromium_url') + '/external/github.com/WebAssembly/spec.git' + '@' + '2113ea7e106f8a964e0445ba38f289d2aa845edd',\n }\n \n recursedeps = ["
        },
        {
            "sha": "d32f7213822f108afcfc607ebab97d3195ed91b4",
            "filename": "deps/v8/OWNERS",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FOWNERS",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FOWNERS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FOWNERS?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -10,10 +10,10 @@ clemensh@chromium.org\n danno@chromium.org\n delphick@chromium.org\n eholk@chromium.org\n-franzih@chromium.org\n gdeepti@chromium.org\n gsathya@chromium.org\n hablich@chromium.org\n+herhut@chromium.org\n hpayer@chromium.org\n ishell@chromium.org\n jarin@chromium.org\n@@ -22,8 +22,10 @@ jkummerow@chromium.org\n kschimpf@chromium.org\n leszeks@chromium.org\n machenbach@chromium.org\n+mathias@chromium.org\n marja@chromium.org\n mlippautz@chromium.org\n+mslekova@chromium.org\n mstarzinger@chromium.org\n mvstanton@chromium.org\n mythria@chromium.org"
        },
        {
            "sha": "bd780ce62f7a7876ffe19b85d42c254a901aa11f",
            "filename": "deps/v8/PRESUBMIT.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FPRESUBMIT.py",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2FPRESUBMIT.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FPRESUBMIT.py?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -96,7 +96,9 @@ def FilterFile(affected_file):\n       input_api.AffectedFiles(include_deletes=True)):\n     results.append(output_api.PresubmitError(\"Status file check failed\"))\n   results.extend(input_api.canned_checks.CheckAuthorizedAuthor(\n-      input_api, output_api))\n+      input_api, output_api, bot_whitelist=[\n+        'v8-ci-autoroll-builder@chops-service-accounts.iam.gserviceaccount.com'\n+      ]))\n   return results\n \n "
        },
        {
            "sha": "83866b6690a22fb70c927224b2b40b36c0ddc176",
            "filename": "deps/v8/custom_deps/.gitignore",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fcustom_deps%2F.gitignore",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fcustom_deps%2F.gitignore",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fcustom_deps%2F.gitignore?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -0,0 +1,4 @@\n+*\n+!.gitignore\n+!OWNERS\n+!README.md\n\\ No newline at end of file"
        },
        {
            "sha": "76719caca0ecccab348b44a29b7319a232bdac45",
            "filename": "deps/v8/custom_deps/OWNERS",
            "status": "added",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fcustom_deps%2FOWNERS",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fcustom_deps%2FOWNERS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fcustom_deps%2FOWNERS?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -0,0 +1,2 @@\n+machenbach@chromium.org\n+sergiyb@chromium.org\n\\ No newline at end of file"
        },
        {
            "sha": "f49930fb939d96afe4377a5849baeb6c15399490",
            "filename": "deps/v8/custom_deps/README.md",
            "status": "added",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fcustom_deps%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fcustom_deps%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fcustom_deps%2FREADME.md?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -0,0 +1,2 @@\n+Common directory for custom dependencies pulled in via .gclient custom_deps.\n+All subdirectories are ignored by git by default.\n\\ No newline at end of file"
        },
        {
            "sha": "a5312f76acd9ddb7002abd49225f5f4188de844d",
            "filename": "deps/v8/gni/v8.gni",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fgni%2Fv8.gni",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fgni%2Fv8.gni",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fgni%2Fv8.gni?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -38,7 +38,7 @@ declare_args() {\n   v8_use_snapshot = !(is_win && host_os != \"win\" && target_cpu == \"x64\")\n \n   # Enable several snapshots side-by-side (e.g. default and for trusted code).\n-  v8_use_multi_snapshots = \"\"\n+  v8_use_multi_snapshots = false\n \n   # Use external files for startup data blobs:\n   # the JS builtins sources and the start snapshot.\n@@ -61,7 +61,10 @@ if (v8_use_external_startup_data == \"\") {\n   v8_use_external_startup_data = v8_use_snapshot && !is_ios\n }\n \n-if (v8_use_multi_snapshots == \"\") {\n+if (v8_use_multi_snapshots) {\n+  # Silently disable multi snapshots if they're incompatible with the current\n+  # build configuration. This allows us to set v8_use_multi_snapshots=true on\n+  # all bots, and e.g. no-snapshot bots will automatically do the right thing.\n   v8_use_multi_snapshots =\n       v8_use_external_startup_data && !build_with_chromium && !use_jumbo_build\n }"
        },
        {
            "sha": "b486683c279f31f53c2aa50c8e1729c621bb3d36",
            "filename": "deps/v8/include/v8-profiler.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finclude%2Fv8-profiler.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finclude%2Fv8-profiler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8-profiler.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -54,7 +54,7 @@ namespace v8 {\n  */\n class V8_EXPORT TracingCpuProfiler {\n  public:\n-  V8_DEPRECATE_SOON(\n+  V8_DEPRECATED(\n       \"The profiler is created automatically with the isolate.\\n\"\n       \"No need to create it explicitly.\",\n       static std::unique_ptr<TracingCpuProfiler> Create(Isolate*));"
        },
        {
            "sha": "c7cffaca444941a0b61becc31b72fb37fb3a368d",
            "filename": "deps/v8/include/v8-version.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finclude%2Fv8-version.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finclude%2Fv8-version.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8-version.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -9,9 +9,9 @@\n // NOTE these macros are used by some of the tool scripts and the build\n // system so their names cannot be changed without changing the scripts.\n #define V8_MAJOR_VERSION 6\n-#define V8_MINOR_VERSION 8\n-#define V8_BUILD_NUMBER 275\n-#define V8_PATCH_LEVEL 32\n+#define V8_MINOR_VERSION 9\n+#define V8_BUILD_NUMBER 427\n+#define V8_PATCH_LEVEL 22\n \n // Use 1 for candidates and 0 otherwise.\n // (Boolean macro values are not supported by all preprocessors.)"
        },
        {
            "sha": "23d5ba36db97dab2bb706ab90930ee1403a68104",
            "filename": "deps/v8/include/v8.h",
            "status": "modified",
            "additions": 264,
            "deletions": 80,
            "changes": 344,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finclude%2Fv8.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finclude%2Fv8.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -71,7 +71,6 @@ class BigIntObject;\n class Boolean;\n class BooleanObject;\n class Context;\n-class CpuProfiler;\n class Data;\n class Date;\n class External;\n@@ -146,6 +145,8 @@ class DeferredHandles;\n class Heap;\n class HeapObject;\n class Isolate;\n+class LocalEmbedderHeapTracer;\n+class NeverReadOnlySpaceObject;\n class Object;\n struct ScriptStreamingData;\n template<typename T> class CustomArguments;\n@@ -154,6 +155,7 @@ class FunctionCallbackArguments;\n class GlobalHandles;\n \n namespace wasm {\n+class CompilationResultResolver;\n class StreamingDecoder;\n }  // namespace wasm\n \n@@ -176,18 +178,18 @@ const int kSmiTag = 0;\n const int kSmiTagSize = 1;\n const intptr_t kSmiTagMask = (1 << kSmiTagSize) - 1;\n \n-template <size_t ptr_size>\n+template <size_t tagged_ptr_size>\n struct SmiTagging;\n \n template <int kSmiShiftSize>\n V8_INLINE internal::Object* IntToSmi(int value) {\n   int smi_shift_bits = kSmiTagSize + kSmiShiftSize;\n-  uintptr_t tagged_value =\n-      (static_cast<uintptr_t>(value) << smi_shift_bits) | kSmiTag;\n+  intptr_t tagged_value =\n+      (static_cast<intptr_t>(value) << smi_shift_bits) | kSmiTag;\n   return reinterpret_cast<internal::Object*>(tagged_value);\n }\n \n-// Smi constants for 32-bit systems.\n+// Smi constants for systems where tagged pointer is a 32-bit value.\n template <>\n struct SmiTagging<4> {\n   enum { kSmiShiftSize = 0, kSmiValueSize = 31 };\n@@ -217,7 +219,7 @@ struct SmiTagging<4> {\n   }\n };\n \n-// Smi constants for 64-bit systems.\n+// Smi constants for systems where tagged pointer is a 64-bit value.\n template <>\n struct SmiTagging<8> {\n   enum { kSmiShiftSize = 31, kSmiValueSize = 32 };\n@@ -237,7 +239,15 @@ struct SmiTagging<8> {\n   }\n };\n \n+#if V8_COMPRESS_POINTERS\n+static_assert(\n+    kApiPointerSize == kApiInt64Size,\n+    \"Pointer compression can be enabled only for 64-bit architectures\");\n+typedef SmiTagging<4> PlatformSmiTagging;\n+#else\n typedef SmiTagging<kApiPointerSize> PlatformSmiTagging;\n+#endif\n+\n const int kSmiShiftSize = PlatformSmiTagging::kSmiShiftSize;\n const int kSmiValueSize = PlatformSmiTagging::kSmiValueSize;\n const int kSmiMinValue = (static_cast<unsigned int>(-1)) << (kSmiValueSize - 1);\n@@ -985,8 +995,8 @@ class V8_EXPORT HandleScope {\n   void operator delete[](void*, size_t);\n \n   // Uses heap_object to obtain the current Isolate.\n-  static internal::Object** CreateHandle(internal::HeapObject* heap_object,\n-                                         internal::Object* value);\n+  static internal::Object** CreateHandle(\n+      internal::NeverReadOnlySpaceObject* heap_object, internal::Object* value);\n \n   internal::Isolate* isolate_;\n   internal::Object** prev_next_;\n@@ -1022,6 +1032,11 @@ class V8_EXPORT EscapableHandleScope : public HandleScope {\n     return Local<T>(reinterpret_cast<T*>(slot));\n   }\n \n+  template <class T>\n+  V8_INLINE MaybeLocal<T> EscapeMaybe(MaybeLocal<T> value) {\n+    return Escape(value.FromMaybe(Local<T>()));\n+  }\n+\n   EscapableHandleScope(const EscapableHandleScope&) = delete;\n   void operator=(const EscapableHandleScope&) = delete;\n \n@@ -1108,8 +1123,12 @@ class V8_EXPORT PrimitiveArray {\n  public:\n   static Local<PrimitiveArray> New(Isolate* isolate, int length);\n   int Length() const;\n-  void Set(int index, Local<Primitive> item);\n-  Local<Primitive> Get(int index);\n+  void Set(Isolate* isolate, int index, Local<Primitive> item);\n+  Local<Primitive> Get(Isolate* isolate, int index);\n+\n+  V8_DEPRECATE_SOON(\"Use Isolate version\",\n+                    void Set(int index, Local<Primitive> item));\n+  V8_DEPRECATE_SOON(\"Use Isolate version\", Local<Primitive> Get(int index));\n };\n \n /**\n@@ -1468,6 +1487,10 @@ class V8_EXPORT ScriptCompiler {\n      * more than two data chunks. The embedder can avoid this problem by always\n      * returning at least 2 bytes of data.\n      *\n+     * When streaming UTF-16 data, V8 does not handle characters split between\n+     * two data chunks. The embedder has to make sure that chunks have an even\n+     * length.\n+     *\n      * If the embedder wants to cancel the streaming, they should make the next\n      * GetMoreData call return 0. V8 will interpret it as end of data (and most\n      * probably, parsing will fail). The streaming task will return as soon as\n@@ -1651,7 +1674,9 @@ class V8_EXPORT ScriptCompiler {\n    * ECMAScript specification.\n    */\n   static V8_WARN_UNUSED_RESULT MaybeLocal<Module> CompileModule(\n-      Isolate* isolate, Source* source);\n+      Isolate* isolate, Source* source,\n+      CompileOptions options = kNoCompileOptions,\n+      NoCacheReason no_cache_reason = kNoCacheNoReason);\n \n   /**\n    * Compile a function for a given context. This is equivalent to running\n@@ -4349,10 +4374,29 @@ class V8_EXPORT Proxy : public Object {\n class V8_EXPORT WasmCompiledModule : public Object {\n  public:\n   typedef std::pair<std::unique_ptr<const uint8_t[]>, size_t> SerializedModule;\n-  /**\n-   * A buffer that is owned by the caller.\n-   */\n-  typedef std::pair<const uint8_t*, size_t> CallerOwnedBuffer;\n+\n+// The COMMA macro allows us to use ',' inside of the V8_DEPRECATE_SOON macro.\n+#define COMMA ,\n+  V8_DEPRECATE_SOON(\n+      \"Use BufferReference.\",\n+      typedef std::pair<const uint8_t * COMMA size_t> CallerOwnedBuffer);\n+#undef COMMA\n+\n+  /**\n+   * A unowned reference to a byte buffer.\n+   */\n+  struct BufferReference {\n+    const uint8_t* start;\n+    size_t size;\n+    BufferReference(const uint8_t* start, size_t size)\n+        : start(start), size(size) {}\n+    // Temporarily allow conversion to and from CallerOwnedBuffer.\n+    V8_DEPRECATE_SOON(\n+        \"Use BufferReference directly.\",\n+        inline BufferReference(CallerOwnedBuffer));  // NOLINT(runtime/explicit)\n+    V8_DEPRECATE_SOON(\"Use BufferReference directly.\",\n+                      inline operator CallerOwnedBuffer());\n+  };\n \n   /**\n    * An opaque, native heap object for transferring wasm modules. It\n@@ -4369,7 +4413,7 @@ class V8_EXPORT WasmCompiledModule : public Object {\n    private:\n     typedef std::pair<std::unique_ptr<const uint8_t[]>, size_t> OwnedBuffer;\n     friend class WasmCompiledModule;\n-    TransferrableModule(OwnedBuffer&& code, OwnedBuffer&& bytes)\n+    TransferrableModule(OwnedBuffer code, OwnedBuffer bytes)\n         : compiled_code(std::move(code)), wire_bytes(std::move(bytes)) {}\n \n     OwnedBuffer compiled_code = {nullptr, 0};\n@@ -4393,7 +4437,9 @@ class V8_EXPORT WasmCompiledModule : public Object {\n   /**\n    * Get the wasm-encoded bytes that were used to compile this module.\n    */\n-  Local<String> GetWasmWireBytes();\n+  BufferReference GetWasmWireBytesRef();\n+  V8_DEPRECATE_SOON(\"Use GetWasmWireBytesRef version.\",\n+                    Local<String> GetWasmWireBytes());\n \n   /**\n    * Serialize the compiled module. The serialized data does not include the\n@@ -4406,18 +4452,18 @@ class V8_EXPORT WasmCompiledModule : public Object {\n    * uncompiled bytes.\n    */\n   static MaybeLocal<WasmCompiledModule> DeserializeOrCompile(\n-      Isolate* isolate, const CallerOwnedBuffer& serialized_module,\n-      const CallerOwnedBuffer& wire_bytes);\n+      Isolate* isolate, BufferReference serialized_module,\n+      BufferReference wire_bytes);\n   V8_INLINE static WasmCompiledModule* Cast(Value* obj);\n \n  private:\n   static MaybeLocal<WasmCompiledModule> Deserialize(\n-      Isolate* isolate, const CallerOwnedBuffer& serialized_module,\n-      const CallerOwnedBuffer& wire_bytes);\n+      Isolate* isolate, BufferReference serialized_module,\n+      BufferReference wire_bytes);\n   static MaybeLocal<WasmCompiledModule> Compile(Isolate* isolate,\n                                                 const uint8_t* start,\n                                                 size_t length);\n-  static CallerOwnedBuffer AsCallerOwned(\n+  static BufferReference AsReference(\n       const TransferrableModule::OwnedBuffer& buff) {\n     return {buff.first.get(), buff.second};\n   }\n@@ -4426,6 +4472,61 @@ class V8_EXPORT WasmCompiledModule : public Object {\n   static void CheckCast(Value* obj);\n };\n \n+// TODO(clemensh): Remove after M69 branch.\n+WasmCompiledModule::BufferReference::BufferReference(\n+    WasmCompiledModule::CallerOwnedBuffer buf)\n+    : BufferReference(buf.first, buf.second) {}\n+WasmCompiledModule::BufferReference::\n+operator WasmCompiledModule::CallerOwnedBuffer() {\n+  return {start, size};\n+}\n+\n+/**\n+ * The V8 interface for WebAssembly streaming compilation. When streaming\n+ * compilation is initiated, V8 passes a {WasmStreaming} object to the embedder\n+ * such that the embedder can pass the input butes for streaming compilation to\n+ * V8.\n+ */\n+class V8_EXPORT WasmStreaming final {\n+ public:\n+  class WasmStreamingImpl;\n+\n+  WasmStreaming(std::unique_ptr<WasmStreamingImpl> impl);\n+\n+  ~WasmStreaming();\n+\n+  /**\n+   * Pass a new chunck of bytes to WebAssembly streaming compilation.\n+   * The buffer passed into {OnBytesReceived} is owned by the caller.\n+   */\n+  void OnBytesReceived(const uint8_t* bytes, size_t size);\n+\n+  /**\n+   * {Finish} should be called after all received bytes where passed to\n+   * {OnBytesReceived} to tell V8 that there will be no more bytes. {Finish}\n+   * does not have to be called after {Abort} has been called already.\n+   */\n+  void Finish();\n+\n+  /**\n+   * Abort streaming compilation. If {exception} has a value, then the promise\n+   * associated with streaming compilation is rejected with that value. If\n+   * {exception} does not have value, the promise does not get rejected.\n+   */\n+  void Abort(MaybeLocal<Value> exception);\n+\n+  /**\n+   * Unpacks a {WasmStreaming} object wrapped in a  {Managed} for the embedder.\n+   * Since the embedder is on the other side of the API, it cannot unpack the\n+   * {Managed} itself.\n+   */\n+  static std::shared_ptr<WasmStreaming> Unpack(Isolate* isolate,\n+                                               Local<Value> value);\n+\n+ private:\n+  std::unique_ptr<WasmStreamingImpl> impl_;\n+};\n+\n // TODO(mtrofin): when streaming compilation is done, we can rename this\n // to simply WasmModuleObjectBuilder\n class V8_EXPORT WasmModuleObjectBuilderStreaming final {\n@@ -5137,7 +5238,9 @@ class V8_EXPORT BooleanObject : public Object {\n  */\n class V8_EXPORT StringObject : public Object {\n  public:\n-  static Local<Value> New(Local<String> value);\n+  static Local<Value> New(Isolate* isolate, Local<String> value);\n+  static V8_DEPRECATE_SOON(\"Use Isolate* version\",\n+                           Local<Value> New(Local<String> value));\n \n   Local<String> ValueOf() const;\n \n@@ -5891,26 +5994,6 @@ enum class PropertyHandlerFlags {\n };\n \n struct NamedPropertyHandlerConfiguration {\n-  NamedPropertyHandlerConfiguration(\n-      GenericNamedPropertyGetterCallback getter,\n-      GenericNamedPropertySetterCallback setter,\n-      GenericNamedPropertyQueryCallback query,\n-      GenericNamedPropertyDeleterCallback deleter,\n-      GenericNamedPropertyEnumeratorCallback enumerator,\n-      GenericNamedPropertyDefinerCallback definer,\n-      GenericNamedPropertyDescriptorCallback descriptor,\n-      Local<Value> data = Local<Value>(),\n-      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)\n-      : getter(getter),\n-        setter(setter),\n-        query(query),\n-        deleter(deleter),\n-        enumerator(enumerator),\n-        definer(definer),\n-        descriptor(descriptor),\n-        data(data),\n-        flags(flags) {}\n-\n   NamedPropertyHandlerConfiguration(\n       /** Note: getter is required */\n       GenericNamedPropertyGetterCallback getter = 0,\n@@ -5962,25 +6045,6 @@ struct NamedPropertyHandlerConfiguration {\n \n \n struct IndexedPropertyHandlerConfiguration {\n-  IndexedPropertyHandlerConfiguration(\n-      IndexedPropertyGetterCallback getter,\n-      IndexedPropertySetterCallback setter, IndexedPropertyQueryCallback query,\n-      IndexedPropertyDeleterCallback deleter,\n-      IndexedPropertyEnumeratorCallback enumerator,\n-      IndexedPropertyDefinerCallback definer,\n-      IndexedPropertyDescriptorCallback descriptor,\n-      Local<Value> data = Local<Value>(),\n-      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)\n-      : getter(getter),\n-        setter(setter),\n-        query(query),\n-        deleter(deleter),\n-        enumerator(enumerator),\n-        definer(definer),\n-        descriptor(descriptor),\n-        data(data),\n-        flags(flags) {}\n-\n   IndexedPropertyHandlerConfiguration(\n       /** Note: getter is required */\n       IndexedPropertyGetterCallback getter = 0,\n@@ -6298,7 +6362,8 @@ class V8_EXPORT AccessorSignature : public Data {\n \n \n // --- Extensions ---\n-\n+V8_DEPRECATE_SOON(\"Implementation detail\",\n+                  class ExternalOneByteStringResourceImpl);\n class V8_EXPORT ExternalOneByteStringResourceImpl\n     : public String::ExternalOneByteStringResource {\n  public:\n@@ -6325,7 +6390,7 @@ class V8_EXPORT Extension {  // NOLINT\n             int dep_count = 0,\n             const char** deps = 0,\n             int source_length = -1);\n-  virtual ~Extension() { }\n+  virtual ~Extension() { delete source_; }\n   virtual Local<FunctionTemplate> GetNativeFunctionTemplate(\n       Isolate* isolate, Local<String> name) {\n     return Local<FunctionTemplate>();\n@@ -6334,7 +6399,8 @@ class V8_EXPORT Extension {  // NOLINT\n   const char* name() const { return name_; }\n   size_t source_length() const { return source_length_; }\n   const String::ExternalOneByteStringResource* source() const {\n-    return &source_; }\n+    return source_;\n+  }\n   int dependency_count() { return dep_count_; }\n   const char** dependencies() { return deps_; }\n   void set_auto_enable(bool value) { auto_enable_ = value; }\n@@ -6347,7 +6413,7 @@ class V8_EXPORT Extension {  // NOLINT\n  private:\n   const char* name_;\n   size_t source_length_;  // expected to initialize before source_\n-  ExternalOneByteStringResourceImpl source_;\n+  String::ExternalOneByteStringResource* source_;\n   int dep_count_;\n   const char** deps_;\n   bool auto_enable_;\n@@ -6679,6 +6745,9 @@ typedef bool (*AllowWasmCodeGenerationCallback)(Local<Context> context,\n // by the embedder. Example: WebAssembly.{compile|instantiate}Streaming ---\n typedef void (*ApiImplementationCallback)(const FunctionCallbackInfo<Value>&);\n \n+// --- Callback for WebAssembly.compileStreaming ---\n+typedef void (*WasmStreamingCallback)(const FunctionCallbackInfo<Value>&);\n+\n // --- Garbage Collection Callbacks ---\n \n /**\n@@ -6919,6 +6988,8 @@ struct JitCodeEvent {\n     // New location of instructions. Only valid for CODE_MOVED.\n     void* new_code_start;\n   };\n+\n+  Isolate* isolate;\n };\n \n /**\n@@ -7040,6 +7111,12 @@ class V8_EXPORT EmbedderHeapTracer {\n   virtual bool AdvanceTracing(double deadline_in_ms,\n                               AdvanceTracingActions actions) = 0;\n \n+  /*\n+   * Returns true if there no more tracing work to be done (see AdvanceTracing)\n+   * and false otherwise.\n+   */\n+  virtual bool IsTracingDone() { return NumberOfWrappersToTrace() == 0; }\n+\n   /**\n    * Called at the end of a GC cycle.\n    *\n@@ -7061,13 +7138,35 @@ class V8_EXPORT EmbedderHeapTracer {\n    */\n   virtual void AbortTracing() = 0;\n \n+  /*\n+   * Called by the embedder to request immediaet finalization of the currently\n+   * running tracing phase that has been started with TracePrologue and not\n+   * yet finished with TraceEpilogue.\n+   *\n+   * Will be a noop when currently not in tracing.\n+   *\n+   * This is an experimental feature.\n+   */\n+  void FinalizeTracing();\n+\n+  /*\n+   * Returns the v8::Isolate this tracer is attached too and |nullptr| if it\n+   * is not attached to any v8::Isolate.\n+   */\n+  v8::Isolate* isolate() const { return isolate_; }\n+\n   /**\n    * Returns the number of wrappers that are still to be traced by the embedder.\n    */\n-  virtual size_t NumberOfWrappersToTrace() { return 0; }\n+  V8_DEPRECATE_SOON(\"Use IsTracingDone\",\n+                    virtual size_t NumberOfWrappersToTrace() { return 0; });\n \n  protected:\n   virtual ~EmbedderHeapTracer() = default;\n+\n+  v8::Isolate* isolate_ = nullptr;\n+\n+  friend class internal::LocalEmbedderHeapTracer;\n };\n \n /**\n@@ -7361,6 +7460,7 @@ class V8_EXPORT Isolate {\n     kWebAssemblyInstantiation = 46,\n     kDeoptimizerDisableSpeculation = 47,\n     kArrayPrototypeSortJSArrayModifiedPrototype = 48,\n+    kFunctionTokenOffsetTooLongForToString = 49,\n \n     // If you add new values here, you'll also need to update Chromium's:\n     // web_feature.mojom, UseCounterCallback.cpp, and enums.xml. V8 changes to\n@@ -7616,15 +7716,7 @@ class V8_EXPORT Isolate {\n   HeapProfiler* GetHeapProfiler();\n \n   /**\n-   * Returns CPU profiler for this isolate. Will return NULL unless the isolate\n-   * is initialized. It is the embedder's responsibility to stop all CPU\n-   * profiling activities if it has started any.\n-   */\n-  V8_DEPRECATED(\"CpuProfiler should be created with CpuProfiler::New call.\",\n-                CpuProfiler* GetCpuProfiler());\n-\n-  /**\n-   * Tells the CPU profiler whether the embedder is idle.\n+   * Tells the VM whether the embedder is idle or not.\n    */\n   void SetIdle(bool is_idle);\n \n@@ -7703,6 +7795,85 @@ class V8_EXPORT Isolate {\n    */\n   void SetEmbedderHeapTracer(EmbedderHeapTracer* tracer);\n \n+  /**\n+   * Use for |AtomicsWaitCallback| to indicate the type of event it receives.\n+   */\n+  enum class AtomicsWaitEvent {\n+    /** Indicates that this call is happening before waiting. */\n+    kStartWait,\n+    /** `Atomics.wait()` finished because of an `Atomics.wake()` call. */\n+    kWokenUp,\n+    /** `Atomics.wait()` finished because it timed out. */\n+    kTimedOut,\n+    /** `Atomics.wait()` was interrupted through |TerminateExecution()|. */\n+    kTerminatedExecution,\n+    /** `Atomics.wait()` was stopped through |AtomicsWaitWakeHandle|. */\n+    kAPIStopped,\n+    /** `Atomics.wait()` did not wait, as the initial condition was not met. */\n+    kNotEqual\n+  };\n+\n+  /**\n+   * Passed to |AtomicsWaitCallback| as a means of stopping an ongoing\n+   * `Atomics.wait` call.\n+   */\n+  class V8_EXPORT AtomicsWaitWakeHandle {\n+   public:\n+    /**\n+     * Stop this `Atomics.wait()` call and call the |AtomicsWaitCallback|\n+     * with |kAPIStopped|.\n+     *\n+     * This function may be called from another thread. The caller has to ensure\n+     * through proper synchronization that it is not called after\n+     * the finishing |AtomicsWaitCallback|.\n+     *\n+     * Note that the ECMAScript specification does not plan for the possibility\n+     * of wakeups that are neither coming from a timeout or an `Atomics.wake()`\n+     * call, so this may invalidate assumptions made by existing code.\n+     * The embedder may accordingly wish to schedule an exception in the\n+     * finishing |AtomicsWaitCallback|.\n+     */\n+    void Wake();\n+  };\n+\n+  /**\n+   * Embedder callback for `Atomics.wait()` that can be added through\n+   * |SetAtomicsWaitCallback|.\n+   *\n+   * This will be called just before starting to wait with the |event| value\n+   * |kStartWait| and after finishing waiting with one of the other\n+   * values of |AtomicsWaitEvent| inside of an `Atomics.wait()` call.\n+   *\n+   * |array_buffer| will refer to the underlying SharedArrayBuffer,\n+   * |offset_in_bytes| to the location of the waited-on memory address inside\n+   * the SharedArrayBuffer.\n+   *\n+   * |value| and |timeout_in_ms| will be the values passed to\n+   * the `Atomics.wait()` call. If no timeout was used, |timeout_in_ms|\n+   * will be `INFINITY`.\n+   *\n+   * In the |kStartWait| callback, |stop_handle| will be an object that\n+   * is only valid until the corresponding finishing callback and that\n+   * can be used to stop the wait process while it is happening.\n+   *\n+   * This callback may schedule exceptions, *unless* |event| is equal to\n+   * |kTerminatedExecution|.\n+   */\n+  typedef void (*AtomicsWaitCallback)(AtomicsWaitEvent event,\n+                                      Local<SharedArrayBuffer> array_buffer,\n+                                      size_t offset_in_bytes, int32_t value,\n+                                      double timeout_in_ms,\n+                                      AtomicsWaitWakeHandle* stop_handle,\n+                                      void* data);\n+\n+  /**\n+   * Set a new |AtomicsWaitCallback|. This overrides an earlier\n+   * |AtomicsWaitCallback|, if there was any. If |callback| is nullptr,\n+   * this unsets the callback. |data| will be passed to the callback\n+   * as its last parameter.\n+   */\n+  void SetAtomicsWaitCallback(AtomicsWaitCallback callback, void* data);\n+\n   /**\n    * Enables the host application to receive a notification after a\n    * garbage collection. Allocations are allowed in the callback function,\n@@ -7956,6 +8127,18 @@ class V8_EXPORT Isolate {\n    */\n   void IsolateInBackgroundNotification();\n \n+  /**\n+   * Optional notification which will enable the memory savings mode.\n+   * V8 uses this notification to guide heuristics which may result in a\n+   * smaller memory footprint at the cost of reduced runtime performance.\n+   */\n+  void EnableMemorySavingsMode();\n+\n+  /**\n+   * Optional notification which will disable the memory savings mode.\n+   */\n+  void DisableMemorySavingsMode();\n+\n   /**\n    * Optional notification to tell V8 the current performance requirements\n    * of the embedder based on RAIL.\n@@ -8079,6 +8262,8 @@ class V8_EXPORT Isolate {\n \n   void SetWasmCompileStreamingCallback(ApiImplementationCallback callback);\n \n+  void SetWasmStreamingCallback(WasmStreamingCallback callback);\n+\n   /**\n   * Check if V8 is dead and therefore unusable.  This is the case after\n   * fatal errors such as out-of-memory situations.\n@@ -9927,7 +10112,6 @@ AccessorSignature* AccessorSignature::Cast(Data* data) {\n Local<Value> Object::GetInternalField(int index) {\n #ifndef V8_ENABLE_CHECKS\n   typedef internal::Object O;\n-  typedef internal::HeapObject HO;\n   typedef internal::Internals I;\n   O* obj = *reinterpret_cast<O**>(this);\n   // Fast path: If the object is a plain JSObject, which is the common case, we\n@@ -9938,7 +10122,8 @@ Local<Value> Object::GetInternalField(int index) {\n       instance_type == I::kJSSpecialApiObjectType) {\n     int offset = I::kJSObjectHeaderSize + (internal::kApiPointerSize * index);\n     O* value = I::ReadField<O*>(obj, offset);\n-    O** result = HandleScope::CreateHandle(reinterpret_cast<HO*>(obj), value);\n+    O** result = HandleScope::CreateHandle(\n+        reinterpret_cast<internal::NeverReadOnlySpaceObject*>(obj), value);\n     return Local<Value>(reinterpret_cast<Value*>(result));\n   }\n #endif\n@@ -10578,9 +10763,8 @@ int64_t Isolate::AdjustAmountOfExternalAllocatedMemory(\n Local<Value> Context::GetEmbedderData(int index) {\n #ifndef V8_ENABLE_CHECKS\n   typedef internal::Object O;\n-  typedef internal::HeapObject HO;\n   typedef internal::Internals I;\n-  HO* context = *reinterpret_cast<HO**>(this);\n+  auto* context = *reinterpret_cast<internal::NeverReadOnlySpaceObject**>(this);\n   O** result =\n       HandleScope::CreateHandle(context, I::ReadEmbedderData<O*>(this, index));\n   return Local<Value>(reinterpret_cast<Value*>(result));"
        },
        {
            "sha": "85fb595ae7e6c47d2acb5bc06a20500fe47c8675",
            "filename": "deps/v8/infra/config/cq.cfg",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finfra%2Fconfig%2Fcq.cfg",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finfra%2Fconfig%2Fcq.cfg",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finfra%2Fconfig%2Fcq.cfg?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -111,7 +111,5 @@ verifiers {\n       }\n     }\n   }\n-\n-  sign_cla {}\n }\n "
        },
        {
            "sha": "0492cf31a5f9b332adce4fd121867702fe91b6db",
            "filename": "deps/v8/infra/mb/mb_config.pyl",
            "status": "modified",
            "additions": 80,
            "deletions": 17,
            "changes": 97,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finfra%2Fmb%2Fmb_config.pyl",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finfra%2Fmb%2Fmb_config.pyl",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finfra%2Fmb%2Fmb_config.pyl?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -30,15 +30,27 @@\n       'ppc.debug': 'default_debug_ppc',\n       'ppc.optdebug': 'default_optdebug_ppc',\n       'ppc.release': 'default_release_ppc',\n+      'ppc.debug.sim': 'default_debug_ppc_sim',\n+      'ppc.optdebug.sim': 'default_optdebug_ppc_sim',\n+      'ppc.release.sim': 'default_release_ppc_sim',\n       'ppc64.debug': 'default_debug_ppc64',\n       'ppc64.optdebug': 'default_optdebug_ppc64',\n       'ppc64.release': 'default_release_ppc64',\n+      'ppc64.debug.sim': 'default_debug_ppc64_sim',\n+      'ppc64.optdebug.sim': 'default_optdebug_ppc64_sim',\n+      'ppc64.release.sim': 'default_release_ppc64_sim',\n       's390.debug': 'default_debug_s390',\n       's390.optdebug': 'default_optdebug_s390',\n       's390.release': 'default_release_s390',\n+      's390.debug.sim': 'default_debug_s390_sim',\n+      's390.optdebug.sim': 'default_optdebug_s390_sim',\n+      's390.release.sim': 'default_release_s390_sim',\n       's390x.debug': 'default_debug_s390x',\n       's390x.optdebug': 'default_optdebug_s390x',\n       's390x.release': 'default_release_s390x',\n+      's390x.debug.sim': 'default_debug_s390x_sim',\n+      's390x.optdebug.sim': 'default_optdebug_s390x_sim',\n+      's390x.release.sim': 'default_release_s390x_sim',\n       'x64.debug': 'default_debug_x64',\n       'x64.optdebug': 'default_optdebug_x64',\n       'x64.release': 'default_release_x64',\n@@ -95,6 +107,7 @@\n       'V8 Fuchsia': 'release_x64_fuchsia',\n       'V8 Fuchsia - debug': 'debug_x64_fuchsia',\n       'V8 Linux64 - cfi': 'release_x64_cfi',\n+      'V8 Linux64 UBSan': 'release_x64_ubsan',\n       'V8 Linux64 UBSanVptr': 'release_x64_ubsan_vptr',\n       'V8 Linux - vtunejit': 'debug_x86_vtunejit',\n       'V8 Linux64 - gcov coverage': 'release_x64_gcc_coverage',\n@@ -285,28 +298,52 @@\n     'default_release_mips64el': [\n       'release', 'simulate_mips64el'],\n     'default_debug_ppc': [\n-      'debug', 'simulate_ppc', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n+      'debug', 'ppc', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n     'default_optdebug_ppc': [\n-      'debug', 'simulate_ppc', 'v8_enable_slow_dchecks'],\n+      'debug', 'ppc', 'v8_enable_slow_dchecks'],\n     'default_release_ppc': [\n+      'release', 'ppc'],\n+    'default_debug_ppc_sim': [\n+      'debug', 'simulate_ppc', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n+    'default_optdebug_ppc_sim': [\n+      'debug', 'simulate_ppc', 'v8_enable_slow_dchecks'],\n+    'default_release_ppc_sim': [\n       'release', 'simulate_ppc'],\n     'default_debug_ppc64': [\n-      'debug', 'simulate_ppc64', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n+      'debug', 'ppc64', 'gcc', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n     'default_optdebug_ppc64': [\n-      'debug', 'simulate_ppc64', 'v8_enable_slow_dchecks'],\n+      'debug', 'ppc64', 'gcc', 'v8_enable_slow_dchecks'],\n     'default_release_ppc64': [\n+      'release', 'ppc64', 'gcc'],\n+    'default_debug_ppc64_sim': [\n+      'debug', 'simulate_ppc64', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n+    'default_optdebug_ppc64_sim': [\n+      'debug', 'simulate_ppc64', 'v8_enable_slow_dchecks'],\n+    'default_release_ppc64_sim': [\n       'release', 'simulate_ppc64'],\n     'default_debug_s390': [\n-      'debug', 'simulate_s390', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n+      'debug', 's390', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n     'default_optdebug_s390': [\n-      'debug', 'simulate_s390', 'v8_enable_slow_dchecks'],\n+      'debug', 's390', 'v8_enable_slow_dchecks'],\n     'default_release_s390': [\n+      'release', 's390'],\n+    'default_debug_s390_sim': [\n+      'debug', 'simulate_s390', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n+    'default_optdebug_s390_sim': [\n+      'debug', 'simulate_s390', 'v8_enable_slow_dchecks'],\n+    'default_release_s390_sim': [\n       'release', 'simulate_s390'],\n     'default_debug_s390x': [\n-      'debug', 'simulate_s390x', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n+      'debug', 's390x', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n     'default_optdebug_s390x': [\n-      'debug', 'simulate_s390x', 'v8_enable_slow_dchecks'],\n+      'debug', 's390x', 'v8_enable_slow_dchecks'],\n     'default_release_s390x': [\n+      'release', 's390x'],\n+    'default_debug_s390x_sim': [\n+      'debug', 'simulate_s390x', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n+    'default_optdebug_s390x_sim': [\n+      'debug', 'simulate_s390x', 'v8_enable_slow_dchecks'],\n+    'default_release_s390x_sim': [\n       'release', 'simulate_s390x'],\n     'default_debug_x64': [\n       'debug', 'x64', 'v8_enable_slow_dchecks', 'v8_full_debug'],\n@@ -417,8 +454,7 @@\n     'release_x64_gcc_coverage': [\n       'release_bot', 'x64', 'coverage', 'gcc', 'no_custom_libcxx', 'no_sysroot'],\n     'release_x64_internal': [\n-      'release_bot', 'x64', 'v8_enable_embedded_builtins',\n-      'v8_snapshot_internal'],\n+      'release_bot', 'x64', 'v8_snapshot_internal'],\n     'release_x64_jumbo': [\n       'release_bot', 'x64', 'jumbo'],\n     'release_x64_jumbo_trybot': [\n@@ -444,6 +480,8 @@\n       'minimal_symbols'],\n     'release_x64_tsan_minimal_symbols': [\n       'release_bot', 'x64', 'tsan', 'minimal_symbols'],\n+    'release_x64_ubsan': [\n+      'release_bot', 'x64', 'ubsan'],\n     'release_x64_ubsan_vptr': [\n       'release_bot', 'x64', 'ubsan_vptr'],\n     'release_x64_ubsan_vptr_recover_edge': [\n@@ -452,7 +490,7 @@\n       'release_bot', 'x64', 'ubsan_vptr', 'minimal_symbols'],\n     'release_x64_verify_csa': [\n       'release_bot', 'x64', 'dcheck_always_on',\n-      'v8_enable_slow_dchecks', 'v8_enable_embedded_builtins', 'v8_verify_csa'],\n+      'v8_enable_slow_dchecks', 'v8_verify_csa'],\n \n     # Debug configs for x64.\n     'debug_x64': [\n@@ -588,10 +626,14 @@\n       'gn_args': 'is_debug=true v8_enable_backtrace=true',\n     },\n \n+    'v8_use_multi_snapshots': {\n+      'gn_args': 'v8_use_multi_snapshots=true',\n+    },\n+\n     'debug_bot': {\n       'mixins': [\n         'debug', 'shared', 'goma', 'v8_enable_slow_dchecks',\n-        'v8_optimized_debug'],\n+        'v8_use_multi_snapshots', 'v8_optimized_debug'],\n     },\n \n     'debug_trybot': {\n@@ -678,7 +720,7 @@\n     },\n \n     'release_bot': {\n-      'mixins': ['release', 'static', 'goma'],\n+      'mixins': ['release', 'static', 'goma', 'v8_use_multi_snapshots'],\n     },\n \n     'release_trybot': {\n@@ -736,6 +778,14 @@\n       'gn_args': 'is_tsan=true',\n     },\n \n+    'ubsan': {\n+      'mixins': ['v8_enable_test_features'],\n+      # TODO(krasin): Remove is_ubsan_no_recover=true when\n+      # https://llvm.org/bugs/show_bug.cgi?id=25569 is fixed and just use\n+      # ubsan instead.\n+      'gn_args': 'is_ubsan=true is_ubsan_no_recover=true',\n+    },\n+\n     'ubsan_vptr': {\n       'mixins': ['v8_enable_test_features'],\n       # TODO(krasin): Remove is_ubsan_no_recover=true when\n@@ -763,10 +813,6 @@\n       'gn_args': 'v8_correctness_fuzzer=true v8_multi_arch_build=true',\n     },\n \n-    'v8_enable_embedded_builtins': {\n-      'gn_args': 'v8_enable_embedded_builtins=true',\n-    },\n-\n     'v8_enable_slow_dchecks': {\n       'gn_args': 'v8_enable_slow_dchecks=true',\n     },\n@@ -816,12 +862,29 @@\n       'gn_args': 'v8_enable_verify_csa=true',\n     },\n \n+    's390': {\n+      'gn_args': 'target_cpu=\"s390x\" v8_target_cpu=\"s390\"',\n+    },\n+\n+    's390x': {\n+      'gn_args': 'target_cpu=\"s390x\" v8_target_cpu=\"s390x\"',\n+    },\n+\n+    'ppc': {\n+      'gn_args': 'target_cpu=\"ppc\"',\n+    },\n+\n+    'ppc64': {\n+      'gn_args': 'target_cpu=\"ppc64\" use_custom_libcxx=false',\n+    },\n+\n     'x64': {\n       'gn_args': 'target_cpu=\"x64\"',\n     },\n \n     'x86': {\n       'gn_args': 'target_cpu=\"x86\"',\n     },\n+\n   },\n }"
        },
        {
            "sha": "f8fad69cb1aecad86c565e24095b91f2f67da820",
            "filename": "deps/v8/infra/testing/builders.pyl",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finfra%2Ftesting%2Fbuilders.pyl",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Finfra%2Ftesting%2Fbuilders.pyl",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finfra%2Ftesting%2Fbuilders.pyl?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -248,7 +248,7 @@\n       {'name': 'mjsunit_sp_frame_access'},\n       {'name': 'mozilla'},\n       {'name': 'test262'},\n-      {'name': 'v8testing', 'shards': 7},\n+      {'name': 'v8testing', 'shards': 9},\n       {'name': 'v8testing', 'variant': 'extra', 'shards': 3},\n     ],\n   },"
        },
        {
            "sha": "d75dcb3c3cc4eff1e42d84f79de43ea8f35dff88",
            "filename": "deps/v8/samples/hello-world.cc",
            "status": "modified",
            "additions": 57,
            "deletions": 16,
            "changes": 73,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsamples%2Fhello-world.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsamples%2Fhello-world.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsamples%2Fhello-world.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -34,22 +34,63 @@ int main(int argc, char* argv[]) {\n     // Enter the context for compiling and running the hello world script.\n     v8::Context::Scope context_scope(context);\n \n-    // Create a string containing the JavaScript source code.\n-    v8::Local<v8::String> source =\n-        v8::String::NewFromUtf8(isolate, \"'Hello' + ', World!'\",\n-                                v8::NewStringType::kNormal)\n-            .ToLocalChecked();\n-\n-    // Compile the source code.\n-    v8::Local<v8::Script> script =\n-        v8::Script::Compile(context, source).ToLocalChecked();\n-\n-    // Run the script to get the result.\n-    v8::Local<v8::Value> result = script->Run(context).ToLocalChecked();\n-\n-    // Convert the result to an UTF8 string and print it.\n-    v8::String::Utf8Value utf8(isolate, result);\n-    printf(\"%s\\n\", *utf8);\n+    {\n+      // Create a string containing the JavaScript source code.\n+      v8::Local<v8::String> source =\n+          v8::String::NewFromUtf8(isolate, \"'Hello' + ', World!'\",\n+                                  v8::NewStringType::kNormal)\n+              .ToLocalChecked();\n+\n+      // Compile the source code.\n+      v8::Local<v8::Script> script =\n+          v8::Script::Compile(context, source).ToLocalChecked();\n+\n+      // Run the script to get the result.\n+      v8::Local<v8::Value> result = script->Run(context).ToLocalChecked();\n+\n+      // Convert the result to an UTF8 string and print it.\n+      v8::String::Utf8Value utf8(isolate, result);\n+      printf(\"%s\\n\", *utf8);\n+    }\n+\n+    {\n+      // Use the JavaScript API to generate a WebAssembly module.\n+      //\n+      // |bytes| contains the binary format for the following module:\n+      //\n+      //     (func (export \"add\") (param i32 i32) (result i32)\n+      //       get_local 0\n+      //       get_local 1\n+      //       i32.add)\n+      //\n+      const char* csource = R\"(\n+        let bytes = new Uint8Array([\n+          0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01,\n+          0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x02, 0x01, 0x00, 0x07,\n+          0x07, 0x01, 0x03, 0x61, 0x64, 0x64, 0x00, 0x00, 0x0a, 0x09, 0x01,\n+          0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b\n+        ]);\n+        let module = new WebAssembly.Module(bytes);\n+        let instance = new WebAssembly.Instance(module);\n+        instance.exports.add(3, 4);\n+      )\";\n+\n+      // Create a string containing the JavaScript source code.\n+      v8::Local<v8::String> source =\n+          v8::String::NewFromUtf8(isolate, csource, v8::NewStringType::kNormal)\n+              .ToLocalChecked();\n+\n+      // Compile the source code.\n+      v8::Local<v8::Script> script =\n+          v8::Script::Compile(context, source).ToLocalChecked();\n+\n+      // Run the script to get the result.\n+      v8::Local<v8::Value> result = script->Run(context).ToLocalChecked();\n+\n+      // Convert the result to a uint32 and print it.\n+      uint32_t number = result->Uint32Value(context).ToChecked();\n+      printf(\"3 + 4 = %u\\n\", number);\n+    }\n   }\n \n   // Dispose the isolate and tear down V8."
        },
        {
            "sha": "ae59ec3356e87fe2b6493de9b88686d56ee16f54",
            "filename": "deps/v8/src/accessors.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 343,
            "changes": 361,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Faccessors.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Faccessors.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Faccessors.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -13,6 +13,7 @@\n #include \"src/isolate-inl.h\"\n #include \"src/messages.h\"\n #include \"src/objects/api-callbacks.h\"\n+#include \"src/objects/module-inl.h\"\n #include \"src/property-details.h\"\n #include \"src/prototype.h\"\n \n@@ -45,11 +46,11 @@ Handle<AccessorInfo> Accessors::MakeAccessor(\n   return info;\n }\n \n-static V8_INLINE bool CheckForName(Handle<Name> name,\n+static V8_INLINE bool CheckForName(Isolate* isolate, Handle<Name> name,\n                                    Handle<String> property_name, int offset,\n                                    FieldIndex::Encoding encoding,\n                                    FieldIndex* index) {\n-  if (Name::Equals(name, property_name)) {\n+  if (Name::Equals(isolate, name, property_name)) {\n     *index = FieldIndex::ForInObjectOffset(offset, encoding);\n     return true;\n   }\n@@ -59,17 +60,15 @@ static V8_INLINE bool CheckForName(Handle<Name> name,\n \n // Returns true for properties that are accessors to object fields.\n // If true, *object_offset contains offset of object field.\n-bool Accessors::IsJSObjectFieldAccessor(Handle<Map> map, Handle<Name> name,\n-                                        FieldIndex* index) {\n-  Isolate* isolate = name->GetIsolate();\n-\n+bool Accessors::IsJSObjectFieldAccessor(Isolate* isolate, Handle<Map> map,\n+                                        Handle<Name> name, FieldIndex* index) {\n   switch (map->instance_type()) {\n     case JS_ARRAY_TYPE:\n-      return CheckForName(name, isolate->factory()->length_string(),\n+      return CheckForName(isolate, name, isolate->factory()->length_string(),\n                           JSArray::kLengthOffset, FieldIndex::kTagged, index);\n     default:\n       if (map->instance_type() < FIRST_NONSTRING_TYPE) {\n-        return CheckForName(name, isolate->factory()->length_string(),\n+        return CheckForName(isolate, name, isolate->factory()->length_string(),\n                             String::kLengthOffset, FieldIndex::kTagged, index);\n       }\n \n@@ -169,7 +168,8 @@ void Accessors::ArrayLengthSetter(\n                               RuntimeCallCounterId::kArrayLengthSetter);\n   HandleScope scope(isolate);\n \n-  DCHECK(Utils::OpenHandle(*name)->SameValue(isolate->heap()->length_string()));\n+  DCHECK(Utils::OpenHandle(*name)->SameValue(\n+      ReadOnlyRoots(isolate).length_string()));\n \n   Handle<JSReceiver> object = Utils::OpenHandle(*info.Holder());\n   Handle<JSArray> array = Handle<JSArray>::cast(object);\n@@ -237,7 +237,8 @@ void Accessors::ModuleNamespaceEntryGetter(\n   JSModuleNamespace* holder =\n       JSModuleNamespace::cast(*Utils::OpenHandle(*info.Holder()));\n   Handle<Object> result;\n-  if (!holder->GetExport(Handle<String>::cast(Utils::OpenHandle(*name)))\n+  if (!holder\n+           ->GetExport(isolate, Handle<String>::cast(Utils::OpenHandle(*name)))\n            .ToHandle(&result)) {\n     isolate->OptionalRescheduleException(false);\n   } else {\n@@ -304,333 +305,6 @@ Handle<AccessorInfo> Accessors::MakeStringLengthInfo(Isolate* isolate) {\n                       &StringLengthGetter, nullptr);\n }\n \n-//\n-// Accessors::ScriptColumnOffset\n-//\n-\n-\n-void Accessors::ScriptColumnOffsetGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* res = Smi::FromInt(\n-      Script::cast(JSValue::cast(object)->value())->column_offset());\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(res, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptColumnOffsetInfo(Isolate* isolate) {\n-  Handle<String> name(isolate->factory()->InternalizeOneByteString(\n-      STATIC_CHAR_VECTOR(\"column_offset\")));\n-  return MakeAccessor(isolate, name, &ScriptColumnOffsetGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptId\n-//\n-\n-\n-void Accessors::ScriptIdGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* id = Smi::FromInt(Script::cast(JSValue::cast(object)->value())->id());\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(id, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptIdInfo(Isolate* isolate) {\n-  Handle<String> name(\n-      isolate->factory()->InternalizeOneByteString(STATIC_CHAR_VECTOR(\"id\")));\n-  return MakeAccessor(isolate, name, &ScriptIdGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptName\n-//\n-\n-\n-void Accessors::ScriptNameGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* source = Script::cast(JSValue::cast(object)->value())->name();\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(source, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptNameInfo(Isolate* isolate) {\n-  return MakeAccessor(isolate, isolate->factory()->name_string(),\n-                      &ScriptNameGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptSource\n-//\n-\n-\n-void Accessors::ScriptSourceGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* source = Script::cast(JSValue::cast(object)->value())->source();\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(source, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptSourceInfo(Isolate* isolate) {\n-  return MakeAccessor(isolate, isolate->factory()->source_string(),\n-                      &ScriptSourceGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptLineOffset\n-//\n-\n-\n-void Accessors::ScriptLineOffsetGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* res =\n-      Smi::FromInt(Script::cast(JSValue::cast(object)->value())->line_offset());\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(res, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptLineOffsetInfo(Isolate* isolate) {\n-  Handle<String> name(isolate->factory()->InternalizeOneByteString(\n-      STATIC_CHAR_VECTOR(\"line_offset\")));\n-  return MakeAccessor(isolate, name, &ScriptLineOffsetGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptType\n-//\n-\n-\n-void Accessors::ScriptTypeGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* res =\n-      Smi::FromInt(Script::cast(JSValue::cast(object)->value())->type());\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(res, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptTypeInfo(Isolate* isolate) {\n-  Handle<String> name(\n-      isolate->factory()->InternalizeOneByteString(STATIC_CHAR_VECTOR(\"type\")));\n-  return MakeAccessor(isolate, name, &ScriptTypeGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptCompilationType\n-//\n-\n-\n-void Accessors::ScriptCompilationTypeGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* res = Smi::FromInt(\n-      Script::cast(JSValue::cast(object)->value())->compilation_type());\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(res, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptCompilationTypeInfo(\n-    Isolate* isolate) {\n-  Handle<String> name(isolate->factory()->InternalizeOneByteString(\n-      STATIC_CHAR_VECTOR(\"compilation_type\")));\n-  return MakeAccessor(isolate, name, &ScriptCompilationTypeGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptSourceUrl\n-//\n-\n-\n-void Accessors::ScriptSourceUrlGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* url = Script::cast(JSValue::cast(object)->value())->source_url();\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(url, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptSourceUrlInfo(Isolate* isolate) {\n-  Handle<String> name(isolate->factory()->InternalizeOneByteString(\n-      STATIC_CHAR_VECTOR(\"source_url\")));\n-  return MakeAccessor(isolate, name, &ScriptSourceUrlGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptSourceMappingUrl\n-//\n-\n-\n-void Accessors::ScriptSourceMappingUrlGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* url =\n-      Script::cast(JSValue::cast(object)->value())->source_mapping_url();\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(url, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptSourceMappingUrlInfo(\n-    Isolate* isolate) {\n-  Handle<String> name(isolate->factory()->InternalizeOneByteString(\n-      STATIC_CHAR_VECTOR(\"source_mapping_url\")));\n-  return MakeAccessor(isolate, name, &ScriptSourceMappingUrlGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptGetContextData\n-//\n-\n-\n-void Accessors::ScriptContextDataGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  DisallowHeapAllocation no_allocation;\n-  HandleScope scope(isolate);\n-  Object* object = *Utils::OpenHandle(*info.Holder());\n-  Object* res = Script::cast(JSValue::cast(object)->value())->context_data();\n-  info.GetReturnValue().Set(Utils::ToLocal(Handle<Object>(res, isolate)));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptContextDataInfo(Isolate* isolate) {\n-  Handle<String> name(isolate->factory()->InternalizeOneByteString(\n-      STATIC_CHAR_VECTOR(\"context_data\")));\n-  return MakeAccessor(isolate, name, &ScriptContextDataGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptGetEvalFromScript\n-//\n-\n-\n-void Accessors::ScriptEvalFromScriptGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  HandleScope scope(isolate);\n-  Handle<Object> object = Utils::OpenHandle(*info.Holder());\n-  Handle<Script> script(\n-      Script::cast(Handle<JSValue>::cast(object)->value()), isolate);\n-  Handle<Object> result = isolate->factory()->undefined_value();\n-  if (script->has_eval_from_shared()) {\n-    Handle<SharedFunctionInfo> eval_from_shared(script->eval_from_shared());\n-    if (eval_from_shared->script()->IsScript()) {\n-      Handle<Script> eval_from_script(Script::cast(eval_from_shared->script()));\n-      result = Script::GetWrapper(eval_from_script);\n-    }\n-  }\n-\n-  info.GetReturnValue().Set(Utils::ToLocal(result));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptEvalFromScriptInfo(Isolate* isolate) {\n-  Handle<String> name(isolate->factory()->InternalizeOneByteString(\n-      STATIC_CHAR_VECTOR(\"eval_from_script\")));\n-  return MakeAccessor(isolate, name, &ScriptEvalFromScriptGetter, nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptGetEvalFromScriptPosition\n-//\n-\n-\n-void Accessors::ScriptEvalFromScriptPositionGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  HandleScope scope(isolate);\n-  Handle<Object> object = Utils::OpenHandle(*info.Holder());\n-  Handle<Script> script(\n-      Script::cast(Handle<JSValue>::cast(object)->value()), isolate);\n-  Handle<Object> result = isolate->factory()->undefined_value();\n-  if (script->compilation_type() == Script::COMPILATION_TYPE_EVAL) {\n-    result = Handle<Object>(Smi::FromInt(script->GetEvalPosition()), isolate);\n-  }\n-  info.GetReturnValue().Set(Utils::ToLocal(result));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptEvalFromScriptPositionInfo(\n-    Isolate* isolate) {\n-  Handle<String> name(isolate->factory()->InternalizeOneByteString(\n-      STATIC_CHAR_VECTOR(\"eval_from_script_position\")));\n-  return MakeAccessor(isolate, name, &ScriptEvalFromScriptPositionGetter,\n-                      nullptr);\n-}\n-\n-\n-//\n-// Accessors::ScriptGetEvalFromFunctionName\n-//\n-\n-\n-void Accessors::ScriptEvalFromFunctionNameGetter(\n-    v8::Local<v8::Name> name,\n-    const v8::PropertyCallbackInfo<v8::Value>& info) {\n-  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());\n-  HandleScope scope(isolate);\n-  Handle<Object> object = Utils::OpenHandle(*info.Holder());\n-  Handle<Script> script(\n-      Script::cast(Handle<JSValue>::cast(object)->value()), isolate);\n-  Handle<Object> result = isolate->factory()->undefined_value();\n-  if (script->has_eval_from_shared()) {\n-    Handle<SharedFunctionInfo> shared(script->eval_from_shared());\n-    // Find the name of the function calling eval.\n-    result = Handle<Object>(shared->Name(), isolate);\n-  }\n-  info.GetReturnValue().Set(Utils::ToLocal(result));\n-}\n-\n-Handle<AccessorInfo> Accessors::MakeScriptEvalFromFunctionNameInfo(\n-    Isolate* isolate) {\n-  Handle<String> name(isolate->factory()->InternalizeOneByteString(\n-      STATIC_CHAR_VECTOR(\"eval_from_function_name\")));\n-  return MakeAccessor(isolate, name, &ScriptEvalFromFunctionNameGetter,\n-                      nullptr);\n-}\n-\n-\n //\n // Accessors::FunctionPrototype\n //\n@@ -824,7 +498,7 @@ Handle<JSObject> GetFrameArguments(Isolate* isolate,\n       // Generators currently use holes as dummy arguments when resuming.  We\n       // must not leak those.\n       DCHECK(IsResumableFunction(function->shared()->kind()));\n-      value = isolate->heap()->undefined_value();\n+      value = ReadOnlyRoots(isolate).undefined_value();\n     }\n     array->set(i, value);\n   }\n@@ -1118,9 +792,9 @@ MaybeHandle<JSReceiver> ClearInternalStackTrace(Isolate* isolate,\n                                                 Handle<JSObject> error) {\n   RETURN_ON_EXCEPTION(\n       isolate,\n-      JSReceiver::SetProperty(error, isolate->factory()->stack_trace_symbol(),\n-                              isolate->factory()->undefined_value(),\n-                              LanguageMode::kStrict),\n+      JSReceiver::SetProperty(\n+          isolate, error, isolate->factory()->stack_trace_symbol(),\n+          isolate->factory()->undefined_value(), LanguageMode::kStrict),\n       JSReceiver);\n   return error;\n }\n@@ -1152,7 +826,7 @@ void Accessors::ErrorStackGetter(\n   Handle<Object> stack_trace;\n   Handle<Symbol> stack_trace_symbol = isolate->factory()->stack_trace_symbol();\n   MaybeHandle<Object> maybe_stack_trace =\n-      JSObject::GetProperty(holder, stack_trace_symbol);\n+      JSObject::GetProperty(isolate, holder, stack_trace_symbol);\n   if (!maybe_stack_trace.ToHandle(&stack_trace) ||\n       stack_trace->IsUndefined(isolate)) {\n     Handle<Object> result = isolate->factory()->undefined_value();\n@@ -1191,7 +865,8 @@ void Accessors::ErrorStackGetter(\n     }\n   } else {\n     // The stack property has been modified in the meantime.\n-    if (!JSObject::GetProperty(holder, name).ToHandle(&formatted_stack_trace)) {\n+    if (!JSObject::GetProperty(isolate, holder, name)\n+             .ToHandle(&formatted_stack_trace)) {\n       isolate->OptionalRescheduleException(false);\n       return;\n     }"
        },
        {
            "sha": "301f830a9aba2bc8a8b2f7f40f514077f9a6e8b4",
            "filename": "deps/v8/src/accessors.h",
            "status": "modified",
            "additions": 2,
            "deletions": 14,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Faccessors.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Faccessors.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Faccessors.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -33,19 +33,6 @@ class JavaScriptFrame;\n   V(function_name, FunctionName)                                    \\\n   V(function_length, FunctionLength)                                \\\n   V(function_prototype, FunctionPrototype)                          \\\n-  V(script_column_offset, ScriptColumnOffset)                       \\\n-  V(script_compilation_type, ScriptCompilationType)                 \\\n-  V(script_context_data, ScriptContextData)                         \\\n-  V(script_eval_from_script, ScriptEvalFromScript)                  \\\n-  V(script_eval_from_script_position, ScriptEvalFromScriptPosition) \\\n-  V(script_eval_from_function_name, ScriptEvalFromFunctionName)     \\\n-  V(script_id, ScriptId)                                            \\\n-  V(script_line_offset, ScriptLineOffset)                           \\\n-  V(script_name, ScriptName)                                        \\\n-  V(script_source, ScriptSource)                                    \\\n-  V(script_type, ScriptType)                                        \\\n-  V(script_source_url, ScriptSourceUrl)                             \\\n-  V(script_source_mapping_url, ScriptSourceMappingUrl)              \\\n   V(string_length, StringLength)\n \n #define SIDE_EFFECT_FREE_ACCESSOR_INFO_LIST(V) \\\n@@ -106,7 +93,8 @@ class Accessors : public AllStatic {\n \n   // Returns true for properties that are accessors to object fields.\n   // If true, the matching FieldIndex is returned through |field_index|.\n-  static bool IsJSObjectFieldAccessor(Handle<Map> map, Handle<Name> name,\n+  static bool IsJSObjectFieldAccessor(Isolate* isolate, Handle<Map> map,\n+                                      Handle<Name> name,\n                                       FieldIndex* field_index);\n \n   static MaybeHandle<Object> ReplaceAccessorWithDataProperty("
        },
        {
            "sha": "599e44724ab1d9562bcf2d32e6d7b23be999ee1d",
            "filename": "deps/v8/src/address-map.h",
            "status": "modified",
            "additions": 0,
            "deletions": 175,
            "changes": 175,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Faddress-map.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Faddress-map.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Faddress-map.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -69,181 +69,6 @@ class RootIndexMap {\n   DISALLOW_COPY_AND_ASSIGN(RootIndexMap);\n };\n \n-class SerializerReference {\n- public:\n-  SerializerReference() : bitfield_(Special(kInvalidValue)) {}\n-\n-  static SerializerReference FromBitfield(uint32_t bitfield) {\n-    return SerializerReference(bitfield);\n-  }\n-\n-  static SerializerReference BackReference(AllocationSpace space,\n-                                           uint32_t chunk_index,\n-                                           uint32_t chunk_offset) {\n-    DCHECK(IsAligned(chunk_offset, kObjectAlignment));\n-    DCHECK_NE(LO_SPACE, space);\n-    return SerializerReference(\n-        SpaceBits::encode(space) | ChunkIndexBits::encode(chunk_index) |\n-        ChunkOffsetBits::encode(chunk_offset >> kObjectAlignmentBits));\n-  }\n-\n-  static SerializerReference MapReference(uint32_t index) {\n-    return SerializerReference(SpaceBits::encode(MAP_SPACE) |\n-                               ValueIndexBits::encode(index));\n-  }\n-\n-  static SerializerReference OffHeapBackingStoreReference(uint32_t index) {\n-    return SerializerReference(SpaceBits::encode(kExternalSpace) |\n-                               ValueIndexBits::encode(index));\n-  }\n-\n-  static SerializerReference LargeObjectReference(uint32_t index) {\n-    return SerializerReference(SpaceBits::encode(LO_SPACE) |\n-                               ValueIndexBits::encode(index));\n-  }\n-\n-  static SerializerReference AttachedReference(uint32_t index) {\n-    return SerializerReference(SpaceBits::encode(kAttachedReferenceSpace) |\n-                               ValueIndexBits::encode(index));\n-  }\n-\n-  static SerializerReference DummyReference() {\n-    return SerializerReference(Special(kDummyValue));\n-  }\n-\n-  bool is_valid() const { return bitfield_ != Special(kInvalidValue); }\n-\n-  bool is_back_reference() const {\n-    return SpaceBits::decode(bitfield_) <= LAST_SPACE;\n-  }\n-\n-  AllocationSpace space() const {\n-    DCHECK(is_back_reference());\n-    return static_cast<AllocationSpace>(SpaceBits::decode(bitfield_));\n-  }\n-\n-  uint32_t chunk_offset() const {\n-    DCHECK(is_back_reference());\n-    return ChunkOffsetBits::decode(bitfield_) << kObjectAlignmentBits;\n-  }\n-\n-  uint32_t map_index() const {\n-    DCHECK(is_back_reference());\n-    return ValueIndexBits::decode(bitfield_);\n-  }\n-\n-  bool is_off_heap_backing_store_reference() const {\n-    return SpaceBits::decode(bitfield_) == kExternalSpace;\n-  }\n-\n-  uint32_t off_heap_backing_store_index() const {\n-    DCHECK(is_off_heap_backing_store_reference());\n-    return ValueIndexBits::decode(bitfield_);\n-  }\n-\n-  uint32_t large_object_index() const {\n-    DCHECK(is_back_reference());\n-    return ValueIndexBits::decode(bitfield_);\n-  }\n-\n-  uint32_t chunk_index() const {\n-    DCHECK(is_back_reference());\n-    return ChunkIndexBits::decode(bitfield_);\n-  }\n-\n-  uint32_t back_reference() const {\n-    DCHECK(is_back_reference());\n-    return bitfield_ & (ChunkOffsetBits::kMask | ChunkIndexBits::kMask);\n-  }\n-\n-  bool is_attached_reference() const {\n-    return SpaceBits::decode(bitfield_) == kAttachedReferenceSpace;\n-  }\n-\n-  int attached_reference_index() const {\n-    DCHECK(is_attached_reference());\n-    return ValueIndexBits::decode(bitfield_);\n-  }\n-\n- private:\n-  explicit SerializerReference(uint32_t bitfield) : bitfield_(bitfield) {}\n-\n-  inline static uint32_t Special(int value) {\n-    return SpaceBits::encode(kSpecialValueSpace) |\n-           ValueIndexBits::encode(value);\n-  }\n-\n-  // We use the 32-bit bitfield to encode either a back reference, a special\n-  // value, or an attached reference index.\n-  // Back reference:\n-  //   [ Space index             ] [ Chunk index ] [ Chunk offset ]\n-  //   [ LO_SPACE                ] [ large object index           ]\n-  // Special value\n-  //   [ kSpecialValueSpace      ] [ Special value index          ]\n-  // Attached reference\n-  //   [ kAttachedReferenceSpace ] [ Attached reference index     ]\n-  // External\n-  //   [ kExternalSpace          ] [ External reference index     ]\n-\n-  static const int kChunkOffsetSize = kPageSizeBits - kObjectAlignmentBits;\n-  static const int kChunkIndexSize = 32 - kChunkOffsetSize - kSpaceTagSize;\n-  static const int kValueIndexSize = kChunkOffsetSize + kChunkIndexSize;\n-\n-  static const int kSpecialValueSpace = LAST_SPACE + 1;\n-  static const int kAttachedReferenceSpace = kSpecialValueSpace + 1;\n-  static const int kExternalSpace = kAttachedReferenceSpace + 1;\n-  STATIC_ASSERT(kExternalSpace < (1 << kSpaceTagSize));\n-\n-  static const int kInvalidValue = 0;\n-  static const int kDummyValue = 1;\n-\n-  // The chunk offset can also be used to encode the index of special values.\n-  class ChunkOffsetBits : public BitField<uint32_t, 0, kChunkOffsetSize> {};\n-  class ChunkIndexBits\n-      : public BitField<uint32_t, ChunkOffsetBits::kNext, kChunkIndexSize> {};\n-  class ValueIndexBits : public BitField<uint32_t, 0, kValueIndexSize> {};\n-  STATIC_ASSERT(ChunkIndexBits::kNext == ValueIndexBits::kNext);\n-  class SpaceBits : public BitField<int, kValueIndexSize, kSpaceTagSize> {};\n-  STATIC_ASSERT(SpaceBits::kNext == 32);\n-\n-  uint32_t bitfield_;\n-\n-  friend class SerializerReferenceMap;\n-};\n-\n-// Mapping objects to their location after deserialization.\n-// This is used during building, but not at runtime by V8.\n-class SerializerReferenceMap {\n- public:\n-  SerializerReferenceMap()\n-      : no_allocation_(), map_(), attached_reference_index_(0) {}\n-\n-  SerializerReference Lookup(void* obj) {\n-    Maybe<uint32_t> maybe_index = map_.Get(obj);\n-    return maybe_index.IsJust() ? SerializerReference(maybe_index.FromJust())\n-                                : SerializerReference();\n-  }\n-\n-  void Add(void* obj, SerializerReference b) {\n-    DCHECK(b.is_valid());\n-    DCHECK(map_.Get(obj).IsNothing());\n-    map_.Set(obj, b.bitfield_);\n-  }\n-\n-  SerializerReference AddAttachedReference(HeapObject* attached_reference) {\n-    SerializerReference reference =\n-        SerializerReference::AttachedReference(attached_reference_index_++);\n-    Add(attached_reference, reference);\n-    return reference;\n-  }\n-\n- private:\n-  DisallowHeapAllocation no_allocation_;\n-  PointerToIndexHashMap<void*> map_;\n-  int attached_reference_index_;\n-  DISALLOW_COPY_AND_ASSIGN(SerializerReferenceMap);\n-};\n-\n }  // namespace internal\n }  // namespace v8\n "
        },
        {
            "sha": "8e17a35514e4bf6f7edb56f9ff98d79cbd927689",
            "filename": "deps/v8/src/allocation.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fallocation.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fallocation.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fallocation.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -71,8 +71,8 @@ char* StrNDup(const char* str, int n);\n // and free. Used as the default policy for lists.\n class FreeStoreAllocationPolicy {\n  public:\n-  INLINE(void* New(size_t size)) { return Malloced::New(size); }\n-  INLINE(static void Delete(void* p)) { Malloced::Delete(p); }\n+  V8_INLINE void* New(size_t size) { return Malloced::New(size); }\n+  V8_INLINE static void Delete(void* p) { Malloced::Delete(p); }\n };\n \n // Performs a malloc, with retry logic on failure. Returns nullptr on failure."
        },
        {
            "sha": "4d91b68521bd020fa2ee7f47756db72e3bbedf65",
            "filename": "deps/v8/src/api-arguments-inl.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi-arguments-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi-arguments-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi-arguments-inl.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -85,7 +85,8 @@ Handle<Object> FunctionCallbackArguments::Call(CallHandlerInfo* handler) {\n   v8::FunctionCallback f =\n       v8::ToCData<v8::FunctionCallback>(handler->callback());\n   if (isolate->debug_execution_mode() == DebugInfo::kSideEffects &&\n-      !isolate->debug()->PerformSideEffectCheckForCallback(handle(handler))) {\n+      !isolate->debug()->PerformSideEffectCheckForCallback(\n+          handle(handler, isolate))) {\n     return Handle<Object>();\n   }\n   VMState<EXTERNAL> state(isolate);"
        },
        {
            "sha": "bed1c123e0e297ff10bdb3ec537c092ee83c3331",
            "filename": "deps/v8/src/api-arguments.h",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi-arguments.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi-arguments.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi-arguments.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -93,9 +93,9 @@ class PropertyCallbackArguments\n \n     // Here the hole is set as default value.\n     // It cannot escape into js as it's removed in Call below.\n-    values[T::kReturnValueDefaultValueIndex] =\n-        isolate->heap()->the_hole_value();\n-    values[T::kReturnValueIndex] = isolate->heap()->the_hole_value();\n+    HeapObject* the_hole = ReadOnlyRoots(isolate).the_hole_value();\n+    values[T::kReturnValueDefaultValueIndex] = the_hole;\n+    values[T::kReturnValueIndex] = the_hole;\n     DCHECK(values[T::kHolderIndex]->IsHeapObject());\n     DCHECK(values[T::kIsolateIndex]->IsSmi());\n   }\n@@ -200,9 +200,9 @@ class FunctionCallbackArguments\n     values[T::kIsolateIndex] = reinterpret_cast<internal::Object*>(isolate);\n     // Here the hole is set as default value.\n     // It cannot escape into js as it's remove in Call below.\n-    values[T::kReturnValueDefaultValueIndex] =\n-        isolate->heap()->the_hole_value();\n-    values[T::kReturnValueIndex] = isolate->heap()->the_hole_value();\n+    HeapObject* the_hole = ReadOnlyRoots(isolate).the_hole_value();\n+    values[T::kReturnValueDefaultValueIndex] = the_hole;\n+    values[T::kReturnValueIndex] = the_hole;\n     DCHECK(values[T::kHolderIndex]->IsHeapObject());\n     DCHECK(values[T::kIsolateIndex]->IsSmi());\n   }"
        },
        {
            "sha": "11dd4d67d53d447ca8c29a1a4e47a646b50c5bdd",
            "filename": "deps/v8/src/api-natives.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 18,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi-natives.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi-natives.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi-natives.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -122,18 +122,18 @@ MaybeHandle<Object> DefineDataProperty(Isolate* isolate,\n \n \n void DisableAccessChecks(Isolate* isolate, Handle<JSObject> object) {\n-  Handle<Map> old_map(object->map());\n+  Handle<Map> old_map(object->map(), isolate);\n   // Copy map so it won't interfere constructor's initial map.\n-  Handle<Map> new_map = Map::Copy(old_map, \"DisableAccessChecks\");\n+  Handle<Map> new_map = Map::Copy(isolate, old_map, \"DisableAccessChecks\");\n   new_map->set_is_access_check_needed(false);\n   JSObject::MigrateToMap(Handle<JSObject>::cast(object), new_map);\n }\n \n \n void EnableAccessChecks(Isolate* isolate, Handle<JSObject> object) {\n-  Handle<Map> old_map(object->map());\n+  Handle<Map> old_map(object->map(), isolate);\n   // Copy map so it won't interfere constructor's initial map.\n-  Handle<Map> new_map = Map::Copy(old_map, \"EnableAccessChecks\");\n+  Handle<Map> new_map = Map::Copy(isolate, old_map, \"EnableAccessChecks\");\n   new_map->set_is_access_check_needed(true);\n   new_map->set_may_have_interesting_symbols(true);\n   JSObject::MigrateToMap(object, new_map);\n@@ -202,19 +202,20 @@ MaybeHandle<JSObject> ConfigureInstance(Isolate* isolate, Handle<JSObject> obj,\n     Handle<FixedArray> array =\n         isolate->factory()->NewFixedArray(max_number_of_properties);\n \n-    for (Handle<TemplateInfoT> temp(*data); *temp != nullptr;\n+    for (Handle<TemplateInfoT> temp(*data, isolate); *temp != nullptr;\n          temp = handle(temp->GetParent(isolate), isolate)) {\n       // Accumulate accessors.\n       Object* maybe_properties = temp->property_accessors();\n       if (!maybe_properties->IsUndefined(isolate)) {\n         valid_descriptors = AccessorInfo::AppendUnique(\n-            handle(maybe_properties, isolate), array, valid_descriptors);\n+            isolate, handle(maybe_properties, isolate), array,\n+            valid_descriptors);\n       }\n     }\n \n     // Install accumulated accessors.\n     for (int i = 0; i < valid_descriptors; i++) {\n-      Handle<AccessorInfo> accessor(AccessorInfo::cast(array->get(i)));\n+      Handle<AccessorInfo> accessor(AccessorInfo::cast(array->get(i)), isolate);\n       Handle<Name> name(Name::cast(accessor->name()), isolate);\n       JSObject::SetAccessor(obj, name, accessor,\n                             accessor->initial_property_attributes())\n@@ -290,7 +291,7 @@ MaybeHandle<JSObject> ProbeInstantiationsCache(Isolate* isolate,\n               TemplateInfo::kSlowTemplateInstantiationsCacheSize)) {\n     Handle<SimpleNumberDictionary> slow_cache =\n         isolate->slow_template_instantiations_cache();\n-    int entry = slow_cache->FindEntry(serial_number);\n+    int entry = slow_cache->FindEntry(isolate, serial_number);\n     if (entry == SimpleNumberDictionary::kNotFound) {\n       return MaybeHandle<JSObject>();\n     }\n@@ -308,7 +309,7 @@ void CacheTemplateInstantiation(Isolate* isolate, int serial_number,\n     Handle<FixedArray> fast_cache =\n         isolate->fast_template_instantiations_cache();\n     Handle<FixedArray> new_cache =\n-        FixedArray::SetAndGrow(fast_cache, serial_number - 1, object);\n+        FixedArray::SetAndGrow(isolate, fast_cache, serial_number - 1, object);\n     if (*new_cache != *fast_cache) {\n       isolate->native_context()->set_fast_template_instantiations_cache(\n           *new_cache);\n@@ -318,7 +319,8 @@ void CacheTemplateInstantiation(Isolate* isolate, int serial_number,\n               TemplateInfo::kSlowTemplateInstantiationsCacheSize)) {\n     Handle<SimpleNumberDictionary> cache =\n         isolate->slow_template_instantiations_cache();\n-    auto new_cache = SimpleNumberDictionary::Set(cache, serial_number, object);\n+    auto new_cache =\n+        SimpleNumberDictionary::Set(isolate, cache, serial_number, object);\n     if (*new_cache != *cache) {\n       isolate->native_context()->set_slow_template_instantiations_cache(\n           *new_cache);\n@@ -339,9 +341,9 @@ void UncacheTemplateInstantiation(Isolate* isolate, int serial_number,\n               TemplateInfo::kSlowTemplateInstantiationsCacheSize)) {\n     Handle<SimpleNumberDictionary> cache =\n         isolate->slow_template_instantiations_cache();\n-    int entry = cache->FindEntry(serial_number);\n+    int entry = cache->FindEntry(isolate, serial_number);\n     DCHECK_NE(SimpleNumberDictionary::kNotFound, entry);\n-    cache = SimpleNumberDictionary::DeleteEntry(cache, entry);\n+    cache = SimpleNumberDictionary::DeleteEntry(isolate, cache, entry);\n     isolate->native_context()->set_slow_template_instantiations_cache(*cache);\n   }\n }\n@@ -443,7 +445,7 @@ MaybeHandle<Object> GetInstancePrototype(Isolate* isolate,\n   // TODO(cbruni): decide what to do here.\n   ASSIGN_RETURN_ON_EXCEPTION(\n       isolate, instance_prototype,\n-      JSObject::GetProperty(parent_instance,\n+      JSObject::GetProperty(isolate, parent_instance,\n                             isolate->factory()->prototype_string()),\n       JSFunction);\n   return scope.CloseAndEscape(instance_prototype);\n@@ -544,8 +546,8 @@ MaybeHandle<JSFunction> ApiNatives::InstantiateFunction(\n }\n \n MaybeHandle<JSObject> ApiNatives::InstantiateObject(\n-    Handle<ObjectTemplateInfo> data, Handle<JSReceiver> new_target) {\n-  Isolate* isolate = data->GetIsolate();\n+    Isolate* isolate, Handle<ObjectTemplateInfo> data,\n+    Handle<JSReceiver> new_target) {\n   InvokeScope invoke_scope(isolate);\n   return ::v8::internal::InstantiateObject(isolate, data, new_target, false,\n                                            false);\n@@ -557,7 +559,7 @@ MaybeHandle<JSObject> ApiNatives::InstantiateRemoteObject(\n   InvokeScope invoke_scope(isolate);\n \n   Handle<FunctionTemplateInfo> constructor(\n-      FunctionTemplateInfo::cast(data->constructor()));\n+      FunctionTemplateInfo::cast(data->constructor()), isolate);\n   Handle<Map> object_map = isolate->factory()->NewMap(\n       JS_SPECIAL_API_OBJECT_TYPE,\n       JSObject::kHeaderSize + data->embedder_field_count() * kPointerSize,\n@@ -654,7 +656,7 @@ Handle<JSFunction> ApiNatives::CreateApiFunction(\n   if (prototype->IsTheHole(isolate)) {\n     prototype = isolate->factory()->NewFunctionPrototype(result);\n   } else if (obj->prototype_provider_template()->IsUndefined(isolate)) {\n-    JSObject::AddProperty(Handle<JSObject>::cast(prototype),\n+    JSObject::AddProperty(isolate, Handle<JSObject>::cast(prototype),\n                           isolate->factory()->constructor_string(), result,\n                           DONT_ENUM);\n   }\n@@ -663,7 +665,7 @@ Handle<JSFunction> ApiNatives::CreateApiFunction(\n   bool immutable_proto = false;\n   if (!obj->instance_template()->IsUndefined(isolate)) {\n     Handle<ObjectTemplateInfo> instance_template = Handle<ObjectTemplateInfo>(\n-        ObjectTemplateInfo::cast(obj->instance_template()));\n+        ObjectTemplateInfo::cast(obj->instance_template()), isolate);\n     embedder_field_count = instance_template->embedder_field_count();\n     immutable_proto = instance_template->immutable_proto();\n   }"
        },
        {
            "sha": "67a4b800609ed91f0717ceef9026555b9c8d1571",
            "filename": "deps/v8/src/api-natives.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi-natives.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi-natives.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi-natives.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -26,7 +26,7 @@ class ApiNatives {\n       MaybeHandle<Name> maybe_name = MaybeHandle<Name>());\n \n   V8_WARN_UNUSED_RESULT static MaybeHandle<JSObject> InstantiateObject(\n-      Handle<ObjectTemplateInfo> data,\n+      Isolate* isolate, Handle<ObjectTemplateInfo> data,\n       Handle<JSReceiver> new_target = Handle<JSReceiver>());\n \n   V8_WARN_UNUSED_RESULT static MaybeHandle<JSObject> InstantiateRemoteObject("
        },
        {
            "sha": "7c569e3a9f0824e1c61b665236589e3b7c1cc464",
            "filename": "deps/v8/src/api.cc",
            "status": "modified",
            "additions": 557,
            "deletions": 350,
            "changes": 907,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -33,6 +33,7 @@\n #include \"src/debug/debug-evaluate.h\"\n #include \"src/debug/debug-type-profile.h\"\n #include \"src/debug/debug.h\"\n+#include \"src/debug/liveedit.h\"\n #include \"src/deoptimizer.h\"\n #include \"src/detachable-vector.h\"\n #include \"src/execution.h\"\n@@ -47,6 +48,10 @@\n #include \"src/messages.h\"\n #include \"src/objects-inl.h\"\n #include \"src/objects/api-callbacks.h\"\n+#include \"src/objects/js-collection-inl.h\"\n+#include \"src/objects/js-promise-inl.h\"\n+#include \"src/objects/js-regexp-inl.h\"\n+#include \"src/objects/module-inl.h\"\n #include \"src/objects/ordered-hash-table-inl.h\"\n #include \"src/objects/templates.h\"\n #include \"src/parsing/parser.h\"\n@@ -202,12 +207,35 @@ namespace v8 {\n \n #define RETURN_ESCAPED(value) return handle_scope.Escape(value);\n \n+// TODO(v8:7786): Remove this when HeapObject::GetIsolate is removed.\n+#ifdef DEPRECATE_GET_ISOLATE\n+#define DISABLE_DEPRECATED_WARNINGS \\\n+  _Pragma(\"clang diagnostic push\")  \\\n+      _Pragma(\"clang diagnostic ignored \\\"-Wdeprecated\\\"\")\n+#define RESET_DEPRECATED_WARNINGS _Pragma(\"clang diagnostic pop\")\n+#else\n+#define DISABLE_DEPRECATED_WARNINGS\n+#define RESET_DEPRECATED_WARNINGS\n+#endif\n \n namespace {\n \n-Local<Context> ContextFromHeapObject(i::Handle<i::Object> obj) {\n+Local<Context> ContextFromNeverReadOnlySpaceObject(\n+    i::Handle<i::NeverReadOnlySpaceObject> obj) {\n+  return reinterpret_cast<v8::Isolate*>(obj->GetIsolate())->GetCurrentContext();\n+}\n+\n+// This is unsafe because obj could be in RO_SPACE which would not be tied to a\n+// particular isolate.\n+#ifdef DEPRECATE_GET_ISOLATE\n+[[deprecated(\"Pass Context explicitly or use a NeverReadOnlySpaceObject\")]]\n+#endif\n+    Local<Context>\n+    UnsafeContextFromHeapObject(i::Handle<i::Object> obj) {\n+  DISABLE_DEPRECATED_WARNINGS\n   return reinterpret_cast<v8::Isolate*>(i::HeapObject::cast(*obj)->GetIsolate())\n       ->GetCurrentContext();\n+  RESET_DEPRECATED_WARNINGS\n }\n \n class InternalEscapableScope : public v8::EscapableHandleScope {\n@@ -300,8 +328,7 @@ static ScriptOrigin GetScriptOriginForScript(i::Isolate* isolate,\n   i::Handle<i::Object> source_map_url(script->source_mapping_url(), isolate);\n   i::Handle<i::FixedArray> host_defined_options(script->host_defined_options(),\n                                                 isolate);\n-  v8::Isolate* v8_isolate =\n-      reinterpret_cast<v8::Isolate*>(script->GetIsolate());\n+  v8::Isolate* v8_isolate = reinterpret_cast<v8::Isolate*>(isolate);\n   ScriptOriginOptions options(script->origin_options());\n   v8::ScriptOrigin origin(\n       Utils::ToLocal(scriptName),\n@@ -463,7 +490,7 @@ void Utils::ReportOOMFailure(i::Isolate* isolate, const char* location,\n static inline bool IsExecutionTerminatingCheck(i::Isolate* isolate) {\n   if (isolate->has_scheduled_exception()) {\n     return isolate->scheduled_exception() ==\n-        isolate->heap()->termination_exception();\n+           i::ReadOnlyRoots(isolate).termination_exception();\n   }\n   return false;\n }\n@@ -638,10 +665,10 @@ size_t SnapshotCreator::AddData(i::Object* object) {\n     list = i::ArrayList::New(isolate, 1);\n   } else {\n     list = i::Handle<i::ArrayList>(\n-        i::ArrayList::cast(isolate->heap()->serialized_objects()));\n+        i::ArrayList::cast(isolate->heap()->serialized_objects()), isolate);\n   }\n   size_t index = static_cast<size_t>(list->Length());\n-  list = i::ArrayList::Add(list, obj);\n+  list = i::ArrayList::Add(isolate, list, obj);\n   isolate->heap()->SetSerializedObjects(*list);\n   return index;\n }\n@@ -657,11 +684,11 @@ size_t SnapshotCreator::AddData(Local<Context> context, i::Object* object) {\n   if (!ctx->serialized_objects()->IsArrayList()) {\n     list = i::ArrayList::New(isolate, 1);\n   } else {\n-    list =\n-        i::Handle<i::ArrayList>(i::ArrayList::cast(ctx->serialized_objects()));\n+    list = i::Handle<i::ArrayList>(\n+        i::ArrayList::cast(ctx->serialized_objects()), isolate);\n   }\n   size_t index = static_cast<size_t>(list->Length());\n-  list = i::ArrayList::Add(list, obj);\n+  list = i::ArrayList::Add(isolate, list, obj);\n   ctx->set_serialized_objects(*list);\n   return index;\n }\n@@ -671,21 +698,23 @@ void ConvertSerializedObjectsToFixedArray(Local<Context> context) {\n   i::Handle<i::Context> ctx = Utils::OpenHandle(*context);\n   i::Isolate* isolate = ctx->GetIsolate();\n   if (!ctx->serialized_objects()->IsArrayList()) {\n-    ctx->set_serialized_objects(isolate->heap()->empty_fixed_array());\n+    ctx->set_serialized_objects(i::ReadOnlyRoots(isolate).empty_fixed_array());\n   } else {\n-    i::Handle<i::ArrayList> list(i::ArrayList::cast(ctx->serialized_objects()));\n-    i::Handle<i::FixedArray> elements = i::ArrayList::Elements(list);\n+    i::Handle<i::ArrayList> list(i::ArrayList::cast(ctx->serialized_objects()),\n+                                 isolate);\n+    i::Handle<i::FixedArray> elements = i::ArrayList::Elements(isolate, list);\n     ctx->set_serialized_objects(*elements);\n   }\n }\n \n void ConvertSerializedObjectsToFixedArray(i::Isolate* isolate) {\n   if (!isolate->heap()->serialized_objects()->IsArrayList()) {\n-    isolate->heap()->SetSerializedObjects(isolate->heap()->empty_fixed_array());\n+    isolate->heap()->SetSerializedObjects(\n+        i::ReadOnlyRoots(isolate).empty_fixed_array());\n   } else {\n     i::Handle<i::ArrayList> list(\n-        i::ArrayList::cast(isolate->heap()->serialized_objects()));\n-    i::Handle<i::FixedArray> elements = i::ArrayList::Elements(list);\n+        i::ArrayList::cast(isolate->heap()->serialized_objects()), isolate);\n+    i::Handle<i::FixedArray> elements = i::ArrayList::Elements(isolate, list);\n     isolate->heap()->SetSerializedObjects(*elements);\n   }\n }\n@@ -732,10 +761,40 @@ StartupData SnapshotCreator::CreateBlob(\n   // context even after we have disposed of the context.\n   isolate->heap()->CollectAllAvailableGarbage(\n       i::GarbageCollectionReason::kSnapshotCreator);\n-  isolate->heap()->CompactFixedArraysOfWeakCells();\n+  {\n+    i::HandleScope scope(isolate);\n+    isolate->heap()->CompactFixedArraysOfWeakCells();\n+  }\n \n   isolate->heap()->read_only_space()->ClearStringPaddingIfNeeded();\n \n+  if (function_code_handling == FunctionCodeHandling::kClear) {\n+    // Clear out re-compilable data from all shared function infos. Any\n+    // JSFunctions using these SFIs will have their code pointers reset by the\n+    // partial serializer.\n+    //\n+    // We have to iterate the heap and collect handles to each clearable SFI,\n+    // before we disable allocation, since we have to allocate UncompiledDatas\n+    // to be able to recompile them.\n+    i::HandleScope scope(isolate);\n+    std::vector<i::Handle<i::SharedFunctionInfo>> sfis_to_clear;\n+\n+    i::HeapIterator heap_iterator(isolate->heap());\n+    while (i::HeapObject* current_obj = heap_iterator.next()) {\n+      if (current_obj->IsSharedFunctionInfo()) {\n+        i::SharedFunctionInfo* shared =\n+            i::SharedFunctionInfo::cast(current_obj);\n+        if (shared->CanDiscardCompiled()) {\n+          sfis_to_clear.emplace_back(shared, isolate);\n+        }\n+      }\n+    }\n+    i::AllowHeapAllocation allocate_for_discard;\n+    for (i::Handle<i::SharedFunctionInfo> shared : sfis_to_clear) {\n+      i::SharedFunctionInfo::DiscardCompiled(isolate, shared);\n+    }\n+  }\n+\n   i::DisallowHeapAllocation no_gc_from_here_on;\n \n   int num_contexts = num_additional_contexts + 1;\n@@ -768,22 +827,16 @@ StartupData SnapshotCreator::CreateBlob(\n \n       // Also, clear out feedback vectors, or any optimized code.\n       if (fun->has_feedback_vector()) {\n-        fun->feedback_cell()->set_value(isolate->heap()->undefined_value());\n+        fun->feedback_cell()->set_value(\n+            i::ReadOnlyRoots(isolate).undefined_value());\n         fun->set_code(isolate->builtins()->builtin(i::Builtins::kCompileLazy));\n       }\n-    }\n-\n-    // Clear out re-compilable data from all shared function infos. Any\n-    // JSFunctions using these SFIs will have their code pointers reset by the\n-    // partial serializer.\n-    if (current_obj->IsSharedFunctionInfo() &&\n-        function_code_handling == FunctionCodeHandling::kClear) {\n-      i::SharedFunctionInfo* shared = i::SharedFunctionInfo::cast(current_obj);\n-      if (shared->CanFlushCompiled()) {\n-        shared->FlushCompiled();\n+      if (function_code_handling == FunctionCodeHandling::kClear) {\n+        DCHECK(fun->shared()->HasWasmExportedFunctionData() ||\n+               fun->shared()->HasBuiltinId() ||\n+               fun->shared()->IsApiFunction() ||\n+               fun->shared()->HasUncompiledDataWithoutPreParsedScope());\n       }\n-      DCHECK(shared->HasWasmExportedFunctionData() || shared->HasBuiltinId() ||\n-             shared->IsApiFunction());\n     }\n   }\n \n@@ -938,6 +991,21 @@ void RegisteredExtension::UnregisterAll() {\n   first_extension_ = nullptr;\n }\n \n+namespace {\n+class ExtensionResource : public String::ExternalOneByteStringResource {\n+ public:\n+  ExtensionResource() : data_(0), length_(0) {}\n+  ExtensionResource(const char* data, size_t length)\n+      : data_(data), length_(length) {}\n+  const char* data() const { return data_; }\n+  size_t length() const { return length_; }\n+  virtual void Dispose() {}\n+\n+ private:\n+  const char* data_;\n+  size_t length_;\n+};\n+}  // anonymous namespace\n \n void RegisterExtension(Extension* that) {\n   RegisteredExtension* extension = new RegisteredExtension(that);\n@@ -954,10 +1022,10 @@ Extension::Extension(const char* name,\n       source_length_(source_length >= 0 ?\n                      source_length :\n                      (source ? static_cast<int>(strlen(source)) : 0)),\n-      source_(source, source_length_),\n       dep_count_(dep_count),\n       deps_(deps),\n       auto_enable_(false) {\n+  source_ = new ExtensionResource(source, source_length_);\n   CHECK(source != nullptr || source_length_ == 0);\n }\n \n@@ -1008,7 +1076,7 @@ i::Object** V8::GlobalizeReference(i::Isolate* isolate, i::Object** obj) {\n   i::Handle<i::Object> result = isolate->global_handles()->Create(*obj);\n #ifdef VERIFY_HEAP\n   if (i::FLAG_verify_heap) {\n-    (*obj)->ObjectVerify();\n+    (*obj)->ObjectVerify(isolate);\n   }\n #endif  // VERIFY_HEAP\n   return result.location();\n@@ -1017,11 +1085,6 @@ i::Object** V8::GlobalizeReference(i::Isolate* isolate, i::Object** obj) {\n \n i::Object** V8::CopyPersistent(i::Object** obj) {\n   i::Handle<i::Object> result = i::GlobalHandles::CopyGlobal(obj);\n-#ifdef VERIFY_HEAP\n-  if (i::FLAG_verify_heap) {\n-    (*obj)->ObjectVerify();\n-  }\n-#endif  // VERIFY_HEAP\n   return result.location();\n }\n \n@@ -1144,17 +1207,17 @@ i::Object** HandleScope::CreateHandle(i::Isolate* isolate, i::Object* value) {\n   return i::HandleScope::CreateHandle(isolate, value);\n }\n \n-\n-i::Object** HandleScope::CreateHandle(i::HeapObject* heap_object,\n-                                      i::Object* value) {\n-  DCHECK(heap_object->IsHeapObject());\n-  return i::HandleScope::CreateHandle(heap_object->GetIsolate(), value);\n+i::Object** HandleScope::CreateHandle(\n+    i::NeverReadOnlySpaceObject* writable_object, i::Object* value) {\n+  DCHECK(reinterpret_cast<i::HeapObject*>(writable_object)->IsHeapObject());\n+  return i::HandleScope::CreateHandle(writable_object->GetIsolate(), value);\n }\n \n \n EscapableHandleScope::EscapableHandleScope(Isolate* v8_isolate) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n-  escape_slot_ = CreateHandle(isolate, isolate->heap()->the_hole_value());\n+  escape_slot_ =\n+      CreateHandle(isolate, i::ReadOnlyRoots(isolate).the_hole_value());\n   Initialize(v8_isolate);\n }\n \n@@ -1164,7 +1227,7 @@ i::Object** EscapableHandleScope::Escape(i::Object** escape_value) {\n   Utils::ApiCheck((*escape_slot_)->IsTheHole(heap->isolate()),\n                   \"EscapableHandleScope::Escape\", \"Escape value set twice\");\n   if (escape_value == nullptr) {\n-    *escape_slot_ = heap->undefined_value();\n+    *escape_slot_ = i::ReadOnlyRoots(heap).undefined_value();\n     return nullptr;\n   }\n   *escape_slot_ = *escape_value;\n@@ -1267,7 +1330,7 @@ static i::Handle<i::FixedArray> EmbedderDataFor(Context* context,\n                       \"Not a native context\") &&\n       Utils::ApiCheck(index >= 0, location, \"Negative index\");\n   if (!ok) return i::Handle<i::FixedArray>();\n-  i::Handle<i::FixedArray> data(env->embedder_data());\n+  i::Handle<i::FixedArray> data(env->embedder_data(), isolate);\n   if (index < data->length()) return data;\n   if (!Utils::ApiCheck(can_grow, location, \"Index too large\")) {\n     return i::Handle<i::FixedArray>();\n@@ -1289,7 +1352,9 @@ v8::Local<v8::Value> Context::SlowGetEmbedderData(int index) {\n   const char* location = \"v8::Context::GetEmbedderData()\";\n   i::Handle<i::FixedArray> data = EmbedderDataFor(this, index, false, location);\n   if (data.is_null()) return Local<Value>();\n-  i::Handle<i::Object> result(data->get(index), data->GetIsolate());\n+  i::Handle<i::Object> result(\n+      data->get(index),\n+      reinterpret_cast<i::Isolate*>(Utils::OpenHandle(this)->GetIsolate()));\n   return Utils::ToLocal(result);\n }\n \n@@ -1456,7 +1521,7 @@ static Local<FunctionTemplate> FunctionTemplateNew(\n   }\n   obj->set_cached_property_name(\n       cached_property_name.IsEmpty()\n-          ? isolate->heap()->the_hole_value()\n+          ? i::ReadOnlyRoots(isolate).the_hole_value()\n           : *Utils::OpenHandle(*cached_property_name));\n   return Utils::ToLocal(obj);\n }\n@@ -1485,7 +1550,7 @@ MaybeLocal<FunctionTemplate> FunctionTemplate::FromSnapshot(Isolate* isolate,\n     i::Object* info = serialized_objects->get(int_index);\n     if (info->IsFunctionTemplateInfo()) {\n       return Utils::ToLocal(i::Handle<i::FunctionTemplateInfo>(\n-          i::FunctionTemplateInfo::cast(info)));\n+          i::FunctionTemplateInfo::cast(info), i_isolate));\n     }\n   }\n   return Local<FunctionTemplate>();\n@@ -1513,10 +1578,10 @@ Local<AccessorSignature> AccessorSignature::New(\n   return Utils::AccessorSignatureToLocal(Utils::OpenHandle(*receiver));\n }\n \n-\n-#define SET_FIELD_WRAPPED(obj, setter, cdata) do {                      \\\n-    i::Handle<i::Object> foreign = FromCData(obj->GetIsolate(), cdata); \\\n-    (obj)->setter(*foreign);                                            \\\n+#define SET_FIELD_WRAPPED(isolate, obj, setter, cdata)        \\\n+  do {                                                        \\\n+    i::Handle<i::Object> foreign = FromCData(isolate, cdata); \\\n+    (obj)->setter(*foreign);                                  \\\n   } while (false)\n \n void FunctionTemplate::SetCallHandler(FunctionCallback callback,\n@@ -1529,8 +1594,8 @@ void FunctionTemplate::SetCallHandler(FunctionCallback callback,\n   i::HandleScope scope(isolate);\n   i::Handle<i::CallHandlerInfo> obj = isolate->factory()->NewCallHandlerInfo(\n       side_effect_type == SideEffectType::kHasNoSideEffect);\n-  SET_FIELD_WRAPPED(obj, set_callback, callback);\n-  SET_FIELD_WRAPPED(obj, set_js_callback, obj->redirected_callback());\n+  SET_FIELD_WRAPPED(isolate, obj, set_callback, callback);\n+  SET_FIELD_WRAPPED(isolate, obj, set_js_callback, obj->redirected_callback());\n   if (data.IsEmpty()) {\n     data = v8::Undefined(reinterpret_cast<v8::Isolate*>(isolate));\n   }\n@@ -1548,16 +1613,16 @@ i::Handle<i::AccessorInfo> MakeAccessorInfo(\n     v8::Local<AccessorSignature> signature, bool is_special_data_property,\n     bool replace_on_access) {\n   i::Handle<i::AccessorInfo> obj = isolate->factory()->NewAccessorInfo();\n-  SET_FIELD_WRAPPED(obj, set_getter, getter);\n+  SET_FIELD_WRAPPED(isolate, obj, set_getter, getter);\n   DCHECK_IMPLIES(replace_on_access,\n                  is_special_data_property && setter == nullptr);\n   if (is_special_data_property && setter == nullptr) {\n     setter = reinterpret_cast<Setter>(&i::Accessors::ReconfigureToDataProperty);\n   }\n-  SET_FIELD_WRAPPED(obj, set_setter, setter);\n+  SET_FIELD_WRAPPED(isolate, obj, set_setter, setter);\n   i::Address redirected = obj->redirected_getter();\n   if (redirected != i::kNullAddress) {\n-    SET_FIELD_WRAPPED(obj, set_js_getter, redirected);\n+    SET_FIELD_WRAPPED(isolate, obj, set_js_getter, redirected);\n   }\n   if (data.IsEmpty()) {\n     data = v8::Undefined(reinterpret_cast<v8::Isolate*>(isolate));\n@@ -1597,7 +1662,7 @@ Local<ObjectTemplate> FunctionTemplate::InstanceTemplate() {\n     handle->set_instance_template(*Utils::OpenHandle(*templ));\n   }\n   i::Handle<i::ObjectTemplateInfo> result(\n-      i::ObjectTemplateInfo::cast(handle->instance_template()));\n+      i::ObjectTemplateInfo::cast(handle->instance_template()), isolate);\n   return Utils::ToLocal(result);\n }\n \n@@ -1699,8 +1764,8 @@ MaybeLocal<ObjectTemplate> ObjectTemplate::FromSnapshot(Isolate* isolate,\n   if (int_index < serialized_objects->length()) {\n     i::Object* info = serialized_objects->get(int_index);\n     if (info->IsObjectTemplateInfo()) {\n-      return Utils::ToLocal(\n-          i::Handle<i::ObjectTemplateInfo>(i::ObjectTemplateInfo::cast(info)));\n+      return Utils::ToLocal(i::Handle<i::ObjectTemplateInfo>(\n+          i::ObjectTemplateInfo::cast(info), i_isolate));\n     }\n   }\n   return Local<ObjectTemplate>();\n@@ -1814,17 +1879,23 @@ static i::Handle<i::InterceptorInfo> CreateInterceptorInfo(\n     i::Isolate* isolate, Getter getter, Setter setter, Query query,\n     Descriptor descriptor, Deleter remover, Enumerator enumerator,\n     Definer definer, Local<Value> data, PropertyHandlerFlags flags) {\n+  // Either intercept attributes or descriptor.\n+  DCHECK(query == nullptr || descriptor == nullptr);\n+  // Only use descriptor callback with definer callback.\n+  DCHECK(query == nullptr || definer == nullptr);\n   auto obj = i::Handle<i::InterceptorInfo>::cast(\n       isolate->factory()->NewStruct(i::INTERCEPTOR_INFO_TYPE, i::TENURED));\n   obj->set_flags(0);\n \n-  if (getter != 0) SET_FIELD_WRAPPED(obj, set_getter, getter);\n-  if (setter != 0) SET_FIELD_WRAPPED(obj, set_setter, setter);\n-  if (query != 0) SET_FIELD_WRAPPED(obj, set_query, query);\n-  if (descriptor != 0) SET_FIELD_WRAPPED(obj, set_descriptor, descriptor);\n-  if (remover != 0) SET_FIELD_WRAPPED(obj, set_deleter, remover);\n-  if (enumerator != 0) SET_FIELD_WRAPPED(obj, set_enumerator, enumerator);\n-  if (definer != 0) SET_FIELD_WRAPPED(obj, set_definer, definer);\n+  if (getter != 0) SET_FIELD_WRAPPED(isolate, obj, set_getter, getter);\n+  if (setter != 0) SET_FIELD_WRAPPED(isolate, obj, set_setter, setter);\n+  if (query != 0) SET_FIELD_WRAPPED(isolate, obj, set_query, query);\n+  if (descriptor != 0)\n+    SET_FIELD_WRAPPED(isolate, obj, set_descriptor, descriptor);\n+  if (remover != 0) SET_FIELD_WRAPPED(isolate, obj, set_deleter, remover);\n+  if (enumerator != 0)\n+    SET_FIELD_WRAPPED(isolate, obj, set_enumerator, enumerator);\n+  if (definer != 0) SET_FIELD_WRAPPED(isolate, obj, set_definer, definer);\n   obj->set_can_intercept_symbols(\n       !(static_cast<int>(flags) &\n         static_cast<int>(PropertyHandlerFlags::kOnlyInterceptStrings)));\n@@ -1928,7 +1999,7 @@ void ObjectTemplate::SetAccessCheckCallback(AccessCheckCallback callback,\n   i::Handle<i::AccessCheckInfo> info =\n       i::Handle<i::AccessCheckInfo>::cast(struct_info);\n \n-  SET_FIELD_WRAPPED(info, set_callback, callback);\n+  SET_FIELD_WRAPPED(isolate, info, set_callback, callback);\n   info->set_named_interceptor(nullptr);\n   info->set_indexed_interceptor(nullptr);\n \n@@ -1958,7 +2029,7 @@ void ObjectTemplate::SetAccessCheckCallbackAndHandler(\n   i::Handle<i::AccessCheckInfo> info =\n       i::Handle<i::AccessCheckInfo>::cast(struct_info);\n \n-  SET_FIELD_WRAPPED(info, set_callback, callback);\n+  SET_FIELD_WRAPPED(isolate, info, set_callback, callback);\n   auto named_interceptor = CreateNamedInterceptorInfo(\n       isolate, named_handler.getter, named_handler.setter, named_handler.query,\n       named_handler.descriptor, named_handler.deleter, named_handler.enumerator,\n@@ -2002,8 +2073,8 @@ void ObjectTemplate::SetCallAsFunctionHandler(FunctionCallback callback,\n   auto cons = EnsureConstructor(isolate, this);\n   EnsureNotInstantiated(cons, \"v8::ObjectTemplate::SetCallAsFunctionHandler\");\n   i::Handle<i::CallHandlerInfo> obj = isolate->factory()->NewCallHandlerInfo();\n-  SET_FIELD_WRAPPED(obj, set_callback, callback);\n-  SET_FIELD_WRAPPED(obj, set_js_callback, obj->redirected_callback());\n+  SET_FIELD_WRAPPED(isolate, obj, set_callback, callback);\n+  SET_FIELD_WRAPPED(isolate, obj, set_js_callback, obj->redirected_callback());\n   if (data.IsEmpty()) {\n     data = v8::Undefined(reinterpret_cast<v8::Isolate*>(isolate));\n   }\n@@ -2082,11 +2153,9 @@ ScriptCompiler::StreamedSource::GetCachedData() const {\n \n \n Local<Script> UnboundScript::BindToCurrentContext() {\n-  i::Handle<i::HeapObject> obj =\n-      i::Handle<i::HeapObject>::cast(Utils::OpenHandle(this));\n-  i::Isolate* isolate = obj->GetIsolate();\n-  i::Handle<i::SharedFunctionInfo> function_info(\n-      i::SharedFunctionInfo::cast(*obj), isolate);\n+  auto function_info =\n+      i::Handle<i::SharedFunctionInfo>::cast(Utils::OpenHandle(this));\n+  i::Isolate* isolate = function_info->GetIsolate();\n   i::Handle<i::JSFunction> function =\n       isolate->factory()->NewFunctionFromSharedFunctionInfo(\n           function_info, isolate->native_context());\n@@ -2095,14 +2164,13 @@ Local<Script> UnboundScript::BindToCurrentContext() {\n \n \n int UnboundScript::GetId() {\n-  i::Handle<i::HeapObject> obj =\n-      i::Handle<i::HeapObject>::cast(Utils::OpenHandle(this));\n-  i::Isolate* isolate = obj->GetIsolate();\n+  auto function_info =\n+      i::Handle<i::SharedFunctionInfo>::cast(Utils::OpenHandle(this));\n+  i::Isolate* isolate = function_info->GetIsolate();\n   LOG_API(isolate, UnboundScript, GetId);\n   i::HandleScope scope(isolate);\n-  i::Handle<i::SharedFunctionInfo> function_info(\n-      i::SharedFunctionInfo::cast(*obj));\n-  i::Handle<i::Script> script(i::Script::cast(function_info->script()));\n+  i::Handle<i::Script> script(i::Script::cast(function_info->script()),\n+                              isolate);\n   return script->id();\n }\n \n@@ -2113,7 +2181,7 @@ int UnboundScript::GetLineNumber(int code_pos) {\n   i::Isolate* isolate = obj->GetIsolate();\n   LOG_API(isolate, UnboundScript, GetLineNumber);\n   if (obj->script()->IsScript()) {\n-    i::Handle<i::Script> script(i::Script::cast(obj->script()));\n+    i::Handle<i::Script> script(i::Script::cast(obj->script()), isolate);\n     return i::Script::GetLineNumber(script, code_pos);\n   } else {\n     return -1;\n@@ -2188,7 +2256,7 @@ Local<Value> Script::Run() {\n   // If execution is terminating, Compile(..)->Run() requires this\n   // check.\n   if (self.is_null()) return Local<Value>();\n-  auto context = ContextFromHeapObject(self);\n+  auto context = ContextFromNeverReadOnlySpaceObject(self);\n   RETURN_TO_LOCAL_UNCHECKED(Run(context), Value);\n }\n \n@@ -2210,8 +2278,9 @@ Local<PrimitiveArray> ScriptOrModule::GetHostDefinedOptions() {\n \n Local<UnboundScript> Script::GetUnboundScript() {\n   i::Handle<i::Object> obj = Utils::OpenHandle(this);\n-  return ToApiHandle<UnboundScript>(\n-      i::Handle<i::SharedFunctionInfo>(i::JSFunction::cast(*obj)->shared()));\n+  i::SharedFunctionInfo* sfi = i::JSFunction::cast(*obj)->shared();\n+  i::Isolate* isolate = sfi->GetIsolate();\n+  return ToApiHandle<UnboundScript>(i::handle(sfi, isolate));\n }\n \n // static\n@@ -2226,14 +2295,13 @@ Local<PrimitiveArray> PrimitiveArray::New(Isolate* v8_isolate, int length) {\n \n int PrimitiveArray::Length() const {\n   i::Handle<i::FixedArray> array = Utils::OpenHandle(this);\n-  i::Isolate* isolate = array->GetIsolate();\n-  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n   return array->length();\n }\n \n-void PrimitiveArray::Set(int index, Local<Primitive> item) {\n+void PrimitiveArray::Set(Isolate* v8_isolate, int index,\n+                         Local<Primitive> item) {\n+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n   i::Handle<i::FixedArray> array = Utils::OpenHandle(this);\n-  i::Isolate* isolate = array->GetIsolate();\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n   Utils::ApiCheck(index >= 0 && index < array->length(),\n                   \"v8::PrimitiveArray::Set\",\n@@ -2243,9 +2311,17 @@ void PrimitiveArray::Set(int index, Local<Primitive> item) {\n   array->set(index, *i_item);\n }\n \n-Local<Primitive> PrimitiveArray::Get(int index) {\n+void PrimitiveArray::Set(int index, Local<Primitive> item) {\n   i::Handle<i::FixedArray> array = Utils::OpenHandle(this);\n+  DISABLE_DEPRECATED_WARNINGS\n   i::Isolate* isolate = array->GetIsolate();\n+  RESET_DEPRECATED_WARNINGS\n+  Set(reinterpret_cast<Isolate*>(isolate), index, item);\n+}\n+\n+Local<Primitive> PrimitiveArray::Get(Isolate* v8_isolate, int index) {\n+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n+  i::Handle<i::FixedArray> array = Utils::OpenHandle(this);\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n   Utils::ApiCheck(index >= 0 && index < array->length(),\n                   \"v8::PrimitiveArray::Get\",\n@@ -2255,6 +2331,14 @@ Local<Primitive> PrimitiveArray::Get(int index) {\n   return ToApiHandle<Primitive>(i_item);\n }\n \n+Local<Primitive> PrimitiveArray::Get(int index) {\n+  i::Handle<i::FixedArray> array = Utils::OpenHandle(this);\n+  DISABLE_DEPRECATED_WARNINGS\n+  i::Isolate* isolate = array->GetIsolate();\n+  RESET_DEPRECATED_WARNINGS\n+  return Get(reinterpret_cast<Isolate*>(isolate), index);\n+}\n+\n Module::Status Module::GetStatus() const {\n   i::Handle<i::Module> self = Utils::OpenHandle(this);\n   switch (self->status()) {\n@@ -2319,7 +2403,7 @@ Local<Value> Module::GetModuleNamespace() {\n       \"v8::Module::GetModuleNamespace must be used on an instantiated module\");\n   i::Handle<i::Module> self = Utils::OpenHandle(this);\n   i::Handle<i::JSModuleNamespace> module_namespace =\n-      i::Module::GetModuleNamespace(self);\n+      i::Module::GetModuleNamespace(self->GetIsolate(), self);\n   return ToApiHandle<Value>(module_namespace);\n }\n \n@@ -2328,8 +2412,8 @@ Local<UnboundModuleScript> Module::GetUnboundModuleScript() {\n       GetStatus() < kEvaluating, \"v8::Module::GetUnboundScript\",\n       \"v8::Module::GetUnboundScript must be used on an unevaluated module\");\n   i::Handle<i::Module> self = Utils::OpenHandle(this);\n-  return ToApiHandle<UnboundModuleScript>(\n-      i::Handle<i::SharedFunctionInfo>(self->GetSharedFunctionInfo()));\n+  return ToApiHandle<UnboundModuleScript>(i::Handle<i::SharedFunctionInfo>(\n+      self->GetSharedFunctionInfo(), self->GetIsolate()));\n }\n \n int Module::GetIdentityHash() const { return Utils::OpenHandle(this)->hash(); }\n@@ -2339,8 +2423,8 @@ Maybe<bool> Module::InstantiateModule(Local<Context> context,\n   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n   ENTER_V8(isolate, context, Module, InstantiateModule, Nothing<bool>(),\n            i::HandleScope);\n-  has_pending_exception =\n-      !i::Module::Instantiate(Utils::OpenHandle(this), context, callback);\n+  has_pending_exception = !i::Module::Instantiate(\n+      isolate, Utils::OpenHandle(this), context, callback);\n   RETURN_ON_FAILED_EXECUTION_PRIMITIVE(bool);\n   return Just(true);\n }\n@@ -2359,7 +2443,7 @@ MaybeLocal<Value> Module::Evaluate(Local<Context> context) {\n   CHECK_GE(self->status(), i::Module::kInstantiated);\n \n   Local<Value> result;\n-  has_pending_exception = !ToLocal(i::Module::Evaluate(self), &result);\n+  has_pending_exception = !ToLocal(i::Module::Evaluate(isolate, self), &result);\n   RETURN_ON_FAILED_EXECUTION(Value);\n   RETURN_ESCAPED(result);\n }\n@@ -2470,15 +2554,18 @@ MaybeLocal<Script> ScriptCompiler::Compile(Local<Context> context,\n   return result->BindToCurrentContext();\n }\n \n-MaybeLocal<Module> ScriptCompiler::CompileModule(Isolate* isolate,\n-                                                 Source* source) {\n+MaybeLocal<Module> ScriptCompiler::CompileModule(\n+    Isolate* isolate, Source* source, CompileOptions options,\n+    NoCacheReason no_cache_reason) {\n+  CHECK(options == kNoCompileOptions || options == kConsumeCodeCache);\n+\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n \n   Utils::ApiCheck(source->GetResourceOptions().IsModule(),\n                   \"v8::ScriptCompiler::CompileModule\",\n                   \"Invalid ScriptOrigin: is_module must be true\");\n-  auto maybe = CompileUnboundInternal(isolate, source, kNoCompileOptions,\n-                                      kNoCacheBecauseModule);\n+  auto maybe =\n+      CompileUnboundInternal(isolate, source, options, no_cache_reason);\n   Local<UnboundScript> unbound;\n   if (!maybe.ToLocal(&unbound)) return MaybeLocal<Module>();\n \n@@ -2561,9 +2648,10 @@ MaybeLocal<Function> ScriptCompiler::CompileFunctionInContext(\n     context = isolate->factory()->NewWithContext(\n         context,\n         i::ScopeInfo::CreateForWithScope(\n-            isolate, context->IsNativeContext()\n-                         ? i::Handle<i::ScopeInfo>::null()\n-                         : i::Handle<i::ScopeInfo>(context->scope_info())),\n+            isolate,\n+            context->IsNativeContext()\n+                ? i::Handle<i::ScopeInfo>::null()\n+                : i::Handle<i::ScopeInfo>(context->scope_info(), isolate)),\n         extension);\n   }\n \n@@ -2690,8 +2778,10 @@ ScriptCompiler::CachedData* ScriptCompiler::CreateCodeCacheForFunction(\n \n ScriptCompiler::CachedData* ScriptCompiler::CreateCodeCacheForFunction(\n     Local<Function> function) {\n-  i::Handle<i::SharedFunctionInfo> shared(\n-      i::Handle<i::JSFunction>::cast(Utils::OpenHandle(*function))->shared());\n+  auto js_function =\n+      i::Handle<i::JSFunction>::cast(Utils::OpenHandle(*function));\n+  i::Handle<i::SharedFunctionInfo> shared(js_function->shared(),\n+                                          js_function->GetIsolate());\n   CHECK(shared->is_wrapped());\n   return i::CodeSerializer::Serialize(shared);\n }\n@@ -2710,15 +2800,19 @@ MaybeLocal<Script> Script::Compile(Local<Context> context, Local<String> source,\n Local<Script> Script::Compile(v8::Local<String> source,\n                               v8::ScriptOrigin* origin) {\n   auto str = Utils::OpenHandle(*source);\n-  auto context = ContextFromHeapObject(str);\n+  DISABLE_DEPRECATED_WARNINGS\n+  auto context = UnsafeContextFromHeapObject(str);\n+  RESET_DEPRECATED_WARNINGS\n   RETURN_TO_LOCAL_UNCHECKED(Compile(context, source, origin), Script);\n }\n \n \n Local<Script> Script::Compile(v8::Local<String> source,\n                               v8::Local<String> file_name) {\n   auto str = Utils::OpenHandle(*source);\n-  auto context = ContextFromHeapObject(str);\n+  DISABLE_DEPRECATED_WARNINGS\n+  auto context = UnsafeContextFromHeapObject(str);\n+  RESET_DEPRECATED_WARNINGS\n   ScriptOrigin origin(file_name);\n   return Compile(context, source, &origin).FromMaybe(Local<Script>());\n }\n@@ -2823,7 +2917,7 @@ MaybeLocal<Value> v8::TryCatch::StackTrace(Local<Context> context) const {\n   if (!maybe.FromJust()) return v8::Local<Value>();\n   Local<Value> result;\n   has_pending_exception =\n-      !ToLocal<Value>(i::JSReceiver::GetProperty(obj, name), &result);\n+      !ToLocal<Value>(i::JSReceiver::GetProperty(isolate, obj, name), &result);\n   RETURN_ON_FAILED_EXECUTION(Value);\n   RETURN_ESCAPED(result);\n }\n@@ -2858,7 +2952,7 @@ void v8::TryCatch::Reset() {\n \n \n void v8::TryCatch::ResetInternal() {\n-  i::Object* the_hole = isolate_->heap()->the_hole_value();\n+  i::Object* the_hole = i::ReadOnlyRoots(isolate_).the_hole_value();\n   exception_ = the_hole;\n   message_obj_ = the_hole;\n }\n@@ -2893,9 +2987,7 @@ ScriptOrigin Message::GetScriptOrigin() const {\n   i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n   auto message = i::Handle<i::JSMessageObject>::cast(Utils::OpenHandle(this));\n-  auto script_wraper = i::Handle<i::Object>(message->script(), isolate);\n-  auto script_value = i::Handle<i::JSValue>::cast(script_wraper);\n-  i::Handle<i::Script> script(i::Script::cast(script_value->value()));\n+  i::Handle<i::Script> script(message->script(), isolate);\n   return GetScriptOriginForScript(isolate, script);\n }\n \n@@ -2928,7 +3020,7 @@ Maybe<int> Message::GetLineNumber(Local<Context> context) const {\n \n \n int Message::GetLineNumber() const {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   return GetLineNumber(context).FromMaybe(0);\n }\n \n@@ -2983,21 +3075,16 @@ Maybe<int> Message::GetEndColumn(Local<Context> context) const {\n bool Message::IsSharedCrossOrigin() const {\n   i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n-  auto self = Utils::OpenHandle(this);\n-  auto script = i::Handle<i::JSValue>::cast(\n-      i::Handle<i::Object>(self->script(), isolate));\n-  return i::Script::cast(script->value())\n+  return Utils::OpenHandle(this)\n+      ->script()\n       ->origin_options()\n       .IsSharedCrossOrigin();\n }\n \n bool Message::IsOpaque() const {\n   i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n-  auto self = Utils::OpenHandle(this);\n-  auto script = i::Handle<i::JSValue>::cast(\n-      i::Handle<i::Object>(self->script(), isolate));\n-  return i::Script::cast(script->value())->origin_options().IsOpaque();\n+  return Utils::OpenHandle(this)->script()->origin_options().IsOpaque();\n }\n \n \n@@ -3012,7 +3099,7 @@ MaybeLocal<String> Message::GetSourceLine(Local<Context> context) const {\n \n \n Local<String> Message::GetSourceLine() const {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   RETURN_TO_LOCAL_UNCHECKED(GetSourceLine(context), String)\n }\n \n@@ -3037,7 +3124,9 @@ Local<StackFrame> StackTrace::GetFrame(Isolate* v8_isolate,\n }\n \n Local<StackFrame> StackTrace::GetFrame(uint32_t index) const {\n+  DISABLE_DEPRECATED_WARNINGS\n   i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();\n+  RESET_DEPRECATED_WARNINGS\n   return GetFrame(reinterpret_cast<Isolate*>(isolate), index);\n }\n \n@@ -3123,7 +3212,7 @@ bool StackFrame::IsWasm() const { return Utils::OpenHandle(this)->is_wasm(); }\n MaybeLocal<Value> JSON::Parse(Isolate* v8_isolate, Local<String> json_string) {\n   PREPARE_FOR_EXECUTION(v8_isolate->GetCurrentContext(), JSON, Parse, Value);\n   i::Handle<i::String> string = Utils::OpenHandle(*json_string);\n-  i::Handle<i::String> source = i::String::Flatten(string);\n+  i::Handle<i::String> source = i::String::Flatten(isolate, string);\n   i::Handle<i::Object> undefined = isolate->factory()->undefined_value();\n   auto maybe = source->IsSeqOneByteString()\n                    ? i::JsonParser<true>::Parse(isolate, source, undefined)\n@@ -3138,7 +3227,7 @@ MaybeLocal<Value> JSON::Parse(Local<Context> context,\n                               Local<String> json_string) {\n   PREPARE_FOR_EXECUTION(context, JSON, Parse, Value);\n   i::Handle<i::String> string = Utils::OpenHandle(*json_string);\n-  i::Handle<i::String> source = i::String::Flatten(string);\n+  i::Handle<i::String> source = i::String::Flatten(isolate, string);\n   i::Handle<i::Object> undefined = isolate->factory()->undefined_value();\n   auto maybe = source->IsSeqOneByteString()\n                    ? i::JsonParser<true>::Parse(isolate, source, undefined)\n@@ -3427,21 +3516,15 @@ bool ValueDeserializer::ReadRawBytes(size_t length, const void** data) {\n \n bool Value::FullIsUndefined() const {\n   i::Handle<i::Object> object = Utils::OpenHandle(this);\n-  bool result = false;\n-  if (!object->IsSmi()) {\n-    result = object->IsUndefined(i::HeapObject::cast(*object)->GetIsolate());\n-  }\n+  bool result = object->IsUndefined();\n   DCHECK_EQ(result, QuickIsUndefined());\n   return result;\n }\n \n \n bool Value::FullIsNull() const {\n   i::Handle<i::Object> object = Utils::OpenHandle(this);\n-  bool result = false;\n-  if (!object->IsSmi()) {\n-    result = object->IsNull(i::HeapObject::cast(*object)->GetIsolate());\n-  }\n+  bool result = object->IsNull();\n   DCHECK_EQ(result, QuickIsNull());\n   return result;\n }\n@@ -3450,14 +3533,14 @@ bool Value::FullIsNull() const {\n bool Value::IsTrue() const {\n   i::Handle<i::Object> object = Utils::OpenHandle(this);\n   if (object->IsSmi()) return false;\n-  return object->IsTrue(i::HeapObject::cast(*object)->GetIsolate());\n+  return object->IsTrue();\n }\n \n \n bool Value::IsFalse() const {\n   i::Handle<i::Object> object = Utils::OpenHandle(this);\n   if (object->IsSmi()) return false;\n-  return object->IsFalse(i::HeapObject::cast(*object)->GetIsolate());\n+  return object->IsFalse();\n }\n \n \n@@ -3570,9 +3653,16 @@ bool Value::IsBoolean() const {\n   return Utils::OpenHandle(this)->IsBoolean();\n }\n \n-\n bool Value::IsExternal() const {\n-  return Utils::OpenHandle(this)->IsExternal();\n+  i::Handle<i::Object> obj = Utils::OpenHandle(this);\n+  if (!obj->IsHeapObject()) return false;\n+  i::Handle<i::HeapObject> heap_obj = i::Handle<i::HeapObject>::cast(obj);\n+  // Check the instance type is JS_OBJECT (instance type of Externals) before\n+  // attempting to get the Isolate since that guarantees the object is writable\n+  // and GetIsolate will work.\n+  if (heap_obj->map()->instance_type() != i::JS_OBJECT_TYPE) return false;\n+  i::Isolate* isolate = i::JSObject::cast(*heap_obj)->GetIsolate();\n+  return heap_obj->IsExternal(isolate);\n }\n \n \n@@ -3704,7 +3794,7 @@ MaybeLocal<Boolean> Value::ToBoolean(Local<Context> context) const {\n   auto obj = Utils::OpenHandle(this);\n   if (obj->IsBoolean()) return ToApiHandle<Boolean>(obj);\n   auto isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n-  auto val = isolate->factory()->ToBoolean(obj->BooleanValue());\n+  auto val = isolate->factory()->ToBoolean(obj->BooleanValue(isolate));\n   return ToApiHandle<Boolean>(val);\n }\n \n@@ -3719,7 +3809,8 @@ MaybeLocal<Number> Value::ToNumber(Local<Context> context) const {\n   if (obj->IsNumber()) return ToApiHandle<Number>(obj);\n   PREPARE_FOR_EXECUTION(context, Object, ToNumber, Number);\n   Local<Number> result;\n-  has_pending_exception = !ToLocal<Number>(i::Object::ToNumber(obj), &result);\n+  has_pending_exception =\n+      !ToLocal<Number>(i::Object::ToNumber(isolate, obj), &result);\n   RETURN_ON_FAILED_EXECUTION(Number);\n   RETURN_ESCAPED(result);\n }\n@@ -3785,7 +3876,7 @@ void i::Internals::CheckInitializedImpl(v8::Isolate* external_isolate) {\n \n \n void External::CheckCast(v8::Value* that) {\n-  Utils::ApiCheck(Utils::OpenHandle(that)->IsExternal(), \"v8::External::Cast\",\n+  Utils::ApiCheck(that->IsExternal(), \"v8::External::Cast\",\n                   \"Could not convert to external\");\n }\n \n@@ -4018,12 +4109,19 @@ void v8::RegExp::CheckCast(v8::Value* that) {\n \n \n Maybe<bool> Value::BooleanValue(Local<Context> context) const {\n-  return Just(Utils::OpenHandle(this)->BooleanValue());\n+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());\n+  return Just(Utils::OpenHandle(this)->BooleanValue(isolate));\n }\n \n \n bool Value::BooleanValue() const {\n-  return Utils::OpenHandle(this)->BooleanValue();\n+  auto obj = Utils::OpenHandle(this);\n+  if (obj->IsSmi()) return *obj != i::Smi::kZero;\n+  DCHECK(obj->IsHeapObject());\n+  DISABLE_DEPRECATED_WARNINGS\n+  i::Isolate* isolate = i::Handle<i::HeapObject>::cast(obj)->GetIsolate();\n+  RESET_DEPRECATED_WARNINGS\n+  return obj->BooleanValue(isolate);\n }\n \n \n@@ -4034,7 +4132,7 @@ Maybe<double> Value::NumberValue(Local<Context> context) const {\n   ENTER_V8(isolate, context, Value, NumberValue, Nothing<double>(),\n            i::HandleScope);\n   i::Handle<i::Object> num;\n-  has_pending_exception = !i::Object::ToNumber(obj).ToHandle(&num);\n+  has_pending_exception = !i::Object::ToNumber(isolate, obj).ToHandle(&num);\n   RETURN_ON_FAILED_EXECUTION_PRIMITIVE(double);\n   return Just(num->Number());\n }\n@@ -4043,8 +4141,10 @@ Maybe<double> Value::NumberValue(Local<Context> context) const {\n double Value::NumberValue() const {\n   auto obj = Utils::OpenHandle(this);\n   if (obj->IsNumber()) return obj->Number();\n-  return NumberValue(ContextFromHeapObject(obj))\n+  DISABLE_DEPRECATED_WARNINGS\n+  return NumberValue(UnsafeContextFromHeapObject(obj))\n       .FromMaybe(std::numeric_limits<double>::quiet_NaN());\n+  RESET_DEPRECATED_WARNINGS\n }\n \n \n@@ -4072,7 +4172,9 @@ int64_t Value::IntegerValue() const {\n       return static_cast<int64_t>(obj->Number());\n     }\n   }\n-  return IntegerValue(ContextFromHeapObject(obj)).FromMaybe(0);\n+  DISABLE_DEPRECATED_WARNINGS\n+  return IntegerValue(UnsafeContextFromHeapObject(obj)).FromMaybe(0);\n+  RESET_DEPRECATED_WARNINGS\n }\n \n \n@@ -4093,7 +4195,9 @@ Maybe<int32_t> Value::Int32Value(Local<Context> context) const {\n int32_t Value::Int32Value() const {\n   auto obj = Utils::OpenHandle(this);\n   if (obj->IsNumber()) return NumberToInt32(*obj);\n-  return Int32Value(ContextFromHeapObject(obj)).FromMaybe(0);\n+  DISABLE_DEPRECATED_WARNINGS\n+  return Int32Value(UnsafeContextFromHeapObject(obj)).FromMaybe(0);\n+  RESET_DEPRECATED_WARNINGS\n }\n \n \n@@ -4114,7 +4218,9 @@ Maybe<uint32_t> Value::Uint32Value(Local<Context> context) const {\n uint32_t Value::Uint32Value() const {\n   auto obj = Utils::OpenHandle(this);\n   if (obj->IsNumber()) return NumberToUint32(*obj);\n-  return Uint32Value(ContextFromHeapObject(obj)).FromMaybe(0);\n+  DISABLE_DEPRECATED_WARNINGS\n+  return Uint32Value(UnsafeContextFromHeapObject(obj)).FromMaybe(0);\n+  RESET_DEPRECATED_WARNINGS\n }\n \n \n@@ -4145,9 +4251,10 @@ MaybeLocal<Uint32> Value::ToArrayIndex(Local<Context> context) const {\n \n \n Maybe<bool> Value::Equals(Local<Context> context, Local<Value> that) const {\n+  i::Isolate* isolate = Utils::OpenHandle(*context)->GetIsolate();\n   auto self = Utils::OpenHandle(this);\n   auto other = Utils::OpenHandle(*that);\n-  return i::Object::Equals(self, other);\n+  return i::Object::Equals(isolate, self, other);\n }\n \n \n@@ -4161,7 +4268,9 @@ bool Value::Equals(Local<Value> that) const {\n     return *self == *other;\n   }\n   auto heap_object = self->IsSmi() ? other : self;\n-  auto context = ContextFromHeapObject(heap_object);\n+  DISABLE_DEPRECATED_WARNINGS\n+  auto context = UnsafeContextFromHeapObject(heap_object);\n+  RESET_DEPRECATED_WARNINGS\n   return Equals(context, that).FromMaybe(false);\n }\n \n@@ -4217,7 +4326,7 @@ Maybe<bool> v8::Object::Set(v8::Local<v8::Context> context,\n \n \n bool v8::Object::Set(v8::Local<Value> key, v8::Local<Value> value) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   return Set(context, key, value).FromMaybe(false);\n }\n \n@@ -4237,7 +4346,7 @@ Maybe<bool> v8::Object::Set(v8::Local<v8::Context> context, uint32_t index,\n \n \n bool v8::Object::Set(uint32_t index, v8::Local<Value> value) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   return Set(context, index, value).FromMaybe(false);\n }\n \n@@ -4464,7 +4573,7 @@ MaybeLocal<Value> v8::Object::Get(Local<v8::Context> context,\n \n \n Local<Value> v8::Object::Get(v8::Local<Value> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   RETURN_TO_LOCAL_UNCHECKED(Get(context, key), Value);\n }\n \n@@ -4481,7 +4590,7 @@ MaybeLocal<Value> v8::Object::Get(Local<Context> context, uint32_t index) {\n \n \n Local<Value> v8::Object::Get(uint32_t index) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   RETURN_TO_LOCAL_UNCHECKED(Get(context, index), Value);\n }\n \n@@ -4605,7 +4714,7 @@ MaybeLocal<Array> v8::Object::GetPropertyNames(\n \n \n Local<Array> v8::Object::GetPropertyNames() {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   RETURN_TO_LOCAL_UNCHECKED(GetPropertyNames(context), Array);\n }\n \n@@ -4615,7 +4724,7 @@ MaybeLocal<Array> v8::Object::GetOwnPropertyNames(Local<Context> context) {\n }\n \n Local<Array> v8::Object::GetOwnPropertyNames() {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   RETURN_TO_LOCAL_UNCHECKED(GetOwnPropertyNames(context), Array);\n }\n \n@@ -4685,7 +4794,7 @@ Maybe<bool> v8::Object::Delete(Local<Context> context, Local<Value> key) {\n }\n \n bool v8::Object::Delete(v8::Local<Value> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   return Delete(context, key).FromMaybe(false);\n }\n \n@@ -4729,7 +4838,7 @@ Maybe<bool> v8::Object::Has(Local<Context> context, Local<Value> key) {\n \n \n bool v8::Object::Has(v8::Local<Value> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   return Has(context, key).FromMaybe(false);\n }\n \n@@ -4789,7 +4898,7 @@ static Maybe<bool> ObjectSetAccessor(\n       !i::JSObject::SetAccessor(obj, accessor_name, info, attrs)\n            .ToHandle(&result);\n   RETURN_ON_FAILED_EXECUTION_PRIMITIVE(bool);\n-  if (result->IsUndefined(obj->GetIsolate())) return Just(false);\n+  if (result->IsUndefined(isolate)) return Just(false);\n   if (fast) {\n     i::JSObject::MigrateSlowToFast(obj, 0, \"APISetAccessor\");\n   }\n@@ -4888,7 +4997,7 @@ Maybe<bool> v8::Object::HasRealNamedProperty(Local<Context> context,\n \n \n bool v8::Object::HasRealNamedProperty(Local<String> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   return HasRealNamedProperty(context, key).FromMaybe(false);\n }\n \n@@ -4909,7 +5018,7 @@ Maybe<bool> v8::Object::HasRealIndexedProperty(Local<Context> context,\n \n \n bool v8::Object::HasRealIndexedProperty(uint32_t index) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   return HasRealIndexedProperty(context, index).FromMaybe(false);\n }\n \n@@ -4931,7 +5040,7 @@ Maybe<bool> v8::Object::HasRealNamedCallbackProperty(Local<Context> context,\n \n \n bool v8::Object::HasRealNamedCallbackProperty(Local<String> key) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   return HasRealNamedCallbackProperty(context, key).FromMaybe(false);\n }\n \n@@ -5207,7 +5316,7 @@ MaybeLocal<v8::Value> Function::Call(Local<Context> context,\n \n Local<v8::Value> Function::Call(v8::Local<v8::Value> recv, int argc,\n                                 v8::Local<v8::Value> argv[]) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   RETURN_TO_LOCAL_UNCHECKED(Call(context, recv, argc, argv), Value);\n }\n \n@@ -5259,7 +5368,7 @@ Local<Value> Function::GetDebugName() const {\n   }\n   auto func = i::Handle<i::JSFunction>::cast(self);\n   i::Handle<i::String> name = i::JSFunction::GetDebugName(func);\n-  return Utils::ToLocal(i::Handle<i::Object>(*name, name->GetIsolate()));\n+  return Utils::ToLocal(i::Handle<i::Object>(*name, self->GetIsolate()));\n }\n \n \n@@ -5290,7 +5399,8 @@ ScriptOrigin Function::GetScriptOrigin() const {\n   }\n   auto func = i::Handle<i::JSFunction>::cast(self);\n   if (func->shared()->script()->IsScript()) {\n-    i::Handle<i::Script> script(i::Script::cast(func->shared()->script()));\n+    i::Handle<i::Script> script(i::Script::cast(func->shared()->script()),\n+                                func->GetIsolate());\n     return GetScriptOriginForScript(func->GetIsolate(), script);\n   }\n   return v8::ScriptOrigin(Local<Value>());\n@@ -5307,7 +5417,8 @@ int Function::GetScriptLineNumber() const {\n   }\n   auto func = i::Handle<i::JSFunction>::cast(self);\n   if (func->shared()->script()->IsScript()) {\n-    i::Handle<i::Script> script(i::Script::cast(func->shared()->script()));\n+    i::Handle<i::Script> script(i::Script::cast(func->shared()->script()),\n+                                func->GetIsolate());\n     return i::Script::GetLineNumber(script, func->shared()->StartPosition());\n   }\n   return kLineOffsetNotFound;\n@@ -5321,7 +5432,8 @@ int Function::GetScriptColumnNumber() const {\n   }\n   auto func = i::Handle<i::JSFunction>::cast(self);\n   if (func->shared()->script()->IsScript()) {\n-    i::Handle<i::Script> script(i::Script::cast(func->shared()->script()));\n+    i::Handle<i::Script> script(i::Script::cast(func->shared()->script()),\n+                                func->GetIsolate());\n     return i::Script::GetColumnNumber(script, func->shared()->StartPosition());\n   }\n   return kLineOffsetNotFound;\n@@ -5337,7 +5449,8 @@ int Function::ScriptId() const {\n   if (!func->shared()->script()->IsScript()) {\n     return v8::UnboundScript::kNoScriptId;\n   }\n-  i::Handle<i::Script> script(i::Script::cast(func->shared()->script()));\n+  i::Handle<i::Script> script(i::Script::cast(func->shared()->script()),\n+                              func->GetIsolate());\n   return script->id();\n }\n \n@@ -5487,13 +5600,14 @@ bool String::ContainsOnlyOneByte() const {\n   return helper.Check(*str);\n }\n \n-int String::Utf8Length(Isolate* isolate) const {\n-  return Utf8Length();\n+int String::Utf8Length() const {\n+  i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();\n+  return Utf8Length(reinterpret_cast<Isolate*>(isolate));\n }\n \n-int String::Utf8Length() const {\n+int String::Utf8Length(Isolate* isolate) const {\n   i::Handle<i::String> str = Utils::OpenHandle(this);\n-  str = i::String::Flatten(str);\n+  str = i::String::Flatten(reinterpret_cast<i::Isolate*>(isolate), str);\n   int length = str->length();\n   if (length == 0) return 0;\n   i::DisallowHeapAllocation no_gc;\n@@ -5515,7 +5629,6 @@ int String::Utf8Length() const {\n   return utf8_length;\n }\n \n-\n class Utf8WriterVisitor {\n  public:\n   Utf8WriterVisitor(\n@@ -5715,14 +5828,13 @@ static bool RecursivelySerializeToUtf8(i::String* current,\n   return true;\n }\n \n-\n int String::WriteUtf8(Isolate* v8_isolate, char* buffer, int capacity,\n                       int* nchars_ref, int options) const {\n   i::Handle<i::String> str = Utils::OpenHandle(this);\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n   LOG_API(isolate, String, WriteUtf8);\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n-  str = i::String::Flatten(str);  // Flatten the string for efficiency.\n+  str = i::String::Flatten(isolate, str);  // Flatten the string for efficiency.\n   const int string_length = str->length();\n   bool write_null = !(options & NO_NULL_TERMINATION);\n   bool replace_invalid_utf8 = (options & REPLACE_INVALID_UTF8);\n@@ -5735,7 +5847,7 @@ int String::WriteUtf8(Isolate* v8_isolate, char* buffer, int capacity,\n     if (success) return writer.CompleteWrite(write_null, nchars_ref);\n   } else if (capacity >= string_length) {\n     // First check that the buffer is large enough.\n-    int utf8_bytes = Utf8Length();\n+    int utf8_bytes = Utf8Length(reinterpret_cast<Isolate*>(isolate));\n     if (utf8_bytes <= capacity) {\n       // one-byte fast path.\n       if (utf8_bytes == string_length) {\n@@ -5763,7 +5875,9 @@ int String::WriteUtf8(Isolate* v8_isolate, char* buffer, int capacity,\n int String::WriteUtf8(char* buffer, int capacity, int* nchars_ref,\n                       int options) const {\n   i::Handle<i::String> str = Utils::OpenHandle(this);\n+  DISABLE_DEPRECATED_WARNINGS\n   i::Isolate* isolate = str->GetIsolate();\n+  RESET_DEPRECATED_WARNINGS\n   return WriteUtf8(reinterpret_cast<Isolate*>(isolate), buffer, capacity,\n                    nchars_ref, options);\n }\n@@ -5776,7 +5890,7 @@ static inline int WriteHelper(i::Isolate* isolate, const String* string,\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n   DCHECK(start >= 0 && length >= -1);\n   i::Handle<i::String> str = Utils::OpenHandle(string);\n-  str = i::String::Flatten(str);\n+  str = i::String::Flatten(isolate, str);\n   int end = start + length;\n   if ((length == -1) || (length > str->length() - start) )\n     end = str->length();\n@@ -5794,7 +5908,9 @@ int String::WriteOneByte(uint8_t* buffer,\n                          int start,\n                          int length,\n                          int options) const {\n+  DISABLE_DEPRECATED_WARNINGS\n   i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();\n+  RESET_DEPRECATED_WARNINGS\n   return WriteHelper(isolate, this, buffer, start, length, options);\n }\n \n@@ -5809,7 +5925,9 @@ int String::Write(uint16_t* buffer,\n                   int start,\n                   int length,\n                   int options) const {\n+  DISABLE_DEPRECATED_WARNINGS\n   i::Isolate* isolate = Utils::OpenHandle(this)->GetIsolate();\n+  RESET_DEPRECATED_WARNINGS\n   return WriteHelper(isolate, this, buffer, start, length, options);\n }\n \n@@ -5885,7 +6003,19 @@ v8::String::GetExternalOneByteStringResource() const {\n \n Local<Value> Symbol::Name() const {\n   i::Handle<i::Symbol> sym = Utils::OpenHandle(this);\n-  i::Handle<i::Object> name(sym->name(), sym->GetIsolate());\n+\n+  i::MemoryChunk* chunk = i::MemoryChunk::FromHeapObject(*sym);\n+  // If the Symbol is in RO_SPACE, then its name must be too. Since RO_SPACE\n+  // objects are immovable we can use the Handle(T**) constructor with the\n+  // address of the name field in the Symbol object without needing an isolate.\n+  if (chunk->owner()->identity() == i::RO_SPACE) {\n+    i::Handle<i::HeapObject> ro_name(reinterpret_cast<i::HeapObject**>(\n+        sym->GetFieldAddress(i::Symbol::kNameOffset)));\n+    return Utils::ToLocal(ro_name);\n+  }\n+\n+  i::Handle<i::Object> name(sym->name(), chunk->heap()->isolate());\n+\n   return Utils::ToLocal(name);\n }\n \n@@ -5903,7 +6033,7 @@ double Number::Value() const {\n \n bool Boolean::Value() const {\n   i::Handle<i::Object> obj = Utils::OpenHandle(this);\n-  return obj->IsTrue(i::HeapObject::cast(*obj)->GetIsolate());\n+  return obj->IsTrue();\n }\n \n \n@@ -6006,8 +6136,7 @@ void v8::Object::SetAlignedPointerInInternalFields(int argc, int indices[],\n \n static void* ExternalValue(i::Object* obj) {\n   // Obscure semantics for undefined, but somehow checked in our unit tests...\n-  if (!obj->IsSmi() &&\n-      obj->IsUndefined(i::HeapObject::cast(obj)->GetIsolate())) {\n+  if (obj->IsUndefined()) {\n     return nullptr;\n   }\n   i::Object* foreign = i::JSObject::cast(obj)->GetEmbedderField(0);\n@@ -6206,7 +6335,7 @@ static i::Handle<ObjectType> CreateEnvironment(\n             global_constructor->needs_access_check());\n         global_constructor->set_needs_access_check(false);\n         global_constructor->set_access_check_info(\n-            isolate->heap()->undefined_value());\n+            i::ReadOnlyRoots(isolate).undefined_value());\n       }\n \n       // Same for other interceptors. If the global constructor has\n@@ -6217,14 +6346,14 @@ static i::Handle<ObjectType> CreateEnvironment(\n         named_interceptor =\n             handle(global_constructor->named_property_handler(), isolate);\n         global_constructor->set_named_property_handler(\n-            isolate->heap()->noop_interceptor_info());\n+            i::ReadOnlyRoots(isolate).noop_interceptor_info());\n       }\n       if (!global_constructor->indexed_property_handler()->IsUndefined(\n               isolate)) {\n         indexed_interceptor =\n             handle(global_constructor->indexed_property_handler(), isolate);\n         global_constructor->set_indexed_property_handler(\n-            isolate->heap()->noop_interceptor_info());\n+            i::ReadOnlyRoots(isolate).noop_interceptor_info());\n       }\n     }\n \n@@ -6397,7 +6526,8 @@ void Context::AllowCodeGenerationFromStrings(bool allow) {\n   i::Isolate* isolate = context->GetIsolate();\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n   context->set_allow_code_gen_from_strings(\n-      allow ? isolate->heap()->true_value() : isolate->heap()->false_value());\n+      allow ? i::ReadOnlyRoots(isolate).true_value()\n+            : i::ReadOnlyRoots(isolate).false_value());\n }\n \n \n@@ -6422,10 +6552,12 @@ i::Object** GetSerializedDataFromFixedArray(i::Isolate* isolate,\n     i::Object* object = list->get(int_index);\n     if (!object->IsTheHole(isolate)) {\n       list->set_the_hole(isolate, int_index);\n-      // Shrink the list so that the last element is not the hole.\n+      // Shrink the list so that the last element is not the hole (unless it's\n+      // the first element, because we don't want to end up with a non-canonical\n+      // empty FixedArray).\n       int last = list->length() - 1;\n       while (last >= 0 && list->is_the_hole(isolate, last)) last--;\n-      list->Shrink(last + 1);\n+      if (last != -1) list->Shrink(isolate, last + 1);\n       return i::Handle<i::Object>(object, isolate).location();\n     }\n   }\n@@ -6436,23 +6568,23 @@ i::Object** GetSerializedDataFromFixedArray(i::Isolate* isolate,\n i::Object** Context::GetDataFromSnapshotOnce(size_t index) {\n   auto context = Utils::OpenHandle(this);\n   i::Isolate* i_isolate = context->GetIsolate();\n-  i::FixedArray* list = i::FixedArray::cast(context->serialized_objects());\n+  i::FixedArray* list = context->serialized_objects();\n   return GetSerializedDataFromFixedArray(i_isolate, list, index);\n }\n \n MaybeLocal<v8::Object> ObjectTemplate::NewInstance(Local<Context> context) {\n   PREPARE_FOR_EXECUTION(context, ObjectTemplate, NewInstance, Object);\n   auto self = Utils::OpenHandle(this);\n   Local<Object> result;\n-  has_pending_exception =\n-      !ToLocal<Object>(i::ApiNatives::InstantiateObject(self), &result);\n+  has_pending_exception = !ToLocal<Object>(\n+      i::ApiNatives::InstantiateObject(isolate, self), &result);\n   RETURN_ON_FAILED_EXECUTION(Object);\n   RETURN_ESCAPED(result);\n }\n \n \n Local<v8::Object> ObjectTemplate::NewInstance() {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   RETURN_TO_LOCAL_UNCHECKED(NewInstance(context), Object);\n }\n \n@@ -6492,7 +6624,7 @@ MaybeLocal<v8::Function> FunctionTemplate::GetFunction(Local<Context> context) {\n \n \n Local<v8::Function> FunctionTemplate::GetFunction() {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   RETURN_TO_LOCAL_UNCHECKED(GetFunction(context), Function);\n }\n \n@@ -6532,7 +6664,8 @@ bool FunctionTemplate::HasInstance(v8::Local<v8::Value> value) {\n   if (obj->IsJSGlobalProxy()) {\n     // If it's a global proxy, then test with the global object. Note that the\n     // inner global object may not necessarily be a JSGlobalObject.\n-    i::PrototypeIterator iter(i::JSObject::cast(*obj)->map());\n+    i::PrototypeIterator iter(self->GetIsolate(),\n+                              i::JSObject::cast(*obj)->map());\n     // The global proxy should always have a prototype, as it is a bug to call\n     // this on a detached JSGlobalProxy.\n     DCHECK(!iter.IsAtEnd());\n@@ -6692,7 +6825,9 @@ Local<String> v8::String::Concat(Isolate* v8_isolate, Local<String> left,\n \n Local<String> v8::String::Concat(Local<String> left, Local<String> right) {\n   i::Handle<i::String> left_string = Utils::OpenHandle(*left);\n+  DISABLE_DEPRECATED_WARNINGS\n   i::Isolate* isolate = left_string->GetIsolate();\n+  RESET_DEPRECATED_WARNINGS\n   return Concat(reinterpret_cast<Isolate*>(isolate), left, right);\n }\n \n@@ -6710,7 +6845,6 @@ MaybeLocal<String> v8::String::NewExternalTwoByte(\n     i::Handle<i::String> string = i_isolate->factory()\n                                       ->NewExternalStringFromTwoByte(resource)\n                                       .ToHandleChecked();\n-    i_isolate->heap()->RegisterExternalString(*string);\n     return Utils::ToLocal(string);\n   } else {\n     // The resource isn't going to be used, free it immediately.\n@@ -6734,7 +6868,6 @@ MaybeLocal<String> v8::String::NewExternalOneByte(\n     i::Handle<i::String> string = i_isolate->factory()\n                                       ->NewExternalStringFromOneByte(resource)\n                                       .ToHandleChecked();\n-    i_isolate->heap()->RegisterExternalString(*string);\n     return Utils::ToLocal(string);\n   } else {\n     // The resource isn't going to be used, free it immediately.\n@@ -6752,7 +6885,13 @@ Local<String> v8::String::NewExternal(\n \n bool v8::String::MakeExternal(v8::String::ExternalStringResource* resource) {\n   i::Handle<i::String> obj = Utils::OpenHandle(this);\n-  i::Isolate* isolate = obj->GetIsolate();\n+  // RO_SPACE strings cannot be externalized.\n+  i::MemoryChunk* chunk = i::MemoryChunk::FromHeapObject(*obj);\n+  if (chunk->owner()->identity() == i::RO_SPACE) {\n+    return false;\n+  }\n+\n+  i::Isolate* isolate = chunk->heap()->isolate();\n   if (i::StringShape(*obj).IsExternal()) {\n     return false;  // Already an external string.\n   }\n@@ -6767,7 +6906,6 @@ bool v8::String::MakeExternal(v8::String::ExternalStringResource* resource) {\n   DCHECK(!CanMakeExternal() || result);\n   if (result) {\n     DCHECK(obj->IsExternalString());\n-    isolate->heap()->RegisterExternalString(*obj);\n   }\n   return result;\n }\n@@ -6776,7 +6914,14 @@ bool v8::String::MakeExternal(v8::String::ExternalStringResource* resource) {\n bool v8::String::MakeExternal(\n     v8::String::ExternalOneByteStringResource* resource) {\n   i::Handle<i::String> obj = Utils::OpenHandle(this);\n-  i::Isolate* isolate = obj->GetIsolate();\n+\n+  // RO_SPACE strings cannot be externalized.\n+  i::MemoryChunk* chunk = i::MemoryChunk::FromHeapObject(*obj);\n+  if (chunk->owner()->identity() == i::RO_SPACE) {\n+    return false;\n+  }\n+\n+  i::Isolate* isolate = chunk->heap()->isolate();\n   if (i::StringShape(*obj).IsExternal()) {\n     return false;  // Already an external string.\n   }\n@@ -6791,7 +6936,6 @@ bool v8::String::MakeExternal(\n   DCHECK(!CanMakeExternal() || result);\n   if (result) {\n     DCHECK(obj->IsExternalString());\n-    isolate->heap()->RegisterExternalString(*obj);\n   }\n   return result;\n }\n@@ -6801,10 +6945,10 @@ bool v8::String::CanMakeExternal() {\n   i::Handle<i::String> obj = Utils::OpenHandle(this);\n   if (obj->IsExternalString()) return false;\n \n-  // Old space strings should be externalized.\n-  i::Heap* heap = obj->GetIsolate()->heap();\n-  return !heap->new_space()->Contains(*obj) &&\n-         !heap->read_only_space()->Contains(*obj);\n+  // Only old space strings should be externalized.\n+  i::MemoryChunk* chunk = i::MemoryChunk::FromHeapObject(*obj);\n+  i::AllocationSpace space = chunk->owner()->identity();\n+  return space != i::NEW_SPACE && space != i::RO_SPACE;\n }\n \n \n@@ -6860,15 +7004,16 @@ Local<v8::BigInt> v8::BigIntObject::ValueOf() const {\n   i::Isolate* isolate = jsvalue->GetIsolate();\n   LOG_API(isolate, BigIntObject, BigIntValue);\n   return Utils::ToLocal(\n-      i::Handle<i::BigInt>(i::BigInt::cast(jsvalue->value())));\n+      i::Handle<i::BigInt>(i::BigInt::cast(jsvalue->value()), isolate));\n }\n \n Local<v8::Value> v8::BooleanObject::New(Isolate* isolate, bool value) {\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n   LOG_API(i_isolate, BooleanObject, New);\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);\n-  i::Handle<i::Object> boolean(value ? i_isolate->heap()->true_value()\n-                                     : i_isolate->heap()->false_value(),\n+  i::Handle<i::Object> boolean(value\n+                                   ? i::ReadOnlyRoots(i_isolate).true_value()\n+                                   : i::ReadOnlyRoots(i_isolate).false_value(),\n                                i_isolate);\n   i::Handle<i::Object> obj =\n       i::Object::ToObject(i_isolate, boolean).ToHandleChecked();\n@@ -6887,7 +7032,16 @@ bool v8::BooleanObject::ValueOf() const {\n \n Local<v8::Value> v8::StringObject::New(Local<String> value) {\n   i::Handle<i::String> string = Utils::OpenHandle(*value);\n+  DISABLE_DEPRECATED_WARNINGS\n   i::Isolate* isolate = string->GetIsolate();\n+  RESET_DEPRECATED_WARNINGS\n+  return New(reinterpret_cast<Isolate*>(isolate), value);\n+}\n+\n+Local<v8::Value> v8::StringObject::New(Isolate* v8_isolate,\n+                                       Local<String> value) {\n+  i::Handle<i::String> string = Utils::OpenHandle(*value);\n+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n   LOG_API(isolate, StringObject, New);\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n   i::Handle<i::Object> obj =\n@@ -6902,7 +7056,7 @@ Local<v8::String> v8::StringObject::ValueOf() const {\n   i::Isolate* isolate = jsvalue->GetIsolate();\n   LOG_API(isolate, StringObject, StringValue);\n   return Utils::ToLocal(\n-      i::Handle<i::String>(i::String::cast(jsvalue->value())));\n+      i::Handle<i::String>(i::String::cast(jsvalue->value()), isolate));\n }\n \n \n@@ -6922,7 +7076,7 @@ Local<v8::Symbol> v8::SymbolObject::ValueOf() const {\n   i::Isolate* isolate = jsvalue->GetIsolate();\n   LOG_API(isolate, SymbolObject, SymbolValue);\n   return Utils::ToLocal(\n-      i::Handle<i::Symbol>(i::Symbol::cast(jsvalue->value())));\n+      i::Handle<i::Symbol>(i::Symbol::cast(jsvalue->value()), isolate));\n }\n \n \n@@ -6980,7 +7134,7 @@ MaybeLocal<v8::RegExp> v8::RegExp::New(Local<Context> context,\n   PREPARE_FOR_EXECUTION(context, RegExp, New, RegExp);\n   Local<v8::RegExp> result;\n   has_pending_exception =\n-      !ToLocal<RegExp>(i::JSRegExp::New(Utils::OpenHandle(*pattern),\n+      !ToLocal<RegExp>(i::JSRegExp::New(isolate, Utils::OpenHandle(*pattern),\n                                         static_cast<i::JSRegExp::Flags>(flags)),\n                        &result);\n   RETURN_ON_FAILED_EXECUTION(RegExp);\n@@ -6998,7 +7152,8 @@ Local<v8::RegExp> v8::RegExp::New(Local<String> pattern, Flags flags) {\n \n Local<v8::String> v8::RegExp::GetSource() const {\n   i::Handle<i::JSRegExp> obj = Utils::OpenHandle(this);\n-  return Utils::ToLocal(i::Handle<i::String>(obj->Pattern()));\n+  return Utils::ToLocal(\n+      i::Handle<i::String>(obj->Pattern(), obj->GetIsolate()));\n }\n \n \n@@ -7064,7 +7219,7 @@ void Map::Clear() {\n   i::Isolate* isolate = self->GetIsolate();\n   LOG_API(isolate, Map, Clear);\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n-  i::JSMap::Clear(self);\n+  i::JSMap::Clear(isolate, self);\n }\n \n \n@@ -7135,7 +7290,8 @@ enum class MapAsArrayKind {\n i::Handle<i::JSArray> MapAsArray(i::Isolate* isolate, i::Object* table_obj,\n                                  int offset, MapAsArrayKind kind) {\n   i::Factory* factory = isolate->factory();\n-  i::Handle<i::OrderedHashMap> table(i::OrderedHashMap::cast(table_obj));\n+  i::Handle<i::OrderedHashMap> table(i::OrderedHashMap::cast(table_obj),\n+                                     isolate);\n   if (offset >= table->NumberOfElements()) return factory->NewJSArray(0);\n   int length = (table->NumberOfElements() - offset) *\n                (kind == MapAsArrayKind::kEntries ? 2 : 1);\n@@ -7144,7 +7300,7 @@ i::Handle<i::JSArray> MapAsArray(i::Isolate* isolate, i::Object* table_obj,\n   {\n     i::DisallowHeapAllocation no_gc;\n     int capacity = table->UsedCapacity();\n-    i::Oddball* the_hole = isolate->heap()->the_hole_value();\n+    i::Oddball* the_hole = i::ReadOnlyRoots(isolate).the_hole_value();\n     for (int i = 0; i < capacity; ++i) {\n       i::Object* key = table->KeyAt(i);\n       if (key == the_hole) continue;\n@@ -7194,7 +7350,7 @@ void Set::Clear() {\n   i::Isolate* isolate = self->GetIsolate();\n   LOG_API(isolate, Set, Clear);\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n-  i::JSSet::Clear(self);\n+  i::JSSet::Clear(isolate, self);\n }\n \n \n@@ -7242,15 +7398,16 @@ namespace {\n i::Handle<i::JSArray> SetAsArray(i::Isolate* isolate, i::Object* table_obj,\n                                  int offset) {\n   i::Factory* factory = isolate->factory();\n-  i::Handle<i::OrderedHashSet> table(i::OrderedHashSet::cast(table_obj));\n+  i::Handle<i::OrderedHashSet> table(i::OrderedHashSet::cast(table_obj),\n+                                     isolate);\n   int length = table->NumberOfElements() - offset;\n   if (length <= 0) return factory->NewJSArray(0);\n   i::Handle<i::FixedArray> result = factory->NewFixedArray(length);\n   int result_index = 0;\n   {\n     i::DisallowHeapAllocation no_gc;\n     int capacity = table->UsedCapacity();\n-    i::Oddball* the_hole = isolate->heap()->the_hole_value();\n+    i::Oddball* the_hole = i::ReadOnlyRoots(isolate).the_hole_value();\n     for (int i = 0; i < capacity; ++i) {\n       i::Object* key = table->KeyAt(i);\n       if (key == the_hole) continue;\n@@ -7315,7 +7472,7 @@ Maybe<bool> Promise::Resolver::Resolve(Local<Context> context,\n \n \n void Promise::Resolver::Resolve(Local<Value> value) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   USE(Resolve(context, value));\n }\n \n@@ -7340,7 +7497,7 @@ Maybe<bool> Promise::Resolver::Reject(Local<Context> context,\n \n \n void Promise::Resolver::Reject(Local<Value> value) {\n-  auto context = ContextFromHeapObject(Utils::OpenHandle(this));\n+  auto context = ContextFromNeverReadOnlySpaceObject(Utils::OpenHandle(this));\n   USE(Reject(context, value));\n }\n \n@@ -7442,11 +7599,19 @@ MaybeLocal<Proxy> Proxy::New(Local<Context> context, Local<Object> local_target,\n   RETURN_ESCAPED(result);\n }\n \n-Local<String> WasmCompiledModule::GetWasmWireBytes() {\n+WasmCompiledModule::BufferReference WasmCompiledModule::GetWasmWireBytesRef() {\n   i::Handle<i::WasmModuleObject> obj =\n       i::Handle<i::WasmModuleObject>::cast(Utils::OpenHandle(this));\n-  i::Handle<i::String> wire_bytes(obj->shared()->module_bytes());\n-  return Local<String>::Cast(Utils::ToLocal(wire_bytes));\n+  i::Vector<const uint8_t> bytes_vec = obj->native_module()->wire_bytes();\n+  return {bytes_vec.start(), bytes_vec.size()};\n+}\n+\n+Local<String> WasmCompiledModule::GetWasmWireBytes() {\n+  BufferReference ref = GetWasmWireBytesRef();\n+  CHECK_LE(ref.size, String::kMaxLength);\n+  return String::NewFromOneByte(GetIsolate(), ref.start, NewStringType::kNormal,\n+                                static_cast<int>(ref.size))\n+      .ToLocalChecked();\n }\n \n // Currently, wasm modules are bound, both to Isolate and to\n@@ -7458,50 +7623,45 @@ WasmCompiledModule::GetTransferrableModule() {\n   i::DisallowHeapAllocation no_gc;\n   WasmCompiledModule::SerializedModule compiled_part = Serialize();\n \n-  Local<String> wire_bytes = GetWasmWireBytes();\n-  size_t wire_size = static_cast<size_t>(wire_bytes->Length());\n-  uint8_t* bytes = new uint8_t[wire_size];\n-  wire_bytes->WriteOneByte(bytes, 0, wire_bytes->Length());\n+  BufferReference wire_bytes_ref = GetWasmWireBytesRef();\n+  size_t wire_size = wire_bytes_ref.size;\n+  std::unique_ptr<uint8_t[]> wire_bytes_copy(new uint8_t[wire_size]);\n+  memcpy(wire_bytes_copy.get(), wire_bytes_ref.start, wire_size);\n \n-  return TransferrableModule(\n-      std::move(compiled_part),\n-      std::make_pair(\n-          std::unique_ptr<const uint8_t[]>(const_cast<const uint8_t*>(bytes)),\n-          wire_size));\n+  return TransferrableModule(std::move(compiled_part),\n+                             {std::move(wire_bytes_copy), wire_size});\n }\n \n MaybeLocal<WasmCompiledModule> WasmCompiledModule::FromTransferrableModule(\n     Isolate* isolate,\n     const WasmCompiledModule::TransferrableModule& transferrable_module) {\n   MaybeLocal<WasmCompiledModule> ret =\n-      Deserialize(isolate, AsCallerOwned(transferrable_module.compiled_code),\n-                  AsCallerOwned(transferrable_module.wire_bytes));\n+      Deserialize(isolate, AsReference(transferrable_module.compiled_code),\n+                  AsReference(transferrable_module.wire_bytes));\n   return ret;\n }\n \n WasmCompiledModule::SerializedModule WasmCompiledModule::Serialize() {\n   i::Handle<i::WasmModuleObject> obj =\n       i::Handle<i::WasmModuleObject>::cast(Utils::OpenHandle(this));\n-  i::Handle<i::WasmCompiledModule> compiled_part =\n-      i::handle(i::WasmCompiledModule::cast(obj->compiled_module()));\n+  i::wasm::NativeModule* native_module = obj->native_module();\n   size_t buffer_size =\n-      i::wasm::GetSerializedNativeModuleSize(obj->GetIsolate(), compiled_part);\n+      i::wasm::GetSerializedNativeModuleSize(obj->GetIsolate(), native_module);\n   std::unique_ptr<uint8_t[]> buffer(new uint8_t[buffer_size]);\n-  if (i::wasm::SerializeNativeModule(obj->GetIsolate(), compiled_part,\n+  if (i::wasm::SerializeNativeModule(obj->GetIsolate(), native_module,\n                                      {buffer.get(), buffer_size}))\n     return {std::move(buffer), buffer_size};\n   return {};\n }\n \n MaybeLocal<WasmCompiledModule> WasmCompiledModule::Deserialize(\n-    Isolate* isolate,\n-    const WasmCompiledModule::CallerOwnedBuffer& serialized_module,\n-    const WasmCompiledModule::CallerOwnedBuffer& wire_bytes) {\n+    Isolate* isolate, WasmCompiledModule::BufferReference serialized_module,\n+    WasmCompiledModule::BufferReference wire_bytes) {\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n   i::MaybeHandle<i::WasmModuleObject> maybe_module_object =\n       i::wasm::DeserializeNativeModule(\n-          i_isolate, {serialized_module.first, serialized_module.second},\n-          {wire_bytes.first, wire_bytes.second});\n+          i_isolate, {serialized_module.start, serialized_module.size},\n+          {wire_bytes.start, wire_bytes.size});\n   i::Handle<i::WasmModuleObject> module_object;\n   if (!maybe_module_object.ToHandle(&module_object)) {\n     return MaybeLocal<WasmCompiledModule>();\n@@ -7511,15 +7671,14 @@ MaybeLocal<WasmCompiledModule> WasmCompiledModule::Deserialize(\n }\n \n MaybeLocal<WasmCompiledModule> WasmCompiledModule::DeserializeOrCompile(\n-    Isolate* isolate,\n-    const WasmCompiledModule::CallerOwnedBuffer& serialized_module,\n-    const WasmCompiledModule::CallerOwnedBuffer& wire_bytes) {\n+    Isolate* isolate, WasmCompiledModule::BufferReference serialized_module,\n+    WasmCompiledModule::BufferReference wire_bytes) {\n   MaybeLocal<WasmCompiledModule> ret =\n       Deserialize(isolate, serialized_module, wire_bytes);\n   if (!ret.IsEmpty()) {\n     return ret;\n   }\n-  return Compile(isolate, wire_bytes.first, wire_bytes.second);\n+  return Compile(isolate, wire_bytes.start, wire_bytes.size);\n }\n \n MaybeLocal<WasmCompiledModule> WasmCompiledModule::Compile(Isolate* isolate,\n@@ -7538,6 +7697,38 @@ MaybeLocal<WasmCompiledModule> WasmCompiledModule::Compile(Isolate* isolate,\n       Utils::ToLocal(maybe_compiled.ToHandleChecked()));\n }\n \n+// Resolves the result of streaming compilation.\n+// TODO(ahaas): Refactor the streaming compilation API so that this class can\n+// move to wasm-js.cc.\n+class AsyncCompilationResolver : public i::wasm::CompilationResultResolver {\n+ public:\n+  AsyncCompilationResolver(Isolate* isolate, Handle<Promise> promise)\n+      : promise_(\n+            reinterpret_cast<i::Isolate*>(isolate)->global_handles()->Create(\n+                *Utils::OpenHandle(*promise))) {}\n+\n+  ~AsyncCompilationResolver() {\n+    i::GlobalHandles::Destroy(i::Handle<i::Object>::cast(promise_).location());\n+  }\n+\n+  void OnCompilationSucceeded(i::Handle<i::WasmModuleObject> result) override {\n+    i::MaybeHandle<i::Object> promise_result =\n+        i::JSPromise::Resolve(promise_, result);\n+    CHECK_EQ(promise_result.is_null(),\n+             promise_->GetIsolate()->has_pending_exception());\n+  }\n+\n+  void OnCompilationFailed(i::Handle<i::Object> error_reason) override {\n+    i::MaybeHandle<i::Object> promise_result =\n+        i::JSPromise::Reject(promise_, error_reason);\n+    CHECK_EQ(promise_result.is_null(),\n+             promise_->GetIsolate()->has_pending_exception());\n+  }\n+\n+ private:\n+  i::Handle<i::JSPromise> promise_;\n+};\n+\n WasmModuleObjectBuilderStreaming::WasmModuleObjectBuilderStreaming(\n     Isolate* isolate)\n     : isolate_(isolate) {\n@@ -7546,10 +7737,10 @@ WasmModuleObjectBuilderStreaming::WasmModuleObjectBuilderStreaming(\n   Local<Promise::Resolver> resolver = maybe_resolver.ToLocalChecked();\n   promise_.Reset(isolate, resolver->GetPromise());\n \n-  i::Handle<i::JSPromise> promise = Utils::OpenHandle(*GetPromise());\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n   streaming_decoder_ = i_isolate->wasm_engine()->StartStreamingCompilation(\n-      i_isolate, handle(i_isolate->context()), promise);\n+      i_isolate, handle(i_isolate->context(), i_isolate),\n+      base::make_unique<AsyncCompilationResolver>(isolate, GetPromise()));\n }\n \n Local<Promise> WasmModuleObjectBuilderStreaming::GetPromise() {\n@@ -7580,7 +7771,8 @@ void WasmModuleObjectBuilderStreaming::Abort(MaybeLocal<Value> exception) {\n   Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate_);\n   i::HandleScope scope(i_isolate);\n-  Local<Context> context = Utils::ToLocal(handle(i_isolate->context()));\n+  Local<Context> context =\n+      Utils::ToLocal(handle(i_isolate->context(), i_isolate));\n   auto maybe = resolver->Reject(context, exception.ToLocalChecked());\n   CHECK_IMPLIES(!maybe.FromMaybe(false), i_isolate->has_scheduled_exception());\n }\n@@ -7620,8 +7812,7 @@ v8::ArrayBuffer::Contents v8::ArrayBuffer::Externalize() {\n     // longer track it.\n     //\n     // TODO(eholk): Find a way to track this across externalization\n-    isolate->wasm_engine()->memory_tracker()->ReleaseAllocation(\n-        self->backing_store());\n+    self->StopTrackingWasmMemory(isolate);\n   }\n   isolate->heap()->UnregisterArrayBuffer(*self);\n \n@@ -7701,9 +7892,11 @@ Local<ArrayBuffer> v8::ArrayBufferView::Buffer() {\n   i::Handle<i::JSArrayBufferView> obj = Utils::OpenHandle(this);\n   i::Handle<i::JSArrayBuffer> buffer;\n   if (obj->IsJSDataView()) {\n-    i::Handle<i::JSDataView> data_view(i::JSDataView::cast(*obj));\n+    i::Handle<i::JSDataView> data_view(i::JSDataView::cast(*obj),\n+                                       obj->GetIsolate());\n     DCHECK(data_view->buffer()->IsJSArrayBuffer());\n-    buffer = i::handle(i::JSArrayBuffer::cast(data_view->buffer()));\n+    buffer = i::handle(i::JSArrayBuffer::cast(data_view->buffer()),\n+                       data_view->GetIsolate());\n   } else {\n     DCHECK(obj->IsJSTypedArray());\n     buffer = i::JSTypedArray::cast(*obj)->GetBuffer();\n@@ -7719,13 +7912,16 @@ size_t v8::ArrayBufferView::CopyContents(void* dest, size_t byte_length) {\n       i::Min(byte_length, i::NumberToSize(self->byte_length()));\n   if (bytes_to_copy) {\n     i::DisallowHeapAllocation no_gc;\n-    i::Handle<i::JSArrayBuffer> buffer(i::JSArrayBuffer::cast(self->buffer()));\n+    i::Isolate* isolate = self->GetIsolate();\n+    i::Handle<i::JSArrayBuffer> buffer(i::JSArrayBuffer::cast(self->buffer()),\n+                                       isolate);\n     const char* source = reinterpret_cast<char*>(buffer->backing_store());\n     if (source == nullptr) {\n       DCHECK(self->IsJSTypedArray());\n-      i::Handle<i::JSTypedArray> typed_array(i::JSTypedArray::cast(*self));\n+      i::Handle<i::JSTypedArray> typed_array(i::JSTypedArray::cast(*self),\n+                                             isolate);\n       i::Handle<i::FixedTypedArrayBase> fixed_array(\n-          i::FixedTypedArrayBase::cast(typed_array->elements()));\n+          i::FixedTypedArrayBase::cast(typed_array->elements()), isolate);\n       source = reinterpret_cast<char*>(fixed_array->DataPtr());\n     }\n     memcpy(dest, source + byte_offset, bytes_to_copy);\n@@ -7736,7 +7932,8 @@ size_t v8::ArrayBufferView::CopyContents(void* dest, size_t byte_length) {\n \n bool v8::ArrayBufferView::HasBuffer() const {\n   i::Handle<i::JSArrayBufferView> self = Utils::OpenHandle(this);\n-  i::Handle<i::JSArrayBuffer> buffer(i::JSArrayBuffer::cast(self->buffer()));\n+  i::Handle<i::JSArrayBuffer> buffer(i::JSArrayBuffer::cast(self->buffer()),\n+                                     self->GetIsolate());\n   return buffer->backing_store() != nullptr;\n }\n \n@@ -7849,8 +8046,7 @@ v8::SharedArrayBuffer::Contents v8::SharedArrayBuffer::Externalize() {\n     // longer track it.\n     //\n     // TODO(eholk): Find a way to track this across externalization\n-    isolate->wasm_engine()->memory_tracker()->ReleaseAllocation(\n-        self->backing_store());\n+    self->StopTrackingWasmMemory(isolate);\n   }\n   isolate->heap()->UnregisterArrayBuffer(*self);\n \n@@ -8089,13 +8285,6 @@ HeapProfiler* Isolate::GetHeapProfiler() {\n   return reinterpret_cast<HeapProfiler*>(heap_profiler);\n }\n \n-\n-CpuProfiler* Isolate::GetCpuProfiler() {\n-  i::CpuProfiler* cpu_profiler =\n-      reinterpret_cast<i::Isolate*>(this)->EnsureCpuProfiler();\n-  return reinterpret_cast<CpuProfiler*>(cpu_profiler);\n-}\n-\n void Isolate::SetIdle(bool is_idle) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n   isolate->SetIdle(is_idle);\n@@ -8113,7 +8302,7 @@ v8::Local<v8::Context> Isolate::GetCurrentContext() {\n   if (context == nullptr) return Local<Context>();\n   i::Context* native_context = context->native_context();\n   if (native_context == nullptr) return Local<Context>();\n-  return Utils::ToLocal(i::Handle<i::Context>(native_context));\n+  return Utils::ToLocal(i::Handle<i::Context>(native_context, isolate));\n }\n \n \n@@ -8158,7 +8347,7 @@ v8::Local<Value> Isolate::ThrowException(v8::Local<v8::Value> value) {\n   // If we're passed an empty handle, we throw an undefined exception\n   // to deal more gracefully with out of memory situations.\n   if (value.IsEmpty()) {\n-    isolate->ScheduleThrow(isolate->heap()->undefined_value());\n+    isolate->ScheduleThrow(i::ReadOnlyRoots(isolate).undefined_value());\n   } else {\n     isolate->ScheduleThrow(*Utils::OpenHandle(*value));\n   }\n@@ -8479,10 +8668,15 @@ void Isolate::GetHeapStatistics(HeapStatistics* heap_statistics) {\n   heap_statistics->total_available_size_ = heap->Available();\n   heap_statistics->used_heap_size_ = heap->SizeOfObjects();\n   heap_statistics->heap_size_limit_ = heap->MaxReserved();\n+  // TODO(7424): There is no public API for the {WasmEngine} yet. Once such an\n+  // API becomes available we should report the malloced memory separately. For\n+  // now we just add the values, thereby over-approximating the peak slightly.\n   heap_statistics->malloced_memory_ =\n-      isolate->allocator()->GetCurrentMemoryUsage();\n+      isolate->allocator()->GetCurrentMemoryUsage() +\n+      isolate->wasm_engine()->allocator()->GetCurrentMemoryUsage();\n   heap_statistics->peak_malloced_memory_ =\n-      isolate->allocator()->GetMaxMemoryUsage();\n+      isolate->allocator()->GetMaxMemoryUsage() +\n+      isolate->wasm_engine()->allocator()->GetMaxMemoryUsage();\n   heap_statistics->number_of_native_contexts_ = heap->NumberOfNativeContexts();\n   heap_statistics->number_of_detached_contexts_ =\n       heap->NumberOfDetachedContexts();\n@@ -8628,6 +8822,15 @@ void Isolate::RemoveCallCompletedCallback(\n       reinterpret_cast<CallCompletedCallback>(callback));\n }\n \n+void Isolate::AtomicsWaitWakeHandle::Wake() {\n+  reinterpret_cast<i::AtomicsWaitWakeHandle*>(this)->Wake();\n+}\n+\n+void Isolate::SetAtomicsWaitCallback(AtomicsWaitCallback callback, void* data) {\n+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n+  isolate->SetAtomicsWaitCallback(callback, data);\n+}\n+\n void Isolate::SetPromiseHook(PromiseHook hook) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n   isolate->SetPromiseHook(hook);\n@@ -8758,9 +8961,9 @@ void Isolate::LowMemoryNotification() {\n int Isolate::ContextDisposedNotification(bool dependant_context) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n   if (!dependant_context) {\n-    // We left the current context, we can abort all running WebAssembly\n-    // compilations.\n-    isolate->wasm_engine()->AbortAllCompileJobs();\n+    // We left the current context, we can abort all WebAssembly compilations on\n+    // that isolate.\n+    isolate->wasm_engine()->AbortCompileJobsOnIsolate(isolate);\n   }\n   // TODO(ahaas): move other non-heap activity out of the heap call.\n   return isolate->heap()->NotifyContextDisposed(dependant_context);\n@@ -8790,6 +8993,16 @@ void Isolate::MemoryPressureNotification(MemoryPressureLevel level) {\n                                                              on_isolate_thread);\n }\n \n+void Isolate::EnableMemorySavingsMode() {\n+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n+  isolate->EnableMemorySavingsMode();\n+}\n+\n+void Isolate::DisableMemorySavingsMode() {\n+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n+  isolate->DisableMemorySavingsMode();\n+}\n+\n void Isolate::SetRAILMode(RAILMode rail_mode) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n   return isolate->SetRAILMode(rail_mode);\n@@ -8853,6 +9066,9 @@ CALLBACK_SETTER(WasmInstanceCallback, ExtensionCallback, wasm_instance_callback)\n CALLBACK_SETTER(WasmCompileStreamingCallback, ApiImplementationCallback,\n                 wasm_compile_streaming_callback)\n \n+CALLBACK_SETTER(WasmStreamingCallback, WasmStreamingCallback,\n+                wasm_streaming_callback)\n+\n void Isolate::AddNearHeapLimitCallback(v8::NearHeapLimitCallback callback,\n                                        void* data) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);\n@@ -8885,7 +9101,7 @@ bool Isolate::AddMessageListenerWithErrorLevel(MessageCallback that,\n   i::Handle<i::Foreign> foreign =\n       isolate->factory()->NewForeign(FUNCTION_ADDR(that));\n   listener->set(0, *foreign);\n-  listener->set(1, data.IsEmpty() ? isolate->heap()->undefined_value()\n+  listener->set(1, data.IsEmpty() ? i::ReadOnlyRoots(isolate).undefined_value()\n                                   : *Utils::OpenHandle(*data));\n   listener->set(2, i::Smi::FromInt(message_levels));\n   list = i::TemplateList::Add(isolate, list, listener);\n@@ -8905,7 +9121,7 @@ void Isolate::RemoveMessageListeners(MessageCallback that) {\n     i::FixedArray* listener = i::FixedArray::cast(listeners->get(i));\n     i::Foreign* callback_obj = i::Foreign::cast(listener->get(0));\n     if (callback_obj->foreign_address() == FUNCTION_ADDR(that)) {\n-      listeners->set(i, isolate->heap()->undefined_value());\n+      listeners->set(i, i::ReadOnlyRoots(isolate).undefined_value());\n     }\n   }\n }\n@@ -9021,7 +9237,7 @@ String::Utf8Value::Utf8Value(v8::Isolate* isolate, v8::Local<v8::Value> obj)\n   TryCatch try_catch(isolate);\n   Local<String> str;\n   if (!obj->ToString(context).ToLocal(&str)) return;\n-  length_ = str->Utf8Length();\n+  length_ = str->Utf8Length(isolate);\n   str_ = i::NewArray<char>(length_ + 1);\n   str->WriteUtf8(str_);\n }\n@@ -9122,41 +9338,14 @@ v8_inspector::V8Inspector* debug::GetInspector(Isolate* isolate) {\n   return reinterpret_cast<i::Isolate*>(isolate)->inspector();\n }\n \n-Local<Context> debug::GetDebugContext(Isolate* isolate) {\n-  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);\n-  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);\n-  return Utils::ToLocal(i_isolate->debug()->GetDebugContext());\n-}\n-\n-MaybeLocal<Value> debug::Call(Local<Context> context,\n-                              v8::Local<v8::Function> fun,\n-                              v8::Local<v8::Value> data) {\n-  PREPARE_FOR_EXECUTION(context, Debug, Call, Value);\n-  i::Handle<i::Object> data_obj;\n-  if (data.IsEmpty()) {\n-    data_obj = isolate->factory()->undefined_value();\n-  } else {\n-    data_obj = Utils::OpenHandle(*data);\n-  }\n-  Local<Value> result;\n-  has_pending_exception = !ToLocal<Value>(\n-      isolate->debug()->Call(Utils::OpenHandle(*fun), data_obj), &result);\n-  RETURN_ON_FAILED_EXECUTION(Value);\n-  RETURN_ESCAPED(result);\n-}\n-\n-void debug::SetLiveEditEnabled(Isolate* isolate, bool enable) {\n-  i::Isolate* internal_isolate = reinterpret_cast<i::Isolate*>(isolate);\n-  internal_isolate->debug()->set_live_edit_enabled(enable);\n-}\n-\n-void debug::DebugBreak(Isolate* isolate) {\n-  reinterpret_cast<i::Isolate*>(isolate)->stack_guard()->RequestDebugBreak();\n+void debug::SetBreakOnNextFunctionCall(Isolate* isolate) {\n+  reinterpret_cast<i::Isolate*>(isolate)->debug()->SetBreakOnNextFunctionCall();\n }\n \n-void debug::CancelDebugBreak(Isolate* isolate) {\n-  i::Isolate* internal_isolate = reinterpret_cast<i::Isolate*>(isolate);\n-  internal_isolate->stack_guard()->ClearDebugBreak();\n+void debug::ClearBreakOnNextFunctionCall(Isolate* isolate) {\n+  reinterpret_cast<i::Isolate*>(isolate)\n+      ->debug()\n+      ->ClearBreakOnNextFunctionCall();\n }\n \n MaybeLocal<Array> debug::GetInternalProperties(Isolate* v8_isolate,\n@@ -9184,11 +9373,6 @@ void debug::SetBreakPointsActive(Isolate* v8_isolate, bool is_active) {\n   isolate->debug()->set_break_points_active(is_active);\n }\n \n-void debug::SetOutOfMemoryCallback(Isolate* isolate,\n-                                   OutOfMemoryCallback callback, void* data) {\n-  // No-op.\n-}\n-\n void debug::PrepareStep(Isolate* v8_isolate, StepAction action) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n   ENTER_V8_DO_NOT_USE(isolate);\n@@ -9233,7 +9417,8 @@ bool debug::Script::WasCompiled() const {\n \n bool debug::Script::IsEmbedded() const {\n   i::Handle<i::Script> script = Utils::OpenHandle(this);\n-  return script->context_data() == script->GetHeap()->uninitialized_symbol();\n+  return script->context_data() ==\n+         script->GetReadOnlyRoots().uninitialized_symbol();\n }\n \n int debug::Script::Id() const { return Utils::OpenHandle(this)->id(); }\n@@ -9253,7 +9438,8 @@ std::vector<int> debug::Script::LineEnds() const {\n   i::HandleScope scope(isolate);\n   i::Script::InitLineEnds(script);\n   CHECK(script->line_ends()->IsFixedArray());\n-  i::Handle<i::FixedArray> line_ends(i::FixedArray::cast(script->line_ends()));\n+  i::Handle<i::FixedArray> line_ends(i::FixedArray::cast(script->line_ends()),\n+                                     isolate);\n   std::vector<int> result(line_ends->length());\n   for (int i = 0; i < line_ends->length(); ++i) {\n     i::Smi* line_end = i::Smi::cast(line_ends->get(i));\n@@ -9337,9 +9523,9 @@ bool debug::Script::GetPossibleBreakpoints(\n   CHECK(!start.IsEmpty());\n   i::Handle<i::Script> script = Utils::OpenHandle(this);\n   if (script->type() == i::Script::TYPE_WASM) {\n-    i::WasmSharedModuleData* shared =\n-        i::WasmModuleObject::cast(script->wasm_module_object())->shared();\n-    return shared->GetPossibleBreakpoints(start, end, locations);\n+    i::WasmModuleObject* module_object =\n+        i::WasmModuleObject::cast(script->wasm_module_object());\n+    return module_object->GetPossibleBreakpoints(start, end, locations);\n   }\n \n   i::Script::InitLineEnds(script);\n@@ -9388,7 +9574,6 @@ int debug::Script::GetSourceOffset(const debug::Location& location) const {\n   i::Handle<i::Script> script = Utils::OpenHandle(this);\n   if (script->type() == i::Script::TYPE_WASM) {\n     return i::WasmModuleObject::cast(script->wasm_module_object())\n-               ->shared()\n                ->GetFunctionOffset(location.GetLineNumber()) +\n            location.GetColumnNumber();\n   }\n@@ -9420,11 +9605,12 @@ v8::debug::Location debug::Script::GetSourceLocation(int offset) const {\n }\n \n bool debug::Script::SetScriptSource(v8::Local<v8::String> newSource,\n-                                    bool preview, bool* stack_changed) const {\n+                                    bool preview,\n+                                    debug::LiveEditResult* result) const {\n   i::Handle<i::Script> script = Utils::OpenHandle(this);\n   i::Isolate* isolate = script->GetIsolate();\n   return isolate->debug()->SetScriptSource(\n-      script, Utils::OpenHandle(*newSource), preview, stack_changed);\n+      script, Utils::OpenHandle(*newSource), preview, result);\n }\n \n bool debug::Script::SetBreakpoint(v8::Local<v8::String> condition,\n@@ -9462,7 +9648,7 @@ int debug::WasmScript::NumFunctions() const {\n   DCHECK_EQ(i::Script::TYPE_WASM, script->type());\n   i::WasmModuleObject* module_object =\n       i::WasmModuleObject::cast(script->wasm_module_object());\n-  i::wasm::WasmModule* module = module_object->shared()->module();\n+  const i::wasm::WasmModule* module = module_object->module();\n   DCHECK_GE(i::kMaxInt, module->functions.size());\n   return static_cast<int>(module->functions.size());\n }\n@@ -9473,7 +9659,7 @@ int debug::WasmScript::NumImportedFunctions() const {\n   DCHECK_EQ(i::Script::TYPE_WASM, script->type());\n   i::WasmModuleObject* module_object =\n       i::WasmModuleObject::cast(script->wasm_module_object());\n-  i::wasm::WasmModule* module = module_object->shared()->module();\n+  const i::wasm::WasmModule* module = module_object->module();\n   DCHECK_GE(i::kMaxInt, module->num_imported_functions);\n   return static_cast<int>(module->num_imported_functions);\n }\n@@ -9485,10 +9671,10 @@ std::pair<int, int> debug::WasmScript::GetFunctionRange(\n   DCHECK_EQ(i::Script::TYPE_WASM, script->type());\n   i::WasmModuleObject* module_object =\n       i::WasmModuleObject::cast(script->wasm_module_object());\n-  i::wasm::WasmModule* module = module_object->shared()->module();\n+  const i::wasm::WasmModule* module = module_object->module();\n   DCHECK_LE(0, function_index);\n   DCHECK_GT(module->functions.size(), function_index);\n-  i::wasm::WasmFunction& func = module->functions[function_index];\n+  const i::wasm::WasmFunction& func = module->functions[function_index];\n   DCHECK_GE(i::kMaxInt, func.code.offset());\n   DCHECK_GE(i::kMaxInt, func.code.end_offset());\n   return std::make_pair(static_cast<int>(func.code.offset()),\n@@ -9501,13 +9687,12 @@ uint32_t debug::WasmScript::GetFunctionHash(int function_index) {\n   DCHECK_EQ(i::Script::TYPE_WASM, script->type());\n   i::WasmModuleObject* module_object =\n       i::WasmModuleObject::cast(script->wasm_module_object());\n-  i::wasm::WasmModule* module = module_object->shared()->module();\n+  const i::wasm::WasmModule* module = module_object->module();\n   DCHECK_LE(0, function_index);\n   DCHECK_GT(module->functions.size(), function_index);\n-  i::wasm::WasmFunction& func = module->functions[function_index];\n-  i::SeqOneByteString* module_bytes = module_object->shared()->module_bytes();\n+  const i::wasm::WasmFunction& func = module->functions[function_index];\n   i::wasm::ModuleWireBytes wire_bytes(\n-      module_bytes->GetFlatContent().ToOneByteVector());\n+      module_object->native_module()->wire_bytes());\n   i::Vector<const i::byte> function_bytes = wire_bytes.GetFunctionBytes(&func);\n   // TODO(herhut): Maybe also take module, name and signature into account.\n   return i::StringHasher::HashSequentialString(function_bytes.start(),\n@@ -9521,7 +9706,7 @@ debug::WasmDisassembly debug::WasmScript::DisassembleFunction(\n   DCHECK_EQ(i::Script::TYPE_WASM, script->type());\n   i::WasmModuleObject* module_object =\n       i::WasmModuleObject::cast(script->wasm_module_object());\n-  return module_object->shared()->DisassembleFunction(function_index);\n+  return module_object->DisassembleFunction(function_index);\n }\n \n debug::Location::Location(int line_number, int column_number)\n@@ -9590,19 +9775,25 @@ MaybeLocal<UnboundScript> debug::CompileInspectorScript(Isolate* v8_isolate,\n void debug::SetDebugDelegate(Isolate* v8_isolate,\n                              debug::DebugDelegate* delegate) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n-  // Might create the Debug context.\n-  ENTER_V8_FOR_NEW_CONTEXT(isolate);\n-  isolate->debug()->SetDebugDelegate(delegate, false);\n+  isolate->debug()->SetDebugDelegate(delegate);\n+}\n+\n+void debug::SetAsyncEventDelegate(Isolate* v8_isolate,\n+                                  debug::AsyncEventDelegate* delegate) {\n+  reinterpret_cast<i::Isolate*>(v8_isolate)->set_async_event_delegate(delegate);\n }\n \n void debug::ResetBlackboxedStateCache(Isolate* v8_isolate,\n                                       v8::Local<debug::Script> script) {\n   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);\n   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);\n   i::DisallowHeapAllocation no_gc;\n-  i::SharedFunctionInfo::ScriptIterator iter(Utils::OpenHandle(*script));\n+  i::SharedFunctionInfo::ScriptIterator iter(isolate,\n+                                             *Utils::OpenHandle(*script));\n   while (i::SharedFunctionInfo* info = iter.Next()) {\n-    info->set_computed_debug_is_blackboxed(false);\n+    if (info->HasDebugInfo()) {\n+      info->GetDebugInfo()->set_computed_debug_is_blackboxed(false);\n+    }\n   }\n }\n \n@@ -9730,7 +9921,7 @@ MaybeLocal<debug::Script> debug::GeneratorObject::Script() {\n \n Local<Function> debug::GeneratorObject::Function() {\n   i::Handle<i::JSGeneratorObject> obj = Utils::OpenHandle(this);\n-  return Utils::ToLocal(handle(obj->function()));\n+  return Utils::ToLocal(handle(obj->function(), obj->GetIsolate()));\n }\n \n debug::Location debug::GeneratorObject::SuspendedLocation() {\n@@ -9782,17 +9973,20 @@ void debug::GlobalLexicalScopeNames(\n     v8::Local<v8::Context> v8_context,\n     v8::PersistentValueVector<v8::String>* names) {\n   i::Handle<i::Context> context = Utils::OpenHandle(*v8_context);\n+  i::Isolate* isolate = context->GetIsolate();\n   i::Handle<i::ScriptContextTable> table(\n-      context->global_object()->native_context()->script_context_table());\n+      context->global_object()->native_context()->script_context_table(),\n+      isolate);\n   for (int i = 0; i < table->used(); i++) {\n-    i::Handle<i::Context> context = i::ScriptContextTable::GetContext(table, i);\n+    i::Handle<i::Context> context =\n+        i::ScriptContextTable::GetContext(isolate, table, i);\n     DCHECK(context->IsScriptContext());\n-    i::Handle<i::ScopeInfo> scope_info(context->scope_info());\n+    i::Handle<i::ScopeInfo> scope_info(context->scope_info(), isolate);\n     int local_count = scope_info->ContextLocalCount();\n     for (int j = 0; j < local_count; ++j) {\n       i::String* name = scope_info->ContextLocalName(j);\n       if (i::ScopeInfo::VariableIsSynthetic(name)) continue;\n-      names->Append(Utils::ToLocal(handle(name)));\n+      names->Append(Utils::ToLocal(handle(name, isolate)));\n     }\n   }\n }\n@@ -9813,8 +10007,8 @@ int debug::GetNativeAccessorDescriptor(v8::Local<v8::Context> context,\n   if (name->AsArrayIndex(&index)) {\n     return static_cast<int>(debug::NativeAccessorType::None);\n   }\n-  i::LookupIterator it =\n-      i::LookupIterator(object, name, i::LookupIterator::OWN);\n+  i::LookupIterator it = i::LookupIterator(object->GetIsolate(), object, name,\n+                                           i::LookupIterator::OWN);\n   if (!it.IsFound()) return static_cast<int>(debug::NativeAccessorType::None);\n   if (it.state() != i::LookupIterator::ACCESSOR) {\n     return static_cast<int>(debug::NativeAccessorType::None);\n@@ -9846,16 +10040,11 @@ int64_t debug::GetNextRandomInt64(v8::Isolate* v8_isolate) {\n }\n \n int debug::GetDebuggingId(v8::Local<v8::Function> function) {\n-  i::JSReceiver* callable = *v8::Utils::OpenHandle(*function);\n-  if (!callable->IsJSFunction()) return i::SharedFunctionInfo::kNoDebuggingId;\n-  i::JSFunction* fun = i::JSFunction::cast(callable);\n-  i::SharedFunctionInfo* shared = fun->shared();\n-  int id = shared->debugging_id();\n-  if (id == i::SharedFunctionInfo::kNoDebuggingId) {\n-    id = shared->GetHeap()->NextDebuggingId();\n-    shared->set_debugging_id(id);\n-  }\n-  DCHECK_NE(i::SharedFunctionInfo::kNoDebuggingId, id);\n+  i::Handle<i::JSReceiver> callable = v8::Utils::OpenHandle(*function);\n+  if (!callable->IsJSFunction()) return i::DebugInfo::kNoDebuggingId;\n+  i::Handle<i::JSFunction> func = i::Handle<i::JSFunction>::cast(callable);\n+  int id = func->GetIsolate()->debug()->GetFunctionDebuggingId(func);\n+  DCHECK_NE(i::DebugInfo::kNoDebuggingId, id);\n   return id;\n }\n \n@@ -9874,6 +10063,13 @@ bool debug::SetFunctionBreakpoint(v8::Local<v8::Function> function,\n                                                     condition_string, id);\n }\n \n+debug::PostponeInterruptsScope::PostponeInterruptsScope(v8::Isolate* isolate)\n+    : scope_(\n+          new i::PostponeInterruptsScope(reinterpret_cast<i::Isolate*>(isolate),\n+                                         i::StackGuard::API_INTERRUPT)) {}\n+\n+debug::PostponeInterruptsScope::~PostponeInterruptsScope() {}\n+\n Local<String> CpuProfileNode::GetFunctionName() const {\n   const i::ProfileNode* node = reinterpret_cast<const i::ProfileNode*>(this);\n   i::Isolate* isolate = node->isolate();\n@@ -10571,6 +10767,15 @@ void Testing::DeoptimizeAll(Isolate* isolate) {\n   i::Deoptimizer::DeoptimizeAll(i_isolate);\n }\n \n+void EmbedderHeapTracer::FinalizeTracing() {\n+  if (isolate_) {\n+    i::Isolate* isolate = reinterpret_cast<i::Isolate*>(isolate_);\n+    if (isolate->heap()->incremental_marking()->IsMarking()) {\n+      isolate->heap()->FinalizeIncrementalMarkingAtomically(\n+          i::GarbageCollectionReason::kExternalFinalize);\n+    }\n+  }\n+}\n \n namespace internal {\n \n@@ -10767,6 +10972,8 @@ void InvokeFunctionCallback(const v8::FunctionCallbackInfo<v8::Value>& info,\n #undef SET_FIELD_WRAPPED\n #undef NEW_STRING\n #undef CALLBACK_SETTER\n+#undef DISABLE_DEPRECATED_WARNINGS\n+#undef RESET_DEPRECATED_WARNINGS\n \n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "8ffec881ed6992edaebdf76499fb608b05cf02ad",
            "filename": "deps/v8/src/api.h",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fapi.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -11,7 +11,11 @@\n #include \"src/detachable-vector.h\"\n #include \"src/heap/factory.h\"\n #include \"src/isolate.h\"\n+#include \"src/objects/bigint.h\"\n #include \"src/objects/js-collection.h\"\n+#include \"src/objects/js-promise.h\"\n+#include \"src/objects/module.h\"\n+#include \"src/objects/templates.h\"\n \n namespace v8 {\n \n@@ -248,9 +252,7 @@ OPEN_HANDLE_LIST(DECLARE_OPEN_HANDLE)\n \n   template<class From, class To>\n   static inline Local<To> Convert(v8::internal::Handle<From> obj) {\n-    DCHECK(obj.is_null() ||\n-           (obj->IsSmi() ||\n-            !obj->IsTheHole(i::HeapObject::cast(*obj)->GetIsolate())));\n+    DCHECK(obj.is_null() || (obj->IsSmi() || !obj->IsTheHole()));\n     return Local<To>(reinterpret_cast<To*>(obj.location()));\n   }\n \n@@ -635,7 +637,7 @@ bool HandleScopeImplementer::LastEnteredContextWas(Handle<Context> context) {\n \n Handle<Context> HandleScopeImplementer::LastEnteredContext() {\n   if (entered_contexts_.empty()) return Handle<Context>::null();\n-  return Handle<Context>(entered_contexts_.back());\n+  return Handle<Context>(entered_contexts_.back(), isolate_);\n }\n \n void HandleScopeImplementer::EnterMicrotaskContext(Handle<Context> context) {\n@@ -650,7 +652,7 @@ void HandleScopeImplementer::LeaveMicrotaskContext() {\n }\n \n Handle<Context> HandleScopeImplementer::MicrotaskContext() {\n-  if (microtask_context_) return Handle<Context>(microtask_context_);\n+  if (microtask_context_) return Handle<Context>(microtask_context_, isolate_);\n   return Handle<Context>::null();\n }\n "
        },
        {
            "sha": "bef9cba6988d1626ac3850cdb18e08fb7c39c2d9",
            "filename": "deps/v8/src/arguments.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farguments.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farguments.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farguments.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -81,7 +81,7 @@ double ClobberDoubleRegisters(double x1, double x2, double x3, double x4);\n // TODO(cbruni): add global flag to check whether any tracing events have been\n // enabled.\n #define RUNTIME_FUNCTION_RETURNS_TYPE(Type, Name)                             \\\n-  static INLINE(Type __RT_impl_##Name(Arguments args, Isolate* isolate));     \\\n+  static V8_INLINE Type __RT_impl_##Name(Arguments args, Isolate* isolate);   \\\n                                                                               \\\n   V8_NOINLINE static Type Stats_##Name(int args_length, Object** args_object, \\\n                                        Isolate* isolate) {                    \\"
        },
        {
            "sha": "a432e44814986f3210b5671c3ce80e0320b5980b",
            "filename": "deps/v8/src/arm/assembler-arm-inl.h",
            "status": "modified",
            "additions": 40,
            "deletions": 24,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm-inl.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -60,14 +60,17 @@ void RelocInfo::apply(intptr_t delta) {\n     // absolute code pointer inside code object moves with the code object.\n     int32_t* p = reinterpret_cast<int32_t*>(pc_);\n     *p += delta;  // relocate entry\n+  } else if (RelocInfo::IsRelativeCodeTarget(rmode_)) {\n+    Instruction* branch = Instruction::At(pc_);\n+    int32_t branch_offset = branch->GetBranchOffset() + delta;\n+    branch->SetBranchOffset(branch_offset);\n   }\n-  // We do not use pc relative addressing on ARM, so there is\n-  // nothing else to do.\n }\n \n \n Address RelocInfo::target_address() {\n-  DCHECK(IsCodeTarget(rmode_) || IsRuntimeEntry(rmode_) || IsWasmCall(rmode_));\n+  DCHECK(IsCodeTargetMode(rmode_) || IsRuntimeEntry(rmode_) ||\n+         IsWasmCall(rmode_));\n   return Assembler::target_address_at(pc_, constant_pool_);\n }\n \n@@ -101,22 +104,24 @@ HeapObject* RelocInfo::target_object() {\n }\n \n Handle<HeapObject> RelocInfo::target_object_handle(Assembler* origin) {\n-  DCHECK(IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT);\n-  return Handle<HeapObject>(reinterpret_cast<HeapObject**>(\n-      Assembler::target_address_at(pc_, constant_pool_)));\n+  if (IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT) {\n+    return Handle<HeapObject>(reinterpret_cast<HeapObject**>(\n+        Assembler::target_address_at(pc_, constant_pool_)));\n+  }\n+  DCHECK(IsRelativeCodeTarget(rmode_));\n+  return origin->relative_code_target_object_handle_at(pc_);\n }\n \n-void RelocInfo::set_target_object(HeapObject* target,\n+void RelocInfo::set_target_object(Heap* heap, HeapObject* target,\n                                   WriteBarrierMode write_barrier_mode,\n                                   ICacheFlushMode icache_flush_mode) {\n   DCHECK(IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT);\n   Assembler::set_target_address_at(pc_, constant_pool_,\n                                    reinterpret_cast<Address>(target),\n                                    icache_flush_mode);\n   if (write_barrier_mode == UPDATE_WRITE_BARRIER && host() != nullptr) {\n-    host()->GetHeap()->incremental_marking()->RecordWriteIntoCode(host(), this,\n-                                                                  target);\n-    host()->GetHeap()->RecordWriteIntoCode(host(), this, target);\n+    heap->incremental_marking()->RecordWriteIntoCode(host(), this, target);\n+    heap->RecordWriteIntoCode(host(), this, target);\n   }\n }\n \n@@ -144,13 +149,6 @@ Address RelocInfo::target_internal_reference_address() {\n   return pc_;\n }\n \n-void RelocInfo::set_wasm_code_table_entry(Address target,\n-                                          ICacheFlushMode icache_flush_mode) {\n-  DCHECK(rmode_ == RelocInfo::WASM_CODE_TABLE_ENTRY);\n-  Assembler::set_target_address_at(pc_, constant_pool_, target,\n-                                   icache_flush_mode);\n-}\n-\n Address RelocInfo::target_runtime_entry(Assembler* origin) {\n   DCHECK(IsRuntimeEntry(rmode_));\n   return target_address();\n@@ -180,12 +178,19 @@ void RelocInfo::WipeOut() {\n   }\n }\n \n+Handle<Code> Assembler::relative_code_target_object_handle_at(\n+    Address pc) const {\n+  Instruction* branch = Instruction::At(pc);\n+  int code_target_index = branch->GetBranchOffset() / Instruction::kInstrSize;\n+  return GetCodeTarget(code_target_index);\n+}\n+\n template <typename ObjectVisitor>\n void RelocInfo::Visit(ObjectVisitor* visitor) {\n   RelocInfo::Mode mode = rmode();\n   if (mode == RelocInfo::EMBEDDED_OBJECT) {\n     visitor->VisitEmbeddedPointer(host(), this);\n-  } else if (RelocInfo::IsCodeTarget(mode)) {\n+  } else if (RelocInfo::IsCodeTargetMode(mode)) {\n     visitor->VisitCodeTarget(host(), this);\n   } else if (mode == RelocInfo::EXTERNAL_REFERENCE) {\n     visitor->VisitExternalReference(host(), this);\n@@ -317,23 +322,23 @@ Address Assembler::constant_pool_entry_address(Address pc,\n                                                Address constant_pool) {\n   DCHECK(Assembler::IsLdrPcImmediateOffset(Memory::int32_at(pc)));\n   Instr instr = Memory::int32_at(pc);\n-  return pc + GetLdrRegisterImmediateOffset(instr) + kPcLoadDelta;\n+  return pc + GetLdrRegisterImmediateOffset(instr) + Instruction::kPcLoadDelta;\n }\n \n \n Address Assembler::target_address_at(Address pc, Address constant_pool) {\n   if (is_constant_pool_load(pc)) {\n     // This is a constant pool lookup. Return the value in the constant pool.\n     return Memory::Address_at(constant_pool_entry_address(pc, constant_pool));\n-  } else if (CpuFeatures::IsSupported(ARMv7)) {\n+  } else if (CpuFeatures::IsSupported(ARMv7) && IsMovW(Memory::int32_at(pc))) {\n     // This is an movw / movt immediate load. Return the immediate.\n     DCHECK(IsMovW(Memory::int32_at(pc)) &&\n            IsMovT(Memory::int32_at(pc + kInstrSize)));\n     Instruction* movw_instr = Instruction::At(pc);\n     Instruction* movt_instr = Instruction::At(pc + kInstrSize);\n     return static_cast<Address>((movt_instr->ImmedMovwMovtValue() << 16) |\n                                 movw_instr->ImmedMovwMovtValue());\n-  } else {\n+  } else if (IsMovImmed(Memory::int32_at(pc))) {\n     // This is an mov / orr immediate load. Return the immediate.\n     DCHECK(IsMovImmed(Memory::int32_at(pc)) &&\n            IsOrrImmed(Memory::int32_at(pc + kInstrSize)) &&\n@@ -347,6 +352,10 @@ Address Assembler::target_address_at(Address pc, Address constant_pool) {\n         DecodeShiftImm(mov_instr) | DecodeShiftImm(orr_instr_1) |\n         DecodeShiftImm(orr_instr_2) | DecodeShiftImm(orr_instr_3));\n     return ret;\n+  } else {\n+    Instruction* branch = Instruction::At(pc);\n+    int32_t delta = branch->GetBranchOffset();\n+    return pc + delta + Instruction::kPcLoadDelta;\n   }\n }\n \n@@ -364,7 +373,7 @@ void Assembler::set_target_address_at(Address pc, Address constant_pool,\n     // ldr   ip, [pp, #...]\n     // since the instruction accessing this address in the constant pool remains\n     // unchanged.\n-  } else if (CpuFeatures::IsSupported(ARMv7)) {\n+  } else if (CpuFeatures::IsSupported(ARMv7) && IsMovW(Memory::int32_at(pc))) {\n     // This is an movw / movt immediate load. Patch the immediate embedded in\n     // the instructions.\n     DCHECK(IsMovW(Memory::int32_at(pc)));\n@@ -378,15 +387,15 @@ void Assembler::set_target_address_at(Address pc, Address constant_pool,\n     if (icache_flush_mode != SKIP_ICACHE_FLUSH) {\n       Assembler::FlushICache(pc, 2 * kInstrSize);\n     }\n-  } else {\n+  } else if (IsMovImmed(Memory::int32_at(pc))) {\n     // This is an mov / orr immediate load. Patch the immediate embedded in\n     // the instructions.\n     DCHECK(IsMovImmed(Memory::int32_at(pc)) &&\n            IsOrrImmed(Memory::int32_at(pc + kInstrSize)) &&\n            IsOrrImmed(Memory::int32_at(pc + 2 * kInstrSize)) &&\n            IsOrrImmed(Memory::int32_at(pc + 3 * kInstrSize)));\n     uint32_t* instr_ptr = reinterpret_cast<uint32_t*>(pc);\n-    uint32_t immediate = reinterpret_cast<uint32_t>(target);\n+    uint32_t immediate = static_cast<uint32_t>(target);\n     instr_ptr[0] = PatchShiftImm(instr_ptr[0], immediate & kImm8Mask);\n     instr_ptr[1] = PatchShiftImm(instr_ptr[1], immediate & (kImm8Mask << 8));\n     instr_ptr[2] = PatchShiftImm(instr_ptr[2], immediate & (kImm8Mask << 16));\n@@ -398,6 +407,13 @@ void Assembler::set_target_address_at(Address pc, Address constant_pool,\n     if (icache_flush_mode != SKIP_ICACHE_FLUSH) {\n       Assembler::FlushICache(pc, 4 * kInstrSize);\n     }\n+  } else {\n+    intptr_t branch_offset = target - pc - Instruction::kPcLoadDelta;\n+    Instruction* branch = Instruction::At(pc);\n+    branch->SetBranchOffset(branch_offset);\n+    if (icache_flush_mode != SKIP_ICACHE_FLUSH) {\n+      Assembler::FlushICache(pc, kInstrSize);\n+    }\n   }\n }\n "
        },
        {
            "sha": "576bcb30f60bac68e2b6bbeb6d9a6116fea24869",
            "filename": "deps/v8/src/arm/assembler-arm.cc",
            "status": "modified",
            "additions": 58,
            "deletions": 80,
            "changes": 138,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -43,6 +43,7 @@\n #include \"src/base/bits.h\"\n #include \"src/base/cpu.h\"\n #include \"src/code-stubs.h\"\n+#include \"src/deoptimizer.h\"\n #include \"src/macro-assembler.h\"\n #include \"src/objects-inl.h\"\n \n@@ -323,8 +324,8 @@ void CpuFeatures::PrintFeatures() {\n // Implementation of RelocInfo\n \n // static\n-const int RelocInfo::kApplyMask = 0;\n-\n+const int RelocInfo::kApplyMask =\n+    RelocInfo::ModeMask(RelocInfo::RELATIVE_CODE_TARGET);\n \n bool RelocInfo::IsCodedSpecially() {\n   // The deserializer needs to know whether a pointer is specially coded.  Being\n@@ -333,39 +334,31 @@ bool RelocInfo::IsCodedSpecially() {\n   return false;\n }\n \n-\n bool RelocInfo::IsInConstantPool() {\n   return Assembler::is_constant_pool_load(pc_);\n }\n \n-Address RelocInfo::embedded_address() const {\n-  return Assembler::target_address_at(pc_, constant_pool_);\n-}\n-\n-uint32_t RelocInfo::embedded_size() const {\n-  return reinterpret_cast<uint32_t>(\n-      Assembler::target_address_at(pc_, constant_pool_));\n-}\n-\n-void RelocInfo::set_embedded_address(Address address,\n-                                     ICacheFlushMode flush_mode) {\n-  Assembler::set_target_address_at(pc_, constant_pool_, address, flush_mode);\n-}\n-\n-void RelocInfo::set_embedded_size(uint32_t size, ICacheFlushMode flush_mode) {\n-  Assembler::set_target_address_at(pc_, constant_pool_,\n-                                   reinterpret_cast<Address>(size), flush_mode);\n+int RelocInfo::GetDeoptimizationId(Isolate* isolate, DeoptimizeKind kind) {\n+  DCHECK(IsRuntimeEntry(rmode_));\n+  return Deoptimizer::GetDeoptimizationId(isolate, target_address(), kind);\n }\n \n void RelocInfo::set_js_to_wasm_address(Address address,\n                                        ICacheFlushMode icache_flush_mode) {\n   DCHECK_EQ(rmode_, JS_TO_WASM_CALL);\n-  set_embedded_address(address, icache_flush_mode);\n+  Assembler::set_target_address_at(pc_, constant_pool_, address,\n+                                   icache_flush_mode);\n }\n \n Address RelocInfo::js_to_wasm_address() const {\n   DCHECK_EQ(rmode_, JS_TO_WASM_CALL);\n-  return embedded_address();\n+  return Assembler::target_address_at(pc_, constant_pool_);\n+}\n+\n+uint32_t RelocInfo::wasm_call_tag() const {\n+  DCHECK(rmode_ == WASM_CALL || rmode_ == WASM_STUB_CALL);\n+  return static_cast<uint32_t>(\n+      Assembler::target_address_at(pc_, constant_pool_));\n }\n \n // -----------------------------------------------------------------------------\n@@ -483,8 +476,8 @@ void Assembler::AllocateAndInstallRequestedHeapObjects(Isolate* isolate) {\n     Handle<HeapObject> object;\n     switch (request.kind()) {\n       case HeapObjectRequest::kHeapNumber:\n-        object = isolate->factory()->NewHeapNumber(request.heap_number(),\n-                                                   IMMUTABLE, TENURED);\n+        object =\n+            isolate->factory()->NewHeapNumber(request.heap_number(), TENURED);\n         break;\n       case HeapObjectRequest::kCodeStub:\n         request.code_stub()->set_isolate(isolate);\n@@ -544,16 +537,16 @@ const Instr kLdrRegFpNegOffsetPattern =\n const Instr kStrRegFpNegOffsetPattern = al | B26 | NegOffset | fp.code() * B16;\n const Instr kLdrStrInstrTypeMask = 0xFFFF0000;\n \n-Assembler::Assembler(IsolateData isolate_data, void* buffer, int buffer_size)\n-    : AssemblerBase(isolate_data, buffer, buffer_size),\n+Assembler::Assembler(const AssemblerOptions& options, void* buffer,\n+                     int buffer_size)\n+    : AssemblerBase(options, buffer, buffer_size),\n       pending_32_bit_constants_(),\n       pending_64_bit_constants_(),\n       scratch_register_list_(ip.bit()) {\n   pending_32_bit_constants_.reserve(kMinNumPendingConstants);\n   pending_64_bit_constants_.reserve(kMinNumPendingConstants);\n   reloc_info_writer.Reposition(buffer_ + buffer_size_, pc_);\n   next_buffer_check_ = 0;\n-  code_target_sharing_blocked_nesting_ = 0;\n   const_pool_blocked_nesting_ = 0;\n   no_const_pool_before_ = 0;\n   first_const_pool_32_use_ = -1;\n@@ -576,7 +569,6 @@ Assembler::Assembler(IsolateData isolate_data, void* buffer, int buffer_size)\n \n Assembler::~Assembler() {\n   DCHECK_EQ(const_pool_blocked_nesting_, 0);\n-  DCHECK_EQ(code_target_sharing_blocked_nesting_, 0);\n }\n \n void Assembler::GetCode(Isolate* isolate, CodeDesc* desc) {\n@@ -620,20 +612,6 @@ Condition Assembler::GetCondition(Instr instr) {\n   return Instruction::ConditionField(instr);\n }\n \n-\n-bool Assembler::IsBranch(Instr instr) {\n-  return (instr & (B27 | B25)) == (B27 | B25);\n-}\n-\n-\n-int Assembler::GetBranchOffset(Instr instr) {\n-  DCHECK(IsBranch(instr));\n-  // Take the jump offset in the lower 24 bits, sign extend it and multiply it\n-  // with 4 to get the offset in bytes.\n-  return ((instr & kImm24Mask) << 8) >> 6;\n-}\n-\n-\n bool Assembler::IsLdrRegisterImmediate(Instr instr) {\n   return (instr & (B27 | B26 | B25 | B22 | B20)) == (B26 | B20);\n }\n@@ -851,7 +829,7 @@ int Assembler::target_at(int pos) {\n     // blx uses bit 24 to encode bit 2 of imm26\n     imm26 += 2;\n   }\n-  return pos + kPcLoadDelta + imm26;\n+  return pos + Instruction::kPcLoadDelta + imm26;\n }\n \n \n@@ -890,7 +868,7 @@ void Assembler::target_at_put(int pos, int target_pos) {\n     if (is_uint8(target24)) {\n       // If the target fits in a byte then only patch with a mov\n       // instruction.\n-      PatchingAssembler patcher(isolate_data(),\n+      PatchingAssembler patcher(options(),\n                                 reinterpret_cast<byte*>(buffer_ + pos), 1);\n       patcher.mov(dst, Operand(target24));\n     } else {\n@@ -899,12 +877,12 @@ void Assembler::target_at_put(int pos, int target_pos) {\n       if (CpuFeatures::IsSupported(ARMv7)) {\n         // Patch with movw/movt.\n         if (target16_1 == 0) {\n-          PatchingAssembler patcher(isolate_data(),\n+          PatchingAssembler patcher(options(),\n                                     reinterpret_cast<byte*>(buffer_ + pos), 1);\n           CpuFeatureScope scope(&patcher, ARMv7);\n           patcher.movw(dst, target16_0);\n         } else {\n-          PatchingAssembler patcher(isolate_data(),\n+          PatchingAssembler patcher(options(),\n                                     reinterpret_cast<byte*>(buffer_ + pos), 2);\n           CpuFeatureScope scope(&patcher, ARMv7);\n           patcher.movw(dst, target16_0);\n@@ -916,12 +894,12 @@ void Assembler::target_at_put(int pos, int target_pos) {\n         uint8_t target8_1 = target16_0 >> 8;\n         uint8_t target8_2 = target16_1 & kImm8Mask;\n         if (target8_2 == 0) {\n-          PatchingAssembler patcher(isolate_data(),\n+          PatchingAssembler patcher(options(),\n                                     reinterpret_cast<byte*>(buffer_ + pos), 2);\n           patcher.mov(dst, Operand(target8_0));\n           patcher.orr(dst, dst, Operand(target8_1 << 8));\n         } else {\n-          PatchingAssembler patcher(isolate_data(),\n+          PatchingAssembler patcher(options(),\n                                     reinterpret_cast<byte*>(buffer_ + pos), 3);\n           patcher.mov(dst, Operand(target8_0));\n           patcher.orr(dst, dst, Operand(target8_1 << 8));\n@@ -931,7 +909,7 @@ void Assembler::target_at_put(int pos, int target_pos) {\n     }\n     return;\n   }\n-  int imm26 = target_pos - (pos + kPcLoadDelta);\n+  int imm26 = target_pos - (pos + Instruction::kPcLoadDelta);\n   DCHECK_EQ(5 * B25, instr & 7 * B25);  // b, bl, or blx imm24\n   if (Instruction::ConditionField(instr) == kSpecialCondition) {\n     // blx uses bit 24 to encode bit 2 of imm26\n@@ -1105,9 +1083,9 @@ bool FitsShifter(uint32_t imm32, uint32_t* rotate_imm, uint32_t* immed_8,\n // space.  There is no guarantee that the relocated location can be similarly\n // encoded.\n bool MustOutputRelocInfo(RelocInfo::Mode rmode, const Assembler* assembler) {\n-  if (rmode == RelocInfo::EXTERNAL_REFERENCE) {\n-    if (assembler != nullptr && assembler->predictable_code_size()) return true;\n-    return assembler->serializer_enabled();\n+  if (RelocInfo::IsOnlyForSerializer(rmode)) {\n+    if (assembler->predictable_code_size()) return true;\n+    return assembler->options().record_reloc_info_for_serialization;\n   } else if (RelocInfo::IsNone(rmode)) {\n     return false;\n   }\n@@ -1167,19 +1145,17 @@ int Operand::InstructionsRequired(const Assembler* assembler,\n void Assembler::Move32BitImmediate(Register rd, const Operand& x,\n                                    Condition cond) {\n   if (UseMovImmediateLoad(x, this)) {\n+    CpuFeatureScope scope(this, ARMv7);\n     // UseMovImmediateLoad should return false when we need to output\n     // relocation info, since we prefer the constant pool for values that\n     // can be patched.\n     DCHECK(!x.MustOutputRelocInfo(this));\n     UseScratchRegisterScope temps(this);\n     // Re-use the destination register as a scratch if possible.\n     Register target = rd != pc ? rd : temps.Acquire();\n-    if (CpuFeatures::IsSupported(ARMv7)) {\n-      uint32_t imm32 = static_cast<uint32_t>(x.immediate());\n-      CpuFeatureScope scope(this, ARMv7);\n-      movw(target, imm32 & 0xFFFF, cond);\n-      movt(target, imm32 >> 16, cond);\n-    }\n+    uint32_t imm32 = static_cast<uint32_t>(x.immediate());\n+    movw(target, imm32 & 0xFFFF, cond);\n+    movt(target, imm32 >> 16, cond);\n     if (target.code() != rd.code()) {\n       mov(rd, target, LeaveCC, cond);\n     }\n@@ -1436,15 +1412,17 @@ int Assembler::branch_offset(Label* L) {\n   // be emitted at the pc offset recorded by the label.\n   if (!is_const_pool_blocked()) BlockConstPoolFor(1);\n \n-  return target_pos - (pc_offset() + kPcLoadDelta);\n+  return target_pos - (pc_offset() + Instruction::kPcLoadDelta);\n }\n \n \n // Branch instructions.\n-void Assembler::b(int branch_offset, Condition cond) {\n+void Assembler::b(int branch_offset, Condition cond, RelocInfo::Mode rmode) {\n+  RecordRelocInfo(rmode);\n   DCHECK_EQ(branch_offset & 3, 0);\n   int imm24 = branch_offset >> 2;\n-  CHECK(is_int24(imm24));\n+  const bool b_imm_check = is_int24(imm24);\n+  CHECK(b_imm_check);\n   emit(cond | B27 | B25 | (imm24 & kImm24Mask));\n \n   if (cond == al) {\n@@ -1453,19 +1431,21 @@ void Assembler::b(int branch_offset, Condition cond) {\n   }\n }\n \n-\n-void Assembler::bl(int branch_offset, Condition cond) {\n+void Assembler::bl(int branch_offset, Condition cond, RelocInfo::Mode rmode) {\n+  RecordRelocInfo(rmode);\n   DCHECK_EQ(branch_offset & 3, 0);\n   int imm24 = branch_offset >> 2;\n-  CHECK(is_int24(imm24));\n+  const bool bl_imm_check = is_int24(imm24);\n+  CHECK(bl_imm_check);\n   emit(cond | B27 | B25 | B24 | (imm24 & kImm24Mask));\n }\n \n void Assembler::blx(int branch_offset) {\n   DCHECK_EQ(branch_offset & 1, 0);\n   int h = ((branch_offset & 2) >> 1)*B24;\n   int imm24 = branch_offset >> 2;\n-  CHECK(is_int24(imm24));\n+  const bool blx_imm_check = is_int24(imm24);\n+  CHECK(blx_imm_check);\n   emit(kSpecialCondition | B27 | B25 | h | (imm24 & kImm24Mask));\n }\n \n@@ -5145,10 +5125,11 @@ void Assembler::dq(uint64_t value) {\n }\n \n void Assembler::RecordRelocInfo(RelocInfo::Mode rmode, intptr_t data) {\n+  if (options().disable_reloc_info_for_patching) return;\n   if (RelocInfo::IsNone(rmode) ||\n       // Don't record external references unless the heap will be serialized.\n-      (rmode == RelocInfo::EXTERNAL_REFERENCE && !serializer_enabled() &&\n-       !emit_debug_code())) {\n+      (RelocInfo::IsOnlyForSerializer(rmode) &&\n+       !options().record_reloc_info_for_serialization && !emit_debug_code())) {\n     return;\n   }\n   DCHECK_GE(buffer_space(), kMaxRelocSize);  // too late to grow buffer here\n@@ -5159,16 +5140,14 @@ void Assembler::RecordRelocInfo(RelocInfo::Mode rmode, intptr_t data) {\n void Assembler::ConstantPoolAddEntry(int position, RelocInfo::Mode rmode,\n                                      intptr_t value) {\n   DCHECK(rmode != RelocInfo::COMMENT && rmode != RelocInfo::CONST_POOL);\n-  bool sharing_ok = RelocInfo::IsNone(rmode) ||\n-                    (rmode >= RelocInfo::FIRST_SHAREABLE_RELOC_MODE);\n+  bool sharing_ok =\n+      RelocInfo::IsNone(rmode) || RelocInfo::IsShareableRelocMode(rmode);\n   DCHECK_LT(pending_32_bit_constants_.size(), kMaxNumPending32Constants);\n   if (pending_32_bit_constants_.empty()) {\n     first_const_pool_32_use_ = position;\n   }\n-  ConstantPoolEntry entry(position, value,\n-                          sharing_ok || (rmode == RelocInfo::CODE_TARGET &&\n-                                         IsCodeTargetSharingAllowed()),\n-                          rmode);\n+  ConstantPoolEntry entry(\n+      position, value, sharing_ok || (rmode == RelocInfo::CODE_TARGET), rmode);\n \n   bool shared = false;\n   if (sharing_ok) {\n@@ -5187,8 +5166,7 @@ void Assembler::ConstantPoolAddEntry(int position, RelocInfo::Mode rmode,\n \n   // Share entries if allowed and possible.\n   // Null-values are placeholders and must be ignored.\n-  if (rmode == RelocInfo::CODE_TARGET && IsCodeTargetSharingAllowed() &&\n-      value != 0) {\n+  if (rmode == RelocInfo::CODE_TARGET && value != 0) {\n     // Sharing entries here relies on canonicalized handles - without them, we\n     // will miss the optimisation opportunity.\n     Address handle_address = static_cast<Address>(value);\n@@ -5384,7 +5362,7 @@ void Assembler::CheckConstPool(bool force_emit, bool require_jump) {\n       DCHECK((IsVldrDPcImmediateOffset(instr) &&\n               GetVldrDRegisterImmediateOffset(instr) == 0));\n \n-      int delta = pc_offset() - entry.position() - kPcLoadDelta;\n+      int delta = pc_offset() - entry.position() - Instruction::kPcLoadDelta;\n       DCHECK(is_uint10(delta));\n \n       if (entry.is_merged()) {\n@@ -5415,7 +5393,7 @@ void Assembler::CheckConstPool(bool force_emit, bool require_jump) {\n       DCHECK(IsLdrPcImmediateOffset(instr) &&\n              GetLdrRegisterImmediateOffset(instr) == 0);\n \n-      int delta = pc_offset() - entry.position() - kPcLoadDelta;\n+      int delta = pc_offset() - entry.position() - Instruction::kPcLoadDelta;\n       DCHECK(is_uint12(delta));\n       // 0 is the smallest delta:\n       //   ldr rd, [pc, #0]\n@@ -5460,9 +5438,9 @@ void Assembler::CheckConstPool(bool force_emit, bool require_jump) {\n   next_buffer_check_ = pc_offset() + kCheckPoolInterval;\n }\n \n-PatchingAssembler::PatchingAssembler(IsolateData isolate_data, byte* address,\n-                                     int instructions)\n-    : Assembler(isolate_data, address, instructions * kInstrSize + kGap) {\n+PatchingAssembler::PatchingAssembler(const AssemblerOptions& options,\n+                                     byte* address, int instructions)\n+    : Assembler(options, address, instructions * kInstrSize + kGap) {\n   DCHECK_EQ(reloc_info_writer.pos(), buffer_ + buffer_size_);\n }\n "
        },
        {
            "sha": "2e71ce59e645c508d5291f8fc7544613f117a1cf",
            "filename": "deps/v8/src/arm/assembler-arm.h",
            "status": "modified",
            "additions": 36,
            "deletions": 99,
            "changes": 135,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fassembler-arm.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -397,26 +397,26 @@ enum Coprocessor {\n class Operand BASE_EMBEDDED {\n  public:\n   // immediate\n-  INLINE(explicit Operand(int32_t immediate,\n-                          RelocInfo::Mode rmode = RelocInfo::NONE));\n-  INLINE(static Operand Zero());\n-  INLINE(explicit Operand(const ExternalReference& f));\n+  V8_INLINE explicit Operand(int32_t immediate,\n+                             RelocInfo::Mode rmode = RelocInfo::NONE);\n+  V8_INLINE static Operand Zero();\n+  V8_INLINE explicit Operand(const ExternalReference& f);\n   explicit Operand(Handle<HeapObject> handle);\n-  INLINE(explicit Operand(Smi* value));\n+  V8_INLINE explicit Operand(Smi* value);\n \n   // rm\n-  INLINE(explicit Operand(Register rm));\n+  V8_INLINE explicit Operand(Register rm);\n \n   // rm <shift_op> shift_imm\n   explicit Operand(Register rm, ShiftOp shift_op, int shift_imm);\n-  INLINE(static Operand SmiUntag(Register rm)) {\n+  V8_INLINE static Operand SmiUntag(Register rm) {\n     return Operand(rm, ASR, kSmiTagSize);\n   }\n-  INLINE(static Operand PointerOffsetFromSmiKey(Register key)) {\n+  V8_INLINE static Operand PointerOffsetFromSmiKey(Register key) {\n     STATIC_ASSERT(kSmiTag == 0 && kSmiTagSize < kPointerSizeLog2);\n     return Operand(key, LSL, kPointerSizeLog2 - kSmiTagSize);\n   }\n-  INLINE(static Operand DoubleOffsetFromSmiKey(Register key)) {\n+  V8_INLINE static Operand DoubleOffsetFromSmiKey(Register key) {\n     STATIC_ASSERT(kSmiTag == 0 && kSmiTagSize < kDoubleSizeLog2);\n     return Operand(key, LSL, kDoubleSizeLog2 - kSmiTagSize);\n   }\n@@ -519,9 +519,9 @@ class MemOperand BASE_EMBEDDED {\n   // [rn], +/- rm <shift_op> shift_imm     PostIndex/NegPostIndex\n   explicit MemOperand(Register rn, Register rm,\n                       ShiftOp shift_op, int shift_imm, AddrMode am = Offset);\n-  INLINE(static MemOperand PointerAddressFromSmiKey(Register array,\n-                                                    Register key,\n-                                                    AddrMode am = Offset)) {\n+  V8_INLINE static MemOperand PointerAddressFromSmiKey(Register array,\n+                                                       Register key,\n+                                                       AddrMode am = Offset) {\n     STATIC_ASSERT(kSmiTag == 0 && kSmiTagSize < kPointerSizeLog2);\n     return MemOperand(array, key, LSL, kPointerSizeLog2 - kSmiTagSize, am);\n   }\n@@ -628,9 +628,7 @@ class Assembler : public AssemblerBase {\n   // buffer for code generation and assumes its size to be buffer_size. If the\n   // buffer is too small, a fatal error occurs. No deallocation of the buffer is\n   // done upon destruction of the assembler.\n-  Assembler(Isolate* isolate, void* buffer, int buffer_size)\n-      : Assembler(IsolateData(isolate), buffer, buffer_size) {}\n-  Assembler(IsolateData isolate_data, void* buffer, int buffer_size);\n+  Assembler(const AssemblerOptions& options, void* buffer, int buffer_size);\n   virtual ~Assembler();\n \n   // GetCode emits any pending (non-emitted) code and fills the descriptor\n@@ -662,27 +660,27 @@ class Assembler : public AssemblerBase {\n \n   // Returns true if the given pc address is the start of a constant pool load\n   // instruction sequence.\n-  INLINE(static bool is_constant_pool_load(Address pc));\n+  V8_INLINE static bool is_constant_pool_load(Address pc);\n \n   // Return the address in the constant pool of the code target address used by\n   // the branch/call instruction at pc, or the object in a mov.\n-  INLINE(static Address constant_pool_entry_address(Address pc,\n-                                                    Address constant_pool));\n+  V8_INLINE static Address constant_pool_entry_address(Address pc,\n+                                                       Address constant_pool);\n \n   // Read/Modify the code target address in the branch/call instruction at pc.\n   // The isolate argument is unused (and may be nullptr) when skipping flushing.\n-  INLINE(static Address target_address_at(Address pc, Address constant_pool));\n-  INLINE(static void set_target_address_at(\n+  V8_INLINE static Address target_address_at(Address pc, Address constant_pool);\n+  V8_INLINE static void set_target_address_at(\n       Address pc, Address constant_pool, Address target,\n-      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED));\n+      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n \n   // Return the code target address at a call site from the return address\n   // of that call in the instruction stream.\n-  INLINE(static Address target_address_from_return_address(Address pc));\n+  V8_INLINE static Address target_address_from_return_address(Address pc);\n \n   // Given the address of the beginning of a call, return the address\n   // in the instruction stream that the call will return from.\n-  INLINE(static Address return_address_from_call_start(Address pc));\n+  V8_INLINE static Address return_address_from_call_start(Address pc);\n \n   // This sets the branch destination (which is in the constant pool on ARM).\n   // This is for calls and branches within generated code.\n@@ -705,9 +703,6 @@ class Assembler : public AssemblerBase {\n   // Size of an instruction.\n   static constexpr int kInstrSize = sizeof(Instr);\n \n-  // Difference between address of current opcode and value read from pc\n-  // register.\n-  static constexpr int kPcLoadDelta = 8;\n   RegList* GetScratchRegisterList() { return &scratch_register_list_; }\n   VfpRegList* GetScratchVfpRegisterList() {\n     return &scratch_vfp_register_list_;\n@@ -727,8 +722,10 @@ class Assembler : public AssemblerBase {\n   void CodeTargetAlign();\n \n   // Branch instructions\n-  void b(int branch_offset, Condition cond = al);\n-  void bl(int branch_offset, Condition cond = al);\n+  void b(int branch_offset, Condition cond = al,\n+         RelocInfo::Mode rmode = RelocInfo::NONE);\n+  void bl(int branch_offset, Condition cond = al,\n+          RelocInfo::Mode rmode = RelocInfo::NONE);\n   void blx(int branch_offset);  // v5 and above\n   void blx(Register target, Condition cond = al);  // v5 and above\n   void bx(Register target, Condition cond = al);  // v5 and above, plus v4t\n@@ -1427,36 +1424,6 @@ class Assembler : public AssemblerBase {\n     DISALLOW_IMPLICIT_CONSTRUCTORS(BlockConstPoolScope);\n   };\n \n-  // Class for blocking sharing of code targets in constant pool.\n-  class BlockCodeTargetSharingScope {\n-   public:\n-    explicit BlockCodeTargetSharingScope(Assembler* assem) : assem_(nullptr) {\n-      Open(assem);\n-    }\n-    // This constructor does not initialize the scope. The user needs to\n-    // explicitly call Open() before using it.\n-    BlockCodeTargetSharingScope() : assem_(nullptr) {}\n-    ~BlockCodeTargetSharingScope() {\n-      Close();\n-    }\n-    void Open(Assembler* assem) {\n-      DCHECK_NULL(assem_);\n-      DCHECK_NOT_NULL(assem);\n-      assem_ = assem;\n-      assem_->StartBlockCodeTargetSharing();\n-    }\n-\n-   private:\n-    void Close() {\n-      if (assem_ != nullptr) {\n-        assem_->EndBlockCodeTargetSharing();\n-      }\n-    }\n-    Assembler* assem_;\n-\n-    DISALLOW_COPY_AND_ASSIGN(BlockCodeTargetSharingScope);\n-  };\n-\n   // Record a comment relocation entry that can be used by a disassembler.\n   // Use --code-comments to enable.\n   void RecordComment(const char* msg);\n@@ -1504,8 +1471,6 @@ class Assembler : public AssemblerBase {\n     *reinterpret_cast<Instr*>(pc) = instr;\n   }\n   static Condition GetCondition(Instr instr);\n-  static bool IsBranch(Instr instr);\n-  static int GetBranchOffset(Instr instr);\n   static bool IsLdrRegisterImmediate(Instr instr);\n   static bool IsVldrDRegisterImmediate(Instr instr);\n   static int GetLdrRegisterImmediateOffset(Instr instr);\n@@ -1579,6 +1544,13 @@ class Assembler : public AssemblerBase {\n     UNREACHABLE();\n   }\n \n+  // Move a 32-bit immediate into a register, potentially via the constant pool.\n+  void Move32BitImmediate(Register rd, const Operand& x, Condition cond = al);\n+\n+  // Get the code target object for a pc-relative call or jump.\n+  V8_INLINE Handle<Code> relative_code_target_object_handle_at(\n+      Address pc_) const;\n+\n  protected:\n   int buffer_space() const { return reloc_info_writer.pos() - pc_; }\n \n@@ -1588,20 +1560,6 @@ class Assembler : public AssemblerBase {\n   // Patch branch instruction at pos to branch to given branch target pos\n   void target_at_put(int pos, int target_pos);\n \n-  // Prevent sharing of code target constant pool entries until\n-  // EndBlockCodeTargetSharing is called. Calls to this function can be nested\n-  // but must be followed by an equal number of call to\n-  // EndBlockCodeTargetSharing.\n-  void StartBlockCodeTargetSharing() {\n-    ++code_target_sharing_blocked_nesting_;\n-  }\n-\n-  // Resume sharing of constant pool code target entries. Needs to be called\n-  // as many times as StartBlockCodeTargetSharing to have an effect.\n-  void EndBlockCodeTargetSharing() {\n-    --code_target_sharing_blocked_nesting_;\n-  }\n-\n   // Prevent contant pool emission until EndBlockConstPool is called.\n   // Calls to this function can be nested but must be followed by an equal\n   // number of call to EndBlockConstpool.\n@@ -1709,12 +1667,6 @@ class Assembler : public AssemblerBase {\n   static constexpr int kCheckPoolIntervalInst = 32;\n   static constexpr int kCheckPoolInterval = kCheckPoolIntervalInst * kInstrSize;\n \n-  // Sharing of code target entries may be blocked in some code sequences.\n-  int code_target_sharing_blocked_nesting_;\n-  bool IsCodeTargetSharingAllowed() const {\n-    return code_target_sharing_blocked_nesting_ == 0;\n-  }\n-\n   // Emission of the constant pool may be blocked in some code sequences.\n   int const_pool_blocked_nesting_;  // Block emission if this is not zero.\n   int no_const_pool_before_;  // Block emission before this pc offset.\n@@ -1730,9 +1682,6 @@ class Assembler : public AssemblerBase {\n   inline void CheckBuffer();\n   void GrowBuffer();\n \n-  // 32-bit immediate values\n-  void Move32BitImmediate(Register rd, const Operand& x, Condition cond = al);\n-\n   // Instruction generation\n   void AddrMode1(Instr instr, Register rd, Register rn, const Operand& x);\n   // Attempt to encode operand |x| for instruction |instr| and return true on\n@@ -1757,35 +1706,23 @@ class Assembler : public AssemblerBase {\n   void ConstantPoolAddEntry(int position, RelocInfo::Mode rmode,\n                             intptr_t value);\n   void ConstantPoolAddEntry(int position, Double value);\n+  void AllocateAndInstallRequestedHeapObjects(Isolate* isolate);\n \n   friend class RelocInfo;\n   friend class BlockConstPoolScope;\n-  friend class BlockCodeTargetSharingScope;\n   friend class EnsureSpace;\n   friend class UseScratchRegisterScope;\n-\n-  // The following functions help with avoiding allocations of embedded heap\n-  // objects during the code assembly phase. {RequestHeapObject} records the\n-  // need for a future heap number allocation or code stub generation. After\n-  // code assembly, {AllocateAndInstallRequestedHeapObjects} will allocate these\n-  // objects and place them where they are expected (determined by the pc offset\n-  // associated with each request). That is, for each request, it will patch the\n-  // dummy heap object handle that we emitted during code assembly with the\n-  // actual heap object handle.\n-  void RequestHeapObject(HeapObjectRequest request);\n-  void AllocateAndInstallRequestedHeapObjects(Isolate* isolate);\n-\n-  std::forward_list<HeapObjectRequest> heap_object_requests_;\n };\n \n class EnsureSpace BASE_EMBEDDED {\n  public:\n-  INLINE(explicit EnsureSpace(Assembler* assembler));\n+  V8_INLINE explicit EnsureSpace(Assembler* assembler);\n };\n \n class PatchingAssembler : public Assembler {\n  public:\n-  PatchingAssembler(IsolateData isolate_data, byte* address, int instructions);\n+  PatchingAssembler(const AssemblerOptions& options, byte* address,\n+                    int instructions);\n   ~PatchingAssembler();\n \n   void Emit(Address addr);"
        },
        {
            "sha": "26131ea305bacbdcdb44f51eb92e034c7aa17f57",
            "filename": "deps/v8/src/arm/code-stubs-arm.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 298,
            "changes": 319,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fcode-stubs-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fcode-stubs-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fcode-stubs-arm.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -30,20 +30,6 @@ namespace internal {\n \n #define __ ACCESS_MASM(masm)\n \n-void ArrayNArgumentsConstructorStub::Generate(MacroAssembler* masm) {\n-  __ lsl(r5, r0, Operand(kPointerSizeLog2));\n-  __ str(r1, MemOperand(sp, r5));\n-  __ Push(r1);\n-  __ Push(r2);\n-  __ add(r0, r0, Operand(3));\n-  __ TailCallRuntime(Runtime::kNewArray);\n-}\n-\n-void CodeStub::GenerateStubsAheadOfTime(Isolate* isolate) {\n-  CommonArrayConstructorStub::GenerateStubsAheadOfTime(isolate);\n-  StoreFastElementStub::GenerateAheadOfTime(isolate);\n-}\n-\n void JSEntryStub::Generate(MacroAssembler* masm) {\n   // r0: code entry\n   // r1: function\n@@ -216,6 +202,18 @@ void DirectCEntryStub::Generate(MacroAssembler* masm) {\n \n void DirectCEntryStub::GenerateCall(MacroAssembler* masm,\n                                     Register target) {\n+  if (FLAG_embedded_builtins) {\n+    if (masm->root_array_available() &&\n+        isolate()->ShouldLoadConstantsFromRootList()) {\n+      // This is basically an inlined version of Call(Handle<Code>) that loads\n+      // the code object into lr instead of ip.\n+      __ Move(ip, target);\n+      __ IndirectLoadConstant(lr, GetCode());\n+      __ add(lr, lr, Operand(Code::kHeaderSize - kHeapObjectTag));\n+      __ blx(lr);\n+      return;\n+    }\n+  }\n   intptr_t code =\n       reinterpret_cast<intptr_t>(GetCode().location());\n   __ Move(ip, target);\n@@ -315,280 +313,6 @@ void ProfileEntryHookStub::Generate(MacroAssembler* masm) {\n   __ ldm(ia_w, sp, kSavedRegs | pc.bit());\n }\n \n-\n-template<class T>\n-static void CreateArrayDispatch(MacroAssembler* masm,\n-                                AllocationSiteOverrideMode mode) {\n-  if (mode == DISABLE_ALLOCATION_SITES) {\n-    T stub(masm->isolate(), GetInitialFastElementsKind(), mode);\n-    __ TailCallStub(&stub);\n-  } else if (mode == DONT_OVERRIDE) {\n-    int last_index =\n-        GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);\n-    for (int i = 0; i <= last_index; ++i) {\n-      ElementsKind kind = GetFastElementsKindFromSequenceIndex(i);\n-      __ cmp(r3, Operand(kind));\n-      T stub(masm->isolate(), kind);\n-      __ TailCallStub(&stub, eq);\n-    }\n-\n-    // If we reached this point there is a problem.\n-    __ Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n-  } else {\n-    UNREACHABLE();\n-  }\n-}\n-\n-\n-static void CreateArrayDispatchOneArgument(MacroAssembler* masm,\n-                                           AllocationSiteOverrideMode mode) {\n-  // r2 - allocation site (if mode != DISABLE_ALLOCATION_SITES)\n-  // r3 - kind (if mode != DISABLE_ALLOCATION_SITES)\n-  // r0 - number of arguments\n-  // r1 - constructor?\n-  // sp[0] - last argument\n-  STATIC_ASSERT(PACKED_SMI_ELEMENTS == 0);\n-  STATIC_ASSERT(HOLEY_SMI_ELEMENTS == 1);\n-  STATIC_ASSERT(PACKED_ELEMENTS == 2);\n-  STATIC_ASSERT(HOLEY_ELEMENTS == 3);\n-  STATIC_ASSERT(PACKED_DOUBLE_ELEMENTS == 4);\n-  STATIC_ASSERT(HOLEY_DOUBLE_ELEMENTS == 5);\n-\n-  if (mode == DISABLE_ALLOCATION_SITES) {\n-    ElementsKind initial = GetInitialFastElementsKind();\n-    ElementsKind holey_initial = GetHoleyElementsKind(initial);\n-\n-    ArraySingleArgumentConstructorStub stub_holey(masm->isolate(),\n-                                                  holey_initial,\n-                                                  DISABLE_ALLOCATION_SITES);\n-    __ TailCallStub(&stub_holey);\n-  } else if (mode == DONT_OVERRIDE) {\n-    // is the low bit set? If so, we are holey and that is good.\n-    Label normal_sequence;\n-    __ tst(r3, Operand(1));\n-    __ b(ne, &normal_sequence);\n-\n-    // We are going to create a holey array, but our kind is non-holey.\n-    // Fix kind and retry (only if we have an allocation site in the slot).\n-    __ add(r3, r3, Operand(1));\n-\n-    if (FLAG_debug_code) {\n-      __ ldr(r5, FieldMemOperand(r2, 0));\n-      __ CompareRoot(r5, Heap::kAllocationSiteMapRootIndex);\n-      __ Assert(eq, AbortReason::kExpectedAllocationSite);\n-    }\n-\n-    // Save the resulting elements kind in type info. We can't just store r3\n-    // in the AllocationSite::transition_info field because elements kind is\n-    // restricted to a portion of the field...upper bits need to be left alone.\n-    STATIC_ASSERT(AllocationSite::ElementsKindBits::kShift == 0);\n-    __ ldr(r4, FieldMemOperand(\n-                   r2, AllocationSite::kTransitionInfoOrBoilerplateOffset));\n-    __ add(r4, r4, Operand(Smi::FromInt(kFastElementsKindPackedToHoley)));\n-    __ str(r4, FieldMemOperand(\n-                   r2, AllocationSite::kTransitionInfoOrBoilerplateOffset));\n-\n-    __ bind(&normal_sequence);\n-    int last_index =\n-        GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);\n-    for (int i = 0; i <= last_index; ++i) {\n-      ElementsKind kind = GetFastElementsKindFromSequenceIndex(i);\n-      __ cmp(r3, Operand(kind));\n-      ArraySingleArgumentConstructorStub stub(masm->isolate(), kind);\n-      __ TailCallStub(&stub, eq);\n-    }\n-\n-    // If we reached this point there is a problem.\n-    __ Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n-  } else {\n-    UNREACHABLE();\n-  }\n-}\n-\n-\n-template<class T>\n-static void ArrayConstructorStubAheadOfTimeHelper(Isolate* isolate) {\n-  int to_index =\n-      GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);\n-  for (int i = 0; i <= to_index; ++i) {\n-    ElementsKind kind = GetFastElementsKindFromSequenceIndex(i);\n-    T stub(isolate, kind);\n-    stub.GetCode();\n-    if (AllocationSite::ShouldTrack(kind)) {\n-      T stub1(isolate, kind, DISABLE_ALLOCATION_SITES);\n-      stub1.GetCode();\n-    }\n-  }\n-}\n-\n-void CommonArrayConstructorStub::GenerateStubsAheadOfTime(Isolate* isolate) {\n-  ArrayConstructorStubAheadOfTimeHelper<ArrayNoArgumentConstructorStub>(\n-      isolate);\n-  ArrayConstructorStubAheadOfTimeHelper<ArraySingleArgumentConstructorStub>(\n-      isolate);\n-  ArrayNArgumentsConstructorStub stub(isolate);\n-  stub.GetCode();\n-  ElementsKind kinds[2] = {PACKED_ELEMENTS, HOLEY_ELEMENTS};\n-  for (int i = 0; i < 2; i++) {\n-    // For internal arrays we only need a few things\n-    InternalArrayNoArgumentConstructorStub stubh1(isolate, kinds[i]);\n-    stubh1.GetCode();\n-    InternalArraySingleArgumentConstructorStub stubh2(isolate, kinds[i]);\n-    stubh2.GetCode();\n-  }\n-}\n-\n-\n-void ArrayConstructorStub::GenerateDispatchToArrayStub(\n-    MacroAssembler* masm,\n-    AllocationSiteOverrideMode mode) {\n-  Label not_zero_case, not_one_case;\n-  __ tst(r0, r0);\n-  __ b(ne, &not_zero_case);\n-  CreateArrayDispatch<ArrayNoArgumentConstructorStub>(masm, mode);\n-\n-  __ bind(&not_zero_case);\n-  __ cmp(r0, Operand(1));\n-  __ b(gt, &not_one_case);\n-  CreateArrayDispatchOneArgument(masm, mode);\n-\n-  __ bind(&not_one_case);\n-  ArrayNArgumentsConstructorStub stub(masm->isolate());\n-  __ TailCallStub(&stub);\n-}\n-\n-\n-void ArrayConstructorStub::Generate(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- r0 : argc (only if argument_count() == ANY)\n-  //  -- r1 : constructor\n-  //  -- r2 : AllocationSite or undefined\n-  //  -- r3 : new target\n-  //  -- sp[0] : return address\n-  //  -- sp[4] : last argument\n-  // -----------------------------------\n-\n-  if (FLAG_debug_code) {\n-    // The array construct code is only set for the global and natives\n-    // builtin Array functions which always have maps.\n-\n-    // Initial map for the builtin Array function should be a map.\n-    __ ldr(r4, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n-    // Will both indicate a nullptr and a Smi.\n-    __ tst(r4, Operand(kSmiTagMask));\n-    __ Assert(ne, AbortReason::kUnexpectedInitialMapForArrayFunction);\n-    __ CompareObjectType(r4, r4, r5, MAP_TYPE);\n-    __ Assert(eq, AbortReason::kUnexpectedInitialMapForArrayFunction);\n-\n-    // We should either have undefined in r2 or a valid AllocationSite\n-    __ AssertUndefinedOrAllocationSite(r2, r4);\n-  }\n-\n-  // Enter the context of the Array function.\n-  __ ldr(cp, FieldMemOperand(r1, JSFunction::kContextOffset));\n-\n-  Label subclassing;\n-  __ cmp(r3, r1);\n-  __ b(ne, &subclassing);\n-\n-  Label no_info;\n-  // Get the elements kind and case on that.\n-  __ CompareRoot(r2, Heap::kUndefinedValueRootIndex);\n-  __ b(eq, &no_info);\n-\n-  __ ldr(r3, FieldMemOperand(\n-                 r2, AllocationSite::kTransitionInfoOrBoilerplateOffset));\n-  __ SmiUntag(r3);\n-  STATIC_ASSERT(AllocationSite::ElementsKindBits::kShift == 0);\n-  __ and_(r3, r3, Operand(AllocationSite::ElementsKindBits::kMask));\n-  GenerateDispatchToArrayStub(masm, DONT_OVERRIDE);\n-\n-  __ bind(&no_info);\n-  GenerateDispatchToArrayStub(masm, DISABLE_ALLOCATION_SITES);\n-\n-  __ bind(&subclassing);\n-  __ str(r1, MemOperand(sp, r0, LSL, kPointerSizeLog2));\n-  __ add(r0, r0, Operand(3));\n-  __ Push(r3, r2);\n-  __ JumpToExternalReference(ExternalReference::Create(Runtime::kNewArray));\n-}\n-\n-\n-void InternalArrayConstructorStub::GenerateCase(\n-    MacroAssembler* masm, ElementsKind kind) {\n-  __ cmp(r0, Operand(1));\n-\n-  InternalArrayNoArgumentConstructorStub stub0(isolate(), kind);\n-  __ TailCallStub(&stub0, lo);\n-\n-  ArrayNArgumentsConstructorStub stubN(isolate());\n-  __ TailCallStub(&stubN, hi);\n-\n-  if (IsFastPackedElementsKind(kind)) {\n-    // We might need to create a holey array\n-    // look at the first argument\n-    __ ldr(r3, MemOperand(sp, 0));\n-    __ cmp(r3, Operand::Zero());\n-\n-    InternalArraySingleArgumentConstructorStub\n-        stub1_holey(isolate(), GetHoleyElementsKind(kind));\n-    __ TailCallStub(&stub1_holey, ne);\n-  }\n-\n-  InternalArraySingleArgumentConstructorStub stub1(isolate(), kind);\n-  __ TailCallStub(&stub1);\n-}\n-\n-\n-void InternalArrayConstructorStub::Generate(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- r0 : argc\n-  //  -- r1 : constructor\n-  //  -- sp[0] : return address\n-  //  -- sp[4] : last argument\n-  // -----------------------------------\n-\n-  if (FLAG_debug_code) {\n-    // The array construct code is only set for the global and natives\n-    // builtin Array functions which always have maps.\n-\n-    // Initial map for the builtin Array function should be a map.\n-    __ ldr(r3, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n-    // Will both indicate a nullptr and a Smi.\n-    __ tst(r3, Operand(kSmiTagMask));\n-    __ Assert(ne, AbortReason::kUnexpectedInitialMapForArrayFunction);\n-    __ CompareObjectType(r3, r3, r4, MAP_TYPE);\n-    __ Assert(eq, AbortReason::kUnexpectedInitialMapForArrayFunction);\n-  }\n-\n-  // Figure out the right elements kind\n-  __ ldr(r3, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n-  // Load the map's \"bit field 2\" into |result|. We only need the first byte,\n-  // but the following bit field extraction takes care of that anyway.\n-  __ ldr(r3, FieldMemOperand(r3, Map::kBitField2Offset));\n-  // Retrieve elements_kind from bit field 2.\n-  __ DecodeField<Map::ElementsKindBits>(r3);\n-\n-  if (FLAG_debug_code) {\n-    Label done;\n-    __ cmp(r3, Operand(PACKED_ELEMENTS));\n-    __ b(eq, &done);\n-    __ cmp(r3, Operand(HOLEY_ELEMENTS));\n-    __ Assert(\n-        eq,\n-        AbortReason::kInvalidElementsKindForInternalArrayOrInternalPackedArray);\n-    __ bind(&done);\n-  }\n-\n-  Label fast_elements_case;\n-  __ cmp(r3, Operand(PACKED_ELEMENTS));\n-  __ b(eq, &fast_elements_case);\n-  GenerateCase(masm, HOLEY_ELEMENTS);\n-\n-  __ bind(&fast_elements_case);\n-  GenerateCase(masm, PACKED_ELEMENTS);\n-}\n-\n static int AddressOffset(ExternalReference ref0, ExternalReference ref1) {\n   return ref0.address() - ref1.address();\n }\n@@ -617,21 +341,21 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,\n \n   Label profiler_disabled;\n   Label end_profiler_check;\n-  __ mov(r9, Operand(ExternalReference::is_profiling_address(isolate)));\n+  __ Move(r9, ExternalReference::is_profiling_address(isolate));\n   __ ldrb(r9, MemOperand(r9, 0));\n   __ cmp(r9, Operand(0));\n   __ b(eq, &profiler_disabled);\n \n   // Additional parameter is the address of the actual callback.\n-  __ mov(r3, Operand(thunk_ref));\n+  __ Move(r3, thunk_ref);\n   __ jmp(&end_profiler_check);\n \n   __ bind(&profiler_disabled);\n   __ Move(r3, function_address);\n   __ bind(&end_profiler_check);\n \n   // Allocate HandleScope in callee-save registers.\n-  __ mov(r9, Operand(next_address));\n+  __ Move(r9, next_address);\n   __ ldr(r4, MemOperand(r9, kNextOffset));\n   __ ldr(r5, MemOperand(r9, kLimitOffset));\n   __ ldr(r6, MemOperand(r9, kLevelOffset));\n@@ -642,7 +366,7 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,\n     FrameScope frame(masm, StackFrame::MANUAL);\n     __ PushSafepointRegisters();\n     __ PrepareCallCFunction(1);\n-    __ mov(r0, Operand(ExternalReference::isolate_address(isolate)));\n+    __ Move(r0, ExternalReference::isolate_address(isolate));\n     __ CallCFunction(ExternalReference::log_enter_external_function(), 1);\n     __ PopSafepointRegisters();\n   }\n@@ -657,7 +381,7 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,\n     FrameScope frame(masm, StackFrame::MANUAL);\n     __ PushSafepointRegisters();\n     __ PrepareCallCFunction(1);\n-    __ mov(r0, Operand(ExternalReference::isolate_address(isolate)));\n+    __ Move(r0, ExternalReference::isolate_address(isolate));\n     __ CallCFunction(ExternalReference::log_leave_external_function(), 1);\n     __ PopSafepointRegisters();\n   }\n@@ -696,7 +420,7 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,\n \n   // Check if the function scheduled an exception.\n   __ LoadRoot(r4, Heap::kTheHoleValueRootIndex);\n-  __ mov(r6, Operand(ExternalReference::scheduled_exception_address(isolate)));\n+  __ Move(r6, ExternalReference::scheduled_exception_address(isolate));\n   __ ldr(r5, MemOperand(r6));\n   __ cmp(r4, r5);\n   __ b(ne, &promote_scheduled_exception);\n@@ -712,7 +436,7 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,\n   __ str(r5, MemOperand(r9, kLimitOffset));\n   __ mov(r4, r0);\n   __ PrepareCallCFunction(1);\n-  __ mov(r0, Operand(ExternalReference::isolate_address(isolate)));\n+  __ Move(r0, ExternalReference::isolate_address(isolate));\n   __ CallCFunction(ExternalReference::delete_handle_scope_extensions(), 1);\n   __ mov(r0, r4);\n   __ jmp(&leave_exit_frame);\n@@ -759,8 +483,7 @@ void CallApiCallbackStub::Generate(MacroAssembler* masm) {\n   // return value default\n   __ push(scratch0);\n   // isolate\n-  __ mov(scratch1,\n-         Operand(ExternalReference::isolate_address(masm->isolate())));\n+  __ Move(scratch1, ExternalReference::isolate_address(masm->isolate()));\n   __ push(scratch1);\n   // holder\n   __ push(holder);\n@@ -829,7 +552,7 @@ void CallApiGetterStub::Generate(MacroAssembler* masm) {\n   __ push(scratch);\n   __ LoadRoot(scratch, Heap::kUndefinedValueRootIndex);\n   __ Push(scratch, scratch);\n-  __ mov(scratch, Operand(ExternalReference::isolate_address(isolate())));\n+  __ Move(scratch, ExternalReference::isolate_address(isolate()));\n   __ Push(scratch, holder);\n   __ Push(Smi::kZero);  // should_throw_on_error -> false\n   __ ldr(scratch, FieldMemOperand(callback, AccessorInfo::kNameOffset));"
        },
        {
            "sha": "1d041e75be2d1ceaccc8b0d3e4112ae4f7837557",
            "filename": "deps/v8/src/arm/constants-arm.h",
            "status": "modified",
            "additions": 40,
            "deletions": 9,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fconstants-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fconstants-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fconstants-arm.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -11,6 +11,7 @@\n #include \"src/base/macros.h\"\n #include \"src/boxed-float.h\"\n #include \"src/globals.h\"\n+#include \"src/utils.h\"\n \n // ARM EABI is required.\n #if defined(__arm__) && !defined(__ARM_EABI__)\n@@ -51,6 +52,12 @@ const int kNoRegister = -1;\n const int kLdrMaxReachBits = 12;\n const int kVldrMaxReachBits = 10;\n \n+// Actual value of root register is offset from the root array's start\n+// to take advantage of negative displacement values. Loads allow a uint12\n+// value with a separate sign bit (range [-4095, +4095]), so the first root\n+// is still addressable with a single load instruction.\n+constexpr int kRootRegisterBias = 4095;\n+\n // -----------------------------------------------------------------------------\n // Conditions.\n \n@@ -462,15 +469,19 @@ class Instruction {\n     kPCReadOffset = 8\n   };\n \n-  // Helper macro to define static accessors.\n-  // We use the cast to char* trick to bypass the strict anti-aliasing rules.\n-  #define DECLARE_STATIC_TYPED_ACCESSOR(return_type, Name)                     \\\n-    static inline return_type Name(Instr instr) {                              \\\n-      char* temp = reinterpret_cast<char*>(&instr);                            \\\n-      return reinterpret_cast<Instruction*>(temp)->Name();                     \\\n-    }\n+  // Difference between address of current opcode and value read from pc\n+  // register.\n+  static constexpr int kPcLoadDelta = 8;\n \n-  #define DECLARE_STATIC_ACCESSOR(Name) DECLARE_STATIC_TYPED_ACCESSOR(int, Name)\n+// Helper macro to define static accessors.\n+// We use the cast to char* trick to bypass the strict anti-aliasing rules.\n+#define DECLARE_STATIC_TYPED_ACCESSOR(return_type, Name) \\\n+  static inline return_type Name(Instr instr) {          \\\n+    char* temp = reinterpret_cast<char*>(&instr);        \\\n+    return reinterpret_cast<Instruction*>(temp)->Name(); \\\n+  }\n+\n+#define DECLARE_STATIC_ACCESSOR(Name) DECLARE_STATIC_TYPED_ACCESSOR(int, Name)\n \n   // Get the raw instruction bits.\n   inline Instr InstructionBits() const {\n@@ -624,7 +635,25 @@ class Instruction {\n \n   // Fields used in Branch instructions\n   inline int LinkValue() const { return Bit(24); }\n-  inline int SImmed24Value() const { return ((InstructionBits() << 8) >> 8); }\n+  inline int SImmed24Value() const {\n+    return signed_bitextract_32(23, 0, InstructionBits());\n+  }\n+\n+  bool IsBranch() { return Bit(27) == 1 && Bit(25) == 1; }\n+\n+  int GetBranchOffset() {\n+    DCHECK(IsBranch());\n+    return SImmed24Value() * kInstrSize;\n+  }\n+\n+  void SetBranchOffset(int32_t branch_offset) {\n+    DCHECK(IsBranch());\n+    DCHECK_EQ(branch_offset % kInstrSize, 0);\n+    int32_t new_imm24 = branch_offset / kInstrSize;\n+    CHECK(is_int24(new_imm24));\n+    SetInstructionBits((InstructionBits() & ~(kImm24Mask)) |\n+                       (new_imm24 & kImm24Mask));\n+  }\n \n   // Fields used in Software interrupt instructions\n   inline SoftwareInterruptCodes SvcValue() const {\n@@ -729,6 +758,8 @@ class VFPRegisters {\n   static const char* names_[kNumVFPRegisters];\n };\n \n+// Relative jumps on ARM can address ±32 MB.\n+constexpr size_t kMaxPCRelativeCodeRangeInMB = 32;\n \n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "032f610edcead271197ffd8d9dcd9fa8a38a568b",
            "filename": "deps/v8/src/arm/deoptimizer-arm.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fdeoptimizer-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fdeoptimizer-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fdeoptimizer-arm.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -86,7 +86,7 @@ void Deoptimizer::TableEntryGenerator::Generate() {\n   __ JumpIfSmi(r1, &context_check);\n   __ ldr(r0, MemOperand(fp, JavaScriptFrameConstants::kFunctionOffset));\n   __ bind(&context_check);\n-  __ mov(r1, Operand(type()));  // bailout type,\n+  __ mov(r1, Operand(static_cast<int>(deopt_kind())));\n   // r2: bailout id already loaded.\n   // r3: code address or 0 already loaded.\n   __ str(r4, MemOperand(sp, 0 * kPointerSize));  // Fp-to-sp delta."
        },
        {
            "sha": "73e171009dc2f4c46e83942854556e2002455cc4",
            "filename": "deps/v8/src/arm/frame-constants-arm.h",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fframe-constants-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fframe-constants-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fframe-constants-arm.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -5,6 +5,9 @@\n #ifndef V8_ARM_FRAME_CONSTANTS_ARM_H_\n #define V8_ARM_FRAME_CONSTANTS_ARM_H_\n \n+#include \"src/base/macros.h\"\n+#include \"src/frame-constants.h\"\n+\n namespace v8 {\n namespace internal {\n \n@@ -30,6 +33,19 @@ class ExitFrameConstants : public TypedFrameConstants {\n   static constexpr int kCallerSPDisplacement = 2 * kPointerSize;\n };\n \n+class WasmCompileLazyFrameConstants : public TypedFrameConstants {\n+ public:\n+  static constexpr int kNumberOfSavedGpParamRegs = 4;\n+  static constexpr int kNumberOfSavedFpParamRegs = 8;\n+\n+  // FP-relative.\n+  static constexpr int kWasmInstanceOffset = TYPED_FRAME_PUSHED_VALUE_OFFSET(0);\n+  static constexpr int kFixedFrameSizeFromFp =\n+      TypedFrameConstants::kFixedFrameSizeFromFp +\n+      kNumberOfSavedGpParamRegs * kPointerSize +\n+      kNumberOfSavedFpParamRegs * kDoubleSize;\n+};\n+\n class JavaScriptFrameConstants : public AllStatic {\n  public:\n   // FP-relative."
        },
        {
            "sha": "b96826264a0f667bbc219b5ca4177ebe31cd2f2d",
            "filename": "deps/v8/src/arm/interface-descriptors-arm.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 74,
            "changes": 93,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Finterface-descriptors-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Finterface-descriptors-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Finterface-descriptors-arm.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \"src/arm/interface-descriptors-arm.h\"\n-\n #if V8_TARGET_ARCH_ARM\n \n #include \"src/interface-descriptors.h\"\n@@ -59,13 +57,6 @@ const Register StoreTransitionDescriptor::MapRegister() { return r5; }\n const Register ApiGetterDescriptor::HolderRegister() { return r0; }\n const Register ApiGetterDescriptor::CallbackRegister() { return r3; }\n \n-const Register MathPowTaggedDescriptor::exponent() { return r2; }\n-\n-const Register MathPowIntegerDescriptor::exponent() {\n-  return MathPowTaggedDescriptor::exponent();\n-}\n-\n-\n const Register GrowArrayElementsDescriptor::ObjectRegister() { return r0; }\n const Register GrowArrayElementsDescriptor::KeyRegister() { return r3; }\n \n@@ -179,66 +170,15 @@ void ConstructStubDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n-\n-void ConstructTrampolineDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // r0 : number of arguments\n-  // r1 : the target to call\n-  // r3 : the new target\n-  Register registers[] = {r1, r3, r0};\n-  data->InitializePlatformSpecific(arraysize(registers), registers);\n-}\n-\n-\n-void TransitionElementsKindDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  Register registers[] = {r0, r1};\n-  data->InitializePlatformSpecific(arraysize(registers), registers);\n-}\n-\n-void AbortJSDescriptor::InitializePlatformSpecific(\n+void AbortDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n   Register registers[] = {r1};\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n void AllocateHeapNumberDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n-  data->InitializePlatformSpecific(0, nullptr, nullptr);\n-}\n-\n-void ArrayConstructorDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // kTarget, kNewTarget, kActualArgumentsCount, kAllocationSite\n-  Register registers[] = {r1, r3, r0, r2};\n-  data->InitializePlatformSpecific(arraysize(registers), registers, nullptr);\n-}\n-\n-void ArrayNoArgumentConstructorDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // register state\n-  // r0 -- number of arguments\n-  // r1 -- function\n-  // r2 -- allocation site with elements kind\n-  Register registers[] = {r1, r2, r0};\n-  data->InitializePlatformSpecific(arraysize(registers), registers, nullptr);\n-}\n-\n-void ArraySingleArgumentConstructorDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // register state\n-  // r0 -- number of arguments\n-  // r1 -- function\n-  // r2 -- allocation site with elements kind\n-  Register registers[] = {r1, r2, r0};\n-  data->InitializePlatformSpecific(arraysize(registers), registers, nullptr);\n-}\n-\n-void ArrayNArgumentsConstructorDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // stack param count needs (constructor pointer, and single argument)\n-  Register registers[] = {r1, r2, r0};\n-  data->InitializePlatformSpecific(arraysize(registers), registers);\n+  data->InitializePlatformSpecific(0, nullptr);\n }\n \n void CompareDescriptor::InitializePlatformSpecific(\n@@ -247,7 +187,6 @@ void CompareDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n-\n void BinaryOpDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n   Register registers[] = {r1, r0};\n@@ -256,32 +195,24 @@ void BinaryOpDescriptor::InitializePlatformSpecific(\n \n void ArgumentAdaptorDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n-  static PlatformInterfaceDescriptor default_descriptor =\n-      PlatformInterfaceDescriptor(CAN_INLINE_TARGET_ADDRESS);\n-\n   Register registers[] = {\n       r1,  // JSFunction\n       r3,  // the new target\n       r0,  // actual number of arguments\n       r2,  // expected number of arguments\n   };\n-  data->InitializePlatformSpecific(arraysize(registers), registers,\n-                                   &default_descriptor);\n+  data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n void ApiCallbackDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n-  static PlatformInterfaceDescriptor default_descriptor =\n-      PlatformInterfaceDescriptor(CAN_INLINE_TARGET_ADDRESS);\n-\n   Register registers[] = {\n       JavaScriptFrame::context_register(),  // callee context\n       r4,                                   // call_data\n       r2,                                   // holder\n       r1,                                   // api_function_address\n   };\n-  data->InitializePlatformSpecific(arraysize(registers), registers,\n-                                   &default_descriptor);\n+  data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n void InterpreterDispatchDescriptor::InitializePlatformSpecific(\n@@ -314,7 +245,9 @@ void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n-void InterpreterCEntryDescriptor::InitializePlatformSpecific(\n+namespace {\n+\n+void InterpreterCEntryDescriptor_InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n   Register registers[] = {\n       r0,  // argument count (argc)\n@@ -324,6 +257,18 @@ void InterpreterCEntryDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n+}  // namespace\n+\n+void InterpreterCEntry1Descriptor::InitializePlatformSpecific(\n+    CallInterfaceDescriptorData* data) {\n+  InterpreterCEntryDescriptor_InitializePlatformSpecific(data);\n+}\n+\n+void InterpreterCEntry2Descriptor::InitializePlatformSpecific(\n+    CallInterfaceDescriptorData* data) {\n+  InterpreterCEntryDescriptor_InitializePlatformSpecific(data);\n+}\n+\n void ResumeGeneratorDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n   Register registers[] = {"
        },
        {
            "sha": "a64927924e88009401b182b53a49f1f2b2ec17e1",
            "filename": "deps/v8/src/arm/interface-descriptors-arm.h",
            "status": "removed",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Farm%2Finterface-descriptors-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Farm%2Finterface-descriptors-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Finterface-descriptors-arm.h?ref=12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342",
            "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 the V8 project authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#ifndef V8_ARM_INTERFACE_DESCRIPTORS_ARM_H_\n-#define V8_ARM_INTERFACE_DESCRIPTORS_ARM_H_\n-\n-#include \"src/interface-descriptors.h\"\n-\n-namespace v8 {\n-namespace internal {\n-\n-class PlatformInterfaceDescriptor {\n- public:\n-  explicit PlatformInterfaceDescriptor(TargetAddressStorageMode storage_mode)\n-      : storage_mode_(storage_mode) {}\n-\n-  TargetAddressStorageMode storage_mode() { return storage_mode_; }\n-\n- private:\n-  TargetAddressStorageMode storage_mode_;\n-};\n-}  // namespace internal\n-}  // namespace v8\n-\n-#endif  // V8_ARM_INTERFACE_DESCRIPTORS_ARM_H_"
        },
        {
            "sha": "d02766791bb32de7597b5cf6d1545ee9afa29216",
            "filename": "deps/v8/src/arm/macro-assembler-arm.cc",
            "status": "modified",
            "additions": 126,
            "deletions": 128,
            "changes": 254,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -11,7 +11,6 @@\n #include \"src/base/division-by-constant.h\"\n #include \"src/base/utils/random-number-generator.h\"\n #include \"src/bootstrapper.h\"\n-#include \"src/builtins/constants-table-builder.h\"\n #include \"src/callable.h\"\n #include \"src/code-factory.h\"\n #include \"src/code-stubs.h\"\n@@ -24,16 +23,17 @@\n #include \"src/objects-inl.h\"\n #include \"src/register-configuration.h\"\n #include \"src/runtime/runtime.h\"\n-#include \"src/snapshot/serializer-common.h\"\n+#include \"src/snapshot/snapshot.h\"\n \n #include \"src/arm/macro-assembler-arm.h\"\n \n namespace v8 {\n namespace internal {\n \n-MacroAssembler::MacroAssembler(Isolate* isolate, void* buffer, int size,\n-                               CodeObjectRequired create_code_object)\n-    : TurboAssembler(isolate, buffer, size, create_code_object) {\n+MacroAssembler::MacroAssembler(Isolate* isolate,\n+                               const AssemblerOptions& options, void* buffer,\n+                               int size, CodeObjectRequired create_code_object)\n+    : TurboAssembler(isolate, options, buffer, size, create_code_object) {\n   if (create_code_object == CodeObjectRequired::kYes) {\n     // Unlike TurboAssembler, which can be used off the main thread and may not\n     // allocate, macro assembler creates its own copy of the self-reference\n@@ -45,15 +45,6 @@ MacroAssembler::MacroAssembler(Isolate* isolate, void* buffer, int size,\n   }\n }\n \n-TurboAssembler::TurboAssembler(Isolate* isolate, void* buffer, int buffer_size,\n-                               CodeObjectRequired create_code_object)\n-    : Assembler(isolate, buffer, buffer_size), isolate_(isolate) {\n-  if (create_code_object == CodeObjectRequired::kYes) {\n-    code_object_ = Handle<HeapObject>::New(\n-        isolate->heap()->self_reference_marker(), isolate);\n-  }\n-}\n-\n int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,\n                                                     Register exclusion1,\n                                                     Register exclusion2,\n@@ -135,33 +126,19 @@ int TurboAssembler::PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,\n   return bytes;\n }\n \n-#ifdef V8_EMBEDDED_BUILTINS\n-void TurboAssembler::LookupConstant(Register destination,\n-                                    Handle<Object> object) {\n-  CHECK(isolate()->ShouldLoadConstantsFromRootList());\n-  CHECK(root_array_available_);\n-\n-  // Ensure the given object is in the builtins constants table and fetch its\n-  // index.\n-  BuiltinsConstantsTableBuilder* builder =\n-      isolate()->builtins_constants_table_builder();\n-  uint32_t index = builder->AddObject(object);\n-\n-  // TODO(jgruber): Load builtins from the builtins table.\n-  // TODO(jgruber): Ensure that code generation can recognize constant targets\n-  // in kArchCallCodeObject.\n-\n+void TurboAssembler::LoadFromConstantsTable(Register destination,\n+                                            int constant_index) {\n   DCHECK(isolate()->heap()->RootCanBeTreatedAsConstant(\n       Heap::kBuiltinsConstantsTableRootIndex));\n \n-  // The ldr call below could end up clobbering the destination register when\n-  // the offset does not fit into 12 bits (and thus needs to be loaded from the\n-  // constant pool). In that case, we need to be extra-careful and temporarily\n-  // use another register as the target.\n+  // The ldr call below could end up clobbering ip when the offset does not fit\n+  // into 12 bits (and thus needs to be loaded from the constant pool). In that\n+  // case, we need to be extra-careful and temporarily use another register as\n+  // the target.\n \n   const uint32_t offset =\n-      FixedArray::kHeaderSize + index * kPointerSize - kHeapObjectTag;\n-  const bool could_clobber_ip = !is_uint12(offset) && destination == ip;\n+      FixedArray::kHeaderSize + constant_index * kPointerSize - kHeapObjectTag;\n+  const bool could_clobber_ip = !is_uint12(offset);\n \n   Register reg = destination;\n   if (could_clobber_ip) {\n@@ -178,30 +155,18 @@ void TurboAssembler::LookupConstant(Register destination,\n   }\n }\n \n-void TurboAssembler::LookupExternalReference(Register destination,\n-                                             ExternalReference reference) {\n-  CHECK(reference.address() !=\n-        ExternalReference::roots_array_start(isolate()).address());\n-  CHECK(isolate()->ShouldLoadConstantsFromRootList());\n-  CHECK(root_array_available_);\n-\n-  // Encode as an index into the external reference table stored on the isolate.\n-\n-  ExternalReferenceEncoder encoder(isolate());\n-  ExternalReferenceEncoder::Value v = encoder.Encode(reference.address());\n-  CHECK(!v.is_from_api());\n-  uint32_t index = v.index();\n-\n-  // Generate code to load from the external reference table.\n-\n-  int32_t roots_to_external_reference_offset =\n-      Heap::roots_to_external_reference_table_offset() +\n-      ExternalReferenceTable::OffsetOfEntry(index);\n+void TurboAssembler::LoadRootRelative(Register destination, int32_t offset) {\n+  ldr(destination, MemOperand(kRootRegister, offset));\n+}\n \n-  ldr(destination,\n-      MemOperand(kRootRegister, roots_to_external_reference_offset));\n+void TurboAssembler::LoadRootRegisterOffset(Register destination,\n+                                            intptr_t offset) {\n+  if (offset == 0) {\n+    Move(destination, kRootRegister);\n+  } else {\n+    add(destination, kRootRegister, Operand(offset));\n+  }\n }\n-#endif  // V8_EMBEDDED_BUILTINS\n \n void TurboAssembler::Jump(Register target, Condition cond) { bx(target, cond); }\n \n@@ -220,16 +185,36 @@ void TurboAssembler::Jump(Address target, RelocInfo::Mode rmode,\n void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,\n                           Condition cond) {\n   DCHECK(RelocInfo::IsCodeTarget(rmode));\n-#ifdef V8_EMBEDDED_BUILTINS\n-  if (root_array_available_ && isolate()->ShouldLoadConstantsFromRootList()) {\n-    UseScratchRegisterScope temps(this);\n-    Register scratch = temps.Acquire();\n-    LookupConstant(scratch, code);\n-    add(scratch, scratch, Operand(Code::kHeaderSize - kHeapObjectTag));\n-    Jump(scratch, cond);\n-    return;\n+  if (FLAG_embedded_builtins) {\n+    int builtin_index = Builtins::kNoBuiltinId;\n+    bool target_is_isolate_independent_builtin =\n+        isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&\n+        Builtins::IsIsolateIndependent(builtin_index);\n+    if (target_is_isolate_independent_builtin &&\n+        options().use_pc_relative_calls_and_jumps) {\n+      int32_t code_target_index = AddCodeTarget(code);\n+      b(code_target_index * Instruction::kInstrSize, cond,\n+        RelocInfo::RELATIVE_CODE_TARGET);\n+      return;\n+    } else if (root_array_available_ && options().isolate_independent_code) {\n+      UseScratchRegisterScope temps(this);\n+      Register scratch = temps.Acquire();\n+      IndirectLoadConstant(scratch, code);\n+      add(scratch, scratch, Operand(Code::kHeaderSize - kHeapObjectTag));\n+      Jump(scratch, cond);\n+      return;\n+    } else if (target_is_isolate_independent_builtin &&\n+               options().inline_offheap_trampolines) {\n+      // Inline the trampoline.\n+      EmbeddedData d = EmbeddedData::FromBlob();\n+      Address entry = d.InstructionStartOfBuiltin(builtin_index);\n+      // Use ip directly instead of using UseScratchRegisterScope, as we do not\n+      // preserve scratch registers across calls.\n+      mov(ip, Operand(entry, RelocInfo::OFF_HEAP_TARGET));\n+      Jump(ip, cond);\n+      return;\n+    }\n   }\n-#endif  // V8_EMBEDDED_BUILTINS\n   // 'code' is always generated ARM code, never THUMB code\n   Jump(static_cast<intptr_t>(code.address()), rmode, cond);\n }\n@@ -312,16 +297,37 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,\n                           Condition cond, TargetAddressStorageMode mode,\n                           bool check_constant_pool) {\n   DCHECK(RelocInfo::IsCodeTarget(rmode));\n-#ifdef V8_EMBEDDED_BUILTINS\n-  if (root_array_available_ && isolate()->ShouldLoadConstantsFromRootList()) {\n-    // Use ip directly instead of using UseScratchRegisterScope, as we do not\n-    // preserve scratch registers across calls.\n-    LookupConstant(ip, code);\n-    add(ip, ip, Operand(Code::kHeaderSize - kHeapObjectTag));\n-    Call(ip, cond);\n-    return;\n+  if (FLAG_embedded_builtins) {\n+    int builtin_index = Builtins::kNoBuiltinId;\n+    bool target_is_isolate_independent_builtin =\n+        isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&\n+        Builtins::IsIsolateIndependent(builtin_index);\n+    if (target_is_isolate_independent_builtin &&\n+        options().use_pc_relative_calls_and_jumps) {\n+      int32_t code_target_index = AddCodeTarget(code);\n+      bl(code_target_index * Instruction::kInstrSize, cond,\n+         RelocInfo::RELATIVE_CODE_TARGET);\n+      return;\n+    } else if (root_array_available_ && options().isolate_independent_code) {\n+      // Use ip directly instead of using UseScratchRegisterScope, as we do not\n+      // preserve scratch registers across calls.\n+      IndirectLoadConstant(ip, code);\n+      add(ip, ip, Operand(Code::kHeaderSize - kHeapObjectTag));\n+      Call(ip, cond);\n+      return;\n+    } else if (target_is_isolate_independent_builtin &&\n+               options().inline_offheap_trampolines) {\n+      // Inline the trampoline.\n+      DCHECK(Builtins::IsBuiltinId(builtin_index));\n+      EmbeddedData d = EmbeddedData::FromBlob();\n+      Address entry = d.InstructionStartOfBuiltin(builtin_index);\n+      // Use ip directly instead of using UseScratchRegisterScope, as we do not\n+      // preserve scratch registers across calls.\n+      mov(ip, Operand(entry, RelocInfo::OFF_HEAP_TARGET));\n+      Call(ip, cond);\n+      return;\n+    }\n   }\n-#endif  // V8_EMBEDDED_BUILTINS\n   // 'code' is always generated ARM code, never THUMB code\n   Call(code.address(), rmode, cond, mode);\n }\n@@ -362,29 +368,22 @@ void TurboAssembler::Push(Smi* smi) {\n void TurboAssembler::Move(Register dst, Smi* smi) { mov(dst, Operand(smi)); }\n \n void TurboAssembler::Move(Register dst, Handle<HeapObject> value) {\n-#ifdef V8_EMBEDDED_BUILTINS\n-  if (root_array_available_ && isolate()->ShouldLoadConstantsFromRootList()) {\n-    Heap::RootListIndex root_index;\n-    if (!isolate()->heap()->IsRootHandle(value, &root_index)) {\n-      LookupConstant(dst, value);\n-    } else {\n-      LoadRoot(dst, root_index);\n+  if (FLAG_embedded_builtins) {\n+    if (root_array_available_ && options().isolate_independent_code) {\n+      IndirectLoadConstant(dst, value);\n+      return;\n     }\n-    return;\n   }\n-#endif  // V8_EMBEDDED_BUILTINS\n   mov(dst, Operand(value));\n }\n \n void TurboAssembler::Move(Register dst, ExternalReference reference) {\n-#ifdef V8_EMBEDDED_BUILTINS\n-  if (root_array_available_ && isolate()->ShouldLoadConstantsFromRootList() &&\n-      reference.address() !=\n-          ExternalReference::roots_array_start(isolate()).address()) {\n-    LookupExternalReference(dst, reference);\n-    return;\n+  if (FLAG_embedded_builtins) {\n+    if (root_array_available_ && options().isolate_independent_code) {\n+      IndirectLoadExternalReference(dst, reference);\n+      return;\n+    }\n   }\n-#endif  // V8_EMBEDDED_BUILTINS\n   mov(dst, Operand(reference));\n }\n \n@@ -564,7 +563,7 @@ void MacroAssembler::Store(Register src,\n \n void TurboAssembler::LoadRoot(Register destination, Heap::RootListIndex index,\n                               Condition cond) {\n-  ldr(destination, MemOperand(kRootRegister, index << kPointerSizeLog2), cond);\n+  ldr(destination, MemOperand(kRootRegister, RootRegisterOffset(index)), cond);\n }\n \n \n@@ -1224,10 +1223,6 @@ void TurboAssembler::EnterFrame(StackFrame::Type type,\n   Register scratch = temps.Acquire();\n   mov(scratch, Operand(StackFrame::TypeToMarker(type)));\n   PushCommonFrame(scratch);\n-  if (type == StackFrame::INTERNAL) {\n-    Move(scratch, CodeObject());\n-    push(scratch);\n-  }\n }\n \n int TurboAssembler::LeaveFrame(StackFrame::Type type) {\n@@ -1599,9 +1594,9 @@ void MacroAssembler::InvokeFunction(Register fun, Register new_target,\n \n   ldr(temp_reg, FieldMemOperand(r1, JSFunction::kSharedFunctionInfoOffset));\n   ldr(cp, FieldMemOperand(r1, JSFunction::kContextOffset));\n-  ldr(expected_reg,\n-      FieldMemOperand(temp_reg,\n-                      SharedFunctionInfo::kFormalParameterCountOffset));\n+  ldrh(expected_reg,\n+       FieldMemOperand(temp_reg,\n+                       SharedFunctionInfo::kFormalParameterCountOffset));\n \n   ParameterCount expected(expected_reg);\n   InvokeFunctionCode(fun, new_target, expected, actual, flag);\n@@ -1774,7 +1769,8 @@ void TurboAssembler::TryInlineTruncateDoubleToI(Register result,\n \n void TurboAssembler::TruncateDoubleToI(Isolate* isolate, Zone* zone,\n                                        Register result,\n-                                       DwVfpRegister double_input) {\n+                                       DwVfpRegister double_input,\n+                                       StubCallMode stub_mode) {\n   Label done;\n \n   TryInlineTruncateDoubleToI(result, double_input, &done);\n@@ -1784,7 +1780,11 @@ void TurboAssembler::TruncateDoubleToI(Isolate* isolate, Zone* zone,\n   sub(sp, sp, Operand(kDoubleSize));  // Put input on stack.\n   vstr(double_input, MemOperand(sp, 0));\n \n-  Call(BUILTIN_CODE(isolate, DoubleToI), RelocInfo::CODE_TARGET);\n+  if (stub_mode == StubCallMode::kCallWasmRuntimeStub) {\n+    Call(wasm::WasmCode::kDoubleToI, RelocInfo::WASM_STUB_CALL);\n+  } else {\n+    Call(BUILTIN_CODE(isolate, DoubleToI), RelocInfo::CODE_TARGET);\n+  }\n   ldr(result, MemOperand(sp, 0));\n \n   add(sp, sp, Operand(kDoubleSize));\n@@ -1793,18 +1793,18 @@ void TurboAssembler::TruncateDoubleToI(Isolate* isolate, Zone* zone,\n   bind(&done);\n }\n \n-void TurboAssembler::CallRuntimeDelayed(Zone* zone, Runtime::FunctionId fid,\n-                                        SaveFPRegsMode save_doubles) {\n+void TurboAssembler::CallRuntimeWithCEntry(Runtime::FunctionId fid,\n+                                           Register centry) {\n   const Runtime::Function* f = Runtime::FunctionForId(fid);\n   // TODO(1236192): Most runtime routines don't need the number of\n   // arguments passed in because it is constant. At some point we\n   // should remove this need and make the runtime routine entry code\n   // smarter.\n   mov(r0, Operand(f->nargs));\n   Move(r1, ExternalReference::Create(f));\n-  Handle<Code> code =\n-      CodeFactory::CEntry(isolate(), f->result_size, save_doubles);\n-  Call(code, RelocInfo::CODE_TARGET);\n+  DCHECK(!AreAliased(centry, r0, r1));\n+  add(centry, centry, Operand(Code::kHeaderSize - kHeapObjectTag));\n+  Call(centry);\n }\n \n void MacroAssembler::CallRuntime(const Runtime::Function* f,\n@@ -1905,18 +1905,17 @@ void TurboAssembler::Check(Condition cond, AbortReason reason) {\n void TurboAssembler::Abort(AbortReason reason) {\n   Label abort_start;\n   bind(&abort_start);\n-#ifdef DEBUG\n   const char* msg = GetAbortReason(reason);\n-  if (msg != nullptr) {\n-    RecordComment(\"Abort message: \");\n-    RecordComment(msg);\n-  }\n+#ifdef DEBUG\n+  RecordComment(\"Abort message: \");\n+  RecordComment(msg);\n+#endif\n \n-  if (FLAG_trap_on_abort) {\n+  // Avoid emitting call to builtin if requested.\n+  if (trap_on_abort()) {\n     stop(msg);\n     return;\n   }\n-#endif\n \n   Move(r1, Smi::FromInt(static_cast<int>(reason)));\n \n@@ -1953,6 +1952,7 @@ void TurboAssembler::InitializeRootRegister() {\n   ExternalReference roots_array_start =\n       ExternalReference::roots_array_start(isolate());\n   mov(kRootRegister, Operand(roots_array_start));\n+  add(kRootRegister, kRootRegister, Operand(kRootRegisterBias));\n }\n \n void MacroAssembler::SmiTag(Register reg, SBit s) {\n@@ -1979,6 +1979,16 @@ void TurboAssembler::JumpIfSmi(Register value, Label* smi_label) {\n   b(eq, smi_label);\n }\n \n+void TurboAssembler::JumpIfEqual(Register x, int32_t y, Label* dest) {\n+  cmp(x, Operand(y));\n+  b(eq, dest);\n+}\n+\n+void TurboAssembler::JumpIfLessThan(Register x, int32_t y, Label* dest) {\n+  cmp(x, Operand(y));\n+  b(lt, dest);\n+}\n+\n void MacroAssembler::JumpIfNotSmi(Register value, Label* not_smi_label) {\n   tst(value, Operand(kSmiTagMask));\n   b(ne, not_smi_label);\n@@ -2010,18 +2020,6 @@ void MacroAssembler::AssertSmi(Register object) {\n   }\n }\n \n-void MacroAssembler::AssertFixedArray(Register object) {\n-  if (emit_debug_code()) {\n-    STATIC_ASSERT(kSmiTag == 0);\n-    tst(object, Operand(kSmiTagMask));\n-    Check(ne, AbortReason::kOperandIsASmiAndNotAFixedArray);\n-    push(object);\n-    CompareObjectType(object, object, object, FIXED_ARRAY_TYPE);\n-    pop(object);\n-    Check(eq, AbortReason::kOperandIsNotAFixedArray);\n-  }\n-}\n-\n void MacroAssembler::AssertConstructor(Register object) {\n   if (emit_debug_code()) {\n     STATIC_ASSERT(kSmiTag == 0);\n@@ -2094,7 +2092,7 @@ void MacroAssembler::AssertUndefinedOrAllocationSite(Register object,\n     CompareRoot(object, Heap::kUndefinedValueRootIndex);\n     b(eq, &done_checking);\n     ldr(scratch, FieldMemOperand(object, HeapObject::kMapOffset));\n-    CompareRoot(scratch, Heap::kAllocationSiteMapRootIndex);\n+    CompareInstanceType(scratch, scratch, ALLOCATION_SITE_TYPE);\n     Assert(eq, AbortReason::kExpectedUndefinedOrCell);\n     bind(&done_checking);\n   }\n@@ -2453,7 +2451,7 @@ bool AreAliased(Register reg1,\n \n void TurboAssembler::ComputeCodeStartAddress(Register dst) {\n   // We can use the register pc - 8 for the address of the current instruction.\n-  sub(dst, pc, Operand(pc_offset() + TurboAssembler::kPcLoadDelta));\n+  sub(dst, pc, Operand(pc_offset() + Instruction::kPcLoadDelta));\n }\n \n void TurboAssembler::ResetSpeculationPoisonRegister() {"
        },
        {
            "sha": "87a8ff28349a6667bdb8e6b475e7df06a821761c",
            "filename": "deps/v8/src/arm/macro-assembler-arm.h",
            "status": "modified",
            "additions": 35,
            "deletions": 39,
            "changes": 74,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fmacro-assembler-arm.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -9,6 +9,7 @@\n #include \"src/assembler.h\"\n #include \"src/bailout-reason.h\"\n #include \"src/globals.h\"\n+#include \"src/turbo-assembler.h\"\n \n namespace v8 {\n namespace internal {\n@@ -25,9 +26,13 @@ constexpr Register kInterpreterAccumulatorRegister = r0;\n constexpr Register kInterpreterBytecodeOffsetRegister = r5;\n constexpr Register kInterpreterBytecodeArrayRegister = r6;\n constexpr Register kInterpreterDispatchTableRegister = r8;\n+\n constexpr Register kJavaScriptCallArgCountRegister = r0;\n constexpr Register kJavaScriptCallCodeStartRegister = r2;\n+constexpr Register kJavaScriptCallTargetRegister = kJSFunctionRegister;\n constexpr Register kJavaScriptCallNewTargetRegister = r3;\n+constexpr Register kJavaScriptCallExtraArg1Register = r2;\n+\n constexpr Register kOffHeapTrampolineRegister = ip;\n constexpr Register kRuntimeCallFunctionRegister = r1;\n constexpr Register kRuntimeCallArgCountRegister = r0;\n@@ -85,20 +90,13 @@ enum TargetAddressStorageMode {\n   NEVER_INLINE_TARGET_ADDRESS\n };\n \n-class TurboAssembler : public Assembler {\n+class TurboAssembler : public TurboAssemblerBase {\n  public:\n-  TurboAssembler(Isolate* isolate, void* buffer, int buffer_size,\n-                 CodeObjectRequired create_code_object);\n-\n-  void set_has_frame(bool value) { has_frame_ = value; }\n-  bool has_frame() const { return has_frame_; }\n-\n-  Isolate* isolate() const { return isolate_; }\n-\n-  Handle<HeapObject> CodeObject() {\n-    DCHECK(!code_object_.is_null());\n-    return code_object_;\n-  }\n+  TurboAssembler(Isolate* isolate, const AssemblerOptions& options,\n+                 void* buffer, int buffer_size,\n+                 CodeObjectRequired create_code_object)\n+      : TurboAssemblerBase(isolate, options, buffer, buffer_size,\n+                           create_code_object) {}\n \n   // Activation support.\n   void EnterFrame(StackFrame::Type type,\n@@ -321,11 +319,10 @@ class TurboAssembler : public Assembler {\n   void AsrPair(Register dst_low, Register dst_high, Register src_low,\n                Register src_high, uint32_t shift);\n \n-#ifdef V8_EMBEDDED_BUILTINS\n-  void LookupConstant(Register destination, Handle<Object> object);\n-  void LookupExternalReference(Register destination,\n-                               ExternalReference reference);\n-#endif  // V8_EMBEDDED_BUILTINS\n+  void LoadFromConstantsTable(Register destination,\n+                              int constant_index) override;\n+  void LoadRootRegisterOffset(Register destination, intptr_t offset) override;\n+  void LoadRootRelative(Register destination, int32_t offset) override;\n \n   // Returns the size of a call in instructions. Note, the value returned is\n   // only valid as long as no entries are added to the constant pool between\n@@ -338,9 +335,10 @@ class TurboAssembler : public Assembler {\n   int CallStubSize();\n \n   void CallStubDelayed(CodeStub* stub);\n-  // TODO(jgruber): Remove in favor of MacroAssembler::CallRuntime.\n-  void CallRuntimeDelayed(Zone* zone, Runtime::FunctionId fid,\n-                          SaveFPRegsMode save_doubles = kDontSaveFPRegs);\n+\n+  // Call a runtime routine. This expects {centry} to contain a fitting CEntry\n+  // builtin for the target runtime function and uses an indirect call.\n+  void CallRuntimeWithCEntry(Runtime::FunctionId fid, Register centry);\n \n   // Jump, Call, and Ret pseudo instructions implementing inter-working.\n   void Call(Register target, Condition cond = al);\n@@ -355,7 +353,9 @@ class TurboAssembler : public Assembler {\n \n   // This should only be used when assembling a deoptimizer call because of\n   // the CheckConstPool invocation, which is only needed for deoptimization.\n-  void CallForDeoptimization(Address target, RelocInfo::Mode rmode) {\n+  void CallForDeoptimization(Address target, int deopt_id,\n+                             RelocInfo::Mode rmode) {\n+    USE(deopt_id);\n     Call(target, rmode);\n     CheckConstPool(false, false);\n   }\n@@ -511,12 +511,18 @@ class TurboAssembler : public Assembler {\n   }\n \n   // Load an object from the root table.\n+  void LoadRoot(Register destination, Heap::RootListIndex index) override {\n+    LoadRoot(destination, index, al);\n+  }\n   void LoadRoot(Register destination, Heap::RootListIndex index,\n-                Condition cond = al);\n+                Condition cond);\n \n   // Jump if the register contains a smi.\n   void JumpIfSmi(Register value, Label* smi_label);\n \n+  void JumpIfEqual(Register x, int32_t y, Label* dest);\n+  void JumpIfLessThan(Register x, int32_t y, Label* dest);\n+\n   // Performs a truncating conversion of a floating point number as used by\n   // the JS bitwise operations. See ECMA-262 9.5: ToInt32. Goes to 'done' if it\n   // succeeds, otherwise falls through if result is saturated. On return\n@@ -530,7 +536,7 @@ class TurboAssembler : public Assembler {\n   // the JS bitwise operations. See ECMA-262 9.5: ToInt32.\n   // Exits with 'result' holding the answer.\n   void TruncateDoubleToI(Isolate* isolate, Zone* zone, Register result,\n-                         DwVfpRegister double_input);\n+                         DwVfpRegister double_input, StubCallMode stub_mode);\n \n   // EABI variant for double arguments in use.\n   bool use_eabi_hardfloat() {\n@@ -549,18 +555,7 @@ class TurboAssembler : public Assembler {\n \n   void ResetSpeculationPoisonRegister();\n \n-  bool root_array_available() const { return root_array_available_; }\n-  void set_root_array_available(bool v) { root_array_available_ = v; }\n-\n- protected:\n-  // This handle will be patched with the code object on installation.\n-  Handle<HeapObject> code_object_;\n-\n  private:\n-  bool has_frame_ = false;\n-  bool root_array_available_ = true;\n-  Isolate* const isolate_;\n-\n   // Compare single values and then load the fpscr flags to a register.\n   void VFPCompareAndLoadFlags(const SwVfpRegister src1,\n                               const SwVfpRegister src2,\n@@ -602,7 +597,11 @@ class TurboAssembler : public Assembler {\n class MacroAssembler : public TurboAssembler {\n  public:\n   MacroAssembler(Isolate* isolate, void* buffer, int size,\n-                 CodeObjectRequired create_code_object);\n+                 CodeObjectRequired create_code_object)\n+      : MacroAssembler(isolate, AssemblerOptions::Default(isolate), buffer,\n+                       size, create_code_object) {}\n+  MacroAssembler(Isolate* isolate, const AssemblerOptions& options,\n+                 void* buffer, int size, CodeObjectRequired create_code_object);\n \n   void Mls(Register dst, Register src1, Register src2, Register srcA,\n            Condition cond = al);\n@@ -849,9 +848,6 @@ class MacroAssembler : public TurboAssembler {\n   void AssertNotSmi(Register object);\n   void AssertSmi(Register object);\n \n-  // Abort execution if argument is not a FixedArray, enabled via --debug-code.\n-  void AssertFixedArray(Register object);\n-\n   // Abort execution if argument is not a Constructor, enabled via --debug-code.\n   void AssertConstructor(Register object);\n "
        },
        {
            "sha": "e0f57396c1b5f1d8cd02db28cb12f64536139aa0",
            "filename": "deps/v8/src/arm/simulator-arm.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fsimulator-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm%2Fsimulator-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm%2Fsimulator-arm.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -285,7 +285,7 @@ void ArmDebugger::Debug() {\n                  || (strcmp(cmd, \"printobject\") == 0)) {\n         if (argc == 2) {\n           int32_t value;\n-          OFStream os(stdout);\n+          StdoutStream os;\n           if (GetValue(arg1, &value)) {\n             Object* obj = reinterpret_cast<Object*>(value);\n             os << arg1 << \": \\n\";\n@@ -514,7 +514,7 @@ void ArmDebugger::Debug() {\n         PrintF(\"    Stops are debug instructions inserted by\\n\");\n         PrintF(\"    the Assembler::stop() function.\\n\");\n         PrintF(\"    When hitting a stop, the Simulator will\\n\");\n-        PrintF(\"    stop and and give control to the ArmDebugger.\\n\");\n+        PrintF(\"    stop and give control to the ArmDebugger.\\n\");\n         PrintF(\"    The first %d stop codes are watched:\\n\",\n                Simulator::kNumOfWatchedStops);\n         PrintF(\"    - They can be enabled / disabled: the Simulator\\n\");"
        },
        {
            "sha": "72674b87a3d1184ebf8ebf8a581489509508848e",
            "filename": "deps/v8/src/arm64/assembler-arm64-inl.h",
            "status": "modified",
            "additions": 8,
            "deletions": 21,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64-inl.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -386,18 +386,16 @@ unsigned Operand::shift_amount() const {\n \n \n Operand Operand::UntagSmi(Register smi) {\n-  STATIC_ASSERT(kXRegSizeInBits == static_cast<unsigned>(kSmiShift +\n-                                                         kSmiValueSize));\n   DCHECK(smi.Is64Bits());\n+  DCHECK(SmiValuesAre32Bits() || SmiValuesAre31Bits());\n   return Operand(smi, ASR, kSmiShift);\n }\n \n \n Operand Operand::UntagSmiAndScale(Register smi, int scale) {\n-  STATIC_ASSERT(kXRegSizeInBits == static_cast<unsigned>(kSmiShift +\n-                                                         kSmiValueSize));\n   DCHECK(smi.Is64Bits());\n   DCHECK((scale >= 0) && (scale <= (64 - kSmiValueSize)));\n+  DCHECK(SmiValuesAre32Bits() || SmiValuesAre31Bits());\n   if (scale > kSmiShift) {\n     return Operand(smi, LSL, scale - kSmiShift);\n   } else if (scale < kSmiShift) {\n@@ -551,11 +549,8 @@ Handle<Code> Assembler::code_target_object_handle_at(Address pc) {\n         Assembler::target_address_at(pc, 0 /* unused */)));\n   } else {\n     DCHECK(instr->IsBranchAndLink() || instr->IsUnconditionalBranch());\n-    DCHECK_GE(instr->ImmPCOffset(), 0);\n     DCHECK_EQ(instr->ImmPCOffset() % kInstructionSize, 0);\n-    DCHECK_LT(instr->ImmPCOffset() >> kInstructionSizeLog2,\n-              code_targets_.size());\n-    return code_targets_[instr->ImmPCOffset() >> kInstructionSizeLog2];\n+    return GetCodeTarget(instr->ImmPCOffset() >> kInstructionSizeLog2);\n   }\n }\n \n@@ -565,7 +560,7 @@ Address Assembler::runtime_entry_at(Address pc) {\n     return Assembler::target_address_at(pc, 0 /* unused */);\n   } else {\n     DCHECK(instr->IsBranchAndLink() || instr->IsUnconditionalBranch());\n-    return instr->ImmPCOffset() + isolate_data().code_range_start_;\n+    return instr->ImmPCOffset() + options().code_range_start;\n   }\n }\n \n@@ -708,17 +703,16 @@ Handle<HeapObject> RelocInfo::target_object_handle(Assembler* origin) {\n   }\n }\n \n-void RelocInfo::set_target_object(HeapObject* target,\n+void RelocInfo::set_target_object(Heap* heap, HeapObject* target,\n                                   WriteBarrierMode write_barrier_mode,\n                                   ICacheFlushMode icache_flush_mode) {\n   DCHECK(IsCodeTarget(rmode_) || rmode_ == EMBEDDED_OBJECT);\n   Assembler::set_target_address_at(pc_, constant_pool_,\n                                    reinterpret_cast<Address>(target),\n                                    icache_flush_mode);\n   if (write_barrier_mode == UPDATE_WRITE_BARRIER && host() != nullptr) {\n-    host()->GetHeap()->incremental_marking()->RecordWriteIntoCode(host(), this,\n-                                                                  target);\n-    host()->GetHeap()->RecordWriteIntoCode(host(), this, target);\n+    heap->incremental_marking()->RecordWriteIntoCode(host(), this, target);\n+    heap->RecordWriteIntoCode(host(), this, target);\n   }\n }\n \n@@ -746,13 +740,6 @@ Address RelocInfo::target_internal_reference_address() {\n   return pc_;\n }\n \n-void RelocInfo::set_wasm_code_table_entry(Address target,\n-                                          ICacheFlushMode icache_flush_mode) {\n-  DCHECK(rmode_ == RelocInfo::WASM_CODE_TABLE_ENTRY);\n-  Assembler::set_target_address_at(pc_, constant_pool_, target,\n-                                   icache_flush_mode);\n-}\n-\n Address RelocInfo::target_runtime_entry(Assembler* origin) {\n   DCHECK(IsRuntimeEntry(rmode_));\n   return origin->runtime_entry_at(pc_);\n@@ -788,7 +775,7 @@ void RelocInfo::Visit(ObjectVisitor* visitor) {\n   RelocInfo::Mode mode = rmode();\n   if (mode == RelocInfo::EMBEDDED_OBJECT) {\n     visitor->VisitEmbeddedPointer(host(), this);\n-  } else if (RelocInfo::IsCodeTarget(mode)) {\n+  } else if (RelocInfo::IsCodeTargetMode(mode)) {\n     visitor->VisitCodeTarget(host(), this);\n   } else if (mode == RelocInfo::EXTERNAL_REFERENCE) {\n     visitor->VisitExternalReference(host(), this);"
        },
        {
            "sha": "af3f59bd482d4fcee83df16e67b8b97641df20c6",
            "filename": "deps/v8/src/arm64/assembler-arm64.cc",
            "status": "modified",
            "additions": 53,
            "deletions": 67,
            "changes": 120,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -157,9 +157,10 @@ CPURegList CPURegList::GetSafepointSavedRegisters() {\n // -----------------------------------------------------------------------------\n // Implementation of RelocInfo\n \n-const int RelocInfo::kApplyMask = RelocInfo::kCodeTargetMask |\n-                                  1 << RelocInfo::RUNTIME_ENTRY |\n-                                  1 << RelocInfo::INTERNAL_REFERENCE;\n+const int RelocInfo::kApplyMask =\n+    RelocInfo::ModeMask(RelocInfo::CODE_TARGET) |\n+    RelocInfo::ModeMask(RelocInfo::RUNTIME_ENTRY) |\n+    RelocInfo::ModeMask(RelocInfo::INTERNAL_REFERENCE);\n \n bool RelocInfo::IsCodedSpecially() {\n   // The deserializer needs to know whether a pointer is specially coded. Being\n@@ -179,33 +180,39 @@ bool RelocInfo::IsInConstantPool() {\n   return instr->IsLdrLiteralX();\n }\n \n-Address RelocInfo::embedded_address() const {\n-  return Assembler::target_address_at(pc_, constant_pool_);\n-}\n+int RelocInfo::GetDeoptimizationId(Isolate* isolate, DeoptimizeKind kind) {\n+  DCHECK(IsRuntimeEntry(rmode_));\n+  Instruction* movz_instr = reinterpret_cast<Instruction*>(pc_)->preceding();\n+  DCHECK(movz_instr->IsMovz());\n+  uint64_t imm = static_cast<uint64_t>(movz_instr->ImmMoveWide())\n+                 << (16 * movz_instr->ShiftMoveWide());\n+  DCHECK_LE(imm, INT_MAX);\n \n-uint32_t RelocInfo::embedded_size() const {\n-  return Memory::uint32_at(Assembler::target_pointer_address_at(pc_));\n-}\n-\n-void RelocInfo::set_embedded_address(Address address,\n-                                     ICacheFlushMode flush_mode) {\n-  Assembler::set_target_address_at(pc_, constant_pool_, address, flush_mode);\n-}\n-\n-void RelocInfo::set_embedded_size(uint32_t size, ICacheFlushMode flush_mode) {\n-  Memory::uint32_at(Assembler::target_pointer_address_at(pc_)) = size;\n-  // No icache flushing needed, see comment in set_target_address_at.\n+  return static_cast<int>(imm);\n }\n \n void RelocInfo::set_js_to_wasm_address(Address address,\n                                        ICacheFlushMode icache_flush_mode) {\n   DCHECK_EQ(rmode_, JS_TO_WASM_CALL);\n-  set_embedded_address(address, icache_flush_mode);\n+  Assembler::set_target_address_at(pc_, constant_pool_, address,\n+                                   icache_flush_mode);\n }\n \n Address RelocInfo::js_to_wasm_address() const {\n   DCHECK_EQ(rmode_, JS_TO_WASM_CALL);\n-  return embedded_address();\n+  return Assembler::target_address_at(pc_, constant_pool_);\n+}\n+\n+uint32_t RelocInfo::wasm_call_tag() const {\n+  DCHECK(rmode_ == WASM_CALL || rmode_ == WASM_STUB_CALL);\n+  Instruction* instr = reinterpret_cast<Instruction*>(pc_);\n+  if (instr->IsLdrLiteralX()) {\n+    return static_cast<uint32_t>(\n+        Memory::Address_at(Assembler::target_pointer_address_at(pc_)));\n+  } else {\n+    DCHECK(instr->IsBranchAndLink() || instr->IsUnconditionalBranch());\n+    return static_cast<uint32_t>(instr->ImmPCOffset() / kInstructionSize);\n+  }\n }\n \n bool AreAliased(const CPURegister& reg1, const CPURegister& reg2,\n@@ -304,8 +311,8 @@ void Immediate::InitializeHandle(Handle<HeapObject> handle) {\n bool Operand::NeedsRelocation(const Assembler* assembler) const {\n   RelocInfo::Mode rmode = immediate_.rmode();\n \n-  if (rmode == RelocInfo::EXTERNAL_REFERENCE) {\n-    return assembler->serializer_enabled();\n+  if (RelocInfo::IsOnlyForSerializer(rmode)) {\n+    return assembler->options().record_reloc_info_for_serialization;\n   }\n \n   return !RelocInfo::IsNone(rmode);\n@@ -342,8 +349,7 @@ bool ConstPool::RecordEntry(intptr_t data, RelocInfo::Mode mode) {\n \n   if (CanBeShared(mode)) {\n     write_reloc_info = AddSharedEntry(shared_entries_, raw_data, offset);\n-  } else if (mode == RelocInfo::CODE_TARGET &&\n-             assm_->IsCodeTargetSharingAllowed() && raw_data != 0) {\n+  } else if (mode == RelocInfo::CODE_TARGET && raw_data != 0) {\n     // A zero data value is a placeholder and must not be shared.\n     write_reloc_info = AddSharedEntry(handle_to_index_map_, raw_data, offset);\n   } else {\n@@ -471,8 +477,7 @@ void ConstPool::Clear() {\n \n \n bool ConstPool::CanBeShared(RelocInfo::Mode mode) {\n-  return RelocInfo::IsNone(mode) ||\n-         (mode >= RelocInfo::FIRST_SHAREABLE_RELOC_MODE);\n+  return RelocInfo::IsNone(mode) || RelocInfo::IsShareableRelocMode(mode);\n }\n \n \n@@ -537,7 +542,7 @@ void ConstPool::EmitEntries() {\n \n       // Instruction to patch must be 'ldr rd, [pc, #offset]' with offset == 0.\n       DCHECK(instr->IsLdrLiteral() && instr->ImmLLiteral() == 0);\n-      instr->SetImmPCOffsetTarget(assm_->isolate_data(), assm_->pc());\n+      instr->SetImmPCOffsetTarget(assm_->options(), assm_->pc());\n     }\n \n     assm_->dc64(entry.first);\n@@ -547,13 +552,13 @@ void ConstPool::EmitEntries() {\n \n \n // Assembler\n-Assembler::Assembler(IsolateData isolate_data, void* buffer, int buffer_size)\n-    : AssemblerBase(isolate_data, buffer, buffer_size),\n+Assembler::Assembler(const AssemblerOptions& options, void* buffer,\n+                     int buffer_size)\n+    : AssemblerBase(options, buffer, buffer_size),\n       constpool_(this),\n       unresolved_branches_() {\n   const_pool_blocked_nesting_ = 0;\n   veneer_pool_blocked_nesting_ = 0;\n-  code_target_sharing_blocked_nesting_ = 0;\n   Reset();\n }\n \n@@ -562,7 +567,6 @@ Assembler::~Assembler() {\n   DCHECK(constpool_.IsEmpty());\n   DCHECK_EQ(const_pool_blocked_nesting_, 0);\n   DCHECK_EQ(veneer_pool_blocked_nesting_, 0);\n-  DCHECK_EQ(code_target_sharing_blocked_nesting_, 0);\n }\n \n \n@@ -571,12 +575,11 @@ void Assembler::Reset() {\n   DCHECK((pc_ >= buffer_) && (pc_ < buffer_ + buffer_size_));\n   DCHECK_EQ(const_pool_blocked_nesting_, 0);\n   DCHECK_EQ(veneer_pool_blocked_nesting_, 0);\n-  DCHECK_EQ(code_target_sharing_blocked_nesting_, 0);\n   DCHECK(unresolved_branches_.empty());\n   memset(buffer_, 0, pc_ - buffer_);\n #endif\n   pc_ = buffer_;\n-  code_targets_.reserve(64);\n+  ReserveCodeTargetSpace(64);\n   reloc_info_writer.Reposition(buffer_ + buffer_size_, pc_);\n   constpool_.Clear();\n   next_constant_pool_check_ = 0;\n@@ -589,21 +592,18 @@ void Assembler::AllocateAndInstallRequestedHeapObjects(Isolate* isolate) {\n     Address pc = reinterpret_cast<Address>(buffer_) + request.offset();\n     switch (request.kind()) {\n       case HeapObjectRequest::kHeapNumber: {\n-        Handle<HeapObject> object = isolate->factory()->NewHeapNumber(\n-            request.heap_number(), IMMUTABLE, TENURED);\n+        Handle<HeapObject> object =\n+            isolate->factory()->NewHeapNumber(request.heap_number(), TENURED);\n         set_target_address_at(pc, 0 /* unused */, object.address());\n         break;\n       }\n       case HeapObjectRequest::kCodeStub: {\n         request.code_stub()->set_isolate(isolate);\n         Instruction* instr = reinterpret_cast<Instruction*>(pc);\n         DCHECK(instr->IsBranchAndLink() || instr->IsUnconditionalBranch());\n-        DCHECK_GE(instr->ImmPCOffset(), 0);\n         DCHECK_EQ(instr->ImmPCOffset() % kInstructionSize, 0);\n-        DCHECK_LT(instr->ImmPCOffset() >> kInstructionSizeLog2,\n-                  code_targets_.size());\n-        code_targets_[instr->ImmPCOffset() >> kInstructionSizeLog2] =\n-            request.code_stub()->GetCode();\n+        UpdateCodeTarget(instr->ImmPCOffset() >> kInstructionSizeLog2,\n+                         request.code_stub()->GetCode());\n         break;\n       }\n     }\n@@ -697,22 +697,22 @@ void Assembler::RemoveBranchFromLabelLinkChain(Instruction* branch,\n \n   } else if (branch == next_link) {\n     // The branch is the last (but not also the first) instruction in the chain.\n-    prev_link->SetImmPCOffsetTarget(isolate_data(), prev_link);\n+    prev_link->SetImmPCOffsetTarget(options(), prev_link);\n \n   } else {\n     // The branch is in the middle of the chain.\n     if (prev_link->IsTargetInImmPCOffsetRange(next_link)) {\n-      prev_link->SetImmPCOffsetTarget(isolate_data(), next_link);\n+      prev_link->SetImmPCOffsetTarget(options(), next_link);\n     } else if (label_veneer != nullptr) {\n       // Use the veneer for all previous links in the chain.\n-      prev_link->SetImmPCOffsetTarget(isolate_data(), prev_link);\n+      prev_link->SetImmPCOffsetTarget(options(), prev_link);\n \n       end_of_chain = false;\n       link = next_link;\n       while (!end_of_chain) {\n         next_link = link->ImmPCOffsetTarget();\n         end_of_chain = (link == next_link);\n-        link->SetImmPCOffsetTarget(isolate_data(), label_veneer);\n+        link->SetImmPCOffsetTarget(options(), label_veneer);\n         link = next_link;\n       }\n     } else {\n@@ -783,11 +783,10 @@ void Assembler::bind(Label* label) {\n       // Internal references do not get patched to an instruction but directly\n       // to an address.\n       internal_reference_positions_.push_back(linkoffset);\n-      PatchingAssembler patcher(isolate_data(), reinterpret_cast<byte*>(link),\n-                                2);\n+      PatchingAssembler patcher(options(), reinterpret_cast<byte*>(link), 2);\n       patcher.dc64(reinterpret_cast<uintptr_t>(pc_));\n     } else {\n-      link->SetImmPCOffsetTarget(isolate_data(),\n+      link->SetImmPCOffsetTarget(options(),\n                                  reinterpret_cast<Instruction*>(pc_));\n     }\n \n@@ -4082,9 +4081,7 @@ void Assembler::EmitStringData(const char* string) {\n \n void Assembler::debug(const char* message, uint32_t code, Instr params) {\n #ifdef USE_SIMULATOR\n-  // Don't generate simulator specific code if we are building a snapshot, which\n-  // might be run on real hardware.\n-  if (!serializer_enabled()) {\n+  if (options().enable_simulator_code) {\n     // The arguments to the debug marker need to be contiguous in memory, so\n     // make sure we don't try to emit pools.\n     BlockPoolsScope scope(this);\n@@ -4757,6 +4754,7 @@ void Assembler::RecordRelocInfo(RelocInfo::Mode rmode, intptr_t data,\n                                 ConstantPoolMode constant_pool_mode) {\n   // Non-relocatable constants should not end up in the literal pool.\n   DCHECK(!RelocInfo::IsNone(rmode));\n+  if (options().disable_reloc_info_for_patching) return;\n \n   // We do not try to reuse pool constants.\n   RelocInfo rinfo(reinterpret_cast<Address>(pc_), rmode, data, nullptr);\n@@ -4783,29 +4781,17 @@ void Assembler::RecordRelocInfo(RelocInfo::Mode rmode, intptr_t data,\n   // For modes that cannot use the constant pool, a different sequence of\n   // instructions will be emitted by this function's caller.\n \n-  if (!RelocInfo::IsNone(rmode) && write_reloc_info) {\n+  if (write_reloc_info) {\n     // Don't record external references unless the heap will be serialized.\n-    if (rmode == RelocInfo::EXTERNAL_REFERENCE &&\n-        !serializer_enabled() && !emit_debug_code()) {\n+    if (RelocInfo::IsOnlyForSerializer(rmode) &&\n+        !options().record_reloc_info_for_serialization && !emit_debug_code()) {\n       return;\n     }\n     DCHECK_GE(buffer_space(), kMaxRelocSize);  // too late to grow buffer here\n     reloc_info_writer.Write(&rinfo);\n   }\n }\n \n-int Assembler::GetCodeTargetIndex(Handle<Code> target) {\n-  int current = static_cast<int>(code_targets_.size());\n-  if (current > 0 && !target.is_null() &&\n-      code_targets_.back().address() == target.address()) {\n-    // Optimization if we keep jumping to the same code target.\n-    return (current - 1);\n-  } else {\n-    code_targets_.push_back(target);\n-    return current;\n-  }\n-}\n-\n void Assembler::near_jump(int offset, RelocInfo::Mode rmode) {\n   if (!RelocInfo::IsNone(rmode)) RecordRelocInfo(rmode, offset, NO_POOL_ENTRY);\n   b(offset);\n@@ -4818,7 +4804,7 @@ void Assembler::near_call(int offset, RelocInfo::Mode rmode) {\n \n void Assembler::near_call(HeapObjectRequest request) {\n   RequestHeapObject(request);\n-  int index = GetCodeTargetIndex(Handle<Code>());\n+  int index = AddCodeTarget(Handle<Code>());\n   RecordRelocInfo(RelocInfo::CODE_TARGET, index, NO_POOL_ENTRY);\n   bl(index);\n }\n@@ -4945,7 +4931,7 @@ void Assembler::EmitVeneers(bool force_emit, bool need_protection, int margin) {\n       // to the label.\n       Instruction* veneer = reinterpret_cast<Instruction*>(pc_);\n       RemoveBranchFromLabelLinkChain(branch, label, veneer);\n-      branch->SetImmPCOffsetTarget(isolate_data(), veneer);\n+      branch->SetImmPCOffsetTarget(options(), veneer);\n       b(label);\n #ifdef DEBUG\n       DCHECK(SizeOfCodeGeneratedSince(&veneer_size_check) <="
        },
        {
            "sha": "e2945d59999af4cbc9e43db514a9d917ef6995d4",
            "filename": "deps/v8/src/arm64/assembler-arm64.h",
            "status": "modified",
            "additions": 9,
            "deletions": 74,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fassembler-arm64.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -898,9 +898,7 @@ class Assembler : public AssemblerBase {\n   // buffer for code generation and assumes its size to be buffer_size. If the\n   // buffer is too small, a fatal error occurs. No deallocation of the buffer is\n   // done upon destruction of the assembler.\n-  Assembler(Isolate* isolate, void* buffer, int buffer_size)\n-      : Assembler(IsolateData(isolate), buffer, buffer_size) {}\n-  Assembler(IsolateData isolate_data, void* buffer, int buffer_size);\n+  Assembler(const AssemblerOptions& options, void* buffer, int buffer_size);\n \n   virtual ~Assembler();\n \n@@ -972,10 +970,6 @@ class Assembler : public AssemblerBase {\n       Address pc, Address constant_pool, Address target,\n       ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n \n-  // Add 'target' to the code_targets_ vector, if necessary, and return the\n-  // offset at which it is stored.\n-  int GetCodeTargetIndex(Handle<Code> target);\n-\n   // Returns the handle for the code object called at 'pc'.\n   // This might need to be temporarily encoded as an offset into code_targets_.\n   inline Handle<Code> code_target_object_handle_at(Address pc);\n@@ -984,7 +978,7 @@ class Assembler : public AssemblerBase {\n   // at 'pc'.\n   // Runtime entries can be temporarily encoded as the offset between the\n   // runtime function entrypoint and the code range start (stored in the\n-  // code_range_start_ field), in order to be encodable as we generate the code,\n+  // code_range_start field), in order to be encodable as we generate the code,\n   // before it is moved into the code space.\n   inline Address runtime_entry_at(Address pc);\n \n@@ -2887,6 +2881,10 @@ class Assembler : public AssemblerBase {\n     return reinterpret_cast<byte*>(instr) - buffer_;\n   }\n \n+  static const char* GetSpecialRegisterName(int code) {\n+    return (code == kSPRegInternalCode) ? \"sp\" : \"UNKNOWN\";\n+  }\n+\n   // Register encoding.\n   static Instr Rd(CPURegister rd) {\n     DCHECK_NE(rd.code(), kSPRegInternalCode);\n@@ -3229,34 +3227,6 @@ class Assembler : public AssemblerBase {\n     DISALLOW_IMPLICIT_CONSTRUCTORS(BlockPoolsScope);\n   };\n \n-  // Class for blocking sharing of code targets in constant pool.\n-  class BlockCodeTargetSharingScope {\n-   public:\n-    explicit BlockCodeTargetSharingScope(Assembler* assem) : assem_(nullptr) {\n-      Open(assem);\n-    }\n-    // This constructor does not initialize the scope. The user needs to\n-    // explicitly call Open() before using it.\n-    BlockCodeTargetSharingScope() : assem_(nullptr) {}\n-    ~BlockCodeTargetSharingScope() { Close(); }\n-    void Open(Assembler* assem) {\n-      DCHECK_NULL(assem_);\n-      DCHECK_NOT_NULL(assem);\n-      assem_ = assem;\n-      assem_->StartBlockCodeTargetSharing();\n-    }\n-\n-   private:\n-    void Close() {\n-      if (assem_ != nullptr) {\n-        assem_->EndBlockCodeTargetSharing();\n-      }\n-    }\n-    Assembler* assem_;\n-\n-    DISALLOW_COPY_AND_ASSIGN(BlockCodeTargetSharingScope);\n-  };\n-\n  protected:\n   inline const Register& AppropriateZeroRegFor(const CPURegister& reg) const;\n \n@@ -3341,16 +3311,6 @@ class Assembler : public AssemblerBase {\n   void RemoveBranchFromLabelLinkChain(Instruction* branch, Label* label,\n                                       Instruction* label_veneer = nullptr);\n \n-  // Prevent sharing of code target constant pool entries until\n-  // EndBlockCodeTargetSharing is called. Calls to this function can be nested\n-  // but must be followed by an equal number of call to\n-  // EndBlockCodeTargetSharing.\n-  void StartBlockCodeTargetSharing() { ++code_target_sharing_blocked_nesting_; }\n-\n-  // Resume sharing of constant pool code target entries. Needs to be called\n-  // as many times as StartBlockCodeTargetSharing to have an effect.\n-  void EndBlockCodeTargetSharing() { --code_target_sharing_blocked_nesting_; }\n-\n  private:\n   static uint32_t FPToImm8(double imm);\n \n@@ -3530,12 +3490,6 @@ class Assembler : public AssemblerBase {\n   // Emission of the veneer pools may be blocked in some code sequences.\n   int veneer_pool_blocked_nesting_;  // Block emission if this is not zero.\n \n-  // Sharing of code target entries may be blocked in some code sequences.\n-  int code_target_sharing_blocked_nesting_;\n-  bool IsCodeTargetSharingAllowed() const {\n-    return code_target_sharing_blocked_nesting_ == 0;\n-  }\n-\n   // Relocation info generation\n   // Each relocation is encoded as a variable size value\n   static constexpr int kMaxRelocSize = RelocInfoWriter::kMaxSize;\n@@ -3546,14 +3500,6 @@ class Assembler : public AssemblerBase {\n   // are already bound.\n   std::deque<int> internal_reference_positions_;\n \n-  // Before we copy code into the code space, we cannot encode calls to code\n-  // targets as we normally would, as the difference between the instruction's\n-  // location in the temporary buffer and the call target is not guaranteed to\n-  // fit in the offset field. We keep track of the code handles we encounter\n-  // in calls in this vector, and encode the index of the code handle in the\n-  // vector instead.\n-  std::vector<Handle<Code>> code_targets_;\n-\n   // Relocation info records are also used during code generation as temporary\n   // containers for constants and code target addresses until they are emitted\n   // to the constant pool. These pending relocation info records are temporarily\n@@ -3649,20 +3595,8 @@ class Assembler : public AssemblerBase {\n   // the length of the label chain.\n   void DeleteUnresolvedBranchInfoForLabelTraverse(Label* label);\n \n-  // The following functions help with avoiding allocations of embedded heap\n-  // objects during the code assembly phase. {RequestHeapObject} records the\n-  // need for a future heap number allocation or code stub generation. After\n-  // code assembly, {AllocateAndInstallRequestedHeapObjects} will allocate these\n-  // objects and place them where they are expected (determined by the pc offset\n-  // associated with each request). That is, for each request, it will patch the\n-  // dummy heap object handle that we emitted during code assembly with the\n-  // actual heap object handle.\n-  void RequestHeapObject(HeapObjectRequest request);\n   void AllocateAndInstallRequestedHeapObjects(Isolate* isolate);\n \n-  std::forward_list<HeapObjectRequest> heap_object_requests_;\n-\n- private:\n   friend class EnsureSpace;\n   friend class ConstPool;\n };\n@@ -3678,8 +3612,9 @@ class PatchingAssembler : public Assembler {\n   // relocation information takes space in the buffer, the PatchingAssembler\n   // will crash trying to grow the buffer.\n   // Note that the instruction cache will not be flushed.\n-  PatchingAssembler(IsolateData isolate_data, byte* start, unsigned count)\n-      : Assembler(isolate_data, start, count * kInstructionSize + kGap) {\n+  PatchingAssembler(const AssemblerOptions& options, byte* start,\n+                    unsigned count)\n+      : Assembler(options, start, count * kInstructionSize + kGap) {\n     // Block constant pool emission.\n     StartBlockPools();\n   }"
        },
        {
            "sha": "7a5f06c492131fc89ecb579a873b217a20490115",
            "filename": "deps/v8/src/arm64/code-stubs-arm64.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 333,
            "changes": 334,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fcode-stubs-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fcode-stubs-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fcode-stubs-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -29,21 +29,6 @@ namespace internal {\n \n #define __ ACCESS_MASM(masm)\n \n-void ArrayNArgumentsConstructorStub::Generate(MacroAssembler* masm) {\n-  __ Mov(x5, Operand(x0, LSL, kPointerSizeLog2));\n-  __ Poke(x1, Operand(x5));\n-  __ Push(x1, x2);\n-  __ Add(x0, x0, Operand(3));\n-  __ TailCallRuntime(Runtime::kNewArray);\n-}\n-\n-void CodeStub::GenerateStubsAheadOfTime(Isolate* isolate) {\n-  // It is important that the following stubs are generated in this order\n-  // because pregenerated stubs can only call other pregenerated stubs.\n-  CommonArrayConstructorStub::GenerateStubsAheadOfTime(isolate);\n-  StoreFastElementStub::GenerateAheadOfTime(isolate);\n-}\n-\n // This is the entry point from C++. 5 arguments are provided in x0-x4.\n // See use of the JSEntryFunction for example in src/execution.cc.\n // Input:\n@@ -324,322 +309,6 @@ void DirectCEntryStub::GenerateCall(MacroAssembler* masm,\n   __ Call(GetCode(), RelocInfo::CODE_TARGET);\n }\n \n-template<class T>\n-static void CreateArrayDispatch(MacroAssembler* masm,\n-                                AllocationSiteOverrideMode mode) {\n-  ASM_LOCATION(\"CreateArrayDispatch\");\n-  if (mode == DISABLE_ALLOCATION_SITES) {\n-    T stub(masm->isolate(), GetInitialFastElementsKind(), mode);\n-     __ TailCallStub(&stub);\n-\n-  } else if (mode == DONT_OVERRIDE) {\n-    Register kind = x3;\n-    int last_index =\n-        GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);\n-    for (int i = 0; i <= last_index; ++i) {\n-      Label next;\n-      ElementsKind candidate_kind = GetFastElementsKindFromSequenceIndex(i);\n-      // TODO(jbramley): Is this the best way to handle this? Can we make the\n-      // tail calls conditional, rather than hopping over each one?\n-      __ CompareAndBranch(kind, candidate_kind, ne, &next);\n-      T stub(masm->isolate(), candidate_kind);\n-      __ TailCallStub(&stub);\n-      __ Bind(&next);\n-    }\n-\n-    // If we reached this point there is a problem.\n-    __ Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n-\n-  } else {\n-    UNREACHABLE();\n-  }\n-}\n-\n-\n-// TODO(jbramley): If this needs to be a special case, make it a proper template\n-// specialization, and not a separate function.\n-static void CreateArrayDispatchOneArgument(MacroAssembler* masm,\n-                                           AllocationSiteOverrideMode mode) {\n-  ASM_LOCATION(\"CreateArrayDispatchOneArgument\");\n-  // x0 - argc\n-  // x1 - constructor?\n-  // x2 - allocation site (if mode != DISABLE_ALLOCATION_SITES)\n-  // x3 - kind (if mode != DISABLE_ALLOCATION_SITES)\n-  // sp[0] - last argument\n-\n-  Register allocation_site = x2;\n-  Register kind = x3;\n-\n-  STATIC_ASSERT(PACKED_SMI_ELEMENTS == 0);\n-  STATIC_ASSERT(HOLEY_SMI_ELEMENTS == 1);\n-  STATIC_ASSERT(PACKED_ELEMENTS == 2);\n-  STATIC_ASSERT(HOLEY_ELEMENTS == 3);\n-  STATIC_ASSERT(PACKED_DOUBLE_ELEMENTS == 4);\n-  STATIC_ASSERT(HOLEY_DOUBLE_ELEMENTS == 5);\n-\n-  if (mode == DISABLE_ALLOCATION_SITES) {\n-    ElementsKind initial = GetInitialFastElementsKind();\n-    ElementsKind holey_initial = GetHoleyElementsKind(initial);\n-\n-    ArraySingleArgumentConstructorStub stub_holey(masm->isolate(),\n-                                                  holey_initial,\n-                                                  DISABLE_ALLOCATION_SITES);\n-    __ TailCallStub(&stub_holey);\n-  } else if (mode == DONT_OVERRIDE) {\n-    // Is the low bit set? If so, the array is holey.\n-    Label normal_sequence;\n-    __ Tbnz(kind, 0, &normal_sequence);\n-\n-    // We are going to create a holey array, but our kind is non-holey.\n-    // Fix kind and retry (only if we have an allocation site in the slot).\n-    __ Orr(kind, kind, 1);\n-\n-    if (FLAG_debug_code) {\n-      __ Ldr(x10, FieldMemOperand(allocation_site, 0));\n-      __ JumpIfNotRoot(x10, Heap::kAllocationSiteMapRootIndex,\n-                       &normal_sequence);\n-      __ Assert(eq, AbortReason::kExpectedAllocationSite);\n-    }\n-\n-    // Save the resulting elements kind in type info. We can't just store 'kind'\n-    // in the AllocationSite::transition_info field because elements kind is\n-    // restricted to a portion of the field; upper bits need to be left alone.\n-    STATIC_ASSERT(AllocationSite::ElementsKindBits::kShift == 0);\n-    __ Ldr(x11,\n-           FieldMemOperand(allocation_site,\n-                           AllocationSite::kTransitionInfoOrBoilerplateOffset));\n-    __ Add(x11, x11, Smi::FromInt(kFastElementsKindPackedToHoley));\n-    __ Str(x11,\n-           FieldMemOperand(allocation_site,\n-                           AllocationSite::kTransitionInfoOrBoilerplateOffset));\n-\n-    __ Bind(&normal_sequence);\n-    int last_index =\n-        GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);\n-    for (int i = 0; i <= last_index; ++i) {\n-      Label next;\n-      ElementsKind candidate_kind = GetFastElementsKindFromSequenceIndex(i);\n-      __ CompareAndBranch(kind, candidate_kind, ne, &next);\n-      ArraySingleArgumentConstructorStub stub(masm->isolate(), candidate_kind);\n-      __ TailCallStub(&stub);\n-      __ Bind(&next);\n-    }\n-\n-    // If we reached this point there is a problem.\n-    __ Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n-  } else {\n-    UNREACHABLE();\n-  }\n-}\n-\n-\n-template<class T>\n-static void ArrayConstructorStubAheadOfTimeHelper(Isolate* isolate) {\n-  int to_index =\n-      GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);\n-  for (int i = 0; i <= to_index; ++i) {\n-    ElementsKind kind = GetFastElementsKindFromSequenceIndex(i);\n-    T stub(isolate, kind);\n-    stub.GetCode();\n-    if (AllocationSite::ShouldTrack(kind)) {\n-      T stub1(isolate, kind, DISABLE_ALLOCATION_SITES);\n-      stub1.GetCode();\n-    }\n-  }\n-}\n-\n-void CommonArrayConstructorStub::GenerateStubsAheadOfTime(Isolate* isolate) {\n-  ArrayConstructorStubAheadOfTimeHelper<ArrayNoArgumentConstructorStub>(\n-      isolate);\n-  ArrayConstructorStubAheadOfTimeHelper<ArraySingleArgumentConstructorStub>(\n-      isolate);\n-  ArrayNArgumentsConstructorStub stub(isolate);\n-  stub.GetCode();\n-  ElementsKind kinds[2] = {PACKED_ELEMENTS, HOLEY_ELEMENTS};\n-  for (int i = 0; i < 2; i++) {\n-    // For internal arrays we only need a few things\n-    InternalArrayNoArgumentConstructorStub stubh1(isolate, kinds[i]);\n-    stubh1.GetCode();\n-    InternalArraySingleArgumentConstructorStub stubh2(isolate, kinds[i]);\n-    stubh2.GetCode();\n-  }\n-}\n-\n-\n-void ArrayConstructorStub::GenerateDispatchToArrayStub(\n-    MacroAssembler* masm,\n-    AllocationSiteOverrideMode mode) {\n-  Register argc = x0;\n-  Label zero_case, n_case;\n-  __ Cbz(argc, &zero_case);\n-  __ Cmp(argc, 1);\n-  __ B(ne, &n_case);\n-\n-  // One argument.\n-  CreateArrayDispatchOneArgument(masm, mode);\n-\n-  __ Bind(&zero_case);\n-  // No arguments.\n-  CreateArrayDispatch<ArrayNoArgumentConstructorStub>(masm, mode);\n-\n-  __ Bind(&n_case);\n-  // N arguments.\n-  ArrayNArgumentsConstructorStub stub(masm->isolate());\n-  __ TailCallStub(&stub);\n-}\n-\n-\n-void ArrayConstructorStub::Generate(MacroAssembler* masm) {\n-  ASM_LOCATION(\"ArrayConstructorStub::Generate\");\n-  // ----------- S t a t e -------------\n-  //  -- x0 : argc (only if argument_count() is ANY or MORE_THAN_ONE)\n-  //  -- x1 : constructor\n-  //  -- x2 : AllocationSite or undefined\n-  //  -- x3 : new target\n-  //  -- sp[0] : last argument\n-  // -----------------------------------\n-  Register constructor = x1;\n-  Register allocation_site = x2;\n-  Register new_target = x3;\n-\n-  if (FLAG_debug_code) {\n-    // The array construct code is only set for the global and natives\n-    // builtin Array functions which always have maps.\n-\n-    Label unexpected_map, map_ok;\n-    // Initial map for the builtin Array function should be a map.\n-    __ Ldr(x10, FieldMemOperand(constructor,\n-                                JSFunction::kPrototypeOrInitialMapOffset));\n-    // Will both indicate a nullptr and a Smi.\n-    __ JumpIfSmi(x10, &unexpected_map);\n-    __ JumpIfObjectType(x10, x10, x11, MAP_TYPE, &map_ok);\n-    __ Bind(&unexpected_map);\n-    __ Abort(AbortReason::kUnexpectedInitialMapForArrayFunction);\n-    __ Bind(&map_ok);\n-\n-    // We should either have undefined in the allocation_site register or a\n-    // valid AllocationSite.\n-    __ AssertUndefinedOrAllocationSite(allocation_site);\n-  }\n-\n-  // Enter the context of the Array function.\n-  __ Ldr(cp, FieldMemOperand(x1, JSFunction::kContextOffset));\n-\n-  Label subclassing;\n-  __ Cmp(new_target, constructor);\n-  __ B(ne, &subclassing);\n-\n-  Register kind = x3;\n-  Label no_info;\n-  // Get the elements kind and case on that.\n-  __ JumpIfRoot(allocation_site, Heap::kUndefinedValueRootIndex, &no_info);\n-\n-  __ Ldrsw(kind, UntagSmiFieldMemOperand(\n-                     allocation_site,\n-                     AllocationSite::kTransitionInfoOrBoilerplateOffset));\n-  __ And(kind, kind, AllocationSite::ElementsKindBits::kMask);\n-  GenerateDispatchToArrayStub(masm, DONT_OVERRIDE);\n-\n-  __ Bind(&no_info);\n-  GenerateDispatchToArrayStub(masm, DISABLE_ALLOCATION_SITES);\n-\n-  // Subclassing support.\n-  __ Bind(&subclassing);\n-  __ Poke(constructor, Operand(x0, LSL, kPointerSizeLog2));\n-  __ Add(x0, x0, Operand(3));\n-  __ Push(new_target, allocation_site);\n-  __ JumpToExternalReference(ExternalReference::Create(Runtime::kNewArray));\n-}\n-\n-\n-void InternalArrayConstructorStub::GenerateCase(\n-    MacroAssembler* masm, ElementsKind kind) {\n-  Label zero_case, n_case;\n-  Register argc = x0;\n-\n-  __ Cbz(argc, &zero_case);\n-  __ CompareAndBranch(argc, 1, ne, &n_case);\n-\n-  // One argument.\n-  if (IsFastPackedElementsKind(kind)) {\n-    Label packed_case;\n-\n-    // We might need to create a holey array; look at the first argument.\n-    __ Peek(x10, 0);\n-    __ Cbz(x10, &packed_case);\n-\n-    InternalArraySingleArgumentConstructorStub\n-        stub1_holey(isolate(), GetHoleyElementsKind(kind));\n-    __ TailCallStub(&stub1_holey);\n-\n-    __ Bind(&packed_case);\n-  }\n-  InternalArraySingleArgumentConstructorStub stub1(isolate(), kind);\n-  __ TailCallStub(&stub1);\n-\n-  __ Bind(&zero_case);\n-  // No arguments.\n-  InternalArrayNoArgumentConstructorStub stub0(isolate(), kind);\n-  __ TailCallStub(&stub0);\n-\n-  __ Bind(&n_case);\n-  // N arguments.\n-  ArrayNArgumentsConstructorStub stubN(isolate());\n-  __ TailCallStub(&stubN);\n-}\n-\n-\n-void InternalArrayConstructorStub::Generate(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- x0 : argc\n-  //  -- x1 : constructor\n-  //  -- sp[0] : return address\n-  //  -- sp[4] : last argument\n-  // -----------------------------------\n-\n-  Register constructor = x1;\n-\n-  if (FLAG_debug_code) {\n-    // The array construct code is only set for the global and natives\n-    // builtin Array functions which always have maps.\n-\n-    Label unexpected_map, map_ok;\n-    // Initial map for the builtin Array function should be a map.\n-    __ Ldr(x10, FieldMemOperand(constructor,\n-                                JSFunction::kPrototypeOrInitialMapOffset));\n-    // Will both indicate a nullptr and a Smi.\n-    __ JumpIfSmi(x10, &unexpected_map);\n-    __ JumpIfObjectType(x10, x10, x11, MAP_TYPE, &map_ok);\n-    __ Bind(&unexpected_map);\n-    __ Abort(AbortReason::kUnexpectedInitialMapForArrayFunction);\n-    __ Bind(&map_ok);\n-  }\n-\n-  Register kind = w3;\n-  // Figure out the right elements kind\n-  __ Ldr(x10, FieldMemOperand(constructor,\n-                              JSFunction::kPrototypeOrInitialMapOffset));\n-\n-  // Retrieve elements_kind from map.\n-  __ LoadElementsKindFromMap(kind, x10);\n-\n-  if (FLAG_debug_code) {\n-    Label done;\n-    __ Cmp(x3, PACKED_ELEMENTS);\n-    __ Ccmp(x3, HOLEY_ELEMENTS, ZFlag, ne);\n-    __ Assert(\n-        eq,\n-        AbortReason::kInvalidElementsKindForInternalArrayOrInternalPackedArray);\n-  }\n-\n-  Label fast_elements_case;\n-  __ CompareAndBranch(kind, PACKED_ELEMENTS, eq, &fast_elements_case);\n-  GenerateCase(masm, HOLEY_ELEMENTS);\n-\n-  __ Bind(&fast_elements_case);\n-  GenerateCase(masm, PACKED_ELEMENTS);\n-}\n-\n // The number of register that CallApiFunctionAndReturn will need to save on\n // the stack. The space for these registers need to be allocated in the\n // ExitFrame before calling CallApiFunctionAndReturn.\n@@ -894,8 +563,7 @@ void CallApiGetterStub::Generate(MacroAssembler* masm) {\n \n   __ Ldr(data, FieldMemOperand(callback, AccessorInfo::kDataOffset));\n   __ LoadRoot(undef, Heap::kUndefinedValueRootIndex);\n-  __ Mov(isolate_address,\n-         Operand(ExternalReference::isolate_address(isolate())));\n+  __ Mov(isolate_address, ExternalReference::isolate_address(isolate()));\n   __ Ldr(name, FieldMemOperand(callback, AccessorInfo::kNameOffset));\n \n   // PropertyCallbackArguments:"
        },
        {
            "sha": "1b87ce572c6f38689f788ca41a110f62ffdeeac0",
            "filename": "deps/v8/src/arm64/constants-arm64.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fconstants-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fconstants-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fconstants-arm64.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -26,6 +26,7 @@ STATIC_ASSERT(sizeof(1L) == sizeof(int64_t));\n namespace v8 {\n namespace internal {\n \n+constexpr size_t kMaxPCRelativeCodeRangeInMB = 128;\n \n const unsigned kInstructionSize = 4;\n const unsigned kInstructionSizeLog2 = 2;\n@@ -140,6 +141,11 @@ const unsigned kFloat16MantissaBits = 10;\n const unsigned kFloat16ExponentBits = 5;\n const unsigned kFloat16ExponentBias = 15;\n \n+// Actual value of root register is offset from the root array's start\n+// to take advantage of negative displacement values.\n+// TODO(sigurds): Choose best value.\n+constexpr int kRootRegisterBias = 256;\n+\n typedef uint16_t float16;\n \n #define INSTRUCTION_FIELDS_LIST(V_)                     \\"
        },
        {
            "sha": "b2f534ac457e2965605eaf9fd51c1b8557553684",
            "filename": "deps/v8/src/arm64/deoptimizer-arm64.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 41,
            "changes": 50,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fdeoptimizer-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fdeoptimizer-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fdeoptimizer-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -155,7 +155,7 @@ void Deoptimizer::TableEntryGenerator::Generate() {\n   __ Tst(x1, kSmiTagMask);\n   __ CzeroX(x0, eq);\n \n-  __ Mov(x1, type());\n+  __ Mov(x1, static_cast<int>(deopt_kind()));\n   // Following arguments are already loaded:\n   //  - x2: bailout id\n   //  - x3: code object address\n@@ -275,50 +275,18 @@ void Deoptimizer::TableEntryGenerator::Generate() {\n   __ Br(continuation);\n }\n \n-// Size of an entry of the second level deopt table.\n-// This is the code size generated by GeneratePrologue for one entry.\n-const int Deoptimizer::table_entry_size_ = kInstructionSize;\n+// Size of an entry of the second level deopt table. Since we do not generate\n+// a table for ARM64, the size is zero.\n+const int Deoptimizer::table_entry_size_ = 0 * kInstructionSize;\n \n void Deoptimizer::TableEntryGenerator::GeneratePrologue() {\n   UseScratchRegisterScope temps(masm());\n-  // The address at which the deopt table is entered should be in x16, the first\n-  // temp register allocated. We can't assert that the address is in there, but\n-  // we can check that it's the first allocated temp. Later, we'll also check\n-  // the computed entry_id is in the expected range.\n-  Register entry_addr = temps.AcquireX();\n+  // The MacroAssembler will have put the deoptimization id in x16, the first\n+  // temp register allocated. We can't assert that the id is in there, but we\n+  // can check that x16 the first allocated temp and that the value it contains\n+  // is in the expected range.\n   Register entry_id = temps.AcquireX();\n-  DCHECK(entry_addr.Is(x16));\n-  DCHECK(entry_id.Is(x17));\n-\n-  // Create a sequence of deoptimization entries.\n-  // Note that registers are still live when jumping to an entry.\n-  {\n-    InstructionAccurateScope scope(masm());\n-\n-    Label start_of_table, end_of_table;\n-    __ bind(&start_of_table);\n-    for (int i = 0; i < count(); i++) {\n-      int start = masm()->pc_offset();\n-      USE(start);\n-      __ b(&end_of_table);\n-      DCHECK(masm()->pc_offset() - start == table_entry_size_);\n-    }\n-    __ bind(&end_of_table);\n-\n-    // Get the address of the start of the table.\n-    DCHECK(is_int21(table_entry_size_ * count()));\n-    __ adr(entry_id, &start_of_table);\n-\n-    // Compute the gap in bytes between the entry address, which should have\n-    // been left in entry_addr (x16) by CallForDeoptimization, and the start of\n-    // the table.\n-    __ sub(entry_id, entry_addr, entry_id);\n-\n-    // Shift down to obtain the entry_id.\n-    DCHECK_EQ(table_entry_size_, kInstructionSize);\n-    __ lsr(entry_id, entry_id, kInstructionSizeLog2);\n-  }\n-\n+  DCHECK(entry_id.Is(x16));\n   __ Push(padreg, entry_id);\n \n   if (__ emit_debug_code()) {"
        },
        {
            "sha": "96fc72f126b8ad415981017c3ea0e790308b2591",
            "filename": "deps/v8/src/arm64/frame-constants-arm64.h",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fframe-constants-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fframe-constants-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fframe-constants-arm64.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -5,6 +5,10 @@\n #ifndef V8_ARM64_FRAME_CONSTANTS_ARM64_H_\n #define V8_ARM64_FRAME_CONSTANTS_ARM64_H_\n \n+#include \"src/base/macros.h\"\n+#include \"src/frame-constants.h\"\n+#include \"src/globals.h\"\n+\n namespace v8 {\n namespace internal {\n \n@@ -46,6 +50,20 @@ class ExitFrameConstants : public TypedFrameConstants {\n   static constexpr int kConstantPoolOffset = 0;  // Not used\n };\n \n+class WasmCompileLazyFrameConstants : public TypedFrameConstants {\n+ public:\n+  static constexpr int kNumberOfSavedGpParamRegs = 8;\n+  static constexpr int kNumberOfSavedFpParamRegs = 8;\n+\n+  // FP-relative.\n+  static constexpr int kWasmInstanceOffset = TYPED_FRAME_PUSHED_VALUE_OFFSET(1);\n+  static constexpr int kFixedFrameSizeFromFp =\n+      // Header is padded to 16 byte (see {MacroAssembler::EnterFrame}).\n+      RoundUp<16>(TypedFrameConstants::kFixedFrameSizeFromFp) +\n+      kNumberOfSavedGpParamRegs * kPointerSize +\n+      kNumberOfSavedFpParamRegs * kDoubleSize;\n+};\n+\n class JavaScriptFrameConstants : public AllStatic {\n  public:\n   // FP-relative."
        },
        {
            "sha": "4a10594590230850eedd32c6b1c2fa4165fba620",
            "filename": "deps/v8/src/arm64/instructions-arm64.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Finstructions-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Finstructions-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Finstructions-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -227,21 +227,21 @@ bool Instruction::IsTargetInImmPCOffsetRange(Instruction* target) {\n   return IsValidImmPCOffset(BranchType(), DistanceTo(target));\n }\n \n-void Instruction::SetImmPCOffsetTarget(Assembler::IsolateData isolate_data,\n+void Instruction::SetImmPCOffsetTarget(const AssemblerOptions& options,\n                                        Instruction* target) {\n   if (IsPCRelAddressing()) {\n-    SetPCRelImmTarget(isolate_data, target);\n+    SetPCRelImmTarget(options, target);\n   } else if (BranchType() != UnknownBranchType) {\n     SetBranchImmTarget(target);\n   } else if (IsUnresolvedInternalReference()) {\n-    SetUnresolvedInternalReferenceImmTarget(isolate_data, target);\n+    SetUnresolvedInternalReferenceImmTarget(options, target);\n   } else {\n     // Load literal (offset from PC).\n     SetImmLLiteral(target);\n   }\n }\n \n-void Instruction::SetPCRelImmTarget(Assembler::IsolateData isolate_data,\n+void Instruction::SetPCRelImmTarget(const AssemblerOptions& options,\n                                     Instruction* target) {\n   // ADRP is not supported, so 'this' must point to an ADR instruction.\n   DCHECK(IsAdr());\n@@ -252,7 +252,7 @@ void Instruction::SetPCRelImmTarget(Assembler::IsolateData isolate_data,\n     imm = Assembler::ImmPCRelAddress(static_cast<int>(target_offset));\n     SetInstructionBits(Mask(~ImmPCRel_mask) | imm);\n   } else {\n-    PatchingAssembler patcher(isolate_data, reinterpret_cast<byte*>(this),\n+    PatchingAssembler patcher(options, reinterpret_cast<byte*>(this),\n                               PatchingAssembler::kAdrFarPatchableNInstrs);\n     patcher.PatchAdrFar(target_offset);\n   }\n@@ -293,7 +293,7 @@ void Instruction::SetBranchImmTarget(Instruction* target) {\n }\n \n void Instruction::SetUnresolvedInternalReferenceImmTarget(\n-    Assembler::IsolateData isolate_data, Instruction* target) {\n+    const AssemblerOptions& options, Instruction* target) {\n   DCHECK(IsUnresolvedInternalReference());\n   DCHECK(IsAligned(DistanceTo(target), kInstructionSize));\n   DCHECK(is_int32(DistanceTo(target) >> kInstructionSizeLog2));\n@@ -302,7 +302,7 @@ void Instruction::SetUnresolvedInternalReferenceImmTarget(\n   uint32_t high16 = unsigned_bitextract_32(31, 16, target_offset);\n   uint32_t low16 = unsigned_bitextract_32(15, 0, target_offset);\n \n-  PatchingAssembler patcher(isolate_data, reinterpret_cast<byte*>(this), 2);\n+  PatchingAssembler patcher(options, reinterpret_cast<byte*>(this), 2);\n   patcher.brk(high16);\n   patcher.brk(low16);\n }"
        },
        {
            "sha": "bb1791becb5f3f3d1d2c89183997551685da9605",
            "filename": "deps/v8/src/arm64/instructions-arm64.h",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Finstructions-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Finstructions-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Finstructions-arm64.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -402,9 +402,9 @@ class Instruction {\n   bool IsTargetInImmPCOffsetRange(Instruction* target);\n   // Patch a PC-relative offset to refer to 'target'. 'this' may be a branch or\n   // a PC-relative addressing instruction.\n-  void SetImmPCOffsetTarget(AssemblerBase::IsolateData isolate_data,\n+  void SetImmPCOffsetTarget(const AssemblerOptions& options,\n                             Instruction* target);\n-  void SetUnresolvedInternalReferenceImmTarget(AssemblerBase::IsolateData,\n+  void SetUnresolvedInternalReferenceImmTarget(const AssemblerOptions& options,\n                                                Instruction* target);\n   // Patch a literal load instruction to load from 'source'.\n   void SetImmLLiteral(Instruction* source);\n@@ -441,8 +441,7 @@ class Instruction {\n \n   static const int ImmPCRelRangeBitwidth = 21;\n   static bool IsValidPCRelOffset(ptrdiff_t offset) { return is_int21(offset); }\n-  void SetPCRelImmTarget(AssemblerBase::IsolateData isolate_data,\n-                         Instruction* target);\n+  void SetPCRelImmTarget(const AssemblerOptions& options, Instruction* target);\n   void SetBranchImmTarget(Instruction* target);\n };\n "
        },
        {
            "sha": "10d8ee4bc72456d73af41056246ece80b8aad832",
            "filename": "deps/v8/src/arm64/instrument-arm64.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Finstrument-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Finstrument-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Finstrument-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -69,6 +69,7 @@ static const CounterDescriptor kCounterList[] = {\n     {\"Logical DP\", Gauge},\n     {\"Other Int DP\", Gauge},\n     {\"FP DP\", Gauge},\n+    {\"NEON\", Gauge},\n \n     {\"Conditional Select\", Gauge},\n     {\"Conditional Compare\", Gauge},"
        },
        {
            "sha": "357161d57fa7711cede72ca0c6fc515fe57b240c",
            "filename": "deps/v8/src/arm64/interface-descriptors-arm64.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 75,
            "changes": 94,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Finterface-descriptors-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Finterface-descriptors-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Finterface-descriptors-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \"src/arm64/interface-descriptors-arm64.h\"\n-\n #if V8_TARGET_ARCH_ARM64\n \n #include \"src/interface-descriptors.h\"\n@@ -59,12 +57,6 @@ const Register StoreTransitionDescriptor::MapRegister() { return x5; }\n const Register ApiGetterDescriptor::HolderRegister() { return x0; }\n const Register ApiGetterDescriptor::CallbackRegister() { return x3; }\n \n-const Register MathPowTaggedDescriptor::exponent() { return x11; }\n-\n-\n-const Register MathPowIntegerDescriptor::exponent() { return x12; }\n-\n-\n const Register GrowArrayElementsDescriptor::ObjectRegister() { return x0; }\n const Register GrowArrayElementsDescriptor::KeyRegister() { return x3; }\n \n@@ -179,68 +171,15 @@ void ConstructStubDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n-\n-void ConstructTrampolineDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // x3: new target\n-  // x1: target\n-  // x0: number of arguments\n-  Register registers[] = {x1, x3, x0};\n-  data->InitializePlatformSpecific(arraysize(registers), registers);\n-}\n-\n-\n-void TransitionElementsKindDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // x0: value (js_array)\n-  // x1: to_map\n-  Register registers[] = {x0, x1};\n-  data->InitializePlatformSpecific(arraysize(registers), registers);\n-}\n-\n-void AbortJSDescriptor::InitializePlatformSpecific(\n+void AbortDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n   Register registers[] = {x1};\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n void AllocateHeapNumberDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n-  data->InitializePlatformSpecific(0, nullptr, nullptr);\n-}\n-\n-void ArrayConstructorDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // kTarget, kNewTarget, kActualArgumentsCount, kAllocationSite\n-  Register registers[] = {x1, x3, x0, x2};\n-  data->InitializePlatformSpecific(arraysize(registers), registers, nullptr);\n-}\n-\n-void ArrayNoArgumentConstructorDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // register state\n-  // x1: function\n-  // x2: allocation site with elements kind\n-  // x0: number of arguments to the constructor function\n-  Register registers[] = {x1, x2, x0};\n-  data->InitializePlatformSpecific(arraysize(registers), registers, nullptr);\n-}\n-\n-void ArraySingleArgumentConstructorDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // register state\n-  // x0: number of arguments\n-  // x1: function\n-  // x2: allocation site with elements kind\n-  Register registers[] = {x1, x2, x0};\n-  data->InitializePlatformSpecific(arraysize(registers), registers, nullptr);\n-}\n-\n-void ArrayNArgumentsConstructorDescriptor::InitializePlatformSpecific(\n-    CallInterfaceDescriptorData* data) {\n-  // stack param count needs (constructor pointer, and single argument)\n-  Register registers[] = {x1, x2, x0};\n-  data->InitializePlatformSpecific(arraysize(registers), registers);\n+  data->InitializePlatformSpecific(0, nullptr);\n }\n \n void CompareDescriptor::InitializePlatformSpecific(\n@@ -251,7 +190,6 @@ void CompareDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n-\n void BinaryOpDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n   // x1: left operand\n@@ -262,32 +200,24 @@ void BinaryOpDescriptor::InitializePlatformSpecific(\n \n void ArgumentAdaptorDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n-  static PlatformInterfaceDescriptor default_descriptor =\n-      PlatformInterfaceDescriptor(CAN_INLINE_TARGET_ADDRESS);\n-\n   Register registers[] = {\n       x1,  // JSFunction\n       x3,  // the new target\n       x0,  // actual number of arguments\n       x2,  // expected number of arguments\n   };\n-  data->InitializePlatformSpecific(arraysize(registers), registers,\n-                                   &default_descriptor);\n+  data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n void ApiCallbackDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n-  static PlatformInterfaceDescriptor default_descriptor =\n-      PlatformInterfaceDescriptor(CAN_INLINE_TARGET_ADDRESS);\n-\n   Register registers[] = {\n       JavaScriptFrame::context_register(),  // callee context\n       x4,                                   // call_data\n       x2,                                   // holder\n       x1,                                   // api_function_address\n   };\n-  data->InitializePlatformSpecific(arraysize(registers), registers,\n-                                   &default_descriptor);\n+  data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n void InterpreterDispatchDescriptor::InitializePlatformSpecific(\n@@ -320,7 +250,9 @@ void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n-void InterpreterCEntryDescriptor::InitializePlatformSpecific(\n+namespace {\n+\n+void InterpreterCEntryDescriptor_InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n   Register registers[] = {\n       x0,   // argument count (argc)\n@@ -330,6 +262,18 @@ void InterpreterCEntryDescriptor::InitializePlatformSpecific(\n   data->InitializePlatformSpecific(arraysize(registers), registers);\n }\n \n+}  // namespace\n+\n+void InterpreterCEntry1Descriptor::InitializePlatformSpecific(\n+    CallInterfaceDescriptorData* data) {\n+  InterpreterCEntryDescriptor_InitializePlatformSpecific(data);\n+}\n+\n+void InterpreterCEntry2Descriptor::InitializePlatformSpecific(\n+    CallInterfaceDescriptorData* data) {\n+  InterpreterCEntryDescriptor_InitializePlatformSpecific(data);\n+}\n+\n void ResumeGeneratorDescriptor::InitializePlatformSpecific(\n     CallInterfaceDescriptorData* data) {\n   Register registers[] = {"
        },
        {
            "sha": "20ab8cb61243bceff9e8d7fa70803c13e5462952",
            "filename": "deps/v8/src/arm64/interface-descriptors-arm64.h",
            "status": "removed",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Farm64%2Finterface-descriptors-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Farm64%2Finterface-descriptors-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Finterface-descriptors-arm64.h?ref=12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342",
            "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 the V8 project authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#ifndef V8_ARM64_INTERFACE_DESCRIPTORS_ARM64_H_\n-#define V8_ARM64_INTERFACE_DESCRIPTORS_ARM64_H_\n-\n-#include \"src/interface-descriptors.h\"\n-\n-namespace v8 {\n-namespace internal {\n-\n-class PlatformInterfaceDescriptor {\n- public:\n-  explicit PlatformInterfaceDescriptor(TargetAddressStorageMode storage_mode)\n-      : storage_mode_(storage_mode) {}\n-\n-  TargetAddressStorageMode storage_mode() { return storage_mode_; }\n-\n- private:\n-  TargetAddressStorageMode storage_mode_;\n-};\n-}  // namespace internal\n-}  // namespace v8\n-\n-#endif  // V8_ARM64_INTERFACE_DESCRIPTORS_ARM64_H_"
        },
        {
            "sha": "b583d7ba14b384cde67fd99f38089922b310de69",
            "filename": "deps/v8/src/arm64/macro-assembler-arm64-inl.h",
            "status": "modified",
            "additions": 32,
            "deletions": 29,
            "changes": 61,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64-inl.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -24,17 +24,6 @@ MemOperand FieldMemOperand(Register object, int offset) {\n }\n \n \n-MemOperand UntagSmiFieldMemOperand(Register object, int offset) {\n-  return UntagSmiMemOperand(object, offset - kHeapObjectTag);\n-}\n-\n-\n-MemOperand UntagSmiMemOperand(Register object, int offset) {\n-  // Assumes that Smis are shifted by 32 bits and little endianness.\n-  STATIC_ASSERT(kSmiShift == 32);\n-  return MemOperand(object, offset + (kSmiShift / kBitsPerByte));\n-}\n-\n void TurboAssembler::And(const Register& rd, const Register& rn,\n                          const Operand& operand) {\n   DCHECK(allow_macro_instructions());\n@@ -297,6 +286,7 @@ void TurboAssembler::Asr(const Register& rd, const Register& rn,\n }\n \n void TurboAssembler::B(Label* label) {\n+  DCHECK(allow_macro_instructions());\n   b(label);\n   CheckVeneerPool(false, false);\n }\n@@ -1040,46 +1030,50 @@ void TurboAssembler::InitializeRootRegister() {\n   ExternalReference roots_array_start =\n       ExternalReference::roots_array_start(isolate());\n   Mov(kRootRegister, Operand(roots_array_start));\n+  Add(kRootRegister, kRootRegister, kRootRegisterBias);\n }\n \n \n void MacroAssembler::SmiTag(Register dst, Register src) {\n-  STATIC_ASSERT(kXRegSizeInBits ==\n-                static_cast<unsigned>(kSmiShift + kSmiValueSize));\n   DCHECK(dst.Is64Bits() && src.Is64Bits());\n+  DCHECK(SmiValuesAre32Bits() || SmiValuesAre31Bits());\n   Lsl(dst, src, kSmiShift);\n }\n \n-\n void MacroAssembler::SmiTag(Register smi) { SmiTag(smi, smi); }\n \n void TurboAssembler::SmiUntag(Register dst, Register src) {\n-  STATIC_ASSERT(kXRegSizeInBits ==\n-                static_cast<unsigned>(kSmiShift + kSmiValueSize));\n   DCHECK(dst.Is64Bits() && src.Is64Bits());\n   if (FLAG_enable_slow_asserts) {\n     AssertSmi(src);\n   }\n+  DCHECK(SmiValuesAre32Bits() || SmiValuesAre31Bits());\n   Asr(dst, src, kSmiShift);\n }\n \n-void TurboAssembler::SmiUntag(Register smi) { SmiUntag(smi, smi); }\n+void TurboAssembler::SmiUntag(Register dst, const MemOperand& src) {\n+  DCHECK(dst.Is64Bits());\n+  if (SmiValuesAre32Bits()) {\n+    if (src.IsImmediateOffset() && src.shift_amount() == 0) {\n+      // Load value directly from the upper half-word.\n+      // Assumes that Smis are shifted by 32 bits and little endianness.\n+      DCHECK_EQ(kSmiShift, 32);\n+      Ldrsw(dst,\n+            MemOperand(src.base(), src.offset() + (kSmiShift / kBitsPerByte),\n+                       src.addrmode()));\n \n-void MacroAssembler::SmiUntagToDouble(VRegister dst, Register src) {\n-  DCHECK(dst.Is64Bits() && src.Is64Bits());\n-  if (FLAG_enable_slow_asserts) {\n-    AssertSmi(src);\n+    } else {\n+      Ldr(dst, src);\n+      SmiUntag(dst);\n+    }\n+  } else {\n+    DCHECK(SmiValuesAre31Bits());\n+    Ldr(dst, src);\n+    SmiUntag(dst);\n   }\n-  Scvtf(dst, src, kSmiShift);\n }\n \n-void MacroAssembler::SmiUntagToFloat(VRegister dst, Register src) {\n-  DCHECK(dst.Is32Bits() && src.Is64Bits());\n-  if (FLAG_enable_slow_asserts) {\n-    AssertSmi(src);\n-  }\n-  Scvtf(dst, src, kSmiShift);\n-}\n+void TurboAssembler::SmiUntag(Register smi) { SmiUntag(smi, smi); }\n \n void TurboAssembler::JumpIfSmi(Register value, Label* smi_label,\n                                Label* not_smi_label) {\n@@ -1096,6 +1090,15 @@ void TurboAssembler::JumpIfSmi(Register value, Label* smi_label,\n   }\n }\n \n+void TurboAssembler::JumpIfEqual(Register x, int32_t y, Label* dest) {\n+  Cmp(x, y);\n+  B(eq, dest);\n+}\n+\n+void TurboAssembler::JumpIfLessThan(Register x, int32_t y, Label* dest) {\n+  Cmp(x, y);\n+  B(lt, dest);\n+}\n \n void MacroAssembler::JumpIfNotSmi(Register value, Label* not_smi_label) {\n   JumpIfSmi(value, nullptr, not_smi_label);"
        },
        {
            "sha": "74583523afe971916c74168689697f40376ca2b8",
            "filename": "deps/v8/src/arm64/macro-assembler-arm64.cc",
            "status": "modified",
            "additions": 138,
            "deletions": 152,
            "changes": 290,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -8,7 +8,6 @@\n #include \"src/base/bits.h\"\n #include \"src/base/division-by-constant.h\"\n #include \"src/bootstrapper.h\"\n-#include \"src/builtins/constants-table-builder.h\"\n #include \"src/callable.h\"\n #include \"src/code-factory.h\"\n #include \"src/code-stubs.h\"\n@@ -20,18 +19,18 @@\n #include \"src/instruction-stream.h\"\n #include \"src/register-configuration.h\"\n #include \"src/runtime/runtime.h\"\n-#include \"src/snapshot/serializer-common.h\"\n+#include \"src/snapshot/snapshot.h\"\n \n #include \"src/arm64/macro-assembler-arm64-inl.h\"\n #include \"src/arm64/macro-assembler-arm64.h\"  // Cannot be the first include\n \n namespace v8 {\n namespace internal {\n \n-MacroAssembler::MacroAssembler(Isolate* isolate, byte* buffer,\n-                               unsigned buffer_size,\n-                               CodeObjectRequired create_code_object)\n-    : TurboAssembler(isolate, buffer, buffer_size, create_code_object) {\n+MacroAssembler::MacroAssembler(Isolate* isolate,\n+                               const AssemblerOptions& options, void* buffer,\n+                               int size, CodeObjectRequired create_code_object)\n+    : TurboAssembler(isolate, options, buffer, size, create_code_object) {\n   if (create_code_object == CodeObjectRequired::kYes) {\n     // Unlike TurboAssembler, which can be used off the main thread and may not\n     // allocate, macro assembler creates its own copy of the self-reference\n@@ -49,22 +48,6 @@ CPURegList TurboAssembler::DefaultFPTmpList() {\n   return CPURegList(fp_scratch1, fp_scratch2);\n }\n \n-TurboAssembler::TurboAssembler(Isolate* isolate, void* buffer, int buffer_size,\n-                               CodeObjectRequired create_code_object)\n-    : Assembler(isolate, buffer, buffer_size),\n-      isolate_(isolate),\n-#if DEBUG\n-      allow_macro_instructions_(true),\n-#endif\n-      tmp_list_(DefaultTmpList()),\n-      fptmp_list_(DefaultFPTmpList()),\n-      use_real_aborts_(true) {\n-  if (create_code_object == CodeObjectRequired::kYes) {\n-    code_object_ = Handle<HeapObject>::New(\n-        isolate->heap()->self_reference_marker(), isolate);\n-  }\n-}\n-\n int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,\n                                                     Register exclusion) const {\n   int bytes = 0;\n@@ -365,12 +348,12 @@ void TurboAssembler::Mov(const Register& rd, const Operand& operand,\n }\n \n void TurboAssembler::Mov(const Register& rd, ExternalReference reference) {\n-#ifdef V8_EMBEDDED_BUILTINS\n-  if (root_array_available_ && isolate()->ShouldLoadConstantsFromRootList()) {\n-    LookupExternalReference(rd, reference);\n-    return;\n+  if (FLAG_embedded_builtins) {\n+    if (root_array_available_ && options().isolate_independent_code) {\n+      IndirectLoadExternalReference(rd, reference);\n+      return;\n+    }\n   }\n-#endif  // V8_EMBEDDED_BUILTINS\n   Mov(rd, Operand(reference));\n }\n \n@@ -1445,7 +1428,8 @@ void MacroAssembler::PopCalleeSavedRegisters() {\n }\n \n void TurboAssembler::AssertSpAligned() {\n-  if (emit_debug_code() && use_real_aborts()) {\n+  if (emit_debug_code()) {\n+    TrapOnAbortScope trap_on_abort_scope(this);  // Avoid calls to Abort.\n     // Arm64 requires the stack pointer to be 16-byte aligned prior to address\n     // calculation.\n     UseScratchRegisterScope scope(this);\n@@ -1569,11 +1553,10 @@ void TurboAssembler::CanonicalizeNaN(const VRegister& dst,\n   Fsub(dst, src, fp_zero);\n }\n \n-void TurboAssembler::LoadRoot(CPURegister destination,\n-                              Heap::RootListIndex index) {\n+void TurboAssembler::LoadRoot(Register destination, Heap::RootListIndex index) {\n   // TODO(jbramley): Most root values are constants, and can be synthesized\n   // without a load. Refer to the ARM back end for details.\n-  Ldr(destination, MemOperand(kRootRegister, index << kPointerSizeLog2));\n+  Ldr(destination, MemOperand(kRootRegister, RootRegisterOffset(index)));\n }\n \n \n@@ -1588,14 +1571,14 @@ void MacroAssembler::LoadObject(Register result, Handle<Object> object) {\n \n void TurboAssembler::Move(Register dst, Register src) { Mov(dst, src); }\n \n-void TurboAssembler::Move(Register dst, Handle<HeapObject> x) {\n-#ifdef V8_EMBEDDED_BUILTINS\n-  if (root_array_available_ && isolate()->ShouldLoadConstantsFromRootList()) {\n-    LookupConstant(dst, x);\n-    return;\n+void TurboAssembler::Move(Register dst, Handle<HeapObject> value) {\n+  if (FLAG_embedded_builtins) {\n+    if (root_array_available_ && options().isolate_independent_code) {\n+      IndirectLoadConstant(dst, value);\n+      return;\n+    }\n   }\n-#endif  // V8_EMBEDDED_BUILTINS\n-  Mov(dst, x);\n+  Mov(dst, value);\n }\n \n void TurboAssembler::Move(Register dst, Smi* src) { Mov(dst, src); }\n@@ -1644,18 +1627,6 @@ void MacroAssembler::AssertNotSmi(Register object, AbortReason reason) {\n   }\n }\n \n-void MacroAssembler::AssertFixedArray(Register object) {\n-  if (emit_debug_code()) {\n-    AssertNotSmi(object, AbortReason::kOperandIsASmiAndNotAFixedArray);\n-\n-    UseScratchRegisterScope temps(this);\n-    Register temp = temps.AcquireX();\n-\n-    CompareObjectType(object, temp, temp, FIXED_ARRAY_TYPE);\n-    Check(eq, AbortReason::kOperandIsNotAFixedArray);\n-  }\n-}\n-\n void MacroAssembler::AssertConstructor(Register object) {\n   if (emit_debug_code()) {\n     AssertNotSmi(object, AbortReason::kOperandIsASmiAndNotAConstructor);\n@@ -1726,7 +1697,7 @@ void MacroAssembler::AssertUndefinedOrAllocationSite(Register object) {\n     AssertNotSmi(object);\n     JumpIfRoot(object, Heap::kUndefinedValueRootIndex, &done_checking);\n     Ldr(scratch, FieldMemOperand(object, HeapObject::kMapOffset));\n-    CompareRoot(scratch, Heap::kAllocationSiteMapRootIndex);\n+    CompareInstanceType(scratch, scratch, ALLOCATION_SITE_TYPE);\n     Assert(eq, AbortReason::kExpectedUndefinedOrCell);\n     Bind(&done_checking);\n   }\n@@ -1765,18 +1736,18 @@ void MacroAssembler::TailCallStub(CodeStub* stub) {\n   Jump(stub->GetCode(), RelocInfo::CODE_TARGET);\n }\n \n-void TurboAssembler::CallRuntimeDelayed(Zone* zone, Runtime::FunctionId fid,\n-                                        SaveFPRegsMode save_doubles) {\n+void TurboAssembler::CallRuntimeWithCEntry(Runtime::FunctionId fid,\n+                                           Register centry) {\n   const Runtime::Function* f = Runtime::FunctionForId(fid);\n   // TODO(1236192): Most runtime routines don't need the number of\n   // arguments passed in because it is constant. At some point we\n   // should remove this need and make the runtime routine entry code\n   // smarter.\n   Mov(x0, f->nargs);\n   Mov(x1, ExternalReference::Create(f));\n-  Handle<Code> code =\n-      CodeFactory::CEntry(isolate(), f->result_size, save_doubles);\n-  Call(code, RelocInfo::CODE_TARGET);\n+  DCHECK(!AreAliased(centry, x0, x1));\n+  Add(centry, centry, Operand(Code::kHeaderSize - kHeapObjectTag));\n+  Call(centry);\n }\n \n void MacroAssembler::CallRuntime(const Runtime::Function* f,\n@@ -1883,54 +1854,28 @@ void TurboAssembler::CallCFunction(Register function, int num_of_reg_args,\n   }\n }\n \n-#ifdef V8_EMBEDDED_BUILTINS\n-void TurboAssembler::LookupConstant(Register destination,\n-                                    Handle<Object> object) {\n-  CHECK(isolate()->ShouldLoadConstantsFromRootList());\n-  CHECK(root_array_available_);\n-\n-  // Ensure the given object is in the builtins constants table and fetch its\n-  // index.\n-  BuiltinsConstantsTableBuilder* builder =\n-      isolate()->builtins_constants_table_builder();\n-  uint32_t index = builder->AddObject(object);\n-\n-  // TODO(jgruber): Load builtins from the builtins table.\n-  // TODO(jgruber): Ensure that code generation can recognize constant targets\n-  // in kArchCallCodeObject.\n-\n+void TurboAssembler::LoadFromConstantsTable(Register destination,\n+                                            int constant_index) {\n   DCHECK(isolate()->heap()->RootCanBeTreatedAsConstant(\n       Heap::kBuiltinsConstantsTableRootIndex));\n-\n   LoadRoot(destination, Heap::kBuiltinsConstantsTableRootIndex);\n-  Ldr(destination, FieldMemOperand(destination, FixedArray::kHeaderSize +\n-                                                    index * kPointerSize));\n+  Ldr(destination,\n+      FieldMemOperand(destination,\n+                      FixedArray::kHeaderSize + constant_index * kPointerSize));\n }\n \n-void TurboAssembler::LookupExternalReference(Register destination,\n-                                             ExternalReference reference) {\n-  CHECK(reference.address() !=\n-        ExternalReference::roots_array_start(isolate()).address());\n-  CHECK(isolate()->ShouldLoadConstantsFromRootList());\n-  CHECK(root_array_available_);\n-\n-  // Encode as an index into the external reference table stored on the isolate.\n-\n-  ExternalReferenceEncoder encoder(isolate());\n-  ExternalReferenceEncoder::Value v = encoder.Encode(reference.address());\n-  CHECK(!v.is_from_api());\n-  uint32_t index = v.index();\n-\n-  // Generate code to load from the external reference table.\n-\n-  int32_t roots_to_external_reference_offset =\n-      Heap::roots_to_external_reference_table_offset() +\n-      ExternalReferenceTable::OffsetOfEntry(index);\n+void TurboAssembler::LoadRootRelative(Register destination, int32_t offset) {\n+  Ldr(destination, MemOperand(kRootRegister, offset));\n+}\n \n-  Ldr(destination,\n-      MemOperand(kRootRegister, roots_to_external_reference_offset));\n+void TurboAssembler::LoadRootRegisterOffset(Register destination,\n+                                            intptr_t offset) {\n+  if (offset == 0) {\n+    Move(destination, kRootRegister);\n+  } else {\n+    Add(destination, kRootRegister, Operand(offset));\n+  }\n }\n-#endif  // V8_EMBEDDED_BUILTINS\n \n void TurboAssembler::Jump(Register target, Condition cond) {\n   if (cond == nv) return;\n@@ -1969,7 +1914,7 @@ static int64_t CalculateTargetOffset(Address target, RelocInfo::Mode rmode,\n   int64_t offset = static_cast<int64_t>(target);\n   // The target of WebAssembly calls is still an index instead of an actual\n   // address at this point, and needs to be encoded as-is.\n-  if (rmode != RelocInfo::WASM_CALL) {\n+  if (rmode != RelocInfo::WASM_CALL && rmode != RelocInfo::WASM_STUB_CALL) {\n     offset -= reinterpret_cast<int64_t>(pc);\n     DCHECK_EQ(offset % kInstructionSize, 0);\n     offset = offset / static_cast<int>(kInstructionSize);\n@@ -1986,18 +1931,38 @@ void TurboAssembler::Jump(Address target, RelocInfo::Mode rmode,\n void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,\n                           Condition cond) {\n   DCHECK(RelocInfo::IsCodeTarget(rmode));\n-#ifdef V8_EMBEDDED_BUILTINS\n-  if (root_array_available_ && isolate()->ShouldLoadConstantsFromRootList()) {\n-    UseScratchRegisterScope temps(this);\n-    Register scratch = temps.AcquireX();\n-    LookupConstant(scratch, code);\n-    Add(scratch, scratch, Operand(Code::kHeaderSize - kHeapObjectTag));\n-    Jump(scratch, cond);\n-    return;\n+  if (FLAG_embedded_builtins) {\n+    if (root_array_available_ && options().isolate_independent_code &&\n+        !Builtins::IsIsolateIndependentBuiltin(*code)) {\n+      // Calls to embedded targets are initially generated as standard\n+      // pc-relative calls below. When creating the embedded blob, call offsets\n+      // are patched up to point directly to the off-heap instruction start.\n+      // Note: It is safe to dereference {code} above since code generation\n+      // for builtins and code stubs happens on the main thread.\n+      UseScratchRegisterScope temps(this);\n+      Register scratch = temps.AcquireX();\n+      IndirectLoadConstant(scratch, code);\n+      Add(scratch, scratch, Operand(Code::kHeaderSize - kHeapObjectTag));\n+      Jump(scratch, cond);\n+      return;\n+    } else if (options().inline_offheap_trampolines) {\n+      int builtin_index = Builtins::kNoBuiltinId;\n+      if (isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&\n+          Builtins::IsIsolateIndependent(builtin_index)) {\n+        // Inline the trampoline.\n+        CHECK_NE(builtin_index, Builtins::kNoBuiltinId);\n+        UseScratchRegisterScope temps(this);\n+        Register scratch = temps.AcquireX();\n+        EmbeddedData d = EmbeddedData::FromBlob();\n+        Address entry = d.InstructionStartOfBuiltin(builtin_index);\n+        Mov(scratch, Operand(entry, RelocInfo::OFF_HEAP_TARGET));\n+        Jump(scratch, cond);\n+        return;\n+      }\n+    }\n   }\n-#endif  // V8_EMBEDDED_BUILTINS\n   if (CanUseNearCallOrJump(rmode)) {\n-    JumpHelper(static_cast<int64_t>(GetCodeTargetIndex(code)), rmode, cond);\n+    JumpHelper(static_cast<int64_t>(AddCodeTarget(code)), rmode, cond);\n   } else {\n     Jump(code.address(), rmode, cond);\n   }\n@@ -2045,18 +2010,38 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode) {\n   Bind(&start_call);\n #endif\n \n-#ifdef V8_EMBEDDED_BUILTINS\n-  if (root_array_available_ && isolate()->ShouldLoadConstantsFromRootList()) {\n-    UseScratchRegisterScope temps(this);\n-    Register scratch = temps.AcquireX();\n-    LookupConstant(scratch, code);\n-    Add(scratch, scratch, Operand(Code::kHeaderSize - kHeapObjectTag));\n-    Call(scratch);\n-    return;\n+  if (FLAG_embedded_builtins) {\n+    if (root_array_available_ && options().isolate_independent_code &&\n+        !Builtins::IsIsolateIndependentBuiltin(*code)) {\n+      // Calls to embedded targets are initially generated as standard\n+      // pc-relative calls below. When creating the embedded blob, call offsets\n+      // are patched up to point directly to the off-heap instruction start.\n+      // Note: It is safe to dereference {code} above since code generation\n+      // for builtins and code stubs happens on the main thread.\n+      UseScratchRegisterScope temps(this);\n+      Register scratch = temps.AcquireX();\n+      IndirectLoadConstant(scratch, code);\n+      Add(scratch, scratch, Operand(Code::kHeaderSize - kHeapObjectTag));\n+      Call(scratch);\n+      return;\n+    } else if (options().inline_offheap_trampolines) {\n+      int builtin_index = Builtins::kNoBuiltinId;\n+      if (isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&\n+          Builtins::IsIsolateIndependent(builtin_index)) {\n+        // Inline the trampoline.\n+        CHECK_NE(builtin_index, Builtins::kNoBuiltinId);\n+        UseScratchRegisterScope temps(this);\n+        Register scratch = temps.AcquireX();\n+        EmbeddedData d = EmbeddedData::FromBlob();\n+        Address entry = d.InstructionStartOfBuiltin(builtin_index);\n+        Mov(scratch, Operand(entry, RelocInfo::OFF_HEAP_TARGET));\n+        Call(scratch);\n+        return;\n+      }\n+    }\n   }\n-#endif  // V8_EMBEDDED_BUILTINS\n   if (CanUseNearCallOrJump(rmode)) {\n-    near_call(GetCodeTargetIndex(code), rmode);\n+    near_call(AddCodeTarget(code), rmode);\n   } else {\n     IndirectCall(code.address(), rmode);\n   }\n@@ -2087,7 +2072,7 @@ bool TurboAssembler::IsNearCallOffset(int64_t offset) {\n   return is_int26(offset);\n }\n \n-void TurboAssembler::CallForDeoptimization(Address target,\n+void TurboAssembler::CallForDeoptimization(Address target, int deopt_id,\n                                            RelocInfo::Mode rmode) {\n   DCHECK_EQ(rmode, RelocInfo::RUNTIME_ENTRY);\n \n@@ -2096,22 +2081,20 @@ void TurboAssembler::CallForDeoptimization(Address target,\n   Label start_call;\n   Bind(&start_call);\n #endif\n+  // The deoptimizer requires the deoptimization id to be in x16.\n   UseScratchRegisterScope temps(this);\n   Register temp = temps.AcquireX();\n-\n-  // Deoptimisation table entries require the call address to be in x16, in\n-  // order to compute the entry id.\n-  // TODO(all): Put the entry id back in the table now that we are using\n-  // a direct branch for the call and do not need to set up x16.\n   DCHECK(temp.Is(x16));\n-  Mov(temp, Immediate(target, rmode));\n-\n+  // Make sure that the deopt id can be encoded in 16 bits, so can be encoded\n+  // in a single movz instruction with a zero shift.\n+  DCHECK(is_uint16(deopt_id));\n+  movz(temp, deopt_id);\n   int64_t offset = static_cast<int64_t>(target) -\n-                   static_cast<int64_t>(isolate_data().code_range_start_);\n+                   static_cast<int64_t>(options().code_range_start);\n   DCHECK_EQ(offset % kInstructionSize, 0);\n   offset = offset / static_cast<int>(kInstructionSize);\n   DCHECK(IsNearCallOffset(offset));\n-  near_call(static_cast<int>(offset), rmode);\n+  near_call(static_cast<int>(offset), RelocInfo::RUNTIME_ENTRY);\n \n #ifdef DEBUG\n   AssertSizeOfCodeGeneratedSince(&start_call, kNearCallSize + kInstructionSize);\n@@ -2385,9 +2368,9 @@ void MacroAssembler::InvokeFunction(Register function, Register new_target,\n   // extension to correctly handle it.\n   Ldr(expected_reg, FieldMemOperand(function,\n                                     JSFunction::kSharedFunctionInfoOffset));\n-  Ldrsw(expected_reg,\n-        FieldMemOperand(expected_reg,\n-                        SharedFunctionInfo::kFormalParameterCountOffset));\n+  Ldrh(expected_reg,\n+       FieldMemOperand(expected_reg,\n+                       SharedFunctionInfo::kFormalParameterCountOffset));\n \n   ParameterCount expected(expected_reg);\n   InvokeFunctionCode(function, new_target, expected, actual, flag);\n@@ -2436,7 +2419,8 @@ void TurboAssembler::TryConvertDoubleToInt64(Register result,\n \n void TurboAssembler::TruncateDoubleToI(Isolate* isolate, Zone* zone,\n                                        Register result,\n-                                       DoubleRegister double_input) {\n+                                       DoubleRegister double_input,\n+                                       StubCallMode stub_mode) {\n   Label done;\n \n   // Try to convert the double to an int64. If successful, the bottom 32 bits\n@@ -2447,7 +2431,11 @@ void TurboAssembler::TruncateDoubleToI(Isolate* isolate, Zone* zone,\n   Push(lr, double_input);\n \n   // DoubleToI preserves any registers it needs to clobber.\n-  Call(BUILTIN_CODE(isolate, DoubleToI), RelocInfo::CODE_TARGET);\n+  if (stub_mode == StubCallMode::kCallWasmRuntimeStub) {\n+    Call(wasm::WasmCode::kDoubleToI, RelocInfo::WASM_STUB_CALL);\n+  } else {\n+    Call(BUILTIN_CODE(isolate, DoubleToI), RelocInfo::CODE_TARGET);\n+  }\n   Ldr(result, MemOperand(sp, 0));\n \n   DCHECK_EQ(xzr.SizeInBytes(), double_input.SizeInBytes());\n@@ -2467,17 +2455,19 @@ void TurboAssembler::EnterFrame(StackFrame::Type type) {\n   UseScratchRegisterScope temps(this);\n \n   if (type == StackFrame::INTERNAL) {\n-    Register code_reg = temps.AcquireX();\n-    Move(code_reg, CodeObject());\n     Register type_reg = temps.AcquireX();\n     Mov(type_reg, StackFrame::TypeToMarker(type));\n-    Push(lr, fp, type_reg, code_reg);\n-    Add(fp, sp, InternalFrameConstants::kFixedFrameSizeFromFp);\n-    // sp[4] : lr\n-    // sp[3] : fp\n+    // type_reg pushed twice for alignment.\n+    Push(lr, fp, type_reg, type_reg);\n+    const int kFrameSize =\n+        TypedFrameConstants::kFixedFrameSizeFromFp + kPointerSize;\n+    Add(fp, sp, kFrameSize);\n+    // sp[3] : lr\n+    // sp[2] : fp\n     // sp[1] : type\n-    // sp[0] : [code object]\n-  } else if (type == StackFrame::WASM_COMPILED) {\n+    // sp[0] : for alignment\n+  } else if (type == StackFrame::WASM_COMPILED ||\n+             type == StackFrame::WASM_COMPILE_LAZY) {\n     Register type_reg = temps.AcquireX();\n     Mov(type_reg, StackFrame::TypeToMarker(type));\n     Push(lr, fp);\n@@ -2507,15 +2497,10 @@ void TurboAssembler::EnterFrame(StackFrame::Type type) {\n }\n \n void TurboAssembler::LeaveFrame(StackFrame::Type type) {\n-  if (type == StackFrame::WASM_COMPILED) {\n-    Mov(sp, fp);\n-    Pop(fp, lr);\n-  } else {\n-    // Drop the execution stack down to the frame pointer and restore\n-    // the caller frame pointer and return address.\n-    Mov(sp, fp);\n-    Pop(fp, lr);\n-  }\n+  // Drop the execution stack down to the frame pointer and restore\n+  // the caller frame pointer and return address.\n+  Mov(sp, fp);\n+  Pop(fp, lr);\n }\n \n \n@@ -3046,12 +3031,13 @@ void TurboAssembler::Abort(AbortReason reason) {\n #ifdef DEBUG\n   RecordComment(\"Abort message: \");\n   RecordComment(GetAbortReason(reason));\n+#endif\n \n-  if (FLAG_trap_on_abort) {\n+  // Avoid emitting call to builtin if requested.\n+  if (trap_on_abort()) {\n     Brk(0);\n     return;\n   }\n-#endif\n \n   // We need some scratch registers for the MacroAssembler, so make sure we have\n   // some. This is safe here because Abort never returns."
        },
        {
            "sha": "a73fc2f47b977b9cad8be0a3e1e24844e55b7938",
            "filename": "deps/v8/src/arm64/macro-assembler-arm64.h",
            "status": "modified",
            "additions": 56,
            "deletions": 68,
            "changes": 124,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fmacro-assembler-arm64.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -11,6 +11,7 @@\n #include \"src/bailout-reason.h\"\n #include \"src/base/bits.h\"\n #include \"src/globals.h\"\n+#include \"src/turbo-assembler.h\"\n \n // Simulator specific helpers.\n #if USE_SIMULATOR\n@@ -41,24 +42,28 @@ namespace v8 {\n namespace internal {\n \n // Give alias names to registers for calling conventions.\n-#define kReturnRegister0 x0\n-#define kReturnRegister1 x1\n-#define kReturnRegister2 x2\n-#define kJSFunctionRegister x1\n-#define kContextRegister cp\n-#define kAllocateSizeRegister x1\n-#define kSpeculationPoisonRegister x18\n-#define kInterpreterAccumulatorRegister x0\n-#define kInterpreterBytecodeOffsetRegister x19\n-#define kInterpreterBytecodeArrayRegister x20\n-#define kInterpreterDispatchTableRegister x21\n-#define kJavaScriptCallArgCountRegister x0\n-#define kJavaScriptCallCodeStartRegister x2\n-#define kJavaScriptCallNewTargetRegister x3\n-#define kOffHeapTrampolineRegister ip0\n-#define kRuntimeCallFunctionRegister x1\n-#define kRuntimeCallArgCountRegister x0\n-#define kWasmInstanceRegister x7\n+constexpr Register kReturnRegister0 = x0;\n+constexpr Register kReturnRegister1 = x1;\n+constexpr Register kReturnRegister2 = x2;\n+constexpr Register kJSFunctionRegister = x1;\n+constexpr Register kContextRegister = cp;\n+constexpr Register kAllocateSizeRegister = x1;\n+constexpr Register kSpeculationPoisonRegister = x18;\n+constexpr Register kInterpreterAccumulatorRegister = x0;\n+constexpr Register kInterpreterBytecodeOffsetRegister = x19;\n+constexpr Register kInterpreterBytecodeArrayRegister = x20;\n+constexpr Register kInterpreterDispatchTableRegister = x21;\n+\n+constexpr Register kJavaScriptCallArgCountRegister = x0;\n+constexpr Register kJavaScriptCallCodeStartRegister = x2;\n+constexpr Register kJavaScriptCallTargetRegister = kJSFunctionRegister;\n+constexpr Register kJavaScriptCallNewTargetRegister = x3;\n+constexpr Register kJavaScriptCallExtraArg1Register = x2;\n+\n+constexpr Register kOffHeapTrampolineRegister = ip0;\n+constexpr Register kRuntimeCallFunctionRegister = x1;\n+constexpr Register kRuntimeCallArgCountRegister = x0;\n+constexpr Register kWasmInstanceRegister = x7;\n \n #define LS_MACRO_LIST(V)                                     \\\n   V(Ldrb, Register&, rt, LDRB_w)                             \\\n@@ -97,11 +102,6 @@ namespace internal {\n \n // Generate a MemOperand for loading a field from an object.\n inline MemOperand FieldMemOperand(Register object, int offset);\n-inline MemOperand UntagSmiFieldMemOperand(Register object, int offset);\n-\n-// Generate a MemOperand for loading a SMI from memory.\n-inline MemOperand UntagSmiMemOperand(Register object, int offset);\n-\n \n // ----------------------------------------------------------------------------\n // MacroAssembler\n@@ -177,10 +177,13 @@ enum PreShiftImmMode {\n   kAnyShift          // Allow any pre-shift.\n };\n \n-class TurboAssembler : public Assembler {\n+class TurboAssembler : public TurboAssemblerBase {\n  public:\n-  TurboAssembler(Isolate* isolate, void* buffer, int buffer_size,\n-                 CodeObjectRequired create_code_object);\n+  TurboAssembler(Isolate* isolate, const AssemblerOptions& options,\n+                 void* buffer, int buffer_size,\n+                 CodeObjectRequired create_code_object)\n+      : TurboAssemblerBase(isolate, options, buffer, buffer_size,\n+                           create_code_object) {}\n \n   // The Abort method should call a V8 runtime function, but the CallRuntime\n   // mechanism depends on CEntry. If use_real_aborts is false, Abort will\n@@ -203,16 +206,6 @@ class TurboAssembler : public Assembler {\n     TurboAssembler* tasm_;\n   };\n \n-  void set_has_frame(bool value) { has_frame_ = value; }\n-  bool has_frame() const { return has_frame_; }\n-\n-  Isolate* isolate() const { return isolate_; }\n-\n-  Handle<HeapObject> CodeObject() {\n-    DCHECK(!code_object_.is_null());\n-    return code_object_;\n-  }\n-\n #if DEBUG\n   void set_allow_macro_instructions(bool value) {\n     allow_macro_instructions_ = value;\n@@ -264,7 +257,7 @@ class TurboAssembler : public Assembler {\n   // This is required for compatibility with architecture independent code.\n   // Remove if not needed.\n   void Move(Register dst, Register src);\n-  void Move(Register dst, Handle<HeapObject> x);\n+  void Move(Register dst, Handle<HeapObject> value);\n   void Move(Register dst, Smi* src);\n \n   // Register swap. Note that the register operands should be distinct.\n@@ -573,9 +566,10 @@ class TurboAssembler : public Assembler {\n \n   bool AllowThisStubCall(CodeStub* stub);\n   void CallStubDelayed(CodeStub* stub);\n-  // TODO(jgruber): Remove in favor of MacroAssembler::CallRuntime.\n-  void CallRuntimeDelayed(Zone* zone, Runtime::FunctionId fid,\n-                          SaveFPRegsMode save_doubles = kDontSaveFPRegs);\n+\n+  // Call a runtime routine. This expects {centry} to contain a fitting CEntry\n+  // builtin for the target runtime function and uses an indirect call.\n+  void CallRuntimeWithCEntry(Runtime::FunctionId fid, Register centry);\n \n   // Removes current frame and its arguments from the stack preserving\n   // the arguments and a return address pushed to the stack for the next call.\n@@ -587,6 +581,7 @@ class TurboAssembler : public Assembler {\n                           Register scratch1);\n \n   inline void SmiUntag(Register dst, Register src);\n+  inline void SmiUntag(Register dst, const MemOperand& src);\n   inline void SmiUntag(Register smi);\n \n   // Calls Abort(msg) if the condition cond is not satisfied.\n@@ -862,6 +857,9 @@ class TurboAssembler : public Assembler {\n   inline void JumpIfSmi(Register value, Label* smi_label,\n                         Label* not_smi_label = nullptr);\n \n+  inline void JumpIfEqual(Register x, int32_t y, Label* dest);\n+  inline void JumpIfLessThan(Register x, int32_t y, Label* dest);\n+\n   inline void Fmov(VRegister fd, VRegister fn);\n   inline void Fmov(VRegister fd, Register rn);\n   // Provide explicit double and float interfaces for FP immediate moves, rather\n@@ -882,11 +880,10 @@ class TurboAssembler : public Assembler {\n             int shift_amount = 0);\n   void Movi(const VRegister& vd, uint64_t hi, uint64_t lo);\n \n-#ifdef V8_EMBEDDED_BUILTINS\n-  void LookupConstant(Register destination, Handle<Object> object);\n-  void LookupExternalReference(Register destination,\n-                               ExternalReference reference);\n-#endif  // V8_EMBEDDED_BUILTINS\n+  void LoadFromConstantsTable(Register destination,\n+                              int constant_index) override;\n+  void LoadRootRegisterOffset(Register destination, intptr_t offset) override;\n+  void LoadRootRelative(Register destination, int32_t offset) override;\n \n   void Jump(Register target, Condition cond = al);\n   void Jump(Address target, RelocInfo::Mode rmode, Condition cond = al);\n@@ -900,7 +897,8 @@ class TurboAssembler : public Assembler {\n   // Generate an indirect call (for when a direct call's range is not adequate).\n   void IndirectCall(Address target, RelocInfo::Mode rmode);\n \n-  void CallForDeoptimization(Address target, RelocInfo::Mode rmode);\n+  void CallForDeoptimization(Address target, int deopt_id,\n+                             RelocInfo::Mode rmode);\n \n   // For every Call variant, there is a matching CallSize function that returns\n   // the size (in bytes) of the call sequence.\n@@ -924,7 +922,7 @@ class TurboAssembler : public Assembler {\n   // the JS bitwise operations. See ECMA-262 9.5: ToInt32.\n   // Exits with 'result' holding the answer.\n   void TruncateDoubleToI(Isolate* isolate, Zone* zone, Register result,\n-                         DoubleRegister double_input);\n+                         DoubleRegister double_input, StubCallMode stub_mode);\n \n   inline void Mul(const Register& rd, const Register& rn, const Register& rm);\n \n@@ -1167,7 +1165,7 @@ class TurboAssembler : public Assembler {\n #undef DECLARE_FUNCTION\n \n   // Load an object from the root table.\n-  void LoadRoot(CPURegister destination, Heap::RootListIndex index);\n+  void LoadRoot(Register destination, Heap::RootListIndex index) override;\n \n   inline void Ret(const Register& xn = lr);\n \n@@ -1231,9 +1229,6 @@ class TurboAssembler : public Assembler {\n \n   void ResetSpeculationPoisonRegister();\n \n-  bool root_array_available() const { return root_array_available_; }\n-  void set_root_array_available(bool v) { root_array_available_ = v; }\n-\n  protected:\n   // The actual Push and Pop implementations. These don't generate any code\n   // other than that required for the push or pop. This allows\n@@ -1266,26 +1261,20 @@ class TurboAssembler : public Assembler {\n   // have mixed types. The format string (x0) should not be included.\n   void CallPrintf(int arg_count = 0, const CPURegister* args = nullptr);\n \n-  // This handle will be patched with the code object on installation.\n-  Handle<HeapObject> code_object_;\n-\n  private:\n-  bool has_frame_ = false;\n-  bool root_array_available_ = true;\n-  Isolate* const isolate_;\n #if DEBUG\n   // Tell whether any of the macro instruction can be used. When false the\n   // MacroAssembler will assert if a method which can emit a variable number\n   // of instructions is called.\n-  bool allow_macro_instructions_;\n+  bool allow_macro_instructions_ = true;\n #endif\n \n \n   // Scratch registers available for use by the MacroAssembler.\n-  CPURegList tmp_list_;\n-  CPURegList fptmp_list_;\n+  CPURegList tmp_list_ = DefaultTmpList();\n+  CPURegList fptmp_list_ = DefaultFPTmpList();\n \n-  bool use_real_aborts_;\n+  bool use_real_aborts_ = true;\n \n   // Helps resolve branching to labels potentially out of range.\n   // If the label is not bound, it registers the information necessary to later\n@@ -1314,8 +1303,12 @@ class TurboAssembler : public Assembler {\n \n class MacroAssembler : public TurboAssembler {\n  public:\n-  MacroAssembler(Isolate* isolate, byte* buffer, unsigned buffer_size,\n-                 CodeObjectRequired create_code_object);\n+  MacroAssembler(Isolate* isolate, void* buffer, int size,\n+                 CodeObjectRequired create_code_object)\n+      : MacroAssembler(isolate, AssemblerOptions::Default(isolate), buffer,\n+                       size, create_code_object) {}\n+  MacroAssembler(Isolate* isolate, const AssemblerOptions& options,\n+                 void* buffer, int size, CodeObjectRequired create_code_object);\n \n   // Instruction set functions ------------------------------------------------\n   // Logical macros.\n@@ -1716,8 +1709,6 @@ class MacroAssembler : public TurboAssembler {\n \n   inline void SmiTag(Register dst, Register src);\n   inline void SmiTag(Register smi);\n-  inline void SmiUntagToDouble(VRegister dst, Register src);\n-  inline void SmiUntagToFloat(VRegister dst, Register src);\n \n   inline void JumpIfNotSmi(Register value, Label* not_smi_label);\n   inline void JumpIfBothSmi(Register value1, Register value2,\n@@ -1740,9 +1731,6 @@ class MacroAssembler : public TurboAssembler {\n   inline void ObjectTag(Register tagged_obj, Register obj);\n   inline void ObjectUntag(Register untagged_obj, Register obj);\n \n-  // Abort execution if argument is not a FixedArray, enabled via --debug-code.\n-  void AssertFixedArray(Register object);\n-\n   // Abort execution if argument is not a Constructor, enabled via --debug-code.\n   void AssertConstructor(Register object);\n "
        },
        {
            "sha": "09c447fdb56aaa3265ee17d63c1af336eed7292c",
            "filename": "deps/v8/src/arm64/simulator-arm64.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Farm64%2Fsimulator-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -3184,7 +3184,7 @@ void Simulator::Debug() {\n                  (strcmp(cmd, \"po\") == 0)) {\n         if (argc == 2) {\n           int64_t value;\n-          OFStream os(stdout);\n+          StdoutStream os;\n           if (GetValue(arg1, &value)) {\n             Object* obj = reinterpret_cast<Object*>(value);\n             os << arg1 << \": \\n\";\n@@ -3246,7 +3246,7 @@ void Simulator::Debug() {\n               current_heap->ContainsSlow(obj->address())) {\n             PrintF(\" (\");\n             if ((value & kSmiTagMask) == 0) {\n-              STATIC_ASSERT(kSmiValueSize == 32);\n+              DCHECK(SmiValuesAre32Bits() || SmiValuesAre31Bits());\n               int32_t untagged = (value >> kSmiShift) & 0xFFFFFFFF;\n               PrintF(\"smi %\" PRId32, untagged);\n             } else {"
        },
        {
            "sha": "604207bc0dcacde50c2da5e9d636944fc7ac1653",
            "filename": "deps/v8/src/asmjs/asm-js.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-js.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-js.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-js.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -338,10 +338,10 @@ MaybeHandle<Object> AsmJs::InstantiateAsmWasm(Isolate* isolate,\n   base::ElapsedTimer instantiate_timer;\n   instantiate_timer.Start();\n   Handle<HeapNumber> uses_bitset(\n-      HeapNumber::cast(wasm_data->get(kWasmDataUsesBitSet)));\n+      HeapNumber::cast(wasm_data->get(kWasmDataUsesBitSet)), isolate);\n   Handle<WasmModuleObject> module(\n-      WasmModuleObject::cast(wasm_data->get(kWasmDataCompiledModule)));\n-  Handle<Script> script(Script::cast(shared->script()));\n+      WasmModuleObject::cast(wasm_data->get(kWasmDataCompiledModule)), isolate);\n+  Handle<Script> script(Script::cast(shared->script()), isolate);\n   // TODO(mstarzinger): The position currently points to the module definition\n   // but should instead point to the instantiation site (more intuitive).\n   int position = shared->StartPosition();\n@@ -405,15 +405,15 @@ MaybeHandle<Object> AsmJs::InstantiateAsmWasm(Isolate* isolate,\n   Handle<Name> single_function_name(\n       isolate->factory()->InternalizeUtf8String(AsmJs::kSingleFunctionName));\n   MaybeHandle<Object> single_function =\n-      Object::GetProperty(module_object, single_function_name);\n+      Object::GetProperty(isolate, module_object, single_function_name);\n   if (!single_function.is_null() &&\n       !single_function.ToHandleChecked()->IsUndefined(isolate)) {\n     return single_function;\n   }\n \n   Handle<String> exports_name =\n       isolate->factory()->InternalizeUtf8String(\"exports\");\n-  return Object::GetProperty(module_object, exports_name);\n+  return Object::GetProperty(isolate, module_object, exports_name);\n }\n \n }  // namespace internal"
        },
        {
            "sha": "fee309d9fb412deb29e7a5f72076453e2d329a7a",
            "filename": "deps/v8/src/asmjs/asm-parser.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-parser.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-parser.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-parser.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -553,7 +553,7 @@ void AsmJsParser::ValidateModuleVarImport(VarInfo* info,\n     } else {\n       info->kind = VarKind::kImportedFunction;\n       info->import = new (zone()->New(sizeof(FunctionImportInfo)))\n-          FunctionImportInfo({name, WasmModuleBuilder::SignatureMap(zone())});\n+          FunctionImportInfo(name, zone());\n       info->mutable_variable = false;\n     }\n   }\n@@ -2210,14 +2210,14 @@ AsmType* AsmJsParser::ValidateCall() {\n     DCHECK_NOT_NULL(function_info->import);\n     // TODO(bradnelson): Factor out.\n     uint32_t index;\n-    auto it = function_info->import->cache.find(sig);\n+    auto it = function_info->import->cache.find(*sig);\n     if (it != function_info->import->cache.end()) {\n       index = it->second;\n       DCHECK(function_info->function_defined);\n     } else {\n       index =\n           module_builder_->AddImport(function_info->import->function_name, sig);\n-      function_info->import->cache[sig] = index;\n+      function_info->import->cache[*sig] = index;\n       function_info->function_defined = true;\n     }\n     current_function_builder_->AddAsmWasmOffset(call_pos, to_number_pos);"
        },
        {
            "sha": "ac8a05a0284cc9d1d6019fbf4eb90066a30c0ef2",
            "filename": "deps/v8/src/asmjs/asm-parser.h",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-parser.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-parser.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-parser.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -76,9 +76,16 @@ class AsmJsParser {\n   };\n   // clang-format on\n \n+  // A single import in asm.js can require multiple imports in wasm, if the\n+  // function is used with different signatures. {cache} keeps the wasm\n+  // imports for the single asm.js import of name {function_name}.\n   struct FunctionImportInfo {\n     Vector<const char> function_name;\n-    WasmModuleBuilder::SignatureMap cache;\n+    ZoneUnorderedMap<FunctionSig, uint32_t> cache;\n+\n+    // Constructor.\n+    FunctionImportInfo(Vector<const char> name, Zone* zone)\n+        : function_name(name), cache(zone) {}\n   };\n \n   struct VarInfo {"
        },
        {
            "sha": "c7144e3be629ca2a3f5f4e0e9ff29d7093bee0fd",
            "filename": "deps/v8/src/asmjs/asm-scanner.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 8,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-scanner.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-scanner.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fasmjs%2Fasm-scanner.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -4,6 +4,7 @@\n \n #include \"src/asmjs/asm-scanner.h\"\n \n+#include \"src/char-predicates-inl.h\"\n #include \"src/conversions.h\"\n #include \"src/flags.h\"\n #include \"src/parsing/scanner.h\"\n@@ -273,17 +274,22 @@ void AsmJsScanner::ConsumeNumber(uc32 ch) {\n   std::string number;\n   number = ch;\n   bool has_dot = ch == '.';\n+  bool has_prefix = false;\n   for (;;) {\n     ch = stream_->Advance();\n     if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n         (ch >= 'A' && ch <= 'F') || ch == '.' || ch == 'b' || ch == 'o' ||\n         ch == 'x' ||\n-        ((ch == '-' || ch == '+') && (number[number.size() - 1] == 'e' ||\n-                                      number[number.size() - 1] == 'E'))) {\n+        ((ch == '-' || ch == '+') && !has_prefix &&\n+         (number[number.size() - 1] == 'e' ||\n+          number[number.size() - 1] == 'E'))) {\n       // TODO(bradnelson): Test weird cases ending in -.\n       if (ch == '.') {\n         has_dot = true;\n       }\n+      if (ch == 'b' || ch == 'o' || ch == 'x') {\n+        has_prefix = true;\n+      }\n       number.push_back(ch);\n     } else {\n       break;\n@@ -413,16 +419,13 @@ void AsmJsScanner::ConsumeCompareOrShift(uc32 ch) {\n }\n \n bool AsmJsScanner::IsIdentifierStart(uc32 ch) {\n-  return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '_' ||\n-         ch == '$';\n+  return IsInRange(AsciiAlphaToLower(ch), 'a', 'z') || ch == '_' || ch == '$';\n }\n \n-bool AsmJsScanner::IsIdentifierPart(uc32 ch) {\n-  return IsIdentifierStart(ch) || (ch >= '0' && ch <= '9');\n-}\n+bool AsmJsScanner::IsIdentifierPart(uc32 ch) { return IsAsciiIdentifier(ch); }\n \n bool AsmJsScanner::IsNumberStart(uc32 ch) {\n-  return ch == '.' || (ch >= '0' && ch <= '9');\n+  return ch == '.' || IsDecimalDigit(ch);\n }\n \n }  // namespace internal"
        },
        {
            "sha": "a431c7442d561eec8dfea8caf2f407ecbc651ed3",
            "filename": "deps/v8/src/assembler.cc",
            "status": "modified",
            "additions": 156,
            "deletions": 109,
            "changes": 265,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fassembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fassembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fassembler.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -43,28 +43,40 @@\n #include \"src/ostreams.h\"\n #include \"src/simulator.h\"  // For flushing instruction cache.\n #include \"src/snapshot/serializer-common.h\"\n+#include \"src/snapshot/snapshot.h\"\n \n namespace v8 {\n namespace internal {\n \n const char* const RelocInfo::kFillerCommentString = \"DEOPTIMIZATION PADDING\";\n \n-// -----------------------------------------------------------------------------\n-// Implementation of AssemblerBase\n-\n-AssemblerBase::IsolateData::IsolateData(Isolate* isolate)\n-    : serializer_enabled_(isolate->serializer_enabled())\n+AssemblerOptions AssemblerOptions::Default(\n+    Isolate* isolate, bool explicitly_support_serialization) {\n+  AssemblerOptions options;\n+  bool serializer =\n+      isolate->serializer_enabled() || explicitly_support_serialization;\n+  options.record_reloc_info_for_serialization = serializer;\n+  options.enable_root_array_delta_access = !serializer;\n+#ifdef USE_SIMULATOR\n+  // Don't generate simulator specific code if we are building a snapshot, which\n+  // might be run on real hardware.\n+  options.enable_simulator_code = !serializer;\n+#endif\n+  options.isolate_independent_code = isolate->ShouldLoadConstantsFromRootList();\n+  options.inline_offheap_trampolines = !serializer;\n #if V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64\n-      ,\n-      code_range_start_(\n-          isolate->heap()->memory_allocator()->code_range()->start())\n+  options.code_range_start =\n+      isolate->heap()->memory_allocator()->code_range()->start();\n #endif\n-{\n+  return options;\n }\n \n-AssemblerBase::AssemblerBase(IsolateData isolate_data, void* buffer,\n+// -----------------------------------------------------------------------------\n+// Implementation of AssemblerBase\n+\n+AssemblerBase::AssemblerBase(const AssemblerOptions& options, void* buffer,\n                              int buffer_size)\n-    : isolate_data_(isolate_data),\n+    : options_(options),\n       enabled_cpu_features_(0),\n       emit_debug_code_(FLAG_debug_code),\n       predictable_code_size_(false),\n@@ -95,7 +107,7 @@ void AssemblerBase::FlushICache(void* start, size_t size) {\n }\n \n void AssemblerBase::Print(Isolate* isolate) {\n-  OFStream os(stdout);\n+  StdoutStream os;\n   v8::internal::Disassembler::Decode(isolate, &os, buffer_, pc_);\n }\n \n@@ -164,8 +176,7 @@ unsigned CpuFeatures::dcache_line_size_ = 0;\n //\n //   01: code_target:          [6-bit pc delta] 01\n //\n-//   10: short_data_record:    [6-bit pc delta] 10 followed by\n-//                             [8-bit data delta]\n+//   10: wasm_stub_call:       [6-bit pc delta] 10\n //\n //   11: long_record           [6 bit reloc mode] 11\n //                             followed by pc delta\n@@ -189,7 +200,7 @@ const int kLongTagBits = 6;\n \n const int kEmbeddedObjectTag = 0;\n const int kCodeTargetTag = 1;\n-const int kLocatableTag = 2;\n+const int kWasmStubCallTag = 2;\n const int kDefaultTag = 3;\n \n const int kSmallPCDeltaBits = kBitsPerByte - kTagBits;\n@@ -202,54 +213,6 @@ const int kLastChunkTagBits = 1;\n const int kLastChunkTagMask = 1;\n const int kLastChunkTag = 1;\n \n-// static\n-bool RelocInfo::OffHeapTargetIsCodedSpecially() {\n-#if defined(V8_TARGET_ARCH_ARM) || defined(V8_TARGET_ARCH_ARM64) || \\\n-    defined(V8_TARGET_ARCH_X64) || defined(V8_TARGET_ARCH_IA32)\n-  return false;\n-#elif defined(V8_TARGET_ARCH_MIPS) || defined(V8_TARGET_ARCH_MIPS64) || \\\n-    defined(V8_TARGET_ARCH_PPC) || defined(V8_TARGET_ARCH_S390)\n-  return true;\n-#endif\n-}\n-\n-void RelocInfo::set_global_handle(Address address,\n-                                  ICacheFlushMode icache_flush_mode) {\n-  DCHECK_EQ(rmode_, WASM_GLOBAL_HANDLE);\n-  set_embedded_address(address, icache_flush_mode);\n-}\n-\n-Address RelocInfo::wasm_call_address() const {\n-  DCHECK_EQ(rmode_, WASM_CALL);\n-  return Assembler::target_address_at(pc_, constant_pool_);\n-}\n-\n-void RelocInfo::set_wasm_call_address(Address address,\n-                                      ICacheFlushMode icache_flush_mode) {\n-  DCHECK_EQ(rmode_, WASM_CALL);\n-  Assembler::set_target_address_at(pc_, constant_pool_, address,\n-                                   icache_flush_mode);\n-}\n-\n-Address RelocInfo::global_handle() const {\n-  DCHECK_EQ(rmode_, WASM_GLOBAL_HANDLE);\n-  return embedded_address();\n-}\n-\n-void RelocInfo::set_target_address(Address target,\n-                                   WriteBarrierMode write_barrier_mode,\n-                                   ICacheFlushMode icache_flush_mode) {\n-  DCHECK(IsCodeTarget(rmode_) || IsRuntimeEntry(rmode_) || IsWasmCall(rmode_));\n-  Assembler::set_target_address_at(pc_, constant_pool_, target,\n-                                   icache_flush_mode);\n-  if (write_barrier_mode == UPDATE_WRITE_BARRIER && host() != nullptr &&\n-      IsCodeTarget(rmode_)) {\n-    Code* target_code = Code::GetCodeFromTargetAddress(target);\n-    host()->GetHeap()->incremental_marking()->RecordWriteIntoCode(host(), this,\n-                                                                  target_code);\n-  }\n-}\n-\n uint32_t RelocInfoWriter::WriteLongPCJump(uint32_t pc_delta) {\n   // Return if the pc_delta can fit in kSmallPCDeltaBits bits.\n   // Otherwise write a variable length PC jump for the bits that do\n@@ -324,14 +287,15 @@ void RelocInfoWriter::Write(const RelocInfo* rinfo) {\n   } else if (rmode == RelocInfo::CODE_TARGET) {\n     WriteShortTaggedPC(pc_delta, kCodeTargetTag);\n     DCHECK_LE(begin_pos - pos_, RelocInfo::kMaxCallSize);\n-  } else if (rmode == RelocInfo::DEOPT_REASON) {\n-    DCHECK(rinfo->data() < (1 << kBitsPerByte));\n-    WriteShortTaggedPC(pc_delta, kLocatableTag);\n-    WriteShortData(rinfo->data());\n+  } else if (rmode == RelocInfo::WASM_STUB_CALL) {\n+    WriteShortTaggedPC(pc_delta, kWasmStubCallTag);\n   } else {\n     WriteModeAndPC(pc_delta, rmode);\n     if (RelocInfo::IsComment(rmode)) {\n       WriteData(rinfo->data());\n+    } else if (RelocInfo::IsDeoptReason(rmode)) {\n+      DCHECK_LT(rinfo->data(), 1 << kBitsPerByte);\n+      WriteShortData(rinfo->data());\n     } else if (RelocInfo::IsConstPool(rmode) ||\n                RelocInfo::IsVeneerPool(rmode) || RelocInfo::IsDeoptId(rmode) ||\n                RelocInfo::IsDeoptPosition(rmode)) {\n@@ -412,13 +376,9 @@ void RelocIterator::next() {\n     } else if (tag == kCodeTargetTag) {\n       ReadShortTaggedPC();\n       if (SetMode(RelocInfo::CODE_TARGET)) return;\n-    } else if (tag == kLocatableTag) {\n+    } else if (tag == kWasmStubCallTag) {\n       ReadShortTaggedPC();\n-      Advance();\n-      if (SetMode(RelocInfo::DEOPT_REASON)) {\n-        ReadShortData();\n-        return;\n-      }\n+      if (SetMode(RelocInfo::WASM_STUB_CALL)) return;\n     } else {\n       DCHECK_EQ(tag, kDefaultTag);\n       RelocInfo::Mode rmode = GetMode();\n@@ -432,6 +392,12 @@ void RelocIterator::next() {\n             return;\n           }\n           Advance(kIntptrSize);\n+        } else if (RelocInfo::IsDeoptReason(rmode)) {\n+          Advance();\n+          if (SetMode(rmode)) {\n+            ReadShortData();\n+            return;\n+          }\n         } else if (RelocInfo::IsConstPool(rmode) ||\n                    RelocInfo::IsVeneerPool(rmode) ||\n                    RelocInfo::IsDeoptId(rmode) ||\n@@ -461,6 +427,14 @@ RelocIterator::RelocIterator(const CodeReference code_reference, int mode_mask)\n                     code_reference.relocation_end(),\n                     code_reference.relocation_start(), mode_mask) {}\n \n+RelocIterator::RelocIterator(EmbeddedData* embedded_data, Code* code,\n+                             int mode_mask)\n+    : RelocIterator(\n+          code, embedded_data->InstructionStartOfBuiltin(code->builtin_index()),\n+          code->constant_pool(),\n+          code->relocation_start() + code->relocation_size(),\n+          code->relocation_start(), mode_mask) {}\n+\n RelocIterator::RelocIterator(const CodeDesc& desc, int mode_mask)\n     : RelocIterator(nullptr, reinterpret_cast<Address>(desc.buffer), 0,\n                     desc.buffer + desc.buffer_size,\n@@ -472,9 +446,7 @@ RelocIterator::RelocIterator(Vector<byte> instructions,\n                              int mode_mask)\n     : RelocIterator(nullptr, reinterpret_cast<Address>(instructions.start()),\n                     const_pool, reloc_info.start() + reloc_info.size(),\n-                    reloc_info.start(), mode_mask) {\n-  rinfo_.flags_ = RelocInfo::kInNativeWasmCode;\n-}\n+                    reloc_info.start(), mode_mask) {}\n \n RelocIterator::RelocIterator(Code* host, Address pc, Address constant_pool,\n                              const byte* pos, const byte* end, int mode_mask)\n@@ -491,12 +463,63 @@ RelocIterator::RelocIterator(Code* host, Address pc, Address constant_pool,\n // -----------------------------------------------------------------------------\n // Implementation of RelocInfo\n \n+// static\n+bool RelocInfo::OffHeapTargetIsCodedSpecially() {\n+#if defined(V8_TARGET_ARCH_ARM) || defined(V8_TARGET_ARCH_ARM64) || \\\n+    defined(V8_TARGET_ARCH_X64) || defined(V8_TARGET_ARCH_IA32)\n+  return false;\n+#elif defined(V8_TARGET_ARCH_MIPS) || defined(V8_TARGET_ARCH_MIPS64) || \\\n+    defined(V8_TARGET_ARCH_PPC) || defined(V8_TARGET_ARCH_S390)\n+  return true;\n+#endif\n+}\n+\n+Address RelocInfo::wasm_call_address() const {\n+  DCHECK_EQ(rmode_, WASM_CALL);\n+  return Assembler::target_address_at(pc_, constant_pool_);\n+}\n+\n+void RelocInfo::set_wasm_call_address(Address address,\n+                                      ICacheFlushMode icache_flush_mode) {\n+  DCHECK_EQ(rmode_, WASM_CALL);\n+  Assembler::set_target_address_at(pc_, constant_pool_, address,\n+                                   icache_flush_mode);\n+}\n+\n+Address RelocInfo::wasm_stub_call_address() const {\n+  DCHECK_EQ(rmode_, WASM_STUB_CALL);\n+  return Assembler::target_address_at(pc_, constant_pool_);\n+}\n+\n+void RelocInfo::set_wasm_stub_call_address(Address address,\n+                                           ICacheFlushMode icache_flush_mode) {\n+  DCHECK_EQ(rmode_, WASM_STUB_CALL);\n+  Assembler::set_target_address_at(pc_, constant_pool_, address,\n+                                   icache_flush_mode);\n+}\n+\n+void RelocInfo::set_target_address(Address target,\n+                                   WriteBarrierMode write_barrier_mode,\n+                                   ICacheFlushMode icache_flush_mode) {\n+  DCHECK(IsCodeTargetMode(rmode_) || IsRuntimeEntry(rmode_) ||\n+         IsWasmCall(rmode_));\n+  Assembler::set_target_address_at(pc_, constant_pool_, target,\n+                                   icache_flush_mode);\n+  if (write_barrier_mode == UPDATE_WRITE_BARRIER && host() != nullptr &&\n+      IsCodeTargetMode(rmode_)) {\n+    Code* target_code = Code::GetCodeFromTargetAddress(target);\n+    host()->GetHeap()->incremental_marking()->RecordWriteIntoCode(host(), this,\n+                                                                  target_code);\n+  }\n+}\n+\n #ifdef DEBUG\n bool RelocInfo::RequiresRelocation(const CodeDesc& desc) {\n   // Ensure there are no code targets or embedded objects present in the\n   // deoptimization entries, they would require relocation after code\n   // generation.\n-  int mode_mask = RelocInfo::kCodeTargetMask |\n+  int mode_mask = RelocInfo::ModeMask(RelocInfo::CODE_TARGET) |\n+                  RelocInfo::ModeMask(RelocInfo::RELATIVE_CODE_TARGET) |\n                   RelocInfo::ModeMask(RelocInfo::EMBEDDED_OBJECT) |\n                   RelocInfo::kApplyMask;\n   RelocIterator it(desc, mode_mask);\n@@ -513,6 +536,8 @@ const char* RelocInfo::RelocModeName(RelocInfo::Mode rmode) {\n       return \"embedded object\";\n     case CODE_TARGET:\n       return \"code target\";\n+    case RELATIVE_CODE_TARGET:\n+      return \"relative code target\";\n     case RUNTIME_ENTRY:\n       return \"runtime entry\";\n     case COMMENT:\n@@ -537,12 +562,10 @@ const char* RelocInfo::RelocModeName(RelocInfo::Mode rmode) {\n       return \"constant pool\";\n     case VENEER_POOL:\n       return \"veneer pool\";\n-    case WASM_GLOBAL_HANDLE:\n-      return \"global handle\";\n     case WASM_CALL:\n       return \"internal wasm call\";\n-    case WASM_CODE_TABLE_ENTRY:\n-      return \"wasm code table entry\";\n+    case WASM_STUB_CALL:\n+      return \"wasm stub call\";\n     case JS_TO_WASM_CALL:\n       return \"js to wasm call\";\n     case NUMBER_OF_MODES:\n@@ -564,33 +587,32 @@ void RelocInfo::Print(Isolate* isolate, std::ostream& os) {  // NOLINT\n   } else if (rmode_ == EMBEDDED_OBJECT) {\n     os << \"  (\" << Brief(target_object()) << \")\";\n   } else if (rmode_ == EXTERNAL_REFERENCE) {\n-    ExternalReferenceEncoder ref_encoder(isolate);\n-    os << \" (\"\n-       << ref_encoder.NameOfAddress(isolate, target_external_reference())\n-       << \")  (\" << reinterpret_cast<const void*>(target_external_reference())\n+    if (isolate) {\n+      ExternalReferenceEncoder ref_encoder(isolate);\n+      os << \" (\"\n+         << ref_encoder.NameOfAddress(isolate, target_external_reference())\n+         << \") \";\n+    }\n+    os << \" (\" << reinterpret_cast<const void*>(target_external_reference())\n        << \")\";\n-  } else if (IsCodeTarget(rmode_)) {\n+  } else if (IsCodeTargetMode(rmode_)) {\n     const Address code_target = target_address();\n-    if (flags_ & kInNativeWasmCode) {\n-      os << \" (wasm trampoline) \";\n-    } else {\n-      Code* code = Code::GetCodeFromTargetAddress(code_target);\n-      DCHECK(code->IsCode());\n-      os << \" (\" << Code::Kind2String(code->kind());\n-      if (Builtins::IsBuiltin(code)) {\n-        os << \" \" << Builtins::name(code->builtin_index());\n-      } else if (code->kind() == Code::STUB) {\n-        os << \" \" << CodeStub::MajorName(CodeStub::GetMajorKey(code));\n-      }\n-      os << \") \";\n+    Code* code = Code::GetCodeFromTargetAddress(code_target);\n+    DCHECK(code->IsCode());\n+    os << \" (\" << Code::Kind2String(code->kind());\n+    if (Builtins::IsBuiltin(code)) {\n+      os << \" \" << Builtins::name(code->builtin_index());\n+    } else if (code->kind() == Code::STUB) {\n+      os << \" \" << CodeStub::MajorName(CodeStub::GetMajorKey(code));\n     }\n-    os << \" (\" << reinterpret_cast<const void*>(target_address()) << \")\";\n+    os << \")  (\" << reinterpret_cast<const void*>(target_address()) << \")\";\n   } else if (IsRuntimeEntry(rmode_) && isolate->deoptimizer_data() != nullptr) {\n-    // Depotimization bailouts are stored as runtime entries.\n-    int id = Deoptimizer::GetDeoptimizationId(\n-        isolate, target_address(), Deoptimizer::EAGER);\n-    if (id != Deoptimizer::kNotDeoptimizationEntry) {\n-      os << \"  (deoptimization bailout \" << id << \")\";\n+    // Deoptimization bailouts are stored as runtime entries.\n+    DeoptimizeKind type;\n+    if (Deoptimizer::IsDeoptimizationEntry(isolate, target_address(), &type)) {\n+      int id = GetDeoptimizationId(isolate, type);\n+      os << \"  (\" << Deoptimizer::MessageFor(type) << \" deoptimization bailout \"\n+         << id << \")\";\n     }\n   } else if (IsConstPool(rmode_)) {\n     os << \" (size \" << static_cast<int>(data_) << \")\";\n@@ -604,9 +626,10 @@ void RelocInfo::Print(Isolate* isolate, std::ostream& os) {  // NOLINT\n void RelocInfo::Verify(Isolate* isolate) {\n   switch (rmode_) {\n     case EMBEDDED_OBJECT:\n-      Object::VerifyPointer(target_object());\n+      Object::VerifyPointer(isolate, target_object());\n       break;\n-    case CODE_TARGET: {\n+    case CODE_TARGET:\n+    case RELATIVE_CODE_TARGET: {\n       // convert inline target address to code object\n       Address addr = target_address();\n       CHECK_NE(addr, kNullAddress);\n@@ -641,10 +664,9 @@ void RelocInfo::Verify(Isolate* isolate) {\n     case DEOPT_ID:\n     case CONST_POOL:\n     case VENEER_POOL:\n-    case WASM_GLOBAL_HANDLE:\n     case WASM_CALL:\n+    case WASM_STUB_CALL:\n     case JS_TO_WASM_CALL:\n-    case WASM_CODE_TABLE_ENTRY:\n     case NONE:\n       break;\n     case NUMBER_OF_MODES:\n@@ -888,10 +910,35 @@ void Assembler::DataAlign(int m) {\n   }\n }\n \n-void Assembler::RequestHeapObject(HeapObjectRequest request) {\n+void AssemblerBase::RequestHeapObject(HeapObjectRequest request) {\n   request.set_offset(pc_offset());\n   heap_object_requests_.push_front(request);\n }\n \n+int AssemblerBase::AddCodeTarget(Handle<Code> target) {\n+  int current = static_cast<int>(code_targets_.size());\n+  if (current > 0 && !target.is_null() &&\n+      code_targets_.back().address() == target.address()) {\n+    // Optimization if we keep jumping to the same code target.\n+    return current - 1;\n+  } else {\n+    code_targets_.push_back(target);\n+    return current;\n+  }\n+}\n+\n+Handle<Code> AssemblerBase::GetCodeTarget(intptr_t code_target_index) const {\n+  DCHECK_LE(0, code_target_index);\n+  DCHECK_LT(code_target_index, code_targets_.size());\n+  return code_targets_[code_target_index];\n+}\n+\n+void AssemblerBase::UpdateCodeTarget(intptr_t code_target_index,\n+                                     Handle<Code> code) {\n+  DCHECK_LE(0, code_target_index);\n+  DCHECK_LT(code_target_index, code_targets_.size());\n+  code_targets_[code_target_index] = code;\n+}\n+\n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "28ec2a68c61f333cb63f28dd0159f1e620a97c48",
            "filename": "deps/v8/src/assembler.h",
            "status": "modified",
            "additions": 191,
            "deletions": 129,
            "changes": 320,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fassembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fassembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fassembler.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -60,6 +60,7 @@ class ApiFunction;\n namespace internal {\n \n // Forward declarations.\n+class EmbeddedData;\n class InstructionStream;\n class Isolate;\n class SCTableReference;\n@@ -78,39 +79,104 @@ class JumpOptimizationInfo {\n   bool is_optimizable() const { return optimizable_; }\n   void set_optimizable() { optimizable_ = true; }\n \n+  // Used to verify the instruction sequence is always the same in two stages.\n+  size_t hash_code() const { return hash_code_; }\n+  void set_hash_code(size_t hash_code) { hash_code_ = hash_code; }\n+\n   std::vector<uint32_t>& farjmp_bitmap() { return farjmp_bitmap_; }\n \n  private:\n   enum { kCollection, kOptimization } stage_ = kCollection;\n   bool optimizable_ = false;\n   std::vector<uint32_t> farjmp_bitmap_;\n+  size_t hash_code_ = 0u;\n+};\n+\n+class HeapObjectRequest {\n+ public:\n+  explicit HeapObjectRequest(double heap_number, int offset = -1);\n+  explicit HeapObjectRequest(CodeStub* code_stub, int offset = -1);\n+\n+  enum Kind { kHeapNumber, kCodeStub };\n+  Kind kind() const { return kind_; }\n+\n+  double heap_number() const {\n+    DCHECK_EQ(kind(), kHeapNumber);\n+    return value_.heap_number;\n+  }\n+\n+  CodeStub* code_stub() const {\n+    DCHECK_EQ(kind(), kCodeStub);\n+    return value_.code_stub;\n+  }\n+\n+  // The code buffer offset at the time of the request.\n+  int offset() const {\n+    DCHECK_GE(offset_, 0);\n+    return offset_;\n+  }\n+  void set_offset(int offset) {\n+    DCHECK_LT(offset_, 0);\n+    offset_ = offset;\n+    DCHECK_GE(offset_, 0);\n+  }\n+\n+ private:\n+  Kind kind_;\n+\n+  union {\n+    double heap_number;\n+    CodeStub* code_stub;\n+  } value_;\n+\n+  int offset_;\n };\n \n // -----------------------------------------------------------------------------\n // Platform independent assembler base class.\n \n enum class CodeObjectRequired { kNo, kYes };\n \n+struct V8_EXPORT_PRIVATE AssemblerOptions {\n+  // Recording reloc info for external references and off-heap targets is\n+  // needed whenever code is serialized, e.g. into the snapshot or as a WASM\n+  // module. This flag allows this reloc info to be disabled for code that\n+  // will not survive process destruction.\n+  bool record_reloc_info_for_serialization = true;\n+  // Recording reloc info can be disabled wholesale. This is needed when the\n+  // assembler is used on existing code directly (e.g. JumpTableAssembler)\n+  // without any buffer to hold reloc information.\n+  bool disable_reloc_info_for_patching = false;\n+  // Enables access to exrefs by computing a delta from the root array.\n+  // Only valid if code will not survive the process.\n+  bool enable_root_array_delta_access = false;\n+  // Enables specific assembler sequences only used for the simulator.\n+  bool enable_simulator_code = false;\n+  // Enables use of isolate-independent constants, indirected through the\n+  // root array.\n+  // (macro assembler feature).\n+  bool isolate_independent_code = false;\n+  // Enables the use of isolate-independent builtins through an off-heap\n+  // trampoline. (macro assembler feature).\n+  bool inline_offheap_trampolines = false;\n+  // On some platforms, all code is within a given range in the process,\n+  // and the start of this range is configured here.\n+  Address code_range_start = 0;\n+  // Enable pc-relative calls/jumps on platforms that support it. When setting\n+  // this flag, the code range must be small enough to fit all offsets into\n+  // the instruction immediates.\n+  bool use_pc_relative_calls_and_jumps = false;\n+\n+  static AssemblerOptions Default(\n+      Isolate* isolate, bool explicitly_support_serialization = false);\n+};\n \n-class AssemblerBase: public Malloced {\n+class AssemblerBase : public Malloced {\n  public:\n-  struct IsolateData {\n-    explicit IsolateData(Isolate* isolate);\n-    IsolateData(const IsolateData&) = default;\n-\n-    bool serializer_enabled_;\n-#if V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64\n-    Address code_range_start_;\n-#endif\n-  };\n-\n-  AssemblerBase(IsolateData isolate_data, void* buffer, int buffer_size);\n+  AssemblerBase(const AssemblerOptions& options, void* buffer, int buffer_size);\n   virtual ~AssemblerBase();\n \n-  IsolateData isolate_data() const { return isolate_data_; }\n-\n-  bool serializer_enabled() const { return isolate_data_.serializer_enabled_; }\n-  void enable_serializer() { isolate_data_.serializer_enabled_ = true; }\n+  const AssemblerOptions& options() const { return options_; }\n \n   bool emit_debug_code() const { return emit_debug_code_; }\n   void set_emit_debug_code(bool value) { emit_debug_code_ = value; }\n@@ -167,12 +233,30 @@ class AssemblerBase: public Malloced {\n     return FlushICache(reinterpret_cast<void*>(start), size);\n   }\n \n+  // Used to print the name of some special registers.\n+  static const char* GetSpecialRegisterName(int code) { return \"UNKNOWN\"; }\n+\n  protected:\n+  // Add 'target' to the {code_targets_} vector, if necessary, and return the\n+  // offset at which it is stored.\n+  int AddCodeTarget(Handle<Code> target);\n+  Handle<Code> GetCodeTarget(intptr_t code_target_index) const;\n+  // Update to the code target at {code_target_index} to {target}.\n+  void UpdateCodeTarget(intptr_t code_target_index, Handle<Code> target);\n+  // Reserves space in the code target vector.\n+  void ReserveCodeTargetSpace(size_t num_of_code_targets) {\n+    code_targets_.reserve(num_of_code_targets);\n+  }\n+\n   // The buffer into which code and relocation info are generated. It could\n   // either be owned by the assembler or be provided externally.\n   byte* buffer_;\n   int buffer_size_;\n   bool own_buffer_;\n+  std::forward_list<HeapObjectRequest> heap_object_requests_;\n+  // The program counter, which points into the buffer above and moves forward.\n+  // TODO(jkummerow): This should probably have type {Address}.\n+  byte* pc_;\n \n   void set_constant_pool_available(bool available) {\n     if (FLAG_enable_embedded_constant_pool) {\n@@ -183,12 +267,23 @@ class AssemblerBase: public Malloced {\n     }\n   }\n \n-  // The program counter, which points into the buffer above and moves forward.\n-  // TODO(jkummerow): This should probably have type {Address}.\n-  byte* pc_;\n+  // {RequestHeapObject} records the need for a future heap number allocation or\n+  // code stub generation. After code assembly, each platform's\n+  // {Assembler::AllocateAndInstallRequestedHeapObjects} will allocate these\n+  // objects and place them where they are expected (determined by the pc offset\n+  // associated with each request).\n+  void RequestHeapObject(HeapObjectRequest request);\n \n  private:\n-  IsolateData isolate_data_;\n+  // Before we copy code into the code space, we sometimes cannot encode\n+  // call/jump code targets as we normally would, as the difference between the\n+  // instruction's location in the temporary buffer and the call target is not\n+  // guaranteed to fit in the instruction's offset field. We keep track of the\n+  // code handles we encounter in calls in this vector, and encode the index of\n+  // the code handle in the vector instead.\n+  std::vector<Handle<Code>> code_targets_;\n+\n+  const AssemblerOptions options_;\n   uint64_t enabled_cpu_features_;\n   bool emit_debug_code_;\n   bool predictable_code_size_;\n@@ -340,12 +435,6 @@ enum ICacheFlushMode { FLUSH_ICACHE_IF_NEEDED, SKIP_ICACHE_FLUSH };\n \n class RelocInfo {\n  public:\n-  enum Flag : uint8_t {\n-    kNoFlags = 0,\n-    kInNativeWasmCode = 1u << 0,  // Reloc info belongs to native wasm code.\n-  };\n-  typedef base::Flags<Flag> Flags;\n-\n   // This string is used to add padding comments to the reloc info in cases\n   // where we are not sure to have enough space for patching in during\n   // lazy deoptimization. This is the case if we have indirect calls for which\n@@ -363,12 +452,16 @@ class RelocInfo {\n   static const int kMaxSmallPCDelta;\n \n   enum Mode : int8_t {\n-    // Please note the order is important (see IsCodeTarget, IsGCRelocMode).\n+    // Please note the order is important (see IsRealRelocMode, IsGCRelocMode,\n+    // and IsShareableRelocMode predicates below).\n+\n     CODE_TARGET,\n-    EMBEDDED_OBJECT,\n-    WASM_GLOBAL_HANDLE,\n-    WASM_CALL,\n+    RELATIVE_CODE_TARGET,  // LAST_CODE_TARGET_MODE\n+    EMBEDDED_OBJECT,       // LAST_GCED_ENUM\n+\n     JS_TO_WASM_CALL,\n+    WASM_CALL,  // FIRST_SHAREABLE_RELOC_MODE\n+    WASM_STUB_CALL,\n \n     RUNTIME_ENTRY,\n     COMMENT,\n@@ -396,32 +489,43 @@ class RelocInfo {\n     // cannot be encoded as part of another record.\n     PC_JUMP,\n \n-    // Points to a wasm code table entry.\n-    WASM_CODE_TABLE_ENTRY,\n-\n     // Pseudo-types\n     NUMBER_OF_MODES,\n     NONE,  // never recorded value\n \n+    LAST_CODE_TARGET_MODE = RELATIVE_CODE_TARGET,\n     FIRST_REAL_RELOC_MODE = CODE_TARGET,\n     LAST_REAL_RELOC_MODE = VENEER_POOL,\n-    LAST_CODE_ENUM = CODE_TARGET,\n     LAST_GCED_ENUM = EMBEDDED_OBJECT,\n-    FIRST_SHAREABLE_RELOC_MODE = RUNTIME_ENTRY,\n+    FIRST_SHAREABLE_RELOC_MODE = WASM_CALL,\n   };\n \n   STATIC_ASSERT(NUMBER_OF_MODES <= kBitsPerInt);\n \n   RelocInfo() = default;\n \n-  RelocInfo(Address pc, Mode rmode, intptr_t data, Code* host)\n-      : pc_(pc), rmode_(rmode), data_(data), host_(host) {}\n+  RelocInfo(Address pc, Mode rmode, intptr_t data, Code* host,\n+            Address constant_pool = kNullAddress)\n+      : pc_(pc),\n+        rmode_(rmode),\n+        data_(data),\n+        host_(host),\n+        constant_pool_(constant_pool) {}\n \n   static inline bool IsRealRelocMode(Mode mode) {\n     return mode >= FIRST_REAL_RELOC_MODE && mode <= LAST_REAL_RELOC_MODE;\n   }\n-  static inline bool IsCodeTarget(Mode mode) {\n-    return mode <= LAST_CODE_ENUM;\n+  // Is the relocation mode affected by GC?\n+  static inline bool IsGCRelocMode(Mode mode) { return mode <= LAST_GCED_ENUM; }\n+  static inline bool IsShareableRelocMode(Mode mode) {\n+    return mode >= RelocInfo::FIRST_SHAREABLE_RELOC_MODE;\n+  }\n+  static inline bool IsCodeTarget(Mode mode) { return mode == CODE_TARGET; }\n+  static inline bool IsCodeTargetMode(Mode mode) {\n+    return mode <= LAST_CODE_TARGET_MODE;\n+  }\n+  static inline bool IsRelativeCodeTarget(Mode mode) {\n+    return mode == RELATIVE_CODE_TARGET;\n   }\n   static inline bool IsEmbeddedObject(Mode mode) {\n     return mode == EMBEDDED_OBJECT;\n@@ -430,9 +534,8 @@ class RelocInfo {\n     return mode == RUNTIME_ENTRY;\n   }\n   static inline bool IsWasmCall(Mode mode) { return mode == WASM_CALL; }\n-  // Is the relocation mode affected by GC?\n-  static inline bool IsGCRelocMode(Mode mode) {\n-    return mode <= LAST_GCED_ENUM;\n+  static inline bool IsWasmStubCall(Mode mode) {\n+    return mode == WASM_STUB_CALL;\n   }\n   static inline bool IsComment(Mode mode) {\n     return mode == COMMENT;\n@@ -469,8 +572,11 @@ class RelocInfo {\n     return IsWasmPtrReference(mode);\n   }\n   static inline bool IsWasmPtrReference(Mode mode) {\n-    return mode == WASM_GLOBAL_HANDLE || mode == WASM_CALL ||\n-           mode == JS_TO_WASM_CALL;\n+    return mode == WASM_CALL || mode == JS_TO_WASM_CALL;\n+  }\n+\n+  static inline bool IsOnlyForSerializer(Mode mode) {\n+    return mode == EXTERNAL_REFERENCE || mode == OFF_HEAP_TARGET;\n   }\n \n   static constexpr int ModeMask(Mode mode) { return 1 << mode; }\n@@ -481,15 +587,12 @@ class RelocInfo {\n   intptr_t data() const { return data_; }\n   Code* host() const { return host_; }\n   Address constant_pool() const { return constant_pool_; }\n-  void set_constant_pool(Address constant_pool) {\n-    constant_pool_ = constant_pool;\n-  }\n \n   // Apply a relocation by delta bytes. When the code object is moved, PC\n   // relative addresses have to be updated as well as absolute addresses\n   // inside the code (internal references).\n   // Do not forget to flush the icache afterwards!\n-  INLINE(void apply(intptr_t delta));\n+  V8_INLINE void apply(intptr_t delta);\n \n   // Is the pointer this relocation info refers to coded like a plain pointer\n   // or is it strange in some way (e.g. relative or patched into a series of\n@@ -504,58 +607,63 @@ class RelocInfo {\n   // constant pool, otherwise the pointer is embedded in the instruction stream.\n   bool IsInConstantPool();\n \n-  Address global_handle() const;\n-  Address js_to_wasm_address() const;\n+  // Returns the deoptimization id for the entry associated with the reloc info\n+  // where {kind} is the deoptimization kind.\n+  // This is only used for printing RUNTIME_ENTRY relocation info.\n+  int GetDeoptimizationId(Isolate* isolate, DeoptimizeKind kind);\n+\n   Address wasm_call_address() const;\n+  Address wasm_stub_call_address() const;\n+  Address js_to_wasm_address() const;\n \n-  void set_target_address(\n-      Address target,\n-      WriteBarrierMode write_barrier_mode = UPDATE_WRITE_BARRIER,\n-      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n+  uint32_t wasm_call_tag() const;\n \n-  void set_global_handle(Address address, ICacheFlushMode icache_flush_mode =\n-                                              FLUSH_ICACHE_IF_NEEDED);\n   void set_wasm_call_address(\n       Address, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n+  void set_wasm_stub_call_address(\n+      Address, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n   void set_js_to_wasm_address(\n       Address, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n \n+  void set_target_address(\n+      Address target,\n+      WriteBarrierMode write_barrier_mode = UPDATE_WRITE_BARRIER,\n+      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n+\n   // this relocation applies to;\n   // can only be called if IsCodeTarget(rmode_) || IsRuntimeEntry(rmode_)\n-  INLINE(Address target_address());\n-  INLINE(HeapObject* target_object());\n-  INLINE(Handle<HeapObject> target_object_handle(Assembler* origin));\n-  INLINE(void set_target_object(\n-      HeapObject* target,\n+  V8_INLINE Address target_address();\n+  V8_INLINE HeapObject* target_object();\n+  V8_INLINE Handle<HeapObject> target_object_handle(Assembler* origin);\n+  V8_INLINE void set_target_object(\n+      Heap* heap, HeapObject* target,\n       WriteBarrierMode write_barrier_mode = UPDATE_WRITE_BARRIER,\n-      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED));\n-  INLINE(Address target_runtime_entry(Assembler* origin));\n-  INLINE(void set_target_runtime_entry(\n+      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n+  V8_INLINE Address target_runtime_entry(Assembler* origin);\n+  V8_INLINE void set_target_runtime_entry(\n       Address target,\n       WriteBarrierMode write_barrier_mode = UPDATE_WRITE_BARRIER,\n-      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED));\n-  INLINE(Address target_off_heap_target());\n-  INLINE(Cell* target_cell());\n-  INLINE(Handle<Cell> target_cell_handle());\n-  INLINE(void set_target_cell(\n+      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n+  V8_INLINE Address target_off_heap_target();\n+  V8_INLINE Cell* target_cell();\n+  V8_INLINE Handle<Cell> target_cell_handle();\n+  V8_INLINE void set_target_cell(\n       Cell* cell, WriteBarrierMode write_barrier_mode = UPDATE_WRITE_BARRIER,\n-      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED));\n-  INLINE(void set_wasm_code_table_entry(\n-      Address, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED));\n-  INLINE(void set_target_external_reference(\n-      Address, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED));\n+      ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n+  V8_INLINE void set_target_external_reference(\n+      Address, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);\n \n   // Returns the address of the constant pool entry where the target address\n   // is held.  This should only be called if IsInConstantPool returns true.\n-  INLINE(Address constant_pool_entry_address());\n+  V8_INLINE Address constant_pool_entry_address();\n \n   // Read the address of the word containing the target_address in an\n   // instruction stream.  What this means exactly is architecture-independent.\n   // The only architecture-independent user of this function is the serializer.\n   // The serializer uses it to find out how many raw bytes of instruction to\n   // output before the next target.  Architecture-independent code shouldn't\n   // dereference the pointer it gets back from this.\n-  INLINE(Address target_address_address());\n+  V8_INLINE Address target_address_address();\n \n   // This indicates how much space a target takes up when deserializing a code\n   // stream.  For most architectures this is just the size of a pointer.  For\n@@ -566,23 +674,23 @@ class RelocInfo {\n   // should return the end of the instructions to be patched, allowing the\n   // deserializer to deserialize the instructions as raw bytes and put them in\n   // place, ready to be patched with the target.\n-  INLINE(int target_address_size());\n+  V8_INLINE int target_address_size();\n \n   // Read the reference in the instruction this relocation\n   // applies to; can only be called if rmode_ is EXTERNAL_REFERENCE.\n-  INLINE(Address target_external_reference());\n+  V8_INLINE Address target_external_reference();\n \n   // Read the reference in the instruction this relocation\n   // applies to; can only be called if rmode_ is INTERNAL_REFERENCE.\n-  INLINE(Address target_internal_reference());\n+  V8_INLINE Address target_internal_reference();\n \n   // Return the reference address this relocation applies to;\n   // can only be called if rmode_ is INTERNAL_REFERENCE.\n-  INLINE(Address target_internal_reference_address());\n+  V8_INLINE Address target_internal_reference_address();\n \n   // Wipe out a relocation to a fixed value, used for making snapshots\n   // reproducible.\n-  INLINE(void WipeOut());\n+  V8_INLINE void WipeOut();\n \n   template <typename ObjectVisitor>\n   inline void Visit(ObjectVisitor* v);\n@@ -602,24 +710,16 @@ class RelocInfo {\n   void Verify(Isolate* isolate);\n #endif\n \n-  static const int kCodeTargetMask = (1 << (LAST_CODE_ENUM + 1)) - 1;\n   static const int kApplyMask;  // Modes affected by apply.  Depends on arch.\n \n  private:\n-  void set_embedded_address(Address address, ICacheFlushMode flush_mode);\n-  void set_embedded_size(uint32_t size, ICacheFlushMode flush_mode);\n-\n-  uint32_t embedded_size() const;\n-  Address embedded_address() const;\n-\n   // On ARM/ARM64, note that pc_ is the address of the instruction referencing\n   // the constant pool and not the address of the constant pool entry.\n   Address pc_;\n   Mode rmode_;\n   intptr_t data_ = 0;\n   Code* host_;\n   Address constant_pool_ = kNullAddress;\n-  Flags flags_;\n   friend class RelocIterator;\n };\n \n@@ -679,6 +779,8 @@ class RelocIterator: public Malloced {\n   // Relocation information with mode k is included in the\n   // iteration iff bit k of mode_mask is set.\n   explicit RelocIterator(Code* code, int mode_mask = -1);\n+  explicit RelocIterator(EmbeddedData* embedded_data, Code* code,\n+                         int mode_mask);\n   explicit RelocIterator(const CodeDesc& desc, int mode_mask = -1);\n   explicit RelocIterator(const CodeReference code_reference,\n                          int mode_mask = -1);\n@@ -877,46 +979,6 @@ class ConstantPoolBuilder BASE_EMBEDDED {\n   PerTypeEntryInfo info_[ConstantPoolEntry::NUMBER_OF_TYPES];\n };\n \n-class HeapObjectRequest {\n- public:\n-  explicit HeapObjectRequest(double heap_number, int offset = -1);\n-  explicit HeapObjectRequest(CodeStub* code_stub, int offset = -1);\n-\n-  enum Kind { kHeapNumber, kCodeStub };\n-  Kind kind() const { return kind_; }\n-\n-  double heap_number() const {\n-    DCHECK_EQ(kind(), kHeapNumber);\n-    return value_.heap_number;\n-  }\n-\n-  CodeStub* code_stub() const {\n-    DCHECK_EQ(kind(), kCodeStub);\n-    return value_.code_stub;\n-  }\n-\n-  // The code buffer offset at the time of the request.\n-  int offset() const {\n-    DCHECK_GE(offset_, 0);\n-    return offset_;\n-  }\n-  void set_offset(int offset) {\n-    DCHECK_LT(offset_, 0);\n-    offset_ = offset;\n-    DCHECK_GE(offset_, 0);\n-  }\n-\n- private:\n-  Kind kind_;\n-\n-  union {\n-    double heap_number;\n-    CodeStub* code_stub;\n-  } value_;\n-\n-  int offset_;\n-};\n-\n // Base type for CPU Registers.\n //\n // 1) We would prefer to use an enum for registers, but enum values are"
        },
        {
            "sha": "640de541b548cd155f204d1f504bcdfc5641a126",
            "filename": "deps/v8/src/ast/ast-traversal-visitor.h",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast-traversal-visitor.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast-traversal-visitor.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fast-traversal-visitor.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -41,7 +41,7 @@ class AstTraversalVisitor : public AstVisitor<Subclass> {\n \n   // Iteration left-to-right.\n   void VisitDeclarations(Declaration::List* declarations);\n-  void VisitStatements(ZoneList<Statement*>* statements);\n+  void VisitStatements(ZonePtrList<Statement>* statements);\n \n // Individual nodes\n #define DECLARE_VISIT(type) void Visit##type(type* node);\n@@ -112,7 +112,7 @@ void AstTraversalVisitor<Subclass>::VisitDeclarations(\n \n template <class Subclass>\n void AstTraversalVisitor<Subclass>::VisitStatements(\n-    ZoneList<Statement*>* stmts) {\n+    ZonePtrList<Statement>* stmts) {\n   for (int i = 0; i < stmts->length(); ++i) {\n     Statement* stmt = stmts->at(i);\n     RECURSE(Visit(stmt));\n@@ -198,14 +198,14 @@ void AstTraversalVisitor<Subclass>::VisitSwitchStatement(\n   PROCESS_NODE(stmt);\n   RECURSE(Visit(stmt->tag()));\n \n-  ZoneList<CaseClause*>* clauses = stmt->cases();\n+  ZonePtrList<CaseClause>* clauses = stmt->cases();\n   for (int i = 0; i < clauses->length(); ++i) {\n     CaseClause* clause = clauses->at(i);\n     if (!clause->is_default()) {\n       Expression* label = clause->label();\n       RECURSE(Visit(label));\n     }\n-    ZoneList<Statement*>* stmts = clause->statements();\n+    ZonePtrList<Statement>* stmts = clause->statements();\n     RECURSE(VisitStatements(stmts));\n   }\n }\n@@ -330,7 +330,7 @@ void AstTraversalVisitor<Subclass>::VisitRegExpLiteral(RegExpLiteral* expr) {\n template <class Subclass>\n void AstTraversalVisitor<Subclass>::VisitObjectLiteral(ObjectLiteral* expr) {\n   PROCESS_EXPRESSION(expr);\n-  ZoneList<ObjectLiteralProperty*>* props = expr->properties();\n+  ZonePtrList<ObjectLiteralProperty>* props = expr->properties();\n   for (int i = 0; i < props->length(); ++i) {\n     ObjectLiteralProperty* prop = props->at(i);\n     RECURSE_EXPRESSION(Visit(prop->key()));\n@@ -341,7 +341,7 @@ void AstTraversalVisitor<Subclass>::VisitObjectLiteral(ObjectLiteral* expr) {\n template <class Subclass>\n void AstTraversalVisitor<Subclass>::VisitArrayLiteral(ArrayLiteral* expr) {\n   PROCESS_EXPRESSION(expr);\n-  ZoneList<Expression*>* values = expr->values();\n+  ZonePtrList<Expression>* values = expr->values();\n   for (int i = 0; i < values->length(); ++i) {\n     Expression* value = values->at(i);\n     RECURSE_EXPRESSION(Visit(value));\n@@ -404,7 +404,7 @@ template <class Subclass>\n void AstTraversalVisitor<Subclass>::VisitCall(Call* expr) {\n   PROCESS_EXPRESSION(expr);\n   RECURSE_EXPRESSION(Visit(expr->expression()));\n-  ZoneList<Expression*>* args = expr->arguments();\n+  ZonePtrList<Expression>* args = expr->arguments();\n   for (int i = 0; i < args->length(); ++i) {\n     Expression* arg = args->at(i);\n     RECURSE_EXPRESSION(Visit(arg));\n@@ -415,7 +415,7 @@ template <class Subclass>\n void AstTraversalVisitor<Subclass>::VisitCallNew(CallNew* expr) {\n   PROCESS_EXPRESSION(expr);\n   RECURSE_EXPRESSION(Visit(expr->expression()));\n-  ZoneList<Expression*>* args = expr->arguments();\n+  ZonePtrList<Expression>* args = expr->arguments();\n   for (int i = 0; i < args->length(); ++i) {\n     Expression* arg = args->at(i);\n     RECURSE_EXPRESSION(Visit(arg));\n@@ -425,7 +425,7 @@ void AstTraversalVisitor<Subclass>::VisitCallNew(CallNew* expr) {\n template <class Subclass>\n void AstTraversalVisitor<Subclass>::VisitCallRuntime(CallRuntime* expr) {\n   PROCESS_EXPRESSION(expr);\n-  ZoneList<Expression*>* args = expr->arguments();\n+  ZonePtrList<Expression>* args = expr->arguments();\n   for (int i = 0; i < args->length(); ++i) {\n     Expression* arg = args->at(i);\n     RECURSE_EXPRESSION(Visit(arg));\n@@ -487,7 +487,7 @@ void AstTraversalVisitor<Subclass>::VisitClassLiteral(ClassLiteral* expr) {\n   if (expr->instance_fields_initializer_function() != nullptr) {\n     RECURSE_EXPRESSION(Visit(expr->instance_fields_initializer_function()));\n   }\n-  ZoneList<ClassLiteralProperty*>* props = expr->properties();\n+  ZonePtrList<ClassLiteral::Property>* props = expr->properties();\n   for (int i = 0; i < props->length(); ++i) {\n     ClassLiteralProperty* prop = props->at(i);\n     if (!prop->key()->IsLiteral()) {\n@@ -501,7 +501,7 @@ template <class Subclass>\n void AstTraversalVisitor<Subclass>::VisitInitializeClassFieldsStatement(\n     InitializeClassFieldsStatement* stmt) {\n   PROCESS_NODE(stmt);\n-  ZoneList<ClassLiteralProperty*>* props = stmt->fields();\n+  ZonePtrList<ClassLiteral::Property>* props = stmt->fields();\n   for (int i = 0; i < props->length(); ++i) {\n     ClassLiteralProperty* prop = props->at(i);\n     if (!prop->key()->IsLiteral()) {"
        },
        {
            "sha": "fc8be819f6cf9336ff89467bb692dd8edd7f5ab5",
            "filename": "deps/v8/src/ast/ast-value-factory.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast-value-factory.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast-value-factory.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fast-value-factory.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -182,7 +182,7 @@ std::forward_list<const AstRawString*> AstConsString::ToRawStrings() const {\n   return result;\n }\n \n-AstStringConstants::AstStringConstants(Isolate* isolate, uint32_t hash_seed)\n+AstStringConstants::AstStringConstants(Isolate* isolate, uint64_t hash_seed)\n     : zone_(isolate->allocator(), ZONE_NAME),\n       string_table_(AstRawString::Compare),\n       hash_seed_(hash_seed) {"
        },
        {
            "sha": "e85b0675bf6fedf5e13f64bb55f5affef73ca9ca",
            "filename": "deps/v8/src/ast/ast-value-factory.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast-value-factory.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast-value-factory.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fast-value-factory.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -240,22 +240,22 @@ class AstBigInt {\n \n class AstStringConstants final {\n  public:\n-  AstStringConstants(Isolate* isolate, uint32_t hash_seed);\n+  AstStringConstants(Isolate* isolate, uint64_t hash_seed);\n \n #define F(name, str) \\\n   const AstRawString* name##_string() const { return name##_string_; }\n   AST_STRING_CONSTANTS(F)\n #undef F\n \n-  uint32_t hash_seed() const { return hash_seed_; }\n+  uint64_t hash_seed() const { return hash_seed_; }\n   const base::CustomMatcherHashMap* string_table() const {\n     return &string_table_;\n   }\n \n  private:\n   Zone zone_;\n   base::CustomMatcherHashMap string_table_;\n-  uint32_t hash_seed_;\n+  uint64_t hash_seed_;\n \n #define F(name, str) AstRawString* name##_string_;\n   AST_STRING_CONSTANTS(F)\n@@ -267,7 +267,7 @@ class AstStringConstants final {\n class AstValueFactory {\n  public:\n   AstValueFactory(Zone* zone, const AstStringConstants* string_constants,\n-                  uint32_t hash_seed)\n+                  uint64_t hash_seed)\n       : string_table_(string_constants->string_table()),\n         strings_(nullptr),\n         strings_end_(&strings_),\n@@ -354,7 +354,7 @@ class AstValueFactory {\n \n   Zone* zone_;\n \n-  uint32_t hash_seed_;\n+  uint64_t hash_seed_;\n };\n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "5a4add60390970f360aef04aff6b3d6f313f84d7",
            "filename": "deps/v8/src/ast/ast.cc",
            "status": "modified",
            "additions": 78,
            "deletions": 43,
            "changes": 121,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fast.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -7,7 +7,6 @@\n #include <cmath>  // For isfinite.\n #include <vector>\n \n-#include \"src/ast/compile-time-value.h\"\n #include \"src/ast/prettyprinter.h\"\n #include \"src/ast/scopes.h\"\n #include \"src/base/hashmap.h\"\n@@ -19,6 +18,7 @@\n #include \"src/double.h\"\n #include \"src/elements.h\"\n #include \"src/objects-inl.h\"\n+#include \"src/objects/literal-objects-inl.h\"\n #include \"src/objects/literal-objects.h\"\n #include \"src/objects/map.h\"\n #include \"src/property-details.h\"\n@@ -114,6 +114,13 @@ bool Expression::IsTheHoleLiteral() const {\n   return IsLiteral() && AsLiteral()->type() == Literal::kTheHole;\n }\n \n+bool Expression::IsCompileTimeValue() {\n+  if (IsLiteral()) return true;\n+  MaterializedLiteral* literal = AsMaterializedLiteral();\n+  if (literal == nullptr) return false;\n+  return literal->IsSimple();\n+}\n+\n bool Expression::IsUndefinedLiteral() const {\n   if (IsLiteral() && AsLiteral()->type() == Literal::kUndefined) return true;\n \n@@ -334,8 +341,7 @@ ClassLiteralProperty::ClassLiteralProperty(Expression* key, Expression* value,\n \n bool ObjectLiteral::Property::IsCompileTimeValue() const {\n   return kind_ == CONSTANT ||\n-      (kind_ == MATERIALIZED_LITERAL &&\n-       CompileTimeValue::IsCompileTimeValue(value_));\n+         (kind_ == MATERIALIZED_LITERAL && value_->IsCompileTimeValue());\n }\n \n \n@@ -360,19 +366,37 @@ void ObjectLiteral::CalculateEmitStore(Zone* zone) {\n     Literal* literal = property->key()->AsLiteral();\n     DCHECK(!literal->IsNullLiteral());\n \n-    // If there is an existing entry do not emit a store unless the previous\n-    // entry was also an accessor.\n     uint32_t hash = literal->Hash();\n     ZoneHashMap::Entry* entry = table.LookupOrInsert(literal, hash, allocator);\n-    if (entry->value != nullptr) {\n-      auto previous_kind =\n+    if (entry->value == nullptr) {\n+      entry->value = property;\n+    } else {\n+      // We already have a later definition of this property, so we don't need\n+      // to emit a store for the current one.\n+      //\n+      // There are two subtleties here.\n+      //\n+      // (1) Emitting a store might actually be incorrect. For example, in {get\n+      // foo() {}, foo: 42}, the getter store would override the data property\n+      // (which, being a non-computed compile-time valued property, is already\n+      // part of the initial literal object.\n+      //\n+      // (2) If the later definition is an accessor (say, a getter), and the\n+      // current definition is a complementary accessor (here, a setter), then\n+      // we still must emit a store for the current definition.\n+\n+      auto later_kind =\n           static_cast<ObjectLiteral::Property*>(entry->value)->kind();\n-      if (!((property->kind() == GETTER && previous_kind == SETTER) ||\n-            (property->kind() == SETTER && previous_kind == GETTER))) {\n+      bool complementary_accessors =\n+          (property->kind() == GETTER && later_kind == SETTER) ||\n+          (property->kind() == SETTER && later_kind == GETTER);\n+      if (!complementary_accessors) {\n         property->set_emit_store(false);\n+        if (later_kind == GETTER || later_kind == SETTER) {\n+          entry->value = property;\n+        }\n       }\n     }\n-    entry->value = property;\n   }\n }\n \n@@ -427,7 +451,7 @@ int ObjectLiteral::InitDepthAndFlags() {\n     Literal* key = property->key()->AsLiteral();\n     Expression* value = property->value();\n \n-    bool is_compile_time_value = CompileTimeValue::IsCompileTimeValue(value);\n+    bool is_compile_time_value = value->IsCompileTimeValue();\n     is_simple = is_simple && is_compile_time_value;\n \n     // Keep track of the number of elements in the object literal and\n@@ -454,8 +478,8 @@ int ObjectLiteral::InitDepthAndFlags() {\n   return depth_acc;\n }\n \n-void ObjectLiteral::BuildConstantProperties(Isolate* isolate) {\n-  if (!constant_properties_.is_null()) return;\n+void ObjectLiteral::BuildBoilerplateDescription(Isolate* isolate) {\n+  if (!boilerplate_description_.is_null()) return;\n \n   int index_keys = 0;\n   bool has_seen_proto = false;\n@@ -476,17 +500,17 @@ void ObjectLiteral::BuildConstantProperties(Isolate* isolate) {\n     }\n   }\n \n-  Handle<BoilerplateDescription> constant_properties =\n-      isolate->factory()->NewBoilerplateDescription(boilerplate_properties_,\n-                                                    properties()->length(),\n-                                                    index_keys, has_seen_proto);\n+  Handle<ObjectBoilerplateDescription> boilerplate_description =\n+      isolate->factory()->NewObjectBoilerplateDescription(\n+          boilerplate_properties_, properties()->length(), index_keys,\n+          has_seen_proto);\n \n   int position = 0;\n   for (int i = 0; i < properties()->length(); i++) {\n     ObjectLiteral::Property* property = properties()->at(i);\n     if (property->IsPrototype()) continue;\n \n-    if (static_cast<uint32_t>(position) == boilerplate_properties_ * 2) {\n+    if (static_cast<uint32_t>(position) == boilerplate_properties_) {\n       DCHECK(property->is_computed_name());\n       break;\n     }\n@@ -510,11 +534,12 @@ void ObjectLiteral::BuildConstantProperties(Isolate* isolate) {\n     Handle<Object> value = GetBoilerplateValue(property->value(), isolate);\n \n     // Add name, value pair to the fixed array.\n-    constant_properties->set(position++, *key);\n-    constant_properties->set(position++, *value);\n+    boilerplate_description->set_key_value(position++, *key, *value);\n   }\n \n-  constant_properties_ = constant_properties;\n+  boilerplate_description->set_flags(EncodeLiteralType());\n+\n+  boilerplate_description_ = boilerplate_description;\n }\n \n bool ObjectLiteral::IsFastCloningSupported() const {\n@@ -528,8 +553,8 @@ bool ObjectLiteral::IsFastCloningSupported() const {\n \n bool ArrayLiteral::is_empty() const {\n   DCHECK(is_initialized());\n-  return values()->is_empty() &&\n-         (constant_elements().is_null() || constant_elements()->is_empty());\n+  return values()->is_empty() && (boilerplate_description().is_null() ||\n+                                  boilerplate_description()->is_empty());\n }\n \n int ArrayLiteral::InitDepthAndFlags() {\n@@ -550,7 +575,7 @@ int ArrayLiteral::InitDepthAndFlags() {\n       if (subliteral_depth > depth_acc) depth_acc = subliteral_depth;\n     }\n \n-    if (!CompileTimeValue::IsCompileTimeValue(element)) {\n+    if (!element->IsCompileTimeValue()) {\n       is_simple = false;\n     }\n   }\n@@ -563,8 +588,8 @@ int ArrayLiteral::InitDepthAndFlags() {\n   return depth_acc;\n }\n \n-void ArrayLiteral::BuildConstantElements(Isolate* isolate) {\n-  if (!constant_elements_.is_null()) return;\n+void ArrayLiteral::BuildBoilerplateDescription(Isolate* isolate) {\n+  if (!boilerplate_description_.is_null()) return;\n \n   int constants_length =\n       first_spread_index_ >= 0 ? first_spread_index_ : values()->length();\n@@ -606,7 +631,7 @@ void ArrayLiteral::BuildConstantElements(Isolate* isolate) {\n   // elements array to a copy-on-write array.\n   if (is_simple() && depth() == 1 && array_index > 0 &&\n       IsSmiOrObjectElementsKind(kind)) {\n-    fixed_array->set_map(isolate->heap()->fixed_cow_array_map());\n+    fixed_array->set_map(ReadOnlyRoots(isolate).fixed_cow_array_map());\n   }\n \n   Handle<FixedArrayBase> elements = fixed_array;\n@@ -615,14 +640,12 @@ void ArrayLiteral::BuildConstantElements(Isolate* isolate) {\n     elements = isolate->factory()->NewFixedDoubleArray(constants_length);\n     // We are copying from non-fast-double to fast-double.\n     ElementsKind from_kind = TERMINAL_FAST_ELEMENTS_KIND;\n-    accessor->CopyElements(fixed_array, from_kind, elements, constants_length);\n+    accessor->CopyElements(isolate, fixed_array, from_kind, elements,\n+                           constants_length);\n   }\n \n-  // Remember both the literal's constant values as well as the ElementsKind.\n-  Handle<ConstantElementsPair> literals =\n-      isolate->factory()->NewConstantElementsPair(kind, elements);\n-\n-  constant_elements_ = literals;\n+  boilerplate_description_ =\n+      isolate->factory()->NewArrayBoilerplateDescription(kind, elements);\n }\n \n bool ArrayLiteral::IsFastCloningSupported() const {\n@@ -643,8 +666,17 @@ Handle<Object> MaterializedLiteral::GetBoilerplateValue(Expression* expression,\n   if (expression->IsLiteral()) {\n     return expression->AsLiteral()->BuildValue(isolate);\n   }\n-  if (CompileTimeValue::IsCompileTimeValue(expression)) {\n-    return CompileTimeValue::GetValue(isolate, expression);\n+  if (expression->IsCompileTimeValue()) {\n+    if (expression->IsObjectLiteral()) {\n+      ObjectLiteral* object_literal = expression->AsObjectLiteral();\n+      DCHECK(object_literal->is_simple());\n+      return object_literal->boilerplate_description();\n+    } else {\n+      DCHECK(expression->IsArrayLiteral());\n+      ArrayLiteral* array_literal = expression->AsArrayLiteral();\n+      DCHECK(array_literal->is_simple());\n+      return array_literal->boilerplate_description();\n+    }\n   }\n   return isolate->factory()->uninitialized_value();\n }\n@@ -669,10 +701,12 @@ bool MaterializedLiteral::NeedsInitialAllocationSite() {\n \n void MaterializedLiteral::BuildConstants(Isolate* isolate) {\n   if (IsArrayLiteral()) {\n-    return AsArrayLiteral()->BuildConstantElements(isolate);\n+    AsArrayLiteral()->BuildBoilerplateDescription(isolate);\n+    return;\n   }\n   if (IsObjectLiteral()) {\n-    return AsObjectLiteral()->BuildConstantProperties(isolate);\n+    AsObjectLiteral()->BuildBoilerplateDescription(isolate);\n+    return;\n   }\n   DCHECK(IsRegExpLiteral());\n }\n@@ -698,7 +732,7 @@ Handle<TemplateObjectDescription> GetTemplateObject::GetOrBuildDescription(\n       if (this->cooked_strings()->at(i) != nullptr) {\n         cooked_strings->set(i, *this->cooked_strings()->at(i)->string());\n       } else {\n-        cooked_strings->set(i, isolate->heap()->undefined_value());\n+        cooked_strings->set(i, ReadOnlyRoots(isolate).undefined_value());\n       }\n     }\n   }\n@@ -806,9 +840,10 @@ Call::CallType Call::GetCallType() const {\n     if (proxy->var()->IsUnallocated()) {\n       return GLOBAL_CALL;\n     } else if (proxy->var()->IsLookupSlot()) {\n-      // Calls going through 'with' always use DYNAMIC rather than DYNAMIC_LOCAL\n-      // or DYNAMIC_GLOBAL.\n-      return proxy->var()->mode() == DYNAMIC ? WITH_CALL : OTHER_CALL;\n+      // Calls going through 'with' always use VariableMode::kDynamic rather\n+      // than VariableMode::kDynamicLocal or VariableMode::kDynamicGlobal.\n+      return proxy->var()->mode() == VariableMode::kDynamic ? WITH_CALL\n+                                                            : OTHER_CALL;\n     }\n   }\n \n@@ -831,7 +866,7 @@ Call::CallType Call::GetCallType() const {\n   return OTHER_CALL;\n }\n \n-CaseClause::CaseClause(Expression* label, ZoneList<Statement*>* statements)\n+CaseClause::CaseClause(Expression* label, ZonePtrList<Statement>* statements)\n     : label_(label), statements_(statements) {}\n \n bool Literal::IsPropertyName() const {\n@@ -954,7 +989,7 @@ const char* CallRuntime::debug_name() {\n   case k##NodeType:             \\\n     return static_cast<const NodeType*>(this)->labels();\n \n-ZoneList<const AstRawString*>* BreakableStatement::labels() const {\n+ZonePtrList<const AstRawString>* BreakableStatement::labels() const {\n   switch (node_type()) {\n     BREAKABLE_NODE_LIST(RETURN_LABELS)\n     ITERATION_NODE_LIST(RETURN_LABELS)"
        },
        {
            "sha": "5a2346ad9f8658c6a9aafdfb9946dd520a2d7579",
            "filename": "deps/v8/src/ast/ast.h",
            "status": "modified",
            "additions": 125,
            "deletions": 126,
            "changes": 251,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fast.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fast.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -241,6 +241,8 @@ class Expression : public AstNode {\n   // that this also checks for loads of the global \"undefined\" variable.\n   bool IsUndefinedLiteral() const;\n \n+  bool IsCompileTimeValue();\n+\n  protected:\n   Expression(int pos, NodeType type) : AstNode(pos, type) {}\n \n@@ -255,7 +257,7 @@ class BreakableStatement : public Statement {\n     TARGET_FOR_NAMED_ONLY\n   };\n \n-  ZoneList<const AstRawString*>* labels() const;\n+  ZonePtrList<const AstRawString>* labels() const;\n \n   // Testers.\n   bool is_target_for_anonymous() const {\n@@ -277,12 +279,12 @@ class BreakableStatement : public Statement {\n \n class Block : public BreakableStatement {\n  public:\n-  ZoneList<Statement*>* statements() { return &statements_; }\n+  ZonePtrList<Statement>* statements() { return &statements_; }\n   bool ignore_completion_value() const {\n     return IgnoreCompletionField::decode(bit_field_);\n   }\n \n-  inline ZoneList<const AstRawString*>* labels() const;\n+  inline ZonePtrList<const AstRawString>* labels() const;\n \n   bool IsJump() const {\n     return !statements_.is_empty() && statements_.last()->IsJump() &&\n@@ -295,7 +297,7 @@ class Block : public BreakableStatement {\n  private:\n   friend class AstNodeFactory;\n \n-  ZoneList<Statement*> statements_;\n+  ZonePtrList<Statement> statements_;\n   Scope* scope_;\n \n   class IgnoreCompletionField\n@@ -304,7 +306,7 @@ class Block : public BreakableStatement {\n       : public BitField<bool, IgnoreCompletionField::kNext, 1> {};\n \n  protected:\n-  Block(Zone* zone, ZoneList<const AstRawString*>* labels, int capacity,\n+  Block(Zone* zone, ZonePtrList<const AstRawString>* labels, int capacity,\n         bool ignore_completion_value)\n       : BreakableStatement(TARGET_FOR_NAMED_ONLY, kNoSourcePosition, kBlock),\n         statements_(capacity, zone),\n@@ -319,18 +321,18 @@ class LabeledBlock final : public Block {\n   friend class AstNodeFactory;\n   friend class Block;\n \n-  LabeledBlock(Zone* zone, ZoneList<const AstRawString*>* labels, int capacity,\n-               bool ignore_completion_value)\n+  LabeledBlock(Zone* zone, ZonePtrList<const AstRawString>* labels,\n+               int capacity, bool ignore_completion_value)\n       : Block(zone, labels, capacity, ignore_completion_value),\n         labels_(labels) {\n     DCHECK_NOT_NULL(labels);\n     DCHECK_GT(labels->length(), 0);\n   }\n \n-  ZoneList<const AstRawString*>* labels_;\n+  ZonePtrList<const AstRawString>* labels_;\n };\n \n-inline ZoneList<const AstRawString*>* Block::labels() const {\n+inline ZonePtrList<const AstRawString>* Block::labels() const {\n   if (IsLabeledField::decode(bit_field_)) {\n     return static_cast<const LabeledBlock*>(this)->labels_;\n   }\n@@ -437,10 +439,10 @@ class IterationStatement : public BreakableStatement {\n   Statement* body() const { return body_; }\n   void set_body(Statement* s) { body_ = s; }\n \n-  ZoneList<const AstRawString*>* labels() const { return labels_; }\n+  ZonePtrList<const AstRawString>* labels() const { return labels_; }\n \n  protected:\n-  IterationStatement(ZoneList<const AstRawString*>* labels, int pos,\n+  IterationStatement(ZonePtrList<const AstRawString>* labels, int pos,\n                      NodeType type)\n       : BreakableStatement(TARGET_FOR_ANONYMOUS, pos, type),\n         labels_(labels),\n@@ -451,7 +453,7 @@ class IterationStatement : public BreakableStatement {\n       BreakableStatement::kNextBitFieldIndex;\n \n  private:\n-  ZoneList<const AstRawString*>* labels_;\n+  ZonePtrList<const AstRawString>* labels_;\n   Statement* body_;\n };\n \n@@ -468,7 +470,7 @@ class DoWhileStatement final : public IterationStatement {\n  private:\n   friend class AstNodeFactory;\n \n-  DoWhileStatement(ZoneList<const AstRawString*>* labels, int pos)\n+  DoWhileStatement(ZonePtrList<const AstRawString>* labels, int pos)\n       : IterationStatement(labels, pos, kDoWhileStatement), cond_(nullptr) {}\n \n   Expression* cond_;\n@@ -487,7 +489,7 @@ class WhileStatement final : public IterationStatement {\n  private:\n   friend class AstNodeFactory;\n \n-  WhileStatement(ZoneList<const AstRawString*>* labels, int pos)\n+  WhileStatement(ZonePtrList<const AstRawString>* labels, int pos)\n       : IterationStatement(labels, pos, kWhileStatement), cond_(nullptr) {}\n \n   Expression* cond_;\n@@ -511,7 +513,7 @@ class ForStatement final : public IterationStatement {\n  private:\n   friend class AstNodeFactory;\n \n-  ForStatement(ZoneList<const AstRawString*>* labels, int pos)\n+  ForStatement(ZonePtrList<const AstRawString>* labels, int pos)\n       : IterationStatement(labels, pos, kForStatement),\n         init_(nullptr),\n         cond_(nullptr),\n@@ -537,7 +539,7 @@ class ForEachStatement : public IterationStatement {\n   }\n \n  protected:\n-  ForEachStatement(ZoneList<const AstRawString*>* labels, int pos,\n+  ForEachStatement(ZonePtrList<const AstRawString>* labels, int pos,\n                    NodeType type)\n       : IterationStatement(labels, pos, type) {}\n };\n@@ -564,7 +566,7 @@ class ForInStatement final : public ForEachStatement {\n  private:\n   friend class AstNodeFactory;\n \n-  ForInStatement(ZoneList<const AstRawString*>* labels, int pos)\n+  ForInStatement(ZonePtrList<const AstRawString>* labels, int pos)\n       : ForEachStatement(labels, pos, kForInStatement),\n         each_(nullptr),\n         subject_(nullptr) {\n@@ -630,7 +632,7 @@ class ForOfStatement final : public ForEachStatement {\n  private:\n   friend class AstNodeFactory;\n \n-  ForOfStatement(ZoneList<const AstRawString*>* labels, int pos)\n+  ForOfStatement(ZonePtrList<const AstRawString>* labels, int pos)\n       : ForEachStatement(labels, pos, kForOfStatement),\n         iterator_(nullptr),\n         assign_iterator_(nullptr),\n@@ -757,40 +759,40 @@ class CaseClause final : public ZoneObject {\n     DCHECK(!is_default());\n     return label_;\n   }\n-  ZoneList<Statement*>* statements() const { return statements_; }\n+  ZonePtrList<Statement>* statements() const { return statements_; }\n \n  private:\n   friend class AstNodeFactory;\n \n-  CaseClause(Expression* label, ZoneList<Statement*>* statements);\n+  CaseClause(Expression* label, ZonePtrList<Statement>* statements);\n \n   Expression* label_;\n-  ZoneList<Statement*>* statements_;\n+  ZonePtrList<Statement>* statements_;\n };\n \n \n class SwitchStatement final : public BreakableStatement {\n  public:\n-  ZoneList<const AstRawString*>* labels() const { return labels_; }\n+  ZonePtrList<const AstRawString>* labels() const { return labels_; }\n \n   Expression* tag() const { return tag_; }\n   void set_tag(Expression* t) { tag_ = t; }\n \n-  ZoneList<CaseClause*>* cases() { return &cases_; }\n+  ZonePtrList<CaseClause>* cases() { return &cases_; }\n \n  private:\n   friend class AstNodeFactory;\n \n-  SwitchStatement(Zone* zone, ZoneList<const AstRawString*>* labels,\n+  SwitchStatement(Zone* zone, ZonePtrList<const AstRawString>* labels,\n                   Expression* tag, int pos)\n       : BreakableStatement(TARGET_FOR_ANONYMOUS, pos, kSwitchStatement),\n         labels_(labels),\n         tag_(tag),\n         cases_(4, zone) {}\n \n-  ZoneList<const AstRawString*>* labels_;\n+  ZonePtrList<const AstRawString>* labels_;\n   Expression* tag_;\n-  ZoneList<CaseClause*> cases_;\n+  ZonePtrList<CaseClause> cases_;\n };\n \n \n@@ -1120,8 +1122,8 @@ class MaterializedLiteral : public Expression {\n   void BuildConstants(Isolate* isolate);\n \n   // If the expression is a literal, return the literal value;\n-  // if the expression is a materialized literal and is simple return a\n-  // compile time value as encoded by CompileTimeValue::GetValue().\n+  // if the expression is a materialized literal and is_simple\n+  // then return an Array or Object Boilerplate Description\n   // Otherwise, return undefined literal as the placeholder\n   // in the object literal boilerplate.\n   Handle<Object> GetBoilerplateValue(Expression* expression, Isolate* isolate);\n@@ -1275,12 +1277,12 @@ class ObjectLiteral final : public AggregateLiteral {\n  public:\n   typedef ObjectLiteralProperty Property;\n \n-  Handle<BoilerplateDescription> constant_properties() const {\n-    DCHECK(!constant_properties_.is_null());\n-    return constant_properties_;\n+  Handle<ObjectBoilerplateDescription> boilerplate_description() const {\n+    DCHECK(!boilerplate_description_.is_null());\n+    return boilerplate_description_;\n   }\n   int properties_count() const { return boilerplate_properties_; }\n-  ZoneList<Property*>* properties() const { return properties_; }\n+  ZonePtrList<Property>* properties() const { return properties_; }\n   bool has_elements() const { return HasElementsField::decode(bit_field_); }\n   bool has_rest_property() const {\n     return HasRestPropertyField::decode(bit_field_);\n@@ -1303,17 +1305,17 @@ class ObjectLiteral final : public AggregateLiteral {\n   // Populate the depth field and flags, returns the depth.\n   int InitDepthAndFlags();\n \n-  // Get the constant properties fixed array, populating it if necessary.\n-  Handle<BoilerplateDescription> GetOrBuildConstantProperties(\n+  // Get the boilerplate description, populating it if necessary.\n+  Handle<ObjectBoilerplateDescription> GetOrBuildBoilerplateDescription(\n       Isolate* isolate) {\n-    if (constant_properties_.is_null()) {\n-      BuildConstantProperties(isolate);\n+    if (boilerplate_description_.is_null()) {\n+      BuildBoilerplateDescription(isolate);\n     }\n-    return constant_properties();\n+    return boilerplate_description();\n   }\n \n-  // Populate the constant properties fixed array.\n-  void BuildConstantProperties(Isolate* isolate);\n+  // Populate the boilerplate description.\n+  void BuildBoilerplateDescription(Isolate* isolate);\n \n   // Mark all computed expressions that are bound to a key that\n   // is shadowed by a later occurrence of the same key. For the\n@@ -1355,7 +1357,7 @@ class ObjectLiteral final : public AggregateLiteral {\n  private:\n   friend class AstNodeFactory;\n \n-  ObjectLiteral(ZoneList<Property*>* properties,\n+  ObjectLiteral(ZonePtrList<Property>* properties,\n                 uint32_t boilerplate_properties, int pos,\n                 bool has_rest_property)\n       : AggregateLiteral(pos, kObjectLiteral),\n@@ -1380,7 +1382,7 @@ class ObjectLiteral final : public AggregateLiteral {\n   }\n \n   uint32_t boilerplate_properties_;\n-  Handle<BoilerplateDescription> constant_properties_;\n+  Handle<ObjectBoilerplateDescription> boilerplate_description_;\n   ZoneList<Property*>* properties_;\n \n   class HasElementsField\n@@ -1423,11 +1425,11 @@ class AccessorTable\n // for minimizing the work when constructing it at runtime.\n class ArrayLiteral final : public AggregateLiteral {\n  public:\n-  Handle<ConstantElementsPair> constant_elements() const {\n-    return constant_elements_;\n+  Handle<ArrayBoilerplateDescription> boilerplate_description() const {\n+    return boilerplate_description_;\n   }\n \n-  ZoneList<Expression*>* values() const { return values_; }\n+  ZonePtrList<Expression>* values() const { return values_; }\n \n   int first_spread_index() const { return first_spread_index_; }\n \n@@ -1436,16 +1438,17 @@ class ArrayLiteral final : public AggregateLiteral {\n   // Populate the depth field and flags, returns the depth.\n   int InitDepthAndFlags();\n \n-  // Get the constant elements fixed array, populating it if necessary.\n-  Handle<ConstantElementsPair> GetOrBuildConstantElements(Isolate* isolate) {\n-    if (constant_elements_.is_null()) {\n-      BuildConstantElements(isolate);\n+  // Get the boilerplate description, populating it if necessary.\n+  Handle<ArrayBoilerplateDescription> GetOrBuildBoilerplateDescription(\n+      Isolate* isolate) {\n+    if (boilerplate_description_.is_null()) {\n+      BuildBoilerplateDescription(isolate);\n     }\n-    return constant_elements();\n+    return boilerplate_description();\n   }\n \n-  // Populate the constant elements fixed array.\n-  void BuildConstantElements(Isolate* isolate);\n+  // Populate the boilerplate description.\n+  void BuildBoilerplateDescription(Isolate* isolate);\n \n   // Determines whether the {CreateShallowArrayLiteral} builtin can be used.\n   bool IsFastCloningSupported() const;\n@@ -1458,15 +1461,14 @@ class ArrayLiteral final : public AggregateLiteral {\n  private:\n   friend class AstNodeFactory;\n \n-  ArrayLiteral(ZoneList<Expression*>* values, int first_spread_index, int pos)\n+  ArrayLiteral(ZonePtrList<Expression>* values, int first_spread_index, int pos)\n       : AggregateLiteral(pos, kArrayLiteral),\n         first_spread_index_(first_spread_index),\n-        values_(values) {\n-  }\n+        values_(values) {}\n \n   int first_spread_index_;\n-  Handle<ConstantElementsPair> constant_elements_;\n-  ZoneList<Expression*>* values_;\n+  Handle<ArrayBoilerplateDescription> boilerplate_description_;\n+  ZonePtrList<Expression>* values_;\n };\n \n enum class HoleCheckMode { kRequired, kElided };\n@@ -1633,7 +1635,7 @@ class ResolvedProperty final : public Expression {\n class Call final : public Expression {\n  public:\n   Expression* expression() const { return expression_; }\n-  ZoneList<Expression*>* arguments() const { return arguments_; }\n+  ZonePtrList<Expression>* arguments() const { return arguments_; }\n \n   bool is_possibly_eval() const {\n     return IsPossiblyEvalField::decode(bit_field_);\n@@ -1672,17 +1674,15 @@ class Call final : public Expression {\n  private:\n   friend class AstNodeFactory;\n \n-  Call(Expression* expression, ZoneList<Expression*>* arguments, int pos,\n+  Call(Expression* expression, ZonePtrList<Expression>* arguments, int pos,\n        PossiblyEval possibly_eval)\n-      : Expression(pos, kCall),\n-        expression_(expression),\n-        arguments_(arguments) {\n+      : Expression(pos, kCall), expression_(expression), arguments_(arguments) {\n     bit_field_ |=\n         IsPossiblyEvalField::encode(possibly_eval == IS_POSSIBLY_EVAL) |\n         IsTaggedTemplateField::encode(false);\n   }\n \n-  Call(Expression* expression, ZoneList<Expression*>* arguments, int pos,\n+  Call(Expression* expression, ZonePtrList<Expression>* arguments, int pos,\n        TaggedTemplateTag tag)\n       : Expression(pos, kCall), expression_(expression), arguments_(arguments) {\n     bit_field_ |= IsPossiblyEvalField::encode(false) |\n@@ -1695,14 +1695,14 @@ class Call final : public Expression {\n       : public BitField<bool, IsPossiblyEvalField::kNext, 1> {};\n \n   Expression* expression_;\n-  ZoneList<Expression*>* arguments_;\n+  ZonePtrList<Expression>* arguments_;\n };\n \n \n class CallNew final : public Expression {\n  public:\n   Expression* expression() const { return expression_; }\n-  ZoneList<Expression*>* arguments() const { return arguments_; }\n+  ZonePtrList<Expression>* arguments() const { return arguments_; }\n \n   bool only_last_arg_is_spread() {\n     return !arguments_->is_empty() && arguments_->last()->IsSpread();\n@@ -1711,14 +1711,13 @@ class CallNew final : public Expression {\n  private:\n   friend class AstNodeFactory;\n \n-  CallNew(Expression* expression, ZoneList<Expression*>* arguments, int pos)\n+  CallNew(Expression* expression, ZonePtrList<Expression>* arguments, int pos)\n       : Expression(pos, kCallNew),\n         expression_(expression),\n-        arguments_(arguments) {\n-  }\n+        arguments_(arguments) {}\n \n   Expression* expression_;\n-  ZoneList<Expression*>* arguments_;\n+  ZonePtrList<Expression>* arguments_;\n };\n \n // The CallRuntime class does not represent any official JavaScript\n@@ -1727,7 +1726,7 @@ class CallNew final : public Expression {\n // implemented in JavaScript.\n class CallRuntime final : public Expression {\n  public:\n-  ZoneList<Expression*>* arguments() const { return arguments_; }\n+  ZonePtrList<Expression>* arguments() const { return arguments_; }\n   bool is_jsruntime() const { return function_ == nullptr; }\n \n   int context_index() const {\n@@ -1745,19 +1744,19 @@ class CallRuntime final : public Expression {\n   friend class AstNodeFactory;\n \n   CallRuntime(const Runtime::Function* function,\n-              ZoneList<Expression*>* arguments, int pos)\n+              ZonePtrList<Expression>* arguments, int pos)\n       : Expression(pos, kCallRuntime),\n         function_(function),\n         arguments_(arguments) {}\n-  CallRuntime(int context_index, ZoneList<Expression*>* arguments, int pos)\n+  CallRuntime(int context_index, ZonePtrList<Expression>* arguments, int pos)\n       : Expression(pos, kCallRuntime),\n         context_index_(context_index),\n         function_(nullptr),\n         arguments_(arguments) {}\n \n   int context_index_;\n   const Runtime::Function* function_;\n-  ZoneList<Expression*>* arguments_;\n+  ZonePtrList<Expression>* arguments_;\n };\n \n \n@@ -2190,7 +2189,7 @@ class FunctionLiteral final : public Expression {\n   const AstConsString* raw_name() const { return raw_name_; }\n   void set_raw_name(const AstConsString* name) { raw_name_ = name; }\n   DeclarationScope* scope() const { return scope_; }\n-  ZoneList<Statement*>* body() const { return body_; }\n+  ZonePtrList<Statement>* body() const { return body_; }\n   void set_function_token_position(int pos) { function_token_position_ = pos; }\n   int function_token_position() const { return function_token_position_; }\n   int start_position() const;\n@@ -2310,7 +2309,7 @@ class FunctionLiteral final : public Expression {\n \n   FunctionLiteral(\n       Zone* zone, const AstRawString* name, AstValueFactory* ast_value_factory,\n-      DeclarationScope* scope, ZoneList<Statement*>* body,\n+      DeclarationScope* scope, ZonePtrList<Statement>* body,\n       int expected_property_count, int parameter_count, int function_length,\n       FunctionType function_type, ParameterFlag has_duplicate_parameters,\n       EagerCompileHint eager_compile_hint, int position, bool has_braces,\n@@ -2359,7 +2358,7 @@ class FunctionLiteral final : public Expression {\n \n   const AstConsString* raw_name_;\n   DeclarationScope* scope_;\n-  ZoneList<Statement*>* body_;\n+  ZonePtrList<Statement>* body_;\n   const AstConsString* raw_inferred_name_;\n   Handle<String> inferred_name_;\n   ProducedPreParsedScopeData* produced_preparsed_scope_data_;\n@@ -2407,15 +2406,16 @@ class ClassLiteralProperty final : public LiteralProperty {\n class InitializeClassFieldsStatement final : public Statement {\n  public:\n   typedef ClassLiteralProperty Property;\n-  ZoneList<Property*>* fields() const { return fields_; }\n+\n+  ZonePtrList<Property>* fields() const { return fields_; }\n \n  private:\n   friend class AstNodeFactory;\n \n-  InitializeClassFieldsStatement(ZoneList<Property*>* fields, int pos)\n+  InitializeClassFieldsStatement(ZonePtrList<Property>* fields, int pos)\n       : Statement(pos, kInitializeClassFieldsStatement), fields_(fields) {}\n \n-  ZoneList<Property*>* fields_;\n+  ZonePtrList<Property>* fields_;\n };\n \n class ClassLiteral final : public Expression {\n@@ -2426,7 +2426,7 @@ class ClassLiteral final : public Expression {\n   Variable* class_variable() const { return class_variable_; }\n   Expression* extends() const { return extends_; }\n   FunctionLiteral* constructor() const { return constructor_; }\n-  ZoneList<Property*>* properties() const { return properties_; }\n+  ZonePtrList<Property>* properties() const { return properties_; }\n   int start_position() const { return position(); }\n   int end_position() const { return end_position_; }\n   bool has_name_static_property() const {\n@@ -2455,7 +2455,7 @@ class ClassLiteral final : public Expression {\n   friend class AstNodeFactory;\n \n   ClassLiteral(Scope* scope, Variable* class_variable, Expression* extends,\n-               FunctionLiteral* constructor, ZoneList<Property*>* properties,\n+               FunctionLiteral* constructor, ZonePtrList<Property>* properties,\n                FunctionLiteral* static_fields_initializer,\n                FunctionLiteral* instance_fields_initializer_function,\n                int start_position, int end_position,\n@@ -2481,7 +2481,7 @@ class ClassLiteral final : public Expression {\n   Variable* class_variable_;\n   Expression* extends_;\n   FunctionLiteral* constructor_;\n-  ZoneList<Property*>* properties_;\n+  ZonePtrList<Property>* properties_;\n   FunctionLiteral* static_fields_initializer_;\n   FunctionLiteral* instance_fields_initializer_function_;\n   class HasNameStaticProperty\n@@ -2636,10 +2636,10 @@ class GetIterator final : public Expression {\n // (defined at https://tc39.github.io/ecma262/#sec-gettemplateobject).\n class GetTemplateObject final : public Expression {\n  public:\n-  const ZoneList<const AstRawString*>* cooked_strings() const {\n+  const ZonePtrList<const AstRawString>* cooked_strings() const {\n     return cooked_strings_;\n   }\n-  const ZoneList<const AstRawString*>* raw_strings() const {\n+  const ZonePtrList<const AstRawString>* raw_strings() const {\n     return raw_strings_;\n   }\n \n@@ -2648,34 +2648,35 @@ class GetTemplateObject final : public Expression {\n  private:\n   friend class AstNodeFactory;\n \n-  GetTemplateObject(const ZoneList<const AstRawString*>* cooked_strings,\n-                    const ZoneList<const AstRawString*>* raw_strings, int pos)\n+  GetTemplateObject(const ZonePtrList<const AstRawString>* cooked_strings,\n+                    const ZonePtrList<const AstRawString>* raw_strings, int pos)\n       : Expression(pos, kGetTemplateObject),\n         cooked_strings_(cooked_strings),\n         raw_strings_(raw_strings) {}\n \n-  const ZoneList<const AstRawString*>* cooked_strings_;\n-  const ZoneList<const AstRawString*>* raw_strings_;\n+  const ZonePtrList<const AstRawString>* cooked_strings_;\n+  const ZonePtrList<const AstRawString>* raw_strings_;\n };\n \n class TemplateLiteral final : public Expression {\n  public:\n-  using StringList = ZoneList<const AstRawString*>;\n-  using ExpressionList = ZoneList<Expression*>;\n-\n-  const StringList* string_parts() const { return string_parts_; }\n-  const ExpressionList* substitutions() const { return substitutions_; }\n+  const ZonePtrList<const AstRawString>* string_parts() const {\n+    return string_parts_;\n+  }\n+  const ZonePtrList<Expression>* substitutions() const {\n+    return substitutions_;\n+  }\n \n  private:\n   friend class AstNodeFactory;\n-  TemplateLiteral(const StringList* parts, const ExpressionList* substitutions,\n-                  int pos)\n+  TemplateLiteral(const ZonePtrList<const AstRawString>* parts,\n+                  const ZonePtrList<Expression>* substitutions, int pos)\n       : Expression(pos, kTemplateLiteral),\n         string_parts_(parts),\n         substitutions_(substitutions) {}\n \n-  const StringList* string_parts_;\n-  const ExpressionList* substitutions_;\n+  const ZonePtrList<const AstRawString>* string_parts_;\n+  const ZonePtrList<Expression>* substitutions_;\n };\n \n // ----------------------------------------------------------------------------\n@@ -2692,15 +2693,15 @@ class AstVisitor BASE_EMBEDDED {\n     for (Declaration* decl : *declarations) Visit(decl);\n   }\n \n-  void VisitStatements(ZoneList<Statement*>* statements) {\n+  void VisitStatements(ZonePtrList<Statement>* statements) {\n     for (int i = 0; i < statements->length(); i++) {\n       Statement* stmt = statements->at(i);\n       Visit(stmt);\n       if (stmt->IsJump()) break;\n     }\n   }\n \n-  void VisitExpressions(ZoneList<Expression*>* expressions) {\n+  void VisitExpressions(ZonePtrList<Expression>* expressions) {\n     for (int i = 0; i < expressions->length(); i++) {\n       // The variable statement visiting code may pass null expressions\n       // to this code. Maybe this should be handled by introducing an\n@@ -2794,30 +2795,30 @@ class AstNodeFactory final BASE_EMBEDDED {\n   }\n \n   Block* NewBlock(int capacity, bool ignore_completion_value,\n-                  ZoneList<const AstRawString*>* labels = nullptr) {\n+                  ZonePtrList<const AstRawString>* labels = nullptr) {\n     return labels != nullptr\n                ? new (zone_) LabeledBlock(zone_, labels, capacity,\n                                           ignore_completion_value)\n                : new (zone_)\n                      Block(zone_, labels, capacity, ignore_completion_value);\n   }\n \n-#define STATEMENT_WITH_LABELS(NodeType)                                     \\\n-  NodeType* New##NodeType(ZoneList<const AstRawString*>* labels, int pos) { \\\n-    return new (zone_) NodeType(labels, pos);                               \\\n+#define STATEMENT_WITH_LABELS(NodeType)                                       \\\n+  NodeType* New##NodeType(ZonePtrList<const AstRawString>* labels, int pos) { \\\n+    return new (zone_) NodeType(labels, pos);                                 \\\n   }\n   STATEMENT_WITH_LABELS(DoWhileStatement)\n   STATEMENT_WITH_LABELS(WhileStatement)\n   STATEMENT_WITH_LABELS(ForStatement)\n #undef STATEMENT_WITH_LABELS\n \n-  SwitchStatement* NewSwitchStatement(ZoneList<const AstRawString*>* labels,\n+  SwitchStatement* NewSwitchStatement(ZonePtrList<const AstRawString>* labels,\n                                       Expression* tag, int pos) {\n     return new (zone_) SwitchStatement(zone_, labels, tag, pos);\n   }\n \n   ForEachStatement* NewForEachStatement(ForEachStatement::VisitMode visit_mode,\n-                                        ZoneList<const AstRawString*>* labels,\n+                                        ZonePtrList<const AstRawString>* labels,\n                                         int pos) {\n     switch (visit_mode) {\n       case ForEachStatement::ENUMERATE: {\n@@ -2830,7 +2831,7 @@ class AstNodeFactory final BASE_EMBEDDED {\n     UNREACHABLE();\n   }\n \n-  ForOfStatement* NewForOfStatement(ZoneList<const AstRawString*>* labels,\n+  ForOfStatement* NewForOfStatement(ZonePtrList<const AstRawString>* labels,\n                                     int pos) {\n     return new (zone_) ForOfStatement(labels, pos);\n   }\n@@ -2921,7 +2922,7 @@ class AstNodeFactory final BASE_EMBEDDED {\n   }\n \n   CaseClause* NewCaseClause(Expression* label,\n-                            ZoneList<Statement*>* statements) {\n+                            ZonePtrList<Statement>* statements) {\n     return new (zone_) CaseClause(label, statements);\n   }\n \n@@ -2961,7 +2962,7 @@ class AstNodeFactory final BASE_EMBEDDED {\n   }\n \n   ObjectLiteral* NewObjectLiteral(\n-      ZoneList<ObjectLiteral::Property*>* properties,\n+      ZonePtrList<ObjectLiteral::Property>* properties,\n       uint32_t boilerplate_properties, int pos, bool has_rest_property) {\n     return new (zone_) ObjectLiteral(properties, boilerplate_properties, pos,\n                                      has_rest_property);\n@@ -2986,12 +2987,11 @@ class AstNodeFactory final BASE_EMBEDDED {\n     return new (zone_) RegExpLiteral(pattern, flags, pos);\n   }\n \n-  ArrayLiteral* NewArrayLiteral(ZoneList<Expression*>* values,\n-                                int pos) {\n+  ArrayLiteral* NewArrayLiteral(ZonePtrList<Expression>* values, int pos) {\n     return new (zone_) ArrayLiteral(values, -1, pos);\n   }\n \n-  ArrayLiteral* NewArrayLiteral(ZoneList<Expression*>* values,\n+  ArrayLiteral* NewArrayLiteral(ZonePtrList<Expression>* values,\n                                 int first_spread_index, int pos) {\n     return new (zone_) ArrayLiteral(values, first_spread_index, pos);\n   }\n@@ -3027,35 +3027,34 @@ class AstNodeFactory final BASE_EMBEDDED {\n     return new (zone_) ResolvedProperty(obj, property, pos);\n   }\n \n-  Call* NewCall(Expression* expression, ZoneList<Expression*>* arguments,\n+  Call* NewCall(Expression* expression, ZonePtrList<Expression>* arguments,\n                 int pos, Call::PossiblyEval possibly_eval = Call::NOT_EVAL) {\n     return new (zone_) Call(expression, arguments, pos, possibly_eval);\n   }\n \n   Call* NewTaggedTemplate(Expression* expression,\n-                          ZoneList<Expression*>* arguments, int pos) {\n+                          ZonePtrList<Expression>* arguments, int pos) {\n     return new (zone_)\n         Call(expression, arguments, pos, Call::TaggedTemplateTag::kTrue);\n   }\n \n   CallNew* NewCallNew(Expression* expression,\n-                      ZoneList<Expression*>* arguments,\n-                      int pos) {\n+                      ZonePtrList<Expression>* arguments, int pos) {\n     return new (zone_) CallNew(expression, arguments, pos);\n   }\n \n   CallRuntime* NewCallRuntime(Runtime::FunctionId id,\n-                              ZoneList<Expression*>* arguments, int pos) {\n+                              ZonePtrList<Expression>* arguments, int pos) {\n     return new (zone_) CallRuntime(Runtime::FunctionForId(id), arguments, pos);\n   }\n \n   CallRuntime* NewCallRuntime(const Runtime::Function* function,\n-                              ZoneList<Expression*>* arguments, int pos) {\n+                              ZonePtrList<Expression>* arguments, int pos) {\n     return new (zone_) CallRuntime(function, arguments, pos);\n   }\n \n   CallRuntime* NewCallRuntime(int context_index,\n-                              ZoneList<Expression*>* arguments, int pos) {\n+                              ZonePtrList<Expression>* arguments, int pos) {\n     return new (zone_) CallRuntime(context_index, arguments, pos);\n   }\n \n@@ -3158,7 +3157,7 @@ class AstNodeFactory final BASE_EMBEDDED {\n \n   FunctionLiteral* NewFunctionLiteral(\n       const AstRawString* name, DeclarationScope* scope,\n-      ZoneList<Statement*>* body, int expected_property_count,\n+      ZonePtrList<Statement>* body, int expected_property_count,\n       int parameter_count, int function_length,\n       FunctionLiteral::ParameterFlag has_duplicate_parameters,\n       FunctionLiteral::FunctionType function_type,\n@@ -3176,15 +3175,15 @@ class AstNodeFactory final BASE_EMBEDDED {\n   // result of an eval (top-level or otherwise), or the result of calling\n   // the Function constructor.\n   FunctionLiteral* NewScriptOrEvalFunctionLiteral(DeclarationScope* scope,\n-                                                  ZoneList<Statement*>* body,\n+                                                  ZonePtrList<Statement>* body,\n                                                   int expected_property_count,\n                                                   int parameter_count) {\n     return new (zone_) FunctionLiteral(\n         zone_, ast_value_factory_->empty_string(), ast_value_factory_, scope,\n         body, expected_property_count, parameter_count, parameter_count,\n         FunctionLiteral::kAnonymousExpression,\n         FunctionLiteral::kNoDuplicateParameters,\n-        FunctionLiteral::kShouldLazyCompile, 0, true,\n+        FunctionLiteral::kShouldLazyCompile, 0, /* has_braces */ false,\n         FunctionLiteral::kIdTypeTopLevel);\n   }\n \n@@ -3198,7 +3197,7 @@ class AstNodeFactory final BASE_EMBEDDED {\n   ClassLiteral* NewClassLiteral(\n       Scope* scope, Variable* variable, Expression* extends,\n       FunctionLiteral* constructor,\n-      ZoneList<ClassLiteral::Property*>* properties,\n+      ZonePtrList<ClassLiteral::Property>* properties,\n       FunctionLiteral* static_fields_initializer,\n       FunctionLiteral* instance_fields_initializer_function, int start_position,\n       int end_position, bool has_name_static_property,\n@@ -3255,14 +3254,14 @@ class AstNodeFactory final BASE_EMBEDDED {\n   }\n \n   GetTemplateObject* NewGetTemplateObject(\n-      const ZoneList<const AstRawString*>* cooked_strings,\n-      const ZoneList<const AstRawString*>* raw_strings, int pos) {\n+      const ZonePtrList<const AstRawString>* cooked_strings,\n+      const ZonePtrList<const AstRawString>* raw_strings, int pos) {\n     return new (zone_) GetTemplateObject(cooked_strings, raw_strings, pos);\n   }\n \n   TemplateLiteral* NewTemplateLiteral(\n-      const ZoneList<const AstRawString*>* string_parts,\n-      const ZoneList<Expression*>* substitutions, int pos) {\n+      const ZonePtrList<const AstRawString>* string_parts,\n+      const ZonePtrList<Expression>* substitutions, int pos) {\n     return new (zone_) TemplateLiteral(string_parts, substitutions, pos);\n   }\n \n@@ -3271,7 +3270,7 @@ class AstNodeFactory final BASE_EMBEDDED {\n   }\n \n   InitializeClassFieldsStatement* NewInitializeClassFieldsStatement(\n-      ZoneList<ClassLiteralProperty*>* args, int pos) {\n+      ZonePtrList<ClassLiteral::Property>* args, int pos) {\n     return new (zone_) InitializeClassFieldsStatement(args, pos);\n   }\n "
        },
        {
            "sha": "f21759ab7da80e1a5555dd707ddbed8a36fec08e",
            "filename": "deps/v8/src/ast/compile-time-value.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 53,
            "changes": 53,
            "blob_url": "https://github.com/nodejs/node/blob/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fast%2Fcompile-time-value.cc",
            "raw_url": "https://github.com/nodejs/node/raw/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fast%2Fcompile-time-value.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fcompile-time-value.cc?ref=12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342",
            "patch": "@@ -1,53 +0,0 @@\n-// Copyright 2016 the V8 project authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#include \"src/ast/compile-time-value.h\"\n-\n-#include \"src/ast/ast.h\"\n-#include \"src/handles-inl.h\"\n-#include \"src/heap/factory.h\"\n-#include \"src/isolate.h\"\n-#include \"src/objects-inl.h\"\n-\n-namespace v8 {\n-namespace internal {\n-\n-bool CompileTimeValue::IsCompileTimeValue(Expression* expression) {\n-  if (expression->IsLiteral()) return true;\n-  MaterializedLiteral* literal = expression->AsMaterializedLiteral();\n-  if (literal == nullptr) return false;\n-  return literal->IsSimple();\n-}\n-\n-Handle<FixedArray> CompileTimeValue::GetValue(Isolate* isolate,\n-                                              Expression* expression) {\n-  Factory* factory = isolate->factory();\n-  DCHECK(IsCompileTimeValue(expression));\n-  Handle<FixedArray> result = factory->NewFixedArray(2, TENURED);\n-  if (expression->IsObjectLiteral()) {\n-    ObjectLiteral* object_literal = expression->AsObjectLiteral();\n-    DCHECK(object_literal->is_simple());\n-    int literalTypeFlag = object_literal->EncodeLiteralType();\n-    DCHECK_NE(kArrayLiteralFlag, literalTypeFlag);\n-    result->set(kLiteralTypeSlot, Smi::FromInt(literalTypeFlag));\n-    result->set(kElementsSlot, *object_literal->constant_properties());\n-  } else {\n-    ArrayLiteral* array_literal = expression->AsArrayLiteral();\n-    DCHECK(array_literal->is_simple());\n-    result->set(kLiteralTypeSlot, Smi::FromInt(kArrayLiteralFlag));\n-    result->set(kElementsSlot, *array_literal->constant_elements());\n-  }\n-  return result;\n-}\n-\n-int CompileTimeValue::GetLiteralTypeFlags(Handle<FixedArray> value) {\n-  return Smi::ToInt(value->get(kLiteralTypeSlot));\n-}\n-\n-Handle<HeapObject> CompileTimeValue::GetElements(Handle<FixedArray> value) {\n-  return Handle<HeapObject>(HeapObject::cast(value->get(kElementsSlot)));\n-}\n-\n-}  // namespace internal\n-}  // namespace v8"
        },
        {
            "sha": "874bc1b32f8cb50ffe05f3a4f0b3fdeb4c7dbd2e",
            "filename": "deps/v8/src/ast/compile-time-value.h",
            "status": "removed",
            "additions": 0,
            "deletions": 46,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fast%2Fcompile-time-value.h",
            "raw_url": "https://github.com/nodejs/node/raw/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fast%2Fcompile-time-value.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fcompile-time-value.h?ref=12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342",
            "patch": "@@ -1,46 +0,0 @@\n-// Copyright 2015 the V8 project authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#ifndef V8_AST_COMPILE_TIME_VALUE_H_\n-#define V8_AST_COMPILE_TIME_VALUE_H_\n-\n-#include \"src/allocation.h\"\n-#include \"src/globals.h\"\n-\n-namespace v8 {\n-namespace internal {\n-\n-class Expression;\n-\n-// Support for handling complex values (array and object literals) that\n-// can be fully handled at compile time.\n-class CompileTimeValue : public AllStatic {\n- public:\n-  // This is a special marker used to encode array literals. The value has to be\n-  // different from any value possibly returned by\n-  // ObjectLiteral::EncodeLiteralType.\n-  static const int kArrayLiteralFlag = -1;\n-\n-  static bool IsCompileTimeValue(Expression* expression);\n-\n-  // Get the value as a compile time value.\n-  static Handle<FixedArray> GetValue(Isolate* isolate, Expression* expression);\n-\n-  // Get the encoded literal type. This can either be kArrayLiteralFlag or\n-  // encoded properties of an ObjectLiteral returned by\n-  // ObjectLiteral::EncodeLiteralType.\n-  static int GetLiteralTypeFlags(Handle<FixedArray> value);\n-\n-  // Get the elements of a compile time value returned by GetValue().\n-  static Handle<HeapObject> GetElements(Handle<FixedArray> value);\n-\n- private:\n-  static const int kLiteralTypeSlot = 0;\n-  static const int kElementsSlot = 1;\n-};\n-\n-}  // namespace internal\n-}  // namespace v8\n-\n-#endif  // V8_AST_COMPILE_TIME_VALUE_H_"
        },
        {
            "sha": "0f66ac91ecde74c6d658a1e4e605ef2a5ee97eeb",
            "filename": "deps/v8/src/ast/modules.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fmodules.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fmodules.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fmodules.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -6,12 +6,27 @@\n #include \"src/ast/ast-value-factory.h\"\n #include \"src/ast/scopes.h\"\n #include \"src/objects-inl.h\"\n-#include \"src/objects/module.h\"\n+#include \"src/objects/module-inl.h\"\n #include \"src/pending-compilation-error-handler.h\"\n \n namespace v8 {\n namespace internal {\n \n+bool ModuleDescriptor::AstRawStringComparer::operator()(\n+    const AstRawString* lhs, const AstRawString* rhs) const {\n+  // Fast path for equal pointers: a pointer is not strictly less than itself.\n+  if (lhs == rhs) return false;\n+\n+  // Order by contents (ordering by hash is unstable across runs).\n+  if (lhs->is_one_byte() != rhs->is_one_byte()) {\n+    return lhs->is_one_byte();\n+  }\n+  if (lhs->byte_length() != rhs->byte_length()) {\n+    return lhs->byte_length() < rhs->byte_length();\n+  }\n+  return memcmp(lhs->raw_data(), rhs->raw_data(), lhs->byte_length()) < 0;\n+}\n+\n void ModuleDescriptor::AddImport(const AstRawString* import_name,\n                                  const AstRawString* local_name,\n                                  const AstRawString* module_request,"
        },
        {
            "sha": "44e86dce42b4804e4c11872d36b89f2b595f7d3d",
            "filename": "deps/v8/src/ast/modules.h",
            "status": "modified",
            "additions": 19,
            "deletions": 12,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fmodules.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fmodules.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fmodules.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -124,20 +124,29 @@ class ModuleDescriptor : public ZoneObject {\n     ModuleRequest(int index, int position) : index(index), position(position) {}\n   };\n \n+  // Custom content-based comparer for the below maps, to keep them stable\n+  // across parses.\n+  struct AstRawStringComparer {\n+    bool operator()(const AstRawString* lhs, const AstRawString* rhs) const;\n+  };\n+\n+  typedef ZoneMap<const AstRawString*, ModuleRequest, AstRawStringComparer>\n+      ModuleRequestMap;\n+  typedef ZoneMultimap<const AstRawString*, Entry*, AstRawStringComparer>\n+      RegularExportMap;\n+  typedef ZoneMap<const AstRawString*, Entry*, AstRawStringComparer>\n+      RegularImportMap;\n+\n   // Module requests.\n-  const ZoneMap<const AstRawString*, ModuleRequest>& module_requests() const {\n-    return module_requests_;\n-  }\n+  const ModuleRequestMap& module_requests() const { return module_requests_; }\n \n   // Namespace imports.\n   const ZoneVector<const Entry*>& namespace_imports() const {\n     return namespace_imports_;\n   }\n \n   // All the remaining imports, indexed by local name.\n-  const ZoneMap<const AstRawString*, Entry*>& regular_imports() const {\n-    return regular_imports_;\n-  }\n+  const RegularImportMap& regular_imports() const { return regular_imports_; }\n \n   // Star exports and explicitly indirect exports.\n   const ZoneVector<const Entry*>& special_exports() const {\n@@ -146,9 +155,7 @@ class ModuleDescriptor : public ZoneObject {\n \n   // All the remaining exports, indexed by local name.\n   // After canonicalization (see Validate), these are exactly the local exports.\n-  const ZoneMultimap<const AstRawString*, Entry*>& regular_exports() const {\n-    return regular_exports_;\n-  }\n+  const RegularExportMap& regular_exports() const { return regular_exports_; }\n \n   void AddRegularExport(Entry* entry) {\n     DCHECK_NOT_NULL(entry->export_name);\n@@ -188,11 +195,11 @@ class ModuleDescriptor : public ZoneObject {\n                                  Handle<ModuleInfo> module_info);\n \n  private:\n-  ZoneMap<const AstRawString*, ModuleRequest> module_requests_;\n+  ModuleRequestMap module_requests_;\n   ZoneVector<const Entry*> special_exports_;\n   ZoneVector<const Entry*> namespace_imports_;\n-  ZoneMultimap<const AstRawString*, Entry*> regular_exports_;\n-  ZoneMap<const AstRawString*, Entry*> regular_imports_;\n+  RegularExportMap regular_exports_;\n+  RegularImportMap regular_imports_;\n \n   // If there are multiple export entries with the same export name, return the\n   // last of them (in source order).  Otherwise return nullptr."
        },
        {
            "sha": "ef086bcefc2d557a470ece82fabc62ee67a1690f",
            "filename": "deps/v8/src/ast/prettyprinter.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 13,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -498,16 +498,14 @@ void CallPrinter::VisitRewritableExpression(RewritableExpression* node) {\n   Find(node->expression());\n }\n \n-\n-void CallPrinter::FindStatements(ZoneList<Statement*>* statements) {\n+void CallPrinter::FindStatements(ZonePtrList<Statement>* statements) {\n   if (statements == nullptr) return;\n   for (int i = 0; i < statements->length(); i++) {\n     Find(statements->at(i));\n   }\n }\n \n-\n-void CallPrinter::FindArguments(ZoneList<Expression*>* arguments) {\n+void CallPrinter::FindArguments(ZonePtrList<Expression>* arguments) {\n   if (found_) return;\n   for (int i = 0; i < arguments->length(); i++) {\n     Find(arguments->at(i));\n@@ -589,7 +587,7 @@ void AstPrinter::Print(const char* format, ...) {\n   }\n }\n \n-void AstPrinter::PrintLabels(ZoneList<const AstRawString*>* labels) {\n+void AstPrinter::PrintLabels(ZonePtrList<const AstRawString>* labels) {\n   if (labels != nullptr) {\n     for (int i = 0; i < labels->length(); i++) {\n       PrintLiteral(labels->at(i), false);\n@@ -748,8 +746,7 @@ void AstPrinter::PrintLiteralWithModeIndented(const char* info, Variable* var,\n   }\n }\n \n-\n-void AstPrinter::PrintLabelsIndented(ZoneList<const AstRawString*>* labels) {\n+void AstPrinter::PrintLabelsIndented(ZonePtrList<const AstRawString>* labels) {\n   if (labels == nullptr || labels->length() == 0) return;\n   PrintIndented(\"LABELS \");\n   PrintLabels(labels);\n@@ -809,15 +806,13 @@ void AstPrinter::PrintParameters(DeclarationScope* scope) {\n   }\n }\n \n-\n-void AstPrinter::PrintStatements(ZoneList<Statement*>* statements) {\n+void AstPrinter::PrintStatements(ZonePtrList<Statement>* statements) {\n   for (int i = 0; i < statements->length(); i++) {\n     Visit(statements->at(i));\n   }\n }\n \n-\n-void AstPrinter::PrintArguments(ZoneList<Expression*>* arguments) {\n+void AstPrinter::PrintArguments(ZonePtrList<Expression>* arguments) {\n   for (int i = 0; i < arguments->length(); i++) {\n     Visit(arguments->at(i));\n   }\n@@ -1040,7 +1035,7 @@ void AstPrinter::VisitInitializeClassFieldsStatement(\n }\n \n void AstPrinter::PrintClassProperties(\n-    ZoneList<ClassLiteral::Property*>* properties) {\n+    ZonePtrList<ClassLiteral::Property>* properties) {\n   for (int i = 0; i < properties->length(); i++) {\n     ClassLiteral::Property* property = properties->at(i);\n     const char* prop_kind = nullptr;\n@@ -1119,7 +1114,7 @@ void AstPrinter::VisitObjectLiteral(ObjectLiteral* node) {\n }\n \n void AstPrinter::PrintObjectProperties(\n-    ZoneList<ObjectLiteral::Property*>* properties) {\n+    ZonePtrList<ObjectLiteral::Property>* properties) {\n   for (int i = 0; i < properties->length(); i++) {\n     ObjectLiteral::Property* property = properties->at(i);\n     const char* prop_kind = nullptr;"
        },
        {
            "sha": "cc29052c2d9783dcbb621b83362d28df5fd82fa4",
            "filename": "deps/v8/src/ast/prettyprinter.h",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fprettyprinter.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -56,8 +56,8 @@ class CallPrinter final : public AstVisitor<CallPrinter> {\n  protected:\n   void PrintLiteral(Handle<Object> value, bool quote);\n   void PrintLiteral(const AstRawString* value, bool quote);\n-  void FindStatements(ZoneList<Statement*>* statements);\n-  void FindArguments(ZoneList<Expression*>* arguments);\n+  void FindStatements(ZonePtrList<Statement>* statements);\n+  void FindArguments(ZonePtrList<Expression>* arguments);\n };\n \n \n@@ -88,17 +88,17 @@ class AstPrinter final : public AstVisitor<AstPrinter> {\n \n   void Init();\n \n-  void PrintLabels(ZoneList<const AstRawString*>* labels);\n+  void PrintLabels(ZonePtrList<const AstRawString>* labels);\n   void PrintLiteral(const AstRawString* value, bool quote);\n   void PrintLiteral(const AstConsString* value, bool quote);\n   void PrintLiteral(Literal* literal, bool quote);\n   void PrintIndented(const char* txt);\n   void PrintIndentedVisit(const char* s, AstNode* node);\n \n-  void PrintStatements(ZoneList<Statement*>* statements);\n+  void PrintStatements(ZonePtrList<Statement>* statements);\n   void PrintDeclarations(Declaration::List* declarations);\n   void PrintParameters(DeclarationScope* scope);\n-  void PrintArguments(ZoneList<Expression*>* arguments);\n+  void PrintArguments(ZonePtrList<Expression>* arguments);\n   void PrintCaseClause(CaseClause* clause);\n   void PrintLiteralIndented(const char* info, Literal* literal, bool quote);\n   void PrintLiteralIndented(const char* info, const AstRawString* value,\n@@ -107,9 +107,9 @@ class AstPrinter final : public AstVisitor<AstPrinter> {\n                             bool quote);\n   void PrintLiteralWithModeIndented(const char* info, Variable* var,\n                                     const AstRawString* value);\n-  void PrintLabelsIndented(ZoneList<const AstRawString*>* labels);\n-  void PrintObjectProperties(ZoneList<ObjectLiteral::Property*>* properties);\n-  void PrintClassProperties(ZoneList<ClassLiteral::Property*>* properties);\n+  void PrintLabelsIndented(ZonePtrList<const AstRawString>* labels);\n+  void PrintObjectProperties(ZonePtrList<ObjectLiteral::Property>* properties);\n+  void PrintClassProperties(ZonePtrList<ClassLiteral::Property>* properties);\n \n   void inc_indent() { indent_++; }\n   void dec_indent() { indent_--; }"
        },
        {
            "sha": "18db88f950144571c7aa8621501aa2020f5fae62",
            "filename": "deps/v8/src/ast/scopes.cc",
            "status": "modified",
            "additions": 103,
            "deletions": 102,
            "changes": 205,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fscopes.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fscopes.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fscopes.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -13,10 +13,11 @@\n #include \"src/counters.h\"\n #include \"src/messages.h\"\n #include \"src/objects-inl.h\"\n-#include \"src/objects/module.h\"\n+#include \"src/objects/module-inl.h\"\n #include \"src/objects/scope-info.h\"\n #include \"src/parsing/parse-info.h\"\n #include \"src/parsing/preparsed-scope-data.h\"\n+#include \"src/zone/zone-list-inl.h\"\n \n namespace v8 {\n namespace internal {\n@@ -75,8 +76,8 @@ Variable* VariableMap::DeclareName(Zone* zone, const AstRawString* name,\n   if (p->value == nullptr) {\n     // The variable has not been declared yet -> insert it.\n     DCHECK_EQ(name, p->key);\n-    p->value =\n-        mode == VAR ? kDummyPreParserVariable : kDummyPreParserLexicalVariable;\n+    p->value = mode == VariableMode::kVar ? kDummyPreParserVariable\n+                                          : kDummyPreParserLexicalVariable;\n   }\n   return reinterpret_cast<Variable*>(p->value);\n }\n@@ -189,6 +190,13 @@ DeclarationScope::DeclarationScope(Zone* zone, Scope* outer_scope,\n   SetDefaults();\n }\n \n+bool DeclarationScope::IsDeclaredParameter(const AstRawString* name) {\n+  // If IsSimpleParameterList is false, duplicate parameters are not allowed,\n+  // however `arguments` may be allowed if function is not strict code. Thus,\n+  // the assumptions explained above do not hold.\n+  return params_.Contains(variables_.Lookup(name));\n+}\n+\n ModuleScope::ModuleScope(DeclarationScope* script_scope,\n                          AstValueFactory* ast_value_factory)\n     : DeclarationScope(ast_value_factory->zone(), script_scope, MODULE_SCOPE,\n@@ -199,11 +207,10 @@ ModuleScope::ModuleScope(DeclarationScope* script_scope,\n   DeclareThis(ast_value_factory);\n }\n \n-ModuleScope::ModuleScope(Handle<ScopeInfo> scope_info,\n+ModuleScope::ModuleScope(Isolate* isolate, Handle<ScopeInfo> scope_info,\n                          AstValueFactory* avfactory)\n     : DeclarationScope(avfactory->zone(), MODULE_SCOPE, scope_info) {\n   Zone* zone = avfactory->zone();\n-  Isolate* isolate = scope_info->GetIsolate();\n   Handle<ModuleInfo> module_info(scope_info->ModuleDescriptorInfo(), isolate);\n \n   set_language_mode(LanguageMode::kStrict);\n@@ -289,8 +296,9 @@ Scope::Scope(Zone* zone, const AstRawString* catch_variable_name,\n   // Cache the catch variable, even though it's also available via the\n   // scope_info, as the parser expects that a catch scope always has the catch\n   // variable as first and only variable.\n-  Variable* variable = Declare(zone, catch_variable_name, VAR, NORMAL_VARIABLE,\n-                               kCreatedInitialized, maybe_assigned);\n+  Variable* variable =\n+      Declare(zone, catch_variable_name, VariableMode::kVar, NORMAL_VARIABLE,\n+              kCreatedInitialized, maybe_assigned);\n   AllocateHeapSlot(variable);\n }\n \n@@ -389,7 +397,8 @@ bool Scope::ContainsAsmModule() const {\n   return false;\n }\n \n-Scope* Scope::DeserializeScopeChain(Zone* zone, ScopeInfo* scope_info,\n+Scope* Scope::DeserializeScopeChain(Isolate* isolate, Zone* zone,\n+                                    ScopeInfo* scope_info,\n                                     DeclarationScope* script_scope,\n                                     AstValueFactory* ast_value_factory,\n                                     DeserializationMode deserialization_mode) {\n@@ -400,7 +409,8 @@ Scope* Scope::DeserializeScopeChain(Zone* zone, ScopeInfo* scope_info,\n   while (scope_info) {\n     if (scope_info->scope_type() == WITH_SCOPE) {\n       // For scope analysis, debug-evaluate is equivalent to a with scope.\n-      outer_scope = new (zone) Scope(zone, WITH_SCOPE, handle(scope_info));\n+      outer_scope =\n+          new (zone) Scope(zone, WITH_SCOPE, handle(scope_info, isolate));\n \n       // TODO(yangguo): Remove once debug-evaluate properly keeps track of the\n       // function scope in which we are evaluating.\n@@ -412,40 +422,40 @@ Scope* Scope::DeserializeScopeChain(Zone* zone, ScopeInfo* scope_info,\n       // scope info of this script context onto the existing script scope to\n       // avoid nesting script scopes.\n       if (deserialization_mode == DeserializationMode::kIncludingVariables) {\n-        script_scope->SetScriptScopeInfo(handle(scope_info));\n+        script_scope->SetScriptScopeInfo(handle(scope_info, isolate));\n       }\n       DCHECK(!scope_info->HasOuterScopeInfo());\n       break;\n     } else if (scope_info->scope_type() == FUNCTION_SCOPE) {\n-      outer_scope =\n-          new (zone) DeclarationScope(zone, FUNCTION_SCOPE, handle(scope_info));\n+      outer_scope = new (zone)\n+          DeclarationScope(zone, FUNCTION_SCOPE, handle(scope_info, isolate));\n       if (scope_info->IsAsmModule())\n         outer_scope->AsDeclarationScope()->set_asm_module();\n     } else if (scope_info->scope_type() == EVAL_SCOPE) {\n-      outer_scope =\n-          new (zone) DeclarationScope(zone, EVAL_SCOPE, handle(scope_info));\n+      outer_scope = new (zone)\n+          DeclarationScope(zone, EVAL_SCOPE, handle(scope_info, isolate));\n     } else if (scope_info->scope_type() == BLOCK_SCOPE) {\n       if (scope_info->is_declaration_scope()) {\n-        outer_scope =\n-            new (zone) DeclarationScope(zone, BLOCK_SCOPE, handle(scope_info));\n+        outer_scope = new (zone)\n+            DeclarationScope(zone, BLOCK_SCOPE, handle(scope_info, isolate));\n       } else {\n-        outer_scope = new (zone) Scope(zone, BLOCK_SCOPE, handle(scope_info));\n+        outer_scope =\n+            new (zone) Scope(zone, BLOCK_SCOPE, handle(scope_info, isolate));\n       }\n     } else if (scope_info->scope_type() == MODULE_SCOPE) {\n-      outer_scope =\n-          new (zone) ModuleScope(handle(scope_info), ast_value_factory);\n+      outer_scope = new (zone)\n+          ModuleScope(isolate, handle(scope_info, isolate), ast_value_factory);\n     } else {\n       DCHECK_EQ(scope_info->scope_type(), CATCH_SCOPE);\n-      DCHECK_EQ(scope_info->LocalCount(), 1);\n       DCHECK_EQ(scope_info->ContextLocalCount(), 1);\n-      DCHECK_EQ(scope_info->ContextLocalMode(0), VAR);\n+      DCHECK_EQ(scope_info->ContextLocalMode(0), VariableMode::kVar);\n       DCHECK_EQ(scope_info->ContextLocalInitFlag(0), kCreatedInitialized);\n       String* name = scope_info->ContextLocalName(0);\n       MaybeAssignedFlag maybe_assigned =\n           scope_info->ContextLocalMaybeAssignedFlag(0);\n-      outer_scope =\n-          new (zone) Scope(zone, ast_value_factory->GetString(handle(name)),\n-                           maybe_assigned, handle(scope_info));\n+      outer_scope = new (zone)\n+          Scope(zone, ast_value_factory->GetString(handle(name, isolate)),\n+                maybe_assigned, handle(scope_info, isolate));\n     }\n     if (deserialization_mode == DeserializationMode::kScopesOnly) {\n       outer_scope->scope_info_ = Handle<ScopeInfo>::null();\n@@ -605,12 +615,13 @@ void DeclarationScope::HoistSloppyBlockFunctions(AstNodeFactory* factory) {\n       // Based on the preceding checks, it doesn't matter what we pass as\n       // sloppy_mode_block_scope_function_redefinition.\n       bool ok = true;\n-      DeclareVariable(declaration, VAR,\n-                      Variable::DefaultInitializationFlag(VAR), nullptr, &ok);\n+      DeclareVariable(declaration, VariableMode::kVar,\n+                      Variable::DefaultInitializationFlag(VariableMode::kVar),\n+                      nullptr, &ok);\n       DCHECK(ok);\n     } else {\n       DCHECK(is_being_lazily_parsed_);\n-      Variable* var = DeclareVariableName(name, VAR);\n+      Variable* var = DeclareVariableName(name, VariableMode::kVar);\n       if (var != kDummyPreParserVariable &&\n           var != kDummyPreParserLexicalVariable) {\n         DCHECK(FLAG_preparser_scope_analysis);\n@@ -633,7 +644,7 @@ void DeclarationScope::AttachOuterScopeInfo(ParseInfo* info, Isolate* isolate) {\n           DeclarationScope(info->zone(), info->ast_value_factory());\n       info->set_script_scope(script_scope);\n       ReplaceOuterScope(Scope::DeserializeScopeChain(\n-          info->zone(), *outer_scope_info, script_scope,\n+          isolate, info->zone(), *outer_scope_info, script_scope,\n           info->ast_value_factory(),\n           Scope::DeserializationMode::kIncludingVariables));\n     } else {\n@@ -703,7 +714,8 @@ void DeclarationScope::DeclareThis(AstValueFactory* ast_value_factory) {\n   bool derived_constructor = IsDerivedConstructor(function_kind_);\n   Variable* var =\n       Declare(zone(), ast_value_factory->this_string(),\n-              derived_constructor ? CONST : VAR, THIS_VARIABLE,\n+              derived_constructor ? VariableMode::kConst : VariableMode::kVar,\n+              THIS_VARIABLE,\n               derived_constructor ? kNeedsInitialization : kCreatedInitialized);\n   receiver_ = var;\n }\n@@ -717,7 +729,8 @@ void DeclarationScope::DeclareArguments(AstValueFactory* ast_value_factory) {\n     // Declare 'arguments' variable which exists in all non arrow functions.\n     // Note that it might never be accessed, in which case it won't be\n     // allocated during variable allocation.\n-    arguments_ = Declare(zone(), ast_value_factory->arguments_string(), VAR);\n+    arguments_ = Declare(zone(), ast_value_factory->arguments_string(),\n+                         VariableMode::kVar);\n   } else if (IsLexical(arguments_)) {\n     // Check if there's lexically declared variable named arguments to avoid\n     // redeclaration. See ES#sec-functiondeclarationinstantiation, step 20.\n@@ -731,12 +744,14 @@ void DeclarationScope::DeclareDefaultFunctionVariables(\n   DCHECK(!is_arrow_scope());\n \n   DeclareThis(ast_value_factory);\n-  new_target_ = Declare(zone(), ast_value_factory->new_target_string(), CONST);\n+  new_target_ = Declare(zone(), ast_value_factory->new_target_string(),\n+                        VariableMode::kConst);\n \n   if (IsConciseMethod(function_kind_) || IsClassConstructor(function_kind_) ||\n       IsAccessorFunction(function_kind_)) {\n     EnsureRareData()->this_function =\n-        Declare(zone(), ast_value_factory->this_function_string(), CONST);\n+        Declare(zone(), ast_value_factory->this_function_string(),\n+                VariableMode::kConst);\n   }\n }\n \n@@ -746,10 +761,10 @@ Variable* DeclarationScope::DeclareFunctionVar(const AstRawString* name) {\n   DCHECK_NULL(variables_.Lookup(name));\n   VariableKind kind = is_sloppy(language_mode()) ? SLOPPY_FUNCTION_NAME_VARIABLE\n                                                  : NORMAL_VARIABLE;\n-  function_ =\n-      new (zone()) Variable(this, name, CONST, kind, kCreatedInitialized);\n+  function_ = new (zone())\n+      Variable(this, name, VariableMode::kConst, kind, kCreatedInitialized);\n   if (calls_sloppy_eval()) {\n-    NonLocal(name, DYNAMIC);\n+    NonLocal(name, VariableMode::kDynamic);\n   } else {\n     variables_.Add(zone(), function_);\n   }\n@@ -913,11 +928,12 @@ void Scope::Snapshot::Reparent(DeclarationScope* new_parent) const {\n \n   new_parent->locals_.MoveTail(outer_closure->locals(), top_local_);\n   for (Variable* local : new_parent->locals_) {\n-    DCHECK(local->mode() == TEMPORARY || local->mode() == VAR);\n+    DCHECK(local->mode() == VariableMode::kTemporary ||\n+           local->mode() == VariableMode::kVar);\n     DCHECK_EQ(local->scope(), local->scope()->GetClosureScope());\n     DCHECK_NE(local->scope(), new_parent);\n     local->set_scope(new_parent);\n-    if (local->mode() == VAR) {\n+    if (local->mode() == VariableMode::kVar) {\n       outer_closure->variables_.Remove(local);\n       new_parent->variables_.Add(new_parent->zone(), local);\n     }\n@@ -949,10 +965,6 @@ Variable* Scope::LookupInScopeInfo(const AstRawString* name) {\n   // The Scope is backed up by ScopeInfo. This means it cannot operate in a\n   // heap-independent mode, and all strings must be internalized immediately. So\n   // it's ok to get the Handle<String> here.\n-  // If we have a serialized scope info, we might find the variable there.\n-  // There should be no local slot with the given name.\n-  DCHECK_LT(scope_info_->StackSlotIndex(*name_handle), 0);\n-\n   bool found = false;\n \n   VariableLocation location;\n@@ -979,7 +991,7 @@ Variable* Scope::LookupInScopeInfo(const AstRawString* name) {\n     index = scope_info_->FunctionContextSlotIndex(*name_handle);\n     if (index < 0) return nullptr;  // Nowhere found.\n     Variable* var = AsDeclarationScope()->DeclareFunctionVar(name);\n-    DCHECK_EQ(CONST, var->mode());\n+    DCHECK_EQ(VariableMode::kConst, var->mode());\n     var->AllocateTo(VariableLocation::CONTEXT, index);\n     return variables_.Lookup(name);\n   }\n@@ -1016,10 +1028,10 @@ Variable* DeclarationScope::DeclareParameter(\n   DCHECK(!is_being_lazily_parsed_);\n   DCHECK(!was_lazily_parsed_);\n   Variable* var;\n-  if (mode == TEMPORARY) {\n+  if (mode == VariableMode::kTemporary) {\n     var = NewTemporary(name);\n   } else {\n-    DCHECK_EQ(mode, VAR);\n+    DCHECK_EQ(mode, VariableMode::kVar);\n     var = Declare(zone(), name, mode);\n     // TODO(wingo): Avoid O(n^2) check.\n     if (is_duplicate != nullptr) {\n@@ -1049,30 +1061,32 @@ Variable* DeclarationScope::DeclareParameterName(\n   if (FLAG_preparser_scope_analysis) {\n     Variable* var;\n     if (declare_as_local) {\n-      var = Declare(zone(), name, VAR);\n+      var = Declare(zone(), name, VariableMode::kVar);\n     } else {\n-      var = new (zone())\n-          Variable(this, name, TEMPORARY, NORMAL_VARIABLE, kCreatedInitialized);\n+      var = new (zone()) Variable(this, name, VariableMode::kTemporary,\n+                                  NORMAL_VARIABLE, kCreatedInitialized);\n     }\n     if (add_parameter) {\n       params_.Add(var, zone());\n     }\n     return var;\n   }\n-  DeclareVariableName(name, VAR);\n+  DeclareVariableName(name, VariableMode::kVar);\n   return nullptr;\n }\n \n Variable* Scope::DeclareLocal(const AstRawString* name, VariableMode mode,\n                               InitializationFlag init_flag, VariableKind kind,\n                               MaybeAssignedFlag maybe_assigned_flag) {\n   DCHECK(!already_resolved_);\n-  // This function handles VAR, LET, and CONST modes.  DYNAMIC variables are\n-  // introduced during variable allocation, and TEMPORARY variables are\n-  // allocated via NewTemporary().\n+  // This function handles VariableMode::kVar, VariableMode::kLet, and\n+  // VariableMode::kConst modes.  VariableMode::kDynamic variables are\n+  // introduced during variable allocation, and VariableMode::kTemporary\n+  // variables are allocated via NewTemporary().\n   DCHECK(IsDeclaredVariableMode(mode));\n   DCHECK_IMPLIES(GetDeclarationScope()->is_being_lazily_parsed(),\n-                 mode == VAR || mode == LET || mode == CONST);\n+                 mode == VariableMode::kVar || mode == VariableMode::kLet ||\n+                     mode == VariableMode::kConst);\n   DCHECK(!GetDeclarationScope()->was_lazily_parsed());\n   return Declare(zone(), name, mode, kind, init_flag, maybe_assigned_flag);\n }\n@@ -1085,7 +1099,7 @@ Variable* Scope::DeclareVariable(\n   DCHECK(!GetDeclarationScope()->is_being_lazily_parsed());\n   DCHECK(!GetDeclarationScope()->was_lazily_parsed());\n \n-  if (mode == VAR && !is_declaration_scope()) {\n+  if (mode == VariableMode::kVar && !is_declaration_scope()) {\n     return GetDeclarationScope()->DeclareVariable(\n         declaration, mode, init, sloppy_mode_block_scope_function_redefinition,\n         ok);\n@@ -1108,11 +1122,12 @@ Variable* Scope::DeclareVariable(\n   // assigned because they might be accessed by a lazily parsed top-level\n   // function, which, for efficiency, we preparse without variable tracking.\n   if (is_script_scope() || is_module_scope()) {\n-    if (mode != CONST) proxy->set_is_assigned();\n+    if (mode != VariableMode::kConst) proxy->set_is_assigned();\n   }\n \n   Variable* var = nullptr;\n-  if (is_eval_scope() && is_sloppy(language_mode()) && mode == VAR) {\n+  if (is_eval_scope() && is_sloppy(language_mode()) &&\n+      mode == VariableMode::kVar) {\n     // In a var binding in a sloppy direct eval, pollute the enclosing scope\n     // with this new binding by doing the following:\n     // The proxy is bound to a lookup variable to force a dynamic declaration\n@@ -1173,7 +1188,7 @@ Variable* Scope::DeclareVariable(\n         *ok = false;\n         return nullptr;\n       }\n-    } else if (mode == VAR) {\n+    } else if (mode == VariableMode::kVar) {\n       var->set_maybe_assigned();\n     }\n   }\n@@ -1199,7 +1214,7 @@ Variable* Scope::DeclareVariableName(const AstRawString* name,\n   DCHECK(!already_resolved_);\n   DCHECK(GetDeclarationScope()->is_being_lazily_parsed());\n \n-  if (mode == VAR && !is_declaration_scope()) {\n+  if (mode == VariableMode::kVar && !is_declaration_scope()) {\n     return GetDeclarationScope()->DeclareVariableName(name, mode);\n   }\n   DCHECK(!is_with_scope());\n@@ -1220,7 +1235,7 @@ Variable* Scope::DeclareVariableName(const AstRawString* name,\n       // a function declaration, it's an error. This is an error PreParser\n       // hasn't previously detected. TODO(marja): Investigate whether we can now\n       // start returning this error.\n-    } else if (mode == VAR) {\n+    } else if (mode == VariableMode::kVar) {\n       var->set_maybe_assigned();\n     }\n     var->set_is_used();\n@@ -1237,9 +1252,9 @@ void Scope::DeclareCatchVariableName(const AstRawString* name) {\n   DCHECK(scope_info_.is_null());\n \n   if (FLAG_preparser_scope_analysis) {\n-    Declare(zone(), name, VAR);\n+    Declare(zone(), name, VariableMode::kVar);\n   } else {\n-    variables_.DeclareName(zone(), name, VAR);\n+    variables_.DeclareName(zone(), name, VariableMode::kVar);\n   }\n }\n \n@@ -1253,11 +1268,11 @@ void Scope::AddUnresolved(VariableProxy* proxy) {\n Variable* DeclarationScope::DeclareDynamicGlobal(const AstRawString* name,\n                                                  VariableKind kind) {\n   DCHECK(is_script_scope());\n-  return variables_.Declare(zone(), this, name, DYNAMIC_GLOBAL, kind);\n+  return variables_.Declare(zone(), this, name, VariableMode::kDynamicGlobal,\n+                            kind);\n   // TODO(neis): Mark variable as maybe-assigned?\n }\n \n-\n bool Scope::RemoveUnresolved(VariableProxy* var) {\n   if (unresolved_ == var) {\n     unresolved_ = var->next_unresolved();\n@@ -1284,8 +1299,8 @@ Variable* Scope::NewTemporary(const AstRawString* name) {\n Variable* Scope::NewTemporary(const AstRawString* name,\n                               MaybeAssignedFlag maybe_assigned) {\n   DeclarationScope* scope = GetClosureScope();\n-  Variable* var = new (zone())\n-      Variable(scope, name, TEMPORARY, NORMAL_VARIABLE, kCreatedInitialized);\n+  Variable* var = new (zone()) Variable(scope, name, VariableMode::kTemporary,\n+                                        NORMAL_VARIABLE, kCreatedInitialized);\n   scope->AddLocal(var);\n   if (maybe_assigned == kMaybeAssigned) var->set_maybe_assigned();\n   return var;\n@@ -1302,7 +1317,7 @@ Declaration* Scope::CheckConflictingVarDeclarations() {\n     Scope* current = this;\n     if (decl->IsVariableDeclaration() &&\n         decl->AsVariableDeclaration()->AsNested() != nullptr) {\n-      DCHECK_EQ(mode, VAR);\n+      DCHECK_EQ(mode, VariableMode::kVar);\n       current = decl->AsVariableDeclaration()->AsNested()->scope();\n     } else if (IsLexicalVariableMode(mode)) {\n       if (!is_block_scope()) continue;\n@@ -1327,7 +1342,7 @@ Declaration* Scope::CheckConflictingVarDeclarations() {\n }\n \n Declaration* Scope::CheckLexDeclarationsConflictingWith(\n-    const ZoneList<const AstRawString*>& names) {\n+    const ZonePtrList<const AstRawString>& names) {\n   DCHECK(is_block_scope());\n   for (int i = 0; i < names.length(); ++i) {\n     Variable* var = LookupLocal(names.at(i));\n@@ -1467,11 +1482,11 @@ Scope* Scope::GetOuterScopeWithContext() {\n }\n \n Handle<StringSet> DeclarationScope::CollectNonLocals(\n-    ParseInfo* info, Handle<StringSet> non_locals) {\n+    Isolate* isolate, ParseInfo* info, Handle<StringSet> non_locals) {\n   VariableProxy* free_variables = FetchFreeVariables(this, info);\n   for (VariableProxy* proxy = free_variables; proxy != nullptr;\n        proxy = proxy->next_unresolved()) {\n-    non_locals = StringSet::Add(non_locals, proxy->name());\n+    non_locals = StringSet::Add(isolate, non_locals, proxy->name());\n   }\n   return non_locals;\n }\n@@ -1759,7 +1774,7 @@ void Scope::Print(int n) {\n   {\n     bool printed_header = false;\n     for (Variable* local : locals_) {\n-      if (local->mode() != TEMPORARY) continue;\n+      if (local->mode() != VariableMode::kTemporary) continue;\n       if (!printed_header) {\n         printed_header = true;\n         Indent(n1, \"// temporary vars:\\n\");\n@@ -1829,7 +1844,8 @@ Variable* Scope::LookupRecursive(ParseInfo* info, VariableProxy* proxy,\n   // variables.\n   // TODO(yangguo): Remove once debug-evaluate creates proper ScopeInfo for the\n   // scopes in which it's evaluating.\n-  if (is_debug_evaluate_scope_) return NonLocal(proxy->raw_name(), DYNAMIC);\n+  if (is_debug_evaluate_scope_)\n+    return NonLocal(proxy->raw_name(), VariableMode::kDynamic);\n \n   // Try to find the variable in this scope.\n   Variable* var = LookupLocal(proxy->raw_name());\n@@ -1892,7 +1908,7 @@ Variable* Scope::LookupRecursive(ParseInfo* info, VariableProxy* proxy,\n       var->ForceContextAllocation();\n       if (proxy->is_assigned()) var->set_maybe_assigned();\n     }\n-    return NonLocal(proxy->raw_name(), DYNAMIC);\n+    return NonLocal(proxy->raw_name(), VariableMode::kDynamic);\n   }\n \n   if (is_declaration_scope() && AsDeclarationScope()->calls_sloppy_eval()) {\n@@ -1904,13 +1920,13 @@ Variable* Scope::LookupRecursive(ParseInfo* info, VariableProxy* proxy,\n     // here (this excludes block and catch scopes), and variable lookups at\n     // script scope are always dynamic.\n     if (var->IsGlobalObjectProperty()) {\n-      return NonLocal(proxy->raw_name(), DYNAMIC_GLOBAL);\n+      return NonLocal(proxy->raw_name(), VariableMode::kDynamicGlobal);\n     }\n \n     if (var->is_dynamic()) return var;\n \n     Variable* invalidated = var;\n-    var = NonLocal(proxy->raw_name(), DYNAMIC_LOCAL);\n+    var = NonLocal(proxy->raw_name(), VariableMode::kDynamicLocal);\n     var->set_local_if_not_shadowed(invalidated);\n   }\n \n@@ -1937,11 +1953,11 @@ void SetNeedsHoleCheck(Variable* var, VariableProxy* proxy) {\n }\n \n void UpdateNeedsHoleCheck(Variable* var, VariableProxy* proxy, Scope* scope) {\n-  if (var->mode() == DYNAMIC_LOCAL) {\n+  if (var->mode() == VariableMode::kDynamicLocal) {\n     // Dynamically introduced variables never need a hole check (since they're\n-    // VAR bindings, either from var or function declarations), but the variable\n-    // they shadow might need a hole check, which we want to do if we decide\n-    // that no shadowing variable was dynamically introoduced.\n+    // VariableMode::kVar bindings, either from var or function declarations),\n+    // but the variable they shadow might need a hole check, which we want to do\n+    // if we decide that no shadowing variable was dynamically introoduced.\n     DCHECK_EQ(kCreatedInitialized, var->initialization_flag());\n     return UpdateNeedsHoleCheck(var->local_if_not_shadowed(), proxy, scope);\n   }\n@@ -1956,12 +1972,12 @@ void UpdateNeedsHoleCheck(Variable* var, VariableProxy* proxy, Scope* scope) {\n   }\n \n   // Check if the binding really needs an initialization check. The check\n-  // can be skipped in the following situation: we have a LET or CONST\n-  // binding, both the Variable and the VariableProxy have the same\n-  // declaration scope (i.e. they are both in global code, in the\n-  // same function or in the same eval code), the VariableProxy is in\n-  // the source physically located after the initializer of the variable,\n-  // and that the initializer cannot be skipped due to a nonlinear scope.\n+  // can be skipped in the following situation: we have a VariableMode::kLet or\n+  // VariableMode::kConst binding, both the Variable and the VariableProxy have\n+  // the same declaration scope (i.e. they are both in global code, in the same\n+  // function or in the same eval code), the VariableProxy is in the source\n+  // physically located after the initializer of the variable, and that the\n+  // initializer cannot be skipped due to a nonlinear scope.\n   //\n   // The condition on the closure scopes is a conservative check for\n   // nested functions that access a binding and are called before the\n@@ -2136,7 +2152,7 @@ bool Scope::MustAllocateInContext(Variable* var) {\n   //\n   // Temporary variables are always stack-allocated.  Catch-bound variables are\n   // always context-allocated.\n-  if (var->mode() == TEMPORARY) return false;\n+  if (var->mode() == VariableMode::kTemporary) return false;\n   if (is_catch_scope()) return true;\n   if ((is_script_scope() || is_eval_scope()) &&\n       IsLexicalVariableMode(var->mode())) {\n@@ -2356,21 +2372,8 @@ void Scope::AllocateScopeInfosRecursively(Isolate* isolate,\n   }\n }\n \n-void Scope::AllocateDebuggerScopeInfos(Isolate* isolate,\n-                                       MaybeHandle<ScopeInfo> outer_scope) {\n-  if (scope_info_.is_null()) {\n-    scope_info_ = ScopeInfo::Create(isolate, zone(), this, outer_scope);\n-  }\n-  MaybeHandle<ScopeInfo> outer = NeedsContext() ? scope_info_ : outer_scope;\n-  for (Scope* scope = inner_scope_; scope != nullptr; scope = scope->sibling_) {\n-    if (scope->is_function_scope()) continue;\n-    scope->AllocateDebuggerScopeInfos(isolate, outer);\n-  }\n-}\n-\n // static\n-void DeclarationScope::AllocateScopeInfos(ParseInfo* info, Isolate* isolate,\n-                                          AnalyzeMode mode) {\n+void DeclarationScope::AllocateScopeInfos(ParseInfo* info, Isolate* isolate) {\n   DeclarationScope* scope = info->literal()->scope();\n   if (!scope->scope_info_.is_null()) return;  // Allocated by outer function.\n \n@@ -2380,9 +2383,6 @@ void DeclarationScope::AllocateScopeInfos(ParseInfo* info, Isolate* isolate,\n   }\n \n   scope->AllocateScopeInfosRecursively(isolate, outer_scope);\n-  if (mode == AnalyzeMode::kDebugger) {\n-    scope->AllocateDebuggerScopeInfos(isolate, outer_scope);\n-  }\n \n   // The debugger expects all shared function infos to contain a scope info.\n   // Since the top-most scope will end up in a shared function info, make sure\n@@ -2396,7 +2396,8 @@ void DeclarationScope::AllocateScopeInfos(ParseInfo* info, Isolate* isolate,\n   // Ensuring that the outer script scope has a scope info avoids having\n   // special case for native contexts vs other contexts.\n   if (info->script_scope() && info->script_scope()->scope_info_.is_null()) {\n-    info->script_scope()->scope_info_ = handle(ScopeInfo::Empty(isolate));\n+    info->script_scope()->scope_info_ =\n+        handle(ScopeInfo::Empty(isolate), isolate);\n   }\n }\n "
        },
        {
            "sha": "5618adee9ebce443372415ee8bd4b0f8d985d67e",
            "filename": "deps/v8/src/ast/scopes.h",
            "status": "modified",
            "additions": 12,
            "deletions": 17,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fscopes.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fscopes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fscopes.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -78,8 +78,6 @@ class SloppyBlockFunctionMap : public ZoneHashMap {\n   int count_;\n };\n \n-enum class AnalyzeMode { kRegular, kDebugger };\n-\n // Global invariants after AST construction: Each reference (i.e. identifier)\n // to a JavaScript variable (including global properties) is represented by a\n // VariableProxy node. Immediately after AST construction and before variable\n@@ -134,7 +132,8 @@ class V8_EXPORT_PRIVATE Scope : public NON_EXPORTED_BASE(ZoneObject) {\n \n   enum class DeserializationMode { kIncludingVariables, kScopesOnly };\n \n-  static Scope* DeserializeScopeChain(Zone* zone, ScopeInfo* scope_info,\n+  static Scope* DeserializeScopeChain(Isolate* isolate, Zone* zone,\n+                                      ScopeInfo* scope_info,\n                                       DeclarationScope* script_scope,\n                                       AstValueFactory* ast_value_factory,\n                                       DeserializationMode deserialization_mode);\n@@ -256,7 +255,7 @@ class V8_EXPORT_PRIVATE Scope : public NON_EXPORTED_BASE(ZoneObject) {\n   // which is an error even though the two 'e's are declared in different\n   // scopes.\n   Declaration* CheckLexDeclarationsConflictingWith(\n-      const ZoneList<const AstRawString*>& names);\n+      const ZonePtrList<const AstRawString>& names);\n \n   // ---------------------------------------------------------------------------\n   // Scope-specific info.\n@@ -366,7 +365,8 @@ class V8_EXPORT_PRIVATE Scope : public NON_EXPORTED_BASE(ZoneObject) {\n   // Whether this needs to be represented by a runtime context.\n   bool NeedsContext() const {\n     // Catch scopes always have heap slots.\n-    DCHECK(!is_catch_scope() || num_heap_slots() > 0);\n+    DCHECK_IMPLIES(is_catch_scope(), num_heap_slots() > 0);\n+    DCHECK_IMPLIES(is_with_scope(), num_heap_slots() > 0);\n     return num_heap_slots() > 0;\n   }\n \n@@ -646,12 +646,7 @@ class V8_EXPORT_PRIVATE DeclarationScope : public Scope {\n   // Creates a script scope.\n   DeclarationScope(Zone* zone, AstValueFactory* ast_value_factory);\n \n-  bool IsDeclaredParameter(const AstRawString* name) {\n-    // If IsSimpleParameterList is false, duplicate parameters are not allowed,\n-    // however `arguments` may be allowed if function is not strict code. Thus,\n-    // the assumptions explained above do not hold.\n-    return params_.Contains(variables_.Lookup(name));\n-  }\n+  bool IsDeclaredParameter(const AstRawString* name);\n \n   FunctionKind function_kind() const { return function_kind_; }\n \n@@ -812,7 +807,7 @@ class V8_EXPORT_PRIVATE DeclarationScope : public Scope {\n   // The local variable 'arguments' if we need to allocate it; nullptr\n   // otherwise.\n   Variable* arguments() const {\n-    DCHECK(!is_arrow_scope() || arguments_ == nullptr);\n+    DCHECK_IMPLIES(is_arrow_scope(), arguments_ == nullptr);\n     return arguments_;\n   }\n \n@@ -867,10 +862,9 @@ class V8_EXPORT_PRIVATE DeclarationScope : public Scope {\n \n   // Allocate ScopeInfos for top scope and any inner scopes that need them.\n   // Does nothing if ScopeInfo is already allocated.\n-  static void AllocateScopeInfos(ParseInfo* info, Isolate* isolate,\n-                                 AnalyzeMode mode);\n+  static void AllocateScopeInfos(ParseInfo* info, Isolate* isolate);\n \n-  Handle<StringSet> CollectNonLocals(ParseInfo* info,\n+  Handle<StringSet> CollectNonLocals(Isolate* isolate, ParseInfo* info,\n                                      Handle<StringSet> non_locals);\n \n   // Determine if we can use lazy compilation for this scope.\n@@ -964,7 +958,7 @@ class V8_EXPORT_PRIVATE DeclarationScope : public Scope {\n   bool has_inferred_function_name_ : 1;\n \n   // Parameter list in source order.\n-  ZoneList<Variable*> params_;\n+  ZonePtrList<Variable> params_;\n   // Map of function names to lists of functions defined in sloppy blocks\n   SloppyBlockFunctionMap* sloppy_block_function_map_;\n   // Convenience variable.\n@@ -1031,7 +1025,8 @@ class ModuleScope final : public DeclarationScope {\n   // The generated ModuleDescriptor does not preserve all information.  In\n   // particular, its module_requests map will be empty because we no longer need\n   // the map after parsing.\n-  ModuleScope(Handle<ScopeInfo> scope_info, AstValueFactory* ast_value_factory);\n+  ModuleScope(Isolate* isolate, Handle<ScopeInfo> scope_info,\n+              AstValueFactory* ast_value_factory);\n \n   ModuleDescriptor* module() const {\n     DCHECK_NOT_NULL(module_descriptor_);"
        },
        {
            "sha": "addcf8db2bd4b698fa5e310556808fc853b0223e",
            "filename": "deps/v8/src/ast/variables.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fvariables.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fvariables.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fvariables.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -26,7 +26,7 @@ Variable::Variable(Variable* other)\n bool Variable::IsGlobalObjectProperty() const {\n   // Temporaries are never global, they must always be allocated in the\n   // activation frame.\n-  return (IsDynamicVariableMode(mode()) || mode() == VAR) &&\n+  return (IsDynamicVariableMode(mode()) || mode() == VariableMode::kVar) &&\n          scope_ != nullptr && scope_->is_script_scope();\n }\n "
        },
        {
            "sha": "10ac5c48a53cee37bda51d36606d2aebd5c4f50a",
            "filename": "deps/v8/src/ast/variables.h",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fvariables.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fast%2Fvariables.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fast%2Fvariables.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -36,7 +36,8 @@ class Variable final : public ZoneObject {\n                    LocationField::encode(VariableLocation::UNALLOCATED) |\n                    VariableKindField::encode(kind)) {\n     // Var declared variables never need initialization.\n-    DCHECK(!(mode == VAR && initialization_flag == kNeedsInitialization));\n+    DCHECK(!(mode == VariableMode::kVar &&\n+             initialization_flag == kNeedsInitialization));\n   }\n \n   explicit Variable(Variable* other);\n@@ -137,7 +138,8 @@ class Variable final : public ZoneObject {\n   }\n \n   Variable* local_if_not_shadowed() const {\n-    DCHECK(mode() == DYNAMIC_LOCAL && local_if_not_shadowed_ != nullptr);\n+    DCHECK(mode() == VariableMode::kDynamicLocal &&\n+           local_if_not_shadowed_ != nullptr);\n     return local_if_not_shadowed_;\n   }\n \n@@ -175,7 +177,8 @@ class Variable final : public ZoneObject {\n \n   static InitializationFlag DefaultInitializationFlag(VariableMode mode) {\n     DCHECK(IsDeclaredVariableMode(mode));\n-    return mode == VAR ? kCreatedInitialized : kNeedsInitialization;\n+    return mode == VariableMode::kVar ? kCreatedInitialized\n+                                      : kNeedsInitialization;\n   }\n \n   typedef ThreadedList<Variable> List;"
        },
        {
            "sha": "cc080d9cfcd74e9be85c582d13b81f3dbfe13caf",
            "filename": "deps/v8/src/async-hooks-wrapper.cc",
            "status": "added",
            "additions": 259,
            "deletions": 0,
            "changes": 259,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasync-hooks-wrapper.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasync-hooks-wrapper.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fasync-hooks-wrapper.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2018 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \"src/async-hooks-wrapper.h\"\n+#include \"src/d8.h\"\n+\n+namespace v8 {\n+\n+void AsyncHooksWrap::Enable() { enabled_ = true; }\n+\n+void AsyncHooksWrap::Disable() { enabled_ = false; }\n+\n+v8::Local<v8::Function> AsyncHooksWrap::init_function() const {\n+  return init_function_.Get(isolate_);\n+}\n+void AsyncHooksWrap::set_init_function(v8::Local<v8::Function> value) {\n+  init_function_.Reset(isolate_, value);\n+}\n+v8::Local<v8::Function> AsyncHooksWrap::before_function() const {\n+  return before_function_.Get(isolate_);\n+}\n+void AsyncHooksWrap::set_before_function(v8::Local<v8::Function> value) {\n+  before_function_.Reset(isolate_, value);\n+}\n+v8::Local<v8::Function> AsyncHooksWrap::after_function() const {\n+  return after_function_.Get(isolate_);\n+}\n+void AsyncHooksWrap::set_after_function(v8::Local<v8::Function> value) {\n+  after_function_.Reset(isolate_, value);\n+}\n+v8::Local<v8::Function> AsyncHooksWrap::promiseResolve_function() const {\n+  return promiseResolve_function_.Get(isolate_);\n+}\n+void AsyncHooksWrap::set_promiseResolve_function(\n+    v8::Local<v8::Function> value) {\n+  promiseResolve_function_.Reset(isolate_, value);\n+}\n+\n+static AsyncHooksWrap* UnwrapHook(\n+    const v8::FunctionCallbackInfo<v8::Value>& args) {\n+  Isolate* isolate = args.GetIsolate();\n+  HandleScope scope(isolate);\n+  Local<Object> hook = args.This();\n+  Local<External> wrap = Local<External>::Cast(hook->GetInternalField(0));\n+  void* ptr = wrap->Value();\n+  return static_cast<AsyncHooksWrap*>(ptr);\n+}\n+\n+static void EnableHook(const v8::FunctionCallbackInfo<v8::Value>& args) {\n+  AsyncHooksWrap* wrap = UnwrapHook(args);\n+  wrap->Enable();\n+}\n+\n+static void DisableHook(const v8::FunctionCallbackInfo<v8::Value>& args) {\n+  AsyncHooksWrap* wrap = UnwrapHook(args);\n+  wrap->Disable();\n+}\n+\n+async_id_t AsyncHooks::GetExecutionAsyncId() const {\n+  return asyncContexts.top().execution_async_id;\n+}\n+\n+async_id_t AsyncHooks::GetTriggerAsyncId() const {\n+  return asyncContexts.top().trigger_async_id;\n+}\n+\n+Local<Object> AsyncHooks::CreateHook(\n+    const v8::FunctionCallbackInfo<v8::Value>& args) {\n+  Isolate* isolate = args.GetIsolate();\n+  EscapableHandleScope handle_scope(isolate);\n+\n+  Local<Context> currentContext = isolate->GetCurrentContext();\n+\n+  if (args.Length() != 1 || !args[0]->IsObject()) {\n+    isolate->ThrowException(\n+        String::NewFromUtf8(isolate, \"Invalid arguments passed to createHook\",\n+                            NewStringType::kNormal)\n+            .ToLocalChecked());\n+    return Local<Object>();\n+  }\n+\n+  AsyncHooksWrap* wrap = new AsyncHooksWrap(isolate);\n+\n+  Local<Object> fn_obj = args[0].As<Object>();\n+\n+#define SET_HOOK_FN(name)                                                   \\\n+  Local<Value> name##_v =                                                   \\\n+      fn_obj                                                                \\\n+          ->Get(currentContext,                                             \\\n+                String::NewFromUtf8(isolate, #name, NewStringType::kNormal) \\\n+                    .ToLocalChecked())                                      \\\n+          .ToLocalChecked();                                                \\\n+  if (name##_v->IsFunction()) {                                             \\\n+    wrap->set_##name##_function(name##_v.As<Function>());                   \\\n+  }\n+\n+  SET_HOOK_FN(init);\n+  SET_HOOK_FN(before);\n+  SET_HOOK_FN(after);\n+  SET_HOOK_FN(promiseResolve);\n+#undef SET_HOOK_FN\n+\n+  async_wraps_.push_back(wrap);\n+\n+  Local<Object> obj = async_hooks_templ.Get(isolate)\n+                          ->NewInstance(currentContext)\n+                          .ToLocalChecked();\n+  obj->SetInternalField(0, External::New(isolate, wrap));\n+\n+  return handle_scope.Escape(obj);\n+}\n+\n+void AsyncHooks::ShellPromiseHook(PromiseHookType type, Local<Promise> promise,\n+                                  Local<Value> parent) {\n+  AsyncHooks* hooks =\n+      PerIsolateData::Get(promise->GetIsolate())->GetAsyncHooks();\n+\n+  HandleScope handle_scope(hooks->isolate_);\n+\n+  Local<Context> currentContext = hooks->isolate_->GetCurrentContext();\n+\n+  if (type == PromiseHookType::kInit) {\n+    ++hooks->current_async_id;\n+    Local<Integer> async_id =\n+        Integer::New(hooks->isolate_, hooks->current_async_id);\n+\n+    promise->SetPrivate(currentContext,\n+                        hooks->async_id_smb.Get(hooks->isolate_), async_id);\n+    if (parent->IsPromise()) {\n+      Local<Promise> parent_promise = parent.As<Promise>();\n+      Local<Value> parent_async_id =\n+          parent_promise\n+              ->GetPrivate(hooks->isolate_->GetCurrentContext(),\n+                           hooks->async_id_smb.Get(hooks->isolate_))\n+              .ToLocalChecked();\n+      promise->SetPrivate(currentContext,\n+                          hooks->trigger_id_smb.Get(hooks->isolate_),\n+                          parent_async_id);\n+    } else {\n+      CHECK(parent->IsUndefined());\n+      Local<Integer> trigger_id = Integer::New(hooks->isolate_, 0);\n+      promise->SetPrivate(currentContext,\n+                          hooks->trigger_id_smb.Get(hooks->isolate_),\n+                          trigger_id);\n+    }\n+  } else if (type == PromiseHookType::kBefore) {\n+    AsyncContext ctx;\n+    ctx.execution_async_id =\n+        promise\n+            ->GetPrivate(hooks->isolate_->GetCurrentContext(),\n+                         hooks->async_id_smb.Get(hooks->isolate_))\n+            .ToLocalChecked()\n+            .As<Integer>()\n+            ->Value();\n+    ctx.trigger_async_id =\n+        promise\n+            ->GetPrivate(hooks->isolate_->GetCurrentContext(),\n+                         hooks->trigger_id_smb.Get(hooks->isolate_))\n+            .ToLocalChecked()\n+            .As<Integer>()\n+            ->Value();\n+    hooks->asyncContexts.push(ctx);\n+  } else if (type == PromiseHookType::kAfter) {\n+    hooks->asyncContexts.pop();\n+  }\n+\n+  for (AsyncHooksWrap* wrap : hooks->async_wraps_) {\n+    PromiseHookDispatch(type, promise, parent, wrap, hooks);\n+  }\n+}\n+\n+void AsyncHooks::Initialize() {\n+  HandleScope handle_scope(isolate_);\n+\n+  async_hook_ctor.Reset(isolate_, FunctionTemplate::New(isolate_));\n+  async_hook_ctor.Get(isolate_)->SetClassName(\n+      String::NewFromUtf8(isolate_, \"AsyncHook\", NewStringType::kNormal)\n+          .ToLocalChecked());\n+\n+  async_hooks_templ.Reset(isolate_,\n+                          async_hook_ctor.Get(isolate_)->InstanceTemplate());\n+  async_hooks_templ.Get(isolate_)->SetInternalFieldCount(1);\n+  async_hooks_templ.Get(isolate_)->Set(\n+      String::NewFromUtf8(isolate_, \"enable\"),\n+      FunctionTemplate::New(isolate_, EnableHook));\n+  async_hooks_templ.Get(isolate_)->Set(\n+      String::NewFromUtf8(isolate_, \"disable\"),\n+      FunctionTemplate::New(isolate_, DisableHook));\n+\n+  async_id_smb.Reset(isolate_, Private::New(isolate_));\n+  trigger_id_smb.Reset(isolate_, Private::New(isolate_));\n+\n+  isolate_->SetPromiseHook(ShellPromiseHook);\n+}\n+\n+void AsyncHooks::Deinitialize() {\n+  isolate_->SetPromiseHook(nullptr);\n+  for (AsyncHooksWrap* wrap : async_wraps_) {\n+    delete wrap;\n+  }\n+}\n+\n+void AsyncHooks::PromiseHookDispatch(PromiseHookType type,\n+                                     Local<Promise> promise,\n+                                     Local<Value> parent, AsyncHooksWrap* wrap,\n+                                     AsyncHooks* hooks) {\n+  if (!wrap->IsEnabled()) {\n+    return;\n+  }\n+\n+  HandleScope handle_scope(hooks->isolate_);\n+\n+  TryCatch try_catch(hooks->isolate_);\n+  try_catch.SetVerbose(true);\n+\n+  Local<Value> rcv = Undefined(hooks->isolate_);\n+  Local<Value> async_id =\n+      promise\n+          ->GetPrivate(hooks->isolate_->GetCurrentContext(),\n+                       hooks->async_id_smb.Get(hooks->isolate_))\n+          .ToLocalChecked();\n+  Local<Value> args[1] = {async_id};\n+\n+  // Sacrifice the brevity for readability and debugfulness\n+  if (type == PromiseHookType::kInit) {\n+    if (!wrap->init_function().IsEmpty()) {\n+      Local<Value> initArgs[4] = {\n+          async_id,\n+          String::NewFromUtf8(hooks->isolate_, \"PROMISE\",\n+                              NewStringType::kNormal)\n+              .ToLocalChecked(),\n+          promise\n+              ->GetPrivate(hooks->isolate_->GetCurrentContext(),\n+                           hooks->trigger_id_smb.Get(hooks->isolate_))\n+              .ToLocalChecked(),\n+          promise};\n+      wrap->init_function()->Call(rcv, 4, initArgs);\n+    }\n+  } else if (type == PromiseHookType::kBefore) {\n+    if (!wrap->before_function().IsEmpty()) {\n+      wrap->before_function()->Call(rcv, 1, args);\n+    }\n+  } else if (type == PromiseHookType::kAfter) {\n+    if (!wrap->after_function().IsEmpty()) {\n+      wrap->after_function()->Call(rcv, 1, args);\n+    }\n+  } else if (type == PromiseHookType::kResolve) {\n+    if (!wrap->promiseResolve_function().IsEmpty()) {\n+      wrap->promiseResolve_function()->Call(rcv, 1, args);\n+    }\n+  }\n+\n+  if (try_catch.HasCaught()) {\n+    Shell::ReportException(hooks->isolate_, &try_catch);\n+  }\n+}\n+\n+}  // namespace v8"
        },
        {
            "sha": "c0c72373e016cec9353bc755b4918df318fbcc40",
            "filename": "deps/v8/src/async-hooks-wrapper.h",
            "status": "added",
            "additions": 95,
            "deletions": 0,
            "changes": 95,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasync-hooks-wrapper.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fasync-hooks-wrapper.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fasync-hooks-wrapper.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2018 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8_ASYNC_HOOKS_WRAPPER_H_\n+#define V8_ASYNC_HOOKS_WRAPPER_H_\n+\n+#include <stack>\n+\n+#include \"include/v8.h\"\n+#include \"src/objects.h\"\n+\n+namespace v8 {\n+\n+typedef double async_id_t;\n+\n+struct AsyncContext {\n+  async_id_t execution_async_id;\n+  async_id_t trigger_async_id;\n+};\n+\n+class AsyncHooksWrap {\n+ public:\n+  explicit AsyncHooksWrap(Isolate* isolate) {\n+    enabled_ = false;\n+    isolate_ = isolate;\n+  }\n+  void Enable();\n+  void Disable();\n+  bool IsEnabled() const { return enabled_; }\n+\n+  inline v8::Local<v8::Function> init_function() const;\n+  inline void set_init_function(v8::Local<v8::Function> value);\n+  inline v8::Local<v8::Function> before_function() const;\n+  inline void set_before_function(v8::Local<v8::Function> value);\n+  inline v8::Local<v8::Function> after_function() const;\n+  inline void set_after_function(v8::Local<v8::Function> value);\n+  inline v8::Local<v8::Function> promiseResolve_function() const;\n+  inline void set_promiseResolve_function(v8::Local<v8::Function> value);\n+\n+ private:\n+  Isolate* isolate_;\n+\n+  Persistent<v8::Function> init_function_;\n+  Persistent<v8::Function> before_function_;\n+  Persistent<v8::Function> after_function_;\n+  Persistent<v8::Function> promiseResolve_function_;\n+\n+  bool enabled_;\n+};\n+\n+class AsyncHooks {\n+ public:\n+  explicit AsyncHooks(Isolate* isolate) {\n+    isolate_ = isolate;\n+\n+    AsyncContext ctx;\n+    ctx.execution_async_id = 1;\n+    ctx.trigger_async_id = 0;\n+    asyncContexts.push(ctx);\n+    current_async_id = 1;\n+\n+    Initialize();\n+  }\n+  ~AsyncHooks() { Deinitialize(); }\n+\n+  async_id_t GetExecutionAsyncId() const;\n+  async_id_t GetTriggerAsyncId() const;\n+\n+  Local<Object> CreateHook(const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n+ private:\n+  std::vector<AsyncHooksWrap*> async_wraps_;\n+  Isolate* isolate_;\n+  Persistent<FunctionTemplate> async_hook_ctor;\n+  Persistent<ObjectTemplate> async_hooks_templ;\n+  Persistent<Private> async_id_smb;\n+  Persistent<Private> trigger_id_smb;\n+\n+  void Initialize();\n+  void Deinitialize();\n+\n+  static void ShellPromiseHook(PromiseHookType type, Local<Promise> promise,\n+                               Local<Value> parent);\n+  static void PromiseHookDispatch(PromiseHookType type, Local<Promise> promise,\n+                                  Local<Value> parent, AsyncHooksWrap* wrap,\n+                                  AsyncHooks* hooks);\n+\n+  std::stack<AsyncContext> asyncContexts;\n+  async_id_t current_async_id;\n+};\n+\n+}  // namespace v8\n+\n+#endif  // V8_ASYNC_HOOKS_WRAPPER_H_"
        },
        {
            "sha": "d48d69602260154e22869f168ef8a77b16e658d0",
            "filename": "deps/v8/src/bailout-reason.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbailout-reason.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbailout-reason.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbailout-reason.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -31,7 +31,8 @@ namespace internal {\n     \"Invalid ElementsKind for InternalArray or InternalPackedArray\")           \\\n   V(kInvalidHandleScopeLevel, \"Invalid HandleScope level\")                     \\\n   V(kInvalidJumpTableIndex, \"Invalid jump table index\")                        \\\n-  V(kInvalidRegisterFileInGenerator, \"invalid register file in generator\")     \\\n+  V(kInvalidParametersAndRegistersInGenerator,                                 \\\n+    \"invalid parameters and registers in generator\")                           \\\n   V(kInvalidSharedFunctionInfoData, \"Invalid SharedFunctionInfo data\")         \\\n   V(kMissingBytecodeArray, \"Missing bytecode array from function\")             \\\n   V(kObjectNotTagged, \"The object is not tagged\")                              \\"
        },
        {
            "sha": "d81c537e57745553914b1d764bcbab6fe9f292e0",
            "filename": "deps/v8/src/base/atomic-utils.h",
            "status": "modified",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fatomic-utils.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fatomic-utils.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fatomic-utils.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -15,46 +15,6 @@ namespace v8 {\n namespace base {\n \n // Deprecated. Use std::atomic<T> for new code.\n-template <class T>\n-class AtomicNumber {\n- public:\n-  AtomicNumber() : value_(0) {}\n-  explicit AtomicNumber(T initial) : value_(initial) {}\n-\n-  // Returns the value after incrementing.\n-  V8_INLINE T Increment(T increment) {\n-    return static_cast<T>(base::Barrier_AtomicIncrement(\n-        &value_, static_cast<base::AtomicWord>(increment)));\n-  }\n-\n-  // Returns the value after decrementing.\n-  V8_INLINE T Decrement(T decrement) {\n-    return static_cast<T>(base::Barrier_AtomicIncrement(\n-        &value_, -static_cast<base::AtomicWord>(decrement)));\n-  }\n-\n-  V8_INLINE T Value() const {\n-    return static_cast<T>(base::Acquire_Load(&value_));\n-  }\n-\n-  V8_INLINE void SetValue(T new_value) {\n-    base::Release_Store(&value_, static_cast<base::AtomicWord>(new_value));\n-  }\n-\n-  V8_INLINE T operator=(T value) {\n-    SetValue(value);\n-    return value;\n-  }\n-\n-  V8_INLINE T operator+=(T value) { return Increment(value); }\n-  V8_INLINE T operator-=(T value) { return Decrement(value); }\n-\n- private:\n-  STATIC_ASSERT(sizeof(T) <= sizeof(base::AtomicWord));\n-\n-  base::AtomicWord value_;\n-};\n-\n // Flag using T atomically. Also accepts void* as T.\n template <typename T>\n class AtomicValue {"
        },
        {
            "sha": "c1637de81c700972c59af13fc486947433cb2d1f",
            "filename": "deps/v8/src/base/flags.h",
            "status": "modified",
            "additions": 26,
            "deletions": 14,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fflags.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fflags.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fflags.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -27,15 +27,15 @@ class Flags final {\n   typedef T flag_type;\n   typedef S mask_type;\n \n-  Flags() : mask_(0) {}\n-  Flags(flag_type flag)  // NOLINT(runtime/explicit)\n+  constexpr Flags() : mask_(0) {}\n+  constexpr Flags(flag_type flag)  // NOLINT(runtime/explicit)\n       : mask_(static_cast<S>(flag)) {}\n-  explicit Flags(mask_type mask) : mask_(static_cast<S>(mask)) {}\n+  constexpr explicit Flags(mask_type mask) : mask_(static_cast<S>(mask)) {}\n \n-  bool operator==(flag_type flag) const {\n+  constexpr bool operator==(flag_type flag) const {\n     return mask_ == static_cast<S>(flag);\n   }\n-  bool operator!=(flag_type flag) const {\n+  constexpr bool operator!=(flag_type flag) const {\n     return mask_ != static_cast<S>(flag);\n   }\n \n@@ -52,22 +52,34 @@ class Flags final {\n     return *this;\n   }\n \n-  Flags operator&(const Flags& flags) const { return Flags(*this) &= flags; }\n-  Flags operator|(const Flags& flags) const { return Flags(*this) |= flags; }\n-  Flags operator^(const Flags& flags) const { return Flags(*this) ^= flags; }\n+  constexpr Flags operator&(const Flags& flags) const {\n+    return Flags(*this) &= flags;\n+  }\n+  constexpr Flags operator|(const Flags& flags) const {\n+    return Flags(*this) |= flags;\n+  }\n+  constexpr Flags operator^(const Flags& flags) const {\n+    return Flags(*this) ^= flags;\n+  }\n \n   Flags& operator&=(flag_type flag) { return operator&=(Flags(flag)); }\n   Flags& operator|=(flag_type flag) { return operator|=(Flags(flag)); }\n   Flags& operator^=(flag_type flag) { return operator^=(Flags(flag)); }\n \n-  Flags operator&(flag_type flag) const { return operator&(Flags(flag)); }\n-  Flags operator|(flag_type flag) const { return operator|(Flags(flag)); }\n-  Flags operator^(flag_type flag) const { return operator^(Flags(flag)); }\n+  constexpr Flags operator&(flag_type flag) const {\n+    return operator&(Flags(flag));\n+  }\n+  constexpr Flags operator|(flag_type flag) const {\n+    return operator|(Flags(flag));\n+  }\n+  constexpr Flags operator^(flag_type flag) const {\n+    return operator^(Flags(flag));\n+  }\n \n-  Flags operator~() const { return Flags(~mask_); }\n+  constexpr Flags operator~() const { return Flags(~mask_); }\n \n-  operator mask_type() const { return mask_; }\n-  bool operator!() const { return !mask_; }\n+  constexpr operator mask_type() const { return mask_; }\n+  constexpr bool operator!() const { return !mask_; }\n \n   friend size_t hash_value(const Flags& flags) { return flags.mask_; }\n "
        },
        {
            "sha": "18e45318a24e8ac3b5bc7ca3108c7f6cba2ecf33",
            "filename": "deps/v8/src/base/list.h",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Flist.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Flist.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Flist.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -0,0 +1,136 @@\n+// Copyright 2018 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef V8_BASE_LIST_H_\n+#define V8_BASE_LIST_H_\n+\n+#include <atomic>\n+\n+#include \"src/base/logging.h\"\n+\n+namespace v8 {\n+namespace base {\n+\n+template <class T>\n+class List {\n+ public:\n+  List() : front_(nullptr), back_(nullptr) {}\n+\n+  void PushBack(T* element) {\n+    DCHECK(!element->list_node().next());\n+    DCHECK(!element->list_node().prev());\n+    if (back_) {\n+      DCHECK(front_);\n+      InsertAfter(element, back_);\n+    } else {\n+      AddFirstElement(element);\n+    }\n+  }\n+\n+  void PushFront(T* element) {\n+    DCHECK(!element->list_node().next());\n+    DCHECK(!element->list_node().prev());\n+    if (front_) {\n+      DCHECK(back_);\n+      InsertBefore(element, front_);\n+    } else {\n+      AddFirstElement(element);\n+    }\n+  }\n+\n+  void Remove(T* element) {\n+    DCHECK(Contains(element));\n+    if (back_ == element) {\n+      back_ = element->list_node().prev();\n+    }\n+    if (front_ == element) {\n+      front_ = element->list_node().next();\n+    }\n+    T* next = element->list_node().next();\n+    T* prev = element->list_node().prev();\n+    if (next) next->list_node().set_prev(prev);\n+    if (prev) prev->list_node().set_next(next);\n+    element->list_node().set_prev(nullptr);\n+    element->list_node().set_next(nullptr);\n+  }\n+\n+  bool Contains(T* element) {\n+    T* it = front_;\n+    while (it) {\n+      if (it == element) return true;\n+      it = it->list_node().next();\n+    }\n+    return false;\n+  }\n+\n+  bool Empty() { return !front_ && !back_; }\n+\n+  T* front() { return front_; }\n+  T* back() { return back_; }\n+\n+ private:\n+  void AddFirstElement(T* element) {\n+    DCHECK(!back_);\n+    DCHECK(!front_);\n+    DCHECK(!element->list_node().next());\n+    DCHECK(!element->list_node().prev());\n+    element->list_node().set_prev(nullptr);\n+    element->list_node().set_next(nullptr);\n+    front_ = element;\n+    back_ = element;\n+  }\n+\n+  void InsertAfter(T* element, T* other) {\n+    T* other_next = other->list_node().next();\n+    element->list_node().set_next(other_next);\n+    element->list_node().set_prev(other);\n+    other->list_node().set_next(element);\n+    if (other_next)\n+      other_next->list_node().set_prev(element);\n+    else\n+      back_ = element;\n+  }\n+\n+  void InsertBefore(T* element, T* other) {\n+    T* other_prev = other->list_node().prev();\n+    element->list_node().set_next(other);\n+    element->list_node().set_prev(other_prev);\n+    other->list_node().set_prev(element);\n+    if (other_prev) {\n+      other_prev->list_node().set_next(element);\n+    } else {\n+      front_ = element;\n+    }\n+  }\n+\n+  T* front_;\n+  T* back_;\n+};\n+\n+template <class T>\n+class ListNode {\n+ public:\n+  ListNode() { Initialize(); }\n+\n+  T* next() { return next_; }\n+  T* prev() { return prev_; }\n+\n+  void Initialize() {\n+    next_ = nullptr;\n+    prev_ = nullptr;\n+  }\n+\n+ private:\n+  void set_next(T* next) { next_ = next; }\n+  void set_prev(T* prev) { prev_ = prev; }\n+\n+  T* next_;\n+  T* prev_;\n+\n+  friend class List<T>;\n+};\n+}  // namespace base\n+}  // namespace v8\n+\n+#endif  // V8_BASE_LIST_H_"
        },
        {
            "sha": "5d10ae4ec0a5a0b4f4cbc66e6faf2603ee0f84c5",
            "filename": "deps/v8/src/base/macros.h",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fmacros.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fmacros.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fmacros.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -145,10 +145,6 @@ V8_INLINE Dest bit_cast(Source const& source) {\n   void operator delete(void*, size_t) { base::OS::Abort(); } \\\n   void operator delete[](void*, size_t) { base::OS::Abort(); }\n \n-// Newly written code should use V8_INLINE and V8_NOINLINE directly.\n-#define INLINE(declarator)    V8_INLINE declarator\n-#define NO_INLINE(declarator) V8_NOINLINE declarator\n-\n // Define V8_USE_ADDRESS_SANITIZER macro.\n #if defined(__has_feature)\n #if __has_feature(address_sanitizer)"
        },
        {
            "sha": "cf7f3ec9bb16281a3cb9869b7a9f407d39dc207c",
            "filename": "deps/v8/src/base/platform/platform-posix.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-posix.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-posix.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform-posix.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -156,6 +156,8 @@ int ReclaimInaccessibleMemory(void* address, size_t size) {\n #else\n   int ret = madvise(address, size, MADV_FREE);\n #endif\n+  if (ret != 0 && errno == ENOSYS)\n+    return 0;  // madvise is not available on all systems.\n   if (ret != 0 && errno == EINVAL) {\n     // MADV_FREE only works on Linux 4.5+ . If request failed, retry with older\n     // MADV_DONTNEED . Note that MADV_FREE being defined at compile time doesn't"
        },
        {
            "sha": "51b60148216ccc8573698cd6d5d000e77b699465",
            "filename": "deps/v8/src/base/platform/platform.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Fplatform.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -48,7 +48,7 @@ namespace base {\n \n #define V8_FAST_TLS_SUPPORTED 1\n \n-INLINE(intptr_t InternalGetExistingThreadLocal(intptr_t index));\n+V8_INLINE intptr_t InternalGetExistingThreadLocal(intptr_t index);\n \n inline intptr_t InternalGetExistingThreadLocal(intptr_t index) {\n   const intptr_t kTibInlineTlsOffset = 0xE10;\n@@ -74,7 +74,7 @@ inline intptr_t InternalGetExistingThreadLocal(intptr_t index) {\n \n extern V8_BASE_EXPORT intptr_t kMacTlsBaseOffset;\n \n-INLINE(intptr_t InternalGetExistingThreadLocal(intptr_t index));\n+V8_INLINE intptr_t InternalGetExistingThreadLocal(intptr_t index);\n \n inline intptr_t InternalGetExistingThreadLocal(intptr_t index) {\n   intptr_t result;"
        },
        {
            "sha": "1ab56f42b5091c2a700eafdca02282b3ae0a2fd4",
            "filename": "deps/v8/src/base/platform/time.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 1,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Ftime.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Ftime.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbase%2Fplatform%2Ftime.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -86,6 +86,26 @@ V8_INLINE int64_t ClockNow(clockid_t clk_id) {\n   return 0;\n #endif\n }\n+\n+V8_INLINE bool IsHighResolutionTimer(clockid_t clk_id) {\n+  // Limit duration of timer resolution measurement to 100 ms. If we cannot\n+  // measure timer resoltuion within this time, we assume a low resolution\n+  // timer.\n+  int64_t end =\n+      ClockNow(clk_id) + 100 * v8::base::Time::kMicrosecondsPerMillisecond;\n+  int64_t start, delta;\n+  do {\n+    start = ClockNow(clk_id);\n+    // Loop until we can detect that the clock has changed. Non-HighRes timers\n+    // will increment in chunks, i.e. 15ms. By spinning until we see a clock\n+    // change, we detect the minimum time between measurements.\n+    do {\n+      delta = ClockNow(clk_id) - start;\n+    } while (delta == 0);\n+  } while (delta > 1 && start < end);\n+  return delta <= 1;\n+}\n+\n #elif V8_OS_WIN\n V8_INLINE bool IsQPCReliable() {\n   v8::base::CPU cpu;\n@@ -735,7 +755,16 @@ TimeTicks TimeTicks::Now() {\n }\n \n // static\n-bool TimeTicks::IsHighResolution() { return true; }\n+bool TimeTicks::IsHighResolution() {\n+#if V8_OS_MACOSX\n+  return true;\n+#elif V8_OS_POSIX\n+  static bool is_high_resolution = IsHighResolutionTimer(CLOCK_MONOTONIC);\n+  return is_high_resolution;\n+#else\n+  return true;\n+#endif\n+}\n \n #endif  // V8_OS_WIN\n "
        },
        {
            "sha": "6723f3d5d463327cada8477626562a3c27c3e69f",
            "filename": "deps/v8/src/bootstrapper.cc",
            "status": "modified",
            "additions": 1445,
            "deletions": 1353,
            "changes": 2798,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbootstrapper.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbootstrapper.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbootstrapper.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "e3ba8c06f2149ffa99aeb8b38447bdc4c703d19d",
            "filename": "deps/v8/src/bootstrapper.h",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbootstrapper.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbootstrapper.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbootstrapper.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -29,9 +29,11 @@ class SourceCodeCache final BASE_EMBEDDED {\n                         bit_cast<Object**, FixedArray**>(&cache_));\n   }\n \n-  bool Lookup(Vector<const char> name, Handle<SharedFunctionInfo>* handle);\n+  bool Lookup(Isolate* isolate, Vector<const char> name,\n+              Handle<SharedFunctionInfo>* handle);\n \n-  void Add(Vector<const char> name, Handle<SharedFunctionInfo> shared);\n+  void Add(Isolate* isolate, Vector<const char> name,\n+           Handle<SharedFunctionInfo> shared);\n \n  private:\n   Script::Type type_;"
        },
        {
            "sha": "a5219bf0701d67f6177bc1bb94441c09356889b1",
            "filename": "deps/v8/src/builtins/arm/builtins-arm.cc",
            "status": "modified",
            "additions": 156,
            "deletions": 403,
            "changes": 559,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm%2Fbuiltins-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm%2Fbuiltins-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm%2Fbuiltins-arm.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -28,7 +28,7 @@ void Builtins::Generate_Adaptor(MacroAssembler* masm, Address address,\n                    ExternalReference::Create(address).address()) &\n                    1);\n #endif\n-  __ Move(r5, ExternalReference::Create(address));\n+  __ Move(kJavaScriptCallExtraArg1Register, ExternalReference::Create(address));\n   if (exit_frame_type == BUILTIN_EXIT) {\n     __ Jump(BUILTIN_CODE(masm->isolate(), AdaptorWithBuiltinExitFrame),\n             RelocInfo::CODE_TARGET);\n@@ -39,57 +39,6 @@ void Builtins::Generate_Adaptor(MacroAssembler* masm, Address address,\n   }\n }\n \n-namespace {\n-\n-void AdaptorWithExitFrameType(MacroAssembler* masm,\n-                              Builtins::ExitFrameType exit_frame_type) {\n-  // ----------- S t a t e -------------\n-  //  -- r0                 : number of arguments excluding receiver\n-  //  -- r1                 : target\n-  //  -- r3                 : new.target\n-  //  -- r5                 : entry point\n-  //  -- sp[0]              : last argument\n-  //  -- ...\n-  //  -- sp[4 * (argc - 1)] : first argument\n-  //  -- sp[4 * argc]       : receiver\n-  // -----------------------------------\n-  __ AssertFunction(r1);\n-\n-  // Make sure we operate in the context of the called function (for example\n-  // ConstructStubs implemented in C++ will be run in the context of the caller\n-  // instead of the callee, due to the way that [[Construct]] is defined for\n-  // ordinary functions).\n-  __ ldr(cp, FieldMemOperand(r1, JSFunction::kContextOffset));\n-\n-  // CEntry expects r0 to contain the number of arguments including the\n-  // receiver and the extra arguments.\n-  __ add(r0, r0, Operand(BuiltinExitFrameConstants::kNumExtraArgsWithReceiver));\n-\n-  // Insert extra arguments.\n-  __ PushRoot(Heap::kTheHoleValueRootIndex);  // Padding.\n-  __ SmiTag(r0);\n-  __ Push(r0, r1, r3);\n-  __ SmiUntag(r0);\n-\n-  // Jump to the C entry runtime stub directly here instead of using\n-  // JumpToExternalReference. We have already loaded entry point to r5\n-  // in Generate_adaptor.\n-  __ mov(r1, r5);\n-  Handle<Code> code =\n-      CodeFactory::CEntry(masm->isolate(), 1, kDontSaveFPRegs, kArgvOnStack,\n-                          exit_frame_type == Builtins::BUILTIN_EXIT);\n-  __ Jump(code, RelocInfo::CODE_TARGET);\n-}\n-}  // namespace\n-\n-void Builtins::Generate_AdaptorWithExitFrame(MacroAssembler* masm) {\n-  AdaptorWithExitFrameType(masm, EXIT);\n-}\n-\n-void Builtins::Generate_AdaptorWithBuiltinExitFrame(MacroAssembler* masm) {\n-  AdaptorWithExitFrameType(masm, BUILTIN_EXIT);\n-}\n-\n void Builtins::Generate_InternalArrayConstructor(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- r0     : number of arguments\n@@ -111,39 +60,8 @@ void Builtins::Generate_InternalArrayConstructor(MacroAssembler* masm) {\n   // function.\n   // tail call a stub\n   __ LoadRoot(r2, Heap::kUndefinedValueRootIndex);\n-  InternalArrayConstructorStub stub(masm->isolate());\n-  __ TailCallStub(&stub);\n-}\n-\n-void Builtins::Generate_ArrayConstructor(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- r0     : number of arguments\n-  //  -- r1     : array function\n-  //  -- lr     : return address\n-  //  -- sp[...]: constructor arguments\n-  // -----------------------------------\n-  Label generic_array_code, one_or_more_arguments, two_or_more_arguments;\n-\n-  if (FLAG_debug_code) {\n-    // Initial map for the builtin Array functions should be maps.\n-    __ ldr(r7, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n-    __ SmiTst(r7);\n-    __ Assert(ne, AbortReason::kUnexpectedInitialMapForArrayFunction);\n-    __ CompareObjectType(r7, r8, r9, MAP_TYPE);\n-    __ Assert(eq, AbortReason::kUnexpectedInitialMapForArrayFunction);\n-  }\n-\n-  // r2 is the AllocationSite - here undefined.\n-  __ LoadRoot(r2, Heap::kUndefinedValueRootIndex);\n-  // If r3 (new target) is undefined, then this is the 'Call' case, so move\n-  // r1 (the constructor) to r3.\n-  __ cmp(r3, r2);\n-  __ mov(r3, r1, LeaveCC, eq);\n-\n-  // Run the native code for the Array function called as a normal function.\n-  // tail call a stub\n-  ArrayConstructorStub stub(masm->isolate());\n-  __ TailCallStub(&stub);\n+  __ Jump(BUILTIN_CODE(masm->isolate(), InternalArrayConstructorImpl),\n+          RelocInfo::CODE_TARGET);\n }\n \n static void GenerateTailCallToReturnedCode(MacroAssembler* masm,\n@@ -494,20 +412,25 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n   //  -- sp[0] : generator receiver\n   // -----------------------------------\n \n-  // Push holes for arguments to generator function. Since the parser forced\n-  // context allocation for any variables in generators, the actual argument\n-  // values have already been copied into the context and these dummy values\n-  // will never be used.\n+  // Copy the function arguments from the generator object's register file.\n   __ ldr(r3, FieldMemOperand(r4, JSFunction::kSharedFunctionInfoOffset));\n-  __ ldr(r3,\n-         FieldMemOperand(r3, SharedFunctionInfo::kFormalParameterCountOffset));\n+  __ ldrh(r3,\n+          FieldMemOperand(r3, SharedFunctionInfo::kFormalParameterCountOffset));\n+  __ ldr(r2,\n+         FieldMemOperand(r1, JSGeneratorObject::kParametersAndRegistersOffset));\n   {\n     Label done_loop, loop;\n+    __ mov(r6, Operand(0));\n+\n     __ bind(&loop);\n-    __ sub(r3, r3, Operand(1), SetCC);\n-    __ b(mi, &done_loop);\n-    __ PushRoot(Heap::kTheHoleValueRootIndex);\n+    __ cmp(r6, r3);\n+    __ b(ge, &done_loop);\n+    __ add(scratch, r2, Operand(r6, LSL, kPointerSizeLog2));\n+    __ ldr(scratch, FieldMemOperand(scratch, FixedArray::kHeaderSize));\n+    __ Push(scratch);\n+    __ add(r6, r6, Operand(1));\n     __ b(&loop);\n+\n     __ bind(&done_loop);\n   }\n \n@@ -523,8 +446,8 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n   // Resume (Ignition/TurboFan) generator object.\n   {\n     __ ldr(r0, FieldMemOperand(r4, JSFunction::kSharedFunctionInfoOffset));\n-    __ ldr(r0, FieldMemOperand(\n-                   r0, SharedFunctionInfo::kFormalParameterCountOffset));\n+    __ ldrh(r0, FieldMemOperand(\n+                    r0, SharedFunctionInfo::kFormalParameterCountOffset));\n     // We abuse new.target both to indicate that this is a resume call and to\n     // pass in the generator object.  In ordinary calls, new.target is always\n     // undefined because generator functions are non-constructable.\n@@ -906,17 +829,12 @@ void Builtins::Generate_InterpreterEntryTrampoline(MacroAssembler* masm) {\n   FrameScope frame_scope(masm, StackFrame::MANUAL);\n   __ PushStandardFrame(closure);\n \n-  // Get the bytecode array from the function object (or from the DebugInfo if\n-  // it is present) and load it into kInterpreterBytecodeArrayRegister.\n-  Label maybe_load_debug_bytecode_array, bytecode_array_loaded;\n+  // Get the bytecode array from the function object and load it into\n+  // kInterpreterBytecodeArrayRegister.\n   __ ldr(r0, FieldMemOperand(closure, JSFunction::kSharedFunctionInfoOffset));\n   __ ldr(kInterpreterBytecodeArrayRegister,\n          FieldMemOperand(r0, SharedFunctionInfo::kFunctionDataOffset));\n   GetSharedFunctionInfoBytecode(masm, kInterpreterBytecodeArrayRegister, r4);\n-  __ ldr(r4, FieldMemOperand(r0, SharedFunctionInfo::kDebugInfoOffset));\n-  __ SmiTst(r4);\n-  __ b(ne, &maybe_load_debug_bytecode_array);\n-  __ bind(&bytecode_array_loaded);\n \n   // Increment invocation count for the function.\n   __ ldr(r9, FieldMemOperand(feedback_vector,\n@@ -1027,37 +945,6 @@ void Builtins::Generate_InterpreterEntryTrampoline(MacroAssembler* masm) {\n   // The return value is in r0.\n   LeaveInterpreterFrame(masm, r2);\n   __ Jump(lr);\n-\n-  // Load debug copy of the bytecode array if it exists.\n-  // kInterpreterBytecodeArrayRegister is already loaded with\n-  // SharedFunctionInfo::kFunctionDataOffset.\n-  __ bind(&maybe_load_debug_bytecode_array);\n-  __ ldr(r9, FieldMemOperand(r4, DebugInfo::kDebugBytecodeArrayOffset), ne);\n-  __ JumpIfRoot(r9, Heap::kUndefinedValueRootIndex, &bytecode_array_loaded);\n-\n-  __ mov(kInterpreterBytecodeArrayRegister, r9);\n-  __ ldr(r9, FieldMemOperand(r4, DebugInfo::kFlagsOffset));\n-  __ SmiUntag(r9);\n-  __ And(r9, r9, Operand(DebugInfo::kDebugExecutionMode));\n-\n-  ExternalReference debug_execution_mode =\n-      ExternalReference::debug_execution_mode_address(masm->isolate());\n-  __ mov(r4, Operand(debug_execution_mode));\n-  __ ldrsb(r4, MemOperand(r4));\n-  STATIC_ASSERT(static_cast<int>(DebugInfo::kDebugExecutionMode) ==\n-                static_cast<int>(DebugInfo::kSideEffects));\n-  __ cmp(r4, r9);\n-  __ b(eq, &bytecode_array_loaded);\n-\n-  __ push(closure);\n-  __ push(feedback_vector);\n-  __ push(kInterpreterBytecodeArrayRegister);\n-  __ push(closure);\n-  __ CallRuntime(Runtime::kDebugApplyInstrumentation);\n-  __ pop(kInterpreterBytecodeArrayRegister);\n-  __ pop(feedback_vector);\n-  __ pop(closure);\n-  __ b(&bytecode_array_loaded);\n }\n \n static void Generate_InterpreterPushArgs(MacroAssembler* masm,\n@@ -1160,8 +1047,8 @@ void Builtins::Generate_InterpreterPushArgsThenConstructImpl(\n \n     // Tail call to the array construct stub (still in the caller\n     // context at this point).\n-    ArrayConstructorStub array_constructor_stub(masm->isolate());\n-    __ Jump(array_constructor_stub.GetCode(), RelocInfo::CODE_TARGET);\n+    Handle<Code> code = BUILTIN_CODE(masm->isolate(), ArrayConstructorImpl);\n+    __ Jump(code, RelocInfo::CODE_TARGET);\n   } else if (mode == InterpreterPushArgsMode::kWithFinalSpread) {\n     // Call the constructor with r0, r1, and r3 unmodified.\n     __ Jump(BUILTIN_CODE(masm->isolate(), ConstructWithSpread),\n@@ -1278,208 +1165,6 @@ void Builtins::Generate_InterpreterEnterBytecodeDispatch(MacroAssembler* masm) {\n   Generate_InterpreterEnterBytecode(masm);\n }\n \n-void Builtins::Generate_CompileLazyDeoptimizedCode(MacroAssembler* masm) {\n-  // Set the code slot inside the JSFunction to CompileLazy.\n-  __ Move(r2, BUILTIN_CODE(masm->isolate(), CompileLazy));\n-  __ str(r2, FieldMemOperand(r1, JSFunction::kCodeOffset));\n-  __ RecordWriteField(r1, JSFunction::kCodeOffset, r2, r4, kLRHasNotBeenSaved,\n-                      kDontSaveFPRegs, OMIT_REMEMBERED_SET, OMIT_SMI_CHECK);\n-  // Jump to compile lazy.\n-  Generate_CompileLazy(masm);\n-}\n-\n-static void GetSharedFunctionInfoCode(MacroAssembler* masm, Register sfi_data,\n-                                      Register scratch1) {\n-  // Figure out the SFI's code object.\n-  Label done;\n-  Label check_is_bytecode_array;\n-  Label check_is_exported_function_data;\n-  Label check_is_fixed_array;\n-  Label check_is_pre_parsed_scope_data;\n-  Label check_is_function_template_info;\n-  Label check_is_interpreter_data;\n-\n-  Register data_type = scratch1;\n-\n-  // IsSmi: Is builtin\n-  __ JumpIfNotSmi(sfi_data, &check_is_bytecode_array);\n-  __ Move(scratch1, ExternalReference::builtins_address(masm->isolate()));\n-  __ ldr(sfi_data, MemOperand::PointerAddressFromSmiKey(scratch1, sfi_data));\n-  __ b(&done);\n-\n-  // Get map for subsequent checks.\n-  __ bind(&check_is_bytecode_array);\n-  __ ldr(data_type, FieldMemOperand(sfi_data, HeapObject::kMapOffset));\n-  __ ldrh(data_type, FieldMemOperand(data_type, Map::kInstanceTypeOffset));\n-\n-  // IsBytecodeArray: Interpret bytecode\n-  __ cmp(data_type, Operand(BYTECODE_ARRAY_TYPE));\n-  __ b(ne, &check_is_exported_function_data);\n-  __ Move(sfi_data, BUILTIN_CODE(masm->isolate(), InterpreterEntryTrampoline));\n-  __ b(&done);\n-\n-  // IsWasmExportedFunctionData: Use the wrapper code\n-  __ bind(&check_is_exported_function_data);\n-  __ cmp(data_type, Operand(WASM_EXPORTED_FUNCTION_DATA_TYPE));\n-  __ b(ne, &check_is_fixed_array);\n-  __ ldr(sfi_data, FieldMemOperand(\n-                       sfi_data, WasmExportedFunctionData::kWrapperCodeOffset));\n-  __ b(&done);\n-\n-  // IsFixedArray: Instantiate using AsmWasmData\n-  __ bind(&check_is_fixed_array);\n-  __ cmp(data_type, Operand(FIXED_ARRAY_TYPE));\n-  __ b(ne, &check_is_pre_parsed_scope_data);\n-  __ Move(sfi_data, BUILTIN_CODE(masm->isolate(), InstantiateAsmJs));\n-  __ b(&done);\n-\n-  // IsPreParsedScopeData: Compile lazy\n-  __ bind(&check_is_pre_parsed_scope_data);\n-  __ cmp(data_type, Operand(TUPLE2_TYPE));\n-  __ b(ne, &check_is_function_template_info);\n-  __ Move(sfi_data, BUILTIN_CODE(masm->isolate(), CompileLazy));\n-  __ b(&done);\n-\n-  // IsFunctionTemplateInfo: API call\n-  __ bind(&check_is_function_template_info);\n-  __ cmp(data_type, Operand(FUNCTION_TEMPLATE_INFO_TYPE));\n-  __ b(ne, &check_is_interpreter_data);\n-  __ Move(sfi_data, BUILTIN_CODE(masm->isolate(), HandleApiCall));\n-  __ b(&done);\n-\n-  // IsInterpreterData: Interpret bytecode\n-  __ bind(&check_is_interpreter_data);\n-  if (FLAG_debug_code) {\n-    __ cmp(data_type, Operand(INTERPRETER_DATA_TYPE));\n-    __ Assert(eq, AbortReason::kInvalidSharedFunctionInfoData);\n-  }\n-  __ ldr(\n-      sfi_data,\n-      FieldMemOperand(sfi_data, InterpreterData::kInterpreterTrampolineOffset));\n-\n-  __ bind(&done);\n-}\n-\n-void Builtins::Generate_CompileLazy(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- r0 : argument count (preserved for callee)\n-  //  -- r3 : new target (preserved for callee)\n-  //  -- r1 : target function (preserved for callee)\n-  // -----------------------------------\n-  // First lookup code, maybe we don't need to compile!\n-  Label gotta_call_runtime;\n-\n-  Register closure = r1;\n-  Register feedback_vector = r2;\n-\n-  // Do we have a valid feedback vector?\n-  __ ldr(feedback_vector,\n-         FieldMemOperand(closure, JSFunction::kFeedbackCellOffset));\n-  __ ldr(feedback_vector, FieldMemOperand(feedback_vector, Cell::kValueOffset));\n-  __ JumpIfRoot(feedback_vector, Heap::kUndefinedValueRootIndex,\n-                &gotta_call_runtime);\n-\n-  // Is there an optimization marker or optimized code in the feedback vector?\n-  MaybeTailCallOptimizedCodeSlot(masm, feedback_vector, r4, r6, r5);\n-\n-  // We found no optimized code. Infer the code object needed for the SFI.\n-  Register entry = r4;\n-  __ ldr(entry,\n-         FieldMemOperand(closure, JSFunction::kSharedFunctionInfoOffset));\n-  __ ldr(entry,\n-         FieldMemOperand(entry, SharedFunctionInfo::kFunctionDataOffset));\n-  GetSharedFunctionInfoCode(masm, entry, r5);\n-\n-  // If code entry points to anything other than CompileLazy, install that.\n-  __ Move(r5, masm->CodeObject());\n-  __ cmp(entry, r5);\n-  __ b(eq, &gotta_call_runtime);\n-\n-  // Install the SFI's code entry.\n-  __ str(entry, FieldMemOperand(closure, JSFunction::kCodeOffset));\n-  __ mov(r9, entry);  // Write barrier clobbers r9 below.\n-  __ RecordWriteField(closure, JSFunction::kCodeOffset, r9, r5,\n-                      kLRHasNotBeenSaved, kDontSaveFPRegs, OMIT_REMEMBERED_SET,\n-                      OMIT_SMI_CHECK);\n-  __ add(entry, entry, Operand(Code::kHeaderSize - kHeapObjectTag));\n-  __ Jump(entry);\n-\n-  __ bind(&gotta_call_runtime);\n-  GenerateTailCallToReturnedCode(masm, Runtime::kCompileLazy);\n-}\n-\n-// Lazy deserialization design doc: http://goo.gl/dxkYDZ.\n-void Builtins::Generate_DeserializeLazy(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- r0 : argument count (preserved for callee)\n-  //  -- r3 : new target (preserved for callee)\n-  //  -- r1 : target function (preserved for callee)\n-  // -----------------------------------\n-\n-  Label deserialize_in_runtime;\n-\n-  Register target = r1;  // Must be preserved\n-  Register scratch0 = r2;\n-  Register scratch1 = r4;\n-\n-  CHECK(scratch0 != r0 && scratch0 != r3 && scratch0 != r1);\n-  CHECK(scratch1 != r0 && scratch1 != r3 && scratch1 != r1);\n-  CHECK(scratch0 != scratch1);\n-\n-  // Load the builtin id for lazy deserialization from SharedFunctionInfo.\n-\n-  __ AssertFunction(target);\n-  __ ldr(scratch0,\n-         FieldMemOperand(target, JSFunction::kSharedFunctionInfoOffset));\n-\n-  __ ldr(scratch1,\n-         FieldMemOperand(scratch0, SharedFunctionInfo::kFunctionDataOffset));\n-  __ AssertSmi(scratch1);\n-\n-  // The builtin may already have been deserialized. If that is the case, it is\n-  // stored in the builtins table, and we can copy to correct code object to\n-  // both the shared function info and function without calling into runtime.\n-  //\n-  // Otherwise, we need to call into runtime to deserialize.\n-\n-  {\n-    // Load the code object at builtins_table[builtin_id] into scratch1.\n-\n-    __ SmiUntag(scratch1);\n-    __ Move(scratch0, ExternalReference::builtins_address(masm->isolate()));\n-    __ ldr(scratch1, MemOperand(scratch0, scratch1, LSL, kPointerSizeLog2));\n-\n-    // Check if the loaded code object has already been deserialized. This is\n-    // the case iff it does not equal DeserializeLazy.\n-\n-    __ Move(scratch0, masm->CodeObject());\n-    __ cmp(scratch1, scratch0);\n-    __ b(eq, &deserialize_in_runtime);\n-  }\n-\n-  {\n-    // If we've reached this spot, the target builtin has been deserialized and\n-    // we simply need to copy it over to the target function.\n-\n-    Register target_builtin = scratch1;\n-\n-    __ str(target_builtin, FieldMemOperand(target, JSFunction::kCodeOffset));\n-    __ mov(r9, target_builtin);  // Write barrier clobbers r9 below.\n-    __ RecordWriteField(target, JSFunction::kCodeOffset, r9, r5,\n-                        kLRHasNotBeenSaved, kDontSaveFPRegs,\n-                        OMIT_REMEMBERED_SET, OMIT_SMI_CHECK);\n-\n-    // All copying is done. Jump to the deserialized code object.\n-\n-    __ add(target_builtin, target_builtin,\n-           Operand(Code::kHeaderSize - kHeapObjectTag));\n-    __ Jump(target_builtin);\n-  }\n-\n-  __ bind(&deserialize_in_runtime);\n-  GenerateTailCallToReturnedCode(masm, Runtime::kDeserializeLazy);\n-}\n-\n void Builtins::Generate_InstantiateAsmJs(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- r0 : argument count (preserved for callee)\n@@ -1892,10 +1577,27 @@ void Builtins::Generate_CallOrConstructVarargs(MacroAssembler* masm,\n   //  -- r4 : len (number of elements to push from args)\n   //  -- r3 : new.target (for [[Construct]])\n   // -----------------------------------\n-  __ AssertFixedArray(r2);\n-\n   Register scratch = r8;\n \n+  if (masm->emit_debug_code()) {\n+    // Allow r2 to be a FixedArray, or a FixedDoubleArray if r4 == 0.\n+    Label ok, fail;\n+    __ AssertNotSmi(r2);\n+    __ ldr(scratch, FieldMemOperand(r2, HeapObject::kMapOffset));\n+    __ ldrh(r6, FieldMemOperand(scratch, Map::kInstanceTypeOffset));\n+    __ cmp(r6, Operand(FIXED_ARRAY_TYPE));\n+    __ b(eq, &ok);\n+    __ cmp(r6, Operand(FIXED_DOUBLE_ARRAY_TYPE));\n+    __ b(ne, &fail);\n+    __ cmp(r4, Operand(0));\n+    __ b(eq, &ok);\n+    // Fall through.\n+    __ bind(&fail);\n+    __ Abort(AbortReason::kOperandIsNotAFixedArray);\n+\n+    __ bind(&ok);\n+  }\n+\n   // Check for stack overflow.\n   {\n     // Check the stack for overflow. We are not trying to catch interruptions\n@@ -1977,8 +1679,8 @@ void Builtins::Generate_CallOrConstructForwardVarargs(MacroAssembler* masm,\n   {\n     __ ldr(r5, MemOperand(fp, JavaScriptFrameConstants::kFunctionOffset));\n     __ ldr(r5, FieldMemOperand(r5, JSFunction::kSharedFunctionInfoOffset));\n-    __ ldr(r5, FieldMemOperand(\n-                   r5, SharedFunctionInfo::kFormalParameterCountOffset));\n+    __ ldrh(r5, FieldMemOperand(\n+                    r5, SharedFunctionInfo::kFormalParameterCountOffset));\n     __ mov(r4, fp);\n   }\n   __ b(&arguments_done);\n@@ -2108,8 +1810,8 @@ void Builtins::Generate_CallFunction(MacroAssembler* masm,\n   //  -- cp : the function context.\n   // -----------------------------------\n \n-  __ ldr(r2,\n-         FieldMemOperand(r2, SharedFunctionInfo::kFormalParameterCountOffset));\n+  __ ldrh(r2,\n+          FieldMemOperand(r2, SharedFunctionInfo::kFormalParameterCountOffset));\n   ParameterCount actual(r0);\n   ParameterCount expected(r2);\n   __ InvokeFunctionCode(r1, no_reg, expected, actual, JUMP_FUNCTION);\n@@ -2378,42 +2080,6 @@ void Builtins::Generate_Construct(MacroAssembler* masm) {\n           RelocInfo::CODE_TARGET);\n }\n \n-// static\n-void Builtins::Generate_AllocateInNewSpace(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- r1 : requested object size (untagged)\n-  //  -- lr : return address\n-  // -----------------------------------\n-  __ SmiTag(r1);\n-  __ Push(r1);\n-  __ Move(cp, Smi::kZero);\n-  __ TailCallRuntime(Runtime::kAllocateInNewSpace);\n-}\n-\n-// static\n-void Builtins::Generate_AllocateInOldSpace(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- r1 : requested object size (untagged)\n-  //  -- lr : return address\n-  // -----------------------------------\n-  __ SmiTag(r1);\n-  __ Move(r2, Smi::FromInt(AllocateTargetSpace::encode(OLD_SPACE)));\n-  __ Push(r1, r2);\n-  __ Move(cp, Smi::kZero);\n-  __ TailCallRuntime(Runtime::kAllocateInTargetSpace);\n-}\n-\n-// static\n-void Builtins::Generate_Abort(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- r1 : message_id as Smi\n-  //  -- lr : return address\n-  // -----------------------------------\n-  __ Push(r1);\n-  __ Move(cp, Smi::kZero);\n-  __ TailCallRuntime(Runtime::kAbort);\n-}\n-\n void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- r0 : actual number of arguments\n@@ -2425,10 +2091,10 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   Label invoke, dont_adapt_arguments, stack_overflow;\n \n   Label enough, too_few;\n-  __ cmp(r0, r2);\n-  __ b(lt, &too_few);\n   __ cmp(r2, Operand(SharedFunctionInfo::kDontAdaptArgumentsSentinel));\n   __ b(eq, &dont_adapt_arguments);\n+  __ cmp(r0, r2);\n+  __ b(lt, &too_few);\n \n   Register scratch = r5;\n \n@@ -2547,29 +2213,36 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n }\n \n void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {\n+  // The function index was put in r4 by the jump table trampoline.\n+  // Convert to Smi for the runtime call.\n+  __ SmiTag(r4, r4);\n   {\n-    FrameAndConstantPoolScope scope(masm, StackFrame::INTERNAL);\n+    TrapOnAbortScope trap_on_abort_scope(masm);  // Avoid calls to Abort.\n+    FrameAndConstantPoolScope scope(masm, StackFrame::WASM_COMPILE_LAZY);\n \n     // Save all parameter registers (see wasm-linkage.cc). They might be\n     // overwritten in the runtime call below. We don't have any callee-saved\n     // registers in wasm, so no need to store anything else.\n-    constexpr RegList gp_regs = Register::ListOf<r0, r1, r2>();\n+    constexpr RegList gp_regs = Register::ListOf<r0, r1, r2, r3>();\n     constexpr DwVfpRegister lowest_fp_reg = d0;\n     constexpr DwVfpRegister highest_fp_reg = d7;\n \n     __ stm(db_w, sp, gp_regs);\n     __ vstm(db_w, sp, lowest_fp_reg, highest_fp_reg);\n \n-    // Pass the WASM instance as an explicit argument to WasmCompileLazy.\n+    // Pass instance and function index as explicit arguments to the runtime\n+    // function.\n     __ push(kWasmInstanceRegister);\n+    __ push(r4);\n+    // Load the correct CEntry builtin from the instance object.\n+    __ ldr(r2, FieldMemOperand(kWasmInstanceRegister,\n+                               WasmInstanceObject::kCEntryStubOffset));\n     // Initialize the JavaScript context with 0. CEntry will use it to\n     // set the current context on the isolate.\n     __ Move(cp, Smi::kZero);\n-    __ CallRuntime(Runtime::kWasmCompileLazy);\n-    // The entrypoint address is the first return value.\n+    __ CallRuntimeWithCEntry(Runtime::kWasmCompileLazy, r2);\n+    // The entrypoint address is the return value.\n     __ mov(r8, kReturnRegister0);\n-    // The WASM instance is the second return value.\n-    __ mov(kWasmInstanceRegister, kReturnRegister1);\n \n     // Restore registers.\n     __ vldm(ia_w, sp, lowest_fp_reg, highest_fp_reg);\n@@ -2741,6 +2414,7 @@ void Builtins::Generate_CEntry(MacroAssembler* masm, int result_size,\n void Builtins::Generate_DoubleToI(MacroAssembler* masm) {\n   Label negate, done;\n \n+  TrapOnAbortScope trap_on_abort_scope(masm);  // Avoid calls to Abort.\n   UseScratchRegisterScope temps(masm);\n   Register result_reg = r7;\n   Register double_low = GetRegisterThatIsNotOneOf(result_reg);\n@@ -2832,20 +2506,20 @@ void Builtins::Generate_DoubleToI(MacroAssembler* masm) {\n }\n \n void Builtins::Generate_MathPowInternal(MacroAssembler* masm) {\n-  const Register exponent = MathPowTaggedDescriptor::exponent();\n-  DCHECK(exponent == r2);\n   const LowDwVfpRegister double_base = d0;\n   const LowDwVfpRegister double_exponent = d1;\n   const LowDwVfpRegister double_result = d2;\n   const LowDwVfpRegister double_scratch = d3;\n   const SwVfpRegister single_scratch = s6;\n-  const Register scratch = r9;\n-  const Register scratch2 = r4;\n+  // Avoid using Registers r0-r3 as they may be needed when calling to C if the\n+  // ABI is softfloat.\n+  const Register integer_exponent = r4;\n+  const Register scratch = r5;\n \n   Label call_runtime, done, int_exponent;\n \n   // Detect integer exponents stored as double.\n-  __ TryDoubleToInt32Exact(scratch, double_exponent, double_scratch);\n+  __ TryDoubleToInt32Exact(integer_exponent, double_exponent, double_scratch);\n   __ b(eq, &int_exponent);\n \n   __ push(lr);\n@@ -2862,16 +2536,13 @@ void Builtins::Generate_MathPowInternal(MacroAssembler* masm) {\n   // Calculate power with integer exponent.\n   __ bind(&int_exponent);\n \n-  // Get two copies of exponent in the registers scratch and exponent.\n-  // Exponent has previously been stored into scratch as untagged integer.\n-  __ mov(exponent, scratch);\n-\n   __ vmov(double_scratch, double_base);  // Back up base.\n-  __ vmov(double_result, Double(1.0), scratch2);\n+  __ vmov(double_result, Double(1.0), scratch);\n \n   // Get absolute value of exponent.\n-  __ cmp(scratch, Operand::Zero());\n-  __ rsb(scratch, scratch, Operand::Zero(), LeaveCC, mi);\n+  __ cmp(integer_exponent, Operand::Zero());\n+  __ mov(scratch, integer_exponent);\n+  __ rsb(scratch, integer_exponent, Operand::Zero(), LeaveCC, mi);\n \n   Label while_true;\n   __ bind(&while_true);\n@@ -2880,7 +2551,7 @@ void Builtins::Generate_MathPowInternal(MacroAssembler* masm) {\n   __ vmul(double_scratch, double_scratch, double_scratch, ne);\n   __ b(ne, &while_true);\n \n-  __ cmp(exponent, Operand::Zero());\n+  __ cmp(integer_exponent, Operand::Zero());\n   __ b(ge, &done);\n   __ vmov(double_scratch, Double(1.0), scratch);\n   __ vdiv(double_result, double_scratch, double_result);\n@@ -2890,7 +2561,7 @@ void Builtins::Generate_MathPowInternal(MacroAssembler* masm) {\n   __ b(ne, &done);\n   // double_exponent may not containe the exponent value if the input was a\n   // smi.  We set it with exponent value before bailing out.\n-  __ vmov(single_scratch, exponent);\n+  __ vmov(single_scratch, integer_exponent);\n   __ vcvt_f64_s32(double_exponent, single_scratch);\n \n   // Returning or bailing out.\n@@ -2908,6 +2579,88 @@ void Builtins::Generate_MathPowInternal(MacroAssembler* masm) {\n   __ Ret();\n }\n \n+namespace {\n+\n+void GenerateInternalArrayConstructorCase(MacroAssembler* masm,\n+                                          ElementsKind kind) {\n+  __ cmp(r0, Operand(1));\n+\n+  __ Jump(CodeFactory::InternalArrayNoArgumentConstructor(masm->isolate(), kind)\n+              .code(),\n+          RelocInfo::CODE_TARGET, lo);\n+\n+  Handle<Code> code = BUILTIN_CODE(masm->isolate(), ArrayNArgumentsConstructor);\n+  __ Jump(code, RelocInfo::CODE_TARGET, hi);\n+\n+  if (IsFastPackedElementsKind(kind)) {\n+    // We might need to create a holey array\n+    // look at the first argument\n+    __ ldr(r3, MemOperand(sp, 0));\n+    __ cmp(r3, Operand::Zero());\n+\n+    __ Jump(CodeFactory::InternalArraySingleArgumentConstructor(\n+                masm->isolate(), GetHoleyElementsKind(kind))\n+                .code(),\n+            RelocInfo::CODE_TARGET, ne);\n+  }\n+\n+  __ Jump(\n+      CodeFactory::InternalArraySingleArgumentConstructor(masm->isolate(), kind)\n+          .code(),\n+      RelocInfo::CODE_TARGET);\n+}\n+\n+}  // namespace\n+\n+void Builtins::Generate_InternalArrayConstructorImpl(MacroAssembler* masm) {\n+  // ----------- S t a t e -------------\n+  //  -- r0 : argc\n+  //  -- r1 : constructor\n+  //  -- sp[0] : return address\n+  //  -- sp[4] : last argument\n+  // -----------------------------------\n+\n+  if (FLAG_debug_code) {\n+    // The array construct code is only set for the global and natives\n+    // builtin Array functions which always have maps.\n+\n+    // Initial map for the builtin Array function should be a map.\n+    __ ldr(r3, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n+    // Will both indicate a nullptr and a Smi.\n+    __ tst(r3, Operand(kSmiTagMask));\n+    __ Assert(ne, AbortReason::kUnexpectedInitialMapForArrayFunction);\n+    __ CompareObjectType(r3, r3, r4, MAP_TYPE);\n+    __ Assert(eq, AbortReason::kUnexpectedInitialMapForArrayFunction);\n+  }\n+\n+  // Figure out the right elements kind\n+  __ ldr(r3, FieldMemOperand(r1, JSFunction::kPrototypeOrInitialMapOffset));\n+  // Load the map's \"bit field 2\" into |result|. We only need the first byte,\n+  // but the following bit field extraction takes care of that anyway.\n+  __ ldr(r3, FieldMemOperand(r3, Map::kBitField2Offset));\n+  // Retrieve elements_kind from bit field 2.\n+  __ DecodeField<Map::ElementsKindBits>(r3);\n+\n+  if (FLAG_debug_code) {\n+    Label done;\n+    __ cmp(r3, Operand(PACKED_ELEMENTS));\n+    __ b(eq, &done);\n+    __ cmp(r3, Operand(HOLEY_ELEMENTS));\n+    __ Assert(\n+        eq,\n+        AbortReason::kInvalidElementsKindForInternalArrayOrInternalPackedArray);\n+    __ bind(&done);\n+  }\n+\n+  Label fast_elements_case;\n+  __ cmp(r3, Operand(PACKED_ELEMENTS));\n+  __ b(eq, &fast_elements_case);\n+  GenerateInternalArrayConstructorCase(masm, HOLEY_ELEMENTS);\n+\n+  __ bind(&fast_elements_case);\n+  GenerateInternalArrayConstructorCase(masm, PACKED_ELEMENTS);\n+}\n+\n #undef __\n \n }  // namespace internal"
        },
        {
            "sha": "2254f010c13dc0b30fcd251086daafefc6b8e8ac",
            "filename": "deps/v8/src/builtins/arm64/builtins-arm64.cc",
            "status": "modified",
            "additions": 170,
            "deletions": 425,
            "changes": 595,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm64%2Fbuiltins-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm64%2Fbuiltins-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Farm64%2Fbuiltins-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -22,7 +22,7 @@ namespace internal {\n \n void Builtins::Generate_Adaptor(MacroAssembler* masm, Address address,\n                                 ExitFrameType exit_frame_type) {\n-  __ Mov(x5, ExternalReference::Create(address));\n+  __ Mov(kJavaScriptCallExtraArg1Register, ExternalReference::Create(address));\n   if (exit_frame_type == BUILTIN_EXIT) {\n     __ Jump(BUILTIN_CODE(masm->isolate(), AdaptorWithBuiltinExitFrame),\n             RelocInfo::CODE_TARGET);\n@@ -33,57 +33,6 @@ void Builtins::Generate_Adaptor(MacroAssembler* masm, Address address,\n   }\n }\n \n-namespace {\n-\n-void AdaptorWithExitFrameType(MacroAssembler* masm,\n-                              Builtins::ExitFrameType exit_frame_type) {\n-  // ----------- S t a t e -------------\n-  //  -- x0                 : number of arguments excluding receiver\n-  //  -- x1                 : target\n-  //  -- x3                 : new target\n-  //  -- x5                 : entry point\n-  //  -- sp[0]              : last argument\n-  //  -- ...\n-  //  -- sp[4 * (argc - 1)] : first argument\n-  //  -- sp[4 * argc]       : receiver\n-  // -----------------------------------\n-  __ AssertFunction(x1);\n-\n-  // Make sure we operate in the context of the called function (for example\n-  // ConstructStubs implemented in C++ will be run in the context of the caller\n-  // instead of the callee, due to the way that [[Construct]] is defined for\n-  // ordinary functions).\n-  __ Ldr(cp, FieldMemOperand(x1, JSFunction::kContextOffset));\n-\n-  // CEntry expects x0 to contain the number of arguments including the\n-  // receiver and the extra arguments.\n-  __ Add(x0, x0, BuiltinExitFrameConstants::kNumExtraArgsWithReceiver);\n-\n-  // Insert extra arguments.\n-  Register padding = x10;\n-  __ LoadRoot(padding, Heap::kTheHoleValueRootIndex);\n-  __ SmiTag(x11, x0);\n-  __ Push(padding, x11, x1, x3);\n-\n-  // Jump to the C entry runtime stub directly here instead of using\n-  // JumpToExternalReference. We have already loaded entry point to x5\n-  // in Generate_adaptor.\n-  __ Mov(x1, x5);\n-  Handle<Code> code =\n-      CodeFactory::CEntry(masm->isolate(), 1, kDontSaveFPRegs, kArgvOnStack,\n-                          exit_frame_type == Builtins::BUILTIN_EXIT);\n-  __ Jump(code, RelocInfo::CODE_TARGET);\n-}\n-}  // namespace\n-\n-void Builtins::Generate_AdaptorWithExitFrame(MacroAssembler* masm) {\n-  AdaptorWithExitFrameType(masm, EXIT);\n-}\n-\n-void Builtins::Generate_AdaptorWithBuiltinExitFrame(MacroAssembler* masm) {\n-  AdaptorWithExitFrameType(masm, BUILTIN_EXIT);\n-}\n-\n void Builtins::Generate_InternalArrayConstructor(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- x0     : number of arguments\n@@ -105,39 +54,8 @@ void Builtins::Generate_InternalArrayConstructor(MacroAssembler* masm) {\n   // Run the native code for the InternalArray function called as a normal\n   // function.\n   __ LoadRoot(x2, Heap::kUndefinedValueRootIndex);\n-  InternalArrayConstructorStub stub(masm->isolate());\n-  __ TailCallStub(&stub);\n-}\n-\n-void Builtins::Generate_ArrayConstructor(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- x0     : number of arguments\n-  //  -- x1     : array function\n-  //  -- lr     : return address\n-  //  -- sp[...]: constructor arguments\n-  // -----------------------------------\n-  ASM_LOCATION(\"Builtins::Generate_ArrayConstructor\");\n-  Label generic_array_code, one_or_more_arguments, two_or_more_arguments;\n-\n-  if (FLAG_debug_code) {\n-    // Initial map for the builtin Array functions should be maps.\n-    __ Ldr(x10, FieldMemOperand(x1, JSFunction::kPrototypeOrInitialMapOffset));\n-    __ Tst(x10, kSmiTagMask);\n-    __ Assert(ne, AbortReason::kUnexpectedInitialMapForArrayFunction);\n-    __ CompareObjectType(x10, x11, x12, MAP_TYPE);\n-    __ Assert(eq, AbortReason::kUnexpectedInitialMapForArrayFunction);\n-  }\n-\n-  // x2 is the AllocationSite - here undefined.\n-  __ LoadRoot(x2, Heap::kUndefinedValueRootIndex);\n-  // If x3 (new target) is undefined, then this is the 'Call' case, so move\n-  // x1 (the constructor) to x3.\n-  __ Cmp(x3, x2);\n-  __ CmovX(x3, x1, eq);\n-\n-  // Run the native code for the Array function called as a normal function.\n-  ArrayConstructorStub stub(masm->isolate());\n-  __ TailCallStub(&stub);\n+  __ Jump(BUILTIN_CODE(masm->isolate(), InternalArrayConstructorImpl),\n+          RelocInfo::CODE_TARGET);\n }\n \n static void GenerateTailCallToReturnedCode(MacroAssembler* masm,\n@@ -266,8 +184,7 @@ void Generate_JSBuiltinsConstructStubHelper(MacroAssembler* masm) {\n     // Restore smi-tagged arguments count from the frame. Use fp relative\n     // addressing to avoid the circular dependency between padding existence and\n     // argc parity.\n-    __ Ldrsw(x1,\n-             UntagSmiMemOperand(fp, ConstructFrameConstants::kLengthOffset));\n+    __ SmiUntag(x1, MemOperand(fp, ConstructFrameConstants::kLengthOffset));\n     // Leave construct frame.\n   }\n \n@@ -351,8 +268,7 @@ void Builtins::Generate_JSConstructStubGeneric(MacroAssembler* masm) {\n \n     // Restore constructor function and argument count.\n     __ Ldr(x1, MemOperand(fp, ConstructFrameConstants::kConstructorOffset));\n-    __ Ldrsw(x12,\n-             UntagSmiMemOperand(fp, ConstructFrameConstants::kLengthOffset));\n+    __ SmiUntag(x12, MemOperand(fp, ConstructFrameConstants::kLengthOffset));\n \n     // Copy arguments to the expression stack. The called function pops the\n     // receiver along with its arguments, so we need an extra receiver on the\n@@ -451,8 +367,7 @@ void Builtins::Generate_JSConstructStubGeneric(MacroAssembler* masm) {\n \n     __ Bind(&leave_frame);\n     // Restore smi-tagged arguments count from the frame.\n-    __ Ldrsw(x1,\n-             UntagSmiMemOperand(fp, ConstructFrameConstants::kLengthOffset));\n+    __ SmiUntag(x1, MemOperand(fp, ConstructFrameConstants::kLengthOffset));\n     // Leave construct frame.\n   }\n   // Remove caller arguments from the stack and return.\n@@ -513,8 +428,8 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n \n   // Get number of arguments for generator function.\n   __ Ldr(x10, FieldMemOperand(x4, JSFunction::kSharedFunctionInfoOffset));\n-  __ Ldr(w10,\n-         FieldMemOperand(x10, SharedFunctionInfo::kFormalParameterCountOffset));\n+  __ Ldrh(w10, FieldMemOperand(\n+                   x10, SharedFunctionInfo::kFormalParameterCountOffset));\n \n   // Claim slots for arguments and receiver (rounded up to a multiple of two).\n   __ Add(x11, x10, 2);\n@@ -539,18 +454,21 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n   //  -- sp[0 .. arg count - 1]   : claimed for args\n   // -----------------------------------\n \n-  // Push holes for arguments to generator function. Since the parser forced\n-  // context allocation for any variables in generators, the actual argument\n-  // values have already been copied into the context and these dummy values\n-  // will never be used.\n+  // Copy the function arguments from the generator object's register file.\n+\n+  __ Ldr(x5,\n+         FieldMemOperand(x1, JSGeneratorObject::kParametersAndRegistersOffset));\n   {\n     Label loop, done;\n     __ Cbz(x10, &done);\n-    __ LoadRoot(x11, Heap::kTheHoleValueRootIndex);\n+    __ Mov(x12, 0);\n \n     __ Bind(&loop);\n     __ Sub(x10, x10, 1);\n+    __ Add(x11, x5, Operand(x12, LSL, kPointerSizeLog2));\n+    __ Ldr(x11, FieldMemOperand(x11, FixedArray::kHeaderSize));\n     __ Poke(x11, Operand(x10, LSL, kPointerSizeLog2));\n+    __ Add(x12, x12, 1);\n     __ Cbnz(x10, &loop);\n     __ Bind(&done);\n   }\n@@ -571,8 +489,8 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {\n   // Resume (Ignition/TurboFan) generator object.\n   {\n     __ Ldr(x0, FieldMemOperand(x4, JSFunction::kSharedFunctionInfoOffset));\n-    __ Ldr(w0, FieldMemOperand(\n-                   x0, SharedFunctionInfo::kFormalParameterCountOffset));\n+    __ Ldrh(w0, FieldMemOperand(\n+                    x0, SharedFunctionInfo::kFormalParameterCountOffset));\n     // We abuse new.target both to indicate that this is a resume call and to\n     // pass in the generator object.  In ordinary calls, new.target is always\n     // undefined because generator functions are non-constructable.\n@@ -983,10 +901,9 @@ void Builtins::Generate_InterpreterEntryTrampoline(MacroAssembler* masm) {\n   __ Push(lr, fp, cp, closure);\n   __ Add(fp, sp, StandardFrameConstants::kFixedFrameSizeFromFp);\n \n-  // Get the bytecode array from the function object (or from the DebugInfo if\n-  // it is present) and load it into kInterpreterBytecodeArrayRegister.\n-  Label maybe_load_debug_bytecode_array, bytecode_array_loaded,\n-      has_bytecode_array;\n+  // Get the bytecode array from the function object and load it into\n+  // kInterpreterBytecodeArrayRegister.\n+  Label has_bytecode_array;\n   __ Ldr(x0, FieldMemOperand(closure, JSFunction::kSharedFunctionInfoOffset));\n   __ Ldr(kInterpreterBytecodeArrayRegister,\n          FieldMemOperand(x0, SharedFunctionInfo::kFunctionDataOffset));\n@@ -997,9 +914,6 @@ void Builtins::Generate_InterpreterEntryTrampoline(MacroAssembler* masm) {\n          FieldMemOperand(kInterpreterBytecodeArrayRegister,\n                          InterpreterData::kBytecodeArrayOffset));\n   __ Bind(&has_bytecode_array);\n-  __ Ldr(x11, FieldMemOperand(x0, SharedFunctionInfo::kDebugInfoOffset));\n-  __ JumpIfNotSmi(x11, &maybe_load_debug_bytecode_array);\n-  __ Bind(&bytecode_array_loaded);\n \n   // Increment invocation count for the function.\n   __ Ldr(x11, FieldMemOperand(closure, JSFunction::kFeedbackCellOffset));\n@@ -1112,31 +1026,6 @@ void Builtins::Generate_InterpreterEntryTrampoline(MacroAssembler* masm) {\n   // The return value is in x0.\n   LeaveInterpreterFrame(masm, x2);\n   __ Ret();\n-\n-  // Load debug copy of the bytecode array if it exists.\n-  // kInterpreterBytecodeArrayRegister is already loaded with\n-  // SharedFunctionInfo::kFunctionDataOffset.\n-  __ Bind(&maybe_load_debug_bytecode_array);\n-  __ Ldr(x10, FieldMemOperand(x11, DebugInfo::kDebugBytecodeArrayOffset));\n-  __ JumpIfRoot(x10, Heap::kUndefinedValueRootIndex, &bytecode_array_loaded);\n-\n-  __ Mov(kInterpreterBytecodeArrayRegister, x10);\n-  __ Ldr(x10, UntagSmiFieldMemOperand(x11, DebugInfo::kFlagsOffset));\n-  __ And(x10, x10, Immediate(DebugInfo::kDebugExecutionMode));\n-\n-  STATIC_ASSERT(static_cast<int>(DebugInfo::kDebugExecutionMode) ==\n-                static_cast<int>(DebugInfo::kSideEffects));\n-  ExternalReference debug_execution_mode =\n-      ExternalReference::debug_execution_mode_address(masm->isolate());\n-  __ Mov(x11, Operand(debug_execution_mode));\n-  __ Ldrsb(x11, MemOperand(x11));\n-  __ CompareAndBranch(x10, x11, eq, &bytecode_array_loaded);\n-\n-  __ Push(closure, feedback_vector);\n-  __ PushArgument(closure);\n-  __ CallRuntime(Runtime::kDebugApplyInstrumentation);\n-  __ Pop(feedback_vector, closure);\n-  __ jmp(&bytecode_array_loaded);\n }\n \n static void Generate_InterpreterPushArgs(MacroAssembler* masm,\n@@ -1274,8 +1163,8 @@ void Builtins::Generate_InterpreterPushArgsThenConstructImpl(\n \n     // Tail call to the array construct stub (still in the caller\n     // context at this point).\n-    ArrayConstructorStub array_constructor_stub(masm->isolate());\n-    __ Jump(array_constructor_stub.GetCode(), RelocInfo::CODE_TARGET);\n+    Handle<Code> code = BUILTIN_CODE(masm->isolate(), ArrayConstructorImpl);\n+    __ Jump(code, RelocInfo::CODE_TARGET);\n   } else if (mode == InterpreterPushArgsMode::kWithFinalSpread) {\n     // Call the constructor with x0, x1, and x3 unmodified.\n     __ Jump(BUILTIN_CODE(masm->isolate(), ConstructWithSpread),\n@@ -1383,209 +1272,6 @@ void Builtins::Generate_InterpreterEnterBytecodeDispatch(MacroAssembler* masm) {\n   Generate_InterpreterEnterBytecode(masm);\n }\n \n-void Builtins::Generate_CompileLazyDeoptimizedCode(MacroAssembler* masm) {\n-  // Set the code slot inside the JSFunction to CompileLazy.\n-  __ Move(x2, BUILTIN_CODE(masm->isolate(), CompileLazy));\n-  __ Str(x2, FieldMemOperand(x1, JSFunction::kCodeOffset));\n-  __ RecordWriteField(x1, JSFunction::kCodeOffset, x2, x5, kLRHasNotBeenSaved,\n-                      kDontSaveFPRegs, OMIT_REMEMBERED_SET, OMIT_SMI_CHECK);\n-  // Jump to compile lazy.\n-  Generate_CompileLazy(masm);\n-}\n-\n-static void GetSharedFunctionInfoCode(MacroAssembler* masm, Register sfi_data,\n-                                      Register scratch1) {\n-  // Figure out the SFI's code object.\n-  Label done;\n-  Label check_is_bytecode_array;\n-  Label check_is_exported_function_data;\n-  Label check_is_fixed_array;\n-  Label check_is_pre_parsed_scope_data;\n-  Label check_is_function_template_info;\n-  Label check_is_interpreter_data;\n-\n-  Register data_type = scratch1;\n-\n-  // IsSmi: Is builtin\n-  __ JumpIfNotSmi(sfi_data, &check_is_bytecode_array);\n-  __ Mov(scratch1, ExternalReference::builtins_address(masm->isolate()));\n-  __ Mov(sfi_data, Operand::UntagSmiAndScale(sfi_data, kPointerSizeLog2));\n-  __ Ldr(sfi_data, MemOperand(scratch1, sfi_data));\n-  __ B(&done);\n-\n-  // Get map for subsequent checks.\n-  __ Bind(&check_is_bytecode_array);\n-  __ Ldr(data_type, FieldMemOperand(sfi_data, HeapObject::kMapOffset));\n-  __ Ldrh(data_type, FieldMemOperand(data_type, Map::kInstanceTypeOffset));\n-\n-  // IsBytecodeArray: Interpret bytecode\n-  __ Cmp(data_type, Operand(BYTECODE_ARRAY_TYPE));\n-  __ B(ne, &check_is_exported_function_data);\n-  __ Move(sfi_data, BUILTIN_CODE(masm->isolate(), InterpreterEntryTrampoline));\n-  __ B(&done);\n-\n-  // IsWasmExportedFunctionData: Use the wrapper code\n-  __ Bind(&check_is_exported_function_data);\n-  __ Cmp(data_type, Operand(WASM_EXPORTED_FUNCTION_DATA_TYPE));\n-  __ B(ne, &check_is_fixed_array);\n-  __ Ldr(sfi_data, FieldMemOperand(\n-                       sfi_data, WasmExportedFunctionData::kWrapperCodeOffset));\n-  __ B(&done);\n-\n-  // IsFixedArray: Instantiate using AsmWasmData\n-  __ Bind(&check_is_fixed_array);\n-  __ Cmp(data_type, Operand(FIXED_ARRAY_TYPE));\n-  __ B(ne, &check_is_pre_parsed_scope_data);\n-  __ Move(sfi_data, BUILTIN_CODE(masm->isolate(), InstantiateAsmJs));\n-  __ B(&done);\n-\n-  // IsPreParsedScopeData: Compile lazy\n-  __ Bind(&check_is_pre_parsed_scope_data);\n-  __ Cmp(data_type, Operand(TUPLE2_TYPE));\n-  __ B(ne, &check_is_function_template_info);\n-  __ Move(sfi_data, BUILTIN_CODE(masm->isolate(), CompileLazy));\n-  __ B(&done);\n-\n-  // IsFunctionTemplateInfo: API call\n-  __ Bind(&check_is_function_template_info);\n-  __ Cmp(data_type, Operand(FUNCTION_TEMPLATE_INFO_TYPE));\n-  __ B(ne, &check_is_interpreter_data);\n-  __ Move(sfi_data, BUILTIN_CODE(masm->isolate(), HandleApiCall));\n-  __ B(&done);\n-\n-  // IsInterpreterData: Interpret bytecode\n-  __ Bind(&check_is_interpreter_data);\n-  if (FLAG_debug_code) {\n-    __ Cmp(data_type, Operand(INTERPRETER_DATA_TYPE));\n-    __ Assert(eq, AbortReason::kInvalidSharedFunctionInfoData);\n-  }\n-  __ Ldr(\n-      sfi_data,\n-      FieldMemOperand(sfi_data, InterpreterData::kInterpreterTrampolineOffset));\n-\n-  __ Bind(&done);\n-}\n-\n-void Builtins::Generate_CompileLazy(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- x0 : argument count (preserved for callee)\n-  //  -- x3 : new target (preserved for callee)\n-  //  -- x1 : target function (preserved for callee)\n-  // -----------------------------------\n-  // First lookup code, maybe we don't need to compile!\n-  Label gotta_call_runtime;\n-\n-  Register closure = x1;\n-  Register feedback_vector = x2;\n-\n-  // Do we have a valid feedback vector?\n-  __ Ldr(feedback_vector,\n-         FieldMemOperand(closure, JSFunction::kFeedbackCellOffset));\n-  __ Ldr(feedback_vector, FieldMemOperand(feedback_vector, Cell::kValueOffset));\n-  __ JumpIfRoot(feedback_vector, Heap::kUndefinedValueRootIndex,\n-                &gotta_call_runtime);\n-\n-  // Is there an optimization marker or optimized code in the feedback vector?\n-  MaybeTailCallOptimizedCodeSlot(masm, feedback_vector, x7, x4, x5);\n-\n-  // We found no optimized code. Infer the code object needed for the SFI.\n-  Register entry = x7;\n-  __ Ldr(entry,\n-         FieldMemOperand(closure, JSFunction::kSharedFunctionInfoOffset));\n-  __ Ldr(entry,\n-         FieldMemOperand(entry, SharedFunctionInfo::kFunctionDataOffset));\n-  GetSharedFunctionInfoCode(masm, entry, x5);\n-\n-  // If code entry points to anything other than CompileLazy, install that.\n-  __ Move(x5, masm->CodeObject());\n-  __ Cmp(entry, x5);\n-  __ B(eq, &gotta_call_runtime);\n-\n-  // Install the SFI's code entry.\n-  __ Str(entry, FieldMemOperand(closure, JSFunction::kCodeOffset));\n-  __ Mov(x10, entry);  // Write barrier clobbers x10 below.\n-  __ RecordWriteField(closure, JSFunction::kCodeOffset, x10, x5,\n-                      kLRHasNotBeenSaved, kDontSaveFPRegs, OMIT_REMEMBERED_SET,\n-                      OMIT_SMI_CHECK);\n-  __ Add(entry, entry, Operand(Code::kHeaderSize - kHeapObjectTag));\n-  __ Jump(entry);\n-\n-  __ Bind(&gotta_call_runtime);\n-  GenerateTailCallToReturnedCode(masm, Runtime::kCompileLazy);\n-}\n-\n-// Lazy deserialization design doc: http://goo.gl/dxkYDZ.\n-void Builtins::Generate_DeserializeLazy(MacroAssembler* masm) {\n-  // ----------- S t a t e -------------\n-  //  -- x0 : argument count (preserved for callee)\n-  //  -- x3 : new target (preserved for callee)\n-  //  -- x1 : target function (preserved for callee)\n-  // -----------------------------------\n-\n-  Label deserialize_in_runtime;\n-\n-  Register target = x1;  // Must be preserved\n-  Register scratch0 = x2;\n-  Register scratch1 = x4;\n-\n-  CHECK(!scratch0.is(x0) && !scratch0.is(x3) && !scratch0.is(x1));\n-  CHECK(!scratch1.is(x0) && !scratch1.is(x3) && !scratch1.is(x1));\n-  CHECK(!scratch0.is(scratch1));\n-\n-  // Load the builtin id for lazy deserialization from SharedFunctionInfo.\n-\n-  __ AssertFunction(target);\n-  __ Ldr(scratch0,\n-         FieldMemOperand(target, JSFunction::kSharedFunctionInfoOffset));\n-\n-  __ Ldr(scratch1,\n-         FieldMemOperand(scratch0, SharedFunctionInfo::kFunctionDataOffset));\n-  __ AssertSmi(scratch1);\n-\n-  // The builtin may already have been deserialized. If that is the case, it is\n-  // stored in the builtins table, and we can copy to correct code object to\n-  // both the shared function info and function without calling into runtime.\n-  //\n-  // Otherwise, we need to call into runtime to deserialize.\n-\n-  {\n-    // Load the code object at builtins_table[builtin_id] into scratch1.\n-\n-    __ SmiUntag(scratch1);\n-    __ Mov(scratch0, ExternalReference::builtins_address(masm->isolate()));\n-    __ Ldr(scratch1, MemOperand(scratch0, scratch1, LSL, kPointerSizeLog2));\n-\n-    // Check if the loaded code object has already been deserialized. This is\n-    // the case iff it does not equal DeserializeLazy.\n-\n-    __ Move(scratch0, masm->CodeObject());\n-    __ Cmp(scratch1, scratch0);\n-    __ B(eq, &deserialize_in_runtime);\n-  }\n-\n-  {\n-    // If we've reached this spot, the target builtin has been deserialized and\n-    // we simply need to copy it over to the target function.\n-\n-    Register target_builtin = scratch1;\n-\n-    __ Str(target_builtin, FieldMemOperand(target, JSFunction::kCodeOffset));\n-    __ Mov(x9, target_builtin);  // Write barrier clobbers x9 below.\n-    __ RecordWriteField(target, JSFunction::kCodeOffset, x9, x5,\n-                        kLRHasNotBeenSaved, kDontSaveFPRegs,\n-                        OMIT_REMEMBERED_SET, OMIT_SMI_CHECK);\n-\n-    // All copying is done. Jump to the deserialized code object.\n-\n-    __ Add(target_builtin, target_builtin,\n-           Operand(Code::kHeaderSize - kHeapObjectTag));\n-    __ Jump(target_builtin);\n-  }\n-\n-  __ bind(&deserialize_in_runtime);\n-  GenerateTailCallToReturnedCode(masm, Runtime::kDeserializeLazy);\n-}\n-\n void Builtins::Generate_InstantiateAsmJs(MacroAssembler* masm) {\n   // ----------- S t a t e -------------\n   //  -- x0 : argument count (preserved for callee)\n@@ -1656,7 +1342,7 @@ void Builtins::Generate_InstantiateAsmJs(MacroAssembler* masm) {\n     __ JumpIfSmi(x0, &failed);\n \n     // Peek the argument count from the stack, untagging at the same time.\n-    __ Ldr(w4, UntagSmiMemOperand(sp, 3 * kPointerSize));\n+    __ SmiUntag(x4, MemOperand(sp, 3 * kPointerSize));\n     __ Drop(4);\n     scope.GenerateLeaveFrame();\n \n@@ -1800,9 +1486,9 @@ static void Generate_OnStackReplacementHelper(MacroAssembler* masm,\n \n   // Load the OSR entrypoint offset from the deoptimization data.\n   // <osr_offset> = <deopt_data>[#header_size + #osr_pc_offset]\n-  __ Ldrsw(w1, UntagSmiFieldMemOperand(\n-                   x1, FixedArray::OffsetOfElementAt(\n-                           DeoptimizationData::kOsrPcOffsetIndex)));\n+  __ SmiUntag(x1,\n+              FieldMemOperand(x1, FixedArray::OffsetOfElementAt(\n+                                      DeoptimizationData::kOsrPcOffsetIndex)));\n \n   // Compute the target address = code_obj + header_size + osr_offset\n   // <entry_addr> = <code_obj> + #header_size + <osr_offset>\n@@ -2222,7 +1908,24 @@ void Builtins::Generate_CallOrConstructVarargs(MacroAssembler* masm,\n   //  -- x4 : len (number of elements to push from args)\n   //  -- x3 : new.target (for [[Construct]])\n   // -----------------------------------\n-  __ AssertFixedArray(x2);\n+  if (masm->emit_debug_code()) {\n+    // Allow x2 to be a FixedArray, or a FixedDoubleArray if x4 == 0.\n+    Label ok, fail;\n+    __ AssertNotSmi(x2, AbortReason::kOperandIsNotAFixedArray);\n+    __ Ldr(x10, FieldMemOperand(x2, HeapObject::kMapOffset));\n+    __ Ldrh(x13, FieldMemOperand(x10, Map::kInstanceTypeOffset));\n+    __ Cmp(x13, FIXED_ARRAY_TYPE);\n+    __ B(eq, &ok);\n+    __ Cmp(x13, FIXED_DOUBLE_ARRAY_TYPE);\n+    __ B(ne, &fail);\n+    __ Cmp(x4, 0);\n+    __ B(eq, &ok);\n+    // Fall through.\n+    __ bind(&fail);\n+    __ Abort(AbortReason::kOperandIsNotAFixedArray);\n+\n+    __ bind(&ok);\n+  }\n \n   Register arguments_list = x2;\n   Register argc = x0;\n@@ -2328,18 +2031,18 @@ void Builtins::Generate_CallOrConstructForwardVarargs(MacroAssembler* masm,\n              MemOperand(fp, JavaScriptFrameConstants::kFunctionOffset));\n       __ Ldr(scratch,\n              FieldMemOperand(scratch, JSFunction::kSharedFunctionInfoOffset));\n-      __ Ldrsw(len,\n-               FieldMemOperand(\n-                   scratch, SharedFunctionInfo::kFormalParameterCountOffset));\n+      __ Ldrh(len,\n+              FieldMemOperand(scratch,\n+                              SharedFunctionInfo::kFormalParameterCountOffset));\n       __ Mov(args_fp, fp);\n     }\n     __ B(&arguments_done);\n     __ Bind(&arguments_adaptor);\n     {\n       // Just load the length from ArgumentsAdaptorFrame.\n-      __ Ldrsw(len,\n-               UntagSmiMemOperand(\n-                   args_fp, ArgumentsAdaptorFrameConstants::kLengthOffset));\n+      __ SmiUntag(\n+          len,\n+          MemOperand(args_fp, ArgumentsAdaptorFrameConstants::kLengthOffset));\n     }\n     __ Bind(&arguments_done);\n   }\n@@ -2455,8 +2158,8 @@ void Builtins::Generate_CallFunction(MacroAssembler* masm,\n   //  -- cp : the function context.\n   // -----------------------------------\n \n-  __ Ldrsw(\n-      x2, FieldMemOperand(x2, SharedFunctionInfo::kFormalParameterCountOffset));\n+  __ Ldrh(x2,\n+          FieldMemOperand(x2, SharedFunctionInfo::kFormalParameterCountOffset));\n   ParameterCount actual(x0);\n   ParameterCount expected(x2);\n   __ InvokeFunctionCode(x1, no_reg, expected, actual, JUMP_FUNCTION);\n@@ -2486,8 +2189,8 @@ void Generate_PushBoundArguments(MacroAssembler* masm) {\n   Label no_bound_arguments;\n   __ Ldr(bound_argv,\n          FieldMemOperand(x1, JSBoundFunction::kBoundArgumentsOffset));\n-  __ Ldrsw(bound_argc,\n-           UntagSmiFieldMemOperand(bound_argv, FixedArray::kLengthOffset));\n+  __ SmiUntag(bound_argc,\n+              FieldMemOperand(bound_argv, FixedArray::kLengthOffset));\n   __ Cbz(bound_argc, &no_bound_arguments);\n   {\n     // ----------- S t a t e -------------\n@@ -2774,46 +2477,6 @@ void Builtins::Generate_Construct(MacroAssembler* masm) {\n           RelocInfo::CODE_TARGET);\n }\n \n-// static\n-void Builtins::Generate_AllocateInNewSpace(MacroAssembler* masm) {\n-  ASM_LOCATION(\"Builtins::Generate_AllocateInNewSpace\");\n-  // ----------- S t a t e -------------\n-  //  -- x1 : requested object size (untagged)\n-  //  -- lr : return address\n-  // -----------------------------------\n-  __ SmiTag(x1);\n-  __ PushArgument(x1);\n-  __ Move(cp, Smi::kZero);\n-  __ TailCallRuntime(Runtime::kAllocateInNewSpace);\n-}\n-\n-// static\n-void Builtins::Generate_AllocateInOldSpace(MacroAssembler* masm) {\n-  ASM_LOCATION(\"Builtins::Generate_AllocateInOldSpace\");\n-  // ----------- S t a t e -------------\n-  //  -- x1 : requested object size (untagged)\n-  //  -- lr : return address\n-  // -----------------------------------\n-  __ SmiTag(x1);\n-  __ Move(x2, Smi::FromInt(AllocateTargetSpace::encode(OLD_SPACE)));\n-  __ Push(x1, x2);\n-  __ Move(cp, Smi::kZero);\n-  __ TailCallRuntime(Runtime::kAllocateInTargetSpace);\n-}\n-\n-// static\n-void Builtins::Generate_Abort(MacroAssembler* masm) {\n-  ASM_LOCATION(\"Builtins::Generate_Abort\");\n-  // ----------- S t a t e -------------\n-  //  -- x1 : message_id as Smi\n-  //  -- lr : return address\n-  // -----------------------------------\n-  MacroAssembler::NoUseRealAbortsScope no_use_real_aborts(masm);\n-  __ PushArgument(x1);\n-  __ Move(cp, Smi::kZero);\n-  __ TailCallRuntime(Runtime::kAbort);\n-}\n-\n void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n   ASM_LOCATION(\"Builtins::Generate_ArgumentsAdaptorTrampoline\");\n   // ----------- S t a t e -------------\n@@ -3007,32 +2670,38 @@ void Builtins::Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm) {\n }\n \n void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {\n+  // The function index was put in w8 by the jump table trampoline.\n+  // Sign extend and convert to Smi for the runtime call.\n+  __ sxtw(x8, w8);\n+  __ SmiTag(x8, x8);\n   {\n-    FrameScope scope(masm, StackFrame::INTERNAL);\n+    TrapOnAbortScope trap_on_abort_scope(masm);  // Avoid calls to Abort.\n+    FrameScope scope(masm, StackFrame::WASM_COMPILE_LAZY);\n \n     // Save all parameter registers (see wasm-linkage.cc). They might be\n     // overwritten in the runtime call below. We don't have any callee-saved\n     // registers in wasm, so no need to store anything else.\n-    constexpr RegList gp_regs = Register::ListOf<x0, x1, x2, x3, x4, x5>();\n+    constexpr RegList gp_regs =\n+        Register::ListOf<x0, x1, x2, x3, x4, x5, x6, x7>();\n     constexpr RegList fp_regs =\n         Register::ListOf<d0, d1, d2, d3, d4, d5, d6, d7>();\n     __ PushXRegList(gp_regs);\n     __ PushDRegList(fp_regs);\n-    __ Push(x5, x6);  // note: pushed twice because alignment required\n \n-    // Pass the WASM instance as an explicit argument to WasmCompileLazy.\n-    __ PushArgument(kWasmInstanceRegister);\n+    // Pass instance and function index as explicit arguments to the runtime\n+    // function.\n+    __ Push(kWasmInstanceRegister, x8);\n+    // Load the correct CEntry builtin from the instance object.\n+    __ Ldr(x2, FieldMemOperand(kWasmInstanceRegister,\n+                               WasmInstanceObject::kCEntryStubOffset));\n     // Initialize the JavaScript context with 0. CEntry will use it to\n     // set the current context on the isolate.\n     __ Move(cp, Smi::kZero);\n-    __ CallRuntime(Runtime::kWasmCompileLazy);\n-    // The entrypoint address is the first return value.\n+    __ CallRuntimeWithCEntry(Runtime::kWasmCompileLazy, x2);\n+    // The entrypoint address is the return value.\n     __ mov(x8, kReturnRegister0);\n-    // The WASM instance is the second return value.\n-    __ mov(kWasmInstanceRegister, kReturnRegister1);\n \n     // Restore registers.\n-    __ Pop(x6, x5);  // note: pushed twice because alignment required\n     __ PopDRegList(fp_regs);\n     __ PopXRegList(gp_regs);\n   }\n@@ -3268,6 +2937,7 @@ void Builtins::Generate_DoubleToI(MacroAssembler* masm) {\n \n   DCHECK(result.Is64Bits());\n \n+  TrapOnAbortScope trap_on_abort_scope(masm);  // Avoid calls to Abort.\n   UseScratchRegisterScope temps(masm);\n   Register scratch1 = temps.AcquireX();\n   Register scratch2 = temps.AcquireX();\n@@ -3329,16 +2999,7 @@ void Builtins::Generate_DoubleToI(MacroAssembler* masm) {\n }\n \n void Builtins::Generate_MathPowInternal(MacroAssembler* masm) {\n-  // Stack on entry:\n-  // sp[0]: Exponent (as a tagged value).\n-  // sp[1]: Base (as a tagged value).\n-  //\n-  // The (tagged) result will be returned in x0, as a heap number.\n-\n-  Register exponent_tagged = MathPowTaggedDescriptor::exponent();\n-  DCHECK(exponent_tagged.is(x11));\n-  Register exponent_integer = MathPowIntegerDescriptor::exponent();\n-  DCHECK(exponent_integer.is(x12));\n+  Register exponent_integer = x12;\n   Register saved_lr = x19;\n   VRegister result_double = d0;\n   VRegister base_double = d0;\n@@ -3348,7 +3009,7 @@ void Builtins::Generate_MathPowInternal(MacroAssembler* masm) {\n   VRegister scratch0_double = d7;\n \n   // A fast-path for integer exponents.\n-  Label exponent_is_smi, exponent_is_integer;\n+  Label exponent_is_integer;\n   // Allocate a heap number for the result, and return it.\n   Label done;\n \n@@ -3368,24 +3029,12 @@ void Builtins::Generate_MathPowInternal(MacroAssembler* masm) {\n     __ B(&done);\n   }\n \n-  // Handle SMI exponents.\n-  __ Bind(&exponent_is_smi);\n-  //  x10   base_tagged       The tagged base (input).\n-  //  x11   exponent_tagged   The tagged exponent (input).\n-  //  d1    base_double       The base as a double.\n-  __ SmiUntag(exponent_integer, exponent_tagged);\n-\n   __ Bind(&exponent_is_integer);\n-  //  x10   base_tagged       The tagged base (input).\n-  //  x11   exponent_tagged   The tagged exponent (input).\n-  //  x12   exponent_integer  The exponent as an integer.\n-  //  d1    base_double       The base as a double.\n \n   // Find abs(exponent). For negative exponents, we can find the inverse later.\n   Register exponent_abs = x13;\n   __ Cmp(exponent_integer, 0);\n   __ Cneg(exponent_abs, exponent_integer, mi);\n-  //  x13   exponent_abs      The value of abs(exponent_integer).\n \n   // Repeatedly multiply to calculate the power.\n   //  result = 1.0;\n@@ -3441,6 +3090,102 @@ void Builtins::Generate_MathPowInternal(MacroAssembler* masm) {\n   __ Ret();\n }\n \n+namespace {\n+\n+void GenerateInternalArrayConstructorCase(MacroAssembler* masm,\n+                                          ElementsKind kind) {\n+  Label zero_case, n_case;\n+  Register argc = x0;\n+\n+  __ Cbz(argc, &zero_case);\n+  __ CompareAndBranch(argc, 1, ne, &n_case);\n+\n+  // One argument.\n+  if (IsFastPackedElementsKind(kind)) {\n+    Label packed_case;\n+\n+    // We might need to create a holey array; look at the first argument.\n+    __ Peek(x10, 0);\n+    __ Cbz(x10, &packed_case);\n+\n+    __ Jump(CodeFactory::InternalArraySingleArgumentConstructor(\n+                masm->isolate(), GetHoleyElementsKind(kind))\n+                .code(),\n+            RelocInfo::CODE_TARGET);\n+\n+    __ Bind(&packed_case);\n+  }\n+\n+  __ Jump(\n+      CodeFactory::InternalArraySingleArgumentConstructor(masm->isolate(), kind)\n+          .code(),\n+      RelocInfo::CODE_TARGET);\n+\n+  __ Bind(&zero_case);\n+  // No arguments.\n+  __ Jump(CodeFactory::InternalArrayNoArgumentConstructor(masm->isolate(), kind)\n+              .code(),\n+          RelocInfo::CODE_TARGET);\n+\n+  __ Bind(&n_case);\n+  // N arguments.\n+  Handle<Code> code = BUILTIN_CODE(masm->isolate(), ArrayNArgumentsConstructor);\n+  __ Jump(code, RelocInfo::CODE_TARGET);\n+}\n+\n+}  // namespace\n+\n+void Builtins::Generate_InternalArrayConstructorImpl(MacroAssembler* masm) {\n+  // ----------- S t a t e -------------\n+  //  -- x0 : argc\n+  //  -- x1 : constructor\n+  //  -- sp[0] : return address\n+  //  -- sp[4] : last argument\n+  // -----------------------------------\n+\n+  Register constructor = x1;\n+\n+  if (FLAG_debug_code) {\n+    // The array construct code is only set for the global and natives\n+    // builtin Array functions which always have maps.\n+\n+    Label unexpected_map, map_ok;\n+    // Initial map for the builtin Array function should be a map.\n+    __ Ldr(x10, FieldMemOperand(constructor,\n+                                JSFunction::kPrototypeOrInitialMapOffset));\n+    // Will both indicate a nullptr and a Smi.\n+    __ JumpIfSmi(x10, &unexpected_map);\n+    __ JumpIfObjectType(x10, x10, x11, MAP_TYPE, &map_ok);\n+    __ Bind(&unexpected_map);\n+    __ Abort(AbortReason::kUnexpectedInitialMapForArrayFunction);\n+    __ Bind(&map_ok);\n+  }\n+\n+  Register kind = w3;\n+  // Figure out the right elements kind\n+  __ Ldr(x10, FieldMemOperand(constructor,\n+                              JSFunction::kPrototypeOrInitialMapOffset));\n+\n+  // Retrieve elements_kind from map.\n+  __ LoadElementsKindFromMap(kind, x10);\n+\n+  if (FLAG_debug_code) {\n+    Label done;\n+    __ Cmp(x3, PACKED_ELEMENTS);\n+    __ Ccmp(x3, HOLEY_ELEMENTS, ZFlag, ne);\n+    __ Assert(\n+        eq,\n+        AbortReason::kInvalidElementsKindForInternalArrayOrInternalPackedArray);\n+  }\n+\n+  Label fast_elements_case;\n+  __ CompareAndBranch(kind, PACKED_ELEMENTS, eq, &fast_elements_case);\n+  GenerateInternalArrayConstructorCase(masm, HOLEY_ELEMENTS);\n+\n+  __ Bind(&fast_elements_case);\n+  GenerateInternalArrayConstructorCase(masm, PACKED_ELEMENTS);\n+}\n+\n #undef __\n \n }  // namespace internal"
        },
        {
            "sha": "9919f9e3954ae3c3a09afc02caa65740bb527402",
            "filename": "deps/v8/src/builtins/array-foreach.tq",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray-foreach.tq",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray-foreach.tq",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray-foreach.tq?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2018 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+module array {\n+  macro ArrayForEachTorqueContinuation(\n+      context: Context, o: Object, len: Number, callbackfn: Callable,\n+      thisArg: Object, initial_k: Smi): Object {\n+    // 5. Let k be 0.\n+    // 6. Repeat, while k < len\n+    for (let k: Smi = initial_k; k < len; k = k + 1) {\n+      // 6a. Let Pk be ! ToString(k).\n+      let pK: String = ToString_Inline(context, k);\n+\n+      // 6b. Let kPresent be ? HasProperty(O, Pk).\n+      let kPresent: Oddball = HasPropertyObject(o, pK, context, kHasProperty);\n+\n+      // 6c. If kPresent is true, then\n+      if (kPresent == True) {\n+        // 6c. i. Let kValue be ? Get(O, Pk).\n+        let kValue: Object = GetProperty(context, o, pK);\n+\n+        // 6c. ii. Perform ? Call(callbackfn, T, <kValue, k, O>).\n+        Call(context, callbackfn, thisArg, kValue, k, o);\n+      }\n+\n+      // 6d. Increase k by 1. (done by the loop).\n+    }\n+    return Undefined;\n+  }\n+\n+  javascript builtin ArrayForEachLoopEagerDeoptContinuation(\n+      context: Context, receiver: Object, callback: Object, thisArg: Object,\n+      initialK: Object, length: Object): Object {\n+    return ArrayForEachLoopContinuation(\n+        context, receiver, callback, thisArg, Undefined, receiver, initialK,\n+        length, Undefined);\n+  }\n+\n+  javascript builtin ArrayForEachLoopLazyDeoptContinuation(\n+      context: Context, receiver: Object, callback: Object, thisArg: Object,\n+      initialK: Object, length: Object, result: Object): Object {\n+    return ArrayForEachLoopContinuation(\n+        context, receiver, callback, thisArg, Undefined, receiver, initialK,\n+        length, Undefined);\n+  }\n+\n+  builtin ArrayForEachLoopContinuation(\n+      context: Context, receiver: Object, callback: Object, thisArg: Object,\n+      array: Object, object: Object, initialK: Object, length: Object,\n+      to: Object): Object {\n+    try {\n+      let callbackfn: Callable = cast<Callable>(callback) otherwise Unexpected;\n+      let k: Smi = cast<Smi>(initialK) otherwise Unexpected;\n+      let number_length: Number = cast<Number>(length) otherwise Unexpected;\n+\n+      return ArrayForEachTorqueContinuation(\n+          context, object, number_length, callbackfn, thisArg, k);\n+    }\n+    label Unexpected {\n+      unreachable;\n+    }\n+  }\n+\n+  macro VisitAllElements<FixedArrayType : type>(\n+      context: Context, a: JSArray, len: Smi, callbackfn: Callable,\n+      thisArg: Object): void labels\n+  Bailout(Smi) {\n+    let k: Smi = 0;\n+    let map: Map = a.map;\n+\n+    try {\n+      // Build a fast loop over the smi array.\n+      for (; k < len; k = k + 1) {\n+        // Ensure that the map didn't change.\n+        if (map != a.map) goto Slow;\n+        // Ensure that we haven't walked beyond a possibly updated length.\n+        if (k >= a.length) goto Slow;\n+\n+        try {\n+          let value: Object =\n+              LoadElementNoHole<FixedArrayType>(a, k) otherwise FoundHole;\n+          Call(context, callbackfn, thisArg, value, k, a);\n+        }\n+        label FoundHole {\n+          // If we found the hole, we need to bail out if the initial\n+          // array prototype has had elements inserted. This is preferable\n+          // to walking the prototype chain looking for elements.\n+\n+          if (IsNoElementsProtectorCellInvalid()) goto Bailout(k);\n+        }\n+      }\n+    }\n+    label Slow {\n+      goto Bailout(k);\n+    }\n+  }\n+\n+  macro FastArrayForEach(\n+      context: Context, o: Object, len: Number, callbackfn: Callable,\n+      thisArg: Object): Object labels\n+  Bailout(Smi) {\n+    let k: Smi = 0;\n+    try {\n+      let smi_len: Smi = cast<Smi>(len) otherwise Slow;\n+      let a: JSArray = cast<JSArray>(o) otherwise Slow;\n+      let map: Map = a.map;\n+\n+      if (!IsPrototypeInitialArrayPrototype(context, map)) goto Slow;\n+      let elementsKind: ElementsKind = map.elements_kind;\n+      if (!IsFastElementsKind(elementsKind)) goto Slow;\n+\n+      if (IsElementsKindGreaterThan(elementsKind, HOLEY_ELEMENTS)) {\n+        VisitAllElements<FixedDoubleArray>(\n+            context, a, smi_len, callbackfn, thisArg)\n+        otherwise Bailout;\n+      } else {\n+        VisitAllElements<FixedArray>(context, a, smi_len, callbackfn, thisArg)\n+        otherwise Bailout;\n+      }\n+    }\n+    label Slow {\n+      goto Bailout(k);\n+    }\n+    return Undefined;\n+  }\n+\n+  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n+  javascript builtin ArrayForEach(\n+      context: Context, receiver: Object, ...arguments): Object {\n+    try {\n+      if (IsNullOrUndefined(receiver)) {\n+        goto NullOrUndefinedError;\n+      }\n+\n+      // 1. Let O be ? ToObject(this value).\n+      let o: Object = ToObject(context, receiver);\n+\n+      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n+      let len: Number = GetLengthProperty(context, o);\n+\n+      // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n+      if (arguments.length == 0) {\n+        goto TypeError;\n+      }\n+      let callbackfn: Callable =\n+          cast<Callable>(arguments[0]) otherwise TypeError;\n+\n+      // 4. If thisArg is present, let T be thisArg; else let T be undefined.\n+      let thisArg: Object = arguments.length > 1 ? arguments[1] : Undefined;\n+\n+      // Special cases.\n+      let k: Smi = 0;\n+      try {\n+        return FastArrayForEach(context, o, len, callbackfn, thisArg)\n+        otherwise Bailout;\n+      }\n+      label Bailout(k_value: Smi) {\n+        k = k_value;\n+      }\n+\n+      return ArrayForEachTorqueContinuation(\n+          context, o, len, callbackfn, thisArg, k);\n+    }\n+    label TypeError {\n+      ThrowTypeError(context, kCalledNonCallable, arguments[0]);\n+    }\n+    label NullOrUndefinedError {\n+      ThrowTypeError(\n+          context, kCalledOnNullOrUndefined, 'Array.prototype.forEach');\n+    }\n+  }\n+}"
        },
        {
            "sha": "30bbf5ef7467951906bc24ca97d8a3af8d628ac8",
            "filename": "deps/v8/src/builtins/array-sort.tq",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray-sort.tq",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray-sort.tq",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray-sort.tq?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -0,0 +1,8 @@\n+// Copyright 2018 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+module array {\n+  // TODO(szuend): TimSort implementation will go here. Keeping the file around\n+  //               after removing the QuickSort Torque implementation.\n+}"
        },
        {
            "sha": "edfe342ae3878c940eec439f2528dd12f6c97b9d",
            "filename": "deps/v8/src/builtins/array.tq",
            "status": "modified",
            "additions": 21,
            "deletions": 181,
            "changes": 202,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray.tq",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray.tq",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Farray.tq?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -3,8 +3,18 @@\n // found in the LICENSE file.\n \n module array {\n+  macro GetLengthProperty(context: Context, o: Object): Number {\n+    if (BranchIfFastJSArray(o, context)) {\n+      let a: JSArray = unsafe_cast<JSArray>(o);\n+      return a.length_fast;\n+    } else\n+      deferred {\n+        return ToLength_Inline(context, GetProperty(context, o, 'length'));\n+      }\n+  }\n+\n   macro FastArraySplice(\n-      context: Context, args: Arguments, o: Object,\n+      context: Context, args: constexpr Arguments, o: Object,\n       originalLengthNumber: Number, actualStartNumber: Number, insertCount: Smi,\n       actualDeleteCountNumber: Number): Object\n   labels Bailout {\n@@ -103,8 +113,7 @@ module array {\n     let o: Object = ToObject(context, receiver);\n \n     // 2. Let len be ? ToLength(? Get(O, \"length\")).\n-    let len: Number =\n-        ToLength_Inline(context, GetProperty(context, o, 'length'));\n+    let len: Number = GetLengthProperty(context, o);\n \n     // 3. Let relativeStart be ? ToInteger(start).\n     let start: Object = arguments[0];\n@@ -145,7 +154,7 @@ module array {\n     // 8. If len + insertCount - actualDeleteCount > 2^53-1, throw a\n     //    Bailout exception.\n     if (len + insertCount - actualDeleteCount > kMaxSafeInteger) {\n-      ThrowRangeError(context, kInvalidArrayLengthMessage);\n+      ThrowRangeError(context, kInvalidArrayLength);\n     }\n \n     try {\n@@ -186,7 +195,7 @@ module array {\n     }\n \n     // 12. Perform ? Set(A, \"length\", actualDeleteCount, true).\n-    SetProperty(context, a, 'length', actualDeleteCount, strict);\n+    SetProperty(context, a, 'length', actualDeleteCount, kStrict);\n \n     // 13. Let items be a List whose elements are, in left-to-right order,\n     //     the portion of the actual argument list starting with the third\n@@ -217,12 +226,12 @@ module array {\n           let fromValue: Object = GetProperty(context, o, from);\n \n           // 2. Perform ? Set(O, to, fromValue, true).\n-          SetProperty(context, o, to, fromValue, strict);\n+          SetProperty(context, o, to, fromValue, kStrict);\n \n           // v. Else fromPresent is false,\n         } else {\n           // 1. Perform ? DeletePropertyOrThrow(O, to).\n-          DeleteProperty(context, o, to, strict);\n+          DeleteProperty(context, o, to, kStrict);\n         }\n         // vi. Increase k by 1.\n         k = k + 1;\n@@ -233,7 +242,7 @@ module array {\n       // d. Repeat, while k > (len - actualDeleteCount + itemCount)\n       while (k > (len - actualDeleteCount + itemCount)) {\n         // i. Perform ? DeletePropertyOrThrow(O, ! ToString(k - 1)).\n-        DeleteProperty(context, o, ToString_Inline(context, k - 1), strict);\n+        DeleteProperty(context, o, ToString_Inline(context, k - 1), kStrict);\n \n         // ii. Decrease k by 1.\n         k = k - 1;\n@@ -261,12 +270,12 @@ module array {\n           let fromValue: Object = GetProperty(context, o, from);\n \n           // 2. Perform ? Set(O, to, fromValue, true).\n-          SetProperty(context, o, to, fromValue, strict);\n+          SetProperty(context, o, to, fromValue, kStrict);\n \n           // v. Else fromPresent is false,\n         } else {\n           // 1. Perform ? DeletePropertyOrThrow(O, to).\n-          DeleteProperty(context, o, to, strict);\n+          DeleteProperty(context, o, to, kStrict);\n         }\n \n         // vi. Decrease k by 1.\n@@ -283,7 +292,7 @@ module array {\n     if (arguments.length > 2) {\n       for (let e: Object of arguments [2: ]) {\n         // b. Perform ? Set(O, ! ToString(k), E, true).\n-        SetProperty(context, o, ToString_Inline(context, k), e, strict);\n+        SetProperty(context, o, ToString_Inline(context, k), e, kStrict);\n \n         // c. Increase k by 1.\n         k = k + 1;\n@@ -293,177 +302,8 @@ module array {\n     // 19. Perform ? Set(O, \"length\", len - actualDeleteCount + itemCount,\n     // true).\n     SetProperty(\n-        context, o, 'length', len - actualDeleteCount + itemCount, strict);\n+        context, o, 'length', len - actualDeleteCount + itemCount, kStrict);\n \n     return a;\n   }\n-\n-  macro ArrayForEachTorqueContinuation(\n-      context: Context, o: Object, len: Number, callbackfn: Callable,\n-      thisArg: Object, initial_k: Smi): Object {\n-    // 5. Let k be 0.\n-    // 6. Repeat, while k < len\n-    for (let k: Smi = initial_k; k < len; k = k + 1) {\n-      // 6a. Let Pk be ! ToString(k).\n-      let pK: String = ToString_Inline(context, k);\n-\n-      // 6b. Let kPresent be ? HasProperty(O, Pk).\n-      let kPresent: Oddball = HasPropertyObject(o, pK, context, kHasProperty);\n-\n-      // 6c. If kPresent is true, then\n-      if (kPresent == True) {\n-        // 6c. i. Let kValue be ? Get(O, Pk).\n-        let kValue: Object = GetProperty(context, o, pK);\n-\n-        // 6c. ii. Perform ? Call(callbackfn, T, <kValue, k, O>).\n-        Call(context, callbackfn, thisArg, kValue, k, o);\n-      }\n-\n-      // 6d. Increase k by 1. (done by the loop).\n-    }\n-    return Undefined;\n-  }\n-\n-  javascript builtin ArrayForEachLoopEagerDeoptContinuation(\n-      context: Context, receiver: Object, callback: Object, thisArg: Object,\n-      initialK: Object, length: Object): Object {\n-    return ArrayForEachLoopContinuation(\n-        context, receiver, callback, thisArg, Undefined, receiver, initialK,\n-        length, Undefined);\n-  }\n-\n-  javascript builtin ArrayForEachLoopLazyDeoptContinuation(\n-      context: Context, receiver: Object, callback: Object, thisArg: Object,\n-      initialK: Object, length: Object, result: Object): Object {\n-    return ArrayForEachLoopContinuation(\n-        context, receiver, callback, thisArg, Undefined, receiver, initialK,\n-        length, Undefined);\n-  }\n-\n-  builtin ArrayForEachLoopContinuation(\n-      context: Context, receiver: Object, callback: Object, thisArg: Object,\n-      array: Object, object: Object, initialK: Object, length: Object,\n-      to: Object): Object {\n-    try {\n-      let callbackfn: Callable = cast<Callable>(callback) otherwise Unexpected;\n-      let k: Smi = cast<Smi>(initialK) otherwise Unexpected;\n-      let number_length: Number = cast<Number>(length) otherwise Unexpected;\n-\n-      return ArrayForEachTorqueContinuation(\n-          context, object, number_length, callbackfn, thisArg, k);\n-    }\n-    label Unexpected {\n-      unreachable;\n-    }\n-  }\n-\n-  macro VisitAllElements<FixedArrayType : type>(\n-      context: Context, a: JSArray, len: Smi, callbackfn: Callable,\n-      thisArg: Object): void labels\n-  Bailout(Smi) {\n-    let k: Smi = 0;\n-    let map: Map = a.map;\n-\n-    try {\n-      // Build a fast loop over the smi array.\n-      for (; k < len; k = k + 1) {\n-        // Ensure that the map didn't change.\n-        if (map != a.map) goto Slow;\n-        // Ensure that we haven't walked beyond a possibly updated length.\n-        if (k >= a.length) goto Slow;\n-\n-        try {\n-          let value: Object =\n-              LoadElementNoHole<FixedArrayType>(a, k) otherwise FoundHole;\n-          Call(context, callbackfn, thisArg, value, k, a);\n-        }\n-        label FoundHole {\n-          // If we found the hole, we need to bail out if the initial\n-          // array prototype has had elements inserted. This is preferable\n-          // to walking the prototype chain looking for elements.\n-\n-          if (IsNoElementsProtectorCellInvalid()) goto Bailout(k);\n-        }\n-      }\n-    }\n-    label Slow {\n-      goto Bailout(k);\n-    }\n-  }\n-\n-  macro FastArrayForEach(\n-      context: Context, o: Object, len: Number, callbackfn: Callable,\n-      thisArg: Object): Object labels\n-  Bailout(Smi) {\n-    let k: Smi = 0;\n-    try {\n-      let smi_len: Smi = cast<Smi>(len) otherwise Slow;\n-      let a: JSArray = cast<JSArray>(o) otherwise Slow;\n-      let map: Map = a.map;\n-\n-      if (!IsPrototypeInitialArrayPrototype(context, map)) goto Slow;\n-      let elementsKind: ElementsKind = map.elements_kind;\n-      if (!IsFastElementsKind(elementsKind)) goto Slow;\n-\n-      if (IsElementsKindGreaterThan(elementsKind, HOLEY_ELEMENTS)) {\n-        VisitAllElements<FixedDoubleArray>(\n-            context, a, smi_len, callbackfn, thisArg)\n-        otherwise Bailout;\n-      } else {\n-        VisitAllElements<FixedArray>(context, a, smi_len, callbackfn, thisArg)\n-        otherwise Bailout;\n-      }\n-    }\n-    label Slow {\n-      goto Bailout(k);\n-    }\n-    return Undefined;\n-  }\n-\n-  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach\n-  javascript builtin ArrayForEach(\n-      context: Context, receiver: Object, ...arguments): Object {\n-    try {\n-      if (IsNullOrUndefined(receiver)) {\n-        goto NullOrUndefinedError;\n-      }\n-\n-      // 1. Let O be ? ToObject(this value).\n-      let o: Object = ToObject(context, receiver);\n-\n-      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n-      let len: Number =\n-          ToLength_Inline(context, GetProperty(context, o, 'length'));\n-\n-      // 3. If IsCallable(callbackfn) is false, throw a TypeError exception.\n-      if (arguments.length == 0) {\n-        goto TypeError;\n-      }\n-      let callbackfn: Callable =\n-          cast<Callable>(arguments[0]) otherwise TypeError;\n-\n-      // 4. If thisArg is present, let T be thisArg; else let T be undefined.\n-      let thisArg: Object = arguments.length > 1 ? arguments[1] : Undefined;\n-\n-      // Special cases.\n-      let k: Smi = 0;\n-      try {\n-        return FastArrayForEach(context, o, len, callbackfn, thisArg)\n-        otherwise Bailout;\n-      }\n-      label Bailout(k_value: Smi) {\n-        k = k_value;\n-      }\n-\n-      return ArrayForEachTorqueContinuation(\n-          context, o, len, callbackfn, thisArg, k);\n-    }\n-    label TypeError {\n-      ThrowTypeError(context, kCalledNonCallable, arguments[0]);\n-    }\n-    label NullOrUndefinedError {\n-      ThrowTypeError(\n-          context, kCalledOnNullOrUndefined, 'Array.prototype.forEach');\n-    }\n-  }\n }"
        },
        {
            "sha": "1c9acdd5c6122a920359d702340500960a558d72",
            "filename": "deps/v8/src/builtins/base.tq",
            "status": "modified",
            "additions": 532,
            "deletions": 126,
            "changes": 658,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbase.tq",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbase.tq",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbase.tq?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -2,130 +2,210 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-type Arguments generates 'CodeStubArguments*';\n+type Arguments constexpr 'CodeStubArguments*';\n type void generates 'void';\n type never generates 'void';\n \n-type Object generates 'TNode<Object>';\n+type Tagged generates 'TNode<Object>';\n+type Smi extends Tagged generates 'TNode<Smi>';\n+type HeapObject extends Tagged generates 'TNode<HeapObject>';\n+type Object = Smi|HeapObject;\n type int32 generates 'TNode<Int32T>' constexpr 'int32_t';\n+type uint32 generates 'TNode<Uint32T>' constexpr 'uint32_t';\n+type int64 generates 'TNode<Int64T>' constexpr 'int64_t';\n type intptr generates 'TNode<IntPtrT>' constexpr 'intptr_t';\n+type uintptr generates 'TNode<UintPtrT>' constexpr 'uintptr_t';\n+type float32 generates 'TNode<Float32T>' constexpr 'float';\n type float64 generates 'TNode<Float64T>' constexpr 'double';\n type bool generates 'TNode<BoolT>' constexpr 'bool';\n+type string constexpr 'const char*';\n \n-type int31 extends int32 generates 'TNode<Int32T>' constexpr 'int32_t';\n+type int31 extends int32 generates 'TNode<Int32T>' constexpr 'int31_t';\n type RawPtr generates 'TNode<RawPtrT>' constexpr 'void*';\n-type Number extends Object generates 'TNode<Number>';\n-type Smi extends Number generates 'TNode<Smi>';\n-type HeapObject extends Object generates 'TNode<HeapObject>';\n type AbstractCode extends HeapObject generates 'TNode<AbstractCode>';\n type Code extends AbstractCode generates 'TNode<Code>';\n type JSReceiver extends HeapObject generates 'TNode<JSReceiver>';\n type Context extends HeapObject generates 'TNode<Context>';\n type String extends HeapObject generates 'TNode<String>';\n type Oddball extends HeapObject generates 'TNode<Oddball>';\n type HeapNumber extends HeapObject generates 'TNode<HeapNumber>';\n+type Number = Smi|HeapNumber;\n+type BigInt extends HeapObject generates 'TNode<BigInt>';\n+type Numeric = Number|BigInt;\n type Boolean extends Oddball generates 'TNode<Oddball>';\n-type JSArray extends HeapObject generates 'TNode<JSArray>';\n-type Callable extends JSReceiver generates 'TNode<JSReceiver>';\n-type JSFunction extends Callable generates 'TNode<JSFunction>';\n+type JSProxy extends JSReceiver generates 'TNode<JSProxy>';\n+type JSObject extends JSReceiver generates 'TNode<JSObject>';\n+type JSArray extends JSObject generates 'TNode<JSArray>';\n+type JSFunction extends JSObject generates 'TNode<JSFunction>';\n+type JSBoundFunction extends JSObject generates 'TNode<JSBoundFunction>';\n+type Callable = JSFunction|JSBoundFunction|JSProxy;\n type Map extends HeapObject generates 'TNode<Map>';\n type FixedArrayBase extends HeapObject generates 'TNode<FixedArrayBase>';\n type FixedArray extends FixedArrayBase generates 'TNode<FixedArray>';\n type FixedDoubleArray extends FixedArrayBase generates\n 'TNode<FixedDoubleArray>';\n-\n-type JSArrayBuffer extends Object generates 'TNode<JSArrayBuffer>';\n-type JSArrayBufferView extends Object generates 'TNode<JSArrayBufferView>';\n+type FixedTypedArrayBase extends FixedArrayBase generates\n+'TNode<FixedTypedArrayBase>';\n+type FixedTypedArray extends FixedTypedArrayBase generates\n+'TNode<FixedTypedArray>';\n+type NumberDictionary extends HeapObject generates 'TNode<NumberDictionary>';\n+\n+type JSArrayBuffer extends JSObject generates 'TNode<JSArrayBuffer>';\n+type JSArrayBufferView extends JSObject generates 'TNode<JSArrayBufferView>';\n type JSTypedArray extends JSArrayBufferView generates 'TNode<JSTypedArray>';\n+type JSDataView extends JSArrayBufferView generates 'TNode<JSDataView>';\n \n-type InstanceType extends int32 generates 'TNode<Int32T>';\n+type InstanceType generates 'TNode<Int32T>' constexpr 'InstanceType';\n type ElementsKind generates 'TNode<Int32T>' constexpr 'ElementsKind';\n type LanguageMode generates 'TNode<Smi>' constexpr 'LanguageMode';\n type ExtractFixedArrayFlags generates\n 'TNode<Smi>' constexpr 'ExtractFixedArrayFlags';\n-\n-type MessageTemplate;\n-type HasPropertyFlag generates 'HasPropertyLookupMode';\n-\n-const PACKED_SMI_ELEMENTS: constexpr ElementsKind = 'PACKED_SMI_ELEMENTS';\n-const HOLEY_SMI_ELEMENTS: constexpr ElementsKind = 'HOLEY_SMI_ELEMENTS';\n-const PACKED_ELEMENTS: constexpr ElementsKind = 'PACKED_ELEMENTS';\n-const HOLEY_ELEMENTS: constexpr ElementsKind = 'HOLEY_ELEMENTS';\n-const PACKED_DOUBLE_ELEMENTS: constexpr ElementsKind = 'PACKED_DOUBLE_ELEMENTS';\n-const HOLEY_DOUBLE_ELEMENTS: constexpr ElementsKind = 'HOLEY_DOUBLE_ELEMENTS';\n-\n-const UINT8_ELEMENTS: constexpr ElementsKind = 'UINT8_ELEMENTS';\n-const INT8_ELEMENTS: constexpr ElementsKind = 'INT8_ELEMENTS';\n-const UINT16_ELEMENTS: constexpr ElementsKind = 'UINT16_ELEMENTS';\n-const INT16_ELEMENTS: constexpr ElementsKind = 'INT16_ELEMENTS';\n-const UINT32_ELEMENTS: constexpr ElementsKind = 'UINT32_ELEMENTS';\n-const INT32_ELEMENTS: constexpr ElementsKind = 'INT32_ELEMENTS';\n-const FLOAT32_ELEMENTS: constexpr ElementsKind = 'FLOAT32_ELEMENTS';\n-const FLOAT64_ELEMENTS: constexpr ElementsKind = 'FLOAT64_ELEMENTS';\n-const UINT8_CLAMPED_ELEMENTS: constexpr ElementsKind = 'UINT8_CLAMPED_ELEMENTS';\n-const BIGUINT64_ELEMENTS: constexpr ElementsKind = 'BIGUINT64_ELEMENTS';\n-const BIGINT64_ELEMENTS: constexpr ElementsKind = 'BIGINT64_ELEMENTS';\n-\n-const kAllFixedArrays: constexpr ExtractFixedArrayFlags =\n-    'ExtractFixedArrayFlag::kAllFixedArrays';\n-\n-const kCOWMap: Map = 'LoadRoot(Heap::kFixedCOWArrayMapRootIndex)';\n-const kEmptyFixedArray: FixedArrayBase =\n-    'UncheckedCast<FixedArrayBase>(LoadRoot(Heap::kEmptyFixedArrayRootIndex))';\n-\n-const kInvalidArrayLengthMessage: MessageTemplate =\n-    'MessageTemplate::kInvalidArrayLength';\n-const kCalledNonCallable: MessageTemplate =\n-    'MessageTemplate::kCalledNonCallable';\n-const kCalledOnNullOrUndefined: MessageTemplate =\n-    'MessageTemplate::kCalledOnNullOrUndefined';\n-\n-const kHasProperty: HasPropertyFlag = 'kHasProperty';\n-\n-const kMaxSafeInteger: constexpr float64 = 'kMaxSafeInteger';\n-\n-const kNotTypedArray: MessageTemplate = 'MessageTemplate::kNotTypedArray';\n-const kDetachedOperation: MessageTemplate =\n-    'MessageTemplate::kDetachedOperation';\n-const kBadSortComparisonFunction: MessageTemplate =\n-    'MessageTemplate::kBadSortComparisonFunction';\n-\n-const Hole: Oddball = 'TheHoleConstant()';\n-const Null: Oddball = 'NullConstant()';\n-const Undefined: Oddball = 'UndefinedConstant()';\n-const True: Boolean = 'TrueConstant()';\n-const False: Boolean = 'FalseConstant()';\n-const true: constexpr bool = 'true';\n-const false: constexpr bool = 'false';\n-\n-const strict: constexpr LanguageMode = 'LanguageMode::kStrict';\n-const sloppy: constexpr LanguageMode = 'LanguageMode::kSloppy';\n-\n+type ParameterMode generates 'TNode<Int32T>' constexpr 'ParameterMode';\n+type RootListIndex generates 'TNode<Int32T>' constexpr 'Heap::RootListIndex';\n+\n+type MessageTemplate constexpr 'MessageTemplate';\n+type HasPropertyLookupMode constexpr 'HasPropertyLookupMode';\n+\n+type ToIntegerTruncationMode constexpr 'ToIntegerTruncationMode';\n+\n+const NO_ELEMENTS: constexpr ElementsKind generates 'NO_ELEMENTS';\n+\n+const PACKED_SMI_ELEMENTS: constexpr ElementsKind generates\n+    'PACKED_SMI_ELEMENTS';\n+const HOLEY_SMI_ELEMENTS: constexpr ElementsKind generates 'HOLEY_SMI_ELEMENTS';\n+const PACKED_ELEMENTS: constexpr ElementsKind generates 'PACKED_ELEMENTS';\n+const HOLEY_ELEMENTS: constexpr ElementsKind generates 'HOLEY_ELEMENTS';\n+const PACKED_DOUBLE_ELEMENTS: constexpr ElementsKind generates\n+    'PACKED_DOUBLE_ELEMENTS';\n+const HOLEY_DOUBLE_ELEMENTS: constexpr ElementsKind generates\n+    'HOLEY_DOUBLE_ELEMENTS';\n+const DICTIONARY_ELEMENTS: constexpr ElementsKind generates\n+    'DICTIONARY_ELEMENTS';\n+\n+const UINT8_ELEMENTS: constexpr ElementsKind generates 'UINT8_ELEMENTS';\n+const INT8_ELEMENTS: constexpr ElementsKind generates 'INT8_ELEMENTS';\n+const UINT16_ELEMENTS: constexpr ElementsKind generates 'UINT16_ELEMENTS';\n+const INT16_ELEMENTS: constexpr ElementsKind generates 'INT16_ELEMENTS';\n+const UINT32_ELEMENTS: constexpr ElementsKind generates 'UINT32_ELEMENTS';\n+const INT32_ELEMENTS: constexpr ElementsKind generates 'INT32_ELEMENTS';\n+const FLOAT32_ELEMENTS: constexpr ElementsKind generates 'FLOAT32_ELEMENTS';\n+const FLOAT64_ELEMENTS: constexpr ElementsKind generates 'FLOAT64_ELEMENTS';\n+const UINT8_CLAMPED_ELEMENTS: constexpr ElementsKind generates\n+    'UINT8_CLAMPED_ELEMENTS';\n+const BIGUINT64_ELEMENTS: constexpr ElementsKind generates 'BIGUINT64_ELEMENTS';\n+const BIGINT64_ELEMENTS: constexpr ElementsKind generates 'BIGINT64_ELEMENTS';\n+\n+type FixedUint8Array extends FixedTypedArray;\n+type FixedInt8Array extends FixedTypedArray;\n+type FixedUint16Array extends FixedTypedArray;\n+type FixedInt16Array extends FixedTypedArray;\n+type FixedUint32Array extends FixedTypedArray;\n+type FixedInt32Array extends FixedTypedArray;\n+type FixedFloat32Array extends FixedTypedArray;\n+type FixedFloat64Array extends FixedTypedArray;\n+type FixedUint8ClampedArray extends FixedTypedArray;\n+type FixedBigUint64Array extends FixedTypedArray;\n+type FixedBigInt64Array extends FixedTypedArray;\n+\n+const kAllFixedArrays: constexpr ExtractFixedArrayFlags generates\n+'ExtractFixedArrayFlag::kAllFixedArrays';\n+\n+const kFixedCOWArrayMapRootIndex: constexpr RootListIndex generates\n+'Heap::kFixedCOWArrayMapRootIndex';\n+const kEmptyFixedArrayRootIndex: constexpr RootListIndex generates\n+'Heap::kEmptyFixedArrayRootIndex';\n+\n+const kInvalidArrayLength: constexpr MessageTemplate generates\n+'MessageTemplate::kInvalidArrayLength';\n+const kCalledNonCallable: constexpr MessageTemplate generates\n+'MessageTemplate::kCalledNonCallable';\n+const kCalledOnNullOrUndefined: constexpr MessageTemplate generates\n+'MessageTemplate::kCalledOnNullOrUndefined';\n+\n+const kHasProperty: constexpr HasPropertyLookupMode generates 'kHasProperty';\n+\n+const kMaxSafeInteger: constexpr float64 generates 'kMaxSafeInteger';\n+\n+const kTruncateMinusZero: constexpr ToIntegerTruncationMode generates\n+'ToIntegerTruncationMode::kTruncateMinusZero';\n+\n+const kNotTypedArray: constexpr MessageTemplate generates\n+'MessageTemplate::kNotTypedArray';\n+const kDetachedOperation: constexpr MessageTemplate generates\n+'MessageTemplate::kDetachedOperation';\n+const kBadSortComparisonFunction: constexpr MessageTemplate generates\n+'MessageTemplate::kBadSortComparisonFunction';\n+const kIncompatibleMethodReceiver: constexpr MessageTemplate generates\n+'MessageTemplate::kIncompatibleMethodReceiver';\n+const kInvalidDataViewAccessorOffset: constexpr MessageTemplate generates\n+'MessageTemplate::kInvalidDataViewAccessorOffset';\n+const kStrictReadOnlyProperty: constexpr MessageTemplate generates\n+'MessageTemplate::kStrictReadOnlyProperty';\n+\n+extern macro TheHoleConstant(): Oddball;\n+extern macro NullConstant(): Oddball;\n+extern macro UndefinedConstant(): Oddball;\n+extern macro TrueConstant(): Boolean;\n+extern macro FalseConstant(): Boolean;\n+\n+const Hole: Oddball = TheHoleConstant();\n+const Null: Oddball = NullConstant();\n+const Undefined: Oddball = UndefinedConstant();\n+const True: Boolean = TrueConstant();\n+const False: Boolean = FalseConstant();\n+\n+const true: constexpr bool generates 'true';\n+const false: constexpr bool generates 'false';\n+\n+const kStrict: constexpr LanguageMode generates 'LanguageMode::kStrict';\n+const kSloppy: constexpr LanguageMode generates 'LanguageMode::kSloppy';\n+\n+const SMI_PARAMETERS: constexpr ParameterMode generates 'SMI_PARAMETERS';\n+const INTPTR_PARAMETERS: constexpr ParameterMode generates 'INTPTR_PARAMETERS';\n+\n+extern macro Is64(): constexpr bool;\n+\n+extern macro Print(constexpr string);\n+extern macro Print(constexpr string, Object);\n extern macro Print(Object);\n extern macro DebugBreak();\n extern macro ToInteger_Inline(Context, Object): Number;\n+extern macro ToInteger_Inline(\n+    Context, Object, constexpr ToIntegerTruncationMode): Number;\n extern macro ToLength_Inline(Context, Object): Number;\n extern macro ToNumber_Inline(Context, Object): Number;\n extern macro ToString_Inline(Context, Object): String;\n extern macro GetProperty(Context, Object, Object): Object;\n-extern macro HasProperty(HeapObject, Object, Context, HasPropertyFlag): Oddball;\n-extern macro ThrowRangeError(Context, MessageTemplate): never;\n-extern macro ThrowTypeError(Context, MessageTemplate): never;\n-extern macro ThrowTypeError(Context, MessageTemplate, Object): never;\n+extern macro HasProperty(\n+    HeapObject, Object, Context, constexpr HasPropertyLookupMode): Oddball;\n+extern macro ThrowRangeError(Context, constexpr MessageTemplate): never;\n+extern macro ThrowTypeError(Context, constexpr MessageTemplate): never;\n+extern macro ThrowTypeError(Context, constexpr MessageTemplate, Object): never;\n+extern macro ThrowTypeError(Context, constexpr MessageTemplate, Object, Object,\n+    Object): never;\n extern macro ArraySpeciesCreate(Context, Object, Number): Object;\n extern macro EnsureArrayPushable(Map): ElementsKind labels Bailout;\n \n-extern builtin ToObject(Context, Object): Object;\n+extern builtin ToObject(Context, Object): JSReceiver;\n extern macro IsNullOrUndefined(Object): bool;\n+extern macro IsTheHole(Object): bool;\n+extern macro IsString(HeapObject): bool;\n+extern builtin ToString(Context, Object): String;\n \n extern runtime CreateDataProperty(Context, Object, Object, Object);\n extern runtime SetProperty(Context, Object, Object, Object, LanguageMode);\n extern runtime DeleteProperty(Context, Object, Object, LanguageMode);\n \n+extern macro LoadRoot(constexpr RootListIndex): Object;\n+extern macro StoreRoot(constexpr RootListIndex, Object): Object;\n+extern macro LoadAndUntagToWord32Root(constexpr RootListIndex): int32;\n+\n extern runtime StringEqual(Context, String, String): Oddball;\n+extern builtin StringLessThan(Context, String, String): Boolean;\n+\n+extern macro StrictEqual(Object, Object): Boolean;\n+extern runtime SmiLexicographicCompare(Context, Object, Object): Number;\n \n-extern operator '==' macro Word32Equal(int32, int32): bool;\n-extern operator '!=' macro Word32NotEqual(int32, int32): bool;\n extern operator '<' macro Int32LessThan(int32, int32): bool;\n extern operator '>' macro Int32GreaterThan(int32, int32): bool;\n extern operator '<=' macro Int32LessThanOrEqual(int32, int32): bool;\n@@ -140,18 +220,24 @@ extern operator '>=' macro SmiGreaterThanOrEqual(Smi, Smi): bool;\n \n extern operator '==' macro ElementsKindEqual(\n     constexpr ElementsKind, constexpr ElementsKind): constexpr bool;\n+extern operator '==' macro ElementsKindEqual(ElementsKind, ElementsKind): bool;\n extern macro IsFastElementsKind(constexpr ElementsKind): constexpr bool;\n+extern macro IsDoubleElementsKind(constexpr ElementsKind): constexpr bool;\n \n extern macro SmiAbove(Smi, Smi): bool;\n \n extern operator '==' macro WordEqual(intptr, intptr): bool;\n+extern operator '==' macro WordEqual(uintptr, uintptr): bool;\n extern operator '!=' macro WordNotEqual(intptr, intptr): bool;\n+extern operator '!=' macro WordNotEqual(uintptr, uintptr): bool;\n extern operator '<' macro IntPtrLessThan(intptr, intptr): bool;\n extern operator '>' macro IntPtrGreaterThan(intptr, intptr): bool;\n extern operator '<=' macro IntPtrLessThanOrEqual(intptr, intptr): bool;\n extern operator '>=' macro IntPtrGreaterThanOrEqual(intptr, intptr): bool;\n+extern operator '>=' macro UintPtrGreaterThanOrEqual(uintptr, uintptr): bool;\n \n extern operator '==' macro Float64Equal(float64, float64): bool;\n+extern operator '!=' macro Float64NotEqual(float64, float64): bool;\n \n extern operator\n '<' macro BranchIfNumberLessThan(Number, Number): never labels Taken, NotTaken;\n@@ -170,11 +256,34 @@ extern operator '!=' macro WordNotEqual(Object, Object): bool;\n \n extern operator '+' macro SmiAdd(Smi, Smi): Smi;\n extern operator '-' macro SmiSub(Smi, Smi): Smi;\n+extern operator '&' macro SmiAnd(Smi, Smi): Smi;\n extern operator '>>>' macro SmiShr(Smi, constexpr int31): Smi;\n \n extern operator '+' macro IntPtrAdd(intptr, intptr): intptr;\n extern operator '-' macro IntPtrSub(intptr, intptr): intptr;\n-extern operator '>>>' macro WordShr(intptr, intptr): intptr;\n+extern operator '>>>' macro WordShr(uintptr, uintptr): uintptr;\n+extern operator '<<' macro WordShl(intptr, intptr): intptr;\n+extern operator '&' macro WordAnd(intptr, intptr): intptr;\n+extern operator '&' macro WordAnd(uintptr, uintptr): uintptr;\n+\n+extern operator '+' macro Int32Add(int32, int32): int32;\n+extern operator '-' macro Int32Sub(int32, int32): int32;\n+extern operator '*' macro Int32Mul(int32, int32): int32;\n+extern operator '%' macro Int32Mod(int32, int32): int32;\n+extern operator '&' macro Word32And(int32, int32): int32;\n+extern operator '&' macro Word32And(uint32, uint32): uint32;\n+extern operator '==' macro\n+ConstexprInt31Equal(constexpr int31, constexpr int31): constexpr bool;\n+\n+extern operator '==' macro Word32Equal(int32, int32): bool;\n+extern operator '==' macro Word32Equal(uint32, uint32): bool;\n+extern operator '!=' macro Word32NotEqual(int32, int32): bool;\n+extern operator '!=' macro Word32NotEqual(uint32, uint32): bool;\n+extern operator '>>>' macro Word32Shr(uint32, uint32): uint32;\n+extern operator '<<' macro Word32Shl(int32, int32): int32;\n+extern operator '<<' macro Word32Shl(uint32, uint32): uint32;\n+extern operator '|' macro Word32Or(int32, int32): int32;\n+extern operator '|' macro Word32Or(uint32, uint32): uint32;\n \n extern operator '+' macro NumberAdd(Number, Number): Number;\n extern operator '-' macro NumberSub(Number, Number): Number;\n@@ -186,51 +295,286 @@ extern operator '!' macro Word32BinaryNot(bool): bool;\n \n extern operator '.map' macro LoadMap(HeapObject): Map;\n extern operator '.map=' macro StoreMap(HeapObject, Map);\n-extern operator '.instanceType' macro LoadInstanceType(Object): InstanceType;\n+extern operator\n+'.instanceType' macro LoadInstanceType(HeapObject): InstanceType;\n \n extern operator '.length' macro LoadStringLengthAsWord(String): intptr;\n \n-extern operator '.length' macro GetArgumentsLength(Arguments): intptr;\n-extern operator '[]' macro GetArgumentValue(Arguments, intptr): Object;\n-extern operator '[]' macro GetArgumentValueSmiIndex(Arguments, Smi): Object;\n+extern operator '.length' macro GetArgumentsLength(constexpr Arguments): intptr;\n+extern operator\n+'[]' macro GetArgumentValue(constexpr Arguments, intptr): Object;\n \n extern operator 'is<Smi>' macro TaggedIsSmi(Object): bool;\n extern operator 'isnt<Smi>' macro TaggedIsNotSmi(Object): bool;\n-\n-extern operator\n-'cast<>' macro TaggedToHeapObject(Object): HeapObject labels CastError;\n-extern operator 'cast<>' macro TaggedToSmi(Object): Smi labels CastError;\n-extern operator\n-'cast<>' macro TaggedToJSArray(Object): JSArray labels CastError;\n-extern operator\n-'cast<>' macro TaggedToCallable(Object): Callable labels CastError;\n-extern operator 'cast<>' macro ConvertFixedArrayBaseToFixedArray(\n-    FixedArrayBase): FixedArray labels CastError;\n-extern operator 'cast<>' macro ConvertFixedArrayBaseToFixedDoubleArray(\n-    FixedArrayBase): FixedDoubleArray labels CastError;\n+extern macro TaggedIsPositiveSmi(Object): bool;\n+\n+extern macro TaggedToJSDataView(Object): JSDataView labels CastError;\n+extern macro TaggedToHeapObject(Object): HeapObject labels CastError;\n+extern macro TaggedToSmi(Object): Smi labels CastError;\n+extern macro TaggedToJSArray(Object): JSArray labels CastError;\n+extern macro TaggedToCallable(Object): Callable labels CastError;\n+extern macro ConvertFixedArrayBaseToFixedArray(FixedArrayBase):\n+    FixedArray labels CastError;\n+extern macro ConvertFixedArrayBaseToFixedDoubleArray(FixedArrayBase):\n+    FixedDoubleArray labels CastError;\n+extern macro TaggedToNumber(Object): Number labels CastError;\n+\n+macro cast<A : type>(o: Object): A labels CastError;\n+cast<Number>(o: Object): Number labels CastError {\n+  return TaggedToNumber(o) otherwise CastError;\n+}\n+cast<HeapObject>(o: Object): HeapObject labels CastError {\n+  return TaggedToHeapObject(o) otherwise CastError;\n+}\n+cast<Smi>(o: Object): Smi labels CastError {\n+  return TaggedToSmi(o) otherwise CastError;\n+}\n+cast<JSDataView>(o: Object): JSDataView labels CastError {\n+  return TaggedToJSDataView(o) otherwise CastError;\n+}\n+cast<Callable>(o: Object): Callable labels CastError {\n+  return TaggedToCallable(o) otherwise CastError;\n+}\n+cast<JSArray>(o: Object): JSArray labels CastError {\n+  return TaggedToJSArray(o) otherwise CastError;\n+}\n+macro cast<A : type>(o: FixedArrayBase): A labels CastError;\n+cast<FixedArray>(o: FixedArrayBase): FixedArray labels CastError {\n+  return ConvertFixedArrayBaseToFixedArray(o) otherwise CastError;\n+}\n+cast<FixedDoubleArray>(o: FixedArrayBase): FixedDoubleArray labels CastError {\n+  return ConvertFixedArrayBaseToFixedDoubleArray(o) otherwise CastError;\n+}\n \n extern macro AllocateHeapNumberWithValue(float64): HeapNumber;\n+extern macro ChangeInt32ToTagged(int32): Number;\n+extern macro ChangeUint32ToTagged(uint32): Number;\n+extern macro Unsigned(int32): uint32;\n+extern macro Unsigned(intptr): uintptr;\n+extern macro Unsigned(RawPtr): uintptr;\n+extern macro Signed(uint32): int32;\n+extern macro Signed(uintptr): intptr;\n+extern macro Signed(RawPtr): intptr;\n+extern macro TruncateIntPtrToInt32(intptr): int32;\n+extern macro SmiTag(intptr): Smi;\n+extern macro SmiFromInt32(int32): Smi;\n+extern macro SmiUntag(Smi): intptr;\n+extern macro SmiToInt32(Smi): int32;\n+extern macro RoundIntPtrToFloat64(intptr): float64;\n+extern macro LoadHeapNumberValue(HeapNumber): float64;\n+extern macro ChangeFloat32ToFloat64(float32): float64;\n+extern macro ChangeNumberToFloat64(Number): float64;\n+extern macro ChangeFloat64ToUintPtr(float64): uintptr;\n+extern macro ChangeInt32ToIntPtr(int32): intptr;  // Sign-extends.\n+extern macro ChangeUint32ToWord(uint32): uintptr;  // Doesn't sign-extend.\n+\n+extern macro NumberConstant(constexpr float64): Number;\n+extern macro NumberConstant(constexpr int32): Number;\n+extern macro IntPtrConstant(constexpr int31): intptr;\n+extern macro IntPtrConstant(constexpr int32): intptr;\n+extern macro Int32Constant(constexpr int31): int31;\n+extern macro Int32Constant(constexpr int32): int32;\n+extern macro Float64Constant(constexpr int31): float64;\n+extern macro SmiConstant(constexpr int31): Smi;\n+extern macro BoolConstant(constexpr bool): bool;\n+extern macro StringConstant(constexpr string): String;\n+extern macro LanguageModeConstant(constexpr LanguageMode): LanguageMode;\n+extern macro Int32Constant(constexpr ElementsKind): ElementsKind;\n+\n+macro from_constexpr<A : type>(o: constexpr int31): A;\n+from_constexpr<intptr>(i: constexpr int31): intptr {\n+  return IntPtrConstant(i);\n+}\n+from_constexpr<int31>(i: constexpr int31): int31 {\n+  return Int32Constant(i);\n+}\n+from_constexpr<int32>(i: constexpr int31): int32 {\n+  return Int32Constant(i);\n+}\n+from_constexpr<uint32>(i: constexpr int31): uint32 {\n+  return Unsigned(Int32Constant(i));\n+}\n+from_constexpr<uintptr>(i: constexpr int31): uintptr {\n+  return ChangeUint32ToWord(i);\n+}\n+from_constexpr<Smi>(i: constexpr int31): Smi {\n+  return SmiConstant(i);\n+}\n+from_constexpr<Number>(i: constexpr int31): Number {\n+  return SmiConstant(i);\n+}\n+from_constexpr<float64>(i: constexpr int31): float64 {\n+  return Float64Constant(i);\n+}\n+macro from_constexpr<A : type>(o: constexpr int32): A;\n+from_constexpr<intptr>(i: constexpr int32): intptr {\n+  return IntPtrConstant(i);\n+}\n+from_constexpr<int32>(i: constexpr int32): int32 {\n+  return Int32Constant(i);\n+}\n+from_constexpr<Number>(i: constexpr int32): Number {\n+  return NumberConstant(i);\n+}\n+macro from_constexpr<A : type>(o: constexpr float64): A;\n+from_constexpr<Number>(f: constexpr float64): Number {\n+  return NumberConstant(f);\n+}\n+macro from_constexpr<A : type>(b: constexpr bool): A;\n+from_constexpr<bool>(b: constexpr bool): bool {\n+  return BoolConstant(b);\n+}\n+macro from_constexpr<A : type>(l: constexpr LanguageMode): A;\n+from_constexpr<LanguageMode>(b: constexpr LanguageMode): LanguageMode {\n+  return LanguageModeConstant(b);\n+}\n+macro from_constexpr<A : type>(e: constexpr ElementsKind): A;\n+from_constexpr<ElementsKind>(e: constexpr ElementsKind): ElementsKind {\n+  return Int32Constant(e);\n+}\n+macro from_constexpr<A : type>(s: constexpr string): A;\n+from_constexpr<String>(s: constexpr string): String {\n+  return StringConstant(s);\n+}\n+from_constexpr<Object>(s: constexpr string): Object {\n+  return StringConstant(s);\n+}\n \n-extern implicit operator\n-'convert<>' macro AllocateHeapNumberWithValue(constexpr float64): Number;\n-extern implicit operator\n-'convert<>' macro IntPtrConstant(constexpr int31): intptr;\n-extern implicit operator\n-'convert<>' macro Int32Constant(constexpr int31): int32;\n-extern implicit operator 'convert<>' macro SmiConstant(constexpr int31): Smi;\n-extern implicit operator\n-'convert<>' macro NumberConstant(constexpr int31): Number;\n-extern implicit operator 'convert<>' macro BoolConstant(constexpr bool): bool;\n-extern implicit operator 'convert<>' macro LanguageModeConstant(\n-    constexpr LanguageMode): LanguageMode;\n-\n-extern implicit operator 'convert<>' macro SmiFromInt32(ElementsKind): Smi;\n-\n-extern operator 'convert<>' macro ChangeInt32ToTagged(int32): Number;\n-extern operator 'convert<>' macro TruncateWordToWord32(intptr): int32;\n-extern operator 'convert<>' macro SmiTag(intptr): Smi;\n-extern operator 'convert<>' macro SmiFromInt32(int32): Smi;\n-extern operator 'convert<>' macro SmiUntag(Smi): intptr;\n+macro convert<A : type>(i: constexpr int31): A {\n+  return i;\n+}\n+macro convert<A : type>(i: int32): A;\n+convert<Number>(i: int32): Number {\n+  return ChangeInt32ToTagged(i);\n+}\n+convert<intptr>(i: int32): intptr {\n+  return ChangeInt32ToIntPtr(i);\n+}\n+convert<Smi>(i: int32): Smi {\n+  return SmiFromInt32(i);\n+}\n+macro convert<A : type>(ui: uint32): A;\n+convert<Number>(ui: uint32): Number {\n+  return ChangeUint32ToTagged(ui);\n+}\n+convert<Smi>(ui: uint32): Smi {\n+  return SmiFromInt32(Signed(ui));\n+}\n+convert<uintptr>(ui: uint32): uintptr {\n+  return ChangeUint32ToWord(ui);\n+}\n+macro convert<A : type>(i: intptr): A;\n+convert<int32>(i: intptr): int32 {\n+  return TruncateIntPtrToInt32(i);\n+}\n+convert<Smi>(i: intptr): Smi {\n+  return SmiTag(i);\n+}\n+macro convert<A : type>(ui: uintptr): A;\n+convert<uint32>(ui: uintptr): uint32 {\n+  return Unsigned(TruncateIntPtrToInt32(Signed(ui)));\n+}\n+macro convert<A : type>(s: Smi): A;\n+convert<intptr>(s: Smi): intptr {\n+  return SmiUntag(s);\n+}\n+convert<int32>(s: Smi): int32 {\n+  return SmiToInt32(s);\n+}\n+macro convert<A : type>(h: HeapNumber): A;\n+convert<float64>(h: HeapNumber): float64 {\n+  return LoadHeapNumberValue(h);\n+}\n+macro convert<A : type>(n: Number): A;\n+convert<float64>(n: Number): float64 {\n+  return ChangeNumberToFloat64(n);\n+}\n+macro convert<A : type>(f: float32): A;\n+convert<float64>(f: float32): float64 {\n+  return ChangeFloat32ToFloat64(f);\n+}\n+macro convert<A : type>(d: float64): A;\n+convert<Number>(d: float64): Number {\n+  return AllocateHeapNumberWithValue(d);\n+}\n+convert<uintptr>(d: float64): uintptr {\n+  return ChangeFloat64ToUintPtr(d);\n+}\n+macro convert<A : type>(r: RawPtr): A;\n+convert<uintptr>(r: RawPtr): uintptr {\n+  return Unsigned(r);\n+}\n+convert<intptr>(r: RawPtr): intptr {\n+  return Signed(r);\n+}\n+\n+extern macro UnsafeCastNumberToHeapNumber(Number): HeapNumber;\n+extern macro UnsafeCastObjectToFixedArrayBase(Object): FixedArrayBase;\n+extern macro UnsafeCastObjectToFixedArray(Object): FixedArray;\n+extern macro UnsafeCastObjectToFixedDoubleArray(Object): FixedDoubleArray;\n+extern macro UnsafeCastObjectToHeapNumber(Object): HeapNumber;\n+extern macro UnsafeCastObjectToCallable(Object): Callable;\n+extern macro UnsafeCastObjectToSmi(Object): Smi;\n+extern macro UnsafeCastObjectToNumber(Object): Number;\n+extern macro UnsafeCastObjectToHeapObject(Object): HeapObject;\n+extern macro UnsafeCastObjectToJSArray(Object): JSArray;\n+extern macro UnsafeCastObjectToFixedTypedArrayBase(Object): FixedTypedArrayBase;\n+extern macro UnsafeCastObjectToNumberDictionary(Object): NumberDictionary;\n+extern macro UnsafeCastObjectToJSReceiver(Object): JSReceiver;\n+extern macro UnsafeCastObjectToJSObject(Object): JSObject;\n+extern macro UnsafeCastObjectToMap(Object): Map;\n+\n+macro unsafe_cast<A : type>(n: Number): A;\n+unsafe_cast<HeapNumber>(n: Number): HeapNumber {\n+  return UnsafeCastNumberToHeapNumber(n);\n+}\n+macro unsafe_cast<A : type>(o: Object): A;\n+unsafe_cast<FixedArray>(o: Object): FixedArray {\n+  return UnsafeCastObjectToFixedArray(o);\n+}\n+unsafe_cast<FixedDoubleArray>(o: Object): FixedDoubleArray {\n+  return UnsafeCastObjectToFixedDoubleArray(o);\n+}\n+unsafe_cast<HeapNumber>(o: Object): HeapNumber {\n+  return UnsafeCastObjectToHeapNumber(o);\n+}\n+unsafe_cast<Callable>(o: Object): Callable {\n+  return UnsafeCastObjectToCallable(o);\n+}\n+unsafe_cast<Smi>(o: Object): Smi {\n+  return UnsafeCastObjectToSmi(o);\n+}\n+unsafe_cast<Number>(o: Object): Number {\n+  return UnsafeCastObjectToNumber(o);\n+}\n+unsafe_cast<HeapObject>(o: Object): HeapObject {\n+  return UnsafeCastObjectToHeapObject(o);\n+}\n+unsafe_cast<JSArray>(o: Object): JSArray {\n+  return UnsafeCastObjectToJSArray(o);\n+}\n+unsafe_cast<FixedTypedArrayBase>(o: Object): FixedTypedArrayBase {\n+  return UnsafeCastObjectToFixedTypedArrayBase(o);\n+}\n+unsafe_cast<NumberDictionary>(o: Object): NumberDictionary {\n+  return UnsafeCastObjectToNumberDictionary(o);\n+}\n+unsafe_cast<JSReceiver>(o: Object): JSReceiver {\n+  return UnsafeCastObjectToJSReceiver(o);\n+}\n+unsafe_cast<JSObject>(o: Object): JSObject {\n+  return UnsafeCastObjectToJSObject(o);\n+}\n+unsafe_cast<Map>(o: Object): Map {\n+  return UnsafeCastObjectToMap(o);\n+}\n+unsafe_cast<FixedArrayBase>(o: Object): FixedArrayBase {\n+  return UnsafeCastObjectToFixedArrayBase(o);\n+}\n+\n+const kCOWMap: Map = unsafe_cast<Map>(LoadRoot(kFixedCOWArrayMapRootIndex));\n+const kEmptyFixedArray: FixedArrayBase = unsafe_cast<FixedArrayBase>(\n+    LoadRoot(kEmptyFixedArrayRootIndex));\n \n extern macro BranchIfFastJSArray(Object, Context): never labels Taken, NotTaken;\n extern macro BranchIfNotFastJSArray(Object, Context): never labels Taken,\n@@ -251,28 +595,51 @@ extern operator '.elements_kind' macro LoadMapElementsKind(Map): ElementsKind;\n extern operator\n '.elements_kind' macro LoadElementsKind(JSTypedArray): ElementsKind;\n \n-extern operator '.elements' macro LoadElements(Object): FixedArrayBase;\n-extern operator '.elements=' macro StoreElements(Object, FixedArrayBase);\n+extern operator '.elements' macro LoadElements(JSObject): FixedArrayBase;\n+extern operator '.elements=' macro StoreElements(JSObject, FixedArrayBase);\n \n extern operator '.length' macro LoadTypedArrayLength(JSTypedArray): Smi;\n extern operator '.length' macro LoadJSArrayLength(JSArray): Number;\n+extern operator '.length_fast' macro LoadFastJSArrayLength(JSArray): Smi;\n extern operator '.length=' macro StoreJSArrayLength(JSArray, Smi);\n \n extern operator '.length' macro LoadFixedArrayBaseLength(FixedArrayBase): Smi;\n extern operator '[]' macro LoadFixedArrayElement(FixedArray, intptr): Object;\n extern operator '[]' macro LoadFixedArrayElement(FixedArray, Smi): Object;\n extern operator\n+'[]' macro LoadFixedArrayElementInt(FixedArray, constexpr int31): Object;\n+extern operator\n '[]=' macro StoreFixedArrayElement(FixedArray, intptr, Object): void;\n extern operator\n+'[]=' macro StoreFixedArrayElementInt(\n+    FixedArray, constexpr int31, Object): void;\n+extern operator\n '[]=' macro StoreFixedArrayElementSmi(FixedArray, Smi, Object): void;\n \n+extern operator '.instance_type' macro LoadMapInstanceType(Map): int32;\n+\n+extern macro LoadFixedDoubleArrayElement(FixedDoubleArray, Smi): float64;\n+extern macro Float64SilenceNaN(float64): float64;\n+\n+extern macro StoreFixedDoubleArrayElement(\n+    FixedDoubleArray, Object, float64, constexpr ParameterMode);\n+macro StoreFixedDoubleArrayElementWithSmiIndex(\n+    array: FixedDoubleArray, index: Smi, value: float64) {\n+  StoreFixedDoubleArrayElement(array, index, value, SMI_PARAMETERS);\n+}\n+\n+extern macro BasicLoadNumberDictionaryElement(NumberDictionary, intptr):\n+    Object labels NotData, IfHole;\n+extern macro BasicStoreNumberDictionaryElement(NumberDictionary, intptr, Object)\n+labels NotData, IfHole, ReadOnly;\n+\n extern macro IsFastElementsKind(ElementsKind): bool;\n+extern macro IsDoubleElementsKind(ElementsKind): bool;\n extern macro IsFastSmiOrTaggedElementsKind(ElementsKind): bool;\n extern macro IsFastSmiElementsKind(ElementsKind): bool;\n extern macro IsHoleyFastElementsKind(ElementsKind): bool;\n \n-extern macro AllocateFixedArray(constexpr ElementsKind, Smi): FixedArray;\n-extern macro AllocateFixedArray(constexpr ElementsKind, Smi, Map): FixedArray;\n+extern macro AllocateFixedArray(constexpr ElementsKind, intptr): FixedArray;\n \n extern macro CopyFixedArrayElements(\n     constexpr ElementsKind, FixedArray, constexpr ElementsKind, FixedArray,\n@@ -289,17 +656,19 @@ extern macro IsElementsKindGreaterThan(\n extern macro LoadDoubleWithHoleCheck(FixedDoubleArray, Smi): float64\n labels IfHole;\n \n-extern macro Call(Context, Callable, Object, ...): Object;\n+extern macro Call(Context, Callable, Object): Object;\n+extern macro Call(Context, Callable, Object, Object): Object;\n+extern macro Call(Context, Callable, Object, Object, Object): Object;\n+extern macro Call(Context, Callable, Object, Object, Object, Object): Object;\n+extern macro Call(Context, Callable, Object, Object, Object, Object, Object): Object;\n+extern macro Call(Context, Callable, Object, Object, Object, Object, Object, Object): Object;\n \n extern macro ExtractFixedArray(\n     FixedArray, Smi, Smi, Smi, constexpr ExtractFixedArrayFlags): FixedArray;\n \n extern builtin ExtractFastJSArray(Context, JSArray, Smi, Smi): JSArray;\n \n-macro LoadElementNoHole<T : type>(a: JSArray, index: Smi): Object\n-labels IfHole {\n-  unreachable;\n-}\n+macro LoadElementNoHole<T : type>(a: JSArray, index: Smi): Object labels IfHole;\n \n LoadElementNoHole<FixedArray>(a: JSArray, index: Smi): Object\n labels IfHole {\n@@ -331,15 +700,52 @@ labels IfHole {\n }\n \n macro HasPropertyObject(\n-    o: Object, p: Object, c: Context, f: HasPropertyFlag): Oddball {\n+    o: Object, p: Object, c: Context,\n+    f: constexpr HasPropertyLookupMode): Oddball {\n   try {\n-    return HasProperty(cast<HeapObject>(o) otherwise CastError, p, c, f);\n+    return HasProperty((cast<HeapObject>(o) otherwise CastError), p, c, f);\n   }\n   label CastError {\n     return False;\n   }\n }\n \n extern macro IsCallable(HeapObject): bool;\n+extern macro IsJSArray(HeapObject): bool;\n extern macro TaggedIsCallable(Object): bool;\n extern macro IsDetachedBuffer(JSArrayBuffer): bool;\n+extern macro IsHeapNumber(HeapObject): bool;\n+extern macro IsExtensibleMap(Map): bool;\n+extern macro IsCustomElementsReceiverInstanceType(int32): bool;\n+extern macro Typeof(Object): Object;\n+\n+// Return true iff number is NaN.\n+macro NumberIsNaN(number: Number): bool {\n+  if (TaggedIsSmi(number)) return false;\n+\n+  let value: float64 = convert<float64>(unsafe_cast<HeapNumber>(number));\n+  return value != value;\n+}\n+\n+extern macro BranchIfToBooleanIsTrue(Object): never labels Taken, NotTaken;\n+\n+macro ToBoolean(obj: Object): bool {\n+  if (BranchIfToBooleanIsTrue(obj)) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+macro ToIndex(input: Object, context: Context): Number labels RangeError {\n+  if (input == Undefined) {\n+    return 0;\n+  }\n+\n+  let value: Number = ToInteger_Inline(context, input, kTruncateMinusZero);\n+  if (value < 0 || value > kMaxSafeInteger) {\n+    goto RangeError;\n+  }\n+\n+  return value;\n+}"
        },
        {
            "sha": "d77bc792388642f980eca5593da4deaf1af5f7a5",
            "filename": "deps/v8/src/builtins/builtins-api.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-api.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -64,7 +64,7 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> HandleApiCallHelper(\n         ObjectTemplateInfo::cast(fun_data->instance_template()), isolate);\n     ASSIGN_RETURN_ON_EXCEPTION(\n         isolate, js_receiver,\n-        ApiNatives::InstantiateObject(instance_template,\n+        ApiNatives::InstantiateObject(isolate, instance_template,\n                                       Handle<JSReceiver>::cast(new_target)),\n         Object);\n     args[0] = *js_receiver;\n@@ -80,7 +80,8 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> HandleApiCallHelper(\n       // Proxies never need access checks.\n       DCHECK(js_receiver->IsJSObject());\n       Handle<JSObject> js_obj_receiver = Handle<JSObject>::cast(js_receiver);\n-      if (!isolate->MayAccess(handle(isolate->context()), js_obj_receiver)) {\n+      if (!isolate->MayAccess(handle(isolate->context(), isolate),\n+                              js_obj_receiver)) {\n         isolate->ReportFailedAccessCheck(js_obj_receiver);\n         RETURN_EXCEPTION_IF_SCHEDULED_EXCEPTION(isolate, Object);\n         return isolate->factory()->undefined_value();\n@@ -222,7 +223,8 @@ MaybeHandle<Object> Builtins::InvokeApiFunction(Isolate* isolate,\n     argv[cursor--] = *args[i];\n   }\n   DCHECK_EQ(cursor, BuiltinArguments::kPaddingOffset);\n-  argv[BuiltinArguments::kPaddingOffset] = isolate->heap()->the_hole_value();\n+  argv[BuiltinArguments::kPaddingOffset] =\n+      ReadOnlyRoots(isolate).the_hole_value();\n   argv[BuiltinArguments::kArgcOffset] = Smi::FromInt(frame_argc);\n   argv[BuiltinArguments::kTargetOffset] = *function;\n   argv[BuiltinArguments::kNewTargetOffset] = *new_target;\n@@ -260,7 +262,7 @@ V8_WARN_UNUSED_RESULT static Object* HandleApiCallAsFunctionOrConstructor(\n     // right answer.\n     new_target = obj;\n   } else {\n-    new_target = isolate->heap()->undefined_value();\n+    new_target = ReadOnlyRoots(isolate).undefined_value();\n   }\n \n   // Get the invocation callback from the function descriptor that was\n@@ -284,7 +286,7 @@ V8_WARN_UNUSED_RESULT static Object* HandleApiCallAsFunctionOrConstructor(\n                                      args.length() - 1);\n     Handle<Object> result_handle = custom.Call(call_data);\n     if (result_handle.is_null()) {\n-      result = isolate->heap()->undefined_value();\n+      result = ReadOnlyRoots(isolate).undefined_value();\n     } else {\n       result = *result_handle;\n     }"
        },
        {
            "sha": "09c725fe37aa57d54dfa913e5d35261f0a867d49",
            "filename": "deps/v8/src/builtins/builtins-arguments-gen.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-arguments-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-arguments-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-arguments-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -12,6 +12,7 @@\n #include \"src/frame-constants.h\"\n #include \"src/interface-descriptors.h\"\n #include \"src/objects-inl.h\"\n+#include \"src/objects/arguments.h\"\n \n namespace v8 {\n namespace internal {\n@@ -44,7 +45,7 @@ ArgumentsBuiltinsAssembler::GetArgumentsFrameAndCount(Node* function,\n   CSA_SLOW_ASSERT(this, HasInstanceType(shared, SHARED_FUNCTION_INFO_TYPE));\n   Node* formal_parameter_count =\n       LoadObjectField(shared, SharedFunctionInfo::kFormalParameterCountOffset,\n-                      MachineType::Int32());\n+                      MachineType::Uint16());\n   formal_parameter_count = Int32ToParameter(formal_parameter_count, mode);\n \n   argument_count.Bind(formal_parameter_count);"
        },
        {
            "sha": "fd08639c72cd68cb505ad8e011b14de921cc4462",
            "filename": "deps/v8/src/builtins/builtins-array-gen.cc",
            "status": "modified",
            "additions": 539,
            "deletions": 111,
            "changes": 650,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n+#include \"src/builtins/builtins-array-gen.h\"\n+\n #include \"src/builtins/builtins-iterator-gen.h\"\n #include \"src/builtins/builtins-string-gen.h\"\n #include \"src/builtins/builtins-typed-array-gen.h\"\n@@ -10,8 +12,7 @@\n #include \"src/code-stub-assembler.h\"\n #include \"src/frame-constants.h\"\n #include \"src/heap/factory-inl.h\"\n-\n-#include \"src/builtins/builtins-array-gen.h\"\n+#include \"src/objects/arguments-inl.h\"\n \n namespace v8 {\n namespace internal {\n@@ -211,10 +212,7 @@ Node* ArrayBuiltinsAssembler::FindProcessor(Node* k_value, Node* k) {\n         context(), original_array, length, method_name);\n     // In the Spec and our current implementation, the length check is already\n     // performed in TypedArraySpeciesCreate.\n-    CSA_ASSERT(\n-        this,\n-        SmiLessThanOrEqual(\n-            CAST(len_), CAST(LoadObjectField(a, JSTypedArray::kLengthOffset))));\n+    CSA_ASSERT(this, SmiLessThanOrEqual(CAST(len_), LoadTypedArrayLength(a)));\n     fast_typed_array_target_ =\n         Word32Equal(LoadInstanceType(LoadElements(original_array)),\n                     LoadInstanceType(LoadElements(a)));\n@@ -248,7 +246,7 @@ Node* ArrayBuiltinsAssembler::FindProcessor(Node* k_value, Node* k) {\n         transition_smi_double(this);\n     Label array_not_smi(this), array_fast(this), array_double(this);\n \n-    Node* kind = LoadMapElementsKind(LoadMap(a()));\n+    TNode<Int32T> kind = LoadElementsKind(a());\n     Node* elements = LoadElements(a());\n     GotoIf(IsElementsKindGreaterThan(kind, HOLEY_SMI_ELEMENTS), &array_not_smi);\n     TryStoreArrayElement(HOLEY_SMI_ELEMENTS, mode, &transition_pre, elements, k,\n@@ -296,9 +294,18 @@ Node* ArrayBuiltinsAssembler::FindProcessor(Node* k_value, Node* k) {\n       Node* const native_context = LoadNativeContext(context());\n       Node* const double_map = LoadContextElement(\n           native_context, Context::JS_ARRAY_HOLEY_DOUBLE_ELEMENTS_MAP_INDEX);\n-      CallStub(CodeFactory::TransitionElementsKind(\n-                   isolate(), HOLEY_SMI_ELEMENTS, HOLEY_DOUBLE_ELEMENTS, true),\n-               context(), a(), double_map);\n+\n+      const ElementsKind kFromKind = HOLEY_SMI_ELEMENTS;\n+      const ElementsKind kToKind = HOLEY_DOUBLE_ELEMENTS;\n+      const bool kIsJSArray = true;\n+\n+      Label transition_in_runtime(this, Label::kDeferred);\n+      TransitionElementsKind(a(), double_map, kFromKind, kToKind, kIsJSArray,\n+                             &transition_in_runtime);\n+      Goto(&array_double);\n+\n+      BIND(&transition_in_runtime);\n+      CallRuntime(Runtime::kTransitionElementsKind, context(), a(), double_map);\n       Goto(&array_double);\n     }\n \n@@ -419,28 +426,34 @@ Node* ArrayBuiltinsAssembler::FindProcessor(Node* k_value, Node* k) {\n     GotoIf(DoesntHaveInstanceType(o(), JS_ARRAY_TYPE), &not_js_array);\n     merged_length = LoadJSArrayLength(CAST(o()));\n     Goto(&has_length);\n+\n     BIND(&not_js_array);\n-    Node* len_property =\n-        GetProperty(context(), o(), isolate()->factory()->length_string());\n-    merged_length = ToLength_Inline(context(), len_property);\n-    Goto(&has_length);\n+    {\n+      Node* len_property =\n+          GetProperty(context(), o(), isolate()->factory()->length_string());\n+      merged_length = ToLength_Inline(context(), len_property);\n+      Goto(&has_length);\n+    }\n     BIND(&has_length);\n-    len_ = merged_length.value();\n+    {\n+      len_ = merged_length.value();\n \n-    // 5. If IsCallable(callbackfn) is false, throw a TypeError exception.\n-    Label type_exception(this, Label::kDeferred);\n-    Label done(this);\n-    GotoIf(TaggedIsSmi(callbackfn()), &type_exception);\n-    Branch(IsCallableMap(LoadMap(callbackfn())), &done, &type_exception);\n+      // 5. If IsCallable(callbackfn) is false, throw a TypeError exception.\n+      Label type_exception(this, Label::kDeferred);\n+      Label done(this);\n+      GotoIf(TaggedIsSmi(callbackfn()), &type_exception);\n+      Branch(IsCallableMap(LoadMap(callbackfn())), &done, &type_exception);\n \n-    BIND(&throw_null_undefined_exception);\n-    ThrowTypeError(context(), MessageTemplate::kCalledOnNullOrUndefined, name);\n+      BIND(&throw_null_undefined_exception);\n+      ThrowTypeError(context(), MessageTemplate::kCalledOnNullOrUndefined,\n+                     name);\n \n-    BIND(&type_exception);\n-    ThrowTypeError(context(), MessageTemplate::kCalledNonCallable,\n-                   callbackfn());\n+      BIND(&type_exception);\n+      ThrowTypeError(context(), MessageTemplate::kCalledNonCallable,\n+                     callbackfn());\n \n-    BIND(&done);\n+      BIND(&done);\n+    }\n \n     // 6. If thisArg was supplied, let T be thisArg; else let T be undefined.\n     // [Already done by the arguments adapter]\n@@ -501,7 +514,7 @@ Node* ArrayBuiltinsAssembler::FindProcessor(Node* k_value, Node* k) {\n         LoadObjectField(typed_array, JSTypedArray::kBufferOffset);\n     GotoIf(IsDetachedBuffer(array_buffer), &throw_detached);\n \n-    len_ = LoadObjectField<Smi>(typed_array, JSTypedArray::kLengthOffset);\n+    len_ = LoadTypedArrayLength(typed_array);\n \n     Label throw_not_callable(this, Label::kDeferred);\n     Label distinguish_types(this);\n@@ -545,6 +558,7 @@ Node* ArrayBuiltinsAssembler::FindProcessor(Node* k_value, Node* k) {\n     } else {\n       k_.Bind(NumberDec(len()));\n     }\n+    CSA_ASSERT(this, IsSafeInteger(k()));\n     Node* instance_type = LoadInstanceType(LoadElements(typed_array));\n     Switch(instance_type, &unexpected_instance_type, instance_types.data(),\n            label_ptrs.data(), labels.size());\n@@ -586,10 +600,9 @@ Node* ArrayBuiltinsAssembler::FindProcessor(Node* k_value, Node* k) {\n \n       Label done_element(this, &to_);\n       // a. Let Pk be ToString(k).\n-      // We never have to perform a ToString conversion as the above guards\n-      // guarantee that we have a positive {k} which also is a valid array\n-      // index in the range [0, 2^32-1).\n-      CSA_ASSERT(this, IsNumberArrayIndex(k()));\n+      // k() is guaranteed to be a positive integer, hence ToString is\n+      // side-effect free and HasProperty/GetProperty do the conversion inline.\n+      CSA_ASSERT(this, IsSafeInteger(k()));\n \n       if (missing_property_mode == MissingPropertyMode::kSkip) {\n         // b. Let kPresent be HasProperty(O, Pk).\n@@ -902,9 +915,9 @@ Node* ArrayBuiltinsAssembler::FindProcessor(Node* k_value, Node* k) {\n \n TF_BUILTIN(ArrayPrototypePop, CodeStubAssembler) {\n   TNode<Int32T> argc =\n-      UncheckedCast<Int32T>(Parameter(BuiltinDescriptor::kArgumentsCount));\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n-  CSA_ASSERT(this, IsUndefined(Parameter(BuiltinDescriptor::kNewTarget)));\n+      UncheckedCast<Int32T>(Parameter(Descriptor::kJSActualArgumentsCount));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n+  CSA_ASSERT(this, IsUndefined(Parameter(Descriptor::kJSNewTarget)));\n \n   CodeStubArguments args(this, ChangeInt32ToIntPtr(argc));\n   TNode<Object> receiver = args.GetReceiver();\n@@ -953,7 +966,7 @@ TF_BUILTIN(ArrayPrototypePop, CodeStubAssembler) {\n     StoreObjectFieldNoWriteBarrier(array_receiver, JSArray::kLengthOffset,\n                                    SmiTag(new_length));\n \n-    Node* elements_kind = LoadMapElementsKind(LoadMap(array_receiver));\n+    TNode<Int32T> elements_kind = LoadElementsKind(array_receiver);\n     GotoIf(Int32LessThanOrEqual(elements_kind,\n                                 Int32Constant(TERMINAL_FAST_ELEMENTS_KIND)),\n            &fast_elements);\n@@ -994,10 +1007,12 @@ TF_BUILTIN(ArrayPrototypePop, CodeStubAssembler) {\n \n   BIND(&runtime);\n   {\n-    Node* target = LoadFromFrame(StandardFrameConstants::kFunctionOffset,\n-                                 MachineType::TaggedPointer());\n-    TailCallStub(CodeFactory::ArrayPop(isolate()), context, target,\n-                 UndefinedConstant(), argc);\n+    // We are not using Parameter(Descriptor::kJSTarget) and loading the value\n+    // from the current frame here in order to reduce register pressure on the\n+    // fast path.\n+    TNode<JSFunction> target = LoadTargetFromFrame();\n+    TailCallBuiltin(Builtins::kArrayPop, context, target, UndefinedConstant(),\n+                    argc);\n   }\n }\n \n@@ -1014,9 +1029,9 @@ TF_BUILTIN(ArrayPrototypePush, CodeStubAssembler) {\n   // TODO(ishell): use constants from Descriptor once the JSFunction linkage\n   // arguments are reordered.\n   TNode<Int32T> argc =\n-      UncheckedCast<Int32T>(Parameter(BuiltinDescriptor::kArgumentsCount));\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n-  CSA_ASSERT(this, IsUndefined(Parameter(BuiltinDescriptor::kNewTarget)));\n+      UncheckedCast<Int32T>(Parameter(Descriptor::kJSActualArgumentsCount));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n+  CSA_ASSERT(this, IsUndefined(Parameter(Descriptor::kJSNewTarget)));\n \n   CodeStubArguments args(this, ChangeInt32ToIntPtr(argc));\n   TNode<Object> receiver = args.GetReceiver();\n@@ -1126,10 +1141,12 @@ TF_BUILTIN(ArrayPrototypePush, CodeStubAssembler) {\n \n   BIND(&runtime);\n   {\n-    Node* target = LoadFromFrame(StandardFrameConstants::kFunctionOffset,\n-                                 MachineType::TaggedPointer());\n-    TailCallStub(CodeFactory::ArrayPush(isolate()), context, target,\n-                 UndefinedConstant(), argc);\n+    // We are not using Parameter(Descriptor::kJSTarget) and loading the value\n+    // from the current frame here in order to reduce register pressure on the\n+    // fast path.\n+    TNode<JSFunction> target = LoadTargetFromFrame();\n+    TailCallBuiltin(Builtins::kArrayPush, context, target, UndefinedConstant(),\n+                    argc);\n   }\n }\n \n@@ -1170,8 +1187,8 @@ class ArrayPrototypeSliceCodeStubAssembler : public CodeStubAssembler {\n \n     CSA_ASSERT(this, SmiGreaterThanOrEqual(CAST(from), SmiConstant(0)));\n \n-    result.Bind(CallStub(CodeFactory::ExtractFastJSArray(isolate()), context,\n-                         array, from, count));\n+    result.Bind(CallBuiltin(Builtins::kExtractFastJSArray, context, array, from,\n+                            count));\n     Goto(&done);\n \n     BIND(&try_fast_arguments);\n@@ -1297,8 +1314,8 @@ class ArrayPrototypeSliceCodeStubAssembler : public CodeStubAssembler {\n \n TF_BUILTIN(ArrayPrototypeSlice, ArrayPrototypeSliceCodeStubAssembler) {\n   Node* const argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   Label slow(this, Label::kDeferred), fast_elements_kind(this);\n \n   CodeStubArguments args(this, argc);\n@@ -1326,7 +1343,7 @@ TF_BUILTIN(ArrayPrototypeSlice, ArrayPrototypeSliceCodeStubAssembler) {\n   BIND(&clone);\n \n   args.PopAndReturn(\n-      CallStub(CodeFactory::CloneFastJSArray(isolate()), context, receiver));\n+      CallBuiltin(Builtins::kCloneFastJSArray, context, receiver));\n \n   BIND(&check_arguments_length);\n \n@@ -1472,9 +1489,9 @@ TF_BUILTIN(ArrayPrototypeSlice, ArrayPrototypeSliceCodeStubAssembler) {\n \n TF_BUILTIN(ArrayPrototypeShift, CodeStubAssembler) {\n   TNode<Int32T> argc =\n-      UncheckedCast<Int32T>(Parameter(BuiltinDescriptor::kArgumentsCount));\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n-  CSA_ASSERT(this, IsUndefined(Parameter(BuiltinDescriptor::kNewTarget)));\n+      UncheckedCast<Int32T>(Parameter(Descriptor::kJSActualArgumentsCount));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n+  CSA_ASSERT(this, IsUndefined(Parameter(Descriptor::kJSNewTarget)));\n \n   CodeStubArguments args(this, ChangeInt32ToIntPtr(argc));\n   TNode<Object> receiver = args.GetReceiver();\n@@ -1531,7 +1548,7 @@ TF_BUILTIN(ArrayPrototypeShift, CodeStubAssembler) {\n     StoreObjectFieldNoWriteBarrier(array_receiver, JSArray::kLengthOffset,\n                                    SmiTag(new_length));\n \n-    Node* elements_kind = LoadMapElementsKind(LoadMap(array_receiver));\n+    TNode<Int32T> elements_kind = LoadElementsKind(array_receiver);\n     GotoIf(\n         Int32LessThanOrEqual(elements_kind, Int32Constant(HOLEY_SMI_ELEMENTS)),\n         &fast_elements_smi);\n@@ -1623,10 +1640,12 @@ TF_BUILTIN(ArrayPrototypeShift, CodeStubAssembler) {\n \n   BIND(&runtime);\n   {\n-    Node* target = LoadFromFrame(StandardFrameConstants::kFunctionOffset,\n-                                 MachineType::TaggedPointer());\n-    TailCallStub(CodeFactory::ArrayShift(isolate()), context, target,\n-                 UndefinedConstant(), argc);\n+    // We are not using Parameter(Descriptor::kJSTarget) and loading the value\n+    // from the current frame here in order to reduce register pressure on the\n+    // fast path.\n+    TNode<JSFunction> target = LoadTargetFromFrame();\n+    TailCallBuiltin(Builtins::kArrayShift, context, target, UndefinedConstant(),\n+                    argc);\n   }\n }\n \n@@ -1736,9 +1755,9 @@ TF_BUILTIN(ArrayFindLoopAfterCallbackLazyDeoptContinuation,\n // ES #sec-get-%typedarray%.prototype.find\n TF_BUILTIN(ArrayPrototypeFind, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -1828,9 +1847,9 @@ TF_BUILTIN(ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation,\n // ES #sec-get-%typedarray%.prototype.findIndex\n TF_BUILTIN(ArrayPrototypeFindIndex, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -1988,9 +2007,9 @@ class ArrayPopulatorAssembler : public CodeStubAssembler {\n \n // ES #sec-array.from\n TF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler) {\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Int32T> argc =\n-      UncheckedCast<Int32T>(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      UncheckedCast<Int32T>(Parameter(Descriptor::kJSActualArgumentsCount));\n \n   CodeStubArguments args(this, ChangeInt32ToIntPtr(argc));\n \n@@ -2182,10 +2201,10 @@ TF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler) {\n // ES #sec-array.of\n TF_BUILTIN(ArrayOf, ArrayPopulatorAssembler) {\n   TNode<Int32T> argc =\n-      UncheckedCast<Int32T>(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      UncheckedCast<Int32T>(Parameter(Descriptor::kJSActualArgumentsCount));\n   TNode<Smi> length = SmiFromInt32(argc);\n \n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n \n   CodeStubArguments args(this, length, nullptr, ParameterMode::SMI_PARAMETERS);\n \n@@ -2208,9 +2227,9 @@ TF_BUILTIN(ArrayOf, ArrayPopulatorAssembler) {\n // ES #sec-get-%typedarray%.prototype.find\n TF_BUILTIN(TypedArrayPrototypeFind, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2227,9 +2246,9 @@ TF_BUILTIN(TypedArrayPrototypeFind, ArrayBuiltinsAssembler) {\n // ES #sec-get-%typedarray%.prototype.findIndex\n TF_BUILTIN(TypedArrayPrototypeFindIndex, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2245,9 +2264,9 @@ TF_BUILTIN(TypedArrayPrototypeFindIndex, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(TypedArrayPrototypeForEach, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2325,9 +2344,9 @@ TF_BUILTIN(ArraySomeLoopContinuation, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(ArraySome, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2344,9 +2363,9 @@ TF_BUILTIN(ArraySome, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(TypedArrayPrototypeSome, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2424,9 +2443,9 @@ TF_BUILTIN(ArrayEveryLoopContinuation, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(ArrayEvery, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2443,9 +2462,9 @@ TF_BUILTIN(ArrayEvery, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(TypedArrayPrototypeEvery, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2522,9 +2541,9 @@ TF_BUILTIN(ArrayReduceLoopLazyDeoptContinuation, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(ArrayReduce, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* initial_value = args.GetOptionalArgumentValue(1, TheHoleConstant());\n@@ -2542,9 +2561,9 @@ TF_BUILTIN(ArrayReduce, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(TypedArrayPrototypeReduce, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* initial_value = args.GetOptionalArgumentValue(1, TheHoleConstant());\n@@ -2624,9 +2643,9 @@ TF_BUILTIN(ArrayReduceRightLoopLazyDeoptContinuation, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(ArrayReduceRight, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* initial_value = args.GetOptionalArgumentValue(1, TheHoleConstant());\n@@ -2646,9 +2665,9 @@ TF_BUILTIN(ArrayReduceRight, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(TypedArrayPrototypeReduceRight, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* initial_value = args.GetOptionalArgumentValue(1, TheHoleConstant());\n@@ -2742,9 +2761,9 @@ TF_BUILTIN(ArrayFilterLoopLazyDeoptContinuation, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(ArrayFilter, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2820,9 +2839,9 @@ TF_BUILTIN(ArrayMapLoopLazyDeoptContinuation, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(ArrayMap, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2839,9 +2858,9 @@ TF_BUILTIN(ArrayMap, ArrayBuiltinsAssembler) {\n \n TF_BUILTIN(TypedArrayPrototypeMap, ArrayBuiltinsAssembler) {\n   TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n   TNode<Object> receiver = args.GetReceiver();\n   Node* callbackfn = args.GetOptionalArgumentValue(0);\n   Node* this_arg = args.GetOptionalArgumentValue(1);\n@@ -2887,7 +2906,8 @@ class ArrayIncludesIndexofAssembler : public CodeStubAssembler {\n \n   enum SearchVariant { kIncludes, kIndexOf };\n \n-  void Generate(SearchVariant variant);\n+  void Generate(SearchVariant variant, TNode<IntPtrT> argc,\n+                TNode<Context> context);\n   void GenerateSmiOrObject(SearchVariant variant, Node* context, Node* elements,\n                            Node* search_element, Node* array_length,\n                            Node* from_index);\n@@ -2899,18 +2919,17 @@ class ArrayIncludesIndexofAssembler : public CodeStubAssembler {\n                             Node* from_index);\n };\n \n-void ArrayIncludesIndexofAssembler::Generate(SearchVariant variant) {\n+void ArrayIncludesIndexofAssembler::Generate(SearchVariant variant,\n+                                             TNode<IntPtrT> argc,\n+                                             TNode<Context> context) {\n   const int kSearchElementArg = 0;\n   const int kFromIndexArg = 1;\n \n-  TNode<IntPtrT> argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n   CodeStubArguments args(this, argc);\n \n   TNode<Object> receiver = args.GetReceiver();\n   TNode<Object> search_element =\n       args.GetOptionalArgumentValue(kSearchElementArg);\n-  TNode<Context> context = CAST(Parameter(BuiltinDescriptor::kContext));\n \n   Node* intptr_zero = IntPtrConstant(0);\n \n@@ -2970,7 +2989,7 @@ void ArrayIncludesIndexofAssembler::Generate(SearchVariant variant) {\n \n   Label if_smiorobjects(this), if_packed_doubles(this), if_holey_doubles(this);\n \n-  Node* elements_kind = LoadMapElementsKind(LoadMap(array));\n+  TNode<Int32T> elements_kind = LoadElementsKind(array);\n   Node* elements = LoadElements(array);\n   STATIC_ASSERT(PACKED_SMI_ELEMENTS == 0);\n   STATIC_ASSERT(HOLEY_SMI_ELEMENTS == 1);\n@@ -3375,7 +3394,11 @@ void ArrayIncludesIndexofAssembler::GenerateHoleyDoubles(SearchVariant variant,\n }\n \n TF_BUILTIN(ArrayIncludes, ArrayIncludesIndexofAssembler) {\n-  Generate(kIncludes);\n+  TNode<IntPtrT> argc =\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n+\n+  Generate(kIncludes, argc, context);\n }\n \n TF_BUILTIN(ArrayIncludesSmiOrObject, ArrayIncludesIndexofAssembler) {\n@@ -3409,7 +3432,13 @@ TF_BUILTIN(ArrayIncludesHoleyDoubles, ArrayIncludesIndexofAssembler) {\n                        from_index);\n }\n \n-TF_BUILTIN(ArrayIndexOf, ArrayIncludesIndexofAssembler) { Generate(kIndexOf); }\n+TF_BUILTIN(ArrayIndexOf, ArrayIncludesIndexofAssembler) {\n+  TNode<IntPtrT> argc =\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n+\n+  Generate(kIndexOf, argc, context);\n+}\n \n TF_BUILTIN(ArrayIndexOfSmiOrObject, ArrayIncludesIndexofAssembler) {\n   Node* context = Parameter(Descriptor::kContext);\n@@ -3627,8 +3656,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {\n     Node* buffer = LoadObjectField(array, JSTypedArray::kBufferOffset);\n     GotoIf(IsDetachedBuffer(buffer), &if_detached);\n \n-    TNode<Smi> length =\n-        CAST(LoadObjectField(array, JSTypedArray::kLengthOffset));\n+    TNode<Smi> length = LoadTypedArrayLength(CAST(array));\n \n     GotoIfNot(SmiBelow(CAST(index), length), &set_done);\n \n@@ -3921,12 +3949,12 @@ TF_BUILTIN(FlatMapIntoArray, ArrayFlattenAssembler) {\n                           mapper_function, this_arg));\n }\n \n-// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten\n-TF_BUILTIN(ArrayPrototypeFlatten, CodeStubAssembler) {\n+// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flat\n+TF_BUILTIN(ArrayPrototypeFlat, CodeStubAssembler) {\n   Node* const argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  Node* const context = Parameter(BuiltinDescriptor::kContext);\n+  Node* const context = Parameter(Descriptor::kContext);\n   Node* const receiver = args.GetReceiver();\n   Node* const depth = args.GetOptionalArgumentValue(0);\n \n@@ -3967,9 +3995,9 @@ TF_BUILTIN(ArrayPrototypeFlatten, CodeStubAssembler) {\n // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap\n TF_BUILTIN(ArrayPrototypeFlatMap, CodeStubAssembler) {\n   Node* const argc =\n-      ChangeInt32ToIntPtr(Parameter(BuiltinDescriptor::kArgumentsCount));\n+      ChangeInt32ToIntPtr(Parameter(Descriptor::kJSActualArgumentsCount));\n   CodeStubArguments args(this, argc);\n-  Node* const context = Parameter(BuiltinDescriptor::kContext);\n+  Node* const context = Parameter(Descriptor::kContext);\n   Node* const receiver = args.GetReceiver();\n   Node* const mapper_function = args.GetOptionalArgumentValue(0);\n \n@@ -4005,5 +4033,405 @@ TF_BUILTIN(ArrayPrototypeFlatMap, CodeStubAssembler) {\n   { ThrowTypeError(context, MessageTemplate::kMapperFunctionNonCallable); }\n }\n \n+TF_BUILTIN(ArrayConstructor, ArrayBuiltinsAssembler) {\n+  // This is a trampoline to ArrayConstructorImpl which just adds\n+  // allocation_site parameter value and sets new_target if necessary.\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n+  TNode<JSFunction> function = CAST(Parameter(Descriptor::kTarget));\n+  TNode<Object> new_target = CAST(Parameter(Descriptor::kNewTarget));\n+  TNode<Int32T> argc =\n+      UncheckedCast<Int32T>(Parameter(Descriptor::kActualArgumentsCount));\n+\n+  // If new_target is undefined, then this is the 'Call' case, so set new_target\n+  // to function.\n+  new_target =\n+      SelectConstant<Object>(IsUndefined(new_target), function, new_target);\n+\n+  // Run the native code for the Array function called as a normal function.\n+  TNode<Object> no_allocation_site = UndefinedConstant();\n+  TailCallBuiltin(Builtins::kArrayConstructorImpl, context, function,\n+                  new_target, argc, no_allocation_site);\n+}\n+\n+void ArrayBuiltinsAssembler::TailCallArrayConstructorStub(\n+    const Callable& callable, TNode<Context> context, TNode<JSFunction> target,\n+    TNode<HeapObject> allocation_site_or_undefined, TNode<Int32T> argc) {\n+  TNode<Code> code = HeapConstant(callable.code());\n+\n+  // We are going to call here ArrayNoArgumentsConstructor or\n+  // ArraySingleArgumentsConstructor which in addition to the register arguments\n+  // also expect some number of arguments on the expression stack.\n+  // Since\n+  // 1) incoming JS arguments are still on the stack,\n+  // 2) the ArrayNoArgumentsConstructor, ArraySingleArgumentsConstructor and\n+  //    ArrayNArgumentsConstructor are defined so that the register arguments\n+  //    are passed on the same registers,\n+  // in order to be able to generate a tail call to those builtins we do the\n+  // following trick here: we tail call to the constructor builtin using\n+  // ArrayNArgumentsConstructorDescriptor, so the tail call instruction\n+  // pops the current frame but leaves all the incoming JS arguments on the\n+  // expression stack so that the target builtin can still find them where it\n+  // expects.\n+  TailCallStub(ArrayNArgumentsConstructorDescriptor{}, code, context, target,\n+               allocation_site_or_undefined, argc);\n+}\n+\n+void ArrayBuiltinsAssembler::CreateArrayDispatchNoArgument(\n+    TNode<Context> context, TNode<JSFunction> target, TNode<Int32T> argc,\n+    AllocationSiteOverrideMode mode, TNode<AllocationSite> allocation_site) {\n+  if (mode == DISABLE_ALLOCATION_SITES) {\n+    Callable callable = CodeFactory::ArrayNoArgumentConstructor(\n+        isolate(), GetInitialFastElementsKind(), mode);\n+\n+    TailCallArrayConstructorStub(callable, context, target, UndefinedConstant(),\n+                                 argc);\n+  } else {\n+    DCHECK_EQ(mode, DONT_OVERRIDE);\n+    TNode<Int32T> elements_kind = LoadElementsKind(allocation_site);\n+\n+    // TODO(ishell): Compute the builtin index dynamically instead of\n+    // iterating over all expected elements kinds.\n+    int last_index =\n+        GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);\n+    for (int i = 0; i <= last_index; ++i) {\n+      Label next(this);\n+      ElementsKind kind = GetFastElementsKindFromSequenceIndex(i);\n+      GotoIfNot(Word32Equal(elements_kind, Int32Constant(kind)), &next);\n+\n+      Callable callable =\n+          CodeFactory::ArrayNoArgumentConstructor(isolate(), kind, mode);\n+\n+      TailCallArrayConstructorStub(callable, context, target, allocation_site,\n+                                   argc);\n+\n+      BIND(&next);\n+    }\n+\n+    // If we reached this point there is a problem.\n+    Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n+  }\n+}\n+\n+void ArrayBuiltinsAssembler::CreateArrayDispatchSingleArgument(\n+    TNode<Context> context, TNode<JSFunction> target, TNode<Int32T> argc,\n+    AllocationSiteOverrideMode mode, TNode<AllocationSite> allocation_site) {\n+  if (mode == DISABLE_ALLOCATION_SITES) {\n+    ElementsKind initial = GetInitialFastElementsKind();\n+    ElementsKind holey_initial = GetHoleyElementsKind(initial);\n+    Callable callable = CodeFactory::ArraySingleArgumentConstructor(\n+        isolate(), holey_initial, mode);\n+\n+    TailCallArrayConstructorStub(callable, context, target, UndefinedConstant(),\n+                                 argc);\n+  } else {\n+    DCHECK_EQ(mode, DONT_OVERRIDE);\n+    TNode<Smi> transition_info = LoadTransitionInfo(allocation_site);\n+\n+    // Least significant bit in fast array elements kind means holeyness.\n+    STATIC_ASSERT(PACKED_SMI_ELEMENTS == 0);\n+    STATIC_ASSERT(HOLEY_SMI_ELEMENTS == 1);\n+    STATIC_ASSERT(PACKED_ELEMENTS == 2);\n+    STATIC_ASSERT(HOLEY_ELEMENTS == 3);\n+    STATIC_ASSERT(PACKED_DOUBLE_ELEMENTS == 4);\n+    STATIC_ASSERT(HOLEY_DOUBLE_ELEMENTS == 5);\n+\n+    Label normal_sequence(this);\n+    TVARIABLE(Int32T, var_elements_kind,\n+              Signed(DecodeWord32<AllocationSite::ElementsKindBits>(\n+                  SmiToInt32(transition_info))));\n+    // Is the low bit set? If so, we are holey and that is good.\n+    int fast_elements_kind_holey_mask =\n+        AllocationSite::ElementsKindBits::encode(static_cast<ElementsKind>(1));\n+    GotoIf(IsSetSmi(transition_info, fast_elements_kind_holey_mask),\n+           &normal_sequence);\n+    {\n+      // Make elements kind holey and update elements kind in the type info.\n+      var_elements_kind =\n+          Signed(Word32Or(var_elements_kind.value(), Int32Constant(1)));\n+      StoreObjectFieldNoWriteBarrier(\n+          allocation_site, AllocationSite::kTransitionInfoOrBoilerplateOffset,\n+          SmiOr(transition_info, SmiConstant(fast_elements_kind_holey_mask)));\n+      Goto(&normal_sequence);\n+    }\n+    BIND(&normal_sequence);\n+\n+    // TODO(ishell): Compute the builtin index dynamically instead of\n+    // iterating over all expected elements kinds.\n+    // TODO(ishell): Given that the code above ensures that the elements kind\n+    // is holey we can skip checking with non-holey elements kinds.\n+    int last_index =\n+        GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);\n+    for (int i = 0; i <= last_index; ++i) {\n+      Label next(this);\n+      ElementsKind kind = GetFastElementsKindFromSequenceIndex(i);\n+      GotoIfNot(Word32Equal(var_elements_kind.value(), Int32Constant(kind)),\n+                &next);\n+\n+      Callable callable =\n+          CodeFactory::ArraySingleArgumentConstructor(isolate(), kind, mode);\n+\n+      TailCallArrayConstructorStub(callable, context, target, allocation_site,\n+                                   argc);\n+\n+      BIND(&next);\n+    }\n+\n+    // If we reached this point there is a problem.\n+    Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);\n+  }\n+}\n+\n+void ArrayBuiltinsAssembler::GenerateDispatchToArrayStub(\n+    TNode<Context> context, TNode<JSFunction> target, TNode<Int32T> argc,\n+    AllocationSiteOverrideMode mode, TNode<AllocationSite> allocation_site) {\n+  Label check_one_case(this), fallthrough(this);\n+  GotoIfNot(Word32Equal(argc, Int32Constant(0)), &check_one_case);\n+  CreateArrayDispatchNoArgument(context, target, argc, mode, allocation_site);\n+\n+  BIND(&check_one_case);\n+  GotoIfNot(Word32Equal(argc, Int32Constant(1)), &fallthrough);\n+  CreateArrayDispatchSingleArgument(context, target, argc, mode,\n+                                    allocation_site);\n+\n+  BIND(&fallthrough);\n+}\n+\n+TF_BUILTIN(ArrayConstructorImpl, ArrayBuiltinsAssembler) {\n+  TNode<JSFunction> target = CAST(Parameter(Descriptor::kTarget));\n+  TNode<Object> new_target = CAST(Parameter(Descriptor::kNewTarget));\n+  TNode<Int32T> argc =\n+      UncheckedCast<Int32T>(Parameter(Descriptor::kActualArgumentsCount));\n+  TNode<HeapObject> maybe_allocation_site =\n+      CAST(Parameter(Descriptor::kAllocationSite));\n+\n+  // Initial map for the builtin Array functions should be Map.\n+  CSA_ASSERT(this, IsMap(CAST(LoadObjectField(\n+                       target, JSFunction::kPrototypeOrInitialMapOffset))));\n+\n+  // We should either have undefined or a valid AllocationSite\n+  CSA_ASSERT(this, Word32Or(IsUndefined(maybe_allocation_site),\n+                            IsAllocationSite(maybe_allocation_site)));\n+\n+  // \"Enter\" the context of the Array function.\n+  TNode<Context> context =\n+      CAST(LoadObjectField(target, JSFunction::kContextOffset));\n+\n+  Label runtime(this, Label::kDeferred);\n+  GotoIf(WordNotEqual(target, new_target), &runtime);\n+\n+  Label no_info(this);\n+  // If the feedback vector is the undefined value call an array constructor\n+  // that doesn't use AllocationSites.\n+  GotoIf(IsUndefined(maybe_allocation_site), &no_info);\n+\n+  GenerateDispatchToArrayStub(context, target, argc, DONT_OVERRIDE,\n+                              CAST(maybe_allocation_site));\n+  Goto(&runtime);\n+\n+  BIND(&no_info);\n+  GenerateDispatchToArrayStub(context, target, argc, DISABLE_ALLOCATION_SITES);\n+  Goto(&runtime);\n+\n+  BIND(&runtime);\n+  GenerateArrayNArgumentsConstructor(context, target, new_target, argc,\n+                                     maybe_allocation_site);\n+}\n+\n+void ArrayBuiltinsAssembler::GenerateConstructor(\n+    Node* context, Node* array_function, Node* array_map, Node* array_size,\n+    Node* allocation_site, ElementsKind elements_kind,\n+    AllocationSiteMode mode) {\n+  Label ok(this);\n+  Label smi_size(this);\n+  Label small_smi_size(this);\n+  Label call_runtime(this, Label::kDeferred);\n+\n+  Branch(TaggedIsSmi(array_size), &smi_size, &call_runtime);\n+\n+  BIND(&smi_size);\n+\n+  if (IsFastPackedElementsKind(elements_kind)) {\n+    Label abort(this, Label::kDeferred);\n+    Branch(SmiEqual(CAST(array_size), SmiConstant(0)), &small_smi_size, &abort);\n+\n+    BIND(&abort);\n+    Node* reason = SmiConstant(AbortReason::kAllocatingNonEmptyPackedArray);\n+    TailCallRuntime(Runtime::kAbort, context, reason);\n+  } else {\n+    int element_size =\n+        IsDoubleElementsKind(elements_kind) ? kDoubleSize : kPointerSize;\n+    int max_fast_elements =\n+        (kMaxRegularHeapObjectSize - FixedArray::kHeaderSize - JSArray::kSize -\n+         AllocationMemento::kSize) /\n+        element_size;\n+    Branch(SmiAboveOrEqual(CAST(array_size), SmiConstant(max_fast_elements)),\n+           &call_runtime, &small_smi_size);\n+  }\n+\n+  BIND(&small_smi_size);\n+  {\n+    Node* array = AllocateJSArray(\n+        elements_kind, array_map, array_size, array_size,\n+        mode == DONT_TRACK_ALLOCATION_SITE ? nullptr : allocation_site,\n+        CodeStubAssembler::SMI_PARAMETERS);\n+    Return(array);\n+  }\n+\n+  BIND(&call_runtime);\n+  {\n+    TailCallRuntime(Runtime::kNewArray, context, array_function, array_size,\n+                    array_function, allocation_site);\n+  }\n+}\n+\n+void ArrayBuiltinsAssembler::GenerateArrayNoArgumentConstructor(\n+    ElementsKind kind, AllocationSiteOverrideMode mode) {\n+  typedef ArrayNoArgumentConstructorDescriptor Descriptor;\n+  Node* native_context = LoadObjectField(Parameter(Descriptor::kFunction),\n+                                         JSFunction::kContextOffset);\n+  bool track_allocation_site =\n+      AllocationSite::ShouldTrack(kind) && mode != DISABLE_ALLOCATION_SITES;\n+  Node* allocation_site =\n+      track_allocation_site ? Parameter(Descriptor::kAllocationSite) : nullptr;\n+  Node* array_map = LoadJSArrayElementsMap(kind, native_context);\n+  Node* array = AllocateJSArray(\n+      kind, array_map, IntPtrConstant(JSArray::kPreallocatedArrayElements),\n+      SmiConstant(0), allocation_site);\n+  Return(array);\n+}\n+\n+void ArrayBuiltinsAssembler::GenerateArraySingleArgumentConstructor(\n+    ElementsKind kind, AllocationSiteOverrideMode mode) {\n+  typedef ArraySingleArgumentConstructorDescriptor Descriptor;\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* function = Parameter(Descriptor::kFunction);\n+  Node* native_context = LoadObjectField(function, JSFunction::kContextOffset);\n+  Node* array_map = LoadJSArrayElementsMap(kind, native_context);\n+\n+  AllocationSiteMode allocation_site_mode = DONT_TRACK_ALLOCATION_SITE;\n+  if (mode == DONT_OVERRIDE) {\n+    allocation_site_mode = AllocationSite::ShouldTrack(kind)\n+                               ? TRACK_ALLOCATION_SITE\n+                               : DONT_TRACK_ALLOCATION_SITE;\n+  }\n+\n+  Node* array_size = Parameter(Descriptor::kArraySizeSmiParameter);\n+  Node* allocation_site = Parameter(Descriptor::kAllocationSite);\n+\n+  GenerateConstructor(context, function, array_map, array_size, allocation_site,\n+                      kind, allocation_site_mode);\n+}\n+\n+void ArrayBuiltinsAssembler::GenerateArrayNArgumentsConstructor(\n+    TNode<Context> context, TNode<JSFunction> target, TNode<Object> new_target,\n+    TNode<Int32T> argc, TNode<HeapObject> maybe_allocation_site) {\n+  // Replace incoming JS receiver argument with the target.\n+  // TODO(ishell): Avoid replacing the target on the stack and just add it\n+  // as another additional parameter for Runtime::kNewArray.\n+  CodeStubArguments args(this, ChangeInt32ToIntPtr(argc));\n+  args.SetReceiver(target);\n+\n+  // Adjust arguments count for the runtime call: +1 for implicit receiver\n+  // and +2 for new_target and maybe_allocation_site.\n+  argc = Int32Add(argc, Int32Constant(3));\n+  TailCallRuntime(Runtime::kNewArray, argc, context, new_target,\n+                  maybe_allocation_site);\n+}\n+\n+TF_BUILTIN(ArrayNArgumentsConstructor, ArrayBuiltinsAssembler) {\n+  TNode<Context> context = CAST(Parameter(Descriptor::kContext));\n+  TNode<JSFunction> target = CAST(Parameter(Descriptor::kFunction));\n+  TNode<Int32T> argc =\n+      UncheckedCast<Int32T>(Parameter(Descriptor::kActualArgumentsCount));\n+  TNode<HeapObject> maybe_allocation_site =\n+      CAST(Parameter(Descriptor::kAllocationSite));\n+\n+  GenerateArrayNArgumentsConstructor(context, target, target, argc,\n+                                     maybe_allocation_site);\n+}\n+\n+void ArrayBuiltinsAssembler::GenerateInternalArrayNoArgumentConstructor(\n+    ElementsKind kind) {\n+  typedef ArrayNoArgumentConstructorDescriptor Descriptor;\n+  Node* array_map = LoadObjectField(Parameter(Descriptor::kFunction),\n+                                    JSFunction::kPrototypeOrInitialMapOffset);\n+  Node* array = AllocateJSArray(\n+      kind, array_map, IntPtrConstant(JSArray::kPreallocatedArrayElements),\n+      SmiConstant(0));\n+  Return(array);\n+}\n+\n+void ArrayBuiltinsAssembler::GenerateInternalArraySingleArgumentConstructor(\n+    ElementsKind kind) {\n+  typedef ArraySingleArgumentConstructorDescriptor Descriptor;\n+  Node* context = Parameter(Descriptor::kContext);\n+  Node* function = Parameter(Descriptor::kFunction);\n+  Node* array_map =\n+      LoadObjectField(function, JSFunction::kPrototypeOrInitialMapOffset);\n+  Node* array_size = Parameter(Descriptor::kArraySizeSmiParameter);\n+  Node* allocation_site = UndefinedConstant();\n+\n+  GenerateConstructor(context, function, array_map, array_size, allocation_site,\n+                      kind, DONT_TRACK_ALLOCATION_SITE);\n+}\n+\n+#define GENERATE_ARRAY_CTOR(name, kind_camel, kind_caps, mode_camel, \\\n+                            mode_caps)                               \\\n+  TF_BUILTIN(Array##name##Constructor_##kind_camel##_##mode_camel,   \\\n+             ArrayBuiltinsAssembler) {                               \\\n+    GenerateArray##name##Constructor(kind_caps, mode_caps);          \\\n+  }\n+\n+// The ArrayNoArgumentConstructor builtin family.\n+GENERATE_ARRAY_CTOR(NoArgument, PackedSmi, PACKED_SMI_ELEMENTS, DontOverride,\n+                    DONT_OVERRIDE);\n+GENERATE_ARRAY_CTOR(NoArgument, HoleySmi, HOLEY_SMI_ELEMENTS, DontOverride,\n+                    DONT_OVERRIDE);\n+GENERATE_ARRAY_CTOR(NoArgument, PackedSmi, PACKED_SMI_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(NoArgument, HoleySmi, HOLEY_SMI_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(NoArgument, Packed, PACKED_ELEMENTS, DisableAllocationSites,\n+                    DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(NoArgument, Holey, HOLEY_ELEMENTS, DisableAllocationSites,\n+                    DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(NoArgument, PackedDouble, PACKED_DOUBLE_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(NoArgument, HoleyDouble, HOLEY_DOUBLE_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+\n+// The ArraySingleArgumentConstructor builtin family.\n+GENERATE_ARRAY_CTOR(SingleArgument, PackedSmi, PACKED_SMI_ELEMENTS,\n+                    DontOverride, DONT_OVERRIDE);\n+GENERATE_ARRAY_CTOR(SingleArgument, HoleySmi, HOLEY_SMI_ELEMENTS, DontOverride,\n+                    DONT_OVERRIDE);\n+GENERATE_ARRAY_CTOR(SingleArgument, PackedSmi, PACKED_SMI_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(SingleArgument, HoleySmi, HOLEY_SMI_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(SingleArgument, Packed, PACKED_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(SingleArgument, Holey, HOLEY_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(SingleArgument, PackedDouble, PACKED_DOUBLE_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+GENERATE_ARRAY_CTOR(SingleArgument, HoleyDouble, HOLEY_DOUBLE_ELEMENTS,\n+                    DisableAllocationSites, DISABLE_ALLOCATION_SITES);\n+\n+#undef GENERATE_ARRAY_CTOR\n+\n+#define GENERATE_INTERNAL_ARRAY_CTOR(name, kind_camel, kind_caps) \\\n+  TF_BUILTIN(InternalArray##name##Constructor_##kind_camel,       \\\n+             ArrayBuiltinsAssembler) {                            \\\n+    GenerateInternalArray##name##Constructor(kind_caps);          \\\n+  }\n+\n+GENERATE_INTERNAL_ARRAY_CTOR(NoArgument, Packed, PACKED_ELEMENTS);\n+GENERATE_INTERNAL_ARRAY_CTOR(NoArgument, Holey, HOLEY_ELEMENTS);\n+GENERATE_INTERNAL_ARRAY_CTOR(SingleArgument, Packed, PACKED_ELEMENTS);\n+GENERATE_INTERNAL_ARRAY_CTOR(SingleArgument, Holey, HOLEY_ELEMENTS);\n+\n+#undef GENERATE_INTERNAL_ARRAY_CTOR\n+\n }  // namespace internal\n }  // namespace v8"
        },
        {
            "sha": "92b32115a009a2b09f5a1ca1efbd9fe1f805ce4f",
            "filename": "deps/v8/src/builtins/builtins-array-gen.h",
            "status": "modified",
            "additions": 45,
            "deletions": 1,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -68,6 +68,15 @@ class ArrayBuiltinsAssembler : public BaseBuiltinsFromDSLAssembler {\n \n   void NullPostLoopAction();\n \n+  // TODO(szuend): Remove once overload resolution is fixed in Torque.\n+  TNode<Object> LoadFixedArrayElementInt(TNode<FixedArray> array, int index) {\n+    return LoadFixedArrayElement(array, index);\n+  }\n+  Node* StoreFixedArrayElementInt(TNode<FixedArray> array, int index,\n+                                  TNode<Object> value) {\n+    return StoreFixedArrayElement(array, index, value);\n+  }\n+\n  protected:\n   TNode<Context> context() { return context_; }\n   TNode<Object> receiver() { return receiver_; }\n@@ -76,7 +85,7 @@ class ArrayBuiltinsAssembler : public BaseBuiltinsFromDSLAssembler {\n   TNode<Number> len() { return len_; }\n   Node* callbackfn() { return callbackfn_; }\n   Node* this_arg() { return this_arg_; }\n-  Node* k() { return k_.value(); }\n+  TNode<Number> k() { return CAST(k_.value()); }\n   Node* a() { return a_.value(); }\n \n   void ReturnFromBuiltin(Node* value);\n@@ -106,6 +115,41 @@ class ArrayBuiltinsAssembler : public BaseBuiltinsFromDSLAssembler {\n       MissingPropertyMode missing_property_mode,\n       ForEachDirection direction = ForEachDirection::kForward);\n \n+  void TailCallArrayConstructorStub(\n+      const Callable& callable, TNode<Context> context,\n+      TNode<JSFunction> target, TNode<HeapObject> allocation_site_or_undefined,\n+      TNode<Int32T> argc);\n+\n+  void GenerateDispatchToArrayStub(\n+      TNode<Context> context, TNode<JSFunction> target, TNode<Int32T> argc,\n+      AllocationSiteOverrideMode mode,\n+      TNode<AllocationSite> allocation_site = TNode<AllocationSite>());\n+\n+  void CreateArrayDispatchNoArgument(\n+      TNode<Context> context, TNode<JSFunction> target, TNode<Int32T> argc,\n+      AllocationSiteOverrideMode mode,\n+      TNode<AllocationSite> allocation_site = TNode<AllocationSite>());\n+\n+  void CreateArrayDispatchSingleArgument(\n+      TNode<Context> context, TNode<JSFunction> target, TNode<Int32T> argc,\n+      AllocationSiteOverrideMode mode,\n+      TNode<AllocationSite> allocation_site = TNode<AllocationSite>());\n+\n+  void GenerateConstructor(Node* context, Node* array_function, Node* array_map,\n+                           Node* array_size, Node* allocation_site,\n+                           ElementsKind elements_kind, AllocationSiteMode mode);\n+  void GenerateArrayNoArgumentConstructor(ElementsKind kind,\n+                                          AllocationSiteOverrideMode mode);\n+  void GenerateArraySingleArgumentConstructor(ElementsKind kind,\n+                                              AllocationSiteOverrideMode mode);\n+  void GenerateArrayNArgumentsConstructor(\n+      TNode<Context> context, TNode<JSFunction> target,\n+      TNode<Object> new_target, TNode<Int32T> argc,\n+      TNode<HeapObject> maybe_allocation_site);\n+\n+  void GenerateInternalArrayNoArgumentConstructor(ElementsKind kind);\n+  void GenerateInternalArraySingleArgumentConstructor(ElementsKind kind);\n+\n  private:\n   static ElementsKind ElementsKindForInstanceType(InstanceType type);\n "
        },
        {
            "sha": "5154b904f5fda9e96b846f06550760cc2a5fbeb0",
            "filename": "deps/v8/src/builtins/builtins-array.cc",
            "status": "modified",
            "additions": 166,
            "deletions": 41,
            "changes": 207,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-array.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -141,46 +141,168 @@ V8_WARN_UNUSED_RESULT static Object* CallJsIntrinsic(\n       isolate,\n       Execution::Call(isolate, function, args.receiver(), argc, argv.start()));\n }\n+\n+V8_WARN_UNUSED_RESULT Object* GenericArrayPush(Isolate* isolate,\n+                                               BuiltinArguments* args) {\n+  // 1. Let O be ? ToObject(this value).\n+  Handle<JSReceiver> receiver;\n+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(\n+      isolate, receiver, Object::ToObject(isolate, args->receiver()));\n+\n+  // 2. Let len be ? ToLength(? Get(O, \"length\")).\n+  Handle<Object> raw_length_number;\n+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(\n+      isolate, raw_length_number,\n+      Object::GetLengthFromArrayLike(isolate, Handle<Object>::cast(receiver)));\n+\n+  // 3. Let args be a List whose elements are, in left to right order,\n+  //    the arguments that were passed to this function invocation.\n+  // 4. Let arg_count be the number of elements in args.\n+  int arg_count = args->length() - 1;\n+\n+  // 5. If len + arg_count > 2^53-1, throw a TypeError exception.\n+  double length = raw_length_number->Number();\n+  if (arg_count > kMaxSafeInteger - length) {\n+    THROW_NEW_ERROR_RETURN_FAILURE(\n+        isolate, NewTypeError(MessageTemplate::kPushPastSafeLength,\n+                              isolate->factory()->NewNumberFromInt(arg_count),\n+                              raw_length_number));\n+  }\n+\n+  // 6. Repeat, while args is not empty.\n+  for (int i = 0; i < arg_count; ++i) {\n+    // a. Remove the first element from args and let E be the value of the\n+    //    element.\n+    Handle<Object> element = args->at(i + 1);\n+\n+    // b. Perform ? Set(O, ! ToString(len), E, true).\n+    if (length <= static_cast<double>(JSArray::kMaxArrayIndex)) {\n+      RETURN_FAILURE_ON_EXCEPTION(\n+          isolate, Object::SetElement(isolate, receiver, length, element,\n+                                      LanguageMode::kStrict));\n+    } else {\n+      bool success;\n+      LookupIterator it = LookupIterator::PropertyOrElement(\n+          isolate, receiver, isolate->factory()->NewNumber(length), &success);\n+      // Must succeed since we always pass a valid key.\n+      DCHECK(success);\n+      MAYBE_RETURN(Object::SetProperty(&it, element, LanguageMode::kStrict,\n+                                       Object::MAY_BE_STORE_FROM_KEYED),\n+                   ReadOnlyRoots(isolate).exception());\n+    }\n+\n+    // c. Let len be len+1.\n+    ++length;\n+  }\n+\n+  // 7. Perform ? Set(O, \"length\", len, true).\n+  Handle<Object> final_length = isolate->factory()->NewNumber(length);\n+  RETURN_FAILURE_ON_EXCEPTION(\n+      isolate, Object::SetProperty(isolate, receiver,\n+                                   isolate->factory()->length_string(),\n+                                   final_length, LanguageMode::kStrict));\n+\n+  // 8. Return len.\n+  return *final_length;\n+}\n }  // namespace\n \n BUILTIN(ArrayPush) {\n   HandleScope scope(isolate);\n   Handle<Object> receiver = args.receiver();\n   if (!EnsureJSArrayWithWritableFastElements(isolate, receiver, &args, 1)) {\n-    return CallJsIntrinsic(isolate, isolate->array_push(), args);\n+    return GenericArrayPush(isolate, &args);\n   }\n+\n   // Fast Elements Path\n   int to_add = args.length() - 1;\n   Handle<JSArray> array = Handle<JSArray>::cast(receiver);\n-  int len = Smi::ToInt(array->length());\n-  if (to_add == 0) return Smi::FromInt(len);\n+  uint32_t len = static_cast<uint32_t>(array->length()->Number());\n+  if (to_add == 0) return *isolate->factory()->NewNumberFromUint(len);\n \n   // Currently fixed arrays cannot grow too big, so we should never hit this.\n   DCHECK_LE(to_add, Smi::kMaxValue - Smi::ToInt(array->length()));\n \n   if (JSArray::HasReadOnlyLength(array)) {\n-    return CallJsIntrinsic(isolate, isolate->array_push(), args);\n+    return GenericArrayPush(isolate, &args);\n   }\n \n   ElementsAccessor* accessor = array->GetElementsAccessor();\n-  int new_length = accessor->Push(array, &args, to_add);\n-  return Smi::FromInt(new_length);\n+  uint32_t new_length = accessor->Push(array, &args, to_add);\n+  return *isolate->factory()->NewNumberFromUint((new_length));\n }\n \n+namespace {\n+\n+V8_WARN_UNUSED_RESULT Object* GenericArrayPop(Isolate* isolate,\n+                                              BuiltinArguments* args) {\n+  // 1. Let O be ? ToObject(this value).\n+  Handle<JSReceiver> receiver;\n+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(\n+      isolate, receiver, Object::ToObject(isolate, args->receiver()));\n+\n+  // 2. Let len be ? ToLength(? Get(O, \"length\")).\n+  Handle<Object> raw_length_number;\n+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(\n+      isolate, raw_length_number,\n+      Object::GetLengthFromArrayLike(isolate, receiver));\n+  double length = raw_length_number->Number();\n+\n+  // 3. If len is zero, then.\n+  if (length == 0) {\n+    // a. Perform ? Set(O, \"length\", 0, true).\n+    RETURN_FAILURE_ON_EXCEPTION(\n+        isolate, Object::SetProperty(\n+                     isolate, receiver, isolate->factory()->length_string(),\n+                     Handle<Smi>(Smi::kZero, isolate), LanguageMode::kStrict));\n+\n+    // b. Return undefined.\n+    return ReadOnlyRoots(isolate).undefined_value();\n+  }\n+\n+  // 4. Else len > 0.\n+  // a. Let new_len be len-1.\n+  Handle<Object> new_length = isolate->factory()->NewNumber(length - 1);\n+\n+  // b. Let index be ! ToString(newLen).\n+  Handle<String> index = isolate->factory()->NumberToString(new_length);\n+\n+  // c. Let element be ? Get(O, index).\n+  Handle<Object> element;\n+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(\n+      isolate, element,\n+      JSReceiver::GetPropertyOrElement(isolate, receiver, index));\n+\n+  // d. Perform ? DeletePropertyOrThrow(O, index).\n+  MAYBE_RETURN(JSReceiver::DeletePropertyOrElement(receiver, index,\n+                                                   LanguageMode::kStrict),\n+               ReadOnlyRoots(isolate).exception());\n+\n+  // e. Perform ? Set(O, \"length\", newLen, true).\n+  RETURN_FAILURE_ON_EXCEPTION(\n+      isolate, Object::SetProperty(isolate, receiver,\n+                                   isolate->factory()->length_string(),\n+                                   new_length, LanguageMode::kStrict));\n+\n+  // f. Return element.\n+  return *element;\n+}\n+\n+}  // namespace\n+\n BUILTIN(ArrayPop) {\n   HandleScope scope(isolate);\n   Handle<Object> receiver = args.receiver();\n   if (!EnsureJSArrayWithWritableFastElements(isolate, receiver, nullptr, 0)) {\n-    return CallJsIntrinsic(isolate, isolate->array_pop(), args);\n+    return GenericArrayPop(isolate, &args);\n   }\n-\n   Handle<JSArray> array = Handle<JSArray>::cast(receiver);\n \n-  uint32_t len = static_cast<uint32_t>(Smi::ToInt(array->length()));\n-  if (len == 0) return isolate->heap()->undefined_value();\n+  uint32_t len = static_cast<uint32_t>(array->length()->Number());\n+  if (len == 0) return ReadOnlyRoots(isolate).undefined_value();\n \n   if (JSArray::HasReadOnlyLength(array)) {\n-    return CallJsIntrinsic(isolate, isolate->array_pop(), args);\n+    return GenericArrayPop(isolate, &args);\n   }\n \n   Handle<Object> result;\n@@ -194,6 +316,7 @@ BUILTIN(ArrayPop) {\n         isolate, result, JSReceiver::GetElement(isolate, array, new_length));\n     JSArray::SetLength(array, new_length);\n   }\n+\n   return *result;\n }\n \n@@ -208,7 +331,7 @@ BUILTIN(ArrayShift) {\n   Handle<JSArray> array = Handle<JSArray>::cast(receiver);\n \n   int len = Smi::ToInt(array->length());\n-  if (len == 0) return heap->undefined_value();\n+  if (len == 0) return ReadOnlyRoots(heap).undefined_value();\n \n   if (JSArray::HasReadOnlyLength(array)) {\n     return CallJsIntrinsic(isolate, isolate->array_shift(), args);\n@@ -364,12 +487,12 @@ class ArrayConcatVisitor {\n       // Fall-through to dictionary mode.\n     }\n     DCHECK(!fast_elements());\n-    Handle<NumberDictionary> dict(NumberDictionary::cast(*storage_));\n+    Handle<NumberDictionary> dict(NumberDictionary::cast(*storage_), isolate_);\n     // The object holding this backing store has just been allocated, so\n     // it cannot yet be used as a prototype.\n     Handle<JSObject> not_a_prototype_holder;\n-    Handle<NumberDictionary> result =\n-        NumberDictionary::Set(dict, index, elm, not_a_prototype_holder);\n+    Handle<NumberDictionary> result = NumberDictionary::Set(\n+        isolate_, dict, index, elm, not_a_prototype_holder);\n     if (!result.is_identical_to(dict)) {\n       // Dictionary needed to grow.\n       clear_storage();\n@@ -420,8 +543,9 @@ class ArrayConcatVisitor {\n         isolate_->factory()->NewNumber(static_cast<double>(index_offset_));\n     RETURN_ON_EXCEPTION(\n         isolate_,\n-        JSReceiver::SetProperty(result, isolate_->factory()->length_string(),\n-                                length, LanguageMode::kStrict),\n+        JSReceiver::SetProperty(isolate_, result,\n+                                isolate_->factory()->length_string(), length,\n+                                LanguageMode::kStrict),\n         JSReceiver);\n     return result;\n   }\n@@ -445,7 +569,7 @@ class ArrayConcatVisitor {\n             // it cannot yet be used as a prototype.\n             Handle<JSObject> not_a_prototype_holder;\n             Handle<NumberDictionary> new_storage = NumberDictionary::Set(\n-                slow_storage, i, element, not_a_prototype_holder);\n+                isolate_, slow_storage, i, element, not_a_prototype_holder);\n             if (!new_storage.is_identical_to(slow_storage)) {\n               slow_storage = loop_scope.CloseAndEscape(new_storage);\n             }\n@@ -491,7 +615,7 @@ class ArrayConcatVisitor {\n   uint32_t bit_field_;\n };\n \n-uint32_t EstimateElementCount(Handle<JSArray> array) {\n+uint32_t EstimateElementCount(Isolate* isolate, Handle<JSArray> array) {\n   DisallowHeapAllocation no_gc;\n   uint32_t length = static_cast<uint32_t>(array->length()->Number());\n   int element_count = 0;\n@@ -504,7 +628,6 @@ uint32_t EstimateElementCount(Handle<JSArray> array) {\n       // a 32-bit signed integer.\n       DCHECK_GE(static_cast<int32_t>(FixedArray::kMaxLength), 0);\n       int fast_length = static_cast<int>(length);\n-      Isolate* isolate = array->GetIsolate();\n       FixedArray* elements = FixedArray::cast(array->elements());\n       for (int i = 0; i < fast_length; i++) {\n         if (!elements->get(i)->IsTheHole(isolate)) element_count++;\n@@ -529,11 +652,11 @@ uint32_t EstimateElementCount(Handle<JSArray> array) {\n     }\n     case DICTIONARY_ELEMENTS: {\n       NumberDictionary* dictionary = NumberDictionary::cast(array->elements());\n-      Isolate* isolate = dictionary->GetIsolate();\n       int capacity = dictionary->Capacity();\n+      ReadOnlyRoots roots(isolate);\n       for (int i = 0; i < capacity; i++) {\n         Object* key = dictionary->KeyAt(i);\n-        if (dictionary->IsKey(isolate, key)) {\n+        if (dictionary->IsKey(roots, key)) {\n           element_count++;\n         }\n       }\n@@ -558,9 +681,8 @@ uint32_t EstimateElementCount(Handle<JSArray> array) {\n   return element_count;\n }\n \n-void CollectElementIndices(Handle<JSObject> object, uint32_t range,\n-                           std::vector<uint32_t>* indices) {\n-  Isolate* isolate = object->GetIsolate();\n+void CollectElementIndices(Isolate* isolate, Handle<JSObject> object,\n+                           uint32_t range, std::vector<uint32_t>* indices) {\n   ElementsKind kind = object->GetElementsKind();\n   switch (kind) {\n     case PACKED_SMI_ELEMENTS:\n@@ -585,7 +707,7 @@ void CollectElementIndices(Handle<JSObject> object, uint32_t range,\n         break;\n       }\n       Handle<FixedDoubleArray> elements(\n-          FixedDoubleArray::cast(object->elements()));\n+          FixedDoubleArray::cast(object->elements()), isolate);\n       uint32_t length = static_cast<uint32_t>(elements->length());\n       if (range < length) length = range;\n       for (uint32_t i = 0; i < length; i++) {\n@@ -599,9 +721,10 @@ void CollectElementIndices(Handle<JSObject> object, uint32_t range,\n       DisallowHeapAllocation no_gc;\n       NumberDictionary* dict = NumberDictionary::cast(object->elements());\n       uint32_t capacity = dict->Capacity();\n+      ReadOnlyRoots roots(isolate);\n       FOR_WITH_HANDLE_SCOPE(isolate, uint32_t, j = 0, j, j < capacity, j++, {\n         Object* k = dict->KeyAt(j);\n-        if (!dict->IsKey(isolate, k)) continue;\n+        if (!dict->IsKey(roots, k)) continue;\n         DCHECK(k->IsNumber());\n         uint32_t index = static_cast<uint32_t>(k->Number());\n         if (index < range) {\n@@ -670,8 +793,8 @@ void CollectElementIndices(Handle<JSObject> object, uint32_t range,\n   if (!iter.IsAtEnd()) {\n     // The prototype will usually have no inherited element indices,\n     // but we have to check.\n-    CollectElementIndices(PrototypeIterator::GetCurrent<JSObject>(iter), range,\n-                          indices);\n+    CollectElementIndices(\n+        isolate, PrototypeIterator::GetCurrent<JSObject>(iter), range, indices);\n   }\n }\n \n@@ -738,7 +861,7 @@ bool IterateElements(Isolate* isolate, Handle<JSReceiver> receiver,\n     case HOLEY_ELEMENTS: {\n       // Run through the elements FixedArray and use HasElement and GetElement\n       // to check the prototype for missing elements.\n-      Handle<FixedArray> elements(FixedArray::cast(array->elements()));\n+      Handle<FixedArray> elements(FixedArray::cast(array->elements()), isolate);\n       int fast_length = static_cast<int>(length);\n       DCHECK(fast_length <= elements->length());\n       FOR_WITH_HANDLE_SCOPE(isolate, int, j = 0, j, j < fast_length, j++, {\n@@ -771,7 +894,7 @@ bool IterateElements(Isolate* isolate, Handle<JSReceiver> receiver,\n         break;\n       }\n       Handle<FixedDoubleArray> elements(\n-          FixedDoubleArray::cast(array->elements()));\n+          FixedDoubleArray::cast(array->elements()), isolate);\n       int fast_length = static_cast<int>(length);\n       DCHECK(fast_length <= elements->length());\n       FOR_WITH_HANDLE_SCOPE(isolate, int, j = 0, j, j < fast_length, j++, {\n@@ -798,13 +921,13 @@ bool IterateElements(Isolate* isolate, Handle<JSReceiver> receiver,\n     }\n \n     case DICTIONARY_ELEMENTS: {\n-      Handle<NumberDictionary> dict(array->element_dictionary());\n+      Handle<NumberDictionary> dict(array->element_dictionary(), isolate);\n       std::vector<uint32_t> indices;\n       indices.reserve(dict->Capacity() / 2);\n \n       // Collect all indices in the object and the prototypes less\n       // than length. This might introduce duplicates in the indices list.\n-      CollectElementIndices(array, length, &indices);\n+      CollectElementIndices(isolate, array, length, &indices);\n       std::sort(indices.begin(), indices.end());\n       size_t n = indices.size();\n       FOR_WITH_HANDLE_SCOPE(isolate, size_t, j = 0, j, j < n, (void)0, {\n@@ -859,7 +982,7 @@ static Maybe<bool> IsConcatSpreadable(Isolate* isolate, Handle<Object> obj) {\n     MaybeHandle<Object> maybeValue =\n         i::Runtime::GetObjectProperty(isolate, obj, key);\n     if (!maybeValue.ToHandle(&value)) return Nothing<bool>();\n-    if (!value->IsUndefined(isolate)) return Just(value->BooleanValue());\n+    if (!value->IsUndefined(isolate)) return Just(value->BooleanValue(isolate));\n   }\n   return Object::IsArray(obj);\n }\n@@ -891,7 +1014,7 @@ Object* Slow_ArrayConcat(BuiltinArguments* args, Handle<Object> species,\n             GetPackedElementsKind(array->GetElementsKind());\n         kind = GetMoreGeneralElementsKind(kind, array_kind);\n       }\n-      element_estimate = EstimateElementCount(array);\n+      element_estimate = EstimateElementCount(isolate, array);\n     } else {\n       if (obj->IsHeapObject()) {\n         kind = GetMoreGeneralElementsKind(\n@@ -965,7 +1088,7 @@ Object* Slow_ArrayConcat(BuiltinArguments* args, Handle<Object> species,\n             }\n             case HOLEY_SMI_ELEMENTS:\n             case PACKED_SMI_ELEMENTS: {\n-              Object* the_hole = isolate->heap()->the_hole_value();\n+              Object* the_hole = ReadOnlyRoots(isolate).the_hole_value();\n               FixedArray* elements(FixedArray::cast(array->elements()));\n               for (uint32_t i = 0; i < length; i++) {\n                 Object* element = elements->get(i);\n@@ -1021,14 +1144,14 @@ Object* Slow_ArrayConcat(BuiltinArguments* args, Handle<Object> species,\n   for (int i = 0; i < argument_count; i++) {\n     Handle<Object> obj((*args)[i], isolate);\n     Maybe<bool> spreadable = IsConcatSpreadable(isolate, obj);\n-    MAYBE_RETURN(spreadable, isolate->heap()->exception());\n+    MAYBE_RETURN(spreadable, ReadOnlyRoots(isolate).exception());\n     if (spreadable.FromJust()) {\n       Handle<JSReceiver> object = Handle<JSReceiver>::cast(obj);\n       if (!IterateElements(isolate, object, &visitor)) {\n-        return isolate->heap()->exception();\n+        return ReadOnlyRoots(isolate).exception();\n       }\n     } else {\n-      if (!visitor.visit(0, obj)) return isolate->heap()->exception();\n+      if (!visitor.visit(0, obj)) return ReadOnlyRoots(isolate).exception();\n       visitor.increase_index_offset(1);\n     }\n   }\n@@ -1128,7 +1251,8 @@ BUILTIN(ArrayConcat) {\n     if (Fast_ArrayConcat(isolate, &args).ToHandle(&result_array)) {\n       return *result_array;\n     }\n-    if (isolate->has_pending_exception()) return isolate->heap()->exception();\n+    if (isolate->has_pending_exception())\n+      return ReadOnlyRoots(isolate).exception();\n   }\n   // Reading @@species happens before anything else with a side effect, so\n   // we can do it here to determine whether to take the fast path.\n@@ -1139,7 +1263,8 @@ BUILTIN(ArrayConcat) {\n     if (Fast_ArrayConcat(isolate, &args).ToHandle(&result_array)) {\n       return *result_array;\n     }\n-    if (isolate->has_pending_exception()) return isolate->heap()->exception();\n+    if (isolate->has_pending_exception())\n+      return ReadOnlyRoots(isolate).exception();\n   }\n   return Slow_ArrayConcat(&args, species, isolate);\n }"
        },
        {
            "sha": "92b003a4e28e48cece2584a17354ce16240802ea",
            "filename": "deps/v8/src/builtins/builtins-arraybuffer.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-arraybuffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-arraybuffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-arraybuffer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -82,7 +82,8 @@ BUILTIN(ArrayBufferConstructor) {\n // all cases, or we will expose uinitialized memory to user code.\n BUILTIN(ArrayBufferConstructor_DoNotInitialize) {\n   HandleScope scope(isolate);\n-  Handle<JSFunction> target(isolate->native_context()->array_buffer_fun());\n+  Handle<JSFunction> target(isolate->native_context()->array_buffer_fun(),\n+                            isolate);\n   Handle<Object> length = args.atOrUndefined(isolate, 1);\n   return ConstructBuffer(isolate, target, target, length, false);\n }"
        },
        {
            "sha": "7fbfbdd4940ca4dd0cef36bf1c27cae158680ebc",
            "filename": "deps/v8/src/builtins/builtins-async-function-gen.cc",
            "status": "modified",
            "additions": 85,
            "deletions": 8,
            "changes": 93,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-function-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-function-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-function-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -20,6 +20,10 @@ class AsyncFunctionBuiltinsAssembler : public AsyncBuiltinsAssembler {\n   void AsyncFunctionAwait(Node* const context, Node* const generator,\n                           Node* const awaited, Node* const outer_promise,\n                           const bool is_predicted_as_caught);\n+  void AsyncFunctionAwaitOptimized(Node* const context, Node* const generator,\n+                                   Node* const awaited,\n+                                   Node* const outer_promise,\n+                                   const bool is_predicted_as_caught);\n \n   void AsyncFunctionAwaitResumeClosure(\n       Node* const context, Node* const sent_value,\n@@ -120,6 +124,11 @@ void AsyncFunctionBuiltinsAssembler::AsyncFunctionAwait(\n   // TODO(jgruber): Use a faster specialized version of\n   // InternalPerformPromiseThen.\n \n+  Label after_debug_hook(this), call_debug_hook(this, Label::kDeferred);\n+  GotoIf(HasAsyncEventDelegate(), &call_debug_hook);\n+  Goto(&after_debug_hook);\n+  BIND(&after_debug_hook);\n+\n   Await(context, generator, awaited, outer_promise, AwaitContext::kLength,\n         init_closure_context, Context::ASYNC_FUNCTION_AWAIT_RESOLVE_SHARED_FUN,\n         Context::ASYNC_FUNCTION_AWAIT_REJECT_SHARED_FUN,\n@@ -128,6 +137,47 @@ void AsyncFunctionBuiltinsAssembler::AsyncFunctionAwait(\n   // Return outer promise to avoid adding an load of the outer promise before\n   // suspending in BytecodeGenerator.\n   Return(outer_promise);\n+\n+  BIND(&call_debug_hook);\n+  CallRuntime(Runtime::kDebugAsyncFunctionSuspended, context, outer_promise);\n+  Goto(&after_debug_hook);\n+}\n+\n+void AsyncFunctionBuiltinsAssembler::AsyncFunctionAwaitOptimized(\n+    Node* const context, Node* const generator, Node* const awaited,\n+    Node* const outer_promise, const bool is_predicted_as_caught) {\n+  CSA_SLOW_ASSERT(this, HasInstanceType(generator, JS_GENERATOR_OBJECT_TYPE));\n+  CSA_SLOW_ASSERT(this, HasInstanceType(outer_promise, JS_PROMISE_TYPE));\n+\n+  ContextInitializer init_closure_context = [&](Node* context) {\n+    StoreContextElementNoWriteBarrier(context, AwaitContext::kGeneratorSlot,\n+                                      generator);\n+  };\n+\n+  // TODO(jgruber): AsyncBuiltinsAssembler::Await currently does not reuse\n+  // the awaited promise if it is already a promise. Reuse is non-spec compliant\n+  // but part of our old behavior gives us a couple of percent\n+  // performance boost.\n+  // TODO(jgruber): Use a faster specialized version of\n+  // InternalPerformPromiseThen.\n+\n+  Label after_debug_hook(this), call_debug_hook(this, Label::kDeferred);\n+  GotoIf(HasAsyncEventDelegate(), &call_debug_hook);\n+  Goto(&after_debug_hook);\n+  BIND(&after_debug_hook);\n+\n+  AwaitOptimized(\n+      context, generator, awaited, outer_promise, AwaitContext::kLength,\n+      init_closure_context, Context::ASYNC_FUNCTION_AWAIT_RESOLVE_SHARED_FUN,\n+      Context::ASYNC_FUNCTION_AWAIT_REJECT_SHARED_FUN, is_predicted_as_caught);\n+\n+  // Return outer promise to avoid adding an load of the outer promise before\n+  // suspending in BytecodeGenerator.\n+  Return(outer_promise);\n+\n+  BIND(&call_debug_hook);\n+  CallRuntime(Runtime::kDebugAsyncFunctionSuspended, context, outer_promise);\n+  Goto(&after_debug_hook);\n }\n \n // Called by the parser from the desugaring of 'await' when catch\n@@ -145,6 +195,19 @@ TF_BUILTIN(AsyncFunctionAwaitCaught, AsyncFunctionBuiltinsAssembler) {\n                      kIsPredictedAsCaught);\n }\n \n+TF_BUILTIN(AsyncFunctionAwaitCaughtOptimized, AsyncFunctionBuiltinsAssembler) {\n+  CSA_ASSERT_JS_ARGC_EQ(this, 3);\n+  Node* const generator = Parameter(Descriptor::kGenerator);\n+  Node* const awaited = Parameter(Descriptor::kAwaited);\n+  Node* const outer_promise = Parameter(Descriptor::kOuterPromise);\n+  Node* const context = Parameter(Descriptor::kContext);\n+\n+  static const bool kIsPredictedAsCaught = true;\n+\n+  AsyncFunctionAwaitOptimized(context, generator, awaited, outer_promise,\n+                              kIsPredictedAsCaught);\n+}\n+\n // Called by the parser from the desugaring of 'await' when catch\n // prediction indicates no locally surrounding catch block.\n TF_BUILTIN(AsyncFunctionAwaitUncaught, AsyncFunctionBuiltinsAssembler) {\n@@ -160,6 +223,20 @@ TF_BUILTIN(AsyncFunctionAwaitUncaught, AsyncFunctionBuiltinsAssembler) {\n                      kIsPredictedAsCaught);\n }\n \n+TF_BUILTIN(AsyncFunctionAwaitUncaughtOptimized,\n+           AsyncFunctionBuiltinsAssembler) {\n+  CSA_ASSERT_JS_ARGC_EQ(this, 3);\n+  Node* const generator = Parameter(Descriptor::kGenerator);\n+  Node* const awaited = Parameter(Descriptor::kAwaited);\n+  Node* const outer_promise = Parameter(Descriptor::kOuterPromise);\n+  Node* const context = Parameter(Descriptor::kContext);\n+\n+  static const bool kIsPredictedAsCaught = false;\n+\n+  AsyncFunctionAwaitOptimized(context, generator, awaited, outer_promise,\n+                              kIsPredictedAsCaught);\n+}\n+\n TF_BUILTIN(AsyncFunctionPromiseCreate, AsyncFunctionBuiltinsAssembler) {\n   CSA_ASSERT_JS_ARGC_EQ(this, 0);\n   Node* const context = Parameter(Descriptor::kContext);\n@@ -177,29 +254,29 @@ TF_BUILTIN(AsyncFunctionPromiseCreate, AsyncFunctionBuiltinsAssembler) {\n     // Push the Promise under construction in an async function on\n     // the catch prediction stack to handle exceptions thrown before\n     // the first await.\n-    // Assign ID and create a recurring task to save stack for future\n-    // resumptions from await.\n-    CallRuntime(Runtime::kDebugAsyncFunctionPromiseCreated, context, promise);\n+    CallRuntime(Runtime::kDebugPushPromise, context, promise);\n     Return(promise);\n   }\n }\n \n TF_BUILTIN(AsyncFunctionPromiseRelease, AsyncFunctionBuiltinsAssembler) {\n-  CSA_ASSERT_JS_ARGC_EQ(this, 1);\n+  CSA_ASSERT_JS_ARGC_EQ(this, 2);\n   Node* const promise = Parameter(Descriptor::kPromise);\n   Node* const context = Parameter(Descriptor::kContext);\n \n-  Label if_is_debug_active(this, Label::kDeferred);\n-  GotoIf(IsDebugActive(), &if_is_debug_active);\n+  Label call_debug_instrumentation(this, Label::kDeferred);\n+  GotoIf(HasAsyncEventDelegate(), &call_debug_instrumentation);\n+  GotoIf(IsDebugActive(), &call_debug_instrumentation);\n \n   // Early exit if debug is not active.\n   Return(UndefinedConstant());\n \n-  BIND(&if_is_debug_active);\n+  BIND(&call_debug_instrumentation);\n   {\n     // Pop the Promise under construction in an async function on\n     // from catch prediction stack.\n-    CallRuntime(Runtime::kDebugPopPromise, context);\n+    CallRuntime(Runtime::kDebugAsyncFunctionFinished, context,\n+                Parameter(Descriptor::kCanSuspend), promise);\n     Return(promise);\n   }\n }"
        },
        {
            "sha": "c7e3c5cdeb643a2c9ff98da893af855ec4e22753",
            "filename": "deps/v8/src/builtins/builtins-async-gen.cc",
            "status": "modified",
            "additions": 118,
            "deletions": 4,
            "changes": 122,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a",
            "patch": "@@ -6,6 +6,7 @@\n \n #include \"src/builtins/builtins-utils-gen.h\"\n #include \"src/heap/factory-inl.h\"\n+#include \"src/objects/js-promise.h\"\n #include \"src/objects/shared-function-info.h\"\n \n namespace v8 {\n@@ -97,10 +98,9 @@ Node* AsyncBuiltinsAssembler::Await(\n   {\n     // Add PromiseHooks if needed\n     Label next(this);\n-    GotoIfNot(IsPromiseHookEnabledOrDebugIsActive(), &next);\n-    CallRuntime(Runtime::kPromiseHookInit, context, wrapped_value,\n-                outer_promise);\n-    CallRuntime(Runtime::kPromiseHookInit, context, throwaway, wrapped_value);\n+    GotoIfNot(IsPromiseHookEnabledOrHasAsyncEventDelegate(), &next);\n+    CallRuntime(Runtime::kAwaitPromisesInit, context, wrapped_value,\n+                outer_promise, throwaway);\n     Goto(&next);\n     BIND(&next);\n   }\n@@ -147,6 +147,120 @@ Node* AsyncBuiltinsAssembler::Await(\n                      on_resolve, on_reject, throwaway);\n }\n \n+Node* AsyncBuiltinsAssembler::AwaitOptimized(\n+    Node* context, Node* generator, Node* value, Node* outer_promise,\n+    int context_length, const ContextInitializer& init_closure_context,\n+    Node* on_resolve_context_index, Node* on_reject_context_index,\n+    Node* is_predicted_as_caught) {\n+  DCHECK_GE(context_length, Context::MIN_CONTEXT_SLOTS);\n+\n+  Node* const native_context = LoadNativeContext(context);\n+  Node* const promise_fun =\n+      LoadContextElement(native_context, Context::PROMISE_FUNCTION_INDEX);\n+  CSA_ASSERT(this, IsFunctionWithPrototypeSlotMap(LoadMap(promise_fun)));\n+  CSA_ASSERT(this, IsConstructor(promise_fun));\n+\n+  static const int kThrowawayPromiseOffset =\n+      FixedArray::SizeFor(context_length);\n+  static const int kResolveClosureOffset =\n+      kThrowawayPromiseOffset + JSPromise::kSizeWithEmbedderFields;\n+  static const int kRejectClosureOffset =\n+      kResolveClosureOffset + JSFunction::kSizeWithoutPrototype;\n+  static const int kTotalSize =\n+      kRejectClosureOffset + JSFunction::kSizeWithoutPrototype;\n+\n+  // 2. Let promise be ? PromiseResolve(« promise »).\n+  Node* const promise =\n+      CallBuiltin(Builtins::kPromiseResolve, context, promise_fun, value);\n+\n+  Node* const base = AllocateInNewSpace(kTotalSize);\n+  Node* const closure_context = base;\n+  {\n+    // Initialize closure context\n+    InitializeFunctionContext(native_context, closure_context, context_length);\n+    init_closure_context(closure_context);\n+  }\n+\n+  Node* const promise_map =\n+      LoadObjectField(promise_fun, JSFunction::kPrototypeOrInitialMapOffset);\n+  // Assert that the JSPromise map has an instance size is\n+  // JSPromise::kSizeWithEmbedderFields.\n+  CSA_ASSERT(this, WordEqual(LoadMapInstanceSizeInWords(promise_map),\n+                             IntPtrConstant(JSPromise::kSizeWithEmbedderFields /\n+                                            kPointerSize)));\n+  Node* const throwaway = InnerAllocate(base, kThrowawayPromiseOffset);\n+  {\n+    // Initialize throwawayPromise\n+    StoreMapNoWriteBarrier(throwaway, promise_map);\n+    InitializeJSObjectFromMap(\n+        throwaway, promise_map,\n+        IntPtrConstant(JSPromise::kSizeWithEmbedderFields));\n+    PromiseInit(throwaway);\n+  }\n+\n+  Node* const on_resolve = InnerAllocate(base, kResolveClosureOffset);\n+  {\n+    // Initialize resolve handler\n+    InitializeNativeClosure(closure_context, native_context, on_resolve,\n+                            on_resolve_context_index);\n+  }\n+\n+  Node* const on_reject = InnerAllocate(base, kRejectClosureOffset);\n+  {\n+    // Initialize reject handler\n+    InitializeNativeClosure(closure_context, native_context, on_reject,\n+                            on_reject_context_index);\n+  }\n+\n+  {\n+    // Add PromiseHooks if needed\n+    Label next(this);\n+    GotoIfNot(IsPromiseHookEnabledOrHasAsyncEventDelegate(), &next);\n+    CallRuntime(Runtime::kAwaitPromisesInit, context, promise, outer_promise,\n+                throwaway);\n+    Goto(&next);\n+    BIND(&next);\n+  }\n+\n+  // The Promise will be thrown away and not handled, but it shouldn't trigger\n+  // unhandled reject events as its work is done\n+  PromiseSetHasHandler(throwaway);\n+\n+  Label do_perform_promise_then(this);\n+  GotoIfNot(IsDebugActive(), &do_perform_promise_then);\n+  {\n+    Label common(this);\n+    GotoIf(TaggedIsSmi(value), &common);\n+    GotoIfNot(HasInstanceType(value, JS_PROMISE_TYPE), &common);\n+    {\n+      // Mark the reject handler callback to be a forwarding edge, rather\n+      // than a meaningful catch handler\n+      Node* const key =\n+          HeapConstant(factory()->promise_forwarding_handler_symbol());\n+      CallRuntime(Runtime::kSetProperty, context, on_reject, key,\n+                  TrueConstant(), SmiConstant(LanguageMode::kStrict));\n+\n+      GotoIf(IsFalse(is_predicted_as_caught), &common);\n+      PromiseSetHandledHint(value);\n+    }\n+\n+    Goto(&common);\n+    BIND(&common);\n+    // Mark the dependency to outer Promise in case the throwaway Promise is\n+    // found on the Promise stack\n+    CSA_SLOW_ASSERT(this, HasInstanceType(outer_promise, JS_PROMISE_TYPE));\n+\n+    Node* const key = HeapConstant(factory()->promise_handled_by_symbol());\n+    CallRuntime(Runtime::kSetProperty, context, throwaway, key, outer_promise,\n+                SmiConstant(LanguageMode::kStrict));\n+  }\n+\n+  Goto(&do_perform_promise_then);\n+  BIND(&do_perform_promise_then);\n+  return CallBuiltin(Builtins::kPerformPromiseThen, native_context, promise,\n+                     on_resolve, on_reject, throwaway);\n+}\n+\n void AsyncBuiltinsAssembler::InitializeNativeClosure(Node* context,\n                                                      Node* native_context,\n                                                      Node* function,"
        },
        {
            "sha": "e5f487d8cc37edff3d15938b3f5e0e141f77ace6",
            "filename": "deps/v8/src/builtins/builtins-async-gen.h",
            "status": "modified",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "251ff1ee4004085b1e9fd3da2932eb9366ef71e3",
            "filename": "deps/v8/src/builtins/builtins-async-generator-gen.cc",
            "status": "modified",
            "additions": 35,
            "deletions": 8,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-generator-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-generator-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-generator-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "82db5fbd5da07c99675048c17e51ab3efa8501aa",
            "filename": "deps/v8/src/builtins/builtins-async-iterator-gen.cc",
            "status": "modified",
            "additions": 141,
            "deletions": 0,
            "changes": 141,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-iterator-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-iterator-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-async-iterator-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6bc1a911f7770e548f374fdb3ba95997c52ca948",
            "filename": "deps/v8/src/builtins/builtins-bigint.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-bigint.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-bigint.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-bigint.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "e0e1bb738c179617d317f32e772e5fc1ea271969",
            "filename": "deps/v8/src/builtins/builtins-boolean.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-boolean.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-boolean.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-boolean.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "35aaee5ec200bf4ad99132634e7642d09469f876",
            "filename": "deps/v8/src/builtins/builtins-call-gen.cc",
            "status": "modified",
            "additions": 113,
            "deletions": 97,
            "changes": 210,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-call-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-call-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-call-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "013093f38b456d46b8acbadfa8ff98bd3b53844d",
            "filename": "deps/v8/src/builtins/builtins-call-gen.h",
            "status": "modified",
            "additions": 13,
            "deletions": 8,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-call-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-call-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-call-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "ff04fa2dbe3c57cb8d5dc60871cf64529689df83",
            "filename": "deps/v8/src/builtins/builtins-callsite.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-callsite.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-callsite.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-callsite.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6cab828e2e2ed00a256edf15ab6428962779833f",
            "filename": "deps/v8/src/builtins/builtins-collections-gen.cc",
            "status": "modified",
            "additions": 74,
            "deletions": 45,
            "changes": 119,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-collections-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-collections-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-collections-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "9a642e7d3b90aae4da28b6a96086ae60c3698f7b",
            "filename": "deps/v8/src/builtins/builtins-collections.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-collections.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-collections.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-collections.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "249ec10a28b60b1c032af6a6133c0e33e52fd3de",
            "filename": "deps/v8/src/builtins/builtins-console-gen.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-console-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-console-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-console-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "d87183c7164b31af265732af4abe1ae8585790f2",
            "filename": "deps/v8/src/builtins/builtins-console.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 26,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-console.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-console.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-console.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "76c28bc8698894a89789b8fa90b4a236aa48691a",
            "filename": "deps/v8/src/builtins/builtins-constructor-gen.cc",
            "status": "modified",
            "additions": 64,
            "deletions": 70,
            "changes": 134,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3079d9a4f796302a726bb9b6f99a982bc2bc2ed2",
            "filename": "deps/v8/src/builtins/builtins-constructor-gen.h",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "b1441adc3722726ae70f96d929ed123b08718350",
            "filename": "deps/v8/src/builtins/builtins-conversion-gen.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-conversion-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-conversion-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-conversion-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6c755c4d08b319a7d6613c0ec01c82ba47a1bb85",
            "filename": "deps/v8/src/builtins/builtins-data-view-gen.h",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-data-view-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-data-view-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-data-view-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "07aa4eb48b86472f82397cb58eeb48ccc2278ec5",
            "filename": "deps/v8/src/builtins/builtins-dataview.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 294,
            "changes": 294,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-dataview.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-dataview.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-dataview.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "0669963a0991a6b927fe0d0f4c7c7a519def798b",
            "filename": "deps/v8/src/builtins/builtins-date.cc",
            "status": "modified",
            "additions": 110,
            "deletions": 75,
            "changes": 185,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-date.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-date.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-date.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "46b02d88d817199620f02afdac753f12f4829e8f",
            "filename": "deps/v8/src/builtins/builtins-definitions.h",
            "status": "modified",
            "additions": 382,
            "deletions": 333,
            "changes": 715,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-definitions.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-definitions.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-definitions.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "abc5d58e2735a478ad7fa0528ef2816e1ed4a299",
            "filename": "deps/v8/src/builtins/builtins-descriptors.h",
            "status": "modified",
            "additions": 15,
            "deletions": 10,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-descriptors.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-descriptors.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-descriptors.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "0043c42810bdb89a710f22a983b39fdd934df8fb",
            "filename": "deps/v8/src/builtins/builtins-error.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-error.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-error.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-error.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "4924d4c0c411734b123a1f48ed59df901dd0c644",
            "filename": "deps/v8/src/builtins/builtins-function-gen.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 19,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-function-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-function-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-function-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "663eedc29a1aab08d63c7fff7b6ec8f236dfc464",
            "filename": "deps/v8/src/builtins/builtins-function.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 8,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-function.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-function.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-function.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "b7f296ac4d0a91516e0b0b63d80d7006b4fe5e70",
            "filename": "deps/v8/src/builtins/builtins-generator-gen.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-generator-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-generator-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-generator-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3c71a322f9ea04f06359e38d9a620b6d5ec1869f",
            "filename": "deps/v8/src/builtins/builtins-global.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-global.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-global.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-global.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "c2a16e35707854b1d4cb06fa04a705b17154d2a0",
            "filename": "deps/v8/src/builtins/builtins-internal-gen.cc",
            "status": "modified",
            "additions": 118,
            "deletions": 63,
            "changes": 181,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-internal-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-internal-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-internal-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3a1eb078d0ac3b65e4efa572a444438b003e1592",
            "filename": "deps/v8/src/builtins/builtins-internal.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-internal.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-internal.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-internal.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "e6664950d0a848fdb420b04ecf7331e8e9e1a25f",
            "filename": "deps/v8/src/builtins/builtins-intl.cc",
            "status": "modified",
            "additions": 161,
            "deletions": 38,
            "changes": 199,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-intl.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-intl.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-intl.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3c317d5b88f7b5a14b26eebc9523434f8d636b14",
            "filename": "deps/v8/src/builtins/builtins-json.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-json.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-json.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-json.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "d1314733c7cbda6ac147d59ec1e965c54221371d",
            "filename": "deps/v8/src/builtins/builtins-lazy-gen.cc",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-lazy-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-lazy-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-lazy-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "7f64aa096b0c91e8dff2b49baaa13d74b412e511",
            "filename": "deps/v8/src/builtins/builtins-lazy-gen.h",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-lazy-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-lazy-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-lazy-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "952bdda5de32648ce48ee6f575a5deef95c840b4",
            "filename": "deps/v8/src/builtins/builtins-math-gen.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-math-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-math-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-math-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "ae2bf03d694afae4cfce9521b9fe7c7dc11bd8a5",
            "filename": "deps/v8/src/builtins/builtins-math.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-math.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-math.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-math.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "cfc81612f2d4c262510727fdf13d1f2d9597cfd6",
            "filename": "deps/v8/src/builtins/builtins-number-gen.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 56,
            "changes": 60,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-number-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-number-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-number-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "7e701c1546e077954ace744514e7a04fae700d95",
            "filename": "deps/v8/src/builtins/builtins-number.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-number.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-number.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-number.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "fb89694c314558e38bd3f85d5f9bf40f7ce45c15",
            "filename": "deps/v8/src/builtins/builtins-object-gen.cc",
            "status": "modified",
            "additions": 144,
            "deletions": 38,
            "changes": 182,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "074c926587c729b0f4087ac520749eb5190fae61",
            "filename": "deps/v8/src/builtins/builtins-object.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 28,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-object.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "ccfb3b11b0978ecd9dfdc5a5f99c62cff667fba3",
            "filename": "deps/v8/src/builtins/builtins-promise-gen.cc",
            "status": "modified",
            "additions": 56,
            "deletions": 34,
            "changes": 90,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-promise-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-promise-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-promise-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "1d4c6d0802820732da0c927c39161c7f228dc81a",
            "filename": "deps/v8/src/builtins/builtins-proxy-gen.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-proxy-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-proxy-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-proxy-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "cc97caf6a9e25966f6d72a0cd9e89e5fd8354577",
            "filename": "deps/v8/src/builtins/builtins-reflect.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-reflect.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-reflect.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-reflect.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "1cf5d4f61f47aac90673dee97d01b6d30f10a98f",
            "filename": "deps/v8/src/builtins/builtins-regexp-gen.cc",
            "status": "modified",
            "additions": 126,
            "deletions": 71,
            "changes": 197,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "251e8c035e49f366aa6fa708475e8ea34f3e3863",
            "filename": "deps/v8/src/builtins/builtins-regexp-gen.h",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "86bf06b6581ef77a0ace43162a1bce6559c050e7",
            "filename": "deps/v8/src/builtins/builtins-regexp.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 7,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-regexp.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "52673bfd367ba714cce5cb6366a713c2a682608f",
            "filename": "deps/v8/src/builtins/builtins-sharedarraybuffer-gen.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-sharedarraybuffer-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-sharedarraybuffer-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-sharedarraybuffer-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "cb9ecfbc6177be45a1de40e4a0a79fdbc61db3bd",
            "filename": "deps/v8/src/builtins/builtins-sharedarraybuffer.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-sharedarraybuffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-sharedarraybuffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-sharedarraybuffer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "5524db56da6c6b661b6d5388402bf38230156e26",
            "filename": "deps/v8/src/builtins/builtins-string-gen.cc",
            "status": "modified",
            "additions": 64,
            "deletions": 38,
            "changes": 102,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "06ac127f13132827effbcc8cd1be5b2257293d30",
            "filename": "deps/v8/src/builtins/builtins-string-gen.h",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "e52fbd577dd4b6aa13b71b1d61eefb8d3b2edbe9",
            "filename": "deps/v8/src/builtins/builtins-string.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 27,
            "changes": 57,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-string.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "425fbab5d1199872cea5ad60b7a2a0e2fcb4ab5b",
            "filename": "deps/v8/src/builtins/builtins-symbol-gen.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-symbol-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-symbol-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-symbol-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "9ebb8c499dd6dd10fa94223128de32e6125c7798",
            "filename": "deps/v8/src/builtins/builtins-symbol.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-symbol.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-symbol.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-symbol.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "a10c1363387db8a3923e3909cbf7cf512f2d296f",
            "filename": "deps/v8/src/builtins/builtins-trace.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 191,
            "changes": 191,
            "blob_url": "https://github.com/nodejs/node/blob/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-trace.cc",
            "raw_url": "https://github.com/nodejs/node/raw/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-trace.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-trace.cc?ref=12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342"
        },
        {
            "sha": "595ec1f97bedb68aafee9ce8d17d27aacd8831b6",
            "filename": "deps/v8/src/builtins/builtins-typed-array-gen.cc",
            "status": "modified",
            "additions": 49,
            "deletions": 105,
            "changes": 154,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typed-array-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typed-array-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typed-array-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "e74469187fde981a801fca9b23e29dab469128bf",
            "filename": "deps/v8/src/builtins/builtins-typed-array-gen.h",
            "status": "modified",
            "additions": 3,
            "deletions": 14,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typed-array-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typed-array-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typed-array-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6750f2863bcb778c833c181fbacdf48f3af60bb6",
            "filename": "deps/v8/src/builtins/builtins-typed-array.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typed-array.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typed-array.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-typed-array.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "99843309809967ca286f4b8f941ac82248d33ee4",
            "filename": "deps/v8/src/builtins/builtins-utils-gen.h",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-utils-gen.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-utils-gen.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-utils-gen.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "5826ec546e882bbec546f1c7082937faab67093a",
            "filename": "deps/v8/src/builtins/builtins-wasm-gen.cc",
            "status": "modified",
            "additions": 100,
            "deletions": 6,
            "changes": 106,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-wasm-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-wasm-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-wasm-gen.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "ee4031d71a1b70311e02d6ad21339dd911f2a6b7",
            "filename": "deps/v8/src/builtins/builtins.cc",
            "status": "modified",
            "additions": 70,
            "deletions": 50,
            "changes": 120,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "ccb9619eeba183a1344cfa559f4a8563faa99d68",
            "filename": "deps/v8/src/builtins/builtins.h",
            "status": "modified",
            "additions": 10,
            "deletions": 33,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6dd390c795dbb9ed537e9610b46d26aa28b1d437",
            "filename": "deps/v8/src/builtins/constants-table-builder.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 7,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fconstants-table-builder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fconstants-table-builder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fconstants-table-builder.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "7cdc74a944f7aa880ae777e115e936d6deef9028",
            "filename": "deps/v8/src/builtins/data-view.tq",
            "status": "added",
            "additions": 896,
            "deletions": 0,
            "changes": 896,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fdata-view.tq",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fdata-view.tq",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fdata-view.tq?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "d1c0a5d5fbbc7620e00c5d1e1b74a014c337d501",
            "filename": "deps/v8/src/builtins/ia32/builtins-ia32.cc",
            "status": "modified",
            "additions": 170,
            "deletions": 430,
            "changes": 600,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fia32%2Fbuiltins-ia32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fia32%2Fbuiltins-ia32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fia32%2Fbuiltins-ia32.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "12c1d6075747b8337325d6d0d9dee32fc7390f0d",
            "filename": "deps/v8/src/builtins/mips/builtins-mips.cc",
            "status": "modified",
            "additions": 132,
            "deletions": 385,
            "changes": 517,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips%2Fbuiltins-mips.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips%2Fbuiltins-mips.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips%2Fbuiltins-mips.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "a93c75b2fceaf857e8fe3892c159c2658850f13a",
            "filename": "deps/v8/src/builtins/mips64/builtins-mips64.cc",
            "status": "modified",
            "additions": 143,
            "deletions": 397,
            "changes": 540,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips64%2Fbuiltins-mips64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips64%2Fbuiltins-mips64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fmips64%2Fbuiltins-mips64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3ba3e99789c7a622d4ec3ee7cb65df156809c665",
            "filename": "deps/v8/src/builtins/ppc/builtins-ppc.cc",
            "status": "modified",
            "additions": 147,
            "deletions": 393,
            "changes": 540,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fppc%2Fbuiltins-ppc.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fppc%2Fbuiltins-ppc.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fppc%2Fbuiltins-ppc.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "c7e955f6e4c5e3fa1b9f0040e5efb6f0cfe77548",
            "filename": "deps/v8/src/builtins/s390/builtins-s390.cc",
            "status": "modified",
            "additions": 160,
            "deletions": 410,
            "changes": 570,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fs390%2Fbuiltins-s390.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fs390%2Fbuiltins-s390.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fs390%2Fbuiltins-s390.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "ab0180e825bf2e680611a8ddaab48629a4808150",
            "filename": "deps/v8/src/builtins/setup-builtins-internal.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 29,
            "changes": 77,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fsetup-builtins-internal.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fsetup-builtins-internal.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fsetup-builtins-internal.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "2d2a086de58022b377014c25396946235681650a",
            "filename": "deps/v8/src/builtins/typed-array.tq",
            "status": "modified",
            "additions": 146,
            "deletions": 67,
            "changes": 213,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Ftyped-array.tq",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Ftyped-array.tq",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Ftyped-array.tq?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "438b577af6b72c63e341a7854b58ab8a4dfa402d",
            "filename": "deps/v8/src/builtins/x64/builtins-x64.cc",
            "status": "modified",
            "additions": 193,
            "deletions": 440,
            "changes": 633,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fx64%2Fbuiltins-x64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fbuiltins%2Fx64%2Fbuiltins-x64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fx64%2Fbuiltins-x64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "64ca6814166b300c7f2c4c9c18c9adc1a37608f3",
            "filename": "deps/v8/src/cancelable-task.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcancelable-task.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcancelable-task.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcancelable-task.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "09cd5a62e00beb4320e3e9cb05e07f019f26ab37",
            "filename": "deps/v8/src/code-events.h",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-events.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-events.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-events.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "b6eb03f81babd97692a52573f85a98c66bd2ef1b",
            "filename": "deps/v8/src/code-factory.cc",
            "status": "modified",
            "additions": 147,
            "deletions": 80,
            "changes": 227,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-factory.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-factory.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-factory.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3ff37695e2570efee48f806eb5569f14d9094195",
            "filename": "deps/v8/src/code-factory.h",
            "status": "modified",
            "additions": 17,
            "deletions": 9,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-factory.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-factory.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-factory.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "cb4b25a62186e15f57dc019561fefaf4705af0fb",
            "filename": "deps/v8/src/code-reference.h",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-reference.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-reference.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-reference.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "d39d841fbd58fd4d66259ca412b1a5d612f20353",
            "filename": "deps/v8/src/code-stub-assembler.cc",
            "status": "modified",
            "additions": 764,
            "deletions": 285,
            "changes": 1049,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3d7859f0647b573b1da1f4f987ddf25073384591",
            "filename": "deps/v8/src/code-stub-assembler.h",
            "status": "modified",
            "additions": 484,
            "deletions": 237,
            "changes": 721,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "adca79ac8f4975590ed6447b2827d4584a49f1f5",
            "filename": "deps/v8/src/code-stubs.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 167,
            "changes": 185,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-stubs.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-stubs.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stubs.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "745aa1aa24ecb4bc03265358789482197e631cc0",
            "filename": "deps/v8/src/code-stubs.h",
            "status": "modified",
            "additions": 12,
            "deletions": 200,
            "changes": 212,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-stubs.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-stubs.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stubs.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3ed07be77ea6e7149b25714b1135dee0944dd5fc",
            "filename": "deps/v8/src/code-tracer.h",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-tracer.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcode-tracer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-tracer.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "61b83b1a1853b2f822b479a32d20a51de410f9ca",
            "filename": "deps/v8/src/compilation-cache.cc",
            "status": "modified",
            "additions": 24,
            "deletions": 8,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompilation-cache.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompilation-cache.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompilation-cache.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3a4fe2e7b5ef56f19437044f8ee8e25828b1310b",
            "filename": "deps/v8/src/compilation-cache.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompilation-cache.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompilation-cache.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompilation-cache.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "8be814025a0e3e306c27fdb63234597e50faa60f",
            "filename": "deps/v8/src/compilation-dependencies.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 153,
            "changes": 153,
            "blob_url": "https://github.com/nodejs/node/blob/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fcompilation-dependencies.cc",
            "raw_url": "https://github.com/nodejs/node/raw/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fcompilation-dependencies.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompilation-dependencies.cc?ref=12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342"
        },
        {
            "sha": "fa26e67b1a0d2c3e0b09167dee86c1a02adbc20a",
            "filename": "deps/v8/src/compilation-dependencies.h",
            "status": "removed",
            "additions": 0,
            "deletions": 74,
            "changes": 74,
            "blob_url": "https://github.com/nodejs/node/blob/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fcompilation-dependencies.h",
            "raw_url": "https://github.com/nodejs/node/raw/12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342/deps%2Fv8%2Fsrc%2Fcompilation-dependencies.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompilation-dependencies.h?ref=12ed7c94e5160aa6d38e3d2cb2a73dae0a6f9342"
        },
        {
            "sha": "47b2181a88bf50c839086b9b792558fe285fc6f6",
            "filename": "deps/v8/src/compiler-dispatcher/optimizing-compile-dispatcher.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Foptimizing-compile-dispatcher.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Foptimizing-compile-dispatcher.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Foptimizing-compile-dispatcher.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "2e8065ed11b1d79cac72269e4949ba259dcaa69f",
            "filename": "deps/v8/src/compiler-dispatcher/unoptimized-compile-job.cc",
            "status": "modified",
            "additions": 24,
            "deletions": 31,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Funoptimized-compile-job.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Funoptimized-compile-job.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Funoptimized-compile-job.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3e08388ca097ee38942e6ada13c76a314a75742e",
            "filename": "deps/v8/src/compiler-dispatcher/unoptimized-compile-job.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Funoptimized-compile-job.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Funoptimized-compile-job.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler-dispatcher%2Funoptimized-compile-job.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6c5211b74d8f6ae91dfb4b51cefd9e4cd232e1ec",
            "filename": "deps/v8/src/compiler.cc",
            "status": "modified",
            "additions": 63,
            "deletions": 104,
            "changes": 167,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "4789759dfca68262bb34abe4b422f88105d89df6",
            "filename": "deps/v8/src/compiler.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "40783a35117915152b49b730115fcb9810ab81d8",
            "filename": "deps/v8/src/compiler/OWNERS",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2FOWNERS",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2FOWNERS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2FOWNERS?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "0b78795e008462351c279b852d71b0e5daae6a31",
            "filename": "deps/v8/src/compiler/access-builder.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "945edf30148deda990117b8097db08d2cfbcab55",
            "filename": "deps/v8/src/compiler/access-builder.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-builder.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "62ed7e7d857ad9eec9b36fc90f84c474eddf9efc",
            "filename": "deps/v8/src/compiler/access-info.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 41,
            "changes": 86,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-info.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-info.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-info.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "fa737ce0c4175921f17ce0b1fe743710469f4c5e",
            "filename": "deps/v8/src/compiler/access-info.h",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-info.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-info.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Faccess-info.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "4aabac1c110f3cb1e4787ff92d1988c5d3a97d88",
            "filename": "deps/v8/src/compiler/allocation-builder.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fallocation-builder.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fallocation-builder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fallocation-builder.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "d129274863134f6f5a9be22c88bbdf2f922fc763",
            "filename": "deps/v8/src/compiler/arm/code-generator-arm.cc",
            "status": "modified",
            "additions": 85,
            "deletions": 124,
            "changes": 209,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Fcode-generator-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Fcode-generator-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Fcode-generator-arm.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "8fc57791127d39602204617e7d256fa56d8f7a78",
            "filename": "deps/v8/src/compiler/arm/instruction-selector-arm.cc",
            "status": "modified",
            "additions": 33,
            "deletions": 29,
            "changes": 62,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-selector-arm.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-selector-arm.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm%2Finstruction-selector-arm.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "a7c5beee4cf9baaf7c1617e35ae38cca71a622ee",
            "filename": "deps/v8/src/compiler/arm64/code-generator-arm64.cc",
            "status": "modified",
            "additions": 62,
            "deletions": 79,
            "changes": 141,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Fcode-generator-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Fcode-generator-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Fcode-generator-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "ce73515321e2dccc0e59315c9ff8996756e79932",
            "filename": "deps/v8/src/compiler/arm64/instruction-codes-arm64.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-codes-arm64.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-codes-arm64.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-codes-arm64.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "e07debf9ecf9edafd8dec1a4e66b15992786bda9",
            "filename": "deps/v8/src/compiler/arm64/instruction-selector-arm64.cc",
            "status": "modified",
            "additions": 72,
            "deletions": 37,
            "changes": 109,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-selector-arm64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-selector-arm64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Farm64%2Finstruction-selector-arm64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "741de6f26493c70c837a2afcc213fbd4a4534ffd",
            "filename": "deps/v8/src/compiler/branch-elimination.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fbranch-elimination.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fbranch-elimination.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fbranch-elimination.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "23881ebd0a7c79744c10f7fde8b5108175c83178",
            "filename": "deps/v8/src/compiler/branch-elimination.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fbranch-elimination.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fbranch-elimination.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fbranch-elimination.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "2d16ba525c45e6c42c259c6ccf51abbd8e26bdb5",
            "filename": "deps/v8/src/compiler/bytecode-graph-builder.cc",
            "status": "modified",
            "additions": 96,
            "deletions": 63,
            "changes": 159,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "a94a3d79afe7e68af690b28d44525c82ec02a934",
            "filename": "deps/v8/src/compiler/bytecode-graph-builder.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fbytecode-graph-builder.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "172d42845c2d98b340484483ff6173d78f7f0702",
            "filename": "deps/v8/src/compiler/checkpoint-elimination.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcheckpoint-elimination.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcheckpoint-elimination.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcheckpoint-elimination.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "0b77d100723312e40776dbeb283a405f475b2f70",
            "filename": "deps/v8/src/compiler/code-assembler.cc",
            "status": "modified",
            "additions": 201,
            "deletions": 213,
            "changes": 414,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6419140a7458349e4db294ac2375b3dcf7232850",
            "filename": "deps/v8/src/compiler/code-assembler.h",
            "status": "modified",
            "additions": 160,
            "deletions": 56,
            "changes": 216,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-assembler.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6a7d0985f4d860a2a8e23129754841626925ca77",
            "filename": "deps/v8/src/compiler/code-generator.cc",
            "status": "modified",
            "additions": 63,
            "deletions": 37,
            "changes": 100,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-generator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-generator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-generator.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "dcdb6bb806e330f7334357dd15d53dddb0142742",
            "filename": "deps/v8/src/compiler/code-generator.h",
            "status": "modified",
            "additions": 20,
            "deletions": 4,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-generator.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-generator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcode-generator.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6e50d700b71aae747801bc95f1b4aa3b8f86b10b",
            "filename": "deps/v8/src/compiler/common-operator-reducer.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator-reducer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator-reducer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator-reducer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "77a1d710841db951db9e968afb3d159f18cecf25",
            "filename": "deps/v8/src/compiler/common-operator-reducer.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator-reducer.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator-reducer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator-reducer.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "253a92eb8472411e2fb65088ed1509b51d02d233",
            "filename": "deps/v8/src/compiler/common-operator.cc",
            "status": "modified",
            "additions": 37,
            "deletions": 20,
            "changes": 57,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "23f1cdfc1db8a5317b83f7fbb79c5f3ce7aa9377",
            "filename": "deps/v8/src/compiler/common-operator.h",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcommon-operator.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "a672d0a1f04623a2831be420947cd608896a8dce",
            "filename": "deps/v8/src/compiler/compilation-dependencies.cc",
            "status": "added",
            "additions": 396,
            "deletions": 0,
            "changes": 396,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcompilation-dependencies.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcompilation-dependencies.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcompilation-dependencies.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "9770775c2e4e3728200c7e90833fc7b69cccde87",
            "filename": "deps/v8/src/compiler/compilation-dependencies.h",
            "status": "added",
            "additions": 77,
            "deletions": 0,
            "changes": 77,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcompilation-dependencies.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fcompilation-dependencies.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fcompilation-dependencies.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "1811c06f98e25c17f3340231e929d21c06b4c2b5",
            "filename": "deps/v8/src/compiler/constant-folding-reducer.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fconstant-folding-reducer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fconstant-folding-reducer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fconstant-folding-reducer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "b111e5b87899a065d94136673eec09d5be2ce76e",
            "filename": "deps/v8/src/compiler/constant-folding-reducer.h",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fconstant-folding-reducer.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fconstant-folding-reducer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fconstant-folding-reducer.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "424db00fc4ba1e9e460216a536be6b6ea65da89c",
            "filename": "deps/v8/src/compiler/dead-code-elimination.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fdead-code-elimination.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fdead-code-elimination.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fdead-code-elimination.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "cc6ca954f3d92e3223eefa6d6862af539b23cf95",
            "filename": "deps/v8/src/compiler/diamond.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fdiamond.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fdiamond.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fdiamond.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "9a3a2930555e9dd732c06ed0a35d8d839e02017b",
            "filename": "deps/v8/src/compiler/effect-control-linearizer.cc",
            "status": "modified",
            "additions": 402,
            "deletions": 38,
            "changes": 440,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "47e0a249cfefc4fd75e84784b5baf38c0e26f0d0",
            "filename": "deps/v8/src/compiler/effect-control-linearizer.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Feffect-control-linearizer.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "976be6d906828555dbe28528875e518193ca9a9c",
            "filename": "deps/v8/src/compiler/escape-analysis-reducer.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis-reducer.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis-reducer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis-reducer.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "0e6822a9cadcce5e73fa71bc2d8a70dd698653e3",
            "filename": "deps/v8/src/compiler/escape-analysis.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "71aae6b2a4e06228b4e883d817d0f3443cba7e83",
            "filename": "deps/v8/src/compiler/escape-analysis.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fescape-analysis.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "9780d227fd37a7f843dc3ce54d7f1c45fe56546e",
            "filename": "deps/v8/src/compiler/graph-assembler.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "f9b45a2007d71a61cbb123bcbb3863ff1d2a2aba",
            "filename": "deps/v8/src/compiler/graph-assembler.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-assembler.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "dc7b23521f188caa165f2257a33a16c9f522643c",
            "filename": "deps/v8/src/compiler/graph-reducer.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 7,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-reducer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-reducer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-reducer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "c3de2cd8097175d018ef2557bb11ba54b6d78202",
            "filename": "deps/v8/src/compiler/graph-trimmer.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-trimmer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-trimmer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-trimmer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "feb0a8e9d316d670c7a045394f0888be5421fe26",
            "filename": "deps/v8/src/compiler/graph-visualizer.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 7,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-visualizer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-visualizer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-visualizer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "4b95169215a8ae9044b50c1e1d809532e71344fd",
            "filename": "deps/v8/src/compiler/graph-visualizer.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-visualizer.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-visualizer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph-visualizer.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "fea76bff81506feedf7ccf371c7d2a8affca8caf",
            "filename": "deps/v8/src/compiler/graph.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fgraph.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "9aef13881189c614317f69ae4d92727817ca4652",
            "filename": "deps/v8/src/compiler/ia32/code-generator-ia32.cc",
            "status": "modified",
            "additions": 624,
            "deletions": 244,
            "changes": 868,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Fcode-generator-ia32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Fcode-generator-ia32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Fcode-generator-ia32.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "8ffc9c3819b645cab0e5942a40f32aaf6278efed",
            "filename": "deps/v8/src/compiler/ia32/instruction-codes-ia32.h",
            "status": "modified",
            "additions": 47,
            "deletions": 4,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-codes-ia32.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-codes-ia32.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-codes-ia32.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "82d6fb88a308448b8b0f703d5d0107d0a8ff757f",
            "filename": "deps/v8/src/compiler/ia32/instruction-scheduler-ia32.cc",
            "status": "modified",
            "additions": 47,
            "deletions": 4,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-scheduler-ia32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-scheduler-ia32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-scheduler-ia32.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "41442542850c3ffac30314b0e710ba171a4f5f86",
            "filename": "deps/v8/src/compiler/ia32/instruction-selector-ia32.cc",
            "status": "modified",
            "additions": 443,
            "deletions": 169,
            "changes": 612,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-selector-ia32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-selector-ia32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fia32%2Finstruction-selector-ia32.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "83e8da9e8a4133fbbf3464256eba1dda79380fc7",
            "filename": "deps/v8/src/compiler/instruction-codes.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-codes.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-codes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-codes.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "de042cb670bb01760731ae4752c16c21f0e20e2f",
            "filename": "deps/v8/src/compiler/instruction-scheduler.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-scheduler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-scheduler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-scheduler.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "27f37215dfd4419756aaee5be7b3ae9eb7f6335b",
            "filename": "deps/v8/src/compiler/instruction-selector-impl.h",
            "status": "modified",
            "additions": 13,
            "deletions": 4,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector-impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector-impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector-impl.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "f1ca52b14d0fd46f8e7e757c76934902747bad18",
            "filename": "deps/v8/src/compiler/instruction-selector.cc",
            "status": "modified",
            "additions": 195,
            "deletions": 103,
            "changes": 298,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "39d0c01ee9ac765fe5c81f7f19c60b09b873ce0f",
            "filename": "deps/v8/src/compiler/instruction-selector.h",
            "status": "modified",
            "additions": 97,
            "deletions": 26,
            "changes": 123,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction-selector.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "83ed28fb5374635253fc38a31ffe80752a89974a",
            "filename": "deps/v8/src/compiler/instruction.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 21,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Finstruction.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6b545c28537b5d006c7f8c834db187e103375a99",
            "filename": "deps/v8/src/compiler/js-call-reducer.cc",
            "status": "modified",
            "additions": 696,
            "deletions": 140,
            "changes": 836,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "6e3f53164712de5b57c186f340b4503a790699b6",
            "filename": "deps/v8/src/compiler/js-call-reducer.h",
            "status": "modified",
            "additions": 13,
            "deletions": 3,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-call-reducer.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "85a80a2b2fe9b65813cc14000b795a12095ba096",
            "filename": "deps/v8/src/compiler/js-context-specialization.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 23,
            "changes": 63,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-context-specialization.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-context-specialization.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-context-specialization.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "d2f56d50f1a8396fdb746c0db592448ae26b3235",
            "filename": "deps/v8/src/compiler/js-context-specialization.h",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-context-specialization.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-context-specialization.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-context-specialization.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "a9ce42e1e2d11acea13bea0ced4924e6224f8d64",
            "filename": "deps/v8/src/compiler/js-create-lowering.cc",
            "status": "modified",
            "additions": 315,
            "deletions": 375,
            "changes": 690,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-create-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-create-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-create-lowering.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "667298c2388db6fe48ec3d25643ed7bfb4fbb428",
            "filename": "deps/v8/src/compiler/js-create-lowering.h",
            "status": "modified",
            "additions": 13,
            "deletions": 10,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-create-lowering.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-create-lowering.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-create-lowering.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "5e134307f423c7851d7c0990bbe67d9ffc8b386c",
            "filename": "deps/v8/src/compiler/js-generic-lowering.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 18,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-generic-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-generic-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-generic-lowering.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "09fafb4dc5e84b5fb3f99e13da0cef83963b3c3f",
            "filename": "deps/v8/src/compiler/js-generic-lowering.h",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-generic-lowering.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-generic-lowering.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-generic-lowering.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "b3ef85fb07000defd9e54ab61e6ccaa36bd19fbc",
            "filename": "deps/v8/src/compiler/js-graph.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 1,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "517b799a24ca4d0d44d8a87dea280ca0937d5fa0",
            "filename": "deps/v8/src/compiler/js-graph.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-graph.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "262438716577cb7cfd2a92e40855b31f329db69c",
            "filename": "deps/v8/src/compiler/js-heap-broker.cc",
            "status": "added",
            "additions": 848,
            "deletions": 0,
            "changes": 848,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-heap-broker.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-heap-broker.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-heap-broker.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "8503e82d12cd855bdeab55cdba2bab9c462a4ca7",
            "filename": "deps/v8/src/compiler/js-heap-broker.h",
            "status": "added",
            "additions": 432,
            "deletions": 0,
            "changes": 432,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-heap-broker.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-heap-broker.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-heap-broker.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "588626e2926d117233da4931375bddafb501d002",
            "filename": "deps/v8/src/compiler/js-inlining-heuristic.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "dc8d70f6aca3a28100fc7e3e7879b6bf1a5b97a2",
            "filename": "deps/v8/src/compiler/js-inlining-heuristic.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining-heuristic.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "247e36d5b397907d0d468968495bb717f49a8ce6",
            "filename": "deps/v8/src/compiler/js-inlining.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "1c7ee6c0b8b5b5e49e5ddaa9ec8ffda67e840c6b",
            "filename": "deps/v8/src/compiler/js-inlining.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-inlining.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "fcb9e87adb37bbdcdcd1b5b0a41f57024ca6db84",
            "filename": "deps/v8/src/compiler/js-intrinsic-lowering.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 5,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-intrinsic-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-intrinsic-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-intrinsic-lowering.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "4c6ea30bae7b7920d5653b34a1f4379b57ce779f",
            "filename": "deps/v8/src/compiler/js-native-context-specialization.cc",
            "status": "modified",
            "additions": 133,
            "deletions": 110,
            "changes": 243,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-native-context-specialization.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-native-context-specialization.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-native-context-specialization.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "53fe9e2c11cc20f7e5051de20fc6ad8f43e6aeb8",
            "filename": "deps/v8/src/compiler/js-native-context-specialization.h",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-native-context-specialization.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-native-context-specialization.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-native-context-specialization.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "5d45bb7f954e85371f3a4e8f16c1a755eb881075",
            "filename": "deps/v8/src/compiler/js-operator.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "f73aca819f59b826710daf6cdb2a48a92e6a449c",
            "filename": "deps/v8/src/compiler/js-operator.h",
            "status": "modified",
            "additions": 13,
            "deletions": 11,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-operator.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "fc7fab4b54b0b2880fc93da78c7cf69ae73b1d29",
            "filename": "deps/v8/src/compiler/js-type-hint-lowering.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-type-hint-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-type-hint-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-type-hint-lowering.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "5b6da84bcf3a2f30e6947a94baf1e23f0cf01317",
            "filename": "deps/v8/src/compiler/js-type-hint-lowering.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-type-hint-lowering.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-type-hint-lowering.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-type-hint-lowering.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "4fc1f845386c74defee9b451256ab5f9ab4b6f6e",
            "filename": "deps/v8/src/compiler/js-typed-lowering.cc",
            "status": "modified",
            "additions": 92,
            "deletions": 100,
            "changes": 192,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "c8fcac5ff6a563631c9dc86bf81b2eb9df65d1b9",
            "filename": "deps/v8/src/compiler/js-typed-lowering.h",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjs-typed-lowering.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "d10f06e4f40c6003649d0c57998b36097ec9f4d1",
            "filename": "deps/v8/src/compiler/jump-threading.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjump-threading.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjump-threading.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjump-threading.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "4d57f281c5dc6234d855aab33778e7a2d6782198",
            "filename": "deps/v8/src/compiler/jump-threading.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjump-threading.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fjump-threading.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fjump-threading.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "99f192acdfedf8c7f438de2ab87719f226532285",
            "filename": "deps/v8/src/compiler/linkage.cc",
            "status": "modified",
            "additions": 33,
            "deletions": 56,
            "changes": 89,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "e8c15123d403c52c4f67fe4e9913ae0dae452f71",
            "filename": "deps/v8/src/compiler/linkage.h",
            "status": "modified",
            "additions": 3,
            "deletions": 8,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Flinkage.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "c1d857035317ef33db29625ea86df7dc460820ec",
            "filename": "deps/v8/src/compiler/load-elimination.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fload-elimination.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fload-elimination.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fload-elimination.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "d3b1b5c14ad4adf29094be717afeba7720c86d2e",
            "filename": "deps/v8/src/compiler/load-elimination.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fload-elimination.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fload-elimination.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fload-elimination.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "fe5b8c7889bdd850c6236af212e7de2b888a6b08",
            "filename": "deps/v8/src/compiler/loop-variable-optimizer.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-variable-optimizer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-variable-optimizer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Floop-variable-optimizer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "55ef35d231b0c4edae1ac3429580ae8491ebf343",
            "filename": "deps/v8/src/compiler/machine-graph-verifier.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-graph-verifier.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-graph-verifier.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-graph-verifier.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "8eac3ed18c0b64979b221ca59ba6d06c8d9a8f0a",
            "filename": "deps/v8/src/compiler/machine-operator.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "65217cf2a66323e32c0949c9e14caabeab0e7c92",
            "filename": "deps/v8/src/compiler/machine-operator.h",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmachine-operator.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "e7ec15098579850c4cc887c841a90bbdd88ae40e",
            "filename": "deps/v8/src/compiler/memory-optimizer.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmemory-optimizer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmemory-optimizer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmemory-optimizer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "00575fe11717f6774279d99e6a7285933245f30d",
            "filename": "deps/v8/src/compiler/mips/code-generator-mips.cc",
            "status": "modified",
            "additions": 50,
            "deletions": 44,
            "changes": 94,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Fcode-generator-mips.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Fcode-generator-mips.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Fcode-generator-mips.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "a0fe18843077fe7b08c08370ccf48f67e3e90b93",
            "filename": "deps/v8/src/compiler/mips/instruction-scheduler-mips.cc",
            "status": "modified",
            "additions": 1709,
            "deletions": 4,
            "changes": 1713,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-scheduler-mips.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-scheduler-mips.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-scheduler-mips.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "cfe132338c0c406cd7904068e967a41a89c8ceb0",
            "filename": "deps/v8/src/compiler/mips/instruction-selector-mips.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 20,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-selector-mips.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-selector-mips.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips%2Finstruction-selector-mips.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "7beb887b5385aae157e0e10d5c22f6e01a2bdbf3",
            "filename": "deps/v8/src/compiler/mips64/code-generator-mips64.cc",
            "status": "modified",
            "additions": 58,
            "deletions": 52,
            "changes": 110,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Fcode-generator-mips64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Fcode-generator-mips64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Fcode-generator-mips64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "b0f6d65bfe48a75c42d1f13b1b1125abb3a4c2b8",
            "filename": "deps/v8/src/compiler/mips64/instruction-scheduler-mips64.cc",
            "status": "modified",
            "additions": 1662,
            "deletions": 4,
            "changes": 1666,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-scheduler-mips64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-scheduler-mips64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-scheduler-mips64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "ee02d30244e9e242894c3721be405306e46dc319",
            "filename": "deps/v8/src/compiler/mips64/instruction-selector-mips64.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 19,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-selector-mips64.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-selector-mips64.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fmips64%2Finstruction-selector-mips64.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "4b02cad9b9976a4ec1f034f5bd3d4f949e375dcb",
            "filename": "deps/v8/src/compiler/node-matchers.h",
            "status": "modified",
            "additions": 97,
            "deletions": 12,
            "changes": 109,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-matchers.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-matchers.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-matchers.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "fc1f403939eb863757d19979663c6afc8cd7ada1",
            "filename": "deps/v8/src/compiler/node-origin-table.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-origin-table.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-origin-table.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-origin-table.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "8429b2f692d32b078e3f5fdc689af3c8967ae9d2",
            "filename": "deps/v8/src/compiler/node-origin-table.h",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-origin-table.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-origin-table.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-origin-table.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "0d0e4f3c97efcc7b287daef1ba1dda16569fb29b",
            "filename": "deps/v8/src/compiler/node-properties.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 12,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "abcee4eaf93a17cd5cac88e5f96d4abbdc8b9bf2",
            "filename": "deps/v8/src/compiler/node-properties.h",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode-properties.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "0e1ebce9bc3e2a88fffdfad823d73b654b21d4bc",
            "filename": "deps/v8/src/compiler/node.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 15,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "fc5a17c19d0732e99a76eda4acebb83c7d1e772c",
            "filename": "deps/v8/src/compiler/node.h",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fnode.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "7a6b19cb35d4ee11e7c90b56183cb01db09c112a",
            "filename": "deps/v8/src/compiler/opcodes.h",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fopcodes.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fopcodes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fopcodes.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "a9ae8c322aa6d1be31f52cef77f0915a1506cad9",
            "filename": "deps/v8/src/compiler/operation-typer.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 9,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "81f20bcda4e46437af295b880d90a45125750c7d",
            "filename": "deps/v8/src/compiler/operation-typer.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Foperation-typer.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "689561059cf350e4f7f81637a5b4bb632feef6da",
            "filename": "deps/v8/src/compiler/operator-properties.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Foperator-properties.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Foperator-properties.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Foperator-properties.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "099e5599b852030591f77729cbe0755a7a643f17",
            "filename": "deps/v8/src/compiler/pipeline-statistics.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline-statistics.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline-statistics.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline-statistics.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "21ef2b02aa4db6d8cdcfcfbf87b1029930bb3559",
            "filename": "deps/v8/src/compiler/pipeline-statistics.h",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline-statistics.h",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline-statistics.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline-statistics.h?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        },
        {
            "sha": "3366d1db9499f9fb0652d13deecae9c1558b2a2a",
            "filename": "deps/v8/src/compiler/pipeline.cc",
            "status": "modified",
            "additions": 436,
            "deletions": 216,
            "changes": 652,
            "blob_url": "https://github.com/nodejs/node/blob/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline.cc",
            "raw_url": "https://github.com/nodejs/node/raw/586db2414a338e1bf6eaf6e672a3adc7ce309f6a/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcompiler%2Fpipeline.cc?ref=586db2414a338e1bf6eaf6e672a3adc7ce309f6a"
        }
    ],
    "stats": {
        "total": 158925,
        "additions": 86377,
        "deletions": 72548
    }
}