{
    "author": "Trott",
    "message": "doc: wrap child_process.md at 80 characters\n\nPR-URL: https://github.com/nodejs/node/pull/26141\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "bf1559c698870734d395e564d7c567ea36e6ef12",
    "files": [
        {
            "sha": "62b2ff08c1e8eb3c88c41a3f25eacbe6af547b34",
            "filename": "doc/api/child_process.md",
            "status": "modified",
            "additions": 61,
            "deletions": 56,
            "changes": 117,
            "blob_url": "https://github.com/nodejs/node/blob/bf1559c698870734d395e564d7c567ea36e6ef12/doc%2Fapi%2Fchild_process.md",
            "raw_url": "https://github.com/nodejs/node/raw/bf1559c698870734d395e564d7c567ea36e6ef12/doc%2Fapi%2Fchild_process.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fchild_process.md?ref=bf1559c698870734d395e564d7c567ea36e6ef12",
            "patch": "@@ -1,7 +1,6 @@\n # Child Process\n \n <!--introduced_in=v0.10.0-->\n-<!--lint disable maximum-line-length-->\n \n > Stability: 2 - Stable\n \n@@ -44,10 +43,12 @@ and asynchronous alternatives to [`child_process.spawn()`][] and\n [`child_process.spawnSync()`][]. *Note that each of these alternatives are\n implemented on top of [`child_process.spawn()`][] or [`child_process.spawnSync()`][].*\n \n-  * [`child_process.exec()`][]: spawns a shell and runs a command within that shell,\n-    passing the `stdout` and `stderr` to a callback function when complete.\n-  * [`child_process.execFile()`][]: similar to [`child_process.exec()`][] except that\n-    it spawns the command directly without first spawning a shell by default.\n+  * [`child_process.exec()`][]: spawns a shell and runs a command within that\n+    shell, passing the `stdout` and `stderr` to a callback function when\n+    complete.\n+  * [`child_process.execFile()`][]: similar to [`child_process.exec()`][] except\n+    that it spawns the command directly without first spawning a shell by\n+    default.\n   * [`child_process.fork()`][]: spawns a new Node.js process and invokes a\n     specified module with an IPC communication channel established that allows\n     sending messages between parent and child.\n@@ -72,21 +73,22 @@ implement the Node.js [`EventEmitter`][] API, allowing the parent process to\n register listener functions that are called when certain events occur during\n the life cycle of the child process.\n \n-The [`child_process.exec()`][] and [`child_process.execFile()`][] methods additionally\n-allow for an optional `callback` function to be specified that is invoked\n-when the child process terminates.\n+The [`child_process.exec()`][] and [`child_process.execFile()`][] methods\n+additionally allow for an optional `callback` function to be specified that is\n+invoked when the child process terminates.\n \n ### Spawning `.bat` and `.cmd` files on Windows\n \n The importance of the distinction between [`child_process.exec()`][] and\n-[`child_process.execFile()`][] can vary based on platform. On Unix-type operating\n-systems (Unix, Linux, macOS) [`child_process.execFile()`][] can be more efficient\n-because it does not spawn a shell by default. On Windows, however, `.bat` and `.cmd`\n-files are not executable on their own without a terminal, and therefore cannot\n-be launched using [`child_process.execFile()`][]. When running on Windows, `.bat`\n-and `.cmd` files can be invoked using [`child_process.spawn()`][] with the `shell`\n-option set, with [`child_process.exec()`][], or by spawning `cmd.exe` and passing\n-the `.bat` or `.cmd` file as an argument (which is what the `shell` option and\n+[`child_process.execFile()`][] can vary based on platform. On Unix-type\n+operating systems (Unix, Linux, macOS) [`child_process.execFile()`][] can be\n+more efficient because it does not spawn a shell by default. On Windows,\n+however, `.bat` and `.cmd` files are not executable on their own without a\n+terminal, and therefore cannot be launched using [`child_process.execFile()`][].\n+When running on Windows, `.bat` and `.cmd` files can be invoked using\n+[`child_process.spawn()`][] with the `shell` option set, with\n+[`child_process.exec()`][], or by spawning `cmd.exe` and passing the `.bat` or\n+`.cmd` file as an argument (which is what the `shell` option and\n [`child_process.exec()`][] do). In any case, if the script filename contains\n spaces it needs to be quoted.\n \n@@ -267,12 +269,13 @@ changes:\n * Returns: {ChildProcess}\n \n The `child_process.execFile()` function is similar to [`child_process.exec()`][]\n-except that it does not spawn a shell by default. Rather, the specified executable `file`\n-is spawned directly as a new process making it slightly more efficient than\n-[`child_process.exec()`][].\n+except that it does not spawn a shell by default. Rather, the specified\n+executable `file` is spawned directly as a new process making it slightly more\n+efficient than [`child_process.exec()`][].\n \n-The same options as [`child_process.exec()`][] are supported. Since a shell is not\n-spawned, behaviors such as I/O redirection and file globbing are not supported.\n+The same options as [`child_process.exec()`][] are supported. Since a shell is\n+not spawned, behaviors such as I/O redirection and file globbing are not\n+supported.\n \n ```js\n const { execFile } = require('child_process');\n@@ -350,10 +353,10 @@ changes:\n \n The `child_process.fork()` method is a special case of\n [`child_process.spawn()`][] used specifically to spawn new Node.js processes.\n-Like [`child_process.spawn()`][], a [`ChildProcess`][] object is returned. The returned\n-[`ChildProcess`][] will have an additional communication channel built-in that\n-allows messages to be passed back and forth between the parent and child. See\n-[`subprocess.send()`][] for details.\n+Like [`child_process.spawn()`][], a [`ChildProcess`][] object is returned. The\n+returned [`ChildProcess`][] will have an additional communication channel\n+built-in that allows messages to be passed back and forth between the parent and\n+child. See [`subprocess.send()`][] for details.\n \n It is important to keep in mind that spawned Node.js child processes are\n independent of the parent with exception of the IPC communication channel\n@@ -608,11 +611,12 @@ pipes between the parent and child. The value is one of the following:\n    for fds 0 - 2 are also available as [`subprocess.stdin`][],\n    [`subprocess.stdout`][] and [`subprocess.stderr`][], respectively.\n 2. `'ipc'` - Create an IPC channel for passing messages/file descriptors\n-   between parent and child. A [`ChildProcess`][] may have at most *one* IPC stdio\n-   file descriptor. Setting this option enables the [`subprocess.send()`][]\n-   method. If the child is a Node.js process, the presence of an IPC channel\n-   will enable [`process.send()`][] and [`process.disconnect()`][] methods,\n-   as well as [`'disconnect'`][] and [`'message'`][] events within the child.\n+   between parent and child. A [`ChildProcess`][] may have at most *one* IPC\n+   stdio file descriptor. Setting this option enables the\n+   [`subprocess.send()`][] method. If the child is a Node.js process, the\n+   presence of an IPC channel will enable [`process.send()`][] and\n+   [`process.disconnect()`][] methods, as well as [`'disconnect'`][] and\n+   [`'message'`][] events within the child.\n \n    Accessing the IPC channel fd in any way other than [`process.send()`][]\n    or using the IPC channel with a child process that is not a Node.js instance\n@@ -670,8 +674,8 @@ See also: [`child_process.exec()`][] and [`child_process.fork()`][].\n ## Synchronous Process Creation\n \n The [`child_process.spawnSync()`][], [`child_process.execSync()`][], and\n-[`child_process.execFileSync()`][] methods are **synchronous** and **WILL** block\n-the Node.js event loop, pausing execution of any additional code until the\n+[`child_process.execFileSync()`][] methods are **synchronous** and **WILL**\n+block the Node.js event loop, pausing execution of any additional code until the\n spawned process exits.\n \n Blocking calls like these are mostly useful for simplifying general-purpose\n@@ -728,10 +732,10 @@ changes:\n * Returns: {Buffer|string} The stdout from the command.\n \n The `child_process.execFileSync()` method is generally identical to\n-[`child_process.execFile()`][] with the exception that the method will not return\n-until the child process has fully closed. When a timeout has been encountered\n-and `killSignal` is sent, the method won't return until the process has\n-completely exited.\n+[`child_process.execFile()`][] with the exception that the method will not\n+return until the child process has fully closed. When a timeout has been\n+encountered and `killSignal` is sent, the method won't return until the process\n+has completely exited.\n \n If the child process intercepts and handles the `SIGTERM` signal and\n does not exit, the parent process will still wait until the child process has\n@@ -791,11 +795,11 @@ changes:\n * Returns: {Buffer|string} The stdout from the command.\n \n The `child_process.execSync()` method is generally identical to\n-[`child_process.exec()`][] with the exception that the method will not return until\n-the child process has fully closed. When a timeout has been encountered and\n-`killSignal` is sent, the method won't return until the process has completely\n-exited. *Note that if the child process intercepts and handles the `SIGTERM`\n-signal and doesn't exit, the parent process will wait until the child\n+[`child_process.exec()`][] with the exception that the method will not return\n+until the child process has fully closed. When a timeout has been encountered\n+and `killSignal` is sent, the method won't return until the process has\n+completely exited. *Note that if the child process intercepts and handles the\n+`SIGTERM` signal and doesn't exit, the parent process will wait until the child\n process has exited.*\n \n If the process times out or has a non-zero exit code, this method ***will***\n@@ -885,8 +889,8 @@ arbitrary command execution.**\n added: v2.2.0\n -->\n \n-Instances of the `ChildProcess` class are [`EventEmitters`][`EventEmitter`] that represent\n-spawned child processes.\n+Instances of the `ChildProcess` class are [`EventEmitters`][`EventEmitter`] that\n+represent spawned child processes.\n \n Instances of `ChildProcess` are not intended to be created directly. Rather,\n use the [`child_process.spawn()`][], [`child_process.exec()`][],\n@@ -964,8 +968,8 @@ added: v0.5.9\n * `sendHandle` {Handle} A [`net.Socket`][] or [`net.Server`][] object, or\n   undefined.\n \n-The `'message'` event is triggered when a child process uses [`process.send()`][]\n-to send messages.\n+The `'message'` event is triggered when a child process uses\n+[`process.send()`][] to send messages.\n \n The message goes through serialization and parsing. The resulting\n message might not be the same as what is originally sent.\n@@ -1034,11 +1038,11 @@ grep.on('close', (code, signal) => {\n grep.kill('SIGHUP');\n ```\n \n-The [`ChildProcess`][] object may emit an [`'error'`][] event if the signal cannot be\n-delivered. Sending a signal to a child process that has already exited is not\n-an error but may have unforeseen consequences. Specifically, if the process\n-identifier (PID) has been reassigned to another process, the signal will be\n-delivered to that process instead which can have unexpected results.\n+The [`ChildProcess`][] object may emit an [`'error'`][] event if the signal\n+cannot be delivered. Sending a signal to a child process that has already exited\n+is not an error but may have unforeseen consequences. Specifically, if the\n+process identifier (PID) has been reassigned to another process, the signal will\n+be delivered to that process instead which can have unexpected results.\n \n Note that while the function is called `kill`, the signal delivered to the\n child process may not actually terminate the process.\n@@ -1180,8 +1184,8 @@ process.on('message', (m) => {\n process.send({ foo: 'bar', baz: NaN });\n ```\n \n-Child Node.js processes will have a [`process.send()`][] method of their own that\n-allows the child to send messages back to the parent.\n+Child Node.js processes will have a [`process.send()`][] method of their own\n+that allows the child to send messages back to the parent.\n \n There is a special case when sending a `{cmd: 'NODE_foo'}` message. Messages\n containing a `NODE_` prefix in the `cmd` property are reserved for use within\n@@ -1202,8 +1206,8 @@ sent but before the child may have received it. The function is called with a\n single argument: `null` on success, or an [`Error`][] object on failure.\n \n If no `callback` function is provided and the message cannot be sent, an\n-`'error'` event will be emitted by the [`ChildProcess`][] object. This can happen,\n-for instance, when the child process has already exited.\n+`'error'` event will be emitted by the [`ChildProcess`][] object. This can\n+happen, for instance, when the child process has already exited.\n \n `subprocess.send()` will return `false` if the channel has closed or when the\n backlog of unsent messages exceeds a threshold that makes it unwise to send\n@@ -1245,8 +1249,9 @@ can be handled by the parent and some by the child.\n \n While the example above uses a server created using the `net` module, `dgram`\n module servers use exactly the same workflow with the exceptions of listening on\n-a `'message'` event instead of `'connection'` and using `server.bind()` instead of\n-`server.listen()`. This is, however, currently only supported on UNIX platforms.\n+a `'message'` event instead of `'connection'` and using `server.bind()` instead\n+of `server.listen()`. This is, however, currently only supported on UNIX\n+platforms.\n \n #### Example: sending a socket object\n "
        }
    ],
    "stats": {
        "total": 117,
        "additions": 61,
        "deletions": 56
    }
}