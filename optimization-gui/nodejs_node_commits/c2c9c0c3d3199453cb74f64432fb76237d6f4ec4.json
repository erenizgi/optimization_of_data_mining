{
    "author": "bnoordhuis",
    "message": "src: restore stdio on program exit\n\nRecord the state of the stdio file descriptors on start-up and restore\nthem to that state on exit.  This should prevent issues where node.js\nsometimes leaves stdio in raw or non-blocking mode.\n\nCo-authored-by: Krzysztof Taborski <taborskikrzysztof@gmail.com>\nPR-URL: https://github.com/nodejs/node/pull/20592\nFixes: https://github.com/nodejs/node/issues/14752\nFixes: https://github.com/nodejs/node/issues/21020\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "c2c9c0c3d3199453cb74f64432fb76237d6f4ec4",
    "files": [
        {
            "sha": "5c22b2962f6a0f14897dc66cd422039316d6e20d",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 94,
            "deletions": 6,
            "changes": 100,
            "blob_url": "https://github.com/nodejs/node/blob/c2c9c0c3d3199453cb74f64432fb76237d6f4ec4/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c2c9c0c3d3199453cb74f64432fb76237d6f4ec4/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=c2c9c0c3d3199453cb74f64432fb76237d6f4ec4",
            "patch": "@@ -100,6 +100,7 @@ typedef int mode_t;\n #else\n #include <pthread.h>\n #include <sys/resource.h>  // getrlimit, setrlimit\n+#include <termios.h>  // tcgetattr, tcsetattr\n #include <unistd.h>  // setuid, getuid\n #endif\n \n@@ -173,6 +174,9 @@ using v8::Value;\n static Mutex process_mutex;\n static Mutex environ_mutex;\n \n+// Safe to call more than once and from signal handlers.\n+inline void PlatformExit();\n+\n static bool print_eval = false;\n static bool force_repl = false;\n static bool syntax_check_only = false;\n@@ -1092,7 +1096,7 @@ void AppendExceptionLine(Environment* env,\n     Mutex::ScopedLock lock(process_mutex);\n     env->set_printed_error(true);\n \n-    uv_tty_reset_mode();\n+    PlatformExit();\n     PrintErrorString(\"\\n%s\", arrow);\n     return;\n   }\n@@ -3011,7 +3015,7 @@ void SetupProcessObject(Environment* env,\n \n \n void SignalExit(int signo) {\n-  uv_tty_reset_mode();\n+  PlatformExit();\n   v8_platform.StopTracingAgent();\n #ifdef __FreeBSD__\n   // FreeBSD has a nasty bug, see RegisterSignalHandler for details\n@@ -3828,6 +3832,27 @@ static void DebugEnd(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n+#ifdef __POSIX__\n+static struct {\n+  int flags;\n+  bool isatty;\n+  struct stat stat;\n+  struct termios termios;\n+} stdio[1 + STDERR_FILENO];\n+\n+\n+inline int GetFileDescriptorFlags(int fd) {\n+  int flags;\n+\n+  do {\n+    flags = fcntl(fd, F_GETFL);\n+  } while (flags == -1 && errno == EINTR);\n+\n+  return flags;\n+}\n+#endif  // __POSIX__\n+\n+\n inline void PlatformInit() {\n #ifdef __POSIX__\n #if HAVE_INSPECTOR\n@@ -3838,16 +3863,18 @@ inline void PlatformInit() {\n #endif  // HAVE_INSPECTOR\n \n   // Make sure file descriptors 0-2 are valid before we start logging anything.\n-  for (int fd = STDIN_FILENO; fd <= STDERR_FILENO; fd += 1) {\n-    struct stat ignored;\n-    if (fstat(fd, &ignored) == 0)\n+  for (auto& s : stdio) {\n+    const int fd = &s - stdio;\n+    if (fstat(fd, &s.stat) == 0)\n       continue;\n     // Anything but EBADF means something is seriously wrong.  We don't\n     // have to special-case EINTR, fstat() is not interruptible.\n     if (errno != EBADF)\n       ABORT();\n     if (fd != open(\"/dev/null\", O_RDWR))\n       ABORT();\n+    if (fstat(fd, &s.stat) != 0)\n+      ABORT();\n   }\n \n #if HAVE_INSPECTOR\n@@ -3870,6 +3897,24 @@ inline void PlatformInit() {\n   }\n #endif  // !NODE_SHARED_MODE\n \n+  // Record the state of the stdio file descriptors so we can restore it\n+  // on exit.  Needs to happen before installing signal handlers because\n+  // they make use of that information.\n+  for (auto& s : stdio) {\n+    const int fd = &s - stdio;\n+    int err;\n+\n+    s.flags = GetFileDescriptorFlags(fd);\n+    CHECK_NE(s.flags, -1);\n+\n+    if (!isatty(fd)) continue;\n+    s.isatty = true;\n+    do {\n+      err = tcgetattr(fd, &s.termios);\n+    } while (err == -1 && errno == EINTR);\n+    CHECK_EQ(err, 0);\n+  }\n+\n   RegisterSignalHandler(SIGINT, SignalExit, true);\n   RegisterSignalHandler(SIGTERM, SignalExit, true);\n \n@@ -3910,6 +3955,49 @@ inline void PlatformInit() {\n }\n \n \n+// This function must be safe to call more than once and from signal handlers.\n+inline void PlatformExit() {\n+#ifdef __POSIX__\n+  for (auto& s : stdio) {\n+    const int fd = &s - stdio;\n+\n+    struct stat tmp;\n+    if (-1 == fstat(fd, &tmp)) {\n+      CHECK_EQ(errno, EBADF);  // Program closed file descriptor.\n+      continue;\n+    }\n+\n+    bool is_same_file =\n+        (s.stat.st_dev == tmp.st_dev && s.stat.st_ino == tmp.st_ino);\n+    if (!is_same_file) continue;  // Program reopened file descriptor.\n+\n+    int flags = GetFileDescriptorFlags(fd);\n+    CHECK_NE(flags, -1);\n+\n+    // Restore the O_NONBLOCK flag if it changed.\n+    if (O_NONBLOCK & (flags ^ s.flags)) {\n+      flags &= ~O_NONBLOCK;\n+      flags |= s.flags & O_NONBLOCK;\n+\n+      int err;\n+      do {\n+        err = fcntl(fd, F_SETFL, flags);\n+      } while (err == -1 && errno == EINTR);\n+      CHECK_NE(err, -1);\n+    }\n+\n+    if (s.isatty) {\n+      int err;\n+      do {\n+        err = tcsetattr(fd, TCSANOW, &s.termios);\n+      } while (err == -1 && errno == EINTR);\n+      CHECK_NE(err, -1);\n+    }\n+  }\n+#endif  // __POSIX__\n+}\n+\n+\n void ProcessArgv(int* argc,\n                  const char** argv,\n                  int* exec_argc,\n@@ -4374,7 +4462,7 @@ inline int Start(uv_loop_t* event_loop,\n }\n \n int Start(int argc, char** argv) {\n-  atexit([] () { uv_tty_reset_mode(); });\n+  atexit([] () { PlatformExit(); });\n   PlatformInit();\n   performance::performance_node_start = PERFORMANCE_NOW();\n "
        }
    ],
    "stats": {
        "total": 100,
        "additions": 94,
        "deletions": 6
    }
}