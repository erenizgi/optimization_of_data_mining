{
    "author": "wuweiweiwu",
    "message": "crypto: add ECDH.convertKey to convert public keys\n\nECDH.convertKey is used to convert public keys between different\nformats.\n\nPR-URL: https://github.com/nodejs/node/pull/19080\nFixes: https://github.com/nodejs/node/issues/18977\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "f2e02883e7ef6ff58331e980f91bc31d8076a5c8",
    "files": [
        {
            "sha": "4c2354f52eb44d2417ad52595889312bb32ab5fd",
            "filename": "doc/api/crypto.md",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/doc%2Fapi%2Fcrypto.md",
            "raw_url": "https://github.com/nodejs/node/raw/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/doc%2Fapi%2Fcrypto.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fcrypto.md?ref=f2e02883e7ef6ff58331e980f91bc31d8076a5c8",
            "patch": "@@ -656,6 +656,54 @@ assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));\n // OK\n ```\n \n+### ECDH.convertKey(key, curve[, inputEncoding[, outputEncoding[, format]]])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+- `key` {string | Buffer | TypedArray | DataView}\n+- `curve` {string}\n+- `inputEncoding` {string}\n+- `outputEncoding` {string}\n+- `format` {string} Defaults to `uncompressed`.\n+\n+Converts the EC Diffie-Hellman public key specified by `key` and `curve` to the\n+format specified by `format`. The `format` argument specifies point encoding\n+and can be `'compressed'`, `'uncompressed'` or `'hybrid'`. The supplied key is\n+interpreted using the specified `inputEncoding`, and the returned key is encoded\n+using the specified `outputEncoding`. Encodings can be `'latin1'`, `'hex'`,\n+or `'base64'`.\n+\n+Use [`crypto.getCurves()`][] to obtain a list of available curve names.\n+On recent OpenSSL releases, `openssl ecparam -list_curves` will also display\n+the name and description of each available elliptic curve.\n+\n+If `format` is not specified the point will be returned in `'uncompressed'`\n+format.\n+\n+If the `inputEncoding` is not provided, `key` is expected to be a [`Buffer`][],\n+`TypedArray`, or `DataView`.\n+\n+Example (uncompressing a key):\n+\n+```js\n+const { ECDH } = require('crypto');\n+\n+const ecdh = ECDH('secp256k1');\n+ecdh.generateKeys();\n+\n+const compressedKey = ecdh.getPublicKey('hex', 'compressed');\n+\n+const uncompressedKey = ECDH.convertKey(compressedKey,\n+                                        'secp256k1',\n+                                        'hex',\n+                                        'hex',\n+                                        'uncompressed');\n+\n+// the converted key and the uncompressed public key should be the same\n+console.log(uncompressedKey === ecdh.getPublicKey('hex'));\n+```\n+\n ### ecdh.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])\n <!-- YAML\n added: v0.11.14"
        },
        {
            "sha": "793f3fb351460ee0774160b7d018c1f5e855bcc8",
            "filename": "lib/internal/crypto/diffiehellman.js",
            "status": "modified",
            "additions": 50,
            "deletions": 32,
            "changes": 82,
            "blob_url": "https://github.com/nodejs/node/blob/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/lib%2Finternal%2Fcrypto%2Fdiffiehellman.js",
            "raw_url": "https://github.com/nodejs/node/raw/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/lib%2Finternal%2Fcrypto%2Fdiffiehellman.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fdiffiehellman.js?ref=f2e02883e7ef6ff58331e980f91bc31d8076a5c8",
            "patch": "@@ -14,7 +14,8 @@ const {\n const {\n   DiffieHellman: _DiffieHellman,\n   DiffieHellmanGroup: _DiffieHellmanGroup,\n-  ECDH: _ECDH\n+  ECDH: _ECDH,\n+  ECDHConvertKey: _ECDHConvertKey\n } = process.binding('crypto');\n const {\n   POINT_CONVERSION_COMPRESSED,\n@@ -84,11 +85,9 @@ DiffieHellmanGroup.prototype.generateKeys =\n     dhGenerateKeys;\n \n function dhGenerateKeys(encoding) {\n-  var keys = this._handle.generateKeys();\n+  const keys = this._handle.generateKeys();\n   encoding = encoding || getDefaultEncoding();\n-  if (encoding && encoding !== 'buffer')\n-    keys = keys.toString(encoding);\n-  return keys;\n+  return encode(keys, encoding);\n }\n \n \n@@ -100,12 +99,10 @@ function dhComputeSecret(key, inEnc, outEnc) {\n   const encoding = getDefaultEncoding();\n   inEnc = inEnc || encoding;\n   outEnc = outEnc || encoding;\n-  var ret = this._handle.computeSecret(toBuf(key, inEnc));\n+  const ret = this._handle.computeSecret(toBuf(key, inEnc));\n   if (typeof ret === 'string')\n     throw new ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY();\n-  if (outEnc && outEnc !== 'buffer')\n-    ret = ret.toString(outEnc);\n-  return ret;\n+  return encode(ret, outEnc);\n }\n \n \n@@ -114,11 +111,9 @@ DiffieHellmanGroup.prototype.getPrime =\n     dhGetPrime;\n \n function dhGetPrime(encoding) {\n-  var prime = this._handle.getPrime();\n+  const prime = this._handle.getPrime();\n   encoding = encoding || getDefaultEncoding();\n-  if (encoding && encoding !== 'buffer')\n-    prime = prime.toString(encoding);\n-  return prime;\n+  return encode(prime, encoding);\n }\n \n \n@@ -127,11 +122,9 @@ DiffieHellmanGroup.prototype.getGenerator =\n     dhGetGenerator;\n \n function dhGetGenerator(encoding) {\n-  var generator = this._handle.getGenerator();\n+  const generator = this._handle.getGenerator();\n   encoding = encoding || getDefaultEncoding();\n-  if (encoding && encoding !== 'buffer')\n-    generator = generator.toString(encoding);\n-  return generator;\n+  return encode(generator, encoding);\n }\n \n \n@@ -140,11 +133,9 @@ DiffieHellmanGroup.prototype.getPublicKey =\n     dhGetPublicKey;\n \n function dhGetPublicKey(encoding) {\n-  var key = this._handle.getPublicKey();\n+  const key = this._handle.getPublicKey();\n   encoding = encoding || getDefaultEncoding();\n-  if (encoding && encoding !== 'buffer')\n-    key = key.toString(encoding);\n-  return key;\n+  return encode(key, encoding);\n }\n \n \n@@ -153,11 +144,9 @@ DiffieHellmanGroup.prototype.getPrivateKey =\n     dhGetPrivateKey;\n \n function dhGetPrivateKey(encoding) {\n-  var key = this._handle.getPrivateKey();\n+  const key = this._handle.getPrivateKey();\n   encoding = encoding || getDefaultEncoding();\n-  if (encoding && encoding !== 'buffer')\n-    key = key.toString(encoding);\n-  return key;\n+  return encode(key, encoding);\n }\n \n \n@@ -197,7 +186,40 @@ ECDH.prototype.generateKeys = function generateKeys(encoding, format) {\n };\n \n ECDH.prototype.getPublicKey = function getPublicKey(encoding, format) {\n-  var f;\n+  const f = getFormat(format);\n+  const key = this._handle.getPublicKey(f);\n+  encoding = encoding || getDefaultEncoding();\n+  return encode(key, encoding);\n+};\n+\n+ECDH.convertKey = function convertKey(key, curve, inEnc, outEnc, format) {\n+  if (typeof key !== 'string' && !isArrayBufferView(key)) {\n+    throw new ERR_INVALID_ARG_TYPE(\n+      'key',\n+      ['string', 'Buffer', 'TypedArray', 'DataView']\n+    );\n+  }\n+\n+  if (typeof curve !== 'string') {\n+    throw new ERR_INVALID_ARG_TYPE('curve', 'string');\n+  }\n+\n+  const encoding = getDefaultEncoding();\n+  inEnc = inEnc || encoding;\n+  outEnc = outEnc || encoding;\n+  const f = getFormat(format);\n+  const convertedKey = _ECDHConvertKey(toBuf(key, inEnc), curve, f);\n+  return encode(convertedKey, outEnc);\n+};\n+\n+function encode(buffer, encoding) {\n+  if (encoding && encoding !== 'buffer')\n+    buffer = buffer.toString(encoding);\n+  return buffer;\n+}\n+\n+function getFormat(format) {\n+  let f;\n   if (format) {\n     if (format === 'compressed')\n       f = POINT_CONVERSION_COMPRESSED;\n@@ -211,12 +233,8 @@ ECDH.prototype.getPublicKey = function getPublicKey(encoding, format) {\n   } else {\n     f = POINT_CONVERSION_UNCOMPRESSED;\n   }\n-  var key = this._handle.getPublicKey(f);\n-  encoding = encoding || getDefaultEncoding();\n-  if (encoding && encoding !== 'buffer')\n-    key = key.toString(encoding);\n-  return key;\n-};\n+  return f;\n+}\n \n module.exports = {\n   DiffieHellman,"
        },
        {
            "sha": "3253b701f3bb82b7dc859ec724fd9c899a9dfc34",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 72,
            "deletions": 11,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=f2e02883e7ef6ff58331e980f91bc31d8076a5c8",
            "patch": "@@ -4731,31 +4731,31 @@ void ECDH::GenerateKeys(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-EC_POINT* ECDH::BufferToPoint(char* data, size_t len) {\n+EC_POINT* ECDH::BufferToPoint(Environment* env,\n+                              const EC_GROUP* group,\n+                              char* data,\n+                              size_t len) {\n   EC_POINT* pub;\n   int r;\n \n-  pub = EC_POINT_new(group_);\n+  pub = EC_POINT_new(group);\n   if (pub == nullptr) {\n-    env()->ThrowError(\"Failed to allocate EC_POINT for a public key\");\n+    env->ThrowError(\"Failed to allocate EC_POINT for a public key\");\n     return nullptr;\n   }\n \n   r = EC_POINT_oct2point(\n-      group_,\n+      group,\n       pub,\n       reinterpret_cast<unsigned char*>(data),\n       len,\n       nullptr);\n   if (!r) {\n-    goto fatal;\n+    EC_POINT_free(pub);\n+    return nullptr;\n   }\n \n   return pub;\n-\n- fatal:\n-  EC_POINT_free(pub);\n-  return nullptr;\n }\n \n \n@@ -4772,7 +4772,9 @@ void ECDH::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n   if (!ecdh->IsKeyPairValid())\n     return env->ThrowError(\"Invalid key pair\");\n \n-  EC_POINT* pub = ecdh->BufferToPoint(Buffer::Data(args[0]),\n+  EC_POINT* pub = ECDH::BufferToPoint(env,\n+                                      ecdh->group_,\n+                                      Buffer::Data(args[0]),\n                                       Buffer::Length(args[0]));\n   if (pub == nullptr) {\n     args.GetReturnValue().Set(\n@@ -4921,7 +4923,9 @@ void ECDH::SetPublicKey(const FunctionCallbackInfo<Value>& args) {\n \n   MarkPopErrorOnReturn mark_pop_error_on_return;\n \n-  EC_POINT* pub = ecdh->BufferToPoint(Buffer::Data(args[0].As<Object>()),\n+  EC_POINT* pub = ECDH::BufferToPoint(env,\n+                                      ecdh->group_,\n+                                      Buffer::Data(args[0].As<Object>()),\n                                       Buffer::Length(args[0].As<Object>()));\n   if (pub == nullptr)\n     return env->ThrowError(\"Failed to convert Buffer to EC_POINT\");\n@@ -5597,6 +5601,61 @@ void ExportChallenge(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(outString);\n }\n \n+\n+// Convert the input public key to compressed, uncompressed, or hybrid formats.\n+void ConvertKey(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  CHECK_EQ(args.Length(), 3);\n+\n+  size_t len = Buffer::Length(args[0]);\n+  if (len == 0)\n+    return args.GetReturnValue().SetEmptyString();\n+\n+  node::Utf8Value curve(env->isolate(), args[1]);\n+\n+  int nid = OBJ_sn2nid(*curve);\n+  if (nid == NID_undef)\n+    return env->ThrowTypeError(\"Invalid ECDH curve name\");\n+\n+  EC_GROUP* group = EC_GROUP_new_by_curve_name(nid);\n+  if (group == nullptr)\n+    return env->ThrowError(\"Failed to get EC_GROUP\");\n+\n+  EC_POINT* pub = ECDH::BufferToPoint(env,\n+                                      group,\n+                                      Buffer::Data(args[0]),\n+                                      len);\n+\n+  std::shared_ptr<void> cleanup(nullptr, [group, pub] (...) {\n+    EC_GROUP_free(group);\n+    EC_POINT_free(pub);\n+  });\n+\n+  if (pub == nullptr)\n+    return env->ThrowError(\"Failed to convert Buffer to EC_POINT\");\n+\n+  point_conversion_form_t form =\n+      static_cast<point_conversion_form_t>(args[2]->Uint32Value());\n+\n+  int size = EC_POINT_point2oct(group, pub, form, nullptr, 0, nullptr);\n+  if (size == 0)\n+    return env->ThrowError(\"Failed to get public key length\");\n+\n+  unsigned char* out = node::Malloc<unsigned char>(size);\n+\n+  int r = EC_POINT_point2oct(group, pub, form, out, size, nullptr);\n+  if (r != size) {\n+    free(out);\n+    return env->ThrowError(\"Failed to get public key\");\n+  }\n+\n+  Local<Object> buf =\n+      Buffer::New(env, reinterpret_cast<char*>(out), size).ToLocalChecked();\n+  args.GetReturnValue().Set(buf);\n+}\n+\n+\n void TimingSafeEqual(const FunctionCallbackInfo<Value>& args) {\n   CHECK(Buffer::HasInstance(args[0]));\n   CHECK(Buffer::HasInstance(args[1]));\n@@ -5739,6 +5798,8 @@ void InitCrypto(Local<Object> target,\n   env->SetMethod(target, \"certVerifySpkac\", VerifySpkac);\n   env->SetMethod(target, \"certExportPublicKey\", ExportPublicKey);\n   env->SetMethod(target, \"certExportChallenge\", ExportChallenge);\n+\n+  env->SetMethod(target, \"ECDHConvertKey\", ConvertKey);\n #ifndef OPENSSL_NO_ENGINE\n   env->SetMethod(target, \"setEngine\", SetEngine);\n #endif  // !OPENSSL_NO_ENGINE"
        },
        {
            "sha": "1b2170ef851f95630324c85d311bfce6fe9e4a51",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=f2e02883e7ef6ff58331e980f91bc31d8076a5c8",
            "patch": "@@ -627,6 +627,10 @@ class ECDH : public BaseObject {\n   }\n \n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n+  static EC_POINT* BufferToPoint(Environment* env,\n+                                 const EC_GROUP* group,\n+                                 char* data,\n+                                 size_t len);\n \n  protected:\n   ECDH(Environment* env, v8::Local<v8::Object> wrap, EC_KEY* key)\n@@ -645,8 +649,6 @@ class ECDH : public BaseObject {\n   static void GetPublicKey(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void SetPublicKey(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n-  EC_POINT* BufferToPoint(char* data, size_t len);\n-\n   bool IsKeyPairValid();\n   bool IsKeyValidForCurve(const BIGNUM* private_key);\n "
        },
        {
            "sha": "407178a1953250d520a0cb87281bd86f20bed2ac",
            "filename": "test/parallel/test-crypto-ecdh-convert-key.js",
            "status": "added",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/nodejs/node/blob/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/test%2Fparallel%2Ftest-crypto-ecdh-convert-key.js",
            "raw_url": "https://github.com/nodejs/node/raw/f2e02883e7ef6ff58331e980f91bc31d8076a5c8/test%2Fparallel%2Ftest-crypto-ecdh-convert-key.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-ecdh-convert-key.js?ref=f2e02883e7ef6ff58331e980f91bc31d8076a5c8",
            "patch": "@@ -0,0 +1,101 @@\n+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+\n+const assert = require('assert');\n+\n+const { ECDH, getCurves } = require('crypto');\n+\n+// A valid private key for the secp256k1 curve.\n+const cafebabeKey = 'cafebabe'.repeat(8);\n+// Associated compressed and uncompressed public keys (points).\n+const cafebabePubPtComp =\n+    '03672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3';\n+const cafebabePubPtUnComp =\n+    '04672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3' +\n+    '2e02c7f93d13dc2732b760ca377a5897b9dd41a1c1b29dc0442fdce6d0a04d1d';\n+\n+// Invalid test: key argument is undefined.\n+common.expectsError(\n+  () => ECDH.convertKey(),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+  });\n+\n+// Invalid test: curve argument is undefined.\n+common.expectsError(\n+  () => ECDH.convertKey(cafebabePubPtComp),\n+  {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError,\n+  });\n+\n+// Invalid test: curve argument is invalid.\n+common.expectsError(\n+  () => ECDH.convertKey(cafebabePubPtComp, 'badcurve'),\n+  {\n+    type: TypeError,\n+    message: 'Invalid ECDH curve name'\n+  });\n+\n+if (getCurves().includes('secp256k1')) {\n+  // Invalid test: format argument is undefined.\n+  common.expectsError(\n+    () => ECDH.convertKey(cafebabePubPtComp, 'secp256k1', 'hex', 'hex', 10),\n+    {\n+      code: 'ERR_CRYPTO_ECDH_INVALID_FORMAT',\n+      type: TypeError,\n+      message: 'Invalid ECDH format: 10'\n+    });\n+\n+  // Point formats.\n+  let uncompressed = ECDH.convertKey(cafebabePubPtComp,\n+                                     'secp256k1',\n+                                     'hex',\n+                                     'buffer',\n+                                     'uncompressed');\n+  let compressed = ECDH.convertKey(cafebabePubPtComp,\n+                                   'secp256k1',\n+                                   'hex',\n+                                   'buffer',\n+                                   'compressed');\n+  let hybrid = ECDH.convertKey(cafebabePubPtComp,\n+                               'secp256k1',\n+                               'hex',\n+                               'buffer',\n+                               'hybrid');\n+  assert.strictEqual(uncompressed[0], 4);\n+  let firstByte = compressed[0];\n+  assert(firstByte === 2 || firstByte === 3);\n+  firstByte = hybrid[0];\n+  assert(firstByte === 6 || firstByte === 7);\n+\n+  // Format conversion from hex to hex\n+  uncompressed = ECDH.convertKey(cafebabePubPtComp,\n+                                 'secp256k1',\n+                                 'hex',\n+                                 'hex',\n+                                 'uncompressed');\n+  compressed = ECDH.convertKey(cafebabePubPtComp,\n+                               'secp256k1',\n+                               'hex',\n+                               'hex',\n+                               'compressed');\n+  hybrid = ECDH.convertKey(cafebabePubPtComp,\n+                           'secp256k1',\n+                           'hex',\n+                           'hex',\n+                           'hybrid');\n+  assert.strictEqual(uncompressed, cafebabePubPtUnComp);\n+  assert.strictEqual(compressed, cafebabePubPtComp);\n+\n+  // Compare to getPublicKey.\n+  const ecdh1 = ECDH('secp256k1');\n+  ecdh1.generateKeys();\n+  ecdh1.setPrivateKey(cafebabeKey, 'hex');\n+  assert.strictEqual(ecdh1.getPublicKey('hex', 'uncompressed'), uncompressed);\n+  assert.strictEqual(ecdh1.getPublicKey('hex', 'compressed'), compressed);\n+  assert.strictEqual(ecdh1.getPublicKey('hex', 'hybrid'), hybrid);\n+}"
        }
    ],
    "stats": {
        "total": 320,
        "additions": 275,
        "deletions": 45
    }
}