{
    "author": "jasnell",
    "message": "perf_hooks: implement histogram based api\n\nAdd a sampling-based event loop delay monitor.\n\n```js\nconst { monitorEventLoopDelay } = require('perf_hooks');\n\nconst h = monitorEventLoopDelay();\n\nh.enable();\n\nh.disable();\n\nconsole.log(h.percentiles);\nconsole.log(h.min);\nconsole.log(h.max);\nconsole.log(h.mean);\nconsole.log(h.stddev);\nconsole.log(h.percentile(50));\n```\n\nPR-URL: https://github.com/nodejs/node/pull/25378\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Stephen Belanger <admin@stephenbelanger.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "bcdd228f90b3e9e428b584814e7d52627616456a",
    "files": [
        {
            "sha": "53176c816407ecb4ce1794bf49301132669ea79b",
            "filename": "LICENSE",
            "status": "modified",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/LICENSE",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/LICENSE",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/LICENSE?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -1371,3 +1371,48 @@ The externally maintained libraries used by Node.js are:\n     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n     THE SOFTWARE.\n   \"\"\"\n+\n+- HdrHistogram, located at deps/histogram, is licensed as follows:\n+  \"\"\"\n+    The code in this repository code was Written by Gil Tene, Michael Barker,\n+    and Matt Warren, and released to the public domain, as explained at\n+    http://creativecommons.org/publicdomain/zero/1.0/\n+\n+    For users of this code who wish to consume it under the \"BSD\" license\n+    rather than under the public domain or CC0 contribution text mentioned\n+    above, the code found under this directory is *also* provided under the\n+    following license (commonly referred to as the BSD 2-Clause License). This\n+    license does not detract from the above stated release of the code into\n+    the public domain, and simply represents an additional license granted by\n+    the Author.\n+\n+    -----------------------------------------------------------------------------\n+    ** Beginning of \"BSD 2-Clause License\" text. **\n+\n+     Copyright (c) 2012, 2013, 2014 Gil Tene\n+     Copyright (c) 2014 Michael Barker\n+     Copyright (c) 2014 Matt Warren\n+     All rights reserved.\n+\n+     Redistribution and use in source and binary forms, with or without\n+     modification, are permitted provided that the following conditions are met:\n+\n+     1. Redistributions of source code must retain the above copyright notice,\n+        this list of conditions and the following disclaimer.\n+\n+     2. Redistributions in binary form must reproduce the above copyright notice,\n+        this list of conditions and the following disclaimer in the documentation\n+        and/or other materials provided with the distribution.\n+\n+     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+     ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+     LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+     THE POSSIBILITY OF SUCH DAMAGE.\n+  \"\"\""
        },
        {
            "sha": "9b4e66ed7defab66d6325f68c764eea795d02f63",
            "filename": "deps/histogram/LICENSE.txt",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2FLICENSE.txt",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2FLICENSE.txt",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fhistogram%2FLICENSE.txt?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -0,0 +1,41 @@\n+The code in this repository code was Written by Gil Tene, Michael Barker,\n+and Matt Warren, and released to the public domain, as explained at\n+http://creativecommons.org/publicdomain/zero/1.0/\n+\n+For users of this code who wish to consume it under the \"BSD\" license\n+rather than under the public domain or CC0 contribution text mentioned\n+above, the code found under this directory is *also* provided under the\n+following license (commonly referred to as the BSD 2-Clause License). This\n+license does not detract from the above stated release of the code into\n+the public domain, and simply represents an additional license granted by\n+the Author.\n+\n+-----------------------------------------------------------------------------\n+** Beginning of \"BSD 2-Clause License\" text. **\n+\n+ Copyright (c) 2012, 2013, 2014 Gil Tene\n+ Copyright (c) 2014 Michael Barker\n+ Copyright (c) 2014 Matt Warren\n+ All rights reserved.\n+\n+ Redistribution and use in source and binary forms, with or without\n+ modification, are permitted provided that the following conditions are met:\n+\n+ 1. Redistributions of source code must retain the above copyright notice,\n+    this list of conditions and the following disclaimer.\n+\n+ 2. Redistributions in binary form must reproduce the above copyright notice,\n+    this list of conditions and the following disclaimer in the documentation\n+    and/or other materials provided with the distribution.\n+\n+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
            "sha": "b6775fd6dcb6035da39036eb7d96d46a5660068f",
            "filename": "deps/histogram/README.md",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fhistogram%2FREADME.md?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -0,0 +1,3 @@\n+# HdrHistogram_c\n+\n+From: https://github.com/HdrHistogram/HdrHistogram_c"
        },
        {
            "sha": "bcfa198f9d37c13a0e739644afe674e93face8e4",
            "filename": "deps/histogram/histogram.gyp",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2Fhistogram.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2Fhistogram.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fhistogram%2Fhistogram.gyp?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -0,0 +1,15 @@\n+{\n+  'targets': [\n+    {\n+      'target_name': 'histogram',\n+      'type': 'static_library',\n+      'include_dirs': ['src'],\n+      'direct_dependent_settings': {\n+        'include_dirs': [ 'src' ]\n+      },\n+      'sources': [\n+        'src/hdr_histogram.c',\n+      ]\n+    }\n+  ]\n+}"
        },
        {
            "sha": "1d7343442d3b67b7946a93b6e6b96bba139a9949",
            "filename": "deps/histogram/src/hdr_histogram.c",
            "status": "added",
            "additions": 1032,
            "deletions": 0,
            "changes": 1032,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2Fsrc%2Fhdr_histogram.c",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2Fsrc%2Fhdr_histogram.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fhistogram%2Fsrc%2Fhdr_histogram.c?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -0,0 +1,1032 @@\n+/**\n+ * hdr_histogram.c\n+ * Written by Michael Barker and released to the public domain,\n+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/\n+ */\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+#include <math.h>\n+#include <assert.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdint.h>\n+#include <errno.h>\n+#include <inttypes.h>\n+\n+#include \"hdr_histogram.h\"\n+#include \"hdr_tests.h\"\n+\n+/*  ######   #######  ##     ## ##    ## ########  ######  */\n+/* ##    ## ##     ## ##     ## ###   ##    ##    ##    ## */\n+/* ##       ##     ## ##     ## ####  ##    ##    ##       */\n+/* ##       ##     ## ##     ## ## ## ##    ##     ######  */\n+/* ##       ##     ## ##     ## ##  ####    ##          ## */\n+/* ##    ## ##     ## ##     ## ##   ###    ##    ##    ## */\n+/*  ######   #######   #######  ##    ##    ##     ######  */\n+\n+static int32_t normalize_index(const struct hdr_histogram* h, int32_t index)\n+{\n+    int32_t normalized_index;\n+    int32_t adjustment = 0;\n+    if (h->normalizing_index_offset == 0)\n+    {\n+        return index;\n+    }\n+\n+    normalized_index = index - h->normalizing_index_offset;\n+\n+    if (normalized_index < 0)\n+    {\n+        adjustment = h->counts_len;\n+    }\n+    else if (normalized_index >= h->counts_len)\n+    {\n+        adjustment = -h->counts_len;\n+    }\n+\n+    return normalized_index + adjustment;\n+}\n+\n+static int64_t counts_get_direct(const struct hdr_histogram* h, int32_t index)\n+{\n+    return h->counts[index];\n+}\n+\n+static int64_t counts_get_normalised(const struct hdr_histogram* h, int32_t index)\n+{\n+    return counts_get_direct(h, normalize_index(h, index));\n+}\n+\n+static void counts_inc_normalised(\n+    struct hdr_histogram* h, int32_t index, int64_t value)\n+{\n+    int32_t normalised_index = normalize_index(h, index);\n+    h->counts[normalised_index] += value;\n+    h->total_count += value;\n+}\n+\n+static void update_min_max(struct hdr_histogram* h, int64_t value)\n+{\n+    h->min_value = (value < h->min_value && value != 0) ? value : h->min_value;\n+    h->max_value = (value > h->max_value) ? value : h->max_value;\n+}\n+\n+/* ##     ## ######## #### ##       #### ######## ##    ## */\n+/* ##     ##    ##     ##  ##        ##     ##     ##  ##  */\n+/* ##     ##    ##     ##  ##        ##     ##      ####   */\n+/* ##     ##    ##     ##  ##        ##     ##       ##    */\n+/* ##     ##    ##     ##  ##        ##     ##       ##    */\n+/* ##     ##    ##     ##  ##        ##     ##       ##    */\n+/*  #######     ##    #### ######## ####    ##       ##    */\n+\n+static int64_t power(int64_t base, int64_t exp)\n+{\n+    int64_t result = 1;\n+    while(exp)\n+    {\n+        result *= base; exp--;\n+    }\n+    return result;\n+}\n+\n+#if defined(_MSC_VER)\n+#pragma intrinsic(_BitScanReverse64)\n+#endif\n+\n+static int32_t get_bucket_index(const struct hdr_histogram* h, int64_t value)\n+{\n+#if defined(_MSC_VER)\n+    uint32_t leading_zero = 0;\n+    _BitScanReverse64(&leading_zero, value | h->sub_bucket_mask);\n+    int32_t pow2ceiling = 64 - (63 - leading_zero); /* smallest power of 2 containing value */\n+#else\n+    int32_t pow2ceiling = 64 - __builtin_clzll(value | h->sub_bucket_mask); /* smallest power of 2 containing value */\n+#endif\n+    return pow2ceiling - h->unit_magnitude - (h->sub_bucket_half_count_magnitude + 1);\n+}\n+\n+static int32_t get_sub_bucket_index(int64_t value, int32_t bucket_index, int32_t unit_magnitude)\n+{\n+    return (int32_t)(value >> (bucket_index + unit_magnitude));\n+}\n+\n+static int32_t counts_index(const struct hdr_histogram* h, int32_t bucket_index, int32_t sub_bucket_index)\n+{\n+    /* Calculate the index for the first entry in the bucket: */\n+    /* (The following is the equivalent of ((bucket_index + 1) * subBucketHalfCount) ): */\n+    int32_t bucket_base_index = (bucket_index + 1) << h->sub_bucket_half_count_magnitude;\n+    /* Calculate the offset in the bucket: */\n+    int32_t offset_in_bucket = sub_bucket_index - h->sub_bucket_half_count;\n+    /* The following is the equivalent of ((sub_bucket_index  - subBucketHalfCount) + bucketBaseIndex; */\n+    return bucket_base_index + offset_in_bucket;\n+}\n+\n+static int64_t value_from_index(int32_t bucket_index, int32_t sub_bucket_index, int32_t unit_magnitude)\n+{\n+    return ((int64_t) sub_bucket_index) << (bucket_index + unit_magnitude);\n+}\n+\n+int32_t counts_index_for(const struct hdr_histogram* h, int64_t value)\n+{\n+    int32_t bucket_index     = get_bucket_index(h, value);\n+    int32_t sub_bucket_index = get_sub_bucket_index(value, bucket_index, h->unit_magnitude);\n+\n+    return counts_index(h, bucket_index, sub_bucket_index);\n+}\n+\n+int64_t hdr_value_at_index(const struct hdr_histogram *h, int32_t index)\n+{\n+    int32_t bucket_index = (index >> h->sub_bucket_half_count_magnitude) - 1;\n+    int32_t sub_bucket_index = (index & (h->sub_bucket_half_count - 1)) + h->sub_bucket_half_count;\n+\n+    if (bucket_index < 0)\n+    {\n+        sub_bucket_index -= h->sub_bucket_half_count;\n+        bucket_index = 0;\n+    }\n+\n+    return value_from_index(bucket_index, sub_bucket_index, h->unit_magnitude);\n+}\n+\n+int64_t hdr_size_of_equivalent_value_range(const struct hdr_histogram* h, int64_t value)\n+{\n+    int32_t bucket_index     = get_bucket_index(h, value);\n+    int32_t sub_bucket_index = get_sub_bucket_index(value, bucket_index, h->unit_magnitude);\n+    int32_t adjusted_bucket  = (sub_bucket_index >= h->sub_bucket_count) ? (bucket_index + 1) : bucket_index;\n+    return INT64_C(1) << (h->unit_magnitude + adjusted_bucket);\n+}\n+\n+static int64_t lowest_equivalent_value(const struct hdr_histogram* h, int64_t value)\n+{\n+    int32_t bucket_index     = get_bucket_index(h, value);\n+    int32_t sub_bucket_index = get_sub_bucket_index(value, bucket_index, h->unit_magnitude);\n+    return value_from_index(bucket_index, sub_bucket_index, h->unit_magnitude);\n+}\n+\n+int64_t hdr_next_non_equivalent_value(const struct hdr_histogram *h, int64_t value)\n+{\n+    return lowest_equivalent_value(h, value) + hdr_size_of_equivalent_value_range(h, value);\n+}\n+\n+static int64_t highest_equivalent_value(const struct hdr_histogram* h, int64_t value)\n+{\n+    return hdr_next_non_equivalent_value(h, value) - 1;\n+}\n+\n+int64_t hdr_median_equivalent_value(const struct hdr_histogram *h, int64_t value)\n+{\n+    return lowest_equivalent_value(h, value) + (hdr_size_of_equivalent_value_range(h, value) >> 1);\n+}\n+\n+static int64_t non_zero_min(const struct hdr_histogram* h)\n+{\n+    if (INT64_MAX == h->min_value)\n+    {\n+        return INT64_MAX;\n+    }\n+\n+    return lowest_equivalent_value(h, h->min_value);\n+}\n+\n+void hdr_reset_internal_counters(struct hdr_histogram* h)\n+{\n+    int min_non_zero_index = -1;\n+    int max_index = -1;\n+    int64_t observed_total_count = 0;\n+    int i;\n+\n+    for (i = 0; i < h->counts_len; i++)\n+    {\n+        int64_t count_at_index;\n+\n+        if ((count_at_index = counts_get_direct(h, i)) > 0)\n+        {\n+            observed_total_count += count_at_index;\n+            max_index = i;\n+            if (min_non_zero_index == -1 && i != 0)\n+            {\n+                min_non_zero_index = i;\n+            }\n+        }\n+    }\n+\n+    if (max_index == -1)\n+    {\n+        h->max_value = 0;\n+    }\n+    else\n+    {\n+        int64_t max_value = hdr_value_at_index(h, max_index);\n+        h->max_value = highest_equivalent_value(h, max_value);\n+    }\n+\n+    if (min_non_zero_index == -1)\n+    {\n+        h->min_value = INT64_MAX;\n+    }\n+    else\n+    {\n+        h->min_value = hdr_value_at_index(h, min_non_zero_index);\n+    }\n+\n+    h->total_count = observed_total_count;\n+}\n+\n+static int32_t buckets_needed_to_cover_value(int64_t value, int32_t sub_bucket_count, int32_t unit_magnitude)\n+{\n+    int64_t smallest_untrackable_value = ((int64_t) sub_bucket_count) << unit_magnitude;\n+    int32_t buckets_needed = 1;\n+    while (smallest_untrackable_value <= value)\n+    {\n+        if (smallest_untrackable_value > INT64_MAX / 2)\n+        {\n+            return buckets_needed + 1;\n+        }\n+        smallest_untrackable_value <<= 1;\n+        buckets_needed++;\n+    }\n+\n+    return buckets_needed;\n+}\n+\n+/* ##     ## ######## ##     ##  #######  ########  ##    ## */\n+/* ###   ### ##       ###   ### ##     ## ##     ##  ##  ##  */\n+/* #### #### ##       #### #### ##     ## ##     ##   ####   */\n+/* ## ### ## ######   ## ### ## ##     ## ########     ##    */\n+/* ##     ## ##       ##     ## ##     ## ##   ##      ##    */\n+/* ##     ## ##       ##     ## ##     ## ##    ##     ##    */\n+/* ##     ## ######## ##     ##  #######  ##     ##    ##    */\n+\n+int hdr_calculate_bucket_config(\n+        int64_t lowest_trackable_value,\n+        int64_t highest_trackable_value,\n+        int significant_figures,\n+        struct hdr_histogram_bucket_config* cfg)\n+{\n+    int32_t sub_bucket_count_magnitude;\n+    int64_t largest_value_with_single_unit_resolution;\n+\n+    if (lowest_trackable_value < 1 ||\n+            significant_figures < 1 || 5 < significant_figures)\n+    {\n+        return EINVAL;\n+    }\n+    else if (lowest_trackable_value * 2 > highest_trackable_value)\n+    {\n+        return EINVAL;\n+    }\n+\n+    cfg->lowest_trackable_value = lowest_trackable_value;\n+    cfg->significant_figures = significant_figures;\n+    cfg->highest_trackable_value = highest_trackable_value;\n+\n+    largest_value_with_single_unit_resolution = 2 * power(10, significant_figures);\n+    sub_bucket_count_magnitude = (int32_t) ceil(log((double)largest_value_with_single_unit_resolution) / log(2));\n+    cfg->sub_bucket_half_count_magnitude = ((sub_bucket_count_magnitude > 1) ? sub_bucket_count_magnitude : 1) - 1;\n+\n+    cfg->unit_magnitude = (int32_t) floor(log((double)lowest_trackable_value) / log(2));\n+\n+    cfg->sub_bucket_count      = (int32_t) pow(2, (cfg->sub_bucket_half_count_magnitude + 1));\n+    cfg->sub_bucket_half_count = cfg->sub_bucket_count / 2;\n+    cfg->sub_bucket_mask       = ((int64_t) cfg->sub_bucket_count - 1) << cfg->unit_magnitude;\n+\n+    if (cfg->unit_magnitude + cfg->sub_bucket_half_count_magnitude > 61)\n+    {\n+        return EINVAL;\n+    }\n+\n+    cfg->bucket_count = buckets_needed_to_cover_value(highest_trackable_value, cfg->sub_bucket_count, (int32_t)cfg->unit_magnitude);\n+    cfg->counts_len = (cfg->bucket_count + 1) * (cfg->sub_bucket_count / 2);\n+\n+    return 0;\n+}\n+\n+void hdr_init_preallocated(struct hdr_histogram* h, struct hdr_histogram_bucket_config* cfg)\n+{\n+    h->lowest_trackable_value          = cfg->lowest_trackable_value;\n+    h->highest_trackable_value         = cfg->highest_trackable_value;\n+    h->unit_magnitude                  = (int32_t)cfg->unit_magnitude;\n+    h->significant_figures             = (int32_t)cfg->significant_figures;\n+    h->sub_bucket_half_count_magnitude = cfg->sub_bucket_half_count_magnitude;\n+    h->sub_bucket_half_count           = cfg->sub_bucket_half_count;\n+    h->sub_bucket_mask                 = cfg->sub_bucket_mask;\n+    h->sub_bucket_count                = cfg->sub_bucket_count;\n+    h->min_value                       = INT64_MAX;\n+    h->max_value                       = 0;\n+    h->normalizing_index_offset        = 0;\n+    h->conversion_ratio                = 1.0;\n+    h->bucket_count                    = cfg->bucket_count;\n+    h->counts_len                      = cfg->counts_len;\n+    h->total_count                     = 0;\n+}\n+\n+int hdr_init(\n+        int64_t lowest_trackable_value,\n+        int64_t highest_trackable_value,\n+        int significant_figures,\n+        struct hdr_histogram** result)\n+{\n+    int64_t* counts;\n+    struct hdr_histogram_bucket_config cfg;\n+    struct hdr_histogram* histogram;\n+\n+    int r = hdr_calculate_bucket_config(lowest_trackable_value, highest_trackable_value, significant_figures, &cfg);\n+    if (r)\n+    {\n+        return r;\n+    }\n+\n+    counts = calloc((size_t) cfg.counts_len, sizeof(int64_t));\n+    histogram = calloc(1, sizeof(struct hdr_histogram));\n+\n+    if (!counts || !histogram)\n+    {\n+        return ENOMEM;\n+    }\n+\n+    histogram->counts = counts;\n+\n+    hdr_init_preallocated(histogram, &cfg);\n+    *result = histogram;\n+\n+    return 0;\n+}\n+\n+void hdr_close(struct hdr_histogram* h)\n+{\n+    free(h->counts);\n+    free(h);\n+}\n+\n+int hdr_alloc(int64_t highest_trackable_value, int significant_figures, struct hdr_histogram** result)\n+{\n+    return hdr_init(1, highest_trackable_value, significant_figures, result);\n+}\n+\n+/* reset a histogram to zero. */\n+void hdr_reset(struct hdr_histogram *h)\n+{\n+     h->total_count=0;\n+     h->min_value = INT64_MAX;\n+     h->max_value = 0;\n+     memset(h->counts, 0, (sizeof(int64_t) * h->counts_len));\n+}\n+\n+size_t hdr_get_memory_size(struct hdr_histogram *h)\n+{\n+    return sizeof(struct hdr_histogram) + h->counts_len * sizeof(int64_t);\n+}\n+\n+/* ##     ## ########  ########     ###    ######## ########  ######  */\n+/* ##     ## ##     ## ##     ##   ## ##      ##    ##       ##    ## */\n+/* ##     ## ##     ## ##     ##  ##   ##     ##    ##       ##       */\n+/* ##     ## ########  ##     ## ##     ##    ##    ######    ######  */\n+/* ##     ## ##        ##     ## #########    ##    ##             ## */\n+/* ##     ## ##        ##     ## ##     ##    ##    ##       ##    ## */\n+/*  #######  ##        ########  ##     ##    ##    ########  ######  */\n+\n+\n+bool hdr_record_value(struct hdr_histogram* h, int64_t value)\n+{\n+    return hdr_record_values(h, value, 1);\n+}\n+\n+bool hdr_record_values(struct hdr_histogram* h, int64_t value, int64_t count)\n+{\n+    int32_t counts_index;\n+\n+    if (value < 0)\n+    {\n+        return false;\n+    }\n+\n+    counts_index = counts_index_for(h, value);\n+\n+    if (counts_index < 0 || h->counts_len <= counts_index)\n+    {\n+        return false;\n+    }\n+\n+    counts_inc_normalised(h, counts_index, count);\n+    update_min_max(h, value);\n+\n+    return true;\n+}\n+\n+bool hdr_record_corrected_value(struct hdr_histogram* h, int64_t value, int64_t expected_interval)\n+{\n+    return hdr_record_corrected_values(h, value, 1, expected_interval);\n+}\n+\n+\n+bool hdr_record_corrected_values(struct hdr_histogram* h, int64_t value, int64_t count, int64_t expected_interval)\n+{\n+    int64_t missing_value;\n+\n+    if (!hdr_record_values(h, value, count))\n+    {\n+        return false;\n+    }\n+\n+    if (expected_interval <= 0 || value <= expected_interval)\n+    {\n+        return true;\n+    }\n+\n+    missing_value = value - expected_interval;\n+    for (; missing_value >= expected_interval; missing_value -= expected_interval)\n+    {\n+        if (!hdr_record_values(h, missing_value, count))\n+        {\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+int64_t hdr_add(struct hdr_histogram* h, const struct hdr_histogram* from)\n+{\n+    struct hdr_iter iter;\n+    int64_t dropped = 0;\n+    hdr_iter_recorded_init(&iter, from);\n+\n+    while (hdr_iter_next(&iter))\n+    {\n+        int64_t value = iter.value;\n+        int64_t count = iter.count;\n+\n+        if (!hdr_record_values(h, value, count))\n+        {\n+            dropped += count;\n+        }\n+    }\n+\n+    return dropped;\n+}\n+\n+int64_t hdr_add_while_correcting_for_coordinated_omission(\n+        struct hdr_histogram* h, struct hdr_histogram* from, int64_t expected_interval)\n+{\n+    struct hdr_iter iter;\n+    int64_t dropped = 0;\n+    hdr_iter_recorded_init(&iter, from);\n+\n+    while (hdr_iter_next(&iter))\n+    {\n+        int64_t value = iter.value;\n+        int64_t count = iter.count;\n+\n+        if (!hdr_record_corrected_values(h, value, count, expected_interval))\n+        {\n+            dropped += count;\n+        }\n+    }\n+\n+    return dropped;\n+}\n+\n+\n+\n+/* ##     ##    ###    ##       ##     ## ########  ######  */\n+/* ##     ##   ## ##   ##       ##     ## ##       ##    ## */\n+/* ##     ##  ##   ##  ##       ##     ## ##       ##       */\n+/* ##     ## ##     ## ##       ##     ## ######    ######  */\n+/*  ##   ##  ######### ##       ##     ## ##             ## */\n+/*   ## ##   ##     ## ##       ##     ## ##       ##    ## */\n+/*    ###    ##     ## ########  #######  ########  ######  */\n+\n+\n+int64_t hdr_max(const struct hdr_histogram* h)\n+{\n+    if (0 == h->max_value)\n+    {\n+        return 0;\n+    }\n+\n+    return highest_equivalent_value(h, h->max_value);\n+}\n+\n+int64_t hdr_min(const struct hdr_histogram* h)\n+{\n+    if (0 < hdr_count_at_index(h, 0))\n+    {\n+        return 0;\n+    }\n+\n+    return non_zero_min(h);\n+}\n+\n+int64_t hdr_value_at_percentile(const struct hdr_histogram* h, double percentile)\n+{\n+    struct hdr_iter iter;\n+    int64_t total = 0;\n+    double requested_percentile = percentile < 100.0 ? percentile : 100.0;\n+    int64_t count_at_percentile =\n+        (int64_t) (((requested_percentile / 100) * h->total_count) + 0.5);\n+    count_at_percentile = count_at_percentile > 1 ? count_at_percentile : 1;\n+\n+    hdr_iter_init(&iter, h);\n+\n+    while (hdr_iter_next(&iter))\n+    {\n+        total += iter.count;\n+\n+        if (total >= count_at_percentile)\n+        {\n+            int64_t value_from_index = iter.value;\n+            return highest_equivalent_value(h, value_from_index);\n+        }\n+    }\n+\n+    return 0;\n+}\n+\n+double hdr_mean(const struct hdr_histogram* h)\n+{\n+    struct hdr_iter iter;\n+    int64_t total = 0;\n+\n+    hdr_iter_init(&iter, h);\n+\n+    while (hdr_iter_next(&iter))\n+    {\n+        if (0 != iter.count)\n+        {\n+            total += iter.count * hdr_median_equivalent_value(h, iter.value);\n+        }\n+    }\n+\n+    return (total * 1.0) / h->total_count;\n+}\n+\n+double hdr_stddev(const struct hdr_histogram* h)\n+{\n+    double mean = hdr_mean(h);\n+    double geometric_dev_total = 0.0;\n+\n+    struct hdr_iter iter;\n+    hdr_iter_init(&iter, h);\n+\n+    while (hdr_iter_next(&iter))\n+    {\n+        if (0 != iter.count)\n+        {\n+            double dev = (hdr_median_equivalent_value(h, iter.value) * 1.0) - mean;\n+            geometric_dev_total += (dev * dev) * iter.count;\n+        }\n+    }\n+\n+    return sqrt(geometric_dev_total / h->total_count);\n+}\n+\n+bool hdr_values_are_equivalent(const struct hdr_histogram* h, int64_t a, int64_t b)\n+{\n+    return lowest_equivalent_value(h, a) == lowest_equivalent_value(h, b);\n+}\n+\n+int64_t hdr_lowest_equivalent_value(const struct hdr_histogram* h, int64_t value)\n+{\n+    return lowest_equivalent_value(h, value);\n+}\n+\n+int64_t hdr_count_at_value(const struct hdr_histogram* h, int64_t value)\n+{\n+    return counts_get_normalised(h, counts_index_for(h, value));\n+}\n+\n+int64_t hdr_count_at_index(const struct hdr_histogram* h, int32_t index)\n+{\n+    return counts_get_normalised(h, index);\n+}\n+\n+\n+/* #### ######## ######## ########     ###    ########  #######  ########   ######  */\n+/*  ##     ##    ##       ##     ##   ## ##      ##    ##     ## ##     ## ##    ## */\n+/*  ##     ##    ##       ##     ##  ##   ##     ##    ##     ## ##     ## ##       */\n+/*  ##     ##    ######   ########  ##     ##    ##    ##     ## ########   ######  */\n+/*  ##     ##    ##       ##   ##   #########    ##    ##     ## ##   ##         ## */\n+/*  ##     ##    ##       ##    ##  ##     ##    ##    ##     ## ##    ##  ##    ## */\n+/* ####    ##    ######## ##     ## ##     ##    ##     #######  ##     ##  ######  */\n+\n+\n+static bool has_buckets(struct hdr_iter* iter)\n+{\n+    return iter->counts_index < iter->h->counts_len;\n+}\n+\n+static bool has_next(struct hdr_iter* iter)\n+{\n+    return iter->cumulative_count < iter->total_count;\n+}\n+\n+static bool move_next(struct hdr_iter* iter)\n+{\n+    iter->counts_index++;\n+\n+    if (!has_buckets(iter))\n+    {\n+        return false;\n+    }\n+\n+    iter->count = counts_get_normalised(iter->h, iter->counts_index);\n+    iter->cumulative_count += iter->count;\n+\n+    iter->value = hdr_value_at_index(iter->h, iter->counts_index);\n+    iter->highest_equivalent_value = highest_equivalent_value(iter->h, iter->value);\n+    iter->lowest_equivalent_value = lowest_equivalent_value(iter->h, iter->value);\n+    iter->median_equivalent_value = hdr_median_equivalent_value(iter->h, iter->value);\n+\n+    return true;\n+}\n+\n+static int64_t peek_next_value_from_index(struct hdr_iter* iter)\n+{\n+    return hdr_value_at_index(iter->h, iter->counts_index + 1);\n+}\n+\n+static bool next_value_greater_than_reporting_level_upper_bound(\n+    struct hdr_iter *iter, int64_t reporting_level_upper_bound)\n+{\n+    if (iter->counts_index >= iter->h->counts_len)\n+    {\n+        return false;\n+    }\n+\n+    return peek_next_value_from_index(iter) > reporting_level_upper_bound;\n+}\n+\n+static bool _basic_iter_next(struct hdr_iter *iter)\n+{\n+    if (!has_next(iter) || iter->counts_index >= iter->h->counts_len)\n+    {\n+        return false;\n+    }\n+\n+    move_next(iter);\n+\n+    return true;\n+}\n+\n+static void _update_iterated_values(struct hdr_iter* iter, int64_t new_value_iterated_to)\n+{\n+    iter->value_iterated_from = iter->value_iterated_to;\n+    iter->value_iterated_to = new_value_iterated_to;\n+}\n+\n+static bool _all_values_iter_next(struct hdr_iter* iter)\n+{\n+    bool result = move_next(iter);\n+\n+    if (result)\n+    {\n+        _update_iterated_values(iter, iter->value);\n+    }\n+\n+    return result;\n+}\n+\n+void hdr_iter_init(struct hdr_iter* iter, const struct hdr_histogram* h)\n+{\n+    iter->h = h;\n+\n+    iter->counts_index = -1;\n+    iter->total_count = h->total_count;\n+    iter->count = 0;\n+    iter->cumulative_count = 0;\n+    iter->value = 0;\n+    iter->highest_equivalent_value = 0;\n+    iter->value_iterated_from = 0;\n+    iter->value_iterated_to = 0;\n+\n+    iter->_next_fp = _all_values_iter_next;\n+}\n+\n+bool hdr_iter_next(struct hdr_iter* iter)\n+{\n+    return iter->_next_fp(iter);\n+}\n+\n+/* ########  ######## ########   ######  ######## ##    ## ######## #### ##       ########  ######  */\n+/* ##     ## ##       ##     ## ##    ## ##       ###   ##    ##     ##  ##       ##       ##    ## */\n+/* ##     ## ##       ##     ## ##       ##       ####  ##    ##     ##  ##       ##       ##       */\n+/* ########  ######   ########  ##       ######   ## ## ##    ##     ##  ##       ######    ######  */\n+/* ##        ##       ##   ##   ##       ##       ##  ####    ##     ##  ##       ##             ## */\n+/* ##        ##       ##    ##  ##    ## ##       ##   ###    ##     ##  ##       ##       ##    ## */\n+/* ##        ######## ##     ##  ######  ######## ##    ##    ##    #### ######## ########  ######  */\n+\n+static bool _percentile_iter_next(struct hdr_iter* iter)\n+{\n+    int64_t temp, half_distance, percentile_reporting_ticks;\n+\n+    struct hdr_iter_percentiles* percentiles = &iter->specifics.percentiles;\n+\n+    if (!has_next(iter))\n+    {\n+        if (percentiles->seen_last_value)\n+        {\n+            return false;\n+        }\n+\n+        percentiles->seen_last_value = true;\n+        percentiles->percentile = 100.0;\n+\n+        return true;\n+    }\n+\n+    if (iter->counts_index == -1 && !_basic_iter_next(iter))\n+    {\n+        return false;\n+    }\n+\n+    do\n+    {\n+        double current_percentile = (100.0 * (double) iter->cumulative_count) / iter->h->total_count;\n+        if (iter->count != 0 &&\n+                percentiles->percentile_to_iterate_to <= current_percentile)\n+        {\n+            _update_iterated_values(iter, highest_equivalent_value(iter->h, iter->value));\n+\n+            percentiles->percentile = percentiles->percentile_to_iterate_to;\n+            temp = (int64_t)(log(100 / (100.0 - (percentiles->percentile_to_iterate_to))) / log(2)) + 1;\n+            half_distance = (int64_t) pow(2, (double) temp);\n+            percentile_reporting_ticks = percentiles->ticks_per_half_distance * half_distance;\n+            percentiles->percentile_to_iterate_to += 100.0 / percentile_reporting_ticks;\n+\n+            return true;\n+        }\n+    }\n+    while (_basic_iter_next(iter));\n+\n+    return true;\n+}\n+\n+void hdr_iter_percentile_init(struct hdr_iter* iter, const struct hdr_histogram* h, int32_t ticks_per_half_distance)\n+{\n+    iter->h = h;\n+\n+    hdr_iter_init(iter, h);\n+\n+    iter->specifics.percentiles.seen_last_value          = false;\n+    iter->specifics.percentiles.ticks_per_half_distance  = ticks_per_half_distance;\n+    iter->specifics.percentiles.percentile_to_iterate_to = 0.0;\n+    iter->specifics.percentiles.percentile               = 0.0;\n+\n+    iter->_next_fp = _percentile_iter_next;\n+}\n+\n+static void format_line_string(char* str, size_t len, int significant_figures, format_type format)\n+{\n+#if defined(_MSC_VER)\n+#define snprintf _snprintf\n+#pragma warning(push)\n+#pragma warning(disable: 4996)\n+#endif\n+    const char* format_str = \"%s%d%s\";\n+\n+    switch (format)\n+    {\n+        case CSV:\n+            snprintf(str, len, format_str, \"%.\", significant_figures, \"f,%f,%d,%.2f\\n\");\n+            break;\n+        case CLASSIC:\n+            snprintf(str, len, format_str, \"%12.\", significant_figures, \"f %12f %12d %12.2f\\n\");\n+            break;\n+        default:\n+            snprintf(str, len, format_str, \"%12.\", significant_figures, \"f %12f %12d %12.2f\\n\");\n+    }\n+#if defined(_MSC_VER)\n+#undef snprintf\n+#pragma warning(pop)\n+#endif\n+}\n+\n+\n+/* ########  ########  ######   #######  ########  ########  ######## ########   */\n+/* ##     ## ##       ##    ## ##     ## ##     ## ##     ## ##       ##     ##  */\n+/* ##     ## ##       ##       ##     ## ##     ## ##     ## ##       ##     ##  */\n+/* ########  ######   ##       ##     ## ########  ##     ## ######   ##     ##  */\n+/* ##   ##   ##       ##       ##     ## ##   ##   ##     ## ##       ##     ##  */\n+/* ##    ##  ##       ##    ## ##     ## ##    ##  ##     ## ##       ##     ##  */\n+/* ##     ## ########  ######   #######  ##     ## ########  ######## ########   */\n+\n+\n+static bool _recorded_iter_next(struct hdr_iter* iter)\n+{\n+    while (_basic_iter_next(iter))\n+    {\n+        if (iter->count != 0)\n+        {\n+            _update_iterated_values(iter, iter->value);\n+\n+            iter->specifics.recorded.count_added_in_this_iteration_step = iter->count;\n+            return true;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+void hdr_iter_recorded_init(struct hdr_iter* iter, const struct hdr_histogram* h)\n+{\n+    hdr_iter_init(iter, h);\n+\n+    iter->specifics.recorded.count_added_in_this_iteration_step = 0;\n+\n+    iter->_next_fp = _recorded_iter_next;\n+}\n+\n+/* ##       #### ##    ## ########    ###    ########  */\n+/* ##        ##  ###   ## ##         ## ##   ##     ## */\n+/* ##        ##  ####  ## ##        ##   ##  ##     ## */\n+/* ##        ##  ## ## ## ######   ##     ## ########  */\n+/* ##        ##  ##  #### ##       ######### ##   ##   */\n+/* ##        ##  ##   ### ##       ##     ## ##    ##  */\n+/* ######## #### ##    ## ######## ##     ## ##     ## */\n+\n+\n+static bool _iter_linear_next(struct hdr_iter* iter)\n+{\n+    struct hdr_iter_linear* linear = &iter->specifics.linear;\n+\n+    linear->count_added_in_this_iteration_step = 0;\n+\n+    if (has_next(iter) ||\n+        next_value_greater_than_reporting_level_upper_bound(\n+            iter, linear->next_value_reporting_level_lowest_equivalent))\n+    {\n+        do\n+        {\n+            if (iter->value >= linear->next_value_reporting_level_lowest_equivalent)\n+            {\n+                _update_iterated_values(iter, linear->next_value_reporting_level);\n+\n+                linear->next_value_reporting_level += linear->value_units_per_bucket;\n+                linear->next_value_reporting_level_lowest_equivalent =\n+                    lowest_equivalent_value(iter->h, linear->next_value_reporting_level);\n+\n+                return true;\n+            }\n+\n+            if (!move_next(iter))\n+            {\n+                return true;\n+            }\n+\n+            linear->count_added_in_this_iteration_step += iter->count;\n+        }\n+        while (true);\n+    }\n+\n+    return false;\n+}\n+\n+\n+void hdr_iter_linear_init(struct hdr_iter* iter, const struct hdr_histogram* h, int64_t value_units_per_bucket)\n+{\n+    hdr_iter_init(iter, h);\n+\n+    iter->specifics.linear.count_added_in_this_iteration_step = 0;\n+    iter->specifics.linear.value_units_per_bucket = value_units_per_bucket;\n+    iter->specifics.linear.next_value_reporting_level = value_units_per_bucket;\n+    iter->specifics.linear.next_value_reporting_level_lowest_equivalent = lowest_equivalent_value(h, value_units_per_bucket);\n+\n+    iter->_next_fp = _iter_linear_next;\n+}\n+\n+/* ##        #######   ######      ###    ########  #### ######## ##     ## ##     ## ####  ######  */\n+/* ##       ##     ## ##    ##    ## ##   ##     ##  ##     ##    ##     ## ###   ###  ##  ##    ## */\n+/* ##       ##     ## ##         ##   ##  ##     ##  ##     ##    ##     ## #### ####  ##  ##       */\n+/* ##       ##     ## ##   #### ##     ## ########   ##     ##    ######### ## ### ##  ##  ##       */\n+/* ##       ##     ## ##    ##  ######### ##   ##    ##     ##    ##     ## ##     ##  ##  ##       */\n+/* ##       ##     ## ##    ##  ##     ## ##    ##   ##     ##    ##     ## ##     ##  ##  ##    ## */\n+/* ########  #######   ######   ##     ## ##     ## ####    ##    ##     ## ##     ## ####  ######  */\n+\n+static bool _log_iter_next(struct hdr_iter *iter)\n+{\n+    struct hdr_iter_log* logarithmic = &iter->specifics.log;\n+\n+    logarithmic->count_added_in_this_iteration_step = 0;\n+\n+    if (has_next(iter) ||\n+        next_value_greater_than_reporting_level_upper_bound(\n+            iter, logarithmic->next_value_reporting_level_lowest_equivalent))\n+    {\n+        do\n+        {\n+            if (iter->value >= logarithmic->next_value_reporting_level_lowest_equivalent)\n+            {\n+                _update_iterated_values(iter, logarithmic->next_value_reporting_level);\n+\n+                logarithmic->next_value_reporting_level *= (int64_t)logarithmic->log_base;\n+                logarithmic->next_value_reporting_level_lowest_equivalent = lowest_equivalent_value(iter->h, logarithmic->next_value_reporting_level);\n+\n+                return true;\n+            }\n+\n+            if (!move_next(iter))\n+            {\n+                return true;\n+            }\n+\n+            logarithmic->count_added_in_this_iteration_step += iter->count;\n+        }\n+        while (true);\n+    }\n+\n+    return false;\n+}\n+\n+void hdr_iter_log_init(\n+        struct hdr_iter* iter,\n+        const struct hdr_histogram* h,\n+        int64_t value_units_first_bucket,\n+        double log_base)\n+{\n+    hdr_iter_init(iter, h);\n+    iter->specifics.log.count_added_in_this_iteration_step = 0;\n+    iter->specifics.log.log_base = log_base;\n+    iter->specifics.log.next_value_reporting_level = value_units_first_bucket;\n+    iter->specifics.log.next_value_reporting_level_lowest_equivalent = lowest_equivalent_value(h, value_units_first_bucket);\n+\n+    iter->_next_fp = _log_iter_next;\n+}\n+\n+/* Printing. */\n+\n+static const char* format_head_string(format_type format)\n+{\n+    switch (format)\n+    {\n+        case CSV:\n+            return \"%s,%s,%s,%s\\n\";\n+        case CLASSIC:\n+            return \"%12s %12s %12s %12s\\n\\n\";\n+        default:\n+            return \"%12s %12s %12s %12s\\n\\n\";\n+    }\n+}\n+\n+static const char CLASSIC_FOOTER[] =\n+    \"#[Mean    = %12.3f, StdDeviation   = %12.3f]\\n\"\n+    \"#[Max     = %12.3f, Total count    = %12\" PRIu64 \"]\\n\"\n+    \"#[Buckets = %12d, SubBuckets     = %12d]\\n\";\n+\n+int hdr_percentiles_print(\n+        struct hdr_histogram* h, FILE* stream, int32_t ticks_per_half_distance,\n+        double value_scale, format_type format)\n+{\n+    char line_format[25];\n+    const char* head_format;\n+    int rc = 0;\n+    struct hdr_iter iter;\n+    struct hdr_iter_percentiles * percentiles;\n+\n+    format_line_string(line_format, 25, h->significant_figures, format);\n+    head_format = format_head_string(format);\n+\n+    hdr_iter_percentile_init(&iter, h, ticks_per_half_distance);\n+\n+    if (fprintf(\n+            stream, head_format,\n+            \"Value\", \"Percentile\", \"TotalCount\", \"1/(1-Percentile)\") < 0)\n+    {\n+        rc = EIO;\n+        goto cleanup;\n+    }\n+\n+    percentiles = &iter.specifics.percentiles;\n+    while (hdr_iter_next(&iter))\n+    {\n+        double  value               = iter.highest_equivalent_value / value_scale;\n+        double  percentile          = percentiles->percentile / 100.0;\n+        int64_t total_count         = iter.cumulative_count;\n+        double  inverted_percentile = (1.0 / (1.0 - percentile));\n+\n+        if (fprintf(\n+                stream, line_format, value, percentile, total_count, inverted_percentile) < 0)\n+        {\n+            rc = EIO;\n+            goto cleanup;\n+        }\n+    }\n+\n+    if (CLASSIC == format)\n+    {\n+        double mean   = hdr_mean(h)   / value_scale;\n+        double stddev = hdr_stddev(h) / value_scale;\n+        double max    = hdr_max(h)    / value_scale;\n+\n+        if (fprintf(\n+                stream, CLASSIC_FOOTER,  mean, stddev, max,\n+                h->total_count, h->bucket_count, h->sub_bucket_count) < 0)\n+        {\n+            rc = EIO;\n+            goto cleanup;\n+        }\n+    }\n+\n+    cleanup:\n+    return rc;\n+}"
        },
        {
            "sha": "4a0f4606b5717292a31e46fcf155ae640202b0d5",
            "filename": "deps/histogram/src/hdr_histogram.h",
            "status": "added",
            "additions": 434,
            "deletions": 0,
            "changes": 434,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2Fsrc%2Fhdr_histogram.h",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2Fsrc%2Fhdr_histogram.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fhistogram%2Fsrc%2Fhdr_histogram.h?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -0,0 +1,434 @@\n+/**\n+ * hdr_histogram.h\n+ * Written by Michael Barker and released to the public domain,\n+ * as explained at http://creativecommons.org/publicdomain/zero/1.0/\n+ *\n+ * The source for the hdr_histogram utilises a few C99 constructs, specifically\n+ * the use of stdint/stdbool and inline variable declaration.\n+ */\n+\n+#ifndef HDR_HISTOGRAM_H\n+#define HDR_HISTOGRAM_H 1\n+\n+#include <stdint.h>\n+#include <stdbool.h>\n+#include <stdio.h>\n+\n+struct hdr_histogram\n+{\n+    int64_t lowest_trackable_value;\n+    int64_t highest_trackable_value;\n+    int32_t unit_magnitude;\n+    int32_t significant_figures;\n+    int32_t sub_bucket_half_count_magnitude;\n+    int32_t sub_bucket_half_count;\n+    int64_t sub_bucket_mask;\n+    int32_t sub_bucket_count;\n+    int32_t bucket_count;\n+    int64_t min_value;\n+    int64_t max_value;\n+    int32_t normalizing_index_offset;\n+    double conversion_ratio;\n+    int32_t counts_len;\n+    int64_t total_count;\n+    int64_t* counts;\n+};\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/**\n+ * Allocate the memory and initialise the hdr_histogram.\n+ *\n+ * Due to the size of the histogram being the result of some reasonably\n+ * involved math on the input parameters this function it is tricky to stack allocate.\n+ * The histogram should be released with hdr_close\n+ *\n+ * @param lowest_trackable_value The smallest possible value to be put into the\n+ * histogram.\n+ * @param highest_trackable_value The largest possible value to be put into the\n+ * histogram.\n+ * @param significant_figures The level of precision for this histogram, i.e. the number\n+ * of figures in a decimal number that will be maintained.  E.g. a value of 3 will mean\n+ * the results from the histogram will be accurate up to the first three digits.  Must\n+ * be a value between 1 and 5 (inclusive).\n+ * @param result Output parameter to capture allocated histogram.\n+ * @return 0 on success, EINVAL if lowest_trackable_value is < 1 or the\n+ * significant_figure value is outside of the allowed range, ENOMEM if malloc\n+ * failed.\n+ */\n+int hdr_init(\n+    int64_t lowest_trackable_value,\n+    int64_t highest_trackable_value,\n+    int significant_figures,\n+    struct hdr_histogram** result);\n+\n+/**\n+ * Free the memory and close the hdr_histogram.\n+ *\n+ * @param h The histogram you want to close.\n+ */\n+void hdr_close(struct hdr_histogram* h);\n+\n+/**\n+ * Allocate the memory and initialise the hdr_histogram.  This is the equivalent of calling\n+ * hdr_init(1, highest_trackable_value, significant_figures, result);\n+ *\n+ * @deprecated use hdr_init.\n+ */\n+int hdr_alloc(int64_t highest_trackable_value, int significant_figures, struct hdr_histogram** result);\n+\n+\n+/**\n+ * Reset a histogram to zero - empty out a histogram and re-initialise it\n+ *\n+ * If you want to re-use an existing histogram, but reset everything back to zero, this\n+ * is the routine to use.\n+ *\n+ * @param h The histogram you want to reset to empty.\n+ *\n+ */\n+void hdr_reset(struct hdr_histogram* h);\n+\n+/**\n+ * Get the memory size of the hdr_histogram.\n+ *\n+ * @param h \"This\" pointer\n+ * @return The amount of memory used by the hdr_histogram in bytes\n+ */\n+size_t hdr_get_memory_size(struct hdr_histogram* h);\n+\n+/**\n+ * Records a value in the histogram, will round this value of to a precision at or better\n+ * than the significant_figure specified at construction time.\n+ *\n+ * @param h \"This\" pointer\n+ * @param value Value to add to the histogram\n+ * @return false if the value is larger than the highest_trackable_value and can't be recorded,\n+ * true otherwise.\n+ */\n+bool hdr_record_value(struct hdr_histogram* h, int64_t value);\n+\n+/**\n+ * Records count values in the histogram, will round this value of to a\n+ * precision at or better than the significant_figure specified at construction\n+ * time.\n+ *\n+ * @param h \"This\" pointer\n+ * @param value Value to add to the histogram\n+ * @param count Number of 'value's to add to the histogram\n+ * @return false if any value is larger than the highest_trackable_value and can't be recorded,\n+ * true otherwise.\n+ */\n+bool hdr_record_values(struct hdr_histogram* h, int64_t value, int64_t count);\n+\n+\n+/**\n+ * Record a value in the histogram and backfill based on an expected interval.\n+ *\n+ * Records a value in the histogram, will round this value of to a precision at or better\n+ * than the significant_figure specified at contruction time.  This is specifically used\n+ * for recording latency.  If the value is larger than the expected_interval then the\n+ * latency recording system has experienced co-ordinated omission.  This method fills in the\n+ * values that would have occured had the client providing the load not been blocked.\n+\n+ * @param h \"This\" pointer\n+ * @param value Value to add to the histogram\n+ * @param expected_interval The delay between recording values.\n+ * @return false if the value is larger than the highest_trackable_value and can't be recorded,\n+ * true otherwise.\n+ */\n+bool hdr_record_corrected_value(struct hdr_histogram* h, int64_t value, int64_t expexcted_interval);\n+/**\n+ * Record a value in the histogram 'count' times.  Applies the same correcting logic\n+ * as 'hdr_record_corrected_value'.\n+ *\n+ * @param h \"This\" pointer\n+ * @param value Value to add to the histogram\n+ * @param count Number of 'value's to add to the histogram\n+ * @param expected_interval The delay between recording values.\n+ * @return false if the value is larger than the highest_trackable_value and can't be recorded,\n+ * true otherwise.\n+ */\n+bool hdr_record_corrected_values(struct hdr_histogram* h, int64_t value, int64_t count, int64_t expected_interval);\n+\n+/**\n+ * Adds all of the values from 'from' to 'this' histogram.  Will return the\n+ * number of values that are dropped when copying.  Values will be dropped\n+ * if they around outside of h.lowest_trackable_value and\n+ * h.highest_trackable_value.\n+ *\n+ * @param h \"This\" pointer\n+ * @param from Histogram to copy values from.\n+ * @return The number of values dropped when copying.\n+ */\n+int64_t hdr_add(struct hdr_histogram* h, const struct hdr_histogram* from);\n+\n+/**\n+ * Adds all of the values from 'from' to 'this' histogram.  Will return the\n+ * number of values that are dropped when copying.  Values will be dropped\n+ * if they around outside of h.lowest_trackable_value and\n+ * h.highest_trackable_value.\n+ *\n+ * @param h \"This\" pointer\n+ * @param from Histogram to copy values from.\n+ * @return The number of values dropped when copying.\n+ */\n+int64_t hdr_add_while_correcting_for_coordinated_omission(\n+    struct hdr_histogram* h, struct hdr_histogram* from, int64_t expected_interval);\n+\n+/**\n+ * Get minimum value from the histogram.  Will return 2^63-1 if the histogram\n+ * is empty.\n+ *\n+ * @param h \"This\" pointer\n+ */\n+int64_t hdr_min(const struct hdr_histogram* h);\n+\n+/**\n+ * Get maximum value from the histogram.  Will return 0 if the histogram\n+ * is empty.\n+ *\n+ * @param h \"This\" pointer\n+ */\n+int64_t hdr_max(const struct hdr_histogram* h);\n+\n+/**\n+ * Get the value at a specific percentile.\n+ *\n+ * @param h \"This\" pointer.\n+ * @param percentile The percentile to get the value for\n+ */\n+int64_t hdr_value_at_percentile(const struct hdr_histogram* h, double percentile);\n+\n+/**\n+ * Gets the standard deviation for the values in the histogram.\n+ *\n+ * @param h \"This\" pointer\n+ * @return The standard deviation\n+ */\n+double hdr_stddev(const struct hdr_histogram* h);\n+\n+/**\n+ * Gets the mean for the values in the histogram.\n+ *\n+ * @param h \"This\" pointer\n+ * @return The mean\n+ */\n+double hdr_mean(const struct hdr_histogram* h);\n+\n+/**\n+ * Determine if two values are equivalent with the histogram's resolution.\n+ * Where \"equivalent\" means that value samples recorded for any two\n+ * equivalent values are counted in a common total count.\n+ *\n+ * @param h \"This\" pointer\n+ * @param a first value to compare\n+ * @param b second value to compare\n+ * @return 'true' if values are equivalent with the histogram's resolution.\n+ */\n+bool hdr_values_are_equivalent(const struct hdr_histogram* h, int64_t a, int64_t b);\n+\n+/**\n+ * Get the lowest value that is equivalent to the given value within the histogram's resolution.\n+ * Where \"equivalent\" means that value samples recorded for any two\n+ * equivalent values are counted in a common total count.\n+ *\n+ * @param h \"This\" pointer\n+ * @param value The given value\n+ * @return The lowest value that is equivalent to the given value within the histogram's resolution.\n+ */\n+int64_t hdr_lowest_equivalent_value(const struct hdr_histogram* h, int64_t value);\n+\n+/**\n+ * Get the count of recorded values at a specific value\n+ * (to within the histogram resolution at the value level).\n+ *\n+ * @param h \"This\" pointer\n+ * @param value The value for which to provide the recorded count\n+ * @return The total count of values recorded in the histogram within the value range that is\n+ * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\n+ */\n+int64_t hdr_count_at_value(const struct hdr_histogram* h, int64_t value);\n+\n+int64_t hdr_count_at_index(const struct hdr_histogram* h, int32_t index);\n+\n+int64_t hdr_value_at_index(const struct hdr_histogram* h, int32_t index);\n+\n+struct hdr_iter_percentiles\n+{\n+    bool seen_last_value;\n+    int32_t ticks_per_half_distance;\n+    double percentile_to_iterate_to;\n+    double percentile;\n+};\n+\n+struct hdr_iter_recorded\n+{\n+    int64_t count_added_in_this_iteration_step;\n+};\n+\n+struct hdr_iter_linear\n+{\n+    int64_t value_units_per_bucket;\n+    int64_t count_added_in_this_iteration_step;\n+    int64_t next_value_reporting_level;\n+    int64_t next_value_reporting_level_lowest_equivalent;\n+};\n+\n+struct hdr_iter_log\n+{\n+    double log_base;\n+    int64_t count_added_in_this_iteration_step;\n+    int64_t next_value_reporting_level;\n+    int64_t next_value_reporting_level_lowest_equivalent;\n+};\n+\n+/**\n+ * The basic iterator.  This is a generic structure\n+ * that supports all of the types of iteration.  Use\n+ * the appropriate initialiser to get the desired\n+ * iteration.\n+ *\n+ * @\n+ */\n+struct hdr_iter\n+{\n+    const struct hdr_histogram* h;\n+    /** raw index into the counts array */\n+    int32_t counts_index;\n+    /** snapshot of the length at the time the iterator is created */\n+    int32_t total_count;\n+    /** value directly from array for the current counts_index */\n+    int64_t count;\n+    /** sum of all of the counts up to and including the count at this index */\n+    int64_t cumulative_count;\n+    /** The current value based on counts_index */\n+    int64_t value;\n+    int64_t highest_equivalent_value;\n+    int64_t lowest_equivalent_value;\n+    int64_t median_equivalent_value;\n+    int64_t value_iterated_from;\n+    int64_t value_iterated_to;\n+\n+    union\n+    {\n+        struct hdr_iter_percentiles percentiles;\n+        struct hdr_iter_recorded recorded;\n+        struct hdr_iter_linear linear;\n+        struct hdr_iter_log log;\n+    } specifics;\n+\n+    bool (* _next_fp)(struct hdr_iter* iter);\n+\n+};\n+\n+/**\n+ * Initalises the basic iterator.\n+ *\n+ * @param itr 'This' pointer\n+ * @param h The histogram to iterate over\n+ */\n+void hdr_iter_init(struct hdr_iter* iter, const struct hdr_histogram* h);\n+\n+/**\n+ * Initialise the iterator for use with percentiles.\n+ */\n+void hdr_iter_percentile_init(struct hdr_iter* iter, const struct hdr_histogram* h, int32_t ticks_per_half_distance);\n+\n+/**\n+ * Initialise the iterator for use with recorded values.\n+ */\n+void hdr_iter_recorded_init(struct hdr_iter* iter, const struct hdr_histogram* h);\n+\n+/**\n+ * Initialise the iterator for use with linear values.\n+ */\n+void hdr_iter_linear_init(\n+    struct hdr_iter* iter,\n+    const struct hdr_histogram* h,\n+    int64_t value_units_per_bucket);\n+\n+/**\n+ * Initialise the iterator for use with logarithmic values\n+ */\n+void hdr_iter_log_init(\n+    struct hdr_iter* iter,\n+    const struct hdr_histogram* h,\n+    int64_t value_units_first_bucket,\n+    double log_base);\n+\n+/**\n+ * Iterate to the next value for the iterator.  If there are no more values\n+ * available return faluse.\n+ *\n+ * @param itr 'This' pointer\n+ * @return 'false' if there are no values remaining for this iterator.\n+ */\n+bool hdr_iter_next(struct hdr_iter* iter);\n+\n+typedef enum\n+{\n+    CLASSIC,\n+    CSV\n+} format_type;\n+\n+/**\n+ * Print out a percentile based histogram to the supplied stream.  Note that\n+ * this call will not flush the FILE, this is left up to the user.\n+ *\n+ * @param h 'This' pointer\n+ * @param stream The FILE to write the output to\n+ * @param ticks_per_half_distance The number of iteration steps per half-distance to 100%\n+ * @param value_scale Scale the output values by this amount\n+ * @param format_type Format to use, e.g. CSV.\n+ * @return 0 on success, error code on failure.  EIO if an error occurs writing\n+ * the output.\n+ */\n+int hdr_percentiles_print(\n+    struct hdr_histogram* h, FILE* stream, int32_t ticks_per_half_distance,\n+    double value_scale, format_type format);\n+\n+/**\n+* Internal allocation methods, used by hdr_dbl_histogram.\n+*/\n+struct hdr_histogram_bucket_config\n+{\n+    int64_t lowest_trackable_value;\n+    int64_t highest_trackable_value;\n+    int64_t unit_magnitude;\n+    int64_t significant_figures;\n+    int32_t sub_bucket_half_count_magnitude;\n+    int32_t sub_bucket_half_count;\n+    int64_t sub_bucket_mask;\n+    int32_t sub_bucket_count;\n+    int32_t bucket_count;\n+    int32_t counts_len;\n+};\n+\n+int hdr_calculate_bucket_config(\n+    int64_t lowest_trackable_value,\n+    int64_t highest_trackable_value,\n+    int significant_figures,\n+    struct hdr_histogram_bucket_config* cfg);\n+\n+void hdr_init_preallocated(struct hdr_histogram* h, struct hdr_histogram_bucket_config* cfg);\n+\n+int64_t hdr_size_of_equivalent_value_range(const struct hdr_histogram* h, int64_t value);\n+\n+int64_t hdr_next_non_equivalent_value(const struct hdr_histogram* h, int64_t value);\n+\n+int64_t hdr_median_equivalent_value(const struct hdr_histogram* h, int64_t value);\n+\n+/**\n+ * Used to reset counters after importing data manuallying into the histogram, used by the logging code\n+ * and other custom serialisation tools.\n+ */\n+void hdr_reset_internal_counters(struct hdr_histogram* h);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n\\ No newline at end of file"
        },
        {
            "sha": "c016d3a6de09aa8422c22353cf57910186435c75",
            "filename": "deps/histogram/src/hdr_tests.h",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2Fsrc%2Fhdr_tests.h",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/deps%2Fhistogram%2Fsrc%2Fhdr_tests.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fhistogram%2Fsrc%2Fhdr_tests.h?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -0,0 +1,22 @@\n+#ifndef HDR_TESTS_H\n+#define HDR_TESTS_H\n+\n+/* These are functions used in tests and are not intended for normal usage. */\n+\n+#include \"hdr_histogram.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+int32_t counts_index_for(const struct hdr_histogram* h, int64_t value);\n+int hdr_encode_compressed(struct hdr_histogram* h, uint8_t** compressed_histogram, size_t* compressed_len);\n+int hdr_decode_compressed(uint8_t* buffer, size_t length, struct hdr_histogram** histogram);\n+void hdr_base64_decode_block(const char* input, uint8_t* output);\n+void hdr_base64_encode_block(const uint8_t* input, char* output);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"
        },
        {
            "sha": "d805a0cf9de4d91dd60bde76927a777490758325",
            "filename": "doc/api/perf_hooks.md",
            "status": "modified",
            "additions": 113,
            "deletions": 0,
            "changes": 113,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/doc%2Fapi%2Fperf_hooks.md",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/doc%2Fapi%2Fperf_hooks.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fperf_hooks.md?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -398,6 +398,119 @@ Returns a list of `PerformanceEntry` objects in chronological order\n with respect to `performanceEntry.startTime` whose `performanceEntry.entryType`\n is equal to `type`.\n \n+## monitorEventLoopDelay([options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `options` {Object}\n+  * `resolution` {number} The sampling rate in milliseconds. Must be greater\n+    than zero. Defaults to `10`.\n+* Returns: {Histogram}\n+\n+Creates a `Histogram` object that samples and reports the event loop delay\n+over time.\n+\n+Using a timer to detect approximate event loop delay works because the\n+execution of timers is tied specifically to the lifecycle of the libuv\n+event loop. That is, a delay in the loop will cause a delay in the execution\n+of the timer, and those delays are specifically what this API is intended to\n+detect.\n+\n+```js\n+const { monitorEventLoopDelay } = require('perf_hooks');\n+const h = monitorEventLoopDelay({ resolution: 20 });\n+h.enable();\n+// Do something\n+h.disable();\n+console.log(h.min);\n+console.log(h.max);\n+console.log(h.mean);\n+console.log(h.stddev);\n+console.log(h.percentiles);\n+console.log(h.percentile(50));\n+console.log(h.percentile(99));\n+```\n+\n+### Class: Histogram\n+<!-- YAML\n+added: REPLACEME\n+-->\n+Tracks the event loop delay at a given sampling rate.\n+\n+#### histogram.disable()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {boolean}\n+\n+Disables the event loop delay sample timer. Returns `true` if the timer was\n+stopped, `false` if it was already stopped.\n+\n+#### histogram.enable()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {boolean}\n+\n+Enables the event loop delay sample timer. Returns `true` if the timer was\n+started, `false` if it was already started.\n+\n+#### histogram.exceeds\n+\n+* Value: {number}\n+\n+The number of times the event loop delay exceeded the maximum 1 hour event\n+loop delay threshold.\n+\n+#### histogram.max\n+\n+* Value: {number}\n+\n+The maximum recorded event loop delay.\n+\n+#### histogram.mean\n+\n+* Value: {number}\n+\n+The mean of the recorded event loop delays.\n+\n+#### histogram.min\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Value: {number}\n+\n+The minimum recorded event loop delay.\n+\n+#### histogram.percentile(percentile)\n+\n+* `percentile` {number} A percentile value between 1 and 100.\n+\n+Returns the value at the given percentile.\n+\n+#### histogram.percentiles\n+\n+* Value: {Map}\n+\n+Returns a `Map` object detailing the accumulated percentile distribution.\n+\n+#### histogram.reset()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Resets the collected histogram data.\n+\n+#### histogram.stddev\n+\n+* Value: {number}\n+\n+The standard deviation of the recorded event loop delays.\n+\n ## Examples\n \n ### Measuring the duration of async operations"
        },
        {
            "sha": "b1d634bf3c632fabf97ee269d08c3a48d26e2a08",
            "filename": "lib/perf_hooks.js",
            "status": "modified",
            "additions": 68,
            "deletions": 1,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/lib%2Fperf_hooks.js",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/lib%2Fperf_hooks.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fperf_hooks.js?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -1,6 +1,7 @@\n 'use strict';\n \n const {\n+  ELDHistogram: _ELDHistogram,\n   PerformanceEntry,\n   mark: _mark,\n   clearMark: _clearMark,\n@@ -35,6 +36,8 @@ const { AsyncResource } = require('async_hooks');\n const L = require('internal/linkedlist');\n const kInspect = require('internal/util').customInspectSymbol;\n \n+const kHandle = Symbol('handle');\n+const kMap = Symbol('map');\n const kCallback = Symbol('callback');\n const kTypes = Symbol('types');\n const kEntries = Symbol('entries');\n@@ -545,9 +548,73 @@ function sortedInsert(list, entry) {\n   list.splice(location, 0, entry);\n }\n \n+class ELDHistogram {\n+  constructor(handle) {\n+    this[kHandle] = handle;\n+    this[kMap] = new Map();\n+  }\n+\n+  reset() { this[kHandle].reset(); }\n+  enable() { return this[kHandle].enable(); }\n+  disable() { return this[kHandle].disable(); }\n+\n+  get exceeds() { return this[kHandle].exceeds(); }\n+  get min() { return this[kHandle].min(); }\n+  get max() { return this[kHandle].max(); }\n+  get mean() { return this[kHandle].mean(); }\n+  get stddev() { return this[kHandle].stddev(); }\n+  percentile(percentile) {\n+    if (typeof percentile !== 'number') {\n+      const errors = lazyErrors();\n+      throw new errors.ERR_INVALID_ARG_TYPE('percentile', 'number', percentile);\n+    }\n+    if (percentile <= 0 || percentile > 100) {\n+      const errors = lazyErrors();\n+      throw new errors.ERR_INVALID_ARG_VALUE.RangeError('percentile',\n+                                                        percentile);\n+    }\n+    return this[kHandle].percentile(percentile);\n+  }\n+  get percentiles() {\n+    this[kMap].clear();\n+    this[kHandle].percentiles(this[kMap]);\n+    return this[kMap];\n+  }\n+\n+  [kInspect]() {\n+    return {\n+      min: this.min,\n+      max: this.max,\n+      mean: this.mean,\n+      stddev: this.stddev,\n+      percentiles: this.percentiles,\n+      exceeds: this.exceeds\n+    };\n+  }\n+}\n+\n+function monitorEventLoopDelay(options = {}) {\n+  if (typeof options !== 'object' || options === null) {\n+    const errors = lazyErrors();\n+    throw new errors.ERR_INVALID_ARG_TYPE('options', 'Object', options);\n+  }\n+  const { resolution = 10 } = options;\n+  if (typeof resolution !== 'number') {\n+    const errors = lazyErrors();\n+    throw new errors.ERR_INVALID_ARG_TYPE('options.resolution',\n+                                          'number', resolution);\n+  }\n+  if (resolution <= 0 || !Number.isSafeInteger(resolution)) {\n+    const errors = lazyErrors();\n+    throw new errors.ERR_INVALID_OPT_VALUE.RangeError('resolution', resolution);\n+  }\n+  return new ELDHistogram(new _ELDHistogram(resolution));\n+}\n+\n module.exports = {\n   performance,\n-  PerformanceObserver\n+  PerformanceObserver,\n+  monitorEventLoopDelay\n };\n \n Object.defineProperty(module.exports, 'constants', {"
        },
        {
            "sha": "1cbc8822ccf52235094df8c47d092c849aab48a6",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -261,8 +261,9 @@\n       ],\n       'include_dirs': [\n         'src',\n-        'deps/v8/include',\n+        'deps/v8/include'\n       ],\n+      'dependencies': [ 'deps/histogram/histogram.gyp:histogram' ],\n \n       # - \"C4244: conversion from 'type1' to 'type2', possible loss of data\"\n       #   Ususaly safe. Disable for `dep`, enable for `src`\n@@ -360,6 +361,7 @@\n         'src',\n         '<(SHARED_INTERMEDIATE_DIR)' # for node_natives.h\n       ],\n+      'dependencies': [ 'deps/histogram/histogram.gyp:histogram' ],\n \n       'sources': [\n         'src/api/callback.cc',\n@@ -458,6 +460,8 @@\n         'src/env.h',\n         'src/env-inl.h',\n         'src/handle_wrap.h',\n+        'src/histogram.h',\n+        'src/histogram-inl.h',\n         'src/http_parser_adaptor.h',\n         'src/js_stream.h',\n         'src/memory_tracker.h',\n@@ -966,6 +970,7 @@\n         '<(node_lib_target_name)',\n         'rename_node_bin_win',\n         'deps/gtest/gtest.gyp:gtest',\n+        'deps/histogram/histogram.gyp:histogram',\n         'node_dtrace_header',\n         'node_dtrace_ustack',\n         'node_dtrace_provider',"
        },
        {
            "sha": "7d6ff06128ac63cb4332dcd229103c8c17715405",
            "filename": "node.gypi",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/node.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/node.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gypi?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -233,6 +233,7 @@\n     [ 'OS==\"aix\"', {\n       'defines': [\n         '_LINUX_SOURCE_COMPAT',\n+        '__STDC_FORMAT_MACROS'\n       ],\n       'conditions': [\n         [ 'force_load==\"true\"', {"
        },
        {
            "sha": "3135041f7387a96e95e72245ee3009438305458a",
            "filename": "src/histogram-inl.h",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/src%2Fhistogram-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/src%2Fhistogram-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fhistogram-inl.h?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -0,0 +1,63 @@\n+#ifndef SRC_HISTOGRAM_INL_H_\n+#define SRC_HISTOGRAM_INL_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"histogram.h\"\n+#include \"node_internals.h\"\n+\n+namespace node {\n+\n+inline Histogram::Histogram(int64_t lowest, int64_t highest, int figures) {\n+  CHECK_EQ(0, hdr_init(lowest, highest, figures, &histogram_));\n+}\n+\n+inline Histogram::~Histogram() {\n+  hdr_close(histogram_);\n+}\n+\n+inline void Histogram::Reset() {\n+  hdr_reset(histogram_);\n+}\n+\n+inline bool Histogram::Record(int64_t value) {\n+  return hdr_record_value(histogram_, value);\n+}\n+\n+inline int64_t Histogram::Min() {\n+  return hdr_min(histogram_);\n+}\n+\n+inline int64_t Histogram::Max() {\n+  return hdr_max(histogram_);\n+}\n+\n+inline double Histogram::Mean() {\n+  return hdr_mean(histogram_);\n+}\n+\n+inline double Histogram::Stddev() {\n+  return hdr_stddev(histogram_);\n+}\n+\n+inline double Histogram::Percentile(double percentile) {\n+  CHECK_GT(percentile, 0);\n+  CHECK_LE(percentile, 100);\n+  return hdr_value_at_percentile(histogram_, percentile);\n+}\n+\n+inline void Histogram::Percentiles(std::function<void(double, double)> fn) {\n+  hdr_iter iter;\n+  hdr_iter_percentile_init(&iter, histogram_, 1);\n+  while (hdr_iter_next(&iter)) {\n+    double key = iter.specifics.percentiles.percentile;\n+    double value = iter.value;\n+    fn(key, value);\n+  }\n+}\n+\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#endif  // SRC_HISTOGRAM_INL_H_"
        },
        {
            "sha": "eb94af5da2a997c3d78f0783947d68f66a865f13",
            "filename": "src/histogram.h",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/src%2Fhistogram.h",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/src%2Fhistogram.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fhistogram.h?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -0,0 +1,38 @@\n+#ifndef SRC_HISTOGRAM_H_\n+#define SRC_HISTOGRAM_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"hdr_histogram.h\"\n+#include <functional>\n+#include <map>\n+\n+namespace node {\n+\n+class Histogram {\n+ public:\n+  inline Histogram(int64_t lowest, int64_t highest, int figures = 3);\n+  inline virtual ~Histogram();\n+\n+  inline bool Record(int64_t value);\n+  inline void Reset();\n+  inline int64_t Min();\n+  inline int64_t Max();\n+  inline double Mean();\n+  inline double Stddev();\n+  inline double Percentile(double percentile);\n+  inline void Percentiles(std::function<void(double, double)> fn);\n+\n+  size_t GetMemorySize() const {\n+    return hdr_get_memory_size(histogram_);\n+  }\n+\n+ private:\n+  hdr_histogram* histogram_;\n+};\n+\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#endif  // SRC_HISTOGRAM_H_"
        },
        {
            "sha": "b9c0183a83d930ff2fbb2055f4061df77f9a8804",
            "filename": "src/node_perf.cc",
            "status": "modified",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/src%2Fnode_perf.cc",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/src%2Fnode_perf.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_perf.cc?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -1,5 +1,10 @@\n+#include \"aliased_buffer.h\"\n #include \"node_internals.h\"\n #include \"node_perf.h\"\n+#include \"node_buffer.h\"\n+#include \"node_process.h\"\n+\n+#include <cinttypes>\n \n #ifdef __POSIX__\n #include <sys/time.h>  // gettimeofday\n@@ -20,6 +25,7 @@ using v8::HandleScope;\n using v8::Integer;\n using v8::Isolate;\n using v8::Local;\n+using v8::Map;\n using v8::MaybeLocal;\n using v8::Name;\n using v8::NewStringType;\n@@ -387,6 +393,168 @@ void Timerify(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(wrap);\n }\n \n+// Event Loop Timing Histogram\n+namespace {\n+static void ELDHistogramMin(const FunctionCallbackInfo<Value>& args) {\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  double value = static_cast<double>(histogram->Min());\n+  args.GetReturnValue().Set(value);\n+}\n+\n+static void ELDHistogramMax(const FunctionCallbackInfo<Value>& args) {\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  double value = static_cast<double>(histogram->Max());\n+  args.GetReturnValue().Set(value);\n+}\n+\n+static void ELDHistogramMean(const FunctionCallbackInfo<Value>& args) {\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  args.GetReturnValue().Set(histogram->Mean());\n+}\n+\n+static void ELDHistogramExceeds(const FunctionCallbackInfo<Value>& args) {\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  double value = static_cast<double>(histogram->Exceeds());\n+  args.GetReturnValue().Set(value);\n+}\n+\n+static void ELDHistogramStddev(const FunctionCallbackInfo<Value>& args) {\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  args.GetReturnValue().Set(histogram->Stddev());\n+}\n+\n+static void ELDHistogramPercentile(const FunctionCallbackInfo<Value>& args) {\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  CHECK(args[0]->IsNumber());\n+  double percentile = args[0].As<Number>()->Value();\n+  args.GetReturnValue().Set(histogram->Percentile(percentile));\n+}\n+\n+static void ELDHistogramPercentiles(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  CHECK(args[0]->IsMap());\n+  Local<Map> map = args[0].As<Map>();\n+  histogram->Percentiles([&](double key, double value) {\n+    map->Set(env->context(),\n+             Number::New(env->isolate(), key),\n+             Number::New(env->isolate(), value)).IsEmpty();\n+  });\n+}\n+\n+static void ELDHistogramEnable(const FunctionCallbackInfo<Value>& args) {\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  args.GetReturnValue().Set(histogram->Enable());\n+}\n+\n+static void ELDHistogramDisable(const FunctionCallbackInfo<Value>& args) {\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  args.GetReturnValue().Set(histogram->Disable());\n+}\n+\n+static void ELDHistogramReset(const FunctionCallbackInfo<Value>& args) {\n+  ELDHistogram* histogram;\n+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());\n+  histogram->ResetState();\n+}\n+\n+static void ELDHistogramNew(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  CHECK(args.IsConstructCall());\n+  int32_t resolution = args[0]->IntegerValue(env->context()).FromJust();\n+  CHECK_GT(resolution, 0);\n+  new ELDHistogram(env, args.This(), resolution);\n+}\n+}  // namespace\n+\n+ELDHistogram::ELDHistogram(\n+    Environment* env,\n+    Local<Object> wrap,\n+    int32_t resolution) : BaseObject(env, wrap),\n+                          Histogram(1, 3.6e12),\n+                          resolution_(resolution) {\n+  MakeWeak();\n+  timer_ = new uv_timer_t();\n+  uv_timer_init(env->event_loop(), timer_);\n+  timer_->data = this;\n+}\n+\n+void ELDHistogram::CloseTimer() {\n+  if (timer_ == nullptr)\n+    return;\n+\n+  env()->CloseHandle(timer_, [](uv_timer_t* handle) { delete handle; });\n+  timer_ = nullptr;\n+}\n+\n+ELDHistogram::~ELDHistogram() {\n+  Disable();\n+  CloseTimer();\n+}\n+\n+void ELDHistogramDelayInterval(uv_timer_t* req) {\n+  ELDHistogram* histogram =\n+    reinterpret_cast<ELDHistogram*>(req->data);\n+  histogram->RecordDelta();\n+  TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),\n+                 \"min\", histogram->Min());\n+  TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),\n+                 \"max\", histogram->Max());\n+  TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),\n+                 \"mean\", histogram->Mean());\n+  TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),\n+                 \"stddev\", histogram->Stddev());\n+}\n+\n+bool ELDHistogram::RecordDelta() {\n+  uint64_t time = uv_hrtime();\n+  bool ret = true;\n+  if (prev_ > 0) {\n+    int64_t delta = time - prev_;\n+    if (delta > 0) {\n+      ret = Record(delta);\n+      TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),\n+                     \"delay\", delta);\n+      if (!ret) {\n+        if (exceeds_ < 0xFFFFFFFF)\n+          exceeds_++;\n+        ProcessEmitWarning(\n+            env(),\n+            \"Event loop delay exceeded 1 hour: %\" PRId64 \" nanoseconds\",\n+            delta);\n+      }\n+    }\n+  }\n+  prev_ = time;\n+  return ret;\n+}\n+\n+bool ELDHistogram::Enable() {\n+  if (enabled_) return false;\n+  enabled_ = true;\n+  uv_timer_start(timer_,\n+                 ELDHistogramDelayInterval,\n+                 resolution_,\n+                 resolution_);\n+  uv_unref(reinterpret_cast<uv_handle_t*>(timer_));\n+  return true;\n+}\n+\n+bool ELDHistogram::Disable() {\n+  if (!enabled_) return false;\n+  enabled_ = false;\n+  uv_timer_stop(timer_);\n+  return true;\n+}\n \n void Initialize(Local<Object> target,\n                 Local<Value> unused,\n@@ -456,6 +624,24 @@ void Initialize(Local<Object> target,\n                             env->constants_string(),\n                             constants,\n                             attr).ToChecked();\n+\n+  Local<String> eldh_classname = FIXED_ONE_BYTE_STRING(isolate, \"ELDHistogram\");\n+  Local<FunctionTemplate> eldh =\n+      env->NewFunctionTemplate(ELDHistogramNew);\n+  eldh->SetClassName(eldh_classname);\n+  eldh->InstanceTemplate()->SetInternalFieldCount(1);\n+  env->SetProtoMethod(eldh, \"exceeds\", ELDHistogramExceeds);\n+  env->SetProtoMethod(eldh, \"min\", ELDHistogramMin);\n+  env->SetProtoMethod(eldh, \"max\", ELDHistogramMax);\n+  env->SetProtoMethod(eldh, \"mean\", ELDHistogramMean);\n+  env->SetProtoMethod(eldh, \"stddev\", ELDHistogramStddev);\n+  env->SetProtoMethod(eldh, \"percentile\", ELDHistogramPercentile);\n+  env->SetProtoMethod(eldh, \"percentiles\", ELDHistogramPercentiles);\n+  env->SetProtoMethod(eldh, \"enable\", ELDHistogramEnable);\n+  env->SetProtoMethod(eldh, \"disable\", ELDHistogramDisable);\n+  env->SetProtoMethod(eldh, \"reset\", ELDHistogramReset);\n+  target->Set(context, eldh_classname,\n+              eldh->GetFunction(env->context()).ToLocalChecked()).FromJust();\n }\n \n }  // namespace performance"
        },
        {
            "sha": "a8e43dc3476cc2f5368b2f84cb77db74ad46da8e",
            "filename": "src/node_perf.h",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/src%2Fnode_perf.h",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/src%2Fnode_perf.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_perf.h?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -7,6 +7,7 @@\n #include \"node_perf_common.h\"\n #include \"env.h\"\n #include \"base_object-inl.h\"\n+#include \"histogram-inl.h\"\n \n #include \"v8.h\"\n #include \"uv.h\"\n@@ -124,6 +125,41 @@ class GCPerformanceEntry : public PerformanceEntry {\n   PerformanceGCKind gckind_;\n };\n \n+class ELDHistogram : public BaseObject, public Histogram {\n+ public:\n+  ELDHistogram(Environment* env,\n+               Local<Object> wrap,\n+               int32_t resolution);\n+\n+  ~ELDHistogram() override;\n+\n+  bool RecordDelta();\n+  bool Enable();\n+  bool Disable();\n+  void ResetState() {\n+    Reset();\n+    exceeds_ = 0;\n+    prev_ = 0;\n+  }\n+  int64_t Exceeds() { return exceeds_; }\n+\n+  void MemoryInfo(MemoryTracker* tracker) const override {\n+    tracker->TrackFieldWithSize(\"histogram\", GetMemorySize());\n+  }\n+\n+  SET_MEMORY_INFO_NAME(ELDHistogram)\n+  SET_SELF_SIZE(ELDHistogram)\n+\n+ private:\n+  void CloseTimer();\n+\n+  bool enabled_ = false;\n+  int32_t resolution_ = 0;\n+  int64_t exceeds_ = 0;\n+  uint64_t prev_ = 0;\n+  uv_timer_t* timer_;\n+};\n+\n }  // namespace performance\n }  // namespace node\n "
        },
        {
            "sha": "82f47b6fb29c47a0ffbf9f9c8dd0a7f4883fc66a",
            "filename": "test/sequential/test-performance-eventloopdelay.js",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/test%2Fsequential%2Ftest-performance-eventloopdelay.js",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/test%2Fsequential%2Ftest-performance-eventloopdelay.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-performance-eventloopdelay.js?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -0,0 +1,99 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const {\n+  monitorEventLoopDelay\n+} = require('perf_hooks');\n+\n+{\n+  const histogram = monitorEventLoopDelay();\n+  assert(histogram);\n+  assert(histogram.enable());\n+  assert(!histogram.enable());\n+  histogram.reset();\n+  assert(histogram.disable());\n+  assert(!histogram.disable());\n+}\n+\n+{\n+  [null, 'a', 1, false, Infinity].forEach((i) => {\n+    common.expectsError(\n+      () => monitorEventLoopDelay(i),\n+      {\n+        type: TypeError,\n+        code: 'ERR_INVALID_ARG_TYPE'\n+      }\n+    );\n+  });\n+\n+  [null, 'a', false, {}, []].forEach((i) => {\n+    common.expectsError(\n+      () => monitorEventLoopDelay({ resolution: i }),\n+      {\n+        type: TypeError,\n+        code: 'ERR_INVALID_ARG_TYPE'\n+      }\n+    );\n+  });\n+\n+  [-1, 0, Infinity].forEach((i) => {\n+    common.expectsError(\n+      () => monitorEventLoopDelay({ resolution: i }),\n+      {\n+        type: RangeError,\n+        code: 'ERR_INVALID_OPT_VALUE'\n+      }\n+    );\n+  });\n+}\n+\n+{\n+  const histogram = monitorEventLoopDelay({ resolution: 1 });\n+  histogram.enable();\n+  let m = 5;\n+  function spinAWhile() {\n+    common.busyLoop(1000);\n+    if (--m > 0) {\n+      setTimeout(spinAWhile, common.platformTimeout(500));\n+    } else {\n+      histogram.disable();\n+      // The values are non-deterministic, so we just check that a value is\n+      // present, as opposed to a specific value.\n+      assert(histogram.min > 0);\n+      assert(histogram.max > 0);\n+      assert(histogram.stddev > 0);\n+      assert(histogram.mean > 0);\n+      assert(histogram.percentiles.size > 0);\n+      for (let n = 1; n < 100; n = n + 0.1) {\n+        assert(histogram.percentile(n) >= 0);\n+      }\n+      histogram.reset();\n+      assert.strictEqual(histogram.min, 9223372036854776000);\n+      assert.strictEqual(histogram.max, 0);\n+      assert(Number.isNaN(histogram.stddev));\n+      assert(Number.isNaN(histogram.mean));\n+      assert.strictEqual(histogram.percentiles.size, 1);\n+\n+      ['a', false, {}, []].forEach((i) => {\n+        common.expectsError(\n+          () => histogram.percentile(i),\n+          {\n+            type: TypeError,\n+            code: 'ERR_INVALID_ARG_TYPE'\n+          }\n+        );\n+      });\n+      [-1, 0, 101].forEach((i) => {\n+        common.expectsError(\n+          () => histogram.percentile(i),\n+          {\n+            type: RangeError,\n+            code: 'ERR_INVALID_ARG_VALUE'\n+          }\n+        );\n+      });\n+    }\n+  }\n+  spinAWhile();\n+}"
        },
        {
            "sha": "ffbec9115c272ef21a6a5db2547a3f6d84970ced",
            "filename": "tools/doc/type-parser.js",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/tools%2Fdoc%2Ftype-parser.js",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/tools%2Fdoc%2Ftype-parser.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Ftype-parser.js?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -16,7 +16,7 @@ const jsPrimitives = {\n const jsGlobalObjectsUrl = `${jsDocPrefix}Reference/Global_Objects/`;\n const jsGlobalTypes = [\n   'Array', 'ArrayBuffer', 'DataView', 'Date', 'Error', 'EvalError', 'Function',\n-  'Object', 'Promise', 'RangeError', 'ReferenceError', 'RegExp', 'Set',\n+  'Map', 'Object', 'Promise', 'RangeError', 'ReferenceError', 'RegExp', 'Set',\n   'SharedArrayBuffer', 'SyntaxError', 'TypeError', 'TypedArray', 'URIError',\n   'Uint8Array',\n ];\n@@ -75,6 +75,8 @@ const customTypesMap = {\n   'fs.Stats': 'fs.html#fs_class_fs_stats',\n   'fs.WriteStream': 'fs.html#fs_class_fs_writestream',\n \n+  'Histogram': 'perf_hooks.html#perf_hooks_class_histogram',\n+\n   'http.Agent': 'http.html#http_class_http_agent',\n   'http.ClientRequest': 'http.html#http_class_http_clientrequest',\n   'http.IncomingMessage': 'http.html#http_class_http_incomingmessage',"
        },
        {
            "sha": "be808f00d1be49a676f6f8f65d80dba1494969f7",
            "filename": "tools/license-builder.sh",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/bcdd228f90b3e9e428b584814e7d52627616456a/tools%2Flicense-builder.sh",
            "raw_url": "https://github.com/nodejs/node/raw/bcdd228f90b3e9e428b584814e7d52627616456a/tools%2Flicense-builder.sh",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Flicense-builder.sh?ref=bcdd228f90b3e9e428b584814e7d52627616456a",
            "patch": "@@ -95,4 +95,6 @@ addlicense \"large_pages\" \"src/large_pages\" \"$(sed -e '/SPDX-License-Identifier/,\n # brotli\n addlicense \"brotli\" \"deps/brotli\" \"$(cat ${rootdir}/deps/brotli/LICENSE)\"\n \n+addlicense \"HdrHistogram\" \"deps/histogram\" \"$(cat ${rootdir}/deps/histogram/LICENSE.txt)\"\n+\n mv $tmplicense $licensefile"
        }
    ],
    "stats": {
        "total": 2210,
        "additions": 2207,
        "deletions": 3
    }
}