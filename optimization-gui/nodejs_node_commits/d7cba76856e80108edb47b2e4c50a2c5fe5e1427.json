{
    "author": "addaleax",
    "message": "src: more automatic memory management in node_crypto.cc\n\nPrefer custom smart pointers fitted to the OpenSSL data structures\nover more manual memory management and lots of `goto`s.\n\nPR-URL: https://github.com/nodejs/node/pull/20238\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "d7cba76856e80108edb47b2e4c50a2c5fe5e1427",
    "files": [
        {
            "sha": "ce9c41deaebcd2ddcc78c6dd3f5ba51dc23c78bb",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 614,
            "deletions": 808,
            "changes": 1422,
            "blob_url": "https://github.com/nodejs/node/blob/d7cba76856e80108edb47b2e4c50a2c5fe5e1427/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d7cba76856e80108edb47b2e4c50a2c5fe5e1427/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=d7cba76856e80108edb47b2e4c50a2c5fe5e1427",
            "patch": "@@ -92,9 +92,21 @@ using v8::Value;\n struct StackOfX509Deleter {\n   void operator()(STACK_OF(X509)* p) const { sk_X509_pop_free(p, X509_free); }\n };\n-\n using StackOfX509 = std::unique_ptr<STACK_OF(X509), StackOfX509Deleter>;\n \n+struct StackOfXASN1Deleter {\n+  void operator()(STACK_OF(ASN1_OBJECT)* p) const {\n+    sk_ASN1_OBJECT_pop_free(p, ASN1_OBJECT_free);\n+  }\n+};\n+using StackOfASN1 = std::unique_ptr<STACK_OF(ASN1_OBJECT), StackOfXASN1Deleter>;\n+\n+// OPENSSL_free is a macro, so we need a wrapper function.\n+struct OpenSSLBufferDeleter {\n+  void operator()(char* pointer) const { OPENSSL_free(pointer); }\n+};\n+using OpenSSLBuffer = std::unique_ptr<char[], OpenSSLBufferDeleter>;\n+\n static const char* const root_certs[] = {\n #include \"node_root_certs.h\"  // NOLINT(build/include_order)\n };\n@@ -426,24 +438,24 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {\n     }\n   }\n \n-  sc->ctx_ = SSL_CTX_new(method);\n-  SSL_CTX_set_app_data(sc->ctx_, sc);\n+  sc->ctx_.reset(SSL_CTX_new(method));\n+  SSL_CTX_set_app_data(sc->ctx_.get(), sc);\n \n   // Disable SSLv2 in the case when method == TLS_method() and the\n   // cipher list contains SSLv2 ciphers (not the default, should be rare.)\n   // The bundled OpenSSL doesn't have SSLv2 support but the system OpenSSL may.\n   // SSLv3 is disabled because it's susceptible to downgrade attacks (POODLE.)\n-  SSL_CTX_set_options(sc->ctx_, SSL_OP_NO_SSLv2);\n-  SSL_CTX_set_options(sc->ctx_, SSL_OP_NO_SSLv3);\n+  SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv2);\n+  SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_NO_SSLv3);\n \n   // SSL session cache configuration\n-  SSL_CTX_set_session_cache_mode(sc->ctx_,\n+  SSL_CTX_set_session_cache_mode(sc->ctx_.get(),\n                                  SSL_SESS_CACHE_SERVER |\n                                  SSL_SESS_CACHE_NO_INTERNAL |\n                                  SSL_SESS_CACHE_NO_AUTO_CLEAR);\n \n-  SSL_CTX_set_min_proto_version(sc->ctx_, min_version);\n-  SSL_CTX_set_max_proto_version(sc->ctx_, max_version);\n+  SSL_CTX_set_min_proto_version(sc->ctx_.get(), min_version);\n+  SSL_CTX_set_max_proto_version(sc->ctx_.get(), max_version);\n   // OpenSSL 1.1.0 changed the ticket key size, but the OpenSSL 1.0.x size was\n   // exposed in the public API. To retain compatibility, install a callback\n   // which restores the old algorithm.\n@@ -452,7 +464,7 @@ void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {\n       RAND_bytes(sc->ticket_key_aes_, sizeof(sc->ticket_key_aes_)) <= 0) {\n     return env->ThrowError(\"Error generating ticket keys\");\n   }\n-  SSL_CTX_set_tlsext_ticket_key_cb(sc->ctx_,\n+  SSL_CTX_set_tlsext_ticket_key_cb(sc->ctx_.get(),\n                                    SecureContext::TicketCompatibilityCallback);\n }\n \n@@ -497,29 +509,27 @@ void SecureContext::SetKey(const FunctionCallbackInfo<Value>& args) {\n       THROW_AND_RETURN_IF_NOT_STRING(env, args[1], \"Pass phrase\");\n   }\n \n-  BIO *bio = LoadBIO(env, args[0]);\n+  BIOPointer bio(LoadBIO(env, args[0]));\n   if (!bio)\n     return;\n \n   node::Utf8Value passphrase(env->isolate(), args[1]);\n \n-  EVP_PKEY* key = PEM_read_bio_PrivateKey(bio,\n-                                          nullptr,\n-                                          PasswordCallback,\n-                                          len == 1 ? nullptr : *passphrase);\n+  EVPKeyPointer key(\n+      PEM_read_bio_PrivateKey(bio.get(),\n+                              nullptr,\n+                              PasswordCallback,\n+                              len == 1 ? nullptr : *passphrase));\n \n   if (!key) {\n-    BIO_free_all(bio);\n     unsigned long err = ERR_get_error();  // NOLINT(runtime/int)\n     if (!err) {\n       return env->ThrowError(\"PEM_read_bio_PrivateKey\");\n     }\n     return ThrowCryptoError(env, err);\n   }\n \n-  int rv = SSL_CTX_use_PrivateKey(sc->ctx_, key);\n-  EVP_PKEY_free(key);\n-  BIO_free_all(bio);\n+  int rv = SSL_CTX_use_PrivateKey(sc->ctx_.get(), key.get());\n \n   if (!rv) {\n     unsigned long err = ERR_get_error();  // NOLINT(runtime/int)\n@@ -532,24 +542,24 @@ void SecureContext::SetKey(const FunctionCallbackInfo<Value>& args) {\n \n int SSL_CTX_get_issuer(SSL_CTX* ctx, X509* cert, X509** issuer) {\n   X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n-  X509_STORE_CTX* store_ctx = X509_STORE_CTX_new();\n-  int ret = store_ctx != nullptr &&\n-            X509_STORE_CTX_init(store_ctx, store, nullptr, nullptr) == 1 &&\n-            X509_STORE_CTX_get1_issuer(issuer, store_ctx, cert) == 1;\n-  X509_STORE_CTX_free(store_ctx);\n-  return ret;\n+  DeleteFnPtr<X509_STORE_CTX, X509_STORE_CTX_free> store_ctx(\n+      X509_STORE_CTX_new());\n+  return store_ctx.get() != nullptr &&\n+         X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&\n+         X509_STORE_CTX_get1_issuer(issuer, store_ctx.get(), cert) == 1;\n }\n \n \n int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,\n-                                  X509* x,\n+                                  X509Pointer&& x,\n                                   STACK_OF(X509)* extra_certs,\n-                                  X509** cert,\n-                                  X509** issuer) {\n-  CHECK_EQ(*issuer, nullptr);\n-  CHECK_EQ(*cert, nullptr);\n+                                  X509Pointer* cert,\n+                                  X509Pointer* issuer_) {\n+  CHECK(!*issuer_);\n+  CHECK(!*cert);\n+  X509* issuer = nullptr;\n \n-  int ret = SSL_CTX_use_certificate(ctx, x);\n+  int ret = SSL_CTX_use_certificate(ctx, x.get());\n \n   if (ret) {\n     // If we could set up our certificate, now proceed to\n@@ -566,7 +576,7 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,\n \n       if (!r) {\n         ret = 0;\n-        *issuer = nullptr;\n+        issuer = nullptr;\n         goto end;\n       }\n       // Note that we must not free r if it was successfully\n@@ -575,34 +585,36 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,\n       // by SSL_CTX_use_certificate).\n \n       // Find issuer\n-      if (*issuer != nullptr || X509_check_issued(ca, x) != X509_V_OK)\n+      if (issuer != nullptr || X509_check_issued(ca, x.get()) != X509_V_OK)\n         continue;\n \n-      *issuer = ca;\n+      issuer = ca;\n     }\n   }\n \n   // Try getting issuer from a cert store\n   if (ret) {\n-    if (*issuer == nullptr) {\n-      ret = SSL_CTX_get_issuer(ctx, x, issuer);\n+    if (issuer == nullptr) {\n+      ret = SSL_CTX_get_issuer(ctx, x.get(), &issuer);\n       ret = ret < 0 ? 0 : 1;\n       // NOTE: get_cert_store doesn't increment reference count,\n       // no need to free `store`\n     } else {\n       // Increment issuer reference count\n-      *issuer = X509_dup(*issuer);\n-      if (*issuer == nullptr) {\n+      issuer = X509_dup(issuer);\n+      if (issuer == nullptr) {\n         ret = 0;\n         goto end;\n       }\n     }\n   }\n \n  end:\n+  issuer_->reset(issuer);\n+\n   if (ret && x != nullptr) {\n-    *cert = X509_dup(x);\n-    if (*cert == nullptr)\n+    cert->reset(X509_dup(x.get()));\n+    if (!*cert)\n       ret = 0;\n   }\n   return ret;\n@@ -615,21 +627,20 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,\n //\n // Taken from OpenSSL - edited for style.\n int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,\n-                                  BIO* in,\n-                                  X509** cert,\n-                                  X509** issuer) {\n-  X509* x = nullptr;\n-\n+                                  BIOPointer&& in,\n+                                  X509Pointer* cert,\n+                                  X509Pointer* issuer) {\n   // Just to ensure that `ERR_peek_last_error` below will return only errors\n   // that we are interested in\n   ERR_clear_error();\n \n-  x = PEM_read_bio_X509_AUX(in, nullptr, NoPasswordCallback, nullptr);\n+  X509Pointer x(\n+      PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));\n \n-  if (x == nullptr) {\n+  if (!x)\n     return 0;\n-  }\n \n+  // TODO(addaleax): Turn this into smart pointer as well.\n   X509* extra = nullptr;\n   int ret = 0;\n   unsigned long err = 0;  // NOLINT(runtime/int)\n@@ -638,7 +649,7 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,\n   if (!extra_certs)\n     goto done;\n \n-  while ((extra = PEM_read_bio_X509(in,\n+  while ((extra = PEM_read_bio_X509(in.get(),\n                                     nullptr,\n                                     NoPasswordCallback,\n                                     nullptr))) {\n@@ -660,15 +671,17 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,\n     goto done;\n   }\n \n-  ret = SSL_CTX_use_certificate_chain(ctx, x, extra_certs.get(), cert, issuer);\n+  ret = SSL_CTX_use_certificate_chain(ctx,\n+                                      std::move(x),\n+                                      extra_certs.get(),\n+                                      cert,\n+                                      issuer);\n   if (!ret)\n     goto done;\n \n  done:\n   if (extra != nullptr)\n     X509_free(extra);\n-  if (x != nullptr)\n-    X509_free(x);\n \n   return ret;\n }\n@@ -684,27 +697,18 @@ void SecureContext::SetCert(const FunctionCallbackInfo<Value>& args) {\n     return THROW_ERR_MISSING_ARGS(env, \"Certificate argument is mandatory\");\n   }\n \n-  BIO* bio = LoadBIO(env, args[0]);\n+  BIOPointer bio(LoadBIO(env, args[0]));\n   if (!bio)\n     return;\n \n-  // Free previous certs\n-  if (sc->issuer_ != nullptr) {\n-    X509_free(sc->issuer_);\n-    sc->issuer_ = nullptr;\n-  }\n-  if (sc->cert_ != nullptr) {\n-    X509_free(sc->cert_);\n-    sc->cert_ = nullptr;\n-  }\n+  sc->cert_.reset();\n+  sc->issuer_.reset();\n \n-  int rv = SSL_CTX_use_certificate_chain(sc->ctx_,\n-                                         bio,\n+  int rv = SSL_CTX_use_certificate_chain(sc->ctx_.get(),\n+                                         std::move(bio),\n                                          &sc->cert_,\n                                          &sc->issuer_);\n \n-  BIO_free_all(bio);\n-\n   if (!rv) {\n     unsigned long err = ERR_get_error();  // NOLINT(runtime/int)\n     if (!err) {\n@@ -758,24 +762,21 @@ void SecureContext::AddCACert(const FunctionCallbackInfo<Value>& args) {\n     return THROW_ERR_MISSING_ARGS(env, \"CA certificate argument is mandatory\");\n   }\n \n-  BIO* bio = LoadBIO(env, args[0]);\n-  if (!bio) {\n+  BIOPointer bio(LoadBIO(env, args[0]));\n+  if (!bio)\n     return;\n-  }\n \n-  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_);\n-  while (X509* x509 =\n-             PEM_read_bio_X509(bio, nullptr, NoPasswordCallback, nullptr)) {\n+  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());\n+  while (X509* x509 = PEM_read_bio_X509(\n+      bio.get(), nullptr, NoPasswordCallback, nullptr)) {\n     if (cert_store == root_cert_store) {\n       cert_store = NewRootCertStore();\n-      SSL_CTX_set_cert_store(sc->ctx_, cert_store);\n+      SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);\n     }\n     X509_STORE_add_cert(cert_store, x509);\n-    SSL_CTX_add_client_CA(sc->ctx_, x509);\n+    SSL_CTX_add_client_CA(sc->ctx_.get(), x509);\n     X509_free(x509);\n   }\n-\n-  BIO_free_all(bio);\n }\n \n \n@@ -791,30 +792,25 @@ void SecureContext::AddCRL(const FunctionCallbackInfo<Value>& args) {\n \n   ClearErrorOnReturn clear_error_on_return;\n \n-  BIO *bio = LoadBIO(env, args[0]);\n+  BIOPointer bio(LoadBIO(env, args[0]));\n   if (!bio)\n     return;\n \n-  X509_CRL* crl =\n-      PEM_read_bio_X509_CRL(bio, nullptr, NoPasswordCallback, nullptr);\n+  DeleteFnPtr<X509_CRL, X509_CRL_free> crl(\n+      PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));\n \n-  if (crl == nullptr) {\n-    BIO_free_all(bio);\n+  if (!crl)\n     return env->ThrowError(\"Failed to parse CRL\");\n-  }\n \n-  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_);\n+  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());\n   if (cert_store == root_cert_store) {\n     cert_store = NewRootCertStore();\n-    SSL_CTX_set_cert_store(sc->ctx_, cert_store);\n+    SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);\n   }\n \n-  X509_STORE_add_crl(cert_store, crl);\n+  X509_STORE_add_crl(cert_store, crl.get());\n   X509_STORE_set_flags(cert_store,\n                        X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n-\n-  BIO_free_all(bio);\n-  X509_CRL_free(crl);\n }\n \n \n@@ -829,17 +825,15 @@ static unsigned long AddCertsFromFile(  // NOLINT(runtime/int)\n   ERR_clear_error();\n   MarkPopErrorOnReturn mark_pop_error_on_return;\n \n-  BIO* bio = BIO_new_file(file, \"r\");\n-  if (!bio) {\n+  BIOPointer bio(BIO_new_file(file, \"r\"));\n+  if (!bio)\n     return ERR_get_error();\n-  }\n \n   while (X509* x509 =\n-      PEM_read_bio_X509(bio, nullptr, NoPasswordCallback, nullptr)) {\n+      PEM_read_bio_X509(bio.get(), nullptr, NoPasswordCallback, nullptr)) {\n     X509_STORE_add_cert(store, x509);\n     X509_free(x509);\n   }\n-  BIO_free_all(bio);\n \n   unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)\n   // Ignore error if its EOF/no start line found.\n@@ -878,7 +872,7 @@ void SecureContext::AddRootCerts(const FunctionCallbackInfo<Value>& args) {\n \n   // Increment reference count so global store is not deleted along with CTX.\n   X509_STORE_up_ref(root_cert_store);\n-  SSL_CTX_set_cert_store(sc->ctx_, root_cert_store);\n+  SSL_CTX_set_cert_store(sc->ctx_.get(), root_cert_store);\n }\n \n \n@@ -895,7 +889,7 @@ void SecureContext::SetCiphers(const FunctionCallbackInfo<Value>& args) {\n   THROW_AND_RETURN_IF_NOT_STRING(env, args[0], \"Ciphers\");\n \n   const node::Utf8Value ciphers(args.GetIsolate(), args[0]);\n-  SSL_CTX_set_cipher_list(sc->ctx_, *ciphers);\n+  SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers);\n }\n \n \n@@ -914,7 +908,7 @@ void SecureContext::SetECDHCurve(const FunctionCallbackInfo<Value>& args) {\n   if (strcmp(*curve, \"auto\") == 0)\n     return;\n \n-  if (!SSL_CTX_set1_curves_list(sc->ctx_, *curve))\n+  if (!SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve))\n     return env->ThrowError(\"Failed to set ECDH curve\");\n }\n \n@@ -930,19 +924,21 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {\n   if (args.Length() != 1)\n     return THROW_ERR_MISSING_ARGS(env, \"DH argument is mandatory\");\n \n-  // Invalid dhparam is silently discarded and DHE is no longer used.\n-  BIO* bio = LoadBIO(env, args[0]);\n-  if (!bio)\n-    return;\n+  DHPointer dh;\n+  {\n+    BIOPointer bio(LoadBIO(env, args[0]));\n+    if (!bio)\n+      return;\n \n-  DH* dh = PEM_read_bio_DHparams(bio, nullptr, nullptr, nullptr);\n-  BIO_free_all(bio);\n+    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));\n+  }\n \n-  if (dh == nullptr)\n+  // Invalid dhparam is silently discarded and DHE is no longer used.\n+  if (!dh)\n     return;\n \n   const BIGNUM* p;\n-  DH_get0_pqg(dh, &p, nullptr, nullptr);\n+  DH_get0_pqg(dh.get(), &p, nullptr, nullptr);\n   const int size = BN_num_bits(p);\n   if (size < 1024) {\n     return THROW_ERR_INVALID_ARG_VALUE(\n@@ -952,9 +948,8 @@ void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {\n         env->isolate(), \"DH parameter is less than 2048 bits\"));\n   }\n \n-  SSL_CTX_set_options(sc->ctx_, SSL_OP_SINGLE_DH_USE);\n-  int r = SSL_CTX_set_tmp_dh(sc->ctx_, dh);\n-  DH_free(dh);\n+  SSL_CTX_set_options(sc->ctx_.get(), SSL_OP_SINGLE_DH_USE);\n+  int r = SSL_CTX_set_tmp_dh(sc->ctx_.get(), dh.get());\n \n   if (!r)\n     return env->ThrowTypeError(\"Error setting temp DH parameter\");\n@@ -971,7 +966,7 @@ void SecureContext::SetOptions(const FunctionCallbackInfo<Value>& args) {\n   }\n \n   SSL_CTX_set_options(\n-      sc->ctx_,\n+      sc->ctx_.get(),\n       static_cast<long>(args[0]->IntegerValue()));  // NOLINT(runtime/int)\n }\n \n@@ -994,23 +989,21 @@ void SecureContext::SetSessionIdContext(\n       reinterpret_cast<const unsigned char*>(*sessionIdContext);\n   unsigned int sid_ctx_len = sessionIdContext.length();\n \n-  int r = SSL_CTX_set_session_id_context(sc->ctx_, sid_ctx, sid_ctx_len);\n+  int r = SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len);\n   if (r == 1)\n     return;\n \n-  BIO* bio;\n   BUF_MEM* mem;\n   Local<String> message;\n \n-  bio = BIO_new(BIO_s_mem());\n-  if (bio == nullptr) {\n+  BIOPointer bio(BIO_new(BIO_s_mem()));\n+  if (!bio) {\n     message = FIXED_ONE_BYTE_STRING(args.GetIsolate(),\n                                     \"SSL_CTX_set_session_id_context error\");\n   } else {\n-    ERR_print_errors(bio);\n-    BIO_get_mem_ptr(bio, &mem);\n+    ERR_print_errors(bio.get());\n+    BIO_get_mem_ptr(bio.get(), &mem);\n     message = OneByteString(args.GetIsolate(), mem->data, mem->length);\n-    BIO_free_all(bio);\n   }\n \n   args.GetIsolate()->ThrowException(Exception::TypeError(message));\n@@ -1027,27 +1020,22 @@ void SecureContext::SetSessionTimeout(const FunctionCallbackInfo<Value>& args) {\n   }\n \n   int32_t sessionTimeout = args[0]->Int32Value();\n-  SSL_CTX_set_timeout(sc->ctx_, sessionTimeout);\n+  SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);\n }\n \n \n void SecureContext::Close(const FunctionCallbackInfo<Value>& args) {\n   SecureContext* sc;\n   ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());\n-  sc->FreeCTXMem();\n+  sc->Reset();\n }\n \n \n // Takes .pfx or .p12 and password in string or buffer format\n void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n-  BIO* in = nullptr;\n-  PKCS12* p12 = nullptr;\n-  EVP_PKEY* pkey = nullptr;\n-  X509* cert = nullptr;\n-  STACK_OF(X509)* extra_certs = nullptr;\n-  char* pass = nullptr;\n+  std::vector<char> pass;\n   bool ret = false;\n \n   SecureContext* sc;\n@@ -1058,64 +1046,61 @@ void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {\n     return THROW_ERR_MISSING_ARGS(env, \"PFX certificate argument is mandatory\");\n   }\n \n-  in = LoadBIO(env, args[0]);\n-  if (in == nullptr) {\n+  BIOPointer in(LoadBIO(env, args[0]));\n+  if (!in)\n     return env->ThrowError(\"Unable to load BIO\");\n-  }\n \n   if (args.Length() >= 2) {\n     THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], \"Pass phrase\");\n     size_t passlen = Buffer::Length(args[1]);\n-    pass = new char[passlen + 1];\n-    memcpy(pass, Buffer::Data(args[1]), passlen);\n+    pass.resize(passlen + 1);\n+    memcpy(pass.data(), Buffer::Data(args[1]), passlen);\n     pass[passlen] = '\\0';\n   }\n \n   // Free previous certs\n-  if (sc->issuer_ != nullptr) {\n-    X509_free(sc->issuer_);\n-    sc->issuer_ = nullptr;\n-  }\n-  if (sc->cert_ != nullptr) {\n-    X509_free(sc->cert_);\n-    sc->cert_ = nullptr;\n-  }\n-\n-  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_);\n-\n-  if (d2i_PKCS12_bio(in, &p12) &&\n-      PKCS12_parse(p12, pass, &pkey, &cert, &extra_certs) &&\n-      SSL_CTX_use_certificate_chain(sc->ctx_,\n-                                    cert,\n-                                    extra_certs,\n+  sc->issuer_.reset();\n+  sc->cert_.reset();\n+\n+  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());\n+\n+  DeleteFnPtr<PKCS12, PKCS12_free> p12;\n+  EVPKeyPointer pkey;\n+  X509Pointer cert;\n+  StackOfX509 extra_certs;\n+\n+  PKCS12* p12_ptr = nullptr;\n+  EVP_PKEY* pkey_ptr = nullptr;\n+  X509* cert_ptr = nullptr;\n+  STACK_OF(X509)* extra_certs_ptr = nullptr;\n+  if (d2i_PKCS12_bio(in.get(), &p12_ptr) &&\n+      (p12.reset(p12_ptr), true) &&  // Move ownership to the smart pointer.\n+      PKCS12_parse(p12.get(), pass.data(),\n+                   &pkey_ptr,\n+                   &cert_ptr,\n+                   &extra_certs_ptr) &&\n+      (pkey.reset(pkey_ptr), cert.reset(cert_ptr),\n+       extra_certs.reset(extra_certs_ptr), true) &&  // Move ownership.\n+      SSL_CTX_use_certificate_chain(sc->ctx_.get(),\n+                                    std::move(cert),\n+                                    extra_certs.get(),\n                                     &sc->cert_,\n                                     &sc->issuer_) &&\n-      SSL_CTX_use_PrivateKey(sc->ctx_, pkey)) {\n+      SSL_CTX_use_PrivateKey(sc->ctx_.get(), pkey.get())) {\n     // Add CA certs too\n-    for (int i = 0; i < sk_X509_num(extra_certs); i++) {\n-      X509* ca = sk_X509_value(extra_certs, i);\n+    for (int i = 0; i < sk_X509_num(extra_certs.get()); i++) {\n+      X509* ca = sk_X509_value(extra_certs.get(), i);\n \n       if (cert_store == root_cert_store) {\n         cert_store = NewRootCertStore();\n-        SSL_CTX_set_cert_store(sc->ctx_, cert_store);\n+        SSL_CTX_set_cert_store(sc->ctx_.get(), cert_store);\n       }\n       X509_STORE_add_cert(cert_store, ca);\n-      SSL_CTX_add_client_CA(sc->ctx_, ca);\n+      SSL_CTX_add_client_CA(sc->ctx_.get(), ca);\n     }\n     ret = true;\n   }\n \n-  if (pkey != nullptr)\n-    EVP_PKEY_free(pkey);\n-  if (cert != nullptr)\n-    X509_free(cert);\n-  if (extra_certs != nullptr)\n-    sk_X509_pop_free(extra_certs, X509_free);\n-\n-  PKCS12_free(p12);\n-  BIO_free_all(in);\n-  delete[] pass;\n-\n   if (!ret) {\n     unsigned long err = ERR_get_error();  // NOLINT(runtime/int)\n     const char* str = ERR_reason_error_string(err);\n@@ -1125,6 +1110,9 @@ void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {\n \n \n #ifndef OPENSSL_NO_ENGINE\n+// Helper for the smart pointer.\n+void ENGINE_free_fn(ENGINE* engine) { ENGINE_free(engine); }\n+\n void SecureContext::SetClientCertEngine(\n     const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n@@ -1148,18 +1136,16 @@ void SecureContext::SetClientCertEngine(\n \n   const node::Utf8Value engine_id(env->isolate(), args[0]);\n   char errmsg[1024];\n-  ENGINE* engine = LoadEngineById(*engine_id, &errmsg);\n+  DeleteFnPtr<ENGINE, ENGINE_free_fn> engine(\n+      LoadEngineById(*engine_id, &errmsg));\n \n-  if (engine == nullptr) {\n+  if (!engine)\n     return env->ThrowError(errmsg);\n-  }\n \n-  int r = SSL_CTX_set_client_cert_engine(sc->ctx_, engine);\n-  // Free reference (SSL_CTX_set_client_cert_engine took it via ENGINE_init).\n-  ENGINE_free(engine);\n-  if (r == 0) {\n+  // Note that this takes another reference to `engine`.\n+  int r = SSL_CTX_set_client_cert_engine(sc->ctx_.get(), engine.get());\n+  if (r == 0)\n     return ThrowCryptoError(env, ERR_get_error());\n-  }\n   sc->client_cert_engine_provided_ = true;\n }\n #endif  // !OPENSSL_NO_ENGINE\n@@ -1218,7 +1204,7 @@ void SecureContext::EnableTicketKeyCallback(\n   SecureContext* wrap;\n   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n \n-  SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_, TicketKeyCallback);\n+  SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);\n }\n \n \n@@ -1347,9 +1333,9 @@ void SecureContext::GetCertificate(const FunctionCallbackInfo<Value>& args) {\n   X509* cert;\n \n   if (primary)\n-    cert = wrap->cert_;\n+    cert = wrap->cert_.get();\n   else\n-    cert = wrap->issuer_;\n+    cert = wrap->issuer_.get();\n   if (cert == nullptr)\n     return args.GetReturnValue().SetNull();\n \n@@ -1401,8 +1387,8 @@ template <class Base>\n void SSLWrap<Base>::ConfigureSecureContext(SecureContext* sc) {\n #ifdef NODE__HAVE_TLSEXT_STATUS_CB\n   // OCSP stapling\n-  SSL_CTX_set_tlsext_status_cb(sc->ctx_, TLSExtStatusCallback);\n-  SSL_CTX_set_tlsext_status_arg(sc->ctx_, nullptr);\n+  SSL_CTX_set_tlsext_status_cb(sc->ctx_.get(), TLSExtStatusCallback);\n+  SSL_CTX_set_tlsext_status_arg(sc->ctx_.get(), nullptr);\n #endif  // NODE__HAVE_TLSEXT_STATUS_CB\n }\n \n@@ -1415,10 +1401,7 @@ SSL_SESSION* SSLWrap<Base>::GetSessionCallback(SSL* s,\n   Base* w = static_cast<Base*>(SSL_get_app_data(s));\n \n   *copy = 0;\n-  SSL_SESSION* sess = w->next_sess_;\n-  w->next_sess_ = nullptr;\n-\n-  return sess;\n+  return w->next_sess_.release();\n }\n \n \n@@ -1556,29 +1539,29 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n   Local<Context> context = env->context();\n   Local<Object> info = Object::New(env->isolate());\n \n-  BIO* bio = BIO_new(BIO_s_mem());\n+  BIOPointer bio(BIO_new(BIO_s_mem()));\n   BUF_MEM* mem;\n-  if (X509_NAME_print_ex(bio,\n+  if (X509_NAME_print_ex(bio.get(),\n                          X509_get_subject_name(cert),\n                          0,\n                          X509_NAME_FLAGS) > 0) {\n-    BIO_get_mem_ptr(bio, &mem);\n+    BIO_get_mem_ptr(bio.get(), &mem);\n     info->Set(context, env->subject_string(),\n               String::NewFromUtf8(env->isolate(), mem->data,\n                                   String::kNormalString,\n                                   mem->length)).FromJust();\n   }\n-  USE(BIO_reset(bio));\n+  USE(BIO_reset(bio.get()));\n \n   X509_NAME* issuer_name = X509_get_issuer_name(cert);\n-  if (X509_NAME_print_ex(bio, issuer_name, 0, X509_NAME_FLAGS) > 0) {\n-    BIO_get_mem_ptr(bio, &mem);\n+  if (X509_NAME_print_ex(bio.get(), issuer_name, 0, X509_NAME_FLAGS) > 0) {\n+    BIO_get_mem_ptr(bio.get(), &mem);\n     info->Set(context, env->issuer_string(),\n               String::NewFromUtf8(env->isolate(), mem->data,\n                                   String::kNormalString,\n                                   mem->length)).FromJust();\n   }\n-  USE(BIO_reset(bio));\n+  USE(BIO_reset(bio.get()));\n \n   int nids[] = { NID_subject_alt_name, NID_info_access };\n   Local<String> keys[] = { env->subjectaltname_string(),\n@@ -1595,85 +1578,79 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n     ext = X509_get_ext(cert, index);\n     CHECK_NE(ext, nullptr);\n \n-    if (!SafeX509ExtPrint(bio, ext)) {\n-      rv = X509V3_EXT_print(bio, ext, 0, 0);\n+    if (!SafeX509ExtPrint(bio.get(), ext)) {\n+      rv = X509V3_EXT_print(bio.get(), ext, 0, 0);\n       CHECK_EQ(rv, 1);\n     }\n \n-    BIO_get_mem_ptr(bio, &mem);\n+    BIO_get_mem_ptr(bio.get(), &mem);\n     info->Set(context, keys[i],\n               String::NewFromUtf8(env->isolate(), mem->data,\n                                   String::kNormalString,\n                                   mem->length)).FromJust();\n \n-    USE(BIO_reset(bio));\n+    USE(BIO_reset(bio.get()));\n   }\n \n-  EVP_PKEY* pkey = X509_get_pubkey(cert);\n-  RSA* rsa = nullptr;\n-  if (pkey != nullptr)\n-    rsa = EVP_PKEY_get1_RSA(pkey);\n+  EVPKeyPointer pkey(X509_get_pubkey(cert));\n+  RSAPointer rsa;\n+  if (pkey)\n+    rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));\n \n-  if (rsa != nullptr) {\n+  if (rsa) {\n     const BIGNUM* n;\n     const BIGNUM* e;\n-    RSA_get0_key(rsa, &n, &e, nullptr);\n-    BN_print(bio, n);\n-    BIO_get_mem_ptr(bio, &mem);\n+    RSA_get0_key(rsa.get(), &n, &e, nullptr);\n+    BN_print(bio.get(), n);\n+    BIO_get_mem_ptr(bio.get(), &mem);\n     info->Set(context, env->modulus_string(),\n               String::NewFromUtf8(env->isolate(), mem->data,\n                                   String::kNormalString,\n                                   mem->length)).FromJust();\n-    USE(BIO_reset(bio));\n+    USE(BIO_reset(bio.get()));\n \n     uint64_t exponent_word = static_cast<uint64_t>(BN_get_word(e));\n     uint32_t lo = static_cast<uint32_t>(exponent_word);\n     uint32_t hi = static_cast<uint32_t>(exponent_word >> 32);\n     if (hi == 0) {\n-      BIO_printf(bio, \"0x%x\", lo);\n+      BIO_printf(bio.get(), \"0x%x\", lo);\n     } else {\n-      BIO_printf(bio, \"0x%x%08x\", hi, lo);\n+      BIO_printf(bio.get(), \"0x%x%08x\", hi, lo);\n     }\n-    BIO_get_mem_ptr(bio, &mem);\n+    BIO_get_mem_ptr(bio.get(), &mem);\n     info->Set(context, env->exponent_string(),\n               String::NewFromUtf8(env->isolate(), mem->data,\n                                   String::kNormalString,\n                                   mem->length)).FromJust();\n-    USE(BIO_reset(bio));\n+    USE(BIO_reset(bio.get()));\n \n-    int size = i2d_RSA_PUBKEY(rsa, nullptr);\n+    int size = i2d_RSA_PUBKEY(rsa.get(), nullptr);\n     CHECK_GE(size, 0);\n     Local<Object> pubbuff = Buffer::New(env, size).ToLocalChecked();\n     unsigned char* pubserialized =\n         reinterpret_cast<unsigned char*>(Buffer::Data(pubbuff));\n-    i2d_RSA_PUBKEY(rsa, &pubserialized);\n+    i2d_RSA_PUBKEY(rsa.get(), &pubserialized);\n     info->Set(env->pubkey_string(), pubbuff);\n   }\n \n-  if (pkey != nullptr) {\n-    EVP_PKEY_free(pkey);\n-    pkey = nullptr;\n-  }\n-  if (rsa != nullptr) {\n-    RSA_free(rsa);\n-    rsa = nullptr;\n-  }\n+  pkey.reset();\n+  rsa.reset();\n \n-  ASN1_TIME_print(bio, X509_get_notBefore(cert));\n-  BIO_get_mem_ptr(bio, &mem);\n+  ASN1_TIME_print(bio.get(), X509_get_notBefore(cert));\n+  BIO_get_mem_ptr(bio.get(), &mem);\n   info->Set(context, env->valid_from_string(),\n             String::NewFromUtf8(env->isolate(), mem->data,\n                                 String::kNormalString,\n                                 mem->length)).FromJust();\n-  USE(BIO_reset(bio));\n+  USE(BIO_reset(bio.get()));\n \n-  ASN1_TIME_print(bio, X509_get_notAfter(cert));\n-  BIO_get_mem_ptr(bio, &mem);\n+  ASN1_TIME_print(bio.get(), X509_get_notAfter(cert));\n+  BIO_get_mem_ptr(bio.get(), &mem);\n   info->Set(context, env->valid_to_string(),\n             String::NewFromUtf8(env->isolate(), mem->data,\n                                 String::kNormalString,\n                                 mem->length)).FromJust();\n-  BIO_free_all(bio);\n+  bio.reset();\n \n   unsigned char md[EVP_MAX_MD_SIZE];\n   unsigned int md_size;\n@@ -1689,32 +1666,35 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n                 OneByteString(env->isolate(), fingerprint)).FromJust();\n   }\n \n-  STACK_OF(ASN1_OBJECT)* eku = static_cast<STACK_OF(ASN1_OBJECT)*>(\n-      X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr));\n-  if (eku != nullptr) {\n+  StackOfASN1 eku(static_cast<STACK_OF(ASN1_OBJECT)*>(\n+      X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));\n+  if (eku) {\n     Local<Array> ext_key_usage = Array::New(env->isolate());\n     char buf[256];\n \n     int j = 0;\n-    for (int i = 0; i < sk_ASN1_OBJECT_num(eku); i++) {\n-      if (OBJ_obj2txt(buf, sizeof(buf), sk_ASN1_OBJECT_value(eku, i), 1) >= 0)\n+    for (int i = 0; i < sk_ASN1_OBJECT_num(eku.get()); i++) {\n+      if (OBJ_obj2txt(buf,\n+                      sizeof(buf),\n+                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {\n         ext_key_usage->Set(context,\n                            j++,\n                            OneByteString(env->isolate(), buf)).FromJust();\n+      }\n     }\n \n-    sk_ASN1_OBJECT_pop_free(eku, ASN1_OBJECT_free);\n+    eku.reset();\n     info->Set(context, env->ext_key_usage_string(), ext_key_usage).FromJust();\n   }\n \n   if (ASN1_INTEGER* serial_number = X509_get_serialNumber(cert)) {\n-    if (BIGNUM* bn = ASN1_INTEGER_to_BN(serial_number, nullptr)) {\n-      if (char* buf = BN_bn2hex(bn)) {\n+    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));\n+    if (bn) {\n+      OpenSSLBuffer buf(BN_bn2hex(bn.get()));\n+      if (buf) {\n         info->Set(context, env->serial_number_string(),\n-                  OneByteString(env->isolate(), buf)).FromJust();\n-        OPENSSL_free(buf);\n+                  OneByteString(env->isolate(), buf.get())).FromJust();\n       }\n-      BN_free(bn);\n     }\n   }\n \n@@ -1730,28 +1710,26 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n }\n \n \n-static Local<Object> AddIssuerChainToObject(X509** cert,\n+static Local<Object> AddIssuerChainToObject(X509Pointer* cert,\n                                             Local<Object> object,\n-                                            StackOfX509 peer_certs,\n+                                            StackOfX509&& peer_certs,\n                                             Environment* const env) {\n   Local<Context> context = env->isolate()->GetCurrentContext();\n-  *cert = sk_X509_delete(peer_certs.get(), 0);\n+  cert->reset(sk_X509_delete(peer_certs.get(), 0));\n   for (;;) {\n     int i;\n     for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {\n       X509* ca = sk_X509_value(peer_certs.get(), i);\n-      if (X509_check_issued(ca, *cert) != X509_V_OK)\n+      if (X509_check_issued(ca, cert->get()) != X509_V_OK)\n         continue;\n \n       Local<Object> ca_info = X509ToObject(env, ca);\n       object->Set(context, env->issuercert_string(), ca_info).FromJust();\n       object = ca_info;\n \n       // NOTE: Intentionally freeing cert that is not used anymore.\n-      X509_free(*cert);\n-\n       // Delete cert and continue aggregating issuers.\n-      *cert = sk_X509_delete(peer_certs.get(), i);\n+      cert->reset(sk_X509_delete(peer_certs.get(), i));\n       break;\n     }\n \n@@ -1763,41 +1741,38 @@ static Local<Object> AddIssuerChainToObject(X509** cert,\n }\n \n \n-static StackOfX509 CloneSSLCerts(X509** cert,\n+static StackOfX509 CloneSSLCerts(X509Pointer&& cert,\n                                  const STACK_OF(X509)* const ssl_certs) {\n   StackOfX509 peer_certs(sk_X509_new(nullptr));\n-  if (*cert != nullptr)\n-    sk_X509_push(peer_certs.get(), *cert);\n+  if (cert)\n+    sk_X509_push(peer_certs.get(), cert.release());\n   for (int i = 0; i < sk_X509_num(ssl_certs); i++) {\n-    *cert = X509_dup(sk_X509_value(ssl_certs, i));\n-    if (*cert == nullptr)\n-      return StackOfX509();\n-    if (!sk_X509_push(peer_certs.get(), *cert))\n+    X509Pointer cert(X509_dup(sk_X509_value(ssl_certs, i)));\n+    if (!cert || !sk_X509_push(peer_certs.get(), cert.get()))\n       return StackOfX509();\n+    // `cert` is now managed by the stack.\n+    cert.release();\n   }\n   return peer_certs;\n }\n \n \n-static Local<Object> GetLastIssuedCert(X509** cert,\n-                                       const SSL* const ssl,\n+static Local<Object> GetLastIssuedCert(X509Pointer* cert,\n+                                       const SSLPointer& ssl,\n                                        Local<Object> issuer_chain,\n                                        Environment* const env) {\n   Local<Context> context = env->isolate()->GetCurrentContext();\n-  while (X509_check_issued(*cert, *cert) != X509_V_OK) {\n+  while (X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {\n     X509* ca;\n-    if (SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl), *cert, &ca) <= 0)\n+    if (SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get(), &ca) <= 0)\n       break;\n \n     Local<Object> ca_info = X509ToObject(env, ca);\n     issuer_chain->Set(context, env->issuercert_string(), ca_info).FromJust();\n     issuer_chain = ca_info;\n \n-    // NOTE: Intentionally freeing cert that is not used anymore.\n-    X509_free(*cert);\n-\n-    // Delete cert and continue aggregating issuers.\n-    *cert = ca;\n+    // Delete previous cert and continue aggregating issuers.\n+    cert->reset(ca);\n   }\n   return issuer_chain;\n }\n@@ -1818,40 +1793,35 @@ void SSLWrap<Base>::GetPeerCertificate(\n \n   // NOTE: This is because of the odd OpenSSL behavior. On client `cert_chain`\n   // contains the `peer_certificate`, but on server it doesn't.\n-  X509* cert = w->is_server() ? SSL_get_peer_certificate(w->ssl_) : nullptr;\n-  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(w->ssl_);\n-  if (cert == nullptr && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))\n+  X509Pointer cert(\n+      w->is_server() ? SSL_get_peer_certificate(w->ssl_.get()) : nullptr);\n+  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(w->ssl_.get());\n+  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))\n     goto done;\n \n   // Short result requested.\n   if (args.Length() < 1 || !args[0]->IsTrue()) {\n-    X509* target_cert = cert;\n-    if (target_cert == nullptr)\n-      target_cert = sk_X509_value(ssl_certs, 0);\n-    result = X509ToObject(env, target_cert);\n+    result = X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));\n     goto done;\n   }\n \n-  if (auto peer_certs = CloneSSLCerts(&cert, ssl_certs)) {\n+  if (auto peer_certs = CloneSSLCerts(std::move(cert), ssl_certs)) {\n     // First and main certificate.\n-    cert = sk_X509_value(peer_certs.get(), 0);\n-    result = X509ToObject(env, cert);\n+    X509Pointer cert(sk_X509_value(peer_certs.get(), 0));\n+    CHECK(cert);\n+    result = X509ToObject(env, cert.release());\n \n     issuer_chain =\n         AddIssuerChainToObject(&cert, result, std::move(peer_certs), env);\n     issuer_chain = GetLastIssuedCert(&cert, w->ssl_, issuer_chain, env);\n     // Last certificate should be self-signed.\n-    if (X509_check_issued(cert, cert) == X509_V_OK)\n+    if (X509_check_issued(cert.get(), cert.get()) == X509_V_OK)\n       issuer_chain->Set(env->context(),\n                         env->issuercert_string(),\n                         issuer_chain).FromJust();\n-\n-    CHECK_NE(cert, nullptr);\n   }\n \n  done:\n-  if (cert != nullptr)\n-    X509_free(cert);\n   if (result.IsEmpty())\n     result = Object::New(env->isolate());\n   args.GetReturnValue().Set(result);\n@@ -1871,12 +1841,12 @@ void SSLWrap<Base>::GetFinished(const FunctionCallbackInfo<Value>& args) {\n   // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.\n   // Thus, we use a dummy byte.\n   char dummy[1];\n-  size_t len = SSL_get_finished(w->ssl_, dummy, sizeof dummy);\n+  size_t len = SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);\n   if (len == 0)\n     return;\n \n   char* buf = Malloc(len);\n-  CHECK_EQ(len, SSL_get_finished(w->ssl_, buf, len));\n+  CHECK_EQ(len, SSL_get_finished(w->ssl_.get(), buf, len));\n   args.GetReturnValue().Set(Buffer::New(env, buf, len).ToLocalChecked());\n }\n \n@@ -1894,12 +1864,12 @@ void SSLWrap<Base>::GetPeerFinished(const FunctionCallbackInfo<Value>& args) {\n   // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.\n   // Thus, we use a dummy byte.\n   char dummy[1];\n-  size_t len = SSL_get_peer_finished(w->ssl_, dummy, sizeof dummy);\n+  size_t len = SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);\n   if (len == 0)\n     return;\n \n   char* buf = Malloc(len);\n-  CHECK_EQ(len, SSL_get_peer_finished(w->ssl_, buf, len));\n+  CHECK_EQ(len, SSL_get_peer_finished(w->ssl_.get(), buf, len));\n   args.GetReturnValue().Set(Buffer::New(env, buf, len).ToLocalChecked());\n }\n \n@@ -1911,7 +1881,7 @@ void SSLWrap<Base>::GetSession(const FunctionCallbackInfo<Value>& args) {\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n \n-  SSL_SESSION* sess = SSL_get_session(w->ssl_);\n+  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());\n   if (sess == nullptr)\n     return;\n \n@@ -1938,19 +1908,18 @@ void SSLWrap<Base>::SetSession(const FunctionCallbackInfo<Value>& args) {\n \n   THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Session\");\n   size_t slen = Buffer::Length(args[0]);\n-  char* sbuf = new char[slen];\n-  memcpy(sbuf, Buffer::Data(args[0]), slen);\n-\n-  const unsigned char* p = reinterpret_cast<const unsigned char*>(sbuf);\n-  SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, slen);\n+  std::vector<char> sbuf(slen);\n+  if (char* p = Buffer::Data(args[0]))\n+    sbuf.assign(p, p + slen);\n \n-  delete[] sbuf;\n+  const unsigned char* p = reinterpret_cast<const unsigned char*>(sbuf.data());\n+  SSLSessionPointer sess(\n+      d2i_SSL_SESSION(nullptr, &p, slen));\n \n   if (sess == nullptr)\n     return;\n \n-  int r = SSL_set_session(w->ssl_, sess);\n-  SSL_SESSION_free(sess);\n+  int r = SSL_set_session(w->ssl_.get(), sess.get());\n \n   if (!r)\n     return env->ThrowError(\"SSL_set_session error\");\n@@ -1970,9 +1939,7 @@ void SSLWrap<Base>::LoadSession(const FunctionCallbackInfo<Value>& args) {\n     SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, slen);\n \n     // Setup next session and move hello to the BIO buffer\n-    if (w->next_sess_ != nullptr)\n-      SSL_SESSION_free(w->next_sess_);\n-    w->next_sess_ = sess;\n+    w->next_sess_.reset(sess);\n   }\n }\n \n@@ -1981,7 +1948,7 @@ template <class Base>\n void SSLWrap<Base>::IsSessionReused(const FunctionCallbackInfo<Value>& args) {\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n-  bool yes = SSL_session_reused(w->ssl_);\n+  bool yes = SSL_session_reused(w->ssl_.get());\n   args.GetReturnValue().Set(yes);\n }\n \n@@ -2001,7 +1968,7 @@ void SSLWrap<Base>::Renegotiate(const FunctionCallbackInfo<Value>& args) {\n \n   ClearErrorOnReturn clear_error_on_return;\n \n-  bool yes = SSL_renegotiate(w->ssl_) == 1;\n+  bool yes = SSL_renegotiate(w->ssl_.get()) == 1;\n   args.GetReturnValue().Set(yes);\n }\n \n@@ -2011,7 +1978,7 @@ void SSLWrap<Base>::Shutdown(const FunctionCallbackInfo<Value>& args) {\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n \n-  int rv = SSL_shutdown(w->ssl_);\n+  int rv = SSL_shutdown(w->ssl_.get());\n   args.GetReturnValue().Set(rv);\n }\n \n@@ -2022,7 +1989,7 @@ void SSLWrap<Base>::GetTLSTicket(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n   Environment* env = w->ssl_env();\n \n-  SSL_SESSION* sess = SSL_get_session(w->ssl_);\n+  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());\n   if (sess == nullptr)\n     return;\n \n@@ -2074,7 +2041,7 @@ void SSLWrap<Base>::RequestOCSP(\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n \n-  SSL_set_tlsext_status_type(w->ssl_, TLSEXT_STATUSTYPE_ocsp);\n+  SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);\n #endif  // NODE__HAVE_TLSEXT_STATUS_CB\n }\n \n@@ -2087,7 +2054,7 @@ void SSLWrap<Base>::GetEphemeralKeyInfo(\n   Environment* env = Environment::GetCurrent(args);\n   Local<Context> context = env->context();\n \n-  CHECK_NE(w->ssl_, nullptr);\n+  CHECK(w->ssl_);\n \n   // tmp key is available on only client\n   if (w->is_server())\n@@ -2097,7 +2064,7 @@ void SSLWrap<Base>::GetEphemeralKeyInfo(\n \n   EVP_PKEY* key;\n \n-  if (SSL_get_server_tmp_key(w->ssl_, &key)) {\n+  if (SSL_get_server_tmp_key(w->ssl_.get(), &key)) {\n     int kid = EVP_PKEY_id(key);\n     switch (kid) {\n       case EVP_PKEY_DH:\n@@ -2147,7 +2114,9 @@ void SSLWrap<Base>::SetMaxSendFragment(\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n \n-  int rv = SSL_set_max_send_fragment(w->ssl_, args[0]->Int32Value());\n+  int rv = SSL_set_max_send_fragment(\n+      w->ssl_.get(),\n+      args[0]->Int32Value(w->ssl_env()->context()).FromJust());\n   args.GetReturnValue().Set(rv);\n }\n #endif  // SSL_set_max_send_fragment\n@@ -2157,7 +2126,7 @@ template <class Base>\n void SSLWrap<Base>::IsInitFinished(const FunctionCallbackInfo<Value>& args) {\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n-  bool yes = SSL_is_init_finished(w->ssl_);\n+  bool yes = SSL_is_init_finished(w->ssl_.get());\n   args.GetReturnValue().Set(yes);\n }\n \n@@ -2172,9 +2141,9 @@ void SSLWrap<Base>::VerifyError(const FunctionCallbackInfo<Value>& args) {\n   // here before.\n   long x509_verify_error =  // NOLINT(runtime/int)\n       X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n-  if (X509* peer_cert = SSL_get_peer_certificate(w->ssl_)) {\n+  if (X509* peer_cert = SSL_get_peer_certificate(w->ssl_.get())) {\n     X509_free(peer_cert);\n-    x509_verify_error = SSL_get_verify_result(w->ssl_);\n+    x509_verify_error = SSL_get_verify_result(w->ssl_.get());\n   }\n \n   if (x509_verify_error == X509_V_OK)\n@@ -2234,7 +2203,7 @@ void SSLWrap<Base>::GetCurrentCipher(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = w->ssl_env();\n   Local<Context> context = env->context();\n \n-  const SSL_CIPHER* c = SSL_get_current_cipher(w->ssl_);\n+  const SSL_CIPHER* c = SSL_get_current_cipher(w->ssl_.get());\n   if (c == nullptr)\n     return;\n \n@@ -2253,7 +2222,7 @@ void SSLWrap<Base>::GetProtocol(const FunctionCallbackInfo<Value>& args) {\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n \n-  const char* tls_version = SSL_get_version(w->ssl_);\n+  const char* tls_version = SSL_get_version(w->ssl_.get());\n   args.GetReturnValue().Set(OneByteString(args.GetIsolate(), tls_version));\n }\n \n@@ -2301,7 +2270,7 @@ void SSLWrap<Base>::GetALPNNegotiatedProto(\n   const unsigned char* alpn_proto;\n   unsigned int alpn_proto_len;\n \n-  SSL_get0_alpn_selected(w->ssl_, &alpn_proto, &alpn_proto_len);\n+  SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);\n \n   if (!alpn_proto)\n     return args.GetReturnValue().Set(false);\n@@ -2326,16 +2295,17 @@ void SSLWrap<Base>::SetALPNProtocols(\n     const unsigned char* alpn_protos =\n         reinterpret_cast<const unsigned char*>(Buffer::Data(args[0]));\n     unsigned alpn_protos_len = Buffer::Length(args[0]);\n-    int r = SSL_set_alpn_protos(w->ssl_, alpn_protos, alpn_protos_len);\n+    int r = SSL_set_alpn_protos(w->ssl_.get(), alpn_protos, alpn_protos_len);\n     CHECK_EQ(r, 0);\n   } else {\n     CHECK(\n         w->object()->SetPrivate(\n-          env->context(),\n-          env->alpn_buffer_private_symbol(),\n-          args[0]).FromJust());\n+            env->context(),\n+            env->alpn_buffer_private_symbol(),\n+            args[0]).FromJust());\n     // Server should select ALPN protocol from list of advertised by client\n-    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(w->ssl_), SelectALPNCallback,\n+    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(w->ssl_.get()),\n+                               SelectALPNCallback,\n                                nullptr);\n   }\n #endif  // TLSEXT_TYPE_application_layer_protocol_negotiation\n@@ -2471,17 +2441,17 @@ void SSLWrap<Base>::CertCbDone(const FunctionCallbackInfo<Value>& args) {\n     int rv;\n \n     // NOTE: reference count is not increased by this API methods\n-    X509* x509 = SSL_CTX_get0_certificate(sc->ctx_);\n-    EVP_PKEY* pkey = SSL_CTX_get0_privatekey(sc->ctx_);\n+    X509* x509 = SSL_CTX_get0_certificate(sc->ctx_.get());\n+    EVP_PKEY* pkey = SSL_CTX_get0_privatekey(sc->ctx_.get());\n     STACK_OF(X509)* chain;\n \n-    rv = SSL_CTX_get0_chain_certs(sc->ctx_, &chain);\n+    rv = SSL_CTX_get0_chain_certs(sc->ctx_.get(), &chain);\n     if (rv)\n-      rv = SSL_use_certificate(w->ssl_, x509);\n+      rv = SSL_use_certificate(w->ssl_.get(), x509);\n     if (rv)\n-      rv = SSL_use_PrivateKey(w->ssl_, pkey);\n+      rv = SSL_use_PrivateKey(w->ssl_.get(), pkey);\n     if (rv && chain != nullptr)\n-      rv = SSL_set1_chain(w->ssl_, chain);\n+      rv = SSL_set1_chain(w->ssl_.get(), chain);\n     if (rv)\n       rv = w->SetCACerts(sc);\n     if (!rv) {\n@@ -2514,35 +2484,35 @@ void SSLWrap<Base>::CertCbDone(const FunctionCallbackInfo<Value>& args) {\n \n template <class Base>\n void SSLWrap<Base>::DestroySSL() {\n-  if (ssl_ == nullptr)\n+  if (!ssl_)\n     return;\n \n-  SSL_free(ssl_);\n   env_->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);\n-  ssl_ = nullptr;\n+  ssl_.reset();\n }\n \n \n template <class Base>\n void SSLWrap<Base>::SetSNIContext(SecureContext* sc) {\n   ConfigureSecureContext(sc);\n-  CHECK_EQ(SSL_set_SSL_CTX(ssl_, sc->ctx_), sc->ctx_);\n+  CHECK_EQ(SSL_set_SSL_CTX(ssl_.get(), sc->ctx_.get()), sc->ctx_.get());\n \n   SetCACerts(sc);\n }\n \n \n template <class Base>\n int SSLWrap<Base>::SetCACerts(SecureContext* sc) {\n-  int err = SSL_set1_verify_cert_store(ssl_, SSL_CTX_get_cert_store(sc->ctx_));\n+  int err = SSL_set1_verify_cert_store(ssl_.get(),\n+                                       SSL_CTX_get_cert_store(sc->ctx_.get()));\n   if (err != 1)\n     return err;\n \n   STACK_OF(X509_NAME)* list = SSL_dup_CA_list(\n-      SSL_CTX_get_client_CA_list(sc->ctx_));\n+      SSL_CTX_get_client_CA_list(sc->ctx_.get()));\n \n   // NOTE: `SSL_set_client_CA_list` takes the ownership of `list`\n-  SSL_set_client_CA_list(ssl_, list);\n+  SSL_set_client_CA_list(ssl_.get(), list);\n   return 1;\n }\n \n@@ -2631,11 +2601,10 @@ void CipherBase::Init(const char* cipher_type,\n   }\n #endif  // NODE_FIPS_MODE\n \n-  CHECK_EQ(ctx_, nullptr);\n+  CHECK(!ctx_);\n   const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);\n-  if (cipher == nullptr) {\n+  if (cipher == nullptr)\n     return env()->ThrowError(\"Unknown cipher\");\n-  }\n \n   unsigned char key[EVP_MAX_KEY_LENGTH];\n   unsigned char iv[EVP_MAX_IV_LENGTH];\n@@ -2649,11 +2618,11 @@ void CipherBase::Init(const char* cipher_type,\n                                key,\n                                iv);\n \n-  ctx_ = EVP_CIPHER_CTX_new();\n+  ctx_.reset(EVP_CIPHER_CTX_new());\n   const bool encrypt = (kind_ == kCipher);\n-  EVP_CipherInit_ex(ctx_, cipher, nullptr, nullptr, nullptr, encrypt);\n+  EVP_CipherInit_ex(ctx_.get(), cipher, nullptr, nullptr, nullptr, encrypt);\n \n-  int mode = EVP_CIPHER_CTX_mode(ctx_);\n+  int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n   if (encrypt && (mode == EVP_CIPH_CTR_MODE || mode == EVP_CIPH_GCM_MODE ||\n       mode == EVP_CIPH_CCM_MODE)) {\n     // Ignore the return value (i.e. possible exception) because we are\n@@ -2664,17 +2633,17 @@ void CipherBase::Init(const char* cipher_type,\n   }\n \n   if (mode == EVP_CIPH_WRAP_MODE)\n-    EVP_CIPHER_CTX_set_flags(ctx_, EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n+    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n \n   if (IsAuthenticatedMode()) {\n     if (!InitAuthenticated(cipher_type, EVP_CIPHER_iv_length(cipher),\n                            auth_tag_len))\n       return;\n   }\n \n-  CHECK_EQ(1, EVP_CIPHER_CTX_set_key_length(ctx_, key_len));\n+  CHECK_EQ(1, EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len));\n \n-  EVP_CipherInit_ex(ctx_,\n+  EVP_CipherInit_ex(ctx_.get(),\n                     nullptr,\n                     nullptr,\n                     reinterpret_cast<unsigned char*>(key),\n@@ -2738,27 +2707,26 @@ void CipherBase::InitIv(const char* cipher_type,\n     return env()->ThrowError(\"Invalid IV length\");\n   }\n \n-  ctx_ = EVP_CIPHER_CTX_new();\n+  ctx_.reset(EVP_CIPHER_CTX_new());\n \n   if (mode == EVP_CIPH_WRAP_MODE)\n-    EVP_CIPHER_CTX_set_flags(ctx_, EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n+    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n \n   const bool encrypt = (kind_ == kCipher);\n-  EVP_CipherInit_ex(ctx_, cipher, nullptr, nullptr, nullptr, encrypt);\n+  EVP_CipherInit_ex(ctx_.get(), cipher, nullptr, nullptr, nullptr, encrypt);\n \n   if (IsAuthenticatedMode()) {\n     CHECK(has_iv);\n     if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))\n       return;\n   }\n \n-  if (!EVP_CIPHER_CTX_set_key_length(ctx_, key_len)) {\n-    EVP_CIPHER_CTX_free(ctx_);\n-    ctx_ = nullptr;\n+  if (!EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {\n+    ctx_.reset();\n     return env()->ThrowError(\"Invalid key length\");\n   }\n \n-  EVP_CipherInit_ex(ctx_,\n+  EVP_CipherInit_ex(ctx_.get(),\n                     nullptr,\n                     nullptr,\n                     reinterpret_cast<const unsigned char*>(key),\n@@ -2809,12 +2777,15 @@ bool CipherBase::InitAuthenticated(const char *cipher_type, int iv_len,\n                                    unsigned int auth_tag_len) {\n   CHECK(IsAuthenticatedMode());\n \n-  if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_AEAD_SET_IVLEN, iv_len, nullptr)) {\n+  if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),\n+                           EVP_CTRL_AEAD_SET_IVLEN,\n+                           iv_len,\n+                           nullptr)) {\n     env()->ThrowError(\"Invalid IV length\");\n     return false;\n   }\n \n-  const int mode = EVP_CIPHER_CTX_mode(ctx_);\n+  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n   if (mode == EVP_CIPH_CCM_MODE) {\n     if (auth_tag_len == kNoAuthTagLength) {\n       char msg[128];\n@@ -2831,8 +2802,8 @@ bool CipherBase::InitAuthenticated(const char *cipher_type, int iv_len,\n     }\n #endif\n \n-    if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_CCM_SET_TAG, auth_tag_len,\n-        nullptr)) {\n+    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_CCM_SET_TAG, auth_tag_len,\n+                             nullptr)) {\n       env()->ThrowError(\"Invalid authentication tag length\");\n       return false;\n     }\n@@ -2870,8 +2841,8 @@ bool CipherBase::InitAuthenticated(const char *cipher_type, int iv_len,\n \n \n bool CipherBase::CheckCCMMessageLength(int message_len) {\n-  CHECK_NE(ctx_, nullptr);\n-  CHECK(EVP_CIPHER_CTX_mode(ctx_) == EVP_CIPH_CCM_MODE);\n+  CHECK(ctx_);\n+  CHECK(EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);\n \n   if (message_len > max_message_size_) {\n     env()->ThrowError(\"Message exceeds maximum size\");\n@@ -2884,8 +2855,8 @@ bool CipherBase::CheckCCMMessageLength(int message_len) {\n \n bool CipherBase::IsAuthenticatedMode() const {\n   // Check if this cipher operates in an AEAD mode that we support.\n-  CHECK_NE(ctx_, nullptr);\n-  const int mode = EVP_CIPHER_CTX_mode(ctx_);\n+  CHECK(ctx_);\n+  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n   return mode == EVP_CIPH_GCM_MODE || mode == EVP_CIPH_CCM_MODE;\n }\n \n@@ -2896,7 +2867,7 @@ void CipherBase::GetAuthTag(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());\n \n   // Only callable after Final and if encrypting.\n-  if (cipher->ctx_ != nullptr ||\n+  if (cipher->ctx_ ||\n       cipher->kind_ != kCipher ||\n       cipher->auth_tag_len_ == kNoAuthTagLength) {\n     return args.GetReturnValue().SetUndefined();\n@@ -2913,15 +2884,15 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n   CipherBase* cipher;\n   ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());\n \n-  if (cipher->ctx_ == nullptr ||\n+  if (!cipher->ctx_ ||\n       !cipher->IsAuthenticatedMode() ||\n       cipher->kind_ != kDecipher) {\n     return args.GetReturnValue().Set(false);\n   }\n \n   // Restrict GCM tag lengths according to NIST 800-38d, page 9.\n   unsigned int tag_len = Buffer::Length(args[0]);\n-  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_);\n+  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());\n   if (mode == EVP_CIPH_GCM_MODE) {\n     if ((cipher->auth_tag_len_ != kNoAuthTagLength &&\n         cipher->auth_tag_len_ != tag_len) ||\n@@ -2944,11 +2915,11 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n \n \n bool CipherBase::SetAAD(const char* data, unsigned int len, int plaintext_len) {\n-  if (ctx_ == nullptr || !IsAuthenticatedMode())\n+  if (!ctx_ || !IsAuthenticatedMode())\n     return false;\n \n   int outlen;\n-  const int mode = EVP_CIPHER_CTX_mode(ctx_);\n+  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n \n   // When in CCM mode, we need to set the authentication tag and the plaintext\n   // length in advance.\n@@ -2963,7 +2934,7 @@ bool CipherBase::SetAAD(const char* data, unsigned int len, int plaintext_len) {\n \n     if (kind_ == kDecipher && !auth_tag_set_ && auth_tag_len_ > 0 &&\n         auth_tag_len_ != kNoAuthTagLength) {\n-      if (!EVP_CIPHER_CTX_ctrl(ctx_,\n+      if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),\n                                EVP_CTRL_CCM_SET_TAG,\n                                auth_tag_len_,\n                                reinterpret_cast<unsigned char*>(auth_tag_))) {\n@@ -2973,11 +2944,11 @@ bool CipherBase::SetAAD(const char* data, unsigned int len, int plaintext_len) {\n     }\n \n     // Specify the plaintext length.\n-    if (!EVP_CipherUpdate(ctx_, nullptr, &outlen, nullptr, plaintext_len))\n+    if (!EVP_CipherUpdate(ctx_.get(), nullptr, &outlen, nullptr, plaintext_len))\n       return false;\n   }\n \n-  return 1 == EVP_CipherUpdate(ctx_,\n+  return 1 == EVP_CipherUpdate(ctx_.get(),\n                                nullptr,\n                                &outlen,\n                                reinterpret_cast<const unsigned char*>(data),\n@@ -3003,10 +2974,10 @@ CipherBase::UpdateResult CipherBase::Update(const char* data,\n                                             int len,\n                                             unsigned char** out,\n                                             int* out_len) {\n-  if (ctx_ == nullptr)\n+  if (!ctx_)\n     return kErrorState;\n \n-  const int mode = EVP_CIPHER_CTX_mode(ctx_);\n+  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n \n   if (mode == EVP_CIPH_CCM_MODE) {\n     if (!CheckCCMMessageLength(len))\n@@ -3016,19 +2987,19 @@ CipherBase::UpdateResult CipherBase::Update(const char* data,\n   // on first update:\n   if (kind_ == kDecipher && IsAuthenticatedMode() && auth_tag_len_ > 0 &&\n       auth_tag_len_ != kNoAuthTagLength && !auth_tag_set_) {\n-    EVP_CIPHER_CTX_ctrl(ctx_,\n+    EVP_CIPHER_CTX_ctrl(ctx_.get(),\n                         EVP_CTRL_GCM_SET_TAG,\n                         auth_tag_len_,\n                         reinterpret_cast<unsigned char*>(auth_tag_));\n     auth_tag_set_ = true;\n   }\n \n   *out_len = 0;\n-  int buff_len = len + EVP_CIPHER_CTX_block_size(ctx_);\n+  int buff_len = len + EVP_CIPHER_CTX_block_size(ctx_.get());\n   // For key wrapping algorithms, get output size by calling\n   // EVP_CipherUpdate() with null output.\n   if (mode == EVP_CIPH_WRAP_MODE &&\n-      EVP_CipherUpdate(ctx_,\n+      EVP_CipherUpdate(ctx_.get(),\n                        nullptr,\n                        &buff_len,\n                        reinterpret_cast<const unsigned char*>(data),\n@@ -3037,7 +3008,7 @@ CipherBase::UpdateResult CipherBase::Update(const char* data,\n   }\n \n   *out = Malloc<unsigned char>(buff_len);\n-  int r = EVP_CipherUpdate(ctx_,\n+  int r = EVP_CipherUpdate(ctx_.get(),\n                            *out,\n                            out_len,\n                            reinterpret_cast<const unsigned char*>(data),\n@@ -3095,9 +3066,9 @@ void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {\n \n \n bool CipherBase::SetAutoPadding(bool auto_padding) {\n-  if (ctx_ == nullptr)\n+  if (!ctx_)\n     return false;\n-  return EVP_CIPHER_CTX_set_padding(ctx_, auto_padding);\n+  return EVP_CIPHER_CTX_set_padding(ctx_.get(), auto_padding);\n }\n \n \n@@ -3111,36 +3082,35 @@ void CipherBase::SetAutoPadding(const FunctionCallbackInfo<Value>& args) {\n \n \n bool CipherBase::Final(unsigned char** out, int *out_len) {\n-  if (ctx_ == nullptr)\n+  if (!ctx_)\n     return false;\n \n-  const int mode = EVP_CIPHER_CTX_mode(ctx_);\n+  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n \n   *out = Malloc<unsigned char>(\n-      static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_)));\n+      static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));\n \n   // In CCM mode, final() only checks whether authentication failed in update().\n   // EVP_CipherFinal_ex must not be called and will fail.\n   bool ok;\n   if (kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {\n     ok = !pending_auth_failed_;\n   } else {\n-    ok = EVP_CipherFinal_ex(ctx_, *out, out_len) == 1;\n+    ok = EVP_CipherFinal_ex(ctx_.get(), *out, out_len) == 1;\n \n     if (ok && kind_ == kCipher && IsAuthenticatedMode()) {\n       // In GCM mode, the authentication tag length can be specified in advance,\n       // but defaults to 16 bytes when encrypting. In CCM mode, it must always\n       // be given by the user.\n       if (mode == EVP_CIPH_GCM_MODE && auth_tag_len_ == kNoAuthTagLength)\n         auth_tag_len_ = sizeof(auth_tag_);\n-      CHECK_EQ(1, EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_AEAD_GET_TAG,\n+      CHECK_EQ(1, EVP_CIPHER_CTX_ctrl(ctx_.get(), EVP_CTRL_AEAD_GET_TAG,\n                       auth_tag_len_,\n                       reinterpret_cast<unsigned char*>(auth_tag_)));\n     }\n   }\n \n-  EVP_CIPHER_CTX_free(ctx_);\n-  ctx_ = nullptr;\n+  ctx_.reset();\n \n   return ok;\n }\n@@ -3183,11 +3153,6 @@ void CipherBase::Final(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-Hmac::~Hmac() {\n-  HMAC_CTX_free(ctx_);\n-}\n-\n-\n void Hmac::Initialize(Environment* env, v8::Local<v8::Object> target) {\n   Local<FunctionTemplate> t = env->NewFunctionTemplate(New);\n \n@@ -3217,11 +3182,9 @@ void Hmac::HmacInit(const char* hash_type, const char* key, int key_len) {\n   if (key_len == 0) {\n     key = \"\";\n   }\n-  ctx_ = HMAC_CTX_new();\n-  if (ctx_ == nullptr ||\n-      !HMAC_Init_ex(ctx_, key, key_len, md, nullptr)) {\n-    HMAC_CTX_free(ctx_);\n-    ctx_ = nullptr;\n+  ctx_.reset(HMAC_CTX_new());\n+  if (!ctx_ || !HMAC_Init_ex(ctx_.get(), key, key_len, md, nullptr)) {\n+    ctx_.reset();\n     return ThrowCryptoError(env(), ERR_get_error());\n   }\n }\n@@ -3240,9 +3203,11 @@ void Hmac::HmacInit(const FunctionCallbackInfo<Value>& args) {\n \n \n bool Hmac::HmacUpdate(const char* data, int len) {\n-  if (ctx_ == nullptr)\n+  if (!ctx_)\n     return false;\n-  int r = HMAC_Update(ctx_, reinterpret_cast<const unsigned char*>(data), len);\n+  int r = HMAC_Update(ctx_.get(),\n+                      reinterpret_cast<const unsigned char*>(data),\n+                      len);\n   return r == 1;\n }\n \n@@ -3287,10 +3252,9 @@ void Hmac::HmacDigest(const FunctionCallbackInfo<Value>& args) {\n   unsigned char md_value[EVP_MAX_MD_SIZE];\n   unsigned int md_len = 0;\n \n-  if (hmac->ctx_ != nullptr) {\n-    HMAC_Final(hmac->ctx_, md_value, &md_len);\n-    HMAC_CTX_free(hmac->ctx_);\n-    hmac->ctx_ = nullptr;\n+  if (hmac->ctx_) {\n+    HMAC_Final(hmac->ctx_.get(), md_value, &md_len);\n+    hmac->ctx_.reset();\n   }\n \n   Local<Value> error;\n@@ -3309,11 +3273,6 @@ void Hmac::HmacDigest(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-Hash::~Hash() {\n-  EVP_MD_CTX_free(mdctx_);\n-}\n-\n-\n void Hash::Initialize(Environment* env, v8::Local<v8::Object> target) {\n   Local<FunctionTemplate> t = env->NewFunctionTemplate(New);\n \n@@ -3343,11 +3302,9 @@ bool Hash::HashInit(const char* hash_type) {\n   const EVP_MD* md = EVP_get_digestbyname(hash_type);\n   if (md == nullptr)\n     return false;\n-  mdctx_ = EVP_MD_CTX_new();\n-  if (mdctx_ == nullptr ||\n-      EVP_DigestInit_ex(mdctx_, md, nullptr) <= 0) {\n-    EVP_MD_CTX_free(mdctx_);\n-    mdctx_ = nullptr;\n+  mdctx_.reset(EVP_MD_CTX_new());\n+  if (!mdctx_ || EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {\n+    mdctx_.reset();\n     return false;\n   }\n   finalized_ = false;\n@@ -3356,9 +3313,9 @@ bool Hash::HashInit(const char* hash_type) {\n \n \n bool Hash::HashUpdate(const char* data, int len) {\n-  if (mdctx_ == nullptr)\n+  if (!mdctx_)\n     return false;\n-  EVP_DigestUpdate(mdctx_, data, len);\n+  EVP_DigestUpdate(mdctx_.get(), data, len);\n   return true;\n }\n \n@@ -3402,7 +3359,7 @@ void Hash::HashDigest(const FunctionCallbackInfo<Value>& args) {\n   unsigned char md_value[EVP_MAX_MD_SIZE];\n   unsigned int md_len;\n \n-  EVP_DigestFinal_ex(hash->mdctx_, md_value, &md_len);\n+  EVP_DigestFinal_ex(hash->mdctx_.get(), md_value, &md_len);\n   hash->finalized_ = true;\n \n   Local<Value> error;\n@@ -3421,11 +3378,6 @@ void Hash::HashDigest(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-SignBase::~SignBase() {\n-  EVP_MD_CTX_free(mdctx_);\n-}\n-\n-\n SignBase::Error SignBase::Init(const char* sign_type) {\n   CHECK_EQ(mdctx_, nullptr);\n   // Historically, \"dss1\" and \"DSS1\" were DSA aliases for SHA-1\n@@ -3438,11 +3390,9 @@ SignBase::Error SignBase::Init(const char* sign_type) {\n   if (md == nullptr)\n     return kSignUnknownDigest;\n \n-  mdctx_ = EVP_MD_CTX_new();\n-  if (mdctx_ == nullptr ||\n-      !EVP_DigestInit_ex(mdctx_, md, nullptr)) {\n-    EVP_MD_CTX_free(mdctx_);\n-    mdctx_ = nullptr;\n+  mdctx_.reset(EVP_MD_CTX_new());\n+  if (!mdctx_ || !EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {\n+    mdctx_.reset();\n     return kSignInit;\n   }\n \n@@ -3453,7 +3403,7 @@ SignBase::Error SignBase::Init(const char* sign_type) {\n SignBase::Error SignBase::Update(const char* data, int len) {\n   if (mdctx_ == nullptr)\n     return kSignNotInitialised;\n-  if (!EVP_DigestUpdate(mdctx_, data, len))\n+  if (!EVP_DigestUpdate(mdctx_.get(), data, len))\n     return kSignUpdate;\n   return kSignOk;\n }\n@@ -3496,10 +3446,12 @@ void SignBase::CheckThrow(SignBase::Error error) {\n   }\n }\n \n-static bool ApplyRSAOptions(EVP_PKEY* pkey, EVP_PKEY_CTX* pkctx, int padding,\n+static bool ApplyRSAOptions(const EVPKeyPointer& pkey,\n+                            EVP_PKEY_CTX* pkctx,\n+                            int padding,\n                             int salt_len) {\n-  if (EVP_PKEY_id(pkey) == EVP_PKEY_RSA ||\n-      EVP_PKEY_id(pkey) == EVP_PKEY_RSA2) {\n+  if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||\n+      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2) {\n     if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)\n       return false;\n     if (padding == RSA_PKCS1_PSS_PADDING) {\n@@ -3553,35 +3505,29 @@ void Sign::SignUpdate(const FunctionCallbackInfo<Value>& args) {\n   sign->CheckThrow(err);\n }\n \n-static int Node_SignFinal(EVP_MD_CTX* mdctx, unsigned char* md,\n-                          unsigned int* sig_len, EVP_PKEY* pkey, int padding,\n+static int Node_SignFinal(EVPMDPointer&& mdctx, unsigned char* md,\n+                          unsigned int* sig_len,\n+                          const EVPKeyPointer& pkey, int padding,\n                           int pss_salt_len) {\n   unsigned char m[EVP_MAX_MD_SIZE];\n   unsigned int m_len;\n-  int rv = 0;\n-  EVP_PKEY_CTX* pkctx = nullptr;\n \n   *sig_len = 0;\n-  if (!EVP_DigestFinal_ex(mdctx, m, &m_len))\n-    return rv;\n-\n-  size_t sltmp = static_cast<size_t>(EVP_PKEY_size(pkey));\n-  pkctx = EVP_PKEY_CTX_new(pkey, nullptr);\n-  if (pkctx == nullptr)\n-    goto err;\n-  if (EVP_PKEY_sign_init(pkctx) <= 0)\n-    goto err;\n-  if (!ApplyRSAOptions(pkey, pkctx, padding, pss_salt_len))\n-    goto err;\n-  if (EVP_PKEY_CTX_set_signature_md(pkctx, EVP_MD_CTX_md(mdctx)) <= 0)\n-    goto err;\n-  if (EVP_PKEY_sign(pkctx, md, &sltmp, m, m_len) <= 0)\n-    goto err;\n-  *sig_len = sltmp;\n-  rv = 1;\n- err:\n-  EVP_PKEY_CTX_free(pkctx);\n-  return rv;\n+  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))\n+    return 0;\n+\n+  size_t sltmp = static_cast<size_t>(EVP_PKEY_size(pkey.get()));\n+  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));\n+  if (pkctx &&\n+      EVP_PKEY_sign_init(pkctx.get()) > 0 &&\n+      ApplyRSAOptions(pkey, pkctx.get(), padding, pss_salt_len) &&\n+      EVP_PKEY_CTX_set_signature_md(pkctx.get(),\n+                                    EVP_MD_CTX_md(mdctx.get())) > 0 &&\n+      EVP_PKEY_sign(pkctx.get(), md, &sltmp, m, m_len) > 0) {\n+    *sig_len = sltmp;\n+    return 1;\n+  }\n+  return 0;\n }\n \n SignBase::Error Sign::SignFinal(const char* key_pem,\n@@ -3594,24 +3540,22 @@ SignBase::Error Sign::SignFinal(const char* key_pem,\n   if (!mdctx_)\n     return kSignNotInitialised;\n \n-  BIO* bp = nullptr;\n-  EVP_PKEY* pkey = nullptr;\n-  bool fatal = true;\n+  EVPMDPointer mdctx = std::move(mdctx_);\n \n-  bp = BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len);\n-  if (bp == nullptr)\n-    goto exit;\n+  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n+  if (!bp)\n+    return kSignPrivateKey;\n \n-  pkey = PEM_read_bio_PrivateKey(bp,\n-                                 nullptr,\n-                                 PasswordCallback,\n-                                 const_cast<char*>(passphrase));\n+  EVPKeyPointer pkey(PEM_read_bio_PrivateKey(bp.get(),\n+                                             nullptr,\n+                                             PasswordCallback,\n+                                             const_cast<char*>(passphrase)));\n \n   // Errors might be injected into OpenSSL's error stack\n   // without `pkey` being set to nullptr;\n   // cf. the test of `test_bad_rsa_privkey.pem` for an example.\n-  if (pkey == nullptr || 0 != ERR_peek_error())\n-    goto exit;\n+  if (!pkey || 0 != ERR_peek_error())\n+    return kSignPrivateKey;\n \n #ifdef NODE_FIPS_MODE\n   /* Validate DSA2 parameters from FIPS 186-4 */\n@@ -3630,28 +3574,15 @@ SignBase::Error Sign::SignFinal(const char* key_pem,\n       result = true;\n \n     if (!result) {\n-      fatal = true;\n-      goto exit;\n+      return kSignPrivateKey;\n     }\n   }\n #endif  // NODE_FIPS_MODE\n \n-  if (Node_SignFinal(mdctx_, sig, sig_len, pkey, padding, salt_len))\n-    fatal = false;\n-\n- exit:\n-  if (pkey != nullptr)\n-    EVP_PKEY_free(pkey);\n-  if (bp != nullptr)\n-    BIO_free_all(bp);\n-\n-  EVP_MD_CTX_free(mdctx_);\n-  mdctx_ = nullptr;\n-\n-  if (fatal)\n+  if (Node_SignFinal(std::move(mdctx), sig, sig_len, pkey, padding, salt_len))\n+    return kSignOk;\n+  else\n     return kSignPrivateKey;\n-\n-  return kSignOk;\n }\n \n \n@@ -3752,87 +3683,60 @@ SignBase::Error Verify::VerifyFinal(const char* key_pem,\n   if (!mdctx_)\n     return kSignNotInitialised;\n \n-  EVP_PKEY* pkey = nullptr;\n-  BIO* bp = nullptr;\n-  X509* x509 = nullptr;\n-  bool fatal = true;\n+  EVPKeyPointer pkey;\n   unsigned char m[EVP_MAX_MD_SIZE];\n   unsigned int m_len;\n   int r = 0;\n-  EVP_PKEY_CTX* pkctx = nullptr;\n+  *verify_result = false;\n+  EVPMDPointer mdctx = std::move(mdctx_);\n \n-  bp = BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len);\n-  if (bp == nullptr)\n-    goto exit;\n+  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n+  if (!bp)\n+    return kSignPublicKey;\n \n   // Check if this is a PKCS#8 or RSA public key before trying as X.509.\n   // Split this out into a separate function once we have more than one\n   // consumer of public keys.\n   if (strncmp(key_pem, PUBLIC_KEY_PFX, PUBLIC_KEY_PFX_LEN) == 0) {\n-    pkey = PEM_read_bio_PUBKEY(bp, nullptr, NoPasswordCallback, nullptr);\n-    if (pkey == nullptr)\n-      goto exit;\n+    pkey.reset(\n+        PEM_read_bio_PUBKEY(bp.get(), nullptr, NoPasswordCallback, nullptr));\n   } else if (strncmp(key_pem, PUBRSA_KEY_PFX, PUBRSA_KEY_PFX_LEN) == 0) {\n-    RSA* rsa =\n-        PEM_read_bio_RSAPublicKey(bp, nullptr, PasswordCallback, nullptr);\n+    RSAPointer rsa(PEM_read_bio_RSAPublicKey(\n+        bp.get(), nullptr, PasswordCallback, nullptr));\n     if (rsa) {\n-      pkey = EVP_PKEY_new();\n+      pkey.reset(EVP_PKEY_new());\n       if (pkey)\n-        EVP_PKEY_set1_RSA(pkey, rsa);\n-      RSA_free(rsa);\n+        EVP_PKEY_set1_RSA(pkey.get(), rsa.get());\n     }\n-    if (pkey == nullptr)\n-      goto exit;\n   } else {\n     // X.509 fallback\n-    x509 = PEM_read_bio_X509(bp, nullptr, NoPasswordCallback, nullptr);\n-    if (x509 == nullptr)\n-      goto exit;\n-\n-    pkey = X509_get_pubkey(x509);\n-    if (pkey == nullptr)\n-      goto exit;\n-  }\n-\n-  if (!EVP_DigestFinal_ex(mdctx_, m, &m_len)) {\n-    goto exit;\n-  }\n-\n-  fatal = false;\n-\n-  pkctx = EVP_PKEY_CTX_new(pkey, nullptr);\n-  if (pkctx == nullptr)\n-    goto err;\n-  if (EVP_PKEY_verify_init(pkctx) <= 0)\n-    goto err;\n-  if (!ApplyRSAOptions(pkey, pkctx, padding, saltlen))\n-    goto err;\n-  if (EVP_PKEY_CTX_set_signature_md(pkctx, EVP_MD_CTX_md(mdctx_)) <= 0)\n-    goto err;\n-  r = EVP_PKEY_verify(pkctx,\n-                      reinterpret_cast<const unsigned char*>(sig),\n-                      siglen,\n-                      m,\n-                      m_len);\n-\n- err:\n-  EVP_PKEY_CTX_free(pkctx);\n-\n- exit:\n-  if (pkey != nullptr)\n-    EVP_PKEY_free(pkey);\n-  if (bp != nullptr)\n-    BIO_free_all(bp);\n-  if (x509 != nullptr)\n-    X509_free(x509);\n+    X509Pointer x509(PEM_read_bio_X509(\n+        bp.get(), nullptr, NoPasswordCallback, nullptr));\n+    if (!x509)\n+      return kSignPublicKey;\n \n-  EVP_MD_CTX_free(mdctx_);\n-  mdctx_ = nullptr;\n+    pkey.reset(X509_get_pubkey(x509.get()));\n+  }\n+  if (!pkey)\n+    return kSignPublicKey;\n \n-  if (fatal)\n+  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))\n     return kSignPublicKey;\n \n-  *verify_result = r == 1;\n+  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));\n+  if (pkctx &&\n+      EVP_PKEY_verify_init(pkctx.get()) > 0 &&\n+      ApplyRSAOptions(pkey, pkctx.get(), padding, saltlen) &&\n+      EVP_PKEY_CTX_set_signature_md(pkctx.get(),\n+                                    EVP_MD_CTX_md(mdctx.get())) > 0) {\n+    r = EVP_PKEY_verify(pkctx.get(),\n+                        reinterpret_cast<const unsigned char*>(sig),\n+                        siglen,\n+                        m,\n+                        m_len);\n+    *verify_result = r == 1;\n+  }\n+\n   return kSignOk;\n }\n \n@@ -3881,81 +3785,60 @@ bool PublicKeyCipher::Cipher(const char* key_pem,\n                              int len,\n                              unsigned char** out,\n                              size_t* out_len) {\n-  EVP_PKEY* pkey = nullptr;\n-  EVP_PKEY_CTX* ctx = nullptr;\n-  BIO* bp = nullptr;\n-  X509* x509 = nullptr;\n-  bool fatal = true;\n+  EVPKeyPointer pkey;\n \n-  bp = BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len);\n-  if (bp == nullptr)\n-    goto exit;\n+  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n+  if (!bp)\n+    return false;\n \n   // Check if this is a PKCS#8 or RSA public key before trying as X.509 and\n   // private key.\n   if (operation == kPublic &&\n       strncmp(key_pem, PUBLIC_KEY_PFX, PUBLIC_KEY_PFX_LEN) == 0) {\n-    pkey = PEM_read_bio_PUBKEY(bp, nullptr, nullptr, nullptr);\n-    if (pkey == nullptr)\n-      goto exit;\n+    pkey.reset(PEM_read_bio_PUBKEY(bp.get(), nullptr, nullptr, nullptr));\n   } else if (operation == kPublic &&\n              strncmp(key_pem, PUBRSA_KEY_PFX, PUBRSA_KEY_PFX_LEN) == 0) {\n-    RSA* rsa = PEM_read_bio_RSAPublicKey(bp, nullptr, nullptr, nullptr);\n+    RSAPointer rsa(\n+        PEM_read_bio_RSAPublicKey(bp.get(), nullptr, nullptr, nullptr));\n     if (rsa) {\n-      pkey = EVP_PKEY_new();\n+      pkey.reset(EVP_PKEY_new());\n       if (pkey)\n-        EVP_PKEY_set1_RSA(pkey, rsa);\n-      RSA_free(rsa);\n+        EVP_PKEY_set1_RSA(pkey.get(), rsa.get());\n     }\n-    if (pkey == nullptr)\n-      goto exit;\n   } else if (operation == kPublic &&\n              strncmp(key_pem, CERTIFICATE_PFX, CERTIFICATE_PFX_LEN) == 0) {\n-    x509 = PEM_read_bio_X509(bp, nullptr, NoPasswordCallback, nullptr);\n-    if (x509 == nullptr)\n-      goto exit;\n+    X509Pointer x509(\n+        PEM_read_bio_X509(bp.get(), nullptr, NoPasswordCallback, nullptr));\n+    if (!x509)\n+      return false;\n \n-    pkey = X509_get_pubkey(x509);\n-    if (pkey == nullptr)\n-      goto exit;\n+    pkey.reset(X509_get_pubkey(x509.get()));\n   } else {\n-    pkey = PEM_read_bio_PrivateKey(bp,\n-                                   nullptr,\n-                                   PasswordCallback,\n-                                   const_cast<char*>(passphrase));\n-    if (pkey == nullptr)\n-      goto exit;\n+    pkey.reset(PEM_read_bio_PrivateKey(bp.get(),\n+                                       nullptr,\n+                                       PasswordCallback,\n+                                       const_cast<char*>(passphrase)));\n   }\n+  if (!pkey)\n+    return false;\n \n-  ctx = EVP_PKEY_CTX_new(pkey, nullptr);\n+  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));\n   if (!ctx)\n-    goto exit;\n-  if (EVP_PKEY_cipher_init(ctx) <= 0)\n-    goto exit;\n-  if (EVP_PKEY_CTX_set_rsa_padding(ctx, padding) <= 0)\n-    goto exit;\n+    return false;\n+  if (EVP_PKEY_cipher_init(ctx.get()) <= 0)\n+    return false;\n+  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)\n+    return false;\n \n-  if (EVP_PKEY_cipher(ctx, nullptr, out_len, data, len) <= 0)\n-    goto exit;\n+  if (EVP_PKEY_cipher(ctx.get(), nullptr, out_len, data, len) <= 0)\n+    return false;\n \n   *out = Malloc<unsigned char>(*out_len);\n \n-  if (EVP_PKEY_cipher(ctx, *out, out_len, data, len) <= 0)\n-    goto exit;\n-\n-  fatal = false;\n-\n- exit:\n-  if (x509 != nullptr)\n-    X509_free(x509);\n-  if (pkey != nullptr)\n-    EVP_PKEY_free(pkey);\n-  if (bp != nullptr)\n-    BIO_free_all(bp);\n-  if (ctx != nullptr)\n-    EVP_PKEY_CTX_free(ctx);\n+  if (EVP_PKEY_cipher(ctx.get(), *out, out_len, data, len) <= 0)\n+    return false;\n \n-  return !fatal;\n+  return true;\n }\n \n \n@@ -4069,8 +3952,8 @@ void DiffieHellman::Initialize(Environment* env, Local<Object> target) {\n \n \n bool DiffieHellman::Init(int primeLength, int g) {\n-  dh = DH_new();\n-  if (!DH_generate_parameters_ex(dh, primeLength, g, 0))\n+  dh_.reset(DH_new());\n+  if (!DH_generate_parameters_ex(dh_.get(), primeLength, g, 0))\n     return false;\n   bool result = VerifyContext();\n   if (!result)\n@@ -4081,12 +3964,12 @@ bool DiffieHellman::Init(int primeLength, int g) {\n \n \n bool DiffieHellman::Init(const char* p, int p_len, int g) {\n-  dh = DH_new();\n+  dh_.reset(DH_new());\n   BIGNUM* bn_p =\n       BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);\n   BIGNUM* bn_g = BN_new();\n   if (!BN_set_word(bn_g, g) ||\n-      !DH_set0_pqg(dh, bn_p, nullptr, bn_g)) {\n+      !DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {\n     BN_free(bn_p);\n     BN_free(bn_g);\n     return false;\n@@ -4100,10 +3983,10 @@ bool DiffieHellman::Init(const char* p, int p_len, int g) {\n \n \n bool DiffieHellman::Init(const char* p, int p_len, const char* g, int g_len) {\n-  dh = DH_new();\n+  dh_.reset(DH_new());\n   BIGNUM *bn_p = BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, 0);\n   BIGNUM *bn_g = BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, 0);\n-  if (!DH_set0_pqg(dh, bn_p, nullptr, bn_g)) {\n+  if (!DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {\n     BN_free(bn_p);\n     BN_free(bn_g);\n     return false;\n@@ -4191,12 +4074,12 @@ void DiffieHellman::GenerateKeys(const FunctionCallbackInfo<Value>& args) {\n     return ThrowCryptoError(env, ERR_get_error(), \"Not initialized\");\n   }\n \n-  if (!DH_generate_key(diffieHellman->dh)) {\n+  if (!DH_generate_key(diffieHellman->dh_.get())) {\n     return ThrowCryptoError(env, ERR_get_error(), \"Key generation failed\");\n   }\n \n   const BIGNUM* pub_key;\n-  DH_get0_key(diffieHellman->dh, &pub_key, nullptr);\n+  DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);\n   size_t size = BN_num_bytes(pub_key);\n   char* data = Malloc(size);\n   BN_bn2bin(pub_key, reinterpret_cast<unsigned char*>(data));\n@@ -4213,7 +4096,7 @@ void DiffieHellman::GetField(const FunctionCallbackInfo<Value>& args,\n   ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());\n   if (!dh->initialised_) return env->ThrowError(\"Not initialized\");\n \n-  const BIGNUM* num = get_field(dh->dh);\n+  const BIGNUM* num = get_field(dh->dh_.get());\n   if (num == nullptr) return env->ThrowError(err_if_null);\n \n   size_t size = BN_num_bytes(num);\n@@ -4269,33 +4152,31 @@ void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n   }\n \n   ClearErrorOnReturn clear_error_on_return;\n-  BIGNUM* key = nullptr;\n \n   if (args.Length() == 0) {\n     return THROW_ERR_MISSING_ARGS(\n         env, \"Other party's public key argument is mandatory\");\n-  } else {\n-    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Other party's public key\");\n-    key = BN_bin2bn(\n-        reinterpret_cast<unsigned char*>(Buffer::Data(args[0])),\n-        Buffer::Length(args[0]),\n-        0);\n   }\n \n-  int dataSize = DH_size(diffieHellman->dh);\n-  char* data = Malloc(dataSize);\n+  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Other party's public key\");\n+  BignumPointer key(BN_bin2bn(\n+      reinterpret_cast<unsigned char*>(Buffer::Data(args[0])),\n+      Buffer::Length(args[0]),\n+      0));\n+\n+  MallocedBuffer<char> data(DH_size(diffieHellman->dh_.get()));\n \n-  int size = DH_compute_key(reinterpret_cast<unsigned char*>(data),\n-                            key,\n-                            diffieHellman->dh);\n+  int size = DH_compute_key(reinterpret_cast<unsigned char*>(data.data),\n+                            key.get(),\n+                            diffieHellman->dh_.get());\n \n   if (size == -1) {\n     int checkResult;\n     int checked;\n \n-    checked = DH_check_pub_key(diffieHellman->dh, key, &checkResult);\n-    BN_free(key);\n-    free(data);\n+    checked = DH_check_pub_key(diffieHellman->dh_.get(),\n+                               key.get(),\n+                               &checkResult);\n \n     if (!checked) {\n       return ThrowCryptoError(env, ERR_get_error(), \"Invalid Key\");\n@@ -4314,21 +4195,20 @@ void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n     UNREACHABLE();\n   }\n \n-  BN_free(key);\n   CHECK_GE(size, 0);\n \n   // DH_size returns number of bytes in a prime number\n   // DH_compute_key returns number of bytes in a remainder of exponent, which\n   // may have less bytes than a prime number. Therefore add 0-padding to the\n   // allocated buffer.\n-  if (size != dataSize) {\n-    CHECK(dataSize > size);\n-    memmove(data + dataSize - size, data, size);\n-    memset(data, 0, dataSize - size);\n+  if (static_cast<size_t>(size) != data.size) {\n+    CHECK_GT(data.size, static_cast<size_t>(size));\n+    memmove(data.data + data.size - size, data.data, size);\n+    memset(data.data, 0, data.size - size);\n   }\n \n-  auto rc = Buffer::New(env->isolate(), data, dataSize).ToLocalChecked();\n-  args.GetReturnValue().Set(rc);\n+  args.GetReturnValue().Set(\n+      Buffer::New(env->isolate(), data.release(), data.size).ToLocalChecked());\n }\n \n void DiffieHellman::SetKey(const v8::FunctionCallbackInfo<v8::Value>& args,\n@@ -4355,7 +4235,7 @@ void DiffieHellman::SetKey(const v8::FunctionCallbackInfo<v8::Value>& args,\n       BN_bin2bn(reinterpret_cast<unsigned char*>(Buffer::Data(args[0])),\n                 Buffer::Length(args[0]), nullptr);\n   CHECK_NE(num, nullptr);\n-  CHECK_EQ(1, set_field(dh->dh, num));\n+  CHECK_EQ(1, set_field(dh->dh_.get(), num));\n }\n \n \n@@ -4394,7 +4274,7 @@ void DiffieHellman::VerifyErrorGetter(const FunctionCallbackInfo<Value>& args) {\n \n bool DiffieHellman::VerifyContext() {\n   int codes;\n-  if (!DH_check(dh, &codes))\n+  if (!DH_check(dh_.get(), &codes))\n     return false;\n   verifyError_ = codes;\n   return true;\n@@ -4434,11 +4314,11 @@ void ECDH::New(const FunctionCallbackInfo<Value>& args) {\n     return THROW_ERR_INVALID_ARG_VALUE(env,\n         \"First argument should be a valid curve name\");\n \n-  EC_KEY* key = EC_KEY_new_by_curve_name(nid);\n-  if (key == nullptr)\n+  ECKeyPointer key(EC_KEY_new_by_curve_name(nid));\n+  if (!key)\n     return env->ThrowError(\"Failed to create EC_KEY using curve name\");\n \n-  new ECDH(env, args.This(), key);\n+  new ECDH(env, args.This(), std::move(key));\n }\n \n \n@@ -4448,34 +4328,31 @@ void ECDH::GenerateKeys(const FunctionCallbackInfo<Value>& args) {\n   ECDH* ecdh;\n   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());\n \n-  if (!EC_KEY_generate_key(ecdh->key_))\n+  if (!EC_KEY_generate_key(ecdh->key_.get()))\n     return env->ThrowError(\"Failed to generate EC_KEY\");\n }\n \n \n-EC_POINT* ECDH::BufferToPoint(Environment* env,\n-                              const EC_GROUP* group,\n-                              char* data,\n-                              size_t len) {\n-  EC_POINT* pub;\n+ECPointPointer ECDH::BufferToPoint(Environment* env,\n+                                   const EC_GROUP* group,\n+                                   char* data,\n+                                   size_t len) {\n   int r;\n \n-  pub = EC_POINT_new(group);\n-  if (pub == nullptr) {\n+  ECPointPointer pub(EC_POINT_new(group));\n+  if (!pub) {\n     env->ThrowError(\"Failed to allocate EC_POINT for a public key\");\n-    return nullptr;\n+    return pub;\n   }\n \n   r = EC_POINT_oct2point(\n       group,\n-      pub,\n+      pub.get(),\n       reinterpret_cast<unsigned char*>(data),\n       len,\n       nullptr);\n-  if (!r) {\n-    EC_POINT_free(pub);\n-    return nullptr;\n-  }\n+  if (!r)\n+    return ECPointPointer();\n \n   return pub;\n }\n@@ -4494,11 +4371,12 @@ void ECDH::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n   if (!ecdh->IsKeyPairValid())\n     return env->ThrowError(\"Invalid key pair\");\n \n-  EC_POINT* pub = ECDH::BufferToPoint(env,\n-                                      ecdh->group_,\n-                                      Buffer::Data(args[0]),\n-                                      Buffer::Length(args[0]));\n-  if (pub == nullptr) {\n+  ECPointPointer pub(\n+      ECDH::BufferToPoint(env,\n+                          ecdh->group_,\n+                          Buffer::Data(args[0]),\n+                          Buffer::Length(args[0])));\n+  if (!pub) {\n     args.GetReturnValue().Set(\n         FIXED_ONE_BYTE_STRING(env->isolate(),\n         \"ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY\"));\n@@ -4510,8 +4388,7 @@ void ECDH::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n   size_t out_len = (field_size + 7) / 8;\n   char* out = node::Malloc(out_len);\n \n-  int r = ECDH_compute_key(out, out_len, pub, ecdh->key_, nullptr);\n-  EC_POINT_free(pub);\n+  int r = ECDH_compute_key(out, out_len, pub.get(), ecdh->key_.get(), nullptr);\n   if (!r) {\n     free(out);\n     return env->ThrowError(\"Failed to compute ECDH key\");\n@@ -4531,7 +4408,7 @@ void ECDH::GetPublicKey(const FunctionCallbackInfo<Value>& args) {\n   ECDH* ecdh;\n   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());\n \n-  const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_);\n+  const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_.get());\n   if (pub == nullptr)\n     return env->ThrowError(\"Failed to get ECDH public key\");\n \n@@ -4563,7 +4440,7 @@ void ECDH::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {\n   ECDH* ecdh;\n   ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());\n \n-  const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_);\n+  const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_.get());\n   if (b == nullptr)\n     return env->ThrowError(\"Failed to get ECDH private key\");\n \n@@ -4589,49 +4466,44 @@ void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {\n \n   THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], \"Private key\");\n \n-  BIGNUM* priv = BN_bin2bn(\n+  BignumPointer priv(BN_bin2bn(\n       reinterpret_cast<unsigned char*>(Buffer::Data(args[0].As<Object>())),\n       Buffer::Length(args[0].As<Object>()),\n-      nullptr);\n-  if (priv == nullptr)\n+      nullptr));\n+  if (!priv)\n     return env->ThrowError(\"Failed to convert Buffer to BN\");\n \n   if (!ecdh->IsKeyValidForCurve(priv)) {\n-    BN_free(priv);\n     return env->ThrowError(\"Private key is not valid for specified curve.\");\n   }\n \n-  int result = EC_KEY_set_private_key(ecdh->key_, priv);\n-  BN_free(priv);\n+  int result = EC_KEY_set_private_key(ecdh->key_.get(), priv.get());\n+  priv.reset();\n \n   if (!result) {\n     return env->ThrowError(\"Failed to convert BN to a private key\");\n   }\n \n   // To avoid inconsistency, clear the current public key in-case computing\n   // the new one fails for some reason.\n-  EC_KEY_set_public_key(ecdh->key_, nullptr);\n+  EC_KEY_set_public_key(ecdh->key_.get(), nullptr);\n \n   MarkPopErrorOnReturn mark_pop_error_on_return;\n   USE(&mark_pop_error_on_return);\n \n-  const BIGNUM* priv_key = EC_KEY_get0_private_key(ecdh->key_);\n+  const BIGNUM* priv_key = EC_KEY_get0_private_key(ecdh->key_.get());\n   CHECK_NE(priv_key, nullptr);\n \n-  EC_POINT* pub = EC_POINT_new(ecdh->group_);\n-  CHECK_NE(pub, nullptr);\n+  ECPointPointer pub(EC_POINT_new(ecdh->group_));\n+  CHECK(pub);\n \n-  if (!EC_POINT_mul(ecdh->group_, pub, priv_key, nullptr, nullptr, nullptr)) {\n-    EC_POINT_free(pub);\n+  if (!EC_POINT_mul(ecdh->group_, pub.get(), priv_key,\n+                    nullptr, nullptr, nullptr)) {\n     return env->ThrowError(\"Failed to generate ECDH public key\");\n   }\n \n-  if (!EC_KEY_set_public_key(ecdh->key_, pub)) {\n-    EC_POINT_free(pub);\n+  if (!EC_KEY_set_public_key(ecdh->key_.get(), pub.get()))\n     return env->ThrowError(\"Failed to set generated public key\");\n-  }\n-\n-  EC_POINT_free(pub);\n }\n \n \n@@ -4645,41 +4517,39 @@ void ECDH::SetPublicKey(const FunctionCallbackInfo<Value>& args) {\n \n   MarkPopErrorOnReturn mark_pop_error_on_return;\n \n-  EC_POINT* pub = ECDH::BufferToPoint(env,\n-                                      ecdh->group_,\n-                                      Buffer::Data(args[0].As<Object>()),\n-                                      Buffer::Length(args[0].As<Object>()));\n-  if (pub == nullptr)\n+  ECPointPointer pub(\n+      ECDH::BufferToPoint(env,\n+                          ecdh->group_,\n+                          Buffer::Data(args[0].As<Object>()),\n+                          Buffer::Length(args[0].As<Object>())));\n+  if (!pub)\n     return env->ThrowError(\"Failed to convert Buffer to EC_POINT\");\n \n-  int r = EC_KEY_set_public_key(ecdh->key_, pub);\n-  EC_POINT_free(pub);\n+  int r = EC_KEY_set_public_key(ecdh->key_.get(), pub.get());\n   if (!r)\n     return env->ThrowError(\"Failed to set EC_POINT as the public key\");\n }\n \n \n-bool ECDH::IsKeyValidForCurve(const BIGNUM* private_key) {\n-  CHECK_NE(group_, nullptr);\n-  CHECK_NE(private_key, nullptr);\n+bool ECDH::IsKeyValidForCurve(const BignumPointer& private_key) {\n+  CHECK(group_);\n+  CHECK(private_key);\n   // Private keys must be in the range [1, n-1].\n   // Ref: Section 3.2.1 - http://www.secg.org/sec1-v2.pdf\n-  if (BN_cmp(private_key, BN_value_one()) < 0) {\n+  if (BN_cmp(private_key.get(), BN_value_one()) < 0) {\n     return false;\n   }\n-  BIGNUM* order = BN_new();\n-  CHECK_NE(order, nullptr);\n-  bool result = EC_GROUP_get_order(group_, order, nullptr) &&\n-                BN_cmp(private_key, order) < 0;\n-  BN_free(order);\n-  return result;\n+  BignumPointer order(BN_new());\n+  CHECK(order);\n+  return EC_GROUP_get_order(group_, order.get(), nullptr) &&\n+         BN_cmp(private_key.get(), order.get()) < 0;\n }\n \n \n bool ECDH::IsKeyPairValid() {\n   MarkPopErrorOnReturn mark_pop_error_on_return;\n   USE(&mark_pop_error_on_return);\n-  return 1 == EC_KEY_check_key(key_);\n+  return 1 == EC_KEY_check_key(key_.get());\n }\n \n \n@@ -4688,36 +4558,17 @@ class PBKDF2Request : public AsyncWrap {\n   PBKDF2Request(Environment* env,\n                 Local<Object> object,\n                 const EVP_MD* digest,\n-                int passlen,\n-                char* pass,\n-                int saltlen,\n-                char* salt,\n-                int iter,\n-                int keylen)\n+                MallocedBuffer<char>&& pass,\n+                MallocedBuffer<char>&& salt,\n+                int keylen,\n+                int iteration_count)\n       : AsyncWrap(env, object, AsyncWrap::PROVIDER_PBKDF2REQUEST),\n         digest_(digest),\n         success_(false),\n-        passlen_(passlen),\n-        pass_(pass),\n-        saltlen_(saltlen),\n-        salt_(salt),\n-        keylen_(keylen),\n-        key_(node::Malloc(keylen)),\n-        iter_(iter) {\n-  }\n-\n-  ~PBKDF2Request() override {\n-    free(pass_);\n-    pass_ = nullptr;\n-    passlen_ = 0;\n-\n-    free(salt_);\n-    salt_ = nullptr;\n-    saltlen_ = 0;\n-\n-    free(key_);\n-    key_ = nullptr;\n-    keylen_ = 0;\n+        pass_(std::move(pass)),\n+        salt_(std::move(salt)),\n+        key_(keylen),\n+        iteration_count_(iteration_count) {\n   }\n \n   uv_work_t* work_req() {\n@@ -4737,23 +4588,23 @@ class PBKDF2Request : public AsyncWrap {\n   uv_work_t work_req_;\n   const EVP_MD* digest_;\n   bool success_;\n-  int passlen_;\n-  char* pass_;\n-  int saltlen_;\n-  char* salt_;\n-  int keylen_;\n-  char* key_;\n-  int iter_;\n+  MallocedBuffer<char> pass_;\n+  MallocedBuffer<char> salt_;\n+  MallocedBuffer<char> key_;\n+  int iteration_count_;\n };\n \n \n void PBKDF2Request::Work() {\n   success_ =\n       PKCS5_PBKDF2_HMAC(\n-          pass_, passlen_, reinterpret_cast<unsigned char*>(salt_), saltlen_,\n-          iter_, digest_, keylen_, reinterpret_cast<unsigned char*>(key_));\n-  OPENSSL_cleanse(pass_, passlen_);\n-  OPENSSL_cleanse(salt_, saltlen_);\n+          pass_.data, pass_.size,\n+          reinterpret_cast<unsigned char*>(salt_.data), salt_.size,\n+          iteration_count_, digest_,\n+          key_.size,\n+          reinterpret_cast<unsigned char*>(key_.data));\n+  OPENSSL_cleanse(pass_.data, pass_.size);\n+  OPENSSL_cleanse(salt_.data, salt_.size);\n }\n \n \n@@ -4766,9 +4617,8 @@ void PBKDF2Request::Work(uv_work_t* work_req) {\n void PBKDF2Request::After(Local<Value> (*argv)[2]) {\n   if (success_) {\n     (*argv)[0] = Null(env()->isolate());\n-    (*argv)[1] = Buffer::New(env(), key_, keylen_).ToLocalChecked();\n-    key_ = nullptr;\n-    keylen_ = 0;\n+    (*argv)[1] = Buffer::New(env(), key_.release(), key_.size)\n+        .ToLocalChecked();\n   } else {\n     (*argv)[0] = Exception::Error(env()->pbkdf2_error_string());\n     (*argv)[1] = Undefined(env()->isolate());\n@@ -4797,37 +4647,27 @@ void PBKDF2(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n   const EVP_MD* digest = nullptr;\n-  char* pass = nullptr;\n-  char* salt = nullptr;\n-  int passlen = -1;\n-  int saltlen = -1;\n-  double raw_keylen = -1;\n   int keylen = -1;\n-  int iter = -1;\n+  int iteration_count = -1;\n   Local<Object> obj;\n \n-  passlen = Buffer::Length(args[0]);\n+  int passlen = Buffer::Length(args[0]);\n \n-  pass = node::Malloc(passlen);\n-  memcpy(pass, Buffer::Data(args[0]), passlen);\n+  MallocedBuffer<char> pass(passlen);\n+  memcpy(pass.data, Buffer::Data(args[0]), passlen);\n \n-  saltlen = Buffer::Length(args[1]);\n+  int saltlen = Buffer::Length(args[1]);\n \n-  salt = node::Malloc(saltlen);\n-  memcpy(salt, Buffer::Data(args[1]), saltlen);\n+  MallocedBuffer<char> salt(saltlen);\n+  memcpy(salt.data, Buffer::Data(args[1]), saltlen);\n \n-  iter = args[2]->Int32Value();\n-\n-  raw_keylen = args[3]->NumberValue();\n-\n-  keylen = static_cast<int>(raw_keylen);\n+  iteration_count = args[2]->Int32Value(env->context()).FromJust();\n+  keylen = args[3]->IntegerValue(env->context()).FromJust();\n \n   if (args[4]->IsString()) {\n     node::Utf8Value digest_name(env->isolate(), args[4]);\n     digest = EVP_get_digestbyname(*digest_name);\n     if (digest == nullptr) {\n-      free(salt);\n-      free(pass);\n       args.GetReturnValue().Set(-1);\n       return;\n     }\n@@ -4840,8 +4680,11 @@ void PBKDF2(const FunctionCallbackInfo<Value>& args) {\n   obj = env->pbkdf2_constructor_template()->\n       NewInstance(env->context()).ToLocalChecked();\n   std::unique_ptr<PBKDF2Request> req(\n-      new PBKDF2Request(env, obj, digest, passlen, pass, saltlen, salt, iter,\n-                        keylen));\n+      new PBKDF2Request(env, obj, digest,\n+                        std::move(pass),\n+                        std::move(salt),\n+                        keylen,\n+                        iteration_count));\n \n   if (args[5]->IsFunction()) {\n     obj->Set(env->context(), env->ondone_string(), args[5]).FromJust();\n@@ -5084,14 +4927,14 @@ void RandomBytesBuffer(const FunctionCallbackInfo<Value>& args) {\n void GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n-  SSL_CTX* ctx = SSL_CTX_new(TLS_method());\n-  CHECK_NE(ctx, nullptr);\n+  SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));\n+  CHECK(ctx);\n \n-  SSL* ssl = SSL_new(ctx);\n-  CHECK_NE(ssl, nullptr);\n+  SSLPointer ssl(SSL_new(ctx.get()));\n+  CHECK(ssl);\n \n   Local<Array> arr = Array::New(env->isolate());\n-  STACK_OF(SSL_CIPHER)* ciphers = SSL_get_ciphers(ssl);\n+  STACK_OF(SSL_CIPHER)* ciphers = SSL_get_ciphers(ssl.get());\n \n   for (int i = 0; i < sk_SSL_CIPHER_num(ciphers); ++i) {\n     const SSL_CIPHER* cipher = sk_SSL_CIPHER_value(ciphers, i);\n@@ -5101,9 +4944,6 @@ void GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {\n                            SSL_CIPHER_get_name(cipher))).FromJust();\n   }\n \n-  SSL_free(ssl);\n-  SSL_CTX_free(ctx);\n-\n   args.GetReturnValue().Set(arr);\n }\n \n@@ -5154,50 +4994,34 @@ void GetCurves(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   const size_t num_curves = EC_get_builtin_curves(nullptr, 0);\n   Local<Array> arr = Array::New(env->isolate(), num_curves);\n-  EC_builtin_curve* curves;\n \n   if (num_curves) {\n-    curves = node::Malloc<EC_builtin_curve>(num_curves);\n+    std::vector<EC_builtin_curve> curves(num_curves);\n \n-    if (EC_get_builtin_curves(curves, num_curves)) {\n+    if (EC_get_builtin_curves(curves.data(), num_curves)) {\n       for (size_t i = 0; i < num_curves; i++) {\n         arr->Set(env->context(),\n                  i,\n                  OneByteString(env->isolate(),\n                                OBJ_nid2sn(curves[i].nid))).FromJust();\n       }\n     }\n-\n-    free(curves);\n   }\n \n   args.GetReturnValue().Set(arr);\n }\n \n \n bool VerifySpkac(const char* data, unsigned int len) {\n-  bool verify_result = false;\n-  EVP_PKEY* pkey = nullptr;\n-  NETSCAPE_SPKI* spki = nullptr;\n-\n-  spki = NETSCAPE_SPKI_b64_decode(data, len);\n-  if (spki == nullptr)\n-    goto exit;\n-\n-  pkey = X509_PUBKEY_get(spki->spkac->pubkey);\n-  if (pkey == nullptr)\n-    goto exit;\n-\n-  verify_result = NETSCAPE_SPKI_verify(spki, pkey) > 0;\n-\n- exit:\n-  if (pkey != nullptr)\n-    EVP_PKEY_free(pkey);\n+  NetscapeSPKIPointer spki(NETSCAPE_SPKI_b64_decode(data, len));\n+  if (!spki)\n+    return false;\n \n-  if (spki != nullptr)\n-    NETSCAPE_SPKI_free(spki);\n+  EVPKeyPointer pkey(X509_PUBKEY_get(spki->spkac->pubkey));\n+  if (!pkey)\n+    return false;\n \n-  return verify_result;\n+  return NETSCAPE_SPKI_verify(spki.get(), pkey.get()) > 0;\n }\n \n \n@@ -5219,41 +5043,29 @@ void VerifySpkac(const FunctionCallbackInfo<Value>& args) {\n \n char* ExportPublicKey(const char* data, int len, size_t* size) {\n   char* buf = nullptr;\n-  EVP_PKEY* pkey = nullptr;\n-  NETSCAPE_SPKI* spki = nullptr;\n \n-  BIO* bio = BIO_new(BIO_s_mem());\n-  if (bio == nullptr)\n-    goto exit;\n+  BIOPointer bio(BIO_new(BIO_s_mem()));\n+  if (!bio)\n+    return nullptr;\n \n-  spki = NETSCAPE_SPKI_b64_decode(data, len);\n-  if (spki == nullptr)\n-    goto exit;\n+  NetscapeSPKIPointer spki(NETSCAPE_SPKI_b64_decode(data, len));\n+  if (!spki)\n+    return nullptr;\n \n-  pkey = NETSCAPE_SPKI_get_pubkey(spki);\n-  if (pkey == nullptr)\n-    goto exit;\n+  EVPKeyPointer pkey(NETSCAPE_SPKI_get_pubkey(spki.get()));\n+  if (!pkey)\n+    return nullptr;\n \n-  if (PEM_write_bio_PUBKEY(bio, pkey) <= 0)\n-    goto exit;\n+  if (PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0)\n+    return nullptr;\n \n   BUF_MEM* ptr;\n-  BIO_get_mem_ptr(bio, &ptr);\n+  BIO_get_mem_ptr(bio.get(), &ptr);\n \n   *size = ptr->length;\n   buf = Malloc(*size);\n   memcpy(buf, ptr->data, *size);\n \n- exit:\n-  if (pkey != nullptr)\n-    EVP_PKEY_free(pkey);\n-\n-  if (spki != nullptr)\n-    NETSCAPE_SPKI_free(spki);\n-\n-  if (bio != nullptr)\n-    BIO_free_all(bio);\n-\n   return buf;\n }\n \n@@ -5278,19 +5090,15 @@ void ExportPublicKey(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-const char* ExportChallenge(const char* data, int len) {\n-  NETSCAPE_SPKI* sp = nullptr;\n-\n-  sp = NETSCAPE_SPKI_b64_decode(data, len);\n-  if (sp == nullptr)\n+OpenSSLBuffer ExportChallenge(const char* data, int len) {\n+  NetscapeSPKIPointer sp(NETSCAPE_SPKI_b64_decode(data, len));\n+  if (!sp)\n     return nullptr;\n \n   unsigned char* buf = nullptr;\n   ASN1_STRING_to_UTF8(&buf, sp->spkac->challenge);\n \n-  NETSCAPE_SPKI_free(sp);\n-\n-  return reinterpret_cast<const char*>(buf);\n+  return OpenSSLBuffer(reinterpret_cast<char*>(buf));\n }\n \n \n@@ -5304,13 +5112,12 @@ void ExportChallenge(const FunctionCallbackInfo<Value>& args) {\n   char* data = Buffer::Data(args[0]);\n   CHECK_NE(data, nullptr);\n \n-  const char* cert = ExportChallenge(data, len);\n-  if (cert == nullptr)\n+  OpenSSLBuffer cert = ExportChallenge(data, len);\n+  if (!cert)\n     return args.GetReturnValue().SetEmptyString();\n \n-  Local<Value> outString = Encode(env->isolate(), cert, strlen(cert), BUFFER);\n-\n-  OPENSSL_free(const_cast<char*>(cert));\n+  Local<Value> outString =\n+      Encode(env->isolate(), cert.get(), strlen(cert.get()), BUFFER);\n \n   args.GetReturnValue().Set(outString);\n }\n@@ -5332,33 +5139,32 @@ void ConvertKey(const FunctionCallbackInfo<Value>& args) {\n   if (nid == NID_undef)\n     return env->ThrowTypeError(\"Invalid ECDH curve name\");\n \n-  EC_GROUP* group = EC_GROUP_new_by_curve_name(nid);\n+  ECGroupPointer group(\n+      EC_GROUP_new_by_curve_name(nid));\n   if (group == nullptr)\n     return env->ThrowError(\"Failed to get EC_GROUP\");\n \n-  EC_POINT* pub = ECDH::BufferToPoint(env,\n-                                      group,\n-                                      Buffer::Data(args[0]),\n-                                      len);\n-\n-  std::shared_ptr<void> cleanup(nullptr, [group, pub] (...) {\n-    EC_GROUP_free(group);\n-    EC_POINT_free(pub);\n-  });\n+  ECPointPointer pub(\n+      ECDH::BufferToPoint(env,\n+                          group.get(),\n+                          Buffer::Data(args[0]),\n+                          len));\n \n   if (pub == nullptr)\n     return env->ThrowError(\"Failed to convert Buffer to EC_POINT\");\n \n   point_conversion_form_t form =\n       static_cast<point_conversion_form_t>(args[2]->Uint32Value());\n \n-  int size = EC_POINT_point2oct(group, pub, form, nullptr, 0, nullptr);\n+  int size = EC_POINT_point2oct(\n+      group.get(), pub.get(), form, nullptr, 0, nullptr);\n+\n   if (size == 0)\n     return env->ThrowError(\"Failed to get public key length\");\n \n   unsigned char* out = node::Malloc<unsigned char>(size);\n \n-  int r = EC_POINT_point2oct(group, pub, form, out, size, nullptr);\n+  int r = EC_POINT_point2oct(group.get(), pub.get(), form, out, size, nullptr);\n   if (r != size) {\n     free(out);\n     return env->ThrowError(\"Failed to get public key\");"
        },
        {
            "sha": "ee933ede1f83fbfab2da81344d6c3427842745b9",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 55,
            "deletions": 67,
            "changes": 122,
            "blob_url": "https://github.com/nodejs/node/blob/d7cba76856e80108edb47b2e4c50a2c5fe5e1427/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/d7cba76856e80108edb47b2e4c50a2c5fe5e1427/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=d7cba76856e80108edb47b2e4c50a2c5fe5e1427",
            "patch": "@@ -75,6 +75,32 @@ struct MarkPopErrorOnReturn {\n   ~MarkPopErrorOnReturn() { ERR_pop_to_mark(); }\n };\n \n+template <typename T, void (*function)(T*)>\n+struct FunctionDeleter {\n+  void operator()(T* pointer) const { function(pointer); }\n+  typedef std::unique_ptr<T, FunctionDeleter> Pointer;\n+};\n+\n+template <typename T, void (*function)(T*)>\n+using DeleteFnPtr = typename FunctionDeleter<T, function>::Pointer;\n+\n+// Define smart pointers for the most commonly used OpenSSL types:\n+using X509Pointer = DeleteFnPtr<X509, X509_free>;\n+using BIOPointer = DeleteFnPtr<BIO, BIO_free_all>;\n+using SSLCtxPointer = DeleteFnPtr<SSL_CTX, SSL_CTX_free>;\n+using SSLSessionPointer = DeleteFnPtr<SSL_SESSION, SSL_SESSION_free>;\n+using SSLPointer = DeleteFnPtr<SSL, SSL_free>;\n+using EVPKeyPointer = DeleteFnPtr<EVP_PKEY, EVP_PKEY_free>;\n+using EVPKeyCtxPointer = DeleteFnPtr<EVP_PKEY_CTX, EVP_PKEY_CTX_free>;\n+using EVPMDPointer = DeleteFnPtr<EVP_MD_CTX, EVP_MD_CTX_free>;\n+using RSAPointer = DeleteFnPtr<RSA, RSA_free>;\n+using BignumPointer = DeleteFnPtr<BIGNUM, BN_free>;\n+using NetscapeSPKIPointer = DeleteFnPtr<NETSCAPE_SPKI, NETSCAPE_SPKI_free>;\n+using ECGroupPointer = DeleteFnPtr<EC_GROUP, EC_GROUP_free>;\n+using ECPointPointer = DeleteFnPtr<EC_POINT, EC_POINT_free>;\n+using ECKeyPointer = DeleteFnPtr<EC_KEY, EC_KEY_free>;\n+using DHPointer = DeleteFnPtr<DH, DH_free>;\n+\n enum CheckResult {\n   CHECK_CERT_REVOKED = 0,\n   CHECK_OK = 1\n@@ -87,14 +113,14 @@ extern void UseExtraCaCerts(const std::string& file);\n class SecureContext : public BaseObject {\n  public:\n   ~SecureContext() override {\n-    FreeCTXMem();\n+    Reset();\n   }\n \n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n \n-  SSL_CTX* ctx_;\n-  X509* cert_;\n-  X509* issuer_;\n+  SSLCtxPointer ctx_;\n+  X509Pointer cert_;\n+  X509Pointer issuer_;\n #ifndef OPENSSL_NO_ENGINE\n   bool client_cert_engine_provided_ = false;\n #endif  // !OPENSSL_NO_ENGINE\n@@ -171,28 +197,16 @@ class SecureContext : public BaseObject {\n #endif\n \n   SecureContext(Environment* env, v8::Local<v8::Object> wrap)\n-      : BaseObject(env, wrap),\n-        ctx_(nullptr),\n-        cert_(nullptr),\n-        issuer_(nullptr) {\n+      : BaseObject(env, wrap) {\n     MakeWeak();\n     env->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);\n   }\n \n-  void FreeCTXMem() {\n-    if (!ctx_) {\n-      return;\n-    }\n-\n+  inline void Reset() {\n     env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);\n-    SSL_CTX_free(ctx_);\n-    if (cert_ != nullptr)\n-      X509_free(cert_);\n-    if (issuer_ != nullptr)\n-      X509_free(issuer_);\n-    ctx_ = nullptr;\n-    cert_ = nullptr;\n-    issuer_ = nullptr;\n+    ctx_.reset();\n+    cert_.reset();\n+    issuer_.reset();\n   }\n };\n \n@@ -215,20 +229,15 @@ class SSLWrap {\n         cert_cb_(nullptr),\n         cert_cb_arg_(nullptr),\n         cert_cb_running_(false) {\n-    ssl_ = SSL_new(sc->ctx_);\n+    ssl_.reset(SSL_new(sc->ctx_.get()));\n+    CHECK(ssl_);\n     env_->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);\n-    CHECK_NE(ssl_, nullptr);\n   }\n \n   virtual ~SSLWrap() {\n     DestroySSL();\n-    if (next_sess_ != nullptr) {\n-      SSL_SESSION_free(next_sess_);\n-      next_sess_ = nullptr;\n-    }\n   }\n \n-  inline SSL* ssl() const { return ssl_; }\n   inline void enable_session_callbacks() { session_callbacks_ = true; }\n   inline bool is_server() const { return kind_ == kServer; }\n   inline bool is_client() const { return kind_ == kClient; }\n@@ -319,8 +328,8 @@ class SSLWrap {\n \n   Environment* const env_;\n   Kind kind_;\n-  SSL_SESSION* next_sess_;\n-  SSL* ssl_;\n+  SSLSessionPointer next_sess_;\n+  SSLPointer ssl_;\n   bool session_callbacks_;\n   bool new_session_wait_;\n \n@@ -344,10 +353,6 @@ class SSLWrap {\n \n class CipherBase : public BaseObject {\n  public:\n-  ~CipherBase() override {\n-    EVP_CIPHER_CTX_free(ctx_);\n-  }\n-\n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n \n  protected:\n@@ -407,7 +412,7 @@ class CipherBase : public BaseObject {\n   }\n \n  private:\n-  EVP_CIPHER_CTX* ctx_;\n+  DeleteFnPtr<EVP_CIPHER_CTX, EVP_CIPHER_CTX_free> ctx_;\n   const CipherKind kind_;\n   bool auth_tag_set_;\n   unsigned int auth_tag_len_;\n@@ -418,8 +423,6 @@ class CipherBase : public BaseObject {\n \n class Hmac : public BaseObject {\n  public:\n-  ~Hmac() override;\n-\n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n \n  protected:\n@@ -438,13 +441,11 @@ class Hmac : public BaseObject {\n   }\n \n  private:\n-  HMAC_CTX* ctx_;\n+  DeleteFnPtr<HMAC_CTX, HMAC_CTX_free> ctx_;\n };\n \n class Hash : public BaseObject {\n  public:\n-  ~Hash() override;\n-\n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n \n   bool HashInit(const char* hash_type);\n@@ -463,7 +464,7 @@ class Hash : public BaseObject {\n   }\n \n  private:\n-  EVP_MD_CTX* mdctx_;\n+  EVPMDPointer mdctx_;\n   bool finalized_;\n };\n \n@@ -480,19 +481,16 @@ class SignBase : public BaseObject {\n   } Error;\n \n   SignBase(Environment* env, v8::Local<v8::Object> wrap)\n-      : BaseObject(env, wrap),\n-        mdctx_(nullptr) {\n+      : BaseObject(env, wrap) {\n   }\n \n-  ~SignBase() override;\n-\n   Error Init(const char* sign_type);\n   Error Update(const char* data, int len);\n \n  protected:\n   void CheckThrow(Error error);\n \n-  EVP_MD_CTX* mdctx_;\n+  EVPMDPointer mdctx_;\n };\n \n class Sign : public SignBase {\n@@ -573,12 +571,6 @@ class PublicKeyCipher {\n \n class DiffieHellman : public BaseObject {\n  public:\n-  ~DiffieHellman() override {\n-    if (dh != nullptr) {\n-      DH_free(dh);\n-    }\n-  }\n-\n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n \n   bool Init(int primeLength, int g);\n@@ -603,8 +595,7 @@ class DiffieHellman : public BaseObject {\n   DiffieHellman(Environment* env, v8::Local<v8::Object> wrap)\n       : BaseObject(env, wrap),\n         initialised_(false),\n-        verifyError_(0),\n-        dh(nullptr) {\n+        verifyError_(0) {\n     MakeWeak();\n   }\n \n@@ -618,29 +609,26 @@ class DiffieHellman : public BaseObject {\n \n   bool initialised_;\n   int verifyError_;\n-  DH* dh;\n+  DHPointer dh_;\n };\n \n class ECDH : public BaseObject {\n  public:\n   ~ECDH() override {\n-    if (key_ != nullptr)\n-      EC_KEY_free(key_);\n-    key_ = nullptr;\n     group_ = nullptr;\n   }\n \n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n-  static EC_POINT* BufferToPoint(Environment* env,\n-                                 const EC_GROUP* group,\n-                                 char* data,\n-                                 size_t len);\n+  static ECPointPointer BufferToPoint(Environment* env,\n+                                      const EC_GROUP* group,\n+                                      char* data,\n+                                      size_t len);\n \n  protected:\n-  ECDH(Environment* env, v8::Local<v8::Object> wrap, EC_KEY* key)\n+  ECDH(Environment* env, v8::Local<v8::Object> wrap, ECKeyPointer&& key)\n       : BaseObject(env, wrap),\n-        key_(key),\n-        group_(EC_KEY_get0_group(key_)) {\n+        key_(std::move(key)),\n+        group_(EC_KEY_get0_group(key_.get())) {\n     MakeWeak();\n     CHECK_NE(group_, nullptr);\n   }\n@@ -654,9 +642,9 @@ class ECDH : public BaseObject {\n   static void SetPublicKey(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n   bool IsKeyPairValid();\n-  bool IsKeyValidForCurve(const BIGNUM* private_key);\n+  bool IsKeyValidForCurve(const BignumPointer& private_key);\n \n-  EC_KEY* key_;\n+  ECKeyPointer key_;\n   const EC_GROUP* group_;\n };\n "
        },
        {
            "sha": "5d84a10da2e0b1b8cfa1910229ca6e601aba1ab7",
            "filename": "src/tls_wrap.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 22,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/d7cba76856e80108edb47b2e4c50a2c5fe5e1427/src%2Ftls_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d7cba76856e80108edb47b2e4c50a2c5fe5e1427/src%2Ftls_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.cc?ref=d7cba76856e80108edb47b2e4c50a2c5fe5e1427",
            "patch": "@@ -74,8 +74,10 @@ TLSWrap::TLSWrap(Environment* env,\n   CHECK_NE(sc, nullptr);\n \n   // We've our own session callbacks\n-  SSL_CTX_sess_set_get_cb(sc_->ctx_, SSLWrap<TLSWrap>::GetSessionCallback);\n-  SSL_CTX_sess_set_new_cb(sc_->ctx_, SSLWrap<TLSWrap>::NewSessionCallback);\n+  SSL_CTX_sess_set_get_cb(sc_->ctx_.get(),\n+                          SSLWrap<TLSWrap>::GetSessionCallback);\n+  SSL_CTX_sess_set_new_cb(sc_->ctx_.get(),\n+                          SSLWrap<TLSWrap>::NewSessionCallback);\n \n   stream->PushStreamListener(this);\n \n@@ -116,35 +118,36 @@ void TLSWrap::InitSSL() {\n   crypto::NodeBIO::FromBIO(enc_in_)->AssignEnvironment(env());\n   crypto::NodeBIO::FromBIO(enc_out_)->AssignEnvironment(env());\n \n-  SSL_set_bio(ssl_, enc_in_, enc_out_);\n+  SSL_set_bio(ssl_.get(), enc_in_, enc_out_);\n \n   // NOTE: This could be overridden in SetVerifyMode\n-  SSL_set_verify(ssl_, SSL_VERIFY_NONE, crypto::VerifyCallback);\n+  SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, crypto::VerifyCallback);\n \n #ifdef SSL_MODE_RELEASE_BUFFERS\n-  long mode = SSL_get_mode(ssl_);  // NOLINT(runtime/int)\n-  SSL_set_mode(ssl_, mode | SSL_MODE_RELEASE_BUFFERS);\n+  long mode = SSL_get_mode(ssl_.get());  // NOLINT(runtime/int)\n+  SSL_set_mode(ssl_.get(), mode | SSL_MODE_RELEASE_BUFFERS);\n #endif  // SSL_MODE_RELEASE_BUFFERS\n \n-  SSL_set_app_data(ssl_, this);\n-  SSL_set_info_callback(ssl_, SSLInfoCallback);\n+  SSL_set_app_data(ssl_.get(), this);\n+  SSL_set_info_callback(ssl_.get(), SSLInfoCallback);\n \n #ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n   if (is_server()) {\n-    SSL_CTX_set_tlsext_servername_callback(sc_->ctx_, SelectSNIContextCallback);\n+    SSL_CTX_set_tlsext_servername_callback(sc_->ctx_.get(),\n+                                           SelectSNIContextCallback);\n   }\n #endif  // SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n \n   ConfigureSecureContext(sc_);\n \n-  SSL_set_cert_cb(ssl_, SSLWrap<TLSWrap>::SSLCertCallback, this);\n+  SSL_set_cert_cb(ssl_.get(), SSLWrap<TLSWrap>::SSLCertCallback, this);\n \n   if (is_server()) {\n-    SSL_set_accept_state(ssl_);\n+    SSL_set_accept_state(ssl_.get());\n   } else if (is_client()) {\n     // Enough space for server response (hello, cert)\n     crypto::NodeBIO::FromBIO(enc_in_)->set_initial(kInitialClientBufferLength);\n-    SSL_set_connect_state(ssl_);\n+    SSL_set_connect_state(ssl_.get());\n   } else {\n     // Unexpected\n     ABORT();\n@@ -342,7 +345,7 @@ Local<Value> TLSWrap::GetSSLError(int status, int* err, std::string* msg) {\n   if (ssl_ == nullptr)\n     return Local<Value>();\n \n-  *err = SSL_get_error(ssl_, status);\n+  *err = SSL_get_error(ssl_.get(), status);\n   switch (*err) {\n     case SSL_ERROR_NONE:\n     case SSL_ERROR_WANT_READ:\n@@ -395,7 +398,7 @@ void TLSWrap::ClearOut() {\n   char out[kClearOutChunkSize];\n   int read;\n   for (;;) {\n-    read = SSL_read(ssl_, out, sizeof(out));\n+    read = SSL_read(ssl_.get(), out, sizeof(out));\n \n     if (read <= 0)\n       break;\n@@ -421,7 +424,7 @@ void TLSWrap::ClearOut() {\n     }\n   }\n \n-  int flags = SSL_get_shutdown(ssl_);\n+  int flags = SSL_get_shutdown(ssl_.get());\n   if (!eof_ && flags & SSL_RECEIVED_SHUTDOWN) {\n     eof_ = true;\n     EmitRead(UV_EOF);\n@@ -469,7 +472,7 @@ bool TLSWrap::ClearIn() {\n   for (i = 0; i < buffers.size(); ++i) {\n     size_t avail = buffers[i].len;\n     char* data = buffers[i].base;\n-    written = SSL_write(ssl_, data, avail);\n+    written = SSL_write(ssl_.get(), data, avail);\n     CHECK(written == -1 || written == static_cast<int>(avail));\n     if (written == -1)\n       break;\n@@ -610,7 +613,7 @@ int TLSWrap::DoWrite(WriteWrap* w,\n \n   int written = 0;\n   for (i = 0; i < count; i++) {\n-    written = SSL_write(ssl_, bufs[i].base, bufs[i].len);\n+    written = SSL_write(ssl_.get(), bufs[i].base, bufs[i].len);\n     CHECK(written == -1 || written == static_cast<int>(bufs[i].len));\n     if (written == -1)\n       break;\n@@ -690,8 +693,8 @@ ShutdownWrap* TLSWrap::CreateShutdownWrap(Local<Object> req_wrap_object) {\n int TLSWrap::DoShutdown(ShutdownWrap* req_wrap) {\n   crypto::MarkPopErrorOnReturn mark_pop_error_on_return;\n \n-  if (ssl_ != nullptr && SSL_shutdown(ssl_) == 0)\n-    SSL_shutdown(ssl_);\n+  if (ssl_ && SSL_shutdown(ssl_.get()) == 0)\n+    SSL_shutdown(ssl_.get());\n \n   shutdown_ = true;\n   EncOut();\n@@ -726,7 +729,7 @@ void TLSWrap::SetVerifyMode(const FunctionCallbackInfo<Value>& args) {\n   }\n \n   // Always allow a connection. We'll reject in javascript.\n-  SSL_set_verify(wrap->ssl_, verify_mode, crypto::VerifyCallback);\n+  SSL_set_verify(wrap->ssl_.get(), verify_mode, crypto::VerifyCallback);\n }\n \n \n@@ -783,7 +786,7 @@ void TLSWrap::GetServername(const FunctionCallbackInfo<Value>& args) {\n \n   CHECK_NE(wrap->ssl_, nullptr);\n \n-  const char* servername = SSL_get_servername(wrap->ssl_,\n+  const char* servername = SSL_get_servername(wrap->ssl_.get(),\n                                               TLSEXT_NAMETYPE_host_name);\n   if (servername != nullptr) {\n     args.GetReturnValue().Set(OneByteString(env->isolate(), servername));\n@@ -808,7 +811,7 @@ void TLSWrap::SetServername(const FunctionCallbackInfo<Value>& args) {\n \n #ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n   node::Utf8Value servername(env->isolate(), args[0].As<String>());\n-  SSL_set_tlsext_host_name(wrap->ssl_, *servername);\n+  SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);\n #endif  // SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n }\n "
        },
        {
            "sha": "7a1c6c109fdbffd5b7b78599aec244c325e19e8f",
            "filename": "src/util.h",
            "status": "modified",
            "additions": 31,
            "deletions": 1,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/d7cba76856e80108edb47b2e4c50a2c5fe5e1427/src%2Futil.h",
            "raw_url": "https://github.com/nodejs/node/raw/d7cba76856e80108edb47b2e4c50a2c5fe5e1427/src%2Futil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.h?ref=d7cba76856e80108edb47b2e4c50a2c5fe5e1427",
            "patch": "@@ -410,7 +410,6 @@ class BufferValue : public MaybeStackBuffer<char> {\n // Use this when a variable or parameter is unused in order to explicitly\n // silence a compiler warning about that.\n template <typename T> inline void USE(T&&) {}\n-}  // namespace node\n \n // Run a function when exiting the current scope.\n struct OnScopeLeave {\n@@ -420,6 +419,37 @@ struct OnScopeLeave {\n   ~OnScopeLeave() { fn_(); }\n };\n \n+// Simple RAII wrapper for contiguous data that uses malloc()/free().\n+template<typename T>\n+struct MallocedBuffer {\n+  T* data;\n+  size_t size;\n+\n+  T* release() {\n+    T* ret = data;\n+    data = nullptr;\n+    return ret;\n+  }\n+\n+  MallocedBuffer() : data(nullptr) {}\n+  explicit MallocedBuffer(size_t size) : data(Malloc<T>(size)), size(size) {}\n+  MallocedBuffer(MallocedBuffer&& other) : data(other.data), size(other.size) {\n+    other.data = nullptr;\n+  }\n+  MallocedBuffer& operator=(MallocedBuffer&& other) {\n+    this->~MallocedBuffer();\n+    return *new(this) MallocedBuffer(other);\n+  }\n+  ~MallocedBuffer() {\n+    free(data);\n+  }\n+  MallocedBuffer(const MallocedBuffer&) = delete;\n+  MallocedBuffer& operator=(const MallocedBuffer&) = delete;\n+};\n+\n+}  // namespace node\n+\n+\n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n \n #endif  // SRC_UTIL_H_"
        }
    ],
    "stats": {
        "total": 1623,
        "additions": 725,
        "deletions": 898
    }
}