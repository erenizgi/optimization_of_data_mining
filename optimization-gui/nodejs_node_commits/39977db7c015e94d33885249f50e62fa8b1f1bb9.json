{
    "author": "unknown",
    "message": "inspector: split main thread interface from transport\n\nWorkers debugging will require interfacing between the \"main\" inspector\nand per-worker isolate inspectors. This is consistent with what WS\ninterface does. This change is a refactoring change and does not change\nthe functionality.\n\nPR-URL: https://github.com/nodejs/node/pull/21182\nFixes: https://github.com/nodejs/node/issues/21725\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "39977db7c015e94d33885249f50e62fa8b1f1bb9",
    "files": [
        {
            "sha": "d3bebba8cec4f1b2555d6f26b8c9a0279e433a3f",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -493,12 +493,14 @@\n             'src/inspector_js_api.cc',\n             'src/inspector_socket.cc',\n             'src/inspector_socket_server.cc',\n-            'src/inspector/tracing_agent.cc',\n+            'src/inspector/main_thread_interface.cc',\n             'src/inspector/node_string.cc',\n+            'src/inspector/tracing_agent.cc',\n             'src/inspector_agent.h',\n             'src/inspector_io.h',\n             'src/inspector_socket.h',\n             'src/inspector_socket_server.h',\n+            'src/inspector/main_thread_interface.h',\n             'src/inspector/node_string.h',\n             'src/inspector/tracing_agent.h',\n             '<@(node_inspector_generated_sources)'"
        },
        {
            "sha": "da43c95bea5fe318fd968469d6701e693ed06cfe",
            "filename": "src/inspector/main_thread_interface.cc",
            "status": "added",
            "additions": 317,
            "deletions": 0,
            "changes": 317,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector%2Fmain_thread_interface.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector%2Fmain_thread_interface.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fmain_thread_interface.cc?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -0,0 +1,317 @@\n+#include \"main_thread_interface.h\"\n+\n+#include \"node_mutex.h\"\n+#include \"v8-inspector.h\"\n+\n+#include <unicode/unistr.h>\n+\n+namespace node {\n+namespace inspector {\n+namespace {\n+\n+using v8_inspector::StringView;\n+using v8_inspector::StringBuffer;\n+\n+template <typename T>\n+class DeleteRequest : public Request {\n+ public:\n+  explicit DeleteRequest(T* object) : object_(object) {}\n+  void Call() override {\n+    delete object_;\n+  }\n+\n+ private:\n+  T* object_;\n+};\n+\n+template <typename Target, typename Arg>\n+class SingleArgumentFunctionCall : public Request {\n+ public:\n+  using Fn = void (Target::*)(Arg);\n+\n+  SingleArgumentFunctionCall(Target* target, Fn fn, Arg argument)\n+                             : target_(target),\n+                               fn_(fn),\n+                               arg_(std::move(argument)) {}\n+\n+  void Call() override {\n+    Apply(target_, fn_, std::move(arg_));\n+  }\n+\n+ private:\n+  template <typename Element>\n+  void Apply(Element* target, Fn fn, Arg arg) {\n+    (target->*fn)(std::move(arg));\n+  }\n+\n+  Target* target_;\n+  Fn fn_;\n+  Arg arg_;\n+};\n+\n+class PostMessageRequest : public Request {\n+ public:\n+  PostMessageRequest(InspectorSessionDelegate* delegate,\n+                     StringView message)\n+                     : delegate_(delegate),\n+                       message_(StringBuffer::create(message)) {}\n+\n+  void Call() override {\n+    delegate_->SendMessageToFrontend(message_->string());\n+  }\n+\n+ private:\n+  InspectorSessionDelegate* delegate_;\n+  std::unique_ptr<StringBuffer> message_;\n+};\n+\n+class DispatchMessagesTask : public v8::Task {\n+ public:\n+  explicit DispatchMessagesTask(MainThreadInterface* thread)\n+                                : thread_(thread) {}\n+\n+  void Run() override {\n+    thread_->DispatchMessages();\n+  }\n+\n+ private:\n+  MainThreadInterface* thread_;\n+};\n+\n+void DisposePairCallback(uv_handle_t* ref) {\n+  using AsyncAndInterface = std::pair<uv_async_t, MainThreadInterface*>;\n+  AsyncAndInterface* pair = node::ContainerOf(\n+      &AsyncAndInterface::first, reinterpret_cast<uv_async_t*>(ref));\n+  delete pair;\n+}\n+\n+template <typename T>\n+class AnotherThreadObjectReference {\n+ public:\n+  // We create it on whatever thread, just make sure it gets disposed on the\n+  // proper thread.\n+  AnotherThreadObjectReference(std::shared_ptr<MainThreadHandle> thread,\n+                               T* object)\n+                               : thread_(thread), object_(object) {\n+  }\n+  AnotherThreadObjectReference(AnotherThreadObjectReference&) = delete;\n+\n+  ~AnotherThreadObjectReference() {\n+    // Disappearing thread may cause a memory leak\n+    CHECK(thread_->Post(\n+        std::unique_ptr<DeleteRequest<T>>(new DeleteRequest<T>(object_))));\n+    object_ = nullptr;\n+  }\n+\n+  template <typename Fn, typename Arg>\n+  void Post(Fn fn, Arg argument) const {\n+    using R = SingleArgumentFunctionCall<T, Arg>;\n+    thread_->Post(std::unique_ptr<R>(new R(object_, fn, std::move(argument))));\n+  }\n+\n+  T* get() const {\n+    return object_;\n+  }\n+\n+ private:\n+  std::shared_ptr<MainThreadHandle> thread_;\n+  T* object_;\n+};\n+\n+class MainThreadSessionState {\n+ public:\n+  MainThreadSessionState(\n+      std::shared_ptr<MainThreadHandle> thread,\n+      bool prevent_shutdown) : thread_(thread),\n+                               prevent_shutdown_(prevent_shutdown) {}\n+\n+  void Connect(std::unique_ptr<InspectorSessionDelegate> delegate) {\n+    Agent* agent = thread_->GetInspectorAgent();\n+    if (agent != nullptr)\n+      session_ = agent->Connect(std::move(delegate), prevent_shutdown_);\n+  }\n+\n+  void Dispatch(std::unique_ptr<StringBuffer> message) {\n+    session_->Dispatch(message->string());\n+  }\n+\n+ private:\n+  std::shared_ptr<MainThreadHandle> thread_;\n+  bool prevent_shutdown_;\n+  std::unique_ptr<InspectorSession> session_;\n+};\n+\n+class CrossThreadInspectorSession : public InspectorSession {\n+ public:\n+  CrossThreadInspectorSession(\n+      int id,\n+      std::shared_ptr<MainThreadHandle> thread,\n+      std::unique_ptr<InspectorSessionDelegate> delegate,\n+      bool prevent_shutdown)\n+      : state_(thread, new MainThreadSessionState(thread, prevent_shutdown)) {\n+    state_.Post(&MainThreadSessionState::Connect, std::move(delegate));\n+  }\n+\n+  void Dispatch(const StringView& message) override {\n+    state_.Post(&MainThreadSessionState::Dispatch,\n+                StringBuffer::create(message));\n+  }\n+\n+ private:\n+  AnotherThreadObjectReference<MainThreadSessionState> state_;\n+};\n+\n+class ThreadSafeDelegate : public InspectorSessionDelegate {\n+ public:\n+  ThreadSafeDelegate(std::shared_ptr<MainThreadHandle> thread,\n+                     std::unique_ptr<InspectorSessionDelegate> delegate)\n+                     : thread_(thread), delegate_(thread, delegate.release()) {}\n+\n+  void SendMessageToFrontend(const v8_inspector::StringView& message) override {\n+    thread_->Post(std::unique_ptr<Request>(\n+        new PostMessageRequest(delegate_.get(), message)));\n+  }\n+\n+ private:\n+  std::shared_ptr<MainThreadHandle> thread_;\n+  AnotherThreadObjectReference<InspectorSessionDelegate> delegate_;\n+};\n+}  // namespace\n+\n+\n+MainThreadInterface::MainThreadInterface(Agent* agent, uv_loop_t* loop,\n+                                         v8::Isolate* isolate,\n+                                         v8::Platform* platform)\n+                                         : agent_(agent), isolate_(isolate),\n+                                           platform_(platform) {\n+  main_thread_request_.reset(new AsyncAndInterface(uv_async_t(), this));\n+  CHECK_EQ(0, uv_async_init(loop, &main_thread_request_->first,\n+                            DispatchMessagesAsyncCallback));\n+  // Inspector uv_async_t should not prevent main loop shutdown.\n+  uv_unref(reinterpret_cast<uv_handle_t*>(&main_thread_request_->first));\n+}\n+\n+MainThreadInterface::~MainThreadInterface() {\n+  if (handle_)\n+    handle_->Reset();\n+}\n+\n+// static\n+void MainThreadInterface::DispatchMessagesAsyncCallback(uv_async_t* async) {\n+  AsyncAndInterface* asyncAndInterface =\n+      node::ContainerOf(&AsyncAndInterface::first, async);\n+  asyncAndInterface->second->DispatchMessages();\n+}\n+\n+// static\n+void MainThreadInterface::CloseAsync(AsyncAndInterface* pair) {\n+  uv_close(reinterpret_cast<uv_handle_t*>(&pair->first), DisposePairCallback);\n+}\n+\n+void MainThreadInterface::Post(std::unique_ptr<Request> request) {\n+  Mutex::ScopedLock scoped_lock(requests_lock_);\n+  bool needs_notify = requests_.empty();\n+  requests_.push_back(std::move(request));\n+  if (needs_notify) {\n+    CHECK_EQ(0, uv_async_send(&main_thread_request_->first));\n+    if (isolate_ != nullptr && platform_ != nullptr) {\n+      platform_->CallOnForegroundThread(isolate_,\n+                                        new DispatchMessagesTask(this));\n+      isolate_->RequestInterrupt([](v8::Isolate* isolate, void* thread) {\n+        static_cast<MainThreadInterface*>(thread)->DispatchMessages();\n+      }, this);\n+    }\n+  }\n+  incoming_message_cond_.Broadcast(scoped_lock);\n+}\n+\n+bool MainThreadInterface::WaitForFrontendEvent() {\n+  // We allow DispatchMessages reentry as we enter the pause. This is important\n+  // to support debugging the code invoked by an inspector call, such\n+  // as Runtime.evaluate\n+  dispatching_messages_ = false;\n+  if (dispatching_message_queue_.empty()) {\n+    Mutex::ScopedLock scoped_lock(requests_lock_);\n+    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);\n+  }\n+  return true;\n+}\n+\n+void MainThreadInterface::DispatchMessages() {\n+  if (dispatching_messages_)\n+    return;\n+  dispatching_messages_ = true;\n+  bool had_messages = false;\n+  do {\n+    if (dispatching_message_queue_.empty()) {\n+      Mutex::ScopedLock scoped_lock(requests_lock_);\n+      requests_.swap(dispatching_message_queue_);\n+    }\n+    had_messages = !dispatching_message_queue_.empty();\n+    while (!dispatching_message_queue_.empty()) {\n+      MessageQueue::value_type task;\n+      std::swap(dispatching_message_queue_.front(), task);\n+      dispatching_message_queue_.pop_front();\n+      task->Call();\n+    }\n+  } while (had_messages);\n+  dispatching_messages_ = false;\n+}\n+\n+std::shared_ptr<MainThreadHandle> MainThreadInterface::GetHandle() {\n+  if (handle_ == nullptr)\n+    handle_ = std::make_shared<MainThreadHandle>(this);\n+  return handle_;\n+}\n+\n+std::unique_ptr<StringBuffer> Utf8ToStringView(const std::string& message) {\n+  icu::UnicodeString utf16 = icu::UnicodeString::fromUTF8(\n+      icu::StringPiece(message.data(), message.length()));\n+  StringView view(reinterpret_cast<const uint16_t*>(utf16.getBuffer()),\n+                  utf16.length());\n+  return StringBuffer::create(view);\n+}\n+\n+std::unique_ptr<InspectorSession> MainThreadHandle::Connect(\n+    std::unique_ptr<InspectorSessionDelegate> delegate,\n+    bool prevent_shutdown) {\n+  return std::unique_ptr<InspectorSession>(\n+      new CrossThreadInspectorSession(++next_session_id_,\n+                                      shared_from_this(),\n+                                      std::move(delegate),\n+                                      prevent_shutdown));\n+}\n+\n+bool MainThreadHandle::Post(std::unique_ptr<Request> request) {\n+  Mutex::ScopedLock scoped_lock(block_lock_);\n+  if (!main_thread_)\n+    return false;\n+  main_thread_->Post(std::move(request));\n+  return true;\n+}\n+\n+void MainThreadHandle::Reset() {\n+  Mutex::ScopedLock scoped_lock(block_lock_);\n+  main_thread_ = nullptr;\n+}\n+\n+Agent* MainThreadHandle::GetInspectorAgent() {\n+  Mutex::ScopedLock scoped_lock(block_lock_);\n+  if (main_thread_ == nullptr)\n+    return nullptr;\n+  return main_thread_->inspector_agent();\n+}\n+\n+std::unique_ptr<InspectorSessionDelegate>\n+MainThreadHandle::MakeThreadSafeDelegate(\n+    std::unique_ptr<InspectorSessionDelegate> delegate) {\n+  return std::unique_ptr<InspectorSessionDelegate>(\n+      new ThreadSafeDelegate(shared_from_this(), std::move(delegate)));\n+}\n+\n+bool MainThreadHandle::Expired() {\n+  Mutex::ScopedLock scoped_lock(block_lock_);\n+  return main_thread_ == nullptr;\n+}\n+}  // namespace inspector\n+}  // namespace node"
        },
        {
            "sha": "75df5ffe80904828868879702298b897c24f3cd6",
            "filename": "src/inspector/main_thread_interface.h",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector%2Fmain_thread_interface.h",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector%2Fmain_thread_interface.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fmain_thread_interface.h?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -0,0 +1,99 @@\n+#ifndef SRC_INSPECTOR_MAIN_THREAD_INTERFACE_H_\n+#define SRC_INSPECTOR_MAIN_THREAD_INTERFACE_H_\n+\n+#if !HAVE_INSPECTOR\n+#error(\"This header can only be used when inspector is enabled\")\n+#endif\n+\n+#include \"env.h\"\n+#include \"inspector_agent.h\"\n+#include \"node_mutex.h\"\n+\n+#include <deque>\n+#include <memory>\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+namespace v8_inspector {\n+class StringBuffer;\n+class StringView;\n+}  // namespace v8_inspector\n+\n+namespace node {\n+namespace inspector {\n+class Request {\n+ public:\n+  virtual void Call() = 0;\n+  virtual ~Request() {}\n+};\n+\n+std::unique_ptr<v8_inspector::StringBuffer> Utf8ToStringView(\n+    const std::string& message);\n+\n+using MessageQueue = std::deque<std::unique_ptr<Request>>;\n+class MainThreadInterface;\n+\n+class MainThreadHandle : public std::enable_shared_from_this<MainThreadHandle> {\n+ public:\n+  explicit MainThreadHandle(MainThreadInterface* main_thread)\n+                            : main_thread_(main_thread) {}\n+  ~MainThreadHandle() {\n+    CHECK_NULL(main_thread_);  // main_thread_ should have called Reset\n+  }\n+  std::unique_ptr<InspectorSession> Connect(\n+      std::unique_ptr<InspectorSessionDelegate> delegate,\n+      bool prevent_shutdown);\n+  bool Post(std::unique_ptr<Request> request);\n+  Agent* GetInspectorAgent();\n+  std::unique_ptr<InspectorSessionDelegate> MakeThreadSafeDelegate(\n+      std::unique_ptr<InspectorSessionDelegate> delegate);\n+  bool Expired();\n+\n+ private:\n+  void Reset();\n+\n+  MainThreadInterface* main_thread_;\n+  Mutex block_lock_;\n+  int next_session_id_ = 0;\n+\n+  friend class MainThreadInterface;\n+};\n+\n+class MainThreadInterface {\n+ public:\n+  MainThreadInterface(Agent* agent, uv_loop_t*, v8::Isolate* isolate,\n+                      v8::Platform* platform);\n+  ~MainThreadInterface();\n+\n+  void DispatchMessages();\n+  void Post(std::unique_ptr<Request> request);\n+  bool WaitForFrontendEvent();\n+  std::shared_ptr<MainThreadHandle> GetHandle();\n+  Agent* inspector_agent() {\n+    return agent_;\n+  }\n+\n+ private:\n+  using AsyncAndInterface = std::pair<uv_async_t, MainThreadInterface*>;\n+\n+  static void DispatchMessagesAsyncCallback(uv_async_t* async);\n+  static void CloseAsync(AsyncAndInterface*);\n+\n+  MessageQueue requests_;\n+  Mutex requests_lock_;   // requests_ live across threads\n+  // This queue is to maintain the order of the messages for the cases\n+  // when we reenter the DispatchMessages function.\n+  MessageQueue dispatching_message_queue_;\n+  bool dispatching_messages_ = false;\n+  ConditionVariable incoming_message_cond_;\n+  // Used from any thread\n+  Agent* const agent_;\n+  v8::Isolate* const isolate_;\n+  v8::Platform* const platform_;\n+  DeleteFnPtr<AsyncAndInterface, CloseAsync> main_thread_request_;\n+  std::shared_ptr<MainThreadHandle> handle_;\n+};\n+\n+}  // namespace inspector\n+}  // namespace node\n+#endif  // SRC_INSPECTOR_MAIN_THREAD_INTERFACE_H_"
        },
        {
            "sha": "ebb8d8a161606d34f7e0d52c3e05aeaf14dcea29",
            "filename": "src/inspector_agent.cc",
            "status": "modified",
            "additions": 183,
            "deletions": 102,
            "changes": 285,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.cc?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -1,6 +1,7 @@\n #include \"inspector_agent.h\"\n \n #include \"inspector_io.h\"\n+#include \"inspector/main_thread_interface.h\"\n #include \"inspector/node_string.h\"\n #include \"inspector/tracing_agent.h\"\n #include \"node/inspector/protocol/Protocol.h\"\n@@ -49,7 +50,7 @@ class StartIoTask : public v8::Task {\n   explicit StartIoTask(Agent* agent) : agent(agent) {}\n \n   void Run() override {\n-    agent->StartIoThread(false);\n+    agent->StartIoThread();\n   }\n \n  private:\n@@ -64,11 +65,11 @@ std::unique_ptr<StringBuffer> ToProtocolString(Isolate* isolate,\n \n // Called on the main thread.\n void StartIoThreadAsyncCallback(uv_async_t* handle) {\n-  static_cast<Agent*>(handle->data)->StartIoThread(false);\n+  static_cast<Agent*>(handle->data)->StartIoThread();\n }\n \n void StartIoInterrupt(Isolate* isolate, void* agent) {\n-  static_cast<Agent*>(agent)->StartIoThread(false);\n+  static_cast<Agent*>(agent)->StartIoThread();\n }\n \n \n@@ -195,8 +196,10 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel,\n  public:\n   explicit ChannelImpl(Environment* env,\n                        const std::unique_ptr<V8Inspector>& inspector,\n-                       std::unique_ptr<InspectorSessionDelegate> delegate)\n-                       : delegate_(std::move(delegate)) {\n+                       std::unique_ptr<InspectorSessionDelegate> delegate,\n+                       bool prevent_shutdown)\n+                       : delegate_(std::move(delegate)),\n+                         prevent_shutdown_(prevent_shutdown) {\n     session_ = inspector->connect(1, this, StringView());\n     node_dispatcher_.reset(new protocol::UberDispatcher(this));\n     tracing_agent_.reset(new protocol::TracingAgent(env));\n@@ -208,7 +211,7 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel,\n     tracing_agent_.reset();  // Dispose before the dispatchers\n   }\n \n-  void dispatchProtocolMessage(const StringView& message) {\n+  std::string dispatchProtocolMessage(const StringView& message) {\n     std::unique_ptr<protocol::DictionaryValue> parsed;\n     std::string method;\n     node_dispatcher_->getCommandName(\n@@ -219,13 +222,18 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel,\n     } else {\n       node_dispatcher_->dispatch(std::move(parsed));\n     }\n+    return method;\n   }\n \n   void schedulePauseOnNextStatement(const std::string& reason) {\n     std::unique_ptr<StringBuffer> buffer = Utf8ToStringView(reason);\n     session_->schedulePauseOnNextStatement(buffer->string(), buffer->string());\n   }\n \n+  bool preventShutdown() {\n+    return prevent_shutdown_;\n+  }\n+\n  private:\n   void sendResponse(\n       int callId,\n@@ -263,6 +271,7 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel,\n   std::unique_ptr<InspectorSessionDelegate> delegate_;\n   std::unique_ptr<v8_inspector::V8InspectorSession> session_;\n   std::unique_ptr<protocol::UberDispatcher> node_dispatcher_;\n+  bool prevent_shutdown_;\n };\n \n class InspectorTimer {\n@@ -324,6 +333,44 @@ class InspectorTimerHandle {\n  private:\n   InspectorTimer* timer_;\n };\n+\n+class SameThreadInspectorSession : public InspectorSession {\n+ public:\n+  SameThreadInspectorSession(\n+      int session_id, std::shared_ptr<NodeInspectorClient> client)\n+      : session_id_(session_id), client_(client) {}\n+  ~SameThreadInspectorSession() override;\n+  void Dispatch(const v8_inspector::StringView& message) override;\n+\n+ private:\n+  int session_id_;\n+  std::weak_ptr<NodeInspectorClient> client_;\n+};\n+\n+void NotifyClusterWorkersDebugEnabled(Environment* env) {\n+  v8::Isolate* isolate = env->isolate();\n+  HandleScope handle_scope(isolate);\n+  auto context = env->context();\n+\n+  // Send message to enable debug in cluster workers\n+  Local<Object> process_object = env->process_object();\n+  Local<Value> emit_fn =\n+      process_object->Get(context, FIXED_ONE_BYTE_STRING(isolate, \"emit\"))\n+          .ToLocalChecked();\n+  // In case the thread started early during the startup\n+  if (!emit_fn->IsFunction())\n+    return;\n+\n+  Local<Object> message = Object::New(isolate);\n+  message->Set(context, FIXED_ONE_BYTE_STRING(isolate, \"cmd\"),\n+               FIXED_ONE_BYTE_STRING(isolate, \"NODE_DEBUG_ENABLED\")).FromJust();\n+  Local<Value> argv[] = {\n+    FIXED_ONE_BYTE_STRING(isolate, \"internalMessage\"),\n+    message\n+  };\n+  MakeCallback(env->isolate(), process_object, emit_fn.As<Function>(),\n+               arraysize(argv), argv, {0, 0});\n+}\n }  // namespace\n \n class NodeInspectorClient : public V8InspectorClient {\n@@ -337,31 +384,18 @@ class NodeInspectorClient : public V8InspectorClient {\n   }\n \n   void runMessageLoopOnPause(int context_group_id) override {\n-    runMessageLoop(false);\n-  }\n-\n-  void runMessageLoop(bool ignore_terminated) {\n-    if (running_nested_loop_)\n-      return;\n-    terminated_ = false;\n-    running_nested_loop_ = true;\n-    MultiIsolatePlatform* platform = env_->isolate_data()->platform();\n-    while ((ignore_terminated || !terminated_) && waitForFrontendEvent()) {\n-      while (platform->FlushForegroundTasks(env_->isolate())) {}\n-    }\n-    terminated_ = false;\n-    running_nested_loop_ = false;\n+    waiting_for_resume_ = true;\n+    runMessageLoop();\n   }\n \n-  bool waitForFrontendEvent() {\n-    InspectorIo* io = env_->inspector_agent()->io();\n-    if (io == nullptr)\n-      return false;\n-    return io->WaitForFrontendEvent();\n+  void waitForIoShutdown() {\n+    waiting_for_io_shutdown_ = true;\n+    runMessageLoop();\n   }\n \n-  double currentTimeMS() override {\n-    return uv_hrtime() * 1.0 / NANOS_PER_MSEC;\n+  void waitForFrontend() {\n+    waiting_for_frontend_ = true;\n+    runMessageLoop();\n   }\n \n   void maxAsyncCallStackDepthChanged(int depth) override {\n@@ -398,16 +432,17 @@ class NodeInspectorClient : public V8InspectorClient {\n   }\n \n   void quitMessageLoopOnPause() override {\n-    terminated_ = true;\n+    waiting_for_resume_ = false;\n   }\n \n-  int connectFrontend(std::unique_ptr<InspectorSessionDelegate> delegate) {\n+  int connectFrontend(std::unique_ptr<InspectorSessionDelegate> delegate,\n+                      bool prevent_shutdown) {\n     events_dispatched_ = true;\n     int session_id = next_session_id_++;\n     // TODO(addaleax): Revert back to using make_unique once we get issues\n     // with CI resolved (i.e. revert the patch that added this comment).\n     channels_[session_id].reset(\n-        new ChannelImpl(env_, client_, std::move(delegate)));\n+        new ChannelImpl(env_, client_, std::move(delegate), prevent_shutdown));\n     return session_id;\n   }\n \n@@ -418,7 +453,10 @@ class NodeInspectorClient : public V8InspectorClient {\n \n   void dispatchMessageFromFrontend(int session_id, const StringView& message) {\n     events_dispatched_ = true;\n-    channels_[session_id]->dispatchProtocolMessage(message);\n+    std::string method =\n+        channels_[session_id]->dispatchProtocolMessage(message);\n+    if (waiting_for_frontend_)\n+      waiting_for_frontend_ = method != \"Runtime.runIfWaitingForDebugger\";\n   }\n \n   Local<Context> ensureDefaultContextInGroup(int contextGroupId) override {\n@@ -509,116 +547,150 @@ class NodeInspectorClient : public V8InspectorClient {\n   }\n \n   bool hasConnectedSessions() {\n+    for (const auto& id_channel : channels_) {\n+      // Other sessions are \"invisible\" more most purposes\n+      if (id_channel.second->preventShutdown())\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  std::shared_ptr<MainThreadHandle> getThreadHandle() {\n+    if (interface_ == nullptr) {\n+      interface_.reset(new MainThreadInterface(\n+          env_->inspector_agent(), env_->event_loop(), env_->isolate(),\n+          env_->isolate_data()->platform()));\n+    }\n+    return interface_->GetHandle();\n+  }\n+\n+  bool IsActive() {\n     return !channels_.empty();\n   }\n \n  private:\n+  bool shouldRunMessageLoop() {\n+    if (waiting_for_frontend_)\n+      return true;\n+    if (waiting_for_io_shutdown_ || waiting_for_resume_)\n+      return hasConnectedSessions();\n+    return false;\n+  }\n+\n+  void runMessageLoop() {\n+    if (running_nested_loop_)\n+      return;\n+\n+    running_nested_loop_ = true;\n+\n+    MultiIsolatePlatform* platform = env_->isolate_data()->platform();\n+    while (shouldRunMessageLoop()) {\n+      if (interface_ && hasConnectedSessions())\n+        interface_->WaitForFrontendEvent();\n+      while (platform->FlushForegroundTasks(env_->isolate())) {}\n+    }\n+    running_nested_loop_ = false;\n+  }\n+\n+  double currentTimeMS() override {\n+    return uv_hrtime() * 1.0 / NANOS_PER_MSEC;\n+  }\n+\n   node::Environment* env_;\n-  bool terminated_ = false;\n   bool running_nested_loop_ = false;\n   std::unique_ptr<V8Inspector> client_;\n   std::unordered_map<int, std::unique_ptr<ChannelImpl>> channels_;\n   std::unordered_map<void*, InspectorTimerHandle> timers_;\n   int next_session_id_ = 1;\n   bool events_dispatched_ = false;\n+  bool waiting_for_resume_ = false;\n+  bool waiting_for_frontend_ = false;\n+  bool waiting_for_io_shutdown_ = false;\n+  // Allows accessing Inspector from non-main threads\n+  std::unique_ptr<MainThreadInterface> interface_;\n };\n \n Agent::Agent(Environment* env) : parent_env_(env) {}\n \n-// Destructor needs to be defined here in implementation file as the header\n-// does not have full definition of some classes.\n-Agent::~Agent() {\n-}\n+Agent::~Agent() = default;\n \n-bool Agent::Start(const char* path, const DebugOptions& options) {\n-  path_ = path == nullptr ? \"\" : path;\n+bool Agent::Start(const std::string& path, const DebugOptions& options) {\n+  path_ = path;\n   debug_options_ = options;\n   client_ = std::make_shared<NodeInspectorClient>(parent_env_);\n-  CHECK_EQ(0, uv_async_init(uv_default_loop(),\n-                            &start_io_thread_async,\n-                            StartIoThreadAsyncCallback));\n-  start_io_thread_async.data = this;\n-  uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));\n-\n-  // Ignore failure, SIGUSR1 won't work, but that should not block node start.\n-  StartDebugSignalHandler();\n-  if (options.inspector_enabled()) {\n-    // This will return false if listen failed on the inspector port.\n-    return StartIoThread(options.wait_for_connect());\n+  if (parent_env_->is_main_thread()) {\n+    CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),\n+                              &start_io_thread_async,\n+                              StartIoThreadAsyncCallback));\n+    uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));\n+    start_io_thread_async.data = this;\n+    // Ignore failure, SIGUSR1 won't work, but that should not block node start.\n+    StartDebugSignalHandler();\n+  }\n+\n+  bool wait_for_connect = options.wait_for_connect();\n+  if (!options.inspector_enabled() || !StartIoThread()) {\n+    return false;\n+  }\n+  if (wait_for_connect) {\n+    HandleScope scope(parent_env_->isolate());\n+    parent_env_->process_object()->DefineOwnProperty(\n+        parent_env_->context(),\n+        FIXED_ONE_BYTE_STRING(parent_env_->isolate(), \"_breakFirstLine\"),\n+        True(parent_env_->isolate()),\n+        static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontEnum))\n+        .FromJust();\n+    client_->waitForFrontend();\n   }\n   return true;\n }\n \n-bool Agent::StartIoThread(bool wait_for_connect) {\n+bool Agent::StartIoThread() {\n   if (io_ != nullptr)\n     return true;\n \n   CHECK_NOT_NULL(client_);\n \n-  io_ = std::unique_ptr<InspectorIo>(\n-      new InspectorIo(parent_env_, path_, debug_options_, wait_for_connect));\n-  if (!io_->Start()) {\n-    client_.reset();\n+  io_ = InspectorIo::Start(\n+      client_->getThreadHandle(), path_, debug_options_);\n+  if (io_ == nullptr) {\n     return false;\n   }\n-\n-  v8::Isolate* isolate = parent_env_->isolate();\n-  HandleScope handle_scope(isolate);\n-  auto context = parent_env_->context();\n-\n-  // Send message to enable debug in workers\n-  Local<Object> process_object = parent_env_->process_object();\n-  Local<Value> emit_fn =\n-      process_object->Get(context, FIXED_ONE_BYTE_STRING(isolate, \"emit\"))\n-          .ToLocalChecked();\n-  // In case the thread started early during the startup\n-  if (!emit_fn->IsFunction())\n-    return true;\n-\n-  Local<Object> message = Object::New(isolate);\n-  message->Set(context, FIXED_ONE_BYTE_STRING(isolate, \"cmd\"),\n-               FIXED_ONE_BYTE_STRING(isolate, \"NODE_DEBUG_ENABLED\")).FromJust();\n-  Local<Value> argv[] = {\n-    FIXED_ONE_BYTE_STRING(isolate, \"internalMessage\"),\n-    message\n-  };\n-  MakeCallback(parent_env_->isolate(), process_object, emit_fn.As<Function>(),\n-               arraysize(argv), argv, {0, 0});\n-\n+  NotifyClusterWorkersDebugEnabled(parent_env_);\n   return true;\n }\n \n void Agent::Stop() {\n-  if (io_ != nullptr) {\n-    io_->Stop();\n-    io_.reset();\n-  }\n+  io_.reset();\n }\n \n std::unique_ptr<InspectorSession> Agent::Connect(\n-    std::unique_ptr<InspectorSessionDelegate> delegate) {\n-  int session_id = client_->connectFrontend(std::move(delegate));\n+    std::unique_ptr<InspectorSessionDelegate> delegate,\n+    bool prevent_shutdown) {\n+  CHECK_NOT_NULL(client_);\n+  int session_id = client_->connectFrontend(std::move(delegate),\n+                                            prevent_shutdown);\n   return std::unique_ptr<InspectorSession>(\n-      new InspectorSession(session_id, client_));\n+      new SameThreadInspectorSession(session_id, client_));\n }\n \n void Agent::WaitForDisconnect() {\n   CHECK_NOT_NULL(client_);\n+  if (client_->hasConnectedSessions()) {\n+    fprintf(stderr, \"Waiting for the debugger to disconnect...\\n\");\n+    fflush(stderr);\n+  }\n   // TODO(addaleax): Maybe this should use an at-exit hook for the Environment\n   // or something similar?\n   client_->contextDestroyed(parent_env_->context());\n   if (io_ != nullptr) {\n-    io_->WaitForDisconnect();\n-    // There is a bug in V8 Inspector (https://crbug.com/834056) that\n-    // calls V8InspectorClient::quitMessageLoopOnPause when a session\n-    // disconnects. We are using this flag to ignore those calls so the message\n-    // loop is spinning as long as there's a reason to expect inspector messages\n-    client_->runMessageLoop(true);\n+    io_->StopAcceptingNewConnections();\n+    client_->waitForIoShutdown();\n   }\n }\n \n void Agent::FatalException(Local<Value> error, Local<v8::Message> message) {\n-  if (!IsStarted())\n+  if (!IsListening())\n     return;\n   client_->FatalException(error, message);\n   WaitForDisconnect();\n@@ -718,26 +790,35 @@ void Agent::ContextCreated(Local<Context> context, const ContextInfo& info) {\n   client_->contextCreated(context, info);\n }\n \n-bool Agent::IsWaitingForConnect() {\n+bool Agent::WillWaitForConnect() {\n   return debug_options_.wait_for_connect();\n }\n \n-bool Agent::HasConnectedSessions() {\n+bool Agent::IsActive() {\n   if (client_ == nullptr)\n     return false;\n-  return client_->hasConnectedSessions();\n+  return io_ != nullptr || client_->IsActive();\n }\n \n-InspectorSession::InspectorSession(int session_id,\n-                                   std::shared_ptr<NodeInspectorClient> client)\n-                                   : session_id_(session_id), client_(client) {}\n+void Agent::WaitForConnect() {\n+  CHECK_NOT_NULL(client_);\n+  client_->waitForFrontend();\n+}\n \n-InspectorSession::~InspectorSession() {\n-  client_->disconnectFrontend(session_id_);\n+SameThreadInspectorSession::~SameThreadInspectorSession() {\n+  auto client = client_.lock();\n+  if (client)\n+    client->disconnectFrontend(session_id_);\n }\n \n-void InspectorSession::Dispatch(const StringView& message) {\n-  client_->dispatchMessageFromFrontend(session_id_, message);\n+void SameThreadInspectorSession::Dispatch(\n+    const v8_inspector::StringView& message) {\n+  auto client = client_.lock();\n+  if (client)\n+    client->dispatchMessageFromFrontend(session_id_, message);\n }\n+\n+\n+\n }  // namespace inspector\n }  // namespace node"
        },
        {
            "sha": "dcd6e13aba275fb10a660a6d59dd4131babe89a0",
            "filename": "src/inspector_agent.h",
            "status": "modified",
            "additions": 20,
            "deletions": 19,
            "changes": 39,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_agent.h",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_agent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.h?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -20,7 +20,6 @@ class StringView;\n namespace node {\n // Forward declaration to break recursive dependency chain with src/env.h.\n class Environment;\n-class NodePlatform;\n struct ContextInfo;\n \n namespace inspector {\n@@ -29,12 +28,8 @@ class NodeInspectorClient;\n \n class InspectorSession {\n  public:\n-  InspectorSession(int session_id, std::shared_ptr<NodeInspectorClient> client);\n-  ~InspectorSession();\n-  void Dispatch(const v8_inspector::StringView& message);\n- private:\n-  int session_id_;\n-  std::shared_ptr<NodeInspectorClient> client_;\n+  virtual ~InspectorSession() {}\n+  virtual void Dispatch(const v8_inspector::StringView& message) = 0;\n };\n \n class InspectorSessionDelegate {\n@@ -50,15 +45,21 @@ class Agent {\n   ~Agent();\n \n   // Create client_, may create io_ if option enabled\n-  bool Start(const char* path, const DebugOptions& options);\n+  bool Start(const std::string& path, const DebugOptions& options);\n   // Stop and destroy io_\n   void Stop();\n \n-  bool IsStarted() { return !!client_; }\n-\n-  // IO thread started, and client connected\n-  bool IsWaitingForConnect();\n-\n+  bool IsListening() { return io_ != nullptr; }\n+  // Returns true if the Node inspector is actually in use. It will be true\n+  // if either the user explicitely opted into inspector (e.g. with the\n+  // --inspect command line flag) or if inspector JS API had been used.\n+  bool IsActive();\n+\n+  // Option is set to wait for session connection\n+  bool WillWaitForConnect();\n+  // Blocks till frontend connects and sends \"runIfWaitingForDebugger\"\n+  void WaitForConnect();\n+  // Blocks till all the sessions with \"WaitForDisconnectOnShutdown\" disconnect\n   void WaitForDisconnect();\n   void FatalException(v8::Local<v8::Value> error,\n                       v8::Local<v8::Message> message);\n@@ -77,22 +78,20 @@ class Agent {\n   void EnableAsyncHook();\n   void DisableAsyncHook();\n \n-  // Called by the WS protocol and JS binding to create inspector sessions.\n+  // Called to create inspector sessions that can be used from the main thread.\n   // The inspector responds by using the delegate to send messages back.\n   std::unique_ptr<InspectorSession> Connect(\n-      std::unique_ptr<InspectorSessionDelegate> delegate);\n+      std::unique_ptr<InspectorSessionDelegate> delegate,\n+      bool prevent_shutdown);\n \n   void PauseOnNextJavascriptStatement(const std::string& reason);\n \n-  // Returns true as long as there is at least one connected session.\n-  bool HasConnectedSessions();\n-\n   InspectorIo* io() {\n     return io_.get();\n   }\n \n   // Can only be called from the main thread.\n-  bool StartIoThread(bool wait_for_connect);\n+  bool StartIoThread();\n \n   // Calls StartIoThread() from off the main thread.\n   void RequestIoThreadStart();\n@@ -105,7 +104,9 @@ class Agent {\n                        const node::Persistent<v8::Function>& fn);\n \n   node::Environment* parent_env_;\n+  // Encapsulates majority of the Inspector functionality\n   std::shared_ptr<NodeInspectorClient> client_;\n+  // Interface for transports, e.g. WebSocket server\n   std::unique_ptr<InspectorIo> io_;\n   std::string path_;\n   DebugOptions debug_options_;"
        },
        {
            "sha": "41fea546a832651eab8a1dd965dc6973a6d96bdc",
            "filename": "src/inspector_io.cc",
            "status": "modified",
            "additions": 214,
            "deletions": 335,
            "changes": 549,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_io.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_io.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.cc?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -1,6 +1,7 @@\n #include \"inspector_io.h\"\n \n #include \"inspector_socket_server.h\"\n+#include \"inspector/main_thread_interface.h\"\n #include \"inspector/node_string.h\"\n #include \"env-inl.h\"\n #include \"debug_utils.h\"\n@@ -11,23 +12,16 @@\n #include \"util.h\"\n #include \"zlib.h\"\n \n-#include <sstream>\n-#include <unicode/unistr.h>\n-\n+#include <deque>\n #include <string.h>\n #include <vector>\n \n-\n namespace node {\n namespace inspector {\n namespace {\n-using AsyncAndAgent = std::pair<uv_async_t, Agent*>;\n using v8_inspector::StringBuffer;\n using v8_inspector::StringView;\n \n-template <typename Transport>\n-using TransportAndIo = std::pair<Transport*, InspectorIo*>;\n-\n std::string ScriptPath(uv_loop_t* loop, const std::string& script_name) {\n   std::string script_path;\n \n@@ -64,407 +58,285 @@ std::string GenerateID() {\n   return uuid;\n }\n \n-void HandleSyncCloseCb(uv_handle_t* handle) {\n-  *static_cast<bool*>(handle->data) = true;\n-}\n+class RequestToServer {\n+ public:\n+  RequestToServer(TransportAction action,\n+                  int session_id,\n+                  std::unique_ptr<v8_inspector::StringBuffer> message)\n+                  : action_(action),\n+                    session_id_(session_id),\n+                    message_(std::move(message)) {}\n+\n+  void Dispatch(InspectorSocketServer* server) const {\n+    switch (action_) {\n+      case TransportAction::kKill:\n+        server->TerminateConnections();\n+        // Fallthrough\n+      case TransportAction::kStop:\n+        server->Stop();\n+        break;\n+      case TransportAction::kSendMessage:\n+        server->Send(\n+            session_id_,\n+            protocol::StringUtil::StringViewToUtf8(message_->string()));\n+        break;\n+    }\n+  }\n \n-void CloseAsyncAndLoop(uv_async_t* async) {\n-  bool is_closed = false;\n-  async->data = &is_closed;\n-  uv_close(reinterpret_cast<uv_handle_t*>(async), HandleSyncCloseCb);\n-  while (!is_closed)\n-    uv_run(async->loop, UV_RUN_ONCE);\n-  async->data = nullptr;\n-  CheckedUvLoopClose(async->loop);\n-}\n+ private:\n+  TransportAction action_;\n+  int session_id_;\n+  std::unique_ptr<v8_inspector::StringBuffer> message_;\n+};\n \n-// Delete main_thread_req_ on async handle close\n-void ReleasePairOnAsyncClose(uv_handle_t* async) {\n-  std::unique_ptr<AsyncAndAgent> pair(node::ContainerOf(&AsyncAndAgent::first,\n-      reinterpret_cast<uv_async_t*>(async)));\n-  // Unique_ptr goes out of scope here and pointer is deleted.\n-}\n+class RequestQueueData {\n+ public:\n+  using MessageQueue = std::deque<RequestToServer>;\n+\n+  explicit RequestQueueData(uv_loop_t* loop)\n+                            : handle_(std::make_shared<RequestQueue>(this)) {\n+    int err = uv_async_init(loop, &async_, [](uv_async_t* async) {\n+      RequestQueueData* wrapper =\n+          node::ContainerOf(&RequestQueueData::async_, async);\n+      wrapper->DoDispatch();\n+    });\n+    CHECK_EQ(0, err);\n+  }\n+\n+  static void CloseAndFree(RequestQueueData* queue);\n+\n+  void Post(int session_id,\n+            TransportAction action,\n+            std::unique_ptr<StringBuffer> message) {\n+    Mutex::ScopedLock scoped_lock(state_lock_);\n+    bool notify = messages_.empty();\n+    messages_.emplace_back(action, session_id, std::move(message));\n+    if (notify) {\n+      CHECK_EQ(0, uv_async_send(&async_));\n+      incoming_message_cond_.Broadcast(scoped_lock);\n+    }\n+  }\n+\n+  void Wait() {\n+    Mutex::ScopedLock scoped_lock(state_lock_);\n+    if (messages_.empty()) {\n+      incoming_message_cond_.Wait(scoped_lock);\n+    }\n+  }\n+\n+  void SetServer(InspectorSocketServer* server) {\n+    server_ = server;\n+  }\n \n+  std::shared_ptr<RequestQueue> handle() {\n+    return handle_;\n+  }\n+\n+ private:\n+  ~RequestQueueData() = default;\n+\n+  MessageQueue GetMessages() {\n+    Mutex::ScopedLock scoped_lock(state_lock_);\n+    MessageQueue messages;\n+    messages_.swap(messages);\n+    return messages;\n+  }\n+\n+  void DoDispatch() {\n+    if (server_ == nullptr)\n+      return;\n+    for (const auto& request : GetMessages()) {\n+      request.Dispatch(server_);\n+    }\n+  }\n+\n+  std::shared_ptr<RequestQueue> handle_;\n+  uv_async_t async_;\n+  InspectorSocketServer* server_ = nullptr;\n+  MessageQueue messages_;\n+  Mutex state_lock_;  // Locked before mutating the queue.\n+  ConditionVariable incoming_message_cond_;\n+};\n }  // namespace\n \n-std::unique_ptr<StringBuffer> Utf8ToStringView(const std::string& message) {\n-  icu::UnicodeString utf16 =\n-    icu::UnicodeString::fromUTF8(icu::StringPiece(message.data(),\n-      message.length()));\n-  StringView view(reinterpret_cast<const uint16_t*>(utf16.getBuffer()),\n-                  utf16.length());\n-  return StringBuffer::create(view);\n-}\n+class RequestQueue {\n+ public:\n+  explicit RequestQueue(RequestQueueData* data) : data_(data) {}\n+\n+  void Reset() {\n+    Mutex::ScopedLock scoped_lock(lock_);\n+    data_ = nullptr;\n+  }\n \n+  void Post(int session_id,\n+            TransportAction action,\n+            std::unique_ptr<StringBuffer> message) {\n+    Mutex::ScopedLock scoped_lock(lock_);\n+    if (data_ != nullptr)\n+      data_->Post(session_id, action, std::move(message));\n+  }\n+\n+  void SetServer(InspectorSocketServer* server) {\n+    Mutex::ScopedLock scoped_lock(lock_);\n+    if (data_ != nullptr)\n+      data_->SetServer(server);\n+  }\n+\n+  bool Expired() {\n+    Mutex::ScopedLock scoped_lock(lock_);\n+    return data_ == nullptr;\n+  }\n+\n+ private:\n+  RequestQueueData* data_;\n+  Mutex lock_;\n+};\n \n class IoSessionDelegate : public InspectorSessionDelegate {\n  public:\n-  explicit IoSessionDelegate(InspectorIo* io, int id) : io_(io), id_(id) { }\n-  void SendMessageToFrontend(const v8_inspector::StringView& message) override;\n+  explicit IoSessionDelegate(std::shared_ptr<RequestQueue> queue, int id)\n+                             : request_queue_(queue), id_(id) { }\n+  void SendMessageToFrontend(const v8_inspector::StringView& message) override {\n+    request_queue_->Post(id_, TransportAction::kSendMessage,\n+                         StringBuffer::create(message));\n+  }\n+\n  private:\n-  InspectorIo* io_;\n+  std::shared_ptr<RequestQueue> request_queue_;\n   int id_;\n };\n \n // Passed to InspectorSocketServer to handle WS inspector protocol events,\n // mostly session start, message received, and session end.\n class InspectorIoDelegate: public node::inspector::SocketServerDelegate {\n  public:\n-  InspectorIoDelegate(InspectorIo* io, const std::string& target_id,\n+  InspectorIoDelegate(std::shared_ptr<RequestQueueData> queue,\n+                      std::shared_ptr<MainThreadHandle> main_threade,\n+                      const std::string& target_id,\n                       const std::string& script_path,\n-                      const std::string& script_name, bool wait);\n+                      const std::string& script_name);\n   ~InspectorIoDelegate() {\n-    io_->ServerDone();\n   }\n-  // Calls PostIncomingMessage() with appropriate InspectorAction:\n-  //   kStartSession\n+\n   void StartSession(int session_id, const std::string& target_id) override;\n-  //   kSendMessage\n   void MessageReceived(int session_id, const std::string& message) override;\n-  //   kEndSession\n   void EndSession(int session_id) override;\n \n   std::vector<std::string> GetTargetIds() override;\n   std::string GetTargetTitle(const std::string& id) override;\n   std::string GetTargetUrl(const std::string& id) override;\n-\n   void AssignServer(InspectorSocketServer* server) override {\n-    server_ = server;\n+    request_queue_->SetServer(server);\n   }\n \n  private:\n-  InspectorIo* io_;\n-  int session_id_;\n+  std::shared_ptr<RequestQueueData> request_queue_;\n+  std::shared_ptr<MainThreadHandle> main_thread_;\n+  std::unordered_map<int, std::unique_ptr<InspectorSession>> sessions_;\n   const std::string script_name_;\n   const std::string script_path_;\n   const std::string target_id_;\n-  bool waiting_;\n-  InspectorSocketServer* server_;\n };\n \n-void InterruptCallback(v8::Isolate*, void* agent) {\n-  InspectorIo* io = static_cast<Agent*>(agent)->io();\n-  if (io != nullptr)\n-    io->DispatchMessages();\n-}\n-\n-class DispatchMessagesTask : public v8::Task {\n- public:\n-  explicit DispatchMessagesTask(Agent* agent) : agent_(agent) {}\n-\n-  void Run() override {\n-    InspectorIo* io = agent_->io();\n-    if (io != nullptr)\n-      io->DispatchMessages();\n+// static\n+std::unique_ptr<InspectorIo> InspectorIo::Start(\n+    std::shared_ptr<MainThreadHandle> main_thread,\n+    const std::string& path,\n+    const DebugOptions& options) {\n+  auto io = std::unique_ptr<InspectorIo>(\n+      new InspectorIo(main_thread, path, options));\n+  if (io->request_queue_->Expired()) {  // Thread is not running\n+    return nullptr;\n   }\n-\n- private:\n-  Agent* agent_;\n-};\n-\n-InspectorIo::InspectorIo(Environment* env, const std::string& path,\n-                         const DebugOptions& options, bool wait_for_connect)\n-                         : options_(options), thread_(), state_(State::kNew),\n-                           parent_env_(env), thread_req_(),\n-                           platform_(parent_env_->isolate_data()->platform()),\n-                           dispatching_messages_(false), script_name_(path),\n-                           wait_for_connect_(wait_for_connect), port_(-1),\n-                           id_(GenerateID()) {\n-  main_thread_req_ = new AsyncAndAgent({uv_async_t(), env->inspector_agent()});\n-  CHECK_EQ(0, uv_async_init(env->event_loop(), &main_thread_req_->first,\n-                            InspectorIo::MainThreadReqAsyncCb));\n-  uv_unref(reinterpret_cast<uv_handle_t*>(&main_thread_req_->first));\n-  CHECK_EQ(0, uv_sem_init(&thread_start_sem_, 0));\n+  return io;\n }\n \n-InspectorIo::~InspectorIo() {\n-  uv_sem_destroy(&thread_start_sem_);\n-  uv_close(reinterpret_cast<uv_handle_t*>(&main_thread_req_->first),\n-           ReleasePairOnAsyncClose);\n-}\n-\n-bool InspectorIo::Start() {\n-  CHECK_EQ(state_, State::kNew);\n+InspectorIo::InspectorIo(std::shared_ptr<MainThreadHandle> main_thread,\n+                         const std::string& path,\n+                         const DebugOptions& options)\n+                         : main_thread_(main_thread), options_(options),\n+                           thread_(), script_name_(path), id_(GenerateID()) {\n+  Mutex::ScopedLock scoped_lock(thread_start_lock_);\n   CHECK_EQ(uv_thread_create(&thread_, InspectorIo::ThreadMain, this), 0);\n-  uv_sem_wait(&thread_start_sem_);\n-\n-  if (state_ == State::kError) {\n-    return false;\n-  }\n-  state_ = State::kAccepting;\n-  if (wait_for_connect_) {\n-    DispatchMessages();\n-  }\n-  return true;\n+  thread_start_condition_.Wait(scoped_lock);\n }\n \n-void InspectorIo::Stop() {\n-  CHECK_IMPLIES(sessions_.empty(), state_ == State::kAccepting);\n-  Write(TransportAction::kKill, 0, StringView());\n+InspectorIo::~InspectorIo() {\n+  request_queue_->Post(0, TransportAction::kKill, nullptr);\n   int err = uv_thread_join(&thread_);\n   CHECK_EQ(err, 0);\n-  state_ = State::kShutDown;\n-  DispatchMessages();\n }\n \n-bool InspectorIo::IsStarted() {\n-  return platform_ != nullptr;\n-}\n-\n-void InspectorIo::WaitForDisconnect() {\n-  if (state_ == State::kAccepting)\n-    state_ = State::kDone;\n-  if (!sessions_.empty()) {\n-    state_ = State::kShutDown;\n-    Write(TransportAction::kStop, 0, StringView());\n-    fprintf(stderr, \"Waiting for the debugger to disconnect...\\n\");\n-    fflush(stderr);\n-  }\n+void InspectorIo::StopAcceptingNewConnections() {\n+  request_queue_->Post(0, TransportAction::kStop, nullptr);\n }\n \n // static\n void InspectorIo::ThreadMain(void* io) {\n-  static_cast<InspectorIo*>(io)->ThreadMain<InspectorSocketServer>();\n-}\n-\n-// static\n-template <typename Transport>\n-void InspectorIo::IoThreadAsyncCb(uv_async_t* async) {\n-  TransportAndIo<Transport>* transport_and_io =\n-      static_cast<TransportAndIo<Transport>*>(async->data);\n-  if (transport_and_io == nullptr) {\n-    return;\n-  }\n-  Transport* transport = transport_and_io->first;\n-  InspectorIo* io = transport_and_io->second;\n-  MessageQueue<TransportAction> outgoing_message_queue;\n-  io->SwapBehindLock(&io->outgoing_message_queue_, &outgoing_message_queue);\n-  for (const auto& outgoing : outgoing_message_queue) {\n-    int session_id = std::get<1>(outgoing);\n-    switch (std::get<0>(outgoing)) {\n-    case TransportAction::kKill:\n-      transport->TerminateConnections();\n-      // Fallthrough\n-    case TransportAction::kStop:\n-      transport->Stop();\n-      break;\n-    case TransportAction::kSendMessage:\n-      transport->Send(session_id,\n-                      protocol::StringUtil::StringViewToUtf8(\n-                          std::get<2>(outgoing)->string()));\n-      break;\n-    case TransportAction::kAcceptSession:\n-      transport->AcceptSession(session_id);\n-      break;\n-    case TransportAction::kDeclineSession:\n-      transport->DeclineSession(session_id);\n-      break;\n-    }\n-  }\n+  static_cast<InspectorIo*>(io)->ThreadMain();\n }\n \n-template <typename Transport>\n void InspectorIo::ThreadMain() {\n   uv_loop_t loop;\n   loop.data = nullptr;\n   int err = uv_loop_init(&loop);\n   CHECK_EQ(err, 0);\n-  thread_req_.data = nullptr;\n-  err = uv_async_init(&loop, &thread_req_, IoThreadAsyncCb<Transport>);\n-  CHECK_EQ(err, 0);\n+  std::shared_ptr<RequestQueueData> queue(new RequestQueueData(&loop),\n+                                          RequestQueueData::CloseAndFree);\n   std::string script_path = ScriptPath(&loop, script_name_);\n-  auto delegate = std::unique_ptr<InspectorIoDelegate>(\n-      new InspectorIoDelegate(this, id_, script_path, script_name_,\n-                              wait_for_connect_));\n-  Transport server(std::move(delegate), &loop, options_.host_name(),\n-                   options_.port());\n-  TransportAndIo<Transport> queue_transport(&server, this);\n-  thread_req_.data = &queue_transport;\n-  if (!server.Start()) {\n-    state_ = State::kError;  // Safe, main thread is waiting on semaphore\n-    CloseAsyncAndLoop(&thread_req_);\n-    uv_sem_post(&thread_start_sem_);\n-    return;\n-  }\n-  port_ = server.Port();  // Safe, main thread is waiting on semaphore.\n-  if (!wait_for_connect_) {\n-    uv_sem_post(&thread_start_sem_);\n+  std::unique_ptr<InspectorIoDelegate> delegate(\n+      new InspectorIoDelegate(queue, main_thread_, id_,\n+                              script_path, script_name_));\n+  InspectorSocketServer server(std::move(delegate), &loop,\n+                               options_.host_name(), options_.port());\n+  request_queue_ = queue->handle();\n+  // Its lifetime is now that of the server delegate\n+  queue.reset();\n+  {\n+    Mutex::ScopedLock scoped_lock(thread_start_lock_);\n+    if (server.Start()) {\n+      port_ = server.Port();\n+    }\n+    thread_start_condition_.Broadcast(scoped_lock);\n   }\n   uv_run(&loop, UV_RUN_DEFAULT);\n-  thread_req_.data = nullptr;\n   CheckedUvLoopClose(&loop);\n }\n \n-template <typename ActionType>\n-bool InspectorIo::AppendMessage(MessageQueue<ActionType>* queue,\n-                                ActionType action, int session_id,\n-                                std::unique_ptr<StringBuffer> buffer) {\n-  Mutex::ScopedLock scoped_lock(state_lock_);\n-  bool trigger_pumping = queue->empty();\n-  queue->push_back(std::make_tuple(action, session_id, std::move(buffer)));\n-  return trigger_pumping;\n-}\n-\n-template <typename ActionType>\n-void InspectorIo::SwapBehindLock(MessageQueue<ActionType>* vector1,\n-                                 MessageQueue<ActionType>* vector2) {\n-  Mutex::ScopedLock scoped_lock(state_lock_);\n-  vector1->swap(*vector2);\n-}\n-\n-void InspectorIo::PostIncomingMessage(InspectorAction action, int session_id,\n-                                      const std::string& message) {\n-  Debug(parent_env_, DebugCategory::INSPECTOR_SERVER,\n-        \">>> %s\\n\", message.c_str());\n-  if (AppendMessage(&incoming_message_queue_, action, session_id,\n-                    Utf8ToStringView(message))) {\n-    Agent* agent = main_thread_req_->second;\n-    v8::Isolate* isolate = parent_env_->isolate();\n-    platform_->CallOnForegroundThread(isolate,\n-                                      new DispatchMessagesTask(agent));\n-    isolate->RequestInterrupt(InterruptCallback, agent);\n-    CHECK_EQ(0, uv_async_send(&main_thread_req_->first));\n-  }\n-  Mutex::ScopedLock scoped_lock(state_lock_);\n-  incoming_message_cond_.Broadcast(scoped_lock);\n-}\n-\n std::vector<std::string> InspectorIo::GetTargetIds() const {\n   return { id_ };\n }\n \n-TransportAction InspectorIo::Attach(int session_id) {\n-  Agent* agent = parent_env_->inspector_agent();\n-  fprintf(stderr, \"Debugger attached.\\n\");\n-  sessions_[session_id] = agent->Connect(std::unique_ptr<IoSessionDelegate>(\n-      new IoSessionDelegate(this, session_id)));\n-  return TransportAction::kAcceptSession;\n-}\n-\n-void InspectorIo::DispatchMessages() {\n-  if (dispatching_messages_)\n-    return;\n-  dispatching_messages_ = true;\n-  bool had_messages = false;\n-  do {\n-    if (dispatching_message_queue_.empty())\n-      SwapBehindLock(&incoming_message_queue_, &dispatching_message_queue_);\n-    had_messages = !dispatching_message_queue_.empty();\n-    while (!dispatching_message_queue_.empty()) {\n-      MessageQueue<InspectorAction>::value_type task;\n-      std::swap(dispatching_message_queue_.front(), task);\n-      dispatching_message_queue_.pop_front();\n-      int id = std::get<1>(task);\n-      StringView message = std::get<2>(task)->string();\n-      switch (std::get<0>(task)) {\n-      case InspectorAction::kStartSession:\n-        Write(Attach(id), id, StringView());\n-        break;\n-      case InspectorAction::kStartSessionUnconditionally:\n-        Attach(id);\n-        break;\n-      case InspectorAction::kEndSession:\n-        sessions_.erase(id);\n-        if (!sessions_.empty())\n-          continue;\n-        if (state_ == State::kShutDown) {\n-          state_ = State::kDone;\n-        } else {\n-          state_ = State::kAccepting;\n-        }\n-        break;\n-      case InspectorAction::kSendMessage:\n-        auto session = sessions_.find(id);\n-        if (session != sessions_.end() && session->second) {\n-          session->second->Dispatch(message);\n-        }\n-        break;\n-      }\n-    }\n-  } while (had_messages);\n-  dispatching_messages_ = false;\n-}\n-\n-// static\n-void InspectorIo::MainThreadReqAsyncCb(uv_async_t* req) {\n-  AsyncAndAgent* pair = node::ContainerOf(&AsyncAndAgent::first, req);\n-  // Note that this may be called after io was closed or even after a new\n-  // one was created and ran.\n-  InspectorIo* io = pair->second->io();\n-  if (io != nullptr)\n-    io->DispatchMessages();\n-}\n-\n-void InspectorIo::Write(TransportAction action, int session_id,\n-                        const StringView& inspector_message) {\n-  std::string message_str =\n-      protocol::StringUtil::StringViewToUtf8(inspector_message);\n-  Debug(parent_env_, DebugCategory::INSPECTOR_SERVER,\n-        \"<<< %s\\n\", message_str.c_str());\n-  AppendMessage(&outgoing_message_queue_, action, session_id,\n-                StringBuffer::create(inspector_message));\n-  int err = uv_async_send(&thread_req_);\n-  CHECK_EQ(0, err);\n-}\n-\n-bool InspectorIo::WaitForFrontendEvent() {\n-  // We allow DispatchMessages reentry as we enter the pause. This is important\n-  // to support debugging the code invoked by an inspector call, such\n-  // as Runtime.evaluate\n-  dispatching_messages_ = false;\n-  Mutex::ScopedLock scoped_lock(state_lock_);\n-  if (sessions_.empty())\n-    return false;\n-  if (dispatching_message_queue_.empty() && incoming_message_queue_.empty()) {\n-    incoming_message_cond_.Wait(scoped_lock);\n-  }\n-  return true;\n-}\n-\n-InspectorIoDelegate::InspectorIoDelegate(InspectorIo* io,\n-                                         const std::string& target_id,\n-                                         const std::string& script_path,\n-                                         const std::string& script_name,\n-                                         bool wait)\n-                                         : io_(io),\n-                                           session_id_(0),\n-                                           script_name_(script_name),\n-                                           script_path_(script_path),\n-                                           target_id_(target_id),\n-                                           waiting_(wait),\n-                                           server_(nullptr) { }\n-\n+InspectorIoDelegate::InspectorIoDelegate(\n+    std::shared_ptr<RequestQueueData> queue,\n+    std::shared_ptr<MainThreadHandle> main_thread,\n+    const std::string& target_id,\n+    const std::string& script_path,\n+    const std::string& script_name)\n+    : request_queue_(queue), main_thread_(main_thread),\n+      script_name_(script_name), script_path_(script_path),\n+      target_id_(target_id) {}\n \n void InspectorIoDelegate::StartSession(int session_id,\n                                        const std::string& target_id) {\n-  session_id_ = session_id;\n-  InspectorAction action = InspectorAction::kStartSession;\n-  if (waiting_) {\n-    action = InspectorAction::kStartSessionUnconditionally;\n-    server_->AcceptSession(session_id);\n+  auto session = main_thread_->Connect(\n+      std::unique_ptr<InspectorSessionDelegate>(\n+          new IoSessionDelegate(request_queue_->handle(), session_id)), true);\n+  if (session) {\n+    sessions_[session_id] = std::move(session);\n+    fprintf(stderr, \"Debugger attached.\\n\");\n   }\n-  io_->PostIncomingMessage(action, session_id, \"\");\n }\n \n void InspectorIoDelegate::MessageReceived(int session_id,\n                                           const std::string& message) {\n-  // TODO(pfeldman): Instead of blocking execution while debugger\n-  // engages, node should wait for the run callback from the remote client\n-  // and initiate its startup. This is a change to node.cc that should be\n-  // upstreamed separately.\n-  if (waiting_) {\n-    if (message.find(\"\\\"Runtime.runIfWaitingForDebugger\\\"\") !=\n-        std::string::npos) {\n-      waiting_ = false;\n-      io_->ResumeStartup();\n-    }\n-  }\n-  io_->PostIncomingMessage(InspectorAction::kSendMessage, session_id,\n-                           message);\n+  auto session = sessions_.find(session_id);\n+  if (session != sessions_.end())\n+    session->second->Dispatch(Utf8ToStringView(message)->string());\n }\n \n void InspectorIoDelegate::EndSession(int session_id) {\n-  io_->PostIncomingMessage(InspectorAction::kEndSession, session_id, \"\");\n+  sessions_.erase(session_id);\n }\n \n std::vector<std::string> InspectorIoDelegate::GetTargetIds() {\n@@ -479,10 +351,17 @@ std::string InspectorIoDelegate::GetTargetUrl(const std::string& id) {\n   return \"file://\" + script_path_;\n }\n \n-void IoSessionDelegate::SendMessageToFrontend(\n-    const v8_inspector::StringView& message) {\n-  io_->Write(TransportAction::kSendMessage, id_, message);\n+// static\n+void RequestQueueData::CloseAndFree(RequestQueueData* queue) {\n+  queue->handle_->Reset();\n+  queue->handle_.reset();\n+  uv_close(reinterpret_cast<uv_handle_t*>(&queue->async_),\n+           [](uv_handle_t* handle) {\n+    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);\n+    RequestQueueData* wrapper =\n+        node::ContainerOf(&RequestQueueData::async_, async);\n+    delete wrapper;\n+  });\n }\n-\n }  // namespace inspector\n }  // namespace node"
        },
        {
            "sha": "7c43d212f0422e048e6ab6e321026bce6b4e58c4",
            "filename": "src/inspector_io.h",
            "status": "modified",
            "additions": 29,
            "deletions": 113,
            "changes": 142,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_io.h",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_io.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.h?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -6,8 +6,6 @@\n #include \"node_mutex.h\"\n #include \"uv.h\"\n \n-#include <deque>\n-#include <unordered_map>\n #include <memory>\n #include <stddef.h>\n \n@@ -16,161 +14,79 @@\n #endif\n \n \n-// Forward declaration to break recursive dependency chain with src/env.h.\n-namespace node {\n-class Environment;\n-}  // namespace node\n-\n namespace v8_inspector {\n class StringBuffer;\n class StringView;\n }  // namespace v8_inspector\n \n namespace node {\n+// Forward declaration to break recursive dependency chain with src/env.h.\n+class Environment;\n namespace inspector {\n \n std::string FormatWsAddress(const std::string& host, int port,\n                             const std::string& target_id,\n                             bool include_protocol);\n \n class InspectorIoDelegate;\n-\n-enum class InspectorAction {\n-  kStartSession,\n-  kStartSessionUnconditionally,  // First attach with --inspect-brk\n-  kEndSession,\n-  kSendMessage\n-};\n+class MainThreadHandle;\n+class RequestQueue;\n \n // kKill closes connections and stops the server, kStop only stops the server\n enum class TransportAction {\n   kKill,\n   kSendMessage,\n-  kStop,\n-  kAcceptSession,\n-  kDeclineSession\n+  kStop\n };\n \n class InspectorIo {\n  public:\n-  InspectorIo(node::Environment* env, const std::string& path,\n-              const DebugOptions& options, bool wait_for_connect);\n-\n+  // Start the inspector agent thread, waiting for it to initialize\n+  // bool Start();\n+  // Returns empty pointer if thread was not started\n+  static std::unique_ptr<InspectorIo> Start(\n+      std::shared_ptr<MainThreadHandle> main_thread, const std::string& path,\n+      const DebugOptions& options);\n+\n+  // Will block till the transport thread shuts down\n   ~InspectorIo();\n-  // Start the inspector agent thread, waiting for it to initialize,\n-  // and waiting as well for a connection if wait_for_connect.\n-  bool Start();\n-  // Stop the inspector agent thread.\n-  void Stop();\n-\n-  bool IsStarted();\n-\n-  void WaitForDisconnect();\n-  // Called from thread to queue an incoming message and trigger\n-  // DispatchMessages() on the main thread.\n-  void PostIncomingMessage(InspectorAction action, int session_id,\n-                           const std::string& message);\n-  void ResumeStartup() {\n-    uv_sem_post(&thread_start_sem_);\n-  }\n-  void ServerDone() {\n-    uv_close(reinterpret_cast<uv_handle_t*>(&thread_req_), nullptr);\n-  }\n-  bool WaitForFrontendEvent();\n \n-  int port() const { return port_; }\n+  void StopAcceptingNewConnections();\n   std::string host() const { return options_.host_name(); }\n+  int port() const { return port_; }\n   std::vector<std::string> GetTargetIds() const;\n \n  private:\n-  template <typename Action>\n-  using MessageQueue =\n-      std::deque<std::tuple<Action, int,\n-                  std::unique_ptr<v8_inspector::StringBuffer>>>;\n-  enum class State {\n-    kNew,\n-    kAccepting,\n-    kDone,\n-    kError,\n-    kShutDown\n-  };\n-\n-  // Callback for main_thread_req_'s uv_async_t\n-  static void MainThreadReqAsyncCb(uv_async_t* req);\n+  InspectorIo(std::shared_ptr<MainThreadHandle> handle,\n+              const std::string& path, const DebugOptions& options);\n \n   // Wrapper for agent->ThreadMain()\n   static void ThreadMain(void* agent);\n \n   // Runs a uv_loop_t\n-  template <typename Transport> void ThreadMain();\n-  // Called by ThreadMain's loop when triggered by thread_req_, writes\n-  // messages from outgoing_message_queue to the InspectorSockerServer\n-  template <typename Transport> static void IoThreadAsyncCb(uv_async_t* async);\n-\n-  void DispatchMessages();\n-  // Write action to outgoing_message_queue, and wake the thread\n-  void Write(TransportAction action, int session_id,\n-             const v8_inspector::StringView& message);\n-  // Thread-safe append of message to a queue. Return true if the queue\n-  // used to be empty.\n-  template <typename ActionType>\n-  bool AppendMessage(MessageQueue<ActionType>* vector, ActionType action,\n-                     int session_id,\n-                     std::unique_ptr<v8_inspector::StringBuffer> buffer);\n-  // Used as equivalent of a thread-safe \"pop\" of an entire queue's content.\n-  template <typename ActionType>\n-  void SwapBehindLock(MessageQueue<ActionType>* vector1,\n-                      MessageQueue<ActionType>* vector2);\n-  // Attach session to an inspector. Either kAcceptSession or kDeclineSession\n-  TransportAction Attach(int session_id);\n-\n+  void ThreadMain();\n+\n+  // This is a thread-safe object that will post async tasks. It lives as long\n+  // as an Inspector object lives (almost as long as an Isolate).\n+  std::shared_ptr<MainThreadHandle> main_thread_;\n+  // Used to post on a frontend interface thread, lives while the server is\n+  // running\n+  std::shared_ptr<RequestQueue> request_queue_;\n   const DebugOptions options_;\n \n   // The IO thread runs its own uv_loop to implement the TCP server off\n   // the main thread.\n   uv_thread_t thread_;\n-  // Used by Start() to wait for thread to initialize, or for it to initialize\n-  // and receive a connection if wait_for_connect was requested.\n-  uv_sem_t thread_start_sem_;\n-\n-  State state_;\n-  node::Environment* parent_env_;\n-\n-  // Attached to the uv_loop in ThreadMain()\n-  uv_async_t thread_req_;\n-  // Note that this will live while the async is being closed - likely, past\n-  // the parent object lifespan\n-  std::pair<uv_async_t, Agent*>* main_thread_req_;\n-  // Will be used to post tasks from another thread\n-  v8::Platform* const platform_;\n-\n-  // Message queues\n-  ConditionVariable incoming_message_cond_;\n-  Mutex state_lock_;  // Locked before mutating either queue.\n-  MessageQueue<InspectorAction> incoming_message_queue_;\n-  MessageQueue<TransportAction> outgoing_message_queue_;\n-  // This queue is to maintain the order of the messages for the cases\n-  // when we reenter the DispatchMessages function.\n-  MessageQueue<InspectorAction> dispatching_message_queue_;\n-\n-  bool dispatching_messages_;\n \n+  // For setting up interthread communications\n+  Mutex thread_start_lock_;\n+  ConditionVariable thread_start_condition_;\n   std::string script_name_;\n-  std::string script_path_;\n-  const bool wait_for_connect_;\n-  int port_;\n-  std::unordered_map<int, std::unique_ptr<InspectorSession>> sessions_;\n+  int port_ = -1;\n   // May be accessed from any thread\n   const std::string id_;\n-\n-  friend class DispatchMessagesTask;\n-  friend class IoSessionDelegate;\n-  friend void InterruptCallback(v8::Isolate*, void* agent);\n };\n \n-std::unique_ptr<v8_inspector::StringBuffer> Utf8ToStringView(\n-    const std::string& message);\n-\n }  // namespace inspector\n }  // namespace node\n "
        },
        {
            "sha": "a8e2e8ecafeefe43740073cda606ca8a3544fc14",
            "filename": "src/inspector_js_api.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_js_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_js_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_js_api.cc?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -66,7 +66,7 @@ class JSBindingsConnection : public AsyncWrap {\n                          callback_(env->isolate(), callback) {\n     Agent* inspector = env->inspector_agent();\n     session_ = inspector->Connect(std::unique_ptr<JSBindingsSessionDelegate>(\n-        new JSBindingsSessionDelegate(env, this)));\n+        new JSBindingsSessionDelegate(env, this)), false);\n   }\n \n   void OnMessage(Local<Value> value) {\n@@ -116,7 +116,7 @@ class JSBindingsConnection : public AsyncWrap {\n \n static bool InspectorEnabled(Environment* env) {\n   Agent* agent = env->inspector_agent();\n-  return agent->io() != nullptr || agent->HasConnectedSessions();\n+  return agent->IsActive();\n }\n \n void AddCommandLineAPI(const FunctionCallbackInfo<Value>& info) {\n@@ -251,8 +251,9 @@ void Open(const FunctionCallbackInfo<Value>& args) {\n   if (args.Length() > 2 && args[2]->IsBoolean()) {\n     wait_for_connect = args[2]->BooleanValue(env->context()).FromJust();\n   }\n-\n-  agent->StartIoThread(wait_for_connect);\n+  agent->StartIoThread();\n+  if (wait_for_connect)\n+    agent->WaitForConnect();\n }\n \n void Url(const FunctionCallbackInfo<Value>& args) {\n@@ -283,7 +284,7 @@ void Initialize(Local<Object> target, Local<Value> unused,\n   Agent* agent = env->inspector_agent();\n   env->SetMethod(target, \"consoleCall\", InspectorConsoleCall);\n   env->SetMethod(target, \"addCommandLineAPI\", AddCommandLineAPI);\n-  if (agent->IsWaitingForConnect())\n+  if (agent->WillWaitForConnect())\n     env->SetMethod(target, \"callAndPauseOnStart\", CallAndPauseOnStart);\n   env->SetMethod(target, \"open\", Open);\n   env->SetMethodNoSideEffect(target, \"url\", Url);"
        },
        {
            "sha": "1621b408b43274a315454e93c0a90855cf00eb01",
            "filename": "src/inspector_socket_server.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 25,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_socket_server.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_socket_server.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_socket_server.cc?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -173,11 +173,8 @@ class SocketSession {\n   InspectorSocket* ws_socket() {\n     return ws_socket_.get();\n   }\n-  void set_ws_key(const std::string& ws_key) {\n-    ws_key_ = ws_key;\n-  }\n-  void Accept() {\n-    ws_socket_->AcceptUpgrade(ws_key_);\n+  void Accept(const std::string& ws_key) {\n+    ws_socket_->AcceptUpgrade(ws_key);\n   }\n   void Decline() {\n     ws_socket_->CancelHandshake();\n@@ -208,7 +205,6 @@ class SocketSession {\n   const int id_;\n   InspectorSocket::Pointer ws_socket_;\n   const int server_port_;\n-  std::string ws_key_;\n };\n \n class ServerSocket {\n@@ -260,11 +256,11 @@ void InspectorSocketServer::SessionStarted(int session_id,\n                                            const std::string& ws_key) {\n   SocketSession* session = Session(session_id);\n   if (!TargetExists(id)) {\n-    Session(session_id)->Decline();\n+    session->Decline();\n     return;\n   }\n   connected_sessions_[session_id].first = id;\n-  session->set_ws_key(ws_key);\n+  session->Accept(ws_key);\n   delegate_->StartSession(session_id, id);\n }\n \n@@ -404,6 +400,8 @@ bool InspectorSocketServer::Start() {\n }\n \n void InspectorSocketServer::Stop() {\n+  if (state_ == ServerState::kStopped)\n+    return;\n   CHECK_EQ(state_, ServerState::kRunning);\n   state_ = ServerState::kStopped;\n   server_sockets_.clear();\n@@ -446,23 +444,6 @@ void InspectorSocketServer::Accept(int server_port,\n   }\n }\n \n-void InspectorSocketServer::AcceptSession(int session_id) {\n-  SocketSession* session = Session(session_id);\n-  if (session == nullptr) {\n-    delegate_->EndSession(session_id);\n-  } else {\n-    session->Accept();\n-  }\n-}\n-\n-void InspectorSocketServer::DeclineSession(int session_id) {\n-  auto it = connected_sessions_.find(session_id);\n-  if (it != connected_sessions_.end()) {\n-    it->second.first.clear();\n-    it->second.second->Decline();\n-  }\n-}\n-\n void InspectorSocketServer::Send(int session_id, const std::string& message) {\n   SocketSession* session = Session(session_id);\n   if (session != nullptr) {"
        },
        {
            "sha": "271be6ec555bf1d4ddf649a16fc2d09ecfc5d214",
            "filename": "src/inspector_socket_server.h",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_socket_server.h",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Finspector_socket_server.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_socket_server.h?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -54,10 +54,6 @@ class InspectorSocketServer {\n   void Send(int session_id, const std::string& message);\n   //   kKill\n   void TerminateConnections();\n-  //   kAcceptSession\n-  void AcceptSession(int session_id);\n-  //   kDeclineSession\n-  void DeclineSession(int session_id);\n   int Port() const;\n \n   // Session connection lifecycle"
        },
        {
            "sha": "1fbd43b26c7a48bbf2abeacfe1295b65d1066302",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -321,11 +321,12 @@ static struct {\n     // Inspector agent can't fail to start, but if it was configured to listen\n     // right away on the websocket port and fails to bind/etc, this will return\n     // false.\n-    return env->inspector_agent()->Start(script_path, options);\n+    return env->inspector_agent()->Start(\n+        script_path == nullptr ? \"\" : script_path, options);\n   }\n \n   bool InspectorStarted(Environment* env) {\n-    return env->inspector_agent()->IsStarted();\n+    return env->inspector_agent()->IsListening();\n   }\n #endif  // HAVE_INSPECTOR\n \n@@ -1104,7 +1105,7 @@ NO_RETURN void Assert(const char* const (*args)[4]) {\n \n static void WaitForInspectorDisconnect(Environment* env) {\n #if HAVE_INSPECTOR\n-  if (env->inspector_agent()->HasConnectedSessions()) {\n+  if (env->inspector_agent()->IsActive()) {\n     // Restore signal dispositions, the app is done and is no longer\n     // capable of handling signals.\n #if defined(__POSIX__) && !defined(NODE_SHARED_MODE)\n@@ -2968,7 +2969,7 @@ static void ParseArgs(int* argc,\n static void StartInspector(Environment* env, const char* path,\n                            DebugOptions debug_options) {\n #if HAVE_INSPECTOR\n-  CHECK(!env->inspector_agent()->IsStarted());\n+  CHECK(!env->inspector_agent()->IsListening());\n   v8_platform.StartInspector(env, path, debug_options);\n #endif  // HAVE_INSPECTOR\n }\n@@ -3111,7 +3112,7 @@ static void DebugProcess(const FunctionCallbackInfo<Value>& args) {\n static void DebugEnd(const FunctionCallbackInfo<Value>& args) {\n #if HAVE_INSPECTOR\n   Environment* env = Environment::GetCurrent(args);\n-  if (env->inspector_agent()->IsStarted()) {\n+  if (env->inspector_agent()->IsListening()) {\n     env->inspector_agent()->Stop();\n   }\n #endif"
        },
        {
            "sha": "5568d22e4c62284d2d2bb0d035a69c8bf070696c",
            "filename": "src/signal_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Fsignal_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/src%2Fsignal_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fsignal_wrap.cc?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -90,7 +90,7 @@ class SignalWrap : public HandleWrap {\n #if defined(__POSIX__) && HAVE_INSPECTOR\n     if (signum == SIGPROF) {\n       Environment* env = Environment::GetCurrent(args);\n-      if (env->inspector_agent()->IsStarted()) {\n+      if (env->inspector_agent()->IsListening()) {\n         ProcessEmitWarning(env,\n                            \"process.on(SIGPROF) is reserved while debugging\");\n         return;"
        },
        {
            "sha": "349356ef56c9fc1000c4c9f0d780b88d91f062e1",
            "filename": "test/cctest/test_inspector_socket_server.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 24,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/test%2Fcctest%2Ftest_inspector_socket_server.cc",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/test%2Fcctest%2Ftest_inspector_socket_server.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcctest%2Ftest_inspector_socket_server.cc?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -14,7 +14,6 @@ static const char CLIENT_CLOSE_FRAME[] = \"\\x88\\x80\\x2D\\x0E\\x1E\\xFA\";\n static const char SERVER_CLOSE_FRAME[] = \"\\x88\\x00\";\n \n static const char MAIN_TARGET_ID[] = \"main-target\";\n-static const char UNCONNECTABLE_TARGET_ID[] = \"unconnectable-target\";\n \n static const char WS_HANDSHAKE_RESPONSE[] =\n     \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n@@ -258,10 +257,6 @@ class ServerHolder {\n     return server_->done();\n   }\n \n-  void Connected() {\n-    connected++;\n-  }\n-\n   void Disconnected() {\n     disconnected++;\n   }\n@@ -270,9 +265,10 @@ class ServerHolder {\n     delegate_done = true;\n   }\n \n-  void PrepareSession(int id) {\n+  void Connected(int id) {\n     buffer_.clear();\n     session_id_ = id;\n+    connected++;\n   }\n \n   void Received(const std::string& message) {\n@@ -319,15 +315,9 @@ class TestSocketServerDelegate : public SocketServerDelegate {\n \n   void StartSession(int session_id, const std::string& target_id) override {\n     session_id_ = session_id;\n-    harness_->PrepareSession(session_id_);\n     CHECK_NE(targets_.end(),\n              std::find(targets_.begin(), targets_.end(), target_id));\n-    if (target_id == UNCONNECTABLE_TARGET_ID) {\n-      server_->DeclineSession(session_id);\n-      return;\n-    }\n-    harness_->Connected();\n-    server_->AcceptSession(session_id);\n+    harness_->Connected(session_id_);\n   }\n \n   void MessageReceived(int session_id, const std::string& message) override {\n@@ -363,7 +353,7 @@ ServerHolder::ServerHolder(bool has_targets, uv_loop_t* loop,\n                            const std::string host, int port, FILE* out) {\n   std::vector<std::string> targets;\n   if (has_targets)\n-    targets = { MAIN_TARGET_ID, UNCONNECTABLE_TARGET_ID };\n+    targets = { MAIN_TARGET_ID };\n   std::unique_ptr<TestSocketServerDelegate> delegate(\n       new TestSocketServerDelegate(this, targets));\n   server_.reset(\n@@ -414,15 +404,6 @@ TEST_F(InspectorSocketServerTest, InspectorSessions) {\n \n   well_behaved_socket.Close();\n \n-  // Declined connection\n-  SocketWrapper declined_target_socket(&loop);\n-  declined_target_socket.Connect(HOST, server.port());\n-  declined_target_socket.Write(WsHandshakeRequest(UNCONNECTABLE_TARGET_ID));\n-  declined_target_socket.Expect(\"HTTP/1.0 400 Bad Request\");\n-  declined_target_socket.ExpectEOF();\n-  EXPECT_EQ(1, server.connected);\n-  EXPECT_EQ(1, server.disconnected);\n-\n   // Bogus target - start session callback should not even be invoked\n   SocketWrapper bogus_target_socket(&loop);\n   bogus_target_socket.Connect(HOST, server.port());\n@@ -491,7 +472,7 @@ TEST_F(InspectorSocketServerTest, ServerWithoutTargets) {\n   // Declined connection\n   SocketWrapper socket(&loop);\n   socket.Connect(HOST, server.port());\n-  socket.Write(WsHandshakeRequest(UNCONNECTABLE_TARGET_ID));\n+  socket.Write(WsHandshakeRequest(\"any target id\"));\n   socket.Expect(\"HTTP/1.0 400 Bad Request\");\n   socket.ExpectEOF();\n   server->Stop();"
        },
        {
            "sha": "e5335215d743b66ed4ee5bc9574ec36ce06d366c",
            "filename": "test/parallel/test-warn-sigprof.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/39977db7c015e94d33885249f50e62fa8b1f1bb9/test%2Fparallel%2Ftest-warn-sigprof.js",
            "raw_url": "https://github.com/nodejs/node/raw/39977db7c015e94d33885249f50e62fa8b1f1bb9/test%2Fparallel%2Ftest-warn-sigprof.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-warn-sigprof.js?ref=39977db7c015e94d33885249f50e62fa8b1f1bb9",
            "patch": "@@ -1,3 +1,4 @@\n+// Flags: --inspect=0\n 'use strict';\n const common = require('../common');\n "
        }
    ],
    "stats": {
        "total": 1524,
        "additions": 890,
        "deletions": 634
    }
}