{
    "author": "unknown",
    "message": "n-api: add API for asynchronous functions\n\nBundle a `uv_async_t`, a `uv_idle_t`, a `uv_mutex_t`, a `uv_cond_t`,\nand a `v8::Persistent<v8::Function>` to make it possible to call into JS\nfrom another thread. The API accepts a void data pointer and a callback\nwhich will be invoked on the loop thread and which will receive the\n`napi_value` representing the JavaScript function to call so as to\nperform the call into JS. The callback is run inside a\n`node::CallbackScope`.\n\nA `std::queue<void*>` is used to store calls from the secondary\nthreads, and an idle loop is started by the `uv_async_t` callback on the\nloop thread to drain the queue, calling into JS with each item.\n\nItems can be added to the queue blockingly or non-blockingly.\n\nThe thread-safe function can be referenced or unreferenced, with the\nsame semantics as libuv handles.\n\nRe: https://github.com/nodejs/help/issues/1035\nRe: https://github.com/nodejs/node/issues/20964\nFixes: https://github.com/nodejs/node/issues/13512\nPR-URL: https://github.com/nodejs/node/pull/17887\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>",
    "sha": "81f06ba7e49d9c077c209ab9c9de63bad08aa801",
    "files": [
        {
            "sha": "c0b2564e2b0c6e236231df8733ae959d3d11c21f",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/81f06ba7e49d9c077c209ab9c9de63bad08aa801/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/81f06ba7e49d9c077c209ab9c9de63bad08aa801/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=81f06ba7e49d9c077c209ab9c9de63bad08aa801",
            "patch": "@@ -1376,6 +1376,31 @@ multiple of the element size.\n While calling `napi_create_typedarray()`, `(length * size_of_element) +\n byte_offset` was larger than the length of given `buffer`.\n \n+<a id=\"ERR_NAPI_TSFN_CALL_JS\"></a>\n+### ERR_NAPI_TSFN_CALL_JS\n+\n+An error occurred while invoking the JavaScript portion of the thread-safe\n+function.\n+\n+<a id=\"ERR_NAPI_TSFN_GET_UNDEFINED\"></a>\n+### ERR_NAPI_TSFN_GET_UNDEFINED\n+\n+An error occurred while attempting to retrieve the JavaScript `undefined`\n+value.\n+\n+<a id=\"ERR_NAPI_TSFN_START_IDLE_LOOP\"></a>\n+### ERR_NAPI_TSFN_START_IDLE_LOOP\n+\n+On the main thread, values are removed from the queue associated with the\n+thread-safe function in an idle loop. This error indicates that an error\n+has occurred when attemping to start the loop.\n+\n+<a id=\"ERR_NAPI_TSFN_STOP_IDLE_LOOP\"></a>\n+### ERR_NAPI_TSFN_STOP_IDLE_LOOP\n+\n+Once no more items are left in the queue, the idle loop must be suspended. This\n+error indicates that the idle loop has failed to stop.\n+\n <a id=\"ERR_NO_CRYPTO\"></a>\n ### ERR_NO_CRYPTO\n "
        },
        {
            "sha": "ff90249606cfbba17f10b731d7c7bfe996ff9177",
            "filename": "doc/api/n-api.md",
            "status": "modified",
            "additions": 373,
            "deletions": 1,
            "changes": 374,
            "blob_url": "https://github.com/nodejs/node/blob/81f06ba7e49d9c077c209ab9c9de63bad08aa801/doc%2Fapi%2Fn-api.md",
            "raw_url": "https://github.com/nodejs/node/raw/81f06ba7e49d9c077c209ab9c9de63bad08aa801/doc%2Fapi%2Fn-api.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fn-api.md?ref=81f06ba7e49d9c077c209ab9c9de63bad08aa801",
            "patch": "@@ -75,7 +75,11 @@ typedef enum {\n   napi_cancelled,\n   napi_escape_called_twice,\n   napi_handle_scope_mismatch,\n-  napi_callback_scope_mismatch\n+  napi_callback_scope_mismatch,\n+#ifdef NAPI_EXPERIMENTAL\n+  napi_queue_full,\n+  napi_closing,\n+#endif  // NAPI_EXPERIMENTAL\n } napi_status;\n ```\n If additional information is required upon an API returning a failed status,\n@@ -113,6 +117,43 @@ not allowed.\n ### napi_value\n This is an opaque pointer that is used to represent a JavaScript value.\n \n+### napi_threadsafe_function\n+\n+> Stability: 1 - Experimental\n+\n+This is an opaque pointer that represents a JavaScript function which can be\n+called asynchronously from multiple threads via\n+`napi_call_threadsafe_function()`.\n+\n+### napi_threadsafe_function_release_mode\n+\n+> Stability: 1 - Experimental\n+\n+A value to be given to `napi_release_threadsafe_function()` to indicate whether\n+the thread-safe function is to be closed immediately (`napi_tsfn_abort`) or\n+merely released (`napi_tsfn_release`) and thus available for subsequent use via\n+`napi_acquire_threadsafe_function()` and `napi_call_threadsafe_function()`.\n+```C\n+typedef enum {\n+  napi_tsfn_release,\n+  napi_tsfn_abort\n+} napi_threadsafe_function_release_mode;\n+```\n+\n+### napi_threadsafe_function_call_mode\n+\n+> Stability: 1 - Experimental\n+\n+A value to be given to `napi_call_threadsafe_function()` to indicate whether\n+the call should block whenever the queue associated with the thread-safe\n+function is full.\n+```C\n+typedef enum {\n+  napi_tsfn_nonblocking,\n+  napi_tsfn_blocking\n+} napi_threadsafe_function_call_mode;\n+```\n+\n ### N-API Memory Management types\n #### napi_handle_scope\n This is an abstraction used to control and modify the lifetime of objects\n@@ -194,6 +235,43 @@ typedef void (*napi_async_complete_callback)(napi_env env,\n                                              void* data);\n ```\n \n+#### napi_threadsafe_function_call_js\n+\n+> Stability: 1 - Experimental\n+\n+Function pointer used with asynchronous thread-safe function calls. The callback\n+will be called on the main thread. Its purpose is to use a data item arriving\n+via the queue from one of the secondary threads to construct the parameters\n+necessary for a call into JavaScript, usually via `napi_call_function`, and then\n+make the call into JavaScript.\n+\n+The data arriving from the secondary thread via the queue is given in the `data`\n+parameter and the JavaScript function to call is given in the `js_callback`\n+parameter.\n+\n+N-API sets up the environment prior to calling this callback, so it is\n+sufficient to call the JavaScript function via `napi_call_function` rather than\n+via `napi_make_callback`.\n+\n+Callback functions must satisfy the following signature:\n+```C\n+typedef void (*napi_threadsafe_function_call_js)(napi_env env,\n+                                                 napi_value js_callback,\n+                                                 void* context,\n+                                                 void* data);\n+```\n+- `[in] env`: The environment to use for API calls, or `NULL` if the thread-safe\n+function is being torn down and `data` may need to be freed.\n+- `[in] js_callback`: The JavaScript function to call, or `NULL` if the\n+thread-safe function is being torn down and `data` may need to be freed.\n+- `[in] context`: The optional data with which the thread-safe function was\n+created.\n+- `[in] data`: Data created by the secondary thread. It is the responsibility of\n+the callback to convert this native data to JavaScript values (with N-API\n+functions) that can be passed as parameters when `js_callback` is invoked. This\n+pointer is managed entirely by the threads and this callback. Thus this callback\n+should free the data.\n+\n ## Error Handling\n N-API uses both return values and JavaScript exceptions for error handling.\n The following sections explain the approach for each case.\n@@ -3851,6 +3929,298 @@ NAPI_EXTERN napi_status napi_get_uv_event_loop(napi_env env,\n - `[in] env`: The environment that the API is invoked under.\n - `[out] loop`: The current libuv loop instance.\n \n+<!-- it's very convenient to have all the anchors indexed -->\n+<!--lint disable no-unused-definitions remark-lint-->\n+## Asynchronous Thread-safe Function Calls\n+\n+> Stability: 1 - Experimental\n+\n+JavaScript functions can normally only be called from a native addon's main\n+thread. If an addon creates additional threads, then N-API functions that\n+require a `napi_env`, `napi_value`, or `napi_ref` must not be called from those\n+threads.\n+\n+When an addon has additional threads and JavaScript functions need to be invoked\n+based on the processing completed by those threads, those threads must\n+communicate with the addon's main thread so that the main thread can invoke the\n+JavaScript function on their behalf. The thread-safe function APIs provide an\n+easy way to do this.\n+\n+These APIs provide the type `napi_threadsafe_function` as well as APIs to\n+create, destroy, and call objects of this type.\n+`napi_create_threadsafe_function()` creates a persistent reference to a\n+`napi_value` that holds a JavaScript function which can be called from multiple\n+threads. The calls happen asynchronously. This means that values with which the\n+JavaScript callback is to be called will be placed in a queue, and, for each\n+value in the queue, a call will eventually be made to the JavaScript function.\n+\n+Upon creation of a `napi_threadsafe_function` a `napi_finalize` callback can be\n+provided. This callback will be invoked on the main thread when the thread-safe\n+function is about to be destroyed. It receives the context and the finalize data\n+given during construction, and provides an opportunity for cleaning up after the\n+threads e.g. by calling `uv_thread_join()`. **It is important that, aside from\n+the main loop thread, there be no threads left using the thread-safe function\n+after the finalize callback completes.**\n+\n+The `context` given during the call to `napi_create_threadsafe_function()` can\n+be retrieved from any thread with a call to\n+`napi_get_threadsafe_function_context()`.\n+\n+`napi_call_threadsafe_function()` can then be used for initiating a call into\n+JavaScript. `napi_call_threadsafe_function()` accepts a parameter which controls\n+whether the API behaves blockingly. If set to `napi_tsfn_nonblocking`, the API\n+behaves non-blockingly, returning `napi_queue_full` if the queue was full,\n+preventing data from being successfully added to the queue. If set to\n+`napi_tsfn_blocking`, the API blocks until space becomes available in the queue.\n+`napi_call_threadsafe_function()` never blocks if the thread-safe function was\n+created with a maximum queue size of 0.\n+\n+The actual call into JavaScript is controlled by the callback given via the\n+`call_js_cb` parameter. `call_js_cb` is invoked on the main thread once for each\n+value that was placed into the queue by a successful call to\n+`napi_call_threadsafe_function()`. If such a callback is not given, a default\n+callback will be used, and the resulting JavaScript call will have no arguments.\n+The `call_js_cb` callback receives the JavaScript function to call as a\n+`napi_value` in its parameters, as well as the `void*` context pointer used when\n+creating the `napi_threadsafe_function`, and the next data pointer that was\n+created by one of the secondary threads. The callback can then use an API such\n+as `napi_call_function()` to call into JavaScript.\n+\n+The callback may also be invoked with `env` and `call_js_cb` both set to `NULL`\n+to indicate that calls into JavaScript are no longer possible, while items\n+remain in the queue that may need to be freed. This normally occurs when the\n+Node.js process exits while there is a thread-safe function still active.\n+\n+It is not necessary to call into JavaScript via `napi_make_callback()` because\n+N-API runs `call_js_cb` in a context appropriate for callbacks.\n+\n+Threads can be added to and removed from a `napi_threadsafe_function` object\n+during its existence. Thus, in addition to specifying an initial number of\n+threads upon creation, `napi_acquire_threadsafe_function` can be called to\n+indicate that a new thread will start making use of the thread-safe function.\n+Similarly, `napi_release_threadsafe_function` can be called to indicate that an\n+existing thread will stop making use of the thread-safe function.\n+\n+`napi_threadsafe_function` objects are destroyed when every thread which uses\n+the object has called `napi_release_threadsafe_function()` or has received a\n+return status of `napi_closing` in response to a call to\n+`napi_call_threadsafe_function`. The queue is emptied before the\n+`napi_threadsafe_function` is destroyed. It is important that\n+`napi_release_threadsafe_function()` be the last API call made in conjunction\n+with a given `napi_threadsafe_function`, because after the call completes, there\n+is no guarantee that the `napi_threadsafe_function` is still allocated. For the\n+same reason it is also important that no more use be made of a thread-safe\n+function after receiving a return value of `napi_closing` in response to a call\n+to `napi_call_threadsafe_function`. Data associated with the\n+`napi_threadsafe_function` can be freed in its `napi_finalize` callback which\n+was passed to `napi_create_threadsafe_function()`.\n+\n+Once the number of threads making use of a `napi_threadsafe_function` reaches\n+zero, no further threads can start making use of it by calling\n+`napi_acquire_threadsafe_function()`. In fact, all subsequent API calls\n+associated with it, except `napi_release_threadsafe_function()`, will return an\n+error value of `napi_closing`.\n+\n+The thread-safe function can be \"aborted\" by giving a value of `napi_tsfn_abort`\n+to `napi_release_threadsafe_function()`. This will cause all subsequent APIs\n+associated with the thread-safe function except\n+`napi_release_threadsafe_function()` to return `napi_closing` even before its\n+reference count reaches zero. In particular, `napi_call_threadsafe_function()`\n+will return `napi_closing`, thus informing the threads that it is no longer\n+possible to make asynchronous calls to the thread-safe function. This can be\n+used as a criterion for terminating the thread. **Upon receiving a return value\n+of `napi_closing` from `napi_call_threadsafe_function()` a thread must make no\n+further use of the thread-safe function because it is no longer guaranteed to\n+be allocated.**\n+\n+Similarly to libuv handles, thread-safe functions can be \"referenced\" and\n+\"unreferenced\". A \"referenced\" thread-safe function will cause the event loop on\n+the thread on which it is created to remain alive until the thread-safe function\n+is destroyed. In contrast, an \"unreferenced\" thread-safe function will not\n+prevent the event loop from exiting. The APIs `napi_ref_threadsafe_function` and\n+`napi_unref_threadsafe_function` exist for this purpose.\n+\n+### napi_create_threadsafe_function\n+\n+> Stability: 1 - Experimental\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+```C\n+NAPI_EXTERN napi_status\n+napi_create_threadsafe_function(napi_env env,\n+                                napi_value func,\n+                                napi_value async_resource,\n+                                napi_value async_resource_name,\n+                                size_t max_queue_size,\n+                                size_t initial_thread_count,\n+                                void* thread_finalize_data,\n+                                napi_finalize thread_finalize_cb,\n+                                void* context,\n+                                napi_threadsafe_function_call_js call_js_cb,\n+                                napi_threadsafe_function* result);\n+```\n+\n+- `[in] env`: The environment that the API is invoked under.\n+- `[in] func`: The JavaScript function to call from another thread.\n+- `[in] async_resource`: An optional object associated with the async work that\n+will be passed to possible `async_hooks` [`init` hooks][].\n+- `[in] async_resource_name`: A javaScript string to provide an identifier for\n+the kind of resource that is being provided for diagnostic information exposed\n+by the `async_hooks` API.\n+- `[in] max_queue_size`: Maximum size of the queue. 0 for no limit.\n+- `[in] initial_thread_count`: The initial number of threads, including the main\n+thread, which will be making use of this function.\n+- `[in] thread_finalize_data`: Data to be passed to `thread_finalize_cb`.\n+- `[in] thread_finalize_cb`: Function to call when the\n+`napi_threadsafe_function` is being destroyed.\n+- `[in] context`: Optional data to attach to the resulting\n+`napi_threadsafe_function`.\n+- `[in] call_js_cb`: Optional callback which calls the JavaScript function in\n+response to a call on a different thread. This callback will be called on the\n+main thread. If not given, the JavaScript function will be called with no\n+parameters and with `undefined` as its `this` value.\n+- `[out] result`: The asynchronous thread-safe JavaScript function.\n+\n+### napi_get_threadsafe_function_context\n+\n+> Stability: 1 - Experimental\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+```C\n+NAPI_EXTERN napi_status\n+napi_get_threadsafe_function_context(napi_threadsafe_function func,\n+                                     void** result);\n+```\n+\n+- `[in] func`: The thread-safe function for which to retrieve the context.\n+- `[out] context`: The location where to store the context.\n+\n+This API may be called from any thread which makes use of `func`.\n+\n+### napi_call_threadsafe_function\n+\n+> Stability: 1 - Experimental\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+```C\n+NAPI_EXTERN napi_status\n+napi_call_threadsafe_function(napi_threadsafe_function func,\n+                              void* data,\n+                              napi_threadsafe_function_call_mode is_blocking);\n+```\n+\n+- `[in] func`: The asynchronous thread-safe JavaScript function to invoke.\n+- `[in] data`: Data to send into JavaScript via the callback `call_js_cb`\n+provided during the creation of the thread-safe JavaScript function.\n+- `[in] is_blocking`: Flag whose value can be either `napi_tsfn_blocking` to\n+indicate that the call should block if the queue is full or\n+`napi_tsfn_nonblocking` to indicate that the call should return immediately with\n+a status of `napi_queue_full` whenever the queue is full.\n+\n+This API will return `napi_closing` if `napi_release_threadsafe_function()` was\n+called with `abort` set to `napi_tsfn_abort` from any thread. The value is only\n+added to the queue if the API returns `napi_ok`.\n+\n+This API may be called from any thread which makes use of `func`.\n+\n+### napi_acquire_threadsafe_function\n+\n+> Stability: 1 - Experimental\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+```C\n+NAPI_EXTERN napi_status\n+napi_acquire_threadsafe_function(napi_threadsafe_function func);\n+```\n+\n+- `[in] func`: The asynchronous thread-safe JavaScript function to start making\n+use of.\n+\n+A thread should call this API before passing `func` to any other thread-safe\n+function APIs to indicate that it will be making use of `func`. This prevents\n+`func` from being destroyed when all other threads have stopped making use of\n+it.\n+\n+This API may be called from any thread which will start making use of `func`.\n+\n+### napi_release_threadsafe_function\n+\n+> Stability: 1 - Experimental\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+```C\n+NAPI_EXTERN napi_status\n+napi_release_threadsafe_function(napi_threadsafe_function func,\n+                                 napi_threadsafe_function_release_mode mode);\n+```\n+\n+- `[in] func`: The asynchronous thread-safe JavaScript function whose reference\n+count to decrement.\n+- `[in] mode`: Flag whose value can be either `napi_tsfn_release` to indicate\n+that the current thread will make no further calls to the thread-safe function,\n+or `napi_tsfn_abort` to indicate that in addition to the current thread, no\n+other thread should make any further calls to the thread-safe function. If set\n+to `napi_tsfn_abort`, further calls to `napi_call_threadsafe_function()` will\n+return `napi_closing`, and no further values will be placed in the queue.\n+\n+A thread should call this API when it stops making use of `func`. Passing `func`\n+to any thread-safe APIs after having called this API has undefined results, as\n+`func` may have been destroyed.\n+\n+This API may be called from any thread which will stop making use of `func`.\n+\n+### napi_ref_threadsafe_function\n+\n+> Stability: 1 - Experimental\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+```C\n+NAPI_EXTERN napi_status\n+napi_ref_threadsafe_function(napi_env env, napi_threadsafe_function func);\n+```\n+\n+- `[in] env`: The environment that the API is invoked under.\n+- `[in] func`: The thread-safe function to reference.\n+\n+This API is used to indicate that the event loop running on the main thread\n+should not exit until `func` has been destroyed. Similar to [`uv_ref`][] it is\n+also idempotent.\n+\n+This API may only be called from the main thread.\n+\n+### napi_unref_threadsafe_function\n+\n+> Stability: 1 - Experimental\n+\n+<!-- YAML\n+added: REPLACEME\n+-->\n+```C\n+NAPI_EXTERN napi_status\n+napi_unref_threadsafe_function(napi_env env, napi_threadsafe_function func);\n+```\n+\n+- `[in] env`: The environment that the API is invoked under.\n+- `[in] func`: The thread-safe function to unreference.\n+\n+This API is used to indicate that the event loop running on the main thread\n+may exit before `func` is destroyed. Similar to [`uv_unref`][] it is also\n+idempotent.\n+\n+This API may only be called from the main thread.\n+\n [ECMAScript Language Specification]: https://tc39.github.io/ecma262/\n [Error Handling]: #n_api_error_handling\n [Native Abstractions for Node.js]: https://github.com/nodejs/nan\n@@ -3913,6 +4283,8 @@ NAPI_EXTERN napi_status napi_get_uv_event_loop(napi_env env,\n [`napi_throw_type_error`]: #n_api_napi_throw_type_error\n [`napi_unwrap`]: #n_api_napi_unwrap\n [`napi_wrap`]: #n_api_napi_wrap\n+[`uv_ref`]: http://docs.libuv.org/en/v1.x/handle.html#c.uv_ref\n+[`uv_unref`]: http://docs.libuv.org/en/v1.x/handle.html#c.uv_unref\n \n [`process.release`]: process.html#process_process_release\n [`init` hooks]: async_hooks.html#async_hooks_init_asyncid_type_triggerasyncid_resource"
        },
        {
            "sha": "c32e63ea2331ba51b4eb2e917b17db65cd7d5646",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 438,
            "deletions": 2,
            "changes": 440,
            "blob_url": "https://github.com/nodejs/node/blob/81f06ba7e49d9c077c209ab9c9de63bad08aa801/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/81f06ba7e49d9c077c209ab9c9de63bad08aa801/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=81f06ba7e49d9c077c209ab9c9de63bad08aa801",
            "patch": "@@ -5,6 +5,7 @@\n #include <algorithm>\n #include <cmath>\n #include <vector>\n+#define NAPI_EXPERIMENTAL\n #include \"node_api.h\"\n #include \"node_internals.h\"\n #include \"env.h\"\n@@ -923,7 +924,10 @@ const char* error_messages[] = {nullptr,\n                                 \"The async work item was cancelled\",\n                                 \"napi_escape_handle already called on scope\",\n                                 \"Invalid handle scope usage\",\n-                                \"Invalid callback scope usage\"};\n+                                \"Invalid callback scope usage\",\n+                                \"Thread-safe function queue is full\",\n+                                \"Thread-safe function handle is closing\"\n+};\n \n static inline napi_status napi_clear_last_error(napi_env env) {\n   env->last_error.error_code = napi_ok;\n@@ -954,7 +958,7 @@ napi_status napi_get_last_error_info(napi_env env,\n   // We don't have a napi_status_last as this would result in an ABI\n   // change each time a message was added.\n   static_assert(\n-      node::arraysize(error_messages) == napi_callback_scope_mismatch + 1,\n+      node::arraysize(error_messages) == napi_closing + 1,\n       \"Count of error messages must match count of error values\");\n   CHECK_LE(env->last_error.error_code, napi_callback_scope_mismatch);\n \n@@ -3553,3 +3557,435 @@ napi_status napi_run_script(napi_env env,\n   *result = v8impl::JsValueFromV8LocalValue(script_result.ToLocalChecked());\n   return GET_RETURN_STATUS(env);\n }\n+\n+class TsFn: public node::AsyncResource {\n+ public:\n+  TsFn(v8::Local<v8::Function> func,\n+       v8::Local<v8::Object> resource,\n+       v8::Local<v8::String> name,\n+       size_t thread_count_,\n+       void* context_,\n+       size_t max_queue_size_,\n+       napi_env env_,\n+       void* finalize_data_,\n+       napi_finalize finalize_cb_,\n+       napi_threadsafe_function_call_js call_js_cb_):\n+      AsyncResource(env_->isolate,\n+                    resource,\n+                    *v8::String::Utf8Value(env_->isolate, name)),\n+      thread_count(thread_count_),\n+      is_closing(false),\n+      context(context_),\n+      max_queue_size(max_queue_size_),\n+      env(env_),\n+      finalize_data(finalize_data_),\n+      finalize_cb(finalize_cb_),\n+      idle_running(false),\n+      call_js_cb(call_js_cb_ == nullptr ? CallJs : call_js_cb_),\n+      handles_closing(false) {\n+    ref.Reset(env->isolate, func);\n+    node::AddEnvironmentCleanupHook(env->isolate, Cleanup, this);\n+  }\n+\n+  ~TsFn() {\n+    node::RemoveEnvironmentCleanupHook(env->isolate, Cleanup, this);\n+  }\n+\n+  // These methods can be called from any thread.\n+\n+  napi_status Push(void* data, napi_threadsafe_function_call_mode mode) {\n+    node::Mutex::ScopedLock lock(this->mutex);\n+\n+    while (queue.size() >= max_queue_size &&\n+        max_queue_size > 0 &&\n+        !is_closing) {\n+      if (mode == napi_tsfn_nonblocking) {\n+        return napi_queue_full;\n+      }\n+      cond->Wait(lock);\n+    }\n+\n+    if (is_closing) {\n+      if (thread_count == 0) {\n+        return napi_invalid_arg;\n+      } else {\n+        thread_count--;\n+        return napi_closing;\n+      }\n+    } else {\n+      if (uv_async_send(&async) != 0) {\n+        return napi_generic_failure;\n+      }\n+      queue.push(data);\n+      return napi_ok;\n+    }\n+  }\n+\n+  napi_status Acquire() {\n+    node::Mutex::ScopedLock lock(this->mutex);\n+\n+    if (is_closing) {\n+      return napi_closing;\n+    }\n+\n+    thread_count++;\n+\n+    return napi_ok;\n+  }\n+\n+  napi_status Release(napi_threadsafe_function_release_mode mode) {\n+    node::Mutex::ScopedLock lock(this->mutex);\n+\n+    if (thread_count == 0) {\n+      return napi_invalid_arg;\n+    }\n+\n+    thread_count--;\n+\n+    if (thread_count == 0 || mode == napi_tsfn_abort) {\n+      if (!is_closing) {\n+        is_closing = (mode == napi_tsfn_abort);\n+        if (is_closing) {\n+          cond->Signal(lock);\n+        }\n+        if (uv_async_send(&async) != 0) {\n+          return napi_generic_failure;\n+        }\n+      }\n+    }\n+\n+    return napi_ok;\n+  }\n+\n+  void EmptyQueueAndDelete() {\n+    for (; !queue.empty() ; queue.pop()) {\n+      call_js_cb(nullptr, nullptr, context, queue.front());\n+    }\n+    delete this;\n+  }\n+\n+  // These methods must only be called from the loop thread.\n+\n+  napi_status Init() {\n+    TsFn* ts_fn = this;\n+\n+    if (uv_async_init(env->loop, &async, AsyncCb) == 0) {\n+      if (max_queue_size > 0) {\n+        cond.reset(new node::ConditionVariable);\n+      }\n+      if ((max_queue_size == 0 || cond.get() != nullptr) &&\n+          uv_idle_init(env->loop, &idle) == 0) {\n+        return napi_ok;\n+      }\n+\n+      node::Environment::GetCurrent(env->isolate)->CloseHandle(\n+          reinterpret_cast<uv_handle_t*>(&async),\n+          [] (uv_handle_t* handle) -> void {\n+            TsFn* ts_fn =\n+                node::ContainerOf(&TsFn::async,\n+                                  reinterpret_cast<uv_async_t*>(handle));\n+            delete ts_fn;\n+          });\n+\n+      // Prevent the thread-safe function from being deleted here, because\n+      // the callback above will delete it.\n+      ts_fn = nullptr;\n+    }\n+\n+    delete ts_fn;\n+\n+    return napi_generic_failure;\n+  }\n+\n+  napi_status Unref() {\n+    uv_unref(reinterpret_cast<uv_handle_t*>(&async));\n+    uv_unref(reinterpret_cast<uv_handle_t*>(&idle));\n+\n+    return napi_ok;\n+  }\n+\n+  napi_status Ref() {\n+    uv_ref(reinterpret_cast<uv_handle_t*>(&async));\n+    uv_ref(reinterpret_cast<uv_handle_t*>(&idle));\n+\n+    return napi_ok;\n+  }\n+\n+  void DispatchOne() {\n+    void* data;\n+    bool popped_value = false;\n+    bool idle_stop_failed = false;\n+\n+    {\n+      node::Mutex::ScopedLock lock(this->mutex);\n+      if (is_closing) {\n+        CloseHandlesAndMaybeDelete();\n+      } else {\n+        size_t size = queue.size();\n+        if (size > 0) {\n+          data = queue.front();\n+          queue.pop();\n+          popped_value = true;\n+          if (size == max_queue_size && max_queue_size > 0) {\n+            cond->Signal(lock);\n+          }\n+          size--;\n+        }\n+\n+        if (size == 0) {\n+          if (thread_count == 0) {\n+            is_closing = true;\n+            cond->Signal(lock);\n+            CloseHandlesAndMaybeDelete();\n+          } else {\n+            if (uv_idle_stop(&idle) != 0) {\n+              idle_stop_failed = true;\n+            } else {\n+              idle_running = false;\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    if (popped_value || idle_stop_failed) {\n+      v8::HandleScope scope(env->isolate);\n+      CallbackScope cb_scope(this);\n+\n+      if (idle_stop_failed) {\n+        CHECK(napi_throw_error(env,\n+                               \"ERR_NAPI_TSFN_STOP_IDLE_LOOP\",\n+                               \"Failed to stop the idle loop\") == napi_ok);\n+      } else {\n+        v8::Local<v8::Function> js_cb =\n+            v8::Local<v8::Function>::New(env->isolate, ref);\n+        call_js_cb(env,\n+                   v8impl::JsValueFromV8LocalValue(js_cb),\n+                   context,\n+                   data);\n+      }\n+    }\n+  }\n+\n+  node::Environment* NodeEnv() {\n+    // For some reason grabbing the Node.js environment requires a handle scope.\n+    v8::HandleScope scope(env->isolate);\n+    return node::Environment::GetCurrent(env->isolate);\n+  }\n+\n+  void MaybeStartIdle() {\n+    if (!idle_running) {\n+      if (uv_idle_start(&idle, IdleCb) != 0) {\n+        v8::HandleScope scope(env->isolate);\n+        CallbackScope cb_scope(this);\n+        CHECK(napi_throw_error(env,\n+                               \"ERR_NAPI_TSFN_START_IDLE_LOOP\",\n+                               \"Failed to start the idle loop\") == napi_ok);\n+      }\n+    }\n+  }\n+\n+  void Finalize() {\n+    v8::HandleScope scope(env->isolate);\n+    if (finalize_cb) {\n+      CallbackScope cb_scope(this);\n+      finalize_cb(env, finalize_data, context);\n+    }\n+    EmptyQueueAndDelete();\n+  }\n+\n+  inline void* Context() {\n+    return context;\n+  }\n+\n+  void CloseHandlesAndMaybeDelete(bool set_closing = false) {\n+    if (set_closing) {\n+      node::Mutex::ScopedLock lock(this->mutex);\n+      is_closing = true;\n+      cond->Signal(lock);\n+    }\n+    if (handles_closing) {\n+      return;\n+    }\n+    handles_closing = true;\n+    NodeEnv()->CloseHandle(\n+        reinterpret_cast<uv_handle_t*>(&async),\n+        [] (uv_handle_t* handle) -> void {\n+          TsFn* ts_fn = node::ContainerOf(&TsFn::async,\n+              reinterpret_cast<uv_async_t*>(handle));\n+          ts_fn->NodeEnv()->CloseHandle(\n+              reinterpret_cast<uv_handle_t*>(&ts_fn->idle),\n+              [] (uv_handle_t* handle) -> void {\n+                TsFn* ts_fn = node::ContainerOf(&TsFn::idle,\n+                    reinterpret_cast<uv_idle_t*>(handle));\n+                ts_fn->Finalize();\n+              });\n+        });\n+  }\n+\n+  // Default way of calling into JavaScript. Used when TsFn is constructed\n+  // without a call_js_cb_.\n+  static void CallJs(napi_env env, napi_value cb, void* context, void* data) {\n+    if (!(env == nullptr || cb == nullptr)) {\n+      napi_value recv;\n+      napi_status status;\n+\n+      status = napi_get_undefined(env, &recv);\n+      if (status != napi_ok) {\n+        napi_throw_error(env, \"ERR_NAPI_TSFN_GET_UNDEFINED\",\n+            \"Failed to retrieve undefined value\");\n+        return;\n+      }\n+\n+      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);\n+      if (status != napi_ok && status != napi_pending_exception) {\n+        napi_throw_error(env, \"ERR_NAPI_TSFN_CALL_JS\",\n+            \"Failed to call JS callback\");\n+        return;\n+      }\n+    }\n+  }\n+\n+  static void IdleCb(uv_idle_t* idle) {\n+    TsFn* ts_fn =\n+        node::ContainerOf(&TsFn::idle, idle);\n+    ts_fn->DispatchOne();\n+  }\n+\n+  static void AsyncCb(uv_async_t* async) {\n+    TsFn* ts_fn =\n+        node::ContainerOf(&TsFn::async, async);\n+    ts_fn->MaybeStartIdle();\n+  }\n+\n+  static void Cleanup(void* data) {\n+    reinterpret_cast<TsFn*>(data)->CloseHandlesAndMaybeDelete(true);\n+  }\n+\n+ private:\n+  // These are variables protected by the mutex.\n+  node::Mutex mutex;\n+  std::unique_ptr<node::ConditionVariable> cond;\n+  std::queue<void*> queue;\n+  uv_async_t async;\n+  uv_idle_t idle;\n+  size_t thread_count;\n+  bool is_closing;\n+\n+  // These are variables set once, upon creation, and then never again, which\n+  // means we don't need the mutex to read them.\n+  void* context;\n+  size_t max_queue_size;\n+\n+  // These are variables accessed only from the loop thread.\n+  node::Persistent<v8::Function> ref;\n+  napi_env env;\n+  void* finalize_data;\n+  napi_finalize finalize_cb;\n+  bool idle_running;\n+  napi_async_context async_context;\n+  napi_threadsafe_function_call_js call_js_cb;\n+  bool handles_closing;\n+};\n+\n+NAPI_EXTERN napi_status\n+napi_create_threadsafe_function(napi_env env,\n+                                napi_value func,\n+                                napi_value async_resource,\n+                                napi_value async_resource_name,\n+                                size_t max_queue_size,\n+                                size_t initial_thread_count,\n+                                void* thread_finalize_data,\n+                                napi_finalize thread_finalize_cb,\n+                                void* context,\n+                                napi_threadsafe_function_call_js call_js_cb,\n+                                napi_threadsafe_function* result) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, func);\n+  CHECK_ARG(env, async_resource_name);\n+  RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg);\n+  CHECK_ARG(env, result);\n+\n+  napi_status status = napi_ok;\n+\n+  v8::Local<v8::Function> v8_func;\n+  CHECK_TO_FUNCTION(env, v8_func, func);\n+\n+  v8::Local<v8::Context> v8_context = env->isolate->GetCurrentContext();\n+\n+  v8::Local<v8::Object> v8_resource;\n+  if (async_resource == nullptr) {\n+    v8_resource = v8::Object::New(env->isolate);\n+  } else {\n+    CHECK_TO_OBJECT(env, v8_context, v8_resource, async_resource);\n+  }\n+\n+  v8::Local<v8::String> v8_name;\n+  CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name);\n+\n+  TsFn* ts_fn = new TsFn(v8_func,\n+                         v8_resource,\n+                         v8_name,\n+                         initial_thread_count,\n+                         context,\n+                         max_queue_size,\n+                         env,\n+                         thread_finalize_data,\n+                         thread_finalize_cb,\n+                         call_js_cb);\n+\n+  if (ts_fn == nullptr) {\n+    status = napi_generic_failure;\n+  } else {\n+    // Init deletes ts_fn upon failure.\n+    status = ts_fn->Init();\n+    if (status == napi_ok) {\n+      *result = reinterpret_cast<napi_threadsafe_function>(ts_fn);\n+    }\n+  }\n+\n+  return napi_set_last_error(env, status);\n+}\n+\n+NAPI_EXTERN napi_status\n+napi_get_threadsafe_function_context(napi_threadsafe_function func,\n+                                     void** result) {\n+  CHECK(func != nullptr);\n+  CHECK(result != nullptr);\n+\n+  *result = reinterpret_cast<TsFn*>(func)->Context();\n+  return napi_ok;\n+}\n+\n+NAPI_EXTERN napi_status\n+napi_call_threadsafe_function(napi_threadsafe_function func,\n+                              void* data,\n+                              napi_threadsafe_function_call_mode is_blocking) {\n+  CHECK(func != nullptr);\n+  return reinterpret_cast<TsFn*>(func)->Push(data, is_blocking);\n+}\n+\n+NAPI_EXTERN napi_status\n+napi_acquire_threadsafe_function(napi_threadsafe_function func) {\n+  CHECK(func != nullptr);\n+  return reinterpret_cast<TsFn*>(func)->Acquire();\n+}\n+\n+NAPI_EXTERN napi_status\n+napi_release_threadsafe_function(napi_threadsafe_function func,\n+                                 napi_threadsafe_function_release_mode mode) {\n+  CHECK(func != nullptr);\n+  return reinterpret_cast<TsFn*>(func)->Release(mode);\n+}\n+\n+NAPI_EXTERN napi_status\n+napi_unref_threadsafe_function(napi_env env, napi_threadsafe_function func) {\n+  CHECK(func != nullptr);\n+  return reinterpret_cast<TsFn*>(func)->Unref();\n+}\n+\n+NAPI_EXTERN napi_status\n+napi_ref_threadsafe_function(napi_env env, napi_threadsafe_function func) {\n+  CHECK(func != nullptr);\n+  return reinterpret_cast<TsFn*>(func)->Ref();\n+}"
        },
        {
            "sha": "84706ac3ed67692765d1d58b40d985cb9f2dbb42",
            "filename": "src/node_api.h",
            "status": "modified",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/81f06ba7e49d9c077c209ab9c9de63bad08aa801/src%2Fnode_api.h",
            "raw_url": "https://github.com/nodejs/node/raw/81f06ba7e49d9c077c209ab9c9de63bad08aa801/src%2Fnode_api.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.h?ref=81f06ba7e49d9c077c209ab9c9de63bad08aa801",
            "patch": "@@ -614,6 +614,44 @@ NAPI_EXTERN napi_status napi_run_script(napi_env env,\n NAPI_EXTERN napi_status napi_get_uv_event_loop(napi_env env,\n                                                struct uv_loop_s** loop);\n \n+#ifdef NAPI_EXPERIMENTAL\n+// Calling into JS from other threads\n+NAPI_EXTERN napi_status\n+napi_create_threadsafe_function(napi_env env,\n+                                napi_value func,\n+                                napi_value async_resource,\n+                                napi_value async_resource_name,\n+                                size_t max_queue_size,\n+                                size_t initial_thread_count,\n+                                void* thread_finalize_data,\n+                                napi_finalize thread_finalize_cb,\n+                                void* context,\n+                                napi_threadsafe_function_call_js call_js_cb,\n+                                napi_threadsafe_function* result);\n+\n+NAPI_EXTERN napi_status\n+napi_get_threadsafe_function_context(napi_threadsafe_function func,\n+                                     void** result);\n+\n+NAPI_EXTERN napi_status\n+napi_call_threadsafe_function(napi_threadsafe_function func,\n+                              void* data,\n+                              napi_threadsafe_function_call_mode is_blocking);\n+\n+NAPI_EXTERN napi_status\n+napi_acquire_threadsafe_function(napi_threadsafe_function func);\n+\n+NAPI_EXTERN napi_status\n+napi_release_threadsafe_function(napi_threadsafe_function func,\n+                                 napi_threadsafe_function_release_mode mode);\n+\n+NAPI_EXTERN napi_status\n+napi_unref_threadsafe_function(napi_env env, napi_threadsafe_function func);\n+\n+NAPI_EXTERN napi_status\n+napi_ref_threadsafe_function(napi_env env, napi_threadsafe_function func);\n+\n+#endif  // NAPI_EXPERIMENTAL\n EXTERN_C_END\n \n #endif  // SRC_NODE_API_H_"
        },
        {
            "sha": "af7d7c7f95331d060e1f46a060815253d6243214",
            "filename": "src/node_api_types.h",
            "status": "modified",
            "additions": 27,
            "deletions": 1,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/81f06ba7e49d9c077c209ab9c9de63bad08aa801/src%2Fnode_api_types.h",
            "raw_url": "https://github.com/nodejs/node/raw/81f06ba7e49d9c077c209ab9c9de63bad08aa801/src%2Fnode_api_types.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api_types.h?ref=81f06ba7e49d9c077c209ab9c9de63bad08aa801",
            "patch": "@@ -20,6 +20,9 @@ typedef struct napi_callback_info__* napi_callback_info;\n typedef struct napi_async_context__* napi_async_context;\n typedef struct napi_async_work__* napi_async_work;\n typedef struct napi_deferred__* napi_deferred;\n+#ifdef NAPI_EXPERIMENTAL\n+typedef struct napi_threadsafe_function__* napi_threadsafe_function;\n+#endif  // NAPI_EXPERIMENTAL\n \n typedef enum {\n   napi_default = 0,\n@@ -72,9 +75,25 @@ typedef enum {\n   napi_cancelled,\n   napi_escape_called_twice,\n   napi_handle_scope_mismatch,\n-  napi_callback_scope_mismatch\n+  napi_callback_scope_mismatch,\n+#ifdef NAPI_EXPERIMENTAL\n+  napi_queue_full,\n+  napi_closing,\n+#endif  // NAPI_EXPERIMENTAL\n } napi_status;\n \n+#ifdef NAPI_EXPERIMENTAL\n+typedef enum {\n+  napi_tsfn_release,\n+  napi_tsfn_abort\n+} napi_threadsafe_function_release_mode;\n+\n+typedef enum {\n+  napi_tsfn_nonblocking,\n+  napi_tsfn_blocking\n+} napi_threadsafe_function_call_mode;\n+#endif  // NAPI_EXPERIMENTAL\n+\n typedef napi_value (*napi_callback)(napi_env env,\n                                     napi_callback_info info);\n typedef void (*napi_finalize)(napi_env env,\n@@ -86,6 +105,13 @@ typedef void (*napi_async_complete_callback)(napi_env env,\n                                              napi_status status,\n                                              void* data);\n \n+#ifdef NAPI_EXPERIMENTAL\n+typedef void (*napi_threadsafe_function_call_js)(napi_env env,\n+                                                 napi_value js_callback,\n+                                                 void* context,\n+                                                 void* data);\n+#endif  // NAPI_EXPERIMENTAL\n+\n typedef struct {\n   // One of utf8name or name should be NULL.\n   const char* utf8name;"
        },
        {
            "sha": "551705b1f21074f9613a94897dd54349beacbb1b",
            "filename": "test/addons-napi/test_threadsafe_function/binding.c",
            "status": "added",
            "additions": 254,
            "deletions": 0,
            "changes": 254,
            "blob_url": "https://github.com/nodejs/node/blob/81f06ba7e49d9c077c209ab9c9de63bad08aa801/test%2Faddons-napi%2Ftest_threadsafe_function%2Fbinding.c",
            "raw_url": "https://github.com/nodejs/node/raw/81f06ba7e49d9c077c209ab9c9de63bad08aa801/test%2Faddons-napi%2Ftest_threadsafe_function%2Fbinding.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2Ftest_threadsafe_function%2Fbinding.c?ref=81f06ba7e49d9c077c209ab9c9de63bad08aa801",
            "patch": "@@ -0,0 +1,254 @@\n+// For the purpose of this test we use libuv's threading library. When deciding\n+// on a threading library for a new project it bears remembering that in the\n+// future libuv may introduce API changes which may render it non-ABI-stable,\n+// which, in turn, may affect the ABI stability of the project despite its use\n+// of N-API.\n+#include <uv.h>\n+#define NAPI_EXPERIMENTAL\n+#include <node_api.h>\n+#include \"../common.h\"\n+\n+#define ARRAY_LENGTH 10\n+\n+static uv_thread_t uv_threads[2];\n+static napi_threadsafe_function ts_fn;\n+\n+typedef struct {\n+  napi_threadsafe_function_call_mode block_on_full;\n+  napi_threadsafe_function_release_mode abort;\n+  bool start_secondary;\n+  napi_ref js_finalize_cb;\n+} ts_fn_hint;\n+\n+static ts_fn_hint ts_info;\n+\n+// Thread data to transmit to JS\n+static int ints[ARRAY_LENGTH];\n+\n+static void secondary_thread(void* data) {\n+  napi_threadsafe_function ts_fn = data;\n+\n+  if (napi_release_threadsafe_function(ts_fn, napi_tsfn_release) != napi_ok) {\n+    napi_fatal_error(\"secondary_thread\", NAPI_AUTO_LENGTH,\n+        \"napi_release_threadsafe_function failed\", NAPI_AUTO_LENGTH);\n+  }\n+}\n+\n+// Source thread producing the data\n+static void data_source_thread(void* data) {\n+  napi_threadsafe_function ts_fn = data;\n+  int index;\n+  void* hint;\n+  ts_fn_hint *ts_fn_info;\n+  napi_status status;\n+  bool queue_was_full = false;\n+  bool queue_was_closing = false;\n+\n+  if (napi_get_threadsafe_function_context(ts_fn, &hint) != napi_ok) {\n+    napi_fatal_error(\"data_source_thread\", NAPI_AUTO_LENGTH,\n+        \"napi_get_threadsafe_function_context failed\", NAPI_AUTO_LENGTH);\n+  }\n+\n+  ts_fn_info = (ts_fn_hint *)hint;\n+\n+  if (ts_fn_info != &ts_info) {\n+    napi_fatal_error(\"data_source_thread\", NAPI_AUTO_LENGTH,\n+      \"thread-safe function hint is not as expected\", NAPI_AUTO_LENGTH);\n+  }\n+\n+  if (ts_fn_info->start_secondary) {\n+    if (napi_acquire_threadsafe_function(ts_fn) != napi_ok) {\n+      napi_fatal_error(\"data_source_thread\", NAPI_AUTO_LENGTH,\n+        \"napi_acquire_threadsafe_function failed\", NAPI_AUTO_LENGTH);\n+    }\n+\n+    if (uv_thread_create(&uv_threads[1], secondary_thread, ts_fn) != 0) {\n+      napi_fatal_error(\"data_source_thread\", NAPI_AUTO_LENGTH,\n+        \"failed to start secondary thread\", NAPI_AUTO_LENGTH);\n+    }\n+  }\n+\n+  for (index = ARRAY_LENGTH - 1; index > -1 && !queue_was_closing; index--) {\n+    status = napi_call_threadsafe_function(ts_fn, &ints[index],\n+        ts_fn_info->block_on_full);\n+    switch (status) {\n+      case napi_queue_full:\n+        queue_was_full = true;\n+        index++;\n+        // fall through\n+\n+      case napi_ok:\n+        continue;\n+\n+      case napi_closing:\n+        queue_was_closing = true;\n+        break;\n+\n+      default:\n+        napi_fatal_error(\"data_source_thread\", NAPI_AUTO_LENGTH,\n+            \"napi_call_threadsafe_function failed\", NAPI_AUTO_LENGTH);\n+    }\n+  }\n+\n+  // Assert that the enqueuing of a value was refused at least once, if this is\n+  // a non-blocking test run.\n+  if (!ts_fn_info->block_on_full && !queue_was_full) {\n+    napi_fatal_error(\"data_source_thread\", NAPI_AUTO_LENGTH,\n+        \"queue was never full\", NAPI_AUTO_LENGTH);\n+  }\n+\n+  // Assert that the queue was marked as closing at least once, if this is an\n+  // aborting test run.\n+  if (ts_fn_info->abort == napi_tsfn_abort && !queue_was_closing) {\n+    napi_fatal_error(\"data_source_thread\", NAPI_AUTO_LENGTH,\n+      \"queue was never closing\", NAPI_AUTO_LENGTH);\n+  }\n+\n+  if (!queue_was_closing &&\n+      napi_release_threadsafe_function(ts_fn, napi_tsfn_release) != napi_ok) {\n+    napi_fatal_error(\"data_source_thread\", NAPI_AUTO_LENGTH,\n+        \"napi_release_threadsafe_function failed\", NAPI_AUTO_LENGTH);\n+  }\n+}\n+\n+// Getting the data into JS\n+static void call_js(napi_env env, napi_value cb, void* hint, void* data) {\n+  if (!(env == NULL || cb == NULL)) {\n+    napi_value argv, undefined;\n+    NAPI_CALL_RETURN_VOID(env, napi_create_int32(env, *(int*)data, &argv));\n+    NAPI_CALL_RETURN_VOID(env, napi_get_undefined(env, &undefined));\n+    NAPI_CALL_RETURN_VOID(env, napi_call_function(env, undefined, cb, 1, &argv,\n+        NULL));\n+  }\n+}\n+\n+// Cleanup\n+static napi_value StopThread(napi_env env, napi_callback_info info) {\n+  size_t argc = 2;\n+  napi_value argv[2];\n+  NAPI_CALL(env, napi_get_cb_info(env, info, &argc, argv, NULL, NULL));\n+  napi_valuetype value_type;\n+  NAPI_CALL(env, napi_typeof(env, argv[0], &value_type));\n+  NAPI_ASSERT(env, value_type == napi_function,\n+      \"StopThread argument is a function\");\n+  NAPI_ASSERT(env, (ts_fn != NULL), \"Existing threadsafe function\");\n+  NAPI_CALL(env,\n+      napi_create_reference(env, argv[0], 1, &(ts_info.js_finalize_cb)));\n+  bool abort;\n+  NAPI_CALL(env, napi_get_value_bool(env, argv[1], &abort));\n+  NAPI_CALL(env,\n+      napi_release_threadsafe_function(ts_fn,\n+          abort ? napi_tsfn_abort : napi_tsfn_release));\n+  ts_fn = NULL;\n+  return NULL;\n+}\n+\n+// Join the thread and inform JS that we're done.\n+static void join_the_threads(napi_env env, void *data, void *hint) {\n+  uv_thread_t *the_threads = data;\n+  ts_fn_hint *the_hint = hint;\n+  napi_value js_cb, undefined;\n+\n+  uv_thread_join(&the_threads[0]);\n+  if (the_hint->start_secondary) {\n+    uv_thread_join(&the_threads[1]);\n+  }\n+\n+  NAPI_CALL_RETURN_VOID(env,\n+      napi_get_reference_value(env, the_hint->js_finalize_cb, &js_cb));\n+  NAPI_CALL_RETURN_VOID(env, napi_get_undefined(env, &undefined));\n+  NAPI_CALL_RETURN_VOID(env,\n+      napi_call_function(env, undefined, js_cb, 0, NULL, NULL));\n+  NAPI_CALL_RETURN_VOID(env, napi_delete_reference(env,\n+      the_hint->js_finalize_cb));\n+}\n+\n+static napi_value StartThreadInternal(napi_env env,\n+                                      napi_callback_info info,\n+                                      napi_threadsafe_function_call_js cb,\n+                                      bool block_on_full) {\n+  size_t argc = 3;\n+  napi_value argv[3];\n+\n+  ts_info.block_on_full =\n+      (block_on_full ? napi_tsfn_blocking : napi_tsfn_nonblocking);\n+\n+  NAPI_ASSERT(env, (ts_fn == NULL), \"Existing thread-safe function\");\n+  NAPI_CALL(env, napi_get_cb_info(env, info, &argc, argv, NULL, NULL));\n+  napi_value async_name;\n+  NAPI_CALL(env, napi_create_string_utf8(env, \"N-API Thread-safe Function Test\",\n+      NAPI_AUTO_LENGTH, &async_name));\n+  NAPI_CALL(env, napi_create_threadsafe_function(env, argv[0], NULL, async_name,\n+      2, 2, uv_threads, join_the_threads, &ts_info, cb, &ts_fn));\n+  bool abort;\n+  NAPI_CALL(env, napi_get_value_bool(env, argv[1], &abort));\n+  ts_info.abort = abort ? napi_tsfn_abort : napi_tsfn_release;\n+  NAPI_CALL(env, napi_get_value_bool(env, argv[2], &(ts_info.start_secondary)));\n+\n+  NAPI_ASSERT(env,\n+      (uv_thread_create(&uv_threads[0], data_source_thread, ts_fn) == 0),\n+      \"Thread creation\");\n+\n+  return NULL;\n+}\n+\n+static napi_value Unref(napi_env env, napi_callback_info info) {\n+  NAPI_ASSERT(env, ts_fn != NULL, \"No existing thread-safe function\");\n+  NAPI_CALL(env, napi_unref_threadsafe_function(env, ts_fn));\n+  return NULL;\n+}\n+\n+static napi_value Release(napi_env env, napi_callback_info info) {\n+  NAPI_ASSERT(env, ts_fn != NULL, \"No existing thread-safe function\");\n+  NAPI_CALL(env, napi_release_threadsafe_function(ts_fn, napi_tsfn_release));\n+  return NULL;\n+}\n+\n+// Startup\n+static napi_value StartThread(napi_env env, napi_callback_info info) {\n+  return StartThreadInternal(env, info, call_js, true);\n+}\n+\n+static napi_value StartThreadNonblocking(napi_env env,\n+                                         napi_callback_info info) {\n+  return StartThreadInternal(env, info, call_js, false);\n+}\n+\n+static napi_value StartThreadNoNative(napi_env env, napi_callback_info info) {\n+  return StartThreadInternal(env, info, NULL, true);\n+}\n+\n+// Module init\n+static napi_value Init(napi_env env, napi_value exports) {\n+  size_t index;\n+  for (index = 0; index < ARRAY_LENGTH; index++) {\n+    ints[index] = index;\n+  }\n+  napi_value js_array_length;\n+  napi_create_uint32(env, ARRAY_LENGTH, &js_array_length);\n+\n+  napi_property_descriptor properties[] = {\n+    {\n+      \"ARRAY_LENGTH\",\n+      NULL,\n+      NULL,\n+      NULL,\n+      NULL,\n+      js_array_length,\n+      napi_enumerable,\n+      NULL\n+    },\n+    DECLARE_NAPI_PROPERTY(\"StartThread\", StartThread),\n+    DECLARE_NAPI_PROPERTY(\"StartThreadNoNative\", StartThreadNoNative),\n+    DECLARE_NAPI_PROPERTY(\"StartThreadNonblocking\", StartThreadNonblocking),\n+    DECLARE_NAPI_PROPERTY(\"StopThread\", StopThread),\n+    DECLARE_NAPI_PROPERTY(\"Unref\", Unref),\n+    DECLARE_NAPI_PROPERTY(\"Release\", Release),\n+  };\n+\n+  NAPI_CALL(env, napi_define_properties(env, exports,\n+    sizeof(properties)/sizeof(properties[0]), properties));\n+\n+  return exports;\n+}\n+NAPI_MODULE(NODE_GYP_MODULE_NAME, Init)"
        },
        {
            "sha": "b60352e05af103cb7dfbe8e77aba1c3f5cd77709",
            "filename": "test/addons-napi/test_threadsafe_function/binding.gyp",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/81f06ba7e49d9c077c209ab9c9de63bad08aa801/test%2Faddons-napi%2Ftest_threadsafe_function%2Fbinding.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/81f06ba7e49d9c077c209ab9c9de63bad08aa801/test%2Faddons-napi%2Ftest_threadsafe_function%2Fbinding.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2Ftest_threadsafe_function%2Fbinding.gyp?ref=81f06ba7e49d9c077c209ab9c9de63bad08aa801",
            "patch": "@@ -0,0 +1,8 @@\n+{\n+  'targets': [\n+    {\n+      'target_name': 'binding',\n+      'sources': ['binding.c']\n+    }\n+  ]\n+}"
        },
        {
            "sha": "8d8a6d9d8c682753431c6e80d8b8f8f2d2fdb320",
            "filename": "test/addons-napi/test_threadsafe_function/test.js",
            "status": "added",
            "additions": 166,
            "deletions": 0,
            "changes": 166,
            "blob_url": "https://github.com/nodejs/node/blob/81f06ba7e49d9c077c209ab9c9de63bad08aa801/test%2Faddons-napi%2Ftest_threadsafe_function%2Ftest.js",
            "raw_url": "https://github.com/nodejs/node/raw/81f06ba7e49d9c077c209ab9c9de63bad08aa801/test%2Faddons-napi%2Ftest_threadsafe_function%2Ftest.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2Ftest_threadsafe_function%2Ftest.js?ref=81f06ba7e49d9c077c209ab9c9de63bad08aa801",
            "patch": "@@ -0,0 +1,166 @@\n+'use strict';\n+\n+const common = require('../../common');\n+const assert = require('assert');\n+const binding = require(`./build/${common.buildType}/binding`);\n+const { fork } = require('child_process');\n+const expectedArray = (function(arrayLength) {\n+  const result = [];\n+  for (let index = 0; index < arrayLength; index++) {\n+    result.push(arrayLength - 1 - index);\n+  }\n+  return result;\n+})(binding.ARRAY_LENGTH);\n+\n+common.crashOnUnhandledRejection();\n+\n+// Handle the rapid teardown test case as the child process. We unref the\n+// thread-safe function after we have received two values. This causes the\n+// process to exit and the environment cleanup handler to be invoked.\n+if (process.argv[2] === 'child') {\n+  let callCount = 0;\n+  binding.StartThread((value) => {\n+    callCount++;\n+    console.log(value);\n+    if (callCount === 2) {\n+      binding.Unref();\n+    }\n+  }, false /* abort */, true /* launchSecondary */);\n+\n+  // Release the thread-safe function from the main thread so that it may be\n+  // torn down via the environment cleanup handler.\n+  binding.Release();\n+  return;\n+}\n+\n+function testWithJSMarshaller({\n+  threadStarter,\n+  quitAfter,\n+  abort,\n+  launchSecondary }) {\n+  return new Promise((resolve) => {\n+    const array = [];\n+    binding[threadStarter](function testCallback(value) {\n+      array.push(value);\n+      if (array.length === quitAfter) {\n+        setImmediate(() => {\n+          binding.StopThread(common.mustCall(() => {\n+            resolve(array);\n+          }), !!abort);\n+        });\n+      }\n+    }, !!abort, !!launchSecondary);\n+    if (threadStarter === 'StartThreadNonblocking') {\n+      // Let's make this thread really busy for a short while to ensure that\n+      // the queue fills and the thread receives a napi_queue_full.\n+      const start = Date.now();\n+      while (Date.now() - start < 200);\n+    }\n+  });\n+}\n+\n+new Promise(function testWithoutJSMarshaller(resolve) {\n+  let callCount = 0;\n+  binding.StartThreadNoNative(function testCallback() {\n+    callCount++;\n+\n+    // The default call-into-JS implementation passes no arguments.\n+    assert.strictEqual(arguments.length, 0);\n+    if (callCount === binding.ARRAY_LENGTH) {\n+      setImmediate(() => {\n+        binding.StopThread(common.mustCall(() => {\n+          resolve();\n+        }), false);\n+      });\n+    }\n+  }, false /* abort */, false /* launchSecondary */);\n+})\n+\n+// Start the thread in blocking mode, and assert that all values are passed.\n+// Quit after it's done.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThread',\n+  quitAfter: binding.ARRAY_LENGTH\n+}))\n+.then((result) => assert.deepStrictEqual(result, expectedArray))\n+\n+// Start the thread in non-blocking mode, and assert that all values are passed.\n+// Quit after it's done.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThreadNonblocking',\n+  quitAfter: binding.ARRAY_LENGTH\n+}))\n+.then((result) => assert.deepStrictEqual(result, expectedArray))\n+\n+// Start the thread in blocking mode, and assert that all values are passed.\n+// Quit early, but let the thread finish.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThread',\n+  quitAfter: 1\n+}))\n+.then((result) => assert.deepStrictEqual(result, expectedArray))\n+\n+// Start the thread in non-blocking mode, and assert that all values are passed.\n+// Quit early, but let the thread finish.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThreadNonblocking',\n+  quitAfter: 1\n+}))\n+.then((result) => assert.deepStrictEqual(result, expectedArray))\n+\n+// Start the thread in blocking mode, and assert that all values are passed.\n+// Quit early, but let the thread finish. Launch a secondary thread to test the\n+// reference counter incrementing functionality.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThread',\n+  quitAfter: 1,\n+  launchSecondary: true\n+}))\n+.then((result) => assert.deepStrictEqual(result, expectedArray))\n+\n+// Start the thread in non-blocking mode, and assert that all values are passed.\n+// Quit early, but let the thread finish. Launch a secondary thread to test the\n+// reference counter incrementing functionality.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThreadNonblocking',\n+  quitAfter: 1,\n+  launchSecondary: true\n+}))\n+.then((result) => assert.deepStrictEqual(result, expectedArray))\n+\n+// Start the thread in blocking mode, and assert that it could not finish.\n+// Quit early and aborting.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThread',\n+  quitAfter: 1,\n+  abort: true\n+}))\n+.then((result) => assert.strictEqual(result.indexOf(0), -1))\n+\n+// Start the thread in non-blocking mode, and assert that it could not finish.\n+// Quit early and aborting.\n+.then(() => testWithJSMarshaller({\n+  threadStarter: 'StartThreadNonblocking',\n+  quitAfter: 1,\n+  abort: true\n+}))\n+.then((result) => assert.strictEqual(result.indexOf(0), -1))\n+\n+// Start a child process to test rapid teardown\n+.then(() => {\n+  return new Promise((resolve, reject) => {\n+    let output = '';\n+    const child = fork(__filename, ['child'], {\n+      stdio: [process.stdin, 'pipe', process.stderr, 'ipc']\n+    });\n+    child.on('close', (code) => {\n+      if (code === 0) {\n+        resolve(output.match(/\\S+/g));\n+      } else {\n+        reject(new Error('Child process died with code ' + code));\n+      }\n+    });\n+    child.stdout.on('data', (data) => (output += data.toString()));\n+  });\n+})\n+.then((result) => assert.strictEqual(result.indexOf(0), -1));"
        }
    ],
    "stats": {
        "total": 1333,
        "additions": 1329,
        "deletions": 4
    }
}