{
    "author": "bnoordhuis",
    "message": "crypto: refactor randomBytes()\n\nUse the scrypt() infrastructure to reimplement randomBytes() and\nrandomFill() in a simpler manner.\n\nPR-URL: https://github.com/nodejs/node/pull/20816\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>",
    "sha": "078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6",
    "files": [
        {
            "sha": "b4812d606c02fd45b3be6127caa2ce24bba4ada5",
            "filename": "lib/internal/crypto/random.js",
            "status": "modified",
            "additions": 32,
            "deletions": 10,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6/lib%2Finternal%2Fcrypto%2Frandom.js",
            "raw_url": "https://github.com/nodejs/node/raw/078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6/lib%2Finternal%2Fcrypto%2Frandom.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Frandom.js?ref=078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6",
            "patch": "@@ -1,15 +1,14 @@\n 'use strict';\n \n+const { AsyncWrap, Providers } = process.binding('async_wrap');\n+const { Buffer } = require('buffer');\n+const { randomBytes: _randomBytes } = process.binding('crypto');\n const {\n   ERR_INVALID_ARG_TYPE,\n   ERR_INVALID_CALLBACK,\n   ERR_OUT_OF_RANGE\n } = require('internal/errors').codes;\n const { isArrayBufferView } = require('internal/util/types');\n-const {\n-  randomBytes: _randomBytes,\n-  randomFill: _randomFill\n-} = process.binding('crypto');\n \n const { kMaxLength } = require('buffer');\n const kMaxUint32 = Math.pow(2, 32) - 1;\n@@ -27,7 +26,7 @@ function assertOffset(offset, elementSize, length) {\n     throw new ERR_OUT_OF_RANGE('offset', `>= 0 && <= ${maxLength}`, offset);\n   }\n \n-  return offset;\n+  return offset >>> 0;  // Convert to uint32.\n }\n \n function assertSize(size, elementSize, offset, length) {\n@@ -46,14 +45,25 @@ function assertSize(size, elementSize, offset, length) {\n     throw new ERR_OUT_OF_RANGE('size + offset', `<= ${length}`, size + offset);\n   }\n \n-  return size;\n+  return size >>> 0;  // Convert to uint32.\n }\n \n function randomBytes(size, cb) {\n-  assertSize(size, 1, 0, Infinity);\n+  size = assertSize(size, 1, 0, Infinity);\n   if (cb !== undefined && typeof cb !== 'function')\n     throw new ERR_INVALID_CALLBACK();\n-  return _randomBytes(size, cb);\n+\n+  const buf = Buffer.alloc(size);\n+\n+  if (!cb) return handleError(buf, 0, size);\n+\n+  const wrap = new AsyncWrap(Providers.RANDOMBYTESREQUEST);\n+  wrap.ondone = (ex) => {  // Retains buf while request is in flight.\n+    if (ex) return cb.call(wrap, ex);\n+    cb.call(wrap, null, buf);\n+  };\n+\n+  _randomBytes(buf, 0, size, wrap);\n }\n \n function randomFillSync(buf, offset = 0, size) {\n@@ -71,7 +81,7 @@ function randomFillSync(buf, offset = 0, size) {\n     size = assertSize(size, elementSize, offset, buf.byteLength);\n   }\n \n-  return _randomFill(buf, offset, size);\n+  return handleError(buf, offset, size);\n }\n \n function randomFill(buf, offset, size, cb) {\n@@ -100,7 +110,19 @@ function randomFill(buf, offset, size, cb) {\n     size = assertSize(size, elementSize, offset, buf.byteLength);\n   }\n \n-  return _randomFill(buf, offset, size, cb);\n+  const wrap = new AsyncWrap(Providers.RANDOMBYTESREQUEST);\n+  wrap.ondone = (ex) => {  // Retains buf while request is in flight.\n+    if (ex) return cb.call(wrap, ex);\n+    cb.call(wrap, null, buf);\n+  };\n+\n+  _randomBytes(buf, offset, size, wrap);\n+}\n+\n+function handleError(buf, offset, size) {\n+  const ex = _randomBytes(buf, offset, size);\n+  if (ex) throw ex;\n+  return buf;\n }\n \n module.exports = {"
        },
        {
            "sha": "1a96abe106a7528ae3805c3449050432ab92d9a0",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6",
            "patch": "@@ -344,7 +344,6 @@ struct PackageConfig {\n   V(promise_reject_unhandled_function, v8::Function)                          \\\n   V(promise_wrap_template, v8::ObjectTemplate)                                \\\n   V(push_values_to_array_function, v8::Function)                              \\\n-  V(randombytes_constructor_template, v8::ObjectTemplate)                     \\\n   V(sab_lifetimepartner_constructor_template, v8::FunctionTemplate)           \\\n   V(script_context_constructor_template, v8::FunctionTemplate)                \\\n   V(script_data_constructor_function, v8::Function)                           \\"
        },
        {
            "sha": "3fcd2910bb6ce24f7913d087fe0aaa2360a53d77",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 32,
            "deletions": 199,
            "changes": 231,
            "blob_url": "https://github.com/nodejs/node/blob/078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6",
            "patch": "@@ -82,7 +82,6 @@ using v8::NewStringType;\n using v8::Nothing;\n using v8::Null;\n using v8::Object;\n-using v8::ObjectTemplate;\n using v8::PropertyAttribute;\n using v8::ReadOnly;\n using v8::Signature;\n@@ -4586,208 +4585,50 @@ inline void CopyBuffer(Local<Value> buf, std::vector<char>* vec) {\n }\n \n \n-// Only instantiate within a valid HandleScope.\n-class RandomBytesRequest : public AsyncWrap, public ThreadPoolWork {\n- public:\n-  enum FreeMode { FREE_DATA, DONT_FREE_DATA };\n-\n-  RandomBytesRequest(Environment* env,\n-                     Local<Object> object,\n-                     size_t size,\n-                     char* data,\n-                     FreeMode free_mode)\n-      : AsyncWrap(env, object, AsyncWrap::PROVIDER_RANDOMBYTESREQUEST),\n-        ThreadPoolWork(env),\n-        error_(0),\n-        size_(size),\n-        data_(data),\n-        free_mode_(free_mode) {\n-  }\n-\n-  inline size_t size() const {\n-    return size_;\n-  }\n-\n-  inline char* data() const {\n-    return data_;\n-  }\n-\n-  inline void set_data(char* data) {\n-    data_ = data;\n-  }\n+struct RandomBytesJob : public CryptoJob {\n+  unsigned char* data;\n+  size_t size;\n+  CryptoErrorVector errors;\n+  Maybe<int> rc;\n \n-  inline void release() {\n-    size_ = 0;\n-    if (free_mode_ == FREE_DATA) {\n-      free(data_);\n-      data_ = nullptr;\n-    }\n-  }\n+  inline explicit RandomBytesJob(Environment* env)\n+      : CryptoJob(env), rc(Nothing<int>()) {}\n \n-  inline void return_memory(char** d, size_t* len) {\n-    *d = data_;\n-    data_ = nullptr;\n-    *len = size_;\n-    size_ = 0;\n+  inline void DoThreadPoolWork() override {\n+    CheckEntropy();  // Ensure that OpenSSL's PRNG is properly seeded.\n+    rc = Just(RAND_bytes(data, size));\n+    if (0 == rc.FromJust()) errors.Capture();\n   }\n \n-  inline unsigned long error() const {  // NOLINT(runtime/int)\n-    return error_;\n+  inline void AfterThreadPoolWork() override {\n+    Local<Value> arg = ToResult();\n+    async_wrap->MakeCallback(env->ondone_string(), 1, &arg);\n   }\n \n-  inline void set_error(unsigned long err) {  // NOLINT(runtime/int)\n-    error_ = err;\n+  inline Local<Value> ToResult() const {\n+    if (errors.empty()) return Undefined(env->isolate());\n+    return errors.ToException(env);\n   }\n-\n-  size_t self_size() const override { return sizeof(*this); }\n-\n-  void DoThreadPoolWork() override;\n-  void AfterThreadPoolWork(int status) override;\n-\n- private:\n-  unsigned long error_;  // NOLINT(runtime/int)\n-  size_t size_;\n-  char* data_;\n-  const FreeMode free_mode_;\n };\n \n \n-void RandomBytesRequest::DoThreadPoolWork() {\n-  // Ensure that OpenSSL's PRNG is properly seeded.\n-  CheckEntropy();\n-\n-  const int r = RAND_bytes(reinterpret_cast<unsigned char*>(data_), size_);\n-\n-  // RAND_bytes() returns 0 on error.\n-  if (r == 0) {\n-    set_error(ERR_get_error());  // NOLINT(runtime/int)\n-  } else if (r == -1) {\n-    set_error(static_cast<unsigned long>(-1));  // NOLINT(runtime/int)\n-  }\n-}\n-\n-\n-// don't call this function without a valid HandleScope\n-void RandomBytesCheck(RandomBytesRequest* req, Local<Value> (*argv)[2]) {\n-  if (req->error()) {\n-    char errmsg[256] = \"Operation not supported\";\n-\n-    if (req->error() != static_cast<unsigned long>(-1))  // NOLINT(runtime/int)\n-      ERR_error_string_n(req->error(), errmsg, sizeof errmsg);\n-\n-    (*argv)[0] = Exception::Error(OneByteString(req->env()->isolate(), errmsg));\n-    (*argv)[1] = Null(req->env()->isolate());\n-    req->release();\n-  } else {\n-    char* data = nullptr;\n-    size_t size;\n-    req->return_memory(&data, &size);\n-    (*argv)[0] = Null(req->env()->isolate());\n-    Local<Value> buffer =\n-        req->object()->Get(req->env()->context(),\n-                           req->env()->buffer_string()).ToLocalChecked();\n-\n-    if (buffer->IsArrayBufferView()) {\n-      CHECK_LE(req->size(), Buffer::Length(buffer));\n-      char* buf = Buffer::Data(buffer);\n-      memcpy(buf, data, req->size());\n-      (*argv)[1] = buffer;\n-    } else {\n-      (*argv)[1] = Buffer::New(req->env(), data, size)\n-          .ToLocalChecked();\n-    }\n-  }\n-}\n-\n-\n-void RandomBytesRequest::AfterThreadPoolWork(int status) {\n-  std::unique_ptr<RandomBytesRequest> req(this);\n-  if (status == UV_ECANCELED)\n-    return;\n-  CHECK_EQ(status, 0);\n-  HandleScope handle_scope(env()->isolate());\n-  Context::Scope context_scope(env()->context());\n-  Local<Value> argv[2];\n-  RandomBytesCheck(this, &argv);\n-  MakeCallback(env()->ondone_string(), arraysize(argv), argv);\n-}\n-\n-\n-void RandomBytesProcessSync(Environment* env,\n-                            std::unique_ptr<RandomBytesRequest> req,\n-                            Local<Value> (*argv)[2]) {\n-  env->PrintSyncTrace();\n-  req->DoThreadPoolWork();\n-  RandomBytesCheck(req.get(), argv);\n-\n-  if (!(*argv)[0]->IsNull())\n-    env->isolate()->ThrowException((*argv)[0]);\n-}\n-\n-\n void RandomBytes(const FunctionCallbackInfo<Value>& args) {\n+  CHECK(args[0]->IsArrayBufferView());  // buffer; wrap object retains ref.\n+  CHECK(args[1]->IsUint32());  // offset\n+  CHECK(args[2]->IsUint32());  // size\n+  CHECK(args[3]->IsObject() || args[3]->IsUndefined());  // wrap object\n+  const uint32_t offset = args[1].As<Uint32>()->Value();\n+  const uint32_t size = args[2].As<Uint32>()->Value();\n+  CHECK_GE(offset + size, offset);  // Overflow check.\n+  CHECK_LE(offset + size, Buffer::Length(args[0]));  // Bounds check.\n   Environment* env = Environment::GetCurrent(args);\n-\n-  const int64_t size = args[0]->IntegerValue();\n-  CHECK(size <= Buffer::kMaxLength);\n-\n-  Local<Object> obj = env->randombytes_constructor_template()->\n-      NewInstance(env->context()).ToLocalChecked();\n-  char* data = node::Malloc(size);\n-  std::unique_ptr<RandomBytesRequest> req(\n-      new RandomBytesRequest(env,\n-                             obj,\n-                             size,\n-                             data,\n-                             RandomBytesRequest::FREE_DATA));\n-\n-  if (args[1]->IsFunction()) {\n-    obj->Set(env->context(), env->ondone_string(), args[1]).FromJust();\n-\n-    req.release()->ScheduleWork();\n-    args.GetReturnValue().Set(obj);\n-  } else {\n-    Local<Value> argv[2];\n-    RandomBytesProcessSync(env, std::move(req), &argv);\n-    if (argv[0]->IsNull())\n-      args.GetReturnValue().Set(argv[1]);\n-  }\n-}\n-\n-\n-void RandomBytesBuffer(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  CHECK(args[0]->IsArrayBufferView());\n-  CHECK(args[1]->IsUint32());\n-  CHECK(args[2]->IsUint32());\n-\n-  int64_t offset = args[1]->IntegerValue();\n-  int64_t size = args[2]->IntegerValue();\n-\n-  Local<Object> obj = env->randombytes_constructor_template()->\n-      NewInstance(env->context()).ToLocalChecked();\n-  obj->Set(env->context(), env->buffer_string(), args[0]).FromJust();\n-  char* data = Buffer::Data(args[0]);\n-  data += offset;\n-\n-  std::unique_ptr<RandomBytesRequest> req(\n-      new RandomBytesRequest(env,\n-                             obj,\n-                             size,\n-                             data,\n-                             RandomBytesRequest::DONT_FREE_DATA));\n-  if (args[3]->IsFunction()) {\n-    obj->Set(env->context(), env->ondone_string(), args[3]).FromJust();\n-\n-    req.release()->ScheduleWork();\n-    args.GetReturnValue().Set(obj);\n-  } else {\n-    Local<Value> argv[2];\n-    RandomBytesProcessSync(env, std::move(req), &argv);\n-    if (argv[0]->IsNull())\n-      args.GetReturnValue().Set(argv[1]);\n-  }\n+  std::unique_ptr<RandomBytesJob> job(new RandomBytesJob(env));\n+  job->data = reinterpret_cast<unsigned char*>(Buffer::Data(args[0])) + offset;\n+  job->size = size;\n+  if (args[3]->IsObject()) return RandomBytesJob::Run(std::move(job), args[3]);\n+  env->PrintSyncTrace();\n+  job->DoThreadPoolWork();\n+  args.GetReturnValue().Set(job->ToResult());\n }\n \n \n@@ -5352,7 +5193,6 @@ void Initialize(Local<Object> target,\n \n   env->SetMethod(target, \"pbkdf2\", PBKDF2);\n   env->SetMethod(target, \"randomBytes\", RandomBytes);\n-  env->SetMethod(target, \"randomFill\", RandomBytesBuffer);\n   env->SetMethod(target, \"timingSafeEqual\", TimingSafeEqual);\n   env->SetMethod(target, \"getSSLCiphers\", GetSSLCiphers);\n   env->SetMethod(target, \"getCiphers\", GetCiphers);\n@@ -5377,13 +5217,6 @@ void Initialize(Local<Object> target,\n #ifndef OPENSSL_NO_SCRYPT\n   env->SetMethod(target, \"scrypt\", Scrypt);\n #endif  // OPENSSL_NO_SCRYPT\n-\n-  Local<FunctionTemplate> rb = FunctionTemplate::New(env->isolate());\n-  rb->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), \"RandomBytes\"));\n-  AsyncWrap::AddWrapMethods(env, rb);\n-  Local<ObjectTemplate> rbt = rb->InstanceTemplate();\n-  rbt->SetInternalFieldCount(1);\n-  env->set_randombytes_constructor_template(rbt);\n }\n \n }  // namespace crypto"
        },
        {
            "sha": "002ffcffd820c17ee7fa37e0da6d022b288a8f46",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=078bb0f0a0ef3fef2eee93fb1b6be117f6e93ef6",
            "patch": "@@ -120,7 +120,7 @@ if (common.hasCrypto) { // eslint-disable-line node-core/crypto-check\n   crypto.pbkdf2('password', 'salt', 1, 20, 'sha256', mc);\n \n   crypto.randomBytes(1, common.mustCall(function rb() {\n-    testInitialized(this, 'RandomBytes');\n+    testInitialized(this, 'AsyncWrap');\n   }));\n \n   if (typeof process.binding('crypto').scrypt === 'function') {"
        }
    ],
    "stats": {
        "total": 276,
        "additions": 65,
        "deletions": 211
    }
}