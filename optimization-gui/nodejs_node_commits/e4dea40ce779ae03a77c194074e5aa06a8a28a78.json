{
    "author": "oyyd",
    "message": "tls: make StreamWrap work correctly in \"drain\" callback\n\nWhen an instance of StreamWrap is shutting down and a \"drain\" event\nis emitted, the instance will abort as its\n`this[kCurrentShutdownRequest]` is already set. The following test\nwill fail before this commit.\n\nPR-URL: https://github.com/nodejs/node/pull/23294\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "e4dea40ce779ae03a77c194074e5aa06a8a28a78",
    "files": [
        {
            "sha": "e6de433676f7d3fb8b7b5e7f12bb97732c725d19",
            "filename": "lib/internal/wrap_js_stream.js",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/e4dea40ce779ae03a77c194074e5aa06a8a28a78/lib%2Finternal%2Fwrap_js_stream.js",
            "raw_url": "https://github.com/nodejs/node/raw/e4dea40ce779ae03a77c194074e5aa06a8a28a78/lib%2Finternal%2Fwrap_js_stream.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fwrap_js_stream.js?ref=e4dea40ce779ae03a77c194074e5aa06a8a28a78",
            "patch": "@@ -100,9 +100,6 @@ class JSStreamWrap extends Socket {\n   }\n \n   doShutdown(req) {\n-    assert.strictEqual(this[kCurrentShutdownRequest], null);\n-    this[kCurrentShutdownRequest] = req;\n-\n     // TODO(addaleax): It might be nice if we could get into a state where\n     // DoShutdown() is not called on streams while a write is still pending.\n     //\n@@ -113,8 +110,10 @@ class JSStreamWrap extends Socket {\n     // so for now that is supported here.\n \n     if (this[kCurrentWriteRequest] !== null)\n-      return this.on('drain', () => this.doShutdown(req));\n+      return this.once('drain', () => this.doShutdown(req));\n     assert.strictEqual(this[kCurrentWriteRequest], null);\n+    assert.strictEqual(this[kCurrentShutdownRequest], null);\n+    this[kCurrentShutdownRequest] = req;\n \n     const handle = this._handle;\n "
        },
        {
            "sha": "068e2d7fd45979b6aefa3b647c5f31cc658a8991",
            "filename": "test/parallel/test-stream-wrap-drain.js",
            "status": "added",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/nodejs/node/blob/e4dea40ce779ae03a77c194074e5aa06a8a28a78/test%2Fparallel%2Ftest-stream-wrap-drain.js",
            "raw_url": "https://github.com/nodejs/node/raw/e4dea40ce779ae03a77c194074e5aa06a8a28a78/test%2Fparallel%2Ftest-stream-wrap-drain.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream-wrap-drain.js?ref=e4dea40ce779ae03a77c194074e5aa06a8a28a78",
            "patch": "@@ -0,0 +1,50 @@\n+// Flags: --expose-internals\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const { StreamWrap } = require('_stream_wrap');\n+const { Duplex } = require('stream');\n+const { internalBinding } = require('internal/test/binding');\n+const { ShutdownWrap } = internalBinding('stream_wrap');\n+\n+// This test makes sure that when an instance of JSStreamWrap is waiting for\n+// a \"drain\" event to `doShutdown`, the instance will work correctly when a\n+// \"drain\" event emitted.\n+{\n+  let resolve = null;\n+\n+  class TestDuplex extends Duplex {\n+    _write(chunk, encoding, callback) {\n+      // We will resolve the write later.\n+      resolve = () => {\n+        callback();\n+      };\n+    }\n+\n+    _read() {}\n+  }\n+\n+  const testDuplex = new TestDuplex();\n+  const socket = new StreamWrap(testDuplex);\n+\n+  socket.write(\n+    // Make the buffer long enough so that the `Writable` will emit \"drain\".\n+    Buffer.allocUnsafe(socket.writableHighWaterMark * 2),\n+    common.mustCall()\n+  );\n+\n+  // Make sure that the 'drain' events will be emitted.\n+  testDuplex.on('drain', common.mustCall(() => {\n+    console.log('testDuplex drain');\n+  }));\n+\n+  assert.strictEqual(typeof resolve, 'function');\n+\n+  const req = new ShutdownWrap();\n+  req.oncomplete = common.mustCall();\n+  req.handle = socket._handle;\n+  // Should not throw.\n+  socket._handle.shutdown(req);\n+\n+  resolve();\n+}"
        }
    ],
    "stats": {
        "total": 57,
        "additions": 53,
        "deletions": 4
    }
}