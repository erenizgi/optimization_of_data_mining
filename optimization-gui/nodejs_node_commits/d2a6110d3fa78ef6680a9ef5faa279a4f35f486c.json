{
    "author": "jridgewell",
    "message": "string_decoder: reset decoder on end\n\nThis resets the StringDecoder's state after calling `#end`. Further\nwrites to the decoder will act as if it were a brand new instance,\nallowing simple reuse.\n\nPR-URL: https://github.com/nodejs/node/pull/18494\nFixes: https://github.com/nodejs/node/issues/16564\nRefs: https://github.com/nodejs/node/pull/16594\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "d2a6110d3fa78ef6680a9ef5faa279a4f35f486c",
    "files": [
        {
            "sha": "1e569ba6b26a4c266f69daa04e04bff880b4f673",
            "filename": "lib/string_decoder.js",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/d2a6110d3fa78ef6680a9ef5faa279a4f35f486c/lib%2Fstring_decoder.js",
            "raw_url": "https://github.com/nodejs/node/raw/d2a6110d3fa78ef6680a9ef5faa279a4f35f486c/lib%2Fstring_decoder.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fstring_decoder.js?ref=d2a6110d3fa78ef6680a9ef5faa279a4f35f486c",
            "patch": "@@ -210,8 +210,11 @@ function utf8Text(buf, i) {\n // character.\n function utf8End(buf) {\n   const r = (buf && buf.length ? this.write(buf) : '');\n-  if (this.lastNeed)\n+  if (this.lastNeed) {\n+    this.lastNeed = 0;\n+    this.lastTotal = 0;\n     return r + '\\ufffd';\n+  }\n   return r;\n }\n \n@@ -246,6 +249,8 @@ function utf16End(buf) {\n   const r = (buf && buf.length ? this.write(buf) : '');\n   if (this.lastNeed) {\n     const end = this.lastTotal - this.lastNeed;\n+    this.lastNeed = 0;\n+    this.lastTotal = 0;\n     return r + this.lastChar.toString('utf16le', 0, end);\n   }\n   return r;\n@@ -269,8 +274,12 @@ function base64Text(buf, i) {\n \n function base64End(buf) {\n   const r = (buf && buf.length ? this.write(buf) : '');\n-  if (this.lastNeed)\n-    return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n+  if (this.lastNeed) {\n+    const end = 3 - this.lastNeed;\n+    this.lastNeed = 0;\n+    this.lastTotal = 0;\n+    return r + this.lastChar.toString('base64', 0, end);\n+  }\n   return r;\n }\n "
        },
        {
            "sha": "2762ef096289db4e51e0f4650e12e5a85af5a018",
            "filename": "test/parallel/test-string-decoder-end.js",
            "status": "modified",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/d2a6110d3fa78ef6680a9ef5faa279a4f35f486c/test%2Fparallel%2Ftest-string-decoder-end.js",
            "raw_url": "https://github.com/nodejs/node/raw/d2a6110d3fa78ef6680a9ef5faa279a4f35f486c/test%2Fparallel%2Ftest-string-decoder-end.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-string-decoder-end.js?ref=d2a6110d3fa78ef6680a9ef5faa279a4f35f486c",
            "patch": "@@ -39,6 +39,46 @@ for (let i = 1; i <= 16; i++) {\n \n encodings.forEach(testEncoding);\n \n+testEnd('utf8', Buffer.of(0xE2), Buffer.of(0x61), '\\uFFFDa');\n+testEnd('utf8', Buffer.of(0xE2), Buffer.of(0x82), '\\uFFFD\\uFFFD');\n+testEnd('utf8', Buffer.of(0xE2), Buffer.of(0xE2), '\\uFFFD\\uFFFD');\n+testEnd('utf8', Buffer.of(0xE2, 0x82), Buffer.of(0x61), '\\uFFFDa');\n+testEnd('utf8', Buffer.of(0xE2, 0x82), Buffer.of(0xAC), '\\uFFFD\\uFFFD');\n+testEnd('utf8', Buffer.of(0xE2, 0x82), Buffer.of(0xE2), '\\uFFFD\\uFFFD');\n+testEnd('utf8', Buffer.of(0xE2, 0x82, 0xAC), Buffer.of(0x61), 'â‚¬a');\n+\n+testEnd('utf16le', Buffer.of(0x3D), Buffer.of(0x61, 0x00), 'a');\n+testEnd('utf16le', Buffer.of(0x3D), Buffer.of(0xD8, 0x4D, 0xDC), '\\u4DD8');\n+testEnd('utf16le', Buffer.of(0x3D, 0xD8), Buffer.of(), '\\uD83D');\n+testEnd('utf16le', Buffer.of(0x3D, 0xD8), Buffer.of(0x61, 0x00), '\\uD83Da');\n+testEnd(\n+  'utf16le',\n+  Buffer.of(0x3D, 0xD8),\n+  Buffer.of(0x4D, 0xDC),\n+  '\\uD83D\\uDC4D'\n+);\n+testEnd('utf16le', Buffer.of(0x3D, 0xD8, 0x4D), Buffer.of(), '\\uD83D');\n+testEnd(\n+  'utf16le',\n+  Buffer.of(0x3D, 0xD8, 0x4D),\n+  Buffer.of(0x61, 0x00),\n+  '\\uD83Da'\n+);\n+testEnd('utf16le', Buffer.of(0x3D, 0xD8, 0x4D), Buffer.of(0xDC), '\\uD83D');\n+testEnd(\n+  'utf16le',\n+  Buffer.of(0x3D, 0xD8, 0x4D, 0xDC),\n+  Buffer.of(0x61, 0x00),\n+  'ðŸ‘a'\n+);\n+\n+testEnd('base64', Buffer.of(0x61), Buffer.of(), 'YQ==');\n+testEnd('base64', Buffer.of(0x61), Buffer.of(0x61), 'YQ==YQ==');\n+testEnd('base64', Buffer.of(0x61, 0x61), Buffer.of(), 'YWE=');\n+testEnd('base64', Buffer.of(0x61, 0x61), Buffer.of(0x61), 'YWE=YQ==');\n+testEnd('base64', Buffer.of(0x61, 0x61, 0x61), Buffer.of(), 'YWFh');\n+testEnd('base64', Buffer.of(0x61, 0x61, 0x61), Buffer.of(0x61), 'YWFhYQ==');\n+\n function testEncoding(encoding) {\n   bufs.forEach((buf) => {\n     testBuf(encoding, buf);\n@@ -66,3 +106,14 @@ function testBuf(encoding, buf) {\n   assert.strictEqual(res1, res3, 'one byte at a time should match toString');\n   assert.strictEqual(res2, res3, 'all bytes at once should match toString');\n }\n+\n+function testEnd(encoding, incomplete, next, expected) {\n+  let res = '';\n+  const s = new SD(encoding);\n+  res += s.write(incomplete);\n+  res += s.end();\n+  res += s.write(next);\n+  res += s.end();\n+\n+  assert.strictEqual(res, expected);\n+}"
        }
    ],
    "stats": {
        "total": 66,
        "additions": 63,
        "deletions": 3
    }
}