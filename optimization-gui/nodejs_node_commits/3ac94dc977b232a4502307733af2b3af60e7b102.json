{
    "author": "addaleax",
    "message": "src: refactor tracing agent code\n\nAvoid unnecessary operations, add a bit of documentation,\nand turn the `ClientHandle` smart pointer alias into a real\nclass.\n\nThis should allow de-coupling the unnecessary combination of\na single specific `file_writer` from `Agent`.\n\nPR-URL: https://github.com/nodejs/node/pull/21867\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Eugene Ostroukhov <eostroukhov@google.com>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>",
    "sha": "3ac94dc977b232a4502307733af2b3af60e7b102",
    "files": [
        {
            "sha": "92c3597590dabfbea1e6fc49a9cb1ee2e2191256",
            "filename": "src/inspector/tracing_agent.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Finspector%2Ftracing_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Finspector%2Ftracing_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Ftracing_agent.cc?ref=3ac94dc977b232a4502307733af2b3af60e7b102",
            "patch": "@@ -46,9 +46,7 @@ class InspectorTraceWriter : public node::tracing::AsyncTraceWriter {\n }  // namespace\n \n TracingAgent::TracingAgent(Environment* env)\n-                           : env_(env),\n-                             trace_writer_(\n-                                  tracing::Agent::EmptyClientHandle()) {\n+                           : env_(env) {\n }\n \n TracingAgent::~TracingAgent() {\n@@ -62,7 +60,7 @@ void TracingAgent::Wire(UberDispatcher* dispatcher) {\n \n DispatchResponse TracingAgent::start(\n     std::unique_ptr<protocol::NodeTracing::TraceConfig> traceConfig) {\n-  if (trace_writer_ != nullptr) {\n+  if (!trace_writer_.empty()) {\n     return DispatchResponse::Error(\n         \"Call NodeTracing::end to stop tracing before updating the config\");\n   }"
        },
        {
            "sha": "029fce7c191b42113d78a5636639674e83632104",
            "filename": "src/inspector/tracing_agent.h",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Finspector%2Ftracing_agent.h",
            "raw_url": "https://github.com/nodejs/node/raw/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Finspector%2Ftracing_agent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Ftracing_agent.h?ref=3ac94dc977b232a4502307733af2b3af60e7b102",
            "patch": "@@ -2,16 +2,13 @@\n #define SRC_INSPECTOR_TRACING_AGENT_H_\n \n #include \"node/inspector/protocol/NodeTracing.h\"\n+#include \"tracing/agent.h\"\n #include \"v8.h\"\n \n \n namespace node {\n class Environment;\n \n-namespace tracing {\n-class Agent;\n-}  // namespace tracing\n-\n namespace inspector {\n namespace protocol {\n \n@@ -32,8 +29,7 @@ class TracingAgent : public NodeTracing::Backend {\n   void DisconnectTraceClient();\n \n   Environment* env_;\n-  std::unique_ptr<std::pair<tracing::Agent*, int>,\n-                  void (*)(std::pair<tracing::Agent*, int>*)> trace_writer_;\n+  tracing::AgentWriterHandle trace_writer_;\n   std::unique_ptr<NodeTracing::Frontend> frontend_;\n };\n "
        },
        {
            "sha": "b5b7ef1a5be86db7676956386ff59b042aec38b7",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=3ac94dc977b232a4502307733af2b3af60e7b102",
            "patch": "@@ -387,7 +387,7 @@ class NodeTraceStateObserver :\n static struct {\n #if NODE_USE_V8_PLATFORM\n   void Initialize(int thread_pool_size) {\n-    tracing_agent_.reset(new tracing::Agent(trace_file_pattern));\n+    tracing_agent_.reset(new tracing::Agent());\n     auto controller = tracing_agent_->GetTracingController();\n     controller->AddTraceStateObserver(new NodeTraceStateObserver(controller));\n     tracing::TraceEventHelper::SetTracingController(controller);\n@@ -427,12 +427,13 @@ static struct {\n #endif  // HAVE_INSPECTOR\n \n   void StartTracingAgent() {\n-    tracing_agent_->Enable(trace_enabled_categories);\n+    tracing_file_writer_ = tracing_agent_->AddClient(\n+        trace_enabled_categories,\n+        new tracing::NodeTraceWriter(trace_file_pattern));\n   }\n \n   void StopTracingAgent() {\n-    if (tracing_agent_)\n-      tracing_agent_->Stop();\n+    tracing_file_writer_.reset();\n   }\n \n   tracing::Agent* GetTracingAgent() const {\n@@ -444,6 +445,7 @@ static struct {\n   }\n \n   std::unique_ptr<tracing::Agent> tracing_agent_;\n+  tracing::AgentWriterHandle tracing_file_writer_;\n   NodePlatform* platform_;\n #else  // !NODE_USE_V8_PLATFORM\n   void Initialize(int thread_pool_size) {}"
        },
        {
            "sha": "9cc21863e3ed421ae1a1788a6e9830f3af1dd0b8",
            "filename": "src/tracing/agent.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 26,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Ftracing%2Fagent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Ftracing%2Fagent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fagent.cc?ref=3ac94dc977b232a4502307733af2b3af60e7b102",
            "patch": "@@ -44,7 +44,7 @@ using v8::platform::tracing::TraceWriter;\n using std::string;\n \n Agent::Agent(const std::string& log_file_pattern)\n-    : log_file_pattern_(log_file_pattern), file_writer_(EmptyClientHandle()) {\n+    : log_file_pattern_(log_file_pattern) {\n   tracing_controller_ = new TracingController();\n   tracing_controller_->Initialize(nullptr);\n }\n@@ -62,20 +62,23 @@ void Agent::Start() {\n   // This thread should be created *after* async handles are created\n   // (within NodeTraceWriter and NodeTraceBuffer constructors).\n   // Otherwise the thread could shut down prematurely.\n-  CHECK_EQ(0, uv_thread_create(&thread_, ThreadCb, this));\n+  CHECK_EQ(0, uv_thread_create(&thread_, [](void* arg) {\n+    Agent* agent = static_cast<Agent*>(arg);\n+    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);\n+  }, this));\n   started_ = true;\n }\n \n-Agent::ClientHandle Agent::AddClient(const std::set<std::string>& categories,\n-                                     std::unique_ptr<AsyncTraceWriter> writer) {\n+AgentWriterHandle Agent::AddClient(\n+    const std::set<std::string>& categories,\n+    std::unique_ptr<AsyncTraceWriter> writer) {\n   Start();\n   ScopedSuspendTracing suspend(tracing_controller_, this);\n   int id = next_writer_id_++;\n   writers_[id] = std::move(writer);\n   categories_[id] = categories;\n \n-  auto client_id = new std::pair<Agent*, int>(this, id);\n-  return ClientHandle(client_id, &DisconnectClient);\n+  return AgentWriterHandle(this, id);\n }\n \n void Agent::Stop() {\n@@ -101,61 +104,52 @@ void Agent::Disconnect(int client) {\n   categories_.erase(client);\n }\n \n-// static\n-void Agent::ThreadCb(void* arg) {\n-  Agent* agent = static_cast<Agent*>(arg);\n-  uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);\n-}\n-\n void Agent::Enable(const std::string& categories) {\n   if (categories.empty())\n     return;\n   std::set<std::string> categories_set;\n-  std::stringstream category_list(categories);\n+  std::istringstream category_list(categories);\n   while (category_list.good()) {\n     std::string category;\n     getline(category_list, category, ',');\n-    categories_set.insert(category);\n+    categories_set.emplace(std::move(category));\n   }\n   Enable(categories_set);\n }\n \n void Agent::Enable(const std::set<std::string>& categories) {\n-  std::string cats;\n-  for (const std::string cat : categories)\n-    cats += cat + \", \";\n   if (categories.empty())\n     return;\n \n   file_writer_categories_.insert(categories.begin(), categories.end());\n   std::set<std::string> full_list(file_writer_categories_.begin(),\n                                   file_writer_categories_.end());\n-  if (!file_writer_) {\n+  if (file_writer_.empty()) {\n     // Ensure background thread is running\n     Start();\n     std::unique_ptr<NodeTraceWriter> writer(\n         new NodeTraceWriter(log_file_pattern_, &tracing_loop_));\n     file_writer_ = AddClient(full_list, std::move(writer));\n   } else {\n     ScopedSuspendTracing suspend(tracing_controller_, this);\n-    categories_[file_writer_->second] = full_list;\n+    categories_[file_writer_.id_] = full_list;\n   }\n }\n \n void Agent::Disable(const std::set<std::string>& categories) {\n-  for (auto category : categories) {\n+  for (const std::string& category : categories) {\n     auto it = file_writer_categories_.find(category);\n     if (it != file_writer_categories_.end())\n       file_writer_categories_.erase(it);\n   }\n-  if (!file_writer_)\n+  if (file_writer_.empty())\n     return;\n   ScopedSuspendTracing suspend(tracing_controller_, this);\n-  categories_[file_writer_->second] = { file_writer_categories_.begin(),\n-                                        file_writer_categories_.end() };\n+  categories_[file_writer_.id_] = { file_writer_categories_.begin(),\n+                                    file_writer_categories_.end() };\n }\n \n-TraceConfig* Agent::CreateTraceConfig() {\n+TraceConfig* Agent::CreateTraceConfig() const {\n   if (categories_.empty())\n     return nullptr;\n   TraceConfig* trace_config = new TraceConfig();\n@@ -165,9 +159,9 @@ TraceConfig* Agent::CreateTraceConfig() {\n   return trace_config;\n }\n \n-std::string Agent::GetEnabledCategories() {\n+std::string Agent::GetEnabledCategories() const {\n   std::string categories;\n-  for (const auto& category : flatten(categories_)) {\n+  for (const std::string& category : flatten(categories_)) {\n     if (!categories.empty())\n       categories += ',';\n     categories += category;"
        },
        {
            "sha": "022e86f11afba9da97332c6baa91810b3a2a058e",
            "filename": "src/tracing/agent.h",
            "status": "modified",
            "additions": 57,
            "deletions": 18,
            "changes": 75,
            "blob_url": "https://github.com/nodejs/node/blob/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Ftracing%2Fagent.h",
            "raw_url": "https://github.com/nodejs/node/raw/3ac94dc977b232a4502307733af2b3af60e7b102/src%2Ftracing%2Fagent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fagent.h?ref=3ac94dc977b232a4502307733af2b3af60e7b102",
            "patch": "@@ -4,6 +4,7 @@\n #include \"libplatform/v8-tracing.h\"\n #include \"uv.h\"\n #include \"v8.h\"\n+#include \"util.h\"\n \n #include <set>\n #include <string>\n@@ -15,6 +16,8 @@ namespace tracing {\n using v8::platform::tracing::TraceConfig;\n using v8::platform::tracing::TraceObject;\n \n+class Agent;\n+\n class AsyncTraceWriter {\n  public:\n   virtual ~AsyncTraceWriter() {}\n@@ -31,42 +34,58 @@ class TracingController : public v8::platform::tracing::TracingController {\n   }\n };\n \n+class AgentWriterHandle {\n+ public:\n+  inline AgentWriterHandle() {}\n+  inline ~AgentWriterHandle() { reset(); }\n+\n+  inline AgentWriterHandle(AgentWriterHandle&& other);\n+  inline AgentWriterHandle& operator=(AgentWriterHandle&& other);\n+  inline bool empty() const { return agent_ == nullptr; }\n+  inline void reset();\n+\n+ private:\n+  inline AgentWriterHandle(Agent* agent, int id) : agent_(agent), id_(id) {}\n+\n+  AgentWriterHandle(const AgentWriterHandle& other) = delete;\n+  AgentWriterHandle& operator=(const AgentWriterHandle& other) = delete;\n+\n+  Agent* agent_ = nullptr;\n+  int id_;\n+\n+  friend class Agent;\n+};\n \n class Agent {\n  public:\n-  // Resetting the pointer disconnects client\n-  using ClientHandle = std::unique_ptr<std::pair<Agent*, int>,\n-                                       void (*)(std::pair<Agent*, int>*)>;\n-\n-  static ClientHandle EmptyClientHandle() {\n-    return ClientHandle(nullptr, DisconnectClient);\n-  }\n   explicit Agent(const std::string& log_file_pattern);\n   void Stop();\n \n   TracingController* GetTracingController() { return tracing_controller_; }\n \n   // Destroying the handle disconnects the client\n-  ClientHandle AddClient(const std::set<std::string>& categories,\n-                         std::unique_ptr<AsyncTraceWriter> writer);\n+  AgentWriterHandle AddClient(const std::set<std::string>& categories,\n+                              std::unique_ptr<AsyncTraceWriter> writer);\n \n   // These 3 methods operate on a \"default\" client, e.g. the file writer\n   void Enable(const std::string& categories);\n   void Enable(const std::set<std::string>& categories);\n   void Disable(const std::set<std::string>& categories);\n-  std::string GetEnabledCategories();\n \n+  // Returns a comma-separated list of enabled categories.\n+  std::string GetEnabledCategories() const;\n+\n+  // Writes to all writers registered through AddClient().\n   void AppendTraceEvent(TraceObject* trace_event);\n+  // Flushes all writers registered through AddClient().\n   void Flush(bool blocking);\n \n-  TraceConfig* CreateTraceConfig();\n+  TraceConfig* CreateTraceConfig() const;\n \n  private:\n+  friend class AgentWriterHandle;\n+\n   static void ThreadCb(void* arg);\n-  static void DisconnectClient(std::pair<Agent*, int>* id_agent) {\n-    id_agent->first->Disconnect(id_agent->second);\n-    delete id_agent;\n-  }\n \n   void Start();\n   void StopTracing();\n@@ -77,14 +96,34 @@ class Agent {\n   uv_loop_t tracing_loop_;\n   bool started_ = false;\n \n-  std::unordered_map<int, std::set<std::string>> categories_;\n-  TracingController* tracing_controller_ = nullptr;\n-  ClientHandle file_writer_;\n+  // Each individual Writer has one id.\n   int next_writer_id_ = 1;\n+  // These maps store the original arguments to AddClient(), by id.\n+  std::unordered_map<int, std::set<std::string>> categories_;\n   std::unordered_map<int, std::unique_ptr<AsyncTraceWriter>> writers_;\n+  TracingController* tracing_controller_ = nullptr;\n+  AgentWriterHandle file_writer_;\n   std::multiset<std::string> file_writer_categories_;\n };\n \n+void AgentWriterHandle::reset() {\n+  if (agent_ != nullptr)\n+    agent_->Disconnect(id_);\n+  agent_ = nullptr;\n+}\n+\n+AgentWriterHandle& AgentWriterHandle::operator=(AgentWriterHandle&& other) {\n+  reset();\n+  agent_ = other.agent_;\n+  id_ = other.id_;\n+  other.agent_ = nullptr;\n+  return *this;\n+}\n+\n+AgentWriterHandle::AgentWriterHandle(AgentWriterHandle&& other) {\n+  *this = std::move(other);\n+}\n+\n }  // namespace tracing\n }  // namespace node\n "
        }
    ],
    "stats": {
        "total": 145,
        "additions": 87,
        "deletions": 58
    }
}