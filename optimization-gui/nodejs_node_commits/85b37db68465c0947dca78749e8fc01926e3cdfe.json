{
    "author": "jasnell",
    "message": "fs: add FileHandle object fd wrapper\n\nThe `node::fs::FileHandle` object wraps a file descriptor\nand will close it on garbage collection along with a\nprocess warning. The intent is to prevent (as much as\npossible) file descriptors from being leaked if the user\ndoes not close them explicitly.\n\nPR-URL: https://github.com/nodejs/node/pull/18297\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "85b37db68465c0947dca78749e8fc01926e3cdfe",
    "files": [
        {
            "sha": "1a5a347ba6519b2d498f824bcbd69eb539a11cd8",
            "filename": "src/async_wrap.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/85b37db68465c0947dca78749e8fc01926e3cdfe/src%2Fasync_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/85b37db68465c0947dca78749e8fc01926e3cdfe/src%2Fasync_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.h?ref=85b37db68465c0947dca78749e8fc01926e3cdfe",
            "patch": "@@ -36,6 +36,8 @@ namespace node {\n #define NODE_ASYNC_NON_CRYPTO_PROVIDER_TYPES(V)                               \\\n   V(NONE)                                                                     \\\n   V(DNSCHANNEL)                                                               \\\n+  V(FILEHANDLE)                                                               \\\n+  V(FILEHANDLECLOSEREQ)                                                       \\\n   V(FSEVENTWRAP)                                                              \\\n   V(FSREQWRAP)                                                                \\\n   V(FSREQPROMISE)                                                             \\"
        },
        {
            "sha": "262ccdef387471ec1401d54faae4342fc582bda6",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/85b37db68465c0947dca78749e8fc01926e3cdfe/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/85b37db68465c0947dca78749e8fc01926e3cdfe/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=85b37db68465c0947dca78749e8fc01926e3cdfe",
            "patch": "@@ -283,6 +283,8 @@ class ModuleWrap;\n   V(buffer_prototype_object, v8::Object)                                      \\\n   V(context, v8::Context)                                                     \\\n   V(domain_callback, v8::Function)                                            \\\n+  V(fd_constructor_template, v8::ObjectTemplate)                              \\\n+  V(fdclose_constructor_template, v8::ObjectTemplate)                         \\\n   V(host_import_module_dynamically_callback, v8::Function)                    \\\n   V(host_initialize_import_meta_object_callback, v8::Function)                \\\n   V(http2ping_constructor_template, v8::ObjectTemplate)                       \\"
        },
        {
            "sha": "c4fc802669ea576572fffc1ab5de681d605c2db9",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 210,
            "deletions": 4,
            "changes": 214,
            "blob_url": "https://github.com/nodejs/node/blob/85b37db68465c0947dca78749e8fc01926e3cdfe/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/85b37db68465c0947dca78749e8fc01926e3cdfe/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=85b37db68465c0947dca78749e8fc01926e3cdfe",
            "patch": "@@ -97,6 +97,7 @@ using v8::Local;\n using v8::MaybeLocal;\n using v8::Number;\n using v8::Object;\n+using v8::ObjectTemplate;\n using v8::Promise;\n using v8::String;\n using v8::Undefined;\n@@ -108,6 +109,150 @@ using v8::Value;\n \n #define GET_OFFSET(a) ((a)->IsNumber() ? (a)->IntegerValue() : -1)\n \n+// The FileHandle object wraps a file descriptor and will close it on garbage\n+// collection if necessary. If that happens, a process warning will be\n+// emitted (or a fatal exception will occur if the fd cannot be closed.)\n+FileHandle::FileHandle(Environment* env, int fd)\n+    : AsyncWrap(env,\n+                env->fd_constructor_template()\n+                    ->NewInstance(env->context()).ToLocalChecked(),\n+                AsyncWrap::PROVIDER_FILEHANDLE), fd_(fd) {\n+  MakeWeak<FileHandle>(this);\n+  v8::PropertyAttribute attr =\n+      static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete);\n+  object()->DefineOwnProperty(env->context(),\n+                              FIXED_ONE_BYTE_STRING(env->isolate(), \"fd\"),\n+                              Integer::New(env->isolate(), fd),\n+                              attr).FromJust();\n+}\n+\n+FileHandle::~FileHandle() {\n+  CHECK(!closing_);  // We should not be deleting while explicitly closing!\n+  Close();           // Close synchronously and emit warning\n+  CHECK(closed_);    // We have to be closed at the point\n+  CHECK(persistent().IsEmpty());\n+}\n+\n+\n+// Close the file descriptor if it hasn't already been closed. A process\n+// warning will be emitted using a SetImmediate to avoid calling back to\n+// JS during GC. If closing the fd fails at this point, a fatal exception\n+// will crash the process immediately.\n+inline void FileHandle::Close() {\n+  if (closed_) return;\n+  closed_ = true;\n+  uv_fs_t req;\n+  int ret = uv_fs_close(env()->event_loop(), &req, fd_, nullptr);\n+  uv_fs_req_cleanup(&req);\n+\n+  struct err_detail { int ret; int fd; };\n+\n+  err_detail* detail = new err_detail { ret, fd_ };\n+\n+  if (ret < 0) {\n+    // Do not unref this\n+    env()->SetImmediate([](Environment* env, void* data) {\n+      char msg[70];\n+      err_detail* detail = static_cast<err_detail*>(data);\n+      snprintf(msg, arraysize(msg),\n+              \"Closing file descriptor %d on garbage collection failed\",\n+              detail->fd);\n+      // This exception will end up being fatal for the process because\n+      // it is being thrown from within the SetImmediate handler and\n+      // there is no JS stack to bubble it to. In other words, tearing\n+      // down the process is the only reasonable thing we can do here.\n+      env->ThrowUVException(detail->ret, \"close\", msg);\n+      delete detail;\n+    }, detail);\n+    return;\n+  }\n+\n+  // If the close was successful, we still want to emit a process warning\n+  // to notify that the file descriptor was gc'd. We want to be noisy about\n+  // this because not explicitly closing the garbage collector is a bug.\n+  env()->SetUnrefImmediate([](Environment* env, void* data) {\n+    char msg[70];\n+    err_detail* detail = static_cast<err_detail*>(data);\n+    snprintf(msg, arraysize(msg),\n+            \"Closing file descriptor %d on garbage collection\",\n+            detail->fd);\n+    delete detail;\n+    ProcessEmitWarning(env, msg);\n+  }, detail);\n+}\n+\n+void FileHandle::CloseReq::Resolve() {\n+  InternalCallbackScope callback_scope(this);\n+  HandleScope scope(env()->isolate());\n+  Local<Promise> promise = promise_.Get(env()->isolate());\n+  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n+  resolver->Resolve(env()->context(), Undefined(env()->isolate()));\n+}\n+\n+void FileHandle::CloseReq::Reject(Local<Value> reason) {\n+  InternalCallbackScope callback_scope(this);\n+  HandleScope scope(env()->isolate());\n+  Local<Promise> promise = promise_.Get(env()->isolate());\n+  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n+  resolver->Reject(env()->context(), reason);\n+}\n+\n+FileHandle* FileHandle::CloseReq::fd() {\n+  HandleScope scope(env()->isolate());\n+  Local<Value> val = ref_.Get(env()->isolate());\n+  Local<Object> obj = val.As<Object>();\n+  return Unwrap<FileHandle>(obj);\n+}\n+\n+// Closes this FileHandle asynchronously and returns a Promise that will be\n+// resolved when the callback is invoked, or rejects with a UVException if\n+// there was a problem closing the fd. This is the preferred mechanism for\n+// closing the FD object even tho the object will attempt to close\n+// automatically on gc.\n+inline Local<Promise> FileHandle::ClosePromise() {\n+  Isolate* isolate = env()->isolate();\n+  HandleScope scope(isolate);\n+  Local<Context> context = env()->context();\n+  auto maybe_resolver = Promise::Resolver::New(context);\n+  CHECK(!maybe_resolver.IsEmpty());\n+  Local<Promise::Resolver> resolver = maybe_resolver.ToLocalChecked();\n+  Local<Promise> promise = resolver.As<Promise>();\n+  if (!closed_ && !closing_) {\n+    closing_ = true;\n+    CloseReq* req = new CloseReq(env(), promise, object());\n+    auto AfterClose = [](uv_fs_t* req) {\n+      CloseReq* close = static_cast<CloseReq*>(req->data);\n+      CHECK_NE(close, nullptr);\n+      close->fd()->closing_ = false;\n+      Isolate* isolate = close->env()->isolate();\n+      if (req->result < 0) {\n+        close->Reject(UVException(isolate, req->result, \"close\"));\n+      } else {\n+        close->fd()->closed_ = true;\n+        close->Resolve();\n+      }\n+      delete close;\n+    };\n+    req->Dispatched();\n+    int ret = uv_fs_close(env()->event_loop(), req->req(), fd_, AfterClose);\n+    if (ret < 0) {\n+      req->Reject(UVException(isolate, ret, \"close\"));\n+      delete req;\n+    }\n+  } else {\n+    // Already closed. Just reject the promise immediately\n+    resolver->Reject(context, UVException(isolate, UV_EBADF, \"close\"));\n+  }\n+  return promise;\n+}\n+\n+void FileHandle::Close(const FunctionCallbackInfo<Value>& args) {\n+  FileHandle* fd;\n+  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());\n+  args.GetReturnValue().Set(fd->ClosePromise());\n+}\n+\n+\n void FSReqWrap::Reject(Local<Value> reject) {\n   MakeCallback(env()->oncomplete_string(), 1, &reject);\n }\n@@ -142,8 +287,7 @@ FSReqPromise::FSReqPromise(Environment* env, Local<Object> req)\n \n   Local<ArrayBuffer> ab =\n       ArrayBuffer::New(env->isolate(), statFields_,\n-                       sizeof(double) * 14,\n-                       v8::ArrayBufferCreationMode::kInternalized);\n+                       sizeof(double) * 14);\n   object()->Set(env->context(),\n                 env->statfields_string(),\n                 Float64Array::New(ab, 0, 14)).FromJust();\n@@ -261,6 +405,16 @@ void AfterInteger(uv_fs_t* req) {\n     req_wrap->Resolve(Integer::New(req_wrap->env()->isolate(), req->result));\n }\n \n+void AfterOpenFileHandle(uv_fs_t* req) {\n+  FSReqWrap* req_wrap = static_cast<FSReqWrap*>(req->data);\n+  FSReqAfterScope after(req_wrap, req);\n+\n+  if (after.Proceed()) {\n+    FileHandle* fd = new FileHandle(req_wrap->env(), req->result);\n+    req_wrap->Resolve(fd->object());\n+  }\n+}\n+\n void AfterStringPath(uv_fs_t* req) {\n   FSReqBase* req_wrap = static_cast<FSReqBase*>(req->data);\n   FSReqAfterScope after(req_wrap, req);\n@@ -969,6 +1123,7 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n \n static void Open(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Local<Context> context = env->context();\n \n   CHECK_GE(args.Length(), 3);\n   CHECK(args[1]->IsInt32());\n@@ -977,8 +1132,8 @@ static void Open(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  int flags = args[1]->Int32Value();\n-  int mode = static_cast<int>(args[2]->Int32Value());\n+  int flags = args[1]->Int32Value(context).ToChecked();\n+  int mode = args[2]->Int32Value(context).ToChecked();\n \n   if (args[3]->IsObject()) {\n     CHECK_EQ(args.Length(), 4);\n@@ -990,6 +1145,35 @@ static void Open(const FunctionCallbackInfo<Value>& args) {\n   }\n }\n \n+static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Local<Context> context = env->context();\n+\n+  CHECK_GE(args.Length(), 3);\n+  CHECK(args[1]->IsInt32());\n+  CHECK(args[2]->IsInt32());\n+\n+  BufferValue path(env->isolate(), args[0]);\n+  CHECK_NE(*path, nullptr);\n+\n+  int flags = args[1]->Int32Value(context).ToChecked();\n+  int mode = args[2]->Int32Value(context).ToChecked();\n+\n+  if (args[3]->IsObject()) {\n+    CHECK_EQ(args.Length(), 4);\n+    AsyncCall(env, args, \"open\", UTF8, AfterOpenFileHandle,\n+              uv_fs_open, *path, flags, mode);\n+  } else {\n+    SYNC_CALL(open, *path, *path, flags, mode)\n+    if (SYNC_RESULT < 0) {\n+      args.GetReturnValue().Set(SYNC_RESULT);\n+    } else {\n+      HandleScope scope(env->isolate());\n+      FileHandle* fd = new FileHandle(env, SYNC_RESULT);\n+      args.GetReturnValue().Set(fd->object());\n+    }\n+  }\n+}\n \n static void CopyFile(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n@@ -1391,6 +1575,7 @@ void InitFs(Local<Object> target,\n   env->SetMethod(target, \"access\", Access);\n   env->SetMethod(target, \"close\", Close);\n   env->SetMethod(target, \"open\", Open);\n+  env->SetMethod(target, \"openFileHandle\", OpenFileHandle);\n   env->SetMethod(target, \"read\", Read);\n   env->SetMethod(target, \"fdatasync\", Fdatasync);\n   env->SetMethod(target, \"fsync\", Fsync);\n@@ -1452,6 +1637,27 @@ void InitFs(Local<Object> target,\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"FSReqPromise\");\n   fpt->SetClassName(promiseString);\n   target->Set(context, promiseString, fpt->GetFunction()).FromJust();\n+\n+  // Create FunctionTemplate for FileHandle\n+  Local<FunctionTemplate> fd = FunctionTemplate::New(env->isolate());\n+  AsyncWrap::AddWrapMethods(env, fd);\n+  env->SetProtoMethod(fd, \"close\", FileHandle::Close);\n+  Local<ObjectTemplate> fdt = fd->InstanceTemplate();\n+  fdt->SetInternalFieldCount(1);\n+  Local<String> handleString =\n+       FIXED_ONE_BYTE_STRING(env->isolate(), \"FileHandle\");\n+  fd->SetClassName(handleString);\n+  target->Set(context, handleString, fd->GetFunction()).FromJust();\n+  env->set_fd_constructor_template(fdt);\n+\n+  // Create FunctionTemplate for FileHandle::CloseReq\n+  Local<FunctionTemplate> fdclose = FunctionTemplate::New(env->isolate());\n+  fdclose->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(),\n+                        \"FileHandleCloseReq\"));\n+  AsyncWrap::AddWrapMethods(env, fdclose);\n+  Local<ObjectTemplate> fdcloset = fdclose->InstanceTemplate();\n+  fdcloset->SetInternalFieldCount(1);\n+  env->set_fdclose_constructor_template(fdcloset);\n }\n \n }  // namespace fs"
        },
        {
            "sha": "4d276aaa3f049963653fd811a331f1c9148588a5",
            "filename": "src/node_file.h",
            "status": "modified",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/nodejs/node/blob/85b37db68465c0947dca78749e8fc01926e3cdfe/src%2Fnode_file.h",
            "raw_url": "https://github.com/nodejs/node/raw/85b37db68465c0947dca78749e8fc01926e3cdfe/src%2Fnode_file.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.h?ref=85b37db68465c0947dca78749e8fc01926e3cdfe",
            "patch": "@@ -9,9 +9,12 @@\n namespace node {\n \n using v8::Context;\n+using v8::FunctionCallbackInfo;\n using v8::HandleScope;\n using v8::Local;\n using v8::Object;\n+using v8::Persistent;\n+using v8::Promise;\n using v8::Undefined;\n using v8::Value;\n \n@@ -112,6 +115,66 @@ class FSReqAfterScope {\n   Context::Scope context_scope_;\n };\n \n+// A wrapper for a file descriptor that will automatically close the fd when\n+// the object is garbage collected\n+class FileHandle : public AsyncWrap {\n+ public:\n+  FileHandle(Environment* env, int fd);\n+  virtual ~FileHandle();\n+\n+  int fd() const { return fd_; }\n+  size_t self_size() const override { return sizeof(*this); }\n+\n+  // Will asynchronously close the FD and return a Promise that will\n+  // be resolved once closing is complete.\n+  static void Close(const FunctionCallbackInfo<Value>& args);\n+\n+ private:\n+  // Synchronous close that emits a warning\n+  inline void Close();\n+\n+  class CloseReq : public ReqWrap<uv_fs_t> {\n+   public:\n+    CloseReq(Environment* env,\n+             Local<Promise> promise,\n+             Local<Value> ref)\n+        : ReqWrap(env,\n+                  env->fdclose_constructor_template()\n+                      ->NewInstance(env->context()).ToLocalChecked(),\n+                  AsyncWrap::PROVIDER_FILEHANDLECLOSEREQ) {\n+      Wrap(object(), this);\n+      promise_.Reset(env->isolate(), promise);\n+      ref_.Reset(env->isolate(), ref);\n+    }\n+    ~CloseReq() {\n+      uv_fs_req_cleanup(req());\n+      promise_.Empty();\n+      ref_.Empty();\n+    }\n+\n+    FileHandle* fd();\n+\n+    size_t self_size() const override { return sizeof(*this); }\n+\n+    void Resolve();\n+\n+    void Reject(Local<Value> reason);\n+\n+   private:\n+    Persistent<Promise> promise_;\n+    Persistent<Value> ref_;\n+  };\n+\n+  // Asynchronous close\n+  inline Local<Promise> ClosePromise();\n+\n+  int fd_;\n+  bool closing_ = false;\n+  bool closed_ = false;\n+\n+  DISALLOW_COPY_AND_ASSIGN(FileHandle);\n+};\n+\n }  // namespace fs\n \n }  // namespace node"
        }
    ],
    "stats": {
        "total": 281,
        "additions": 277,
        "deletions": 4
    }
}