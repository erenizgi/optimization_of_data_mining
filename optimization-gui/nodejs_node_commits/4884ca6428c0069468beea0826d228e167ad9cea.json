{
    "author": "BridgeAR",
    "message": "deps: V8: backport 3e010af\n\nOriginal commit message:\n\n    [CloneObjectIC] clone MutableHeapNumbers only if !FLAG_unbox_double_fields\n\n    Change the macros added in bf84766a2cd3e09070adcd6228a3a487c8dc4bbd to\n    only do the hard work if FLAG_unbox_double_fields is unset (otherwise,\n    they will attempt to dereference raw float64s, which is bad!)\n\n    Also adds a write barrier in CopyPropertyArrayValues for each store if\n    it's possible that a MutableHeapNumber is cloned.\n\n    BUG=chromium:901301, chromium:902965, chromium:903070, v8:7611\n    R=cbruni@chromium.org, jkummerow@chromium.org, ishell@chromium.org\n\n    Change-Id: I224d3c4e7b0a887684bff68985b4d97021ba4cfb\n    Reviewed-on: https://chromium-review.googlesource.com/c/1323911\n    Commit-Queue: Caitlin Potter <caitp@igalia.com>\n    Reviewed-by: Camillo Bruni <cbruni@chromium.org>\n    Reviewed-by: Igor Sheludko <ishell@chromium.org>\n    Cr-Commit-Position: refs/heads/master@{#57368}\n\nPR-URL: https://github.com/nodejs/node/pull/25101\nRefs: https://github.com/v8/v8/commit/3e010af274088493f3485d7a16dec4e31550e876\nFixes: https://github.com/nodejs/node/issues/25089\nReviewed-By: Richard Lau <riclau@uk.ibm.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>\nReviewed-By: Yang Guo <yangguo@chromium.org>",
    "sha": "4884ca6428c0069468beea0826d228e167ad9cea",
    "files": [
        {
            "sha": "9c5efa905dfd3c51fc5b5e9435344d0a8ce12272",
            "filename": "common.gypi",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/4884ca6428c0069468beea0826d228e167ad9cea/common.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/4884ca6428c0069468beea0826d228e167ad9cea/common.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/common.gypi?ref=4884ca6428c0069468beea0826d228e167ad9cea",
            "patch": "@@ -38,7 +38,7 @@\n \n     # Reset this number to 0 on major V8 upgrades.\n     # Increment by one for each non-official patch applied to deps/v8.\n-    'v8_embedder_string': '-node.6',\n+    'v8_embedder_string': '-node.7',\n \n     ##### V8 defaults for Node.js #####\n "
        },
        {
            "sha": "d34236bab77051df7dfe32c269adb64da80b92ac",
            "filename": "deps/v8/src/builtins/builtins-constructor-gen.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fbuiltins%2Fbuiltins-constructor-gen.cc?ref=4884ca6428c0069468beea0826d228e167ad9cea",
            "patch": "@@ -534,8 +534,7 @@ Node* ConstructorBuiltinsAssembler::EmitCreateShallowObjectLiteral(\n     VARIABLE(offset, MachineType::PointerRepresentation(),\n              IntPtrConstant(JSObject::kHeaderSize));\n     // Mutable heap numbers only occur on 32-bit platforms.\n-    bool may_use_mutable_heap_numbers =\n-        FLAG_track_double_fields && !FLAG_unbox_double_fields;\n+    bool may_use_mutable_heap_numbers = !FLAG_unbox_double_fields;\n     {\n       Comment(\"Copy in-object properties fast\");\n       Label continue_fast(this, &offset);"
        },
        {
            "sha": "6a70ee825e90357337283a3f9e1ca8572fb1648d",
            "filename": "deps/v8/src/code-stub-assembler.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-stub-assembler.cc?ref=4884ca6428c0069468beea0826d228e167ad9cea",
            "patch": "@@ -4931,6 +4931,13 @@ void CodeStubAssembler::CopyPropertyArrayValues(Node* from_array,\n   Comment(\"[ CopyPropertyArrayValues\");\n \n   bool needs_write_barrier = barrier_mode == UPDATE_WRITE_BARRIER;\n+\n+  if (destroy_source == DestroySource::kNo) {\n+    // PropertyArray may contain MutableHeapNumbers, which will be cloned on the\n+    // heap, requiring a write barrier.\n+    needs_write_barrier = true;\n+  }\n+\n   Node* start = IntPtrOrSmiConstant(0, mode);\n   ElementsKind kind = PACKED_ELEMENTS;\n   BuildFastFixedArrayForEach("
        },
        {
            "sha": "0cb326763c9cb81b3e4fb5fb416cd0d896ebb989",
            "filename": "deps/v8/src/ic/accessor-assembler.cc",
            "status": "modified",
            "additions": 41,
            "deletions": 19,
            "changes": 60,
            "blob_url": "https://github.com/nodejs/node/blob/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Fsrc%2Fic%2Faccessor-assembler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Fsrc%2Fic%2Faccessor-assembler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fic%2Faccessor-assembler.cc?ref=4884ca6428c0069468beea0826d228e167ad9cea",
            "patch": "@@ -3566,7 +3566,7 @@ void AccessorAssembler::GenerateCloneObjectIC_Slow() {\n \n void AccessorAssembler::GenerateCloneObjectIC() {\n   typedef CloneObjectWithVectorDescriptor Descriptor;\n-  Node* source = Parameter(Descriptor::kSource);\n+  TNode<HeapObject> source = CAST(Parameter(Descriptor::kSource));\n   Node* flags = Parameter(Descriptor::kFlags);\n   Node* slot = Parameter(Descriptor::kSlot);\n   Node* vector = Parameter(Descriptor::kVector);\n@@ -3576,8 +3576,7 @@ void AccessorAssembler::GenerateCloneObjectIC() {\n   Label miss(this, Label::kDeferred), try_polymorphic(this, Label::kDeferred),\n       try_megamorphic(this, Label::kDeferred);\n \n-  CSA_SLOW_ASSERT(this, TaggedIsNotSmi(source));\n-  Node* source_map = LoadMap(UncheckedCast<HeapObject>(source));\n+  TNode<Map> source_map = LoadMap(UncheckedCast<HeapObject>(source));\n   GotoIf(IsDeprecatedMap(source_map), &miss);\n   TNode<MaybeObject> feedback = TryMonomorphicCase(\n       slot, vector, source_map, &if_handler, &var_handler, &try_polymorphic);\n@@ -3598,7 +3597,7 @@ void AccessorAssembler::GenerateCloneObjectIC() {\n \n     // The IC fast case should only be taken if the result map a compatible\n     // elements kind with the source object.\n-    TNode<FixedArrayBase> source_elements = LoadElements(source);\n+    TNode<FixedArrayBase> source_elements = LoadElements(CAST(source));\n \n     auto flags = ExtractFixedArrayFlag::kAllFixedArraysDontCopyCOW;\n     var_elements = CAST(CloneFixedArray(source_elements, flags));\n@@ -3633,22 +3632,45 @@ void AccessorAssembler::GenerateCloneObjectIC() {\n     // Lastly, clone any in-object properties.\n     // Determine the inobject property capacity of both objects, and copy the\n     // smaller number into the resulting object.\n-    Node* source_start = LoadMapInobjectPropertiesStartInWords(source_map);\n-    Node* source_size = LoadMapInstanceSizeInWords(source_map);\n-    Node* result_start = LoadMapInobjectPropertiesStartInWords(result_map);\n-    Node* field_offset_difference =\n+    TNode<IntPtrT> source_start =\n+        LoadMapInobjectPropertiesStartInWords(source_map);\n+    TNode<IntPtrT> source_size = LoadMapInstanceSizeInWords(source_map);\n+    TNode<IntPtrT> result_start =\n+        LoadMapInobjectPropertiesStartInWords(result_map);\n+    TNode<IntPtrT> field_offset_difference =\n         TimesPointerSize(IntPtrSub(result_start, source_start));\n-    BuildFastLoop(source_start, source_size,\n-                  [=](Node* field_index) {\n-                    Node* field_offset = TimesPointerSize(field_index);\n-                    TNode<Object> field = LoadObjectField(source, field_offset);\n-                    field = CloneIfMutablePrimitive(field);\n-                    Node* result_offset =\n-                        IntPtrAdd(field_offset, field_offset_difference);\n-                    StoreObjectFieldNoWriteBarrier(object, result_offset,\n-                                                   field);\n-                  },\n-                  1, INTPTR_PARAMETERS, IndexAdvanceMode::kPost);\n+\n+    // If MutableHeapNumbers may be present in-object, allocations may occur\n+    // within this loop, thus the write barrier is required.\n+    //\n+    // TODO(caitp): skip the write barrier until the first MutableHeapNumber\n+    // field is found\n+    const bool may_use_mutable_heap_numbers = !FLAG_unbox_double_fields;\n+\n+    BuildFastLoop(\n+        source_start, source_size,\n+        [=](Node* field_index) {\n+          TNode<IntPtrT> field_offset =\n+              TimesPointerSize(UncheckedCast<IntPtrT>(field_index));\n+\n+          if (may_use_mutable_heap_numbers) {\n+            TNode<Object> field = LoadObjectField(source, field_offset);\n+            field = CloneIfMutablePrimitive(field);\n+            TNode<IntPtrT> result_offset =\n+                IntPtrAdd(field_offset, field_offset_difference);\n+            StoreObjectField(object, result_offset, field);\n+          } else {\n+            // Copy fields as raw data.\n+            TNode<IntPtrT> field = UncheckedCast<IntPtrT>(\n+                LoadObjectField(source, field_offset, MachineType::IntPtr()));\n+            TNode<IntPtrT> result_offset =\n+                IntPtrAdd(field_offset, field_offset_difference);\n+            StoreObjectFieldNoWriteBarrier(\n+                object, result_offset, field,\n+                MachineType::IntPtr().representation());\n+          }\n+        },\n+        1, INTPTR_PARAMETERS, IndexAdvanceMode::kPost);\n     Return(object);\n   }\n "
        },
        {
            "sha": "e2035b242f25b4bf418674e59d99b1bf9f2e04e1",
            "filename": "deps/v8/test/mjsunit/es9/regress/regress-902965.js",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Ftest%2Fmjsunit%2Fes9%2Fregress%2Fregress-902965.js",
            "raw_url": "https://github.com/nodejs/node/raw/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Ftest%2Fmjsunit%2Fes9%2Fregress%2Fregress-902965.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fmjsunit%2Fes9%2Fregress%2Fregress-902965.js?ref=4884ca6428c0069468beea0826d228e167ad9cea",
            "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2018 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+// Previously, spreading in-object properties would always treat double fields\n+// as tagged, potentially dereferencing a Float64.\n+function inobjectDouble() {\n+  \"use strict\";\n+  this.x = -3.9;\n+}\n+const instance = new inobjectDouble();\n+const clone = { ...instance, };"
        },
        {
            "sha": "cca02ee0c41de2f6cf903d644e9cb4213c04effe",
            "filename": "deps/v8/test/mjsunit/es9/regress/regress-903070.js",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Ftest%2Fmjsunit%2Fes9%2Fregress%2Fregress-903070.js",
            "raw_url": "https://github.com/nodejs/node/raw/4884ca6428c0069468beea0826d228e167ad9cea/deps%2Fv8%2Ftest%2Fmjsunit%2Fes9%2Fregress%2Fregress-903070.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fmjsunit%2Fes9%2Fregress%2Fregress-903070.js?ref=4884ca6428c0069468beea0826d228e167ad9cea",
            "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 the V8 project authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+function clone(src) {\n+  return { ...src };\n+}\n+\n+function inobjectDoubles() {\n+  \"use strict\";\n+  this.p0 = -6400510997704731;\n+}\n+\n+// Check that unboxed double is not treated as tagged\n+assertEquals({ p0: -6400510997704731 }, clone(new inobjectDoubles()));"
        }
    ],
    "stats": {
        "total": 99,
        "additions": 77,
        "deletions": 22
    }
}