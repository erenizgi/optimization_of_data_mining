{
    "author": "refack",
    "message": "src: add AliasedBuffer::reserve\n\nrefactor grow_async_ids_stack\n\nPR-URL: https://github.com/nodejs/node/pull/23808\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Matheus Marchini <mat@mmarchini.me>",
    "sha": "4044b06c08314d3197fc2d8bd6177e7e870236e2",
    "files": [
        {
            "sha": "cdfd90765fcd86353140c90dfed6bb918ea37df0",
            "filename": "src/aliased_buffer.h",
            "status": "modified",
            "additions": 43,
            "deletions": 5,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/4044b06c08314d3197fc2d8bd6177e7e870236e2/src%2Faliased_buffer.h",
            "raw_url": "https://github.com/nodejs/node/raw/4044b06c08314d3197fc2d8bd6177e7e870236e2/src%2Faliased_buffer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Faliased_buffer.h?ref=4044b06c08314d3197fc2d8bd6177e7e870236e2",
            "patch": "@@ -4,7 +4,7 @@\n #if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n \n #include \"v8.h\"\n-#include \"util-inl.h\"\n+#include \"util.h\"\n \n namespace node {\n \n@@ -22,7 +22,9 @@ namespace node {\n  * The encapsulation herein provides a placeholder where such writes can be\n  * observed. Any notification APIs will be left as a future exercise.\n  */\n-template <class NativeT, class V8T>\n+template <class NativeT, class V8T,\n+          // SFINAE NativeT to be scalar\n+          typename = std::enable_if_t<std::is_scalar<NativeT>::value>>\n class AliasedBuffer {\n  public:\n   AliasedBuffer(v8::Isolate* isolate, const size_t count)\n@@ -33,14 +35,14 @@ class AliasedBuffer {\n     CHECK_GT(count, 0);\n     const v8::HandleScope handle_scope(isolate_);\n \n-    const size_t sizeInBytes = sizeof(NativeT) * count;\n+    const size_t size_in_bytes = sizeof(NativeT) * count;\n \n     // allocate native buffer\n     buffer_ = Calloc<NativeT>(count);\n \n     // allocate v8 ArrayBuffer\n     v8::Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(\n-        isolate_, buffer_, sizeInBytes);\n+        isolate_, buffer_, size_in_bytes);\n \n     // allocate v8 TypedArray\n     v8::Local<V8T> js_array = V8T::New(ab, byte_offset_, count);\n@@ -55,6 +57,7 @@ class AliasedBuffer {\n    *\n    *  Note that byte_offset must by aligned by sizeof(NativeT).\n    */\n+  // TODO(refack): refactor into a non-owning `AliasedBufferView`\n   AliasedBuffer(v8::Isolate* isolate,\n                 const size_t byte_offset,\n                 const size_t count,\n@@ -96,7 +99,7 @@ class AliasedBuffer {\n     js_array_.Reset();\n   }\n \n-  AliasedBuffer& operator=(AliasedBuffer&& that) {\n+  AliasedBuffer& operator=(AliasedBuffer&& that) noexcept {\n     this->~AliasedBuffer();\n     isolate_ = that.isolate_;\n     count_ = that.count_;\n@@ -226,6 +229,41 @@ class AliasedBuffer {\n     return count_;\n   }\n \n+  // Should only be used to extend the array.\n+  // Should only be used on an owning array, not one created as a sub array of\n+  // an owning `AliasedBuffer`.\n+  void reserve(size_t new_capacity) {\n+#if defined(DEBUG) && DEBUG\n+    CHECK_GE(new_capacity, count_);\n+    CHECK_EQ(byte_offset_, 0);\n+    CHECK(free_buffer_);\n+#endif\n+    const v8::HandleScope handle_scope(isolate_);\n+\n+    const size_t old_size_in_bytes = sizeof(NativeT) * count_;\n+    const size_t new_size_in_bytes = sizeof(NativeT) * new_capacity;\n+\n+    // allocate new native buffer\n+    NativeT* new_buffer = Calloc<NativeT>(new_capacity);\n+    // copy old content\n+    memcpy(new_buffer, buffer_, old_size_in_bytes);\n+\n+    // allocate v8 new ArrayBuffer\n+    v8::Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(\n+        isolate_, new_buffer, new_size_in_bytes);\n+\n+    // allocate v8 TypedArray\n+    v8::Local<V8T> js_array = V8T::New(ab, byte_offset_, new_capacity);\n+\n+    // move over old v8 TypedArray\n+    js_array_ = std::move(v8::Global<V8T>(isolate_, js_array));\n+\n+    // Free old buffer and set new values\n+    free(buffer_);\n+    buffer_ = new_buffer;\n+    count_ = new_capacity;\n+  }\n+\n  private:\n   v8::Isolate* isolate_;\n   size_t count_;"
        },
        {
            "sha": "9983da1e0dd53cfcc889820dd84503f4aae48fa6",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 8,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/4044b06c08314d3197fc2d8bd6177e7e870236e2/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4044b06c08314d3197fc2d8bd6177e7e870236e2/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=4044b06c08314d3197fc2d8bd6177e7e870236e2",
            "patch": "@@ -826,14 +826,7 @@ void Environment::CollectUVExceptionInfo(v8::Local<v8::Value> object,\n \n \n void Environment::AsyncHooks::grow_async_ids_stack() {\n-  const uint32_t old_capacity = async_ids_stack_.Length() / 2;\n-  const uint32_t new_capacity = old_capacity * 1.5;\n-  AliasedBuffer<double, v8::Float64Array> new_buffer(\n-      env()->isolate(), new_capacity * 2);\n-\n-  for (uint32_t i = 0; i < old_capacity * 2; ++i)\n-    new_buffer[i] = async_ids_stack_[i];\n-  async_ids_stack_ = std::move(new_buffer);\n+  async_ids_stack_.reserve(async_ids_stack_.Length() * 3);\n \n   env()->async_hooks_binding()->Set(\n       env()->context(),"
        }
    ],
    "stats": {
        "total": 57,
        "additions": 44,
        "deletions": 13
    }
}