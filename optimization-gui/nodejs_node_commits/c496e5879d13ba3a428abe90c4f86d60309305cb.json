{
    "author": "addaleax",
    "message": "src: refactor zlib dictionary to STL vector\n\nPR-URL: https://github.com/nodejs/node/pull/23019\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "c496e5879d13ba3a428abe90c4f86d60309305cb",
    "files": [
        {
            "sha": "8b04ba4e9eea968a293be21db4b94919ee2792ae",
            "filename": "src/node_zlib.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 35,
            "changes": 63,
            "blob_url": "https://github.com/nodejs/node/blob/c496e5879d13ba3a428abe90c4f86d60309305cb/src%2Fnode_zlib.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c496e5879d13ba3a428abe90c4f86d60309305cb/src%2Fnode_zlib.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_zlib.cc?ref=c496e5879d13ba3a428abe90c4f86d60309305cb",
            "patch": "@@ -78,8 +78,6 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   ZCtx(Environment* env, Local<Object> wrap, node_zlib_mode mode)\n       : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_ZLIB),\n         ThreadPoolWork(env),\n-        dictionary_(nullptr),\n-        dictionary_len_(0),\n         err_(0),\n         flush_(0),\n         init_done_(false),\n@@ -126,10 +124,7 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     CHECK(status == Z_OK || status == Z_DATA_ERROR);\n     mode_ = NONE;\n \n-    if (dictionary_ != nullptr) {\n-      delete[] dictionary_;\n-      dictionary_ = nullptr;\n-    }\n+    dictionary_.clear();\n   }\n \n \n@@ -294,9 +289,11 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n         // SetDictionary, don't repeat that here)\n         if (mode_ != INFLATERAW &&\n             err_ == Z_NEED_DICT &&\n-            dictionary_ != nullptr) {\n+            !dictionary_.empty()) {\n           // Load it\n-          err_ = inflateSetDictionary(&strm_, dictionary_, dictionary_len_);\n+          err_ = inflateSetDictionary(&strm_,\n+                                      dictionary_.data(),\n+                                      dictionary_.size());\n           if (err_ == Z_OK) {\n             // And try to decode again\n             err_ = inflate(&strm_, flush_);\n@@ -346,7 +343,7 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n       // normal statuses, not fatal\n       break;\n     case Z_NEED_DICT:\n-      if (dictionary_ == nullptr)\n+      if (dictionary_.empty())\n         Error(\"Missing dictionary\");\n       else\n         Error(\"Bad dictionary\");\n@@ -483,23 +480,20 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n \n     Local<Function> write_js_callback = args[5].As<Function>();\n \n-    char* dictionary = nullptr;\n-    size_t dictionary_len = 0;\n+    std::vector<unsigned char> dictionary;\n     if (Buffer::HasInstance(args[6])) {\n-      const char* dictionary_ = Buffer::Data(args[6]);\n-      dictionary_len = Buffer::Length(args[6]);\n-\n-      dictionary = new char[dictionary_len];\n-      memcpy(dictionary, dictionary_, dictionary_len);\n+      unsigned char* data =\n+          reinterpret_cast<unsigned char*>(Buffer::Data(args[6]));\n+      dictionary = std::vector<unsigned char>(\n+          data,\n+          data + Buffer::Length(args[6]));\n     }\n \n     bool ret = Init(ctx, level, windowBits, memLevel, strategy, write_result,\n-                    write_js_callback, dictionary, dictionary_len);\n-    if (!ret) goto end;\n+                    write_js_callback, std::move(dictionary));\n+    if (ret)\n+      ctx->SetDictionary();\n \n-    ctx->SetDictionary();\n-\n-   end:\n     return args.GetReturnValue().Set(ret);\n   }\n \n@@ -524,8 +518,8 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n \n   static bool Init(ZCtx* ctx, int level, int windowBits, int memLevel,\n                    int strategy, uint32_t* write_result,\n-                   Local<Function> write_js_callback, char* dictionary,\n-                   size_t dictionary_len) {\n+                   Local<Function> write_js_callback,\n+                   std::vector<unsigned char>&& dictionary) {\n     AllocScope alloc_scope(ctx);\n     ctx->level_ = level;\n     ctx->windowBits_ = windowBits;\n@@ -573,17 +567,13 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n         UNREACHABLE();\n     }\n \n-    ctx->dictionary_ = reinterpret_cast<Bytef *>(dictionary);\n-    ctx->dictionary_len_ = dictionary_len;\n+    ctx->dictionary_ = std::move(dictionary);\n \n     ctx->write_in_progress_ = false;\n     ctx->init_done_ = true;\n \n     if (ctx->err_ != Z_OK) {\n-      if (dictionary != nullptr) {\n-        delete[] dictionary;\n-        ctx->dictionary_ = nullptr;\n-      }\n+      ctx->dictionary_.clear();\n       ctx->mode_ = NONE;\n       return false;\n     }\n@@ -594,20 +584,24 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   }\n \n   void SetDictionary() {\n-    if (dictionary_ == nullptr)\n+    if (dictionary_.empty())\n       return;\n \n     err_ = Z_OK;\n \n     switch (mode_) {\n       case DEFLATE:\n       case DEFLATERAW:\n-        err_ = deflateSetDictionary(&strm_, dictionary_, dictionary_len_);\n+        err_ = deflateSetDictionary(&strm_,\n+                                    dictionary_.data(),\n+                                    dictionary_.size());\n         break;\n       case INFLATERAW:\n         // The other inflate cases will have the dictionary set when inflate()\n         // returns Z_NEED_DICT in Process()\n-        err_ = inflateSetDictionary(&strm_, dictionary_, dictionary_len_);\n+        err_ = inflateSetDictionary(&strm_,\n+                                    dictionary_.data(),\n+                                    dictionary_.size());\n         break;\n       default:\n         break;\n@@ -664,7 +658,7 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n \n   void MemoryInfo(MemoryTracker* tracker) const override {\n     tracker->TrackThis(this);\n-    tracker->TrackFieldWithSize(\"dictionary\", dictionary_len_);\n+    tracker->TrackField(\"dictionary\", dictionary_);\n     tracker->TrackFieldWithSize(\"zlib memory\",\n         zlib_memory_ + unreported_allocations_);\n   }\n@@ -732,8 +726,7 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     ZCtx* ctx;\n   };\n \n-  Bytef* dictionary_;\n-  size_t dictionary_len_;\n+  std::vector<unsigned char> dictionary_;\n   int err_;\n   int flush_;\n   bool init_done_;"
        }
    ],
    "stats": {
        "total": 63,
        "additions": 28,
        "deletions": 35
    }
}