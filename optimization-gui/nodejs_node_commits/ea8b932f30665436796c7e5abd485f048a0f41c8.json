{
    "author": "BridgeAR",
    "message": "util: restore all information in inspect\n\nThe former implementation lacked symbols on the iterator objects\nwithout prototype. This is now fixed.\nThe special handling for overriding `Symbol.iterator` was removed as\nit's very difficult to deal with this properly. Manipulating the\nsymbols is just not supported.\n\nPR-URL: https://github.com/nodejs/node/pull/22437\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "ea8b932f30665436796c7e5abd485f048a0f41c8",
    "files": [
        {
            "sha": "e8fb41a2198a9980d3d3686fdce43d59f8825c3b",
            "filename": "lib/util.js",
            "status": "modified",
            "additions": 42,
            "deletions": 41,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/ea8b932f30665436796c7e5abd485f048a0f41c8/lib%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/ea8b932f30665436796c7e5abd485f048a0f41c8/lib%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Futil.js?ref=ea8b932f30665436796c7e5abd485f048a0f41c8",
            "patch": "@@ -513,13 +513,6 @@ function getPrefix(constructor, tag, fallback) {\n   return '';\n }\n \n-function addExtraKeys(source, target, keys) {\n-  for (const key of keys) {\n-    target[key] = source[key];\n-  }\n-  return target;\n-}\n-\n function findTypedConstructor(value) {\n   for (const [check, clazz] of [\n     [isUint8Array, Uint8Array],\n@@ -535,14 +528,36 @@ function findTypedConstructor(value) {\n     [isBigUint64Array, BigUint64Array]\n   ]) {\n     if (check(value)) {\n-      return new clazz(value);\n+      return clazz;\n     }\n   }\n-  return value;\n }\n \n const getBoxedValue = formatPrimitive.bind(null, stylizeNoColor);\n \n+function noPrototypeIterator(ctx, value, recurseTimes) {\n+  let newVal;\n+  // TODO: Create a Subclass in case there's no prototype and show\n+  // `null-prototype`.\n+  if (isSet(value)) {\n+    const clazz = Object.getPrototypeOf(value) || Set;\n+    newVal = new clazz(setValues(value));\n+  } else if (isMap(value)) {\n+    const clazz = Object.getPrototypeOf(value) || Map;\n+    newVal = new clazz(mapEntries(value));\n+  } else if (Array.isArray(value)) {\n+    const clazz = Object.getPrototypeOf(value) || Array;\n+    newVal = new clazz(value.length || 0);\n+  } else if (isTypedArray(value)) {\n+    const clazz = findTypedConstructor(value) || Uint8Array;\n+    newVal = new clazz(value);\n+  }\n+  if (newVal) {\n+    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));\n+    return formatValue(ctx, newVal, recurseTimes);\n+  }\n+}\n+\n // Note: using `formatValue` directly requires the indentation level to be\n // corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n // value afterwards again.\n@@ -798,39 +813,25 @@ function formatValue(ctx, value, recurseTimes) {\n       braces = ['{', '}'];\n     // The input prototype got manipulated. Special handle these.\n     // We have to rebuild the information so we are able to display everything.\n-    } else if (isSet(value)) {\n-      const newVal = addExtraKeys(value, new Set(setValues(value)), keys);\n-      return formatValue(ctx, newVal, recurseTimes);\n-    } else if (isMap(value)) {\n-      const newVal = addExtraKeys(value, new Map(mapEntries(value)), keys);\n-      return formatValue(ctx, newVal, recurseTimes);\n-    } else if (Array.isArray(value)) {\n-      // The prefix is not always possible to fully reconstruct.\n-      const prefix = getPrefix(constructor, tag);\n-      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];\n-      formatter = formatArray;\n-      const newValue = [];\n-      newValue.length = value.length;\n-      value = addExtraKeys(value, newValue, keys);\n-    } else if (isTypedArray(value)) {\n-      const newValue = findTypedConstructor(value);\n-      value = addExtraKeys(value, newValue, keys.slice(newValue.length));\n-      // The prefix is not always possible to fully reconstruct.\n-      braces = [`${getPrefix(getConstructorName(value), tag)}[`, ']'];\n-      formatter = formatTypedArray;\n-    } else if (isMapIterator(value)) {\n-      braces = [`[${tag || 'Map Iterator'}] {`, '}'];\n-      formatter = formatMapIterator;\n-    } else if (isSetIterator(value)) {\n-      braces = [`[${tag || 'Set Iterator'}] {`, '}'];\n-      formatter = formatSetIterator;\n-    // Handle other regular objects again.\n-    } else if (keyLength === 0) {\n-      if (isExternal(value))\n-        return ctx.stylize('[External]', 'special');\n-      return `${getPrefix(constructor, tag)}{}`;\n     } else {\n-      braces[0] = `${getPrefix(constructor, tag)}{`;\n+      const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);\n+      if (specialIterator) {\n+        return specialIterator;\n+      }\n+      if (isMapIterator(value)) {\n+        braces = [`[${tag || 'Map Iterator'}] {`, '}'];\n+        formatter = formatMapIterator;\n+      } else if (isSetIterator(value)) {\n+        braces = [`[${tag || 'Set Iterator'}] {`, '}'];\n+        formatter = formatSetIterator;\n+      // Handle other regular objects again.\n+      } else if (keyLength === 0) {\n+        if (isExternal(value))\n+          return ctx.stylize('[External]', 'special');\n+        return `${getPrefix(constructor, tag)}{}`;\n+      } else {\n+        braces[0] = `${getPrefix(constructor, tag)}{`;\n+      }\n     }\n   }\n "
        },
        {
            "sha": "8e78430c01204dab47879f3017be6a502e695425",
            "filename": "test/parallel/test-util-inspect.js",
            "status": "modified",
            "additions": 3,
            "deletions": 18,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/ea8b932f30665436796c7e5abd485f048a0f41c8/test%2Fparallel%2Ftest-util-inspect.js",
            "raw_url": "https://github.com/nodejs/node/raw/ea8b932f30665436796c7e5abd485f048a0f41c8/test%2Fparallel%2Ftest-util-inspect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-util-inspect.js?ref=ea8b932f30665436796c7e5abd485f048a0f41c8",
            "patch": "@@ -1557,24 +1557,6 @@ assert.strictEqual(util.inspect('\"\\''), '`\"\\'`');\n // eslint-disable-next-line no-template-curly-in-string\n assert.strictEqual(util.inspect('\"\\'${a}'), \"'\\\"\\\\'${a}'\");\n \n-// Manipulating the Symbol.iterator should still produce nice results.\n-[\n-  [[1, 2], '[ 1, 2 ]'],\n-  [[, , 5, , , , ], '[ <2 empty items>, 5, <3 empty items> ]'],\n-  [new Set([1, 2]), 'Set { 1, 2 }'],\n-  [new Map([[1, 2]]), 'Map { 1 => 2 }'],\n-  [new Uint8Array(2), 'Uint8Array [ 0, 0 ]'],\n-  // It seems like the following can not be fully restored :(\n-  [new Set([1, 2]).entries(), 'Object [Set Iterator] {}'],\n-  [new Map([[1, 2]]).keys(), 'Object [Map Iterator] {}'],\n-].forEach(([value, expected]) => {\n-  // \"Remove the Symbol.iterator\"\n-  Object.defineProperty(value, Symbol.iterator, {\n-    value: false\n-  });\n-  assert.strictEqual(util.inspect(value), expected);\n-});\n-\n // Verify the output in case the value has no prototype.\n // Sadly, these cases can not be fully inspected :(\n [\n@@ -1630,6 +1612,9 @@ assert.strictEqual(util.inspect('\"\\'${a}'), \"'\\\"\\\\'${a}'\");\n   );\n   value.foo = 'bar';\n   assert.notStrictEqual(util.inspect(value), expected);\n+  delete value.foo;\n+  value[Symbol('foo')] = 'yeah';\n+  assert.notStrictEqual(util.inspect(value), expected);\n });\n \n assert.strictEqual(inspect(1n), '1n');"
        }
    ],
    "stats": {
        "total": 104,
        "additions": 45,
        "deletions": 59
    }
}