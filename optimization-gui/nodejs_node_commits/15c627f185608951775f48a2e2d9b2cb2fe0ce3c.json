{
    "author": "addaleax",
    "message": "http2: track memory allocated by nghttp2\n\nProvide a custom memory allocator for nghttp2, and track\nmemory allocated by the library with it.\n\nThis makes the used-memory-per-session estimate more\naccurate, and allows us to track memory leaks either\nin nghttp2 itself or, more likely, through faulty\nusage on our end.\n\nIt also allows us to make the per-session memory limit\nmore accurate in the future; currently, we are not\nhandling this in an ideal way, and instead let nghttp2\nallocate what it wants, even if that goes over our limit.\n\nPR-URL: https://github.com/nodejs/node/pull/21374\nRefs: https://github.com/nodejs/node/pull/21373\nRefs: https://github.com/nodejs/node/pull/21336\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>",
    "sha": "15c627f185608951775f48a2e2d9b2cb2fe0ce3c",
    "files": [
        {
            "sha": "c1ab584134b20a3b97bb27daebf77f6ca755ef28",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 94,
            "deletions": 5,
            "changes": 99,
            "blob_url": "https://github.com/nodejs/node/blob/15c627f185608951775f48a2e2d9b2cb2fe0ce3c/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/15c627f185608951775f48a2e2d9b2cb2fe0ce3c/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=15c627f185608951775f48a2e2d9b2cb2fe0ce3c",
            "patch": "@@ -451,6 +451,92 @@ Http2Session::Callbacks::~Callbacks() {\n   nghttp2_session_callbacks_del(callbacks);\n }\n \n+// Track memory allocated by nghttp2 using a custom allocator.\n+class Http2Session::MemoryAllocatorInfo {\n+ public:\n+  explicit MemoryAllocatorInfo(Http2Session* session)\n+      : info({ session, H2Malloc, H2Free, H2Calloc, H2Realloc }) {}\n+\n+  static void* H2Malloc(size_t size, void* user_data) {\n+    return H2Realloc(nullptr, size, user_data);\n+  }\n+\n+  static void* H2Calloc(size_t nmemb, size_t size, void* user_data) {\n+    size_t real_size = MultiplyWithOverflowCheck(nmemb, size);\n+    void* mem = H2Malloc(real_size, user_data);\n+    if (mem != nullptr)\n+      memset(mem, 0, real_size);\n+    return mem;\n+  }\n+\n+  static void H2Free(void* ptr, void* user_data) {\n+    if (ptr == nullptr) return;  // free(null); happens quite often.\n+    void* result = H2Realloc(ptr, 0, user_data);\n+    CHECK_EQ(result, nullptr);\n+  }\n+\n+  static void* H2Realloc(void* ptr, size_t size, void* user_data) {\n+    Http2Session* session = static_cast<Http2Session*>(user_data);\n+    size_t previous_size = 0;\n+    char* original_ptr = nullptr;\n+\n+    // We prepend each allocated buffer with a size_t containing the full\n+    // size of the allocation.\n+    if (size > 0) size += sizeof(size_t);\n+\n+    if (ptr != nullptr) {\n+      // We are free()ing or re-allocating.\n+      original_ptr = static_cast<char*>(ptr) - sizeof(size_t);\n+      previous_size = *reinterpret_cast<size_t*>(original_ptr);\n+      // This means we called StopTracking() on this pointer before.\n+      if (previous_size == 0) {\n+        // Fall back to the standard Realloc() function.\n+        char* ret = UncheckedRealloc(original_ptr, size);\n+        if (ret != nullptr)\n+          ret += sizeof(size_t);\n+        return ret;\n+      }\n+    }\n+    CHECK_GE(session->current_nghttp2_memory_, previous_size);\n+\n+    // TODO(addaleax): Add the following, and handle NGHTTP2_ERR_NOMEM properly\n+    // everywhere:\n+    //\n+    // if (size > previous_size &&\n+    //     !session->IsAvailableSessionMemory(size - previous_size)) {\n+    //  return nullptr;\n+    //}\n+\n+    char* mem = UncheckedRealloc(original_ptr, size);\n+\n+    if (mem != nullptr) {\n+      // Adjust the memory info counter.\n+      session->current_nghttp2_memory_ += size - previous_size;\n+      *reinterpret_cast<size_t*>(mem) = size;\n+      mem += sizeof(size_t);\n+    } else if (size == 0) {\n+      session->current_nghttp2_memory_ -= previous_size;\n+    }\n+\n+    return mem;\n+  }\n+\n+  static void StopTracking(Http2Session* session, void* ptr) {\n+    size_t* original_ptr = reinterpret_cast<size_t*>(\n+        static_cast<char*>(ptr) - sizeof(size_t));\n+    session->current_nghttp2_memory_ -= *original_ptr;\n+    *original_ptr = 0;\n+  }\n+\n+  inline nghttp2_mem* operator*() { return &info; }\n+\n+  nghttp2_mem info;\n+};\n+\n+void Http2Session::StopTrackingRcbuf(nghttp2_rcbuf* buf) {\n+  MemoryAllocatorInfo::StopTracking(this, buf);\n+}\n+\n Http2Session::Http2Session(Environment* env,\n                            Local<Object> wrap,\n                            nghttp2_session_type type)\n@@ -482,15 +568,17 @@ Http2Session::Http2Session(Environment* env,\n       = callback_struct_saved[hasGetPaddingCallback ? 1 : 0].callbacks;\n \n   auto fn = type == NGHTTP2_SESSION_SERVER ?\n-      nghttp2_session_server_new2 :\n-      nghttp2_session_client_new2;\n+      nghttp2_session_server_new3 :\n+      nghttp2_session_client_new3;\n+\n+  MemoryAllocatorInfo allocator_info(this);\n \n   // This should fail only if the system is out of memory, which\n   // is going to cause lots of other problems anyway, or if any\n   // of the options are out of acceptable range, which we should\n   // be catching before it gets this far. Either way, crash if this\n   // fails.\n-  CHECK_EQ(fn(&session_, callbacks, this, *opts), 0);\n+  CHECK_EQ(fn(&session_, callbacks, this, *opts, *allocator_info), 0);\n \n   outgoing_storage_.reserve(4096);\n   outgoing_buffers_.reserve(32);\n@@ -502,6 +590,7 @@ Http2Session::~Http2Session() {\n   for (const auto& iter : streams_)\n     iter.second->session_ = nullptr;\n   nghttp2_session_del(session_);\n+  CHECK_EQ(current_nghttp2_memory_, 0);\n }\n \n std::string Http2Session::diagnostic_name() const {\n@@ -1150,9 +1239,9 @@ void Http2Session::HandleHeadersFrame(const nghttp2_frame* frame) {\n       nghttp2_header item = headers[n++];\n       // The header name and value are passed as external one-byte strings\n       name_str =\n-          ExternalHeader::New<true>(env(), item.name).ToLocalChecked();\n+          ExternalHeader::New<true>(this, item.name).ToLocalChecked();\n       value_str =\n-          ExternalHeader::New<false>(env(), item.value).ToLocalChecked();\n+          ExternalHeader::New<false>(this, item.value).ToLocalChecked();\n       argv[j * 2] = name_str;\n       argv[j * 2 + 1] = value_str;\n       j++;"
        },
        {
            "sha": "d90c3aed66b0a0d44a6964550c84b61e9279b617",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 13,
            "deletions": 6,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/15c627f185608951775f48a2e2d9b2cb2fe0ce3c/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/15c627f185608951775f48a2e2d9b2cb2fe0ce3c/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=15c627f185608951775f48a2e2d9b2cb2fe0ce3c",
            "patch": "@@ -721,6 +721,7 @@ class Http2Session : public AsyncWrap, public StreamListener {\n \n   class Http2Ping;\n   class Http2Settings;\n+  class MemoryAllocatorInfo;\n \n   void EmitStatistics();\n \n@@ -849,13 +850,15 @@ class Http2Session : public AsyncWrap, public StreamListener {\n     current_session_memory_ -= amount;\n   }\n \n-  // Returns the current session memory including the current size of both\n-  // the inflate and deflate hpack headers, the current outbound storage\n-  // queue, and pending writes.\n+  // Tell our custom memory allocator that this rcbuf is independent of\n+  // this session now, and may outlive it.\n+  void StopTrackingRcbuf(nghttp2_rcbuf* buf);\n+\n+  // Returns the current session memory including memory allocated by nghttp2,\n+  // the current outbound storage queue, and pending writes.\n   uint64_t GetCurrentSessionMemory() {\n     uint64_t total = current_session_memory_ + sizeof(Http2Session);\n-    total += nghttp2_session_get_hd_deflate_dynamic_table_size(session_);\n-    total += nghttp2_session_get_hd_inflate_dynamic_table_size(session_);\n+    total += current_nghttp2_memory_;\n     total += outgoing_storage_.size();\n     return total;\n   }\n@@ -987,6 +990,8 @@ class Http2Session : public AsyncWrap, public StreamListener {\n   // The maximum amount of memory allocated for this session\n   uint64_t max_session_memory_ = DEFAULT_MAX_SESSION_MEMORY;\n   uint64_t current_session_memory_ = 0;\n+  // The amount of memory allocated by nghttp2 internals\n+  uint64_t current_nghttp2_memory_ = 0;\n \n   // The collection of active Http2Streams associated with this session\n   std::unordered_map<int32_t, Http2Stream*> streams_;\n@@ -1178,7 +1183,8 @@ class ExternalHeader :\n   }\n \n   template <bool may_internalize>\n-  static MaybeLocal<String> New(Environment* env, nghttp2_rcbuf* buf) {\n+  static MaybeLocal<String> New(Http2Session* session, nghttp2_rcbuf* buf) {\n+    Environment* env = session->env();\n     if (nghttp2_rcbuf_is_static(buf)) {\n       auto& static_str_map = env->isolate_data()->http2_static_strs;\n       v8::Eternal<v8::String>& eternal = static_str_map[buf];\n@@ -1205,6 +1211,7 @@ class ExternalHeader :\n       return GetInternalizedString(env, vec);\n     }\n \n+    session->StopTrackingRcbuf(buf);\n     ExternalHeader* h_str = new ExternalHeader(buf);\n     MaybeLocal<String> str = String::NewExternalOneByte(env->isolate(), h_str);\n     if (str.IsEmpty())"
        },
        {
            "sha": "c6cd263aa2714a7cc37a0da97d0d748379a85c99",
            "filename": "src/util-inl.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/15c627f185608951775f48a2e2d9b2cb2fe0ce3c/src%2Futil-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/15c627f185608951775f48a2e2d9b2cb2fe0ce3c/src%2Futil-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil-inl.h?ref=15c627f185608951775f48a2e2d9b2cb2fe0ce3c",
            "patch": "@@ -320,8 +320,9 @@ bool StringEqualNoCaseN(const char* a, const char* b, size_t length) {\n   return true;\n }\n \n-inline size_t MultiplyWithOverflowCheck(size_t a, size_t b) {\n-  size_t ret = a * b;\n+template <typename T>\n+inline T MultiplyWithOverflowCheck(T a, T b) {\n+  auto ret = a * b;\n   if (a != 0)\n     CHECK_EQ(b, ret / a);\n "
        },
        {
            "sha": "f7dcc5ea35abf8a5f19e53b72bf09d13889e7924",
            "filename": "src/util.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/15c627f185608951775f48a2e2d9b2cb2fe0ce3c/src%2Futil.h",
            "raw_url": "https://github.com/nodejs/node/raw/15c627f185608951775f48a2e2d9b2cb2fe0ce3c/src%2Futil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.h?ref=15c627f185608951775f48a2e2d9b2cb2fe0ce3c",
            "patch": "@@ -67,6 +67,9 @@ inline char* Calloc(size_t n);\n inline char* UncheckedMalloc(size_t n);\n inline char* UncheckedCalloc(size_t n);\n \n+template <typename T>\n+inline T MultiplyWithOverflowCheck(T a, T b);\n+\n // Used by the allocation functions when allocation fails.\n // Thin wrapper around v8::Isolate::LowMemoryNotification() that checks\n // whether V8 is initialized."
        }
    ],
    "stats": {
        "total": 126,
        "additions": 113,
        "deletions": 13
    }
}