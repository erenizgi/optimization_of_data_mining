{
    "author": "addaleax",
    "message": "zlib: refactor zlib internals\n\nSplit out things that are specific to zlib as a specific\ncompression library, vs. the interface that is common to\nmost C compression libraries.\n\nThis should pave the way for including support for e.g.\nbrotli.\n\nPR-URL: https://github.com/nodejs/node/pull/23360\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "c34eae5f882c8bb4d58b492caf97cdb08b1dbbcb",
    "files": [
        {
            "sha": "8b257cf0d47934595e09c4891dfeac2c2cf3b608",
            "filename": "src/node_zlib.cc",
            "status": "modified",
            "additions": 518,
            "deletions": 410,
            "changes": 928,
            "blob_url": "https://github.com/nodejs/node/blob/c34eae5f882c8bb4d58b492caf97cdb08b1dbbcb/src%2Fnode_zlib.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c34eae5f882c8bb4d58b492caf97cdb08b1dbbcb/src%2Fnode_zlib.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_zlib.cc?ref=c34eae5f882c8bb4d58b492caf97cdb08b1dbbcb",
            "patch": "@@ -88,32 +88,75 @@ enum node_zlib_mode {\n #define GZIP_HEADER_ID1 0x1f\n #define GZIP_HEADER_ID2 0x8b\n \n-/**\n- * Deflate/Inflate\n- */\n-class ZCtx : public AsyncWrap, public ThreadPoolWork {\n+struct CompressionError {\n+  CompressionError(const char* message, const char* code, int err)\n+    : message(message), code(code), err(err) {}\n+  CompressionError() = default;\n+\n+  const char* message = nullptr;\n+  const char* code = nullptr;\n+  int err = 0;\n+\n+  inline bool IsError() const { return code != nullptr; }\n+};\n+\n+class ZlibContext : public MemoryRetainer {\n+ public:\n+  ZlibContext() = default;\n+\n+  // Streaming-related, should be available for all compression libraries:\n+  void Close();\n+  void DoThreadPoolWork();\n+  void SetBuffers(char* in, uint32_t in_len, char* out, uint32_t out_len);\n+  void SetFlush(int flush);\n+  void GetAfterWriteOffsets(uint32_t* avail_in, uint32_t* avail_out) const;\n+  CompressionError GetErrorInfo() const;\n+\n+  // Zlib-specific:\n+  CompressionError Init(int level, int window_bits, int mem_level, int strategy,\n+                        std::vector<unsigned char>&& dictionary);\n+  inline void SetMode(node_zlib_mode mode) { mode_ = mode; }\n+  void SetAllocationFunctions(alloc_func alloc, free_func free, void* opaque);\n+  CompressionError ResetStream();\n+  CompressionError SetParams(int level, int strategy);\n+\n+  SET_MEMORY_INFO_NAME(ZlibContext)\n+  SET_SELF_SIZE(ZlibContext)\n+\n+  void MemoryInfo(MemoryTracker* tracker) const override {\n+    tracker->TrackField(\"dictionary\", dictionary_);\n+  }\n+\n+ private:\n+  CompressionError ErrorForMessage(const char* message) const;\n+  CompressionError SetDictionary();\n+\n+  int err_ = 0;\n+  int flush_ = 0;\n+  int level_ = 0;\n+  int mem_level_ = 0;\n+  node_zlib_mode mode_ = NONE;\n+  int strategy_ = 0;\n+  int window_bits_ = 0;\n+  unsigned int gzip_id_bytes_read_ = 0;\n+  std::vector<unsigned char> dictionary_;\n+\n+  z_stream strm_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(ZlibContext);\n+};\n+\n+template <typename CompressionContext>\n+class CompressionStream : public AsyncWrap, public ThreadPoolWork {\n  public:\n-  ZCtx(Environment* env, Local<Object> wrap, node_zlib_mode mode)\n+  CompressionStream(Environment* env, Local<Object> wrap)\n       : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_ZLIB),\n         ThreadPoolWork(env),\n-        err_(0),\n-        flush_(0),\n-        init_done_(false),\n-        level_(0),\n-        memLevel_(0),\n-        mode_(mode),\n-        strategy_(0),\n-        windowBits_(0),\n-        write_in_progress_(false),\n-        pending_close_(false),\n-        refs_(0),\n-        gzip_id_bytes_read_(0),\n         write_result_(nullptr) {\n     MakeWeak();\n   }\n \n-\n-  ~ZCtx() override {\n+  ~CompressionStream() override {\n     CHECK_EQ(false, write_in_progress_ && \"write in progress\");\n     Close();\n     CHECK_EQ(zlib_memory_, 0);\n@@ -127,27 +170,16 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     }\n \n     pending_close_ = false;\n+    closed_ = true;\n     CHECK(init_done_ && \"close before init\");\n-    CHECK_LE(mode_, UNZIP);\n \n     AllocScope alloc_scope(this);\n-    int status = Z_OK;\n-    if (mode_ == DEFLATE || mode_ == GZIP || mode_ == DEFLATERAW) {\n-      status = deflateEnd(&strm_);\n-    } else if (mode_ == INFLATE || mode_ == GUNZIP || mode_ == INFLATERAW ||\n-               mode_ == UNZIP) {\n-      status = inflateEnd(&strm_);\n-    }\n-\n-    CHECK(status == Z_OK || status == Z_DATA_ERROR);\n-    mode_ = NONE;\n-\n-    dictionary_.clear();\n+    ctx_.Close();\n   }\n \n \n   static void Close(const FunctionCallbackInfo<Value>& args) {\n-    ZCtx* ctx;\n+    CompressionStream* ctx;\n     ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n     ctx->Close();\n   }\n@@ -198,7 +230,7 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     CHECK(Buffer::IsWithinBounds(out_off, out_len, Buffer::Length(out_buf)));\n     out = Buffer::Data(out_buf) + out_off;\n \n-    ZCtx* ctx;\n+    CompressionStream* ctx;\n     ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n \n     ctx->Write<async>(flush, in, in_len, out, out_len);\n@@ -211,26 +243,22 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     AllocScope alloc_scope(this);\n \n     CHECK(init_done_ && \"write before init\");\n-    CHECK(mode_ != NONE && \"already finalized\");\n+    CHECK(!closed_ && \"already finalized\");\n \n     CHECK_EQ(false, write_in_progress_);\n     CHECK_EQ(false, pending_close_);\n     write_in_progress_ = true;\n     Ref();\n \n-    strm_.avail_in = in_len;\n-    strm_.next_in = reinterpret_cast<Bytef*>(in);\n-    strm_.avail_out = out_len;\n-    strm_.next_out = reinterpret_cast<Bytef*>(out);\n-    flush_ = flush;\n+    ctx_.SetBuffers(in, in_len, out, out_len);\n+    ctx_.SetFlush(flush);\n \n     if (!async) {\n       // sync version\n       env()->PrintSyncTrace();\n       DoThreadPoolWork();\n       if (CheckError()) {\n-        write_result_[0] = strm_.avail_out;\n-        write_result_[1] = strm_.avail_in;\n+        UpdateWriteResult();\n         write_in_progress_ = false;\n       }\n       Unref();\n@@ -241,142 +269,24 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     ScheduleWork();\n   }\n \n+  void UpdateWriteResult() {\n+    ctx_.GetAfterWriteOffsets(&write_result_[1], &write_result_[0]);\n+  }\n+\n   // thread pool!\n   // This function may be called multiple times on the uv_work pool\n   // for a single write() call, until all of the input bytes have\n   // been consumed.\n   void DoThreadPoolWork() override {\n-    const Bytef* next_expected_header_byte = nullptr;\n-\n-    // If the avail_out is left at 0, then it means that it ran out\n-    // of room.  If there was avail_out left over, then it means\n-    // that all of the input was consumed.\n-    switch (mode_) {\n-      case DEFLATE:\n-      case GZIP:\n-      case DEFLATERAW:\n-        err_ = deflate(&strm_, flush_);\n-        break;\n-      case UNZIP:\n-        if (strm_.avail_in > 0) {\n-          next_expected_header_byte = strm_.next_in;\n-        }\n-\n-        switch (gzip_id_bytes_read_) {\n-          case 0:\n-            if (next_expected_header_byte == nullptr) {\n-              break;\n-            }\n-\n-            if (*next_expected_header_byte == GZIP_HEADER_ID1) {\n-              gzip_id_bytes_read_ = 1;\n-              next_expected_header_byte++;\n-\n-              if (strm_.avail_in == 1) {\n-                // The only available byte was already read.\n-                break;\n-              }\n-            } else {\n-              mode_ = INFLATE;\n-              break;\n-            }\n-\n-            // fallthrough\n-          case 1:\n-            if (next_expected_header_byte == nullptr) {\n-              break;\n-            }\n-\n-            if (*next_expected_header_byte == GZIP_HEADER_ID2) {\n-              gzip_id_bytes_read_ = 2;\n-              mode_ = GUNZIP;\n-            } else {\n-              // There is no actual difference between INFLATE and INFLATERAW\n-              // (after initialization).\n-              mode_ = INFLATE;\n-            }\n-\n-            break;\n-          default:\n-            CHECK(0 && \"invalid number of gzip magic number bytes read\");\n-        }\n-\n-        // fallthrough\n-      case INFLATE:\n-      case GUNZIP:\n-      case INFLATERAW:\n-        err_ = inflate(&strm_, flush_);\n-\n-        // If data was encoded with dictionary (INFLATERAW will have it set in\n-        // SetDictionary, don't repeat that here)\n-        if (mode_ != INFLATERAW &&\n-            err_ == Z_NEED_DICT &&\n-            !dictionary_.empty()) {\n-          // Load it\n-          err_ = inflateSetDictionary(&strm_,\n-                                      dictionary_.data(),\n-                                      dictionary_.size());\n-          if (err_ == Z_OK) {\n-            // And try to decode again\n-            err_ = inflate(&strm_, flush_);\n-          } else if (err_ == Z_DATA_ERROR) {\n-            // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.\n-            // Make it possible for After() to tell a bad dictionary from bad\n-            // input.\n-            err_ = Z_NEED_DICT;\n-          }\n-        }\n-\n-        while (strm_.avail_in > 0 &&\n-               mode_ == GUNZIP &&\n-               err_ == Z_STREAM_END &&\n-               strm_.next_in[0] != 0x00) {\n-          // Bytes remain in input buffer. Perhaps this is another compressed\n-          // member in the same archive, or just trailing garbage.\n-          // Trailing zero bytes are okay, though, since they are frequently\n-          // used for padding.\n-\n-          Reset();\n-          err_ = inflate(&strm_, flush_);\n-        }\n-        break;\n-      default:\n-        UNREACHABLE();\n-    }\n-\n-    // pass any errors back to the main thread to deal with.\n-\n-    // now After will emit the output, and\n-    // either schedule another call to Process,\n-    // or shift the queue and call Process.\n+    ctx_.DoThreadPoolWork();\n   }\n \n \n   bool CheckError() {\n-    // Acceptable error states depend on the type of zlib stream.\n-    switch (err_) {\n-    case Z_OK:\n-    case Z_BUF_ERROR:\n-      if (strm_.avail_out != 0 && flush_ == Z_FINISH) {\n-        Error(\"unexpected end of file\");\n-        return false;\n-      }\n-    case Z_STREAM_END:\n-      // normal statuses, not fatal\n-      break;\n-    case Z_NEED_DICT:\n-      if (dictionary_.empty())\n-        Error(\"Missing dictionary\");\n-      else\n-        Error(\"Bad dictionary\");\n-      return false;\n-    default:\n-      // something else.\n-      Error(\"Zlib error\");\n-      return false;\n-    }\n-\n-    return true;\n+    const CompressionError err = ctx_.GetErrorInfo();\n+    if (!err.IsError()) return true;\n+    EmitError(err);\n+    return false;\n   }\n \n \n@@ -400,8 +310,7 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     if (!CheckError())\n       return;\n \n-    write_result_[0] = strm_.avail_out;\n-    write_result_[1] = strm_.avail_in;\n+    UpdateWriteResult();\n \n     // call the write() cb\n     Local<Function> cb = PersistentToLocal(env()->isolate(),\n@@ -413,19 +322,15 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   }\n \n   // TODO(addaleax): Switch to modern error system (node_errors.h).\n-  void Error(const char* message) {\n+  void EmitError(const CompressionError& err) {\n     // If you hit this assertion, you forgot to enter the v8::Context first.\n     CHECK_EQ(env()->context(), env()->isolate()->GetCurrentContext());\n \n-    if (strm_.msg != nullptr) {\n-      message = strm_.msg;\n-    }\n-\n     HandleScope scope(env()->isolate());\n     Local<Value> args[3] = {\n-      OneByteString(env()->isolate(), message),\n-      Integer::New(env()->isolate(), err_),\n-      OneByteString(env()->isolate(), ZlibStrerror(err_))\n+      OneByteString(env()->isolate(), err.message),\n+      Integer::New(env()->isolate(), err.err),\n+      OneByteString(env()->isolate(), err.code)\n     };\n     MakeCallback(env()->onerror_string(), arraysize(args), args);\n \n@@ -435,12 +340,107 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n       Close();\n   }\n \n+  void MemoryInfo(MemoryTracker* tracker) const override {\n+    tracker->TrackField(\"compression context\", ctx_);\n+    tracker->TrackFieldWithSize(\"zlib_memory\",\n+                                zlib_memory_ + unreported_allocations_);\n+  }\n+\n+ protected:\n+  CompressionContext* context() { return &ctx_; }\n+\n+  void InitStream(uint32_t* write_result, Local<Function> write_js_callback) {\n+    write_result_ = write_result;\n+    write_js_callback_.Reset(env()->isolate(), write_js_callback);\n+    init_done_ = true;\n+  }\n+\n+  // Allocation functions provided to zlib itself. We store the real size of\n+  // the allocated memory chunk just before the \"payload\" memory we return\n+  // to zlib.\n+  // Because we use zlib off the thread pool, we can not report memory directly\n+  // to V8; rather, we first store it as \"unreported\" memory in a separate\n+  // field and later report it back from the main thread.\n+  static void* AllocForZlib(void* data, uInt items, uInt size) {\n+    CompressionStream* ctx = static_cast<CompressionStream*>(data);\n+    size_t real_size =\n+        MultiplyWithOverflowCheck(static_cast<size_t>(items),\n+                                  static_cast<size_t>(size)) + sizeof(size_t);\n+    char* memory = UncheckedMalloc(real_size);\n+    if (UNLIKELY(memory == nullptr)) return nullptr;\n+    *reinterpret_cast<size_t*>(memory) = real_size;\n+    ctx->unreported_allocations_.fetch_add(real_size,\n+                                           std::memory_order_relaxed);\n+    return memory + sizeof(size_t);\n+  }\n+\n+  static void FreeForZlib(void* data, void* pointer) {\n+    if (UNLIKELY(pointer == nullptr)) return;\n+    CompressionStream* ctx = static_cast<CompressionStream*>(data);\n+    char* real_pointer = static_cast<char*>(pointer) - sizeof(size_t);\n+    size_t real_size = *reinterpret_cast<size_t*>(real_pointer);\n+    ctx->unreported_allocations_.fetch_sub(real_size,\n+                                           std::memory_order_relaxed);\n+    free(real_pointer);\n+  }\n+\n+  // This is called on the main thread after zlib may have allocated something\n+  // in order to report it back to V8.\n+  void AdjustAmountOfExternalAllocatedMemory() {\n+    ssize_t report =\n+        unreported_allocations_.exchange(0, std::memory_order_relaxed);\n+    if (report == 0) return;\n+    CHECK_IMPLIES(report < 0, zlib_memory_ >= static_cast<size_t>(-report));\n+    zlib_memory_ += report;\n+    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(report);\n+  }\n+\n+  struct AllocScope {\n+    explicit AllocScope(CompressionStream* stream) : stream(stream) {}\n+    ~AllocScope() { stream->AdjustAmountOfExternalAllocatedMemory(); }\n+    CompressionStream* stream;\n+  };\n+\n+ private:\n+  void Ref() {\n+    if (++refs_ == 1) {\n+      ClearWeak();\n+    }\n+  }\n+\n+  void Unref() {\n+    CHECK_GT(refs_, 0);\n+    if (--refs_ == 0) {\n+      MakeWeak();\n+    }\n+  }\n+\n+  bool init_done_ = false;\n+  bool write_in_progress_ = false;\n+  bool pending_close_ = false;\n+  bool closed_ = false;\n+  unsigned int refs_ = 0;\n+  uint32_t* write_result_ = nullptr;\n+  Persistent<Function> write_js_callback_;\n+  std::atomic<ssize_t> unreported_allocations_{0};\n+  size_t zlib_memory_ = 0;\n+\n+  CompressionContext ctx_;\n+};\n+\n+class ZlibStream : public CompressionStream<ZlibContext> {\n+ public:\n+  ZlibStream(Environment* env, Local<Object> wrap, node_zlib_mode mode)\n+    : CompressionStream(env, wrap) {\n+    context()->SetMode(mode);\n+  }\n+\n   static void New(const FunctionCallbackInfo<Value>& args) {\n     Environment* env = Environment::GetCurrent(args);\n     CHECK(args[0]->IsInt32());\n     node_zlib_mode mode =\n         static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());\n-    new ZCtx(env, args.This(), mode);\n+    new ZlibStream(env, args.This(), mode);\n   }\n \n   // just pull the ints out of the args and call the other Init\n@@ -459,42 +459,25 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n       \"init(windowBits, level, memLevel, strategy, writeResult, writeCallback,\"\n       \" dictionary)\");\n \n-    ZCtx* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n+    ZlibStream* wrap;\n+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n \n     Local<Context> context = args.GetIsolate()->GetCurrentContext();\n \n     // windowBits is special. On the compression side, 0 is an invalid value.\n     // But on the decompression side, a value of 0 for windowBits tells zlib\n     // to use the window size in the zlib header of the compressed stream.\n-    uint32_t windowBits;\n-    if (!args[0]->Uint32Value(context).To(&windowBits)) return;\n-\n-    if (!((windowBits == 0) &&\n-          (ctx->mode_ == INFLATE ||\n-           ctx->mode_ == GUNZIP ||\n-           ctx->mode_ == UNZIP))) {\n-      CHECK(\n-          (windowBits >= Z_MIN_WINDOWBITS && windowBits <= Z_MAX_WINDOWBITS) &&\n-          \"invalid windowBits\");\n-    }\n+    uint32_t window_bits;\n+    if (!args[0]->Uint32Value(context).To(&window_bits)) return;\n \n-    int level;\n+    int32_t level;\n     if (!args[1]->Int32Value(context).To(&level)) return;\n-    CHECK((level >= Z_MIN_LEVEL && level <= Z_MAX_LEVEL) &&\n-      \"invalid compression level\");\n \n-    uint32_t memLevel;\n-    if (!args[2]->Uint32Value(context).To(&memLevel)) return;\n-    CHECK((memLevel >= Z_MIN_MEMLEVEL && memLevel <= Z_MAX_MEMLEVEL) &&\n-          \"invalid memlevel\");\n+    uint32_t mem_level;\n+    if (!args[2]->Uint32Value(context).To(&mem_level)) return;\n \n     uint32_t strategy;\n     if (!args[3]->Uint32Value(context).To(&strategy)) return;\n-    CHECK((strategy == Z_FILTERED || strategy == Z_HUFFMAN_ONLY ||\n-           strategy == Z_RLE || strategy == Z_FIXED ||\n-           strategy == Z_DEFAULT_STRATEGY) &&\n-          \"invalid strategy\");\n \n     CHECK(args[4]->IsUint32Array());\n     Local<Uint32Array> array = args[4].As<Uint32Array>();\n@@ -512,279 +495,404 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n           data + Buffer::Length(args[6]));\n     }\n \n-    bool ret = ctx->Init(level, windowBits, memLevel, strategy, write_result,\n-                         write_js_callback, std::move(dictionary));\n-    if (ret)\n-      ctx->SetDictionary();\n+    wrap->InitStream(write_result, write_js_callback);\n+\n+    AllocScope alloc_scope(wrap);\n+    wrap->context()->SetAllocationFunctions(\n+        AllocForZlib, FreeForZlib, static_cast<CompressionStream*>(wrap));\n+    const CompressionError err =\n+        wrap->context()->Init(level, window_bits, mem_level, strategy,\n+                              std::move(dictionary));\n+    if (err.IsError())\n+      wrap->EmitError(err);\n \n-    return args.GetReturnValue().Set(ret);\n+    return args.GetReturnValue().Set(!err.IsError());\n   }\n \n   static void Params(const FunctionCallbackInfo<Value>& args) {\n     CHECK(args.Length() == 2 && \"params(level, strategy)\");\n-    ZCtx* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n-    Environment* env = ctx->env();\n+    ZlibStream* wrap;\n+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n+    Local<Context> context = args.GetIsolate()->GetCurrentContext();\n     int level;\n-    if (!args[0]->Int32Value(env->context()).To(&level)) return;\n+    if (!args[0]->Int32Value(context).To(&level)) return;\n     int strategy;\n-    if (!args[1]->Int32Value(env->context()).To(&strategy)) return;\n-    ctx->Params(level, strategy);\n+    if (!args[1]->Int32Value(context).To(&strategy)) return;\n+\n+    AllocScope alloc_scope(wrap);\n+    const CompressionError err = wrap->context()->SetParams(level, strategy);\n+    if (err.IsError())\n+      wrap->EmitError(err);\n   }\n \n   static void Reset(const FunctionCallbackInfo<Value> &args) {\n-    ZCtx* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n-    ctx->Reset();\n-    ctx->SetDictionary();\n+    ZlibStream* wrap;\n+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n+\n+    AllocScope alloc_scope(wrap);\n+    const CompressionError err = wrap->context()->ResetStream();\n+    if (err.IsError())\n+      wrap->EmitError(err);\n   }\n \n-  bool Init(int level, int windowBits, int memLevel,\n-            int strategy, uint32_t* write_result,\n-            Local<Function> write_js_callback,\n-            std::vector<unsigned char>&& dictionary) {\n-    AllocScope alloc_scope(this);\n-    level_ = level;\n-    windowBits_ = windowBits;\n-    memLevel_ = memLevel;\n-    strategy_ = strategy;\n+  SET_MEMORY_INFO_NAME(ZlibStream)\n+  SET_SELF_SIZE(ZlibStream)\n+};\n \n-    strm_.zalloc = AllocForZlib;\n-    strm_.zfree = FreeForZlib;\n-    strm_.opaque = static_cast<void*>(this);\n \n-    flush_ = Z_NO_FLUSH;\n+void ZlibContext::Close() {\n+  CHECK_LE(mode_, UNZIP);\n \n-    err_ = Z_OK;\n+  int status = Z_OK;\n+  if (mode_ == DEFLATE || mode_ == GZIP || mode_ == DEFLATERAW) {\n+    status = deflateEnd(&strm_);\n+  } else if (mode_ == INFLATE || mode_ == GUNZIP || mode_ == INFLATERAW ||\n+             mode_ == UNZIP) {\n+    status = inflateEnd(&strm_);\n+  }\n \n-    if (mode_ == GZIP || mode_ == GUNZIP) {\n-      windowBits_ += 16;\n-    }\n+  CHECK(status == Z_OK || status == Z_DATA_ERROR);\n+  mode_ = NONE;\n \n-    if (mode_ == UNZIP) {\n-      windowBits_ += 32;\n-    }\n+  dictionary_.clear();\n+}\n \n-    if (mode_ == DEFLATERAW || mode_ == INFLATERAW) {\n-      windowBits_ *= -1;\n-    }\n \n-    switch (mode_) {\n-      case DEFLATE:\n-      case GZIP:\n-      case DEFLATERAW:\n-        err_ = deflateInit2(&strm_,\n-                            level_,\n-                            Z_DEFLATED,\n-                            windowBits_,\n-                            memLevel_,\n-                            strategy_);\n-        break;\n-      case INFLATE:\n-      case GUNZIP:\n-      case INFLATERAW:\n-      case UNZIP:\n-        err_ = inflateInit2(&strm_, windowBits_);\n-        break;\n-      default:\n-        UNREACHABLE();\n-    }\n+void ZlibContext::DoThreadPoolWork() {\n+  const Bytef* next_expected_header_byte = nullptr;\n+\n+  // If the avail_out is left at 0, then it means that it ran out\n+  // of room.  If there was avail_out left over, then it means\n+  // that all of the input was consumed.\n+  switch (mode_) {\n+    case DEFLATE:\n+    case GZIP:\n+    case DEFLATERAW:\n+      err_ = deflate(&strm_, flush_);\n+      break;\n+    case UNZIP:\n+      if (strm_.avail_in > 0) {\n+        next_expected_header_byte = strm_.next_in;\n+      }\n \n-    dictionary_ = std::move(dictionary);\n+      switch (gzip_id_bytes_read_) {\n+        case 0:\n+          if (next_expected_header_byte == nullptr) {\n+            break;\n+          }\n \n-    write_in_progress_ = false;\n-    init_done_ = true;\n+          if (*next_expected_header_byte == GZIP_HEADER_ID1) {\n+            gzip_id_bytes_read_ = 1;\n+            next_expected_header_byte++;\n \n-    if (err_ != Z_OK) {\n-      dictionary_.clear();\n-      mode_ = NONE;\n-      return false;\n-    }\n+            if (strm_.avail_in == 1) {\n+              // The only available byte was already read.\n+              break;\n+            }\n+          } else {\n+            mode_ = INFLATE;\n+            break;\n+          }\n \n-    write_result_ = write_result;\n-    write_js_callback_.Reset(env()->isolate(), write_js_callback);\n-    return true;\n-  }\n+          // fallthrough\n+        case 1:\n+          if (next_expected_header_byte == nullptr) {\n+            break;\n+          }\n \n-  void SetDictionary() {\n-    if (dictionary_.empty())\n-      return;\n+          if (*next_expected_header_byte == GZIP_HEADER_ID2) {\n+            gzip_id_bytes_read_ = 2;\n+            mode_ = GUNZIP;\n+          } else {\n+            // There is no actual difference between INFLATE and INFLATERAW\n+            // (after initialization).\n+            mode_ = INFLATE;\n+          }\n \n-    err_ = Z_OK;\n+          break;\n+        default:\n+          CHECK(0 && \"invalid number of gzip magic number bytes read\");\n+      }\n \n-    switch (mode_) {\n-      case DEFLATE:\n-      case DEFLATERAW:\n-        err_ = deflateSetDictionary(&strm_,\n-                                    dictionary_.data(),\n-                                    dictionary_.size());\n-        break;\n-      case INFLATERAW:\n-        // The other inflate cases will have the dictionary set when inflate()\n-        // returns Z_NEED_DICT in Process()\n+      // fallthrough\n+    case INFLATE:\n+    case GUNZIP:\n+    case INFLATERAW:\n+      err_ = inflate(&strm_, flush_);\n+\n+      // If data was encoded with dictionary (INFLATERAW will have it set in\n+      // SetDictionary, don't repeat that here)\n+      if (mode_ != INFLATERAW &&\n+          err_ == Z_NEED_DICT &&\n+          !dictionary_.empty()) {\n+        // Load it\n         err_ = inflateSetDictionary(&strm_,\n                                     dictionary_.data(),\n                                     dictionary_.size());\n-        break;\n-      default:\n-        break;\n-    }\n+        if (err_ == Z_OK) {\n+          // And try to decode again\n+          err_ = inflate(&strm_, flush_);\n+        } else if (err_ == Z_DATA_ERROR) {\n+          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.\n+          // Make it possible for After() to tell a bad dictionary from bad\n+          // input.\n+          err_ = Z_NEED_DICT;\n+        }\n+      }\n \n-    if (err_ != Z_OK) {\n-      Error(\"Failed to set dictionary\");\n-    }\n+      while (strm_.avail_in > 0 &&\n+             mode_ == GUNZIP &&\n+             err_ == Z_STREAM_END &&\n+             strm_.next_in[0] != 0x00) {\n+        // Bytes remain in input buffer. Perhaps this is another compressed\n+        // member in the same archive, or just trailing garbage.\n+        // Trailing zero bytes are okay, though, since they are frequently\n+        // used for padding.\n+\n+        ResetStream();\n+        err_ = inflate(&strm_, flush_);\n+      }\n+      break;\n+    default:\n+      UNREACHABLE();\n   }\n+}\n \n-  void Params(int level, int strategy) {\n-    AllocScope alloc_scope(this);\n \n-    err_ = Z_OK;\n+void ZlibContext::SetBuffers(char* in, uint32_t in_len,\n+                             char* out, uint32_t out_len) {\n+  strm_.avail_in = in_len;\n+  strm_.next_in = reinterpret_cast<Bytef*>(in);\n+  strm_.avail_out = out_len;\n+  strm_.next_out = reinterpret_cast<Bytef*>(out);\n+}\n+\n+\n+void ZlibContext::SetFlush(int flush) {\n+  flush_ = flush;\n+}\n \n-    switch (mode_) {\n-      case DEFLATE:\n-      case DEFLATERAW:\n-        err_ = deflateParams(&strm_, level, strategy);\n-        break;\n-      default:\n-        break;\n-    }\n \n-    if (err_ != Z_OK && err_ != Z_BUF_ERROR) {\n-      Error(\"Failed to set parameters\");\n+void ZlibContext::GetAfterWriteOffsets(uint32_t* avail_in,\n+                                       uint32_t* avail_out) const {\n+  *avail_in = strm_.avail_in;\n+  *avail_out = strm_.avail_out;\n+}\n+\n+\n+CompressionError ZlibContext::ErrorForMessage(const char* message) const {\n+  if (strm_.msg != nullptr)\n+    message = strm_.msg;\n+\n+  return CompressionError { message, ZlibStrerror(err_), err_ };\n+}\n+\n+\n+CompressionError ZlibContext::GetErrorInfo() const {\n+  // Acceptable error states depend on the type of zlib stream.\n+  switch (err_) {\n+  case Z_OK:\n+  case Z_BUF_ERROR:\n+    if (strm_.avail_out != 0 && flush_ == Z_FINISH) {\n+      return ErrorForMessage(\"unexpected end of file\");\n     }\n+  case Z_STREAM_END:\n+    // normal statuses, not fatal\n+    break;\n+  case Z_NEED_DICT:\n+    if (dictionary_.empty())\n+      return ErrorForMessage(\"Missing dictionary\");\n+    else\n+      return ErrorForMessage(\"Bad dictionary\");\n+  default:\n+    // something else.\n+    return ErrorForMessage(\"Zlib error\");\n   }\n \n-  void Reset() {\n-    AllocScope alloc_scope(this);\n+  return CompressionError {};\n+}\n \n-    err_ = Z_OK;\n-\n-    switch (mode_) {\n-      case DEFLATE:\n-      case DEFLATERAW:\n-      case GZIP:\n-        err_ = deflateReset(&strm_);\n-        break;\n-      case INFLATE:\n-      case INFLATERAW:\n-      case GUNZIP:\n-        err_ = inflateReset(&strm_);\n-        break;\n-      default:\n-        break;\n-    }\n \n-    if (err_ != Z_OK) {\n-      Error(\"Failed to reset stream\");\n-    }\n+CompressionError ZlibContext::ResetStream() {\n+  err_ = Z_OK;\n+\n+  switch (mode_) {\n+    case DEFLATE:\n+    case DEFLATERAW:\n+    case GZIP:\n+      err_ = deflateReset(&strm_);\n+      break;\n+    case INFLATE:\n+    case INFLATERAW:\n+    case GUNZIP:\n+      err_ = inflateReset(&strm_);\n+      break;\n+    default:\n+      break;\n   }\n \n-  void MemoryInfo(MemoryTracker* tracker) const override {\n-    tracker->TrackField(\"dictionary\", dictionary_);\n-    tracker->TrackFieldWithSize(\"zlib_memory\",\n-                                zlib_memory_ + unreported_allocations_);\n+  if (err_ != Z_OK)\n+    return ErrorForMessage(\"Failed to reset stream\");\n+\n+  return SetDictionary();\n+}\n+\n+\n+void ZlibContext::SetAllocationFunctions(alloc_func alloc,\n+                                         free_func free,\n+                                         void* opaque) {\n+  strm_.zalloc = alloc;\n+  strm_.zfree = free;\n+  strm_.opaque = opaque;\n+}\n+\n+\n+CompressionError ZlibContext::Init(\n+    int level, int window_bits, int mem_level, int strategy,\n+    std::vector<unsigned char>&& dictionary) {\n+  if (!((window_bits == 0) &&\n+        (mode_ == INFLATE ||\n+         mode_ == GUNZIP ||\n+         mode_ == UNZIP))) {\n+    CHECK(\n+        (window_bits >= Z_MIN_WINDOWBITS && window_bits <= Z_MAX_WINDOWBITS) &&\n+        \"invalid windowBits\");\n   }\n \n-  SET_MEMORY_INFO_NAME(ZCtx)\n-  SET_SELF_SIZE(ZCtx)\n+  CHECK((level >= Z_MIN_LEVEL && level <= Z_MAX_LEVEL) &&\n+    \"invalid compression level\");\n \n- private:\n-  void Ref() {\n-    if (++refs_ == 1) {\n-      ClearWeak();\n-    }\n+  CHECK((mem_level >= Z_MIN_MEMLEVEL && mem_level <= Z_MAX_MEMLEVEL) &&\n+        \"invalid memlevel\");\n+\n+  CHECK((strategy == Z_FILTERED || strategy == Z_HUFFMAN_ONLY ||\n+         strategy == Z_RLE || strategy == Z_FIXED ||\n+         strategy == Z_DEFAULT_STRATEGY) &&\n+        \"invalid strategy\");\n+\n+  level_ = level;\n+  window_bits_ = window_bits;\n+  mem_level_ = mem_level;\n+  strategy_ = strategy;\n+\n+  flush_ = Z_NO_FLUSH;\n+\n+  err_ = Z_OK;\n+\n+  if (mode_ == GZIP || mode_ == GUNZIP) {\n+    window_bits_ += 16;\n   }\n \n-  void Unref() {\n-    CHECK_GT(refs_, 0);\n-    if (--refs_ == 0) {\n-      MakeWeak();\n-    }\n+  if (mode_ == UNZIP) {\n+    window_bits_ += 32;\n   }\n \n-  // Allocation functions provided to zlib itself. We store the real size of\n-  // the allocated memory chunk just before the \"payload\" memory we return\n-  // to zlib.\n-  // Because we use zlib off the thread pool, we can not report memory directly\n-  // to V8; rather, we first store it as \"unreported\" memory in a separate\n-  // field and later report it back from the main thread.\n-  static void* AllocForZlib(void* data, uInt items, uInt size) {\n-    ZCtx* ctx = static_cast<ZCtx*>(data);\n-    size_t real_size =\n-        MultiplyWithOverflowCheck(static_cast<size_t>(items),\n-                                  static_cast<size_t>(size)) + sizeof(size_t);\n-    char* memory = UncheckedMalloc(real_size);\n-    if (UNLIKELY(memory == nullptr)) return nullptr;\n-    *reinterpret_cast<size_t*>(memory) = real_size;\n-    ctx->unreported_allocations_.fetch_add(real_size,\n-                                           std::memory_order_relaxed);\n-    return memory + sizeof(size_t);\n+  if (mode_ == DEFLATERAW || mode_ == INFLATERAW) {\n+    window_bits_ *= -1;\n   }\n \n-  static void FreeForZlib(void* data, void* pointer) {\n-    if (UNLIKELY(pointer == nullptr)) return;\n-    ZCtx* ctx = static_cast<ZCtx*>(data);\n-    char* real_pointer = static_cast<char*>(pointer) - sizeof(size_t);\n-    size_t real_size = *reinterpret_cast<size_t*>(real_pointer);\n-    ctx->unreported_allocations_.fetch_sub(real_size,\n-                                           std::memory_order_relaxed);\n-    free(real_pointer);\n+  switch (mode_) {\n+    case DEFLATE:\n+    case GZIP:\n+    case DEFLATERAW:\n+      err_ = deflateInit2(&strm_,\n+                          level_,\n+                          Z_DEFLATED,\n+                          window_bits_,\n+                          mem_level_,\n+                          strategy_);\n+      break;\n+    case INFLATE:\n+    case GUNZIP:\n+    case INFLATERAW:\n+    case UNZIP:\n+      err_ = inflateInit2(&strm_, window_bits_);\n+      break;\n+    default:\n+      UNREACHABLE();\n   }\n \n-  // This is called on the main thread after zlib may have allocated something\n-  // in order to report it back to V8.\n-  void AdjustAmountOfExternalAllocatedMemory() {\n-    ssize_t report =\n-        unreported_allocations_.exchange(0, std::memory_order_relaxed);\n-    if (report == 0) return;\n-    CHECK_IMPLIES(report < 0, zlib_memory_ >= static_cast<size_t>(-report));\n-    zlib_memory_ += report;\n-    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(report);\n+  dictionary_ = std::move(dictionary);\n+\n+  if (err_ != Z_OK) {\n+    dictionary_.clear();\n+    mode_ = NONE;\n+    return ErrorForMessage(nullptr);\n   }\n \n-  struct AllocScope {\n-    explicit AllocScope(ZCtx* ctx) : ctx(ctx) {}\n-    ~AllocScope() { ctx->AdjustAmountOfExternalAllocatedMemory(); }\n-    ZCtx* ctx;\n-  };\n+  return SetDictionary();\n+}\n \n-  std::vector<unsigned char> dictionary_;\n-  int err_;\n-  int flush_;\n-  bool init_done_;\n-  int level_;\n-  int memLevel_;\n-  node_zlib_mode mode_;\n-  int strategy_;\n-  z_stream strm_;\n-  int windowBits_;\n-  bool write_in_progress_;\n-  bool pending_close_;\n-  unsigned int refs_;\n-  unsigned int gzip_id_bytes_read_;\n-  uint32_t* write_result_;\n-  Persistent<Function> write_js_callback_;\n-  std::atomic<ssize_t> unreported_allocations_{0};\n-  size_t zlib_memory_ = 0;\n-};\n+\n+CompressionError ZlibContext::SetDictionary() {\n+  if (dictionary_.empty())\n+    return CompressionError {};\n+\n+  err_ = Z_OK;\n+\n+  switch (mode_) {\n+    case DEFLATE:\n+    case DEFLATERAW:\n+      err_ = deflateSetDictionary(&strm_,\n+                                  dictionary_.data(),\n+                                  dictionary_.size());\n+      break;\n+    case INFLATERAW:\n+      // The other inflate cases will have the dictionary set when inflate()\n+      // returns Z_NEED_DICT in Process()\n+      err_ = inflateSetDictionary(&strm_,\n+                                  dictionary_.data(),\n+                                  dictionary_.size());\n+      break;\n+    default:\n+      break;\n+  }\n+\n+  if (err_ != Z_OK) {\n+    return ErrorForMessage(\"Failed to set dictionary\");\n+  }\n+\n+  return CompressionError {};\n+}\n+\n+\n+CompressionError ZlibContext::SetParams(int level, int strategy) {\n+  err_ = Z_OK;\n+\n+  switch (mode_) {\n+    case DEFLATE:\n+    case DEFLATERAW:\n+      err_ = deflateParams(&strm_, level, strategy);\n+      break;\n+    default:\n+      break;\n+  }\n+\n+  if (err_ != Z_OK && err_ != Z_BUF_ERROR) {\n+    return ErrorForMessage(\"Failed to set parameters\");\n+  }\n+\n+  return CompressionError {};\n+}\n \n \n void Initialize(Local<Object> target,\n                 Local<Value> unused,\n                 Local<Context> context,\n                 void* priv) {\n   Environment* env = Environment::GetCurrent(context);\n-  Local<FunctionTemplate> z = env->NewFunctionTemplate(ZCtx::New);\n+  Local<FunctionTemplate> z = env->NewFunctionTemplate(ZlibStream::New);\n \n   z->InstanceTemplate()->SetInternalFieldCount(1);\n   z->Inherit(AsyncWrap::GetConstructorTemplate(env));\n \n-  env->SetProtoMethod(z, \"write\", ZCtx::Write<true>);\n-  env->SetProtoMethod(z, \"writeSync\", ZCtx::Write<false>);\n-  env->SetProtoMethod(z, \"init\", ZCtx::Init);\n-  env->SetProtoMethod(z, \"close\", ZCtx::Close);\n-  env->SetProtoMethod(z, \"params\", ZCtx::Params);\n-  env->SetProtoMethod(z, \"reset\", ZCtx::Reset);\n+  env->SetProtoMethod(z, \"write\", ZlibStream::Write<true>);\n+  env->SetProtoMethod(z, \"writeSync\", ZlibStream::Write<false>);\n+  env->SetProtoMethod(z, \"close\", ZlibStream::Close);\n+\n+  env->SetProtoMethod(z, \"init\", ZlibStream::Init);\n+  env->SetProtoMethod(z, \"params\", ZlibStream::Params);\n+  env->SetProtoMethod(z, \"reset\", ZlibStream::Reset);\n \n   Local<String> zlibString = FIXED_ONE_BYTE_STRING(env->isolate(), \"Zlib\");\n   z->SetClassName(zlibString);"
        },
        {
            "sha": "0f86576bd1f2fadc52176c27d074eabe375e0550",
            "filename": "test/parallel/test-heapdump-zlib.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/c34eae5f882c8bb4d58b492caf97cdb08b1dbbcb/test%2Fparallel%2Ftest-heapdump-zlib.js",
            "raw_url": "https://github.com/nodejs/node/raw/c34eae5f882c8bb4d58b492caf97cdb08b1dbbcb/test%2Fparallel%2Ftest-heapdump-zlib.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-heapdump-zlib.js?ref=c34eae5f882c8bb4d58b492caf97cdb08b1dbbcb",
            "patch": "@@ -4,10 +4,10 @@ require('../common');\n const { validateSnapshotNodes } = require('../common/heap');\n const zlib = require('zlib');\n \n-validateSnapshotNodes('Node / ZCtx', []);\n+validateSnapshotNodes('Node / ZlibStream', []);\n // eslint-disable-next-line no-unused-vars\n const gunzip = zlib.createGunzip();\n-validateSnapshotNodes('Node / ZCtx', [\n+validateSnapshotNodes('Node / ZlibStream', [\n   {\n     children: [\n       { node_name: 'Zlib', edge_name: 'wrapped' },"
        }
    ],
    "stats": {
        "total": 932,
        "additions": 520,
        "deletions": 412
    }
}