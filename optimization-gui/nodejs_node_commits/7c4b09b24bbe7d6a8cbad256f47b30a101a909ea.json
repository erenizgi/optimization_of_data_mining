{
    "author": "addaleax",
    "message": "src: refactor stream callbacks and ownership\n\nInstead of setting individual callbacks on streams and tracking\nstream ownership through a boolean `consume_` flag, always have\none specific listener object in charge of a stream, and call\nmethods on that object rather than generic C-style callbacks.\n\nPR-URL: https://github.com/nodejs/node/pull/18334\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
    "files": [
        {
            "sha": "496ebf285c814ef9e02a1711112f930b0b00a924",
            "filename": "lib/_http_server.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/lib%2F_http_server.js",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/lib%2F_http_server.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_http_server.js?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -666,7 +666,7 @@ function onSocketPause() {\n function unconsume(parser, socket) {\n   if (socket._handle) {\n     if (parser._consumed)\n-      parser.unconsume(socket._handle._externalStream);\n+      parser.unconsume();\n     parser._consumed = false;\n     socket.removeListener('pause', onSocketPause);\n     socket.removeListener('resume', onSocketResume);"
        },
        {
            "sha": "a6cf67ceee2477666bde49c77636d745566fff95",
            "filename": "src/connection_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fconnection_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fconnection_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fconnection_wrap.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -3,6 +3,7 @@\n #include \"connect_wrap.h\"\n #include \"env-inl.h\"\n #include \"pipe_wrap.h\"\n+#include \"stream_base-inl.h\"\n #include \"stream_wrap.h\"\n #include \"tcp_wrap.h\"\n #include \"util-inl.h\""
        },
        {
            "sha": "9e67a2094ded89e3f478f28e0fa8a2694052ace6",
            "filename": "src/js_stream.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 48,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fjs_stream.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fjs_stream.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fjs_stream.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -25,55 +25,13 @@ JSStream::JSStream(Environment* env, Local<Object> obj)\n       StreamBase(env) {\n   node::Wrap(obj, this);\n   MakeWeak<JSStream>(this);\n-\n-  set_alloc_cb({ OnAllocImpl, this });\n-  set_read_cb({ OnReadImpl, this });\n }\n \n \n JSStream::~JSStream() {\n }\n \n \n-void JSStream::OnAllocImpl(size_t size, uv_buf_t* buf, void* ctx) {\n-  buf->base = Malloc(size);\n-  buf->len = size;\n-}\n-\n-\n-void JSStream::OnReadImpl(ssize_t nread,\n-                          const uv_buf_t* buf,\n-                          uv_handle_type pending,\n-                          void* ctx) {\n-  JSStream* wrap = static_cast<JSStream*>(ctx);\n-  CHECK_NE(wrap, nullptr);\n-  Environment* env = wrap->env();\n-  HandleScope handle_scope(env->isolate());\n-  Context::Scope context_scope(env->context());\n-\n-  if (nread < 0)  {\n-    if (buf != nullptr && buf->base != nullptr)\n-      free(buf->base);\n-    wrap->EmitData(nread, Local<Object>(), Local<Object>());\n-    return;\n-  }\n-\n-  if (nread == 0) {\n-    if (buf->base != nullptr)\n-      free(buf->base);\n-    return;\n-  }\n-\n-  CHECK_LE(static_cast<size_t>(nread), buf->len);\n-  char* base = node::Realloc(buf->base, nread);\n-\n-  CHECK_EQ(pending, UV_UNKNOWN_HANDLE);\n-\n-  Local<Object> obj = Buffer::New(env, base, nread).ToLocalChecked();\n-  wrap->EmitData(nread, obj, Local<Object>());\n-}\n-\n-\n AsyncWrap* JSStream::GetAsyncWrap() {\n   return static_cast<AsyncWrap*>(this);\n }\n@@ -212,26 +170,27 @@ void JSStream::ReadBuffer(const FunctionCallbackInfo<Value>& args) {\n   char* data = Buffer::Data(args[0]);\n   int len = Buffer::Length(args[0]);\n \n-  do {\n-    uv_buf_t buf;\n+  // Repeatedly ask the stream's owner for memory, copy the data that we\n+  // just read from JS into those buffers and emit them as reads.\n+  while (len != 0) {\n+    uv_buf_t buf = wrap->EmitAlloc(len);\n     ssize_t avail = len;\n-    wrap->EmitAlloc(len, &buf);\n     if (static_cast<ssize_t>(buf.len) < avail)\n       avail = buf.len;\n \n     memcpy(buf.base, data, avail);\n     data += avail;\n     len -= avail;\n-    wrap->EmitRead(avail, &buf);\n-  } while (len != 0);\n+    wrap->EmitRead(avail, buf);\n+  }\n }\n \n \n void JSStream::EmitEOF(const FunctionCallbackInfo<Value>& args) {\n   JSStream* wrap;\n   ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n \n-  wrap->EmitRead(UV_EOF, nullptr);\n+  wrap->EmitRead(UV_EOF);\n }\n \n "
        },
        {
            "sha": "bd2e93a13c208b86c32e551f170c9ff436c3e68d",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 109,
            "deletions": 99,
            "changes": 208,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -531,24 +531,12 @@ Http2Session::Http2Session(Environment* env,\n   outgoing_buffers_.reserve(32);\n }\n \n-void Http2Session::Unconsume() {\n-  if (stream_ != nullptr) {\n-    DEBUG_HTTP2SESSION(this, \"unconsuming the i/o stream\");\n-    stream_->set_destruct_cb({ nullptr, nullptr });\n-    stream_->set_alloc_cb({ nullptr, nullptr });\n-    stream_->set_read_cb({ nullptr, nullptr });\n-    stream_->Unconsume();\n-    stream_ = nullptr;\n-  }\n-}\n-\n Http2Session::~Http2Session() {\n   CHECK_EQ(flags_ & SESSION_STATE_HAS_SCOPE, 0);\n   if (!object().IsEmpty())\n     ClearWrap(object());\n   persistent().Reset();\n   CHECK(persistent().IsEmpty());\n-  Unconsume();\n   DEBUG_HTTP2SESSION(this, \"freeing nghttp2 session\");\n   nghttp2_session_del(session_);\n }\n@@ -646,7 +634,8 @@ void Http2Session::Close(uint32_t code, bool socket_closed) {\n     DEBUG_HTTP2SESSION2(this, \"terminating session with code %d\", code);\n     CHECK_EQ(nghttp2_session_terminate_session(session_, code), 0);\n   } else {\n-    Unconsume();\n+    if (stream_ != nullptr)\n+      stream_->RemoveStreamListener(this);\n   }\n \n   // If there are outstanding pings, those will need to be canceled, do\n@@ -1044,22 +1033,38 @@ inline int Http2Session::OnDataChunkReceived(nghttp2_session* handle,\n \n     stream->statistics_.received_bytes += len;\n \n-    // There is a single large array buffer for the entire data read from the\n-    // network; create a slice of that array buffer and emit it as the\n-    // received data buffer.\n-    CHECK(!session->stream_buf_ab_.IsEmpty());\n-    size_t offset = reinterpret_cast<const char*>(data) - session->stream_buf_;\n-    // Verify that the data offset is inside the current read buffer.\n-    CHECK_LE(offset, session->stream_buf_size_);\n-\n-    Local<Object> buf =\n-        Buffer::New(env, session->stream_buf_ab_, offset, len).ToLocalChecked();\n-\n-    stream->EmitData(len, buf, Local<Object>());\n-    if (!stream->IsReading())\n-      stream->inbound_consumed_data_while_paused_ += len;\n-    else\n-      nghttp2_session_consume_stream(handle, id, len);\n+    // Repeatedly ask the stream's owner for memory, and copy the read data\n+    // into those buffers.\n+    // The typical case is actually the exception here; Http2StreamListeners\n+    // know about the HTTP2 session associated with this stream, so they know\n+    // about the larger from-socket read buffer, so they do not require copying.\n+    do {\n+      uv_buf_t buf = stream->EmitAlloc(len);\n+      ssize_t avail = len;\n+      if (static_cast<ssize_t>(buf.len) < avail)\n+        avail = buf.len;\n+\n+      // `buf.base == nullptr` is the default Http2StreamListener's way\n+      // of saying that it wants a pointer to the raw original.\n+      // Since it has access to the original socket buffer from which the data\n+      // was read in the first place, it can use that to minizime ArrayBuffer\n+      // allocations.\n+      if (LIKELY(buf.base == nullptr))\n+        buf.base = reinterpret_cast<char*>(const_cast<uint8_t*>(data));\n+      else\n+        memcpy(buf.base, data, avail);\n+      data += avail;\n+      len -= avail;\n+      stream->EmitRead(avail, buf);\n+\n+      // If the stream owner (e.g. the JS Http2Stream) wants more data, just\n+      // tell nghttp2 that all data has been consumed. Otherwise, defer until\n+      // more data is being requested.\n+      if (stream->IsReading())\n+        nghttp2_session_consume_stream(handle, id, avail);\n+      else\n+        stream->inbound_consumed_data_while_paused_ += avail;\n+    } while (len != 0);\n   }\n   return 0;\n }\n@@ -1129,6 +1134,38 @@ inline void Http2Session::GetTrailers(Http2Stream* stream, uint32_t* flags) {\n   }\n }\n \n+uv_buf_t Http2StreamListener::OnStreamAlloc(size_t size) {\n+  // See the comments in Http2Session::OnDataChunkReceived\n+  // (which is the only possible call site for this method).\n+  return uv_buf_init(nullptr, size);\n+}\n+\n+void Http2StreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n+  Http2Stream* stream = static_cast<Http2Stream*>(stream_);\n+  Http2Session* session = stream->session();\n+  Environment* env = stream->env();\n+\n+  if (nread < 0) {\n+    PassReadErrorToPreviousListener(nread);\n+    return;\n+  }\n+\n+  CHECK(!session->stream_buf_ab_.IsEmpty());\n+\n+  // There is a single large array buffer for the entire data read from the\n+  // network; create a slice of that array buffer and emit it as the\n+  // received data buffer.\n+  size_t offset = buf.base - session->stream_buf_.base;\n+\n+  // Verify that the data offset is inside the current read buffer.\n+  CHECK_LE(offset, session->stream_buf_.len);\n+  CHECK_LE(offset + buf.len, session->stream_buf_.len);\n+\n+  Local<Object> buffer =\n+      Buffer::New(env, session->stream_buf_ab_, offset, nread).ToLocalChecked();\n+\n+  stream->CallJSOnreadMethod(nread, buffer);\n+}\n \n Http2Stream::SubmitTrailers::SubmitTrailers(\n     Http2Session* session,\n@@ -1257,7 +1294,7 @@ inline void Http2Session::HandleDataFrame(const nghttp2_frame* frame) {\n     return;\n \n   if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {\n-    stream->EmitData(UV_EOF, Local<Object>(), Local<Object>());\n+    stream->EmitRead(UV_EOF);\n   }\n }\n \n@@ -1378,16 +1415,15 @@ inline void Http2Session::HandleSettingsFrame(const nghttp2_frame* frame) {\n }\n \n // Callback used when data has been written to the stream.\n-void Http2Session::OnStreamAfterWriteImpl(WriteWrap* w, int status, void* ctx) {\n-  Http2Session* session = static_cast<Http2Session*>(ctx);\n-  DEBUG_HTTP2SESSION2(session, \"write finished with status %d\", status);\n+void Http2Session::OnStreamAfterWrite(WriteWrap* w, int status) {\n+  DEBUG_HTTP2SESSION2(this, \"write finished with status %d\", status);\n \n   // Inform all pending writes about their completion.\n-  session->ClearOutgoing(status);\n+  ClearOutgoing(status);\n \n-  if (!(session->flags_ & SESSION_STATE_WRITE_SCHEDULED)) {\n+  if (!(flags_ & SESSION_STATE_WRITE_SCHEDULED)) {\n     // Schedule a new write if nghttp2 wants to send data.\n-    session->MaybeScheduleWrite();\n+    MaybeScheduleWrite();\n   }\n }\n \n@@ -1625,97 +1661,76 @@ WriteWrap* Http2Session::AllocateSend() {\n   Local<Object> obj =\n       env()->write_wrap_constructor_function()\n           ->NewInstance(env()->context()).ToLocalChecked();\n-  return WriteWrap::New(env(), obj, stream_);\n-}\n-\n-// Allocates the data buffer used to receive inbound data from the i/o stream\n-void Http2Session::OnStreamAllocImpl(size_t suggested_size,\n-                                     uv_buf_t* buf,\n-                                     void* ctx) {\n-  Http2Session* session = static_cast<Http2Session*>(ctx);\n-  CHECK_EQ(session->stream_buf_, nullptr);\n-  CHECK_EQ(session->stream_buf_size_, 0);\n-  buf->base = session->stream_buf_ = Malloc(suggested_size);\n-  buf->len = session->stream_buf_size_ = suggested_size;\n-  session->IncrementCurrentSessionMemory(suggested_size);\n+  return WriteWrap::New(env(), obj, static_cast<StreamBase*>(stream_));\n }\n \n // Callback used to receive inbound data from the i/o stream\n-void Http2Session::OnStreamReadImpl(ssize_t nread,\n-                                    const uv_buf_t* buf,\n-                                    uv_handle_type pending,\n-                                    void* ctx) {\n-  Http2Session* session = static_cast<Http2Session*>(ctx);\n-  Http2Scope h2scope(session);\n-  CHECK_NE(session->stream_, nullptr);\n-  DEBUG_HTTP2SESSION2(session, \"receiving %d bytes\", nread);\n+void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n+  Http2Scope h2scope(this);\n+  CHECK_NE(stream_, nullptr);\n+  DEBUG_HTTP2SESSION2(this, \"receiving %d bytes\", nread);\n+  IncrementCurrentSessionMemory(buf.len);\n+  CHECK(stream_buf_ab_.IsEmpty());\n+\n   if (nread <= 0) {\n-    free(session->stream_buf_);\n+    free(buf.base);\n     if (nread < 0) {\n-      uv_buf_t tmp_buf = uv_buf_init(nullptr, 0);\n-      session->prev_read_cb_.fn(nread,\n-                                &tmp_buf,\n-                                pending,\n-                                session->prev_read_cb_.ctx);\n+      PassReadErrorToPreviousListener(nread);\n     }\n   } else {\n     // Only pass data on if nread > 0\n \n+    // Makre sure that there was no read previously active.\n+    CHECK_EQ(stream_buf_.base, nullptr);\n+    CHECK_EQ(stream_buf_.len, 0);\n+\n+    // Remember the current buffer, so that OnDataChunkReceived knows the\n+    // offset of a DATA frame's data into the socket read buffer.\n+    stream_buf_ = uv_buf_init(buf.base, nread);\n+\n     // Verify that currently: There is memory allocated into which\n     // the data has been read, and that memory buffer is at least as large\n     // as the amount of data we have read, but we have not yet made an\n     // ArrayBuffer out of it.\n-    CHECK_NE(session->stream_buf_, nullptr);\n-    CHECK_EQ(session->stream_buf_, buf->base);\n-    CHECK_EQ(session->stream_buf_size_, buf->len);\n-    CHECK_GE(session->stream_buf_size_, static_cast<size_t>(nread));\n-    CHECK(session->stream_buf_ab_.IsEmpty());\n+    CHECK_LE(static_cast<size_t>(nread), stream_buf_.len);\n \n-    Environment* env = session->env();\n-    Isolate* isolate = env->isolate();\n+    Isolate* isolate = env()->isolate();\n     HandleScope scope(isolate);\n-    Local<Context> context = env->context();\n-    Context::Scope context_scope(context);\n+    Context::Scope context_scope(env()->context());\n \n     // Create an array buffer for the read data. DATA frames will be emitted\n     // as slices of this array buffer to avoid having to copy memory.\n-    session->stream_buf_ab_ =\n+    stream_buf_ab_ =\n         ArrayBuffer::New(isolate,\n-                         session->stream_buf_,\n-                         session->stream_buf_size_,\n+                         buf.base,\n+                         nread,\n                          v8::ArrayBufferCreationMode::kInternalized);\n \n-    uv_buf_t buf_ = uv_buf_init(buf->base, nread);\n-    session->statistics_.data_received += nread;\n-    ssize_t ret = session->Write(&buf_, 1);\n+    statistics_.data_received += nread;\n+    ssize_t ret = Write(&stream_buf_, 1);\n \n     // Note: if ssize_t is not defined (e.g. on Win32), nghttp2 will typedef\n     // ssize_t to int. Cast here so that the < 0 check actually works on\n     // Windows.\n     if (static_cast<int>(ret) < 0) {\n-      DEBUG_HTTP2SESSION2(session, \"fatal error receiving data: %d\", ret);\n+      DEBUG_HTTP2SESSION2(this, \"fatal error receiving data: %d\", ret);\n \n-      Local<Value> argv[1] = {\n+      Local<Value> argv[] = {\n         Integer::New(isolate, ret),\n       };\n-      session->MakeCallback(env->error_string(), arraysize(argv), argv);\n+      MakeCallback(env()->error_string(), arraysize(argv), argv);\n     } else {\n-      DEBUG_HTTP2SESSION2(session, \"processed %d bytes. wants more? %d\", ret,\n-                          nghttp2_session_want_read(**session));\n+      DEBUG_HTTP2SESSION2(this, \"processed %d bytes. wants more? %d\", ret,\n+                          nghttp2_session_want_read(session_));\n     }\n   }\n \n   // Since we are finished handling this write, reset the stream buffer.\n   // The memory has either been free()d or was handed over to V8.\n-  session->DecrementCurrentSessionMemory(session->stream_buf_size_);\n-  session->stream_buf_ = nullptr;\n-  session->stream_buf_size_ = 0;\n-  session->stream_buf_ab_ = Local<ArrayBuffer>();\n-}\n+  DecrementCurrentSessionMemory(buf.len);\n \n-void Http2Session::OnStreamDestructImpl(void* ctx) {\n-  Http2Session* session = static_cast<Http2Session*>(ctx);\n-  session->stream_ = nullptr;\n+  stream_buf_ab_ = Local<ArrayBuffer>();\n+  stream_buf_ = uv_buf_init(nullptr, 0);\n }\n \n // Every Http2Session session is tightly bound to a single i/o StreamBase\n@@ -1724,14 +1739,7 @@ void Http2Session::OnStreamDestructImpl(void* ctx) {\n // C++ layer via the StreamBase API.\n void Http2Session::Consume(Local<External> external) {\n   StreamBase* stream = static_cast<StreamBase*>(external->Value());\n-  stream->Consume();\n-  stream_ = stream;\n-  prev_alloc_cb_ = stream->alloc_cb();\n-  prev_read_cb_ = stream->read_cb();\n-  stream->set_alloc_cb({ Http2Session::OnStreamAllocImpl, this });\n-  stream->set_read_cb({ Http2Session::OnStreamReadImpl, this });\n-  stream->set_after_write_cb({ Http2Session::OnStreamAfterWriteImpl, this });\n-  stream->set_destruct_cb({ Http2Session::OnStreamDestructImpl, this });\n+  stream->PushStreamListener(this);\n   DEBUG_HTTP2SESSION(this, \"i/o stream consumed\");\n }\n \n@@ -1769,6 +1777,8 @@ Http2Stream::Http2Stream(\n   if (options & STREAM_OPTION_GET_TRAILERS)\n     flags_ |= NGHTTP2_STREAM_FLAG_TRAILERS;\n \n+  PushStreamListener(&stream_listener_);\n+\n   if (options & STREAM_OPTION_EMPTY_PAYLOAD)\n     Shutdown();\n   session->AddStream(this);"
        },
        {
            "sha": "bf41d74ed49ad9e05888a530d00cb27f0b9ed56e",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 14,
            "deletions": 19,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -535,6 +535,12 @@ class Http2Priority {\n   nghttp2_priority_spec spec;\n };\n \n+class Http2StreamListener : public StreamListener {\n+ public:\n+  uv_buf_t OnStreamAlloc(size_t suggested_size) override;\n+  void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n+};\n+\n class Http2Stream : public AsyncWrap,\n                     public StreamBase {\n  public:\n@@ -747,6 +753,8 @@ class Http2Stream : public AsyncWrap,\n   int64_t fd_offset_ = 0;\n   int64_t fd_length_ = -1;\n \n+  Http2StreamListener stream_listener_;\n+\n   friend class Http2Session;\n };\n \n@@ -798,7 +806,7 @@ class Http2Stream::Provider::Stream : public Http2Stream::Provider {\n };\n \n \n-class Http2Session : public AsyncWrap {\n+class Http2Session : public AsyncWrap, public StreamListener {\n  public:\n   Http2Session(Environment* env,\n                Local<Object> wrap,\n@@ -872,21 +880,11 @@ class Http2Session : public AsyncWrap {\n \n   size_t self_size() const override { return sizeof(*this); }\n \n-  char* stream_alloc() {\n-    return stream_buf_;\n-  }\n-\n   inline void GetTrailers(Http2Stream* stream, uint32_t* flags);\n \n-  static void OnStreamAllocImpl(size_t suggested_size,\n-                                uv_buf_t* buf,\n-                                void* ctx);\n-  static void OnStreamReadImpl(ssize_t nread,\n-                               const uv_buf_t* bufs,\n-                               uv_handle_type pending,\n-                               void* ctx);\n-  static void OnStreamAfterWriteImpl(WriteWrap* w, int status, void* ctx);\n-  static void OnStreamDestructImpl(void* ctx);\n+  // Handle reads/writes from the underlying network transport.\n+  void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n+  void OnStreamAfterWrite(WriteWrap* w, int status) override;\n \n   // The JavaScript API\n   static void New(const FunctionCallbackInfo<Value>& args);\n@@ -1074,16 +1072,12 @@ class Http2Session : public AsyncWrap {\n   int flags_ = SESSION_STATE_NONE;\n \n   // The StreamBase instance being used for i/o\n-  StreamBase* stream_;\n-  StreamResource::Callback<StreamResource::AllocCb> prev_alloc_cb_;\n-  StreamResource::Callback<StreamResource::ReadCb> prev_read_cb_;\n   padding_strategy_type padding_strategy_ = PADDING_STRATEGY_NONE;\n \n   // use this to allow timeout tracking during long-lasting writes\n   uint32_t chunks_sent_since_last_write_ = 0;\n \n-  char* stream_buf_ = nullptr;\n-  size_t stream_buf_size_ = 0;\n+  uv_buf_t stream_buf_ = uv_buf_init(nullptr, 0);\n   v8::Local<v8::ArrayBuffer> stream_buf_ab_;\n \n   size_t max_outstanding_pings_ = DEFAULT_MAX_PINGS;\n@@ -1099,6 +1093,7 @@ class Http2Session : public AsyncWrap {\n   void ClearOutgoing(int status);\n \n   friend class Http2Scope;\n+  friend class Http2StreamListener;\n };\n \n class Http2SessionPerformanceEntry : public PerformanceEntry {"
        },
        {
            "sha": "d4044f8bbeea7b6ab192492886cdcf0ad382abd4",
            "filename": "src/node_http_parser.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 55,
            "changes": 75,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fnode_http_parser.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fnode_http_parser.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http_parser.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -144,7 +144,7 @@ struct StringPtr {\n };\n \n \n-class Parser : public AsyncWrap {\n+class Parser : public AsyncWrap, public StreamListener {\n  public:\n   Parser(Environment* env, Local<Object> wrap, enum http_parser_type type)\n       : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_HTTPPARSER),\n@@ -494,14 +494,7 @@ class Parser : public AsyncWrap {\n     Local<External> stream_obj = args[0].As<External>();\n     StreamBase* stream = static_cast<StreamBase*>(stream_obj->Value());\n     CHECK_NE(stream, nullptr);\n-\n-    stream->Consume();\n-\n-    parser->prev_alloc_cb_ = stream->alloc_cb();\n-    parser->prev_read_cb_ = stream->read_cb();\n-\n-    stream->set_alloc_cb({ OnAllocImpl, parser });\n-    stream->set_read_cb({ OnReadImpl, parser });\n+    stream->PushStreamListener(parser);\n   }\n \n \n@@ -510,22 +503,10 @@ class Parser : public AsyncWrap {\n     ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());\n \n     // Already unconsumed\n-    if (parser->prev_alloc_cb_.is_empty())\n+    if (parser->stream_ == nullptr)\n       return;\n \n-    // Restore stream's callbacks\n-    if (args.Length() == 1 && args[0]->IsExternal()) {\n-      Local<External> stream_obj = args[0].As<External>();\n-      StreamBase* stream = static_cast<StreamBase*>(stream_obj->Value());\n-      CHECK_NE(stream, nullptr);\n-\n-      stream->set_alloc_cb(parser->prev_alloc_cb_);\n-      stream->set_read_cb(parser->prev_read_cb_);\n-      stream->Unconsume();\n-    }\n-\n-    parser->prev_alloc_cb_.clear();\n-    parser->prev_read_cb_.clear();\n+    parser->stream_->RemoveStreamListener(parser);\n   }\n \n \n@@ -544,61 +525,47 @@ class Parser : public AsyncWrap {\n  protected:\n   static const size_t kAllocBufferSize = 64 * 1024;\n \n-  static void OnAllocImpl(size_t suggested_size, uv_buf_t* buf, void* ctx) {\n-    Parser* parser = static_cast<Parser*>(ctx);\n-    Environment* env = parser->env();\n+  uv_buf_t OnStreamAlloc(size_t suggested_size) override {\n+    if (env()->http_parser_buffer() == nullptr)\n+      env()->set_http_parser_buffer(new char[kAllocBufferSize]);\n \n-    if (env->http_parser_buffer() == nullptr)\n-      env->set_http_parser_buffer(new char[kAllocBufferSize]);\n-\n-    buf->base = env->http_parser_buffer();\n-    buf->len = kAllocBufferSize;\n+    return uv_buf_init(env()->http_parser_buffer(), kAllocBufferSize);\n   }\n \n \n-  static void OnReadImpl(ssize_t nread,\n-                         const uv_buf_t* buf,\n-                         uv_handle_type pending,\n-                         void* ctx) {\n-    Parser* parser = static_cast<Parser*>(ctx);\n-    HandleScope scope(parser->env()->isolate());\n+  void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override {\n+    HandleScope scope(env()->isolate());\n \n     if (nread < 0) {\n-      uv_buf_t tmp_buf;\n-      tmp_buf.base = nullptr;\n-      tmp_buf.len = 0;\n-      parser->prev_read_cb_.fn(nread,\n-                               &tmp_buf,\n-                               pending,\n-                               parser->prev_read_cb_.ctx);\n+      PassReadErrorToPreviousListener(nread);\n       return;\n     }\n \n     // Ignore, empty reads have special meaning in http parser\n     if (nread == 0)\n       return;\n \n-    parser->current_buffer_.Clear();\n-    Local<Value> ret = parser->Execute(buf->base, nread);\n+    current_buffer_.Clear();\n+    Local<Value> ret = Execute(buf.base, nread);\n \n     // Exception\n     if (ret.IsEmpty())\n       return;\n \n-    Local<Object> obj = parser->object();\n-    Local<Value> cb = obj->Get(kOnExecute);\n+    Local<Value> cb =\n+        object()->Get(env()->context(), kOnExecute).ToLocalChecked();\n \n     if (!cb->IsFunction())\n       return;\n \n     // Hooks for GetCurrentBuffer\n-    parser->current_buffer_len_ = nread;\n-    parser->current_buffer_data_ = buf->base;\n+    current_buffer_len_ = nread;\n+    current_buffer_data_ = buf.base;\n \n-    parser->MakeCallback(cb.As<Function>(), 1, &ret);\n+    MakeCallback(cb.As<Function>(), 1, &ret);\n \n-    parser->current_buffer_len_ = 0;\n-    parser->current_buffer_data_ = nullptr;\n+    current_buffer_len_ = 0;\n+    current_buffer_data_ = nullptr;\n   }\n \n \n@@ -713,8 +680,6 @@ class Parser : public AsyncWrap {\n   Local<Object> current_buffer_;\n   size_t current_buffer_len_;\n   char* current_buffer_data_;\n-  StreamResource::Callback<StreamResource::AllocCb> prev_alloc_cb_;\n-  StreamResource::Callback<StreamResource::ReadCb> prev_read_cb_;\n \n   // These are helper functions for filling `http_parser_settings`, which turn\n   // a member function of Parser into a C-style HTTP parser callback."
        },
        {
            "sha": "016ce480b6a80996059f79811752040ae33eb45c",
            "filename": "src/pipe_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fpipe_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fpipe_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fpipe_wrap.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -29,6 +29,7 @@\n #include \"node_buffer.h\"\n #include \"node_wrap.h\"\n #include \"connect_wrap.h\"\n+#include \"stream_base-inl.h\"\n #include \"stream_wrap.h\"\n #include \"util-inl.h\"\n "
        },
        {
            "sha": "314131e1dd319f0c63dcfd5fe86b7506ae6966a8",
            "filename": "src/process_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fprocess_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fprocess_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fprocess_wrap.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -22,6 +22,7 @@\n #include \"env-inl.h\"\n #include \"handle_wrap.h\"\n #include \"node_wrap.h\"\n+#include \"stream_base-inl.h\"\n #include \"util-inl.h\"\n \n #include <string.h>"
        },
        {
            "sha": "287978a87034ebbb108fb83aaee8e3477d5c3060",
            "filename": "src/stream_base-inl.h",
            "status": "modified",
            "additions": 83,
            "deletions": 2,
            "changes": 85,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_base-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_base-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base-inl.h?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -25,6 +25,87 @@ using v8::Value;\n \n using AsyncHooks = Environment::AsyncHooks;\n \n+\n+inline StreamListener::~StreamListener() {\n+  if (stream_ != nullptr)\n+    stream_->RemoveStreamListener(this);\n+}\n+\n+inline void StreamListener::PassReadErrorToPreviousListener(ssize_t nread) {\n+  CHECK_NE(previous_listener_, nullptr);\n+  previous_listener_->OnStreamRead(nread,\n+                                   uv_buf_init(nullptr, 0),\n+                                   UV_UNKNOWN_HANDLE);\n+}\n+\n+\n+inline StreamResource::~StreamResource() {\n+  while (listener_ != nullptr) {\n+    listener_->OnStreamDestroy();\n+    RemoveStreamListener(listener_);\n+  }\n+}\n+\n+inline void StreamResource::PushStreamListener(StreamListener* listener) {\n+  CHECK_NE(listener, nullptr);\n+  CHECK_EQ(listener->stream_, nullptr);\n+\n+  listener->previous_listener_ = listener_;\n+  listener->stream_ = this;\n+\n+  listener_ = listener;\n+}\n+\n+inline void StreamResource::RemoveStreamListener(StreamListener* listener) {\n+  CHECK_NE(listener, nullptr);\n+\n+  StreamListener* previous;\n+  StreamListener* current;\n+\n+  // Remove from the linked list.\n+  for (current = listener_, previous = nullptr;\n+       /* No loop condition because we want a crash if listener is not found */\n+       ; previous = current, current = current->previous_listener_) {\n+    CHECK_NE(current, nullptr);\n+    if (current == listener) {\n+      if (previous != nullptr)\n+        previous->previous_listener_ = current->previous_listener_;\n+      else\n+        listener_ = listener->previous_listener_;\n+      break;\n+    }\n+  }\n+\n+  listener->stream_ = nullptr;\n+  listener->previous_listener_ = nullptr;\n+}\n+\n+\n+inline uv_buf_t StreamResource::EmitAlloc(size_t suggested_size) {\n+  return listener_->OnStreamAlloc(suggested_size);\n+}\n+\n+inline void StreamResource::EmitRead(ssize_t nread,\n+                                     const uv_buf_t& buf,\n+                                     uv_handle_type pending) {\n+  if (nread > 0)\n+    bytes_read_ += static_cast<uint64_t>(nread);\n+  listener_->OnStreamRead(nread, buf, pending);\n+}\n+\n+inline void StreamResource::EmitAfterWrite(WriteWrap* w, int status) {\n+  listener_->OnStreamAfterWrite(w, status);\n+}\n+\n+\n+inline StreamBase::StreamBase(Environment* env) : env_(env) {\n+  PushStreamListener(&default_listener_);\n+}\n+\n+inline Environment* StreamBase::stream_env() const {\n+  return env_;\n+}\n+\n template <class Base>\n void StreamBase::AddMethods(Environment* env,\n                             Local<FunctionTemplate> t,\n@@ -70,8 +151,8 @@ void StreamBase::AddMethods(Environment* env,\n                                               Local<FunctionTemplate>(),\n                                               attributes);\n \n-  env->SetProtoMethod(t, \"readStart\", JSMethod<Base, &StreamBase::ReadStart>);\n-  env->SetProtoMethod(t, \"readStop\", JSMethod<Base, &StreamBase::ReadStop>);\n+  env->SetProtoMethod(t, \"readStart\", JSMethod<Base, &StreamBase::ReadStartJS>);\n+  env->SetProtoMethod(t, \"readStop\", JSMethod<Base, &StreamBase::ReadStopJS>);\n   if ((flags & kFlagNoShutdown) == 0)\n     env->SetProtoMethod(t, \"shutdown\", JSMethod<Base, &StreamBase::Shutdown>);\n   if ((flags & kFlagHasWritev) != 0)"
        },
        {
            "sha": "9acf2273abd78bd8719a103b0af132df60fec34b",
            "filename": "src/stream_base.cc",
            "status": "modified",
            "additions": 44,
            "deletions": 5,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_base.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_base.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -34,12 +34,12 @@ template int StreamBase::WriteString<LATIN1>(\n     const FunctionCallbackInfo<Value>& args);\n \n \n-int StreamBase::ReadStart(const FunctionCallbackInfo<Value>& args) {\n+int StreamBase::ReadStartJS(const FunctionCallbackInfo<Value>& args) {\n   return ReadStart();\n }\n \n \n-int StreamBase::ReadStop(const FunctionCallbackInfo<Value>& args) {\n+int StreamBase::ReadStopJS(const FunctionCallbackInfo<Value>& args) {\n   return ReadStop();\n }\n \n@@ -437,9 +437,9 @@ void StreamBase::AfterWrite(WriteWrap* req_wrap, int status) {\n }\n \n \n-void StreamBase::EmitData(ssize_t nread,\n-                          Local<Object> buf,\n-                          Local<Object> handle) {\n+void StreamBase::CallJSOnreadMethod(ssize_t nread,\n+                                    Local<Object> buf,\n+                                    Local<Object> handle) {\n   Environment* env = env_;\n \n   Local<Value> argv[] = {\n@@ -490,4 +490,43 @@ void StreamResource::ClearError() {\n   // No-op\n }\n \n+\n+uv_buf_t StreamListener::OnStreamAlloc(size_t suggested_size) {\n+  return uv_buf_init(Malloc(suggested_size), suggested_size);\n+}\n+\n+void StreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n+  // This cannot be virtual because it is just as valid to override the other\n+  // OnStreamRead() callback.\n+  CHECK(0 && \"OnStreamRead() needs to be implemented\");\n+}\n+\n+void StreamListener::OnStreamRead(ssize_t nread,\n+                                  const uv_buf_t& buf,\n+                                  uv_handle_type pending) {\n+  CHECK_EQ(pending, UV_UNKNOWN_HANDLE);\n+  OnStreamRead(nread, buf);\n+}\n+\n+\n+void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n+  CHECK_NE(stream_, nullptr);\n+  StreamBase* stream = static_cast<StreamBase*>(stream_);\n+  Environment* env = stream->stream_env();\n+  HandleScope handle_scope(env->isolate());\n+  Context::Scope context_scope(env->context());\n+\n+  if (nread <= 0)  {\n+    free(buf.base);\n+    if (nread < 0)\n+      stream->CallJSOnreadMethod(nread, Local<Object>());\n+    return;\n+  }\n+\n+  CHECK_LE(static_cast<size_t>(nread), buf.len);\n+\n+  Local<Object> obj = Buffer::New(env, buf.base, nread).ToLocalChecked();\n+  stream->CallJSOnreadMethod(nread, obj);\n+}\n+\n }  // namespace node"
        },
        {
            "sha": "0b176d11819fcad9c868c722a873d40778bc0747",
            "filename": "src/stream_base.h",
            "status": "modified",
            "additions": 113,
            "deletions": 88,
            "changes": 201,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_base.h",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_base.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.h?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -15,6 +15,7 @@ namespace node {\n \n // Forward declarations\n class StreamBase;\n+class StreamResource;\n \n template<typename Base>\n class StreamReq {\n@@ -123,89 +124,124 @@ class WriteWrap : public ReqWrap<uv_write_t>,\n   const size_t storage_size_;\n };\n \n-class StreamResource {\n+\n+// This is the generic interface for objects that control Node.js' C++ streams.\n+// For example, the default `EmitToJSStreamListener` emits a stream's data\n+// as Buffers in JS, or `TLSWrap` reads and decrypts data from a stream.\n+class StreamListener {\n  public:\n-  template <class T>\n-  struct Callback {\n-    Callback() : fn(nullptr), ctx(nullptr) {}\n-    Callback(T fn, void* ctx) : fn(fn), ctx(ctx) {}\n-    Callback(const Callback&) = default;\n-\n-    inline bool is_empty() { return fn == nullptr; }\n-    inline void clear() {\n-      fn = nullptr;\n-      ctx = nullptr;\n-    }\n+  virtual ~StreamListener();\n+\n+  // This is called when a stream wants to allocate memory immediately before\n+  // reading data into the freshly allocated buffer (i.e. it is always followed\n+  // by a `OnStreamRead()` call).\n+  // This memory may be statically or dynamically allocated; for example,\n+  // a protocol parser may want to read data into a static buffer if it knows\n+  // that all data is going to be fully handled during the next\n+  // `OnStreamRead()` call.\n+  // The returned buffer does not need to contain `suggested_size` bytes.\n+  // The default implementation of this method returns a buffer that has exactly\n+  // the suggested size and is allocated using malloc().\n+  virtual uv_buf_t OnStreamAlloc(size_t suggested_size);\n+\n+  // `OnStreamRead()` is called when data is available on the socket and has\n+  // been read into the buffer provided by `OnStreamAlloc()`.\n+  // The `buf` argument is the return value of `uv_buf_t`, or may be a buffer\n+  // with base nullpptr in case of an error.\n+  // `nread` is the number of read bytes (which is at most the buffer length),\n+  // or, if negative, a libuv error code.\n+  // The variant with a `uv_handle_type` argument is used by libuv-backed\n+  // streams for handle transfers (e.g. passing net.Socket instances between\n+  // cluster workers). For all other streams, overriding the simple variant\n+  // should be sufficient.\n+  // By default, the second variant crashes if `pending` is set and otherwise\n+  // calls the simple variant.\n+  virtual void OnStreamRead(ssize_t nread,\n+                            const uv_buf_t& buf) = 0;\n+  virtual void OnStreamRead(ssize_t nread,\n+                            const uv_buf_t& buf,\n+                            uv_handle_type pending);\n+\n+  // This is called once a Write has finished. `status` may be 0 or,\n+  // if negative, a libuv error code.\n+  virtual void OnStreamAfterWrite(WriteWrap* w, int status) {}\n+\n+  // This is called immediately before the stream is destroyed.\n+  virtual void OnStreamDestroy() {}\n \n-    T fn;\n-    void* ctx;\n-  };\n+ protected:\n+  // Pass along a read error to the `StreamListener` instance that was active\n+  // before this one. For example, a protocol parser does not care about read\n+  // errors and may instead want to let the original handler\n+  // (e.g. the JS handler) take care of the situation.\n+  void PassReadErrorToPreviousListener(ssize_t nread);\n \n-  typedef void (*AfterWriteCb)(WriteWrap* w, int status, void* ctx);\n-  typedef void (*AllocCb)(size_t size, uv_buf_t* buf, void* ctx);\n-  typedef void (*ReadCb)(ssize_t nread,\n-                         const uv_buf_t* buf,\n-                         uv_handle_type pending,\n-                         void* ctx);\n-  typedef void (*DestructCb)(void* ctx);\n+  StreamResource* stream_ = nullptr;\n+  StreamListener* previous_listener_ = nullptr;\n \n-  StreamResource() : bytes_read_(0) {\n-  }\n-  virtual ~StreamResource() {\n-    if (!destruct_cb_.is_empty())\n-      destruct_cb_.fn(destruct_cb_.ctx);\n-  }\n+  friend class StreamResource;\n+};\n+\n+\n+// A default emitter that just pushes data chunks as Buffer instances to\n+// JS land via the handle’s .ondata method.\n+class EmitToJSStreamListener : public StreamListener {\n+ public:\n+  void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n+};\n+\n+\n+// A generic stream, comparable to JS land’s `Duplex` streams.\n+// A stream is always controlled through one `StreamListener` instance.\n+class StreamResource {\n+ public:\n+  virtual ~StreamResource();\n \n   virtual int DoShutdown(ShutdownWrap* req_wrap) = 0;\n   virtual int DoTryWrite(uv_buf_t** bufs, size_t* count);\n   virtual int DoWrite(WriteWrap* w,\n                       uv_buf_t* bufs,\n                       size_t count,\n                       uv_stream_t* send_handle) = 0;\n-  virtual const char* Error() const;\n-  virtual void ClearError();\n-\n-  // Events\n-  inline void EmitAfterWrite(WriteWrap* w, int status) {\n-    if (!after_write_cb_.is_empty())\n-      after_write_cb_.fn(w, status, after_write_cb_.ctx);\n-  }\n \n-  inline void EmitAlloc(size_t size, uv_buf_t* buf) {\n-    if (!alloc_cb_.is_empty())\n-      alloc_cb_.fn(size, buf, alloc_cb_.ctx);\n-  }\n-\n-  inline void EmitRead(ssize_t nread,\n-                       const uv_buf_t* buf,\n-                       uv_handle_type pending = UV_UNKNOWN_HANDLE) {\n-    if (nread > 0)\n-      bytes_read_ += static_cast<uint64_t>(nread);\n-    if (!read_cb_.is_empty())\n-      read_cb_.fn(nread, buf, pending, read_cb_.ctx);\n-  }\n-\n-  inline void set_after_write_cb(Callback<AfterWriteCb> c) {\n-    after_write_cb_ = c;\n-  }\n+  // Start reading from the underlying resource. This is called by the consumer\n+  // when more data is desired.\n+  virtual int ReadStart() = 0;\n+  // Stop reading from the underlying resource. This is called by the\n+  // consumer when its buffers are full and no more data can be handled.\n+  virtual int ReadStop() = 0;\n \n-  inline void set_alloc_cb(Callback<AllocCb> c) { alloc_cb_ = c; }\n-  inline void set_read_cb(Callback<ReadCb> c) { read_cb_ = c; }\n-  inline void set_destruct_cb(Callback<DestructCb> c) { destruct_cb_ = c; }\n+  // Optionally, this may provide an error message to be used for\n+  // failing writes.\n+  virtual const char* Error() const;\n+  // Clear the current error (i.e. that would be returned by Error()).\n+  virtual void ClearError();\n \n-  inline Callback<AfterWriteCb> after_write_cb() { return after_write_cb_; }\n-  inline Callback<AllocCb> alloc_cb() { return alloc_cb_; }\n-  inline Callback<ReadCb> read_cb() { return read_cb_; }\n-  inline Callback<DestructCb> destruct_cb() { return destruct_cb_; }\n+  // Transfer ownership of this tream to `listener`. The previous listener\n+  // will not receive any more callbacks while the new listener was active.\n+  void PushStreamListener(StreamListener* listener);\n+  // Remove a listener, and, if this was the currently active one,\n+  // transfer ownership back to the previous listener.\n+  void RemoveStreamListener(StreamListener* listener);\n \n  protected:\n-  Callback<AfterWriteCb> after_write_cb_;\n-  Callback<AllocCb> alloc_cb_;\n-  Callback<ReadCb> read_cb_;\n-  Callback<DestructCb> destruct_cb_;\n-  uint64_t bytes_read_;\n+  // Call the current listener's OnStreamAlloc() method.\n+  uv_buf_t EmitAlloc(size_t suggested_size);\n+  // Call the current listener's OnStreamRead() method and update the\n+  // stream's read byte counter.\n+  void EmitRead(ssize_t nread,\n+                const uv_buf_t& buf = uv_buf_init(nullptr, 0),\n+                uv_handle_type pending = UV_UNKNOWN_HANDLE);\n+  // Call the current listener's OnStreamAfterWrite() method.\n+  void EmitAfterWrite(WriteWrap* w, int status);\n+\n+  StreamListener* listener_ = nullptr;\n+  uint64_t bytes_read_ = 0;\n+\n+  friend class StreamListener;\n };\n \n+\n class StreamBase : public StreamResource {\n  public:\n   enum Flags {\n@@ -224,40 +260,29 @@ class StreamBase : public StreamResource {\n   virtual bool IsIPCPipe();\n   virtual int GetFD();\n \n-  virtual int ReadStart() = 0;\n-  virtual int ReadStop() = 0;\n-\n-  inline void Consume() {\n-    CHECK_EQ(consumed_, false);\n-    consumed_ = true;\n-  }\n-\n-  inline void Unconsume() {\n-    CHECK_EQ(consumed_, true);\n-    consumed_ = false;\n-  }\n-\n-  void EmitData(ssize_t nread,\n-                v8::Local<v8::Object> buf,\n-                v8::Local<v8::Object> handle);\n+  void CallJSOnreadMethod(\n+      ssize_t nread,\n+      v8::Local<v8::Object> buf,\n+      v8::Local<v8::Object> handle = v8::Local<v8::Object>());\n \n   // These are called by the respective {Write,Shutdown}Wrap class.\n   virtual void AfterShutdown(ShutdownWrap* req, int status);\n   virtual void AfterWrite(WriteWrap* req, int status);\n \n- protected:\n-  explicit StreamBase(Environment* env) : env_(env), consumed_(false) {\n-  }\n+  // This is named `stream_env` to avoid name clashes, because a lot of\n+  // subclasses are also `BaseObject`s.\n+  Environment* stream_env() const;\n \n-  virtual ~StreamBase() = default;\n+ protected:\n+  explicit StreamBase(Environment* env);\n \n   // One of these must be implemented\n   virtual AsyncWrap* GetAsyncWrap() = 0;\n   virtual v8::Local<v8::Object> GetObject();\n \n   // JS Methods\n-  int ReadStart(const v8::FunctionCallbackInfo<v8::Value>& args);\n-  int ReadStop(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  int ReadStartJS(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  int ReadStopJS(const v8::FunctionCallbackInfo<v8::Value>& args);\n   int Shutdown(const v8::FunctionCallbackInfo<v8::Value>& args);\n   int Writev(const v8::FunctionCallbackInfo<v8::Value>& args);\n   int WriteBuffer(const v8::FunctionCallbackInfo<v8::Value>& args);\n@@ -280,7 +305,7 @@ class StreamBase : public StreamResource {\n \n  private:\n   Environment* env_;\n-  bool consumed_;\n+  EmitToJSStreamListener default_listener_;\n };\n \n }  // namespace node"
        },
        {
            "sha": "0be73f9114adb13de91a8b7071ff6faede5b1afd",
            "filename": "src/stream_wrap.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 39,
            "changes": 62,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -93,8 +93,7 @@ LibuvStreamWrap::LibuvStreamWrap(Environment* env,\n                  provider),\n       StreamBase(env),\n       stream_(stream) {\n-  set_alloc_cb({ OnAllocImpl, this });\n-  set_read_cb({ OnReadImpl, this });\n+  PushStreamListener(this);\n }\n \n \n@@ -157,23 +156,18 @@ int LibuvStreamWrap::ReadStop() {\n \n \n void LibuvStreamWrap::OnAlloc(uv_handle_t* handle,\n-                         size_t suggested_size,\n-                         uv_buf_t* buf) {\n+                              size_t suggested_size,\n+                              uv_buf_t* buf) {\n   LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(handle->data);\n   HandleScope scope(wrap->env()->isolate());\n   Context::Scope context_scope(wrap->env()->context());\n \n   CHECK_EQ(wrap->stream(), reinterpret_cast<uv_stream_t*>(handle));\n \n-  return wrap->EmitAlloc(suggested_size, buf);\n+  *buf = wrap->EmitAlloc(suggested_size);\n }\n \n \n-void LibuvStreamWrap::OnAllocImpl(size_t size, uv_buf_t* buf, void* ctx) {\n-  buf->base = node::Malloc(size);\n-  buf->len = size;\n-}\n-\n \n template <class WrapType, class UVType>\n static Local<Object> AcceptHandle(Environment* env, LibuvStreamWrap* parent) {\n@@ -196,51 +190,41 @@ static Local<Object> AcceptHandle(Environment* env, LibuvStreamWrap* parent) {\n }\n \n \n-void LibuvStreamWrap::OnReadImpl(ssize_t nread,\n-                            const uv_buf_t* buf,\n-                            uv_handle_type pending,\n-                            void* ctx) {\n-  LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(ctx);\n-  Environment* env = wrap->env();\n-  HandleScope handle_scope(env->isolate());\n-  Context::Scope context_scope(env->context());\n-\n-  Local<Object> pending_obj;\n+void LibuvStreamWrap::OnStreamRead(ssize_t nread,\n+                                   const uv_buf_t& buf,\n+                                   uv_handle_type pending) {\n+  HandleScope handle_scope(env()->isolate());\n+  Context::Scope context_scope(env()->context());\n \n-  if (nread < 0)  {\n-    if (buf->base != nullptr)\n-      free(buf->base);\n-    wrap->EmitData(nread, Local<Object>(), pending_obj);\n+  if (nread <= 0) {\n+    free(buf.base);\n+    if (nread < 0)\n+      CallJSOnreadMethod(nread, Local<Object>());\n     return;\n   }\n \n-  if (nread == 0) {\n-    if (buf->base != nullptr)\n-      free(buf->base);\n-    return;\n-  }\n+  CHECK_LE(static_cast<size_t>(nread), buf.len);\n \n-  CHECK_LE(static_cast<size_t>(nread), buf->len);\n-  char* base = node::Realloc(buf->base, nread);\n+  Local<Object> pending_obj;\n \n   if (pending == UV_TCP) {\n-    pending_obj = AcceptHandle<TCPWrap, uv_tcp_t>(env, wrap);\n+    pending_obj = AcceptHandle<TCPWrap, uv_tcp_t>(env(), this);\n   } else if (pending == UV_NAMED_PIPE) {\n-    pending_obj = AcceptHandle<PipeWrap, uv_pipe_t>(env, wrap);\n+    pending_obj = AcceptHandle<PipeWrap, uv_pipe_t>(env(), this);\n   } else if (pending == UV_UDP) {\n-    pending_obj = AcceptHandle<UDPWrap, uv_udp_t>(env, wrap);\n+    pending_obj = AcceptHandle<UDPWrap, uv_udp_t>(env(), this);\n   } else {\n     CHECK_EQ(pending, UV_UNKNOWN_HANDLE);\n   }\n \n-  Local<Object> obj = Buffer::New(env, base, nread).ToLocalChecked();\n-  wrap->EmitData(nread, obj, pending_obj);\n+  Local<Object> obj = Buffer::New(env(), buf.base, nread).ToLocalChecked();\n+  CallJSOnreadMethod(nread, obj, pending_obj);\n }\n \n \n void LibuvStreamWrap::OnRead(uv_stream_t* handle,\n-                        ssize_t nread,\n-                        const uv_buf_t* buf) {\n+                             ssize_t nread,\n+                             const uv_buf_t* buf) {\n   LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(handle->data);\n   HandleScope scope(wrap->env()->isolate());\n   Context::Scope context_scope(wrap->env()->context());\n@@ -263,7 +247,7 @@ void LibuvStreamWrap::OnRead(uv_stream_t* handle,\n     }\n   }\n \n-  wrap->EmitRead(nread, buf, type);\n+  wrap->EmitRead(nread, *buf, type);\n }\n \n "
        },
        {
            "sha": "129006b1600c6c4dae69e2badaa59dbbb3a61ccd",
            "filename": "src/stream_wrap.h",
            "status": "modified",
            "additions": 13,
            "deletions": 9,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Fstream_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.h?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -33,7 +33,9 @@\n \n namespace node {\n \n-class LibuvStreamWrap : public HandleWrap, public StreamBase {\n+class LibuvStreamWrap : public HandleWrap,\n+                        public StreamListener,\n+                        public StreamBase {\n  public:\n   static void Initialize(v8::Local<v8::Object> target,\n                          v8::Local<v8::Value> unused,\n@@ -79,9 +81,6 @@ class LibuvStreamWrap : public HandleWrap, public StreamBase {\n                   uv_stream_t* stream,\n                   AsyncWrap::ProviderType provider);\n \n-  ~LibuvStreamWrap() {\n-  }\n-\n   AsyncWrap* GetAsyncWrap() override;\n \n   static void AddMethods(Environment* env,\n@@ -105,11 +104,16 @@ class LibuvStreamWrap : public HandleWrap, public StreamBase {\n   static void AfterUvShutdown(uv_shutdown_t* req, int status);\n \n   // Resource interface implementation\n-  static void OnAllocImpl(size_t size, uv_buf_t* buf, void* ctx);\n-  static void OnReadImpl(ssize_t nread,\n-                         const uv_buf_t* buf,\n-                         uv_handle_type pending,\n-                         void* ctx);\n+  void OnStreamRead(ssize_t nread,\n+                    const uv_buf_t& buf) override {\n+    CHECK(0 && \"must not be called\");\n+  }\n+  void OnStreamRead(ssize_t nread,\n+                    const uv_buf_t& buf,\n+                    uv_handle_type pending) override;\n+  void OnStreamAfterWrite(WriteWrap* w, int status) override {\n+    previous_listener_->OnStreamAfterWrite(w, status);\n+  }\n \n   void AfterWrite(WriteWrap* req_wrap, int status) override;\n "
        },
        {
            "sha": "a0a58fb1b5cc8d222cdde1338f8440fe3cd888d4",
            "filename": "src/tcp_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Ftcp_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Ftcp_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftcp_wrap.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -27,6 +27,7 @@\n #include \"node_buffer.h\"\n #include \"node_wrap.h\"\n #include \"connect_wrap.h\"\n+#include \"stream_base-inl.h\"\n #include \"stream_wrap.h\"\n #include \"util-inl.h\"\n "
        },
        {
            "sha": "971dbb857f77f56af2559f9896c1a9bec980fe65",
            "filename": "src/tls_wrap.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 90,
            "changes": 115,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Ftls_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Ftls_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -59,7 +59,6 @@ TLSWrap::TLSWrap(Environment* env,\n       SSLWrap<TLSWrap>(env, sc, kind),\n       StreamBase(env),\n       sc_(sc),\n-      stream_(stream),\n       enc_in_(nullptr),\n       enc_out_(nullptr),\n       write_size_(0),\n@@ -78,14 +77,7 @@ TLSWrap::TLSWrap(Environment* env,\n   SSL_CTX_sess_set_get_cb(sc_->ctx_, SSLWrap<TLSWrap>::GetSessionCallback);\n   SSL_CTX_sess_set_new_cb(sc_->ctx_, SSLWrap<TLSWrap>::NewSessionCallback);\n \n-  stream_->Consume();\n-  stream_->set_after_write_cb({ OnAfterWriteImpl, this });\n-  stream_->set_alloc_cb({ OnAllocImpl, this });\n-  stream_->set_read_cb({ OnReadImpl, this });\n-  stream_->set_destruct_cb({ OnDestructImpl, this });\n-\n-  set_alloc_cb({ OnAllocSelf, this });\n-  set_read_cb({ OnReadSelf, this });\n+  stream->PushStreamListener(this);\n \n   InitSSL();\n }\n@@ -100,19 +92,6 @@ TLSWrap::~TLSWrap() {\n #ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n   sni_context_.Reset();\n #endif  // SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n-\n-  // See test/parallel/test-tls-transport-destroy-after-own-gc.js:\n-  // If this TLSWrap is garbage collected, we cannot allow callbacks to be\n-  // called on this stream.\n-\n-  if (stream_ == nullptr)\n-    return;\n-  stream_->set_destruct_cb({ nullptr, nullptr });\n-  stream_->set_after_write_cb({ nullptr, nullptr });\n-  stream_->set_alloc_cb({ nullptr, nullptr });\n-  stream_->set_read_cb({ nullptr, nullptr });\n-  stream_->set_destruct_cb({ nullptr, nullptr });\n-  stream_->Unconsume();\n }\n \n \n@@ -208,15 +187,13 @@ void TLSWrap::Receive(const FunctionCallbackInfo<Value>& args) {\n   char* data = Buffer::Data(args[0]);\n   size_t len = Buffer::Length(args[0]);\n \n-  uv_buf_t buf;\n-\n   // Copy given buffer entirely or partiall if handle becomes closed\n   while (len > 0 && wrap->IsAlive() && !wrap->IsClosing()) {\n-    wrap->stream_->EmitAlloc(len, &buf);\n+    uv_buf_t buf = wrap->OnStreamAlloc(len);\n     size_t copy = buf.len > len ? len : buf.len;\n     memcpy(buf.base, data, copy);\n     buf.len = copy;\n-    wrap->stream_->EmitRead(buf.len, &buf);\n+    wrap->OnStreamRead(copy, buf);\n \n     data += copy;\n     len -= copy;\n@@ -307,7 +284,7 @@ void TLSWrap::EncOut() {\n           ->NewInstance(env()->context()).ToLocalChecked();\n   WriteWrap* write_req = WriteWrap::New(env(),\n                                         req_wrap_obj,\n-                                        stream_);\n+                                        static_cast<StreamBase*>(stream_));\n \n   uv_buf_t buf[arraysize(data)];\n   for (size_t i = 0; i < count; i++)\n@@ -324,7 +301,7 @@ void TLSWrap::EncOut() {\n }\n \n \n-void TLSWrap::EncOutAfterWrite(WriteWrap* req_wrap, int status) {\n+void TLSWrap::OnStreamAfterWrite(WriteWrap* req_wrap, int status) {\n   // We should not be getting here after `DestroySSL`, because all queued writes\n   // must be invoked with UV_ECANCELED\n   CHECK_NE(ssl_, nullptr);\n@@ -421,12 +398,11 @@ void TLSWrap::ClearOut() {\n     while (read > 0) {\n       int avail = read;\n \n-      uv_buf_t buf;\n-      EmitAlloc(avail, &buf);\n+      uv_buf_t buf = EmitAlloc(avail);\n       if (static_cast<int>(buf.len) < avail)\n         avail = buf.len;\n       memcpy(buf.base, current, avail);\n-      EmitRead(avail, &buf);\n+      EmitRead(avail, buf);\n \n       // Caveat emptor: OnRead() calls into JS land which can result in\n       // the SSL context object being destroyed.  We have to carefully\n@@ -442,7 +418,7 @@ void TLSWrap::ClearOut() {\n   int flags = SSL_get_shutdown(ssl_);\n   if (!eof_ && flags & SSL_RECEIVED_SHUTDOWN) {\n     eof_ = true;\n-    EmitRead(UV_EOF, nullptr);\n+    EmitRead(UV_EOF);\n   }\n \n   // We need to check whether an error occurred or the connection was\n@@ -524,22 +500,24 @@ AsyncWrap* TLSWrap::GetAsyncWrap() {\n \n \n bool TLSWrap::IsIPCPipe() {\n-  return stream_->IsIPCPipe();\n+  return static_cast<StreamBase*>(stream_)->IsIPCPipe();\n }\n \n \n int TLSWrap::GetFD() {\n-  return stream_->GetFD();\n+  return static_cast<StreamBase*>(stream_)->GetFD();\n }\n \n \n bool TLSWrap::IsAlive() {\n-  return ssl_ != nullptr && stream_ != nullptr && stream_->IsAlive();\n+  return ssl_ != nullptr &&\n+      stream_ != nullptr &&\n+      static_cast<StreamBase*>(stream_)->IsAlive();\n }\n \n \n bool TLSWrap::IsClosing() {\n-  return stream_->IsClosing();\n+  return static_cast<StreamBase*>(stream_)->IsClosing();\n }\n \n \n@@ -638,62 +616,16 @@ int TLSWrap::DoWrite(WriteWrap* w,\n }\n \n \n-void TLSWrap::OnAfterWriteImpl(WriteWrap* w, int status, void* ctx) {\n-  TLSWrap* wrap = static_cast<TLSWrap*>(ctx);\n-  wrap->EncOutAfterWrite(w, status);\n-}\n-\n-\n-void TLSWrap::OnAllocImpl(size_t suggested_size, uv_buf_t* buf, void* ctx) {\n-  TLSWrap* wrap = static_cast<TLSWrap*>(ctx);\n-\n-  if (wrap->ssl_ == nullptr) {\n-    *buf = uv_buf_init(nullptr, 0);\n-    return;\n-  }\n-\n-  size_t size = 0;\n-  buf->base = crypto::NodeBIO::FromBIO(wrap->enc_in_)->PeekWritable(&size);\n-  buf->len = size;\n-}\n-\n-\n-void TLSWrap::OnReadImpl(ssize_t nread,\n-                         const uv_buf_t* buf,\n-                         uv_handle_type pending,\n-                         void* ctx) {\n-  TLSWrap* wrap = static_cast<TLSWrap*>(ctx);\n-  wrap->DoRead(nread, buf, pending);\n-}\n-\n-\n-void TLSWrap::OnDestructImpl(void* ctx) {\n-  TLSWrap* wrap = static_cast<TLSWrap*>(ctx);\n-  wrap->clear_stream();\n-}\n-\n-\n-void TLSWrap::OnAllocSelf(size_t suggested_size, uv_buf_t* buf, void* ctx) {\n-  buf->base = node::Malloc(suggested_size);\n-  buf->len = suggested_size;\n-}\n-\n+uv_buf_t TLSWrap::OnStreamAlloc(size_t suggested_size) {\n+  CHECK_NE(ssl_, nullptr);\n \n-void TLSWrap::OnReadSelf(ssize_t nread,\n-                         const uv_buf_t* buf,\n-                         uv_handle_type pending,\n-                         void* ctx) {\n-  TLSWrap* wrap = static_cast<TLSWrap*>(ctx);\n-  Local<Object> buf_obj;\n-  if (buf != nullptr)\n-    buf_obj = Buffer::New(wrap->env(), buf->base, buf->len).ToLocalChecked();\n-  wrap->EmitData(nread, buf_obj, Local<Object>());\n+  size_t size = suggested_size;\n+  char* base = crypto::NodeBIO::FromBIO(enc_in_)->PeekWritable(&size);\n+  return uv_buf_init(base, size);\n }\n \n \n-void TLSWrap::DoRead(ssize_t nread,\n-                     const uv_buf_t* buf,\n-                     uv_handle_type pending) {\n+void TLSWrap::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n   if (nread < 0)  {\n     // Error should be emitted only after all data was read\n     ClearOut();\n@@ -705,13 +637,13 @@ void TLSWrap::DoRead(ssize_t nread,\n       eof_ = true;\n     }\n \n-    EmitRead(nread, nullptr);\n+    EmitRead(nread);\n     return;\n   }\n \n   // Only client connections can receive data\n   if (ssl_ == nullptr) {\n-    EmitRead(UV_EPROTO, nullptr);\n+    EmitRead(UV_EPROTO);\n     return;\n   }\n \n@@ -800,6 +732,9 @@ void TLSWrap::DestroySSL(const FunctionCallbackInfo<Value>& args) {\n \n   // Destroy the SSL structure and friends\n   wrap->SSLWrap<TLSWrap>::DestroySSL();\n+\n+  if (wrap->stream_ != nullptr)\n+    wrap->stream_->RemoveStreamListener(wrap);\n }\n \n "
        },
        {
            "sha": "a1f0b99e86beeca08587003f8bd8497ebbfa0ae2",
            "filename": "src/tls_wrap.h",
            "status": "modified",
            "additions": 5,
            "deletions": 19,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Ftls_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Ftls_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.h?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -48,7 +48,8 @@ class NodeBIO;\n \n class TLSWrap : public AsyncWrap,\n                 public crypto::SSLWrap<TLSWrap>,\n-                public StreamBase {\n+                public StreamBase,\n+                public StreamListener {\n  public:\n   ~TLSWrap() override;\n \n@@ -76,8 +77,6 @@ class TLSWrap : public AsyncWrap,\n \n   size_t self_size() const override { return sizeof(*this); }\n \n-  void clear_stream() { stream_ = nullptr; }\n-\n  protected:\n   static const int kClearOutChunkSize = 16384;\n \n@@ -98,7 +97,6 @@ class TLSWrap : public AsyncWrap,\n   static void SSLInfoCallback(const SSL* ssl_, int where, int ret);\n   void InitSSL();\n   void EncOut();\n-  void EncOutAfterWrite(WriteWrap* req_wrap, int status);\n   bool ClearIn();\n   void ClearOut();\n   bool InvokeQueued(int status, const char* error_str = nullptr);\n@@ -119,20 +117,9 @@ class TLSWrap : public AsyncWrap,\n   bool IsIPCPipe() override;\n \n   // Resource implementation\n-  static void OnAfterWriteImpl(WriteWrap* w, int status, void* ctx);\n-  static void OnAllocImpl(size_t size, uv_buf_t* buf, void* ctx);\n-  static void OnReadImpl(ssize_t nread,\n-                         const uv_buf_t* buf,\n-                         uv_handle_type pending,\n-                         void* ctx);\n-  static void OnAllocSelf(size_t size, uv_buf_t* buf, void* ctx);\n-  static void OnReadSelf(ssize_t nread,\n-                         const uv_buf_t* buf,\n-                         uv_handle_type pending,\n-                         void* ctx);\n-  static void OnDestructImpl(void* ctx);\n-\n-  void DoRead(ssize_t nread, const uv_buf_t* buf, uv_handle_type pending);\n+  void OnStreamAfterWrite(WriteWrap* w, int status) override;\n+  uv_buf_t OnStreamAlloc(size_t size) override;\n+  void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n \n   v8::Local<v8::Value> GetSSLError(int status, int* err, std::string* msg);\n \n@@ -154,7 +141,6 @@ class TLSWrap : public AsyncWrap,\n #endif  // SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n \n   crypto::SecureContext* sc_;\n-  StreamBase* stream_;\n   BIO* enc_in_;\n   BIO* enc_out_;\n   std::vector<uv_buf_t> pending_cleartext_input_;"
        },
        {
            "sha": "9977738afcbfd5a231a440e838529883fd9e8dac",
            "filename": "src/tty_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Ftty_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/src%2Ftty_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftty_wrap.cc?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -26,6 +26,7 @@\n #include \"node_buffer.h\"\n #include \"node_wrap.h\"\n #include \"req_wrap-inl.h\"\n+#include \"stream_base-inl.h\"\n #include \"stream_wrap.h\"\n #include \"util-inl.h\"\n "
        },
        {
            "sha": "6f1d4b4186b74fd72cae8c3f8568085a735955eb",
            "filename": "test/parallel/test-tls-socket-destroy.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/test%2Fparallel%2Ftest-tls-socket-destroy.js",
            "raw_url": "https://github.com/nodejs/node/raw/7c4b09b24bbe7d6a8cbad256f47b30a101a909ea/test%2Fparallel%2Ftest-tls-socket-destroy.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-socket-destroy.js?ref=7c4b09b24bbe7d6a8cbad256f47b30a101a909ea",
            "patch": "@@ -19,6 +19,7 @@ const server = net.createServer(common.mustCall((conn) => {\n   const socket = new tls.TLSSocket(conn, options);\n   socket.once('data', common.mustCall(() => {\n     socket._destroySSL();  // Should not crash.\n+    socket.destroy();\n     server.close();\n   }));\n }));"
        }
    ],
    "stats": {
        "total": 937,
        "additions": 463,
        "deletions": 474
    }
}