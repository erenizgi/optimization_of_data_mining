{
    "author": "targos",
    "message": "vm: move options checks from C++ to JS\n\nAlso introduces stronger type validations for options passed to vm\nfunctions.\n\nPR-URL: https://github.com/nodejs/node/pull/19398\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>",
    "sha": "34d988f122c206da692b5c39ec5342fec22b60ab",
    "files": [
        {
            "sha": "3712fa4f2b14504dae8850f796940b1a462e8640",
            "filename": "doc/api/vm.md",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/doc%2Fapi%2Fvm.md",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/doc%2Fapi%2Fvm.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fvm.md?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -618,6 +618,9 @@ console.log(globalVar);\n <!-- YAML\n added: v0.3.1\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/19398\n+    description: The `sandbox` option can no longer be a function.\n   - version: REPLACEME\n     pr-url: https://github.com/nodejs/node/pull/19016\n     description: The `codeGeneration` option is supported now."
        },
        {
            "sha": "828370f6eadd01d0adc33f4ec0ef718cb9751a10",
            "filename": "lib/internal/bootstrap/loaders.js",
            "status": "modified",
            "additions": 3,
            "deletions": 10,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Floaders.js?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -88,12 +88,7 @@\n     };\n   }\n \n-  // Minimal sandbox helper\n   const ContextifyScript = process.binding('contextify').ContextifyScript;\n-  function runInThisContext(code, options) {\n-    const script = new ContextifyScript(code, options);\n-    return script.runInThisContext();\n-  }\n \n   // Set up NativeModule\n   function NativeModule(id) {\n@@ -205,11 +200,9 @@\n     this.loading = true;\n \n     try {\n-      const fn = runInThisContext(source, {\n-        filename: this.filename,\n-        lineOffset: 0,\n-        displayErrors: true\n-      });\n+      const script = new ContextifyScript(source, this.filename);\n+      // Arguments: timeout, displayErrors, breakOnSigint\n+      const fn = script.runInThisContext(-1, true, false);\n       const requireFn = this.id.startsWith('internal/deps/') ?\n         NativeModule.requireForDeps :\n         NativeModule.require;"
        },
        {
            "sha": "a64ccfe3b2d553263922daeb7efadfd3e6a09a89",
            "filename": "lib/internal/vm/module.js",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/lib%2Finternal%2Fvm%2Fmodule.js",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/lib%2Finternal%2Fvm%2Fmodule.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fvm%2Fmodule.js?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -59,6 +59,10 @@ class Module {\n \n     let context;\n     if (options.context !== undefined) {\n+      if (typeof options.context !== 'object' || options.context === null) {\n+        throw new ERR_INVALID_ARG_TYPE('options.context', 'object',\n+                                       options.context);\n+      }\n       if (isContext(options.context)) {\n         context = options.context;\n       } else {"
        },
        {
            "sha": "5a5130d7c9c32828e43a27bd5f9b27ace7ccd235",
            "filename": "lib/vm.js",
            "status": "modified",
            "additions": 145,
            "deletions": 76,
            "changes": 221,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/lib%2Fvm.js",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/lib%2Fvm.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fvm.js?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -24,63 +24,109 @@\n const {\n   ContextifyScript,\n   kParsingContext,\n-\n   makeContext,\n   isContext: _isContext,\n } = process.binding('contextify');\n \n const {\n   ERR_INVALID_ARG_TYPE,\n-  ERR_MISSING_ARGS\n+  ERR_OUT_OF_RANGE\n } = require('internal/errors').codes;\n-\n-// The binding provides a few useful primitives:\n-// - Script(code, { filename = \"evalmachine.anonymous\",\n-//                  displayErrors = true } = {})\n-//   with methods:\n-//   - runInThisContext({ displayErrors = true } = {})\n-//   - runInContext(sandbox, { displayErrors = true, timeout = undefined } = {})\n-// - makeContext(sandbox)\n-// - isContext(sandbox)\n-// From this we build the entire documented API.\n+const { isUint8Array } = require('internal/util/types');\n \n class Script extends ContextifyScript {\n-  constructor(code, options) {\n+  constructor(code, options = {}) {\n+    code = `${code}`;\n+    if (typeof options === 'string') {\n+      options = { filename: options };\n+    }\n+    if (typeof options !== 'object' || options === null) {\n+      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n+    }\n+\n+    const {\n+      filename = 'evalmachine.<anonymous>',\n+      lineOffset = 0,\n+      columnOffset = 0,\n+      cachedData,\n+      produceCachedData = false,\n+      [kParsingContext]: parsingContext\n+    } = options;\n+\n+    if (typeof filename !== 'string') {\n+      throw new ERR_INVALID_ARG_TYPE('options.filename', 'string', filename);\n+    }\n+    validateInteger(lineOffset, 'options.lineOffset');\n+    validateInteger(columnOffset, 'options.columnOffset');\n+    if (cachedData !== undefined && !isUint8Array(cachedData)) {\n+      throw new ERR_INVALID_ARG_TYPE('options.cachedData',\n+                                     ['Buffer', 'Uint8Array'], cachedData);\n+    }\n+    if (typeof produceCachedData !== 'boolean') {\n+      throw new ERR_INVALID_ARG_TYPE('options.produceCachedData', 'boolean',\n+                                     produceCachedData);\n+    }\n+\n     // Calling `ReThrow()` on a native TryCatch does not generate a new\n     // abort-on-uncaught-exception check. A dummy try/catch in JS land\n     // protects against that.\n     try {\n-      super(code, options);\n+      super(code,\n+            filename,\n+            lineOffset,\n+            columnOffset,\n+            cachedData,\n+            produceCachedData,\n+            parsingContext);\n     } catch (e) {\n       throw e; /* node-do-not-add-exception-line */\n     }\n   }\n-}\n \n-const realRunInThisContext = Script.prototype.runInThisContext;\n-const realRunInContext = Script.prototype.runInContext;\n+  runInThisContext(options) {\n+    const { breakOnSigint, args } = getRunInContextArgs(options);\n+    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n+      return sigintHandlersWrap(super.runInThisContext, this, args);\n+    } else {\n+      return super.runInThisContext(...args);\n+    }\n+  }\n \n-Script.prototype.runInThisContext = function(options) {\n-  if (options && options.breakOnSigint && process.listenerCount('SIGINT') > 0) {\n-    return sigintHandlersWrap(realRunInThisContext, this, [options]);\n-  } else {\n-    return realRunInThisContext.call(this, options);\n+  runInContext(contextifiedSandbox, options) {\n+    validateContext(contextifiedSandbox);\n+    const { breakOnSigint, args } = getRunInContextArgs(options);\n+    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n+      return sigintHandlersWrap(super.runInContext, this,\n+                                [contextifiedSandbox, ...args]);\n+    } else {\n+      return super.runInContext(contextifiedSandbox, ...args);\n+    }\n   }\n-};\n \n-Script.prototype.runInContext = function(contextifiedSandbox, options) {\n-  if (options && options.breakOnSigint && process.listenerCount('SIGINT') > 0) {\n-    return sigintHandlersWrap(realRunInContext, this,\n-                              [contextifiedSandbox, options]);\n-  } else {\n-    return realRunInContext.call(this, contextifiedSandbox, options);\n+  runInNewContext(sandbox, options) {\n+    const context = createContext(sandbox, getContextOptions(options));\n+    return this.runInContext(context, options);\n   }\n-};\n+}\n \n-Script.prototype.runInNewContext = function(sandbox, options) {\n-  const context = createContext(sandbox, getContextOptions(options));\n-  return this.runInContext(context, options);\n-};\n+function validateContext(sandbox) {\n+  if (typeof sandbox !== 'object' || sandbox === null) {\n+    throw new ERR_INVALID_ARG_TYPE('contextifiedSandbox', 'Object', sandbox);\n+  }\n+  if (!_isContext(sandbox)) {\n+    throw new ERR_INVALID_ARG_TYPE('contextifiedSandbox', 'vm.Context',\n+                                   sandbox);\n+  }\n+}\n+\n+function validateInteger(prop, propName) {\n+  if (!Number.isInteger(prop)) {\n+    throw new ERR_INVALID_ARG_TYPE(propName, 'integer', prop);\n+  }\n+  if ((prop >> 0) !== prop) {\n+    throw new ERR_OUT_OF_RANGE(propName, '32-bit integer', prop);\n+  }\n+}\n \n function validateString(prop, propName) {\n   if (prop !== undefined && typeof prop !== 'string')\n@@ -97,6 +143,39 @@ function validateObject(prop, propName) {\n     throw new ERR_INVALID_ARG_TYPE(propName, 'Object', prop);\n }\n \n+function getRunInContextArgs(options = {}) {\n+  if (typeof options !== 'object' || options === null) {\n+    throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n+  }\n+\n+  let timeout = options.timeout;\n+  if (timeout === undefined) {\n+    timeout = -1;\n+  } else if (!Number.isInteger(timeout) || timeout <= 0) {\n+    throw new ERR_INVALID_ARG_TYPE('options.timeout', 'a positive integer',\n+                                   timeout);\n+  }\n+\n+  const {\n+    displayErrors = true,\n+    breakOnSigint = false\n+  } = options;\n+\n+  if (typeof displayErrors !== 'boolean') {\n+    throw new ERR_INVALID_ARG_TYPE('options.displayErrors', 'boolean',\n+                                   displayErrors);\n+  }\n+  if (typeof breakOnSigint !== 'boolean') {\n+    throw new ERR_INVALID_ARG_TYPE('options.breakOnSigint', 'boolean',\n+                                   breakOnSigint);\n+  }\n+\n+  return {\n+    breakOnSigint,\n+    args: [timeout, displayErrors, breakOnSigint]\n+  };\n+}\n+\n function getContextOptions(options) {\n   if (options) {\n     validateObject(options.contextCodeGeneration,\n@@ -123,57 +202,43 @@ function getContextOptions(options) {\n }\n \n function isContext(sandbox) {\n-  if (arguments.length < 1) {\n-    throw new ERR_MISSING_ARGS('sandbox');\n+  if (typeof sandbox !== 'object' || sandbox === null) {\n+    throw new ERR_INVALID_ARG_TYPE('sandbox', 'Object', sandbox);\n   }\n-\n-  if (typeof sandbox !== 'object' && typeof sandbox !== 'function' ||\n-      sandbox === null) {\n-    throw new ERR_INVALID_ARG_TYPE('sandbox', 'object', sandbox);\n-  }\n-\n   return _isContext(sandbox);\n }\n \n let defaultContextNameIndex = 1;\n-function createContext(sandbox, options) {\n-  if (sandbox === undefined) {\n-    sandbox = {};\n-  } else if (isContext(sandbox)) {\n+function createContext(sandbox = {}, options = {}) {\n+  if (isContext(sandbox)) {\n     return sandbox;\n   }\n \n-  if (options !== undefined) {\n-    if (typeof options !== 'object' || options === null) {\n-      throw new ERR_INVALID_ARG_TYPE('options', 'object', options);\n-    }\n-    validateObject(options.codeGeneration, 'options.codeGeneration');\n-    options = {\n-      name: options.name,\n-      origin: options.origin,\n-      codeGeneration: typeof options.codeGeneration === 'object' ? {\n-        strings: options.codeGeneration.strings,\n-        wasm: options.codeGeneration.wasm,\n-      } : undefined,\n-    };\n-    if (options.codeGeneration !== undefined) {\n-      validateBool(options.codeGeneration.strings,\n-                   'options.codeGeneration.strings');\n-      validateBool(options.codeGeneration.wasm,\n-                   'options.codeGeneration.wasm');\n-    }\n-    if (options.name === undefined) {\n-      options.name = `VM Context ${defaultContextNameIndex++}`;\n-    } else if (typeof options.name !== 'string') {\n-      throw new ERR_INVALID_ARG_TYPE('options.name', 'string', options.name);\n-    }\n-    validateString(options.origin, 'options.origin');\n-  } else {\n-    options = {\n-      name: `VM Context ${defaultContextNameIndex++}`\n-    };\n+  if (typeof options !== 'object' || options === null) {\n+    throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n   }\n-  makeContext(sandbox, options);\n+\n+  const {\n+    name = `VM Context ${defaultContextNameIndex++}`,\n+    origin,\n+    codeGeneration\n+  } = options;\n+\n+  if (typeof name !== 'string') {\n+    throw new ERR_INVALID_ARG_TYPE('options.name', 'string', options.name);\n+  }\n+  validateString(origin, 'options.origin');\n+  validateObject(codeGeneration, 'options.codeGeneration');\n+\n+  let strings = true;\n+  let wasm = true;\n+  if (codeGeneration !== undefined) {\n+    ({ strings = true, wasm = true } = codeGeneration);\n+    validateBool(strings, 'options.codeGeneration.strings');\n+    validateBool(wasm, 'options.codeGeneration.wasm');\n+  }\n+\n+  makeContext(sandbox, name, origin, strings, wasm);\n   return sandbox;\n }\n \n@@ -200,6 +265,7 @@ function sigintHandlersWrap(fn, thisArg, argsArray) {\n }\n \n function runInContext(code, contextifiedSandbox, options) {\n+  validateContext(contextifiedSandbox);\n   if (typeof options === 'string') {\n     options = {\n       filename: options,\n@@ -226,6 +292,9 @@ function runInNewContext(code, sandbox, options) {\n }\n \n function runInThisContext(code, options) {\n+  if (typeof options === 'string') {\n+    options = { filename: options };\n+  }\n   return createScript(code, options).runInThisContext(options);\n }\n "
        },
        {
            "sha": "e6a4e1dc05fe77bb58905583fc5d3e8ec9834c37",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -239,7 +239,6 @@ struct PackageConfig {\n   V(port_string, \"port\")                                                      \\\n   V(preference_string, \"preference\")                                          \\\n   V(priority_string, \"priority\")                                              \\\n-  V(produce_cached_data_string, \"produceCachedData\")                          \\\n   V(promise_string, \"promise\")                                                \\\n   V(pubkey_string, \"pubkey\")                                                  \\\n   V(query_string, \"query\")                                                    \\"
        },
        {
            "sha": "c71e9b578968364a093f6a8135283c0a634102c6",
            "filename": "src/node_contextify.cc",
            "status": "modified",
            "additions": 119,
            "deletions": 243,
            "changes": 362,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/src%2Fnode_contextify.cc",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/src%2Fnode_contextify.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.cc?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -40,6 +40,7 @@ using v8::FunctionTemplate;\n using v8::HandleScope;\n using v8::IndexedPropertyHandlerConfiguration;\n using v8::Integer;\n+using v8::Isolate;\n using v8::Just;\n using v8::Local;\n using v8::Maybe;\n@@ -96,8 +97,8 @@ Local<Name> Uint32ToName(Local<Context> context, uint32_t index) {\n \n ContextifyContext::ContextifyContext(\n     Environment* env,\n-    Local<Object> sandbox_obj, Local<Object> options_obj) : env_(env) {\n-  Local<Context> v8_context = CreateV8Context(env, sandbox_obj, options_obj);\n+    Local<Object> sandbox_obj, const ContextOptions& options) : env_(env) {\n+  Local<Context> v8_context = CreateV8Context(env, sandbox_obj, options);\n   context_.Reset(env->isolate(), v8_context);\n \n   // Allocation failure or maximum call stack size reached\n@@ -129,7 +130,7 @@ Local<Value> ContextifyContext::CreateDataWrapper(Environment* env) {\n Local<Context> ContextifyContext::CreateV8Context(\n     Environment* env,\n     Local<Object> sandbox_obj,\n-    Local<Object> options_obj) {\n+    const ContextOptions& options) {\n   EscapableHandleScope scope(env->isolate());\n   Local<FunctionTemplate> function_template =\n       FunctionTemplate::New(env->isolate());\n@@ -179,45 +180,15 @@ Local<Context> ContextifyContext::CreateV8Context(\n                           env->contextify_global_private_symbol(),\n                           ctx->Global());\n \n-  Local<Value> name =\n-      options_obj->Get(env->context(), env->name_string())\n-          .ToLocalChecked();\n-  CHECK(name->IsString());\n-  Utf8Value name_val(env->isolate(), name);\n-\n-  Local<Value> codegen = options_obj->Get(env->context(),\n-      FIXED_ONE_BYTE_STRING(env->isolate(), \"codeGeneration\"))\n-          .ToLocalChecked();\n-\n-  if (!codegen->IsUndefined()) {\n-    CHECK(codegen->IsObject());\n-    Local<Object> codegen_obj = codegen.As<Object>();\n-\n-    Local<Value> allow_code_gen_from_strings =\n-      codegen_obj->Get(env->context(),\n-          FIXED_ONE_BYTE_STRING(env->isolate(), \"strings\"))\n-      .ToLocalChecked();\n-    ctx->AllowCodeGenerationFromStrings(\n-        allow_code_gen_from_strings->IsUndefined() ||\n-            allow_code_gen_from_strings->IsTrue());\n-\n-    Local<Value> allow_wasm_code_gen = codegen_obj->Get(env->context(),\n-        FIXED_ONE_BYTE_STRING(env->isolate(), \"wasm\"))\n-      .ToLocalChecked();\n-    ctx->SetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration,\n-        Boolean::New(env->isolate(), allow_wasm_code_gen->IsUndefined() ||\n-            allow_wasm_code_gen->IsTrue()));\n-  }\n+  Utf8Value name_val(env->isolate(), options.name);\n+  ctx->AllowCodeGenerationFromStrings(options.allow_code_gen_strings->IsTrue());\n+  ctx->SetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration,\n+                       options.allow_code_gen_wasm);\n \n   ContextInfo info(*name_val);\n \n-  Local<Value> origin =\n-      options_obj->Get(env->context(),\n-                       FIXED_ONE_BYTE_STRING(env->isolate(), \"origin\"))\n-          .ToLocalChecked();\n-  if (!origin->IsUndefined()) {\n-    CHECK(origin->IsString());\n-    Utf8Value origin_val(env->isolate(), origin);\n+  if (!options.origin.IsEmpty()) {\n+    Utf8Value origin_val(env->isolate(), options.origin);\n     info.origin = *origin_val;\n   }\n \n@@ -238,12 +209,12 @@ void ContextifyContext::Init(Environment* env, Local<Object> target) {\n }\n \n \n+// makeContext(sandbox, name, origin, strings, wasm);\n void ContextifyContext::MakeContext(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n-  if (!args[0]->IsObject()) {\n-    return env->ThrowTypeError(\"sandbox argument must be an object.\");\n-  }\n+  CHECK_EQ(args.Length(), 5);\n+  CHECK(args[0]->IsObject());\n   Local<Object> sandbox = args[0].As<Object>();\n \n   // Don't allow contextifying a sandbox multiple times.\n@@ -252,8 +223,21 @@ void ContextifyContext::MakeContext(const FunctionCallbackInfo<Value>& args) {\n           env->context(),\n           env->contextify_context_private_symbol()).FromJust());\n \n-  Local<Object> options = args[1].As<Object>();\n-  CHECK(options->IsObject());\n+  ContextOptions options;\n+\n+  CHECK(args[1]->IsString());\n+  options.name = args[1].As<String>();\n+\n+  CHECK(args[2]->IsString() || args[2]->IsUndefined());\n+  if (args[2]->IsString()) {\n+    options.origin = args[2].As<String>();\n+  }\n+\n+  CHECK(args[3]->IsBoolean());\n+  options.allow_code_gen_strings = args[3].As<Boolean>();\n+\n+  CHECK(args[4]->IsBoolean());\n+  options.allow_code_gen_wasm = args[4].As<Boolean>();\n \n   TryCatch try_catch(env->isolate());\n   ContextifyContext* context = new ContextifyContext(env, sandbox, options);\n@@ -277,7 +261,6 @@ void ContextifyContext::IsContext(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n   CHECK(args[0]->IsObject());\n-\n   Local<Object> sandbox = args[0].As<Object>();\n \n   Maybe<bool> result =\n@@ -729,101 +712,6 @@ MaybeLocal<Context> GetContextArg(Environment* env,\n   return context;\n }\n \n-namespace {\n-\n-Maybe<bool> GetDisplayErrorsArg(Environment* env,\n-                                Local<Value> options) {\n-  if (options->IsUndefined() || options->IsString()) {\n-    return Just(true);\n-  }\n-  if (!options->IsObject()) {\n-    env->ThrowTypeError(\"options must be an object\");\n-    return Nothing<bool>();\n-  }\n-\n-  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"displayErrors\");\n-  MaybeLocal<Value> maybe_value =\n-      options.As<Object>()->Get(env->context(), key);\n-  if (maybe_value.IsEmpty())\n-    return Nothing<bool>();\n-\n-  Local<Value> value = maybe_value.ToLocalChecked();\n-  if (value->IsUndefined())\n-    return Just(true);\n-\n-  return value->BooleanValue(env->context());\n-}\n-\n-MaybeLocal<String> GetFilenameArg(Environment* env,\n-                                  Local<Value> options) {\n-  Local<String> defaultFilename =\n-      FIXED_ONE_BYTE_STRING(env->isolate(), \"evalmachine.<anonymous>\");\n-\n-  if (options->IsUndefined()) {\n-    return defaultFilename;\n-  }\n-  if (options->IsString()) {\n-    return options.As<String>();\n-  }\n-  if (!options->IsObject()) {\n-    env->ThrowTypeError(\"options must be an object\");\n-    return Local<String>();\n-  }\n-\n-  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"filename\");\n-  MaybeLocal<Value> maybe_value =\n-      options.As<Object>()->Get(env->context(), key);\n-  if (maybe_value.IsEmpty())\n-    return MaybeLocal<String>();\n-\n-  Local<Value> value = maybe_value.ToLocalChecked();\n-  if (value->IsUndefined())\n-    return defaultFilename;\n-  return value->ToString(env->context());\n-}\n-\n-MaybeLocal<Uint8Array> GetCachedData(Environment* env,\n-                                     Local<Value> options) {\n-  if (!options->IsObject()) {\n-    return MaybeLocal<Uint8Array>();\n-  }\n-\n-  MaybeLocal<Value> maybe_value =\n-      options.As<Object>()->Get(env->context(), env->cached_data_string());\n-  if (maybe_value.IsEmpty())\n-    return MaybeLocal<Uint8Array>();\n-\n-  Local<Value> value = maybe_value.ToLocalChecked();\n-  if (value->IsUndefined()) {\n-    return MaybeLocal<Uint8Array>();\n-  }\n-\n-  if (!value->IsUint8Array()) {\n-    env->ThrowTypeError(\"options.cachedData must be a Buffer instance\");\n-    return MaybeLocal<Uint8Array>();\n-  }\n-\n-  return value.As<Uint8Array>();\n-}\n-\n-Maybe<bool> GetProduceCachedData(Environment* env,\n-                                 Local<Value> options) {\n-  if (!options->IsObject()) {\n-    return Just(false);\n-  }\n-\n-  MaybeLocal<Value> maybe_value =\n-      options.As<Object>()->Get(env->context(),\n-                                env->produce_cached_data_string());\n-  if (maybe_value.IsEmpty())\n-    return Nothing<bool>();\n-\n-  Local<Value> value = maybe_value.ToLocalChecked();\n-  return Just(value->IsTrue());\n-}\n-\n-}  // anonymous namespace\n-\n class ContextifyScript : public BaseObject {\n  private:\n   Persistent<UnboundScript> script_;\n@@ -855,59 +743,80 @@ class ContextifyScript : public BaseObject {\n   }\n \n \n-  // args: code, [options]\n   static void New(const FunctionCallbackInfo<Value>& args) {\n     Environment* env = Environment::GetCurrent(args);\n-\n-    if (!args.IsConstructCall()) {\n-      return env->ThrowError(\"Must call vm.Script as a constructor.\");\n+    Isolate* isolate = env->isolate();\n+    Local<Context> context = env->context();\n+\n+    CHECK(args.IsConstructCall());\n+\n+    const int argc = args.Length();\n+    CHECK_GE(argc, 2);\n+\n+    CHECK(args[0]->IsString());\n+    Local<String> code = args[0].As<String>();\n+\n+    CHECK(args[1]->IsString());\n+    Local<String> filename = args[1].As<String>();\n+\n+    Local<Integer> line_offset;\n+    Local<Integer> column_offset;\n+    Local<Uint8Array> cached_data_buf;\n+    bool produce_cached_data = false;\n+    Local<Context> parsing_context = context;\n+\n+    if (argc > 2) {\n+      // new ContextifyScript(code, filename, lineOffset, columnOffset\n+      //                      cachedData, produceCachedData, parsingContext)\n+      CHECK_EQ(argc, 7);\n+      CHECK(args[2]->IsNumber());\n+      line_offset = args[2].As<Integer>();\n+      CHECK(args[3]->IsNumber());\n+      column_offset = args[3].As<Integer>();\n+      if (!args[4]->IsUndefined()) {\n+        CHECK(args[4]->IsUint8Array());\n+        cached_data_buf = args[4].As<Uint8Array>();\n+      }\n+      CHECK(args[5]->IsBoolean());\n+      produce_cached_data = args[5]->IsTrue();\n+      if (!args[6]->IsUndefined()) {\n+        CHECK(args[6]->IsObject());\n+        ContextifyContext* sandbox =\n+            ContextifyContext::ContextFromContextifiedSandbox(\n+                env, args[6].As<Object>());\n+        CHECK_NE(sandbox, nullptr);\n+        parsing_context = sandbox->context();\n+      }\n+    } else {\n+      line_offset = Integer::New(isolate, 0);\n+      column_offset = Integer::New(isolate, 0);\n     }\n \n     ContextifyScript* contextify_script =\n         new ContextifyScript(env, args.This());\n \n-    TryCatch try_catch(env->isolate());\n-    Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n-    Local<String> code =\n-        args[0]->ToString(env->context()).FromMaybe(Local<String>());\n-\n-    Local<Value> options = args[1];\n-    MaybeLocal<String> filename = GetFilenameArg(env, options);\n-    MaybeLocal<Integer> lineOffset = GetLineOffsetArg(env, options);\n-    MaybeLocal<Integer> columnOffset = GetColumnOffsetArg(env, options);\n-    MaybeLocal<Uint8Array> cached_data_buf = GetCachedData(env, options);\n-    Maybe<bool> maybe_produce_cached_data = GetProduceCachedData(env, options);\n-    MaybeLocal<Context> maybe_context = GetContextArg(env, options);\n-    if (try_catch.HasCaught()) {\n-      no_abort_scope.Close();\n-      try_catch.ReThrow();\n-      return;\n-    }\n-\n-    bool produce_cached_data = maybe_produce_cached_data.ToChecked();\n-\n     ScriptCompiler::CachedData* cached_data = nullptr;\n-    Local<Uint8Array> ui8;\n-    if (cached_data_buf.ToLocal(&ui8)) {\n-      ArrayBuffer::Contents contents = ui8->Buffer()->GetContents();\n+    if (!cached_data_buf.IsEmpty()) {\n+      ArrayBuffer::Contents contents = cached_data_buf->Buffer()->GetContents();\n+      uint8_t* data = static_cast<uint8_t*>(contents.Data());\n       cached_data = new ScriptCompiler::CachedData(\n-          static_cast<uint8_t*>(contents.Data()) + ui8->ByteOffset(),\n-          ui8->ByteLength());\n+          data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());\n     }\n \n-    ScriptOrigin origin(filename.ToLocalChecked(), lineOffset.ToLocalChecked(),\n-                        columnOffset.ToLocalChecked());\n+    ScriptOrigin origin(filename, line_offset, column_offset);\n     ScriptCompiler::Source source(code, origin, cached_data);\n     ScriptCompiler::CompileOptions compile_options =\n         ScriptCompiler::kNoCompileOptions;\n \n     if (source.GetCachedData() != nullptr)\n       compile_options = ScriptCompiler::kConsumeCodeCache;\n \n-    Context::Scope scope(maybe_context.FromMaybe(env->context()));\n+    TryCatch try_catch(isolate);\n+    Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n+    Context::Scope scope(parsing_context);\n \n     MaybeLocal<UnboundScript> v8_script = ScriptCompiler::CompileUnboundScript(\n-        env->isolate(),\n+        isolate,\n         &source,\n         compile_options);\n \n@@ -917,13 +826,12 @@ class ContextifyScript : public BaseObject {\n       try_catch.ReThrow();\n       return;\n     }\n-    contextify_script->script_.Reset(env->isolate(),\n-                                     v8_script.ToLocalChecked());\n+    contextify_script->script_.Reset(isolate, v8_script.ToLocalChecked());\n \n     if (compile_options == ScriptCompiler::kConsumeCodeCache) {\n       args.This()->Set(\n           env->cached_data_rejected_string(),\n-          Boolean::New(env->isolate(), source.GetCachedData()->rejected));\n+          Boolean::New(isolate, source.GetCachedData()->rejected));\n     } else if (produce_cached_data) {\n       const ScriptCompiler::CachedData* cached_data =\n         ScriptCompiler::CreateCodeCache(v8_script.ToLocalChecked(), code);\n@@ -937,7 +845,7 @@ class ContextifyScript : public BaseObject {\n       }\n       args.This()->Set(\n           env->cached_data_produced_string(),\n-          Boolean::New(env->isolate(), cached_data_produced));\n+          Boolean::New(isolate, cached_data_produced));\n     }\n   }\n \n@@ -948,86 +856,55 @@ class ContextifyScript : public BaseObject {\n   }\n \n \n-  // args: [options]\n   static void RunInThisContext(const FunctionCallbackInfo<Value>& args) {\n     Environment* env = Environment::GetCurrent(args);\n \n-    // Assemble arguments\n-    TryCatch try_catch(args.GetIsolate());\n-    Maybe<int64_t> maybe_timeout = GetTimeoutArg(env, args[0]);\n-    Maybe<bool> maybe_display_errors = GetDisplayErrorsArg(env, args[0]);\n-    Maybe<bool> maybe_break_on_sigint = GetBreakOnSigintArg(env, args[0]);\n-    if (try_catch.HasCaught()) {\n-      try_catch.ReThrow();\n-      return;\n-    }\n+    CHECK_EQ(args.Length(), 3);\n+\n+    CHECK(args[0]->IsNumber());\n+    int64_t timeout = args[0]->IntegerValue(env->context()).FromJust();\n+\n+    CHECK(args[1]->IsBoolean());\n+    bool display_errors = args[1]->IsTrue();\n \n-    int64_t timeout = maybe_timeout.ToChecked();\n-    bool display_errors = maybe_display_errors.ToChecked();\n-    bool break_on_sigint = maybe_break_on_sigint.ToChecked();\n+    CHECK(args[2]->IsBoolean());\n+    bool break_on_sigint = args[2]->IsTrue();\n \n     // Do the eval within this context\n-    EvalMachine(env, timeout, display_errors, break_on_sigint, args,\n-                &try_catch);\n+    EvalMachine(env, timeout, display_errors, break_on_sigint, args);\n   }\n \n-  // args: sandbox, [options]\n   static void RunInContext(const FunctionCallbackInfo<Value>& args) {\n     Environment* env = Environment::GetCurrent(args);\n \n-    int64_t timeout;\n-    bool display_errors;\n-    bool break_on_sigint;\n-\n-    // Assemble arguments\n-    if (!args[0]->IsObject()) {\n-      return env->ThrowTypeError(\n-          \"contextifiedSandbox argument must be an object.\");\n-    }\n+    CHECK_EQ(args.Length(), 4);\n \n+    CHECK(args[0]->IsObject());\n     Local<Object> sandbox = args[0].As<Object>();\n-    {\n-      TryCatch try_catch(env->isolate());\n-      Maybe<int64_t> maybe_timeout = GetTimeoutArg(env, args[1]);\n-      Maybe<bool> maybe_display_errors = GetDisplayErrorsArg(env, args[1]);\n-      Maybe<bool> maybe_break_on_sigint = GetBreakOnSigintArg(env, args[1]);\n-      if (try_catch.HasCaught()) {\n-        try_catch.ReThrow();\n-        return;\n-      }\n-\n-      timeout = maybe_timeout.ToChecked();\n-      display_errors = maybe_display_errors.ToChecked();\n-      break_on_sigint = maybe_break_on_sigint.ToChecked();\n-    }\n-\n     // Get the context from the sandbox\n     ContextifyContext* contextify_context =\n         ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);\n-    if (contextify_context == nullptr) {\n-      return env->ThrowTypeError(\n-          \"sandbox argument must have been converted to a context.\");\n-    }\n+    CHECK_NE(contextify_context, nullptr);\n \n     if (contextify_context->context().IsEmpty())\n       return;\n \n-    {\n-      TryCatch try_catch(env->isolate());\n-      // Do the eval within the context\n-      Context::Scope context_scope(contextify_context->context());\n-      EvalMachine(contextify_context->env(),\n-                  timeout,\n-                  display_errors,\n-                  break_on_sigint,\n-                  args,\n-                  &try_catch);\n-\n-      if (try_catch.HasCaught()) {\n-        try_catch.ReThrow();\n-        return;\n-      }\n-    }\n+    CHECK(args[1]->IsNumber());\n+    int64_t timeout = args[1]->IntegerValue(env->context()).FromJust();\n+\n+    CHECK(args[2]->IsBoolean());\n+    bool display_errors = args[2]->IsTrue();\n+\n+    CHECK(args[3]->IsBoolean());\n+    bool break_on_sigint = args[3]->IsTrue();\n+\n+    // Do the eval within the context\n+    Context::Scope context_scope(contextify_context->context());\n+    EvalMachine(contextify_context->env(),\n+                timeout,\n+                display_errors,\n+                break_on_sigint,\n+                args);\n   }\n \n   static void DecorateErrorStack(Environment* env, const TryCatch& try_catch) {\n@@ -1072,14 +949,13 @@ class ContextifyScript : public BaseObject {\n                           const int64_t timeout,\n                           const bool display_errors,\n                           const bool break_on_sigint,\n-                          const FunctionCallbackInfo<Value>& args,\n-                          TryCatch* try_catch) {\n+                          const FunctionCallbackInfo<Value>& args) {\n     if (!ContextifyScript::InstanceOf(env, args.Holder())) {\n       env->ThrowTypeError(\n           \"Script methods can only be called on script instances.\");\n       return false;\n     }\n-\n+    TryCatch try_catch(env->isolate());\n     ContextifyScript* wrapped_script;\n     ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder(), false);\n     Local<UnboundScript> unbound_script =\n@@ -1115,18 +991,18 @@ class ContextifyScript : public BaseObject {\n       env->isolate()->CancelTerminateExecution();\n     }\n \n-    if (try_catch->HasCaught()) {\n+    if (try_catch.HasCaught()) {\n       if (!timed_out && !received_signal && display_errors) {\n         // We should decorate non-termination exceptions\n-        DecorateErrorStack(env, *try_catch);\n+        DecorateErrorStack(env, try_catch);\n       }\n \n       // If there was an exception thrown during script execution, re-throw it.\n       // If one of the above checks threw, re-throw the exception instead of\n       // letting try_catch catch it.\n       // If execution has been terminated, but not by one of the watchdogs from\n       // this invocation, this will re-throw a `null` value.\n-      try_catch->ReThrow();\n+      try_catch.ReThrow();\n \n       return false;\n     }"
        },
        {
            "sha": "1075bc5c6865a908d90d7eb0e677756d7918d420",
            "filename": "src/node_contextify.h",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/src%2Fnode_contextify.h",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/src%2Fnode_contextify.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.h?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -9,6 +9,13 @@\n namespace node {\n namespace contextify {\n \n+struct ContextOptions {\n+  v8::Local<v8::String> name;\n+  v8::Local<v8::String> origin;\n+  v8::Local<v8::Boolean> allow_code_gen_strings;\n+  v8::Local<v8::Boolean> allow_code_gen_wasm;\n+};\n+\n class ContextifyContext {\n  protected:\n   Environment* const env_;\n@@ -17,11 +24,11 @@ class ContextifyContext {\n  public:\n   ContextifyContext(Environment* env,\n                     v8::Local<v8::Object> sandbox_obj,\n-                    v8::Local<v8::Object> options_obj);\n+                    const ContextOptions& options);\n \n   v8::Local<v8::Value> CreateDataWrapper(Environment* env);\n   v8::Local<v8::Context> CreateV8Context(Environment* env,\n-      v8::Local<v8::Object> sandbox_obj, v8::Local<v8::Object> options_obj);\n+      v8::Local<v8::Object> sandbox_obj, const ContextOptions& options);\n   static void Init(Environment* env, v8::Local<v8::Object> target);\n \n   static bool AllowWasmCodeGeneration("
        },
        {
            "sha": "2dfc1e9cb72ed9508c26c5a73b47819f0297e4b5",
            "filename": "test/parallel/test-vm-basic.js",
            "status": "modified",
            "additions": 68,
            "deletions": 43,
            "changes": 111,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-basic.js",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-basic.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-basic.js?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -24,60 +24,85 @@ const common = require('../common');\n const assert = require('assert');\n const vm = require('vm');\n \n-// Test 1: vm.runInNewContext\n-const sandbox = {};\n-let result = vm.runInNewContext(\n-  'foo = \"bar\"; this.typeofProcess = typeof process; typeof Object;',\n-  sandbox\n-);\n-assert.deepStrictEqual(sandbox, {\n-  foo: 'bar',\n-  typeofProcess: 'undefined',\n-});\n-assert.strictEqual(result, 'function');\n+// vm.runInNewContext\n+{\n+  const sandbox = {};\n+  const result = vm.runInNewContext(\n+    'foo = \"bar\"; this.typeofProcess = typeof process; typeof Object;',\n+    sandbox\n+  );\n+  assert.deepStrictEqual(sandbox, {\n+    foo: 'bar',\n+    typeofProcess: 'undefined',\n+  });\n+  assert.strictEqual(result, 'function');\n+}\n \n-// Test 2: vm.runInContext\n-const sandbox2 = { foo: 'bar' };\n-const context = vm.createContext(sandbox2);\n-result = vm.runInContext(\n-  'baz = foo; this.typeofProcess = typeof process; typeof Object;',\n-  context\n-);\n-assert.deepStrictEqual(sandbox2, {\n-  foo: 'bar',\n-  baz: 'bar',\n-  typeofProcess: 'undefined'\n-});\n-assert.strictEqual(result, 'function');\n+// vm.runInContext\n+{\n+  const sandbox = { foo: 'bar' };\n+  const context = vm.createContext(sandbox);\n+  const result = vm.runInContext(\n+    'baz = foo; this.typeofProcess = typeof process; typeof Object;',\n+    context\n+  );\n+  assert.deepStrictEqual(sandbox, {\n+    foo: 'bar',\n+    baz: 'bar',\n+    typeofProcess: 'undefined'\n+  });\n+  assert.strictEqual(result, 'function');\n+}\n+\n+// vm.runInThisContext\n+{\n+  const result = vm.runInThisContext(\n+    'vmResult = \"foo\"; Object.prototype.toString.call(process);'\n+  );\n+  assert.strictEqual(global.vmResult, 'foo');\n+  assert.strictEqual(result, '[object process]');\n+  delete global.vmResult;\n+}\n+\n+// vm.runInNewContext\n+{\n+  const result = vm.runInNewContext(\n+    'vmResult = \"foo\"; typeof process;'\n+  );\n+  assert.strictEqual(global.vmResult, undefined);\n+  assert.strictEqual(result, 'undefined');\n+}\n+\n+// vm.createContext\n+{\n+  const sandbox = {};\n+  const context = vm.createContext(sandbox);\n+  assert.strictEqual(sandbox, context);\n+}\n \n-// Test 3: vm.runInThisContext\n-result = vm.runInThisContext(\n-  'vmResult = \"foo\"; Object.prototype.toString.call(process);'\n-);\n-assert.strictEqual(global.vmResult, 'foo');\n-assert.strictEqual(result, '[object process]');\n-delete global.vmResult;\n+// Run script with filename\n+{\n+  const script = 'throw new Error(\"boom\")';\n+  const filename = 'test-boom-error';\n+  const context = vm.createContext();\n \n-// Test 4: vm.runInNewContext\n-result = vm.runInNewContext(\n-  'vmResult = \"foo\"; typeof process;'\n-);\n-assert.strictEqual(global.vmResult, undefined);\n-assert.strictEqual(result, 'undefined');\n+  function checkErr(err) {\n+    return err.stack.startsWith('test-boom-error:1');\n+  }\n \n-// Test 5: vm.createContext\n-const sandbox3 = {};\n-const context2 = vm.createContext(sandbox3);\n-assert.strictEqual(sandbox3, context2);\n+  assert.throws(() => vm.runInContext(script, context, filename), checkErr);\n+  assert.throws(() => vm.runInNewContext(script, context, filename), checkErr);\n+  assert.throws(() => vm.runInThisContext(script, filename), checkErr);\n+}\n \n-// Test 6: invalid arguments\n+// Invalid arguments\n [null, 'string'].forEach((input) => {\n   common.expectsError(() => {\n     vm.createContext({}, input);\n   }, {\n     code: 'ERR_INVALID_ARG_TYPE',\n     type: TypeError,\n-    message: 'The \"options\" argument must be of type object. ' +\n+    message: 'The \"options\" argument must be of type Object. ' +\n              `Received type ${typeof input}`\n   });\n });"
        },
        {
            "sha": "e3947d1ae6c16681cbf2ea521740f3dff3174e20",
            "filename": "test/parallel/test-vm-cached-data.js",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-cached-data.js",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-cached-data.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-cached-data.js?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -1,5 +1,5 @@\n 'use strict';\n-require('../common');\n+const common = require('../common');\n const assert = require('assert');\n const vm = require('vm');\n const spawnSync = require('child_process').spawnSync;\n@@ -84,8 +84,12 @@ function testRejectSlice() {\n testRejectSlice();\n \n // It should throw on non-Buffer cachedData\n-assert.throws(() => {\n+common.expectsError(() => {\n   new vm.Script('function abc() {}', {\n     cachedData: 'ohai'\n   });\n-}, /^TypeError: options\\.cachedData must be a Buffer instance$/);\n+}, {\n+  code: 'ERR_INVALID_ARG_TYPE',\n+  type: TypeError,\n+  message: /must be one of type Buffer or Uint8Array/\n+});"
        },
        {
            "sha": "31ed69da93fabcb8b28f7554db8664f9305bca04",
            "filename": "test/parallel/test-vm-context.js",
            "status": "modified",
            "additions": 17,
            "deletions": 11,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-context.js",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-context.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-context.js?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -64,19 +64,25 @@ try {\n // This is outside of catch block to confirm catch block ran.\n assert.strictEqual(gh1140Exception.toString(), 'Error');\n \n-// GH-558, non-context argument segfaults / raises assertion\n-const nonContextualSandboxErrorMsg =\n-  /^TypeError: contextifiedSandbox argument must be an object\\.$/;\n-const contextifiedSandboxErrorMsg =\n-    /^TypeError: sandbox argument must have been converted to a context\\.$/;\n+const nonContextualSandboxError = {\n+  code: 'ERR_INVALID_ARG_TYPE',\n+  type: TypeError,\n+  message: /must be of type Object/\n+};\n+const contextifiedSandboxError = {\n+  code: 'ERR_INVALID_ARG_TYPE',\n+  type: TypeError,\n+  message: /must be of type vm\\.Context/\n+};\n+\n [\n-  [undefined, nonContextualSandboxErrorMsg],\n-  [null, nonContextualSandboxErrorMsg], [0, nonContextualSandboxErrorMsg],\n-  [0.0, nonContextualSandboxErrorMsg], ['', nonContextualSandboxErrorMsg],\n-  [{}, contextifiedSandboxErrorMsg], [[], contextifiedSandboxErrorMsg]\n+  [undefined, nonContextualSandboxError],\n+  [null, nonContextualSandboxError], [0, nonContextualSandboxError],\n+  [0.0, nonContextualSandboxError], ['', nonContextualSandboxError],\n+  [{}, contextifiedSandboxError], [[], contextifiedSandboxError]\n ].forEach((e) => {\n-  assert.throws(() => { script.runInContext(e[0]); }, e[1]);\n-  assert.throws(() => { vm.runInContext('', e[0]); }, e[1]);\n+  common.expectsError(() => { script.runInContext(e[0]); }, e[1]);\n+  common.expectsError(() => { vm.runInContext('', e[0]); }, e[1]);\n });\n \n // Issue GH-693:"
        },
        {
            "sha": "2749a14834b2951edaf612fc7ceb9ad00472b1b8",
            "filename": "test/parallel/test-vm-is-context.js",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-is-context.js",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-is-context.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-is-context.js?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -35,13 +35,6 @@ for (const valToTest of [\n   });\n }\n \n-common.expectsError(() => {\n-  vm.isContext();\n-}, {\n-  code: 'ERR_MISSING_ARGS',\n-  type: TypeError\n-});\n-\n assert.strictEqual(vm.isContext({}), false);\n assert.strictEqual(vm.isContext([]), false);\n "
        },
        {
            "sha": "e00a14e4b9e6034b6af016a2c22a4620b49dc39c",
            "filename": "test/parallel/test-vm-options-validation.js",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-options-validation.js",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-options-validation.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-options-validation.js?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -0,0 +1,78 @@\n+'use strict';\n+\n+const common = require('../common');\n+const vm = require('vm');\n+\n+const invalidArgType = {\n+  type: TypeError,\n+  code: 'ERR_INVALID_ARG_TYPE'\n+};\n+\n+const outOfRange = {\n+  type: RangeError,\n+  code: 'ERR_OUT_OF_RANGE'\n+};\n+\n+common.expectsError(() => {\n+  new vm.Script('void 0', 42);\n+}, invalidArgType);\n+\n+[null, {}, [1], 'bad', true, 0.1].forEach((value) => {\n+  common.expectsError(() => {\n+    new vm.Script('void 0', { lineOffset: value });\n+  }, invalidArgType);\n+\n+  common.expectsError(() => {\n+    new vm.Script('void 0', { columnOffset: value });\n+  }, invalidArgType);\n+});\n+\n+common.expectsError(() => {\n+  new vm.Script('void 0', { lineOffset: Number.MAX_SAFE_INTEGER });\n+}, outOfRange);\n+\n+common.expectsError(() => {\n+  new vm.Script('void 0', { columnOffset: Number.MAX_SAFE_INTEGER });\n+}, outOfRange);\n+\n+common.expectsError(() => {\n+  new vm.Script('void 0', { filename: 123 });\n+}, invalidArgType);\n+\n+common.expectsError(() => {\n+  new vm.Script('void 0', { produceCachedData: 1 });\n+}, invalidArgType);\n+\n+[[0], {}, true, 'bad', 42].forEach((value) => {\n+  common.expectsError(() => {\n+    new vm.Script('void 0', { cachedData: value });\n+  }, invalidArgType);\n+});\n+\n+{\n+  const script = new vm.Script('void 0');\n+  const sandbox = vm.createContext();\n+\n+  function assertErrors(options) {\n+    common.expectsError(() => {\n+      script.runInThisContext(options);\n+    }, invalidArgType);\n+\n+    common.expectsError(() => {\n+      script.runInContext(sandbox, options);\n+    }, invalidArgType);\n+\n+    common.expectsError(() => {\n+      script.runInNewContext({}, options);\n+    }, invalidArgType);\n+  }\n+\n+  [null, 'bad', 42].forEach(assertErrors);\n+  [{}, [1], 'bad', null, -1, 0, NaN].forEach((value) => {\n+    assertErrors({ timeout: value });\n+  });\n+  [{}, [1], 'bad', 1, null].forEach((value) => {\n+    assertErrors({ displayErrors: value });\n+    assertErrors({ breakOnSigint: value });\n+  });\n+}"
        },
        {
            "sha": "859992e99ba36f14e0c4a2f0e4b424be8639acc6",
            "filename": "test/parallel/test-vm-timeout.js",
            "status": "modified",
            "additions": 5,
            "deletions": 15,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-timeout.js",
            "raw_url": "https://github.com/nodejs/node/raw/34d988f122c206da692b5c39ec5342fec22b60ab/test%2Fparallel%2Ftest-vm-timeout.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-timeout.js?ref=34d988f122c206da692b5c39ec5342fec22b60ab",
            "patch": "@@ -24,25 +24,15 @@ require('../common');\n const assert = require('assert');\n const vm = require('vm');\n \n-// Test 1: Timeout of 100ms executing endless loop\n+// Timeout of 100ms executing endless loop\n assert.throws(function() {\n   vm.runInThisContext('while(true) {}', { timeout: 100 });\n }, /^Error: Script execution timed out\\.$/);\n \n-// Test 2: Timeout must be >= 0ms\n-assert.throws(function() {\n-  vm.runInThisContext('', { timeout: -1 });\n-}, /^RangeError: timeout must be a positive number$/);\n-\n-// Test 3: Timeout of 0ms\n-assert.throws(function() {\n-  vm.runInThisContext('', { timeout: 0 });\n-}, /^RangeError: timeout must be a positive number$/);\n-\n-// Test 4: Timeout of 1000ms, script finishes first\n+// Timeout of 1000ms, script finishes first\n vm.runInThisContext('', { timeout: 1000 });\n \n-// Test 5: Nested vm timeouts, inner timeout propagates out\n+// Nested vm timeouts, inner timeout propagates out\n assert.throws(function() {\n   const context = {\n     log: console.log,\n@@ -54,7 +44,7 @@ assert.throws(function() {\n   throw new Error('Test 5 failed');\n }, /Script execution timed out\\./);\n \n-// Test 6: Nested vm timeouts, outer timeout is shorter and fires first.\n+// Nested vm timeouts, outer timeout is shorter and fires first.\n assert.throws(function() {\n   const context = {\n     runInVM: function(timeout) {\n@@ -65,7 +55,7 @@ assert.throws(function() {\n   throw new Error('Test 6 failed');\n }, /Script execution timed out\\./);\n \n-// Test 7: Nested vm timeouts, inner script throws an error.\n+// Nested vm timeouts, inner script throws an error.\n assert.throws(function() {\n   const context = {\n     runInVM: function(timeout) {"
        }
    ],
    "stats": {
        "total": 869,
        "additions": 458,
        "deletions": 411
    }
}