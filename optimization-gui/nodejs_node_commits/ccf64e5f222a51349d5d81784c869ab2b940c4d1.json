{
    "author": "lpinca",
    "message": "stream: augment BufferList.prototype\n\nMove functions that deal with `BufferList` to `BufferList.prototype`.\n\nPR-URL: https://github.com/nodejs/node/pull/18353\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "ccf64e5f222a51349d5d81784c869ab2b940c4d1",
    "files": [
        {
            "sha": "19e9e7a7439e53a10e3a2429808cc2167033846c",
            "filename": "lib/_stream_readable.js",
            "status": "modified",
            "additions": 2,
            "deletions": 90,
            "changes": 92,
            "blob_url": "https://github.com/nodejs/node/blob/ccf64e5f222a51349d5d81784c869ab2b940c4d1/lib%2F_stream_readable.js",
            "raw_url": "https://github.com/nodejs/node/raw/ccf64e5f222a51349d5d81784c869ab2b940c4d1/lib%2F_stream_readable.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_stream_readable.js?ref=ccf64e5f222a51349d5d81784c869ab2b940c4d1",
            "patch": "@@ -987,106 +987,18 @@ function fromList(n, state) {\n     if (state.decoder)\n       ret = state.buffer.join('');\n     else if (state.buffer.length === 1)\n-      ret = state.buffer.head.data;\n+      ret = state.buffer.first();\n     else\n       ret = state.buffer.concat(state.length);\n     state.buffer.clear();\n   } else {\n     // read part of list\n-    ret = fromListPartial(n, state.buffer, state.decoder);\n+    ret = state.buffer.consume(n, state.decoder);\n   }\n \n   return ret;\n }\n \n-// Extracts only enough buffered data to satisfy the amount requested.\n-// This function is designed to be inlinable, so please take care when making\n-// changes to the function body.\n-function fromListPartial(n, list, hasStrings) {\n-  var ret;\n-  if (n < list.head.data.length) {\n-    // slice is the same for buffers and strings\n-    ret = list.head.data.slice(0, n);\n-    list.head.data = list.head.data.slice(n);\n-  } else if (n === list.head.data.length) {\n-    // first chunk is a perfect match\n-    ret = list.shift();\n-  } else {\n-    // result spans more than one buffer\n-    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n-  }\n-  return ret;\n-}\n-\n-// Copies a specified amount of characters from the list of buffered data\n-// chunks.\n-// This function is designed to be inlinable, so please take care when making\n-// changes to the function body.\n-function copyFromBufferString(n, list) {\n-  var p = list.head;\n-  var c = 1;\n-  var ret = p.data;\n-  n -= ret.length;\n-  while (p = p.next) {\n-    const str = p.data;\n-    const nb = (n > str.length ? str.length : n);\n-    if (nb === str.length)\n-      ret += str;\n-    else\n-      ret += str.slice(0, n);\n-    n -= nb;\n-    if (n === 0) {\n-      if (nb === str.length) {\n-        ++c;\n-        if (p.next)\n-          list.head = p.next;\n-        else\n-          list.head = list.tail = null;\n-      } else {\n-        list.head = p;\n-        p.data = str.slice(nb);\n-      }\n-      break;\n-    }\n-    ++c;\n-  }\n-  list.length -= c;\n-  return ret;\n-}\n-\n-// Copies a specified amount of bytes from the list of buffered data chunks.\n-// This function is designed to be inlinable, so please take care when making\n-// changes to the function body.\n-function copyFromBuffer(n, list) {\n-  const ret = Buffer.allocUnsafe(n);\n-  var p = list.head;\n-  var c = 1;\n-  p.data.copy(ret);\n-  n -= p.data.length;\n-  while (p = p.next) {\n-    const buf = p.data;\n-    const nb = (n > buf.length ? buf.length : n);\n-    buf.copy(ret, ret.length - n, 0, nb);\n-    n -= nb;\n-    if (n === 0) {\n-      if (nb === buf.length) {\n-        ++c;\n-        if (p.next)\n-          list.head = p.next;\n-        else\n-          list.head = list.tail = null;\n-      } else {\n-        list.head = p;\n-        p.data = buf.slice(nb);\n-      }\n-      break;\n-    }\n-    ++c;\n-  }\n-  list.length -= c;\n-  return ret;\n-}\n-\n function endReadable(stream) {\n   var state = stream._readableState;\n "
        },
        {
            "sha": "a72bf37a31410bdac7a442c43fb0277403896c7e",
            "filename": "lib/internal/streams/BufferList.js",
            "status": "modified",
            "additions": 85,
            "deletions": 0,
            "changes": 85,
            "blob_url": "https://github.com/nodejs/node/blob/ccf64e5f222a51349d5d81784c869ab2b940c4d1/lib%2Finternal%2Fstreams%2FBufferList.js",
            "raw_url": "https://github.com/nodejs/node/raw/ccf64e5f222a51349d5d81784c869ab2b940c4d1/lib%2Finternal%2Fstreams%2FBufferList.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fstreams%2FBufferList.js?ref=ccf64e5f222a51349d5d81784c869ab2b940c4d1",
            "patch": "@@ -73,6 +73,91 @@ module.exports = class BufferList {\n     return ret;\n   }\n \n+  // Consumes a specified amount of bytes or characters from the buffered data.\n+  consume(n, hasStrings) {\n+    var ret;\n+    if (n < this.head.data.length) {\n+      // `slice` is the same for buffers and strings.\n+      ret = this.head.data.slice(0, n);\n+      this.head.data = this.head.data.slice(n);\n+    } else if (n === this.head.data.length) {\n+      // First chunk is a perfect match.\n+      ret = this.shift();\n+    } else {\n+      // Result spans more than one buffer.\n+      ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n+    }\n+    return ret;\n+  }\n+\n+  first() {\n+    return this.head.data;\n+  }\n+\n+  // Consumes a specified amount of characters from the buffered data.\n+  _getString(n) {\n+    var p = this.head;\n+    var c = 1;\n+    var ret = p.data;\n+    n -= ret.length;\n+    while (p = p.next) {\n+      const str = p.data;\n+      const nb = (n > str.length ? str.length : n);\n+      if (nb === str.length)\n+        ret += str;\n+      else\n+        ret += str.slice(0, n);\n+      n -= nb;\n+      if (n === 0) {\n+        if (nb === str.length) {\n+          ++c;\n+          if (p.next)\n+            this.head = p.next;\n+          else\n+            this.head = this.tail = null;\n+        } else {\n+          this.head = p;\n+          p.data = str.slice(nb);\n+        }\n+        break;\n+      }\n+      ++c;\n+    }\n+    this.length -= c;\n+    return ret;\n+  }\n+\n+  // Consumes a specified amount of bytes from the buffered data.\n+  _getBuffer(n) {\n+    const ret = Buffer.allocUnsafe(n);\n+    var p = this.head;\n+    var c = 1;\n+    p.data.copy(ret);\n+    n -= p.data.length;\n+    while (p = p.next) {\n+      const buf = p.data;\n+      const nb = (n > buf.length ? buf.length : n);\n+      buf.copy(ret, ret.length - n, 0, nb);\n+      n -= nb;\n+      if (n === 0) {\n+        if (nb === buf.length) {\n+          ++c;\n+          if (p.next)\n+            this.head = p.next;\n+          else\n+            this.head = this.tail = null;\n+        } else {\n+          this.head = p;\n+          p.data = buf.slice(nb);\n+        }\n+        break;\n+      }\n+      ++c;\n+    }\n+    this.length -= c;\n+    return ret;\n+  }\n+\n   [inspect.custom]() {\n     const obj = inspect({ length: this.length });\n     return `${this.constructor.name} ${obj}`;"
        }
    ],
    "stats": {
        "total": 177,
        "additions": 87,
        "deletions": 90
    }
}