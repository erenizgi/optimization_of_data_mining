{
    "author": "joyeecheung",
    "message": "src: move C++ binding/addon related code into node_binding{.h, .cc}\n\nThis patch:\n\n- Moves the C++ binding/addon related code out of\n  node_internals.h/node.cc and into dedicated files\n  node_binding.h/node_binding.cc, and only puts the code resued\n  by other files into the header.\n- Introduce a node::binding namespace so that code exposed to\n  other files can be easily recognized.\n\nPR-URL: https://github.com/nodejs/node/pull/24701\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>",
    "sha": "3d668262a09ef031003babc14eff9e5d4ac81698",
    "files": [
        {
            "sha": "4ad5ef3a9f8706ed8999d38cf2a7648b2c2cfd26",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/3d668262a09ef031003babc14eff9e5d4ac81698/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/3d668262a09ef031003babc14eff9e5d4ac81698/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=3d668262a09ef031003babc14eff9e5d4ac81698",
            "patch": "@@ -343,6 +343,7 @@\n         'src/module_wrap.cc',\n         'src/node.cc',\n         'src/node_api.cc',\n+        'src/node_binding.cc',\n         'src/node_buffer.cc',\n         'src/node_config.cc',\n         'src/node_constants.cc',\n@@ -414,6 +415,7 @@\n         'src/node.h',\n         'src/node_api.h',\n         'src/node_api_types.h',\n+        'src/node_binding.h',\n         'src/node_buffer.h',\n         'src/node_constants.h',\n         'src/node_context_data.h',"
        },
        {
            "sha": "01690a1e6c94da9a7f74168d5ac1571ae7edbbf7",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 399,
            "changes": 409,
            "blob_url": "https://github.com/nodejs/node/blob/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=3d668262a09ef031003babc14eff9e5d4ac81698",
            "patch": "@@ -19,6 +19,7 @@\n // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n // USE OR OTHER DEALINGS IN THE SOFTWARE.\n \n+#include \"node_binding.h\"\n #include \"node_buffer.h\"\n #include \"node_constants.h\"\n #include \"node_context_data.h\"\n@@ -113,20 +114,6 @@ typedef int mode_t;\n #include <grp.h>  // getgrnam()\n #endif\n \n-#if defined(__POSIX__)\n-#include <dlfcn.h>\n-#endif\n-\n-// This is used to load built-in modules. Instead of using\n-// __attribute__((constructor)), we call the _register_<modname>\n-// function for each built-in modules explicitly in\n-// node::RegisterBuiltinModules(). This is only forward declaration.\n-// The definitions are in each module's implementation when calling\n-// the NODE_BUILTIN_MODULE_CONTEXT_AWARE.\n-#define V(modname) void _register_##modname();\n-  NODE_BUILTIN_MODULES(V)\n-#undef V\n-\n namespace node {\n \n using native_module::NativeModuleLoader;\n@@ -173,13 +160,6 @@ using v8::V8;\n using v8::Value;\n \n static bool v8_is_profiling = false;\n-static bool node_is_initialized = false;\n-static uv_once_t init_modpending_once = UV_ONCE_INIT;\n-static uv_key_t thread_local_modpending;\n-static node_module* modlist_builtin;\n-static node_module* modlist_internal;\n-static node_module* modlist_linked;\n-static node_module* modlist_addon;\n \n #ifdef NODE_EXPERIMENTAL_HTTP\n static const char llhttp_version[] =\n@@ -825,257 +805,6 @@ static void Exit(const FunctionCallbackInfo<Value>& args) {\n   env->Exit(code);\n }\n \n-extern \"C\" void node_module_register(void* m) {\n-  struct node_module* mp = reinterpret_cast<struct node_module*>(m);\n-\n-  if (mp->nm_flags & NM_F_BUILTIN) {\n-    mp->nm_link = modlist_builtin;\n-    modlist_builtin = mp;\n-  } else if (mp->nm_flags & NM_F_INTERNAL) {\n-    mp->nm_link = modlist_internal;\n-    modlist_internal = mp;\n-  } else if (!node_is_initialized) {\n-    // \"Linked\" modules are included as part of the node project.\n-    // Like builtins they are registered *before* node::Init runs.\n-    mp->nm_flags = NM_F_LINKED;\n-    mp->nm_link = modlist_linked;\n-    modlist_linked = mp;\n-  } else {\n-    uv_key_set(&thread_local_modpending, mp);\n-  }\n-}\n-\n-inline struct node_module* FindModule(struct node_module* list,\n-                                      const char* name,\n-                                      int flag) {\n-  struct node_module* mp;\n-\n-  for (mp = list; mp != nullptr; mp = mp->nm_link) {\n-    if (strcmp(mp->nm_modname, name) == 0)\n-      break;\n-  }\n-\n-  CHECK(mp == nullptr || (mp->nm_flags & flag) != 0);\n-  return mp;\n-}\n-\n-node_module* get_builtin_module(const char* name) {\n-  return FindModule(modlist_builtin, name, NM_F_BUILTIN);\n-}\n-node_module* get_internal_module(const char* name) {\n-  return FindModule(modlist_internal, name, NM_F_INTERNAL);\n-}\n-node_module* get_linked_module(const char* name) {\n-  return FindModule(modlist_linked, name, NM_F_LINKED);\n-}\n-\n-class DLib {\n- public:\n-#ifdef __POSIX__\n-  static const int kDefaultFlags = RTLD_LAZY;\n-#else\n-  static const int kDefaultFlags = 0;\n-#endif\n-\n-  inline DLib(const char* filename, int flags)\n-      : filename_(filename), flags_(flags), handle_(nullptr) {}\n-\n-  inline bool Open();\n-  inline void Close();\n-  inline void* GetSymbolAddress(const char* name);\n-\n-  const std::string filename_;\n-  const int flags_;\n-  std::string errmsg_;\n-  void* handle_;\n-#ifndef __POSIX__\n-  uv_lib_t lib_;\n-#endif\n- private:\n-  DISALLOW_COPY_AND_ASSIGN(DLib);\n-};\n-\n-\n-#ifdef __POSIX__\n-bool DLib::Open() {\n-  handle_ = dlopen(filename_.c_str(), flags_);\n-  if (handle_ != nullptr)\n-    return true;\n-  errmsg_ = dlerror();\n-  return false;\n-}\n-\n-void DLib::Close() {\n-  if (handle_ == nullptr) return;\n-  dlclose(handle_);\n-  handle_ = nullptr;\n-}\n-\n-void* DLib::GetSymbolAddress(const char* name) {\n-  return dlsym(handle_, name);\n-}\n-#else  // !__POSIX__\n-bool DLib::Open() {\n-  int ret = uv_dlopen(filename_.c_str(), &lib_);\n-  if (ret == 0) {\n-    handle_ = static_cast<void*>(lib_.handle);\n-    return true;\n-  }\n-  errmsg_ = uv_dlerror(&lib_);\n-  uv_dlclose(&lib_);\n-  return false;\n-}\n-\n-void DLib::Close() {\n-  if (handle_ == nullptr) return;\n-  uv_dlclose(&lib_);\n-  handle_ = nullptr;\n-}\n-\n-void* DLib::GetSymbolAddress(const char* name) {\n-  void* address;\n-  if (0 == uv_dlsym(&lib_, name, &address)) return address;\n-  return nullptr;\n-}\n-#endif  // !__POSIX__\n-\n-using InitializerCallback = void (*)(Local<Object> exports,\n-                                     Local<Value> module,\n-                                     Local<Context> context);\n-\n-inline InitializerCallback GetInitializerCallback(DLib* dlib) {\n-  const char* name = \"node_register_module_v\" STRINGIFY(NODE_MODULE_VERSION);\n-  return reinterpret_cast<InitializerCallback>(dlib->GetSymbolAddress(name));\n-}\n-\n-inline napi_addon_register_func GetNapiInitializerCallback(DLib* dlib) {\n-  const char* name =\n-      STRINGIFY(NAPI_MODULE_INITIALIZER_BASE) STRINGIFY(NAPI_MODULE_VERSION);\n-  return\n-      reinterpret_cast<napi_addon_register_func>(dlib->GetSymbolAddress(name));\n-}\n-\n-void InitModpendingOnce() {\n-  CHECK_EQ(0, uv_key_create(&thread_local_modpending));\n-}\n-\n-// DLOpen is process.dlopen(module, filename, flags).\n-// Used to load 'module.node' dynamically shared objects.\n-//\n-// FIXME(bnoordhuis) Not multi-context ready. TBD how to resolve the conflict\n-// when two contexts try to load the same shared object. Maybe have a shadow\n-// cache that's a plain C list or hash table that's shared across contexts?\n-static void DLOpen(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-  auto context = env->context();\n-\n-  uv_once(&init_modpending_once, InitModpendingOnce);\n-  CHECK_NULL(uv_key_get(&thread_local_modpending));\n-\n-  if (args.Length() < 2) {\n-    env->ThrowError(\"process.dlopen needs at least 2 arguments.\");\n-    return;\n-  }\n-\n-  int32_t flags = DLib::kDefaultFlags;\n-  if (args.Length() > 2 && !args[2]->Int32Value(context).To(&flags)) {\n-    return env->ThrowTypeError(\"flag argument must be an integer.\");\n-  }\n-\n-  Local<Object> module;\n-  Local<Object> exports;\n-  Local<Value> exports_v;\n-  if (!args[0]->ToObject(context).ToLocal(&module) ||\n-      !module->Get(context, env->exports_string()).ToLocal(&exports_v) ||\n-      !exports_v->ToObject(context).ToLocal(&exports)) {\n-    return;  // Exception pending.\n-  }\n-\n-  node::Utf8Value filename(env->isolate(), args[1]);  // Cast\n-  DLib dlib(*filename, flags);\n-  bool is_opened = dlib.Open();\n-\n-  // Objects containing v14 or later modules will have registered themselves\n-  // on the pending list.  Activate all of them now.  At present, only one\n-  // module per object is supported.\n-  node_module* const mp = static_cast<node_module*>(\n-      uv_key_get(&thread_local_modpending));\n-  uv_key_set(&thread_local_modpending, nullptr);\n-\n-  if (!is_opened) {\n-    Local<String> errmsg = OneByteString(env->isolate(), dlib.errmsg_.c_str());\n-    dlib.Close();\n-#ifdef _WIN32\n-    // Windows needs to add the filename into the error message\n-    errmsg = String::Concat(\n-        env->isolate(), errmsg, args[1]->ToString(context).ToLocalChecked());\n-#endif  // _WIN32\n-    env->isolate()->ThrowException(Exception::Error(errmsg));\n-    return;\n-  }\n-\n-  if (mp == nullptr) {\n-    if (auto callback = GetInitializerCallback(&dlib)) {\n-      callback(exports, module, context);\n-    } else if (auto napi_callback = GetNapiInitializerCallback(&dlib)) {\n-      napi_module_register_by_symbol(exports, module, context, napi_callback);\n-    } else {\n-      dlib.Close();\n-      env->ThrowError(\"Module did not self-register.\");\n-    }\n-    return;\n-  }\n-\n-  // -1 is used for N-API modules\n-  if ((mp->nm_version != -1) && (mp->nm_version != NODE_MODULE_VERSION)) {\n-    // Even if the module did self-register, it may have done so with the wrong\n-    // version. We must only give up after having checked to see if it has an\n-    // appropriate initializer callback.\n-    if (auto callback = GetInitializerCallback(&dlib)) {\n-      callback(exports, module, context);\n-      return;\n-    }\n-    char errmsg[1024];\n-    snprintf(errmsg,\n-             sizeof(errmsg),\n-             \"The module '%s'\"\n-             \"\\nwas compiled against a different Node.js version using\"\n-             \"\\nNODE_MODULE_VERSION %d. This version of Node.js requires\"\n-             \"\\nNODE_MODULE_VERSION %d. Please try re-compiling or \"\n-             \"re-installing\\nthe module (for instance, using `npm rebuild` \"\n-             \"or `npm install`).\",\n-             *filename, mp->nm_version, NODE_MODULE_VERSION);\n-\n-    // NOTE: `mp` is allocated inside of the shared library's memory, calling\n-    // `dlclose` will deallocate it\n-    dlib.Close();\n-    env->ThrowError(errmsg);\n-    return;\n-  }\n-  if (mp->nm_flags & NM_F_BUILTIN) {\n-    dlib.Close();\n-    env->ThrowError(\"Built-in module self-registered.\");\n-    return;\n-  }\n-\n-  mp->nm_dso_handle = dlib.handle_;\n-  mp->nm_link = modlist_addon;\n-  modlist_addon = mp;\n-\n-  if (mp->nm_context_register_func != nullptr) {\n-    mp->nm_context_register_func(exports, module, context, mp->nm_priv);\n-  } else if (mp->nm_register_func != nullptr) {\n-    mp->nm_register_func(exports, module, mp->nm_priv);\n-  } else {\n-    dlib.Close();\n-    env->ThrowError(\"Module has no declared entry point.\");\n-    return;\n-  }\n-\n-  // Tell coverity that 'handle' should not be freed when we return.\n-  // coverity[leaked_storage]\n-}\n-\n static Maybe<bool> ProcessEmitWarningGeneric(Environment* env,\n                                              const char* warning,\n                                              const char* type = nullptr,\n@@ -1179,118 +908,6 @@ static void OnMessage(Local<Message> message, Local<Value> error) {\n   }\n }\n \n-\n-static Local<Object> InitModule(Environment* env,\n-                                 node_module* mod,\n-                                 Local<String> module) {\n-  Local<Object> exports = Object::New(env->isolate());\n-  // Internal bindings don't have a \"module\" object, only exports.\n-  CHECK_NULL(mod->nm_register_func);\n-  CHECK_NOT_NULL(mod->nm_context_register_func);\n-  Local<Value> unused = Undefined(env->isolate());\n-  mod->nm_context_register_func(exports,\n-                                unused,\n-                                env->context(),\n-                                mod->nm_priv);\n-  return exports;\n-}\n-\n-static void ThrowIfNoSuchModule(Environment* env, const char* module_v) {\n-  char errmsg[1024];\n-  snprintf(errmsg,\n-           sizeof(errmsg),\n-           \"No such module: %s\",\n-           module_v);\n-  env->ThrowError(errmsg);\n-}\n-\n-static void GetBinding(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  CHECK(args[0]->IsString());\n-\n-  Local<String> module = args[0].As<String>();\n-  node::Utf8Value module_v(env->isolate(), module);\n-\n-  node_module* mod = get_builtin_module(*module_v);\n-  Local<Object> exports;\n-  if (mod != nullptr) {\n-    exports = InitModule(env, mod, module);\n-  } else {\n-    return ThrowIfNoSuchModule(env, *module_v);\n-  }\n-\n-  args.GetReturnValue().Set(exports);\n-}\n-\n-static void GetInternalBinding(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  CHECK(args[0]->IsString());\n-\n-  Local<String> module = args[0].As<String>();\n-  node::Utf8Value module_v(env->isolate(), module);\n-  Local<Object> exports;\n-\n-  node_module* mod = get_internal_module(*module_v);\n-  if (mod != nullptr) {\n-    exports = InitModule(env, mod, module);\n-  } else if (!strcmp(*module_v, \"constants\")) {\n-    exports = Object::New(env->isolate());\n-    CHECK(exports->SetPrototype(env->context(),\n-                                Null(env->isolate())).FromJust());\n-    DefineConstants(env->isolate(), exports);\n-  } else if (!strcmp(*module_v, \"natives\")) {\n-    exports = per_process_loader.GetSourceObject(env->context());\n-  } else {\n-    return ThrowIfNoSuchModule(env, *module_v);\n-  }\n-\n-  args.GetReturnValue().Set(exports);\n-}\n-\n-static void GetLinkedBinding(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  CHECK(args[0]->IsString());\n-\n-  Local<String> module_name = args[0].As<String>();\n-\n-  node::Utf8Value module_name_v(env->isolate(), module_name);\n-  node_module* mod = get_linked_module(*module_name_v);\n-\n-  if (mod == nullptr) {\n-    char errmsg[1024];\n-    snprintf(errmsg,\n-             sizeof(errmsg),\n-             \"No such module was linked: %s\",\n-             *module_name_v);\n-    return env->ThrowError(errmsg);\n-  }\n-\n-  Local<Object> module = Object::New(env->isolate());\n-  Local<Object> exports = Object::New(env->isolate());\n-  Local<String> exports_prop = String::NewFromUtf8(env->isolate(), \"exports\",\n-      NewStringType::kNormal).ToLocalChecked();\n-  module->Set(env->context(), exports_prop, exports).FromJust();\n-\n-  if (mod->nm_context_register_func != nullptr) {\n-    mod->nm_context_register_func(exports,\n-                                  module,\n-                                  env->context(),\n-                                  mod->nm_priv);\n-  } else if (mod->nm_register_func != nullptr) {\n-    mod->nm_register_func(exports, module, mod->nm_priv);\n-  } else {\n-    return env->ThrowError(\"Linked module has no declared entry point.\");\n-  }\n-\n-  auto effective_exports = module->Get(env->context(),\n-                                       exports_prop).ToLocalChecked();\n-\n-  args.GetReturnValue().Set(effective_exports);\n-}\n-\n static Local<Object> GetFeatures(Environment* env) {\n   EscapableHandleScope scope(env->isolate());\n \n@@ -1688,7 +1305,7 @@ void SetupProcessObject(Environment* env,\n   env->SetMethod(process, \"_kill\", Kill);\n \n   env->SetMethodNoSideEffect(process, \"cwd\", Cwd);\n-  env->SetMethod(process, \"dlopen\", DLOpen);\n+  env->SetMethod(process, \"dlopen\", binding::DLOpen);\n   env->SetMethod(process, \"reallyExit\", Exit);\n   env->SetMethodNoSideEffect(process, \"uptime\", Uptime);\n \n@@ -1825,16 +1442,18 @@ void LoadEnvironment(Environment* env) {\n               global).FromJust();\n \n   // Create binding loaders\n-  Local<Function> get_binding_fn =\n-      env->NewFunctionTemplate(GetBinding)->GetFunction(env->context())\n-          .ToLocalChecked();\n+  Local<Function> get_binding_fn = env->NewFunctionTemplate(binding::GetBinding)\n+                                       ->GetFunction(env->context())\n+                                       .ToLocalChecked();\n \n   Local<Function> get_linked_binding_fn =\n-      env->NewFunctionTemplate(GetLinkedBinding)->GetFunction(env->context())\n+      env->NewFunctionTemplate(binding::GetLinkedBinding)\n+          ->GetFunction(env->context())\n           .ToLocalChecked();\n \n   Local<Function> get_internal_binding_fn =\n-      env->NewFunctionTemplate(GetInternalBinding)->GetFunction(env->context())\n+      env->NewFunctionTemplate(binding::GetInternalBinding)\n+          ->GetFunction(env->context())\n           .ToLocalChecked();\n \n   Local<Value> loaders_bootstrapper_args[] = {\n@@ -2206,7 +1825,7 @@ void Init(std::vector<std::string>* argv,\n   prog_start_time = static_cast<double>(uv_now(uv_default_loop()));\n \n   // Register built-in modules\n-  RegisterBuiltinModules();\n+  binding::RegisterBuiltinModules();\n \n   // Make inherited handles noninheritable.\n   uv_disable_stdio_inheritance();\n@@ -2727,14 +2346,6 @@ int Start(int argc, char** argv) {\n   return exit_code;\n }\n \n-// Call built-in modules' _register_<module name> function to\n-// do module registration explicitly.\n-void RegisterBuiltinModules() {\n-#define V(modname) _register_##modname();\n-  NODE_BUILTIN_MODULES(V)\n-#undef V\n-}\n-\n }  // namespace node\n \n #if !HAVE_INSPECTOR"
        },
        {
            "sha": "7d843c08f5a69da61133006ef892fb50eec92cac",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=3d668262a09ef031003babc14eff9e5d4ac81698",
            "patch": "@@ -1,10 +1,11 @@\n #include <node_buffer.h>\n #include \"env.h\"\n #define NAPI_EXPERIMENTAL\n+#include \"js_native_api_v8.h\"\n #include \"node_api.h\"\n+#include \"node_binding.h\"\n #include \"node_errors.h\"\n #include \"node_internals.h\"\n-#include \"js_native_api_v8.h\"\n \n struct node_napi_env__ : public napi_env__ {\n   explicit node_napi_env__(v8::Local<v8::Context> context):"
        },
        {
            "sha": "a2e5134bfa1188c62e291b9d51b0c7d1008eb0a0",
            "filename": "src/node_binding.cc",
            "status": "added",
            "additions": 471,
            "deletions": 0,
            "changes": 471,
            "blob_url": "https://github.com/nodejs/node/blob/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode_binding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode_binding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_binding.cc?ref=3d668262a09ef031003babc14eff9e5d4ac81698",
            "patch": "@@ -0,0 +1,471 @@\n+#include \"node_binding.h\"\n+#include \"node_internals.h\"\n+#include \"node_native_module.h\"\n+\n+#if defined(__POSIX__)\n+#include <dlfcn.h>\n+#endif\n+\n+#if HAVE_OPENSSL\n+#define NODE_BUILTIN_OPENSSL_MODULES(V) V(crypto) V(tls_wrap)\n+#else\n+#define NODE_BUILTIN_OPENSSL_MODULES(V)\n+#endif\n+\n+#if NODE_HAVE_I18N_SUPPORT\n+#define NODE_BUILTIN_ICU_MODULES(V) V(icu)\n+#else\n+#define NODE_BUILTIN_ICU_MODULES(V)\n+#endif\n+\n+// A list of built-in modules. In order to do module registration\n+// in node::Init(), need to add built-in modules in the following list.\n+// Then in binding::RegisterBuiltinModules(), it calls modules' registration\n+// function. This helps the built-in modules are loaded properly when\n+// node is built as static library. No need to depend on the\n+// __attribute__((constructor)) like mechanism in GCC.\n+#define NODE_BUILTIN_STANDARD_MODULES(V)                                       \\\n+  V(async_wrap)                                                                \\\n+  V(buffer)                                                                    \\\n+  V(cares_wrap)                                                                \\\n+  V(config)                                                                    \\\n+  V(contextify)                                                                \\\n+  V(domain)                                                                    \\\n+  V(fs)                                                                        \\\n+  V(fs_event_wrap)                                                             \\\n+  V(heap_utils)                                                                \\\n+  V(http2)                                                                     \\\n+  V(http_parser)                                                               \\\n+  V(inspector)                                                                 \\\n+  V(js_stream)                                                                 \\\n+  V(messaging)                                                                 \\\n+  V(module_wrap)                                                               \\\n+  V(native_module)                                                             \\\n+  V(options)                                                                   \\\n+  V(os)                                                                        \\\n+  V(performance)                                                               \\\n+  V(pipe_wrap)                                                                 \\\n+  V(process_wrap)                                                              \\\n+  V(serdes)                                                                    \\\n+  V(signal_wrap)                                                               \\\n+  V(spawn_sync)                                                                \\\n+  V(stream_pipe)                                                               \\\n+  V(stream_wrap)                                                               \\\n+  V(string_decoder)                                                            \\\n+  V(symbols)                                                                   \\\n+  V(tcp_wrap)                                                                  \\\n+  V(timers)                                                                    \\\n+  V(trace_events)                                                              \\\n+  V(tty_wrap)                                                                  \\\n+  V(types)                                                                     \\\n+  V(udp_wrap)                                                                  \\\n+  V(url)                                                                       \\\n+  V(util)                                                                      \\\n+  V(uv)                                                                        \\\n+  V(v8)                                                                        \\\n+  V(worker)                                                                    \\\n+  V(zlib)\n+\n+#define NODE_BUILTIN_MODULES(V)                                                \\\n+  NODE_BUILTIN_STANDARD_MODULES(V)                                             \\\n+  NODE_BUILTIN_OPENSSL_MODULES(V)                                              \\\n+  NODE_BUILTIN_ICU_MODULES(V)\n+\n+// This is used to load built-in modules. Instead of using\n+// __attribute__((constructor)), we call the _register_<modname>\n+// function for each built-in modules explicitly in\n+// binding::RegisterBuiltinModules(). This is only forward declaration.\n+// The definitions are in each module's implementation when calling\n+// the NODE_BUILTIN_MODULE_CONTEXT_AWARE.\n+#define V(modname) void _register_##modname();\n+NODE_BUILTIN_MODULES(V)\n+#undef V\n+\n+namespace node {\n+\n+using v8::Context;\n+using v8::Exception;\n+using v8::FunctionCallbackInfo;\n+using v8::Local;\n+using v8::NewStringType;\n+using v8::Object;\n+using v8::String;\n+using v8::Value;\n+\n+// Globals per process\n+static node_module* modlist_builtin;\n+static node_module* modlist_internal;\n+static node_module* modlist_linked;\n+static node_module* modlist_addon;\n+static uv_once_t init_modpending_once = UV_ONCE_INIT;\n+static uv_key_t thread_local_modpending;\n+\n+// This is set by node::Init() which is used by embedders\n+bool node_is_initialized = false;\n+\n+extern \"C\" void node_module_register(void* m) {\n+  struct node_module* mp = reinterpret_cast<struct node_module*>(m);\n+\n+  if (mp->nm_flags & NM_F_BUILTIN) {\n+    mp->nm_link = modlist_builtin;\n+    modlist_builtin = mp;\n+  } else if (mp->nm_flags & NM_F_INTERNAL) {\n+    mp->nm_link = modlist_internal;\n+    modlist_internal = mp;\n+  } else if (!node_is_initialized) {\n+    // \"Linked\" modules are included as part of the node project.\n+    // Like builtins they are registered *before* node::Init runs.\n+    mp->nm_flags = NM_F_LINKED;\n+    mp->nm_link = modlist_linked;\n+    modlist_linked = mp;\n+  } else {\n+    uv_key_set(&thread_local_modpending, mp);\n+  }\n+}\n+\n+namespace binding {\n+\n+class DLib {\n+ public:\n+#ifdef __POSIX__\n+  static const int kDefaultFlags = RTLD_LAZY;\n+#else\n+  static const int kDefaultFlags = 0;\n+#endif\n+\n+  inline DLib(const char* filename, int flags)\n+      : filename_(filename), flags_(flags), handle_(nullptr) {}\n+\n+  inline bool Open();\n+  inline void Close();\n+  inline void* GetSymbolAddress(const char* name);\n+\n+  const std::string filename_;\n+  const int flags_;\n+  std::string errmsg_;\n+  void* handle_;\n+#ifndef __POSIX__\n+  uv_lib_t lib_;\n+#endif\n+ private:\n+  DISALLOW_COPY_AND_ASSIGN(DLib);\n+};\n+\n+#ifdef __POSIX__\n+bool DLib::Open() {\n+  handle_ = dlopen(filename_.c_str(), flags_);\n+  if (handle_ != nullptr) return true;\n+  errmsg_ = dlerror();\n+  return false;\n+}\n+\n+void DLib::Close() {\n+  if (handle_ == nullptr) return;\n+  dlclose(handle_);\n+  handle_ = nullptr;\n+}\n+\n+void* DLib::GetSymbolAddress(const char* name) {\n+  return dlsym(handle_, name);\n+}\n+#else   // !__POSIX__\n+bool DLib::Open() {\n+  int ret = uv_dlopen(filename_.c_str(), &lib_);\n+  if (ret == 0) {\n+    handle_ = static_cast<void*>(lib_.handle);\n+    return true;\n+  }\n+  errmsg_ = uv_dlerror(&lib_);\n+  uv_dlclose(&lib_);\n+  return false;\n+}\n+\n+void DLib::Close() {\n+  if (handle_ == nullptr) return;\n+  uv_dlclose(&lib_);\n+  handle_ = nullptr;\n+}\n+\n+void* DLib::GetSymbolAddress(const char* name) {\n+  void* address;\n+  if (0 == uv_dlsym(&lib_, name, &address)) return address;\n+  return nullptr;\n+}\n+#endif  // !__POSIX__\n+\n+using InitializerCallback = void (*)(Local<Object> exports,\n+                                     Local<Value> module,\n+                                     Local<Context> context);\n+\n+inline InitializerCallback GetInitializerCallback(DLib* dlib) {\n+  const char* name = \"node_register_module_v\" STRINGIFY(NODE_MODULE_VERSION);\n+  return reinterpret_cast<InitializerCallback>(dlib->GetSymbolAddress(name));\n+}\n+\n+inline napi_addon_register_func GetNapiInitializerCallback(DLib* dlib) {\n+  const char* name =\n+      STRINGIFY(NAPI_MODULE_INITIALIZER_BASE) STRINGIFY(NAPI_MODULE_VERSION);\n+  return reinterpret_cast<napi_addon_register_func>(\n+      dlib->GetSymbolAddress(name));\n+}\n+\n+void InitModpendingOnce() {\n+  CHECK_EQ(0, uv_key_create(&thread_local_modpending));\n+}\n+\n+// DLOpen is process.dlopen(module, filename, flags).\n+// Used to load 'module.node' dynamically shared objects.\n+//\n+// FIXME(bnoordhuis) Not multi-context ready. TBD how to resolve the conflict\n+// when two contexts try to load the same shared object. Maybe have a shadow\n+// cache that's a plain C list or hash table that's shared across contexts?\n+void DLOpen(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  auto context = env->context();\n+\n+  uv_once(&init_modpending_once, InitModpendingOnce);\n+  CHECK_NULL(uv_key_get(&thread_local_modpending));\n+\n+  if (args.Length() < 2) {\n+    env->ThrowError(\"process.dlopen needs at least 2 arguments.\");\n+    return;\n+  }\n+\n+  int32_t flags = DLib::kDefaultFlags;\n+  if (args.Length() > 2 && !args[2]->Int32Value(context).To(&flags)) {\n+    return env->ThrowTypeError(\"flag argument must be an integer.\");\n+  }\n+\n+  Local<Object> module;\n+  Local<Object> exports;\n+  Local<Value> exports_v;\n+  if (!args[0]->ToObject(context).ToLocal(&module) ||\n+      !module->Get(context, env->exports_string()).ToLocal(&exports_v) ||\n+      !exports_v->ToObject(context).ToLocal(&exports)) {\n+    return;  // Exception pending.\n+  }\n+\n+  node::Utf8Value filename(env->isolate(), args[1]);  // Cast\n+  DLib dlib(*filename, flags);\n+  bool is_opened = dlib.Open();\n+\n+  // Objects containing v14 or later modules will have registered themselves\n+  // on the pending list.  Activate all of them now.  At present, only one\n+  // module per object is supported.\n+  node_module* const mp =\n+      static_cast<node_module*>(uv_key_get(&thread_local_modpending));\n+  uv_key_set(&thread_local_modpending, nullptr);\n+\n+  if (!is_opened) {\n+    Local<String> errmsg = OneByteString(env->isolate(), dlib.errmsg_.c_str());\n+    dlib.Close();\n+#ifdef _WIN32\n+    // Windows needs to add the filename into the error message\n+    errmsg = String::Concat(\n+        env->isolate(), errmsg, args[1]->ToString(context).ToLocalChecked());\n+#endif  // _WIN32\n+    env->isolate()->ThrowException(Exception::Error(errmsg));\n+    return;\n+  }\n+\n+  if (mp == nullptr) {\n+    if (auto callback = GetInitializerCallback(&dlib)) {\n+      callback(exports, module, context);\n+    } else if (auto napi_callback = GetNapiInitializerCallback(&dlib)) {\n+      napi_module_register_by_symbol(exports, module, context, napi_callback);\n+    } else {\n+      dlib.Close();\n+      env->ThrowError(\"Module did not self-register.\");\n+    }\n+    return;\n+  }\n+\n+  // -1 is used for N-API modules\n+  if ((mp->nm_version != -1) && (mp->nm_version != NODE_MODULE_VERSION)) {\n+    // Even if the module did self-register, it may have done so with the wrong\n+    // version. We must only give up after having checked to see if it has an\n+    // appropriate initializer callback.\n+    if (auto callback = GetInitializerCallback(&dlib)) {\n+      callback(exports, module, context);\n+      return;\n+    }\n+    char errmsg[1024];\n+    snprintf(errmsg,\n+             sizeof(errmsg),\n+             \"The module '%s'\"\n+             \"\\nwas compiled against a different Node.js version using\"\n+             \"\\nNODE_MODULE_VERSION %d. This version of Node.js requires\"\n+             \"\\nNODE_MODULE_VERSION %d. Please try re-compiling or \"\n+             \"re-installing\\nthe module (for instance, using `npm rebuild` \"\n+             \"or `npm install`).\",\n+             *filename,\n+             mp->nm_version,\n+             NODE_MODULE_VERSION);\n+\n+    // NOTE: `mp` is allocated inside of the shared library's memory, calling\n+    // `dlclose` will deallocate it\n+    dlib.Close();\n+    env->ThrowError(errmsg);\n+    return;\n+  }\n+  if (mp->nm_flags & NM_F_BUILTIN) {\n+    dlib.Close();\n+    env->ThrowError(\"Built-in module self-registered.\");\n+    return;\n+  }\n+\n+  mp->nm_dso_handle = dlib.handle_;\n+  mp->nm_link = modlist_addon;\n+  modlist_addon = mp;\n+\n+  if (mp->nm_context_register_func != nullptr) {\n+    mp->nm_context_register_func(exports, module, context, mp->nm_priv);\n+  } else if (mp->nm_register_func != nullptr) {\n+    mp->nm_register_func(exports, module, mp->nm_priv);\n+  } else {\n+    dlib.Close();\n+    env->ThrowError(\"Module has no declared entry point.\");\n+    return;\n+  }\n+\n+  // Tell coverity that 'handle' should not be freed when we return.\n+  // coverity[leaked_storage]\n+}\n+\n+inline struct node_module* FindModule(struct node_module* list,\n+                                      const char* name,\n+                                      int flag) {\n+  struct node_module* mp;\n+\n+  for (mp = list; mp != nullptr; mp = mp->nm_link) {\n+    if (strcmp(mp->nm_modname, name) == 0) break;\n+  }\n+\n+  CHECK(mp == nullptr || (mp->nm_flags & flag) != 0);\n+  return mp;\n+}\n+\n+node_module* get_builtin_module(const char* name) {\n+  return FindModule(modlist_builtin, name, NM_F_BUILTIN);\n+}\n+node_module* get_internal_module(const char* name) {\n+  return FindModule(modlist_internal, name, NM_F_INTERNAL);\n+}\n+node_module* get_linked_module(const char* name) {\n+  return FindModule(modlist_linked, name, NM_F_LINKED);\n+}\n+\n+static Local<Object> InitModule(Environment* env,\n+                                node_module* mod,\n+                                Local<String> module) {\n+  Local<Object> exports = Object::New(env->isolate());\n+  // Internal bindings don't have a \"module\" object, only exports.\n+  CHECK_NULL(mod->nm_register_func);\n+  CHECK_NOT_NULL(mod->nm_context_register_func);\n+  Local<Value> unused = Undefined(env->isolate());\n+  mod->nm_context_register_func(exports, unused, env->context(), mod->nm_priv);\n+  return exports;\n+}\n+\n+static void ThrowIfNoSuchModule(Environment* env, const char* module_v) {\n+  char errmsg[1024];\n+  snprintf(errmsg, sizeof(errmsg), \"No such module: %s\", module_v);\n+  env->ThrowError(errmsg);\n+}\n+\n+void GetBinding(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  CHECK(args[0]->IsString());\n+\n+  Local<String> module = args[0].As<String>();\n+  node::Utf8Value module_v(env->isolate(), module);\n+\n+  node_module* mod = get_builtin_module(*module_v);\n+  Local<Object> exports;\n+  if (mod != nullptr) {\n+    exports = InitModule(env, mod, module);\n+  } else {\n+    return ThrowIfNoSuchModule(env, *module_v);\n+  }\n+\n+  args.GetReturnValue().Set(exports);\n+}\n+\n+void GetInternalBinding(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  CHECK(args[0]->IsString());\n+\n+  Local<String> module = args[0].As<String>();\n+  node::Utf8Value module_v(env->isolate(), module);\n+  Local<Object> exports;\n+\n+  node_module* mod = get_internal_module(*module_v);\n+  if (mod != nullptr) {\n+    exports = InitModule(env, mod, module);\n+  } else if (!strcmp(*module_v, \"constants\")) {\n+    exports = Object::New(env->isolate());\n+    CHECK(\n+        exports->SetPrototype(env->context(), Null(env->isolate())).FromJust());\n+    DefineConstants(env->isolate(), exports);\n+  } else if (!strcmp(*module_v, \"natives\")) {\n+    exports = per_process_loader.GetSourceObject(env->context());\n+  } else {\n+    return ThrowIfNoSuchModule(env, *module_v);\n+  }\n+\n+  args.GetReturnValue().Set(exports);\n+}\n+\n+void GetLinkedBinding(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  CHECK(args[0]->IsString());\n+\n+  Local<String> module_name = args[0].As<String>();\n+\n+  node::Utf8Value module_name_v(env->isolate(), module_name);\n+  node_module* mod = get_linked_module(*module_name_v);\n+\n+  if (mod == nullptr) {\n+    char errmsg[1024];\n+    snprintf(errmsg,\n+             sizeof(errmsg),\n+             \"No such module was linked: %s\",\n+             *module_name_v);\n+    return env->ThrowError(errmsg);\n+  }\n+\n+  Local<Object> module = Object::New(env->isolate());\n+  Local<Object> exports = Object::New(env->isolate());\n+  Local<String> exports_prop =\n+      String::NewFromUtf8(env->isolate(), \"exports\", NewStringType::kNormal)\n+          .ToLocalChecked();\n+  module->Set(env->context(), exports_prop, exports).FromJust();\n+\n+  if (mod->nm_context_register_func != nullptr) {\n+    mod->nm_context_register_func(\n+        exports, module, env->context(), mod->nm_priv);\n+  } else if (mod->nm_register_func != nullptr) {\n+    mod->nm_register_func(exports, module, mod->nm_priv);\n+  } else {\n+    return env->ThrowError(\"Linked module has no declared entry point.\");\n+  }\n+\n+  auto effective_exports =\n+      module->Get(env->context(), exports_prop).ToLocalChecked();\n+\n+  args.GetReturnValue().Set(effective_exports);\n+}\n+\n+// Call built-in modules' _register_<module name> function to\n+// do module registration explicitly.\n+void RegisterBuiltinModules() {\n+#define V(modname) _register_##modname();\n+  NODE_BUILTIN_MODULES(V)\n+#undef V\n+}\n+\n+}  // namespace binding\n+}  // namespace node"
        },
        {
            "sha": "743c82accd09b87d5a6552aca2730f01611bd660",
            "filename": "src/node_binding.h",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode_binding.h",
            "raw_url": "https://github.com/nodejs/node/raw/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode_binding.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_binding.h?ref=3d668262a09ef031003babc14eff9e5d4ac81698",
            "patch": "@@ -0,0 +1,64 @@\n+#ifndef SRC_NODE_BINDING_H_\n+#define SRC_NODE_BINDING_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"node.h\"\n+#include \"node_api.h\"\n+#include \"uv.h\"\n+#include \"v8.h\"\n+\n+enum {\n+  NM_F_BUILTIN = 1 << 0,\n+  NM_F_LINKED = 1 << 1,\n+  NM_F_INTERNAL = 1 << 2,\n+};\n+\n+#define NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags)           \\\n+  static node::node_module _module = {                                         \\\n+      NODE_MODULE_VERSION,                                                     \\\n+      flags,                                                                   \\\n+      nullptr,                                                                 \\\n+      __FILE__,                                                                \\\n+      nullptr,                                                                 \\\n+      (node::addon_context_register_func)(regfunc),                            \\\n+      NODE_STRINGIFY(modname),                                                 \\\n+      priv,                                                                    \\\n+      nullptr};                                                                \\\n+  void _register_##modname() { node_module_register(&_module); }\n+\n+#define NODE_BUILTIN_MODULE_CONTEXT_AWARE(modname, regfunc)                    \\\n+  NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, nullptr, NM_F_BUILTIN)\n+\n+void napi_module_register_by_symbol(v8::Local<v8::Object> exports,\n+                                    v8::Local<v8::Value> module,\n+                                    v8::Local<v8::Context> context,\n+                                    napi_addon_register_func init);\n+\n+namespace node {\n+\n+#define NODE_MODULE_CONTEXT_AWARE_INTERNAL(modname, regfunc)                   \\\n+  NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, nullptr, NM_F_INTERNAL)\n+\n+// Globals per process\n+// This is set by node::Init() which is used by embedders\n+extern bool node_is_initialized;\n+\n+namespace binding {\n+\n+// Call _register<module_name> functions for all of\n+// the built-in modules. Because built-in modules don't\n+// use the __attribute__((constructor)). Need to\n+// explicitly call the _register* functions.\n+void RegisterBuiltinModules();\n+void GetBinding(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void GetInternalBinding(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void GetLinkedBinding(const v8::FunctionCallbackInfo<v8::Value>& args);\n+void DLOpen(const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n+}  // namespace binding\n+\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+#endif  // SRC_NODE_BINDING_H_"
        },
        {
            "sha": "6cb40c9070e6a071bcf885db78d3409238d853e1",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 3,
            "deletions": 109,
            "changes": 112,
            "blob_url": "https://github.com/nodejs/node/blob/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/3d668262a09ef031003babc14eff9e5d4ac81698/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=3d668262a09ef031003babc14eff9e5d4ac81698",
            "patch": "@@ -24,15 +24,15 @@\n \n #if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n \n+#include \"env-inl.h\"\n #include \"node.h\"\n+#include \"node_binding.h\"\n #include \"node_mutex.h\"\n #include \"node_persistent.h\"\n+#include \"tracing/trace_event.h\"\n #include \"util-inl.h\"\n-#include \"env-inl.h\"\n #include \"uv.h\"\n #include \"v8.h\"\n-#include \"tracing/trace_event.h\"\n-#include \"node_api.h\"\n \n #include <stdint.h>\n #include <stdlib.h>\n@@ -57,12 +57,6 @@\n #define Z_MAX_LEVEL 9\n #define Z_DEFAULT_LEVEL Z_DEFAULT_COMPRESSION\n \n-enum {\n-  NM_F_BUILTIN  = 1 << 0,\n-  NM_F_LINKED   = 1 << 1,\n-  NM_F_INTERNAL = 1 << 2,\n-};\n-\n struct sockaddr;\n \n // Variation on NODE_DEFINE_CONSTANT that sets a String value.\n@@ -83,92 +77,6 @@ struct sockaddr;\n                               constant_attributes).FromJust();                \\\n   } while (0)\n \n-\n-#if HAVE_OPENSSL\n-#define NODE_BUILTIN_OPENSSL_MODULES(V) V(crypto) V(tls_wrap)\n-#else\n-#define NODE_BUILTIN_OPENSSL_MODULES(V)\n-#endif\n-\n-#if NODE_HAVE_I18N_SUPPORT\n-#define NODE_BUILTIN_ICU_MODULES(V) V(icu)\n-#else\n-#define NODE_BUILTIN_ICU_MODULES(V)\n-#endif\n-\n-// A list of built-in modules. In order to do module registration\n-// in node::Init(), need to add built-in modules in the following list.\n-// Then in node::RegisterBuiltinModules(), it calls modules' registration\n-// function. This helps the built-in modules are loaded properly when\n-// node is built as static library. No need to depend on the\n-// __attribute__((constructor)) like mechanism in GCC.\n-#define NODE_BUILTIN_STANDARD_MODULES(V)                                       \\\n-  V(async_wrap)                                                                \\\n-  V(buffer)                                                                    \\\n-  V(cares_wrap)                                                                \\\n-  V(config)                                                                    \\\n-  V(contextify)                                                                \\\n-  V(domain)                                                                    \\\n-  V(fs)                                                                        \\\n-  V(fs_event_wrap)                                                             \\\n-  V(heap_utils)                                                                \\\n-  V(http2)                                                                     \\\n-  V(http_parser)                                                               \\\n-  V(inspector)                                                                 \\\n-  V(js_stream)                                                                 \\\n-  V(messaging)                                                                 \\\n-  V(module_wrap)                                                               \\\n-  V(native_module)                                                             \\\n-  V(options)                                                                   \\\n-  V(os)                                                                        \\\n-  V(performance)                                                               \\\n-  V(pipe_wrap)                                                                 \\\n-  V(process_wrap)                                                              \\\n-  V(serdes)                                                                    \\\n-  V(signal_wrap)                                                               \\\n-  V(spawn_sync)                                                                \\\n-  V(stream_pipe)                                                               \\\n-  V(stream_wrap)                                                               \\\n-  V(string_decoder)                                                            \\\n-  V(symbols)                                                                   \\\n-  V(tcp_wrap)                                                                  \\\n-  V(timers)                                                                    \\\n-  V(trace_events)                                                              \\\n-  V(tty_wrap)                                                                  \\\n-  V(types)                                                                     \\\n-  V(udp_wrap)                                                                  \\\n-  V(url)                                                                       \\\n-  V(util)                                                                      \\\n-  V(uv)                                                                        \\\n-  V(v8)                                                                        \\\n-  V(worker)                                                                    \\\n-  V(zlib)\n-\n-#define NODE_BUILTIN_MODULES(V)                                               \\\n-  NODE_BUILTIN_STANDARD_MODULES(V)                                            \\\n-  NODE_BUILTIN_OPENSSL_MODULES(V)                                             \\\n-  NODE_BUILTIN_ICU_MODULES(V)\n-\n-#define NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags)          \\\n-  static node::node_module _module = {                                        \\\n-    NODE_MODULE_VERSION,                                                      \\\n-    flags,                                                                    \\\n-    nullptr,                                                                  \\\n-    __FILE__,                                                                 \\\n-    nullptr,                                                                  \\\n-    (node::addon_context_register_func) (regfunc),                            \\\n-    NODE_STRINGIFY(modname),                                                  \\\n-    priv,                                                                     \\\n-    nullptr                                                                   \\\n-  };                                                                          \\\n-  void _register_ ## modname() {                                              \\\n-    node_module_register(&_module);                                           \\\n-  }\n-\n-\n-#define NODE_BUILTIN_MODULE_CONTEXT_AWARE(modname, regfunc)                   \\\n-  NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, nullptr, NM_F_BUILTIN)\n-\n namespace node {\n \n namespace native_module {\n@@ -281,12 +189,6 @@ void SetupProcessObject(Environment* env,\n                         const std::vector<std::string>& args,\n                         const std::vector<std::string>& exec_args);\n \n-// Call _register<module_name> functions for all of\n-// the built-in modules. Because built-in modules don't\n-// use the __attribute__((constructor)). Need to\n-// explicitly call the _register* functions.\n-void RegisterBuiltinModules();\n-\n enum Endianness {\n   kLittleEndian,  // _Not_ LITTLE_ENDIAN, clashes with endian.h.\n   kBigEndian\n@@ -782,9 +684,6 @@ static inline const char* errno_string(int errorno) {\n   }\n }\n \n-#define NODE_MODULE_CONTEXT_AWARE_INTERNAL(modname, regfunc)                  \\\n-  NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, nullptr, NM_F_INTERNAL)\n-\n #define TRACING_CATEGORY_NODE \"node\"\n #define TRACING_CATEGORY_NODE1(one)                                           \\\n     TRACING_CATEGORY_NODE \",\"                                                 \\\n@@ -857,11 +756,6 @@ void DefineZlibConstants(v8::Local<v8::Object> target);\n \n }  // namespace node\n \n-void napi_module_register_by_symbol(v8::Local<v8::Object> exports,\n-                                    v8::Local<v8::Value> module,\n-                                    v8::Local<v8::Context> context,\n-                                    napi_addon_register_func init);\n-\n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n \n #endif  // SRC_NODE_INTERNALS_H_"
        }
    ],
    "stats": {
        "total": 1061,
        "additions": 552,
        "deletions": 509
    }
}