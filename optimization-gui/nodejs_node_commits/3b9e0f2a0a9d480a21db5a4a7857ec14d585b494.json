{
    "author": "addaleax",
    "message": "zlib: split JS code as prep for non-zlib-backed streams\n\nSplit the `Zlib` class into `ZlibBase` and `Zlib` classes,\nto facilitate introduction of similar streams with minor\nimplementation differences.\n\nPR-URL: https://github.com/nodejs/node/pull/24939\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "3b9e0f2a0a9d480a21db5a4a7857ec14d585b494",
    "files": [
        {
            "sha": "a5d7ee82e33b3aeef700f23b9b94526635224954",
            "filename": "lib/zlib.js",
            "status": "modified",
            "additions": 129,
            "deletions": 112,
            "changes": 241,
            "blob_url": "https://github.com/nodejs/node/blob/3b9e0f2a0a9d480a21db5a4a7857ec14d585b494/lib%2Fzlib.js",
            "raw_url": "https://github.com/nodejs/node/raw/3b9e0f2a0a9d480a21db5a4a7857ec14d585b494/lib%2Fzlib.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fzlib.js?ref=3b9e0f2a0a9d480a21db5a4a7857ec14d585b494",
            "patch": "@@ -207,21 +207,10 @@ function checkRangesOrGetDefault(number, name, lower, upper, def) {\n   return number;\n }\n \n-// the Zlib class they all inherit from\n-// This thing manages the queue of requests, and returns\n-// true or false if there is anything in the queue when\n-// you call the .write() method.\n-function Zlib(opts, mode) {\n+// The base class for all Zlib-style streams.\n+function ZlibBase(opts, mode, handle, { flush, finishFlush, fullFlush }) {\n   var chunkSize = Z_DEFAULT_CHUNK;\n-  var flush = Z_NO_FLUSH;\n-  var finishFlush = Z_FINISH;\n-  var windowBits = Z_DEFAULT_WINDOWBITS;\n-  var level = Z_DEFAULT_COMPRESSION;\n-  var memLevel = Z_DEFAULT_MEMLEVEL;\n-  var strategy = Z_DEFAULT_STRATEGY;\n-  var dictionary;\n-\n-  // The Zlib class is not exported to user land, the mode should only be\n+  // The ZlibBase class is not exported to user land, the mode should only be\n   // passed in by us.\n   assert(typeof mode === 'number');\n   assert(mode >= DEFLATE && mode <= UNZIP);\n@@ -237,50 +226,11 @@ function Zlib(opts, mode) {\n \n     flush = checkRangesOrGetDefault(\n       opts.flush, 'options.flush',\n-      Z_NO_FLUSH, Z_BLOCK, Z_NO_FLUSH);\n+      Z_NO_FLUSH, Z_BLOCK, flush);\n \n     finishFlush = checkRangesOrGetDefault(\n       opts.finishFlush, 'options.finishFlush',\n-      Z_NO_FLUSH, Z_BLOCK, Z_FINISH);\n-\n-    // windowBits is special. On the compression side, 0 is an invalid value.\n-    // But on the decompression side, a value of 0 for windowBits tells zlib\n-    // to use the window size in the zlib header of the compressed stream.\n-    if ((opts.windowBits == null || opts.windowBits === 0) &&\n-        (mode === INFLATE ||\n-         mode === GUNZIP ||\n-         mode === UNZIP)) {\n-      windowBits = 0;\n-    } else {\n-      windowBits = checkRangesOrGetDefault(\n-        opts.windowBits, 'options.windowBits',\n-        Z_MIN_WINDOWBITS, Z_MAX_WINDOWBITS, Z_DEFAULT_WINDOWBITS);\n-    }\n-\n-    level = checkRangesOrGetDefault(\n-      opts.level, 'options.level',\n-      Z_MIN_LEVEL, Z_MAX_LEVEL, Z_DEFAULT_COMPRESSION);\n-\n-    memLevel = checkRangesOrGetDefault(\n-      opts.memLevel, 'options.memLevel',\n-      Z_MIN_MEMLEVEL, Z_MAX_MEMLEVEL, Z_DEFAULT_MEMLEVEL);\n-\n-    strategy = checkRangesOrGetDefault(\n-      opts.strategy, 'options.strategy',\n-      Z_DEFAULT_STRATEGY, Z_FIXED, Z_DEFAULT_STRATEGY);\n-\n-    dictionary = opts.dictionary;\n-    if (dictionary !== undefined && !isArrayBufferView(dictionary)) {\n-      if (isAnyArrayBuffer(dictionary)) {\n-        dictionary = Buffer.from(dictionary);\n-      } else {\n-        throw new ERR_INVALID_ARG_TYPE(\n-          'options.dictionary',\n-          ['Buffer', 'TypedArray', 'DataView', 'ArrayBuffer'],\n-          dictionary\n-        );\n-      }\n-    }\n+      Z_NO_FLUSH, Z_BLOCK, finishFlush);\n \n     if (opts.encoding || opts.objectMode || opts.writableObjectMode) {\n       opts = _extend({}, opts);\n@@ -289,40 +239,29 @@ function Zlib(opts, mode) {\n       opts.writableObjectMode = false;\n     }\n   }\n+\n   Transform.call(this, opts);\n+  this._hadError = false;\n   this.bytesWritten = 0;\n-  this._handle = new binding.Zlib(mode);\n+  this._handle = handle;\n+  handle[owner_symbol] = this;\n   // Used by processCallback() and zlibOnError()\n-  this._handle[owner_symbol] = this;\n-  this._handle.onerror = zlibOnError;\n-  this._hadError = false;\n-  this._writeState = new Uint32Array(2);\n-\n-  if (!this._handle.init(windowBits,\n-                         level,\n-                         memLevel,\n-                         strategy,\n-                         this._writeState,\n-                         processCallback,\n-                         dictionary)) {\n-    throw new ERR_ZLIB_INITIALIZATION_FAILED();\n-  }\n-\n+  handle.onerror = zlibOnError;\n   this._outBuffer = Buffer.allocUnsafe(chunkSize);\n   this._outOffset = 0;\n-  this._level = level;\n-  this._strategy = strategy;\n+\n   this._chunkSize = chunkSize;\n   this._defaultFlushFlag = flush;\n   this._finishFlushFlag = finishFlush;\n   this._nextFlush = -1;\n-  this._info = opts && opts.info;\n+  this._defaultFullFlushFlag = fullFlush;\n   this.once('end', this.close);\n+  this._info = opts && opts.info;\n }\n-Object.setPrototypeOf(Zlib.prototype, Transform.prototype);\n-Object.setPrototypeOf(Zlib, Transform);\n+Object.setPrototypeOf(ZlibBase.prototype, Transform.prototype);\n+Object.setPrototypeOf(ZlibBase, Transform);\n \n-Object.defineProperty(Zlib.prototype, '_closed', {\n+Object.defineProperty(ZlibBase.prototype, '_closed', {\n   configurable: true,\n   enumerable: true,\n   get() {\n@@ -334,7 +273,7 @@ Object.defineProperty(Zlib.prototype, '_closed', {\n // perspective, but it is inconsistent with all other streams exposed by Node.js\n // that have this concept, where it stands for the number of bytes read\n // *from* the stream (that is, net.Socket/tls.Socket & file system streams).\n-Object.defineProperty(Zlib.prototype, 'bytesRead', {\n+Object.defineProperty(ZlibBase.prototype, 'bytesRead', {\n   configurable: true,\n   enumerable: true,\n   get: deprecate(function() {\n@@ -347,41 +286,15 @@ Object.defineProperty(Zlib.prototype, 'bytesRead', {\n      'This feature will be removed in the future.', 'DEP0108')\n });\n \n-// This callback is used by `.params()` to wait until a full flush happened\n-// before adjusting the parameters. In particular, the call to the native\n-// `params()` function should not happen while a write is currently in progress\n-// on the threadpool.\n-function paramsAfterFlushCallback(level, strategy, callback) {\n-  assert(this._handle, 'zlib binding closed');\n-  this._handle.params(level, strategy);\n-  if (!this._hadError) {\n-    this._level = level;\n-    this._strategy = strategy;\n-    if (callback) callback();\n-  }\n-}\n-\n-Zlib.prototype.params = function params(level, strategy, callback) {\n-  checkRangesOrGetDefault(level, 'level', Z_MIN_LEVEL, Z_MAX_LEVEL);\n-  checkRangesOrGetDefault(strategy, 'strategy', Z_DEFAULT_STRATEGY, Z_FIXED);\n-\n-  if (this._level !== level || this._strategy !== strategy) {\n-    this.flush(Z_SYNC_FLUSH,\n-               paramsAfterFlushCallback.bind(this, level, strategy, callback));\n-  } else {\n-    process.nextTick(callback);\n-  }\n-};\n-\n-Zlib.prototype.reset = function reset() {\n+ZlibBase.prototype.reset = function() {\n   if (!this._handle)\n     assert(false, 'zlib binding closed');\n   return this._handle.reset();\n };\n \n // This is the _flush function called by the transform class,\n // internally, when the last chunk has been written.\n-Zlib.prototype._flush = function _flush(callback) {\n+ZlibBase.prototype._flush = function(callback) {\n   this._transform(Buffer.alloc(0), '', callback);\n };\n \n@@ -402,12 +315,12 @@ function maxFlush(a, b) {\n }\n \n const flushBuffer = Buffer.alloc(0);\n-Zlib.prototype.flush = function flush(kind, callback) {\n+ZlibBase.prototype.flush = function(kind, callback) {\n   var ws = this._writableState;\n \n   if (typeof kind === 'function' || (kind === undefined && !callback)) {\n     callback = kind;\n-    kind = Z_FULL_FLUSH;\n+    kind = this._defaultFullFlushFlag;\n   }\n \n   if (ws.ended) {\n@@ -426,17 +339,17 @@ Zlib.prototype.flush = function flush(kind, callback) {\n   }\n };\n \n-Zlib.prototype.close = function close(callback) {\n+ZlibBase.prototype.close = function(callback) {\n   _close(this, callback);\n   this.destroy();\n };\n \n-Zlib.prototype._destroy = function _destroy(err, callback) {\n+ZlibBase.prototype._destroy = function(err, callback) {\n   _close(this);\n   callback(err);\n };\n \n-Zlib.prototype._transform = function _transform(chunk, encoding, cb) {\n+ZlibBase.prototype._transform = function(chunk, encoding, cb) {\n   var flushFlag = this._defaultFlushFlag;\n   // We use a 'fake' zero-length chunk to carry information about flushes from\n   // the public API to the actual stream implementation.\n@@ -453,7 +366,7 @@ Zlib.prototype._transform = function _transform(chunk, encoding, cb) {\n   processChunk(this, chunk, flushFlag, cb);\n };\n \n-Zlib.prototype._processChunk = function _processChunk(chunk, flushFlag, cb) {\n+ZlibBase.prototype._processChunk = function(chunk, flushFlag, cb) {\n   // _processChunk() is left for backwards compatibility\n   if (typeof cb === 'function')\n     processChunk(this, chunk, flushFlag, cb);\n@@ -643,6 +556,110 @@ function _close(engine, callback) {\n   engine._handle = null;\n }\n \n+const zlibDefaultOpts = {\n+  flush: Z_NO_FLUSH,\n+  finishFlush: Z_FINISH,\n+  fullFlush: Z_FULL_FLUSH\n+};\n+// Base class for all streams actually backed by zlib and using zlib-specific\n+// parameters.\n+function Zlib(opts, mode) {\n+  var windowBits = Z_DEFAULT_WINDOWBITS;\n+  var level = Z_DEFAULT_COMPRESSION;\n+  var memLevel = Z_DEFAULT_MEMLEVEL;\n+  var strategy = Z_DEFAULT_STRATEGY;\n+  var dictionary;\n+\n+  if (opts) {\n+    // windowBits is special. On the compression side, 0 is an invalid value.\n+    // But on the decompression side, a value of 0 for windowBits tells zlib\n+    // to use the window size in the zlib header of the compressed stream.\n+    if ((opts.windowBits == null || opts.windowBits === 0) &&\n+        (mode === INFLATE ||\n+         mode === GUNZIP ||\n+         mode === UNZIP)) {\n+      windowBits = 0;\n+    } else {\n+      windowBits = checkRangesOrGetDefault(\n+        opts.windowBits, 'options.windowBits',\n+        Z_MIN_WINDOWBITS, Z_MAX_WINDOWBITS, Z_DEFAULT_WINDOWBITS);\n+    }\n+\n+    level = checkRangesOrGetDefault(\n+      opts.level, 'options.level',\n+      Z_MIN_LEVEL, Z_MAX_LEVEL, Z_DEFAULT_COMPRESSION);\n+\n+    memLevel = checkRangesOrGetDefault(\n+      opts.memLevel, 'options.memLevel',\n+      Z_MIN_MEMLEVEL, Z_MAX_MEMLEVEL, Z_DEFAULT_MEMLEVEL);\n+\n+    strategy = checkRangesOrGetDefault(\n+      opts.strategy, 'options.strategy',\n+      Z_DEFAULT_STRATEGY, Z_FIXED, Z_DEFAULT_STRATEGY);\n+\n+    dictionary = opts.dictionary;\n+    if (dictionary !== undefined && !isArrayBufferView(dictionary)) {\n+      if (isAnyArrayBuffer(dictionary)) {\n+        dictionary = Buffer.from(dictionary);\n+      } else {\n+        throw new ERR_INVALID_ARG_TYPE(\n+          'options.dictionary',\n+          ['Buffer', 'TypedArray', 'DataView', 'ArrayBuffer'],\n+          dictionary\n+        );\n+      }\n+    }\n+  }\n+\n+  const handle = new binding.Zlib(mode);\n+  // Ideally, we could let ZlibBase() set up _writeState. I haven't been able\n+  // to come up with a good solution that doesn't break our internal API,\n+  // and with it all supported npm versions at the time of writing.\n+  this._writeState = new Uint32Array(2);\n+  if (!handle.init(windowBits,\n+                   level,\n+                   memLevel,\n+                   strategy,\n+                   this._writeState,\n+                   processCallback,\n+                   dictionary)) {\n+    throw new ERR_ZLIB_INITIALIZATION_FAILED();\n+  }\n+\n+  ZlibBase.call(this, opts, mode, handle, zlibDefaultOpts);\n+\n+  this._level = level;\n+  this._strategy = strategy;\n+}\n+Object.setPrototypeOf(Zlib.prototype, ZlibBase.prototype);\n+Object.setPrototypeOf(Zlib, ZlibBase);\n+\n+// This callback is used by `.params()` to wait until a full flush happened\n+// before adjusting the parameters. In particular, the call to the native\n+// `params()` function should not happen while a write is currently in progress\n+// on the threadpool.\n+function paramsAfterFlushCallback(level, strategy, callback) {\n+  assert(this._handle, 'zlib binding closed');\n+  this._handle.params(level, strategy);\n+  if (!this._hadError) {\n+    this._level = level;\n+    this._strategy = strategy;\n+    if (callback) callback();\n+  }\n+}\n+\n+Zlib.prototype.params = function params(level, strategy, callback) {\n+  checkRangesOrGetDefault(level, 'level', Z_MIN_LEVEL, Z_MAX_LEVEL);\n+  checkRangesOrGetDefault(strategy, 'strategy', Z_DEFAULT_STRATEGY, Z_FIXED);\n+\n+  if (this._level !== level || this._strategy !== strategy) {\n+    this.flush(Z_SYNC_FLUSH,\n+               paramsAfterFlushCallback.bind(this, level, strategy, callback));\n+  } else {\n+    process.nextTick(callback);\n+  }\n+};\n+\n // generic zlib\n // minimal 2-byte header\n function Deflate(opts) {"
        }
    ],
    "stats": {
        "total": 241,
        "additions": 129,
        "deletions": 112
    }
}