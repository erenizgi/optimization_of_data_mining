{
    "author": "bnoordhuis",
    "message": "crypto: add scrypt() and scryptSync() methods\n\nScrypt is a password-based key derivation function that is designed to\nbe expensive both computationally and memory-wise in order to make\nbrute-force attacks unrewarding.\n\nOpenSSL has had support for the scrypt algorithm since v1.1.0.  Add a\nNode.js API modeled after `crypto.pbkdf2()` and `crypto.pbkdf2Sync()`.\n\nChanges:\n\n* Introduce helpers for copying buffers, collecting openssl errors, etc.\n\n* Add new infrastructure for offloading crypto to a worker thread.\n\n* Add a `AsyncWrap` JS class to simplify pbkdf2(), randomBytes() and\n  scrypt().\n\nFixes: https://github.com/nodejs/node/issues/8417\nPR-URL: https://github.com/nodejs/node/pull/20816\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>",
    "sha": "371103dae8b97264471e17de1989199ffcd2718e",
    "files": [
        {
            "sha": "c88f856ed262661375105d56a800001e59a9e7fb",
            "filename": "doc/api/crypto.md",
            "status": "modified",
            "additions": 95,
            "deletions": 11,
            "changes": 106,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/doc%2Fapi%2Fcrypto.md",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/doc%2Fapi%2Fcrypto.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fcrypto.md?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -1361,9 +1361,9 @@ password always creates the same key. The low iteration count and\n non-cryptographically secure hash algorithm allow passwords to be tested very\n rapidly.\n \n-In line with OpenSSL's recommendation to use PBKDF2 instead of\n+In line with OpenSSL's recommendation to use a more modern algorithm instead of\n [`EVP_BytesToKey`][] it is recommended that developers derive a key and IV on\n-their own using [`crypto.pbkdf2()`][] and to use [`crypto.createCipheriv()`][]\n+their own using [`crypto.scrypt()`][] and to use [`crypto.createCipheriv()`][]\n to create the `Cipher` object. Users should not use ciphers with counter mode\n (e.g. CTR, GCM, or CCM) in `crypto.createCipher()`. A warning is emitted when\n they are used in order to avoid the risk of IV reuse that causes\n@@ -1463,9 +1463,9 @@ password always creates the same key. The low iteration count and\n non-cryptographically secure hash algorithm allow passwords to be tested very\n rapidly.\n \n-In line with OpenSSL's recommendation to use PBKDF2 instead of\n+In line with OpenSSL's recommendation to use a more modern algorithm instead of\n [`EVP_BytesToKey`][] it is recommended that developers derive a key and IV on\n-their own using [`crypto.pbkdf2()`][] and to use [`crypto.createDecipheriv()`][]\n+their own using [`crypto.scrypt()`][] and to use [`crypto.createDecipheriv()`][]\n to create the `Decipher` object.\n \n ### crypto.createDecipheriv(algorithm, key, iv[, options])\n@@ -1801,9 +1801,8 @@ The `iterations` argument must be a number set as high as possible. The\n higher the number of iterations, the more secure the derived key will be,\n but will take a longer amount of time to complete.\n \n-The `salt` should also be as unique as possible. It is recommended that the\n-salts are random and their lengths are at least 16 bytes. See\n-[NIST SP 800-132][] for details.\n+The `salt` should be as unique as possible. It is recommended that a salt is\n+random and at least 16 bytes long. See [NIST SP 800-132][] for details.\n \n Example:\n \n@@ -1867,9 +1866,8 @@ The `iterations` argument must be a number set as high as possible. The\n higher the number of iterations, the more secure the derived key will be,\n but will take a longer amount of time to complete.\n \n-The `salt` should also be as unique as possible. It is recommended that the\n-salts are random and their lengths are at least 16 bytes. See\n-[NIST SP 800-132][] for details.\n+The `salt` should be as unique as possible. It is recommended that a salt is\n+random and at least 16 bytes long. See [NIST SP 800-132][] for details.\n \n Example:\n \n@@ -2143,6 +2141,91 @@ threadpool request. To minimize threadpool task length variation, partition\n large `randomFill` requests when doing so as part of fulfilling a client\n request.\n \n+### crypto.scrypt(password, salt, keylen[, options], callback)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `password` {string|Buffer|TypedArray}\n+- `salt` {string|Buffer|TypedArray}\n+- `keylen` {number}\n+- `options` {Object}\n+  - `N` {number} CPU/memory cost parameter. Must be a power of two greater\n+                 than one. **Default:** `16384`.\n+  - `r` {number} Block size parameter. **Default:** `8`.\n+  - `p` {number} Parallelization parameter. **Default:** `1`.\n+  - `maxmem` {number} Memory upper bound. It is an error when (approximately)\n+                      `128*N*r > maxmem` **Default:** `32 * 1024 * 1024`.\n+- `callback` {Function}\n+  - `err` {Error}\n+  - `derivedKey` {Buffer}\n+\n+Provides an asynchronous [scrypt][] implementation. Scrypt is a password-based\n+key derivation function that is designed to be expensive computationally and\n+memory-wise in order to make brute-force attacks unrewarding.\n+\n+The `salt` should be as unique as possible. It is recommended that a salt is\n+random and at least 16 bytes long. See [NIST SP 800-132][] for details.\n+\n+The `callback` function is called with two arguments: `err` and `derivedKey`.\n+`err` is an exception object when key derivation fails, otherwise `err` is\n+`null`. `derivedKey` is passed to the callback as a [`Buffer`][].\n+\n+An exception is thrown when any of the input arguments specify invalid values\n+or types.\n+\n+```js\n+const crypto = require('crypto');\n+// Using the factory defaults.\n+crypto.scrypt('secret', 'salt', 64, (err, derivedKey) => {\n+  if (err) throw err;\n+  console.log(derivedKey.toString('hex'));  // '3745e48...08d59ae'\n+});\n+// Using a custom N parameter. Must be a power of two.\n+crypto.scrypt('secret', 'salt', 64, { N: 1024 }, (err, derivedKey) => {\n+  if (err) throw err;\n+  console.log(derivedKey.toString('hex'));  // '3745e48...aa39b34'\n+});\n+```\n+\n+### crypto.scryptSync(password, salt, keylen[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+- `password` {string|Buffer|TypedArray}\n+- `salt` {string|Buffer|TypedArray}\n+- `keylen` {number}\n+- `options` {Object}\n+  - `N` {number} CPU/memory cost parameter. Must be a power of two greater\n+                 than one. **Default:** `16384`.\n+  - `r` {number} Block size parameter. **Default:** `8`.\n+  - `p` {number} Parallelization parameter. **Default:** `1`.\n+  - `maxmem` {number} Memory upper bound. It is an error when (approximately)\n+                      `128*N*r > maxmem` **Default:** `32 * 1024 * 1024`.\n+- Returns: {Buffer}\n+\n+Provides a synchronous [scrypt][] implementation. Scrypt is a password-based\n+key derivation function that is designed to be expensive computationally and\n+memory-wise in order to make brute-force attacks unrewarding.\n+\n+The `salt` should be as unique as possible. It is recommended that a salt is\n+random and at least 16 bytes long. See [NIST SP 800-132][] for details.\n+\n+An exception is thrown when key derivation fails, otherwise the derived key is\n+returned as a [`Buffer`][].\n+\n+An exception is thrown when any of the input arguments specify invalid values\n+or types.\n+\n+```js\n+const crypto = require('crypto');\n+// Using the factory defaults.\n+const key1 = crypto.scryptSync('secret', 'salt', 64);\n+console.log(key1.toString('hex'));  // '3745e48...08d59ae'\n+// Using a custom N parameter. Must be a power of two.\n+const key2 = crypto.scryptSync('secret', 'salt', 64, { N: 1024 });\n+console.log(key2.toString('hex'));  // '3745e48...aa39b34'\n+```\n+\n ### crypto.setEngine(engine[, flags])\n <!-- YAML\n added: v0.11.11\n@@ -2650,9 +2733,9 @@ the `crypto`, `tls`, and `https` modules and are generally specific to OpenSSL.\n [`crypto.createVerify()`]: #crypto_crypto_createverify_algorithm_options\n [`crypto.getCurves()`]: #crypto_crypto_getcurves\n [`crypto.getHashes()`]: #crypto_crypto_gethashes\n-[`crypto.pbkdf2()`]: #crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback\n [`crypto.randomBytes()`]: #crypto_crypto_randombytes_size_callback\n [`crypto.randomFill()`]: #crypto_crypto_randomfill_buffer_offset_size_callback\n+[`crypto.scrypt()`]: #crypto_crypto_scrypt_password_salt_keylen_options_callback\n [`decipher.final()`]: #crypto_decipher_final_outputencoding\n [`decipher.update()`]: #crypto_decipher_update_data_inputencoding_outputencoding\n [`diffieHellman.setPublicKey()`]: #crypto_diffiehellman_setpublickey_publickey_encoding\n@@ -2686,5 +2769,6 @@ the `crypto`, `tls`, and `https` modules and are generally specific to OpenSSL.\n [RFC 3610]: https://www.rfc-editor.org/rfc/rfc3610.txt\n [RFC 4055]: https://www.rfc-editor.org/rfc/rfc4055.txt\n [initialization vector]: https://en.wikipedia.org/wiki/Initialization_vector\n+[scrypt]: https://en.wikipedia.org/wiki/Scrypt\n [stream-writable-write]: stream.html#stream_writable_write_chunk_encoding_callback\n [stream]: stream.html"
        },
        {
            "sha": "68e12f36e01ed2ab331b76217d368f633595889d",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -739,6 +739,18 @@ An invalid [crypto digest algorithm][] was specified.\n A crypto method was used on an object that was in an invalid state. For\n instance, calling [`cipher.getAuthTag()`][] before calling `cipher.final()`.\n \n+<a id=\"ERR_CRYPTO_SCRYPT_INVALID_PARAMETER\"></a>\n+### ERR_CRYPTO_SCRYPT_INVALID_PARAMETER\n+\n+One or more [`crypto.scrypt()`][] or [`crypto.scryptSync()`][] parameters are\n+outside their legal range.\n+\n+<a id=\"ERR_CRYPTO_SCRYPT_NOT_SUPPORTED\"></a>\n+### ERR_CRYPTO_SCRYPT_NOT_SUPPORTED\n+\n+Node.js was compiled without `scrypt` support. Not possible with the official\n+release binaries but can happen with custom builds, including distro builds.\n+\n <a id=\"ERR_CRYPTO_SIGN_KEY_REQUIRED\"></a>\n ### ERR_CRYPTO_SIGN_KEY_REQUIRED\n \n@@ -1749,6 +1761,8 @@ Creation of a [`zlib`][] object failed due to incorrect configuration.\n [`child_process`]: child_process.html\n [`cipher.getAuthTag()`]: crypto.html#crypto_cipher_getauthtag\n [`Class: assert.AssertionError`]: assert.html#assert_class_assert_assertionerror\n+[`crypto.scrypt()`]: crypto.html#crypto_crypto_scrypt_password_salt_keylen_options_callback\n+[`crypto.scryptSync()`]: crypto.html#crypto_crypto_scryptSync_password_salt_keylen_options\n [`crypto.timingSafeEqual()`]: crypto.html#crypto_crypto_timingsafeequal_a_b\n [`dgram.createSocket()`]: dgram.html#dgram_dgram_createsocket_options_callback\n [`ERR_INVALID_ARG_TYPE`]: #ERR_INVALID_ARG_TYPE"
        },
        {
            "sha": "281a30c2cfa8f2bc54259e3d7f23a5a91e334207",
            "filename": "lib/crypto.js",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/lib%2Fcrypto.js",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/lib%2Fcrypto.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fcrypto.js?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -52,6 +52,10 @@ const {\n   pbkdf2,\n   pbkdf2Sync\n } = require('internal/crypto/pbkdf2');\n+const {\n+  scrypt,\n+  scryptSync\n+} = require('internal/crypto/scrypt');\n const {\n   DiffieHellman,\n   DiffieHellmanGroup,\n@@ -163,6 +167,8 @@ module.exports = exports = {\n   randomFill,\n   randomFillSync,\n   rng: randomBytes,\n+  scrypt,\n+  scryptSync,\n   setEngine,\n   timingSafeEqual,\n   getFips: !fipsMode ? getFipsDisabled :"
        },
        {
            "sha": "09771455ac2d9dabe6b080d8152581fb26b9d7f7",
            "filename": "lib/internal/crypto/scrypt.js",
            "status": "added",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/lib%2Finternal%2Fcrypto%2Fscrypt.js",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/lib%2Finternal%2Fcrypto%2Fscrypt.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fscrypt.js?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -0,0 +1,97 @@\n+'use strict';\n+\n+const { AsyncWrap, Providers } = process.binding('async_wrap');\n+const { Buffer } = require('buffer');\n+const { scrypt: _scrypt } = process.binding('crypto');\n+const {\n+  ERR_CRYPTO_SCRYPT_INVALID_PARAMETER,\n+  ERR_CRYPTO_SCRYPT_NOT_SUPPORTED,\n+  ERR_INVALID_CALLBACK,\n+} = require('internal/errors').codes;\n+const {\n+  checkIsArrayBufferView,\n+  checkIsUint,\n+  getDefaultEncoding,\n+} = require('internal/crypto/util');\n+\n+const defaults = {\n+  N: 16384,\n+  r: 8,\n+  p: 1,\n+  maxmem: 32 << 20,  // 32 MB, matches SCRYPT_MAX_MEM.\n+};\n+\n+function scrypt(password, salt, keylen, options, callback = defaults) {\n+  if (callback === defaults) {\n+    callback = options;\n+    options = defaults;\n+  }\n+\n+  options = check(password, salt, keylen, options);\n+  const { N, r, p, maxmem } = options;\n+  ({ password, salt, keylen } = options);\n+\n+  if (typeof callback !== 'function')\n+    throw new ERR_INVALID_CALLBACK();\n+\n+  const encoding = getDefaultEncoding();\n+  const keybuf = Buffer.alloc(keylen);\n+\n+  const wrap = new AsyncWrap(Providers.SCRYPTREQUEST);\n+  wrap.ondone = (ex) => {  // Retains keybuf while request is in flight.\n+    if (ex) return callback.call(wrap, ex);\n+    if (encoding === 'buffer') return callback.call(wrap, null, keybuf);\n+    callback.call(wrap, null, keybuf.toString(encoding));\n+  };\n+\n+  handleError(keybuf, password, salt, N, r, p, maxmem, wrap);\n+}\n+\n+function scryptSync(password, salt, keylen, options = defaults) {\n+  options = check(password, salt, keylen, options);\n+  const { N, r, p, maxmem } = options;\n+  ({ password, salt, keylen } = options);\n+  const keybuf = Buffer.alloc(keylen);\n+  handleError(keybuf, password, salt, N, r, p, maxmem);\n+  const encoding = getDefaultEncoding();\n+  if (encoding === 'buffer') return keybuf;\n+  return keybuf.toString(encoding);\n+}\n+\n+function handleError(keybuf, password, salt, N, r, p, maxmem, wrap) {\n+  const ex = _scrypt(keybuf, password, salt, N, r, p, maxmem, wrap);\n+\n+  if (ex === undefined)\n+    return;\n+\n+  if (ex === null)\n+    throw new ERR_CRYPTO_SCRYPT_INVALID_PARAMETER();  // Bad N, r, p, or maxmem.\n+\n+  throw ex;  // Scrypt operation failed, exception object contains details.\n+}\n+\n+function check(password, salt, keylen, options, callback) {\n+  if (_scrypt === undefined)\n+    throw new ERR_CRYPTO_SCRYPT_NOT_SUPPORTED();\n+\n+  password = checkIsArrayBufferView('password', password);\n+  salt = checkIsArrayBufferView('salt', salt);\n+  keylen = checkIsUint('keylen', keylen);\n+\n+  let { N, r, p, maxmem } = defaults;\n+  if (options && options !== defaults) {\n+    if (options.hasOwnProperty('N')) N = checkIsUint('N', options.N);\n+    if (options.hasOwnProperty('r')) r = checkIsUint('r', options.r);\n+    if (options.hasOwnProperty('p')) p = checkIsUint('p', options.p);\n+    if (options.hasOwnProperty('maxmem'))\n+      maxmem = checkIsUint('maxmem', options.maxmem);\n+    if (N === 0) N = defaults.N;\n+    if (r === 0) r = defaults.r;\n+    if (p === 0) p = defaults.p;\n+    if (maxmem === 0) maxmem = defaults.maxmem;\n+  }\n+\n+  return { password, salt, keylen, N, r, p, maxmem };\n+}\n+\n+module.exports = { scrypt, scryptSync };"
        },
        {
            "sha": "af844692d74defd3f08a3fff900f8ac9ae070240",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -500,7 +500,8 @@ E('ERR_CRYPTO_HASH_FINALIZED', 'Digest already called', Error);\n E('ERR_CRYPTO_HASH_UPDATE_FAILED', 'Hash update failed', Error);\n E('ERR_CRYPTO_INVALID_DIGEST', 'Invalid digest: %s', TypeError);\n E('ERR_CRYPTO_INVALID_STATE', 'Invalid state for operation %s', Error);\n-\n+E('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER', 'Invalid scrypt parameter', Error);\n+E('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED', 'Scrypt algorithm not supported', Error);\n // Switch to TypeError. The current implementation does not seem right.\n E('ERR_CRYPTO_SIGN_KEY_REQUIRED', 'No key provided to sign', Error);\n E('ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH',"
        },
        {
            "sha": "c3e4196c66c0255f064122fba7892cc55d5786a4",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -97,6 +97,7 @@\n       'lib/internal/crypto/hash.js',\n       'lib/internal/crypto/pbkdf2.js',\n       'lib/internal/crypto/random.js',\n+      'lib/internal/crypto/scrypt.js',\n       'lib/internal/crypto/sig.js',\n       'lib/internal/crypto/util.js',\n       'lib/internal/constants.js',"
        },
        {
            "sha": "7734c1b1017a8937c4fb2450e5e5b79859509eb4",
            "filename": "src/async_wrap.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/src%2Fasync_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/src%2Fasync_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.cc?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -45,6 +45,7 @@ using v8::PromiseHookType;\n using v8::PropertyCallbackInfo;\n using v8::RetainedObjectInfo;\n using v8::String;\n+using v8::Uint32;\n using v8::Undefined;\n using v8::Value;\n \n@@ -133,6 +134,23 @@ RetainedObjectInfo* WrapperInfo(uint16_t class_id, Local<Value> wrapper) {\n // end RetainedAsyncInfo\n \n \n+struct AsyncWrapObject : public AsyncWrap {\n+  static inline void New(const FunctionCallbackInfo<Value>& args) {\n+    Environment* env = Environment::GetCurrent(args);\n+    CHECK(args.IsConstructCall());\n+    CHECK(env->async_wrap_constructor_template()->HasInstance(args.This()));\n+    CHECK(args[0]->IsUint32());\n+    auto type = static_cast<ProviderType>(args[0].As<Uint32>()->Value());\n+    new AsyncWrapObject(env, args.This(), type);\n+  }\n+\n+  inline AsyncWrapObject(Environment* env, Local<Object> object,\n+                         ProviderType type) : AsyncWrap(env, object, type) {}\n+\n+  inline size_t self_size() const override { return sizeof(*this); }\n+};\n+\n+\n static void DestroyAsyncIdsCallback(Environment* env, void* data) {\n   Local<Function> fn = env->async_hooks_destroy_function();\n \n@@ -569,6 +587,19 @@ void AsyncWrap::Initialize(Local<Object> target,\n   env->set_async_hooks_destroy_function(Local<Function>());\n   env->set_async_hooks_promise_resolve_function(Local<Function>());\n   env->set_async_hooks_binding(target);\n+\n+  {\n+    auto class_name = FIXED_ONE_BYTE_STRING(env->isolate(), \"AsyncWrap\");\n+    auto function_template = env->NewFunctionTemplate(AsyncWrapObject::New);\n+    function_template->SetClassName(class_name);\n+    AsyncWrap::AddWrapMethods(env, function_template);\n+    auto instance_template = function_template->InstanceTemplate();\n+    instance_template->SetInternalFieldCount(1);\n+    auto function =\n+        function_template->GetFunction(env->context()).ToLocalChecked();\n+    target->Set(env->context(), class_name, function).FromJust();\n+    env->set_async_wrap_constructor_template(function_template);\n+  }\n }\n \n "
        },
        {
            "sha": "f696facd485188624bef40869805791d44230588",
            "filename": "src/async_wrap.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/src%2Fasync_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/src%2Fasync_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.h?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -75,6 +75,7 @@ namespace node {\n #define NODE_ASYNC_CRYPTO_PROVIDER_TYPES(V)                                   \\\n   V(PBKDF2REQUEST)                                                            \\\n   V(RANDOMBYTESREQUEST)                                                       \\\n+  V(SCRYPTREQUEST)                                                            \\\n   V(TLSWRAP)\n #else\n #define NODE_ASYNC_CRYPTO_PROVIDER_TYPES(V)"
        },
        {
            "sha": "266ef76647fc8b8ef9014f1c170d593c911e9af4",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -319,6 +319,7 @@ struct PackageConfig {\n   V(async_hooks_destroy_function, v8::Function)                               \\\n   V(async_hooks_init_function, v8::Function)                                  \\\n   V(async_hooks_promise_resolve_function, v8::Function)                       \\\n+  V(async_wrap_constructor_template, v8::FunctionTemplate)                    \\\n   V(buffer_prototype_object, v8::Object)                                      \\\n   V(context, v8::Context)                                                     \\\n   V(domain_callback, v8::Function)                                            \\"
        },
        {
            "sha": "cf7e7f0ee09ee486d8ea5b6e9d19edbb52c4b990",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 196,
            "deletions": 45,
            "changes": 241,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -78,6 +78,7 @@ using v8::Isolate;\n using v8::Local;\n using v8::Maybe;\n using v8::MaybeLocal;\n+using v8::NewStringType;\n using v8::Null;\n using v8::Object;\n using v8::ObjectTemplate;\n@@ -204,57 +205,75 @@ static int NoPasswordCallback(char* buf, int size, int rwflag, void* u) {\n }\n \n \n-void ThrowCryptoError(Environment* env,\n-                      unsigned long err,  // NOLINT(runtime/int)\n-                      const char* default_message = nullptr) {\n-  HandleScope scope(env->isolate());\n-  Local<String> message;\n+struct CryptoErrorVector : public std::vector<std::string> {\n+  inline void Capture() {\n+    clear();\n+    while (auto err = ERR_get_error()) {\n+      char buf[256];\n+      ERR_error_string_n(err, buf, sizeof(buf));\n+      push_back(buf);\n+    }\n+    std::reverse(begin(), end());\n+  }\n+\n+  inline Local<Value> ToException(\n+      Environment* env,\n+      Local<String> exception_string = Local<String>()) const {\n+    if (exception_string.IsEmpty()) {\n+      CryptoErrorVector copy(*this);\n+      if (copy.empty()) copy.push_back(\"no error\");  // But possibly a bug...\n+      // Use last element as the error message, everything else goes\n+      // into the .opensslErrorStack property on the exception object.\n+      auto exception_string =\n+          String::NewFromUtf8(env->isolate(), copy.back().data(),\n+                              NewStringType::kNormal, copy.back().size())\n+          .ToLocalChecked();\n+      copy.pop_back();\n+      return copy.ToException(env, exception_string);\n+    }\n \n-  if (err != 0 || default_message == nullptr) {\n-    char errmsg[128] = { 0 };\n-    ERR_error_string_n(err, errmsg, sizeof(errmsg));\n-    message = String::NewFromUtf8(env->isolate(), errmsg,\n-                                  v8::NewStringType::kNormal)\n-                                      .ToLocalChecked();\n-  } else {\n-    message = String::NewFromUtf8(env->isolate(), default_message,\n-                                  v8::NewStringType::kNormal)\n-                                      .ToLocalChecked();\n-  }\n+    Local<Value> exception_v = Exception::Error(exception_string);\n+    CHECK(!exception_v.IsEmpty());\n \n-  Local<Value> exception_v = Exception::Error(message);\n-  CHECK(!exception_v.IsEmpty());\n-  Local<Object> exception = exception_v.As<Object>();\n+    if (!empty()) {\n+      Local<Array> array = Array::New(env->isolate(), size());\n+      CHECK(!array.IsEmpty());\n \n-  std::vector<Local<String>> errors;\n-  for (;;) {\n-    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)\n-    if (err == 0) {\n-      break;\n-    }\n-    char tmp_str[256];\n-    ERR_error_string_n(err, tmp_str, sizeof(tmp_str));\n-    errors.push_back(String::NewFromUtf8(env->isolate(), tmp_str,\n-                                         v8::NewStringType::kNormal)\n-                     .ToLocalChecked());\n-  }\n-\n-  // ERR_get_error returns errors in order of most specific to least\n-  // specific. We wish to have the reverse ordering:\n-  // opensslErrorStack: [\n-  // 'error:0906700D:PEM routines:PEM_ASN1_read_bio:ASN1 lib',\n-  // 'error:0D07803A:asn1 encoding routines:ASN1_ITEM_EX_D2I:nested asn1 err'\n-  // ]\n-  if (!errors.empty()) {\n-    std::reverse(errors.begin(), errors.end());\n-    Local<Array> errors_array = Array::New(env->isolate(), errors.size());\n-    for (size_t i = 0; i < errors.size(); i++) {\n-      errors_array->Set(env->context(), i, errors[i]).FromJust();\n+      for (const std::string& string : *this) {\n+        const size_t index = &string - &front();\n+        Local<String> value =\n+            String::NewFromUtf8(env->isolate(), string.data(),\n+                                NewStringType::kNormal, string.size())\n+            .ToLocalChecked();\n+        array->Set(env->context(), index, value).FromJust();\n+      }\n+\n+      CHECK(exception_v->IsObject());\n+      Local<Object> exception = exception_v.As<Object>();\n+      exception->Set(env->context(),\n+                     env->openssl_error_stack(), array).FromJust();\n     }\n-    exception->Set(env->context(), env->openssl_error_stack(), errors_array)\n-        .FromJust();\n+\n+    return exception_v;\n   }\n+};\n+\n \n+void ThrowCryptoError(Environment* env,\n+                      unsigned long err,  // NOLINT(runtime/int)\n+                      const char* message = nullptr) {\n+  char message_buffer[128] = {0};\n+  if (err != 0 || message == nullptr) {\n+    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));\n+    message = message_buffer;\n+  }\n+  HandleScope scope(env->isolate());\n+  auto exception_string =\n+      String::NewFromUtf8(env->isolate(), message, NewStringType::kNormal)\n+      .ToLocalChecked();\n+  CryptoErrorVector errors;\n+  errors.Capture();\n+  auto exception = errors.ToException(env, exception_string);\n   env->isolate()->ThrowException(exception);\n }\n \n@@ -4529,6 +4548,43 @@ bool ECDH::IsKeyPairValid() {\n }\n \n \n+struct CryptoJob : public ThreadPoolWork {\n+  Environment* const env;\n+  std::unique_ptr<AsyncWrap> async_wrap;\n+  inline explicit CryptoJob(Environment* env) : ThreadPoolWork(env), env(env) {}\n+  inline void AfterThreadPoolWork(int status) final;\n+  virtual void AfterThreadPoolWork() = 0;\n+  static inline void Run(std::unique_ptr<CryptoJob> job, Local<Value> wrap);\n+};\n+\n+\n+void CryptoJob::AfterThreadPoolWork(int status) {\n+  CHECK(status == 0 || status == UV_ECANCELED);\n+  std::unique_ptr<CryptoJob> job(this);\n+  if (status == UV_ECANCELED) return;\n+  HandleScope handle_scope(env->isolate());\n+  Context::Scope context_scope(env->context());\n+  CHECK_EQ(false, async_wrap->persistent().IsWeak());\n+  AfterThreadPoolWork();\n+}\n+\n+\n+void CryptoJob::Run(std::unique_ptr<CryptoJob> job, Local<Value> wrap) {\n+  CHECK(wrap->IsObject());\n+  CHECK_EQ(nullptr, job->async_wrap);\n+  job->async_wrap.reset(Unwrap<AsyncWrap>(wrap.As<Object>()));\n+  CHECK_EQ(false, job->async_wrap->persistent().IsWeak());\n+  job->ScheduleWork();\n+  job.release();  // Run free, little job!\n+}\n+\n+\n+inline void CopyBuffer(Local<Value> buf, std::vector<char>* vec) {\n+  vec->clear();\n+  if (auto p = Buffer::Data(buf)) vec->assign(p, p + Buffer::Length(buf));\n+}\n+\n+\n class PBKDF2Request : public AsyncWrap, public ThreadPoolWork {\n  public:\n   PBKDF2Request(Environment* env,\n@@ -4870,6 +4926,98 @@ void RandomBytesBuffer(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n+#ifndef OPENSSL_NO_SCRYPT\n+struct ScryptJob : public CryptoJob {\n+  unsigned char* keybuf_data;\n+  size_t keybuf_size;\n+  std::vector<char> pass;\n+  std::vector<char> salt;\n+  uint32_t N;\n+  uint32_t r;\n+  uint32_t p;\n+  uint32_t maxmem;\n+  CryptoErrorVector errors;\n+\n+  inline explicit ScryptJob(Environment* env) : CryptoJob(env) {}\n+\n+  inline ~ScryptJob() override {\n+    Cleanse();\n+  }\n+\n+  inline bool Validate() {\n+    if (1 == EVP_PBE_scrypt(nullptr, 0, nullptr, 0, N, r, p, maxmem,\n+                            nullptr, 0)) {\n+      return true;\n+    } else {\n+      // Note: EVP_PBE_scrypt() does not always put errors on the error stack.\n+      errors.Capture();\n+      return false;\n+    }\n+  }\n+\n+  inline void DoThreadPoolWork() override {\n+    auto salt_data = reinterpret_cast<const unsigned char*>(salt.data());\n+    if (1 != EVP_PBE_scrypt(pass.data(), pass.size(), salt_data, salt.size(),\n+                            N, r, p, maxmem, keybuf_data, keybuf_size)) {\n+      errors.Capture();\n+    }\n+  }\n+\n+  inline void AfterThreadPoolWork() override {\n+    Local<Value> arg = ToResult();\n+    async_wrap->MakeCallback(env->ondone_string(), 1, &arg);\n+  }\n+\n+  inline Local<Value> ToResult() const {\n+    if (errors.empty()) return Undefined(env->isolate());\n+    return errors.ToException(env);\n+  }\n+\n+  inline void Cleanse() {\n+    OPENSSL_cleanse(pass.data(), pass.size());\n+    OPENSSL_cleanse(salt.data(), salt.size());\n+    pass.clear();\n+    salt.clear();\n+  }\n+};\n+\n+\n+void Scrypt(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  CHECK(args[0]->IsArrayBufferView());  // keybuf; wrap object retains ref.\n+  CHECK(args[1]->IsArrayBufferView());  // pass\n+  CHECK(args[2]->IsArrayBufferView());  // salt\n+  CHECK(args[3]->IsUint32());  // N\n+  CHECK(args[4]->IsUint32());  // r\n+  CHECK(args[5]->IsUint32());  // p\n+  CHECK(args[6]->IsUint32());  // maxmem\n+  CHECK(args[7]->IsObject() || args[7]->IsUndefined());  // wrap object\n+  std::unique_ptr<ScryptJob> job(new ScryptJob(env));\n+  job->keybuf_data = reinterpret_cast<unsigned char*>(Buffer::Data(args[0]));\n+  job->keybuf_size = Buffer::Length(args[0]);\n+  CopyBuffer(args[1], &job->pass);\n+  CopyBuffer(args[2], &job->salt);\n+  job->N = args[3].As<Uint32>()->Value();\n+  job->r = args[4].As<Uint32>()->Value();\n+  job->p = args[5].As<Uint32>()->Value();\n+  job->maxmem = args[6].As<Uint32>()->Value();\n+  if (!job->Validate()) {\n+    // EVP_PBE_scrypt() does not always put errors on the error stack\n+    // and therefore ToResult() may or may not return an exception\n+    // object.  Return a sentinel value to inform JS land it should\n+    // throw an ERR_CRYPTO_SCRYPT_PARAMETER_ERROR on our behalf.\n+    auto result = job->ToResult();\n+    if (result->IsUndefined()) result = Null(args.GetIsolate());\n+    return args.GetReturnValue().Set(result);\n+  }\n+  if (args[7]->IsObject()) return ScryptJob::Run(std::move(job), args[7]);\n+  env->PrintSyncTrace();\n+  job->DoThreadPoolWork();\n+  args.GetReturnValue().Set(job->ToResult());\n+}\n+#endif  // OPENSSL_NO_SCRYPT\n+\n+\n void GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n@@ -5293,6 +5441,9 @@ void Initialize(Local<Object> target,\n                  PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,\n                                          EVP_PKEY_verify_recover_init,\n                                          EVP_PKEY_verify_recover>);\n+#ifndef OPENSSL_NO_SCRYPT\n+  env->SetMethod(target, \"scrypt\", Scrypt);\n+#endif  // OPENSSL_NO_SCRYPT\n \n   Local<FunctionTemplate> pb = FunctionTemplate::New(env->isolate());\n   pb->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), \"PBKDF2\"));"
        },
        {
            "sha": "9b161ef43111fbbfc9500ababd481424d3864ebc",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -523,6 +523,8 @@ class InternalCallbackScope {\n class ThreadPoolWork {\n  public:\n   explicit inline ThreadPoolWork(Environment* env) : env_(env) {}\n+  inline virtual ~ThreadPoolWork() = default;\n+\n   inline void ScheduleWork();\n   inline int CancelWork();\n "
        },
        {
            "sha": "9d0e495881f186731a415fd5564ace03a4084d82",
            "filename": "test/parallel/test-crypto-scrypt.js",
            "status": "added",
            "additions": 165,
            "deletions": 0,
            "changes": 165,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/test%2Fparallel%2Ftest-crypto-scrypt.js",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/test%2Fparallel%2Ftest-crypto-scrypt.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-scrypt.js?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -0,0 +1,165 @@\n+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+\n+const assert = require('assert');\n+const crypto = require('crypto');\n+\n+if (typeof process.binding('crypto').scrypt !== 'function')\n+  common.skip('no scrypt support');\n+\n+const good = [\n+  // Zero-length key is legal, functions as a parameter validation check.\n+  {\n+    pass: '',\n+    salt: '',\n+    keylen: 0,\n+    N: 16,\n+    p: 1,\n+    r: 1,\n+    expected: '',\n+  },\n+  // Test vectors from https://tools.ietf.org/html/rfc7914#page-13 that\n+  // should pass.  Note that the test vector with N=1048576 is omitted\n+  // because it takes too long to complete and uses over 1 GB of memory.\n+  {\n+    pass: '',\n+    salt: '',\n+    keylen: 64,\n+    N: 16,\n+    p: 1,\n+    r: 1,\n+    expected:\n+        '77d6576238657b203b19ca42c18a0497f16b4844e3074ae8dfdffa3fede21442' +\n+        'fcd0069ded0948f8326a753a0fc81f17e8d3e0fb2e0d3628cf35e20c38d18906',\n+  },\n+  {\n+    pass: 'password',\n+    salt: 'NaCl',\n+    keylen: 64,\n+    N: 1024,\n+    p: 16,\n+    r: 8,\n+    expected:\n+        'fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b373162' +\n+        '2eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640',\n+  },\n+  {\n+    pass: 'pleaseletmein',\n+    salt: 'SodiumChloride',\n+    keylen: 64,\n+    N: 16384,\n+    p: 1,\n+    r: 8,\n+    expected:\n+        '7023bdcb3afd7348461c06cd81fd38ebfda8fbba904f8e3ea9b543f6545da1f2' +\n+        'd5432955613f0fcf62d49705242a9af9e61e85dc0d651e40dfcf017b45575887',\n+  },\n+];\n+\n+// Test vectors that should fail.\n+const bad = [\n+  { N: 1, p: 1, r: 1 },        // N < 2\n+  { N: 3, p: 1, r: 1 },        // Not power of 2.\n+  { N: 2 ** 16, p: 1, r: 1 },  // N >= 2**(r*16)\n+  { N: 2, p: 2 ** 30, r: 1 },  // p > (2**30-1)/r\n+];\n+\n+// Test vectors where 128*N*r exceeds maxmem.\n+const toobig = [\n+  { N: 2 ** 20, p: 1, r: 8 },\n+  { N: 2 ** 10, p: 1, r: 8, maxmem: 2 ** 20 },\n+];\n+\n+const badargs = [\n+  {\n+    args: [],\n+    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /\"password\"/ },\n+  },\n+  {\n+    args: [null],\n+    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /\"password\"/ },\n+  },\n+  {\n+    args: [''],\n+    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /\"salt\"/ },\n+  },\n+  {\n+    args: ['', null],\n+    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /\"salt\"/ },\n+  },\n+  {\n+    args: ['', ''],\n+    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /\"keylen\"/ },\n+  },\n+  {\n+    args: ['', '', null],\n+    expected: { code: 'ERR_INVALID_ARG_TYPE', message: /\"keylen\"/ },\n+  },\n+  {\n+    args: ['', '', .42],\n+    expected: { code: 'ERR_OUT_OF_RANGE', message: /\"keylen\"/ },\n+  },\n+  {\n+    args: ['', '', -42],\n+    expected: { code: 'ERR_OUT_OF_RANGE', message: /\"keylen\"/ },\n+  },\n+];\n+\n+for (const options of good) {\n+  const { pass, salt, keylen, expected } = options;\n+  const actual = crypto.scryptSync(pass, salt, keylen, options);\n+  assert.strictEqual(actual.toString('hex'), expected);\n+  crypto.scrypt(pass, salt, keylen, options, common.mustCall((err, actual) => {\n+    assert.ifError(err);\n+    assert.strictEqual(actual.toString('hex'), expected);\n+  }));\n+}\n+\n+for (const options of bad) {\n+  const expected = {\n+    code: 'ERR_CRYPTO_SCRYPT_INVALID_PARAMETER',\n+    message: 'Invalid scrypt parameter',\n+    type: Error,\n+  };\n+  common.expectsError(() => crypto.scrypt('pass', 'salt', 1, options, () => {}),\n+                      expected);\n+  common.expectsError(() => crypto.scryptSync('pass', 'salt', 1, options),\n+                      expected);\n+}\n+\n+for (const options of toobig) {\n+  const expected = {\n+    message: /error:[^:]+:digital envelope routines:EVP_PBE_scrypt:memory limit exceeded/,\n+    type: Error,\n+  };\n+  common.expectsError(() => crypto.scrypt('pass', 'salt', 1, options, () => {}),\n+                      expected);\n+  common.expectsError(() => crypto.scryptSync('pass', 'salt', 1, options),\n+                      expected);\n+}\n+\n+{\n+  const defaults = { N: 16384, p: 1, r: 8 };\n+  const expected = crypto.scryptSync('pass', 'salt', 1, defaults);\n+  const actual = crypto.scryptSync('pass', 'salt', 1);\n+  assert.deepStrictEqual(actual.toString('hex'), expected.toString('hex'));\n+  crypto.scrypt('pass', 'salt', 1, common.mustCall((err, actual) => {\n+    assert.ifError(err);\n+    assert.deepStrictEqual(actual.toString('hex'), expected.toString('hex'));\n+  }));\n+}\n+\n+for (const { args, expected } of badargs) {\n+  common.expectsError(() => crypto.scrypt(...args), expected);\n+  common.expectsError(() => crypto.scryptSync(...args), expected);\n+}\n+\n+{\n+  const expected = { code: 'ERR_INVALID_CALLBACK' };\n+  common.expectsError(() => crypto.scrypt('', '', 42, null), expected);\n+  common.expectsError(() => crypto.scrypt('', '', 42, {}, null), expected);\n+  common.expectsError(() => crypto.scrypt('', '', 42, {}), expected);\n+  common.expectsError(() => crypto.scrypt('', '', 42, {}, {}), expected);\n+}"
        },
        {
            "sha": "a17f509294a9ed5a52ab9f47be28815981abd538",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/371103dae8b97264471e17de1989199ffcd2718e/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/371103dae8b97264471e17de1989199ffcd2718e/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=371103dae8b97264471e17de1989199ffcd2718e",
            "patch": "@@ -122,6 +122,12 @@ if (common.hasCrypto) { // eslint-disable-line node-core/crypto-check\n   crypto.randomBytes(1, common.mustCall(function rb() {\n     testInitialized(this, 'RandomBytes');\n   }));\n+\n+  if (typeof process.binding('crypto').scrypt === 'function') {\n+    crypto.scrypt('password', 'salt', 8, common.mustCall(function() {\n+      testInitialized(this, 'AsyncWrap');\n+    }));\n+  }\n }\n \n "
        }
    ],
    "stats": {
        "total": 674,
        "additions": 617,
        "deletions": 57
    }
}