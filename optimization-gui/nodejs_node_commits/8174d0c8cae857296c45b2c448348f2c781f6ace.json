{
    "author": "cjihrig",
    "message": "deps: upgrade to libuv 1.22.0\n\nPR-URL: https://github.com/nodejs/node/pull/21731\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Santiago Gimeno <santiago.gimeno@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "8174d0c8cae857296c45b2c448348f2c781f6ace",
    "files": [
        {
            "sha": "ef3d5e181a800fa0599b6220fd7363d1861c296c",
            "filename": "deps/uv/AUTHORS",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FAUTHORS?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -343,3 +343,5 @@ Bj√∂rn Linse <bjorn.linse@gmail.com>\n zyxwvu Shi <i@shiyc.cn>\n Peter Johnson <johnson.peter@gmail.com>\n Paolo Greppi <paolo.greppi@libpf.com>\n+Shelley Vohr <shelley.vohr@gmail.com>\n+Ujjwal Sharma <usharma1998@gmail.com>"
        },
        {
            "sha": "a133edb8500fa2a8a3392843987a3de1cf59422e",
            "filename": "deps/uv/CMakeLists.txt",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FCMakeLists.txt",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FCMakeLists.txt",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FCMakeLists.txt?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -15,6 +15,7 @@ set(uv_sources\n     src/fs-poll.c\n     src/inet.c\n     src/threadpool.c\n+    src/timer.c\n     src/uv-common.c\n     src/uv-data-getter-setters.c\n     src/version.c)\n@@ -197,7 +198,6 @@ if(WIN32)\n        src/win/stream.c\n        src/win/tcp.c\n        src/win/tty.c\n-       src/win/timer.c\n        src/win/udp.c\n        src/win/util.c\n        src/win/winapi.c\n@@ -223,7 +223,6 @@ else()\n        src/unix/stream.c\n        src/unix/tcp.c\n        src/unix/thread.c\n-       src/unix/timer.c\n        src/unix/tty.c\n        src/unix/udp.c)\n   list(APPEND uv_test_sources test/runner-unix.c)"
        },
        {
            "sha": "acf42e0123a6c1cdc5f2cb35811bfe04a23bc19e",
            "filename": "deps/uv/ChangeLog",
            "status": "modified",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FChangeLog",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FChangeLog",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FChangeLog?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -1,3 +1,36 @@\n+2018.07.11, Version 1.22.0 (Stable), 8568f78a777d79d35eb7d6994617267b9fb33967\n+\n+Changes since version 1.21.0:\n+\n+* unix: remove checksparse.sh (Ben Noordhuis)\n+\n+* win: fix mingw build error (Ben Noordhuis)\n+\n+* win: fix -Wunused-function warnings in thread.c (Ben Noordhuis)\n+\n+* unix,win: merge timers implementation (Ben Noordhuis)\n+\n+* win: fix pointer type in pipe.c (Ben Noordhuis)\n+\n+* win: fixing build for older MSVC compilers (Michael Fero)\n+\n+* zos: clear poll events on every iteration (jBarz)\n+\n+* zos: write-protect message queue (jBarz)\n+\n+* zos: use correct pointer type in strnlen (jBarz)\n+\n+* unix,win: merge handle flags (Ben Noordhuis)\n+\n+* doc: update Imran Iqbal's GitHub handle (cjihrig)\n+\n+* src: add new error apis to prevent memory leaks (Shelley Vohr)\n+\n+* test: make test-condvar call uv_cond_wait (Jamie Davis)\n+\n+* fs: change position of uv_fs_lchown (Ujjwal Sharma)\n+\n+\n 2018.06.23, Version 1.21.0 (Stable), e4983a9b0c152932f7553ff4a9ff189d2314cdcb\n \n Changes since version 1.20.3:"
        },
        {
            "sha": "889ee4988c482cc5f5bd853eecf027c546eb9e9d",
            "filename": "deps/uv/MAINTAINERS.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FMAINTAINERS.md",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FMAINTAINERS.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FMAINTAINERS.md?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -12,7 +12,7 @@ libuv is currently managed by the following individuals:\n   - GPG key: 5735 3E0D BDAA A7E8 39B6  6A1A FF47 D5E4 AD8B 4FDC (pubkey-cjihrig-kb)\n * **Fedor Indutny** ([@indutny](https://github.com/indutny))\n   - GPG key: AF2E EA41 EC34 47BF DD86  FED9 D706 3CCE 19B7 E890 (pubkey-indutny)\n-* **Imran Iqbal** ([@iWuzHere](https://github.com/iWuzHere))\n+* **Imran Iqbal** ([@imran-iq](https://github.com/imran-iq))\n   - GPG key: 9DFE AA5F 481B BF77 2D90  03CE D592 4925 2F8E C41A (pubkey-iwuzhere)\n * **John Barboza** ([@jbarz](https://github.com/jbarz))\n * **Santiago Gimeno** ([@santigimeno](https://github.com/santigimeno))"
        },
        {
            "sha": "04aecab55558861fbf4a3ad8e4a1ee3af3a09127",
            "filename": "deps/uv/Makefile.am",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FMakefile.am",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2FMakefile.am",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FMakefile.am?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -32,6 +32,7 @@ libuv_la_SOURCES = src/fs-poll.c \\\n                    src/inet.c \\\n                    src/queue.h \\\n                    src/threadpool.c \\\n+                   src/timer.c \\\n                    src/uv-data-getter-setters.c \\\n                    src/uv-common.c \\\n                    src/uv-common.h \\\n@@ -74,7 +75,6 @@ libuv_la_SOURCES += src/win/async.c \\\n                     src/win/stream-inl.h \\\n                     src/win/tcp.c \\\n                     src/win/thread.c \\\n-                    src/win/timer.c \\\n                     src/win/tty.c \\\n                     src/win/udp.c \\\n                     src/win/util.c \\\n@@ -105,7 +105,6 @@ libuv_la_SOURCES += src/unix/async.c \\\n                    src/unix/stream.c \\\n                    src/unix/tcp.c \\\n                    src/unix/thread.c \\\n-                   src/unix/timer.c \\\n                    src/unix/tty.c \\\n                    src/unix/udp.c\n "
        },
        {
            "sha": "91f130d4f5893cf058769256f623d550c0f263a1",
            "filename": "deps/uv/checksparse.sh",
            "status": "removed",
            "additions": 0,
            "deletions": 254,
            "changes": 254,
            "blob_url": "https://github.com/nodejs/node/blob/9d71619bbee7c198cb20ec4702024ac983b5db7d/deps%2Fuv%2Fchecksparse.sh",
            "raw_url": "https://github.com/nodejs/node/raw/9d71619bbee7c198cb20ec4702024ac983b5db7d/deps%2Fuv%2Fchecksparse.sh",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fchecksparse.sh?ref=9d71619bbee7c198cb20ec4702024ac983b5db7d",
            "patch": "@@ -1,254 +0,0 @@\n-#!/bin/sh\n-\n-# Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>\n-#\n-# Permission to use, copy, modify, and/or distribute this software for any\n-# purpose with or without fee is hereby granted, provided that the above\n-# copyright notice and this permission notice appear in all copies.\n-#\n-# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n-# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n-# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n-# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n-# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n-# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n-\n-SPARSE=${SPARSE:-sparse}\n-\n-SPARSE_FLAGS=${SPARSE_FLAGS:-\"\n--D__POSIX__\n--Wsparse-all\n--Wno-do-while\n--Wno-transparent-union\n--Iinclude\n--Isrc\n-\"}\n-\n-SOURCES=\"\n-include/uv/tree.h\n-include/uv/unix.h\n-include/uv.h\n-src/fs-poll.c\n-src/inet.c\n-src/queue.h\n-src/unix/async.c\n-src/unix/core.c\n-src/unix/dl.c\n-src/unix/fs.c\n-src/unix/getaddrinfo.c\n-src/unix/internal.h\n-src/unix/loop-watcher.c\n-src/unix/loop.c\n-src/unix/pipe.c\n-src/unix/poll.c\n-src/unix/process.c\n-src/unix/signal.c\n-src/unix/stream.c\n-src/unix/tcp.c\n-src/unix/thread.c\n-src/unix/threadpool.c\n-src/unix/timer.c\n-src/unix/tty.c\n-src/unix/udp.c\n-src/uv-common.c\n-src/uv-common.h\n-src/uv-data-getter-setters.c\n-\"\n-\n-TESTS=\"\n-test/benchmark-async-pummel.c\n-test/benchmark-async.c\n-test/benchmark-fs-stat.c\n-test/benchmark-getaddrinfo.c\n-test/benchmark-loop-count.c\n-test/benchmark-million-async.c\n-test/benchmark-million-timers.c\n-test/benchmark-multi-accept.c\n-test/benchmark-ping-pongs.c\n-test/benchmark-pound.c\n-test/benchmark-pump.c\n-test/benchmark-sizes.c\n-test/benchmark-spawn.c\n-test/benchmark-tcp-write-batch.c\n-test/benchmark-thread.c\n-test/benchmark-udp-pummel.c\n-test/blackhole-server.c\n-test/dns-server.c\n-test/echo-server.c\n-test/run-benchmarks.c\n-test/run-tests.c\n-test/runner-unix.c\n-test/runner-unix.h\n-test/runner.c\n-test/runner.h\n-test/task.h\n-test/test-active.c\n-test/test-async.c\n-test/test-barrier.c\n-test/test-callback-order.c\n-test/test-callback-stack.c\n-test/test-condvar.c\n-test/test-connection-fail.c\n-test/test-cwd-and-chdir.c\n-test/test-delayed-accept.c\n-test/test-dlerror.c\n-test/test-embed.c\n-test/test-env-vars.c\n-test/test-error.c\n-test/test-fail-always.c\n-test/test-fs-copyfile.c\n-test/test-fs-event.c\n-test/test-fs-poll.c\n-test/test-fs.c\n-test/test-getters-setters.c\n-test/test-get-currentexe.c\n-test/test-get-loadavg.c\n-test/test-get-memory.c\n-test/test-get-passwd.c\n-test/test-getaddrinfo.c\n-test/test-gethostname.c\n-test/test-getsockname.c\n-test/test-homedir.c\n-test/test-hrtime.c\n-test/test-idle.c\n-test/test-ip6-addr.c\n-test/test-ipc-heavy-traffic-deadlock-bug.c\n-test/test-ipc-send-recv.c\n-test/test-ipc.c\n-test/test-loop-handles.c\n-test/test-multiple-listen.c\n-test/test-mutexes.c\n-test/test-pass-always.c\n-test/test-ping-pong.c\n-test/test-pipe-bind-error.c\n-test/test-pipe-connect-error.c\n-test/test-pipe-sendmsg.c\n-test/test-pipe-server-close.c\n-test/test-platform-output.c\n-test/test-poll-close.c\n-test/test-poll.c\n-test/test-process-title.c\n-test/test-process-title-threadsafe.c\n-test/test-ref.c\n-test/test-run-nowait.c\n-test/test-run-once.c\n-test/test-semaphore.c\n-test/test-shutdown-close.c\n-test/test-shutdown-eof.c\n-test/test-signal-multiple-loops.c\n-test/test-signal.c\n-test/test-spawn.c\n-test/test-stdio-over-pipes.c\n-test/test-tcp-bind-error.c\n-test/test-tcp-bind6-error.c\n-test/test-tcp-close-while-connecting.c\n-test/test-tcp-close-accept.c\n-test/test-tcp-close.c\n-test/test-tcp-connect-error-after-write.c\n-test/test-tcp-connect-error.c\n-test/test-tcp-connect-timeout.c\n-test/test-tcp-connect6-error.c\n-test/test-tcp-flags.c\n-test/test-tcp-open.c\n-test/test-tcp-read-stop.c\n-test/test-tcp-shutdown-after-write.c\n-test/test-tcp-unexpected-read.c\n-test/test-tcp-oob.c\n-test/test-tcp-write-error.c\n-test/test-tcp-write-to-half-open-connection.c\n-test/test-tcp-writealot.c\n-test/test-thread.c\n-test/test-threadpool-cancel.c\n-test/test-threadpool.c\n-test/test-timer-again.c\n-test/test-timer.c\n-test/test-tmpdir.c\n-test/test-tty.c\n-test/test-udp-dgram-too-big.c\n-test/test-udp-ipv6.c\n-test/test-udp-multicast-join.c\n-test/test-udp-multicast-ttl.c\n-test/test-udp-open.c\n-test/test-udp-options.c\n-test/test-udp-send-and-recv.c\n-test/test-udp-send-hang-loop.c\n-test/test-walk-handles.c\n-test/test-watcher-cross-stop.c\n-\"\n-\n-case `uname -s` in\n-AIX)\n-  SPARSE_FLAGS=\"$SPARSE_FLAGS -D_AIX=1\"\n-  SOURCES=\"$SOURCES\n-           src/unix/aix-common.c\n-           src/unix/aix.c\"\n-  ;;\n-OS400)\n-  SPARSE_FLAGS=\"$SPARSE_FLAGS -D__PASE__=1\"\n-  SOURCES=\"$SOURCES\n-           src/unix/aix-common.c\n-           src/unix/ibmi.c\n-           src/unix/posix-poll.c\n-           src/unix/no-fsevents.c\n-           src/unix/no-proctitle.c\"\n-  ;;\n-Darwin)\n-  SPARSE_FLAGS=\"$SPARSE_FLAGS -D__APPLE__=1\"\n-  SOURCES=\"$SOURCES\n-           include/uv/bsd.h\n-           src/unix/darwin.c\n-           src/unix/kqueue.c\n-           src/unix/fsevents.c\"\n-  ;;\n-DragonFly)\n-  SPARSE_FLAGS=\"$SPARSE_FLAGS -D__DragonFly__=1\"\n-  SOURCES=\"$SOURCES\n-           include/uv/bsd.h\n-           src/unix/kqueue.c\n-           src/unix/freebsd.c\"\n-  ;;\n-FreeBSD)\n-  SPARSE_FLAGS=\"$SPARSE_FLAGS -D__FreeBSD__=1\"\n-  SOURCES=\"$SOURCES\n-           include/uv/bsd.h\n-           src/unix/kqueue.c\n-           src/unix/freebsd.c\"\n-  ;;\n-Linux)\n-  SPARSE_FLAGS=\"$SPARSE_FLAGS -D__linux__=1\"\n-  SOURCES=\"$SOURCES\n-           include/uv/linux.h\n-           src/unix/linux-inotify.c\n-           src/unix/linux-core.c\n-           src/unix/linux-syscalls.c\n-           src/unix/linux-syscalls.h\"\n-  ;;\n-NetBSD)\n-  SPARSE_FLAGS=\"$SPARSE_FLAGS -D__NetBSD__=1\"\n-  SOURCES=\"$SOURCES\n-           include/uv/bsd.h\n-           src/unix/kqueue.c\n-           src/unix/netbsd.c\"\n-  ;;\n-OpenBSD)\n-  SPARSE_FLAGS=\"$SPARSE_FLAGS -D__OpenBSD__=1\"\n-  SOURCES=\"$SOURCES\n-           include/uv/bsd.h\n-           src/unix/kqueue.c\n-           src/unix/openbsd.c\"\n-  ;;\n-SunOS)\n-  SPARSE_FLAGS=\"$SPARSE_FLAGS -D__sun=1\"\n-  SOURCES=\"$SOURCES\n-           include/uv/sunos.h\n-           src/unix/sunos.c\"\n-  ;;\n-esac\n-\n-for ARCH in __i386__ __x86_64__ __arm__ __mips__; do\n-  $SPARSE $SPARSE_FLAGS -D$ARCH=1 $SOURCES\n-done\n-\n-# Tests are architecture independent.\n-$SPARSE $SPARSE_FLAGS -Itest $TESTS"
        },
        {
            "sha": "aa6e6d16a8c80463f5d1e55c8b820f55e11015a1",
            "filename": "deps/uv/configure.ac",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fconfigure.ac",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fconfigure.ac",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fconfigure.ac?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -13,7 +13,7 @@\n # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n \n AC_PREREQ(2.57)\n-AC_INIT([libuv], [1.21.0], [https://github.com/libuv/libuv/issues])\n+AC_INIT([libuv], [1.22.0], [https://github.com/libuv/libuv/issues])\n AC_CONFIG_MACRO_DIR([m4])\n m4_include([m4/libuv-extra-automake-flags.m4])\n m4_include([m4/as_case.m4])"
        },
        {
            "sha": "b8f971f5763511998982658ab7e53914eab63bb1",
            "filename": "deps/uv/docs/src/errors.rst",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fdocs%2Fsrc%2Ferrors.rst",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fdocs%2Fsrc%2Ferrors.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Ferrors.rst?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -335,11 +335,25 @@ API\n     Returns the error message for the given error code.  Leaks a few bytes\n     of memory when you call it with an unknown error code.\n \n+.. c:function:: char* uv_strerror_r(int err, char* buf, size_t buflen)\n+\n+    Returns the error message for the given error code. The zero-terminated\n+    message is stored in the user-supplied buffer `buf` of at most `buflen` bytes.\n+\n+    .. versionadded:: 1.22.0\n+\n .. c:function:: const char* uv_err_name(int err)\n \n     Returns the error name for the given error code.  Leaks a few bytes\n     of memory when you call it with an unknown error code.\n \n+.. c:function:: char* uv_err_name_r(int err, char* buf, size_t buflen)\n+\n+    Returns the error name for the given error code. The zero-terminated\n+    name is stored in the user-supplied buffer `buf` of at most `buflen` bytes.\n+\n+    .. versionadded:: 1.22.0\n+\n .. c:function:: int uv_translate_sys_error(int sys_errno)\n \n    Returns the libuv error code equivalent to the given platform dependent error"
        },
        {
            "sha": "f383e5b10cd9d523b78e48cd0ee697b439075213",
            "filename": "deps/uv/docs/src/fs.rst",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -92,9 +92,9 @@ Data types\n             UV_FS_READLINK,\n             UV_FS_CHOWN,\n             UV_FS_FCHOWN,\n-            UV_FS_LCHOWN,\n             UV_FS_REALPATH,\n-            UV_FS_COPYFILE\n+            UV_FS_COPYFILE,\n+            UV_FS_LCHOWN\n         } uv_fs_type;\n \n .. c:type:: uv_dirent_t"
        },
        {
            "sha": "a8b305793d4b145e48c1f7db862e7b291736c540",
            "filename": "deps/uv/include/uv.h",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Finclude%2Fuv.h",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Finclude%2Fuv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv.h?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -370,7 +370,10 @@ typedef enum {\n UV_EXTERN int uv_translate_sys_error(int sys_errno);\n \n UV_EXTERN const char* uv_strerror(int err);\n+UV_EXTERN char* uv_strerror_r(int err, char* buf, size_t buflen);\n+\n UV_EXTERN const char* uv_err_name(int err);\n+UV_EXTERN char* uv_err_name_r(int err, char* buf, size_t buflen);\n \n \n #define UV_REQ_FIELDS                                                         \\\n@@ -1141,9 +1144,9 @@ typedef enum {\n   UV_FS_READLINK,\n   UV_FS_CHOWN,\n   UV_FS_FCHOWN,\n-  UV_FS_LCHOWN,\n   UV_FS_REALPATH,\n-  UV_FS_COPYFILE\n+  UV_FS_COPYFILE,\n+  UV_FS_LCHOWN\n } uv_fs_type;\n \n /* uv_fs_t is a subclass of uv_req_t. */"
        },
        {
            "sha": "a990137f85209c7829723f286ce4e6843a4fd107",
            "filename": "deps/uv/include/uv/version.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fversion.h?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -31,7 +31,7 @@\n  */\n \n #define UV_VERSION_MAJOR 1\n-#define UV_VERSION_MINOR 21\n+#define UV_VERSION_MINOR 22\n #define UV_VERSION_PATCH 0\n #define UV_VERSION_IS_RELEASE 1\n #define UV_VERSION_SUFFIX \"\""
        },
        {
            "sha": "d6b8b3a7f7b9a20ad57df6b810ce91cbab8c6d4b",
            "filename": "deps/uv/include/uv/win.h",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Finclude%2Fuv%2Fwin.h",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Finclude%2Fuv%2Fwin.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fwin.h?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -308,8 +308,6 @@ typedef struct {\n   char* errmsg;\n } uv_lib_t;\n \n-RB_HEAD(uv_timer_tree_s, uv_timer_s);\n-\n #define UV_LOOP_PRIVATE_FIELDS                                                \\\n     /* The loop's I/O completion port */                                      \\\n   HANDLE iocp;                                                                \\\n@@ -321,8 +319,8 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n   uv_req_t* pending_reqs_tail;                                                \\\n   /* Head of a single-linked list of closed handles */                        \\\n   uv_handle_t* endgame_handles;                                               \\\n-  /* The head of the timers tree */                                           \\\n-  struct uv_timer_tree_s timers;                                              \\\n+  /* TODO(bnoordhuis) Stop heap-allocating |timer_heap| in libuv v2.x. */     \\\n+  void* timer_heap;                                                           \\\n     /* Lists of active loop (prepare / check / idle) watchers */              \\\n   uv_prepare_t* prepare_handles;                                              \\\n   uv_check_t* check_handles;                                                  \\\n@@ -529,8 +527,9 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n   unsigned char events;\n \n #define UV_TIMER_PRIVATE_FIELDS                                               \\\n-  RB_ENTRY(uv_timer_s) tree_entry;                                            \\\n-  uint64_t due;                                                               \\\n+  void* heap_node[3];                                                         \\\n+  int unused;                                                                 \\\n+  uint64_t timeout;                                                           \\\n   uint64_t repeat;                                                            \\\n   uint64_t start_id;                                                          \\\n   uv_timer_cb timer_cb;"
        },
        {
            "sha": "6c82dfc1d76302c9173d72f0863c233de026bf3a",
            "filename": "deps/uv/src/fs-poll.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Ffs-poll.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Ffs-poll.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Ffs-poll.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -83,7 +83,7 @@ int uv_fs_poll_start(uv_fs_poll_t* handle,\n   if (err < 0)\n     goto error;\n \n-  ctx->timer_handle.flags |= UV__HANDLE_INTERNAL;\n+  ctx->timer_handle.flags |= UV_HANDLE_INTERNAL;\n   uv__handle_unref(&ctx->timer_handle);\n \n   err = uv_fs_stat(loop, &ctx->fs_req, ctx->path, poll_cb);\n@@ -248,7 +248,7 @@ static int statbuf_eq(const uv_stat_t* a, const uv_stat_t* b) {\n #include \"win/handle-inl.h\"\n \n void uv__fs_poll_endgame(uv_loop_t* loop, uv_fs_poll_t* handle) {\n-  assert(handle->flags & UV__HANDLE_CLOSING);\n+  assert(handle->flags & UV_HANDLE_CLOSING);\n   assert(!(handle->flags & UV_HANDLE_CLOSED));\n   uv__handle_close(handle);\n }"
        },
        {
            "sha": "2bf449a736c2bb5102b9754292223e9fddf9b25a",
            "filename": "deps/uv/src/timer.c",
            "status": "renamed",
            "additions": 14,
            "deletions": 5,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Ftimer.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Ftimer.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Ftimer.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -19,13 +19,22 @@\n  */\n \n #include \"uv.h\"\n-#include \"internal.h\"\n+#include \"uv-common.h\"\n #include \"heap-inl.h\"\n \n #include <assert.h>\n #include <limits.h>\n \n \n+static struct heap *timer_heap(const uv_loop_t* loop) {\n+#ifdef _WIN32\n+  return (struct heap*) loop->timer_heap;\n+#else\n+  return (struct heap*) &loop->timer_heap;\n+#endif\n+}\n+\n+\n static int timer_less_than(const struct heap_node* ha,\n                            const struct heap_node* hb) {\n   const uv_timer_t* a;\n@@ -81,7 +90,7 @@ int uv_timer_start(uv_timer_t* handle,\n   /* start_id is the second index to be compared in uv__timer_cmp() */\n   handle->start_id = handle->loop->timer_counter++;\n \n-  heap_insert((struct heap*) &handle->loop->timer_heap,\n+  heap_insert(timer_heap(handle->loop),\n               (struct heap_node*) &handle->heap_node,\n               timer_less_than);\n   uv__handle_start(handle);\n@@ -94,7 +103,7 @@ int uv_timer_stop(uv_timer_t* handle) {\n   if (!uv__is_active(handle))\n     return 0;\n \n-  heap_remove((struct heap*) &handle->loop->timer_heap,\n+  heap_remove(timer_heap(handle->loop),\n               (struct heap_node*) &handle->heap_node,\n               timer_less_than);\n   uv__handle_stop(handle);\n@@ -131,7 +140,7 @@ int uv__next_timeout(const uv_loop_t* loop) {\n   const uv_timer_t* handle;\n   uint64_t diff;\n \n-  heap_node = heap_min((const struct heap*) &loop->timer_heap);\n+  heap_node = heap_min(timer_heap(loop));\n   if (heap_node == NULL)\n     return -1; /* block indefinitely */\n \n@@ -152,7 +161,7 @@ void uv__run_timers(uv_loop_t* loop) {\n   uv_timer_t* handle;\n \n   for (;;) {\n-    heap_node = heap_min((struct heap*) &loop->timer_heap);\n+    heap_node = heap_min(timer_heap(loop));\n     if (heap_node == NULL)\n       break;\n ",
            "previous_filename": "deps/uv/src/unix/timer.c"
        },
        {
            "sha": "066c9bee32e2b2a9f8d9871a5bf61983e7491724",
            "filename": "deps/uv/src/unix/core.c",
            "status": "modified",
            "additions": 10,
            "deletions": 8,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fcore.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -116,7 +116,7 @@ uint64_t uv_hrtime(void) {\n void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n   assert(!uv__is_closing(handle));\n \n-  handle->flags |= UV_CLOSING;\n+  handle->flags |= UV_HANDLE_CLOSING;\n   handle->close_cb = close_cb;\n \n   switch (handle->type) {\n@@ -214,8 +214,8 @@ int uv__socket_sockopt(uv_handle_t* handle, int optname, int* value) {\n }\n \n void uv__make_close_pending(uv_handle_t* handle) {\n-  assert(handle->flags & UV_CLOSING);\n-  assert(!(handle->flags & UV_CLOSED));\n+  assert(handle->flags & UV_HANDLE_CLOSING);\n+  assert(!(handle->flags & UV_HANDLE_CLOSED));\n   handle->next_closing = handle->loop->closing_handles;\n   handle->loop->closing_handles = handle;\n }\n@@ -241,15 +241,17 @@ int uv__getiovmax(void) {\n \n \n static void uv__finish_close(uv_handle_t* handle) {\n-  /* Note: while the handle is in the UV_CLOSING state now, it's still possible\n-   * for it to be active in the sense that uv__is_active() returns true.\n+  /* Note: while the handle is in the UV_HANDLE_CLOSING state now, it's still\n+   * possible for it to be active in the sense that uv__is_active() returns\n+   * true.\n+   *\n    * A good example is when the user calls uv_shutdown(), immediately followed\n    * by uv_close(). The handle is considered active at this point because the\n    * completion of the shutdown req is still pending.\n    */\n-  assert(handle->flags & UV_CLOSING);\n-  assert(!(handle->flags & UV_CLOSED));\n-  handle->flags |= UV_CLOSED;\n+  assert(handle->flags & UV_HANDLE_CLOSING);\n+  assert(!(handle->flags & UV_HANDLE_CLOSED));\n+  handle->flags |= UV_HANDLE_CLOSED;\n \n   switch (handle->type) {\n     case UV_PREPARE:"
        },
        {
            "sha": "ee45299b791294debf401bdb44780d6383722599",
            "filename": "deps/uv/src/unix/fsevents.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Ffsevents.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Ffsevents.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ffsevents.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -836,7 +836,7 @@ int uv__fsevents_init(uv_fs_event_t* handle) {\n \n   handle->cf_cb->data = handle;\n   uv_async_init(handle->loop, handle->cf_cb, uv__fsevents_cb);\n-  handle->cf_cb->flags |= UV__HANDLE_INTERNAL;\n+  handle->cf_cb->flags |= UV_HANDLE_INTERNAL;\n   uv_unref((uv_handle_t*) handle->cf_cb);\n \n   err = uv_mutex_init(&handle->cf_mutex);"
        },
        {
            "sha": "cd79037102013e5d7f1abcc346055e3788a2cc51",
            "filename": "deps/uv/src/unix/internal.h",
            "status": "modified",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Finternal.h",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Finternal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Finternal.h?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -127,26 +127,6 @@ int uv__pthread_sigmask(int how, const sigset_t* set, sigset_t* oset);\n \n typedef struct uv__stream_queued_fds_s uv__stream_queued_fds_t;\n \n-/* handle flags */\n-enum {\n-  UV_CLOSING              = 0x01,   /* uv_close() called but not finished. */\n-  UV_CLOSED               = 0x02,   /* close(2) finished. */\n-  UV_STREAM_READING       = 0x04,   /* uv_read_start() called. */\n-  UV_STREAM_SHUTTING      = 0x08,   /* uv_shutdown() called but not complete. */\n-  UV_STREAM_SHUT          = 0x10,   /* Write side closed. */\n-  UV_STREAM_READABLE      = 0x20,   /* The stream is readable */\n-  UV_STREAM_WRITABLE      = 0x40,   /* The stream is writable */\n-  UV_STREAM_BLOCKING      = 0x80,   /* Synchronous writes. */\n-  UV_STREAM_READ_PARTIAL  = 0x100,  /* read(2) read less than requested. */\n-  UV_STREAM_READ_EOF      = 0x200,  /* read(2) read EOF. */\n-  UV_TCP_NODELAY          = 0x400,  /* Disable Nagle. */\n-  UV_TCP_KEEPALIVE        = 0x800,  /* Turn on keep-alive. */\n-  UV_TCP_SINGLE_ACCEPT    = 0x1000, /* Only accept() when idle. */\n-  UV_HANDLE_IPV6          = 0x10000, /* Handle is bound to a IPv6 socket. */\n-  UV_UDP_PROCESSING       = 0x20000, /* Handle is running the send callback queue. */\n-  UV_HANDLE_BOUND         = 0x40000  /* Handle is bound to an address and port */\n-};\n-\n /* loop flags */\n enum {\n   UV_LOOP_BLOCK_SIGPROF = 1\n@@ -252,10 +232,6 @@ int uv__tcp_keepalive(int fd, int on, unsigned int delay);\n /* pipe */\n int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);\n \n-/* timer */\n-void uv__run_timers(uv_loop_t* loop);\n-int uv__next_timeout(const uv_loop_t* loop);\n-\n /* signal */\n void uv__signal_close(uv_signal_t* handle);\n void uv__signal_global_once_init(void);\n@@ -280,7 +256,6 @@ void uv__prepare_close(uv_prepare_t* handle);\n void uv__process_close(uv_process_t* handle);\n void uv__stream_close(uv_stream_t* handle);\n void uv__tcp_close(uv_tcp_t* handle);\n-void uv__timer_close(uv_timer_t* handle);\n void uv__udp_close(uv_udp_t* handle);\n void uv__udp_finish_close(uv_udp_t* handle);\n uv_handle_type uv__handle_type(int fd);"
        },
        {
            "sha": "c2a03d770f3764ab1e88cc19c2eb1e7fc7bbb5fe",
            "filename": "deps/uv/src/unix/loop.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Floop.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Floop.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Floop.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -74,7 +74,7 @@ int uv_loop_init(uv_loop_t* loop) {\n     goto fail_signal_init;\n \n   uv__handle_unref(&loop->child_watcher);\n-  loop->child_watcher.flags |= UV__HANDLE_INTERNAL;\n+  loop->child_watcher.flags |= UV_HANDLE_INTERNAL;\n   QUEUE_INIT(&loop->process_handles);\n \n   err = uv_rwlock_init(&loop->cloexec_lock);\n@@ -90,7 +90,7 @@ int uv_loop_init(uv_loop_t* loop) {\n     goto fail_async_init;\n \n   uv__handle_unref(&loop->wq_async);\n-  loop->wq_async.flags |= UV__HANDLE_INTERNAL;\n+  loop->wq_async.flags |= UV_HANDLE_INTERNAL;\n \n   return 0;\n "
        },
        {
            "sha": "1040d66979da0451f83c5cca9baffe2a2c4f3c67",
            "filename": "deps/uv/src/unix/os390-syscalls.c",
            "status": "modified",
            "additions": 20,
            "deletions": 9,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fos390-syscalls.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fos390-syscalls.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fos390-syscalls.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -141,7 +141,7 @@ static void init_message_queue(uv__os390_epoll* lst) {\n   } msg;\n \n   /* initialize message queue */\n-  lst->msg_queue = msgget(IPC_PRIVATE, 0622 | IPC_CREAT);\n+  lst->msg_queue = msgget(IPC_PRIVATE, 0600 | IPC_CREAT);\n   if (lst->msg_queue == -1)\n     abort();\n \n@@ -255,12 +255,13 @@ int epoll_ctl(uv__os390_epoll* lst,\n     lst->items[fd].events = event->events;\n     lst->items[fd].revents = 0;\n   } else if (op == EPOLL_CTL_MOD) {\n-    if (fd >= lst->size || lst->items[fd].fd == -1) {\n+    if (fd >= lst->size - 1 || lst->items[fd].fd == -1) {\n       uv_mutex_unlock(&global_epoll_lock);\n       errno = ENOENT;\n       return -1;\n     }\n     lst->items[fd].events = event->events;\n+    lst->items[fd].revents = 0;\n   } else\n     abort();\n \n@@ -275,8 +276,9 @@ int epoll_wait(uv__os390_epoll* lst, struct epoll_event* events,\n   struct pollfd* pfds;\n   int pollret;\n   int reventcount;\n+  int nevents;\n \n-  size = _SET_FDS_MSGS(size, 1, lst->size - 1);\n+  _SET_FDS_MSGS(size, 1, lst->size - 1);\n   pfds = lst->items;\n   pollret = poll(pfds, size, timeout);\n   if (pollret <= 0)\n@@ -285,19 +287,28 @@ int epoll_wait(uv__os390_epoll* lst, struct epoll_event* events,\n   pollret = _NFDS(pollret) + _NMSGS(pollret);\n \n   reventcount = 0;\n+  nevents = 0;\n   for (int i = 0; \n        i < lst->size && i < maxevents && reventcount < pollret; ++i) {\n     struct epoll_event ev;\n+    struct pollfd* pfd;\n \n-    if (pfds[i].fd == -1 || pfds[i].revents == 0)\n+    pfd = &pfds[i];\n+    if (pfd->fd == -1 || pfd->revents == 0)\n       continue;\n \n-    ev.fd = pfds[i].fd;\n-    ev.events = pfds[i].revents;\n-    events[reventcount++] = ev;\n+    ev.fd = pfd->fd;\n+    ev.events = pfd->revents;\n+    if (pfd->revents & POLLIN && pfd->revents & POLLOUT)\n+      reventcount += 2;\n+    else if (pfd->revents & (POLLIN | POLLOUT))\n+      ++reventcount;\n+\n+    pfd->revents = 0;\n+    events[nevents++] = ev;\n   }\n \n-  return reventcount;\n+  return nevents;\n }\n \n \n@@ -493,7 +504,7 @@ ssize_t os390_readlink(const char* path, char* buf, size_t len) {\n \n \n size_t strnlen(const char* str, size_t maxlen) {\n-  void* p = memchr(str, 0, maxlen);\n+  char* p = memchr(str, 0, maxlen);\n   if (p == NULL)\n     return maxlen;\n   else"
        },
        {
            "sha": "0718bc81b86f63d2b0107b4fc4f36c8ac4345f02",
            "filename": "deps/uv/src/unix/pipe.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fpipe.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fpipe.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fpipe.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -149,7 +149,7 @@ int uv_pipe_open(uv_pipe_t* handle, uv_file fd) {\n \n   return uv__stream_open((uv_stream_t*)handle,\n                          fd,\n-                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n+                         UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);\n }\n \n \n@@ -199,7 +199,7 @@ void uv_pipe_connect(uv_connect_t* req,\n   if (new_sock) {\n     err = uv__stream_open((uv_stream_t*)handle,\n                           uv__stream_fd(handle),\n-                          UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n+                          UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);\n   }\n \n   if (err == 0)"
        },
        {
            "sha": "101c9c53dfafe3279e972d0be35a35a54d57faef",
            "filename": "deps/uv/src/unix/process.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fprocess.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fprocess.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fprocess.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -239,9 +239,9 @@ static int uv__process_open_stream(uv_stdio_container_t* container,\n \n   flags = 0;\n   if (container->flags & UV_WRITABLE_PIPE)\n-    flags |= UV_STREAM_READABLE;\n+    flags |= UV_HANDLE_READABLE;\n   if (container->flags & UV_READABLE_PIPE)\n-    flags |= UV_STREAM_WRITABLE;\n+    flags |= UV_HANDLE_WRITABLE;\n \n   return uv__stream_open(container->data.stream, pipefds[0], flags);\n }"
        },
        {
            "sha": "01aa55f3fe7c6687760ed91bde482373eb6a271c",
            "filename": "deps/uv/src/unix/signal.c",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fsignal.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fsignal.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fsignal.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -396,7 +396,7 @@ static int uv__signal_start(uv_signal_t* handle,\n    */\n   first_handle = uv__signal_first_handle(signum);\n   if (first_handle == NULL ||\n-      (!oneshot && (first_handle->flags & UV__SIGNAL_ONE_SHOT))) {\n+      (!oneshot && (first_handle->flags & UV_SIGNAL_ONE_SHOT))) {\n     err = uv__signal_register_handler(signum, oneshot);\n     if (err) {\n       /* Registering the signal handler failed. Must be an invalid signal. */\n@@ -407,7 +407,7 @@ static int uv__signal_start(uv_signal_t* handle,\n \n   handle->signum = signum;\n   if (oneshot)\n-    handle->flags |= UV__SIGNAL_ONE_SHOT;\n+    handle->flags |= UV_SIGNAL_ONE_SHOT;\n \n   RB_INSERT(uv__signal_tree_s, &uv__signal_tree, handle);\n \n@@ -464,20 +464,20 @@ static void uv__signal_event(uv_loop_t* loop,\n       handle = msg->handle;\n \n       if (msg->signum == handle->signum) {\n-        assert(!(handle->flags & UV_CLOSING));\n+        assert(!(handle->flags & UV_HANDLE_CLOSING));\n         handle->signal_cb(handle, handle->signum);\n       }\n \n       handle->dispatched_signals++;\n \n-      if (handle->flags & UV__SIGNAL_ONE_SHOT)\n+      if (handle->flags & UV_SIGNAL_ONE_SHOT)\n         uv__signal_stop(handle);\n \n       /* If uv_close was called while there were caught signals that were not\n        * yet dispatched, the uv__finish_close was deferred. Make close pending\n        * now if this has happened.\n        */\n-      if ((handle->flags & UV_CLOSING) &&\n+      if ((handle->flags & UV_HANDLE_CLOSING) &&\n           (handle->caught_signals == handle->dispatched_signals)) {\n         uv__make_close_pending((uv_handle_t*) handle);\n       }\n@@ -505,11 +505,11 @@ static int uv__signal_compare(uv_signal_t* w1, uv_signal_t* w2) {\n   if (w1->signum < w2->signum) return -1;\n   if (w1->signum > w2->signum) return 1;\n \n-  /* Handlers without UV__SIGNAL_ONE_SHOT set will come first, so if the first\n+  /* Handlers without UV_SIGNAL_ONE_SHOT set will come first, so if the first\n    * handler returned is a one-shot handler, the rest will be too.\n    */\n-  f1 = w1->flags & UV__SIGNAL_ONE_SHOT;\n-  f2 = w2->flags & UV__SIGNAL_ONE_SHOT;\n+  f1 = w1->flags & UV_SIGNAL_ONE_SHOT;\n+  f2 = w2->flags & UV_SIGNAL_ONE_SHOT;\n   if (f1 < f2) return -1;\n   if (f1 > f2) return 1;\n \n@@ -558,8 +558,8 @@ static void uv__signal_stop(uv_signal_t* handle) {\n   if (first_handle == NULL) {\n     uv__signal_unregister_handler(handle->signum);\n   } else {\n-    rem_oneshot = handle->flags & UV__SIGNAL_ONE_SHOT;\n-    first_oneshot = first_handle->flags & UV__SIGNAL_ONE_SHOT;\n+    rem_oneshot = handle->flags & UV_SIGNAL_ONE_SHOT;\n+    first_oneshot = first_handle->flags & UV_SIGNAL_ONE_SHOT;\n     if (first_oneshot && !rem_oneshot) {\n       ret = uv__signal_register_handler(handle->signum, 1);\n       assert(ret == 0);"
        },
        {
            "sha": "4d62a23f1b9b7a0e3b54fb59c08077f58d662344",
            "filename": "deps/uv/src/unix/stream.c",
            "status": "modified",
            "additions": 47,
            "deletions": 44,
            "changes": 91,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fstream.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -220,7 +220,7 @@ static void uv__stream_osx_select(void* arg) {\n       uv_sem_wait(&s->async_sem);\n \n       /* Should be processed at this stage */\n-      assert((s->events == 0) || (stream->flags & UV_CLOSING));\n+      assert((s->events == 0) || (stream->flags & UV_HANDLE_CLOSING));\n     }\n   }\n }\n@@ -248,7 +248,7 @@ static void uv__stream_osx_select_cb(uv_async_t* handle) {\n   if ((events & POLLOUT) && uv__io_active(&stream->io_watcher, POLLOUT))\n     uv__stream_io(stream->loop, &stream->io_watcher, POLLOUT);\n \n-  if (stream->flags & UV_CLOSING)\n+  if (stream->flags & UV_HANDLE_CLOSING)\n     return;\n \n   /* NOTE: It is important to do it here, otherwise `select()` might be called\n@@ -342,7 +342,7 @@ int uv__stream_try_select(uv_stream_t* stream, int* fd) {\n   if (err)\n     goto failed_async_init;\n \n-  s->async.flags |= UV__HANDLE_INTERNAL;\n+  s->async.flags |= UV_HANDLE_INTERNAL;\n   uv__handle_unref(&s->async);\n \n   err = uv_sem_init(&s->close_sem, 0);\n@@ -407,12 +407,14 @@ int uv__stream_open(uv_stream_t* stream, int fd, int flags) {\n   stream->flags |= flags;\n \n   if (stream->type == UV_TCP) {\n-    if ((stream->flags & UV_TCP_NODELAY) && uv__tcp_nodelay(fd, 1))\n+    if ((stream->flags & UV_HANDLE_TCP_NODELAY) && uv__tcp_nodelay(fd, 1))\n       return UV__ERR(errno);\n \n     /* TODO Use delay the user passed in. */\n-    if ((stream->flags & UV_TCP_KEEPALIVE) && uv__tcp_keepalive(fd, 1, 60))\n+    if ((stream->flags & UV_HANDLE_TCP_KEEPALIVE) &&\n+        uv__tcp_keepalive(fd, 1, 60)) {\n       return UV__ERR(errno);\n+    }\n   }\n \n #if defined(__APPLE__)\n@@ -447,7 +449,7 @@ void uv__stream_flush_write_queue(uv_stream_t* stream, int error) {\n \n void uv__stream_destroy(uv_stream_t* stream) {\n   assert(!uv__io_active(&stream->io_watcher, POLLIN | POLLOUT));\n-  assert(stream->flags & UV_CLOSED);\n+  assert(stream->flags & UV_HANDLE_CLOSED);\n \n   if (stream->connect_req) {\n     uv__req_unregister(stream->loop, stream->connect_req);\n@@ -522,7 +524,7 @@ void uv__server_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n   stream = container_of(w, uv_stream_t, io_watcher);\n   assert(events & POLLIN);\n   assert(stream->accepted_fd == -1);\n-  assert(!(stream->flags & UV_CLOSING));\n+  assert(!(stream->flags & UV_HANDLE_CLOSING));\n \n   uv__io_start(stream->loop, &stream->io_watcher, POLLIN);\n \n@@ -565,7 +567,8 @@ void uv__server_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n       return;\n     }\n \n-    if (stream->type == UV_TCP && (stream->flags & UV_TCP_SINGLE_ACCEPT)) {\n+    if (stream->type == UV_TCP &&\n+        (stream->flags & UV_HANDLE_TCP_SINGLE_ACCEPT)) {\n       /* Give other processes a chance to accept connections. */\n       struct timespec timeout = { 0, 1 };\n       nanosleep(&timeout, NULL);\n@@ -590,7 +593,7 @@ int uv_accept(uv_stream_t* server, uv_stream_t* client) {\n     case UV_TCP:\n       err = uv__stream_open(client,\n                             server->accepted_fd,\n-                            UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n+                            UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);\n       if (err) {\n         /* TODO handle error */\n         uv__close(server->accepted_fd);\n@@ -674,22 +677,22 @@ static void uv__drain(uv_stream_t* stream) {\n   uv__stream_osx_interrupt_select(stream);\n \n   /* Shutdown? */\n-  if ((stream->flags & UV_STREAM_SHUTTING) &&\n-      !(stream->flags & UV_CLOSING) &&\n-      !(stream->flags & UV_STREAM_SHUT)) {\n+  if ((stream->flags & UV_HANDLE_SHUTTING) &&\n+      !(stream->flags & UV_HANDLE_CLOSING) &&\n+      !(stream->flags & UV_HANDLE_SHUT)) {\n     assert(stream->shutdown_req);\n \n     req = stream->shutdown_req;\n     stream->shutdown_req = NULL;\n-    stream->flags &= ~UV_STREAM_SHUTTING;\n+    stream->flags &= ~UV_HANDLE_SHUTTING;\n     uv__req_unregister(stream->loop, req);\n \n     err = 0;\n     if (shutdown(uv__stream_fd(stream), SHUT_WR))\n       err = UV__ERR(errno);\n \n     if (err == 0)\n-      stream->flags |= UV_STREAM_SHUT;\n+      stream->flags |= UV_HANDLE_SHUT;\n \n     if (req->cb != NULL)\n       req->cb(req, err);\n@@ -868,7 +871,7 @@ static void uv__write(uv_stream_t* stream) {\n     if (!WRITE_RETRY_ON_ERROR(req->send_handle)) {\n       err = UV__ERR(errno);\n       goto error;\n-    } else if (stream->flags & UV_STREAM_BLOCKING) {\n+    } else if (stream->flags & UV_HANDLE_BLOCKING_WRITES) {\n       /* If this is a blocking stream, try again. */\n       goto start;\n     }\n@@ -888,7 +891,7 @@ static void uv__write(uv_stream_t* stream) {\n         n = 0;\n \n         /* There is more to write. */\n-        if (stream->flags & UV_STREAM_BLOCKING) {\n+        if (stream->flags & UV_HANDLE_BLOCKING_WRITES) {\n           /*\n            * If we're blocking then we should not be enabling the write\n            * watcher - instead we need to try again.\n@@ -924,7 +927,7 @@ static void uv__write(uv_stream_t* stream) {\n   assert(n == 0 || n == -1);\n \n   /* Only non-blocking streams should use the write_watcher. */\n-  assert(!(stream->flags & UV_STREAM_BLOCKING));\n+  assert(!(stream->flags & UV_HANDLE_BLOCKING_WRITES));\n \n   /* We're not done. */\n   uv__io_start(stream->loop, &stream->io_watcher, POLLOUT);\n@@ -1015,13 +1018,13 @@ uv_handle_type uv__handle_type(int fd) {\n \n \n static void uv__stream_eof(uv_stream_t* stream, const uv_buf_t* buf) {\n-  stream->flags |= UV_STREAM_READ_EOF;\n+  stream->flags |= UV_HANDLE_READ_EOF;\n   uv__io_stop(stream->loop, &stream->io_watcher, POLLIN);\n   if (!uv__io_active(&stream->io_watcher, POLLOUT))\n     uv__handle_stop(stream);\n   uv__stream_osx_interrupt_select(stream);\n   stream->read_cb(stream, UV_EOF, buf);\n-  stream->flags &= ~UV_STREAM_READING;\n+  stream->flags &= ~UV_HANDLE_READING;\n }\n \n \n@@ -1133,7 +1136,7 @@ static void uv__read(uv_stream_t* stream) {\n   int err;\n   int is_ipc;\n \n-  stream->flags &= ~UV_STREAM_READ_PARTIAL;\n+  stream->flags &= ~UV_HANDLE_READ_PARTIAL;\n \n   /* Prevent loop starvation when the data comes in as fast as (or faster than)\n    * we can read it. XXX Need to rearm fd if we switch to edge-triggered I/O.\n@@ -1142,11 +1145,11 @@ static void uv__read(uv_stream_t* stream) {\n \n   is_ipc = stream->type == UV_NAMED_PIPE && ((uv_pipe_t*) stream)->ipc;\n \n-  /* XXX: Maybe instead of having UV_STREAM_READING we just test if\n+  /* XXX: Maybe instead of having UV_HANDLE_READING we just test if\n    * tcp->read_cb is NULL or not?\n    */\n   while (stream->read_cb\n-      && (stream->flags & UV_STREAM_READING)\n+      && (stream->flags & UV_HANDLE_READING)\n       && (count-- > 0)) {\n     assert(stream->alloc_cb != NULL);\n \n@@ -1187,7 +1190,7 @@ static void uv__read(uv_stream_t* stream) {\n       /* Error */\n       if (errno == EAGAIN || errno == EWOULDBLOCK) {\n         /* Wait for the next one. */\n-        if (stream->flags & UV_STREAM_READING) {\n+        if (stream->flags & UV_HANDLE_READING) {\n           uv__io_start(stream->loop, &stream->io_watcher, POLLIN);\n           uv__stream_osx_interrupt_select(stream);\n         }\n@@ -1200,8 +1203,8 @@ static void uv__read(uv_stream_t* stream) {\n       } else {\n         /* Error. User should call uv_close(). */\n         stream->read_cb(stream, UV__ERR(errno), &buf);\n-        if (stream->flags & UV_STREAM_READING) {\n-          stream->flags &= ~UV_STREAM_READING;\n+        if (stream->flags & UV_HANDLE_READING) {\n+          stream->flags &= ~UV_HANDLE_READING;\n           uv__io_stop(stream->loop, &stream->io_watcher, POLLIN);\n           if (!uv__io_active(&stream->io_watcher, POLLOUT))\n             uv__handle_stop(stream);\n@@ -1251,7 +1254,7 @@ static void uv__read(uv_stream_t* stream) {\n \n       /* Return if we didn't fill the buffer, there is no more data to read. */\n       if (nread < buflen) {\n-        stream->flags |= UV_STREAM_READ_PARTIAL;\n+        stream->flags |= UV_HANDLE_READ_PARTIAL;\n         return;\n       }\n     }\n@@ -1272,9 +1275,9 @@ int uv_shutdown(uv_shutdown_t* req, uv_stream_t* stream, uv_shutdown_cb cb) {\n          stream->type == UV_TTY ||\n          stream->type == UV_NAMED_PIPE);\n \n-  if (!(stream->flags & UV_STREAM_WRITABLE) ||\n-      stream->flags & UV_STREAM_SHUT ||\n-      stream->flags & UV_STREAM_SHUTTING ||\n+  if (!(stream->flags & UV_HANDLE_WRITABLE) ||\n+      stream->flags & UV_HANDLE_SHUT ||\n+      stream->flags & UV_HANDLE_SHUTTING ||\n       uv__is_closing(stream)) {\n     return UV_ENOTCONN;\n   }\n@@ -1286,7 +1289,7 @@ int uv_shutdown(uv_shutdown_t* req, uv_stream_t* stream, uv_shutdown_cb cb) {\n   req->handle = stream;\n   req->cb = cb;\n   stream->shutdown_req = req;\n-  stream->flags |= UV_STREAM_SHUTTING;\n+  stream->flags |= UV_HANDLE_SHUTTING;\n \n   uv__io_start(stream->loop, &stream->io_watcher, POLLOUT);\n   uv__stream_osx_interrupt_select(stream);\n@@ -1303,7 +1306,7 @@ static void uv__stream_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n   assert(stream->type == UV_TCP ||\n          stream->type == UV_NAMED_PIPE ||\n          stream->type == UV_TTY);\n-  assert(!(stream->flags & UV_CLOSING));\n+  assert(!(stream->flags & UV_HANDLE_CLOSING));\n \n   if (stream->connect_req) {\n     uv__stream_connect(stream);\n@@ -1326,9 +1329,9 @@ static void uv__stream_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n    * report the EOF yet because there is still data to read.\n    */\n   if ((events & POLLHUP) &&\n-      (stream->flags & UV_STREAM_READING) &&\n-      (stream->flags & UV_STREAM_READ_PARTIAL) &&\n-      !(stream->flags & UV_STREAM_READ_EOF)) {\n+      (stream->flags & UV_HANDLE_READING) &&\n+      (stream->flags & UV_HANDLE_READ_PARTIAL) &&\n+      !(stream->flags & UV_HANDLE_READ_EOF)) {\n     uv_buf_t buf = { NULL, 0 };\n     uv__stream_eof(stream, &buf);\n   }\n@@ -1418,7 +1421,7 @@ int uv_write2(uv_write_t* req,\n   if (uv__stream_fd(stream) < 0)\n     return UV_EBADF;\n \n-  if (!(stream->flags & UV_STREAM_WRITABLE))\n+  if (!(stream->flags & UV_HANDLE_WRITABLE))\n     return -EPIPE;\n \n   if (send_handle) {\n@@ -1488,7 +1491,7 @@ int uv_write2(uv_write_t* req,\n      * if this assert fires then somehow the blocking stream isn't being\n      * sufficiently flushed in uv__write.\n      */\n-    assert(!(stream->flags & UV_STREAM_BLOCKING));\n+    assert(!(stream->flags & UV_HANDLE_BLOCKING_WRITES));\n     uv__io_start(stream->loop, &stream->io_watcher, POLLOUT);\n     uv__stream_osx_interrupt_select(stream);\n   }\n@@ -1569,16 +1572,16 @@ int uv_read_start(uv_stream_t* stream,\n   assert(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE ||\n       stream->type == UV_TTY);\n \n-  if (stream->flags & UV_CLOSING)\n+  if (stream->flags & UV_HANDLE_CLOSING)\n     return UV_EINVAL;\n \n-  if (!(stream->flags & UV_STREAM_READABLE))\n+  if (!(stream->flags & UV_HANDLE_READABLE))\n     return -ENOTCONN;\n \n-  /* The UV_STREAM_READING flag is irrelevant of the state of the tcp - it just\n+  /* The UV_HANDLE_READING flag is irrelevant of the state of the tcp - it just\n    * expresses the desired state of the user.\n    */\n-  stream->flags |= UV_STREAM_READING;\n+  stream->flags |= UV_HANDLE_READING;\n \n   /* TODO: try to do the read inline? */\n   /* TODO: keep track of tcp state. If we've gotten a EOF then we should\n@@ -1599,10 +1602,10 @@ int uv_read_start(uv_stream_t* stream,\n \n \n int uv_read_stop(uv_stream_t* stream) {\n-  if (!(stream->flags & UV_STREAM_READING))\n+  if (!(stream->flags & UV_HANDLE_READING))\n     return 0;\n \n-  stream->flags &= ~UV_STREAM_READING;\n+  stream->flags &= ~UV_HANDLE_READING;\n   uv__io_stop(stream->loop, &stream->io_watcher, POLLIN);\n   if (!uv__io_active(&stream->io_watcher, POLLOUT))\n     uv__handle_stop(stream);\n@@ -1615,12 +1618,12 @@ int uv_read_stop(uv_stream_t* stream) {\n \n \n int uv_is_readable(const uv_stream_t* stream) {\n-  return !!(stream->flags & UV_STREAM_READABLE);\n+  return !!(stream->flags & UV_HANDLE_READABLE);\n }\n \n \n int uv_is_writable(const uv_stream_t* stream) {\n-  return !!(stream->flags & UV_STREAM_WRITABLE);\n+  return !!(stream->flags & UV_HANDLE_WRITABLE);\n }\n \n "
        },
        {
            "sha": "2982851dc6eaa1bee2c8967a0c9b6e9b5b829b87",
            "filename": "deps/uv/src/unix/tcp.c",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Ftcp.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Ftcp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ftcp.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -216,7 +216,7 @@ int uv__tcp_connect(uv_connect_t* req,\n \n   err = maybe_new_socket(handle,\n                          addr->sa_family,\n-                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n+                         UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);\n   if (err)\n     return err;\n \n@@ -272,7 +272,7 @@ int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock) {\n \n   return uv__stream_open((uv_stream_t*)handle,\n                          sock,\n-                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n+                         UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);\n }\n \n \n@@ -334,7 +334,7 @@ int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n   }\n \n   if (single_accept)\n-    tcp->flags |= UV_TCP_SINGLE_ACCEPT;\n+    tcp->flags |= UV_HANDLE_TCP_SINGLE_ACCEPT;\n \n   flags = 0;\n #if defined(__MVS__)\n@@ -401,9 +401,9 @@ int uv_tcp_nodelay(uv_tcp_t* handle, int on) {\n   }\n \n   if (on)\n-    handle->flags |= UV_TCP_NODELAY;\n+    handle->flags |= UV_HANDLE_TCP_NODELAY;\n   else\n-    handle->flags &= ~UV_TCP_NODELAY;\n+    handle->flags &= ~UV_HANDLE_TCP_NODELAY;\n \n   return 0;\n }\n@@ -419,9 +419,9 @@ int uv_tcp_keepalive(uv_tcp_t* handle, int on, unsigned int delay) {\n   }\n \n   if (on)\n-    handle->flags |= UV_TCP_KEEPALIVE;\n+    handle->flags |= UV_HANDLE_TCP_KEEPALIVE;\n   else\n-    handle->flags &= ~UV_TCP_KEEPALIVE;\n+    handle->flags &= ~UV_HANDLE_TCP_KEEPALIVE;\n \n   /* TODO Store delay if uv__stream_fd(handle) == -1 but don't want to enlarge\n    *      uv_tcp_t with an int that's almost never used...\n@@ -433,9 +433,9 @@ int uv_tcp_keepalive(uv_tcp_t* handle, int on, unsigned int delay) {\n \n int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable) {\n   if (enable)\n-    handle->flags &= ~UV_TCP_SINGLE_ACCEPT;\n+    handle->flags &= ~UV_HANDLE_TCP_SINGLE_ACCEPT;\n   else\n-    handle->flags |= UV_TCP_SINGLE_ACCEPT;\n+    handle->flags |= UV_HANDLE_TCP_SINGLE_ACCEPT;\n   return 0;\n }\n "
        },
        {
            "sha": "1b92b5c914ce9e69179a971ef6b57b011ee16843",
            "filename": "deps/uv/src/unix/tty.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Ftty.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Ftty.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ftty.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -135,7 +135,7 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n     if (r < 0) {\n       /* fallback to using blocking writes */\n       if (!readable)\n-        flags |= UV_STREAM_BLOCKING;\n+        flags |= UV_HANDLE_BLOCKING_WRITES;\n       goto skip;\n     }\n \n@@ -177,7 +177,7 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n    * the handle queue, since it was added by uv__handle_init in uv_stream_init.\n    */\n \n-  if (!(flags & UV_STREAM_BLOCKING))\n+  if (!(flags & UV_HANDLE_BLOCKING_WRITES))\n     uv__nonblock(fd, 1);\n \n #if defined(__APPLE__)\n@@ -195,9 +195,9 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n #endif\n \n   if (readable)\n-    flags |= UV_STREAM_READABLE;\n+    flags |= UV_HANDLE_READABLE;\n   else\n-    flags |= UV_STREAM_WRITABLE;\n+    flags |= UV_HANDLE_WRITABLE;\n \n   uv__stream_open((uv_stream_t*) tty, fd, flags);\n   tty->mode = UV_TTY_MODE_NORMAL;"
        },
        {
            "sha": "e6668a012c5c2781eb0f2cda7b0b06865d90c92d",
            "filename": "deps/uv/src/unix/udp.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fudp.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Funix%2Fudp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fudp.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -92,8 +92,8 @@ static void uv__udp_run_completed(uv_udp_t* handle) {\n   uv_udp_send_t* req;\n   QUEUE* q;\n \n-  assert(!(handle->flags & UV_UDP_PROCESSING));\n-  handle->flags |= UV_UDP_PROCESSING;\n+  assert(!(handle->flags & UV_HANDLE_UDP_PROCESSING));\n+  handle->flags |= UV_HANDLE_UDP_PROCESSING;\n \n   while (!QUEUE_EMPTY(&handle->write_completed_queue)) {\n     q = QUEUE_HEAD(&handle->write_completed_queue);\n@@ -128,7 +128,7 @@ static void uv__udp_run_completed(uv_udp_t* handle) {\n       uv__handle_stop(handle);\n   }\n \n-  handle->flags &= ~UV_UDP_PROCESSING;\n+  handle->flags &= ~UV_HANDLE_UDP_PROCESSING;\n }\n \n \n@@ -427,7 +427,7 @@ int uv__udp_send(uv_udp_send_t* req,\n   QUEUE_INSERT_TAIL(&handle->write_queue, &req->queue);\n   uv__handle_start(handle);\n \n-  if (empty_queue && !(handle->flags & UV_UDP_PROCESSING)) {\n+  if (empty_queue && !(handle->flags & UV_HANDLE_UDP_PROCESSING)) {\n     uv__udp_sendmsg(handle);\n \n     /* `uv__udp_sendmsg` may not be able to do non-blocking write straight"
        },
        {
            "sha": "f0aec452606cb843d4894468a7bdffbbb691a4b6",
            "filename": "deps/uv/src/uv-common.c",
            "status": "modified",
            "additions": 30,
            "deletions": 5,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fuv-common.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fuv-common.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fuv-common.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -155,6 +155,18 @@ static const char* uv__unknown_err_code(int err) {\n   return copy != NULL ? copy : \"Unknown system error\";\n }\n \n+#define UV_ERR_NAME_GEN_R(name, _) \\\n+case UV_## name: \\\n+  snprintf(buf, buflen, \"%s\", #name); break;\n+char* uv_err_name_r(int err, char* buf, size_t buflen) {\n+  switch (err) {\n+    UV_ERRNO_MAP(UV_ERR_NAME_GEN_R)\n+    default: snprintf(buf, buflen, \"Unknown system error %d\", err);\n+  }\n+  return buf;\n+}\n+#undef UV_ERR_NAME_GEN_R\n+\n \n #define UV_ERR_NAME_GEN(name, _) case UV_ ## name: return #name;\n const char* uv_err_name(int err) {\n@@ -166,6 +178,19 @@ const char* uv_err_name(int err) {\n #undef UV_ERR_NAME_GEN\n \n \n+#define UV_STRERROR_GEN_R(name, msg) \\\n+case UV_ ## name: \\\n+  snprintf(buf, buflen, \"%s\", msg); break;\n+char* uv_strerror_r(int err, char* buf, size_t buflen) {\n+  switch (err) {\n+    UV_ERRNO_MAP(UV_STRERROR_GEN_R)\n+    default: snprintf(buf, buflen, \"Unknown system error %d\", err);\n+  }\n+  return buf;\n+}\n+#undef UV_STRERROR_GEN_R\n+\n+\n #define UV_STRERROR_GEN(name, msg) case UV_ ## name: return msg;\n const char* uv_strerror(int err) {\n   switch (err) {\n@@ -357,7 +382,7 @@ void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg) {\n     QUEUE_REMOVE(q);\n     QUEUE_INSERT_TAIL(&loop->handle_queue, q);\n \n-    if (h->flags & UV__HANDLE_INTERNAL) continue;\n+    if (h->flags & UV_HANDLE_INTERNAL) continue;\n     walk_cb(h, arg);\n   }\n }\n@@ -386,9 +411,9 @@ static void uv__print_handles(uv_loop_t* loop, int only_active, FILE* stream) {\n \n     fprintf(stream,\n             \"[%c%c%c] %-8s %p\\n\",\n-            \"R-\"[!(h->flags & UV__HANDLE_REF)],\n-            \"A-\"[!(h->flags & UV__HANDLE_ACTIVE)],\n-            \"I-\"[!(h->flags & UV__HANDLE_INTERNAL)],\n+            \"R-\"[!(h->flags & UV_HANDLE_REF)],\n+            \"A-\"[!(h->flags & UV_HANDLE_ACTIVE)],\n+            \"I-\"[!(h->flags & UV_HANDLE_INTERNAL)],\n             type,\n             (void*)h);\n   }\n@@ -632,7 +657,7 @@ int uv_loop_close(uv_loop_t* loop) {\n \n   QUEUE_FOREACH(q, &loop->handle_queue) {\n     h = QUEUE_DATA(q, uv_handle_t, handle_queue);\n-    if (!(h->flags & UV__HANDLE_INTERNAL))\n+    if (!(h->flags & UV_HANDLE_INTERNAL))\n       return UV_EBUSY;\n   }\n "
        },
        {
            "sha": "3289950d009ccd7024e4656de0518cd98dd3c9e4",
            "filename": "deps/uv/src/uv-common.h",
            "status": "modified",
            "additions": 81,
            "deletions": 34,
            "changes": 115,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fuv-common.h",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fuv-common.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fuv-common.h?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -59,22 +59,67 @@ extern int snprintf(char*, size_t, const char*, ...);\n #define STATIC_ASSERT(expr)                                                   \\\n   void uv__static_assert(int static_assert_failed[1 - 2 * !(expr)])\n \n-#ifndef _WIN32\n+/* Handle flags. Some flags are specific to Windows or UNIX. */\n enum {\n-  UV__SIGNAL_ONE_SHOT = 0x80000,  /* On signal reception remove sighandler */\n-  UV__HANDLE_INTERNAL = 0x8000,\n-  UV__HANDLE_ACTIVE   = 0x4000,\n-  UV__HANDLE_REF      = 0x2000,\n-  UV__HANDLE_CLOSING  = 0 /* no-op on unix */\n+  /* Used by all handles. */\n+  UV_HANDLE_CLOSING                     = 0x00000001,\n+  UV_HANDLE_CLOSED                      = 0x00000002,\n+  UV_HANDLE_ACTIVE                      = 0x00000004,\n+  UV_HANDLE_REF                         = 0x00000008,\n+  UV_HANDLE_INTERNAL                    = 0x00000010,\n+  UV_HANDLE_ENDGAME_QUEUED              = 0x00000020,\n+\n+  /* Used by streams. */\n+  UV_HANDLE_LISTENING                   = 0x00000040,\n+  UV_HANDLE_CONNECTION                  = 0x00000080,\n+  UV_HANDLE_SHUTTING                    = 0x00000100,\n+  UV_HANDLE_SHUT                        = 0x00000200,\n+  UV_HANDLE_READ_PARTIAL                = 0x00000400,\n+  UV_HANDLE_READ_EOF                    = 0x00000800,\n+\n+  /* Used by streams and UDP handles. */\n+  UV_HANDLE_READING                     = 0x00001000,\n+  UV_HANDLE_BOUND                       = 0x00002000,\n+  UV_HANDLE_READABLE                    = 0x00004000,\n+  UV_HANDLE_WRITABLE                    = 0x00008000,\n+  UV_HANDLE_READ_PENDING                = 0x00010000,\n+  UV_HANDLE_SYNC_BYPASS_IOCP            = 0x00020000,\n+  UV_HANDLE_ZERO_READ                   = 0x00040000,\n+  UV_HANDLE_EMULATE_IOCP                = 0x00080000,\n+  UV_HANDLE_BLOCKING_WRITES             = 0x00100000,\n+  UV_HANDLE_CANCELLATION_PENDING        = 0x00200000,\n+\n+  /* Used by uv_tcp_t and uv_udp_t handles */\n+  UV_HANDLE_IPV6                        = 0x00400000,\n+\n+  /* Only used by uv_tcp_t handles. */\n+  UV_HANDLE_TCP_NODELAY                 = 0x01000000,\n+  UV_HANDLE_TCP_KEEPALIVE               = 0x02000000,\n+  UV_HANDLE_TCP_SINGLE_ACCEPT           = 0x04000000,\n+  UV_HANDLE_TCP_ACCEPT_STATE_CHANGING   = 0x08000000,\n+  UV_HANDLE_TCP_SOCKET_CLOSED           = 0x10000000,\n+  UV_HANDLE_SHARED_TCP_SOCKET           = 0x20000000,\n+\n+  /* Only used by uv_udp_t handles. */\n+  UV_HANDLE_UDP_PROCESSING              = 0x01000000,\n+\n+  /* Only used by uv_pipe_t handles. */\n+  UV_HANDLE_NON_OVERLAPPED_PIPE         = 0x01000000,\n+  UV_HANDLE_PIPESERVER                  = 0x02000000,\n+\n+  /* Only used by uv_tty_t handles. */\n+  UV_HANDLE_TTY_READABLE                = 0x01000000,\n+  UV_HANDLE_TTY_RAW                     = 0x02000000,\n+  UV_HANDLE_TTY_SAVED_POSITION          = 0x04000000,\n+  UV_HANDLE_TTY_SAVED_ATTRIBUTES        = 0x08000000,\n+\n+  /* Only used by uv_signal_t handles. */\n+  UV_SIGNAL_ONE_SHOT_DISPATCHED         = 0x01000000,\n+  UV_SIGNAL_ONE_SHOT                    = 0x02000000,\n+\n+  /* Only used by uv_poll_t handles. */\n+  UV_HANDLE_POLL_SLOW                   = 0x01000000\n };\n-#else\n-# define UV__SIGNAL_ONE_SHOT_DISPATCHED   0x200\n-# define UV__SIGNAL_ONE_SHOT              0x100\n-# define UV__HANDLE_INTERNAL              0x80\n-# define UV__HANDLE_ACTIVE                0x40\n-# define UV__HANDLE_REF                   0x20\n-# define UV__HANDLE_CLOSING               0x01\n-#endif\n \n int uv__loop_configure(uv_loop_t* loop, uv_loop_option option, va_list ap);\n \n@@ -132,6 +177,10 @@ int uv__socket_sockopt(uv_handle_t* handle, int optname, int* value);\n \n void uv__fs_scandir_cleanup(uv_fs_t* req);\n \n+int uv__next_timeout(const uv_loop_t* loop);\n+void uv__run_timers(uv_loop_t* loop);\n+void uv__timer_close(uv_timer_t* handle);\n+\n #define uv__has_active_reqs(loop)                                             \\\n   ((loop)->active_reqs.count > 0)\n \n@@ -164,49 +213,47 @@ void uv__fs_scandir_cleanup(uv_fs_t* req);\n   while (0)\n \n #define uv__is_active(h)                                                      \\\n-  (((h)->flags & UV__HANDLE_ACTIVE) != 0)\n+  (((h)->flags & UV_HANDLE_ACTIVE) != 0)\n \n #define uv__is_closing(h)                                                     \\\n-  (((h)->flags & (UV_CLOSING |  UV_CLOSED)) != 0)\n+  (((h)->flags & (UV_HANDLE_CLOSING | UV_HANDLE_CLOSED)) != 0)\n \n #define uv__handle_start(h)                                                   \\\n   do {                                                                        \\\n-    assert(((h)->flags & UV__HANDLE_CLOSING) == 0);                           \\\n-    if (((h)->flags & UV__HANDLE_ACTIVE) != 0) break;                         \\\n-    (h)->flags |= UV__HANDLE_ACTIVE;                                          \\\n-    if (((h)->flags & UV__HANDLE_REF) != 0) uv__active_handle_add(h);         \\\n+    if (((h)->flags & UV_HANDLE_ACTIVE) != 0) break;                          \\\n+    (h)->flags |= UV_HANDLE_ACTIVE;                                           \\\n+    if (((h)->flags & UV_HANDLE_REF) != 0) uv__active_handle_add(h);          \\\n   }                                                                           \\\n   while (0)\n \n #define uv__handle_stop(h)                                                    \\\n   do {                                                                        \\\n-    assert(((h)->flags & UV__HANDLE_CLOSING) == 0);                           \\\n-    if (((h)->flags & UV__HANDLE_ACTIVE) == 0) break;                         \\\n-    (h)->flags &= ~UV__HANDLE_ACTIVE;                                         \\\n-    if (((h)->flags & UV__HANDLE_REF) != 0) uv__active_handle_rm(h);          \\\n+    if (((h)->flags & UV_HANDLE_ACTIVE) == 0) break;                          \\\n+    (h)->flags &= ~UV_HANDLE_ACTIVE;                                          \\\n+    if (((h)->flags & UV_HANDLE_REF) != 0) uv__active_handle_rm(h);           \\\n   }                                                                           \\\n   while (0)\n \n #define uv__handle_ref(h)                                                     \\\n   do {                                                                        \\\n-    if (((h)->flags & UV__HANDLE_REF) != 0) break;                            \\\n-    (h)->flags |= UV__HANDLE_REF;                                             \\\n-    if (((h)->flags & UV__HANDLE_CLOSING) != 0) break;                        \\\n-    if (((h)->flags & UV__HANDLE_ACTIVE) != 0) uv__active_handle_add(h);      \\\n+    if (((h)->flags & UV_HANDLE_REF) != 0) break;                             \\\n+    (h)->flags |= UV_HANDLE_REF;                                              \\\n+    if (((h)->flags & UV_HANDLE_CLOSING) != 0) break;                         \\\n+    if (((h)->flags & UV_HANDLE_ACTIVE) != 0) uv__active_handle_add(h);       \\\n   }                                                                           \\\n   while (0)\n \n #define uv__handle_unref(h)                                                   \\\n   do {                                                                        \\\n-    if (((h)->flags & UV__HANDLE_REF) == 0) break;                            \\\n-    (h)->flags &= ~UV__HANDLE_REF;                                            \\\n-    if (((h)->flags & UV__HANDLE_CLOSING) != 0) break;                        \\\n-    if (((h)->flags & UV__HANDLE_ACTIVE) != 0) uv__active_handle_rm(h);       \\\n+    if (((h)->flags & UV_HANDLE_REF) == 0) break;                             \\\n+    (h)->flags &= ~UV_HANDLE_REF;                                             \\\n+    if (((h)->flags & UV_HANDLE_CLOSING) != 0) break;                         \\\n+    if (((h)->flags & UV_HANDLE_ACTIVE) != 0) uv__active_handle_rm(h);        \\\n   }                                                                           \\\n   while (0)\n \n #define uv__has_ref(h)                                                        \\\n-  (((h)->flags & UV__HANDLE_REF) != 0)\n+  (((h)->flags & UV_HANDLE_REF) != 0)\n \n #if defined(_WIN32)\n # define uv__handle_platform_init(h) ((h)->u.fd = -1)\n@@ -218,7 +265,7 @@ void uv__fs_scandir_cleanup(uv_fs_t* req);\n   do {                                                                        \\\n     (h)->loop = (loop_);                                                      \\\n     (h)->type = (type_);                                                      \\\n-    (h)->flags = UV__HANDLE_REF;  /* Ref the loop when active. */             \\\n+    (h)->flags = UV_HANDLE_REF;  /* Ref the loop when active. */              \\\n     QUEUE_INSERT_TAIL(&(loop_)->handle_queue, &(h)->handle_queue);            \\\n     uv__handle_platform_init(h);                                              \\\n   }                                                                           \\"
        },
        {
            "sha": "d787f6604eaeddcc5da958639fa6c5423b00752f",
            "filename": "deps/uv/src/win/async.c",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fasync.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fasync.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fasync.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -29,7 +29,7 @@\n \n \n void uv_async_endgame(uv_loop_t* loop, uv_async_t* handle) {\n-  if (handle->flags & UV__HANDLE_CLOSING &&\n+  if (handle->flags & UV_HANDLE_CLOSING &&\n       !handle->async_sent) {\n     assert(!(handle->flags & UV_HANDLE_CLOSED));\n     uv__handle_close(handle);\n@@ -73,7 +73,7 @@ int uv_async_send(uv_async_t* handle) {\n \n   /* The user should make sure never to call uv_async_send to a closing or\n    * closed handle. */\n-  assert(!(handle->flags & UV__HANDLE_CLOSING));\n+  assert(!(handle->flags & UV_HANDLE_CLOSING));\n \n   if (!uv__atomic_exchange_set(&handle->async_sent)) {\n     POST_COMPLETION_FOR_REQ(loop, &handle->async_req);\n@@ -90,7 +90,7 @@ void uv_process_async_wakeup_req(uv_loop_t* loop, uv_async_t* handle,\n \n   handle->async_sent = 0;\n \n-  if (handle->flags & UV__HANDLE_CLOSING) {\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n     uv_want_endgame(loop, (uv_handle_t*)handle);\n   } else if (handle->async_cb != NULL) {\n     handle->async_cb(handle);"
        },
        {
            "sha": "5a76c900337c3d3c8afa8dfba43bc93d705adc55",
            "filename": "deps/uv/src/win/core.c",
            "status": "modified",
            "additions": 24,
            "deletions": 4,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fcore.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fcore.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fcore.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -33,6 +33,7 @@\n #include \"internal.h\"\n #include \"queue.h\"\n #include \"handle-inl.h\"\n+#include \"heap-inl.h\"\n #include \"req-inl.h\"\n \n /* uv_once initialization guards */\n@@ -221,6 +222,7 @@ static void uv_init(void) {\n \n \n int uv_loop_init(uv_loop_t* loop) {\n+  struct heap* timer_heap;\n   int err;\n \n   /* Initialize libuv itself first */\n@@ -246,7 +248,11 @@ int uv_loop_init(uv_loop_t* loop) {\n \n   loop->endgame_handles = NULL;\n \n-  RB_INIT(&loop->timers);\n+  loop->timer_heap = timer_heap = uv__malloc(sizeof(*timer_heap));\n+  if (timer_heap == NULL)\n+    goto fail_timers_alloc;\n+\n+  heap_init(timer_heap);\n \n   loop->check_handles = NULL;\n   loop->prepare_handles = NULL;\n@@ -273,7 +279,7 @@ int uv_loop_init(uv_loop_t* loop) {\n     goto fail_async_init;\n \n   uv__handle_unref(&loop->wq_async);\n-  loop->wq_async.flags |= UV__HANDLE_INTERNAL;\n+  loop->wq_async.flags |= UV_HANDLE_INTERNAL;\n \n   err = uv__loops_add(loop);\n   if (err)\n@@ -285,13 +291,24 @@ int uv_loop_init(uv_loop_t* loop) {\n   uv_mutex_destroy(&loop->wq_mutex);\n \n fail_mutex_init:\n+  uv__free(timer_heap);\n+  loop->timer_heap = NULL;\n+\n+fail_timers_alloc:\n   CloseHandle(loop->iocp);\n   loop->iocp = INVALID_HANDLE_VALUE;\n \n   return err;\n }\n \n \n+void uv_update_time(uv_loop_t* loop) {\n+  uint64_t new_time = uv__hrtime(1000);\n+  assert(new_time >= loop->time);\n+  loop->time = new_time;\n+}\n+\n+\n void uv__once_init(void) {\n   uv_once(&uv_init_guard_, uv_init);\n }\n@@ -320,6 +337,9 @@ void uv__loop_close(uv_loop_t* loop) {\n   uv_mutex_unlock(&loop->wq_mutex);\n   uv_mutex_destroy(&loop->wq_mutex);\n \n+  uv__free(loop->timer_heap);\n+  loop->timer_heap = NULL;\n+\n   CloseHandle(loop->iocp);\n }\n \n@@ -441,7 +461,7 @@ int uv_run(uv_loop_t *loop, uv_run_mode mode) {\n \n   while (r != 0 && loop->stop_flag == 0) {\n     uv_update_time(loop);\n-    uv_process_timers(loop);\n+    uv__run_timers(loop);\n \n     ran_pending = uv_process_reqs(loop);\n     uv_idle_invoke(loop);\n@@ -465,7 +485,7 @@ int uv_run(uv_loop_t *loop, uv_run_mode mode) {\n        * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from\n        * the check.\n        */\n-      uv_process_timers(loop);\n+      uv__run_timers(loop);\n     }\n \n     r = uv__loop_alive(loop);"
        },
        {
            "sha": "226e6e7aee6c0981664653ab15cb7bf46caecfbb",
            "filename": "deps/uv/src/win/fs-event.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Ffs-event.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Ffs-event.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ffs-event.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -419,7 +419,7 @@ void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,\n    * - We are not active, just ignore the callback\n    */\n   if (!uv__is_active(handle)) {\n-    if (handle->flags & UV__HANDLE_CLOSING) {\n+    if (handle->flags & UV_HANDLE_CLOSING) {\n       uv_want_endgame(loop, (uv_handle_t*) handle);\n     }\n     return;\n@@ -543,7 +543,7 @@ void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,\n         }\n \n         offset = file_info->NextEntryOffset;\n-      } while (offset && !(handle->flags & UV__HANDLE_CLOSING));\n+      } while (offset && !(handle->flags & UV_HANDLE_CLOSING));\n     } else {\n       handle->cb(handle, NULL, UV_CHANGE, 0);\n     }\n@@ -552,7 +552,7 @@ void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,\n     handle->cb(handle, NULL, 0, uv_translate_sys_error(err));\n   }\n \n-  if (!(handle->flags & UV__HANDLE_CLOSING)) {\n+  if (!(handle->flags & UV_HANDLE_CLOSING)) {\n     uv_fs_event_queue_readdirchanges(loop, handle);\n   } else {\n     uv_want_endgame(loop, (uv_handle_t*)handle);\n@@ -573,7 +573,7 @@ void uv_fs_event_close(uv_loop_t* loop, uv_fs_event_t* handle) {\n \n \n void uv_fs_event_endgame(uv_loop_t* loop, uv_fs_event_t* handle) {\n-  if ((handle->flags & UV__HANDLE_CLOSING) && !handle->req_pending) {\n+  if ((handle->flags & UV_HANDLE_CLOSING) && !handle->req_pending) {\n     assert(!(handle->flags & UV_HANDLE_CLOSED));\n \n     if (handle->buffer) {"
        },
        {
            "sha": "82c657d579fb047b2649eacb0642fabe8c9e193c",
            "filename": "deps/uv/src/win/handle-inl.h",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fhandle-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fhandle-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fhandle-inl.h?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -32,7 +32,7 @@\n #define DECREASE_ACTIVE_COUNT(loop, handle)                             \\\n   do {                                                                  \\\n     if (--(handle)->activecnt == 0 &&                                   \\\n-        !((handle)->flags & UV__HANDLE_CLOSING)) {                      \\\n+        !((handle)->flags & UV_HANDLE_CLOSING)) {                       \\\n       uv__handle_stop((handle));                                        \\\n     }                                                                   \\\n     assert((handle)->activecnt >= 0);                                   \\\n@@ -53,7 +53,7 @@\n     assert(handle->reqs_pending > 0);                                   \\\n     handle->reqs_pending--;                                             \\\n                                                                         \\\n-    if (handle->flags & UV__HANDLE_CLOSING &&                           \\\n+    if (handle->flags & UV_HANDLE_CLOSING &&                            \\\n         handle->reqs_pending == 0) {                                    \\\n       uv_want_endgame(loop, (uv_handle_t*)handle);                      \\\n     }                                                                   \\\n@@ -62,14 +62,14 @@\n \n #define uv__handle_closing(handle)                                      \\\n   do {                                                                  \\\n-    assert(!((handle)->flags & UV__HANDLE_CLOSING));                    \\\n+    assert(!((handle)->flags & UV_HANDLE_CLOSING));                     \\\n                                                                         \\\n-    if (!(((handle)->flags & UV__HANDLE_ACTIVE) &&                      \\\n-          ((handle)->flags & UV__HANDLE_REF)))                          \\\n+    if (!(((handle)->flags & UV_HANDLE_ACTIVE) &&                       \\\n+          ((handle)->flags & UV_HANDLE_REF)))                           \\\n       uv__active_handle_add((uv_handle_t*) (handle));                   \\\n                                                                         \\\n-    (handle)->flags |= UV__HANDLE_CLOSING;                              \\\n-    (handle)->flags &= ~UV__HANDLE_ACTIVE;                              \\\n+    (handle)->flags |= UV_HANDLE_CLOSING;                               \\\n+    (handle)->flags &= ~UV_HANDLE_ACTIVE;                               \\\n   } while (0)\n \n \n@@ -126,7 +126,8 @@ INLINE static void uv_process_endgames(uv_loop_t* loop) {\n         break;\n \n       case UV_TIMER:\n-        uv_timer_endgame(loop, (uv_timer_t*) handle);\n+        uv__timer_close((uv_timer_t*) handle);\n+        uv__handle_close(handle);\n         break;\n \n       case UV_PREPARE:"
        },
        {
            "sha": "738d7ff3248ab4a8bbf8854bb5346ca4c039eb32",
            "filename": "deps/uv/src/win/handle.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fhandle.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fhandle.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fhandle.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -59,15 +59,15 @@ uv_handle_type uv_guess_handle(uv_file file) {\n \n \n int uv_is_active(const uv_handle_t* handle) {\n-  return (handle->flags & UV__HANDLE_ACTIVE) &&\n-        !(handle->flags & UV__HANDLE_CLOSING);\n+  return (handle->flags & UV_HANDLE_ACTIVE) &&\n+        !(handle->flags & UV_HANDLE_CLOSING);\n }\n \n \n void uv_close(uv_handle_t* handle, uv_close_cb cb) {\n   uv_loop_t* loop = handle->loop;\n \n-  if (handle->flags & UV__HANDLE_CLOSING) {\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n     assert(0);\n     return;\n   }\n@@ -150,7 +150,7 @@ void uv_close(uv_handle_t* handle, uv_close_cb cb) {\n \n \n int uv_is_closing(const uv_handle_t* handle) {\n-  return !!(handle->flags & (UV__HANDLE_CLOSING | UV_HANDLE_CLOSED));\n+  return !!(handle->flags & (UV_HANDLE_CLOSING | UV_HANDLE_CLOSED));\n }\n \n "
        },
        {
            "sha": "b37b4c0c9be59fd04b282d17b7e290b4d7c69cfc",
            "filename": "deps/uv/src/win/internal.h",
            "status": "modified",
            "additions": 0,
            "deletions": 72,
            "changes": 72,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Finternal.h",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Finternal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Finternal.h?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -57,69 +57,6 @@ extern UV_THREAD_LOCAL int uv__crt_assert_enabled;\n #define UV_END_DISABLE_CRT_ASSERT()\n #endif\n \n-/*\n- * Handles\n- * (also see handle-inl.h)\n- */\n-\n-/* Used by all handles. */\n-#define UV_HANDLE_CLOSED                        0x00000002\n-#define UV_HANDLE_ENDGAME_QUEUED                0x00000008\n-\n-/* uv-common.h: #define UV__HANDLE_CLOSING      0x00000001 */\n-/* uv-common.h: #define UV__HANDLE_ACTIVE       0x00000040 */\n-/* uv-common.h: #define UV__HANDLE_REF          0x00000020 */\n-/* uv-common.h: #define UV_HANDLE_INTERNAL      0x00000080 */\n-\n-/* Used by streams and UDP handles. */\n-#define UV_HANDLE_READING                       0x00000100\n-#define UV_HANDLE_BOUND                         0x00000200\n-#define UV_HANDLE_LISTENING                     0x00000800\n-#define UV_HANDLE_CONNECTION                    0x00001000\n-#define UV_HANDLE_READABLE                      0x00008000\n-#define UV_HANDLE_WRITABLE                      0x00010000\n-#define UV_HANDLE_READ_PENDING                  0x00020000\n-#define UV_HANDLE_SYNC_BYPASS_IOCP              0x00040000\n-#define UV_HANDLE_ZERO_READ                     0x00080000\n-#define UV_HANDLE_EMULATE_IOCP                  0x00100000\n-#define UV_HANDLE_BLOCKING_WRITES               0x00200000\n-#define UV_HANDLE_CANCELLATION_PENDING          0x00400000\n-\n-/* Used by uv_tcp_t and uv_udp_t handles */\n-#define UV_HANDLE_IPV6                          0x01000000\n-\n-/* Only used by uv_tcp_t handles. */\n-#define UV_HANDLE_TCP_NODELAY                   0x02000000\n-#define UV_HANDLE_TCP_KEEPALIVE                 0x04000000\n-#define UV_HANDLE_TCP_SINGLE_ACCEPT             0x08000000\n-#define UV_HANDLE_TCP_ACCEPT_STATE_CHANGING     0x10000000\n-#define UV_HANDLE_TCP_SOCKET_CLOSED             0x20000000\n-#define UV_HANDLE_SHARED_TCP_SOCKET             0x40000000\n-\n-/* Only used by uv_pipe_t handles. */\n-#define UV_HANDLE_NON_OVERLAPPED_PIPE           0x01000000\n-#define UV_HANDLE_PIPESERVER                    0x02000000\n-\n-/* Only used by uv_tty_t handles. */\n-#define UV_HANDLE_TTY_READABLE                  0x01000000\n-#define UV_HANDLE_TTY_RAW                       0x02000000\n-#define UV_HANDLE_TTY_SAVED_POSITION            0x04000000\n-#define UV_HANDLE_TTY_SAVED_ATTRIBUTES          0x08000000\n-\n-/* Only used by uv_poll_t handles. */\n-#define UV_HANDLE_POLL_SLOW                     0x02000000\n-\n-\n-/*\n- * Requests: see req-inl.h\n- */\n-\n-\n-/*\n- * Streams: see stream-inl.h\n- */\n-\n-\n /*\n  * TCP\n  */\n@@ -246,15 +183,6 @@ int uv_poll_close(uv_loop_t* loop, uv_poll_t* handle);\n void uv_poll_endgame(uv_loop_t* loop, uv_poll_t* handle);\n \n \n-/*\n- * Timers\n- */\n-void uv_timer_endgame(uv_loop_t* loop, uv_timer_t* handle);\n-\n-DWORD uv__next_timeout(const uv_loop_t* loop);\n-void uv_process_timers(uv_loop_t* loop);\n-\n-\n /*\n  * Loop watchers\n  */"
        },
        {
            "sha": "ad7fbea169717f3f43676c3b0dd4ea08a5bec33d",
            "filename": "deps/uv/src/win/loop-watcher.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Floop-watcher.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Floop-watcher.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Floop-watcher.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -27,7 +27,7 @@\n \n \n void uv_loop_watcher_endgame(uv_loop_t* loop, uv_handle_t* handle) {\n-  if (handle->flags & UV__HANDLE_CLOSING) {\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n     assert(!(handle->flags & UV_HANDLE_CLOSED));\n     handle->flags |= UV_HANDLE_CLOSED;\n     uv__handle_close(handle);"
        },
        {
            "sha": "42380f6599a45bc58b50e1a55856a6d877815398",
            "filename": "deps/uv/src/win/pipe.c",
            "status": "modified",
            "additions": 9,
            "deletions": 10,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -21,7 +21,6 @@\n \n #include <assert.h>\n #include <io.h>\n-#include <stdbool.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n@@ -347,7 +346,7 @@ void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {\n     /* Clear the shutdown_req field so we don't go here again. */\n     handle->stream.conn.shutdown_req = NULL;\n \n-    if (handle->flags & UV__HANDLE_CLOSING) {\n+    if (handle->flags & UV_HANDLE_CLOSING) {\n       UNREGISTER_HANDLE_REQ(loop, handle, req);\n \n       /* Already closing. Cancel the shutdown. */\n@@ -408,7 +407,7 @@ void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {\n     }\n   }\n \n-  if (handle->flags & UV__HANDLE_CLOSING &&\n+  if (handle->flags & UV_HANDLE_CLOSING &&\n       handle->reqs_pending == 0) {\n     assert(!(handle->flags & UV_HANDLE_CLOSED));\n \n@@ -907,7 +906,7 @@ int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client) {\n     req->next_pending = NULL;\n     req->pipeHandle = INVALID_HANDLE_VALUE;\n \n-    if (!(server->flags & UV__HANDLE_CLOSING)) {\n+    if (!(server->flags & UV_HANDLE_CLOSING)) {\n       uv_pipe_queue_accept(loop, server, req, FALSE);\n     }\n   }\n@@ -1294,7 +1293,7 @@ static int uv__pipe_write_data(uv_loop_t* loop,\n                                size_t nbufs,\n                                uv_stream_t* send_handle,\n                                uv_write_cb cb,\n-                               bool copy_always) {\n+                               int copy_always) {\n   int err;\n   int result;\n   uv_buf_t write_buf;\n@@ -1536,7 +1535,7 @@ int uv__pipe_write_ipc(uv_loop_t* loop,\n   /* Write buffers. We set the `always_copy` flag, so it is not a problem that\n    * some of the written data lives on the stack. */\n   err = uv__pipe_write_data(\n-      loop, req, handle, bufs, buf_count, send_handle, cb, true);\n+      loop, req, handle, bufs, buf_count, send_handle, cb, 1);\n \n   /* If we had to heap-allocate the bufs array, free it now. */\n   if (bufs != stack_bufs) {\n@@ -1561,7 +1560,7 @@ int uv__pipe_write(uv_loop_t* loop,\n     /* Non-IPC pipe write: put data on the wire directly. */\n     assert(send_handle == NULL);\n     return uv__pipe_write_data(\n-        loop, req, handle, bufs, nbufs, NULL, cb, false);\n+        loop, req, handle, bufs, nbufs, NULL, cb, 0);\n   }\n }\n \n@@ -1675,7 +1674,7 @@ static DWORD uv__pipe_read_data(uv_loop_t* loop,\n \n \n static DWORD uv__pipe_read_ipc(uv_loop_t* loop, uv_pipe_t* handle) {\n-  DWORD* data_remaining = &handle->pipe.conn.ipc_data_frame.payload_remaining;\n+  uint32_t* data_remaining = &handle->pipe.conn.ipc_data_frame.payload_remaining;\n   int err;\n \n   if (*data_remaining > 0) {\n@@ -1856,7 +1855,7 @@ void uv_process_pipe_accept_req(uv_loop_t* loop, uv_pipe_t* handle,\n \n   assert(handle->type == UV_NAMED_PIPE);\n \n-  if (handle->flags & UV__HANDLE_CLOSING) {\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n     /* The req->pipeHandle should be freed already in uv_pipe_cleanup(). */\n     assert(req->pipeHandle == INVALID_HANDLE_VALUE);\n     DECREASE_PENDING_REQ_COUNT(handle);\n@@ -1876,7 +1875,7 @@ void uv_process_pipe_accept_req(uv_loop_t* loop, uv_pipe_t* handle,\n       CloseHandle(req->pipeHandle);\n       req->pipeHandle = INVALID_HANDLE_VALUE;\n     }\n-    if (!(handle->flags & UV__HANDLE_CLOSING)) {\n+    if (!(handle->flags & UV_HANDLE_CLOSING)) {\n       uv_pipe_queue_accept(loop, handle, req, FALSE);\n     }\n   }"
        },
        {
            "sha": "77eb071c85a338ca2176d947fbe0e3a94c16c5f7",
            "filename": "deps/uv/src/win/poll.c",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fpoll.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fpoll.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fpoll.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -218,7 +218,7 @@ static void uv__fast_poll_process_poll_req(uv_loop_t* loop, uv_poll_t* handle,\n   if ((handle->events & ~(handle->submitted_events_1 |\n       handle->submitted_events_2)) != 0) {\n     uv__fast_poll_submit_poll_req(loop, handle);\n-  } else if ((handle->flags & UV__HANDLE_CLOSING) &&\n+  } else if ((handle->flags & UV_HANDLE_CLOSING) &&\n              handle->submitted_events_1 == 0 &&\n              handle->submitted_events_2 == 0) {\n     uv_want_endgame(loop, (uv_handle_t*) handle);\n@@ -228,7 +228,7 @@ static void uv__fast_poll_process_poll_req(uv_loop_t* loop, uv_poll_t* handle,\n \n static int uv__fast_poll_set(uv_loop_t* loop, uv_poll_t* handle, int events) {\n   assert(handle->type == UV_POLL);\n-  assert(!(handle->flags & UV__HANDLE_CLOSING));\n+  assert(!(handle->flags & UV_HANDLE_CLOSING));\n   assert((events & ~(UV_READABLE | UV_WRITABLE | UV_DISCONNECT)) == 0);\n \n   handle->events = events;\n@@ -461,7 +461,7 @@ static void uv__slow_poll_process_poll_req(uv_loop_t* loop, uv_poll_t* handle,\n   if ((handle->events & ~(handle->submitted_events_1 |\n       handle->submitted_events_2)) != 0) {\n     uv__slow_poll_submit_poll_req(loop, handle);\n-  } else if ((handle->flags & UV__HANDLE_CLOSING) &&\n+  } else if ((handle->flags & UV_HANDLE_CLOSING) &&\n              handle->submitted_events_1 == 0 &&\n              handle->submitted_events_2 == 0) {\n     uv_want_endgame(loop, (uv_handle_t*) handle);\n@@ -471,7 +471,7 @@ static void uv__slow_poll_process_poll_req(uv_loop_t* loop, uv_poll_t* handle,\n \n static int uv__slow_poll_set(uv_loop_t* loop, uv_poll_t* handle, int events) {\n   assert(handle->type == UV_POLL);\n-  assert(!(handle->flags & UV__HANDLE_CLOSING));\n+  assert(!(handle->flags & UV_HANDLE_CLOSING));\n   assert((events & ~(UV_READABLE | UV_WRITABLE)) == 0);\n \n   handle->events = events;\n@@ -633,7 +633,7 @@ int uv_poll_close(uv_loop_t* loop, uv_poll_t* handle) {\n \n \n void uv_poll_endgame(uv_loop_t* loop, uv_poll_t* handle) {\n-  assert(handle->flags & UV__HANDLE_CLOSING);\n+  assert(handle->flags & UV_HANDLE_CLOSING);\n   assert(!(handle->flags & UV_HANDLE_CLOSED));\n \n   assert(handle->submitted_events_1 == 0);"
        },
        {
            "sha": "355d6188088b4ad89af7789b0afffe24acd13ce1",
            "filename": "deps/uv/src/win/process-stdio.c",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fprocess-stdio.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fprocess-stdio.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fprocess-stdio.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -103,6 +103,7 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,\n   DWORD client_access = 0;\n   HANDLE child_pipe = INVALID_HANDLE_VALUE;\n   int err;\n+  int overlap;\n \n   if (flags & UV_READABLE_PIPE) {\n     /* The server needs inbound access too, otherwise CreateNamedPipe() won't\n@@ -130,7 +131,7 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,\n   sa.lpSecurityDescriptor = NULL;\n   sa.bInheritHandle = TRUE;\n \n-  BOOL overlap = server_pipe->ipc || (flags & UV_OVERLAPPED_PIPE);\n+  overlap = server_pipe->ipc || (flags & UV_OVERLAPPED_PIPE);\n   child_pipe = CreateFileA(pipe_name,\n                            client_access,\n                            0,"
        },
        {
            "sha": "b47f203e9d9c7f7890325e8affa44685a40982de",
            "filename": "deps/uv/src/win/process.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fprocess.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fprocess.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fprocess.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -872,7 +872,7 @@ void uv_process_proc_exit(uv_loop_t* loop, uv_process_t* handle) {\n \n   /* If we're closing, don't call the exit callback. Just schedule a close\n    * callback now. */\n-  if (handle->flags & UV__HANDLE_CLOSING) {\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n     uv_want_endgame(loop, (uv_handle_t*) handle);\n     return;\n   }\n@@ -924,7 +924,7 @@ void uv_process_close(uv_loop_t* loop, uv_process_t* handle) {\n \n void uv_process_endgame(uv_loop_t* loop, uv_process_t* handle) {\n   assert(!handle->exit_cb_pending);\n-  assert(handle->flags & UV__HANDLE_CLOSING);\n+  assert(handle->flags & UV_HANDLE_CLOSING);\n   assert(!(handle->flags & UV_HANDLE_CLOSED));\n \n   /* Clean-up the process handle. */"
        },
        {
            "sha": "3d0b8a35b93ace1272af5595f9bbafb84dd4ccc9",
            "filename": "deps/uv/src/win/signal.c",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fsignal.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fsignal.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fsignal.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -90,16 +90,16 @@ int uv__signal_dispatch(int signum) {\n     unsigned long previous = InterlockedExchange(\n             (volatile LONG*) &handle->pending_signum, signum);\n \n-    if (handle->flags & UV__SIGNAL_ONE_SHOT_DISPATCHED)\n+    if (handle->flags & UV_SIGNAL_ONE_SHOT_DISPATCHED)\n       continue;\n \n     if (!previous) {\n       POST_COMPLETION_FOR_REQ(handle->loop, &handle->signal_req);\n     }\n \n     dispatched = 1;\n-    if (handle->flags & UV__SIGNAL_ONE_SHOT)\n-      handle->flags |= UV__SIGNAL_ONE_SHOT_DISPATCHED;\n+    if (handle->flags & UV_SIGNAL_ONE_SHOT)\n+      handle->flags |= UV_SIGNAL_ONE_SHOT_DISPATCHED;\n   }\n \n   LeaveCriticalSection(&uv__signal_lock);\n@@ -213,7 +213,7 @@ int uv__signal_start(uv_signal_t* handle,\n \n   handle->signum = signum;\n   if (oneshot)\n-    handle->flags |= UV__SIGNAL_ONE_SHOT;\n+    handle->flags |= UV_SIGNAL_ONE_SHOT;\n \n   RB_INSERT(uv_signal_tree_s, &uv__signal_tree, handle);\n \n@@ -243,10 +243,10 @@ void uv_process_signal_req(uv_loop_t* loop, uv_signal_t* handle,\n   if (dispatched_signum == handle->signum)\n     handle->signal_cb(handle, dispatched_signum);\n \n-  if (handle->flags & UV__SIGNAL_ONE_SHOT)\n+  if (handle->flags & UV_SIGNAL_ONE_SHOT)\n     uv_signal_stop(handle);\n \n-  if (handle->flags & UV__HANDLE_CLOSING) {\n+  if (handle->flags & UV_HANDLE_CLOSING) {\n     /* When it is closing, it must be stopped at this point. */\n     assert(handle->signum == 0);\n     uv_want_endgame(loop, (uv_handle_t*) handle);\n@@ -265,7 +265,7 @@ void uv_signal_close(uv_loop_t* loop, uv_signal_t* handle) {\n \n \n void uv_signal_endgame(uv_loop_t* loop, uv_signal_t* handle) {\n-  assert(handle->flags & UV__HANDLE_CLOSING);\n+  assert(handle->flags & UV_HANDLE_CLOSING);\n   assert(!(handle->flags & UV_HANDLE_CLOSED));\n \n   assert(handle->signum == 0);"
        },
        {
            "sha": "7656627e902da0f4c1b78f8ad4bacaf26cbf05c3",
            "filename": "deps/uv/src/win/stream.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fstream.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fstream.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fstream.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -176,7 +176,7 @@ int uv_write2(uv_write_t* req,\n int uv_try_write(uv_stream_t* stream,\n                  const uv_buf_t bufs[],\n                  unsigned int nbufs) {\n-  if (stream->flags & UV__HANDLE_CLOSING)\n+  if (stream->flags & UV_HANDLE_CLOSING)\n     return UV_EBADF;\n   if (!(stream->flags & UV_HANDLE_WRITABLE))\n     return UV_EPIPE;"
        },
        {
            "sha": "a97ab2a518871424c20011b28faeee7e7688c478",
            "filename": "deps/uv/src/win/tcp.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Ftcp.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Ftcp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ftcp.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -217,7 +217,7 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle) {\n     UNREGISTER_HANDLE_REQ(loop, handle, handle->stream.conn.shutdown_req);\n \n     err = 0;\n-    if (handle->flags & UV__HANDLE_CLOSING) {\n+    if (handle->flags & UV_HANDLE_CLOSING) {\n       err = ERROR_OPERATION_ABORTED;\n     } else if (shutdown(handle->socket, SD_SEND) == SOCKET_ERROR) {\n       err = WSAGetLastError();\n@@ -233,7 +233,7 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle) {\n     return;\n   }\n \n-  if (handle->flags & UV__HANDLE_CLOSING &&\n+  if (handle->flags & UV_HANDLE_CLOSING &&\n       handle->reqs_pending == 0) {\n     assert(!(handle->flags & UV_HANDLE_CLOSED));\n \n@@ -680,7 +680,7 @@ int uv_tcp_accept(uv_tcp_t* server, uv_tcp_t* client) {\n   req->next_pending = NULL;\n   req->accept_socket = INVALID_SOCKET;\n \n-  if (!(server->flags & UV__HANDLE_CLOSING)) {\n+  if (!(server->flags & UV_HANDLE_CLOSING)) {\n     /* Check if we're in a middle of changing the number of pending accepts. */\n     if (!(server->flags & UV_HANDLE_TCP_ACCEPT_STATE_CHANGING)) {\n       uv_tcp_queue_accept(server, req);\n@@ -1166,7 +1166,7 @@ void uv_process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,\n \n   err = 0;\n   if (REQ_SUCCESS(req)) {\n-    if (handle->flags & UV__HANDLE_CLOSING) {\n+    if (handle->flags & UV_HANDLE_CLOSING) {\n       /* use UV_ECANCELED for consistency with Unix */\n       err = ERROR_OPERATION_ABORTED;\n     } else if (setsockopt(handle->socket,"
        },
        {
            "sha": "6e41dcd8a087da40fc6e6d5566be4e99a126b956",
            "filename": "deps/uv/src/win/thread.c",
            "status": "modified",
            "additions": 1,
            "deletions": 10,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -26,15 +26,6 @@\n #include \"uv.h\"\n #include \"internal.h\"\n \n-static int uv_cond_condvar_init(uv_cond_t* cond);\n-static void uv_cond_condvar_destroy(uv_cond_t* cond);\n-static void uv_cond_condvar_signal(uv_cond_t* cond);\n-static void uv_cond_condvar_broadcast(uv_cond_t* cond);\n-static void uv_cond_condvar_wait(uv_cond_t* cond, uv_mutex_t* mutex);\n-static int uv_cond_condvar_timedwait(uv_cond_t* cond,\n-    uv_mutex_t* mutex, uint64_t timeout);\n-\n-\n static void uv__once_inner(uv_once_t* guard, void (*callback)(void)) {\n   DWORD result;\n   HANDLE existing_event, created_event;\n@@ -374,7 +365,7 @@ int uv_cond_init(uv_cond_t* cond) {\n \n void uv_cond_destroy(uv_cond_t* cond) {\n   /* nothing to do */\n-  UV__UNUSED(cond);\n+  (void) &cond;\n }\n \n "
        },
        {
            "sha": "eda5c24f6e83921582d8f5ad065dab68e122a3b7",
            "filename": "deps/uv/src/win/timer.c",
            "status": "removed",
            "additions": 0,
            "deletions": 195,
            "changes": 195,
            "blob_url": "https://github.com/nodejs/node/blob/9d71619bbee7c198cb20ec4702024ac983b5db7d/deps%2Fuv%2Fsrc%2Fwin%2Ftimer.c",
            "raw_url": "https://github.com/nodejs/node/raw/9d71619bbee7c198cb20ec4702024ac983b5db7d/deps%2Fuv%2Fsrc%2Fwin%2Ftimer.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ftimer.c?ref=9d71619bbee7c198cb20ec4702024ac983b5db7d",
            "patch": "@@ -1,195 +0,0 @@\n-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to\n- * deal in the Software without restriction, including without limitation the\n- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n- * sell copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n- * IN THE SOFTWARE.\n- */\n-\n-#include <assert.h>\n-#include <limits.h>\n-\n-#include \"uv.h\"\n-#include \"internal.h\"\n-#include \"uv/tree.h\"\n-#include \"handle-inl.h\"\n-\n-\n-/* The number of milliseconds in one second. */\n-#define UV__MILLISEC 1000\n-\n-\n-void uv_update_time(uv_loop_t* loop) {\n-  uint64_t new_time = uv__hrtime(UV__MILLISEC);\n-  assert(new_time >= loop->time);\n-  loop->time = new_time;\n-}\n-\n-\n-static int uv_timer_compare(uv_timer_t* a, uv_timer_t* b) {\n-  if (a->due < b->due)\n-    return -1;\n-  if (a->due > b->due)\n-    return 1;\n-  /*\n-   *  compare start_id when both has the same due. start_id is\n-   *  allocated with loop->timer_counter in uv_timer_start().\n-   */\n-  if (a->start_id < b->start_id)\n-    return -1;\n-  if (a->start_id > b->start_id)\n-    return 1;\n-  return 0;\n-}\n-\n-\n-RB_GENERATE_STATIC(uv_timer_tree_s, uv_timer_s, tree_entry, uv_timer_compare)\n-\n-\n-int uv_timer_init(uv_loop_t* loop, uv_timer_t* handle) {\n-  uv__handle_init(loop, (uv_handle_t*) handle, UV_TIMER);\n-  handle->timer_cb = NULL;\n-  handle->repeat = 0;\n-\n-  return 0;\n-}\n-\n-\n-void uv_timer_endgame(uv_loop_t* loop, uv_timer_t* handle) {\n-  if (handle->flags & UV__HANDLE_CLOSING) {\n-    assert(!(handle->flags & UV_HANDLE_CLOSED));\n-    uv__handle_close(handle);\n-  }\n-}\n-\n-\n-static uint64_t get_clamped_due_time(uint64_t loop_time, uint64_t timeout) {\n-  uint64_t clamped_timeout;\n-\n-  clamped_timeout = loop_time + timeout;\n-  if (clamped_timeout < timeout)\n-    clamped_timeout = (uint64_t) -1;\n-\n-  return clamped_timeout;\n-}\n-\n-\n-int uv_timer_start(uv_timer_t* handle, uv_timer_cb timer_cb, uint64_t timeout,\n-    uint64_t repeat) {\n-  uv_loop_t* loop = handle->loop;\n-  uv_timer_t* old;\n-\n-  if (timer_cb == NULL)\n-    return UV_EINVAL;\n-\n-  if (uv__is_active(handle))\n-    uv_timer_stop(handle);\n-\n-  handle->timer_cb = timer_cb;\n-  handle->due = get_clamped_due_time(loop->time, timeout);\n-  handle->repeat = repeat;\n-  uv__handle_start(handle);\n-\n-  /* start_id is the second index to be compared in uv__timer_cmp() */\n-  handle->start_id = handle->loop->timer_counter++;\n-\n-  old = RB_INSERT(uv_timer_tree_s, &loop->timers, handle);\n-  assert(old == NULL);\n-\n-  return 0;\n-}\n-\n-\n-int uv_timer_stop(uv_timer_t* handle) {\n-  uv_loop_t* loop = handle->loop;\n-\n-  if (!uv__is_active(handle))\n-    return 0;\n-\n-  RB_REMOVE(uv_timer_tree_s, &loop->timers, handle);\n-  uv__handle_stop(handle);\n-\n-  return 0;\n-}\n-\n-\n-int uv_timer_again(uv_timer_t* handle) {\n-  /* If timer_cb is NULL that means that the timer was never started. */\n-  if (!handle->timer_cb) {\n-    return UV_EINVAL;\n-  }\n-\n-  if (handle->repeat) {\n-    uv_timer_stop(handle);\n-    uv_timer_start(handle, handle->timer_cb, handle->repeat, handle->repeat);\n-  }\n-\n-  return 0;\n-}\n-\n-\n-void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat) {\n-  assert(handle->type == UV_TIMER);\n-  handle->repeat = repeat;\n-}\n-\n-\n-uint64_t uv_timer_get_repeat(const uv_timer_t* handle) {\n-  assert(handle->type == UV_TIMER);\n-  return handle->repeat;\n-}\n-\n-\n-DWORD uv__next_timeout(const uv_loop_t* loop) {\n-  uv_timer_t* timer;\n-  int64_t delta;\n-\n-  /* Check if there are any running timers\n-   * Need to cast away const first, since RB_MIN doesn't know what we are\n-   * going to do with this return value, it can't be marked const\n-   */\n-  timer = RB_MIN(uv_timer_tree_s, &((uv_loop_t*)loop)->timers);\n-  if (timer) {\n-    delta = timer->due - loop->time;\n-    if (delta >= UINT_MAX - 1) {\n-      /* A timeout value of UINT_MAX means infinite, so that's no good. */\n-      return UINT_MAX - 1;\n-    } else if (delta < 0) {\n-      /* Negative timeout values are not allowed */\n-      return 0;\n-    } else {\n-      return (DWORD)delta;\n-    }\n-  } else {\n-    /* No timers */\n-    return INFINITE;\n-  }\n-}\n-\n-\n-void uv_process_timers(uv_loop_t* loop) {\n-  uv_timer_t* timer;\n-\n-  /* Call timer callbacks */\n-  for (timer = RB_MIN(uv_timer_tree_s, &loop->timers);\n-       timer != NULL && timer->due <= loop->time;\n-       timer = RB_MIN(uv_timer_tree_s, &loop->timers)) {\n-\n-    uv_timer_stop(timer);\n-    uv_timer_again(timer);\n-    timer->timer_cb((uv_timer_t*) timer);\n-  }\n-}"
        },
        {
            "sha": "d62aafb7d8c9213d09aa7c11e64cd7af912c11f8",
            "filename": "deps/uv/src/win/tty.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -2208,7 +2208,7 @@ void uv_tty_endgame(uv_loop_t* loop, uv_tty_t* handle) {\n \n     /* TTY shutdown is really just a no-op */\n     if (handle->stream.conn.shutdown_req->cb) {\n-      if (handle->flags & UV__HANDLE_CLOSING) {\n+      if (handle->flags & UV_HANDLE_CLOSING) {\n         handle->stream.conn.shutdown_req->cb(handle->stream.conn.shutdown_req, UV_ECANCELED);\n       } else {\n         handle->stream.conn.shutdown_req->cb(handle->stream.conn.shutdown_req, 0);\n@@ -2221,7 +2221,7 @@ void uv_tty_endgame(uv_loop_t* loop, uv_tty_t* handle) {\n     return;\n   }\n \n-  if (handle->flags & UV__HANDLE_CLOSING &&\n+  if (handle->flags & UV_HANDLE_CLOSING &&\n       handle->reqs_pending == 0) {\n     /* The wait handle used for raw reading should be unregistered when the\n      * wait callback runs. */"
        },
        {
            "sha": "402aeea6666b5a800c79c7c2594ff2a1d41354bd",
            "filename": "deps/uv/src/win/udp.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fudp.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fsrc%2Fwin%2Fudp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fudp.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -188,7 +188,7 @@ void uv_udp_close(uv_loop_t* loop, uv_udp_t* handle) {\n \n \n void uv_udp_endgame(uv_loop_t* loop, uv_udp_t* handle) {\n-  if (handle->flags & UV__HANDLE_CLOSING &&\n+  if (handle->flags & UV_HANDLE_CLOSING &&\n       handle->reqs_pending == 0) {\n     assert(!(handle->flags & UV_HANDLE_CLOSED));\n     uv__handle_close(handle);"
        },
        {
            "sha": "ec60f16403ad0b3f625cebb0706e6140a10894c3",
            "filename": "deps/uv/test/test-condvar.c",
            "status": "modified",
            "additions": 134,
            "deletions": 112,
            "changes": 246,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Ftest%2Ftest-condvar.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Ftest%2Ftest-condvar.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-condvar.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -25,221 +25,243 @@\n #include <string.h>\n #include <errno.h>\n \n+struct worker_config;\n+\n+typedef void (*signal_func)(struct worker_config* c, int* flag);\n+typedef int (*wait_func)(struct worker_config* c, const int* flag);\n+\n typedef struct worker_config {\n+  uv_sem_t sem_waiting; /* post before waiting. */\n+  uv_sem_t sem_signaled; /* post after signaling. */\n   uv_mutex_t mutex;\n   uv_cond_t cond;\n-  int signal_delay;\n-  int wait_delay;\n   int use_broadcast;\n-  volatile int posted_1;\n-  volatile int posted_2;\n-  void (*signal_cond)(struct worker_config* c, volatile int* flag);\n-  int (*wait_cond)(struct worker_config* c, const volatile int* flag);\n+  int posted_1;\n+  int posted_2;\n+  signal_func signal_cond;\n+  wait_func wait_cond;\n } worker_config;\n \n+void worker_config_init(worker_config* wc,\n+                        int use_broadcast,\n+                        signal_func signal_f,\n+                        wait_func wait_f) {\n+  /* Wipe. */\n+  memset(wc, 0, sizeof(*wc));\n+\n+  /* Copy vars. */\n+  wc->signal_cond = signal_f;\n+  wc->wait_cond = wait_f;\n+  wc->use_broadcast = use_broadcast;\n+\n+  /* Init. */\n+  ASSERT(0 == uv_sem_init(&wc->sem_waiting, 0));\n+  ASSERT(0 == uv_sem_init(&wc->sem_signaled, 0));\n+  ASSERT(0 == uv_cond_init(&wc->cond));\n+  ASSERT(0 == uv_mutex_init(&wc->mutex));\n+}\n \n+void worker_config_destroy(worker_config* wc) {\n+  uv_mutex_destroy(&wc->mutex);\n+  uv_cond_destroy(&wc->cond);\n+  uv_sem_destroy(&wc->sem_signaled);\n+  uv_sem_destroy(&wc->sem_waiting);\n+}\n+\n+/* arg is a worker_config.\n+ * Call signal_cond then wait_cond.\n+ * Partner should call wait then signal. */\n static void worker(void* arg) {\n   worker_config* c = arg;\n   c->signal_cond(c, &c->posted_1);\n   c->wait_cond(c, &c->posted_2);\n }\n \n-static void noop_worker(void* arg) {\n-  return;\n-}\n-\n-static void condvar_signal(worker_config* c, volatile int* flag) {\n-  if (c->signal_delay)\n-    uv_sleep(c->signal_delay);\n+/* 1. Signal a waiting waiter.\n+ * 2. Tell waiter we finished. */\n+static void condvar_signal(worker_config* c, int* flag) {\n+  /* Wait until waiter holds mutex and is preparing to wait. */\n+  uv_sem_wait(&c->sem_waiting);\n \n+  /* Make sure waiter has begun waiting. */\n   uv_mutex_lock(&c->mutex);\n+\n+  /* Help waiter differentiate between spurious and legitimate wakeup. */\n   ASSERT(*flag == 0);\n   *flag = 1;\n+\n   if (c->use_broadcast)\n     uv_cond_broadcast(&c->cond);\n   else\n     uv_cond_signal(&c->cond);\n+\n   uv_mutex_unlock(&c->mutex);\n-}\n \n+  /* Done signaling. */\n+  uv_sem_post(&c->sem_signaled);\n+}\n \n-static int condvar_wait(worker_config* c, const volatile int* flag) {\n+/* 1. Wait on a signal.\n+ * 2. Ensure that the signaler finished. */\n+static int condvar_wait(worker_config* c, const int* flag) {\n   uv_mutex_lock(&c->mutex);\n-  if (c->wait_delay)\n-    uv_sleep(c->wait_delay);\n-  while (*flag == 0) {\n+\n+  /* Tell signal'er that I am waiting. */\n+  uv_sem_post(&c->sem_waiting);\n+\n+  /* Wait until I get a non-spurious signal. */\n+  do {\n     uv_cond_wait(&c->cond, &c->mutex);\n-  }\n+  } while (*flag == 0);\n   ASSERT(*flag == 1);\n+\n   uv_mutex_unlock(&c->mutex);\n \n+  /* Wait for my signal'er to finish. */\n+  uv_sem_wait(&c->sem_signaled);\n+\n   return 0;\n }\n \n-\n+/* uv_cond_wait: One thread signals, the other waits. */\n TEST_IMPL(condvar_1) {\n-  uv_thread_t thread;\n   worker_config wc;\n+  uv_thread_t thread;\n \n-  memset(&wc, 0, sizeof(wc));\n-  wc.wait_delay = 100;\n-  wc.signal_cond = condvar_signal;\n-  wc.wait_cond = condvar_wait;\n-\n-  ASSERT(0 == uv_cond_init(&wc.cond));\n-  ASSERT(0 == uv_mutex_init(&wc.mutex));\n+  /* Helper signal-then-wait. */\n+  worker_config_init(&wc, 0, condvar_signal, condvar_wait);\n   ASSERT(0 == uv_thread_create(&thread, worker, &wc));\n \n+  /* We wait-then-signal. */\n   ASSERT(0 == wc.wait_cond(&wc, &wc.posted_1));\n   wc.signal_cond(&wc, &wc.posted_2);\n \n   ASSERT(0 == uv_thread_join(&thread));\n-  uv_mutex_destroy(&wc.mutex);\n-  uv_cond_destroy(&wc.cond);\n+  worker_config_destroy(&wc);\n \n   return 0;\n }\n \n-\n+/* uv_cond_wait: One thread broadcasts, the other waits. */\n TEST_IMPL(condvar_2) {\n-  uv_thread_t thread;\n   worker_config wc;\n+  uv_thread_t thread;\n \n-  memset(&wc, 0, sizeof(wc));\n-  wc.signal_delay = 100;\n-  wc.signal_cond = condvar_signal;\n-  wc.wait_cond = condvar_wait;\n-\n-  ASSERT(0 == uv_cond_init(&wc.cond));\n-  ASSERT(0 == uv_mutex_init(&wc.mutex));\n+  /* Helper to signal-then-wait. */\n+  worker_config_init(&wc, 1, condvar_signal, condvar_wait);\n   ASSERT(0 == uv_thread_create(&thread, worker, &wc));\n \n+  /* We wait-then-signal. */\n   ASSERT(0 == wc.wait_cond(&wc, &wc.posted_1));\n   wc.signal_cond(&wc, &wc.posted_2);\n \n   ASSERT(0 == uv_thread_join(&thread));\n-  uv_mutex_destroy(&wc.mutex);\n-  uv_cond_destroy(&wc.cond);\n+  worker_config_destroy(&wc);\n \n   return 0;\n }\n \n-\n-static int condvar_timedwait(worker_config* c, const volatile int* flag) {\n+/* 1. Wait on a signal (hopefully not timeout, else we'll hang).\n+ * 2. Ensure that the signaler finished. */\n+static int condvar_timedwait(worker_config* c, const int* flag) {\n   int r;\n \n   r = 0;\n \n   uv_mutex_lock(&c->mutex);\n-  if (c->wait_delay)\n-    uv_sleep(c->wait_delay);\n-  while (*flag == 0) {\n-    r = uv_cond_timedwait(&c->cond, &c->mutex, (uint64_t)(150 * 1e6));\n-    ASSERT(r == 0 || r == UV_ETIMEDOUT);\n-    if (r == UV_ETIMEDOUT)\n-      break;\n-  }\n+\n+  /* Tell signal'er that I am waiting. */\n+  uv_sem_post(&c->sem_waiting);\n+\n+  /* Wait until I get a non-spurious signal. */\n+  do {\n+    r = uv_cond_timedwait(&c->cond, &c->mutex, (uint64_t)(1 * 1e9)); /* 1 s */\n+    ASSERT(r == 0); /* Should not time out. */\n+  } while (*flag == 0);\n+  ASSERT(*flag == 1);\n+\n   uv_mutex_unlock(&c->mutex);\n \n+  /* Wait for my signal'er to finish. */\n+  uv_sem_wait(&c->sem_signaled);\n   return r;\n }\n \n-/* Test that uv_cond_timedwait will return early when cond is signaled. */\n+/* uv_cond_timedwait: One thread signals, the other timedwaits. */\n TEST_IMPL(condvar_3) {\n-  uv_thread_t thread;\n   worker_config wc;\n+  uv_thread_t thread;\n \n-  memset(&wc, 0, sizeof(wc));\n-  wc.signal_delay = 100;\n-  wc.signal_cond = condvar_signal;\n-  wc.wait_cond = condvar_timedwait;\n-\n-  ASSERT(0 == uv_cond_init(&wc.cond));\n-  ASSERT(0 == uv_mutex_init(&wc.mutex));\n+  /* Helper to signal-then-wait. */\n+  worker_config_init(&wc, 0, condvar_signal, condvar_timedwait);\n   ASSERT(0 == uv_thread_create(&thread, worker, &wc));\n \n-  ASSERT(0 == wc.wait_cond(&wc, &wc.posted_1));\n+  /* We wait-then-signal. */\n+  wc.wait_cond(&wc, &wc.posted_1);\n   wc.signal_cond(&wc, &wc.posted_2);\n \n   ASSERT(0 == uv_thread_join(&thread));\n-  uv_mutex_destroy(&wc.mutex);\n-  uv_cond_destroy(&wc.cond);\n+  worker_config_destroy(&wc);\n \n   return 0;\n }\n \n-\n+/* uv_cond_timedwait: One thread broadcasts, the other waits. */\n TEST_IMPL(condvar_4) {\n-  uv_thread_t thread;\n   worker_config wc;\n+  uv_thread_t thread;\n \n-  memset(&wc, 0, sizeof(wc));\n-  wc.signal_delay = 100;\n-  wc.signal_cond = condvar_signal;\n-  wc.wait_cond = condvar_timedwait;\n-\n-  ASSERT(0 == uv_cond_init(&wc.cond));\n-  ASSERT(0 == uv_mutex_init(&wc.mutex));\n+  /* Helper to signal-then-wait. */\n+  worker_config_init(&wc, 1, condvar_signal, condvar_timedwait);\n   ASSERT(0 == uv_thread_create(&thread, worker, &wc));\n \n+  /* We wait-then-signal. */\n   wc.wait_cond(&wc, &wc.posted_1);\n   wc.signal_cond(&wc, &wc.posted_2);\n \n   ASSERT(0 == uv_thread_join(&thread));\n-  uv_mutex_destroy(&wc.mutex);\n-  uv_cond_destroy(&wc.cond);\n+  worker_config_destroy(&wc);\n \n   return 0;\n }\n \n-\n+/* uv_cond_timedwait: One thread waits, no signal. Timeout should be delivered. */\n TEST_IMPL(condvar_5) {\n-  uv_thread_t thread;\n   worker_config wc;\n+  int r;\n+  /* ns */\n+  uint64_t before;\n+  uint64_t after;\n+  uint64_t elapsed;\n+  uint64_t timeout;\n \n-  memset(&wc, 0, sizeof(wc));\n-  wc.use_broadcast = 1;\n-  wc.signal_delay = 100;\n-  wc.signal_cond = condvar_signal;\n-  wc.wait_cond = condvar_wait;\n-\n-  ASSERT(0 == uv_cond_init(&wc.cond));\n-  ASSERT(0 == uv_mutex_init(&wc.mutex));\n-  ASSERT(0 == uv_thread_create(&thread, worker, &wc));\n-\n-  wc.wait_cond(&wc, &wc.posted_1);\n-  wc.signal_cond(&wc, &wc.posted_2);\n+  timeout = 100 * 1e6; /* 100 ms in ns */\n \n-  ASSERT(0 == uv_thread_join(&thread));\n-  uv_mutex_destroy(&wc.mutex);\n-  uv_cond_destroy(&wc.cond);\n+  /* Mostly irrelevant. We need cond and mutex initialized. */\n+  worker_config_init(&wc, 0, NULL, NULL);\n \n-  return 0;\n-}\n+  uv_mutex_lock(&wc.mutex);\n \n-/* Test that uv_cond_timedwait will time out when cond is not signaled. */\n-TEST_IMPL(condvar_6) {\n-  uv_thread_t thread;\n-  worker_config wc;\n-  int r;\n+  /* We wait.\n+   * No signaler, so this will only return if timeout is delivered. */\n+  before = uv_hrtime();\n+  r = uv_cond_timedwait(&wc.cond, &wc.mutex, timeout);\n+  after = uv_hrtime();\n \n-  memset(&wc, 0, sizeof(wc));\n-  wc.signal_delay = 100;\n-  wc.signal_cond = condvar_signal;\n-  wc.wait_cond = condvar_timedwait;\n+  uv_mutex_unlock(&wc.mutex);\n \n-  ASSERT(0 == uv_cond_init(&wc.cond));\n-  ASSERT(0 == uv_mutex_init(&wc.mutex));\n-  ASSERT(0 == uv_thread_create(&thread, noop_worker, &wc));\n-\n-  /* This can only return having timed out, because otherwise we\n-   * loop forever in condvar_timedwait. */\n-  r = wc.wait_cond(&wc, &wc.posted_1);\n+  /* It timed out. */\n   ASSERT(r == UV_ETIMEDOUT);\n \n-  ASSERT(0 == uv_thread_join(&thread));\n-  uv_mutex_destroy(&wc.mutex);\n-  uv_cond_destroy(&wc.cond);\n+  /* It must have taken at least timeout, modulo system timer ticks.\n+   * But it should not take too much longer.\n+   * cf. MSDN docs:\n+   * https://msdn.microsoft.com/en-us/library/ms687069(VS.85).aspx */\n+  elapsed = after - before;\n+  ASSERT(0.75 * timeout <= elapsed); /* 1.0 too large for Windows. */\n+  ASSERT(elapsed <= 1.5 * timeout); /* 1.1 too small for OSX. */\n+\n+  worker_config_destroy(&wc);\n \n   return 0;\n }"
        },
        {
            "sha": "7f44f4a1bc606dea9b2b7e881585045b621546cb",
            "filename": "deps/uv/test/test-error.c",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Ftest%2Ftest-error.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Ftest%2Ftest-error.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-error.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -37,6 +37,8 @@\n  * See https://github.com/joyent/libuv/issues/210\n  */\n TEST_IMPL(error_message) {\n+  char buf[32];\n+\n   /* Cop out. Can't do proper checks on systems with\n    * i18n-ized error messages...\n    */\n@@ -49,6 +51,10 @@ TEST_IMPL(error_message) {\n   ASSERT(strcmp(uv_strerror(1337), \"Unknown error\") == 0);\n   ASSERT(strcmp(uv_strerror(-1337), \"Unknown error\") == 0);\n \n+  ASSERT(strstr(uv_strerror_r(UV_EINVAL, buf, sizeof(buf)), \"Success\") == NULL);\n+  ASSERT(strstr(uv_strerror_r(1337, buf, sizeof(buf)), \"1337\") != NULL);\n+  ASSERT(strstr(uv_strerror_r(-1337, buf, sizeof(buf)), \"-1337\") != NULL);\n+\n   return 0;\n }\n "
        },
        {
            "sha": "24ba37461eb4de7b7c5f5fdf1dd18cbd339e236b",
            "filename": "deps/uv/test/test-list.h",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Ftest%2Ftest-list.h",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Ftest%2Ftest-list.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-list.h?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -42,7 +42,6 @@ TEST_DECLARE   (condvar_2)\n TEST_DECLARE   (condvar_3)\n TEST_DECLARE   (condvar_4)\n TEST_DECLARE   (condvar_5)\n-TEST_DECLARE   (condvar_6)\n TEST_DECLARE   (semaphore_1)\n TEST_DECLARE   (semaphore_2)\n TEST_DECLARE   (semaphore_3)\n@@ -459,7 +458,6 @@ TASK_LIST_START\n   TEST_ENTRY  (condvar_3)\n   TEST_ENTRY  (condvar_4)\n   TEST_ENTRY  (condvar_5)\n-  TEST_ENTRY  (condvar_6)\n   TEST_ENTRY  (semaphore_1)\n   TEST_ENTRY  (semaphore_2)\n   TEST_ENTRY  (semaphore_3)"
        },
        {
            "sha": "6aaeda8f59619bce85f6df1cc1adfd3248ddfdce",
            "filename": "deps/uv/test/test-tty.c",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Ftest%2Ftest-tty.c",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Ftest%2Ftest-tty.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-tty.c?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -371,12 +371,12 @@ TEST_IMPL(tty_pty) {\n   ASSERT(0 == uv_tty_init(&loop, &slave_tty, slave_fd, 0));\n   ASSERT(0 == uv_tty_init(&loop, &master_tty, master_fd, 0));\n   /* Check if the file descriptor was reopened. If it is,\n-   * UV_STREAM_BLOCKING (value 0x80) isn't set on flags.\n+   * UV_HANDLE_BLOCKING_WRITES (value 0x100000) isn't set on flags.\n    */\n-  ASSERT(0 == (slave_tty.flags & 0x80));\n+  ASSERT(0 == (slave_tty.flags & 0x100000));\n   /* The master_fd of a pty should never be reopened.\n    */\n-  ASSERT(master_tty.flags & 0x80);\n+  ASSERT(master_tty.flags & 0x100000);\n   ASSERT(0 == close(slave_fd));\n   uv_close((uv_handle_t*) &slave_tty, NULL);\n   ASSERT(0 == close(master_fd));"
        },
        {
            "sha": "37dcb3604f4c72ba12e2acd0ace9faba3676526a",
            "filename": "deps/uv/uv.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fuv.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/8174d0c8cae857296c45b2c448348f2c781f6ace/deps%2Fuv%2Fuv.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fuv.gyp?ref=8174d0c8cae857296c45b2c448348f2c781f6ace",
            "patch": "@@ -73,6 +73,7 @@\n         'src/inet.c',\n         'src/queue.h',\n         'src/threadpool.c',\n+        'src/timer.c',\n         'src/uv-data-getter-setters.c',\n         'src/uv-common.c',\n         'src/uv-common.h',\n@@ -123,7 +124,6 @@\n             'src/win/stream-inl.h',\n             'src/win/tcp.c',\n             'src/win/tty.c',\n-            'src/win/timer.c',\n             'src/win/udp.c',\n             'src/win/util.c',\n             'src/win/winapi.c',\n@@ -168,7 +168,6 @@\n             'src/unix/stream.c',\n             'src/unix/tcp.c',\n             'src/unix/thread.c',\n-            'src/unix/timer.c',\n             'src/unix/tty.c',\n             'src/unix/udp.c',\n           ],"
        }
    ],
    "stats": {
        "total": 1417,
        "additions": 527,
        "deletions": 890
    }
}