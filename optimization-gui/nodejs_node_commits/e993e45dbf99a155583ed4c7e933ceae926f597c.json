{
    "author": "MayaLekova",
    "message": "test: add test for async hooks parity for async/await\n\nAdd a basic test ensuring parity between before-after and\ninit-promiseResolve hooks when using async/await.\nAdd ability to initHooks and to checkInvocations utilities to transmit\npromiseResolve hook as well.\n\nSee: https://github.com/nodejs/node/issues/20516\n\nPR-URL: https://github.com/nodejs/node/pull/20626\nRefs: https://github.com/nodejs/node/issues/20516\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Benedikt Meurer <benedikt.meurer@gmail.com>",
    "sha": "e993e45dbf99a155583ed4c7e933ceae926f597c",
    "files": [
        {
            "sha": "44970378131c4a9df0f7f5791cc79bca84138a9a",
            "filename": "test/async-hooks/hook-checks.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/e993e45dbf99a155583ed4c7e933ceae926f597c/test%2Fasync-hooks%2Fhook-checks.js",
            "raw_url": "https://github.com/nodejs/node/raw/e993e45dbf99a155583ed4c7e933ceae926f597c/test%2Fasync-hooks%2Fhook-checks.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fasync-hooks%2Fhook-checks.js?ref=e993e45dbf99a155583ed4c7e933ceae926f597c",
            "patch": "@@ -25,7 +25,7 @@ exports.checkInvocations = function checkInvocations(activity, hooks, stage) {\n   );\n \n   // Check that actual invocations for all hooks match the expected invocations\n-  [ 'init', 'before', 'after', 'destroy' ].forEach(checkHook);\n+  [ 'init', 'before', 'after', 'destroy', 'promiseResolve' ].forEach(checkHook);\n \n   function checkHook(k) {\n     const val = hooks[k];"
        },
        {
            "sha": "509f443b29a67130b917878da98a784dd16d4a25",
            "filename": "test/async-hooks/init-hooks.js",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/e993e45dbf99a155583ed4c7e933ceae926f597c/test%2Fasync-hooks%2Finit-hooks.js",
            "raw_url": "https://github.com/nodejs/node/raw/e993e45dbf99a155583ed4c7e933ceae926f597c/test%2Fasync-hooks%2Finit-hooks.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fasync-hooks%2Finit-hooks.js?ref=e993e45dbf99a155583ed4c7e933ceae926f597c",
            "patch": "@@ -25,6 +25,7 @@ class ActivityCollector {\n     onbefore,\n     onafter,\n     ondestroy,\n+    onpromiseResolve,\n     logid = null,\n     logtype = null\n   } = {}) {\n@@ -39,13 +40,16 @@ class ActivityCollector {\n     this.onbefore = typeof onbefore === 'function' ? onbefore : noop;\n     this.onafter = typeof onafter === 'function' ? onafter : noop;\n     this.ondestroy = typeof ondestroy === 'function' ? ondestroy : noop;\n+    this.onpromiseResolve = typeof onpromiseResolve === 'function' ?\n+      onpromiseResolve : noop;\n \n     // Create the hook with which we'll collect activity data\n     this._asyncHook = async_hooks.createHook({\n       init: this._init.bind(this),\n       before: this._before.bind(this),\n       after: this._after.bind(this),\n-      destroy: this._destroy.bind(this)\n+      destroy: this._destroy.bind(this),\n+      promiseResolve: this._promiseResolve.bind(this)\n     });\n   }\n \n@@ -206,6 +210,13 @@ class ActivityCollector {\n     this.ondestroy(uid);\n   }\n \n+  _promiseResolve(uid) {\n+    const h = this._getActivity(uid, 'promiseResolve');\n+    this._stamp(h, 'promiseResolve');\n+    this._maybeLog(uid, h && h.type, 'promiseResolve');\n+    this.onpromiseResolve(uid);\n+  }\n+\n   _maybeLog(uid, type, name) {\n     if (this._logid &&\n       (type == null || this._logtype == null || this._logtype === type)) {\n@@ -219,6 +230,7 @@ exports = module.exports = function initHooks({\n   onbefore,\n   onafter,\n   ondestroy,\n+  onpromiseResolve,\n   allowNoInit,\n   logid,\n   logtype\n@@ -228,6 +240,7 @@ exports = module.exports = function initHooks({\n     onbefore,\n     onafter,\n     ondestroy,\n+    onpromiseResolve,\n     allowNoInit,\n     logid,\n     logtype"
        },
        {
            "sha": "7f88cd9b18176fa1c19b6d5aad61201738380f22",
            "filename": "test/async-hooks/test-async-await.js",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/nodejs/node/blob/e993e45dbf99a155583ed4c7e933ceae926f597c/test%2Fasync-hooks%2Ftest-async-await.js",
            "raw_url": "https://github.com/nodejs/node/raw/e993e45dbf99a155583ed4c7e933ceae926f597c/test%2Fasync-hooks%2Ftest-async-await.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fasync-hooks%2Ftest-async-await.js?ref=e993e45dbf99a155583ed4c7e933ceae926f597c",
            "patch": "@@ -0,0 +1,91 @@\n+'use strict';\n+const common = require('../common');\n+\n+// This test ensures async hooks are being properly called\n+// when using async-await mechanics. This involves:\n+// 1. Checking that all initialized promises are being resolved\n+// 2. Checking that for each 'before' corresponding hook 'after' hook is called\n+\n+const assert = require('assert');\n+const initHooks = require('./init-hooks');\n+\n+const util = require('util');\n+\n+const sleep = util.promisify(setTimeout);\n+// either 'inited' or 'resolved'\n+const promisesInitState = new Map();\n+// either 'before' or 'after' AND asyncId must be present in the other map\n+const promisesExecutionState = new Map();\n+\n+const hooks = initHooks({\n+  oninit,\n+  onbefore,\n+  onafter,\n+  ondestroy: null,  // Intentionally not tested, since it will be removed soon\n+  onpromiseResolve\n+});\n+hooks.enable();\n+\n+function oninit(asyncId, type, triggerAsyncId, resource) {\n+  if (type === 'PROMISE') {\n+    promisesInitState.set(asyncId, 'inited');\n+  }\n+}\n+\n+function onbefore(asyncId) {\n+  if (!promisesInitState.has(asyncId)) {\n+    return;\n+  }\n+  promisesExecutionState.set(asyncId, 'before');\n+}\n+\n+function onafter(asyncId) {\n+  if (!promisesInitState.has(asyncId)) {\n+    return;\n+  }\n+\n+  assert.strictEqual(promisesExecutionState.get(asyncId), 'before',\n+                     'after hook called for promise without prior call' +\n+                     'to before hook');\n+  assert.strictEqual(promisesInitState.get(asyncId), 'resolved',\n+                     'after hook called for promise without prior call' +\n+                     'to resolve hook');\n+  promisesExecutionState.set(asyncId, 'after');\n+}\n+\n+function onpromiseResolve(asyncId) {\n+  assert(promisesInitState.has(asyncId),\n+         'resolve hook called for promise without prior call to init hook');\n+\n+  promisesInitState.set(asyncId, 'resolved');\n+}\n+\n+const timeout = common.platformTimeout(10);\n+\n+function checkPromisesInitState() {\n+  for (const initState of promisesInitState.values()) {\n+    assert.strictEqual(initState, 'resolved',\n+                       'promise initialized without being resolved');\n+  }\n+}\n+\n+function checkPromisesExecutionState() {\n+  for (const executionState of promisesExecutionState.values()) {\n+    assert.strictEqual(executionState, 'after',\n+                       'mismatch between before and after hook calls');\n+  }\n+}\n+\n+process.on('beforeExit', common.mustCall(() => {\n+  hooks.disable();\n+  hooks.sanityCheck('PROMISE');\n+\n+  checkPromisesInitState();\n+  checkPromisesExecutionState();\n+}));\n+\n+async function asyncFunc() {\n+  await sleep(timeout);\n+}\n+\n+asyncFunc();"
        }
    ],
    "stats": {
        "total": 108,
        "additions": 106,
        "deletions": 2
    }
}