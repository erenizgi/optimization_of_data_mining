{
    "author": "sam-github",
    "message": "tls: in-line comments and other cleanups\n\nPR-URL: https://github.com/nodejs/node/pull/25861\nReviewed-By: Fedor Indutny <fedor.indutny@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "62b4796e369895e614e22bb176702f2499317f4a",
    "files": [
        {
            "sha": "365dbb9491266b020e96cc7ff09a3ca7d7dc7aac",
            "filename": "lib/_tls_wrap.js",
            "status": "modified",
            "additions": 24,
            "deletions": 7,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/62b4796e369895e614e22bb176702f2499317f4a/lib%2F_tls_wrap.js",
            "raw_url": "https://github.com/nodejs/node/raw/62b4796e369895e614e22bb176702f2499317f4a/lib%2F_tls_wrap.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_tls_wrap.js?ref=62b4796e369895e614e22bb176702f2499317f4a",
            "patch": "@@ -62,6 +62,8 @@ const noop = () => {};\n \n let ipServernameWarned = false;\n \n+// Server side times how long a handshake is taking to protect against slow\n+// handshakes being used for DoS.\n function onhandshakestart(now) {\n   debug('onhandshakestart');\n \n@@ -121,13 +123,19 @@ function loadSession(hello) {\n       return owner.destroy(new ERR_SOCKET_CLOSED());\n \n     owner._handle.loadSession(session);\n+    // Session is loaded. End the parser to allow handshaking to continue.\n     owner._handle.endParser();\n   }\n \n   if (hello.sessionId.length <= 0 ||\n       hello.tlsTicket ||\n       owner.server &&\n       !owner.server.emit('resumeSession', hello.sessionId, onSession)) {\n+    // Sessions without identifiers can't be resumed.\n+    // Sessions with tickets can be resumed directly from the ticket, no server\n+    // session storage is necessary.\n+    // Without a call to a resumeSession listener, a session will never be\n+    // loaded, so end the parser to allow handshaking to continue.\n     owner._handle.endParser();\n   }\n }\n@@ -222,13 +230,17 @@ function onnewsessionclient(sessionId, session) {\n }\n \n function onnewsession(sessionId, session) {\n+  debug('onnewsession');\n   const owner = this[owner_symbol];\n \n+  // XXX(sam) no server to emit the event on, but handshake won't continue\n+  // unless newSessionDone() is called, should it be?\n   if (!owner.server)\n     return;\n \n   var once = false;\n   const done = () => {\n+    debug('onnewsession done');\n     if (once)\n       return;\n     once = true;\n@@ -319,8 +331,12 @@ function TLSSocket(socket, opts) {\n \n   var wrap;\n   if ((socket instanceof net.Socket && socket._handle) || !socket) {\n+    // 1. connected socket\n+    // 2. no socket, one will be created with net.Socket().connect\n     wrap = socket;\n   } else {\n+    // 3. socket has no handle so it is js not c++\n+    // 4. unconnected sockets are wrapped\n     // TLS expects to interact from C++ with a net.Socket that has a C++ stream\n     // handle, but a JS stream doesn't have one. Wrap it up to make it look like\n     // a socket.\n@@ -340,7 +356,7 @@ function TLSSocket(socket, opts) {\n   });\n \n   // Proxy for API compatibility\n-  this.ssl = this._handle;\n+  this.ssl = this._handle;  // C++ TLSWrap object\n \n   this.on('error', this._tlsError);\n \n@@ -436,8 +452,8 @@ TLSSocket.prototype._wrapHandle = function(wrap) {\n   const res = tls_wrap.wrap(externalStream,\n                             context.context,\n                             !!options.isServer);\n-  res._parent = handle;\n-  res._parentWrap = wrap;\n+  res._parent = handle;  // C++ \"wrap\" object: TCPWrap, JSStream, ...\n+  res._parentWrap = wrap;  // JS object: net.Socket, JSStreamSocket, ...\n   res._secureContext = context;\n   res.reading = handle.reading;\n   this[kRes] = res;\n@@ -487,8 +503,8 @@ TLSSocket.prototype._init = function(socket, wrap) {\n \n   this.server = options.server;\n \n-  // For clients, we will always have either a given ca list or be using\n-  // default one\n+  // Clients (!isServer) always request a cert, servers request a client cert\n+  // only on explicit configuration.\n   const requestCert = !!options.requestCert || !options.isServer;\n   const rejectUnauthorized = !!options.rejectUnauthorized;\n \n@@ -509,6 +525,7 @@ TLSSocket.prototype._init = function(socket, wrap) {\n     if (this.server) {\n       if (this.server.listenerCount('resumeSession') > 0 ||\n           this.server.listenerCount('newSession') > 0) {\n+        // Also starts the client hello parser as a side effect.\n         ssl.enableSessionCallbacks();\n       }\n       if (this.server.listenerCount('OCSPRequest') > 0)\n@@ -736,7 +753,7 @@ TLSSocket.prototype.getCipher = function(err) {\n // TODO: support anonymous (nocert) and PSK\n \n \n-function onSocketSecure() {\n+function onServerSocketSecure() {\n   if (this._requestCert) {\n     const verifyError = this._handle.verifyError();\n     if (verifyError) {\n@@ -787,7 +804,7 @@ function tlsConnectionListener(rawSocket) {\n     SNICallback: this[kSNICallback] || SNICallback\n   });\n \n-  socket.on('secure', onSocketSecure);\n+  socket.on('secure', onServerSocketSecure);\n \n   socket[kErrorEmitted] = false;\n   socket.on('close', onSocketClose);"
        },
        {
            "sha": "c30212117ef4f49590cd4ff3b4ea0f518ac33c43",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 38,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/62b4796e369895e614e22bb176702f2499317f4a/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/62b4796e369895e614e22bb176702f2499317f4a/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=62b4796e369895e614e22bb176702f2499317f4a",
            "patch": "@@ -2670,47 +2670,19 @@ int SSLWrap<Base>::SetCACerts(SecureContext* sc) {\n }\n \n int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx) {\n-  // Quoting SSL_set_verify(3ssl):\n+  // From https://www.openssl.org/docs/man1.1.1/man3/SSL_verify_cb:\n   //\n-  //   The VerifyCallback function is used to control the behaviour when\n-  //   the SSL_VERIFY_PEER flag is set. It must be supplied by the\n-  //   application and receives two arguments: preverify_ok indicates,\n-  //   whether the verification of the certificate in question was passed\n-  //   (preverify_ok=1) or not (preverify_ok=0). x509_ctx is a pointer to\n-  //   the complete context used for the certificate chain verification.\n-  //\n-  //   The certificate chain is checked starting with the deepest nesting\n-  //   level (the root CA certificate) and worked upward to the peer's\n-  //   certificate.  At each level signatures and issuer attributes are\n-  //   checked.  Whenever a verification error is found, the error number is\n-  //   stored in x509_ctx and VerifyCallback is called with preverify_ok=0.\n-  //   By applying X509_CTX_store_* functions VerifyCallback can locate the\n-  //   certificate in question and perform additional steps (see EXAMPLES).\n-  //   If no error is found for a certificate, VerifyCallback is called\n-  //   with preverify_ok=1 before advancing to the next level.\n-  //\n-  //   The return value of VerifyCallback controls the strategy of the\n-  //   further verification process. If VerifyCallback returns 0, the\n-  //   verification process is immediately stopped with \"verification\n-  //   failed\" state. If SSL_VERIFY_PEER is set, a verification failure\n-  //   alert is sent to the peer and the TLS/SSL handshake is terminated. If\n-  //   VerifyCallback returns 1, the verification process is continued. If\n+  //   If VerifyCallback returns 1, the verification process is continued. If\n   //   VerifyCallback always returns 1, the TLS/SSL handshake will not be\n-  //   terminated with respect to verification failures and the connection\n-  //   will be established. The calling process can however retrieve the\n-  //   error code of the last verification error using\n-  //   SSL_get_verify_result(3) or by maintaining its own error storage\n-  //   managed by VerifyCallback.\n-  //\n-  //   If no VerifyCallback is specified, the default callback will be\n-  //   used.  Its return value is identical to preverify_ok, so that any\n-  //   verification failure will lead to a termination of the TLS/SSL\n-  //   handshake with an alert message, if SSL_VERIFY_PEER is set.\n+  //   terminated with respect to verification failures and the connection will\n+  //   be established. The calling process can however retrieve the error code\n+  //   of the last verification error using SSL_get_verify_result(3) or by\n+  //   maintaining its own error storage managed by VerifyCallback.\n   //\n-  // Since we cannot perform I/O quickly enough in this callback, we ignore\n-  // all preverify_ok errors and let the handshake continue. It is\n-  // imperative that the user use Connection::VerifyError after the\n-  // 'secure' callback has been made.\n+  // Since we cannot perform I/O quickly enough with X509_STORE_CTX_ APIs in\n+  // this callback, we ignore all preverify_ok errors and let the handshake\n+  // continue. It is imperative that the user use Connection::VerifyError after\n+  // the 'secure' callback has been made.\n   return 1;\n }\n "
        },
        {
            "sha": "4871cd405d1ec0edae181c35f3a027cb4eb4d77d",
            "filename": "src/tls_wrap.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/62b4796e369895e614e22bb176702f2499317f4a/src%2Ftls_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/62b4796e369895e614e22bb176702f2499317f4a/src%2Ftls_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.cc?ref=62b4796e369895e614e22bb176702f2499317f4a",
            "patch": "@@ -770,7 +770,7 @@ void TLSWrap::SetVerifyMode(const FunctionCallbackInfo<Value>& args) {\n   if (wrap->is_server()) {\n     bool request_cert = args[0]->IsTrue();\n     if (!request_cert) {\n-      // Note reject_unauthorized ignored.\n+      // If no cert is requested, there will be none to reject as unauthorized.\n       verify_mode = SSL_VERIFY_NONE;\n     } else {\n       bool reject_unauthorized = args[1]->IsTrue();\n@@ -779,7 +779,9 @@ void TLSWrap::SetVerifyMode(const FunctionCallbackInfo<Value>& args) {\n         verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n     }\n   } else {\n-    // Note request_cert and reject_unauthorized are ignored for clients.\n+    // Servers always send a cert if the cipher is not anonymous (anon is\n+    // disabled by default), so use VERIFY_NONE and check the cert after the\n+    // handshake has completed.\n     verify_mode = SSL_VERIFY_NONE;\n   }\n "
        },
        {
            "sha": "d3cbb992bafb299b2f35c02d473ae5b66ab50d99",
            "filename": "src/tls_wrap.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/62b4796e369895e614e22bb176702f2499317f4a/src%2Ftls_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/62b4796e369895e614e22bb176702f2499317f4a/src%2Ftls_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.h?ref=62b4796e369895e614e22bb176702f2499317f4a",
            "patch": "@@ -80,6 +80,8 @@ class TLSWrap : public AsyncWrap,\n   // Reset error_ string to empty. Not related to \"clear text\".\n   void ClearError() override;\n \n+\n+  // Called by the done() callback of the 'newSession' event.\n   void NewSessionDoneCb();\n \n   // Implement MemoryRetainer:\n@@ -88,6 +90,8 @@ class TLSWrap : public AsyncWrap,\n   SET_SELF_SIZE(TLSWrap)\n \n  protected:\n+  // Alternative to StreamListener::stream(), that returns a StreamBase instead\n+  // of a StreamResource.\n   inline StreamBase* underlying_stream() {\n     return static_cast<StreamBase*>(stream_);\n   }"
        }
    ],
    "stats": {
        "total": 89,
        "additions": 42,
        "deletions": 47
    }
}