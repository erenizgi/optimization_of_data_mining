{
    "author": "refack",
    "message": "src: clean clang-tidy errors in node_file.h\n\n* explicitly delete move overloads\n* default initialize all members\n* explicitly discard unused return values\n* const some possibles\n\nPR-URL: https://github.com/nodejs/node/pull/23793\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "205b6672361d8926ba2e1169254838dad3707e5b",
    "files": [
        {
            "sha": "e2f8bdc55e6ad1ce4d0cb45560c496336bba8ded",
            "filename": "src/node_file.h",
            "status": "modified",
            "additions": 29,
            "deletions": 12,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/205b6672361d8926ba2e1169254838dad3707e5b/src%2Fnode_file.h",
            "raw_url": "https://github.com/nodejs/node/raw/205b6672361d8926ba2e1169254838dad3707e5b/src%2Fnode_file.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.h?ref=205b6672361d8926ba2e1169254838dad3707e5b",
            "patch": "@@ -30,7 +30,7 @@ class FSContinuationData : public MemoryRetainer {\n \n   uv_fs_t* req;\n   int mode;\n-  std::vector<std::string> paths;\n+  std::vector<std::string> paths{};\n \n   void PushPath(std::string&& path) {\n     paths.emplace_back(std::move(path));\n@@ -244,9 +244,10 @@ class FSReqPromise : public FSReqBase {\n                   AsyncWrap::PROVIDER_FSREQPROMISE,\n                   use_bigint),\n         stats_field_array_(env->isolate(), kFsStatsFieldsNumber) {\n-    auto resolver = Promise::Resolver::New(env->context()).ToLocalChecked();\n-    object()->Set(env->context(), env->promise_string(),\n-                  resolver).FromJust();\n+    const auto resolver =\n+      Promise::Resolver::New(env->context()).ToLocalChecked();\n+    USE(object()->Set(env->context(), env->promise_string(),\n+                      resolver).FromJust());\n   }\n \n   ~FSReqPromise() override {\n@@ -262,7 +263,7 @@ class FSReqPromise : public FSReqBase {\n         object()->Get(env()->context(),\n                       env()->promise_string()).ToLocalChecked();\n     Local<Promise::Resolver> resolver = value.As<Promise::Resolver>();\n-    resolver->Reject(env()->context(), reject).FromJust();\n+    USE(resolver->Reject(env()->context(), reject).FromJust());\n   }\n \n   void Resolve(Local<Value> value) override {\n@@ -273,7 +274,7 @@ class FSReqPromise : public FSReqBase {\n         object()->Get(env()->context(),\n                       env()->promise_string()).ToLocalChecked();\n     Local<Promise::Resolver> resolver = val.As<Promise::Resolver>();\n-    resolver->Resolve(env()->context(), value).FromJust();\n+    USE(resolver->Resolve(env()->context(), value).FromJust());\n   }\n \n   void ResolveStat(const uv_stat_t* stat) override {\n@@ -297,10 +298,14 @@ class FSReqPromise : public FSReqBase {\n   SET_MEMORY_INFO_NAME(FSReqPromise)\n   SET_SELF_SIZE(FSReqPromise)\n \n+  FSReqPromise(const FSReqPromise&) = delete;\n+  FSReqPromise& operator=(const FSReqPromise&) = delete;\n+  FSReqPromise(const FSReqPromise&&) = delete;\n+  FSReqPromise& operator=(const FSReqPromise&&) = delete;\n+\n  private:\n   bool finished_ = false;\n   AliasedBuffer<NativeT, V8T> stats_field_array_;\n-  DISALLOW_COPY_AND_ASSIGN(FSReqPromise);\n };\n \n class FSReqAfterScope {\n@@ -312,6 +317,11 @@ class FSReqAfterScope {\n \n   void Reject(uv_fs_t* req);\n \n+  FSReqAfterScope(const FSReqAfterScope&) = delete;\n+  FSReqAfterScope& operator=(const FSReqAfterScope&) = delete;\n+  FSReqAfterScope(const FSReqAfterScope&&) = delete;\n+  FSReqAfterScope& operator=(const FSReqAfterScope&&) = delete;\n+\n  private:\n   FSReqBase* wrap_ = nullptr;\n   uv_fs_t* req_ = nullptr;\n@@ -388,6 +398,11 @@ class FileHandle : public AsyncWrap, public StreamBase {\n   SET_MEMORY_INFO_NAME(FileHandle)\n   SET_SELF_SIZE(FileHandle)\n \n+  FileHandle(const FileHandle&) = delete;\n+  FileHandle& operator=(const FileHandle&) = delete;\n+  FileHandle(const FileHandle&&) = delete;\n+  FileHandle& operator=(const FileHandle&&) = delete;\n+\n  private:\n   // Synchronous close that emits a warning\n   void Close();\n@@ -430,9 +445,14 @@ class FileHandle : public AsyncWrap, public StreamBase {\n       return static_cast<CloseReq*>(ReqWrap::from_req(req));\n     }\n \n+    CloseReq(const CloseReq&) = delete;\n+    CloseReq& operator=(const CloseReq&) = delete;\n+    CloseReq(const CloseReq&&) = delete;\n+    CloseReq& operator=(const CloseReq&&) = delete;\n+\n    private:\n-    Persistent<Promise> promise_;\n-    Persistent<Value> ref_;\n+    Persistent<Promise> promise_{};\n+    Persistent<Value> ref_{};\n   };\n \n   // Asynchronous close\n@@ -446,9 +466,6 @@ class FileHandle : public AsyncWrap, public StreamBase {\n \n   bool reading_ = false;\n   std::unique_ptr<FileHandleReadWrap> current_read_ = nullptr;\n-\n-\n-  DISALLOW_COPY_AND_ASSIGN(FileHandle);\n };\n \n }  // namespace fs"
        }
    ],
    "stats": {
        "total": 41,
        "additions": 29,
        "deletions": 12
    }
}