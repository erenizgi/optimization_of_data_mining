{
    "author": "jasnell",
    "message": "http2: don't aggressively inline\n\nMost of the inlines were leftovers from a much older design\niteration and are largely pointless or counter productive.\n\nPR-URL: https://github.com/nodejs/node/pull/19400\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "49799f3163be5dbae6639cd4dc475a46e1da7722",
    "files": [
        {
            "sha": "5f7c42b6902287f77d159ec5212f19bc2428ee60",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 94,
            "deletions": 99,
            "changes": 193,
            "blob_url": "https://github.com/nodejs/node/blob/49799f3163be5dbae6639cd4dc475a46e1da7722/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/49799f3163be5dbae6639cd4dc475a46e1da7722/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=49799f3163be5dbae6639cd4dc475a46e1da7722",
            "patch": "@@ -283,7 +283,7 @@ Http2Session::Http2Settings::~Http2Settings() {\n // Generates a Buffer that contains the serialized payload of a SETTINGS\n // frame. This can be used, for instance, to create the Base64-encoded\n // content of an Http2-Settings header field.\n-inline Local<Value> Http2Session::Http2Settings::Pack() {\n+Local<Value> Http2Session::Http2Settings::Pack() {\n   const size_t len = count_ * 6;\n   Local<Value> buf = Buffer::New(env(), len).ToLocalChecked();\n   ssize_t ret =\n@@ -298,9 +298,9 @@ inline Local<Value> Http2Session::Http2Settings::Pack() {\n \n // Updates the shared TypedArray with the current remote or local settings for\n // the session.\n-inline void Http2Session::Http2Settings::Update(Environment* env,\n-                                                Http2Session* session,\n-                                                get_setting fn) {\n+void Http2Session::Http2Settings::Update(Environment* env,\n+                                         Http2Session* session,\n+                                         get_setting fn) {\n   AliasedBuffer<uint32_t, v8::Uint32Array>& buffer =\n       env->http2_state()->settings_buffer;\n   buffer[IDX_SETTINGS_HEADER_TABLE_SIZE] =\n@@ -318,7 +318,7 @@ inline void Http2Session::Http2Settings::Update(Environment* env,\n }\n \n // Initializes the shared TypedArray with the default settings values.\n-inline void Http2Session::Http2Settings::RefreshDefaults(Environment* env) {\n+void Http2Session::Http2Settings::RefreshDefaults(Environment* env) {\n   AliasedBuffer<uint32_t, v8::Uint32Array>& buffer =\n       env->http2_state()->settings_buffer;\n \n@@ -541,7 +541,7 @@ inline bool HasHttp2Observer(Environment* env) {\n   return observers[performance::NODE_PERFORMANCE_ENTRY_TYPE_HTTP2] != 0;\n }\n \n-inline void Http2Stream::EmitStatistics() {\n+void Http2Stream::EmitStatistics() {\n   if (!HasHttp2Observer(env()))\n     return;\n   Http2StreamPerformanceEntry* entry =\n@@ -579,7 +579,7 @@ inline void Http2Stream::EmitStatistics() {\n   }, static_cast<void*>(entry));\n }\n \n-inline void Http2Session::EmitStatistics() {\n+void Http2Session::EmitStatistics() {\n   if (!HasHttp2Observer(env()))\n     return;\n   Http2SessionPerformanceEntry* entry =\n@@ -684,8 +684,8 @@ inline void Http2Session::RemoveStream(Http2Stream* stream) {\n // that the total frame size, including header bytes, are 8-byte aligned.\n // If maxPayloadLen is smaller than the number of bytes necessary to align,\n // will return maxPayloadLen instead.\n-inline ssize_t Http2Session::OnDWordAlignedPadding(size_t frameLen,\n-                                                   size_t maxPayloadLen) {\n+ssize_t Http2Session::OnDWordAlignedPadding(size_t frameLen,\n+                                            size_t maxPayloadLen) {\n   size_t r = (frameLen + 9) % 8;\n   if (r == 0) return frameLen;  // If already a multiple of 8, return.\n \n@@ -701,8 +701,8 @@ inline ssize_t Http2Session::OnDWordAlignedPadding(size_t frameLen,\n \n // Used as one of the Padding Strategy functions. Uses the maximum amount\n // of padding allowed for the current frame.\n-inline ssize_t Http2Session::OnMaxFrameSizePadding(size_t frameLen,\n-                                                   size_t maxPayloadLen) {\n+ssize_t Http2Session::OnMaxFrameSizePadding(size_t frameLen,\n+                                            size_t maxPayloadLen) {\n   DEBUG_HTTP2SESSION2(this, \"using max frame size padding: %d\", maxPayloadLen);\n   return maxPayloadLen;\n }\n@@ -711,8 +711,8 @@ inline ssize_t Http2Session::OnMaxFrameSizePadding(size_t frameLen,\n // to determine the amount of padding for the current frame. This option is\n // rather more expensive because of the JS boundary cross. It generally should\n // not be the preferred option.\n-inline ssize_t Http2Session::OnCallbackPadding(size_t frameLen,\n-                                               size_t maxPayloadLen) {\n+ssize_t Http2Session::OnCallbackPadding(size_t frameLen,\n+                                        size_t maxPayloadLen) {\n   if (frameLen == 0) return 0;\n   DEBUG_HTTP2SESSION(this, \"using callback to determine padding\");\n   Isolate* isolate = env()->isolate();\n@@ -743,7 +743,7 @@ inline ssize_t Http2Session::OnCallbackPadding(size_t frameLen,\n // various callback functions. Each of these will typically result in a call\n // out to JavaScript so this particular function is rather hot and can be\n // quite expensive. This is a potential performance optimization target later.\n-inline ssize_t Http2Session::Write(const uv_buf_t* bufs, size_t nbufs) {\n+ssize_t Http2Session::Write(const uv_buf_t* bufs, size_t nbufs) {\n   size_t total = 0;\n   // Note that nghttp2_session_mem_recv is a synchronous operation that\n   // will trigger a number of other callbacks. Those will, in turn have\n@@ -783,9 +783,9 @@ inline int32_t GetFrameID(const nghttp2_frame* frame) {\n // callback to determine if a new stream is being created or if we are simply\n // adding a new block of headers to an existing stream. The header pairs\n // themselves are set in the OnHeaderCallback\n-inline int Http2Session::OnBeginHeadersCallback(nghttp2_session* handle,\n-                                                const nghttp2_frame* frame,\n-                                                void* user_data) {\n+int Http2Session::OnBeginHeadersCallback(nghttp2_session* handle,\n+                                         const nghttp2_frame* frame,\n+                                         void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   int32_t id = GetFrameID(frame);\n   DEBUG_HTTP2SESSION2(session, \"beginning headers for stream %d\", id);\n@@ -812,12 +812,12 @@ inline int Http2Session::OnBeginHeadersCallback(nghttp2_session* handle,\n // Called by nghttp2 for each header name/value pair in a HEADERS block.\n // This had to have been preceded by a call to OnBeginHeadersCallback so\n // the Http2Stream is guaranteed to already exist.\n-inline int Http2Session::OnHeaderCallback(nghttp2_session* handle,\n-                                          const nghttp2_frame* frame,\n-                                          nghttp2_rcbuf* name,\n-                                          nghttp2_rcbuf* value,\n-                                          uint8_t flags,\n-                                          void* user_data) {\n+int Http2Session::OnHeaderCallback(nghttp2_session* handle,\n+                                   const nghttp2_frame* frame,\n+                                   nghttp2_rcbuf* name,\n+                                   nghttp2_rcbuf* value,\n+                                   uint8_t flags,\n+                                   void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   int32_t id = GetFrameID(frame);\n   Http2Stream* stream = session->FindStream(id);\n@@ -837,9 +837,9 @@ inline int Http2Session::OnHeaderCallback(nghttp2_session* handle,\n \n // Called by nghttp2 when a complete HTTP2 frame has been received. There are\n // only a handful of frame types tha we care about handling here.\n-inline int Http2Session::OnFrameReceive(nghttp2_session* handle,\n-                                        const nghttp2_frame* frame,\n-                                        void* user_data) {\n+int Http2Session::OnFrameReceive(nghttp2_session* handle,\n+                                 const nghttp2_frame* frame,\n+                                 void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   session->statistics_.frame_count++;\n   DEBUG_HTTP2SESSION2(session, \"complete frame received: type: %d\",\n@@ -874,10 +874,10 @@ inline int Http2Session::OnFrameReceive(nghttp2_session* handle,\n   return 0;\n }\n \n-inline int Http2Session::OnInvalidFrame(nghttp2_session* handle,\n-                                        const nghttp2_frame *frame,\n-                                        int lib_error_code,\n-                                        void* user_data) {\n+int Http2Session::OnInvalidFrame(nghttp2_session* handle,\n+                                 const nghttp2_frame *frame,\n+                                 int lib_error_code,\n+                                 void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n \n   DEBUG_HTTP2SESSION2(session, \"invalid frame received, code: %d\",\n@@ -906,10 +906,10 @@ inline int Http2Session::OnInvalidFrame(nghttp2_session* handle,\n // really care about those and there's nothing we can reasonably do about it\n // anyway. Other types of failures are reported up to JavaScript. This should\n // be exceedingly rare.\n-inline int Http2Session::OnFrameNotSent(nghttp2_session* handle,\n-                                        const nghttp2_frame* frame,\n-                                        int error_code,\n-                                        void* user_data) {\n+int Http2Session::OnFrameNotSent(nghttp2_session* handle,\n+                                 const nghttp2_frame* frame,\n+                                 int error_code,\n+                                 void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   Environment* env = session->env();\n   DEBUG_HTTP2SESSION2(session, \"frame type %d was not sent, code: %d\",\n@@ -933,19 +933,19 @@ inline int Http2Session::OnFrameNotSent(nghttp2_session* handle,\n   return 0;\n }\n \n-inline int Http2Session::OnFrameSent(nghttp2_session* handle,\n-                                     const nghttp2_frame* frame,\n-                                     void* user_data) {\n+int Http2Session::OnFrameSent(nghttp2_session* handle,\n+                              const nghttp2_frame* frame,\n+                              void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   session->statistics_.frame_sent += 1;\n   return 0;\n }\n \n // Called by nghttp2 when a stream closes.\n-inline int Http2Session::OnStreamClose(nghttp2_session* handle,\n-                                       int32_t id,\n-                                       uint32_t code,\n-                                       void* user_data) {\n+int Http2Session::OnStreamClose(nghttp2_session* handle,\n+                                int32_t id,\n+                                uint32_t code,\n+                                void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   Environment* env = session->env();\n   Isolate* isolate = env->isolate();\n@@ -982,12 +982,12 @@ inline int Http2Session::OnStreamClose(nghttp2_session* handle,\n // ignore these. If this callback was not provided, nghttp2 would handle\n // invalid headers strictly and would shut down the stream. We are intentionally\n // being more lenient here although we may want to revisit this choice later.\n-inline int Http2Session::OnInvalidHeader(nghttp2_session* session,\n-                                         const nghttp2_frame* frame,\n-                                         nghttp2_rcbuf* name,\n-                                         nghttp2_rcbuf* value,\n-                                         uint8_t flags,\n-                                         void* user_data) {\n+int Http2Session::OnInvalidHeader(nghttp2_session* session,\n+                                  const nghttp2_frame* frame,\n+                                  nghttp2_rcbuf* name,\n+                                  nghttp2_rcbuf* value,\n+                                  uint8_t flags,\n+                                  void* user_data) {\n   // Ignore invalid header fields by default.\n   return 0;\n }\n@@ -996,12 +996,12 @@ inline int Http2Session::OnInvalidHeader(nghttp2_session* session,\n // us in discrete chunks. We push these into a linked list stored in the\n // Http2Sttream which is flushed out to JavaScript as quickly as possible.\n // This can be a particularly hot path.\n-inline int Http2Session::OnDataChunkReceived(nghttp2_session* handle,\n-                                             uint8_t flags,\n-                                             int32_t id,\n-                                             const uint8_t* data,\n-                                             size_t len,\n-                                             void* user_data) {\n+int Http2Session::OnDataChunkReceived(nghttp2_session* handle,\n+                                      uint8_t flags,\n+                                      int32_t id,\n+                                      const uint8_t* data,\n+                                      size_t len,\n+                                      void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   DEBUG_HTTP2SESSION2(session, \"buffering data chunk for stream %d, size: \"\n               \"%d, flags: %d\", id, len, flags);\n@@ -1059,10 +1059,10 @@ inline int Http2Session::OnDataChunkReceived(nghttp2_session* handle,\n \n // Called by nghttp2 when it needs to determine how much padding to use in\n // a DATA or HEADERS frame.\n-inline ssize_t Http2Session::OnSelectPadding(nghttp2_session* handle,\n-                                             const nghttp2_frame* frame,\n-                                             size_t maxPayloadLen,\n-                                             void* user_data) {\n+ssize_t Http2Session::OnSelectPadding(nghttp2_session* handle,\n+                                      const nghttp2_frame* frame,\n+                                      size_t maxPayloadLen,\n+                                      void* user_data) {\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n   ssize_t padding = frame->hd.length;\n \n@@ -1089,10 +1089,10 @@ inline ssize_t Http2Session::OnSelectPadding(nghttp2_session* handle,\n \n // We use this currently to determine when an attempt is made to use the http2\n // protocol with a non-http2 peer.\n-inline int Http2Session::OnNghttpError(nghttp2_session* handle,\n-                                       const char* message,\n-                                       size_t len,\n-                                       void* user_data) {\n+int Http2Session::OnNghttpError(nghttp2_session* handle,\n+                                const char* message,\n+                                size_t len,\n+                                void* user_data) {\n   // Unfortunately, this is currently the only way for us to know if\n   // the session errored because the peer is not an http2 peer.\n   Http2Session* session = static_cast<Http2Session*>(user_data);\n@@ -1115,7 +1115,7 @@ inline int Http2Session::OnNghttpError(nghttp2_session* handle,\n // Once all of the DATA frames for a Stream have been sent, the GetTrailers\n // method calls out to JavaScript to fetch the trailing headers that need\n // to be sent.\n-inline void Http2Session::GetTrailers(Http2Stream* stream, uint32_t* flags) {\n+void Http2Session::GetTrailers(Http2Stream* stream, uint32_t* flags) {\n   if (!stream->IsDestroyed() && stream->HasTrailers()) {\n     Http2Stream::SubmitTrailers submit_trailers{this, stream, flags};\n     stream->OnTrailers(submit_trailers);\n@@ -1164,8 +1164,8 @@ Http2Stream::SubmitTrailers::SubmitTrailers(\n   : session_(session), stream_(stream), flags_(flags) { }\n \n \n-inline void Http2Stream::SubmitTrailers::Submit(nghttp2_nv* trailers,\n-                                                size_t length) const {\n+void Http2Stream::SubmitTrailers::Submit(nghttp2_nv* trailers,\n+                                         size_t length) const {\n   Http2Scope h2scope(session_);\n   if (length == 0)\n     return;\n@@ -1180,7 +1180,7 @@ inline void Http2Stream::SubmitTrailers::Submit(nghttp2_nv* trailers,\n // Called by OnFrameReceived to notify JavaScript land that a complete\n // HEADERS frame has been received and processed. This method converts the\n // received headers into a JavaScript array and pushes those out to JS.\n-inline void Http2Session::HandleHeadersFrame(const nghttp2_frame* frame) {\n+void Http2Session::HandleHeadersFrame(const nghttp2_frame* frame) {\n   Isolate* isolate = env()->isolate();\n   HandleScope scope(isolate);\n   Local<Context> context = env()->context();\n@@ -1249,7 +1249,7 @@ inline void Http2Session::HandleHeadersFrame(const nghttp2_frame* frame) {\n // received. Notifies JS land about the priority change. Note that priorities\n // are considered advisory only, so this has no real effect other than to\n // simply let user code know that the priority has changed.\n-inline void Http2Session::HandlePriorityFrame(const nghttp2_frame* frame) {\n+void Http2Session::HandlePriorityFrame(const nghttp2_frame* frame) {\n   Isolate* isolate = env()->isolate();\n   HandleScope scope(isolate);\n   Local<Context> context = env()->context();\n@@ -1274,7 +1274,7 @@ inline void Http2Session::HandlePriorityFrame(const nghttp2_frame* frame) {\n // Called by OnFrameReceived when a complete DATA frame has been received.\n // If we know that this was the last DATA frame (because the END_STREAM flag\n // is set), then we'll terminate the readable side of the StreamBase.\n-inline void Http2Session::HandleDataFrame(const nghttp2_frame* frame) {\n+void Http2Session::HandleDataFrame(const nghttp2_frame* frame) {\n   int32_t id = GetFrameID(frame);\n   DEBUG_HTTP2SESSION2(this, \"handling data frame for stream %d\", id);\n   Http2Stream* stream = FindStream(id);\n@@ -1290,7 +1290,7 @@ inline void Http2Session::HandleDataFrame(const nghttp2_frame* frame) {\n \n \n // Called by OnFrameReceived when a complete GOAWAY frame has been received.\n-inline void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {\n+void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {\n   Isolate* isolate = env()->isolate();\n   HandleScope scope(isolate);\n   Local<Context> context = env()->context();\n@@ -1316,7 +1316,7 @@ inline void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {\n }\n \n // Called by OnFrameReceived when a complete ALTSVC frame has been received.\n-inline void Http2Session::HandleAltSvcFrame(const nghttp2_frame* frame) {\n+void Http2Session::HandleAltSvcFrame(const nghttp2_frame* frame) {\n   Isolate* isolate = env()->isolate();\n   HandleScope scope(isolate);\n   Local<Context> context = env()->context();\n@@ -1344,7 +1344,7 @@ inline void Http2Session::HandleAltSvcFrame(const nghttp2_frame* frame) {\n }\n \n // Called by OnFrameReceived when a complete PING frame has been received.\n-inline void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {\n+void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {\n   bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;\n   if (ack) {\n     Http2Ping* ping = PopPing();\n@@ -1370,7 +1370,7 @@ inline void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {\n }\n \n // Called by OnFrameReceived when a complete SETTINGS frame has been received.\n-inline void Http2Session::HandleSettingsFrame(const nghttp2_frame* frame) {\n+void Http2Session::HandleSettingsFrame(const nghttp2_frame* frame) {\n   bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;\n   if (ack) {\n     // If this is an acknowledgement, we should have an Http2Settings\n@@ -1616,7 +1616,7 @@ int Http2Session::OnSendData(\n }\n \n // Creates a new Http2Stream and submits a new http2 request.\n-inline Http2Stream* Http2Session::SubmitRequest(\n+Http2Stream* Http2Session::SubmitRequest(\n     nghttp2_priority_spec* prispec,\n     nghttp2_nv* nva,\n     size_t len,\n@@ -1805,7 +1805,7 @@ void Http2Stream::OnTrailers(const SubmitTrailers& submit_trailers) {\n   }\n }\n \n-inline void Http2Stream::Close(int32_t code) {\n+void Http2Stream::Close(int32_t code) {\n   CHECK(!this->IsDestroyed());\n   flags_ |= NGHTTP2_STREAM_FLAG_CLOSED;\n   code_ = code;\n@@ -1830,7 +1830,7 @@ int Http2Stream::DoShutdown(ShutdownWrap* req_wrap) {\n // Destroy the Http2Stream and render it unusable. Actual resources for the\n // Stream will not be freed until the next tick of the Node.js event loop\n // using the SetImmediate queue.\n-inline void Http2Stream::Destroy() {\n+void Http2Stream::Destroy() {\n   // Do nothing if this stream instance is already destroyed\n   if (IsDestroyed())\n     return;\n@@ -1869,9 +1869,7 @@ inline void Http2Stream::Destroy() {\n \n // Initiates a response on the Http2Stream using data provided via the\n // StreamBase Streams API.\n-inline int Http2Stream::SubmitResponse(nghttp2_nv* nva,\n-                                       size_t len,\n-                                       int options) {\n+int Http2Stream::SubmitResponse(nghttp2_nv* nva, size_t len, int options) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n   DEBUG_HTTP2STREAM(this, \"submitting response\");\n@@ -1889,7 +1887,7 @@ inline int Http2Stream::SubmitResponse(nghttp2_nv* nva,\n \n \n // Submit informational headers for a stream.\n-inline int Http2Stream::SubmitInfo(nghttp2_nv* nva, size_t len) {\n+int Http2Stream::SubmitInfo(nghttp2_nv* nva, size_t len) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n   DEBUG_HTTP2STREAM2(this, \"sending %d informational headers\", len);\n@@ -1902,8 +1900,8 @@ inline int Http2Stream::SubmitInfo(nghttp2_nv* nva, size_t len) {\n }\n \n // Submit a PRIORITY frame to the connected peer.\n-inline int Http2Stream::SubmitPriority(nghttp2_priority_spec* prispec,\n-                                       bool silent) {\n+int Http2Stream::SubmitPriority(nghttp2_priority_spec* prispec,\n+                                bool silent) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n   DEBUG_HTTP2STREAM(this, \"sending priority spec\");\n@@ -1919,7 +1917,7 @@ inline int Http2Stream::SubmitPriority(nghttp2_priority_spec* prispec,\n \n // Closes the Http2Stream by submitting an RST_STREAM frame to the connected\n // peer.\n-inline void Http2Stream::SubmitRstStream(const uint32_t code) {\n+void Http2Stream::SubmitRstStream(const uint32_t code) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n   // Force a purge of any currently pending data here to make sure\n@@ -1931,10 +1929,10 @@ inline void Http2Stream::SubmitRstStream(const uint32_t code) {\n \n \n // Submit a push promise and create the associated Http2Stream if successful.\n-inline Http2Stream* Http2Stream::SubmitPushPromise(nghttp2_nv* nva,\n-                                                   size_t len,\n-                                                   int32_t* ret,\n-                                                   int options) {\n+Http2Stream* Http2Stream::SubmitPushPromise(nghttp2_nv* nva,\n+                                            size_t len,\n+                                            int32_t* ret,\n+                                            int options) {\n   CHECK(!this->IsDestroyed());\n   Http2Scope h2scope(this);\n   DEBUG_HTTP2STREAM(this, \"sending push promise\");\n@@ -1950,7 +1948,7 @@ inline Http2Stream* Http2Stream::SubmitPushPromise(nghttp2_nv* nva,\n \n // Switch the StreamBase into flowing mode to begin pushing chunks of data\n // out to JS land.\n-inline int Http2Stream::ReadStart() {\n+int Http2Stream::ReadStart() {\n   Http2Scope h2scope(this);\n   CHECK(!this->IsDestroyed());\n   flags_ |= NGHTTP2_STREAM_FLAG_READ_START;\n@@ -1969,7 +1967,7 @@ inline int Http2Stream::ReadStart() {\n }\n \n // Switch the StreamBase into paused mode.\n-inline int Http2Stream::ReadStop() {\n+int Http2Stream::ReadStop() {\n   CHECK(!this->IsDestroyed());\n   if (!IsReading())\n     return 0;\n@@ -1988,10 +1986,10 @@ inline int Http2Stream::ReadStop() {\n // chunks of data have been flushed to the underlying nghttp2_session.\n // Note that this does *not* mean that the data has been flushed\n // to the socket yet.\n-inline int Http2Stream::DoWrite(WriteWrap* req_wrap,\n-                                uv_buf_t* bufs,\n-                                size_t nbufs,\n-                                uv_stream_t* send_handle) {\n+int Http2Stream::DoWrite(WriteWrap* req_wrap,\n+                         uv_buf_t* bufs,\n+                         size_t nbufs,\n+                         uv_stream_t* send_handle) {\n   CHECK(!this->IsDestroyed());\n   CHECK_EQ(send_handle, nullptr);\n   Http2Scope h2scope(this);\n@@ -2013,22 +2011,19 @@ inline int Http2Stream::DoWrite(WriteWrap* req_wrap,\n   return 0;\n }\n \n-inline size_t GetBufferLength(nghttp2_rcbuf* buf) {\n-  return nghttp2_rcbuf_get_buf(buf).len;\n-}\n-\n // Ads a header to the Http2Stream. Note that the header name and value are\n // provided using a buffer structure provided by nghttp2 that allows us to\n // avoid unnecessary memcpy's. Those buffers are ref counted. The ref count\n // is incremented here and are decremented when the header name and values\n // are garbage collected later.\n-inline bool Http2Stream::AddHeader(nghttp2_rcbuf* name,\n-                                   nghttp2_rcbuf* value,\n-                                   uint8_t flags) {\n+bool Http2Stream::AddHeader(nghttp2_rcbuf* name,\n+                            nghttp2_rcbuf* value,\n+                            uint8_t flags) {\n   CHECK(!this->IsDestroyed());\n   if (this->statistics_.first_header == 0)\n     this->statistics_.first_header = uv_hrtime();\n-  size_t length = GetBufferLength(name) + GetBufferLength(value) + 32;\n+  size_t length = nghttp2_rcbuf_get_buf(name).len +\n+                  nghttp2_rcbuf_get_buf(value).len + 32;\n   // A header can only be added if we have not exceeded the maximum number\n   // of headers and the session has memory available for it.\n   if (!session_->IsAvailableSessionMemory(length) ||"
        },
        {
            "sha": "d09dcc22dd6978712c40892f26213ef3754701ad",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 51,
            "deletions": 56,
            "changes": 107,
            "blob_url": "https://github.com/nodejs/node/blob/49799f3163be5dbae6639cd4dc475a46e1da7722/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/49799f3163be5dbae6639cd4dc475a46e1da7722/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=49799f3163be5dbae6639cd4dc475a46e1da7722",
            "patch": "@@ -558,7 +558,7 @@ class Http2Stream : public AsyncWrap,\n \n   Http2Session* session() { return session_; }\n \n-  inline void EmitStatistics();\n+  void EmitStatistics();\n \n   // Process a Data Chunk\n   void OnDataChunk(uv_buf_t* chunk);\n@@ -576,32 +576,29 @@ class Http2Stream : public AsyncWrap,\n   bool HasWantsWrite() const override { return true; }\n \n   // Initiate a response on this stream.\n-  inline int SubmitResponse(nghttp2_nv* nva,\n-                            size_t len,\n-                            int options);\n+  int SubmitResponse(nghttp2_nv* nva, size_t len, int options);\n \n   // Submit informational headers for this stream\n-  inline int SubmitInfo(nghttp2_nv* nva, size_t len);\n+  int SubmitInfo(nghttp2_nv* nva, size_t len);\n \n   // Submit a PRIORITY frame for this stream\n-  inline int SubmitPriority(nghttp2_priority_spec* prispec,\n-                            bool silent = false);\n+  int SubmitPriority(nghttp2_priority_spec* prispec, bool silent = false);\n \n   // Submits an RST_STREAM frame using the given code\n-  inline void SubmitRstStream(const uint32_t code);\n+  void SubmitRstStream(const uint32_t code);\n \n   // Submits a PUSH_PROMISE frame with this stream as the parent.\n-  inline Http2Stream* SubmitPushPromise(\n+  Http2Stream* SubmitPushPromise(\n       nghttp2_nv* nva,\n       size_t len,\n       int32_t* ret,\n       int options = 0);\n \n \n-  inline void Close(int32_t code);\n+  void Close(int32_t code);\n \n   // Destroy this stream instance and free all held memory.\n-  inline void Destroy();\n+  void Destroy();\n \n   inline bool IsDestroyed() const {\n     return flags_ & NGHTTP2_STREAM_FLAG_DESTROYED;\n@@ -640,9 +637,7 @@ class Http2Stream : public AsyncWrap,\n   inline void IncrementAvailableOutboundLength(size_t amount);\n   inline void DecrementAvailableOutboundLength(size_t amount);\n \n-  inline bool AddHeader(nghttp2_rcbuf* name,\n-                        nghttp2_rcbuf* value,\n-                        uint8_t flags);\n+  bool AddHeader(nghttp2_rcbuf* name, nghttp2_rcbuf* value, uint8_t flags);\n \n   inline nghttp2_header* headers() {\n     return current_headers_.data();\n@@ -678,11 +673,11 @@ class Http2Stream : public AsyncWrap,\n   // Handling Trailer Headers\n   class SubmitTrailers {\n    public:\n-    inline void Submit(nghttp2_nv* trailers, size_t length) const;\n+    void Submit(nghttp2_nv* trailers, size_t length) const;\n \n-    inline SubmitTrailers(Http2Session* sesion,\n-                          Http2Stream* stream,\n-                          uint32_t* flags);\n+    SubmitTrailers(Http2Session* sesion,\n+                   Http2Stream* stream,\n+                   uint32_t* flags);\n \n    private:\n     Http2Session* const session_;\n@@ -795,7 +790,7 @@ class Http2Session : public AsyncWrap, public StreamListener {\n   class Http2Ping;\n   class Http2Settings;\n \n-  inline void EmitStatistics();\n+  void EmitStatistics();\n \n   inline StreamBase* underlying_stream() {\n     return static_cast<StreamBase*>(stream_);\n@@ -816,25 +811,25 @@ class Http2Session : public AsyncWrap, public StreamListener {\n \n   bool Ping(v8::Local<v8::Function> function);\n \n-  inline void SendPendingData();\n+  void SendPendingData();\n \n   // Submits a new request. If the request is a success, assigned\n   // will be a pointer to the Http2Stream instance assigned.\n   // This only works if the session is a client session.\n-  inline Http2Stream* SubmitRequest(\n+  Http2Stream* SubmitRequest(\n       nghttp2_priority_spec* prispec,\n       nghttp2_nv* nva,\n       size_t len,\n       int32_t* ret,\n       int options = 0);\n \n-  nghttp2_session_type type() const { return session_type_; }\n+  inline nghttp2_session_type type() const { return session_type_; }\n \n   inline nghttp2_session* session() const { return session_; }\n \n-  nghttp2_session* operator*() { return session_; }\n+  inline nghttp2_session* operator*() { return session_; }\n \n-  uint32_t GetMaxHeaderPairs() const { return max_header_pairs_; }\n+  inline uint32_t GetMaxHeaderPairs() const { return max_header_pairs_; }\n \n   inline const char* TypeName();\n \n@@ -860,11 +855,11 @@ class Http2Session : public AsyncWrap, public StreamListener {\n   bool HasWritesOnSocketForStream(Http2Stream* stream);\n \n   // Write data to the session\n-  inline ssize_t Write(const uv_buf_t* bufs, size_t nbufs);\n+  ssize_t Write(const uv_buf_t* bufs, size_t nbufs);\n \n   size_t self_size() const override { return sizeof(*this); }\n \n-  inline void GetTrailers(Http2Stream* stream, uint32_t* flags);\n+  void GetTrailers(Http2Stream* stream, uint32_t* flags);\n \n   // Handle reads/writes from the underlying network transport.\n   void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n@@ -942,84 +937,84 @@ class Http2Session : public AsyncWrap, public StreamListener {\n \n  private:\n   // Frame Padding Strategies\n-  inline ssize_t OnDWordAlignedPadding(size_t frameLength,\n-                                       size_t maxPayloadLen);\n-  inline ssize_t OnMaxFrameSizePadding(size_t frameLength,\n-                                       size_t maxPayloadLen);\n-  inline ssize_t OnCallbackPadding(size_t frame,\n-                                   size_t maxPayloadLen);\n+  ssize_t OnDWordAlignedPadding(size_t frameLength,\n+                                size_t maxPayloadLen);\n+  ssize_t OnMaxFrameSizePadding(size_t frameLength,\n+                                size_t maxPayloadLen);\n+  ssize_t OnCallbackPadding(size_t frameLength,\n+                            size_t maxPayloadLen);\n \n   // Frame Handler\n-  inline void HandleDataFrame(const nghttp2_frame* frame);\n-  inline void HandleGoawayFrame(const nghttp2_frame* frame);\n-  inline void HandleHeadersFrame(const nghttp2_frame* frame);\n-  inline void HandlePriorityFrame(const nghttp2_frame* frame);\n-  inline void HandleSettingsFrame(const nghttp2_frame* frame);\n-  inline void HandlePingFrame(const nghttp2_frame* frame);\n-  inline void HandleAltSvcFrame(const nghttp2_frame* frame);\n+  void HandleDataFrame(const nghttp2_frame* frame);\n+  void HandleGoawayFrame(const nghttp2_frame* frame);\n+  void HandleHeadersFrame(const nghttp2_frame* frame);\n+  void HandlePriorityFrame(const nghttp2_frame* frame);\n+  void HandleSettingsFrame(const nghttp2_frame* frame);\n+  void HandlePingFrame(const nghttp2_frame* frame);\n+  void HandleAltSvcFrame(const nghttp2_frame* frame);\n \n   // nghttp2 callbacks\n-  static inline int OnBeginHeadersCallback(\n+  static int OnBeginHeadersCallback(\n       nghttp2_session* session,\n       const nghttp2_frame* frame,\n       void* user_data);\n-  static inline int OnHeaderCallback(\n+  static int OnHeaderCallback(\n       nghttp2_session* session,\n       const nghttp2_frame* frame,\n       nghttp2_rcbuf* name,\n       nghttp2_rcbuf* value,\n       uint8_t flags,\n       void* user_data);\n-  static inline int OnFrameReceive(\n+  static int OnFrameReceive(\n       nghttp2_session* session,\n       const nghttp2_frame* frame,\n       void* user_data);\n-  static inline int OnFrameNotSent(\n+  static int OnFrameNotSent(\n       nghttp2_session* session,\n       const nghttp2_frame* frame,\n       int error_code,\n       void* user_data);\n-  static inline int OnFrameSent(\n+  static int OnFrameSent(\n       nghttp2_session* session,\n       const nghttp2_frame* frame,\n       void* user_data);\n-  static inline int OnStreamClose(\n+  static int OnStreamClose(\n       nghttp2_session* session,\n       int32_t id,\n       uint32_t code,\n       void* user_data);\n-  static inline int OnInvalidHeader(\n+  static int OnInvalidHeader(\n       nghttp2_session* session,\n       const nghttp2_frame* frame,\n       nghttp2_rcbuf* name,\n       nghttp2_rcbuf* value,\n       uint8_t flags,\n       void* user_data);\n-  static inline int OnDataChunkReceived(\n+  static int OnDataChunkReceived(\n       nghttp2_session* session,\n       uint8_t flags,\n       int32_t id,\n       const uint8_t* data,\n       size_t len,\n       void* user_data);\n-  static inline ssize_t OnSelectPadding(\n+  static ssize_t OnSelectPadding(\n       nghttp2_session* session,\n       const nghttp2_frame* frame,\n       size_t maxPayloadLen,\n       void* user_data);\n-  static inline int OnNghttpError(\n+  static int OnNghttpError(\n       nghttp2_session* session,\n       const char* message,\n       size_t len,\n       void* user_data);\n-  static inline int OnSendData(\n+  static int OnSendData(\n       nghttp2_session* session,\n       nghttp2_frame* frame,\n       const uint8_t* framehd,\n       size_t length,\n       nghttp2_data_source* source,\n       void* user_data);\n-  static inline int OnInvalidFrame(\n+  static int OnInvalidFrame(\n       nghttp2_session* session,\n       const nghttp2_frame *frame,\n       int lib_error_code,\n@@ -1197,15 +1192,15 @@ class Http2Session::Http2Settings : public AsyncWrap {\n   }\n \n   // Returns a Buffer instance with the serialized SETTINGS payload\n-  inline Local<Value> Pack();\n+  Local<Value> Pack();\n \n   // Resets the default values in the settings buffer\n-  static inline void RefreshDefaults(Environment* env);\n+  static void RefreshDefaults(Environment* env);\n \n   // Update the local or remote settings for the given session\n-  static inline void Update(Environment* env,\n-                            Http2Session* session,\n-                            get_setting fn);\n+  static void Update(Environment* env,\n+                     Http2Session* session,\n+                     get_setting fn);\n \n  private:\n   void Init();"
        }
    ],
    "stats": {
        "total": 300,
        "additions": 145,
        "deletions": 155
    }
}