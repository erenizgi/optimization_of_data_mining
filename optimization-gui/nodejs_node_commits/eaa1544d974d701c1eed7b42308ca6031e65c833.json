{
    "author": "sam-github",
    "message": "doc: describe TLS session resumption\n\nPR-URL: https://github.com/nodejs/node/pull/25174\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>",
    "sha": "eaa1544d974d701c1eed7b42308ca6031e65c833",
    "files": [
        {
            "sha": "9d0011bb5ccf496b86d3ca7478f894dc715cc2fe",
            "filename": "doc/api/tls.md",
            "status": "modified",
            "additions": 147,
            "deletions": 39,
            "changes": 186,
            "blob_url": "https://github.com/nodejs/node/blob/eaa1544d974d701c1eed7b42308ca6031e65c833/doc%2Fapi%2Ftls.md",
            "raw_url": "https://github.com/nodejs/node/raw/eaa1544d974d701c1eed7b42308ca6031e65c833/doc%2Fapi%2Ftls.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ftls.md?ref=eaa1544d974d701c1eed7b42308ca6031e65c833",
            "patch": "@@ -140,6 +140,94 @@ To test the renegotiation limits on a server, connect to it using the OpenSSL\n command-line client (`openssl s_client -connect address:port`) then input\n `R<CR>` (i.e., the letter `R` followed by a carriage return) multiple times.\n \n+### Session Resumption\n+\n+Establishing a TLS session can be relatively slow. The process can be sped\n+up by saving and later reusing the session state. There are several mechanisms\n+to do so, discussed here from oldest to newest (and preferred).\n+\n+***Session Identifiers*** Servers generate a unique ID for new connections and\n+send it to the client. Clients and servers save the session state. When\n+reconnecting, clients send the ID of their saved session state and if the server\n+also has the state for that ID, it can agree to use it. Otherwise, the server\n+will create a new session. See [RFC 2246][] for more information, page 23 and\n+30.\n+\n+Resumption using session identifiers is supported by most web browsers when\n+making HTTPS requests.\n+\n+For Node.js, clients must call [`tls.TLSSocket.getSession()`][] after the\n+[`'secureConnect'`][] event to get the session data, and provide the data to the\n+`session` option of [`tls.connect()`][] to reuse the session. Servers must\n+implement handlers for the [`'newSession'`][] and [`'resumeSession'`][] events\n+to save and restore the session data using the session ID as the lookup key to\n+reuse sessions. To reuse sessions across load balancers or cluster workers,\n+servers must use a shared session cache (such as Redis) in their session\n+handlers.\n+\n+***Session Tickets*** The servers encrypt the entire session state and send it\n+to the client as a \"ticket\". When reconnecting, the state is sent to the server\n+in the initial connection. This mechanism avoids the need for server-side\n+session cache. If the server doesn't use the ticket, for any reason (failure\n+to decrypt it, it's too old, etc.), it will create a new session and send a new\n+ticket. See [RFC 5077][] for more information.\n+\n+Resumption using session tickets is becoming commonly supported by many web\n+browsers when making HTTPS requests.\n+\n+For Node.js, clients use the same APIs for resumption with session identifiers\n+as for resumption with session tickets. For debugging, if\n+[`tls.TLSSocket.getTLSTicket()`][] returns a value, the session data contains a\n+ticket, otherwise it contains client-side session state.\n+\n+Single process servers need no specific implementation to use session tickets.\n+To use session tickets across server restarts or load balancers, servers must\n+all have the same ticket keys. There are three 16-byte keys internally, but the\n+tls API exposes them as a single 48-byte buffer for convenience.\n+\n+Its possible to get the ticket keys by calling [`server.getTicketKeys()`][] on\n+one server instance and then distribute them, but it is more reasonable to\n+securely generate 48 bytes of secure random data and set them with the\n+`ticketKeys` option of [`tls.createServer()`][]. The keys should be regularly\n+regenerated and server's keys can be reset with\n+[`server.setTicketKeys()`][].\n+\n+Session ticket keys are cryptographic keys, and they ***must be stored\n+securely***. With TLS 1.2 and below, if they are compromised all sessions that\n+used tickets encrypted with them can be decrypted. They should not be stored\n+on disk, and they should be regenerated regularly.\n+\n+If clients advertise support for tickets, the server will send them. The\n+server can disable tickets by supplying\n+`require('constants').SSL_OP_NO_TICKET` in `secureOptions`.\n+\n+Both session identifiers and session tickets timeout, causing the server to\n+create new sessions. The timeout can be configured with the `sessionTimeout`\n+option of [`tls.createServer()`][].\n+\n+For all the mechanisms, when resumption fails, servers will create new sessions.\n+Since failing to resume the session does not cause TLS/HTTPS connection\n+failures, it is easy to not notice unnecessarily poor TLS performance. The\n+OpenSSL CLI can be used to verify that servers are resuming sessions. Use the\n+`-reconnect` option to `openssl s_client`, for example:\n+\n+```sh\n+$ openssl s_client -connect localhost:443 -reconnect\n+```\n+\n+Read through the debug output. The first connection should say \"New\", for\n+example:\n+\n+```text\n+New, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256\n+```\n+\n+Subsequent connections should say \"Reused\", for example:\n+\n+```text\n+Reused, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256\n+```\n+\n ## Modifying the Default TLS Cipher suite\n \n Node.js is built with a default suite of enabled and disabled TLS ciphers.\n@@ -169,10 +257,10 @@ HIGH:\n !CAMELLIA\n ```\n \n-This default can be replaced entirely using the [`--tls-cipher-list`][] command line\n-switch (directly, or via the [`NODE_OPTIONS`][] environment variable). For\n-instance, the following makes `ECDHE-RSA-AES128-GCM-SHA256:!RC4` the default\n-TLS cipher suite:\n+This default can be replaced entirely using the [`--tls-cipher-list`][] command\n+line switch (directly, or via the [`NODE_OPTIONS`][] environment variable). For\n+instance, the following makes `ECDHE-RSA-AES128-GCM-SHA256:!RC4` the default TLS\n+cipher suite:\n \n ```sh\n node --tls-cipher-list=\"ECDHE-RSA-AES128-GCM-SHA256:!RC4\" server.js\n@@ -221,11 +309,13 @@ added: v0.9.2\n -->\n \n The `'newSession'` event is emitted upon creation of a new TLS session. This may\n-be used to store sessions in external storage. The listener callback is passed\n-three arguments when called:\n+be used to store sessions in external storage. The data should be provided to\n+the [`'resumeSession'`][] callback.\n+\n+The listener callback is passed three arguments when called:\n \n-* `sessionId` - The TLS session identifier\n-* `sessionData` - The TLS session data\n+* `sessionId` {Buffer} The TLS session identifier\n+* `sessionData` {Buffer} The TLS session data\n * `callback` {Function} A callback function taking no arguments that must be\n   invoked in order for data to be sent or received over the secure connection.\n \n@@ -288,15 +378,19 @@ The `'resumeSession'` event is emitted when the client requests to resume a\n previous TLS session. The listener callback is passed two arguments when\n called:\n \n-* `sessionId` - The TLS/SSL session identifier\n+* `sessionId` {Buffer} The TLS session identifier\n * `callback` {Function} A callback function to be called when the prior session\n-  has been recovered.\n-\n-When called, the event listener may perform a lookup in external storage using\n-the given `sessionId` and invoke `callback(null, sessionData)` once finished. If\n-the session cannot be resumed (i.e., doesn't exist in storage) the callback may\n-be invoked as `callback(null, null)`. Calling `callback(err)` will terminate the\n-incoming connection and destroy the socket.\n+  has been recovered: `callback([err[, sessionData]])`\n+  * `err` {Error}\n+  * `sessionData` {Buffer}\n+\n+The event listener should perform a lookup in external storage for the\n+`sessionData` saved by the [`'newSession'`][] event handler using the given\n+`sessionId`. If found, call `callback(null, sessionData)` to resume the session.\n+If not found, the session cannot be resumed. `callback()` must be called\n+without `sessionData` so that the handshake can continue and a new session can\n+be created. It is possible to call `callback(err)` to terminate the incoming\n+connection and destroy the socket.\n \n Listening for this event will have an effect only on connections established\n after the addition of the event listener.\n@@ -406,10 +500,11 @@ Returns the current number of concurrent connections on the server.\n added: v3.0.0\n -->\n \n-* Returns: {Buffer}\n+* Returns: {Buffer} A 48-byte buffer containing the session ticket keys.\n \n-Returns a `Buffer` instance holding the keys currently used for\n-encryption/decryption of the [TLS Session Tickets][].\n+Returns the session ticket keys.\n+\n+See [Session Resumption][] for more information.\n \n ### server.listen()\n \n@@ -433,17 +528,15 @@ existing server. Existing connections to the server are not interrupted.\n added: v3.0.0\n -->\n \n-* `keys` {Buffer} The keys used for encryption/decryption of the\n-  [TLS Session Tickets][].\n-\n-Updates the keys for encryption/decryption of the [TLS Session Tickets][].\n+* `keys` {Buffer} A 48-byte buffer containing the session ticket keys.\n \n-The key's `Buffer` should be 48 bytes long. See `ticketKeys` option in\n-[`tls.createServer()`] for more information on how it is used.\n+Sets the session ticket keys.\n \n Changes to the ticket keys are effective only for future server connections.\n Existing or currently pending server connections will use the previous keys.\n \n+See [Session Resumption][] for more information.\n+\n ## Class: tls.TLSSocket\n <!-- YAML\n added: v0.11.4\n@@ -782,19 +875,28 @@ information.\n added: v0.11.4\n -->\n \n-Returns the ASN.1 encoded TLS session or `undefined` if no session was\n-negotiated. Can be used to speed up handshake establishment when reconnecting\n-to the server.\n+* {Buffer}\n+\n+Returns the TLS session data or `undefined` if no session was\n+negotiated. On the client, the data can be provided to the `session` option of\n+[`tls.connect()`][] to resume the connection. On the server, it may be useful\n+for debugging.\n+\n+See [Session Resumption][] for more information.\n \n ### tlsSocket.getTLSTicket()\n <!-- YAML\n added: v0.11.4\n -->\n \n-Returns the TLS session ticket or `undefined` if no session was negotiated.\n+* {Buffer}\n+\n+For a client, returns the TLS session ticket if one is available, or\n+`undefined`. For a server, always returns `undefined`.\n+\n+It may be useful for debugging.\n \n-This only works with client TLS sockets. Useful only for debugging, for session\n-reuse provide `session` option to [`tls.connect()`][].\n+See [Session Resumption][] for more information.\n \n ### tlsSocket.localAddress\n <!-- YAML\n@@ -1230,18 +1332,17 @@ changes:\n   * `requestCert` {boolean} If `true` the server will request a certificate from\n     clients that connect and attempt to verify that certificate. **Default:**\n     `false`.\n-  * `sessionTimeout` {number} An integer specifying the number of seconds after\n-    which the TLS session identifiers and TLS session tickets created by the\n-    server will time out. See [`SSL_CTX_set_timeout`] for more details.\n+  * `sessionTimeout` {number} The number of seconds after which a TLS session\n+    created by the server will no longer be resumable. See\n+    [Session Resumption][] for more information. **Default:** `300`.\n   * `SNICallback(servername, cb)` {Function} A function that will be called if\n     the client supports SNI TLS extension. Two arguments will be passed when\n     called: `servername` and `cb`. `SNICallback` should invoke `cb(null, ctx)`,\n     where `ctx` is a `SecureContext` instance. (`tls.createSecureContext(...)`\n     can be used to get a proper `SecureContext`.) If `SNICallback` wasn't\n     provided the default callback with high-level API will be used (see below).\n-  * `ticketKeys`: A 48-byte `Buffer` instance consisting of a 16-byte prefix,\n-    a 16-byte HMAC key, and a 16-byte AES key. This can be used to accept TLS\n-    session tickets on multiple instances of the TLS server.\n+  * `ticketKeys`: {Buffer} 48-bytes of cryptographically strong pseudo-random\n+    data. See [Session Resumption][] for more information.\n   * ...: Any [`tls.createSecureContext()`][] option can be provided. For\n     servers, the identity options (`pfx` or `key`/`cert`) are usually required.\n * `secureConnectionListener` {Function}\n@@ -1416,21 +1517,26 @@ secureSocket = tls.TLSSocket(socket, options);\n \n where `secureSocket` has the same API as `pair.cleartext`.\n \n+[`'newSession'`]: #tls_event_newsession\n+[`'resumeSession'`]: #tls_event_resumesession\n [`'secureConnect'`]: #tls_event_secureconnect\n [`'secureConnection'`]: #tls_event_secureconnection\n [`--tls-cipher-list`]: cli.html#cli_tls_cipher_list_list\n [`NODE_OPTIONS`]: cli.html#cli_node_options_options\n-[`SSL_CTX_set_timeout`]: https://www.openssl.org/docs/man1.1.0/ssl/SSL_CTX_set_timeout.html\n [`crypto.getCurves()`]: crypto.html#crypto_crypto_getcurves\n [`dns.lookup()`]: dns.html#dns_dns_lookup_hostname_options_callback\n [`net.Server.address()`]: net.html#net_server_address\n [`net.Server`]: net.html#net_class_net_server\n [`net.Socket`]: net.html#net_class_net_socket\n [`server.getConnections()`]: net.html#net_server_getconnections_callback\n+[`server.getTicketKeys()`]: #tls_server_getticketkeys\n [`server.listen()`]: net.html#net_server_listen\n+[`server.setTicketKeys()`]: #tls_server_setticketkeys_keys\n [`tls.DEFAULT_ECDH_CURVE`]: #tls_tls_default_ecdh_curve\n [`tls.Server`]: #tls_class_tls_server\n [`tls.TLSSocket.getPeerCertificate()`]: #tls_tlssocket_getpeercertificate_detailed\n+[`tls.TLSSocket.getSession()`]: #tls_tlssocket_getsession\n+[`tls.TLSSocket.getTLSTicket()`]: #tls_tlssocket_gettlsticket\n [`tls.TLSSocket`]: #tls_class_tls_tlssocket\n [`tls.connect()`]: #tls_tls_connect_options_callback\n [`tls.createSecureContext()`]: #tls_tls_createsecurecontext_options\n@@ -1445,10 +1551,12 @@ where `secureSocket` has the same API as `pair.cleartext`.\n [OpenSSL Options]: crypto.html#crypto_openssl_options\n [OpenSSL cipher list format documentation]: https://www.openssl.org/docs/man1.1.0/apps/ciphers.html#CIPHER-LIST-FORMAT\n [Perfect Forward Secrecy]: #tls_perfect_forward_secrecy\n+[RFC 2246]: https://www.ietf.org/rfc/rfc2246.txt\n+[RFC 5077]: https://tools.ietf.org/html/rfc5077\n [RFC 5929]: https://tools.ietf.org/html/rfc5929\n [SSL_METHODS]: https://www.openssl.org/docs/man1.1.0/ssl/ssl.html#Dealing-with-Protocol-Methods\n+[Session Resumption]: #tls_session_resumption\n [Stream]: stream.html#stream_stream\n-[TLS Session Tickets]: https://www.ietf.org/rfc/rfc5077.txt\n [TLS recommendations]: https://wiki.mozilla.org/Security/Server_Side_TLS\n [asn1.js]: https://www.npmjs.com/package/asn1.js\n [certificate object]: #tls_certificate_object"
        }
    ],
    "stats": {
        "total": 186,
        "additions": 147,
        "deletions": 39
    }
}