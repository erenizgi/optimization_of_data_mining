{
    "author": "anandsuresh",
    "message": "zlib: fix windowBits validation to allow 0 for decompression mode\n\nFrom the zlib v1.2.11 manual:\n\n> ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,\n>                                      int  windowBits));\n>\n> ...\n> windowBits can also be zero to request that inflate use the window\n> size in the zlib header of the compressed stream.\n\nThe current validation of windowBits in zlib.js doesn't check for this\ncase.\n\nPR-URL: https://github.com/nodejs/node/pull/19686\nReviewed-By: Richard Lau <riclau@uk.ibm.com>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>",
    "sha": "7bc5151d5ec819001d40c4b34f6921d5a7242ba8",
    "files": [
        {
            "sha": "5ce8637a50f04fdac84b677009464ff2756d476c",
            "filename": "lib/zlib.js",
            "status": "modified",
            "additions": 13,
            "deletions": 3,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/7bc5151d5ec819001d40c4b34f6921d5a7242ba8/lib%2Fzlib.js",
            "raw_url": "https://github.com/nodejs/node/raw/7bc5151d5ec819001d40c4b34f6921d5a7242ba8/lib%2Fzlib.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fzlib.js?ref=7bc5151d5ec819001d40c4b34f6921d5a7242ba8",
            "patch": "@@ -251,9 +251,19 @@ function Zlib(opts, mode) {\n       opts.finishFlush, 'options.finishFlush',\n       Z_NO_FLUSH, Z_BLOCK, Z_FINISH);\n \n-    windowBits = checkRangesOrGetDefault(\n-      opts.windowBits, 'options.windowBits',\n-      Z_MIN_WINDOWBITS, Z_MAX_WINDOWBITS, Z_DEFAULT_WINDOWBITS);\n+    // windowBits is special. On the compression side, 0 is an invalid value.\n+    // But on the decompression side, a value of 0 for windowBits tells zlib\n+    // to use the window size in the zlib header of the compressed stream.\n+    if ((opts.windowBits == null || opts.windowBits === 0) &&\n+        (mode === INFLATE ||\n+         mode === GUNZIP ||\n+         mode === UNZIP)) {\n+      windowBits = 0;\n+    } else {\n+      windowBits = checkRangesOrGetDefault(\n+        opts.windowBits, 'options.windowBits',\n+        Z_MIN_WINDOWBITS, Z_MAX_WINDOWBITS, Z_DEFAULT_WINDOWBITS);\n+    }\n \n     level = checkRangesOrGetDefault(\n       opts.level, 'options.level',"
        },
        {
            "sha": "4367d043d25a30dd574a3fd9359179036b2afe13",
            "filename": "src/node_zlib.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/7bc5151d5ec819001d40c4b34f6921d5a7242ba8/src%2Fnode_zlib.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7bc5151d5ec819001d40c4b34f6921d5a7242ba8/src%2Fnode_zlib.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_zlib.cc?ref=7bc5151d5ec819001d40c4b34f6921d5a7242ba8",
            "patch": "@@ -438,9 +438,17 @@ class ZCtx : public AsyncWrap {\n     ZCtx* ctx;\n     ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n \n+    // windowBits is special. On the compression side, 0 is an invalid value.\n+    // But on the decompression side, a value of 0 for windowBits tells zlib\n+    // to use the window size in the zlib header of the compressed stream.\n     int windowBits = args[0]->Uint32Value();\n-    CHECK((windowBits >= Z_MIN_WINDOWBITS && windowBits <= Z_MAX_WINDOWBITS) &&\n-      \"invalid windowBits\");\n+    if (!((windowBits == 0) &&\n+          (ctx->mode_ == INFLATE ||\n+           ctx->mode_ == GUNZIP ||\n+           ctx->mode_ == UNZIP))) {\n+      CHECK((windowBits >= Z_MIN_WINDOWBITS &&\n+             windowBits <= Z_MAX_WINDOWBITS) && \"invalid windowBits\");\n+    }\n \n     int level = args[1]->Int32Value();\n     CHECK((level >= Z_MIN_LEVEL && level <= Z_MAX_LEVEL) &&"
        },
        {
            "sha": "a62e6148e33df77e5f471692c60e5da9e8f8fc41",
            "filename": "test/parallel/test-zlib-zero-windowBits.js",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/7bc5151d5ec819001d40c4b34f6921d5a7242ba8/test%2Fparallel%2Ftest-zlib-zero-windowBits.js",
            "raw_url": "https://github.com/nodejs/node/raw/7bc5151d5ec819001d40c4b34f6921d5a7242ba8/test%2Fparallel%2Ftest-zlib-zero-windowBits.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-zlib-zero-windowBits.js?ref=7bc5151d5ec819001d40c4b34f6921d5a7242ba8",
            "patch": "@@ -0,0 +1,33 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const zlib = require('zlib');\n+\n+\n+// windowBits is a special case in zlib. On the compression side, 0 is invalid.\n+// On the decompression side, it indicates that zlib should use the value from\n+// the header of the compressed stream.\n+{\n+  const inflate = zlib.createInflate({ windowBits: 0 });\n+  assert(inflate instanceof zlib.Inflate);\n+}\n+\n+{\n+  const gunzip = zlib.createGunzip({ windowBits: 0 });\n+  assert(gunzip instanceof zlib.Gunzip);\n+}\n+\n+{\n+  const unzip = zlib.createUnzip({ windowBits: 0 });\n+  assert(unzip instanceof zlib.Unzip);\n+}\n+\n+{\n+  common.expectsError(() => zlib.createGzip({ windowBits: 0 }), {\n+    code: 'ERR_OUT_OF_RANGE',\n+    type: RangeError,\n+    message: 'The value of \"options.windowBits\" is out of range. ' +\n+             'It must be >= 8 and <= 15. Received 0'\n+  });\n+}"
        }
    ],
    "stats": {
        "total": 61,
        "additions": 56,
        "deletions": 5
    }
}