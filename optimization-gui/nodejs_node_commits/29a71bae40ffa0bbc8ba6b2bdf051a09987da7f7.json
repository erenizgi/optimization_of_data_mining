{
    "author": "addaleax",
    "message": "src: refactor options parsing\n\nThis is a major refactor of our Nodeâ€™s parser. See `node_options.cc`\nfor how it is used, and  `node_options-inl.h` for the bulk\nof its implementation.\n\nUnfortunately, the implementation has come to have some\ncomplexity, in order to meet the following goals:\n\n- Make it easy to *use* for defining or changing options.\n- Keep it (mostly) backwards-compatible.\n  - No tests were harmed as part of this commit.\n- Be as consistent as possible.\n  - In particular, options can now generally accept arguments\n    through both `--foo=bar` notation and `--foo bar` notation.\n    We were previously very inconsistent on this point.\n- Separate into different levels of scope, namely\n  per-process (global), per-Isolate and per-Environment\n  (+ debug options).\n- Allow programmatic accessibility in the future.\n  - This includes a possible expansion for `--help` output.\n\nThis commit also leaves a number of `TODO` comments, mostly for\nimproving consistency even more (possibly with having to modify\ntests), improving embedder support, as well as removing pieces of\nexposed configuration variables that should never have become\npart of the public API but unfortunately are at this point.\n\nPR-URL: https://github.com/nodejs/node/pull/22392\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
    "files": [
        {
            "sha": "5b8ca26bb2010d472820ae22df63966847b63025",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -343,14 +343,14 @@\n         'src/node_config.cc',\n         'src/node_constants.cc',\n         'src/node_contextify.cc',\n-        'src/node_debug_options.cc',\n         'src/node_domain.cc',\n         'src/node_encoding.cc',\n         'src/node_errors.h',\n         'src/node_file.cc',\n         'src/node_http2.cc',\n         'src/node_http_parser.cc',\n         'src/node_messaging.cc',\n+        'src/node_options.cc',\n         'src/node_os.cc',\n         'src/node_platform.cc',\n         'src/node_perf.cc',\n@@ -407,14 +407,15 @@\n         'src/node_code_cache.h',\n         'src/node_constants.h',\n         'src/node_contextify.h',\n-        'src/node_debug_options.h',\n         'src/node_file.h',\n         'src/node_http2.h',\n         'src/node_http2_state.h',\n         'src/node_internals.h',\n         'src/node_javascript.h',\n         'src/node_messaging.h',\n         'src/node_mutex.h',\n+        'src/node_options.h',\n+        'src/node_options-inl.h',\n         'src/node_perf.h',\n         'src/node_perf_common.h',\n         'src/node_persistent.h',"
        },
        {
            "sha": "28c30e035438c56a5b311de94a9a25231025e51f",
            "filename": "src/env-inl.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fenv-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fenv-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv-inl.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -564,6 +564,14 @@ Environment::file_handle_read_wrap_freelist() {\n   return file_handle_read_wrap_freelist_;\n }\n \n+inline std::shared_ptr<EnvironmentOptions> Environment::options() {\n+  return options_;\n+}\n+\n+inline std::shared_ptr<PerIsolateOptions> IsolateData::options() {\n+  return options_;\n+}\n+\n void Environment::CreateImmediate(native_immediate_callback cb,\n                                   void* data,\n                                   v8::Local<v8::Object> obj,"
        },
        {
            "sha": "9c854f6f3ffee72650457be6ccded8afd650fc77",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 8,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -48,6 +48,8 @@ IsolateData::IsolateData(Isolate* isolate,\n   if (platform_ != nullptr)\n     platform_->RegisterIsolate(this, event_loop);\n \n+  options_.reset(new PerIsolateOptions(*per_process_opts->per_isolate));\n+\n   // Create string and private symbol properties as internalized one byte\n   // strings after the platform is properly initialized.\n   //\n@@ -136,9 +138,6 @@ Environment::Environment(IsolateData* isolate_data,\n       makecallback_cntr_(0),\n       should_abort_on_uncaught_toggle_(isolate_, 1),\n       trace_category_state_(isolate_, kTraceCategoryCount),\n-#if HAVE_INSPECTOR\n-      inspector_agent_(new inspector::Agent(this)),\n-#endif\n       http_parser_buffer_(nullptr),\n       fs_stats_field_array_(isolate_, kFsStatsFieldsLength * 2),\n       fs_stats_field_bigint_array_(isolate_, kFsStatsFieldsLength * 2),\n@@ -148,6 +147,19 @@ Environment::Environment(IsolateData* isolate_data,\n   v8::Context::Scope context_scope(context);\n   set_as_external(v8::External::New(isolate(), this));\n \n+  // We create new copies of the per-Environment option sets, so that it is\n+  // easier to modify them after Environment creation. The defaults are\n+  // part of the per-Isolate option set, for which in turn the defaults are\n+  // part of the per-process option set.\n+  options_.reset(new EnvironmentOptions(*isolate_data->options()->per_env));\n+  options_->debug_options.reset(new DebugOptions(*options_->debug_options));\n+\n+#if HAVE_INSPECTOR\n+  // We can only create the inspector agent after having cloned the options.\n+  inspector_agent_ =\n+      std::unique_ptr<inspector::Agent>(new inspector::Agent(this));\n+#endif\n+\n   AssignToContext(context, ContextInfo(\"\"));\n \n   if (tracing_agent_writer_ != nullptr) {\n@@ -211,10 +223,8 @@ Environment::~Environment() {\n   delete[] http_parser_buffer_;\n }\n \n-void Environment::Start(int argc,\n-                        const char* const* argv,\n-                        int exec_argc,\n-                        const char* const* exec_argv,\n+void Environment::Start(const std::vector<std::string>& args,\n+                        const std::vector<std::string>& exec_args,\n                         bool start_profiler_idle_notifier) {\n   HandleScope handle_scope(isolate());\n   Context::Scope context_scope(context());\n@@ -260,7 +270,7 @@ void Environment::Start(int argc,\n       process_template->GetFunction()->NewInstance(context()).ToLocalChecked();\n   set_process_object(process_object);\n \n-  SetupProcessObject(this, argc, argv, exec_argc, exec_argv);\n+  SetupProcessObject(this, args, exec_args);\n \n   static uv_once_t init_once = UV_ONCE_INIT;\n   uv_once(&init_once, InitThreadLocalOnce);"
        },
        {
            "sha": "556a09754fc465c9d45467f4c99df00ff44caad5",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -34,6 +34,7 @@\n #include \"uv.h\"\n #include \"v8.h\"\n #include \"node.h\"\n+#include \"node_options.h\"\n #include \"node_http2_state.h\"\n \n #include <list>\n@@ -365,6 +366,7 @@ class IsolateData {\n   inline uv_loop_t* event_loop() const;\n   inline uint32_t* zero_fill_field() const;\n   inline MultiIsolatePlatform* platform() const;\n+  inline std::shared_ptr<PerIsolateOptions> options();\n \n #define VP(PropertyName, StringValue) V(v8::Private, PropertyName)\n #define VY(PropertyName, StringValue) V(v8::Symbol, PropertyName)\n@@ -398,6 +400,7 @@ class IsolateData {\n   uv_loop_t* const event_loop_;\n   uint32_t* const zero_fill_field_;\n   MultiIsolatePlatform* platform_;\n+  std::shared_ptr<PerIsolateOptions> options_;\n \n   DISALLOW_COPY_AND_ASSIGN(IsolateData);\n };\n@@ -582,10 +585,8 @@ class Environment {\n               tracing::AgentWriterHandle* tracing_agent_writer);\n   ~Environment();\n \n-  void Start(int argc,\n-             const char* const* argv,\n-             int exec_argc,\n-             const char* const* exec_argv,\n+  void Start(const std::vector<std::string>& args,\n+             const std::vector<std::string>& exec_args,\n              bool start_profiler_idle_notifier);\n \n   typedef void (*HandleCleanupCb)(Environment* env,\n@@ -882,6 +883,8 @@ class Environment {\n                                  v8::EmbedderGraph* graph,\n                                  void* data);\n \n+  inline std::shared_ptr<EnvironmentOptions> options();\n+\n  private:\n   inline void CreateImmediate(native_immediate_callback cb,\n                               void* data,\n@@ -912,6 +915,8 @@ class Environment {\n   size_t makecallback_cntr_;\n   std::vector<double> destroy_async_id_list_;\n \n+  std::shared_ptr<EnvironmentOptions> options_;\n+\n   AliasedBuffer<uint32_t, v8::Uint32Array> should_abort_on_uncaught_toggle_;\n   int should_not_abort_scope_counter_ = 0;\n "
        },
        {
            "sha": "adc32f1bcd4c190438020d79bbe06cca13a3f377",
            "filename": "src/inspector_agent.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -608,11 +608,14 @@ class NodeInspectorClient : public V8InspectorClient {\n   std::unique_ptr<MainThreadInterface> interface_;\n };\n \n-Agent::Agent(Environment* env) : parent_env_(env) {}\n+Agent::Agent(Environment* env)\n+  : parent_env_(env),\n+    debug_options_(env->options()->debug_options) {}\n \n Agent::~Agent() = default;\n \n-bool Agent::Start(const std::string& path, const DebugOptions& options) {\n+bool Agent::Start(const std::string& path,\n+                  std::shared_ptr<DebugOptions> options) {\n   path_ = path;\n   debug_options_ = options;\n   client_ = std::make_shared<NodeInspectorClient>(parent_env_);\n@@ -626,8 +629,8 @@ bool Agent::Start(const std::string& path, const DebugOptions& options) {\n     StartDebugSignalHandler();\n   }\n \n-  bool wait_for_connect = options.wait_for_connect();\n-  if (!options.inspector_enabled() || !StartIoThread()) {\n+  bool wait_for_connect = options->wait_for_connect();\n+  if (!options->inspector_enabled || !StartIoThread()) {\n     return false;\n   }\n   if (wait_for_connect) {\n@@ -789,7 +792,7 @@ void Agent::ContextCreated(Local<Context> context, const ContextInfo& info) {\n }\n \n bool Agent::WillWaitForConnect() {\n-  return debug_options_.wait_for_connect();\n+  return debug_options_->wait_for_connect();\n }\n \n bool Agent::IsActive() {"
        },
        {
            "sha": "4e32d3ef1a96b42b160c6709bb236a5e1284cb82",
            "filename": "src/inspector_agent.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_agent.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_agent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -9,7 +9,7 @@\n #error(\"This header can only be used when inspector is enabled\")\n #endif\n \n-#include \"node_debug_options.h\"\n+#include \"node_options.h\"\n #include \"node_persistent.h\"\n #include \"v8.h\"\n \n@@ -45,7 +45,7 @@ class Agent {\n   ~Agent();\n \n   // Create client_, may create io_ if option enabled\n-  bool Start(const std::string& path, const DebugOptions& options);\n+  bool Start(const std::string& path, std::shared_ptr<DebugOptions> options);\n   // Stop and destroy io_\n   void Stop();\n \n@@ -96,7 +96,7 @@ class Agent {\n   // Calls StartIoThread() from off the main thread.\n   void RequestIoThreadStart();\n \n-  DebugOptions& options() { return debug_options_; }\n+  std::shared_ptr<DebugOptions> options() { return debug_options_; }\n   void ContextCreated(v8::Local<v8::Context> context, const ContextInfo& info);\n \n  private:\n@@ -109,7 +109,7 @@ class Agent {\n   // Interface for transports, e.g. WebSocket server\n   std::unique_ptr<InspectorIo> io_;\n   std::string path_;\n-  DebugOptions debug_options_;\n+  std::shared_ptr<DebugOptions> debug_options_;\n \n   bool pending_enable_async_hook_ = false;\n   bool pending_disable_async_hook_ = false;"
        },
        {
            "sha": "da44d55d06e10a2c1d8f86743d23abbfb83578bb",
            "filename": "src/inspector_io.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_io.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_io.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -242,7 +242,7 @@ class InspectorIoDelegate: public node::inspector::SocketServerDelegate {\n std::unique_ptr<InspectorIo> InspectorIo::Start(\n     std::shared_ptr<MainThreadHandle> main_thread,\n     const std::string& path,\n-    const DebugOptions& options) {\n+    std::shared_ptr<DebugOptions> options) {\n   auto io = std::unique_ptr<InspectorIo>(\n       new InspectorIo(main_thread, path, options));\n   if (io->request_queue_->Expired()) {  // Thread is not running\n@@ -253,7 +253,7 @@ std::unique_ptr<InspectorIo> InspectorIo::Start(\n \n InspectorIo::InspectorIo(std::shared_ptr<MainThreadHandle> main_thread,\n                          const std::string& path,\n-                         const DebugOptions& options)\n+                         std::shared_ptr<DebugOptions> options)\n                          : main_thread_(main_thread), options_(options),\n                            thread_(), script_name_(path), id_(GenerateID()) {\n   Mutex::ScopedLock scoped_lock(thread_start_lock_);\n@@ -288,7 +288,8 @@ void InspectorIo::ThreadMain() {\n       new InspectorIoDelegate(queue, main_thread_, id_,\n                               script_path, script_name_));\n   InspectorSocketServer server(std::move(delegate), &loop,\n-                               options_.host_name(), options_.port());\n+                               options_->host().c_str(),\n+                               options_->port());\n   request_queue_ = queue->handle();\n   // Its lifetime is now that of the server delegate\n   queue.reset();"
        },
        {
            "sha": "2b9f0acd48383d4ef4a53bdc0654318bc33ae951",
            "filename": "src/inspector_io.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_io.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_io.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -2,7 +2,6 @@\n #define SRC_INSPECTOR_IO_H_\n \n #include \"inspector_socket_server.h\"\n-#include \"node_debug_options.h\"\n #include \"node_mutex.h\"\n #include \"uv.h\"\n \n@@ -46,19 +45,20 @@ class InspectorIo {\n   // Returns empty pointer if thread was not started\n   static std::unique_ptr<InspectorIo> Start(\n       std::shared_ptr<MainThreadHandle> main_thread, const std::string& path,\n-      const DebugOptions& options);\n+      std::shared_ptr<DebugOptions> options);\n \n   // Will block till the transport thread shuts down\n   ~InspectorIo();\n \n   void StopAcceptingNewConnections();\n-  std::string host() const { return options_.host_name(); }\n+  const std::string& host() const { return options_->host(); }\n   int port() const { return port_; }\n   std::vector<std::string> GetTargetIds() const;\n \n  private:\n   InspectorIo(std::shared_ptr<MainThreadHandle> handle,\n-              const std::string& path, const DebugOptions& options);\n+              const std::string& path,\n+              std::shared_ptr<DebugOptions> options);\n \n   // Wrapper for agent->ThreadMain()\n   static void ThreadMain(void* agent);\n@@ -72,7 +72,7 @@ class InspectorIo {\n   // Used to post on a frontend interface thread, lives while the server is\n   // running\n   std::shared_ptr<RequestQueue> request_queue_;\n-  const DebugOptions options_;\n+  std::shared_ptr<DebugOptions> options_;\n \n   // The IO thread runs its own uv_loop to implement the TCP server off\n   // the main thread."
        },
        {
            "sha": "b8c78ba5ebd66d7bd37ab7b7329a6f3c634c325d",
            "filename": "src/inspector_js_api.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_js_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Finspector_js_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_js_api.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -242,12 +242,12 @@ void Open(const FunctionCallbackInfo<Value>& args) {\n \n   if (args.Length() > 0 && args[0]->IsUint32()) {\n     uint32_t port = args[0]->Uint32Value();\n-    agent->options().set_port(static_cast<int>(port));\n+    agent->options()->host_port.port = port;\n   }\n \n   if (args.Length() > 1 && args[1]->IsString()) {\n     Utf8Value host(env->isolate(), args[1].As<String>());\n-    agent->options().set_host_name(*host);\n+    agent->options()->host_port.host_name = *host;\n   }\n \n   if (args.Length() > 2 && args[2]->IsBoolean()) {"
        },
        {
            "sha": "b60024171046ff04515042b9987083e868c84533",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 244,
            "deletions": 574,
            "changes": 818,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -27,7 +27,6 @@\n #include \"node_version.h\"\n #include \"node_internals.h\"\n #include \"node_revert.h\"\n-#include \"node_debug_options.h\"\n #include \"node_perf.h\"\n #include \"node_context_data.h\"\n #include \"tracing/traced_value.h\"\n@@ -172,19 +171,6 @@ using v8::Value;\n static Mutex process_mutex;\n static Mutex environ_mutex;\n \n-static bool print_eval = false;\n-static bool force_repl = false;\n-static bool syntax_check_only = false;\n-static bool trace_deprecation = false;\n-static bool throw_deprecation = false;\n-static bool trace_sync_io = false;\n-static bool no_force_async_hooks_checks = false;\n-static bool track_heap_objects = false;\n-static const char* eval_string = nullptr;\n-static std::vector<std::string> preload_modules;\n-static const int v8_default_thread_pool_size = 4;\n-static int v8_thread_pool_size = v8_default_thread_pool_size;\n-static bool prof_process = false;\n static bool v8_is_profiling = false;\n static bool node_is_initialized = false;\n static uv_once_t init_modpending_once = UV_ONCE_INIT;\n@@ -193,105 +179,26 @@ static node_module* modlist_builtin;\n static node_module* modlist_internal;\n static node_module* modlist_linked;\n static node_module* modlist_addon;\n-static std::string trace_enabled_categories;  // NOLINT(runtime/string)\n-static std::string trace_file_pattern =  // NOLINT(runtime/string)\n-  \"node_trace.${rotation}.log\";\n+\n+// TODO(addaleax): This should not be global.\n static bool abort_on_uncaught_exception = false;\n \n // Bit flag used to track security reverts (see node_revert.h)\n unsigned int reverted = 0;\n \n-#if defined(NODE_HAVE_I18N_SUPPORT)\n-// Path to ICU data (for i18n / Intl)\n-std::string icu_data_dir;  // NOLINT(runtime/string)\n-#endif\n-\n-// used by C++ modules as well\n-bool no_deprecation = false;\n-\n-#if HAVE_OPENSSL\n-// use OpenSSL's cert store instead of bundled certs\n-bool ssl_openssl_cert_store =\n-#if defined(NODE_OPENSSL_CERT_STORE)\n-        true;\n-#else\n-        false;\n-#endif\n-\n-# if NODE_FIPS_MODE\n-// used by crypto module\n-bool enable_fips_crypto = false;\n-bool force_fips_crypto = false;\n-# endif  // NODE_FIPS_MODE\n-std::string openssl_config;  // NOLINT(runtime/string)\n-#endif  // HAVE_OPENSSL\n-\n-// true if process warnings should be suppressed\n-bool no_process_warnings = false;\n-bool trace_warnings = false;\n-\n-// Set in node.cc by ParseArgs when --preserve-symlinks is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/module.js\n-bool config_preserve_symlinks = false;\n-\n-// Set in node.cc by ParseArgs when --preserve-symlinks-main is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/module.js\n-bool config_preserve_symlinks_main = false;\n-\n-// Set in node.cc by ParseArgs when --experimental-modules is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/module.js\n-bool config_experimental_modules = false;\n-\n-// Set in node.cc by ParseArgs when --experimental-vm-modules is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/vm.js\n-bool config_experimental_vm_modules = false;\n-\n-// Set in node.cc by ParseArgs when --experimental-worker is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/worker.js\n-bool config_experimental_worker = false;\n-\n-// Set in node.cc by ParseArgs when --experimental-repl-await is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/repl.js.\n-bool config_experimental_repl_await = false;\n-\n-// Set in node.cc by ParseArgs when --loader is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/internal/bootstrap/node.js\n-std::string config_userland_loader;  // NOLINT(runtime/string)\n-\n-// Set by ParseArgs when --pending-deprecation or NODE_PENDING_DEPRECATION\n-// is used.\n-bool config_pending_deprecation = false;\n-\n-// Set in node.cc by ParseArgs when --redirect-warnings= is used.\n-std::string config_warning_file;  // NOLINT(runtime/string)\n-\n-// Set in node.cc by ParseArgs when --expose-internals or --expose_internals is\n-// used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/internal/bootstrap/node.js\n-bool config_expose_internals = false;\n-\n-std::string config_process_title;  // NOLINT(runtime/string)\n-\n bool v8_initialized = false;\n \n bool linux_at_secure = false;\n \n // process-relative uptime base, initialized at start-up\n double prog_start_time;\n \n+std::shared_ptr<PerProcessOptions> per_process_opts {\n+    new PerProcessOptions() };\n+\n static Mutex node_isolate_mutex;\n static v8::Isolate* node_isolate;\n \n-DebugOptions debug_options;\n-\n // Ensures that __metadata trace events are only emitted\n // when tracing is enabled.\n class NodeTraceStateObserver :\n@@ -415,7 +322,7 @@ static struct {\n \n #if HAVE_INSPECTOR\n   bool StartInspector(Environment* env, const char* script_path,\n-                      const DebugOptions& options) {\n+                      std::shared_ptr<DebugOptions> options) {\n     // Inspector agent can't fail to start, but if it was configured to listen\n     // right away on the websocket port and fails to bind/etc, this will return\n     // false.\n@@ -429,13 +336,14 @@ static struct {\n #endif  // HAVE_INSPECTOR\n \n   void StartTracingAgent() {\n-    if (trace_enabled_categories.empty()) {\n+    if (per_process_opts->trace_event_categories.empty()) {\n       tracing_file_writer_ = tracing_agent_->DefaultHandle();\n     } else {\n       tracing_file_writer_ = tracing_agent_->AddClient(\n-          ParseCommaSeparatedSet(trace_enabled_categories),\n+          ParseCommaSeparatedSet(per_process_opts->trace_event_categories),\n           std::unique_ptr<tracing::AsyncTraceWriter>(\n-              new tracing::NodeTraceWriter(trace_file_pattern)),\n+              new tracing::NodeTraceWriter(\n+                  per_process_opts->trace_event_file_pattern)),\n           tracing::Agent::kUseDefaultCategories);\n     }\n   }\n@@ -1844,7 +1752,7 @@ static void EnvSetter(Local<Name> property,\n                       Local<Value> value,\n                       const PropertyCallbackInfo<Value>& info) {\n   Environment* env = Environment::GetCurrent(info);\n-  if (config_pending_deprecation && env->EmitProcessEnvWarning() &&\n+  if (env->options()->pending_deprecation && env->EmitProcessEnvWarning() &&\n       !value->IsString() && !value->IsNumber() && !value->IsBoolean()) {\n     if (ProcessEmitDeprecationWarning(\n           env,\n@@ -2034,11 +1942,11 @@ static Local<Object> GetFeatures(Environment* env) {\n \n static void DebugPortGetter(Local<Name> property,\n                             const PropertyCallbackInfo<Value>& info) {\n+  Environment* env = Environment::GetCurrent(info);\n   Mutex::ScopedLock lock(process_mutex);\n-  int port = debug_options.port();\n+  int port = env->options()->debug_options->port();\n #if HAVE_INSPECTOR\n   if (port == 0) {\n-    Environment* env = Environment::GetCurrent(info);\n     if (auto io = env->inspector_agent()->io())\n       port = io->port();\n   }\n@@ -2050,8 +1958,10 @@ static void DebugPortGetter(Local<Name> property,\n static void DebugPortSetter(Local<Name> property,\n                             Local<Value> value,\n                             const PropertyCallbackInfo<void>& info) {\n+  Environment* env = Environment::GetCurrent(info);\n   Mutex::ScopedLock lock(process_mutex);\n-  debug_options.set_port(value->Int32Value());\n+  env->options()->debug_options->host_port.port =\n+      value->Int32Value(env->context()).FromMaybe(0);\n }\n \n \n@@ -2081,10 +1991,8 @@ namespace {\n }  // anonymous namespace\n \n void SetupProcessObject(Environment* env,\n-                        int argc,\n-                        const char* const* argv,\n-                        int exec_argc,\n-                        const char* const* exec_argv) {\n+                        const std::vector<std::string>& args,\n+                        const std::vector<std::string>& exec_args) {\n   HandleScope scope(env->isolate());\n \n   Local<Object> process = env->process_object();\n@@ -2222,18 +2130,22 @@ void SetupProcessObject(Environment* env,\n #endif\n \n   // process.argv\n-  Local<Array> arguments = Array::New(env->isolate(), argc);\n-  for (int i = 0; i < argc; ++i) {\n-    arguments->Set(i, String::NewFromUtf8(env->isolate(), argv[i],\n-        v8::NewStringType::kNormal).ToLocalChecked());\n+  Local<Array> arguments = Array::New(env->isolate(), args.size());\n+  for (size_t i = 0; i < args.size(); ++i) {\n+    arguments->Set(env->context(), i,\n+        String::NewFromUtf8(env->isolate(), args[i].c_str(),\n+                            v8::NewStringType::kNormal).ToLocalChecked())\n+        .FromJust();\n   }\n   process->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"argv\"), arguments);\n \n   // process.execArgv\n-  Local<Array> exec_arguments = Array::New(env->isolate(), exec_argc);\n-  for (int i = 0; i < exec_argc; ++i) {\n-    exec_arguments->Set(i, String::NewFromUtf8(env->isolate(), exec_argv[i],\n-        v8::NewStringType::kNormal).ToLocalChecked());\n+  Local<Array> exec_arguments = Array::New(env->isolate(), exec_args.size());\n+  for (size_t i = 0; i < exec_args.size(); ++i) {\n+    exec_arguments->Set(env->context(), i,\n+        String::NewFromUtf8(env->isolate(), exec_args[i].c_str(),\n+                            v8::NewStringType::kNormal).ToLocalChecked())\n+        .FromJust();\n   }\n   process->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"execArgv\"),\n                exec_arguments);\n@@ -2262,29 +2174,33 @@ void SetupProcessObject(Environment* env,\n                              GetParentProcessId).FromJust());\n \n   // -e, --eval\n-  if (eval_string) {\n+  if (env->options()->has_eval_string) {\n     READONLY_PROPERTY(process,\n                       \"_eval\",\n-                      String::NewFromUtf8(env->isolate(), eval_string,\n+                      String::NewFromUtf8(\n+                          env->isolate(),\n+                          env->options()->eval_string.c_str(),\n                           v8::NewStringType::kNormal).ToLocalChecked());\n   }\n \n   // -p, --print\n-  if (print_eval) {\n+  if (env->options()->print_eval) {\n     READONLY_PROPERTY(process, \"_print_eval\", True(env->isolate()));\n   }\n \n   // -c, --check\n-  if (syntax_check_only) {\n+  if (env->options()->syntax_check_only) {\n     READONLY_PROPERTY(process, \"_syntax_check_only\", True(env->isolate()));\n   }\n \n   // -i, --interactive\n-  if (force_repl) {\n+  if (env->options()->force_repl) {\n     READONLY_PROPERTY(process, \"_forceRepl\", True(env->isolate()));\n   }\n \n   // -r, --require\n+  std::vector<std::string> preload_modules =\n+      std::move(env->options()->preload_modules);\n   if (!preload_modules.empty()) {\n     Local<Array> array = Array::New(env->isolate());\n     for (unsigned int i = 0; i < preload_modules.size(); ++i) {\n@@ -2302,22 +2218,23 @@ void SetupProcessObject(Environment* env,\n   }\n \n   // --no-deprecation\n-  if (no_deprecation) {\n+  // TODO(addaleax): Uncomment the commented part.\n+  if (/*env->options()->*/no_deprecation) {\n     READONLY_PROPERTY(process, \"noDeprecation\", True(env->isolate()));\n   }\n \n   // --no-warnings\n-  if (no_process_warnings) {\n+  if (env->options()->no_warnings) {\n     READONLY_PROPERTY(process, \"noProcessWarnings\", True(env->isolate()));\n   }\n \n   // --trace-warnings\n-  if (trace_warnings) {\n+  if (env->options()->trace_warnings) {\n     READONLY_PROPERTY(process, \"traceProcessWarnings\", True(env->isolate()));\n   }\n \n   // --throw-deprecation\n-  if (throw_deprecation) {\n+  if (env->options()->throw_deprecation) {\n     READONLY_PROPERTY(process, \"throwDeprecation\", True(env->isolate()));\n   }\n \n@@ -2327,35 +2244,35 @@ void SetupProcessObject(Environment* env,\n #endif  // NODE_NO_BROWSER_GLOBALS\n \n   // --prof-process\n-  if (prof_process) {\n+  if (env->options()->prof_process) {\n     READONLY_PROPERTY(process, \"profProcess\", True(env->isolate()));\n   }\n \n   // --trace-deprecation\n-  if (trace_deprecation) {\n+  if (env->options()->trace_deprecation) {\n     READONLY_PROPERTY(process, \"traceDeprecation\", True(env->isolate()));\n   }\n \n-  // TODO(refack): move the following 3 to `node_config`\n+  // TODO(refack): move the following 4 to `node_config`\n   // --inspect-brk\n-  if (debug_options.wait_for_connect()) {\n+  if (env->options()->debug_options->wait_for_connect()) {\n     READONLY_DONT_ENUM_PROPERTY(process,\n                                 \"_breakFirstLine\", True(env->isolate()));\n   }\n \n-  if (debug_options.break_node_first_line()) {\n+  if (env->options()->debug_options->break_node_first_line) {\n     READONLY_DONT_ENUM_PROPERTY(process,\n                                 \"_breakNodeFirstLine\", True(env->isolate()));\n   }\n \n   // --inspect --debug-brk\n-  if (debug_options.deprecated_invocation()) {\n+  if (env->options()->debug_options->deprecated_invocation()) {\n     READONLY_DONT_ENUM_PROPERTY(process,\n                                 \"_deprecatedDebugBrk\", True(env->isolate()));\n   }\n \n   // --debug or, --debug-brk without --inspect\n-  if (debug_options.invalid_invocation()) {\n+  if (env->options()->debug_options->invalid_invocation()) {\n     READONLY_DONT_ENUM_PROPERTY(process,\n                                 \"_invalidDebug\", True(env->isolate()));\n   }\n@@ -2379,7 +2296,7 @@ void SetupProcessObject(Environment* env,\n                                           v8::NewStringType::kInternalized,\n                                           exec_path_len).ToLocalChecked();\n   } else {\n-    exec_path_value = String::NewFromUtf8(env->isolate(), argv[0],\n+    exec_path_value = String::NewFromUtf8(env->isolate(), args[0].c_str(),\n         v8::NewStringType::kInternalized).ToLocalChecked();\n   }\n   process->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"execPath\"),\n@@ -2561,7 +2478,8 @@ void LoadEnvironment(Environment* env) {\n     get_binding_fn,\n     get_linked_binding_fn,\n     get_internal_binding_fn,\n-    Boolean::New(env->isolate(), debug_options.break_node_first_line())\n+    Boolean::New(env->isolate(),\n+                 env->options()->debug_options->break_node_first_line)\n   };\n \n   // Bootstrap internal loaders\n@@ -2742,359 +2660,8 @@ static void PrintHelp() {\n }\n \n \n-static bool ArgIsAllowed(const char* arg, const char* allowed) {\n-  for (; *arg && *allowed; arg++, allowed++) {\n-    // Like normal strcmp(), except that a '_' in `allowed` matches either a '-'\n-    // or '_' in `arg`.\n-    if (*allowed == '_') {\n-      if (!(*arg == '_' || *arg == '-'))\n-        return false;\n-    } else {\n-      if (*arg != *allowed)\n-        return false;\n-    }\n-  }\n-\n-  // \"--some-arg=val\" is allowed for \"--some-arg\"\n-  if (*arg == '=')\n-    return true;\n-\n-  // Both must be null, or one string is just a prefix of the other, not a\n-  // match.\n-  return !*arg && !*allowed;\n-}\n-\n-\n-static void CheckIfAllowedInEnv(const char* exe, bool is_env,\n-                                const char* arg) {\n-  if (!is_env)\n-    return;\n-\n-  static const char* whitelist[] = {\n-    // Node options, sorted in `node --help` order for ease of comparison.\n-    // Please, update NODE_OPTIONS section in cli.md if changed.\n-    \"--enable-fips\",\n-    \"--experimental-modules\",\n-    \"--experimental-repl-await\",\n-    \"--experimental-vm-modules\",\n-    \"--experimental-worker\",\n-    \"--force-fips\",\n-    \"--icu-data-dir\",\n-    \"--inspect\",\n-    \"--inspect-brk\",\n-    \"--inspect-port\",\n-    \"--loader\",\n-    \"--napi-modules\",\n-    \"--no-deprecation\",\n-    \"--no-force-async-hooks-checks\",\n-    \"--no-warnings\",\n-    \"--openssl-config\",\n-    \"--pending-deprecation\",\n-    \"--redirect-warnings\",\n-    \"--require\",\n-    \"--throw-deprecation\",\n-    \"--title\",\n-    \"--tls-cipher-list\",\n-    \"--trace-deprecation\",\n-    \"--trace-event-categories\",\n-    \"--trace-event-file-pattern\",\n-    \"--trace-events-enabled\",\n-    \"--trace-sync-io\",\n-    \"--trace-warnings\",\n-    \"--track-heap-objects\",\n-    \"--use-bundled-ca\",\n-    \"--use-openssl-ca\",\n-    \"--v8-pool-size\",\n-    \"--zero-fill-buffers\",\n-    \"-r\",\n-\n-    // V8 options (define with '_', which allows '-' or '_')\n-    \"--abort_on_uncaught_exception\",\n-    \"--max_old_space_size\",\n-    \"--perf_basic_prof\",\n-    \"--perf_prof\",\n-    \"--stack_trace_limit\",\n-  };\n-\n-  for (unsigned i = 0; i < arraysize(whitelist); i++) {\n-    const char* allowed = whitelist[i];\n-    if (ArgIsAllowed(arg, allowed))\n-      return;\n-  }\n-\n-  fprintf(stderr, \"%s: %s is not allowed in NODE_OPTIONS\\n\", exe, arg);\n-  exit(9);\n-}\n-\n-\n-// Parse command line arguments.\n-//\n-// argv is modified in place. exec_argv and v8_argv are out arguments that\n-// ParseArgs() allocates memory for and stores a pointer to the output\n-// vector in.  The caller should free them with delete[].\n-//\n-// On exit:\n-//\n-//  * argv contains the arguments with node and V8 options filtered out.\n-//  * exec_argv contains both node and V8 options and nothing else.\n-//  * v8_argv contains argv[0] plus any V8 options\n-static void ParseArgs(int* argc,\n-                      const char** argv,\n-                      int* exec_argc,\n-                      const char*** exec_argv,\n-                      int* v8_argc,\n-                      const char*** v8_argv,\n-                      bool is_env) {\n-  const unsigned int nargs = static_cast<unsigned int>(*argc);\n-  const char** new_exec_argv = new const char*[nargs];\n-  const char** new_v8_argv = new const char*[nargs];\n-  const char** new_argv = new const char*[nargs];\n-#if HAVE_OPENSSL\n-  bool use_bundled_ca = false;\n-  bool use_openssl_ca = false;\n-#endif  // HAVE_OPENSSL\n-\n-  for (unsigned int i = 0; i < nargs; ++i) {\n-    new_exec_argv[i] = nullptr;\n-    new_v8_argv[i] = nullptr;\n-    new_argv[i] = nullptr;\n-  }\n-\n-  // exec_argv starts with the first option, the other two start with argv[0].\n-  unsigned int new_exec_argc = 0;\n-  unsigned int new_v8_argc = 1;\n-  unsigned int new_argc = 1;\n-  new_v8_argv[0] = argv[0];\n-  new_argv[0] = argv[0];\n-\n-  unsigned int index = 1;\n-  bool short_circuit = false;\n-  while (index < nargs && argv[index][0] == '-' && !short_circuit) {\n-    const char* const arg = argv[index];\n-    unsigned int args_consumed = 1;\n-\n-    CheckIfAllowedInEnv(argv[0], is_env, arg);\n-\n-    if (debug_options.ParseOption(argv[0], arg)) {\n-      // Done, consumed by DebugOptions::ParseOption().\n-    } else if (strcmp(arg, \"--version\") == 0 || strcmp(arg, \"-v\") == 0) {\n-      printf(\"%s\\n\", NODE_VERSION);\n-      exit(0);\n-    } else if (strcmp(arg, \"--help\") == 0 || strcmp(arg, \"-h\") == 0) {\n-      PrintHelp();\n-      exit(0);\n-    } else if (strcmp(arg, \"--eval\") == 0 ||\n-               strcmp(arg, \"-e\") == 0 ||\n-               strcmp(arg, \"--print\") == 0 ||\n-               strcmp(arg, \"-pe\") == 0 ||\n-               strcmp(arg, \"-p\") == 0) {\n-      bool is_eval = strchr(arg, 'e') != nullptr;\n-      bool is_print = strchr(arg, 'p') != nullptr;\n-      print_eval = print_eval || is_print;\n-      // --eval, -e and -pe always require an argument.\n-      if (is_eval == true) {\n-        args_consumed += 1;\n-        eval_string = argv[index + 1];\n-        if (eval_string == nullptr) {\n-          fprintf(stderr, \"%s: %s requires an argument\\n\", argv[0], arg);\n-          exit(9);\n-        }\n-      } else if ((index + 1 < nargs) &&\n-                 argv[index + 1] != nullptr &&\n-                 argv[index + 1][0] != '-') {\n-        args_consumed += 1;\n-        eval_string = argv[index + 1];\n-        if (strncmp(eval_string, \"\\\\-\", 2) == 0) {\n-          // Starts with \"\\\\-\": escaped expression, drop the backslash.\n-          eval_string += 1;\n-        }\n-      }\n-    } else if (strcmp(arg, \"--require\") == 0 ||\n-               strcmp(arg, \"-r\") == 0) {\n-      const char* module = argv[index + 1];\n-      if (module == nullptr) {\n-        fprintf(stderr, \"%s: %s requires an argument\\n\", argv[0], arg);\n-        exit(9);\n-      }\n-      args_consumed += 1;\n-      preload_modules.push_back(module);\n-    } else if (strcmp(arg, \"--check\") == 0 || strcmp(arg, \"-c\") == 0) {\n-      syntax_check_only = true;\n-    } else if (strcmp(arg, \"--interactive\") == 0 || strcmp(arg, \"-i\") == 0) {\n-      force_repl = true;\n-    } else if (strcmp(arg, \"--no-deprecation\") == 0) {\n-      no_deprecation = true;\n-    } else if (strcmp(arg, \"--napi-modules\") == 0) {\n-      // no-op\n-    } else if (strcmp(arg, \"--no-warnings\") == 0) {\n-      no_process_warnings = true;\n-    } else if (strcmp(arg, \"--trace-warnings\") == 0) {\n-      trace_warnings = true;\n-    } else if (strncmp(arg, \"--redirect-warnings=\", 20) == 0) {\n-      config_warning_file = arg + 20;\n-    } else if (strcmp(arg, \"--trace-deprecation\") == 0) {\n-      trace_deprecation = true;\n-    } else if (strcmp(arg, \"--trace-sync-io\") == 0) {\n-      trace_sync_io = true;\n-    } else if (strcmp(arg, \"--no-force-async-hooks-checks\") == 0) {\n-      no_force_async_hooks_checks = true;\n-    } else if (strcmp(arg, \"--trace-events-enabled\") == 0) {\n-      if (trace_enabled_categories.empty())\n-        trace_enabled_categories = \"v8,node,node.async_hooks\";\n-    } else if (strcmp(arg, \"--trace-event-categories\") == 0) {\n-      const char* categories = argv[index + 1];\n-      if (categories == nullptr) {\n-        fprintf(stderr, \"%s: %s requires an argument\\n\", argv[0], arg);\n-        exit(9);\n-      }\n-      args_consumed += 1;\n-      trace_enabled_categories = categories;\n-    } else if (strcmp(arg, \"--trace-event-file-pattern\") == 0) {\n-      const char* file_pattern = argv[index + 1];\n-      if (file_pattern == nullptr) {\n-        fprintf(stderr, \"%s: %s requires an argument\\n\", argv[0], arg);\n-        exit(9);\n-      }\n-      args_consumed += 1;\n-      trace_file_pattern = file_pattern;\n-    } else if (strcmp(arg, \"--track-heap-objects\") == 0) {\n-      track_heap_objects = true;\n-    } else if (strcmp(arg, \"--throw-deprecation\") == 0) {\n-      throw_deprecation = true;\n-    } else if (strncmp(arg, \"--security-revert=\", 18) == 0) {\n-      const char* cve = arg + 18;\n-      Revert(cve);\n-    } else if (strncmp(arg, \"--title=\", 8) == 0) {\n-      config_process_title = arg + 8;\n-    } else if (strcmp(arg, \"--preserve-symlinks\") == 0) {\n-      config_preserve_symlinks = true;\n-    } else if (strcmp(arg, \"--preserve-symlinks-main\") == 0) {\n-      config_preserve_symlinks_main = true;\n-    } else if (strcmp(arg, \"--experimental-modules\") == 0) {\n-      config_experimental_modules = true;\n-    } else if (strcmp(arg, \"--experimental-vm-modules\") == 0) {\n-      config_experimental_vm_modules = true;\n-    } else if (strcmp(arg, \"--experimental-worker\") == 0) {\n-      config_experimental_worker = true;\n-    } else if (strcmp(arg, \"--experimental-repl-await\") == 0) {\n-      config_experimental_repl_await = true;\n-    }  else if (strcmp(arg, \"--loader\") == 0) {\n-      const char* module = argv[index + 1];\n-      if (!config_experimental_modules) {\n-        fprintf(stderr, \"%s: %s requires --experimental-modules be enabled\\n\",\n-            argv[0], arg);\n-        exit(9);\n-      }\n-      if (module == nullptr) {\n-        fprintf(stderr, \"%s: %s requires an argument\\n\", argv[0], arg);\n-        exit(9);\n-      }\n-      args_consumed += 1;\n-      config_userland_loader = module;\n-    } else if (strcmp(arg, \"--prof-process\") == 0) {\n-      prof_process = true;\n-      short_circuit = true;\n-    } else if (strcmp(arg, \"--zero-fill-buffers\") == 0) {\n-      zero_fill_all_buffers = true;\n-    } else if (strcmp(arg, \"--pending-deprecation\") == 0) {\n-      config_pending_deprecation = true;\n-    } else if (strcmp(arg, \"--v8-options\") == 0) {\n-      new_v8_argv[new_v8_argc] = \"--help\";\n-      new_v8_argc += 1;\n-    } else if (strncmp(arg, \"--v8-pool-size=\", 15) == 0) {\n-      v8_thread_pool_size = atoi(arg + 15);\n-#if HAVE_OPENSSL\n-    } else if (strncmp(arg, \"--tls-cipher-list=\", 18) == 0) {\n-      default_cipher_list = arg + 18;\n-    } else if (strncmp(arg, \"--use-openssl-ca\", 16) == 0) {\n-      ssl_openssl_cert_store = true;\n-      use_openssl_ca = true;\n-    } else if (strncmp(arg, \"--use-bundled-ca\", 16) == 0) {\n-      use_bundled_ca = true;\n-      ssl_openssl_cert_store = false;\n-#if NODE_FIPS_MODE\n-    } else if (strcmp(arg, \"--enable-fips\") == 0) {\n-      enable_fips_crypto = true;\n-    } else if (strcmp(arg, \"--force-fips\") == 0) {\n-      force_fips_crypto = true;\n-#endif /* NODE_FIPS_MODE */\n-    } else if (strncmp(arg, \"--openssl-config=\", 17) == 0) {\n-      openssl_config.assign(arg + 17);\n-#endif /* HAVE_OPENSSL */\n-#if defined(NODE_HAVE_I18N_SUPPORT)\n-    } else if (strncmp(arg, \"--icu-data-dir=\", 15) == 0) {\n-      icu_data_dir.assign(arg + 15);\n-#endif\n-    } else if (strcmp(arg, \"--expose-internals\") == 0 ||\n-               strcmp(arg, \"--expose_internals\") == 0) {\n-      config_expose_internals = true;\n-    } else if (strcmp(arg, \"-\") == 0) {\n-      break;\n-    } else if (strcmp(arg, \"--\") == 0) {\n-      index += 1;\n-      break;\n-    } else if (strcmp(arg, \"--abort-on-uncaught-exception\") == 0 ||\n-               strcmp(arg, \"--abort_on_uncaught_exception\") == 0) {\n-      abort_on_uncaught_exception = true;\n-      // Also a V8 option.  Pass through as-is.\n-      new_v8_argv[new_v8_argc] = arg;\n-      new_v8_argc += 1;\n-    } else {\n-      // V8 option.  Pass through as-is.\n-      new_v8_argv[new_v8_argc] = arg;\n-      new_v8_argc += 1;\n-    }\n-\n-    memcpy(new_exec_argv + new_exec_argc,\n-           argv + index,\n-           args_consumed * sizeof(*argv));\n-\n-    new_exec_argc += args_consumed;\n-    index += args_consumed;\n-  }\n-\n-#if HAVE_OPENSSL\n-  if (use_openssl_ca && use_bundled_ca) {\n-    fprintf(stderr,\n-            \"%s: either --use-openssl-ca or --use-bundled-ca can be used, \"\n-            \"not both\\n\",\n-            argv[0]);\n-    exit(9);\n-  }\n-#endif\n-\n-  if (eval_string != nullptr && syntax_check_only) {\n-    fprintf(stderr,\n-            \"%s: either --check or --eval can be used, not both\\n\", argv[0]);\n-    exit(9);\n-  }\n-\n-  // Copy remaining arguments.\n-  const unsigned int args_left = nargs - index;\n-\n-  if (is_env && args_left) {\n-    fprintf(stderr, \"%s: %s is not supported in NODE_OPTIONS\\n\",\n-            argv[0], argv[index]);\n-    exit(9);\n-  }\n-\n-  memcpy(new_argv + new_argc, argv + index, args_left * sizeof(*argv));\n-  new_argc += args_left;\n-\n-  *exec_argc = new_exec_argc;\n-  *exec_argv = new_exec_argv;\n-  *v8_argc = new_v8_argc;\n-  *v8_argv = new_v8_argv;\n-\n-  // Copy new_argv over argv and update argc.\n-  memcpy(argv, new_argv, new_argc * sizeof(*argv));\n-  delete[] new_argv;\n-  *argc = static_cast<int>(new_argc);\n-}\n-\n-\n static void StartInspector(Environment* env, const char* path,\n-                           DebugOptions debug_options) {\n+                           std::shared_ptr<DebugOptions> debug_options) {\n #if HAVE_INSPECTOR\n   CHECK(!env->inspector_agent()->IsListening());\n   v8_platform.StartInspector(env, path, debug_options);\n@@ -3327,26 +2894,87 @@ inline void PlatformInit() {\n #endif  // _WIN32\n }\n \n+// TODO(addaleax): Remove, both from the public API and in implementation.\n+bool no_deprecation = false;\n+#if HAVE_OPENSSL\n+bool ssl_openssl_cert_store = false;\n+#if NODE_FIPS_MODE\n+bool enable_fips_crypto = false;\n+bool force_fips_crypto = false;\n+#endif\n+#endif\n \n-void ProcessArgv(int* argc,\n-                 const char** argv,\n-                 int* exec_argc,\n-                 const char*** exec_argv,\n-                 bool is_env = false) {\n+void ProcessArgv(std::vector<std::string>* args,\n+                 std::vector<std::string>* exec_args,\n+                 bool is_env) {\n   // Parse a few arguments which are specific to Node.\n-  int v8_argc;\n-  const char** v8_argv;\n-  ParseArgs(argc, argv, exec_argc, exec_argv, &v8_argc, &v8_argv, is_env);\n+  std::vector<std::string> v8_args;\n+  std::string error;\n+  PerProcessOptionsParser::instance.Parse(\n+      args,\n+      exec_args,\n+      &v8_args,\n+      per_process_opts.get(),\n+      is_env ? kAllowedInEnvironment : kDisallowedInEnvironment,\n+      &error);\n+  if (!error.empty()) {\n+    fprintf(stderr, \"%s: %s\\n\", args->at(0).c_str(), error.c_str());\n+    exit(9);\n+  }\n+\n+  if (per_process_opts->print_version) {\n+    printf(\"%s\\n\", NODE_VERSION);\n+    exit(0);\n+  }\n+\n+  if (per_process_opts->print_help) {\n+    PrintHelp();\n+    exit(0);\n+  }\n+\n+  if (per_process_opts->print_v8_help) {\n+    V8::SetFlagsFromString(\"--help\", 6);\n+    exit(0);\n+  }\n+\n+  for (const std::string& cve : per_process_opts->security_reverts)\n+    Revert(cve.c_str());\n+\n+  // TODO(addaleax): Move this validation to the option parsers.\n+  auto env_opts = per_process_opts->per_isolate->per_env;\n+  if (!env_opts->userland_loader.empty() &&\n+      !env_opts->experimental_modules) {\n+    fprintf(stderr, \"%s: --loader requires --experimental-modules be enabled\\n\",\n+            args->at(0).c_str());\n+    exit(9);\n+  }\n+\n+  if (env_opts->syntax_check_only && env_opts->has_eval_string) {\n+    fprintf(stderr, \"%s: either --check or --eval can be used, not both\\n\",\n+            args->at(0).c_str());\n+    exit(9);\n+  }\n+\n+  if (per_process_opts->use_openssl_ca && per_process_opts->use_bundled_ca) {\n+    fprintf(stderr, \"%s: either --use-openssl-ca or --use-bundled-ca can be \"\n+                    \"used, not both\\n\",\n+            args->at(0).c_str());\n+    exit(9);\n+  }\n+\n+  if (std::find(v8_args.begin(), v8_args.end(),\n+                \"--abort-on-uncaught-exception\") != v8_args.end() ||\n+      std::find(v8_args.begin(), v8_args.end(),\n+                \"--abort_on_uncaught_exception\") != v8_args.end()) {\n+    abort_on_uncaught_exception = true;\n+  }\n \n   // TODO(bnoordhuis) Intercept --prof arguments and start the CPU profiler\n   // manually?  That would give us a little more control over its runtime\n   // behavior but it could also interfere with the user's intentions in ways\n   // we fail to anticipate.  Dillema.\n-  for (int i = 1; i < v8_argc; ++i) {\n-    if (strncmp(v8_argv[i], \"--prof\", sizeof(\"--prof\") - 1) == 0) {\n-      v8_is_profiling = true;\n-      break;\n-    }\n+  if (std::find(v8_args.begin(), v8_args.end(), \"--prof\") != v8_args.end()) {\n+    v8_is_profiling = true;\n   }\n \n #ifdef __POSIX__\n@@ -3358,28 +2986,40 @@ void ProcessArgv(int* argc,\n   }\n #endif\n \n-  // The const_cast doesn't violate conceptual const-ness.  V8 doesn't modify\n-  // the argv array or the elements it points to.\n-  if (v8_argc > 1)\n-    V8::SetFlagsFromCommandLine(&v8_argc, const_cast<char**>(v8_argv), true);\n+  std::vector<char*> v8_args_as_char_ptr(v8_args.size());\n+  if (v8_args.size() > 0) {\n+    for (size_t i = 0; i < v8_args.size(); ++i)\n+      v8_args_as_char_ptr[i] = &v8_args[i][0];\n+    int argc = v8_args.size();\n+    V8::SetFlagsFromCommandLine(&argc, &v8_args_as_char_ptr[0], true);\n+    v8_args_as_char_ptr.resize(argc);\n+  }\n \n   // Anything that's still in v8_argv is not a V8 or a node option.\n-  for (int i = 1; i < v8_argc; i++) {\n-    fprintf(stderr, \"%s: bad option: %s\\n\", argv[0], v8_argv[i]);\n+  for (size_t i = 1; i < v8_args_as_char_ptr.size(); i++) {\n+    fprintf(stderr, \"%s: bad option: %s\\n\",\n+            args->at(0).c_str(), v8_args_as_char_ptr[i]);\n   }\n-  delete[] v8_argv;\n-  v8_argv = nullptr;\n \n-  if (v8_argc > 1) {\n+  if (v8_args_as_char_ptr.size() > 1) {\n     exit(9);\n   }\n+\n+  // TODO(addaleax): Remove.\n+  zero_fill_all_buffers = per_process_opts->zero_fill_all_buffers;\n+  no_deprecation = per_process_opts->per_isolate->per_env->no_deprecation;\n+#if HAVE_OPENSSL\n+  ssl_openssl_cert_store = per_process_opts->ssl_openssl_cert_store;\n+#if NODE_FIPS_MODE\n+  enable_fips_crypto = per_process_opts->enable_fips_crypto;\n+  force_fips_crypto = per_process_opts->force_fips_crypto;\n+#endif\n+#endif\n }\n \n \n-void Init(int* argc,\n-          const char** argv,\n-          int* exec_argc,\n-          const char*** exec_argv) {\n+void Init(std::vector<std::string>* argv,\n+          std::vector<std::string>* exec_argv) {\n   // Initialize prog_start_time to get relative uptime.\n   prog_start_time = static_cast<double>(uv_now(uv_default_loop()));\n \n@@ -3396,78 +3036,80 @@ void Init(int* argc,\n   V8::SetFlagsFromString(NODE_V8_OPTIONS, sizeof(NODE_V8_OPTIONS) - 1);\n #endif\n \n+  std::shared_ptr<EnvironmentOptions> default_env_options =\n+      per_process_opts->per_isolate->per_env;\n   {\n     std::string text;\n-    config_pending_deprecation =\n+    default_env_options->pending_deprecation =\n         SafeGetenv(\"NODE_PENDING_DEPRECATION\", &text) && text[0] == '1';\n   }\n \n   // Allow for environment set preserving symlinks.\n   {\n     std::string text;\n-    config_preserve_symlinks =\n+    default_env_options->preserve_symlinks =\n         SafeGetenv(\"NODE_PRESERVE_SYMLINKS\", &text) && text[0] == '1';\n   }\n \n   {\n     std::string text;\n-    config_preserve_symlinks_main =\n+    default_env_options->preserve_symlinks_main =\n         SafeGetenv(\"NODE_PRESERVE_SYMLINKS_MAIN\", &text) && text[0] == '1';\n   }\n \n-  if (config_warning_file.empty())\n-    SafeGetenv(\"NODE_REDIRECT_WARNINGS\", &config_warning_file);\n+  if (default_env_options->redirect_warnings.empty()) {\n+    SafeGetenv(\"NODE_REDIRECT_WARNINGS\",\n+               &default_env_options->redirect_warnings);\n+  }\n \n #if HAVE_OPENSSL\n-  if (openssl_config.empty())\n-    SafeGetenv(\"OPENSSL_CONF\", &openssl_config);\n+  std::string* openssl_config = &per_process_opts->openssl_config;\n+  if (openssl_config->empty()) {\n+    SafeGetenv(\"OPENSSL_CONF\", openssl_config);\n+  }\n #endif\n \n #if !defined(NODE_WITHOUT_NODE_OPTIONS)\n   std::string node_options;\n   if (SafeGetenv(\"NODE_OPTIONS\", &node_options)) {\n-    // Smallest tokens are 2-chars (a not space and a space), plus 2 extra\n-    // pointers, for the prepended executable name, and appended NULL pointer.\n-    size_t max_len = 2 + (node_options.length() + 1) / 2;\n-    const char** argv_from_env = new const char*[max_len];\n-    int argc_from_env = 0;\n+    std::vector<std::string> env_argv;\n     // [0] is expected to be the program name, fill it in from the real argv.\n-    argv_from_env[argc_from_env++] = argv[0];\n-\n-    char* cstr = strdup(node_options.c_str());\n-    char* initptr = cstr;\n-    char* token;\n-    while ((token = strtok(initptr, \" \"))) {  // NOLINT(runtime/threadsafe_fn)\n-      initptr = nullptr;\n-      argv_from_env[argc_from_env++] = token;\n-    }\n-    argv_from_env[argc_from_env] = nullptr;\n-    int exec_argc_;\n-    const char** exec_argv_ = nullptr;\n-    ProcessArgv(&argc_from_env, argv_from_env, &exec_argc_, &exec_argv_, true);\n-    delete[] exec_argv_;\n-    delete[] argv_from_env;\n-    free(cstr);\n+    env_argv.push_back(argv->at(0));\n+\n+    // Split NODE_OPTIONS at each ' ' character.\n+    std::string::size_type index = std::string::npos;\n+    do {\n+      std::string::size_type prev_index = index;\n+      index = node_options.find(' ', index + 1);\n+      if (index - prev_index == 1) continue;\n+\n+      const std::string option = node_options.substr(prev_index + 1, index);\n+      if (!option.empty())\n+        env_argv.emplace_back(std::move(option));\n+    } while (index != std::string::npos);\n+\n+\n+    ProcessArgv(&env_argv, nullptr, true);\n   }\n #endif\n \n-  ProcessArgv(argc, argv, exec_argc, exec_argv);\n+  ProcessArgv(argv, exec_argv, false);\n \n   // Set the process.title immediately after processing argv if --title is set.\n-  if (!config_process_title.empty())\n-    uv_set_process_title(config_process_title.c_str());\n+  if (!per_process_opts->title.empty())\n+    uv_set_process_title(per_process_opts->title.c_str());\n \n #if defined(NODE_HAVE_I18N_SUPPORT)\n   // If the parameter isn't given, use the env variable.\n-  if (icu_data_dir.empty())\n-    SafeGetenv(\"NODE_ICU_DATA\", &icu_data_dir);\n+  if (per_process_opts->icu_data_dir.empty())\n+    SafeGetenv(\"NODE_ICU_DATA\", &per_process_opts->icu_data_dir);\n   // Initialize ICU.\n   // If icu_data_dir is empty here, it will load the 'minimal' data.\n-  if (!i18n::InitializeICUDirectory(icu_data_dir)) {\n+  if (!i18n::InitializeICUDirectory(per_process_opts->icu_data_dir)) {\n     fprintf(stderr,\n             \"%s: could not initialize ICU \"\n             \"(check NODE_ICU_DATA or --icu-data-dir parameters)\\n\",\n-            argv[0]);\n+            argv->at(0).c_str());\n     exit(9);\n   }\n #endif\n@@ -3478,6 +3120,27 @@ void Init(int* argc,\n   node_is_initialized = true;\n }\n \n+// TODO(addaleax): Deprecate and eventually remove this.\n+void Init(int* argc,\n+          const char** argv,\n+          int* exec_argc,\n+          const char*** exec_argv) {\n+  std::vector<std::string> argv_(argv, argv + *argc);  // NOLINT\n+  std::vector<std::string> exec_argv_;\n+\n+  Init(&argv_, &exec_argv_);\n+\n+  *argc = argv_.size();\n+  *exec_argc = exec_argv_.size();\n+  // These leak memory, because, in the original code of this function, no\n+  // extra allocations were visible. This should be okay because this function\n+  // is only supposed to be called once per process, though.\n+  *exec_argv = Malloc<const char*>(*exec_argc);\n+  for (int i = 0; i < *exec_argc; ++i)\n+    (*exec_argv)[i] = strdup(exec_argv_[i].c_str());\n+  for (int i = 0; i < *argc; ++i)\n+    argv[i] = strdup(argv_[i].c_str());\n+}\n \n void RunAtExit(Environment* env) {\n   env->RunAtExitCallbacks();\n@@ -3602,9 +3265,13 @@ Environment* CreateEnvironment(IsolateData* isolate_data,\n   Isolate* isolate = context->GetIsolate();\n   HandleScope handle_scope(isolate);\n   Context::Scope context_scope(context);\n-  auto env = new Environment(isolate_data, context,\n-                             v8_platform.GetTracingAgentWriter());\n-  env->Start(argc, argv, exec_argc, exec_argv, v8_is_profiling);\n+  // TODO(addaleax): This is a much better place for parsing per-Environment\n+  // options than the global parse call.\n+  std::vector<std::string> args(argv, argv + argc);\n+  std::vector<std::string> exec_args(exec_argv, exec_argv + exec_argc);\n+  Environment* env = new Environment(isolate_data, context,\n+                                     v8_platform.GetTracingAgentWriter());\n+  env->Start(args, exec_args, v8_is_profiling);\n   return env;\n }\n \n@@ -3657,23 +3324,27 @@ Local<Context> NewContext(Isolate* isolate,\n \n \n inline int Start(Isolate* isolate, IsolateData* isolate_data,\n-                 int argc, const char* const* argv,\n-                 int exec_argc, const char* const* exec_argv) {\n+                 const std::vector<std::string>& args,\n+                 const std::vector<std::string>& exec_args) {\n   HandleScope handle_scope(isolate);\n   Local<Context> context = NewContext(isolate);\n   Context::Scope context_scope(context);\n   Environment env(isolate_data, context, v8_platform.GetTracingAgentWriter());\n-  env.Start(argc, argv, exec_argc, exec_argv, v8_is_profiling);\n+  env.Start(args, exec_args, v8_is_profiling);\n \n-  const char* path = argc > 1 ? argv[1] : nullptr;\n-  StartInspector(&env, path, debug_options);\n+  const char* path = args.size() > 1 ? args[1].c_str() : nullptr;\n+  StartInspector(&env, path, env.options()->debug_options);\n \n-  if (debug_options.inspector_enabled() && !v8_platform.InspectorStarted(&env))\n+  if (env.options()->debug_options->inspector_enabled &&\n+      !v8_platform.InspectorStarted(&env)) {\n     return 12;  // Signal internal error.\n+  }\n \n   env.set_abort_on_uncaught_exception(abort_on_uncaught_exception);\n \n-  if (no_force_async_hooks_checks) {\n+  // TODO(addaleax): Maybe access this option directly instead of setting\n+  // a boolean member of Environment. Ditto below for trace_sync_io.\n+  if (env.options()->no_force_async_hooks_checks) {\n     env.async_hooks()->no_force_checks();\n   }\n \n@@ -3684,7 +3355,7 @@ inline int Start(Isolate* isolate, IsolateData* isolate_data,\n     env.async_hooks()->pop_async_id(1);\n   }\n \n-  env.set_trace_sync_io(trace_sync_io);\n+  env.set_trace_sync_io(env.options()->trace_sync_io);\n \n   {\n     SealHandleScope seal(isolate);\n@@ -3759,8 +3430,8 @@ Isolate* NewIsolate(ArrayBufferAllocator* allocator) {\n }\n \n inline int Start(uv_loop_t* event_loop,\n-                 int argc, const char* const* argv,\n-                 int exec_argc, const char* const* exec_argv) {\n+                 const std::vector<std::string>& args,\n+                 const std::vector<std::string>& exec_args) {\n   std::unique_ptr<ArrayBufferAllocator, decltype(&FreeArrayBufferAllocator)>\n       allocator(CreateArrayBufferAllocator(), &FreeArrayBufferAllocator);\n   Isolate* const isolate = NewIsolate(allocator.get());\n@@ -3785,11 +3456,13 @@ inline int Start(uv_loop_t* event_loop,\n             v8_platform.Platform(),\n             allocator.get()),\n         &FreeIsolateData);\n-    if (track_heap_objects) {\n+    // TODO(addaleax): This should load a real per-Isolate option, currently\n+    // this is still effectively per-process.\n+    if (isolate_data->options()->track_heap_objects) {\n       isolate->GetHeapProfiler()->StartTrackingHeapObjects(true);\n     }\n     exit_code =\n-        Start(isolate, isolate_data.get(), argc, argv, exec_argc, exec_argv);\n+        Start(isolate, isolate_data.get(), args, exec_args);\n   }\n \n   {\n@@ -3813,11 +3486,10 @@ int Start(int argc, char** argv) {\n   // Hack around with the argv pointer. Used for process.title = \"blah\".\n   argv = uv_setup_args(argc, argv);\n \n-  // This needs to run *before* V8::Initialize().  The const_cast is not\n-  // optional, in case you're wondering.\n-  int exec_argc;\n-  const char** exec_argv;\n-  Init(&argc, const_cast<const char**>(argv), &exec_argc, &exec_argv);\n+  std::vector<std::string> args(argv, argv + argc);\n+  std::vector<std::string> exec_args;\n+  // This needs to run *before* V8::Initialize().\n+  Init(&args, &exec_args);\n \n #if HAVE_OPENSSL\n   {\n@@ -3835,12 +3507,13 @@ int Start(int argc, char** argv) {\n   V8::SetEntropySource(crypto::EntropySource);\n #endif  // HAVE_OPENSSL\n \n-  v8_platform.Initialize(v8_thread_pool_size);\n+  v8_platform.Initialize(\n+      per_process_opts->v8_thread_pool_size);\n   V8::Initialize();\n   performance::performance_v8_start = PERFORMANCE_NOW();\n   v8_initialized = true;\n   const int exit_code =\n-      Start(uv_default_loop(), argc, argv, exec_argc, exec_argv);\n+      Start(uv_default_loop(), args, exec_args);\n   v8_platform.StopTracingAgent();\n   v8_initialized = false;\n   V8::Dispose();\n@@ -3853,9 +3526,6 @@ int Start(int argc, char** argv) {\n   // will never be fully cleaned up.\n   v8_platform.Dispose();\n \n-  delete[] exec_argv;\n-  exec_argv = nullptr;\n-\n   return exit_code;\n }\n "
        },
        {
            "sha": "ab82be7ac4d30f93607f9617b18ff161960fdca8",
            "filename": "src/node.h",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -199,6 +199,8 @@ typedef intptr_t ssize_t;\n \n namespace node {\n \n+// TODO(addaleax): Deprecate and remove all of these ASAP. They have been\n+// made effectively non-functional anyway.\n NODE_EXTERN extern bool no_deprecation;\n #if HAVE_OPENSSL\n NODE_EXTERN extern bool ssl_openssl_cert_store;\n@@ -208,7 +210,12 @@ NODE_EXTERN extern bool force_fips_crypto;\n # endif\n #endif\n \n+// TODO(addaleax): Officially deprecate this and replace it with something\n+// better suited for a public embedder API.\n NODE_EXTERN int Start(int argc, char* argv[]);\n+\n+// TODO(addaleax): Officially deprecate this and replace it with something\n+// better suited for a public embedder API.\n NODE_EXTERN void Init(int* argc,\n                       const char** argv,\n                       int* exec_argc,\n@@ -265,6 +272,8 @@ NODE_EXTERN IsolateData* CreateIsolateData(\n     ArrayBufferAllocator* allocator);\n NODE_EXTERN void FreeIsolateData(IsolateData* isolate_data);\n \n+// TODO(addaleax): Add an official variant using STL containers, and move\n+// per-Environment options parsing here.\n NODE_EXTERN Environment* CreateEnvironment(IsolateData* isolate_data,\n                                            v8::Local<v8::Context> context,\n                                            int argc,"
        },
        {
            "sha": "e8d306e7dd6bff37f442a385b73279000099a664",
            "filename": "src/node_buffer.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_buffer.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_buffer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -27,6 +27,7 @@\n \n namespace node {\n \n+// TODO(addaleax): Deprecate and remove this ASAP.\n extern bool zero_fill_all_buffers;\n \n namespace Buffer {"
        },
        {
            "sha": "d34269912e4713dab55c9893aa126a2343171829",
            "filename": "src/node_config.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 21,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_config.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_config.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_config.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -2,7 +2,6 @@\n #include \"node_i18n.h\"\n #include \"env-inl.h\"\n #include \"util-inl.h\"\n-#include \"node_debug_options.h\"\n \n namespace node {\n \n@@ -56,6 +55,7 @@ static void Initialize(Local<Object> target,\n \n #ifdef NODE_FIPS_MODE\n   READONLY_BOOLEAN_PROPERTY(\"fipsMode\");\n+  // TODO(addaleax): Use options parser variable instead.\n   if (force_fips_crypto)\n     READONLY_BOOLEAN_PROPERTY(\"fipsForced\");\n #endif\n@@ -72,35 +72,38 @@ static void Initialize(Local<Object> target,\n   READONLY_BOOLEAN_PROPERTY(\"hasTracing\");\n #endif\n \n-  READONLY_STRING_PROPERTY(target, \"icuDataDir\", icu_data_dir);\n+  // TODO(addaleax): This seems to be an unused, private API. Remove it?\n+  READONLY_STRING_PROPERTY(target, \"icuDataDir\",\n+      per_process_opts->icu_data_dir);\n \n #endif  // NODE_HAVE_I18N_SUPPORT\n \n-  if (config_preserve_symlinks)\n+  if (env->options()->preserve_symlinks)\n     READONLY_BOOLEAN_PROPERTY(\"preserveSymlinks\");\n-  if (config_preserve_symlinks_main)\n+  if (env->options()->preserve_symlinks_main)\n     READONLY_BOOLEAN_PROPERTY(\"preserveSymlinksMain\");\n \n-  if (config_experimental_modules) {\n+  if (env->options()->experimental_modules) {\n     READONLY_BOOLEAN_PROPERTY(\"experimentalModules\");\n-    if (!config_userland_loader.empty()) {\n-      READONLY_STRING_PROPERTY(target, \"userLoader\",  config_userland_loader);\n+    const std::string& userland_loader = env->options()->userland_loader;\n+    if (!userland_loader.empty()) {\n+      READONLY_STRING_PROPERTY(target, \"userLoader\",  userland_loader);\n     }\n   }\n \n-  if (config_experimental_vm_modules)\n+  if (env->options()->experimental_vm_modules)\n     READONLY_BOOLEAN_PROPERTY(\"experimentalVMModules\");\n \n-  if (config_experimental_worker)\n+  if (env->options()->experimental_worker)\n     READONLY_BOOLEAN_PROPERTY(\"experimentalWorker\");\n \n-  if (config_experimental_repl_await)\n+  if (env->options()->experimental_repl_await)\n     READONLY_BOOLEAN_PROPERTY(\"experimentalREPLAwait\");\n \n-  if (config_pending_deprecation)\n+  if (env->options()->pending_deprecation)\n     READONLY_BOOLEAN_PROPERTY(\"pendingDeprecation\");\n \n-  if (config_expose_internals)\n+  if (env->options()->expose_internals)\n     READONLY_BOOLEAN_PROPERTY(\"exposeInternals\");\n \n   if (env->abort_on_uncaught_exception())\n@@ -110,22 +113,25 @@ static void Initialize(Local<Object> target,\n                     \"bits\",\n                     Number::New(env->isolate(), 8 * sizeof(intptr_t)));\n \n-  if (!config_warning_file.empty()) {\n-    READONLY_STRING_PROPERTY(target, \"warningFile\", config_warning_file);\n+  const std::string& warning_file = env->options()->redirect_warnings;\n+  if (!warning_file.empty()) {\n+    READONLY_STRING_PROPERTY(target, \"warningFile\", warning_file);\n   }\n \n-  Local<Object> debugOptions = Object::New(isolate);\n-  READONLY_PROPERTY(target, \"debugOptions\", debugOptions);\n+  std::shared_ptr<DebugOptions> debug_options = env->options()->debug_options;\n+  Local<Object> debug_options_obj = Object::New(isolate);\n+  READONLY_PROPERTY(target, \"debugOptions\", debug_options_obj);\n \n-  READONLY_STRING_PROPERTY(debugOptions, \"host\", debug_options.host_name());\n+  READONLY_STRING_PROPERTY(debug_options_obj, \"host\",\n+                           debug_options->host());\n \n-  READONLY_PROPERTY(debugOptions,\n+  READONLY_PROPERTY(debug_options_obj,\n                     \"port\",\n-                    Integer::New(isolate, debug_options.port()));\n+                    Integer::New(isolate, debug_options->port()));\n \n-  READONLY_PROPERTY(debugOptions,\n+  READONLY_PROPERTY(debug_options_obj,\n                     \"inspectorEnabled\",\n-                    Boolean::New(isolate, debug_options.inspector_enabled()));\n+                    Boolean::New(isolate, debug_options->inspector_enabled));\n }  // InitConfig\n \n }  // namespace node"
        },
        {
            "sha": "b6c7bf37a3ad865d7950625ed51a556132500618",
            "filename": "src/node_constants.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 5,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_constants.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_constants.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_constants.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -51,10 +51,6 @@ namespace node {\n using v8::Local;\n using v8::Object;\n \n-#if HAVE_OPENSSL\n-const char* default_cipher_list = DEFAULT_CIPHER_LIST_CORE;\n-#endif\n-\n namespace {\n \n void DefineErrnoConstants(Local<Object> target) {\n@@ -1240,7 +1236,7 @@ void DefineCryptoConstants(Local<Object> target) {\n                               DEFAULT_CIPHER_LIST_CORE);\n   NODE_DEFINE_STRING_CONSTANT(target,\n                               \"defaultCipherList\",\n-                              default_cipher_list);\n+                              per_process_opts->tls_cipher_list.c_str());\n #endif\n   NODE_DEFINE_CONSTANT(target, INT_MAX);\n }"
        },
        {
            "sha": "6f73fb4d7d9bfc6864cb4189c77a93a58e077e3f",
            "filename": "src/node_constants.h",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_constants.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_constants.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_constants.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -66,10 +66,6 @@\n \n namespace node {\n \n-#if HAVE_OPENSSL\n-extern const char* default_cipher_list;\n-#endif\n-\n void DefineConstants(v8::Isolate* isolate, v8::Local<v8::Object> target);\n }  // namespace node\n "
        },
        {
            "sha": "11ed4a3f1928792d8a7e324b6cedc401dacf2c35",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -756,6 +756,8 @@ static X509_STORE* NewRootCertStore() {\n   if (*system_cert_path != '\\0') {\n     X509_STORE_load_locations(store, system_cert_path, nullptr);\n   }\n+  // TODO(addaleax): Replace `ssl_openssl_cert_store` with\n+  // `per_process_opts->ssl_openssl_cert_store`.\n   if (ssl_openssl_cert_store) {\n     X509_STORE_set_default_paths(store);\n   } else {\n@@ -5094,14 +5096,14 @@ void InitCryptoOnce() {\n   OPENSSL_no_config();\n \n   // --openssl-config=...\n-  if (!openssl_config.empty()) {\n+  if (!per_process_opts->openssl_config.empty()) {\n     OPENSSL_load_builtin_modules();\n #ifndef OPENSSL_NO_ENGINE\n     ENGINE_load_builtin_engines();\n #endif\n     ERR_clear_error();\n     CONF_modules_load_file(\n-        openssl_config.c_str(),\n+        per_process_opts->openssl_config.c_str(),\n         nullptr,\n         CONF_MFLAGS_DEFAULT_SECTION);\n     int err = ERR_get_error();\n@@ -5119,6 +5121,9 @@ void InitCryptoOnce() {\n #ifdef NODE_FIPS_MODE\n   /* Override FIPS settings in cnf file, if needed. */\n   unsigned long err = 0;  // NOLINT(runtime/int)\n+  // TODO(addaleax): Use commented part instead.\n+  /*if (per_process_opts->enable_fips_crypto ||\n+      per_process_opts->force_fips_crypto) {*/\n   if (enable_fips_crypto || force_fips_crypto) {\n     if (0 == FIPS_mode() && !FIPS_mode_set(1)) {\n       err = ERR_get_error();\n@@ -5181,6 +5186,7 @@ void GetFipsCrypto(const FunctionCallbackInfo<Value>& args) {\n }\n \n void SetFipsCrypto(const FunctionCallbackInfo<Value>& args) {\n+  // TODO(addaleax): Use options parser variables instead.\n   CHECK(!force_fips_crypto);\n   Environment* env = Environment::GetCurrent(args);\n   const bool enabled = FIPS_mode();"
        },
        {
            "sha": "5fc29059ddc84f3f37a8f4d7f0e6aef03b00ea30",
            "filename": "src/node_debug_options.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 142,
            "changes": 142,
            "blob_url": "https://github.com/nodejs/node/blob/92880f31da1eca98a42e0f61708b10d9d8d83955/src%2Fnode_debug_options.cc",
            "raw_url": "https://github.com/nodejs/node/raw/92880f31da1eca98a42e0f61708b10d9d8d83955/src%2Fnode_debug_options.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_debug_options.cc?ref=92880f31da1eca98a42e0f61708b10d9d8d83955",
            "patch": "@@ -1,142 +0,0 @@\n-#include \"node_debug_options.h\"\n-\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"util.h\"\n-\n-namespace node {\n-\n-namespace {\n-const int default_inspector_port = 9229;\n-\n-inline std::string remove_brackets(const std::string& host) {\n-  if (!host.empty() && host.front() == '[' && host.back() == ']')\n-    return host.substr(1, host.size() - 2);\n-  else\n-    return host;\n-}\n-\n-int parse_and_validate_port(const std::string& port) {\n-  char* endptr;\n-  errno = 0;\n-  const long result = strtol(port.c_str(), &endptr, 10);  // NOLINT(runtime/int)\n-  if (errno != 0 || *endptr != '\\0'||\n-      (result != 0 && result < 1024) || result > 65535) {\n-    fprintf(stderr, \"Debug port must be 0 or in range 1024 to 65535.\\n\");\n-    exit(12);\n-  }\n-  return static_cast<int>(result);\n-}\n-\n-std::pair<std::string, int> split_host_port(const std::string& arg) {\n-  // remove_brackets only works if no port is specified\n-  // so if it has an effect only an IPv6 address was specified\n-  std::string host = remove_brackets(arg);\n-  if (host.length() < arg.length())\n-    return {host, -1};\n-\n-  size_t colon = arg.rfind(':');\n-  if (colon == std::string::npos) {\n-    // Either a port number or a host name.  Assume that\n-    // if it's not all decimal digits, it's a host name.\n-    for (char c : arg) {\n-      if (c < '0' || c > '9') {\n-        return {arg, -1};\n-      }\n-    }\n-    return {\"\", parse_and_validate_port(arg)};\n-  }\n-  // host and port found\n-  return std::make_pair(remove_brackets(arg.substr(0, colon)),\n-                        parse_and_validate_port(arg.substr(colon + 1)));\n-}\n-\n-}  // namespace\n-\n-DebugOptions::DebugOptions() :\n-                               inspector_enabled_(false),\n-                               deprecated_debug_(false),\n-                               break_first_line_(false),\n-                               break_node_first_line_(false),\n-                               host_name_(\"127.0.0.1\"), port_(-1) { }\n-\n-bool DebugOptions::ParseOption(const char* argv0, const std::string& option) {\n-  bool has_argument = false;\n-  std::string option_name;\n-  std::string argument;\n-\n-  auto pos = option.find(\"=\");\n-  if (pos == std::string::npos) {\n-    option_name = option;\n-  } else {\n-    option_name = option.substr(0, pos);\n-    argument = option.substr(pos + 1);\n-\n-    if (argument.length() > 0)\n-      has_argument = true;\n-    else\n-      argument.clear();\n-  }\n-\n-  // Note that --debug-port and --debug-brk in conjunction with --inspect\n-  // work but are undocumented.\n-  // --debug is no longer valid.\n-  // Ref: https://github.com/nodejs/node/issues/12630\n-  // Ref: https://github.com/nodejs/node/pull/12949\n-  if (option_name == \"--inspect\") {\n-    inspector_enabled_ = true;\n-  } else if (option_name == \"--debug\") {\n-    deprecated_debug_ = true;\n-  } else if (option_name == \"--inspect-brk\") {\n-    inspector_enabled_ = true;\n-    break_first_line_ = true;\n-  } else if (option_name == \"--inspect-brk-node\") {\n-    inspector_enabled_ = true;\n-    break_node_first_line_ = true;\n-  } else if (option_name == \"--debug-brk\") {\n-    break_first_line_ = true;\n-    deprecated_debug_ = true;\n-  } else if (option_name == \"--debug-port\" ||\n-             option_name == \"--inspect-port\") {\n-    if (!has_argument) {\n-      fprintf(stderr, \"%s: %s requires an argument\\n\",\n-              argv0, option.c_str());\n-      exit(9);\n-    }\n-  } else {\n-    return false;\n-  }\n-\n-#if !HAVE_INSPECTOR\n-  if (inspector_enabled_) {\n-    fprintf(stderr,\n-            \"Inspector support is not available with this Node.js build\\n\");\n-  }\n-  inspector_enabled_ = false;\n-  return false;\n-#endif\n-\n-  // argument can be specified for *any* option to specify host:port\n-  if (has_argument) {\n-    std::pair<std::string, int> host_port = split_host_port(argument);\n-    if (!host_port.first.empty()) {\n-      host_name_ = host_port.first;\n-    }\n-    if (host_port.second >= 0) {\n-      port_ = host_port.second;\n-    }\n-  }\n-\n-  return true;\n-}\n-\n-int DebugOptions::port() const {\n-  int port = port_;\n-  if (port < 0) {\n-    port = default_inspector_port;\n-  }\n-  return port;\n-}\n-\n-}  // namespace node"
        },
        {
            "sha": "98922ab099ac775bc9c2ec910b03a777a33eba71",
            "filename": "src/node_debug_options.h",
            "status": "removed",
            "additions": 0,
            "deletions": 42,
            "changes": 42,
            "blob_url": "https://github.com/nodejs/node/blob/92880f31da1eca98a42e0f61708b10d9d8d83955/src%2Fnode_debug_options.h",
            "raw_url": "https://github.com/nodejs/node/raw/92880f31da1eca98a42e0f61708b10d9d8d83955/src%2Fnode_debug_options.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_debug_options.h?ref=92880f31da1eca98a42e0f61708b10d9d8d83955",
            "patch": "@@ -1,42 +0,0 @@\n-#ifndef SRC_NODE_DEBUG_OPTIONS_H_\n-#define SRC_NODE_DEBUG_OPTIONS_H_\n-\n-#include <string>\n-\n-// Forward declaration to break recursive dependency chain with src/env.h.\n-namespace node {\n-\n-class DebugOptions {\n- public:\n-  DebugOptions();\n-  bool ParseOption(const char* argv0, const std::string& option);\n-  bool inspector_enabled() const { return inspector_enabled_; }\n-  bool deprecated_invocation() const {\n-    return deprecated_debug_ &&\n-      inspector_enabled_ &&\n-      break_first_line_;\n-  }\n-  bool invalid_invocation() const {\n-    return deprecated_debug_ && !inspector_enabled_;\n-  }\n-  bool wait_for_connect() const {\n-    return break_first_line_ || break_node_first_line_;\n-  }\n-  std::string host_name() const { return host_name_; }\n-  void set_host_name(std::string host_name) { host_name_ = host_name; }\n-  int port() const;\n-  void set_port(int port) { port_ = port; }\n-  bool break_node_first_line() const { return break_node_first_line_; }\n-\n- private:\n-  bool inspector_enabled_;\n-  bool deprecated_debug_;\n-  bool break_first_line_;\n-  bool break_node_first_line_;\n-  std::string host_name_;\n-  int port_;\n-};\n-\n-}  // namespace node\n-\n-#endif  // SRC_NODE_DEBUG_OPTIONS_H_"
        },
        {
            "sha": "7faa5e57ef25fb37a9334bebac1466c635bc32ee",
            "filename": "src/node_i18n.h",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_i18n.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_i18n.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_i18n.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -31,8 +31,6 @@\n \n namespace node {\n \n-extern std::string icu_data_dir;  // NOLINT(runtime/string)\n-\n namespace i18n {\n \n bool InitializeICUDirectory(const std::string& path);"
        },
        {
            "sha": "60630953c78c18c2653ee2b48b30f5c6d696d533",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 3,
            "deletions": 63,
            "changes": 66,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -33,7 +33,6 @@\n #include \"v8.h\"\n #include \"tracing/trace_event.h\"\n #include \"node_perf_common.h\"\n-#include \"node_debug_options.h\"\n #include \"node_api.h\"\n \n #include <stdint.h>\n@@ -171,67 +170,10 @@ struct sockaddr;\n \n namespace node {\n \n-// Set in node.cc by ParseArgs with the value of --openssl-config.\n-// Used in node_crypto.cc when initializing OpenSSL.\n-extern std::string openssl_config;\n-\n-// Set in node.cc by ParseArgs when --preserve-symlinks is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/module.js\n-extern bool config_preserve_symlinks;\n-\n-// Set in node.cc by ParseArgs when --preserve-symlinks-main is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/module.js\n-extern bool config_preserve_symlinks_main;\n-\n-// Set in node.cc by ParseArgs when --experimental-modules is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/module.js\n-extern bool config_experimental_modules;\n-\n-// Set in node.cc by ParseArgs when --experimental-vm-modules is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/vm.js\n-extern bool config_experimental_vm_modules;\n-\n-// Set in node.cc by ParseArgs when --experimental-worker is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by the module loader.\n-extern bool config_experimental_worker;\n-\n-// Set in node.cc by ParseArgs when --experimental-repl-await is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/repl.js.\n-extern bool config_experimental_repl_await;\n-\n-// Set in node.cc by ParseArgs when --loader is used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/internal/bootstrap/node.js\n-extern std::string config_userland_loader;\n-\n-// Set in node.cc by ParseArgs when --expose-internals or --expose_internals is\n-// used.\n-// Used in node_config.cc to set a constant on process.binding('config')\n-// that is used by lib/internal/bootstrap/node.js\n-extern bool config_expose_internals;\n-\n-// Set in node.cc by ParseArgs when --redirect-warnings= is used.\n-// Used to redirect warning output to a file rather than sending\n-// it to stderr.\n-extern std::string config_warning_file;  // NOLINT(runtime/string)\n-\n-// Set in node.cc by ParseArgs when --pending-deprecation or\n-// NODE_PENDING_DEPRECATION is used\n-extern bool config_pending_deprecation;\n-\n // Tells whether it is safe to call v8::Isolate::GetCurrent().\n extern bool v8_initialized;\n \n-// Contains initial debug options.\n-// Set in node.cc.\n-// Used in node_config.cc.\n-extern node::DebugOptions debug_options;\n+extern std::shared_ptr<PerProcessOptions> per_process_opts;\n \n // Forward declaration\n class Environment;\n@@ -415,10 +357,8 @@ inline v8::Local<v8::Value> FillGlobalStatsArray(Environment* env,\n void SetupBootstrapObject(Environment* env,\n                           v8::Local<v8::Object> bootstrapper);\n void SetupProcessObject(Environment* env,\n-                        int argc,\n-                        const char* const* argv,\n-                        int exec_argc,\n-                        const char* const* exec_argv);\n+                        const std::vector<std::string>& args,\n+                        const std::vector<std::string>& exec_args);\n \n // Call _register<module_name> functions for all of\n // the built-in modules. Because built-in modules don't"
        },
        {
            "sha": "e610cd50d114368268c600dd17cd0029e1b79f96",
            "filename": "src/node_options-inl.h",
            "status": "added",
            "additions": 422,
            "deletions": 0,
            "changes": 422,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_options-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_options-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_options-inl.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -0,0 +1,422 @@\n+#ifndef SRC_NODE_OPTIONS_INL_H_\n+#define SRC_NODE_OPTIONS_INL_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"node_options.h\"\n+#include \"util.h\"\n+#include <cstdlib>\n+\n+namespace node {\n+\n+PerIsolateOptions* PerProcessOptions::get_per_isolate_options() {\n+  return per_isolate.get();\n+}\n+\n+DebugOptions* EnvironmentOptions::get_debug_options() {\n+  return debug_options.get();\n+}\n+\n+EnvironmentOptions* PerIsolateOptions::get_per_env_options() {\n+  return per_env.get();\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddOption(const std::string& name,\n+                                       bool Options::* field,\n+                                       OptionEnvvarSettings env_setting) {\n+  options_.emplace(name, OptionInfo {\n+    kBoolean,\n+    std::make_shared<SimpleOptionField<bool>>(field),\n+    env_setting\n+  });\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddOption(const std::string& name,\n+                                       int64_t Options::* field,\n+                                       OptionEnvvarSettings env_setting) {\n+  options_.emplace(name, OptionInfo {\n+    kInteger,\n+    std::make_shared<SimpleOptionField<int64_t>>(field),\n+    env_setting\n+  });\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddOption(const std::string& name,\n+                                       std::string Options::* field,\n+                                       OptionEnvvarSettings env_setting) {\n+  options_.emplace(name, OptionInfo {\n+    kString,\n+    std::make_shared<SimpleOptionField<std::string>>(field),\n+    env_setting\n+  });\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddOption(\n+    const std::string& name,\n+    std::vector<std::string> Options::* field,\n+    OptionEnvvarSettings env_setting) {\n+  options_.emplace(name, OptionInfo {\n+    kStringList,\n+    std::make_shared<SimpleOptionField<std::vector<std::string>>>(field),\n+    env_setting\n+  });\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddOption(const std::string& name,\n+                                       HostPort Options::* field,\n+                                       OptionEnvvarSettings env_setting) {\n+  options_.emplace(name, OptionInfo {\n+    kHostPort,\n+    std::make_shared<SimpleOptionField<HostPort>>(field),\n+    env_setting\n+  });\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddOption(const std::string& name, NoOp no_op_tag,\n+                                       OptionEnvvarSettings env_setting) {\n+  options_.emplace(name, OptionInfo { kNoOp, nullptr, env_setting });\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddOption(const std::string& name,\n+                                       V8Option v8_option_tag,\n+                                       OptionEnvvarSettings env_setting) {\n+  options_.emplace(name, OptionInfo { kV8Option, nullptr, env_setting });\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddAlias(const std::string& from,\n+                                      const std::string& to) {\n+  aliases_[from] = { to };\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddAlias(const std::string& from,\n+                                      const std::vector<std::string>& to) {\n+  aliases_[from] = to;\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::AddAlias(\n+    const std::string& from,\n+    const std::initializer_list<std::string>& to) {\n+  AddAlias(from, std::vector<std::string>(to));\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::Implies(const std::string& from,\n+                                     const std::string& to) {\n+  auto it = options_.find(to);\n+  CHECK_NE(it, options_.end());\n+  CHECK_EQ(it->second.type, kBoolean);\n+  implications_.emplace(from, Implication {\n+    std::static_pointer_cast<OptionField<bool>>(it->second.field), true\n+  });\n+}\n+\n+template <typename Options>\n+void OptionsParser<Options>::ImpliesNot(const std::string& from,\n+                                        const std::string& to) {\n+  auto it = options_.find(to);\n+  CHECK_NE(it, options_.end());\n+  CHECK_EQ(it->second.type, kBoolean);\n+  implications_.emplace(from, Implication {\n+    std::static_pointer_cast<OptionField<bool>>(it->second.field), false\n+  });\n+}\n+\n+template <typename Options>\n+template <typename OriginalField, typename ChildOptions>\n+auto OptionsParser<Options>::Convert(\n+    std::shared_ptr<OriginalField> original,\n+    ChildOptions* (Options::* get_child)()) {\n+  // If we have a field on ChildOptions, and we want to access it from an\n+  // Options instance, we call get_child() on the original Options and then\n+  // access it, i.e. this class implements a kind of function chaining.\n+  struct AdaptedField : BaseOptionField {\n+    void* LookupImpl(Options* options) const override {\n+      return original->LookupImpl((options->*get_child)());\n+    }\n+\n+    AdaptedField(\n+        std::shared_ptr<OriginalField> original,\n+        ChildOptions* (Options::* get_child)())\n+          : original(original), get_child(get_child) {}\n+\n+    std::shared_ptr<OriginalField> original;\n+    ChildOptions* (Options::* get_child)();\n+  };\n+\n+  return std::shared_ptr<BaseOptionField>(\n+      new AdaptedField(original, get_child));\n+}\n+template <typename Options>\n+template <typename ChildOptions>\n+auto OptionsParser<Options>::Convert(\n+    typename OptionsParser<ChildOptions>::OptionInfo original,\n+    ChildOptions* (Options::* get_child)()) {\n+  return OptionInfo {\n+    original.type,\n+    Convert(original.field, get_child),\n+    original.env_setting\n+  };\n+}\n+\n+template <typename Options>\n+template <typename ChildOptions>\n+auto OptionsParser<Options>::Convert(\n+    typename OptionsParser<ChildOptions>::Implication original,\n+    ChildOptions* (Options::* get_child)()) {\n+  return Implication {\n+    std::static_pointer_cast<OptionField<bool>>(\n+        Convert(original.target_field, get_child)),\n+    original.target_value\n+  };\n+}\n+\n+template <typename Options>\n+template <typename ChildOptions>\n+void OptionsParser<Options>::Insert(\n+    OptionsParser<ChildOptions>* child_options_parser,\n+    ChildOptions* (Options::* get_child)()) {\n+  aliases_.insert(child_options_parser->aliases_.begin(),\n+                  child_options_parser->aliases_.end());\n+\n+  for (const auto& pair : child_options_parser->options_)\n+    options_.emplace(pair.first, Convert(pair.second, get_child));\n+\n+  for (const auto& pair : child_options_parser->implications_)\n+    implications_.emplace(pair.first, Convert(pair.second, get_child));\n+}\n+\n+inline std::string NotAllowedInEnvErr(const std::string& arg) {\n+  return arg + \" is not allowed in NODE_OPTIONS\";\n+}\n+\n+inline std::string RequiresArgumentErr(const std::string& arg) {\n+  return arg + \" requires an argument\";\n+}\n+\n+// We store some of the basic information around a single Parse call inside\n+// this struct, to separate storage of command line arguments and their\n+// handling. In particular, this makes it easier to introduce 'synthetic'\n+// arguments that get inserted by expanding option aliases.\n+struct ArgsInfo {\n+  // Generally, the idea here is that the first entry in `*underlying` stores\n+  // the \"0th\" argument (the program name), then `synthetic_args` are inserted,\n+  // followed by the remainder of `*underlying`.\n+  std::vector<std::string>* underlying;\n+  std::vector<std::string> synthetic_args;\n+\n+  std::vector<std::string>* exec_args;\n+\n+  ArgsInfo(std::vector<std::string>* args,\n+           std::vector<std::string>* exec_args)\n+    : underlying(args), exec_args(exec_args) {}\n+\n+  size_t remaining() const {\n+    // -1 to account for the program name.\n+    return underlying->size() - 1 + synthetic_args.size();\n+  }\n+\n+  bool empty() const { return remaining() == 0; }\n+  const std::string& program_name() const { return underlying->at(0); }\n+\n+  std::string& first() {\n+    return synthetic_args.empty() ? underlying->at(1) : synthetic_args.front();\n+  }\n+\n+  std::string pop_first() {\n+    std::string ret = std::move(first());\n+    if (synthetic_args.empty()) {\n+      // Only push arguments to `exec_args` that were also originally passed\n+      // on the command line (i.e. not generated through alias expansion).\n+      // '--' is a special case here since its purpose is to end `exec_argv`,\n+      // which is why we do not include it.\n+      if (exec_args != nullptr && first() != \"--\")\n+        exec_args->push_back(ret);\n+      underlying->erase(underlying->begin() + 1);\n+    } else {\n+      synthetic_args.erase(synthetic_args.begin());\n+    }\n+    return ret;\n+  }\n+};\n+\n+template <typename Options>\n+void OptionsParser<Options>::Parse(\n+    std::vector<std::string>* const orig_args,\n+    std::vector<std::string>* const exec_args,\n+    std::vector<std::string>* const v8_args,\n+    Options* const options,\n+    OptionEnvvarSettings required_env_settings,\n+    std::string* const error) {\n+  ArgsInfo args(orig_args, exec_args);\n+\n+  // The first entry is the process name. Make sure it ends up in the V8 argv,\n+  // since V8::SetFlagsFromCommandLine() expects that to hold true for that\n+  // array as well.\n+  if (v8_args->empty())\n+    v8_args->push_back(args.program_name());\n+\n+  while (!args.empty() && error->empty()) {\n+    if (args.first().size() <= 1 || args.first()[0] != '-') break;\n+\n+    // We know that we're either going to consume this\n+    // argument or fail completely.\n+    const std::string arg = args.pop_first();\n+\n+    if (arg == \"--\") {\n+      if (required_env_settings == kAllowedInEnvironment)\n+        *error = NotAllowedInEnvErr(\"--\");\n+      break;\n+    }\n+\n+    // Only allow --foo=bar notation for options starting with double dashes.\n+    // (E.g. -e=a is not allowed as shorthand for --eval=a, which would\n+    // otherwise be the result of alias expansion.)\n+    const std::string::size_type equals_index =\n+        arg[0] == '-' && arg[1] == '-' ? arg.find('=') : std::string::npos;\n+    std::string name =\n+      equals_index == std::string::npos ? arg : arg.substr(0, equals_index);\n+\n+    // Store the 'original name' of the argument. This name differs from\n+    // 'name' in that it contains a possible '=' sign and is not affected\n+    // by alias expansion.\n+    std::string original_name = name;\n+    if (equals_index != std::string::npos)\n+      original_name += '=';\n+\n+    {\n+      auto it = aliases_.end();\n+      // Expand aliases:\n+      // - If `name` can be found in `aliases_`.\n+      // - If `name` + '=' can be found in `aliases_`.\n+      // - If `name` + \" <arg>\" can be found in `aliases_`, and we have\n+      //   a subsequent argument that does not start with '-' itself.\n+      while ((it = aliases_.find(name)) != aliases_.end() ||\n+             (equals_index != std::string::npos &&\n+              (it = aliases_.find(name + '=')) != aliases_.end()) ||\n+             (!args.empty() &&\n+                 !args.first().empty() &&\n+                 args.first()[0] != '-' &&\n+              (it = aliases_.find(name + \" <arg>\")) != aliases_.end())) {\n+        const std::string prev_name = std::move(name);\n+        const std::vector<std::string>& expansion = it->second;\n+\n+        // Use the first entry in the expansion as the new 'name'.\n+        name = expansion.front();\n+\n+        if (expansion.size() > 1) {\n+          // The other arguments, if any, are going to be handled later.\n+          args.synthetic_args.insert(\n+              args.synthetic_args.begin(),\n+              expansion.begin() + 1,\n+              expansion.end());\n+        }\n+\n+        if (name == prev_name) break;\n+      }\n+    }\n+\n+    auto it = options_.find(name);\n+\n+    if (it == options_.end()) {\n+      // We would assume that this is a V8 option if neither we nor any child\n+      // parser knows about it, so we convert - to _ for\n+      // canonicalization (since V8 accepts both) and look up again in order\n+      // to find a match.\n+      // TODO(addaleax): Make the canonicalization unconditional, i.e. allow\n+      // both - and _ in Node's own options as well.\n+      std::string::size_type index = 2;  // Start after initial '--'.\n+      while ((index = name.find('-', index + 1)) != std::string::npos)\n+        name[index] = '_';\n+      it = options_.find(name);\n+    }\n+\n+    if ((it == options_.end() ||\n+         it->second.env_setting == kDisallowedInEnvironment) &&\n+        required_env_settings == kAllowedInEnvironment) {\n+      *error = NotAllowedInEnvErr(original_name);\n+      break;\n+    }\n+\n+    if (it == options_.end()) {\n+      v8_args->push_back(arg);\n+      continue;\n+    }\n+\n+    {\n+      auto implications = implications_.equal_range(name);\n+      for (auto it = implications.first; it != implications.second; ++it)\n+        *it->second.target_field->Lookup(options) = it->second.target_value;\n+    }\n+\n+    const OptionInfo& info = it->second;\n+    std::string value;\n+    if (info.type != kBoolean && info.type != kNoOp && info.type != kV8Option) {\n+      if (equals_index != std::string::npos) {\n+        value = arg.substr(equals_index + 1);\n+        if (value.empty()) {\n+        missing_argument:\n+          *error = RequiresArgumentErr(original_name);\n+          break;\n+        }\n+      } else {\n+        if (args.empty())\n+          goto missing_argument;\n+\n+        value = args.pop_first();\n+\n+        if (!value.empty() && value[0] == '-') {\n+          goto missing_argument;\n+        } else {\n+          if (!value.empty() && value[0] == '\\\\' && value[1] == '-')\n+            value = value.substr(1);  // Treat \\- as escaping an -.\n+        }\n+      }\n+    }\n+\n+    switch (info.type) {\n+      case kBoolean:\n+        *std::static_pointer_cast<OptionField<bool>>(info.field)\n+            ->Lookup(options) = true;\n+        break;\n+      case kInteger:\n+        *std::static_pointer_cast<OptionField<int64_t>>(info.field)\n+            ->Lookup(options) = std::atoll(value.c_str());\n+        break;\n+      case kString:\n+        *std::static_pointer_cast<OptionField<std::string>>(info.field)\n+            ->Lookup(options) = value;\n+        break;\n+      case kStringList:\n+        std::static_pointer_cast<OptionField<std::vector<std::string>>>(\n+            info.field)->Lookup(options)->emplace_back(std::move(value));\n+        break;\n+      case kHostPort:\n+        std::static_pointer_cast<OptionField<HostPort>>(info.field)\n+            ->Lookup(options)->Update(SplitHostPort(value, error));\n+        break;\n+      case kNoOp:\n+        break;\n+      case kV8Option:\n+        v8_args->push_back(arg);\n+        break;\n+      default:\n+        UNREACHABLE();\n+    }\n+  }\n+}\n+\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#endif  // SRC_NODE_OPTIONS_INL_H_"
        },
        {
            "sha": "b10de9ef28ab9c1859af4bc035f517432964d1cf",
            "filename": "src/node_options.cc",
            "status": "added",
            "additions": 219,
            "deletions": 0,
            "changes": 219,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_options.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_options.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_options.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -0,0 +1,219 @@\n+#include \"node_options-inl.h\"\n+#include <errno.h>\n+\n+namespace node {\n+\n+DebugOptionsParser::DebugOptionsParser() {\n+  AddOption(\"--inspect-port\", &DebugOptions::host_port,\n+            kAllowedInEnvironment);\n+  AddAlias(\"--debug-port\", \"--inspect-port\");\n+\n+  AddOption(\"--inspect\", &DebugOptions::inspector_enabled,\n+            kAllowedInEnvironment);\n+  AddAlias(\"--inspect=\", { \"--inspect-port\", \"--inspect\" });\n+\n+  AddOption(\"--debug\", &DebugOptions::deprecated_debug);\n+  AddAlias(\"--debug=\", { \"--inspect-port\", \"--debug\" });\n+\n+  AddOption(\"--inspect-brk\", &DebugOptions::break_first_line,\n+            kAllowedInEnvironment);\n+  Implies(\"--inspect-brk\", \"--inspect\");\n+  AddAlias(\"--inspect-brk=\", { \"--inspect-port\", \"--inspect-brk\" });\n+\n+  AddOption(\"--inspect-brk-node\", &DebugOptions::break_node_first_line);\n+  Implies(\"--inspect-brk-node\", \"--inspect\");\n+  AddAlias(\"--inspect-brk-node=\", { \"--inspect-port\", \"--inspect-brk-node\" });\n+\n+  AddOption(\"--debug-brk\", &DebugOptions::break_first_line);\n+  Implies(\"--debug-brk\", \"--debug\");\n+  AddAlias(\"--debug-brk=\", { \"--inspect-port\", \"--debug-brk\" });\n+}\n+\n+DebugOptionsParser DebugOptionsParser::instance;\n+\n+EnvironmentOptionsParser::EnvironmentOptionsParser() {\n+  AddOption(\"--experimental-modules\", &EnvironmentOptions::experimental_modules,\n+            kAllowedInEnvironment);\n+  AddOption(\"--experimental-repl-await\",\n+            &EnvironmentOptions::experimental_repl_await,\n+            kAllowedInEnvironment);\n+  AddOption(\"--experimental-vm-modules\",\n+            &EnvironmentOptions::experimental_vm_modules,\n+            kAllowedInEnvironment);\n+  AddOption(\"--experimental-worker\", &EnvironmentOptions::experimental_worker,\n+            kAllowedInEnvironment);\n+  AddOption(\"--expose-internals\", &EnvironmentOptions::expose_internals);\n+  // TODO(addaleax): Remove this when adding -/_ canonicalization to the parser.\n+  AddAlias(\"--expose_internals\", \"--expose-internals\");\n+  AddOption(\"--loader\", &EnvironmentOptions::userland_loader,\n+            kAllowedInEnvironment);\n+  AddOption(\"--no-deprecation\", &EnvironmentOptions::no_deprecation,\n+            kAllowedInEnvironment);\n+  AddOption(\"--no-force-async-hooks-checks\",\n+            &EnvironmentOptions::no_force_async_hooks_checks,\n+            kAllowedInEnvironment);\n+  AddOption(\"--no-warnings\", &EnvironmentOptions::no_warnings,\n+            kAllowedInEnvironment);\n+  AddOption(\"--pending-deprecation\", &EnvironmentOptions::pending_deprecation,\n+            kAllowedInEnvironment);\n+  AddOption(\"--preserve-symlinks\", &EnvironmentOptions::preserve_symlinks);\n+  AddOption(\"--preserve-symlinks-main\",\n+            &EnvironmentOptions::preserve_symlinks_main);\n+  AddOption(\"--prof-process\", &EnvironmentOptions::prof_process);\n+  AddOption(\"--redirect-warnings\", &EnvironmentOptions::redirect_warnings,\n+            kAllowedInEnvironment);\n+  AddOption(\"--throw-deprecation\", &EnvironmentOptions::throw_deprecation,\n+            kAllowedInEnvironment);\n+  AddOption(\"--trace-deprecation\", &EnvironmentOptions::trace_deprecation,\n+            kAllowedInEnvironment);\n+  AddOption(\"--trace-sync-io\", &EnvironmentOptions::trace_sync_io,\n+            kAllowedInEnvironment);\n+  AddOption(\"--trace-warnings\", &EnvironmentOptions::trace_warnings,\n+            kAllowedInEnvironment);\n+\n+  AddOption(\"--check\", &EnvironmentOptions::syntax_check_only);\n+  AddAlias(\"-c\", \"--check\");\n+  // This option is only so that we can tell --eval with an empty string from\n+  // no eval at all. Having it not start with a dash makes it inaccessible\n+  // from the parser itself, but available for using Implies().\n+  // TODO(addaleax): When moving --help over to something generated from the\n+  // programmatic descriptions, this will need some special care.\n+  // (See also [ssl_openssl_cert_store] below.)\n+  AddOption(\"[has_eval_string]\", &EnvironmentOptions::has_eval_string);\n+  AddOption(\"--eval\", &EnvironmentOptions::eval_string);\n+  Implies(\"--eval\", \"[has_eval_string]\");\n+  AddOption(\"--print\", &EnvironmentOptions::print_eval);\n+  AddAlias(\"-e\", \"--eval\");\n+  AddAlias(\"--print <arg>\", \"-pe\");\n+  AddAlias(\"-pe\", { \"--print\", \"--eval\" });\n+  AddAlias(\"-p\", \"--print\");\n+  AddOption(\"--require\", &EnvironmentOptions::preload_modules,\n+            kAllowedInEnvironment);\n+  AddAlias(\"-r\", \"--require\");\n+  AddOption(\"--interactive\", &EnvironmentOptions::force_repl);\n+  AddAlias(\"-i\", \"--interactive\");\n+\n+  AddOption(\"--napi-modules\", NoOp {}, kAllowedInEnvironment);\n+\n+  Insert(&DebugOptionsParser::instance,\n+         &EnvironmentOptions::get_debug_options);\n+}\n+\n+EnvironmentOptionsParser EnvironmentOptionsParser::instance;\n+\n+PerIsolateOptionsParser::PerIsolateOptionsParser() {\n+  AddOption(\"--track-heap-objects\", &PerIsolateOptions::track_heap_objects,\n+            kAllowedInEnvironment);\n+\n+  // Explicitly add some V8 flags to mark them as allowed in NODE_OPTIONS.\n+  AddOption(\"--abort_on_uncaught_exception\", V8Option {},\n+            kAllowedInEnvironment);\n+  AddOption(\"--max_old_space_size\", V8Option {}, kAllowedInEnvironment);\n+  AddOption(\"--perf_basic_prof\", V8Option {}, kAllowedInEnvironment);\n+  AddOption(\"--perf_prof\", V8Option {}, kAllowedInEnvironment);\n+  AddOption(\"--stack_trace_limit\", V8Option {}, kAllowedInEnvironment);\n+\n+  Insert(&EnvironmentOptionsParser::instance,\n+         &PerIsolateOptions::get_per_env_options);\n+}\n+\n+PerIsolateOptionsParser PerIsolateOptionsParser::instance;\n+\n+PerProcessOptionsParser::PerProcessOptionsParser() {\n+  AddOption(\"--title\", &PerProcessOptions::title, kAllowedInEnvironment);\n+  AddOption(\"--trace-event-categories\",\n+            &PerProcessOptions::trace_event_categories,\n+            kAllowedInEnvironment);\n+  AddOption(\"--trace-event-file-pattern\",\n+            &PerProcessOptions::trace_event_file_pattern,\n+            kAllowedInEnvironment);\n+  AddAlias(\"--trace-events-enabled\", {\n+    \"--trace-event-categories\", \"v8,node,node.async_hooks\" });\n+  AddOption(\"--v8-pool-size\", &PerProcessOptions::v8_thread_pool_size,\n+            kAllowedInEnvironment);\n+  AddOption(\"--zero-fill-buffers\", &PerProcessOptions::zero_fill_all_buffers,\n+            kAllowedInEnvironment);\n+\n+  AddOption(\"--security-reverts\", &PerProcessOptions::security_reverts);\n+  AddOption(\"--help\", &PerProcessOptions::print_help);\n+  AddAlias(\"-h\", \"--help\");\n+  AddOption(\"--version\", &PerProcessOptions::print_version);\n+  AddAlias(\"-v\", \"--version\");\n+  AddOption(\"--v8-options\", &PerProcessOptions::print_v8_help);\n+\n+#ifdef NODE_HAVE_I18N_SUPPORT\n+  AddOption(\"--icu-data-dir\", &PerProcessOptions::icu_data_dir,\n+            kAllowedInEnvironment);\n+#endif\n+\n+#if HAVE_OPENSSL\n+  AddOption(\"--openssl-config\", &PerProcessOptions::openssl_config,\n+            kAllowedInEnvironment);\n+  AddOption(\"--tls-cipher-list\", &PerProcessOptions::tls_cipher_list,\n+            kAllowedInEnvironment);\n+  AddOption(\"--use-openssl-ca\", &PerProcessOptions::use_openssl_ca,\n+            kAllowedInEnvironment);\n+  AddOption(\"--use-bundled-ca\", &PerProcessOptions::use_bundled_ca,\n+            kAllowedInEnvironment);\n+  // Similar to [has_eval_string] above, except that the separation between\n+  // this and use_openssl_ca only exists for option validation after parsing.\n+  // This is not ideal.\n+  AddOption(\"[ssl_openssl_cert_store]\",\n+            &PerProcessOptions::ssl_openssl_cert_store);\n+  Implies(\"--use-openssl-ca\", \"[ssl_openssl_cert_store]\");\n+  ImpliesNot(\"--use-bundled-ca\", \"[ssl_openssl_cert_store]\");\n+#if NODE_FIPS_MODE\n+  AddOption(\"--enable-fips\", &PerProcessOptions::enable_fips_crypto,\n+            kAllowedInEnvironment);\n+  AddOption(\"--force-fips\", &PerProcessOptions::force_fips_crypto,\n+            kAllowedInEnvironment);\n+#endif\n+#endif\n+\n+  Insert(&PerIsolateOptionsParser::instance,\n+         &PerProcessOptions::get_per_isolate_options);\n+}\n+\n+PerProcessOptionsParser PerProcessOptionsParser::instance;\n+\n+inline std::string RemoveBrackets(const std::string& host) {\n+  if (!host.empty() && host.front() == '[' && host.back() == ']')\n+    return host.substr(1, host.size() - 2);\n+  else\n+    return host;\n+}\n+\n+inline int ParseAndValidatePort(const std::string& port, std::string* error) {\n+  char* endptr;\n+  errno = 0;\n+  const long result = strtol(port.c_str(), &endptr, 10);  // NOLINT(runtime/int)\n+  if (errno != 0 || *endptr != '\\0'||\n+      (result != 0 && result < 1024) || result > 65535) {\n+    *error = \"Port must be 0 or in range 1024 to 65535.\";\n+  }\n+  return static_cast<int>(result);\n+}\n+\n+HostPort SplitHostPort(const std::string& arg, std::string* error) {\n+  // remove_brackets only works if no port is specified\n+  // so if it has an effect only an IPv6 address was specified.\n+  std::string host = RemoveBrackets(arg);\n+  if (host.length() < arg.length())\n+    return HostPort { host, -1 };\n+\n+  size_t colon = arg.rfind(':');\n+  if (colon == std::string::npos) {\n+    // Either a port number or a host name.  Assume that\n+    // if it's not all decimal digits, it's a host name.\n+    for (char c : arg) {\n+      if (c < '0' || c > '9') {\n+        return HostPort { arg, -1 };\n+      }\n+    }\n+    return HostPort { \"\", ParseAndValidatePort(arg, error) };\n+  }\n+  // Host and port found:\n+  return HostPort { RemoveBrackets(arg.substr(0, colon)),\n+                    ParseAndValidatePort(arg.substr(colon + 1), error) };\n+}\n+}  // namespace node"
        },
        {
            "sha": "957e2b729d9ff44e04af8fd9cef39e0111d03e83",
            "filename": "src/node_options.h",
            "status": "added",
            "additions": 356,
            "deletions": 0,
            "changes": 356,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_options.h",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_options.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_options.h?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -0,0 +1,356 @@\n+#ifndef SRC_NODE_OPTIONS_H_\n+#define SRC_NODE_OPTIONS_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include <string>\n+#include <vector>\n+#include <unordered_map>\n+#include <memory>\n+#include \"node_constants.h\"\n+\n+namespace node {\n+\n+struct HostPort {\n+  std::string host_name;\n+  int port;\n+\n+  void Update(const HostPort& other) {\n+    if (!other.host_name.empty()) host_name = other.host_name;\n+    if (other.port >= 0) port = other.port;\n+  }\n+};\n+\n+// These options are currently essentially per-Environment, but it can be nice\n+// to keep them separate since they are a group of options applying to a very\n+// specific part of Node. It might also make more sense for them to be\n+// per-Isolate, rather than per-Environment.\n+class DebugOptions {\n+ public:\n+  bool inspector_enabled = false;\n+  bool deprecated_debug = false;\n+  bool break_first_line = false;\n+  bool break_node_first_line = false;\n+  HostPort host_port = {\"127.0.0.1\", -1};\n+  enum { kDefaultInspectorPort = 9229 };\n+\n+  bool deprecated_invocation() const {\n+    return deprecated_debug &&\n+      inspector_enabled &&\n+      break_first_line;\n+  }\n+\n+  bool invalid_invocation() const {\n+    return deprecated_debug && !inspector_enabled;\n+  }\n+\n+  bool wait_for_connect() const {\n+    return break_first_line || break_node_first_line;\n+  }\n+\n+  const std::string& host() {\n+    return host_port.host_name;\n+  }\n+\n+  int port() {\n+    return host_port.port < 0 ? kDefaultInspectorPort : host_port.port;\n+  }\n+};\n+\n+class EnvironmentOptions {\n+ public:\n+  std::shared_ptr<DebugOptions> debug_options { new DebugOptions() };\n+  bool experimental_modules = false;\n+  bool experimental_repl_await = false;\n+  bool experimental_vm_modules = false;\n+  bool experimental_worker = false;\n+  bool expose_internals = false;\n+  bool no_deprecation = false;\n+  bool no_force_async_hooks_checks = false;\n+  bool no_warnings = false;\n+  bool pending_deprecation = false;\n+  bool preserve_symlinks = false;\n+  bool preserve_symlinks_main = false;\n+  bool prof_process = false;\n+  std::string redirect_warnings;\n+  bool throw_deprecation = false;\n+  bool trace_deprecation = false;\n+  bool trace_sync_io = false;\n+  bool trace_warnings = false;\n+  std::string userland_loader;\n+\n+  bool syntax_check_only = false;\n+  bool has_eval_string = false;\n+  std::string eval_string;\n+  bool print_eval = false;\n+  bool force_repl = false;\n+\n+  std::vector<std::string> preload_modules;\n+\n+  std::vector<std::string> user_argv;\n+\n+  inline DebugOptions* get_debug_options();\n+};\n+\n+class PerIsolateOptions {\n+ public:\n+  std::shared_ptr<EnvironmentOptions> per_env { new EnvironmentOptions() };\n+  bool track_heap_objects = false;\n+\n+  inline EnvironmentOptions* get_per_env_options();\n+};\n+\n+class PerProcessOptions {\n+ public:\n+  std::shared_ptr<PerIsolateOptions> per_isolate { new PerIsolateOptions() };\n+\n+  std::string title;\n+  std::string trace_event_categories;\n+  std::string trace_event_file_pattern = \"node_trace.${rotation}.log\";\n+  int64_t v8_thread_pool_size = 4;\n+  bool zero_fill_all_buffers = false;\n+\n+  std::vector<std::string> security_reverts;\n+  bool print_help = false;\n+  bool print_v8_help = false;\n+  bool print_version = false;\n+\n+#ifdef NODE_HAVE_I18N_SUPPORT\n+  std::string icu_data_dir;\n+#endif\n+\n+  // TODO(addaleax): Some of these could probably be per-Environment.\n+#if HAVE_OPENSSL\n+  std::string openssl_config;\n+  std::string tls_cipher_list = DEFAULT_CIPHER_LIST_CORE;\n+#ifdef NODE_OPENSSL_CERT_STORE\n+  bool ssl_openssl_cert_store = true;\n+#else\n+  bool ssl_openssl_cert_store = false;\n+#endif\n+  bool use_openssl_ca = false;\n+  bool use_bundled_ca = false;\n+#if NODE_FIPS_MODE\n+  bool enable_fips_crypto = false;\n+  bool force_fips_crypto = false;\n+#endif\n+#endif\n+\n+  inline PerIsolateOptions* get_per_isolate_options();\n+};\n+\n+// The actual options parser, as opposed to the structs containing them:\n+\n+HostPort SplitHostPort(const std::string& arg, std::string* error);\n+\n+enum OptionEnvvarSettings {\n+  kAllowedInEnvironment,\n+  kDisallowedInEnvironment\n+};\n+\n+enum OptionType {\n+  kNoOp,\n+  kV8Option,\n+  kBoolean,\n+  kInteger,\n+  kString,\n+  kHostPort,\n+  kStringList,\n+};\n+\n+template <typename Options>\n+class OptionsParser {\n+ public:\n+  virtual ~OptionsParser() {}\n+\n+  typedef Options TargetType;\n+\n+  struct NoOp {};\n+  struct V8Option {};\n+\n+  // TODO(addaleax): A lot of the `std::string` usage here could be reduced\n+  // to simple `const char*`s if it's reasonable to expect the values to be\n+  // known at compile-time.\n+\n+  // These methods add a single option to the parser. Optionally, it can be\n+  // specified whether the option should be allowed from environment variable\n+  // sources (i.e. NODE_OPTIONS).\n+  void AddOption(const std::string& name,\n+                 bool Options::* field,\n+                 OptionEnvvarSettings env_setting = kDisallowedInEnvironment);\n+  void AddOption(const std::string& name,\n+                 int64_t Options::* field,\n+                 OptionEnvvarSettings env_setting = kDisallowedInEnvironment);\n+  void AddOption(const std::string& name,\n+                 std::string Options::* field,\n+                 OptionEnvvarSettings env_setting = kDisallowedInEnvironment);\n+  void AddOption(const std::string& name,\n+                 std::vector<std::string> Options::* field,\n+                 OptionEnvvarSettings env_setting = kDisallowedInEnvironment);\n+  void AddOption(const std::string& name,\n+                 HostPort Options::* field,\n+                 OptionEnvvarSettings env_setting = kDisallowedInEnvironment);\n+  void AddOption(const std::string& name,\n+                 NoOp no_op_tag,\n+                 OptionEnvvarSettings env_setting = kDisallowedInEnvironment);\n+  void AddOption(const std::string& name,\n+                 V8Option v8_option_tag,\n+                 OptionEnvvarSettings env_setting = kDisallowedInEnvironment);\n+\n+  // Adds aliases. An alias can be of the form \"--option-a\" -> \"--option-b\",\n+  // or have a more complex group expansion, like\n+  //   \"--option-a\" -> { \"--option-b\", \"--harmony-foobar\", \"--eval\", \"42\" }\n+  // If `from` has the form \"--option-a=\", the alias will only be expanded if\n+  // the option is presented in that form (i.e. with a '=').\n+  // If `from` has the form \"--option-a <arg>\", the alias will only be expanded\n+  // if the option has a non-option argument (not starting with -) following it.\n+  void AddAlias(const std::string& from, const std::string& to);\n+  void AddAlias(const std::string& from, const std::vector<std::string>& to);\n+  void AddAlias(const std::string& from,\n+                const std::initializer_list<std::string>& to);\n+\n+  // Add implications from some arbitary option to a boolean one, either\n+  // in a way that makes `from` set `to` to true or to false.\n+  void Implies(const std::string& from, const std::string& to);\n+  void ImpliesNot(const std::string& from, const std::string& to);\n+\n+  // Insert options from another options parser into this one, along with\n+  // a method that yields the target options type from this parser's options\n+  // type.\n+  template <typename ChildOptions>\n+  void Insert(OptionsParser<ChildOptions>* child_options_parser,\n+              ChildOptions* (Options::* get_child)());\n+\n+  // Parse a sequence of options into an options struct, a list of\n+  // arguments that were parsed as options, a list of unknown/JS engine options,\n+  // and leave the remainder in the input `args` vector.\n+  //\n+  // For example, an `args` input of\n+  //\n+  //   node --foo --harmony-bar --fizzle=42 -- /path/to/cow moo\n+  //\n+  // expands as\n+  //\n+  // - `args` -> { \"node\", \"/path/to/cow\", \"moo\" }\n+  // - `exec_args` -> { \"--foo\", \"--harmony-bar\", \"--fizzle=42\" }\n+  // - `v8_args` -> `{ \"node\", \"--harmony-bar\" }\n+  // - `options->foo == true`, `options->fizzle == 42`.\n+  //\n+  // If `*error` is set, the result of the parsing should be discarded and the\n+  // contents of any of the argument vectors should be considered undefined.\n+  virtual void Parse(std::vector<std::string>* const args,\n+                     std::vector<std::string>* const exec_args,\n+                     std::vector<std::string>* const v8_args,\n+                     Options* const options,\n+                     OptionEnvvarSettings required_env_settings,\n+                     std::string* const error);\n+\n+ private:\n+  // We support the wide variety of different option types by remembering\n+  // how to access them, given a certain `Options` struct.\n+\n+  // Represents a field within `Options`.\n+  class BaseOptionField {\n+   public:\n+    virtual ~BaseOptionField() {}\n+    virtual void* LookupImpl(Options* options) const = 0;\n+  };\n+\n+  // Represents a field of type T within `Options`.\n+  template <typename T>\n+  class OptionField : public BaseOptionField {\n+   public:\n+    typedef T Type;\n+\n+    T* Lookup(Options* options) const {\n+      return static_cast<T*>(this->LookupImpl(options));\n+    }\n+  };\n+\n+  // Represents a field of type T withing `Options` that can be looked up\n+  // as a C++ member field.\n+  template <typename T>\n+  class SimpleOptionField : public OptionField<T> {\n+   public:\n+    explicit SimpleOptionField(T Options::* field) : field_(field) {}\n+    void* LookupImpl(Options* options) const override {\n+      return static_cast<void*>(&(options->*field_));\n+    }\n+\n+   private:\n+    T Options::* field_;\n+  };\n+\n+  // An option consists of:\n+  // - A type.\n+  // - A way to store/access the property value.\n+  // - The information of whether it may occur in an env var or not.\n+  struct OptionInfo {\n+    OptionType type;\n+    std::shared_ptr<BaseOptionField> field;\n+    OptionEnvvarSettings env_setting;\n+  };\n+\n+  // An implied option is composed of the information on where to store a\n+  // specific boolean value (if another specific option is encountered).\n+  struct Implication {\n+    std::shared_ptr<OptionField<bool>> target_field;\n+    bool target_value;\n+  };\n+\n+  // These are helpers that make `Insert()` support properties of other\n+  // options structs, if we know how to access them.\n+  template <typename OriginalField, typename ChildOptions>\n+  static auto Convert(\n+      std::shared_ptr<OriginalField> original,\n+      ChildOptions* (Options::* get_child)());\n+  template <typename ChildOptions>\n+  static auto Convert(\n+      typename OptionsParser<ChildOptions>::OptionInfo original,\n+      ChildOptions* (Options::* get_child)());\n+  template <typename ChildOptions>\n+  static auto Convert(\n+      typename OptionsParser<ChildOptions>::Implication original,\n+      ChildOptions* (Options::* get_child)());\n+\n+  std::unordered_map<std::string, OptionInfo> options_;\n+  std::unordered_map<std::string, std::vector<std::string>> aliases_;\n+  std::unordered_multimap<std::string, Implication> implications_;\n+\n+  template <typename OtherOptions>\n+  friend class OptionsParser;\n+};\n+\n+class DebugOptionsParser : public OptionsParser<DebugOptions> {\n+ public:\n+  DebugOptionsParser();\n+\n+  static DebugOptionsParser instance;\n+};\n+\n+class EnvironmentOptionsParser : public OptionsParser<EnvironmentOptions> {\n+ public:\n+  EnvironmentOptionsParser();\n+\n+  static EnvironmentOptionsParser instance;\n+};\n+\n+class PerIsolateOptionsParser : public OptionsParser<PerIsolateOptions> {\n+ public:\n+  PerIsolateOptionsParser();\n+\n+  static PerIsolateOptionsParser instance;\n+};\n+\n+class PerProcessOptionsParser : public OptionsParser<PerProcessOptions> {\n+ public:\n+  PerProcessOptionsParser();\n+\n+  static PerProcessOptionsParser instance;\n+};\n+\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#endif  // SRC_NODE_OPTIONS_H_"
        },
        {
            "sha": "80deddedde6ff41acff6b67a5574e324c1cf522a",
            "filename": "src/node_worker.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_worker.cc",
            "raw_url": "https://github.com/nodejs/node/raw/29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7/src%2Fnode_worker.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_worker.cc?ref=29a71bae40ffa0bbc8ba6b2bdf051a09987da7f7",
            "patch": "@@ -104,7 +104,9 @@ Worker::Worker(Environment* env, Local<Object> wrap)\n     env_->set_worker_context(this);\n     env_->set_thread_id(thread_id_);\n \n-    env_->Start(0, nullptr, 0, nullptr, env->profiler_idle_notifier_started());\n+    env_->Start(std::vector<std::string>{},\n+                std::vector<std::string>{},\n+                env->profiler_idle_notifier_started());\n   }\n \n   // The new isolate won't be bothered on this thread again."
        }
    ],
    "stats": {
        "total": 2243,
        "additions": 1354,
        "deletions": 889
    }
}