{
    "author": "addaleax",
    "message": "src: clean up zlib write code\n\nSplit the existing `Write()` method into one that takes care\nof translating the arguments from JS to C++, and a non-static\nmethod for the actual write operations, as well as some minor\nstylistic drive-by fixes.\n\nPR-URL: https://github.com/nodejs/node/pull/23183\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "1fd99b4ac7f73f46017b459d9a8b99fcb37bcf93",
    "files": [
        {
            "sha": "5def50d3b9dceba52d44bfc0f8c248d284a1461b",
            "filename": "src/node_zlib.cc",
            "status": "modified",
            "additions": 42,
            "deletions": 38,
            "changes": 80,
            "blob_url": "https://github.com/nodejs/node/blob/1fd99b4ac7f73f46017b459d9a8b99fcb37bcf93/src%2Fnode_zlib.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1fd99b4ac7f73f46017b459d9a8b99fcb37bcf93/src%2Fnode_zlib.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_zlib.cc?ref=1fd99b4ac7f73f46017b459d9a8b99fcb37bcf93",
            "patch": "@@ -138,24 +138,15 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   // write(flush, in, in_off, in_len, out, out_off, out_len)\n   template <bool async>\n   static void Write(const FunctionCallbackInfo<Value>& args) {\n+    Environment* env = Environment::GetCurrent(args);\n+    Local<Context> context = env->context();\n     CHECK_EQ(args.Length(), 7);\n \n-    ZCtx* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n-    CHECK(ctx->init_done_ && \"write before init\");\n-    CHECK(ctx->mode_ != NONE && \"already finalized\");\n-\n-    CHECK_EQ(false, ctx->write_in_progress_ && \"write already in progress\");\n-    CHECK_EQ(false, ctx->pending_close_ && \"close is pending\");\n-    ctx->write_in_progress_ = true;\n-    ctx->Ref();\n+    uint32_t in_off, in_len, out_off, out_len, flush;\n+    char* in;\n+    char* out;\n \n     CHECK_EQ(false, args[0]->IsUndefined() && \"must provide flush value\");\n-\n-    Environment* env = ctx->env();\n-    Local<Context> context = env->context();\n-\n-    unsigned int flush;\n     if (!args[0]->Uint32Value(context).To(&flush)) return;\n \n     if (flush != Z_NO_FLUSH &&\n@@ -167,56 +158,69 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n       CHECK(0 && \"Invalid flush value\");\n     }\n \n-    AllocScope alloc_scope(ctx);\n-\n-    Bytef* in;\n-    Bytef* out;\n-    uint32_t in_off, in_len, out_off, out_len;\n-\n     if (args[1]->IsNull()) {\n       // just a flush\n       in = nullptr;\n       in_len = 0;\n       in_off = 0;\n     } else {\n       CHECK(Buffer::HasInstance(args[1]));\n-      Local<Object> in_buf;\n-      in_buf = args[1]->ToObject(context).ToLocalChecked();\n+      Local<Object> in_buf = args[1].As<Object>();\n       if (!args[2]->Uint32Value(context).To(&in_off)) return;\n       if (!args[3]->Uint32Value(context).To(&in_len)) return;\n \n       CHECK(Buffer::IsWithinBounds(in_off, in_len, Buffer::Length(in_buf)));\n-      in = reinterpret_cast<Bytef *>(Buffer::Data(in_buf) + in_off);\n+      in = Buffer::Data(in_buf) + in_off;\n     }\n \n     CHECK(Buffer::HasInstance(args[4]));\n-    Local<Object> out_buf = args[4]->ToObject(context).ToLocalChecked();\n+    Local<Object> out_buf = args[4].As<Object>();\n     if (!args[5]->Uint32Value(context).To(&out_off)) return;\n     if (!args[6]->Uint32Value(context).To(&out_len)) return;\n     CHECK(Buffer::IsWithinBounds(out_off, out_len, Buffer::Length(out_buf)));\n-    out = reinterpret_cast<Bytef *>(Buffer::Data(out_buf) + out_off);\n+    out = Buffer::Data(out_buf) + out_off;\n+\n+    ZCtx* ctx;\n+    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n+\n+    ctx->Write<async>(flush, in, in_len, out, out_len);\n+  }\n+\n+  template <bool async>\n+  void Write(uint32_t flush,\n+             char* in, uint32_t in_len,\n+             char* out, uint32_t out_len) {\n+    AllocScope alloc_scope(this);\n+\n+    CHECK(init_done_ && \"write before init\");\n+    CHECK(mode_ != NONE && \"already finalized\");\n+\n+    CHECK_EQ(false, write_in_progress_);\n+    CHECK_EQ(false, pending_close_);\n+    write_in_progress_ = true;\n+    Ref();\n \n-    ctx->strm_.avail_in = in_len;\n-    ctx->strm_.next_in = in;\n-    ctx->strm_.avail_out = out_len;\n-    ctx->strm_.next_out = out;\n-    ctx->flush_ = flush;\n+    strm_.avail_in = in_len;\n+    strm_.next_in = reinterpret_cast<Bytef*>(in);\n+    strm_.avail_out = out_len;\n+    strm_.next_out = reinterpret_cast<Bytef*>(out);\n+    flush_ = flush;\n \n     if (!async) {\n       // sync version\n-      env->PrintSyncTrace();\n-      ctx->DoThreadPoolWork();\n-      if (ctx->CheckError()) {\n-        ctx->write_result_[0] = ctx->strm_.avail_out;\n-        ctx->write_result_[1] = ctx->strm_.avail_in;\n-        ctx->write_in_progress_ = false;\n+      env()->PrintSyncTrace();\n+      DoThreadPoolWork();\n+      if (CheckError()) {\n+        write_result_[0] = strm_.avail_out;\n+        write_result_[1] = strm_.avail_in;\n+        write_in_progress_ = false;\n       }\n-      ctx->Unref();\n+      Unref();\n       return;\n     }\n \n     // async version\n-    ctx->ScheduleWork();\n+    ScheduleWork();\n   }\n \n   // thread pool!"
        }
    ],
    "stats": {
        "total": 80,
        "additions": 42,
        "deletions": 38
    }
}