{
    "author": "danbev",
    "message": "src: refactor emit before/after/promiseResolve\n\nCurrently EmitBefore, EmitAfter, EmitPromiseResolve are very similar.\nThis commit suggests extracting the code they have in common to a new\nfunction to reduce code duplication.\n\nPR-URL: https://github.com/nodejs/node/pull/19295\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "861285abb5dbf23e5ce14d0695da468976cad478",
    "files": [
        {
            "sha": "83882d9f80571016dabff4353dcf783e6bfb70e6",
            "filename": "src/async_wrap.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 21,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/861285abb5dbf23e5ce14d0695da468976cad478/src%2Fasync_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/861285abb5dbf23e5ce14d0695da468976cad478/src%2Fasync_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.cc?ref=861285abb5dbf23e5ce14d0695da468976cad478",
            "patch": "@@ -162,19 +162,25 @@ static void DestroyAsyncIdsCallback(void* arg) {\n }\n \n \n-void AsyncWrap::EmitPromiseResolve(Environment* env, double async_id) {\n+void Emit(Environment* env, double async_id, AsyncHooks::Fields type,\n+          Local<Function> fn) {\n   AsyncHooks* async_hooks = env->async_hooks();\n \n-  if (async_hooks->fields()[AsyncHooks::kPromiseResolve] == 0)\n+  if (async_hooks->fields()[type] == 0)\n     return;\n \n   Local<Value> async_id_value = Number::New(env->isolate(), async_id);\n-  Local<Function> fn = env->async_hooks_promise_resolve_function();\n   FatalTryCatch try_catch(env);\n   USE(fn->Call(env->context(), Undefined(env->isolate()), 1, &async_id_value));\n }\n \n \n+void AsyncWrap::EmitPromiseResolve(Environment* env, double async_id) {\n+  Emit(env, async_id, AsyncHooks::kPromiseResolve,\n+       env->async_hooks_promise_resolve_function());\n+}\n+\n+\n void AsyncWrap::EmitTraceEventBefore() {\n   switch (provider_type()) {\n #define V(PROVIDER)                                                           \\\n@@ -192,15 +198,8 @@ void AsyncWrap::EmitTraceEventBefore() {\n \n \n void AsyncWrap::EmitBefore(Environment* env, double async_id) {\n-  AsyncHooks* async_hooks = env->async_hooks();\n-\n-  if (async_hooks->fields()[AsyncHooks::kBefore] == 0)\n-    return;\n-\n-  Local<Value> async_id_value = Number::New(env->isolate(), async_id);\n-  Local<Function> fn = env->async_hooks_before_function();\n-  FatalTryCatch try_catch(env);\n-  USE(fn->Call(env->context(), Undefined(env->isolate()), 1, &async_id_value));\n+  Emit(env, async_id, AsyncHooks::kBefore,\n+       env->async_hooks_before_function());\n }\n \n \n@@ -221,17 +220,10 @@ void AsyncWrap::EmitTraceEventAfter() {\n \n \n void AsyncWrap::EmitAfter(Environment* env, double async_id) {\n-  AsyncHooks* async_hooks = env->async_hooks();\n-\n-  if (async_hooks->fields()[AsyncHooks::kAfter] == 0)\n-    return;\n-\n   // If the user's callback failed then the after() hooks will be called at the\n   // end of _fatalException().\n-  Local<Value> async_id_value = Number::New(env->isolate(), async_id);\n-  Local<Function> fn = env->async_hooks_after_function();\n-  FatalTryCatch try_catch(env);\n-  USE(fn->Call(env->context(), Undefined(env->isolate()), 1, &async_id_value));\n+  Emit(env, async_id, AsyncHooks::kAfter,\n+       env->async_hooks_after_function());\n }\n \n class PromiseWrap : public AsyncWrap {"
        }
    ],
    "stats": {
        "total": 34,
        "additions": 13,
        "deletions": 21
    }
}