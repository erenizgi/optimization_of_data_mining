{
    "author": "targos",
    "message": "deps: cherry-pick a8f6869 from upstream V8\n\nOriginal commit message:\n\n    [debug] Fully implement Debug::ArchiveDebug and Debug::RestoreDebug.\n\n    I have a project that embeds V8 and uses a single `Isolate` from multiple\n    threads. The program runs just fine, but sometimes the inspector doesn't\n    stop on the correct line after stepping over a statement that switches\n    threads behind the scenes, even though the original thread is restored by\n    the time the next statement is executed.\n\n    After some digging, I discovered that the `Debug::ArchiveDebug` and\n    `Debug::RestoreDebug` methods, which should be responsible for\n    saving/restoring this `ThreadLocal` information when switching threads,\n    currently don't do anything.\n\n    This commit implements those methods using MemCopy, in the style of other\n    Archive/Restore methods in the V8 codebase.\n\n    Related: https://groups.google.com/forum/#!topic/v8-users/_Qf2rwljRk8\n\n    Note: I believe my employer, Meteor Development Group, has previously\n    signed the CLA using the group email address google-contrib@meteor.com.\n\n    R=yangguo@chromium.org,jgruber@chromium.org\n    CC=info@bnoordhuis.nl\n\n    Bug: v8:7230\n    Change-Id: Id517c873eb81cd53f7216c7efd441b956cf7f943\n    Reviewed-on: https://chromium-review.googlesource.com/833260\n    Commit-Queue: Yang Guo <yangguo@chromium.org>\n    Reviewed-by: Yang Guo <yangguo@chromium.org>\n    Cr-Commit-Position: refs/heads/master@{#54902}\n\nRefs: https://github.com/v8/v8/commit/a8f6869177685cfb9c199c454a86f4698c260515\n\nPR-URL: https://github.com/nodejs/node/pull/21983\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "a3f258c7693fd76fc26edc8c9d5b67f260eb755d",
    "files": [
        {
            "sha": "594b43df3cc89c88430da8a702c6f910a45f9fe0",
            "filename": "common.gypi",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/common.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/common.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/common.gypi?ref=a3f258c7693fd76fc26edc8c9d5b67f260eb755d",
            "patch": "@@ -29,7 +29,7 @@\n \n     # Reset this number to 0 on major V8 upgrades.\n     # Increment by one for each non-official patch applied to deps/v8.\n-    'v8_embedder_string': '-node.7',\n+    'v8_embedder_string': '-node.8',\n \n     # Enable disassembler for `--print-code` v8 options\n     'v8_enable_disassembler': 1,"
        },
        {
            "sha": "6179e2230d8011025fa3202327071c5b05fee86f",
            "filename": "deps/v8/AUTHORS",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FAUTHORS?ref=a3f258c7693fd76fc26edc8c9d5b67f260eb755d",
            "patch": "@@ -32,6 +32,7 @@ Facebook, Inc. <*@fb.com>\n Facebook, Inc. <*@oculus.com>\n Vewd Software AS <*@vewd.com>\n Groupon <*@groupon.com>\n+Meteor Development Group <*@meteor.com>\n Cloudflare, Inc. <*@cloudflare.com>\n \n Aaron Bieber <deftly@gmail.com>\n@@ -49,6 +50,7 @@ Andrei Kashcha <anvaka@gmail.com>\n Anna Henningsen <anna@addaleax.net>\n Bangfu Tao <bangfu.tao@samsung.com>\n Ben Coe <ben@npmjs.com>\n+Ben Newman <ben@meteor.com>\n Ben Noordhuis <info@bnoordhuis.nl>\n Benjamin Tan <demoneaux@gmail.com>\n Bert Belder <bertbelder@gmail.com>"
        },
        {
            "sha": "3877f156efac34279a9f55c0d335468330867380",
            "filename": "deps/v8/src/debug/debug.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 6,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.cc?ref=a3f258c7693fd76fc26edc8c9d5b67f260eb755d",
            "patch": "@@ -355,19 +355,31 @@ void Debug::ThreadInit() {\n \n \n char* Debug::ArchiveDebug(char* storage) {\n-  // Simply reset state. Don't archive anything.\n-  ThreadInit();\n+  MemCopy(storage, reinterpret_cast<char*>(&thread_local_),\n+          ArchiveSpacePerThread());\n   return storage + ArchiveSpacePerThread();\n }\n \n-\n char* Debug::RestoreDebug(char* storage) {\n-  // Simply reset state. Don't restore anything.\n-  ThreadInit();\n+  MemCopy(reinterpret_cast<char*>(&thread_local_), storage,\n+          ArchiveSpacePerThread());\n+\n+  // Enter the debugger.\n+  DebugScope debug_scope(this);\n+\n+  // Clear any one-shot breakpoints that may have been set by the other\n+  // thread, and reapply breakpoints for this thread.\n+  ClearOneShot();\n+\n+  if (thread_local_.last_step_action_ != StepNone) {\n+    // Reset the previous step action for this thread.\n+    PrepareStep(thread_local_.last_step_action_);\n+  }\n+\n   return storage + ArchiveSpacePerThread();\n }\n \n-int Debug::ArchiveSpacePerThread() { return 0; }\n+int Debug::ArchiveSpacePerThread() { return sizeof(ThreadLocal); }\n \n void Debug::Iterate(RootVisitor* v) {\n   v->VisitRootPointer(Root::kDebug, nullptr, &thread_local_.return_value_);"
        },
        {
            "sha": "13844769c1434955b8c65b762cce771a360cc7f5",
            "filename": "deps/v8/src/debug/debug.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.h?ref=a3f258c7693fd76fc26edc8c9d5b67f260eb755d",
            "patch": "@@ -314,6 +314,7 @@ class Debug {\n   static int ArchiveSpacePerThread();\n   void FreeThreadResources() { }\n   void Iterate(RootVisitor* v);\n+  void InitThread(const ExecutionAccess& lock) { ThreadInit(); }\n \n   bool CheckExecutionState() { return is_active() && break_id() != 0; }\n "
        },
        {
            "sha": "0fb333c1f37572e688560aa7de7f6e478364b6b6",
            "filename": "deps/v8/src/v8threads.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Fsrc%2Fv8threads.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Fsrc%2Fv8threads.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fv8threads.cc?ref=a3f258c7693fd76fc26edc8c9d5b67f260eb755d",
            "patch": "@@ -45,7 +45,7 @@ void Locker::Initialize(v8::Isolate* isolate) {\n     } else {\n       internal::ExecutionAccess access(isolate_);\n       isolate_->stack_guard()->ClearThread(access);\n-      isolate_->stack_guard()->InitThread(access);\n+      isolate_->thread_manager()->InitThread(access);\n     }\n   }\n   DCHECK(isolate_->thread_manager()->IsLockedByCurrentThread());\n@@ -95,6 +95,10 @@ Unlocker::~Unlocker() {\n \n namespace internal {\n \n+void ThreadManager::InitThread(const ExecutionAccess& lock) {\n+  isolate_->stack_guard()->InitThread(lock);\n+  isolate_->debug()->InitThread(lock);\n+}\n \n bool ThreadManager::RestoreThread() {\n   DCHECK(IsLockedByCurrentThread());\n@@ -127,7 +131,7 @@ bool ThreadManager::RestoreThread() {\n       isolate_->FindPerThreadDataForThisThread();\n   if (per_thread == nullptr || per_thread->thread_state() == nullptr) {\n     // This is a new thread.\n-    isolate_->stack_guard()->InitThread(access);\n+    InitThread(access);\n     return false;\n   }\n   ThreadState* state = per_thread->thread_state();"
        },
        {
            "sha": "7fde0c9ec494e77dbbcf8bdbeb3817ab1a9d4c00",
            "filename": "deps/v8/src/v8threads.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Fsrc%2Fv8threads.h",
            "raw_url": "https://github.com/nodejs/node/raw/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Fsrc%2Fv8threads.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fv8threads.h?ref=a3f258c7693fd76fc26edc8c9d5b67f260eb755d",
            "patch": "@@ -67,6 +67,7 @@ class ThreadManager {\n   void Lock();\n   void Unlock();\n \n+  void InitThread(const ExecutionAccess&);\n   void ArchiveThread();\n   bool RestoreThread();\n   void FreeThreadResources();"
        },
        {
            "sha": "7430fbf06b802e54233edfb94196a806e2b68d6b",
            "filename": "deps/v8/test/cctest/test-debug.cc",
            "status": "modified",
            "additions": 127,
            "deletions": 0,
            "changes": 127,
            "blob_url": "https://github.com/nodejs/node/blob/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Ftest%2Fcctest%2Ftest-debug.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a3f258c7693fd76fc26edc8c9d5b67f260eb755d/deps%2Fv8%2Ftest%2Fcctest%2Ftest-debug.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fcctest%2Ftest-debug.cc?ref=a3f258c7693fd76fc26edc8c9d5b67f260eb755d",
            "patch": "@@ -3717,6 +3717,133 @@ TEST(DebugBreakOffThreadTerminate) {\n   CHECK(try_catch.HasTerminated());\n }\n \n+class ArchiveRestoreThread : public v8::base::Thread,\n+                             public v8::debug::DebugDelegate {\n+ public:\n+  ArchiveRestoreThread(v8::Isolate* isolate, int spawn_count)\n+      : Thread(Options(\"ArchiveRestoreThread\")),\n+        isolate_(isolate),\n+        debug_(reinterpret_cast<i::Isolate*>(isolate_)->debug()),\n+        spawn_count_(spawn_count),\n+        break_count_(0) {}\n+\n+  virtual void Run() {\n+    v8::Locker locker(isolate_);\n+    isolate_->Enter();\n+\n+    v8::HandleScope scope(isolate_);\n+    v8::Local<v8::Context> context = v8::Context::New(isolate_);\n+    v8::Context::Scope context_scope(context);\n+\n+    v8::Local<v8::Function> test = CompileFunction(isolate_,\n+                                                   \"function test(n) {\\n\"\n+                                                   \"  debugger;\\n\"\n+                                                   \"  return n + 1;\\n\"\n+                                                   \"}\\n\",\n+                                                   \"test\");\n+\n+    debug_->SetDebugDelegate(this);\n+    v8::internal::DisableBreak enable_break(debug_, false);\n+\n+    v8::Local<v8::Value> args[1] = {v8::Integer::New(isolate_, spawn_count_)};\n+\n+    int result = test->Call(context, context->Global(), 1, args)\n+                     .ToLocalChecked()\n+                     ->Int32Value(context)\n+                     .FromJust();\n+\n+    // Verify that test(spawn_count_) returned spawn_count_ + 1.\n+    CHECK_EQ(spawn_count_ + 1, result);\n+\n+    isolate_->Exit();\n+  }\n+\n+  void BreakProgramRequested(v8::Local<v8::Context> context,\n+                             const std::vector<v8::debug::BreakpointId>&) {\n+    auto stack_traces = v8::debug::StackTraceIterator::Create(isolate_);\n+    if (!stack_traces->Done()) {\n+      v8::debug::Location location = stack_traces->GetSourceLocation();\n+\n+      i::PrintF(\"ArchiveRestoreThread #%d hit breakpoint at line %d\\n\",\n+                spawn_count_, location.GetLineNumber());\n+\n+      switch (location.GetLineNumber()) {\n+        case 1:  // debugger;\n+          CHECK_EQ(break_count_, 0);\n+\n+          // Attempt to stop on the next line after the first debugger\n+          // statement. If debug->{Archive,Restore}Debug() improperly reset\n+          // thread-local debug information, the debugger will fail to stop\n+          // before the test function returns.\n+          debug_->PrepareStep(StepNext);\n+\n+          // Spawning threads while handling the current breakpoint verifies\n+          // that the parent thread correctly archived and restored the\n+          // state necessary to stop on the next line. If not, then control\n+          // will simply continue past the `return n + 1` statement.\n+          MaybeSpawnChildThread();\n+\n+          break;\n+\n+        case 2:  // return n + 1;\n+          CHECK_EQ(break_count_, 1);\n+          break;\n+\n+        default:\n+          CHECK(false);\n+      }\n+    }\n+\n+    ++break_count_;\n+  }\n+\n+  void MaybeSpawnChildThread() {\n+    if (spawn_count_ > 1) {\n+      v8::Unlocker unlocker(isolate_);\n+\n+      // Spawn a thread that spawns a thread that spawns a thread (and so\n+      // on) so that the ThreadManager is forced to archive and restore\n+      // the current thread.\n+      ArchiveRestoreThread child(isolate_, spawn_count_ - 1);\n+      child.Start();\n+      child.Join();\n+\n+      // The child thread sets itself as the debug delegate, so we need to\n+      // usurp it after the child finishes, or else future breakpoints\n+      // will be delegated to a destroyed ArchiveRestoreThread object.\n+      debug_->SetDebugDelegate(this);\n+\n+      // This is the most important check in this test, since\n+      // child.GetBreakCount() will return 1 if the debugger fails to stop\n+      // on the `return n + 1` line after the grandchild thread returns.\n+      CHECK_EQ(child.GetBreakCount(), 2);\n+    }\n+  }\n+\n+  int GetBreakCount() { return break_count_; }\n+\n+ private:\n+  v8::Isolate* isolate_;\n+  v8::internal::Debug* debug_;\n+  const int spawn_count_;\n+  int break_count_;\n+};\n+\n+TEST(DebugArchiveRestore) {\n+  v8::Isolate::CreateParams create_params;\n+  create_params.array_buffer_allocator = CcTest::array_buffer_allocator();\n+  v8::Isolate* isolate = v8::Isolate::New(create_params);\n+\n+  ArchiveRestoreThread thread(isolate, 5);\n+  // Instead of calling thread.Start() and thread.Join() here, we call\n+  // thread.Run() directly, to make sure we exercise archive/restore\n+  // logic on the *current* thread as well as other threads.\n+  thread.Run();\n+  CHECK_EQ(thread.GetBreakCount(), 2);\n+\n+  isolate->Dispose();\n+}\n+\n class DebugEventExpectNoException : public v8::debug::DebugDelegate {\n  public:\n   void ExceptionThrown(v8::Local<v8::Context> paused_context,"
        }
    ],
    "stats": {
        "total": 165,
        "additions": 156,
        "deletions": 9
    }
}