{
    "author": "billywhizz",
    "message": "http: prevent aborted event when already completed\n\nTests in progress to reproduce issue consistently.\n\nFixes: https://github.com/nodejs/node/issues/18756\n\nPR-URL: https://github.com/nodejs/node/pull/18999\nReviewed-By: Shingo Inoue <leko.noor@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "f7a6971281d863e2b56682ff0f45eee7a7c4d3bb",
    "files": [
        {
            "sha": "1b5f6301a65928cd35ed602bc4d6b2d432403af5",
            "filename": "test/parallel/test-http-client-spurious-aborted.js",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/f7a6971281d863e2b56682ff0f45eee7a7c4d3bb/test%2Fparallel%2Ftest-http-client-spurious-aborted.js",
            "raw_url": "https://github.com/nodejs/node/raw/f7a6971281d863e2b56682ff0f45eee7a7c4d3bb/test%2Fparallel%2Ftest-http-client-spurious-aborted.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-client-spurious-aborted.js?ref=f7a6971281d863e2b56682ff0f45eee7a7c4d3bb",
            "patch": "@@ -0,0 +1,83 @@\n+'use strict';\n+\n+const common = require('../common');\n+const http = require('http');\n+const assert = require('assert');\n+const fs = require('fs');\n+const Countdown = require('../common/countdown');\n+\n+function cleanup(fname) {\n+  try {\n+    if (fs.statSync(fname)) fs.unlinkSync(fname);\n+  } catch (err) {}\n+}\n+\n+const N = 2;\n+const fname = '/dev/null';\n+let abortRequest = true;\n+\n+const server = http.Server(common.mustCall((req, res) => {\n+  const headers = { 'Content-Type': 'text/plain' };\n+  headers['Content-Length'] = 50;\n+  const socket = res.socket;\n+  res.writeHead(200, headers);\n+  setTimeout(() => res.write('aaaaaaaaaa'), 100);\n+  setTimeout(() => res.write('bbbbbbbbbb'), 200);\n+  setTimeout(() => res.write('cccccccccc'), 300);\n+  setTimeout(() => res.write('dddddddddd'), 400);\n+  if (abortRequest) {\n+    setTimeout(() => socket.destroy(), 600);\n+  } else {\n+    setTimeout(() => res.end('eeeeeeeeee'), 1000);\n+  }\n+}, N));\n+\n+server.listen(0, common.mustCall(() => {\n+  cleanup(fname);\n+  download();\n+}));\n+\n+const finishCountdown = new Countdown(N, common.mustCall(() => {\n+  server.close();\n+}));\n+const reqCountdown = new Countdown(N, common.mustCall());\n+\n+function download() {\n+  const opts = {\n+    port: server.address().port,\n+    path: '/',\n+  };\n+  const req = http.get(opts);\n+  req.on('error', common.mustNotCall());\n+  req.on('response', (res) => {\n+    assert.strictEqual(res.statusCode, 200);\n+    assert.strictEqual(res.headers.connection, 'close');\n+    let aborted = false;\n+    const fstream = fs.createWriteStream(fname);\n+    res.pipe(fstream);\n+    const _handle = res.socket._handle;\n+    _handle._close = res.socket._handle.close;\n+    _handle.close = function(callback) {\n+      _handle._close();\n+      // set readable to true event though request is complete\n+      if (res.complete) res.readable = true;\n+      callback();\n+    };\n+    res.on('end', common.mustCall(() => {\n+      reqCountdown.dec();\n+    }));\n+    res.on('aborted', () => {\n+      aborted = true;\n+    });\n+    res.on('error', common.mustNotCall());\n+    fstream.on('finish', () => {\n+      assert.strictEqual(aborted, abortRequest);\n+      cleanup(fname);\n+      finishCountdown.dec();\n+      if (finishCountdown.remaining === 0) return;\n+      abortRequest = false; // next one should be a good response\n+      download();\n+    });\n+  });\n+  req.end();\n+}"
        }
    ],
    "stats": {
        "total": 83,
        "additions": 83,
        "deletions": 0
    }
}