{
    "author": "devsnek",
    "message": "vm: add dynamic import support\n\nPR-URL: https://github.com/nodejs/node/pull/22381\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Guy Bedford <guybedford@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>",
    "sha": "4c37df779cf944b5666fc72e2a27fbf2e745881f",
    "files": [
        {
            "sha": "7cdee52e79266022f722a79556bb89684bb02fb0",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -1779,6 +1779,11 @@ The V8 `BreakIterator` API was used but the full ICU data set is not installed.\n While using the Performance Timing API (`perf_hooks`), no valid performance\n entry types were found.\n \n+<a id=\"ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\"></a>\n+### ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\n+\n+A dynamic import callback was not specified.\n+\n <a id=\"ERR_VM_MODULE_ALREADY_LINKED\"></a>\n ### ERR_VM_MODULE_ALREADY_LINKED\n "
        },
        {
            "sha": "07923de5856e7dcb15a9f09555b739f78920f959",
            "filename": "doc/api/vm.md",
            "status": "modified",
            "additions": 21,
            "deletions": 1,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/doc%2Fapi%2Fvm.md",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/doc%2Fapi%2Fvm.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fvm.md?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -167,10 +167,19 @@ const contextifiedSandbox = vm.createContext({ secret: 42 });\n     in stack traces produced by this `Module`.\n   * `columnOffset` {integer} Specifies the column number offset that is\n     displayed in stack traces produced by this `Module`.\n-  * `initalizeImportMeta` {Function} Called during evaluation of this `Module`\n+  * `initializeImportMeta` {Function} Called during evaluation of this `Module`\n     to initialize the `import.meta`. This function has the signature `(meta,\n     module)`, where `meta` is the `import.meta` object in the `Module`, and\n     `module` is this `vm.SourceTextModule` object.\n+  * `importModuleDynamically` {Function} Called during evaluation of this\n+    module when `import()` is called. This function has the signature\n+    `(specifier, module)` where `specifier` is the specifier passed to\n+    `import()` and `module` is this `vm.SourceTextModule`. If this option is\n+    not specified, calls to `import()` will reject with\n+    [`ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING`][]. This method can return a\n+    [Module Namespace Object][], but returning a `vm.SourceTextModule` is\n+    recommended in order to take advantage of error tracking, and to avoid\n+    issues with namespaces that contain `then` function exports.\n \n Creates a new ES `Module` object.\n \n@@ -436,6 +445,15 @@ changes:\n     The `cachedDataProduced` value will be set to either `true` or `false`\n     depending on whether code cache data is produced successfully.\n     This option is deprecated in favor of `script.createCachedData()`.\n+  * `importModuleDynamically` {Function} Called during evaluation of this\n+    module when `import()` is called. This function has the signature\n+    `(specifier, module)` where `specifier` is the specifier passed to\n+    `import()` and `module` is this `vm.SourceTextModule`. If this option is\n+    not specified, calls to `import()` will reject with\n+    [`ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING`][]. This method can return a\n+    [Module Namespace Object][], but returning a `vm.SourceTextModule` is\n+    recommended in order to take advantage of error tracking, and to avoid\n+    issues with namespaces that contain `then` function exports.\n \n Creating a new `vm.Script` object compiles `code` but does not run it. The\n compiled `vm.Script` can be run later multiple times. The `code` is not bound to\n@@ -945,6 +963,7 @@ associating it with the `sandbox` object is what this document refers to as\n \"contextifying\" the `sandbox`.\n \n [`Error`]: errors.html#errors_class_error\n+[`ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING`]: errors.html#ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\n [`URL`]: url.html#url_class_url\n [`eval()`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval\n [`script.runInContext()`]: #vm_script_runincontext_contextifiedsandbox_options\n@@ -954,6 +973,7 @@ associating it with the `sandbox` object is what this document refers to as\n [`vm.runInContext()`]: #vm_vm_runincontext_code_contextifiedsandbox_options\n [`vm.runInThisContext()`]: #vm_vm_runinthiscontext_code_options\n [GetModuleNamespace]: https://tc39.github.io/ecma262/#sec-getmodulenamespace\n+[Module Namespace Object]: https://tc39.github.io/ecma262/#sec-module-namespace-exotic-objects\n [ECMAScript Module Loader]: esm.html#esm_ecmascript_modules\n [Evaluate() concrete method]: https://tc39.github.io/ecma262/#sec-moduleevaluation\n [HostResolveImportedModule]: https://tc39.github.io/ecma262/#sec-hostresolveimportedmodule"
        },
        {
            "sha": "359812e1e9e34249aa08e4d3ff37f6e6cd3d4e90",
            "filename": "lib/internal/bootstrap/loaders.js",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Floaders.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -107,6 +107,8 @@\n     };\n   }\n \n+  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap\n+  internalBinding('module_wrap').callbackMap = new WeakMap();\n   const { ContextifyScript } = internalBinding('contextify');\n \n   // Set up NativeModule"
        },
        {
            "sha": "4094a40f6b5631ad41769ed31fd9593a8545dab5",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -873,6 +873,8 @@ E('ERR_V8BREAKITERATOR',\n // This should probably be a `TypeError`.\n E('ERR_VALID_PERFORMANCE_ENTRY_TYPE',\n   'At least one valid performance entry type is required', Error);\n+E('ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING',\n+  'A dynamic import callback was not specified.', TypeError);\n E('ERR_VM_MODULE_ALREADY_LINKED', 'Module has already been linked', Error);\n E('ERR_VM_MODULE_DIFFERENT_CONTEXT',\n   'Linked modules must use the same context', Error);"
        },
        {
            "sha": "6cdafac3de5c17c33e25514666be45286a25332b",
            "filename": "lib/internal/modules/cjs/loader.js",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fmodules%2Fcjs%2Floader.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fmodules%2Fcjs%2Floader.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fmodules%2Fcjs%2Floader.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -29,6 +29,7 @@ const assert = require('assert').ok;\n const fs = require('fs');\n const internalFS = require('internal/fs/utils');\n const path = require('path');\n+const { URL } = require('url');\n const {\n   internalModuleReadJSON,\n   internalModuleStat\n@@ -656,6 +657,13 @@ Module.prototype.require = function(id) {\n // (needed for setting breakpoint when called with --inspect-brk)\n var resolvedArgv;\n \n+function normalizeReferrerURL(referrer) {\n+  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n+    return pathToFileURL(referrer).href;\n+  }\n+  return new URL(referrer).href;\n+}\n+\n \n // Run the file contents in the correct scope or sandbox. Expose\n // the correct helper variables (require, module, exports) to\n@@ -671,7 +679,12 @@ Module.prototype._compile = function(content, filename) {\n   var compiledWrapper = vm.runInThisContext(wrapper, {\n     filename: filename,\n     lineOffset: 0,\n-    displayErrors: true\n+    displayErrors: true,\n+    importModuleDynamically: experimentalModules ? async (specifier) => {\n+      if (asyncESM === undefined) lazyLoadESM();\n+      const loader = await asyncESM.loaderPromise;\n+      return loader.import(specifier, normalizeReferrerURL(filename));\n+    } : undefined,\n   });\n \n   var inspectorWrapper = null;"
        },
        {
            "sha": "0c34283b8af9e066ebee8164eea7f66f08a56d74",
            "filename": "lib/internal/modules/esm/translators.js",
            "status": "modified",
            "additions": 19,
            "deletions": 3,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fmodules%2Fesm%2Ftranslators.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fmodules%2Fesm%2Ftranslators.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fmodules%2Fesm%2Ftranslators.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -1,7 +1,7 @@\n 'use strict';\n \n const { NativeModule } = require('internal/bootstrap/loaders');\n-const { ModuleWrap } = internalBinding('module_wrap');\n+const { ModuleWrap, callbackMap } = internalBinding('module_wrap');\n const {\n   stripShebang,\n   stripBOM\n@@ -15,6 +15,8 @@ const { _makeLong } = require('path');\n const { SafeMap } = require('internal/safe_globals');\n const { URL } = require('url');\n const { debuglog, promisify } = require('util');\n+const esmLoader = require('internal/process/esm_loader');\n+\n const readFileAsync = promisify(fs.readFile);\n const readFileSync = fs.readFileSync;\n const StringReplace = Function.call.bind(String.prototype.replace);\n@@ -25,13 +27,27 @@ const debug = debuglog('esm');\n const translators = new SafeMap();\n module.exports = translators;\n \n+function initializeImportMeta(meta, { url }) {\n+  meta.url = url;\n+}\n+\n+async function importModuleDynamically(specifier, { url }) {\n+  const loader = await esmLoader.loaderPromise;\n+  return loader.import(specifier, url);\n+}\n+\n // Strategy for loading a standard JavaScript module\n translators.set('esm', async (url) => {\n   const source = `${await readFileAsync(new URL(url))}`;\n   debug(`Translating StandardModule ${url}`);\n+  const module = new ModuleWrap(stripShebang(source), url);\n+  callbackMap.set(module, {\n+    initializeImportMeta,\n+    importModuleDynamically,\n+  });\n   return {\n-    module: new ModuleWrap(stripShebang(source), url),\n-    reflect: undefined\n+    module,\n+    reflect: undefined,\n   };\n });\n "
        },
        {
            "sha": "b2415ec171f9854cfd6e3c289a34ba41f79b1d1f",
            "filename": "lib/internal/process/esm_loader.js",
            "status": "modified",
            "additions": 22,
            "deletions": 27,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fprocess%2Fesm_loader.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fprocess%2Fesm_loader.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fesm_loader.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -2,40 +2,42 @@\n \n const {\n   setImportModuleDynamicallyCallback,\n-  setInitializeImportMetaObjectCallback\n+  setInitializeImportMetaObjectCallback,\n+  callbackMap,\n } = internalBinding('module_wrap');\n \n const { pathToFileURL } = require('internal/url');\n const Loader = require('internal/modules/esm/loader');\n-const path = require('path');\n-const { URL } = require('url');\n const {\n-  initImportMetaMap,\n-  wrapToModuleMap\n+  wrapToModuleMap,\n } = require('internal/vm/source_text_module');\n+const {\n+  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING,\n+} = require('internal/errors').codes;\n \n-function normalizeReferrerURL(referrer) {\n-  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n-    return pathToFileURL(referrer).href;\n+function initializeImportMetaObject(wrap, meta) {\n+  if (callbackMap.has(wrap)) {\n+    const { initializeImportMeta } = callbackMap.get(wrap);\n+    if (initializeImportMeta !== undefined) {\n+      initializeImportMeta(meta, wrapToModuleMap.get(wrap) || wrap);\n+    }\n   }\n-  return new URL(referrer).href;\n }\n \n-function initializeImportMetaObject(wrap, meta) {\n-  const vmModule = wrapToModuleMap.get(wrap);\n-  if (vmModule === undefined) {\n-    // This ModuleWrap belongs to the Loader.\n-    meta.url = wrap.url;\n-  } else {\n-    const initializeImportMeta = initImportMetaMap.get(vmModule);\n-    if (initializeImportMeta !== undefined) {\n-      // This ModuleWrap belongs to vm.SourceTextModule,\n-      // initializer callback was provided.\n-      initializeImportMeta(meta, vmModule);\n+async function importModuleDynamicallyCallback(wrap, specifier) {\n+  if (callbackMap.has(wrap)) {\n+    const { importModuleDynamically } = callbackMap.get(wrap);\n+    if (importModuleDynamically !== undefined) {\n+      return importModuleDynamically(\n+        specifier, wrapToModuleMap.get(wrap) || wrap);\n     }\n   }\n+  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n }\n \n+setInitializeImportMetaObjectCallback(initializeImportMetaObject);\n+setImportModuleDynamicallyCallback(importModuleDynamicallyCallback);\n+\n let loaderResolve;\n exports.loaderPromise = new Promise((resolve, reject) => {\n   loaderResolve = resolve;\n@@ -44,8 +46,6 @@ exports.loaderPromise = new Promise((resolve, reject) => {\n exports.ESMLoader = undefined;\n \n exports.setup = function() {\n-  setInitializeImportMetaObjectCallback(initializeImportMetaObject);\n-\n   let ESMLoader = new Loader();\n   const loaderPromise = (async () => {\n     const userLoader = process.binding('config').userLoader;\n@@ -60,10 +60,5 @@ exports.setup = function() {\n   })();\n   loaderResolve(loaderPromise);\n \n-  setImportModuleDynamicallyCallback(async (referrer, specifier) => {\n-    const loader = await loaderPromise;\n-    return loader.import(specifier, normalizeReferrerURL(referrer));\n-  });\n-\n   exports.ESMLoader = ESMLoader;\n };"
        },
        {
            "sha": "d22db6e914f50d25ff5500d40e870ee0023f163a",
            "filename": "lib/internal/vm/source_text_module.js",
            "status": "modified",
            "additions": 34,
            "deletions": 13,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fvm%2Fsource_text_module.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Finternal%2Fvm%2Fsource_text_module.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fvm%2Fsource_text_module.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -1,5 +1,6 @@\n 'use strict';\n \n+const { isModuleNamespaceObject } = require('util').types;\n const { URL } = require('internal/url');\n const { isContext } = internalBinding('contextify');\n const {\n@@ -9,7 +10,7 @@ const {\n   ERR_VM_MODULE_LINKING_ERRORED,\n   ERR_VM_MODULE_NOT_LINKED,\n   ERR_VM_MODULE_NOT_MODULE,\n-  ERR_VM_MODULE_STATUS\n+  ERR_VM_MODULE_STATUS,\n } = require('internal/errors').codes;\n const {\n   getConstructorOf,\n@@ -21,6 +22,7 @@ const { validateInt32, validateUint32 } = require('internal/validators');\n \n const {\n   ModuleWrap,\n+  callbackMap,\n   kUninstantiated,\n   kInstantiating,\n   kInstantiated,\n@@ -43,8 +45,6 @@ const perContextModuleId = new WeakMap();\n const wrapMap = new WeakMap();\n const dependencyCacheMap = new WeakMap();\n const linkingStatusMap = new WeakMap();\n-// vm.SourceTextModule -> function\n-const initImportMetaMap = new WeakMap();\n // ModuleWrap -> vm.SourceTextModule\n const wrapToModuleMap = new WeakMap();\n const defaultModuleName = 'vm:module';\n@@ -63,7 +63,8 @@ class SourceTextModule {\n       context,\n       lineOffset = 0,\n       columnOffset = 0,\n-      initializeImportMeta\n+      initializeImportMeta,\n+      importModuleDynamically,\n     } = options;\n \n     if (context !== undefined) {\n@@ -96,20 +97,39 @@ class SourceTextModule {\n     validateInt32(lineOffset, 'options.lineOffset');\n     validateInt32(columnOffset, 'options.columnOffset');\n \n-    if (initializeImportMeta !== undefined) {\n-      if (typeof initializeImportMeta === 'function') {\n-        initImportMetaMap.set(this, initializeImportMeta);\n-      } else {\n-        throw new ERR_INVALID_ARG_TYPE(\n-          'options.initializeImportMeta', 'function', initializeImportMeta);\n-      }\n+    if (initializeImportMeta !== undefined &&\n+        typeof initializeImportMeta !== 'function') {\n+      throw new ERR_INVALID_ARG_TYPE(\n+        'options.initializeImportMeta', 'function', initializeImportMeta);\n+    }\n+\n+    if (importModuleDynamically !== undefined &&\n+        typeof importModuleDynamically !== 'function') {\n+      throw new ERR_INVALID_ARG_TYPE(\n+        'options.importModuleDynamically', 'function', importModuleDynamically);\n     }\n \n     const wrap = new ModuleWrap(src, url, context, lineOffset, columnOffset);\n     wrapMap.set(this, wrap);\n     linkingStatusMap.set(this, 'unlinked');\n     wrapToModuleMap.set(wrap, this);\n \n+    callbackMap.set(wrap, {\n+      initializeImportMeta,\n+      importModuleDynamically: importModuleDynamically ? async (...args) => {\n+        const m = await importModuleDynamically(...args);\n+        if (isModuleNamespaceObject(m)) {\n+          return m;\n+        }\n+        if (!m || !wrapMap.has(m))\n+          throw new ERR_VM_MODULE_NOT_MODULE();\n+        const childLinkingStatus = linkingStatusMap.get(m);\n+        if (childLinkingStatus === 'errored')\n+          throw m.error;\n+        return m.namespace;\n+      } : undefined,\n+    });\n+\n     Object.defineProperties(this, {\n       url: { value: url, enumerable: true },\n       context: { value: context, enumerable: true },\n@@ -245,6 +265,7 @@ class SourceTextModule {\n \n module.exports = {\n   SourceTextModule,\n-  initImportMetaMap,\n-  wrapToModuleMap\n+  wrapToModuleMap,\n+  wrapMap,\n+  linkingStatusMap,\n };"
        },
        {
            "sha": "869b4aa65485cb19c347d44cdf31f242fd2186b0",
            "filename": "lib/vm.js",
            "status": "modified",
            "additions": 30,
            "deletions": 4,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Fvm.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/lib%2Fvm.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fvm.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -27,9 +27,12 @@ const {\n   isContext: _isContext,\n   compileFunction: _compileFunction\n } = internalBinding('contextify');\n-\n-const { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\n-const { isUint8Array } = require('internal/util/types');\n+const { callbackMap } = internalBinding('module_wrap');\n+const {\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_VM_MODULE_NOT_MODULE,\n+} = require('internal/errors').codes;\n+const { isModuleNamespaceObject, isUint8Array } = require('util').types;\n const { validateInt32, validateUint32 } = require('internal/validators');\n const kParsingContext = Symbol('script parsing context');\n \n@@ -52,7 +55,8 @@ class Script extends ContextifyScript {\n       columnOffset = 0,\n       cachedData,\n       produceCachedData = false,\n-      [kParsingContext]: parsingContext\n+      importModuleDynamically,\n+      [kParsingContext]: parsingContext,\n     } = options;\n \n     if (typeof filename !== 'string') {\n@@ -83,6 +87,28 @@ class Script extends ContextifyScript {\n     } catch (e) {\n       throw e; /* node-do-not-add-exception-line */\n     }\n+\n+    if (importModuleDynamically !== undefined) {\n+      if (typeof importModuleDynamically !== 'function') {\n+        throw new ERR_INVALID_ARG_TYPE('options.importModuleDynamically',\n+                                       'function',\n+                                       importModuleDynamically);\n+      }\n+      const { wrapMap, linkingStatusMap } =\n+        require('internal/vm/source_text_module');\n+      callbackMap.set(this, { importModuleDynamically: async (...args) => {\n+        const m = await importModuleDynamically(...args);\n+        if (isModuleNamespaceObject(m)) {\n+          return m;\n+        }\n+        if (!m || !wrapMap.has(m))\n+          throw new ERR_VM_MODULE_NOT_MODULE();\n+        const childLinkingStatus = linkingStatusMap.get(m);\n+        if (childLinkingStatus === 'errored')\n+          throw m.error;\n+        return m.namespace;\n+      } });\n+    }\n   }\n \n   runInThisContext(options) {"
        },
        {
            "sha": "6ace0bf82533d545c026c618ba5977d5c8ab8516",
            "filename": "src/env-inl.h",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fenv-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fenv-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv-inl.h?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -446,6 +446,13 @@ Environment::trace_category_state() {\n   return trace_category_state_;\n }\n \n+inline uint32_t Environment::get_next_module_id() {\n+  return module_id_counter_++;\n+}\n+inline uint32_t Environment::get_next_script_id() {\n+  return script_id_counter_++;\n+}\n+\n Environment::ShouldNotAbortOnUncaughtScope::ShouldNotAbortOnUncaughtScope(\n     Environment* env)\n     : env_(env) {"
        },
        {
            "sha": "1eb333b0ef31d95b32b4f073aa2ab4ab56f8c0e4",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -47,6 +47,10 @@ struct nghttp2_rcbuf;\n \n namespace node {\n \n+namespace contextify {\n+class ContextifyScript;\n+}\n+\n namespace fs {\n class FileHandleReadWrap;\n }\n@@ -674,7 +678,13 @@ class Environment {\n   // List of id's that have been destroyed and need the destroy() cb called.\n   inline std::vector<double>* destroy_async_id_list();\n \n-  std::unordered_multimap<int, loader::ModuleWrap*> module_map;\n+  std::unordered_multimap<int, loader::ModuleWrap*> hash_to_module_map;\n+  std::unordered_map<uint32_t, loader::ModuleWrap*> id_to_module_map;\n+  std::unordered_map<uint32_t, contextify::ContextifyScript*>\n+      id_to_script_map;\n+\n+  inline uint32_t get_next_module_id();\n+  inline uint32_t get_next_script_id();\n \n   std::unordered_map<std::string, const loader::PackageConfig>\n       package_json_cache;\n@@ -924,6 +934,9 @@ class Environment {\n \n   std::shared_ptr<EnvironmentOptions> options_;\n \n+  uint32_t module_id_counter_ = 0;\n+  uint32_t script_id_counter_ = 0;\n+\n   AliasedBuffer<uint32_t, v8::Uint32Array> should_abort_on_uncaught_toggle_;\n   int should_not_abort_scope_counter_ = 0;\n "
        },
        {
            "sha": "4a7be86af802501b7398a4b7eb219e8f15eb4b56",
            "filename": "src/module_wrap.cc",
            "status": "modified",
            "additions": 75,
            "deletions": 38,
            "changes": 113,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fmodule_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fmodule_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmodule_wrap.cc?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -33,7 +33,9 @@ using v8::Maybe;\n using v8::MaybeLocal;\n using v8::Module;\n using v8::Nothing;\n+using v8::Number;\n using v8::Object;\n+using v8::PrimitiveArray;\n using v8::Promise;\n using v8::ScriptCompiler;\n using v8::ScriptOrigin;\n@@ -47,34 +49,44 @@ static const char* const EXTENSIONS[] = {\".mjs\", \".js\", \".json\", \".node\"};\n ModuleWrap::ModuleWrap(Environment* env,\n                        Local<Object> object,\n                        Local<Module> module,\n-                       Local<String> url) : BaseObject(env, object) {\n+                       Local<String> url) :\n+  BaseObject(env, object),\n+  id_(env->get_next_module_id()) {\n   module_.Reset(env->isolate(), module);\n   url_.Reset(env->isolate(), url);\n+  env->id_to_module_map.emplace(id_, this);\n }\n \n ModuleWrap::~ModuleWrap() {\n   HandleScope scope(env()->isolate());\n   Local<Module> module = module_.Get(env()->isolate());\n-  auto range = env()->module_map.equal_range(module->GetIdentityHash());\n+  env()->id_to_module_map.erase(id_);\n+  auto range = env()->hash_to_module_map.equal_range(module->GetIdentityHash());\n   for (auto it = range.first; it != range.second; ++it) {\n     if (it->second == this) {\n-      env()->module_map.erase(it);\n+      env()->hash_to_module_map.erase(it);\n       break;\n     }\n   }\n }\n \n ModuleWrap* ModuleWrap::GetFromModule(Environment* env,\n                                       Local<Module> module) {\n-  ModuleWrap* ret = nullptr;\n-  auto range = env->module_map.equal_range(module->GetIdentityHash());\n+  auto range = env->hash_to_module_map.equal_range(module->GetIdentityHash());\n   for (auto it = range.first; it != range.second; ++it) {\n     if (it->second->module_ == module) {\n-      ret = it->second;\n-      break;\n+      return it->second;\n     }\n   }\n-  return ret;\n+  return nullptr;\n+}\n+\n+ModuleWrap* ModuleWrap::GetFromID(Environment* env, uint32_t id) {\n+  auto module_wrap_it = env->id_to_module_map.find(id);\n+  if (module_wrap_it == env->id_to_module_map.end()) {\n+    return nullptr;\n+  }\n+  return module_wrap_it->second;\n }\n \n void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n@@ -126,6 +138,11 @@ void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n   TryCatch try_catch(isolate);\n   Local<Module> module;\n \n+  Local<PrimitiveArray> host_defined_options =\n+      PrimitiveArray::New(isolate, HostDefinedOptions::kLength);\n+  host_defined_options->Set(isolate, HostDefinedOptions::kType,\n+                            Number::New(isolate, ScriptType::kModule));\n+\n   // compile\n   {\n     ScriptOrigin origin(url,\n@@ -136,7 +153,8 @@ void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n                         Local<Value>(),                       // source map URL\n                         False(isolate),                       // is opaque (?)\n                         False(isolate),                       // is WASM\n-                        True(isolate));                       // is ES6 module\n+                        True(isolate),                        // is ES Module\n+                        host_defined_options);\n     Context::Scope context_scope(context);\n     ScriptCompiler::Source source(source_text, origin);\n     if (!ScriptCompiler::CompileModule(isolate, &source).ToLocal(&module)) {\n@@ -157,7 +175,10 @@ void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n   ModuleWrap* obj = new ModuleWrap(env, that, module, url);\n   obj->context_.Reset(isolate, context);\n \n-  env->module_map.emplace(module->GetIdentityHash(), obj);\n+  env->hash_to_module_map.emplace(module->GetIdentityHash(), obj);\n+\n+  host_defined_options->Set(isolate, HostDefinedOptions::kID,\n+                            Number::New(isolate, obj->id()));\n \n   that->SetIntegrityLevel(context, IntegrityLevel::kFrozen);\n   args.GetReturnValue().Set(that);\n@@ -364,19 +385,14 @@ MaybeLocal<Module> ModuleWrap::ResolveCallback(Local<Context> context,\n   Environment* env = Environment::GetCurrent(context);\n   CHECK_NOT_NULL(env);  // TODO(addaleax): Handle nullptr here.\n   Isolate* isolate = env->isolate();\n-  if (env->module_map.count(referrer->GetIdentityHash()) == 0) {\n-    env->ThrowError(\"linking error, unknown module\");\n-    return MaybeLocal<Module>();\n-  }\n \n   ModuleWrap* dependent = GetFromModule(env, referrer);\n-\n   if (dependent == nullptr) {\n     env->ThrowError(\"linking error, null dep\");\n     return MaybeLocal<Module>();\n   }\n \n-  Utf8Value specifier_utf8(env->isolate(), specifier);\n+  Utf8Value specifier_utf8(isolate, specifier);\n   std::string specifier_std(*specifier_utf8, specifier_utf8.length());\n \n   if (dependent->resolve_cache_.count(specifier_std) != 1) {\n@@ -402,7 +418,7 @@ MaybeLocal<Module> ModuleWrap::ResolveCallback(Local<Context> context,\n \n   ModuleWrap* module;\n   ASSIGN_OR_RETURN_UNWRAP(&module, module_object, MaybeLocal<Module>());\n-  return module->module_.Get(env->isolate());\n+  return module->module_.Get(isolate);\n }\n \n namespace {\n@@ -704,35 +720,56 @@ static MaybeLocal<Promise> ImportModuleDynamically(\n   CHECK_NOT_NULL(env);  // TODO(addaleax): Handle nullptr here.\n   v8::EscapableHandleScope handle_scope(iso);\n \n-  if (env->context() != context) {\n-    auto maybe_resolver = Promise::Resolver::New(context);\n-    Local<Promise::Resolver> resolver;\n-    if (maybe_resolver.ToLocal(&resolver)) {\n-      // TODO(jkrems): Turn into proper error object w/ code\n-      Local<Value> error = v8::Exception::Error(\n-        OneByteString(iso, \"import() called outside of main context\"));\n-      if (resolver->Reject(context, error).IsJust()) {\n-        return handle_scope.Escape(resolver.As<Promise>());\n-      }\n-    }\n-    return MaybeLocal<Promise>();\n-  }\n-\n   Local<Function> import_callback =\n     env->host_import_module_dynamically_callback();\n+\n+  Local<PrimitiveArray> options = referrer->GetHostDefinedOptions();\n+  if (options->Length() != HostDefinedOptions::kLength) {\n+    Local<Promise::Resolver> resolver =\n+        Promise::Resolver::New(context).ToLocalChecked();\n+    resolver\n+        ->Reject(context,\n+                 v8::Exception::TypeError(FIXED_ONE_BYTE_STRING(\n+                     context->GetIsolate(), \"Invalid host defined options\")))\n+        .ToChecked();\n+    return handle_scope.Escape(resolver->GetPromise());\n+  }\n+\n+  Local<Value> object;\n+\n+  int type = options->Get(iso, HostDefinedOptions::kType)\n+                 .As<Number>()\n+                 ->Int32Value(context)\n+                 .ToChecked();\n+  uint32_t id = options->Get(iso, HostDefinedOptions::kID)\n+                    .As<Number>()\n+                    ->Uint32Value(context)\n+                    .ToChecked();\n+  if (type == ScriptType::kScript) {\n+    contextify::ContextifyScript* wrap = env->id_to_script_map.find(id)->second;\n+    object = wrap->object();\n+  } else if (type == ScriptType::kModule) {\n+    ModuleWrap* wrap = ModuleWrap::GetFromID(env, id);\n+    object = wrap->object();\n+  } else {\n+    UNREACHABLE();\n+  }\n+\n   Local<Value> import_args[] = {\n-    referrer->GetResourceName(),\n-    Local<Value>(specifier)\n+    object,\n+    Local<Value>(specifier),\n   };\n-  MaybeLocal<Value> maybe_result = import_callback->Call(context,\n-                                                         v8::Undefined(iso),\n-                                                         2,\n-                                                         import_args);\n \n   Local<Value> result;\n-  if (maybe_result.ToLocal(&result)) {\n+  if (import_callback->Call(\n+        context,\n+        v8::Undefined(iso),\n+        arraysize(import_args),\n+        import_args).ToLocal(&result)) {\n+    CHECK(result->IsPromise());\n     return handle_scope.Escape(result.As<Promise>());\n   }\n+\n   return MaybeLocal<Promise>();\n }\n "
        },
        {
            "sha": "0e352c657580e42909f42fa6e0d4845eb14aab87",
            "filename": "src/module_wrap.h",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fmodule_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fmodule_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmodule_wrap.h?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -17,6 +17,17 @@ enum PackageMainCheck : bool {\n     IgnoreMain = false\n };\n \n+enum ScriptType : int {\n+  kScript,\n+  kModule,\n+};\n+\n+enum HostDefinedOptions : int {\n+  kType = 8,\n+  kID = 9,\n+  kLength = 10,\n+};\n+\n v8::Maybe<url::URL> Resolve(Environment* env,\n                             const std::string& specifier,\n                             const url::URL& base,\n@@ -38,6 +49,9 @@ class ModuleWrap : public BaseObject {\n     tracker->TrackField(\"resolve_cache\", resolve_cache_);\n   }\n \n+  inline uint32_t id() { return id_; }\n+  static ModuleWrap* GetFromID(node::Environment*, uint32_t id);\n+\n   SET_MEMORY_INFO_NAME(ModuleWrap)\n   SET_SELF_SIZE(ModuleWrap)\n \n@@ -69,12 +83,12 @@ class ModuleWrap : public BaseObject {\n       v8::Local<v8::Module> referrer);\n   static ModuleWrap* GetFromModule(node::Environment*, v8::Local<v8::Module>);\n \n-\n   Persistent<v8::Module> module_;\n   Persistent<v8::String> url_;\n   bool linked_ = false;\n   std::unordered_map<std::string, Persistent<v8::Promise>> resolve_cache_;\n   Persistent<v8::Context> context_;\n+  uint32_t id_;\n };\n \n }  // namespace loader"
        },
        {
            "sha": "023a659ebb66a53155d3afcc92ef484b5bd5876a",
            "filename": "src/node_contextify.cc",
            "status": "modified",
            "additions": 317,
            "deletions": 301,
            "changes": 618,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fnode_contextify.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fnode_contextify.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.cc?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -26,6 +26,7 @@\n #include \"node_contextify.h\"\n #include \"node_context_data.h\"\n #include \"node_errors.h\"\n+#include \"module_wrap.h\"\n \n namespace node {\n namespace contextify {\n@@ -49,8 +50,10 @@ using v8::Maybe;\n using v8::MaybeLocal;\n using v8::Name;\n using v8::NamedPropertyHandlerConfiguration;\n+using v8::Number;\n using v8::Object;\n using v8::ObjectTemplate;\n+using v8::PrimitiveArray;\n using v8::PropertyAttribute;\n using v8::PropertyCallbackInfo;\n using v8::PropertyDescriptor;\n@@ -586,368 +589,381 @@ void ContextifyContext::IndexedPropertyDeleterCallback(\n   args.GetReturnValue().Set(false);\n }\n \n-class ContextifyScript : public BaseObject {\n- private:\n-  Persistent<UnboundScript> script_;\n-\n- public:\n-  SET_NO_MEMORY_INFO()\n-  SET_MEMORY_INFO_NAME(ContextifyScript)\n-  SET_SELF_SIZE(ContextifyScript)\n-\n-  static void Init(Environment* env, Local<Object> target) {\n-    HandleScope scope(env->isolate());\n-    Local<String> class_name =\n-        FIXED_ONE_BYTE_STRING(env->isolate(), \"ContextifyScript\");\n-\n-    Local<FunctionTemplate> script_tmpl = env->NewFunctionTemplate(New);\n-    script_tmpl->InstanceTemplate()->SetInternalFieldCount(1);\n-    script_tmpl->SetClassName(class_name);\n-    env->SetProtoMethod(script_tmpl, \"createCachedData\", CreateCachedData);\n-    env->SetProtoMethod(script_tmpl, \"runInContext\", RunInContext);\n-    env->SetProtoMethod(script_tmpl, \"runInThisContext\", RunInThisContext);\n-\n-    target->Set(class_name,\n-                script_tmpl->GetFunction(env->context()).ToLocalChecked());\n-    env->set_script_context_constructor_template(script_tmpl);\n-  }\n-\n-\n-  static void New(const FunctionCallbackInfo<Value>& args) {\n-    Environment* env = Environment::GetCurrent(args);\n-    Isolate* isolate = env->isolate();\n-    Local<Context> context = env->context();\n-\n-    CHECK(args.IsConstructCall());\n-\n-    const int argc = args.Length();\n-    CHECK_GE(argc, 2);\n-\n-    CHECK(args[0]->IsString());\n-    Local<String> code = args[0].As<String>();\n-\n-    CHECK(args[1]->IsString());\n-    Local<String> filename = args[1].As<String>();\n-\n-    Local<Integer> line_offset;\n-    Local<Integer> column_offset;\n-    Local<Uint8Array> cached_data_buf;\n-    bool produce_cached_data = false;\n-    Local<Context> parsing_context = context;\n-\n-    if (argc > 2) {\n-      // new ContextifyScript(code, filename, lineOffset, columnOffset,\n-      //                      cachedData, produceCachedData, parsingContext)\n-      CHECK_EQ(argc, 7);\n-      CHECK(args[2]->IsNumber());\n-      line_offset = args[2].As<Integer>();\n-      CHECK(args[3]->IsNumber());\n-      column_offset = args[3].As<Integer>();\n-      if (!args[4]->IsUndefined()) {\n-        CHECK(args[4]->IsUint8Array());\n-        cached_data_buf = args[4].As<Uint8Array>();\n-      }\n-      CHECK(args[5]->IsBoolean());\n-      produce_cached_data = args[5]->IsTrue();\n-      if (!args[6]->IsUndefined()) {\n-        CHECK(args[6]->IsObject());\n-        ContextifyContext* sandbox =\n-            ContextifyContext::ContextFromContextifiedSandbox(\n-                env, args[6].As<Object>());\n-        CHECK_NOT_NULL(sandbox);\n-        parsing_context = sandbox->context();\n-      }\n-    } else {\n-      line_offset = Integer::New(isolate, 0);\n-      column_offset = Integer::New(isolate, 0);\n-    }\n-\n-    ContextifyScript* contextify_script =\n-        new ContextifyScript(env, args.This());\n-\n-    if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(\n-            TRACING_CATEGORY_NODE2(vm, script)) != 0) {\n-      Utf8Value fn(isolate, filename);\n-      TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(\n-          TRACING_CATEGORY_NODE2(vm, script),\n-          \"ContextifyScript::New\",\n-          contextify_script,\n-          \"filename\", TRACE_STR_COPY(*fn));\n-    }\n+void ContextifyScript::Init(Environment* env, Local<Object> target) {\n+  HandleScope scope(env->isolate());\n+  Local<String> class_name =\n+      FIXED_ONE_BYTE_STRING(env->isolate(), \"ContextifyScript\");\n+\n+  Local<FunctionTemplate> script_tmpl = env->NewFunctionTemplate(New);\n+  script_tmpl->InstanceTemplate()->SetInternalFieldCount(1);\n+  script_tmpl->SetClassName(class_name);\n+  env->SetProtoMethod(script_tmpl, \"createCachedData\", CreateCachedData);\n+  env->SetProtoMethod(script_tmpl, \"runInContext\", RunInContext);\n+  env->SetProtoMethod(script_tmpl, \"runInThisContext\", RunInThisContext);\n+\n+  target->Set(class_name,\n+              script_tmpl->GetFunction(env->context()).ToLocalChecked());\n+  env->set_script_context_constructor_template(script_tmpl);\n+}\n \n-    ScriptCompiler::CachedData* cached_data = nullptr;\n-    if (!cached_data_buf.IsEmpty()) {\n-      ArrayBuffer::Contents contents = cached_data_buf->Buffer()->GetContents();\n-      uint8_t* data = static_cast<uint8_t*>(contents.Data());\n-      cached_data = new ScriptCompiler::CachedData(\n-          data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());\n-    }\n+void ContextifyScript::New(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n+  Local<Context> context = env->context();\n \n-    ScriptOrigin origin(filename, line_offset, column_offset);\n-    ScriptCompiler::Source source(code, origin, cached_data);\n-    ScriptCompiler::CompileOptions compile_options =\n-        ScriptCompiler::kNoCompileOptions;\n+  CHECK(args.IsConstructCall());\n \n-    if (source.GetCachedData() != nullptr)\n-      compile_options = ScriptCompiler::kConsumeCodeCache;\n+  const int argc = args.Length();\n+  CHECK_GE(argc, 2);\n \n-    TryCatch try_catch(isolate);\n-    Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n-    Context::Scope scope(parsing_context);\n+  CHECK(args[0]->IsString());\n+  Local<String> code = args[0].As<String>();\n \n-    MaybeLocal<UnboundScript> v8_script = ScriptCompiler::CompileUnboundScript(\n-        isolate,\n-        &source,\n-        compile_options);\n+  CHECK(args[1]->IsString());\n+  Local<String> filename = args[1].As<String>();\n \n-    if (v8_script.IsEmpty()) {\n-      DecorateErrorStack(env, try_catch);\n-      no_abort_scope.Close();\n-      try_catch.ReThrow();\n-      TRACE_EVENT_NESTABLE_ASYNC_END0(\n-          TRACING_CATEGORY_NODE2(vm, script),\n-          \"ContextifyScript::New\",\n-          contextify_script);\n-      return;\n+  Local<Integer> line_offset;\n+  Local<Integer> column_offset;\n+  Local<Uint8Array> cached_data_buf;\n+  bool produce_cached_data = false;\n+  Local<Context> parsing_context = context;\n+\n+  if (argc > 2) {\n+    // new ContextifyScript(code, filename, lineOffset, columnOffset,\n+    //                      cachedData, produceCachedData, parsingContext)\n+    CHECK_EQ(argc, 7);\n+    CHECK(args[2]->IsNumber());\n+    line_offset = args[2].As<Integer>();\n+    CHECK(args[3]->IsNumber());\n+    column_offset = args[3].As<Integer>();\n+    if (!args[4]->IsUndefined()) {\n+      CHECK(args[4]->IsUint8Array());\n+      cached_data_buf = args[4].As<Uint8Array>();\n     }\n-    contextify_script->script_.Reset(isolate, v8_script.ToLocalChecked());\n-\n-    if (compile_options == ScriptCompiler::kConsumeCodeCache) {\n-      args.This()->Set(\n-          env->cached_data_rejected_string(),\n-          Boolean::New(isolate, source.GetCachedData()->rejected));\n-    } else if (produce_cached_data) {\n-      const ScriptCompiler::CachedData* cached_data =\n-        ScriptCompiler::CreateCodeCache(v8_script.ToLocalChecked());\n-      bool cached_data_produced = cached_data != nullptr;\n-      if (cached_data_produced) {\n-        MaybeLocal<Object> buf = Buffer::Copy(\n-            env,\n-            reinterpret_cast<const char*>(cached_data->data),\n-            cached_data->length);\n-        args.This()->Set(env->cached_data_string(), buf.ToLocalChecked());\n-      }\n-      args.This()->Set(\n-          env->cached_data_produced_string(),\n-          Boolean::New(isolate, cached_data_produced));\n+    CHECK(args[5]->IsBoolean());\n+    produce_cached_data = args[5]->IsTrue();\n+    if (!args[6]->IsUndefined()) {\n+      CHECK(args[6]->IsObject());\n+      ContextifyContext* sandbox =\n+          ContextifyContext::ContextFromContextifiedSandbox(\n+              env, args[6].As<Object>());\n+      CHECK_NOT_NULL(sandbox);\n+      parsing_context = sandbox->context();\n     }\n-    TRACE_EVENT_NESTABLE_ASYNC_END0(\n+  } else {\n+    line_offset = Integer::New(isolate, 0);\n+    column_offset = Integer::New(isolate, 0);\n+  }\n+\n+  ContextifyScript* contextify_script =\n+      new ContextifyScript(env, args.This());\n+\n+  if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(\n+          TRACING_CATEGORY_NODE2(vm, script)) != 0) {\n+    Utf8Value fn(isolate, filename);\n+    TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(\n         TRACING_CATEGORY_NODE2(vm, script),\n         \"ContextifyScript::New\",\n-        contextify_script);\n+        contextify_script,\n+        \"filename\", TRACE_STR_COPY(*fn));\n   }\n \n-\n-  static bool InstanceOf(Environment* env, const Local<Value>& value) {\n-    return !value.IsEmpty() &&\n-           env->script_context_constructor_template()->HasInstance(value);\n+  ScriptCompiler::CachedData* cached_data = nullptr;\n+  if (!cached_data_buf.IsEmpty()) {\n+    ArrayBuffer::Contents contents = cached_data_buf->Buffer()->GetContents();\n+    uint8_t* data = static_cast<uint8_t*>(contents.Data());\n+    cached_data = new ScriptCompiler::CachedData(\n+        data + cached_data_buf->ByteOffset(), cached_data_buf->ByteLength());\n   }\n \n+  Local<PrimitiveArray> host_defined_options =\n+      PrimitiveArray::New(isolate, loader::HostDefinedOptions::kLength);\n+  host_defined_options->Set(isolate, loader::HostDefinedOptions::kType,\n+                            Number::New(isolate, loader::ScriptType::kScript));\n+  host_defined_options->Set(isolate, loader::HostDefinedOptions::kID,\n+                            Number::New(isolate, contextify_script->id()));\n+\n+  ScriptOrigin origin(filename,\n+                      line_offset,                          // line offset\n+                      column_offset,                        // column offset\n+                      False(isolate),                       // is cross origin\n+                      Local<Integer>(),                     // script id\n+                      Local<Value>(),                       // source map URL\n+                      False(isolate),                       // is opaque (?)\n+                      False(isolate),                       // is WASM\n+                      False(isolate),                       // is ES Module\n+                      host_defined_options);\n+  ScriptCompiler::Source source(code, origin, cached_data);\n+  ScriptCompiler::CompileOptions compile_options =\n+      ScriptCompiler::kNoCompileOptions;\n \n-  static void CreateCachedData(const FunctionCallbackInfo<Value>& args) {\n-    Environment* env = Environment::GetCurrent(args);\n-    ContextifyScript* wrapped_script;\n-    ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());\n-    Local<UnboundScript> unbound_script =\n-        PersistentToLocal(env->isolate(), wrapped_script->script_);\n-    std::unique_ptr<ScriptCompiler::CachedData> cached_data(\n-        ScriptCompiler::CreateCodeCache(unbound_script));\n-    if (!cached_data) {\n-      args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());\n-    } else {\n+  if (source.GetCachedData() != nullptr)\n+    compile_options = ScriptCompiler::kConsumeCodeCache;\n+\n+  TryCatch try_catch(isolate);\n+  Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n+  Context::Scope scope(parsing_context);\n+\n+  MaybeLocal<UnboundScript> v8_script = ScriptCompiler::CompileUnboundScript(\n+      isolate,\n+      &source,\n+      compile_options);\n+\n+  if (v8_script.IsEmpty()) {\n+    DecorateErrorStack(env, try_catch);\n+    no_abort_scope.Close();\n+    try_catch.ReThrow();\n+    TRACE_EVENT_NESTABLE_ASYNC_END0(\n+        TRACING_CATEGORY_NODE2(vm, script),\n+        \"ContextifyScript::New\",\n+        contextify_script);\n+    return;\n+  }\n+  contextify_script->script_.Reset(isolate, v8_script.ToLocalChecked());\n+\n+  if (compile_options == ScriptCompiler::kConsumeCodeCache) {\n+    args.This()->Set(\n+        env->cached_data_rejected_string(),\n+        Boolean::New(isolate, source.GetCachedData()->rejected));\n+  } else if (produce_cached_data) {\n+    const ScriptCompiler::CachedData* cached_data =\n+      ScriptCompiler::CreateCodeCache(v8_script.ToLocalChecked());\n+    bool cached_data_produced = cached_data != nullptr;\n+    if (cached_data_produced) {\n       MaybeLocal<Object> buf = Buffer::Copy(\n           env,\n           reinterpret_cast<const char*>(cached_data->data),\n           cached_data->length);\n-      args.GetReturnValue().Set(buf.ToLocalChecked());\n+      args.This()->Set(env->cached_data_string(), buf.ToLocalChecked());\n     }\n+    args.This()->Set(\n+        env->cached_data_produced_string(),\n+        Boolean::New(isolate, cached_data_produced));\n   }\n+  TRACE_EVENT_NESTABLE_ASYNC_END0(\n+      TRACING_CATEGORY_NODE2(vm, script),\n+      \"ContextifyScript::New\",\n+      contextify_script);\n+}\n \n+bool ContextifyScript::InstanceOf(Environment* env,\n+                                  const Local<Value>& value) {\n+  return !value.IsEmpty() &&\n+         env->script_context_constructor_template()->HasInstance(value);\n+}\n \n-  static void RunInThisContext(const FunctionCallbackInfo<Value>& args) {\n-    Environment* env = Environment::GetCurrent(args);\n+void ContextifyScript::CreateCachedData(\n+    const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  ContextifyScript* wrapped_script;\n+  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());\n+  Local<UnboundScript> unbound_script =\n+      PersistentToLocal(env->isolate(), wrapped_script->script_);\n+  std::unique_ptr<ScriptCompiler::CachedData> cached_data(\n+      ScriptCompiler::CreateCodeCache(unbound_script));\n+  if (!cached_data) {\n+    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());\n+  } else {\n+    MaybeLocal<Object> buf = Buffer::Copy(\n+        env,\n+        reinterpret_cast<const char*>(cached_data->data),\n+        cached_data->length);\n+    args.GetReturnValue().Set(buf.ToLocalChecked());\n+  }\n+}\n \n-    ContextifyScript* wrapped_script;\n-    ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());\n+void ContextifyScript::RunInThisContext(\n+    const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n \n-    TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(\n-        TRACING_CATEGORY_NODE2(vm, script), \"RunInThisContext\", wrapped_script);\n+  ContextifyScript* wrapped_script;\n+  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());\n \n-    CHECK_EQ(args.Length(), 3);\n+  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(\n+      TRACING_CATEGORY_NODE2(vm, script), \"RunInThisContext\", wrapped_script);\n \n-    CHECK(args[0]->IsNumber());\n-    int64_t timeout = args[0]->IntegerValue(env->context()).FromJust();\n+  CHECK_EQ(args.Length(), 3);\n \n-    CHECK(args[1]->IsBoolean());\n-    bool display_errors = args[1]->IsTrue();\n+  CHECK(args[0]->IsNumber());\n+  int64_t timeout = args[0]->IntegerValue(env->context()).FromJust();\n \n-    CHECK(args[2]->IsBoolean());\n-    bool break_on_sigint = args[2]->IsTrue();\n+  CHECK(args[1]->IsBoolean());\n+  bool display_errors = args[1]->IsTrue();\n \n-    // Do the eval within this context\n-    EvalMachine(env, timeout, display_errors, break_on_sigint, args);\n+  CHECK(args[2]->IsBoolean());\n+  bool break_on_sigint = args[2]->IsTrue();\n \n-    TRACE_EVENT_NESTABLE_ASYNC_END0(\n-        TRACING_CATEGORY_NODE2(vm, script), \"RunInThisContext\", wrapped_script);\n-  }\n+  // Do the eval within this context\n+  EvalMachine(env, timeout, display_errors, break_on_sigint, args);\n \n-  static void RunInContext(const FunctionCallbackInfo<Value>& args) {\n-    Environment* env = Environment::GetCurrent(args);\n+  TRACE_EVENT_NESTABLE_ASYNC_END0(\n+      TRACING_CATEGORY_NODE2(vm, script), \"RunInThisContext\", wrapped_script);\n+}\n \n-    ContextifyScript* wrapped_script;\n-    ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());\n+void ContextifyScript::RunInContext(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n \n-    CHECK_EQ(args.Length(), 4);\n+  ContextifyScript* wrapped_script;\n+  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());\n \n-    CHECK(args[0]->IsObject());\n-    Local<Object> sandbox = args[0].As<Object>();\n-    // Get the context from the sandbox\n-    ContextifyContext* contextify_context =\n-        ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);\n-    CHECK_NOT_NULL(contextify_context);\n+  CHECK_EQ(args.Length(), 4);\n \n-    if (contextify_context->context().IsEmpty())\n-      return;\n+  CHECK(args[0]->IsObject());\n+  Local<Object> sandbox = args[0].As<Object>();\n+  // Get the context from the sandbox\n+  ContextifyContext* contextify_context =\n+      ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);\n+  CHECK_NOT_NULL(contextify_context);\n \n-    TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(\n-        TRACING_CATEGORY_NODE2(vm, script), \"RunInContext\", wrapped_script);\n+  if (contextify_context->context().IsEmpty())\n+    return;\n \n-    CHECK(args[1]->IsNumber());\n-    int64_t timeout = args[1]->IntegerValue(env->context()).FromJust();\n+  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(\n+      TRACING_CATEGORY_NODE2(vm, script), \"RunInContext\", wrapped_script);\n \n-    CHECK(args[2]->IsBoolean());\n-    bool display_errors = args[2]->IsTrue();\n+  CHECK(args[1]->IsNumber());\n+  int64_t timeout = args[1]->IntegerValue(env->context()).FromJust();\n \n-    CHECK(args[3]->IsBoolean());\n-    bool break_on_sigint = args[3]->IsTrue();\n+  CHECK(args[2]->IsBoolean());\n+  bool display_errors = args[2]->IsTrue();\n \n-    // Do the eval within the context\n-    Context::Scope context_scope(contextify_context->context());\n-    EvalMachine(contextify_context->env(),\n-                timeout,\n-                display_errors,\n-                break_on_sigint,\n-                args);\n+  CHECK(args[3]->IsBoolean());\n+  bool break_on_sigint = args[3]->IsTrue();\n+\n+  // Do the eval within the context\n+  Context::Scope context_scope(contextify_context->context());\n+  EvalMachine(contextify_context->env(),\n+              timeout,\n+              display_errors,\n+              break_on_sigint,\n+              args);\n+\n+  TRACE_EVENT_NESTABLE_ASYNC_END0(\n+      TRACING_CATEGORY_NODE2(vm, script), \"RunInContext\", wrapped_script);\n+}\n \n-    TRACE_EVENT_NESTABLE_ASYNC_END0(\n-        TRACING_CATEGORY_NODE2(vm, script), \"RunInContext\", wrapped_script);\n-  }\n+void ContextifyScript::DecorateErrorStack(\n+    Environment* env, const TryCatch& try_catch) {\n+  Local<Value> exception = try_catch.Exception();\n \n-  static void DecorateErrorStack(Environment* env, const TryCatch& try_catch) {\n-    Local<Value> exception = try_catch.Exception();\n+  if (!exception->IsObject())\n+    return;\n \n-    if (!exception->IsObject())\n-      return;\n+  Local<Object> err_obj = exception.As<Object>();\n \n-    Local<Object> err_obj = exception.As<Object>();\n+  if (IsExceptionDecorated(env, err_obj))\n+    return;\n \n-    if (IsExceptionDecorated(env, err_obj))\n-      return;\n+  AppendExceptionLine(env, exception, try_catch.Message(), CONTEXTIFY_ERROR);\n+  Local<Value> stack = err_obj->Get(env->stack_string());\n+  MaybeLocal<Value> maybe_value =\n+      err_obj->GetPrivate(\n+          env->context(),\n+          env->arrow_message_private_symbol());\n \n-    AppendExceptionLine(env, exception, try_catch.Message(), CONTEXTIFY_ERROR);\n-    Local<Value> stack = err_obj->Get(env->stack_string());\n-    MaybeLocal<Value> maybe_value =\n-        err_obj->GetPrivate(\n-            env->context(),\n-            env->arrow_message_private_symbol());\n+  Local<Value> arrow;\n+  if (!(maybe_value.ToLocal(&arrow) && arrow->IsString())) {\n+    return;\n+  }\n \n-    Local<Value> arrow;\n-    if (!(maybe_value.ToLocal(&arrow) && arrow->IsString())) {\n-      return;\n-    }\n+  if (stack.IsEmpty() || !stack->IsString()) {\n+    return;\n+  }\n \n-    if (stack.IsEmpty() || !stack->IsString()) {\n-      return;\n-    }\n+  Local<String> decorated_stack = String::Concat(\n+      env->isolate(),\n+      String::Concat(env->isolate(),\n+                     arrow.As<String>(),\n+                     FIXED_ONE_BYTE_STRING(env->isolate(), \"\\n\")),\n+      stack.As<String>());\n+  err_obj->Set(env->stack_string(), decorated_stack);\n+  err_obj->SetPrivate(\n+      env->context(),\n+      env->decorated_private_symbol(),\n+      True(env->isolate()));\n+}\n \n-    Local<String> decorated_stack = String::Concat(\n-        env->isolate(),\n-        String::Concat(env->isolate(),\n-                       arrow.As<String>(),\n-                       FIXED_ONE_BYTE_STRING(env->isolate(), \"\\n\")),\n-        stack.As<String>());\n-    err_obj->Set(env->stack_string(), decorated_stack);\n-    err_obj->SetPrivate(\n-        env->context(),\n-        env->decorated_private_symbol(),\n-        True(env->isolate()));\n+bool ContextifyScript::EvalMachine(Environment* env,\n+                                   const int64_t timeout,\n+                                   const bool display_errors,\n+                                   const bool break_on_sigint,\n+                                   const FunctionCallbackInfo<Value>& args) {\n+  if (!env->can_call_into_js())\n+    return false;\n+  if (!ContextifyScript::InstanceOf(env, args.Holder())) {\n+    env->ThrowTypeError(\n+        \"Script methods can only be called on script instances.\");\n+    return false;\n+  }\n+  TryCatch try_catch(env->isolate());\n+  ContextifyScript* wrapped_script;\n+  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder(), false);\n+  Local<UnboundScript> unbound_script =\n+      PersistentToLocal(env->isolate(), wrapped_script->script_);\n+  Local<Script> script = unbound_script->BindToCurrentContext();\n+\n+  MaybeLocal<Value> result;\n+  bool timed_out = false;\n+  bool received_signal = false;\n+  if (break_on_sigint && timeout != -1) {\n+    Watchdog wd(env->isolate(), timeout, &timed_out);\n+    SigintWatchdog swd(env->isolate(), &received_signal);\n+    result = script->Run(env->context());\n+  } else if (break_on_sigint) {\n+    SigintWatchdog swd(env->isolate(), &received_signal);\n+    result = script->Run(env->context());\n+  } else if (timeout != -1) {\n+    Watchdog wd(env->isolate(), timeout, &timed_out);\n+    result = script->Run(env->context());\n+  } else {\n+    result = script->Run(env->context());\n   }\n \n-  static bool EvalMachine(Environment* env,\n-                          const int64_t timeout,\n-                          const bool display_errors,\n-                          const bool break_on_sigint,\n-                          const FunctionCallbackInfo<Value>& args) {\n-    if (!env->can_call_into_js())\n-      return false;\n-    if (!ContextifyScript::InstanceOf(env, args.Holder())) {\n-      env->ThrowTypeError(\n-          \"Script methods can only be called on script instances.\");\n-      return false;\n-    }\n-    TryCatch try_catch(env->isolate());\n-    ContextifyScript* wrapped_script;\n-    ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder(), false);\n-    Local<UnboundScript> unbound_script =\n-        PersistentToLocal(env->isolate(), wrapped_script->script_);\n-    Local<Script> script = unbound_script->BindToCurrentContext();\n-\n-    MaybeLocal<Value> result;\n-    bool timed_out = false;\n-    bool received_signal = false;\n-    if (break_on_sigint && timeout != -1) {\n-      Watchdog wd(env->isolate(), timeout, &timed_out);\n-      SigintWatchdog swd(env->isolate(), &received_signal);\n-      result = script->Run(env->context());\n-    } else if (break_on_sigint) {\n-      SigintWatchdog swd(env->isolate(), &received_signal);\n-      result = script->Run(env->context());\n-    } else if (timeout != -1) {\n-      Watchdog wd(env->isolate(), timeout, &timed_out);\n-      result = script->Run(env->context());\n-    } else {\n-      result = script->Run(env->context());\n+  // Convert the termination exception into a regular exception.\n+  if (timed_out || received_signal) {\n+    env->isolate()->CancelTerminateExecution();\n+    // It is possible that execution was terminated by another timeout in\n+    // which this timeout is nested, so check whether one of the watchdogs\n+    // from this invocation is responsible for termination.\n+    if (timed_out) {\n+      node::THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);\n+    } else if (received_signal) {\n+      node::THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);\n     }\n+  }\n \n-    // Convert the termination exception into a regular exception.\n-    if (timed_out || received_signal) {\n-      env->isolate()->CancelTerminateExecution();\n-      // It is possible that execution was terminated by another timeout in\n-      // which this timeout is nested, so check whether one of the watchdogs\n-      // from this invocation is responsible for termination.\n-      if (timed_out) {\n-        node::THROW_ERR_SCRIPT_EXECUTION_TIMEOUT(env, timeout);\n-      } else if (received_signal) {\n-        node::THROW_ERR_SCRIPT_EXECUTION_INTERRUPTED(env);\n-      }\n+  if (try_catch.HasCaught()) {\n+    if (!timed_out && !received_signal && display_errors) {\n+      // We should decorate non-termination exceptions\n+      DecorateErrorStack(env, try_catch);\n     }\n \n-    if (try_catch.HasCaught()) {\n-      if (!timed_out && !received_signal && display_errors) {\n-        // We should decorate non-termination exceptions\n-        DecorateErrorStack(env, try_catch);\n-      }\n+    // If there was an exception thrown during script execution, re-throw it.\n+    // If one of the above checks threw, re-throw the exception instead of\n+    // letting try_catch catch it.\n+    // If execution has been terminated, but not by one of the watchdogs from\n+    // this invocation, this will re-throw a `null` value.\n+    try_catch.ReThrow();\n \n-      // If there was an exception thrown during script execution, re-throw it.\n-      // If one of the above checks threw, re-throw the exception instead of\n-      // letting try_catch catch it.\n-      // If execution has been terminated, but not by one of the watchdogs from\n-      // this invocation, this will re-throw a `null` value.\n-      try_catch.ReThrow();\n+    return false;\n+  }\n \n-      return false;\n-    }\n+  args.GetReturnValue().Set(result.ToLocalChecked());\n+  return true;\n+}\n \n-    args.GetReturnValue().Set(result.ToLocalChecked());\n-    return true;\n-  }\n+\n+ContextifyScript::ContextifyScript(Environment* env, Local<Object> object)\n+    : BaseObject(env, object),\n+      id_(env->get_next_script_id()) {\n+  MakeWeak();\n+  env->id_to_script_map.emplace(id_, this);\n+}\n \n \n-  ContextifyScript(Environment* env, Local<Object> object)\n-      : BaseObject(env, object) {\n-    MakeWeak();\n-  }\n-};\n+ContextifyScript::~ContextifyScript() {\n+  env()->id_to_script_map.erase(id_);\n+}\n \n \n void ContextifyContext::CompileFunction("
        },
        {
            "sha": "6d6dc12b4b8d5db1801e671a140bc72f6f16aef9",
            "filename": "src/node_contextify.h",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fnode_contextify.h",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/src%2Fnode_contextify.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.h?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -5,6 +5,7 @@\n \n #include \"node_internals.h\"\n #include \"node_context_data.h\"\n+#include \"base_object-inl.h\"\n \n namespace node {\n namespace contextify {\n@@ -102,6 +103,37 @@ class ContextifyContext {\n   Persistent<v8::Context> context_;\n };\n \n+class ContextifyScript : public BaseObject {\n+ public:\n+  SET_NO_MEMORY_INFO()\n+  SET_MEMORY_INFO_NAME(ContextifyScript)\n+  SET_SELF_SIZE(ContextifyScript)\n+\n+  ContextifyScript(Environment* env, v8::Local<v8::Object> object);\n+  ~ContextifyScript();\n+\n+  static void Init(Environment* env, v8::Local<v8::Object> target);\n+  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static bool InstanceOf(Environment* env, const v8::Local<v8::Value>& args);\n+  static void CreateCachedData(\n+      const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void RunInThisContext(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void RunInContext(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void DecorateErrorStack(Environment* env,\n+                                 const v8::TryCatch& try_catch);\n+  static bool EvalMachine(Environment* env,\n+                          const int64_t timeout,\n+                          const bool display_errors,\n+                          const bool break_on_sigint,\n+                          const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n+  inline uint32_t id() { return id_; }\n+\n+ private:\n+  node::Persistent<v8::UnboundScript> script_;\n+  uint32_t id_;\n+};\n+\n }  // namespace contextify\n }  // namespace node\n "
        },
        {
            "sha": "6cbbd0ac67dd660c6a357ebac641328925e9ad98",
            "filename": "test/es-module/test-esm-dynamic-import.js",
            "status": "modified",
            "additions": 0,
            "deletions": 35,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/test%2Fes-module%2Ftest-esm-dynamic-import.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/test%2Fes-module%2Ftest-esm-dynamic-import.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fes-module%2Ftest-esm-dynamic-import.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -75,38 +75,3 @@ function expectFsNamespace(result) {\n   expectMissingModuleError(import(\"node:fs\"));\n   expectMissingModuleError(import('http://example.com/foo.js'));\n })();\n-\n-// vm.runInThisContext:\n-// * Supports built-ins, always\n-// * Supports imports if the script has a known defined origin\n-(function testRunInThisContext() {\n-  // Succeeds because it's got an valid base url\n-  expectFsNamespace(vm.runInThisContext(`import(\"fs\")`, {\n-    filename: __filename,\n-  }));\n-  expectOkNamespace(vm.runInThisContext(`import(\"${relativePath}\")`, {\n-    filename: __filename,\n-  }));\n-  // Rejects because it's got an invalid referrer URL.\n-  // TODO(jkrems): Arguably the first two (built-in + absolute URL) could work\n-  // with some additional effort.\n-  expectInvalidReferrerError(vm.runInThisContext('import(\"fs\")'));\n-  expectInvalidReferrerError(vm.runInThisContext(`import(\"${targetURL}\")`));\n-  expectInvalidReferrerError(vm.runInThisContext(`import(\"${relativePath}\")`));\n-})();\n-\n-// vm.runInNewContext is currently completely unsupported, pending well-defined\n-// semantics for per-context/realm module maps in node.\n-(function testRunInNewContext() {\n-  // Rejects because it's running in the wrong context\n-  expectInvalidContextError(\n-    vm.runInNewContext(`import(\"${targetURL}\")`, undefined, {\n-      filename: __filename,\n-    })\n-  );\n-\n-  // Rejects because it's running in the wrong context\n-  expectInvalidContextError(vm.runInNewContext(`import(\"fs\")`, undefined, {\n-    filename: __filename,\n-  }));\n-})();"
        },
        {
            "sha": "885a58ff9f86fc621f02c65d21575090d042c69a",
            "filename": "test/parallel/test-bootstrap-modules.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/test%2Fparallel%2Ftest-bootstrap-modules.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/test%2Fparallel%2Ftest-bootstrap-modules.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-bootstrap-modules.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -11,4 +11,4 @@ const list = process.moduleLoadList.slice();\n \n const assert = require('assert');\n \n-assert(list.length <= 76, list);\n+assert(list.length <= 77, list);"
        },
        {
            "sha": "5c0f6f81fa842b5ee45596ee73891eb8f8ab566c",
            "filename": "test/parallel/test-vm-module-dynamic-import.js",
            "status": "modified",
            "additions": 64,
            "deletions": 7,
            "changes": 71,
            "blob_url": "https://github.com/nodejs/node/blob/4c37df779cf944b5666fc72e2a27fbf2e745881f/test%2Fparallel%2Ftest-vm-module-dynamic-import.js",
            "raw_url": "https://github.com/nodejs/node/raw/4c37df779cf944b5666fc72e2a27fbf2e745881f/test%2Fparallel%2Ftest-vm-module-dynamic-import.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-module-dynamic-import.js?ref=4c37df779cf944b5666fc72e2a27fbf2e745881f",
            "patch": "@@ -5,11 +5,9 @@\n const common = require('../common');\n \n const assert = require('assert');\n-const { SourceTextModule, createContext } = require('vm');\n+const { Script, SourceTextModule, createContext } = require('vm');\n \n-const finished = common.mustCall();\n-\n-(async function() {\n+async function testNoCallback() {\n   const m = new SourceTextModule('import(\"foo\")', { context: createContext() });\n   await m.link(common.mustNotCall());\n   m.instantiate();\n@@ -19,8 +17,67 @@ const finished = common.mustCall();\n     await result;\n   } catch (err) {\n     threw = true;\n-    assert.strictEqual(err.message, 'import() called outside of main context');\n+    assert.strictEqual(err.code, 'ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING');\n   }\n   assert(threw);\n-  finished();\n-}());\n+}\n+\n+async function test() {\n+  const foo = new SourceTextModule('export const a = 1;');\n+  await foo.link(common.mustNotCall());\n+  foo.instantiate();\n+  await foo.evaluate();\n+\n+  {\n+    const s = new Script('import(\"foo\")', {\n+      importModuleDynamically: common.mustCall((specifier, wrap) => {\n+        assert.strictEqual(specifier, 'foo');\n+        assert.strictEqual(wrap, s);\n+        return foo;\n+      }),\n+    });\n+\n+    const result = s.runInThisContext();\n+    assert.strictEqual(foo.namespace, await result);\n+  }\n+\n+  {\n+    const m = new SourceTextModule('import(\"foo\")', {\n+      importModuleDynamically: common.mustCall((specifier, wrap) => {\n+        assert.strictEqual(specifier, 'foo');\n+        assert.strictEqual(wrap, m);\n+        return foo;\n+      }),\n+    });\n+    await m.link(common.mustNotCall());\n+    m.instantiate();\n+    const { result } = await m.evaluate();\n+    assert.strictEqual(foo.namespace, await result);\n+  }\n+}\n+\n+async function testInvalid() {\n+  const m = new SourceTextModule('import(\"foo\")', {\n+    importModuleDynamically: common.mustCall((specifier, wrap) => {\n+      return 5;\n+    }),\n+  });\n+  await m.link(common.mustNotCall());\n+  m.instantiate();\n+  const { result } = await m.evaluate();\n+  await result.catch(common.mustCall((e) => {\n+    assert.strictEqual(e.code, 'ERR_VM_MODULE_NOT_MODULE');\n+  }));\n+}\n+\n+const done = common.mustCallAtLeast(3);\n+(async function() {\n+  await testNoCallback();\n+  done();\n+\n+  await test();\n+  done();\n+\n+  await testInvalid();\n+  done();\n+}()).then(common.mustCall());"
        }
    ],
    "stats": {
        "total": 1107,
        "additions": 674,
        "deletions": 433
    }
}