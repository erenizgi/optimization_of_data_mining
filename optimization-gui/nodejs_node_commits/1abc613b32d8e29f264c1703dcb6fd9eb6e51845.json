{
    "author": "BridgeAR",
    "message": "util: properly indent special properties\n\nCalling `formatValue()` directly requires the indentation level to\nbe set manually. This was not the case so far in most cases and the\nindentation was off in all these cases.\n\nPR-URL: https://github.com/nodejs/node/pull/22291\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "1abc613b32d8e29f264c1703dcb6fd9eb6e51845",
    "files": [
        {
            "sha": "240489ad0d47725e531f3f93aae33280e8c107f5",
            "filename": "lib/util.js",
            "status": "modified",
            "additions": 28,
            "deletions": 9,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/1abc613b32d8e29f264c1703dcb6fd9eb6e51845/lib%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/1abc613b32d8e29f264c1703dcb6fd9eb6e51845/lib%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Futil.js?ref=1abc613b32d8e29f264c1703dcb6fd9eb6e51845",
            "patch": "@@ -543,6 +543,9 @@ function findTypedConstructor(value) {\n \n const getBoxedValue = formatPrimitive.bind(null, stylizeNoColor);\n \n+// Note: using `formatValue` directly requires the indentation level to be\n+// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n+// value afterwards again.\n function formatValue(ctx, value, recurseTimes) {\n   // Primitive types cannot have properties\n   if (typeof value !== 'object' && typeof value !== 'function') {\n@@ -1063,17 +1066,18 @@ function formatTypedArray(ctx, value, recurseTimes, keys) {\n     output[i] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n   if (ctx.showHidden) {\n     // .buffer goes last, it's not a primitive like the others.\n-    const extraKeys = [\n+    ctx.indentationLvl += 2;\n+    for (const key of [\n       'BYTES_PER_ELEMENT',\n       'length',\n       'byteLength',\n       'byteOffset',\n       'buffer'\n-    ];\n-    for (i = 0; i < extraKeys.length; i++) {\n-      const str = formatValue(ctx, value[extraKeys[i]], recurseTimes);\n-      output.push(`[${extraKeys[i]}]: ${str}`);\n+    ]) {\n+      const str = formatValue(ctx, value[key], recurseTimes);\n+      output.push(`[${key}]: ${str}`);\n     }\n+    ctx.indentationLvl -= 2;\n   }\n   // TypedArrays cannot have holes. Therefore it is safe to assume that all\n   // extra keys are indexed after value.length.\n@@ -1086,8 +1090,11 @@ function formatTypedArray(ctx, value, recurseTimes, keys) {\n function formatSet(ctx, value, recurseTimes, keys) {\n   const output = new Array(value.size + keys.length + (ctx.showHidden ? 1 : 0));\n   let i = 0;\n-  for (const v of value)\n+  ctx.indentationLvl += 2;\n+  for (const v of value) {\n     output[i++] = formatValue(ctx, v, recurseTimes);\n+  }\n+  ctx.indentationLvl -= 2;\n   // With `showHidden`, `length` will display as a hidden property for\n   // arrays. For consistency's sake, do the same for `size`, even though this\n   // property isn't selected by Object.getOwnPropertyNames().\n@@ -1102,9 +1109,12 @@ function formatSet(ctx, value, recurseTimes, keys) {\n function formatMap(ctx, value, recurseTimes, keys) {\n   const output = new Array(value.size + keys.length + (ctx.showHidden ? 1 : 0));\n   let i = 0;\n-  for (const [k, v] of value)\n+  ctx.indentationLvl += 2;\n+  for (const [k, v] of value) {\n     output[i++] = `${formatValue(ctx, k, recurseTimes)} => ` +\n-      formatValue(ctx, v, recurseTimes);\n+                  formatValue(ctx, v, recurseTimes);\n+  }\n+  ctx.indentationLvl -= 2;\n   // See comment in formatSet\n   if (ctx.showHidden)\n     output[i++] = `[size]: ${ctx.stylize(`${value.size}`, 'number')}`;\n@@ -1118,8 +1128,11 @@ function formatSetIterInner(ctx, value, recurseTimes, keys, entries, state) {\n   const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n   const maxLength = Math.min(maxArrayLength, entries.length);\n   let output = new Array(maxLength);\n-  for (var i = 0; i < maxLength; ++i)\n+  ctx.indentationLvl += 2;\n+  for (var i = 0; i < maxLength; i++) {\n     output[i] = formatValue(ctx, entries[i], recurseTimes);\n+  }\n+  ctx.indentationLvl -= 2;\n   if (state === kWeak) {\n     // Sort all entries to have a halfway reliable output (if more entries than\n     // retrieved ones exist, we can not reliably return the same output).\n@@ -1150,11 +1163,13 @@ function formatMapIterInner(ctx, value, recurseTimes, keys, entries, state) {\n     end = ' ]';\n     middle = ', ';\n   }\n+  ctx.indentationLvl += 2;\n   for (; i < maxLength; i++) {\n     const pos = i * 2;\n     output[i] = `${start}${formatValue(ctx, entries[pos], recurseTimes)}` +\n       `${middle}${formatValue(ctx, entries[pos + 1], recurseTimes)}${end}`;\n   }\n+  ctx.indentationLvl -= 2;\n   if (state === kWeak) {\n     // Sort all entries to have a halfway reliable output (if more entries\n     // than retrieved ones exist, we can not reliably return the same output).\n@@ -1199,7 +1214,11 @@ function formatPromise(ctx, value, recurseTimes, keys) {\n   if (state === kPending) {\n     output = ['<pending>'];\n   } else {\n+    // Using `formatValue` is correct here without the need to fix the\n+    // indentation level.\n+    ctx.indentationLvl += 2;\n     const str = formatValue(ctx, result, recurseTimes);\n+    ctx.indentationLvl -= 2;\n     output = [state === kRejected ? `<rejected> ${str}` : str];\n   }\n   for (var n = 0; n < keys.length; n++) {"
        },
        {
            "sha": "4a79d050cf99b35f5bb1edae80b83d13f850c354",
            "filename": "test/parallel/test-util-inspect.js",
            "status": "modified",
            "additions": 102,
            "deletions": 2,
            "changes": 104,
            "blob_url": "https://github.com/nodejs/node/blob/1abc613b32d8e29f264c1703dcb6fd9eb6e51845/test%2Fparallel%2Ftest-util-inspect.js",
            "raw_url": "https://github.com/nodejs/node/raw/1abc613b32d8e29f264c1703dcb6fd9eb6e51845/test%2Fparallel%2Ftest-util-inspect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-util-inspect.js?ref=1abc613b32d8e29f264c1703dcb6fd9eb6e51845",
            "patch": "@@ -179,7 +179,6 @@ for (const showHidden of [true, false]) {\n                      '  y: 1337 }');\n }\n \n-\n [ Float32Array,\n   Float64Array,\n   Int16Array,\n@@ -195,7 +194,7 @@ for (const showHidden of [true, false]) {\n   array[0] = 65;\n   array[1] = 97;\n   assert.strictEqual(\n-    util.inspect(array, true),\n+    util.inspect(array, { showHidden: true }),\n     `${constructor.name} [\\n` +\n       '  65,\\n' +\n       '  97,\\n' +\n@@ -1362,6 +1361,107 @@ util.inspect(process);\n   assert.strictEqual(out, expect);\n }\n \n+// Check compact indentation.\n+{\n+  const typed = new Uint8Array();\n+  typed.buffer.foo = true;\n+  const set = new Set([[1, 2]]);\n+  const promise = Promise.resolve([[1, set]]);\n+  const map = new Map([[promise, typed]]);\n+  map.set(set.values(), map.values());\n+\n+  let out = util.inspect(map, { compact: false, showHidden: true, depth: 9 });\n+  let expected = [\n+    'Map {',\n+    '  Promise {',\n+    '    [',\n+    '      [',\n+    '        1,',\n+    '        Set {',\n+    '          [',\n+    '            1,',\n+    '            2,',\n+    '            [length]: 2',\n+    '          ],',\n+    '          [size]: 1',\n+    '        },',\n+    '        [length]: 2',\n+    '      ],',\n+    '      [length]: 1',\n+    '    ]',\n+    '  } => Uint8Array [',\n+    '    [BYTES_PER_ELEMENT]: 1,',\n+    '    [length]: 0,',\n+    '    [byteLength]: 0,',\n+    '    [byteOffset]: 0,',\n+    '    [buffer]: ArrayBuffer {',\n+    '      byteLength: 0,',\n+    '      foo: true',\n+    '    }',\n+    '  ],',\n+    '  [Set Iterator] {',\n+    '    [',\n+    '      1,',\n+    '      2,',\n+    '      [length]: 2',\n+    '    ]',\n+    '  } => [Map Iterator] {',\n+    '    Uint8Array [',\n+    '      [BYTES_PER_ELEMENT]: 1,',\n+    '      [length]: 0,',\n+    '      [byteLength]: 0,',\n+    '      [byteOffset]: 0,',\n+    '      [buffer]: ArrayBuffer {',\n+    '        byteLength: 0,',\n+    '        foo: true',\n+    '      }',\n+    '    ],',\n+    '    [Circular]',\n+    '  },',\n+    '  [size]: 2',\n+    '}'\n+  ].join('\\n');\n+\n+  assert.strict.equal(out, expected);\n+\n+  out = util.inspect(map, { showHidden: true, depth: 9, breakLength: 4 });\n+  expected = [\n+    'Map {',\n+    '  Promise {',\n+    '    [ [ 1,',\n+    '        Set {',\n+    '          [ 1,',\n+    '            2,',\n+    '            [length]: 2 ],',\n+    '          [size]: 1 },',\n+    '        [length]: 2 ],',\n+    '      [length]: 1 ] } => Uint8Array [',\n+    '    [BYTES_PER_ELEMENT]: 1,',\n+    '    [length]: 0,',\n+    '    [byteLength]: 0,',\n+    '    [byteOffset]: 0,',\n+    '    [buffer]: ArrayBuffer {',\n+    '      byteLength: 0,',\n+    '      foo: true } ],',\n+    '  [Set Iterator] {',\n+    '    [ 1,',\n+    '      2,',\n+    '      [length]: 2 ] } => [Map Iterator] {',\n+    '    Uint8Array [',\n+    '      [BYTES_PER_ELEMENT]: 1,',\n+    '      [length]: 0,',\n+    '      [byteLength]: 0,',\n+    '      [byteOffset]: 0,',\n+    '      [buffer]: ArrayBuffer {',\n+    '        byteLength: 0,',\n+    '        foo: true } ],',\n+    '    [Circular] },',\n+    '  [size]: 2 }'\n+  ].join('\\n');\n+\n+  assert.strict.equal(out, expected);\n+}\n+\n { // Test WeakMap\n   const obj = {};\n   const arr = [];"
        }
    ],
    "stats": {
        "total": 141,
        "additions": 130,
        "deletions": 11
    }
}