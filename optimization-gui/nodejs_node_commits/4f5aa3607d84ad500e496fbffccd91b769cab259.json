{
    "author": "mcollina",
    "message": "doc: added symbols guidelines\n\nPR-URL: https://github.com/nodejs/node/pull/22684\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>",
    "sha": "4f5aa3607d84ad500e496fbffccd91b769cab259",
    "files": [
        {
            "sha": "1e79e1a4e4b11c639ca7144de5949ec69308dc19",
            "filename": "doc/guides/using-symbols.md",
            "status": "added",
            "additions": 73,
            "deletions": 0,
            "changes": 73,
            "blob_url": "https://github.com/nodejs/node/blob/4f5aa3607d84ad500e496fbffccd91b769cab259/doc%2Fguides%2Fusing-symbols.md",
            "raw_url": "https://github.com/nodejs/node/raw/4f5aa3607d84ad500e496fbffccd91b769cab259/doc%2Fguides%2Fusing-symbols.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fguides%2Fusing-symbols.md?ref=4f5aa3607d84ad500e496fbffccd91b769cab259",
            "patch": "@@ -0,0 +1,73 @@\n+# Using global symbols\n+\n+ES6 introduced a new type: `Symbol`. This new type is _immutable_, and\n+it is often used for metaprogramming purposes, as it can be used as\n+property keys like string. There are two types of\n+symbols, local and global.\n+Symbol-keyed properties of an object are not included in the output of\n+`JSON.stringify()`, but the `util.inspect()` function includes them by\n+default.\n+\n+Learn more about symbols at\n+https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol.\n+\n+## `Symbol(string)`\n+\n+Symbols created via `Symbol(string)` are local to the caller function.\n+Note that `Symbol('hello') !== Symbol('hello')`.\n+For this reason, we often use them to simulate private fields, like so:\n+\n+```js\n+const kField = Symbol('kField');\n+\n+console.log(kField === Symbol('kField')); // false\n+\n+class MyObject {\n+  constructor() {\n+    this[kField] = 'something';\n+  }\n+}\n+\n+module.exports.MyObject = MyObject;\n+```\n+\n+Note that Symbols are not _fully private_, as the data could be accessed\n+anyway:\n+\n+```js\n+for (const s of Object.getOwnPropertySymbols(obj)) {\n+  const desc = s.toString().replace(/Symbol\\((.*)\\)$/, '$1');\n+  if (desc === 'kField') {\n+    console.log(obj[s]); // 'something'\n+  }\n+}\n+```\n+\n+Local symbols make it harder for developers to monkey patch/access\n+private fields, as they require more work than a property prefixed\n+with an `_`. Monkey patching private API that were not designed to be\n+monkey-patchable make maintaining and evolving Node.js harder, as private\n+properties are not documented and can change within a patch release.\n+Some extremely popular modules in the ecosystem monkey patch some\n+internals, making it impossible for us to update and improve those\n+areas without causing issues for a significant amount of users.\n+\n+## `Symbol.for`\n+\n+Symbols created with `Symbol.for(string)` are global and unique to the\n+same V8 Isolate. On the first call to `Symbol.for(string)` a symbol is\n+stored in a global registry and easily retrieved for every call of\n+`Symbol.for(string)`. However, this might cause problems when two module\n+authors use the same symbol\n+for different reasons.\n+\n+```js\n+const s = Symbol.for('hello');\n+console.log(s === Symbol.for('hello'));\n+```\n+\n+In the Node.js runtime we prefix all our global symbols with `nodejs.`,\n+e.g. `Symbol.for('nodejs.hello')`.\n+\n+Global symbols should be preferred when a developer-facing interface is\n+needed to allow behavior customization, i.e., metaprogramming."
        }
    ],
    "stats": {
        "total": 73,
        "additions": 73,
        "deletions": 0
    }
}