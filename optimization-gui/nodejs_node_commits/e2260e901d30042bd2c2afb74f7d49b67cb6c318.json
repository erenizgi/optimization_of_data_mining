{
    "author": "rvagg",
    "message": "deps: float 415c3356 from openssl (DSA vulnerability)\n\nLow severity timing vulnerability in the DSA signature algorithm\n\nPublicly disclosed but unreleased, pending OpenSSL 1.1.0j, not deemed\nsevere enough to be assigned a CVE #.\n\nRef: https://github.com/openssl/openssl/pull/7487\nPR-URL: https://github.com/nodejs/node/pull/???\nUpstream: https://github.com/openssl/openssl/commit/415c3356\n\nOriginal commit message:\n\n    DSA mod inverse fix\n\n    There is a side channel attack against the division used to calculate one of\n    the modulo inverses in the DSA algorithm.  This change takes advantage of the\n    primality of the modulo and Fermat's little theorem to calculate the inverse\n    without leaking information.\n\n    Thanks to Samuel Weiser for finding and reporting this.\n\n    Reviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>\n    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>\n    (Merged from https://github.com/openssl/openssl/pull/7487)\n\nPR-URL: https://github.com/nodejs/node/pull/23965\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>\nReviewed-By: Franziska Hinkelmann <franziska.hinkelmann@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "e2260e901d30042bd2c2afb74f7d49b67cb6c318",
    "files": [
        {
            "sha": "3b657d5d3d13f414839d348dd49cbaf28b04951c",
            "filename": "deps/openssl/openssl/crypto/dsa/dsa_ossl.c",
            "status": "modified",
            "additions": 31,
            "deletions": 1,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/e2260e901d30042bd2c2afb74f7d49b67cb6c318/deps%2Fopenssl%2Fopenssl%2Fcrypto%2Fdsa%2Fdsa_ossl.c",
            "raw_url": "https://github.com/nodejs/node/raw/e2260e901d30042bd2c2afb74f7d49b67cb6c318/deps%2Fopenssl%2Fopenssl%2Fcrypto%2Fdsa%2Fdsa_ossl.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fopenssl%2Fopenssl%2Fcrypto%2Fdsa%2Fdsa_ossl.c?ref=e2260e901d30042bd2c2afb74f7d49b67cb6c318",
            "patch": "@@ -25,6 +25,8 @@ static int dsa_do_verify(const unsigned char *dgst, int dgst_len,\n                          DSA_SIG *sig, DSA *dsa);\n static int dsa_init(DSA *dsa);\n static int dsa_finish(DSA *dsa);\n+static BIGNUM *dsa_mod_inverse_fermat(const BIGNUM *k, const BIGNUM *q,\n+                                      BN_CTX *ctx);\n \n static DSA_METHOD openssl_dsa_meth = {\n     \"OpenSSL DSA method\",\n@@ -261,7 +263,7 @@ static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in,\n         goto err;\n \n     /* Compute  part of 's = inv(k) (m + xr) mod q' */\n-    if ((kinv = BN_mod_inverse(NULL, k, dsa->q, ctx)) == NULL)\n+    if ((kinv = dsa_mod_inverse_fermat(k, dsa->q, ctx)) == NULL)\n         goto err;\n \n     BN_clear_free(*kinvp);\n@@ -395,3 +397,31 @@ static int dsa_finish(DSA *dsa)\n     BN_MONT_CTX_free(dsa->method_mont_p);\n     return (1);\n }\n+\n+/*\n+ * Compute the inverse of k modulo q.\n+ * Since q is prime, Fermat's Little Theorem applies, which reduces this to\n+ * mod-exp operation.  Both the exponent and modulus are public information\n+ * so a mod-exp that doesn't leak the base is sufficient.  A newly allocated\n+ * BIGNUM is returned which the caller must free.\n+ */\n+static BIGNUM *dsa_mod_inverse_fermat(const BIGNUM *k, const BIGNUM *q,\n+                                      BN_CTX *ctx)\n+{\n+    BIGNUM *res = NULL;\n+    BIGNUM *r, *e;\n+\n+    if ((r = BN_new()) == NULL)\n+        return NULL;\n+\n+    BN_CTX_start(ctx);\n+    if ((e = BN_CTX_get(ctx)) != NULL\n+            && BN_set_word(r, 2)\n+            && BN_sub(e, q, r)\n+            && BN_mod_exp_mont(r, k, e, q, ctx, NULL))\n+        res = r;\n+    else\n+        BN_free(r);\n+    BN_CTX_end(ctx);\n+    return res;\n+}"
        }
    ],
    "stats": {
        "total": 32,
        "additions": 31,
        "deletions": 1
    }
}