{
    "author": "tniessen",
    "message": "crypto: deduplicate cipher initialization code\n\nCipherBase::Init and CipherBase::InitIv contain a lot of duplicate\ncode, this commit moves that into a separate function.\n\nPR-URL: https://github.com/nodejs/node/pull/23011\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>",
    "sha": "b7bdde013a8abd09b6b486a9e452177a015db1a9",
    "files": [
        {
            "sha": "033af7b0892a013bc6457cf6020f4abaff0d299c",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 55,
            "deletions": 75,
            "changes": 130,
            "blob_url": "https://github.com/nodejs/node/blob/b7bdde013a8abd09b6b486a9e452177a015db1a9/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/b7bdde013a8abd09b6b486a9e452177a015db1a9/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=b7bdde013a8abd09b6b486a9e452177a015db1a9",
            "patch": "@@ -2545,6 +2545,12 @@ int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx) {\n   return 1;\n }\n \n+static bool IsSupportedAuthenticatedMode(int mode) {\n+  return mode == EVP_CIPH_CCM_MODE ||\n+         mode == EVP_CIPH_GCM_MODE ||\n+         mode == EVP_CIPH_OCB_MODE;\n+}\n+\n void CipherBase::Initialize(Environment* env, Local<Object> target) {\n   Local<FunctionTemplate> t = env->NewFunctionTemplate(New);\n \n@@ -2571,6 +2577,43 @@ void CipherBase::New(const FunctionCallbackInfo<Value>& args) {\n   new CipherBase(env, args.This(), kind);\n }\n \n+void CipherBase::CommonInit(const char* cipher_type,\n+                            const EVP_CIPHER* cipher,\n+                            const unsigned char* key,\n+                            int key_len,\n+                            const unsigned char* iv,\n+                            int iv_len,\n+                            unsigned int auth_tag_len) {\n+  CHECK(!ctx_);\n+  ctx_.reset(EVP_CIPHER_CTX_new());\n+\n+  const int mode = EVP_CIPHER_mode(cipher);\n+  if (mode == EVP_CIPH_WRAP_MODE)\n+    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n+\n+  const bool encrypt = (kind_ == kCipher);\n+  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,\n+                             nullptr, nullptr, encrypt)) {\n+    return ThrowCryptoError(env(), ERR_get_error(),\n+                            \"Failed to initialize cipher\");\n+  }\n+\n+  if (IsSupportedAuthenticatedMode(mode)) {\n+    CHECK_GE(iv_len, 0);\n+    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))\n+      return;\n+  }\n+\n+  if (!EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {\n+    ctx_.reset();\n+    return env()->ThrowError(\"Invalid key length\");\n+  }\n+\n+  if (1 != EVP_CipherInit_ex(ctx_.get(), nullptr, nullptr, key, iv, encrypt)) {\n+    return ThrowCryptoError(env(), ERR_get_error(),\n+                            \"Failed to initialize cipher\");\n+  }\n+}\n \n void CipherBase::Init(const char* cipher_type,\n                       const char* key_buf,\n@@ -2586,7 +2629,6 @@ void CipherBase::Init(const char* cipher_type,\n   }\n #endif  // NODE_FIPS_MODE\n \n-  CHECK(!ctx_);\n   const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);\n   if (cipher == nullptr)\n     return env()->ThrowError(\"Unknown cipher\");\n@@ -2604,45 +2646,19 @@ void CipherBase::Init(const char* cipher_type,\n                                iv);\n   CHECK_NE(key_len, 0);\n \n-  ctx_.reset(EVP_CIPHER_CTX_new());\n-\n   const int mode = EVP_CIPHER_mode(cipher);\n-  if (mode == EVP_CIPH_WRAP_MODE)\n-    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n-\n-  const bool encrypt = (kind_ == kCipher);\n-  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,\n-                             nullptr, nullptr, encrypt)) {\n-    return ThrowCryptoError(env(), ERR_get_error(),\n-                            \"Failed to initialize cipher\");\n-  }\n-\n-  if (encrypt && (mode == EVP_CIPH_CTR_MODE || mode == EVP_CIPH_GCM_MODE ||\n-      mode == EVP_CIPH_CCM_MODE)) {\n+  if (kind_ == kCipher && (mode == EVP_CIPH_CTR_MODE ||\n+                           mode == EVP_CIPH_GCM_MODE ||\n+                           mode == EVP_CIPH_CCM_MODE)) {\n     // Ignore the return value (i.e. possible exception) because we are\n     // not calling back into JS anyway.\n     ProcessEmitWarning(env(),\n                        \"Use Cipheriv for counter mode of %s\",\n                        cipher_type);\n   }\n \n-  if (IsAuthenticatedMode()) {\n-    if (!InitAuthenticated(cipher_type, EVP_CIPHER_iv_length(cipher),\n-                           auth_tag_len))\n-      return;\n-  }\n-\n-  CHECK_EQ(1, EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len));\n-\n-  if (1 != EVP_CipherInit_ex(ctx_.get(),\n-                             nullptr,\n-                             nullptr,\n-                             reinterpret_cast<unsigned char*>(key),\n-                             reinterpret_cast<unsigned char*>(iv),\n-                             encrypt)) {\n-    return ThrowCryptoError(env(), ERR_get_error(),\n-                            \"Failed to initialize cipher\");\n-  }\n+  CommonInit(cipher_type, cipher, key, key_len, iv,\n+             EVP_CIPHER_iv_length(cipher), auth_tag_len);\n }\n \n \n@@ -2669,16 +2685,10 @@ void CipherBase::Init(const FunctionCallbackInfo<Value>& args) {\n   cipher->Init(*cipher_type, key_buf, key_buf_len, auth_tag_len);\n }\n \n-static bool IsSupportedAuthenticatedMode(int mode) {\n-  return mode == EVP_CIPH_CCM_MODE ||\n-         mode == EVP_CIPH_GCM_MODE ||\n-         mode == EVP_CIPH_OCB_MODE;\n-}\n-\n void CipherBase::InitIv(const char* cipher_type,\n-                        const char* key,\n+                        const unsigned char* key,\n                         int key_len,\n-                        const char* iv,\n+                        const unsigned char* iv,\n                         int iv_len,\n                         unsigned int auth_tag_len) {\n   HandleScope scope(env()->isolate());\n@@ -2706,38 +2716,7 @@ void CipherBase::InitIv(const char* cipher_type,\n     return env()->ThrowError(\"Invalid IV length\");\n   }\n \n-  ctx_.reset(EVP_CIPHER_CTX_new());\n-\n-  if (mode == EVP_CIPH_WRAP_MODE)\n-    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n-\n-  const bool encrypt = (kind_ == kCipher);\n-  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,\n-                             nullptr, nullptr, encrypt)) {\n-    return ThrowCryptoError(env(), ERR_get_error(),\n-                            \"Failed to initialize cipher\");\n-  }\n-\n-  if (is_authenticated_mode) {\n-    CHECK(has_iv);\n-    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))\n-      return;\n-  }\n-\n-  if (!EVP_CIPHER_CTX_set_key_length(ctx_.get(), key_len)) {\n-    ctx_.reset();\n-    return env()->ThrowError(\"Invalid key length\");\n-  }\n-\n-  if (1 != EVP_CipherInit_ex(ctx_.get(),\n-                             nullptr,\n-                             nullptr,\n-                             reinterpret_cast<const unsigned char*>(key),\n-                             reinterpret_cast<const unsigned char*>(iv),\n-                             encrypt)) {\n-    return ThrowCryptoError(env(), ERR_get_error(),\n-                            \"Failed to initialize cipher\");\n-  }\n+  CommonInit(cipher_type, cipher, key, key_len, iv, iv_len, auth_tag_len);\n }\n \n \n@@ -2750,14 +2729,15 @@ void CipherBase::InitIv(const FunctionCallbackInfo<Value>& args) {\n \n   const node::Utf8Value cipher_type(env->isolate(), args[0]);\n   ssize_t key_len = Buffer::Length(args[1]);\n-  const char* key_buf = Buffer::Data(args[1]);\n+  const unsigned char* key_buf = reinterpret_cast<unsigned char*>(\n+      Buffer::Data(args[1]));\n   ssize_t iv_len;\n-  const char* iv_buf;\n+  const unsigned char* iv_buf;\n   if (args[2]->IsNull()) {\n     iv_buf = nullptr;\n     iv_len = -1;\n   } else {\n-    iv_buf = Buffer::Data(args[2]);\n+    iv_buf = reinterpret_cast<unsigned char*>(Buffer::Data(args[2]));\n     iv_len = Buffer::Length(args[2]);\n   }\n "
        },
        {
            "sha": "714afd0d3bb86876bb9e2349add2b1a34d762393",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/b7bdde013a8abd09b6b486a9e452177a015db1a9/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/b7bdde013a8abd09b6b486a9e452177a015db1a9/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=b7bdde013a8abd09b6b486a9e452177a015db1a9",
            "patch": "@@ -370,14 +370,21 @@ class CipherBase : public BaseObject {\n   };\n   static const unsigned kNoAuthTagLength = static_cast<unsigned>(-1);\n \n+  void CommonInit(const char* cipher_type,\n+                  const EVP_CIPHER* cipher,\n+                  const unsigned char* key,\n+                  int key_len,\n+                  const unsigned char* iv,\n+                  int iv_len,\n+                  unsigned int auth_tag_len);\n   void Init(const char* cipher_type,\n             const char* key_buf,\n             int key_buf_len,\n             unsigned int auth_tag_len);\n   void InitIv(const char* cipher_type,\n-              const char* key,\n+              const unsigned char* key,\n               int key_len,\n-              const char* iv,\n+              const unsigned char* iv,\n               int iv_len,\n               unsigned int auth_tag_len);\n   bool InitAuthenticated(const char* cipher_type, int iv_len,"
        }
    ],
    "stats": {
        "total": 141,
        "additions": 64,
        "deletions": 77
    }
}