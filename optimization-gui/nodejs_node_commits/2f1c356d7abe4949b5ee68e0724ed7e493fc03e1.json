{
    "author": "cjihrig",
    "message": "tools: update ESLint to 5.8.0\n\nUpdate ESLint to 5.8.0.\n\nPR-URL: https://github.com/nodejs/node/pull/23904\nReviewed-By: Rich Trott <rtrott@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
    "files": [
        {
            "sha": "b47e6eb1fcfb6aa84a8f93b730000b9d5a1e2863",
            "filename": "tools/node_modules/eslint/lib/linter.js",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Flib%2Flinter.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Flib%2Flinter.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Flib%2Flinter.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -888,6 +888,15 @@ module.exports = class Linter {\n         this.environments = new Environments();\n     }\n \n+    /**\n+     * Getter for package version.\n+     * @static\n+     * @returns {string} The version from package.json.\n+     */\n+    static get version() {\n+        return pkg.version;\n+    }\n+\n     /**\n      * Configuration object for the `verify` API. A JS representation of the eslintrc files.\n      * @typedef {Object} ESLintConfig"
        },
        {
            "sha": "de6934c635ac336728b803d2a29227579d66a7f8",
            "filename": "tools/node_modules/eslint/lib/rules/no-irregular-whitespace.js",
            "status": "modified",
            "additions": 4,
            "deletions": 8,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Flib%2Frules%2Fno-irregular-whitespace.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Flib%2Frules%2Fno-irregular-whitespace.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Flib%2Frules%2Fno-irregular-whitespace.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -81,9 +81,7 @@ module.exports = {\n             const locStart = node.loc.start;\n             const locEnd = node.loc.end;\n \n-            errors = errors.filter(error => {\n-                const errorLoc = error[1];\n-\n+            errors = errors.filter(({ loc: errorLoc }) => {\n                 if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {\n                     if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {\n                         return false;\n@@ -157,7 +155,7 @@ module.exports = {\n                         column: match.index\n                     };\n \n-                    errors.push([node, location, \"Irregular whitespace not allowed.\"]);\n+                    errors.push({ node, message: \"Irregular whitespace not allowed.\", loc: location });\n                 }\n             });\n         }\n@@ -182,7 +180,7 @@ module.exports = {\n                     column: sourceLines[lineIndex].length\n                 };\n \n-                errors.push([node, location, \"Irregular whitespace not allowed.\"]);\n+                errors.push({ node, message: \"Irregular whitespace not allowed.\", loc: location });\n                 lastLineIndex = lineIndex;\n             }\n         }\n@@ -224,9 +222,7 @@ module.exports = {\n                 }\n \n                 // If we have any errors remaining report on them\n-                errors.forEach(error => {\n-                    context.report(...error);\n-                });\n+                errors.forEach(error => context.report(error));\n             };\n         } else {\n             nodes.Program = noop;"
        },
        {
            "sha": "8b3bc5e0e436d366530dd3a64c520a357c00a179",
            "filename": "tools/node_modules/eslint/lib/rules/prefer-const.js",
            "status": "modified",
            "additions": 63,
            "deletions": 4,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Flib%2Frules%2Fprefer-const.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Flib%2Frules%2Fprefer-const.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Flib%2Frules%2Fprefer-const.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -57,6 +57,7 @@ function canBecomeVariableDeclaration(identifier) {\n  * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n  */\n function isOuterVariableInDestructing(name, initScope) {\n+\n     if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n         return true;\n     }\n@@ -96,6 +97,54 @@ function getDestructuringHost(reference) {\n     return node;\n }\n \n+/**\n+ * Determines if a destructuring assignment node contains\n+ * any MemberExpression nodes. This is used to determine if a\n+ * variable that is only written once using destructuring can be\n+ * safely converted into a const declaration.\n+ * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n+ * @returns {boolean} True if the destructuring pattern contains\n+ *      a MemberExpression, false if not.\n+ */\n+function hasMemberExpressionAssignment(node) {\n+    switch (node.type) {\n+        case \"ObjectPattern\":\n+            return node.properties.some(prop => {\n+                if (prop) {\n+\n+                    /*\n+                     * Spread elements have an argument property while\n+                     * others have a value property. Because different\n+                     * parsers use different node types for spread elements,\n+                     * we just check if there is an argument property.\n+                     */\n+                    return hasMemberExpressionAssignment(prop.argument || prop.value);\n+                }\n+\n+                return false;\n+            });\n+\n+        case \"ArrayPattern\":\n+            return node.elements.some(element => {\n+                if (element) {\n+                    return hasMemberExpressionAssignment(element);\n+                }\n+\n+                return false;\n+            });\n+\n+        case \"AssignmentPattern\":\n+            return hasMemberExpressionAssignment(node.left);\n+\n+        case \"MemberExpression\":\n+            return true;\n+\n+        // no default\n+    }\n+\n+    return false;\n+}\n+\n /**\n  * Gets an identifier node of a given variable.\n  *\n@@ -148,7 +197,8 @@ function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n \n             if (destructuringHost !== null && destructuringHost.left !== void 0) {\n                 const leftNode = destructuringHost.left;\n-                let hasOuterVariables = false;\n+                let hasOuterVariables = false,\n+                    hasNonIdentifiers = false;\n \n                 if (leftNode.type === \"ObjectPattern\") {\n                     const properties = leftNode.properties;\n@@ -157,16 +207,23 @@ function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n                         .filter(prop => prop.value)\n                         .map(prop => prop.value.name)\n                         .some(name => isOuterVariableInDestructing(name, variable.scope));\n+\n+                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n+\n                 } else if (leftNode.type === \"ArrayPattern\") {\n                     const elements = leftNode.elements;\n \n                     hasOuterVariables = elements\n                         .map(element => element && element.name)\n                         .some(name => isOuterVariableInDestructing(name, variable.scope));\n+\n+                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n                 }\n-                if (hasOuterVariables) {\n+\n+                if (hasOuterVariables || hasNonIdentifiers) {\n                     return null;\n                 }\n+\n             }\n \n             writer = reference;\n@@ -192,9 +249,11 @@ function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n     if (!shouldBeConst) {\n         return null;\n     }\n+\n     if (isReadBeforeInit) {\n         return variable.defs[0].name;\n     }\n+\n     return writer.identifier;\n }\n \n@@ -295,7 +354,7 @@ module.exports = {\n     create(context) {\n         const options = context.options[0] || {};\n         const sourceCode = context.getSourceCode();\n-        const checkingMixedDestructuring = options.destructuring !== \"all\";\n+        const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n         const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n         const variables = [];\n \n@@ -316,7 +375,7 @@ module.exports = {\n         function checkGroup(nodes) {\n             const nodesToReport = nodes.filter(Boolean);\n \n-            if (nodes.length && (checkingMixedDestructuring || nodesToReport.length === nodes.length)) {\n+            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n                 const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                 const shouldFix = varDeclParent &&\n "
        },
        {
            "sha": "6d1bba989fdeea92a03c460d5e61ed7ab4c07db3",
            "filename": "tools/node_modules/eslint/lib/testers/rule-tester.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Flib%2Ftesters%2Frule-tester.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Flib%2Ftesters%2Frule-tester.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Flib%2Ftesters%2Frule-tester.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -397,7 +397,7 @@ class RuleTester {\n          */\n         function assertASTDidntChange(beforeAST, afterAST) {\n             if (!lodash.isEqual(beforeAST, afterAST)) {\n-                assert.fail(null, null, \"Rule should not modify AST.\");\n+                assert.fail(\"Rule should not modify AST.\");\n             }\n         }\n \n@@ -551,7 +551,7 @@ class RuleTester {\n                     } else {\n \n                         // Message was an unexpected type\n-                        assert.fail(message, null, \"Error should be a string, object, or RegExp.\");\n+                        assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n                     }\n                 }\n             }"
        },
        {
            "sha": "2bbb1d99fd8cfab7f6d73121de1f80da7d378e8d",
            "filename": "tools/node_modules/eslint/node_modules/acorn-jsx/README.md",
            "status": "modified",
            "additions": 6,
            "deletions": 26,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2FREADME.md?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -17,44 +17,24 @@ Please note that this tool only parses source code to JSX AST, which is useful f\n \n ## Usage\n \n-You can use module directly in order to get Acorn instance with plugin installed:\n+Requiring this module provides you with an Acorn plugin that you can use like this:\n \n ```javascript\n-var acorn = require('acorn-jsx');\n-```\n-\n-Or you can use `inject.js` for injecting plugin into your own version of Acorn like following:\n-\n-```javascript\n-var acorn = require('acorn-jsx/inject')(require('./custom-acorn'));\n-```\n-\n-Then, use `plugins` option whenever you need to support JSX while parsing:\n-\n-```javascript\n-var ast = acorn.parse(code, {\n-  plugins: { jsx: true }\n-});\n+var acorn = require(\"acorn\");\n+var jsx = require(\"acorn-jsx\");\n+acorn.Parser.extend(jsx()).parse(\"my(<jsx/>, 'code');\");\n ```\n \n Note that official spec doesn't support mix of XML namespaces and object-style access in tag names (#27) like in `<namespace:Object.Property />`, so it was deprecated in `acorn-jsx@3.0`. If you still want to opt-in to support of such constructions, you can pass the following option:\n \n ```javascript\n-var ast = acorn.parse(code, {\n-  plugins: {\n-    jsx: { allowNamespacedObjects: true }\n-  }\n-});\n+acorn.Parser.extend(jsx({ allowNamespacedObjects: true }))\n ```\n \n Also, since most apps use pure React transformer, a new option was introduced that allows to prohibit namespaces completely:\n \n ```javascript\n-var ast = acorn.parse(code, {\n-  plugins: {\n-    jsx: { allowNamespaces: false }\n-  }\n-});\n+acorn.Parser.extend(jsx({ allowNamespaces: false }))\n ```\n \n Note that by default `allowNamespaces` is enabled for spec compliancy."
        },
        {
            "sha": "292315f65bfc90064a013aae2e74189b773ebb5c",
            "filename": "tools/node_modules/eslint/node_modules/acorn-jsx/index.js",
            "status": "modified",
            "additions": 430,
            "deletions": 2,
            "changes": 432,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2Findex.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2Findex.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2Findex.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -1,3 +1,431 @@\n-'use strict';\n+const XHTMLEntities = require('./xhtml');\n \n-module.exports = require('./inject')(require('acorn'));\n+const hexNumber = /^[\\da-fA-F]+$/;\n+const decimalNumber = /^\\d+$/;\n+\n+const {tokTypes: tt, TokContext, tokContexts, TokenType, isNewLine, isIdentifierStart, isIdentifierChar} = require(\"acorn\");\n+\n+const tc_oTag = new TokContext('<tag', false);\n+const tc_cTag = new TokContext('</tag', false);\n+const tc_expr = new TokContext('<tag>...</tag>', true, true);\n+\n+const tok = {\n+  jsxName: new TokenType('jsxName'),\n+  jsxText: new TokenType('jsxText', {beforeExpr: true}),\n+  jsxTagStart: new TokenType('jsxTagStart'),\n+  jsxTagEnd: new TokenType('jsxTagEnd')\n+}\n+\n+tok.jsxTagStart.updateContext = function() {\n+  this.context.push(tc_expr); // treat as beginning of JSX expression\n+  this.context.push(tc_oTag); // start opening tag context\n+  this.exprAllowed = false;\n+};\n+tok.jsxTagEnd.updateContext = function(prevType) {\n+  let out = this.context.pop();\n+  if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n+    this.context.pop();\n+    this.exprAllowed = this.curContext() === tc_expr;\n+  } else {\n+    this.exprAllowed = true;\n+  }\n+};\n+\n+// Transforms JSX element name to string.\n+\n+function getQualifiedJSXName(object) {\n+  if (!object)\n+    return object;\n+\n+  if (object.type === 'JSXIdentifier')\n+    return object.name;\n+\n+  if (object.type === 'JSXNamespacedName')\n+    return object.namespace.name + ':' + object.name.name;\n+\n+  if (object.type === 'JSXMemberExpression')\n+    return getQualifiedJSXName(object.object) + '.' +\n+    getQualifiedJSXName(object.property);\n+}\n+\n+module.exports = function(options = {}) {\n+  return function(Parser) {\n+    return plugin({\n+      allowNamespaces: options.allowNamespaces !== false,\n+      allowNamespacedObjects: !!options.allowNamespacedObjects\n+    }, Parser);\n+  }\n+}\n+module.exports.tokTypes = tok\n+\n+function plugin(options, Parser) {\n+  return class extends Parser {\n+    // Reads inline JSX contents token.\n+    jsx_readToken() {\n+      let out = '', chunkStart = this.pos;\n+      for (;;) {\n+        if (this.pos >= this.input.length)\n+          this.raise(this.start, 'Unterminated JSX contents');\n+        let ch = this.input.charCodeAt(this.pos);\n+\n+        switch (ch) {\n+        case 60: // '<'\n+        case 123: // '{'\n+          if (this.pos === this.start) {\n+            if (ch === 60 && this.exprAllowed) {\n+              ++this.pos;\n+              return this.finishToken(tok.jsxTagStart);\n+            }\n+            return this.getTokenFromCode(ch);\n+          }\n+          out += this.input.slice(chunkStart, this.pos);\n+          return this.finishToken(tok.jsxText, out);\n+\n+        case 38: // '&'\n+          out += this.input.slice(chunkStart, this.pos);\n+          out += this.jsx_readEntity();\n+          chunkStart = this.pos;\n+          break;\n+\n+        default:\n+          if (isNewLine(ch)) {\n+            out += this.input.slice(chunkStart, this.pos);\n+            out += this.jsx_readNewLine(true);\n+            chunkStart = this.pos;\n+          } else {\n+            ++this.pos;\n+          }\n+        }\n+      }\n+    }\n+\n+    jsx_readNewLine(normalizeCRLF) {\n+      let ch = this.input.charCodeAt(this.pos);\n+      let out;\n+      ++this.pos;\n+      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n+        ++this.pos;\n+        out = normalizeCRLF ? '\\n' : '\\r\\n';\n+      } else {\n+        out = String.fromCharCode(ch);\n+      }\n+      if (this.options.locations) {\n+        ++this.curLine;\n+        this.lineStart = this.pos;\n+      }\n+\n+      return out;\n+    };\n+\n+    jsx_readString(quote) {\n+      let out = '', chunkStart = ++this.pos;\n+      for (;;) {\n+        if (this.pos >= this.input.length)\n+          this.raise(this.start, 'Unterminated string constant');\n+        let ch = this.input.charCodeAt(this.pos);\n+        if (ch === quote) break;\n+        if (ch === 38) { // '&'\n+          out += this.input.slice(chunkStart, this.pos);\n+          out += this.jsx_readEntity();\n+          chunkStart = this.pos;\n+        } else if (isNewLine(ch)) {\n+          out += this.input.slice(chunkStart, this.pos);\n+          out += this.jsx_readNewLine(false);\n+          chunkStart = this.pos;\n+        } else {\n+          ++this.pos;\n+        }\n+      }\n+      out += this.input.slice(chunkStart, this.pos++);\n+      return this.finishToken(tt.string, out);\n+    }\n+\n+    jsx_readEntity() {\n+      let str = '', count = 0, entity;\n+      let ch = this.input[this.pos];\n+      if (ch !== '&')\n+        this.raise(this.pos, 'Entity must start with an ampersand');\n+      let startPos = ++this.pos;\n+      while (this.pos < this.input.length && count++ < 10) {\n+        ch = this.input[this.pos++];\n+        if (ch === ';') {\n+          if (str[0] === '#') {\n+            if (str[1] === 'x') {\n+              str = str.substr(2);\n+              if (hexNumber.test(str))\n+                entity = String.fromCharCode(parseInt(str, 16));\n+            } else {\n+              str = str.substr(1);\n+              if (decimalNumber.test(str))\n+                entity = String.fromCharCode(parseInt(str, 10));\n+            }\n+          } else {\n+            entity = XHTMLEntities[str];\n+          }\n+          break;\n+        }\n+        str += ch;\n+      }\n+      if (!entity) {\n+        this.pos = startPos;\n+        return '&';\n+      }\n+      return entity;\n+    }\n+\n+    // Read a JSX identifier (valid tag or attribute name).\n+    //\n+    // Optimized version since JSX identifiers can't contain\n+    // escape characters and so can be read as single slice.\n+    // Also assumes that first character was already checked\n+    // by isIdentifierStart in readToken.\n+\n+    jsx_readWord() {\n+      let ch, start = this.pos;\n+      do {\n+        ch = this.input.charCodeAt(++this.pos);\n+      } while (isIdentifierChar(ch) || ch === 45); // '-'\n+      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n+    }\n+\n+    // Parse next token as JSX identifier\n+\n+    jsx_parseIdentifier() {\n+      let node = this.startNode();\n+      if (this.type === tok.jsxName)\n+        node.name = this.value;\n+      else if (this.type.keyword)\n+        node.name = this.type.keyword;\n+      else\n+        this.unexpected();\n+      this.next();\n+      return this.finishNode(node, 'JSXIdentifier');\n+    }\n+\n+    // Parse namespaced identifier.\n+\n+    jsx_parseNamespacedName() {\n+      let startPos = this.start, startLoc = this.startLoc;\n+      let name = this.jsx_parseIdentifier();\n+      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n+      var node = this.startNodeAt(startPos, startLoc);\n+      node.namespace = name;\n+      node.name = this.jsx_parseIdentifier();\n+      return this.finishNode(node, 'JSXNamespacedName');\n+    }\n+\n+    // Parses element name in any form - namespaced, member\n+    // or single identifier.\n+\n+    jsx_parseElementName() {\n+      if (this.type === tok.jsxTagEnd) return '';\n+      let startPos = this.start, startLoc = this.startLoc;\n+      let node = this.jsx_parseNamespacedName();\n+      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n+        this.unexpected();\n+      }\n+      while (this.eat(tt.dot)) {\n+        let newNode = this.startNodeAt(startPos, startLoc);\n+        newNode.object = node;\n+        newNode.property = this.jsx_parseIdentifier();\n+        node = this.finishNode(newNode, 'JSXMemberExpression');\n+      }\n+      return node;\n+    }\n+\n+    // Parses any type of JSX attribute value.\n+\n+    jsx_parseAttributeValue() {\n+      switch (this.type) {\n+      case tt.braceL:\n+        let node = this.jsx_parseExpressionContainer();\n+        if (node.expression.type === 'JSXEmptyExpression')\n+          this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n+        return node;\n+\n+      case tok.jsxTagStart:\n+      case tt.string:\n+        return this.parseExprAtom();\n+\n+      default:\n+        this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n+      }\n+    }\n+\n+    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n+    // and so it should start at the end of last read token (left brace) and finish\n+    // at the beginning of the next one (right brace).\n+\n+    jsx_parseEmptyExpression() {\n+      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n+      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n+    }\n+\n+    // Parses JSX expression enclosed into curly brackets.\n+\n+    jsx_parseExpressionContainer() {\n+      let node = this.startNode();\n+      this.next();\n+      node.expression = this.type === tt.braceR\n+        ? this.jsx_parseEmptyExpression()\n+        : this.parseExpression();\n+      this.expect(tt.braceR);\n+      return this.finishNode(node, 'JSXExpressionContainer');\n+    }\n+\n+    // Parses following JSX attribute name-value pair.\n+\n+    jsx_parseAttribute() {\n+      let node = this.startNode();\n+      if (this.eat(tt.braceL)) {\n+        this.expect(tt.ellipsis);\n+        node.argument = this.parseMaybeAssign();\n+        this.expect(tt.braceR);\n+        return this.finishNode(node, 'JSXSpreadAttribute');\n+      }\n+      node.name = this.jsx_parseNamespacedName();\n+      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n+      return this.finishNode(node, 'JSXAttribute');\n+    }\n+\n+    // Parses JSX opening tag starting after '<'.\n+\n+    jsx_parseOpeningElementAt(startPos, startLoc) {\n+      let node = this.startNodeAt(startPos, startLoc);\n+      node.attributes = [];\n+      let nodeName = this.jsx_parseElementName();\n+      if (nodeName) node.name = nodeName;\n+      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\n+        node.attributes.push(this.jsx_parseAttribute());\n+      node.selfClosing = this.eat(tt.slash);\n+      this.expect(tok.jsxTagEnd);\n+      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n+    }\n+\n+    // Parses JSX closing tag starting after '</'.\n+\n+    jsx_parseClosingElementAt(startPos, startLoc) {\n+      let node = this.startNodeAt(startPos, startLoc);\n+      let nodeName = this.jsx_parseElementName();\n+      if (nodeName) node.name = nodeName;\n+      this.expect(tok.jsxTagEnd);\n+      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n+    }\n+\n+    // Parses entire JSX element, including it's opening tag\n+    // (starting after '<'), attributes, contents and closing tag.\n+\n+    jsx_parseElementAt(startPos, startLoc) {\n+      let node = this.startNodeAt(startPos, startLoc);\n+      let children = [];\n+      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n+      let closingElement = null;\n+\n+      if (!openingElement.selfClosing) {\n+        contents: for (;;) {\n+          switch (this.type) {\n+          case tok.jsxTagStart:\n+            startPos = this.start; startLoc = this.startLoc;\n+            this.next();\n+            if (this.eat(tt.slash)) {\n+              closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n+              break contents;\n+            }\n+            children.push(this.jsx_parseElementAt(startPos, startLoc));\n+            break;\n+\n+          case tok.jsxText:\n+            children.push(this.parseExprAtom());\n+            break;\n+\n+          case tt.braceL:\n+            children.push(this.jsx_parseExpressionContainer());\n+            break;\n+\n+          default:\n+            this.unexpected();\n+          }\n+        }\n+        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n+          this.raise(\n+            closingElement.start,\n+            'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n+        }\n+      }\n+      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n+\n+      node['opening' + fragmentOrElement] = openingElement;\n+      node['closing' + fragmentOrElement] = closingElement;\n+      node.children = children;\n+      if (this.type === tt.relational && this.value === \"<\") {\n+        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n+      }\n+      return this.finishNode(node, 'JSX' + fragmentOrElement);\n+    }\n+\n+    // Parse JSX text\n+\n+    jsx_parseText(value) {\n+      let node = this.parseLiteral(value);\n+      node.type = \"JSXText\";\n+      return node;\n+    }\n+\n+    // Parses entire JSX element from current position.\n+\n+    jsx_parseElement() {\n+      let startPos = this.start, startLoc = this.startLoc;\n+      this.next();\n+      return this.jsx_parseElementAt(startPos, startLoc);\n+    }\n+\n+    parseExprAtom(refShortHandDefaultPos) {\n+      if (this.type === tok.jsxText)\n+        return this.jsx_parseText(this.value);\n+      else if (this.type === tok.jsxTagStart)\n+        return this.jsx_parseElement();\n+      else\n+        return super.parseExprAtom(refShortHandDefaultPos);\n+    }\n+\n+    readToken(code) {\n+      let context = this.curContext();\n+\n+      if (context === tc_expr) return this.jsx_readToken();\n+\n+      if (context === tc_oTag || context === tc_cTag) {\n+        if (isIdentifierStart(code)) return this.jsx_readWord();\n+\n+        if (code == 62) {\n+          ++this.pos;\n+          return this.finishToken(tok.jsxTagEnd);\n+        }\n+\n+        if ((code === 34 || code === 39) && context == tc_oTag)\n+          return this.jsx_readString(code);\n+      }\n+\n+      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n+        ++this.pos;\n+        return this.finishToken(tok.jsxTagStart);\n+      }\n+      return super.readToken(code)\n+    }\n+\n+    updateContext(prevType) {\n+      if (this.type == tt.braceL) {\n+        var curContext = this.curContext();\n+        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);\n+        else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);\n+        else super.updateContext(prevType)\n+        this.exprAllowed = true;\n+      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n+        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n+        this.context.push(tc_cTag); // reconsider as closing tag context\n+        this.exprAllowed = false;\n+      } else {\n+        return super.updateContext(prevType);\n+      }\n+    }\n+  };\n+};"
        },
        {
            "sha": "33806c72ce0a1c79155ab12dbefd72dbc78b5c55",
            "filename": "tools/node_modules/eslint/node_modules/acorn-jsx/inject.js",
            "status": "removed",
            "additions": 0,
            "deletions": 449,
            "changes": 449,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2Finject.js",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2Finject.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2Finject.js?ref=9697c0820f015ccf898a3662305a0caa3cd9c208",
            "patch": "@@ -1,449 +0,0 @@\n-'use strict';\n-\n-var XHTMLEntities = require('./xhtml');\n-\n-var hexNumber = /^[\\da-fA-F]+$/;\n-var decimalNumber = /^\\d+$/;\n-\n-module.exports = function(acorn) {\n-  var tt = acorn.tokTypes;\n-  var tc = acorn.tokContexts;\n-\n-  tc.j_oTag = new acorn.TokContext('<tag', false);\n-  tc.j_cTag = new acorn.TokContext('</tag', false);\n-  tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true);\n-\n-  tt.jsxName = new acorn.TokenType('jsxName');\n-  tt.jsxText = new acorn.TokenType('jsxText', {beforeExpr: true});\n-  tt.jsxTagStart = new acorn.TokenType('jsxTagStart');\n-  tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd');\n-\n-  tt.jsxTagStart.updateContext = function() {\n-    this.context.push(tc.j_expr); // treat as beginning of JSX expression\n-    this.context.push(tc.j_oTag); // start opening tag context\n-    this.exprAllowed = false;\n-  };\n-  tt.jsxTagEnd.updateContext = function(prevType) {\n-    var out = this.context.pop();\n-    if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {\n-      this.context.pop();\n-      this.exprAllowed = this.curContext() === tc.j_expr;\n-    } else {\n-      this.exprAllowed = true;\n-    }\n-  };\n-\n-  var pp = acorn.Parser.prototype;\n-\n-  // Reads inline JSX contents token.\n-\n-  pp.jsx_readToken = function() {\n-    var out = '', chunkStart = this.pos;\n-    for (;;) {\n-      if (this.pos >= this.input.length)\n-        this.raise(this.start, 'Unterminated JSX contents');\n-      var ch = this.input.charCodeAt(this.pos);\n-\n-      switch (ch) {\n-      case 60: // '<'\n-      case 123: // '{'\n-        if (this.pos === this.start) {\n-          if (ch === 60 && this.exprAllowed) {\n-            ++this.pos;\n-            return this.finishToken(tt.jsxTagStart);\n-          }\n-          return this.getTokenFromCode(ch);\n-        }\n-        out += this.input.slice(chunkStart, this.pos);\n-        return this.finishToken(tt.jsxText, out);\n-\n-      case 38: // '&'\n-        out += this.input.slice(chunkStart, this.pos);\n-        out += this.jsx_readEntity();\n-        chunkStart = this.pos;\n-        break;\n-\n-      default:\n-        if (acorn.isNewLine(ch)) {\n-          out += this.input.slice(chunkStart, this.pos);\n-          out += this.jsx_readNewLine(true);\n-          chunkStart = this.pos;\n-        } else {\n-          ++this.pos;\n-        }\n-      }\n-    }\n-  };\n-\n-  pp.jsx_readNewLine = function(normalizeCRLF) {\n-    var ch = this.input.charCodeAt(this.pos);\n-    var out;\n-    ++this.pos;\n-    if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n-      ++this.pos;\n-      out = normalizeCRLF ? '\\n' : '\\r\\n';\n-    } else {\n-      out = String.fromCharCode(ch);\n-    }\n-    if (this.options.locations) {\n-      ++this.curLine;\n-      this.lineStart = this.pos;\n-    }\n-\n-    return out;\n-  };\n-\n-  pp.jsx_readString = function(quote) {\n-    var out = '', chunkStart = ++this.pos;\n-    for (;;) {\n-      if (this.pos >= this.input.length)\n-        this.raise(this.start, 'Unterminated string constant');\n-      var ch = this.input.charCodeAt(this.pos);\n-      if (ch === quote) break;\n-      if (ch === 38) { // '&'\n-        out += this.input.slice(chunkStart, this.pos);\n-        out += this.jsx_readEntity();\n-        chunkStart = this.pos;\n-      } else if (acorn.isNewLine(ch)) {\n-        out += this.input.slice(chunkStart, this.pos);\n-        out += this.jsx_readNewLine(false);\n-        chunkStart = this.pos;\n-      } else {\n-        ++this.pos;\n-      }\n-    }\n-    out += this.input.slice(chunkStart, this.pos++);\n-    return this.finishToken(tt.string, out);\n-  };\n-\n-  pp.jsx_readEntity = function() {\n-    var str = '', count = 0, entity;\n-    var ch = this.input[this.pos];\n-    if (ch !== '&')\n-      this.raise(this.pos, 'Entity must start with an ampersand');\n-    var startPos = ++this.pos;\n-    while (this.pos < this.input.length && count++ < 10) {\n-      ch = this.input[this.pos++];\n-      if (ch === ';') {\n-        if (str[0] === '#') {\n-          if (str[1] === 'x') {\n-            str = str.substr(2);\n-            if (hexNumber.test(str))\n-              entity = String.fromCharCode(parseInt(str, 16));\n-          } else {\n-            str = str.substr(1);\n-            if (decimalNumber.test(str))\n-              entity = String.fromCharCode(parseInt(str, 10));\n-          }\n-        } else {\n-          entity = XHTMLEntities[str];\n-        }\n-        break;\n-      }\n-      str += ch;\n-    }\n-    if (!entity) {\n-      this.pos = startPos;\n-      return '&';\n-    }\n-    return entity;\n-  };\n-\n-\n-  // Read a JSX identifier (valid tag or attribute name).\n-  //\n-  // Optimized version since JSX identifiers can't contain\n-  // escape characters and so can be read as single slice.\n-  // Also assumes that first character was already checked\n-  // by isIdentifierStart in readToken.\n-\n-  pp.jsx_readWord = function() {\n-    var ch, start = this.pos;\n-    do {\n-      ch = this.input.charCodeAt(++this.pos);\n-    } while (acorn.isIdentifierChar(ch) || ch === 45); // '-'\n-    return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));\n-  };\n-\n-  // Transforms JSX element name to string.\n-\n-  function getQualifiedJSXName(object) {\n-    if (!object)\n-      return object;\n-\n-    if (object.type === 'JSXIdentifier')\n-      return object.name;\n-\n-    if (object.type === 'JSXNamespacedName')\n-      return object.namespace.name + ':' + object.name.name;\n-\n-    if (object.type === 'JSXMemberExpression')\n-      return getQualifiedJSXName(object.object) + '.' +\n-      getQualifiedJSXName(object.property);\n-  }\n-\n-  // Parse next token as JSX identifier\n-\n-  pp.jsx_parseIdentifier = function() {\n-    var node = this.startNode();\n-    if (this.type === tt.jsxName)\n-      node.name = this.value;\n-    else if (this.type.keyword)\n-      node.name = this.type.keyword;\n-    else\n-      this.unexpected();\n-    this.next();\n-    return this.finishNode(node, 'JSXIdentifier');\n-  };\n-\n-  // Parse namespaced identifier.\n-\n-  pp.jsx_parseNamespacedName = function() {\n-    var startPos = this.start, startLoc = this.startLoc;\n-    var name = this.jsx_parseIdentifier();\n-    if (!this.options.plugins.jsx.allowNamespaces || !this.eat(tt.colon)) return name;\n-    var node = this.startNodeAt(startPos, startLoc);\n-    node.namespace = name;\n-    node.name = this.jsx_parseIdentifier();\n-    return this.finishNode(node, 'JSXNamespacedName');\n-  };\n-\n-  // Parses element name in any form - namespaced, member\n-  // or single identifier.\n-\n-  pp.jsx_parseElementName = function() {\n-    if (this.type === tt.jsxTagEnd)\n-      return '';\n-    var startPos = this.start, startLoc = this.startLoc;\n-    var node = this.jsx_parseNamespacedName();\n-    if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !this.options.plugins.jsx.allowNamespacedObjects) {\n-      this.unexpected();\n-    }\n-    while (this.eat(tt.dot)) {\n-      var newNode = this.startNodeAt(startPos, startLoc);\n-      newNode.object = node;\n-      newNode.property = this.jsx_parseIdentifier();\n-      node = this.finishNode(newNode, 'JSXMemberExpression');\n-    }\n-    return node;\n-  };\n-\n-  // Parses any type of JSX attribute value.\n-\n-  pp.jsx_parseAttributeValue = function() {\n-    switch (this.type) {\n-    case tt.braceL:\n-      var node = this.jsx_parseExpressionContainer();\n-      if (node.expression.type === 'JSXEmptyExpression')\n-        this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n-      return node;\n-\n-    case tt.jsxTagStart:\n-    case tt.string:\n-      return this.parseExprAtom();\n-\n-    default:\n-      this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n-    }\n-  };\n-\n-  // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n-  // and so it should start at the end of last read token (left brace) and finish\n-  // at the beginning of the next one (right brace).\n-\n-  pp.jsx_parseEmptyExpression = function() {\n-    var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n-    return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n-  };\n-\n-  // Parses JSX expression enclosed into curly brackets.\n-\n-\n-  pp.jsx_parseExpressionContainer = function() {\n-    var node = this.startNode();\n-    this.next();\n-    node.expression = this.type === tt.braceR\n-      ? this.jsx_parseEmptyExpression()\n-      : this.parseExpression();\n-    this.expect(tt.braceR);\n-    return this.finishNode(node, 'JSXExpressionContainer');\n-  };\n-\n-  // Parses following JSX attribute name-value pair.\n-\n-  pp.jsx_parseAttribute = function() {\n-    var node = this.startNode();\n-    if (this.eat(tt.braceL)) {\n-      this.expect(tt.ellipsis);\n-      node.argument = this.parseMaybeAssign();\n-      this.expect(tt.braceR);\n-      return this.finishNode(node, 'JSXSpreadAttribute');\n-    }\n-    node.name = this.jsx_parseNamespacedName();\n-    node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n-    return this.finishNode(node, 'JSXAttribute');\n-  };\n-\n-  // Parses JSX opening tag starting after '<'.\n-\n-  pp.jsx_parseOpeningElementAt = function(startPos, startLoc) {\n-    var node = this.startNodeAt(startPos, startLoc);\n-    node.attributes = [];\n-    var nodeName = this.jsx_parseElementName();\n-    if (nodeName) node.name = nodeName;\n-    while (this.type !== tt.slash && this.type !== tt.jsxTagEnd)\n-      node.attributes.push(this.jsx_parseAttribute());\n-    node.selfClosing = this.eat(tt.slash);\n-    this.expect(tt.jsxTagEnd);\n-    return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n-  };\n-\n-  // Parses JSX closing tag starting after '</'.\n-\n-  pp.jsx_parseClosingElementAt = function(startPos, startLoc) {\n-    var node = this.startNodeAt(startPos, startLoc);\n-    var nodeName = this.jsx_parseElementName();\n-    if (nodeName) node.name = nodeName;\n-    this.expect(tt.jsxTagEnd);\n-    return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n-  };\n-\n-  // Parses entire JSX element, including it's opening tag\n-  // (starting after '<'), attributes, contents and closing tag.\n-\n-  pp.jsx_parseElementAt = function(startPos, startLoc) {\n-    var node = this.startNodeAt(startPos, startLoc);\n-    var children = [];\n-    var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n-    var closingElement = null;\n-\n-    if (!openingElement.selfClosing) {\n-      contents: for (;;) {\n-        switch (this.type) {\n-        case tt.jsxTagStart:\n-          startPos = this.start; startLoc = this.startLoc;\n-          this.next();\n-          if (this.eat(tt.slash)) {\n-            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n-            break contents;\n-          }\n-          children.push(this.jsx_parseElementAt(startPos, startLoc));\n-          break;\n-\n-        case tt.jsxText:\n-          children.push(this.parseExprAtom());\n-          break;\n-\n-        case tt.braceL:\n-          children.push(this.jsx_parseExpressionContainer());\n-          break;\n-\n-        default:\n-          this.unexpected();\n-        }\n-      }\n-      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n-        this.raise(\n-          closingElement.start,\n-          'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n-      }\n-    }\n-\n-    node.openingElement = openingElement;\n-    node.closingElement = closingElement;\n-    node.children = children;\n-    if (this.type === tt.relational && this.value === \"<\") {\n-      this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n-    }\n-    return this.finishNode(node, openingElement.name ? 'JSXElement' : 'JSXFragment');\n-  };\n-\n-  // Parse JSX text\n-\n-  pp.jsx_parseText = function(value) {\n-    var node = this.parseLiteral(value);\n-    node.type = \"JSXText\";\n-\n-    return node;\n-  };\n-\n-  // Parses entire JSX element from current position.\n-\n-  pp.jsx_parseElement = function() {\n-    var startPos = this.start, startLoc = this.startLoc;\n-    this.next();\n-    return this.jsx_parseElementAt(startPos, startLoc);\n-  };\n-\n-  acorn.plugins.jsx = function(instance, opts) {\n-    if (!opts) {\n-      return;\n-    }\n-\n-    if (typeof opts !== 'object') {\n-      opts = {};\n-    }\n-\n-    instance.options.plugins.jsx = {\n-      allowNamespaces: opts.allowNamespaces !== false,\n-      allowNamespacedObjects: !!opts.allowNamespacedObjects\n-    };\n-\n-    instance.extend('parseExprAtom', function(inner) {\n-      return function(refShortHandDefaultPos) {\n-        if (this.type === tt.jsxText)\n-          return this.jsx_parseText(this.value);\n-        else if (this.type === tt.jsxTagStart)\n-          return this.jsx_parseElement();\n-        else\n-          return inner.call(this, refShortHandDefaultPos);\n-      };\n-    });\n-\n-    instance.extend('readToken', function(inner) {\n-      return function(code) {\n-        var context = this.curContext();\n-\n-        if (context === tc.j_expr) return this.jsx_readToken();\n-\n-        if (context === tc.j_oTag || context === tc.j_cTag) {\n-          if (acorn.isIdentifierStart(code)) return this.jsx_readWord();\n-\n-          if (code == 62) {\n-            ++this.pos;\n-            return this.finishToken(tt.jsxTagEnd);\n-          }\n-\n-          if ((code === 34 || code === 39) && context == tc.j_oTag)\n-            return this.jsx_readString(code);\n-        }\n-\n-        if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n-          ++this.pos;\n-          return this.finishToken(tt.jsxTagStart);\n-        }\n-        return inner.call(this, code);\n-      };\n-    });\n-\n-    instance.extend('updateContext', function(inner) {\n-      return function(prevType) {\n-        if (this.type == tt.braceL) {\n-          var curContext = this.curContext();\n-          if (curContext == tc.j_oTag) this.context.push(tc.b_expr);\n-          else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);\n-          else inner.call(this, prevType);\n-          this.exprAllowed = true;\n-        } else if (this.type === tt.slash && prevType === tt.jsxTagStart) {\n-          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n-          this.context.push(tc.j_cTag); // reconsider as closing tag context\n-          this.exprAllowed = false;\n-        } else {\n-          return inner.call(this, prevType);\n-        }\n-      };\n-    });\n-  };\n-\n-  return acorn;\n-};"
        },
        {
            "sha": "d22757b6a8d4505b40ac76ed3c4f408320091a1b",
            "filename": "tools/node_modules/eslint/node_modules/acorn-jsx/package.json",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2Fpackage.json",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn-jsx%2Fpackage.json?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -3,14 +3,10 @@\n     \"url\": \"https://github.com/RReverser/acorn-jsx/issues\"\n   },\n   \"bundleDependencies\": false,\n-  \"dependencies\": {\n-    \"acorn\": \"^5.0.3\"\n-  },\n   \"deprecated\": false,\n   \"description\": \"Alternative, faster React.js JSX parser\",\n   \"devDependencies\": {\n-    \"chai\": \"^3.0.0\",\n-    \"mocha\": \"^3.3.0\"\n+    \"acorn\": \"^6.0.0\"\n   },\n   \"homepage\": \"https://github.com/RReverser/acorn-jsx\",\n   \"license\": \"MIT\",\n@@ -22,12 +18,15 @@\n     }\n   ],\n   \"name\": \"acorn-jsx\",\n+  \"peerDependencies\": {\n+    \"acorn\": \"^6.0.0\"\n+  },\n   \"repository\": {\n     \"type\": \"git\",\n     \"url\": \"git+https://github.com/RReverser/acorn-jsx.git\"\n   },\n   \"scripts\": {\n     \"test\": \"node test/run.js\"\n   },\n-  \"version\": \"4.1.1\"\n+  \"version\": \"5.0.0\"\n }\n\\ No newline at end of file"
        },
        {
            "sha": "c5ac22cbd7c6baa21d2eda94f15ec78961b1ff19",
            "filename": "tools/node_modules/eslint/node_modules/acorn/AUTHORS",
            "status": "removed",
            "additions": 0,
            "deletions": 79,
            "changes": 79,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2FAUTHORS?ref=9697c0820f015ccf898a3662305a0caa3cd9c208",
            "patch": "@@ -1,79 +0,0 @@\n-List of Acorn contributors. Updated before every release.\n-\n-Adrian Heine\n-Adrian Rakovsky\n-Alistair Braidwood\n-Amila Welihinda\n-Andres Suarez\n-Angelo\n-Aparajita Fishman\n-Arian Stolwijk\n-Artem Govorov\n-Boopesh Mahendran\n-Bradley Heinz\n-Brandon Mills\n-Charles Hughes\n-Charmander\n-Chris McKnight\n-Conrad Irwin\n-Daniel Tschinder\n-David Bonnet\n-Domenico Matteo\n-ehmicky\n-Eugene Obrezkov\n-Felix Maier\n-Forbes Lindesay\n-Gilad Peleg\n-impinball\n-Ingvar Stepanyan\n-Jackson Ray Hamilton\n-Jesse McCarthy\n-Jiaxing Wang\n-Joel Kemp\n-Johannes Herr\n-John-David Dalton\n-Jordan Klassen\n-Jürg Lehni\n-Kai Cataldo\n-keeyipchan\n-Keheliya Gallaba\n-Kevin Irish\n-Kevin Kwok\n-krator\n-laosb\n-luckyzeng\n-Marek\n-Marijn Haverbeke\n-Martin Carlberg\n-Mat Garcia\n-Mathias Bynens\n-Mathieu 'p01' Henri\n-Matthew Bastien\n-Max Schaefer\n-Max Zerzouri\n-Mihai Bazon\n-Mike Rennie\n-naoh\n-Nicholas C. Zakas\n-Nick Fitzgerald\n-Olivier Thomann\n-Oskar Schöldström\n-Paul Harper\n-Peter Rust\n-PlNG\n-Prayag Verma\n-ReadmeCritic\n-r-e-d\n-Renée Kooi\n-Richard Gibson\n-Rich Harris\n-Sebastian McKenzie\n-Shahar Soel\n-Sheel Bedi\n-Simen Bekkhus\n-Teddy Katz\n-Timothy Gu\n-Toru Nagashima\n-Victor Homyakov\n-Wexpo Lyu\n-zsjforcn"
        },
        {
            "sha": "e66dac31de22b238bfb50ca83700f07eac3df9d6",
            "filename": "tools/node_modules/eslint/node_modules/acorn/README.md",
            "status": "modified",
            "additions": 52,
            "deletions": 250,
            "changes": 302,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2FREADME.md?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -1,11 +1,6 @@\n # Acorn\n \n-[![Build Status](https://travis-ci.org/acornjs/acorn.svg?branch=master)](https://travis-ci.org/acornjs/acorn)\n-[![NPM version](https://img.shields.io/npm/v/acorn.svg)](https://www.npmjs.com/package/acorn)\n-[![CDNJS](https://img.shields.io/cdnjs/v/acorn.svg)](https://cdnjs.com/libraries/acorn)  \n-[Author funding status: ![maintainer happiness](https://marijnhaverbeke.nl/fund/status_s.png?force)](https://marijnhaverbeke.nl/fund/)\n-\n-A tiny, fast JavaScript parser, written completely in JavaScript.\n+A tiny, fast JavaScript parser written in JavaScript.\n \n ## Community\n \n@@ -20,9 +15,7 @@ and discussion, please use the\n \n ## Installation\n \n-The easiest way to install acorn is with [`npm`][npm].\n-\n-[npm]: https://www.npmjs.com/\n+The easiest way to install acorn is from [`npm`](https://www.npmjs.com/):\n \n ```sh\n npm install acorn\n@@ -34,44 +27,38 @@ Alternately, you can download the source and build acorn yourself:\n git clone https://github.com/acornjs/acorn.git\n cd acorn\n npm install\n-npm run build\n ```\n \n-## Components\n-\n-When run in a CommonJS (node.js) or AMD environment, exported values\n-appear in the interfaces exposed by the individual files, as usual.\n-When loaded in the browser (Acorn works in any JS-enabled browser more\n-recent than IE5) without any kind of module management, a single\n-global object `acorn` will be defined, and all the exported properties\n-will be added to that.\n+## Interface\n \n-### Main parser\n+**parse**`(input, options)` is the main interface to the library. The\n+`input` parameter is a string, `options` can be undefined or an object\n+setting some of the options listed below. The return value will be an\n+abstract syntax tree object as specified by the [ESTree\n+spec](https://github.com/estree/estree).\n \n-This is implemented in `dist/acorn.js`, and is what you get when you\n-`require(\"acorn\")` in node.js.\n-\n-**parse**`(input, options)` is used to parse a JavaScript program.\n-The `input` parameter is a string, `options` can be undefined or an\n-object setting some of the options listed below. The return value will\n-be an abstract syntax tree object as specified by the\n-[ESTree spec][estree].\n+```javascript\n+let acorn = require(\"acorn\");\n+console.log(acorn.parse(\"1 + 1\"));\n+```\n \n-When  encountering   a  syntax   error,  the   parser  will   raise  a\n-`SyntaxError` object with a meaningful  message. The error object will\n-have a `pos` property that indicates the character offset at which the\n-error occurred,  and a `loc`  object that contains a  `{line, column}`\n+When encountering a syntax error, the parser will raise a\n+`SyntaxError` object with a meaningful message. The error object will\n+have a `pos` property that indicates the string offset at which the\n+error occurred, and a `loc` object that contains a `{line, column}`\n object referring to that same position.\n \n-[estree]: https://github.com/estree/estree\n+Options can be provided by passing a second argument, which should be\n+an object containing any of these fields:\n \n - **ecmaVersion**: Indicates the ECMAScript version to parse. Must be\n   either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018) or 10 (2019, partial\n   support). This influences support for strict mode, the set of\n   reserved words, and support for new syntax features. Default is 7.\n \n   **NOTE**: Only 'stage 4' (finalized) ECMAScript features are being\n-  implemented by Acorn.\n+  implemented by Acorn. Other proposed new features can be implemented\n+  through plugins.\n \n - **sourceType**: Indicate the mode the code should be parsed in. Can be\n   either `\"script\"` or `\"module\"`. This influences global strict mode\n@@ -100,7 +87,10 @@ object referring to that same position.\n   declarations can only appear at a program's top level. Setting this\n   option to `true` allows them anywhere where a statement is allowed.\n   \n-- **allowAwaitOutsideFunction**: By default, `await` expressions can only appear inside `async` functions. Setting this option to `true` allows to have top-level `await` expressions. They are still not allowed in non-`async` functions, though.\n+- **allowAwaitOutsideFunction**: By default, `await` expressions can\n+  only appear inside `async` functions. Setting this option to\n+  `true` allows to have top-level `await` expressions. They are\n+  still not allowed in non-`async` functions, though.\n \n - **allowHashBang**: When this is enabled (off by default), if the\n   code starts with the characters `#!` (as in a shellscript), the\n@@ -159,9 +149,10 @@ object referring to that same position.\n - **ranges**: Nodes have their start and end characters offsets\n   recorded in `start` and `end` properties (directly on the node,\n   rather than the `loc` object, which holds line/column data. To also\n-  add a [semi-standardized][range] `range` property holding a\n-  `[start, end]` array with the same numbers, set the `ranges` option\n-  to `true`.\n+  add a\n+  [semi-standardized](https://bugzilla.mozilla.org/show_bug.cgi?id=745678)\n+  `range` property holding a `[start, end]` array with the same\n+  numbers, set the `ranges` option to `true`.\n \n - **program**: It is possible to parse multiple files into a single\n   AST by passing the tree produced by parsing the first file as the\n@@ -184,15 +175,10 @@ object referring to that same position.\n   that have a single `expression` property containing the expression\n   inside parentheses.\n \n-[range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n-\n **parseExpressionAt**`(input, offset, options)` will parse a single\n expression in a string, and return its AST. It will not complain if\n there is more of the string left after the expression.\n \n-**getLineInfo**`(input, offset)` can be used to get a `{line,\n-column}` object for a given program string and character offset.\n-\n **tokenizer**`(input, options)` returns an object with a `getToken`\n method that can be called repeatedly to get the next token, a `{start,\n end, type, value}` object (with added `loc` property when the\n@@ -216,139 +202,30 @@ var tokens = [...acorn.tokenizer(str)];\n **tokTypes** holds an object mapping names to the token type objects\n that end up in the `type` properties of tokens.\n \n-#### Note on using with [Escodegen][escodegen]\n-\n-Escodegen supports generating comments from AST, attached in\n-Esprima-specific format. In order to simulate same format in\n-Acorn, consider following example:\n-\n-```javascript\n-var comments = [], tokens = [];\n-\n-var ast = acorn.parse('var x = 42; // answer', {\n-\t// collect ranges for each node\n-\tranges: true,\n-\t// collect comments in Esprima's format\n-\tonComment: comments,\n-\t// collect token ranges\n-\tonToken: tokens\n-});\n-\n-// attach comments using collected information\n-escodegen.attachComments(ast, comments, tokens);\n-\n-// generate code\n-console.log(escodegen.generate(ast, {comment: true}));\n-// > 'var x = 42;    // answer'\n-```\n-\n-[escodegen]: https://github.com/estools/escodegen\n-\n-### dist/acorn_loose.js ###\n-\n-This file implements an error-tolerant parser. It exposes a single\n-function. The loose parser is accessible in node.js via `require(\"acorn/dist/acorn_loose\")`.\n-\n-**parse_dammit**`(input, options)` takes the same arguments and\n-returns the same syntax tree as the `parse` function in `acorn.js`,\n-but never raises an error, and will do its best to parse syntactically\n-invalid code in as meaningful a way as it can. It'll insert identifier\n-nodes with name `\"✖\"` as placeholders in places where it can't make\n-sense of the input. Depends on `acorn.js`, because it uses the same\n-tokenizer.\n-\n-### dist/walk.js ###\n-\n-Implements an abstract syntax tree walker. Will store its interface in\n-`acorn.walk` when loaded without a module system.\n-\n-**simple**`(node, visitors, base, state)` does a 'simple' walk over\n-a tree. `node` should be the AST node to walk, and `visitors` an\n-object with properties whose names correspond to node types in the\n-[ESTree spec][estree]. The properties should contain functions\n-that will be called with the node object and, if applicable the state\n-at that point. The last two arguments are optional. `base` is a walker\n-algorithm, and `state` is a start state. The default walker will\n-simply visit all statements and expressions and not produce a\n-meaningful state. (An example of a use of state is to track scope at\n-each point in the tree.)\n-\n-```js\n-const acorn = require(\"acorn\")\n-const walk = require(\"acorn/dist/walk\")\n-\n-walk.simple(acorn.parse(\"let x = 10\"), {\n-  Literal(node) {\n-    console.log(`Found a literal: ${node.value}`)\n-  }\n-})\n-```\n+**getLineInfo**`(input, offset)` can be used to get a `{line,\n+column}` object for a given program string and offset.\n \n-**ancestor**`(node, visitors, base, state)` does a 'simple' walk over\n-a tree, building up an array of ancestor nodes (including the current node)\n-and passing the array to the callbacks as a third parameter.\n+### The `Parser` class\n \n-```js\n-const acorn = require(\"acorn\")\n-const walk = require(\"acorn/dist/walk\")\n+Instances of the **`Parser`** class contain all the state and logic\n+that drives a parse. It has static methods `parse`,\n+`parseExpressionAt`, and `tokenizer` that match the top-level\n+functions by the same name.\n \n-walk.ancestor(acorn.parse(\"foo('hi')\"), {\n-  Literal(_, ancestors) {\n-    console.log(\"This literal's ancestors are:\",\n-                ancestors.map(n => n.type))\n-  }\n-})\n-```\n+When extending the parser with plugins, you need to call these methods\n+on the extended version of the class. To extend a parser with plugins,\n+you can use its static `extend` method.\n \n-**recursive**`(node, state, functions, base)` does a 'recursive'\n-walk, where the walker functions are responsible for continuing the\n-walk on the child nodes of their target node. `state` is the start\n-state, and `functions` should contain an object that maps node types\n-to walker functions. Such functions are called with `(node, state, c)`\n-arguments, and can cause the walk to continue on a sub-node by calling\n-the `c` argument on it with `(node, state)` arguments. The optional\n-`base` argument provides the fallback walker functions for node types\n-that aren't handled in the `functions` object. If not given, the\n-default walkers will be used.\n-\n-**make**`(functions, base)` builds a new walker object by using the\n-walker functions in `functions` and filling in the missing ones by\n-taking defaults from `base`.\n-\n-**full**`(node, callback, base, state)` does a 'full'\n-walk over a tree, calling the callback with the arguments (node, state, type)\n-for each node\n-\n-**fullAncestor**`(node, callback, base, state)` does a 'full' walk over\n-a tree, building up an array of ancestor nodes (including the current node)\n-and passing the array to the callbacks as a third parameter.\n-\n-```js\n-const acorn = require(\"acorn\")\n-const walk = require(\"acorn/dist/walk\")\n-\n-walk.full(acorn.parse(\"1 + 1\"), node => {\n-  console.log(`There's a ${node.type} node at ${node.ch}`)\n-})\n+```javascript\n+var acorn = require(\"acorn\");\n+var jsx = require(\"acorn-jsx\");\n+var JSXParser = acorn.Parser.extend(jsx());\n+JSXParser.parse(\"foo(<bar/>)\");\n ```\n \n-**findNodeAt**`(node, start, end, test, base, state)` tries to\n-locate a node in a tree at the given start and/or end offsets, which\n-satisfies the predicate `test`. `start` and `end` can be either `null`\n-(as wildcard) or a number. `test` may be a string (indicating a node\n-type) or a function that takes `(nodeType, node)` arguments and\n-returns a boolean indicating whether this node is interesting. `base`\n-and `state` are optional, and can be used to specify a custom walker.\n-Nodes are tested from inner to outer, so if two nodes match the\n-boundaries, the inner one will be preferred.\n-\n-**findNodeAround**`(node, pos, test, base, state)` is a lot like\n-`findNodeAt`, but will match any node that exists 'around' (spanning)\n-the given position.\n-\n-**findNodeAfter**`(node, pos, test, base, state)` is similar to\n-`findNodeAround`, but will match all nodes *after* the given position\n-(testing outer nodes before inner nodes).\n+The `extend` method takes any number of plugin values, and returns a\n+new `Parser` class that includes the extra parser logic provided by\n+the plugins.\n \n ## Command line interface\n \n@@ -357,15 +234,16 @@ line. It accepts as arguments its input file and the following\n options:\n \n - `--ecma3|--ecma5|--ecma6|--ecma7|--ecma8|--ecma9|--ecma10`: Sets the ECMAScript version\n-  to parse. Default is version 7.\n+  to parse. Default is version 9.\n \n - `--module`: Sets the parsing mode to `\"module\"`. Is set to `\"script\"` otherwise.\n \n - `--locations`: Attaches a \"loc\" object to each node with \"start\" and\n   \"end\" subobjects, each of which contains the one-based line and\n   zero-based column numbers in `{line, column}` form.\n \n-- `--allow-hash-bang`: If the code starts with the characters #! (as in a shellscript), the first line will be treated as a comment.\n+- `--allow-hash-bang`: If the code starts with the characters #! (as\n+  in a shellscript), the first line will be treated as a comment.\n \n - `--compact`: No whitespace is used in the AST output.\n \n@@ -375,82 +253,11 @@ options:\n \n The utility spits out the syntax tree as JSON data.\n \n-## Build system\n-\n-Acorn is written in ECMAScript 6, as a set of small modules, in the\n-project's `src` directory, and compiled down to bigger ECMAScript 3\n-files in `dist` using [Browserify](http://browserify.org) and\n-[Babel](http://babeljs.io/). If you are already using Babel, you can\n-consider including the modules directly.\n-\n-The command-line test runner (`npm test`) uses the ES6 modules. The\n-browser-based test page (`test/index.html`) uses the compiled modules.\n-The `bin/build-acorn.js` script builds the latter from the former.\n-\n-If you are working on Acorn, you'll probably want to try the code out\n-directly, without an intermediate build step. In your scripts, you can\n-register the Babel require shim like this:\n-\n-    require(\"babel-core/register\")\n-\n-That will allow you to directly `require` the ES6 modules.\n-\n-## Plugins\n-\n-Acorn is designed support allow plugins which, within reasonable\n-bounds, redefine the way the parser works. Plugins can add new token\n-types and new tokenizer contexts (if necessary), and extend methods in\n-the parser object. This is not a clean, elegant API—using it requires\n-an understanding of Acorn's internals, and plugins are likely to break\n-whenever those internals are significantly changed. But still, it is\n-_possible_, in this way, to create parsers for JavaScript dialects\n-without forking all of Acorn. And in principle it is even possible to\n-combine such plugins, so that if you have, for example, a plugin for\n-parsing types and a plugin for parsing JSX-style XML literals, you\n-could load them both and parse code with both JSX tags and types.\n-\n-A plugin should register itself by adding a property to\n-`acorn.plugins`, which holds a function. Calling `acorn.parse`, a\n-`plugins` option can be passed, holding an object mapping plugin names\n-to configuration values (or just `true` for plugins that don't take\n-options). After the parser object has been created, the initialization\n-functions for the chosen plugins are called with `(parser,\n-configValue)` arguments. They are expected to use the `parser.extend`\n-method to extend parser methods. For example, the `readToken` method\n-could be extended like this:\n-\n-```javascript\n-parser.extend(\"readToken\", function(nextMethod) {\n-  return function(code) {\n-    console.log(\"Reading a token!\")\n-    return nextMethod.call(this, code)\n-  }\n-})\n-```\n-\n-The `nextMethod` argument passed to `extend`'s second argument is the\n-previous value of this method, and should usually be called through to\n-whenever the extended method does not handle the call itself.\n-\n-Similarly, the loose parser allows plugins to register themselves via\n-`acorn.pluginsLoose`.  The extension mechanism is the same as for the\n-normal parser:\n-\n-```javascript\n-looseParser.extend(\"readToken\", function(nextMethod) {\n-  return function() {\n-    console.log(\"Reading a token in the loose parser!\")\n-    return nextMethod.call(this)\n-  }\n-})\n-```\n-\n-### Existing plugins\n+## Existing plugins\n \n  - [`acorn-jsx`](https://github.com/RReverser/acorn-jsx): Parse [Facebook JSX syntax extensions](https://github.com/facebook/jsx)\n- - [`acorn-objj`](https://github.com/cappuccino/acorn-objj): [Objective-J](http://www.cappuccino-project.org/learn/objective-j.html) language parser built as Acorn plugin\n  \n- Plugins for ECMAScript proposals:\n+Plugins for ECMAScript proposals:\n  \n  - [`acorn-stage3`](https://github.com/acornjs/acorn-stage3): Parse most stage 3 proposals, bundling:\n    - [`acorn-async-iteration`](https://github.com/acornjs/acorn-async-iteration): Parse [async iteration proposal](https://github.com/tc39/proposal-async-iteration)\n@@ -459,9 +266,4 @@ looseParser.extend(\"readToken\", function(nextMethod) {\n    - [`acorn-dynamic-import`](https://github.com/kesne/acorn-dynamic-import): Parse [import() proposal](https://github.com/tc39/proposal-dynamic-import)\n    - [`acorn-import-meta`](https://github.com/acornjs/acorn-import-meta): Parse [import.meta proposal](https://github.com/tc39/proposal-import-meta)\n    - [`acorn-numeric-separator`](https://github.com/acornjs/acorn-numeric-separator): Parse [numeric separator proposal](https://github.com/tc39/proposal-numeric-separator)\n-   - [`acorn-optional-catch-binding`](https://github.com/acornjs/acorn-optional-catch-binding): Parse [optional catch binding proposal](https://github.com/tc39/proposal-optional-catch-binding)\n-   - [`acorn-private-methods`](https://github.com/acornjs/acorn-private-methods): parse [private methods, getters and setters proposal](https://github.com/tc39/proposal-private-methods)\n-   - [`acorn5-object-spread`](https://github.com/adrianheine/acorn5-object-spread): Parse [Object Rest/Spread Properties proposal](https://github.com/tc39/proposal-object-rest-spread)\n- - [`acorn-object-rest-spread`](https://github.com/victor-homyakov/acorn-object-rest-spread): Parse [Object Rest/Spread Properties proposal](https://github.com/tc39/proposal-object-rest-spread)\n- - [`acorn-es7`](https://github.com/angelozerr/acorn-es7): Parse [decorator syntax proposal](https://github.com/wycats/javascript-decorators)\n- - [`acorn-static-class-property-initializer`](https://github.com/victor-homyakov/acorn-static-class-property-initializer): Partial support for static class properties from [ES Class Fields & Static Properties Proposal](https://github.com/tc39/proposal-class-public-fields) to support static property initializers in [React components written as ES6+ classes](https://babeljs.io/blog/2015/07/07/react-on-es6-plus)\n+   - [`acorn-private-methods`](https://github.com/acornjs/acorn-private-methods): parse [private methods, getters and setters proposal](https://github.com/tc39/proposal-private-methods)n"
        },
        {
            "sha": "cf7df46890fdd48bbaa57fb0478c142bc4409f21",
            "filename": "tools/node_modules/eslint/node_modules/acorn/bin/acorn",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fbin%2Facorn",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fbin%2Facorn",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fbin%2Facorn?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -1,4 +1,4 @@\n #!/usr/bin/env node\n 'use strict';\n \n-require('./_acorn.js');\n+require('../dist/bin.js');"
        },
        {
            "sha": "150429a1f20957dbe02911afe5deb7b214a79c00",
            "filename": "tools/node_modules/eslint/node_modules/acorn/bin/run_test262.js",
            "status": "removed",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fbin%2Frun_test262.js",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fbin%2Frun_test262.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fbin%2Frun_test262.js?ref=9697c0820f015ccf898a3662305a0caa3cd9c208",
            "patch": "@@ -1,21 +0,0 @@\n-const fs = require(\"fs\")\n-const path = require(\"path\")\n-const run = require(\"test262-parser-runner\")\n-const parse = require(\"..\").parse\n-\n-const unsupportedFeatures = [\n-  \"BigInt\",\n-  \"class-fields\",\n-  \"class-fields-private\",\n-  \"class-fields-public\",\n-  \"numeric-separator-literal\"\n-];\n-\n-run(\n-  (content, {sourceType}) => parse(content, {sourceType, ecmaVersion: 10}),\n-  {\n-    testsDirectory: path.dirname(require.resolve(\"test262/package.json\")),\n-    skip: test => (test.attrs.features && unsupportedFeatures.some(f => test.attrs.features.includes(f))),\n-    whitelist: fs.readFileSync(\"./bin/test262.whitelist\", \"utf8\").split(\"\\n\").filter(v => v)\n-  }\n-)"
        },
        {
            "sha": "c8c6ce4a82774ba060d0eab4beaa74408c6101e8",
            "filename": "tools/node_modules/eslint/node_modules/acorn/bin/test262.whitelist",
            "status": "removed",
            "additions": 0,
            "deletions": 404,
            "changes": 404,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fbin%2Ftest262.whitelist",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fbin%2Ftest262.whitelist",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fbin%2Ftest262.whitelist?ref=9697c0820f015ccf898a3662305a0caa3cd9c208",
            "patch": "@@ -1,404 +0,0 @@\n-annexB/language/function-code/block-decl-func-no-skip-try.js (default)\n-annexB/language/function-code/block-decl-func-skip-early-err-block.js (default)\n-annexB/language/function-code/block-decl-func-skip-early-err.js (default)\n-annexB/language/function-code/block-decl-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/block-decl-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-no-skip-try.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-skip-early-err.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-decl-else-decl-a-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-no-skip-try.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-skip-early-err.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-decl-else-decl-b-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-no-skip-try.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-skip-early-err.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-decl-else-stmt-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-decl-no-else-func-no-skip-try.js (default)\n-annexB/language/function-code/if-decl-no-else-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-decl-no-else-func-skip-early-err.js (default)\n-annexB/language/function-code/if-decl-no-else-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-decl-no-else-func-skip-early-err-try.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-no-skip-try.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-skip-early-err-block.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-skip-early-err.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/if-stmt-else-decl-func-skip-early-err-try.js (default)\n-annexB/language/function-code/switch-case-func-no-skip-try.js (default)\n-annexB/language/function-code/switch-case-func-skip-early-err-block.js (default)\n-annexB/language/function-code/switch-case-func-skip-early-err.js (default)\n-annexB/language/function-code/switch-case-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/switch-case-func-skip-early-err-try.js (default)\n-annexB/language/function-code/switch-dflt-func-no-skip-try.js (default)\n-annexB/language/function-code/switch-dflt-func-skip-early-err-block.js (default)\n-annexB/language/function-code/switch-dflt-func-skip-early-err.js (default)\n-annexB/language/function-code/switch-dflt-func-skip-early-err-switch.js (default)\n-annexB/language/function-code/switch-dflt-func-skip-early-err-try.js (default)\n-annexB/language/global-code/block-decl-global-no-skip-try.js (default)\n-annexB/language/global-code/block-decl-global-skip-early-err-block.js (default)\n-annexB/language/global-code/block-decl-global-skip-early-err.js (default)\n-annexB/language/global-code/block-decl-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/block-decl-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-no-skip-try.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-skip-early-err.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-decl-else-decl-a-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-no-skip-try.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-skip-early-err.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-decl-else-decl-b-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-no-skip-try.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-skip-early-err.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-decl-else-stmt-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-decl-no-else-global-no-skip-try.js (default)\n-annexB/language/global-code/if-decl-no-else-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-decl-no-else-global-skip-early-err.js (default)\n-annexB/language/global-code/if-decl-no-else-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-decl-no-else-global-skip-early-err-try.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-no-skip-try.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-skip-early-err-block.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-skip-early-err.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/if-stmt-else-decl-global-skip-early-err-try.js (default)\n-annexB/language/global-code/switch-case-global-no-skip-try.js (default)\n-annexB/language/global-code/switch-case-global-skip-early-err-block.js (default)\n-annexB/language/global-code/switch-case-global-skip-early-err.js (default)\n-annexB/language/global-code/switch-case-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/switch-case-global-skip-early-err-try.js (default)\n-annexB/language/global-code/switch-dflt-global-no-skip-try.js (default)\n-annexB/language/global-code/switch-dflt-global-skip-early-err-block.js (default)\n-annexB/language/global-code/switch-dflt-global-skip-early-err.js (default)\n-annexB/language/global-code/switch-dflt-global-skip-early-err-switch.js (default)\n-annexB/language/global-code/switch-dflt-global-skip-early-err-try.js (default)\n-annexB/language/statements/try/catch-redeclared-for-in-var.js (default)\n-annexB/language/statements/try/catch-redeclared-for-in-var.js (strict mode)\n-annexB/language/statements/try/catch-redeclared-for-var.js (default)\n-annexB/language/statements/try/catch-redeclared-for-var.js (strict mode)\n-annexB/language/statements/try/catch-redeclared-var-statement-captured.js (default)\n-annexB/language/statements/try/catch-redeclared-var-statement-captured.js (strict mode)\n-annexB/language/statements/try/catch-redeclared-var-statement.js (default)\n-annexB/language/statements/try/catch-redeclared-var-statement.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-const-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-const-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-let-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-let-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/const-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/const-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/block-scope/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/let-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/let-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/block-scope/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/expressions/async-arrow-function/early-errors-arrow-await-in-formals-default.js (default)\n-language/expressions/async-arrow-function/early-errors-arrow-await-in-formals-default.js (strict mode)\n-language/expressions/async-arrow-function/early-errors-arrow-body-contains-super-call.js (default)\n-language/expressions/async-arrow-function/early-errors-arrow-body-contains-super-call.js (strict mode)\n-language/expressions/async-arrow-function/early-errors-arrow-body-contains-super-property.js (default)\n-language/expressions/async-arrow-function/early-errors-arrow-body-contains-super-property.js (strict mode)\n-language/expressions/async-function/early-errors-expression-body-contains-super-call.js (default)\n-language/expressions/async-function/early-errors-expression-body-contains-super-call.js (strict mode)\n-language/expressions/async-function/early-errors-expression-body-contains-super-property.js (default)\n-language/expressions/async-function/early-errors-expression-body-contains-super-property.js (strict mode)\n-language/expressions/async-function/early-errors-expression-formals-contains-super-call.js (default)\n-language/expressions/async-function/early-errors-expression-formals-contains-super-call.js (strict mode)\n-language/expressions/async-function/early-errors-expression-formals-contains-super-property.js (default)\n-language/expressions/async-function/early-errors-expression-formals-contains-super-property.js (strict mode)\n-language/expressions/class/method-param-dflt-yield.js (default)\n-language/expressions/class/static-method-param-dflt-yield.js (default)\n-language/expressions/function/early-body-super-call.js (default)\n-language/expressions/function/early-body-super-call.js (strict mode)\n-language/expressions/function/early-body-super-prop.js (default)\n-language/expressions/function/early-body-super-prop.js (strict mode)\n-language/expressions/function/early-params-super-call.js (default)\n-language/expressions/function/early-params-super-call.js (strict mode)\n-language/expressions/function/early-params-super-prop.js (default)\n-language/expressions/function/early-params-super-prop.js (strict mode)\n-language/expressions/object/method-definition/early-errors-object-method-body-contains-super-call.js (default)\n-language/expressions/object/method-definition/early-errors-object-method-body-contains-super-call.js (strict mode)\n-language/expressions/object/method-definition/early-errors-object-method-duplicate-parameters.js (default)\n-language/expressions/object/method-definition/early-errors-object-method-formals-contains-super-call.js (default)\n-language/expressions/object/method-definition/early-errors-object-method-formals-contains-super-call.js (strict mode)\n-language/expressions/object/method-definition/generator-super-call-body.js (default)\n-language/expressions/object/method-definition/generator-super-call-body.js (strict mode)\n-language/expressions/object/method-definition/generator-super-call-param.js (default)\n-language/expressions/object/method-definition/generator-super-call-param.js (strict mode)\n-language/expressions/object/prop-def-invalid-async-prefix.js (default)\n-language/expressions/object/prop-def-invalid-async-prefix.js (strict mode)\n-language/expressions/yield/in-iteration-stmt.js (default)\n-language/expressions/yield/in-iteration-stmt.js (strict mode)\n-language/expressions/yield/star-in-iteration-stmt.js (default)\n-language/expressions/yield/star-in-iteration-stmt.js (strict mode)\n-language/global-code/new.target-arrow.js (default)\n-language/global-code/new.target-arrow.js (strict mode)\n-language/global-code/super-call-arrow.js (default)\n-language/global-code/super-call-arrow.js (strict mode)\n-language/global-code/super-prop-arrow.js (default)\n-language/global-code/super-prop-arrow.js (strict mode)\n-language/module-code/early-export-global.js (default)\n-language/module-code/early-export-global.js (strict mode)\n-language/module-code/early-export-unresolvable.js (default)\n-language/module-code/early-export-unresolvable.js (strict mode)\n-language/statements/async-function/early-errors-declaration-body-contains-super-call.js (default)\n-language/statements/async-function/early-errors-declaration-body-contains-super-call.js (strict mode)\n-language/statements/async-function/early-errors-declaration-body-contains-super-property.js (default)\n-language/statements/async-function/early-errors-declaration-body-contains-super-property.js (strict mode)\n-language/statements/async-function/early-errors-declaration-formals-contains-super-call.js (default)\n-language/statements/async-function/early-errors-declaration-formals-contains-super-call.js (strict mode)\n-language/statements/async-function/early-errors-declaration-formals-contains-super-property.js (default)\n-language/statements/async-function/early-errors-declaration-formals-contains-super-property.js (strict mode)\n-language/expressions/async-generator/early-errors-expression-body-contains-super-call.js (default)\n-language/expressions/async-generator/early-errors-expression-body-contains-super-call.js (strict mode)\n-language/expressions/async-generator/early-errors-expression-body-contains-super-property.js (default)\n-language/expressions/async-generator/early-errors-expression-body-contains-super-property.js (strict mode)\n-language/expressions/async-generator/early-errors-expression-formals-contains-super-call.js (default)\n-language/expressions/async-generator/early-errors-expression-formals-contains-super-call.js (strict mode)\n-language/expressions/async-generator/early-errors-expression-formals-contains-super-property.js (default)\n-language/expressions/async-generator/early-errors-expression-formals-contains-super-property.js (strict mode)\n-language/statements/class/definition/early-errors-class-method-arguments-in-formal-parameters.js (default)\n-language/statements/class/definition/early-errors-class-method-body-contains-super-call.js (default)\n-language/statements/class/definition/early-errors-class-method-body-contains-super-call.js (strict mode)\n-language/statements/class/definition/early-errors-class-method-duplicate-parameters.js (default)\n-language/statements/class/definition/early-errors-class-method-eval-in-formal-parameters.js (default)\n-language/statements/class/definition/early-errors-class-method-formals-contains-super-call.js (default)\n-language/statements/class/definition/early-errors-class-method-formals-contains-super-call.js (strict mode)\n-language/statements/class/definition/methods-gen-yield-as-function-expression-binding-identifier.js (default)\n-language/statements/class/definition/methods-gen-yield-as-identifier-in-nested-function.js (default)\n-language/statements/class/method-param-yield.js (default)\n-language/statements/class/static-method-param-yield.js (default)\n-language/statements/class/strict-mode/with.js (default)\n-language/statements/class/syntax/early-errors/class-body-has-direct-super-missing-class-heritage.js (default)\n-language/statements/class/syntax/early-errors/class-body-has-direct-super-missing-class-heritage.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-method-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-method-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-special-method-generator-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-special-method-generator-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-special-method-get-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-special-method-get-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-special-method-set-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-special-method-set-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-static-method-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-static-method-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-static-method-get-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-static-method-get-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-body-static-method-set-contains-direct-super.js (default)\n-language/statements/class/syntax/early-errors/class-body-static-method-set-contains-direct-super.js (strict mode)\n-language/statements/class/syntax/early-errors/class-definition-evaluation-block-duplicate-binding.js (default)\n-language/statements/class/syntax/early-errors/class-definition-evaluation-block-duplicate-binding.js (strict mode)\n-language/statements/class/syntax/early-errors/class-definition-evaluation-scriptbody-duplicate-binding.js (default)\n-language/statements/class/syntax/early-errors/class-definition-evaluation-scriptbody-duplicate-binding.js (strict mode)\n-language/statements/const/syntax/const-declaring-let-split-across-two-lines.js (default)\n-language/statements/do-while/labelled-fn-stmt.js (default)\n-language/statements/for/head-let-bound-names-in-stmt.js (default)\n-language/statements/for/head-let-bound-names-in-stmt.js (strict mode)\n-language/statements/for-in/head-const-bound-names-in-stmt.js (default)\n-language/statements/for-in/head-const-bound-names-in-stmt.js (strict mode)\n-language/statements/for-in/head-const-bound-names-let.js (default)\n-language/statements/for-in/head-let-bound-names-in-stmt.js (default)\n-language/statements/for-in/head-let-bound-names-in-stmt.js (strict mode)\n-language/statements/for-in/head-let-bound-names-let.js (default)\n-language/statements/for-in/labelled-fn-stmt-const.js (default)\n-language/statements/for-in/labelled-fn-stmt-let.js (default)\n-language/statements/for-in/labelled-fn-stmt-lhs.js (default)\n-language/statements/for-in/labelled-fn-stmt-var.js (default)\n-language/statements/for-in/let-block-with-newline.js (default)\n-language/statements/for-in/let-identifier-with-newline.js (default)\n-language/statements/for/labelled-fn-stmt-expr.js (default)\n-language/statements/for/labelled-fn-stmt-let.js (default)\n-language/statements/for/labelled-fn-stmt-var.js (default)\n-language/statements/for/let-block-with-newline.js (default)\n-language/statements/for/let-identifier-with-newline.js (default)\n-language/statements/for-of/head-const-bound-names-in-stmt.js (default)\n-language/statements/for-of/head-const-bound-names-in-stmt.js (strict mode)\n-language/statements/for-of/head-const-bound-names-let.js (default)\n-language/statements/for-of/head-let-bound-names-in-stmt.js (default)\n-language/statements/for-of/head-let-bound-names-in-stmt.js (strict mode)\n-language/statements/for-of/head-let-bound-names-let.js (default)\n-language/statements/for-of/labelled-fn-stmt-const.js (default)\n-language/statements/for-of/labelled-fn-stmt-let.js (default)\n-language/statements/for-of/labelled-fn-stmt-lhs.js (default)\n-language/statements/for-of/labelled-fn-stmt-var.js (default)\n-language/statements/for-of/let-block-with-newline.js (default)\n-language/statements/for-of/let-identifier-with-newline.js (default)\n-language/statements/for-await-of/let-block-with-newline.js (default)\n-language/statements/for-await-of/let-identifier-with-newline.js (default)\n-language/statements/function/early-body-super-call.js (default)\n-language/statements/function/early-body-super-call.js (strict mode)\n-language/statements/function/early-body-super-prop.js (default)\n-language/statements/function/early-body-super-prop.js (strict mode)\n-language/statements/function/early-params-super-call.js (default)\n-language/statements/function/early-params-super-call.js (strict mode)\n-language/statements/function/early-params-super-prop.js (default)\n-language/statements/function/early-params-super-prop.js (strict mode)\n-language/statements/if/if-gen-else-gen.js (default)\n-language/statements/if/if-gen-else-stmt.js (default)\n-language/statements/if/if-gen-no-else.js (default)\n-language/statements/if/if-stmt-else-gen.js (default)\n-language/statements/if/labelled-fn-stmt-first.js (default)\n-language/statements/if/labelled-fn-stmt-lone.js (default)\n-language/statements/if/labelled-fn-stmt-second.js (default)\n-language/statements/if/let-block-with-newline.js (default)\n-language/statements/if/let-identifier-with-newline.js (default)\n-language/statements/labeled/let-block-with-newline.js (default)\n-language/statements/labeled/let-identifier-with-newline.js (default)\n-language/statements/let/syntax/identifier-let-disallowed-as-boundname.js (default)\n-language/statements/let/syntax/let-let-declaration-split-across-two-lines.js (default)\n-language/statements/let/syntax/let-let-declaration-with-initializer-split-across-two-lines.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/async-generator-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-const-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-const-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-let-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-let-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/class-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/const-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/const-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/function-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-var-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/generator-declaration-attempt-to-redeclare-with-var-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/let-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/let-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-async-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-class-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-class-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-function-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-function-declaration.js (strict mode)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-generator-declaration.js (default)\n-language/statements/switch/syntax/redeclaration/var-declaration-attempt-to-redeclare-with-generator-declaration.js (strict mode)\n-language/statements/while/labelled-fn-stmt.js (default)\n-language/statements/while/let-block-with-newline.js (default)\n-language/statements/while/let-identifier-with-newline.js (default)\n-language/statements/with/labelled-fn-stmt.js (default)\n-language/statements/with/let-block-with-newline.js (default)\n-language/statements/with/let-identifier-with-newline.js (default)\n-language/white-space/mongolian-vowel-separator.js (default)\n-language/white-space/mongolian-vowel-separator.js (strict mode)"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/.keep",
            "status": "removed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2F.keep",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2F.keep",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2F.keep?ref=9697c0820f015ccf898a3662305a0caa3cd9c208"
        },
        {
            "sha": "1c8d927d6ecc8c43aa58867d27e11cddde70ebbd",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/acorn.d.ts",
            "status": "added",
            "additions": 208,
            "deletions": 0,
            "changes": 208,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.d.ts",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.d.ts",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.d.ts?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -0,0 +1,208 @@\n+export as namespace acorn\n+export = acorn\n+\n+declare namespace acorn {\n+  function parse(input: string, options?: Options): Node\n+\n+  function parseExpressionAt(input: string, pos?: number, options?: Options): Node\n+\n+  function tokenizer(input: string, options?: Options): {\n+    getToken(): Token\n+    [Symbol.iterator](): Iterator<Token>\n+  }\n+\n+  interface Options {\n+    ecmaVersion?: 3 | 5 | 6 | 7 | 8 | 9 | 10 | 2015 | 2016 | 2017 | 2018 | 2019\n+    sourceType?: 'script' | 'module'\n+    onInsertedSemicolon?: (lastTokEnd: number, lastTokEndLoc?: Position) => void\n+    onTrailingComma?: (lastTokEnd: number, lastTokEndLoc?: Position) => void\n+    allowReserved?: boolean\n+    allowReturnOutsideFunction?: boolean\n+    allowImportExportEverywhere?: boolean\n+    allowHashBang?: boolean\n+    locations?: boolean\n+    onToken?: ((token: Token) => any) | Token[]\n+    onComment?: ((\n+      isBlock: boolean, text: string, start: number, end: number, startLoc?: Position,\n+      endLoc?: Position\n+    ) => void) | Comment[]\n+    ranges?: boolean\n+    program?: Node\n+    sourceFile?: string\n+    directSourceFile?: string\n+    preserveParens?: boolean\n+  }\n+\n+  class Parser {\n+    constructor(options: Options, input: string, startPos?: number)\n+    parse(): Node\n+    static parse(input: string, options?: Options): Node\n+    static parseExpressionAt(input: string, pos: number, options?: Options): Node\n+    static tokenizer(input: string, options?: Options): {\n+      getToken(): Token\n+      [Symbol.iterator](): Iterator<Token>\n+    }\n+    static extend(...plugins: (typeof Parser)[]): typeof Parser\n+  }\n+\n+  interface Position { line: number; column: number; offset: number }\n+\n+  const defaultOptions: Options\n+\n+  function getLineInfo(input: string, offset: number): Position\n+\n+  class SourceLocation {\n+    start: Position\n+    end: Position\n+    source?: string | null\n+    constructor(p: Parser, start: Position, end: Position)\n+  }\n+\n+  class Node {\n+    type: string\n+    start: number\n+    end: number\n+    loc?: SourceLocation\n+    sourceFile?: string\n+    range?: [number, number]\n+    constructor(parser: Parser, pos: number, loc?: SourceLocation)\n+  }\n+\n+  class TokenType {\n+    label: string\n+    keyword: string\n+    beforeExpr: boolean\n+    startsExpr: boolean\n+    isLoop: boolean\n+    isAssign: boolean\n+    prefix: boolean\n+    postfix: boolean\n+    binop: number\n+    updateContext?: (prevType: TokenType) => void\n+    constructor(label: string, conf?: any)\n+  }\n+\n+  const tokTypes: {\n+    num: TokenType\n+    regexp: TokenType\n+    string: TokenType\n+    name: TokenType\n+    eof: TokenType\n+    bracketL: TokenType\n+    bracketR: TokenType\n+    braceL: TokenType\n+    braceR: TokenType\n+    parenL: TokenType\n+    parenR: TokenType\n+    comma: TokenType\n+    semi: TokenType\n+    colon: TokenType\n+    dot: TokenType\n+    question: TokenType\n+    arrow: TokenType\n+    template: TokenType\n+    ellipsis: TokenType\n+    backQuote: TokenType\n+    dollarBraceL: TokenType\n+    eq: TokenType\n+    assign: TokenType\n+    incDec: TokenType\n+    prefix: TokenType\n+    logicalOR: TokenType\n+    logicalAND: TokenType\n+    bitwiseOR: TokenType\n+    bitwiseXOR: TokenType\n+    bitwiseAND: TokenType\n+    equality: TokenType\n+    relational: TokenType\n+    bitShift: TokenType\n+    plusMin: TokenType\n+    modulo: TokenType\n+    star: TokenType\n+    slash: TokenType\n+    starstar: TokenType\n+    _break: TokenType\n+    _case: TokenType\n+    _catch: TokenType\n+    _continue: TokenType\n+    _debugger: TokenType\n+    _default: TokenType\n+    _do: TokenType\n+    _else: TokenType\n+    _finally: TokenType\n+    _for: TokenType\n+    _function: TokenType\n+    _if: TokenType\n+    _return: TokenType\n+    _switch: TokenType\n+    _throw: TokenType\n+    _try: TokenType\n+    _var: TokenType\n+    _const: TokenType\n+    _while: TokenType\n+    _with: TokenType\n+    _new: TokenType\n+    _this: TokenType\n+    _super: TokenType\n+    _class: TokenType\n+    _extends: TokenType\n+    _export: TokenType\n+    _import: TokenType\n+    _null: TokenType\n+    _true: TokenType\n+    _false: TokenType\n+    _in: TokenType\n+    _instanceof: TokenType\n+    _typeof: TokenType\n+    _void: TokenType\n+    _delete: TokenType\n+  }\n+\n+  class TokContext {\n+    constructor(token: string, isExpr: boolean, preserveSpace: boolean, override?: (p: Parser) => void)\n+  }\n+\n+  const tokContexts: {\n+    b_stat: TokContext\n+    b_expr: TokContext\n+    b_tmpl: TokContext\n+    p_stat: TokContext\n+    p_expr: TokContext\n+    q_tmpl: TokContext\n+    f_expr: TokContext\n+  }\n+\n+  function isIdentifierStart(code: number, astral?: boolean): boolean\n+\n+  function isIdentifierChar(code: number, astral?: boolean): boolean\n+\n+  interface AbstractToken {\n+  }\n+\n+  interface Comment extends AbstractToken {\n+    type: string\n+    value: string\n+    start: number\n+    end: number\n+    loc?: SourceLocation\n+    range?: [number, number]\n+  }\n+\n+  class Token {\n+    type: TokenType\n+    value: any\n+    start: number\n+    end: number\n+    loc?: SourceLocation\n+    range?: [number, number]\n+    constructor(p: Parser)\n+  }\n+\n+  function isNewLine(code: number): boolean\n+\n+  const lineBreak: RegExp\n+\n+  const lineBreakG: RegExp\n+\n+  const version: string\n+}"
        },
        {
            "sha": "922ff0c9fc9c1b2816433f5f1293ab64e986fd8a",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/acorn.js",
            "status": "modified",
            "additions": 201,
            "deletions": 232,
            "changes": 433,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -313,11 +313,12 @@ function getLineInfo(input, offset) {\n // the parser process. These options are recognized:\n \n var defaultOptions = {\n-  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n-  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n-  // for strict mode, the set of reserved words, and support for\n-  // new syntax features. The default is 7.\n-  ecmaVersion: 7,\n+  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n+  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n+  // (2019). This influences support for strict mode, the set of\n+  // reserved words, and support for new syntax features. The default\n+  // is 9.\n+  ecmaVersion: 9,\n   // `sourceType` indicates the mode the code should be parsed in.\n   // Can be either `\"script\"` or `\"module\"`. This influences global\n   // strict mode and parsing of `import` and `export` declarations.\n@@ -393,8 +394,7 @@ var defaultOptions = {\n   directSourceFile: null,\n   // When enabled, parenthesized expressions are represented by\n   // (non-standard) ParenthesizedExpression nodes\n-  preserveParens: false,\n-  plugins: {}\n+  preserveParens: false\n };\n \n // Interpret and default an options object\n@@ -437,8 +437,26 @@ function pushComment(options, array) {\n   }\n }\n \n-// Registered plugins\n-var plugins = {};\n+// Each scope gets a bitset that may contain these flags\n+var SCOPE_TOP = 1;\n+var SCOPE_FUNCTION = 2;\n+var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION;\n+var SCOPE_ASYNC = 4;\n+var SCOPE_GENERATOR = 8;\n+var SCOPE_ARROW = 16;\n+var SCOPE_SIMPLE_CATCH = 32;\n+\n+function functionFlags(async, generator) {\n+  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n+}\n+\n+// Used in checkLVal and declareName to determine the type of a binding\n+var BIND_NONE = 0;\n+var BIND_VAR = 1;\n+var BIND_LEXICAL = 2;\n+var BIND_FUNCTION = 3;\n+var BIND_SIMPLE_CATCH = 4;\n+var BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n \n function keywordRegexp(words) {\n   return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n@@ -465,9 +483,6 @@ var Parser = function Parser(options, input, startPos) {\n   // escape sequences must not be interpreted as keywords.\n   this.containsEsc = false;\n \n-  // Load plugins\n-  this.loadPlugins(options.plugins);\n-\n   // Set up token state\n \n   // The current position of the tokenizer in the input.\n@@ -508,8 +523,6 @@ var Parser = function Parser(options, input, startPos) {\n   // Used to signify the start of a potential arrow function\n   this.potentialArrowAt = -1;\n \n-  // Flags to track whether we are in a function, a generator, an async function.\n-  this.inFunction = this.inGenerator = this.inAsync = false;\n   // Positions to delayed-check that yield/await does not exist in default parameters.\n   this.yieldPos = this.awaitPos = 0;\n   // Labels in scope.\n@@ -521,36 +534,49 @@ var Parser = function Parser(options, input, startPos) {\n \n   // Scope tracking for duplicate variable names (see scope.js)\n   this.scopeStack = [];\n-  this.enterFunctionScope();\n+  this.enterScope(SCOPE_TOP);\n \n   // For RegExp validation\n   this.regexpState = null;\n };\n \n-// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n-Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\n-Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n+var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true } };\n \n-Parser.prototype.extend = function extend (name, f) {\n-  this[name] = f(this[name]);\n+Parser.prototype.parse = function parse () {\n+  var node = this.options.program || this.startNode();\n+  this.nextToken();\n+  return this.parseTopLevel(node)\n };\n \n-Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n-    var this$1 = this;\n+prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n+prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n+prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n \n-  for (var name in pluginConfigs) {\n-    var plugin = plugins[name];\n-    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n-    plugin(this$1, pluginConfigs[name]);\n-  }\n+Parser.extend = function extend () {\n+    var plugins = [], len = arguments.length;\n+    while ( len-- ) plugins[ len ] = arguments[ len ];\n+\n+  var cls = this;\n+  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n+  return cls\n };\n \n-Parser.prototype.parse = function parse () {\n-  var node = this.options.program || this.startNode();\n-  this.nextToken();\n-  return this.parseTopLevel(node)\n+Parser.parse = function parse (input, options) {\n+  return new this(options, input).parse()\n+};\n+\n+Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n+  var parser = new this(options, input, pos);\n+  parser.nextToken();\n+  return parser.parseExpression()\n };\n \n+Parser.tokenizer = function tokenizer (input, options) {\n+  return new this(options, input)\n+};\n+\n+Object.defineProperties( Parser.prototype, prototypeAccessors );\n+\n var pp = Parser.prototype;\n \n // ## Parser utilities\n@@ -703,7 +729,7 @@ pp$1.parseTopLevel = function(node) {\n   var exports = {};\n   if (!node.body) { node.body = []; }\n   while (this.type !== types.eof) {\n-    var stmt = this$1.parseStatement(true, true, exports);\n+    var stmt = this$1.parseStatement(null, true, exports);\n     node.body.push(stmt);\n   }\n   this.adaptDirectivePrologue(node.body);\n@@ -754,7 +780,7 @@ pp$1.isAsyncFunction = function() {\n // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n // does not help.\n \n-pp$1.parseStatement = function(declaration, topLevel, exports) {\n+pp$1.parseStatement = function(context, topLevel, exports) {\n   var starttype = this.type, node = this.startNode(), kind;\n \n   if (this.isLet()) {\n@@ -772,10 +798,10 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n   case types._do: return this.parseDoStatement(node)\n   case types._for: return this.parseForStatement(node)\n   case types._function:\n-    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n-    return this.parseFunctionStatement(node, false)\n+    if ((context && (this.strict || context !== \"if\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n+    return this.parseFunctionStatement(node, false, !context)\n   case types._class:\n-    if (!declaration) { this.unexpected(); }\n+    if (context) { this.unexpected(); }\n     return this.parseClass(node, true)\n   case types._if: return this.parseIfStatement(node)\n   case types._return: return this.parseReturnStatement(node)\n@@ -784,11 +810,11 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n   case types._try: return this.parseTryStatement(node)\n   case types._const: case types._var:\n     kind = kind || this.value;\n-    if (!declaration && kind !== \"var\") { this.unexpected(); }\n+    if (context && kind !== \"var\") { this.unexpected(); }\n     return this.parseVarStatement(node, kind)\n   case types._while: return this.parseWhileStatement(node)\n   case types._with: return this.parseWithStatement(node)\n-  case types.braceL: return this.parseBlock()\n+  case types.braceL: return this.parseBlock(true, node)\n   case types.semi: return this.parseEmptyStatement(node)\n   case types._export:\n   case types._import:\n@@ -807,14 +833,14 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n     // Identifier node, we switch to interpreting it as a label.\n   default:\n     if (this.isAsyncFunction()) {\n-      if (!declaration) { this.unexpected(); }\n+      if (context) { this.unexpected(); }\n       this.next();\n-      return this.parseFunctionStatement(node, true)\n+      return this.parseFunctionStatement(node, true, !context)\n     }\n \n     var maybeName = this.value, expr = this.parseExpression();\n     if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n-      { return this.parseLabeledStatement(node, maybeName, expr) }\n+      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n     else { return this.parseExpressionStatement(node, expr) }\n   }\n };\n@@ -854,7 +880,7 @@ pp$1.parseDebuggerStatement = function(node) {\n pp$1.parseDoStatement = function(node) {\n   this.next();\n   this.labels.push(loopLabel);\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"do\");\n   this.labels.pop();\n   this.expect(types._while);\n   node.test = this.parseParenExpression();\n@@ -877,7 +903,7 @@ pp$1.parseForStatement = function(node) {\n   this.next();\n   var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n   this.labels.push(loopLabel);\n-  this.enterLexicalScope();\n+  this.enterScope(0);\n   this.expect(types.parenL);\n   if (this.type === types.semi) {\n     if (awaitAt > -1) { this.unexpected(awaitAt); }\n@@ -919,17 +945,17 @@ pp$1.parseForStatement = function(node) {\n   return this.parseFor(node, init)\n };\n \n-pp$1.parseFunctionStatement = function(node, isAsync) {\n+pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n   this.next();\n-  return this.parseFunction(node, true, false, isAsync)\n+  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n };\n \n pp$1.parseIfStatement = function(node) {\n   this.next();\n   node.test = this.parseParenExpression();\n   // allow function declarations in branches, but only in non-strict mode\n-  node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n-  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n+  node.consequent = this.parseStatement(\"if\");\n+  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n   return this.finishNode(node, \"IfStatement\")\n };\n \n@@ -955,7 +981,7 @@ pp$1.parseSwitchStatement = function(node) {\n   node.cases = [];\n   this.expect(types.braceL);\n   this.labels.push(switchLabel);\n-  this.enterLexicalScope();\n+  this.enterScope(0);\n \n   // Statements under must be grouped (by label) in SwitchCase\n   // nodes. `cur` is used to keep the node that we are currently\n@@ -979,10 +1005,10 @@ pp$1.parseSwitchStatement = function(node) {\n       this$1.expect(types.colon);\n     } else {\n       if (!cur) { this$1.unexpected(); }\n-      cur.consequent.push(this$1.parseStatement(true));\n+      cur.consequent.push(this$1.parseStatement(null));\n     }\n   }\n-  this.exitLexicalScope();\n+  this.exitScope();\n   if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n   this.next(); // Closing brace\n   this.labels.pop();\n@@ -1011,16 +1037,17 @@ pp$1.parseTryStatement = function(node) {\n     this.next();\n     if (this.eat(types.parenL)) {\n       clause.param = this.parseBindingAtom();\n-      this.enterLexicalScope();\n-      this.checkLVal(clause.param, \"let\");\n+      var simple = clause.param.type === \"Identifier\";\n+      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n+      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n       this.expect(types.parenR);\n     } else {\n       if (this.options.ecmaVersion < 10) { this.unexpected(); }\n       clause.param = null;\n-      this.enterLexicalScope();\n+      this.enterScope(0);\n     }\n     clause.body = this.parseBlock(false);\n-    this.exitLexicalScope();\n+    this.exitScope();\n     node.handler = this.finishNode(clause, \"CatchClause\");\n   }\n   node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n@@ -1040,7 +1067,7 @@ pp$1.parseWhileStatement = function(node) {\n   this.next();\n   node.test = this.parseParenExpression();\n   this.labels.push(loopLabel);\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"while\");\n   this.labels.pop();\n   return this.finishNode(node, \"WhileStatement\")\n };\n@@ -1049,7 +1076,7 @@ pp$1.parseWithStatement = function(node) {\n   if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n   this.next();\n   node.object = this.parseParenExpression();\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"with\");\n   return this.finishNode(node, \"WithStatement\")\n };\n \n@@ -1058,7 +1085,7 @@ pp$1.parseEmptyStatement = function(node) {\n   return this.finishNode(node, \"EmptyStatement\")\n };\n \n-pp$1.parseLabeledStatement = function(node, maybeName, expr) {\n+pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n   var this$1 = this;\n \n   for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n@@ -1078,7 +1105,7 @@ pp$1.parseLabeledStatement = function(node, maybeName, expr) {\n     } else { break }\n   }\n   this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n-  node.body = this.parseStatement(true);\n+  node.body = this.parseStatement(context);\n   if (node.body.type === \"ClassDeclaration\" ||\n       node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" ||\n       node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async))\n@@ -1098,23 +1125,19 @@ pp$1.parseExpressionStatement = function(node, expr) {\n // strict\"` declarations when `allowStrict` is true (used for\n // function bodies).\n \n-pp$1.parseBlock = function(createNewLexicalScope) {\n+pp$1.parseBlock = function(createNewLexicalScope, node) {\n   var this$1 = this;\n   if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n+  if ( node === void 0 ) node = this.startNode();\n \n-  var node = this.startNode();\n   node.body = [];\n   this.expect(types.braceL);\n-  if (createNewLexicalScope) {\n-    this.enterLexicalScope();\n-  }\n+  if (createNewLexicalScope) { this.enterScope(0); }\n   while (!this.eat(types.braceR)) {\n-    var stmt = this$1.parseStatement(true);\n+    var stmt = this$1.parseStatement(null);\n     node.body.push(stmt);\n   }\n-  if (createNewLexicalScope) {\n-    this.exitLexicalScope();\n-  }\n+  if (createNewLexicalScope) { this.exitScope(); }\n   return this.finishNode(node, \"BlockStatement\")\n };\n \n@@ -1129,8 +1152,8 @@ pp$1.parseFor = function(node, init) {\n   this.expect(types.semi);\n   node.update = this.type === types.parenR ? null : this.parseExpression();\n   this.expect(types.parenR);\n-  this.exitLexicalScope();\n-  node.body = this.parseStatement(false);\n+  this.exitScope();\n+  node.body = this.parseStatement(\"for\");\n   this.labels.pop();\n   return this.finishNode(node, \"ForStatement\")\n };\n@@ -1150,8 +1173,8 @@ pp$1.parseForIn = function(node, init) {\n   node.left = init;\n   node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n   this.expect(types.parenR);\n-  this.exitLexicalScope();\n-  node.body = this.parseStatement(false);\n+  this.exitScope();\n+  node.body = this.parseStatement(\"for\");\n   this.labels.pop();\n   return this.finishNode(node, type)\n };\n@@ -1183,47 +1206,43 @@ pp$1.parseVar = function(node, isFor, kind) {\n \n pp$1.parseVarId = function(decl, kind) {\n   decl.id = this.parseBindingAtom(kind);\n-  this.checkLVal(decl.id, kind, false);\n+  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n };\n \n+var FUNC_STATEMENT = 1;\n+var FUNC_HANGING_STATEMENT = 2;\n+var FUNC_NULLABLE_ID = 4;\n+\n // Parse a function declaration or literal (depending on the\n // `isStatement` parameter).\n \n-pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n+pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n   this.initFunction(node);\n   if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\n     { node.generator = this.eat(types.star); }\n   if (this.options.ecmaVersion >= 8)\n     { node.async = !!isAsync; }\n \n-  if (isStatement) {\n-    node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n-    if (node.id) {\n-      this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n-    }\n+  if (statement & FUNC_STATEMENT) {\n+    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n+    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n+      { this.checkLVal(node.id, this.inModule && !this.inFunction ? BIND_LEXICAL : BIND_FUNCTION); }\n   }\n \n-  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n-  this.inGenerator = node.generator;\n-  this.inAsync = node.async;\n+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n-  this.enterFunctionScope();\n+  this.enterScope(functionFlags(node.async, node.generator));\n \n-  if (!isStatement)\n+  if (!(statement & FUNC_STATEMENT))\n     { node.id = this.type === types.name ? this.parseIdent() : null; }\n \n   this.parseFunctionParams(node);\n   this.parseFunctionBody(node, allowExpressionBody);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n-  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n+  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n };\n \n pp$1.parseFunctionParams = function(node) {\n@@ -1247,17 +1266,20 @@ pp$1.parseClass = function(node, isStatement) {\n   classBody.body = [];\n   this.expect(types.braceL);\n   while (!this.eat(types.braceR)) {\n-    var member = this$1.parseClassMember(classBody);\n-    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n-      if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\n-      hadConstructor = true;\n+    var element = this$1.parseClassElement();\n+    if (element) {\n+      classBody.body.push(element);\n+      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n+        if (hadConstructor) { this$1.raise(element.start, \"Duplicate constructor in the same class\"); }\n+        hadConstructor = true;\n+      }\n     }\n   }\n   node.body = this.finishNode(classBody, \"ClassBody\");\n   return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n };\n \n-pp$1.parseClassMember = function(classBody) {\n+pp$1.parseClassElement = function() {\n   var this$1 = this;\n \n   if (this.eat(types.semi)) { return null }\n@@ -1302,7 +1324,7 @@ pp$1.parseClassMember = function(classBody) {\n   } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n     this.raise(key.start, \"Classes may not have a static property named prototype\");\n   }\n-  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n+  this.parseClassMethod(method, isGenerator, isAsync);\n   if (method.kind === \"get\" && method.value.params.length !== 0)\n     { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n   if (method.kind === \"set\" && method.value.params.length !== 1)\n@@ -1312,9 +1334,9 @@ pp$1.parseClassMember = function(classBody) {\n   return method\n };\n \n-pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n+pp$1.parseClassMethod = function(method, isGenerator, isAsync) {\n   method.value = this.parseMethod(isGenerator, isAsync);\n-  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n+  return this.finishNode(method, \"MethodDefinition\")\n };\n \n pp$1.parseClassId = function(node, isStatement) {\n@@ -1346,7 +1368,7 @@ pp$1.parseExport = function(node, exports) {\n       var fNode = this.startNode();\n       this.next();\n       if (isAsync) { this.next(); }\n-      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n+      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync, true);\n     } else if (this.type === types._class) {\n       var cNode = this.startNode();\n       node.declaration = this.parseClass(cNode, \"nullableID\");\n@@ -1358,7 +1380,7 @@ pp$1.parseExport = function(node, exports) {\n   }\n   // export var|const|let|function|class ...\n   if (this.shouldParseExportStatement()) {\n-    node.declaration = this.parseStatement(true);\n+    node.declaration = this.parseStatement(null);\n     if (node.declaration.type === \"VariableDeclaration\")\n       { this.checkVariableExport(exports, node.declaration.declarations); }\n     else\n@@ -1493,7 +1515,7 @@ pp$1.parseImportSpecifiers = function() {\n     // import defaultObj, { x, y as z } from '...'\n     var node = this.startNode();\n     node.local = this.parseIdent();\n-    this.checkLVal(node.local, \"let\");\n+    this.checkLVal(node.local, BIND_LEXICAL);\n     nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n     if (!this.eat(types.comma)) { return nodes }\n   }\n@@ -1502,7 +1524,7 @@ pp$1.parseImportSpecifiers = function() {\n     this.next();\n     this.expectContextual(\"as\");\n     node$1.local = this.parseIdent();\n-    this.checkLVal(node$1.local, \"let\");\n+    this.checkLVal(node$1.local, BIND_LEXICAL);\n     nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n     return nodes\n   }\n@@ -1521,7 +1543,7 @@ pp$1.parseImportSpecifiers = function() {\n       this$1.checkUnreserved(node$2.imported);\n       node$2.local = node$2.imported;\n     }\n-    this$1.checkLVal(node$2.local, \"let\");\n+    this$1.checkLVal(node$2.local, BIND_LEXICAL);\n     nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n   }\n   return nodes\n@@ -1736,6 +1758,7 @@ pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n \n pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n   var this$1 = this;\n+  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n \n   switch (expr.type) {\n   case \"Identifier\":\n@@ -1746,19 +1769,7 @@ pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n         { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n       checkClashes[expr.name] = true;\n     }\n-    if (bindingType && bindingType !== \"none\") {\n-      if (\n-        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n-        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n-      ) {\n-        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n-      }\n-      if (bindingType === \"var\") {\n-        this.declareVarName(expr.name);\n-      } else {\n-        this.declareLexicalName(expr.name);\n-      }\n-    }\n+    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n     break\n \n   case \"MemberExpression\":\n@@ -1907,13 +1918,19 @@ pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n // operators like `+=`.\n \n pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n-  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n+  if (this.isContextual(\"yield\")) {\n+    if (this.inGenerator) { return this.parseYield() }\n+    // The tokenizer will assume an expression is allowed after\n+    // `yield`, but this isn't that kind of yield\n+    else { this.exprAllowed = false; }\n+  }\n \n-  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n+  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n   if (refDestructuringErrors) {\n     oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n     oldTrailingComma = refDestructuringErrors.trailingComma;\n-    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n+    oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n+    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n   } else {\n     refDestructuringErrors = new DestructuringErrors;\n     ownDestructuringErrors = true;\n@@ -1939,6 +1956,7 @@ pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n   }\n   if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n   if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n+  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n   return left\n };\n \n@@ -2130,7 +2148,7 @@ pp$3.parseExprAtom = function(refDestructuringErrors) {\n     var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n     var id = this.parseIdent(this.type !== types.name);\n     if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n-      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n+      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n     if (canBeArrow && !this.canInsertSemicolon()) {\n       if (this.eat(types.arrow))\n         { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n@@ -2181,7 +2199,7 @@ pp$3.parseExprAtom = function(refDestructuringErrors) {\n   case types._function:\n     node = this.startNode();\n     this.next();\n-    return this.parseFunction(node, false)\n+    return this.parseFunction(node, 0)\n \n   case types._class:\n     return this.parseClass(this.startNode(), false)\n@@ -2300,7 +2318,7 @@ pp$3.parseNew = function() {\n     node.property = this.parseIdent(true);\n     if (node.property.name !== \"target\" || containsEsc)\n       { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n-    if (!this.inFunction)\n+    if (!this.inNonArrowFunction())\n       { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n     return this.finishNode(node, \"MetaProperty\")\n   }\n@@ -2500,71 +2518,52 @@ pp$3.parsePropertyName = function(prop) {\n \n pp$3.initFunction = function(node) {\n   node.id = null;\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = false;\n-    node.expression = false;\n-  }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = false; }\n+  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n+  if (this.options.ecmaVersion >= 8) { node.async = false; }\n };\n \n // Parse object or class method.\n \n pp$3.parseMethod = function(isGenerator, isAsync) {\n-  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n+  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;\n \n   this.initFunction(node);\n   if (this.options.ecmaVersion >= 6)\n     { node.generator = isGenerator; }\n   if (this.options.ecmaVersion >= 8)\n     { node.async = !!isAsync; }\n \n-  this.inGenerator = node.generator;\n-  this.inAsync = node.async;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n-  this.enterFunctionScope();\n+  this.enterScope(functionFlags(isAsync, node.generator));\n \n   this.expect(types.parenL);\n   node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n   this.checkYieldAwaitInDefaultParams();\n   this.parseFunctionBody(node, false);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n   return this.finishNode(node, \"FunctionExpression\")\n };\n \n // Parse arrow function expression with given parameters.\n \n pp$3.parseArrowExpression = function(node, params, isAsync) {\n-  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;\n \n-  this.enterFunctionScope();\n+  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n   this.initFunction(node);\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n+  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n \n-  this.inGenerator = false;\n-  this.inAsync = node.async;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n \n   node.params = this.toAssignableList(params, true);\n   this.parseFunctionBody(node, true);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n   return this.finishNode(node, \"ArrowFunctionExpression\")\n };\n \n@@ -2602,12 +2601,10 @@ pp$3.parseFunctionBody = function(node, isArrowFunction) {\n     this.adaptDirectivePrologue(node.body.body);\n     this.labels = oldLabels;\n   }\n-  this.exitFunctionScope();\n+  this.exitScope();\n \n-  if (this.strict && node.id) {\n-    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n-    this.checkLVal(node.id, \"none\");\n-  }\n+  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n+  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n   this.strict = oldStrict;\n };\n \n@@ -2632,7 +2629,7 @@ pp$3.checkParams = function(node, allowDuplicates) {\n     {\n     var param = list[i];\n \n-    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n+    this$1.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n   }\n };\n \n@@ -2676,7 +2673,7 @@ pp$3.checkUnreserved = function(ref) {\n     { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n   if (this.inAsync && name === \"await\")\n     { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n-  if (this.isKeyword(name))\n+  if (this.keywords.test(name))\n     { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n   if (this.options.ecmaVersion < 6 &&\n     this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n@@ -2769,79 +2766,69 @@ pp$4.curPosition = function() {\n \n var pp$5 = Parser.prototype;\n \n-// Object.assign polyfill\n-var assign = Object.assign || function(target) {\n-  var sources = [], len = arguments.length - 1;\n-  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n-\n-  for (var i = 0, list = sources; i < list.length; i += 1) {\n-    var source = list[i];\n-\n-    for (var key in source) {\n-      if (has(source, key)) {\n-        target[key] = source[key];\n-      }\n-    }\n-  }\n-  return target\n+var Scope = function Scope(flags) {\n+  this.flags = flags;\n+  // A list of var-declared names in the current lexical scope\n+  this.var = [];\n+  // A list of lexically-declared names in the current lexical scope\n+  this.lexical = [];\n };\n \n // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n \n-pp$5.enterFunctionScope = function() {\n-  // var: a hash of var-declared names in the current lexical scope\n-  // lexical: a hash of lexically-declared names in the current lexical scope\n-  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n-  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n-  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n+pp$5.enterScope = function(flags) {\n+  this.scopeStack.push(new Scope(flags));\n };\n \n-pp$5.exitFunctionScope = function() {\n+pp$5.exitScope = function() {\n   this.scopeStack.pop();\n };\n \n-pp$5.enterLexicalScope = function() {\n-  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n-  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n-\n-  this.scopeStack.push(childScope);\n-  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n-};\n-\n-pp$5.exitLexicalScope = function() {\n-  var childScope = this.scopeStack.pop();\n-  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.declareName = function(name, bindingType, pos) {\n+  var this$1 = this;\n \n-  assign(parentScope.childVar, childScope.var, childScope.childVar);\n+  var redeclared = false;\n+  if (bindingType === BIND_LEXICAL) {\n+    var scope = this.currentScope();\n+    redeclared = scope.lexical.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n+    scope.lexical.push(name);\n+  } else if (bindingType === BIND_SIMPLE_CATCH) {\n+    var scope$1 = this.currentScope();\n+    scope$1.lexical.push(name);\n+  } else if (bindingType === BIND_FUNCTION) {\n+    var scope$2 = this.currentScope();\n+    redeclared = scope$2.lexical.indexOf(name) > -1;\n+    scope$2.var.push(name);\n+  } else {\n+    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n+      var scope$3 = this$1.scopeStack[i];\n+      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) { redeclared = true; }\n+      scope$3.var.push(name);\n+      if (scope$3.flags & SCOPE_VAR) { break }\n+    }\n+  }\n+  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n };\n \n-/**\n- * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n- * in the current lexical scope or any of the parent lexical scopes in this function.\n- */\n-pp$5.canDeclareVarName = function(name) {\n-  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n-\n-  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n+pp$5.currentScope = function() {\n+  return this.scopeStack[this.scopeStack.length - 1]\n };\n \n-/**\n- * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n- * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n- * any child lexical scopes in this function.\n- */\n-pp$5.canDeclareLexicalName = function(name) {\n-  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.currentVarScope = function() {\n+  var this$1 = this;\n \n-  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n+  for (var i = this.scopeStack.length - 1;; i--) {\n+    var scope = this$1.scopeStack[i];\n+    if (scope.flags & SCOPE_VAR) { return scope }\n+  }\n };\n \n-pp$5.declareVarName = function(name) {\n-  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n-};\n+pp$5.inNonArrowFunction = function() {\n+  var this$1 = this;\n \n-pp$5.declareLexicalName = function(name) {\n-  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n+  for (var i = this.scopeStack.length - 1; i >= 0; i--)\n+    { if (this$1.scopeStack[i].flags & SCOPE_FUNCTION && !(this$1.scopeStack[i].flags & SCOPE_ARROW)) { return true } }\n+  return false\n };\n \n var Node = function Node(parser, pos, loc) {\n@@ -5268,14 +5255,9 @@ pp$8.readWord = function() {\n //\n // [ghbt]: https://github.com/acornjs/acorn/issues\n //\n-// This file defines the main parser interface. The library also comes\n-// with a [error-tolerant parser][dammit] and an\n-// [abstract syntax tree walker][walk], defined in other files.\n-//\n-// [dammit]: acorn_loose.js\n // [walk]: util/walk.js\n \n-var version = \"5.7.3\";\n+var version = \"6.0.2\";\n \n // The main exported interface (under `self.acorn` when in the\n // browser) is a `parse` function that takes a code string and\n@@ -5285,43 +5267,29 @@ var version = \"5.7.3\";\n // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n \n function parse(input, options) {\n-  return new Parser(options, input).parse()\n+  return Parser.parse(input, options)\n }\n \n // This function tries to parse a single expression at a given\n // offset in a string. Useful for parsing mixed-language formats\n // that embed JavaScript expressions.\n \n function parseExpressionAt(input, pos, options) {\n-  var p = new Parser(options, input, pos);\n-  p.nextToken();\n-  return p.parseExpression()\n+  return Parser.parseExpressionAt(input, pos, options)\n }\n \n // Acorn is organized as a tokenizer and a recursive-descent parser.\n // The `tokenizer` export provides an interface to the tokenizer.\n \n function tokenizer(input, options) {\n-  return new Parser(options, input)\n-}\n-\n-// This is a terrible kludge to support the existing, pre-ES6\n-// interface where the loose parser module retroactively adds exports\n-// to this module.\n- // eslint-disable-line camelcase\n-function addLooseExports(parse, Parser$$1, plugins$$1) {\n-  exports.parse_dammit = parse; // eslint-disable-line camelcase\n-  exports.LooseParser = Parser$$1;\n-  exports.pluginsLoose = plugins$$1;\n+  return Parser.tokenizer(input, options)\n }\n \n exports.version = version;\n exports.parse = parse;\n exports.parseExpressionAt = parseExpressionAt;\n exports.tokenizer = tokenizer;\n-exports.addLooseExports = addLooseExports;\n exports.Parser = Parser;\n-exports.plugins = plugins;\n exports.defaultOptions = defaultOptions;\n exports.Position = Position;\n exports.SourceLocation = SourceLocation;\n@@ -5343,3 +5311,4 @@ exports.nonASCIIwhitespace = nonASCIIwhitespace;\n Object.defineProperty(exports, '__esModule', { value: true });\n \n })));\n+//# sourceMappingURL=acorn.js.map"
        },
        {
            "sha": "57c8681c2eac8ea0ce29af9d571c7c4f20eeaca2",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/acorn.js.map",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.js.map",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.js.map",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.js.map?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1"
        },
        {
            "sha": "c23a7a2eddae81a4f160308d708b5b2c1a75a660",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/acorn.mjs",
            "status": "renamed",
            "additions": 202,
            "deletions": 233,
            "changes": 435,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.mjs",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.mjs",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.mjs?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -307,11 +307,12 @@ function getLineInfo(input, offset) {\n // the parser process. These options are recognized:\n \n var defaultOptions = {\n-  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n-  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n-  // for strict mode, the set of reserved words, and support for\n-  // new syntax features. The default is 7.\n-  ecmaVersion: 7,\n+  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n+  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n+  // (2019). This influences support for strict mode, the set of\n+  // reserved words, and support for new syntax features. The default\n+  // is 9.\n+  ecmaVersion: 9,\n   // `sourceType` indicates the mode the code should be parsed in.\n   // Can be either `\"script\"` or `\"module\"`. This influences global\n   // strict mode and parsing of `import` and `export` declarations.\n@@ -387,8 +388,7 @@ var defaultOptions = {\n   directSourceFile: null,\n   // When enabled, parenthesized expressions are represented by\n   // (non-standard) ParenthesizedExpression nodes\n-  preserveParens: false,\n-  plugins: {}\n+  preserveParens: false\n };\n \n // Interpret and default an options object\n@@ -431,8 +431,26 @@ function pushComment(options, array) {\n   }\n }\n \n-// Registered plugins\n-var plugins = {};\n+// Each scope gets a bitset that may contain these flags\n+var SCOPE_TOP = 1;\n+var SCOPE_FUNCTION = 2;\n+var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION;\n+var SCOPE_ASYNC = 4;\n+var SCOPE_GENERATOR = 8;\n+var SCOPE_ARROW = 16;\n+var SCOPE_SIMPLE_CATCH = 32;\n+\n+function functionFlags(async, generator) {\n+  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n+}\n+\n+// Used in checkLVal and declareName to determine the type of a binding\n+var BIND_NONE = 0;\n+var BIND_VAR = 1;\n+var BIND_LEXICAL = 2;\n+var BIND_FUNCTION = 3;\n+var BIND_SIMPLE_CATCH = 4;\n+var BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n \n function keywordRegexp(words) {\n   return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n@@ -459,9 +477,6 @@ var Parser = function Parser(options, input, startPos) {\n   // escape sequences must not be interpreted as keywords.\n   this.containsEsc = false;\n \n-  // Load plugins\n-  this.loadPlugins(options.plugins);\n-\n   // Set up token state\n \n   // The current position of the tokenizer in the input.\n@@ -502,8 +517,6 @@ var Parser = function Parser(options, input, startPos) {\n   // Used to signify the start of a potential arrow function\n   this.potentialArrowAt = -1;\n \n-  // Flags to track whether we are in a function, a generator, an async function.\n-  this.inFunction = this.inGenerator = this.inAsync = false;\n   // Positions to delayed-check that yield/await does not exist in default parameters.\n   this.yieldPos = this.awaitPos = 0;\n   // Labels in scope.\n@@ -515,36 +528,49 @@ var Parser = function Parser(options, input, startPos) {\n \n   // Scope tracking for duplicate variable names (see scope.js)\n   this.scopeStack = [];\n-  this.enterFunctionScope();\n+  this.enterScope(SCOPE_TOP);\n \n   // For RegExp validation\n   this.regexpState = null;\n };\n \n-// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n-Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\n-Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n+var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true } };\n \n-Parser.prototype.extend = function extend (name, f) {\n-  this[name] = f(this[name]);\n+Parser.prototype.parse = function parse () {\n+  var node = this.options.program || this.startNode();\n+  this.nextToken();\n+  return this.parseTopLevel(node)\n };\n \n-Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n-    var this$1 = this;\n+prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n+prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n+prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n \n-  for (var name in pluginConfigs) {\n-    var plugin = plugins[name];\n-    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n-    plugin(this$1, pluginConfigs[name]);\n-  }\n+Parser.extend = function extend () {\n+    var plugins = [], len = arguments.length;\n+    while ( len-- ) plugins[ len ] = arguments[ len ];\n+\n+  var cls = this;\n+  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n+  return cls\n };\n \n-Parser.prototype.parse = function parse () {\n-  var node = this.options.program || this.startNode();\n-  this.nextToken();\n-  return this.parseTopLevel(node)\n+Parser.parse = function parse (input, options) {\n+  return new this(options, input).parse()\n+};\n+\n+Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n+  var parser = new this(options, input, pos);\n+  parser.nextToken();\n+  return parser.parseExpression()\n };\n \n+Parser.tokenizer = function tokenizer (input, options) {\n+  return new this(options, input)\n+};\n+\n+Object.defineProperties( Parser.prototype, prototypeAccessors );\n+\n var pp = Parser.prototype;\n \n // ## Parser utilities\n@@ -697,7 +723,7 @@ pp$1.parseTopLevel = function(node) {\n   var exports = {};\n   if (!node.body) { node.body = []; }\n   while (this.type !== types.eof) {\n-    var stmt = this$1.parseStatement(true, true, exports);\n+    var stmt = this$1.parseStatement(null, true, exports);\n     node.body.push(stmt);\n   }\n   this.adaptDirectivePrologue(node.body);\n@@ -748,7 +774,7 @@ pp$1.isAsyncFunction = function() {\n // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n // does not help.\n \n-pp$1.parseStatement = function(declaration, topLevel, exports) {\n+pp$1.parseStatement = function(context, topLevel, exports) {\n   var starttype = this.type, node = this.startNode(), kind;\n \n   if (this.isLet()) {\n@@ -766,10 +792,10 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n   case types._do: return this.parseDoStatement(node)\n   case types._for: return this.parseForStatement(node)\n   case types._function:\n-    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n-    return this.parseFunctionStatement(node, false)\n+    if ((context && (this.strict || context !== \"if\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n+    return this.parseFunctionStatement(node, false, !context)\n   case types._class:\n-    if (!declaration) { this.unexpected(); }\n+    if (context) { this.unexpected(); }\n     return this.parseClass(node, true)\n   case types._if: return this.parseIfStatement(node)\n   case types._return: return this.parseReturnStatement(node)\n@@ -778,11 +804,11 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n   case types._try: return this.parseTryStatement(node)\n   case types._const: case types._var:\n     kind = kind || this.value;\n-    if (!declaration && kind !== \"var\") { this.unexpected(); }\n+    if (context && kind !== \"var\") { this.unexpected(); }\n     return this.parseVarStatement(node, kind)\n   case types._while: return this.parseWhileStatement(node)\n   case types._with: return this.parseWithStatement(node)\n-  case types.braceL: return this.parseBlock()\n+  case types.braceL: return this.parseBlock(true, node)\n   case types.semi: return this.parseEmptyStatement(node)\n   case types._export:\n   case types._import:\n@@ -801,14 +827,14 @@ pp$1.parseStatement = function(declaration, topLevel, exports) {\n     // Identifier node, we switch to interpreting it as a label.\n   default:\n     if (this.isAsyncFunction()) {\n-      if (!declaration) { this.unexpected(); }\n+      if (context) { this.unexpected(); }\n       this.next();\n-      return this.parseFunctionStatement(node, true)\n+      return this.parseFunctionStatement(node, true, !context)\n     }\n \n     var maybeName = this.value, expr = this.parseExpression();\n     if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n-      { return this.parseLabeledStatement(node, maybeName, expr) }\n+      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n     else { return this.parseExpressionStatement(node, expr) }\n   }\n };\n@@ -848,7 +874,7 @@ pp$1.parseDebuggerStatement = function(node) {\n pp$1.parseDoStatement = function(node) {\n   this.next();\n   this.labels.push(loopLabel);\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"do\");\n   this.labels.pop();\n   this.expect(types._while);\n   node.test = this.parseParenExpression();\n@@ -871,7 +897,7 @@ pp$1.parseForStatement = function(node) {\n   this.next();\n   var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n   this.labels.push(loopLabel);\n-  this.enterLexicalScope();\n+  this.enterScope(0);\n   this.expect(types.parenL);\n   if (this.type === types.semi) {\n     if (awaitAt > -1) { this.unexpected(awaitAt); }\n@@ -913,17 +939,17 @@ pp$1.parseForStatement = function(node) {\n   return this.parseFor(node, init)\n };\n \n-pp$1.parseFunctionStatement = function(node, isAsync) {\n+pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n   this.next();\n-  return this.parseFunction(node, true, false, isAsync)\n+  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n };\n \n pp$1.parseIfStatement = function(node) {\n   this.next();\n   node.test = this.parseParenExpression();\n   // allow function declarations in branches, but only in non-strict mode\n-  node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n-  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n+  node.consequent = this.parseStatement(\"if\");\n+  node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n   return this.finishNode(node, \"IfStatement\")\n };\n \n@@ -949,7 +975,7 @@ pp$1.parseSwitchStatement = function(node) {\n   node.cases = [];\n   this.expect(types.braceL);\n   this.labels.push(switchLabel);\n-  this.enterLexicalScope();\n+  this.enterScope(0);\n \n   // Statements under must be grouped (by label) in SwitchCase\n   // nodes. `cur` is used to keep the node that we are currently\n@@ -973,10 +999,10 @@ pp$1.parseSwitchStatement = function(node) {\n       this$1.expect(types.colon);\n     } else {\n       if (!cur) { this$1.unexpected(); }\n-      cur.consequent.push(this$1.parseStatement(true));\n+      cur.consequent.push(this$1.parseStatement(null));\n     }\n   }\n-  this.exitLexicalScope();\n+  this.exitScope();\n   if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n   this.next(); // Closing brace\n   this.labels.pop();\n@@ -1005,16 +1031,17 @@ pp$1.parseTryStatement = function(node) {\n     this.next();\n     if (this.eat(types.parenL)) {\n       clause.param = this.parseBindingAtom();\n-      this.enterLexicalScope();\n-      this.checkLVal(clause.param, \"let\");\n+      var simple = clause.param.type === \"Identifier\";\n+      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n+      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n       this.expect(types.parenR);\n     } else {\n       if (this.options.ecmaVersion < 10) { this.unexpected(); }\n       clause.param = null;\n-      this.enterLexicalScope();\n+      this.enterScope(0);\n     }\n     clause.body = this.parseBlock(false);\n-    this.exitLexicalScope();\n+    this.exitScope();\n     node.handler = this.finishNode(clause, \"CatchClause\");\n   }\n   node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n@@ -1034,7 +1061,7 @@ pp$1.parseWhileStatement = function(node) {\n   this.next();\n   node.test = this.parseParenExpression();\n   this.labels.push(loopLabel);\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"while\");\n   this.labels.pop();\n   return this.finishNode(node, \"WhileStatement\")\n };\n@@ -1043,7 +1070,7 @@ pp$1.parseWithStatement = function(node) {\n   if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n   this.next();\n   node.object = this.parseParenExpression();\n-  node.body = this.parseStatement(false);\n+  node.body = this.parseStatement(\"with\");\n   return this.finishNode(node, \"WithStatement\")\n };\n \n@@ -1052,7 +1079,7 @@ pp$1.parseEmptyStatement = function(node) {\n   return this.finishNode(node, \"EmptyStatement\")\n };\n \n-pp$1.parseLabeledStatement = function(node, maybeName, expr) {\n+pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n   var this$1 = this;\n \n   for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n@@ -1072,7 +1099,7 @@ pp$1.parseLabeledStatement = function(node, maybeName, expr) {\n     } else { break }\n   }\n   this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n-  node.body = this.parseStatement(true);\n+  node.body = this.parseStatement(context);\n   if (node.body.type === \"ClassDeclaration\" ||\n       node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" ||\n       node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async))\n@@ -1092,23 +1119,19 @@ pp$1.parseExpressionStatement = function(node, expr) {\n // strict\"` declarations when `allowStrict` is true (used for\n // function bodies).\n \n-pp$1.parseBlock = function(createNewLexicalScope) {\n+pp$1.parseBlock = function(createNewLexicalScope, node) {\n   var this$1 = this;\n   if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n+  if ( node === void 0 ) node = this.startNode();\n \n-  var node = this.startNode();\n   node.body = [];\n   this.expect(types.braceL);\n-  if (createNewLexicalScope) {\n-    this.enterLexicalScope();\n-  }\n+  if (createNewLexicalScope) { this.enterScope(0); }\n   while (!this.eat(types.braceR)) {\n-    var stmt = this$1.parseStatement(true);\n+    var stmt = this$1.parseStatement(null);\n     node.body.push(stmt);\n   }\n-  if (createNewLexicalScope) {\n-    this.exitLexicalScope();\n-  }\n+  if (createNewLexicalScope) { this.exitScope(); }\n   return this.finishNode(node, \"BlockStatement\")\n };\n \n@@ -1123,8 +1146,8 @@ pp$1.parseFor = function(node, init) {\n   this.expect(types.semi);\n   node.update = this.type === types.parenR ? null : this.parseExpression();\n   this.expect(types.parenR);\n-  this.exitLexicalScope();\n-  node.body = this.parseStatement(false);\n+  this.exitScope();\n+  node.body = this.parseStatement(\"for\");\n   this.labels.pop();\n   return this.finishNode(node, \"ForStatement\")\n };\n@@ -1144,8 +1167,8 @@ pp$1.parseForIn = function(node, init) {\n   node.left = init;\n   node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n   this.expect(types.parenR);\n-  this.exitLexicalScope();\n-  node.body = this.parseStatement(false);\n+  this.exitScope();\n+  node.body = this.parseStatement(\"for\");\n   this.labels.pop();\n   return this.finishNode(node, type)\n };\n@@ -1177,47 +1200,43 @@ pp$1.parseVar = function(node, isFor, kind) {\n \n pp$1.parseVarId = function(decl, kind) {\n   decl.id = this.parseBindingAtom(kind);\n-  this.checkLVal(decl.id, kind, false);\n+  this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n };\n \n+var FUNC_STATEMENT = 1;\n+var FUNC_HANGING_STATEMENT = 2;\n+var FUNC_NULLABLE_ID = 4;\n+\n // Parse a function declaration or literal (depending on the\n // `isStatement` parameter).\n \n-pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n+pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n   this.initFunction(node);\n   if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\n     { node.generator = this.eat(types.star); }\n   if (this.options.ecmaVersion >= 8)\n     { node.async = !!isAsync; }\n \n-  if (isStatement) {\n-    node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n-    if (node.id) {\n-      this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n-    }\n+  if (statement & FUNC_STATEMENT) {\n+    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n+    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n+      { this.checkLVal(node.id, this.inModule && !this.inFunction ? BIND_LEXICAL : BIND_FUNCTION); }\n   }\n \n-  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n-  this.inGenerator = node.generator;\n-  this.inAsync = node.async;\n+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n-  this.enterFunctionScope();\n+  this.enterScope(functionFlags(node.async, node.generator));\n \n-  if (!isStatement)\n+  if (!(statement & FUNC_STATEMENT))\n     { node.id = this.type === types.name ? this.parseIdent() : null; }\n \n   this.parseFunctionParams(node);\n   this.parseFunctionBody(node, allowExpressionBody);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n-  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n+  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n };\n \n pp$1.parseFunctionParams = function(node) {\n@@ -1241,17 +1260,20 @@ pp$1.parseClass = function(node, isStatement) {\n   classBody.body = [];\n   this.expect(types.braceL);\n   while (!this.eat(types.braceR)) {\n-    var member = this$1.parseClassMember(classBody);\n-    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n-      if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\n-      hadConstructor = true;\n+    var element = this$1.parseClassElement();\n+    if (element) {\n+      classBody.body.push(element);\n+      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n+        if (hadConstructor) { this$1.raise(element.start, \"Duplicate constructor in the same class\"); }\n+        hadConstructor = true;\n+      }\n     }\n   }\n   node.body = this.finishNode(classBody, \"ClassBody\");\n   return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n };\n \n-pp$1.parseClassMember = function(classBody) {\n+pp$1.parseClassElement = function() {\n   var this$1 = this;\n \n   if (this.eat(types.semi)) { return null }\n@@ -1296,7 +1318,7 @@ pp$1.parseClassMember = function(classBody) {\n   } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n     this.raise(key.start, \"Classes may not have a static property named prototype\");\n   }\n-  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n+  this.parseClassMethod(method, isGenerator, isAsync);\n   if (method.kind === \"get\" && method.value.params.length !== 0)\n     { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n   if (method.kind === \"set\" && method.value.params.length !== 1)\n@@ -1306,9 +1328,9 @@ pp$1.parseClassMember = function(classBody) {\n   return method\n };\n \n-pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n+pp$1.parseClassMethod = function(method, isGenerator, isAsync) {\n   method.value = this.parseMethod(isGenerator, isAsync);\n-  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n+  return this.finishNode(method, \"MethodDefinition\")\n };\n \n pp$1.parseClassId = function(node, isStatement) {\n@@ -1340,7 +1362,7 @@ pp$1.parseExport = function(node, exports) {\n       var fNode = this.startNode();\n       this.next();\n       if (isAsync) { this.next(); }\n-      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n+      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync, true);\n     } else if (this.type === types._class) {\n       var cNode = this.startNode();\n       node.declaration = this.parseClass(cNode, \"nullableID\");\n@@ -1352,7 +1374,7 @@ pp$1.parseExport = function(node, exports) {\n   }\n   // export var|const|let|function|class ...\n   if (this.shouldParseExportStatement()) {\n-    node.declaration = this.parseStatement(true);\n+    node.declaration = this.parseStatement(null);\n     if (node.declaration.type === \"VariableDeclaration\")\n       { this.checkVariableExport(exports, node.declaration.declarations); }\n     else\n@@ -1487,7 +1509,7 @@ pp$1.parseImportSpecifiers = function() {\n     // import defaultObj, { x, y as z } from '...'\n     var node = this.startNode();\n     node.local = this.parseIdent();\n-    this.checkLVal(node.local, \"let\");\n+    this.checkLVal(node.local, BIND_LEXICAL);\n     nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n     if (!this.eat(types.comma)) { return nodes }\n   }\n@@ -1496,7 +1518,7 @@ pp$1.parseImportSpecifiers = function() {\n     this.next();\n     this.expectContextual(\"as\");\n     node$1.local = this.parseIdent();\n-    this.checkLVal(node$1.local, \"let\");\n+    this.checkLVal(node$1.local, BIND_LEXICAL);\n     nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n     return nodes\n   }\n@@ -1515,7 +1537,7 @@ pp$1.parseImportSpecifiers = function() {\n       this$1.checkUnreserved(node$2.imported);\n       node$2.local = node$2.imported;\n     }\n-    this$1.checkLVal(node$2.local, \"let\");\n+    this$1.checkLVal(node$2.local, BIND_LEXICAL);\n     nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n   }\n   return nodes\n@@ -1730,6 +1752,7 @@ pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n \n pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n   var this$1 = this;\n+  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n \n   switch (expr.type) {\n   case \"Identifier\":\n@@ -1740,19 +1763,7 @@ pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n         { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n       checkClashes[expr.name] = true;\n     }\n-    if (bindingType && bindingType !== \"none\") {\n-      if (\n-        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n-        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n-      ) {\n-        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n-      }\n-      if (bindingType === \"var\") {\n-        this.declareVarName(expr.name);\n-      } else {\n-        this.declareLexicalName(expr.name);\n-      }\n-    }\n+    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n     break\n \n   case \"MemberExpression\":\n@@ -1901,13 +1912,19 @@ pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n // operators like `+=`.\n \n pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n-  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n+  if (this.isContextual(\"yield\")) {\n+    if (this.inGenerator) { return this.parseYield() }\n+    // The tokenizer will assume an expression is allowed after\n+    // `yield`, but this isn't that kind of yield\n+    else { this.exprAllowed = false; }\n+  }\n \n-  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n+  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n   if (refDestructuringErrors) {\n     oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n     oldTrailingComma = refDestructuringErrors.trailingComma;\n-    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n+    oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n+    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n   } else {\n     refDestructuringErrors = new DestructuringErrors;\n     ownDestructuringErrors = true;\n@@ -1933,6 +1950,7 @@ pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n   }\n   if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n   if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n+  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n   return left\n };\n \n@@ -2124,7 +2142,7 @@ pp$3.parseExprAtom = function(refDestructuringErrors) {\n     var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n     var id = this.parseIdent(this.type !== types.name);\n     if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n-      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n+      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n     if (canBeArrow && !this.canInsertSemicolon()) {\n       if (this.eat(types.arrow))\n         { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n@@ -2175,7 +2193,7 @@ pp$3.parseExprAtom = function(refDestructuringErrors) {\n   case types._function:\n     node = this.startNode();\n     this.next();\n-    return this.parseFunction(node, false)\n+    return this.parseFunction(node, 0)\n \n   case types._class:\n     return this.parseClass(this.startNode(), false)\n@@ -2294,7 +2312,7 @@ pp$3.parseNew = function() {\n     node.property = this.parseIdent(true);\n     if (node.property.name !== \"target\" || containsEsc)\n       { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n-    if (!this.inFunction)\n+    if (!this.inNonArrowFunction())\n       { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n     return this.finishNode(node, \"MetaProperty\")\n   }\n@@ -2494,71 +2512,52 @@ pp$3.parsePropertyName = function(prop) {\n \n pp$3.initFunction = function(node) {\n   node.id = null;\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = false;\n-    node.expression = false;\n-  }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = false; }\n+  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n+  if (this.options.ecmaVersion >= 8) { node.async = false; }\n };\n \n // Parse object or class method.\n \n pp$3.parseMethod = function(isGenerator, isAsync) {\n-  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n+  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;\n \n   this.initFunction(node);\n   if (this.options.ecmaVersion >= 6)\n     { node.generator = isGenerator; }\n   if (this.options.ecmaVersion >= 8)\n     { node.async = !!isAsync; }\n \n-  this.inGenerator = node.generator;\n-  this.inAsync = node.async;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n-  this.enterFunctionScope();\n+  this.enterScope(functionFlags(isAsync, node.generator));\n \n   this.expect(types.parenL);\n   node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n   this.checkYieldAwaitInDefaultParams();\n   this.parseFunctionBody(node, false);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n   return this.finishNode(node, \"FunctionExpression\")\n };\n \n // Parse arrow function expression with given parameters.\n \n pp$3.parseArrowExpression = function(node, params, isAsync) {\n-  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n-      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n+  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;\n \n-  this.enterFunctionScope();\n+  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n   this.initFunction(node);\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n+  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n \n-  this.inGenerator = false;\n-  this.inAsync = node.async;\n   this.yieldPos = 0;\n   this.awaitPos = 0;\n-  this.inFunction = true;\n \n   node.params = this.toAssignableList(params, true);\n   this.parseFunctionBody(node, true);\n \n-  this.inGenerator = oldInGen;\n-  this.inAsync = oldInAsync;\n   this.yieldPos = oldYieldPos;\n   this.awaitPos = oldAwaitPos;\n-  this.inFunction = oldInFunc;\n   return this.finishNode(node, \"ArrowFunctionExpression\")\n };\n \n@@ -2596,12 +2595,10 @@ pp$3.parseFunctionBody = function(node, isArrowFunction) {\n     this.adaptDirectivePrologue(node.body.body);\n     this.labels = oldLabels;\n   }\n-  this.exitFunctionScope();\n+  this.exitScope();\n \n-  if (this.strict && node.id) {\n-    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n-    this.checkLVal(node.id, \"none\");\n-  }\n+  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n+  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n   this.strict = oldStrict;\n };\n \n@@ -2626,7 +2623,7 @@ pp$3.checkParams = function(node, allowDuplicates) {\n     {\n     var param = list[i];\n \n-    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n+    this$1.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n   }\n };\n \n@@ -2670,7 +2667,7 @@ pp$3.checkUnreserved = function(ref) {\n     { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n   if (this.inAsync && name === \"await\")\n     { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n-  if (this.isKeyword(name))\n+  if (this.keywords.test(name))\n     { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n   if (this.options.ecmaVersion < 6 &&\n     this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n@@ -2763,79 +2760,69 @@ pp$4.curPosition = function() {\n \n var pp$5 = Parser.prototype;\n \n-// Object.assign polyfill\n-var assign = Object.assign || function(target) {\n-  var sources = [], len = arguments.length - 1;\n-  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n-\n-  for (var i = 0, list = sources; i < list.length; i += 1) {\n-    var source = list[i];\n-\n-    for (var key in source) {\n-      if (has(source, key)) {\n-        target[key] = source[key];\n-      }\n-    }\n-  }\n-  return target\n+var Scope = function Scope(flags) {\n+  this.flags = flags;\n+  // A list of var-declared names in the current lexical scope\n+  this.var = [];\n+  // A list of lexically-declared names in the current lexical scope\n+  this.lexical = [];\n };\n \n // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n \n-pp$5.enterFunctionScope = function() {\n-  // var: a hash of var-declared names in the current lexical scope\n-  // lexical: a hash of lexically-declared names in the current lexical scope\n-  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n-  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n-  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n+pp$5.enterScope = function(flags) {\n+  this.scopeStack.push(new Scope(flags));\n };\n \n-pp$5.exitFunctionScope = function() {\n+pp$5.exitScope = function() {\n   this.scopeStack.pop();\n };\n \n-pp$5.enterLexicalScope = function() {\n-  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n-  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n-\n-  this.scopeStack.push(childScope);\n-  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n-};\n-\n-pp$5.exitLexicalScope = function() {\n-  var childScope = this.scopeStack.pop();\n-  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.declareName = function(name, bindingType, pos) {\n+  var this$1 = this;\n \n-  assign(parentScope.childVar, childScope.var, childScope.childVar);\n+  var redeclared = false;\n+  if (bindingType === BIND_LEXICAL) {\n+    var scope = this.currentScope();\n+    redeclared = scope.lexical.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n+    scope.lexical.push(name);\n+  } else if (bindingType === BIND_SIMPLE_CATCH) {\n+    var scope$1 = this.currentScope();\n+    scope$1.lexical.push(name);\n+  } else if (bindingType === BIND_FUNCTION) {\n+    var scope$2 = this.currentScope();\n+    redeclared = scope$2.lexical.indexOf(name) > -1;\n+    scope$2.var.push(name);\n+  } else {\n+    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n+      var scope$3 = this$1.scopeStack[i];\n+      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) { redeclared = true; }\n+      scope$3.var.push(name);\n+      if (scope$3.flags & SCOPE_VAR) { break }\n+    }\n+  }\n+  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n };\n \n-/**\n- * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n- * in the current lexical scope or any of the parent lexical scopes in this function.\n- */\n-pp$5.canDeclareVarName = function(name) {\n-  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n-\n-  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n+pp$5.currentScope = function() {\n+  return this.scopeStack[this.scopeStack.length - 1]\n };\n \n-/**\n- * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n- * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n- * any child lexical scopes in this function.\n- */\n-pp$5.canDeclareLexicalName = function(name) {\n-  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n+pp$5.currentVarScope = function() {\n+  var this$1 = this;\n \n-  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n+  for (var i = this.scopeStack.length - 1;; i--) {\n+    var scope = this$1.scopeStack[i];\n+    if (scope.flags & SCOPE_VAR) { return scope }\n+  }\n };\n \n-pp$5.declareVarName = function(name) {\n-  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n-};\n+pp$5.inNonArrowFunction = function() {\n+  var this$1 = this;\n \n-pp$5.declareLexicalName = function(name) {\n-  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n+  for (var i = this.scopeStack.length - 1; i >= 0; i--)\n+    { if (this$1.scopeStack[i].flags & SCOPE_FUNCTION && !(this$1.scopeStack[i].flags & SCOPE_ARROW)) { return true } }\n+  return false\n };\n \n var Node = function Node(parser, pos, loc) {\n@@ -5262,14 +5249,9 @@ pp$8.readWord = function() {\n //\n // [ghbt]: https://github.com/acornjs/acorn/issues\n //\n-// This file defines the main parser interface. The library also comes\n-// with a [error-tolerant parser][dammit] and an\n-// [abstract syntax tree walker][walk], defined in other files.\n-//\n-// [dammit]: acorn_loose.js\n // [walk]: util/walk.js\n \n-var version = \"5.7.3\";\n+var version = \"6.0.2\";\n \n // The main exported interface (under `self.acorn` when in the\n // browser) is a `parse` function that takes a code string and\n@@ -5279,36 +5261,23 @@ var version = \"5.7.3\";\n // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n \n function parse(input, options) {\n-  return new Parser(options, input).parse()\n+  return Parser.parse(input, options)\n }\n \n // This function tries to parse a single expression at a given\n // offset in a string. Useful for parsing mixed-language formats\n // that embed JavaScript expressions.\n \n function parseExpressionAt(input, pos, options) {\n-  var p = new Parser(options, input, pos);\n-  p.nextToken();\n-  return p.parseExpression()\n+  return Parser.parseExpressionAt(input, pos, options)\n }\n \n // Acorn is organized as a tokenizer and a recursive-descent parser.\n // The `tokenizer` export provides an interface to the tokenizer.\n \n function tokenizer(input, options) {\n-  return new Parser(options, input)\n-}\n-\n-// This is a terrible kludge to support the existing, pre-ES6\n-// interface where the loose parser module retroactively adds exports\n-// to this module.\n-var parse_dammit;\n-var LooseParser;\n-var pluginsLoose; // eslint-disable-line camelcase\n-function addLooseExports(parse, Parser$$1, plugins$$1) {\n-  parse_dammit = parse; // eslint-disable-line camelcase\n-  LooseParser = Parser$$1;\n-  pluginsLoose = plugins$$1;\n+  return Parser.tokenizer(input, options)\n }\n \n-export { version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };\n+export { version, parse, parseExpressionAt, tokenizer, Parser, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };\n+//# sourceMappingURL=acorn.mjs.map",
            "previous_filename": "tools/node_modules/eslint/node_modules/acorn/dist/acorn.es.js"
        },
        {
            "sha": "c4b45787be194d81c6aeab00253499f21de18a60",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/acorn.mjs.map",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.mjs.map",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.mjs.map",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn.mjs.map?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1"
        },
        {
            "sha": "89d38a1c29d581bde4e21364bfdd0f05f672aec8",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/acorn_loose.es.js",
            "status": "removed",
            "additions": 0,
            "deletions": 1424,
            "changes": 1424,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn_loose.es.js",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn_loose.es.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn_loose.es.js?ref=9697c0820f015ccf898a3662305a0caa3cd9c208",
            "patch": "@@ -1,1424 +0,0 @@\n-import { Node, SourceLocation, Token, addLooseExports, defaultOptions, getLineInfo, isNewLine, lineBreak, lineBreakG, tokTypes, tokenizer } from './acorn.es';\n-\n-function noop() {}\n-\n-// Registered plugins\n-var pluginsLoose = {};\n-\n-var LooseParser = function LooseParser(input, options) {\n-  if ( options === void 0 ) options = {};\n-\n-  this.toks = tokenizer(input, options);\n-  this.options = this.toks.options;\n-  this.input = this.toks.input;\n-  this.tok = this.last = {type: tokTypes.eof, start: 0, end: 0};\n-  this.tok.validateRegExpFlags = noop;\n-  this.tok.validateRegExpPattern = noop;\n-  if (this.options.locations) {\n-    var here = this.toks.curPosition();\n-    this.tok.loc = new SourceLocation(this.toks, here, here);\n-  }\n-  this.ahead = []; // Tokens ahead\n-  this.context = []; // Indentation contexted\n-  this.curIndent = 0;\n-  this.curLineStart = 0;\n-  this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n-  this.inAsync = false;\n-  this.inFunction = false;\n-  // Load plugins\n-  this.options.pluginsLoose = options.pluginsLoose || {};\n-  this.loadPlugins(this.options.pluginsLoose);\n-};\n-\n-LooseParser.prototype.startNode = function startNode () {\n-  return new Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n-};\n-\n-LooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n-  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n-};\n-\n-LooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n-  if (this.options.locations) {\n-    return new Node(this.toks, pos[0], pos[1])\n-  } else {\n-    return new Node(this.toks, pos)\n-  }\n-};\n-\n-LooseParser.prototype.finishNode = function finishNode (node, type) {\n-  node.type = type;\n-  node.end = this.last.end;\n-  if (this.options.locations)\n-    { node.loc.end = this.last.loc.end; }\n-  if (this.options.ranges)\n-    { node.range[1] = this.last.end; }\n-  return node\n-};\n-\n-LooseParser.prototype.dummyNode = function dummyNode (type) {\n-  var dummy = this.startNode();\n-  dummy.type = type;\n-  dummy.end = dummy.start;\n-  if (this.options.locations)\n-    { dummy.loc.end = dummy.loc.start; }\n-  if (this.options.ranges)\n-    { dummy.range[1] = dummy.start; }\n-  this.last = {type: tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n-  return dummy\n-};\n-\n-LooseParser.prototype.dummyIdent = function dummyIdent () {\n-  var dummy = this.dummyNode(\"Identifier\");\n-  dummy.name = \"✖\";\n-  return dummy\n-};\n-\n-LooseParser.prototype.dummyString = function dummyString () {\n-  var dummy = this.dummyNode(\"Literal\");\n-  dummy.value = dummy.raw = \"✖\";\n-  return dummy\n-};\n-\n-LooseParser.prototype.eat = function eat (type) {\n-  if (this.tok.type === type) {\n-    this.next();\n-    return true\n-  } else {\n-    return false\n-  }\n-};\n-\n-LooseParser.prototype.isContextual = function isContextual (name) {\n-  return this.tok.type === tokTypes.name && this.tok.value === name\n-};\n-\n-LooseParser.prototype.eatContextual = function eatContextual (name) {\n-  return this.tok.value === name && this.eat(tokTypes.name)\n-};\n-\n-LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n-  return this.tok.type === tokTypes.eof || this.tok.type === tokTypes.braceR ||\n-    lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n-};\n-\n-LooseParser.prototype.semicolon = function semicolon () {\n-  return this.eat(tokTypes.semi)\n-};\n-\n-LooseParser.prototype.expect = function expect (type) {\n-    var this$1 = this;\n-\n-  if (this.eat(type)) { return true }\n-  for (var i = 1; i <= 2; i++) {\n-    if (this$1.lookAhead(i).type === type) {\n-      for (var j = 0; j < i; j++) { this$1.next(); }\n-      return true\n-    }\n-  }\n-};\n-\n-LooseParser.prototype.pushCx = function pushCx () {\n-  this.context.push(this.curIndent);\n-};\n-\n-LooseParser.prototype.popCx = function popCx () {\n-  this.curIndent = this.context.pop();\n-};\n-\n-LooseParser.prototype.lineEnd = function lineEnd (pos) {\n-  while (pos < this.input.length && !isNewLine(this.input.charCodeAt(pos))) { ++pos; }\n-  return pos\n-};\n-\n-LooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n-    var this$1 = this;\n-\n-  for (var count = 0;; ++pos) {\n-    var ch = this$1.input.charCodeAt(pos);\n-    if (ch === 32) { ++count; }\n-    else if (ch === 9) { count += this$1.options.tabSize; }\n-    else { return count }\n-  }\n-};\n-\n-LooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n-  if (this.tok.type === closeTok || this.tok.type === tokTypes.eof) { return true }\n-  return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n-    (!blockHeuristic || this.nextLineStart >= this.input.length ||\n-     this.indentationAfter(this.nextLineStart) < indent)\n-};\n-\n-LooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n-    var this$1 = this;\n-\n-  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n-    var ch = this$1.input.charCodeAt(p);\n-    if (ch !== 9 && ch !== 32) { return false }\n-  }\n-  return true\n-};\n-\n-LooseParser.prototype.extend = function extend (name, f) {\n-  this[name] = f(this[name]);\n-};\n-\n-LooseParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n-    var this$1 = this;\n-\n-  for (var name in pluginConfigs) {\n-    var plugin = pluginsLoose[name];\n-    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n-    plugin(this$1, pluginConfigs[name]);\n-  }\n-};\n-\n-LooseParser.prototype.parse = function parse () {\n-  this.next();\n-  return this.parseTopLevel()\n-};\n-\n-var lp = LooseParser.prototype;\n-\n-function isSpace(ch) {\n-  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || isNewLine(ch)\n-}\n-\n-lp.next = function() {\n-  var this$1 = this;\n-\n-  this.last = this.tok;\n-  if (this.ahead.length)\n-    { this.tok = this.ahead.shift(); }\n-  else\n-    { this.tok = this.readToken(); }\n-\n-  if (this.tok.start >= this.nextLineStart) {\n-    while (this.tok.start >= this.nextLineStart) {\n-      this$1.curLineStart = this$1.nextLineStart;\n-      this$1.nextLineStart = this$1.lineEnd(this$1.curLineStart) + 1;\n-    }\n-    this.curIndent = this.indentationAfter(this.curLineStart);\n-  }\n-};\n-\n-lp.readToken = function() {\n-  var this$1 = this;\n-\n-  for (;;) {\n-    try {\n-      this$1.toks.next();\n-      if (this$1.toks.type === tokTypes.dot &&\n-          this$1.input.substr(this$1.toks.end, 1) === \".\" &&\n-          this$1.options.ecmaVersion >= 6) {\n-        this$1.toks.end++;\n-        this$1.toks.type = tokTypes.ellipsis;\n-      }\n-      return new Token(this$1.toks)\n-    } catch (e) {\n-      if (!(e instanceof SyntaxError)) { throw e }\n-\n-      // Try to skip some text, based on the error message, and then continue\n-      var msg = e.message, pos = e.raisedAt, replace = true;\n-      if (/unterminated/i.test(msg)) {\n-        pos = this$1.lineEnd(e.pos + 1);\n-        if (/string/.test(msg)) {\n-          replace = {start: e.pos, end: pos, type: tokTypes.string, value: this$1.input.slice(e.pos + 1, pos)};\n-        } else if (/regular expr/i.test(msg)) {\n-          var re = this$1.input.slice(e.pos, pos);\n-          try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n-          replace = {start: e.pos, end: pos, type: tokTypes.regexp, value: re};\n-        } else if (/template/.test(msg)) {\n-          replace = {\n-            start: e.pos,\n-            end: pos,\n-            type: tokTypes.template,\n-            value: this$1.input.slice(e.pos, pos)\n-          };\n-        } else {\n-          replace = false;\n-        }\n-      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n-        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n-      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n-        while (pos < this.input.length) {\n-          var ch = this$1.input.charCodeAt(pos++);\n-          if (ch === 34 || ch === 39 || isNewLine(ch)) { break }\n-        }\n-      } else if (/unexpected character/i.test(msg)) {\n-        pos++;\n-        replace = false;\n-      } else if (/regular expression/i.test(msg)) {\n-        replace = true;\n-      } else {\n-        throw e\n-      }\n-      this$1.resetTo(pos);\n-      if (replace === true) { replace = {start: pos, end: pos, type: tokTypes.name, value: \"✖\"}; }\n-      if (replace) {\n-        if (this$1.options.locations)\n-          { replace.loc = new SourceLocation(\n-            this$1.toks,\n-            getLineInfo(this$1.input, replace.start),\n-            getLineInfo(this$1.input, replace.end)); }\n-        return replace\n-      }\n-    }\n-  }\n-};\n-\n-lp.resetTo = function(pos) {\n-  var this$1 = this;\n-\n-  this.toks.pos = pos;\n-  var ch = this.input.charAt(pos - 1);\n-  this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n-    /[enwfd]/.test(ch) &&\n-    /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n-\n-  if (this.options.locations) {\n-    this.toks.curLine = 1;\n-    this.toks.lineStart = lineBreakG.lastIndex = 0;\n-    var match;\n-    while ((match = lineBreakG.exec(this.input)) && match.index < pos) {\n-      ++this$1.toks.curLine;\n-      this$1.toks.lineStart = match.index + match[0].length;\n-    }\n-  }\n-};\n-\n-lp.lookAhead = function(n) {\n-  var this$1 = this;\n-\n-  while (n > this.ahead.length)\n-    { this$1.ahead.push(this$1.readToken()); }\n-  return this.ahead[n - 1]\n-};\n-\n-function isDummy(node) { return node.name === \"✖\" }\n-\n-var lp$1 = LooseParser.prototype;\n-\n-lp$1.parseTopLevel = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNodeAt(this.options.locations ? [0, getLineInfo(this.input, 0)] : 0);\n-  node.body = [];\n-  while (this.tok.type !== tokTypes.eof) { node.body.push(this$1.parseStatement()); }\n-  this.toks.adaptDirectivePrologue(node.body);\n-  this.last = this.tok;\n-  if (this.options.ecmaVersion >= 6) {\n-    node.sourceType = this.options.sourceType;\n-  }\n-  return this.finishNode(node, \"Program\")\n-};\n-\n-lp$1.parseStatement = function() {\n-  var this$1 = this;\n-\n-  var starttype = this.tok.type, node = this.startNode(), kind;\n-\n-  if (this.toks.isLet()) {\n-    starttype = tokTypes._var;\n-    kind = \"let\";\n-  }\n-\n-  switch (starttype) {\n-  case tokTypes._break: case tokTypes._continue:\n-    this.next();\n-    var isBreak = starttype === tokTypes._break;\n-    if (this.semicolon() || this.canInsertSemicolon()) {\n-      node.label = null;\n-    } else {\n-      node.label = this.tok.type === tokTypes.name ? this.parseIdent() : null;\n-      this.semicolon();\n-    }\n-    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n-\n-  case tokTypes._debugger:\n-    this.next();\n-    this.semicolon();\n-    return this.finishNode(node, \"DebuggerStatement\")\n-\n-  case tokTypes._do:\n-    this.next();\n-    node.body = this.parseStatement();\n-    node.test = this.eat(tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n-    this.semicolon();\n-    return this.finishNode(node, \"DoWhileStatement\")\n-\n-  case tokTypes._for:\n-    this.next(); // `for` keyword\n-    var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n-\n-    this.pushCx();\n-    this.expect(tokTypes.parenL);\n-    if (this.tok.type === tokTypes.semi) { return this.parseFor(node, null) }\n-    var isLet = this.toks.isLet();\n-    if (isLet || this.tok.type === tokTypes._var || this.tok.type === tokTypes._const) {\n-      var init$1 = this.parseVar(true, isLet ? \"let\" : this.tok.value);\n-      if (init$1.declarations.length === 1 && (this.tok.type === tokTypes._in || this.isContextual(\"of\"))) {\n-        if (this.options.ecmaVersion >= 9 && this.tok.type !== tokTypes._in) {\n-          node.await = isAwait;\n-        }\n-        return this.parseForIn(node, init$1)\n-      }\n-      return this.parseFor(node, init$1)\n-    }\n-    var init = this.parseExpression(true);\n-    if (this.tok.type === tokTypes._in || this.isContextual(\"of\")) {\n-      if (this.options.ecmaVersion >= 9 && this.tok.type !== tokTypes._in) {\n-        node.await = isAwait;\n-      }\n-      return this.parseForIn(node, this.toAssignable(init))\n-    }\n-    return this.parseFor(node, init)\n-\n-  case tokTypes._function:\n-    this.next();\n-    return this.parseFunction(node, true)\n-\n-  case tokTypes._if:\n-    this.next();\n-    node.test = this.parseParenExpression();\n-    node.consequent = this.parseStatement();\n-    node.alternate = this.eat(tokTypes._else) ? this.parseStatement() : null;\n-    return this.finishNode(node, \"IfStatement\")\n-\n-  case tokTypes._return:\n-    this.next();\n-    if (this.eat(tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n-    else { node.argument = this.parseExpression(); this.semicolon(); }\n-    return this.finishNode(node, \"ReturnStatement\")\n-\n-  case tokTypes._switch:\n-    var blockIndent = this.curIndent, line = this.curLineStart;\n-    this.next();\n-    node.discriminant = this.parseParenExpression();\n-    node.cases = [];\n-    this.pushCx();\n-    this.expect(tokTypes.braceL);\n-\n-    var cur;\n-    while (!this.closes(tokTypes.braceR, blockIndent, line, true)) {\n-      if (this$1.tok.type === tokTypes._case || this$1.tok.type === tokTypes._default) {\n-        var isCase = this$1.tok.type === tokTypes._case;\n-        if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n-        node.cases.push(cur = this$1.startNode());\n-        cur.consequent = [];\n-        this$1.next();\n-        if (isCase) { cur.test = this$1.parseExpression(); }\n-        else { cur.test = null; }\n-        this$1.expect(tokTypes.colon);\n-      } else {\n-        if (!cur) {\n-          node.cases.push(cur = this$1.startNode());\n-          cur.consequent = [];\n-          cur.test = null;\n-        }\n-        cur.consequent.push(this$1.parseStatement());\n-      }\n-    }\n-    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n-    this.popCx();\n-    this.eat(tokTypes.braceR);\n-    return this.finishNode(node, \"SwitchStatement\")\n-\n-  case tokTypes._throw:\n-    this.next();\n-    node.argument = this.parseExpression();\n-    this.semicolon();\n-    return this.finishNode(node, \"ThrowStatement\")\n-\n-  case tokTypes._try:\n-    this.next();\n-    node.block = this.parseBlock();\n-    node.handler = null;\n-    if (this.tok.type === tokTypes._catch) {\n-      var clause = this.startNode();\n-      this.next();\n-      if (this.eat(tokTypes.parenL)) {\n-        clause.param = this.toAssignable(this.parseExprAtom(), true);\n-        this.expect(tokTypes.parenR);\n-      } else {\n-        clause.param = null;\n-      }\n-      clause.body = this.parseBlock();\n-      node.handler = this.finishNode(clause, \"CatchClause\");\n-    }\n-    node.finalizer = this.eat(tokTypes._finally) ? this.parseBlock() : null;\n-    if (!node.handler && !node.finalizer) { return node.block }\n-    return this.finishNode(node, \"TryStatement\")\n-\n-  case tokTypes._var:\n-  case tokTypes._const:\n-    return this.parseVar(false, kind || this.tok.value)\n-\n-  case tokTypes._while:\n-    this.next();\n-    node.test = this.parseParenExpression();\n-    node.body = this.parseStatement();\n-    return this.finishNode(node, \"WhileStatement\")\n-\n-  case tokTypes._with:\n-    this.next();\n-    node.object = this.parseParenExpression();\n-    node.body = this.parseStatement();\n-    return this.finishNode(node, \"WithStatement\")\n-\n-  case tokTypes.braceL:\n-    return this.parseBlock()\n-\n-  case tokTypes.semi:\n-    this.next();\n-    return this.finishNode(node, \"EmptyStatement\")\n-\n-  case tokTypes._class:\n-    return this.parseClass(true)\n-\n-  case tokTypes._import:\n-    return this.parseImport()\n-\n-  case tokTypes._export:\n-    return this.parseExport()\n-\n-  default:\n-    if (this.toks.isAsyncFunction()) {\n-      this.next();\n-      this.next();\n-      return this.parseFunction(node, true, true)\n-    }\n-    var expr = this.parseExpression();\n-    if (isDummy(expr)) {\n-      this.next();\n-      if (this.tok.type === tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n-      return this.parseStatement()\n-    } else if (starttype === tokTypes.name && expr.type === \"Identifier\" && this.eat(tokTypes.colon)) {\n-      node.body = this.parseStatement();\n-      node.label = expr;\n-      return this.finishNode(node, \"LabeledStatement\")\n-    } else {\n-      node.expression = expr;\n-      this.semicolon();\n-      return this.finishNode(node, \"ExpressionStatement\")\n-    }\n-  }\n-};\n-\n-lp$1.parseBlock = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.pushCx();\n-  this.expect(tokTypes.braceL);\n-  var blockIndent = this.curIndent, line = this.curLineStart;\n-  node.body = [];\n-  while (!this.closes(tokTypes.braceR, blockIndent, line, true))\n-    { node.body.push(this$1.parseStatement()); }\n-  this.popCx();\n-  this.eat(tokTypes.braceR);\n-  return this.finishNode(node, \"BlockStatement\")\n-};\n-\n-lp$1.parseFor = function(node, init) {\n-  node.init = init;\n-  node.test = node.update = null;\n-  if (this.eat(tokTypes.semi) && this.tok.type !== tokTypes.semi) { node.test = this.parseExpression(); }\n-  if (this.eat(tokTypes.semi) && this.tok.type !== tokTypes.parenR) { node.update = this.parseExpression(); }\n-  this.popCx();\n-  this.expect(tokTypes.parenR);\n-  node.body = this.parseStatement();\n-  return this.finishNode(node, \"ForStatement\")\n-};\n-\n-lp$1.parseForIn = function(node, init) {\n-  var type = this.tok.type === tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n-  this.next();\n-  node.left = init;\n-  node.right = this.parseExpression();\n-  this.popCx();\n-  this.expect(tokTypes.parenR);\n-  node.body = this.parseStatement();\n-  return this.finishNode(node, type)\n-};\n-\n-lp$1.parseVar = function(noIn, kind) {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  node.kind = kind;\n-  this.next();\n-  node.declarations = [];\n-  do {\n-    var decl = this$1.startNode();\n-    decl.id = this$1.options.ecmaVersion >= 6 ? this$1.toAssignable(this$1.parseExprAtom(), true) : this$1.parseIdent();\n-    decl.init = this$1.eat(tokTypes.eq) ? this$1.parseMaybeAssign(noIn) : null;\n-    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n-  } while (this.eat(tokTypes.comma))\n-  if (!node.declarations.length) {\n-    var decl$1 = this.startNode();\n-    decl$1.id = this.dummyIdent();\n-    node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n-  }\n-  if (!noIn) { this.semicolon(); }\n-  return this.finishNode(node, \"VariableDeclaration\")\n-};\n-\n-lp$1.parseClass = function(isStatement) {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.next();\n-  if (this.tok.type === tokTypes.name) { node.id = this.parseIdent(); }\n-  else if (isStatement === true) { node.id = this.dummyIdent(); }\n-  else { node.id = null; }\n-  node.superClass = this.eat(tokTypes._extends) ? this.parseExpression() : null;\n-  node.body = this.startNode();\n-  node.body.body = [];\n-  this.pushCx();\n-  var indent = this.curIndent + 1, line = this.curLineStart;\n-  this.eat(tokTypes.braceL);\n-  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n-  while (!this.closes(tokTypes.braceR, indent, line)) {\n-    if (this$1.semicolon()) { continue }\n-    var method = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0);\n-    if (this$1.options.ecmaVersion >= 6) {\n-      method.static = false;\n-      isGenerator = this$1.eat(tokTypes.star);\n-    }\n-    this$1.parsePropertyName(method);\n-    if (isDummy(method.key)) { if (isDummy(this$1.parseMaybeAssign())) { this$1.next(); } this$1.eat(tokTypes.comma); continue }\n-    if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n-        (this$1.tok.type !== tokTypes.parenL && this$1.tok.type !== tokTypes.braceL)) {\n-      method.static = true;\n-      isGenerator = this$1.eat(tokTypes.star);\n-      this$1.parsePropertyName(method);\n-    } else {\n-      method.static = false;\n-    }\n-    if (!method.computed &&\n-        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.tok.type !== tokTypes.parenL &&\n-        !this$1.canInsertSemicolon()) {\n-      isAsync = true;\n-      isGenerator = this$1.options.ecmaVersion >= 9 && this$1.eat(tokTypes.star);\n-      this$1.parsePropertyName(method);\n-    } else {\n-      isAsync = false;\n-    }\n-    if (this$1.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n-        !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n-        this$1.tok.type !== tokTypes.parenL && this$1.tok.type !== tokTypes.braceL) {\n-      method.kind = method.key.name;\n-      this$1.parsePropertyName(method);\n-      method.value = this$1.parseMethod(false);\n-    } else {\n-      if (!method.computed && !method.static && !isGenerator && !isAsync && (\n-        method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n-          method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n-        method.kind = \"constructor\";\n-      } else {\n-        method.kind = \"method\";\n-      }\n-      method.value = this$1.parseMethod(isGenerator, isAsync);\n-    }\n-    node.body.body.push(this$1.finishNode(method, \"MethodDefinition\"));\n-  }\n-  this.popCx();\n-  if (!this.eat(tokTypes.braceR)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  this.semicolon();\n-  this.finishNode(node.body, \"ClassBody\");\n-  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n-};\n-\n-lp$1.parseFunction = function(node, isStatement, isAsync) {\n-  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = this.eat(tokTypes.star);\n-  }\n-  if (this.options.ecmaVersion >= 8) {\n-    node.async = !!isAsync;\n-  }\n-  if (this.tok.type === tokTypes.name) { node.id = this.parseIdent(); }\n-  else if (isStatement === true) { node.id = this.dummyIdent(); }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.parseFunctionParams();\n-  node.body = this.parseBlock();\n-  this.toks.adaptDirectivePrologue(node.body.body);\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n-};\n-\n-lp$1.parseExport = function() {\n-  var node = this.startNode();\n-  this.next();\n-  if (this.eat(tokTypes.star)) {\n-    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n-    return this.finishNode(node, \"ExportAllDeclaration\")\n-  }\n-  if (this.eat(tokTypes._default)) {\n-    // export default (function foo() {}) // This is FunctionExpression.\n-    var isAsync;\n-    if (this.tok.type === tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n-      var fNode = this.startNode();\n-      this.next();\n-      if (isAsync) { this.next(); }\n-      node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n-    } else if (this.tok.type === tokTypes._class) {\n-      node.declaration = this.parseClass(\"nullableID\");\n-    } else {\n-      node.declaration = this.parseMaybeAssign();\n-      this.semicolon();\n-    }\n-    return this.finishNode(node, \"ExportDefaultDeclaration\")\n-  }\n-  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n-    node.declaration = this.parseStatement();\n-    node.specifiers = [];\n-    node.source = null;\n-  } else {\n-    node.declaration = null;\n-    node.specifiers = this.parseExportSpecifierList();\n-    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n-    this.semicolon();\n-  }\n-  return this.finishNode(node, \"ExportNamedDeclaration\")\n-};\n-\n-lp$1.parseImport = function() {\n-  var node = this.startNode();\n-  this.next();\n-  if (this.tok.type === tokTypes.string) {\n-    node.specifiers = [];\n-    node.source = this.parseExprAtom();\n-  } else {\n-    var elt;\n-    if (this.tok.type === tokTypes.name && this.tok.value !== \"from\") {\n-      elt = this.startNode();\n-      elt.local = this.parseIdent();\n-      this.finishNode(elt, \"ImportDefaultSpecifier\");\n-      this.eat(tokTypes.comma);\n-    }\n-    node.specifiers = this.parseImportSpecifierList();\n-    node.source = this.eatContextual(\"from\") && this.tok.type === tokTypes.string ? this.parseExprAtom() : this.dummyString();\n-    if (elt) { node.specifiers.unshift(elt); }\n-  }\n-  this.semicolon();\n-  return this.finishNode(node, \"ImportDeclaration\")\n-};\n-\n-lp$1.parseImportSpecifierList = function() {\n-  var this$1 = this;\n-\n-  var elts = [];\n-  if (this.tok.type === tokTypes.star) {\n-    var elt = this.startNode();\n-    this.next();\n-    elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n-    elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n-  } else {\n-    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n-    this.pushCx();\n-    this.eat(tokTypes.braceL);\n-    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n-    while (!this.closes(tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n-      var elt$1 = this$1.startNode();\n-      if (this$1.eat(tokTypes.star)) {\n-        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : this$1.dummyIdent();\n-        this$1.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n-      } else {\n-        if (this$1.isContextual(\"from\")) { break }\n-        elt$1.imported = this$1.parseIdent();\n-        if (isDummy(elt$1.imported)) { break }\n-        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt$1.imported;\n-        this$1.finishNode(elt$1, \"ImportSpecifier\");\n-      }\n-      elts.push(elt$1);\n-      this$1.eat(tokTypes.comma);\n-    }\n-    this.eat(tokTypes.braceR);\n-    this.popCx();\n-  }\n-  return elts\n-};\n-\n-lp$1.parseExportSpecifierList = function() {\n-  var this$1 = this;\n-\n-  var elts = [];\n-  var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n-  this.pushCx();\n-  this.eat(tokTypes.braceL);\n-  if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n-  while (!this.closes(tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n-    if (this$1.isContextual(\"from\")) { break }\n-    var elt = this$1.startNode();\n-    elt.local = this$1.parseIdent();\n-    if (isDummy(elt.local)) { break }\n-    elt.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt.local;\n-    this$1.finishNode(elt, \"ExportSpecifier\");\n-    elts.push(elt);\n-    this$1.eat(tokTypes.comma);\n-  }\n-  this.eat(tokTypes.braceR);\n-  this.popCx();\n-  return elts\n-};\n-\n-var lp$2 = LooseParser.prototype;\n-\n-lp$2.checkLVal = function(expr) {\n-  if (!expr) { return expr }\n-  switch (expr.type) {\n-  case \"Identifier\":\n-  case \"MemberExpression\":\n-    return expr\n-\n-  case \"ParenthesizedExpression\":\n-    expr.expression = this.checkLVal(expr.expression);\n-    return expr\n-\n-  default:\n-    return this.dummyIdent()\n-  }\n-};\n-\n-lp$2.parseExpression = function(noIn) {\n-  var this$1 = this;\n-\n-  var start = this.storeCurrentPos();\n-  var expr = this.parseMaybeAssign(noIn);\n-  if (this.tok.type === tokTypes.comma) {\n-    var node = this.startNodeAt(start);\n-    node.expressions = [expr];\n-    while (this.eat(tokTypes.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn)); }\n-    return this.finishNode(node, \"SequenceExpression\")\n-  }\n-  return expr\n-};\n-\n-lp$2.parseParenExpression = function() {\n-  this.pushCx();\n-  this.expect(tokTypes.parenL);\n-  var val = this.parseExpression();\n-  this.popCx();\n-  this.expect(tokTypes.parenR);\n-  return val\n-};\n-\n-lp$2.parseMaybeAssign = function(noIn) {\n-  if (this.toks.isContextual(\"yield\")) {\n-    var node = this.startNode();\n-    this.next();\n-    if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== tokTypes.star && !this.tok.type.startsExpr)) {\n-      node.delegate = false;\n-      node.argument = null;\n-    } else {\n-      node.delegate = this.eat(tokTypes.star);\n-      node.argument = this.parseMaybeAssign();\n-    }\n-    return this.finishNode(node, \"YieldExpression\")\n-  }\n-\n-  var start = this.storeCurrentPos();\n-  var left = this.parseMaybeConditional(noIn);\n-  if (this.tok.type.isAssign) {\n-    var node$1 = this.startNodeAt(start);\n-    node$1.operator = this.tok.value;\n-    node$1.left = this.tok.type === tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n-    this.next();\n-    node$1.right = this.parseMaybeAssign(noIn);\n-    return this.finishNode(node$1, \"AssignmentExpression\")\n-  }\n-  return left\n-};\n-\n-lp$2.parseMaybeConditional = function(noIn) {\n-  var start = this.storeCurrentPos();\n-  var expr = this.parseExprOps(noIn);\n-  if (this.eat(tokTypes.question)) {\n-    var node = this.startNodeAt(start);\n-    node.test = expr;\n-    node.consequent = this.parseMaybeAssign();\n-    node.alternate = this.expect(tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n-    return this.finishNode(node, \"ConditionalExpression\")\n-  }\n-  return expr\n-};\n-\n-lp$2.parseExprOps = function(noIn) {\n-  var start = this.storeCurrentPos();\n-  var indent = this.curIndent, line = this.curLineStart;\n-  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n-};\n-\n-lp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n-  if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n-  var prec = this.tok.type.binop;\n-  if (prec != null && (!noIn || this.tok.type !== tokTypes._in)) {\n-    if (prec > minPrec) {\n-      var node = this.startNodeAt(start);\n-      node.left = left;\n-      node.operator = this.tok.value;\n-      this.next();\n-      if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n-        node.right = this.dummyIdent();\n-      } else {\n-        var rightStart = this.storeCurrentPos();\n-        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n-      }\n-      this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n-      return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n-    }\n-  }\n-  return left\n-};\n-\n-lp$2.parseMaybeUnary = function(sawUnary) {\n-  var this$1 = this;\n-\n-  var start = this.storeCurrentPos(), expr;\n-  if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n-    (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n-  ) {\n-    expr = this.parseAwait();\n-    sawUnary = true;\n-  } else if (this.tok.type.prefix) {\n-    var node = this.startNode(), update = this.tok.type === tokTypes.incDec;\n-    if (!update) { sawUnary = true; }\n-    node.operator = this.tok.value;\n-    node.prefix = true;\n-    this.next();\n-    node.argument = this.parseMaybeUnary(true);\n-    if (update) { node.argument = this.checkLVal(node.argument); }\n-    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n-  } else if (this.tok.type === tokTypes.ellipsis) {\n-    var node$1 = this.startNode();\n-    this.next();\n-    node$1.argument = this.parseMaybeUnary(sawUnary);\n-    expr = this.finishNode(node$1, \"SpreadElement\");\n-  } else {\n-    expr = this.parseExprSubscripts();\n-    while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n-      var node$2 = this$1.startNodeAt(start);\n-      node$2.operator = this$1.tok.value;\n-      node$2.prefix = false;\n-      node$2.argument = this$1.checkLVal(expr);\n-      this$1.next();\n-      expr = this$1.finishNode(node$2, \"UpdateExpression\");\n-    }\n-  }\n-\n-  if (!sawUnary && this.eat(tokTypes.starstar)) {\n-    var node$3 = this.startNodeAt(start);\n-    node$3.operator = \"**\";\n-    node$3.left = expr;\n-    node$3.right = this.parseMaybeUnary(false);\n-    return this.finishNode(node$3, \"BinaryExpression\")\n-  }\n-\n-  return expr\n-};\n-\n-lp$2.parseExprSubscripts = function() {\n-  var start = this.storeCurrentPos();\n-  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n-};\n-\n-lp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n-  var this$1 = this;\n-\n-  for (;;) {\n-    if (this$1.curLineStart !== line && this$1.curIndent <= startIndent && this$1.tokenStartsLine()) {\n-      if (this$1.tok.type === tokTypes.dot && this$1.curIndent === startIndent)\n-        { --startIndent; }\n-      else\n-        { return base }\n-    }\n-\n-    var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this$1.canInsertSemicolon();\n-\n-    if (this$1.eat(tokTypes.dot)) {\n-      var node = this$1.startNodeAt(start);\n-      node.object = base;\n-      if (this$1.curLineStart !== line && this$1.curIndent <= startIndent && this$1.tokenStartsLine())\n-        { node.property = this$1.dummyIdent(); }\n-      else\n-        { node.property = this$1.parsePropertyAccessor() || this$1.dummyIdent(); }\n-      node.computed = false;\n-      base = this$1.finishNode(node, \"MemberExpression\");\n-    } else if (this$1.tok.type === tokTypes.bracketL) {\n-      this$1.pushCx();\n-      this$1.next();\n-      var node$1 = this$1.startNodeAt(start);\n-      node$1.object = base;\n-      node$1.property = this$1.parseExpression();\n-      node$1.computed = true;\n-      this$1.popCx();\n-      this$1.expect(tokTypes.bracketR);\n-      base = this$1.finishNode(node$1, \"MemberExpression\");\n-    } else if (!noCalls && this$1.tok.type === tokTypes.parenL) {\n-      var exprList = this$1.parseExprList(tokTypes.parenR);\n-      if (maybeAsyncArrow && this$1.eat(tokTypes.arrow))\n-        { return this$1.parseArrowExpression(this$1.startNodeAt(start), exprList, true) }\n-      var node$2 = this$1.startNodeAt(start);\n-      node$2.callee = base;\n-      node$2.arguments = exprList;\n-      base = this$1.finishNode(node$2, \"CallExpression\");\n-    } else if (this$1.tok.type === tokTypes.backQuote) {\n-      var node$3 = this$1.startNodeAt(start);\n-      node$3.tag = base;\n-      node$3.quasi = this$1.parseTemplate();\n-      base = this$1.finishNode(node$3, \"TaggedTemplateExpression\");\n-    } else {\n-      return base\n-    }\n-  }\n-};\n-\n-lp$2.parseExprAtom = function() {\n-  var node;\n-  switch (this.tok.type) {\n-  case tokTypes._this:\n-  case tokTypes._super:\n-    var type = this.tok.type === tokTypes._this ? \"ThisExpression\" : \"Super\";\n-    node = this.startNode();\n-    this.next();\n-    return this.finishNode(node, type)\n-\n-  case tokTypes.name:\n-    var start = this.storeCurrentPos();\n-    var id = this.parseIdent();\n-    var isAsync = false;\n-    if (id.name === \"async\" && !this.canInsertSemicolon()) {\n-      if (this.eat(tokTypes._function))\n-        { return this.parseFunction(this.startNodeAt(start), false, true) }\n-      if (this.tok.type === tokTypes.name) {\n-        id = this.parseIdent();\n-        isAsync = true;\n-      }\n-    }\n-    return this.eat(tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n-\n-  case tokTypes.regexp:\n-    node = this.startNode();\n-    var val = this.tok.value;\n-    node.regex = {pattern: val.pattern, flags: val.flags};\n-    node.value = val.value;\n-    node.raw = this.input.slice(this.tok.start, this.tok.end);\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case tokTypes.num: case tokTypes.string:\n-    node = this.startNode();\n-    node.value = this.tok.value;\n-    node.raw = this.input.slice(this.tok.start, this.tok.end);\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case tokTypes._null: case tokTypes._true: case tokTypes._false:\n-    node = this.startNode();\n-    node.value = this.tok.type === tokTypes._null ? null : this.tok.type === tokTypes._true;\n-    node.raw = this.tok.type.keyword;\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case tokTypes.parenL:\n-    var parenStart = this.storeCurrentPos();\n-    this.next();\n-    var inner = this.parseExpression();\n-    this.expect(tokTypes.parenR);\n-    if (this.eat(tokTypes.arrow)) {\n-      // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n-      var params = inner.expressions || [inner];\n-      if (params.length && isDummy(params[params.length - 1]))\n-        { params.pop(); }\n-      return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n-    }\n-    if (this.options.preserveParens) {\n-      var par = this.startNodeAt(parenStart);\n-      par.expression = inner;\n-      inner = this.finishNode(par, \"ParenthesizedExpression\");\n-    }\n-    return inner\n-\n-  case tokTypes.bracketL:\n-    node = this.startNode();\n-    node.elements = this.parseExprList(tokTypes.bracketR, true);\n-    return this.finishNode(node, \"ArrayExpression\")\n-\n-  case tokTypes.braceL:\n-    return this.parseObj()\n-\n-  case tokTypes._class:\n-    return this.parseClass(false)\n-\n-  case tokTypes._function:\n-    node = this.startNode();\n-    this.next();\n-    return this.parseFunction(node, false)\n-\n-  case tokTypes._new:\n-    return this.parseNew()\n-\n-  case tokTypes.backQuote:\n-    return this.parseTemplate()\n-\n-  default:\n-    return this.dummyIdent()\n-  }\n-};\n-\n-lp$2.parseNew = function() {\n-  var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n-  var meta = this.parseIdent(true);\n-  if (this.options.ecmaVersion >= 6 && this.eat(tokTypes.dot)) {\n-    node.meta = meta;\n-    node.property = this.parseIdent(true);\n-    return this.finishNode(node, \"MetaProperty\")\n-  }\n-  var start = this.storeCurrentPos();\n-  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n-  if (this.tok.type === tokTypes.parenL) {\n-    node.arguments = this.parseExprList(tokTypes.parenR);\n-  } else {\n-    node.arguments = [];\n-  }\n-  return this.finishNode(node, \"NewExpression\")\n-};\n-\n-lp$2.parseTemplateElement = function() {\n-  var elem = this.startNode();\n-\n-  // The loose parser accepts invalid unicode escapes even in untagged templates.\n-  if (this.tok.type === tokTypes.invalidTemplate) {\n-    elem.value = {\n-      raw: this.tok.value,\n-      cooked: null\n-    };\n-  } else {\n-    elem.value = {\n-      raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n-      cooked: this.tok.value\n-    };\n-  }\n-  this.next();\n-  elem.tail = this.tok.type === tokTypes.backQuote;\n-  return this.finishNode(elem, \"TemplateElement\")\n-};\n-\n-lp$2.parseTemplate = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.next();\n-  node.expressions = [];\n-  var curElt = this.parseTemplateElement();\n-  node.quasis = [curElt];\n-  while (!curElt.tail) {\n-    this$1.next();\n-    node.expressions.push(this$1.parseExpression());\n-    if (this$1.expect(tokTypes.braceR)) {\n-      curElt = this$1.parseTemplateElement();\n-    } else {\n-      curElt = this$1.startNode();\n-      curElt.value = {cooked: \"\", raw: \"\"};\n-      curElt.tail = true;\n-      this$1.finishNode(curElt, \"TemplateElement\");\n-    }\n-    node.quasis.push(curElt);\n-  }\n-  this.expect(tokTypes.backQuote);\n-  return this.finishNode(node, \"TemplateLiteral\")\n-};\n-\n-lp$2.parseObj = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  node.properties = [];\n-  this.pushCx();\n-  var indent = this.curIndent + 1, line = this.curLineStart;\n-  this.eat(tokTypes.braceL);\n-  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n-  while (!this.closes(tokTypes.braceR, indent, line)) {\n-    var prop = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n-    if (this$1.options.ecmaVersion >= 9 && this$1.eat(tokTypes.ellipsis)) {\n-      prop.argument = this$1.parseMaybeAssign();\n-      node.properties.push(this$1.finishNode(prop, \"SpreadElement\"));\n-      this$1.eat(tokTypes.comma);\n-      continue\n-    }\n-    if (this$1.options.ecmaVersion >= 6) {\n-      start = this$1.storeCurrentPos();\n-      prop.method = false;\n-      prop.shorthand = false;\n-      isGenerator = this$1.eat(tokTypes.star);\n-    }\n-    this$1.parsePropertyName(prop);\n-    if (this$1.toks.isAsyncProp(prop)) {\n-      isAsync = true;\n-      isGenerator = this$1.options.ecmaVersion >= 9 && this$1.eat(tokTypes.star);\n-      this$1.parsePropertyName(prop);\n-    } else {\n-      isAsync = false;\n-    }\n-    if (isDummy(prop.key)) { if (isDummy(this$1.parseMaybeAssign())) { this$1.next(); } this$1.eat(tokTypes.comma); continue }\n-    if (this$1.eat(tokTypes.colon)) {\n-      prop.kind = \"init\";\n-      prop.value = this$1.parseMaybeAssign();\n-    } else if (this$1.options.ecmaVersion >= 6 && (this$1.tok.type === tokTypes.parenL || this$1.tok.type === tokTypes.braceL)) {\n-      prop.kind = \"init\";\n-      prop.method = true;\n-      prop.value = this$1.parseMethod(isGenerator, isAsync);\n-    } else if (this$1.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n-               !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n-               (this$1.tok.type !== tokTypes.comma && this$1.tok.type !== tokTypes.braceR && this$1.tok.type !== tokTypes.eq)) {\n-      prop.kind = prop.key.name;\n-      this$1.parsePropertyName(prop);\n-      prop.value = this$1.parseMethod(false);\n-    } else {\n-      prop.kind = \"init\";\n-      if (this$1.options.ecmaVersion >= 6) {\n-        if (this$1.eat(tokTypes.eq)) {\n-          var assign = this$1.startNodeAt(start);\n-          assign.operator = \"=\";\n-          assign.left = prop.key;\n-          assign.right = this$1.parseMaybeAssign();\n-          prop.value = this$1.finishNode(assign, \"AssignmentExpression\");\n-        } else {\n-          prop.value = prop.key;\n-        }\n-      } else {\n-        prop.value = this$1.dummyIdent();\n-      }\n-      prop.shorthand = true;\n-    }\n-    node.properties.push(this$1.finishNode(prop, \"Property\"));\n-    this$1.eat(tokTypes.comma);\n-  }\n-  this.popCx();\n-  if (!this.eat(tokTypes.braceR)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  return this.finishNode(node, \"ObjectExpression\")\n-};\n-\n-lp$2.parsePropertyName = function(prop) {\n-  if (this.options.ecmaVersion >= 6) {\n-    if (this.eat(tokTypes.bracketL)) {\n-      prop.computed = true;\n-      prop.key = this.parseExpression();\n-      this.expect(tokTypes.bracketR);\n-      return\n-    } else {\n-      prop.computed = false;\n-    }\n-  }\n-  var key = (this.tok.type === tokTypes.num || this.tok.type === tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n-  prop.key = key || this.dummyIdent();\n-};\n-\n-lp$2.parsePropertyAccessor = function() {\n-  if (this.tok.type === tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n-};\n-\n-lp$2.parseIdent = function() {\n-  var name = this.tok.type === tokTypes.name ? this.tok.value : this.tok.type.keyword;\n-  if (!name) { return this.dummyIdent() }\n-  var node = this.startNode();\n-  this.next();\n-  node.name = name;\n-  return this.finishNode(node, \"Identifier\")\n-};\n-\n-lp$2.initFunction = function(node) {\n-  node.id = null;\n-  node.params = [];\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = false;\n-    node.expression = false;\n-  }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = false; }\n-};\n-\n-// Convert existing expression atom to assignable pattern\n-// if possible.\n-\n-lp$2.toAssignable = function(node, binding) {\n-  var this$1 = this;\n-\n-  if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) {\n-    // Okay\n-  } else if (node.type === \"ParenthesizedExpression\") {\n-    this.toAssignable(node.expression, binding);\n-  } else if (this.options.ecmaVersion < 6) {\n-    return this.dummyIdent()\n-  } else if (node.type === \"ObjectExpression\") {\n-    node.type = \"ObjectPattern\";\n-    for (var i = 0, list = node.properties; i < list.length; i += 1)\n-      {\n-      var prop = list[i];\n-\n-      this$1.toAssignable(prop, binding);\n-    }\n-  } else if (node.type === \"ArrayExpression\") {\n-    node.type = \"ArrayPattern\";\n-    this.toAssignableList(node.elements, binding);\n-  } else if (node.type === \"Property\") {\n-    this.toAssignable(node.value, binding);\n-  } else if (node.type === \"SpreadElement\") {\n-    node.type = \"RestElement\";\n-    this.toAssignable(node.argument, binding);\n-  } else if (node.type === \"AssignmentExpression\") {\n-    node.type = \"AssignmentPattern\";\n-    delete node.operator;\n-  } else {\n-    return this.dummyIdent()\n-  }\n-  return node\n-};\n-\n-lp$2.toAssignableList = function(exprList, binding) {\n-  var this$1 = this;\n-\n-  for (var i = 0, list = exprList; i < list.length; i += 1)\n-    {\n-    var expr = list[i];\n-\n-    this$1.toAssignable(expr, binding);\n-  }\n-  return exprList\n-};\n-\n-lp$2.parseFunctionParams = function(params) {\n-  params = this.parseExprList(tokTypes.parenR);\n-  return this.toAssignableList(params, true)\n-};\n-\n-lp$2.parseMethod = function(isGenerator, isAsync) {\n-  var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 6)\n-    { node.generator = !!isGenerator; }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.parseFunctionParams();\n-  node.body = this.parseBlock();\n-  this.toks.adaptDirectivePrologue(node.body.body);\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, \"FunctionExpression\")\n-};\n-\n-lp$2.parseArrowExpression = function(node, params, isAsync) {\n-  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.toAssignableList(params, true);\n-  node.expression = this.tok.type !== tokTypes.braceL;\n-  if (node.expression) {\n-    node.body = this.parseMaybeAssign();\n-  } else {\n-    node.body = this.parseBlock();\n-    this.toks.adaptDirectivePrologue(node.body.body);\n-  }\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, \"ArrowFunctionExpression\")\n-};\n-\n-lp$2.parseExprList = function(close, allowEmpty) {\n-  var this$1 = this;\n-\n-  this.pushCx();\n-  var indent = this.curIndent, line = this.curLineStart, elts = [];\n-  this.next(); // Opening bracket\n-  while (!this.closes(close, indent + 1, line)) {\n-    if (this$1.eat(tokTypes.comma)) {\n-      elts.push(allowEmpty ? null : this$1.dummyIdent());\n-      continue\n-    }\n-    var elt = this$1.parseMaybeAssign();\n-    if (isDummy(elt)) {\n-      if (this$1.closes(close, indent, line)) { break }\n-      this$1.next();\n-    } else {\n-      elts.push(elt);\n-    }\n-    this$1.eat(tokTypes.comma);\n-  }\n-  this.popCx();\n-  if (!this.eat(close)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  return elts\n-};\n-\n-lp$2.parseAwait = function() {\n-  var node = this.startNode();\n-  this.next();\n-  node.argument = this.parseMaybeUnary();\n-  return this.finishNode(node, \"AwaitExpression\")\n-};\n-\n-// Acorn: Loose parser\n-//\n-// This module provides an alternative parser (`parse_dammit`) that\n-// exposes that same interface as `parse`, but will try to parse\n-// anything as JavaScript, repairing syntax error the best it can.\n-// There are circumstances in which it will raise an error and give\n-// up, but they are very rare. The resulting AST will be a mostly\n-// valid JavaScript AST (as per the [Mozilla parser API][api], except\n-// that:\n-//\n-// - Return outside functions is allowed\n-//\n-// - Label consistency (no conflicts, break only to existing labels)\n-//   is not enforced.\n-//\n-// - Bogus Identifier nodes with a name of `\"✖\"` are inserted whenever\n-//   the parser got too confused to return anything meaningful.\n-//\n-// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n-//\n-// The expected use for this is to *first* try `acorn.parse`, and only\n-// if that fails switch to `parse_dammit`. The loose parser might\n-// parse badly indented code incorrectly, so **don't** use it as\n-// your default parser.\n-//\n-// Quite a lot of acorn.js is duplicated here. The alternative was to\n-// add a *lot* of extra cruft to that file, making it less readable\n-// and slower. Copying and editing the code allowed me to make\n-// invasive changes and simplifications without creating a complicated\n-// tangle.\n-\n-defaultOptions.tabSize = 4;\n-\n-// eslint-disable-next-line camelcase\n-function parse_dammit(input, options) {\n-  return new LooseParser(input, options).parse()\n-}\n-\n-addLooseExports(parse_dammit, LooseParser, pluginsLoose);\n-\n-export { parse_dammit, LooseParser, pluginsLoose };"
        },
        {
            "sha": "e1dc7a44d463c2aac2716a59cc646bb606bc4165",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/acorn_loose.js",
            "status": "removed",
            "additions": 0,
            "deletions": 1434,
            "changes": 1434,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn_loose.js",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn_loose.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Facorn_loose.js?ref=9697c0820f015ccf898a3662305a0caa3cd9c208",
            "patch": "@@ -1,1434 +0,0 @@\n-(function (global, factory) {\n-\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('./acorn')) :\n-\ttypeof define === 'function' && define.amd ? define(['exports', './acorn'], factory) :\n-\t(factory((global.acorn = global.acorn || {}, global.acorn.loose = {}),global.acorn));\n-}(this, (function (exports,__acorn) { 'use strict';\n-\n-function noop() {}\n-\n-// Registered plugins\n-var pluginsLoose = {};\n-\n-var LooseParser = function LooseParser(input, options) {\n-  if ( options === void 0 ) options = {};\n-\n-  this.toks = __acorn.tokenizer(input, options);\n-  this.options = this.toks.options;\n-  this.input = this.toks.input;\n-  this.tok = this.last = {type: __acorn.tokTypes.eof, start: 0, end: 0};\n-  this.tok.validateRegExpFlags = noop;\n-  this.tok.validateRegExpPattern = noop;\n-  if (this.options.locations) {\n-    var here = this.toks.curPosition();\n-    this.tok.loc = new __acorn.SourceLocation(this.toks, here, here);\n-  }\n-  this.ahead = []; // Tokens ahead\n-  this.context = []; // Indentation contexted\n-  this.curIndent = 0;\n-  this.curLineStart = 0;\n-  this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n-  this.inAsync = false;\n-  this.inFunction = false;\n-  // Load plugins\n-  this.options.pluginsLoose = options.pluginsLoose || {};\n-  this.loadPlugins(this.options.pluginsLoose);\n-};\n-\n-LooseParser.prototype.startNode = function startNode () {\n-  return new __acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n-};\n-\n-LooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n-  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n-};\n-\n-LooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n-  if (this.options.locations) {\n-    return new __acorn.Node(this.toks, pos[0], pos[1])\n-  } else {\n-    return new __acorn.Node(this.toks, pos)\n-  }\n-};\n-\n-LooseParser.prototype.finishNode = function finishNode (node, type) {\n-  node.type = type;\n-  node.end = this.last.end;\n-  if (this.options.locations)\n-    { node.loc.end = this.last.loc.end; }\n-  if (this.options.ranges)\n-    { node.range[1] = this.last.end; }\n-  return node\n-};\n-\n-LooseParser.prototype.dummyNode = function dummyNode (type) {\n-  var dummy = this.startNode();\n-  dummy.type = type;\n-  dummy.end = dummy.start;\n-  if (this.options.locations)\n-    { dummy.loc.end = dummy.loc.start; }\n-  if (this.options.ranges)\n-    { dummy.range[1] = dummy.start; }\n-  this.last = {type: __acorn.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n-  return dummy\n-};\n-\n-LooseParser.prototype.dummyIdent = function dummyIdent () {\n-  var dummy = this.dummyNode(\"Identifier\");\n-  dummy.name = \"✖\";\n-  return dummy\n-};\n-\n-LooseParser.prototype.dummyString = function dummyString () {\n-  var dummy = this.dummyNode(\"Literal\");\n-  dummy.value = dummy.raw = \"✖\";\n-  return dummy\n-};\n-\n-LooseParser.prototype.eat = function eat (type) {\n-  if (this.tok.type === type) {\n-    this.next();\n-    return true\n-  } else {\n-    return false\n-  }\n-};\n-\n-LooseParser.prototype.isContextual = function isContextual (name) {\n-  return this.tok.type === __acorn.tokTypes.name && this.tok.value === name\n-};\n-\n-LooseParser.prototype.eatContextual = function eatContextual (name) {\n-  return this.tok.value === name && this.eat(__acorn.tokTypes.name)\n-};\n-\n-LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n-  return this.tok.type === __acorn.tokTypes.eof || this.tok.type === __acorn.tokTypes.braceR ||\n-    __acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n-};\n-\n-LooseParser.prototype.semicolon = function semicolon () {\n-  return this.eat(__acorn.tokTypes.semi)\n-};\n-\n-LooseParser.prototype.expect = function expect (type) {\n-    var this$1 = this;\n-\n-  if (this.eat(type)) { return true }\n-  for (var i = 1; i <= 2; i++) {\n-    if (this$1.lookAhead(i).type === type) {\n-      for (var j = 0; j < i; j++) { this$1.next(); }\n-      return true\n-    }\n-  }\n-};\n-\n-LooseParser.prototype.pushCx = function pushCx () {\n-  this.context.push(this.curIndent);\n-};\n-\n-LooseParser.prototype.popCx = function popCx () {\n-  this.curIndent = this.context.pop();\n-};\n-\n-LooseParser.prototype.lineEnd = function lineEnd (pos) {\n-  while (pos < this.input.length && !__acorn.isNewLine(this.input.charCodeAt(pos))) { ++pos; }\n-  return pos\n-};\n-\n-LooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n-    var this$1 = this;\n-\n-  for (var count = 0;; ++pos) {\n-    var ch = this$1.input.charCodeAt(pos);\n-    if (ch === 32) { ++count; }\n-    else if (ch === 9) { count += this$1.options.tabSize; }\n-    else { return count }\n-  }\n-};\n-\n-LooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n-  if (this.tok.type === closeTok || this.tok.type === __acorn.tokTypes.eof) { return true }\n-  return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n-    (!blockHeuristic || this.nextLineStart >= this.input.length ||\n-     this.indentationAfter(this.nextLineStart) < indent)\n-};\n-\n-LooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n-    var this$1 = this;\n-\n-  for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n-    var ch = this$1.input.charCodeAt(p);\n-    if (ch !== 9 && ch !== 32) { return false }\n-  }\n-  return true\n-};\n-\n-LooseParser.prototype.extend = function extend (name, f) {\n-  this[name] = f(this[name]);\n-};\n-\n-LooseParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n-    var this$1 = this;\n-\n-  for (var name in pluginConfigs) {\n-    var plugin = pluginsLoose[name];\n-    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n-    plugin(this$1, pluginConfigs[name]);\n-  }\n-};\n-\n-LooseParser.prototype.parse = function parse () {\n-  this.next();\n-  return this.parseTopLevel()\n-};\n-\n-var lp = LooseParser.prototype;\n-\n-function isSpace(ch) {\n-  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || __acorn.isNewLine(ch)\n-}\n-\n-lp.next = function() {\n-  var this$1 = this;\n-\n-  this.last = this.tok;\n-  if (this.ahead.length)\n-    { this.tok = this.ahead.shift(); }\n-  else\n-    { this.tok = this.readToken(); }\n-\n-  if (this.tok.start >= this.nextLineStart) {\n-    while (this.tok.start >= this.nextLineStart) {\n-      this$1.curLineStart = this$1.nextLineStart;\n-      this$1.nextLineStart = this$1.lineEnd(this$1.curLineStart) + 1;\n-    }\n-    this.curIndent = this.indentationAfter(this.curLineStart);\n-  }\n-};\n-\n-lp.readToken = function() {\n-  var this$1 = this;\n-\n-  for (;;) {\n-    try {\n-      this$1.toks.next();\n-      if (this$1.toks.type === __acorn.tokTypes.dot &&\n-          this$1.input.substr(this$1.toks.end, 1) === \".\" &&\n-          this$1.options.ecmaVersion >= 6) {\n-        this$1.toks.end++;\n-        this$1.toks.type = __acorn.tokTypes.ellipsis;\n-      }\n-      return new __acorn.Token(this$1.toks)\n-    } catch (e) {\n-      if (!(e instanceof SyntaxError)) { throw e }\n-\n-      // Try to skip some text, based on the error message, and then continue\n-      var msg = e.message, pos = e.raisedAt, replace = true;\n-      if (/unterminated/i.test(msg)) {\n-        pos = this$1.lineEnd(e.pos + 1);\n-        if (/string/.test(msg)) {\n-          replace = {start: e.pos, end: pos, type: __acorn.tokTypes.string, value: this$1.input.slice(e.pos + 1, pos)};\n-        } else if (/regular expr/i.test(msg)) {\n-          var re = this$1.input.slice(e.pos, pos);\n-          try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n-          replace = {start: e.pos, end: pos, type: __acorn.tokTypes.regexp, value: re};\n-        } else if (/template/.test(msg)) {\n-          replace = {\n-            start: e.pos,\n-            end: pos,\n-            type: __acorn.tokTypes.template,\n-            value: this$1.input.slice(e.pos, pos)\n-          };\n-        } else {\n-          replace = false;\n-        }\n-      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n-        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n-      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n-        while (pos < this.input.length) {\n-          var ch = this$1.input.charCodeAt(pos++);\n-          if (ch === 34 || ch === 39 || __acorn.isNewLine(ch)) { break }\n-        }\n-      } else if (/unexpected character/i.test(msg)) {\n-        pos++;\n-        replace = false;\n-      } else if (/regular expression/i.test(msg)) {\n-        replace = true;\n-      } else {\n-        throw e\n-      }\n-      this$1.resetTo(pos);\n-      if (replace === true) { replace = {start: pos, end: pos, type: __acorn.tokTypes.name, value: \"✖\"}; }\n-      if (replace) {\n-        if (this$1.options.locations)\n-          { replace.loc = new __acorn.SourceLocation(\n-            this$1.toks,\n-            __acorn.getLineInfo(this$1.input, replace.start),\n-            __acorn.getLineInfo(this$1.input, replace.end)); }\n-        return replace\n-      }\n-    }\n-  }\n-};\n-\n-lp.resetTo = function(pos) {\n-  var this$1 = this;\n-\n-  this.toks.pos = pos;\n-  var ch = this.input.charAt(pos - 1);\n-  this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n-    /[enwfd]/.test(ch) &&\n-    /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n-\n-  if (this.options.locations) {\n-    this.toks.curLine = 1;\n-    this.toks.lineStart = __acorn.lineBreakG.lastIndex = 0;\n-    var match;\n-    while ((match = __acorn.lineBreakG.exec(this.input)) && match.index < pos) {\n-      ++this$1.toks.curLine;\n-      this$1.toks.lineStart = match.index + match[0].length;\n-    }\n-  }\n-};\n-\n-lp.lookAhead = function(n) {\n-  var this$1 = this;\n-\n-  while (n > this.ahead.length)\n-    { this$1.ahead.push(this$1.readToken()); }\n-  return this.ahead[n - 1]\n-};\n-\n-function isDummy(node) { return node.name === \"✖\" }\n-\n-var lp$1 = LooseParser.prototype;\n-\n-lp$1.parseTopLevel = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNodeAt(this.options.locations ? [0, __acorn.getLineInfo(this.input, 0)] : 0);\n-  node.body = [];\n-  while (this.tok.type !== __acorn.tokTypes.eof) { node.body.push(this$1.parseStatement()); }\n-  this.toks.adaptDirectivePrologue(node.body);\n-  this.last = this.tok;\n-  if (this.options.ecmaVersion >= 6) {\n-    node.sourceType = this.options.sourceType;\n-  }\n-  return this.finishNode(node, \"Program\")\n-};\n-\n-lp$1.parseStatement = function() {\n-  var this$1 = this;\n-\n-  var starttype = this.tok.type, node = this.startNode(), kind;\n-\n-  if (this.toks.isLet()) {\n-    starttype = __acorn.tokTypes._var;\n-    kind = \"let\";\n-  }\n-\n-  switch (starttype) {\n-  case __acorn.tokTypes._break: case __acorn.tokTypes._continue:\n-    this.next();\n-    var isBreak = starttype === __acorn.tokTypes._break;\n-    if (this.semicolon() || this.canInsertSemicolon()) {\n-      node.label = null;\n-    } else {\n-      node.label = this.tok.type === __acorn.tokTypes.name ? this.parseIdent() : null;\n-      this.semicolon();\n-    }\n-    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n-\n-  case __acorn.tokTypes._debugger:\n-    this.next();\n-    this.semicolon();\n-    return this.finishNode(node, \"DebuggerStatement\")\n-\n-  case __acorn.tokTypes._do:\n-    this.next();\n-    node.body = this.parseStatement();\n-    node.test = this.eat(__acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n-    this.semicolon();\n-    return this.finishNode(node, \"DoWhileStatement\")\n-\n-  case __acorn.tokTypes._for:\n-    this.next(); // `for` keyword\n-    var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n-\n-    this.pushCx();\n-    this.expect(__acorn.tokTypes.parenL);\n-    if (this.tok.type === __acorn.tokTypes.semi) { return this.parseFor(node, null) }\n-    var isLet = this.toks.isLet();\n-    if (isLet || this.tok.type === __acorn.tokTypes._var || this.tok.type === __acorn.tokTypes._const) {\n-      var init$1 = this.parseVar(true, isLet ? \"let\" : this.tok.value);\n-      if (init$1.declarations.length === 1 && (this.tok.type === __acorn.tokTypes._in || this.isContextual(\"of\"))) {\n-        if (this.options.ecmaVersion >= 9 && this.tok.type !== __acorn.tokTypes._in) {\n-          node.await = isAwait;\n-        }\n-        return this.parseForIn(node, init$1)\n-      }\n-      return this.parseFor(node, init$1)\n-    }\n-    var init = this.parseExpression(true);\n-    if (this.tok.type === __acorn.tokTypes._in || this.isContextual(\"of\")) {\n-      if (this.options.ecmaVersion >= 9 && this.tok.type !== __acorn.tokTypes._in) {\n-        node.await = isAwait;\n-      }\n-      return this.parseForIn(node, this.toAssignable(init))\n-    }\n-    return this.parseFor(node, init)\n-\n-  case __acorn.tokTypes._function:\n-    this.next();\n-    return this.parseFunction(node, true)\n-\n-  case __acorn.tokTypes._if:\n-    this.next();\n-    node.test = this.parseParenExpression();\n-    node.consequent = this.parseStatement();\n-    node.alternate = this.eat(__acorn.tokTypes._else) ? this.parseStatement() : null;\n-    return this.finishNode(node, \"IfStatement\")\n-\n-  case __acorn.tokTypes._return:\n-    this.next();\n-    if (this.eat(__acorn.tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n-    else { node.argument = this.parseExpression(); this.semicolon(); }\n-    return this.finishNode(node, \"ReturnStatement\")\n-\n-  case __acorn.tokTypes._switch:\n-    var blockIndent = this.curIndent, line = this.curLineStart;\n-    this.next();\n-    node.discriminant = this.parseParenExpression();\n-    node.cases = [];\n-    this.pushCx();\n-    this.expect(__acorn.tokTypes.braceL);\n-\n-    var cur;\n-    while (!this.closes(__acorn.tokTypes.braceR, blockIndent, line, true)) {\n-      if (this$1.tok.type === __acorn.tokTypes._case || this$1.tok.type === __acorn.tokTypes._default) {\n-        var isCase = this$1.tok.type === __acorn.tokTypes._case;\n-        if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n-        node.cases.push(cur = this$1.startNode());\n-        cur.consequent = [];\n-        this$1.next();\n-        if (isCase) { cur.test = this$1.parseExpression(); }\n-        else { cur.test = null; }\n-        this$1.expect(__acorn.tokTypes.colon);\n-      } else {\n-        if (!cur) {\n-          node.cases.push(cur = this$1.startNode());\n-          cur.consequent = [];\n-          cur.test = null;\n-        }\n-        cur.consequent.push(this$1.parseStatement());\n-      }\n-    }\n-    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n-    this.popCx();\n-    this.eat(__acorn.tokTypes.braceR);\n-    return this.finishNode(node, \"SwitchStatement\")\n-\n-  case __acorn.tokTypes._throw:\n-    this.next();\n-    node.argument = this.parseExpression();\n-    this.semicolon();\n-    return this.finishNode(node, \"ThrowStatement\")\n-\n-  case __acorn.tokTypes._try:\n-    this.next();\n-    node.block = this.parseBlock();\n-    node.handler = null;\n-    if (this.tok.type === __acorn.tokTypes._catch) {\n-      var clause = this.startNode();\n-      this.next();\n-      if (this.eat(__acorn.tokTypes.parenL)) {\n-        clause.param = this.toAssignable(this.parseExprAtom(), true);\n-        this.expect(__acorn.tokTypes.parenR);\n-      } else {\n-        clause.param = null;\n-      }\n-      clause.body = this.parseBlock();\n-      node.handler = this.finishNode(clause, \"CatchClause\");\n-    }\n-    node.finalizer = this.eat(__acorn.tokTypes._finally) ? this.parseBlock() : null;\n-    if (!node.handler && !node.finalizer) { return node.block }\n-    return this.finishNode(node, \"TryStatement\")\n-\n-  case __acorn.tokTypes._var:\n-  case __acorn.tokTypes._const:\n-    return this.parseVar(false, kind || this.tok.value)\n-\n-  case __acorn.tokTypes._while:\n-    this.next();\n-    node.test = this.parseParenExpression();\n-    node.body = this.parseStatement();\n-    return this.finishNode(node, \"WhileStatement\")\n-\n-  case __acorn.tokTypes._with:\n-    this.next();\n-    node.object = this.parseParenExpression();\n-    node.body = this.parseStatement();\n-    return this.finishNode(node, \"WithStatement\")\n-\n-  case __acorn.tokTypes.braceL:\n-    return this.parseBlock()\n-\n-  case __acorn.tokTypes.semi:\n-    this.next();\n-    return this.finishNode(node, \"EmptyStatement\")\n-\n-  case __acorn.tokTypes._class:\n-    return this.parseClass(true)\n-\n-  case __acorn.tokTypes._import:\n-    return this.parseImport()\n-\n-  case __acorn.tokTypes._export:\n-    return this.parseExport()\n-\n-  default:\n-    if (this.toks.isAsyncFunction()) {\n-      this.next();\n-      this.next();\n-      return this.parseFunction(node, true, true)\n-    }\n-    var expr = this.parseExpression();\n-    if (isDummy(expr)) {\n-      this.next();\n-      if (this.tok.type === __acorn.tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n-      return this.parseStatement()\n-    } else if (starttype === __acorn.tokTypes.name && expr.type === \"Identifier\" && this.eat(__acorn.tokTypes.colon)) {\n-      node.body = this.parseStatement();\n-      node.label = expr;\n-      return this.finishNode(node, \"LabeledStatement\")\n-    } else {\n-      node.expression = expr;\n-      this.semicolon();\n-      return this.finishNode(node, \"ExpressionStatement\")\n-    }\n-  }\n-};\n-\n-lp$1.parseBlock = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.pushCx();\n-  this.expect(__acorn.tokTypes.braceL);\n-  var blockIndent = this.curIndent, line = this.curLineStart;\n-  node.body = [];\n-  while (!this.closes(__acorn.tokTypes.braceR, blockIndent, line, true))\n-    { node.body.push(this$1.parseStatement()); }\n-  this.popCx();\n-  this.eat(__acorn.tokTypes.braceR);\n-  return this.finishNode(node, \"BlockStatement\")\n-};\n-\n-lp$1.parseFor = function(node, init) {\n-  node.init = init;\n-  node.test = node.update = null;\n-  if (this.eat(__acorn.tokTypes.semi) && this.tok.type !== __acorn.tokTypes.semi) { node.test = this.parseExpression(); }\n-  if (this.eat(__acorn.tokTypes.semi) && this.tok.type !== __acorn.tokTypes.parenR) { node.update = this.parseExpression(); }\n-  this.popCx();\n-  this.expect(__acorn.tokTypes.parenR);\n-  node.body = this.parseStatement();\n-  return this.finishNode(node, \"ForStatement\")\n-};\n-\n-lp$1.parseForIn = function(node, init) {\n-  var type = this.tok.type === __acorn.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n-  this.next();\n-  node.left = init;\n-  node.right = this.parseExpression();\n-  this.popCx();\n-  this.expect(__acorn.tokTypes.parenR);\n-  node.body = this.parseStatement();\n-  return this.finishNode(node, type)\n-};\n-\n-lp$1.parseVar = function(noIn, kind) {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  node.kind = kind;\n-  this.next();\n-  node.declarations = [];\n-  do {\n-    var decl = this$1.startNode();\n-    decl.id = this$1.options.ecmaVersion >= 6 ? this$1.toAssignable(this$1.parseExprAtom(), true) : this$1.parseIdent();\n-    decl.init = this$1.eat(__acorn.tokTypes.eq) ? this$1.parseMaybeAssign(noIn) : null;\n-    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n-  } while (this.eat(__acorn.tokTypes.comma))\n-  if (!node.declarations.length) {\n-    var decl$1 = this.startNode();\n-    decl$1.id = this.dummyIdent();\n-    node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n-  }\n-  if (!noIn) { this.semicolon(); }\n-  return this.finishNode(node, \"VariableDeclaration\")\n-};\n-\n-lp$1.parseClass = function(isStatement) {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.next();\n-  if (this.tok.type === __acorn.tokTypes.name) { node.id = this.parseIdent(); }\n-  else if (isStatement === true) { node.id = this.dummyIdent(); }\n-  else { node.id = null; }\n-  node.superClass = this.eat(__acorn.tokTypes._extends) ? this.parseExpression() : null;\n-  node.body = this.startNode();\n-  node.body.body = [];\n-  this.pushCx();\n-  var indent = this.curIndent + 1, line = this.curLineStart;\n-  this.eat(__acorn.tokTypes.braceL);\n-  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n-  while (!this.closes(__acorn.tokTypes.braceR, indent, line)) {\n-    if (this$1.semicolon()) { continue }\n-    var method = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0);\n-    if (this$1.options.ecmaVersion >= 6) {\n-      method.static = false;\n-      isGenerator = this$1.eat(__acorn.tokTypes.star);\n-    }\n-    this$1.parsePropertyName(method);\n-    if (isDummy(method.key)) { if (isDummy(this$1.parseMaybeAssign())) { this$1.next(); } this$1.eat(__acorn.tokTypes.comma); continue }\n-    if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n-        (this$1.tok.type !== __acorn.tokTypes.parenL && this$1.tok.type !== __acorn.tokTypes.braceL)) {\n-      method.static = true;\n-      isGenerator = this$1.eat(__acorn.tokTypes.star);\n-      this$1.parsePropertyName(method);\n-    } else {\n-      method.static = false;\n-    }\n-    if (!method.computed &&\n-        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.tok.type !== __acorn.tokTypes.parenL &&\n-        !this$1.canInsertSemicolon()) {\n-      isAsync = true;\n-      isGenerator = this$1.options.ecmaVersion >= 9 && this$1.eat(__acorn.tokTypes.star);\n-      this$1.parsePropertyName(method);\n-    } else {\n-      isAsync = false;\n-    }\n-    if (this$1.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n-        !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n-        this$1.tok.type !== __acorn.tokTypes.parenL && this$1.tok.type !== __acorn.tokTypes.braceL) {\n-      method.kind = method.key.name;\n-      this$1.parsePropertyName(method);\n-      method.value = this$1.parseMethod(false);\n-    } else {\n-      if (!method.computed && !method.static && !isGenerator && !isAsync && (\n-        method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n-          method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n-        method.kind = \"constructor\";\n-      } else {\n-        method.kind = \"method\";\n-      }\n-      method.value = this$1.parseMethod(isGenerator, isAsync);\n-    }\n-    node.body.body.push(this$1.finishNode(method, \"MethodDefinition\"));\n-  }\n-  this.popCx();\n-  if (!this.eat(__acorn.tokTypes.braceR)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  this.semicolon();\n-  this.finishNode(node.body, \"ClassBody\");\n-  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n-};\n-\n-lp$1.parseFunction = function(node, isStatement, isAsync) {\n-  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = this.eat(__acorn.tokTypes.star);\n-  }\n-  if (this.options.ecmaVersion >= 8) {\n-    node.async = !!isAsync;\n-  }\n-  if (this.tok.type === __acorn.tokTypes.name) { node.id = this.parseIdent(); }\n-  else if (isStatement === true) { node.id = this.dummyIdent(); }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.parseFunctionParams();\n-  node.body = this.parseBlock();\n-  this.toks.adaptDirectivePrologue(node.body.body);\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n-};\n-\n-lp$1.parseExport = function() {\n-  var node = this.startNode();\n-  this.next();\n-  if (this.eat(__acorn.tokTypes.star)) {\n-    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n-    return this.finishNode(node, \"ExportAllDeclaration\")\n-  }\n-  if (this.eat(__acorn.tokTypes._default)) {\n-    // export default (function foo() {}) // This is FunctionExpression.\n-    var isAsync;\n-    if (this.tok.type === __acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n-      var fNode = this.startNode();\n-      this.next();\n-      if (isAsync) { this.next(); }\n-      node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n-    } else if (this.tok.type === __acorn.tokTypes._class) {\n-      node.declaration = this.parseClass(\"nullableID\");\n-    } else {\n-      node.declaration = this.parseMaybeAssign();\n-      this.semicolon();\n-    }\n-    return this.finishNode(node, \"ExportDefaultDeclaration\")\n-  }\n-  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n-    node.declaration = this.parseStatement();\n-    node.specifiers = [];\n-    node.source = null;\n-  } else {\n-    node.declaration = null;\n-    node.specifiers = this.parseExportSpecifierList();\n-    node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n-    this.semicolon();\n-  }\n-  return this.finishNode(node, \"ExportNamedDeclaration\")\n-};\n-\n-lp$1.parseImport = function() {\n-  var node = this.startNode();\n-  this.next();\n-  if (this.tok.type === __acorn.tokTypes.string) {\n-    node.specifiers = [];\n-    node.source = this.parseExprAtom();\n-  } else {\n-    var elt;\n-    if (this.tok.type === __acorn.tokTypes.name && this.tok.value !== \"from\") {\n-      elt = this.startNode();\n-      elt.local = this.parseIdent();\n-      this.finishNode(elt, \"ImportDefaultSpecifier\");\n-      this.eat(__acorn.tokTypes.comma);\n-    }\n-    node.specifiers = this.parseImportSpecifierList();\n-    node.source = this.eatContextual(\"from\") && this.tok.type === __acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString();\n-    if (elt) { node.specifiers.unshift(elt); }\n-  }\n-  this.semicolon();\n-  return this.finishNode(node, \"ImportDeclaration\")\n-};\n-\n-lp$1.parseImportSpecifierList = function() {\n-  var this$1 = this;\n-\n-  var elts = [];\n-  if (this.tok.type === __acorn.tokTypes.star) {\n-    var elt = this.startNode();\n-    this.next();\n-    elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n-    elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n-  } else {\n-    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n-    this.pushCx();\n-    this.eat(__acorn.tokTypes.braceL);\n-    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n-    while (!this.closes(__acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n-      var elt$1 = this$1.startNode();\n-      if (this$1.eat(__acorn.tokTypes.star)) {\n-        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : this$1.dummyIdent();\n-        this$1.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n-      } else {\n-        if (this$1.isContextual(\"from\")) { break }\n-        elt$1.imported = this$1.parseIdent();\n-        if (isDummy(elt$1.imported)) { break }\n-        elt$1.local = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt$1.imported;\n-        this$1.finishNode(elt$1, \"ImportSpecifier\");\n-      }\n-      elts.push(elt$1);\n-      this$1.eat(__acorn.tokTypes.comma);\n-    }\n-    this.eat(__acorn.tokTypes.braceR);\n-    this.popCx();\n-  }\n-  return elts\n-};\n-\n-lp$1.parseExportSpecifierList = function() {\n-  var this$1 = this;\n-\n-  var elts = [];\n-  var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n-  this.pushCx();\n-  this.eat(__acorn.tokTypes.braceL);\n-  if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n-  while (!this.closes(__acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n-    if (this$1.isContextual(\"from\")) { break }\n-    var elt = this$1.startNode();\n-    elt.local = this$1.parseIdent();\n-    if (isDummy(elt.local)) { break }\n-    elt.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent() : elt.local;\n-    this$1.finishNode(elt, \"ExportSpecifier\");\n-    elts.push(elt);\n-    this$1.eat(__acorn.tokTypes.comma);\n-  }\n-  this.eat(__acorn.tokTypes.braceR);\n-  this.popCx();\n-  return elts\n-};\n-\n-var lp$2 = LooseParser.prototype;\n-\n-lp$2.checkLVal = function(expr) {\n-  if (!expr) { return expr }\n-  switch (expr.type) {\n-  case \"Identifier\":\n-  case \"MemberExpression\":\n-    return expr\n-\n-  case \"ParenthesizedExpression\":\n-    expr.expression = this.checkLVal(expr.expression);\n-    return expr\n-\n-  default:\n-    return this.dummyIdent()\n-  }\n-};\n-\n-lp$2.parseExpression = function(noIn) {\n-  var this$1 = this;\n-\n-  var start = this.storeCurrentPos();\n-  var expr = this.parseMaybeAssign(noIn);\n-  if (this.tok.type === __acorn.tokTypes.comma) {\n-    var node = this.startNodeAt(start);\n-    node.expressions = [expr];\n-    while (this.eat(__acorn.tokTypes.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn)); }\n-    return this.finishNode(node, \"SequenceExpression\")\n-  }\n-  return expr\n-};\n-\n-lp$2.parseParenExpression = function() {\n-  this.pushCx();\n-  this.expect(__acorn.tokTypes.parenL);\n-  var val = this.parseExpression();\n-  this.popCx();\n-  this.expect(__acorn.tokTypes.parenR);\n-  return val\n-};\n-\n-lp$2.parseMaybeAssign = function(noIn) {\n-  if (this.toks.isContextual(\"yield\")) {\n-    var node = this.startNode();\n-    this.next();\n-    if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== __acorn.tokTypes.star && !this.tok.type.startsExpr)) {\n-      node.delegate = false;\n-      node.argument = null;\n-    } else {\n-      node.delegate = this.eat(__acorn.tokTypes.star);\n-      node.argument = this.parseMaybeAssign();\n-    }\n-    return this.finishNode(node, \"YieldExpression\")\n-  }\n-\n-  var start = this.storeCurrentPos();\n-  var left = this.parseMaybeConditional(noIn);\n-  if (this.tok.type.isAssign) {\n-    var node$1 = this.startNodeAt(start);\n-    node$1.operator = this.tok.value;\n-    node$1.left = this.tok.type === __acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n-    this.next();\n-    node$1.right = this.parseMaybeAssign(noIn);\n-    return this.finishNode(node$1, \"AssignmentExpression\")\n-  }\n-  return left\n-};\n-\n-lp$2.parseMaybeConditional = function(noIn) {\n-  var start = this.storeCurrentPos();\n-  var expr = this.parseExprOps(noIn);\n-  if (this.eat(__acorn.tokTypes.question)) {\n-    var node = this.startNodeAt(start);\n-    node.test = expr;\n-    node.consequent = this.parseMaybeAssign();\n-    node.alternate = this.expect(__acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n-    return this.finishNode(node, \"ConditionalExpression\")\n-  }\n-  return expr\n-};\n-\n-lp$2.parseExprOps = function(noIn) {\n-  var start = this.storeCurrentPos();\n-  var indent = this.curIndent, line = this.curLineStart;\n-  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n-};\n-\n-lp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n-  if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n-  var prec = this.tok.type.binop;\n-  if (prec != null && (!noIn || this.tok.type !== __acorn.tokTypes._in)) {\n-    if (prec > minPrec) {\n-      var node = this.startNodeAt(start);\n-      node.left = left;\n-      node.operator = this.tok.value;\n-      this.next();\n-      if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n-        node.right = this.dummyIdent();\n-      } else {\n-        var rightStart = this.storeCurrentPos();\n-        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n-      }\n-      this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n-      return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n-    }\n-  }\n-  return left\n-};\n-\n-lp$2.parseMaybeUnary = function(sawUnary) {\n-  var this$1 = this;\n-\n-  var start = this.storeCurrentPos(), expr;\n-  if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n-    (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n-  ) {\n-    expr = this.parseAwait();\n-    sawUnary = true;\n-  } else if (this.tok.type.prefix) {\n-    var node = this.startNode(), update = this.tok.type === __acorn.tokTypes.incDec;\n-    if (!update) { sawUnary = true; }\n-    node.operator = this.tok.value;\n-    node.prefix = true;\n-    this.next();\n-    node.argument = this.parseMaybeUnary(true);\n-    if (update) { node.argument = this.checkLVal(node.argument); }\n-    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n-  } else if (this.tok.type === __acorn.tokTypes.ellipsis) {\n-    var node$1 = this.startNode();\n-    this.next();\n-    node$1.argument = this.parseMaybeUnary(sawUnary);\n-    expr = this.finishNode(node$1, \"SpreadElement\");\n-  } else {\n-    expr = this.parseExprSubscripts();\n-    while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n-      var node$2 = this$1.startNodeAt(start);\n-      node$2.operator = this$1.tok.value;\n-      node$2.prefix = false;\n-      node$2.argument = this$1.checkLVal(expr);\n-      this$1.next();\n-      expr = this$1.finishNode(node$2, \"UpdateExpression\");\n-    }\n-  }\n-\n-  if (!sawUnary && this.eat(__acorn.tokTypes.starstar)) {\n-    var node$3 = this.startNodeAt(start);\n-    node$3.operator = \"**\";\n-    node$3.left = expr;\n-    node$3.right = this.parseMaybeUnary(false);\n-    return this.finishNode(node$3, \"BinaryExpression\")\n-  }\n-\n-  return expr\n-};\n-\n-lp$2.parseExprSubscripts = function() {\n-  var start = this.storeCurrentPos();\n-  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n-};\n-\n-lp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n-  var this$1 = this;\n-\n-  for (;;) {\n-    if (this$1.curLineStart !== line && this$1.curIndent <= startIndent && this$1.tokenStartsLine()) {\n-      if (this$1.tok.type === __acorn.tokTypes.dot && this$1.curIndent === startIndent)\n-        { --startIndent; }\n-      else\n-        { return base }\n-    }\n-\n-    var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this$1.canInsertSemicolon();\n-\n-    if (this$1.eat(__acorn.tokTypes.dot)) {\n-      var node = this$1.startNodeAt(start);\n-      node.object = base;\n-      if (this$1.curLineStart !== line && this$1.curIndent <= startIndent && this$1.tokenStartsLine())\n-        { node.property = this$1.dummyIdent(); }\n-      else\n-        { node.property = this$1.parsePropertyAccessor() || this$1.dummyIdent(); }\n-      node.computed = false;\n-      base = this$1.finishNode(node, \"MemberExpression\");\n-    } else if (this$1.tok.type === __acorn.tokTypes.bracketL) {\n-      this$1.pushCx();\n-      this$1.next();\n-      var node$1 = this$1.startNodeAt(start);\n-      node$1.object = base;\n-      node$1.property = this$1.parseExpression();\n-      node$1.computed = true;\n-      this$1.popCx();\n-      this$1.expect(__acorn.tokTypes.bracketR);\n-      base = this$1.finishNode(node$1, \"MemberExpression\");\n-    } else if (!noCalls && this$1.tok.type === __acorn.tokTypes.parenL) {\n-      var exprList = this$1.parseExprList(__acorn.tokTypes.parenR);\n-      if (maybeAsyncArrow && this$1.eat(__acorn.tokTypes.arrow))\n-        { return this$1.parseArrowExpression(this$1.startNodeAt(start), exprList, true) }\n-      var node$2 = this$1.startNodeAt(start);\n-      node$2.callee = base;\n-      node$2.arguments = exprList;\n-      base = this$1.finishNode(node$2, \"CallExpression\");\n-    } else if (this$1.tok.type === __acorn.tokTypes.backQuote) {\n-      var node$3 = this$1.startNodeAt(start);\n-      node$3.tag = base;\n-      node$3.quasi = this$1.parseTemplate();\n-      base = this$1.finishNode(node$3, \"TaggedTemplateExpression\");\n-    } else {\n-      return base\n-    }\n-  }\n-};\n-\n-lp$2.parseExprAtom = function() {\n-  var node;\n-  switch (this.tok.type) {\n-  case __acorn.tokTypes._this:\n-  case __acorn.tokTypes._super:\n-    var type = this.tok.type === __acorn.tokTypes._this ? \"ThisExpression\" : \"Super\";\n-    node = this.startNode();\n-    this.next();\n-    return this.finishNode(node, type)\n-\n-  case __acorn.tokTypes.name:\n-    var start = this.storeCurrentPos();\n-    var id = this.parseIdent();\n-    var isAsync = false;\n-    if (id.name === \"async\" && !this.canInsertSemicolon()) {\n-      if (this.eat(__acorn.tokTypes._function))\n-        { return this.parseFunction(this.startNodeAt(start), false, true) }\n-      if (this.tok.type === __acorn.tokTypes.name) {\n-        id = this.parseIdent();\n-        isAsync = true;\n-      }\n-    }\n-    return this.eat(__acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n-\n-  case __acorn.tokTypes.regexp:\n-    node = this.startNode();\n-    var val = this.tok.value;\n-    node.regex = {pattern: val.pattern, flags: val.flags};\n-    node.value = val.value;\n-    node.raw = this.input.slice(this.tok.start, this.tok.end);\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case __acorn.tokTypes.num: case __acorn.tokTypes.string:\n-    node = this.startNode();\n-    node.value = this.tok.value;\n-    node.raw = this.input.slice(this.tok.start, this.tok.end);\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case __acorn.tokTypes._null: case __acorn.tokTypes._true: case __acorn.tokTypes._false:\n-    node = this.startNode();\n-    node.value = this.tok.type === __acorn.tokTypes._null ? null : this.tok.type === __acorn.tokTypes._true;\n-    node.raw = this.tok.type.keyword;\n-    this.next();\n-    return this.finishNode(node, \"Literal\")\n-\n-  case __acorn.tokTypes.parenL:\n-    var parenStart = this.storeCurrentPos();\n-    this.next();\n-    var inner = this.parseExpression();\n-    this.expect(__acorn.tokTypes.parenR);\n-    if (this.eat(__acorn.tokTypes.arrow)) {\n-      // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n-      var params = inner.expressions || [inner];\n-      if (params.length && isDummy(params[params.length - 1]))\n-        { params.pop(); }\n-      return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n-    }\n-    if (this.options.preserveParens) {\n-      var par = this.startNodeAt(parenStart);\n-      par.expression = inner;\n-      inner = this.finishNode(par, \"ParenthesizedExpression\");\n-    }\n-    return inner\n-\n-  case __acorn.tokTypes.bracketL:\n-    node = this.startNode();\n-    node.elements = this.parseExprList(__acorn.tokTypes.bracketR, true);\n-    return this.finishNode(node, \"ArrayExpression\")\n-\n-  case __acorn.tokTypes.braceL:\n-    return this.parseObj()\n-\n-  case __acorn.tokTypes._class:\n-    return this.parseClass(false)\n-\n-  case __acorn.tokTypes._function:\n-    node = this.startNode();\n-    this.next();\n-    return this.parseFunction(node, false)\n-\n-  case __acorn.tokTypes._new:\n-    return this.parseNew()\n-\n-  case __acorn.tokTypes.backQuote:\n-    return this.parseTemplate()\n-\n-  default:\n-    return this.dummyIdent()\n-  }\n-};\n-\n-lp$2.parseNew = function() {\n-  var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n-  var meta = this.parseIdent(true);\n-  if (this.options.ecmaVersion >= 6 && this.eat(__acorn.tokTypes.dot)) {\n-    node.meta = meta;\n-    node.property = this.parseIdent(true);\n-    return this.finishNode(node, \"MetaProperty\")\n-  }\n-  var start = this.storeCurrentPos();\n-  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n-  if (this.tok.type === __acorn.tokTypes.parenL) {\n-    node.arguments = this.parseExprList(__acorn.tokTypes.parenR);\n-  } else {\n-    node.arguments = [];\n-  }\n-  return this.finishNode(node, \"NewExpression\")\n-};\n-\n-lp$2.parseTemplateElement = function() {\n-  var elem = this.startNode();\n-\n-  // The loose parser accepts invalid unicode escapes even in untagged templates.\n-  if (this.tok.type === __acorn.tokTypes.invalidTemplate) {\n-    elem.value = {\n-      raw: this.tok.value,\n-      cooked: null\n-    };\n-  } else {\n-    elem.value = {\n-      raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n-      cooked: this.tok.value\n-    };\n-  }\n-  this.next();\n-  elem.tail = this.tok.type === __acorn.tokTypes.backQuote;\n-  return this.finishNode(elem, \"TemplateElement\")\n-};\n-\n-lp$2.parseTemplate = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  this.next();\n-  node.expressions = [];\n-  var curElt = this.parseTemplateElement();\n-  node.quasis = [curElt];\n-  while (!curElt.tail) {\n-    this$1.next();\n-    node.expressions.push(this$1.parseExpression());\n-    if (this$1.expect(__acorn.tokTypes.braceR)) {\n-      curElt = this$1.parseTemplateElement();\n-    } else {\n-      curElt = this$1.startNode();\n-      curElt.value = {cooked: \"\", raw: \"\"};\n-      curElt.tail = true;\n-      this$1.finishNode(curElt, \"TemplateElement\");\n-    }\n-    node.quasis.push(curElt);\n-  }\n-  this.expect(__acorn.tokTypes.backQuote);\n-  return this.finishNode(node, \"TemplateLiteral\")\n-};\n-\n-lp$2.parseObj = function() {\n-  var this$1 = this;\n-\n-  var node = this.startNode();\n-  node.properties = [];\n-  this.pushCx();\n-  var indent = this.curIndent + 1, line = this.curLineStart;\n-  this.eat(__acorn.tokTypes.braceL);\n-  if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n-  while (!this.closes(__acorn.tokTypes.braceR, indent, line)) {\n-    var prop = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n-    if (this$1.options.ecmaVersion >= 9 && this$1.eat(__acorn.tokTypes.ellipsis)) {\n-      prop.argument = this$1.parseMaybeAssign();\n-      node.properties.push(this$1.finishNode(prop, \"SpreadElement\"));\n-      this$1.eat(__acorn.tokTypes.comma);\n-      continue\n-    }\n-    if (this$1.options.ecmaVersion >= 6) {\n-      start = this$1.storeCurrentPos();\n-      prop.method = false;\n-      prop.shorthand = false;\n-      isGenerator = this$1.eat(__acorn.tokTypes.star);\n-    }\n-    this$1.parsePropertyName(prop);\n-    if (this$1.toks.isAsyncProp(prop)) {\n-      isAsync = true;\n-      isGenerator = this$1.options.ecmaVersion >= 9 && this$1.eat(__acorn.tokTypes.star);\n-      this$1.parsePropertyName(prop);\n-    } else {\n-      isAsync = false;\n-    }\n-    if (isDummy(prop.key)) { if (isDummy(this$1.parseMaybeAssign())) { this$1.next(); } this$1.eat(__acorn.tokTypes.comma); continue }\n-    if (this$1.eat(__acorn.tokTypes.colon)) {\n-      prop.kind = \"init\";\n-      prop.value = this$1.parseMaybeAssign();\n-    } else if (this$1.options.ecmaVersion >= 6 && (this$1.tok.type === __acorn.tokTypes.parenL || this$1.tok.type === __acorn.tokTypes.braceL)) {\n-      prop.kind = \"init\";\n-      prop.method = true;\n-      prop.value = this$1.parseMethod(isGenerator, isAsync);\n-    } else if (this$1.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n-               !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n-               (this$1.tok.type !== __acorn.tokTypes.comma && this$1.tok.type !== __acorn.tokTypes.braceR && this$1.tok.type !== __acorn.tokTypes.eq)) {\n-      prop.kind = prop.key.name;\n-      this$1.parsePropertyName(prop);\n-      prop.value = this$1.parseMethod(false);\n-    } else {\n-      prop.kind = \"init\";\n-      if (this$1.options.ecmaVersion >= 6) {\n-        if (this$1.eat(__acorn.tokTypes.eq)) {\n-          var assign = this$1.startNodeAt(start);\n-          assign.operator = \"=\";\n-          assign.left = prop.key;\n-          assign.right = this$1.parseMaybeAssign();\n-          prop.value = this$1.finishNode(assign, \"AssignmentExpression\");\n-        } else {\n-          prop.value = prop.key;\n-        }\n-      } else {\n-        prop.value = this$1.dummyIdent();\n-      }\n-      prop.shorthand = true;\n-    }\n-    node.properties.push(this$1.finishNode(prop, \"Property\"));\n-    this$1.eat(__acorn.tokTypes.comma);\n-  }\n-  this.popCx();\n-  if (!this.eat(__acorn.tokTypes.braceR)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  return this.finishNode(node, \"ObjectExpression\")\n-};\n-\n-lp$2.parsePropertyName = function(prop) {\n-  if (this.options.ecmaVersion >= 6) {\n-    if (this.eat(__acorn.tokTypes.bracketL)) {\n-      prop.computed = true;\n-      prop.key = this.parseExpression();\n-      this.expect(__acorn.tokTypes.bracketR);\n-      return\n-    } else {\n-      prop.computed = false;\n-    }\n-  }\n-  var key = (this.tok.type === __acorn.tokTypes.num || this.tok.type === __acorn.tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n-  prop.key = key || this.dummyIdent();\n-};\n-\n-lp$2.parsePropertyAccessor = function() {\n-  if (this.tok.type === __acorn.tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n-};\n-\n-lp$2.parseIdent = function() {\n-  var name = this.tok.type === __acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword;\n-  if (!name) { return this.dummyIdent() }\n-  var node = this.startNode();\n-  this.next();\n-  node.name = name;\n-  return this.finishNode(node, \"Identifier\")\n-};\n-\n-lp$2.initFunction = function(node) {\n-  node.id = null;\n-  node.params = [];\n-  if (this.options.ecmaVersion >= 6) {\n-    node.generator = false;\n-    node.expression = false;\n-  }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = false; }\n-};\n-\n-// Convert existing expression atom to assignable pattern\n-// if possible.\n-\n-lp$2.toAssignable = function(node, binding) {\n-  var this$1 = this;\n-\n-  if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) {\n-    // Okay\n-  } else if (node.type === \"ParenthesizedExpression\") {\n-    this.toAssignable(node.expression, binding);\n-  } else if (this.options.ecmaVersion < 6) {\n-    return this.dummyIdent()\n-  } else if (node.type === \"ObjectExpression\") {\n-    node.type = \"ObjectPattern\";\n-    for (var i = 0, list = node.properties; i < list.length; i += 1)\n-      {\n-      var prop = list[i];\n-\n-      this$1.toAssignable(prop, binding);\n-    }\n-  } else if (node.type === \"ArrayExpression\") {\n-    node.type = \"ArrayPattern\";\n-    this.toAssignableList(node.elements, binding);\n-  } else if (node.type === \"Property\") {\n-    this.toAssignable(node.value, binding);\n-  } else if (node.type === \"SpreadElement\") {\n-    node.type = \"RestElement\";\n-    this.toAssignable(node.argument, binding);\n-  } else if (node.type === \"AssignmentExpression\") {\n-    node.type = \"AssignmentPattern\";\n-    delete node.operator;\n-  } else {\n-    return this.dummyIdent()\n-  }\n-  return node\n-};\n-\n-lp$2.toAssignableList = function(exprList, binding) {\n-  var this$1 = this;\n-\n-  for (var i = 0, list = exprList; i < list.length; i += 1)\n-    {\n-    var expr = list[i];\n-\n-    this$1.toAssignable(expr, binding);\n-  }\n-  return exprList\n-};\n-\n-lp$2.parseFunctionParams = function(params) {\n-  params = this.parseExprList(__acorn.tokTypes.parenR);\n-  return this.toAssignableList(params, true)\n-};\n-\n-lp$2.parseMethod = function(isGenerator, isAsync) {\n-  var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 6)\n-    { node.generator = !!isGenerator; }\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.parseFunctionParams();\n-  node.body = this.parseBlock();\n-  this.toks.adaptDirectivePrologue(node.body.body);\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, \"FunctionExpression\")\n-};\n-\n-lp$2.parseArrowExpression = function(node, params, isAsync) {\n-  var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n-  this.initFunction(node);\n-  if (this.options.ecmaVersion >= 8)\n-    { node.async = !!isAsync; }\n-  this.inAsync = node.async;\n-  this.inFunction = true;\n-  node.params = this.toAssignableList(params, true);\n-  node.expression = this.tok.type !== __acorn.tokTypes.braceL;\n-  if (node.expression) {\n-    node.body = this.parseMaybeAssign();\n-  } else {\n-    node.body = this.parseBlock();\n-    this.toks.adaptDirectivePrologue(node.body.body);\n-  }\n-  this.inAsync = oldInAsync;\n-  this.inFunction = oldInFunction;\n-  return this.finishNode(node, \"ArrowFunctionExpression\")\n-};\n-\n-lp$2.parseExprList = function(close, allowEmpty) {\n-  var this$1 = this;\n-\n-  this.pushCx();\n-  var indent = this.curIndent, line = this.curLineStart, elts = [];\n-  this.next(); // Opening bracket\n-  while (!this.closes(close, indent + 1, line)) {\n-    if (this$1.eat(__acorn.tokTypes.comma)) {\n-      elts.push(allowEmpty ? null : this$1.dummyIdent());\n-      continue\n-    }\n-    var elt = this$1.parseMaybeAssign();\n-    if (isDummy(elt)) {\n-      if (this$1.closes(close, indent, line)) { break }\n-      this$1.next();\n-    } else {\n-      elts.push(elt);\n-    }\n-    this$1.eat(__acorn.tokTypes.comma);\n-  }\n-  this.popCx();\n-  if (!this.eat(close)) {\n-    // If there is no closing brace, make the node span to the start\n-    // of the next token (this is useful for Tern)\n-    this.last.end = this.tok.start;\n-    if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n-  }\n-  return elts\n-};\n-\n-lp$2.parseAwait = function() {\n-  var node = this.startNode();\n-  this.next();\n-  node.argument = this.parseMaybeUnary();\n-  return this.finishNode(node, \"AwaitExpression\")\n-};\n-\n-// Acorn: Loose parser\n-//\n-// This module provides an alternative parser (`parse_dammit`) that\n-// exposes that same interface as `parse`, but will try to parse\n-// anything as JavaScript, repairing syntax error the best it can.\n-// There are circumstances in which it will raise an error and give\n-// up, but they are very rare. The resulting AST will be a mostly\n-// valid JavaScript AST (as per the [Mozilla parser API][api], except\n-// that:\n-//\n-// - Return outside functions is allowed\n-//\n-// - Label consistency (no conflicts, break only to existing labels)\n-//   is not enforced.\n-//\n-// - Bogus Identifier nodes with a name of `\"✖\"` are inserted whenever\n-//   the parser got too confused to return anything meaningful.\n-//\n-// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n-//\n-// The expected use for this is to *first* try `acorn.parse`, and only\n-// if that fails switch to `parse_dammit`. The loose parser might\n-// parse badly indented code incorrectly, so **don't** use it as\n-// your default parser.\n-//\n-// Quite a lot of acorn.js is duplicated here. The alternative was to\n-// add a *lot* of extra cruft to that file, making it less readable\n-// and slower. Copying and editing the code allowed me to make\n-// invasive changes and simplifications without creating a complicated\n-// tangle.\n-\n-__acorn.defaultOptions.tabSize = 4;\n-\n-// eslint-disable-next-line camelcase\n-function parse_dammit(input, options) {\n-  return new LooseParser(input, options).parse()\n-}\n-\n-__acorn.addLooseExports(parse_dammit, LooseParser, pluginsLoose);\n-\n-exports.parse_dammit = parse_dammit;\n-exports.LooseParser = LooseParser;\n-exports.pluginsLoose = pluginsLoose;\n-\n-Object.defineProperty(exports, '__esModule', { value: true });\n-\n-})));"
        },
        {
            "sha": "f8961ce87eacc7fbd4470c4bcb1e3c58ba025945",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/bin.js",
            "status": "renamed",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Fbin.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Fbin.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Fbin.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -1,9 +1,8 @@\n-#!/usr/bin/env node\n 'use strict';\n \n var path = require('path');\n var fs = require('fs');\n-var acorn = require('../dist/acorn.js');\n+var acorn = require('./acorn.js');\n \n var infile;\n var forceFile;",
            "previous_filename": "tools/node_modules/eslint/node_modules/acorn/bin/_acorn.js"
        },
        {
            "sha": "faa2f0012d3b2a73510b2dd931d7fddf711b87bc",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/walk.es.js",
            "status": "removed",
            "additions": 0,
            "deletions": 423,
            "changes": 423,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Fwalk.es.js",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Fwalk.es.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Fwalk.es.js?ref=9697c0820f015ccf898a3662305a0caa3cd9c208",
            "patch": "@@ -1,423 +0,0 @@\n-// AST walker module for Mozilla Parser API compatible trees\n-\n-// A simple walk is one where you simply specify callbacks to be\n-// called on specific nodes. The last two arguments are optional. A\n-// simple use would be\n-//\n-//     walk.simple(myTree, {\n-//         Expression: function(node) { ... }\n-//     });\n-//\n-// to do something with all expressions. All Parser API node types\n-// can be used to identify node types, as well as Expression,\n-// Statement, and ScopeBody, which denote categories of nodes.\n-//\n-// The base argument can be used to pass a custom (recursive)\n-// walker, and state can be used to give this walked an initial\n-// state.\n-\n-function simple(node, visitors, baseVisitor, state, override) {\n-  if (!baseVisitor) { baseVisitor = base\n-  ; }(function c(node, st, override) {\n-    var type = override || node.type, found = visitors[type];\n-    baseVisitor[type](node, st, c);\n-    if (found) { found(node, st); }\n-  })(node, state, override);\n-}\n-\n-// An ancestor walk keeps an array of ancestor nodes (including the\n-// current node) and passes them to the callback as third parameter\n-// (and also as state parameter when no other state is present).\n-function ancestor(node, visitors, baseVisitor, state) {\n-  var ancestors = [];\n-  if (!baseVisitor) { baseVisitor = base\n-  ; }(function c(node, st, override) {\n-    var type = override || node.type, found = visitors[type];\n-    var isNew = node !== ancestors[ancestors.length - 1];\n-    if (isNew) { ancestors.push(node); }\n-    baseVisitor[type](node, st, c);\n-    if (found) { found(node, st || ancestors, ancestors); }\n-    if (isNew) { ancestors.pop(); }\n-  })(node, state);\n-}\n-\n-// A recursive walk is one where your functions override the default\n-// walkers. They can modify and replace the state parameter that's\n-// threaded through the walk, and can opt how and whether to walk\n-// their child nodes (by calling their third argument on these\n-// nodes).\n-function recursive(node, state, funcs, baseVisitor, override) {\n-  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;(function c(node, st, override) {\n-    visitor[override || node.type](node, st, c);\n-  })(node, state, override);\n-}\n-\n-function makeTest(test) {\n-  if (typeof test === \"string\")\n-    { return function (type) { return type === test; } }\n-  else if (!test)\n-    { return function () { return true; } }\n-  else\n-    { return test }\n-}\n-\n-var Found = function Found(node, state) { this.node = node; this.state = state; };\n-\n-// A full walk triggers the callback on each node\n-function full(node, callback, baseVisitor, state, override) {\n-  if (!baseVisitor) { baseVisitor = base\n-  ; }(function c(node, st, override) {\n-    var type = override || node.type;\n-    baseVisitor[type](node, st, c);\n-    if (!override) { callback(node, st, type); }\n-  })(node, state, override);\n-}\n-\n-// An fullAncestor walk is like an ancestor walk, but triggers\n-// the callback on each node\n-function fullAncestor(node, callback, baseVisitor, state) {\n-  if (!baseVisitor) { baseVisitor = base; }\n-  var ancestors = [];(function c(node, st, override) {\n-    var type = override || node.type;\n-    var isNew = node !== ancestors[ancestors.length - 1];\n-    if (isNew) { ancestors.push(node); }\n-    baseVisitor[type](node, st, c);\n-    if (!override) { callback(node, st || ancestors, ancestors, type); }\n-    if (isNew) { ancestors.pop(); }\n-  })(node, state);\n-}\n-\n-// Find a node with a given start, end, and type (all are optional,\n-// null can be used as wildcard). Returns a {node, state} object, or\n-// undefined when it doesn't find a matching node.\n-function findNodeAt(node, start, end, test, baseVisitor, state) {\n-  if (!baseVisitor) { baseVisitor = base; }\n-  test = makeTest(test);\n-  try {\n-    (function c(node, st, override) {\n-      var type = override || node.type;\n-      if ((start == null || node.start <= start) &&\n-          (end == null || node.end >= end))\n-        { baseVisitor[type](node, st, c); }\n-      if ((start == null || node.start === start) &&\n-          (end == null || node.end === end) &&\n-          test(type, node))\n-        { throw new Found(node, st) }\n-    })(node, state);\n-  } catch (e) {\n-    if (e instanceof Found) { return e }\n-    throw e\n-  }\n-}\n-\n-// Find the innermost node of a given type that contains the given\n-// position. Interface similar to findNodeAt.\n-function findNodeAround(node, pos, test, baseVisitor, state) {\n-  test = makeTest(test);\n-  if (!baseVisitor) { baseVisitor = base; }\n-  try {\n-    (function c(node, st, override) {\n-      var type = override || node.type;\n-      if (node.start > pos || node.end < pos) { return }\n-      baseVisitor[type](node, st, c);\n-      if (test(type, node)) { throw new Found(node, st) }\n-    })(node, state);\n-  } catch (e) {\n-    if (e instanceof Found) { return e }\n-    throw e\n-  }\n-}\n-\n-// Find the outermost matching node after a given position.\n-function findNodeAfter(node, pos, test, baseVisitor, state) {\n-  test = makeTest(test);\n-  if (!baseVisitor) { baseVisitor = base; }\n-  try {\n-    (function c(node, st, override) {\n-      if (node.end < pos) { return }\n-      var type = override || node.type;\n-      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n-      baseVisitor[type](node, st, c);\n-    })(node, state);\n-  } catch (e) {\n-    if (e instanceof Found) { return e }\n-    throw e\n-  }\n-}\n-\n-// Find the outermost matching node before a given position.\n-function findNodeBefore(node, pos, test, baseVisitor, state) {\n-  test = makeTest(test);\n-  if (!baseVisitor) { baseVisitor = base; }\n-  var max;(function c(node, st, override) {\n-    if (node.start > pos) { return }\n-    var type = override || node.type;\n-    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n-      { max = new Found(node, st); }\n-    baseVisitor[type](node, st, c);\n-  })(node, state);\n-  return max\n-}\n-\n-// Fallback to an Object.create polyfill for older environments.\n-var create = Object.create || function(proto) {\n-  function Ctor() {}\n-  Ctor.prototype = proto;\n-  return new Ctor\n-};\n-\n-// Used to create a custom walker. Will fill in all missing node\n-// type properties with the defaults.\n-function make(funcs, baseVisitor) {\n-  var visitor = create(baseVisitor || base);\n-  for (var type in funcs) { visitor[type] = funcs[type]; }\n-  return visitor\n-}\n-\n-function skipThrough(node, st, c) { c(node, st); }\n-function ignore(_node, _st, _c) {}\n-\n-// Node walkers.\n-\n-var base = {};\n-\n-base.Program = base.BlockStatement = function (node, st, c) {\n-  for (var i = 0, list = node.body; i < list.length; i += 1)\n-    {\n-    var stmt = list[i];\n-\n-    c(stmt, st, \"Statement\");\n-  }\n-};\n-base.Statement = skipThrough;\n-base.EmptyStatement = ignore;\n-base.ExpressionStatement = base.ParenthesizedExpression =\n-  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\n-base.IfStatement = function (node, st, c) {\n-  c(node.test, st, \"Expression\");\n-  c(node.consequent, st, \"Statement\");\n-  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n-};\n-base.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\n-base.BreakStatement = base.ContinueStatement = ignore;\n-base.WithStatement = function (node, st, c) {\n-  c(node.object, st, \"Expression\");\n-  c(node.body, st, \"Statement\");\n-};\n-base.SwitchStatement = function (node, st, c) {\n-  c(node.discriminant, st, \"Expression\");\n-  for (var i = 0, list = node.cases; i < list.length; i += 1) {\n-    var cs = list[i];\n-\n-    if (cs.test) { c(cs.test, st, \"Expression\"); }\n-    for (var i$1 = 0, list$1 = cs.consequent; i$1 < list$1.length; i$1 += 1)\n-      {\n-      var cons = list$1[i$1];\n-\n-      c(cons, st, \"Statement\");\n-    }\n-  }\n-};\n-base.SwitchCase = function (node, st, c) {\n-  if (node.test) { c(node.test, st, \"Expression\"); }\n-  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n-    {\n-    var cons = list[i];\n-\n-    c(cons, st, \"Statement\");\n-  }\n-};\n-base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n-  if (node.argument) { c(node.argument, st, \"Expression\"); }\n-};\n-base.ThrowStatement = base.SpreadElement =\n-  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\n-base.TryStatement = function (node, st, c) {\n-  c(node.block, st, \"Statement\");\n-  if (node.handler) { c(node.handler, st); }\n-  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n-};\n-base.CatchClause = function (node, st, c) {\n-  if (node.param) { c(node.param, st, \"Pattern\"); }\n-  c(node.body, st, \"ScopeBody\");\n-};\n-base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n-  c(node.test, st, \"Expression\");\n-  c(node.body, st, \"Statement\");\n-};\n-base.ForStatement = function (node, st, c) {\n-  if (node.init) { c(node.init, st, \"ForInit\"); }\n-  if (node.test) { c(node.test, st, \"Expression\"); }\n-  if (node.update) { c(node.update, st, \"Expression\"); }\n-  c(node.body, st, \"Statement\");\n-};\n-base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n-  c(node.left, st, \"ForInit\");\n-  c(node.right, st, \"Expression\");\n-  c(node.body, st, \"Statement\");\n-};\n-base.ForInit = function (node, st, c) {\n-  if (node.type === \"VariableDeclaration\") { c(node, st); }\n-  else { c(node, st, \"Expression\"); }\n-};\n-base.DebuggerStatement = ignore;\n-\n-base.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\n-base.VariableDeclaration = function (node, st, c) {\n-  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n-    {\n-    var decl = list[i];\n-\n-    c(decl, st);\n-  }\n-};\n-base.VariableDeclarator = function (node, st, c) {\n-  c(node.id, st, \"Pattern\");\n-  if (node.init) { c(node.init, st, \"Expression\"); }\n-};\n-\n-base.Function = function (node, st, c) {\n-  if (node.id) { c(node.id, st, \"Pattern\"); }\n-  for (var i = 0, list = node.params; i < list.length; i += 1)\n-    {\n-    var param = list[i];\n-\n-    c(param, st, \"Pattern\");\n-  }\n-  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\");\n-};\n-// FIXME drop these node types in next major version\n-// (They are awkward, and in ES6 every block can be a scope.)\n-base.ScopeBody = function (node, st, c) { return c(node, st, \"Statement\"); };\n-base.ScopeExpression = function (node, st, c) { return c(node, st, \"Expression\"); };\n-\n-base.Pattern = function (node, st, c) {\n-  if (node.type === \"Identifier\")\n-    { c(node, st, \"VariablePattern\"); }\n-  else if (node.type === \"MemberExpression\")\n-    { c(node, st, \"MemberPattern\"); }\n-  else\n-    { c(node, st); }\n-};\n-base.VariablePattern = ignore;\n-base.MemberPattern = skipThrough;\n-base.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\n-base.ArrayPattern = function (node, st, c) {\n-  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n-    var elt = list[i];\n-\n-    if (elt) { c(elt, st, \"Pattern\"); }\n-  }\n-};\n-base.ObjectPattern = function (node, st, c) {\n-  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n-    var prop = list[i];\n-\n-    if (prop.type === \"Property\") {\n-      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n-      c(prop.value, st, \"Pattern\");\n-    } else if (prop.type === \"RestElement\") {\n-      c(prop.argument, st, \"Pattern\");\n-    }\n-  }\n-};\n-\n-base.Expression = skipThrough;\n-base.ThisExpression = base.Super = base.MetaProperty = ignore;\n-base.ArrayExpression = function (node, st, c) {\n-  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n-    var elt = list[i];\n-\n-    if (elt) { c(elt, st, \"Expression\"); }\n-  }\n-};\n-base.ObjectExpression = function (node, st, c) {\n-  for (var i = 0, list = node.properties; i < list.length; i += 1)\n-    {\n-    var prop = list[i];\n-\n-    c(prop, st);\n-  }\n-};\n-base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n-base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n-  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n-    {\n-    var expr = list[i];\n-\n-    c(expr, st, \"Expression\");\n-  }\n-};\n-base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n-  c(node.argument, st, \"Expression\");\n-};\n-base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n-  c(node.left, st, \"Expression\");\n-  c(node.right, st, \"Expression\");\n-};\n-base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n-  c(node.left, st, \"Pattern\");\n-  c(node.right, st, \"Expression\");\n-};\n-base.ConditionalExpression = function (node, st, c) {\n-  c(node.test, st, \"Expression\");\n-  c(node.consequent, st, \"Expression\");\n-  c(node.alternate, st, \"Expression\");\n-};\n-base.NewExpression = base.CallExpression = function (node, st, c) {\n-  c(node.callee, st, \"Expression\");\n-  if (node.arguments)\n-    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n-      {\n-        var arg = list[i];\n-\n-        c(arg, st, \"Expression\");\n-      } }\n-};\n-base.MemberExpression = function (node, st, c) {\n-  c(node.object, st, \"Expression\");\n-  if (node.computed) { c(node.property, st, \"Expression\"); }\n-};\n-base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n-  if (node.declaration)\n-    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n-  if (node.source) { c(node.source, st, \"Expression\"); }\n-};\n-base.ExportAllDeclaration = function (node, st, c) {\n-  c(node.source, st, \"Expression\");\n-};\n-base.ImportDeclaration = function (node, st, c) {\n-  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n-    {\n-    var spec = list[i];\n-\n-    c(spec, st);\n-  }\n-  c(node.source, st, \"Expression\");\n-};\n-base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n-\n-base.TaggedTemplateExpression = function (node, st, c) {\n-  c(node.tag, st, \"Expression\");\n-  c(node.quasi, st, \"Expression\");\n-};\n-base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\n-base.Class = function (node, st, c) {\n-  if (node.id) { c(node.id, st, \"Pattern\"); }\n-  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n-  c(node.body, st);\n-};\n-base.ClassBody = function (node, st, c) {\n-  for (var i = 0, list = node.body; i < list.length; i += 1)\n-    {\n-    var elt = list[i];\n-\n-    c(elt, st);\n-  }\n-};\n-base.MethodDefinition = base.Property = function (node, st, c) {\n-  if (node.computed) { c(node.key, st, \"Expression\"); }\n-  c(node.value, st, \"Expression\");\n-};\n-\n-export { simple, ancestor, recursive, full, fullAncestor, findNodeAt, findNodeAround, findNodeAfter, findNodeBefore, make, base };"
        },
        {
            "sha": "4f6cb415f0e9518e7ae9951a2609a6746ced9fb0",
            "filename": "tools/node_modules/eslint/node_modules/acorn/dist/walk.js",
            "status": "removed",
            "additions": 0,
            "deletions": 443,
            "changes": 443,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Fwalk.js",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Fwalk.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fdist%2Fwalk.js?ref=9697c0820f015ccf898a3662305a0caa3cd9c208",
            "patch": "@@ -1,443 +0,0 @@\n-(function (global, factory) {\n-\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n-\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n-\t(factory((global.acorn = global.acorn || {}, global.acorn.walk = {})));\n-}(this, (function (exports) { 'use strict';\n-\n-// AST walker module for Mozilla Parser API compatible trees\n-\n-// A simple walk is one where you simply specify callbacks to be\n-// called on specific nodes. The last two arguments are optional. A\n-// simple use would be\n-//\n-//     walk.simple(myTree, {\n-//         Expression: function(node) { ... }\n-//     });\n-//\n-// to do something with all expressions. All Parser API node types\n-// can be used to identify node types, as well as Expression,\n-// Statement, and ScopeBody, which denote categories of nodes.\n-//\n-// The base argument can be used to pass a custom (recursive)\n-// walker, and state can be used to give this walked an initial\n-// state.\n-\n-function simple(node, visitors, baseVisitor, state, override) {\n-  if (!baseVisitor) { baseVisitor = base\n-  ; }(function c(node, st, override) {\n-    var type = override || node.type, found = visitors[type];\n-    baseVisitor[type](node, st, c);\n-    if (found) { found(node, st); }\n-  })(node, state, override);\n-}\n-\n-// An ancestor walk keeps an array of ancestor nodes (including the\n-// current node) and passes them to the callback as third parameter\n-// (and also as state parameter when no other state is present).\n-function ancestor(node, visitors, baseVisitor, state) {\n-  var ancestors = [];\n-  if (!baseVisitor) { baseVisitor = base\n-  ; }(function c(node, st, override) {\n-    var type = override || node.type, found = visitors[type];\n-    var isNew = node !== ancestors[ancestors.length - 1];\n-    if (isNew) { ancestors.push(node); }\n-    baseVisitor[type](node, st, c);\n-    if (found) { found(node, st || ancestors, ancestors); }\n-    if (isNew) { ancestors.pop(); }\n-  })(node, state);\n-}\n-\n-// A recursive walk is one where your functions override the default\n-// walkers. They can modify and replace the state parameter that's\n-// threaded through the walk, and can opt how and whether to walk\n-// their child nodes (by calling their third argument on these\n-// nodes).\n-function recursive(node, state, funcs, baseVisitor, override) {\n-  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;(function c(node, st, override) {\n-    visitor[override || node.type](node, st, c);\n-  })(node, state, override);\n-}\n-\n-function makeTest(test) {\n-  if (typeof test === \"string\")\n-    { return function (type) { return type === test; } }\n-  else if (!test)\n-    { return function () { return true; } }\n-  else\n-    { return test }\n-}\n-\n-var Found = function Found(node, state) { this.node = node; this.state = state; };\n-\n-// A full walk triggers the callback on each node\n-function full(node, callback, baseVisitor, state, override) {\n-  if (!baseVisitor) { baseVisitor = base\n-  ; }(function c(node, st, override) {\n-    var type = override || node.type;\n-    baseVisitor[type](node, st, c);\n-    if (!override) { callback(node, st, type); }\n-  })(node, state, override);\n-}\n-\n-// An fullAncestor walk is like an ancestor walk, but triggers\n-// the callback on each node\n-function fullAncestor(node, callback, baseVisitor, state) {\n-  if (!baseVisitor) { baseVisitor = base; }\n-  var ancestors = [];(function c(node, st, override) {\n-    var type = override || node.type;\n-    var isNew = node !== ancestors[ancestors.length - 1];\n-    if (isNew) { ancestors.push(node); }\n-    baseVisitor[type](node, st, c);\n-    if (!override) { callback(node, st || ancestors, ancestors, type); }\n-    if (isNew) { ancestors.pop(); }\n-  })(node, state);\n-}\n-\n-// Find a node with a given start, end, and type (all are optional,\n-// null can be used as wildcard). Returns a {node, state} object, or\n-// undefined when it doesn't find a matching node.\n-function findNodeAt(node, start, end, test, baseVisitor, state) {\n-  if (!baseVisitor) { baseVisitor = base; }\n-  test = makeTest(test);\n-  try {\n-    (function c(node, st, override) {\n-      var type = override || node.type;\n-      if ((start == null || node.start <= start) &&\n-          (end == null || node.end >= end))\n-        { baseVisitor[type](node, st, c); }\n-      if ((start == null || node.start === start) &&\n-          (end == null || node.end === end) &&\n-          test(type, node))\n-        { throw new Found(node, st) }\n-    })(node, state);\n-  } catch (e) {\n-    if (e instanceof Found) { return e }\n-    throw e\n-  }\n-}\n-\n-// Find the innermost node of a given type that contains the given\n-// position. Interface similar to findNodeAt.\n-function findNodeAround(node, pos, test, baseVisitor, state) {\n-  test = makeTest(test);\n-  if (!baseVisitor) { baseVisitor = base; }\n-  try {\n-    (function c(node, st, override) {\n-      var type = override || node.type;\n-      if (node.start > pos || node.end < pos) { return }\n-      baseVisitor[type](node, st, c);\n-      if (test(type, node)) { throw new Found(node, st) }\n-    })(node, state);\n-  } catch (e) {\n-    if (e instanceof Found) { return e }\n-    throw e\n-  }\n-}\n-\n-// Find the outermost matching node after a given position.\n-function findNodeAfter(node, pos, test, baseVisitor, state) {\n-  test = makeTest(test);\n-  if (!baseVisitor) { baseVisitor = base; }\n-  try {\n-    (function c(node, st, override) {\n-      if (node.end < pos) { return }\n-      var type = override || node.type;\n-      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n-      baseVisitor[type](node, st, c);\n-    })(node, state);\n-  } catch (e) {\n-    if (e instanceof Found) { return e }\n-    throw e\n-  }\n-}\n-\n-// Find the outermost matching node before a given position.\n-function findNodeBefore(node, pos, test, baseVisitor, state) {\n-  test = makeTest(test);\n-  if (!baseVisitor) { baseVisitor = base; }\n-  var max;(function c(node, st, override) {\n-    if (node.start > pos) { return }\n-    var type = override || node.type;\n-    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n-      { max = new Found(node, st); }\n-    baseVisitor[type](node, st, c);\n-  })(node, state);\n-  return max\n-}\n-\n-// Fallback to an Object.create polyfill for older environments.\n-var create = Object.create || function(proto) {\n-  function Ctor() {}\n-  Ctor.prototype = proto;\n-  return new Ctor\n-};\n-\n-// Used to create a custom walker. Will fill in all missing node\n-// type properties with the defaults.\n-function make(funcs, baseVisitor) {\n-  var visitor = create(baseVisitor || base);\n-  for (var type in funcs) { visitor[type] = funcs[type]; }\n-  return visitor\n-}\n-\n-function skipThrough(node, st, c) { c(node, st); }\n-function ignore(_node, _st, _c) {}\n-\n-// Node walkers.\n-\n-var base = {};\n-\n-base.Program = base.BlockStatement = function (node, st, c) {\n-  for (var i = 0, list = node.body; i < list.length; i += 1)\n-    {\n-    var stmt = list[i];\n-\n-    c(stmt, st, \"Statement\");\n-  }\n-};\n-base.Statement = skipThrough;\n-base.EmptyStatement = ignore;\n-base.ExpressionStatement = base.ParenthesizedExpression =\n-  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\n-base.IfStatement = function (node, st, c) {\n-  c(node.test, st, \"Expression\");\n-  c(node.consequent, st, \"Statement\");\n-  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n-};\n-base.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\n-base.BreakStatement = base.ContinueStatement = ignore;\n-base.WithStatement = function (node, st, c) {\n-  c(node.object, st, \"Expression\");\n-  c(node.body, st, \"Statement\");\n-};\n-base.SwitchStatement = function (node, st, c) {\n-  c(node.discriminant, st, \"Expression\");\n-  for (var i = 0, list = node.cases; i < list.length; i += 1) {\n-    var cs = list[i];\n-\n-    if (cs.test) { c(cs.test, st, \"Expression\"); }\n-    for (var i$1 = 0, list$1 = cs.consequent; i$1 < list$1.length; i$1 += 1)\n-      {\n-      var cons = list$1[i$1];\n-\n-      c(cons, st, \"Statement\");\n-    }\n-  }\n-};\n-base.SwitchCase = function (node, st, c) {\n-  if (node.test) { c(node.test, st, \"Expression\"); }\n-  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n-    {\n-    var cons = list[i];\n-\n-    c(cons, st, \"Statement\");\n-  }\n-};\n-base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n-  if (node.argument) { c(node.argument, st, \"Expression\"); }\n-};\n-base.ThrowStatement = base.SpreadElement =\n-  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\n-base.TryStatement = function (node, st, c) {\n-  c(node.block, st, \"Statement\");\n-  if (node.handler) { c(node.handler, st); }\n-  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n-};\n-base.CatchClause = function (node, st, c) {\n-  if (node.param) { c(node.param, st, \"Pattern\"); }\n-  c(node.body, st, \"ScopeBody\");\n-};\n-base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n-  c(node.test, st, \"Expression\");\n-  c(node.body, st, \"Statement\");\n-};\n-base.ForStatement = function (node, st, c) {\n-  if (node.init) { c(node.init, st, \"ForInit\"); }\n-  if (node.test) { c(node.test, st, \"Expression\"); }\n-  if (node.update) { c(node.update, st, \"Expression\"); }\n-  c(node.body, st, \"Statement\");\n-};\n-base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n-  c(node.left, st, \"ForInit\");\n-  c(node.right, st, \"Expression\");\n-  c(node.body, st, \"Statement\");\n-};\n-base.ForInit = function (node, st, c) {\n-  if (node.type === \"VariableDeclaration\") { c(node, st); }\n-  else { c(node, st, \"Expression\"); }\n-};\n-base.DebuggerStatement = ignore;\n-\n-base.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\n-base.VariableDeclaration = function (node, st, c) {\n-  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n-    {\n-    var decl = list[i];\n-\n-    c(decl, st);\n-  }\n-};\n-base.VariableDeclarator = function (node, st, c) {\n-  c(node.id, st, \"Pattern\");\n-  if (node.init) { c(node.init, st, \"Expression\"); }\n-};\n-\n-base.Function = function (node, st, c) {\n-  if (node.id) { c(node.id, st, \"Pattern\"); }\n-  for (var i = 0, list = node.params; i < list.length; i += 1)\n-    {\n-    var param = list[i];\n-\n-    c(param, st, \"Pattern\");\n-  }\n-  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\");\n-};\n-// FIXME drop these node types in next major version\n-// (They are awkward, and in ES6 every block can be a scope.)\n-base.ScopeBody = function (node, st, c) { return c(node, st, \"Statement\"); };\n-base.ScopeExpression = function (node, st, c) { return c(node, st, \"Expression\"); };\n-\n-base.Pattern = function (node, st, c) {\n-  if (node.type === \"Identifier\")\n-    { c(node, st, \"VariablePattern\"); }\n-  else if (node.type === \"MemberExpression\")\n-    { c(node, st, \"MemberPattern\"); }\n-  else\n-    { c(node, st); }\n-};\n-base.VariablePattern = ignore;\n-base.MemberPattern = skipThrough;\n-base.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\n-base.ArrayPattern = function (node, st, c) {\n-  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n-    var elt = list[i];\n-\n-    if (elt) { c(elt, st, \"Pattern\"); }\n-  }\n-};\n-base.ObjectPattern = function (node, st, c) {\n-  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n-    var prop = list[i];\n-\n-    if (prop.type === \"Property\") {\n-      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n-      c(prop.value, st, \"Pattern\");\n-    } else if (prop.type === \"RestElement\") {\n-      c(prop.argument, st, \"Pattern\");\n-    }\n-  }\n-};\n-\n-base.Expression = skipThrough;\n-base.ThisExpression = base.Super = base.MetaProperty = ignore;\n-base.ArrayExpression = function (node, st, c) {\n-  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n-    var elt = list[i];\n-\n-    if (elt) { c(elt, st, \"Expression\"); }\n-  }\n-};\n-base.ObjectExpression = function (node, st, c) {\n-  for (var i = 0, list = node.properties; i < list.length; i += 1)\n-    {\n-    var prop = list[i];\n-\n-    c(prop, st);\n-  }\n-};\n-base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n-base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n-  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n-    {\n-    var expr = list[i];\n-\n-    c(expr, st, \"Expression\");\n-  }\n-};\n-base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n-  c(node.argument, st, \"Expression\");\n-};\n-base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n-  c(node.left, st, \"Expression\");\n-  c(node.right, st, \"Expression\");\n-};\n-base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n-  c(node.left, st, \"Pattern\");\n-  c(node.right, st, \"Expression\");\n-};\n-base.ConditionalExpression = function (node, st, c) {\n-  c(node.test, st, \"Expression\");\n-  c(node.consequent, st, \"Expression\");\n-  c(node.alternate, st, \"Expression\");\n-};\n-base.NewExpression = base.CallExpression = function (node, st, c) {\n-  c(node.callee, st, \"Expression\");\n-  if (node.arguments)\n-    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n-      {\n-        var arg = list[i];\n-\n-        c(arg, st, \"Expression\");\n-      } }\n-};\n-base.MemberExpression = function (node, st, c) {\n-  c(node.object, st, \"Expression\");\n-  if (node.computed) { c(node.property, st, \"Expression\"); }\n-};\n-base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n-  if (node.declaration)\n-    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n-  if (node.source) { c(node.source, st, \"Expression\"); }\n-};\n-base.ExportAllDeclaration = function (node, st, c) {\n-  c(node.source, st, \"Expression\");\n-};\n-base.ImportDeclaration = function (node, st, c) {\n-  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n-    {\n-    var spec = list[i];\n-\n-    c(spec, st);\n-  }\n-  c(node.source, st, \"Expression\");\n-};\n-base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n-\n-base.TaggedTemplateExpression = function (node, st, c) {\n-  c(node.tag, st, \"Expression\");\n-  c(node.quasi, st, \"Expression\");\n-};\n-base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\n-base.Class = function (node, st, c) {\n-  if (node.id) { c(node.id, st, \"Pattern\"); }\n-  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n-  c(node.body, st);\n-};\n-base.ClassBody = function (node, st, c) {\n-  for (var i = 0, list = node.body; i < list.length; i += 1)\n-    {\n-    var elt = list[i];\n-\n-    c(elt, st);\n-  }\n-};\n-base.MethodDefinition = base.Property = function (node, st, c) {\n-  if (node.computed) { c(node.key, st, \"Expression\"); }\n-  c(node.value, st, \"Expression\");\n-};\n-\n-exports.simple = simple;\n-exports.ancestor = ancestor;\n-exports.recursive = recursive;\n-exports.full = full;\n-exports.fullAncestor = fullAncestor;\n-exports.findNodeAt = findNodeAt;\n-exports.findNodeAround = findNodeAround;\n-exports.findNodeAfter = findNodeAfter;\n-exports.findNodeBefore = findNodeBefore;\n-exports.make = make;\n-exports.base = base;\n-\n-Object.defineProperty(exports, '__esModule', { value: true });\n-\n-})));"
        },
        {
            "sha": "62f34134c0e708c3c6b372ead9b7a8525bc68e2f",
            "filename": "tools/node_modules/eslint/node_modules/acorn/package.json",
            "status": "modified",
            "additions": 6,
            "deletions": 264,
            "changes": 270,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fpackage.json",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Facorn%2Fpackage.json?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -6,257 +6,8 @@\n     \"url\": \"https://github.com/acornjs/acorn/issues\"\n   },\n   \"bundleDependencies\": false,\n-  \"contributors\": [\n-    {\n-      \"name\": \"List of Acorn contributors. Updated before every release.\"\n-    },\n-    {\n-      \"name\": \"Adrian Heine\"\n-    },\n-    {\n-      \"name\": \"Adrian Rakovsky\"\n-    },\n-    {\n-      \"name\": \"Alistair Braidwood\"\n-    },\n-    {\n-      \"name\": \"Amila Welihinda\"\n-    },\n-    {\n-      \"name\": \"Andres Suarez\"\n-    },\n-    {\n-      \"name\": \"Angelo\"\n-    },\n-    {\n-      \"name\": \"Aparajita Fishman\"\n-    },\n-    {\n-      \"name\": \"Arian Stolwijk\"\n-    },\n-    {\n-      \"name\": \"Artem Govorov\"\n-    },\n-    {\n-      \"name\": \"Boopesh Mahendran\"\n-    },\n-    {\n-      \"name\": \"Bradley Heinz\"\n-    },\n-    {\n-      \"name\": \"Brandon Mills\"\n-    },\n-    {\n-      \"name\": \"Charles Hughes\"\n-    },\n-    {\n-      \"name\": \"Charmander\"\n-    },\n-    {\n-      \"name\": \"Chris McKnight\"\n-    },\n-    {\n-      \"name\": \"Conrad Irwin\"\n-    },\n-    {\n-      \"name\": \"Daniel Tschinder\"\n-    },\n-    {\n-      \"name\": \"David Bonnet\"\n-    },\n-    {\n-      \"name\": \"Domenico Matteo\"\n-    },\n-    {\n-      \"name\": \"ehmicky\"\n-    },\n-    {\n-      \"name\": \"Eugene Obrezkov\"\n-    },\n-    {\n-      \"name\": \"Felix Maier\"\n-    },\n-    {\n-      \"name\": \"Forbes Lindesay\"\n-    },\n-    {\n-      \"name\": \"Gilad Peleg\"\n-    },\n-    {\n-      \"name\": \"impinball\"\n-    },\n-    {\n-      \"name\": \"Ingvar Stepanyan\"\n-    },\n-    {\n-      \"name\": \"Jackson Ray Hamilton\"\n-    },\n-    {\n-      \"name\": \"Jesse McCarthy\"\n-    },\n-    {\n-      \"name\": \"Jiaxing Wang\"\n-    },\n-    {\n-      \"name\": \"Joel Kemp\"\n-    },\n-    {\n-      \"name\": \"Johannes Herr\"\n-    },\n-    {\n-      \"name\": \"John-David Dalton\"\n-    },\n-    {\n-      \"name\": \"Jordan Klassen\"\n-    },\n-    {\n-      \"name\": \"Jürg Lehni\"\n-    },\n-    {\n-      \"name\": \"Kai Cataldo\"\n-    },\n-    {\n-      \"name\": \"keeyipchan\"\n-    },\n-    {\n-      \"name\": \"Keheliya Gallaba\"\n-    },\n-    {\n-      \"name\": \"Kevin Irish\"\n-    },\n-    {\n-      \"name\": \"Kevin Kwok\"\n-    },\n-    {\n-      \"name\": \"krator\"\n-    },\n-    {\n-      \"name\": \"laosb\"\n-    },\n-    {\n-      \"name\": \"luckyzeng\"\n-    },\n-    {\n-      \"name\": \"Marek\"\n-    },\n-    {\n-      \"name\": \"Marijn Haverbeke\"\n-    },\n-    {\n-      \"name\": \"Martin Carlberg\"\n-    },\n-    {\n-      \"name\": \"Mat Garcia\"\n-    },\n-    {\n-      \"name\": \"Mathias Bynens\"\n-    },\n-    {\n-      \"name\": \"Mathieu 'p01' Henri\"\n-    },\n-    {\n-      \"name\": \"Matthew Bastien\"\n-    },\n-    {\n-      \"name\": \"Max Schaefer\"\n-    },\n-    {\n-      \"name\": \"Max Zerzouri\"\n-    },\n-    {\n-      \"name\": \"Mihai Bazon\"\n-    },\n-    {\n-      \"name\": \"Mike Rennie\"\n-    },\n-    {\n-      \"name\": \"naoh\"\n-    },\n-    {\n-      \"name\": \"Nicholas C. Zakas\"\n-    },\n-    {\n-      \"name\": \"Nick Fitzgerald\"\n-    },\n-    {\n-      \"name\": \"Olivier Thomann\"\n-    },\n-    {\n-      \"name\": \"Oskar Schöldström\"\n-    },\n-    {\n-      \"name\": \"Paul Harper\"\n-    },\n-    {\n-      \"name\": \"Peter Rust\"\n-    },\n-    {\n-      \"name\": \"PlNG\"\n-    },\n-    {\n-      \"name\": \"Prayag Verma\"\n-    },\n-    {\n-      \"name\": \"ReadmeCritic\"\n-    },\n-    {\n-      \"name\": \"r-e-d\"\n-    },\n-    {\n-      \"name\": \"Renée Kooi\"\n-    },\n-    {\n-      \"name\": \"Richard Gibson\"\n-    },\n-    {\n-      \"name\": \"Rich Harris\"\n-    },\n-    {\n-      \"name\": \"Sebastian McKenzie\"\n-    },\n-    {\n-      \"name\": \"Shahar Soel\"\n-    },\n-    {\n-      \"name\": \"Sheel Bedi\"\n-    },\n-    {\n-      \"name\": \"Simen Bekkhus\"\n-    },\n-    {\n-      \"name\": \"Teddy Katz\"\n-    },\n-    {\n-      \"name\": \"Timothy Gu\"\n-    },\n-    {\n-      \"name\": \"Toru Nagashima\"\n-    },\n-    {\n-      \"name\": \"Victor Homyakov\"\n-    },\n-    {\n-      \"name\": \"Wexpo Lyu\"\n-    },\n-    {\n-      \"name\": \"zsjforcn\"\n-    }\n-  ],\n   \"deprecated\": false,\n   \"description\": \"ECMAScript parser\",\n-  \"devDependencies\": {\n-    \"eslint\": \"^4.10.0\",\n-    \"eslint-config-standard\": \"^10.2.1\",\n-    \"eslint-plugin-import\": \"^2.2.0\",\n-    \"eslint-plugin-node\": \"^5.2.1\",\n-    \"eslint-plugin-promise\": \"^3.5.0\",\n-    \"eslint-plugin-standard\": \"^3.0.1\",\n-    \"rollup\": \"^0.45.0\",\n-    \"rollup-plugin-buble\": \"^0.16.0\",\n-    \"test262\": \"git+https://github.com/tc39/test262.git#3bfad28cc302fd4455badcfcbca7c5bb7ce41a72\",\n-    \"test262-parser-runner\": \"^0.4.0\",\n-    \"unicode-11.0.0\": \"^0.7.7\"\n-  },\n   \"engines\": {\n     \"node\": \">=0.4.0\"\n   },\n@@ -267,35 +18,26 @@\n     {\n       \"name\": \"Marijn Haverbeke\",\n       \"email\": \"marijnh@gmail.com\",\n-      \"url\": \"http://marijnhaverbeke.nl\"\n+      \"url\": \"https://marijnhaverbeke.nl\"\n     },\n     {\n       \"name\": \"Ingvar Stepanyan\",\n       \"email\": \"me@rreverser.com\",\n-      \"url\": \"http://rreverser.com/\"\n+      \"url\": \"https://rreverser.com/\"\n     },\n     {\n       \"name\": \"Adrian Heine\",\n-      \"email\": \"http://adrianheine.de\"\n+      \"url\": \"http://adrianheine.de\"\n     }\n   ],\n-  \"module\": \"dist/acorn.es.js\",\n+  \"module\": \"dist/acorn.mjs\",\n   \"name\": \"acorn\",\n   \"repository\": {\n     \"type\": \"git\",\n     \"url\": \"git+https://github.com/acornjs/acorn.git\"\n   },\n   \"scripts\": {\n-    \"build\": \"npm run build:main && npm run build:walk && npm run build:loose && npm run build:bin\",\n-    \"build:bin\": \"rollup -c rollup/config.bin.js\",\n-    \"build:loose\": \"rollup -c rollup/config.loose.js && rollup -c rollup/config.loose_es.js\",\n-    \"build:main\": \"rollup -c rollup/config.main.js\",\n-    \"build:walk\": \"rollup -c rollup/config.walk.js\",\n-    \"lint\": \"eslint src/\",\n-    \"prepare\": \"npm run build && node test/run.js && node test/lint.js\",\n-    \"pretest\": \"npm run build:main && npm run build:loose\",\n-    \"test\": \"node test/run.js && node test/lint.js\",\n-    \"test:test262\": \"node bin/run_test262.js\"\n+    \"prepare\": \"cd ..; npm run build:main && npm run build:bin\"\n   },\n-  \"version\": \"5.7.3\"\n+  \"version\": \"6.0.2\"\n }\n\\ No newline at end of file"
        },
        {
            "sha": "16fb93f85607e2585b4a4297ffb0bf5fbe3fe823",
            "filename": "tools/node_modules/eslint/node_modules/espree/README.md",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2FREADME.md?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -150,8 +150,8 @@ There are seven ECMAScript 2018 syntax changes:\n * Async iteration\n * RegExp `s` flag\n * RegExp named capture groups\n-* RegExp lookhehind assersions\n-* RegExp unicode property escapes\n+* RegExp lookbehind assertions\n+* RegExp Unicode property escapes\n \n Espree supports all of them.\n "
        },
        {
            "sha": "dea35ef083db54fa180b19722beb6743e1f4fb96",
            "filename": "tools/node_modules/eslint/node_modules/espree/espree.js",
            "status": "modified",
            "additions": 39,
            "deletions": 526,
            "changes": 565,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Fespree.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Fespree.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Fespree.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -58,271 +58,38 @@\n \n \"use strict\";\n \n-var astNodeTypes = require(\"./lib/ast-node-types\"),\n-    commentAttachment = require(\"./lib/comment-attachment\"),\n-    TokenTranslator = require(\"./lib/token-translator\"),\n-    acornJSX = require(\"acorn-jsx/inject\"),\n-    rawAcorn = require(\"acorn\");\n-\n-\n-var acorn = acornJSX(rawAcorn);\n-var DEFAULT_ECMA_VERSION = 5;\n-var lookahead,\n-    extra,\n-    lastToken;\n-\n-/**\n- * Resets the extra object to its default.\n- * @returns {void}\n- * @private\n- */\n-function resetExtra() {\n-    extra = {\n-        tokens: null,\n-        range: false,\n-        loc: false,\n-        comment: false,\n-        comments: [],\n-        tolerant: false,\n-        errors: [],\n-        strict: false,\n-        ecmaFeatures: {},\n-        ecmaVersion: DEFAULT_ECMA_VERSION,\n-        isModule: false\n-    };\n-}\n-\n-\n-\n-var tt = acorn.tokTypes,\n-    getLineInfo = acorn.getLineInfo;\n-\n-// custom type for JSX attribute values\n-tt.jsxAttrValueToken = {};\n-\n-/**\n- * Normalize ECMAScript version from the initial config\n- * @param  {number} ecmaVersion ECMAScript version from the initial config\n- * @returns {number} normalized ECMAScript version\n- */\n-function normalizeEcmaVersion(ecmaVersion) {\n-    if (typeof ecmaVersion === \"number\") {\n-        var version = ecmaVersion;\n-\n-        // Calculate ECMAScript edition number from official year version starting with\n-        // ES2015, which corresponds with ES6 (or a difference of 2009).\n-        if (version >= 2015) {\n-            version -= 2009;\n-        }\n-\n-        switch (version) {\n-            case 3:\n-            case 5:\n-            case 6:\n-            case 7:\n-            case 8:\n-            case 9:\n-            case 10:\n-                return version;\n-\n-            default:\n-                throw new Error(\"Invalid ecmaVersion.\");\n-        }\n-    } else {\n-        return DEFAULT_ECMA_VERSION;\n-    }\n-}\n-\n-/**\n- * Determines if a node is valid given the set of ecmaFeatures.\n- * @param {ASTNode} node The node to check.\n- * @returns {boolean} True if the node is allowed, false if not.\n- * @private\n- */\n-function isValidNode(node) {\n-    switch (node.type) {\n-        case \"ImportDeclaration\":\n-        case \"ExportNamedDeclaration\":\n-        case \"ExportDefaultDeclaration\":\n-        case \"ExportAllDeclaration\":\n-            return extra.isModule;\n-\n-        default:\n-            return true;\n-    }\n-}\n-\n-/**\n- * Performs last-minute Esprima-specific compatibility checks and fixes.\n- * @param {ASTNode} result The node to check.\n- * @returns {ASTNode} The finished node.\n- * @private\n- * @this acorn.Parser\n- */\n-function esprimaFinishNode(result) {\n-    // ensure that parsed node was allowed through ecmaFeatures\n-    if (!isValidNode(result)) {\n-        this.unexpected(result.start);\n-    }\n-\n-    // Acorn doesn't count the opening and closing backticks as part of templates\n-    // so we have to adjust ranges/locations appropriately.\n-    if (result.type === \"TemplateElement\") {\n-\n-        // additional adjustment needed if ${ is the last token\n-        var terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === \"${\";\n-\n-        if (result.range) {\n-            result.range[0]--;\n-            result.range[1] += (terminalDollarBraceL ? 2 : 1);\n-        }\n-\n-        if (result.loc) {\n-            result.loc.start.column--;\n-            result.loc.end.column += (terminalDollarBraceL ? 2 : 1);\n-        }\n-    }\n-\n-    if (extra.attachComment) {\n-        commentAttachment.processComment(result);\n+const acorn = require(\"acorn\");\n+const jsx = require(\"acorn-jsx\");\n+const astNodeTypes = require(\"./lib/ast-node-types\");\n+const espree = require(\"./lib/espree\");\n+\n+// To initialize lazily.\n+const parsers = {\n+    _regular: null,\n+    _jsx: null,\n+\n+    get regular() {\n+        if (this._regular === null) {\n+            this._regular = acorn.Parser.extend(espree());\n+        }\n+        return this._regular;\n+    },\n+\n+    get jsx() {\n+        if (this._jsx === null) {\n+            this._jsx = acorn.Parser.extend(jsx(), espree());\n+        }\n+        return this._jsx;\n+    },\n+\n+    get(options) {\n+        const useJsx = Boolean(\n+            options &&\n+            options.ecmaFeatures &&\n+            options.ecmaFeatures.jsx\n+        );\n+        return useJsx ? this.jsx : this.regular;\n     }\n-\n-    if (result.type.indexOf(\"Function\") > -1 && !result.generator) {\n-        result.generator = false;\n-    }\n-\n-    return result;\n-}\n-\n-/**\n- * Determines if a token is valid given the set of ecmaFeatures.\n- * @param {acorn.Parser} parser The parser to check.\n- * @returns {boolean} True if the token is allowed, false if not.\n- * @private\n- */\n-function isValidToken(parser) {\n-    var ecma = extra.ecmaFeatures;\n-    var type = parser.type;\n-\n-    switch (type) {\n-        case tt.jsxName:\n-        case tt.jsxText:\n-        case tt.jsxTagStart:\n-        case tt.jsxTagEnd:\n-            return ecma.jsx;\n-\n-        // https://github.com/ternjs/acorn/issues/363\n-        case tt.regexp:\n-            if (extra.ecmaVersion < 6 && parser.value.flags && parser.value.flags.indexOf(\"y\") > -1) {\n-                return false;\n-            }\n-\n-            return true;\n-\n-        default:\n-            return true;\n-    }\n-}\n-\n-/**\n- * Injects esprimaFinishNode into the finishNode process.\n- * @param {Function} finishNode Original finishNode function.\n- * @returns {ASTNode} The finished node.\n- * @private\n- */\n-function wrapFinishNode(finishNode) {\n-    return /** @this acorn.Parser */ function(node, type, pos, loc) {\n-        var result = finishNode.call(this, node, type, pos, loc);\n-        return esprimaFinishNode.call(this, result);\n-    };\n-}\n-\n-acorn.plugins.espree = function(instance) {\n-\n-    instance.extend(\"finishNode\", wrapFinishNode);\n-\n-    instance.extend(\"finishNodeAt\", wrapFinishNode);\n-\n-    instance.extend(\"next\", function(next) {\n-        return /** @this acorn.Parser */ function() {\n-            if (!isValidToken(this)) {\n-                this.unexpected();\n-            }\n-            return next.call(this);\n-        };\n-    });\n-\n-    instance.extend(\"parseTopLevel\", function(parseTopLevel) {\n-        return /** @this acorn.Parser */ function(node) {\n-            if (extra.ecmaFeatures.impliedStrict && this.options.ecmaVersion >= 5) {\n-                this.strict = true;\n-            }\n-            return parseTopLevel.call(this, node);\n-        };\n-    });\n-\n-    /**\n-     * Overwrites the default raise method to throw Esprima-style errors.\n-     * @param {int} pos The position of the error.\n-     * @param {string} message The error message.\n-     * @throws {SyntaxError} A syntax error.\n-     * @returns {void}\n-     */\n-    instance.raise = instance.raiseRecoverable = function(pos, message) {\n-        var loc = getLineInfo(this.input, pos);\n-        var err = new SyntaxError(message);\n-        err.index = pos;\n-        err.lineNumber = loc.line;\n-        err.column = loc.column + 1; // acorn uses 0-based columns\n-        throw err;\n-    };\n-\n-    /**\n-     * Overwrites the default unexpected method to throw Esprima-style errors.\n-     * @param {int} pos The position of the error.\n-     * @throws {SyntaxError} A syntax error.\n-     * @returns {void}\n-     */\n-    instance.unexpected = function(pos) {\n-        var message = \"Unexpected token\";\n-\n-        if (pos !== null && pos !== undefined) {\n-            this.pos = pos;\n-\n-            if (this.options.locations) {\n-                while (this.pos < this.lineStart) {\n-                    this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n-                    --this.curLine;\n-                }\n-            }\n-\n-            this.nextToken();\n-        }\n-\n-        if (this.end > this.start) {\n-            message += \" \" + this.input.slice(this.start, this.end);\n-        }\n-\n-        this.raise(this.start, message);\n-    };\n-\n-    /*\n-    * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n-    * uses regular tt.string without any distinction between this and regular JS\n-    * strings. As such, we intercept an attempt to read a JSX string and set a flag\n-    * on extra so that when tokens are converted, the next token will be switched\n-    * to JSXText via onToken.\n-    */\n-    instance.extend(\"jsx_readString\", function(jsxReadString) {\n-        return /** @this acorn.Parser */ function(quote) {\n-            var result = jsxReadString.call(this, quote);\n-            if (this.type === tt.string) {\n-                extra.jsxAttrValueToken = true;\n-            }\n-\n-            return result;\n-        };\n-    });\n };\n \n //------------------------------------------------------------------------------\n@@ -338,266 +105,30 @@ acorn.plugins.espree = function(instance) {\n  * @private\n  */\n function tokenize(code, options) {\n-    var toString,\n-        tokens,\n-        impliedStrict,\n-        translator = new TokenTranslator(tt, code);\n+    const Parser = parsers.get(options);\n \n-    toString = String;\n-    if (typeof code !== \"string\" && !(code instanceof String)) {\n-        code = toString(code);\n+    // Ensure to collect tokens.\n+    if (!options || options.tokens !== true) {\n+        options = Object.assign({}, options, { tokens: true });\n     }\n \n-    lookahead = null;\n-\n-    // Options matching.\n-    options = Object.assign({}, options);\n-\n-    var acornOptions = {\n-        ecmaVersion: DEFAULT_ECMA_VERSION,\n-        plugins: {\n-            espree: true\n-        }\n-    };\n-\n-    resetExtra();\n-\n-    // Of course we collect tokens here.\n-    options.tokens = true;\n-    extra.tokens = [];\n-\n-    extra.range = (typeof options.range === \"boolean\") && options.range;\n-    acornOptions.ranges = extra.range;\n-\n-    extra.loc = (typeof options.loc === \"boolean\") && options.loc;\n-    acornOptions.locations = extra.loc;\n-\n-    extra.comment = typeof options.comment === \"boolean\" && options.comment;\n-\n-    if (extra.comment) {\n-        acornOptions.onComment = function() {\n-            var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);\n-            extra.comments.push(comment);\n-        };\n-    }\n-\n-    extra.tolerant = typeof options.tolerant === \"boolean\" && options.tolerant;\n-\n-    acornOptions.ecmaVersion = extra.ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);\n-\n-    // apply parsing flags\n-    if (options.ecmaFeatures && typeof options.ecmaFeatures === \"object\") {\n-        extra.ecmaFeatures = Object.assign({}, options.ecmaFeatures);\n-        impliedStrict = extra.ecmaFeatures.impliedStrict;\n-        extra.ecmaFeatures.impliedStrict = typeof impliedStrict === \"boolean\" && impliedStrict;\n-    }\n-\n-    try {\n-        var tokenizer = acorn.tokenizer(code, acornOptions);\n-        while ((lookahead = tokenizer.getToken()).type !== tt.eof) {\n-            translator.onToken(lookahead, extra);\n-        }\n-\n-        // filterTokenLocation();\n-        tokens = extra.tokens;\n-\n-        if (extra.comment) {\n-            tokens.comments = extra.comments;\n-        }\n-        if (extra.tolerant) {\n-            tokens.errors = extra.errors;\n-        }\n-    } catch (e) {\n-        throw e;\n-    }\n-    return tokens;\n+    return new Parser(options, code).tokenize();\n }\n \n //------------------------------------------------------------------------------\n // Parser\n //------------------------------------------------------------------------------\n \n-\n-\n-/**\n- * Converts an Acorn comment to a Esprima comment.\n- * @param {boolean} block True if it's a block comment, false if not.\n- * @param {string} text The text of the comment.\n- * @param {int} start The index at which the comment starts.\n- * @param {int} end The index at which the comment ends.\n- * @param {Location} startLoc The location at which the comment starts.\n- * @param {Location} endLoc The location at which the comment ends.\n- * @returns {Object} The comment object.\n- * @private\n- */\n-function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {\n-    var comment = {\n-        type: block ? \"Block\" : \"Line\",\n-        value: text\n-    };\n-\n-    if (typeof start === \"number\") {\n-        comment.start = start;\n-        comment.end = end;\n-        comment.range = [start, end];\n-    }\n-\n-    if (typeof startLoc === \"object\") {\n-        comment.loc = {\n-            start: startLoc,\n-            end: endLoc\n-        };\n-    }\n-\n-    return comment;\n-}\n-\n /**\n  * Parses the given code.\n  * @param {string} code The code to tokenize.\n  * @param {Object} options Options defining how to tokenize.\n  * @returns {ASTNode} The \"Program\" AST node.\n  * @throws {SyntaxError} If the input code is invalid.\n- * @private\n  */\n function parse(code, options) {\n-    var program,\n-        toString = String,\n-        translator,\n-        impliedStrict,\n-        acornOptions = {\n-            ecmaVersion: DEFAULT_ECMA_VERSION,\n-            plugins: {\n-                espree: true\n-            }\n-        };\n-\n-    lastToken = null;\n-\n-    if (typeof code !== \"string\" && !(code instanceof String)) {\n-        code = toString(code);\n-    }\n-\n-    resetExtra();\n-    commentAttachment.reset();\n-\n-    if (typeof options !== \"undefined\") {\n-        extra.range = (typeof options.range === \"boolean\") && options.range;\n-        extra.loc = (typeof options.loc === \"boolean\") && options.loc;\n-        extra.attachComment = (typeof options.attachComment === \"boolean\") && options.attachComment;\n-\n-        if (extra.loc && options.source !== null && options.source !== undefined) {\n-            extra.source = toString(options.source);\n-        }\n-\n-        if (typeof options.tokens === \"boolean\" && options.tokens) {\n-            extra.tokens = [];\n-            translator = new TokenTranslator(tt, code);\n-        }\n-        if (typeof options.comment === \"boolean\" && options.comment) {\n-            extra.comment = true;\n-            extra.comments = [];\n-        }\n-        if (typeof options.tolerant === \"boolean\" && options.tolerant) {\n-            extra.errors = [];\n-        }\n-        if (extra.attachComment) {\n-            extra.range = true;\n-            extra.comments = [];\n-            commentAttachment.reset();\n-        }\n-\n-        acornOptions.ecmaVersion = extra.ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);\n-\n-        if (options.sourceType === \"module\") {\n-            extra.isModule = true;\n-\n-            // modules must be in 6 at least\n-            if (acornOptions.ecmaVersion < 6) {\n-                acornOptions.ecmaVersion = 6;\n-                extra.ecmaVersion = 6;\n-            }\n-\n-            acornOptions.sourceType = \"module\";\n-        }\n-\n-        // apply parsing flags after sourceType to allow overriding\n-        if (options.ecmaFeatures && typeof options.ecmaFeatures === \"object\") {\n-            extra.ecmaFeatures = Object.assign({}, options.ecmaFeatures);\n-            impliedStrict = extra.ecmaFeatures.impliedStrict;\n-            extra.ecmaFeatures.impliedStrict = typeof impliedStrict === \"boolean\" && impliedStrict;\n-            if (options.ecmaFeatures.globalReturn) {\n-                acornOptions.allowReturnOutsideFunction = true;\n-            }\n-        }\n-\n-\n-        acornOptions.onToken = function(token) {\n-            if (extra.tokens) {\n-                translator.onToken(token, extra);\n-            }\n-            if (token.type !== tt.eof) {\n-                lastToken = token;\n-            }\n-        };\n-\n-        if (extra.attachComment || extra.comment) {\n-            acornOptions.onComment = function() {\n-                var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);\n-                extra.comments.push(comment);\n-\n-                if (extra.attachComment) {\n-                    commentAttachment.addComment(comment);\n-                }\n-            };\n-        }\n-\n-        if (extra.range) {\n-            acornOptions.ranges = true;\n-        }\n-\n-        if (extra.loc) {\n-            acornOptions.locations = true;\n-        }\n-\n-        if (extra.ecmaFeatures.jsx) {\n-            // Should process jsx plugin before espree plugin.\n-            acornOptions.plugins = {\n-                jsx: true,\n-                espree: true\n-            };\n-        }\n-    }\n-\n-    program = acorn.parse(code, acornOptions);\n-    program.sourceType = extra.isModule ? \"module\" : \"script\";\n-\n-    if (extra.comment || extra.attachComment) {\n-        program.comments = extra.comments;\n-    }\n-\n-    if (extra.tokens) {\n-        program.tokens = extra.tokens;\n-    }\n-\n-    /*\n-     * Adjust opening and closing position of program to match Esprima.\n-     * Acorn always starts programs at range 0 whereas Esprima starts at the\n-     * first AST node's start (the only real difference is when there's leading\n-     * whitespace or leading comments). Acorn also counts trailing whitespace\n-     * as part of the program whereas Esprima only counts up to the last token.\n-     */\n-    if (program.range) {\n-        program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];\n-        program.range[1] = lastToken ? lastToken.range[1] : program.range[1];\n-    }\n-\n-    if (program.loc) {\n-        program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;\n-        program.loc.end = lastToken ? lastToken.loc.end : program.loc.end;\n-    }\n-\n-    return program;\n+    const Parser = parsers.get(options);\n+    return new Parser(options, code).parse();\n }\n \n //------------------------------------------------------------------------------\n@@ -634,23 +165,5 @@ exports.Syntax = (function() {\n \n /* istanbul ignore next */\n exports.VisitorKeys = (function() {\n-    var visitorKeys = require(\"./lib/visitor-keys\");\n-    var name,\n-        keys = {};\n-\n-    if (typeof Object.create === \"function\") {\n-        keys = Object.create(null);\n-    }\n-\n-    for (name in visitorKeys) {\n-        if (visitorKeys.hasOwnProperty(name)) {\n-            keys[name] = visitorKeys[name];\n-        }\n-    }\n-\n-    if (typeof Object.freeze === \"function\") {\n-        Object.freeze(keys);\n-    }\n-\n-    return keys;\n+    return require(\"eslint-visitor-keys\").KEYS;\n }());"
        },
        {
            "sha": "3b4d1eab65d379a30f98cd4d3db4a4be7302a3ae",
            "filename": "tools/node_modules/eslint/node_modules/espree/lib/espree.js",
            "status": "added",
            "additions": 314,
            "deletions": 0,
            "changes": 314,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Flib%2Fespree.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Flib%2Fespree.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Flib%2Fespree.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -0,0 +1,314 @@\n+\"use strict\";\n+\n+const acorn = require(\"acorn\");\n+const jsx = require(\"acorn-jsx\");\n+const commentAttachment = require(\"./comment-attachment\");\n+const TokenTranslator = require(\"./token-translator\");\n+\n+const DEFAULT_ECMA_VERSION = 5;\n+const STATE = Symbol(\"espree's internal state\");\n+const ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n+const tokTypes = Object.assign({}, acorn.tokTypes, jsx.tokTypes);\n+\n+/**\n+ * Normalize ECMAScript version from the initial config\n+ * @param {number} ecmaVersion ECMAScript version from the initial config\n+ * @returns {number} normalized ECMAScript version\n+ */\n+function normalizeEcmaVersion(ecmaVersion) {\n+    if (typeof ecmaVersion === \"number\") {\n+        let version = ecmaVersion;\n+\n+        // Calculate ECMAScript edition number from official year version starting with\n+        // ES2015, which corresponds with ES6 (or a difference of 2009).\n+        if (version >= 2015) {\n+            version -= 2009;\n+        }\n+\n+        switch (version) {\n+            case 3:\n+            case 5:\n+            case 6:\n+            case 7:\n+            case 8:\n+            case 9:\n+            case 10:\n+                return version;\n+\n+            default:\n+                throw new Error(\"Invalid ecmaVersion.\");\n+        }\n+    } else {\n+        return DEFAULT_ECMA_VERSION;\n+    }\n+}\n+\n+/**\n+ * Converts an Acorn comment to a Esprima comment.\n+ * @param {boolean} block True if it's a block comment, false if not.\n+ * @param {string} text The text of the comment.\n+ * @param {int} start The index at which the comment starts.\n+ * @param {int} end The index at which the comment ends.\n+ * @param {Location} startLoc The location at which the comment starts.\n+ * @param {Location} endLoc The location at which the comment ends.\n+ * @returns {Object} The comment object.\n+ * @private\n+ */\n+function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {\n+    const comment = {\n+        type: block ? \"Block\" : \"Line\",\n+        value: text\n+    };\n+\n+    if (typeof start === \"number\") {\n+        comment.start = start;\n+        comment.end = end;\n+        comment.range = [start, end];\n+    }\n+\n+    if (typeof startLoc === \"object\") {\n+        comment.loc = {\n+            start: startLoc,\n+            end: endLoc\n+        };\n+    }\n+\n+    return comment;\n+}\n+\n+module.exports = () => Parser => class Espree extends Parser {\n+    constructor(options, code) {\n+        if (typeof options !== \"object\" || options === null) {\n+            options = {};\n+        }\n+        if (typeof code !== \"string\" && !(code instanceof String)) {\n+            code = String(code);\n+        }\n+\n+        const ecmaFeatures = options.ecmaFeatures || {};\n+        const ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);\n+        const isModule = options.sourceType === \"module\";\n+        const tokenTranslator =\n+            options.tokens === true ?\n+                new TokenTranslator(tokTypes, code) :\n+                null;\n+\n+        // Initialize acorn parser.\n+        super({\n+            ecmaVersion: isModule ? Math.max(6, ecmaVersion) : ecmaVersion,\n+            sourceType: isModule ? \"module\" : \"script\",\n+            ranges: options.range === true || options.attachComment === true,\n+            locations: options.loc === true,\n+\n+            // Truthy value is true for backward compatibility.\n+            allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),\n+\n+            // Collect tokens\n+            onToken: (token) => {\n+                if (tokenTranslator) {\n+                    // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n+                    tokenTranslator.onToken(token, this[STATE]);\n+                }\n+                if (token.type !== tokTypes.eof) {\n+                    this[STATE].lastToken = token;\n+                }\n+            },\n+\n+            // Collect comments\n+            onComment: (block, text, start, end, startLoc, endLoc) => {\n+                if (this[STATE].comments) {\n+                    const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);\n+                    this[STATE].comments.push(comment);\n+\n+                    if (options.attachComment === true) {\n+                        commentAttachment.addComment(comment);\n+                    }\n+                }\n+            }\n+        }, code);\n+\n+        // TODO: remove global state.\n+        commentAttachment.reset();\n+\n+        // Initialize internal state.\n+        this[STATE] = {\n+            tokens: tokenTranslator ? [] : null,\n+            comments: options.comment === true || options.attachComment === true ? [] : null,\n+            attachComment: options.attachComment === true,\n+            impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,\n+            ecmaVersion: this.options.ecmaVersion,\n+            jsxAttrValueToken: false,\n+            lastToken: null\n+        };\n+    }\n+\n+    tokenize() {\n+        do {\n+            this.next();\n+        } while (this.type !== tokTypes.eof);\n+\n+        const extra = this[STATE];\n+        const tokens = extra.tokens;\n+\n+        if (extra.comments) {\n+            tokens.comments = extra.comments;\n+        }\n+\n+        return tokens;\n+    }\n+\n+    finishNode(...args) {\n+        const result = super.finishNode(...args);\n+        return this[ESPRIMA_FINISH_NODE](result);\n+    }\n+\n+    finishNodeAt(...args) {\n+        const result = super.finishNodeAt(...args);\n+        return this[ESPRIMA_FINISH_NODE](result);\n+    }\n+\n+    parse() {\n+        const extra = this[STATE];\n+        const program = super.parse();\n+\n+        program.sourceType = this.options.sourceType;\n+\n+        if (extra.comments) {\n+            program.comments = extra.comments;\n+        }\n+        if (extra.tokens) {\n+            program.tokens = extra.tokens;\n+        }\n+\n+        /*\n+         * Adjust opening and closing position of program to match Esprima.\n+         * Acorn always starts programs at range 0 whereas Esprima starts at the\n+         * first AST node's start (the only real difference is when there's leading\n+         * whitespace or leading comments). Acorn also counts trailing whitespace\n+         * as part of the program whereas Esprima only counts up to the last token.\n+         */\n+        if (program.range) {\n+            program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];\n+            program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];\n+        }\n+        if (program.loc) {\n+            program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;\n+            program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;\n+        }\n+\n+        return program;\n+    }\n+\n+    parseTopLevel(node) {\n+        if (this[STATE].impliedStrict) {\n+            this.strict = true;\n+        }\n+        return super.parseTopLevel(node);\n+    }\n+\n+    /**\n+     * Overwrites the default raise method to throw Esprima-style errors.\n+     * @param {int} pos The position of the error.\n+     * @param {string} message The error message.\n+     * @throws {SyntaxError} A syntax error.\n+     * @returns {void}\n+     */\n+    raise(pos, message) {\n+        const loc = acorn.getLineInfo(this.input, pos);\n+        const err = new SyntaxError(message);\n+        err.index = pos;\n+        err.lineNumber = loc.line;\n+        err.column = loc.column + 1; // acorn uses 0-based columns\n+        throw err;\n+    }\n+\n+    /**\n+     * Overwrites the default raise method to throw Esprima-style errors.\n+     * @param {int} pos The position of the error.\n+     * @param {string} message The error message.\n+     * @throws {SyntaxError} A syntax error.\n+     * @returns {void}\n+     */\n+    raiseRecoverable(pos, message) {\n+        this.raise(pos, message);\n+    }\n+\n+    /**\n+     * Overwrites the default unexpected method to throw Esprima-style errors.\n+     * @param {int} pos The position of the error.\n+     * @throws {SyntaxError} A syntax error.\n+     * @returns {void}\n+     */\n+    unexpected(pos) {\n+        let message = \"Unexpected token\";\n+\n+        if (pos !== null && pos !== void 0) {\n+            this.pos = pos;\n+\n+            if (this.options.locations) {\n+                while (this.pos < this.lineStart) {\n+                    this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n+                    --this.curLine;\n+                }\n+            }\n+\n+            this.nextToken();\n+        }\n+\n+        if (this.end > this.start) {\n+            message += \" \" + this.input.slice(this.start, this.end);\n+        }\n+\n+        this.raise(this.start, message);\n+    }\n+\n+    /*\n+     * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n+     * uses regular tt.string without any distinction between this and regular JS\n+     * strings. As such, we intercept an attempt to read a JSX string and set a flag\n+     * on extra so that when tokens are converted, the next token will be switched\n+     * to JSXText via onToken.\n+     */\n+    jsx_readString(quote) { // eslint-disable-line camelcase\n+        const result = super.jsx_readString(quote);\n+        if (this.type === tokTypes.string) {\n+            this[STATE].jsxAttrValueToken = true;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Performs last-minute Esprima-specific compatibility checks and fixes.\n+     * @param {ASTNode} result The node to check.\n+     * @returns {ASTNode} The finished node.\n+     */\n+    [ESPRIMA_FINISH_NODE](result) {\n+        // Acorn doesn't count the opening and closing backticks as part of templates\n+        // so we have to adjust ranges/locations appropriately.\n+        if (result.type === \"TemplateElement\") {\n+\n+            // additional adjustment needed if ${ is the last token\n+            const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === \"${\";\n+\n+            if (result.range) {\n+                result.range[0]--;\n+                result.range[1] += (terminalDollarBraceL ? 2 : 1);\n+            }\n+\n+            if (result.loc) {\n+                result.loc.start.column--;\n+                result.loc.end.column += (terminalDollarBraceL ? 2 : 1);\n+            }\n+        }\n+\n+        if (this[STATE].attachComment) {\n+            commentAttachment.processComment(result);\n+        }\n+\n+        if (result.type.indexOf(\"Function\") > -1 && !result.generator) {\n+            result.generator = false;\n+        }\n+\n+        return result;\n+    }\n+};"
        },
        {
            "sha": "efc6c616fe52f8c3ff410881da5370d9e9629d8d",
            "filename": "tools/node_modules/eslint/node_modules/espree/lib/visitor-keys.js",
            "status": "removed",
            "additions": 0,
            "deletions": 123,
            "changes": 123,
            "blob_url": "https://github.com/nodejs/node/blob/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Flib%2Fvisitor-keys.js",
            "raw_url": "https://github.com/nodejs/node/raw/9697c0820f015ccf898a3662305a0caa3cd9c208/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Flib%2Fvisitor-keys.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Flib%2Fvisitor-keys.js?ref=9697c0820f015ccf898a3662305a0caa3cd9c208",
            "patch": "@@ -1,123 +0,0 @@\n-/**\n- * @fileoverview The visitor keys for the node types Espree supports\n- * @author Nicholas C. Zakas\n- *\n- * This file contains code from estraverse-fb.\n- *\n- * The MIT license. Copyright (c) 2014 Ingvar Stepanyan\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to deal\n- * in the Software without restriction, including without limitation the rights\n- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n- * copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in all\n- * copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n- * SOFTWARE.\n- */\n-\n-\"use strict\";\n-\n-//------------------------------------------------------------------------------\n-// Requirements\n-//------------------------------------------------------------------------------\n-\n-// None!\n-\n-//------------------------------------------------------------------------------\n-// Public\n-//------------------------------------------------------------------------------\n-\n-module.exports = {\n-\n-    // ECMAScript\n-    AssignmentExpression: [\"left\", \"right\"],\n-    AssignmentPattern: [\"left\", \"right\"],\n-    ArrayExpression: [\"elements\"],\n-    ArrayPattern: [\"elements\"],\n-    ArrowFunctionExpression: [\"params\", \"body\"],\n-    BlockStatement: [\"body\"],\n-    BinaryExpression: [\"left\", \"right\"],\n-    BreakStatement: [\"label\"],\n-    CallExpression: [\"callee\", \"arguments\"],\n-    CatchClause: [\"param\", \"body\"],\n-    ClassBody: [\"body\"],\n-    ClassDeclaration: [\"id\", \"superClass\", \"body\"],\n-    ClassExpression: [\"id\", \"superClass\", \"body\"],\n-    ConditionalExpression: [\"test\", \"consequent\", \"alternate\"],\n-    ContinueStatement: [\"label\"],\n-    DebuggerStatement: [],\n-    DirectiveStatement: [],\n-    DoWhileStatement: [\"body\", \"test\"],\n-    EmptyStatement: [],\n-    ExportAllDeclaration: [\"source\"],\n-    ExportDefaultDeclaration: [\"declaration\"],\n-    ExportNamedDeclaration: [\"declaration\", \"specifiers\", \"source\"],\n-    ExportSpecifier: [\"exported\", \"local\"],\n-    ExpressionStatement: [\"expression\"],\n-    ForStatement: [\"init\", \"test\", \"update\", \"body\"],\n-    ForInStatement: [\"left\", \"right\", \"body\"],\n-    ForOfStatement: [\"left\", \"right\", \"body\"],\n-    FunctionDeclaration: [\"id\", \"params\", \"body\"],\n-    FunctionExpression: [\"id\", \"params\", \"body\"],\n-    Identifier: [],\n-    IfStatement: [\"test\", \"consequent\", \"alternate\"],\n-    ImportDeclaration: [\"specifiers\", \"source\"],\n-    ImportDefaultSpecifier: [\"local\"],\n-    ImportNamespaceSpecifier: [\"local\"],\n-    ImportSpecifier: [\"imported\", \"local\"],\n-    Literal: [],\n-    LabeledStatement: [\"label\", \"body\"],\n-    LogicalExpression: [\"left\", \"right\"],\n-    MemberExpression: [\"object\", \"property\"],\n-    MetaProperty: [\"meta\", \"property\"],\n-    MethodDefinition: [\"key\", \"value\"],\n-    ModuleSpecifier: [],\n-    NewExpression: [\"callee\", \"arguments\"],\n-    ObjectExpression: [\"properties\"],\n-    ObjectPattern: [\"properties\"],\n-    Program: [\"body\"],\n-    Property: [\"key\", \"value\"],\n-    RestElement: [ \"argument\" ],\n-    ReturnStatement: [\"argument\"],\n-    SequenceExpression: [\"expressions\"],\n-    SpreadElement: [\"argument\"],\n-    Super: [],\n-    SwitchStatement: [\"discriminant\", \"cases\"],\n-    SwitchCase: [\"test\", \"consequent\"],\n-    TaggedTemplateExpression: [\"tag\", \"quasi\"],\n-    TemplateElement: [],\n-    TemplateLiteral: [\"quasis\", \"expressions\"],\n-    ThisExpression: [],\n-    ThrowStatement: [\"argument\"],\n-    TryStatement: [\"block\", \"handler\", \"finalizer\"],\n-    UnaryExpression: [\"argument\"],\n-    UpdateExpression: [\"argument\"],\n-    VariableDeclaration: [\"declarations\"],\n-    VariableDeclarator: [\"id\", \"init\"],\n-    WhileStatement: [\"test\", \"body\"],\n-    WithStatement: [\"object\", \"body\"],\n-    YieldExpression: [\"argument\"],\n-\n-    // JSX\n-    JSXIdentifier: [],\n-    JSXNamespacedName: [\"namespace\", \"name\"],\n-    JSXMemberExpression: [\"object\", \"property\"],\n-    JSXEmptyExpression: [],\n-    JSXExpressionContainer: [\"expression\"],\n-    JSXElement: [\"openingElement\", \"closingElement\", \"children\"],\n-    JSXClosingElement: [\"name\"],\n-    JSXOpeningElement: [\"name\", \"attributes\"],\n-    JSXAttribute: [\"name\", \"value\"],\n-    JSXText: null,\n-    JSXSpreadAttribute: [\"argument\"]\n-};"
        },
        {
            "sha": "91e99e4b2136c07b869b883aa0462841b0321c9b",
            "filename": "tools/node_modules/eslint/node_modules/espree/package.json",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Fpackage.json",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fespree%2Fpackage.json?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -8,8 +8,9 @@\n   },\n   \"bundleDependencies\": false,\n   \"dependencies\": {\n-    \"acorn\": \"^5.6.0\",\n-    \"acorn-jsx\": \"^4.1.1\"\n+    \"acorn\": \"^6.0.2\",\n+    \"acorn-jsx\": \"^5.0.0\",\n+    \"eslint-visitor-keys\": \"^1.0.0\"\n   },\n   \"deprecated\": false,\n   \"description\": \"An Esprima-compatible JavaScript parser built on Acorn\",\n@@ -18,13 +19,13 @@\n     \"chai\": \"^1.10.0\",\n     \"eslint\": \"^2.13.1\",\n     \"eslint-config-eslint\": \"^3.0.0\",\n-    \"eslint-release\": \"^0.11.1\",\n+    \"eslint-release\": \"^1.0.0\",\n     \"esprima\": \"latest\",\n     \"esprima-fb\": \"^8001.2001.0-dev-harmony-fb\",\n-    \"istanbul\": \"~0.2.6\",\n     \"json-diff\": \"~0.3.1\",\n     \"leche\": \"^1.0.1\",\n     \"mocha\": \"^2.0.1\",\n+    \"nyc\": \"^13.0.1\",\n     \"regenerate\": \"~0.5.4\",\n     \"shelljs\": \"^0.3.0\",\n     \"shelljs-nodecli\": \"^0.1.1\",\n@@ -54,16 +55,15 @@\n     \"url\": \"git+https://github.com/eslint/espree.git\"\n   },\n   \"scripts\": {\n-    \"alpharelease\": \"eslint-prerelease alpha\",\n-    \"betarelease\": \"eslint-prerelease beta\",\n     \"browserify\": \"node Makefile.js browserify\",\n-    \"ci-release\": \"eslint-ci-release\",\n+    \"generate-alpharelease\": \"eslint-generate-prerelease alpha\",\n+    \"generate-betarelease\": \"eslint-generate-prerelease beta\",\n+    \"generate-rcrelease\": \"eslint-generate-prerelease rc\",\n     \"generate-regex\": \"node tools/generate-identifier-regex.js\",\n-    \"gh-release\": \"eslint-gh-release\",\n+    \"generate-release\": \"eslint-generate-release\",\n     \"lint\": \"node Makefile.js lint\",\n-    \"rcrelease\": \"eslint-prerelease rc\",\n-    \"release\": \"eslint-release\",\n+    \"publish-release\": \"eslint-publish-release\",\n     \"test\": \"npm run-script lint && node Makefile.js test\"\n   },\n-  \"version\": \"4.0.0\"\n+  \"version\": \"4.1.0\"\n }\n\\ No newline at end of file"
        },
        {
            "sha": "5b56c1529d57b3fed56097572cf6fab1b5397683",
            "filename": "tools/node_modules/eslint/node_modules/progress/lib/node-progress.js",
            "status": "modified",
            "additions": 13,
            "deletions": 9,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fprogress%2Flib%2Fnode-progress.js",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fprogress%2Flib%2Fnode-progress.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fprogress%2Flib%2Fnode-progress.js?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -66,6 +66,7 @@ function ProgressBar(fmt, options) {\n     head       : options.head || (options.complete || '=')\n   };\n   this.renderThrottle = options.renderThrottle !== 0 ? (options.renderThrottle || 16) : 0;\n+  this.lastRender = -Infinity;\n   this.callback = options.callback || function () {};\n   this.tokens = {};\n   this.lastDraw = '';\n@@ -92,14 +93,12 @@ ProgressBar.prototype.tick = function(len, tokens){\n \n   this.curr += len\n \n-  // schedule render\n-  if (!this.renderThrottleTimeout) {\n-    this.renderThrottleTimeout = setTimeout(this.render.bind(this), this.renderThrottle);\n-  }\n+  // try to render\n+  this.render();\n \n   // progress complete\n   if (this.curr >= this.total) {\n-    if (this.renderThrottleTimeout) this.render();\n+    this.render();\n     this.complete = true;\n     this.terminate();\n     this.callback(this);\n@@ -116,17 +115,22 @@ ProgressBar.prototype.tick = function(len, tokens){\n  */\n \n ProgressBar.prototype.render = function (tokens) {\n-  clearTimeout(this.renderThrottleTimeout);\n-  this.renderThrottleTimeout = null;\n-\n   if (tokens) this.tokens = tokens;\n \n   if (!this.stream.isTTY) return;\n \n+  var now = Date.now();\n+  var delta = now - this.lastRender;\n+  if (delta < this.renderThrottle) {\n+    return;\n+  } else {\n+    this.lastRender = now;\n+  }\n+\n   var ratio = this.curr / this.total;\n   ratio = Math.min(Math.max(ratio, 0), 1);\n \n-  var percent = ratio * 100;\n+  var percent = Math.floor(ratio * 100);\n   var incomplete, complete, completeLength;\n   var elapsed = new Date - this.start;\n   var eta = (percent == 100) ? 0 : elapsed * (this.total / this.curr - 1);"
        },
        {
            "sha": "d20aaf0f9e27d5f9d0e1b4e5987736c0160867f4",
            "filename": "tools/node_modules/eslint/node_modules/progress/package.json",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fprogress%2Fpackage.json",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fprogress%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fnode_modules%2Fprogress%2Fpackage.json?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -19,6 +19,10 @@\n     {\n       \"name\": \"Andrew Rhyne\",\n       \"email\": \"rhyneandrew@gmail.com\"\n+    },\n+    {\n+      \"name\": \"Marco Brack\",\n+      \"email\": \"PapstDonB@Googlemail.com\"\n     }\n   ],\n   \"dependencies\": {},\n@@ -39,5 +43,5 @@\n     \"type\": \"git\",\n     \"url\": \"git://github.com/visionmedia/node-progress.git\"\n   },\n-  \"version\": \"2.0.0\"\n+  \"version\": \"2.0.1\"\n }\n\\ No newline at end of file"
        },
        {
            "sha": "7b47dbd691f1ceb42eef92baa4808fca4dabd276",
            "filename": "tools/node_modules/eslint/package.json",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fpackage.json",
            "raw_url": "https://github.com/nodejs/node/raw/2f1c356d7abe4949b5ee68e0724ed7e493fc03e1/tools%2Fnode_modules%2Feslint%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fnode_modules%2Feslint%2Fpackage.json?ref=2f1c356d7abe4949b5ee68e0724ed7e493fc03e1",
            "patch": "@@ -69,7 +69,7 @@\n     \"eslint-plugin-eslint-plugin\": \"^1.2.0\",\n     \"eslint-plugin-node\": \"^7.0.1\",\n     \"eslint-plugin-rulesdir\": \"^0.1.0\",\n-    \"eslint-release\": \"^0.11.1\",\n+    \"eslint-release\": \"^1.0.0\",\n     \"eslint-rule-composer\": \"^0.3.0\",\n     \"eslump\": \"^1.6.2\",\n     \"esprima\": \"^4.0.1\",\n@@ -120,20 +120,20 @@\n     \"url\": \"git+https://github.com/eslint/eslint.git\"\n   },\n   \"scripts\": {\n-    \"alpharelease\": \"node Makefile.js prerelease -- alpha\",\n-    \"betarelease\": \"node Makefile.js prerelease -- beta\",\n     \"browserify\": \"node Makefile.js browserify\",\n-    \"ci-release\": \"node Makefile.js ciRelease\",\n     \"coveralls\": \"cat ./coverage/lcov.info | coveralls\",\n     \"docs\": \"node Makefile.js docs\",\n     \"fuzz\": \"node Makefile.js fuzz\",\n+    \"generate-alpharelease\": \"node Makefile.js generatePrerelease -- alpha\",\n+    \"generate-betarelease\": \"node Makefile.js generatePrerelease -- beta\",\n+    \"generate-rcrelease\": \"node Makefile.js generatePrerelease -- rc\",\n+    \"generate-release\": \"node Makefile.js generateRelease\",\n     \"gensite\": \"node Makefile.js gensite\",\n     \"lint\": \"node Makefile.js lint\",\n     \"perf\": \"node Makefile.js perf\",\n     \"profile\": \"beefy tests/bench/bench.js --open -- -t brfs -t ./tests/bench/xform-rules.js -r espree\",\n-    \"rcrelease\": \"node Makefile.js prerelease -- rc\",\n-    \"release\": \"node Makefile.js release\",\n+    \"publish-release\": \"node Makefile.js publishRelease\",\n     \"test\": \"node Makefile.js test\"\n   },\n-  \"version\": \"5.7.0\"\n+  \"version\": \"5.8.0\"\n }\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 7969,
        "additions": 1583,
        "deletions": 6386
    }
}