{
    "author": "hashseed",
    "message": "deps: cherry-pick 88f8fe1 from upstream V8\n\nOriginal commit message:\n\n    Fix collection iterator preview with deleted entries\n\n    We used to assume that we know the remaining entries returned by the\n    iterator based on the current index. However, that is not accurate,\n    since entries skipped by the current index could be deleted.\n\n    In the new approach, we allocate conservatively and shrink the result.\n\n    R=neis@chromium.org\n\n    Bug: v8:8433\n    Change-Id: I38a3004dc3af292daabb454bb76f38d65ef437e8\n    Reviewed-on: https://chromium-review.googlesource.com/c/1325966\n    Commit-Queue: Yang Guo <yangguo@chromium.org>\n    Reviewed-by: Georg Neis <neis@chromium.org>\n    Cr-Commit-Position: refs/heads/master@{#57360}\n\nRefs: https://github.com/v8/v8/commit/88f8fe19a863c6392bd296faf86c06eff2a41bc1\n\nPR-URL: https://github.com/nodejs/node/pull/24514\nRefs: https://github.com/nodejs/node/issues/24053\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "70e2f9db13e6e7fd845f5329b76782906a50ce02",
    "files": [
        {
            "sha": "5a5a0718323b64ca91066cf41fa9ff309ca4a988",
            "filename": "common.gypi",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/70e2f9db13e6e7fd845f5329b76782906a50ce02/common.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/70e2f9db13e6e7fd845f5329b76782906a50ce02/common.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/common.gypi?ref=70e2f9db13e6e7fd845f5329b76782906a50ce02",
            "patch": "@@ -31,7 +31,7 @@\n \n     # Reset this number to 0 on major V8 upgrades.\n     # Increment by one for each non-official patch applied to deps/v8.\n-    'v8_embedder_string': '-node.12',\n+    'v8_embedder_string': '-node.13',\n \n     # Enable disassembler for `--print-code` v8 options\n     'v8_enable_disassembler': 1,"
        },
        {
            "sha": "5ac9aec047927786666f9491d67987e30a608ee0",
            "filename": "deps/v8/src/api.cc",
            "status": "modified",
            "additions": 27,
            "deletions": 25,
            "changes": 52,
            "blob_url": "https://github.com/nodejs/node/blob/70e2f9db13e6e7fd845f5329b76782906a50ce02/deps%2Fv8%2Fsrc%2Fapi.cc",
            "raw_url": "https://github.com/nodejs/node/raw/70e2f9db13e6e7fd845f5329b76782906a50ce02/deps%2Fv8%2Fsrc%2Fapi.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi.cc?ref=70e2f9db13e6e7fd845f5329b76782906a50ce02",
            "patch": "@@ -7103,30 +7103,30 @@ i::Handle<i::JSArray> MapAsArray(i::Isolate* isolate, i::Object* table_obj,\n   i::Factory* factory = isolate->factory();\n   i::Handle<i::OrderedHashMap> table(i::OrderedHashMap::cast(table_obj),\n                                      isolate);\n-  if (offset >= table->NumberOfElements()) return factory->NewJSArray(0);\n-  int length = (table->NumberOfElements() - offset) *\n-               (kind == MapAsArrayKind::kEntries ? 2 : 1);\n-  i::Handle<i::FixedArray> result = factory->NewFixedArray(length);\n+  const bool collect_keys =\n+      kind == MapAsArrayKind::kEntries || kind == MapAsArrayKind::kKeys;\n+  const bool collect_values =\n+      kind == MapAsArrayKind::kEntries || kind == MapAsArrayKind::kValues;\n+  int capacity = table->UsedCapacity();\n+  int max_length =\n+      (capacity - offset) * ((collect_keys && collect_values) ? 2 : 1);\n+  i::Handle<i::FixedArray> result = factory->NewFixedArray(max_length);\n   int result_index = 0;\n   {\n     i::DisallowHeapAllocation no_gc;\n-    int capacity = table->UsedCapacity();\n     i::Oddball* the_hole = i::ReadOnlyRoots(isolate).the_hole_value();\n-    for (int i = 0; i < capacity; ++i) {\n+    for (int i = offset; i < capacity; ++i) {\n       i::Object* key = table->KeyAt(i);\n       if (key == the_hole) continue;\n-      if (offset-- > 0) continue;\n-      if (kind == MapAsArrayKind::kEntries || kind == MapAsArrayKind::kKeys) {\n-        result->set(result_index++, key);\n-      }\n-      if (kind == MapAsArrayKind::kEntries || kind == MapAsArrayKind::kValues) {\n-        result->set(result_index++, table->ValueAt(i));\n-      }\n+      if (collect_keys) result->set(result_index++, key);\n+      if (collect_values) result->set(result_index++, table->ValueAt(i));\n     }\n   }\n-  DCHECK_EQ(result_index, result->length());\n-  DCHECK_EQ(result_index, length);\n-  return factory->NewJSArrayWithElements(result, i::PACKED_ELEMENTS, length);\n+  DCHECK_GE(max_length, result_index);\n+  if (result_index == 0) return factory->NewJSArray(0);\n+  result->Shrink(isolate, result_index);\n+  return factory->NewJSArrayWithElements(result, i::PACKED_ELEMENTS,\n+                                         result_index);\n }\n \n }  // namespace\n@@ -7211,24 +7211,26 @@ i::Handle<i::JSArray> SetAsArray(i::Isolate* isolate, i::Object* table_obj,\n   i::Factory* factory = isolate->factory();\n   i::Handle<i::OrderedHashSet> table(i::OrderedHashSet::cast(table_obj),\n                                      isolate);\n-  int length = table->NumberOfElements() - offset;\n-  if (length <= 0) return factory->NewJSArray(0);\n-  i::Handle<i::FixedArray> result = factory->NewFixedArray(length);\n+  // Elements skipped by |offset| may already be deleted.\n+  int capacity = table->UsedCapacity();\n+  int max_length = capacity - offset;\n+  if (max_length == 0) return factory->NewJSArray(0);\n+  i::Handle<i::FixedArray> result = factory->NewFixedArray(max_length);\n   int result_index = 0;\n   {\n     i::DisallowHeapAllocation no_gc;\n-    int capacity = table->UsedCapacity();\n     i::Oddball* the_hole = i::ReadOnlyRoots(isolate).the_hole_value();\n-    for (int i = 0; i < capacity; ++i) {\n+    for (int i = offset; i < capacity; ++i) {\n       i::Object* key = table->KeyAt(i);\n       if (key == the_hole) continue;\n-      if (offset-- > 0) continue;\n       result->set(result_index++, key);\n     }\n   }\n-  DCHECK_EQ(result_index, result->length());\n-  DCHECK_EQ(result_index, length);\n-  return factory->NewJSArrayWithElements(result, i::PACKED_ELEMENTS, length);\n+  DCHECK_GE(max_length, result_index);\n+  if (result_index == 0) return factory->NewJSArray(0);\n+  result->Shrink(isolate, result_index);\n+  return factory->NewJSArrayWithElements(result, i::PACKED_ELEMENTS,\n+                                         result_index);\n }\n }  // namespace\n "
        },
        {
            "sha": "1b74ecfd70c655b31dc9c1b02cf8673ff4c98db2",
            "filename": "deps/v8/test/cctest/test-api.cc",
            "status": "modified",
            "additions": 214,
            "deletions": 0,
            "changes": 214,
            "blob_url": "https://github.com/nodejs/node/blob/70e2f9db13e6e7fd845f5329b76782906a50ce02/deps%2Fv8%2Ftest%2Fcctest%2Ftest-api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/70e2f9db13e6e7fd845f5329b76782906a50ce02/deps%2Fv8%2Ftest%2Fcctest%2Ftest-api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fcctest%2Ftest-api.cc?ref=70e2f9db13e6e7fd845f5329b76782906a50ce02",
            "patch": "@@ -28777,3 +28777,217 @@ TEST(TestSetWasmThreadsEnabledCallback) {\n   i::FLAG_experimental_wasm_threads = false;\n   CHECK(i_isolate->AreWasmThreadsEnabled(i_context));\n }\n+\n+TEST(PreviewSetIteratorEntriesWithDeleted) {\n+  LocalContext env;\n+  v8::HandleScope handle_scope(env->GetIsolate());\n+  v8::Local<v8::Context> context = env.local();\n+\n+  {\n+    // Create set, delete entry, create iterator, preview.\n+    v8::Local<v8::Object> iterator =\n+        CompileRun(\"var set = new Set([1,2,3]); set.delete(1); set.keys()\")\n+            ->ToObject(context)\n+            .ToLocalChecked();\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(2, entries->Length());\n+    CHECK_EQ(2, entries->Get(context, 0)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+    CHECK_EQ(3, entries->Get(context, 1)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+  }\n+  {\n+    // Create set, create iterator, delete entry, preview.\n+    v8::Local<v8::Object> iterator =\n+        CompileRun(\"var set = new Set([1,2,3]); set.keys()\")\n+            ->ToObject(context)\n+            .ToLocalChecked();\n+    CompileRun(\"set.delete(1);\");\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(2, entries->Length());\n+    CHECK_EQ(2, entries->Get(context, 0)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+    CHECK_EQ(3, entries->Get(context, 1)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+  }\n+  {\n+    // Create set, create iterator, delete entry, iterate, preview.\n+    v8::Local<v8::Object> iterator =\n+        CompileRun(\"var set = new Set([1,2,3]); var it = set.keys(); it\")\n+            ->ToObject(context)\n+            .ToLocalChecked();\n+    CompileRun(\"set.delete(1); it.next();\");\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(1, entries->Length());\n+    CHECK_EQ(3, entries->Get(context, 0)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+  }\n+  {\n+    // Create set, create iterator, delete entry, iterate until empty, preview.\n+    v8::Local<v8::Object> iterator =\n+        CompileRun(\"var set = new Set([1,2,3]); var it = set.keys(); it\")\n+            ->ToObject(context)\n+            .ToLocalChecked();\n+    CompileRun(\"set.delete(1); it.next(); it.next();\");\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(0, entries->Length());\n+  }\n+  {\n+    // Create set, create iterator, delete entry, iterate, trigger rehash,\n+    // preview.\n+    v8::Local<v8::Object> iterator =\n+        CompileRun(\"var set = new Set([1,2,3]); var it = set.keys(); it\")\n+            ->ToObject(context)\n+            .ToLocalChecked();\n+    CompileRun(\"set.delete(1); it.next();\");\n+    CompileRun(\"for (var i = 4; i < 20; i++) set.add(i);\");\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(17, entries->Length());\n+    for (uint32_t i = 0; i < 17; i++) {\n+      CHECK_EQ(i + 3, entries->Get(context, i)\n+                          .ToLocalChecked()\n+                          ->Int32Value(context)\n+                          .FromJust());\n+    }\n+  }\n+}\n+\n+TEST(PreviewMapIteratorEntriesWithDeleted) {\n+  LocalContext env;\n+  v8::HandleScope handle_scope(env->GetIsolate());\n+  v8::Local<v8::Context> context = env.local();\n+\n+  {\n+    // Create map, delete entry, create iterator, preview.\n+    v8::Local<v8::Object> iterator = CompileRun(\n+                                         \"var map = new Map();\"\n+                                         \"var key = {}; map.set(key, 1);\"\n+                                         \"map.set({}, 2); map.set({}, 3);\"\n+                                         \"map.delete(key);\"\n+                                         \"map.values()\")\n+                                         ->ToObject(context)\n+                                         .ToLocalChecked();\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(2, entries->Length());\n+    CHECK_EQ(2, entries->Get(context, 0)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+    CHECK_EQ(3, entries->Get(context, 1)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+  }\n+  {\n+    // Create map, create iterator, delete entry, preview.\n+    v8::Local<v8::Object> iterator = CompileRun(\n+                                         \"var map = new Map();\"\n+                                         \"var key = {}; map.set(key, 1);\"\n+                                         \"map.set({}, 2); map.set({}, 3);\"\n+                                         \"map.values()\")\n+                                         ->ToObject(context)\n+                                         .ToLocalChecked();\n+    CompileRun(\"map.delete(key);\");\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(2, entries->Length());\n+    CHECK_EQ(2, entries->Get(context, 0)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+    CHECK_EQ(3, entries->Get(context, 1)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+  }\n+  {\n+    // Create map, create iterator, delete entry, iterate, preview.\n+    v8::Local<v8::Object> iterator = CompileRun(\n+                                         \"var map = new Map();\"\n+                                         \"var key = {}; map.set(key, 1);\"\n+                                         \"map.set({}, 2); map.set({}, 3);\"\n+                                         \"var it = map.values(); it\")\n+                                         ->ToObject(context)\n+                                         .ToLocalChecked();\n+    CompileRun(\"map.delete(key); it.next();\");\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(1, entries->Length());\n+    CHECK_EQ(3, entries->Get(context, 0)\n+                    .ToLocalChecked()\n+                    ->Int32Value(context)\n+                    .FromJust());\n+  }\n+  {\n+    // Create map, create iterator, delete entry, iterate until empty, preview.\n+    v8::Local<v8::Object> iterator = CompileRun(\n+                                         \"var map = new Map();\"\n+                                         \"var key = {}; map.set(key, 1);\"\n+                                         \"map.set({}, 2); map.set({}, 3);\"\n+                                         \"var it = map.values(); it\")\n+                                         ->ToObject(context)\n+                                         .ToLocalChecked();\n+    CompileRun(\"map.delete(key); it.next(); it.next();\");\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(0, entries->Length());\n+  }\n+  {\n+    // Create map, create iterator, delete entry, iterate, trigger rehash,\n+    // preview.\n+    v8::Local<v8::Object> iterator = CompileRun(\n+                                         \"var map = new Map();\"\n+                                         \"var key = {}; map.set(key, 1);\"\n+                                         \"map.set({}, 2); map.set({}, 3);\"\n+                                         \"var it = map.values(); it\")\n+                                         ->ToObject(context)\n+                                         .ToLocalChecked();\n+    CompileRun(\"map.delete(key); it.next();\");\n+    CompileRun(\"for (var i = 4; i < 20; i++) map.set({}, i);\");\n+    bool is_key;\n+    v8::Local<v8::Array> entries =\n+        iterator->PreviewEntries(&is_key).ToLocalChecked();\n+    CHECK(!is_key);\n+    CHECK_EQ(17, entries->Length());\n+    for (uint32_t i = 0; i < 17; i++) {\n+      CHECK_EQ(i + 3, entries->Get(context, i)\n+                          .ToLocalChecked()\n+                          ->Int32Value(context)\n+                          .FromJust());\n+    }\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 268,
        "additions": 242,
        "deletions": 26
    }
}