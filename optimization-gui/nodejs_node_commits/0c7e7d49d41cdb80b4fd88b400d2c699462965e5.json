{
    "author": "bnoordhuis",
    "message": "src: use std::unique_ptr for STACK_OF(X509)\n\nConvert manual memory management of STACK_OF(X509) instances to\nstd::unique_ptr with a custom deleter.\n\nNote the tasteful application of std::move() to indicate a function\nthat consumes its argument.\n\nPR-URL: https://github.com/nodejs/node/pull/19087\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "0c7e7d49d41cdb80b4fd88b400d2c699462965e5",
    "files": [
        {
            "sha": "b3c9149b032bde608eb47b6a07e53e98fc4f6caa",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 44,
            "deletions": 54,
            "changes": 98,
            "blob_url": "https://github.com/nodejs/node/blob/0c7e7d49d41cdb80b4fd88b400d2c699462965e5/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0c7e7d49d41cdb80b4fd88b400d2c699462965e5/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=0c7e7d49d41cdb80b4fd88b400d2c699462965e5",
            "patch": "@@ -43,12 +43,14 @@\n // StartComAndWoSignData.inc\n #include \"StartComAndWoSignData.inc\"\n \n-#include <algorithm>\n #include <errno.h>\n #include <limits.h>  // INT_MAX\n #include <math.h>\n #include <stdlib.h>\n #include <string.h>\n+\n+#include <algorithm>\n+#include <memory>\n #include <vector>\n \n #define THROW_AND_RETURN_IF_NOT_BUFFER(val, prefix)           \\\n@@ -107,6 +109,12 @@ using v8::String;\n using v8::Value;\n \n \n+struct StackOfX509Deleter {\n+  void operator()(STACK_OF(X509)* p) const { sk_X509_pop_free(p, X509_free); }\n+};\n+\n+using StackOfX509 = std::unique_ptr<STACK_OF(X509), StackOfX509Deleter>;\n+\n #if OPENSSL_VERSION_NUMBER < 0x10100000L\n static void RSA_get0_key(const RSA* r, const BIGNUM** n, const BIGNUM** e,\n                          const BIGNUM** d) {\n@@ -829,17 +837,15 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,\n   int ret = 0;\n   unsigned long err = 0;  // NOLINT(runtime/int)\n \n-  // Read extra certs\n-  STACK_OF(X509)* extra_certs = sk_X509_new_null();\n-  if (extra_certs == nullptr) {\n+  StackOfX509 extra_certs(sk_X509_new_null());\n+  if (!extra_certs)\n     goto done;\n-  }\n \n   while ((extra = PEM_read_bio_X509(in,\n                                     nullptr,\n                                     NoPasswordCallback,\n                                     nullptr))) {\n-    if (sk_X509_push(extra_certs, extra))\n+    if (sk_X509_push(extra_certs.get(), extra))\n       continue;\n \n     // Failure, free all certs\n@@ -857,13 +863,11 @@ int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,\n     goto done;\n   }\n \n-  ret = SSL_CTX_use_certificate_chain(ctx, x, extra_certs, cert, issuer);\n+  ret = SSL_CTX_use_certificate_chain(ctx, x, extra_certs.get(), cert, issuer);\n   if (!ret)\n     goto done;\n \n  done:\n-  if (extra_certs != nullptr)\n-    sk_X509_pop_free(extra_certs, X509_free);\n   if (extra != nullptr)\n     X509_free(extra);\n   if (x != nullptr)\n@@ -1990,14 +1994,14 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n \n static Local<Object> AddIssuerChainToObject(X509** cert,\n                                             Local<Object> object,\n-                                            STACK_OF(X509)* const peer_certs,\n+                                            StackOfX509 peer_certs,\n                                             Environment* const env) {\n   Local<Context> context = env->isolate()->GetCurrentContext();\n-  *cert = sk_X509_delete(peer_certs, 0);\n+  *cert = sk_X509_delete(peer_certs.get(), 0);\n   for (;;) {\n     int i;\n-    for (i = 0; i < sk_X509_num(peer_certs); i++) {\n-      X509* ca = sk_X509_value(peer_certs, i);\n+    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {\n+      X509* ca = sk_X509_value(peer_certs.get(), i);\n       if (X509_check_issued(ca, *cert) != X509_V_OK)\n         continue;\n \n@@ -2009,41 +2013,31 @@ static Local<Object> AddIssuerChainToObject(X509** cert,\n       X509_free(*cert);\n \n       // Delete cert and continue aggregating issuers.\n-      *cert = sk_X509_delete(peer_certs, i);\n+      *cert = sk_X509_delete(peer_certs.get(), i);\n       break;\n     }\n \n     // Issuer not found, break out of the loop.\n-    if (i == sk_X509_num(peer_certs))\n+    if (i == sk_X509_num(peer_certs.get()))\n       break;\n   }\n-  sk_X509_pop_free(peer_certs, X509_free);\n   return object;\n }\n \n \n-static bool CloneSSLCerts(X509** cert,\n-                          const STACK_OF(X509)* const ssl_certs,\n-                          STACK_OF(X509)** peer_certs) {\n-  *peer_certs = sk_X509_new(nullptr);\n-  bool result = true;\n+static StackOfX509 CloneSSLCerts(X509** cert,\n+                                 const STACK_OF(X509)* const ssl_certs) {\n+  StackOfX509 peer_certs(sk_X509_new(nullptr));\n   if (*cert != nullptr)\n-    sk_X509_push(*peer_certs, *cert);\n+    sk_X509_push(peer_certs.get(), *cert);\n   for (int i = 0; i < sk_X509_num(ssl_certs); i++) {\n     *cert = X509_dup(sk_X509_value(ssl_certs, i));\n-    if (*cert == nullptr) {\n-      result = false;\n-      break;\n-    }\n-    if (!sk_X509_push(*peer_certs, *cert)) {\n-      result = false;\n-      break;\n-    }\n-  }\n-  if (!result) {\n-    sk_X509_pop_free(*peer_certs, X509_free);\n+    if (*cert == nullptr)\n+      return StackOfX509();\n+    if (!sk_X509_push(peer_certs.get(), *cert))\n+      return StackOfX509();\n   }\n-  return result;\n+  return peer_certs;\n }\n \n \n@@ -2077,7 +2071,6 @@ void SSLWrap<Base>::GetPeerCertificate(\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n   Environment* env = w->ssl_env();\n-  Local<Context> context = env->context();\n \n   ClearErrorOnReturn clear_error_on_return;\n \n@@ -2089,23 +2082,25 @@ void SSLWrap<Base>::GetPeerCertificate(\n   // contains the `peer_certificate`, but on server it doesn't.\n   X509* cert = w->is_server() ? SSL_get_peer_certificate(w->ssl_) : nullptr;\n   STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(w->ssl_);\n-  STACK_OF(X509)* peer_certs = nullptr;\n   if (cert == nullptr && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))\n     goto done;\n \n   // Short result requested.\n   if (args.Length() < 1 || !args[0]->IsTrue()) {\n-    result = X509ToObject(env,\n-                          cert == nullptr ? sk_X509_value(ssl_certs, 0) : cert);\n+    X509* target_cert = cert;\n+    if (target_cert == nullptr)\n+      target_cert = sk_X509_value(ssl_certs, 0);\n+    result = X509ToObject(env, target_cert);\n     goto done;\n   }\n \n-  if (CloneSSLCerts(&cert, ssl_certs, &peer_certs)) {\n+  if (auto peer_certs = CloneSSLCerts(&cert, ssl_certs)) {\n     // First and main certificate.\n-    cert = sk_X509_value(peer_certs, 0);\n+    cert = sk_X509_value(peer_certs.get(), 0);\n     result = X509ToObject(env, cert);\n \n-    issuer_chain = AddIssuerChainToObject(&cert, result, peer_certs, env);\n+    issuer_chain =\n+        AddIssuerChainToObject(&cert, result, std::move(peer_certs), env);\n     issuer_chain = GetLastIssuedCert(&cert, w->ssl_, issuer_chain, env);\n     // Last certificate should be self-signed.\n     if (X509_check_issued(cert, cert) == X509_V_OK)\n@@ -2959,25 +2954,23 @@ inline CheckResult CheckWhitelistedServerCert(X509_STORE_CTX* ctx) {\n   unsigned char hash[CNNIC_WHITELIST_HASH_LEN];\n   unsigned int hashlen = CNNIC_WHITELIST_HASH_LEN;\n \n-  STACK_OF(X509)* chain = X509_STORE_CTX_get1_chain(ctx);\n-  CHECK_NE(chain, nullptr);\n-  CHECK_GT(sk_X509_num(chain), 0);\n+  StackOfX509 chain(X509_STORE_CTX_get1_chain(ctx));\n+  CHECK(chain);\n+  CHECK_GT(sk_X509_num(chain.get()), 0);\n \n   // Take the last cert as root at the first time.\n-  X509* root_cert = sk_X509_value(chain, sk_X509_num(chain)-1);\n+  X509* root_cert = sk_X509_value(chain.get(), sk_X509_num(chain.get())-1);\n   X509_NAME* root_name = X509_get_subject_name(root_cert);\n \n   if (!IsSelfSigned(root_cert)) {\n-    root_cert = FindRoot(chain);\n+    root_cert = FindRoot(chain.get());\n     CHECK_NE(root_cert, nullptr);\n     root_name = X509_get_subject_name(root_cert);\n   }\n \n-  X509* leaf_cert = sk_X509_value(chain, 0);\n-  if (!CheckStartComOrWoSign(root_name, leaf_cert)) {\n-    sk_X509_pop_free(chain, X509_free);\n+  X509* leaf_cert = sk_X509_value(chain.get(), 0);\n+  if (!CheckStartComOrWoSign(root_name, leaf_cert))\n     return CHECK_CERT_REVOKED;\n-  }\n \n   // When the cert is issued from either CNNNIC ROOT CA or CNNNIC EV\n   // ROOT CA, check a hash of its leaf cert if it is in the whitelist.\n@@ -2990,13 +2983,10 @@ inline CheckResult CheckWhitelistedServerCert(X509_STORE_CTX* ctx) {\n     void* result = bsearch(hash, WhitelistedCNNICHashes,\n                            arraysize(WhitelistedCNNICHashes),\n                            CNNIC_WHITELIST_HASH_LEN, compar);\n-    if (result == nullptr) {\n-      sk_X509_pop_free(chain, X509_free);\n+    if (result == nullptr)\n       return CHECK_CERT_REVOKED;\n-    }\n   }\n \n-  sk_X509_pop_free(chain, X509_free);\n   return CHECK_OK;\n }\n "
        }
    ],
    "stats": {
        "total": 98,
        "additions": 44,
        "deletions": 54
    }
}