{
    "author": "codebytere",
    "message": "src: remove OCB support ifdef OPENSSL_NO_OCB\n\nElectron uses BoringSSL which does not support OCB . It is also\npossible to build OpenSSL without support for OCB for Node.js.\nThis commit disables OCB if OPENSSL_NO_OCB is defined.\n\nPR-URL: https://github.com/nodejs/node/pull/23635\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "ca2eec463974aff1a040329c0fc968ac903d03ba",
    "files": [
        {
            "sha": "088483686df0dce7f3b3f3e1094de506928fbd4a",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/ca2eec463974aff1a040329c0fc968ac903d03ba/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca2eec463974aff1a040329c0fc968ac903d03ba/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=ca2eec463974aff1a040329c0fc968ac903d03ba",
            "patch": "@@ -84,6 +84,11 @@ using v8::Uint32;\n using v8::Undefined;\n using v8::Value;\n \n+#ifdef OPENSSL_NO_OCB\n+# define IS_OCB_MODE(mode) false\n+#else\n+# define IS_OCB_MODE(mode) ((mode) == EVP_CIPH_OCB_MODE)\n+#endif\n \n struct StackOfX509Deleter {\n   void operator()(STACK_OF(X509)* p) const { sk_X509_pop_free(p, X509_free); }\n@@ -2544,7 +2549,7 @@ int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx) {\n static bool IsSupportedAuthenticatedMode(int mode) {\n   return mode == EVP_CIPH_CCM_MODE ||\n          mode == EVP_CIPH_GCM_MODE ||\n-         mode == EVP_CIPH_OCB_MODE;\n+         IS_OCB_MODE(mode);\n }\n \n void CipherBase::Initialize(Environment* env, Local<Object> target) {\n@@ -2769,7 +2774,7 @@ bool CipherBase::InitAuthenticated(const char* cipher_type, int iv_len,\n   }\n \n   const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n-  if (mode == EVP_CIPH_CCM_MODE || mode == EVP_CIPH_OCB_MODE) {\n+  if (mode == EVP_CIPH_CCM_MODE || IS_OCB_MODE(mode)) {\n     if (auth_tag_len == kNoAuthTagLength) {\n       char msg[128];\n       snprintf(msg, sizeof(msg), \"authTagLength required for %s\", cipher_type);\n@@ -2885,7 +2890,7 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n   } else {\n     // At this point, the tag length is already known and must match the\n     // length of the given authentication tag.\n-    CHECK(mode == EVP_CIPH_CCM_MODE || mode == EVP_CIPH_OCB_MODE);\n+    CHECK(mode == EVP_CIPH_CCM_MODE || IS_OCB_MODE(mode));\n     CHECK_NE(cipher->auth_tag_len_, kNoAuthTagLength);\n     is_valid = cipher->auth_tag_len_ == tag_len;\n   }"
        }
    ],
    "stats": {
        "total": 11,
        "additions": 8,
        "deletions": 3
    }
}