{
    "author": "mcollina",
    "message": "test,http: fix http dump test\n\nMake sure the dump test actually verify what is happening and it is\nnot flaky.\n\nSee: https://github.com/nodejs/node/issues/19139\nPR-URL: https://github.com/nodejs/node/pull/19823\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "1f29963eacf587817a6d40da527d05d151668198",
    "files": [
        {
            "sha": "cba70bd896058c4905d7def52e795c1c79420066",
            "filename": "lib/_http_server.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/1f29963eacf587817a6d40da527d05d151668198/lib%2F_http_server.js",
            "raw_url": "https://github.com/nodejs/node/raw/1f29963eacf587817a6d40da527d05d151668198/lib%2F_http_server.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_http_server.js?ref=1f29963eacf587817a6d40da527d05d151668198",
            "patch": "@@ -560,7 +560,7 @@ function resOnFinish(req, res, socket, state, server) {\n   // if the user never called req.read(), and didn't pipe() or\n   // .resume() or .on('data'), then we call req._dump() so that the\n   // bytes will be pulled off the wire.\n-  if (!req._consuming && !req._readableState.resumeScheduled)\n+  if (!req._readableState.resumeScheduled)\n     req._dump();\n \n   res.detachSocket(socket);"
        },
        {
            "sha": "e00f9c5fecee2500d82969683933f7b470078186",
            "filename": "test/sequential/test-http-dump-req-when-res-ends.js",
            "status": "modified",
            "additions": 39,
            "deletions": 21,
            "changes": 60,
            "blob_url": "https://github.com/nodejs/node/blob/1f29963eacf587817a6d40da527d05d151668198/test%2Fsequential%2Ftest-http-dump-req-when-res-ends.js",
            "raw_url": "https://github.com/nodejs/node/raw/1f29963eacf587817a6d40da527d05d151668198/test%2Fsequential%2Ftest-http-dump-req-when-res-ends.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-http-dump-req-when-res-ends.js?ref=1f29963eacf587817a6d40da527d05d151668198",
            "patch": "@@ -2,53 +2,71 @@\n \n const common = require('../common');\n const http = require('http');\n+const assert = require('assert');\n const fs = require('fs');\n \n-const server = http.createServer(function(req, res) {\n-  // this checks if the request gets dumped\n+let resEnd = null;\n+\n+const server = http.createServer(common.mustCall(function(req, res) {\n+  // This checks if the request gets dumped\n+  // resume will be triggered by res.end().\n   req.on('resume', common.mustCall(function() {\n-    console.log('resume called');\n+    // There is no 'data' event handler anymore\n+    // it gets automatically removed when dumping the request.\n+    assert.strictEqual(req.listenerCount('data'), 0);\n \n     req.on('data', common.mustCallAtLeast(function(d) {\n+      // Leaving the console.log explicitly, so that\n+      // we can know how many chunks we have received.\n       console.log('data', d);\n     }, 1));\n   }));\n \n-  // end is not called as we are just exhausting\n-  // the in-memory buffer\n-  req.on('end', common.mustNotCall);\n-\n-  // this 'data' handler will be removed when dumped\n-  req.on('data', common.mustNotCall);\n+  // We explicitly pause the stream\n+  // so that the following on('data') does not cause\n+  // a resume.\n+  req.pause();\n+  req.on('data', function() {});\n \n-  // start sending the response\n+  // Start sending the response.\n   res.flushHeaders();\n \n-  setTimeout(function() {\n-    res.end('hello world');\n-  }, common.platformTimeout(100));\n-});\n+  resEnd = function() {\n+    setImmediate(function() {\n+      res.end('hello world');\n+    });\n+  };\n+}));\n \n-server.listen(0, function() {\n+server.listen(0, common.mustCall(function() {\n   const req = http.request({\n     method: 'POST',\n     port: server.address().port\n   });\n \n   // Send the http request without waiting\n-  // for the body\n+  // for the body.\n   req.flushHeaders();\n \n   req.on('response', common.mustCall(function(res) {\n-    // pipe the body as soon as we get the headers of the\n-    // response back\n-    fs.createReadStream(__filename).pipe(req);\n+    // Pipe the body as soon as we get the headers of the\n+    // response back.\n+    const readFileStream = fs.createReadStream(__filename);\n+    readFileStream.on('end', resEnd);\n+\n+    readFileStream.pipe(req);\n \n     res.resume();\n \n-    // wait for the response\n+    // Wait for the response.\n     res.on('end', function() {\n       server.close();\n     });\n   }));\n-});\n+\n+  req.on('error', function() {\n+    // An error can happen if there is some data still\n+    // being sent, as the other side is calling .destroy()\n+    // this is safe to ignore.\n+  });\n+}));"
        }
    ],
    "stats": {
        "total": 62,
        "additions": 40,
        "deletions": 22
    }
}