{
    "author": "refack",
    "message": "src,win: informative stack traces\n\nRefresh `Win32SymbolDebuggingContext::LookupSymbol` to use more APIs\n\nPR-URL: https://github.com/nodejs/node/pull/23822\nRefs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address\nRefs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-undecorated-symbol-names\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>",
    "sha": "247b513059592cbfe9ec3012aa9bc461b9899c7f",
    "files": [
        {
            "sha": "77ea219bfc880a19961b3cf22010ac6182c10b3c",
            "filename": "src/debug_utils.cc",
            "status": "modified",
            "additions": 110,
            "deletions": 29,
            "changes": 139,
            "blob_url": "https://github.com/nodejs/node/blob/247b513059592cbfe9ec3012aa9bc461b9899c7f/src%2Fdebug_utils.cc",
            "raw_url": "https://github.com/nodejs/node/raw/247b513059592cbfe9ec3012aa9bc461b9899c7f/src%2Fdebug_utils.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fdebug_utils.cc?ref=247b513059592cbfe9ec3012aa9bc461b9899c7f",
            "patch": "@@ -100,35 +100,104 @@ class Win32SymbolDebuggingContext final : public NativeSymbolDebuggingContext {\n     USE(SymInitialize(current_process_, nullptr, true));\n   }\n \n-  ~Win32SymbolDebuggingContext() {\n+  ~Win32SymbolDebuggingContext() override {\n     USE(SymCleanup(current_process_));\n   }\n \n-  SymbolInfo LookupSymbol(void* address) override {\n-    // Ref: https://msdn.microsoft.com/en-en/library/windows/desktop/ms680578(v=vs.85).aspx\n-    char info_buf[sizeof(SYMBOL_INFO) + MAX_SYM_NAME];\n-    SYMBOL_INFO* info = reinterpret_cast<SYMBOL_INFO*>(info_buf);\n-    char demangled[MAX_SYM_NAME];\n+  using NameAndDisplacement = std::pair<std::string, DWORD64>;\n+  NameAndDisplacement WrappedSymFromAddr(DWORD64 dwAddress) const {\n+    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address\n+    // Patches:\n+    // Use `fprintf(stderr, ` instead of `printf`\n+    // `sym.filename = pSymbol->Name` on success\n+    // `current_process_` instead of `hProcess.\n+    DWORD64 dwDisplacement = 0;\n+    // Patch: made into arg - DWORD64  dwAddress = SOME_ADDRESS;\n+\n+    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];\n+    const auto pSymbol = reinterpret_cast<PSYMBOL_INFO>(buffer);\n+\n+    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);\n+    pSymbol->MaxNameLen = MAX_SYM_NAME;\n+\n+    if (SymFromAddr(current_process_, dwAddress, &dwDisplacement, pSymbol)) {\n+      // SymFromAddr returned success\n+      return NameAndDisplacement(pSymbol->Name, dwDisplacement);\n+    } else {\n+      // SymFromAddr failed\n+      const DWORD error = GetLastError();  // \"eat\" the error anyway\n+#ifdef DEBUG\n+      fprintf(stderr, \"SymFromAddr returned error : %lu\\n\", error);\n+#endif\n+    }\n+    // End MSDN code\n \n-    info->MaxNameLen = MAX_SYM_NAME;\n-    info->SizeOfStruct = sizeof(SYMBOL_INFO);\n+    return NameAndDisplacement();\n+  }\n \n-    SymbolInfo ret;\n-    const bool have_info = SymFromAddr(current_process_,\n-                                       reinterpret_cast<DWORD64>(address),\n-                                       nullptr,\n-                                       info);\n-    if (have_info && strlen(info->Name) == 0) {\n-      if (UnDecorateSymbolName(info->Name,\n-                               demangled,\n-                               sizeof(demangled),\n-                               UNDNAME_COMPLETE)) {\n-        ret.name = demangled;\n-      } else {\n-        ret.name = info->Name;\n-      }\n+  SymbolInfo WrappedGetLine(DWORD64 dwAddress) const {\n+    SymbolInfo sym{};\n+\n+    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address\n+    // Patches:\n+    // Use `fprintf(stderr, ` instead of `printf`.\n+    // Assign values to `sym` on success.\n+    // `current_process_` instead of `hProcess.\n+\n+    // Patch: made into arg - DWORD64  dwAddress;\n+    DWORD dwDisplacement;\n+    IMAGEHLP_LINE64 line;\n+\n+    SymSetOptions(SYMOPT_LOAD_LINES);\n+\n+    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);\n+    // Patch: made into arg - dwAddress = 0x1000000;\n+\n+    if (SymGetLineFromAddr64(current_process_, dwAddress,\n+                             &dwDisplacement, &line)) {\n+      // SymGetLineFromAddr64 returned success\n+      sym.filename = line.FileName;\n+      sym.line = line.LineNumber;\n+    } else {\n+      // SymGetLineFromAddr64 failed\n+      const DWORD error = GetLastError();  // \"eat\" the error anyway\n+#ifdef DEBUG\n+      fprintf(stderr, \"SymGetLineFromAddr64 returned error : %lu\\n\", error);\n+#endif\n+    }\n+    // End MSDN code\n+\n+    return sym;\n+  }\n+\n+  // Fills the SymbolInfo::name of the io/out argument `sym`\n+  std::string WrappedUnDecorateSymbolName(const char* name) const {\n+    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-undecorated-symbol-names\n+    // Patches:\n+    // Use `fprintf(stderr, ` instead of `printf`.\n+    // return `szUndName` instead of `printf` on success\n+    char szUndName[MAX_SYM_NAME];\n+    if (UnDecorateSymbolName(name, szUndName, sizeof(szUndName),\n+                             UNDNAME_COMPLETE)) {\n+      // UnDecorateSymbolName returned success\n+      return szUndName;\n+    } else {\n+      // UnDecorateSymbolName failed\n+      const DWORD error = GetLastError();  // \"eat\" the error anyway\n+#ifdef DEBUG\n+      fprintf(stderr, \"UnDecorateSymbolName returned error %lu\\n\", error);\n+#endif\n     }\n+    return nullptr;\n+  }\n \n+  SymbolInfo LookupSymbol(void* address) override {\n+    const DWORD64 dw_address = reinterpret_cast<DWORD64>(address);\n+    SymbolInfo ret = WrappedGetLine(dw_address);\n+    std::tie(ret.name, ret.dis) = WrappedSymFromAddr(dw_address);\n+    if (!ret.name.empty()) {\n+      ret.name = WrappedUnDecorateSymbolName(ret.name.c_str());\n+    }\n     return ret;\n   }\n \n@@ -145,6 +214,13 @@ class Win32SymbolDebuggingContext final : public NativeSymbolDebuggingContext {\n     return CaptureStackBackTrace(0, count, frames, nullptr);\n   }\n \n+  Win32SymbolDebuggingContext(const Win32SymbolDebuggingContext&) = delete;\n+  Win32SymbolDebuggingContext(Win32SymbolDebuggingContext&&) = delete;\n+  Win32SymbolDebuggingContext operator=(const Win32SymbolDebuggingContext&)\n+    = delete;\n+  Win32SymbolDebuggingContext operator=(Win32SymbolDebuggingContext&&)\n+    = delete;\n+\n  private:\n   HANDLE current_process_;\n };\n@@ -158,13 +234,18 @@ NativeSymbolDebuggingContext::New() {\n #endif  // __POSIX__\n \n std::string NativeSymbolDebuggingContext::SymbolInfo::Display() const {\n-  std::string ret = name;\n+  std::ostringstream oss;\n+  oss << name;\n+  if (dis != 0) {\n+    oss << \"+\" << dis;\n+  }\n   if (!filename.empty()) {\n-    ret += \" [\";\n-    ret += filename;\n-    ret += ']';\n+    oss << \" [\" << filename << ']';\n+  }\n+  if (line != 0) {\n+    oss << \":L\" << line;\n   }\n-  return ret;\n+  return oss.str();\n }\n \n void DumpBacktrace(FILE* fp) {\n@@ -173,8 +254,8 @@ void DumpBacktrace(FILE* fp) {\n   const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));\n   for (int i = 1; i < size; i += 1) {\n     void* frame = frames[i];\n-    fprintf(fp, \"%2d: %p %s\\n\",\n-            i, frame, sym_ctx->LookupSymbol(frame).Display().c_str());\n+    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);\n+    fprintf(fp, \"%2d: %p %s\\n\", i, frame, s.Display().c_str());\n   }\n }\n "
        },
        {
            "sha": "c6c8e03b51fd643c8c79eed6987b65c9301d18d0",
            "filename": "src/debug_utils.h",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/247b513059592cbfe9ec3012aa9bc461b9899c7f/src%2Fdebug_utils.h",
            "raw_url": "https://github.com/nodejs/node/raw/247b513059592cbfe9ec3012aa9bc461b9899c7f/src%2Fdebug_utils.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fdebug_utils.h?ref=247b513059592cbfe9ec3012aa9bc461b9899c7f",
            "patch": "@@ -6,6 +6,7 @@\n #include \"async_wrap.h\"\n #include \"env.h\"\n #include <string>\n+#include <sstream>\n \n // Use FORCE_INLINE on functions that have a debug-category-enabled check first\n // and then ideally only a single function call following it, to maintain\n@@ -93,14 +94,25 @@ class NativeSymbolDebuggingContext {\n    public:\n     std::string name;\n     std::string filename;\n+    size_t line = 0;\n+    size_t dis = 0;\n \n     std::string Display() const;\n   };\n \n+  NativeSymbolDebuggingContext() = default;\n   virtual ~NativeSymbolDebuggingContext() {}\n-  virtual SymbolInfo LookupSymbol(void* address) { return { \"\", \"\" }; }\n+\n+  virtual SymbolInfo LookupSymbol(void* address) { return {}; }\n   virtual bool IsMapped(void* address) { return false; }\n   virtual int GetStackTrace(void** frames, int count) { return 0; }\n+\n+  NativeSymbolDebuggingContext(const NativeSymbolDebuggingContext&) = delete;\n+  NativeSymbolDebuggingContext(NativeSymbolDebuggingContext&&) = delete;\n+  NativeSymbolDebuggingContext operator=(NativeSymbolDebuggingContext&)\n+    = delete;\n+  NativeSymbolDebuggingContext operator=(NativeSymbolDebuggingContext&&)\n+    = delete;\n };\n \n // Variant of `uv_loop_close` that tries to be as helpful as possible"
        }
    ],
    "stats": {
        "total": 153,
        "additions": 123,
        "deletions": 30
    }
}