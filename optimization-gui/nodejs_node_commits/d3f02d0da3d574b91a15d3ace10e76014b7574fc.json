{
    "author": "addaleax",
    "message": "stream: make `.destroy()` interact better with write queue\n\nMake sure that it is safe to call the callback for `_write()`\neven in the presence of `.destroy()` calls during that write.\n\nIn particular, letting the write queue continue processing would\npreviously have thrown an exception, because processing writes\nafter calling `.destroy()` is forbidden.\n\nOne test had to be modified to account for the fact that callbacks\nfor writes will now always be called, even when the stream\nis destroyed during the process.\n\nPR-URL: https://github.com/nodejs/node/pull/24062\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "d3f02d0da3d574b91a15d3ace10e76014b7574fc",
    "files": [
        {
            "sha": "d62c95ad800567f241d400f74dedec4a40bcdb9b",
            "filename": "lib/_stream_writable.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d3f02d0da3d574b91a15d3ace10e76014b7574fc/lib%2F_stream_writable.js",
            "raw_url": "https://github.com/nodejs/node/raw/d3f02d0da3d574b91a15d3ace10e76014b7574fc/lib%2F_stream_writable.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_stream_writable.js?ref=d3f02d0da3d574b91a15d3ace10e76014b7574fc",
            "patch": "@@ -461,7 +461,7 @@ function onwrite(stream, er) {\n     onwriteError(stream, state, sync, er, cb);\n   else {\n     // Check if we're actually ready to finish, but don't emit yet\n-    var finished = needFinish(state);\n+    var finished = needFinish(state) || stream.destroyed;\n \n     if (!finished &&\n         !state.corked &&"
        },
        {
            "sha": "83b329a6a8a7b3dcd57287b9bb748d5bf97077c7",
            "filename": "test/parallel/test-stream-write-destroy.js",
            "status": "added",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/d3f02d0da3d574b91a15d3ace10e76014b7574fc/test%2Fparallel%2Ftest-stream-write-destroy.js",
            "raw_url": "https://github.com/nodejs/node/raw/d3f02d0da3d574b91a15d3ace10e76014b7574fc/test%2Fparallel%2Ftest-stream-write-destroy.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream-write-destroy.js?ref=d3f02d0da3d574b91a15d3ace10e76014b7574fc",
            "patch": "@@ -0,0 +1,59 @@\n+'use strict';\n+require('../common');\n+const assert = require('assert');\n+const { Writable } = require('stream');\n+\n+// Test interaction between calling .destroy() on a writable and pending\n+// writes.\n+\n+for (const withPendingData of [ false, true ]) {\n+  for (const useEnd of [ false, true ]) {\n+    const callbacks = [];\n+\n+    const w = new Writable({\n+      write(data, enc, cb) {\n+        callbacks.push(cb);\n+      },\n+      // Effectively disable the HWM to observe 'drain' events more easily.\n+      highWaterMark: 1\n+    });\n+\n+    let chunksWritten = 0;\n+    let drains = 0;\n+    let finished = false;\n+    w.on('drain', () => drains++);\n+    w.on('finish', () => finished = true);\n+\n+    w.write('abc', () => chunksWritten++);\n+    assert.strictEqual(chunksWritten, 0);\n+    assert.strictEqual(drains, 0);\n+    callbacks.shift()();\n+    assert.strictEqual(chunksWritten, 1);\n+    assert.strictEqual(drains, 1);\n+\n+    if (withPendingData) {\n+      // Test 2 cases: There either is or is not data still in the write queue.\n+      // (The second write will never actually get executed either way.)\n+      w.write('def', () => chunksWritten++);\n+    }\n+    if (useEnd) {\n+      // Again, test 2 cases: Either we indicate that we want to end the\n+      // writable or not.\n+      w.end('ghi', () => chunksWritten++);\n+    } else {\n+      w.write('ghi', () => chunksWritten++);\n+    }\n+\n+    assert.strictEqual(chunksWritten, 1);\n+    w.destroy();\n+    assert.strictEqual(chunksWritten, 1);\n+    callbacks.shift()();\n+    assert.strictEqual(chunksWritten, 2);\n+    assert.strictEqual(callbacks.length, 0);\n+    assert.strictEqual(drains, 1);\n+\n+    // When we used `.end()`, we see the 'finished' event if and only if\n+    // we actually finished processing the write queue.\n+    assert.strictEqual(finished, !withPendingData && useEnd);\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 61,
        "additions": 60,
        "deletions": 1
    }
}